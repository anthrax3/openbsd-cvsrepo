head	1.76;
access;
symbols
	OPENBSD_6_2_BASE:1.76
	OPENBSD_6_1:1.74.0.4
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.66.0.4
	OPENBSD_6_0_BASE:1.66
	OPENBSD_5_9:1.66.0.2
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.60.0.4
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.59.0.2
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.49.0.4
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.43.0.2
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.40.0.2
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.35.0.2
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.2
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18;
locks; strict;
comment	@ * @;


1.76
date	2017.07.28.13.17.43;	author florian;	state Exp;
branches;
next	1.75;
commitid	4trFHiOymRpBpy70;

1.75
date	2017.04.21.13.50.23;	author jca;	state Exp;
branches;
next	1.74;
commitid	0khcEEJIl2QP335t;

1.74
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.73;
commitid	eA8b246voAapPTkX;

1.73
date	2016.11.18.16.16.39;	author jca;	state Exp;
branches;
next	1.72;
commitid	5lrkdv6CJEuqxjzU;

1.72
date	2016.11.09.20.31.56;	author jca;	state Exp;
branches;
next	1.71;
commitid	W7m2j1sZd5b467J6;

1.71
date	2016.10.28.09.07.08;	author rzalamena;	state Exp;
branches;
next	1.70;
commitid	Uh6U1yLTyYRsvccR;

1.70
date	2016.10.28.08.01.53;	author rzalamena;	state Exp;
branches;
next	1.69;
commitid	SMslalgbhOIf4OXA;

1.69
date	2016.10.03.12.16.41;	author dlg;	state Exp;
branches;
next	1.68;
commitid	ZuUV3E8ce9OKqber;

1.68
date	2016.09.25.14.58.00;	author fcambus;	state Exp;
branches;
next	1.67;
commitid	EigQrdBOHNJWegdi;

1.67
date	2016.08.16.18.41.57;	author tedu;	state Exp;
branches;
next	1.66;
commitid	eyeRGwF24702KeRh;

1.66
date	2015.12.07.12.33.08;	author reyk;	state Exp;
branches;
next	1.65;
commitid	CRYSGrkpOiXC6mfK;

1.65
date	2015.11.23.19.31.52;	author reyk;	state Exp;
branches;
next	1.64;
commitid	7cxebI3ghebF4Szu;

1.64
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.63;
commitid	T3JBYxNT0thPuavp;

1.63
date	2015.11.21.13.06.22;	author reyk;	state Exp;
branches;
next	1.62;
commitid	TRmhct846bt43J7w;

1.62
date	2015.10.08.08.17.30;	author sthen;	state Exp;
branches;
next	1.61;
commitid	zteDEVyy8dewN13K;

1.61
date	2015.10.05.15.29.14;	author uebayasi;	state Exp;
branches;
next	1.60;
commitid	8fzumuBgZ88G39PA;

1.60
date	2015.06.11.18.49.09;	author reyk;	state Exp;
branches;
next	1.59;
commitid	r36j1ZCD0yPK3S9O;

1.59
date	2015.01.16.00.05.13;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	khLbW7SmDyckNaAs;

1.58
date	2014.11.19.10.19.00;	author blambert;	state Exp;
branches;
next	1.57;
commitid	cXioMeUnRYhFJvcH;

1.57
date	2014.11.16.19.07.51;	author bluhm;	state Exp;
branches;
next	1.56;
commitid	ohVlnYugDUFcNu2w;

1.56
date	2014.08.18.13.13.42;	author reyk;	state Exp;
branches;
next	1.55;
commitid	SoP35sFKzkBxNqzm;

1.55
date	2014.05.14.09.42.22;	author mikeb;	state Exp;
branches;
next	1.54;

1.54
date	2014.04.28.12.03.32;	author mikeb;	state Exp;
branches;
next	1.53;

1.53
date	2014.04.28.08.25.05;	author blambert;	state Exp;
branches;
next	1.52;

1.52
date	2014.04.25.06.57.11;	author blambert;	state Exp;
branches;
next	1.51;

1.51
date	2014.04.21.19.47.27;	author reyk;	state Exp;
branches;
next	1.50;

1.50
date	2014.04.14.12.55.10;	author blambert;	state Exp;
branches;
next	1.49;

1.49
date	2014.02.14.10.38.09;	author florian;	state Exp;
branches;
next	1.48;

1.48
date	2013.11.21.17.32.13;	author mikeb;	state Exp;
branches;
next	1.47;

1.47
date	2013.10.17.08.42.44;	author reyk;	state Exp;
branches;
next	1.46;

1.46
date	2013.10.16.16.05.03;	author blambert;	state Exp;
branches;
next	1.45;

1.45
date	2013.10.01.12.41.47;	author reyk;	state Exp;
branches;
next	1.44;

1.44
date	2013.09.26.09.11.30;	author reyk;	state Exp;
branches;
next	1.43;

1.43
date	2013.03.29.12.53.41;	author gerhard;	state Exp;
branches;
next	1.42;

1.42
date	2013.03.06.21.42.40;	author sthen;	state Exp;
branches;
next	1.41;

1.41
date	2013.03.04.14.00.31;	author bluhm;	state Exp;
branches;
next	1.40;

1.40
date	2013.01.24.09.30.27;	author gerhard;	state Exp;
branches;
next	1.39;

1.39
date	2012.10.01.11.36.55;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2012.09.18.08.29.09;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2012.09.17.16.43.59;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2012.09.17.16.30.35;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2012.05.28.20.55.40;	author joel;	state Exp;
branches;
next	1.34;

1.34
date	2012.04.08.02.57.40;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2012.02.23.03.54.38;	author joel;	state Exp;
branches;
next	1.32;

1.32
date	2012.02.01.18.44.06;	author camield;	state Exp;
branches;
next	1.31;

1.31
date	2011.04.21.14.55.22;	author sthen;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.20.08.56.16;	author martinh;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.11.10.45.36;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2010.04.01.14.42.32;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2010.03.31.09.20.23;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2010.03.29.14.52.49;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.06.18.38.01;	author pyr;	state Exp;
branches;
next	1.24;

1.24
date	2009.06.06.05.52.01;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2008.12.23.08.06.10;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.08.11.34.55;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2008.09.26.15.19.55;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2008.07.18.12.30.06;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.29.16.00.22;	author ragge;	state Exp;
branches;
next	1.18;

1.18
date	2008.02.07.11.33.26;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.18.02.09.30;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2008.01.17.17.35.06;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.16.21.43.19;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.16.19.36.06;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.16.09.51.15;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.16.09.42.29;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.16.09.36.30;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.03.15.03.47;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.02.20.54.59;	author maja;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.29.09.24.43;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.12.28.16.59.31;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.12.28.16.27.51;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.28.15.32.02;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.15.04.15.12;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.07.09.50.51;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.05.22.52.50;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.05.09.22.44;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.76
log
@Make the engine id is just binary data so make it uint8_t.
clang pointed out that we tried to store 128 in a signed char.
OK gerhard
@
text
@/*	$OpenBSD: snmpd.h,v 1.75 2017/04/21 13:50:23 jca Exp $	*/

/*
 * Copyright (c) 2007, 2008, 2012 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef SNMPD_H
#define SNMPD_H

#include <sys/tree.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <net/pfvar.h>
#include <net/route.h>

#include <stdio.h>
#include <imsg.h>

#include "ber.h"
#include "snmp.h"

#ifndef nitems
#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))
#endif

/*
 * common definitions for snmpd
 */

#define CONF_FILE		"/etc/snmpd.conf"
#define SNMPD_SOCKET		"/var/run/snmpd.sock"
#define SNMPD_USER		"_snmpd"
#define SNMPD_PORT		161
#define SNMPD_TRAPPORT		162

#define SNMPD_MAXSTRLEN		484
#define SNMPD_MAXCOMMUNITYLEN	SNMPD_MAXSTRLEN
#define SNMPD_MAXVARBIND	0x7fffffff
#define SNMPD_MAXVARBINDLEN	1210
#define SNMPD_MAXENGINEIDLEN	32
#define SNMPD_MAXUSERNAMELEN	32
#define SNMPD_MAXCONTEXNAMELEN	32

#define SNMP_USM_DIGESTLEN	12
#define SNMP_USM_SALTLEN	8
#define SNMP_USM_KEYLEN		64
#define SNMP_CIPHER_KEYLEN	16

#define SMALL_READ_BUF_SIZE	1024
#define READ_BUF_SIZE		65535
#define	RT_BUF_SIZE		16384
#define	MAX_RTSOCK_BUF		(128 * 1024)

#define SNMP_ENGINEID_OLD	0x00
#define SNMP_ENGINEID_NEW	0x80	/* RFC3411 */

#define SNMP_ENGINEID_FMT_IPv4	1
#define SNMP_ENGINEID_FMT_IPv6	2
#define SNMP_ENGINEID_FMT_MAC	3
#define SNMP_ENGINEID_FMT_TEXT	4
#define SNMP_ENGINEID_FMT_OCT	5
#define SNMP_ENGINEID_FMT_EID	128

enum imsg_type {
	IMSG_NONE,
	IMSG_CTL_OK,		/* answer to snmpctl requests */
	IMSG_CTL_FAIL,
	IMSG_CTL_END,
	IMSG_CTL_NOTIFY,
	IMSG_CTL_VERBOSE,
	IMSG_CTL_RELOAD,
	IMSG_CTL_PROCFD,
	IMSG_ALERT
};

struct imsgev {
	struct imsgbuf		 ibuf;
	void			(*handler)(int, short, void *);
	struct event		 ev;
	struct privsep_proc	*proc;
	void			*data;
	short			 events;
	const char		*name;
};

#define IMSG_SIZE_CHECK(imsg, p) do {				\
	if (IMSG_DATA_SIZE(imsg) < sizeof(*p))			\
		fatalx("bad length imsg received");		\
} while (0)
#define IMSG_DATA_SIZE(imsg)	((imsg)->hdr.len - IMSG_HEADER_SIZE)

/* initially control.h */
struct control_sock {
	const char	*cs_name;
	struct event	 cs_ev;
	struct event	 cs_evt;
	int		 cs_fd;
	int		 cs_restricted;
	int		 cs_agentx;
	void		*cs_env;

	TAILQ_ENTRY(control_sock) cs_entry;
};
TAILQ_HEAD(control_socks, control_sock);

enum privsep_procid {
	PROC_PARENT,	/* Parent process and application interface */
	PROC_SNMPE,	/* SNMP engine */
	PROC_TRAP,	/* SNMP trap receiver */
	PROC_MAX
};

enum privsep_procid privsep_process;

/* Attach the control socket to the following process */
#define PROC_CONTROL	PROC_SNMPE

struct privsep_pipes {
	int			*pp_pipes[PROC_MAX];
};

struct privsep {
	struct privsep_pipes	*ps_pipes[PROC_MAX];
	struct privsep_pipes	*ps_pp;

	struct imsgev		*ps_ievs[PROC_MAX];
	const char		*ps_title[PROC_MAX];
	pid_t			 ps_pid[PROC_MAX];
	struct passwd		*ps_pw;

	u_int			 ps_instances[PROC_MAX];
	u_int			 ps_instance;
	int			 ps_noaction;

	struct control_sock	 ps_csock;
	struct control_socks	 ps_rcsocks;

	/* Event and signal handlers */
	struct event		 ps_evsigint;
	struct event		 ps_evsigterm;
	struct event		 ps_evsigchld;
	struct event		 ps_evsighup;
	struct event		 ps_evsigpipe;
	struct event		 ps_evsigusr1;

	void			*ps_env;
};

struct privsep_proc {
	const char		*p_title;
	enum privsep_procid	 p_id;
	int			(*p_cb)(int, struct privsep_proc *,
				    struct imsg *);
	void			(*p_init)(struct privsep *,
				    struct privsep_proc *);
	void			(*p_shutdown)(void);
	const char		*p_chroot;
	struct privsep		*p_ps;
	struct passwd		*p_pw;
};

struct privsep_fd {
	enum privsep_procid		 pf_procid;
	unsigned int			 pf_instance;
};

#define PROC_PARENT_SOCK_FILENO	3
#define PROC_MAX_INSTANCES	32

#if DEBUG
#define DPRINTF		log_debug
#else
#define DPRINTF(x...)	do {} while(0)
#endif

/*
 * kroute
 */

struct kroute_node;
struct kroute6_node;
RB_HEAD(kroute_tree, kroute_node);
RB_HEAD(kroute6_tree, kroute6_node);

struct ktable {
	struct kroute_tree	 krt;
	struct kroute6_tree	 krt6;
	u_int			 rtableid;
	u_int			 rdomain;
};

union kaddr {
	struct sockaddr		sa;
	struct sockaddr_in	sin;
	struct sockaddr_in6	sin6;
	struct sockaddr_dl	sdl;
	char			pad[32];
};

struct kroute {
	struct in_addr	prefix;
	struct in_addr	nexthop;
	u_long		ticks;
	u_int16_t	flags;
	u_short		if_index;
	u_int8_t	prefixlen;
	u_int8_t	priority;
};

struct kroute6 {
	struct in6_addr	prefix;
	struct in6_addr	nexthop;
	u_long		ticks;
	u_int16_t	flags;
	u_short		if_index;
	u_int8_t	prefixlen;
	u_int8_t	priority;
};

struct kif_addr {
	u_short			 if_index;
	union kaddr		 addr;
	union kaddr		 mask;
	union kaddr		 dstbrd;

	TAILQ_ENTRY(kif_addr)	 entry;
	RB_ENTRY(kif_addr)	 node;
};

struct kif_arp {
	u_short			 flags;
	u_short			 if_index;
	union kaddr		 addr;
	union kaddr		 target;

	TAILQ_ENTRY(kif_arp)	 entry;
};

struct kif {
	char			 if_name[IF_NAMESIZE];
	char			 if_descr[IFDESCRSIZE];
	u_int8_t		 if_lladdr[ETHER_ADDR_LEN];
	struct if_data		 if_data;
	u_long			 if_ticks;
	int			 if_flags;
	u_short			 if_index;
};
#define	if_mtu		if_data.ifi_mtu
#define	if_type		if_data.ifi_type
#define	if_addrlen	if_data.ifi_addrlen
#define	if_hdrlen	if_data.ifi_hdrlen
#define	if_metric	if_data.ifi_metric
#define	if_link_state	if_data.ifi_link_state
#define	if_baudrate	if_data.ifi_baudrate
#define	if_ipackets	if_data.ifi_ipackets
#define	if_ierrors	if_data.ifi_ierrors
#define	if_opackets	if_data.ifi_opackets
#define	if_oerrors	if_data.ifi_oerrors
#define	if_collisions	if_data.ifi_collisions
#define	if_ibytes	if_data.ifi_ibytes
#define	if_obytes	if_data.ifi_obytes
#define	if_imcasts	if_data.ifi_imcasts
#define	if_omcasts	if_data.ifi_omcasts
#define	if_iqdrops	if_data.ifi_iqdrops
#define	if_oqdrops	if_data.ifi_oqdrops
#define	if_noproto	if_data.ifi_noproto
#define	if_lastchange	if_data.ifi_lastchange
#define	if_capabilities	if_data.ifi_capabilities

#define F_CONNECTED		0x0001
#define F_STATIC		0x0002
#define F_BLACKHOLE		0x0004
#define F_REJECT		0x0008
#define F_DYNAMIC		0x0010

/*
 * Message Processing Subsystem (mps)
 */

struct oid {
	struct ber_oid		 o_id;
#define o_oid			 o_id.bo_id
#define o_oidlen		 o_id.bo_n

	char			*o_name;

	u_int			 o_flags;

	int			 (*o_get)(struct oid *, struct ber_oid *,
				    struct ber_element **);
	int			 (*o_set)(struct oid *, struct ber_oid *,
				    struct ber_element **);
	struct ber_oid		*(*o_table)(struct oid *, struct ber_oid *,
				    struct ber_oid *);

	long long		 o_val;
	void			*o_data;

	struct ctl_conn		*o_session;

	RB_ENTRY(oid)		 o_element;
	RB_ENTRY(oid)		 o_keyword;
	TAILQ_ENTRY(oid)	 o_list;
};
TAILQ_HEAD(oidlist, oid);

#define OID_ROOT		0x00
#define OID_RD			0x01
#define OID_WR			0x02
#define OID_IFSET		0x04	/* only if user-specified value */
#define OID_DYNAMIC		0x08	/* free allocated data */
#define OID_TABLE		0x10	/* dynamic sub-elements */
#define OID_MIB			0x20	/* root-OID of a supported MIB */
#define OID_KEY			0x40	/* lookup tables */
#define	OID_REGISTERED		0x80	/* OID registered by subagent */

#define OID_RS			(OID_RD|OID_IFSET)
#define OID_WS			(OID_WR|OID_IFSET)
#define OID_RW			(OID_RD|OID_WR)
#define OID_RWS			(OID_RW|OID_IFSET)

#define OID_TRD			(OID_RD|OID_TABLE)
#define OID_TWR			(OID_WR|OID_TABLE)
#define OID_TRS			(OID_RD|OID_IFSET|OID_TABLE)
#define OID_TWS			(OID_WR|OID_IFSET|OID_TABLE)
#define OID_TRW			(OID_RD|OID_WR|OID_TABLE)
#define OID_TRWS		(OID_RW|OID_IFSET|OID_TABLE)

#define OID_NOTSET(_oid)						\
	(((_oid)->o_flags & OID_IFSET) &&				\
	((_oid)->o_data == NULL) && ((_oid)->o_val == 0))

#define OID(...)		{ { __VA_ARGS__ } }
#define MIBDECL(...)		{ { MIB_##__VA_ARGS__ } }, #__VA_ARGS__
#define MIB(...)		{ { MIB_##__VA_ARGS__ } }, NULL
#define MIBEND			{ { 0 } }, NULL

struct ctl_conn {
	TAILQ_ENTRY(ctl_conn)	 entry;
	u_int8_t		 flags;
#define CTL_CONN_NOTIFY		 0x01
#define CTL_CONN_LOCKED		 0x02	/* restricted mode */
	struct imsgev		 iev;
	struct control_sock	*cs;
	struct agentx_handle	*handle;
	struct oidlist		 oids;
};
TAILQ_HEAD(ctl_connlist, ctl_conn);
extern  struct ctl_connlist ctl_conns;

/*
 * pf
 */

enum {	PFRB_TABLES = 1, PFRB_TSTATS, PFRB_ADDRS, PFRB_ASTATS,
	PFRB_IFACES, PFRB_TRANS, PFRB_MAX };

enum {  IN, OUT };
enum {  IPV4, IPV6 };
enum {  PASS, BLOCK };

enum {  PFI_IFTYPE_GROUP, PFI_IFTYPE_INSTANCE };

struct pfr_buffer {
	int	 pfrb_type;	/* type of content, see enum above */
	int	 pfrb_size;	/* number of objects in buffer */
	int	 pfrb_msize;	/* maximum number of objects in buffer */
	void	*pfrb_caddr;	/* malloc'ated memory area */
};

#define PFRB_FOREACH(var, buf)				\
	for ((var) = pfr_buf_next((buf), NULL);		\
	    (var) != NULL;				\
	    (var) = pfr_buf_next((buf), (var)))

/*
 * daemon structures
 */

#define MSG_HAS_AUTH(m)		(((m)->sm_flags & SNMP_MSGFLAG_AUTH) != 0)
#define MSG_HAS_PRIV(m)		(((m)->sm_flags & SNMP_MSGFLAG_PRIV) != 0)
#define MSG_SECLEVEL(m)		((m)->sm_flags & SNMP_MSGFLAG_SECMASK)
#define MSG_REPORT(m)		(((m)->sm_flags & SNMP_MSGFLAG_REPORT) != 0)

struct snmp_message {
	int			 sm_sock;
	struct sockaddr_storage	 sm_ss;
	socklen_t		 sm_slen;
	char			 sm_host[HOST_NAME_MAX+1];

	struct sockaddr_storage	 sm_local_ss;
	socklen_t		 sm_local_slen;

	struct ber		 sm_ber;
	struct ber_element	*sm_req;
	struct ber_element	*sm_resp;

	int			 sm_i;
	struct ber_element	*sm_a;
	struct ber_element	*sm_b;
	struct ber_element	*sm_c;
	struct ber_element	*sm_next;
	struct ber_element	*sm_last;
	struct ber_element	*sm_end;

	u_int8_t		 sm_data[READ_BUF_SIZE];
	size_t			 sm_datalen;

	u_int			 sm_version;
	u_int			 sm_state;

	/* V1, V2c */
	char			 sm_community[SNMPD_MAXCOMMUNITYLEN];
	int			 sm_context;

	/* V3 */
	long long		 sm_msgid;
	long long		 sm_max_msg_size;
	u_int8_t		 sm_flags;
	long long		 sm_secmodel;
	u_int32_t		 sm_engine_boots;
	u_int32_t		 sm_engine_time;
	uint8_t			 sm_ctxengineid[SNMPD_MAXENGINEIDLEN];
	size_t			 sm_ctxengineid_len;
	char			 sm_ctxname[SNMPD_MAXCONTEXNAMELEN+1];

	/* USM */
	char			 sm_username[SNMPD_MAXUSERNAMELEN+1];
	struct usmuser		*sm_user;
	size_t			 sm_digest_offs;
	char			 sm_salt[SNMP_USM_SALTLEN];
	int			 sm_usmerr;

	long long		 sm_request;

	const char		*sm_errstr;
	long long		 sm_error;
#define sm_nonrepeaters		 sm_error
	long long		 sm_errorindex;
#define sm_maxrepetitions	 sm_errorindex

	struct ber_element	*sm_pdu;
	struct ber_element	*sm_pduend;

	struct ber_element	*sm_varbind;
	struct ber_element	*sm_varbindresp;
};

/* Defined in SNMPv2-MIB.txt (RFC 3418) */
struct snmp_stats {
	u_int32_t		snmp_inpkts;
	u_int32_t		snmp_outpkts;
	u_int32_t		snmp_inbadversions;
	u_int32_t		snmp_inbadcommunitynames;
	u_int32_t		snmp_inbadcommunityuses;
	u_int32_t		snmp_inasnparseerrs;
	u_int32_t		snmp_intoobigs;
	u_int32_t		snmp_innosuchnames;
	u_int32_t		snmp_inbadvalues;
	u_int32_t		snmp_inreadonlys;
	u_int32_t		snmp_ingenerrs;
	u_int32_t		snmp_intotalreqvars;
	u_int32_t		snmp_intotalsetvars;
	u_int32_t		snmp_ingetrequests;
	u_int32_t		snmp_ingetnexts;
	u_int32_t		snmp_insetrequests;
	u_int32_t		snmp_ingetresponses;
	u_int32_t		snmp_intraps;
	u_int32_t		snmp_outtoobigs;
	u_int32_t		snmp_outnosuchnames;
	u_int32_t		snmp_outbadvalues;
	u_int32_t		snmp_outgenerrs;
	u_int32_t		snmp_outgetrequests;
	u_int32_t		snmp_outgetnexts;
	u_int32_t		snmp_outsetrequests;
	u_int32_t		snmp_outgetresponses;
	u_int32_t		snmp_outtraps;
	int			snmp_enableauthentraps;
	u_int32_t		snmp_silentdrops;
	u_int32_t		snmp_proxydrops;

	/* USM stats (RFC 3414) */
	u_int32_t		snmp_usmbadseclevel;
	u_int32_t		snmp_usmtimewindow;
	u_int32_t		snmp_usmnosuchuser;
	u_int32_t		snmp_usmnosuchengine;
	u_int32_t		snmp_usmwrongdigest;
	u_int32_t		snmp_usmdecrypterr;
};

struct address {
	struct sockaddr_storage	 ss;
	in_port_t		 port;

	TAILQ_ENTRY(address)	 entry;

	/* For SNMP trap receivers etc. */
	char			*sa_community;
	struct ber_oid		*sa_oid;
	struct address		*sa_srcaddr;
};
TAILQ_HEAD(addresslist, address);

struct listen_sock {
	int				s_fd;
	struct event			s_ev;
	TAILQ_ENTRY(listen_sock)	entry;
};
TAILQ_HEAD(socklist, listen_sock);

enum usmauth {
	AUTH_NONE = 0,
	AUTH_MD5,	/* HMAC-MD5-96, RFC3414 */
	AUTH_SHA1	/* HMAC-SHA-96, RFC3414 */
};

#define AUTH_DEFAULT	AUTH_SHA1	/* Default digest */

enum usmpriv {
	PRIV_NONE = 0,
	PRIV_DES,	/* CBC-DES, RFC3414 */
	PRIV_AES	/* CFB128-AES-128, RFC3826 */
};

#define PRIV_DEFAULT	PRIV_DES	/* Default cipher */

struct usmuser {
	char			*uu_name;
	int			 uu_seclevel;

	enum usmauth		 uu_auth;
	char			*uu_authkey;
	unsigned		 uu_authkeylen;


	enum usmpriv		 uu_priv;
	char			*uu_privkey;
	unsigned long long	 uu_salt;

	SLIST_ENTRY(usmuser)	 uu_next;
};

struct snmpd {
	u_int8_t		 sc_flags;
#define SNMPD_F_VERBOSE		 0x01
#define SNMPD_F_DEBUG		 0x02
#define SNMPD_F_NONAMES		 0x04

	const char		*sc_confpath;
	struct addresslist	 sc_addresses;
	struct socklist		 sc_sockets;
	struct timeval		 sc_starttime;
	u_int32_t		 sc_engine_boots;

	char			 sc_rdcommunity[SNMPD_MAXCOMMUNITYLEN];
	char			 sc_rwcommunity[SNMPD_MAXCOMMUNITYLEN];
	char			 sc_trcommunity[SNMPD_MAXCOMMUNITYLEN];

	uint8_t			 sc_engineid[SNMPD_MAXENGINEIDLEN];
	size_t			 sc_engineid_len;

	struct snmp_stats	 sc_stats;

	struct addresslist	 sc_trapreceivers;

	int			 sc_ncpu;
	int64_t			*sc_cpustates;
	int			 sc_rtfilter;

	int			 sc_min_seclevel;
	int			 sc_readonly;
	int			 sc_traphandler;

	struct privsep		 sc_ps;
};

struct trapcmd {
	struct ber_oid		*cmd_oid;
		/* sideways return for intermediate lookups */
	struct trapcmd		*cmd_maybe;

	int			 cmd_argc;
	char			**cmd_argv;

	RB_ENTRY(trapcmd)	 cmd_entry;
};
RB_HEAD(trapcmd_tree, trapcmd);
extern	struct trapcmd_tree trapcmd_tree;

extern struct snmpd *snmpd_env;

/* control.c */
int		 control_init(struct privsep *, struct control_sock *);
int		 control_listen(struct control_sock *);
void		 control_cleanup(struct control_sock *);

/* parse.y */
struct snmpd	*parse_config(const char *, u_int);
int		 cmdline_symset(char *);

/* log.c */
void	log_init(int, int);
void	log_procinit(const char *);
void	log_setverbose(int);
int	log_getverbose(void);
void	log_warn(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_warnx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_info(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_debug(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	logit(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	vlog(int, const char *, va_list)
	    __attribute__((__format__ (printf, 2, 0)));
__dead void fatal(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
__dead void fatalx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));

/* kroute.c */
void		 kr_init(void);
void		 kr_shutdown(void);

u_int		 kr_ifnumber(void);
u_long		 kr_iflastchange(void);
int		 kr_updateif(u_int);
u_long		 kr_routenumber(void);

struct kif	*kr_getif(u_short);
struct kif	*kr_getnextif(u_short);
struct kif_addr *kr_getaddr(struct sockaddr *);
struct kif_addr *kr_getnextaddr(struct sockaddr *);

struct kroute	*kroute_first(void);
struct kroute	*kroute_getaddr(in_addr_t, u_int8_t, u_int8_t, int);

struct kif_arp	*karp_first(u_short);
struct kif_arp	*karp_getaddr(struct sockaddr *, u_short, int);

/* snmpe.c */
void		 snmpe(struct privsep *, struct privsep_proc *);
void		 snmpe_shutdown(void);
void		 snmpe_dispatchmsg(struct snmp_message *);

/* trap.c */
void		 trap_init(void);
int		 trap_imsg(struct imsgev *, pid_t);
int		 trap_agentx(struct agentx_handle *, struct agentx_pdu *,
		    int *, char **, int *);
int		 trap_send(struct ber_oid *, struct ber_element *);

/* mps.c */
int		 mps_getreq(struct snmp_message *, struct ber_element *,
		    struct ber_oid *, u_int);
int		 mps_getnextreq(struct snmp_message *, struct ber_element *,
		    struct ber_oid *);
int		 mps_getbulkreq(struct snmp_message *, struct ber_element **,
		    struct ber_element **, struct ber_oid *, int);
int		 mps_setreq(struct snmp_message *, struct ber_element *,
		    struct ber_oid *);
int		 mps_set(struct ber_oid *, void *, long long);
int		 mps_getstr(struct oid *, struct ber_oid *,
		    struct ber_element **);
int		 mps_setstr(struct oid *, struct ber_oid *,
		    struct ber_element **);
int		 mps_getint(struct oid *, struct ber_oid *,
		    struct ber_element **);
int		 mps_setint(struct oid *, struct ber_oid *,
		    struct ber_element **);
int		 mps_getts(struct oid *, struct ber_oid *,
		    struct ber_element **);
void		 mps_encodeinaddr(struct ber_oid *, struct in_addr *, int);
int		 mps_decodeinaddr(struct ber_oid *, struct in_addr *, int);
struct ber_oid	*mps_table(struct oid *, struct ber_oid *, struct ber_oid *);

/* pf.c */
void			 pf_init(void);
int			 pf_get_stats(struct pf_status *);
int			 pfr_get_astats(struct pfr_table *, struct pfr_astats *,
			    int *, int);
int			 pfr_get_tstats(struct pfr_table *, struct pfr_tstats *,
			    int *, int);
int			 pfr_buf_grow(struct pfr_buffer *, int);
const void		*pfr_buf_next(struct pfr_buffer *, const void *);
int			 pfi_get_ifaces(const char *, struct pfi_kif *, int *);
int			 pfi_get(struct pfr_buffer *, const char *);
int			 pfi_count(void);
int			 pfi_get_if(struct pfi_kif *, int);
int			 pft_get(struct pfr_buffer *, struct pfr_table *);
int			 pft_count(void);
int			 pft_get_table(struct pfr_tstats *, int);
int			 pfta_get(struct pfr_buffer *, struct pfr_table *);
int			 pfta_get_addr(struct pfr_astats *, int);
int			 pfta_get_nextaddr(struct pfr_astats *, int *);
int			 pfta_get_first(struct pfr_astats *);

/* smi.c */
int		 smi_init(void);
u_long		 smi_getticks(void);
void		 smi_mibtree(struct oid *);
struct oid	*smi_find(struct oid *);
struct oid	*smi_findkey(char *);
struct oid	*smi_next(struct oid *);
struct oid	*smi_foreach(struct oid *, u_int);
void		 smi_oidlen(struct ber_oid *);
void		 smi_scalar_oidlen(struct ber_oid *);
char		*smi_oid2string(struct ber_oid *, char *, size_t, size_t);
int		 smi_string2oid(const char *, struct ber_oid *);
void		 smi_delete(struct oid *);
int		 smi_insert(struct oid *);
int		 smi_oid_cmp(struct oid *, struct oid *);
int		 smi_key_cmp(struct oid *, struct oid *);
unsigned long	 smi_application(struct ber_element *);
void		 smi_debug_elements(struct ber_element *);
char		*smi_print_element(struct ber_element *);

/* timer.c */
void		 timer_init(void);

/* snmpd.c */
int		 snmpd_socket_af(struct sockaddr_storage *, in_port_t);
u_long		 snmpd_engine_time(void);
char		*tohexstr(u_int8_t *, int);

/* usm.c */
void		 usm_generate_keys(void);
struct usmuser	*usm_newuser(char *name, const char **);
struct usmuser	*usm_finduser(char *name);
int		 usm_checkuser(struct usmuser *, const char **);
struct ber_element *usm_decode(struct snmp_message *, struct ber_element *,
		    const char **);
struct ber_element *usm_encode(struct snmp_message *, struct ber_element *);
struct ber_element *usm_encrypt(struct snmp_message *, struct ber_element *);
void		 usm_finalize_digest(struct snmp_message *, char *, ssize_t);
void		 usm_make_report(struct snmp_message *);

/* proc.c */
enum privsep_procid
	    proc_getid(struct privsep_proc *, unsigned int, const char *);
void	 proc_init(struct privsep *, struct privsep_proc *, unsigned int,
	    int, char **, enum privsep_procid);
void	 proc_kill(struct privsep *);
void	 proc_connect(struct privsep *);
void	 proc_dispatch(int, short event, void *);
void	 proc_run(struct privsep *, struct privsep_proc *,
	    struct privsep_proc *, u_int,
	    void (*)(struct privsep *, struct privsep_proc *, void *), void *);
void	 imsg_event_add(struct imsgev *);
int	 imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t,
	    pid_t, int, void *, u_int16_t);
int	 imsg_composev_event(struct imsgev *, u_int16_t, u_int32_t,
	    pid_t, int, const struct iovec *, int);
void	 proc_range(struct privsep *, enum privsep_procid, int *, int *);
int	 proc_compose_imsg(struct privsep *, enum privsep_procid, int,
	    u_int16_t, u_int32_t, int, void *, u_int16_t);
int	 proc_compose(struct privsep *, enum privsep_procid,
	    uint16_t, void *, uint16_t);
int	 proc_composev_imsg(struct privsep *, enum privsep_procid, int,
	    u_int16_t, u_int32_t, int, const struct iovec *, int);
int	 proc_composev(struct privsep *, enum privsep_procid,
	    uint16_t, const struct iovec *, int);
int	 proc_forward_imsg(struct privsep *, struct imsg *,
	    enum privsep_procid, int);
struct imsgbuf *
	 proc_ibuf(struct privsep *, enum privsep_procid, int);
struct imsgev *
	 proc_iev(struct privsep *, enum privsep_procid, int);
int	 proc_flush_imsg(struct privsep *, enum privsep_procid, int);

/* traphandler.c */
void	 traphandler(struct privsep *, struct privsep_proc *);
void	 traphandler_shutdown(void);
int	 snmpd_dispatch_traphandler(int, struct privsep_proc *, struct imsg *);
void	 trapcmd_free(struct trapcmd *);
int	 trapcmd_add(struct trapcmd *);
struct trapcmd *
	 trapcmd_lookup(struct ber_oid *);

/* util.c */
int	 varbind_convert(struct agentx_pdu *, struct agentx_varbind_hdr *,
	    struct ber_element **, struct ber_element **);
ssize_t	 sendtofrom(int, void *, size_t, int, struct sockaddr *,
	    socklen_t, struct sockaddr *, socklen_t);
ssize_t	 recvfromto(int, void *, size_t, int, struct sockaddr *,
	    socklen_t *, struct sockaddr *, socklen_t *);
void	 print_debug(const char *, ...);
void	 print_verbose(const char *, ...);
const char *log_in6addr(const struct in6_addr *);
const char *print_host(struct sockaddr_storage *, char *, size_t);

#endif /* SNMPD_H */
@


1.75
log
@Repair AgentX support.

which I broke when adding support for multiple listen address.  SNMP
data should be sent to the client using the appropriate socket, which we
now store when we receive the query.

Reported & fix tested by Rivo Nurges.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.74 2017/01/09 14:49:22 reyk Exp $	*/
d441 1
a441 1
	char			 sm_ctxengineid[SNMPD_MAXENGINEIDLEN];
d577 1
a577 1
	char			 sc_engineid[SNMPD_MAXENGINEIDLEN];
@


1.74
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.73 2016/11/18 16:16:39 jca Exp $	*/
d404 1
d664 1
a664 1
void		 snmpe_dispatchmsg(struct snmp_message *, int);
@


1.73
log
@Add support for multiple listening sockets

One can now specify multiple "listen on" statements. The default is to
listen on 0.0.0.0 and ::, which means better handling of dual-stack
setups.  ok sthen@@ on a previous version, input and ok reyk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.72 2016/11/09 20:31:56 jca Exp $	*/
d563 2
a564 1
#define SNMPD_F_NONAMES		 0x02
d621 2
a622 1
void	log_verbose(int);
@


1.72
log
@Improve source IP address handling.

- send replies using a source address equal to the destination address
  of queries, using IP_SENDSRCADDR.  This help in multihomed setups and
  can remove the need to explicitely configure a bind address.
- config knob to set the source address of packets sent to trap
  receivers.  "trap receiver" gains an optional "source-address"
  setting.

Source address issues reported by Andy Lemin.  ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.71 2016/10/28 09:07:08 rzalamena Exp $	*/
d521 7
d566 2
a567 3
	struct address		 sc_address;
	int			 sc_sock;
	struct event		 sc_ev;
d661 1
a661 1
void		 snmpe_dispatchmsg(struct snmp_message *);
@


1.71
log
@Sync snmpd(8) with other daemons proc.c and teach him how to fork+exec.

ok jca@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.70 2016/10/28 08:01:53 rzalamena Exp $	*/
d408 3
d517 1
d794 4
@


1.70
log
@Use snmpd_env as the only global variable for env to simplify the daemon
and avoid problems.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.69 2016/10/03 12:16:41 dlg Exp $	*/
d90 1
a149 1
	u_int			 ps_ninstances;
d172 1
a172 1
	pid_t			(*p_init)(struct privsep *,
d177 1
a177 2
	void 			*p_env;
	u_int			 p_instance;
d180 14
d649 1
a649 1
pid_t		 snmpe(struct privsep *, struct privsep_proc *);
d746 4
a749 1
void	 proc_init(struct privsep *, struct privsep_proc *, u_int);
d751 1
a751 1
void	 proc_listen(struct privsep *, struct privsep_proc *, size_t);
d753 1
a753 1
pid_t	 proc_run(struct privsep *, struct privsep_proc *,
d776 1
d779 1
a779 1
pid_t	 traphandler(struct privsep *, struct privsep_proc *);
@


1.69
log
@include sys/tree.h explicitly rather than rely on a random pf header
to do it.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.68 2016/09/25 14:58:00 fcambus Exp $	*/
d582 2
@


1.68
log
@Remove more duplicated includes

OK jca@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.67 2016/08/16 18:41:57 tedu Exp $	*/
d22 2
@


1.67
log
@stop including sys/param.h for nitems. define locally as needed.
ok natano reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.66 2015/12/07 12:33:08 reyk Exp $	*/
a26 1
#include <netinet/in.h>
@


1.66
log
@Sync proc.c, use proc_composev()
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.65 2015/11/23 19:31:52 reyk Exp $	*/
d38 4
@


1.65
log
@Use SOCK_NONBLOCK to replace socket_set_blockmode() and fcntl(..O_NONBLOCK).
(SOCK_CLOEXEC should also be added where it is appropriate, but this is OBnot
done in this commit yet.)

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.64 2015/11/22 13:27:13 reyk Exp $	*/
d740 3
a742 1
	    u_int16_t, int, void *, u_int16_t);
d744 3
a746 1
	    u_int16_t, int, const struct iovec *, int);
@


1.64
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.63 2015/11/21 13:06:22 reyk Exp $	*/
a175 5
enum blockmodes {
	BM_NORMAL,
	BM_NONBLOCK
};

a581 2

void		 socket_set_blockmode(int, enum blockmodes);
@


1.63
log
@Move local logging functions to util.c and copy log.c from iked.  Now
a copy of the same log.c file is shared by relayd, httpd, iked, and
snmpd.  No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.62 2015/10/08 08:17:30 sthen Exp $	*/
d23 2
d27 3
a29 1
#include <net/if_dl.h>
d33 3
d37 1
a37 3
#include <snmp.h>

#include <imsg.h>
d595 2
a596 1
void	log_init(int);
d610 4
a613 2
__dead void fatal(const char *);
__dead void fatalx(const char *);
@


1.62
log
@Link the result of each mps_getbulkreq() to the end of the previous list
and not the start of it. Fixes getbulk requests for multiple OIDs.

From Gerhard Roth, ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.61 2015/10/05 15:29:14 uebayasi Exp $	*/
d590 16
a605 14
void		 log_init(int);
void		 log_verbose(int);
void		 log_warn(const char *, ...);
void		 log_warnx(const char *, ...);
void		 log_info(const char *, ...);
void		 log_debug(const char *, ...);
void		 print_debug(const char *, ...);
void		 print_verbose(const char *, ...);
__dead void	 fatal(const char *);
__dead void	 fatalx(const char *);
void		 logit(int, const char *, ...);
void		 vlog(int, const char *, va_list);
const char	*log_in6addr(const struct in6_addr *);
const char	*print_host(struct sockaddr_storage *, char *, size_t);
d761 4
@


1.61
log
@Teach snmpd(8) about if_oqdrops.

OK mpi@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d400 1
d643 1
a643 1
		    struct ber_oid *, int);
@


1.60
log
@Use "compliant" header guards by avoiding the reserved '_' namespace.

Pointed out by Markus Elfring

OK mikeb@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.59 2015/01/16 00:05:13 deraadt Exp $	*/
d265 1
@


1.59
log
@first batch of cleanup to programs based upon the namespace cleanups
in net/pfvar.h sys/proc.h sys/ucred.h arpa/nameser.h
change to PATH_MAX, reduce use of MIN() and MAX(), HOST_NAME_MAX+1,
LOGIN_NAME_MAX, etc etc
ok millert guenther, some review by doug
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.58 2014/11/19 10:19:00 blambert Exp $	*/
d20 2
a21 2
#ifndef _SNMPD_H
#define _SNMPD_H
d758 1
a758 1
#endif /* _SNMPD_H */
@


1.58
log
@add support for AgentX subagents in snmpd

snmp requests are now packaged into pseudo-continuations
to allow for being dispatched to seperate processes;
lightly tested for interoperability with NetSNMP, but
doesn't implement the complete set of AgentX messages

while here, clean up return types of mps_get* functions,
and make smi_insert refuse to insert duplicate OIDs

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.57 2014/11/16 19:07:51 bluhm Exp $	*/
d387 1
a387 1
	char			 sm_host[MAXHOSTNAMELEN];
@


1.57
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.56 2014/08/18 13:13:42 reyk Exp $	*/
a175 12
struct ctl_conn {
	TAILQ_ENTRY(ctl_conn)	 entry;
	u_int8_t		 flags;
#define CTL_CONN_NOTIFY		 0x01
#define CTL_CONN_LOCKED		 0x02	/* restricted mode */
	struct imsgev		 iev;
	void 			*data;
	struct control_sock	*cs;
};
TAILQ_HEAD(ctl_connlist, ctl_conn);
extern  struct ctl_connlist ctl_conns;

d298 2
d302 1
d304 1
d314 1
d337 13
d393 7
d404 1
d626 1
d636 8
a643 7
struct ber_element *
		 mps_getreq(struct ber_element *, struct ber_oid *, u_int);
struct ber_element *
		 mps_getnextreq(struct ber_element *, struct ber_oid *);
struct ber_element *
		 mps_getbulkreq(struct ber_element *, struct ber_oid *, int);
int		 mps_setreq(struct ber_element *, struct ber_oid *);
d693 1
a693 1
void		 smi_insert(struct oid *);
d753 4
@


1.56
log
@Sync proc.c with httpd.  httpd needs SIGUSR1 but snmpd will ignore it
now instead of terminating the process.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.55 2014/05/14 09:42:22 mikeb Exp $	*/
d584 1
@


1.55
log
@Sync ktable code with bgpd to fetch, store and perform lookups in
multiple routing tables.  Currently it doesn't do anything useful
but it's a prerequisite for any future work in this direction.

ok sthen, reyk, blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.54 2014/04/28 12:03:32 mikeb Exp $	*/
d152 1
@


1.54
log
@Add support for exporting ARP table via ipNetToMediaTable OID.
With help from blambert@@ and sthen@@, tested by sthen@@, benno@@
and myself;  ok blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.53 2014/04/28 08:25:05 blambert Exp $	*/
d190 12
@


1.53
log
@better proc id name (it handles traps, not alerts) for the
snmp trap handler
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.52 2014/04/25 06:57:11 blambert Exp $	*/
d25 1
d195 1
d229 9
d591 3
@


1.52
log
@Support running user-defined actions on receipt of snmp traps.

testing sthen@@
much man page guidance jmc@@
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.51 2014/04/21 19:47:27 reyk Exp $	*/
d115 1
a115 1
	PROC_ALERT,	/* SNMP trap receiver */
@


1.51
log
@Copy the updated proc.c from relayd to use the same file.  Adjust
snmpd accordingly.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.50 2014/04/14 12:55:10 blambert Exp $	*/
d78 2
a79 1
	IMSG_CTL_RELOAD
d115 1
d520 1
d525 13
d700 9
@


1.50
log
@Make snmpd use the AgentX protcol for accepting trap requests.
AgentX notifications are the only portion implemented right now;
get in the tree to flesh out the remainder.

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.49 2014/02/14 10:38:09 florian Exp $	*/
d85 1
d122 4
d127 4
a130 2
	int			 ps_pipes[PROC_MAX][PROC_MAX];
	struct imsgev		 ps_ievs[PROC_MAX];
d135 5
d160 1
a160 2
	void			(*p_shutdown)(struct privsep *,
				    struct privsep_proc *);
d164 1
d567 1
a567 1
void		 snmpe_shutdown(struct privsep *, struct privsep_proc *);
d663 1
a663 1
void	 proc_config(struct privsep *, struct privsep_proc *, u_int);
d667 1
a667 1
	    void (*)(struct privsep *, void *), void *);
d673 2
a674 1
int	 proc_compose_imsg(struct privsep *, enum privsep_procid,
d676 1
a676 1
int	 proc_composev_imsg(struct privsep *, enum privsep_procid,
d679 5
a683 2
	    enum privsep_procid);
void	 proc_flush_imsg(struct privsep *, enum privsep_procid);
@


1.49
log
@remove unused function that distracts from cleaning up the imsg_flush() mess
OK hennig@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.48 2013/11/21 17:32:13 mikeb Exp $	*/
d103 1
d166 2
a167 1

d341 6
d348 1
d378 1
d560 2
d569 2
d667 2
@


1.48
log
@split kernel parts of the if.h into a separate header file if_var.h
which allows us to modify ifnet structure in a relatively safe way;
discussed with deraadt, ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.47 2013/10/17 08:42:44 reyk Exp $	*/
a652 1
void	 proc_flush_imsg(struct privsep *, enum privsep_procid);
@


1.47
log
@Update snmpd(8) to use the proc.c privsep style from iked and relayd.

ok sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.46 2013/10/16 16:05:03 blambert Exp $	*/
d220 20
@


1.46
log
@ 1) move the creation of 'restricted' communication sockets
    into snmpd.conf
 2) add the ability to specify an alternate 'control' socket location
 3) allow for the creation of multiple 'restricted' sockets (but
    only one control socket, for the time being)

Committing slightly ahead of schedule in order to clear the pipeline
for a few other upcoming changes.

ok reyk@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.45 2013/10/01 12:41:47 reyk Exp $	*/
d76 3
a78 1
	IMSG_CTL_NOTIFY
d81 14
a94 4
enum {
	PROC_PARENT,	/* Parent process and application interface */
	PROC_SNMPE	/* SNMP engine */
} snmpd_process;
d103 1
d109 45
a158 8
struct imsgev {
	struct imsgbuf		 ibuf;
	void			(*handler)(int, short, void *);
	struct event		 ev;
	void			*data;
	short			 events;
};

a458 3
	struct control_sock	 sc_csock;
	struct control_socks	 sc_rcsocks;

d476 2
d481 1
a481 1
int		 control_init(struct control_sock *);
a482 3
void		 control_accept(int, short, void *);
void		 control_dispatch_imsg(int, short, void *);
void		 control_imsg_forward(struct imsg *);
d485 1
a485 1
void		 session_socket_blockmode(int, enum blockmodes);
d493 1
d498 2
a505 4
void		 imsg_event_add(struct imsgev *);
int		 imsg_compose_event(struct imsgev *, enum imsg_type, u_int32_t,
		    pid_t, int, void *, u_int16_t);

d524 2
a525 1
pid_t		 snmpe(struct snmpd *, int [2]);
d613 21
@


1.45
log
@Add initial SNMP client utility to snmpctl(8).
For example, snmpctl snmp walk 127.0.0.1

commit it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.44 2013/09/26 09:11:30 reyk Exp $	*/
d91 2
d94 1
d410 1
a410 1
	struct control_sock	 sc_rcsock;
@


1.44
log
@shuffle some snmpd functions to make them visible in smi.c for snmpctl.

ok gerhard@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.43 2013/03/29 12:53:41 gerhard Exp $	*/
d198 1
d530 1
d535 2
a536 1
char		*smi_oidstring(struct ber_oid *, char *, size_t);
d540 1
@


1.43
log
@Patch from Ilya Bakulin that allows to put snmpd(8) into read-only mode
so that all "set" requests will be rejected.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.42 2013/03/06 21:42:40 sthen Exp $	*/
a475 1
void		 snmpe_debug_elements(struct ber_element *);
d537 3
@


1.42
log
@as done in ospf{,6}d/relayd, sync yyerror in various other daemons with
that from bgpd, so that it logs to syslog when daemonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.41 2013/03/04 14:00:31 bluhm Exp $	*/
d424 1
@


1.41
log
@Fix compiler warnings about casts discarding const qualifiers and
comparison between signed and unsigned.  No binary change.
OK reyk@@ joel@@ gerhard@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.40 2013/01/24 09:30:27 gerhard Exp $	*/
d448 1
@


1.40
log
@Even if there's no special seclevel required in snmpd.conf, we have to
validate the user of a received SNMPv3 request. If the configured user
has a certain security level (i.e. authentication and maybe encryption),
the received message must fulfill this security requirements, too.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.39 2012/10/01 11:36:55 reyk Exp $	*/
d510 1
a510 1
void			*pfr_buf_next(struct pfr_buffer *, const void *);
@


1.39
log
@Support the 0.0.0.0 and 255.255.255.255 IPv4 addresses in the ipAddrTable.
This fixes an issue which aborted the address traversal / SNMP walk when
an "any"/0.0.0.0 address was configured on an interface.  The problem
was found with a pppoe(4) device that is typically configured with 0.0.0.0
on startup.

Found and fix tested by Gerhard Roth
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.38 2012/09/18 08:29:09 reyk Exp $	*/
d379 1
@


1.38
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.37 2012/09/17 16:43:59 reyk Exp $	*/
d498 1
a498 1
void		 mps_decodeinaddr(struct ber_oid *, struct in_addr *, int);
@


1.37
log
@Update copyright and my email address in snmpd while I'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.36 2012/09/17 16:30:35 reyk Exp $	*/
d511 2
a512 2
int	 		 pfi_get(struct pfr_buffer *, const char *);
int	 	 	 pfi_count(void);
d516 1
a516 1
int		 	 pft_get_table(struct pfr_tstats *, int);
@


1.36
log
@Add initial SNMPv3 support to snmpd(8).

Traps are still sent via SNMPv2 protocol. They can neither be
authenticated nor encrypted. - Transport mode is still UDP. Not
additional transport subsystems were added. - Only the User-based
Security Model (USM, RFC3414) is supported.  View-Based Access Control
(VACM, RFC3415) is not included. - Configuration is described in
snmpd.conf(5).

This diff includes a few minor changes to ber.c/h adding a necessary
callback for the USM HMAC calculation and merging it with other
minor changes from ldapd's ber code.

From Gerhard Roth at genua
ok claudio@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.35 2012/05/28 20:55:40 joel Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007, 2008 Reyk Floeter <reyk@@vantronix.net>
@


1.35
log
@Plug a couple more fd leaks. As part of the fix, make all the *init
functions return void.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.34 2012/04/08 02:57:40 deraadt Exp $	*/
d28 1
a28 1
#include <ber.h>
d47 8
d61 10
d259 5
d265 4
d270 2
d273 1
a273 1
	u_int			 sm_context;
d275 17
a291 2
	struct ber_element	*sm_header;
	struct ber_element	*sm_headerend;
d339 8
d361 31
d402 1
d411 3
d421 2
d541 2
d544 11
@


1.34
log
@add the evtimout rate-limiting code for accept() here too.
eyed a little by joel
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.33 2012/02/23 03:54:38 joel Exp $	*/
d366 1
a366 1
int		 kr_init(void);
d413 1
a413 1
int			 pf_init(void);
@


1.33
log
@Bring in PF-MIB to snmpd.

ok krw@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.32 2012/02/01 18:44:06 camield Exp $	*/
d70 1
@


1.32
log
@Variable bindings need instance identifiers, for scalars this is always .0.
At least NetSNMP and HPOV now understand it.

ok joel@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.31 2011/04/21 14:55:22 sthen Exp $	*/
d25 1
d212 25
d410 21
@


1.31
log
@Add a "filter-routes" option; when set, snmpd asks the kernel not to
send route updates. If you aren't interested in examining routing tables
over SNMP (e.g. if you only use it for sensors or interface stats) this
reduces cpu use during heavy route updates. Makes my full-table bgp
routers happier when a major peer bounces.  ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.30 2010/09/20 08:56:16 martinh Exp $	*/
d393 1
@


1.30
log
@Return error on GET requests without an instance identifier, both for
tables and scalar values.

Fixes system/6468 by not calling table get functions with an unexpectedly
short OID.

Also fixes system/6071. Scalar variables without an instance specified now
returns a noSuchInstance error. GetNext requests correctly returns the .0
instance.

This means you can no longer rely on
$ snmpget -v2c -c public localhost SNMPv2-MIB::sysDescr
returning the .0 instance. You need to specify it explicitly:
$ snmpget -v2c -c public localhost SNMPv2-MIB::sysDescr.0

Also return proper SNMPv2 errors per varbind instead of a noSuchName error
status, unless SNMPv1 was specified in the request.

An earlier version of this diff tested by Remi Laurent, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.29 2010/06/11 10:45:36 jsg Exp $	*/
d306 1
@


1.29
log
@Implement IP-FORWARD-MIB, ipv4 only for now.

ok reyk@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.28 2010/04/01 14:42:32 claudio Exp $	*/
d365 1
a365 1
		 mps_getreq(struct ber_element *, struct ber_oid *);
@


1.28
log
@Track blackhole and reject flags since the MIB knows about them.
Remove an unneeded stack storage as well.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.27 2010/03/31 09:20:23 claudio Exp $	*/
d350 3
@


1.27
log
@Track interface addresses in a AF independent way. This is needed to support
the AF independent MIBs like RFC4292 in the future. Additionally count number
of routes (also needed by some MIBs) and do not track the state of routes
since the MIB do not require it and it is expensive.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.26 2010/03/29 14:52:49 claudio Exp $	*/
d148 5
a152 3
#define	F_CONNECTED		0x0008
#define	F_STATIC		0x0020
#define	F_DYNAMIC		0x0040
@


1.26
log
@Sync kroute.c code with bgpd so that snmpd is able to track INET6 addrs as
well. First big sync, the interface address tree still needs to be made
AF independent but that will be done in a second step.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.25 2009/06/06 18:38:01 pyr Exp $	*/
d101 7
d130 3
a132 3
	struct in_addr		 addr;
	struct in_addr		 mask;
	struct in_addr		 dstbrd;
d142 2
a145 3
	u_int8_t		 if_nhreachable; /* for nexthop verification */
	u_long			 if_ticks;
	struct if_data		 if_data;
a148 1
#define	F_DOWN			0x0010
a338 1
int		 kr_updateif(u_int);
d341 3
d346 2
a347 2
struct kif_addr *kr_getaddr(struct in_addr *);
struct kif_addr *kr_getnextaddr(struct in_addr *);
@


1.25
log
@this one missed the last batch.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.24 2009/06/06 05:52:01 pyr Exp $	*/
d104 1
a105 1
	u_int16_t	rtlabel;
d108 6
d115 4
a141 3
#define	F_OSPFD_INSERTED	0x0001
#define	F_KERNEL		0x0002
#define	F_BGPD_INSERTED		0x0004
a145 1
#define	F_REDISTRIBUTED		0x0100
d323 1
@


1.24
log
@sync snmpd with the common imsg code, making it lib ready as well.
ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.23 2008/12/23 08:06:10 reyk Exp $	*/
d30 1
a30 1
#include "imsg.h"
@


1.23
log
@export the livelock counter in a private mib openBSD.5.

discussed with dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.22 2008/12/08 11:34:55 reyk Exp $	*/
d30 2
a51 45
/*
 * imsg framework and privsep
 */

struct buf {
	TAILQ_ENTRY(buf)	 entry;
	u_char			*buf;
	size_t			 size;
	size_t			 max;
	size_t			 wpos;
	size_t			 rpos;
	int			 fd;
};

struct msgbuf {
	TAILQ_HEAD(, buf)	 bufs;
	u_int32_t		 queued;
	int			 fd;
};

#define IMSG_HEADER_SIZE	sizeof(struct imsg_hdr)
#define MAX_IMSGSIZE		8192

struct buf_read {
	u_char			 buf[READ_BUF_SIZE];
	u_char			*rptr;
	size_t			 wpos;
};

struct imsg_fd {
	TAILQ_ENTRY(imsg_fd)	entry;
	int			fd;
};

struct imsgbuf {
	TAILQ_HEAD(, imsg_fd)	 fds;
	struct buf_read		 r;
	struct msgbuf		 w;
	struct event		 ev;
	void			(*handler)(int, short, void *);
	int			 fd;
	pid_t			 pid;
	short			 events;
};

a59 12
struct imsg_hdr {
	u_int16_t	 type;
	u_int16_t	 len;
	u_int32_t	 peerid;
	pid_t		 pid;
};

struct imsg {
	struct imsg_hdr	 hdr;
	void		*data;
};

d78 8
d91 1
a91 1
	struct imsgbuf		 ibuf;
d319 2
a320 16
/* buffer.c */
struct buf	*buf_open(size_t);
struct buf	*buf_dynamic(size_t, size_t);
int		 buf_add(struct buf *, void *, size_t);
void		*buf_reserve(struct buf *, size_t);
int		 buf_close(struct msgbuf *, struct buf *);
void		 buf_free(struct buf *);
void		 msgbuf_init(struct msgbuf *);
void		 msgbuf_clear(struct msgbuf *);
int		 msgbuf_write(struct msgbuf *);

/* imsg.c */
void		 imsg_init(struct imsgbuf *, int, void (*)(int, short, void *));
ssize_t		 imsg_read(struct imsgbuf *);
ssize_t		 imsg_get(struct imsgbuf *, struct imsg *);
int		 imsg_compose(struct imsgbuf *, enum imsg_type, u_int32_t,
a321 9
int		 imsg_composev(struct imsgbuf *, enum imsg_type , u_int32_t,
		    pid_t, int, const struct iovec *, int);
struct buf	*imsg_create(struct imsgbuf *, enum imsg_type, u_int32_t,
		    pid_t, u_int16_t);
int		 imsg_add(struct buf *, void *, u_int16_t);
int		 imsg_close(struct imsgbuf *, struct buf *);
void		 imsg_free(struct imsg *);
void		 imsg_event_add(struct imsgbuf *); /* provided externally */
int		 imsg_get_fd(struct imsgbuf *);
d341 1
a341 1
int		 trap_imsg(struct imsgbuf *, pid_t);
@


1.22
log
@report memory and swap in hrStorage, and implement hrProcessor to report
hrProcessorLoad (where load means the percentage of time the system was
not idle during the last minute).  based on HOST-RESOURCES-MIB.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.21 2008/09/26 15:19:55 reyk Exp $	*/
d433 1
@


1.21
log
@allow to add an additional restricted control socket for trap sending
only (not even show commands).  this allows to place a socket for
traps in another daemon's chroot.

(based on restricted socket support from bgpd)
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.20 2008/07/18 12:30:06 reyk Exp $	*/
d337 3
d446 3
@


1.20
log
@merge log_host with relayd's version using getnameinfo and rename it
to print_host.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.19 2008/06/29 16:00:22 ragge Exp $	*/
d121 6
a126 4
struct {
	struct event	 ev;
	int		 fd;
} control_state;
d327 3
d340 2
a341 2
int		 control_init(void);
int		 control_listen(struct snmpd *, struct imsgbuf *);
d345 1
a345 1
void		 control_cleanup(void);
@


1.19
log
@Use C99, not gcc-specific variadics.  Ok miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.18 2008/02/07 11:33:26 reyk Exp $	*/
d356 1
a356 1
const char	*log_host(struct sockaddr_storage *, char *, size_t);
@


1.18
log
@add a imsg which allows to "lock" the control connection, the
restricted connection will reject any commands except snmp traps.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.17 2008/01/18 02:09:30 reyk Exp $	*/
d237 3
a239 3
#define OID(_mib...)		{ { _mib } }
#define MIBDECL(_mib...)	{ { MIB_##_mib } }, #_mib
#define MIB(_mib...)		{ { MIB_##_mib } }, NULL
@


1.17
log
@add a snmpctl command to send traps to registered receivers using
snmpd's imsg trap interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.16 2008/01/17 17:35:06 reyk Exp $	*/
d135 1
@


1.16
log
@allow to configure optional per trap receiver communities and to
restrict the receivers to a specified mib.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.15 2008/01/16 21:43:19 reyk Exp $	*/
d374 2
@


1.15
log
@send a coldStart trap to registered receivers on startup and cleanup
the trap code a little bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.14 2008/01/16 19:36:06 reyk Exp $	*/
a303 1
	char			 ifname[IFNAMSIZ];
@


1.14
log
@implementation of the SNMP trap sender interface
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.13 2008/01/16 09:51:15 reyk Exp $	*/
d400 1
d402 1
a402 1
int		 trap_send(struct ber_element *, struct ber_oid *);
@


1.13
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.12 2008/01/16 09:42:29 reyk Exp $	*/
a49 8
struct address {
	struct sockaddr_storage	 ss;
	in_port_t		 port;
	char			 ifname[IFNAMSIZ];
	TAILQ_ENTRY(address)	 entry;
};
TAILQ_HEAD(addresslist, address);

d301 13
d330 2
d397 1
d400 2
a401 1
int		 trap_request(struct imsgbuf *, pid_t);
d435 3
@


1.12
log
@move trap code to an own file; there will be more
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.11 2008/01/16 09:36:30 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007 Reyk Floeter <reyk@@vantronix.net>
@


1.11
log
@start working on an interface to send traps via snmpd.sock.  userland
applications will be able to send imsgs defining the trap to snmpd and
the daemon will do the ASN.1/BER encoding before sending traps to the
registered receivers.  there are two advantages of this approach that
a) the applications do not need to handle any ASN.1/BER encoding and
b) snmpd will provide a central interface to define trap receivers.

discussed with thib and others
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.10 2008/01/03 15:03:47 reyk Exp $	*/
d390 3
a392 1
int		 snmpe_trap(struct imsgbuf *, pid_t);
@


1.10
log
@handle no more than 2147483647 (0x7fffffff) variable bindings
From RFC3416
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.9 2008/01/02 20:54:59 maja Exp $	*/
d390 1
@


1.9
log
@Make sure that a key belongs to the table before returning a match.
Change smi_odi_cmp to return int as expected by RB-tree. -moj

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.8 2007/12/29 09:24:43 reyk Exp $	*/
d42 1
@


1.8
log
@add the IP-MIB ipAddrTable.  it requires to encode the ipv4 addresses
in the OIDs as the table index.  the next step is to simplify the
common mib implementation regarding the special requirements of these
strange snmp tables.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.7 2007/12/28 16:59:31 reyk Exp $	*/
d421 1
a421 1
long		 smi_oid_cmp(struct oid *, struct oid *);
@


1.7
log
@split code handling the "structure of management information" and the
"message processing subsystem" into separate files smi.c and mps.c
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.6 2007/12/28 16:27:51 reyk Exp $	*/
d163 1
a163 1
	TAILQ_ENTRY(kif_addr)	 entry;
d167 3
d205 1
a205 1
	int			(*o_get)(struct oid *, struct ber_oid *,
d207 1
a207 1
	int			(*o_set)(struct oid *, struct ber_oid *,
d209 2
d225 1
d384 2
d407 2
@


1.6
log
@split the MIB declarations (names) from the definitions (implementation).
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.5 2007/12/28 15:32:02 reyk Exp $	*/
a382 7
int		 mps_init(void);
u_long		 mps_getticks(void);
long		 mps_oid_cmp(struct oid *, struct oid *);
void		 mps_mibtree(struct oid *);
struct oid	*mps_foreach(struct oid *, u_int);
void		 mps_oidlen(struct ber_oid *);
char		*mps_oidstring(struct ber_oid *, char *, size_t);
a388 2
void		 mps_delete(struct oid *);
void		 mps_insert(struct oid *);
d399 13
@


1.5
log
@use the snmp camelCase for MIB definitions, this allows to simplify
the code a bit and is mostly a stylistic change.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.4 2007/12/15 04:15:12 reyk Exp $	*/
d238 2
a239 1
#define MIB(_mib...)		{ { MIB_##_mib } }, #_mib
@


1.4
log
@shrink the code by making some ipstat parts table-driven.  at some
point i may want to define a general table-driven interface for mibs.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.3 2007/12/07 09:50:51 reyk Exp $	*/
d238 1
a238 1
#define MIB(_mib...)		{ { MIB_##_mib } }
@


1.3
log
@add a new 'd' format to ber_printf_elements to pass ints instead of
long longs; you have to pass the right type with vargs. this finally
fixes the previous problem on i386.

discussed with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.2 2007/12/05 22:52:50 reyk Exp $	*/
d207 1
a208 1
	long long		 o_val;
@


1.2
log
@- add support joel's OPENBSD-SENSORS-MIB; it will dump the current
sensor status in a SNMP table.
- some other minor changes
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.1 2007/12/05 09:22:44 reyk Exp $	*/
d246 1
a246 1
	u_int8_t		 sm_version;
@


1.1
log
@Start working on snmpd(8) and snmpctl(8), a lightweight SNMP implementation
for OpenBSD.  SNMP is a necessary evil.  This is work in progress, don't
expect too much from it yet.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpd.h,v 1.11 2007/11/13 18:50:07 reyk Exp $	*/
d239 1
d385 1
a385 1
void		 mps_mibtree(struct oid *, size_t);
@

