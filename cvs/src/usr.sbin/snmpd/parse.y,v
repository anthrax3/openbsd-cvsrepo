head	1.45;
access;
symbols
	OPENBSD_6_2:1.45.0.2
	OPENBSD_6_2_BASE:1.45
	OPENBSD_6_1:1.43.0.4
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.39.0.2
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.37.0.6
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14;
locks; strict;
comment	@ * @;


1.45
date	2017.08.20.07.03.45;	author tb;	state Exp;
branches;
next	1.44;
commitid	Wmnxs3O3dQNaCKWo;

1.44
date	2017.07.28.13.15.32;	author florian;	state Exp;
branches;
next	1.43;
commitid	sHqydfSAeLctsBFj;

1.43
date	2017.01.05.13.53.10;	author krw;	state Exp;
branches;
next	1.42;
commitid	3AKCl24jEn0sIt6p;

1.42
date	2017.01.05.12.42.19;	author krw;	state Exp;
branches;
next	1.41;
commitid	uzjOUwLRoN7KbcZI;

1.41
date	2016.11.18.16.16.39;	author jca;	state Exp;
branches;
next	1.40;
commitid	5lrkdv6CJEuqxjzU;

1.40
date	2016.11.09.20.31.56;	author jca;	state Exp;
branches;
next	1.39;
commitid	W7m2j1sZd5b467J6;

1.39
date	2016.06.21.21.35.25;	author benno;	state Exp;
branches;
next	1.38;
commitid	AL6SnrmnHkmPOpjv;

1.38
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.37;
commitid	T3JBYxNT0thPuavp;

1.37
date	2015.02.08.04.50.32;	author reyk;	state Exp;
branches;
next	1.36;
commitid	jVCsun3nRn9HXgv1;

1.36
date	2014.11.20.05.51.21;	author jsg;	state Exp;
branches;
next	1.35;
commitid	3Z7yItGpFsmshk0c;

1.35
date	2014.11.19.10.19.00;	author blambert;	state Exp;
branches;
next	1.34;
commitid	cXioMeUnRYhFJvcH;

1.34
date	2014.11.16.19.07.51;	author bluhm;	state Exp;
branches;
next	1.33;
commitid	ohVlnYugDUFcNu2w;

1.33
date	2014.11.14.03.20.37;	author doug;	state Exp;
branches;
next	1.32;
commitid	M08zdkdK3z1pxKwF;

1.32
date	2014.04.25.06.57.11;	author blambert;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.24.08.51.08;	author blambert;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.14.12.55.10;	author blambert;	state Exp;
branches;
next	1.29;

1.29
date	2014.01.22.00.21.17;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2013.11.25.13.00.56;	author benno;	state Exp;
branches;
next	1.27;

1.27
date	2013.10.17.08.42.44;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2013.10.16.16.05.02;	author blambert;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.29.12.53.41;	author gerhard;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.06.21.42.40;	author sthen;	state Exp;
branches;
next	1.23;

1.23
date	2012.09.17.19.00.06;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2012.09.17.16.43.59;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2012.09.17.16.30.34;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.21.14.55.22;	author sthen;	state Exp;
branches;
next	1.19;

1.19
date	2010.10.18.13.29.49;	author sthen;	state Exp;
branches;
next	1.18;

1.18
date	2010.08.03.18.42.41;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.31.21.03.49;	author tobias;	state Exp;
branches;
next	1.16;

1.16
date	2008.10.17.13.02.55;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2008.07.18.12.35.27;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2008.02.27.15.12.10;	author mpf;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.27.10.30.11;	author mpf;	state Exp;
branches;
next	1.12;

1.12
date	2008.02.26.20.06.14;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.30.10.12.45;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.17.17.35.06;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.16.19.36.06;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.16.09.51.15;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.12.28.17.36.55;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.12.28.16.59.31;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.28.15.33.37;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.28.15.32.02;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.07.10.22.38;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.05.22.57.02;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.05.09.22.44;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Check that we haven't yet reached the end of the string before calling
strcspn(3) instead of afterwards.  Fixes an out-of-bound read that led
to intermittent crashes experienced by rob in his regression test.

ok rob
@
text
@/*	$OpenBSD: parse.y,v 1.44 2017/07/28 13:15:32 florian Exp $	*/

/*
 * Copyright (c) 2007, 2008, 2012 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2004 Ryan McBride <mcbride@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/queue.h>
#include <sys/tree.h>

#include <netinet/in.h>
#include <net/if.h>

#include <arpa/inet.h>
#include <arpa/nameser.h>

#include <ctype.h>
#include <unistd.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <limits.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdio.h>
#include <netdb.h>
#include <string.h>
#include <syslog.h>

#include "snmpd.h"
#include "mib.h"

enum socktype {
	SOCK_TYPE_RESTRICTED = 1,
	SOCK_TYPE_AGENTX = 2
};

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file, *topfile;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

struct snmpd			*conf = NULL;
static int			 errors = 0;
static struct addresslist	*hlist;
static struct usmuser		*user = NULL;
static int			 nctlsocks = 0;

struct address	*host_v4(const char *);
struct address	*host_v6(const char *);
int		 host_dns(const char *, struct addresslist *,
		    int, in_port_t, struct ber_oid *, char *,
		    struct address *);
int		 host(const char *, struct addresslist *,
		    int, in_port_t, struct ber_oid *, char *, char *);

typedef struct {
	union {
		int64_t		 number;
		char		*string;
		struct host	*host;
		struct timeval	 tv;
		struct ber_oid	*oid;
		struct {
			int		 type;
			void		*data;
			long long	 value;
		}		 data;
		enum usmauth	 auth;
		enum usmpriv	 enc;
	} v;
	int lineno;
} YYSTYPE;

%}

%token	INCLUDE
%token  LISTEN ON
%token	SYSTEM CONTACT DESCR LOCATION NAME OBJECTID SERVICES RTFILTER
%token	READONLY READWRITE OCTETSTRING INTEGER COMMUNITY TRAP RECEIVER
%token	SECLEVEL NONE AUTH ENC USER AUTHKEY ENCKEY ERROR DISABLED
%token	SOCKET RESTRICTED AGENTX HANDLE DEFAULT SRCADDR
%token	<v.string>	STRING
%token  <v.number>	NUMBER
%type	<v.string>	hostcmn
%type	<v.string>	srcaddr
%type	<v.number>	optwrite yesno seclevel socktype
%type	<v.data>	objtype cmd
%type	<v.oid>		oid hostoid trapoid
%type	<v.auth>	auth
%type	<v.enc>		enc

%%

grammar		: /* empty */
		| grammar include '\n'
		| grammar '\n'
		| grammar varset '\n'
		| grammar main '\n'
		| grammar system '\n'
		| grammar mib '\n'
		| grammar error '\n'		{ file->errors++; }
		;

include		: INCLUDE STRING		{
			struct file	*nfile;

			if ((nfile = pushfile($2, 0)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}
		;

varset		: STRING '=' STRING	{
			char *s = $1;
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				fatal("cannot store variable");
			free($1);
			free($3);
		}
		;

yesno		:  STRING			{
			if (!strcmp($1, "yes"))
				$$ = 1;
			else if (!strcmp($1, "no"))
				$$ = 0;
			else {
				yyerror("syntax error, "
				    "either yes or no expected");
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

main		: LISTEN ON STRING		{
			if (host($3, &conf->sc_addresses, 16, SNMPD_PORT, NULL,
			    NULL, NULL) <= 0) {
				yyerror("invalid ip address: %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
		}
		| READONLY COMMUNITY STRING	{
			if (strlcpy(conf->sc_rdcommunity, $3,
			    sizeof(conf->sc_rdcommunity)) >=
			    sizeof(conf->sc_rdcommunity)) {
				yyerror("r/o community name too long");
				free($3);
				YYERROR;
			}
			free($3);
		}
		| READWRITE COMMUNITY STRING	{
			if (strlcpy(conf->sc_rwcommunity, $3,
			    sizeof(conf->sc_rwcommunity)) >=
			    sizeof(conf->sc_rwcommunity)) {
				yyerror("r/w community name too long");
				free($3);
				YYERROR;
			}
			free($3);
		}
		| READWRITE DISABLED {
			conf->sc_readonly = 1;
 		}
		| TRAP COMMUNITY STRING		{
			if (strlcpy(conf->sc_trcommunity, $3,
			    sizeof(conf->sc_trcommunity)) >=
			    sizeof(conf->sc_trcommunity)) {
				yyerror("trap community name too long");
				free($3);
				YYERROR;
			}
			free($3);
		}
		| TRAP RECEIVER			{
			hlist = &conf->sc_trapreceivers;
		} host				{
			hlist = NULL;
		}
		| TRAP HANDLE hostcmn trapoid cmd {
			struct trapcmd *cmd = $5.data;

			cmd->cmd_oid = $4;

			if (trapcmd_add(cmd) != 0) {
				free($4);
				free(cmd);
				yyerror("duplicate oid");
				YYERROR;
			}
			conf->sc_traphandler = 1;
		}
		| RTFILTER yesno		{
			if ($2 == 1)
				conf->sc_rtfilter = ROUTE_FILTER(RTM_NEWADDR) |
				    ROUTE_FILTER(RTM_DELADDR) |
				    ROUTE_FILTER(RTM_IFINFO) |
				    ROUTE_FILTER(RTM_IFANNOUNCE);
			else
				conf->sc_rtfilter = 0;
		}
		| SECLEVEL seclevel {
			conf->sc_min_seclevel = $2;
		}
		| USER STRING			{
			const char *errstr;
			user = usm_newuser($2, &errstr);
			if (user == NULL) {
				yyerror("%s", errstr);
				free($2);
				YYERROR;
			}
		} userspecs {
			const char *errstr;
			if (usm_checkuser(user, &errstr) < 0) {
				yyerror("%s", errstr);
				YYERROR;
			}
			user = NULL;
		}
		| SOCKET STRING socktype {
			if ($3) {
				struct control_sock *rcsock;

				rcsock = calloc(1, sizeof(*rcsock));
				if (rcsock == NULL) {
					yyerror("calloc");
					YYERROR;
				}
				rcsock->cs_name = $2;
				if ($3 == SOCK_TYPE_RESTRICTED)
					rcsock->cs_restricted = 1;
				else if ($3 == SOCK_TYPE_AGENTX)
					rcsock->cs_agentx = 1;
				TAILQ_INSERT_TAIL(&conf->sc_ps.ps_rcsocks,
				    rcsock, cs_entry);
			} else {
				if (++nctlsocks > 1) {
					yyerror("multiple control "
					    "sockets specified");
					YYERROR;
				}
				conf->sc_ps.ps_csock.cs_name = $2;
			}
		}
		;

system		: SYSTEM sysmib
		;

sysmib		: CONTACT STRING		{
			struct ber_oid	 o = OID(MIB_sysContact);
			mps_set(&o, $2, strlen($2));
		}
		| DESCR STRING			{
			struct ber_oid	 o = OID(MIB_sysDescr);
			mps_set(&o, $2, strlen($2));
		}
		| LOCATION STRING		{
			struct ber_oid	 o = OID(MIB_sysLocation);
			mps_set(&o, $2, strlen($2));
		}
		| NAME STRING			{
			struct ber_oid	 o = OID(MIB_sysName);
			mps_set(&o, $2, strlen($2));
		}
		| OBJECTID oid			{
			struct ber_oid	 o = OID(MIB_sysOID);
			mps_set(&o, $2, sizeof(struct ber_oid));
		}
		| SERVICES NUMBER		{
			struct ber_oid	 o = OID(MIB_sysServices);
			mps_set(&o, NULL, $2);
		}
		;

mib		: OBJECTID oid NAME STRING optwrite objtype	{
			struct oid	*oid;
			if ((oid = (struct oid *)
			    calloc(1, sizeof(*oid))) == NULL) {
				yyerror("calloc");
				free($2);
				free($6.data);
				YYERROR;
			}

			smi_oidlen($2);
			bcopy($2, &oid->o_id, sizeof(struct ber_oid));
			free($2);
			oid->o_name = $4;
			oid->o_data = $6.data;
			oid->o_val = $6.value;
			switch ($6.type) {
			case 1:
				oid->o_get = mps_getint;
				oid->o_set = mps_setint;
				break;
			case 2:
				oid->o_get = mps_getstr;
				oid->o_set = mps_setstr;
				break;
			}
			oid->o_flags = OID_RD|OID_DYNAMIC;
			if ($5)
				oid->o_flags |= OID_WR;

			if (smi_insert(oid) == -1) {
				yyerror("duplicate oid");
				free(oid->o_name);
				free(oid->o_data);
				YYERROR;
			}
		}
		;

objtype		: INTEGER NUMBER			{
			$$.type = 1;
			$$.data = NULL;
			$$.value = $2;
		}
		| OCTETSTRING STRING			{
			$$.type = 2;
			$$.data = $2;
			$$.value = strlen($2);
		}
		;

optwrite	: READONLY				{ $$ = 0; }
		| READWRITE				{ $$ = 1; }
		;

oid		: STRING				{
			struct ber_oid	*sysoid;
			if ((sysoid =
			    calloc(1, sizeof(*sysoid))) == NULL) {
				yyerror("calloc");
				free($1);
				YYERROR;
			}
			if (ber_string2oid($1, sysoid) == -1) {
				yyerror("invalid OID: %s", $1);
				free(sysoid);
				free($1);
				YYERROR;
			}
			free($1);
			$$ = sysoid;
		}
		;

trapoid		: oid					{ $$ = $1; }
		| DEFAULT				{
			struct ber_oid	*sysoid;
			if ((sysoid =
			    calloc(1, sizeof(*sysoid))) == NULL) {
				yyerror("calloc");
				YYERROR;
			}
			ber_string2oid("1.3", sysoid);
			$$ = sysoid;
		}
		;

hostoid		: /* empty */				{ $$ = NULL; }
		| OBJECTID oid				{ $$ = $2; }
		;

hostcmn		: /* empty */				{ $$ = NULL; }
		| COMMUNITY STRING			{ $$ = $2; }
		;

srcaddr		: /* empty */				{ $$ = NULL; }
		| SRCADDR STRING			{ $$ = $2; }
		;

hostdef		: STRING hostoid hostcmn srcaddr	{
			if (host($1, hlist, 1,
			    SNMPD_TRAPPORT, $2, $3, $4) <= 0) {
				yyerror("invalid host: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

hostlist	: /* empty */
		| hostlist comma hostdef
		;

host		: hostdef
		| '{' hostlist '}'
		;

comma		: /* empty */
		| ','
		;

seclevel	: NONE		{ $$ = 0; }
		| AUTH		{ $$ = SNMP_MSGFLAG_AUTH; }
		| ENC		{ $$ = SNMP_MSGFLAG_AUTH | SNMP_MSGFLAG_PRIV; }
		;

userspecs	: /* empty */
		| userspecs userspec
		;

userspec	: AUTHKEY STRING		{
			user->uu_authkey = $2;
		}
		| AUTH auth			{
			user->uu_auth = $2;
		}
		| ENCKEY STRING			{
			user->uu_privkey = $2;
		}
		| ENC enc			{
			user->uu_priv = $2;
		}
		;

auth		: STRING			{
			if (strcasecmp($1, "hmac-md5") == 0 ||
			    strcasecmp($1, "hmac-md5-96") == 0)
				$$ = AUTH_MD5;
			else if (strcasecmp($1, "hmac-sha1") == 0 ||
			     strcasecmp($1, "hmac-sha1-96") == 0)
				$$ = AUTH_SHA1;
			else {
				yyerror("syntax error, bad auth hmac");
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

enc		: STRING			{
			if (strcasecmp($1, "des") == 0 ||
			    strcasecmp($1, "cbc-des") == 0)
				$$ = PRIV_DES;
			else if (strcasecmp($1, "aes") == 0 ||
			    strcasecmp($1, "cfb128-aes-128") == 0)
				$$ = PRIV_AES;
			else {
				yyerror("syntax error, bad encryption cipher");
				free($1);
				YYERROR;
			}
			free($1);

		}
		;

socktype	: RESTRICTED		{ $$ = SOCK_TYPE_RESTRICTED; }
		| AGENTX		{ $$ = SOCK_TYPE_AGENTX; }
		| /* nothing */		{ $$ = 0; }
		;

cmd		: STRING		{
			struct trapcmd	*cmd;
			size_t		 span, limit;
			char		*pos, **args, **args2;
			int		 nargs = 32;		/* XXX */

			if ((cmd = calloc(1, sizeof(*cmd))) == NULL ||
			    (args = calloc(nargs, sizeof(char *))) == NULL) {
				free(cmd);
				free($1);
				YYERROR;
			}

			pos = $1;
			limit = strlen($1);

			while (pos < $1 + limit &&
			    (span = strcspn(pos, " \t")) != 0) {
				pos[span] = '\0';
				args[cmd->cmd_argc] = strdup(pos);
				if (args[cmd->cmd_argc] == NULL) {
					trapcmd_free(cmd);
					free(args);
					free($1);
					YYERROR;
				}
				cmd->cmd_argc++;
				if (cmd->cmd_argc >= nargs - 1) {
					nargs *= 2;
					args2 = calloc(nargs, sizeof(char *));
					if (args2 == NULL) {
						trapcmd_free(cmd);
						free(args);
						free($1);
						YYERROR;
					}
					args = args2;
				}
				pos += span + 1;
			}
			free($1);
			cmd->cmd_argv = args;
			$$.data = cmd;
		}
		;

%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;
	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		fatalx("yyerror vasprintf");
	va_end(ap);
	logit(LOG_CRIT, "%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "agentx",		AGENTX },
		{ "auth",		AUTH },
		{ "authkey",		AUTHKEY },
		{ "community",		COMMUNITY },
		{ "contact",		CONTACT },
		{ "default",		DEFAULT },
		{ "description",	DESCR },
		{ "disabled",		DISABLED},
		{ "enc",		ENC },
		{ "enckey",		ENCKEY },
		{ "filter-routes",	RTFILTER },
		{ "handle",		HANDLE },
		{ "include",		INCLUDE },
		{ "integer",		INTEGER },
		{ "listen",		LISTEN },
		{ "location",		LOCATION },
		{ "name",		NAME },
		{ "none",		NONE },
		{ "oid",		OBJECTID },
		{ "on",			ON },
		{ "read-only",		READONLY },
		{ "read-write",		READWRITE },
		{ "receiver",		RECEIVER },
		{ "restricted",		RESTRICTED },
		{ "seclevel",		SECLEVEL },
		{ "services",		SERVICES },
		{ "socket",		SOCKET },
		{ "source-address",	SRCADDR },
		{ "string",		OCTETSTRING },
		{ "system",		SYSTEM },
		{ "trap",		TRAP },
		{ "user",		USER }
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(file->stream);
		} while (c == '\t' || c == ' ');
		ungetc(c, file->stream);
		c = ' ';
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && \
	x != '!' && x != '=' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		log_warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		log_warnx("%s: group writable or world read/writable", fname);
		return (-1);
	}
	return (0);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		log_warn("malloc");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		log_warn("malloc");
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		log_warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

struct snmpd *
parse_config(const char *filename, u_int flags)
{
	struct sym	*sym, *next;

	if ((conf = calloc(1, sizeof(*conf))) == NULL) {
		log_warn("cannot allocate memory");
		return (NULL);
	}

	conf->sc_flags = flags;
	conf->sc_confpath = filename;
	TAILQ_INIT(&conf->sc_addresses);
	TAILQ_INIT(&conf->sc_sockets);
	conf->sc_ps.ps_csock.cs_name = SNMPD_SOCKET;
	TAILQ_INIT(&conf->sc_ps.ps_rcsocks);
	strlcpy(conf->sc_rdcommunity, "public", SNMPD_MAXCOMMUNITYLEN);
	strlcpy(conf->sc_rwcommunity, "private", SNMPD_MAXCOMMUNITYLEN);
	strlcpy(conf->sc_trcommunity, "public", SNMPD_MAXCOMMUNITYLEN);
	TAILQ_INIT(&conf->sc_trapreceivers);

	if ((file = pushfile(filename, 0)) == NULL) {
		free(conf);
		return (NULL);
	}
	topfile = file;
	setservent(1);

	yyparse();
	errors = file->errors;
	popfile();

	endservent();

	if (TAILQ_EMPTY(&conf->sc_addresses)) {
		struct address		*h;
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal("snmpe: %s", __func__);
		h->ss.ss_family = AF_INET;
		h->port = SNMPD_PORT;
		TAILQ_INSERT_TAIL(&conf->sc_addresses, h, entry);
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal("snmpe: %s", __func__);
		h->ss.ss_family = AF_INET6;
		h->port = SNMPD_PORT;
		TAILQ_INSERT_TAIL(&conf->sc_addresses, h, entry);
	}

	/* Free macros and check which have not been used. */
	TAILQ_FOREACH_SAFE(sym, &symhead, entry, next) {
		if ((conf->sc_flags & SNMPD_F_VERBOSE) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	if (errors) {
		free(conf);
		return (NULL);
	}

	return (conf);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		errx(1, "cmdline_symset: malloc");

	(void)strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

struct address *
host_v4(const char *s)
{
	struct in_addr		 ina;
	struct sockaddr_in	*sain;
	struct address		*h;

	bzero(&ina, sizeof(ina));
	if (inet_pton(AF_INET, s, &ina) != 1)
		return (NULL);

	if ((h = calloc(1, sizeof(*h))) == NULL)
		fatal(__func__);
	sain = (struct sockaddr_in *)&h->ss;
	sain->sin_len = sizeof(struct sockaddr_in);
	sain->sin_family = AF_INET;
	sain->sin_addr.s_addr = ina.s_addr;

	return (h);
}

struct address *
host_v6(const char *s)
{
	struct addrinfo		 hints, *res;
	struct sockaddr_in6	*sa_in6;
	struct address		*h = NULL;

	bzero(&hints, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_DGRAM; /* dummy */
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(s, "0", &hints, &res) == 0) {
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal(__func__);
		sa_in6 = (struct sockaddr_in6 *)&h->ss;
		sa_in6->sin6_len = sizeof(struct sockaddr_in6);
		sa_in6->sin6_family = AF_INET6;
		memcpy(&sa_in6->sin6_addr,
		    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr,
		    sizeof(sa_in6->sin6_addr));
		sa_in6->sin6_scope_id =
		    ((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id;

		freeaddrinfo(res);
	}

	return (h);
}

int
host_dns(const char *s, struct addresslist *al, int max,
	in_port_t port, struct ber_oid *oid, char *cmn, struct address *src)
{
	struct addrinfo		 hints, *res0, *res;
	int			 error, cnt = 0;
	struct sockaddr_in	*sain;
	struct sockaddr_in6	*sin6;
	struct address		*h;

	bzero(&hints, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM; /* DUMMY */
	hints.ai_flags = AI_ADDRCONFIG;
	error = getaddrinfo(s, NULL, &hints, &res0);
	if (error == EAI_AGAIN || error == EAI_NODATA || error == EAI_NONAME)
		return (0);
	if (error) {
		log_warnx("host_dns: could not parse \"%s\": %s", s,
		    gai_strerror(error));
		return (-1);
	}

	for (res = res0; res && cnt < max; res = res->ai_next) {
		if (res->ai_family != AF_INET &&
		    res->ai_family != AF_INET6)
			continue;
		if (src != NULL && src->ss.ss_family != res->ai_family)
			continue;
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal(__func__);

		h->port = port;
		if (oid != NULL) {
			if ((h->sa_oid = calloc(1, sizeof(*oid))) == NULL)
				fatal(__func__);
			bcopy(oid, h->sa_oid, sizeof(*oid));
		}
		if (cmn != NULL) {
			if ((h->sa_community = strdup(cmn)) == NULL)
				fatal(__func__);
		}

		h->ss.ss_family = res->ai_family;
		if (res->ai_family == AF_INET) {
			sain = (struct sockaddr_in *)&h->ss;
			sain->sin_len = sizeof(struct sockaddr_in);
			sain->sin_addr.s_addr = ((struct sockaddr_in *)
			    res->ai_addr)->sin_addr.s_addr;
		} else {
			sin6 = (struct sockaddr_in6 *)&h->ss;
			sin6->sin6_len = sizeof(struct sockaddr_in6);
			memcpy(&sin6->sin6_addr, &((struct sockaddr_in6 *)
			    res->ai_addr)->sin6_addr, sizeof(struct in6_addr));
		}

		h->sa_srcaddr = src;

		TAILQ_INSERT_TAIL(al, h, entry);
		cnt++;
	}
	if (cnt == max && res) {
		log_warnx("host_dns: %s resolves to more than %d hosts",
		    s, max);
	}
	freeaddrinfo(res0);
	if (oid != NULL)
		free(oid);
	if (cmn != NULL)
		free(cmn);
	return (cnt);
}

int
host(const char *s, struct addresslist *al, int max,
    in_port_t port, struct ber_oid *oid, char *cmn, char *srcaddr)
{
	struct address	*h, *src = NULL;

	if (srcaddr != NULL) {
		src = host_v4(srcaddr);
		if (src == NULL)
			src = host_v6(srcaddr);
		if (src == NULL) {
			log_warnx("invalid source-address %s", srcaddr);
			return (-1);
		}
	}

	h = host_v4(s);

	/* IPv6 address? */
	if (h == NULL)
		h = host_v6(s);

	if (h != NULL) {
		h->port = port;
		h->sa_oid = oid;
		h->sa_community = cmn;
		if (src != NULL && h->ss.ss_family != src->ss.ss_family) {
			log_warnx("host and source-address family mismatch");
			return (-1);
		}
		h->sa_srcaddr = src;

		TAILQ_INSERT_TAIL(al, h, entry);
		return (1);
	}

	return (host_dns(s, al, max, port, oid, cmn, src));
}
@


1.44
log
@Use a format string for yyerror when printing a variable string.
Pointed out by clang.
(Not really a problem here since we control the string, but these
things tend to get coppied around)
ok gerhard@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.43 2017/01/05 13:53:10 krw Exp $	*/
d528 1
a528 1
			struct		 trapcmd *cmd;
d543 2
a544 2
			while ((span = strcspn(pos, " \t")) != 0 &&
			    pos < $1 + limit) {
@


1.43
log
@Replace hand-rolled for(;;) emptying of 'symhead' TAILQ with more
modern TAILQ_FOREACH_SAFE().

No intentional functional change.

ok millert@@ bluhm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.42 2017/01/05 12:42:19 krw Exp $	*/
d276 1
a276 1
				yyerror(errstr);
d283 1
a283 1
				yyerror(errstr);
@


1.42
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2016/11/18 16:16:39 jca Exp $	*/
d1017 1
a1017 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
@


1.41
log
@Add support for multiple listening sockets

One can now specify multiple "listen on" statements. The default is to
listen on 0.0.0.0 and ::, which means better handling of dual-stack
setups.  ok sthen@@ on a previous version, input and ok reyk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2016/11/09 20:31:56 jca Exp $	*/
d1043 4
a1046 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d1105 1
a1105 1
	TAILQ_FOREACH(sym, &symhead, entry)
d1110 1
@


1.40
log
@Improve source IP address handling.

- send replies using a source address equal to the destination address
  of queries, using IP_SENDSRCADDR.  This help in multihomed setups and
  can remove the need to explicitely configure a bind address.
- config knob to set the source address of packets sent to trap
  receivers.  "trap receiver" gains an optional "source-address"
  setting.

Source address issues reported by Andy Lemin.  ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.39 2016/06/21 21:35:25 benno Exp $	*/
d201 2
a202 6
			struct addresslist	 al;
			struct address		*h;

			TAILQ_INIT(&al);
			if (host($3, &al, 1, SNMPD_PORT, NULL, NULL, NULL)
			    <= 0) {
a207 8
			h = TAILQ_FIRST(&al);
			bcopy(&h->ss, &conf->sc_address.ss, sizeof(*h));
			conf->sc_address.port = h->port;

			while ((h = TAILQ_FIRST(&al)) != NULL) {
				TAILQ_REMOVE(&al, h, entry);
				free(h);
			}
d980 2
a981 2
	conf->sc_address.ss.ss_family = AF_INET;
	conf->sc_address.port = SNMPD_PORT;
d1002 14
d1220 1
a1220 1
		TAILQ_INSERT_HEAD(al, h, entry);
d1267 1
a1267 1
		TAILQ_INSERT_HEAD(al, h, entry);
@


1.39
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2015/11/22 13:27:13 reyk Exp $	*/
d101 2
a102 1
		    int, in_port_t, struct ber_oid *, char *);
d104 1
a104 1
		    int, in_port_t, struct ber_oid *, char *);
d131 1
a131 1
%token	SOCKET RESTRICTED AGENTX HANDLE DEFAULT
d135 1
d205 2
a206 1
			if (host($3, &al, 1, SNMPD_PORT, NULL, NULL) <= 0) {
d451 5
a455 1
hostdef		: STRING hostoid hostcmn		{
d457 1
a457 1
			    SNMPD_TRAPPORT, $2, $3) <= 0) {
d646 1
d1162 1
a1162 1
	 in_port_t port, struct ber_oid *oid, char *cmn)
d1187 2
d1216 2
d1235 1
a1235 1
    in_port_t port, struct ber_oid *oid, char *cmn)
d1237 11
a1247 1
	struct address	*h;
d1259 5
d1269 1
a1269 1
	return (host_dns(s, al, max, port, oid, cmn));
@


1.38
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2015/02/08 04:50:32 reyk Exp $	*/
d168 8
@


1.37
log
@Use AI_ADDRCONFIG when resolv hosts on startup.

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.36 2014/11/20 05:51:21 jsg Exp $	*/
d1106 1
a1106 1
		fatal(NULL);
d1128 1
a1128 1
			fatal(NULL);
d1172 1
a1172 1
			fatal(NULL);
d1177 1
a1177 1
				fatal(NULL);
d1182 1
a1182 1
				fatal(NULL);
@


1.36
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2014/11/19 10:19:00 blambert Exp $	*/
d1157 1
@


1.35
log
@add support for AgentX subagents in snmpd

snmp requests are now packaged into pseudo-continuations
to allow for being dispatched to seperate processes;
lightly tested for interoperability with NetSNMP, but
doesn't implement the complete set of AgentX messages

while here, clean up return types of mps_get* functions,
and make smi_insert refuse to insert duplicate OIDs

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2014/11/16 19:07:51 bluhm Exp $	*/
d815 3
@


1.34
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2014/11/14 03:20:37 doug Exp $	*/
d375 6
a380 1
			smi_insert(oid);
@


1.33
log
@Add gcc printf format attributes to yyerror() in parse.y files.
No yyerror() calls needed to be changed.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2014/04/25 06:57:11 blambert Exp $	*/
d576 1
a576 1
	char		*nfmt;
d580 2
a581 3
	if (asprintf(&nfmt, "%s:%d: %s", file->name, yylval.lineno, fmt) == -1)
		fatalx("yyerror asprintf");
	vlog(LOG_CRIT, nfmt, ap);
d583 2
a584 1
	free(nfmt);
@


1.32
log
@Support running user-defined actions on receipt of snmp traps.

testing sthen@@
much man page guidance jmc@@
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2014/04/24 08:51:08 blambert Exp $	*/
d72 3
a74 1
int		 yyerror(const char *, ...);
@


1.31
log
@fix copied text in error string

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2014/04/14 12:55:10 blambert Exp $	*/
d128 1
a128 1
%token	SOCKET RESTRICTED AGENTX
d133 2
a134 2
%type	<v.data>	objtype
%type	<v.oid>		oid hostoid
d246 13
d412 13
d517 46
d602 1
d608 1
@


1.30
log
@Make snmpd use the AgentX protcol for accepting trap requests.
AgentX notifications are the only portion implemented right now;
get in the tree to flesh out the remainder.

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2014/01/22 00:21:17 henning Exp $	*/
d235 1
a235 1
				yyerror("r/w community name too long");
@


1.29
log
@relax the cfg file secrecy check slightly to allow group readability
default permissions and mtree NOT changed.
prodded by benno, ok phessler benno jmatthew theo pelikan florian
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2013/10/17 08:42:44 reyk Exp $	*/
d54 5
d128 1
a128 1
%token	SOCKET RESTRICTED
d132 1
a132 1
%type	<v.number>	optwrite yesno seclevel restricted
d274 1
a274 1
		| SOCKET STRING restricted {
d284 4
a287 1
				rcsock->cs_restricted = 1;
d486 2
a487 1
restricted	: RESTRICTED		{ $$ = 1; }
d525 1
@


1.28
log
@use u_char for buffers in yylex, for ctype calls
found by millert@@, ok deraadt@@
@
text
@d816 2
a817 2
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		log_warnx("%s: group/world readable/writeable", fname);
@


1.27
log
@Update snmpd(8) to use the proc.c privsep style from iked and relayd.

ok sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2013/10/16 16:05:02 blambert Exp $	*/
d558 1
a558 1
char	*parsebuf;
d560 1
a560 1
char	 pushback_buffer[MAXPUSHBACK];
d660 2
a661 2
	char	 buf[8096];
	char	*p, *val;
d684 1
a684 1
				*p++ = (char)c;
d729 1
a729 1
			*p++ = (char)c;
@


1.26
log
@ 1) move the creation of 'restricted' communication sockets
    into snmpd.conf
 2) add the ability to specify an alternate 'control' socket location
 3) allow for the creation of multiple 'restricted' sockets (but
    only one control socket, for the time being)

Committing slightly ahead of schedule in order to clear the pipeline
for a few other upcoming changes.

ok reyk@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2013/03/29 12:53:41 gerhard Exp $	*/
d280 2
a281 2
				TAILQ_INSERT_TAIL(&conf->sc_rcsocks, rcsock,
				    cs_entry);
d288 1
a288 1
				conf->sc_csock.cs_name = $2;
d884 2
a885 2
	conf->sc_csock.cs_name = SNMPD_SOCKET;
	TAILQ_INIT(&conf->sc_rcsocks);
@


1.25
log
@Patch from Ilya Bakulin that allows to put snmpd(8) into read-only mode
so that all "set" requests will be rejected.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2013/03/06 21:42:40 sthen Exp $	*/
d89 1
d123 1
d127 1
a127 1
%type	<v.number>	optwrite yesno seclevel
d269 22
d478 4
d536 1
d539 1
d884 2
@


1.24
log
@as done in ospf{,6}d/relayd, sync yyerror in various other daemons with
that from bgpd, so that it logs to syslog when daemonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2012/09/17 19:00:06 reyk Exp $	*/
d121 1
a121 1
%token	SECLEVEL NONE AUTH ENC USER AUTHKEY ENCKEY ERROR
d221 3
d493 1
@


1.23
log
@let the debug message look like the configuration syntax
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2012/09/17 16:43:59 reyk Exp $	*/
d49 1
d462 1
d466 3
a468 3
	fprintf(stderr, "%s:%d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
d470 1
@


1.22
log
@Update copyright and my email address in snmpd while I'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2012/09/17 16:30:34 reyk Exp $	*/
d418 2
a419 1
			if (!strcasecmp($1, "hmac-md5"))
d421 2
a422 1
			else if (!strcasecmp($1, "hmac-sha1"))
d434 2
a435 1
			if (!strcasecmp($1, "des"))
d437 2
a438 1
			else if (!strcasecmp($1, "aes"))
@


1.21
log
@Add initial SNMPv3 support to snmpd(8).

Traps are still sent via SNMPv2 protocol. They can neither be
authenticated nor encrypted. - Transport mode is still UDP. Not
additional transport subsystems were added. - Only the User-based
Security Model (USM, RFC3414) is supported.  View-Based Access Control
(VACM, RFC3415) is not included. - Configuration is described in
snmpd.conf(5).

This diff includes a few minor changes to ber.c/h adding a necessary
callback for the USM HMAC calculation and merging it with other
minor changes from ldapd's ber code.

From Gerhard Roth at genua
ok claudio@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2011/04/21 14:55:22 sthen Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007, 2008 Reyk Floeter <reyk@@vantronix.net>
@


1.20
log
@Add a "filter-routes" option; when set, snmpd asks the kernel not to
send route updates. If you aren't interested in examining routing tables
over SNMP (e.g. if you only use it for sensors or interface stats) this
reduces cpu use during heavy route updates. Makes my full-table bgp
routers happier when a major peer bounces.  ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2010/10/18 13:29:49 sthen Exp $	*/
d87 1
d108 2
d120 1
a120 1
%token	ERROR
d124 1
a124 1
%type	<v.number>	optwrite yesno
d127 2
d244 19
d394 52
d478 2
d483 2
d491 1
d497 1
d501 2
a502 1
		{ "trap",		TRAP }
@


1.19
log
@Missing ; to appease yyextract, ok martinh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2010/08/03 18:42:41 henning Exp $	*/
d115 1
a115 1
%token	SYSTEM CONTACT DESCR LOCATION NAME OBJECTID SERVICES
d121 1
a121 1
%type	<v.number>	optwrite
d160 15
d230 9
d405 1
@


1.18
log
@fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432
applied to all the others by yours truly. ok theo
isn't it amazing how far this parser (and more) spread?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2009/03/31 21:03:49 tobias Exp $	*/
d150 1
@


1.17
log
@Fixed memory leaks which would occur if the second of two memory
allocations fails.

looks right deraadt, krw
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2008/10/17 13:02:55 henning Exp $	*/
d566 2
a567 1
				else if (next == '\n')
d569 1
a569 1
				else
@


1.16
log
@bring in the findeol() fix from pfctl. list of affected parsers by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2008/07/18 12:35:27 reyk Exp $	*/
d677 1
a677 2
	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
d679 5
@


1.15
log
@merge host_v6 with relayd's version to use getaddrinfo instead of
inet_pton.  host_v4, host_v6, and host_dns could be merged into one
function using getaddrinfo but i keep it in multiple functions to keep
it in sync with the other daemons using this common code.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2008/02/27 15:12:10 mpf Exp $	*/
a489 1
	pushback_index = 0;
d493 4
a496 1
		c = lgetc(0);
@


1.14
log
@Unbreak parser by initializing topfile correctly.
I got fooled by patch(1). Sorry.
Found by and OK thib@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2008/02/27 10:30:11 mpf Exp $	*/
d865 19
a883 3
	struct in6_addr		 ina6;
	struct sockaddr_in6	*sin6;
	struct address		*h;
d885 2
a886 10
	bzero(&ina6, sizeof(ina6));
	if (inet_pton(AF_INET6, s, &ina6) != 1)
		return (NULL);

	if ((h = calloc(1, sizeof(*h))) == NULL)
		fatal(NULL);
	sin6 = (struct sockaddr_in6 *)&h->ss;
	sin6->sin6_len = sizeof(struct sockaddr_in6);
	sin6->sin6_family = AF_INET6;
	memcpy(&sin6->sin6_addr, &ina6, sizeof(ina6));
@


1.13
log
@Have popfile() also close the main config file,
but only do the final popfile call after yyparse() is done.
This also fixes config reload on SIGHUP for some daemons.

Spotted by otto@@. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2008/02/26 20:06:14 claudio Exp $	*/
a721 1
	topfile = file;
d736 1
@


1.12
log
@Fix memory leak in the parser. Found by Matthew Dempsky but using the more
common way to clear the TAILQ. OK thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2008/01/30 10:12:45 reyk Exp $	*/
d60 1
a60 1
} *file;
d435 1
a435 1
			if (popfile() == EOF)
d461 1
a461 1
		if (popfile() == EOF)
d702 1
a702 1
	if ((prev = TAILQ_PREV(file, files, entry)) != NULL) {
d704 7
a710 8
		TAILQ_REMOVE(&files, file, entry);
		fclose(file->stream);
		free(file->name);
		free(file);
		file = prev;
		return (0);
	}
	return (EOF);
d722 1
@


1.11
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2008/01/17 17:35:06 reyk Exp $	*/
d173 5
@


1.10
log
@allow to configure optional per trap receiver communities and to
restrict the receivers to a specified mib.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2008/01/16 19:36:06 reyk Exp $	*/
d204 1
a204 1
		| TRAP RECEIVER 		{
@


1.9
log
@implementation of the SNMP trap sender interface
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2008/01/16 09:51:15 reyk Exp $	*/
d91 1
a91 1
		    int, in_port_t, const char *);
d93 1
a93 1
		    int, in_port_t, const char *);
d120 1
d123 1
a123 1
%type	<v.oid>		oid
d164 1
a164 1
			if (host($3, &al, 1, SNMPD_PORT, NULL) <= 0) {
d309 9
a317 1
hostdef		: STRING			{
d319 1
a319 1
			    SNMPD_TRAPPORT, NULL) <= 0) {
d880 1
a880 1
	 in_port_t port, const char *ifname)
d908 8
a915 5
		if (ifname != NULL) {
			if (strlcpy(h->ifname, ifname, sizeof(h->ifname)) >=
			    sizeof(h->ifname))
				log_warnx("host_dns: interface name truncated");
			return (-1);
d917 1
d939 4
d948 1
a948 1
    in_port_t port, const char *ifname)
d950 1
a950 1
	struct address *h;
d960 2
a961 7
		if (ifname != NULL) {
			if (strlcpy(h->ifname, ifname, sizeof(h->ifname)) >=
			    sizeof(h->ifname)) {
				log_warnx("host: interface name truncated");
				return (-1);
			}
		}
d967 1
a967 1
	return (host_dns(s, al, max, port, ifname));
@


1.8
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2007/12/28 17:36:55 reyk Exp $	*/
d84 3
a86 2
struct snmpd		*conf = NULL;
static int		 errors = 0;
d116 1
a116 1
%token	READONLY READWRITE OCTETSTRING INTEGER COMMUNITY TRAP
d203 5
d308 23
d375 1
d717 1
@


1.7
log
@set the default port in host byte order to get the correct result
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2007/12/28 16:59:31 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007 Reyk Floeter <reyk@@vantronix.net>
@


1.6
log
@split code handling the "structure of management information" and the
"message processing subsystem" into separate files smi.c and mps.c
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2007/12/28 15:33:37 reyk Exp $	*/
d683 1
a683 1
	conf->sc_address.port = htons(SNMPD_PORT);
@


1.5
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2007/12/28 15:32:02 reyk Exp $	*/
d243 1
a243 1
			mps_oidlen($2);
d263 1
a263 1
			mps_insert(oid);
@


1.4
log
@use the snmp camelCase for MIB definitions, this allows to simplify
the code a bit and is mostly a stylistic change.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2007/12/07 10:22:38 reyk Exp $	*/
d158 1
a158 1
			struct addresslist 	 al;
@


1.3
log
@remove unreduced rules
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2007/12/05 22:57:02 reyk Exp $	*/
d208 1
a208 1
			struct ber_oid	 o = OID(MIB_SYSCONTACT);
d212 1
a212 1
			struct ber_oid	 o = OID(MIB_SYSDESCR);
d216 1
a216 1
			struct ber_oid	 o = OID(MIB_SYSLOCATION);
d220 1
a220 1
			struct ber_oid	 o = OID(MIB_SYSNAME);
d224 1
a224 1
			struct ber_oid	 o = OID(MIB_SYSOID);
d228 1
a228 1
			struct ber_oid	 o = OID(MIB_SYSSERVICES);
@


1.2
log
@re-sync yylex to the other parsers

found by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2007/12/05 09:22:44 reyk Exp $	*/
a299 11
		;

comma		: ','
		| /* empty */
		;

optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl
@


1.1
log
@Start working on snmpd(8) and snmpctl(8), a lightweight SNMP implementation
for OpenBSD.  SNMP is a necessary evil.  This is work in progress, don't
expect too much from it yet.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2007/11/10 13:52:34 reyk Exp $	*/
d482 1
a482 1
	while ((c = lgetc(0)) == ' ')
@

