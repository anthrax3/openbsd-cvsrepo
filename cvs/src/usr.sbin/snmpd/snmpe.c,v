head	1.50;
access;
symbols
	OPENBSD_6_1:1.46.0.4
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.41.0.4
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.32.0.2
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.28.0.8
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.6
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.4
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16;
locks; strict;
comment	@ * @;


1.50
date	2017.08.12.16.31.09;	author florian;	state Exp;
branches;
next	1.49;
commitid	KdkubmhDljuvieOJ;

1.49
date	2017.08.12.04.29.57;	author rob;	state Exp;
branches;
next	1.48;
commitid	C4V8ON55bE0Lfuf0;

1.48
date	2017.07.27.14.04.16;	author gerhard;	state Exp;
branches;
next	1.47;
commitid	2bchMAegtXnMPBmd;

1.47
date	2017.04.21.13.50.23;	author jca;	state Exp;
branches;
next	1.46;
commitid	0khcEEJIl2QP335t;

1.46
date	2016.11.18.16.16.39;	author jca;	state Exp;
branches;
next	1.45;
commitid	5lrkdv6CJEuqxjzU;

1.45
date	2016.11.09.20.31.56;	author jca;	state Exp;
branches;
next	1.44;
commitid	W7m2j1sZd5b467J6;

1.44
date	2016.10.28.09.07.08;	author rzalamena;	state Exp;
branches;
next	1.43;
commitid	Uh6U1yLTyYRsvccR;

1.43
date	2016.10.28.08.01.53;	author rzalamena;	state Exp;
branches;
next	1.42;
commitid	SMslalgbhOIf4OXA;

1.42
date	2016.08.16.18.41.57;	author tedu;	state Exp;
branches;
next	1.41;
commitid	eyeRGwF24702KeRh;

1.41
date	2015.10.08.08.17.30;	author sthen;	state Exp;
branches;
next	1.40;
commitid	zteDEVyy8dewN13K;

1.40
date	2015.01.16.00.05.13;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	khLbW7SmDyckNaAs;

1.39
date	2014.11.19.10.19.00;	author blambert;	state Exp;
branches;
next	1.38;
commitid	cXioMeUnRYhFJvcH;

1.38
date	2014.04.21.19.47.27;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2013.10.17.08.42.44;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2013.10.16.16.05.03;	author blambert;	state Exp;
branches;
next	1.35;

1.35
date	2013.10.01.12.41.48;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2013.09.26.09.11.30;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2013.03.29.12.53.41;	author gerhard;	state Exp;
branches;
next	1.32;

1.32
date	2012.11.29.14.53.24;	author yasuoka;	state Exp;
branches;
next	1.31;

1.31
date	2012.09.18.08.29.09;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2012.09.17.16.43.59;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2012.09.17.16.30.35;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2010.09.20.12.32.41;	author martinh;	state Exp;
branches;
next	1.27;

1.27
date	2010.09.20.08.56.16;	author martinh;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.20.08.33.18;	author martinh;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.16.22.17.53;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2009.06.06.05.52.01;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2008.12.08.11.34.55;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.05.12.34.01;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2008.09.26.15.19.55;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2008.09.03.13.41.49;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.18.12.30.06;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.12.14.11.52;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.12.13.12.42;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.09.13.03.01;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.16.21.43.19;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.16.19.36.06;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.16.09.51.15;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.16.09.42.29;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.16.09.36.30;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.12.13.57.43;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.11.12.12.14;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.03.15.32.48;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.03.15.03.47;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.03.14.24.15;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.28.16.59.31;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.27.20.39.32;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.07.09.50.51;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.07.09.18.00;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.05.09.22.44;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Make not yet implemented pledges more visible in grep output.
input benno, deraadt, tedu
also standardize on #if 0 since it makes tedu's editor vomit.
OK benno, pirofti on a previous version
@
text
@/*	$OpenBSD: snmpe.c,v 1.49 2017/08/12 04:29:57 rob Exp $	*/

/*
 * Copyright (c) 2007, 2008, 2012 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/tree.h>

#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <pwd.h>

#include "snmpd.h"
#include "mib.h"

void	 snmpe_init(struct privsep *, struct privsep_proc *, void *);
int	 snmpe_parse(struct snmp_message *);
int	 snmpe_parsevarbinds(struct snmp_message *);
void	 snmpe_response(struct snmp_message *);
unsigned long
	 snmpe_application(struct ber_element *);
void	 snmpe_sig_handler(int sig, short, void *);
int	 snmpe_dispatch_parent(int, struct privsep_proc *, struct imsg *);
int	 snmpe_bind(struct address *);
void	 snmpe_recvmsg(int fd, short, void *);
int	 snmpe_encode(struct snmp_message *);
void	 snmp_msgfree(struct snmp_message *);

struct imsgev	*iev_parent;

static struct privsep_proc procs[] = {
	{ "parent",	PROC_PARENT,	snmpe_dispatch_parent }
};

void
snmpe(struct privsep *ps, struct privsep_proc *p)
{
	struct snmpd		*env = ps->ps_env;
	struct address		*h;
	struct listen_sock	*so;
#ifdef DEBUG
	char		 buf[BUFSIZ];
	struct oid	*oid;
#endif

#ifdef DEBUG
	for (oid = NULL; (oid = smi_foreach(oid, 0)) != NULL;) {
		smi_oid2string(&oid->o_id, buf, sizeof(buf), 0);
		log_debug("oid %s", buf);
	}
#endif

	TAILQ_FOREACH(h, &env->sc_addresses, entry) {
		if ((so = calloc(1, sizeof(*so))) == NULL)
			fatal("snmpe: %s", __func__);
		if ((so->s_fd = snmpe_bind(h)) == -1)
			fatal("snmpe: failed to bind SNMP UDP socket");
		TAILQ_INSERT_TAIL(&env->sc_sockets, so, entry);
	}

	proc_run(ps, p, procs, nitems(procs), snmpe_init, NULL);
}

/* ARGSUSED */
void
snmpe_init(struct privsep *ps, struct privsep_proc *p, void *arg)
{
	struct snmpd		*env = ps->ps_env;
	struct listen_sock	*so;

	kr_init();
	trap_init();
	timer_init();
	usm_generate_keys();

	/* listen for incoming SNMP UDP messages */
	TAILQ_FOREACH(so, &env->sc_sockets, entry) {
		event_set(&so->s_ev, so->s_fd, EV_READ|EV_PERSIST,
		    snmpe_recvmsg, env);
		event_add(&so->s_ev, NULL);
	}

#if 0
	/*
	 * XXX Refactoring required to move illegal ioctls and sysctls.
	 * XXX See mps_* and if_mib in mib.c, etc.
	 */
BROKEN	if (pledge("stdio inet route recvfd vminfo", NULL) == -1)
		fatal("pledge");
#endif
}

void
snmpe_shutdown(void)
{
	kr_shutdown();
}

int
snmpe_dispatch_parent(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	switch (imsg->hdr.type) {
	default:
		break;
	}

	return (-1);
}

int
snmpe_bind(struct address *addr)
{
	char	 buf[512];
	int	 val, s;

	if ((s = snmpd_socket_af(&addr->ss, htons(addr->port))) == -1)
		return (-1);

	/*
	 * Socket options
	 */
	if (fcntl(s, F_SETFL, O_NONBLOCK) == -1)
		goto bad;

	switch (addr->ss.ss_family) {
	case AF_INET:
		val = 1;
		if (setsockopt(s, IPPROTO_IP, IP_RECVDSTADDR,
		    &val, sizeof(int)) == -1) {
			log_warn("%s: failed to set IPv4 packet info",
			    __func__);
			goto bad;
		}
		break;
	case AF_INET6:
		val = 1;
		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVPKTINFO,
		    &val, sizeof(int)) == -1) {
			log_warn("%s: failed to set IPv6 packet info",
			    __func__);
			goto bad;
		}
	}

	if (bind(s, (struct sockaddr *)&addr->ss, addr->ss.ss_len) == -1)
		goto bad;

	if (print_host(&addr->ss, buf, sizeof(buf)) == NULL)
		goto bad;

	log_info("snmpe: listening on %s:%d", buf, addr->port);

	return (s);

 bad:
	close(s);
	return (-1);
}

int
snmpe_parse(struct snmp_message *msg)
{
	struct snmpd		*env = snmpd_env;
	struct snmp_stats	*stats = &env->sc_stats;
	struct ber_element	*a;
	long long		 ver, req;
	long long		 errval, erridx;
	unsigned long		 type;
	u_int			 class;
	char			*comn;
	char			*flagstr, *ctxname;
	size_t			 len;
	struct sockaddr_storage *ss = &msg->sm_ss;
	struct ber_element	*root = msg->sm_req;

	msg->sm_errstr = "invalid message";

	if (ber_scanf_elements(root, "{ie", &ver, &a) != 0)
		goto parsefail;

	/* SNMP version and community */
	msg->sm_version = ver;
	switch (msg->sm_version) {
	case SNMP_V1:
	case SNMP_V2:
		if (env->sc_min_seclevel != 0)
			goto badversion;
		if (ber_scanf_elements(a, "se", &comn, &msg->sm_pdu) != 0)
			goto parsefail;
		if (strlcpy(msg->sm_community, comn,
		    sizeof(msg->sm_community)) >= sizeof(msg->sm_community)) {
			stats->snmp_inbadcommunitynames++;
			msg->sm_errstr = "community name too long";
			goto fail;
		}
		break;
	case SNMP_V3:
		if (ber_scanf_elements(a, "{iisi}e",
		    &msg->sm_msgid, &msg->sm_max_msg_size, &flagstr,
		    &msg->sm_secmodel, &a) != 0)
			goto parsefail;

		msg->sm_flags = *flagstr;
		if (MSG_SECLEVEL(msg) < env->sc_min_seclevel ||
		    msg->sm_secmodel != SNMP_SEC_USM) {
			/* XXX currently only USM supported */
			msg->sm_errstr = "unsupported security model";
			stats->snmp_usmbadseclevel++;
			msg->sm_usmerr = OIDVAL_usmErrSecLevel;
			goto parsefail;
		}

		if ((a = usm_decode(msg, a, &msg->sm_errstr)) == NULL)
			goto parsefail;

		if (ber_scanf_elements(a, "{xxe",
		    &msg->sm_ctxengineid, &msg->sm_ctxengineid_len,
		    &ctxname, &len, &msg->sm_pdu) != 0)
			goto parsefail;
		if (len > SNMPD_MAXCONTEXNAMELEN)
			goto parsefail;
		memcpy(msg->sm_ctxname, ctxname, len);
		msg->sm_ctxname[len] = '\0';
		break;
	default:
	badversion:
		stats->snmp_inbadversions++;
		msg->sm_errstr = "bad snmp version";
		goto fail;
	}

	if (ber_scanf_elements(msg->sm_pdu, "t{e", &class, &type, &a) != 0)
		goto parsefail;

	/* SNMP PDU context */
	if (class != BER_CLASS_CONTEXT)
		goto parsefail;

	switch (type) {
	case SNMP_C_GETBULKREQ:
		if (msg->sm_version == SNMP_V1) {
			stats->snmp_inbadversions++;
			msg->sm_errstr =
			    "invalid request for protocol version 1";
			goto fail;
		}
		/* FALLTHROUGH */

	case SNMP_C_GETREQ:
		stats->snmp_ingetrequests++;
		/* FALLTHROUGH */

	case SNMP_C_GETNEXTREQ:
		if (type == SNMP_C_GETNEXTREQ)
			stats->snmp_ingetnexts++;
		if (msg->sm_version != SNMP_V3 &&
		    strcmp(env->sc_rdcommunity, msg->sm_community) != 0 &&
		    strcmp(env->sc_rwcommunity, msg->sm_community) != 0) {
			stats->snmp_inbadcommunitynames++;
			msg->sm_errstr = "wrong read community";
			goto fail;
		}
		msg->sm_context = type;
		break;

	case SNMP_C_SETREQ:
		stats->snmp_insetrequests++;
		if (msg->sm_version != SNMP_V3 &&
		    strcmp(env->sc_rwcommunity, msg->sm_community) != 0) {
			if (strcmp(env->sc_rdcommunity, msg->sm_community) != 0)
				stats->snmp_inbadcommunitynames++;
			else
				stats->snmp_inbadcommunityuses++;
			msg->sm_errstr = "wrong write community";
			goto fail;
		}
		msg->sm_context = type;
		break;

	case SNMP_C_GETRESP:
		stats->snmp_ingetresponses++;
		msg->sm_errstr = "response without request";
		goto parsefail;

	case SNMP_C_TRAP:
	case SNMP_C_TRAPV2:
		if (msg->sm_version != SNMP_V3 &&
		    strcmp(env->sc_trcommunity, msg->sm_community) != 0) {
			stats->snmp_inbadcommunitynames++;
			msg->sm_errstr = "wrong trap community";
			goto fail;
		}
		stats->snmp_intraps++;
		msg->sm_errstr = "received trap";
		goto fail;

	default:
		msg->sm_errstr = "invalid context";
		goto parsefail;
	}

	/* SNMP PDU */
	if (ber_scanf_elements(a, "iiie{et",
	    &req, &errval, &erridx, &msg->sm_pduend,
	    &msg->sm_varbind, &class, &type) != 0) {
		stats->snmp_silentdrops++;
		msg->sm_errstr = "invalid PDU";
		goto fail;
	}
	if (class != BER_CLASS_UNIVERSAL || type != BER_TYPE_SEQUENCE) {
		stats->snmp_silentdrops++;
		msg->sm_errstr = "invalid varbind";
		goto fail;
	}

	msg->sm_request = req;
	msg->sm_error = errval;
	msg->sm_errorindex = erridx;

	print_host(ss, msg->sm_host, sizeof(msg->sm_host));
	if (msg->sm_version == SNMP_V3)
		log_debug("%s: %s: SNMPv3 context %d, flags %#x, "
		    "secmodel %lld, user '%s', ctx-engine %s, ctx-name '%s', "
		    "request %lld", __func__, msg->sm_host, msg->sm_context,
		    msg->sm_flags, msg->sm_secmodel, msg->sm_username,
		    tohexstr(msg->sm_ctxengineid, msg->sm_ctxengineid_len),
		    msg->sm_ctxname, msg->sm_request);
	else
		log_debug("%s: %s: SNMPv%d '%s' context %d request %lld",
		    __func__, msg->sm_host, msg->sm_version + 1,
		    msg->sm_community, msg->sm_context, msg->sm_request);

	return (0);

 parsefail:
	stats->snmp_inasnparseerrs++;
 fail:
	print_host(ss, msg->sm_host, sizeof(msg->sm_host));
	log_debug("%s: %s: %s", __func__, msg->sm_host, msg->sm_errstr);
	return (-1);
}

int
snmpe_parsevarbinds(struct snmp_message *msg)
{
	struct snmp_stats	*stats = &snmpd_env->sc_stats;
	char			 buf[BUFSIZ];
	struct ber_oid		 o;
	int			 ret = 0;

	msg->sm_errstr = "invalid varbind element";

	if (msg->sm_i == 0) {
		msg->sm_i = 1;
		msg->sm_a = msg->sm_varbind;
		msg->sm_last = NULL;
	}

	 for (; msg->sm_a != NULL && msg->sm_i < SNMPD_MAXVARBIND;
	    msg->sm_a = msg->sm_next, msg->sm_i++) {
		msg->sm_next = msg->sm_a->be_next;

		if (msg->sm_a->be_class != BER_CLASS_UNIVERSAL ||
		    msg->sm_a->be_type != BER_TYPE_SEQUENCE)
			continue;
		if ((msg->sm_b = msg->sm_a->be_sub) == NULL)
			continue;

		for (msg->sm_state = 0; msg->sm_state < 2 && msg->sm_b != NULL;
		    msg->sm_b = msg->sm_b->be_next) {
			switch (msg->sm_state++) {
			case 0:
				if (ber_get_oid(msg->sm_b, &o) != 0)
					goto varfail;
				if (o.bo_n < BER_MIN_OID_LEN ||
				    o.bo_n > BER_MAX_OID_LEN)
					goto varfail;
				if (msg->sm_context == SNMP_C_SETREQ)
					stats->snmp_intotalsetvars++;
				else
					stats->snmp_intotalreqvars++;
				log_debug("%s: %s: oid %s",
				    __func__, msg->sm_host,
				    smi_oid2string(&o, buf, sizeof(buf), 0));
				break;
			case 1:
				msg->sm_c = NULL;
				msg->sm_end = NULL;

				switch (msg->sm_context) {

				case SNMP_C_GETNEXTREQ:
					msg->sm_c = ber_add_sequence(NULL);
					ret = mps_getnextreq(msg, msg->sm_c,
					    &o);
					if (ret == 0 || ret == 1)
						break;
					ber_free_elements(msg->sm_c);
					msg->sm_error = SNMP_ERROR_NOSUCHNAME;
					goto varfail;

				case SNMP_C_GETREQ:
					msg->sm_c = ber_add_sequence(NULL);
					ret = mps_getreq(msg, msg->sm_c, &o,
					    msg->sm_version);
					if (ret == 0 || ret == 1)
						break;
					msg->sm_error = SNMP_ERROR_NOSUCHNAME;
					ber_free_elements(msg->sm_c);
					goto varfail;

				case SNMP_C_SETREQ:
					if (snmpd_env->sc_readonly == 0) {
						ret = mps_setreq(msg,
						    msg->sm_b, &o);
						if (ret == 0)
							break;
					}
					msg->sm_error = SNMP_ERROR_READONLY;
					goto varfail;

				case SNMP_C_GETBULKREQ:
					ret = mps_getbulkreq(msg, &msg->sm_c,
					    &msg->sm_end, &o,
					    (msg->sm_i <= msg->sm_nonrepeaters)
					    ? 1 : msg->sm_maxrepetitions);
					if (ret == 0 || ret == 1)
						break;
					msg->sm_error = SNMP_ERROR_NOSUCHNAME;
					goto varfail;

				default:
					goto varfail;
				}
				if (msg->sm_c == NULL)
					break;
				if (msg->sm_end == NULL)
					msg->sm_end = msg->sm_c;
				if (msg->sm_last == NULL)
					msg->sm_varbindresp = msg->sm_c;
				else
					ber_link_elements(msg->sm_last, msg->sm_c);
				msg->sm_last = msg->sm_end;
				break;
			}
		}
		if (msg->sm_state < 2)  {
			log_debug("%s: state %d", __func__, msg->sm_state);
			goto varfail;
		}
	}

	msg->sm_errstr = "none";
	msg->sm_error = 0;
	msg->sm_errorindex = 0;

	return (ret);
 varfail:
	log_debug("%s: %s: %s, error index %d", __func__,
	    msg->sm_host, msg->sm_errstr, msg->sm_i);
	if (msg->sm_error == 0)
		msg->sm_error = SNMP_ERROR_GENERR;
	msg->sm_errorindex = msg->sm_i;
	return (-1);
}

void
snmpe_recvmsg(int fd, short sig, void *arg)
{
	struct snmpd		*env = arg;
	struct snmp_stats	*stats = &env->sc_stats;
	ssize_t			 len;
	struct snmp_message	*msg;

	if ((msg = calloc(1, sizeof(*msg))) == NULL)
		return;

	msg->sm_sock = fd;
	msg->sm_slen = sizeof(msg->sm_ss);
	if ((len = recvfromto(fd, msg->sm_data, sizeof(msg->sm_data), 0,
	    (struct sockaddr *)&msg->sm_ss, &msg->sm_slen,
	    (struct sockaddr *)&msg->sm_local_ss, &msg->sm_local_slen)) < 1) {
		free(msg);
		return;
	}

	stats->snmp_inpkts++;
	msg->sm_datalen = (size_t)len;

	bzero(&msg->sm_ber, sizeof(msg->sm_ber));
	msg->sm_ber.fd = -1;
	ber_set_application(&msg->sm_ber, smi_application);
	ber_set_readbuf(&msg->sm_ber, msg->sm_data, msg->sm_datalen);

	msg->sm_req = ber_read_elements(&msg->sm_ber, NULL);
	if (msg->sm_req == NULL) {
		stats->snmp_inasnparseerrs++;
		snmp_msgfree(msg);
		return;
	}

#ifdef DEBUG
	fprintf(stderr, "recv msg:\n");
	smi_debug_elements(msg->sm_req);
#endif

	if (snmpe_parse(msg) == -1) {
		if (msg->sm_usmerr != 0 && MSG_REPORT(msg)) {
			usm_make_report(msg);
			snmpe_response(msg);
			return;
		} else {
			snmp_msgfree(msg);
			return;
		}
	}

	snmpe_dispatchmsg(msg);
}

void
snmpe_dispatchmsg(struct snmp_message *msg)
{
	if (snmpe_parsevarbinds(msg) == 1)
		return;

	/* not dispatched to subagent; respond directly */
	msg->sm_context = SNMP_C_GETRESP;
	snmpe_response(msg);
}

void
snmpe_response(struct snmp_message *msg)
{
	struct snmp_stats	*stats = &snmpd_env->sc_stats;
	u_int8_t		*ptr = NULL;
	ssize_t			 len;

	if (msg->sm_varbindresp == NULL && msg->sm_pduend != NULL)
		msg->sm_varbindresp = ber_unlink_elements(msg->sm_pduend);

	switch (msg->sm_error) {
	case SNMP_ERROR_TOOBIG:
		stats->snmp_intoobigs++;
		break;
	case SNMP_ERROR_NOSUCHNAME:
		stats->snmp_innosuchnames++;
		break;
	case SNMP_ERROR_BADVALUE:
		stats->snmp_inbadvalues++;
		break;
	case SNMP_ERROR_READONLY:
		stats->snmp_inreadonlys++;
		break;
	case SNMP_ERROR_GENERR:
	default:
		stats->snmp_ingenerrs++;
		break;
	}

	/* Create new SNMP packet */
	if (snmpe_encode(msg) < 0)
		goto done;

	len = ber_write_elements(&msg->sm_ber, msg->sm_resp);
	if (ber_get_writebuf(&msg->sm_ber, (void *)&ptr) == -1)
		goto done;

	usm_finalize_digest(msg, ptr, len);
	len = sendtofrom(msg->sm_sock, ptr, len, 0,
	    (struct sockaddr *)&msg->sm_ss, msg->sm_slen,
	    (struct sockaddr *)&msg->sm_local_ss, msg->sm_local_slen);
	if (len != -1)
		stats->snmp_outpkts++;

 done:
	snmp_msgfree(msg);
}

void
snmp_msgfree(struct snmp_message *msg)
{
	ber_free(&msg->sm_ber);
	if (msg->sm_req != NULL)
		ber_free_elements(msg->sm_req);
	if (msg->sm_resp != NULL)
		ber_free_elements(msg->sm_resp);
	free(msg);
}

int
snmpe_encode(struct snmp_message *msg)
{
	struct ber_element	*ehdr;
	struct ber_element	*pdu, *epdu;

	msg->sm_resp = ber_add_sequence(NULL);
	if ((ehdr = ber_add_integer(msg->sm_resp, msg->sm_version)) == NULL)
		return -1;
	if (msg->sm_version == SNMP_V3) {
		char	f = MSG_SECLEVEL(msg);

		if ((ehdr = ber_printf_elements(ehdr, "{iixi}", msg->sm_msgid,
		    msg->sm_max_msg_size, &f, sizeof(f),
		    msg->sm_secmodel)) == NULL)
			return -1;

		/* XXX currently only USM supported */
		if ((ehdr = usm_encode(msg, ehdr)) == NULL)
			return -1;
	} else {
		if ((ehdr = ber_add_string(ehdr, msg->sm_community)) == NULL)
			return -1;
	}

	pdu = epdu = ber_add_sequence(NULL);
	if (msg->sm_version == SNMP_V3) {
		if ((epdu = ber_printf_elements(epdu, "xs{",
		    snmpd_env->sc_engineid, snmpd_env->sc_engineid_len,
		    msg->sm_ctxname)) == NULL) {
			ber_free_elements(pdu);
			return -1;
		}
	}

	if (!ber_printf_elements(epdu, "tiii{e}.", BER_CLASS_CONTEXT,
	    msg->sm_context, msg->sm_request,
	    msg->sm_error, msg->sm_errorindex,
	    msg->sm_varbindresp)) {
		ber_free_elements(pdu);
		return -1;
	}

	if (MSG_HAS_PRIV(msg))
		pdu = usm_encrypt(msg, pdu);
	ber_link_elements(ehdr, pdu);

#ifdef DEBUG
	fprintf(stderr, "resp msg:\n");
	smi_debug_elements(msg->sm_resp);
#endif
	return 0;
}
@


1.49
log
@Initial pledge for snmpd. snmpe remains unpledged. Regression tests pass.

Ok benno@@, jca@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.48 2017/07/27 14:04:16 gerhard Exp $	*/
d109 1
a109 1
#ifdef notyet
d114 1
a114 1
	if (pledge("stdio inet route recvfd vminfo", NULL) == -1)
@


1.48
log
@Heed the non-repeaters of GetBulkRequests and make sure to set
error-status and error-index to zero in the response PDU.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.47 2017/04/21 13:50:23 jca Exp $	*/
d108 9
@


1.47
log
@Repair AgentX support.

which I broke when adding support for multiple listen address.  SNMP
data should be sent to the client using the appropriate socket, which we
now store when we receive the query.

Reported & fix tested by Rivo Nurges.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.46 2016/11/18 16:16:39 jca Exp $	*/
d442 2
a443 1
					    msg->sm_maxrepetitions);
d471 2
@


1.46
log
@Add support for multiple listening sockets

One can now specify multiple "listen on" statements. The default is to
listen on 0.0.0.0 and ::, which means better handling of dual-stack
setups.  ok sthen@@ on a previous version, input and ok reyk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.45 2016/11/09 20:31:56 jca Exp $	*/
d45 1
a45 1
void	 snmpe_response(int, struct snmp_message *);
d492 1
d524 1
a524 1
			snmpe_response(fd, msg);
d532 1
a532 1
	snmpe_dispatchmsg(msg, fd);
d536 1
a536 1
snmpe_dispatchmsg(struct snmp_message *msg, int sock)
d543 1
a543 1
	snmpe_response(sock, msg);
d547 1
a547 1
snmpe_response(int fd, struct snmp_message *msg)
d584 1
a584 1
	len = sendtofrom(fd, ptr, len, 0,
@


1.45
log
@Improve source IP address handling.

- send replies using a source address equal to the destination address
  of queries, using IP_SENDSRCADDR.  This help in multihomed setups and
  can remove the need to explicitely configure a bind address.
- config knob to set the source address of packets sent to trap
  receivers.  "trap receiver" gains an optional "source-address"
  setting.

Source address issues reported by Andy Lemin.  ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.44 2016/10/28 09:07:08 rzalamena Exp $	*/
d64 3
a66 1
	struct snmpd	*env = ps->ps_env;
d79 7
a85 3
	/* bind SNMP UDP socket */
	if ((env->sc_sock = snmpe_bind(&env->sc_address)) == -1)
		fatalx("snmpe: failed to bind SNMP UDP socket");
d94 2
a95 1
	struct snmpd	*env = ps->ps_env;
d103 5
a107 3
	event_set(&env->sc_ev, env->sc_sock, EV_READ|EV_PERSIST,
	    snmpe_recvmsg, env);
	event_add(&env->sc_ev, NULL);
d168 1
a168 1
	log_info("snmpe_bind: binding to address %s:%d", buf, addr->port);
d531 1
a531 1
	snmpe_dispatchmsg(msg);
d535 1
a535 1
snmpe_dispatchmsg(struct snmp_message *msg)
d542 1
a542 1
	snmpe_response(snmpd_env->sc_sock, msg);
@


1.44
log
@Sync snmpd(8) with other daemons proc.c and teach him how to fork+exec.

ok jca@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.43 2016/10/28 08:01:53 rzalamena Exp $	*/
d122 1
a122 1
	int	 s;
d133 20
d484 3
a486 2
	if ((len = recvfrom(fd, msg->sm_data, sizeof(msg->sm_data), 0,
	    (struct sockaddr *)&msg->sm_ss, &msg->sm_slen)) < 1) {
d574 3
a576 2
	len = sendto(fd, ptr, len, 0, (struct sockaddr *)&msg->sm_ss,
	    msg->sm_slen);
@


1.43
log
@Use snmpd_env as the only global variable for env to simplify the daemon
and avoid problems.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.42 2016/08/16 18:41:57 tedu Exp $	*/
d61 1
a61 1
pid_t
d81 1
a81 1
	return (proc_run(ps, p, procs, nitems(procs), snmpe_init, NULL));
@


1.42
log
@stop including sys/param.h for nitems. define locally as needed.
ok natano reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.41 2015/10/08 08:17:30 sthen Exp $	*/
a54 2
struct snmpd	*env = NULL;

d64 1
a69 2
	env = ps->ps_env;

d88 2
d151 1
d334 1
a334 1
	struct snmp_stats	*stats = &env->sc_stats;
d401 1
a401 1
					if (env->sc_readonly == 0) {
d455 1
d512 1
a512 1
	snmpe_response(env->sc_sock, msg);
d518 1
a518 1
	struct snmp_stats	*stats = &env->sc_stats;
d600 3
a602 2
		if ((epdu = ber_printf_elements(epdu, "xs{", env->sc_engineid,
		    env->sc_engineid_len, msg->sm_ctxname)) == NULL) {
@


1.41
log
@Link the result of each mps_getbulkreq() to the end of the previous list
and not the start of it. Fixes getbulk requests for multiple OIDs.

From Gerhard Roth, ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.40 2015/01/16 00:05:13 deraadt Exp $	*/
a18 1
#include <sys/param.h>	/* nitems */
@


1.40
log
@first batch of cleanup to programs based upon the namespace cleanups
in net/pfvar.h sys/proc.h sys/ucred.h arpa/nameser.h
change to PATH_MAX, reduce use of MIN() and MAX(), HOST_NAME_MAX+1,
LOGIN_NAME_MAX, etc etc
ok millert guenther, some review by doug
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.39 2014/11/19 10:19:00 blambert Exp $	*/
d377 1
d413 2
a414 1
					    &o, msg->sm_maxrepetitions);
d425 2
d431 1
a431 1
				msg->sm_last = msg->sm_c;
@


1.39
log
@add support for AgentX subagents in snmpd

snmp requests are now packaged into pseudo-continuations
to allow for being dispatched to seperate processes;
lightly tested for interoperability with NetSNMP, but
doesn't implement the complete set of AgentX messages

while here, clean up return types of mps_get* functions,
and make smi_insert refuse to insert duplicate OIDs

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.38 2014/04/21 19:47:27 reyk Exp $	*/
d19 1
a20 1
#include <sys/param.h>
@


1.38
log
@Copy the updated proc.c from relayd to use the same file.  Adjust
snmpd accordingly.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.37 2013/10/17 08:42:44 reyk Exp $	*/
d44 3
a46 2
int	 snmpe_parse(struct sockaddr_storage *,
	    struct ber_element *, struct snmp_message *);
d54 1
d151 1
a151 2
snmpe_parse(struct sockaddr_storage *ss,
    struct ber_element *root, struct snmp_message *msg)
d154 1
a154 2
	struct ber_element	*a, *b, *c, *d, *e, *f, *next, *last;
	const char		*errstr = "invalid message";
d158 2
a159 2
	u_int			 class, state, i = 0, j = 0;
	char			*comn, buf[BUFSIZ], host[MAXHOSTNAMELEN];
a160 1
	struct ber_oid		 o;
d162 4
d182 1
a182 1
			errstr = "community name too long";
d196 1
a196 1
			errstr = "unsupported security model";
d202 1
a202 1
		if ((a = usm_decode(msg, a, &errstr)) == NULL)
d217 1
a217 1
		errstr = "bad snmp version";
d227 1
d232 2
a233 1
			errstr = "invalid request for protocol version 1";
d237 1
d241 1
d249 1
a249 1
			errstr = "wrong read community";
d254 1
d263 1
a263 1
			errstr = "wrong write community";
d268 1
d271 1
a271 1
		errstr = "response without request";
d273 1
d279 1
a279 1
			errstr = "wrong trap community";
d283 1
a283 1
		errstr = "received trap";
d285 1
d287 1
a287 1
		errstr = "invalid context";
d296 1
a296 1
		errstr = "invalid PDU";
d301 1
a301 1
		errstr = "invalid varbind";
d309 1
a309 1
	print_host(ss, host, sizeof(host));
d311 1
a311 1
		log_debug("snmpe_parse: %s: SNMPv3 context %d, flags %#x, "
d313 2
a314 2
		    "request %lld", host, msg->sm_context, msg->sm_flags,
		    msg->sm_secmodel, msg->sm_username,
d318 2
a319 2
		log_debug("snmpe_parse: %s: SNMPv%d '%s' context %d "
		    "request %lld", host, msg->sm_version + 1,
d322 29
a350 4
	errstr = "invalid varbind element";
	for (i = 1, a = msg->sm_varbind, last = NULL;
	    a != NULL && i < SNMPD_MAXVARBIND; a = next, i++) {
		next = a->be_next;
d352 2
a353 2
		if (a->be_class != BER_CLASS_UNIVERSAL ||
		    a->be_type != BER_TYPE_SEQUENCE)
d355 1
a355 1
		if ((b = a->be_sub) == NULL)
d357 4
a360 2
		for (state = 0; state < 2 && b != NULL; b = b->be_next) {
			switch (state++) {
d362 1
a362 1
				if (ber_get_oid(b, &o) != 0)
d371 2
a372 1
				log_debug("snmpe_parse: %s: oid %s", host,
d376 2
a377 1
				c = d = NULL;
d379 1
d381 4
a384 2
					c = ber_add_sequence(NULL);
					if ((d = mps_getnextreq(c, &o)) != NULL)
d386 1
a386 2
					ber_free_elements(c);
					c = NULL;
d388 2
a389 2
					msg->sm_errorindex = i;
					break;	/* ignore error */
d391 4
a394 3
					c = ber_add_sequence(NULL);
					if ((d = mps_getreq(c, &o,
					    msg->sm_version)) != NULL)
d397 1
a397 1
					ber_free_elements(c);
d399 1
d401 6
a406 3
					if (env->sc_readonly == 0
					    && mps_setreq(b, &o) == 0)
						break;
d409 1
d411 4
a414 2
					j = msg->sm_maxrepetitions;
					msg->sm_errorindex = 0;
d416 2
a417 22
					for (d = NULL, len = 0; j > 0; j--) {
						e = ber_add_sequence(NULL);
						if (c == NULL)
							c = e;
						f = mps_getnextreq(e, &o);
						if (f == NULL) {
							ber_free_elements(e);
							if (d == NULL)
								goto varfail;
							break;
						}
						len += ber_calc_len(e);
						if (len > SNMPD_MAXVARBINDLEN) {
							ber_free_elements(e);
							break;
						}
						if (d != NULL)
							ber_link_elements(d, e);
						d = e;
					}
					msg->sm_error = 0;
					break;
d421 1
a421 1
				if (c == NULL)
d423 2
a424 2
				if (last == NULL)
					msg->sm_varbindresp = c;
d426 2
a427 2
					ber_link_elements(last, c);
				last = c;
d431 2
a432 2
		if (state < 2)  {
			log_debug("snmpe_parse: state %d", state);
d437 3
a439 1
	return (0);
d441 2
a442 1
	log_debug("snmpe_parse: %s: %s, error index %d", host, errstr, i);
d445 1
a445 7
	msg->sm_errorindex = i;
	return (0);
 parsefail:
	stats->snmp_inasnparseerrs++;
 fail:
	print_host(ss, host, sizeof(host));
	log_debug("snmpe_parse: %s: %s", host, errstr);
a452 3
	struct sockaddr_storage	 ss;
	u_int8_t		*ptr = NULL;
	socklen_t		 slen;
d454 3
a456 8
	struct ber		 ber;
	struct ber_element	*req = NULL;
	struct snmp_message	 msg;

	bzero(&msg, sizeof(msg));
	slen = sizeof(ss);
	if ((len = recvfrom(fd, msg.sm_data, sizeof(msg.sm_data), 0,
	    (struct sockaddr *)&ss, &slen)) < 1)
d459 7
d467 1
a467 1
	msg.sm_datalen = (size_t)len;
d469 4
a472 4
	bzero(&ber, sizeof(ber));
	ber.fd = -1;
	ber_set_application(&ber, smi_application);
	ber_set_readbuf(&ber, msg.sm_data, msg.sm_datalen);
d474 2
a475 2
	req = ber_read_elements(&ber, NULL);
	if (req == NULL) {
d477 2
a478 1
		goto done;
d483 1
a483 1
	smi_debug_elements(req);
d486 10
a495 7
	if (snmpe_parse(&ss, req, &msg) == -1) {
		if (msg.sm_usmerr != 0 && MSG_REPORT(&msg))
			usm_make_report(&msg);
		else
			goto done;
	} else
		msg.sm_context = SNMP_C_GETRESP;
d497 23
a519 2
	if (msg.sm_varbindresp == NULL && msg.sm_pduend != NULL)
		msg.sm_varbindresp = ber_unlink_elements(msg.sm_pduend);
d521 1
a521 1
	switch (msg.sm_error) {
d541 1
a541 1
	if (snmpe_encode(&msg) < 0)
d544 2
a545 2
	len = ber_write_elements(&ber, msg.sm_resp);
	if (ber_get_writebuf(&ber, (void *)&ptr) == -1)
d548 3
a550 2
	usm_finalize_digest(&msg, ptr, len);
	len = sendto(fd, ptr, len, 0, (struct sockaddr *)&ss, slen);
d555 12
a566 5
	ber_free(&ber);
	if (req != NULL)
		ber_free_elements(req);
	if (msg.sm_resp != NULL)
		ber_free_elements(msg.sm_resp);
@


1.37
log
@Update snmpd(8) to use the proc.c privsep style from iked and relayd.

ok sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.36 2013/10/16 16:05:03 blambert Exp $	*/
d43 1
a43 1
void	 snmpe_init(struct privsep *, void *);
d88 1
a88 1
snmpe_init(struct privsep *p, void *arg)
d102 1
a102 1
snmpe_shutdown(struct privsep *ps, struct privsep_proc *p)
@


1.36
log
@ 1) move the creation of 'restricted' communication sockets
    into snmpd.conf
 2) add the ability to specify an alternate 'control' socket location
 3) allow for the creation of multiple 'restricted' sockets (but
    only one control socket, for the time being)

Committing slightly ahead of schedule in order to clear the pipeline
for a few other upcoming changes.

ok reyk@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.35 2013/10/01 12:41:48 reyk Exp $	*/
d43 1
d49 1
a49 2
void	 snmpe_shutdown(void);
void	 snmpe_dispatch_parent(int, short, void *);
d58 3
a60 12
void
snmpe_sig_handler(int sig, short event, void *arg)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		snmpe_shutdown();
		break;
	default:
		fatalx("snmpe_sig_handler: unexpected signal");
	}
}
d63 1
a63 1
snmpe(struct snmpd *x_env, int pipe_parent2snmpe[2])
a64 5
	pid_t			 pid;
	struct passwd		*pw;
	struct event		 ev_sigint;
	struct event		 ev_sigterm;
	struct control_sock	*rcs;
d66 1
d70 1
a70 41
	switch (pid = fork()) {
	case -1:
		fatal("snmpe: cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}

	env = x_env;

	if (control_init(&env->sc_csock) == -1)
		fatalx("snmpe: control socket setup failed");
	TAILQ_FOREACH(rcs, &env->sc_rcsocks, cs_entry)
		if (control_init(rcs) == -1)
			fatalx("snmpe: restricted control socket setup failed");

	if ((env->sc_sock = snmpe_bind(&env->sc_address)) == -1)
		fatalx("snmpe: failed to bind SNMP UDP socket");

	if ((pw = getpwnam(SNMPD_USER)) == NULL)
		fatal("snmpe: getpwnam");

#ifndef DEBUG
	if (chroot(pw->pw_dir) == -1)
		fatal("snmpe: chroot");
	if (chdir("/") == -1)
		fatal("snmpe: chdir(\"/\")");
#else
#warning disabling privilege revocation and chroot in DEBUG mode
#endif

	setproctitle("snmp engine");
	snmpd_process = PROC_SNMPE;

#ifndef DEBUG
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("snmpe: cannot drop privileges");
#endif
a73 1
		char	 buf[BUFSIZ];
d79 3
a81 1
	event_init();
d83 2
a84 32
	signal_set(&ev_sigint, SIGINT, snmpe_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, snmpe_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	close(pipe_parent2snmpe[0]);

	if ((iev_parent = calloc(1, sizeof(struct imsgev))) == NULL)
		fatal("snmpe");

	imsg_init(&iev_parent->ibuf, pipe_parent2snmpe[1]);
	iev_parent->handler = snmpe_dispatch_parent;
	iev_parent->data = iev_parent;

	iev_parent->events = EV_READ;
	event_set(&iev_parent->ev, iev_parent->ibuf.fd, iev_parent->events,
	    iev_parent->handler, iev_parent);
	event_add(&iev_parent->ev, NULL);

	TAILQ_INIT(&ctl_conns);

	if (control_listen(&env->sc_csock) == -1)
		fatalx("snmpe: control socket listen failed");
	TAILQ_FOREACH(rcs, &env->sc_rcsocks, cs_entry)
		if (control_listen(rcs) == -1)
			fatalx("snmpe: restricted control socket listen failed");

	event_set(&env->sc_ev, env->sc_sock, EV_READ|EV_PERSIST,
	    snmpe_recvmsg, env);
	event_add(&env->sc_ev, NULL);
d86 4
a92 1

d95 4
a98 6
	event_dispatch();

	snmpe_shutdown();
	kr_shutdown();

	return (0);
d102 1
a102 1
snmpe_shutdown(void)
d104 1
a104 2
	log_info("snmp engine exiting");
	_exit(0);
d107 2
a108 2
void
snmpe_dispatch_parent(int fd, short event, void * ptr)
d110 2
a111 17
	struct imsgev	*iev;
	struct imsgbuf	*ibuf;
	struct imsg	 imsg;
	ssize_t		 n;

	iev = ptr;
	ibuf = &iev->ibuf;
	switch (event) {
	case EV_READ:
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
a112 7
	case EV_WRITE:
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
		imsg_event_add(iev);
		return;
	default:
		fatalx("snmpe_dispatch_parent: unknown event");
d115 1
a115 15
	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("snmpe_dispatch_parent: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_debug("snmpe_dispatch_parent: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
@


1.35
log
@Add initial SNMP client utility to snmpctl(8).
For example, snmpctl snmp walk 127.0.0.1

commit it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.34 2013/09/26 09:11:30 reyk Exp $	*/
d74 5
a78 4
	pid_t		 pid;
	struct passwd	*pw;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
d96 3
a98 2
	if (control_init(&env->sc_rcsock) == -1)
		fatalx("snmpe: restricted control socket setup failed");
d160 3
a162 2
	if (control_listen(&env->sc_rcsock) == -1)
		fatalx("snmpe: restricted control socket listen failed");
@


1.34
log
@shuffle some snmpd functions to make them visible in smi.c for snmpctl.

ok gerhard@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.33 2013/03/29 12:53:41 gerhard Exp $	*/
d126 1
a126 1
		smi_oidstring(&oid->o_id, buf, sizeof(buf));
d449 1
a449 1
				    smi_oidstring(&o, buf, sizeof(buf)));
@


1.33
log
@Patch from Ilya Bakulin that allows to put snmpd(8) into read-only mode
so that all "set" requests will be rejected.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.32 2012/11/29 14:53:24 yasuoka Exp $	*/
a38 1
#include <vis.h>
a262 227
#ifdef DEBUG
void
snmpe_debug_elements(struct ber_element *root)
{
	static int	 indent = 0;
	long long	 v;
	int		 d;
	char		*buf;
	size_t		 len;
	u_int		 i;
	int		 constructed;
	struct ber_oid	 o;
	char		 str[BUFSIZ];

	/* calculate lengths */
	ber_calc_len(root);

	switch (root->be_encoding) {
	case BER_TYPE_SEQUENCE:
	case BER_TYPE_SET:
		constructed = root->be_encoding;
		break;
	default:
		constructed = 0;
		break;
	}

	fprintf(stderr, "%*slen %lu ", indent, "", root->be_len);
	switch (root->be_class) {
	case BER_CLASS_UNIVERSAL:
		fprintf(stderr, "class: universal(%u) type: ", root->be_class);
		switch (root->be_type) {
		case BER_TYPE_EOC:
			fprintf(stderr, "end-of-content");
			break;
		case BER_TYPE_BOOLEAN:
			fprintf(stderr, "boolean");
			break;
		case BER_TYPE_INTEGER:
			fprintf(stderr, "integer");
			break;
		case BER_TYPE_BITSTRING:
			fprintf(stderr, "bit-string");
			break;
		case BER_TYPE_OCTETSTRING:
			fprintf(stderr, "octet-string");
			break;
		case BER_TYPE_NULL:
			fprintf(stderr, "null");
			break;
		case BER_TYPE_OBJECT:
			fprintf(stderr, "object");
			break;
		case BER_TYPE_ENUMERATED:
			fprintf(stderr, "enumerated");
			break;
		case BER_TYPE_SEQUENCE:
			fprintf(stderr, "sequence");
			break;
		case BER_TYPE_SET:
			fprintf(stderr, "set");
			break;
		}
		break;
	case BER_CLASS_APPLICATION:
		fprintf(stderr, "class: application(%u) type: ",
		    root->be_class);
		switch (root->be_type) {
		case SNMP_T_IPADDR:
			fprintf(stderr, "ipaddr");
			break;
		case SNMP_T_COUNTER32:
			fprintf(stderr, "counter32");
			break;
		case SNMP_T_GAUGE32:
			fprintf(stderr, "gauge32");
			break;
		case SNMP_T_TIMETICKS:
			fprintf(stderr, "timeticks");
			break;
		case SNMP_T_OPAQUE:
			fprintf(stderr, "opaque");
			break;
		case SNMP_T_COUNTER64:
			fprintf(stderr, "counter64");
			break;
		}
		break;
	case BER_CLASS_CONTEXT:
		fprintf(stderr, "class: context(%u) type: ",
		    root->be_class);
		switch (root->be_type) {
		case SNMP_C_GETREQ:
			fprintf(stderr, "getreq");
			break;
		case SNMP_C_GETNEXTREQ:
			fprintf(stderr, "nextreq");
			break;
		case SNMP_C_GETRESP:
			fprintf(stderr, "getresp");
			break;
		case SNMP_C_SETREQ:
			fprintf(stderr, "setreq");
			break;
		case SNMP_C_TRAP:
			fprintf(stderr, "trap");
			break;
		case SNMP_C_GETBULKREQ:
			fprintf(stderr, "getbulkreq");
			break;
		case SNMP_C_INFORMREQ:
			fprintf(stderr, "informreq");
			break;
		case SNMP_C_TRAPV2:
			fprintf(stderr, "trapv2");
			break;
		case SNMP_C_REPORT:
			fprintf(stderr, "report");
			break;
		}
		break;
	case BER_CLASS_PRIVATE:
		fprintf(stderr, "class: private(%u) type: ", root->be_class);
		break;
	default:
		fprintf(stderr, "class: <INVALID>(%u) type: ", root->be_class);
		break;
	}
	fprintf(stderr, "(%lu) encoding %lu ",
	    root->be_type, root->be_encoding);

	if (constructed)
		root->be_encoding = constructed;

	switch (root->be_encoding) {
	case BER_TYPE_BOOLEAN:
		if (ber_get_boolean(root, &d) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "%s(%d)\n", d ? "true" : "false", d);
		break;
	case BER_TYPE_INTEGER:
	case BER_TYPE_ENUMERATED:
		if (ber_get_integer(root, &v) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "value %lld\n", v);
		break;
	case BER_TYPE_BITSTRING:
		if (ber_get_bitstring(root, (void *)&buf, &len) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "hexdump ");
		for (i = 0; i < len; i++)
			fprintf(stderr, "%02x", buf[i]);
		fprintf(stderr, "\n");
		break;
	case BER_TYPE_OBJECT:
		if (ber_get_oid(root, &o) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		fprintf(stderr, "oid %s",
		    smi_oidstring(&o, str, sizeof(str)));
		fprintf(stderr, "\n");
		break;
	case BER_TYPE_OCTETSTRING:
		if (ber_get_string(root, &buf) == -1) {
			fprintf(stderr, "<INVALID>\n");
			break;
		}
		if (root->be_class == BER_CLASS_APPLICATION &&
		    root->be_type == SNMP_T_IPADDR) {
			fprintf(stderr, "addr %s\n",
			    inet_ntoa(*(struct in_addr *)buf));
		} else {
			char *visbuf;
			if ((visbuf = malloc(root->be_len * 4 + 1)) == NULL)
				fatal("malloc");
			strvisx(visbuf, buf, root->be_len, 0);
			fprintf(stderr, "string \"%s\"\n",  visbuf);
			free(visbuf);
		}
		break;
	case BER_TYPE_NULL:	/* no payload */
	case BER_TYPE_EOC:
	case BER_TYPE_SEQUENCE:
	case BER_TYPE_SET:
	default:
		fprintf(stderr, "\n");
		break;
	}

	if (constructed && root->be_sub) {
		indent += 2;
		snmpe_debug_elements(root->be_sub);
		indent -= 2;
	}
	if (root->be_next)
		snmpe_debug_elements(root->be_next);
}
#endif

unsigned long
snmpe_application(struct ber_element *elm)
{
	if (elm->be_class != BER_CLASS_APPLICATION)
		return (BER_TYPE_OCTETSTRING);

	switch (elm->be_type) {
	case SNMP_T_IPADDR:
		return (BER_TYPE_OCTETSTRING);
	case SNMP_T_COUNTER32:
	case SNMP_T_GAUGE32:
	case SNMP_T_TIMETICKS:
	case SNMP_T_OPAQUE:
	case SNMP_T_COUNTER64:
		return (BER_TYPE_INTEGER);
	default:
		break;
	}
	return (BER_TYPE_OCTETSTRING);
}

d560 1
a560 1
	ber_set_application(&ber, snmpe_application);
d571 1
a571 1
	snmpe_debug_elements(req);
d673 1
a673 1
	snmpe_debug_elements(msg->sm_resp);
@


1.32
log
@Wrong argument was passed to control_dispatch_imsg().  Use always
(struct imsgev *)->data for the argument of imsgev handlers.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.31 2012/09/18 08:29:09 reyk Exp $	*/
d700 2
a701 1
					if (mps_setreq(b, &o) == 0)
@


1.31
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.30 2012/09/17 16:43:59 reyk Exp $	*/
d148 1
@


1.30
log
@Update copyright and my email address in snmpd while I'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.29 2012/09/17 16:30:35 reyk Exp $	*/
d864 1
a864 1
		    msg->sm_max_msg_size, &f, sizeof (f),
@


1.29
log
@Add initial SNMPv3 support to snmpd(8).

Traps are still sent via SNMPv2 protocol. They can neither be
authenticated nor encrypted. - Transport mode is still UDP. Not
additional transport subsystems were added. - Only the User-based
Security Model (USM, RFC3414) is supported.  View-Based Access Control
(VACM, RFC3415) is not included. - Configuration is described in
snmpd.conf(5).

This diff includes a few minor changes to ber.c/h adding a necessary
callback for the USM HMAC calculation and merging it with other
minor changes from ldapd's ber code.

From Gerhard Roth at genua
ok claudio@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.28 2010/09/20 12:32:41 martinh Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007, 2008 Reyk Floeter <reyk@@vantronix.net>
@


1.28
log
@Use strvis to encode octet strings in -DDEBUG mode.
Makes my terminal happier when debugging.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.27 2010/09/20 08:56:16 martinh Exp $	*/
d42 1
d53 1
d169 2
d502 1
d506 1
a506 5
	bzero(msg, sizeof(*msg));

	if (ber_scanf_elements(root, "e{ieset{e",
	    &msg->sm_header, &ver, &msg->sm_headerend, &comn,
	    &msg->sm_pdu, &class, &type, &a) != 0)
d510 2
a511 1
	switch (ver) {
d514 10
a523 1
		msg->sm_version = ver;
d526 27
d554 1
d560 3
d580 3
a582 2
		if (strcmp(env->sc_rdcommunity, comn) != 0 &&
		    strcmp(env->sc_rwcommunity, comn) != 0) {
d591 3
a593 2
		if (strcmp(env->sc_rwcommunity, comn) != 0) {
			if (strcmp(env->sc_rdcommunity, comn) != 0)
d608 2
a609 1
		if (strcmp(env->sc_trcommunity, comn) != 0) {
a621 7
	if (strlcpy(msg->sm_community, comn, sizeof(msg->sm_community)) >=
	    sizeof(msg->sm_community)) {
		stats->snmp_inbadcommunitynames++;
		errstr = "community name too long";
		goto fail;
	}

d641 11
a651 3
	log_debug("snmpe_parse: %s: SNMPv%d '%s' context %d request %lld",
	    host, msg->sm_version + 1, msg->sm_community, msg->sm_context,
	    msg->sm_request);
d768 1
a768 1
	u_int8_t		 buf[READ_BUF_SIZE], *ptr = NULL;
d772 1
a772 1
	struct ber_element	*req = NULL, *resp = NULL;
d775 1
d777 1
a777 1
	if ((len = recvfrom(fd, buf, sizeof(buf), 0,
d782 1
d787 1
a787 1
	ber_set_readbuf(&ber, buf, len);
a789 1

d796 1
d800 7
a806 2
	if (snmpe_parse(&ss, req, &msg) == -1)
		goto done;
d808 1
a808 1
	if (msg.sm_varbindresp == NULL)
d831 2
a832 6
	resp = ber_add_sequence(NULL);
	ber_printf_elements(resp, "ds{tiii{e}}.",
	    msg.sm_version, msg.sm_community,
	    BER_CLASS_CONTEXT, SNMP_C_GETRESP,
	    msg.sm_request, msg.sm_error, msg.sm_errorindex,
	    msg.sm_varbindresp);
d834 1
a834 5
#ifdef DEBUG
	snmpe_debug_elements(resp);
#endif

	len = ber_write_elements(&ber, resp);
d838 1
d847 55
a901 2
	if (resp != NULL)
		ber_free_elements(resp);
@


1.27
log
@Return error on GET requests without an instance identifier, both for
tables and scalar values.

Fixes system/6468 by not calling table get functions with an unexpectedly
short OID.

Also fixes system/6071. Scalar variables without an instance specified now
returns a noSuchInstance error. GetNext requests correctly returns the .0
instance.

This means you can no longer rely on
$ snmpget -v2c -c public localhost SNMPv2-MIB::sysDescr
returning the .0 instance. You need to specify it explicitly:
$ snmpget -v2c -c public localhost SNMPv2-MIB::sysDescr.0

Also return proper SNMPv2 errors per varbind instead of a noSuchName error
status, unless SNMPv1 was specified in the request.

An earlier version of this diff tested by Remi Laurent, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.26 2010/09/20 08:33:18 martinh Exp $	*/
d39 1
d437 8
a444 3
		} else
			fprintf(stderr, "string \"%s\"\n",
			    root->be_len ? buf : "");
@


1.26
log
@ber_scanf_elements "i" format expects a long long pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.25 2009/12/16 22:17:53 deraadt Exp $	*/
d640 2
a641 1
					if ((d = mps_getreq(c, &o)) != NULL)
@


1.25
log
@knf and unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.24 2009/06/06 05:52:01 pyr Exp $	*/
d488 2
a489 1
	unsigned long		 type, errval, erridx;
@


1.24
log
@sync snmpd with the common imsg code, making it lib ready as well.
ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.23 2008/12/08 11:34:55 reyk Exp $	*/
d577 1
a577 1
	/* SNMP PDU */		    
@


1.23
log
@report memory and swap in hrStorage, and implement hrProcessor to report
hrProcessorLoad (where load means the percentage of time the system was
not idle during the last minute).  based on HOST-RESOURCES-MIB.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.22 2008/12/05 12:34:01 reyk Exp $	*/
d54 1
a54 1
struct imsgbuf	*ibuf_parent;
d140 1
a140 1
	if ((ibuf_parent = calloc(1, sizeof(struct imsgbuf))) == NULL)
d143 2
a144 1
	imsg_init(ibuf_parent, pipe_parent2snmpe[1], snmpe_dispatch_parent);
d146 4
a149 4
	ibuf_parent->events = EV_READ;
	event_set(&ibuf_parent->ev, ibuf_parent->fd, ibuf_parent->events,
	    ibuf_parent->handler, ibuf_parent);
	event_add(&ibuf_parent->ev, NULL);
d184 1
d189 2
a190 1
	ibuf = ptr;
d197 1
a197 1
			event_del(&ibuf->ev);
d205 1
a205 1
		imsg_event_add(ibuf);
d225 1
a225 1
	imsg_event_add(ibuf);
@


1.22
log
@fix a possible crash in debugging mode (if compiled for with -DDEBUG)

found by Alexander Sabourenkov
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.21 2008/09/26 15:19:55 reyk Exp $	*/
d163 1
@


1.21
log
@allow to add an additional restricted control socket for trap sending
only (not even show commands).  this allows to place a socket for
traps in another daemon's chroot.

(based on restricted socket support from bgpd)
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.20 2008/09/03 13:41:49 jsg Exp $	*/
d433 2
a434 1
			fprintf(stderr, "string \"%s\"\n", buf);
@


1.20
log
@Missing breaks.
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.19 2008/07/18 12:30:06 reyk Exp $	*/
d91 1
a91 1
	if (control_init() == -1)
d93 2
d152 1
a152 1
	if (control_listen(env, ibuf_parent) == -1)
d154 2
@


1.19
log
@merge log_host with relayd's version using getnameinfo and rename it
to print_host.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.18 2008/03/12 14:11:52 reyk Exp $	*/
d63 1
@


1.18
log
@mostly stylistic - always print the client host name in snmpe error
messages and make sure that the host string is initialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.17 2008/03/12 13:12:42 claudio Exp $	*/
d237 1
a237 1
	if (log_host(&addr->ss, buf, sizeof(buf)) == NULL)
d585 1
a585 1
	log_host(ss, host, sizeof(host));
d694 1
a694 1
	log_host(ss, host, sizeof(host));
@


1.17
log
@if (class != BER_CLASS_UNIVERSAL || type != BER_TYPE_SEQUENCE)
not
if (class != BER_CLASS_UNIVERSAL && type != BER_TYPE_SEQUENCE)
the class and type need to be of correct.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.16 2008/02/09 13:03:01 reyk Exp $	*/
d489 1
a489 1
		goto fail;
d500 2
a501 2
		log_debug("bad snmp version");
		return (-1);
d506 1
a506 1
		goto fail;
d511 2
a512 2
			log_debug("invalid request for protocol version 1");
			return (-1);
d524 2
a525 2
			log_debug("wrong read community");
			return (-1);
d536 2
a537 2
			log_debug("wrong write community");
			return (-1);
d542 1
d544 1
a544 2
		stats->snmp_ingetresponses++;
		goto fail;
d549 2
a550 2
			log_debug("wrong trap community");
			return (-1);
d552 1
a553 1
		stats->snmp_intraps++;
d557 1
a557 1
		goto fail;
d563 2
a564 2
		log_debug("community name too long");
		return (-1);
d572 2
a573 2
		log_debug("invalid PDU");
		return (-1);
d577 2
a578 2
		log_debug("invalid varbind");
		return (-1);
d585 1
d587 1
a587 2
	    log_host(ss, host, sizeof(host)),
	    msg->sm_version + 1, msg->sm_community, msg->sm_context,
d691 2
d694 1
a694 1
	stats->snmp_inasnparseerrs++;
@


1.16
log
@fix a memleak in the snmp engine and the ber i/o; free the dynamically
allocated ber write buffer after using it.  extend the ber api with a
ber_free() function to do the required cleanup.

Thanks to Will Backman (bitgeist at yahoo dot com) for testing and for
figuring out that there was a memleak.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.15 2008/01/16 21:43:19 reyk Exp $	*/
d575 1
a575 1
	if (class != BER_CLASS_UNIVERSAL && type != BER_TYPE_SEQUENCE) {
d595 1
a595 1
		if (a->be_class != BER_CLASS_UNIVERSAL &&
d597 1
a597 1
			goto varfail;
@


1.15
log
@send a coldStart trap to registered receivers on startup and cleanup
the trap code a little bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.14 2008/01/16 19:36:06 reyk Exp $	*/
d702 1
a702 1
	u_int8_t		 buf[READ_BUF_SIZE], *ptr;
d778 1
@


1.14
log
@implementation of the SNMP trap sender interface
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.13 2008/01/16 09:51:15 reyk Exp $	*/
d157 1
@


1.13
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.12 2008/01/16 09:42:29 reyk Exp $	*/
a48 1
int	 snmpe_socket_af(struct sockaddr_storage *, in_port_t);
a218 21
snmpe_socket_af(struct sockaddr_storage *ss, in_port_t port)
{
	switch (ss->ss_family) {
	case AF_INET:
		((struct sockaddr_in *)ss)->sin_port = port;
		((struct sockaddr_in *)ss)->sin_len =
		    sizeof(struct sockaddr_in);
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)ss)->sin6_port = port;
		((struct sockaddr_in6 *)ss)->sin6_len =
		    sizeof(struct sockaddr_in6);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
d222 1
a222 1
	int	 s = -1;
d224 2
a225 5
	if (snmpe_socket_af(&addr->ss, htons(addr->port)) == -1)
		goto bad;

	if ((s = socket(addr->ss.ss_family, SOCK_DGRAM, IPPROTO_UDP)) == -1)
		goto bad;
d244 1
a244 2
	if (s != -1)
		close(s);
d249 1
a249 1
static void
d715 1
d718 1
a719 1
	ber_set_readbuf(&ber, buf, len);
@


1.12
log
@move trap code to an own file; there will be more
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.11 2008/01/16 09:36:30 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007 Reyk Floeter <reyk@@vantronix.net>
@


1.11
log
@start working on an interface to send traps via snmpd.sock.  userland
applications will be able to send imsgs defining the trap to snmpd and
the daemon will do the ASN.1/BER encoding before sending traps to the
registered receivers.  there are two advantages of this approach that
a) the applications do not need to handle any ASN.1/BER encoding and
b) snmpd will provide a central interface to define trap receivers.

discussed with thib and others
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.10 2008/01/12 13:57:43 reyk Exp $	*/
a805 152
}

int
snmpe_trap(struct imsgbuf *ibuf, pid_t pid)
{
	struct imsg	 	 imsg;
	int		 	 ret = -1, n, x = 0;
	int		 	 done = 0;
	struct snmp_imsg	*sm;
	u_int32_t	 	 d;
	u_int64_t	 	 l;
	u_int8_t		*c;
	char			 o[SNMP_MAX_OID_LEN];
	struct ber_element	*ber, *trap = NULL, *oid = NULL, *a;
	size_t			 len;

	ber = trap = ber_add_sequence(NULL);

	while (!done) {
		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				goto done;
			if (n == 0)
				break;
			switch (imsg.hdr.type) {
			case IMSG_SNMP_ELEMENT:
				if (imsg.hdr.len < (IMSG_HEADER_SIZE +
				    sizeof(struct snmp_imsg)))
					goto imsgdone;

				sm = (struct snmp_imsg *)imsg.data;

				if (oid == NULL) {
					/* First element must be the trap OID */
					if (sm->snmp_type != SNMP_NULL)
						goto imsgdone;
					ber = oid = ber_printf_elements(ber,
					    "{o0}", sm->snmp_oid);
					break;
				}

				ber = a = ber_add_sequence(ber);
				a = ber_add_oidstring(a, sm->snmp_oid);

				switch (sm->snmp_type) {
				case SNMP_OBJECT:
					if (sm->snmp_len != sizeof(o))
						goto imsgdone;
					bcopy(sm + 1, &o, sm->snmp_len);
					a = ber_add_oidstring(a, o);
					break;
				case SNMP_BITSTRING:
				case SNMP_OCTETSTRING:
					if ((sm->snmp_len < 1) ||
					    (sm->snmp_len >= SNMPD_MAXSTRLEN))
						goto imsgdone;
					if ((c =
					    calloc(1, sm->snmp_len)) == NULL)
						goto imsgdone;
					bcopy(sm + 1, c, sm->snmp_len);
					if (sm->snmp_type == SNMP_BITSTRING)
						a = ber_add_bitstring(a, c,
						    sm->snmp_len);
					else
						a = ber_add_nstring(a, c,
						    sm->snmp_len);
					a->be_free = 1;
					break;
				case SNMP_NULL:
					a = ber_add_null(a);
					break;
				case SNMP_INTEGER32:
				case SNMP_IPADDR:
				case SNMP_COUNTER32:
				case SNMP_GAUGE32:
				case SNMP_TIMETICKS:
				case SNMP_OPAQUE:
				case SNMP_UINTEGER32:
					if (sm->snmp_len != sizeof(d))
						goto imsgdone;
					bcopy(sm + 1, &d, sm->snmp_len);
					a = ber_add_integer(a, d);
					break;
				case SNMP_COUNTER64:
					if (sm->snmp_len != sizeof(l))
						goto imsgdone;
					bcopy(sm + 1, &l, sm->snmp_len);
					a = ber_add_integer(a, d);
					break;
				default:
					log_debug("snmpe_trap: illegal type %d",
					    sm->snmp_type);
					imsg_free(&imsg);
					goto imsgdone;
				}
				switch (sm->snmp_type) {
				case SNMP_INTEGER32:
				case SNMP_BITSTRING:
				case SNMP_OCTETSTRING:
				case SNMP_NULL:
				case SNMP_OBJECT:
					/* universal types */
					break;
				case SNMP_IPADDR:
				case SNMP_COUNTER32:
				case SNMP_GAUGE32:
				case SNMP_TIMETICKS:
				case SNMP_OPAQUE:
				case SNMP_NSAPADDR:
				case SNMP_COUNTER64:
				case SNMP_UINTEGER32:
					/* application-specific types */
					ber_set_header(a, BER_CLASS_APPLICATION,
					    sm->snmp_type);
					break;
				}
				x++;
				break;
			case IMSG_SNMP_END:
				done = 1;
				break;
			default:
				log_debug("snmpe_trap: illegal imsg %d",
				    imsg.hdr.type);
				goto imsgdone;
			}
			imsg_free(&imsg);
		}
		if (done)
			break;
		if ((n = imsg_read(ibuf)) == -1)
			goto done;
		if (n == 0)
			goto done;
	}

	len = ber_calc_len(trap);
	log_debug("snmpe_trap: %d bytes from pid %d", len, pid);

	/* XXX send trap to registered receivers */

#ifdef DEBUG
	snmpe_debug_elements(trap);
#endif

	ret = 0;
 imsgdone:
	if (ret != 0)
		imsg_free(&imsg);
 done:
	ber_free_elements(trap);
	return (ret);
@


1.10
log
@unbreak DEBUG code
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.9 2008/01/11 12:12:14 reyk Exp $	*/
d806 152
@


1.9
log
@rename snmp context type enum elements
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.8 2008/01/03 15:32:48 reyk Exp $	*/
d366 1
a366 1
		case SNMP_T_GETREQ:
d369 1
a369 1
		case SNMP_T_GETNEXTREQ:
d372 1
a372 1
		case SNMP_T_GETRESP:
d375 1
a375 1
		case SNMP_T_SETREQ:
d378 1
a378 1
		case SNMP_T_TRAP:
d381 1
a381 1
		case SNMP_T_GETBULKREQ:
d384 1
a384 1
		case SNMP_T_INFORMREQ:
d387 1
a387 1
		case SNMP_T_TRAPV2:
d390 1
a390 1
		case SNMP_T_REPORT:
@


1.8
log
@send the correct length
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.7 2008/01/03 15:03:47 reyk Exp $	*/
d533 1
a533 1
	case SNMP_T_GETBULKREQ:
d540 1
a540 1
	case SNMP_T_GETREQ:
d543 2
a544 2
	case SNMP_T_GETNEXTREQ:
		if (type == SNMP_T_GETNEXTREQ)
d554 1
a554 1
	case SNMP_T_SETREQ:
d566 1
a566 1
	case SNMP_T_GETRESP:
d570 2
a571 2
	case SNMP_T_TRAP:
	case SNMP_T_TRAPV2:
d633 1
a633 1
				if (msg->sm_context == SNMP_T_SETREQ)
d643 1
a643 1
				case SNMP_T_GETNEXTREQ:
d652 1
a652 1
				case SNMP_T_GETREQ:
d659 1
a659 1
				case SNMP_T_SETREQ:
d664 1
a664 1
				case SNMP_T_GETBULKREQ:
d785 1
a785 1
	    BER_CLASS_CONTEXT, SNMP_T_GETRESP,
@


1.7
log
@handle no more than 2147483647 (0x7fffffff) variable bindings
From RFC3416
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.6 2008/01/03 14:24:15 reyk Exp $	*/
d793 2
a794 2
	ber_write_elements(&ber, resp);
	if ((len = ber_get_writebuf(&ber, (void *)&ptr)) == -1)
@


1.6
log
@fix parsing of get* requests with multiple varbind elements
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.5 2007/12/28 16:59:31 reyk Exp $	*/
d504 1
a504 1
	int			 class, state, i = 0, j = 0;
d617 1
a617 1
	    a != NULL; a = next, i++) {
d633 4
@


1.5
log
@split code handling the "structure of management information" and the
"message processing subsystem" into separate files smi.c and mps.c
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.4 2007/12/27 20:39:32 maja Exp $	*/
d617 1
a617 1
	    a != NULL; a = a->be_next, i++) {
d694 2
a695 2
					ber_replace_elements(last, c);
				a = c;
a702 1
		last = a;
@


1.4
log
@Make a snmpwalk against snmpd on hppa and macppc work. armish still dont
work. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.3 2007/12/07 09:50:51 reyk Exp $	*/
d120 1
a120 1
	for (oid = NULL; (oid = mps_foreach(oid, 0)) != NULL;) {
d122 1
a122 1
		mps_oidstring(&oid->o_id, buf, sizeof(buf));
d440 1
a440 1
		    mps_oidstring(&o, str, sizeof(str)));
d634 1
a634 1
				    mps_oidstring(&o, buf, sizeof(buf)));
@


1.3
log
@add a new 'd' format to ber_printf_elements to pass ints instead of
long longs; you have to pass the right type with vargs. this finally
fixes the previous problem on i386.

discussed with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.2 2007/12/07 09:18:00 reyk Exp $	*/
d502 2
a503 2
	long long		 ver;
	unsigned long		 type, req, errval, erridx;
@


1.2
log
@unbreak snmpd on 32bit archs like i386
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.1 2007/12/05 09:22:44 reyk Exp $	*/
d610 1
a610 1
	log_debug("snmpe_parse: %s: SNMPv%d '%s' context %d request %d",
d728 1
a728 1
	struct ber_element	*req = NULL, *resp = NULL, *b, *c;
d780 1
a780 2
#ifdef notyet
	ber_printf_elements(resp, "is{tiii{e}}.",
a784 11
#else
	b = ber_add_integer(resp, msg.sm_version);
	b = ber_add_string(b, msg.sm_community);
	c = b = ber_add_sequence(b);
	ber_set_header(b, BER_CLASS_CONTEXT, SNMP_T_GETRESP);
	c = ber_add_integer(c, msg.sm_request);
	c = ber_add_integer(c, msg.sm_error);
	c = ber_add_integer(c, msg.sm_errorindex);
	c = ber_add_sequence(c);
	ber_link_elements(c, msg.sm_varbindresp);
#endif
@


1.1
log
@Start working on snmpd(8) and snmpctl(8), a lightweight SNMP implementation
for OpenBSD.  SNMP is a necessary evil.  This is work in progress, don't
expect too much from it yet.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpe.c,v 1.15 2007/11/14 11:17:46 reyk Exp $	*/
d728 1
a728 1
	struct ber_element	*req = NULL, *resp = NULL;
d780 1
d786 11
@

