head	1.34;
access;
symbols
	OPENBSD_6_2:1.34.0.2
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.24.0.2
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15;
locks; strict;
comment	@ * @;


1.34
date	2016.09.02.17.59.58;	author benno;	state Exp;
branches;
next	1.33;
commitid	q45EjvXYS6j1V7Qb;

1.33
date	2016.09.02.16.46.29;	author renato;	state Exp;
branches;
next	1.32;
commitid	K6uLqMvlsHB7ikcI;

1.32
date	2016.09.02.16.44.33;	author renato;	state Exp;
branches;
next	1.31;
commitid	o7fEENaKxNIOcUKV;

1.31
date	2016.09.02.16.39.44;	author renato;	state Exp;
branches;
next	1.30;
commitid	POT6tRNh9I6XBjro;

1.30
date	2016.09.02.16.36.33;	author renato;	state Exp;
branches;
next	1.29;
commitid	RP73Rgb2x0oQ1Vfz;

1.29
date	2016.09.02.16.34.20;	author renato;	state Exp;
branches;
next	1.28;
commitid	OEx84t3rZg0W9VAV;

1.28
date	2016.09.02.16.32.19;	author renato;	state Exp;
branches;
next	1.27;
commitid	DXJ3lzgOTpF2RJna;

1.27
date	2016.09.02.16.29.55;	author renato;	state Exp;
branches;
next	1.26;
commitid	w1am8mhLiSfZo4x6;

1.26
date	2016.09.02.16.23.50;	author renato;	state Exp;
branches;
next	1.25;
commitid	DH2pL4vn6jxcoOc4;

1.25
date	2016.08.08.16.48.53;	author renato;	state Exp;
branches;
next	1.24;
commitid	c8D4zvIO7MW01tkY;

1.24
date	2016.06.05.17.07.41;	author renato;	state Exp;
branches;
next	1.23;
commitid	Vz8UnMLlq0YkNvcG;

1.23
date	2016.06.05.03.36.41;	author renato;	state Exp;
branches;
next	1.22;
commitid	zEMo2iI4upK0IUZs;

1.22
date	2016.05.12.00.18.27;	author renato;	state Exp;
branches;
next	1.21;
commitid	odj3BGP4pqCw3ma3;

1.21
date	2016.05.12.00.15.24;	author renato;	state Exp;
branches;
next	1.20;
commitid	d0Cl14ESmQZtUiKF;

1.20
date	2016.04.18.13.14.27;	author renato;	state Exp;
branches;
next	1.19;
commitid	rJZSxp1A2B7ePbpv;

1.19
date	2016.04.15.13.31.03;	author renato;	state Exp;
branches;
next	1.18;
commitid	O4hLgqBnOhtx0sRS;

1.18
date	2016.04.15.13.27.58;	author renato;	state Exp;
branches;
next	1.17;
commitid	kPO5lrKuqb5ObcwF;

1.17
date	2016.04.15.13.21.45;	author renato;	state Exp;
branches;
next	1.16;
commitid	zOVrWYmdyccBjHwb;

1.16
date	2016.04.15.13.10.56;	author renato;	state Exp;
branches;
next	1.15;
commitid	uxYgTnCpWxKsx7Ds;

1.15
date	2016.02.21.19.01.12;	author renato;	state Exp;
branches;
next	1.14;
commitid	6khscN8oOn8rqpDY;

1.14
date	2016.02.21.18.56.49;	author renato;	state Exp;
branches;
next	1.13;
commitid	Fln6asbk1x7lkTSp;

1.13
date	2016.01.15.12.41.09;	author renato;	state Exp;
branches;
next	1.12;
commitid	mZmD6DNRylxiI3gq;

1.12
date	2016.01.15.12.36.41;	author renato;	state Exp;
branches;
next	1.11;
commitid	VxpaEFsR30Xigk4x;

1.11
date	2016.01.15.12.32.34;	author renato;	state Exp;
branches;
next	1.10;
commitid	NKjBajp5Z0fkMb21;

1.10
date	2015.12.13.18.55.53;	author renato;	state Exp;
branches;
next	1.9;
commitid	OoBnb9jAV4TnaVRr;

1.9
date	2015.12.05.15.49.01;	author claudio;	state Exp;
branches;
next	1.8;
commitid	2wnDVolm6bXCrxDq;

1.8
date	2015.10.25.00.43.35;	author renato;	state Exp;
branches;
next	1.7;
commitid	WBcSbkaRyPxQfriP;

1.7
date	2015.10.22.10.42.14;	author renato;	state Exp;
branches;
next	1.6;
commitid	mOhAYb8DLQxuefug;

1.6
date	2015.10.21.03.52.12;	author renato;	state Exp;
branches;
next	1.5;
commitid	67lIWG5WR4Do3HhB;

1.5
date	2015.10.10.05.12.33;	author renato;	state Exp;
branches;
next	1.4;
commitid	XDavuEoYjKwlIReL;

1.4
date	2015.10.10.05.09.19;	author renato;	state Exp;
branches;
next	1.3;
commitid	ihAjab5XlJsGNNhO;

1.3
date	2015.10.05.01.59.33;	author renato;	state Exp;
branches;
next	1.2;
commitid	gALnAEcCWDSQBrng;

1.2
date	2015.10.04.23.00.10;	author renato;	state Exp;
branches;
next	1.1;
commitid	vb2pR0BnPuOhwW09;

1.1
date	2015.10.02.04.26.47;	author renato;	state Exp;
branches;
next	;
commitid	dGX9Xs9GfneSNaca;


desc
@@


1.34
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@
@
text
@/*	$OpenBSD: eigrpe.c,v 1.33 2016/09/02 16:46:29 renato Exp $ */

/*
 * Copyright (c) 2015 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <netinet/in.h>
#include <netinet/ip.h>

#include <arpa/inet.h>
#include <errno.h>
#include <pwd.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "eigrpd.h"
#include "eigrpe.h"
#include "rde.h"
#include "log.h"
#include "control.h"

static void		 eigrpe_sig_handler(int, short, void *);
static __dead void	 eigrpe_shutdown(void);
static void		 eigrpe_dispatch_main(int, short, void *);
static void		 eigrpe_dispatch_rde(int, short, void *);

struct eigrpd_conf	*econf;

static struct event	 ev4;
static struct event	 ev6;
static struct imsgev	*iev_main;
static struct imsgev	*iev_rde;

/* ARGSUSED */
static void
eigrpe_sig_handler(int sig, short event, void *bula)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		eigrpe_shutdown();
		/* NOTREACHED */
	default:
		fatalx("unexpected signal");
	}
}

/* eigrp engine */
void
eigrpe(int debug, int verbose, char *sockname)
{
	struct passwd		*pw;
	struct event		 ev_sigint, ev_sigterm;

	econf = config_new_empty();

	log_init(debug);
	log_verbose(verbose);

	/* create eigrpd control socket outside chroot */
	global.csock = sockname;
	if (control_init(global.csock) == -1)
		fatalx("control socket setup failed");

	if (inet_pton(AF_INET, AllEIGRPRouters_v4, &global.mcast_addr_v4) != 1)
		fatal("inet_pton");
	if (inet_pton(AF_INET6, AllEIGRPRouters_v6, &global.mcast_addr_v6) != 1)
		fatal("inet_pton");

	/* create the raw ipv4 socket */
	if ((global.eigrp_socket_v4 = socket(AF_INET,
	    SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK, IPPROTO_EIGRP)) == -1)
		fatal("error creating raw ipv4 socket");

	/* set some defaults */
	if (if_set_ipv4_mcast_ttl(global.eigrp_socket_v4, EIGRP_IP_TTL) == -1)
		fatal("if_set_ipv4_mcast_ttl");
	if (if_set_ipv4_mcast_loop(global.eigrp_socket_v4) == -1)
		fatal("if_set_ipv4_mcast_loop");
	if (if_set_ipv4_recvif(global.eigrp_socket_v4, 1) == -1)
		fatal("if_set_ipv4_recvif");
	if (if_set_ipv4_hdrincl(global.eigrp_socket_v4) == -1)
		fatal("if_set_ipv4_hdrincl");
	if_set_sockbuf(global.eigrp_socket_v4);

	/* create the raw ipv6 socket */
	if ((global.eigrp_socket_v6 = socket(AF_INET6,
	    SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK, IPPROTO_EIGRP)) == -1)
		fatal("error creating raw ipv6 socket");

	/* set some defaults */
	if (if_set_ipv6_mcast_loop(global.eigrp_socket_v6) == -1)
		fatal("if_set_ipv6_mcast_loop");
	if (if_set_ipv6_pktinfo(global.eigrp_socket_v6, 1) == -1)
		fatal("if_set_ipv6_pktinfo");
	if (if_set_ipv6_dscp(global.eigrp_socket_v6,
	    IPTOS_PREC_NETCONTROL) == -1)
		fatal("if_set_ipv6_dscp");
	if_set_sockbuf(global.eigrp_socket_v6);

	if ((pw = getpwnam(EIGRPD_USER)) == NULL)
		fatal("getpwnam");

	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	setproctitle("eigrp engine");
	eigrpd_process = PROC_EIGRP_ENGINE;
	log_procname = log_procnames[eigrpd_process];

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	if (pledge("stdio cpath inet mcast recvfd", NULL) == -1)
		fatal("pledge");

	event_init();

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, eigrpe_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, eigrpe_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	/* setup pipe and event handler to the parent process */
	if ((iev_main = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_main->ibuf, 3);
	iev_main->handler = eigrpe_dispatch_main;
	iev_main->events = EV_READ;
	event_set(&iev_main->ev, iev_main->ibuf.fd, iev_main->events,
	    iev_main->handler, iev_main);
	event_add(&iev_main->ev, NULL);

	event_set(&ev4, global.eigrp_socket_v4, EV_READ|EV_PERSIST,
	    recv_packet, econf);
	event_add(&ev4, NULL);

	event_set(&ev6, global.eigrp_socket_v6, EV_READ|EV_PERSIST,
	    recv_packet, econf);
	event_add(&ev6, NULL);

	/* listen on eigrpd control socket */
	TAILQ_INIT(&ctl_conns);
	control_listen();

	if ((pkt_ptr = calloc(1, READ_BUF_SIZE)) == NULL)
		fatal("eigrpe");

	event_dispatch();

	eigrpe_shutdown();
}

static __dead void
eigrpe_shutdown(void)
{
	/* close pipes */
	msgbuf_write(&iev_rde->ibuf.w);
	msgbuf_clear(&iev_rde->ibuf.w);
	close(iev_rde->ibuf.fd);
	msgbuf_write(&iev_main->ibuf.w);
	msgbuf_clear(&iev_main->ibuf.w);
	close(iev_main->ibuf.fd);

	control_cleanup(global.csock);
	config_clear(econf);

	event_del(&ev4);
	event_del(&ev6);
	close(global.eigrp_socket_v4);
	close(global.eigrp_socket_v6);

	/* clean up */
	free(iev_rde);
	free(iev_main);
	free(pkt_ptr);

	log_info("eigrp engine exiting");
	exit(0);
}

/* imesg */
int
eigrpe_imsg_compose_parent(int type, pid_t pid, void *data, uint16_t datalen)
{
	return (imsg_compose_event(iev_main, type, 0, pid, -1, data, datalen));
}

int
eigrpe_imsg_compose_rde(int type, uint32_t peerid, pid_t pid,
    void *data, uint16_t datalen)
{
	return (imsg_compose_event(iev_rde, type, peerid, pid, -1,
	    data, datalen));
}

/* ARGSUSED */
static void
eigrpe_dispatch_main(int fd, short event, void *bula)
{
	static struct eigrpd_conf *nconf;
	static struct iface	*niface;
	static struct eigrp	*neigrp;
	struct eigrp_iface	*nei;
	struct imsg		 imsg;
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct iface		*iface = NULL;
	struct kif		*kif;
	struct kaddr		*ka;
	int			 n, shut = 0;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("eigrpe_dispatch_main: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_IFINFO:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct kif))
				fatalx("IFSTATUS imsg with wrong len");
			kif = imsg.data;

			iface = if_lookup(econf, kif->ifindex);
			if (!iface)
				break;

			iface->flags = kif->flags;
			iface->linkstate = kif->link_state;
			if_update(iface, AF_UNSPEC);
			break;
		case IMSG_NEWADDR:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct kaddr))
				fatalx("NEWADDR imsg with wrong len");
			ka = imsg.data;

			iface = if_lookup(econf, ka->ifindex);
			if (iface == NULL)
				break;

			if_addr_new(iface, ka);
			break;
		case IMSG_DELADDR:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct kaddr))
				fatalx("DELADDR imsg with wrong len");
			ka = imsg.data;

			iface = if_lookup(econf, ka->ifindex);
			if (iface == NULL)
				break;

			if_addr_del(iface, ka);
			break;
		case IMSG_SOCKET_IPC:
			if (iev_rde) {
				log_warnx("%s: received unexpected imsg fd "
				    "to rde", __func__);
				break;
			}
			if ((fd = imsg.fd) == -1) {
				log_warnx("%s: expected to receive imsg fd to "
				    "rde but didn't receive any", __func__);
				break;
			}

			iev_rde = malloc(sizeof(struct imsgev));
			if (iev_rde == NULL)
				fatal(NULL);
			imsg_init(&iev_rde->ibuf, fd);
			iev_rde->handler = eigrpe_dispatch_rde;
			iev_rde->events = EV_READ;
			event_set(&iev_rde->ev, iev_rde->ibuf.fd,
			    iev_rde->events, iev_rde->handler, iev_rde);
			event_add(&iev_rde->ev, NULL);
			break;
		case IMSG_RECONF_CONF:
			if ((nconf = malloc(sizeof(struct eigrpd_conf))) ==
			    NULL)
				fatal(NULL);
			memcpy(nconf, imsg.data, sizeof(struct eigrpd_conf));

			TAILQ_INIT(&nconf->iface_list);
			TAILQ_INIT(&nconf->instances);
			break;
		case IMSG_RECONF_INSTANCE:
			if ((neigrp = malloc(sizeof(struct eigrp))) == NULL)
				fatal(NULL);
			memcpy(neigrp, imsg.data, sizeof(struct eigrp));

			SIMPLEQ_INIT(&neigrp->redist_list);
			TAILQ_INIT(&neigrp->ei_list);
			RB_INIT(&neigrp->nbrs);
			RB_INIT(&neigrp->topology);
			TAILQ_INSERT_TAIL(&nconf->instances, neigrp, entry);
			break;
		case IMSG_RECONF_IFACE:
			niface = imsg.data;
			niface = if_lookup(nconf, niface->ifindex);
			if (niface)
				break;

			if ((niface = malloc(sizeof(struct iface))) == NULL)
				fatal(NULL);
			memcpy(niface, imsg.data, sizeof(struct iface));

			TAILQ_INIT(&niface->ei_list);
			TAILQ_INIT(&niface->addr_list);
			TAILQ_INSERT_TAIL(&nconf->iface_list, niface, entry);
			break;
		case IMSG_RECONF_EIGRP_IFACE:
			if (niface == NULL)
				break;
			if ((nei = malloc(sizeof(struct eigrp_iface))) == NULL)
				fatal(NULL);
			memcpy(nei, imsg.data, sizeof(struct eigrp_iface));

			nei->iface = niface;
			nei->eigrp = neigrp;
			TAILQ_INIT(&nei->nbr_list);
			TAILQ_INIT(&nei->update_list);
			TAILQ_INIT(&nei->query_list);
			TAILQ_INIT(&nei->summary_list);
			TAILQ_INSERT_TAIL(&niface->ei_list, nei, i_entry);
			TAILQ_INSERT_TAIL(&neigrp->ei_list, nei, e_entry);
			if (RB_INSERT(iface_id_head, &ifaces_by_id, nei) !=
			    NULL)
				fatalx("eigrpe_dispatch_main: "
				    "RB_INSERT(ifaces_by_id) failed");
			break;
		case IMSG_RECONF_END:
			merge_config(econf, nconf);
			nconf = NULL;
			break;
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_IFINFO:
		case IMSG_CTL_END:
			control_imsg_relay(&imsg);
			break;
		default:
			log_debug("%s: error handling imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
static void
eigrpe_dispatch_rde(int fd, short event, void *bula)
{
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct imsg		 imsg;
	struct nbr		*nbr;
	struct eigrp_iface	*ei;
	struct rinfo		 rinfo;
	int			 n, shut = 0;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("eigrpe_dispatch_rde: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_SEND_UPDATE:
		case IMSG_SEND_QUERY:
		case IMSG_SEND_REPLY:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(rinfo))
				fatalx("invalid size of rinfo");
			memcpy(&rinfo, imsg.data, sizeof(rinfo));

			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL) {
				log_debug("%s: cannot find rde neighbor",
				    __func__);
				break;
			}

			switch (imsg.hdr.type) {
			case IMSG_SEND_UPDATE:
				message_add(&nbr->update_list, &rinfo);
				break;
			case IMSG_SEND_QUERY:
				message_add(&nbr->query_list, &rinfo);
				break;
			case IMSG_SEND_REPLY:
				message_add(&nbr->reply_list, &rinfo);
				break;
			}
			break;
		case IMSG_SEND_MUPDATE:
		case IMSG_SEND_MQUERY:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(rinfo))
				fatalx("invalid size of rinfo");
			memcpy(&rinfo, imsg.data, sizeof(rinfo));

			ei = eigrp_if_lookup_id(imsg.hdr.peerid);
			if (ei == NULL) {
				log_debug("%s: cannot find interface",
				    __func__);
				break;
			}

			switch (imsg.hdr.type) {
			case IMSG_SEND_MUPDATE:
				message_add(&ei->update_list, &rinfo);
				break;
			case IMSG_SEND_MQUERY:
				message_add(&ei->query_list, &rinfo);
				break;
			}
			break;
		case IMSG_SEND_UPDATE_END:
		case IMSG_SEND_REPLY_END:
		case IMSG_SEND_SIAQUERY_END:
		case IMSG_SEND_SIAREPLY_END:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL) {
				log_debug("%s: cannot find rde neighbor",
				    __func__);
				break;
			}

			switch (imsg.hdr.type) {
			case IMSG_SEND_UPDATE_END:
				send_update(nbr->ei, nbr, 0, &nbr->update_list);
				message_list_clr(&nbr->update_list);
				break;
			case IMSG_SEND_REPLY_END:
				send_reply(nbr,  &nbr->reply_list, 0);
				message_list_clr(&nbr->reply_list);
				break;
			case IMSG_SEND_SIAQUERY_END:
				send_query(nbr->ei, nbr, &nbr->query_list, 1);
				message_list_clr(&nbr->query_list);
				break;
			case IMSG_SEND_SIAREPLY_END:
				send_reply(nbr, &nbr->reply_list, 1);
				message_list_clr(&nbr->reply_list);
				break;
			}
			break;
		case IMSG_SEND_MUPDATE_END:
		case IMSG_SEND_MQUERY_END:
			ei = eigrp_if_lookup_id(imsg.hdr.peerid);
			if (ei == NULL) {
				log_debug("%s: cannot find interface",
				    __func__);
				break;
			}

			switch (imsg.hdr.type) {
			case IMSG_SEND_MUPDATE_END:
				send_update(ei, NULL, 0, &ei->update_list);
				message_list_clr(&ei->update_list);
				break;
			case IMSG_SEND_MQUERY_END:
				send_query(ei, NULL, &ei->query_list, 0);
				message_list_clr(&ei->query_list);
				break;
			}
			break;
		case IMSG_NEIGHBOR_DOWN:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL) {
				log_debug("%s: cannot find rde neighbor",
				    __func__);
				break;
			}
			/* announce that this neighborship is dead */
			send_peerterm(nbr);
			nbr_del(nbr);
			break;
		case IMSG_CTL_SHOW_TOPOLOGY:
		case IMSG_CTL_END:
			control_imsg_relay(&imsg);
			break;
		default:
			log_debug("%s: error handling imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
eigrpe_instance_init(struct eigrp *eigrp)
{
}

void
eigrpe_instance_del(struct eigrp *eigrp)
{
	struct eigrp_iface	*ei;

	while ((ei = TAILQ_FIRST(&eigrp->ei_list)) != NULL)
		eigrp_if_del(ei);

	free(eigrp);
}

void
message_add(struct rinfo_head *rinfo_list, struct rinfo *rinfo)
{
	struct rinfo_entry	*re;

	re = calloc(1, sizeof(*re));
	if (re == NULL)
		fatal("message_add");
	re->rinfo = *rinfo;

	TAILQ_INSERT_TAIL(rinfo_list, re, entry);
}

void
message_list_clr(struct rinfo_head *rinfo_list)
{
	struct rinfo_entry	*re;

	while ((re = TAILQ_FIRST(rinfo_list)) != NULL) {
		TAILQ_REMOVE(rinfo_list, re, entry);
		free(re);
	}
}

void
seq_addr_list_clr(struct seq_addr_head *seq_addr_list)
{
	struct seq_addr_entry	*sa;

	while ((sa = TAILQ_FIRST(seq_addr_list)) != NULL) {
		TAILQ_REMOVE(seq_addr_list, sa, entry);
		free(sa);
	}
}

void
eigrpe_orig_local_route(struct eigrp_iface *ei, struct if_addr *if_addr,
    int withdraw)
{
	struct rinfo	 rinfo;

	memset(&rinfo, 0, sizeof(rinfo));
	rinfo.af = if_addr->af;
	rinfo.type = EIGRP_ROUTE_INTERNAL;
	rinfo.prefix = if_addr->addr;
	rinfo.prefixlen = if_addr->prefixlen;

	eigrp_applymask(rinfo.af, &rinfo.prefix, &rinfo.prefix,
	    rinfo.prefixlen);

	if (withdraw)
		rinfo.metric.delay = EIGRP_INFINITE_METRIC;
	else
		rinfo.metric.delay = eigrp_composite_delay(ei->delay);
	rinfo.metric.bandwidth = eigrp_composite_bandwidth(ei->bandwidth);
	metric_encode_mtu(rinfo.metric.mtu, ei->iface->mtu);
	rinfo.metric.hop_count = 0;
	rinfo.metric.reliability = DEFAULT_RELIABILITY;
	rinfo.metric.load = DEFAULT_LOAD;
	rinfo.metric.tag = 0;
	rinfo.metric.flags = 0;

	eigrpe_imsg_compose_rde(IMSG_RECV_UPDATE, ei->self->peerid, 0,
	    &rinfo, sizeof(rinfo));
}

void
eigrpe_iface_ctl(struct ctl_conn *c, unsigned int idx)
{
	struct eigrp		*eigrp;
	struct eigrp_iface	*ei;
	struct ctl_iface	*ictl;

	TAILQ_FOREACH(eigrp, &econf->instances, entry) {
		TAILQ_FOREACH(ei, &eigrp->ei_list, e_entry) {
			if (idx == 0 || idx == ei->iface->ifindex) {
				ictl = if_to_ctl(ei);
				imsg_compose_event(&c->iev,
				    IMSG_CTL_SHOW_INTERFACE, 0, 0, -1,
				    ictl, sizeof(struct ctl_iface));
			}
		}
	}
}

void
eigrpe_nbr_ctl(struct ctl_conn *c)
{
	struct eigrp	*eigrp;
	struct nbr	*nbr;
	struct ctl_nbr	*nctl;

	TAILQ_FOREACH(eigrp, &econf->instances, entry) {
		RB_FOREACH(nbr, nbr_addr_head, &eigrp->nbrs) {
			if (nbr->flags & (F_EIGRP_NBR_PENDING|F_EIGRP_NBR_SELF))
				continue;

			nctl = nbr_to_ctl(nbr);
			imsg_compose_event(&c->iev, IMSG_CTL_SHOW_NBR, 0,
			    0, -1, nctl, sizeof(struct ctl_nbr));
		}
	}

	imsg_compose_event(&c->iev, IMSG_CTL_END, 0, 0, -1, NULL, 0);
}

void
eigrpe_stats_ctl(struct ctl_conn *c)
{
	struct eigrp		*eigrp;
	struct ctl_stats	 sctl;

	TAILQ_FOREACH(eigrp, &econf->instances, entry) {
		sctl.af = eigrp->af;
		sctl.as = eigrp->as;
		sctl.stats = eigrp->stats;
		imsg_compose_event(&c->iev, IMSG_CTL_SHOW_STATS, 0,
		    0, -1, &sctl, sizeof(struct ctl_stats));
	}

	imsg_compose_event(&c->iev, IMSG_CTL_END, 0, 0, -1, NULL, 0);
}
@


1.33
log
@Minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.32 2016/09/02 16:44:33 renato Exp $ */
d129 1
@


1.32
log
@Make functions and variables static whenever possible.

style(9) says:
"Function prototypes for private functions (i.e., functions not used
elsewhere) go at the top of the first source module. In userland,
functions local to one source module should be declared 'static'".

The benefits of doing so include:
* clean up of the eigrpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Additional changes:
* Declare all extern variables in header files;
* Clean up the indentation of all function prototypes and global
  variables.

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.31 2016/09/02 16:39:44 renato Exp $ */
d67 1
a67 1
pid_t
a175 2
	/* NOTREACHED */
	return (0);
@


1.31
log
@Use static local variables instead of global variables whenever possible.

Also, there's no need to zero initialize global and static variables,
that's done automatically by the compiler.

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.30 2016/09/02 16:36:33 renato Exp $ */
d40 6
a45 2
void		 eigrpe_sig_handler(int, short, void *);
__dead void	 eigrpe_shutdown(void);
d49 2
a50 9
struct eigrpd_conf	*econf;
struct imsgev		*iev_main;
struct imsgev		*iev_rde;

extern struct iface_id_head ifaces_by_id;
RB_PROTOTYPE(iface_id_head, eigrp_iface, id_tree, iface_id_compare)

extern struct nbr_addr_head nbrs_by_addr;
RB_PROTOTYPE(nbr_addr_head, nbr, addr_tree, nbr_compare)
d53 1
a53 1
void
d180 1
a180 1
__dead void
d224 1
a224 1
void
d399 1
a399 1
void
@


1.30
log
@Merge the recv_packet_v[46] functions into one.

This reduces some code duplication and makes it easier to see the
difference between the IPv4 and IPv6 raw sockets API.

tweak + ok claudio@@, ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.29 2016/09/02 16:34:20 renato Exp $ */
d45 1
a45 1
struct eigrpd_conf	*econf = NULL, *nconf;
d230 2
a231 1
	static struct iface	*niface = NULL;
@


1.29
log
@Simplify handling of multicast addresses.

During the initialization of the eigrpe process, use inet_pton() to
store the EIGRP multicast addresses in two global variables:
* global.mcast_addr_v4 (in_addr);
* global.mcast_addr_v6 (in6_addr).

This way we don't need to create temporary in_addr/in6_addr variables
everytime we need to use these multicast addresses for something.

"I like this" claudio@@ ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.28 2016/09/02 16:32:19 renato Exp $ */
d162 1
a162 1
	    recv_packet_v4, econf);
d166 1
a166 1
	    recv_packet_v6, econf);
@


1.28
log
@Pledge earlier on eigrpe.

This is for consistency with the other routing daemons.

ok claudio@@ "earlier is better" benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.27 2016/09/02 16:29:55 renato Exp $ */
d85 5
@


1.27
log
@Remove superfluous includes and follow style(9).

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.26 2016/09/02 16:23:50 renato Exp $ */
d133 3
a169 3

	if (pledge("stdio cpath inet mcast recvfd", NULL) == -1)
		fatal("pledge");
@


1.26
log
@Fix broken pipe teardown.

* Add missing close() calls to actually close the pipes, calling just
  msgbuf_clean() is not enough;
* Bring back some NOTREACHED lint comments. style(9) says they can be
  removed but in some cases they are useful to humans too;
* Add __dead to the shutdown functions;
* Some other minor changes to make eigrpd(8) more similar to the other
  routing daemons.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.25 2016/08/08 16:48:53 renato Exp $ */
d22 4
a25 1
#include <stdlib.h>
d27 2
d30 1
a31 2
#include <fcntl.h>
#include <pwd.h>
a32 1
#include <errno.h>
a33 1
#include "eigrp.h"
d37 1
a38 1
#include "log.h"
@


1.25
log
@rde and eigrpe should use exit(3) instead of _exit(2)

Since recently these processes call exec() after fork(), so they should
stop using _exit(2) and use exit(3) instead when shutting down.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.24 2016/06/05 17:07:41 renato Exp $ */
d39 1
a39 1
void		 eigrpe_shutdown(void);
d176 1
a176 1
void
d179 8
a187 1

a195 2
	msgbuf_write(&iev_rde->ibuf.w);
	msgbuf_clear(&iev_rde->ibuf.w);
a196 2
	msgbuf_write(&iev_main->ibuf.w);
	msgbuf_clear(&iev_main->ibuf.w);
@


1.24
log
@Call if_update() only when necessary for IPv6 address changes.

For EIGRPv6, an interface only needs an link-local address in order
to be enabled in the routing daemon. So adding or removing global
unicast addresses, for example, will never trigger a state change in
the interface.

Additionally, move all address handling code to if_addr_new() and
if_addr_del() to improve readability.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.23 2016/06/05 03:36:41 renato Exp $ */
d198 1
a198 1
	_exit(0);
@


1.23
log
@Improve security by calling exec after fork.

For each child process (rde and eigrpe), re-exec eigrpd with a special
"per-role" getopt flag. This way we have seperate ASLR/cookies per
process.

Based on a similar patch for bgpd, from claudio@@

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.22 2016/05/12 00:18:27 renato Exp $ */
a274 7
			if (ka->af == AF_INET6 &&
			    IN6_IS_ADDR_LINKLOCAL(&ka->addr.v6)) {
				iface->linklocal = ka->addr.v6;
				if_update(iface, AF_INET6);
				break;
			}

a285 9

			if (ka->af == AF_INET6 &&
			    IN6_ARE_ADDR_EQUAL(&iface->linklocal,
			    &ka->addr.v6)) {
				memset(&iface->linklocal, 0,
				    sizeof(iface->linklocal));
				if_update(iface, AF_INET6);
				break;
			}
@


1.22
log
@Disable EIGRPv6 on an interface when it loses its link-local address.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.21 2016/05/12 00:15:24 renato Exp $ */
d69 1
a69 2
eigrpe(struct eigrpd_conf *xconf, int pipe_parent2eigrpe[2],
    int pipe_eigrpe2rde[2], int pipe_parent2rde[2])
a72 2
	pid_t			 pid;
	struct iface		*iface;
d74 4
a77 8
	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}
d80 1
a114 2
	econf = xconf;

d141 2
a142 8
	/* setup pipes */
	close(pipe_parent2eigrpe[0]);
	close(pipe_eigrpe2rde[1]);
	close(pipe_parent2rde[0]);
	close(pipe_parent2rde[1]);

	if ((iev_rde = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_main = malloc(sizeof(struct imsgev))) == NULL)
d144 1
a144 3
	imsg_init(&iev_rde->ibuf, pipe_eigrpe2rde[0]);
	iev_rde->handler = eigrpe_dispatch_rde;
	imsg_init(&iev_main->ibuf, pipe_parent2eigrpe[1]);
a145 7

	/* setup event handler */
	iev_rde->events = EV_READ;
	event_set(&iev_rde->ev, iev_rde->ibuf.fd, iev_rde->events,
	    iev_rde->handler, iev_rde);
	event_add(&iev_rde->ev, NULL);

d166 1
a166 5
	/* initialize interfaces */
	TAILQ_FOREACH(iface, &econf->iface_list, entry)
		if_init(xconf, iface);

	if (pledge("stdio cpath inet mcast", NULL) == -1)
d304 22
@


1.21
log
@Improve support for config reloading.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.20 2016/04/18 13:14:27 renato Exp $ */
d326 1
@


1.20
log
@Revert previous commit.

When a process receives an EOF on a socketpair, it removes the event
handler for that fd and then calls event_loopexit(). Once the process
leaves the main loop, it calls its shutdown function. With that said,
revert the previous patch because it was unnecessary.

Pointed out and ok by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.19 2016/04/15 13:31:03 renato Exp $ */
d247 1
a247 1
	struct iface		*niface = NULL;
@


1.19
log
@Kill the child processes if their parent dies unexpectedly.

There's no point on keeping eigrpd running if any of its processes
dies unexpectedly.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.18 2016/04/15 13:27:58 renato Exp $ */
d403 5
a407 2
	else
		eigrpe_shutdown();
d564 5
a568 2
	else
		eigrpe_shutdown();
@


1.18
log
@Fix segfault on reloading the config multiple times.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.17 2016/04/15 13:21:45 renato Exp $ */
d403 2
a404 5
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
d561 2
a562 5
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
@


1.17
log
@Move several other variables out of eigrpd_conf.

Now eigrpd_conf contains only variables that can be modified via a
config reload. The other variables were moved to a new struct called
eigrpd_global, which is now a central point for storing global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.16 2016/04/15 13:10:56 renato Exp $ */
d361 1
@


1.16
log
@Minor fixes and code cleanup.

* whitespace cleanup;
* copy in_addr structs directly;
* add more malloc return value checks;
* fix some log messages;
* turn ifacecnt into a static variable;
* use eigrp_addrcmp() on if_deladdr() to avoid code duplication;
* s/route_print_origin/log_route_origin/
* more smaller issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.15 2016/02/21 19:01:12 renato Exp $ */
d87 1
a87 1
	if (control_init(xconf->csock) == -1)
d91 1
a91 1
	if ((xconf->eigrp_socket_v4 = socket(AF_INET,
d96 1
a96 1
	if (if_set_ipv4_mcast_ttl(xconf->eigrp_socket_v4, EIGRP_IP_TTL) == -1)
d98 1
a98 1
	if (if_set_ipv4_mcast_loop(xconf->eigrp_socket_v4) == -1)
d100 1
a100 1
	if (if_set_ipv4_recvif(xconf->eigrp_socket_v4, 1) == -1)
d102 1
a102 1
	if (if_set_ipv4_hdrincl(xconf->eigrp_socket_v4) == -1)
d104 1
a104 1
	if_set_sockbuf(xconf->eigrp_socket_v4);
d107 1
a107 1
	if ((xconf->eigrp_socket_v6 = socket(AF_INET6,
d112 1
a112 1
	if (if_set_ipv6_mcast_loop(xconf->eigrp_socket_v6) == -1)
d114 1
a114 1
	if (if_set_ipv6_pktinfo(xconf->eigrp_socket_v6, 1) == -1)
d116 1
a116 1
	if (if_set_ipv6_dscp(xconf->eigrp_socket_v6,
d119 1
a119 1
	if_set_sockbuf(xconf->eigrp_socket_v6);
d174 1
a174 1
	event_set(&ev4, econf->eigrp_socket_v4, EV_READ|EV_PERSIST,
d178 1
a178 1
	event_set(&ev6, econf->eigrp_socket_v6, EV_READ|EV_PERSIST,
d206 1
a206 1
	control_cleanup(econf->csock);
d212 2
a213 2
	close(econf->eigrp_socket_v4);
	close(econf->eigrp_socket_v6);
@


1.15
log
@Move some functions around and rename a few variables and functions.

The sooner we do these changes the better. This rearrangement will make
the code easier to read.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.14 2016/02/21 18:56:49 renato Exp $ */
d381 1
a381 1
				fatalx("rde_dispatch_parent: "
@


1.14
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.13 2016/01/15 12:41:09 renato Exp $ */
d473 1
a473 1
			ei = eigrp_iface_find_id(imsg.hdr.peerid);
d521 1
a521 1
			ei = eigrp_iface_find_id(imsg.hdr.peerid);
@


1.13
log
@Minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.12 2016/01/15 12:36:41 renato Exp $ */
d304 1
a304 2
				memcpy(&iface->linklocal, &ka->addr.v6,
				    sizeof(iface->linklocal));
d594 1
a594 1
	memcpy(&re->rinfo, rinfo, sizeof(re->rinfo));;
d630 1
a630 1
	memcpy(&rinfo.prefix, &if_addr->addr, sizeof(rinfo.prefix));
d701 1
a701 1
		memcpy(&sctl.stats, &eigrp->stats, sizeof(sctl.stats));
@


1.12
log
@Add support for manually clearing neighbors.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.11 2016/01/15 12:32:34 renato Exp $ */
d69 2
a70 2
eigrpe(struct eigrpd_conf *xconf, int pipe_parent2eigrpe[2], int pipe_eigrpe2rde[2],
    int pipe_parent2rde[2])
@


1.11
log
@Do not set the EoT flag in the last startup update.

Unfortunately we don't have enough information to support the NSF feature,
the EIGRP draft is missing a lot of information in this regard.

The EoT flag is used as part of EIGRP NSF to announce the end of the
startup process with a neighbor. The problem is that, when we set this
flag, the Cisco neighbors will assume that we support NSF, which is
not true.  When this happens, these routers expect us to do things that
we don't know, and weird things can happen. So let's play safe and just
ignore this flag for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.10 2015/12/13 18:55:53 renato Exp $ */
d548 1
a548 1
			send_hello(nbr->ei, NULL, 0, 1);
@


1.10
log
@Introduce new command to show traffic statistics.

Can be useful as a troubleshooting tool.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.9 2015/12/05 15:49:01 claudio Exp $ */
d503 1
a503 2
				send_update(nbr->ei, nbr, 0, 1,
				    &nbr->update_list);
d531 1
a531 1
				send_update(ei, NULL, 0, 0, &ei->update_list);
@


1.9
log
@Forgot about eigrp when doing the imsg_read EAGAIN fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.8 2015/10/25 00:43:35 renato Exp $ */
d689 17
@


1.8
log
@Fix some bugs in the detection of when an interface can be enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.7 2015/10/22 10:42:14 renato Exp $ */
d259 1
a259 1
		if ((n = imsg_read(ibuf)) == -1)
d273 1
a273 1
			fatal("eigrpe_dispatch_main: imsg_read error");
d423 1
a423 1
		if ((n = imsg_read(ibuf)) == -1)
d437 1
a437 1
			fatal("eigrpe_dispatch_rde: imsg_read error");
@


1.7
log
@The eigrpe process also needs to pledge "cpath" for unlinking the
control socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.6 2015/10/21 03:52:12 renato Exp $ */
d306 1
@


1.6
log
@Add support for route summarization.

Working great but need more testing, especially with ipv6. For now
we don't validate if one configured summary is inside another or the
presence of duplicates. Will address these issues in a future commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.5 2015/10/10 05:12:33 renato Exp $ */
d193 1
a193 1
	if (pledge("stdio inet mcast", NULL) == -1)
@


1.5
log
@Make use of pledge(2).

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.4 2015/10/10 05:09:19 renato Exp $ */
d376 1
@


1.4
log
@Move some interface initialization bits from if_init() to eigrp_if_start()
and call if_init() only during the startup of the eigrpe process.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.3 2015/10/05 01:59:33 renato Exp $ */
d192 3
@


1.3
log
@When the SIA state is declared for a given destination, reset the
adjacency with the unresponsive neighbor(s).
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.2 2015/10/04 23:00:10 renato Exp $ */
a569 4
	struct eigrp_iface	*ei;

	TAILQ_FOREACH(ei, &eigrp->ei_list, e_entry)
		if_init(econf, ei->iface);
@


1.2
log
@Fix warnings and add safeguards to protect against corrupted data.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.c,v 1.1 2015/10/02 04:26:47 renato Exp $ */
d535 11
@


1.1
log
@Welcome eigrpd

The eigrpd daemon will support the Enhanced Interior Gateway Routing Protocol.

Built using the imsg/three process framework and heavily based on ospfd(8), ospf6d(8) and ldpd(8).

The current status of eigrpd(8) is as follows:
* Almost full compliance with the specification: DUAL FSM, RTP, CR mode, SIA, etc
* Support for both IPv4 and IPv6
* Support for multiple instances (different ASes/AFs) within the same process
* Support for rdomains (one process per rdomain)
* RIB/FIB synchronization
* Basic redistribution support

Not implemented features (yet):
* Configuration reload support (partially implemented)
* Route summarization
* Advanced route redistribution/filtering
* Carp integration
* Authentication (draft is missing information)
* Stub (not released by Cisco)

Not yet connected to the builds.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d244 1
a244 1
	struct iface		*niface;
d362 2
@

