head	1.22;
access;
symbols
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9;
locks; strict;
comment	@ * @;


1.22
date	2017.02.22.14.24.50;	author renato;	state Exp;
branches;
next	1.21;
commitid	x9CmxuqJPBEKTEJN;

1.21
date	2017.01.05.13.53.09;	author krw;	state Exp;
branches;
next	1.20;
commitid	3AKCl24jEn0sIt6p;

1.20
date	2017.01.05.12.42.18;	author krw;	state Exp;
branches;
next	1.19;
commitid	uzjOUwLRoN7KbcZI;

1.19
date	2016.09.02.16.44.33;	author renato;	state Exp;
branches;
next	1.18;
commitid	o7fEENaKxNIOcUKV;

1.18
date	2016.09.02.16.39.44;	author renato;	state Exp;
branches;
next	1.17;
commitid	POT6tRNh9I6XBjro;

1.17
date	2016.09.02.16.29.55;	author renato;	state Exp;
branches;
next	1.16;
commitid	w1am8mhLiSfZo4x6;

1.16
date	2016.06.21.21.35.24;	author benno;	state Exp;
branches;
next	1.15;
commitid	AL6SnrmnHkmPOpjv;

1.15
date	2016.06.05.03.36.41;	author renato;	state Exp;
branches;
next	1.14;
commitid	zEMo2iI4upK0IUZs;

1.14
date	2016.04.15.13.34.08;	author renato;	state Exp;
branches;
next	1.13;
commitid	uztiTpyTVAWMXZo3;

1.13
date	2016.04.15.13.24.52;	author renato;	state Exp;
branches;
next	1.12;
commitid	pGw6vPt52H3iOOrJ;

1.12
date	2016.04.15.13.21.45;	author renato;	state Exp;
branches;
next	1.11;
commitid	zOVrWYmdyccBjHwb;

1.11
date	2016.04.15.13.18.38;	author renato;	state Exp;
branches;
next	1.10;
commitid	0UlzEoUmDtZvwtk7;

1.10
date	2016.04.15.13.10.56;	author renato;	state Exp;
branches;
next	1.9;
commitid	uxYgTnCpWxKsx7Ds;

1.9
date	2016.02.21.19.01.12;	author renato;	state Exp;
branches;
next	1.8;
commitid	6khscN8oOn8rqpDY;

1.8
date	2016.02.21.18.56.49;	author renato;	state Exp;
branches;
next	1.7;
commitid	Fln6asbk1x7lkTSp;

1.7
date	2016.02.21.18.53.54;	author renato;	state Exp;
branches;
next	1.6;
commitid	wQY3qMWTuqWqk9Cy;

1.6
date	2016.02.21.18.40.56;	author renato;	state Exp;
branches;
next	1.5;
commitid	kZCMT2snnUUUOEjb;

1.5
date	2016.01.15.12.23.45;	author renato;	state Exp;
branches;
next	1.4;
commitid	p7QeYTL0LDa4tIEh;

1.4
date	2015.10.21.03.52.12;	author renato;	state Exp;
branches;
next	1.3;
commitid	67lIWG5WR4Do3HhB;

1.3
date	2015.10.19.14.15.59;	author jsg;	state Exp;
branches;
next	1.2;
commitid	omre81EH1ygWNa47;

1.2
date	2015.10.04.22.54.38;	author renato;	state Exp;
branches;
next	1.1;
commitid	UF6urvMjq1VzeguX;

1.1
date	2015.10.02.04.26.47;	author renato;	state Exp;
branches;
next	;
commitid	dGX9Xs9GfneSNaca;


desc
@@


1.22
log
@No need to use SIOCGIFRDOMAIN anymore.
@
text
@/*	$OpenBSD: parse.y,v 1.21 2017/01/05 13:53:09 krw Exp $ */

/*
 * Copyright (c) 2015 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2004 Ryan McBride <mcbride@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <net/route.h>

#include <arpa/inet.h>
#include <ctype.h>
#include <err.h>
#include <ifaddrs.h>
#include <limits.h>
#include <stdio.h>
#include <syslog.h>
#include <unistd.h>

#include "eigrpd.h"
#include "eigrpe.h"
#include "log.h"

struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
};
TAILQ_HEAD(files, file);

struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
TAILQ_HEAD(symhead, sym);

struct config_defaults {
	uint8_t		kvalues[6];
	uint16_t	active_timeout;
	uint8_t		maximum_hops;
	uint8_t		maximum_paths;
	uint8_t		variance;
	struct redist_metric *dflt_metric;
	uint16_t	hello_interval;
	uint16_t	hello_holdtime;
	uint32_t	delay;
	uint32_t	bandwidth;
	uint8_t		splithorizon;
};

typedef struct {
	union {
		int64_t			 number;
		char			*string;
		struct redistribute	*redist;
		struct redist_metric	*redist_metric;
	} v;
	int lineno;
} YYSTYPE;

#define MAXPUSHBACK	128

static int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
static int		 kw_cmp(const void *, const void *);
static int		 lookup(char *);
static int		 lgetc(int);
static int		 lungetc(int);
static int		 findeol(void);
static int		 yylex(void);
static int		 check_file_secrecy(int, const char *);
static struct file	*pushfile(const char *, int);
static int		 popfile(void);
static int		 yyparse(void);
static int		 symset(const char *, const char *, int);
static char		*symget(const char *);
static struct eigrp	*conf_get_instance(uint16_t);
static struct eigrp_iface *conf_get_if(struct kif *);
int			 conf_check_rdomain(unsigned int);
static void		 clear_config(struct eigrpd_conf *xconf);
static uint32_t	 get_rtr_id(void);
static int		 get_prefix(const char *, union eigrpd_addr *, uint8_t *);

static struct file		*file, *topfile;
static struct files		 files = TAILQ_HEAD_INITIALIZER(files);
static struct symhead		 symhead = TAILQ_HEAD_INITIALIZER(symhead);
static struct eigrpd_conf	*conf;
static int			 errors;

static int			 af;
static struct eigrp		*eigrp;
static struct eigrp_iface	*ei;

static struct config_defaults	 globaldefs;
static struct config_defaults	 afdefs;
static struct config_defaults	 asdefs;
static struct config_defaults	 ifacedefs;
static struct config_defaults	*defs;

static unsigned char		*parsebuf;
static int			 parseindex;
static unsigned char		 pushback_buffer[MAXPUSHBACK];
static int			 pushback_index;

%}

%token	ROUTERID AS FIBUPDATE RDOMAIN REDISTRIBUTE METRIC DFLTMETRIC
%token	MAXHOPS MAXPATHS VARIANCE FIBPRIORITY_INT FIBPRIORITY_EXT
%token	FIBPRIORITY_SUMM SUMMARY_ADDR
%token	AF IPV4 IPV6 HELLOINTERVAL HOLDTIME KVALUES ACTIVETIMEOUT
%token	INTERFACE PASSIVE DELAY BANDWIDTH SPLITHORIZON
%token	YES NO
%token	INCLUDE
%token	ERROR
%token	<v.string>	STRING
%token	<v.number>	NUMBER
%type	<v.number>	yesno no eigrp_af
%type	<v.string>	string
%type	<v.redist>	redistribute
%type	<v.redist_metric> redist_metric opt_red_metric

%%

grammar		: /* empty */
		| grammar include '\n'
		| grammar '\n'
		| grammar conf_main '\n'
		| grammar varset '\n'
		| grammar af '\n'
		| grammar error '\n'		{ file->errors++; }
		;

include		: INCLUDE STRING {
			struct file	*nfile;

			if ((nfile = pushfile($2, 1)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}
		;

string		: string STRING	{
			if (asprintf(&$$, "%s %s", $1, $2) == -1) {
				free($1);
				free($2);
				yyerror("string: asprintf");
				YYERROR;
			}
			free($1);
			free($2);
		}
		| STRING
		;

optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl		/* one newline or more */
		;

yesno		: YES	{ $$ = 1; }
		| NO	{ $$ = 0; }
		;

no		: /* empty */	{ $$ = 0; }
		| NO		{ $$ = 1; }
		;

eigrp_af	: IPV4	{ $$ = AF_INET; }
		| IPV6	{ $$ = AF_INET6; }
		;

varset		: STRING '=' string {
			char *s = $1;
			if (global.cmd_opts & EIGRPD_OPT_VERBOSE)
				printf("%s = \"%s\"\n", $1, $3);
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				fatal("cannot store variable");
			free($1);
			free($3);
		}
		;

conf_main	: ROUTERID STRING {
			if (!inet_aton($2, &conf->rtr_id)) {
				yyerror("error parsing router-id");
				free($2);
				YYERROR;
			}
			free($2);
			if (bad_addr_v4(conf->rtr_id)) {
				yyerror("invalid router-id");
				YYERROR;
			}
		}
		| FIBUPDATE yesno {
			if ($2 == 0)
				conf->flags |= EIGRPD_FLAG_NO_FIB_UPDATE;
			else
				conf->flags &= ~EIGRPD_FLAG_NO_FIB_UPDATE;
		}
		| RDOMAIN NUMBER {
			if ($2 < 0 || $2 > RT_TABLEID_MAX) {
				yyerror("invalid rdomain");
				YYERROR;
			}
			conf->rdomain = $2;
		}
		| FIBPRIORITY_INT NUMBER {
			if ($2 <= RTP_NONE || $2 > RTP_MAX) {
				yyerror("invalid fib-priority");
				YYERROR;
			}
			conf->fib_priority_internal = $2;
		}
		| FIBPRIORITY_EXT NUMBER {
			if ($2 <= RTP_NONE || $2 > RTP_MAX) {
				yyerror("invalid fib-priority");
				YYERROR;
			}
			conf->fib_priority_external = $2;
		}
		| FIBPRIORITY_SUMM NUMBER {
			if ($2 <= RTP_NONE || $2 > RTP_MAX) {
				yyerror("invalid fib-priority");
				YYERROR;
			}
			conf->fib_priority_summary = $2;
		}
		| defaults
		;

af		: AF eigrp_af {
			af = $2;
			afdefs = *defs;
			defs = &afdefs;
		} af_block {
			af = AF_UNSPEC;
			defs = &globaldefs;
		}
		;

af_block	: '{' optnl afopts_l '}'
		| '{' optnl '}'
		|
		;

afopts_l	: afopts_l afoptsl nl
		| afoptsl optnl
		;

afoptsl		: as
		| defaults
		;

as		: AS NUMBER {
			if ($2 < EIGRP_MIN_AS || $2 > EIGRP_MAX_AS) {
				yyerror("invalid autonomous-system");
				YYERROR;
			}
			eigrp = conf_get_instance($2);
			if (eigrp == NULL)
				YYERROR;

			asdefs = *defs;
			defs = &asdefs;
		} as_block {
			memcpy(eigrp->kvalues, defs->kvalues,
			    sizeof(eigrp->kvalues));
			eigrp->active_timeout = defs->active_timeout;
			eigrp->maximum_hops = defs->maximum_hops;
			eigrp->maximum_paths = defs->maximum_paths;
			eigrp->variance = defs->variance;
			eigrp->dflt_metric = defs->dflt_metric;
			eigrp = NULL;
			defs = &afdefs;
		}
		;

as_block	: '{' optnl asopts_l '}'
		| '{' optnl '}'
		|
		;

asopts_l	: asopts_l asoptsl nl
		| asoptsl optnl
		;

asoptsl		: interface
		| redistribute {
			SIMPLEQ_INSERT_TAIL(&eigrp->redist_list, $1, entry);
		}
		| defaults
		;

interface	: INTERFACE STRING {
			struct kif	*kif;

			if ((kif = kif_findname($2)) == NULL) {
				yyerror("unknown interface %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
			ei = conf_get_if(kif);
			if (ei == NULL)
				YYERROR;

			ifacedefs = *defs;
			defs = &ifacedefs;
		} interface_block {
			ei->hello_holdtime = defs->hello_holdtime;
			ei->hello_interval = defs->hello_interval;
			ei->delay = defs->delay;
			ei->bandwidth = defs->bandwidth;
			ei->splithorizon = defs->splithorizon;
			ei = NULL;
			defs = &asdefs;
		}
		;

interface_block	: '{' optnl interfaceopts_l '}'
		| '{' optnl '}'
		|
		;

interfaceopts_l	: interfaceopts_l interfaceoptsl nl
		| interfaceoptsl optnl
		;

interfaceoptsl	: PASSIVE { ei->passive = 1; }
		| SUMMARY_ADDR STRING {
			struct summary_addr	*s, *tmp;

			if ((s = calloc(1, sizeof(*s))) == NULL)
				fatal(NULL);
			if (get_prefix($2, &s->prefix, &s->prefixlen) < 0) {
				yyerror("invalid summary-address");
				free($2);
				free(s);
				YYERROR;
			}
			free($2);

			TAILQ_FOREACH(tmp, &ei->summary_list, entry) {
				if (eigrp_prefixcmp(af, &s->prefix,
				    &tmp->prefix, min(s->prefixlen,
				    tmp->prefixlen)) == 0) {
					yyerror("summary-address conflicts "
					    "with another summary-address "
					    "already configured");
					YYERROR;
				}
			}

			TAILQ_INSERT_TAIL(&ei->summary_list, s, entry);
		}
		| iface_defaults
		;

redistribute	: no REDISTRIBUTE STRING opt_red_metric {
			struct redistribute	*r;

			if ((r = calloc(1, sizeof(*r))) == NULL)
				fatal(NULL);
			if (!strcmp($3, "default"))
				r->type = REDIST_DEFAULT;
			else if (!strcmp($3, "static"))
				r->type = REDIST_STATIC;
			else if (!strcmp($3, "rip"))
				r->type = REDIST_RIP;
			else if (!strcmp($3, "ospf"))
				r->type = REDIST_OSPF;
			else if (!strcmp($3, "connected"))
				r->type = REDIST_CONNECTED;
			else if (get_prefix($3, &r->addr, &r->prefixlen) >= 0)
				r->type = REDIST_ADDR;
			else {
				yyerror("invalid redistribute");
				free($3);
				free(r);
				YYERROR;
			}

			r->af = af;
			if ($1)
				r->type |= REDIST_NO;
			r->metric = $4;
			free($3);
			$$ = r;
		}
		;

redist_metric	: NUMBER NUMBER NUMBER NUMBER NUMBER {
			struct redist_metric	*m;

			if ($1 < MIN_BANDWIDTH || $1 > MAX_BANDWIDTH) {
				yyerror("bandwidth out of range (%d-%d)",
				    MIN_BANDWIDTH, MAX_BANDWIDTH);
				YYERROR;
			}
			if ($2 < MIN_DELAY || $2 > MAX_DELAY) {
				yyerror("delay out of range (%d-%d)",
				    MIN_DELAY, MAX_DELAY);
				YYERROR;
			}
			if ($3 < MIN_RELIABILITY || $3 > MAX_RELIABILITY) {
				yyerror("reliability out of range (%d-%d)",
				    MIN_RELIABILITY, MAX_RELIABILITY);
				YYERROR;
			}
			if ($4 < MIN_LOAD || $4 > MAX_LOAD) {
				yyerror("load out of range (%d-%d)",
				    MIN_LOAD, MAX_LOAD);
				YYERROR;
			}
			if ($5 < MIN_MTU || $5 > MAX_MTU) {
				yyerror("mtu out of range (%d-%d)",
				    MIN_MTU, MAX_MTU);
				YYERROR;
			}

			if ((m = calloc(1, sizeof(*m))) == NULL)
				fatal(NULL);
			m->bandwidth = $1;
			m->delay = $2;
			m->reliability = $3;
			m->load = $4;
			m->mtu = $5;

			$$ = m;
		}
		;

opt_red_metric	: /* empty */		{ $$ = NULL; }
		| METRIC redist_metric 	{ $$ = $2; }
		;

defaults	: KVALUES NUMBER NUMBER NUMBER NUMBER NUMBER NUMBER {
			if ($2 < MIN_KVALUE || $2 > MAX_KVALUE ||
			    $3 < MIN_KVALUE || $3 > MAX_KVALUE ||
			    $4 < MIN_KVALUE || $4 > MAX_KVALUE ||
			    $5 < MIN_KVALUE || $5 > MAX_KVALUE ||
			    $6 < MIN_KVALUE || $6 > MAX_KVALUE ||
			    $7 < MIN_KVALUE || $7 > MAX_KVALUE) {
				yyerror("k-value out of range (%d-%d)",
				    MIN_KVALUE, MAX_KVALUE);
				YYERROR;
			}
			defs->kvalues[0] = $2;
			defs->kvalues[1] = $3;
			defs->kvalues[2] = $4;
			defs->kvalues[3] = $5;
			defs->kvalues[4] = $6;
			defs->kvalues[5] = $7;
		}
		| ACTIVETIMEOUT NUMBER {
			if ($2 < MIN_ACTIVE_TIMEOUT ||
			    $2 > MAX_ACTIVE_TIMEOUT) {
				yyerror("active-timeout out of range (%d-%d)",
				    MIN_ACTIVE_TIMEOUT, MAX_ACTIVE_TIMEOUT);
				YYERROR;
			}
			defs->active_timeout = $2;
		}
		| MAXHOPS NUMBER {
			if ($2 < MIN_MAXIMUM_HOPS ||
			    $2 > MAX_MAXIMUM_HOPS) {
				yyerror("maximum-hops out of range (%d-%d)",
				    MIN_MAXIMUM_HOPS, MAX_MAXIMUM_HOPS);
				YYERROR;
			}
			defs->maximum_hops = $2;
		}
		| MAXPATHS NUMBER {
			if ($2 < MIN_MAXIMUM_PATHS ||
			    $2 > MAX_MAXIMUM_PATHS) {
				yyerror("maximum-paths out of range (%d-%d)",
				    MIN_MAXIMUM_PATHS, MAX_MAXIMUM_PATHS);
				YYERROR;
			}
			defs->maximum_paths = $2;
		}
		| VARIANCE NUMBER {
			if ($2 < MIN_VARIANCE ||
			    $2 > MAX_VARIANCE) {
				yyerror("variance out of range (%d-%d)",
				    MIN_VARIANCE, MAX_VARIANCE);
				YYERROR;
			}
			defs->variance = $2;
		}
		| DFLTMETRIC redist_metric {
			defs->dflt_metric = $2;
		}
		| iface_defaults
		;

iface_defaults	: HELLOINTERVAL NUMBER {
			if ($2 < MIN_HELLO_INTERVAL ||
			    $2 > MAX_HELLO_INTERVAL) {
				yyerror("hello-interval out of range (%d-%d)",
				    MIN_HELLO_INTERVAL, MAX_HELLO_INTERVAL);
				YYERROR;
			}
			defs->hello_interval = $2;
		}
		| HOLDTIME NUMBER {
			if ($2 < MIN_HELLO_HOLDTIME ||
			    $2 > MAX_HELLO_HOLDTIME) {
				yyerror("hold-timel out of range (%d-%d)",
				    MIN_HELLO_HOLDTIME,
				    MAX_HELLO_HOLDTIME);
				YYERROR;
			}
			defs->hello_holdtime = $2;
		}
		| DELAY NUMBER {
			if ($2 < MIN_DELAY || $2 > MAX_DELAY) {
				yyerror("delay out of range (%d-%d)",
				    MIN_DELAY, MAX_DELAY);
				YYERROR;
			}
			defs->delay = $2;
		}
		| BANDWIDTH NUMBER {
			if ($2 < MIN_BANDWIDTH || $2 > MAX_BANDWIDTH) {
				yyerror("bandwidth out of range (%d-%d)",
				    MIN_BANDWIDTH, MAX_BANDWIDTH);
				YYERROR;
			}
			defs->bandwidth = $2;
		}
		| SPLITHORIZON yesno {
			defs->splithorizon = $2;
		}
		;

%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

static int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;
	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		fatalx("yyerror vasprintf");
	va_end(ap);
	logit(LOG_CRIT, "%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
	return (0);
}

static int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

static int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{"active-timeout",		ACTIVETIMEOUT},
		{"address-family",		AF},
		{"autonomous-system",		AS},
		{"bandwidth",			BANDWIDTH},
		{"default-metric",		DFLTMETRIC},
		{"delay",			DELAY},
		{"fib-priority-external",	FIBPRIORITY_EXT},
		{"fib-priority-internal",	FIBPRIORITY_INT},
		{"fib-priority-summary",	FIBPRIORITY_SUMM},
		{"fib-update",			FIBUPDATE},
		{"hello-interval",		HELLOINTERVAL},
		{"holdtime",			HOLDTIME},
		{"include",			INCLUDE},
		{"interface",			INTERFACE},
		{"ipv4",			IPV4},
		{"ipv6",			IPV6},
		{"k-values",			KVALUES},
		{"maximum-hops",		MAXHOPS},
		{"maximum-paths",		MAXPATHS},
		{"metric",			METRIC},
		{"no",				NO},
		{"passive",			PASSIVE},
		{"rdomain",			RDOMAIN},
		{"redistribute",		REDISTRIBUTE},
		{"router-id",			ROUTERID},
		{"split-horizon",		SPLITHORIZON},
		{"summary-address",		SUMMARY_ADDR},
		{"variance",			VARIANCE},
		{"yes",				YES}
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

static int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

static int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

static int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

static int
yylex(void)
{
	unsigned char	 buf[8096];
	unsigned char	*p, *val;
	int		 quotec, next, c;
	int		 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && \
	x != '!' && x != '=' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

static int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		log_warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		log_warnx("%s: group writable or world read/writable", fname);
		return (-1);
	}
	return (0);
}

static struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		log_warn("calloc");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		log_warn("strdup");
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		log_warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

static int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

struct eigrpd_conf *
parse_config(char *filename)
{
	struct sym	*sym, *next;

	conf = config_new_empty();
	conf->rdomain = 0;
	conf->fib_priority_internal = RTP_EIGRP;
	conf->fib_priority_external = RTP_EIGRP;
	conf->fib_priority_summary = RTP_EIGRP;

	defs = &globaldefs;
	defs->kvalues[0] = defs->kvalues[2] = 1;
	defs->active_timeout = DEFAULT_ACTIVE_TIMEOUT;
	defs->maximum_hops = DEFAULT_MAXIMUM_HOPS;
	defs->maximum_paths = DEFAULT_MAXIMUM_PATHS;
	defs->variance = DEFAULT_VARIANCE;
	defs->hello_holdtime = DEFAULT_HELLO_HOLDTIME;
	defs->hello_interval = DEFAULT_HELLO_INTERVAL;
	defs->delay = DEFAULT_DELAY;
	defs->bandwidth = DEFAULT_BANDWIDTH;
	defs->splithorizon = 1;

	if ((file = pushfile(filename,
	    !(global.cmd_opts & EIGRPD_OPT_NOACTION))) == NULL) {
		free(conf);
		return (NULL);
	}
	topfile = file;

	yyparse();
	errors = file->errors;
	popfile();

	/* Free macros and check which have not been used. */
	TAILQ_FOREACH_SAFE(sym, &symhead, entry, next) {
		if ((global.cmd_opts & EIGRPD_OPT_VERBOSE2) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	/* check that all interfaces belong to the configured rdomain */
	errors += conf_check_rdomain(conf->rdomain);

	if (errors) {
		clear_config(conf);
		return (NULL);
	}

	if (conf->rtr_id.s_addr == 0)
		conf->rtr_id.s_addr = get_rtr_id();

	return (conf);
}

static int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		errx(1, "cmdline_symset: malloc");

	strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

static char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

static struct eigrp *
conf_get_instance(uint16_t as)
{
	struct eigrp	*e, *tmp;

	if (eigrp_find(conf, af, as)) {
		yyerror("autonomous-system %u already configured"
		    "for address-family %s", as, af_name(af));
		return (NULL);
	}

	e = calloc(1, sizeof(struct eigrp));
	if (e == NULL)
		fatal(NULL);

	e->af = af;
	e->as = as;
	SIMPLEQ_INIT(&e->redist_list);
	TAILQ_INIT(&e->ei_list);
	RB_INIT(&e->nbrs);
	RB_INIT(&e->topology);

	/* start local sequence number used by RTP */
	e->seq_num = 1;

	/* order by address-family and then by autonomous-system */
	TAILQ_FOREACH(tmp, &conf->instances, entry)
		if (tmp->af > e->af ||
		    (tmp->af == e->af && tmp->as > e->as))
			break;
	if (tmp)
		TAILQ_INSERT_BEFORE(tmp, e, entry);
	else
		TAILQ_INSERT_TAIL(&conf->instances, e, entry);

	return (e);
}

static struct eigrp_iface *
conf_get_if(struct kif *kif)
{
	struct eigrp_iface	*e;

	TAILQ_FOREACH(e, &eigrp->ei_list, e_entry)
		if (e->iface->ifindex == kif->ifindex) {
			yyerror("interface %s already configured "
			    "for address-family %s and "
			    "autonomous-system %u", kif->ifname,
			    af_name(af), eigrp->as);
			return (NULL);
		}

	e = eigrp_if_new(conf, eigrp, kif);

	return (e);
}

int
conf_check_rdomain(unsigned int rdomain)
{
	struct iface	*iface;
	int		 errs = 0;

	TAILQ_FOREACH(iface, &conf->iface_list, entry) {
		if (iface->rdomain != rdomain) {
			logit(LOG_CRIT, "interface %s not in rdomain %u",
			    iface->name, rdomain);
			errs++;
		}
	}

	return (errs);
}

static void
clear_config(struct eigrpd_conf *xconf)
{
	struct eigrp		*e;
	struct redistribute	*r;
	struct eigrp_iface	*i;
	struct summary_addr	*s;

	while ((e = TAILQ_FIRST(&xconf->instances)) != NULL) {
		while (!SIMPLEQ_EMPTY(&e->redist_list)) {
			r = SIMPLEQ_FIRST(&e->redist_list);
			SIMPLEQ_REMOVE_HEAD(&e->redist_list, entry);
			free(r);
		}

		while ((i = TAILQ_FIRST(&e->ei_list)) != NULL) {
			RB_REMOVE(iface_id_head, &ifaces_by_id, i);
			TAILQ_REMOVE(&e->ei_list, i, e_entry);
			TAILQ_REMOVE(&e->ei_list, i, i_entry);
			while ((s = TAILQ_FIRST(&i->summary_list)) != NULL) {
				TAILQ_REMOVE(&i->summary_list, s, entry);
				free(s);
			}
			if (TAILQ_EMPTY(&i->iface->ei_list)) {
				TAILQ_REMOVE(&xconf->iface_list, i->iface, entry);
				free(i->iface);
			}
			free(i);
		}

		TAILQ_REMOVE(&xconf->instances, e, entry);
		free(e);
	}

	free(xconf);
}

static uint32_t
get_rtr_id(void)
{
	struct ifaddrs		*ifap, *ifa;
	uint32_t		 ip = 0, cur, localnet;

	localnet = htonl(INADDR_LOOPBACK & IN_CLASSA_NET);

	if (getifaddrs(&ifap) == -1)
		fatal("getifaddrs");

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (strncmp(ifa->ifa_name, "carp", 4) == 0)
			continue;
		if (ifa->ifa_addr->sa_family != AF_INET)
			continue;
		cur = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr;
		if ((cur & localnet) == localnet)	/* skip 127/8 */
			continue;
		if (ntohl(cur) < ntohl(ip) || ip == 0)
			ip = cur;
	}
	freeifaddrs(ifap);

	if (ip == 0)
		fatal("router-id is 0.0.0.0");

	return (ip);
}

static int
get_prefix(const char *s, union eigrpd_addr *addr, uint8_t *plen)
{
	char			*p, *ps;
	const char		*errstr;
	int			 maxplen;

	switch (af) {
	case AF_INET:
		maxplen = 32;
		break;
	case AF_INET6:
		maxplen = 128;
		break;
	default:
		return (-1);
	}

	if ((p = strrchr(s, '/')) != NULL) {
		*plen = strtonum(p + 1, 0, maxplen, &errstr);
		if (errstr) {
			log_warnx("prefixlen is %s: %s", errstr, p + 1);
			return (-1);
		}
		if ((ps = malloc(strlen(s) - strlen(p) + 1)) == NULL)
			fatal("get_prefix: malloc");
		strlcpy(ps, s, strlen(s) - strlen(p) + 1);
	} else {
		if ((ps = strdup(s)) == NULL)
			fatal("get_prefix: strdup");
		*plen = maxplen;
	}

	memset(addr, 0, sizeof(union eigrpd_addr));
	switch (af) {
	case AF_INET:
		if (inet_pton(AF_INET, ps, &addr->v4) != 1) {
			free(ps);
			return (-1);
		}
		break;
	case AF_INET6:
		if (inet_pton(AF_INET6, ps, &addr->v6) != 1) {
			free(ps);
			return (-1);
		}
		break;
	default:
		free(ps);
		return (-1);
	}
	eigrp_applymask(af, addr, addr, *plen);
	free(ps);

	return (0);
}
@


1.21
log
@Replace hand-rolled for(;;) emptying of 'symhead' TAILQ with more
modern TAILQ_FOREACH_SAFE().

No intentional functional change.

ok millert@@ bluhm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2017/01/05 12:42:18 krw Exp $ */
d105 1
d1004 3
d1149 17
@


1.20
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2016/09/02 16:44:33 renato Exp $ */
d991 1
a991 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
@


1.19
log
@Make functions and variables static whenever possible.

style(9) says:
"Function prototypes for private functions (i.e., functions not used
elsewhere) go at the top of the first source module. In userland,
functions local to one source module should be declared 'static'".

The benefits of doing so include:
* clean up of the eigrpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Additional changes:
* Declare all extern variables in header files;
* Clean up the indentation of all function prototypes and global
  variables.

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2016/09/02 16:39:44 renato Exp $ */
d1020 4
a1023 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d1082 1
a1082 1
	TAILQ_FOREACH(sym, &symhead, entry)
d1087 1
@


1.18
log
@Use static local variables instead of global variables whenever possible.

Also, there's no need to zero initialize global and static variables,
that's done automatically by the compiler.

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2016/09/02 16:29:55 renato Exp $ */
d44 1
a44 2
TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
d50 2
a51 14
} *file, *topfile;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);
a52 1
TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
d60 1
a60 13
int		 symset(const char *, const char *, int);
char		*symget(const char *);

void		 clear_config(struct eigrpd_conf *xconf);
uint32_t	 get_rtr_id(void);
int		 get_prefix(const char *, union eigrpd_addr *, uint8_t *);

static struct eigrpd_conf	*conf;
static int			 errors;

int			 af;
struct eigrp		*eigrp;
struct eigrp_iface	*ei;
a75 9
struct config_defaults	 globaldefs;
struct config_defaults	 afdefs;
struct config_defaults	 asdefs;
struct config_defaults	 ifacedefs;
struct config_defaults	*defs;

struct eigrp		*conf_get_instance(uint16_t);
struct eigrp_iface	*conf_get_if(struct kif *);

d86 44
d585 1
a585 1
int
d601 1
a601 1
int
d607 1
a607 1
int
d653 1
a653 8
#define MAXPUSHBACK	128

unsigned char	*parsebuf;
int		 parseindex;
unsigned char	 pushback_buffer[MAXPUSHBACK];
int		 pushback_index = 0;

int
d701 1
a701 1
int
d717 1
a717 1
int
d740 1
a740 1
int
d889 1
a889 1
int
d909 1
a909 1
struct file *
d940 1
a940 1
int
d1015 1
a1015 1
int
d1076 1
a1076 1
char *
d1089 1
a1089 1
struct eigrp *
d1127 1
a1127 1
struct eigrp_iface *
d1146 1
a1146 4
extern struct iface_id_head ifaces_by_id;
RB_PROTOTYPE(iface_id_head, eigrp_iface, id_tree, iface_id_compare)

void
d1183 1
a1183 1
uint32_t
d1213 1
a1213 1
int
@


1.17
log
@Remove superfluous includes and follow style(9).

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2016/06/21 21:35:24 benno Exp $ */
d82 1
a82 1
static int			 errors = 0;
d84 3
a86 3
int			 af = AF_UNSPEC;
struct eigrp		*eigrp = NULL;
struct eigrp_iface	*ei = NULL;
@


1.16
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2016/06/05 03:36:41 renato Exp $ */
d29 2
a30 1
#include <netinet/in.h>
a33 2
#include <errno.h>
#include <unistd.h>
a35 1
#include <stdarg.h>
a36 1
#include <string.h>
d38 1
a39 1
#include "eigrp.h"
@


1.15
log
@Improve security by calling exec after fork.

For each child process (rde and eigrpe), re-exec eigrpd with a special
"per-role" getopt flag. This way we have seperate ASLR/cookies per
process.

Based on a similar patch for bgpd, from claudio@@

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2016/04/15 13:34:08 renato Exp $ */
d200 1
d203 7
@


1.14
log
@Check for subnet overlap between the configured summary-addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2016/04/15 13:24:52 renato Exp $ */
d954 1
a954 2
	if ((conf = calloc(1, sizeof(struct eigrpd_conf))) == NULL)
		fatal("parse_config");
a977 3

	TAILQ_INIT(&conf->iface_list);
	TAILQ_INIT(&conf->instances);
@


1.13
log
@Properly implement the clear_config() function.

We need to free the internal pointers of the eigrpd_conf struct, not
only the main struct. This avoids memory leaks when a config reload
happens to fail (e.g. due to a syntax error).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2016/04/15 13:21:45 renato Exp $ */
d358 1
a358 1
			struct summary_addr	*s;
d368 12
a380 1
			free($2);
@


1.12
log
@Move several other variables out of eigrpd_conf.

Now eigrpd_conf contains only variables that can be modified via a
config reload. The other variables were moved to a new struct called
eigrpd_global, which is now a central point for storing global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2016/04/15 13:18:38 renato Exp $ */
d1132 3
d1138 31
@


1.11
log
@Move the command line options out of struct eigrpd_config
into an own flag field since these can't be modified via a
config reload.

Pulled from bgpd. Original author: claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2016/04/15 13:10:56 renato Exp $ */
d200 1
a200 1
			if (cmd_opts & EIGRPD_OPT_VERBOSE)
d962 2
a963 1
	if ((file = pushfile(filename, !(cmd_opts & EIGRPD_OPT_NOACTION))) == NULL) {
d979 1
a979 1
		if ((cmd_opts & EIGRPD_OPT_VERBOSE2) && !sym->used)
@


1.10
log
@Minor fixes and code cleanup.

* whitespace cleanup;
* copy in_addr structs directly;
* add more malloc return value checks;
* fix some log messages;
* turn ifacecnt into a static variable;
* use eigrp_addrcmp() on if_deladdr() to avoid code duplication;
* s/route_print_origin/log_route_origin/
* more smaller issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2016/02/21 19:01:12 renato Exp $ */
d200 1
a200 1
			if (conf->opts & EIGRPD_OPT_VERBOSE)
d939 1
a939 1
parse_config(char *filename, int opts)
a944 1
	conf->opts = opts;
d962 1
a962 1
	if ((file = pushfile(filename, !(conf->opts & EIGRPD_OPT_NOACTION))) == NULL) {
d978 1
a978 1
		if ((conf->opts & EIGRPD_OPT_VERBOSE2) && !sym->used)
@


1.9
log
@Move some functions around and rename a few variables and functions.

The sooner we do these changes the better. This rearrangement will make
the code easier to read.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2016/02/21 18:56:49 renato Exp $ */
d1087 3
@


1.8
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2016/02/21 18:53:54 renato Exp $ */
d82 1
a82 1
int		 host(const char *, union eigrpd_addr *, uint8_t *);
d152 1
a152 1
include		: INCLUDE STRING		{
d180 7
d199 1
a199 1
varset		: STRING '=' string		{
d258 117
d390 1
a390 1
			else if (host($3, &r->addr, &r->prefixlen) >= 0)
d449 2
a450 2
opt_red_metric	: /* empty */			{ $$ = NULL; }
		| METRIC redist_metric 		{ $$ = $2; }
a552 124
optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl		/* one newline or more */
		;

af		: AF eigrp_af {
			af = $2;
			afdefs = *defs;
			defs = &afdefs;
		} af_block {
			af = AF_UNSPEC;
			defs = &globaldefs;
		}
		;

af_block	: '{' optnl afopts_l '}'
		| '{' optnl '}'
		|
		;

afopts_l	: afopts_l afoptsl nl
		| afoptsl optnl
		;

afoptsl		: as
		| defaults
		;

as		: AS NUMBER {
			if ($2 < EIGRP_MIN_AS || $2 > EIGRP_MAX_AS) {
				yyerror("invalid autonomous-system");
				YYERROR;
			}
			eigrp = conf_get_instance($2);
			if (eigrp == NULL)
				YYERROR;

			asdefs = *defs;
			defs = &asdefs;
		} as_block {
			memcpy(eigrp->kvalues, defs->kvalues,
			    sizeof(eigrp->kvalues));
			eigrp->active_timeout = defs->active_timeout;
			eigrp->maximum_hops = defs->maximum_hops;
			eigrp->maximum_paths = defs->maximum_paths;
			eigrp->variance = defs->variance;
			eigrp->dflt_metric = defs->dflt_metric;
			eigrp = NULL;
			defs = &afdefs;
		}
		;

as_block	: '{' optnl asopts_l '}'
		| '{' optnl '}'
		|
		;

asopts_l	: asopts_l asoptsl nl
		| asoptsl optnl
		;

asoptsl		: interface
		| redistribute {
			SIMPLEQ_INSERT_TAIL(&eigrp->redist_list, $1, entry);
		}
		| defaults
		;

interface	: INTERFACE STRING	{
			struct kif	*kif;

			if ((kif = kif_findname($2)) == NULL) {
				yyerror("unknown interface %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
			ei = conf_get_if(kif);
			if (ei == NULL)
				YYERROR;

			ifacedefs = *defs;
			defs = &ifacedefs;
		} interface_block {
			ei->hello_holdtime = defs->hello_holdtime;
			ei->hello_interval = defs->hello_interval;
			ei->delay = defs->delay;
			ei->bandwidth = defs->bandwidth;
			ei->splithorizon = defs->splithorizon;
			ei = NULL;
			defs = &asdefs;
		}
		;

interface_block	: '{' optnl interfaceopts_l '}'
		| '{' optnl '}'
		|
		;

interfaceopts_l	: interfaceopts_l interfaceoptsl nl
		| interfaceoptsl optnl
		;

interfaceoptsl	: PASSIVE		{ ei->passive = 1; }
		| SUMMARY_ADDR STRING {
			struct summary_addr	*s;

			if ((s = calloc(1, sizeof(*s))) == NULL)
				fatal(NULL);
			if (host($2, &s->prefix, &s->prefixlen) < 0) {
				yyerror("invalid summary-address");
				free($2);
				free(s);
				YYERROR;
			}

			free($2);
			TAILQ_INSERT_TAIL(&ei->summary_list, s, entry);
		}
		| iface_defaults
		;

d1166 1
a1166 1
host(const char *s, union eigrpd_addr *addr, uint8_t *plen)
d1190 1
a1190 1
			fatal("host: malloc");
d1194 1
a1194 1
			fatal("host: strdup");
@


1.7
log
@Introduce the bad_addr() family of functions.

These functions improve code reusability as there's no more need to
check for all possible "bad" addresses in several different places.

Besides that, this patch introduce additional checks in the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2016/02/21 18:40:56 renato Exp $ */
d438 1
a438 1
			memcpy(&afdefs, defs, sizeof(afdefs));
d468 1
a468 1
			memcpy(&asdefs, defs, sizeof(asdefs));
d512 1
a512 1
			memcpy(&ifacedefs, defs, sizeof(ifacedefs));
@


1.6
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2016/01/15 12:23:45 renato Exp $ */
d209 4
@


1.5
log
@Order the routing instances by AF and then by AS.

This commit only improves the readability of the 'eigrpctl' show commands.

Additionaly, we can simplify the nbr_compare() and rt_compare() functions
because we know that under no circumstances nbrs or routes from different
AFs or ASes will be in the same tree. Each instance has its own trees of
neighbors and routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2015/10/21 03:52:12 renato Exp $ */
d136 1
a136 1
%type	<v.number>	yesno no
a137 1
%type	<v.number>	eigrp_af
d893 1
a893 1
		log_warn("malloc");
d897 1
a897 1
		log_warn("malloc");
a946 1
	memset(&globaldefs, 0, sizeof(globaldefs));
@


1.4
log
@Add support for route summarization.

Working great but need more testing, especially with ipv6. For now
we don't validate if one configured summary is inside another or the
presence of duplicates. Will address these issues in a future commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2015/10/19 14:15:59 jsg Exp $ */
a463 1
			TAILQ_INSERT_TAIL(&conf->instances, eigrp, entry);
d1076 1
a1076 1
	struct eigrp	*e;
d1094 10
@


1.3
log
@fix memory leaks in error paths
ok renato@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2015/10/04 22:54:38 renato Exp $ */
d128 1
d238 7
d533 15
d593 1
d611 1
d947 1
@


1.2
log
@Add option to configure or disable the DUAL active timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2015/10/02 04:26:47 renato Exp $ */
d1164 2
a1165 1
		if (inet_pton(AF_INET, ps, &addr->v4) != 1)
d1167 1
d1170 2
a1171 1
		if (inet_pton(AF_INET6, ps, &addr->v6) != 1)
d1173 1
d1176 1
@


1.1
log
@Welcome eigrpd

The eigrpd daemon will support the Enhanced Interior Gateway Routing Protocol.

Built using the imsg/three process framework and heavily based on ospfd(8), ospf6d(8) and ldpd(8).

The current status of eigrpd(8) is as follows:
* Almost full compliance with the specification: DUAL FSM, RTP, CR mode, SIA, etc
* Support for both IPv4 and IPv6
* Support for multiple instances (different ASes/AFs) within the same process
* Support for rdomains (one process per rdomain)
* RIB/FIB synchronization
* Basic redistribution support

Not implemented features (yet):
* Configuration reload support (partially implemented)
* Route summarization
* Advanced route redistribution/filtering
* Carp integration
* Authentication (draft is missing information)
* Stub (not released by Cisco)

Not yet connected to the builds.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d93 1
d128 1
a128 1
%token	AF IPV4 IPV6 HELLOINTERVAL HOLDTIME KVALUES
d336 9
d463 1
d562 1
d926 1
@

