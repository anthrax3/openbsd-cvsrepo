head	1.21;
access;
symbols
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8;
locks; strict;
comment	@ * @;


1.21
date	2016.09.02.17.59.58;	author benno;	state Exp;
branches;
next	1.20;
commitid	q45EjvXYS6j1V7Qb;

1.20
date	2016.09.02.16.44.33;	author renato;	state Exp;
branches;
next	1.19;
commitid	o7fEENaKxNIOcUKV;

1.19
date	2016.09.02.16.29.54;	author renato;	state Exp;
branches;
next	1.18;
commitid	w1am8mhLiSfZo4x6;

1.18
date	2016.09.02.16.23.50;	author renato;	state Exp;
branches;
next	1.17;
commitid	DH2pL4vn6jxcoOc4;

1.17
date	2016.08.08.21.38.42;	author renato;	state Exp;
branches;
next	1.16;
commitid	fgqtijswl1VlpNiP;

1.16
date	2016.06.05.17.19.18;	author renato;	state Exp;
branches;
next	1.15;
commitid	DXWkoBpb3juap4P0;

1.15
date	2016.06.05.03.36.41;	author renato;	state Exp;
branches;
next	1.14;
commitid	zEMo2iI4upK0IUZs;

1.14
date	2016.05.12.00.15.24;	author renato;	state Exp;
branches;
next	1.13;
commitid	d0Cl14ESmQZtUiKF;

1.13
date	2016.04.18.13.14.27;	author renato;	state Exp;
branches;
next	1.12;
commitid	rJZSxp1A2B7ePbpv;

1.12
date	2016.04.15.13.31.03;	author renato;	state Exp;
branches;
next	1.11;
commitid	O4hLgqBnOhtx0sRS;

1.11
date	2016.04.15.13.21.45;	author renato;	state Exp;
branches;
next	1.10;
commitid	zOVrWYmdyccBjHwb;

1.10
date	2016.04.15.13.18.38;	author renato;	state Exp;
branches;
next	1.9;
commitid	0UlzEoUmDtZvwtk7;

1.9
date	2016.04.15.13.10.56;	author renato;	state Exp;
branches;
next	1.8;
commitid	uxYgTnCpWxKsx7Ds;

1.8
date	2016.02.23.14.51.13;	author gsoares;	state Exp;
branches;
next	1.7;
commitid	nOnfYf9xOepIi5Ni;

1.7
date	2016.02.21.18.56.49;	author renato;	state Exp;
branches;
next	1.6;
commitid	Fln6asbk1x7lkTSp;

1.6
date	2016.02.21.18.40.56;	author renato;	state Exp;
branches;
next	1.5;
commitid	kZCMT2snnUUUOEjb;

1.5
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches;
next	1.4;
commitid	LQHdRRMF0nq0fugE;

1.4
date	2015.12.05.15.49.01;	author claudio;	state Exp;
branches;
next	1.3;
commitid	2wnDVolm6bXCrxDq;

1.3
date	2015.10.21.03.52.12;	author renato;	state Exp;
branches;
next	1.2;
commitid	67lIWG5WR4Do3HhB;

1.2
date	2015.10.10.05.12.33;	author renato;	state Exp;
branches;
next	1.1;
commitid	XDavuEoYjKwlIReL;

1.1
date	2015.10.02.04.26.47;	author renato;	state Exp;
branches;
next	;
commitid	dGX9Xs9GfneSNaca;


desc
@@


1.21
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@
@
text
@/*	$OpenBSD: eigrpd.c,v 1.20 2016/09/02 16:44:33 renato Exp $ */

/*
 * Copyright (c) 2015 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/sysctl.h>

#include <err.h>
#include <errno.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "eigrpd.h"
#include "eigrpe.h"
#include "rde.h"
#include "log.h"

static void		 main_sig_handler(int, short, void *);
static __dead void	 usage(void);
static __dead void	 eigrpd_shutdown(void);
static pid_t		 start_child(enum eigrpd_process, char *, int, int, int,
			    char *);
static void		 main_dispatch_eigrpe(int, short, void *);
static void		 main_dispatch_rde(int, short, void *);
static int		 main_imsg_send_ipc_sockets(struct imsgbuf *,
			    struct imsgbuf *);
static int		 main_imsg_send_config(struct eigrpd_conf *);
static int		 eigrp_reload(void);
static int		 eigrp_sendboth(enum imsg_type, void *, uint16_t);
static void		 merge_instances(struct eigrpd_conf *, struct eigrp *,
			    struct eigrp *);

struct eigrpd_conf	*eigrpd_conf;

static char		*conffile;
static struct imsgev	*iev_eigrpe;
static struct imsgev	*iev_rde;
static pid_t		 eigrpe_pid;
static pid_t		 rde_pid;

/* ARGSUSED */
static void
main_sig_handler(int sig, short event, void *arg)
{
	/* signal handler rules don't apply, libevent decouples for us */
	switch (sig) {
	case SIGTERM:
	case SIGINT:
		eigrpd_shutdown();
		/* NOTREACHED */
	case SIGHUP:
		if (eigrp_reload() == -1)
			log_warnx("configuration reload failed");
		else
			log_debug("configuration reloaded");
		break;
	default:
		fatalx("unexpected signal");
		/* NOTREACHED */
	}
}

static __dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-dnv] [-D macro=value]"
	    " [-f file] [-s socket]\n",
	    __progname);
	exit(1);
}

struct eigrpd_global global;

int
main(int argc, char *argv[])
{
	struct event		 ev_sigint, ev_sigterm, ev_sighup;
	char			*saved_argv0;
	int			 ch;
	int			 debug = 0, rflag = 0, eflag = 0;
	int			 ipforwarding;
	int			 mib[4];
	size_t			 len;
	char			*sockname;
	int			 pipe_parent2eigrpe[2];
	int			 pipe_parent2rde[2];

	conffile = CONF_FILE;
	eigrpd_process = PROC_MAIN;
	log_procname = log_procnames[eigrpd_process];
	sockname = EIGRPD_SOCKET;

	log_init(1);	/* log to stderr until daemonized */
	log_verbose(1);

	saved_argv0 = argv[0];
	if (saved_argv0 == NULL)
		saved_argv0 = "eigrpd";

	while ((ch = getopt(argc, argv, "dD:f:ns:vRE")) != -1) {
		switch (ch) {
		case 'd':
			debug = 1;
			break;
		case 'D':
			if (cmdline_symset(optarg) < 0)
				log_warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'n':
			global.cmd_opts |= EIGRPD_OPT_NOACTION;
			break;
		case 's':
			sockname = optarg;
			break;
		case 'v':
			if (global.cmd_opts & EIGRPD_OPT_VERBOSE)
				global.cmd_opts |= EIGRPD_OPT_VERBOSE2;
			global.cmd_opts |= EIGRPD_OPT_VERBOSE;
			break;
		case 'R':
			rflag = 1;
			break;
		case 'E':
			eflag = 1;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	argc -= optind;
	argv += optind;
	if (argc > 0 || (rflag && eflag))
		usage();

	if (rflag)
		rde(debug, global.cmd_opts & EIGRPD_OPT_VERBOSE);
	else if (eflag)
		eigrpe(debug, global.cmd_opts & EIGRPD_OPT_VERBOSE, sockname);

	mib[0] = CTL_NET;
	mib[1] = PF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_FORWARDING;
	len = sizeof(ipforwarding);
	if (sysctl(mib, 4, &ipforwarding, &len, NULL, 0) == -1)
		log_warn("sysctl");

	if (ipforwarding != 1)
		log_warnx("WARNING: IP forwarding NOT enabled");

	/* fetch interfaces early */
	kif_init();

	/* parse config file */
	if ((eigrpd_conf = parse_config(conffile)) == NULL) {
		kif_clear();
		exit(1);
	}

	if (global.cmd_opts & EIGRPD_OPT_NOACTION) {
		if (global.cmd_opts & EIGRPD_OPT_VERBOSE)
			print_config(eigrpd_conf);
		else
			fprintf(stderr, "configuration OK\n");
		kif_clear();
		exit(0);
	}

	/* check for root privileges  */
	if (geteuid())
		errx(1, "need root privileges");

	/* check for eigrpd user */
	if (getpwnam(EIGRPD_USER) == NULL)
		errx(1, "unknown user %s", EIGRPD_USER);

	log_init(debug);
	log_verbose(global.cmd_opts & EIGRPD_OPT_VERBOSE);

	if (!debug)
		daemon(1, 0);

	log_info("startup");

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_parent2eigrpe) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_parent2rde) == -1)
		fatal("socketpair");

	/* start children */
	rde_pid = start_child(PROC_RDE_ENGINE, saved_argv0, pipe_parent2rde[1],
	    debug, global.cmd_opts & EIGRPD_OPT_VERBOSE, NULL);
	eigrpe_pid = start_child(PROC_EIGRP_ENGINE, saved_argv0,
	    pipe_parent2eigrpe[1], debug, global.cmd_opts & EIGRPD_OPT_VERBOSE,
	    sockname);

	event_init();

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, main_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, main_sig_handler, NULL);
	signal_set(&ev_sighup, SIGHUP, main_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sighup, NULL);
	signal(SIGPIPE, SIG_IGN);

	/* setup pipes to children */
	if ((iev_eigrpe = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_rde = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_eigrpe->ibuf, pipe_parent2eigrpe[0]);
	iev_eigrpe->handler = main_dispatch_eigrpe;
	imsg_init(&iev_rde->ibuf, pipe_parent2rde[0]);
	iev_rde->handler = main_dispatch_rde;

	/* setup event handler */
	iev_eigrpe->events = EV_READ;
	event_set(&iev_eigrpe->ev, iev_eigrpe->ibuf.fd, iev_eigrpe->events,
	    iev_eigrpe->handler, iev_eigrpe);
	event_add(&iev_eigrpe->ev, NULL);

	iev_rde->events = EV_READ;
	event_set(&iev_rde->ev, iev_rde->ibuf.fd, iev_rde->events,
	    iev_rde->handler, iev_rde);
	event_add(&iev_rde->ev, NULL);

	if (main_imsg_send_ipc_sockets(&iev_eigrpe->ibuf, &iev_rde->ibuf))
		fatal("could not establish imsg links");
	main_imsg_send_config(eigrpd_conf);

	/* notify eigrpe about existing interfaces and addresses */
	kif_redistribute();

	if (kr_init(!(eigrpd_conf->flags & EIGRPD_FLAG_NO_FIB_UPDATE),
	    eigrpd_conf->rdomain) == -1)
		fatalx("kr_init failed");

	if (pledge("inet rpath stdio sendfd", NULL) == -1)
		fatal("pledge");

	event_dispatch();

	eigrpd_shutdown();
	/* NOTREACHED */
	return (0);
}

static __dead void
eigrpd_shutdown(void)
{
	pid_t		 pid;
	int		 status;

	/* close pipes */
	msgbuf_clear(&iev_eigrpe->ibuf.w);
	close(iev_eigrpe->ibuf.fd);
	msgbuf_clear(&iev_rde->ibuf.w);
	close(iev_rde->ibuf.fd);

	kr_shutdown();
	config_clear(eigrpd_conf);

	log_debug("waiting for children to terminate");
	do {
		pid = wait(&status);
		if (pid == -1) {
			if (errno != EINTR && errno != ECHILD)
				fatal("wait");
		} else if (WIFSIGNALED(status))
			log_warnx("%s terminated; signal %d",
			    (pid == rde_pid) ? "route decision engine" :
			    "eigrp engine", WTERMSIG(status));
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	free(iev_eigrpe);
	free(iev_rde);

	log_info("terminating");
	exit(0);
}

static pid_t
start_child(enum eigrpd_process p, char *argv0, int fd, int debug, int verbose,
    char *sockname)
{
	char	*argv[7];
	int	 argc = 0;
	pid_t	 pid;

	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
	case 0:
		break;
	default:
		close(fd);
		return (pid);
	}

	if (dup2(fd, 3) == -1)
		fatal("cannot setup imsg fd");

	argv[argc++] = argv0;
	switch (p) {
	case PROC_MAIN:
		fatalx("Can not start main process");
	case PROC_RDE_ENGINE:
		argv[argc++] = "-R";
		break;
	case PROC_EIGRP_ENGINE:
		argv[argc++] = "-E";
		break;
	}
	if (debug)
		argv[argc++] = "-d";
	if (verbose)
		argv[argc++] = "-v";
	if (sockname) {
		argv[argc++] = "-s";
		argv[argc++] = sockname;
	}
	argv[argc++] = NULL;

	execvp(argv0, argv);
	fatal("execvp");
}

/* imsg handling */
/* ARGSUSED */
static void
main_dispatch_eigrpe(int fd, short event, void *bula)
{
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
	int			 shut = 0, verbose;

	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("imsg_get");

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CTL_RELOAD:
			if (eigrp_reload() == -1)
				log_warnx("configuration reload failed");
			else
				log_debug("configuration reloaded");
			break;
		case IMSG_CTL_FIB_COUPLE:
			kr_fib_couple();
			break;
		case IMSG_CTL_FIB_DECOUPLE:
			kr_fib_decouple();
			break;
		case IMSG_CTL_KROUTE:
			kr_show_route(&imsg);
			break;
		case IMSG_CTL_IFINFO:
			if (imsg.hdr.len == IMSG_HEADER_SIZE)
				kr_ifinfo(NULL, imsg.hdr.pid);
			else if (imsg.hdr.len == IMSG_HEADER_SIZE + IFNAMSIZ)
				kr_ifinfo(imsg.data, imsg.hdr.pid);
			else
				log_warnx("IFINFO request with wrong len");
			break;
		case IMSG_CTL_LOG_VERBOSE:
			/* already checked by eigrpe */
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		default:
			log_debug("%s: error handling imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
static void
main_dispatch_rde(int fd, short event, void *bula)
{
	struct imsgev	*iev = bula;
	struct imsgbuf  *ibuf;
	struct imsg	 imsg;
	ssize_t		 n;
	int		 shut = 0;

	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("imsg_get");

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_KROUTE_CHANGE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct kroute))
				fatalx("invalid size of IMSG_KROUTE_CHANGE");
			if (kr_change(imsg.data))
				log_warnx("%s: error changing route", __func__);
			break;
		case IMSG_KROUTE_DELETE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct kroute))
				fatalx("invalid size of IMSG_KROUTE_DELETE");
			if (kr_delete(imsg.data))
				log_warnx("%s: error deleting route", __func__);
			break;

		default:
			log_debug("%s: error handling imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

int
main_imsg_compose_eigrpe(int type, pid_t pid, void *data, uint16_t datalen)
{
	if (iev_eigrpe == NULL)
		return (-1);
	return (imsg_compose_event(iev_eigrpe, type, 0, pid, -1, data, datalen));
}

int
main_imsg_compose_rde(int type, pid_t pid, void *data, uint16_t datalen)
{
	if (iev_rde == NULL)
		return (-1);
	return (imsg_compose_event(iev_rde, type, 0, pid, -1, data, datalen));
}

void
imsg_event_add(struct imsgev *iev)
{
	iev->events = EV_READ;
	if (iev->ibuf.w.queued)
		iev->events |= EV_WRITE;

	event_del(&iev->ev);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev);
	event_add(&iev->ev, NULL);
}

int
imsg_compose_event(struct imsgev *iev, uint16_t type, uint32_t peerid,
    pid_t pid, int fd, void *data, uint16_t datalen)
{
	int	ret;

	if ((ret = imsg_compose(&iev->ibuf, type, peerid,
	    pid, fd, data, datalen)) != -1)
		imsg_event_add(iev);
	return (ret);
}

static int
main_imsg_send_ipc_sockets(struct imsgbuf *eigrpe_buf, struct imsgbuf *rde_buf)
{
	int pipe_eigrpe2rde[2];

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_eigrpe2rde) == -1)
		return (-1);

	if (imsg_compose(eigrpe_buf, IMSG_SOCKET_IPC, 0, 0, pipe_eigrpe2rde[0],
	    NULL, 0) == -1)
		return (-1);
	if (imsg_compose(rde_buf, IMSG_SOCKET_IPC, 0, 0, pipe_eigrpe2rde[1],
	    NULL, 0) == -1)
		return (-1);

	return (0);
}

struct eigrp *
eigrp_find(struct eigrpd_conf *xconf, int af, uint16_t as)
{
	struct eigrp	*eigrp;

	TAILQ_FOREACH(eigrp, &xconf->instances, entry)
		if (eigrp->af == af && eigrp->as == as)
			return (eigrp);

	return (NULL);
}

static int
main_imsg_send_config(struct eigrpd_conf *xconf)
{
	struct eigrp		*eigrp;
	struct eigrp_iface	*ei;

	if (eigrp_sendboth(IMSG_RECONF_CONF, xconf, sizeof(*xconf)) == -1)
		return (-1);

	TAILQ_FOREACH(eigrp, &xconf->instances, entry) {
		if (eigrp_sendboth(IMSG_RECONF_INSTANCE, eigrp,
		    sizeof(*eigrp)) == -1)
			return (-1);

		TAILQ_FOREACH(ei, &eigrp->ei_list, e_entry) {
			if (eigrp_sendboth(IMSG_RECONF_IFACE, ei->iface,
			    sizeof(struct iface)) == -1)
				return (-1);

			if (eigrp_sendboth(IMSG_RECONF_EIGRP_IFACE, ei,
			    sizeof(*ei)) == -1)
				return (-1);
		}
	}

	if (eigrp_sendboth(IMSG_RECONF_END, NULL, 0) == -1)
		return (-1);

	return (0);
}

static int
eigrp_reload(void)
{
	struct eigrpd_conf	*xconf;

	if ((xconf = parse_config(conffile)) == NULL)
		return (-1);

	if (main_imsg_send_config(xconf) == -1)
		return (-1);

	merge_config(eigrpd_conf, xconf);

	return (0);
}

static int
eigrp_sendboth(enum imsg_type type, void *buf, uint16_t len)
{
	if (main_imsg_compose_eigrpe(type, 0, buf, len) == -1)
		return (-1);
	if (main_imsg_compose_rde(type, 0, buf, len) == -1)
		return (-1);
	return (0);
}

void
merge_config(struct eigrpd_conf *conf, struct eigrpd_conf *xconf)
{
	struct iface		*iface, *itmp, *xi;
	struct eigrp		*eigrp, *etmp, *xe;

	conf->rtr_id = xconf->rtr_id;
	conf->flags = xconf->flags;
	conf->rdomain= xconf->rdomain;
	conf->fib_priority_internal = xconf->fib_priority_internal;
	conf->fib_priority_external = xconf->fib_priority_external;
	conf->fib_priority_summary = xconf->fib_priority_summary;

	/* merge interfaces */
	TAILQ_FOREACH_SAFE(iface, &conf->iface_list, entry, itmp) {
		/* find deleted ifaces */
		if ((xi = if_lookup(xconf, iface->ifindex)) == NULL) {
			TAILQ_REMOVE(&conf->iface_list, iface, entry);
			free(iface);
		}
	}
	TAILQ_FOREACH_SAFE(xi, &xconf->iface_list, entry, itmp) {
		/* find new ifaces */
		if ((iface = if_lookup(conf, xi->ifindex)) == NULL) {
			TAILQ_REMOVE(&xconf->iface_list, xi, entry);
			TAILQ_INSERT_TAIL(&conf->iface_list, xi, entry);
			continue;
		}

		/* TODO update existing ifaces */
	}

	/* merge instances */
	TAILQ_FOREACH_SAFE(eigrp, &conf->instances, entry, etmp) {
		/* find deleted instances */
		if ((xe = eigrp_find(xconf, eigrp->af, eigrp->as)) == NULL) {
			TAILQ_REMOVE(&conf->instances, eigrp, entry);

			switch (eigrpd_process) {
			case PROC_RDE_ENGINE:
				rde_instance_del(eigrp);
				break;
			case PROC_EIGRP_ENGINE:
				eigrpe_instance_del(eigrp);
				break;
			case PROC_MAIN:
				free(eigrp);
				break;
			}
		}
	}
	TAILQ_FOREACH_SAFE(xe, &xconf->instances, entry, etmp) {
		/* find new instances */
		if ((eigrp = eigrp_find(conf, xe->af, xe->as)) == NULL) {
			TAILQ_REMOVE(&xconf->instances, xe, entry);
			TAILQ_INSERT_TAIL(&conf->instances, xe, entry);

			switch (eigrpd_process) {
			case PROC_RDE_ENGINE:
				rde_instance_init(xe);
				break;
			case PROC_EIGRP_ENGINE:
				eigrpe_instance_init(xe);
				break;
			case PROC_MAIN:
				break;
			}
			continue;
		}

		/* update existing instances */
		merge_instances(conf, eigrp, xe);
	}

	/* resend addresses to activate new interfaces */
	if (eigrpd_process == PROC_MAIN)
		kif_redistribute();

	free(xconf);
}

static void
merge_instances(struct eigrpd_conf *xconf, struct eigrp *eigrp, struct eigrp *xe)
{
	/* TODO */
}

struct eigrpd_conf *
config_new_empty(void)
{
	struct eigrpd_conf	*xconf;

	xconf = calloc(1, sizeof(*xconf));
	if (xconf == NULL)
		fatal(NULL);

	TAILQ_INIT(&xconf->instances);
	TAILQ_INIT(&xconf->iface_list);

	return (xconf);
}

void
config_clear(struct eigrpd_conf *conf)
{
	struct eigrpd_conf	*xconf;

	/* merge current config with an empty config */
	xconf = config_new_empty();
	merge_config(conf, xconf);

	free(conf);
}
@


1.20
log
@Make functions and variables static whenever possible.

style(9) says:
"Function prototypes for private functions (i.e., functions not used
elsewhere) go at the top of the first source module. In userland,
functions local to one source module should be declared 'static'".

The benefits of doing so include:
* clean up of the eigrpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Additional changes:
* Declare all extern variables in header files;
* Clean up the indentation of all function prototypes and global
  variables.

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.19 2016/09/02 16:29:54 renato Exp $ */
d114 1
@


1.19
log
@Remove superfluous includes and follow style(9).

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.18 2016/09/02 16:23:50 renato Exp $ */
d40 22
a61 21
void		main_sig_handler(int, short, void *);
__dead void	usage(void);
__dead void	eigrpd_shutdown(void);
pid_t		start_child(enum eigrpd_process, char *, int, int, int, char *);

void	main_dispatch_eigrpe(int, short, void *);
void	main_dispatch_rde(int, short, void *);
int	main_imsg_send_ipc_sockets(struct imsgbuf *, struct imsgbuf *);

int	main_imsg_send_config(struct eigrpd_conf *);
int	eigrp_reload(void);
int	eigrp_sendboth(enum imsg_type, void *, uint16_t);
void	merge_instances(struct eigrpd_conf *, struct eigrp *, struct eigrp *);

struct eigrpd_conf	*eigrpd_conf = NULL;
struct imsgev		*iev_eigrpe;
struct imsgev		*iev_rde;
char			*conffile;

pid_t			 eigrpe_pid = 0;
pid_t			 rde_pid = 0;
d64 1
a64 1
void
d85 1
a85 1
__dead void
d280 1
a280 1
__dead void
d314 1
a314 1
pid_t
d362 1
a362 1
void
d439 1
a439 1
void
d542 1
a542 1
int
a560 6
uint32_t
eigrp_router_id(struct eigrpd_conf *xconf)
{
	return (xconf->rtr_id.s_addr);
}

d573 1
a573 1
int
d604 1
a604 1
int
d620 1
a620 1
int
d711 1
a711 1
void
@


1.18
log
@Fix broken pipe teardown.

* Add missing close() calls to actually close the pipes, calling just
  msgbuf_clean() is not enough;
* Bring back some NOTREACHED lint comments. style(9) says they can be
  removed but in some cases they are useful to humans too;
* Add __dead to the shutdown functions;
* Some other minor changes to make eigrpd(8) more similar to the other
  routing daemons.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.17 2016/08/08 21:38:42 renato Exp $ */
d22 1
a22 2
#include <stdio.h>
#include <stdlib.h>
d25 1
a25 1
#include <arpa/inet.h>
d29 3
a32 1
#include <signal.h>
a35 1
#include "eigrp.h"
d37 1
a37 1
#include "control.h"
a38 1
#include "rde.h"
@


1.17
log
@Simplify shutdown process

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

This "pipe teardown" removes a PID reuse race condition, makes the code
simpler and allow us to remove "proc" from pledge.

OK and tweaks from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.16 2016/06/05 17:19:18 renato Exp $ */
d72 1
d276 2
d286 1
d288 1
a288 2
	free(iev_eigrpe);
	iev_eigrpe = NULL;
d290 1
a290 2
	free(iev_rde);
	iev_rde = NULL;
d292 1
a293 1
	kr_shutdown();
d295 1
d306 3
@


1.16
log
@Fix potential SIGBUS in startup.

The fork+exec diff introduced this problem where we were indirectly
calling imsg_event_add() before initializing (event_set) iev_rde and
iev_eigrpe. Fix this by moving down both main_imsg_send_ipc_sockets()
and main_imsg_send_config(), after iev_rde and iev_eigrpe are
initialized.

benno@@ reported this problem for the initial ospfd fork+exec attempt,
now fix eigrpd too.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.15 2016/06/05 03:36:41 renato Exp $ */
d43 1
a43 1
void		eigrpd_shutdown(void);
a44 1
int		check_child(pid_t, const char *);
d67 1
a67 6
	/*
	 * signal handler rules don't apply, libevent decouples for us
	 */

	int	die = 0;

d71 1
a71 14
		die = 1;
		/* FALLTHROUGH */
	case SIGCHLD:
		if (check_child(eigrpe_pid, "eigrp engine")) {
			eigrpe_pid = 0;
			die = 1;
		}
		if (check_child(rde_pid, "route decision engine")) {
			rde_pid = 0;
			die = 1;
		}
		if (die)
			eigrpd_shutdown();
		break;
d100 1
a100 1
	struct event		 ev_sigint, ev_sigterm, ev_sigchld, ev_sighup;
a231 1
	signal_set(&ev_sigchld, SIGCHLD, main_sig_handler, NULL);
a234 1
	signal_add(&ev_sigchld, NULL);
d269 1
a269 1
	if (pledge("inet rpath stdio proc sendfd", NULL) == -1)
a274 2
	/* NOTREACHED */
	return (0);
d277 1
a277 1
void
d280 2
a281 1
	pid_t		 	 pid;
d283 6
a288 5
	if (eigrpe_pid)
		kill(eigrpe_pid, SIGTERM);

	if (rde_pid)
		kill(rde_pid, SIGTERM);
d290 1
d294 8
a301 3
		if ((pid = wait(NULL)) == -1 &&
		    errno != EINTR && errno != ECHILD)
			fatal("wait");
a303 7
	config_clear(eigrpd_conf);

	msgbuf_clear(&iev_eigrpe->ibuf.w);
	free(iev_eigrpe);
	msgbuf_clear(&iev_rde->ibuf.w);
	free(iev_rde);

a353 20
int
check_child(pid_t pid, const char *pname)
{
	int	status;

	if (waitpid(pid, &status, WNOHANG) > 0) {
		if (WIFEXITED(status)) {
			log_warnx("lost child: %s exited", pname);
			return (1);
		}
		if (WIFSIGNALED(status)) {
			log_warnx("lost child: %s terminated; signal %d",
			    pname, WTERMSIG(status));
			return (1);
		}
	}

	return (0);
}

d496 1
a496 1
void
d500 2
a501 2
		return;
	imsg_compose_event(iev_eigrpe, type, 0, pid, -1, data, datalen);
d504 1
a504 1
void
d507 3
a509 1
	imsg_compose_event(iev_rde, type, 0, pid, -1, data, datalen);
d623 1
a623 1
	if (imsg_compose_event(iev_eigrpe, type, 0, 0, -1, buf, len) == -1)
d625 1
a625 1
	if (imsg_compose_event(iev_rde, type, 0, 0, -1, buf, len) == -1)
@


1.15
log
@Improve security by calling exec after fork.

For each child process (rde and eigrpe), re-exec eigrpd with a special
"per-role" getopt flag. This way we have seperate ASLR/cookies per
process.

Based on a similar patch for bgpd, from claudio@@

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.14 2016/05/12 00:15:24 renato Exp $ */
a267 4
	if (main_imsg_send_ipc_sockets(&iev_eigrpe->ibuf, &iev_rde->ibuf))
		fatal("could not establish imsg links");
	main_imsg_send_config(eigrpd_conf);

d278 4
@


1.14
log
@Improve support for config reloading.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.13 2016/04/18 13:14:27 renato Exp $ */
d44 1
d49 1
d51 1
a55 4
int	pipe_parent2eigrpe[2];
int	pipe_parent2rde[2];
int	pipe_eigrpe2rde[2];

d120 1
d122 1
a122 1
	int			 debug = 0;
d127 2
d137 5
a141 1
	while ((ch = getopt(argc, argv, "dD:f:ns:v")) != -1) {
d165 6
d179 1
a179 1
	if (argc > 0)
d182 5
a205 1
	global.csock = sockname;
a237 3
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_eigrpe2rde) == -1)
		fatal("socketpair");
d240 5
a244 4
	rde_pid = rde(eigrpd_conf, pipe_parent2rde, pipe_eigrpe2rde,
	    pipe_parent2eigrpe);
	eigrpe_pid = eigrpe(eigrpd_conf, pipe_parent2eigrpe, pipe_eigrpe2rde,
	    pipe_parent2rde);
a259 5
	close(pipe_parent2eigrpe[1]);
	close(pipe_parent2rde[1]);
	close(pipe_eigrpe2rde[0]);
	close(pipe_eigrpe2rde[1]);

d268 4
d290 1
a290 1
	if (pledge("inet rpath stdio proc", NULL) == -1)
d330 46
d576 19
d614 1
a614 1
eigrp_reload(void)
a617 4
	struct eigrpd_conf	*xconf;

	if ((xconf = parse_config(conffile)) == NULL)
		return (-1);
d641 14
d757 2
a758 2
void
config_clear(struct eigrpd_conf *conf)
d762 1
a762 2
	/* merge current config with an empty config */
	xconf = malloc(sizeof(*xconf));
a765 1
	*xconf = *conf;
d767 12
@


1.13
log
@Revert previous commit.

When a process receives an EOF on a socketpair, it removes the event
handler for that fd and then calls event_loopexit(). Once the process
leaves the main loop, it calls its shutdown function. With that said,
revert the previous patch because it was unnecessary.

Pointed out and ok by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.12 2016/04/15 13:31:03 renato Exp $ */
d585 1
d588 1
a588 1
	/* change of rtr_id needs a restart */
d595 19
d655 1
@


1.12
log
@Kill the child processes if their parent dies unexpectedly.

There's no point on keeping eigrpd running if any of its processes
dies unexpectedly.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.11 2016/04/15 13:21:45 renato Exp $ */
d409 3
a411 2
		eigrpe_pid = 0;
		eigrpd_shutdown();
d473 3
a475 2
		rde_pid = 0;
		eigrpd_shutdown();
@


1.11
log
@Move several other variables out of eigrpd_conf.

Now eigrpd_conf contains only variables that can be modified via a
config reload. The other variables were moved to a new struct called
eigrpd_global, which is now a central point for storing global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.10 2016/04/15 13:18:38 renato Exp $ */
d409 2
a410 3
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
d472 2
a473 3
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
@


1.10
log
@Move the command line options out of struct eigrpd_config
into an own flag field since these can't be modified via a
config reload.

Pulled from bgpd. Original author: claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.9 2016/04/15 13:10:56 renato Exp $ */
d115 1
a115 1
int	cmd_opts;
d149 1
a149 1
			cmd_opts |= EIGRPD_OPT_NOACTION;
d155 3
a157 3
			if (cmd_opts & EIGRPD_OPT_VERBOSE)
				cmd_opts |= EIGRPD_OPT_VERBOSE2;
			cmd_opts |= EIGRPD_OPT_VERBOSE;
d189 1
a189 1
	eigrpd_conf->csock = sockname;
d191 2
a192 2
	if (cmd_opts & EIGRPD_OPT_NOACTION) {
		if (cmd_opts & EIGRPD_OPT_VERBOSE)
d209 1
a209 1
	log_verbose(cmd_opts & EIGRPD_OPT_VERBOSE);
@


1.9
log
@Minor fixes and code cleanup.

* whitespace cleanup;
* copy in_addr structs directly;
* add more malloc return value checks;
* fix some log messages;
* turn ifacecnt into a static variable;
* use eigrp_addrcmp() on if_deladdr() to avoid code duplication;
* s/route_print_origin/log_route_origin/
* more smaller issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.8 2016/02/23 14:51:13 gsoares Exp $ */
d115 2
d121 1
a121 1
	int			 ch, opts = 0;
d149 1
a149 1
			opts |= EIGRPD_OPT_NOACTION;
d155 3
a157 3
			if (opts & EIGRPD_OPT_VERBOSE)
				opts |= EIGRPD_OPT_VERBOSE2;
			opts |= EIGRPD_OPT_VERBOSE;
d185 1
a185 1
	if ((eigrpd_conf = parse_config(conffile, opts)) == NULL) {
d191 2
a192 2
	if (eigrpd_conf->opts & EIGRPD_OPT_NOACTION) {
		if (eigrpd_conf->opts & EIGRPD_OPT_VERBOSE)
d209 1
a209 1
	log_verbose(eigrpd_conf->opts & EIGRPD_OPT_VERBOSE);
d542 1
a542 1
	if ((xconf = parse_config(conffile, eigrpd_conf->opts)) == NULL)
@


1.8
log
@I just stumbled on this and noticed that eigrpd requires inet and rpath in pledge(2) call to make "reload",
without that, daemon will crash on SIGHUP signal....

as discurssed/OK renato@@
commit it now, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.7 2016/02/21 18:56:49 renato Exp $ */
d653 3
@


1.7
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.6 2016/02/21 18:40:56 renato Exp $ */
d275 1
a275 1
	if (pledge("stdio proc", NULL) == -1)
@


1.6
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.5 2016/02/02 17:51:11 sthen Exp $ */
d653 1
a653 1
	memcpy(xconf, conf, sizeof(*xconf));
@


1.5
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.4 2015/12/05 15:49:01 claudio Exp $ */
d174 1
a174 1
		err(1, "sysctl");
@


1.4
log
@Forgot about eigrp when doing the imsg_read EAGAIN fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.3 2015/10/21 03:52:12 renato Exp $ */
a228 3

	/* show who we are */
	setproctitle("parent");
@


1.3
log
@Add support for route summarization.

Working great but need more testing, especially with ipv6. For now
we don't validate if one configured summary is inside another or the
presence of duplicates. Will address these issues in a future commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.2 2015/10/10 05:12:33 renato Exp $ */
d352 1
a352 1
		if ((n = imsg_read(ibuf)) == -1)
d429 1
a429 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.2
log
@Make use of pledge(2).

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpd.c,v 1.1 2015/10/02 04:26:47 renato Exp $ */
d593 1
@


1.1
log
@Welcome eigrpd

The eigrpd daemon will support the Enhanced Interior Gateway Routing Protocol.

Built using the imsg/three process framework and heavily based on ospfd(8), ospf6d(8) and ldpd(8).

The current status of eigrpd(8) is as follows:
* Almost full compliance with the specification: DUAL FSM, RTP, CR mode, SIA, etc
* Support for both IPv4 and IPv6
* Support for multiple instances (different ASes/AFs) within the same process
* Support for rdomains (one process per rdomain)
* RIB/FIB synchronization
* Basic redistribution support

Not implemented features (yet):
* Configuration reload support (partially implemented)
* Route summarization
* Advanced route redistribution/filtering
* Carp integration
* Authentication (draft is missing information)
* Stub (not released by Cisco)

Not yet connected to the builds.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d277 3
@

