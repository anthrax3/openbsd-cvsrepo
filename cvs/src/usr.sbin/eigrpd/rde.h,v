head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6;
locks; strict;
comment	@ * @;


1.12
date	2016.09.02.16.46.29;	author renato;	state Exp;
branches;
next	1.11;
commitid	K6uLqMvlsHB7ikcI;

1.11
date	2016.09.02.16.44.33;	author renato;	state Exp;
branches;
next	1.10;
commitid	o7fEENaKxNIOcUKV;

1.10
date	2016.09.02.16.29.55;	author renato;	state Exp;
branches;
next	1.9;
commitid	w1am8mhLiSfZo4x6;

1.9
date	2016.06.05.03.36.41;	author renato;	state Exp;
branches;
next	1.8;
commitid	zEMo2iI4upK0IUZs;

1.8
date	2016.04.15.13.34.08;	author renato;	state Exp;
branches;
next	1.7;
commitid	uztiTpyTVAWMXZo3;

1.7
date	2016.04.15.13.10.56;	author renato;	state Exp;
branches;
next	1.6;
commitid	uxYgTnCpWxKsx7Ds;

1.6
date	2015.12.13.19.02.49;	author renato;	state Exp;
branches;
next	1.5;
commitid	FBV9SoyF8HN4p73z;

1.5
date	2015.10.27.03.25.55;	author renato;	state Exp;
branches;
next	1.4;
commitid	F9mnWuaZvi3UQV0k;

1.4
date	2015.10.21.03.52.12;	author renato;	state Exp;
branches;
next	1.3;
commitid	67lIWG5WR4Do3HhB;

1.3
date	2015.10.21.03.48.09;	author renato;	state Exp;
branches;
next	1.2;
commitid	AfOWCk8vQ1tJuhIQ;

1.2
date	2015.10.05.01.59.33;	author renato;	state Exp;
branches;
next	1.1;
commitid	gALnAEcCWDSQBrng;

1.1
date	2015.10.02.04.26.47;	author renato;	state Exp;
branches;
next	;
commitid	dGX9Xs9GfneSNaca;


desc
@@


1.12
log
@Minor tweaks
@
text
@/*	$OpenBSD: rde.h,v 1.11 2016/09/02 16:44:33 renato Exp $ */

/*
 * Copyright (c) 2015 Renato Westphal <renato@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _RDE_H_
#define _RDE_H_

#include <sys/queue.h>
#include <sys/tree.h>

#include <event.h>

/* just the info RDE needs */
struct rde_nbr {
	RB_ENTRY(rde_nbr)	 entry;
	uint32_t		 peerid;
	uint32_t		 ifaceid;
	union eigrpd_addr	 addr;
	struct eigrp_iface	*ei;
	struct eigrp		*eigrp;
	TAILQ_HEAD(,reply_node)	 rijk;		/* outstanding replies */

	/*
	 * We have one "self" neighbor for each interface on which EIGRP is
	 * configured. This way we can inject local routes into the DUAL FSM
	 * just like any other route received from a remote neighbor. For each
	 * instance, we also have two additional special neighbors used to
	 * inject redistributed and summarized routes.
	 */
	uint8_t			 flags;
#define F_RDE_NBR_SELF		0x01
#define F_RDE_NBR_LOCAL		0x02
#define F_RDE_NBR_REDIST	0x04
#define F_RDE_NBR_SUMMARY	0x08
};
RB_PROTOTYPE(rde_nbr_head, rde_nbr, entry, rde_nbr_compare)

struct reply_node {
	TAILQ_ENTRY(reply_node)	 rn_entry;
	TAILQ_ENTRY(reply_node)	 nbr_entry;
	struct event		 ev_active_timeout;
	struct event		 ev_sia_timeout;
	int			 siaquery_sent;
	int			 siareply_recv;
	struct rt_node		*rn;
	struct rde_nbr		*nbr;
};

struct eigrp_route {
	TAILQ_ENTRY(eigrp_route) entry;
	struct rde_nbr		*nbr;		/* advertising nbr */
	enum route_type		 type;
	union eigrpd_addr	 nexthop;
	uint32_t		 distance;	/* local distance */
	uint32_t		 rdistance;	/* reported distance */
	struct classic_metric	 metric;	/* metric */
	struct classic_emetric	 emetric;	/* external metric */
	uint8_t			 flags;
};
#define F_EIGRP_ROUTE_INSTALLED	0x01
#define F_EIGRP_ROUTE_M_CHANGED	0x02

struct rt_node {
	RB_ENTRY(rt_node)	 entry;
	struct eigrp		*eigrp;
	union eigrpd_addr	 prefix;
	uint8_t			 prefixlen;
	int			 state;
	TAILQ_HEAD(,eigrp_route) routes;
	TAILQ_HEAD(,reply_node)	 rijk;		/* outstanding replies */

	struct {
		struct rde_nbr		*nbr;
		enum route_type		 type;
		uint32_t		 fdistance;
		uint32_t		 rdistance;
		struct classic_metric	 metric;
		struct classic_emetric	 emetric;
	} successor;
};
RB_PROTOTYPE(rt_tree, rt_node, entry, rt_compare)

/* DUAL states */
#define	DUAL_STA_PASSIVE	0x0001
#define	DUAL_STA_ACTIVE0	0x0002
#define	DUAL_STA_ACTIVE1	0x0004
#define	DUAL_STA_ACTIVE2	0x0008
#define	DUAL_STA_ACTIVE3	0x0010
#define	DUAL_STA_ACTIVE_ALL	(DUAL_STA_ACTIVE0 | DUAL_STA_ACTIVE1 | \
				DUAL_STA_ACTIVE2 | DUAL_STA_ACTIVE3)

enum dual_event {
	DUAL_EVT_1,
	DUAL_EVT_2,
	DUAL_EVT_3,
	DUAL_EVT_4,
	DUAL_EVT_5,
	DUAL_EVT_6,
	DUAL_EVT_7,
	DUAL_EVT_8,
	DUAL_EVT_9,
	DUAL_EVT_10,
	DUAL_EVT_11,
	DUAL_EVT_12,
	DUAL_EVT_13,
	DUAL_EVT_14,
	DUAL_EVT_15,
	DUAL_EVT_16
};

extern struct eigrpd_conf	*rdeconf;
extern struct rde_nbr_head	 rde_nbrs;

/* rde.c */
void		 rde(int, int);
int		 rde_imsg_compose_parent(int, pid_t, void *, uint16_t);
int		 rde_imsg_compose_eigrpe(int, uint32_t, pid_t, void *,
		    uint16_t);
void		 rde_instance_init(struct eigrp *);
void		 rde_instance_del(struct eigrp *);
void		 rde_send_change_kroute(struct rt_node *, struct eigrp_route *);
void		 rde_send_delete_kroute(struct rt_node *, struct eigrp_route *);
void		 rt_summary_set(struct eigrp *, struct summary_addr *,
		    struct classic_metric *);

/* rde_dual.c */
void			 rt_del(struct rt_node *);
uint32_t		 eigrp_composite_delay(uint32_t);
uint32_t		 eigrp_real_delay(uint32_t);
uint32_t		 eigrp_composite_bandwidth(uint32_t);
uint32_t		 eigrp_real_bandwidth(uint32_t);
void			 rinfo_fill_successor(struct rt_node *, struct rinfo *);
struct summary_addr	*rde_summary_check(struct eigrp_iface *,
			    union eigrpd_addr *, uint8_t);
void			 rde_flush_queries(void);
void			 rde_check_update(struct rde_nbr *, struct rinfo *);
void			 rde_check_query(struct rde_nbr *, struct rinfo *, int);
void			 rde_check_reply(struct rde_nbr *, struct rinfo *, int);
void			 rde_check_link_down_rn(struct rde_nbr *,
			    struct rt_node *, struct eigrp_route *);
void			 rde_check_link_down_nbr(struct rde_nbr *);
void			 rde_check_link_down(unsigned int);
void			 rde_check_link_cost_change(struct rde_nbr *,
			    struct eigrp_iface *);
struct rde_nbr		*rde_nbr_find(uint32_t);
struct rde_nbr		*rde_nbr_new(uint32_t, struct rde_nbr *);
void			 rde_nbr_del(struct rde_nbr *, int);

#endif	/* _RDE_H_ */
@


1.11
log
@Make functions and variables static whenever possible.

style(9) says:
"Function prototypes for private functions (i.e., functions not used
elsewhere) go at the top of the first source module. In userland,
functions local to one source module should be declared 'static'".

The benefits of doing so include:
* clean up of the eigrpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Additional changes:
* Declare all extern variables in header files;
* Clean up the indentation of all function prototypes and global
  variables.

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.10 2016/09/02 16:29:55 renato Exp $ */
d129 1
a129 1
pid_t		 rde(int, int);
@


1.10
log
@Remove superfluous includes and follow style(9).

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.9 2016/06/05 03:36:41 renato Exp $ */
d36 8
a44 8
};
/*
 * We have one "self" neighbor for each interface on which EIGRP is configured.
 * This way we can inject local routes into the DUAL FSM just like any other
 * route received from a remote neighbor. For each instance, we also have two
 * additional special neighbors used to inject redistributed and summarized
 * routes.
 */
d49 2
d95 1
d125 3
a132 1

a136 1
void		 rt_redist_set(struct kroute *, int);
a138 8
void		 rt_snap(struct rde_nbr *);
struct ctl_rt	*rt_to_ctl(struct rt_node *, struct eigrp_route *);
void		 rt_dump(struct ctl_show_topology_req *, pid_t);

/* rde_nbr.c */
struct rde_nbr		*rde_nbr_find(uint32_t);
struct rde_nbr		*rde_nbr_new(uint32_t, struct rde_nbr *);
void			 rde_nbr_del(struct rde_nbr *, int);
a140 3
int			 dual_fsm(struct rt_node *, enum dual_event);
struct rt_node		*rt_find(struct eigrp *, struct rinfo *);
struct rt_node		*rt_new(struct eigrp *, struct rinfo *);
a141 6
struct eigrp_route	*route_find(struct rde_nbr *, struct rt_node *);
struct eigrp_route	*route_new(struct rt_node *, struct rde_nbr *,
			    struct rinfo *);
void			 route_del(struct rt_node *, struct eigrp_route *);
uint32_t		 safe_sum_uint32(uint32_t, uint32_t);
uint32_t		 safe_mul_uint32(uint32_t, uint32_t);
a145 9
uint32_t		 route_composite_metric(uint8_t *, uint32_t, uint32_t,
			    uint8_t, uint8_t);
void			 route_update_metrics(struct eigrp *,
			    struct eigrp_route *, struct rinfo *);
void			 reply_outstanding_add(struct rt_node *,
			    struct rde_nbr *);
struct reply_node	*reply_outstanding_find(struct rt_node *,
			    struct rde_nbr *);
void			 reply_outstanding_remove(struct reply_node *);
a146 7
void			 rinfo_fill_infinite(struct rt_node *, enum route_type,
			    struct rinfo *);
void			 rt_update_fib(struct rt_node *);
void			 rt_set_successor(struct rt_node *,
			    struct eigrp_route *);
struct eigrp_route	*rt_get_successor_fc(struct rt_node *);

a148 7
void			 rde_send_update(struct eigrp_iface *, struct rinfo *);
void			 rde_send_update_all(struct rt_node *, struct rinfo *);
void			 rde_send_query(struct eigrp_iface *, struct rinfo *,
			    int);
void			 rde_send_siaquery(struct rde_nbr *, struct rinfo *);
void			 rde_send_query_all(struct eigrp *, struct rt_node *,
			    int);
a149 1
void			 rde_send_reply(struct rde_nbr *, struct rinfo *, int);
a151 1
void			 rde_last_reply(struct rt_node *);
d159 3
@


1.9
log
@Improve security by calling exec after fork.

For each child process (rde and eigrpe), re-exec eigrpd with a special
"per-role" getopt flag. This way we have seperate ASLR/cookies per
process.

Based on a similar patch for bgpd, from claudio@@

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.8 2016/04/15 13:34:08 renato Exp $ */
d22 1
a22 2
#include <sys/types.h>
#include <sys/time.h>
d24 1
a24 1
#include <sys/queue.h>
a25 1
#include <limits.h>
@


1.8
log
@Check for subnet overlap between the configured summary-addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.7 2016/04/15 13:10:56 renato Exp $ */
d125 1
a125 1
pid_t		 rde(struct eigrpd_conf *, int [2], int [2], int [2]);
@


1.7
log
@Minor fixes and code cleanup.

* whitespace cleanup;
* copy in_addr structs directly;
* add more malloc return value checks;
* fix some log messages;
* turn ifacecnt into a static variable;
* use eigrp_addrcmp() on if_deladdr() to avoid code duplication;
* s/route_print_origin/log_route_origin/
* more smaller issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.6 2015/12/13 19:02:49 renato Exp $ */
a27 2

#define min(x,y) ((x) <= (y) ? (x) : (y))
@


1.6
log
@Respect the k-values configuration when calculating the composite metric.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.5 2015/10/27 03:25:55 renato Exp $ */
d130 1
a130 1
    uint16_t);
d138 1
a138 1
    struct classic_metric *);
d155 1
a155 1
    struct rinfo *);
d164 1
a164 1
    uint8_t, uint8_t);
d166 1
a166 1
    struct eigrp_route *, struct rinfo *);
d168 1
a168 1
    struct rde_nbr *);
d170 1
a170 1
    struct rde_nbr *);
d174 1
a174 1
    struct rinfo *);
d177 1
a177 1
    struct eigrp_route *);
d181 1
a181 1
    union eigrpd_addr *, uint8_t);
d185 1
a185 1
    int);
d188 1
a188 1
    int);
d196 1
a196 1
    struct rt_node *, struct eigrp_route *);
d200 1
a200 1
    struct eigrp_iface *);
@


1.5
log
@Introduce a new flag to identify "self" neighbors attached to local interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.4 2015/10/21 03:52:12 renato Exp $ */
d158 1
d163 4
a166 2
void			 route_update_metrics(struct eigrp_route *,
    struct rinfo *);
@


1.4
log
@Add support for route summarization.

Working great but need more testing, especially with ipv6. For now
we don't validate if one configured summary is inside another or the
presence of duplicates. Will address these issues in a future commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.3 2015/10/21 03:48:09 renato Exp $ */
d50 3
a52 2
#define F_RDE_NBR_REDIST	0x02
#define F_RDE_NBR_SUMMARY	0x04
@


1.3
log
@Minor fixes and code cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.2 2015/10/05 01:59:33 renato Exp $ */
d136 2
d176 2
@


1.2
log
@When the SIA state is declared for a given destination, reset the
adjacency with the unresponsive neighbor(s).
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.1 2015/10/02 04:26:47 renato Exp $ */
a173 1
void			 rde_send_ack(struct rde_nbr *);
a190 1
struct eigrp_interface;
d192 1
a192 1
    struct eigrp_interface *);
@


1.1
log
@Welcome eigrpd

The eigrpd daemon will support the Enhanced Interior Gateway Routing Protocol.

Built using the imsg/three process framework and heavily based on ospfd(8), ospf6d(8) and ldpd(8).

The current status of eigrpd(8) is as follows:
* Almost full compliance with the specification: DUAL FSM, RTP, CR mode, SIA, etc
* Support for both IPv4 and IPv6
* Support for multiple instances (different ASes/AFs) within the same process
* Support for rdomains (one process per rdomain)
* RIB/FIB synchronization
* Basic redistribution support

Not implemented features (yet):
* Configuration reload support (partially implemented)
* Route summarization
* Advanced route redistribution/filtering
* Carp integration
* Authentication (draft is missing information)
* Stub (not released by Cisco)

Not yet connected to the builds.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d143 1
a143 1
void			 rde_nbr_del(struct rde_nbr *);
@

