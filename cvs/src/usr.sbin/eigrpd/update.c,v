head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.3.0.4
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3;
locks; strict;
comment	@ * @;


1.6
date	2016.09.02.16.46.29;	author renato;	state Exp;
branches;
next	1.5;
commitid	K6uLqMvlsHB7ikcI;

1.5
date	2016.09.02.16.44.33;	author renato;	state Exp;
branches;
next	1.4;
commitid	o7fEENaKxNIOcUKV;

1.4
date	2016.09.02.16.29.55;	author renato;	state Exp;
branches;
next	1.3;
commitid	w1am8mhLiSfZo4x6;

1.3
date	2016.01.15.12.32.34;	author renato;	state Exp;
branches;
next	1.2;
commitid	NKjBajp5Z0fkMb21;

1.2
date	2015.10.04.23.00.10;	author renato;	state Exp;
branches;
next	1.1;
commitid	vb2pR0BnPuOhwW09;

1.1
date	2015.10.02.04.26.47;	author renato;	state Exp;
branches;
next	;
commitid	dGX9Xs9GfneSNaca;


desc
@@


1.6
log
@Minor tweaks
@
text
@/*	$OpenBSD: update.c,v 1.5 2016/09/02 16:44:33 renato Exp $ */

/*
 * Copyright (c) 2015 Renato Westphal <renato@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip6.h>

#include <stdlib.h>

#include "eigrpd.h"
#include "eigrpe.h"
#include "log.h"

/* update packet handling */

void
send_update(struct eigrp_iface *ei, struct nbr *nbr, uint32_t flags,
    struct rinfo_head *rinfo_list)
{
	struct eigrp		*eigrp = ei->eigrp;
	struct ibuf		*buf;
	struct rinfo_entry	*re;
	int			 size;
	int			 route_len;

	do {
		if ((buf = ibuf_dynamic(PKG_DEF_SIZE,
		    IP_MAXPACKET - sizeof(struct ip))) == NULL)
			fatal("send_update");

		/* EIGRP header */
		if (gen_eigrp_hdr(buf, EIGRP_OPC_UPDATE, flags,
		    eigrp->seq_num, eigrp->as))
			goto fail;

		if (rinfo_list == NULL)
			break;

		switch (eigrp->af) {
		case AF_INET:
			size = sizeof(struct ip);
			break;
		case AF_INET6:
			size = sizeof(struct ip6_hdr);
			break;
		default:
			fatalx("send_update: unknown af");
		}
		size += sizeof(struct eigrp_hdr);

		while ((re = TAILQ_FIRST(rinfo_list)) != NULL) {
			route_len = len_route_tlv(&re->rinfo);
			/* don't exceed the MTU to avoid IP fragmentation */
			if (size + route_len > ei->iface->mtu) {
				rtp_send(ei, nbr, buf);
				break;
			}
			size += route_len;

			if (gen_route_tlv(buf, &re->rinfo))
				goto fail;
			TAILQ_REMOVE(rinfo_list, re, entry);
			free(re);
		}
	} while (!TAILQ_EMPTY(rinfo_list));

	rtp_send(ei, nbr, buf);
	return;
fail:
	log_warnx("%s: failed to send message", __func__);
	if (rinfo_list)
		message_list_clr(rinfo_list);
	ibuf_free(buf);
	return;
}

void
recv_update(struct nbr *nbr, struct rinfo_head *rinfo_list, uint32_t flags)
{
	struct rinfo_entry	*re;

	rtp_ack_start_timer(nbr);

	if (flags & EIGRP_HDR_FLAG_INIT) {
		log_debug("%s: INIT flag is set", __func__);

		if (nbr->flags & F_EIGRP_NBR_PENDING)
			nbr_init(nbr);

		/*
		 * The INIT flag instructs us to advertise all of our routes,
		 * even if the neighbor is not pending.
		 */
		eigrpe_imsg_compose_rde(IMSG_RECV_UPDATE_INIT, nbr->peerid,
		    0, NULL, 0);
		return;
	}

	TAILQ_FOREACH(re, rinfo_list, entry)
		eigrpe_imsg_compose_rde(IMSG_RECV_UPDATE, nbr->peerid,
		    0, &re->rinfo, sizeof(re->rinfo));
}
@


1.5
log
@Make functions and variables static whenever possible.

style(9) says:
"Function prototypes for private functions (i.e., functions not used
elsewhere) go at the top of the first source module. In userland,
functions local to one source module should be declared 'static'".

The benefits of doing so include:
* clean up of the eigrpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Additional changes:
* Declare all extern variables in header files;
* Clean up the indentation of all function prototypes and global
  variables.

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.4 2016/09/02 16:29:55 renato Exp $ */
a41 1
	/* don't exceed the interface's mtu */
d69 1
@


1.4
log
@Remove superfluous includes and follow style(9).

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.3 2016/01/15 12:32:34 renato Exp $ */
a28 2

extern struct eigrpd_conf	*econf;
@


1.3
log
@Do not set the EoT flag in the last startup update.

Unfortunately we don't have enough information to support the NSF feature,
the EIGRP draft is missing a lot of information in this regard.

The EoT flag is used as part of EIGRP NSF to announce the end of the
startup process with a neighbor. The problem is that, when we set this
flag, the Cisco neighbors will assume that we support NSF, which is
not true.  When this happens, these routers expect us to do things that
we don't know, and weird things can happen. So let's play safe and just
ignore this flag for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.2 2015/10/04 23:00:10 renato Exp $ */
d19 1
a19 1
#include <stdlib.h>
d21 1
d24 2
d27 1
a27 1
#include "eigrp.h"
a28 1
#include "eigrpe.h"
@


1.2
log
@Fix warnings and add safeguards to protect against corrupted data.
@
text
@d1 1
a1 1
/*	$OpenBSD: update.c,v 1.1 2015/10/02 04:26:47 renato Exp $ */
d34 1
a34 1
    int startup, struct rinfo_head *rinfo_list)
a40 1
	struct eigrp_hdr	*eigrp_hdr;
a82 8
	/* set the EOT flag in the last startup update */
	if (startup) {
		if ((eigrp_hdr = ibuf_seek(buf, 0, sizeof(*eigrp_hdr))) == NULL)
                	fatalx("send_update: buf_seek failed");
		eigrp_hdr->flags = ntohl(eigrp_hdr->flags) | EIGRP_HDR_FLAG_EOT;
		eigrp_hdr->flags = htonl(eigrp_hdr->flags);
	}

a104 18
		else if (!(flags & EIGRP_HDR_FLAG_RS))
			/*
			 * This is not in the draft, but apparently if a Cisco
			 * device sends an INIT Update it expects to receive
			 * an INIT Update as well, otherwise it triggers the
			 * "stuck in INIT state" error and discards subsequent
			 * packets.  However, there is an exception: when the
			 * "clear ip eigrp neighbors soft" command is issued
			 * on a Cisco device, the "Restart Flag" is also set
			 * in the EIGRP header. In this case the Cisco device
			 * doesn't expect to receive an INIT Update otherwise
			 * the adjacency will flap.  Unfortunately it looks
			 * like that there is some kind of initialization
			 * FSM implemented in the Cisco devices that is not
			 * documented in the draft.
			 */
			send_update(nbr->ei, nbr, EIGRP_HDR_FLAG_INIT,
			    0, NULL);
@


1.1
log
@Welcome eigrpd

The eigrpd daemon will support the Enhanced Interior Gateway Routing Protocol.

Built using the imsg/three process framework and heavily based on ospfd(8), ospf6d(8) and ldpd(8).

The current status of eigrpd(8) is as follows:
* Almost full compliance with the specification: DUAL FSM, RTP, CR mode, SIA, etc
* Support for both IPv4 and IPv6
* Support for multiple instances (different ASes/AFs) within the same process
* Support for rdomains (one process per rdomain)
* RIB/FIB synchronization
* Basic redistribution support

Not implemented features (yet):
* Configuration reload support (partially implemented)
* Route summarization
* Advanced route redistribution/filtering
* Carp integration
* Authentication (draft is missing information)
* Stub (not released by Cisco)

Not yet connected to the builds.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d65 1
a65 1
			break;
@

