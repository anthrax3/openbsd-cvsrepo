head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.6
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24;
locks; strict;
comment	@ * @;


1.28
date	2016.09.02.16.44.33;	author renato;	state Exp;
branches;
next	1.27;
commitid	o7fEENaKxNIOcUKV;

1.27
date	2016.09.02.16.29.55;	author renato;	state Exp;
branches;
next	1.26;
commitid	w1am8mhLiSfZo4x6;

1.26
date	2016.04.15.13.15.33;	author renato;	state Exp;
branches;
next	1.25;
commitid	N5A5nDtsM1JimmvI;

1.25
date	2016.04.15.13.10.56;	author renato;	state Exp;
branches;
next	1.24;
commitid	uxYgTnCpWxKsx7Ds;

1.24
date	2016.02.21.19.03.58;	author renato;	state Exp;
branches;
next	1.23;
commitid	gomk3JKryOj7wOoR;

1.23
date	2016.02.21.19.01.12;	author renato;	state Exp;
branches;
next	1.22;
commitid	6khscN8oOn8rqpDY;

1.22
date	2016.02.21.18.56.49;	author renato;	state Exp;
branches;
next	1.21;
commitid	Fln6asbk1x7lkTSp;

1.21
date	2016.02.21.18.52.00;	author renato;	state Exp;
branches;
next	1.20;
commitid	g6ugST8MGfTEZDk1;

1.20
date	2016.02.21.18.40.56;	author renato;	state Exp;
branches;
next	1.19;
commitid	kZCMT2snnUUUOEjb;

1.19
date	2016.01.28.13.25.14;	author jsg;	state Exp;
branches;
next	1.18;
commitid	fewGTuHZdP34O5ea;

1.18
date	2016.01.15.12.56.12;	author renato;	state Exp;
branches;
next	1.17;
commitid	UVNqu5CC8k1X6Tti;

1.17
date	2016.01.15.12.52.49;	author renato;	state Exp;
branches;
next	1.16;
commitid	QKBmJwvNkdZQBsi5;

1.16
date	2016.01.15.12.48.53;	author renato;	state Exp;
branches;
next	1.15;
commitid	yMay1esmA52cW6NB;

1.15
date	2016.01.15.12.41.09;	author renato;	state Exp;
branches;
next	1.14;
commitid	mZmD6DNRylxiI3gq;

1.14
date	2016.01.15.12.36.41;	author renato;	state Exp;
branches;
next	1.13;
commitid	VxpaEFsR30Xigk4x;

1.13
date	2016.01.15.12.23.45;	author renato;	state Exp;
branches;
next	1.12;
commitid	p7QeYTL0LDa4tIEh;

1.12
date	2015.12.13.19.02.49;	author renato;	state Exp;
branches;
next	1.11;
commitid	FBV9SoyF8HN4p73z;

1.11
date	2015.12.13.19.00.42;	author renato;	state Exp;
branches;
next	1.10;
commitid	bXoscWVhNoGRyUzC;

1.10
date	2015.10.27.03.25.55;	author renato;	state Exp;
branches;
next	1.9;
commitid	F9mnWuaZvi3UQV0k;

1.9
date	2015.10.25.00.42.02;	author renato;	state Exp;
branches;
next	1.8;
commitid	nW0JGHKt97AA2bJs;

1.8
date	2015.10.25.00.39.14;	author renato;	state Exp;
branches;
next	1.7;
commitid	vY3soJulAzi9UNZr;

1.7
date	2015.10.21.03.52.12;	author renato;	state Exp;
branches;
next	1.6;
commitid	67lIWG5WR4Do3HhB;

1.6
date	2015.10.21.03.48.09;	author renato;	state Exp;
branches;
next	1.5;
commitid	AfOWCk8vQ1tJuhIQ;

1.5
date	2015.10.20.11.26.40;	author jsg;	state Exp;
branches;
next	1.4;
commitid	VrHNzNUnGcLDyY2d;

1.4
date	2015.10.05.01.59.33;	author renato;	state Exp;
branches;
next	1.3;
commitid	gALnAEcCWDSQBrng;

1.3
date	2015.10.04.23.00.10;	author renato;	state Exp;
branches;
next	1.2;
commitid	vb2pR0BnPuOhwW09;

1.2
date	2015.10.04.22.54.38;	author renato;	state Exp;
branches;
next	1.1;
commitid	UF6urvMjq1VzeguX;

1.1
date	2015.10.02.04.26.47;	author renato;	state Exp;
branches;
next	;
commitid	dGX9Xs9GfneSNaca;


desc
@@


1.28
log
@Make functions and variables static whenever possible.

style(9) says:
"Function prototypes for private functions (i.e., functions not used
elsewhere) go at the top of the first source module. In userland,
functions local to one source module should be declared 'static'".

The benefits of doing so include:
* clean up of the eigrpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Additional changes:
* Declare all extern variables in header files;
* Clean up the indentation of all function prototypes and global
  variables.

ok claudio@@ benno@@
@
text
@/*	$OpenBSD: rde_dual.c,v 1.27 2016/09/02 16:29:55 renato Exp $ */

/*
 * Copyright (c) 2015 Renato Westphal <renato@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>

#include "eigrpd.h"
#include "eigrpe.h"
#include "rde.h"
#include "log.h"

static int		 dual_fsm(struct rt_node *, enum dual_event);
static __inline int	 rt_compare(struct rt_node *, struct rt_node *);
static struct rt_node	*rt_find(struct eigrp *, struct rinfo *);
static struct rt_node	*rt_new(struct eigrp *, struct rinfo *);
static struct eigrp_route *route_find(struct rde_nbr *, struct rt_node *);
static struct eigrp_route *route_new(struct rt_node *, struct rde_nbr *,
			    struct rinfo *);
static void		 route_del(struct rt_node *, struct eigrp_route *);
static uint32_t		 safe_sum_uint32(uint32_t, uint32_t);
static uint32_t		 safe_mul_uint32(uint32_t, uint32_t);
static uint32_t		 route_composite_metric(uint8_t *, uint32_t, uint32_t,
			    uint8_t, uint8_t);
static void		 route_update_metrics(struct eigrp *,
			    struct eigrp_route *, struct rinfo *);
static void		 reply_outstanding_add(struct rt_node *,
			    struct rde_nbr *);
static struct reply_node *reply_outstanding_find(struct rt_node *,
			    struct rde_nbr *);
static void		 reply_outstanding_remove(struct reply_node *);
static void		 reply_active_timer(int, short, void *);
static void		 reply_active_start_timer(struct reply_node *);
static void		 reply_active_stop_timer(struct reply_node *);
static void		 reply_sia_timer(int, short, void *);
static void		 reply_sia_start_timer(struct reply_node *);
static void		 reply_sia_stop_timer(struct reply_node *);
static void		 rinfo_fill_infinite(struct rt_node *, enum route_type,
			    struct rinfo *);
static void		 rt_update_fib(struct rt_node *);
static void		 rt_set_successor(struct rt_node *,
			    struct eigrp_route *);
static struct eigrp_route *rt_get_successor_fc(struct rt_node *);
static void		 rde_send_update(struct eigrp_iface *, struct rinfo *);
static void		 rde_send_update_all(struct rt_node *, struct rinfo *);
static void		 rde_send_query(struct eigrp_iface *, struct rinfo *,
			    int);
static void		 rde_send_siaquery(struct rde_nbr *, struct rinfo *);
static void		 rde_send_query_all(struct eigrp *, struct rt_node *,
			    int);
static void		 rde_send_reply(struct rde_nbr *, struct rinfo *, int);
static void		 rde_last_reply(struct rt_node *);
static __inline int	 rde_nbr_compare(struct rde_nbr *, struct rde_nbr *);

RB_GENERATE(rt_tree, rt_node, entry, rt_compare)
RB_GENERATE(rde_nbr_head, rde_nbr, entry, rde_nbr_compare)

struct rde_nbr_head rde_nbrs = RB_INITIALIZER(&rde_nbrs);

/*
 * NOTE: events that don't cause a state transition aren't triggered to avoid
 * too much verbosity and are here mostly for illustration purposes.
 */
static struct {
	int		state;
	enum dual_event	event;
	int		new_state;
} dual_fsm_tbl[] = {
    /* current state		event		resulting state */
/* Passive */
    {DUAL_STA_PASSIVE,		DUAL_EVT_1,	0},
    {DUAL_STA_PASSIVE,		DUAL_EVT_2,	0},
    {DUAL_STA_PASSIVE,		DUAL_EVT_3,	DUAL_STA_ACTIVE3},
    {DUAL_STA_PASSIVE,		DUAL_EVT_4,	DUAL_STA_ACTIVE1},
/* Active Oij=0 */
    {DUAL_STA_ACTIVE0,		DUAL_EVT_5,	DUAL_STA_ACTIVE2},
    {DUAL_STA_ACTIVE0,		DUAL_EVT_11,	DUAL_STA_ACTIVE1},
    {DUAL_STA_ACTIVE0,		DUAL_EVT_14,	DUAL_STA_PASSIVE},
/* Active Oij=1 */
    {DUAL_STA_ACTIVE1,		DUAL_EVT_5,	DUAL_STA_ACTIVE2},
    {DUAL_STA_ACTIVE1,		DUAL_EVT_9,	DUAL_STA_ACTIVE0},
    {DUAL_STA_ACTIVE1,		DUAL_EVT_15,	DUAL_STA_PASSIVE},
/* Active Oij=2 */
    {DUAL_STA_ACTIVE2,		DUAL_EVT_12,	DUAL_STA_ACTIVE3},
    {DUAL_STA_ACTIVE2,		DUAL_EVT_16,	DUAL_STA_PASSIVE},
/* Active Oij=3 */
    {DUAL_STA_ACTIVE3,		DUAL_EVT_10,	DUAL_STA_ACTIVE2},
    {DUAL_STA_ACTIVE3,		DUAL_EVT_13,	DUAL_STA_PASSIVE},
/* Active (all) */
    {DUAL_STA_ACTIVE_ALL,	DUAL_EVT_6,	0},
    {DUAL_STA_ACTIVE_ALL,	DUAL_EVT_7,	0},
    {DUAL_STA_ACTIVE_ALL,	DUAL_EVT_8,	0},
/* sentinel */
    {-1,			0,		0},
};

static const char * const dual_event_names[] = {
	"DUAL_EVT_1",
	"DUAL_EVT_2",
	"DUAL_EVT_3",
	"DUAL_EVT_4",
	"DUAL_EVT_5",
	"DUAL_EVT_6",
	"DUAL_EVT_7",
	"DUAL_EVT_8",
	"DUAL_EVT_9",
	"DUAL_EVT_10",
	"DUAL_EVT_11",
	"DUAL_EVT_12",
	"DUAL_EVT_13",
	"DUAL_EVT_14",
	"DUAL_EVT_15",
	"DUAL_EVT_16"
};

static int
dual_fsm(struct rt_node *rn, enum dual_event event)
{
	int		old_state;
	int		new_state = 0;
	int		i;

	old_state = rn->state;
	for (i = 0; dual_fsm_tbl[i].state != -1; i++)
		if ((dual_fsm_tbl[i].state & old_state) &&
		    (dual_fsm_tbl[i].event == event)) {
			new_state = dual_fsm_tbl[i].new_state;
			break;
		}

	if (dual_fsm_tbl[i].state == -1) {
		/* event outside of the defined fsm, ignore it. */
		log_warnx("%s: route %s, event %s not expected in state %s",
		    __func__, log_prefix(rn), dual_event_names[event],
		    dual_state_name(old_state));
		return (0);
	}

	if (new_state != 0)
		rn->state = new_state;

	if (old_state != rn->state) {
		log_debug("%s: event %s changing state for prefix %s "
		    "from %s to %s", __func__, dual_event_names[event],
		    log_prefix(rn), dual_state_name(old_state),
		    dual_state_name(rn->state));

		if (old_state == DUAL_STA_PASSIVE ||
		    new_state == DUAL_STA_PASSIVE)
			rt_update_fib(rn);
	}

	return (0);
}

static __inline int
rt_compare(struct rt_node *a, struct rt_node *b)
{
	int		 addrcmp;

	addrcmp = eigrp_addrcmp(a->eigrp->af, &a->prefix, &b->prefix);
	if (addrcmp != 0)
		return (addrcmp);

	if (a->prefixlen < b->prefixlen)
		return (-1);
	if (a->prefixlen > b->prefixlen)
		return (1);

	return (0);
}

static struct rt_node *
rt_find(struct eigrp *eigrp, struct rinfo *ri)
{
	struct rt_node	 rn;

	rn.eigrp = eigrp;
	rn.prefix = ri->prefix;
	rn.prefixlen = ri->prefixlen;

	return (RB_FIND(rt_tree, &eigrp->topology, &rn));
}

static struct rt_node *
rt_new(struct eigrp *eigrp, struct rinfo *ri)
{
	struct rt_node	*rn;

	if ((rn = calloc(1, sizeof(*rn))) == NULL)
		fatal("rt_new");

	rn->eigrp = eigrp;
	rn->prefix = ri->prefix;
	rn->prefixlen = ri->prefixlen;
	rn->state = DUAL_STA_PASSIVE;
	TAILQ_INIT(&rn->routes);
	TAILQ_INIT(&rn->rijk);
	rt_set_successor(rn, NULL);

	if (RB_INSERT(rt_tree, &eigrp->topology, rn) != NULL) {
		log_warnx("%s failed for %s", __func__, log_prefix(rn));
		free(rn);
		return (NULL);
	}

	log_debug("%s: prefix %s", __func__, log_prefix(rn));

	return (rn);
}

void
rt_del(struct rt_node *rn)
{
	struct eigrp_route	*route;
	struct reply_node	*reply;

	log_debug("%s: prefix %s", __func__, log_prefix(rn));

	while ((reply = TAILQ_FIRST(&rn->rijk)) != NULL)
		reply_outstanding_remove(reply);
	while ((route = TAILQ_FIRST(&rn->routes)) != NULL)
		route_del(rn, route);
	RB_REMOVE(rt_tree, &rn->eigrp->topology, rn);
	free(rn);
}

static struct eigrp_route *
route_find(struct rde_nbr *nbr, struct rt_node *rn)
{
	struct eigrp_route	*route;

	TAILQ_FOREACH(route, &rn->routes, entry)
		if (route->nbr == nbr)
			return (route);

	return (NULL);
}

static struct eigrp_route *
route_new(struct rt_node *rn, struct rde_nbr *nbr, struct rinfo *ri)
{
	struct eigrp		*eigrp = rn->eigrp;
	struct eigrp_route	*route, *tmp;

	if ((route = calloc(1, sizeof(*route))) == NULL)
		fatal("route_new");

	route->nbr = nbr;
	route->type = ri->type;
	if (eigrp_addrisset(eigrp->af, &ri->nexthop))
		route->nexthop = ri->nexthop;
	else
		route->nexthop = nbr->addr;
	route_update_metrics(eigrp, route, ri);

	/* order by nexthop */
	TAILQ_FOREACH(tmp, &rn->routes, entry)
		if (eigrp_addrcmp(eigrp->af, &tmp->nexthop,
		    &route->nexthop) > 0)
			break;
	if (tmp)
		TAILQ_INSERT_BEFORE(tmp, route, entry);
	else
		TAILQ_INSERT_TAIL(&rn->routes, route, entry);

	log_debug("%s: prefix %s via %s distance (%u/%u)", __func__,
	    log_prefix(rn), log_route_origin(eigrp->af, route->nbr),
	    route->distance, route->rdistance);

	return (route);
}

static void
route_del(struct rt_node *rn, struct eigrp_route *route)
{
	struct eigrp		*eigrp = rn->eigrp;

	log_debug("%s: prefix %s via %s", __func__, log_prefix(rn),
	    log_route_origin(eigrp->af, route->nbr));

	if (route->flags & F_EIGRP_ROUTE_INSTALLED)
		rde_send_delete_kroute(rn, route);

	TAILQ_REMOVE(&rn->routes, route, entry);
	free(route);
}

static uint32_t
safe_sum_uint32(uint32_t a, uint32_t b)
{
	uint64_t	total;

	total = (uint64_t) a + (uint64_t) b;

	if (total >> 32)
		return ((uint32_t )(~0));

	return ((uint32_t) total);
}

static uint32_t
safe_mul_uint32(uint32_t a, uint32_t b)
{
	uint64_t	total;

	total = (uint64_t) a * (uint64_t) b;

	if (total >> 32)
		return ((uint32_t )(~0));

	return ((uint32_t) total);
}

uint32_t
eigrp_composite_delay(uint32_t delay)
{
	/* cheap overflow protection */
	delay = min(delay, (1 << 24) - 1);
	return (delay * EIGRP_SCALING_FACTOR);
}

uint32_t
eigrp_real_delay(uint32_t delay)
{
	return (delay / EIGRP_SCALING_FACTOR);
}

uint32_t
eigrp_composite_bandwidth(uint32_t bandwidth)
{
	/* truncate before applying the scaling factor */
	bandwidth = 10000000 / bandwidth;
	return (EIGRP_SCALING_FACTOR * bandwidth);
}

uint32_t
eigrp_real_bandwidth(uint32_t bandwidth)
{
	/*
	 * apply the scaling factor before the division and only then truncate.
	 * this is to keep consistent with what cisco does.
	 */
	return ((EIGRP_SCALING_FACTOR * (uint32_t)10000000) / bandwidth);
}

static uint32_t
route_composite_metric(uint8_t *kvalues, uint32_t delay, uint32_t bandwidth,
    uint8_t load, uint8_t reliability)
{
	uint64_t	 distance;
	uint32_t	 operand1, operand2, operand3;
	double		 operand4;

	/*
	 * Need to apply the scaling factor before any division to avoid
	 * losing information from truncation.
	 */
	operand1 = safe_mul_uint32(kvalues[0] * EIGRP_SCALING_FACTOR,
	    10000000 / bandwidth);
	operand2 = safe_mul_uint32(kvalues[1] * EIGRP_SCALING_FACTOR,
	    10000000 / bandwidth) / (256 - load);
	operand3 = safe_mul_uint32(kvalues[2] * EIGRP_SCALING_FACTOR, delay);

	distance = (uint64_t) operand1 + (uint64_t) operand2 +
	    (uint64_t) operand3;

	/* if K5 is set to zero, the last term of the formula is not used */
	if (kvalues[4] != 0) {
		operand4 = (double) kvalues[4] / (reliability + kvalues[3]);
		/* no risk of overflow (64 bits), operand4 can be at most 255 */
		distance *= operand4;
	}

	/* overflow protection */
	if (distance >> 32)
		distance = ((uint32_t )(~0));

	return ((uint32_t) distance);
}

static void
route_update_metrics(struct eigrp *eigrp, struct eigrp_route *route,
    struct rinfo *ri)
{
	struct eigrp_iface	*ei = route->nbr->ei;
	uint32_t		 delay, bandwidth;
	int			 mtu;

	route->metric = ri->metric;
	route->emetric = ri->emetric;
	route->flags |= F_EIGRP_ROUTE_M_CHANGED;

	delay = eigrp_real_delay(route->metric.delay);
	bandwidth = eigrp_real_bandwidth(route->metric.bandwidth);

	if (route->nbr->flags & F_RDE_NBR_SELF)
		route->rdistance = 0;
	else {
		route->rdistance = route_composite_metric(eigrp->kvalues,
		    delay, bandwidth, route->metric.load,
		    route->metric.reliability);

		/* update the delay */
		delay = safe_sum_uint32(delay, ei->delay);
		route->metric.delay = eigrp_composite_delay(delay);

		/* update the bandwidth */
		bandwidth = min(bandwidth, ei->bandwidth);
		route->metric.bandwidth = eigrp_composite_bandwidth(bandwidth);

		/* update the mtu */
		mtu = min(metric_decode_mtu(route->metric.mtu), ei->iface->mtu);
		metric_encode_mtu(route->metric.mtu, mtu);

		/* update the hop count */
		if (route->metric.hop_count < UINT8_MAX)
			route->metric.hop_count++;
	}

	route->distance = route_composite_metric(eigrp->kvalues, delay,
	    bandwidth, DEFAULT_LOAD, DEFAULT_RELIABILITY);
}

static void
reply_outstanding_add(struct rt_node *rn, struct rde_nbr *nbr)
{
	struct reply_node	*reply;

	if ((reply = calloc(1, sizeof(*reply))) == NULL)
		fatal("reply_outstanding_add");

	evtimer_set(&reply->ev_active_timeout, reply_active_timer, reply);
	evtimer_set(&reply->ev_sia_timeout, reply_sia_timer, reply);
	reply->siaquery_sent = 0;
	reply->siareply_recv = 0;
	reply->rn = rn;
	reply->nbr = nbr;
	TAILQ_INSERT_TAIL(&rn->rijk, reply, rn_entry);
	TAILQ_INSERT_TAIL(&nbr->rijk, reply, nbr_entry);

	if (rn->eigrp->active_timeout > 0) {
		reply_active_start_timer(reply);
		reply_sia_start_timer(reply);
	}
}

static struct reply_node *
reply_outstanding_find(struct rt_node *rn, struct rde_nbr *nbr)
{
	struct reply_node	*reply;

	TAILQ_FOREACH(reply, &rn->rijk, rn_entry)
		if (reply->nbr == nbr)
			return (reply);

	return (NULL);
}

static void
reply_outstanding_remove(struct reply_node *reply)
{
	reply_active_stop_timer(reply);
	reply_sia_stop_timer(reply);
	TAILQ_REMOVE(&reply->rn->rijk, reply, rn_entry);
	TAILQ_REMOVE(&reply->nbr->rijk, reply, nbr_entry);
	free(reply);
}

/* ARGSUSED */
static void
reply_active_timer(int fd, short event, void *arg)
{
	struct reply_node	*reply = arg;
	struct rde_nbr		*nbr = reply->nbr;

	log_debug("%s: neighbor %s is stuck in active", __func__,
	    log_addr(nbr->eigrp->af, &nbr->addr));

	rde_nbr_del(reply->nbr, 1);
}

static void
reply_active_start_timer(struct reply_node *reply)
{
	struct eigrp		*eigrp = reply->nbr->eigrp;
	struct timeval		 tv;

	timerclear(&tv);
	tv.tv_sec = eigrp->active_timeout * 60;
	if (evtimer_add(&reply->ev_active_timeout, &tv) == -1)
		fatal("reply_active_start_timer");
}

static void
reply_active_stop_timer(struct reply_node *reply)
{
	if (evtimer_pending(&reply->ev_active_timeout, NULL) &&
	    evtimer_del(&reply->ev_active_timeout) == -1)
		fatal("reply_active_stop_timer");
}

/* ARGSUSED */
static void
reply_sia_timer(int fd, short event, void *arg)
{
	struct reply_node	*reply = arg;
	struct rde_nbr		*nbr = reply->nbr;
	struct rt_node		*rn = reply->rn;
	struct rinfo		 ri;

	log_debug("%s: nbr %s prefix %s", __func__, log_addr(nbr->eigrp->af,
	    &nbr->addr), log_prefix(rn));

	if (reply->siaquery_sent > 0 && reply->siareply_recv == 0) {
		log_debug("%s: neighbor %s is stuck in active", __func__,
		    log_addr(nbr->eigrp->af, &nbr->addr));
		rde_nbr_del(nbr, 1);
		return;
	}

	/*
	 * draft-savage-eigrp-04 - Section 4.4.1.1:
	 * "Up to three SIA-QUERY packets for a specific destination may
	 * be sent, each at a value of one-half the ACTIVE time, so long
	 * as each are successfully acknowledged and met with an SIA-REPLY".
	 */
	if (reply->siaquery_sent >= 3)
		return;

	reply->siaquery_sent++;
	reply->siareply_recv = 0;

	/* restart sia and active timeouts */
	reply_sia_start_timer(reply);
	reply_active_start_timer(reply);

	/* send an sia-query */
	rinfo_fill_successor(rn, &ri);
	ri.metric.flags |= F_METRIC_ACTIVE;
	rde_send_siaquery(nbr, &ri);
}

static void
reply_sia_start_timer(struct reply_node *reply)
{
	struct eigrp		*eigrp = reply->nbr->eigrp;
	struct timeval		 tv;

	/*
	 * draft-savage-eigrp-04 - Section 4.4.1.1:
	 * "The SIA-QUERY packet SHOULD be sent on a per-destination basis
	 * at one-half of the ACTIVE timeout period."
	 */
	timerclear(&tv);
	tv.tv_sec = (eigrp->active_timeout * 60) / 2;
	if (evtimer_add(&reply->ev_sia_timeout, &tv) == -1)
		fatal("reply_sia_start_timer");
}

static void
reply_sia_stop_timer(struct reply_node *reply)
{
	if (evtimer_pending(&reply->ev_sia_timeout, NULL) &&
	    evtimer_del(&reply->ev_sia_timeout) == -1)
		fatal("reply_sia_stop_timer");
}

void
rinfo_fill_successor(struct rt_node *rn, struct rinfo *ri)
{
	if (rn->successor.nbr == NULL) {
		rinfo_fill_infinite(rn, EIGRP_ROUTE_INTERNAL, ri);
		return;
	}

	memset(ri, 0, sizeof(*ri));
	ri->af = rn->eigrp->af;
	ri->type = rn->successor.type;
	ri->prefix = rn->prefix;
	ri->prefixlen = rn->prefixlen;
	ri->metric = rn->successor.metric;
	if (ri->type == EIGRP_ROUTE_EXTERNAL)
		ri->emetric = rn->successor.emetric;
}

static void
rinfo_fill_infinite(struct rt_node *rn, enum route_type type, struct rinfo *ri)
{
	memset(ri, 0, sizeof(*ri));
	ri->af = rn->eigrp->af;
	ri->type = type;
	ri->prefix = rn->prefix;
	ri->prefixlen = rn->prefixlen;
	ri->metric.delay = EIGRP_INFINITE_METRIC;
}

static void
rt_update_fib(struct rt_node *rn)
{
	struct eigrp		*eigrp = rn->eigrp;
	uint8_t			 maximum_paths = eigrp->maximum_paths;
	uint8_t			 variance = eigrp->variance;
	int			 installed = 0;
	struct eigrp_route	*route;

	if (rn->state == DUAL_STA_PASSIVE) {
		/* no multipath for attached networks. */
		if (rn->successor.nbr &&
		    (rn->successor.nbr->flags & F_RDE_NBR_LOCAL))
			return;

		TAILQ_FOREACH(route, &rn->routes, entry) {
			/* skip redistributed routes */
			if (route->nbr->flags & F_RDE_NBR_REDIST)
				continue;

			/*
			 * Only feasible successors and the successor itself
			 * are elegible to be installed.
			 */
			if (route->rdistance >= rn->successor.fdistance)
				goto uninstall;

			if (route->distance >
			    (rn->successor.fdistance * variance))
				goto uninstall;

			if (installed >= maximum_paths)
				goto uninstall;

			installed++;

			if ((route->flags & F_EIGRP_ROUTE_INSTALLED) &&
			    !(route->flags & F_EIGRP_ROUTE_M_CHANGED))
				continue;

			rde_send_change_kroute(rn, route);
			continue;

uninstall:
			if (route->flags & F_EIGRP_ROUTE_INSTALLED)
				rde_send_delete_kroute(rn, route);
		}
	} else {
		TAILQ_FOREACH(route, &rn->routes, entry)
			if (route->flags & F_EIGRP_ROUTE_INSTALLED)
				rde_send_delete_kroute(rn, route);
	}
}

static void
rt_set_successor(struct rt_node *rn, struct eigrp_route *successor)
{
	struct eigrp		*eigrp = rn->eigrp;
	struct eigrp_iface	*ei;
	struct summary_addr	*summary;

	if (successor == NULL) {
		rn->successor.nbr = NULL;
		rn->successor.type = 0;
		rn->successor.fdistance = EIGRP_INFINITE_METRIC;
		rn->successor.rdistance = EIGRP_INFINITE_METRIC;
		memset(&rn->successor.metric, 0,
		    sizeof(rn->successor.metric));
		rn->successor.metric.delay = EIGRP_INFINITE_METRIC;
		memset(&rn->successor.emetric, 0,
		    sizeof(rn->successor.emetric));
	} else {
		rn->successor.nbr = successor->nbr;
		rn->successor.type = successor->type;
		rn->successor.fdistance = successor->distance;
		rn->successor.rdistance = successor->rdistance;
		rn->successor.metric = successor->metric;
		rn->successor.emetric = successor->emetric;
	}

	TAILQ_FOREACH(ei, &eigrp->ei_list, e_entry) {
		summary = rde_summary_check(ei, &rn->prefix, rn->prefixlen);
		if (summary)
			rt_summary_set(eigrp, summary, &rn->successor.metric);
	}
}

static struct eigrp_route *
rt_get_successor_fc(struct rt_node *rn)
{
	struct eigrp_route	*route, *successor = NULL;
	uint32_t		 distance = EIGRP_INFINITE_METRIC;
	int			 external_only = 1;

	TAILQ_FOREACH(route, &rn->routes, entry)
		if (route->type == EIGRP_ROUTE_INTERNAL) {
			/*
			 * connected routes should always be prefered over
			 * received routes independent of the metric.
			 */
			if (route->nbr->flags & F_RDE_NBR_LOCAL)
				return (route);

			external_only = 0;
		}

	TAILQ_FOREACH(route, &rn->routes, entry) {
		/*
		 * draft-savage-eigrp-04 - Section 5.4.7:
		 * "Internal routes MUST be prefered over external routes
		 * independent of the metric."
		 */
		if (route->type == EIGRP_ROUTE_EXTERNAL && !external_only)
			continue;

		/* pick the best route that meets the feasibility condition */
		if (route->rdistance < rn->successor.fdistance &&
		    route->distance < distance) {
			distance = route->distance;
			successor = route;
		}
	}

	return (successor);
}

struct summary_addr *
rde_summary_check(struct eigrp_iface *ei, union eigrpd_addr *prefix,
    uint8_t prefixlen)
{
	struct summary_addr	*summary;

	TAILQ_FOREACH(summary, &ei->summary_list, entry) {
		/* do not filter the summary itself */
		if (summary->prefixlen == prefixlen &&
		    !eigrp_addrcmp(ei->eigrp->af, prefix, &summary->prefix))
			return (NULL);

		if (summary->prefixlen <= prefixlen &&
		    !eigrp_prefixcmp(ei->eigrp->af, prefix, &summary->prefix,
		    summary->prefixlen))
			return (summary);
	}

	return (NULL);
}

static void
rde_send_update(struct eigrp_iface *ei, struct rinfo *ri)
{
	if (ri->metric.hop_count >= ei->eigrp->maximum_hops ||
	    rde_summary_check(ei, &ri->prefix, ri->prefixlen))
		ri->metric.delay = EIGRP_INFINITE_METRIC;

	rde_imsg_compose_eigrpe(IMSG_SEND_MUPDATE, ei->ifaceid, 0,
	    ri, sizeof(*ri));
	rde_imsg_compose_eigrpe(IMSG_SEND_MUPDATE_END, ei->ifaceid, 0,
	    NULL, 0);
}

static void
rde_send_update_all(struct rt_node *rn, struct rinfo *ri)
{
	struct eigrp		*eigrp = rn->eigrp;
	struct eigrp_iface	*ei;

	TAILQ_FOREACH(ei, &eigrp->ei_list, e_entry) {
		/* respect split-horizon configuration */
		if (rn->successor.nbr && rn->successor.nbr->ei == ei &&
		    ei->splithorizon)
			continue;
		rde_send_update(ei, ri);
	}
}

static void
rde_send_query(struct eigrp_iface *ei, struct rinfo *ri, int push)
{
	rde_imsg_compose_eigrpe(IMSG_SEND_MQUERY, ei->ifaceid, 0,
	    ri, sizeof(*ri));
	if (push)
		rde_imsg_compose_eigrpe(IMSG_SEND_MQUERY_END, ei->ifaceid,
		    0, NULL, 0);
}

static void
rde_send_siaquery(struct rde_nbr *nbr, struct rinfo *ri)
{
	rde_imsg_compose_eigrpe(IMSG_SEND_QUERY, nbr->peerid, 0,
	    ri, sizeof(*ri));
	rde_imsg_compose_eigrpe(IMSG_SEND_SIAQUERY_END, nbr->peerid, 0,
	    NULL, 0);
}

static void
rde_send_query_all(struct eigrp *eigrp, struct rt_node *rn, int push)
{
	struct eigrp_iface	*ei;
	struct rde_nbr		*nbr;
	struct rinfo		 ri;

	rinfo_fill_successor(rn, &ri);
	ri.metric.flags |= F_METRIC_ACTIVE;

	TAILQ_FOREACH(ei, &eigrp->ei_list, e_entry) {
		/* respect split-horizon configuration */
		if (rn->successor.nbr && rn->successor.nbr->ei == ei &&
		    ei->splithorizon)
			continue;

		rde_send_query(ei, &ri, push);
	}

	RB_FOREACH(nbr, rde_nbr_head, &rde_nbrs)
		if (nbr->ei->eigrp == eigrp && !(nbr->flags & F_RDE_NBR_SELF)) {
			/* respect split-horizon configuration */
			if (rn->successor.nbr &&
			    rn->successor.nbr->ei == nbr->ei &&
			    nbr->ei->splithorizon)
				continue;

			reply_outstanding_add(rn, nbr);
		}
}

void
rde_flush_queries(void)
{
	struct eigrp		*eigrp;
	struct eigrp_iface	*ei;

	TAILQ_FOREACH(eigrp, &rdeconf->instances, entry)
		TAILQ_FOREACH(ei, &eigrp->ei_list, e_entry)
			rde_imsg_compose_eigrpe(IMSG_SEND_MQUERY_END,
			    ei->ifaceid, 0, NULL, 0);
}

static void
rde_send_reply(struct rde_nbr *nbr, struct rinfo *ri, int siareply)
{
	int	 type;

	if (ri->metric.hop_count >= nbr->eigrp->maximum_hops ||
	    rde_summary_check(nbr->ei, &ri->prefix, ri->prefixlen))
		ri->metric.delay = EIGRP_INFINITE_METRIC;

	if (!siareply)
		type = IMSG_SEND_REPLY_END;
	else
		type = IMSG_SEND_SIAREPLY_END;

	rde_imsg_compose_eigrpe(IMSG_SEND_REPLY, nbr->peerid, 0,
	    ri, sizeof(*ri));
	rde_imsg_compose_eigrpe(type, nbr->peerid, 0, NULL, 0);
}

void
rde_check_update(struct rde_nbr *nbr, struct rinfo *ri)
{
	struct eigrp		*eigrp = nbr->eigrp;
	struct rt_node		*rn;
	struct eigrp_route	*route, *successor;
	uint32_t		 old_fdistance;
	struct rinfo		 sri;

	rn = rt_find(eigrp, ri);
	if (rn == NULL) {
		if (ri->metric.delay == EIGRP_INFINITE_METRIC)
			return;

		rn = rt_new(eigrp, ri);
		route = route_new(rn, nbr, ri);

		old_fdistance = EIGRP_INFINITE_METRIC;
	} else {
		old_fdistance = rn->successor.fdistance;

		if (ri->metric.delay == EIGRP_INFINITE_METRIC) {
			route = route_find(nbr, rn);
			if (route)
				route_del(rn, route);
		} else {
			route = route_find(nbr, rn);
			if (route == NULL)
				route = route_new(rn, nbr, ri);
			else
				route_update_metrics(eigrp, route, ri);
		}
	}

	switch (rn->state) {
	case DUAL_STA_PASSIVE:
		successor = rt_get_successor_fc(rn);

		/*
		 * go active if the successor was affected and no feasible
		 * successor exist.
		 */
		if (successor == NULL) {
			rde_send_query_all(eigrp, rn, 1);

			dual_fsm(rn, DUAL_EVT_4);
		} else {
			rt_set_successor(rn, successor);
			rt_update_fib(rn);

			/* send update with new metric if necessary */
			rinfo_fill_successor(rn, &sri);
			if (rn->successor.fdistance != old_fdistance)
				rde_send_update_all(rn, &sri);
		}
		break;
	case DUAL_STA_ACTIVE1:
		/* XXX event 9 if cost increase? */
		break;
	case DUAL_STA_ACTIVE3:
		/* XXX event 10 if cost increase? */
		break;
	}

	if ((rn->state & DUAL_STA_ACTIVE_ALL) && TAILQ_EMPTY(&rn->rijk))
		rde_last_reply(rn);
}

void
rde_check_query(struct rde_nbr *nbr, struct rinfo *ri, int siaquery)
{
	struct eigrp		*eigrp = nbr->eigrp;
	struct rt_node		*rn;
	struct eigrp_route	*route, *successor;
	uint32_t		 old_fdistance;
	struct rinfo		 sri;
	int			 reply_sent = 0;

	/*
	 * draft-savage-eigrp-02 - Section 4.3:
	 * "When a query is received for a route that doesn't exist in our
	 * topology table, a reply with infinite metric is sent and an entry
	 * in the topology table is added with the metric in the QUERY if
	 * the metric is not an infinite value".
	 */
	rn = rt_find(eigrp, ri);
	if (rn == NULL) {
		sri = *ri;
		sri.metric.delay = EIGRP_INFINITE_METRIC;
		rde_send_reply(nbr, &sri, 0);

		if (ri->metric.delay == EIGRP_INFINITE_METRIC)
			return;

		rn = rt_new(eigrp, ri);
		route = route_new(rn, nbr, ri);
		rt_set_successor(rn, route);
		return;
	}

	old_fdistance = rn->successor.fdistance;

	if (ri->metric.delay == EIGRP_INFINITE_METRIC) {
		route = route_find(nbr, rn);
		if (route)
			route_del(rn, route);
	} else {
		route = route_find(nbr, rn);
		if (route == NULL)
			route = route_new(rn, nbr, ri);
		else
			route_update_metrics(eigrp, route, ri);
	}

	switch (rn->state) {
	case DUAL_STA_PASSIVE:
		successor = rt_get_successor_fc(rn);

		/*
		 * go active if the successor was affected and no feasible
		 * successor exist.
		 */
		if (successor == NULL) {
			rde_send_query_all(eigrp, rn, 1);
			dual_fsm(rn, DUAL_EVT_3);
		} else {
			rt_set_successor(rn, successor);
			rt_update_fib(rn);

			/* send reply */
			rinfo_fill_successor(rn, &sri);
			rde_send_reply(nbr, &sri, 0);
			reply_sent = 1;

			/* send update with new metric if necessary */
			if (rn->successor.fdistance != old_fdistance)
				rde_send_update_all(rn, &sri);
		}
		break;
	case DUAL_STA_ACTIVE0:
	case DUAL_STA_ACTIVE1:
		if (nbr == rn->successor.nbr)
			dual_fsm(rn, DUAL_EVT_5);
		else {
			dual_fsm(rn, DUAL_EVT_6);
			rinfo_fill_successor(rn, &sri);
			sri.metric.flags |= F_METRIC_ACTIVE;
			rde_send_reply(nbr, &sri, 0);
			reply_sent = 1;
		}
		break;
	case DUAL_STA_ACTIVE2:
	case DUAL_STA_ACTIVE3:
		if (nbr == rn->successor.nbr) {
			/* XXX not defined in the spec, do nothing? */
		} else {
			dual_fsm(rn, DUAL_EVT_6);
			rinfo_fill_successor(rn, &sri);
			sri.metric.flags |= F_METRIC_ACTIVE;
			rde_send_reply(nbr, &sri, 0);
			reply_sent = 1;
		}
		break;
	}

	if ((rn->state & DUAL_STA_ACTIVE_ALL) && TAILQ_EMPTY(&rn->rijk))
		rde_last_reply(rn);

	if (siaquery && !reply_sent) {
		rinfo_fill_successor(rn, &sri);
		sri.metric.flags |= F_METRIC_ACTIVE;
		rde_send_reply(nbr, &sri, 1);
	}
}

static void
rde_last_reply(struct rt_node *rn)
{
	struct eigrp		*eigrp = rn->eigrp;
	struct eigrp_route	*successor;
	struct rde_nbr		*old_successor;
	uint32_t		 old_fdistance;
	struct rinfo		 ri;

	old_successor = rn->successor.nbr;
	old_fdistance = rn->successor.fdistance;

	switch (rn->state) {
	case DUAL_STA_ACTIVE0:
		successor = rt_get_successor_fc(rn);
		if (successor == NULL) {
			/* feasibility condition is not met */
			rde_send_query_all(eigrp, rn, 1);
			dual_fsm(rn, DUAL_EVT_11);
			break;
		}

		/* update successor - feasibility condition is met */
		rt_set_successor(rn, successor);

		/* advertise new successor to neighbors */
		rinfo_fill_successor(rn, &ri);
		rde_send_update_all(rn, &ri);

		dual_fsm(rn, DUAL_EVT_14);
		break;
	case DUAL_STA_ACTIVE1:
		/* update successor */
		rn->successor.fdistance = EIGRP_INFINITE_METRIC;
		successor = rt_get_successor_fc(rn);
		rt_set_successor(rn, successor);

		/* advertise new successor to neighbors */
		rinfo_fill_successor(rn, &ri);
		rde_send_update_all(rn, &ri);

		dual_fsm(rn, DUAL_EVT_15);
		break;
	case DUAL_STA_ACTIVE2:
		successor = rt_get_successor_fc(rn);
		if (successor == NULL) {
			/* feasibility condition is not met */
			rde_send_query_all(eigrp, rn, 1);
			dual_fsm(rn, DUAL_EVT_12);
			break;
		}

		/* update successor - feasibility condition is met */
		rt_set_successor(rn, successor);

		/* send a reply to the old successor */
		rinfo_fill_successor(rn, &ri);
		ri.metric.flags |= F_METRIC_ACTIVE;
		if (old_successor)
			rde_send_reply(old_successor, &ri, 0);

		/* advertise new successor to neighbors */
		rde_send_update_all(rn, &ri);

		dual_fsm(rn, DUAL_EVT_16);
		break;
	case DUAL_STA_ACTIVE3:
		/* update successor */
		rn->successor.fdistance = EIGRP_INFINITE_METRIC;
		successor = rt_get_successor_fc(rn);
		rt_set_successor(rn, successor);

		/* send a reply to the old successor */
		rinfo_fill_successor(rn, &ri);
		ri.metric.flags |= F_METRIC_ACTIVE;
		if (old_successor)
			rde_send_reply(old_successor, &ri, 0);

		/* advertise new successor to neighbors */
		rde_send_update_all(rn, &ri);

		dual_fsm(rn, DUAL_EVT_13);
		break;
	}

	if (rn->state == DUAL_STA_PASSIVE && rn->successor.nbr == NULL)
		rt_del(rn);
}

void
rde_check_reply(struct rde_nbr *nbr, struct rinfo *ri, int siareply)
{
	struct eigrp		*eigrp = nbr->eigrp;
	struct rt_node		*rn;
	struct reply_node       *reply;
	struct eigrp_route	*route;

	rn = rt_find(eigrp, ri);
	if (rn == NULL)
		return;

	/* XXX ignore reply when the state is passive? */
	if (rn->state == DUAL_STA_PASSIVE)
		return;

	reply = reply_outstanding_find(rn, nbr);
	if (reply == NULL)
		return;

	if (siareply) {
		reply->siareply_recv = 1;
		reply_active_start_timer(reply);
		return;
	}

	if (ri->metric.delay == EIGRP_INFINITE_METRIC) {
		route = route_find(nbr, rn);
		if (route)
			route_del(rn, route);
	} else {
		route = route_find(nbr, rn);
		if (route == NULL)
			route = route_new(rn, nbr, ri);
		else
			route_update_metrics(eigrp, route, ri);
	}

	reply_outstanding_remove(reply);
	if (TAILQ_EMPTY(&rn->rijk))
		rde_last_reply(rn);
}

void
rde_check_link_down_rn(struct rde_nbr *nbr, struct rt_node *rn,
    struct eigrp_route *route)
{
	struct eigrp		*eigrp = nbr->eigrp;
	struct reply_node       *reply;
	struct eigrp_route	*successor;
	uint32_t		 old_fdistance;
	struct rinfo		 ri;
	enum route_type		 type;

	old_fdistance = rn->successor.fdistance;

	type = route->type;
	route_del(rn, route);

	switch (rn->state) {
	case DUAL_STA_PASSIVE:
		successor = rt_get_successor_fc(rn);

		/*
		 * go active if the successor was affected and no feasible
		 * successor exist.
		 */
		if (successor == NULL) {
			rde_send_query_all(eigrp, rn, 0);

			dual_fsm(rn, DUAL_EVT_4);
		} else {
			rt_set_successor(rn, successor);
			rt_update_fib(rn);

			/* send update with new metric if necessary */
			rinfo_fill_successor(rn, &ri);
			if (rn->successor.fdistance != old_fdistance)
				rde_send_update_all(rn, &ri);
		}
		break;
	case DUAL_STA_ACTIVE1:
		if (nbr == rn->successor.nbr)
			dual_fsm(rn, DUAL_EVT_9);
		break;
	case DUAL_STA_ACTIVE3:
		if (nbr == rn->successor.nbr)
			dual_fsm(rn, DUAL_EVT_10);
		break;
	}

	if (rn->state & DUAL_STA_ACTIVE_ALL) {
		reply = reply_outstanding_find(rn, nbr);
		if (reply) {
			rinfo_fill_infinite(rn, type, &ri);
			rde_check_reply(nbr, &ri, 0);
		}
	}
}

void
rde_check_link_down_nbr(struct rde_nbr *nbr)
{
	struct eigrp		*eigrp = nbr->eigrp;
	struct rt_node		*rn, *safe;
	struct eigrp_route	*route;

	RB_FOREACH_SAFE(rn, rt_tree, &eigrp->topology, safe) {
		route = route_find(nbr, rn);
		if (route) {
			rde_check_link_down_rn(nbr, rn, route);
			if (rn->successor.nbr == nbr)
				rn->successor.nbr = NULL;
		}
	}
}

void
rde_check_link_down(unsigned int ifindex)
{
	struct rde_nbr		*nbr;

	RB_FOREACH(nbr, rde_nbr_head, &rde_nbrs)
		if (nbr->ei->iface->ifindex == ifindex)
			rde_check_link_down_nbr(nbr);

	rde_flush_queries();
}

void
rde_check_link_cost_change(struct rde_nbr *nbr, struct eigrp_iface *ei)
{
}

static __inline int
rde_nbr_compare(struct rde_nbr *a, struct rde_nbr *b)
{
	return (a->peerid - b->peerid);
}

struct rde_nbr *
rde_nbr_find(uint32_t peerid)
{
	struct rde_nbr	n;

	n.peerid = peerid;

	return (RB_FIND(rde_nbr_head, &rde_nbrs, &n));
}

struct rde_nbr *
rde_nbr_new(uint32_t peerid, struct rde_nbr *new)
{
	struct rde_nbr		*nbr;

	if ((nbr = calloc(1, sizeof(*nbr))) == NULL)
		fatal("rde_nbr_new");

	nbr->peerid = peerid;
	nbr->ifaceid = new->ifaceid;
	nbr->addr = new->addr;
	nbr->ei = eigrp_if_lookup_id(nbr->ifaceid);
	if (nbr->ei)
		nbr->eigrp = nbr->ei->eigrp;
	TAILQ_INIT(&nbr->rijk);
	nbr->flags = new->flags;

	if (nbr->peerid != NBR_IDSELF &&
	    RB_INSERT(rde_nbr_head, &rde_nbrs, nbr) != NULL)
		fatalx("rde_nbr_new: RB_INSERT failed");

	return (nbr);
}

void
rde_nbr_del(struct rde_nbr *nbr, int peerterm)
{
	struct reply_node	*reply;

	if (peerterm)
		rde_imsg_compose_eigrpe(IMSG_NEIGHBOR_DOWN, nbr->peerid,
		    0, NULL, 0);

	while((reply = TAILQ_FIRST(&nbr->rijk)) != NULL)
		reply_outstanding_remove(reply);

	if (nbr->peerid != NBR_IDSELF)
		RB_REMOVE(rde_nbr_head, &rde_nbrs, nbr);
	free(nbr);
}
@


1.27
log
@Remove superfluous includes and follow style(9).

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.26 2016/04/15 13:15:33 renato Exp $ */
d29 41
a69 6
void	reply_active_timer(int, short, void *);
void	reply_active_start_timer(struct reply_node *);
void	reply_active_stop_timer(struct reply_node *);
void	reply_sia_timer(int, short, void *);
void	reply_sia_start_timer(struct reply_node *);
void	reply_sia_stop_timer(struct reply_node *);
a70 4
extern struct eigrpd_conf	*rdeconf;

static int rt_compare(struct rt_node *, struct rt_node *);
RB_PROTOTYPE(rt_tree, rt_node, entry, rt_compare)
a71 4

static __inline int rde_nbr_compare(struct rde_nbr *, struct rde_nbr *);
RB_HEAD(rde_nbr_head, rde_nbr);
RB_PROTOTYPE(rde_nbr_head, rde_nbr, entry, rde_nbr_compare)
d80 1
a80 1
struct {
d113 1
a113 1
const char * const dual_event_names[] = {
d132 1
a132 1
int
d172 1
a172 1
static int
d189 1
a189 1
struct rt_node *
d201 1
a201 1
struct rt_node *
d244 1
a244 1
struct eigrp_route *
d256 1
a256 1
struct eigrp_route *
d290 1
a290 1
void
d305 1
a305 1
uint32_t
d318 1
a318 1
uint32_t
d363 1
a363 1
uint32_t
d398 1
a398 1
void
d441 1
a441 1
void
d464 1
a464 1
struct reply_node *
d476 1
a476 1
void
d487 1
a487 1
void
d499 1
a499 1
void
d511 1
a511 1
void
d520 1
a520 1
void
d560 1
a560 1
void
d577 1
a577 1
void
d603 1
a603 1
void
d614 1
a614 1
void
d668 1
a668 1
void
d701 1
a701 1
struct eigrp_route *
d761 1
a761 1
void
d774 1
a774 1
void
d789 1
a789 1
void
d799 1
a799 1
void
d808 1
a808 1
void
d851 1
a851 1
void
d1045 1
a1045 1
void
@


1.26
log
@Fix corner case in Feasible Condition check.

From the EIGRP draft:
"The Feasibility Condition is met when a neighbor's advertised cost, (RD)
to a destination is less than the Feasible Distance for that destination".

So, according to the draf, when the Reported Distance is EQUAL to the
Feasible Distance, the Feasible Condition is NOT met.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.25 2016/04/15 13:10:56 renato Exp $ */
d19 2
a22 1
#include <arpa/inet.h>
a23 1
#include "eigrp.h"
d26 1
a27 1
#include "rde.h"
@


1.25
log
@Minor fixes and code cleanup.

* whitespace cleanup;
* copy in_addr structs directly;
* add more malloc return value checks;
* fix some log messages;
* turn ifacecnt into a static variable;
* use eigrp_addrcmp() on if_deladdr() to avoid code duplication;
* s/route_print_origin/log_route_origin/
* more smaller issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.24 2016/02/21 19:03:58 renato Exp $ */
d611 1
a611 1
			if (route->rdistance > rn->successor.fdistance)
@


1.24
log
@Skip redistributed routes when updating the FIB.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.23 2016/02/21 19:01:12 renato Exp $ */
a228 15
static const char *
route_print_origin(int af, struct rde_nbr *nbr)
{
	if (nbr->flags & F_RDE_NBR_SELF) {
		if (nbr->flags & F_RDE_NBR_REDIST)
			return ("redistribute");
		if (nbr->flags & F_RDE_NBR_SUMMARY)
			return ("summary");
		else
			return ("connected");
	}

	return (log_addr(af, &nbr->addr));
}

d257 1
a257 1
	    log_prefix(rn), route_print_origin(eigrp->af, route->nbr),
d269 1
a269 1
	    route_print_origin(eigrp->af, route->nbr));
d866 1
a866 1
			if (route) {
a867 1
			}
@


1.23
log
@Move some functions around and rename a few variables and functions.

The sooner we do these changes the better. This rearrangement will make
the code easier to read.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.22 2016/02/21 18:56:49 renato Exp $ */
d618 4
d623 1
a623 1
			 * only feasible successors and the successor itself
@


1.22
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.21 2016/02/21 18:52:00 renato Exp $ */
d1280 1
a1280 1
	nbr->ei = eigrp_iface_find_id(nbr->ifaceid);
@


1.21
log
@Extend eigrp_addrcmp() and use it in more places.

The idea is to remove unnecessary code duplication throughout the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.20 2016/02/21 18:40:56 renato Exp $ */
d168 1
a168 1
	memcpy(&rn.prefix, &ri->prefix, sizeof(rn.prefix));
d183 1
a183 1
	memcpy(&rn->prefix, &ri->prefix, sizeof(rn->prefix));
d256 1
a256 1
		memcpy(&route->nexthop, &ri->nexthop, sizeof(route->nexthop));
d258 1
a258 1
		memcpy(&route->nexthop, &nbr->addr, sizeof(route->nexthop));
d394 2
a395 2
	memcpy(&route->metric, &ri->metric, sizeof(route->metric));
	memcpy(&route->emetric, &ri->emetric, sizeof(route->emetric));
d584 1
a584 1
	memcpy(&ri->prefix, &rn->prefix, sizeof(ri->prefix));
d586 1
a586 1
	memcpy(&ri->metric, &rn->successor.metric, sizeof(ri->metric));
d588 1
a588 2
		memcpy(&ri->emetric, &rn->successor.emetric,
		    sizeof(ri->emetric));
d597 1
a597 1
	memcpy(&ri->prefix, &rn->prefix, sizeof(ri->prefix));
d674 2
a675 4
		memcpy(&rn->successor.metric, &successor->metric,
		    sizeof(rn->successor.metric));
		memcpy(&rn->successor.emetric, &successor->emetric,
		    sizeof(rn->successor.emetric));
d942 1
a942 1
		memcpy(&sri, ri, sizeof(sri));
d1279 1
a1279 1
	memcpy(&nbr->addr,  &new->addr, sizeof(nbr->addr));
@


1.20
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.19 2016/01/28 13:25:14 jsg Exp $ */
d148 5
a152 20
	switch (a->eigrp->af) {
	case AF_INET:
		if (ntohl(a->prefix.v4.s_addr) <
		    ntohl(b->prefix.v4.s_addr))
			return (-1);
		if (ntohl(a->prefix.v4.s_addr) >
		    ntohl(b->prefix.v4.s_addr))
			return (1);
		break;
	case AF_INET6:
		if (memcmp(a->prefix.v6.s6_addr,
		    b->prefix.v6.s6_addr, 16) < 0)
			return (-1);
		if (memcmp(a->prefix.v6.s6_addr,
		    b->prefix.v6.s6_addr, 16) > 0)
			return (1);
		break;
	default:
		fatalx("rt_compare: unknown af");
	}
d262 3
a264 12
	TAILQ_FOREACH(tmp, &rn->routes, entry) {
		switch (eigrp->af) {
		case AF_INET:
			if (ntohl(tmp->nexthop.v4.s_addr) >
			    ntohl(route->nexthop.v4.s_addr))
				goto insert;
			break;
		case AF_INET6:
			if (memcmp(&tmp->nexthop.v6.s6_addr[0],
			    &route->nexthop.v6.s6_addr[0],
			    sizeof(struct in6_addr)) > 0)
				goto insert;
a265 5
		default:
			fatalx("route_new: unknown af");
		}
	}
insert:
@


1.19
log
@Correct bit flag tests to work as intended.
ok renato@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.18 2016/01/15 12:56:12 renato Exp $ */
d475 4
a478 2
	reply_active_start_timer(reply);
	reply_sia_start_timer(reply);
a521 3
	if (eigrp->active_timeout == 0)
		return;

a574 1

a581 3

	if (eigrp->active_timeout == 0)
		return;
@


1.18
log
@For each prefix, order routes by their nexthop.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.17 2016/01/15 12:52:49 renato Exp $ */
d669 2
a670 2
			if (route->flags & (F_EIGRP_ROUTE_INSTALLED |
			    !F_EIGRP_ROUTE_M_CHANGED))
@


1.17
log
@Better handle explicit nexthops.

If an explicit nexthop was advertised for a route, show it in the
'eigrpctl show topology' command output instead of the address of the
advertising neighbor (implicit nexthop).
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.16 2016/01/15 12:48:53 renato Exp $ */
d263 1
a263 1
	struct eigrp_route	*route;
d275 24
a298 1
	TAILQ_INSERT_TAIL(&rn->routes, route, entry);
@


1.16
log
@Fix detection of the Stuck-in-Active (SIA) state.

We were rearming the SIA and active timer over and over again. Now,
when the maximum of three SIA-Queries are sent, we stop and wait for the
active timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.15 2016/01/15 12:41:09 renato Exp $ */
d270 4
a273 1
	memcpy(&route->nexthop, &ri->nexthop, sizeof(route->nexthop));
@


1.15
log
@Minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.14 2016/01/15 12:36:41 renato Exp $ */
d530 14
a543 1
	/* restart active timeout */
a550 11
	/*
	 * draft-savage-eigrp-04 - Section 4.4.1.1:
	 * "Up to three SIA-QUERY packets for a specific destination may
	 * be sent, each at a value of one-half the ACTIVE time, so long
	 * as each are successfully acknowledged and met with an SIA-REPLY".
	 */
	if (reply->siaquery_sent < 3) {
		reply->siaquery_sent++;
		reply->siareply_recv = 0;
		reply_sia_start_timer(reply);
	}
@


1.14
log
@Add support for manually clearing neighbors.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.13 2016/01/15 12:23:45 renato Exp $ */
d369 1
a369 1
	    10000000 /bandwidth) / (256 - load);
d482 1
a482 1
	log_debug("%s: neighbor %s is stuck in active",
d524 1
a524 1
		log_debug("%s: neighbor %s is stuck in active",
@


1.13
log
@Order the routing instances by AF and then by AS.

This commit only improves the readability of the 'eigrpctl' show commands.

Additionaly, we can simplify the nbr_compare() and rt_compare() functions
because we know that under no circumstances nbrs or routes from different
AFs or ASes will be in the same tree. Each instance has its own trees of
neighbors and routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.12 2015/12/13 19:02:49 renato Exp $ */
d1303 1
a1303 1
rde_nbr_del(struct rde_nbr *nbr, int send_peerterm)
d1307 1
a1307 1
	if (send_peerterm)
@


1.12
log
@Respect the k-values configuration when calculating the composite metric.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.11 2015/12/13 19:00:42 renato Exp $ */
a147 5
	if (a->eigrp->af < b->eigrp->af)
		return (-1);
	if (a->eigrp->af > b->eigrp->af)
		return (1);

@


1.11
log
@Minor cosmetic changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.10 2015/10/27 03:25:55 renato Exp $ */
d276 1
a276 1
	route_update_metrics(route, ri);
d315 13
d359 35
d395 2
a396 1
route_update_metrics(struct eigrp_route *route, struct rinfo *ri)
d398 7
a404 2
	uint32_t	 bandwidth;
	int		 mtu;
d406 4
a409 3
	if (route->nbr->flags & F_RDE_NBR_SELF) {
		memcpy(&route->metric, &ri->metric, sizeof(route->metric));
		memcpy(&route->emetric, &ri->emetric, sizeof(route->emetric));
d411 8
d420 2
a421 14
		/* no need to update the local metric */
	} else {
		memcpy(&route->metric, &ri->metric, sizeof(route->metric));
		memcpy(&route->emetric, &ri->emetric, sizeof(route->emetric));
		route->rdistance = safe_sum_uint32(ri->metric.delay,
		    ri->metric.bandwidth);

		/* update delay. */
		route->metric.delay = safe_sum_uint32(route->metric.delay,
		    eigrp_composite_delay(route->nbr->ei->delay));

		/* update bandwidth */
		bandwidth = min(route->nbr->ei->bandwidth,
		    eigrp_real_bandwidth(route->metric.bandwidth));
d424 2
a425 3
		/* update mtu */
		mtu = min(metric_decode_mtu(route->metric.mtu),
		    route->nbr->ei->iface->mtu);
d428 1
a428 1
		/* update hop count */
d433 2
a434 3
	route->distance = safe_sum_uint32(route->metric.delay,
	    route->metric.bandwidth);
	route->flags |= F_EIGRP_ROUTE_M_CHANGED;
d678 1
d899 1
a899 1
				route_update_metrics(route, ri);
d980 1
a980 1
			route_update_metrics(route, ri);
d1168 1
a1168 1
			route_update_metrics(route, ri);
@


1.10
log
@Introduce a new flag to identify "self" neighbors attached to local interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.9 2015/10/25 00:42:02 renato Exp $ */
d311 1
a311 1
	return (total & 0xFFFFFFFF);
d1122 2
a1123 5
	if (!TAILQ_EMPTY(&rn->rijk))
		/* not last reply */
		return;

	rde_last_reply(rn);
@


1.9
log
@When converting the real bandwidth to the composite bandwidth, truncate
before applying the scaling factor.

When converting the composite bandwidth to the real bandwidth, apply
the scaling factor before the division and only then truncate.

This is to keep consistent with what Cisco does, the draft is unclear
on this point.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.8 2015/10/25 00:39:14 renato Exp $ */
d568 3
a570 2
	uint8_t			 maximum_paths = rn->eigrp->maximum_paths;
	uint8_t			 variance = rn->eigrp->variance;
d575 5
a580 3
			if (route->nbr->flags & F_RDE_NBR_SELF)
				continue;

a587 5
			/* no multipath for attached networks. */
			if (rn->successor.rdistance == 0 &&
			    route->distance > 0)
				goto uninstall;

d662 1
a662 1
			if (route->rdistance == 0)
@


1.8
log
@Add a few more overflow protections in the DUAL state
machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.7 2015/10/21 03:52:12 renato Exp $ */
d331 3
a333 1
	return ((EIGRP_SCALING_FACTOR * (uint32_t)10000000) / bandwidth);
a335 1
/* the formula is the same but let's focus on keeping the code readable */
d339 4
@


1.7
log
@Add support for route summarization.

Working great but need more testing, especially with ipv6. For now
we don't validate if one configured summary is inside another or the
presence of duplicates. Will address these issues in a future commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.6 2015/10/21 03:48:09 renato Exp $ */
d317 2
a318 4
	/*
	 * NOTE: the multiplication below has no risk of overflow
	 * because of the maximum configurable delay.
	 */
d378 2
a379 1
	route->distance = route->metric.delay + route->metric.bandwidth;
@


1.6
log
@Minor fixes and code cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.5 2015/10/20 11:26:40 jsg Exp $ */
d616 4
d629 9
a637 1
		return;
d640 5
a644 8
	rn->successor.nbr = successor->nbr;
	rn->successor.type = successor->type;
	rn->successor.fdistance = successor->distance;
	rn->successor.rdistance = successor->rdistance;
	memcpy(&rn->successor.metric, &successor->metric,
	    sizeof(rn->successor.metric));
	memcpy(&rn->successor.emetric, &successor->emetric,
	    sizeof(rn->successor.emetric));
d686 21
d710 2
a711 1
	if (ri->metric.hop_count >= ei->eigrp->maximum_hops)
d802 2
a803 1
	if (ri->metric.hop_count >= nbr->eigrp->maximum_hops)
@


1.5
log
@fix a use after free found by clang using an approach suggested by renato
ok renato@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.4 2015/10/05 01:59:33 renato Exp $ */
a558 17
	ri->metric.bandwidth = 0;
	ri->metric.mtu[0] = 0;
	ri->metric.mtu[1] = 0;
	ri->metric.mtu[2] = 0;
	ri->metric.hop_count = 0;
	ri->metric.reliability = 0;
	ri->metric.load = 0;
	ri->metric.tag = 0;
	ri->metric.flags = 0;
	if (ri->type == EIGRP_ROUTE_EXTERNAL) {
		ri->emetric.routerid = 0;
		ri->emetric.as = 0;
		ri->emetric.tag = 0;
		ri->emetric.metric = 0;
		ri->emetric.protocol = 0;
		ri->emetric.flags = 0;
	}
d1182 1
a1182 1
rde_check_link_cost_change(struct rde_nbr *nbr, struct eigrp_interface *ei)
@


1.4
log
@When the SIA state is declared for a given destination, reset the
adjacency with the unresponsive neighbor(s).
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.3 2015/10/04 23:00:10 renato Exp $ */
d1121 1
d1125 1
d1163 1
a1163 1
			rinfo_fill_infinite(rn, route->type, &ri);
@


1.3
log
@Fix warnings and add safeguards to protect against corrupted data.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.2 2015/10/04 22:54:38 renato Exp $ */
d437 1
a437 1
	rde_nbr_del(reply->nbr);
d478 1
a478 1
		rde_nbr_del(nbr);
d1242 1
a1242 1
rde_nbr_del(struct rde_nbr *nbr)
d1245 4
@


1.2
log
@Add option to configure or disable the DUAL active timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_dual.c,v 1.1 2015/10/02 04:26:47 renato Exp $ */
d171 1
a171 2
		log_debug("%s: unexpected address-family", __func__);
		break;
@


1.1
log
@Welcome eigrpd

The eigrpd daemon will support the Enhanced Interior Gateway Routing Protocol.

Built using the imsg/three process framework and heavily based on ospfd(8), ospf6d(8) and ldpd(8).

The current status of eigrpd(8) is as follows:
* Almost full compliance with the specification: DUAL FSM, RTP, CR mode, SIA, etc
* Support for both IPv4 and IPv6
* Support for multiple instances (different ASes/AFs) within the same process
* Support for rdomains (one process per rdomain)
* RIB/FIB synchronization
* Basic redistribution support

Not implemented features (yet):
* Configuration reload support (partially implemented)
* Route summarization
* Advanced route redistribution/filtering
* Carp integration
* Authentication (draft is missing information)
* Stub (not released by Cisco)

Not yet connected to the builds.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d444 1
d447 3
d451 1
a451 1
	tv.tv_sec = EIGRP_ACTIVE_TIMEOUT;
d507 1
d510 3
d519 1
a519 1
	tv.tv_sec = EIGRP_ACTIVE_TIMEOUT / 2;
@

