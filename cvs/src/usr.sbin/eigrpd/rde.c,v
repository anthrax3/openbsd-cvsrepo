head	1.23;
access;
symbols
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11;
locks; strict;
comment	@ * @;


1.23
date	2016.09.02.16.46.29;	author renato;	state Exp;
branches;
next	1.22;
commitid	K6uLqMvlsHB7ikcI;

1.22
date	2016.09.02.16.44.33;	author renato;	state Exp;
branches;
next	1.21;
commitid	o7fEENaKxNIOcUKV;

1.21
date	2016.09.02.16.39.44;	author renato;	state Exp;
branches;
next	1.20;
commitid	POT6tRNh9I6XBjro;

1.20
date	2016.09.02.16.29.55;	author renato;	state Exp;
branches;
next	1.19;
commitid	w1am8mhLiSfZo4x6;

1.19
date	2016.09.02.16.23.50;	author renato;	state Exp;
branches;
next	1.18;
commitid	DH2pL4vn6jxcoOc4;

1.18
date	2016.08.08.16.48.53;	author renato;	state Exp;
branches;
next	1.17;
commitid	c8D4zvIO7MW01tkY;

1.17
date	2016.06.05.03.36.41;	author renato;	state Exp;
branches;
next	1.16;
commitid	zEMo2iI4upK0IUZs;

1.16
date	2016.05.12.00.15.24;	author renato;	state Exp;
branches;
next	1.15;
commitid	d0Cl14ESmQZtUiKF;

1.15
date	2016.04.18.13.14.27;	author renato;	state Exp;
branches;
next	1.14;
commitid	rJZSxp1A2B7ePbpv;

1.14
date	2016.04.15.13.31.03;	author renato;	state Exp;
branches;
next	1.13;
commitid	O4hLgqBnOhtx0sRS;

1.13
date	2016.04.15.13.27.58;	author renato;	state Exp;
branches;
next	1.12;
commitid	kPO5lrKuqb5ObcwF;

1.12
date	2016.04.15.13.21.45;	author renato;	state Exp;
branches;
next	1.11;
commitid	zOVrWYmdyccBjHwb;

1.11
date	2016.02.21.18.56.49;	author renato;	state Exp;
branches;
next	1.10;
commitid	Fln6asbk1x7lkTSp;

1.10
date	2016.01.15.12.52.49;	author renato;	state Exp;
branches;
next	1.9;
commitid	QKBmJwvNkdZQBsi5;

1.9
date	2016.01.15.12.25.43;	author renato;	state Exp;
branches;
next	1.8;
commitid	9OwAkOA9fQWBhvxS;

1.8
date	2015.12.05.15.49.01;	author claudio;	state Exp;
branches;
next	1.7;
commitid	2wnDVolm6bXCrxDq;

1.7
date	2015.10.27.03.27.35;	author renato;	state Exp;
branches;
next	1.6;
commitid	jhqQiZsN9OyMJvYl;

1.6
date	2015.10.21.03.52.12;	author renato;	state Exp;
branches;
next	1.5;
commitid	67lIWG5WR4Do3HhB;

1.5
date	2015.10.21.03.48.09;	author renato;	state Exp;
branches;
next	1.4;
commitid	AfOWCk8vQ1tJuhIQ;

1.4
date	2015.10.10.05.12.33;	author renato;	state Exp;
branches;
next	1.3;
commitid	XDavuEoYjKwlIReL;

1.3
date	2015.10.05.01.59.33;	author renato;	state Exp;
branches;
next	1.2;
commitid	gALnAEcCWDSQBrng;

1.2
date	2015.10.04.23.00.10;	author renato;	state Exp;
branches;
next	1.1;
commitid	vb2pR0BnPuOhwW09;

1.1
date	2015.10.02.04.26.47;	author renato;	state Exp;
branches;
next	;
commitid	dGX9Xs9GfneSNaca;


desc
@@


1.23
log
@Minor tweaks
@
text
@/*	$OpenBSD: rde.c,v 1.22 2016/09/02 16:44:33 renato Exp $ */

/*
 * Copyright (c) 2015 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2004, 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <net/route.h>

#include <errno.h>
#include <pwd.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "eigrpd.h"
#include "eigrpe.h"
#include "rde.h"
#include "log.h"

static void		 rde_sig_handler(int sig, short, void *);
static __dead void	 rde_shutdown(void);
static void		 rde_dispatch_imsg(int, short, void *);
static void		 rde_dispatch_parent(int, short, void *);
static struct redistribute *eigrp_redistribute(struct eigrp *, struct kroute *);
static void		 rt_redist_set(struct kroute *, int);
static void		 rt_snap(struct rde_nbr *);
static struct ctl_rt	*rt_to_ctl(struct rt_node *, struct eigrp_route *);
static void		 rt_dump(struct ctl_show_topology_req *, pid_t);

struct eigrpd_conf	*rdeconf;

static struct imsgev	*iev_eigrpe;
static struct imsgev	*iev_main;

/* ARGSUSED */
static void
rde_sig_handler(int sig, short event, void *arg)
{
	/*
	 * signal handler rules don't apply, libevent decouples for us
	 */

	switch (sig) {
	case SIGINT:
	case SIGTERM:
		rde_shutdown();
		/* NOTREACHED */
	default:
		fatalx("unexpected signal");
	}
}

/* route decision engine */
void
rde(int debug, int verbose)
{
	struct event		 ev_sigint, ev_sigterm;
	struct timeval		 now;
	struct passwd		*pw;

	rdeconf = config_new_empty();

	log_init(debug);
	log_verbose(verbose);

	if ((pw = getpwnam(EIGRPD_USER)) == NULL)
		fatal("getpwnam");

	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	setproctitle("route decision engine");
	eigrpd_process = PROC_RDE_ENGINE;

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	if (pledge("stdio recvfd", NULL) == -1)
		fatal("pledge");

	event_init();

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, rde_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, rde_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	/* setup pipe and event handler to the parent process */
	if ((iev_main = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_main->ibuf, 3);
	iev_main->handler = rde_dispatch_parent;
	iev_main->events = EV_READ;
	event_set(&iev_main->ev, iev_main->ibuf.fd, iev_main->events,
	    iev_main->handler, iev_main);
	event_add(&iev_main->ev, NULL);

	gettimeofday(&now, NULL);
	global.uptime = now.tv_sec;

	event_dispatch();

	rde_shutdown();
}

static __dead void
rde_shutdown(void)
{
	/* close pipes */
	msgbuf_clear(&iev_eigrpe->ibuf.w);
	close(iev_eigrpe->ibuf.fd);
	msgbuf_clear(&iev_main->ibuf.w);
	close(iev_main->ibuf.fd);

	config_clear(rdeconf);

	free(iev_eigrpe);
	free(iev_main);

	log_info("route decision engine exiting");
	exit(0);
}

int
rde_imsg_compose_parent(int type, pid_t pid, void *data, uint16_t datalen)
{
	return (imsg_compose_event(iev_main, type, 0, pid, -1,
	    data, datalen));
}

int
rde_imsg_compose_eigrpe(int type, uint32_t peerid, pid_t pid, void *data,
    uint16_t datalen)
{
	return (imsg_compose_event(iev_eigrpe, type, peerid, pid, -1,
	    data, datalen));
}

/* ARGSUSED */
static void
rde_dispatch_imsg(int fd, short event, void *bula)
{
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	struct rde_nbr		*nbr;
	struct rde_nbr		 new;
	struct rinfo		 rinfo;
	ssize_t			 n;
	int			 shut = 0, verbose;

	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("rde_dispatch_imsg: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_NEIGHBOR_UP:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct rde_nbr))
				fatalx("invalid size of neighbor request");
			memcpy(&new, imsg.data, sizeof(new));

			if (rde_nbr_find(imsg.hdr.peerid))
				fatalx("rde_dispatch_imsg: "
				    "neighbor already exists");
			rde_nbr_new(imsg.hdr.peerid, &new);
			break;
		case IMSG_NEIGHBOR_DOWN:
			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL) {
				log_debug("%s: cannot find rde neighbor",
				    __func__);
				break;
			}

			rde_check_link_down_nbr(nbr);
			rde_flush_queries();
			rde_nbr_del(rde_nbr_find(imsg.hdr.peerid), 0);
			break;
		case IMSG_RECV_UPDATE_INIT:
			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL) {
				log_debug("%s: cannot find rde neighbor",
				    __func__);
				break;
			}

			rt_snap(nbr);
			break;
		case IMSG_RECV_UPDATE:
		case IMSG_RECV_QUERY:
		case IMSG_RECV_REPLY:
		case IMSG_RECV_SIAQUERY:
		case IMSG_RECV_SIAREPLY:
			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL) {
				log_debug("%s: cannot find rde neighbor",
				    __func__);
				break;
			}

			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(rinfo))
				fatalx("invalid size of rinfo");
			memcpy(&rinfo, imsg.data, sizeof(rinfo));

			switch (imsg.hdr.type) {
			case IMSG_RECV_UPDATE:
				rde_check_update(nbr, &rinfo);
				break;
			case IMSG_RECV_QUERY:
				rde_check_query(nbr, &rinfo, 0);
				break;
			case IMSG_RECV_REPLY:
				rde_check_reply(nbr, &rinfo, 0);
				break;
			case IMSG_RECV_SIAQUERY:
				rde_check_query(nbr, &rinfo, 1);
				break;
			case IMSG_RECV_SIAREPLY:
				rde_check_reply(nbr, &rinfo, 1);
				break;
			}
			break;
		case IMSG_CTL_SHOW_TOPOLOGY:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct ctl_show_topology_req)) {
				log_warnx("%s: wrong imsg len", __func__);
				break;
			}

			rt_dump(imsg.data, imsg.hdr.pid);
			rde_imsg_compose_eigrpe(IMSG_CTL_END, 0, imsg.hdr.pid,
			    NULL, 0);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			/* already checked by eigrpe */
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		default:
			log_debug("rde_dispatch_imsg: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
static void
rde_dispatch_parent(int fd, short event, void *bula)
{
	static struct eigrpd_conf *nconf;
	static struct iface	*niface;
	static struct eigrp	*neigrp;
	struct eigrp_iface	*nei;
	struct imsg		 imsg;
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf;
	struct kif		*kif;
	ssize_t			 n;
	int			 shut = 0;

	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("rde_dispatch_parent: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_IFDOWN:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct kif))
				fatalx("IFDOWN imsg with wrong len");
			kif = imsg.data;
			rde_check_link_down(kif->ifindex);
			break;
		case IMSG_NETWORK_ADD:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct kroute))
				fatalx("IMSG_NETWORK_ADD imsg with wrong len");
			rt_redist_set(imsg.data, 0);
			break;
		case IMSG_NETWORK_DEL:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct kroute))
				fatalx("IMSG_NETWORK_DEL imsg with wrong len");
			rt_redist_set(imsg.data, 1);
			break;
		case IMSG_SOCKET_IPC:
			if (iev_eigrpe) {
				log_warnx("%s: received unexpected imsg fd "
				    "to eigrpe", __func__);
				break;
			}
			if ((fd = imsg.fd) == -1) {
				log_warnx("%s: expected to receive imsg fd to "
				    "eigrpe but didn't receive any", __func__);
				break;
			}

			iev_eigrpe = malloc(sizeof(struct imsgev));
			if (iev_eigrpe == NULL)
				fatal(NULL);
			imsg_init(&iev_eigrpe->ibuf, fd);
			iev_eigrpe->handler = rde_dispatch_imsg;
			iev_eigrpe->events = EV_READ;
			event_set(&iev_eigrpe->ev, iev_eigrpe->ibuf.fd,
			    iev_eigrpe->events, iev_eigrpe->handler,
			    iev_eigrpe);
			event_add(&iev_eigrpe->ev, NULL);
			break;
		case IMSG_RECONF_CONF:
			if ((nconf = malloc(sizeof(struct eigrpd_conf))) ==
			    NULL)
				fatal(NULL);
			memcpy(nconf, imsg.data, sizeof(struct eigrpd_conf));

			TAILQ_INIT(&nconf->iface_list);
			TAILQ_INIT(&nconf->instances);
			break;
		case IMSG_RECONF_INSTANCE:
			if ((neigrp = malloc(sizeof(struct eigrp))) == NULL)
				fatal(NULL);
			memcpy(neigrp, imsg.data, sizeof(struct eigrp));

			SIMPLEQ_INIT(&neigrp->redist_list);
			TAILQ_INIT(&neigrp->ei_list);
			RB_INIT(&neigrp->nbrs);
			RB_INIT(&neigrp->topology);
			TAILQ_INSERT_TAIL(&nconf->instances, neigrp, entry);
			break;
		case IMSG_RECONF_IFACE:
			niface = imsg.data;
			niface = if_lookup(nconf, niface->ifindex);
			if (niface)
				break;

			if ((niface = malloc(sizeof(struct iface))) == NULL)
				fatal(NULL);
			memcpy(niface, imsg.data, sizeof(struct iface));

			TAILQ_INIT(&niface->ei_list);
			TAILQ_INIT(&niface->addr_list);
			TAILQ_INSERT_TAIL(&nconf->iface_list, niface, entry);
			break;
		case IMSG_RECONF_EIGRP_IFACE:
			if (niface == NULL)
				break;
			if ((nei = malloc(sizeof(struct eigrp_iface))) == NULL)
				fatal(NULL);
			memcpy(nei, imsg.data, sizeof(struct eigrp_iface));

			nei->iface = niface;
			nei->eigrp = neigrp;
			TAILQ_INIT(&nei->nbr_list);
			TAILQ_INIT(&nei->update_list);
			TAILQ_INIT(&nei->query_list);
			TAILQ_INIT(&nei->summary_list);
			TAILQ_INSERT_TAIL(&niface->ei_list, nei, i_entry);
			TAILQ_INSERT_TAIL(&neigrp->ei_list, nei, e_entry);
			if (RB_INSERT(iface_id_head, &ifaces_by_id, nei) !=
			    NULL)
				fatalx("rde_dispatch_parent: "
				    "RB_INSERT(ifaces_by_id) failed");
			break;
		case IMSG_RECONF_END:
			merge_config(rdeconf, nconf);
			nconf = NULL;
			break;
		default:
			log_debug("%s: unexpected imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
rde_instance_init(struct eigrp *eigrp)
{
	struct rde_nbr		 nbr;

	memset(&nbr, 0, sizeof(nbr));
	nbr.flags = F_RDE_NBR_SELF | F_RDE_NBR_REDIST;
	eigrp->rnbr_redist = rde_nbr_new(NBR_IDSELF, &nbr);
	eigrp->rnbr_redist->eigrp = eigrp;
	nbr.flags = F_RDE_NBR_SELF | F_RDE_NBR_SUMMARY;
	eigrp->rnbr_summary = rde_nbr_new(NBR_IDSELF, &nbr);
	eigrp->rnbr_summary->eigrp = eigrp;
}

void
rde_instance_del(struct eigrp *eigrp)
{
	struct rde_nbr		*nbr, *safe;
	struct rt_node		*rn;

	/* clear topology */
	while((rn = RB_MIN(rt_tree, &eigrp->topology)) != NULL)
		rt_del(rn);

	/* clear nbrs */
	RB_FOREACH_SAFE(nbr, rde_nbr_head, &rde_nbrs, safe)
		if (nbr->eigrp == eigrp)
			rde_nbr_del(nbr, 0);
	rde_nbr_del(eigrp->rnbr_redist, 0);
	rde_nbr_del(eigrp->rnbr_summary, 0);

	free(eigrp);
}

void
rde_send_change_kroute(struct rt_node *rn, struct eigrp_route *route)
{
	struct eigrp	*eigrp = route->nbr->eigrp;
	struct kroute	 kr;
	struct in6_addr	 lo6 = IN6ADDR_LOOPBACK_INIT;

	log_debug("%s: %s nbr %s", __func__, log_prefix(rn),
	    log_addr(eigrp->af, &route->nbr->addr));

	memset(&kr, 0, sizeof(kr));
	kr.af = eigrp->af;
	kr.prefix = rn->prefix;
	kr.prefixlen = rn->prefixlen;
	if (route->nbr->ei) {
		kr.nexthop = route->nexthop;
		kr.ifindex = route->nbr->ei->iface->ifindex;
	} else {
		switch (eigrp->af) {
		case AF_INET:
			kr.nexthop.v4.s_addr = htonl(INADDR_LOOPBACK);
			break;
		case AF_INET6:
			kr.nexthop.v6 = lo6;
			break;
		default:
			fatalx("rde_send_delete_kroute: unknown af");
			break;
		}
		kr.flags = F_BLACKHOLE;
	}
	if (route->type == EIGRP_ROUTE_EXTERNAL)
		kr.priority = rdeconf->fib_priority_external;
	else {
		if (route->nbr->flags & F_RDE_NBR_SUMMARY)
			kr.priority = rdeconf->fib_priority_summary;
		else
			kr.priority = rdeconf->fib_priority_internal;
	}

	rde_imsg_compose_parent(IMSG_KROUTE_CHANGE, 0, &kr, sizeof(kr));

	route->flags |= F_EIGRP_ROUTE_INSTALLED;
}

void
rde_send_delete_kroute(struct rt_node *rn, struct eigrp_route *route)
{
	struct eigrp	*eigrp = route->nbr->eigrp;
	struct kroute	 kr;
	struct in6_addr	 lo6 = IN6ADDR_LOOPBACK_INIT;

	log_debug("%s: %s nbr %s", __func__, log_prefix(rn),
	    log_addr(eigrp->af, &route->nbr->addr));

	memset(&kr, 0, sizeof(kr));
	kr.af = eigrp->af;
	kr.prefix = rn->prefix;
	kr.prefixlen = rn->prefixlen;
	if (route->nbr->ei) {
		kr.nexthop = route->nexthop;
		kr.ifindex = route->nbr->ei->iface->ifindex;
	} else {
		switch (eigrp->af) {
		case AF_INET:
			kr.nexthop.v4.s_addr = htonl(INADDR_LOOPBACK);
			break;
		case AF_INET6:
			kr.nexthop.v6 = lo6;
			break;
		default:
			fatalx("rde_send_delete_kroute: unknown af");
			break;
		}
		kr.flags = F_BLACKHOLE;
	}
	if (route->type == EIGRP_ROUTE_EXTERNAL)
		kr.priority = rdeconf->fib_priority_external;
	else {
		if (route->nbr->flags & F_RDE_NBR_SUMMARY)
			kr.priority = rdeconf->fib_priority_summary;
		else
			kr.priority = rdeconf->fib_priority_internal;
	}

	rde_imsg_compose_parent(IMSG_KROUTE_DELETE, 0, &kr, sizeof(kr));

	route->flags &= ~F_EIGRP_ROUTE_INSTALLED;
}

static struct redistribute *
eigrp_redistribute(struct eigrp *eigrp, struct kroute *kr)
{
	struct redistribute	*r;
	uint8_t			 is_default = 0;
	union eigrpd_addr	 addr;

	/* only allow the default route via REDIST_DEFAULT */
	if (!eigrp_addrisset(kr->af, &kr->prefix) && kr->prefixlen == 0)
		is_default = 1;

	SIMPLEQ_FOREACH(r, &eigrp->redist_list, entry) {
		switch (r->type & ~REDIST_NO) {
		case REDIST_STATIC:
			if (is_default)
				continue;
			if (kr->flags & F_STATIC)
				return (r->type & REDIST_NO ? NULL : r);
			break;
		case REDIST_RIP:
			if (is_default)
				continue;
			if (kr->priority == RTP_RIP)
				return (r->type & REDIST_NO ? NULL : r);
			break;
		case REDIST_OSPF:
			if (is_default)
				continue;
			if (kr->priority == RTP_OSPF)
				return (r->type & REDIST_NO ? NULL : r);
			break;
		case REDIST_CONNECTED:
			if (is_default)
				continue;
			if (kr->flags & F_CONNECTED)
				return (r->type & REDIST_NO ? NULL : r);
			break;
		case REDIST_ADDR:
			if (eigrp_addrisset(r->af, &r->addr) &&
			    r->prefixlen == 0) {
				if (is_default)
					return (r->type & REDIST_NO ? NULL : r);
				else
					return (0);
			}

			eigrp_applymask(kr->af, &addr, &kr->prefix,
			    r->prefixlen);
			if (eigrp_addrcmp(kr->af, &addr, &r->addr) == 0 &&
			    kr->prefixlen >= r->prefixlen)
				return (r->type & REDIST_NO ? NULL : r);
			break;
		case REDIST_DEFAULT:
			if (is_default)
				return (r->type & REDIST_NO ? NULL : r);
			break;
		}
	}

	return (NULL);
}

static void
rt_redist_set(struct kroute *kr, int withdraw)
{
	struct eigrp		*eigrp;
	struct redistribute	*r;
	struct redist_metric	*rmetric;
	struct rinfo		 ri;

	TAILQ_FOREACH(eigrp, &rdeconf->instances, entry) {
		if (eigrp->af != kr->af)
			continue;

		r = eigrp_redistribute(eigrp, kr);
		if (r == NULL)
			continue;

		if (r->metric)
			rmetric = r->metric;
		else if (eigrp->dflt_metric)
			rmetric = eigrp->dflt_metric;
		else
			continue;

		memset(&ri, 0, sizeof(ri));
		ri.af = kr->af;
		ri.type = EIGRP_ROUTE_EXTERNAL;
		ri.prefix = kr->prefix;
		ri.prefixlen = kr->prefixlen;

		/* metric */
		if (withdraw)
			ri.metric.delay = EIGRP_INFINITE_METRIC;
		else
			ri.metric.delay = eigrp_composite_delay(rmetric->delay);
		ri.metric.bandwidth =
		    eigrp_composite_bandwidth(rmetric->bandwidth);
		metric_encode_mtu(ri.metric.mtu, rmetric->mtu);
		ri.metric.hop_count = 0;
		ri.metric.reliability = rmetric->reliability;
		ri.metric.load = rmetric->load;
		ri.metric.tag = 0;
		ri.metric.flags = 0;

		/* external metric */
		ri.emetric.routerid = htonl(rdeconf->rtr_id.s_addr);
		ri.emetric.as = r->emetric.as;
		ri.emetric.tag = r->emetric.tag;
		ri.emetric.metric = r->emetric.metric;
		if (kr->priority == rdeconf->fib_priority_internal)
			ri.emetric.protocol = EIGRP_EXT_PROTO_EIGRP;
		else if (kr->priority == RTP_STATIC)
			ri.emetric.protocol = EIGRP_EXT_PROTO_STATIC;
		else if (kr->priority == RTP_RIP)
			ri.emetric.protocol = EIGRP_EXT_PROTO_RIP;
		else if (kr->priority == RTP_OSPF)
			ri.emetric.protocol = EIGRP_EXT_PROTO_OSPF;
		else
			ri.emetric.protocol = EIGRP_EXT_PROTO_CONN;
		ri.emetric.flags = 0;

		rde_check_update(eigrp->rnbr_redist, &ri);
	}
}

void
rt_summary_set(struct eigrp *eigrp, struct summary_addr *summary,
    struct classic_metric *metric)
{
	struct rinfo		 ri;

	memset(&ri, 0, sizeof(ri));
	ri.af = eigrp->af;
	ri.type = EIGRP_ROUTE_INTERNAL;
	ri.prefix = summary->prefix;
	ri.prefixlen = summary->prefixlen;
	ri.metric = *metric;

	rde_check_update(eigrp->rnbr_summary, &ri);
}

/* send all known routing information to new neighbor */
static void
rt_snap(struct rde_nbr *nbr)
{
	struct eigrp		*eigrp = nbr->eigrp;
	struct rt_node		*rn;
	struct rinfo		 ri;

	RB_FOREACH(rn, rt_tree, &eigrp->topology)
		if (rn->state == DUAL_STA_PASSIVE &&
		    !rde_summary_check(nbr->ei, &rn->prefix, rn->prefixlen)) {
			rinfo_fill_successor(rn, &ri);
			rde_imsg_compose_eigrpe(IMSG_SEND_UPDATE,
			    nbr->peerid, 0, &ri, sizeof(ri));
		}

	rde_imsg_compose_eigrpe(IMSG_SEND_UPDATE_END, nbr->peerid, 0,
	    NULL, 0);
}

static struct ctl_rt *
rt_to_ctl(struct rt_node *rn, struct eigrp_route *route)
{
	static struct ctl_rt	 rtctl;

	memset(&rtctl, 0, sizeof(rtctl));
	rtctl.af = route->nbr->eigrp->af;
	rtctl.as = route->nbr->eigrp->as;
	rtctl.prefix = rn->prefix;
	rtctl.prefixlen = rn->prefixlen;
	rtctl.type = route->type;
	rtctl.nexthop = route->nexthop;
	if (route->nbr->flags & F_RDE_NBR_REDIST)
		strlcpy(rtctl.ifname, "redistribute", sizeof(rtctl.ifname));
	else if (route->nbr->flags & F_RDE_NBR_SUMMARY)
		strlcpy(rtctl.ifname, "summary", sizeof(rtctl.ifname));
	else
		memcpy(rtctl.ifname, route->nbr->ei->iface->name,
		    sizeof(rtctl.ifname));
	rtctl.distance = route->distance;
	rtctl.rdistance = route->rdistance;
	rtctl.fdistance = rn->successor.fdistance;
	rtctl.state = rn->state;
	/* metric */
	rtctl.metric.delay = eigrp_real_delay(route->metric.delay);
	/* translate to microseconds */
	rtctl.metric.delay *= 10;
	rtctl.metric.bandwidth = eigrp_real_bandwidth(route->metric.bandwidth);
	rtctl.metric.mtu = metric_decode_mtu(route->metric.mtu);
	rtctl.metric.hop_count = route->metric.hop_count;
	rtctl.metric.reliability = route->metric.reliability;
	rtctl.metric.load = route->metric.load;
	/* external metric */
	rtctl.emetric = route->emetric;

	if (route->nbr == rn->successor.nbr)
		rtctl.flags |= F_CTL_RT_SUCCESSOR;
	else if (route->rdistance < rn->successor.fdistance)
		rtctl.flags |= F_CTL_RT_FSUCCESSOR;

	return (&rtctl);
}

static void
rt_dump(struct ctl_show_topology_req *treq, pid_t pid)
{
	struct eigrp		*eigrp;
	struct rt_node		*rn;
	struct eigrp_route	*route;
	struct ctl_rt		*rtctl;
	int			 first = 1;

	TAILQ_FOREACH(eigrp, &rdeconf->instances, entry) {
		RB_FOREACH(rn, rt_tree, &eigrp->topology) {
			if (eigrp_addrisset(treq->af, &treq->prefix) &&
			    eigrp_addrcmp(treq->af, &treq->prefix,
			    &rn->prefix))
				continue;

			if (treq->prefixlen &&
			    (treq->prefixlen != rn->prefixlen))
				continue;

			first = 1;
			TAILQ_FOREACH(route, &rn->routes, entry) {
				if (treq->flags & F_CTL_ACTIVE &&
				    !(rn->state & DUAL_STA_ACTIVE_ALL))
					continue;
				if (!(treq->flags & F_CTL_ALLLINKS) &&
				    route->rdistance >= rn->successor.fdistance)
					continue;

				rtctl = rt_to_ctl(rn, route);
				if (first) {
					rtctl->flags |= F_CTL_RT_FIRST;
					first = 0;
				}
				rde_imsg_compose_eigrpe(IMSG_CTL_SHOW_TOPOLOGY,
				    0, pid, rtctl, sizeof(*rtctl));
			}
		}
	}
}
@


1.22
log
@Make functions and variables static whenever possible.

style(9) says:
"Function prototypes for private functions (i.e., functions not used
elsewhere) go at the top of the first source module. In userland,
functions local to one source module should be declared 'static'".

The benefits of doing so include:
* clean up of the eigrpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Additional changes:
* Declare all extern variables in header files;
* Clean up the indentation of all function prototypes and global
  variables.

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.21 2016/09/02 16:39:44 renato Exp $ */
d72 1
a72 1
pid_t
a128 3
	/* NOTREACHED */

	return (0);
@


1.21
log
@Use static local variables instead of global variables whenever possible.

Also, there's no need to zero initialize global and static variables,
that's done automatically by the compiler.

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.20 2016/09/02 16:29:55 renato Exp $ */
d38 9
a46 4
void		 rde_sig_handler(int sig, short, void *);
__dead void	 rde_shutdown(void);
void		 rde_dispatch_imsg(int, short, void *);
void		 rde_dispatch_parent(int, short, void *);
a48 2
struct imsgev		*iev_eigrpe;
struct imsgev		*iev_main;
d50 2
a51 7
extern struct iface_id_head ifaces_by_id;
RB_PROTOTYPE(iface_id_head, eigrp_iface, id_tree, iface_id_compare)

RB_PROTOTYPE(rt_tree, rt_node, entry, rt_compare)

extern struct rde_nbr_head rde_nbrs;
RB_PROTOTYPE(rde_nbr_head, rde_nbr, entry, rde_nbr_compare)
d54 1
a54 1
void
d134 1
a134 1
__dead void
d168 1
a168 1
void
d302 1
a302 1
void
d640 1
a640 1
void
d684 1
a684 1
		ri.emetric.routerid = htonl(eigrp_router_id(rdeconf));
d721 1
a721 1
void
d740 1
a740 1
struct ctl_rt *
d783 1
a783 1
void
@


1.20
log
@Remove superfluous includes and follow style(9).

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.19 2016/09/02 16:23:50 renato Exp $ */
d43 1
a43 1
struct eigrpd_conf	*rdeconf = NULL, *nconf;
d307 2
a308 1
	static struct iface	*niface = NULL;
@


1.19
log
@Fix broken pipe teardown.

* Add missing close() calls to actually close the pipes, calling just
  msgbuf_clean() is not enough;
* Bring back some NOTREACHED lint comments. style(9) says they can be
  removed but in some cases they are useful to humans too;
* Add __dead to the shutdown functions;
* Some other minor changes to make eigrpd(8) more similar to the other
  routing daemons.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.18 2016/08/08 16:48:53 renato Exp $ */
d22 4
a25 3
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
d27 1
d29 1
d31 1
a31 1
#include <pwd.h>
a32 1
#include "eigrp.h"
d35 1
a36 1
#include "rde.h"
@


1.18
log
@rde and eigrpe should use exit(3) instead of _exit(2)

Since recently these processes call exec() after fork(), so they should
stop using _exit(2) and use exit(3) instead when shutting down.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.17 2016/06/05 03:36:41 renato Exp $ */
d37 1
a37 1
void		 rde_shutdown(void);
d134 1
a134 1
void
d137 6
a144 1
	msgbuf_clear(&iev_eigrpe->ibuf.w);
a145 1
	msgbuf_clear(&iev_main->ibuf.w);
@


1.17
log
@Improve security by calling exec after fork.

For each child process (rde and eigrpe), re-exec eigrpd with a special
"per-role" getopt flag. This way we have seperate ASLR/cookies per
process.

Based on a similar patch for bgpd, from claudio@@

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.16 2016/05/12 00:15:24 renato Exp $ */
d145 1
a145 1
	_exit(0);
@


1.16
log
@Improve support for config reloading.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.15 2016/04/18 13:14:27 renato Exp $ */
d73 1
a73 2
rde(struct eigrpd_conf *xconf, int pipe_parent2rde[2], int pipe_eigrpe2rde[2],
    int pipe_parent2eigrpe[2])
a77 2
	pid_t			 pid;
	struct eigrp		*eigrp;
d79 1
a79 9
	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
		/* NOTREACHED */
	case 0:
		break;
	default:
		return (pid);
	}
d81 2
a82 1
	rdeconf = xconf;
d100 1
a100 1
	if (pledge("stdio", NULL) == -1)
d113 2
a114 8
	/* setup pipes */
	close(pipe_eigrpe2rde[0]);
	close(pipe_parent2rde[0]);
	close(pipe_parent2eigrpe[0]);
	close(pipe_parent2eigrpe[1]);

	if ((iev_eigrpe = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_main = malloc(sizeof(struct imsgev))) == NULL)
d116 1
a116 3
	imsg_init(&iev_eigrpe->ibuf, pipe_eigrpe2rde[1]);
	iev_eigrpe->handler = rde_dispatch_imsg;
	imsg_init(&iev_main->ibuf, pipe_parent2rde[1]);
a117 7

	/* setup event handler */
	iev_eigrpe->events = EV_READ;
	event_set(&iev_eigrpe->ev, iev_eigrpe->ibuf.fd, iev_eigrpe->events,
	    iev_eigrpe->handler, iev_eigrpe);
	event_add(&iev_eigrpe->ev, NULL);

a125 3
	TAILQ_FOREACH(eigrp, &rdeconf->instances, entry)
		rde_instance_init(eigrp);

d351 23
@


1.15
log
@Revert previous commit.

When a process receives an EOF on a socketpair, it removes the event
handler for that fd and then calls event_loopexit(). Once the process
leaves the main loop, it calls its shutdown function. With that said,
revert the previous patch because it was unnecessary.

Pointed out and ok by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.14 2016/04/15 13:31:03 renato Exp $ */
d329 1
a329 1
	struct iface		*niface = NULL;
@


1.14
log
@Kill the child processes if their parent dies unexpectedly.

There's no point on keeping eigrpd running if any of its processes
dies unexpectedly.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.13 2016/04/15 13:27:58 renato Exp $ */
d318 5
a322 2
	else
		rde_shutdown();
d447 5
a451 2
	else
		rde_shutdown();
@


1.13
log
@Fix segfault on reloading the config multiple times.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.12 2016/04/15 13:21:45 renato Exp $ */
d318 2
a319 5
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
d444 2
a445 5
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
@


1.12
log
@Move several other variables out of eigrpd_conf.

Now eigrpd_conf contains only variables that can be modified via a
config reload. The other variables were moved to a new struct called
eigrpd_global, which is now a central point for storing global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.11 2016/02/21 18:56:49 renato Exp $ */
d410 1
@


1.11
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.10 2016/01/15 12:52:49 renato Exp $ */
d149 1
a149 1
	rdeconf->uptime = now.tv_sec;
@


1.10
log
@Better handle explicit nexthops.

If an explicit nexthop was advertised for a route, show it in the
'eigrpctl show topology' command output instead of the address of the
advertising neighbor (implicit nexthop).
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.9 2016/01/15 12:25:43 renato Exp $ */
d499 1
a499 1
	memcpy(&kr.prefix, &rn->prefix, sizeof(kr.prefix));
d502 1
a502 1
		memcpy(&kr.nexthop, &route->nexthop, sizeof(kr.nexthop));
d510 1
a510 1
			memcpy(&kr.nexthop.v6, &lo6, sizeof(kr.nexthop.v6));
d544 1
a544 1
	memcpy(&kr.prefix, &rn->prefix, sizeof(kr.prefix));
d547 1
a547 1
		memcpy(&kr.nexthop, &route->nexthop, sizeof(kr.nexthop));
d555 1
a555 1
			memcpy(&kr.nexthop.v6, &lo6, sizeof(kr.nexthop.v6));
d665 1
a665 1
		memcpy(&ri.prefix, &kr->prefix, sizeof(ri.prefix));
d712 1
a712 1
	memcpy(&ri.prefix, &summary->prefix, sizeof(ri.prefix));
d714 1
a714 1
	memcpy(&ri.metric, metric, sizeof(ri.metric));
d747 1
a747 1
	memcpy(&rtctl.prefix, &rn->prefix, sizeof(rtctl.prefix));
d750 1
a750 1
	memcpy(&rtctl.nexthop, &route->nexthop, sizeof(rtctl.nexthop));
d772 1
a772 1
	memcpy(&rtctl.emetric, &route->emetric, sizeof(rtctl.emetric));
@


1.9
log
@Avoid the use of inet_pton() whenever possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.8 2015/12/05 15:49:01 claudio Exp $ */
d501 1
a501 1
	if (eigrp_addrisset(eigrp->af, &route->nexthop))
a502 3
	else
		memcpy(&kr.nexthop, &route->nbr->addr, sizeof(kr.nexthop));
	if (route->nbr->ei)
d504 1
a504 1
	else {
d546 1
a546 1
	if (eigrp_addrisset(eigrp->af, &route->nexthop))
a547 3
	else
		memcpy(&kr.nexthop, &route->nbr->addr, sizeof(kr.nexthop));
	if (route->nbr->ei)
d549 1
a549 1
	else {
d750 1
a750 1
	memcpy(&rtctl.nexthop, &route->nbr->addr, sizeof(rtctl.nexthop));
@


1.8
log
@Forgot about eigrp when doing the imsg_read EAGAIN fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.7 2015/10/27 03:27:35 renato Exp $ */
d492 1
d510 1
a510 1
			inet_pton(AF_INET, "127.0.0.1", &kr.nexthop.v4);
d513 1
a513 1
			inet_pton(AF_INET, "::1", &kr.nexthop.v6);
d540 1
d558 1
a558 1
			inet_pton(AF_INET, "127.0.0.1", &kr.nexthop.v4);
d561 1
a561 1
			inet_pton(AF_INET, "::1", &kr.nexthop.v6);
@


1.7
log
@Whenever a summary route is activated, install a respective blackhole
route in the FIB.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.6 2015/10/21 03:52:12 renato Exp $ */
d207 1
a207 1
		if ((n = imsg_read(ibuf)) == -1)
d221 1
a221 1
			fatal("rde_dispatch_imsg: imsg_read error");
d342 1
a342 1
		if ((n = imsg_read(ibuf)) == -1)
d356 1
a356 1
			fatal("rde_dispatch_parent: imsg_read error");
@


1.6
log
@Add support for route summarization.

Working great but need more testing, especially with ipv6. For now
we don't validate if one configured summary is inside another or the
presence of duplicates. Will address these issues in a future commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.5 2015/10/21 03:48:09 renato Exp $ */
d504 16
a519 1
	kr.ifindex = route->nbr->ei->iface->ifindex;
d522 6
a527 2
	else
		kr.priority = rdeconf->fib_priority_internal;
d551 16
a566 1
	kr.ifindex = route->nbr->ei->iface->ifindex;
d569 6
a574 2
	else
		kr.priority = rdeconf->fib_priority_internal;
@


1.5
log
@Minor fixes and code cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.4 2015/10/10 05:12:33 renato Exp $ */
d425 1
d669 16
d694 2
a695 1
		if (rn->state == DUAL_STA_PASSIVE) {
@


1.4
log
@Make use of pledge(2).

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.3 2015/10/05 01:59:33 renato Exp $ */
d455 1
a455 1
	struct rde_nbr		nbr;
@


1.3
log
@When the SIA state is declared for a given destination, reset the
adjacency with the unresponsive neighbor(s).
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.2 2015/10/04 23:00:10 renato Exp $ */
d109 3
@


1.2
log
@Fix warnings and add safeguards to protect against corrupted data.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.1 2015/10/02 04:26:47 renato Exp $ */
d244 1
a244 1
			rde_nbr_del(rde_nbr_find(imsg.hdr.peerid));
d476 3
a478 3
			rde_nbr_del(nbr);
	rde_nbr_del(eigrp->rnbr_redist);
	rde_nbr_del(eigrp->rnbr_summary);
@


1.1
log
@Welcome eigrpd

The eigrpd daemon will support the Enhanced Interior Gateway Routing Protocol.

Built using the imsg/three process framework and heavily based on ospfd(8), ospf6d(8) and ldpd(8).

The current status of eigrpd(8) is as follows:
* Almost full compliance with the specification: DUAL FSM, RTP, CR mode, SIA, etc
* Support for both IPv4 and IPv6
* Support for multiple instances (different ASes/AFs) within the same process
* Support for rdomains (one process per rdomain)
* RIB/FIB synchronization
* Basic redistribution support

Not implemented features (yet):
* Configuration reload support (partially implemented)
* Route summarization
* Advanced route redistribution/filtering
* Carp integration
* Authentication (draft is missing information)
* Stub (not released by Cisco)

Not yet connected to the builds.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d326 1
a326 1
	struct iface		*niface;
d411 2
@

