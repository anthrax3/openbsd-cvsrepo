head	1.9;
access;
symbols
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7;
locks; strict;
comment	@ * @;


1.9
date	2016.09.02.16.36.33;	author renato;	state Exp;
branches;
next	1.8;
commitid	RP73Rgb2x0oQ1Vfz;

1.8
date	2016.09.02.16.29.55;	author renato;	state Exp;
branches;
next	1.7;
commitid	w1am8mhLiSfZo4x6;

1.7
date	2016.02.21.18.53.54;	author renato;	state Exp;
branches;
next	1.6;
commitid	wQY3qMWTuqWqk9Cy;

1.6
date	2016.02.21.18.52.00;	author renato;	state Exp;
branches;
next	1.5;
commitid	g6ugST8MGfTEZDk1;

1.5
date	2016.02.21.18.40.56;	author renato;	state Exp;
branches;
next	1.4;
commitid	kZCMT2snnUUUOEjb;

1.4
date	2016.01.15.12.41.09;	author renato;	state Exp;
branches;
next	1.3;
commitid	mZmD6DNRylxiI3gq;

1.3
date	2015.10.21.03.52.12;	author renato;	state Exp;
branches;
next	1.2;
commitid	67lIWG5WR4Do3HhB;

1.2
date	2015.10.04.23.00.10;	author renato;	state Exp;
branches;
next	1.1;
commitid	vb2pR0BnPuOhwW09;

1.1
date	2015.10.02.04.26.47;	author renato;	state Exp;
branches;
next	;
commitid	dGX9Xs9GfneSNaca;


desc
@@


1.9
log
@Merge the recv_packet_v[46] functions into one.

This reduces some code duplication and makes it easier to see the
difference between the IPv4 and IPv6 raw sockets API.

tweak + ok claudio@@, ok benno@@
@
text
@/*	$OpenBSD: util.c,v 1.8 2016/09/02 16:29:55 renato Exp $ */

/*
 * Copyright (c) 2015 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2012 Alexander Bluhm <bluhm@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <string.h>

#include "eigrpd.h"
#include "log.h"

uint8_t
mask2prefixlen(in_addr_t ina)
{
	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
}

uint8_t
mask2prefixlen6(struct sockaddr_in6 *sa_in6)
{
	uint8_t	l = 0, *ap, *ep;

	/*
	 * sin6_len is the size of the sockaddr so substract the offset of
	 * the possibly truncated sin6_addr struct.
	 */
	ap = (uint8_t *)&sa_in6->sin6_addr;
	ep = (uint8_t *)sa_in6 + sa_in6->sin6_len;
	for (; ap < ep; ap++) {
		/* this "beauty" is adopted from sbin/route/show.c ... */
		switch (*ap) {
		case 0xff:
			l += 8;
			break;
		case 0xfe:
			l += 7;
			return (l);
		case 0xfc:
			l += 6;
			return (l);
		case 0xf8:
			l += 5;
			return (l);
		case 0xf0:
			l += 4;
			return (l);
		case 0xe0:
			l += 3;
			return (l);
		case 0xc0:
			l += 2;
			return (l);
		case 0x80:
			l += 1;
			return (l);
		case 0x00:
			return (l);
		default:
			fatalx("non contiguous inet6 netmask");
		}
	}

	return (l);
}

in_addr_t
prefixlen2mask(uint8_t prefixlen)
{
	if (prefixlen == 0)
		return (0);

	return (htonl(0xffffffff << (32 - prefixlen)));
}

struct in6_addr *
prefixlen2mask6(uint8_t prefixlen)
{
	static struct in6_addr	mask;
	int			i;

	memset(&mask, 0, sizeof(mask));
	for (i = 0; i < prefixlen / 8; i++)
		mask.s6_addr[i] = 0xff;
	i = prefixlen % 8;
	if (i)
		mask.s6_addr[prefixlen / 8] = 0xff00 >> i;

	return (&mask);
}

void
eigrp_applymask(int af, union eigrpd_addr *dest, const union eigrpd_addr *src,
    int prefixlen)
{
	struct in6_addr	mask;
	int		i;

	switch (af) {
	case AF_INET:
		dest->v4.s_addr = src->v4.s_addr & prefixlen2mask(prefixlen);
		break;
	case AF_INET6:
		memset(&mask, 0, sizeof(mask));
		for (i = 0; i < prefixlen / 8; i++)
			mask.s6_addr[i] = 0xff;
		i = prefixlen % 8;
		if (i)
			mask.s6_addr[prefixlen / 8] = 0xff00 >> i;

		for (i = 0; i < 16; i++)
			dest->v6.s6_addr[i] = src->v6.s6_addr[i] &
			    mask.s6_addr[i];
		break;
	default:
		fatalx("eigrp_applymask: unknown af");
	}
}

int
eigrp_addrcmp(int af, const union eigrpd_addr *a, const union eigrpd_addr *b)
{
	switch (af) {
	case AF_INET:
		if (a->v4.s_addr == b->v4.s_addr)
			return (0);
		return ((ntohl(a->v4.s_addr) > ntohl(b->v4.s_addr)) ? 1 : -1);
	case AF_INET6:
		return (!!memcmp(&a->v6, &b->v6, sizeof(struct in6_addr)));
	default:
		fatalx("eigrp_addrcmp: unknown af");
	}
}

int
eigrp_addrisset(int af, const union eigrpd_addr *addr)
{
	switch (af) {
	case AF_UNSPEC:
		return (0);
	case AF_INET:
		if (addr->v4.s_addr != INADDR_ANY)
			return (1);
		break;
	case AF_INET6:
		if (!IN6_IS_ADDR_UNSPECIFIED(&addr->v6))
			return (1);
		break;
	default:
		fatalx("eigrp_addrisset: unknown af");
	}

	return (0);
}

int
eigrp_prefixcmp(int af, const union eigrpd_addr *a, const union eigrpd_addr *b,
    uint8_t prefixlen)
{
	in_addr_t	mask, aa, ba;
	int		i;
	uint8_t		m;

	switch (af) {
	case AF_INET:
		if (prefixlen == 0)
			return (0);
		if (prefixlen > 32)
			fatalx("eigrp_prefixcmp: bad IPv4 prefixlen");
		mask = htonl(prefixlen2mask(prefixlen));
		aa = htonl(a->v4.s_addr) & mask;
		ba = htonl(b->v4.s_addr) & mask;
		return (aa - ba);
	case AF_INET6:
		if (prefixlen == 0)
			return (0);
		if (prefixlen > 128)
			fatalx("eigrp_prefixcmp: bad IPv6 prefixlen");
		for (i = 0; i < prefixlen / 8; i++)
			if (a->v6.s6_addr[i] != b->v6.s6_addr[i])
				return (a->v6.s6_addr[i] - b->v6.s6_addr[i]);
		i = prefixlen % 8;
		if (i) {
			m = 0xff00 >> i;
			if ((a->v6.s6_addr[prefixlen / 8] & m) !=
			    (b->v6.s6_addr[prefixlen / 8] & m))
				return ((a->v6.s6_addr[prefixlen / 8] & m) -
				    (b->v6.s6_addr[prefixlen / 8] & m));
		}
		return (0);
	default:
		fatalx("eigrp_prefixcmp: unknown af");
	}
	return (-1);
}

int
bad_addr_v4(struct in_addr addr)
{
	uint32_t	 a = ntohl(addr.s_addr);

	if (((a >> IN_CLASSA_NSHIFT) == 0) ||
	    ((a >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET) ||
	    IN_MULTICAST(a) || IN_BADCLASS(a))
		return (1);

	return (0);
}

int
bad_addr_v6(struct in6_addr *addr)
{
	if (IN6_IS_ADDR_UNSPECIFIED(addr) ||
	    IN6_IS_ADDR_LOOPBACK(addr) ||
	    IN6_IS_ADDR_MULTICAST(addr) ||
	    IN6_IS_ADDR_SITELOCAL(addr) ||
	    IN6_IS_ADDR_V4MAPPED(addr) ||
	    IN6_IS_ADDR_V4COMPAT(addr))
		return (1);

	return (0);
}

int
bad_addr(int af, union eigrpd_addr *addr)
{
	switch (af) {
	case AF_INET:
		return (bad_addr_v4(addr->v4));
	case AF_INET6:
		return (bad_addr_v6(&addr->v6));
	default:
		fatalx("bad_addr: unknown af");
	}
}

void
embedscope(struct sockaddr_in6 *sin6)
{
	uint16_t	 tmp16;

	if (IN6_IS_SCOPE_EMBED(&sin6->sin6_addr)) {
		memcpy(&tmp16, &sin6->sin6_addr.s6_addr[2], sizeof(tmp16));
		if (tmp16 != 0) {
			log_warnx("%s: address %s already has embeded scope %u",
			    __func__, log_sockaddr(sin6), ntohs(tmp16));
		}
		tmp16 = htons(sin6->sin6_scope_id);
		memcpy(&sin6->sin6_addr.s6_addr[2], &tmp16, sizeof(tmp16));
		sin6->sin6_scope_id = 0;
	}
}

void
recoverscope(struct sockaddr_in6 *sin6)
{
	uint16_t	 tmp16;

	if (sin6->sin6_scope_id != 0)
		log_warnx("%s: address %s already has scope id %u",
		    __func__, log_sockaddr(sin6), sin6->sin6_scope_id);

	if (IN6_IS_SCOPE_EMBED(&sin6->sin6_addr)) {
		memcpy(&tmp16, &sin6->sin6_addr.s6_addr[2], sizeof(tmp16));
		sin6->sin6_scope_id = ntohs(tmp16);
		sin6->sin6_addr.s6_addr[2] = 0;
		sin6->sin6_addr.s6_addr[3] = 0;
	}
}

void
addscope(struct sockaddr_in6 *sin6, uint32_t id)
{
	if (sin6->sin6_scope_id != 0)
		log_warnx("%s: address %s already has scope id %u", __func__,
		    log_sockaddr(sin6), sin6->sin6_scope_id);

	if (IN6_IS_SCOPE_EMBED(&sin6->sin6_addr))
		sin6->sin6_scope_id = id;
}

void
clearscope(struct in6_addr *in6)
{
	if (IN6_IS_SCOPE_EMBED(in6)) {
		in6->s6_addr[2] = 0;
		in6->s6_addr[3] = 0;
	}
}

void
sa2addr(struct sockaddr *sa, int *af, union eigrpd_addr *addr)
{
	struct sockaddr_in		*sa_in = (struct sockaddr_in *)sa;
	struct sockaddr_in6		*sa_in6 = (struct sockaddr_in6 *)sa;

	memset(addr, 0, sizeof(*addr));
	switch (sa->sa_family) {
	case AF_INET:
		*af = AF_INET;
		addr->v4 = sa_in->sin_addr;
		break;
	case AF_INET6:
		*af = AF_INET6;
		addr->v6 = sa_in6->sin6_addr;
		break;
	default:
		fatalx("sa2addr: unknown af");
	}
}
@


1.8
log
@Remove superfluous includes and follow style(9).

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.7 2016/02/21 18:53:54 renato Exp $ */
d307 21
@


1.7
log
@Introduce the bad_addr() family of functions.

These functions improve code reusability as there's no more need to
check for all possible "bad" addresses in several different places.

Besides that, this patch introduce additional checks in the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.6 2016/02/21 18:52:00 renato Exp $ */
d22 2
a23 1
#include <netinet/in.h>
@


1.6
log
@Extend eigrp_addrcmp() and use it in more places.

The idea is to remove unnecessary code duplication throughout the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.5 2016/02/21 18:40:56 renato Exp $ */
d215 39
@


1.5
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.4 2016/01/15 12:41:09 renato Exp $ */
d143 3
a145 3
		if (a->v4.s_addr != b->v4.s_addr)
			return (1);
		break;
d147 1
a147 3
		if (!IN6_ARE_ADDR_EQUAL(&a->v6, &b->v6))
			return (1);
		break;
a150 2

	return (0);
@


1.4
log
@Minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.3 2015/10/21 03:52:12 renato Exp $ */
a218 4
#define IN6_IS_SCOPE_EMBED(a)   \
	((IN6_IS_ADDR_LINKLOCAL(a)) ||  \
	 (IN6_IS_ADDR_MC_LINKLOCAL(a)) || \
	 (IN6_IS_ADDR_MC_INTFACELOCAL(a)))
d242 1
a242 1
	if (sin6->sin6_scope_id != 0) {
a244 1
	}
d257 1
a257 1
	if (sin6->sin6_scope_id != 0) {
a259 1
	}
d261 1
a261 1
	if (IN6_IS_SCOPE_EMBED(&sin6->sin6_addr)) {
a262 1
	}
a272 2

#undef IN6_IS_SCOPE_EMBED
@


1.3
log
@Add support for route summarization.

Working great but need more testing, especially with ipv6. For now
we don't validate if one configured summary is inside another or the
presence of duplicates. Will address these issues in a future commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.2 2015/10/04 23:00:10 renato Exp $ */
d139 1
a139 1
eigrp_addrcmp(int af, union eigrpd_addr *a, union eigrpd_addr *b)
d158 1
a158 1
eigrp_addrisset(int af, union eigrpd_addr *addr)
@


1.2
log
@Fix warnings and add safeguards to protect against corrupted data.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.1 2015/10/02 04:26:47 renato Exp $ */
d176 41
@


1.1
log
@Welcome eigrpd

The eigrpd daemon will support the Enhanced Interior Gateway Routing Protocol.

Built using the imsg/three process framework and heavily based on ospfd(8), ospf6d(8) and ldpd(8).

The current status of eigrpd(8) is as follows:
* Almost full compliance with the specification: DUAL FSM, RTP, CR mode, SIA, etc
* Support for both IPv4 and IPv6
* Support for multiple instances (different ASes/AFs) within the same process
* Support for rdomains (one process per rdomain)
* RIB/FIB synchronization
* Basic redistribution support

Not implemented features (yet):
* Configuration reload support (partially implemented)
* Route summarization
* Advanced route redistribution/filtering
* Carp integration
* Authentication (draft is missing information)
* Stub (not released by Cisco)

Not yet connected to the builds.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d134 1
a134 1
		break;
d151 1
a151 1
		break;
d161 2
d172 1
a172 1
		break;
@

