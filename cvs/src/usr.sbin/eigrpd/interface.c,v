head	1.24;
access;
symbols
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15;
locks; strict;
comment	@ * @;


1.24
date	2017.02.22.14.24.50;	author renato;	state Exp;
branches;
next	1.23;
commitid	x9CmxuqJPBEKTEJN;

1.23
date	2016.09.02.16.44.33;	author renato;	state Exp;
branches;
next	1.22;
commitid	o7fEENaKxNIOcUKV;

1.22
date	2016.09.02.16.39.44;	author renato;	state Exp;
branches;
next	1.21;
commitid	POT6tRNh9I6XBjro;

1.21
date	2016.09.02.16.34.20;	author renato;	state Exp;
branches;
next	1.20;
commitid	OEx84t3rZg0W9VAV;

1.20
date	2016.09.02.16.29.55;	author renato;	state Exp;
branches;
next	1.19;
commitid	w1am8mhLiSfZo4x6;

1.19
date	2016.06.05.17.07.41;	author renato;	state Exp;
branches;
next	1.18;
commitid	Vz8UnMLlq0YkNvcG;

1.18
date	2016.06.05.17.04.13;	author renato;	state Exp;
branches;
next	1.17;
commitid	KYe2r8EiFeq38biF;

1.17
date	2016.04.15.13.21.45;	author renato;	state Exp;
branches;
next	1.16;
commitid	zOVrWYmdyccBjHwb;

1.16
date	2016.04.15.13.10.56;	author renato;	state Exp;
branches;
next	1.15;
commitid	uxYgTnCpWxKsx7Ds;

1.15
date	2016.02.21.19.01.12;	author renato;	state Exp;
branches;
next	1.14;
commitid	6khscN8oOn8rqpDY;

1.14
date	2016.02.21.18.56.49;	author renato;	state Exp;
branches;
next	1.13;
commitid	Fln6asbk1x7lkTSp;

1.13
date	2016.02.21.18.40.56;	author renato;	state Exp;
branches;
next	1.12;
commitid	kZCMT2snnUUUOEjb;

1.12
date	2016.01.15.12.41.50;	author renato;	state Exp;
branches;
next	1.11;
commitid	i84qyynBGuCZey2g;

1.11
date	2016.01.15.12.36.41;	author renato;	state Exp;
branches;
next	1.10;
commitid	VxpaEFsR30Xigk4x;

1.10
date	2016.01.15.12.25.43;	author renato;	state Exp;
branches;
next	1.9;
commitid	9OwAkOA9fQWBhvxS;

1.9
date	2015.10.25.00.43.35;	author renato;	state Exp;
branches;
next	1.8;
commitid	WBcSbkaRyPxQfriP;

1.8
date	2015.10.21.03.52.12;	author renato;	state Exp;
branches;
next	1.7;
commitid	67lIWG5WR4Do3HhB;

1.7
date	2015.10.21.03.48.09;	author renato;	state Exp;
branches;
next	1.6;
commitid	AfOWCk8vQ1tJuhIQ;

1.6
date	2015.10.10.05.09.19;	author renato;	state Exp;
branches;
next	1.5;
commitid	ihAjab5XlJsGNNhO;

1.5
date	2015.10.10.05.07.10;	author renato;	state Exp;
branches;
next	1.4;
commitid	g9XgfwNFyUlqgLLb;

1.4
date	2015.10.10.05.03.39;	author renato;	state Exp;
branches;
next	1.3;
commitid	BktU0Il2Iu33W2f3;

1.3
date	2015.10.05.01.59.33;	author renato;	state Exp;
branches;
next	1.2;
commitid	gALnAEcCWDSQBrng;

1.2
date	2015.10.04.23.00.10;	author renato;	state Exp;
branches;
next	1.1;
commitid	vb2pR0BnPuOhwW09;

1.1
date	2015.10.02.04.26.47;	author renato;	state Exp;
branches;
next	;
commitid	dGX9Xs9GfneSNaca;


desc
@@


1.24
log
@No need to use SIOCGIFRDOMAIN anymore.
@
text
@/*	$OpenBSD: interface.c,v 1.23 2016/09/02 16:44:33 renato Exp $ */

/*
 * Copyright (c) 2015 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "eigrpd.h"
#include "eigrpe.h"
#include "log.h"

static __inline int	 iface_id_compare(struct eigrp_iface *,
			    struct eigrp_iface *);
static struct iface	*if_new(struct eigrpd_conf *, struct kif *);
static void		 if_del(struct iface *);
static struct if_addr	*if_addr_lookup(struct if_addr_head *, struct kaddr *);
static void		 eigrp_if_start(struct eigrp_iface *);
static void		 eigrp_if_reset(struct eigrp_iface *);
static void		 eigrp_if_hello_timer(int, short, void *);
static void		 eigrp_if_start_hello_timer(struct eigrp_iface *);
static void		 eigrp_if_stop_hello_timer(struct eigrp_iface *);
static int		 if_join_ipv4_group(struct iface *, struct in_addr *);
static int		 if_leave_ipv4_group(struct iface *, struct in_addr *);
static int		 if_join_ipv6_group(struct iface *, struct in6_addr *);
static int		 if_leave_ipv6_group(struct iface *, struct in6_addr *);

RB_GENERATE(iface_id_head, eigrp_iface, id_tree, iface_id_compare)

struct iface_id_head ifaces_by_id = RB_INITIALIZER(&ifaces_by_id);

static __inline int
iface_id_compare(struct eigrp_iface *a, struct eigrp_iface *b)
{
	return (a->ifaceid - b->ifaceid);
}

static struct iface *
if_new(struct eigrpd_conf *xconf, struct kif *kif)
{
	struct iface		*iface;

	if ((iface = calloc(1, sizeof(*iface))) == NULL)
		fatal("if_new: calloc");

	TAILQ_INIT(&iface->ei_list);
	TAILQ_INIT(&iface->addr_list);

	strlcpy(iface->name, kif->ifname, sizeof(iface->name));

	/* get type */
	if (kif->flags & IFF_POINTOPOINT)
		iface->type = IF_TYPE_POINTOPOINT;
	if (kif->flags & IFF_BROADCAST &&
	    kif->flags & IFF_MULTICAST)
		iface->type = IF_TYPE_BROADCAST;
	if (kif->flags & IFF_LOOPBACK)
		iface->type = IF_TYPE_POINTOPOINT;

	/* get index and flags */
	iface->mtu = kif->mtu;
	iface->ifindex = kif->ifindex;
	iface->rdomain = kif->rdomain;
	iface->flags = kif->flags;
	iface->linkstate = kif->link_state;
	iface->if_type = kif->if_type;
	iface->baudrate = kif->baudrate;

	TAILQ_INSERT_TAIL(&xconf->iface_list, iface, entry);

	return (iface);
}

static void
if_del(struct iface *iface)
{
	struct if_addr		*if_addr;

	log_debug("%s: interface %s", __func__, iface->name);

	while ((if_addr = TAILQ_FIRST(&iface->addr_list)) != NULL) {
		TAILQ_REMOVE(&iface->addr_list, if_addr, entry);
		free(if_addr);
	}

	TAILQ_REMOVE(&econf->iface_list, iface, entry);
	free(iface);
}

struct iface *
if_lookup(struct eigrpd_conf *xconf, unsigned int ifindex)
{
	struct iface	*iface;

	TAILQ_FOREACH(iface, &xconf->iface_list, entry)
		if (iface->ifindex == ifindex)
			return (iface);

	return (NULL);
}

void
if_addr_new(struct iface *iface, struct kaddr *ka)
{
	struct if_addr		*if_addr;
	struct eigrp_iface	*ei;

	if (ka->af == AF_INET6 && IN6_IS_ADDR_LINKLOCAL(&ka->addr.v6)) {
		iface->linklocal = ka->addr.v6;
		if_update(iface, AF_INET6);
		return;
	}

	if (if_addr_lookup(&iface->addr_list, ka) != NULL)
		return;

	if ((if_addr = calloc(1, sizeof(*if_addr))) == NULL)
		fatal("if_addr_new: calloc");
	if_addr->af = ka->af;
	if_addr->addr = ka->addr;
	if_addr->prefixlen = ka->prefixlen;
	if_addr->dstbrd = ka->dstbrd;
	TAILQ_INSERT_TAIL(&iface->addr_list, if_addr, entry);

	TAILQ_FOREACH(ei, &iface->ei_list, i_entry)
		if (ei->state == IF_STA_ACTIVE && ei->eigrp->af == if_addr->af)
			eigrpe_orig_local_route(ei, if_addr, 0);

	if (if_addr->af == AF_INET)
		if_update(iface, AF_INET);
}

void
if_addr_del(struct iface *iface, struct kaddr *ka)
{
	struct if_addr		*if_addr;
	struct eigrp_iface	*ei;
	int			 af = ka->af;

	if (ka->af == AF_INET6 &&
	    IN6_ARE_ADDR_EQUAL(&iface->linklocal, &ka->addr.v6)) {
		memset(&iface->linklocal, 0, sizeof(iface->linklocal));
		if_update(iface, AF_INET6);
		return;
	}

	if_addr = if_addr_lookup(&iface->addr_list, ka);
	if (if_addr == NULL)
		return;

	TAILQ_FOREACH(ei, &iface->ei_list, i_entry)
		if (ei->state == IF_STA_ACTIVE && ei->eigrp->af == if_addr->af)
			eigrpe_orig_local_route(ei, if_addr, 1);

	TAILQ_REMOVE(&iface->addr_list, if_addr, entry);
	free(if_addr);

	if (af == AF_INET)
		if_update(iface, AF_INET);
}

static struct if_addr *
if_addr_lookup(struct if_addr_head *addr_list, struct kaddr *ka)
{
	struct if_addr	*if_addr;
	int		 af = ka->af;

	TAILQ_FOREACH(if_addr, addr_list, entry)
		if (!eigrp_addrcmp(af, &if_addr->addr, &ka->addr) &&
		    if_addr->prefixlen == ka->prefixlen &&
		    !eigrp_addrcmp(af, &if_addr->dstbrd, &ka->dstbrd))
			return (if_addr);

	return (NULL);
}

in_addr_t
if_primary_addr(struct iface *iface)
{
	struct if_addr	*if_addr;

	TAILQ_FOREACH(if_addr, &iface->addr_list, entry)
		if (if_addr->af == AF_INET)
			return (if_addr->addr.v4.s_addr);

	return (INADDR_ANY);
}

uint8_t
if_primary_addr_prefixlen(struct iface *iface)
{
	struct if_addr	*if_addr;

	TAILQ_FOREACH(if_addr, &iface->addr_list, entry)
		if (if_addr->af == AF_INET)
			return (if_addr->prefixlen);

	return (0);
}

/* up/down events */
void
if_update(struct iface *iface, int af)
{
	struct eigrp_iface	*ei;
	int			 link_ok;
	int			 addr_ok, addr4_ok = 0, addr6_ok = 0;
	struct if_addr		*if_addr;

	link_ok = (iface->flags & IFF_UP) &&
	    LINK_STATE_IS_UP(iface->linkstate);

	/*
	 * NOTE: for EIGRPv4, each interface should have at least one valid
	 * IP address otherwise they can not be enabled in the routing domain.
	 */
	TAILQ_FOREACH(if_addr, &iface->addr_list, entry) {
		if (if_addr->af == AF_INET) {
			addr4_ok = 1;
			break;
		}
	}
	/* for IPv6 the link-local address is enough. */
	if (IN6_IS_ADDR_LINKLOCAL(&iface->linklocal))
		addr6_ok = 1;

	TAILQ_FOREACH(ei, &iface->ei_list, i_entry) {
		if (af != AF_UNSPEC && ei->eigrp->af != af)
			continue;

		switch (ei->eigrp->af) {
		case AF_INET:
			addr_ok = addr4_ok;
			break;
		case AF_INET6:
			addr_ok = addr6_ok;
			break;
		default:
			fatalx("if_update: unknown af");
		}

		if (ei->state == IF_STA_DOWN) {
			if (!link_ok || !addr_ok)
				continue;
			ei->state = IF_STA_ACTIVE;
			eigrp_if_start(ei);
		} else if (ei->state == IF_STA_ACTIVE) {
			if (link_ok && addr_ok)
				continue;
			ei->state = IF_STA_DOWN;
			eigrp_if_reset(ei);
		}
	}
}

struct eigrp_iface *
eigrp_if_new(struct eigrpd_conf *xconf, struct eigrp *eigrp, struct kif *kif)
{
	struct iface		*iface;
	struct eigrp_iface	*ei;
	static uint32_t		 ifacecnt = 1;

	iface = if_lookup(xconf, kif->ifindex);
	if (iface == NULL)
		iface = if_new(xconf, kif);

	if ((ei = calloc(1, sizeof(*ei))) == NULL)
		fatal("eigrp_if_new: calloc");

	ei->state = IF_STA_DOWN;
	/* get next unused ifaceid */
	while (eigrp_if_lookup_id(ifacecnt++))
		;
	ei->ifaceid = ifacecnt;
	ei->eigrp = eigrp;
	ei->iface = iface;
	if (ei->iface->flags & IFF_LOOPBACK)
		ei->passive = 1;

	TAILQ_INIT(&ei->nbr_list);
	TAILQ_INIT(&ei->update_list);
	TAILQ_INIT(&ei->query_list);
	TAILQ_INIT(&ei->summary_list);
	TAILQ_INSERT_TAIL(&iface->ei_list, ei, i_entry);
	TAILQ_INSERT_TAIL(&eigrp->ei_list, ei, e_entry);
	if (RB_INSERT(iface_id_head, &ifaces_by_id, ei) != NULL)
		fatalx("eigrp_if_new: RB_INSERT(ifaces_by_id) failed");

	return (ei);
}

void
eigrp_if_del(struct eigrp_iface *ei)
{
	struct summary_addr	*summary;

	RB_REMOVE(iface_id_head, &ifaces_by_id, ei);
	TAILQ_REMOVE(&ei->eigrp->ei_list, ei, e_entry);
	TAILQ_REMOVE(&ei->iface->ei_list, ei, i_entry);
	while ((summary = TAILQ_FIRST(&ei->summary_list)) != NULL) {
		TAILQ_REMOVE(&ei->summary_list, summary, entry);
		free(summary);
	}
	message_list_clr(&ei->query_list);
	message_list_clr(&ei->update_list);

	if (ei->state == IF_STA_ACTIVE)
		eigrp_if_reset(ei);

	if (TAILQ_EMPTY(&ei->iface->ei_list))
		if_del(ei->iface);

	free(ei);
}

struct eigrp_iface *
eigrp_if_lookup(struct iface *iface, int af, uint16_t as)
{
	struct eigrp_iface	*ei;

	TAILQ_FOREACH(ei, &iface->ei_list, i_entry)
		if (ei->eigrp->af == af &&
		    ei->eigrp->as == as)
			return (ei);

	return (NULL);
}

struct eigrp_iface *
eigrp_if_lookup_id(uint32_t ifaceid)
{
	struct eigrp_iface	 e;
	e.ifaceid = ifaceid;
	return (RB_FIND(iface_id_head, &ifaces_by_id, &e));
}

static void
eigrp_if_start(struct eigrp_iface *ei)
{
	struct eigrp		*eigrp = ei->eigrp;
	struct timeval		 now;
	struct if_addr		*if_addr;
	union eigrpd_addr	 addr;

	log_debug("%s: %s as %u family %s", __func__, ei->iface->name,
	    eigrp->as, af_name(eigrp->af));

	gettimeofday(&now, NULL);
	ei->uptime = now.tv_sec;

	/* init the dummy self neighbor */
	memset(&addr, 0, sizeof(addr));
	ei->self = nbr_new(ei, &addr, 0, 1);
	nbr_init(ei->self);

	TAILQ_FOREACH(if_addr, &ei->iface->addr_list, entry) {
		if (if_addr->af != eigrp->af)
			continue;

		eigrpe_orig_local_route(ei, if_addr, 0);
	}

	if (ei->passive)
		return;

	switch (eigrp->af) {
	case AF_INET:
		if (if_join_ipv4_group(ei->iface, &global.mcast_addr_v4))
			return;
		break;
	case AF_INET6:
		if (if_join_ipv6_group(ei->iface, &global.mcast_addr_v6))
			return;
		break;
	default:
		fatalx("eigrp_if_start: unknown af");
	}

	evtimer_set(&ei->hello_timer, eigrp_if_hello_timer, ei);
	eigrp_if_start_hello_timer(ei);
}

static void
eigrp_if_reset(struct eigrp_iface *ei)
{
	struct eigrp		*eigrp = ei->eigrp;
	struct nbr		*nbr;

	log_debug("%s: %s as %u family %s", __func__, ei->iface->name,
	    eigrp->as, af_name(eigrp->af));

	/* the rde will withdraw the connected route for us */

	while ((nbr = TAILQ_FIRST(&ei->nbr_list)) != NULL)
		nbr_del(nbr);

	if (ei->passive)
		return;

	/* try to cleanup */
	switch (eigrp->af) {
	case AF_INET:
		if_leave_ipv4_group(ei->iface, &global.mcast_addr_v4);
		break;
	case AF_INET6:
		if_leave_ipv6_group(ei->iface, &global.mcast_addr_v6);
		break;
	default:
		fatalx("eigrp_if_reset: unknown af");
	}

	eigrp_if_stop_hello_timer(ei);
}

/* timers */
/* ARGSUSED */
static void
eigrp_if_hello_timer(int fd, short event, void *arg)
{
	struct eigrp_iface	*ei = arg;
	struct timeval		 tv;

	send_hello(ei, NULL, 0);

	/* reschedule hello_timer */
	timerclear(&tv);
	tv.tv_sec = ei->hello_interval;
	if (evtimer_add(&ei->hello_timer, &tv) == -1)
		fatal("eigrp_if_hello_timer");
}

static void
eigrp_if_start_hello_timer(struct eigrp_iface *ei)
{
	struct timeval		 tv;

	timerclear(&tv);
	tv.tv_sec = ei->hello_interval;
	if (evtimer_add(&ei->hello_timer, &tv) == -1)
		fatal("eigrp_if_start_hello_timer");
}

static void
eigrp_if_stop_hello_timer(struct eigrp_iface *ei)
{
	if (evtimer_pending(&ei->hello_timer, NULL) &&
	    evtimer_del(&ei->hello_timer) == -1)
		fatal("eigrp_if_stop_hello_timer");
}

struct ctl_iface *
if_to_ctl(struct eigrp_iface *ei)
{
	static struct ctl_iface	 ictl;
	struct timeval		 now;
	struct nbr		*nbr;

	ictl.af = ei->eigrp->af;
	ictl.as = ei->eigrp->as;
	memcpy(ictl.name, ei->iface->name, sizeof(ictl.name));
	ictl.ifindex = ei->iface->ifindex;
	switch (ei->eigrp->af) {
	case AF_INET:
		ictl.addr.v4.s_addr = if_primary_addr(ei->iface);
		ictl.prefixlen = if_primary_addr_prefixlen(ei->iface);
		break;
	case AF_INET6:
		ictl.addr.v6 = ei->iface->linklocal;
		if (!IN6_IS_ADDR_UNSPECIFIED(&ei->iface->linklocal))
			ictl.prefixlen = 64;
		else
			ictl.prefixlen = 0;
		break;
	default:
		fatalx("if_to_ctl: unknown af");
	}
	ictl.flags = ei->iface->flags;
	ictl.linkstate = ei->iface->linkstate;
	ictl.mtu = ei->iface->mtu;
	ictl.type = ei->iface->type;
	ictl.if_type = ei->iface->if_type;
	ictl.baudrate = ei->iface->baudrate;
	ictl.delay = ei->delay;
	ictl.bandwidth = ei->bandwidth;
	ictl.hello_holdtime = ei->hello_holdtime;
	ictl.hello_interval = ei->hello_interval;
	ictl.splithorizon = ei->splithorizon;
	ictl.passive = ei->passive;
	ictl.nbr_cnt = 0;

	gettimeofday(&now, NULL);
	if (ei->state != IF_STA_DOWN && ei->uptime != 0)
		ictl.uptime = now.tv_sec - ei->uptime;
	else
		ictl.uptime = 0;

	TAILQ_FOREACH(nbr, &ei->nbr_list, entry)
		if (!(nbr->flags & (F_EIGRP_NBR_PENDING|F_EIGRP_NBR_SELF)))
			ictl.nbr_cnt++;

	return (&ictl);
}

/* misc */
void
if_set_sockbuf(int fd)
{
	int	bsize;

	bsize = 65535;
	while (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &bsize,
	    sizeof(bsize)) == -1)
		bsize /= 2;

	if (bsize != 65535)
		log_warnx("%s: recvbuf size only %d", __func__, bsize);

	bsize = 65535;
	while (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &bsize,
	    sizeof(bsize)) == -1)
		bsize /= 2;

	if (bsize != 65535)
		log_warnx("%s: sendbuf size only %d", __func__, bsize);
}

static int
if_join_ipv4_group(struct iface *iface, struct in_addr *addr)
{
	struct ip_mreq		 mreq;

	if (iface->group_count_v4++ != 0)
		/* already joined */
		return (0);

	log_debug("%s: interface %s addr %s", __func__, iface->name,
	    inet_ntoa(*addr));

	mreq.imr_multiaddr = *addr;
	mreq.imr_interface.s_addr = if_primary_addr(iface);

	if (setsockopt(global.eigrp_socket_v4, IPPROTO_IP, IP_ADD_MEMBERSHIP,
	    (void *)&mreq, sizeof(mreq)) < 0) {
		log_warn("%s: error IP_ADD_MEMBERSHIP, interface %s address %s",
		    __func__, iface->name, inet_ntoa(*addr));
		return (-1);
	}

	return (0);
}

static int
if_leave_ipv4_group(struct iface *iface, struct in_addr *addr)
{
	struct ip_mreq		 mreq;

	if (--iface->group_count_v4 != 0)
		/* others still joined */
		return (0);

	log_debug("%s: interface %s addr %s", __func__, iface->name,
	    inet_ntoa(*addr));

	mreq.imr_multiaddr = *addr;
	mreq.imr_interface.s_addr = if_primary_addr(iface);

	if (setsockopt(global.eigrp_socket_v4, IPPROTO_IP, IP_DROP_MEMBERSHIP,
	    (void *)&mreq, sizeof(mreq)) < 0) {
		log_warn("%s: error IP_DROP_MEMBERSHIP, interface %s "
		    "address %s", iface->name, __func__, inet_ntoa(*addr));
		return (-1);
	}

	return (0);
}

int
if_set_ipv4_mcast_ttl(int fd, uint8_t ttl)
{
	if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,
	    (char *)&ttl, sizeof(ttl)) < 0) {
		log_warn("%s: error setting IP_MULTICAST_TTL to %d",
		    __func__, ttl);
		return (-1);
	}

	return (0);
}

int
if_set_ipv4_mcast(struct iface *iface)
{
	in_addr_t	 addr;

	addr = if_primary_addr(iface);

	if (setsockopt(global.eigrp_socket_v4, IPPROTO_IP, IP_MULTICAST_IF,
	    &addr, sizeof(addr)) < 0) {
		log_warn("%s: error setting IP_MULTICAST_IF, interface %s",
		    __func__, iface->name);
		return (-1);
	}

	return (0);
}

int
if_set_ipv4_mcast_loop(int fd)
{
	uint8_t	loop = 0;

	if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP,
	    (char *)&loop, sizeof(loop)) < 0) {
		log_warn("%s: error setting IP_MULTICAST_LOOP", __func__);
		return (-1);
	}

	return (0);
}

int
if_set_ipv4_recvif(int fd, int enable)
{
	if (setsockopt(fd, IPPROTO_IP, IP_RECVIF, &enable,
	    sizeof(enable)) < 0) {
		log_warn("%s: error setting IP_RECVIF", __func__);
		return (-1);
	}
	return (0);
}

int
if_set_ipv4_hdrincl(int fd)
{
	int	hincl = 1;

	if (setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &hincl, sizeof(hincl)) < 0) {
		log_warn("%s: error setting IP_HDRINCL", __func__);
		return (-1);
	}

	return (0);
}

static int
if_join_ipv6_group(struct iface *iface, struct in6_addr *addr)
{
	struct ipv6_mreq	 mreq;

	if (iface->group_count_v6++ != 0)
		/* already joined */
		return (0);

	log_debug("%s: interface %s addr %s", __func__, iface->name,
	    log_in6addr(addr));

	mreq.ipv6mr_multiaddr = *addr;
	mreq.ipv6mr_interface = iface->ifindex;

	if (setsockopt(global.eigrp_socket_v6, IPPROTO_IPV6, IPV6_JOIN_GROUP,
	    &mreq, sizeof(mreq)) < 0) {
		log_warn("%s: error IPV6_JOIN_GROUP, interface %s address %s",
		    __func__, iface->name, log_in6addr(addr));
		return (-1);
	}

	return (0);
}

static int
if_leave_ipv6_group(struct iface *iface, struct in6_addr *addr)
{
	struct ipv6_mreq	 mreq;

	if (--iface->group_count_v6 != 0)
		/* others still joined */
		return (0);

	log_debug("%s: interface %s addr %s", __func__, iface->name,
	    log_in6addr(addr));

	mreq.ipv6mr_multiaddr = *addr;
	mreq.ipv6mr_interface = iface->ifindex;

	if (setsockopt(global.eigrp_socket_v6, IPPROTO_IPV6, IPV6_LEAVE_GROUP,
	    (void *)&mreq, sizeof(mreq)) < 0) {
		log_warn("%s: error IPV6_LEAVE_GROUP, interface %s address %s",
		    __func__, iface->name, log_in6addr(addr));
		return (-1);
	}

	return (0);
}

int
if_set_ipv6_mcast(struct iface *iface)
{
	if (setsockopt(global.eigrp_socket_v6, IPPROTO_IPV6, IPV6_MULTICAST_IF,
	    &iface->ifindex, sizeof(iface->ifindex)) < 0) {
		log_warn("%s: error setting IPV6_MULTICAST_IF, interface %s",
		    __func__, iface->name);
		return (-1);
	}

	return (0);
}

int
if_set_ipv6_mcast_loop(int fd)
{
	unsigned int	loop = 0;

	if (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP,
	    (unsigned int *)&loop, sizeof(loop)) < 0) {
		log_warn("%s: error setting IPV6_MULTICAST_LOOP", __func__);
		return (-1);
	}

	return (0);
}

int
if_set_ipv6_pktinfo(int fd, int enable)
{
	if (setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPKTINFO, &enable,
	    sizeof(enable)) < 0) {
		log_warn("%s: error setting IPV6_RECVPKTINFO", __func__);
		return (-1);
	}

	return (0);
}

int
if_set_ipv6_dscp(int fd, int dscp)
{
	if (setsockopt(fd, IPPROTO_IPV6, IPV6_TCLASS, &dscp,
	    sizeof(dscp)) < 0) {
		log_warn("%s: error setting IPV6_TCLASS", __func__);
		return (-1);
	}

	return (0);
}
@


1.23
log
@Make functions and variables static whenever possible.

style(9) says:
"Function prototypes for private functions (i.e., functions not used
elsewhere) go at the top of the first source module. In userland,
functions local to one source module should be declared 'static'".

The benefits of doing so include:
* clean up of the eigrpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Additional changes:
* Declare all extern variables in header files;
* Clean up the indentation of all function prototypes and global
  variables.

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.22 2016/09/02 16:39:44 renato Exp $ */
d85 1
a121 20
}

void
if_init(struct eigrpd_conf *xconf, struct iface *iface)
{
	struct ifreq		 ifr;
	unsigned int		 rdomain;

	/* set rdomain */
	strlcpy(ifr.ifr_name, iface->name, sizeof(ifr.ifr_name));
	if (ioctl(global.eigrp_socket_v4, SIOCGIFRDOMAIN, (caddr_t)&ifr) == -1)
		rdomain = 0;
	else {
		rdomain = ifr.ifr_rdomainid;
		if (setsockopt(global.eigrp_socket_v4, SOL_SOCKET, SO_RTABLE,
		    &rdomain, sizeof(rdomain)) == -1)
			fatal("failed to set rdomain");
	}
	if (rdomain != xconf->rdomain)
		fatalx("interface rdomain mismatch");
@


1.22
log
@Use static local variables instead of global variables whenever possible.

Also, there's no need to zero initialize global and static variables,
that's done automatically by the compiler.

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.21 2016/09/02 16:34:20 renato Exp $ */
d35 14
a48 1
extern struct eigrpd_conf        *econf;
d50 3
a52 3
void		 eigrp_if_hello_timer(int, short, void *);
void		 eigrp_if_start_hello_timer(struct eigrp_iface *);
void		 eigrp_if_stop_hello_timer(struct eigrp_iface *);
d60 1
a60 7
RB_HEAD(iface_id_head, eigrp_iface);
RB_PROTOTYPE(iface_id_head, eigrp_iface, id_tree, iface_id_compare)
RB_GENERATE(iface_id_head, eigrp_iface, id_tree, iface_id_compare)

struct iface_id_head ifaces_by_id = RB_INITIALIZER(&ifaces_by_id);

struct iface *
d95 1
a95 1
void
d203 1
a203 1
struct if_addr *
d378 1
a378 1
void
d424 1
a424 1
void
d458 1
a458 1
void
d473 1
a473 1
void
d484 1
a484 1
void
d568 1
a568 1
int
d593 1
a593 1
int
d686 1
a686 1
int
d711 1
a711 1
int
@


1.21
log
@Simplify handling of multicast addresses.

During the initialization of the eigrpe process, use inet_pton() to
store the EIGRP multicast addresses in two global variables:
* global.mcast_addr_v4 (in_addr);
* global.mcast_addr_v6 (in6_addr).

This way we don't need to create temporary in_addr/in6_addr variables
everytime we need to use these multicast addresses for something.

"I like this" claudio@@ ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.20 2016/09/02 16:29:55 renato Exp $ */
a52 2
static uint32_t	ifacecnt = 1;

d295 1
@


1.20
log
@Remove superfluous includes and follow style(9).

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.19 2016/06/05 17:07:41 renato Exp $ */
a378 2
	struct in_addr		 addr4;
	struct in6_addr		 addr6 = AllEIGRPRouters_v6;
d403 1
a403 2
		addr4.s_addr = AllEIGRPRouters_v4;
		if (if_join_ipv4_group(ei->iface, &addr4))
d407 1
a407 1
		if (if_join_ipv6_group(ei->iface, &addr6))
a421 2
	struct in_addr		 addr4;
	struct in6_addr		 addr6 = AllEIGRPRouters_v6;
d438 1
a438 2
		addr4.s_addr = AllEIGRPRouters_v4;
		if_leave_ipv4_group(ei->iface, &addr4);
d441 1
a441 1
		if_leave_ipv6_group(ei->iface, &addr6);
@


1.19
log
@Call if_update() only when necessary for IPv6 address changes.

For EIGRPv6, an interface only needs an link-local address in order
to be enabled in the routing daemon. So adding or removing global
unicast addresses, for example, will never trigger a state change in
the interface.

Additionally, move all address handling code to if_addr_new() and
if_addr_del() to improve readability.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.18 2016/06/05 17:04:13 renato Exp $ */
d21 2
a22 2
#include <stdlib.h>
#include <unistd.h>
a23 1
#include <sys/socket.h>
d25 1
d27 1
d29 1
d32 1
a32 1
#include "eigrp.h"
a33 1
#include "eigrpe.h"
@


1.18
log
@Reset the interface uptime when it is restarted.

The uptime was being set only when the interface was created, which is
not what we want.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.17 2016/04/15 13:21:45 renato Exp $ */
d143 6
a153 1

a157 1

d164 2
a165 1
	if_update(iface, if_addr->af);
d173 8
a190 1
	if_update(iface, if_addr->af);
d192 3
@


1.17
log
@Move several other variables out of eigrpd_conf.

Now eigrpd_conf contains only variables that can be modified via a
config reload. The other variables were moved to a new struct called
eigrpd_global, which is now a central point for storing global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.16 2016/04/15 13:10:56 renato Exp $ */
a280 1
	struct timeval		 now;
a298 3
	gettimeofday(&now, NULL);
	ei->uptime = now.tv_sec;

d360 1
d368 3
@


1.16
log
@Minor fixes and code cleanup.

* whitespace cleanup;
* copy in_addr structs directly;
* add more malloc return value checks;
* fix some log messages;
* turn ifacecnt into a static variable;
* use eigrp_addrcmp() on if_deladdr() to avoid code duplication;
* s/route_print_origin/log_route_origin/
* more smaller issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.15 2016/02/21 19:01:12 renato Exp $ */
d125 1
a125 1
	if (ioctl(econf->eigrp_socket_v4, SIOCGIFRDOMAIN, (caddr_t)&ifr) == -1)
d129 1
a129 1
		if (setsockopt(econf->eigrp_socket_v4, SOL_SOCKET, SO_RTABLE,
d567 1
a567 1
	if (setsockopt(econf->eigrp_socket_v4, IPPROTO_IP, IP_ADD_MEMBERSHIP,
d592 1
a592 1
	if (setsockopt(econf->eigrp_socket_v4, IPPROTO_IP, IP_DROP_MEMBERSHIP,
d622 1
a622 1
	if (setsockopt(econf->eigrp_socket_v4, IPPROTO_IP, IP_MULTICAST_IF,
d685 1
a685 1
	if (setsockopt(econf->eigrp_socket_v6, IPPROTO_IPV6, IPV6_JOIN_GROUP,
d710 1
a710 1
	if (setsockopt(econf->eigrp_socket_v6, IPPROTO_IPV6, IPV6_LEAVE_GROUP,
d723 1
a723 1
	if (setsockopt(econf->eigrp_socket_v6, IPPROTO_IPV6, IPV6_MULTICAST_IF,
@


1.15
log
@Move some functions around and rename a few variables and functions.

The sooner we do these changes the better. This rearrangement will make
the code easier to read.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.14 2016/02/21 18:56:49 renato Exp $ */
a39 7
static __inline int iface_id_compare(struct eigrp_iface *,
    struct eigrp_iface *);

RB_HEAD(iface_id_head, eigrp_iface);
RB_PROTOTYPE(iface_id_head, eigrp_iface, id_tree, iface_id_compare)
RB_GENERATE(iface_id_head, eigrp_iface, id_tree, iface_id_compare)

d46 4
d52 1
a52 1
uint32_t	ifacecnt = 1;
d494 4
a497 1
		ictl.prefixlen = 64;
d564 1
a564 1
	mreq.imr_multiaddr.s_addr = addr->s_addr;
d589 1
a589 1
	mreq.imr_multiaddr.s_addr = addr->s_addr;
d752 1
a752 1
		log_warn("%s: error setting IPV6_PKTINFO", __func__);
@


1.14
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.13 2016/02/21 18:40:56 renato Exp $ */
d108 12
a139 12
struct iface *
if_lookup(struct eigrpd_conf *xconf, unsigned int ifindex)
{
	struct iface	*iface;

	TAILQ_FOREACH(iface, &xconf->iface_list, entry)
		if (iface->ifindex == ifindex)
			return (iface);

	return (NULL);
}

d141 1
a141 1
if_addr_new(struct iface *iface, struct kaddr *kaddr)
d146 1
a146 1
	if (if_addr_lookup(&iface->addr_list, kaddr) != NULL)
d152 4
a155 4
	if_addr->af = kaddr->af;
	if_addr->addr = kaddr->addr;
	if_addr->prefixlen = kaddr->prefixlen;
	if_addr->dstbrd = kaddr->dstbrd;
d167 1
a167 1
if_addr_del(struct iface *iface, struct kaddr *kaddr)
d172 1
a172 1
	if_addr = if_addr_lookup(&iface->addr_list, kaddr);
d186 1
a186 1
if_addr_lookup(struct if_addr_head *addr_list, struct kaddr *kaddr)
d189 1
a189 1
	int		 af = kaddr->af;
d192 3
a194 3
		if (!eigrp_addrcmp(af, &if_addr->addr, &kaddr->addr) &&
		    if_addr->prefixlen == kaddr->prefixlen &&
		    !eigrp_addrcmp(af, &if_addr->dstbrd, &kaddr->dstbrd))
d295 1
a295 1
	while (eigrp_iface_find_id(ifacecnt++))
d342 21
a440 21
}

struct eigrp_iface *
eigrp_iface_find_id(uint32_t ifaceid)
{
	struct eigrp_iface	 e;
	e.ifaceid = ifaceid;
	return (RB_FIND(iface_id_head, &ifaces_by_id, &e));
}

struct eigrp_iface *
eigrp_if_lookup(struct iface *iface, int af, uint16_t as)
{
	struct eigrp_iface	*ei;

	TAILQ_FOREACH(ei, &iface->ei_list, i_entry)
		if (ei->eigrp->af == af &&
		    ei->eigrp->as == as)
			return (ei);

	return (NULL);
@


1.13
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.12 2016/01/15 12:41:50 renato Exp $ */
d153 1
a153 1
	memcpy(&if_addr->addr, &kaddr->addr, sizeof(if_addr->addr));
d155 1
a155 1
	memcpy(&if_addr->dstbrd, &kaddr->dstbrd, sizeof(if_addr->dstbrd));
d496 1
a496 2
		memcpy(&ictl.addr.v6, &ei->iface->linklocal,
		    sizeof(ictl.addr.v6));
@


1.12
log
@Fix bug that happened when a passive interface was shut down and then
reactivated.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.11 2016/01/15 12:36:41 renato Exp $ */
a26 1
#include <err.h>
d63 1
a63 1
		err(1, "if_new: calloc");
d140 1
a140 1
struct if_addr *
d147 1
a147 1
		return (NULL);
d150 1
a150 1
		fatal("if_addr_new");
a163 2

	return (if_addr);
d291 1
a291 1
		err(1, "eigrp_if_new: calloc");
d726 1
a726 1
		log_debug("%s: error setting IPV6_MULTICAST_IF, interface %s",
@


1.11
log
@Add support for manually clearing neighbors.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.10 2016/01/15 12:25:43 renato Exp $ */
a361 3
	/* set event handlers for interface */
	evtimer_set(&ei->hello_timer, eigrp_if_hello_timer, ei);

d386 1
d403 3
a422 3

	while ((nbr = TAILQ_FIRST(&ei->nbr_list)) != NULL)
		nbr_del(nbr);
@


1.10
log
@Avoid the use of inet_pton() whenever possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.9 2015/10/25 00:43:35 renato Exp $ */
d456 1
a456 1
	send_hello(ei, NULL, 0, 0);
@


1.9
log
@Fix some bugs in the detection of when an interface can be enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.8 2015/10/21 03:52:12 renato Exp $ */
d352 1
a352 1
	struct in6_addr		 addr6;
a381 1
		inet_pton(AF_INET6, AllEIGRPRouters_v6, &addr6);
d397 1
a397 1
	struct in6_addr		 addr6;
a414 1
		inet_pton(AF_INET6, AllEIGRPRouters_v6, &addr6);
@


1.8
log
@Add support for route summarization.

Working great but need more testing, especially with ipv6. For now
we don't validate if one configured summary is inside another or the
presence of duplicates. Will address these issues in a future commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.7 2015/10/21 03:48:09 renato Exp $ */
d233 1
a233 1
	int			 addr_ok = 1;
d240 2
a241 4
	 * NOTE: For EIGRPv4, each interface should have a valid IP address
	 * otherwise they can not be enabled in the routing domain. For IPv6
	 * this limitation does not exist because the link-local addresses
	 * are used to form the adjacencies.
d243 5
a247 6
	if (af == AF_INET) {
		TAILQ_FOREACH(if_addr, &iface->addr_list, entry)
			if (if_addr->af == AF_INET)
				break;
		if (if_addr == NULL)
			addr_ok = 0;
d249 3
d256 11
@


1.7
log
@Minor fixes and code cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.6 2015/10/10 05:09:19 renato Exp $ */
d301 1
d313 2
d318 4
@


1.6
log
@Move some interface initialization bits from if_init() to eigrp_if_start()
and call if_init() only during the startup of the eigrpe process.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.5 2015/10/10 05:07:10 renato Exp $ */
a95 1
	struct eigrp_iface	*ei;
a99 3
	while ((ei = TAILQ_FIRST(&iface->ei_list)) != NULL)
		eigrp_if_del(ei);

d315 2
@


1.5
log
@Remove attached neighbors whenever an interface is disabled to speedup
the convergence process.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.4 2015/10/10 05:03:39 renato Exp $ */
a117 12
	struct eigrp_iface	*ei;
	union eigrpd_addr	 addr;

	memset(&addr, 0, sizeof(addr));
	TAILQ_FOREACH(ei, &iface->ei_list, i_entry) {
		/* init the dummy self neighbor */
		ei->self = nbr_new(ei, &addr, 0, 1);
		nbr_init(ei->self);

		/* set event handlers for interface */
		evtimer_set(&ei->hello_timer, eigrp_if_hello_timer, ei);
	}
d334 1
d340 8
@


1.4
log
@Fix detection of interface up/down events.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.3 2015/10/05 01:59:33 renato Exp $ */
a327 2
	struct nbr	*nbr;

a334 3
	while ((nbr = TAILQ_FIRST(&ei->nbr_list)) != NULL)
		nbr_del(nbr);

d386 1
d411 3
@


1.3
log
@When the SIA state is declared for a given destination, reset the
adjacency with the unresponsive neighbor(s).
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.2 2015/10/04 23:00:10 renato Exp $ */
d249 2
d255 14
d274 1
a274 3
			if (!link_ok)
				continue;
			if (af == AF_INET && TAILQ_EMPTY(&iface->addr_list))
d278 2
a279 4
		} else {
			if (link_ok)
				continue;
			if (!(af == AF_INET && TAILQ_EMPTY(&iface->addr_list)))
@


1.2
log
@Fix warnings and add safeguards to protect against corrupted data.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.1 2015/10/02 04:26:47 renato Exp $ */
d434 1
a434 1
	send_hello(ei, NULL, 0);
@


1.1
log
@Welcome eigrpd

The eigrpd daemon will support the Enhanced Interior Gateway Routing Protocol.

Built using the imsg/three process framework and heavily based on ospfd(8), ospf6d(8) and ldpd(8).

The current status of eigrpd(8) is as follows:
* Almost full compliance with the specification: DUAL FSM, RTP, CR mode, SIA, etc
* Support for both IPv4 and IPv6
* Support for multiple instances (different ASes/AFs) within the same process
* Support for rdomains (one process per rdomain)
* RIB/FIB synchronization
* Basic redistribution support

Not implemented features (yet):
* Configuration reload support (partially implemented)
* Route summarization
* Advanced route redistribution/filtering
* Carp integration
* Authentication (draft is missing information)
* Stub (not released by Cisco)

Not yet connected to the builds.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d367 1
a367 1
		break;
d399 1
a399 1
		break;
d484 1
a484 1
		break;
@

