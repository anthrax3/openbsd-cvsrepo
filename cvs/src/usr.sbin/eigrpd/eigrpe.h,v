head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.2
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9;
locks; strict;
comment	@ * @;


1.16
date	2017.02.22.14.24.50;	author renato;	state Exp;
branches;
next	1.15;
commitid	x9CmxuqJPBEKTEJN;

1.15
date	2016.09.02.16.46.29;	author renato;	state Exp;
branches;
next	1.14;
commitid	K6uLqMvlsHB7ikcI;

1.14
date	2016.09.02.16.44.33;	author renato;	state Exp;
branches;
next	1.13;
commitid	o7fEENaKxNIOcUKV;

1.13
date	2016.09.02.16.36.33;	author renato;	state Exp;
branches;
next	1.12;
commitid	RP73Rgb2x0oQ1Vfz;

1.12
date	2016.09.02.16.29.55;	author renato;	state Exp;
branches;
next	1.11;
commitid	w1am8mhLiSfZo4x6;

1.11
date	2016.06.05.03.36.41;	author renato;	state Exp;
branches;
next	1.10;
commitid	zEMo2iI4upK0IUZs;

1.10
date	2016.04.15.13.10.56;	author renato;	state Exp;
branches;
next	1.9;
commitid	uxYgTnCpWxKsx7Ds;

1.9
date	2016.02.21.19.01.12;	author renato;	state Exp;
branches;
next	1.8;
commitid	6khscN8oOn8rqpDY;

1.8
date	2016.02.21.18.40.56;	author renato;	state Exp;
branches;
next	1.7;
commitid	kZCMT2snnUUUOEjb;

1.7
date	2016.01.15.12.36.41;	author renato;	state Exp;
branches;
next	1.6;
commitid	VxpaEFsR30Xigk4x;

1.6
date	2016.01.15.12.32.34;	author renato;	state Exp;
branches;
next	1.5;
commitid	NKjBajp5Z0fkMb21;

1.5
date	2016.01.15.12.29.29;	author renato;	state Exp;
branches;
next	1.4;
commitid	dbbIBjCqCzZHdGeq;

1.4
date	2015.12.13.18.55.53;	author renato;	state Exp;
branches;
next	1.3;
commitid	OoBnb9jAV4TnaVRr;

1.3
date	2015.10.05.01.59.33;	author renato;	state Exp;
branches;
next	1.2;
commitid	gALnAEcCWDSQBrng;

1.2
date	2015.10.04.23.08.57;	author renato;	state Exp;
branches;
next	1.1;
commitid	DeXpnCU2wphuBqEu;

1.1
date	2015.10.02.04.26.47;	author renato;	state Exp;
branches;
next	;
commitid	dGX9Xs9GfneSNaca;


desc
@@


1.16
log
@No need to use SIOCGIFRDOMAIN anymore.
@
text
@/*	$OpenBSD: eigrpe.h,v 1.15 2016/09/02 16:46:29 renato Exp $ */

/*
 * Copyright (c) 2015 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _EIGRPE_H_
#define _EIGRPE_H_

#include <sys/queue.h>
#include <sys/tree.h>

#include <event.h>

TAILQ_HEAD(ctl_conns, ctl_conn)	ctl_conns;

struct pbuf {
	struct ibuf		*buf;
	int			 refcnt;
};

struct packet {
	TAILQ_ENTRY(packet)	 entry;
	struct nbr		*nbr;
	uint32_t		 seq_num;
	struct pbuf		*pbuf;
	struct event		 ev_timeout;
	int			 attempts;
};

struct nbr {
	RB_ENTRY(nbr)		 addr_tree, pid_tree;
	TAILQ_ENTRY(nbr)	 entry;
	struct event		 ev_ack;
	struct event		 ev_hello_timeout;
	struct eigrp_iface	*ei;
	union eigrpd_addr	 addr;
	uint32_t		 peerid;
	time_t			 uptime;
	uint16_t		 hello_holdtime;
	uint8_t			 flags;
#define F_EIGRP_NBR_SELF		0x01
#define F_EIGRP_NBR_PENDING		0x02
#define F_EIGRP_NBR_CR_MODE		0x04

	struct rinfo_head	 update_list;	/* unicast updates */
	struct rinfo_head	 query_list;	/* unicast queries  */
	struct rinfo_head	 reply_list;	/* unicast replies */

	/* RTP */
	uint32_t		 recv_seq;
	uint32_t		 next_mcast_seq;
	TAILQ_HEAD(, packet)	 retrans_list;
};
RB_PROTOTYPE(nbr_addr_head, nbr, addr_tree, nbr_compare)
RB_PROTOTYPE(nbr_pid_head, nbr, pid_tree, nbr_pid_compare)

#define PREFIX_SIZE4(x)	(((x - 1) / 8) + 1)
#define PREFIX_SIZE6(x)	((x == 128) ? 16 : ((x / 8) + 1))

extern struct eigrpd_conf        *econf;

/* eigrpe.c */
void		 eigrpe(int, int, char *);
int		 eigrpe_imsg_compose_parent(int, pid_t, void *, uint16_t);
int		 eigrpe_imsg_compose_rde(int, uint32_t, pid_t, void *,
		    uint16_t);
void		 eigrpe_instance_init(struct eigrp *);
void		 eigrpe_instance_del(struct eigrp *);
void		 message_add(struct rinfo_head *, struct rinfo *);
void		 message_list_clr(struct rinfo_head *);
void		 seq_addr_list_clr(struct seq_addr_head *);
void		 eigrpe_orig_local_route(struct eigrp_iface *,
		    struct if_addr *, int);
void		 eigrpe_iface_ctl(struct ctl_conn *, unsigned int);
void		 eigrpe_nbr_ctl(struct ctl_conn *);
void		 eigrpe_stats_ctl(struct ctl_conn *);

/* interface.c */
struct iface		*if_lookup(struct eigrpd_conf *, unsigned int);
void			 if_addr_new(struct iface *, struct kaddr *);
void			 if_addr_del(struct iface *, struct kaddr *);
in_addr_t		 if_primary_addr(struct iface *);
uint8_t			 if_primary_addr_prefixlen(struct iface *);
void			 if_update(struct iface *, int);
struct eigrp_iface	*eigrp_if_new(struct eigrpd_conf *, struct eigrp *,
			    struct kif *);
void			 eigrp_if_del(struct eigrp_iface *);
struct eigrp_iface	*eigrp_if_lookup(struct iface *, int, uint16_t);
struct eigrp_iface	*eigrp_if_lookup_id(uint32_t);
struct ctl_iface	*if_to_ctl(struct eigrp_iface *);
void			 if_set_sockbuf(int);
int			 if_set_ipv4_mcast_ttl(int, uint8_t);
int			 if_set_ipv4_mcast(struct iface *);
int			 if_set_ipv4_mcast_loop(int);
int			 if_set_ipv4_recvif(int, int);
int			 if_set_ipv4_hdrincl(int);
int			 if_set_ipv6_mcast(struct iface *);
int			 if_set_ipv6_mcast_loop(int);
int			 if_set_ipv6_pktinfo(int, int);
int			 if_set_ipv6_dscp(int, int);

/* neighbor.c */
struct nbr	*nbr_new(struct eigrp_iface *, union eigrpd_addr *,
		    uint16_t, int);
void		 nbr_init(struct nbr *);
void		 nbr_del(struct nbr *);
struct nbr	*nbr_find(struct eigrp_iface *, union eigrpd_addr *);
struct nbr	*nbr_find_peerid(uint32_t);
struct ctl_nbr	*nbr_to_ctl(struct nbr *);
void		 nbr_clear_ctl(struct ctl_nbr *);
void		 nbr_start_timeout(struct nbr *);

/* rtp.c */
void		 rtp_packet_del(struct packet *);
void		 rtp_process_ack(struct nbr *, uint32_t);
void		 rtp_send_ucast(struct nbr *, struct ibuf *);
void		 rtp_send(struct eigrp_iface *, struct nbr *, struct ibuf *);
void		 rtp_send_ack(struct nbr *);
void		 rtp_ack_timer(int, short, void *);
void		 rtp_ack_start_timer(struct nbr *);
void		 rtp_ack_stop_timer(struct nbr *);

/* packet.c */
int	 gen_eigrp_hdr(struct ibuf *, uint16_t, uint8_t, uint32_t,
	    uint16_t);
int	 send_packet(struct eigrp_iface *, struct nbr *, uint32_t,
	    struct ibuf *);
void	 recv_packet(int, short, void *);

/* tlv.c */
int			 gen_parameter_tlv(struct ibuf *, struct eigrp_iface *,
			    int);
int			 gen_sequence_tlv(struct ibuf *,
			    struct seq_addr_head *);
int			 gen_sw_version_tlv(struct ibuf *);
int			 gen_mcast_seq_tlv(struct ibuf *, uint32_t);
uint16_t		 len_route_tlv(struct rinfo *);
int			 gen_route_tlv(struct ibuf *, struct rinfo *);
struct tlv_parameter	*tlv_decode_parameter(struct tlv *, char *);
int			 tlv_decode_seq(int, struct tlv *, char *,
			    struct seq_addr_head *);
struct tlv_sw_version	*tlv_decode_sw_version(struct tlv *, char *);
struct tlv_mcast_seq	*tlv_decode_mcast_seq(struct tlv *, char *);
int			 tlv_decode_route(int, struct tlv *, char *,
			    struct rinfo *);
void			 metric_encode_mtu(uint8_t *, int);
int			 metric_decode_mtu(uint8_t *);

/* hello.c */
void	 send_hello(struct eigrp_iface *, struct seq_addr_head *, uint32_t);
void	 send_peerterm(struct nbr *);
void	 recv_hello(struct eigrp_iface *, union eigrpd_addr *, struct nbr *,
	    struct tlv_parameter *);

/* update.c */
void	 send_update(struct eigrp_iface *, struct nbr *, uint32_t,
	    struct rinfo_head *);
void	 recv_update(struct nbr *, struct rinfo_head *, uint32_t);

/* query.c */
void	 send_query(struct eigrp_iface *, struct nbr *, struct rinfo_head *,
	    int);
void	 recv_query(struct nbr *, struct rinfo_head *, int);

/* reply.c */
void	 send_reply(struct nbr *, struct rinfo_head *, int);
void	 recv_reply(struct nbr *, struct rinfo_head *, int);

char	*pkt_ptr;	/* packet buffer */

#endif	/* _EIGRPE_H_ */
@


1.15
log
@Minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.h,v 1.14 2016/09/02 16:44:33 renato Exp $ */
a93 1
void			 if_init(struct eigrpd_conf *, struct iface *);
@


1.14
log
@Make functions and variables static whenever possible.

style(9) says:
"Function prototypes for private functions (i.e., functions not used
elsewhere) go at the top of the first source module. In userland,
functions local to one source module should be declared 'static'".

The benefits of doing so include:
* clean up of the eigrpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Additional changes:
* Declare all extern variables in header files;
* Clean up the indentation of all function prototypes and global
  variables.

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.h,v 1.13 2016/09/02 16:36:33 renato Exp $ */
d77 1
a77 1
pid_t		 eigrpe(int, int, char *);
@


1.13
log
@Merge the recv_packet_v[46] functions into one.

This reduces some code duplication and makes it easier to see the
difference between the IPv4 and IPv6 raw sockets API.

tweak + ok claudio@@, ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.h,v 1.12 2016/09/02 16:29:55 renato Exp $ */
d55 3
d68 2
a69 3
#define F_EIGRP_NBR_SELF		0x01
#define F_EIGRP_NBR_PENDING		0x02
#define F_EIGRP_NBR_CR_MODE		0x04
d74 2
a77 2
void		 eigrpe_dispatch_main(int, short, void *);
void		 eigrpe_dispatch_rde(int, short, void *);
a92 2
struct iface		*if_new(struct eigrpd_conf *, struct kif *);
void			 if_del(struct iface *);
a96 1
struct if_addr		*if_addr_lookup(struct if_addr_head *, struct kaddr *);
a104 2
void			 eigrp_if_start(struct eigrp_iface *);
void			 eigrp_if_reset(struct eigrp_iface *);
a106 2
int			 if_join_ipv4_group(struct iface *, struct in_addr *);
int			 if_leave_ipv4_group(struct iface *, struct in_addr *);
a111 2
int			 if_join_ipv6_group(struct iface *, struct in6_addr *);
int			 if_leave_ipv6_group(struct iface *, struct in6_addr *);
a121 1
void		 nbr_update_peerid(struct nbr *);
a125 1
void		 nbr_timeout(int, short, void *);
a126 1
void		 nbr_stop_timeout(struct nbr *);
a128 4
struct pbuf	*rtp_buf_new(struct ibuf *);
struct pbuf	*rtp_buf_hold(struct pbuf *);
void		 rtp_buf_release(struct pbuf *);
struct packet	*rtp_packet_new(struct nbr *, uint32_t, struct pbuf *);
a130 2
void		 rtp_send_packet(struct packet *);
void		 rtp_enqueue_packet(struct packet *);
a131 1
void		 rtp_send_mcast(struct eigrp_iface *, struct ibuf *);
@


1.12
log
@Remove superfluous includes and follow style(9).

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.h,v 1.11 2016/06/05 03:36:41 renato Exp $ */
d160 1
a160 2
void	 recv_packet_v4(int, short, void *);
void	 recv_packet_v6(int, short, void *);
@


1.11
log
@Improve security by calling exec after fork.

For each child process (rde and eigrpe), re-exec eigrpd with a special
"per-role" getopt flag. This way we have seperate ASLR/cookies per
process.

Based on a similar patch for bgpd, from claudio@@

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.h,v 1.10 2016/04/15 13:10:56 renato Exp $ */
d23 4
a26 4
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
@


1.10
log
@Minor fixes and code cleanup.

* whitespace cleanup;
* copy in_addr structs directly;
* add more malloc return value checks;
* fix some log messages;
* turn ifacecnt into a static variable;
* use eigrp_addrcmp() on if_deladdr() to avoid code duplication;
* s/route_print_origin/log_route_origin/
* more smaller issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.h,v 1.9 2016/02/21 19:01:12 renato Exp $ */
d73 1
a73 1
pid_t		 eigrpe(struct eigrpd_conf *, int[2], int[2], int[2]);
@


1.9
log
@Move some functions around and rename a few variables and functions.

The sooner we do these changes the better. This rearrangement will make
the code easier to read.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.h,v 1.8 2016/02/21 18:40:56 renato Exp $ */
d78 1
a78 1
    uint16_t);
d85 1
a85 1
    struct if_addr *, int);
d102 1
a102 1
    struct kif *);
d126 1
a126 1
    uint16_t, int);
d157 1
a157 1
    uint16_t);
d159 1
a159 1
    struct ibuf *);
d165 1
a165 1
    int);
d167 1
a167 1
    struct seq_addr_head *);
d174 1
a174 1
    struct seq_addr_head *);
d178 1
a178 1
    struct rinfo *);
d186 1
a186 1
    struct tlv_parameter *);
d190 1
a190 1
    struct rinfo_head *);
d195 1
a195 1
    int);
@


1.8
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.h,v 1.7 2016/01/15 12:36:41 renato Exp $ */
d93 1
a94 1
struct iface		*if_lookup(struct eigrpd_conf *, unsigned int);
d104 2
a107 2
struct eigrp_iface	*eigrp_if_lookup(struct iface *, int, uint16_t);
struct eigrp_iface	*eigrp_iface_find_id(uint32_t);
@


1.7
log
@Add support for manually clearing neighbors.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.h,v 1.6 2016/01/15 12:32:34 renato Exp $ */
d95 1
a95 1
struct if_addr		*if_addr_new(struct iface *, struct kaddr *);
@


1.6
log
@Do not set the EoT flag in the last startup update.

Unfortunately we don't have enough information to support the NSF feature,
the EIGRP draft is missing a lot of information in this regard.

The EoT flag is used as part of EIGRP NSF to announce the end of the
startup process with a neighbor. The problem is that, when we set this
flag, the Cisco neighbors will assume that we support NSF, which is
not true.  When this happens, these routers expect us to do things that
we don't know, and weird things can happen. So let's play safe and just
ignore this flag for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.h,v 1.5 2016/01/15 12:29:29 renato Exp $ */
d133 1
d183 2
a184 2
void	 send_hello(struct eigrp_iface *, struct seq_addr_head *, uint32_t,
    int);
@


1.5
log
@Split TLV constants into subcomponents to simplify the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.h,v 1.4 2015/12/13 18:55:53 renato Exp $ */
d188 1
a188 1
void	 send_update(struct eigrp_iface *, struct nbr *, uint32_t, int,
@


1.4
log
@Introduce new command to show traffic statistics.

Can be useful as a troubleshooting tool.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.h,v 1.3 2015/10/05 01:59:33 renato Exp $ */
d176 2
a177 2
int			 tlv_decode_route(int, enum route_type, struct tlv *,
    char *, struct rinfo *);
@


1.3
log
@When the SIA state is declared for a given destination, reset the
adjacency with the unresponsive neighbor(s).
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.h,v 1.2 2015/10/04 23:08:57 renato Exp $ */
d88 1
@


1.2
log
@Ignore IPv4 TLVs in IPv6 instances and vice-versa.
@
text
@d1 1
a1 1
/*	$OpenBSD: eigrpe.h,v 1.1 2015/10/02 04:26:47 renato Exp $ */
d162 2
a163 1
int			 gen_parameter_tlv(struct ibuf *, struct eigrp_iface *);
d181 2
a182 1
void	 send_hello(struct eigrp_iface *, struct seq_addr_head *, uint32_t);
@


1.1
log
@Welcome eigrpd

The eigrpd daemon will support the Enhanced Interior Gateway Routing Protocol.

Built using the imsg/three process framework and heavily based on ospfd(8), ospf6d(8) and ldpd(8).

The current status of eigrpd(8) is as follows:
* Almost full compliance with the specification: DUAL FSM, RTP, CR mode, SIA, etc
* Support for both IPv4 and IPv6
* Support for multiple instances (different ASes/AFs) within the same process
* Support for rdomains (one process per rdomain)
* RIB/FIB synchronization
* Basic redistribution support

Not implemented features (yet):
* Configuration reload support (partially implemented)
* Route summarization
* Advanced route redistribution/filtering
* Carp integration
* Authentication (draft is missing information)
* Stub (not released by Cisco)

Not yet connected to the builds.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d170 1
a170 1
int			 tlv_decode_seq(struct tlv *, char *,
@

