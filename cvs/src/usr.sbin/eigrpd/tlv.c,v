head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.2
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11;
locks; strict;
comment	@ * @;


1.15
date	2016.10.10.02.26.24;	author gsoares;	state Exp;
branches;
next	1.14;
commitid	qprTTT7qmCUyPyQp;

1.14
date	2016.09.02.16.46.29;	author renato;	state Exp;
branches;
next	1.13;
commitid	K6uLqMvlsHB7ikcI;

1.13
date	2016.09.02.16.29.55;	author renato;	state Exp;
branches;
next	1.12;
commitid	w1am8mhLiSfZo4x6;

1.12
date	2016.07.18.21.14.30;	author benno;	state Exp;
branches;
next	1.11;
commitid	X9E9HZswo9VkBjRl;

1.11
date	2016.02.21.18.59.54;	author renato;	state Exp;
branches;
next	1.10;
commitid	Hd91ZAXKIGRYtqlE;

1.10
date	2016.02.21.18.56.49;	author renato;	state Exp;
branches;
next	1.9;
commitid	Fln6asbk1x7lkTSp;

1.9
date	2016.02.21.18.53.54;	author renato;	state Exp;
branches;
next	1.8;
commitid	wQY3qMWTuqWqk9Cy;

1.8
date	2016.02.21.18.40.56;	author renato;	state Exp;
branches;
next	1.7;
commitid	kZCMT2snnUUUOEjb;

1.7
date	2016.02.21.18.38.37;	author renato;	state Exp;
branches;
next	1.6;
commitid	hg6xye6R8Uf5Uk5s;

1.6
date	2016.01.15.12.29.29;	author renato;	state Exp;
branches;
next	1.5;
commitid	dbbIBjCqCzZHdGeq;

1.5
date	2015.10.21.03.48.09;	author renato;	state Exp;
branches;
next	1.4;
commitid	AfOWCk8vQ1tJuhIQ;

1.4
date	2015.10.05.01.59.33;	author renato;	state Exp;
branches;
next	1.3;
commitid	gALnAEcCWDSQBrng;

1.3
date	2015.10.04.23.08.57;	author renato;	state Exp;
branches;
next	1.2;
commitid	DeXpnCU2wphuBqEu;

1.2
date	2015.10.04.23.00.10;	author renato;	state Exp;
branches;
next	1.1;
commitid	vb2pR0BnPuOhwW09;

1.1
date	2015.10.02.04.26.47;	author renato;	state Exp;
branches;
next	;
commitid	dGX9Xs9GfneSNaca;


desc
@@


1.15
log
@calls to uname(3) should be checked against non-negative value
upon successful and -1 on failure (as per POSIX). No functional change, just
improves portability.

requested by guenther@@
looks correct to schwarze@@
OK renato@@
@
text
@/*	$OpenBSD: tlv.c,v 1.14 2016/09/02 16:46:29 renato Exp $ */

/*
 * Copyright (c) 2015 Renato Westphal <renato@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/utsname.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "eigrpd.h"
#include "eigrpe.h"
#include "log.h"

int
gen_parameter_tlv(struct ibuf *buf, struct eigrp_iface *ei, int peerterm)
{
	struct tlv_parameter	 tp;

	tp.type = htons(TLV_TYPE_PARAMETER);
	tp.length = htons(TLV_TYPE_PARAMETER_LEN);
	if (peerterm) {
		tp.kvalues[0] = 255;
		tp.kvalues[1] = 255;
		tp.kvalues[2] = 255;
		tp.kvalues[3] = 255;
		tp.kvalues[4] = 255;
		tp.kvalues[5] = 0;
	} else
		memcpy(tp.kvalues, ei->eigrp->kvalues, 6);
	tp.holdtime = htons(ei->hello_holdtime);

	return (ibuf_add(buf, &tp, sizeof(tp)));
}

int
gen_sequence_tlv(struct ibuf *buf, struct seq_addr_head *seq_addr_list)
{
	struct tlv		 tlv, *tlvp;
	struct seq_addr_entry	*sa;
	uint8_t			 alen;
	uint16_t		 len = TLV_HDR_LEN;
	size_t			 original_size = ibuf_size(buf);

	tlv.type = htons(TLV_TYPE_SEQ);
	if (ibuf_add(buf, &tlv, sizeof(tlv))) {
		log_warn("%s: ibuf_add failed", __func__);
		return (-1);
	}

	TAILQ_FOREACH(sa, seq_addr_list, entry) {
		switch (sa->af) {
		case AF_INET:
			alen = INADDRSZ;
			break;
		case AF_INET6:
			alen = IN6ADDRSZ;
			break;
		default:
			fatalx("gen_sequence_tlv: unknown address family");
		}
		if (ibuf_add(buf, &alen, sizeof(alen)))
			return (-1);
		if (ibuf_add(buf, &sa->addr, alen)) {
			log_warn("%s: ibuf_add failed", __func__);
			return (-1);
		}

		len += (sizeof(alen) + alen);
	}

	/* adjust tlv length */
	if ((tlvp = ibuf_seek(buf, original_size, sizeof(*tlvp))) == NULL)
                fatalx("gen_sequence_tlv: buf_seek failed");
	tlvp->length = htons(len);

	return (0);
}

int
gen_sw_version_tlv(struct ibuf *buf)
{
	struct tlv_sw_version	 ts;
	struct utsname		 u;
	unsigned int		 vendor_os_major;
	unsigned int		 vendor_os_minor;

	memset(&ts, 0, sizeof(ts));
	ts.type = htons(TLV_TYPE_SW_VERSION);
	ts.length = htons(TLV_TYPE_SW_VERSION_LEN);
	if (uname(&u) >= 0) {
		if (sscanf(u.release, "%u.%u", &vendor_os_major,
		    &vendor_os_minor) == 2) {
			ts.vendor_os_major = (uint8_t) vendor_os_major;
			ts.vendor_os_minor = (uint8_t) vendor_os_minor;
		}
	}
	ts.eigrp_major = EIGRP_VERSION_MAJOR;
	ts.eigrp_minor = EIGRP_VERSION_MINOR;

	return (ibuf_add(buf, &ts, sizeof(ts)));
}

int
gen_mcast_seq_tlv(struct ibuf *buf, uint32_t seq)
{
	struct tlv_mcast_seq	 tm;

	tm.type = htons(TLV_TYPE_MCAST_SEQ);
	tm.length = htons(TLV_TYPE_MCAST_SEQ_LEN);
	tm.seq = htonl(seq);

	return (ibuf_add(buf, &tm, sizeof(tm)));
}

uint16_t
len_route_tlv(struct rinfo *ri)
{
	uint16_t		 len = TLV_HDR_LEN;

	switch (ri->af) {
	case AF_INET:
		len += sizeof(ri->nexthop.v4);
		len += PREFIX_SIZE4(ri->prefixlen);
		break;
	case AF_INET6:
		len += sizeof(ri->nexthop.v6);
		len += PREFIX_SIZE6(ri->prefixlen);
		break;
	default:
		break;
	}

	len += sizeof(ri->metric);
	if (ri->type == EIGRP_ROUTE_EXTERNAL)
		len += sizeof(ri->emetric);

	len += sizeof(ri->prefixlen);

	return (len);
}

int
gen_route_tlv(struct ibuf *buf, struct rinfo *ri)
{
	struct tlv		 tlv, *tlvp;
	struct in_addr		 addr;
	struct classic_metric	 metric;
	struct classic_emetric	 emetric;
	uint16_t		 tlvlen;
	uint8_t			 pflen;
	size_t			 original_size = ibuf_size(buf);

	switch (ri->af) {
	case AF_INET:
		tlv.type = TLV_PROTO_IPV4;
		break;
	case AF_INET6:
		tlv.type = TLV_PROTO_IPV6;
		break;
	default:
		fatalx("gen_route_tlv: unknown af");
	}

	switch (ri->type) {
	case EIGRP_ROUTE_INTERNAL:
		tlv.type |= TLV_ROUTE_INTERNAL;
		break;
	case EIGRP_ROUTE_EXTERNAL:
		tlv.type |= TLV_ROUTE_EXTERNAL;
		break;
	default:
		fatalx("gen_route_tlv: unknown type");
	}
	tlv.type = htons(tlv.type);

	if (ibuf_add(buf, &tlv, sizeof(tlv)))
		return (-1);
	tlvlen = TLV_HDR_LEN;

	/* nexthop */
	switch (ri->af) {
	case AF_INET:
		addr.s_addr = htonl(ri->nexthop.v4.s_addr);
		if (ibuf_add(buf, &addr, sizeof(addr)))
			return (-1);
		tlvlen += sizeof(ri->nexthop.v4);
		break;
	case AF_INET6:
		if (ibuf_add(buf, &ri->nexthop.v6, sizeof(ri->nexthop.v6)))
			return (-1);
		tlvlen += sizeof(ri->nexthop.v6);
		break;
	default:
		fatalx("gen_route_tlv: unknown af");
	}

	/* exterior metric */
	if (ri->type == EIGRP_ROUTE_EXTERNAL) {
		emetric = ri->emetric;
		emetric.routerid = htonl(emetric.routerid);
		emetric.as = htonl(emetric.as);
		emetric.tag = htonl(emetric.tag);
		emetric.metric = htonl(emetric.metric);
		emetric.reserved = htons(emetric.reserved);
		if (ibuf_add(buf, &emetric, sizeof(emetric)))
			return (-1);
		tlvlen += sizeof(emetric);
	}

	/* metric */
	metric = ri->metric;
	metric.delay = htonl(metric.delay);
	metric.bandwidth = htonl(metric.bandwidth);
	if (ibuf_add(buf, &metric, sizeof(metric)))
		return (-1);
	tlvlen += sizeof(metric);

	/* destination */
	if (ibuf_add(buf, &ri->prefixlen, sizeof(ri->prefixlen)))
		return (-1);
	switch (ri->af) {
	case AF_INET:
		pflen = PREFIX_SIZE4(ri->prefixlen);
		if (ibuf_add(buf, &ri->prefix.v4, pflen))
			return (-1);
		break;
	case AF_INET6:
		pflen = PREFIX_SIZE6(ri->prefixlen);
		if (ibuf_add(buf, &ri->prefix.v6, pflen))
			return (-1);
		break;
	default:
		fatalx("gen_route_tlv: unknown af");
	}
	tlvlen += sizeof(pflen) + pflen;

	/* adjust tlv length */
	if ((tlvp = ibuf_seek(buf, original_size, sizeof(*tlvp))) == NULL)
                fatalx("gen_route_tlv: buf_seek failed");
	tlvp->length = htons(tlvlen);

	return (0);
}

struct tlv_parameter *
tlv_decode_parameter(struct tlv *tlv, char *buf)
{
	struct tlv_parameter	*tp;

	if (ntohs(tlv->length) != TLV_TYPE_PARAMETER_LEN) {
		log_debug("%s: malformed tlv (bad length)", __func__);
		return (NULL);
	}
	tp = (struct tlv_parameter *)buf;
	return (tp);
}

int
tlv_decode_seq(int af, struct tlv *tlv, char *buf,
    struct seq_addr_head *seq_addr_list)
{
	uint16_t		 len;
	uint8_t			 alen;
	struct seq_addr_entry	*sa;

	len = ntohs(tlv->length);
	if (len < TLV_HDR_LEN) {
		log_debug("%s: malformed tlv (bad length)", __func__);
		return (-1);
	}
	buf += TLV_HDR_LEN;
	len -= TLV_HDR_LEN;

	while (len > 0) {
		memcpy(&alen, buf, sizeof(alen));
		buf += sizeof(alen);
		len -= sizeof(alen);
		if (alen > len) {
			log_debug("%s: malformed tlv (bad length)", __func__);
			return (-1);
		}

		switch (af) {
		case AF_INET:
			if (alen != INADDRSZ) {
				log_debug("%s: invalid address length",
				    __func__);
				return (-1);
			}
			break;
		case AF_INET6:
			if (alen != IN6ADDRSZ) {
				log_debug("%s: invalid address length",
				    __func__);
				return (-1);
			}
			break;
		default:
			fatalx("tlv_decode_seq: unknown af");
		}
		if ((sa = calloc(1, sizeof(*sa))) == NULL)
			fatal("tlv_decode_seq");
		sa->af = af;
		memcpy(&sa->addr, buf, alen);
		TAILQ_INSERT_TAIL(seq_addr_list, sa, entry);

		buf += alen;
		len -= alen;
	}

	return (0);
}

struct tlv_sw_version *
tlv_decode_sw_version(struct tlv *tlv, char *buf)
{
	struct tlv_sw_version	*tv;

	if (ntohs(tlv->length) != TLV_TYPE_SW_VERSION_LEN) {
		log_debug("%s: malformed tlv (bad length)", __func__);
		return (NULL);
	}
	tv = (struct tlv_sw_version *)buf;
	return (tv);
}

struct tlv_mcast_seq *
tlv_decode_mcast_seq(struct tlv *tlv, char *buf)
{
	struct tlv_mcast_seq	*tm;

	if (ntohs(tlv->length) != TLV_TYPE_MCAST_SEQ_LEN) {
		log_debug("%s: malformed tlv (bad length)", __func__);
		return (NULL);
	}
	tm = (struct tlv_mcast_seq *)buf;
	return (tm);
}

int
tlv_decode_route(int af, struct tlv *tlv, char *buf, struct rinfo *ri)
{
	unsigned int	 tlv_len, min_len, max_plen, plen, offset;

	ri->af = af;
	switch (ri->af) {
	case AF_INET:
		min_len = TLV_TYPE_IPV4_INT_MIN_LEN;
		max_plen = sizeof(ri->prefix.v4);
		break;
	case AF_INET6:
		min_len = TLV_TYPE_IPV6_INT_MIN_LEN;
		max_plen = sizeof(ri->prefix.v6);
		break;
	default:
		fatalx("tlv_decode_route: unknown af");
	}

	switch (ntohs(tlv->type) & TLV_TYPE_MASK) {
	case TLV_ROUTE_INTERNAL:
		ri->type = EIGRP_ROUTE_INTERNAL;
		break;
	case TLV_ROUTE_EXTERNAL:
		ri->type = EIGRP_ROUTE_EXTERNAL;
		min_len += sizeof(struct classic_emetric);
		break;
	default:
		fatalx("tlv_decode_route: unknown type");
	}

	tlv_len = ntohs(tlv->length);
	if (tlv_len < min_len) {
		log_debug("%s: malformed tlv (bad length)", __func__);
		return (-1);
	}

	/* nexthop */
	offset = TLV_HDR_LEN;
	switch (af) {
	case AF_INET:
		memcpy(&ri->nexthop.v4, buf + offset, sizeof(ri->nexthop.v4));
		offset += sizeof(ri->nexthop.v4);
		break;
	case AF_INET6:
		memcpy(&ri->nexthop.v6, buf + offset, sizeof(ri->nexthop.v6));
		offset += sizeof(ri->nexthop.v6);
		break;
	default:
		fatalx("tlv_decode_route: unknown af");
	}

	/* exterior metric */
	if (ri->type == EIGRP_ROUTE_EXTERNAL) {
		memcpy(&ri->emetric, buf + offset, sizeof(ri->emetric));
		ri->emetric.routerid = ntohl(ri->emetric.routerid);
		ri->emetric.as = ntohl(ri->emetric.as);
		ri->emetric.tag = ntohl(ri->emetric.tag);
		ri->emetric.metric = ntohl(ri->emetric.metric);
		ri->emetric.reserved = ntohs(ri->emetric.reserved);
		offset += sizeof(ri->emetric);
	}

	/* metric */
	memcpy(&ri->metric, buf + offset, sizeof(ri->metric));
	ri->metric.delay = ntohl(ri->metric.delay);
	ri->metric.bandwidth = ntohl(ri->metric.bandwidth);
	offset += sizeof(ri->metric);

	/* prefixlen */
	memcpy(&ri->prefixlen, buf + offset, sizeof(ri->prefixlen));
	offset += sizeof(ri->prefixlen);

	/*
	 * Different versions of IOS can use a different number of bytes to
	 * encode the same IPv6 prefix. This sucks but we have to deal with it.
	 * Instead of calculating the number of bytes based on the value of the
	 * prefixlen field, let's get this number by subtracting the size of all
	 * other fields from the total size of the TLV. It works because all
	 * the other fields have a fixed length.
	 */
	plen = tlv_len - min_len;

	/* safety check */
	if (plen > max_plen) {
		log_debug("%s: malformed tlv", __func__);
		return (-1);
	}

	/* destination */
	switch (af) {
	case AF_INET:
		memset(&ri->prefix.v4, 0, sizeof(ri->prefix.v4));
		memcpy(&ri->prefix.v4, buf + offset, plen);
		break;
	case AF_INET6:
		memset(&ri->prefix.v6, 0, sizeof(ri->prefix.v6));
		memcpy(&ri->prefix.v6, buf + offset, plen);
		break;
	default:
		fatalx("tlv_decode_route: unknown af");
	}

	/* check if the network is valid */
	if (bad_addr(af, &ri->prefix) ||
	   (af == AF_INET6 && IN6_IS_SCOPE_EMBED(&ri->prefix.v6))) {
		log_debug("%s: malformed tlv (invalid prefix): %s", __func__,
		    log_addr(af, &ri->prefix));
		return (-1);
	}

	/* just in case... */
	eigrp_applymask(af, &ri->prefix, &ri->prefix, ri->prefixlen);

	return (0);
}

void
metric_encode_mtu(uint8_t *dst, int mtu)
{
	dst[0] = (mtu & 0x00FF0000) >> 16;
	dst[1] = (mtu & 0x0000FF00) >> 8;
	dst[2] = (mtu & 0x000000FF);
}

int
metric_decode_mtu(uint8_t *mtu)
{
	return ((mtu[0] << 16) + (mtu[1] << 8) + mtu[2]);
}
@


1.14
log
@Minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: tlv.c,v 1.13 2016/09/02 16:29:55 renato Exp $ */
d106 1
a106 1
	if (uname(&u) == 0) {
@


1.13
log
@Remove superfluous includes and follow style(9).

ok claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tlv.c,v 1.12 2016/07/18 21:14:30 benno Exp $ */
d302 2
a303 1
				log_debug("%s: invalid address length", __func__);
d309 2
a310 1
				log_debug("%s: invalid address length", __func__);
@


1.12
log
@add format attributes to log functions and fix two errors

ok renato@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tlv.c,v 1.11 2016/02/21 18:59:54 renato Exp $ */
d19 4
a23 2
#include <stdio.h>
#include <inttypes.h>
a24 2
#include <sys/uio.h>
#include <sys/utsname.h>
d27 1
a27 1
#include "eigrp.h"
a28 1
#include "eigrpe.h"
@


1.11
log
@Simplify the handling of the sequence tlv.

The C standard says: "A pointer to a union object, suitably converted,
points to each of its members".

This means that we can use the same code to process both v4 and v6
addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlv.c,v 1.10 2016/02/21 18:56:49 renato Exp $ */
d303 1
a303 1
				log_debug("%s: invalid address length");
d309 1
a309 1
				log_debug("%s: invalid address length");
@


1.10
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).
@
text
@d1 1
a1 1
/*	$OpenBSD: tlv.c,v 1.9 2016/02/21 18:53:54 renato Exp $ */
a70 6
			if (ibuf_add(buf, &alen, sizeof(alen)))
				return (-1);
			if (ibuf_add(buf, &sa->addr.v4, sizeof(sa->addr.v4))) {
				log_warn("%s: ibuf_add failed", __func__);
				return (-1);
			}
a73 6
			if (ibuf_add(buf, &alen, sizeof(alen)))
				return (-1);
			if (ibuf_add(buf, &sa->addr.v6, sizeof(sa->addr.v6))) {
				log_warn("%s: ibuf_add failed", __func__);
				return (-1);
			}
d76 6
a81 1
			log_debug("%s: unknown address family", __func__);
d84 1
a299 3
		if ((sa = calloc(1, sizeof(*sa))) == NULL)
			fatal("tlv_decode_seq");
		sa->af = af;
a303 1
				free(sa);
a305 1
			memcpy(&sa->addr.v4, buf, sizeof(struct in_addr));
a309 1
				free(sa);
a311 1
			memcpy(&sa->addr.v6, buf, sizeof(struct in6_addr));
a313 1
			free(sa);
d316 6
a323 1
		TAILQ_INSERT_TAIL(seq_addr_list, sa, entry);
@


1.9
log
@Introduce the bad_addr() family of functions.

These functions improve code reusability as there's no more need to
check for all possible "bad" addresses in several different places.

Besides that, this patch introduce additional checks in the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlv.c,v 1.8 2016/02/21 18:40:56 renato Exp $ */
d222 1
a222 1
		memcpy(&emetric, &ri->emetric, sizeof(emetric));
d234 1
a234 1
	memcpy(&metric, &ri->metric, sizeof(metric));
@


1.8
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlv.c,v 1.7 2016/02/21 18:38:37 renato Exp $ */
a367 1
	in_addr_t	 ipv4;
a457 9

		/* check if the network is valid */
		ipv4 = ntohl(ri->prefix.v4.s_addr);
		if (((ipv4 >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET) ||
		    IN_MULTICAST(ipv4) || IN_BADCLASS(ipv4)) {
			log_debug("%s: malformed tlv (invalid ipv4 prefix)",
			    __func__);
			return (-1);
		}
a461 8

		/* check if the network is valid */
		if (IN6_IS_ADDR_LOOPBACK(&ri->prefix.v6) ||
		    IN6_IS_ADDR_MULTICAST(&ri->prefix.v6)) {
			log_debug("%s: malformed tlv (invalid ipv6 prefix)",
			    __func__);
			return (-1);
		}
d465 8
@


1.7
log
@Make eigrpd work against newer IOS routers.

Different versions of IOS can use a different number of bytes to encode
the same IPv6 prefix inside route TLVs. This sucks but we have to deal
with it.  Instead of calculating the number of bytes based on the value
of the prefixlen field, let's get this number by subtracting the size
of all other fields from the total size of the TLV. It works because
all the other fields have a fixed length.

For reference, the EIGRP draft says that length of the prefix field
should be obtained according to this function:

((Bit Count - 1) / 8) + 1

But older IOS versions use this for IPv6 (obtained through reverse
engineering):

((Bit Count == 128) ? 16 : ((Bit Count / 8) + 1))

Now, the new IOS-XR apparently uses the first formula for both IPv4 and
IPv6. With this patch, eigrpd will work against both older and newer
versions of IOS.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlv.c,v 1.6 2016/01/15 12:29:29 renato Exp $ */
d88 1
a88 1
			log_debug("%s: unkown address family", __func__);
@


1.6
log
@Split TLV constants into subcomponents to simplify the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlv.c,v 1.5 2015/10/21 03:48:09 renato Exp $ */
d367 1
a367 1
	int		 tlv_len, min_len, plen, offset;
d374 1
d378 1
d438 9
a446 10
	switch (af) {
	case AF_INET:
		plen = PREFIX_SIZE4(ri->prefixlen);
		break;
	case AF_INET6:
		plen = PREFIX_SIZE6(ri->prefixlen);
		break;
	default:
		fatalx("tlv_decode_route: unknown af");
	}
d449 2
a450 3
	if (plen != (tlv_len - min_len)) {
		log_debug("%s: malformed tlv (invalid prefix length)",
		    __func__);
@


1.5
log
@Minor fixes and code cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlv.c,v 1.4 2015/10/05 01:59:33 renato Exp $ */
d178 1
a178 8
		switch (ri->type) {
		case EIGRP_ROUTE_INTERNAL:
			tlv.type = htons(TLV_TYPE_IPV4_INTERNAL);
			break;
		case EIGRP_ROUTE_EXTERNAL:
			tlv.type = htons(TLV_TYPE_IPV4_EXTERNAL);
			break;
		}
d181 1
a181 8
		switch (ri->type) {
		case EIGRP_ROUTE_INTERNAL:
			tlv.type = htons(TLV_TYPE_IPV6_INTERNAL);
			break;
		case EIGRP_ROUTE_EXTERNAL:
			tlv.type = htons(TLV_TYPE_IPV6_EXTERNAL);
			break;
		}
d186 13
d365 1
a365 2
tlv_decode_route(int af, enum route_type type, struct tlv *tlv, char *buf,
    struct rinfo *ri)
d370 2
a371 2
	tlv_len = ntohs(tlv->length);
	switch (af) {
d381 7
a387 1
	if (type == EIGRP_ROUTE_EXTERNAL)
d389 4
d394 1
a399 3
	ri->af = af;
	ri->type = type;

d416 1
a416 1
	if (type == EIGRP_ROUTE_EXTERNAL) {
@


1.4
log
@When the SIA state is declared for a given destination, reset the
adjacency with the unresponsive neighbor(s).
@
text
@d1 1
a1 1
/*	$OpenBSD: tlv.c,v 1.3 2015/10/04 23:08:57 renato Exp $ */
d263 1
a263 1
                fatalx("gen_ipv4_internal_tlv: buf_seek failed");
@


1.3
log
@Ignore IPv4 TLVs in IPv6 instances and vice-versa.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlv.c,v 1.2 2015/10/04 23:00:10 renato Exp $ */
d32 1
a32 1
gen_parameter_tlv(struct ibuf *buf, struct eigrp_iface *ei)
d38 9
a46 1
	memcpy(tp.kvalues, ei->eigrp->kvalues, 6);
@


1.2
log
@Fix warnings and add safeguards to protect against corrupted data.
@
text
@d1 1
a1 1
/*	$OpenBSD: tlv.c,v 1.1 2015/10/02 04:26:47 renato Exp $ */
d275 1
a275 1
tlv_decode_seq(struct tlv *tlv, char *buf,
d301 8
a308 3
		switch (alen) {
		case INADDRSZ:
			sa->af = AF_INET;
d311 6
a316 2
		case IN6ADDRSZ:
			sa->af = AF_INET6;
a319 1
			log_debug("%s: unknown address length", __func__);
d321 1
a321 1
			return (-1);
d396 1
@


1.1
log
@Welcome eigrpd

The eigrpd daemon will support the Enhanced Interior Gateway Routing Protocol.

Built using the imsg/three process framework and heavily based on ospfd(8), ospf6d(8) and ldpd(8).

The current status of eigrpd(8) is as follows:
* Almost full compliance with the specification: DUAL FSM, RTP, CR mode, SIA, etc
* Support for both IPv4 and IPv6
* Support for multiple instances (different ASes/AFs) within the same process
* Support for rdomains (one process per rdomain)
* RIB/FIB synchronization
* Basic redistribution support

Not implemented features (yet):
* Configuration reload support (partially implemented)
* Route summarization
* Advanced route redistribution/filtering
* Carp integration
* Authentication (draft is missing information)
* Stub (not released by Cisco)

Not yet connected to the builds.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d190 1
a190 1
		break;
d210 1
a210 1
		break;
d249 1
a249 1
		break;
d365 1
a365 1
		break;
d389 1
a389 1
		break;
d421 1
a421 1
		break;
d459 1
a459 1
		break;
@

