head	1.14;
access;
symbols
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.22
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.20
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.18
	OPENBSD_5_0:1.9.0.16
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.14
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.12
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.8
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.10
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.6
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.4
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.8
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.6
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6;
locks; strict;
comment	@ * @;


1.14
date	2015.12.12.20.04.23;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	qUunq6kWElREuvSB;

1.13
date	2014.10.08.04.48.22;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	1ZrmZshPZICcJyFj;

1.12
date	2014.04.13.05.38.45;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2013.11.12.22.27.13;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2013.04.20.17.55.51;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.26.09.28.34;	author martynas;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.28.07.25.23;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.05.20.29.54;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.10.21.37.28;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.03.12.20.34;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.01.06.26.57;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.31.12.48.46;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.30.23.28.14;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.27.08.46.51;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Remove NULL-checks before free().
@
text
@/*	$OpenBSD: ntpleaps.c,v 1.13 2014/10/08 04:48:22 deraadt Exp $	*/

/*
 * Copyright (c) 2002 Thorsten Glaser. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

/* Leap second support for NTP clients (generic) */

/*
 * I could include tzfile.h, but this would make the code unportable
 * at no real benefit. Read tzfile.h for why.
 */

#include <sys/types.h>
#include <netinet/in.h>

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ntpleaps.h"

static u_int64_t *leapsecs;
static unsigned int leapsecs_num;

u_int32_t	read_be_dword(u_int8_t *ptr);


int
ntpleaps_init(void)
{
	static int doneinit;
	static int donewarn;

	if (doneinit)
		return (0);

	if (ntpleaps_read() == 0) {
		doneinit = 1;
		return (0);
	}

	/* This does not really hurt, but users will complain about
	 * off-by-22-seconds (at time of coding) errors if we don't warn.
	 */
	if (!donewarn) {
		fputs("Warning: error reading tzfile. You will NOT be\n"
		    "able to get legal time or posix compliance!\n", stderr);
		donewarn = 1;	/* put it only once */
	}

	return (-1);
}

int
ntpleaps_sub(u_int64_t *t)
{
	unsigned int i = 0;
	u_int64_t u;
	int r = 1;

	if (ntpleaps_init() == -1)
		return (-1);

	u = *t;

	while (i < leapsecs_num) {
		if (u < leapsecs[i]) {
			r--;
			break;
		}
		if (u == leapsecs[i++])
			break;
	}

	*t = u - i;
	return (r);
}

u_int32_t
read_be_dword(u_int8_t *ptr)
{
	u_int32_t res;

	memcpy(&res, ptr, 4);
	return (ntohl(res));
}


int
ntpleaps_read(void)
{
	int fd;
	unsigned int r;
	u_int8_t buf[32];
	u_int32_t m1, m2, m3;
	u_int64_t s;
	u_int64_t *l;

	fd = open("/usr/share/zoneinfo/right/UTC", O_RDONLY | O_NDELAY);
	if (fd == -1)
		return (-1);

	/* Check signature */
	read(fd, buf, 4);
	buf[4] = 0;
	if (strcmp((const char *)buf, "TZif")) {
		close(fd);
		return (-1);
	}

	/* Pre-initialize buf[24..27] so we need not check read(2) result */
	buf[24] = 0;
	buf[25] = 0;
	buf[26] = 0;
	buf[27] = 0;

	/* Skip uninteresting parts of header */
	read(fd, buf, 28);

	/* Read number of leap second entries */
	r = read_be_dword(&buf[24]);
	/* Check for plausibility - arbitrary values */
	if ((r < 20) || (r > 60000)) {
		close(fd);
		return (-1);
	}
	if ((l = reallocarray(NULL, r, sizeof(u_int64_t))) == NULL) {
		close(fd);
		return (-1);
	}

	/* Skip further uninteresting stuff */
	read(fd, buf, 12);
	m1 = read_be_dword(buf);
	m2 = read_be_dword(&buf[4]);
	m3 = read_be_dword(&buf[8]);
	m3 += (m1 << 2)+m1+(m2 << 2)+(m2 << 1);
	lseek(fd, (off_t)m3, SEEK_CUR);

	/* Now go parse the tzfile leap second info */
	for (m1 = 0; m1 < r; m1++) {
		if (read(fd, buf, 8) != 8) {
			free(l);
			close(fd);
			return (-1);
		}
		s = SEC_TO_TAI64(read_be_dword(buf));
		/*
		 * Assume just _one_ leap second on each entry, and compensate
		 * the lacking error checking by validating the first entry
		 * against the known value
		 */
		if (!m1 && s != 0x4000000004B2580AULL) {
			free(l);
			close(fd);
			return (-1);
		}
		l[m1] = s;
	}

	/* Clean up and activate the table */
	close(fd);
	free(leapsecs);
	leapsecs = l;
	leapsecs_num = r;
	return (0);
}
@


1.13
log
@use reallocarray().  BTW << 3 is a sloppy compared to * sizeof(u_int64_t)...
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpleaps.c,v 1.12 2014/04/13 05:38:45 jsg Exp $	*/
d191 1
a191 2
	if (leapsecs != NULL)
		free(leapsecs);
@


1.12
log
@remove a 'RCSId[]' which was missed in the rcsid[] removal from 2009.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpleaps.c,v 1.11 2013/11/12 22:27:13 deraadt Exp $	*/
d155 1
a155 1
	if ((l = (u_int64_t *)malloc(r << 3)) == NULL) {
@


1.11
log
@ensure there are prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpleaps.c,v 1.10 2013/04/20 17:55:51 deraadt Exp $	*/
a32 3

static const char RCSId[] = "$OpenBSD: ntpleaps.c,v 1.10 2013/04/20 17:55:51 deraadt Exp $";

@


1.10
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpleaps.c,v 1.9 2007/11/26 09:28:34 martynas Exp $	*/
d34 1
a34 1
static const char RCSId[] = "$OpenBSD: ntpleaps.c,v 1.9 2007/11/26 09:28:34 martynas Exp $";
d55 2
@


1.9
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpleaps.c,v 1.8 2006/01/28 07:25:23 tedu Exp $	*/
d34 1
a34 1
static const char RCSId[] = "$OpenBSD: ntpleaps.c,v 1.8 2006/01/28 07:25:23 tedu Exp $";
d62 1
a62 1
	
@


1.8
log
@simplify statics, remove stupid goto, plug a leak.  ok moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpleaps.c,v 1.7 2004/05/05 20:29:54 jakob Exp $	*/
d34 1
a34 1
static const char RCSId[] = "$OpenBSD: ntpleaps.c,v 1.7 2004/05/05 20:29:54 jakob Exp $";
d140 1
a140 1
	/* Pre-initalize buf[24..27] so we need not check read(2) result */
@


1.7
log
@simplify license. ok author.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpleaps.c,v 1.6 2002/08/10 21:37:28 jakob Exp $	*/
d34 1
a34 1
static const char RCSId[] = "$OpenBSD: ntpleaps.c,v 1.6 2002/08/10 21:37:28 jakob Exp $";
d53 2
a54 4
u_int64_t *leapsecs = NULL;
unsigned int leapsecs_num = 0;
static int flaginit = -1;
static int flagwarn = 0;
d60 4
a63 1
	if (!flaginit)
d66 2
a67 2
	if (!ntpleaps_read()) {
		flaginit = 0;
d74 1
a74 1
	if (!flagwarn) {
d77 1
a77 1
		flagwarn = 1;	/* put it only once */
d90 1
a90 1
	if ((flaginit ? ntpleaps_init() : 0) == -1)
d96 2
a97 1
		if (u < leapsecs[i])
d99 1
d101 1
a101 1
			goto do_sub;
a102 1
	--r;
a103 1
do_sub:
d182 3
a184 1
		if (!m1 && s != 0x4000000004B2580AULL)
d186 1
@


1.6
log
@style; from thorsten
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpleaps.c,v 1.5 2002/08/03 12:20:34 jakob Exp $	*/
d4 1
a4 1
 * Copyright (c) 2002 by Thorsten "mirabile" Glaser <x86@@ePOST.de>
d6 23
a28 7
 * Permission is hereby granted to any person obtaining a copy of this work
 * to deal in the work, without restrictions, including unlimited rights to
 * use, copy, modify, merge, publish, distribute, sublicense or sell copies
 * of the work, and to permit persons to whom the work is furnished to also
 * do so, as long as due credit is given to the original author and contri-
 * butors, and the following disclaimer is kept in all substantial portions
 * of the work or accompanying documentation:
a29 6
 * This work is provided "AS IS", without warranty of any kind, neither ex-
 * press nor implied, including, but not limited to, the warranties of mer-
 * chantability, fitness for particular purposes and noninfringement. In NO
 * event shall the author and contributors be liable for any claim, damages
 * and such, whether in contract, strict liability or otherwise, arising in
 * any way out of this work, even if advised of the possibility of such.
d34 1
a34 1
static const char RCSId[] = "$OpenBSD: ntpleaps.c,v 1.5 2002/08/03 12:20:34 jakob Exp $";
@


1.5
log
@check return value from read; from thorsten
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpleaps.c,v 1.4 2002/08/01 06:26:57 jakob Exp $	*/
d24 1
a24 1
static const char RCSId[] = "$OpenBSD: ntpleaps.c,v 1.4 2002/08/01 06:26:57 jakob Exp $";
d32 3
d40 1
a40 1
#include <sys/types.h>
@


1.4
log
@knf and minor tweeking from thorsten
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d24 1
a24 1
static const char RCSId[] = "$OpenBSD: ntpleaps.c,v 1.3 2002/07/31 12:48:46 jakob Exp $";
d157 5
a161 1
		read(fd, buf, 8);
@


1.3
log
@minor changes and knf from thorsten glaser
@
text
@d1 1
a1 1
/*	$OpenBSD: ntpleaps.c,v 1.1 2002/07/27 08:46:51 jakob Exp $	*/
d24 1
a24 1
static const char RCSId[] = "$OpenBSD: ntpleaps.c,v 1.2 2002/07/30 23:28:14 deraadt Exp $";
d27 2
a28 1
/* I could include tzfile.h, but this would make the code unportable
d35 1
d42 1
a42 1
static int flaginit = 0;
d49 2
a50 2
	if (flaginit)
		return 0;
d53 2
a54 2
		flaginit = 1;
		return(0);
d74 1
a74 1
	int r=1;
d76 2
a77 2
	if (ntpleaps_init() == -1)
		return(-1);
d81 1
a81 1
	while (i<leapsecs_num) {
d90 1
a90 1
	*t=u-i;
d94 10
d110 1
a110 1
	u_int32_t m1,m2,m3;
d136 1
a136 1
	r = ntohl(*((u_int32_t *) (buf + 24)));
d138 1
a138 1
	if (r < 20 || r > 60000) {
d149 3
a151 3
	m1 = ntohl(*((u_int32_t *)(buf)));
	m2 = ntohl(*((u_int32_t *)(buf+4)));
	m3 = ntohl(*((u_int32_t *)(buf+8)));
d158 1
a158 2
		m2 = ntohl(*((u_int32_t *)buf));
		s = SEC_TO_TAI64(m2);
@


1.2
log
@knf
@
text
@d1 1
a1 1
/*	$Id: ntpleaps.c,v 1.1 2002/07/27 08:46:51 jakob Exp $	*/
d24 1
a24 1
static const char RCSId[] = "$OpenBSD: ntpleaps.c,v 1.1 2002/07/27 08:46:51 jakob Exp $";
d147 1
a147 1
		s = NTPLEAPS_OFFSET + (u_int64_t)m2;
@


1.1
log
@leapsecond support; written by thorsten glaser; ok millert@@
@
text
@d1 1
a1 1
/*	$Id$	*/
d24 1
a24 1
static const char RCSId[] = "$OpenBSD$";
d58 1
a58 1
	if(!flagwarn) {
d107 3
a109 2
	read(fd, buf, 4); buf[4]=0;
	if(strcmp((const char *)buf, "TZif")) {
d124 1
a124 1
	r=ntohl( *((u_int32_t *) (buf + 24)) );
d126 1
a126 1
	if( (r<20) || (r>60000) ) {
d130 1
a130 1
	if(( l = (u_int64_t *) malloc(r << 3)) == NULL) {
d137 3
a139 3
	m1 = ntohl( *((u_int32_t *)(buf)) );
	m2 = ntohl( *((u_int32_t *)(buf+4)) );
	m3 = ntohl( *((u_int32_t *)(buf+8)) );
d144 1
a144 1
	for (m1=0; m1<r; m1++) {
d146 8
a153 6
		m2 = ntohl( *((u_int32_t *)buf) );
		s = NTPLEAPS_OFFSET + (u_int64_t) m2;
	/* Assume just _one_ leap second on each entry, and compensate
	 * the lacking error checking by validating the first entry
	 * against the known value */
		if(!m1 && s != 0x4000000004B2580AULL)
a163 1

@

