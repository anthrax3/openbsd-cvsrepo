head	1.33;
access;
symbols
	OPENBSD_6_1:1.33.0.12
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.8
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.4
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.33.0.6
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.31.0.14
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.12
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.8
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.6
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.4
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.2
	OPENBSD_5_0:1.30.0.6
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.4
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.12
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.14
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.10
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.8
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.6
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.4
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.27.0.6
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.4
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13;
locks; strict;
comment	@ * @;


1.33
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	Uu5nFG3wCl0LACBb;

1.32
date	2014.10.29.04.00.44;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	7PXyEcyt3fjEVxRT;

1.31
date	2011.12.28.21.39.30;	author sthen;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.16.11.09.26;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2006.09.17.17.03.56;	author ckuethe;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.14.22.56.20;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2004.10.26.09.48.59;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.10.24.18.47.43;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.15.01.11.12;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.15.01.05.09;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.14.20.11.16;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.17.18.09.33;	author alexander;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.09.07.15.56;	author alexander;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.05.19.18.56;	author alexander;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.30.22.57.42;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.30.22.41.15;	author jakob;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.26.16.38.44;	author jakob;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.18.17.25.18;	author jakob;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.16.21.25.41;	author jakob;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.14.18.06.21;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.08.12.33.42;	author jakob;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.10.21.37.28;	author jakob;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.31.12.48.46;	author jakob;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.28.07.48.29;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.27.20.11.34;	author jakob;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.27.08.47.19;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.14.21.35.01;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.16.22.00.37;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.16.21.05.24;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.16.15.01.32;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.16.11.00.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.16.10.52.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.16.10.46.34;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: ntp.c,v 1.32 2014/10/29 04:00:44 deraadt Exp $	*/

/*
 * Copyright (c) 1996, 1997 by N.M. Maclaren. All rights reserved.
 * Copyright (c) 1996, 1997 by University of Cambridge. All rights reserved.
 * Copyright (c) 2002 by Thorsten "mirabile" Glaser.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the university may be used to
 *    endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <poll.h>
#include <unistd.h>

#include "ntpleaps.h"

/*
 * NTP definitions.  Note that these assume 8-bit bytes - sigh.  There
 * is little point in parameterising everything, as it is neither
 * feasible nor useful.  It would be very useful if more fields could
 * be defined as unspecified.  The NTP packet-handling routines
 * contain a lot of extra assumptions.
 */

#define JAN_1970   2208988800.0		/* 1970 - 1900 in seconds */
#define NTP_SCALE  4294967296.0		/* 2^32, of course! */

#define NTP_MODE_CLIENT       3		/* NTP client mode */
#define NTP_MODE_SERVER       4		/* NTP server mode */
#define NTP_VERSION           4		/* The current version */
#define NTP_VERSION_MIN       1		/* The minimum valid version */
#define NTP_VERSION_MAX       4		/* The maximum valid version */
#define NTP_STRATUM_MAX      14		/* The maximum valid stratum */
#define NTP_INSANITY     3600.0		/* Errors beyond this are hopeless */

#define NTP_PACKET_MIN       48		/* Without authentication */
#define NTP_PACKET_MAX       68		/* With authentication (ignored) */

#define NTP_DISP_FIELD        8		/* Offset of dispersion field */
#define NTP_REFERENCE        16		/* Offset of reference timestamp */
#define NTP_ORIGINATE        24		/* Offset of originate timestamp */
#define NTP_RECEIVE          32		/* Offset of receive timestamp */
#define NTP_TRANSMIT         40		/* Offset of transmit timestamp */

#define STATUS_NOWARNING      0		/* No Leap Indicator */
#define STATUS_LEAPHIGH       1		/* Last Minute Has 61 Seconds */
#define STATUS_LEAPLOW        2		/* Last Minute Has 59 Seconds */
#define STATUS_ALARM          3		/* Server Clock Not Synchronized */

#define MAX_QUERIES         25
#define MAX_DELAY           15

#define MILLION_L    1000000l		/* For conversion to/from timeval */
#define MILLION_D       1.0e6		/* Must be equal to MILLION_L */

struct ntp_data {
	u_char		status;
	u_char		version;
	u_char		mode;
	u_char		stratum;
	double		receive;
	double		transmit;
	double		current;
	u_int64_t	recvck;

	/* Local State */
	double		originate;
	u_int64_t	xmitck;
};

void	ntp_client(const char *, int, struct timeval *, struct timeval *, int);
int	sync_ntp(int, const struct sockaddr *, double *, double *);
int	write_packet(int, struct ntp_data *);
int	read_packet(int, struct ntp_data *, double *, double *);
void	unpack_ntp(struct ntp_data *, u_char *);
double	current_time(double);
void	create_timeval(double, struct timeval *, struct timeval *);

#ifdef DEBUG
void	print_packet(const struct ntp_data *);
#endif

int	corrleaps;

void
ntp_client(const char *hostname, int family, struct timeval *new,
    struct timeval *adjust, int leapflag)
{
	struct addrinfo hints, *res0, *res;
	double offset, error;
	int accept = 0, ret, s, ierror;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = family;
	hints.ai_socktype = SOCK_DGRAM;
	ierror = getaddrinfo(hostname, "ntp", &hints, &res0);
	if (ierror) {
		errx(1, "%s: %s", hostname, gai_strerror(ierror));
		/*NOTREACHED*/
	}

	corrleaps = leapflag;
	if (corrleaps)
		ntpleaps_init();

	s = -1;
	for (res = res0; res; res = res->ai_next) {
		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
		if (s < 0)
			continue;

		ret = sync_ntp(s, res->ai_addr, &offset, &error);
		if (ret < 0) {
#ifdef DEBUG
			fprintf(stderr, "try the next address\n");
#endif
			close(s);
			s = -1;
			continue;
		}

		accept++;
		break;
	}
	freeaddrinfo(res0);

#ifdef DEBUG
	fprintf(stderr, "Correction: %.6f +/- %.6f\n", offset, error);
#endif

	if (accept < 1)
		errx(1, "Unable to get a reasonable time estimate");

	create_timeval(offset, new, adjust);
}

int
sync_ntp(int fd, const struct sockaddr *peer, double *offset, double *error)
{
	int attempts = 0, accepts = 0, rejects = 0;
	int delay = MAX_DELAY, ret;
	double deadline;
	double a, b, x, y;
	double minerr = 0.1;		/* Maximum ignorable variation */
	struct ntp_data data;

	deadline = current_time(JAN_1970) + delay;
	*offset = 0.0;
	*error = NTP_INSANITY;

	if (connect(fd, peer, SA_LEN(peer)) < 0) {
		warn("Failed to connect to server");
		return (-1);
	}

	while (accepts < MAX_QUERIES && attempts < 2 * MAX_QUERIES) {
		memset(&data, 0, sizeof(data));

		if (current_time(JAN_1970) > deadline) {
			warnx("Not enough valid responses received in time");
			return (-1);
		}

		if (write_packet(fd, &data) < 0)
			return (-1);

		ret = read_packet(fd, &data, &x, &y);

		if (ret < 0)
			return (-1);
		else if (ret > 0) {
#ifdef DEBUG
			print_packet(&data);
#endif

			if (++rejects > MAX_QUERIES) {
				warnx("Too many bad or lost packets");
				return (-1);
			} else
				continue;
		} else
			++accepts;

#ifdef DEBUG
		fprintf(stderr, "Offset: %.6f +/- %.6f\n", x, y);
#endif

		if ((a = x - *offset) < 0.0)
			a = -a;
		if (accepts <= 1)
			a = 0.0;
		b = *error + y;
		if (y < *error) {
			*offset = x;
			*error = y;
		}

#ifdef DEBUG
		fprintf(stderr, "Best: %.6f +/- %.6f\n", *offset, *error);
#endif

		if (a > b) {
			warnx("Inconsistent times received from NTP server");
			return (-1);
		}

		if ((data.status & STATUS_ALARM) == STATUS_ALARM) {
			warnx("Ignoring NTP server with alarm flag set");
			return (-1);
		}

		if (*error <= minerr)
			break;
	}

	return (accepts);
}

/* Send out NTP packet. */
int
write_packet(int fd, struct ntp_data *data)
{
	u_char	packet[NTP_PACKET_MIN];
	ssize_t	length;

	memset(packet, 0, sizeof(packet));

	packet[0] = (NTP_VERSION << 3) | (NTP_MODE_CLIENT);

	arc4random_buf(&data->xmitck, sizeof(data->xmitck));

	/*
	 * Send out a random 64-bit number as our transmit time.  The NTP
	 * server will copy said number into the originate field on the
	 * response that it sends us.  This is totally legal per the SNTP spec.
	 *
	 * The impact of this is two fold: we no longer send out the current
	 * system time for the world to see (which may aid an attacker), and
	 * it gives us a (not very secure) way of knowing that we're not
	 * getting spoofed by an attacker that can't capture our traffic
	 * but can spoof packets from the NTP server we're communicating with.
	 *
	 * No endian concerns here.  Since we're running as a strict
	 * unicast client, we don't have to worry about anyone else finding
	 * the transmit field intelligible.
	 */

	bcopy(&data->xmitck, (packet + NTP_TRANSMIT), sizeof(data->xmitck));

	data->originate = current_time(JAN_1970);

	length = write(fd, packet, sizeof(packet));

	if (length != sizeof(packet)) {
		warn("Unable to send NTP packet to server");
		return (-1);
	}

	return (0);
}

/*
 * Check the packet and work out the offset and optionally the error.
 * Note that this contains more checking than xntp does. Return 0 for
 * success, 1 for failure. Note that it must not change its arguments
 * if it fails.
 */
int
read_packet(int fd, struct ntp_data *data, double *off, double *error)
{
	u_char	receive[NTP_PACKET_MAX];
	struct	pollfd pfd[1];
	double	x, y;
	int	length, r;

	pfd[0].fd = fd;
	pfd[0].events = POLLIN;

retry:
	r = poll(pfd, 1, 1000 * MAX_DELAY / MAX_QUERIES);
	if (r < 0) {
		if (errno == EINTR)
			goto retry;
		warn("select");
		return (r);
	}

	if (r != 1)
		return (1);
	if ((pfd[0].revents & POLLIN) == 0)
		return (1);

	length = read(fd, receive, NTP_PACKET_MAX);
	if (length < 0) {
		warn("Unable to receive NTP packet from server");
		return (-1);
	}

	if (length < NTP_PACKET_MIN || length > NTP_PACKET_MAX) {
		warnx("Invalid NTP packet size, packet rejected");
		return (1);
	}

	unpack_ntp(data, receive);

	if (data->recvck != data->xmitck) {
		warnx("Invalid cookie received, packet rejected");
		return (1);
	}

	if (data->version < NTP_VERSION_MIN ||
	    data->version > NTP_VERSION_MAX) {
		warnx("Received NTP version %u, need %u or lower",
		    data->version, NTP_VERSION);
		return (1);
	}

	if (data->mode != NTP_MODE_SERVER) {
		warnx("Invalid NTP server mode, packet rejected");
		return (1);
	}

	if (data->stratum > NTP_STRATUM_MAX) {
		warnx("Invalid stratum received, packet rejected");
		return (1);
	}

	if (data->transmit == 0.0) {
		warnx("Server clock invalid, packet rejected");
		return (1);
	}

	x = data->receive - data->originate;
	y = data->transmit - data->current;

	*off = (x + y) / 2;
	*error = x - y;

	x = (data->current - data->originate) / 2;

	if (x > *error)
		*error = x;

	return (0);
}

/*
 * Unpack the essential data from an NTP packet, bypassing struct
 * layout and endian problems.  Note that it ignores fields irrelevant
 * to SNTP.
 */
void
unpack_ntp(struct ntp_data *data, u_char *packet)
{
	int i;
	double d;

	data->current = current_time(JAN_1970);

	data->status = (packet[0] >> 6);
	data->version = (packet[0] >> 3) & 0x07;
	data->mode = packet[0] & 0x07;
	data->stratum = packet[1];

	for (i = 0, d = 0.0; i < 8; ++i)
	    d = 256.0*d+packet[NTP_RECEIVE+i];

	data->receive = d / NTP_SCALE;

	for (i = 0, d = 0.0; i < 8; ++i)
	    d = 256.0*d+packet[NTP_TRANSMIT+i];

	data->transmit = d / NTP_SCALE;

	/* See write_packet for why this isn't an endian problem. */
	bcopy((packet + NTP_ORIGINATE), &data->recvck, sizeof(data->recvck));
}

/*
 * Get the current UTC time in seconds since the Epoch plus an offset
 * (usually the time from the beginning of the century to the Epoch)
 */
double
current_time(double offset)
{
	struct timeval current;
	u_int64_t t;

	if (gettimeofday(&current, NULL))
		err(1, "Could not get local time of day");

	/*
	 * At this point, current has the current TAI time.
	 * Now subtract leap seconds to set the posix tick.
	 */

	t = SEC_TO_TAI64(current.tv_sec);
	if (corrleaps)
		ntpleaps_sub(&t);

	return (offset + TAI64_TO_SEC(t) + 1.0e-6 * current.tv_usec);
}

/*
 * Change offset into current UTC time. This is portable, even if
 * struct timeval uses an unsigned long for tv_sec.
 */
void
create_timeval(double difference, struct timeval *new, struct timeval *adjust)
{
	struct timeval old;
	long n;

	/* Start by converting to timeval format. Note that we have to
	 * cater for negative, unsigned values. */
	if ((n = (long) difference) > difference)
		--n;
	adjust->tv_sec = n;
	adjust->tv_usec = (long) (MILLION_D * (difference-n));
	errno = 0;
	if (gettimeofday(&old, NULL))
		err(1, "Could not get local time of day");
	new->tv_sec = old.tv_sec + adjust->tv_sec;
	new->tv_usec = (n = (long) old.tv_usec + (long) adjust->tv_usec);

	if (n < 0) {
		new->tv_usec += MILLION_L;
		--new->tv_sec;
	} else if (n >= MILLION_L) {
		new->tv_usec -= MILLION_L;
		++new->tv_sec;
	}
}

#ifdef DEBUG
void
print_packet(const struct ntp_data *data)
{
	printf("status:      %u\n", data->status);
	printf("version:     %u\n", data->version);
	printf("mode:        %u\n", data->mode);
	printf("stratum:     %u\n", data->stratum);
	printf("originate:   %f\n", data->originate);
	printf("receive:     %f\n", data->receive);
	printf("transmit:    %f\n", data->transmit);
	printf("current:     %f\n", data->current);
	printf("xmitck:      0x%0llX\n", data->xmitck);
	printf("recvck:      0x%0llX\n", data->recvck);
};
#endif
@


1.32
log
@use poll() instead of select(), thereby removing the fd_set malloc/free
dance which was used to avoid fd_set overflow with high file descriptor
values.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.31 2011/12/28 21:39:30 sthen Exp $	*/
a31 1
#include <sys/param.h>
@


1.31
log
@s/minum/minimum/ in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.30 2010/08/16 11:09:26 krw Exp $	*/
d50 1
d268 1
a268 1
	data->xmitck = (u_int64_t)arc4random() << 32 | arc4random();
d310 1
a310 1
	struct	timeval tv;
a312 1
	fd_set	*rfds;
d314 2
a315 5
	rfds = calloc(howmany(fd + 1, NFDBITS), sizeof(fd_mask));
	if (rfds == NULL)
		err(1, "calloc");

	FD_SET(fd, rfds);
d318 1
a318 5
	tv.tv_sec = 0;
	tv.tv_usec = 1000000 * MAX_DELAY / MAX_QUERIES;

	r = select(fd + 1, rfds, NULL, NULL, &tv);

d322 1
a322 4
		else
			warn("select");

		free(rfds);
d326 3
a328 2
	if (r != 1 || !FD_ISSET(fd, rfds)) {
		free(rfds);
a329 3
	}

	free(rfds);
a331 1

@


1.30
log
@Fix another gcc4 mis-alignment, by using bcopy() rather than
(u_int64_t *)charptr = value.

Problem reported by Daniel Ouellet, first diff from matthieu@@,
another from naddy@@ equivalent to this one.

ok millert@@ dlg@@ (for naddy's) deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.29 2006/09/17 17:03:56 ckuethe Exp $	*/
d68 1
a68 1
#define NTP_VERSION_MIN       1		/* The minum valid version */
@


1.29
log
@Make rdate ignore ntp responses with ALARM status.
"yeah..." henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.28 2006/03/14 22:56:20 deraadt Exp $	*/
d285 1
a285 1
	*(u_int64_t *)(packet + NTP_TRANSMIT) = data->xmitck;
d427 1
a427 1
	data->recvck = *(u_int64_t *)(packet + NTP_ORIGINATE);
@


1.28
log
@#ifdef DEBUG not #if DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.27 2004/10/26 09:48:59 henning Exp $	*/
d241 5
@


1.27
log
@make the ntp version check even better, use NTP_VERSION_MIN and _MAX
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.26 2004/10/24 18:47:43 henning Exp $	*/
d116 1
a116 1
#if DEBUG
@


1.26
log
@accept replies with a NTP version number of 4 or lower, instead of only 4
as before, we can handle all versions
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.25 2004/09/15 01:11:12 henning Exp $	*/
d357 2
a358 1
	if (data->version > NTP_VERSION) {
@


1.25
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.24 2004/09/15 01:05:09 henning Exp $	*/
d357 3
a359 3
	if (data->version != NTP_VERSION) {
		warnx("Received different NTP version than sent,"
		      "packet rejected");
@


1.24
log
@don't refuse packets with stratum=0, they are fine
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.23 2004/07/14 20:11:16 henning Exp $	*/
d165 1
a165 1
	fprintf(stderr,"Correction: %.6f +/- %.6f\n", offset,error);
d168 1
a168 1
	if (accept < 1) {
a169 1
	}
d190 1
a190 1
		return -1;
d198 1
a198 1
			return -1;
d202 1
a202 1
			return -1;
d207 1
a207 1
			return -1;
d215 1
a215 1
				return -1;
d222 1
a222 2
		fprintf(stderr,"Offset: %.6f +/- %.6f\n",
			x, y);
d236 1
a236 1
		fprintf(stderr,"Best: %.6f +/- %.6f\n", *offset, *error);
d241 1
a241 1
			return -1;
d248 1
a248 1
	return accepts;
d288 1
a288 1
		return -1;
d291 1
a291 1
	return 0;
d309 1
a309 2
	rfds = (fd_set *)calloc(howmany(fd + 1, NFDBITS), sizeof(fd_mask));

d328 1
a328 2

		return r;
d333 1
a333 2

		return 1;
d342 1
a342 1
		return -1;
d347 1
a347 1
		return 1;
d354 1
a354 1
		return 1;
d360 1
a360 1
		return 1;
d365 1
a365 1
		return 1;
d370 1
a370 1
		return 1;
d375 1
a375 1
		return 1;
d389 1
a389 1
	return 0;
d412 2
a413 1
	data->receive = d/NTP_SCALE;
d417 2
a418 1
	data->transmit = d/NTP_SCALE;
d446 1
a446 1
	return offset + TAI64_TO_SEC(t) + 1.0e-6 * current.tv_usec;
@


1.23
log
@do not bail out if the server says its clock is unsynchronized.
rdate is a simple client and doesn't have another server to query,
and a server's idea of the time is better than the local clock's
one in basically any case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.22 2004/06/17 18:09:33 alexander Exp $	*/
a69 1
#define NTP_STRATUM_MIN       1		/* The minum valid stratum */
d373 1
a373 2
	if (data->stratum < NTP_STRATUM_MIN ||
	    data->stratum > NTP_STRATUM_MAX) {
@


1.22
log
@err on calloc failure; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.21 2004/06/09 07:15:56 alexander Exp $	*/
a376 5
		return 1;
	}

	if (data->status == STATUS_ALARM) {
		warnx("Server clock not synchronized, packet rejected");
@


1.21
log
@  * Bring rdate's SNTP support into compliance with SNTPv4 (RFC 2030).
  * More robust handling of NTP error conditions (e.g. host or
    service unreachable).
  * Improve the detection of stale and/or spoofed NTP responses
    from servers.
  * Add support for getaddrinfo(3)'s multiple host support if
    error conditions occur (e.g. round-robin DNS, and the first
    NTP server isn't responding, try the next host in line).
  * Minor formatting/code cleanup.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.20 2004/06/05 19:18:56 alexander Exp $	*/
d313 3
a315 4
	if (!rfds) {
		warnx("calloc() failed");
		return 1;
	}
@


1.20
log
@Typo correction, and consistency changes.

ok jakob@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.19 2004/05/30 22:57:42 deraadt Exp $	*/
d67 1
a67 1
#define NTP_VERSION           3		/* The current version */
d71 1
a71 1
#define NTP_STRATUM_MAX      15		/* The maximum valid stratum */
d95 12
a106 15
	u_char	status;
	u_char	version;
	u_char	mode;
	u_char	stratum;
	u_char	polling;
	u_char	precision;
	double	dispersion;
	double	reference;
	double	originate;
	double	receive;
	double	transmit;
	double	current;

	u_int64_t xmitck;
	u_int64_t recvck;
d111 3
a113 5
void	make_packet(struct ntp_data *);
int	write_packet(int, const struct sockaddr *, struct ntp_data *);
int	read_packet(int, struct ntp_data *, double *, double *, double *);
void	pack_ntp(u_char *, int, struct ntp_data *);
void	unpack_ntp(struct ntp_data *, u_char *, int);
d117 4
d129 1
a129 1
	int packets = 0, s, ierror;
d150 2
a151 2
		packets = sync_ntp(s, res->ai_addr, &offset, &error);
		if (packets == 0) {
d159 2
a160 4
		if (error > NTP_INSANITY) {
			/* should we try the next address instead? */
			errx(1, "Unable to get a reasonable time estimate");
		}
d169 4
d180 1
a180 1
	int delay = MAX_DELAY;
a183 1
	double dispersion = 0.0;	/* The source dispersion in seconds */
d190 5
d196 1
a196 2
		if (current_time(JAN_1970) > deadline)
			errx(1, "Not enough valid responses received in time");
d198 9
a206 2
		make_packet(&data);
		write_packet(fd, peer, &data);
d208 12
a219 5
		if (read_packet(fd, &data, &x, &y, &dispersion)) {
			if (++rejects > MAX_QUERIES)
				errx(1, "Too many bad or lost packets");
			else
			  continue;
d224 2
a225 2
		fprintf(stderr,"Offset: %.6f +/- %.6f disp=%.6f\n",
		    x, y, dispersion);
d242 4
a245 2
		if (a > b)
			errx(1, "Inconsistent times received from NTP server");
d254 3
a256 3
/* Create an outgoing NTP packet */
void
make_packet(struct ntp_data *data)
d258 6
a263 10
	data->status = STATUS_NOWARNING;
	data->version = NTP_VERSION;
	data->mode = NTP_MODE_CLIENT;
	data->stratum = 0;
	data->polling = 0;
	data->precision = 0;
	data->reference = data->dispersion = 0.0;
	data->receive = 0.0;
	data->current = data->transmit = current_time(JAN_1970);
	data->originate = data->transmit;
d265 1
d278 3
d283 3
a285 3
	data->xmitck = ((u_int64_t)arc4random() << 32) | arc4random();
	data->recvck = 0;
}
d287 1
a287 5
int
write_packet(int fd, const struct sockaddr *peer, struct ntp_data *data)
{
	u_char	transmit[NTP_PACKET_MIN];
	ssize_t	length;
d289 3
a291 5
	pack_ntp(transmit, NTP_PACKET_MIN, data);
	length = sendto(fd, transmit, NTP_PACKET_MIN, 0, peer, SA_LEN(peer));
	if (length == -1) {
		warnx("Unable to send NTP packet to server");
		return 1;
d304 1
a304 2
read_packet(int fd, struct ntp_data *data, double *off, double *error,
    double *dispersion)
d306 3
a308 2
	u_char	receive[NTP_PACKET_MAX+1];
	double	delay, x, y;
a310 1
	struct	timeval tv;
d325 13
a337 7
	if (r < 1 || !FD_ISSET(fd, rfds)) {
		if (r < 0) {
			if (errno == EINTR)
				goto retry;
			else
				warnx("select() failed");
		}
d339 1
d342 1
d345 2
a346 1
	length = recvfrom(fd, receive, NTP_PACKET_MAX + 1, 0, NULL, 0);
d348 2
a349 2
		warnx("Unable to receive NTP packet from server");
		return 1;
d357 1
a357 1
	unpack_ntp(data, receive, length);
d364 3
a366 3
	if (data->version < NTP_VERSION_MIN ||
	    data->version > NTP_VERSION_MAX) {
		warnx("Invalid NTP version, packet rejected");
d375 6
d386 2
a387 16
	/*
	 * Note that the conventions are very poorly defined in the NTP
	 * protocol, so we have to guess.  Any full NTP server perpetrating
	 * completely unsynchronised packets is an abomination, anyway, so
	 * reject it.
	 */
	delay = data->transmit - data->receive;

	if (data->reference == 0.0 ||
	    data->transmit == 0.0 ||
	    data->receive == 0.0 ||
	    (data->reference != 0.0 && data->receive < data->reference) ||
	    delay < 0.0 ||
	    delay > NTP_INSANITY ||
	    data->dispersion > NTP_INSANITY) {
		warnx("Incomprehensible NTP packet rejected");
a390 3
	if (*dispersion < data->dispersion)
		*dispersion = data->dispersion;

d392 1
a392 9
	y = (data->transmit == 0.0 ? 0.0 : data->transmit-data->current);
	*off = 0.5*(x+y);
	*error = x-y;
	x = data->current - data->originate;
	if (0.5*x > *error)
		*error = 0.5*x;

	return 0;
}
d394 2
a395 10
/*
 * Pack the essential data into an NTP packet, bypassing struct layout
 * and endian problems.  Note that it ignores fields irrelevant to
 * SNTP.
 */
void
pack_ntp(u_char	*packet, int length, struct ntp_data *data)
{
	int i, k;
	double d;
d397 1
a397 1
	memset(packet,0, (size_t)length);
d399 2
a400 11
	packet[0] = (data->status<<6)|(data->version<<3)|data->mode;
	packet[1] = data->stratum;
	packet[2] = data->polling;
	packet[3] = data->precision;

	d = data->receive/NTP_SCALE;
	for (i = 0; i < 8; ++i) {
		if ((k = (int)(d *= 256.0)) >= 256) k = 255;
		packet[NTP_RECEIVE+i] = k;
		d -= k;
	}
d402 1
a402 7
	/*
	 * No endian concerns here.  Since we're running as a strict
	 * unicast client, we don't have to worry about anyone else finding
	 * this field intelligible.
	 */

	*(u_int64_t *)(packet + NTP_TRANSMIT) = data->xmitck;
d411 1
a411 1
unpack_ntp(struct ntp_data *data, u_char *packet, int length)
d419 2
a420 2
	data->version = (packet[0] >> 3)&0x07;
	data->mode = packet[0]&0x07;
a421 10
	data->polling = packet[2];
	data->precision = packet[3];

	for (i = 0, d = 0.0; i < 4; ++i)
	    d = 256.0*d+packet[NTP_DISP_FIELD+i];
	data->dispersion = d/65536.0;

	for (i = 0, d = 0.0; i < 8; ++i)
	    d = 256.0*d+packet[NTP_REFERENCE+i];
	data->reference = d/NTP_SCALE;
d431 1
a431 1
	/* See unpack_ntp for why there is no byte-order change. */
d499 4
a502 8
	printf("polling:     %u\n", data->polling);
	printf("precision:   %u\n", data->precision);
	printf("dispersion:  %e\n", data->dispersion);
	printf("reference:   %e\n", data->reference);
	printf("originate:   %e\n", data->originate);
	printf("receive:     %e\n", data->receive);
	printf("transmit:    %e\n", data->transmit);
	printf("current:     %e\n", data->current);
@


1.19
log
@insane spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.18 2004/05/30 22:41:15 jakob Exp $	*/
d331 1
a331 1
		warnx("Invalid NTP packet size, packet reject");
d338 1
a338 1
		warnx("Invalid cookie received");
d354 1
a354 1
		warnx("Server clock not syncronized, packet rejected");
@


1.18
log
@verify that the server is confident in the result it is sending us; from Alexander Guy
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.17 2004/05/26 16:38:44 jakob Exp $	*/
d187 2
a188 2
        *offset = 0.0;
        *error = NTP_INSANITY;
d190 1
a190 1
        while (accepts < MAX_QUERIES && attempts < 2 * MAX_QUERIES) {
d229 1
a229 1
        }
d251 1
a251 1
	 * Send out a random 64-bit number as our transmit time.  The NTP 
d254 1
a254 1
	 * 
d256 1
a256 1
	 * system time for the world to see (which may aid an attacker), and 
d262 1
a262 1
	 
d332 1
a332 1
	        return 1;
d353 4
a356 4
	if (data->status == STATUS_ALARM) {                                     
		warnx("Server clock not syncronized, packet rejected");         
		return 1;                                                       
	}                                                                       
d380 6
a385 6
        x = data->receive - data->originate;
        y = (data->transmit == 0.0 ? 0.0 : data->transmit-data->current);
        *off = 0.5*(x+y);
        *error = x-y;
        x = data->current - data->originate;
        if (0.5*x > *error)
d416 2
a417 2
	/* 
	 * No endian concerns here.  Since we're running as a strict 
d419 1
a419 1
	 * this field intelligible. 
d421 1
a421 1
	
@


1.17
log
@Send out a random 64-bit number as our transmit time.  The NTP
server will copy said number into the originate field on the
response that it sends us.  This is totally legal per the SNTP spec.

The impact of this is two fold: we no longer send out the current
system time for the world to see (which may aid an attacker), and
it gives us a (not very secure) way of knowing that we're not
getting spoofed by an attacker that can't capture our traffic
but can spoof packets from the NTP server we're communicating with.

code by Alexander Guy. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.16 2004/05/18 17:25:18 jakob Exp $	*/
d83 5
d238 1
a238 1
	data->status = 0;
d352 5
@


1.16
log
@sendto() return code fixes; from andreq matveev
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.15 2004/02/16 21:25:41 jakob Exp $	*/
d102 3
d240 1
a240 1
	data->receive = data->originate = 0.0;
d242 18
d289 1
a289 1
	double	delay1, delay2, x, y;
d332 5
d354 1
a354 2
	delay1 = data->transmit - data->receive;
	delay2 = data->current - data->originate;
d360 2
a361 4
	    delay1 < 0.0 ||
	    delay1 > NTP_INSANITY ||
	    delay2 < 0.0 ||
	    delay2 > NTP_INSANITY ||
a398 7
	d = data->originate/NTP_SCALE;
	for (i = 0; i < 8; ++i) {
		if ((k = (int)(d *= 256.0)) >= 256) k = 255;
		packet[NTP_ORIGINATE+i] = k;
		d -= k;
	}

d406 7
a412 6
	d = data->transmit/NTP_SCALE;
	for (i = 0; i < 8; ++i) {
		if ((k = (int)(d *= 256.0)) >= 256) k = 255;
		packet[NTP_TRANSMIT+i] = k;
		d -= k;
	}
a443 4
	    d = 256.0*d+packet[NTP_ORIGINATE+i];
	data->originate = d/NTP_SCALE;

	for (i = 0, d = 0.0; i < 8; ++i)
d450 3
d527 2
@


1.15
log
@add IPv4/IPv6 transport selection. ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.14 2003/05/14 18:06:21 itojun Exp $	*/
d245 1
a245 1
	int	length;
d249 1
a249 1
	if (length <= 0) {
@


1.14
log
@"error" was typed double, which is not suitable for getaddrinfo(3).
from tobias
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.13 2002/09/08 12:33:42 jakob Exp $	*/
d104 1
a104 1
void	ntp_client(const char *, struct timeval *, struct timeval *, int);
d117 1
a117 1
ntp_client(const char *hostname, struct timeval *new,
d125 1
a125 1
	hints.ai_family = PF_UNSPEC;
@


1.13
log
@add leap second support for rfc868, from thorsten glaser
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.12 2002/08/10 21:37:28 jakob Exp $	*/
d122 1
a122 1
	int packets = 0, s;
d127 3
a129 3
	error = getaddrinfo(hostname, "ntp", &hints, &res0);
	if (error) {
		errx(1, "%s: %s", hostname, gai_strerror(error));
@


1.12
log
@style; from thorsten
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.11 2002/07/31 12:48:46 jakob Exp $	*/
d104 1
a104 1
void	ntp_client(const char *, struct timeval *, struct timeval *);
d114 1
a114 1
int	corrleaps = 0;
d117 2
a118 1
ntp_client(const char *hostname, struct timeval *new, struct timeval *adjust)
d133 1
@


1.11
log
@minor changes and knf from thorsten glaser
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.10 2002/07/28 07:48:29 jakob Exp $	*/
d32 1
a32 1
#include <sys/types.h>
a34 1

d51 1
d246 1
a246 1
	length = sendto(fd, transmit, NTP_PACKET_MIN, 0, peer, peer->sa_len);
@


1.10
log
@call ntpleaps before trying to sync if needed
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.9 2002/07/27 20:11:34 jakob Exp $	*/
d450 2
a451 1
	/* At this point, current has the current TAI time.
d455 1
a455 1
	t = NTPLEAPS_OFFSET + (u_int64_t) current.tv_sec;
d459 1
a459 1
	return offset + ( t - NTPLEAPS_OFFSET ) + 1.0e-6 * current.tv_usec;
@


1.9
log
@move leap seconds correction to -N option for now
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.8 2002/07/27 08:47:19 jakob Exp $	*/
d131 3
@


1.8
log
@enable leapsecond supprt
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.7 2002/06/14 21:35:01 todd Exp $	*/
d114 2
a131 2
	ntpleaps_init();

d452 2
a453 1
	ntpleaps_sub(&t);
@


1.7
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.6 2002/05/16 22:00:37 ho Exp $	*/
d6 1
d52 1
d130 2
d442 1
d447 8
a454 1
	return offset + current.tv_sec + 1.0e-6 * current.tv_usec;
@


1.6
log
@More careful with select(). deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.5 2002/05/16 21:05:24 jakob Exp $	*/
d208 1
a208 1
			errx(1, "Inconsistent times recieved from NTP server");
@


1.5
log
@IPv6 support; itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.4 2002/05/16 15:01:32 jakob Exp $	*/
d260 2
a261 2
	int	length;
	fd_set	rfds;
d264 9
d276 12
a287 9
	/* XXX potential fdset overflow */
	FD_ZERO(&rfds);
	FD_SET(fd, &rfds);

	if (select (fd + 1, &rfds, NULL, NULL, &tv) < 1)
		return 1; /* failure or timeout */
		/* XXX does not deal with all possible return values */

	/* XXX assumes fd was ready */
@


1.4
log
@#ifdef DEBUG some verbose output, may be moved to a -v flag later perhaps
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.3 2002/05/16 11:00:53 deraadt Exp $	*/
d115 1
a115 4
	struct sockaddr_in server, peer;
	struct protoent *pp, ppp;
	struct servent *sp, ssp;
	struct hostent *hp;
d119 8
a126 2
	if ((hp = gethostbyname(hostname)) == NULL)
		errx(1, "%s: %s", hostname, hstrerror(h_errno));
d128 5
a132 5
	if ((sp = getservbyname("ntp", "udp")) == NULL) {
		sp = &ssp;
		sp->s_port = 123;
		sp->s_proto = "udp";
	}
d134 14
a147 3
	if ((pp = getprotobyname(sp->s_proto)) == NULL) {
		pp = &ppp;
		pp->p_proto = 17;
d149 1
a149 25

	if ((s = socket(AF_INET, SOCK_DGRAM, pp->p_proto)) == -1)
		err(1, "Could not create socket");

	bzero(&peer, sizeof(peer));
	peer.sin_family = AF_INET;
	peer.sin_port = sp->s_port;
	(void) memcpy(&(peer.sin_addr.s_addr), hp->h_addr, hp->h_length);

	bzero(&server, sizeof(server));
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;

	if (bind(s, (struct sockaddr *) &server, sizeof(server)))
		err(1, "Could not bind to socket");

	packets = sync_ntp(s, (struct sockaddr *) &peer, &offset, &error);

	close(s);

	if (packets == 0)
		errx(1, "No acceptable packets received");

	if (error > NTP_INSANITY)
		errx(1, "Unable to get a reasonable time estimate");
d239 1
a239 1
	length = sendto(fd, transmit, NTP_PACKET_MIN, 0, peer, sizeof(*peer));
@


1.3
log
@bit more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.2 2002/05/16 10:52:38 deraadt Exp $	*/
d161 1
d163 1
d198 1
d201 1
d213 1
d215 1
@


1.2
log
@various KNF, and mark some issues
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.1 2002/05/16 10:46:34 jakob Exp $	*/
d52 2
a53 1
/* NTP definitions.  Note that these assume 8-bit bytes - sigh.  There
d57 2
a58 1
 * contain a lot of extra assumptions. */
d115 3
a118 6
	struct servent *sp, ssp;
	struct protoent *pp, ppp;
	struct sockaddr_in server, peer;

	int s;
	int packets = 0;
d120 1
a170 1

a174 1

d252 2
a253 1
/* Check the packet and work out the offset and optionally the error.
d256 2
a257 1
 * if it fails. */
d279 1
a279 1
	/* assumes fd was ready */
d282 1
a282 1
	if (length <= 0) {
d341 2
a342 1
/* Pack the essential data into an NTP packet, bypassing struct layout
d344 2
a345 1
 * SNTP. */
d381 2
a382 1
/* Unpack the essential data from an NTP packet, bypassing struct
d384 2
a385 1
 * to SNTP. */
d422 2
a423 1
/* Get the current UTC time in seconds since the Epoch plus an offset
d425 1
a425 1
 * */
d437 4
a440 2
/* Change offset into current UTC time. This is portable, even if
 * struct timeval uses an unsigned long for tv_sec. */
@


1.1
log
@add support for SNTP & split out RFC868 time support. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ntp.c,v 1.5 2002/05/16 10:42:29 jakob Exp $	*/
a30 1

a51 1

a84 1

d86 12
a97 12
	unsigned char status;
	unsigned char version;
	unsigned char mode;
	unsigned char stratum;
	unsigned char polling;
	unsigned char precision;
	double dispersion;
	double reference;
	double originate;
	double receive;
	double transmit;
	double current;
a99 1

d105 2
a106 2
void	pack_ntp(unsigned char *, int, struct ntp_data *);
void	unpack_ntp(struct ntp_data *, unsigned char *, int);
d201 4
a204 2
		if ((a = x - *offset) < 0.0) a = -a;
		if (accepts <= 1) a = 0.0;
d216 2
a217 1
		if (*error <= minerr) break;
d241 2
a242 2
	unsigned char transmit[NTP_PACKET_MIN];
	int length;
d246 1
a246 1
	if(length <= 0) {
d248 1
a248 1
        	return 1;
d262 5
a266 5
	unsigned char receive[NTP_PACKET_MAX+1];
	double delay1, delay2, x, y;
	int length;
	fd_set rfds;
	struct timeval tv;
d271 1
d277 3
d284 1
a284 1
        	return 1;
d305 2
a306 1
	/* Note that the conventions are very poorly defined in the NTP
d309 2
a310 2
	 * reject it. */

d345 1
a345 1
pack_ntp(unsigned char *packet, int length, struct ntp_data *data)
d383 1
a383 1
unpack_ntp(struct ntp_data *data, unsigned char *packet, int length)
@

