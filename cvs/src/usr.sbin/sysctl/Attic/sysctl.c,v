head	1.45;
access;
symbols
	OPENBSD_2_6:1.41.0.2
	OPENBSD_2_6_BASE:1.41
	OPENBSD_2_5:1.39.0.2
	OPENBSD_2_5_BASE:1.39
	OPENBSD_2_4:1.35.0.4
	OPENBSD_2_4_BASE:1.35
	OPENBSD_2_3:1.35.0.2
	OPENBSD_2_3_BASE:1.35
	OPENBSD_2_2:1.32.0.2
	OPENBSD_2_2_BASE:1.32
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2000.01.01.22.38.19;	author deraadt;	state dead;
branches;
next	1.44;

1.44
date	99.12.30.19.06.06;	author provos;	state Exp;
branches;
next	1.43;

1.43
date	99.12.10.10.12.56;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	99.10.28.03.34.03;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	99.09.02.22.04.38;	author pjanzen;	state Exp;
branches;
next	1.40;

1.40
date	99.07.01.15.45.18;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	99.04.11.19.41.41;	author niklas;	state Exp;
branches;
next	1.38;

1.38
date	99.04.09.23.30.06;	author niklas;	state Exp;
branches;
next	1.37;

1.37
date	99.02.25.21.59.50;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	99.02.24.22.59.43;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	98.03.19.07.36.11;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	98.03.15.17.48.48;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	98.02.17.20.51.24;	author matthieu;	state Exp;
branches;
next	1.32;

1.32
date	97.10.25.21.46.06;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	97.10.25.08.23.38;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	97.10.22.23.40.35;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	97.10.15.19.30.55;	author kstailey;	state Exp;
branches;
next	1.28;

1.28
date	97.10.03.21.15.19;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	97.10.03.20.58.04;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	97.09.21.23.02.03;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	97.09.12.03.56.08;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	97.08.29.02.40.40;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	97.08.28.19.39.20;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	97.08.28.19.31.51;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	97.08.19.23.20.32;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	97.08.19.22.38.31;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.08.19.06.42.42;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	97.08.19.06.16.26;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.08.19.05.53.12;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.08.19.05.32.57;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.08.09.23.36.31;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.07.22.15.06.54;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	97.07.22.14.43.19;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	97.07.15.00.38.15;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	97.06.28.07.05.34;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.06.24.02.45.02;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.06.17.19.42.02;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.06.14.21.37.12;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.04.06.20.19.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.16.03.57.31;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.44.22;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.11.25.08.22.43;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.08.08.06.36.48;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.30.04.53.15;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.22;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.45
log
@move sysctl(8) to /sbin, with a relative symbolic link remaining in the old location
@
text
@/*	$OpenBSD: sysctl.c,v 1.44 1999/12/30 19:06:06 provos Exp $	*/
/*	$NetBSD: sysctl.c,v 1.9 1995/09/30 07:12:50 thorpej Exp $	*/

/*
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)sysctl.c	8.5 (Berkeley) 5/9/95";
#else
static char *rcsid = "$OpenBSD: sysctl.c,v 1.44 1999/12/30 19:06:06 provos Exp $";
#endif
#endif /* not lint */

#include <sys/param.h>
#include <sys/gmon.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <sys/socket.h>
#include <vm/vm_param.h>
#include <machine/cpu.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_icmp.h>
#include <netinet/ip_ip4.h>
#include <netinet/ip_ether.h>
#include <netinet/ip_ah.h>
#include <netinet/ip_esp.h>
#include <netinet/icmp_var.h>
#include <netinet/ip_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>

#ifdef INET6
#include <netinet6/ip6.h>
#include <netinet6/icmp6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/pim6_var.h>
#endif

#include <netipx/ipx.h>
#include <netipx/ipx_var.h>
#include <netipx/spx_var.h>
#include <ddb/db_var.h>
#include <dev/rndvar.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#ifdef CPU_BIOS
#include <machine/biosvar.h>
#endif

struct ctlname topname[] = CTL_NAMES;
struct ctlname kernname[] = CTL_KERN_NAMES;
struct ctlname vmname[] = CTL_VM_NAMES;
struct ctlname fsname[] = CTL_FS_NAMES;
struct ctlname netname[] = CTL_NET_NAMES;
struct ctlname hwname[] = CTL_HW_NAMES;
struct ctlname username[] = CTL_USER_NAMES;
struct ctlname debugname[CTL_DEBUG_MAXID];
struct ctlname *vfsname;
#ifdef CTL_MACHDEP_NAMES
struct ctlname machdepname[] = CTL_MACHDEP_NAMES;
#endif
struct ctlname ddbname[] = CTL_DDB_NAMES;
char names[BUFSIZ];
int lastused;

struct list {
	struct	ctlname *list;
	int	size;
};
struct list toplist = { topname, CTL_MAXID };
struct list secondlevel[] = {
	{ 0, 0 },			/* CTL_UNSPEC */
	{ kernname, KERN_MAXID },	/* CTL_KERN */
	{ vmname, VM_MAXID },		/* CTL_VM */
	{ fsname, FS_MAXID },		/* CTL_FS */
	{ netname, NET_MAXID },		/* CTL_NET */
	{ 0, CTL_DEBUG_MAXID },		/* CTL_DEBUG */
	{ hwname, HW_MAXID },		/* CTL_HW */
#ifdef CTL_MACHDEP_NAMES
	{ machdepname, CPU_MAXID },	/* CTL_MACHDEP */
#else
	{ 0, 0 },			/* CTL_MACHDEP */
#endif
	{ username, USER_MAXID },	/* CTL_USER_NAMES */
	{ ddbname, DBCTL_MAXID },	/* CTL_DDB_NAMES */
	{ 0, 0 },			/* CTL_VFS */
};

int	Aflag, aflag, nflag, wflag;

/*
 * Variables requiring special processing.
 */
#define	CLOCK		0x00000001
#define	BOOTTIME	0x00000002
#define	CHRDEV		0x00000004
#define	BLKDEV		0x00000008
#define	RNDSTATS	0x00000010
#define	BADDYNAMIC	0x00000020
#define	BIOSGEO		0x00000040
#define	BIOSDEV		0x00000080
#define	MAJ2DEV		0x00000100
#define	UNSIGNED	0x00000200

/* prototypes */
void debuginit __P((void));
void listall __P((char *, struct list *));
void parse __P((char *, int));
void parse_baddynamic __P((int *, size_t, char *, void **, size_t *, int, int));
void usage __P((void));
int findname __P((char *, char *, char **, struct list *));
int sysctl_inet __P((char *, char **, int *, int, int *));
#ifdef INET6
int sysctl_inet6 __P((char *, char **, int *, int, int *));
#endif
int sysctl_ipx __P((char *, char **, int *, int, int *));
int sysctl_fs __P((char *, char **, int *, int, int *));
int sysctl_bios __P((char *, char **, int *, int, int *));
void vfsinit __P((void));

int
main(argc, argv)
	int argc;
	char *argv[];
{
	int ch, lvl1;

	while ((ch = getopt(argc, argv, "Aanw")) != -1) {
		switch (ch) {

		case 'A':
			Aflag = 1;
			break;

		case 'a':
			aflag = 1;
			break;

		case 'n':
			nflag = 1;
			break;

		case 'w':
			wflag = 1;
			break;

		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc == 0 && (Aflag || aflag)) {
		debuginit();
		vfsinit();
		for (lvl1 = 1; lvl1 < CTL_MAXID; lvl1++)
			listall(topname[lvl1].ctl_name, &secondlevel[lvl1]);
		exit(0);
	}
	if (argc == 0)
		usage();
	for (; *argv != NULL; ++argv)
		parse(*argv, 1);
	exit(0);
}

/*
 * List all variables known to the system.
 */
void
listall(prefix, lp)
	char *prefix;
	struct list *lp;
{
	int lvl2;
	char *cp, name[BUFSIZ];

	if (lp->list == NULL)
		return;
	(void)strncpy(name, prefix, BUFSIZ-1);
	name[BUFSIZ-1] = '\0';
	cp = &name[strlen(name)];
	*cp++ = '.';
	for (lvl2 = 0; lvl2 < lp->size; lvl2++) {
		if (lp->list[lvl2].ctl_name == NULL)
			continue;
		(void)strcpy(cp, lp->list[lvl2].ctl_name);
		parse(name, Aflag);
	}
}

/*
 * Parse a name into a MIB entry.
 * Lookup and print out the MIB entry if it exists.
 * Set a new value if requested.
 */
void
parse(string, flags)
	char *string;
	int flags;
{
	int indx, type, state, intval;
	size_t size, len,  newsize = 0;
	int special = 0;
	void *newval = 0;
	quad_t quadval;
	struct list *lp;
	struct vfsconf vfc;
	int mib[CTL_MAXNAME];
	char *cp, *bufp, buf[BUFSIZ];

	(void)strncpy(buf, string, sizeof(buf) - 1);
	buf[sizeof(buf) - 1] = '\0';
	bufp = buf;
	if ((cp = strchr(string, '=')) != NULL) {
		if (!wflag)
			errx(2, "must specify -w to set variables");
		*strchr(buf, '=') = '\0';
		*cp++ = '\0';
		while (isspace(*cp))
			cp++;
		newval = cp;
		newsize = strlen(cp);
	}
	if ((indx = findname(string, "top", &bufp, &toplist)) == -1)
		return;
	mib[0] = indx;
	if (indx == CTL_VFS)
		vfsinit();
	if (indx == CTL_DEBUG)
		debuginit();
	lp = &secondlevel[indx];
	if (lp->list == 0) {
		warnx("%s: class is not implemented", topname[indx].ctl_name);
		return;
	}
	if (bufp == NULL) {
		listall(topname[indx].ctl_name, lp);
		return;
	}
	if ((indx = findname(string, "second", &bufp, lp)) == -1)
		return;
	mib[1] = indx;
	type = lp->list[indx].ctl_type;
	len = 2;
	switch (mib[0]) {

	case CTL_KERN:
		switch (mib[1]) {
		case KERN_PROF:
			mib[2] = GPROF_STATE;
			size = sizeof(state);
			if (sysctl(mib, 3, &state, &size, NULL, 0) == -1) {
				if (flags == 0)
					return;
				if (!nflag)
					(void)printf("%s: ", string);
				(void)puts("kernel is not compiled for profiling");
				return;
			}
			if (!nflag)
				(void)printf("%s = %s\n", string,
				    state == GMON_PROF_OFF ? "off" : "running");
			return;
		case KERN_VNODE:
		case KERN_FILE:
			if (flags == 0)
				return;
			warnx("use pstat to view %s information", string);
			return;
		case KERN_PROC:
			if (flags == 0)
				return;
			warnx("use ps to view %s information", string);
			return;
		case KERN_NTPTIME:
			if (flags == 0)
				return;
			warnx("use xntpdc to view %s information", string);
			return;
		case KERN_CLOCKRATE:
			special |= CLOCK;
			break;
		case KERN_BOOTTIME:
			special |= BOOTTIME;
			break;
		case KERN_RND:
			special |= RNDSTATS;
			break;
		case KERN_HOSTID:
		case KERN_ARND:
			special |= UNSIGNED;
			break;
		}
		break;

	case CTL_HW:
		break;

	case CTL_VM:
		if (mib[1] == VM_LOADAVG) {
			double loads[3];

			getloadavg(loads, 3);
			if (!nflag)
				(void)printf("%s = ", string);
			(void)printf("%.2f %.2f %.2f\n", loads[0],
			    loads[1], loads[2]);
			return;
		} else if (mib[1] == VM_PSSTRINGS) {
			struct _ps_strings _ps;

			len = sizeof(_ps);
			if (sysctl(mib, 2, &_ps, &len, NULL, 0) == -1) {
				if (flags == 0)
					return;
				if (!nflag)
					(void)printf("%s: ", string);
				(void)puts("can't find ps strings");
				return;
			}
			if (!nflag)
				(void)printf("%s = ", string);
			(void)printf("%p\n", _ps.val);
			return;
		}
#ifdef UVM
		if (mib[1] != VM_SWAPENCRYPT) {
#endif
		if (flags == 0)
			return;
		warnx("use vmstat or systat to view %s information", string);
		return;
#ifdef UVM
		}
#endif
		break;

	case CTL_NET:
		if (mib[1] == PF_INET) {
			len = sysctl_inet(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;

			if ((mib[2] == IPPROTO_TCP &&
			     mib[3] == TCPCTL_BADDYNAMIC) ||
			    (mib[2] == IPPROTO_UDP &&
			     mib[3] == UDPCTL_BADDYNAMIC)) {

				special |= BADDYNAMIC;

				if (newval != NULL)
					parse_baddynamic(mib, len, string,
					    &newval, &newsize, flags, nflag);
			}
			break;
		}
#ifdef INET6
		if (mib[1] == PF_INET6) {
			len = sysctl_inet6(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;

			break;
		}
#endif
		if (mib[1] == PF_IPX) {
			len = sysctl_ipx(string, &bufp, mib, flags, &type);
			if (len >= 0)
				break;
			return;
		}
		if (flags == 0)
			return;
		warnx("use netstat to view %s information", string);
		return;

	case CTL_DEBUG:
		mib[2] = CTL_DEBUG_VALUE;
		len = 3;
		break;

	case CTL_MACHDEP:
#ifdef CPU_CONSDEV
		if (mib[1] == CPU_CONSDEV)
			special |= CHRDEV;
#endif
#ifdef CPU_BLK2CHR
		if (mib[1] == CPU_BLK2CHR) {
			if (bufp == NULL)
				return;
			mib[2] = makedev(atoi(bufp),0);
			bufp = NULL;
			len = 3;
			special |= CHRDEV;
			break;
		}
#endif
#ifdef CPU_CHR2BLK
		if (mib[1] == CPU_CHR2BLK) {
			if (bufp == NULL)
				return;
			mib[2] = makedev(atoi(bufp),0);
			bufp = NULL;
			len = 3;
			special |= BLKDEV;
			break;
		}
#endif
#ifdef CPU_BIOS
		if (mib[1] == CPU_BIOS) {
			len = sysctl_bios(string, &bufp, mib, flags, &type);
			if (len < 0)
				return;
			if (mib[2] == BIOS_DEV)
				special |= BIOSDEV;
			if (mib[2] == BIOS_DISKINFO)
				special |= BIOSGEO;
			break;
		}
#endif
		break;

	case CTL_FS:
		len = sysctl_fs(string, &bufp, mib, flags, &type);
		if (len >= 0)
			break;
		return;

	case CTL_VFS:
		mib[3] = mib[1];
		mib[1] = VFS_GENERIC;
		mib[2] = VFS_CONF;
		len = 4;
		size = sizeof vfc;
		if (sysctl(mib, 4, &vfc, &size, (void *)0, (size_t)0) < 0) {
			if (errno != EOPNOTSUPP)
				perror("vfs print");
			return;
		}
		if (flags == 0 && vfc.vfc_refcount == 0)
			return;
		if (!nflag)
			fprintf(stdout, "%s has %d mounted instance%s\n",
			    string, vfc.vfc_refcount,
			    vfc.vfc_refcount != 1 ? "s" : "");
		else
			fprintf(stdout, "%d\n", vfc.vfc_refcount);
		return;

	case CTL_USER:
	case CTL_DDB:
		break;

	default:
		warnx("illegal top level value: %d", mib[0]);
		return;
	
	}
	if (bufp) {
		warnx("name %s in %s is unknown", bufp, string);
		return;
	}
	if (newsize > 0) {
		switch (type) {
		case CTLTYPE_INT:
			errno = 0;
			if (special & UNSIGNED)
				intval = strtoul(newval, &cp, 10);
			else
				intval = strtol(newval, &cp, 10);
			if (*cp != '\0') {
				warnx("%s: illegal value: %s", string,
				    (char *)newval);
				return;
			}
			if (errno == ERANGE) {
				warnx("%s: value %s out of range", string,
				    (char *)newval);
				return;
			}
			newval = &intval;
			newsize = sizeof(intval);
			break;

		case CTLTYPE_QUAD:
			(void)sscanf(newval, "%qd", &quadval);
			newval = &quadval;
			newsize = sizeof(quadval);
			break;
		}
	}
	size = BUFSIZ;
	if (sysctl(mib, len, buf, &size, newsize ? newval : 0, newsize) == -1) {
		if (flags == 0)
			return;
		switch (errno) {
		case EOPNOTSUPP:
			warnx("%s: value is not available", string);
			return;
		case ENOTDIR:
			warnx("%s: specification is incomplete", string);
			return;
		case ENOMEM:
			warnx("%s: type is unknown to this program", string);
			return;
		case ENXIO:
			if (special & BIOSGEO)
				return;
		default:
			warn(string);
			return;
		}
	}
	if (special & CLOCK) {
		struct clockinfo *clkp = (struct clockinfo *)buf;

		if (!nflag)
			(void)printf("%s = ", string);
		(void)printf(
		    "tick = %d, tickadj = %d, hz = %d, profhz = %d, stathz = %d\n",
		    clkp->tick, clkp->tickadj, clkp->hz, clkp->profhz, clkp->stathz);
		return;
	}
	if (special & BOOTTIME) {
		struct timeval *btp = (struct timeval *)buf;
		time_t boottime;

		if (!nflag) {
			boottime = btp->tv_sec;
			(void)printf("%s = %s", string, ctime(&boottime));
		} else
			(void)printf("%ld\n", btp->tv_sec);
		return;
	}
	if (special & BLKDEV) {
		dev_t dev = *(dev_t *)buf;

		if (!nflag)
			(void)printf("%s = %s\n", string,
			    devname(dev, S_IFBLK));
		else
			(void)printf("0x%x\n", dev);
		return;
	}
	if (special & CHRDEV) {
		dev_t dev = *(dev_t *)buf;

		if (!nflag)
			(void)printf("%s = %s\n", string,
			    devname(dev, S_IFCHR));
		else
			(void)printf("0x%x\n", dev);
		return;
	}
#ifdef CPU_BIOS
	if (special & BIOSGEO) {
		bios_diskinfo_t *pdi = (bios_diskinfo_t *)buf;

		if (!nflag)
			(void)printf("%s = ", string);
		(void)printf("bootdev = 0x%x, "
			     "cylinders = %u, heads = %u, sectors = %u\n",
			     pdi->bsd_dev, pdi->bios_cylinders, pdi->bios_heads,
			     pdi->bios_sectors);
		return;
	}
	if (special & BIOSDEV) {
		int dev = *(int*)buf;

		if (!nflag)
			(void)printf("%s = ", string);
		(void) printf("0x%02x\n", dev);
		return;
	}
#endif
	if (special & UNSIGNED) {
		if (newsize == 0) {
			if (!nflag)
				(void)printf("%s = ", string);
			(void)printf("%u\n", *(u_int *)buf);
		} else {
			if (!nflag)
				(void)printf("%s: %u -> ", string,
				    *(u_int *)buf);
			(void)printf("%u\n", *(u_int *)newval);
		}
		return;
	}
	if (special & RNDSTATS) {
		struct rndstats *rndstats = (struct rndstats *)buf;

		if (!nflag)
			(void)printf("%s = ", string);
		(void)printf(
		    "%u %u %u %u %u %u %u %u %u %u %u %u %u %u %u %u\n",
		    rndstats->rnd_total, rndstats->rnd_used,
		    rndstats->arc4_reads, rndstats->rnd_timer,
		    rndstats->rnd_mouse, rndstats->rnd_tty,
		    rndstats->rnd_disk, rndstats->rnd_net,
		    rndstats->rnd_reads, rndstats->rnd_waits,
		    rndstats->rnd_enqs, rndstats->rnd_deqs,
		    rndstats->rnd_drops, rndstats->rnd_drople,
		    rndstats->rnd_asleep, rndstats->rnd_queued);
		return;
	}
	if (special & BADDYNAMIC) {
		in_port_t port, lastport;
		u_int32_t *baddynamic = (u_int32_t *)buf;

		if (!nflag)
			(void)printf("%s%s", string, newsize ? ": " : " = ");
		lastport = 0;
		for (port = IPPORT_RESERVED/2; port < IPPORT_RESERVED; port++)
			if (DP_ISSET(baddynamic, port)) {
				(void)printf("%s%hd", lastport ? "," : "",
				    port);
				lastport = port;
			}
		if (newsize != 0) {
			if (!nflag)
				fputs(" -> ", stdout);
			baddynamic = (u_int32_t *)newval;
			lastport = 0;
			for (port = IPPORT_RESERVED/2; port < IPPORT_RESERVED;
			    port++)
				if (DP_ISSET(baddynamic, port)) {
					(void)printf("%s%hd",
					    lastport ? "," : "", port);
					lastport = port;
				}
		}
		(void)putchar('\n');
		return;
	}
	switch (type) {
	case CTLTYPE_INT:
		if (newsize == 0) {
			if (!nflag)
				(void)printf("%s = ", string);
			(void)printf("%d\n", *(int *)buf);
		} else {
			if (!nflag)
				(void)printf("%s: %d -> ", string,
				    *(int *)buf);
			(void)printf("%d\n", *(int *)newval);
		}
		return;

	case CTLTYPE_STRING:
		if (newsize == 0) {
			if (!nflag)
				(void)printf("%s = ", string);
			(void)puts(buf);
		} else {
			if (!nflag)
				(void)printf("%s: %s -> ", string, buf);
			(void)puts((char *)newval);
		}
		return;

	case CTLTYPE_QUAD:
		if (newsize == 0) {
			if (!nflag)
				(void)printf("%s = ", string);
			(void)printf("%qd\n", *(quad_t *)buf);
		} else {
			if (!nflag)
				(void)printf("%s: %qd -> ", string,
				    *(quad_t *)buf);
			(void)printf("%qd\n", *(quad_t *)newval);
		}
		return;

	case CTLTYPE_STRUCT:
		warnx("%s: unknown structure returned", string);
		return;

	default:
	case CTLTYPE_NODE:
		warnx("%s: unknown type returned", string);
		return;
	}
}

void
parse_baddynamic(mib, len, string, newvalp, newsizep, flags, nflag)
	int mib[];
	size_t len;
	char *string;
	void **newvalp;
	size_t *newsizep;
	int flags;
	int nflag;
{
	static u_int32_t newbaddynamic[DP_MAPSIZE];
	in_port_t port;
	size_t size;
	char action, *cp;

	if (strchr((char *)*newvalp, '+') || strchr((char *)*newvalp, '-')) {
		size = sizeof(newbaddynamic);
		if (sysctl(mib, len, newbaddynamic, &size, 0, 0) == -1) {
			if (flags == 0)
				return;
			if (!nflag)
				(void)printf("%s: ", string);
			(void)puts("kernel does contain bad dynamic port tables");
			return;
		}

		while (*newvalp && (cp = strsep((char **)newvalp, ", \t")) && *cp) {
			if (*cp != '+' && *cp != '-')
				errx(1, "cannot mix +/- with full list");
			action = *cp++;
			port = atoi(cp);
			if (port < IPPORT_RESERVED/2 || port >= IPPORT_RESERVED)
				errx(1, "invalid port, range is %d to %d",
				    IPPORT_RESERVED/2, IPPORT_RESERVED-1);
			if (action == '+')
				DP_SET(newbaddynamic, port);
			else
				DP_CLR(newbaddynamic, port);
		}
	} else {
		(void)memset((void *)newbaddynamic, 0, sizeof(newbaddynamic));
		while (*newvalp && (cp = strsep((char **)newvalp, ", \t")) && *cp) {
			port = atoi(cp);
			if (port < IPPORT_RESERVED/2 || port >= IPPORT_RESERVED)
				errx(1, "invalid port, range is %d to %d",
				    IPPORT_RESERVED/2, IPPORT_RESERVED-1);
			DP_SET(newbaddynamic, port);
		}
	}

	*newvalp = (void *)newbaddynamic;
	*newsizep = sizeof(newbaddynamic);
}

/*
 * Initialize the set of debugging names
 */
void
debuginit()
{
	int mib[3], loc, i;
	size_t size;

	if (secondlevel[CTL_DEBUG].list != 0)
		return;
	secondlevel[CTL_DEBUG].list = debugname;
	mib[0] = CTL_DEBUG;
	mib[2] = CTL_DEBUG_NAME;
	for (loc = lastused, i = 0; i < CTL_DEBUG_MAXID; i++) {
		mib[1] = i;
		size = BUFSIZ - loc;
		if (sysctl(mib, 3, &names[loc], &size, NULL, 0) == -1)
			continue;
		debugname[i].ctl_name = &names[loc];
		debugname[i].ctl_type = CTLTYPE_INT;
		loc += size;
	}
	lastused = loc;
}

/*
 * Initialize the set of filesystem names
 */
void
vfsinit()
{
	int mib[4], maxtypenum, cnt, loc, size;
	struct vfsconf vfc;
	size_t buflen;

	if (secondlevel[CTL_VFS].list != 0)
		return;
	mib[0] = CTL_VFS;
	mib[1] = VFS_GENERIC;
	mib[2] = VFS_MAXTYPENUM;
	buflen = 4;
	if (sysctl(mib, 3, &maxtypenum, &buflen, (void *)0, (size_t)0) < 0)
		return;
	if ((vfsname = malloc(maxtypenum * sizeof(*vfsname))) == 0)
		return;
	memset(vfsname, 0, maxtypenum * sizeof(*vfsname));
	mib[2] = VFS_CONF;
	buflen = sizeof vfc;
	for (loc = lastused, cnt = 0; cnt < maxtypenum; cnt++) {
		mib[3] = cnt;
		if (sysctl(mib, 4, &vfc, &buflen, (void *)0, (size_t)0) < 0) {
			if (errno == EOPNOTSUPP)
				continue;
			perror("vfsinit");
			free(vfsname);
			return;
		}
		strcat(&names[loc], vfc.vfc_name);
		vfsname[cnt].ctl_name = &names[loc];
		vfsname[cnt].ctl_type = CTLTYPE_INT;
		size = strlen(vfc.vfc_name) + 1;
		loc += size;
	}
	lastused = loc;
	secondlevel[CTL_VFS].list = vfsname;
	secondlevel[CTL_VFS].size = maxtypenum;
	return;
}

struct ctlname posixname[] = CTL_FS_POSIX_NAMES;
struct list fslist = { posixname, FS_POSIX_MAXID };

/*
 * handle file system requests
 */
int
sysctl_fs(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
{
	int indx;

	if (*bufpp == NULL) {
		listall(string, &fslist);
		return(-1);
	}
	if ((indx = findname(string, "third", bufpp, &fslist)) == -1)
		return(-1);
	mib[2] = indx;
	*typep = fslist.list[indx].ctl_type;
	return(3);
}

#ifdef CPU_BIOS
struct ctlname biosname[] = CTL_BIOS_NAMES;
struct list bioslist = { biosname, BIOS_MAXID };

/*
 * handle BIOS requests
 */
int
sysctl_bios(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
{
	char *name;
	int indx;

	if (*bufpp == NULL) {
		listall(string, &bioslist);
		return(-1);
	}
	if ((indx = findname(string, "third", bufpp, &bioslist)) == -1)
		return(-1);
	mib[2] = indx;
	if (indx == BIOS_DISKINFO) {
		if (*bufpp == NULL) {
			char name[BUFSIZ];

			/* scan all the bios devices */
			for (indx = 0; indx < 256; indx++) {
				snprintf(name, sizeof(name), "%s.%u",
					 string, indx);
				parse(name, 1);
			}
			return(-1);
		}
		if ((name = strsep(bufpp, ".")) == NULL) {
			warnx("%s: incomplete specification", string);
			return(-1);
		}
		mib[3] = atoi(name);
		*typep = CTLTYPE_STRUCT;
		return 4;
	} else {
		*typep = bioslist.list[indx].ctl_type;
		return(3);
	}
}
#endif

struct ctlname inetname[] = CTL_IPPROTO_NAMES;
struct ctlname ipname[] = IPCTL_NAMES;
struct ctlname icmpname[] = ICMPCTL_NAMES;
struct ctlname ip4name[] = IP4CTL_NAMES;
struct ctlname tcpname[] = TCPCTL_NAMES;
struct ctlname udpname[] = UDPCTL_NAMES;
struct ctlname espname[] = ESPCTL_NAMES;
struct ctlname ahname[] = AHCTL_NAMES;
struct ctlname etheripname[] = ETHERIPCTL_NAMES;
struct list inetlist = { inetname, IPPROTO_MAXID };
struct list inetvars[] = {
	{ ipname, IPCTL_MAXID },	/* ip */
	{ icmpname, ICMPCTL_MAXID },	/* icmp */
	{ 0, 0 },			/* igmp */
	{ 0, 0 },			/* ggmp */
	{ ip4name, IP4CTL_MAXID },	/* ipencap */
	{ 0, 0 },
	{ tcpname, TCPCTL_MAXID },	/* tcp */
	{ 0, 0 },
	{ 0, 0 },			/* egp */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },			/* pup */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ udpname, UDPCTL_MAXID },	/* udp */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ espname, ESPCTL_MAXID },	/* esp */
	{ ahname, AHCTL_MAXID },	/* ah */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ etheripname, ETHERIPCTL_MAXID },
};

/*
 * handle internet requests
 */
int
sysctl_inet(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
{
	struct list *lp;
	int indx;

	if (*bufpp == NULL) {
		listall(string, &inetlist);
		return(-1);
	}
	if ((indx = findname(string, "third", bufpp, &inetlist)) == -1)
		return(-1);
	mib[2] = indx;
	if (indx < IPPROTO_MAXID && inetvars[indx].list != NULL)
		lp = &inetvars[indx];
	else if (!flags)
		return(-1);
	else {
		warnx("%s: no variables defined for this protocol", string);
		return(-1);
	}
	if (*bufpp == NULL) {
		listall(string, lp);
		return(-1);
	}
	if ((indx = findname(string, "fourth", bufpp, lp)) == -1)
		return(-1);
	mib[3] = indx;
	*typep = lp->list[indx].ctl_type;
	return(4);
}

#ifdef INET6
struct ctlname inet6name[] = CTL_IPV6PROTO_NAMES;
struct ctlname ip6name[] = IPV6CTL_NAMES;
struct ctlname icmp6name[] = ICMPV6CTL_NAMES;
struct ctlname pim6name[] = PIMCTL_NAMES;
struct list inet6list = { inet6name, IPV6PROTO_MAXID };
struct list inet6vars[] = {
/*0*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
/*10*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*20*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*30*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*40*/	{ 0, 0 },
	{ ip6name, IPV6CTL_MAXID },	/* ipv6 */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*50*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ icmp6name, ICMPV6CTL_MAXID },	/* icmp6 */
	{ 0, 0 },
/*60*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*70*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*80*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*90*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
/*100*/	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ pim6name, PIMCTL_MAXID },	/* pim6 */
};

/*
 * handle internet6 requests
 */
int
sysctl_inet6(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
{
	struct list *lp;
	int indx;

	if (*bufpp == NULL) {
		listall(string, &inet6list);
		return(-1);
	}
	if ((indx = findname(string, "third", bufpp, &inet6list)) == -1)
		return(-1);
	mib[2] = indx;
	if (indx < IPV6PROTO_MAXID && inet6vars[indx].list != NULL)
		lp = &inet6vars[indx];
	else if (!flags)
		return(-1);
	else {
		warnx("%s: no variables defined for this protocol", string);
		return(-1);
	}
	if (*bufpp == NULL) {
		listall(string, lp);
		return(-1);
	}
	if ((indx = findname(string, "fourth", bufpp, lp)) == -1)
		return(-1);
	mib[3] = indx;
	*typep = lp->list[indx].ctl_type;
	return(4);
}
#endif

struct ctlname ipxname[] = CTL_IPXPROTO_NAMES;
struct ctlname ipxpname[] = IPXCTL_NAMES;
struct ctlname spxpname[] = SPXCTL_NAMES;
struct list ipxlist = { ipxname, IPXCTL_MAXID };
struct list ipxvars[] = {
	{ ipxpname, IPXCTL_MAXID },	/* ipx */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ spxpname, SPXCTL_MAXID },
};

/*
 * Handle internet requests
 */
int
sysctl_ipx(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
{
	struct list *lp;
	int indx;

	if (*bufpp == NULL) {
		listall(string, &ipxlist);
		return(-1);
	}
	if ((indx = findname(string, "third", bufpp, &ipxlist)) == -1)
		return(-1);
	mib[2] = indx;
	if (indx <= IPXPROTO_SPX && ipxvars[indx].list != NULL)
		lp = &ipxvars[indx];
	else if (!flags)
		return(-1);
	else {
		warnx("%s: no variables defined for this protocol", string);
		return(-1);
	}
	if (*bufpp == NULL) {
		listall(string, lp);
		return(-1);
	}
	if ((indx = findname(string, "fourth", bufpp, lp)) == -1)
		return(-1);
	mib[3] = indx;
	*typep = lp->list[indx].ctl_type;
	return(4);
}

/*
 * Scan a list of names searching for a particular name.
 */
int
findname(string, level, bufp, namelist)
	char *string;
	char *level;
	char **bufp;
	struct list *namelist;
{
	char *name;
	int i;

	if (namelist->list == 0 || (name = strsep(bufp, ".")) == NULL) {
		warnx("%s: incomplete specification", string);
		return(-1);
	}
	for (i = 0; i < namelist->size; i++)
		if (namelist->list[i].ctl_name != NULL &&
		    strcmp(name, namelist->list[i].ctl_name) == 0)
			break;
	if (i == namelist->size) {
		warnx("%s level name %s in %s is invalid", level, name, string);
		return(-1);
	}
	return(i);
}

void
usage()
{

	(void)fprintf(stderr, "usage:\t%s\n\t%s\n\t%s\n\t%s\n",
	    "sysctl [-n] variable ...", "sysctl [-n] -w variable=value ...",
	    "sysctl [-n] -a", "sysctl [-n] -A");
	exit(1);
}
@


1.44
log
@vm.swapencrypt for UVM
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.43 1999/12/10 10:12:56 itojun Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.43 1999/12/10 10:12:56 itojun Exp $";
@


1.43
log
@add IPv6 support.  net.inet6.{ip6,icmp6} will be printed.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.42 1999/10/28 03:34:03 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.42 1999/10/28 03:34:03 angelos Exp $";
d380 3
d387 4
@


1.42
log
@net.inet.etherip.allow sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.41 1999/09/02 22:04:38 pjanzen Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.41 1999/09/02 22:04:38 pjanzen Exp $";
d78 7
d165 3
d404 9
d1084 86
@


1.41
log
@Treat kern.hostid as a u_int, and clean up parsing of integers on the command
line.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.40 1999/07/01 15:45:18 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.40 1999/07/01 15:45:18 deraadt Exp $";
d67 1
d923 1
d978 46
@


1.40
log
@print kern.arandom unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.39 1999/04/11 19:41:41 niklas Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.39 1999/04/11 19:41:41 niklas Exp $";
d142 4
a145 4
#define RNDSTATS	0x00000010
#define BADDYNAMIC	0x00000020
#define BIOSGEO		0x00000040
#define BIOSDEV		0x00000080
d147 1
a147 1
#define UNSIGNED	0x00000200
d332 1
d493 15
a507 1
			intval = atoi(newval);
@


1.39
log
@Introduce net.inet.{ah,esp}.enable sysctl controls that are off by default.
If you are going to use either of AH or ESP or both, enable these in
/etc/sysctl.conf.  Also correct the IPSec debugging sysctl code, it is now
named net.inet.ip.encdebug.  Some corrected function signatures too.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.38 1999/04/09 23:30:06 niklas Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.38 1999/04/09 23:30:06 niklas Exp $";
d147 1
d332 3
d588 13
@


1.38
log
@The userland parts of a sysctl that can switch on/off IP-in-IP (protocol 4)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.37 1999/02/25 21:59:50 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.37 1999/02/25 21:59:50 deraadt Exp $";
d67 2
a81 2
#include <net/pfkeyv2.h>
#include <netinet/ip_ipsp.h>
a155 1
int sysctl_ipsec __P((char *, char **, int *, int, int *));
a393 6
		if (mib[1] == PF_KEY) {
			len = sysctl_ipsec(string, &bufp, mib, flags, &type);
			if (len >= 0)
				break;
			return;
		}
a881 47
struct ctlname encapname[] = PFKEYCTL_NAMES;
struct ctlname ipsecname[] = CTL_IPSEC_NAMES;
struct list ipseclist = { ipsecname, IPSECCTL_MAXID };
struct list ipsecvars[] = {
	{ encapname, IPSECCTL_MAXID }, 
};

/*
 * handle ipsec requests
 */
int
sysctl_ipsec(string, bufpp, mib, flags, typep)
	char *string;
	char **bufpp;
	int mib[];
	int flags;
	int *typep;
{
	struct list *lp;
	int indx;

	if (*bufpp == NULL) {
		listall(string, &ipseclist);
		return(-1);
	}
	if ((indx = findname(string, "third", bufpp, &ipseclist)) == -1)
		return(-1);
	mib[2] = indx;
	if (indx <= IPSECCTL_MAXID && ipsecvars[indx].list != NULL)
		lp = &ipsecvars[indx];
	else if (!flags)
		return(-1);
	else {
		warnx("%s: no variables defined for this protocol", string);
		return(-1);
	}
	if (*bufpp == NULL) {
		listall(string, lp);
		return(-1);
	}
	if ((indx = findname(string, "fourth", bufpp, lp)) == -1)
		return(-1);
	mib[3] = indx;
	*typep = lp->list[indx].ctl_type;
	return(4);
}

d888 2
d910 34
d967 1
a967 1
	if (indx <= IPPROTO_UDP && inetvars[indx].list != NULL)
@


1.37
log
@mib for pf_key is PF_KEY not PF_KEY_V2
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.36 1999/02/24 22:59:43 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.36 1999/02/24 22:59:43 angelos Exp $";
d66 1
d939 1
d948 1
a948 1
	{ 0, 0 },
@


1.36
log
@New position for the encdebug variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.35 1998/03/19 07:36:11 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.35 1998/03/19 07:36:11 deraadt Exp $";
d394 1
a394 1
		if (mib[1] == PF_KEY_V2) {
@


1.35
log
@fix type botches
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.34 1998/03/15 17:48:48 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.34 1998/03/15 17:48:48 millert Exp $";
a58 1

d79 1
a79 1
#include <net/encap.h>
d394 1
a394 1
		if (mib[1] == PF_ENCAP) {
d888 1
a888 1
struct ctlname encapname[] = ENCAPCTL_NAMES;
d892 1
a892 1
	{ encapname, ENCAPCTL_MAXID }, 
@


1.34
log
@Add support for vfs.* from lite2
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.33 1998/02/17 20:51:24 matthieu Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.33 1998/02/17 20:51:24 matthieu Exp $";
d244 2
a245 2
	int indx, type, state, len;
	size_t size;
a247 1
	int intval, newsize = 0;
@


1.33
log
@use warn() instead of warnx() to print error message
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.32 1997/10/25 21:46:06 mickey Exp $	*/
d45 1
a45 1
static char sccsid[] = "@@(#)sysctl.c	8.1 (Berkeley) 6/6/93";
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.32 1997/10/25 21:46:06 mickey Exp $";
d53 1
d102 1
d108 1
d130 1
d160 1
d195 1
a195 1
	if (Aflag || aflag) {
d197 1
d204 2
a205 2
	while (argc-- > 0)
		parse(*argv++, 1);
d245 1
a249 1
	size_t size;
d251 1
d271 2
d459 21
d756 1
a756 1
	for (loc = 0, i = 0; i < CTL_DEBUG_MAXID; i++) {
d765 45
@


1.32
log
@fix diskinfo listing, support blk2chr,chr2blk
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.31 1997/10/25 08:23:38 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.31 1997/10/25 08:23:38 mickey Exp $";
d496 1
a496 1
			warnx(string);
@


1.31
log
@make diskinfo working; fix one bug and one exploit
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.30 1997/10/22 23:40:35 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.30 1997/10/22 23:40:35 mickey Exp $";
d136 7
a142 5
#define	CONSDEV		0x00000004
#define RNDSTATS	0x00000008
#define BADDYNAMIC	0x00000010
#define BIOSGEO		0x00000020
#define BIOSDEV		0x00000040
d406 23
a428 1
			special |= CONSDEV;
d521 11
a531 1
	if (special & CONSDEV) {
a789 2
		if (!flags)
			return(-1);
@


1.30
log
@newer bios stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.29 1997/10/15 19:30:55 kstailey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.29 1997/10/15 19:30:55 kstailey Exp $";
d215 1
d236 1
a236 1
	int indx, type, state;
d241 1
a241 1
	size_t size, len;
d409 4
d415 1
a415 5
			if (mib[2] == BIOS_DEV)
				special |= BIOSDEV;
			if (len >= 0)
				break;
			return;
d468 3
d509 1
a509 1
		bios_diskinfo_t di = *(bios_diskinfo_t *)buf;
d513 4
a516 2
		printf("Cylinders=%d Tracks=%d Sectors=%d (%08x)\n",
		       di.bios_cylinders, di.bios_heads, di.bios_sectors);
d524 1
a524 5
		if (dev & 0x80)
			dev = ('c' + dev) & 0x7f;
		else
			dev += 'a';
		(void) printf("%c:\n", dev);
d745 1
d755 25
a779 2
	*typep = bioslist.list[indx].ctl_type;
	return(3);
@


1.29
log
@s/xntpd/xntpdc/
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.28 1997/10/03 21:15:19 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.28 1997/10/03 21:15:19 deraadt Exp $";
d408 1
a408 1
			if (mib[2] == BIOS_GEOMETRY)
d505 1
a505 1
		u_int geo = *(int *)buf;
d510 1
a510 1
		    BIOSNTRACKS(geo), BIOSNHEADS(geo), BIOSNSECTS(geo), geo);
@


1.28
log
@put real geo field in ()
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.27 1997/10/03 20:58:04 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.27 1997/10/03 20:58:04 deraadt Exp $";
d310 1
a310 1
			warnx("use xntpd to view %s information", string);
@


1.27
log
@avoid sign extension on bios geometry!
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.26 1997/09/21 23:02:03 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.26 1997/09/21 23:02:03 mickey Exp $";
d509 1
a509 1
		printf("Cylinders=%d Tracks=%d Sectors=%d %08x\n",
@


1.26
log
@new machdep.bios subtree
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.25 1997/09/12 03:56:08 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.25 1997/09/12 03:56:08 millert Exp $";
d505 1
a505 1
		int geo = *(int *)buf;
d509 2
a510 2
		(void) printf("spt = %d, tpc = %d\n",
			      BIOSNSECTS(geo), BIOSNHEADS(geo));
@


1.25
log
@Add parens to shut up -Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.24 1997/08/29 02:40:40 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.24 1997/08/29 02:40:40 mickey Exp $";
d89 1
a89 1
#ifdef CPU_BIOSGEOMETRY
d153 1
d405 11
a415 7
#ifdef CPU_BIOSGEOMETRY
		if (mib[1] == CPU_BIOSGEOMETRY)
			special |= BIOSGEO;
#endif
#ifdef CPU_BIOSDEV
		if (mib[1] == CPU_BIOSDEV)
			special |= BIOSDEV;
d503 1
a503 1
#ifdef CPU_BIOSGEOMETRY
a512 1
#endif
d525 1
d727 29
@


1.24
log
@fix case we have no CPU_BIOS* defined
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.23 1997/08/28 19:39:20 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.23 1997/08/28 19:39:20 mickey Exp $";
d515 1
a515 1
			dev = 'c' + dev & 0x7f;
@


1.23
log
@symbolic bios bootdev, s/hpc/tpc/ for bios geonetry
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.22 1997/08/28 19:31:51 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.22 1997/08/28 19:31:51 mickey Exp $";
d498 1
d508 1
@


1.22
log
@grok bios geometry
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.21 1997/08/19 23:20:32 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.21 1997/08/19 23:20:32 millert Exp $";
d140 1
d408 4
d503 1
a503 1
		(void) printf("spt = %d, hpc = %d\n",
d505 12
@


1.21
log
@Some KNF, check a few return values and use err/warn.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.20 1997/08/19 22:38:31 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.20 1997/08/19 22:38:31 millert Exp $";
d89 4
d139 1
d403 4
d491 9
@


1.20
log
@Move bad dynamic port parsing into parse_baddynamic().
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.19 1997/08/19 06:42:42 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.19 1997/08/19 06:42:42 millert Exp $";
d82 1
d134 1
a134 1
#define BADDYNAMIC	0x00000020
d137 4
d142 5
a146 9
void debuginit __P((void));
void parse __P((char *string, int flags));
void parse_baddynamic __P((int mib[CTL_MAXNAME], size_t len, char *string, void **newvalp, size_t *newsizep, int flags, int nflag));
void listall __P((char *prefix, struct list *lp));
int findname __P((char *string, char *level, char **bufp, struct list *namelist));
int sysctl_inet __P((char *string, char **bufpp, int mib[], int flags, int *typep));
int sysctl_ipsec __P((char *string, char **bufpp, int mib[], int flags, int *typep));
int sysctl_ipx __P((char *string, char **bufpp, int mib[], int flags, int *typep));
int sysctl_fs __P((char *string, char **bufpp, int mib[], int flags, int *typep));
d207 1
a207 1
	strncpy(name, prefix, BUFSIZ-1);
d213 1
a213 1
		strcpy(cp, lp->list[lvl2].ctl_name);
d238 2
a240 1
	snprintf(buf, BUFSIZ, "%s", string);
d242 2
a243 4
		if (!wflag) {
			fprintf(stderr, "Must specify -w to set variables\n");
			exit(2);
		}
d258 1
a258 2
		fprintf(stderr, "%s: class is not implemented\n",
		    topname[indx].ctl_name);
d276 2
a277 2
			size = sizeof state;
			if (sysctl(mib, 3, &state, &size, NULL, 0) < 0) {
d281 2
a282 3
					fprintf(stdout, "%s: ", string);
				fprintf(stdout,
				    "kernel is not compiled for profiling\n");
d286 1
a286 1
				fprintf(stdout, "%s = %s\n", string,
d293 1
a293 2
			fprintf(stderr,
			    "Use pstat to view %s information\n", string);
d298 1
a298 2
			fprintf(stderr,
			    "Use ps to view %s information\n", string);
d303 1
a303 2
			fprintf(stderr,
			    "Use xntpd to view %s information\n", string);
d326 3
a328 3
				fprintf(stdout, "%s = ", string);
			fprintf(stdout, "%.2f %.2f %.2f\n", 
			    loads[0], loads[1], loads[2]);
d334 8
a341 1
			sysctl(mib, 2, &_ps, &len, NULL, 0);
d343 2
a344 2
				fprintf(stdout, "%s = ", string);
			fprintf(stdout, "%ld\n", _ps.val);
d349 1
a349 2
		fprintf(stderr,
		    "Use vmstat or systat to view %s information\n", string);
d385 1
a385 1
		fprintf(stderr, "Use netstat to view %s information\n", string);
d411 1
a411 1
		fprintf(stderr, "Illegal top level value: %d\n", mib[0]);
d416 1
a416 1
		fprintf(stderr, "name %s in %s is unknown\n", bufp, string);
d424 1
a424 1
			newsize = sizeof intval;
d428 1
a428 1
			sscanf(newval, "%qd", &quadval);
d430 1
a430 1
			newsize = sizeof quadval;
d440 1
a440 1
			fprintf(stderr, "%s: value is not available\n", string);
d443 1
a443 2
			fprintf(stderr, "%s: specification is incomplete\n",
			    string);
d446 1
a446 2
			fprintf(stderr, "%s: type is unknown to this program\n",
			    string);
d449 1
a449 1
			perror(string);
d457 2
a458 2
			fprintf(stdout, "%s = ", string);
		fprintf(stdout,
d469 1
a469 1
			fprintf(stdout, "%s = %s\n", string, ctime(&boottime));
d471 1
a471 1
			fprintf(stdout, "%ld\n", btp->tv_sec);
d478 1
a478 1
			fprintf(stdout, "%s = %s\n", string,
d481 1
a481 1
			fprintf(stdout, "0x%x\n", dev);
d486 1
d488 2
a489 2
			fprintf(stdout, "%s = ", string);
		fprintf(stdout,
d506 1
a506 1
			printf("%s%s", string, newsize ? ": " : " = ");
d510 2
a511 1
				printf("%s%hd", lastport ? "," : "", port);
d522 2
a523 2
					printf("%s%hd", lastport ? "," : "",
					    port);
d527 1
a527 1
		putchar('\n');
d534 2
a535 2
				fprintf(stdout, "%s = ", string);
			fprintf(stdout, "%d\n", *(int *)buf);
d538 1
a538 1
				fprintf(stdout, "%s: %d -> ", string,
d540 1
a540 1
			fprintf(stdout, "%d\n", *(int *)newval);
d547 2
a548 2
				fprintf(stdout, "%s = ", string);
			fprintf(stdout, "%s\n", buf);
d551 2
a552 2
				fprintf(stdout, "%s: %s -> ", string, buf);
			fprintf(stdout, "%s\n", (char *)newval);
d559 2
a560 2
				fprintf(stdout, "%s = ", string);
			fprintf(stdout, "%qd\n", *(quad_t *)buf);
d563 1
a563 1
				fprintf(stdout, "%s: %qd -> ", string,
d565 1
a565 1
			fprintf(stdout, "%qd\n", *(quad_t *)newval);
d570 1
a570 2
		fprintf(stderr, "%s: unknown structure returned\n",
		    string);
d575 1
a575 2
		fprintf(stderr, "%s: unknown type returned\n",
		    string);
d582 1
a582 1
	int mib[CTL_MAXNAME];
d597 1
a597 1
		if (sysctl(mib, len, newbaddynamic, &size, 0, 0) < 0) {
d601 2
a602 2
				printf("%s: ", string);
			printf("kernel does contain bad dynamic port tables\n");
d677 1
a677 1
		return (-1);
d680 1
a680 1
		return (-1);
d683 1
a683 1
	return (3);
d709 1
a709 1
		return (-1);
d712 1
a712 1
		return (-1);
d717 1
a717 1
		return (-1);
d719 2
a720 3
		fprintf(stderr, "%s: no variables defined for this protocol\n",
		    string);
		return (-1);
d724 1
a724 1
		return (-1);
d727 1
a727 1
		return (-1);
d730 1
a730 1
	return (4);
d776 1
a776 1
		return (-1);
d779 1
a779 1
		return (-1);
d784 1
a784 1
		return (-1);
d786 2
a787 3
		fprintf(stderr, "%s: no variables defined for this protocol\n",
		    string);
		return (-1);
d791 1
a791 1
		return (-1);
d794 1
a794 1
		return (-1);
d797 1
a797 1
	return (4);
d814 1
a814 1
 * handle internet requests
d829 1
a829 1
		return (-1);
d832 1
a832 1
		return (-1);
d837 1
a837 1
		return (-1);
d839 2
a840 3
		fprintf(stderr, "%s: no variables defined for this protocol\n",
		    string);
		return (-1);
d844 1
a844 1
		return (-1);
d847 1
a847 1
		return (-1);
d850 1
a850 1
	return (4);
d867 2
a868 2
		fprintf(stderr, "%s: incomplete specification\n", string);
		return (-1);
d875 2
a876 3
		fprintf(stderr, "%s level name %s in %s is invalid\n",
		    level, name, string);
		return (-1);
d878 1
a878 1
	return (i);
@


1.19
log
@Add support for adding/subtracting ports from the current baddynamic
mask.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.17 1997/08/19 05:53:12 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.17 1997/08/19 05:53:12 millert Exp $";
d136 10
a145 9
void usage();
void debuginit();
void parse __P((	char *string, int flags));
void listall __P((char *prefix, 	struct list *lp));
int findname __P((char *string, 	char *level, char **bufp, struct list *namelist));
int sysctl_inet __P((char *string, char **bufpp, 	int mib[], int flags, int *typep));
int sysctl_ipsec __P((char *string, char **bufpp, 	int mib[], int flags, int *typep));
int sysctl_ipx __P((char *string, char **bufpp, 	int mib[], int flags, int *typep));
int sysctl_fs __P((char *string, char **bufpp, 	int mib[], int flags, int *typep));
a151 2
	extern char *optarg;
	extern int optind;
d356 1
a360 3
				u_int32_t newbaddynamic[DP_MAPSIZE];
				in_port_t port;
				char action;
a362 2
				if (newval == NULL)
					break;
d364 3
a366 53
				if (strchr((char *)newval, '+') ||
				    strchr((char *)newval, '-')) {
					size = sizeof(newbaddynamic);
					if (sysctl(mib, len, newbaddynamic,
					    &size, 0, 0) < 0) {
						if (flags == 0)
							return;
						if (!nflag)
							printf("%s: ", string);
						printf("kernel does not have "
						    "bad dynamic port tables "
						    "in it\n");
						return;
					}
					while (newval &&
					    (cp = strsep((char **)&newval,
					    ", \t")) && *cp) {
						if (*cp != '+' && *cp != '-')
							errx(1, "cannot mix +/-"
							    " with full list");
						action = *cp++;
						port = atoi(cp);
						if (port < IPPORT_RESERVED/2 ||
						    port >= IPPORT_RESERVED)
							errx(1, "invalid port, "
							    "range is %d to %d",
							    IPPORT_RESERVED/2,
							    IPPORT_RESERVED-1);
						if (action == '+')
							DP_SET(newbaddynamic,
							    port);
						else
							DP_CLR(newbaddynamic,
							    port);
					}
				} else {
					(void)memset((void *)newbaddynamic, 0,
					    sizeof(newbaddynamic));
					while (newval &&
					    (cp = strsep((char **)&newval,
					    ", \t")) && *cp) {
						port = atoi(cp);
						if (port < IPPORT_RESERVED/2 ||
						    port >= IPPORT_RESERVED)
							errx(1, "invalid port, "
							    "range is %d to %d",
							    IPPORT_RESERVED/2,
							    IPPORT_RESERVED-1);
						DP_SET(newbaddynamic, port);
					}
				}
				newval = (void *)newbaddynamic;
				newsize = sizeof(newbaddynamic);
d579 54
@


1.18
log
@typo
@
text
@d363 1
d369 50
a418 12
				(void)memset((void *)&newbaddynamic, 0,
				    sizeof(newbaddynamic));
				while (newval && (cp = strsep((char **)&newval,
				    ", \t")) && *cp) {
					port = atoi(cp);
					if (port < IPPORT_RESERVED/2 ||
					    port >= IPPORT_RESERVED)
						errx(1, "invalid port, "
						    "range is %d to %d",
						    IPPORT_RESERVED/2,
						    IPPORT_RESERVED-1);
					DP_SET(newbaddynamic, port);
@


1.17
log
@Make net.inet.tcp.baddynamic and net.inet.udp.baddynamic
comma-separated instead of space-separated when printing
so it is easy to cut and paste.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.16 1997/08/19 05:32:57 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.16 1997/08/19 05:32:57 millert Exp $";
d365 1
a365 1
				if (newval == NULL);
@


1.16
log
@Only print bad dynamic ports list for udp and tcp since that's all
that exist.  This fixes a bug where net.inet.ip.redirect,
net.inet.ip.directed-broadcast, and net.inet.tcp.keepinittimem
got interpreted as dynamic port lists.  Oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.15 1997/08/09 23:36:31 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.15 1997/08/09 23:36:31 millert Exp $";
d365 15
a379 17
				if (newval != NULL) {
					(void)memset((void *)&newbaddynamic, 0,
					    sizeof(newbaddynamic));
					while (newval &&
					    (cp = strsep((char **)&newval,
					    ", \t")) && *cp) {
						port = atoi(cp);
						if (port < IPPORT_RESERVED/2 ||
						    port >= IPPORT_RESERVED)
							errx(1, "invalid port, "
							    "range is %d to %d",
							    IPPORT_RESERVED/2,
							    IPPORT_RESERVED-1);
						DP_SET(newbaddynamic, port);
					}
					newval = (void *)newbaddynamic;
					newsize = sizeof(newbaddynamic);
d381 2
d518 1
a518 1
		in_port_t port;
d522 2
a523 1
			printf("%s%s", string, newsize ? ":" : " =");
d525 4
a528 2
			if (DP_ISSET(baddynamic, port))
				printf(" %hd", port);
d531 1
a531 1
				fputs(" ->", stdout);
d533 1
d536 5
a540 2
				if (DP_ISSET(baddynamic, port))
					printf(" %hd", port);
@


1.15
log
@The list of tcp/udp ports not to allocate dynamically is now
a bitmask configurable via sysctl([38]).  The default values
have not changed.  If one wants to change the list it should
be done early on in /etc/rc.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.14 1997/07/22 15:06:54 kstailey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.14 1997/07/22 15:06:54 kstailey Exp $";
d357 4
a360 2
			if (mib[3] == TCPCTL_BADDYNAMIC ||
			    mib[3] == UDPCTL_BADDYNAMIC) {
@


1.14
log
@tabify, use NULL for ptr ops, not 0
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.13 1997/07/22 14:43:19 kstailey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.13 1997/07/22 14:43:19 kstailey Exp $";
d59 2
d64 1
d133 1
d355 28
a382 3
			if (len >= 0)
				break;
			return;
d513 21
@


1.13
log
@re-tabify (angelos!)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.12 1997/07/15 00:38:15 angelos Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.12 1997/07/15 00:38:15 angelos Exp $";
d201 1
a201 1
	if (lp->list == 0)
d207 1
a207 1
		if (lp->list[lvl2].ctl_name == 0)
d594 1
a594 1
        { encapname, ENCAPCTL_MAXID }, 
d603 4
a606 4
        char **bufpp;
        int mib[];
        int flags;
        int *typep;
d608 2
a609 2
        struct list *lp;
        int indx;
d611 7
a617 7
        if (*bufpp == NULL) {
                listall(string, &ipseclist);
                return (-1);
        }
        if ((indx = findname(string, "third", bufpp, &ipseclist)) == -1)
                return (-1);
        mib[2] = indx;
d619 1
a619 1
	 	lp = &ipsecvars[indx];
d627 9
a635 9
        if (*bufpp == NULL) {
                listall(string, lp);
                return (-1);
        }
        if ((indx = findname(string, "fourth", bufpp, lp)) == -1)
                return (-1);
        mib[3] = indx;
        *typep = lp->list[indx].ctl_type;
        return (4);
@


1.12
log
@sysctl for PF_ENCAP.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.11 1997/06/28 07:05:34 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.11 1997/06/28 07:05:34 deraadt Exp $";
d645 18
a662 18
        { ipname, IPCTL_MAXID },        /* ip */
        { icmpname, ICMPCTL_MAXID },    /* icmp */
        { 0, 0 },                       /* igmp */
        { 0, 0 },                       /* ggmp */
        { 0, 0 },
        { 0, 0 },
        { tcpname, TCPCTL_MAXID },      /* tcp */
        { 0, 0 },
        { 0, 0 },                       /* egp */
        { 0, 0 },
        { 0, 0 },
        { 0, 0 },
        { 0, 0 },                       /* pup */
        { 0, 0 },
        { 0, 0 },
        { 0, 0 },
        { 0, 0 },
        { udpname, UDPCTL_MAXID },      /* udp */
@


1.11
log
@fix the rnd types
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.10 1997/06/24 02:45:02 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.10 1997/06/24 02:45:02 mickey Exp $";
d76 2
d138 1
d361 6
d590 48
d645 18
a662 18
	{ ipname, IPCTL_MAXID },	/* ip */
	{ icmpname, ICMPCTL_MAXID },	/* icmp */
	{ 0, 0 },			/* igmp */
	{ 0, 0 },			/* ggmp */
	{ 0, 0 },
	{ 0, 0 },
	{ tcpname, TCPCTL_MAXID },	/* tcp */
	{ 0, 0 },
	{ 0, 0 },			/* egp */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },			/* pup */
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ 0, 0 },
	{ udpname, UDPCTL_MAXID },	/* udp */
@


1.10
log
@more accounting!
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.9 1997/06/17 19:42:02 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.9 1997/06/17 19:42:02 mickey Exp $";
d466 9
a474 9
		        "%lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\n",
			rndstats->rnd_total, rndstats->rnd_used,
			rndstats->arc4_reads, rndstats->rnd_timer,
			rndstats->rnd_mouse, rndstats->rnd_tty,
			rndstats->rnd_disk, rndstats->rnd_net,
			rndstats->rnd_reads, rndstats->rnd_waits,
			rndstats->rnd_enqs, rndstats->rnd_deqs,
			rndstats->rnd_drops, rndstats->rnd_drople,
			rndstats->rnd_asleep, rndstats->rnd_queued);
@


1.9
log
@count slow queue low entropy drops
bigger queue
use queue overflows for arc4_stir()
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.8 1997/06/14 21:37:12 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.8 1997/06/14 21:37:12 mickey Exp $";
d466 1
a466 1
		        "%lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\n",
d473 2
a474 1
			rndstats->rnd_drops, rndstats->rnd_drople);
@


1.8
log
@split the treatment of the random events
event_q by flipk@@
spl fix by deraadt@@
gother statistics about whole processing
use 'sysctl kern.random' to view what had happened
also fix wrong vm.psstrings description
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.7 1997/04/06 20:19:22 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.7 1997/04/06 20:19:22 millert Exp $";
d282 1
a282 1
				fprintf(stdout, "%s: %s\n", string,
d325 1
a325 1
				fprintf(stdout, "%s: ", string);
d335 1
a335 1
				fprintf(stdout, "%s: ", string);
d434 1
a434 1
			fprintf(stdout, "%s: ", string);
d464 1
a464 1
			fprintf(stdout, "%s: ", string);
d466 1
a466 1
		        "%lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\n",
d473 1
a473 1
			rndstats->rnd_drops);
@


1.7
log
@Use a size_t as arg 4 to sysctl(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.6 1997/01/16 03:57:31 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.6 1997/01/16 03:57:31 millert Exp $";
d75 1
d127 1
d277 1
a277 1
				fprintf(stderr,
d310 3
d459 15
@


1.6
log
@Support VM_PSSTRINGS.  Man, this has been sitting in my tree for a while...
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.5 1997/01/15 23:44:22 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.5 1997/01/15 23:44:22 millert Exp $";
d219 1
a219 1
	int indx, type, state, len;
d224 1
a224 1
	size_t size;
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: sysctl.c,v 1.4 1996/11/25 08:22:43 mickey Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: sysctl.c,v 1.4 1996/11/25 08:22:43 mickey Exp $";
d323 9
@


1.4
log
@ipx sysctl.
cleanup (protyping, printf formats and so)
1 (one) bug fix in printf's arg (struct instead of field)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD$";
d146 1
a146 1
	while ((ch = getopt(argc, argv, "Aanw")) != EOF) {
@


1.3
log
@Make {,f}chown(2) behaviour POSIX.1 compliant with SUID / SGID files
Enable CTL_FS processing by sysctl(3)
Add CTL_FS request to disable clearing SUID / SGID bit when a files owner
or group is changed by root
Make sysctl(8) understand CTL_FS requests
@
text
@d1 1
d47 1
a47 1
static char *rcsid = "$NetBSD: sysctl.c,v 1.9 1995/09/30 07:12:50 thorpej Exp $";
d70 4
d80 1
d127 10
d188 1
d198 1
a198 1
	strcpy(name, prefix);
d214 1
d227 1
a227 1
	char *cp, *bufp, buf[BUFSIZ], strval[BUFSIZ];
d251 1
a251 1
		    topname[indx]);
d338 6
d434 1
a434 1
			fprintf(stdout, "%d\n", btp->tv_sec);
d469 1
a469 1
			fprintf(stdout, "%s\n", newval);
d502 1
d530 1
a537 1
	struct list *lp;
d581 1
d619 54
d676 1
d702 1
@


1.2
log
@DDB support added.
@
text
@d79 1
d99 1
a99 1
	{ 0, 0 },			/* CTL_FS */
d278 6
d338 5
d497 27
@


1.1
log
@Initial revision
@
text
@d69 1
d86 1
d108 1
d332 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

