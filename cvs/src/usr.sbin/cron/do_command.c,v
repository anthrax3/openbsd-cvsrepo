head	1.56;
access;
symbols
	OPENBSD_6_1_BASE:1.56
	OPENBSD_6_0:1.56.0.4
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.46.0.6
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.38.0.6
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.36.0.6
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.4
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.2
	OPENBSD_5_0:1.35.0.2
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.12
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.8
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.6
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.4
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.30.0.4
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.29.0.8
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.6
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.4
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.56
date	2015.11.17.22.31.44;	author millert;	state Exp;
branches;
next	1.55;
commitid	1DwT6xt7W42FCut9;

1.55
date	2015.11.15.23.24.24;	author millert;	state Exp;
branches;
next	1.54;
commitid	4K3ElIFSUCsF9sYF;

1.54
date	2015.11.14.13.09.14;	author millert;	state Exp;
branches;
next	1.53;
commitid	KNISMJYcyEJqWs74;

1.53
date	2015.11.09.16.37.07;	author millert;	state Exp;
branches;
next	1.52;
commitid	ZJUG9DwHA5l6WcX2;

1.52
date	2015.11.04.20.28.17;	author millert;	state Exp;
branches;
next	1.51;
commitid	6N0oXtYc5KM1a7DW;

1.51
date	2015.10.29.22.41.27;	author millert;	state Exp;
branches;
next	1.50;
commitid	XUZIZeIqHdm2HbHG;

1.50
date	2015.10.25.21.30.11;	author millert;	state Exp;
branches;
next	1.49;
commitid	Z2UkA4v651dEbyJ1;

1.49
date	2015.10.23.18.42.55;	author tedu;	state Exp;
branches;
next	1.48;
commitid	XKGk51XvBaSkXmrX;

1.48
date	2015.10.03.19.47.21;	author tedu;	state Exp;
branches;
next	1.47;
commitid	34TKQiezOQXb6h1Y;

1.47
date	2015.10.03.12.46.54;	author tedu;	state Exp;
branches;
next	1.46;
commitid	WlajD40E0eJCM3xO;

1.46
date	2015.02.09.22.35.08;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	eGq01x6bjr83TVho;

1.45
date	2015.01.23.19.07.27;	author tedu;	state Exp;
branches;
next	1.44;
commitid	YJA2vmvfLuMfGdwZ;

1.44
date	2015.01.23.02.37.25;	author tedu;	state Exp;
branches;
next	1.43;
commitid	UGPHvhzwRtnjrF9O;

1.43
date	2015.01.23.01.03.03;	author tedu;	state Exp;
branches;
next	1.42;
commitid	tWLCGXaX7sMf6hkJ;

1.42
date	2015.01.23.01.01.06;	author tedu;	state Exp;
branches;
next	1.41;
commitid	kzBIhYnXdVeOLxgw;

1.41
date	2015.01.14.17.30.53;	author millert;	state Exp;
branches;
next	1.40;
commitid	qsePpGDsMLqV3DYZ;

1.40
date	2015.01.14.17.27.51;	author millert;	state Exp;
branches;
next	1.39;
commitid	29asVUstLv6pyoCO;

1.39
date	2015.01.14.17.27.30;	author millert;	state Exp;
branches;
next	1.38;
commitid	jXmo2gNqOzD6QEsx;

1.38
date	2013.11.23.18.23.00;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2013.03.07.11.13.54;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2011.08.22.19.32.42;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2011.03.03.15.08.14;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2010.12.14.23.32.06;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.25.17.50.41;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.10.17.14.43;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.13.20.44.00;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.17.22.11.55;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.06.23.56.26;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.03.19.54.04;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.26.17.15.37;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.30.20.20.01;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.14.15.58.13;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.20.20.38.08;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.08.18.17.50;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.15.22.38.36;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.15.22.16.50;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.15.19.13.29;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.12.18.35.24;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.08.18.11.02;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.23.03.07.19;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.21.21.10.32;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.14.21.35.01;	author todd;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.19.18.38.02;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.09.00.51.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.24.17.28.16;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.18.19.48.33;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.21.21.08.56;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.20.18.42.42;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.03.15.36.38;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.08.28.20.13.13;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.05.08.20.17.18;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.03.30.06.59.43;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.12.22.08.10.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.07.06.18.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.30;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Check pipe(2) return value; noticed by deraadt@@
@
text
@/*	$OpenBSD: do_command.c,v 1.55 2015/11/15 23:24:24 millert Exp $	*/

/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
 * Copyright (c) 1997,2000 by Internet Software Consortium, Inc.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/wait.h>

#include <bitstring.h>		/* for structs.h */
#include <bsd_auth.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <login_cap.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>		/* for structs.h */
#include <unistd.h>
#include <vis.h>

#include "config.h"
#include "pathnames.h"
#include "macros.h"
#include "structs.h"
#include "funcs.h"

static void		child_process(entry *, user *);

void
do_command(entry *e, user *u)
{

	/* fork to become asynchronous -- parent process is done immediately,
	 * and continues to run the normal cron code, which means return to
	 * tick().  the child and grandchild don't leave this function, alive.
	 *
	 * vfork() is unsuitable, since we have much to do, and the parent
	 * needs to be able to run off and fork other processes.
	 */
	switch (fork()) {
	case -1:
		syslog(LOG_ERR, "(CRON) CAN'T FORK (%m)");
		break;
	case 0:
		/* child process */
		child_process(e, u);
		_exit(EXIT_SUCCESS);
		break;
	default:
		/* parent process */
		break;
	}
}

static void
child_process(entry *e, user *u)
{
	FILE *in;
	int stdin_pipe[2], stdout_pipe[2];
	char **p, *input_data, *usernm;
	auth_session_t *as;
	login_cap_t *lc;
	int children = 0;
	extern char **environ;

	/* mark ourselves as different to PS command watchers */
	setproctitle("running job");

	/* discover some useful and important environment settings
	 */
	usernm = e->pwd->pw_name;

	/* our parent is watching for our death by catching SIGCHLD.  we
	 * do not care to watch for our children's deaths this way -- we
	 * use wait() explicitly.  so we have to reset the signal (which
	 * was inherited from the parent).
	 */
	(void) signal(SIGCHLD, SIG_DFL);

	/* create some pipes to talk to our future child
	 */
	if (pipe(stdin_pipe) != 0 || pipe(stdout_pipe) != 0) {
		syslog(LOG_ERR, "(CRON) PIPE (%m)");
		_exit(EXIT_FAILURE);
	}

	/* since we are a forked process, we can diddle the command string
	 * we were passed -- nobody else is going to use it again, right?
	 *
	 * if a % is present in the command, previous characters are the
	 * command, and subsequent characters are the additional input to
	 * the command.  An escaped % will have the escape character stripped
	 * from it.  Subsequent %'s will be transformed into newlines,
	 * but that happens later.
	 */
	/*local*/{
		int escaped = FALSE;
		int ch;
		char *p;

		for (input_data = p = e->cmd;
		     (ch = *input_data) != '\0';
		     input_data++, p++) {
			if (p != input_data)
				*p = ch;
			if (escaped) {
				if (ch == '%')
					*--p = ch;
				escaped = FALSE;
				continue;
			}
			if (ch == '\\') {
				escaped = TRUE;
				continue;
			}
			if (ch == '%') {
				*input_data++ = '\0';
				break;
			}
		}
		*p = '\0';
	}

	/* fork again, this time so we can exec the user's command.
	 */
	switch (fork()) {
	case -1:
		syslog(LOG_ERR, "(CRON) CAN'T FORK (%m)");
		_exit(EXIT_FAILURE);
		/*NOTREACHED*/
	case 0:
		/* write a log message.  we've waited this long to do it
		 * because it was not until now that we knew the PID that
		 * the actual user command shell was going to get and the
		 * PID is part of the log message.
		 */
		if ((e->flags & DONT_LOG) == 0) {
			char *x;
			if (stravis(&x, e->cmd, 0) != -1) {
				syslog(LOG_INFO, "(%s) CMD (%s)", usernm, x);
				free(x);
			}
		}

		/* get new pgrp, void tty, etc.
		 */
		(void) setsid();

		/* close the pipe ends that we won't use.  this doesn't affect
		 * the parent, who has to read and write them; it keeps the
		 * kernel from recording us as a potential client TWICE --
		 * which would keep it from sending SIGPIPE in otherwise
		 * appropriate circumstances.
		 */
		close(stdin_pipe[WRITE_PIPE]);
		close(stdout_pipe[READ_PIPE]);

		/* grandchild process.  make std{in,out} be the ends of
		 * pipes opened by our daddy; make stderr go to stdout.
		 */
		if (stdin_pipe[READ_PIPE] != STDIN_FILENO) {
			dup2(stdin_pipe[READ_PIPE], STDIN_FILENO);
			close(stdin_pipe[READ_PIPE]);
		}
		if (stdout_pipe[WRITE_PIPE] != STDOUT_FILENO) {
			dup2(stdout_pipe[WRITE_PIPE], STDOUT_FILENO);
			close(stdout_pipe[WRITE_PIPE]);
		}
		dup2(STDOUT_FILENO, STDERR_FILENO);

		/*
		 * From this point on, anything written to stderr will be
		 * mailed to the user as output.
		 */

		/* XXX - should just pass in a login_cap_t * */
		if ((lc = login_getclass(e->pwd->pw_class)) == NULL) {
			warnx("unable to get login class for %s",
			    e->pwd->pw_name);
			syslog(LOG_ERR, "(CRON) CAN'T GET LOGIN CLASS (%s)",
			    e->pwd->pw_name);
			_exit(EXIT_FAILURE);
		}
		if (setusercontext(lc, e->pwd, e->pwd->pw_uid, LOGIN_SETALL) < 0) {
			warn("setusercontext failed for %s", e->pwd->pw_name);
			syslog(LOG_ERR, "(%s) SETUSERCONTEXT FAILED (%m)",
			    e->pwd->pw_name);
			_exit(EXIT_FAILURE);
		}
		as = auth_open();
		if (as == NULL || auth_setpwd(as, e->pwd) != 0) {
			warn("auth_setpwd");
			syslog(LOG_ERR, "(%s) AUTH_SETPWD FAILED (%m)",
			    e->pwd->pw_name);
			_exit(EXIT_FAILURE);
		}
		if (auth_approval(as, lc, usernm, "cron") <= 0) {
			warnx("approval failed for %s", e->pwd->pw_name);
			syslog(LOG_ERR, "(%s) APPROVAL FAILED (cron)",
			    e->pwd->pw_name);
			_exit(EXIT_FAILURE);
		}
		auth_close(as);
		login_close(lc);

		/* If no PATH specified in crontab file but
		 * we just added one via login.conf, add it to
		 * the crontab environment.
		 */
		if (env_get("PATH", e->envp) == NULL && environ != NULL) {
			for (p = environ; *p; p++) {
				if (strncmp(*p, "PATH=", 5) == 0) {
					e->envp = env_set(e->envp, *p);
					break;
				}
			}
		}
		chdir(env_get("HOME", e->envp));

		(void) signal(SIGPIPE, SIG_DFL);

		/*
		 * Exec the command.
		 */
		{
			char	*shell = env_get("SHELL", e->envp);

			execle(shell, shell, "-c", e->cmd, (char *)NULL, e->envp);
			warn("unable to execute %s", shell);
			syslog(LOG_ERR, "(%s) CAN'T EXEC (%s: %m)",
			    e->pwd->pw_name, shell);
			_exit(EXIT_FAILURE);
		}
		break;
	default:
		/* parent process */
		break;
	}

	children++;

	/* middle process, child of original cron, parent of process running
	 * the user's command.
	 */

	/* close the ends of the pipe that will only be referenced in the
	 * grandchild process...
	 */
	close(stdin_pipe[READ_PIPE]);
	close(stdout_pipe[WRITE_PIPE]);

	/*
	 * write, to the pipe connected to child's stdin, any input specified
	 * after a % in the crontab entry.  while we copy, convert any
	 * additional %'s to newlines.  when done, if some characters were
	 * written and the last one wasn't a newline, write a newline.
	 *
	 * Note that if the input data won't fit into one pipe buffer (2K
	 * or 4K on most BSD systems), and the child doesn't read its stdin,
	 * we would block here.  thus we must fork again.
	 */

	if (*input_data && fork() == 0) {
		FILE *out = fdopen(stdin_pipe[WRITE_PIPE], "w");
		int need_newline = FALSE;
		int escaped = FALSE;
		int ch;

		/* close the pipe we don't use, since we inherited it and
		 * are part of its reference count now.
		 */
		close(stdout_pipe[READ_PIPE]);

		/* translation:
		 *	\% -> %
		 *	%  -> \n
		 *	\x -> \x	for all x != %
		 */
		while ((ch = *input_data++) != '\0') {
			if (escaped) {
				if (ch != '%')
					putc('\\', out);
			} else {
				if (ch == '%')
					ch = '\n';
			}

			if (!(escaped = (ch == '\\'))) {
				putc(ch, out);
				need_newline = (ch != '\n');
			}
		}
		if (escaped)
			putc('\\', out);
		if (need_newline)
			putc('\n', out);

		/* close the pipe, causing an EOF condition.  fclose causes
		 * stdin_pipe[WRITE_PIPE] to be closed, too.
		 */
		fclose(out);

		_exit(EXIT_SUCCESS);
	}

	/* close the pipe to the grandkiddie's stdin, since its wicked uncle
	 * ernie back there has it open and will close it when he's done.
	 */
	close(stdin_pipe[WRITE_PIPE]);

	children++;

	/*
	 * read output from the grandchild.  it's stderr has been redirected to
	 * it's stdout, which has been redirected to our pipe.  if there is any
	 * output, we'll be mailing it to the user whose crontab this is...
	 * when the grandchild exits, we'll get EOF.
	 */

	(void) signal(SIGPIPE, SIG_IGN);
	in = fdopen(stdout_pipe[READ_PIPE], "r");
	if (in != NULL) {
		int	ch = getc(in);

		if (ch != EOF) {
			FILE	*mail = NULL;
			char	*mailto;
			size_t	bytes = 1;
			int	status = 0;
			pid_t	mailpid;

			/* get name of recipient.  this is MAILTO if set to a
			 * valid local username; USER otherwise.
			 */
			mailto = env_get("MAILTO", e->envp);
			if (!mailto) {
				/* MAILTO not present, set to USER.
				 */
				mailto = usernm;
			} else if (!*mailto || !safe_p(usernm, mailto)) {
				mailto = NULL;
			}

			/* if we are supposed to be mailing, MAILTO will
			 * be non-NULL.  only in this case should we set
			 * up the mail command and subjects and stuff...
			 */

			if (mailto) {
				char	**env;
				char	mailcmd[MAX_COMMAND];
				char	hostname[HOST_NAME_MAX + 1];

				gethostname(hostname, sizeof(hostname));
				if (snprintf(mailcmd, sizeof mailcmd,  MAILFMT,
				    MAILARG) >= sizeof mailcmd) {
					syslog(LOG_ERR,
					    "(%s) ERROR (mailcmd too long)",
					    e->pwd->pw_name);
					(void) _exit(EXIT_FAILURE);
				}
				if (!(mail = cron_popen(mailcmd, "w", e->pwd,
				    &mailpid))) {
					syslog(LOG_ERR, "(%s) POPEN (%s)",
					    e->pwd->pw_name, mailcmd);
					(void) _exit(EXIT_FAILURE);
				}
				fprintf(mail, "From: root (Cron Daemon)\n");
				fprintf(mail, "To: %s\n", mailto);
				fprintf(mail, "Subject: Cron <%s@@%s> %s\n",
					usernm, first_word(hostname, "."),
					e->cmd);
				fprintf(mail, "Auto-Submitted: auto-generated\n");
				for (env = e->envp;  *env;  env++)
					fprintf(mail, "X-Cron-Env: <%s>\n",
						*env);
				fprintf(mail, "\n");

				/* this was the first char from the pipe
				 */
				fputc(ch, mail);
			}

			/* we have to read the input pipe no matter whether
			 * we mail or not, but obviously we only write to
			 * mail pipe if we ARE mailing.
			 */

			while (EOF != (ch = getc(in))) {
				bytes++;
				if (mail)
					fputc(ch, mail);
			}

			/* only close pipe if we opened it -- i.e., we're
			 * mailing...
			 */

			if (mail) {
				/* Note: the pclose will probably see
				 * the termination of the grandchild
				 * in addition to the mail process, since
				 * it (the grandchild) is likely to exit
				 * after closing its stdout.
				 */
				status = cron_pclose(mail, mailpid);
			}

			/* if there was output and we could not mail it,
			 * log the facts so the poor user can figure out
			 * what's going on.
			 */
			if (mail && status) {
				syslog(LOG_NOTICE, "(%s) MAIL (mailed %zu byte"
				"%s of output but got status 0x%04x)", usernm,
				bytes, (bytes == 1) ? "" : "s", status);
			}

		} /*if data from grandchild*/

		fclose(in);	/* also closes stdout_pipe[READ_PIPE] */
	}

	/* wait for children to die.
	 */
	for (; children > 0; children--) {
		int waiter;
		pid_t pid;

		while ((pid = wait(&waiter)) < 0 && errno == EINTR)
			;
		if (pid < 0) {
			break;
		}
		/*
		if (WIFSIGNALED(waiter) && WCOREDUMP(waiter))
			Debug(DPROC, (", dumped core"))
		*/
	}
}

int
safe_p(const char *usernm, const char *s)
{
	static const char safe_delim[] = "@@!:%+-.,";     /* conservative! */
	const char *t;
	int ch, first;

	for (t = s, first = 1; (ch = (unsigned char)*t++) != '\0'; first = 0) {
		if (isascii(ch) && isprint(ch) &&
		    (isalnum(ch) || ch == '_' ||
		    (!first && strchr(safe_delim, ch))))
			continue;
		syslog(LOG_WARNING, "(%s) UNSAFE (%s)", usernm, s);
		return (FALSE);
	}
	return (TRUE);
}
@


1.55
log
@Clean up the remaining uses of stderr and perror() and use warn/err
and/or syslog depending on whether stderr is hooked up at the time.
Also remove closelog() which is not needed since we are headed for exec.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.54 2015/11/14 13:09:14 millert Exp $	*/
d102 4
a105 2
	pipe(stdin_pipe);	/* child's stdin */
	pipe(stdout_pipe);	/* child's stdout */
@


1.54
log
@Remove log_it() and call syslog(3) directly using the same format:
"(username) WHAT (details)".  Logs due to normal operation (e.g.
crontab operations or running commands) are logged at LOG_INFO like
before.  Actual errors are logged at LOG_ERR, less important things
are logged at LOG_WARNING OR LOG_NOTICE.  Also ignore SIGHUP now
that there is no log file to reopen.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.53 2015/11/09 16:37:07 millert Exp $	*/
d26 1
d80 3
a82 1
	char *input_data, *usernm;
d84 1
a162 4
		/* that's the last thing we'll log.  close the log files.
		 */
		closelog();

d189 3
a191 2
		/* set our directory, uid and gid.  Set gid first, since once
		 * we set uid, we've lost root privileges.
a192 31
		{
			auth_session_t *as;
			login_cap_t *lc;
			char **p;
			extern char **environ;

			/* XXX - should just pass in a login_cap_t * */
			if ((lc = login_getclass(e->pwd->pw_class)) == NULL) {
				fprintf(stderr,
				    "unable to get login class for %s\n",
				    e->pwd->pw_name);
				_exit(EXIT_FAILURE);
			}
			if (setusercontext(lc, e->pwd, e->pwd->pw_uid, LOGIN_SETALL) < 0) {
				fprintf(stderr,
				    "setusercontext failed for %s\n",
				    e->pwd->pw_name);
				_exit(EXIT_FAILURE);
			}
			as = auth_open();
			if (as == NULL || auth_setpwd(as, e->pwd) != 0) {
				fprintf(stderr, "can't malloc\n");
				_exit(EXIT_FAILURE);
			}
			if (auth_approval(as, lc, usernm, "cron") <= 0) {
				fprintf(stderr, "approval failed for %s\n",
				    e->pwd->pw_name);
				_exit(EXIT_FAILURE);
			}
			auth_close(as);
			login_close(lc);
d194 39
a232 10
			/* If no PATH specified in crontab file but
			 * we just added one via login.conf, add it to
			 * the crontab environment.
			 */
			if (env_get("PATH", e->envp) == NULL && environ != NULL) {
				for (p = environ; *p; p++) {
					if (strncmp(*p, "PATH=", 5) == 0) {
						e->envp = env_set(e->envp, *p);
						break;
					}
d247 3
a249 2
			fprintf(stderr, "execle: couldn't exec `%s'\n", shell);
			perror("execle");
d375 3
a377 1
					fprintf(stderr, "mailcmd too long\n");
d382 2
a383 1
					perror(mailcmd);
@


1.53
log
@Remove unused xpid argument to log_it().
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.52 2015/11/04 20:28:17 millert Exp $	*/
d35 1
d61 1
a61 1
		log_it("CRON", "error", "can't fork");
d142 1
a142 1
		log_it("CRON", "error", "can't fork");
d154 1
a154 1
				log_it(usernm, "CMD", x);
d161 1
a161 1
		log_close();
d346 1
a346 1
			int	bytes = 1;
d429 3
a431 7
				char buf[MAX_TEMPSTR];

				snprintf(buf, sizeof buf,
			"mailed %d byte%s of output but got status 0x%04x\n",
					bytes, (bytes==1)?"":"s",
					status);
				log_it(usernm, "MAIL", buf);
d469 1
a469 1
		log_it(usernm, "UNSAFE", s);
@


1.52
log
@Change cron from including all headers in every file to only including
what each .c file needs.  I have not removed cron.h since it will
be used in a future clean up of the cron's .h files.  OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.51 2015/10/29 22:41:27 millert Exp $	*/
d60 1
a60 1
		log_it("CRON", getpid(), "error", "can't fork");
d141 1
a141 1
		log_it("CRON", getpid(), "error", "can't fork");
d153 1
a153 1
				log_it(usernm, getpid(), "CMD", x);
d434 1
a434 1
				log_it(usernm, getpid(), "MAIL", buf);
d472 1
a472 1
		log_it(usernm, getpid(), "UNSAFE", s);
@


1.51
log
@Use stravis(3) instead of a homegrown vis-like function.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.50 2015/10/25 21:30:11 millert Exp $	*/
d20 17
a36 1
#include "cron.h"
d38 6
@


1.50
log
@Remove cron.pid support.  We still want to avoid multiple crons
running so verify that if the cron socket exists nothing is listening
on it.  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.49 2015/10/23 18:42:55 tedu Exp $	*/
d21 1
d129 5
a133 4
			char *x = mkprints((u_char *)e->cmd, strlen(e->cmd));

			log_it(usernm, getpid(), "CMD", x);
			free(x);
@


1.49
log
@remove some more ifdef maziness
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.48 2015/10/03 19:47:21 tedu Exp $	*/
a40 1
		acquire_daemonlock(1);
@


1.48
log
@There is no need to keep a global array of sysconf(_SC_OPEN_MAX) elements
just to keep track of a single pid. Return it to the caller and make it
their problem.
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.47 2015/10/03 12:46:54 tedu Exp $	*/
a364 4
#ifdef MAIL_DATE
				fprintf(mail, "Date: %s\n",
					arpadate(&StartTime));
#endif /*MAIL_DATE*/
@


1.47
log
@unifdef some features we will always have. ok benno zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.46 2015/02/09 22:35:08 deraadt Exp $	*/
d324 1
d354 2
a355 1
				if (!(mail = cron_popen(mailcmd, "w", e->pwd))) {
d401 1
a401 1
				status = cron_pclose(mail);
@


1.46
log
@correct copyright, upon approval from paul vixie via todd miller.  the
head copyright assertion was seperated from the remaining ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.45 2015/01/23 19:07:27 tedu Exp $	*/
a167 1
#ifdef LOGIN_CAP
a168 1
#ifdef BSD_AUTH
a169 1
#endif
a186 1
#ifdef BSD_AUTH
a197 1
#endif /* BSD_AUTH */
a212 17
#else
		if (setgid(e->pwd->pw_gid) || initgroups(usernm, e->pwd->pw_gid)) {
			fprintf(stderr,
			    "unable to set groups for %s\n", e->pwd->pw_name);
			_exit(EXIT_FAILURE);
		}
#ifdef HAVE_SETLOGIN
		setlogin(usernm);
#endif
		if (setuid(e->pwd->pw_uid)) {
			fprintf(stderr,
			    "unable to set uid to %lu\n",
			    (unsigned long)e->pwd->pw_uid);
			_exit(EXIT_FAILURE);
		}

#endif /* LOGIN_CAP */
@


1.45
log
@braces to open a function go on their own line like god intended
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.44 2015/01/23 02:37:25 tedu Exp $	*/
a3 4
 * All rights reserved
 */

/*
@


1.44
log
@Remove the OK and ERR macros. They obfuscate the code and don't
help legibility. (unix system calls use 0 for ok, but hundreds of
other projects use 1 to indicate success.) Despite the name, many
system calls (e.g., open) also return not OK values for success.
It also cleans up some weird code like int crontab_fd = OK - 1;
This diff is mechanical in nature. Later I will fix the bugs it reveals.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.43 2015/01/23 01:03:03 tedu Exp $	*/
d29 2
a30 1
do_command(entry *e, user *u) {
d56 2
a57 1
child_process(entry *e, user *u) {
d466 2
a467 1
safe_p(const char *usernm, const char *s) {
@


1.43
log
@minor debug removal cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.42 2015/01/23 01:01:06 tedu Exp $	*/
d451 1
a451 1
		while ((pid = wait(&waiter)) < OK && errno == EINTR)
d453 1
a453 1
		if (pid < OK) {
@


1.42
log
@remove debug code.
I think the level of debug code in cron is excessive for a program
that has reached feature complete. If cron needs to provide more
information to the user about its operational status, I think syslog
would be more appropriate. (The debug flags also disable forking
into the background, so they aren't even that useful for debugging a
live system.)
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.41 2015/01/14 17:30:53 millert Exp $	*/
d457 1
a457 1
		 * if (WIFSIGNALED(waiter) && WCOREDUMP(waiter))
@


1.41
log
@Replace MAXHOSTNAMELEN with HOST_NAME_MAX+1 and MAXNAMLEN with NAME_MAX
and use limits.h instead of sys/param.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.40 2015/01/14 17:27:51 millert Exp $	*/
a29 3
	Debug(DPROC, ("[%ld] do_command(%s, (%s,%lu,%lu))\n",
		      (long)getpid(), e->cmd, u->name,
		      (u_long)e->pwd->pw_uid, (u_long)e->pwd->pw_gid))
a45 2
		Debug(DPROC, ("[%ld] child process done, exiting\n",
			      (long)getpid()))
a51 1
	Debug(DPROC, ("[%ld] main process returning to work\n",(long)getpid()))
a60 2
	Debug(DPROC, ("[%ld] child_process('%s')\n", (long)getpid(), e->cmd))

a124 3
		Debug(DPROC, ("[%ld] grandchild process fork()'ed\n",
			      (long)getpid()))

a246 9
# if DEBUGGING
			if (DebugFlags & DTEST) {
				fprintf(stderr,
				"debug DTEST is on, not exec'ing command.\n");
				fprintf(stderr,
				"\tcmd='%s' shell='%s'\n", e->cmd, shell);
				_exit(EXIT_SUCCESS);
			}
# endif /*DEBUGGING*/
a263 2
	Debug(DPROC, ("[%ld] child continues, closing pipes\n",(long)getpid()))

a286 3
		Debug(DPROC, ("[%ld] child2 sending data to grandchild\n",
			      (long)getpid()))

a320 2
		Debug(DPROC, ("[%ld] child2 done sending to grandchild\n",
			      (long)getpid()))
a337 3
	Debug(DPROC, ("[%ld] child reading output from grandchild\n",
		      (long)getpid()))

a348 4
			Debug(DPROC|DEXT,
			      ("[%ld] got data (%x:%c) from grandchild\n",
			       (long)getpid(), ch, ch))

a416 2
				Debug(DPROC, ("[%ld] closing pipe to mail\n",
					      (long)getpid()))
a441 3
		Debug(DPROC, ("[%ld] got EOF from grandchild\n",
			      (long)getpid()))

a450 2
		Debug(DPROC, ("[%ld] waiting for grandchild #%d to finish\n",
			      (long)getpid(), children))
a453 3
			Debug(DPROC,
			      ("[%ld] no more grandchildren--mail written?\n",
			       (long)getpid()))
d456 2
a457 3
		Debug(DPROC, ("[%ld] grandchild #%ld finished, status=%04x",
			      (long)getpid(), (long)pid, WEXITSTATUS(waiter)))
		if (WIFSIGNALED(waiter) && WCOREDUMP(waiter))
d459 1
a459 1
		Debug(DPROC, ("\n"))
@


1.40
log
@Use HAVE_FOO for BSD-specific features instead of relying on the
BSD macro from sys/param.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.39 2015/01/14 17:27:30 millert Exp $	*/
d403 1
a403 1
				char	hostname[MAXHOSTNAMELEN];
@


1.39
log
@Use standard types for wait, readdir, signals and pids.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.38 2013/11/23 18:23:00 deraadt Exp $	*/
d237 1
a237 1
#if (defined(BSD)) && (BSD >= 199103)
d239 1
a239 1
#endif /* BSD */
@


1.38
log
@obvious unsigned char cast for ctype
ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.37 2013/03/07 11:13:54 millert Exp $	*/
d487 2
a488 2
		WAIT_T waiter;
		PID_T pid;
@


1.37
log
@Allow a '+' in the MAILTO email adress; from Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.36 2011/08/22 19:32:42 millert Exp $	*/
d514 1
a514 1
	for (t = s, first = 1; (ch = *t++) != '\0'; first = 0) {
@


1.36
log
@Use standard EXIT_SUCCESS/EXIT_FAILURE and STD{IN,OUT,ERR}_FILENO
defines instead of using custom macros.  OK deraadt@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.35 2011/03/03 15:08:14 millert Exp $	*/
d510 1
a510 1
	static const char safe_delim[] = "@@!:%-.,";     /* conservative! */
@


1.35
log
@Reset the SIGPIPE signal handler immediately before executing a command.
We ignore it by default so cron doesn't die if sendmail is missing
or exits prematurely but the actual command being run should have the
default handler installed.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.34 2010/12/14 23:32:06 millert Exp $	*/
d51 1
a51 1
		_exit(OK_EXIT);
d130 1
a130 1
		_exit(ERROR_EXIT);
d168 2
a169 2
		if (stdin_pipe[READ_PIPE] != STDIN) {
			dup2(stdin_pipe[READ_PIPE], STDIN);
d172 2
a173 2
		if (stdout_pipe[WRITE_PIPE] != STDOUT) {
			dup2(stdout_pipe[WRITE_PIPE], STDOUT);
d176 1
a176 1
		dup2(STDOUT, STDERR);
d195 1
a195 1
				_exit(ERROR_EXIT);
d201 1
a201 1
				_exit(ERROR_EXIT);
d207 1
a207 1
				_exit(ERROR_EXIT);
d212 1
a212 1
				_exit(ERROR_EXIT);
d235 1
a235 1
			_exit(ERROR_EXIT);
d244 1
a244 1
			_exit(ERROR_EXIT);
d264 1
a264 1
				_exit(OK_EXIT);
d270 1
a270 1
			_exit(ERROR_EXIT);
d348 1
a348 1
		_exit(OK_EXIT);
d409 1
a409 1
					(void) _exit(ERROR_EXIT);
d413 1
a413 1
					(void) _exit(ERROR_EXIT);
@


1.34
log
@Use _exit() not exit() after forking.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.33 2009/10/27 23:59:51 deraadt Exp $	*/
d249 2
@


1.33
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.32 2007/05/25 17:50:41 millert Exp $	*/
d130 1
a130 1
		exit(ERROR_EXIT);
d346 1
a346 1
		exit(0);
@


1.32
log
@Check fdopen() return value.
Ignore SIG_PIPE when writing to sendmail.  This allows cron to still
run jobs when sendmail is missing or broken (a warning will be logged).
Move mailto variable to the same scope as mail and use the mail
variable, not mailto, to test whether we have an open pipe to the mailer.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.31 2007/04/10 17:14:43 miod Exp $	*/
a22 4

#if !defined(lint) && !defined(LINT)
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.31 2007/04/10 17:14:43 miod Exp $";
#endif
@


1.31
log
@privledges -> privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.30 2006/08/13 20:44:00 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.30 2006/08/13 20:44:00 millert Exp $";
d66 1
d68 1
a68 1
	char *input_data, *usernm, *mailto;
a78 1
	mailto = env_get("MAILTO", e->envp);
d370 3
a372 2
	/*local*/{
		FILE	*in = fdopen(stdout_pipe[READ_PIPE], "r");
d376 2
a377 1
			FILE	*mail;
d388 1
d444 1
a444 1
				if (mailto)
d452 1
a452 1
			if (mailto) {
d468 1
a468 1
			if (mailto && status) {
@


1.30
log
@Add Auto-Submitted header in generated mail as per RFC 3834.
OK henning@@, ckuethe@@, krw@@, ian@@.  From Tamas TEVESZ.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.29 2004/06/17 22:11:55 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.29 2004/06/17 22:11:55 millert Exp $";
d183 1
a183 1
		 * we set uid, we've lost root privledges.
@


1.29
log
@UUpdate ISC copyright year to 2004
Remove unused macros Skip_Line and MkLower
Remove trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.28 2004/06/06 23:56:26 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.28 2004/06/06 23:56:26 millert Exp $";
d419 1
@


1.28
log
@Fix typo in last commit for non-compiled code.  Dmitry V. Levin
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.27 2004/06/03 19:54:04 millert Exp $	*/
d8 1
d15 7
a21 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.27 2004/06/03 19:54:04 millert Exp $";
d91 1
a91 1
	
d246 2
a247 1
			    "unable to set uid to %ld\n", (long)e->pwd->pw_uid);
d393 1
a393 1
		
@


1.27
log
@More changes from Dmitry V. Levin:

Check return values for setgid, initgroups and setuid in code we don't compile.
Print the correct filename for the at job in mail sent.
Add some #if DEBUGGING in cron.c's usage().
Set sunlen each time before using it in accept().
Don't send mail at all if MAILTO is set but empty.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.26 2004/04/26 17:15:37 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.26 2004/04/26 17:15:37 millert Exp $";
d236 1
a236 1
		if (setgid(e->pwd->pw_gid) || initgroups(usernm, e->pwd->pw_gid) {
@


1.26
log
@isalnum() does not match '_' so check it explicitly.  This allows cron
to send mail to usernames with a '_' in them.  From David Gwynne.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.25 2003/07/30 20:20:01 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.25 2003/07/30 20:20:01 millert Exp $";
d236 5
a240 2
		setgid(e->pwd->pw_gid);
		initgroups(usernm, e->pwd->pw_gid);
d244 5
a248 1
		setuid(e->pwd->pw_uid);	/* we aren't root after this... */
d385 1
a385 9
			if (mailto) {
				/* MAILTO was present in the environment
				 */
				if (!*mailto) {
					/* ... but it's empty. set to NULL
					 */
					mailto = NULL;
				}
			} else {
d389 2
d398 1
a398 1
			if (mailto && safe_p(usernm, mailto)) {
@


1.25
log
@Use (char *)NULL instead of (char *)0 in execl and execle; Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.24 2003/04/14 15:58:13 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.24 2003/04/14 15:58:13 millert Exp $";
d512 2
a513 1
		    (isalnum(ch) || (!first && strchr(safe_delim, ch))))
@


1.24
log
@Use setproctitle() instead of the CAPITALIZE_FOR_PS hack.  Inspired
by similar changes in FreeBSD and NetBSD.  For at jobs, include the
job number in the proctitle.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.23 2003/02/20 20:38:08 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.23 2003/02/20 20:38:08 millert Exp $";
d261 3
a263 3
			execle(shell, shell, "-c", e->cmd, (char *)0, e->envp);
			fprintf(stderr, "execl: couldn't exec `%s'\n", shell);
			perror("execl");
@


1.23
log
@Sync with ISC cron-current + my at(1) integration.
The at(1) code is now more tightly integrated into the cron codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.22 2002/08/08 18:17:50 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.22 2002/08/08 18:17:50 millert Exp $";
d72 2
a73 11
#ifdef CAPITALIZE_FOR_PS
	/* mark ourselves as different to PS command watchers by upshifting
	 * our program name.  This has no effect on some kernels.
	 */
	/*local*/{
		char	*pch;

		for (pch = ProgramName;  *pch;  pch++)
			*pch = MkUpper(*pch);
	}
#endif /* CAPITALIZE_FOR_PS */
@


1.22
log
@Move closelog() into log_close() function and call that instead
of calling closelog() (with #ifdefs) directly.
@
text
@d1 2
a2 1
/*	$OpenBSD: do_command.c,v 1.21 2002/07/15 22:38:36 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.21 2002/07/15 22:38:36 millert Exp $";
d67 1
a67 2
	char *usernm;
	char *input_data, *mailto;
d211 3
a213 1
				fprintf(stderr, "setusercontext failed for %s\n", e->pwd->pw_name);
d247 1
d249 1
d387 1
a387 1
			if (mailto && safe_p(usernm, mailto)) {
d406 1
a406 1
			if (mailto) {
d497 2
a498 1
		pid = wait(&waiter);
a499 2
			if (errno == EINTR)
				continue;
@


1.21
log
@fix typo (pw vs. pwd) in unused code
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.20 2002/07/15 22:16:50 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.20 2002/07/15 22:16:50 millert Exp $";
d163 1
a163 3
#ifdef SYSLOG
		closelog();
#endif
@


1.20
log
@Pass e->pwd to auth_setpwd() to avoid extra passwd lookup in BSD auth routines
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.19 2002/07/15 19:13:29 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.19 2002/07/15 19:13:29 millert Exp $";
d248 1
a248 1
		setuid(e->pw->pw_uid);	/* we aren't root after this... */
@


1.19
log
@Move atrun(8) functionality into cron(8) proper.  This fixes the
long-standing annoyance that atrun's granularity is 10 minutes.
Most at jobs run with a 1 minute granularity.  Jobs submitted via
"at now" or "batch" will run immediately.  Includes a rewritten
cron(8) man page.  at(1) will be integrated more closely into
cron at a future date.

Upgrading notes:
    the atrun job in root's crontab should be removed.
    the /var/at/spool directory is no longer used
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.18 2002/07/12 18:35:24 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.18 2002/07/12 18:35:24 millert Exp $";
d198 3
d217 6
a222 2
			/* XXX - stash pwd with auth_setpwd to avoid lookup */
			if (auth_approval(0, lc, usernm, "cron") <= 0) {
d227 1
@


1.18
log
@Do not collapse \\ -> \ in a command, the shell will be unhappy with
bare backslashes.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.17 2002/07/08 18:11:02 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.17 2002/07/08 18:11:02 millert Exp $";
a29 1
static int		safe_p(const char *, const char *);
d35 1
a35 1
		      (u_long)e->uid, (u_long)e->gid))
d86 1
a86 1
	usernm = env_get("LOGNAME", e->envp);
d106 2
a107 1
	 * the command.  Subsequent %'s will be transformed into newlines,
a108 2
	 *
	 * If there are escaped %'s, remove the escape character.
d142 1
a142 1
		log_it("CRON", getpid(), "error", "can't vfork");
d146 1
a146 1
		Debug(DPROC, ("[%ld] grandchild process Vfork()'ed\n",
d198 3
a200 2
			struct passwd *pwd;
			char *ep, *np;
d203 4
a206 3
			pwd = getpwuid(e->uid);
			if (pwd == NULL) {
				fprintf(stderr, "getpwuid: couldn't get entry for %u\n", e->uid);
d209 2
a210 2
			if (setusercontext(0, pwd, e->uid, LOGIN_SETALL) < 0) {
				fprintf(stderr, "setusercontext failed for %u\n", e->uid);
d214 4
a217 2
			if (auth_approval(0, 0, pwd->pw_name, "cron") <= 0) {
				fprintf(stderr, "approval failed for %u\n", e->uid);
d221 2
d227 6
a232 7
			if (env_get("PATH", e->envp) == NULL &&
			    (ep = getenv("PATH"))) {
				np = malloc(strlen(ep) + 6);
				if (np) {
					strcpy(np, "PATH=");
					strcat(np, ep);
					e->envp = env_set(e->envp, np);
a234 1
			
d237 2
a238 2
		setgid(e->gid);
		initgroups(env_get("LOGNAME", e->envp), e->gid);
d240 1
a240 1
		setuid(e->uid);		/* we aren't root after this... */
d407 1
a407 1
				if (!(mail = cron_popen(mailcmd, "w", e))) {
d504 1
a504 1
static int
@


1.17
log
@Merge in some changes from Paul Vixie's tree; most are cosmetic
o ANSI function headers
o return (foo) not return foo
o add -oi to sendmail flags
o update email address in man pages
o make some strings const
o completely remove globbing cruft from popen.c
o whitespace changes
o add DOW_STAR to flags for "monthly", "weekly", and "daily" cron entries
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.16 2002/06/23 03:07:19 deraadt Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: do_command.c,v 1.16 2002/06/23 03:07:19 deraadt Exp $";
d123 1
a123 1
				if (ch == '%' || ch == '\\')
@


1.16
log
@uid_t and gid_t are unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.15 2002/06/21 21:10:32 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: do_command.c,v 1.15 2002/06/21 21:10:32 millert Exp $";
@


1.15
log
@Correctly close the writing end of the pipe when dup'ing the fd to
stdout.  This was a pasto/thinko on my part.  Problem found by
jean-philippe wan-hoi.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.14 2002/06/14 21:35:01 todd Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: do_command.c,v 1.14 2002/06/14 21:35:01 todd Exp $";
d34 1
a34 1
	Debug(DPROC, ("[%ld] do_command(%s, (%s,%ld,%ld))\n",
d36 1
a36 1
		      (long)e->uid, (long)e->gid))
d206 1
a206 1
				fprintf(stderr, "getpwuid: couldn't get entry for %d\n", e->uid);
d210 1
a210 1
				fprintf(stderr, "setusercontext failed for %d\n", e->uid);
d215 1
a215 1
				fprintf(stderr, "approval failed for %d\n", e->uid);
@


1.14
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.13 2002/02/19 18:38:02 mpech Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: do_command.c,v 1.13 2002/02/19 18:38:02 mpech Exp $";
a189 1
			close(STDOUT);
d191 1
@


1.13
log
@Fix gethostname() usage.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.12 2002/01/09 00:51:00 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: do_command.c,v 1.12 2002/01/09 00:51:00 millert Exp $";
d92 1
a92 1
	 * use wait() explictly.  so we have to reset the signal (which
@


1.12
log
@Kill volatile now that jongjmp is history.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.11 2001/10/24 17:28:16 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: do_command.c,v 1.11 2001/10/24 17:28:16 millert Exp $";
d399 1
a399 1
				gethostname(hostname, MAXHOSTNAMELEN);
@


1.11
log
@When becoming a daemon, dup stdin, stdout, and stderr to /dev/null
Change an unsafe vfork() to fork()
Fix dup2() usage--must check for oldd == newd case and no need to close oldd
Fixes annoying messages from sendmail about stdout being closed.
@
text
@d1 1
a1 1
/*	$OpenBSD: do_command.c,v 1.10 2001/02/18 19:48:33 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: do_command.c,v 1.10 2001/02/18 19:48:33 millert Exp $";
d68 2
a69 2
	char * volatile input_data, * volatile mailto;
	volatile int children = 0;
d364 1
a364 1
			FILE	* volatile mail;
@


1.10
log
@Update to ISC cron 4.0b1 + our patches.  This is now under a BSD license.
I also fixed the signal handlers while I was at it.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: do_command.c,v 1.4 2000/01/02 20:53:41 vixie Exp $";
d142 1
a142 1
	switch (vfork()) {
d185 9
a193 8
		close(STDIN);	dup2(stdin_pipe[READ_PIPE], STDIN);
		close(STDOUT);	dup2(stdout_pipe[WRITE_PIPE], STDOUT);
		close(STDERR);	dup2(STDOUT, STDERR);

		/* close the pipes we just dup'ed.  The resources will remain.
		 */
		close(stdin_pipe[READ_PIPE]);
		close(stdout_pipe[WRITE_PIPE]);
d487 2
@


1.9
log
@snprintf sprinkles; solar@@false.com & I
@
text
@d1 1
d4 4
d9 3
a11 8
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
d13 8
a20 3
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@@vix.com>          uunet!decwrl!vixie!paul
d24 1
a24 1
static char rcsid[] = "$Id: do_command.c,v 1.8 2000/08/20 18:42:42 millert Exp $";
a26 1

a27 10
#include <sys/signal.h>
#if defined(sequent)
# include <sys/universe.h>
#endif
#if defined(SYSLOG)
# include <syslog.h>
#endif
#if defined(LOGIN_CAP)
# include <login_cap.h>
#endif
d29 2
a30 3

static void		child_process __P((entry *, user *)),
			do_univ __P((user *));
d33 4
a36 6
do_command(e, u)
	entry	*e;
	user	*u;
{
	Debug(DPROC, ("[%d] do_command(%s, (%s,%d,%d))\n",
		getpid(), e->cmd, u->name, e->uid, e->gid))
d47 1
a47 1
		log_it("CRON",getpid(),"error","can't fork");
d53 2
a54 1
		Debug(DPROC, ("[%d] child process done, exiting\n", getpid()))
d61 1
a61 1
	Debug(DPROC, ("[%d] main process returning to work\n", getpid()))
a63 1

d65 5
a69 14
child_process(e, u)
	entry	*e;
	user	*u;
{
	int		stdin_pipe[2], stdout_pipe[2];
	char		*input_data;
	char		*usernm, *mailto;
	int		children = 0;

#ifdef __GNUC__
	(void) &input_data;	/* Avoid vfork clobbering */
	(void) &mailto;
	(void) &children;
#endif
d71 1
a71 1
	Debug(DPROC, ("[%d] child_process('%s')\n", getpid(), e->cmd))
d73 1
d78 1
a78 1
		register char	*pch;
d83 1
a89 1
#ifdef USE_SIGCHLD
d92 1
a92 1
	 * use wait() explictly.  so we have to disable the signal (which
a95 7
#else
	/* on system-V systems, we are ignoring SIGCLD.  we have to stop
	 * ignoring it now or the wait() in cron_pclose() won't work.
	 * because of this, we have to wait() for our children here, as well.
	 */
	(void) signal(SIGCLD, SIG_DFL);
#endif /*BSD*/
d113 7
a119 6
		register int escaped = FALSE;
		register int ch;
		register char *p;

		for (input_data = p = e->cmd; (ch = *input_data);
		    input_data++, p++) {
d144 1
a144 1
		log_it("CRON",getpid(),"error","can't vfork");
d148 2
a149 2
		Debug(DPROC, ("[%d] grandchild process Vfork()'ed\n",
			      getpid()))
d156 1
a156 1
		/*local*/{
a193 6
		/* set our login universe.  Do this in the grandchild
		 * so that the child can invoke /usr/lib/sendmail
		 * without surprises.
		 */
		do_univ(u);

d197 1
a197 1
# ifdef LOGIN_CAP
d212 6
d219 1
a219 1
			 * we just added on via login.conf, add it to
d226 3
a228 3
				    strcpy(np, "PATH=");
				    strcat(np, ep);
				    e->envp = env_set(e->envp, np);
d231 1
d233 1
a233 2
		
# else
a234 1
#  if defined(BSD)
a235 1
#  endif
d238 2
a239 1
# endif
d242 2
a243 1
		/* exec the command.
d274 1
a274 1
	Debug(DPROC, ("[%d] child continues, closing pipes\n", getpid()))
d294 4
a297 4
		register FILE	*out = fdopen(stdin_pipe[WRITE_PIPE], "w");
		register int	need_newline = FALSE;
		register int	escaped = FALSE;
		register int	ch;
d299 2
a300 1
		Debug(DPROC, ("[%d] child2 sending data to grandchild\n", getpid()))
d336 2
a337 1
		Debug(DPROC, ("[%d] child2 done sending to grandchild\n", getpid()))
d355 2
a356 1
	Debug(DPROC, ("[%d] child reading output from grandchild\n", getpid()))
d359 2
a360 2
		register FILE	*in = fdopen(stdout_pipe[READ_PIPE], "r");
		register int	ch = getc(in);
d363 3
a365 3
			FILE		*mail;
			register int	bytes = 1;
			int		status = 0;
a366 3
#ifdef __GNUC__
			(void) &mail;
#endif
d368 2
a369 2
				("[%d] got data (%x:%c) from grandchild\n",
					getpid(), ch, ch))
d374 1
a374 1
			if (mailto) {
d394 10
a403 7
				register char	**env;
				auto char	mailcmd[MAX_COMMAND];
				auto char	hostname[MAXHOSTNAMELEN];

				(void) gethostname(hostname, MAXHOSTNAMELEN);
				(void) snprintf(mailcmd, sizeof(mailcmd),
				    MAILARGS, MAILCMD);
d405 1
a405 1
					perror(MAILCMD);
d413 1
a413 1
# if defined(MAIL_DATE)
d416 1
a416 1
# endif /* MAIL_DATE */
d424 1
a424 1
				putc(ch, mail);
d435 1
a435 1
					putc(ch, mail);
d443 2
a444 2
				Debug(DPROC, ("[%d] closing pipe to mail\n",
					getpid()))
d470 2
a471 1
		Debug(DPROC, ("[%d] got EOF from grandchild\n", getpid()))
d478 3
a480 4
	for (;  children > 0;  children--)
	{
		WAIT_T		waiter;
		PID_T		pid;
d482 2
a483 2
		Debug(DPROC, ("[%d] waiting for grandchild #%d to finish\n",
			getpid(), children))
d486 3
a488 2
			Debug(DPROC, ("[%d] no more grandchildren--mail written?\n",
				getpid()))
d491 2
a492 2
		Debug(DPROC, ("[%d] grandchild #%d finished, status=%04x",
			getpid(), pid, WEXITSTATUS(waiter)))
d499 12
a510 30

static void
do_univ(u)
	user	*u;
{
#if defined(sequent)
/* Dynix (Sequent) hack to put the user associated with
 * the passed user structure into the ATT universe if
 * necessary.  We have to dig the gecos info out of
 * the user's password entry to see if the magic
 * "universe(att)" string is present.
 */

	struct	passwd	*p;
	char	*s;
	int	i;

	p = getpwuid(u->uid);
	(void) endpwent();

	if (p == NULL)
		return;

	s = p->pw_gecos;

	for (i = 0; i < 4; i++)
	{
		if ((s = strchr(s, ',')) == NULL)
			return;
		s++;
d512 1
a512 5
	if (strcmp(s, "universe(att)"))
		return;

	(void) universe(U_ATT);
#endif
@


1.8
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: do_command.c,v 1.7 2000/06/03 15:36:38 millert Exp $";
a38 1

d481 1
a481 1
				sprintf(buf,
@


1.7
log
@Set SIGCHLD to SIG_DFL not SIG_IGN to prevent "perl -w" from
complaining "Can't ignore signal CHLD, forcing to default".

Setting SIGCHLD to SIG_IGN means "don't provide exit status for my
children" on some OSes which is not what we want--we just don't
want to catch SIGCHLD since our parent does that for us.
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: do_command.c,v 1.7 2000/06/03 15:35:15 millert Exp $";
d31 3
d227 31
d259 1
a259 1
# if defined(BSD)
d261 1
a261 1
# endif
d264 1
@


1.6
log
@Run sendmail as the user corresponding to the crontab entry.
This keeps a user from abusing sendmail via the MAILTO var.
Had to drop -or0s from MAILARGS since that causes sendmail
to drop its privs (contrary to the sendmail docs).
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: do_command.c,v 1.5 1998/05/08 20:17:18 deraadt Exp $";
d110 1
a110 1
	(void) signal(SIGCHLD, SIG_IGN);
@


1.5
log
@when handling % line breaks, correctly handle escaped % which should be embedded; fenner@@parc.xerox.com
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: do_command.c,v 1.4 1998/03/30 06:59:43 deraadt Exp $";
d390 1
a390 1
				if (!(mail = cron_popen(mailcmd, "w"))) {
@


1.4
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: do_command.c,v 1.3 1997/12/22 08:10:42 deraadt Exp $";
d131 2
d137 1
d139 4
a142 1
		for (input_data = e->cmd; (ch = *input_data); input_data++) {
d144 2
d158 1
@


1.3
log
@handle timing normally except when clock jumps between 1 and 3 hours. If it
jumps, attempt as best as possible to gaurantee that jobs DO run, but only
run ONCE; patch by thompson@@.tgsoft.com
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: do_command.c,v 1.2 1996/08/07 06:18:33 deraadt Exp $";
d77 1
a77 1
	register char	*input_data;
d81 6
d136 1
a136 1
		for (input_data = e->cmd;  ch = *input_data;  input_data++) {
d291 1
a291 1
		while (ch = *input_data++) {
d340 1
a340 1
			register FILE	*mail;
d344 3
@


1.2
log
@setlogin(username)
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: do_command.c,v 1.1.1.1 1995/10/18 08:47:30 deraadt Exp $";
d383 1
a383 1
					arpadate(&TargetTime));
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: do_command.c,v 1.2 1995/04/14 19:49:34 mycroft Exp $";
d213 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
