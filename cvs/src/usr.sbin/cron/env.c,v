head	1.32;
access;
symbols
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.23.0.18
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.16
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.12
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.10
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.8
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.6
	OPENBSD_5_0:1.23.0.4
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.10
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.6
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.18.0.12
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.10
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.8
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.6
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.15.0.6
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.4
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.9.0.6
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.5.0.10
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2015.11.04.20.28.17;	author millert;	state Exp;
branches;
next	1.31;
commitid	6N0oXtYc5KM1a7DW;

1.31
date	2015.10.29.21.24.09;	author millert;	state Exp;
branches;
next	1.30;
commitid	W6mUaaYqUFrjIBIo;

1.30
date	2015.10.29.21.19.09;	author millert;	state Exp;
branches;
next	1.29;
commitid	djZhV8XSdvavOBvh;

1.29
date	2015.02.09.22.35.08;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	eGq01x6bjr83TVho;

1.28
date	2015.01.23.19.07.27;	author tedu;	state Exp;
branches;
next	1.27;
commitid	YJA2vmvfLuMfGdwZ;

1.27
date	2015.01.23.02.37.25;	author tedu;	state Exp;
branches;
next	1.26;
commitid	UGPHvhzwRtnjrF9O;

1.26
date	2015.01.23.01.01.06;	author tedu;	state Exp;
branches;
next	1.25;
commitid	kzBIhYnXdVeOLxgw;

1.25
date	2015.01.14.18.28.15;	author millert;	state Exp;
branches;
next	1.24;
commitid	ZdtQrqmyEYY80nsO;

1.24
date	2014.10.08.04.20.57;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	jaUw0TLzwCT2tWVs;

1.23
date	2011.01.18.14.29.21;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2008.02.29.23.33.29;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.10.14.29.53;	author tobias;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.02.15.19.38;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.30.20.44.50;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.22.03.15.33;	author avsm;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.17.22.11.55;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.21.16.47.29;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.20.20.38.08;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.11.20.15.40;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.09.18.59.12;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.08.23.42.17;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.08.18.11.02;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.18.20.17.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.18.19.48.34;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.21.21.08.56;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.21.20.57.21;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.03.30.06.59.44;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.11.01.23.27.33;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.10.25.20.36.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.09.25.02.06.27;	author bitblt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.30;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Change cron from including all headers in every file to only including
what each .c file needs.  I have not removed cron.h since it will
be used in a future clean up of the cron's .h files.  OK nicm@@
@
text
@/*	$OpenBSD: env.c,v 1.31 2015/10/29 21:24:09 millert Exp $	*/

/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
 * Copyright (c) 1997,2000 by Internet Software Consortium, Inc.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <bitstring.h>		/* for structs.h */
#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>		/* for structs.h */

#include "macros.h"
#include "structs.h"
#include "funcs.h"
#include "globals.h"

char **
env_init(void)
{
	char **p = malloc(sizeof(char *));

	if (p != NULL)
		p[0] = NULL;
	return (p);
}

void
env_free(char **envp)
{
	char **p;

	for (p = envp; *p != NULL; p++)
		free(*p);
	free(envp);
}

char **
env_copy(char **envp)
{
	int count, i, save_errno;
	char **p;

	for (count = 0; envp[count] != NULL; count++)
		continue;
	p = reallocarray(NULL, count+1, sizeof(char *));  /* 1 for the NULL */
	if (p != NULL) {
		for (i = 0; i < count; i++)
			if ((p[i] = strdup(envp[i])) == NULL) {
				save_errno = errno;
				while (--i >= 0)
					free(p[i]);
				free(p);
				errno = save_errno;
				return (NULL);
			}
		p[count] = NULL;
	}
	return (p);
}

static char *
env_find(char *name, char **envp, size_t *count)
{
	char **ep, *p, *q;
	size_t len;

	/*
	 * Find name in envp and return its value along with the
	 * index it was found at or the length of envp if not found.
	 * We treat a '=' in name as end of string for env_set().
	 */
	for (p = name; *p && *p != '='; p++)
		continue;
	len = (size_t)(p - name);
	for (ep = envp; (p = *ep) != NULL; ep++) {
		if ((q = strchr(p, '=')) == NULL)
			continue;
		if ((size_t)(q - p) == len && strncmp(p, name, len) == 0) {
			p = q + 1;
			break;
		}
	}
	*count = (size_t)(ep - envp);
	return (p);
}

char *
env_get(char *name, char **envp)
{
	size_t count;

	return (env_find(name, envp, &count));
}

char **
env_set(char **envp, char *envstr)
{
	size_t count;
	char **p, *envcopy;

	if ((envcopy = strdup(envstr)) == NULL)
		return (NULL);

	/* Replace existing name if found. */
	if (env_find(envstr, envp, &count) != NULL) {
		free(envp[count]);
		envp[count] = envcopy;
		return (envp);
	}

	/* Realloc envp and append new variable. */
	p = reallocarray(envp, count + 2, sizeof(char **));
	if (p == NULL) {
		free(envcopy);
		return (NULL);
	}
	p[count++] = envcopy;
	p[count] = NULL;
	return (p);
}

/* The following states are used by load_env(), traversed in order: */
enum env_state {
	NAMEI,		/* First char of NAME, may be quote */
	NAME,		/* Subsequent chars of NAME */
	EQ1,		/* After end of name, looking for '=' sign */
	EQ2,		/* After '=', skipping whitespace */
	VALUEI,		/* First char of VALUE, may be quote */
	VALUE,		/* Subsequent chars of VALUE */
	FINI,		/* All done, skipping trailing whitespace */
	ERROR		/* Error */
};

/* return	-1 = end of file
 *		FALSE = not an env setting (file was repositioned)
 *		TRUE = was an env setting
 */
int
load_env(char *envstr, FILE *f)
{
	long filepos;
	int fileline;
	enum env_state state;
	char name[MAX_ENVSTR], val[MAX_ENVSTR];
	char quotechar, *c, *str;

	filepos = ftell(f);
	fileline = LineNumber;
	skip_comments(f);
	if (EOF == get_string(envstr, MAX_ENVSTR, f, "\n"))
		return (-1);

	bzero(name, sizeof name);
	bzero(val, sizeof val);
	str = name;
	state = NAMEI;
	quotechar = '\0';
	c = envstr;
	while (state != ERROR && *c) {
		switch (state) {
		case NAMEI:
		case VALUEI:
			if (*c == '\'' || *c == '"')
				quotechar = *c++;
			state++;
			/* FALLTHROUGH */
		case NAME:
		case VALUE:
			if (quotechar) {
				if (*c == quotechar) {
					state++;
					c++;
					break;
				}
				if (state == NAME && *c == '=') {
					state = ERROR;
					break;
				}
			} else {
				if (state == NAME) {
					if (isspace((unsigned char)*c)) {
						c++;
						state++;
						break;
					}
					if (*c == '=') {
						state++;
						break;
					}
				}
			}
			*str++ = *c++;
			break;
		case EQ1:
			if (*c == '=') {
				state++;
				str = val;
				quotechar = '\0';
			} else {
				if (!isspace((unsigned char)*c))
					state = ERROR;
			}
			c++;
			break;
		case EQ2:
		case FINI:
			if (isspace((unsigned char)*c))
				c++;
			else
				state++;
			break;
		case ERROR:
			/* handled below */
			break;
		}
	}
	if (state != FINI && !(state == VALUE && !quotechar)) {
		fseek(f, filepos, SEEK_SET);
		Set_LineNum(fileline);
		return (FALSE);
	}
	if (state == VALUE) {
		/* End of unquoted value: trim trailing whitespace */
		c = val + strlen(val);
		while (c > val && isspace((unsigned char)c[-1]))
			*(--c) = '\0';
	}

	/* 2 fields from parser; looks like an env setting */

	/*
	 * This can't overflow because get_string() limited the size of the
	 * name and val fields.  Still, it doesn't hurt to be careful...
	 */
	if (snprintf(envstr, MAX_ENVSTR, "%s=%s", name, val) >= MAX_ENVSTR)
		return (FALSE);
	return (TRUE);
}
@


1.31
log
@remove unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.30 2015/10/29 21:19:09 millert Exp $	*/
d20 14
a33 1
#include "cron.h"
@


1.30
log
@Convert env_get() into env_find() similar to __findenv() in libc.
Use env_find() in both env_get() and env_set() to find a var in envp.
Remove now-unused strcmp_until() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.29 2015/02/09 22:35:08 deraadt Exp $	*/
d103 1
a103 1
	size_t count, len;
@


1.29
log
@correct copyright, upon approval from paul vixie via todd miller.  the
head copyright assertion was seperated from the remaining ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.28 2015/01/23 19:07:27 tedu Exp $	*/
d25 1
a25 1
	char **p = malloc(sizeof(char **));
d66 34
d103 5
a107 2
	int count, found;
	char **p, *envtmp;
d109 4
a112 20
	/*
	 * count the number of elements, including the null pointer;
	 * also set 'found' to -1 or index of entry if already in here.
	 */
	found = -1;
	for (count = 0; envp[count] != NULL; count++) {
		if (!strcmp_until(envp[count], envstr, '='))
			found = count;
	}
	count++;	/* for the NULL */

	if (found != -1) {
		/*
		 * it exists already, so just free the existing setting,
		 * save our new one there, and return the existing array.
		 */
		if ((envtmp = strdup(envstr)) == NULL)
			return (NULL);
		free(envp[found]);
		envp[found] = envtmp;
d116 2
a117 8
	/*
	 * it doesn't exist yet, so resize the array, move null pointer over
	 * one, save our string over the old null pointer, and return resized
	 * array.
	 */
	if ((envtmp = strdup(envstr)) == NULL)
		return (NULL);
	p = reallocarray(envp, count+1, sizeof(char **));
d119 1
a119 1
		free(envtmp);
d122 2
a123 2
	p[count] = p[count-1];
	p[count-1] = envtmp;
a242 15
}

char *
env_get(char *name, char **envp)
{
	int len = strlen(name);
	char *p, *q;

	while ((p = *envp++) != NULL) {
		if (!(q = strchr(p, '=')))
			continue;
		if ((q - p) == len && !strncmp(p, name, len))
			return (q+1);
	}
	return (NULL);
@


1.28
log
@braces to open a function go on their own line like god intended
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.27 2015/01/23 02:37:25 tedu Exp $	*/
a3 4
 * All rights reserved
 */

/*
@


1.27
log
@Remove the OK and ERR macros. They obfuscate the code and don't
help legibility. (unix system calls use 0 for ok, but hundreds of
other projects use 1 to indicate success.) Despite the name, many
system calls (e.g., open) also return not OK values for success.
It also cleans up some weird code like int crontab_fd = OK - 1;
This diff is mechanical in nature. Later I will fix the bugs it reveals.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.26 2015/01/23 01:01:06 tedu Exp $	*/
d27 2
a28 1
env_init(void) {
d37 2
a38 1
env_free(char **envp) {
d47 2
a48 1
env_copy(char **envp) {
d71 2
a72 1
env_set(char **envp, char *envstr) {
d133 2
a134 1
load_env(char *envstr, FILE *f) {
d235 2
a236 1
env_get(char *name, char **envp) {
@


1.26
log
@remove debug code.
I think the level of debug code in cron is excessive for a program
that has reached feature complete. If cron needs to provide more
information to the user about its operational status, I think syslog
would be more appropriate. (The debug flags also disable forking
into the background, so they aren't even that useful for debugging a
live system.)
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.25 2015/01/14 18:28:15 millert Exp $	*/
d124 1
a124 1
/* return	ERR = end of file
d140 1
a140 1
		return (ERR);
@


1.25
log
@Use reallocarray() instead of calloc() when making a copy of the
environment.  We already explicitly NULL terminate the array.
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.24 2014/10/08 04:20:57 deraadt Exp $	*/
a141 2
	Debug(DPARS, ("load_env, read <%s>\n", envstr))

a206 1
		Debug(DPARS, ("load_env, not an env var, state = %d\n", state))
a225 1
	Debug(DPARS, ("load_env, <%s> <%s> -> <%s>\n", name, val, envstr))
@


1.24
log
@use reallocarray() instead of realloc() to handle potential integer overflow; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.23 2011/01/18 14:29:21 millert Exp $	*/
d28 1
a28 1
	char **p = (char **) malloc(sizeof(char **));
d51 1
a51 1
	p = (char **) calloc(count+1, sizeof(char *));  /* 1 for the NULL */
@


1.23
log
@Quiet a gcc warning
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.22 2009/10/27 23:59:51 deraadt Exp $	*/
d102 1
a102 2
	p = (char **) realloc((void *) envp,
			      (size_t) ((count+1) * sizeof(char **)));
@


1.22
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.21 2008/02/29 23:33:29 deraadt Exp $	*/
d203 3
@


1.21
log
@no , at end of enum; tobiasu@@tmux.org
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.20 2007/09/10 14:29:53 tobias Exp $	*/
a22 4

#if !defined(lint) && !defined(LINT)
static char const rcsid[] = "$OpenBSD: env.c,v 1.20 2007/09/10 14:29:53 tobias Exp $";
#endif
@


1.20
log
@Proper use of fseek/fseeko macros.

OK joris@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.19 2007/09/02 15:19:38 deraadt Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: env.c,v 1.19 2007/09/02 15:19:38 deraadt Exp $";
d126 1
a126 1
	ERROR,		/* Error */
@


1.19
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.18 2005/01/30 20:44:50 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: env.c,v 1.18 2005/01/30 20:44:50 millert Exp $";
d212 1
a212 1
		fseek(f, filepos, 0);
@


1.18
log
@fix some whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.17 2004/06/22 03:15:33 avsm Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: env.c,v 1.17 2004/06/22 03:15:33 avsm Exp $";
d55 1
a55 1
	p = (char **) malloc((count+1) * sizeof(char *));  /* 1 for the NULL */
@


1.17
log
@use snprintf(3) instead of home-grown glue_strings() function
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.16 2004/06/17 22:11:55 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: env.c,v 1.16 2004/06/17 22:11:55 millert Exp $";
a189 1

@


1.16
log
@UUpdate ISC copyright year to 2004
Remove unused macros Skip_Line and MkLower
Remove trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.15 2003/02/21 16:47:29 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: env.c,v 1.15 2003/02/21 16:47:29 millert Exp $";
d230 1
a230 1
	if (!glue_strings(envstr, MAX_ENVSTR, name, val, '='))
@


1.15
log
@Improved environment variable parser from FreeBSD (Thomas Quinot).
Fixes some issues with quoting and allows no longer mistakes commands
starting with a variable assignment for environment variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.14 2003/02/20 20:38:08 millert Exp $	*/
d8 1
d15 7
a21 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: env.c,v 1.14 2003/02/20 20:38:08 millert Exp $";
@


1.14
log
@Sync with ISC cron-current + my at(1) integration.
The at(1) code is now more tightly integrated into the cron codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.13 2002/07/11 20:15:40 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: env.c,v 1.13 2002/07/11 20:15:40 millert Exp $";
d117 12
d137 1
d139 1
a139 1
	int fields;
d149 64
a212 4
	name[0] = val[0] = '\0';
	fields = sscanf(envstr, "%[^ =] = %[^\n#]", name, val);
	if (fields != 2) {
		Debug(DPARS, ("load_env, not 2 fields (%d)\n", fields))
d217 6
d224 1
a224 19
	/*
	 * 2 fields from scanf; looks like an env setting.
	 */

	/*
	 * process value string
	 */
	/*local*/{
		int	len = strdtb(val);

		if (len >= 2) {
			if (val[0] == '\'' || val[0] == '"') {
				if (val[len-1] == val[0]) {
					val[len-1] = '\0';
					memmove(val, val+1, len);
				}
			}
		}
	}
d228 1
a228 1
	 * name and val fields.  Still, it doesn't hurt...
d230 2
a231 1
	(void) snprintf(envstr, MAX_ENVSTR, "%s=%s", name, val);
@


1.13
log
@More syncing with my cron 4.0 patch tree, basically cosmetic:
o change an instance of e_none to e_memory that I missed (forgot?)
o kill some whitespace
o modify malloc failure recovery a bit
@
text
@d1 2
a2 1
/*	$OpenBSD: env.c,v 1.12 2002/07/09 18:59:12 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: env.c,v 1.12 2002/07/09 18:59:12 millert Exp $";
@


1.12
log
@o Add _PATH_CRON_PID which is built up from PIDDIR and PIDFILE via string
concatenation at compile time rather than run time.

o Some minor cosmetic changes to simplify diffing.
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.11 2002/07/08 23:42:17 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: env.c,v 1.11 2002/07/08 23:42:17 millert Exp $";
d42 1
a42 1
	for (p = envp; *p != NULL;  p++)
d52 1
a52 1
	for (count = 0;  envp[count] != NULL;  count++)
d56 1
a56 1
		for (i = 0;  i < count;  i++)
d73 1
a73 1
	char **p, *cp;
d80 1
a80 1
	for (count = 0;  envp[count] != NULL;  count++) {
d91 2
d94 1
a94 4
		if ((envp[found] = strdup(envstr)) == NULL) {
			envp[found] = "";
			return (NULL);
		}
d103 2
d107 2
a108 1
	if (p == NULL)
d110 1
a110 3
	cp = strdup(envstr);
	if (cp == NULL)
		return(NULL);
d112 1
a112 1
	p[count-1] = cp;
@


1.11
log
@minor cosmetic change to reduce diffs
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.10 2002/07/08 18:11:02 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: env.c,v 1.10 2002/07/08 18:11:02 millert Exp $";
d31 1
a31 1
	char	**p = (char **) malloc(sizeof(char **));
d40 1
a40 1
	char	**p;
d42 1
a42 1
	for (p = envp;  *p != NULL;  p++)
@


1.10
log
@Merge in some changes from Paul Vixie's tree; most are cosmetic
o ANSI function headers
o return (foo) not return foo
o add -oi to sendmail flags
o update email address in man pages
o make some strings const
o completely remove globbing cruft from popen.c
o whitespace changes
o add DOW_STAR to flags for "monthly", "weekly", and "daily" cron entries
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.9 2001/02/18 20:17:20 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: env.c,v 1.9 2001/02/18 20:17:20 millert Exp $";
d53 1
a53 1
		NULL;
@


1.9
log
@NULL vs '\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: env.c,v 1.8 2001/02/18 19:48:34 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: env.c,v 1.8 2001/02/18 19:48:34 millert Exp $";
a26 1

a28 1

d30 1
a30 2
env_init()
{
a37 1

d39 1
a39 3
env_free(envp)
	char	**envp;
{
d42 1
a42 1
	for (p = envp;  *p;  p++)
a46 1

d48 3
a50 5
env_copy(envp)
	char	**envp;
{
	int	count, i, save_errno;
	char	**p;
d53 1
a53 1
		;
a69 1

d71 3
a73 6
env_set(envp, envstr)
	char	**envp;
	char	*envstr;
{
	int	count, found;
	char	**p, *cp;
a115 1

d121 5
a125 8
load_env(envstr, f)
	char	*envstr;
	FILE	*f;
{
	long	filepos;
	int	fileline;
	char	name[MAX_ENVSTR], val[MAX_ENVSTR];
	int	fields;
a172 1

d174 3
a176 6
env_get(name, envp)
	char	*name;
	char	**envp;
{
	int	len = strlen(name);
	char	*p, *q;
@


1.8
log
@Update to ISC cron 4.0b1 + our patches.  This is now under a BSD license.
I also fixed the signal handlers while I was at it.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: env.c,v 1.4 2000/01/02 20:53:41 vixie Exp $";
d199 1
a199 1
	while ((p = *envp++) != '\0') {
@


1.7
log
@snprintf sprinkles; solar@@false.com & I
@
text
@d1 1
d4 4
d9 3
a11 8
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
d13 8
a20 3
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@@vix.com>          uunet!decwrl!vixie!paul
d24 1
a24 1
static char rcsid[] = "$Id: env.c,v 1.6 2000/08/21 20:57:21 deraadt Exp $";
d34 1
a34 1
	register char	**p = (char **) malloc(sizeof(char **));
d36 1
a36 1
	if (p)
d56 1
a56 1
	register char	**envp;
d58 2
a59 2
	register int	count, i;
	register char	**p;
d64 11
a74 3
	if (p == NULL) {
		errno = ENOMEM;
		return NULL;
a75 9
	for (i = 0;  i < count;  i++)
		if ((p[i] = strdup(envp[i])) == NULL) {
			while (--i >= 0)
				(void) free(p[i]);
			free(p);
			errno = ENOMEM;
			return NULL;
		}
	p[count] = NULL;
d85 2
a86 2
	register int	count, found;
	register char	**p;
d107 1
a107 2
			errno = ENOMEM;
			return NULL;
d118 6
a123 5
			      (unsigned) ((count+1) * sizeof(char **)));
	if (p == NULL) 	{
		errno = ENOMEM;
		return NULL;
	}
d125 1
a125 4
	if ((p[count-1] = strdup(envstr)) == NULL) {
		errno = ENOMEM;
		return NULL;
	}
d161 2
a162 1
	/* 2 fields from scanf; looks like an env setting
d181 4
a184 2
	if (strlen(name) + 1 + strlen(val) >= MAX_ENVSTR-1)
		return (FALSE);
d193 2
a194 2
	register char	*name;
	register char	**envp;
d196 2
a197 2
	register int	len = strlen(name);
	register char	*p, *q;
d199 1
a199 1
	while ((p = *envp++) != NULL) {
@


1.6
log
@strncpy not safe on overlapping strings
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: env.c,v 1.5 1998/03/30 06:59:44 deraadt Exp $";
d181 1
a181 1
	(void) sprintf(envstr, "%s=%s", name, val);
@


1.5
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: env.c,v 1.4 1996/11/01 23:27:33 millert Exp $";
d173 1
a173 1
					(void) strcpy(val, val+1);
@


1.4
log
@Check malloc/strdup ret val and deal.
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: env.c,v 1.3 1996/10/25 20:36:56 deraadt Exp $";
d195 1
a195 1
	while (p = *envp++) {
@


1.3
log
@proactive buf check
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: env.c,v 1.2 1996/09/25 02:06:27 bitblt Exp $";
d31 2
a32 1
	p[0] = NULL;
d59 4
d64 7
a70 1
		p[i] = strdup(envp[i]);
d101 5
a105 1
		envp[found] = strdup(envstr);
d116 4
d121 4
a124 1
	p[count-1] = strdup(envstr);
@


1.2
log
@Fixed buffer overflow.
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: env.c,v 1.1.1.1 1995/10/18 08:47:30 deraadt Exp $";
d157 2
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: env.c,v 1.1.1.5 1994/01/26 19:09:39 jtc Exp $";
d118 1
a118 1
	char	name[MAX_TEMPSTR], val[MAX_ENVSTR];
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
