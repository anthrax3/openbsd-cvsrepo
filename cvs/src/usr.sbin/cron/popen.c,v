head	1.30;
access;
symbols
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.22.0.14
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.12
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.8
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.6
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.4
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.2
	OPENBSD_5_0:1.21.0.8
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.16
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.12
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.10
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.8
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.6
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.12
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.10
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.8
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2015.11.15.23.24.24;	author millert;	state Exp;
branches;
next	1.29;
commitid	4K3ElIFSUCsF9sYF;

1.29
date	2015.11.04.20.28.17;	author millert;	state Exp;
branches;
next	1.28;
commitid	6N0oXtYc5KM1a7DW;

1.28
date	2015.10.04.09.08.46;	author tedu;	state Exp;
branches;
next	1.27;
commitid	0xJbFfIiuauCvywL;

1.27
date	2015.10.03.19.47.21;	author tedu;	state Exp;
branches;
next	1.26;
commitid	34TKQiezOQXb6h1Y;

1.26
date	2015.10.03.12.46.54;	author tedu;	state Exp;
branches;
next	1.25;
commitid	WlajD40E0eJCM3xO;

1.25
date	2015.01.23.19.07.27;	author tedu;	state Exp;
branches;
next	1.24;
commitid	YJA2vmvfLuMfGdwZ;

1.24
date	2015.01.14.17.27.51;	author millert;	state Exp;
branches;
next	1.23;
commitid	29asVUstLv6pyoCO;

1.23
date	2015.01.14.17.27.30;	author millert;	state Exp;
branches;
next	1.22;
commitid	jXmo2gNqOzD6QEsx;

1.22
date	2011.08.22.19.32.42;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.03.01.31.11;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.04.39.45;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.20.20.38.08;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.15.19.13.29;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.09.00.24.50;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.08.18.11.02;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.23.03.07.19;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.09.00.51.00;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.24.17.28.16;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.01.19.19.09;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.03.01.30.04;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.02.21.56.17;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.18.19.48.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.21.21.01.21;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.20.18.42.42;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.08.30.10.45.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.08.28.20.13.13;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.08.27.10.13.18;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.03.30.06.59.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.31;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Clean up the remaining uses of stderr and perror() and use warn/err
and/or syslog depending on whether stderr is hooked up at the time.
Also remove closelog() which is not needed since we are headed for exec.
OK guenther@@
@
text
@/*	$OpenBSD: popen.c,v 1.29 2015/11/04 20:28:17 millert Exp $	*/

/*
 * Copyright (c) 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software written by Ken Arnold and
 * published in UNIX Review, Vol. 6, No. 8.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/* this came out of the ftpd sources; it's been modified to avoid the
 * globbing stuff since we don't need it.  also execvp instead of execv.
 */

#include <sys/types.h>
#include <sys/wait.h>

#include <bitstring.h>		/* for structs.h */
#include <err.h>
#include <errno.h>
#include <login_cap.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <time.h>		/* for structs.h */

#include "macros.h"
#include "structs.h"
#include "funcs.h"

#define MAX_ARGV	100
#define MAX_GARGV	1000

/*
 * Special version of popen which avoids call to shell
 */
FILE *
cron_popen(char *program, char *type, struct passwd *pw, pid_t *pidptr)
{
	char *cp;
	FILE *iop;
	int argc, pdes[2];
	pid_t pid;
	char *argv[MAX_ARGV];

	if ((*type != 'r' && *type != 'w') || type[1] != '\0')
		return (NULL);

	if (pipe(pdes) < 0)
		return (NULL);

	/* break up string into pieces */
	for (argc = 0, cp = program; argc < MAX_ARGV - 1; cp = NULL)
		if (!(argv[argc++] = strtok(cp, " \t\n")))
			break;
	argv[MAX_ARGV-1] = NULL;

	switch (pid = fork()) {
	case -1:			/* error */
		(void)close(pdes[0]);
		(void)close(pdes[1]);
		return (NULL);
		/* NOTREACHED */
	case 0:				/* child */
		if (pw) {
			if (setusercontext(0, pw, pw->pw_uid, LOGIN_SETALL) < 0) {
				syslog(LOG_ERR,
				    "(%s) SETUSERCONTEXT FAILED (%m)",
				    pw->pw_name);
				warn("setusercontext failed for %s",
				    pw->pw_name);
				_exit(EXIT_FAILURE);
			}
		}
		if (*type == 'r') {
			if (pdes[1] != STDOUT_FILENO) {
				dup2(pdes[1], STDOUT_FILENO);
				(void)close(pdes[1]);
			}
			dup2(STDOUT_FILENO, STDERR_FILENO);
			(void)close(pdes[0]);
		} else {
			if (pdes[0] != STDIN_FILENO) {
				dup2(pdes[0], STDIN_FILENO);
				(void)close(pdes[0]);
			}
			(void)close(pdes[1]);
		}
		execvp(argv[0], argv);
		_exit(1);
	}

	/* parent; assume fdopen can't fail...  */
	if (*type == 'r') {
		iop = fdopen(pdes[0], type);
		(void)close(pdes[1]);
	} else {
		iop = fdopen(pdes[1], type);
		(void)close(pdes[0]);
	}
	*pidptr = pid;

	return (iop);
}

int
cron_pclose(FILE *iop, pid_t pid)
{
	int rv;
	int status;
	sigset_t sigset, osigset;

	(void)fclose(iop);
	sigemptyset(&sigset);
	sigaddset(&sigset, SIGINT);
	sigaddset(&sigset, SIGQUIT);
	sigaddset(&sigset, SIGHUP);
	sigprocmask(SIG_BLOCK, &sigset, &osigset);
	while ((rv = waitpid(pid, &status, 0)) < 0 && errno == EINTR)
		continue;
	sigprocmask(SIG_SETMASK, &osigset, NULL);
	if (rv < 0)
		return (rv);
	if (WIFEXITED(status))
		return (WEXITSTATUS(status));
	return (1);
}
@


1.29
log
@Change cron from including all headers in every file to only including
what each .c file needs.  I have not removed cron.h since it will
be used in a future clean up of the cron's .h files.  OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.28 2015/10/04 09:08:46 tedu Exp $	*/
d44 1
d52 1
d96 4
a99 2
				fprintf(stderr,
				    "setusercontext failed for %s\n",
@


1.28
log
@remove stale comment. there is no need to avoid side effects from a "list"
command, because this is not the ftp daemon
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.27 2015/10/03 19:47:21 tedu Exp $	*/
d40 17
a56 1
#include "cron.h"
@


1.27
log
@There is no need to keep a global array of sysconf(_SC_OPEN_MAX) elements
just to keep track of a single pid. Return it to the caller and make it
their problem.
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.26 2015/10/03 12:46:54 tedu Exp $	*/
d46 1
a46 3
 * Special version of popen which avoids call to shell.  This ensures noone
 * may create a pipe to a hidden program as a side effect of a list or dir
 * command.
@


1.26
log
@unifdef some features we will always have. ok benno zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.25 2015/01/23 19:07:27 tedu Exp $	*/
a49 3
static pid_t *pids;
static int fds;

d51 1
a51 1
cron_popen(char *program, char *type, struct passwd *pw)
a61 6
	if (!pids) {
		if ((fds = sysconf(_SC_OPEN_MAX)) <= 0)
			return (NULL);
		if (!(pids = calloc(fds, sizeof(pid_t))))
			return (NULL);
	}
d112 1
a112 1
	pids[fileno(iop)] = pid;
d118 1
a118 1
cron_pclose(FILE *iop)
d120 1
a120 2
	int fdes;
	pid_t pid;
a123 6
	/*
	 * pclose returns -1 if stream is not associated with a
	 * `popened' command, or, if already `pclosed'.
	 */
	if (pids == 0 || pids[fdes = fileno(iop)] == 0)
		return (-1);
d130 1
a130 1
	while ((pid = waitpid(pids[fdes], &status, 0)) < 0 && errno == EINTR)
d133 2
a134 3
	pids[fdes] = 0;
	if (pid < 0)
		return (pid);
@


1.25
log
@braces to open a function go on their own line like god intended
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.24 2015/01/14 17:27:51 millert Exp $	*/
a87 1
#ifdef LOGIN_CAP
a93 18
#else
			if (setgid(pw->pw_gid) < 0 ||
			    initgroups(pw->pw_name, pw->pw_gid) < 0) {
				fprintf(stderr,
				    "unable to set groups for %s\n",
				    pw->pw_name);
				_exit(1);
			}
#ifdef HAVE_SETLOGIN
			setlogin(pw->pw_name);
#endif
			if (setuid(pw->pw_uid)) {
				fprintf(stderr,
				    "unable to set uid for %s\n",
				    pw->pw_name);
				_exit(1);
			}
#endif /* LOGIN_CAP */
@


1.24
log
@Use HAVE_FOO for BSD-specific features instead of relying on the
BSD macro from sys/param.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.23 2015/01/14 17:27:30 millert Exp $	*/
d54 2
a55 1
cron_popen(char *program, char *type, struct passwd *pw) {
d146 2
a147 1
cron_pclose(FILE *iop) {
@


1.23
log
@Use standard types for wait, readdir, signals and pids.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.22 2011/08/22 19:32:42 millert Exp $	*/
d102 1
a102 1
#if (defined(BSD)) && (BSD >= 199103)
d104 1
a104 1
#endif /* BSD */
@


1.22
log
@Use standard EXIT_SUCCESS/EXIT_FAILURE and STD{IN,OUT,ERR}_FILENO
defines instead of using custom macros.  OK deraadt@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.21 2009/10/27 23:59:51 deraadt Exp $	*/
d50 1
a50 1
static PID_T *pids;
d58 1
a58 1
	PID_T pid;
d67 1
a67 1
		if (!(pids = calloc(fds, sizeof(PID_T))))
d147 2
a148 2
	PID_T pid;
	WAIT_T status;
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.20 2006/04/03 01:31:11 djm Exp $	*/
d92 1
a92 1
				_exit(ERROR_EXIT);
d114 2
a115 2
			if (pdes[1] != STDOUT) {
				dup2(pdes[1], STDOUT);
d118 1
a118 1
			dup2(STDOUT, STDERR);	/* stderr too! */
d121 2
a122 2
			if (pdes[0] != STDIN) {
				dup2(pdes[0], STDIN);
@


1.20
log
@some more malloc(x * y); bzero() -> calloc(x, y) whacking from
adobriyan AT gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.19 2003/06/02 04:39:45 millert Exp $	*/
a38 8

#ifndef lint
#if 0
static const sccsid[] = "@@(#)popen.c	8.3 (Berkeley) 4/6/94";
#else
static const char rcsid[] = "$OpenBSD: popen.c,v 1.19 2003/06/02 04:39:45 millert Exp $";
#endif
#endif /* not lint */
@


1.19
log
@I'm a dork, I removed the 4th clause of the UCB license instead of
the 3rd one.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.18 2003/02/20 20:38:08 millert Exp $	*/
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: popen.c,v 1.18 2003/02/20 20:38:08 millert Exp $";
d75 1
a75 1
		if (!(pids = (PID_T *)malloc((size_t)(fds * sizeof(PID_T)))))
a76 1
		bzero(pids, fds * sizeof(PID_T));
@


1.18
log
@Sync with ISC cron-current + my at(1) integration.
The at(1) code is now more tightly integrated into the cron codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.17 2002/07/15 19:13:29 millert Exp $	*/
d18 3
a20 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: popen.c,v 1.17 2002/07/15 19:13:29 millert Exp $";
@


1.17
log
@Move atrun(8) functionality into cron(8) proper.  This fixes the
long-standing annoyance that atrun's granularity is 10 minutes.
Most at jobs run with a 1 minute granularity.  Jobs submitted via
"at now" or "batch" will run immediately.  Includes a rewritten
cron(8) man page.  at(1) will be integrated more closely into
cron at a future date.

Upgrading notes:
    the atrun job in root's crontab should be removed.
    the /var/at/spool directory is no longer used
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.16 2002/07/09 00:24:50 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: popen.c,v 1.16 2002/07/09 00:24:50 millert Exp $";
d97 1
a97 1
#if defined(LOGIN_CAP)
d105 8
a112 4
			if (setgid(pw->pw_gid) ||
				setgroups(0, NULL) ||
				initgroups(pw->pw_name, pw->pw_gid))
				    _exit(1);
d114 5
a118 1
			if (setuid(pw->pw_uid))
d120 1
a120 1
			chdir(pw->pw_dir);
@


1.16
log
@We already did a closelog(); no need for it here.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.15 2002/07/08 18:11:02 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: popen.c,v 1.15 2002/07/08 18:11:02 millert Exp $";
d63 1
a63 1
cron_popen(char *program, char *type, entry *e) {
d96 1
a96 1
		if (e) {
d98 4
a101 9
			struct passwd *pwd;

			pwd = getpwuid(e->uid);
			if (pwd == NULL) {
				fprintf(stderr, "getpwuid: couldn't get entry for %u\n", e->uid);
				_exit(ERROR_EXIT);
			}
			if (setusercontext(0, pwd, e->uid, LOGIN_SETALL) < 0) {
				fprintf(stderr, "setusercontext failed for %u\n", e->uid);
d105 1
a105 1
			if (setgid(e->gid) ||
d107 1
a107 1
				initgroups(env_get("LOGNAME", e->envp), e->gid))
d109 2
a110 2
			setlogin(env_get("LOGNAME", e->envp));
			if (setuid(e->uid))
d112 1
a112 1
			chdir(env_get("HOME", e->envp));
@


1.15
log
@Merge in some changes from Paul Vixie's tree; most are cosmetic
o ANSI function headers
o return (foo) not return foo
o add -oi to sendmail flags
o update email address in man pages
o make some strings const
o completely remove globbing cruft from popen.c
o whitespace changes
o add DOW_STAR to flags for "monthly", "weekly", and "daily" cron entries
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.14 2002/06/23 03:07:19 deraadt Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: popen.c,v 1.14 2002/06/23 03:07:19 deraadt Exp $";
a119 1
		closelog();
@


1.14
log
@uid_t and gid_t are unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.13 2002/01/09 00:51:00 millert Exp $	*/
d37 4
d43 1
a43 1
static char sccsid[] = "@@(#)popen.c	8.3 (Berkeley) 4/6/94";
d45 1
a45 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.13 2002/01/09 00:51:00 millert Exp $";
a52 1
#define WANT_GLOBBING 0
d63 1
a63 5
cron_popen(program, type, e)
	char *program;
	char *type;
	entry *e;
{
a68 4
#if WANT_GLOBBING
	char **pop, *gargv[MAX_GARGV];
	int gargc;
#endif
d70 1
a70 1
	if ((*type != 'r' && *type != 'w') || type[1])
d76 1
a76 1
		if (!(pids = (PID_T *)malloc((size_t)(fds * sizeof(int)))))
d84 1
a84 1
	for (argc = 0, cp = program;argc < MAX_ARGV-1; cp = NULL)
d89 1
a89 30
#if WANT_GLOBBING
	/* glob each piece */
	gargv[0] = argv[0];
	for (gargc = argc = 1; argv[argc]; argc++) {
		glob_t gl;

		bzero(&gl, sizeof(gl));
		if (glob(argv[argc],
		    GLOB_BRACE|GLOB_NOCHECK|GLOB_QUOTE|GLOB_TILDE|GLOB_LIMIT,
		    NULL, &gl)) {
			if (gargc < MAX_GARGV-1) {
				gargv[gargc++] = strdup(argv[argc]);
				if (gargv[gargc -1] == NULL)
					fatal ("Out of memory");
			}

		} else
			for (pop = gl.gl_pathv; *pop && gargc < MAX_GARGV-1; pop++) {
				gargv[gargc++] = strdup(*pop);
				if (gargv[gargc - 1] == NULL)
					fatal ("Out of memory");
			}
		globfree(&gl);
	}
	gargv[gargc] = NULL;
#endif

	iop = NULL;

	switch(pid = fork()) {
d93 1
a93 1
		goto pfree;
a134 3
#if WANT_GLOBBING
		execvp(gargv[0], gargv);
#else
a135 1
#endif
a148 5
pfree:
#if WANT_GLOBBING
for (argc = 1; gargv[argc] != NULL; argc++)
		free(gargv[argc]);
#endif
d153 1
a153 3
cron_pclose(iop)
	FILE *iop;
{
@


1.13
log
@Kill volatile now that jongjmp is history.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.12 2001/10/24 17:28:16 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.12 2001/10/24 17:28:16 millert Exp $";
d136 1
a136 1
				fprintf(stderr, "getpwuid: couldn't get entry for %d\n", e->uid);
d140 1
a140 1
				fprintf(stderr, "setusercontext failed for %d\n", e->uid);
@


1.12
log
@When becoming a daemon, dup stdin, stdout, and stderr to /dev/null
Change an unsafe vfork() to fork()
Fix dup2() usage--must check for oldd == newd case and no need to close oldd
Fixes annoying messages from sendmail about stdout being closed.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.11 2001/10/01 19:19:09 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.11 2001/10/01 19:19:09 millert Exp $";
d66 1
a66 1
	FILE * volatile iop;
@


1.11
log
@In "r" mode always dup2(STDOUT_FILENO, STDERR_FILENO); from ftpd/popen.c
Otherwise, sendmail may complain about the lack of stderr.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.10 2001/06/03 01:30:04 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.10 2001/06/03 01:30:04 millert Exp $";
d156 2
a157 2
			if (pdes[1] != STDOUT_FILENO) {
				dup2(pdes[1], STDOUT_FILENO);
d160 1
a160 1
			dup2(STDOUT_FILENO, STDERR_FILENO); /* stderr too! */
d163 2
a164 2
			if (pdes[0] != STDIN_FILENO) {
				dup2(pdes[0], STDIN_FILENO);
@


1.10
log
@Move login_cap stuff before pipe duping
Move the stderr dup2 to be with stdout dup2 as before since otherwise
sendmail seems to get unhappy.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.9 2001/06/02 21:56:17 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.9 2001/06/02 21:56:17 millert Exp $";
a157 1
				dup2(pdes[1], STDERR_FILENO); /* stderr too! */
d160 1
@


1.9
log
@Version derived from new ftpd code which has an updated UCB license.
@
text
@d1 1
a1 1
/*	$OpenBSD: popen.c,v 1.8 2001/02/18 19:48:36 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: popen.c,v 1.5 1995/04/11 02:45:00 cgd Exp $";
a129 15
		closelog();
		if (*type == 'r') {
			if (pdes[1] != STDOUT_FILENO) {
				dup2(pdes[1], STDOUT_FILENO);
				(void)close(pdes[1]);
			}
			dup2(STDOUT_FILENO, STDERR_FILENO); /* stderr too! */
			(void)close(pdes[0]);
		} else {
			if (pdes[0] != STDIN_FILENO) {
				dup2(pdes[0], STDIN_FILENO);
				(void)close(pdes[0]);
			}
			(void)close(pdes[1]);
		}
d154 15
d170 1
a170 1
		execv(gargv[0], gargv);
d176 1
@


1.8
log
@Update to ISC cron 4.0b1 + our patches.  This is now under a BSD license.
I also fixed the signal handlers while I was at it.
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d4 2
a5 2
 * Copyright (c) 1988 The Regents of the University of California.
 * All rights reserved.
d10 24
a33 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
a36 4
/* this came out of the ftpd sources; it's been modified to avoid the
 * globbing stuff since we don't need it.  also execvp instead of execv.
 */

d38 5
a42 2
static char rcsid[] = "$OpenBSD: popen.c,v 1.3 1998/08/14 00:32:41 vixie Exp $";
static char sccsid[] = "@@(#)popen.c	5.7 (Berkeley) 2/14/89";
d47 2
a48 2
#define MAX_ARGS 100
#define MAX_GARGS 1000
d52 1
a52 1
 * Special version of popen which avoids call to shell.  This insures noone
d69 1
a69 1
	char *argv[MAX_ARGS + 1];
d71 1
a71 1
	char **pop, *vv[2];
a72 2
	char *gargv[MAX_GARGS];
	extern char **glob(), **copyblk();
d75 1
a75 1
	if ((*type != 'r' && *type != 'w') || type[1] != '\0')
d81 1
a81 1
		if (!(pids = (PID_T *)malloc((size_t)(fds * sizeof(PID_T)))))
d83 1
a83 1
		bzero((char *)pids, fds * sizeof(PID_T));
d89 1
a89 1
	for (argc = 0, cp = program; argc < MAX_ARGS; cp = NULL)
d92 1
a92 1
	argv[MAX_ARGS] = NULL;
d98 19
a116 8
		if (!(pop = glob(argv[argc]))) {	/* globbing failed */
			vv[0] = argv[argc];
			vv[1] = NULL;
			pop = copyblk(vv);
		}
		argv[argc] = (char *)pop;		/* save to free later */
		while (*pop && gargc < MAX_GARGS)
			gargv[gargc++] = *pop++;
d122 2
a123 1
	switch(pid = vfork()) {
d132 2
a133 3
			if (pdes[1] != 1) {
				dup2(pdes[1], 1);
				dup2(pdes[1], 2);	/* stderr, too! */
d136 1
d139 2
a140 2
			if (pdes[0] != 0) {
				dup2(pdes[0], 0);
d170 1
a170 1
		execvp(gargv[0], gargv);
d188 2
a189 4
	for (argc = 1; argv[argc] != NULL; argc++) {
/*		blkfree((char **)argv[argc]);	*/
		free((char *)argv[argc]);
	}
a198 2
	int omask;
	WAIT_T stat_loc;
d200 2
d210 8
a217 4
	omask = sigblock(sigmask(SIGINT)|sigmask(SIGQUIT)|sigmask(SIGHUP));
	while ((pid = wait(&stat_loc)) != pids[fdes] && pid != -1)
		;
	(void)sigsetmask(omask);
d219 5
a223 1
	return (pid == -1 ? -1 : WEXITSTATUS(stat_loc));
@


1.7
log
@closelog, and check for various child setup failures; solar@@false.com
@
text
@d1 1
d28 1
a28 1
static char rcsid[] = "$Id: popen.c,v 1.6 2000/08/20 18:42:42 millert Exp $";
a33 9
#include <signal.h>
#include <syslog.h>
#include <unistd.h>
#include <grp.h>

#if defined(LOGIN_CAP)
# include <login_cap.h>
#endif

d35 1
d48 2
a49 1
	char *program, *type;
d52 2
a53 2
	register char *cp;
	FILE *iop;
d60 1
a60 1
	char *gargv[1000];
d64 2
a65 6
#ifdef __GNUC__
	(void) &iop;	/* Avoid vfork clobbering */
#endif

	if ((*type != 'r' && *type != 'w') || type[1])
		return(NULL);
d68 4
a71 4
		if ((fds = getdtablesize()) <= 0)
			return(NULL);
		if (!(pids = (PID_T *)malloc((u_int)(fds * sizeof(PID_T)))))
			return(NULL);
d75 1
a75 1
		return(NULL);
d93 1
a93 1
		while (*pop && gargc < 1000)
d137 3
a139 3
			    setgroups(0, NULL) ||
			    initgroups(env_get("LOGNAME", e->envp), e->gid))
				_exit(1);
d144 1
a144 1
#endif
d170 1
a170 1
	return(iop);
d177 1
a177 1
	register int fdes;
d187 1
a187 1
		return(-1);
@


1.6
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d27 1
a27 1
static char rcsid[] = "$Id: popen.c,v 1.5 1999/08/30 10:45:37 millert Exp $";
d32 1
d34 4
a41 1

d117 1
d146 4
a149 4
			setgid(e->gid);
# if defined(BSD)
			initgroups(env_get("LOGNAME", e->envp), e->gid);
# endif
d151 2
a152 1
			setuid(e->uid);
@


1.5
log
@in cron_popen(), do an initgroups, setlogin() and chdir to the user's
home dir to make things consistent with what cron does when executing
a normal command on behalf of the user.  I originally didn't think this
was worth doing but changed my mind.
@
text
@d27 1
a27 1
static char rcsid[] = "$Id: popen.c,v 1.4 1999/08/28 20:13:13 millert Exp $";
d33 3
d128 13
d142 1
a142 1
#if defined(BSD)
d144 1
a144 1
#endif
d148 1
@


1.4
log
@Run sendmail as the user corresponding to the crontab entry.
This keeps a user from abusing sendmail via the MAILTO var.
Had to drop -or0s from MAILARGS since that causes sendmail
to drop its privs (contrary to the sendmail docs).
@
text
@d27 1
a27 1
static char rcsid[] = "$Id: popen.c,v 1.3 1999/08/27 10:13:18 millert Exp $";
d126 4
d131 1
@


1.3
log
@Make sure argv gets NULL terminated if cron entry has >= MAX_ARGS arguments.
Gleaned from RedHat info.
@
text
@d27 1
a27 1
static char rcsid[] = "$Id: popen.c,v 1.2 1998/03/30 06:59:47 deraadt Exp $";
d47 1
a47 1
cron_popen(program, type)
d49 1
d123 4
@


1.2
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d27 1
a27 1
static char rcsid[] = "$Id: popen.c,v 1.1.1.1 1995/10/18 08:47:31 deraadt Exp $";
d83 1
@


1.1
log
@Initial revision
@
text
@d27 1
a27 1
static char rcsid[] = "$Id: popen.c,v 1.2 1995/04/14 19:49:35 mycroft Exp $";
d32 1
a32 1
#include <sys/signal.h>
d62 5
a66 1
	if (*type != 'r' && *type != 'w' || type[1])
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
