head	1.34;
access;
symbols
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.19.0.18
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.16
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.12
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.10
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.8
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.12
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.8
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.6
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.4
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.12
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.10
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.8
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.13.0.6
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.4
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.5.0.6
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.8
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2016.01.11.14.23.50;	author millert;	state Exp;
branches;
next	1.33;
commitid	fFP0tihUFMiVcTny;

1.33
date	2015.11.14.13.09.14;	author millert;	state Exp;
branches;
next	1.32;
commitid	KNISMJYcyEJqWs74;

1.32
date	2015.11.12.21.12.05;	author millert;	state Exp;
branches;
next	1.31;
commitid	6PlWoK7FsQNDGZmn;

1.31
date	2015.11.09.16.37.07;	author millert;	state Exp;
branches;
next	1.30;
commitid	ZJUG9DwHA5l6WcX2;

1.30
date	2015.11.09.15.57.39;	author millert;	state Exp;
branches;
next	1.29;
commitid	JJzvBekc1nrVHuHQ;

1.29
date	2015.11.09.01.12.27;	author millert;	state Exp;
branches;
next	1.28;
commitid	NbIbD3dCbvLEHSye;

1.28
date	2015.11.04.20.28.17;	author millert;	state Exp;
branches;
next	1.27;
commitid	6N0oXtYc5KM1a7DW;

1.27
date	2015.10.26.14.27.41;	author millert;	state Exp;
branches;
next	1.26;
commitid	k893fgzG4z9i5qIx;

1.26
date	2015.10.06.14.58.37;	author tedu;	state Exp;
branches;
next	1.25;
commitid	DORRwC1MyrO1Yl4N;

1.25
date	2015.02.09.22.35.08;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	eGq01x6bjr83TVho;

1.24
date	2015.01.23.19.07.27;	author tedu;	state Exp;
branches;
next	1.23;
commitid	YJA2vmvfLuMfGdwZ;

1.23
date	2015.01.23.02.37.25;	author tedu;	state Exp;
branches;
next	1.22;
commitid	UGPHvhzwRtnjrF9O;

1.22
date	2015.01.23.01.01.06;	author tedu;	state Exp;
branches;
next	1.21;
commitid	kzBIhYnXdVeOLxgw;

1.21
date	2015.01.14.17.30.53;	author millert;	state Exp;
branches;
next	1.20;
commitid	qsePpGDsMLqV3DYZ;

1.20
date	2015.01.14.17.27.29;	author millert;	state Exp;
branches;
next	1.19;
commitid	jXmo2gNqOzD6QEsx;

1.19
date	2010.12.14.23.31.33;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.28.16.49.25;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.22.03.15.33;	author avsm;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.17.22.11.55;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.03.18.41.58;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.15.00.39.01;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.20.20.38.08;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.10.20.28.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.07.23.22.41;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.04.22.10.24;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.02.22.40.48;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.08.18.11.02;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.09.21.22.01;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.18.19.48.33;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.21.21.08.56;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.12.22.08.10.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.09.15.09.13.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.30;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.34
log
@When caching the mtime of the spool directory and system crontab files,
stash a struct timespec, not just a time_t.  Fixes a bug where cron
could skip re-reading the spool after two consecutive changes.
@
text
@/*	$OpenBSD: database.c,v 1.33 2015/11/14 13:09:14 millert Exp $	*/

/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
 * Copyright (c) 1997,2000 by Internet Software Consortium, Inc.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <bitstring.h>		/* for structs.h */
#include <dirent.h>
#include <fcntl.h>
#include <limits.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>		/* for structs.h */
#include <unistd.h>

#include "pathnames.h"
#include "macros.h"
#include "structs.h"
#include "funcs.h"

#define HASH(a,b) ((a)+(b))

static	void		process_crontab(int, const char *, const char *,
					struct stat *, cron_db *, cron_db *);

void
load_database(cron_db **db)
{
	struct stat statbuf, syscron_stat;
	cron_db *new_db, *old_db = *db;
	struct timespec mtime;
	struct dirent *dp;
	DIR *dir;
	user *u;

	/* before we start loading any data, do a stat on _PATH_CRON_SPOOL
	 * so that if anything changes as of this moment (i.e., before we've
	 * cached any of the database), we'll see the changes next time.
	 */
	if (stat(_PATH_CRON_SPOOL, &statbuf) < 0) {
		syslog(LOG_ERR, "(CRON) STAT FAILED (%s)", _PATH_CRON_SPOOL);
		return;
	}

	/* track system crontab file
	 */
	if (stat(_PATH_SYS_CRONTAB, &syscron_stat) < 0)
		timespecclear(&syscron_stat.st_mtim);

	/* hash mtime of system crontab file and crontab dir
	 */
	mtime.tv_sec =
	    HASH(statbuf.st_mtim.tv_sec, syscron_stat.st_mtim.tv_sec);
	mtime.tv_nsec =
	    HASH(statbuf.st_mtim.tv_nsec, syscron_stat.st_mtim.tv_nsec);

	/* if spooldir's mtime has not changed, we don't need to fiddle with
	 * the database.
	 */
	if (old_db != NULL && timespeccmp(&mtime, &old_db->mtime, ==))
		return;

	/* something's different.  make a new database, moving unchanged
	 * elements from the old database, reloading elements that have
	 * actually changed.  Whatever is left in the old database when
	 * we're done is chaff -- crontabs that disappeared.
	 */
	if ((new_db = malloc(sizeof(*new_db))) == NULL)
		return;
	new_db->mtime = mtime;
	TAILQ_INIT(&new_db->users);

	if (timespecisset(&syscron_stat.st_mtim)) {
		process_crontab(AT_FDCWD, "*system*", _PATH_SYS_CRONTAB,
				&syscron_stat, new_db, old_db);
	}

	/* we used to keep this dir open all the time, for the sake of
	 * efficiency.  however, we need to close it in every fork, and
	 * we fork a lot more often than the mtime of the dir changes.
	 */
	if (!(dir = opendir(_PATH_CRON_SPOOL))) {
		syslog(LOG_ERR, "(CRON) OPENDIR FAILED (%s)", _PATH_CRON_SPOOL);
		/* Restore system crontab entry as needed. */
		if (!TAILQ_EMPTY(&new_db->users) &&
		    (u = TAILQ_FIRST(&old_db->users))) {
			if (strcmp(u->name, "*system*") == 0) {
				TAILQ_REMOVE(&old_db->users, u, entries);
				free_user(u);
				TAILQ_INSERT_HEAD(&old_db->users,
				    TAILQ_FIRST(&new_db->users), entries);
			}
		}
		free(new_db);
		return;
	}

	while (NULL != (dp = readdir(dir))) {
		/* avoid file names beginning with ".".  this is good
		 * because we would otherwise waste two guaranteed calls
		 * to getpwnam() for . and .., and also because user names
		 * starting with a period are just too nasty to consider.
		 */
		if (dp->d_name[0] == '.')
			continue;

		process_crontab(dirfd(dir), dp->d_name, dp->d_name,
				&statbuf, new_db, old_db);
	}
	closedir(dir);

	/* if we don't do this, then when our children eventually call
	 * getpwnam() in do_command.c's child_process to verify MAILTO=,
	 * they will screw us up (and v-v).
	 */
	endpwent();

	/* whatever's left in the old database is now junk.
	 */
	if (old_db != NULL) {
		while ((u = TAILQ_FIRST(&old_db->users))) {
			TAILQ_REMOVE(&old_db->users, u, entries);
			free_user(u);
		}
		free(old_db);
	}

	/* overwrite the database control block with the new one.
	 */
	*db = new_db;
}

user *
find_user(cron_db *db, const char *name)
{
	user *u = NULL;

	if (db != NULL) {
		TAILQ_FOREACH(u, &db->users, entries) {
			if (strcmp(u->name, name) == 0)
				break;
		}
	}
	return (u);
}

static void
process_crontab(int dfd, const char *uname, const char *fname,
		struct stat *statbuf, cron_db *new_db, cron_db *old_db)
{
	struct passwd *pw = NULL;
	int crontab_fd = -1;
	user *u;

	/* Note: pw must remain NULL for system crontab (see below). */
	if (fname[0] != '/' && (pw = getpwnam(uname)) == NULL) {
		/* file doesn't have a user in passwd file.
		 */
		syslog(LOG_WARNING, "(%s) ORPHAN (no passwd entry)", uname);
		goto next_crontab;
	}

	crontab_fd = openat(dfd, fname, O_RDONLY|O_NONBLOCK|O_NOFOLLOW);
	if (crontab_fd < 0) {
		/* crontab not accessible?
		 */
		syslog(LOG_ERR, "(%s) CAN'T OPEN (%s)", uname, fname);
		goto next_crontab;
	}

	if (fstat(crontab_fd, statbuf) < 0) {
		syslog(LOG_ERR, "(%s) FSTAT FAILED (%s)", uname, fname);
		goto next_crontab;
	}
	if (!S_ISREG(statbuf->st_mode)) {
		syslog(LOG_WARNING, "(%s) NOT REGULAR (%s)", uname, fname);
		goto next_crontab;
	}
	if (pw != NULL) {
		/* Looser permissions on system crontab. */
		if ((statbuf->st_mode & 077) != 0) {
			syslog(LOG_WARNING, "(%s) BAD FILE MODE (%s)",
			    uname, fname);
			goto next_crontab;
		}
	}
	if (statbuf->st_uid != 0 && (pw == NULL ||
	    statbuf->st_uid != pw->pw_uid || strcmp(uname, pw->pw_name) != 0)) {
		syslog(LOG_WARNING, "(%s) WRONG FILE OWNER (%s)", uname, fname);
		goto next_crontab;
	}
	if (pw != NULL && statbuf->st_nlink != 1) {
		syslog(LOG_WARNING, "(%s) BAD LINK COUNT (%s)", uname, fname);
		goto next_crontab;
	}

	u = find_user(old_db, fname);
	if (u != NULL) {
		/* if crontab has not changed since we last read it
		 * in, then we can just use our existing entry.
		 */
		if (timespeccmp(&u->mtime, &statbuf->st_mtim, ==)) {
			TAILQ_REMOVE(&old_db->users, u, entries);
			TAILQ_INSERT_TAIL(&new_db->users, u, entries);
			goto next_crontab;
		}

		/* before we fall through to the code that will reload
		 * the user, let's deallocate and unlink the user in
		 * the old database.  This is more a point of memory
		 * efficiency than anything else, since all leftover
		 * users will be deleted from the old database when
		 * we finish with the crontab...
		 */
		TAILQ_REMOVE(&old_db->users, u, entries);
		free_user(u);
		syslog(LOG_INFO, "(%s) RELOAD (%s)", uname, fname);
	}
	u = load_user(crontab_fd, pw, fname);
	if (u != NULL) {
		u->mtime = statbuf->st_mtim;
		TAILQ_INSERT_TAIL(&new_db->users, u, entries);
	}

 next_crontab:
	if (crontab_fd >= 0) {
		close(crontab_fd);
	}
}
@


1.33
log
@Remove log_it() and call syslog(3) directly using the same format:
"(username) WHAT (details)".  Logs due to normal operation (e.g.
crontab operations or running commands) are logged at LOG_INFO like
before.  Actual errors are logged at LOG_ERR, less important things
are logged at LOG_WARNING OR LOG_NOTICE.  Also ignore SIGHUP now
that there is no log file to reopen.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.32 2015/11/12 21:12:05 millert Exp $	*/
d22 1
d51 1
d68 8
a75 1
		syscron_stat.st_mtime = 0;
d80 1
a80 2
	if (old_db != NULL &&
	    old_db->mtime == HASH(statbuf.st_mtime, syscron_stat.st_mtime)) {
a81 1
	}
d90 1
a90 1
	new_db->mtime = HASH(statbuf.st_mtime, syscron_stat.st_mtime);
d93 1
a93 1
	if (syscron_stat.st_mtime) {
d222 1
a222 1
		if (u->mtime == statbuf->st_mtime) {
d241 1
a241 1
		u->mtime = statbuf->st_mtime;
@


1.32
log
@Use absolute paths in pathnames.h.  There is no longer a need to
chdir(2) to the cron dir and cron(8) now changes to / via daemon(3).
We no longer try to create/chmod the spool directories as they
should be set correctly at install time.  The setegid(crontab)
has been moved to open_socket() so it is closer to the chmod(2)
call that needs it.  OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.31 2015/11/09 16:37:07 millert Exp $	*/
d31 1
d59 1
a59 1
		log_it("CRON", "STAT FAILED", _PATH_CRON_SPOOL);
d96 1
a96 1
		log_it("CRON", "OPENDIR FAILED", _PATH_CRON_SPOOL);
d172 1
a172 1
		log_it(uname, "ORPHAN", "no passwd entry");
d180 1
a180 1
		log_it(uname, "CAN'T OPEN", fname);
d185 1
a185 1
		log_it(uname, "FSTAT FAILED", fname);
d189 1
a189 1
		log_it(uname, "NOT REGULAR", fname);
d195 2
a196 1
			log_it(uname, "BAD FILE MODE", fname);
d202 1
a202 1
		log_it(uname, "WRONG FILE OWNER", fname);
d206 1
a206 1
		log_it(uname, "BAD LINK COUNT", fname);
d230 1
a230 1
		log_it(uname, "RELOAD", fname);
@


1.31
log
@Remove unused xpid argument to log_it().
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.30 2015/11/09 15:57:39 millert Exp $	*/
d41 2
a42 3
static	void		process_crontab(const char *, const char *,
					const char *, struct stat *,
					cron_db *, cron_db *);
d53 1
a53 1
	/* before we start loading any data, do a stat on CRON_SPOOL
d57 2
a58 2
	if (stat(CRON_SPOOL, &statbuf) < 0) {
		log_it("CRON", "STAT FAILED", CRON_SPOOL);
d64 1
a64 1
	if (stat(SYSCRONTAB, &syscron_stat) < 0)
d86 2
a87 2
		process_crontab("root", NULL, SYSCRONTAB, &syscron_stat,
				new_db, old_db);
d94 2
a95 2
	if (!(dir = opendir(CRON_SPOOL))) {
		log_it("CRON", "OPENDIR FAILED", CRON_SPOOL);
a110 2
		char fname[NAME_MAX+1], tabname[MAX_FNAME];

d119 1
a119 8
		if (strlcpy(fname, dp->d_name, sizeof fname) >= sizeof fname)
			continue;	/* XXX log? */

		if (snprintf(tabname, sizeof tabname, "%s/%s", CRON_SPOOL, fname) >=
			sizeof(tabname))
			continue;	/* XXX log? */

		process_crontab(fname, fname, tabname,
d160 1
a160 1
process_crontab(const char *uname, const char *fname, const char *tabname,
d167 2
a168 5
	if (fname == NULL) {
		/* must be set to something for logging purposes.
		 */
		fname = "*system*";
	} else if ((pw = getpwnam(uname)) == NULL) {
d171 1
a171 1
		log_it(fname, "ORPHAN", "no passwd entry");
d175 2
a176 1
	if ((crontab_fd = open(tabname, O_RDONLY|O_NONBLOCK|O_NOFOLLOW, 0)) < 0) {
d179 1
a179 1
		log_it(fname, "CAN'T OPEN", tabname);
d184 1
a184 1
		log_it(fname, "FSTAT FAILED", tabname);
d188 1
a188 1
		log_it(fname, "NOT REGULAR", tabname);
d191 1
a191 1
	if ((statbuf->st_mode & 07577) != 0400) {
d193 2
a194 2
		if (pw != NULL || (statbuf->st_mode & 022) != 0) {
			log_it(fname, "BAD FILE MODE", tabname);
d200 1
a200 1
		log_it(fname, "WRONG FILE OWNER", tabname);
d204 1
a204 1
		log_it(fname, "BAD LINK COUNT", tabname);
d228 1
a228 1
		log_it(fname, "RELOAD", tabname);
@


1.30
log
@Rename AT_DIR -> AT_SPOOL and SPOOL_DIR -> CRON_SPOOL to improve
readability.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.29 2015/11/09 01:12:27 millert Exp $	*/
d59 1
a59 1
		log_it("CRON", getpid(), "STAT FAILED", CRON_SPOOL);
d96 1
a96 1
		log_it("CRON", getpid(), "OPENDIR FAILED", CRON_SPOOL);
d184 1
a184 1
		log_it(fname, getpid(), "ORPHAN", "no passwd entry");
d191 1
a191 1
		log_it(fname, getpid(), "CAN'T OPEN", tabname);
d196 1
a196 1
		log_it(fname, getpid(), "FSTAT FAILED", tabname);
d200 1
a200 1
		log_it(fname, getpid(), "NOT REGULAR", tabname);
d206 1
a206 1
			log_it(fname, getpid(), "BAD FILE MODE", tabname);
d212 1
a212 1
		log_it(fname, getpid(), "WRONG FILE OWNER", tabname);
d216 1
a216 1
		log_it(fname, getpid(), "BAD LINK COUNT", tabname);
d240 1
a240 1
		log_it(fname, getpid(), "RELOAD", tabname);
@


1.29
log
@queue(3) instead of homegrown queues and lists.  This also fixes
some potential memory leaks in error paths.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.28 2015/11/04 20:28:17 millert Exp $	*/
d54 1
a54 1
	/* before we start loading any data, do a stat on SPOOL_DIR
d58 2
a59 2
	if (stat(SPOOL_DIR, &statbuf) < 0) {
		log_it("CRON", getpid(), "STAT FAILED", SPOOL_DIR);
d95 2
a96 2
	if (!(dir = opendir(SPOOL_DIR))) {
		log_it("CRON", getpid(), "OPENDIR FAILED", SPOOL_DIR);
d125 1
a125 1
		if (snprintf(tabname, sizeof tabname, "%s/%s", SPOOL_DIR, fname) >=
@


1.28
log
@Change cron from including all headers in every file to only including
what each .c file needs.  I have not removed cron.h since it will
be used in a future clean up of the cron's .h files.  OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.27 2015/10/26 14:27:41 millert Exp $	*/
d46 1
a46 1
load_database(cron_db *old_db)
d49 1
a49 1
	cron_db new_db;
d52 1
a52 1
	user *u, *nu;
a69 4
	 *
	 * Note that old_db->mtime is initialized to 0 in main(), and
	 * so is guaranteed to be different than the stat() mtime the first
	 * time this function is called.
d71 2
a72 1
	if (old_db->mtime == HASH(statbuf.st_mtime, syscron_stat.st_mtime)) {
d81 4
a84 2
	new_db.mtime = HASH(statbuf.st_mtime, syscron_stat.st_mtime);
	new_db.head = new_db.tail = NULL;
d88 1
a88 1
				&new_db, old_db);
d97 11
d130 1
a130 1
				&statbuf, &new_db, old_db);
d142 6
a147 4
	for (u = old_db->head;  u != NULL;  u = nu) {
		nu = u->next;
		unlink_user(old_db, u);
		free_user(u);
d152 1
a152 27
	*old_db = new_db;
}

void
link_user(cron_db *db, user *u)
{
	if (db->head == NULL)
		db->head = u;
	if (db->tail)
		db->tail->next = u;
	u->prev = db->tail;
	u->next = NULL;
	db->tail = u;
}

void
unlink_user(cron_db *db, user *u)
{
	if (u->prev == NULL)
		db->head = u->next;
	else
		u->prev->next = u->next;

	if (u->next == NULL)
		db->tail = u->prev;
	else
		u->next->prev = u->prev;
d158 1
a158 1
	user *u;
d160 6
a165 3
	for (u = db->head;  u != NULL;  u = u->next)
		if (strcmp(u->name, name) == 0)
			break;
d226 2
a227 2
			unlink_user(old_db, u);
			link_user(new_db, u);
d238 1
a238 1
		unlink_user(old_db, u);
d245 1
a245 1
		link_user(new_db, u);
@


1.27
log
@Remove some useless defines and the set_cron_uid() function.
OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.26 2015/10/06 14:58:37 tedu Exp $	*/
d20 18
a37 1
#include "cron.h"
@


1.26
log
@clear out some more legacy code and whatnot
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.25 2015/02/09 22:35:08 deraadt Exp $	*/
d71 1
a71 1
		process_crontab(ROOT_USER, NULL, SYSCRONTAB, &syscron_stat,
d204 1
a204 1
	if (statbuf->st_uid != ROOT_UID && (pw == NULL ||
@


1.25
log
@correct copyright, upon approval from paul vixie via todd miller.  the
head copyright assertion was seperated from the remaining ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.24 2015/01/23 19:07:27 tedu Exp $	*/
a17 3
 */

/* vix 26jan87 [RCS has the log]
@


1.24
log
@braces to open a function go on their own line like god intended
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.23 2015/01/23 02:37:25 tedu Exp $	*/
a3 4
 * All rights reserved
 */

/*
@


1.23
log
@Remove the OK and ERR macros. They obfuscate the code and don't
help legibility. (unix system calls use 0 for ok, but hundreds of
other projects use 1 to indicate success.) Despite the name, many
system calls (e.g., open) also return not OK values for success.
It also cleans up some weird code like int crontab_fd = OK - 1;
This diff is mechanical in nature. Later I will fix the bugs it reveals.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.22 2015/01/23 01:01:06 tedu Exp $	*/
d36 2
a37 1
load_database(cron_db *old_db) {
d134 2
a135 1
link_user(cron_db *db, user *u) {
d146 2
a147 1
unlink_user(cron_db *db, user *u) {
d160 2
a161 1
find_user(cron_db *db, const char *name) {
@


1.22
log
@remove debug code.
I think the level of debug code in cron is excessive for a program
that has reached feature complete. If cron needs to provide more
information to the user about its operational status, I think syslog
would be more appropriate. (The debug flags also disable forking
into the background, so they aren't even that useful for debugging a
live system.)
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.21 2015/01/14 17:30:53 millert Exp $	*/
d47 1
a47 1
	if (stat(SPOOL_DIR, &statbuf) < OK) {
d54 1
a54 1
	if (stat(SYSCRONTAB, &syscron_stat) < OK)
d171 1
a171 1
	int crontab_fd = OK - 1;
d185 1
a185 1
	if ((crontab_fd = open(tabname, O_RDONLY|O_NONBLOCK|O_NOFOLLOW, 0)) < OK) {
d192 1
a192 1
	if (fstat(crontab_fd, statbuf) < OK) {
d246 1
a246 1
	if (crontab_fd >= OK) {
@


1.21
log
@Replace MAXHOSTNAMELEN with HOST_NAME_MAX+1 and MAXNAMLEN with NAME_MAX
and use limits.h instead of sys/param.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.20 2015/01/14 17:27:29 millert Exp $	*/
a42 2
	Debug(DLOAD, ("[%ld] load_database()\n", (long)getpid()))

a64 2
		Debug(DLOAD, ("[%ld] spool dir mtime unch, no load needed.\n",
			      (long)getpid()))
a120 1
	Debug(DLOAD, ("unlinking old database:\n"))
a121 1
		Debug(DLOAD, ("\t%s\n", u->name))
a129 1
	Debug(DLOAD, ("load_database is done\n"))
a216 1
	Debug(DLOAD, ("\t%s:", fname))
a222 1
			Debug(DLOAD, (" [no change, using old data]"))
a234 1
		Debug(DLOAD, (" [delete old data]"))
a246 1
		Debug(DLOAD, (" [done]\n"))
@


1.20
log
@Use standard types for wait, readdir, signals and pids.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.19 2010/12/14 23:31:33 millert Exp $	*/
d95 1
a95 1
		char fname[MAXNAMLEN+1], tabname[MAXNAMLEN];
@


1.19
log
@Treat a missing spool dir like an empty one.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.18 2009/10/27 23:59:51 deraadt Exp $	*/
d39 1
a39 1
	DIR_T *dp;
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.17 2007/03/28 16:49:25 millert Exp $	*/
d51 1
a51 1
		(void) exit(ERROR_EXIT);
d91 1
a91 1
		(void) exit(ERROR_EXIT);
@


1.17
log
@Since /etc/crontab is not edited via crontab(1) there's no good
reason to require its mode to be be 0400 or to bail if the link
count is != 1.  The reason for such paranoia all has to do with
crontab(1) and editing user crontab files.  We now only require
that /etc/crontab not be writable by anyone other than the owner.
OK deraadt@@ ajacoutot@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.16 2004/06/22 03:15:33 avsm Exp $	*/
a22 4

#if !defined(lint) && !defined(LINT)
static char const rcsid[] = "$OpenBSD: database.c,v 1.16 2004/06/22 03:15:33 avsm Exp $";
#endif
@


1.16
log
@use snprintf(3) instead of home-grown glue_strings() function
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.15 2004/06/17 22:11:55 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: database.c,v 1.15 2004/06/17 22:11:55 millert Exp $";
d212 5
a216 2
		log_it(fname, getpid(), "BAD FILE MODE", tabname);
		goto next_crontab;
d223 1
a223 1
	if (statbuf->st_nlink != 1) {
@


1.15
log
@UUpdate ISC copyright year to 2004
Remove unused macros Skip_Line and MkLower
Remove trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.14 2004/06/03 18:41:58 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: database.c,v 1.14 2004/06/03 18:41:58 millert Exp $";
d112 2
a113 2
		if (!glue_strings(tabname, sizeof tabname, SPOOL_DIR,
				  fname, '/'))
@


1.14
log
@Though crontab files are created mode 0600 we should accept ones that
are mode 0400 too.  From Walt Howard.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.13 2003/03/15 00:39:01 millert Exp $	*/
d8 1
d15 7
a21 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: database.c,v 1.13 2003/03/15 00:39:01 millert Exp $";
d111 1
a111 1
		
@


1.13
log
@Use strlcpy() instead of pre-checking the src len and using strcpy()
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.12 2003/02/20 20:38:08 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: database.c,v 1.12 2003/02/20 20:38:08 millert Exp $";
d211 1
a211 1
	if ((statbuf->st_mode & 07777) != 0600) {
@


1.12
log
@Sync with ISC cron-current + my at(1) integration.
The at(1) code is now more tightly integrated into the cron codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.11 2002/08/10 20:28:51 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: database.c,v 1.11 2002/08/10 20:28:51 millert Exp $";
d109 1
a109 1
		if (strlen(dp->d_name) >= sizeof fname)
a110 1
		(void) strcpy(fname, dp->d_name);
@


1.11
log
@Just zero out pw_passwd in the pw_dup()'d copy.  There's no need
to do this elsewhere and my previous commit in this area caused
problems on systems with an /etc/crontab file.
@
text
@d1 2
a2 1
/*	$OpenBSD: database.c,v 1.10 2002/08/07 23:22:41 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: database.c,v 1.10 2002/08/07 23:22:41 millert Exp $";
d216 1
a216 1
	if (statbuf->st_uid != 0 && (pw == NULL ||
@


1.10
log
@paranoia: zero out pw_passwd since we don't need it
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.9 2002/08/04 22:10:24 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: database.c,v 1.9 2002/08/04 22:10:24 millert Exp $";
a194 1
	bzero(pw->pw_passwd, strlen(pw->pw_passwd));
@


1.9
log
@Extra paranoia -- check that pw_name matches the crontab user's name.
Should not really be needed since we do uid checks but it can't hurt.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.8 2002/08/02 22:40:48 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: database.c,v 1.8 2002/08/02 22:40:48 millert Exp $";
d195 1
@


1.8
log
@o Instead of passing "*system*" as the fname to process_crontab()
  for the system crontab file, pass a NULL pointer instead.  This
  prevents someone from creating a "*system*" file in the tabs directory
  that acts as an alternate root crontab.

o Fix the check for tab file ownership.  This really only affected
  the system crontab file, which must not be owned by root.

deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.7 2002/07/08 18:11:02 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: database.c,v 1.7 2002/07/08 18:11:02 millert Exp $";
d84 1
a84 1
		process_crontab("root", NULL, SYSCRONTAB, &syscron_stat,
d186 1
a186 1
		/* must be set to something.
d215 2
a216 1
	if (statbuf->st_uid != 0 && (!pw || statbuf->st_uid != pw->pw_uid)) {
@


1.7
log
@Merge in some changes from Paul Vixie's tree; most are cosmetic
o ANSI function headers
o return (foo) not return foo
o add -oi to sendmail flags
o update email address in man pages
o make some strings const
o completely remove globbing cruft from popen.c
o whitespace changes
o add DOW_STAR to flags for "monthly", "weekly", and "daily" cron entries
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.6 2002/05/09 21:22:01 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: database.c,v 1.6 2002/05/09 21:22:01 millert Exp $";
d84 1
a84 2
		process_crontab("root", "*system*",
				SYSCRONTAB, &syscron_stat,
d185 5
a189 1
	if (strcmp(fname, "*system*") != 0 && !(pw = getpwnam(uname))) {
d215 1
a215 1
	if (statbuf->st_uid != 0 && pw && statbuf->st_uid != pw->pw_uid) {
@


1.6
log
@crontab is no longer setuid root, it is now setgid crontab.
These changes were modelled after the Owl version of vixie-cron,
but developed independently.

Our crontab used to send cron SIGUSR1 to tell cron to reread the
spool dir.  Now that crontab is not setuid root this doesn't work.
Instead, crontab pokes cron via a Unix domain socket located in the
tabs dir.

Please note, after these changes, the owner on user crontab files
will have to be changed manually from root to the uid of the
corresponding user for crontab to be usable.  cron itself will accept
tab files owned by either root or the user.
Also, any /var/cron/{allow,deny} files must be readable by group crontab.
@
text
@d1 1
a1 1
/*	$OpenBSD: database.c,v 1.5 2001/02/18 19:48:33 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: database.c,v 1.5 2001/02/18 19:48:33 millert Exp $";
@


1.5
log
@Update to ISC cron 4.0b1 + our patches.  This is now under a BSD license.
I also fixed the signal handlers while I was at it.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: database.c,v 1.4 2000/01/02 20:53:40 vixie Exp $";
d193 1
a193 1
	if ((crontab_fd = open(tabname, O_RDONLY, 0)) < OK) {
d202 16
@


1.4
log
@snprintf sprinkles; solar@@false.com & I
@
text
@d1 1
d4 4
d9 3
a11 8
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
d13 8
a20 3
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@@vix.com>          uunet!decwrl!vixie!paul
d24 1
a24 1
static char rcsid[] = "$Id: database.c,v 1.3 1997/12/22 08:10:42 deraadt Exp $";
a29 1

a30 4
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/file.h>

a31 1
#define TMAX(a,b) ((a)>(b)?(a):(b))
d34 3
a36 4
static	void		process_crontab __P((char *, char *, char *,
					     struct stat *,
					     cron_db *, cron_db *));

d39 6
a44 9
load_database(old_db)
	cron_db		*old_db;
{
	DIR		*dir;
	struct stat	statbuf;
	struct stat	syscron_stat;
	DIR_T   	*dp;
	cron_db		new_db;
	user		*u, *nu;
d46 1
a46 1
	Debug(DLOAD, ("[%d] load_database()\n", getpid()))
d70 2
a71 2
		Debug(DLOAD, ("[%d] spool dir mtime unch, no load needed.\n",
			      getpid()))
d99 1
a99 2
		char	fname[MAXNAMLEN+1],
			tabname[MAXPATHLEN];
d109 2
d112 4
a115 1
		snprintf(tabname, sizeof tabname, CRON_TAB(fname));
a143 1

d145 1
a145 4
link_user(db, u)
	cron_db	*db;
	user	*u;
{
a154 1

d156 1
a156 4
unlink_user(db, u)
	cron_db	*db;
	user	*u;
{
a167 1

d169 2
a170 6
find_user(db, name)
	cron_db	*db;
	char	*name;
{
	char	*env_get();
	user	*u;
d173 1
a173 1
		if (!strcmp(u->name, name))
d175 1
a175 1
	return u;
a177 1

d179 2
a180 7
process_crontab(uname, fname, tabname, statbuf, new_db, old_db)
	char		*uname;
	char		*fname;
	char		*tabname;
	struct stat	*statbuf;
	cron_db		*new_db;
	cron_db		*old_db;
d182 3
a184 3
	struct passwd	*pw = NULL;
	int		crontab_fd = OK - 1;
	user		*u;
d186 1
a186 1
	if (strcmp(fname, "*system*") && !(pw = getpwnam(uname))) {
d236 1
a236 1
next_crontab:
@


1.3
log
@handle timing normally except when clock jumps between 1 and 3 hours. If it
jumps, attempt as best as possible to gaurantee that jobs DO run, but only
run ONCE; patch by thompson@@.tgsoft.com
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: database.c,v 1.2 1996/09/15 09:13:18 deraadt Exp $";
d116 1
a116 1
		sprintf(tabname, CRON_TAB(fname));
@


1.2
log
@enlarge buffer
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: database.c,v 1.1.1.1 1995/10/18 08:47:30 deraadt Exp $";
d33 1
a33 1

d74 1
a74 1
	if (old_db->mtime == TMAX(statbuf.st_mtime, syscron_stat.st_mtime)) {
d85 1
a85 1
	new_db.mtime = TMAX(statbuf.st_mtime, syscron_stat.st_mtime);
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: database.c,v 1.1.1.4 1994/01/20 02:47:20 jtc Exp $";
d105 1
a105 1
			tabname[MAXNAMLEN+1];
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
