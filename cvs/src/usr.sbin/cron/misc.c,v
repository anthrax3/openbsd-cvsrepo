head	1.71;
access;
symbols
	OPENBSD_6_2_BASE:1.71
	OPENBSD_6_1:1.71.0.8
	OPENBSD_6_1_BASE:1.71
	OPENBSD_6_0:1.71.0.4
	OPENBSD_6_0_BASE:1.71
	OPENBSD_5_9:1.71.0.2
	OPENBSD_5_9_BASE:1.71
	OPENBSD_5_8:1.55.0.6
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.46.0.8
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.46.0.6
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.44.0.6
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.4
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.2
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.42.0.4
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.39.0.10
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.6
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.39.0.4
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.2
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.38.0.2
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.37.0.8
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.37.0.6
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.37.0.4
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.36.0.2
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.33.0.2
	OPENBSD_3_6_BASE:1.33
	OPENBSD_3_5:1.27.0.4
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.71
date	2015.11.14.13.09.14;	author millert;	state Exp;
branches;
next	1.70;
commitid	KNISMJYcyEJqWs74;

1.70
date	2015.11.09.16.37.07;	author millert;	state Exp;
branches;
next	1.69;
commitid	ZJUG9DwHA5l6WcX2;

1.69
date	2015.11.06.23.47.42;	author millert;	state Exp;
branches;
next	1.68;
commitid	8eaJrEU7qiymGijK;

1.68
date	2015.11.04.20.28.17;	author millert;	state Exp;
branches;
next	1.67;
commitid	6N0oXtYc5KM1a7DW;

1.67
date	2015.11.04.14.47.02;	author millert;	state Exp;
branches;
next	1.66;
commitid	Q0NTVVjpQWPBGYew;

1.66
date	2015.10.31.12.19.41;	author millert;	state Exp;
branches;
next	1.65;
commitid	AJsPrwJ9fd3llOTq;

1.65
date	2015.10.31.12.14.16;	author millert;	state Exp;
branches;
next	1.64;
commitid	mULiWxUknwzu04t4;

1.64
date	2015.10.31.12.13.01;	author millert;	state Exp;
branches;
next	1.63;
commitid	tLnu94klbVSaYhr3;

1.63
date	2015.10.29.22.41.27;	author millert;	state Exp;
branches;
next	1.62;
commitid	XUZIZeIqHdm2HbHG;

1.62
date	2015.10.29.21.19.09;	author millert;	state Exp;
branches;
next	1.61;
commitid	djZhV8XSdvavOBvh;

1.61
date	2015.10.29.21.17.47;	author millert;	state Exp;
branches;
next	1.60;
commitid	D0tlL6lvqAOjlrO5;

1.60
date	2015.10.26.15.16.30;	author millert;	state Exp;
branches;
next	1.59;
commitid	e24e7qBO9dHlxEtO;

1.59
date	2015.10.26.14.27.41;	author millert;	state Exp;
branches;
next	1.58;
commitid	k893fgzG4z9i5qIx;

1.58
date	2015.10.25.21.30.11;	author millert;	state Exp;
branches;
next	1.57;
commitid	Z2UkA4v651dEbyJ1;

1.57
date	2015.10.23.18.42.55;	author tedu;	state Exp;
branches;
next	1.56;
commitid	XKGk51XvBaSkXmrX;

1.56
date	2015.10.06.14.58.37;	author tedu;	state Exp;
branches;
next	1.55;
commitid	DORRwC1MyrO1Yl4N;

1.55
date	2015.02.09.22.35.08;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	eGq01x6bjr83TVho;

1.54
date	2015.01.23.19.07.27;	author tedu;	state Exp;
branches;
next	1.53;
commitid	YJA2vmvfLuMfGdwZ;

1.53
date	2015.01.23.02.37.25;	author tedu;	state Exp;
branches;
next	1.52;
commitid	UGPHvhzwRtnjrF9O;

1.52
date	2015.01.23.01.01.06;	author tedu;	state Exp;
branches;
next	1.51;
commitid	kzBIhYnXdVeOLxgw;

1.51
date	2015.01.22.22.38.55;	author tedu;	state Exp;
branches;
next	1.50;
commitid	F47ioXLOlSmeY3jW;

1.50
date	2015.01.14.17.27.30;	author millert;	state Exp;
branches;
next	1.49;
commitid	jXmo2gNqOzD6QEsx;

1.49
date	2015.01.14.17.27.13;	author millert;	state Exp;
branches;
next	1.48;
commitid	DFl2K6Llc1m42RPv;

1.48
date	2014.10.26.22.16.16;	author guenther;	state Exp;
branches;
next	1.47;
commitid	VEsuFKmQ1pM1IHBT;

1.47
date	2014.08.15.03.51.40;	author guenther;	state Exp;
branches;
next	1.46;
commitid	ILfd29dGeQRUYnTr;

1.46
date	2013.04.21.00.14.51;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2013.04.17.15.58.45;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2011.08.22.19.32.42;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2011.07.09.14.49.14;	author dhill;	state Exp;
branches;
next	1.42;

1.42
date	2010.04.10.16.43.18;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2010.03.30.13.13.33;	author jacekm;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2008.01.05.16.59.06;	author chl;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.02.01.29.11;	author pvalchev;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.08.18.34.00;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.10.22.41.56;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.01.30.20.46.20;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2004.09.16.20.11.09;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.22.16.36.28;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2004.07.09.16.22.02;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.22.03.15.33;	author avsm;	state Exp;
branches;
next	1.30;

1.30
date	2004.06.17.22.11.55;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.13.14.10.10;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.10.12.14.54;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.15.08.08.45;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.20.20.38.08;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.20.19.12.16;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.18.02.25.39;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.08.18.17.50;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.15.19.13.29;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.09.18.59.12;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.08.18.11.02;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.28.02.03.01;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.28.01.20.19;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.22.18.17.53;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.22.16.39.39;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.09.22.14.16;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.09.21.53.17;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.09.21.40.41;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.09.21.22.01;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.12.19.02.50;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.20.02.03.19;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.19.14.33.33;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.18.19.48.35;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.21.21.08.57;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.08.06.20.41.07;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.07.10.08.06.34;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.03.30.06.59.45;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.12.17.02.17.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.11.01.23.27.37;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.30;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.71
log
@Remove log_it() and call syslog(3) directly using the same format:
"(username) WHAT (details)".  Logs due to normal operation (e.g.
crontab operations or running commands) are logged at LOG_INFO like
before.  Actual errors are logged at LOG_ERR, less important things
are logged at LOG_WARNING OR LOG_NOTICE.  Also ignore SIGHUP now
that there is no log file to reopen.
@
text
@/*	$OpenBSD: misc.c,v 1.70 2015/11/09 16:37:07 millert Exp $	*/

/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
 * Copyright (c) 1997,2000 by Internet Software Consortium, Inc.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/wait.h>

#include <bitstring.h>		/* for structs.h */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>		/* for structs.h */

#include "macros.h"
#include "structs.h"
#include "funcs.h"
#include "globals.h"

int LineNumber;

/* get_char(file) : like getc() but increment LineNumber on newlines
 */
int
get_char(FILE *file)
{
	int ch;

	ch = getc(file);
	if (ch == '\n')
		Set_LineNum(LineNumber + 1)
	return (ch);
}

/* unget_char(ch, file) : like ungetc but do LineNumber processing
 */
void
unget_char(int ch, FILE *file)
{
	ungetc(ch, file);
	if (ch == '\n')
		Set_LineNum(LineNumber - 1)
}

/* get_string(str, max, file, termstr) : like fgets() but
 *		(1) has terminator string which should include \n
 *		(2) will always leave room for the null
 *		(3) uses get_char() so LineNumber will be accurate
 *		(4) returns EOF or terminating character, whichever
 */
int
get_string(char *string, int size, FILE *file, char *terms)
{
	int ch;

	while (EOF != (ch = get_char(file)) && !strchr(terms, ch)) {
		if (size > 1) {
			*string++ = ch;
			size--;
		}
	}

	if (size > 0)
		*string = '\0';

	return (ch);
}

/* skip_comments(file) : read past comment (if any)
 */
void
skip_comments(FILE *file)
{
	int ch;

	while (EOF != (ch = get_char(file))) {
		/* ch is now the first character of a line.
		 */

		while (ch == ' ' || ch == '\t')
			ch = get_char(file);

		if (ch == EOF)
			break;

		/* ch is now the first non-blank character of a line.
		 */

		if (ch != '\n' && ch != '#')
			break;

		/* ch must be a newline or comment as first non-blank
		 * character on a line.
		 */

		while (ch != '\n' && ch != EOF)
			ch = get_char(file);

		/* ch is now the newline of a line which we're going to
		 * ignore.
		 */
	}
	if (ch != EOF)
		unget_char(ch, file);
}

/* char *first_word(char *s, char *t)
 *	return pointer to first word
 * parameters:
 *	s - string we want the first word of
 *	t - terminators, implicitly including \0
 * warnings:
 *	(1) this routine is fairly slow
 *	(2) it returns a pointer to static storage
 */
char *
first_word(char *s, char *t)
{
	static char retbuf[2][MAX_TEMPSTR + 1];	/* sure wish C had GC */
	static int retsel = 0;
	char *rb, *rp;

	/* select a return buffer */
	retsel = 1-retsel;
	rb = &retbuf[retsel][0];
	rp = rb;

	/* skip any leading terminators */
	while (*s && (NULL != strchr(t, *s))) {
		s++;
	}

	/* copy until next terminator or full buffer */
	while (*s && (NULL == strchr(t, *s)) && (rp < &rb[MAX_TEMPSTR])) {
		*rp++ = *s++;
	}

	/* finish the return-string and return it */
	*rp = '\0';
	return (rb);
}
@


1.70
log
@Remove unused xpid argument to log_it().
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.69 2015/11/06 23:47:42 millert Exp $	*/
a26 1
#include <syslog.h>
a33 1
static int syslog_open = FALSE;
a118 27
}

void
log_it(const char *username, const char *event, const char *detail)
{
	char **info, *info_events[] = { "CMD", "ATJOB", "BEGIN EDIT", "DELETE",
	    "END EDIT", "LIST", "MAIL", "RELOAD", "REPLACE", "STARTUP", NULL };

	if (!syslog_open) {
		openlog(__progname, LOG_PID, LOG_CRON);
		syslog_open = TRUE;		/* assume openlog success */
	}

	for (info = info_events; *info; info++)
		if (!strcmp(event, *info))
			break;
	syslog(*info ? LOG_INFO : LOG_WARNING, "(%s) %s (%s)", username, event,
	    detail);
}

void
log_close(void)
{
	if (syslog_open) {
		closelog();
		syslog_open = FALSE;
	}
@


1.69
log
@Use __progname instead of the homegrown ProgramName.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.68 2015/11/04 20:28:17 millert Exp $	*/
d124 1
a124 1
log_it(const char *username, pid_t xpid, const char *event, const char *detail)
@


1.68
log
@Change cron from including all headers in every file to only including
what each .c file needs.  I have not removed cron.h since it will
be used in a future clean up of the cron's .h files.  OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.67 2015/11/04 14:47:02 millert Exp $	*/
d36 1
d130 1
a130 1
		openlog(ProgramName, LOG_PID, LOG_CRON);
d144 4
a147 2
	closelog();
	syslog_open = FALSE;
@


1.67
log
@Remove unused LogFD variable
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.66 2015/10/31 12:19:41 millert Exp $	*/
d20 14
a33 1
#include "cron.h"
a137 2


@


1.66
log
@Split client-only (at, crontab) functions out of misc.c and into
client.c.  Move truly common functions into common.c.  This avoids
dead code in the at and crontab commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.65 2015/10/31 12:14:16 millert Exp $	*/
a21 1
static int LogFD = -1;
a131 4
	if (LogFD != -1) {
		close(LogFD);
		LogFD = -1;
	}
@


1.65
log
@open_socket() is only used by cron proper so move to cron.c
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.64 2015/10/31 12:13:01 millert Exp $	*/
a24 82
void
set_cron_cwd(void)
{
	struct stat sb;
	struct group *grp = NULL;

	grp = getgrnam(CRON_GROUP);
	/* first check for CRONDIR ("/var/cron" or some such)
	 */
	if (stat(CRONDIR, &sb) < 0 && errno == ENOENT) {
		perror(CRONDIR);
		if (0 == mkdir(CRONDIR, 0710)) {
			fprintf(stderr, "%s: created\n", CRONDIR);
			stat(CRONDIR, &sb);
		} else {
			fprintf(stderr, "%s: ", CRONDIR);
			perror("mkdir");
			exit(EXIT_FAILURE);
		}
	}
	if (!S_ISDIR(sb.st_mode)) {
		fprintf(stderr, "'%s' is not a directory, bailing out.\n",
			CRONDIR);
		exit(EXIT_FAILURE);
	}
	if (chdir(CRONDIR) < 0) {
		fprintf(stderr, "cannot chdir(%s), bailing out.\n", CRONDIR);
		perror(CRONDIR);
		exit(EXIT_FAILURE);
	}

	/* CRONDIR okay (now==CWD), now look at SPOOL_DIR ("tabs" or some such)
	 */
	if (stat(SPOOL_DIR, &sb) < 0 && errno == ENOENT) {
		perror(SPOOL_DIR);
		if (0 == mkdir(SPOOL_DIR, 0700)) {
			fprintf(stderr, "%s: created\n", SPOOL_DIR);
			stat(SPOOL_DIR, &sb);
		} else {
			fprintf(stderr, "%s: ", SPOOL_DIR);
			perror("mkdir");
			exit(EXIT_FAILURE);
		}
	}
	if (!S_ISDIR(sb.st_mode)) {
		fprintf(stderr, "'%s' is not a directory, bailing out.\n",
			SPOOL_DIR);
		exit(EXIT_FAILURE);
	}
	if (grp != NULL) {
		if (sb.st_gid != grp->gr_gid)
			chown(SPOOL_DIR, -1, grp->gr_gid);
		if (sb.st_mode != 01730)
			chmod(SPOOL_DIR, 01730);
	}

	/* finally, look at AT_DIR ("atjobs" or some such)
	 */
	if (stat(AT_DIR, &sb) < 0 && errno == ENOENT) {
		perror(AT_DIR);
		if (0 == mkdir(AT_DIR, 0700)) {
			fprintf(stderr, "%s: created\n", AT_DIR);
			stat(AT_DIR, &sb);
		} else {
			fprintf(stderr, "%s: ", AT_DIR);
			perror("mkdir");
			exit(EXIT_FAILURE);
		}
	}
	if (!S_ISDIR(sb.st_mode)) {
		fprintf(stderr, "'%s' is not a directory, bailing out.\n",
			AT_DIR);
		exit(EXIT_FAILURE);
	}
	if (grp != NULL) {
		if (sb.st_gid != grp->gr_gid)
			chown(AT_DIR, -1, grp->gr_gid);
		if (sb.st_mode != 01770)
			chmod(AT_DIR, 01770);
	}
}

a109 51
/* int in_file(const char *string, FILE *file, int error)
 *	return TRUE if one of the lines in file matches string exactly,
 *	FALSE if no lines match, and error on error.
 */
static int
in_file(const char *string, FILE *file, int error)
{
	char line[MAX_TEMPSTR];
	char *endp;

	if (fseek(file, 0L, SEEK_SET))
		return (error);
	while (fgets(line, MAX_TEMPSTR, file)) {
		if (line[0] != '\0') {
			endp = &line[strlen(line) - 1];
			if (*endp != '\n')
				return (error);
			*endp = '\0';
			if (0 == strcmp(line, string))
				return (TRUE);
		}
	}
	if (ferror(file))
		return (error);
	return (FALSE);
}

/* int allowed(const char *username, const char *allow_file, const char *deny_file)
 *	returns TRUE if (allow_file exists and user is listed)
 *	or (deny_file exists and user is NOT listed).
 *	root is always allowed.
 */
int
allowed(const char *username, const char *allow_file, const char *deny_file)
{
	FILE	*fp;
	int	isallowed;

	if (strcmp(username, "root") == 0)
		return (TRUE);
	isallowed = FALSE;
	if ((fp = fopen(allow_file, "r")) != NULL) {
		isallowed = in_file(username, fp, FALSE);
		fclose(fp);
	} else if ((fp = fopen(deny_file, "r")) != NULL) {
		isallowed = !in_file(username, fp, FALSE);
		fclose(fp);
	}
	return (isallowed);
}

a174 41
}

void
poke_daemon(const char *spool_dir, unsigned char cookie)
{
	int sock = -1;
	struct sockaddr_un s_un;

	(void) utime(spool_dir, NULL);		/* old poke method */

	bzero(&s_un, sizeof(s_un));
	if (snprintf(s_un.sun_path, sizeof s_un.sun_path, "%s/%s",
	      SPOOL_DIR, CRONSOCK) >= sizeof(s_un.sun_path)) {
		fprintf(stderr, "%s: %s/%s: path too long\n",
		    ProgramName, SPOOL_DIR, CRONSOCK);
		return;
	}
	s_un.sun_family = AF_UNIX;
	s_un.sun_len = SUN_LEN(&s_un);
	(void) signal(SIGPIPE, SIG_IGN);
	if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    connect(sock, (struct sockaddr *)&s_un, sizeof(s_un)) == 0)
		write(sock, &cookie, 1);
	else
		fprintf(stderr, "%s: warning, cron does not appear to be "
		    "running.\n", ProgramName);
	if (sock >= 0)
		close(sock);
	(void) signal(SIGPIPE, SIG_DFL);
}

int
strtot(const char *nptr, char **endptr, time_t *tp)
{
	long long ll;

	ll = strtoll(nptr, endptr, 10);
	if (ll < 0 || (time_t)ll != ll)
		return (-1);
	*tp = (time_t)ll;
	return (0);
@


1.64
log
@swap_gids and swap_gids_back are only used by crontab.c so
move them there.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.63 2015/10/29 22:41:27 millert Exp $	*/
a307 56
}

/* int open_socket(void)
 *	opens a UNIX domain socket that crontab uses to poke cron.
 *	If the socket is already in use, return an error.
 */
int
open_socket(void)
{
	int		   sock;
	mode_t		   omask;
	struct sockaddr_un s_un;

	sock = socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0);
	if (sock == -1) {
		fprintf(stderr, "%s: can't create socket: %s\n",
		    ProgramName, strerror(errno));
		log_it("CRON", getpid(), "DEATH", "can't create socket");
		exit(EXIT_FAILURE);
	}
	bzero(&s_un, sizeof(s_un));
	if (snprintf(s_un.sun_path, sizeof s_un.sun_path, "%s/%s",
	      SPOOL_DIR, CRONSOCK) >= sizeof(s_un.sun_path)) {
		fprintf(stderr, "%s/%s: path too long\n", SPOOL_DIR, CRONSOCK);
		log_it("CRON", getpid(), "DEATH", "path too long");
		exit(EXIT_FAILURE);
	}
	s_un.sun_family = AF_UNIX;
	s_un.sun_len = SUN_LEN(&s_un);

	if (connect(sock, (struct sockaddr *)&s_un, sizeof(s_un)) == 0) {
		fprintf(stderr, "%s: already running\n", ProgramName);
		log_it("CRON", getpid(), "DEATH", "already running");
		exit(EXIT_FAILURE);
	}
	if (errno != ENOENT)
		unlink(s_un.sun_path);

	omask = umask(007);
	if (bind(sock, (struct sockaddr *)&s_un, sizeof(s_un))) {
		fprintf(stderr, "%s: can't bind socket: %s\n",
		    ProgramName, strerror(errno));
		log_it("CRON", getpid(), "DEATH", "can't bind socket");
		umask(omask);
		exit(EXIT_FAILURE);
	}
	umask(omask);
	if (listen(sock, SOMAXCONN)) {
		fprintf(stderr, "%s: can't listen on socket: %s\n",
		    ProgramName, strerror(errno));
		log_it("CRON", getpid(), "DEATH", "can't listen on socket");
		exit(EXIT_FAILURE);
	}
	chmod(s_un.sun_path, 0660);

	return(sock);
@


1.63
log
@Use stravis(3) instead of a homegrown vis-like function.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.62 2015/10/29 21:19:09 millert Exp $	*/
a308 11

static gid_t save_egid;
int swap_gids() { save_egid = getegid(); return (setegid(getgid())); }
int swap_gids_back() { return (setegid(save_egid)); }

/* Return the offset from GMT in seconds (algorithm taken from sendmail).
 *
 * warning:
 *	clobbers the static storage space used by localtime() and gmtime().
 *	If the local pointer is non-NULL it *must* point to a local copy.
 */
@


1.62
log
@Convert env_get() into env_find() similar to __findenv() in libc.
Use env_find() in both env_get() and env_set() to find a var in envp.
Remove now-unused strcmp_until() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.60 2015/10/26 15:16:30 millert Exp $	*/
a308 51

/* warning:
 *	heavily ascii-dependent.
 */
void
mkprint(dst, src, len)
	char *dst;
	unsigned char *src;
	int len;
{
	/*
	 * XXX
	 * We know this routine can't overflow the dst buffer because mkprints()
	 * allocated enough space for the worst case.
	 */
	while (len-- > 0)
	{
		unsigned char ch = *src++;

		if (ch < ' ') {			/* control character */
			*dst++ = '^';
			*dst++ = ch + '@@';
		} else if (ch < 0177) {		/* printable */
			*dst++ = ch;
		} else if (ch == 0177) {	/* delete/rubout */
			*dst++ = '^';
			*dst++ = '?';
		} else {			/* parity character */
			snprintf(dst, 5, "\\%03o", ch);
			dst += strlen(dst);
		}
	}
	*dst = '\0';
}

/* warning:
 *	returns a pointer to malloc'd storage, you must call free yourself.
 */
char *
mkprints(src, len)
	unsigned char *src;
	unsigned int len;
{
	char *dst = malloc(len*4 + 1);

	if (dst)
		mkprint(dst, src, len);

	return (dst);
}

@


1.61
log
@Remove useless FACILITY define and use LOG_CRON directly.
Remove unneeded limits.h include.
@
text
@a24 15
int
strcmp_until(const char *left, const char *right, char until)
{
	while (*left && *left != until && *left == *right) {
		left++;
		right++;
	}

	if ((*left=='\0' || *left == until) &&
	    (*right=='\0' || *right == until)) {
		return (0);
	}
	return (*left - *right);
}

@


1.60
log
@Use SOCK_NONBLOCK and SOCK_CLOEXEC instead of fcntl() calls.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.59 2015/10/26 14:27:41 millert Exp $	*/
a20 9
#include <limits.h>

#if defined(LOG_DAEMON) && !defined(LOG_CRON)
# define LOG_CRON LOG_DAEMON
#endif

#ifndef FACILITY
#define FACILITY LOG_CRON
#endif
a22 1

d265 1
a265 1
		openlog(ProgramName, LOG_PID, FACILITY);
@


1.59
log
@Remove some useless defines and the set_cron_uid() function.
OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.58 2015/10/25 21:30:11 millert Exp $	*/
d408 1
a408 1
	sock = socket(AF_UNIX, SOCK_STREAM, 0);
a412 14
		exit(EXIT_FAILURE);
	}
	if (fcntl(sock, F_SETFD, FD_CLOEXEC) == -1) {
		fprintf(stderr, "%s: can't make socket close on exec: %s\n",
		    ProgramName, strerror(errno));
		log_it("CRON", getpid(), "DEATH",
		    "can't make socket close on exec");
		exit(EXIT_FAILURE);
	}
	if (fcntl(sock, F_SETFL, O_NONBLOCK) == -1) {
		fprintf(stderr, "%s: can't make socket non-blocking: %s\n",
		    ProgramName, strerror(errno));
		log_it("CRON", getpid(), "DEATH",
		    "can't make socket non-blocking");
@


1.58
log
@Remove cron.pid support.  We still want to avoid multiple crons
running so verify that if the cron socket exists nothing is listening
on it.  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.57 2015/10/23 18:42:55 tedu Exp $	*/
a50 9
set_cron_uid(void)
{
	if (seteuid(ROOT_UID) < 0) {
		perror("seteuid");
		exit(EXIT_FAILURE);
	}
}

void
d255 1
a255 1
	if (strcmp(username, ROOT_USER) == 0)
@


1.57
log
@remove some more ifdef maziness
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.56 2015/10/06 14:58:37 tedu Exp $	*/
a140 87
/* acquire_daemonlock() - write our PID into /var/run/cron.pid, unless
 *	another daemon is already running, which we detect here.
 *
 * note: main() calls us twice; once before forking, once after.
 *	we maintain static storage of the file pointer so that we
 *	can rewrite our PID into _PATH_CRON_PID after the fork.
 */
void
acquire_daemonlock(int closeflag)
{
	static int fd = -1;
	char buf[3*MAX_FNAME];
	const char *pidfile;
	char *ep;
	long otherpid;
	ssize_t num;

	if (closeflag) {
		/* close stashed fd for child so we don't leak it. */
		if (fd != -1) {
			close(fd);
			fd = -1;
		}
		return;
	}

	if (fd == -1) {
		pidfile = _PATH_CRON_PID;
		fd = open(pidfile,
		    O_RDWR|O_CREAT|O_EXLOCK|O_NONBLOCK|O_CLOEXEC, 0644);
		if (fd == -1) {
			int save_errno = errno;

			if (errno != EWOULDBLOCK)  {
				snprintf(buf, sizeof buf,
				    "can't open or create %s: %s", pidfile,
				    strerror(save_errno));
				fprintf(stderr, "%s: %s\n", ProgramName, buf);
				log_it("CRON", getpid(), "DEATH", buf);
				exit(EXIT_FAILURE);
			}

			/* couldn't lock the pid file, try to read existing. */
			bzero(buf, sizeof(buf));
			if ((fd = open(pidfile, O_RDONLY, 0)) >= 0 &&
			    (num = read(fd, buf, sizeof(buf) - 1)) > 0 &&
			    (otherpid = strtol(buf, &ep, 10)) > 0 &&
			    ep != buf && *ep == '\n' && otherpid != LONG_MAX) {
				snprintf(buf, sizeof buf,
				    "can't lock %s, otherpid may be %ld: %s",
				    pidfile, otherpid, strerror(save_errno));
			} else {
				snprintf(buf, sizeof buf,
				    "can't lock %s, otherpid unknown: %s",
				    pidfile, strerror(save_errno));
			}
			fprintf(stderr, "%s: %s\n", ProgramName, buf);
			log_it("CRON", getpid(), "DEATH", buf);
			exit(EXIT_FAILURE);
		}
		/* fd must be > STDERR_FILENO since we dup fd 0-2 to /dev/null */
		if (fd <= STDERR_FILENO) {
			int newfd;

			newfd = fcntl(fd, F_DUPFD_CLOEXEC, STDERR_FILENO + 1);
			if (newfd < 0) {
				snprintf(buf, sizeof buf,
				    "can't dup pid fd: %s", strerror(errno));
				fprintf(stderr, "%s: %s\n", ProgramName, buf);
				log_it("CRON", getpid(), "DEATH", buf);
				exit(EXIT_FAILURE);
			}
			close(fd);
			fd = newfd;
		}
	}

	snprintf(buf, sizeof(buf), "%ld\n", (long)getpid());
	(void) lseek(fd, 0, SEEK_SET);
	num = write(fd, buf, strlen(buf));
	(void) ftruncate(fd, num);

	/* abandon fd even though the file is open. we need to keep
	 * it open and locked, but we don't need the handles elsewhere.
	 */
}

d406 1
a406 1
/* void open_socket(void)
d408 1
a444 1
	unlink(s_un.sun_path);
d447 8
@


1.56
log
@clear out some more legacy code and whatnot
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.55 2015/02/09 22:35:08 deraadt Exp $	*/
a64 1
#ifdef CRON_GROUP
a65 1
#endif
a480 35
#ifdef MAIL_DATE
/* Sat, 27 Feb 1993 11:44:51 -0800 (CST)
 * 1234567890123456789012345678901234567
 */
char *
arpadate(clock)
	time_t *clock;
{
	time_t t = clock ? *clock : time(NULL);
	struct tm *tm = localtime(&t);
	static char ret[64];	/* zone name might be >3 chars */
	char *qmark;
	size_t len;
	long gmtoff = get_gmtoff(&t, tm);
	int hours = gmtoff / 3600;
	int minutes = (gmtoff - (hours * 3600)) / 60;

	if (minutes < 0)
		minutes = -minutes;

	/* Defensive coding (almost) never hurts... */
	len = strftime(ret, sizeof(ret), "%a, %e %b %Y %T ????? (%Z)", tm);
	if (len == 0) {
		ret[0] = '?';
		ret[1] = '\0';
		return (ret);
	}
	qmark = strchr(ret, '?');
	if (qmark && len - (qmark - ret) >= 6) {
		snprintf(qmark, 6, "% .2d%.2d", hours, minutes);
		qmark[5] = ' ';
	}
	return (ret);
}
#endif /*MAIL_DATE*/
a532 1
#ifdef SUN_LEN
a533 1
#endif
a570 1
#ifdef SUN_LEN
a571 1
#endif
@


1.55
log
@correct copyright, upon approval from paul vixie via todd miller.  the
head copyright assertion was seperated from the remaining ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.54 2015/01/23 19:07:27 tedu Exp $	*/
a19 4
/* vix 26jan87 [RCS has the rest of the log]
 * vix 30dec86 [written]
 */

a22 4
#if defined(SYSLOG) && defined(LOG_FILE)
# undef LOG_FILE
#endif

a32 1
#if defined(SYSLOG)
a33 1
#endif
a368 10
#if defined(LOG_FILE) || DEBUGGING
	pid_t pid = xpid;
#endif
#if defined(LOG_FILE)
	char *msg;
	size_t msglen;
	time_t now = time(NULL);
	struct tm *t = localtime(&now);
#endif /*LOG_FILE*/
#if defined(SYSLOG)
a370 35
#endif /*SYSLOG*/

#if defined(LOG_FILE)
	/* we assume that MAX_TEMPSTR will hold the date, time, &punctuation.
	 */
	msglen = strlen(username) + strlen(event) + strlen(detail) +
	    MAX_TEMPSTR;
	if ((msg = malloc(msglen)) == NULL)
		return;

	if (LogFD < 0) {
		LogFD = open(LOG_FILE, O_WRONLY|O_APPEND|O_CREAT|O_CLOEXEC,
		    0600);
		if (LogFD < 0) {
			fprintf(stderr, "%s: can't open log file\n",
				ProgramName);
			perror(LOG_FILE);
		}
	}

	/* we have to snprintf() it because fprintf() doesn't always write
	 * everything out in one chunk and this has to be atomically appended
	 * to the log file.
	 */
	snprintf(msg, msglen, "%s (%02d/%02d-%02d:%02d:%02d-%ld) %s (%s)\n",
		username,
		t->tm_mon+1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec,
		(long)pid, event, detail);

	if (LogFD < 0 || write(LogFD, msg, strlen(msg)) < 0) {
		if (LogFD >= 0)
			perror(LOG_FILE);
		fprintf(stderr, "%s: can't write to log file\n", ProgramName);
		write(STDERR_FILENO, msg, strlen(msg));
	}
a371 4
	free(msg);
#endif /*LOG_FILE*/

#if defined(SYSLOG)
a382 1
#endif /*SYSLOG*/
a392 1
#if defined(SYSLOG)
a394 1
#endif /*SYSLOG*/
a528 27
#ifndef HAVE_TM_GMTOFF
long get_gmtoff(time_t *clock, struct tm *local)
{
	struct tm gmt;
	long offset;

	gmt = *gmtime(clock);
	if (local == NULL)
		local = localtime(clock);

	offset = (local->tm_sec - gmt.tm_sec) +
	    ((local->tm_min - gmt.tm_min) * 60) +
	    ((local->tm_hour - gmt.tm_hour) * 3600);

	/* Timezone may cause year rollover to happen on a different day. */
	if (local->tm_year < gmt.tm_year)
		offset -= 24 * 3600;
	else if (local->tm_year > gmt.tm_year)
		offset += 24 * 3600;
	else if (local->tm_yday < gmt.tm_yday)
		offset -= 24 * 3600;
	else if (local->tm_yday > gmt.tm_yday)
		offset += 24 * 3600;

	return (offset);
}
#endif /* HAVE_TM_GMTOFF */
@


1.54
log
@braces to open a function go on their own line like god intended
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.53 2015/01/23 02:37:25 tedu Exp $	*/
a3 4
 * All rights reserved
 */

/*
@


1.53
log
@Remove the OK and ERR macros. They obfuscate the code and don't
help legibility. (unix system calls use 0 for ok, but hundreds of
other projects use 1 to indicate success.) Despite the name, many
system calls (e.g., open) also return not OK values for success.
It also cleans up some weird code like int crontab_fd = OK - 1;
This diff is mechanical in nature. Later I will fix the bugs it reveals.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.52 2015/01/23 01:01:06 tedu Exp $	*/
d50 2
a51 1
strcmp_until(const char *left, const char *right, char until) {
d65 2
a66 1
set_cron_uid(void) {
d74 2
a75 1
set_cron_cwd(void) {
d165 2
a166 1
acquire_daemonlock(int closeflag) {
d247 2
a248 1
get_char(FILE *file) {
d260 2
a261 1
unget_char(int ch, FILE *file) {
d274 2
a275 1
get_string(char *string, int size, FILE *file, char *terms) {
d294 2
a295 1
skip_comments(FILE *file) {
d362 2
a363 1
allowed(const char *username, const char *allow_file, const char *deny_file) {
d381 2
a382 1
log_it(const char *username, pid_t xpid, const char *event, const char *detail) {
d451 2
a452 1
log_close(void) {
d473 2
a474 1
first_word(char *s, char *t) {
d688 2
a689 1
poke_daemon(const char *spool_dir, unsigned char cookie) {
@


1.52
log
@remove debug code.
I think the level of debug code in cron is excessive for a program
that has reached feature complete. If cron needs to provide more
information to the user about its operational status, I think syslog
would be more appropriate. (The debug flags also disable forking
into the background, so they aren't even that useful for debugging a
live system.)
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.51 2015/01/22 22:38:55 tedu Exp $	*/
d43 1
a43 1
static int LogFD = ERR;
d65 1
a65 1
	if (seteuid(ROOT_UID) < OK) {
d81 1
a81 1
	if (stat(CRONDIR, &sb) < OK && errno == ENOENT) {
d83 1
a83 1
		if (OK == mkdir(CRONDIR, 0710)) {
d97 1
a97 1
	if (chdir(CRONDIR) < OK) {
d105 1
a105 1
	if (stat(SPOOL_DIR, &sb) < OK && errno == ENOENT) {
d107 1
a107 1
		if (OK == mkdir(SPOOL_DIR, 0700)) {
d130 1
a130 1
	if (stat(AT_DIR, &sb) < OK && errno == ENOENT) {
d132 1
a132 1
		if (OK == mkdir(AT_DIR, 0700)) {
d395 1
a395 1
	if (LogFD < OK) {
d398 1
a398 1
		if (LogFD < OK) {
d414 2
a415 2
	if (LogFD < OK || write(LogFD, msg, strlen(msg)) < OK) {
		if (LogFD >= OK)
d442 1
a442 1
	if (LogFD != ERR) {
d444 1
a444 1
		LogFD = ERR;
@


1.51
log
@delete useless casts. ok deraadt guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.50 2015/01/14 17:27:30 millert Exp $	*/
a62 63
int
set_debug_flags(const char *flags) {
	/* debug flags are of the form    flag[,flag ...]
	 *
	 * if an error occurs, print a message to stdout and return FALSE.
	 * otherwise return TRUE after setting ERROR_FLAGS.
	 */

#if !DEBUGGING

	printf("this program was compiled without debugging enabled\n");
	return (FALSE);

#else /* DEBUGGING */

	const char *pc = flags;

	DebugFlags = 0;

	while (*pc) {
		const char	**test;
		int		mask;

		/* try to find debug flag name in our list.
		 */
		for (test = DebugFlagNames, mask = 1;
		     *test != NULL && strcmp_until(*test, pc, ',');
		     test++, mask <<= 1)
			continue;

		if (!*test) {
			fprintf(stderr,
				"unrecognized debug flag <%s> <%s>\n",
				flags, pc);
			return (FALSE);
		}

		DebugFlags |= mask;

		/* skip to the next flag
		 */
		while (*pc && *pc != ',')
			pc++;
		if (*pc == ',')
			pc++;
	}

	if (DebugFlags) {
		int flag;

		fprintf(stderr, "debug flags enabled:");

		for (flag = 0;  DebugFlagNames[flag];  flag++)
			if (DebugFlags & (1 << flag))
				fprintf(stderr, " %s", DebugFlagNames[flag]);
		fprintf(stderr, "\n");
	}

	return (TRUE);

#endif /* DEBUGGING */
}

a437 6
#if DEBUGGING
	if (DebugFlags) {
		fprintf(stderr, "log_it: (%s %ld) %s (%s)\n",
			username, (long)pid, event, detail);
	}
#endif
@


1.50
log
@Use standard types for wait, readdir, signals and pids.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.49 2015/01/14 17:27:13 millert Exp $	*/
d294 1
a294 1
	(void) lseek(fd, (off_t)0, SEEK_SET);
d296 1
a296 1
	(void) ftruncate(fd, (off_t)num);
d336 1
a336 1
			*string++ = (char) ch;
@


1.49
log
@Remove compatibility defines for ancient systems.  We assume a
reasonable level of POSIX compliance.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.48 2014/10/26 22:16:16 guenther Exp $	*/
d435 1
a435 1
log_it(const char *username, PID_T xpid, const char *event, const char *detail) {
d437 1
a437 1
	PID_T pid = xpid;
@


1.48
log
@Use socket(SOCK_CLOEXEC), open(O_CLOEXEC), and fcntl(F_DUPFD_CLOEXEC)
instead of calling fcntl(F_SETFD) later.

ok otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.47 2014/08/15 03:51:40 guenther Exp $	*/
a127 1
#if defined(BSD) || defined(POSIX)
a131 6
#else
	if (setuid(ROOT_UID) < OK) {
		perror("setuid");
		exit(EXIT_FAILURE);
	}
#endif
a488 1
# ifdef LOG_DAEMON
a489 3
# else
		openlog(ProgramName, LOG_PID);
# endif
a641 1
#ifdef HAVE_SAVED_UIDS
a644 4
#else /*HAVE_SAVED_UIDS*/
int swap_gids() { return (setregid(getegid(), getgid())); }
int swap_gids_back() { return (swap_gids()); }
#endif /*HAVE_SAVED_UIDS*/
@


1.47
log
@Use O_CLOEXEC wherever we open a file and then call fcntl(F_SETFD, FD_CLOEXEC)
on it, simplifying error checking, reducing system calls, and improving
thread-safety for libraries.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.46 2013/04/21 00:14:51 tedu Exp $	*/
d251 3
a253 2
		if ((fd = open(pidfile, O_RDWR|O_CREAT|O_EXLOCK|O_NONBLOCK,
		    0644)) == -1) {
d285 4
a288 1
			if (dup2(fd, STDERR_FILENO + 1) < 0) {
d296 1
a296 1
			fd = STDERR_FILENO + 1;
a297 1
		(void) fcntl(fd, F_SETFD, FD_CLOEXEC);
@


1.46
log
@cleaner and easier to use signed long long. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.45 2013/04/17 15:58:45 deraadt Exp $	*/
d463 2
a464 1
		LogFD = open(LOG_FILE, O_WRONLY|O_APPEND|O_CREAT, 0600);
a468 2
		} else {
			(void) fcntl(LogFD, F_SETFD, FD_CLOEXEC);
@


1.45
log
@Adapt cron and at for future large time_t and tv_sec types.  These were some
of the harder programs to adapt, so let me know if problems happen.
tested by guenther, gilles, chl, others
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.44 2011/08/22 19:32:42 millert Exp $	*/
d791 1
a791 1
	unsigned long long ull;
d793 2
a794 2
	ull = strtoull(nptr, endptr, 10);
	if ((time_t)ull < 0 || (time_t)ull != ull)
d796 1
a796 1
	*tp = (time_t)ull;
@


1.44
log
@Use standard EXIT_SUCCESS/EXIT_FAILURE and STD{IN,OUT,ERR}_FILENO
defines instead of using custom macros.  OK deraadt@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.43 2011/07/09 14:49:14 dhill Exp $	*/
d446 1
a446 1
	TIME_T now = time((TIME_T) 0);
d786 12
@


1.43
log
@use FD_CLOEXEC instead of 1.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.42 2010/04/10 16:43:18 millert Exp $	*/
d131 1
a131 1
		exit(ERROR_EXIT);
d136 1
a136 1
		exit(ERROR_EXIT);
d159 1
a159 1
			exit(ERROR_EXIT);
d165 1
a165 1
		exit(ERROR_EXIT);
d170 1
a170 1
		exit(ERROR_EXIT);
d183 1
a183 1
			exit(ERROR_EXIT);
d189 1
a189 1
		exit(ERROR_EXIT);
d208 1
a208 1
			exit(ERROR_EXIT);
d214 1
a214 1
		exit(ERROR_EXIT);
d224 1
a224 1
/* acquire_daemonlock() - write our PID into /etc/cron.pid, unless
d261 1
a261 1
				exit(ERROR_EXIT);
d280 1
a280 1
			exit(ERROR_EXIT);
d282 3
a284 3
		/* fd must be > STDERR since we dup fd 0-2 to /dev/null */
		if (fd <= STDERR) {
			if (dup2(fd, STDERR + 1) < 0) {
d289 1
a289 1
				exit(ERROR_EXIT);
d292 1
a292 1
			fd = STDERR + 1;
d486 1
a486 1
		write(STDERR, msg, strlen(msg));
d709 1
a709 1
		exit(ERROR_EXIT);
d716 1
a716 1
		exit(ERROR_EXIT);
d723 1
a723 1
		exit(ERROR_EXIT);
d730 1
a730 1
		exit(ERROR_EXIT);
d744 1
a744 1
		exit(ERROR_EXIT);
d751 1
a751 1
		exit(ERROR_EXIT);
@


1.42
log
@Fix bug in GMT calculation for systems without tm_gmtoff.
From Javier Fernandez-Sanguino Pena
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.41 2010/03/30 13:13:33 jacekm Exp $	*/
d294 1
a294 1
		(void) fcntl(fd, F_SETFD, 1);
d469 1
a469 1
			(void) fcntl(LogFD, F_SETFD, 1);
@


1.41
log
@Log non-informational messages at LOG_WARNING priority instead of LOG_INFO.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.40 2009/10/27 23:59:51 deraadt Exp $	*/
d684 1
a684 1
		offset -= 24 * 3600;
@


1.40
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.39 2008/01/05 16:59:06 chl Exp $	*/
d449 4
d502 5
a506 1
	syslog(LOG_INFO, "(%s) %s (%s)", username, event, detail);
@


1.39
log
@remove unused function

from tobias@@

ok mglocker@@ tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.38 2007/06/02 01:29:11 pvalchev Exp $	*/
a22 4

#if !defined(lint) && !defined(LINT)
static char const rcsid[] = "$OpenBSD: misc.c,v 1.38 2007/06/02 01:29:11 pvalchev Exp $";
#endif
@


1.38
log
@safer snprintf construct with more paranoid length calculation
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.37 2005/06/08 18:34:00 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.37 2005/06/08 18:34:00 millert Exp $";
a64 28
}

/* strdtb(s) - delete trailing blanks in string 's' and return new length
 */
int
strdtb(char *s) {
	char	*x = s;

	/* scan forward to the null
	 */
	while (*x)
		x++;

	/* scan backward to either the first character before the string,
	 * or the last non-blank in the string, whichever comes first.
	 */
	do	{x--;}
	while (x >= s && isspace((unsigned char)*x));

	/* one character beyond where we stopped above is where the null
	 * goes.
	 */
	*++x = '\0';

	/* the difference between the position of the null character and
	 * the position of the first character of the string is the length.
	 */
	return (x - s);
@


1.37
log
@Force pid file fd to be > 2 so we don't clobber it when dup'ing
fds 0-2 to /dev/null.  Tested and OK aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.36 2005/03/10 22:41:56 deraadt Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.36 2005/03/10 22:41:56 deraadt Exp $";
d617 1
a617 1
			dst += 4;
@


1.36
log
@put umask restores in right place; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.35 2005/01/30 20:46:20 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.35 2005/01/30 20:46:20 millert Exp $";
d313 12
@


1.35
log
@bzero s_un before use; Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.34 2004/09/16 20:11:09 deraadt Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.34 2004/09/16 20:11:09 deraadt Exp $";
d755 1
d758 1
a765 1
	umask(omask);
@


1.34
log
@nice off_t cast
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.33 2004/07/22 16:36:28 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.33 2004/07/22 16:36:28 millert Exp $";
d737 1
d776 1
@


1.33
log
@Fix incorrect snprintf return value check noticed by Jarno Huuskonen.
Also make a utime() failure non-fatal since the important thing is
the poke on the socket now.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.32 2004/07/09 16:22:02 deraadt Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.32 2004/07/09 16:22:02 deraadt Exp $";
d320 1
a320 1
	(void) ftruncate(fd, num);
@


1.32
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.31 2004/06/22 03:15:33 avsm Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.31 2004/06/22 03:15:33 avsm Exp $";
d773 6
a778 3
	if (utime(spool_dir, NULL) < 0) {
		fprintf(stderr, "%s: unable to update mtime on %s\n",
		    ProgramName, spool_dir);
d781 1
a781 4

	if (snprintf(s_un.sun_path, sizeof s_un.sun_path, "%s/%s",
	    SPOOL_DIR, CRONSOCK) >= sizeof(s_un.sun_path)) {
		s_un.sun_family = AF_UNIX;
d783 1
a783 1
		s_un.sun_len = SUN_LEN(&s_un);
d785 10
a794 11
		(void) signal(SIGPIPE, SIG_IGN);
		if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
		    connect(sock, (struct sockaddr *)&s_un, sizeof(s_un)) == 0)
			write(sock, &cookie, 1);
		else
			fprintf(stderr, "%s: warning, cron does not appear to be "
			    "running.\n", ProgramName);
		if (sock >= 0)
			close(sock);
		(void) signal(SIGPIPE, SIG_DFL);
	}
@


1.31
log
@use snprintf(3) instead of home-grown glue_strings() function
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.30 2004/06/17 22:11:55 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.30 2004/06/17 22:11:55 millert Exp $";
d710 1
a710 1
open_socket()
@


1.30
log
@UUpdate ISC copyright year to 2004
Remove unused macros Skip_Line and MkLower
Remove trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.29 2004/05/13 14:10:10 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.29 2004/05/13 14:10:10 millert Exp $";
a52 35
/*
 * glue_strings is the overflow-safe equivalent of
 *	snprintf(buffer, buffer_size, "%s%c%s", a, separator, b);
 *
 * returns 1 on success, 0 on failure.  'buffer' MUST NOT be used if
 * glue_strings fails.
 */
int
glue_strings(char *buffer, size_t buffer_size, const char *a, const char *b,
	     char separator)
{
	char *buf;
	char *buf_end;

	if (buffer_size <= 0)
		return (0);
	buf_end = buffer + buffer_size;
	buf = buffer;

	for ( /* nothing */; buf < buf_end && *a != '\0'; buf++, a++ )
		*buf = *a;
	if (buf == buf_end)
		return (0);
	if (separator != '/' || buf == buffer || buf[-1] != '/')
		*buf++ = separator;
	if (buf == buf_end)
		return (0);
	for ( /* nothing */; buf < buf_end && *b != '\0'; buf++, b++ )
		*buf = *b;
	if (buf == buf_end)
		return (0);
	*buf = '\0';
	return (1);
}

d737 2
a738 2
	if (!glue_strings(s_un.sun_path, sizeof s_un.sun_path, SPOOL_DIR,
	    CRONSOCK, '/')) {
d779 2
a780 2
	if (glue_strings(s_un.sun_path, sizeof s_un.sun_path, SPOOL_DIR,
	    CRONSOCK, '/')) {
@


1.29
log
@Set close on exec flag for cron's socket.  Jarno Huuskonen
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.28 2004/05/10 12:14:54 millert Exp $	*/
d8 1
d15 7
a21 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.28 2004/05/10 12:14:54 millert Exp $";
@


1.28
log
@Make the accept socket non-blocking.  Should not matter since we
use select anyway but seems like a good idea since we really
don't want cron to block...
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.27 2003/04/15 08:08:45 deraadt Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.27 2003/04/15 08:08:45 deraadt Exp $";
d756 7
@


1.27
log
@nasty lies from hobbits, clean them out of comments
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.26 2003/02/20 20:38:08 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.26 2003/02/20 20:38:08 millert Exp $";
d756 7
@


1.26
log
@Sync with ISC cron-current + my at(1) integration.
The at(1) code is now more tightly integrated into the cron codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.25 2003/02/20 19:12:16 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.25 2003/02/20 19:12:16 millert Exp $";
d55 1
a55 1
 *		sprintf(buffer, "%s%c%s", a, separator, b);
a532 2
	/* we have to run strlen() because sprintf() returns (char*) on old BSD
	 */
@


1.25
log
@If there is no cron.allow or cron.deny file, only the superuser may run
the crontab command; for POSIX compliance.  Create an empty cron.deny
file to allow any user to run crontab:
    install -c -o root -g crontab -m 660 /dev/null /var/cron/cron.deny
@
text
@d1 2
a2 1
/*	$OpenBSD: misc.c,v 1.24 2003/02/18 02:25:39 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.24 2003/02/18 02:25:39 millert Exp $";
d33 1
a33 2
#include <sys/socket.h>
#include <sys/un.h>
d117 1
a117 1
	while (x >= s && isspace(*x));
d211 1
d213 3
d220 1
a220 1
		if (OK == mkdir(CRONDIR, 0700)) {
d229 1
a229 1
	if ((sb.st_mode & S_IFDIR) == 0) {
d253 1
a253 1
	if ((sb.st_mode & S_IFDIR) == 0) {
d258 31
d461 2
a463 2
		if (0 == strcmp(line, string))
			return (TRUE);
d700 1
a700 1
#ifdef HAVE_SAVED_GIDS
d704 1
a704 1
#else /*HAVE_SAVED_GIDS*/
d707 1
a707 1
#endif /*HAVE_SAVED_GIDS*/
d709 6
a714 1
/* Return the offset from GMT in seconds (algorithm taken from sendmail). */
d751 1
a751 1
	struct sockaddr_un sun;
d760 1
a760 1
	if (!glue_strings(sun.sun_path, sizeof sun.sun_path, SPOOL_DIR,
d766 5
a770 3
	unlink(sun.sun_path);
	sun.sun_family = AF_UNIX;
	sun.sun_len = SUN_LEN(&sun);
d773 1
a773 1
	if (bind(sock, (struct sockaddr *)&sun, sizeof(sun))) {
d785 1
a785 1
	chmod(sun.sun_path, 0660);
d789 30
@


1.24
log
@Use the SUN_LEN macro to set sun_len correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.23 2002/08/08 18:17:50 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.23 2002/08/08 18:17:50 millert Exp $";
d435 4
a438 4
/* int allowed(const char *username)
 *	returns TRUE if (ALLOW_FILE exists and user is listed)
 *	or (DENY_FILE exists and user is NOT listed)
 *	or (neither file exists but user=="root" so it's okay)
d441 2
a442 3
allowed(const char *username) {
	FILE	*allow = NULL;
	FILE	*deny = NULL;
d445 2
a446 1
#if defined(ALLOW_FILE) && defined(DENY_FILE)
d448 6
a453 15
	allow = fopen(ALLOW_FILE, "r");
	if (allow == NULL && errno != ENOENT)
		goto out;
	deny = fopen(DENY_FILE, "r");
	if (deny == NULL && errno != ENOENT)
		goto out;
	Debug(DMISC, ("allow/deny enabled, %d/%d\n", !!allow, !!deny))

	if (allow) {
		isallowed = in_file(username, allow, FALSE);
		goto out;
	}
	if (deny) {
		isallowed = !in_file(username, deny, TRUE);
		goto out;
a454 14
#endif

#if defined(ALLOW_ONLY_ROOT)
	isallowed = strcmp(username, ROOT_USER) == 0;
#else
	isallowed = TRUE;
#endif

out:
	if (allow)
		fclose(allow);
	if (deny)
		fclose(deny);

@


1.23
log
@Move closelog() into log_close() function and call that instead
of calling closelog() (with #ifdefs) directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.22 2002/07/15 19:13:29 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.22 2002/07/15 19:13:29 millert Exp $";
a749 1
	sun.sun_len = strlen(sun.sun_path);
d751 1
@


1.22
log
@Move atrun(8) functionality into cron(8) proper.  This fixes the
long-standing annoyance that atrun's granularity is 10 minutes.
Most at jobs run with a 1 minute granularity.  Jobs submitted via
"at now" or "batch" will run immediately.  Includes a rewritten
cron(8) man page.  at(1) will be integrated more closely into
cron at a future date.

Upgrading notes:
    the atrun job in root's crontab should be removed.
    the /var/at/spool directory is no longer used
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.21 2002/07/09 18:59:12 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.21 2002/07/09 18:59:12 millert Exp $";
d49 4
a492 4
#if defined(SYSLOG)
	static int syslog_open = 0;
#endif

d561 4
@


1.21
log
@o Add _PATH_CRON_PID which is built up from PIDDIR and PIDFILE via string
concatenation at compile time rather than run time.

o Some minor cosmetic changes to simplify diffing.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.20 2002/07/08 18:11:02 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.20 2002/07/08 18:11:02 millert Exp $";
d728 1
a728 1
	int		   sock, flags;
a738 9
	if ((flags = fcntl(sock, F_GETFL)) == -1 ||
	    fcntl(sock, F_SETFL, flags | O_NONBLOCK) == -1) {
		fprintf(stderr, "%s: can't set non-block: %s\n",
		    ProgramName, strerror(errno));
		log_it("CRON", getpid(), "DEATH", "can't set non-block");
		exit(ERROR_EXIT);
	}
	(void) fcntl(sock, F_SETFD, 1);

@


1.20
log
@Merge in some changes from Paul Vixie's tree; most are cosmetic
o ANSI function headers
o return (foo) not return foo
o add -oi to sendmail flags
o update email address in man pages
o make some strings const
o completely remove globbing cruft from popen.c
o whitespace changes
o add DOW_STAR to flags for "monthly", "weekly", and "daily" cron entries
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.19 2002/05/28 02:03:01 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: misc.c,v 1.19 2002/05/28 02:03:01 millert Exp $";
d257 1
a257 1
 *	can rewrite our PID into the PIDFILE after the fork.
d263 1
a263 1
	char pidfile[MAX_FNAME];
d278 1
a278 7
		if (!glue_strings(pidfile, sizeof pidfile, PIDDIR,
		    PIDFILE, '/')) {
			fprintf(stderr, "%s/%s: path too long\n",
				PIDDIR, PIDFILE);
			log_it("CRON", getpid(), "DEATH", "path too long");
			exit(ERROR_EXIT);
		}
@


1.19
log
@Kill an sscanf() in favor of strtol()
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.18 2002/05/28 01:20:19 deraadt Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.18 2002/05/28 01:20:19 deraadt Exp $";
a30 1

d35 1
a35 2

#if defined(LOG_CRON) && defined(LOG_FILE)
d43 3
d47 1
a47 1
static int		LogFD = ERR;
d57 2
a58 6
glue_strings(buffer, buffer_size, a, b, separator)
	char	*buffer;
	int	buffer_size;	
	char	*a;
	char	*b;
	int	separator;
d85 1
a85 1
strcmp_until(const char *left, const char *right, int until) {
a97 1

d101 1
a101 3
strdtb(s)
	char	*s;
{
a125 1

d127 1
a127 3
set_debug_flags(flags)
	char	*flags;
{
d141 1
a141 1
	char	*pc = flags;
d151 4
a154 5
		for (	test = DebugFlagNames, mask = 1;
			*test != NULL && strcmp_until(*test, pc, ',');
			test++, mask <<= 1
		    )
			;
d174 1
a174 1
		int	flag;
a188 1

d190 1
a190 2
set_cron_uid()
{
a203 1

d205 2
a206 3
set_cron_cwd()
{
	struct stat	sb;
d221 1
a221 1
	if (!(sb.st_mode & S_IFDIR)) {
d245 1
a245 1
	if (!(sb.st_mode & S_IFDIR)) {
a251 1

d260 7
a266 9
acquire_daemonlock(closeflag)
	int closeflag;
{
	static int	fd = -1;
	char		buf[3*MAX_FNAME];
	char		pidfile[MAX_FNAME];
	char		*ep;
	long		otherpid;
	ssize_t		num;
d332 2
a333 4
get_char(file)
	FILE	*file;
{
	int	ch;
a340 1

d344 1
a344 4
unget_char(ch, file)
	int	ch;
	FILE	*file;
{
a349 1

d357 2
a358 7
get_string(string, size, file, terms)
	char	*string;
	int	size;
	FILE	*file;
	char	*terms;
{
	int	ch;
a372 1

d376 2
a377 4
skip_comments(file)
	FILE	*file;
{
	int	ch;
d410 1
a410 2

/* int in_file(char *string, FILE *file)
d415 1
a415 4
in_file(string, file, error)
	char *string;
	FILE *file;
	int error;
d437 1
a437 2

/* int allowed(char *username)
d443 1
a443 3
allowed(username)
	char *username;
{
a482 1

d484 1
a484 6
log_it(username, xpid, event, detail)
	const char *username;
	int	xpid;
	const char *event;
	const char *detail;
{
d486 1
a486 1
	PID_T		pid = xpid;
d489 4
a492 4
	char		*msg;
	size_t		msglen;
	TIME_T		now = time((TIME_T) 0);
	struct tm	*t = localtime(&now);
d496 1
a496 1
	static int	syslog_open = 0;
d542 1
a542 1
		openlog(ProgramName, LOG_PID, LOG_CRON);
a560 1

d562 1
a562 1
log_close() {
d569 6
a574 2

/* two warnings:
d579 1
a579 4
first_word(s, t)
	char *s;	/* string we want the first word of */
	char *t;	/* terminators, implicitly including \0 */
{
a603 1

a637 1

a652 1

@


1.18
log
@use %ld (long) for pid
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.17 2002/05/22 18:17:53 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.17 2002/05/22 18:17:53 millert Exp $";
d281 1
d319 2
a320 1
			    sscanf(buf, "%ld", &otherpid) == 1) {
@


1.17
log
@Set close-on-exec flag for the socket cron selects on.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.16 2002/05/22 16:39:39 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.16 2002/05/22 16:39:39 millert Exp $";
d565 1
a565 1
	snprintf(msg, msglen, "%s (%02d/%02d-%02d:%02d:%02d-%d) %s (%s)\n",
d567 2
a568 2
		t->tm_mon+1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec, pid,
		event, detail);
@


1.16
log
@o avoid stdio in acquire_daemonlock() so we don't leak FILE * memory
o fix potential long vs. int mismatch in pid reading/writing.
  Note that we can't use pid_t for the type of the variable stashed
  in the pidfile since we don't have a scanf format for pid_t.  Use long
  instead since we know pid_t can't be bigger than a long.
o just return if closeflag is set, regardless of the value of fd
o fix potential (unwinnable?) race locking the pid file pointed out by dynamo.
  Using O_EXLOCK is not portable but it does help in these situations.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.15 2002/05/09 22:14:16 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.15 2002/05/09 22:14:16 millert Exp $";
d798 1
@


1.15
log
@allowed() is only called once so there is no need to use static
variables and leave the allow/deny files open.  Previously, the
allow/deny fd's were leaked during the crontab edit.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.13 2002/05/09 21:40:41 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.13 2002/05/09 21:40:41 millert Exp $";
a272 2
 *
 * it would be great if fflush() disassociated the file buffer.
d278 1
a278 1
	static	FILE	*fp = NULL;
d281 2
a282 2
	int		fd;
	PID_T		otherpid;
d284 6
a289 3
	if (closeflag && fp) {
		fclose(fp);
		fp = NULL;
d293 1
a293 1
	if (!fp) {
d301 2
a302 10
		if ((-1 == (fd = open(pidfile, O_RDWR|O_CREAT, 0644))) ||
		    (NULL == (fp = fdopen(fd, "r+")))) {
			snprintf(buf, sizeof buf, "can't open or create %s: %s",
				pidfile, strerror(errno));
			fprintf(stderr, "%s: %s\n", ProgramName, buf);
			log_it("CRON", getpid(), "DEATH", buf);
			exit(ERROR_EXIT);
		}

		if (flock(fd, LOCK_EX|LOCK_NB) < OK) {
d305 1
a305 1
			if (fscanf(fp, "%d", &otherpid) == 1)
d307 14
a320 1
				    "can't lock %s, otherpid may be %d: %s",
d322 1
a322 1
			else
d326 1
a330 1

d334 4
a337 4
	rewind(fp);
	fprintf(fp, "%ld\n", (long)getpid());
	fflush(fp);
	(void) ftruncate(fileno(fp), ftell(fp));
d339 2
a340 2
	/* abandon fd and fp even though the file is open. we need to
	 * keep it open and locked, but we don't need the handles elsewhere.
@


1.14
log
@Missing piece from last commit.
@
text
@d475 3
a477 3
	static int	init = FALSE;
	static FILE	*allow, *deny;
	static int	allow_error, deny_error;
a478 2
	if (!init) {
		init = TRUE;
d480 21
a500 5
		allow = fopen(ALLOW_FILE, "r");
		allow_error = !allow && errno != ENOENT;
		deny = fopen(DENY_FILE, "r");
		deny_error = !deny && errno != ENOENT;
		Debug(DMISC, ("allow/deny enabled, %d/%d\n", !!allow, !!deny))
d502 1
a502 4
		allow = NULL;
		allow_error = 0;
		deny = NULL;
		deny_error = 0;
a503 1
	}
d505 1
a505 2
	if (allow_error)
		return (FALSE);
d507 1
a507 3
		return (in_file(username, allow, FALSE));
	if (deny_error)
		return (FALSE);
d509 1
a509 1
		return (!in_file(username, deny, TRUE));
d511 1
a511 5
#if defined(ALLOW_ONLY_ROOT)
	return (strcmp(username, ROOT_USER) == 0);
#else
	return (TRUE);
#endif
@


1.13
log
@Better error handling for in_file(); from Owl
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.12 2002/05/09 21:22:01 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.12 2002/05/09 21:22:01 millert Exp $";
d498 1
a498 1
		return (in_file(username, allow));
d502 1
a502 1
		return (!in_file(username, deny));
@


1.12
log
@crontab is no longer setuid root, it is now setgid crontab.
These changes were modelled after the Owl version of vixie-cron,
but developed independently.

Our crontab used to send cron SIGUSR1 to tell cron to reread the
spool dir.  Now that crontab is not setuid root this doesn't work.
Instead, crontab pokes cron via a Unix domain socket located in the
tabs dir.

Please note, after these changes, the owner on user crontab files
will have to be changed manually from root to the uid of the
corresponding user for crontab to be usable.  cron itself will accept
tab files owned by either root or the user.
Also, any /var/cron/{allow,deny} files must be readable by group crontab.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.11 2001/12/12 19:02:50 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.11 2001/12/12 19:02:50 millert Exp $";
d437 1
a437 1
 *	FALSE otherwise.
d440 1
a440 1
in_file(string, file)
d443 1
d446 1
d448 2
a449 1
	rewind(file);
d451 6
a456 2
		if (line[0] != '\0')
			line[strlen(line)-1] = '\0';
d460 2
d477 1
d483 1
d485 1
d489 1
d491 1
d495 2
d499 2
a574 4
		/* we don't use LOG_PID since the pid passed to us by
		 * our client may not be our own.  therefore we want to
		 * print the pid ourselves.
		 */
@


1.11
log
@o pids should be pid_t, not int
o check return value of fscanf()
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.10 2001/02/20 02:03:19 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.10 2001/02/20 02:03:19 millert Exp $";
d33 2
a34 12
#if SYS_TIME_H
# include <sys/time.h>
#else
# include <time.h>
#endif
#include <sys/file.h>
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>
#if defined(SYSLOG)
# include <syslog.h>
#endif
d295 1
a295 1
			fprintf(stderr, "%s%s: path too long\n",
d713 8
a720 8
#ifdef HAVE_SAVED_UIDS
static uid_t save_euid;
int swap_uids() { save_euid = geteuid(); return (seteuid(getuid())); }
int swap_uids_back() { return (seteuid(save_euid)); }
#else /*HAVE_SAVED_UIDS*/
int swap_uids() { return (setreuid(geteuid(), getuid())); }
int swap_uids_back() { return (swap_uids()); }
#endif /*HAVE_SAVED_UIDS*/
d750 54
@


1.10
log
@Turn get_gmtoff into a macro for OSes with tm_gmtoff (like OpenBSD).
Save the GMT offset in a global so cron_sleep can use it.  This means
the offset can only change in set_time() which is really what we want.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.9 2001/02/19 14:33:33 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.9 2001/02/19 14:33:33 millert Exp $";
d293 2
a294 1
	int		fd, otherpid;
d322 8
a329 4
			fscanf(fp, "%d", &otherpid);
			snprintf(buf, sizeof buf,
			    "can't lock %s, otherpid may be %d: %s",
			    pidfile, otherpid, strerror(save_errno));
@


1.9
log
@Normalize the time in minutes to GMT so we can really catch DST changes
(since time() does not change during a DST switch).  This makes cron
correctly detect DST changes.  It does not fix the problem of wildcard
jobs running multiple times.  Also, don't rely on tm_gmtoff since that
is non-standard (but use it when we have it).
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.8 2001/02/18 19:48:35 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.8 2001/02/18 19:48:35 millert Exp $";
d695 1
a695 1
	long gmtoff = get_gmtoff(&t);
d728 2
a729 2
#ifdef HAVE_TM_GMTOFF
long get_gmtoff(time_t *clock)
d731 1
a731 10
	struct tm *tm;

	tm = localtime(clock);
	return (tm->tm_gmtoff);
}
#else
long get_gmtoff(time_t *clock)
{
	struct tm local;
	struct tm *gmt;
d734 7
a740 6
	local = *localtime(clock);
	gmt = gmtime(clock);

	offset = (local.tm_sec - gmt->tm_sec) +
	    ((local.tm_min - gmt->tm_min) * 60) +
	    ((local.tm_hour - gmt->tm_hour) * 3600);
d743 1
a743 1
	if (local.tm_year < gmt->tm_year)
d745 1
a745 1
	else if (local.tm_year > gmt->tm_year)
d747 1
a747 1
	else if (local.tm_yday < gmt->tm_yday)
d749 1
a749 1
	else if (local.tm_yday > gmt->tm_yday)
@


1.8
log
@Update to ISC cron 4.0b1 + our patches.  This is now under a BSD license.
I also fixed the signal handlers while I was at it.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: misc.c,v 1.6 2000/01/02 20:53:43 vixie Exp $";
d695 3
a697 2
	int hours = tm->tm_gmtoff / 3600;
	int minutes = (tm->tm_gmtoff - (hours * 3600)) / 60;
d726 37
@


1.7
log
@snprintf sprinkles; solar@@false.com & I
@
text
@d1 1
d4 4
d9 3
a11 8
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
d13 8
a20 3
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@@vix.com>          uunet!decwrl!vixie!paul
d24 1
a24 1
static char rcsid[] = "$Id: misc.c,v 1.6 1999/08/06 20:41:07 deraadt Exp $";
a40 1
#include <string.h>
d47 4
d52 1
a52 1
#define LOG_CRON LOG_DAEMON
d58 38
d98 1
a98 7
strcmp_until(left, right, until)
	char	*left;
	char	*right;
	int	until;
{
	register int	diff;

d106 1
a106 3
		diff = 0;
	} else {
		diff = *left - *right;
d108 1
a108 2

	return diff;
d139 1
a139 1
	return x - s;
d156 1
a156 1
	return FALSE;
d165 2
a166 2
		char	**test;
		int	mask;
d171 1
a171 1
			*test && strcmp_until(*test, pc, ',');
d180 1
a180 1
			return FALSE;
d204 1
a204 1
	return TRUE;
d291 3
d302 9
a310 8
		char	pidfile[MAX_FNAME];
		char	buf[MAX_TEMPSTR];
		int	fd, otherpid;

		if (snprintf(pidfile, sizeof pidfile, PIDFILE,
		    PIDDIR) >= sizeof pidfile ||
		    (fd = open(pidfile, O_RDWR|O_CREAT, 0644)) == -1 ||
		    (fp = fdopen(fd, "r+")) == NULL) {
d323 2
a324 2
				"can't lock %s, otherpid may be %d: %s",
				pidfile, otherpid, strerror(save_errno));
d334 1
a334 1
	fprintf(fp, "%d\n", getpid());
d354 1
a354 1
	return ch;
d396 1
a396 1
	return ch;
d456 1
a456 1
			return TRUE;
d458 1
a458 1
	return FALSE;
d494 1
a494 1
	return TRUE;
d501 1
a501 1
	char	*username;
d503 2
a504 2
	char	*event;
	char	*detail;
d506 3
a508 1
	PID_T			pid = xpid;
d510 4
a513 4
	char			*msg;
	TIME_T			now = time((TIME_T) 0);
	register struct tm	*t = localtime(&now);
	int			msglen;
d517 1
a517 1
	static int		syslog_open = 0;
d524 2
a525 3
	    MAX_TEMPSTR);
	msg = malloc(msglen);
	if (!msg)
d544 3
a546 3
	    username,
	    t->tm_mon+1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec, pid,
	    event, detail);
d548 2
d580 2
a581 2
		fprintf(stderr, "log_it: (%s %d) %s (%s)\n",
			username, pid, event, detail);
d602 2
a603 2
	register char *s;	/* string we want the first word of */
	register char *t;	/* terminators, implicitly including \0 */
d607 1
a607 1
	register char *rb, *rp;
d626 1
a626 1
	return rb;
d635 9
a643 4
	register char *dst;
	register unsigned char *src;
	register int len;
{
d646 1
a646 1
		register unsigned char ch = *src++;
d670 2
a671 2
	register unsigned char *src;
	register unsigned int len;
d673 1
a673 1
	register char *dst = malloc(len*4 + 1);
d678 1
a678 1
	return dst;
a689 1
	static char ret[64];	/* zone name might be >3 chars */
d692 1
d706 1
a706 1
		return ret;
d713 1
a713 1
	return ret;
a716 1

d719 2
a720 2
int swap_uids() { save_euid = geteuid(); return seteuid(getuid()); }
int swap_uids_back() { return seteuid(save_euid); }
d722 2
a723 2
int swap_uids() { return setreuid(geteuid(), getuid()); }
int swap_uids_back() { return swap_uids(); }
@


1.6
log
@uid_t and gid_t, and use %u
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: misc.c,v 1.5 1998/07/10 08:06:34 deraadt Exp $";
d266 4
a269 4
		(void) sprintf(pidfile, PIDFILE, PIDDIR);
		if ((-1 == (fd = open(pidfile, O_RDWR|O_CREAT, 0644)))
		    || (NULL == (fp = fdopen(fd, "r+")))
		    ) {
d470 1
d480 5
a484 4
	msg = malloc(strlen(username)
		     + strlen(event)
		     + strlen(detail)
		     + MAX_TEMPSTR);
d497 1
a497 1
	/* we have to sprintf() it because fprintf() doesn't always write
d501 4
a504 4
	sprintf(msg, "%s (%02d/%02d-%02d:%02d:%02d-%d) %s (%s)\n",
		username,
		t->tm_mon+1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec, pid,
		event, detail);
a505 2
	/* we have to run strlen() because sprintf() returns (char*) on old BSD
	 */
d608 1
a608 1
			sprintf(dst, "\\%03o", ch);
@


1.5
log
@do not syslog() with "\n"; skipped smtpd/named/ipmon; 12 minutes of dabbling
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: misc.c,v 1.4 1998/03/30 06:59:45 deraadt Exp $";
d670 1
a670 1
static int save_euid;
@


1.4
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: misc.c,v 1.3 1996/12/17 02:17:09 millert Exp $";
d530 1
a530 1
	syslog(LOG_INFO, "(%s) %s (%s)\n", username, event, detail);
@


1.3
log
@use snprintf when storing the string from strerror().  Who knows how
long it could be esp. when locales come into the picture.
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: misc.c,v 1.2 1996/11/01 23:27:37 millert Exp $";
d634 2
a635 2
/* Sat, 27 Feb 93 11:44:51 CST
 * 123456789012345678901234567
d641 2
a642 1
	time_t t = clock ?*clock :time(0L);
d644 20
a663 11
	static char ret[30];	/* zone name might be >3 chars */
	
	(void) sprintf(ret, "%s, %2d %s %2d %02d:%02d:%02d %s",
		       DowNames[tm->tm_wday],
		       tm->tm_mday,
		       MonthNames[tm->tm_mon],
		       tm->tm_year,
		       tm->tm_hour,
		       tm->tm_min,
		       tm->tm_sec,
		       TZONE(*tm));
@


1.2
log
@Check malloc/strdup ret val and deal.
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: misc.c,v 1.1.1.1 1995/10/18 08:47:30 deraadt Exp $";
d270 1
a270 1
			sprintf(buf, "can't open or create %s: %s",
d281 2
a282 1
			sprintf(buf, "can't lock %s, otherpid may be %d: %s",
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: misc.c,v 1.2 1994/08/31 19:28:50 jtc Exp $";
d625 2
a626 1
	mkprint(dst, src, len);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
