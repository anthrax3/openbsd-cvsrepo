head	1.43;
access;
symbols
	OPENBSD_6_1:1.43.0.8
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.18.0.6
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.4
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5;
locks; strict;
comment	@ * @;


1.43
date	2016.01.11.14.23.50;	author millert;	state Exp;
branches;
next	1.42;
commitid	fFP0tihUFMiVcTny;

1.42
date	2015.11.17.22.31.44;	author millert;	state Exp;
branches;
next	1.41;
commitid	1DwT6xt7W42FCut9;

1.41
date	2015.11.15.23.24.24;	author millert;	state Exp;
branches;
next	1.40;
commitid	4K3ElIFSUCsF9sYF;

1.40
date	2015.11.14.13.09.14;	author millert;	state Exp;
branches;
next	1.39;
commitid	KNISMJYcyEJqWs74;

1.39
date	2015.11.12.21.12.05;	author millert;	state Exp;
branches;
next	1.38;
commitid	6PlWoK7FsQNDGZmn;

1.38
date	2015.11.09.16.37.07;	author millert;	state Exp;
branches;
next	1.37;
commitid	ZJUG9DwHA5l6WcX2;

1.37
date	2015.11.09.15.57.39;	author millert;	state Exp;
branches;
next	1.36;
commitid	JJzvBekc1nrVHuHQ;

1.36
date	2015.11.09.14.44.05;	author millert;	state Exp;
branches;
next	1.35;
commitid	JywzFOJ0RFgKIt5T;

1.35
date	2015.11.09.01.12.27;	author millert;	state Exp;
branches;
next	1.34;
commitid	NbIbD3dCbvLEHSye;

1.34
date	2015.11.04.20.28.17;	author millert;	state Exp;
branches;
next	1.33;
commitid	6N0oXtYc5KM1a7DW;

1.33
date	2015.10.25.21.30.11;	author millert;	state Exp;
branches;
next	1.32;
commitid	Z2UkA4v651dEbyJ1;

1.32
date	2015.10.23.18.42.55;	author tedu;	state Exp;
branches;
next	1.31;
commitid	XKGk51XvBaSkXmrX;

1.31
date	2015.10.03.19.47.21;	author tedu;	state Exp;
branches;
next	1.30;
commitid	34TKQiezOQXb6h1Y;

1.30
date	2015.10.03.12.46.54;	author tedu;	state Exp;
branches;
next	1.29;
commitid	WlajD40E0eJCM3xO;

1.29
date	2015.08.25.20.09.27;	author millert;	state Exp;
branches;
next	1.28;
commitid	SFdjIC9WT8rSna3R;

1.28
date	2015.02.09.23.00.14;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	822YD61EeG0Xl9Na;

1.27
date	2015.01.23.02.37.25;	author tedu;	state Exp;
branches;
next	1.26;
commitid	UGPHvhzwRtnjrF9O;

1.26
date	2015.01.23.01.01.06;	author tedu;	state Exp;
branches;
next	1.25;
commitid	kzBIhYnXdVeOLxgw;

1.25
date	2015.01.22.22.38.55;	author tedu;	state Exp;
branches;
next	1.24;
commitid	F47ioXLOlSmeY3jW;

1.24
date	2015.01.19.01.05.32;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	OquoY4ptwTi2dltP;

1.23
date	2015.01.14.17.30.53;	author millert;	state Exp;
branches;
next	1.22;
commitid	qsePpGDsMLqV3DYZ;

1.22
date	2015.01.14.17.27.51;	author millert;	state Exp;
branches;
next	1.21;
commitid	29asVUstLv6pyoCO;

1.21
date	2015.01.14.17.27.29;	author millert;	state Exp;
branches;
next	1.20;
commitid	jXmo2gNqOzD6QEsx;

1.20
date	2013.11.23.19.18.52;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.17.15.58.45;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2011.08.22.19.32.42;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2011.03.03.15.08.14;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.13.20.44.00;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.30.20.45.58;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.17.22.11.55;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.03.19.54.04;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.13.14.22.18;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.17.21.56.26;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.20.33.31;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.14.15.58.13;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.15.00.39.01;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.20.20.38.08;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.10.20.28.51;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.08.18.17.50;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.08.07.23.22.41;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.15.22.16.41;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.15.19.13.29;	author millert;	state Exp;
branches;
next	;


desc
@@


1.43
log
@When caching the mtime of the spool directory and system crontab files,
stash a struct timespec, not just a time_t.  Fixes a bug where cron
could skip re-reading the spool after two consecutive changes.
@
text
@/*	$OpenBSD: atrun.c,v 1.42 2015/11/17 22:31:44 millert Exp $	*/

/*
 * Copyright (c) 2002-2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>

#include <bitstring.h>		/* for structs.h */
#include <bsd_auth.h>
#include <ctype.h>
#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <login_cap.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

#include "config.h"
#include "pathnames.h"
#include "macros.h"
#include "structs.h"
#include "funcs.h"
#include "globals.h"

static void run_job(atjob *, char *);

static int
strtot(const char *nptr, char **endptr, time_t *tp)
{
	long long ll;

	errno = 0;
	ll = strtoll(nptr, endptr, 10);
	if (*endptr == nptr)
		return (-1);
	if (ll < 0 || (errno == ERANGE && ll == LLONG_MAX) || (time_t)ll != ll)
		return (-1);
	*tp = (time_t)ll;
	return (0);
}

/*
 * Scan the at jobs dir and build up a list of jobs found.
 */
int
scan_atjobs(at_db **db, struct timespec *ts)
{
	DIR *atdir = NULL;
	int dfd, queue, pending;
	time_t run_time;
	char *ep;
	at_db *new_db, *old_db = *db;
	atjob *job;
	struct dirent *file;
	struct stat sb;

	if ((dfd = open(_PATH_AT_SPOOL, O_RDONLY|O_DIRECTORY)) == -1) {
		syslog(LOG_ERR, "(CRON) OPEN FAILED (%s)", _PATH_AT_SPOOL);
		return (0);
	}
	if (fstat(dfd, &sb) != 0) {
		syslog(LOG_ERR, "(CRON) FSTAT FAILED (%s)", _PATH_AT_SPOOL);
		close(dfd);
		return (0);
	}
	if (old_db != NULL && timespeccmp(&old_db->mtime, &sb.st_mtim, ==)) {
		close(dfd);
		return (0);
	}

	if ((atdir = fdopendir(dfd)) == NULL) {
		syslog(LOG_ERR, "(CRON) OPENDIR FAILED (%s)", _PATH_AT_SPOOL);
		close(dfd);
		return (0);
	}

	if ((new_db = malloc(sizeof(*new_db))) == NULL) {
		closedir(atdir);
		return (0);
	}
	new_db->mtime = sb.st_mtim;	/* stash at dir mtime */
	TAILQ_INIT(&new_db->jobs);

	pending = 0;
	while ((file = readdir(atdir)) != NULL) {
		if (fstatat(dfd, file->d_name, &sb, AT_SYMLINK_NOFOLLOW) != 0 ||
		    !S_ISREG(sb.st_mode))
			continue;

		/*
		 * at jobs are named as RUNTIME.QUEUE
		 * RUNTIME is the time to run in seconds since the epoch
		 * QUEUE is a letter that designates the job's queue
		 */
		if (strtot(file->d_name, &ep, &run_time) == -1)
			continue;
		if (ep[0] != '.' || !isalpha((unsigned char)ep[1]))
			continue;
		queue = (unsigned char)ep[1];

		job = malloc(sizeof(*job));
		if (job == NULL) {
			while ((job = TAILQ_FIRST(&new_db->jobs))) {
				TAILQ_REMOVE(&new_db->jobs, job, entries);
				free(job);
			}
			free(new_db);
			closedir(atdir);
			return (0);
		}
		job->uid = sb.st_uid;
		job->gid = sb.st_gid;
		job->queue = queue;
		job->run_time = run_time;
		TAILQ_INSERT_TAIL(&new_db->jobs, job, entries);
		if (ts != NULL && run_time <= ts->tv_sec)
			pending = 1;
	}
	closedir(atdir);

	/* Free up old at db and install new one */
	if (old_db != NULL) {
		while ((job = TAILQ_FIRST(&old_db->jobs))) {
			TAILQ_REMOVE(&old_db->jobs, job, entries);
			free(job);
		}
		free(old_db);
	}
	*db = new_db;

	return (pending);
}

/*
 * Loop through the at job database and run jobs whose time have come.
 */
void
atrun(at_db *db, double batch_maxload, time_t now)
{
	char atfile[PATH_MAX];
	struct stat sb;
	double la;
	atjob *job, *tjob, *batch = NULL;

	if (db == NULL)
		return;

	TAILQ_FOREACH_SAFE(job, &db->jobs, entries, tjob) {
		/* Skip jobs in the future */
		if (job->run_time > now)
			continue;

		snprintf(atfile, sizeof(atfile), "%s/%lld.%c", _PATH_AT_SPOOL,
		    (long long)job->run_time, job->queue);

		if (lstat(atfile, &sb) != 0 || !S_ISREG(sb.st_mode)) {
			TAILQ_REMOVE(&db->jobs, job, entries);
			free(job);
			continue;		/* disapeared or not a file */
		}

		/*
		 * Pending jobs have the user execute bit set.
		 */
		if (sb.st_mode & S_IXUSR) {
			/* new job to run */
			if (isupper(job->queue)) {
				/* we run one batch job per atrun() call */
				if (batch == NULL ||
				    job->run_time < batch->run_time)
					batch = job;
			} else {
				/* normal at job */
				run_job(job, atfile);
				TAILQ_REMOVE(&db->jobs, job, entries);
				free(job);
			}
		}
	}

	/* Run a single batch job if there is one pending. */
	if (batch != NULL
	    && (batch_maxload == 0.0 ||
	    ((getloadavg(&la, 1) == 1) && la <= batch_maxload))
	    ) {
		snprintf(atfile, sizeof(atfile), "%s/%lld.%c", _PATH_AT_SPOOL,
		    (long long)batch->run_time, batch->queue);
		run_job(batch, atfile);
		TAILQ_REMOVE(&db->jobs, batch, entries);
		free(job);
	}
}

/*
 * Run the specified job contained in atfile.
 */
static void
run_job(atjob *job, char *atfile)
{
	struct stat sb;
	struct passwd *pw;
	login_cap_t *lc;
	auth_session_t *as;
	pid_t pid;
	long nuid, ngid;
	FILE *fp;
	int waiter;
	size_t nread;
	char *cp, *ep, mailto[MAX_UNAME], buf[BUFSIZ];
	int fd, always_mail;
	int output_pipe[2];
	char *nargv[2], *nenvp[1];

	/* Open the file and unlink it so we don't try running it again. */
	if ((fd = open(atfile, O_RDONLY|O_NONBLOCK|O_NOFOLLOW, 0)) < 0) {
		syslog(LOG_ERR, "(CRON) CAN'T OPEN (%s)", atfile);
		return;
	}
	unlink(atfile);

	/* We don't want the atjobs dir in the log messages. */
	if ((cp = strrchr(atfile, '/')) != NULL)
		atfile = cp + 1;

	/* Fork so other pending jobs don't have to wait for us to finish. */
	switch (fork()) {
	case 0:
		/* child */
		break;
	case -1:
		/* error */
		syslog(LOG_ERR, "(CRON) CAN'T FORK (%m)");
		/* FALLTHROUGH */
	default:
		/* parent */
		close(fd);
		return;
	}

	/*
	 * We don't want the main cron daemon to wait for our children--
	 * we will do it ourselves via waitpid().
	 */
	(void) signal(SIGCHLD, SIG_DFL);

	/*
	 * Verify the user still exists and their account has not expired.
	 */
	pw = getpwuid(job->uid);
	if (pw == NULL) {
		syslog(LOG_WARNING, "(CRON) ORPHANED JOB (%s)", atfile);
		_exit(EXIT_FAILURE);
	}
	if (pw->pw_expire && time(NULL) >= pw->pw_expire) {
		syslog(LOG_NOTICE, "(%s) ACCOUNT EXPIRED, JOB ABORTED (%s)",
		    pw->pw_name, atfile);
		_exit(EXIT_FAILURE);
	}

	/* Sanity checks */
	if (fstat(fd, &sb) < 0) {
		syslog(LOG_ERR, "(%s) FSTAT FAILED (%s)", pw->pw_name, atfile);
		_exit(EXIT_FAILURE);
	}
	if (!S_ISREG(sb.st_mode)) {
		syslog(LOG_WARNING, "(%s) NOT REGULAR (%s)", pw->pw_name,
		    atfile);
		_exit(EXIT_FAILURE);
	}
	if ((sb.st_mode & ALLPERMS) != (S_IRUSR | S_IWUSR | S_IXUSR)) {
		syslog(LOG_WARNING, "(%s) BAD FILE MODE (%s)", pw->pw_name,
		    atfile);
		_exit(EXIT_FAILURE);
	}
	if (sb.st_uid != 0 && sb.st_uid != job->uid) {
		syslog(LOG_WARNING, "(%s) WRONG FILE OWNER (%s)", pw->pw_name,
		    atfile);
		_exit(EXIT_FAILURE);
	}
	if (sb.st_nlink > 1) {
		syslog(LOG_WARNING, "(%s) BAD LINK COUNT (%s)", pw->pw_name,
		    atfile);
		_exit(EXIT_FAILURE);
	}

	if ((fp = fdopen(dup(fd), "r")) == NULL) {
		syslog(LOG_ERR, "(CRON) DUP FAILED (%m)");
		_exit(EXIT_FAILURE);
	}

	/*
	 * Check the at job header for sanity and extract the
	 * uid, gid, mailto user and always_mail flag.
	 *
	 * The header should look like this:
	 * #!/bin/sh
	 * # atrun uid=123 gid=123
	 * # mail                         joeuser 0
	 */
	if (fgets(buf, sizeof(buf), fp) == NULL ||
	    strcmp(buf, "#!/bin/sh\n") != 0 ||
	    fgets(buf, sizeof(buf), fp) == NULL ||
	    strncmp(buf, "# atrun uid=", 12) != 0)
		goto bad_file;

	/* Pull out uid */
	cp = buf + 12;
	errno = 0;
	nuid = strtol(cp, &ep, 10);
	if (errno == ERANGE || (uid_t)nuid > UID_MAX || cp == ep ||
	    strncmp(ep, " gid=", 5) != 0)
		goto bad_file;

	/* Pull out gid */
	cp = ep + 5;
	errno = 0;
	ngid = strtol(cp, &ep, 10);
	if (errno == ERANGE || (gid_t)ngid > GID_MAX || cp == ep || *ep != '\n')
		goto bad_file;

	/* Pull out mailto user (and always_mail flag) */
	if (fgets(buf, sizeof(buf), fp) == NULL ||
	    strncmp(buf, "# mail ", 7) != 0)
		goto bad_file;
	cp = buf + 7;
	while (isspace((unsigned char)*cp))
		cp++;
	ep = cp;
	while (!isspace((unsigned char)*ep) && *ep != '\0')
		ep++;
	if (*ep == '\0' || *ep != ' ' || ep - cp >= sizeof(mailto))
		goto bad_file;
	memcpy(mailto, cp, ep - cp);
	mailto[ep - cp] = '\0';
	always_mail = ep[1] == '1';

	(void)fclose(fp);
	if (!safe_p(pw->pw_name, mailto))
		_exit(EXIT_FAILURE);
	if ((uid_t)nuid != job->uid) {
		syslog(LOG_WARNING, "(%s) UID MISMATCH (%s)", pw->pw_name,
		    atfile);
		_exit(EXIT_FAILURE);
	}
	if ((gid_t)ngid != job->gid) {
		syslog(LOG_WARNING, "(%s) GID MISMATCH (%s)", pw->pw_name,
		    atfile);
		_exit(EXIT_FAILURE);
	}

	/* mark ourselves as different to PS command watchers */
	setproctitle("atrun %s", atfile);

	if (pipe(output_pipe) != 0) {	/* child's stdout/stderr */
		syslog(LOG_ERR, "(CRON) PIPE (%m)");
		_exit(EXIT_FAILURE);
	}

	/* Fork again, child will run the job, parent will catch output. */
	switch ((pid = fork())) {
	case -1:
		syslog(LOG_ERR, "(CRON) CAN'T FORK (%m)");
		_exit(EXIT_FAILURE);
		/*NOTREACHED*/
	case 0:
		/* Write log message now that we have our real pid. */
		syslog(LOG_INFO, "(%s) ATJOB (%s)", pw->pw_name, atfile);

		/* Connect grandchild's stdin to the at job file. */
		if (lseek(fd, 0, SEEK_SET) < 0) {
			syslog(LOG_ERR, "(CRON) LSEEK (%m)");
			_exit(EXIT_FAILURE);
		}
		if (fd != STDIN_FILENO) {
			dup2(fd, STDIN_FILENO);
			close(fd);
		}

		/* Connect stdout/stderr to the pipe from our parent. */
		if (output_pipe[WRITE_PIPE] != STDOUT_FILENO) {
			dup2(output_pipe[WRITE_PIPE], STDOUT_FILENO);
			close(output_pipe[WRITE_PIPE]);
		}
		dup2(STDOUT_FILENO, STDERR_FILENO);
		close(output_pipe[READ_PIPE]);

		(void) setsid();

		/*
		 * From this point on, anything written to stderr will be
		 * mailed to the user as output.
		 */

		/* Setup execution environment as per login.conf */
		if ((lc = login_getclass(pw->pw_class)) == NULL) {
			warnx("unable to get login class for %s",
			    pw->pw_name);
			syslog(LOG_ERR, "(CRON) CAN'T GET LOGIN CLASS (%s)",
			    pw->pw_name);
			_exit(EXIT_FAILURE);

		}
		if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETALL)) {
			warn("setusercontext failed for %s", pw->pw_name);
			syslog(LOG_ERR, "(%s) SETUSERCONTEXT FAILED (%m)",
			    pw->pw_name);
			_exit(EXIT_FAILURE);
		}

		/* Run any approval scripts. */
		as = auth_open();
		if (as == NULL || auth_setpwd(as, pw) != 0) {
			warn("auth_setpwd");
			syslog(LOG_ERR, "(%s) AUTH_SETPWD FAILED (%m)",
			    pw->pw_name);
			_exit(EXIT_FAILURE);
		}
		if (auth_approval(as, lc, pw->pw_name, "cron") <= 0) {
			warnx("approval failed for %s", pw->pw_name);
			syslog(LOG_ERR, "(%s) APPROVAL FAILED (cron)",
			    pw->pw_name);
			_exit(EXIT_FAILURE);
		}
		auth_close(as);
		login_close(lc);

		/* If this is a low priority job, nice ourself. */
		if (job->queue > 'b') {
			if (setpriority(PRIO_PROCESS, 0, job->queue - 'b') != 0)
				syslog(LOG_ERR, "(%s) CAN'T NICE (%m)",
				    pw->pw_name);
		}

		(void) signal(SIGPIPE, SIG_DFL);

		/*
		 * Exec /bin/sh with stdin connected to the at job file
		 * and stdout/stderr hooked up to our parent.
		 * The at file will set the environment up for us.
		 */
		nargv[0] = "sh";
		nargv[1] = NULL;
		nenvp[0] = NULL;
		if (execve(_PATH_BSHELL, nargv, nenvp) != 0) {
			warn("unable to execute %s", _PATH_BSHELL);
			syslog(LOG_ERR, "(%s) CAN'T EXEC (%s: %m)", pw->pw_name,
			    _PATH_BSHELL);
			_exit(EXIT_FAILURE);
		}
		break;
	default:
		/* parent */
		break;
	}

	/* Close the atfile's fd and the end of the pipe we don't use. */
	close(fd);
	close(output_pipe[WRITE_PIPE]);

	/* Read piped output (if any) from the at job. */
	if ((fp = fdopen(output_pipe[READ_PIPE], "r")) == NULL) {
		syslog(LOG_ERR, "(%s) FDOPEN (%m)", pw->pw_name);
		(void) _exit(EXIT_FAILURE);
	}
	nread = fread(buf, 1, sizeof(buf), fp);
	if (nread != 0 || always_mail) {
		FILE	*mail;
		pid_t	mailpid;
		size_t	bytes = 0;
		int	status = 0;
		char	mailcmd[MAX_COMMAND];
		char	hostname[HOST_NAME_MAX + 1];

		if (gethostname(hostname, sizeof(hostname)) != 0)
			strlcpy(hostname, "unknown", sizeof(hostname));
		if (snprintf(mailcmd, sizeof mailcmd, MAILFMT,
		    MAILARG) >= sizeof mailcmd) {
			syslog(LOG_ERR, "(%s) ERROR (mailcmd too long)",
			    pw->pw_name);
			(void) _exit(EXIT_FAILURE);
		}
		if (!(mail = cron_popen(mailcmd, "w", pw, &mailpid))) {
			syslog(LOG_ERR, "(%s) POPEN (%s)", pw->pw_name, mailcmd);
			(void) _exit(EXIT_FAILURE);
		}
		fprintf(mail, "From: %s (Atrun Service)\n", pw->pw_name);
		fprintf(mail, "To: %s\n", mailto);
		fprintf(mail, "Subject: Output from \"at\" job\n");
		fprintf(mail, "Auto-Submitted: auto-generated\n");
		fprintf(mail, "\nYour \"at\" job on %s\n\"%s/%s\"\n",
		    hostname, _PATH_AT_SPOOL, atfile);
		fprintf(mail, "\nproduced the following output:\n\n");

		/* Pipe the job's output to sendmail. */
		do {
			bytes += nread;
			fwrite(buf, nread, 1, mail);
		} while ((nread = fread(buf, 1, sizeof(buf), fp)) != 0);

		/*
		 * If the mailer exits with non-zero exit status, log
		 * this fact so the problem can (hopefully) be debugged.
		 */
		if ((status = cron_pclose(mail, mailpid)) != 0) {
			syslog(LOG_NOTICE, "(%s) MAIL (mailed %zu byte%s of "
			    "output but got status 0x%04x)", pw->pw_name,
			    bytes, (bytes == 1) ? "" : "s", status);
		}
	}

	fclose(fp);	/* also closes output_pipe[READ_PIPE] */

	/* Wait for grandchild to die.  */
	for (;;) {
		if (waitpid(pid, &waiter, 0) == -1) {
			if (errno == EINTR)
				continue;
			break;
		} else {
			/*
			if (WIFSIGNALED(waiter) && WCOREDUMP(waiter))
				Debug(DPROC, (", dumped core"))
			*/
			break;
		}
	}
	_exit(EXIT_SUCCESS);

bad_file:
	syslog(LOG_ERR, "(%s) BAD FILE FORMAT (%s)", pw->pw_name, atfile);
	_exit(EXIT_FAILURE);
}
@


1.42
log
@Check pipe(2) return value; noticed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.41 2015/11/15 23:24:24 millert Exp $	*/
d26 1
d95 1
a95 1
	if (old_db != NULL && old_db->mtime == sb.st_mtime) {
d110 1
a110 1
	new_db->mtime = sb.st_mtime;	/* stash at dir mtime */
@


1.41
log
@Clean up the remaining uses of stderr and perror() and use warn/err
and/or syslog depending on whether stderr is hooked up at the time.
Also remove closelog() which is not needed since we are headed for exec.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.40 2015/11/14 13:09:14 millert Exp $	*/
d382 4
a385 1
	pipe(output_pipe);	/* child's stdout/stderr */
@


1.40
log
@Remove log_it() and call syslog(3) directly using the same format:
"(username) WHAT (details)".  Logs due to normal operation (e.g.
crontab operations or running commands) are logged at LOG_INFO like
before.  Actual errors are logged at LOG_ERR, less important things
are logged at LOG_WARNING OR LOG_NOTICE.  Also ignore SIGHUP now
that there is no log file to reopen.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.39 2015/11/12 21:12:05 millert Exp $	*/
d32 1
d230 2
a393 3
		/* Close syslog file */
		closelog();

d396 1
a396 1
			perror("lseek");
d414 12
a425 8
		{
			login_cap_t *lc;
			auth_session_t *as;
			if ((lc = login_getclass(pw->pw_class)) == NULL) {
				fprintf(stderr,
				    "Cannot get login class for %s\n",
				    pw->pw_name);
				_exit(EXIT_FAILURE);
d427 7
a433 1
			}
d435 13
a447 18
			if (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETALL)) {
				fprintf(stderr,
				    "setusercontext failed for %s\n",
				    pw->pw_name);
				_exit(EXIT_FAILURE);
			}
			as = auth_open();
			if (as == NULL || auth_setpwd(as, pw) != 0) {
				fprintf(stderr, "can't malloc\n");
				_exit(EXIT_FAILURE);
			}
			if (auth_approval(as, lc, pw->pw_name, "cron") <= 0) {
				fprintf(stderr, "approval failed for %s\n",
				    pw->pw_name);
				_exit(EXIT_FAILURE);
			}
			auth_close(as);
			login_close(lc);
d449 2
d453 5
a457 3
		if (job->queue > 'b')
			(void)setpriority(PRIO_PROCESS, 0, job->queue - 'b');

d470 3
a472 1
			perror("execve: " _PATH_BSHELL);
d487 1
a487 1
		perror("fdopen");
d503 2
a504 1
			fprintf(stderr, "mailcmd too long\n");
d508 1
a508 1
			perror(mailcmd);
@


1.39
log
@Use absolute paths in pathnames.h.  There is no longer a need to
chdir(2) to the cron dir and cron(8) now changes to / via daemon(3).
We no longer try to create/chmod the spool directories as they
should be set correctly at install time.  The setegid(crontab)
has been moved to open_socket() so it is closer to the chmod(2)
call that needs it.  OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.38 2015/11/09 16:37:07 millert Exp $	*/
d41 1
d85 1
a85 1
		log_it("CRON", "OPEN FAILED", _PATH_AT_SPOOL);
d89 1
a89 1
		log_it("CRON", "FSTAT FAILED", _PATH_AT_SPOOL);
d99 1
a99 1
		log_it("CRON", "OPENDIR FAILED", _PATH_AT_SPOOL);
d241 1
a241 1
		log_it("CRON", "CAN'T OPEN", atfile);
d257 1
a257 1
		log_it("CRON", "error", "can't fork");
d276 1
a276 1
		log_it("CRON", "ORPHANED JOB", atfile);
d280 2
a281 2
		log_it(pw->pw_name, "ACCOUNT EXPIRED, JOB ABORTED",
		    atfile);
d287 1
a287 1
		log_it(pw->pw_name, "FSTAT FAILED", atfile);
d291 2
a292 1
		log_it(pw->pw_name, "NOT REGULAR", atfile);
d296 2
a297 1
		log_it(pw->pw_name, "BAD FILE MODE", atfile);
d301 2
a302 1
		log_it(pw->pw_name, "WRONG FILE OWNER", atfile);
d306 2
a307 1
		log_it(pw->pw_name, "BAD LINK COUNT", atfile);
d312 1
a312 1
		log_it("CRON", "error", "dup(2) failed");
d366 2
a367 1
		log_it(pw->pw_name, "UID MISMATCH", atfile);
d371 2
a372 1
		log_it(pw->pw_name, "GID MISMATCH", atfile);
d384 1
a384 1
		log_it("CRON", "error", "can't fork");
d389 1
a389 1
		log_it(pw->pw_name, "ATJOB", atfile);
d391 2
a392 2
		/* Close log file (or syslog) */
		log_close();
d490 1
a490 1
		if (snprintf(mailcmd, sizeof mailcmd,  MAILFMT,
d518 3
a520 4
			snprintf(buf, sizeof(buf), "mailed %lu byte%s of output"
			    " but got status 0x%04x\n", (unsigned long)bytes,
			    (bytes == 1) ? "" : "s", status);
			log_it(pw->pw_name, "MAIL", buf);
d543 1
a543 1
	log_it(pw->pw_name, "BAD FILE FORMAT", atfile);
@


1.38
log
@Remove unused xpid argument to log_it().
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.37 2015/11/09 15:57:39 millert Exp $	*/
d53 15
d83 2
a84 2
	if ((dfd = open(AT_SPOOL, O_RDONLY|O_DIRECTORY)) == -1) {
		log_it("CRON", "OPEN FAILED", AT_SPOOL);
d88 1
a88 1
		log_it("CRON", "FSTAT FAILED", AT_SPOOL);
d98 1
a98 1
		log_it("CRON", "OPENDIR FAILED", AT_SPOOL);
d166 1
a166 1
	char atfile[MAX_FNAME];
d179 1
a179 1
		snprintf(atfile, sizeof(atfile), "%s/%lld.%c", AT_SPOOL,
d212 1
a212 1
		snprintf(atfile, sizeof(atfile), "%s/%lld.%c", AT_SPOOL,
a437 2
		chdir("/");		/* at job will chdir to correct place */

d496 2
a497 2
		fprintf(mail, "\nYour \"at\" job on %s\n\"%s/%s/%s\"\n",
		    hostname, CRONDIR, AT_SPOOL, atfile);
@


1.37
log
@Rename AT_DIR -> AT_SPOOL and SPOOL_DIR -> CRON_SPOOL to improve
readability.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.36 2015/11/09 14:44:05 millert Exp $	*/
d69 1
a69 1
		log_it("CRON", getpid(), "OPEN FAILED", AT_SPOOL);
d73 1
a73 1
		log_it("CRON", getpid(), "FSTAT FAILED", AT_SPOOL);
d83 1
a83 1
		log_it("CRON", getpid(), "OPENDIR FAILED", AT_SPOOL);
d225 1
a225 1
		log_it("CRON", getpid(), "CAN'T OPEN", atfile);
d241 1
a241 1
		log_it("CRON", getpid(), "error", "can't fork");
d260 1
a260 1
		log_it("CRON", getpid(), "ORPHANED JOB", atfile);
d264 1
a264 1
		log_it(pw->pw_name, getpid(), "ACCOUNT EXPIRED, JOB ABORTED",
d271 1
a271 1
		log_it(pw->pw_name, getpid(), "FSTAT FAILED", atfile);
d275 1
a275 1
		log_it(pw->pw_name, getpid(), "NOT REGULAR", atfile);
d279 1
a279 1
		log_it(pw->pw_name, getpid(), "BAD FILE MODE", atfile);
d283 1
a283 1
		log_it(pw->pw_name, getpid(), "WRONG FILE OWNER", atfile);
d287 1
a287 1
		log_it(pw->pw_name, getpid(), "BAD LINK COUNT", atfile);
d292 1
a292 1
		log_it("CRON", getpid(), "error", "dup(2) failed");
d346 1
a346 1
		log_it(pw->pw_name, getpid(), "UID MISMATCH", atfile);
d350 1
a350 1
		log_it(pw->pw_name, getpid(), "GID MISMATCH", atfile);
d362 1
a362 1
		log_it("CRON", getpid(), "error", "can't fork");
d367 1
a367 1
		log_it(pw->pw_name, getpid(), "ATJOB", atfile);
d501 1
a501 1
			log_it(pw->pw_name, getpid(), "MAIL", buf);
d524 1
a524 1
	log_it(pw->pw_name, getpid(), "BAD FILE FORMAT", atfile);
@


1.36
log
@Use fstatat() when checking the files in the at queue so we
don't need to chdir to the queue dir.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.35 2015/11/09 01:12:27 millert Exp $	*/
d68 2
a69 2
	if ((dfd = open(AT_DIR, O_RDONLY|O_DIRECTORY)) == -1) {
		log_it("CRON", getpid(), "OPEN FAILED", AT_DIR);
d73 1
a73 1
		log_it("CRON", getpid(), "FSTAT FAILED", AT_DIR);
d83 1
a83 1
		log_it("CRON", getpid(), "OPENDIR FAILED", AT_DIR);
d164 1
a164 1
		snprintf(atfile, sizeof(atfile), "%s/%lld.%c", AT_DIR,
d197 1
a197 1
		snprintf(atfile, sizeof(atfile), "%s/%lld.%c", AT_DIR,
d484 1
a484 1
		    hostname, CRONDIR, AT_DIR, atfile);
@


1.35
log
@queue(3) instead of homegrown queues and lists.  This also fixes
some potential memory leaks in error paths.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.34 2015/11/04 20:28:17 millert Exp $	*/
d60 1
a60 1
	int cwd, queue, pending;
d66 1
a66 1
	struct stat statbuf;
d68 2
a69 2
	if (stat(AT_DIR, &statbuf) != 0) {
		log_it("CRON", getpid(), "CAN'T STAT", AT_DIR);
d72 3
a74 2

	if (old_db != NULL && old_db->mtime == statbuf.st_mtime) {
d77 2
a78 4

	/* XXX - use fstatat/openat instead of chdir */
	if ((cwd = open(".", O_RDONLY, 0)) < 0) {
		log_it("CRON", getpid(), "CAN'T OPEN", ".");
d82 3
a84 7
	if (chdir(AT_DIR) != 0 || (atdir = opendir(".")) == NULL) {
		if (atdir == NULL)
			log_it("CRON", getpid(), "OPENDIR FAILED", AT_DIR);
		else
			log_it("CRON", getpid(), "CHDIR FAILED", AT_DIR);
		fchdir(cwd);
		close(cwd);
a89 2
		fchdir(cwd);
		close(cwd);
d92 1
a92 1
	new_db->mtime = statbuf.st_mtime;	/* stash at dir mtime */
d97 2
a98 2
		if (stat(file->d_name, &statbuf) != 0 ||
		    !S_ISREG(statbuf.st_mode))
a119 2
			fchdir(cwd);
			close(cwd);
d122 2
a123 2
		job->uid = statbuf.st_uid;
		job->gid = statbuf.st_gid;
a141 4
	/* Change back to the normal cron dir. */
	fchdir(cwd);
	close(cwd);

d152 1
a152 1
	struct stat statbuf;
d167 1
a167 1
		if (lstat(atfile, &statbuf) != 0 || !S_ISREG(statbuf.st_mode)) {
d176 1
a176 1
		if (statbuf.st_mode & S_IXUSR) {
d211 1
a211 1
	struct stat statbuf;
d270 1
a270 1
	if (fstat(fd, &statbuf) < 0) {
d274 1
a274 1
	if (!S_ISREG(statbuf.st_mode)) {
d278 1
a278 1
	if ((statbuf.st_mode & ALLPERMS) != (S_IRUSR | S_IWUSR | S_IXUSR)) {
d282 1
a282 1
	if (statbuf.st_uid != 0 && statbuf.st_uid != job->uid) {
d286 1
a286 1
	if (statbuf.st_nlink > 1) {
@


1.34
log
@Change cron from including all headers in every file to only including
what each .c file needs.  I have not removed cron.h since it will
be used in a future clean up of the cron's .h files.  OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.33 2015/10/25 21:30:11 millert Exp $	*/
a50 1
static void unlink_job(at_db *, atjob *);
d57 1
a57 1
scan_atjobs(at_db *old_db, struct timespec *ts)
d63 2
a64 2
	at_db new_db;
	atjob *job, *tjob;
d73 1
a73 1
	if (old_db->mtime == statbuf.st_mtime) {
d77 1
a77 1
	/* XXX - would be nice to stash the crontab cwd */
d93 8
a100 2
	new_db.mtime = statbuf.st_mtime;	/* stash at dir mtime */
	new_db.head = new_db.tail = NULL;
d121 3
a123 4
			for (job = new_db.head; job != NULL; ) {
				tjob = job;
				job = job->next;
				free(tjob);
d125 1
d135 1
a135 7
		job->prev = new_db.tail;
		job->next = NULL;
		if (new_db.head == NULL)
			new_db.head = job;
		if (new_db.tail != NULL)
			new_db.tail->next = job;
		new_db.tail = job;
d141 7
a147 5
	/* Free up old at db */
	for (job = old_db->head; job != NULL; ) {
		tjob = job;
		job = job->next;
		free(tjob);
d149 1
a154 3
	/* Install the new database */
	*old_db = new_db;

d167 4
a170 1
	atjob *job, *batch;
d172 1
a172 1
	for (batch = NULL, job = db->head; job; job = job->next) {
d180 5
a184 5
		if (stat(atfile, &statbuf) != 0)
			unlink_job(db, job);	/* disapeared */

		if (!S_ISREG(statbuf.st_mode))
			continue;		/* should not happen */
d199 2
a200 1
				unlink_job(db, job);
d213 2
a214 1
		unlink_job(db, batch);
a215 17
}

/*
 * Remove the specified at job from the database.
 */
static void
unlink_job(at_db *db, atjob *job)
{
	if (job->prev == NULL)
		db->head = job->next;
	else
		job->prev->next = job->next;

	if (job->next == NULL)
		db->tail = job->prev;
	else
		job->next->prev = job->prev;
@


1.33
log
@Remove cron.pid support.  We still want to avoid multiple crons
running so verify that if the cron socket exists nothing is listening
on it.  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.32 2015/10/23 18:42:55 tedu Exp $	*/
d23 11
a33 1
#include "cron.h"
d35 15
a49 1
#include <sys/resource.h>
@


1.32
log
@remove some more ifdef maziness
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.31 2015/10/03 19:47:21 tedu Exp $	*/
a249 2

	acquire_daemonlock(1);			/* close lock fd */
@


1.31
log
@There is no need to keep a global array of sysconf(_SC_OPEN_MAX) elements
just to keep track of a single pid. Return it to the caller and make it
their problem.
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.30 2015/10/03 12:46:54 tedu Exp $	*/
a179 1
#ifdef HAVE_GETLOADAVG
a181 1
#endif
a486 3
#ifdef MAIL_DATE
		fprintf(mail, "Date: %s\n", arpadate(&StartTime));
#endif /*MAIL_DATE*/
@


1.30
log
@unifdef some features we will always have. ok benno zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.29 2015/08/25 20:09:27 millert Exp $	*/
d468 1
d481 1
a481 1
		if (!(mail = cron_popen(mailcmd, "w", pw))) {
d506 1
a506 1
		if ((status = cron_pclose(mail)) != 0) {
@


1.29
log
@Use ppoll(2) instead of poll(2).  This has two benefits.  Firstly,
we can use struct timespec throughout and avoid any conversion
issues which might cause jobs to fire prematurely.  Secondly, it
eliminates a race condition that could delay us taking action on
SIGCHLD and SIGHUP.  OK deraadt@@ okan@@ ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.28 2015/02/09 23:00:14 deraadt Exp $	*/
a268 1
#ifdef HAVE_PW_EXPIRE
a273 1
#endif
a397 1
#ifdef LOGIN_CAP
a399 1
# ifdef BSD_AUTH
a400 1
# endif
a414 1
# ifdef BSD_AUTH
a425 1
# endif /* BSD_AUTH */
a427 16
#else
		if (setgid(pw->pw_gid) || initgroups(pw->pw_name, pw->pw_gid)) {
			fprintf(stderr,
			    "unable to set groups for %s\n", pw->pw_name);
			_exit(EXIT_FAILURE);
		}
#ifdef HAVE_SETLOGIN
		setlogin(pw->pw_name);
#endif
		if (setuid(pw->pw_uid)) {
			fprintf(stderr, "unable to set uid to %lu\n",
			    (unsigned long)pw->pw_uid);
			_exit(EXIT_FAILURE);
		}

#endif /* LOGIN_CAP */
@


1.28
log
@clean up flags++ instances around getopt()
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.27 2015/01/23 02:37:25 tedu Exp $	*/
d34 1
a34 1
scan_atjobs(at_db *old_db, struct timeval *tv)
d113 1
a113 1
		if (tv != NULL && run_time <= tv->tv_sec)
@


1.27
log
@Remove the OK and ERR macros. They obfuscate the code and don't
help legibility. (unix system calls use 0 for ok, but hundreds of
other projects use 1 to indicate success.) Despite the name, many
system calls (e.g., open) also return not OK values for success.
It also cleans up some weird code like int crontab_fd = OK - 1;
This diff is mechanical in nature. Later I will fix the bugs it reveals.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.26 2015/01/23 01:01:06 tedu Exp $	*/
d163 1
a163 1
		if (statbuf.st_mode & S_IXUSR) 	{
@


1.26
log
@remove debug code.
I think the level of debug code in cron is excessive for a program
that has reached feature complete. If cron needs to provide more
information to the user about its operational status, I think syslog
would be more appropriate. (The debug flags also disable forking
into the background, so they aren't even that useful for debugging a
live system.)
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.25 2015/01/22 22:38:55 tedu Exp $	*/
d228 1
a228 1
	if ((fd = open(atfile, O_RDONLY|O_NONBLOCK|O_NOFOLLOW, 0)) < OK) {
d278 1
a278 1
	if (fstat(fd, &statbuf) < OK) {
@


1.25
log
@delete useless casts. ok deraadt guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.24 2015/01/19 01:05:32 deraadt Exp $	*/
a44 2
	Debug(DLOAD, ("[%ld] scan_atjobs()\n", (long)getpid()))

a50 2
		Debug(DLOAD, ("[%ld] at jobs dir mtime unch, no load needed.\n",
		    (long)getpid()))
a118 1
	Debug(DLOAD, ("unlinking old at database:\n"))
a119 1
		Debug(DLOAD, ("\t%lld.%c\n", (long long)job->run_time, job->queue))
a130 1
	Debug(DLOAD, ("scan_atjobs is done\n"))
a145 2
	Debug(DPROC, ("[%ld] atrun()\n", (long)getpid()))

a226 2
	Debug(DPROC, ("[%ld] run_job('%s')\n", (long)getpid(), atfile))

a373 3
		Debug(DPROC, ("[%ld] grandchild process fork()'ed\n",
			      (long)getpid()))

a457 8
#if DEBUGGING
		if (DebugFlags & DTEST) {
			fprintf(stderr,
			    "debug DTEST is on, not exec'ing at job %s\n",
			    atfile);
			_exit(EXIT_SUCCESS);
		}
#endif /*DEBUGGING*/
a478 3
	Debug(DPROC, ("[%ld] child continues, closing output pipe\n",
	    (long)getpid()))

a483 3
	Debug(DPROC, ("[%ld] child reading output from grandchild\n",
	    (long)getpid()))

a495 3
		Debug(DPROC|DEXT, ("[%ld] got data from grandchild\n",
		    (long)getpid()))

a527 2
		Debug(DPROC, ("[%ld] closing pipe to mail\n",
		    (long)getpid()))
a534 1
	Debug(DPROC, ("[%ld] got EOF from grandchild\n", (long)getpid()))
a538 2
	Debug(DPROC, ("[%ld] waiting for grandchild (%ld) to finish\n",
		      (long)getpid(), (long)pid))
a542 3
			Debug(DPROC,
			    ("[%ld] no grandchild process--mail written?\n",
			    (long)getpid()))
d545 1
a545 2
			Debug(DPROC, ("[%ld] grandchild (%ld) finished, status=%04x",
			    (long)getpid(), (long)pid, WEXITSTATUS(waiter)))
d548 1
a548 1
			Debug(DPROC, ("\n"))
@


1.24
log
@If UID_MAX is not defined, this should fail to compile.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.23 2015/01/14 17:30:53 millert Exp $	*/
d94 1
a94 1
		job = (atjob *)malloc(sizeof(*job));
d395 1
a395 1
		if (lseek(fd, (off_t) 0, SEEK_SET) < 0) {
@


1.23
log
@Replace MAXHOSTNAMELEN with HOST_NAME_MAX+1 and MAXNAMLEN with NAME_MAX
and use limits.h instead of sys/param.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.22 2015/01/14 17:27:51 millert Exp $	*/
a28 7

#ifndef	UID_MAX
#define	UID_MAX	INT_MAX
#endif
#ifndef	GID_MAX
#define	GID_MAX	INT_MAX
#endif
@


1.22
log
@Use HAVE_FOO for BSD-specific features instead of relying on the
BSD macro from sys/param.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.21 2015/01/14 17:27:29 millert Exp $	*/
d529 1
a529 1
		char	hostname[MAXHOSTNAMELEN];
@


1.21
log
@Use standard types for wait, readdir, signals and pids.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.20 2013/11/23 19:18:52 deraadt Exp $	*/
d287 1
a287 1
#if (defined(BSD)) && (BSD >= 199103)
d462 1
a462 1
#if (defined(BSD)) && (BSD >= 199103)
@


1.20
log
@remove redundant check, and be a bit more careful about queue naming
discussion with jca
ok millert guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.19 2013/04/17 15:58:45 deraadt Exp $	*/
d236 1
a236 1
	WAIT_T waiter;
@


1.19
log
@Adapt cron and at for future large time_t and tv_sec types.  These were some
of the harder programs to adapt, so let me know if problems happen.
tested by guenther, gilles, chl, others
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.18 2011/08/22 19:32:42 millert Exp $	*/
d99 1
a99 3
		queue = ep[1];
		if (!isalpha(queue))
			continue;
@


1.18
log
@Use standard EXIT_SUCCESS/EXIT_FAILURE and STD{IN,OUT,ERR}_FILENO
defines instead of using custom macros.  OK deraadt@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.17 2011/03/03 15:08:14 millert Exp $	*/
d45 1
a45 2
	long l;
	TIME_T run_time;
d95 3
a97 3
		l = strtol(file->d_name, &ep, 10);
		if (ep[0] != '.' || !isalpha((unsigned char)ep[1]) || l < 0 ||
		    l >= INT_MAX)
a98 1
		run_time = (TIME_T)l;
d134 1
a134 1
		Debug(DLOAD, ("\t%ld.%c\n", (long)job->run_time, job->queue))
d155 1
a155 1
atrun(at_db *db, double batch_maxload, TIME_T now)
d169 2
a170 2
		snprintf(atfile, sizeof(atfile), "%s/%ld.%c", AT_DIR,
		    (long)job->run_time, job->queue);
d203 2
a204 2
		snprintf(atfile, sizeof(atfile), "%s/%ld.%c", AT_DIR,
		    (long)batch->run_time, batch->queue);
@


1.17
log
@Reset the SIGPIPE signal handler immediately before executing a command.
We ignore it by default so cron doesn't die if sendmail is missing
or exits prematurely but the actual command being run should have the
default handler installed.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.16 2009/10/27 23:59:51 deraadt Exp $	*/
d289 1
a289 1
		_exit(ERROR_EXIT);
d295 1
a295 1
		_exit(ERROR_EXIT);
d302 1
a302 1
		_exit(ERROR_EXIT);
d306 1
a306 1
		_exit(ERROR_EXIT);
d310 1
a310 1
		_exit(ERROR_EXIT);
d314 1
a314 1
		_exit(ERROR_EXIT);
d318 1
a318 1
		_exit(ERROR_EXIT);
d323 1
a323 1
		_exit(ERROR_EXIT);
d374 1
a374 1
		_exit(ERROR_EXIT);
d377 1
a377 1
		_exit(ERROR_EXIT);
d381 1
a381 1
		_exit(ERROR_EXIT);
d393 1
a393 1
		_exit(ERROR_EXIT);
d408 1
a408 1
			_exit(ERROR_EXIT);
d410 2
a411 2
		if (fd != STDIN) {
			dup2(fd, STDIN);
d416 2
a417 2
		if (output_pipe[WRITE_PIPE] != STDOUT) {
			dup2(output_pipe[WRITE_PIPE], STDOUT);
d420 1
a420 1
		dup2(STDOUT, STDERR);
d435 1
a435 1
				_exit(ERROR_EXIT);
d443 1
a443 1
				_exit(ERROR_EXIT);
d449 1
a449 1
				_exit(ERROR_EXIT);
d454 1
a454 1
				_exit(ERROR_EXIT);
d464 1
a464 1
			_exit(ERROR_EXIT);
d472 1
a472 1
			_exit(ERROR_EXIT);
d488 1
a488 1
			_exit(OK_EXIT);
d504 1
a504 1
			_exit(ERROR_EXIT);
d525 1
a525 1
		(void) _exit(ERROR_EXIT);
d543 1
a543 1
			(void) _exit(ERROR_EXIT);
d547 1
a547 1
			(void) _exit(ERROR_EXIT);
d603 1
a603 1
	_exit(OK_EXIT);
d607 1
a607 1
	_exit(ERROR_EXIT);
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.15 2006/08/13 20:44:00 millert Exp $	*/
d491 2
@


1.15
log
@Add Auto-Submitted header in generated mail as per RFC 3834.
OK henning@@, ckuethe@@, krw@@, ian@@.  From Tamas TEVESZ.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.14 2005/01/30 20:45:58 millert Exp $	*/
a21 4

#if !defined(lint) && !defined(LINT)
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.14 2005/01/30 20:45:58 millert Exp $";
#endif
@


1.14
log
@Proper cleanup on malloc failure; Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.13 2004/06/17 22:11:55 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.13 2004/06/17 22:11:55 millert Exp $";
d554 1
@


1.13
log
@UUpdate ISC copyright year to 2004
Remove unused macros Skip_Line and MkLower
Remove trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.12 2004/06/03 19:54:04 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.12 2004/06/03 19:54:04 millert Exp $";
d90 1
a90 1
	while ((file = readdir(atdir))) {
d116 3
@


1.12
log
@More changes from Dmitry V. Levin:

Check return values for setgid, initgroups and setuid in code we don't compile.
Print the correct filename for the at job in mail sent.
Add some #if DEBUGGING in cron.c's usage().
Set sunlen each time before using it in accept().
Don't send mail at all if MAILTO is set but empty.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.11 2004/05/13 14:22:18 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.11 2004/05/13 14:22:18 millert Exp $";
d389 1
a389 1
	
d471 2
a472 2
			fprintf(stderr,
			    "unable to set uid to %ld\n", (long)pw->pw_uid);
@


1.11
log
@Pasto, change a cast from uid_t to gid_t (no real change...)
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.10 2003/06/17 21:56:26 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.10 2003/06/17 21:56:26 millert Exp $";
d462 5
a466 2
		setgid(pw->pw_gid);
		initgroups(pw->pw_name, pw->pw_gid);
d470 5
a474 1
		setuid(pw->pw_uid);
d554 2
a555 2
		fprintf(mail, "\nYour \"at\" job on %s\n\"%s/%s\"\n",
		    hostname, CRONDIR, atfile);
@


1.10
log
@Sync with share/misc/license.template and add missing DARPA credit
where applicable.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.9 2003/05/12 20:33:31 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.9 2003/05/12 20:33:31 millert Exp $";
d354 1
a354 1
	if (errno == ERANGE || (uid_t)ngid > GID_MAX || cp == ep || *ep != '\n')
@


1.9
log
@feof() can only be used after you actually hit EOF so the check
for no output from the at command was busted.  Instead of using
feof(), just fread() a buffer's worth and check to see if we
got anything back.  Closes PR 3252.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.8 2003/04/14 15:58:13 millert Exp $	*/
d10 11
a20 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.8 2003/04/14 15:58:13 millert Exp $";
@


1.8
log
@Use setproctitle() instead of the CAPITALIZE_FOR_PS hack.  Inspired
by similar changes in FreeBSD and NetBSD.  For at jobs, include the
job number in the proctitle.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.7 2003/03/15 00:39:01 millert Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.7 2003/03/15 00:39:01 millert Exp $";
d238 1
d511 6
a516 2
	fp = fdopen(output_pipe[READ_PIPE], "r");
	if (always_mail || !feof(fp)) {
d518 1
a518 1
		int	bytes = 0;
a521 1
		size_t	nread;
d548 1
a548 1
		while ((nread = fread(buf, 1, sizeof(buf), fp)) > 0) {
d551 1
a551 1
		}
d560 3
a562 3
			snprintf(buf, sizeof(buf), "mailed %d byte%s of output"
			    " but got status 0x%04x\n",
			    bytes, (bytes == 1) ? "" : "s", status);
@


1.7
log
@Use strlcpy() instead of pre-checking the src len and using strcpy()
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.6 2003/02/20 20:38:08 millert Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.6 2003/02/20 20:38:08 millert Exp $";
d252 4
d380 2
a381 12
#ifdef CAPITALIZE_FOR_PS
	/* mark ourselves as different to PS command watchers by upshifting
	 * our program name.  This has no effect on some kernels.
	 * XXX - really want to set proc title to at job name instead
	 */
	/*local*/{
		char *pch;

		for (pch = ProgramName; *pch; pch++)
			*pch = MkUpper(*pch);
	}
#endif /* CAPITALIZE_FOR_PS */
@


1.6
log
@Sync with ISC cron-current + my at(1) integration.
The at(1) code is now more tightly integrated into the cron codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.5 2002/08/10 20:28:51 millert Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.5 2002/08/10 20:28:51 millert Exp $";
d529 1
a529 1
			strcpy(hostname, "unknown");
@


1.5
log
@Just zero out pw_passwd in the pw_dup()'d copy.  There's no need
to do this elsewhere and my previous commit in this area caused
problems on systems with an /etc/crontab file.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.4 2002/08/08 18:17:50 millert Exp $	*/
d4 1
a4 2
 * Copyright (c) 2002 Todd C. Miller <Todd.Miller@@courtesan.com>
 * All rights reserved.
d6 3
a8 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.4 2002/08/08 18:17:50 millert Exp $";
d24 1
d30 7
d55 2
a56 2
	if (stat(_PATH_ATJOBS, &statbuf) != 0) {
		log_it("CRON", getpid(), "CAN'T STAT", _PATH_ATJOBS);
d72 1
a72 1
	if (chdir(_PATH_ATJOBS) != 0 || (atdir = opendir(".")) == NULL) {
d74 1
a74 2
			log_it("CRON", getpid(), "OPENDIR FAILED",
			    _PATH_ATJOBS);
d76 1
a76 2
			log_it("CRON", getpid(), "CHDIR FAILED",
			    _PATH_ATJOBS);
d97 2
a98 1
		if (*ep != '.' || !isalpha(*(ep + 1)) || l < 0 || l >= INT_MAX)
d101 1
a101 1
		queue = *(ep + 1);
d156 1
a156 1
	char atfile[PATH_MAX];
d168 1
a168 1
		snprintf(atfile, sizeof(atfile), "%s/%ld.%c", _PATH_ATJOBS,
d196 7
a202 3
	if (batch != NULL && (batch_maxload == 0.0 ||
	    ((getloadavg(&la, 1) == 1) && la <= batch_maxload))) {
		snprintf(atfile, sizeof(atfile), "%s/%ld.%c", _PATH_ATJOBS,
d283 1
a283 1
	/* XXX - is this needed now that we do auth_approval? */
d289 1
d353 1
a353 1
	while (isspace(*cp))
d356 1
a356 1
	while (!isspace(*ep) && *ep != '\0')
d362 1
a362 1
	always_mail = *(ep + 1) == '1';
d465 1
d467 1
d545 2
a546 2
		fprintf(mail, "\nYour \"at\" job on %s\n\"%s\"\n",
		    hostname, atfile);
@


1.4
log
@Move closelog() into log_close() function and call that instead
of calling closelog() (with #ifdefs) directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.3 2002/08/07 23:22:41 millert Exp $	*/
d31 1
a31 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.3 2002/08/07 23:22:41 millert Exp $";
a282 1
	bzero(pw->pw_passwd, strlen(pw->pw_passwd));
@


1.3
log
@paranoia: zero out pw_passwd since we don't need it
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.2 2002/07/15 22:16:41 millert Exp $	*/
d31 1
a31 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.2 2002/07/15 22:16:41 millert Exp $";
d404 2
a405 3
#ifdef SYSLOG
		closelog();
#endif
@


1.2
log
@Move login_close() out of #ifdef BSD_AUTH block
@
text
@d1 1
a1 1
/*	$OpenBSD: atrun.c,v 1.1 2002/07/15 19:13:29 millert Exp $	*/
d31 1
a31 1
static const char rcsid[] = "$OpenBSD: atrun.c,v 1.1 2002/07/15 19:13:29 millert Exp $";
d283 1
@


1.1
log
@Move atrun(8) functionality into cron(8) proper.  This fixes the
long-standing annoyance that atrun's granularity is 10 minutes.
Most at jobs run with a 1 minute granularity.  Jobs submitted via
"at now" or "batch" will run immediately.  Includes a rewritten
cron(8) man page.  at(1) will be integrated more closely into
cron at a future date.

Upgrading notes:
    the atrun job in root's crontab should be removed.
    the /var/at/spool directory is no longer used
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
a31 1
static const char rcsid[] = "$OpenBSD$";
d459 1
a460 1
# endif /* BSD_AUTH */
@

