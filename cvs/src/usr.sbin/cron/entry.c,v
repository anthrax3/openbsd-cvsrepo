head	1.48;
access;
symbols
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.33.0.16
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.14
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.10
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.8
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.6
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.4
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.32.0.6
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.4
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.30.0.22
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.18
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.16
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.14
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.12
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.10
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.8
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.30.0.6
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.4
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.2
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.8.0.6
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2015.11.14.13.09.14;	author millert;	state Exp;
branches;
next	1.47;
commitid	KNISMJYcyEJqWs74;

1.47
date	2015.11.09.16.37.07;	author millert;	state Exp;
branches;
next	1.46;
commitid	ZJUG9DwHA5l6WcX2;

1.46
date	2015.11.08.14.40.23;	author millert;	state Exp;
branches;
next	1.45;
commitid	7OmJlpVoB3hniMSx;

1.45
date	2015.11.04.20.28.17;	author millert;	state Exp;
branches;
next	1.44;
commitid	6N0oXtYc5KM1a7DW;

1.44
date	2015.11.04.12.53.05;	author millert;	state Exp;
branches;
next	1.43;
commitid	2QMTGnuouMIAKrAq;

1.43
date	2015.10.26.14.27.41;	author millert;	state Exp;
branches;
next	1.42;
commitid	k893fgzG4z9i5qIx;

1.42
date	2015.10.06.14.58.37;	author tedu;	state Exp;
branches;
next	1.41;
commitid	DORRwC1MyrO1Yl4N;

1.41
date	2015.10.03.12.46.54;	author tedu;	state Exp;
branches;
next	1.40;
commitid	WlajD40E0eJCM3xO;

1.40
date	2015.02.09.22.35.08;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	eGq01x6bjr83TVho;

1.39
date	2015.01.23.19.07.27;	author tedu;	state Exp;
branches;
next	1.38;
commitid	YJA2vmvfLuMfGdwZ;

1.38
date	2015.01.23.02.37.25;	author tedu;	state Exp;
branches;
next	1.37;
commitid	UGPHvhzwRtnjrF9O;

1.37
date	2015.01.23.01.01.06;	author tedu;	state Exp;
branches;
next	1.36;
commitid	kzBIhYnXdVeOLxgw;

1.36
date	2015.01.22.22.38.55;	author tedu;	state Exp;
branches;
next	1.35;
commitid	F47ioXLOlSmeY3jW;

1.35
date	2015.01.14.17.27.51;	author millert;	state Exp;
branches;
next	1.34;
commitid	29asVUstLv6pyoCO;

1.34
date	2014.08.25.07.50.26;	author doug;	state Exp;
branches;
next	1.33;
commitid	vcwz0sp1JH7QzUmA;

1.33
date	2011.05.19.15.00.17;	author phessler;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.29.18.56.47;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2005.01.30.20.44.50;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.22.21.02.19;	author avsm;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.22.03.15.33;	author avsm;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.17.22.11.55;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.26.00.13.38;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.17.14.10.47;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.12.18.15.55;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.11.17.54.06;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.10.15.18.25;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.10.15.13.33;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.10.15.09.20;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.09.18.13.02;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.04.21.47.08;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.27.15.02.44;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.20.20.38.08;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.10.20.28.51;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.07.23.22.41;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.15.19.13.29;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.11.20.15.40;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.11.19.29.36;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.08.18.11.02;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.14.21.35.01;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.18.19.48.33;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.21.21.08.56;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.18.21.23.04;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.12.22.08.10.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.12.16.18.40.53;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.12.14.20.20.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.11.01.23.27.32;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.30;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Remove log_it() and call syslog(3) directly using the same format:
"(username) WHAT (details)".  Logs due to normal operation (e.g.
crontab operations or running commands) are logged at LOG_INFO like
before.  Actual errors are logged at LOG_ERR, less important things
are logged at LOG_WARNING OR LOG_NOTICE.  Also ignore SIGHUP now
that there is no log file to reopen.
@
text
@/*	$OpenBSD: entry.c,v 1.47 2015/11/09 16:37:07 millert Exp $	*/

/*
 * Copyright 1988,1990,1993,1994 by Paul Vixie
 * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
 * Copyright (c) 1997,2000 by Internet Software Consortium, Inc.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <bitstring.h>		/* for structs.h */
#include <ctype.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>		/* for structs.h */
#include <unistd.h>

#include "pathnames.h"
#include "macros.h"
#include "structs.h"
#include "funcs.h"

typedef	enum ecode {
	e_none, e_minute, e_hour, e_dom, e_month, e_dow,
	e_cmd, e_timespec, e_username, e_option, e_memory
} ecode_e;

static const char *ecodes[] = {
	"no error",
	"bad minute",
	"bad hour",
	"bad day-of-month",
	"bad month",
	"bad day-of-week",
	"bad command",
	"bad time specifier",
	"bad username",
	"bad option",
	"out of memory"
};

static const char *MonthNames[] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
	NULL
};

static const char *DowNames[] = {
	"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun",
	NULL
};

static int	get_list(bitstr_t *, int, int, const char *[], int, FILE *),
		get_range(bitstr_t *, int, int, const char *[], int, FILE *),
		get_number(int *, int, const char *[], int, FILE *, const char *),
		set_element(bitstr_t *, int, int, int);

void
free_entry(entry *e)
{
	free(e->cmd);
	free(e->pwd);
	if (e->envp)
		env_free(e->envp);
	free(e);
}

/* return NULL if eof or syntax error occurs;
 * otherwise return a pointer to a new entry.
 */
entry *
load_entry(FILE *file, void (*error_func)(const char *), struct passwd *pw,
    char **envp)
{
	/* this function reads one crontab entry -- the next -- from a file.
	 * it skips any leading blank lines, ignores comments, and returns
	 * NULL if for any reason the entry can't be read and parsed.
	 *
	 * the entry is also parsed here.
	 *
	 * syntax:
	 *   user crontab:
	 *	minutes hours doms months dows cmd\n
	 *   system crontab (/etc/crontab):
	 *	minutes hours doms months dows USERNAME cmd\n
	 */

	ecode_e	ecode = e_none;
	entry *e;
	int ch;
	char cmd[MAX_COMMAND];
	char envstr[MAX_ENVSTR];
	char **tenvp;

	skip_comments(file);

	ch = get_char(file);
	if (ch == EOF)
		return (NULL);

	/* ch is now the first useful character of a useful line.
	 * it may be an @@special or it may be the first character
	 * of a list of minutes.
	 */

	e = calloc(sizeof(entry), 1);
	if (e == NULL) {
		ecode = e_memory;
		goto eof;
	}

	if (ch == '@@') {
		/* all of these should be flagged and load-limited; i.e.,
		 * instead of @@hourly meaning "0 * * * *" it should mean
		 * "close to the front of every hour but not 'til the
		 * system load is low".  Problems are: how do you know
		 * what "low" means? (save me from /etc/cron.conf!) and:
		 * how to guarantee low variance (how low is low?), which
		 * means how to we run roughly every hour -- seems like
		 * we need to keep a history or let the first hour set
		 * the schedule, which means we aren't load-limited
		 * anymore.  too much for my overloaded brain. (vix, jan90)
		 * HINT
		 */
		ch = get_string(cmd, MAX_COMMAND, file, " \t\n");
		if (!strcmp("reboot", cmd)) {
			e->flags |= WHEN_REBOOT;
		} else if (!strcmp("yearly", cmd) || !strcmp("annually", cmd)){
			bit_set(e->minute, 0);
			bit_set(e->hour, 0);
			bit_set(e->dom, 0);
			bit_set(e->month, 0);
			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
			e->flags |= DOW_STAR;
		} else if (!strcmp("monthly", cmd)) {
			bit_set(e->minute, 0);
			bit_set(e->hour, 0);
			bit_set(e->dom, 0);
			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
			e->flags |= DOW_STAR;
		} else if (!strcmp("weekly", cmd)) {
			bit_set(e->minute, 0);
			bit_set(e->hour, 0);
			bit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));
			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
			bit_set(e->dow, 0);
			e->flags |= DOW_STAR;
		} else if (!strcmp("daily", cmd) || !strcmp("midnight", cmd)) {
			bit_set(e->minute, 0);
			bit_set(e->hour, 0);
			bit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));
			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
		} else if (!strcmp("hourly", cmd)) {
			bit_set(e->minute, 0);
			bit_nset(e->hour, 0, (LAST_HOUR-FIRST_HOUR+1));
			bit_nset(e->dom, 0, (LAST_DOM-FIRST_DOM+1));
			bit_nset(e->month, 0, (LAST_MONTH-FIRST_MONTH+1));
			bit_nset(e->dow, 0, (LAST_DOW-FIRST_DOW+1));
			e->flags |= HR_STAR;
		} else {
			ecode = e_timespec;
			goto eof;
		}
		/* Advance past whitespace between shortcut and
		 * username/command.
		 */
		Skip_Blanks(ch, file);
		if (ch == EOF || ch == '\n') {
			ecode = e_cmd;
			goto eof;
		}
	} else {
		if (ch == '*')
			e->flags |= MIN_STAR;
		ch = get_list(e->minute, FIRST_MINUTE, LAST_MINUTE,
			      NULL, ch, file);
		if (ch == EOF) {
			ecode = e_minute;
			goto eof;
		}

		/* hours
		 */

		if (ch == '*')
			e->flags |= HR_STAR;
		ch = get_list(e->hour, FIRST_HOUR, LAST_HOUR,
			      NULL, ch, file);
		if (ch == EOF) {
			ecode = e_hour;
			goto eof;
		}

		/* DOM (days of month)
		 */

		if (ch == '*')
			e->flags |= DOM_STAR;
		ch = get_list(e->dom, FIRST_DOM, LAST_DOM,
			      NULL, ch, file);
		if (ch == EOF) {
			ecode = e_dom;
			goto eof;
		}

		/* month
		 */

		ch = get_list(e->month, FIRST_MONTH, LAST_MONTH,
			      MonthNames, ch, file);
		if (ch == EOF) {
			ecode = e_month;
			goto eof;
		}

		/* DOW (days of week)
		 */

		if (ch == '*')
			e->flags |= DOW_STAR;
		ch = get_list(e->dow, FIRST_DOW, LAST_DOW,
			      DowNames, ch, file);
		if (ch == EOF) {
			ecode = e_dow;
			goto eof;
		}
	}

	/* make sundays equivalent */
	if (bit_test(e->dow, 0) || bit_test(e->dow, 7)) {
		bit_set(e->dow, 0);
		bit_set(e->dow, 7);
	}

	/* check for permature EOL and catch a common typo */
	if (ch == '\n' || ch == '*') {
		ecode = e_cmd;
		goto eof;
	}

	/* ch is the first character of a command, or a username */
	unget_char(ch, file);

	if (!pw) {
		char		*username = cmd;	/* temp buffer */

		ch = get_string(username, MAX_COMMAND, file, " \t\n");

		if (ch == EOF || ch == '\n' || ch == '*') {
			ecode = e_cmd;
			goto eof;
		}

		pw = getpwnam(username);
		if (pw == NULL) {
			ecode = e_username;
			goto eof;
		}
	}

	if ((e->pwd = pw_dup(pw)) == NULL) {
		ecode = e_memory;
		goto eof;
	}
	explicit_bzero(e->pwd->pw_passwd, strlen(e->pwd->pw_passwd));

	/* copy and fix up environment.  some variables are just defaults and
	 * others are overrides.
	 */
	if ((e->envp = env_copy(envp)) == NULL) {
		ecode = e_memory;
		goto eof;
	}
	if (!env_get("SHELL", e->envp)) {
		if (snprintf(envstr, sizeof envstr, "SHELL=%s", _PATH_BSHELL) >=
		    sizeof(envstr))
			syslog(LOG_ERR, "(CRON) ERROR (can't set SHELL)");
		else {
			if ((tenvp = env_set(e->envp, envstr)) == NULL) {
				ecode = e_memory;
				goto eof;
			}
			e->envp = tenvp;
		}
	}
	if (!env_get("HOME", e->envp)) {
		if (snprintf(envstr, sizeof envstr, "HOME=%s", pw->pw_dir) >=
		    sizeof(envstr))
			syslog(LOG_ERR, "(CRON) ERROR (can't set HOME)");
		else {
			if ((tenvp = env_set(e->envp, envstr)) == NULL) {
				ecode = e_memory;
				goto eof;
			}
			e->envp = tenvp;
		}
	}
	if (snprintf(envstr, sizeof envstr, "LOGNAME=%s", pw->pw_name) >=
		sizeof(envstr))
		syslog(LOG_ERR, "(CRON) ERROR (can't set LOGNAME)");
	else {
		if ((tenvp = env_set(e->envp, envstr)) == NULL) {
			ecode = e_memory;
			goto eof;
		}
		e->envp = tenvp;
	}
	if (snprintf(envstr, sizeof envstr, "USER=%s", pw->pw_name) >=
		sizeof(envstr))
		syslog(LOG_ERR, "(CRON) ERROR (can't set USER)");
	else {
		if ((tenvp = env_set(e->envp, envstr)) == NULL) {
			ecode = e_memory;
			goto eof;
		}
		e->envp = tenvp;
	}

	/* If the first character of the command is '-' it is a cron option.
	 */
	ch = get_char(file);
	while (ch == '-') {
		switch (ch = get_char(file)) {
		case 'q':
			e->flags |= DONT_LOG;
			Skip_Nonblanks(ch, file)
			break;
		default:
			ecode = e_option;
			goto eof;
		}
		Skip_Blanks(ch, file)
		if (ch == EOF || ch == '\n') {
			ecode = e_cmd;
			goto eof;
		}
	}
	unget_char(ch, file);

	/* Everything up to the next \n or EOF is part of the command...
	 * too bad we don't know in advance how long it will be, since we
	 * need to malloc a string for it... so, we limit it to MAX_COMMAND.
	 */
	ch = get_string(cmd, MAX_COMMAND, file, "\n");

	/* a file without a \n before the EOF is rude, so we'll complain...
	 */
	if (ch == EOF) {
		ecode = e_cmd;
		goto eof;
	}

	/* got the command in the 'cmd' string; save it in *e.
	 */
	if ((e->cmd = strdup(cmd)) == NULL) {
		ecode = e_memory;
		goto eof;
	}

	/* success, fini, return pointer to the entry we just created...
	 */
	return (e);

 eof:
	if (e)
		free_entry(e);
	while (ch != '\n' && !feof(file))
		ch = get_char(file);
	if (ecode != e_none && error_func)
		(*error_func)(ecodes[(int)ecode]);
	return (NULL);
}

static int
get_list(bitstr_t *bits, int low, int high, const char *names[],
	 int ch, FILE *file)
{
	int done;

	/* we know that we point to a non-blank character here;
	 * must do a Skip_Blanks before we exit, so that the
	 * next call (or the code that picks up the cmd) can
	 * assume the same thing.
	 */

	/* list = range {"," range}
	 */

	/* clear the bit string, since the default is 'off'.
	 */
	bit_nclear(bits, 0, (high-low+1));

	/* process all ranges
	 */
	done = FALSE;
	while (!done) {
		if (EOF == (ch = get_range(bits, low, high, names, ch, file)))
			return (EOF);
		if (ch == ',')
			ch = get_char(file);
		else
			done = TRUE;
	}

	/* exiting.  skip to some blanks, then skip over the blanks.
	 */
	Skip_Nonblanks(ch, file)
	Skip_Blanks(ch, file)

	return (ch);
}


static int
get_range(bitstr_t *bits, int low, int high, const char *names[],
	  int ch, FILE *file)
{
	/* range = number | number "-" number [ "/" number ]
	 */

	int i, num1, num2, num3;

	if (ch == '*') {
		/* '*' means "first-last" but can still be modified by /step
		 */
		num1 = low;
		num2 = high;
		ch = get_char(file);
		if (ch == EOF)
			return (EOF);
	} else {
		ch = get_number(&num1, low, names, ch, file, ",- \t\n");
		if (ch == EOF)
			return (EOF);

		if (ch != '-') {
			/* not a range, it's a single number.
			 */
			if (EOF == set_element(bits, low, high, num1)) {
				unget_char(ch, file);
				return (EOF);
			}
			return (ch);
		} else {
			/* eat the dash
			 */
			ch = get_char(file);
			if (ch == EOF)
				return (EOF);

			/* get the number following the dash
			 */
			ch = get_number(&num2, low, names, ch, file, "/, \t\n");
			if (ch == EOF || num1 > num2)
				return (EOF);
		}
	}

	/* check for step size
	 */
	if (ch == '/') {
		/* eat the slash
		 */
		ch = get_char(file);
		if (ch == EOF)
			return (EOF);

		/* get the step size -- note: we don't pass the
		 * names here, because the number is not an
		 * element id, it's a step size.  'low' is
		 * sent as a 0 since there is no offset either.
		 */
		ch = get_number(&num3, 0, NULL, ch, file, ", \t\n");
		if (ch == EOF || num3 == 0)
			return (EOF);
	} else {
		/* no step.  default==1.
		 */
		num3 = 1;
	}

	/* range. set all elements from num1 to num2, stepping
	 * by num3.  (the step is a downward-compatible extension
	 * proposed conceptually by bob@@acornrc, syntactically
	 * designed then implemented by paul vixie).
	 */
	for (i = num1;  i <= num2;  i += num3)
		if (EOF == set_element(bits, low, high, i)) {
			unget_char(ch, file);
			return (EOF);
		}

	return (ch);
}

static int
get_number(int *numptr, int low, const char *names[], int ch, FILE *file,
    const char *terms)
{
	char temp[MAX_TEMPSTR], *pc;
	int len, i;

	pc = temp;
	len = 0;

	/* first look for a number */
	while (isdigit((unsigned char)ch)) {
		if (++len >= MAX_TEMPSTR)
			goto bad;
		*pc++ = ch;
		ch = get_char(file);
	}
	*pc = '\0';
	if (len != 0) {
		/* got a number, check for valid terminator */
		if (!strchr(terms, ch))
			goto bad;
		*numptr = atoi(temp);
		return (ch);
	}

	/* no numbers, look for a string if we have any */
	if (names) {
		while (isalpha((unsigned char)ch)) {
			if (++len >= MAX_TEMPSTR)
				goto bad;
			*pc++ = ch;
			ch = get_char(file);
		}
		*pc = '\0';
		if (len != 0 && strchr(terms, ch)) {
			for (i = 0;  names[i] != NULL;  i++) {
				if (!strcasecmp(names[i], temp)) {
					*numptr = i+low;
					return (ch);
				}
			}
		}
	}

bad:
	unget_char(ch, file);
	return (EOF);
}

static int
set_element(bitstr_t *bits, int low, int high, int number)
{

	if (number < low || number > high)
		return (EOF);

	bit_set(bits, (number-low));
	return (0);
}
@


1.47
log
@Remove unused xpid argument to log_it().
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.46 2015/11/08 14:40:23 millert Exp $	*/
d29 1
d294 1
a294 1
			log_it("CRON", "error", "can't set SHELL");
d306 1
a306 1
			log_it("CRON", "error", "can't set HOME");
d317 1
a317 1
		log_it("CRON", "error", "can't set LOGNAME");
d327 1
a327 1
		log_it("CRON", "error", "can't set USER");
@


1.46
log
@Quiet silly clang analyzer warning in calloc() usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.45 2015/11/04 20:28:17 millert Exp $	*/
d293 1
a293 1
			log_it("CRON", getpid(), "error", "can't set SHELL");
d305 1
a305 1
			log_it("CRON", getpid(), "error", "can't set HOME");
d316 1
a316 1
		log_it("CRON", getpid(), "error", "can't set LOGNAME");
d326 1
a326 1
		log_it("CRON", getpid(), "error", "can't set USER");
@


1.45
log
@Change cron from including all headers in every file to only including
what each .c file needs.  I have not removed cron.h since it will
be used in a future clean up of the cron's .h files.  OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.44 2015/11/04 12:53:05 millert Exp $	*/
d120 1
a120 1
	e = calloc(sizeof(entry), sizeof(char));
@


1.44
log
@Change some globals from extern to static when they are not used
outside their respective .c files.  Also remove some unused defines.
OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.43 2015/10/26 14:27:41 millert Exp $	*/
d21 15
a35 1
#include "cron.h"
@


1.43
log
@Remove some useless defines and the set_cron_uid() function.
OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.42 2015/10/06 14:58:37 tedu Exp $	*/
d28 24
a51 14
static const char *ecodes[] =
	{
		"no error",
		"bad minute",
		"bad hour",
		"bad day-of-month",
		"bad month",
		"bad day-of-week",
		"bad command",
		"bad time specifier",
		"bad username",
		"bad option",
		"out of memory"
	};
@


1.42
log
@clear out some more legacy code and whatnot
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.41 2015/10/03 12:46:54 tedu Exp $	*/
d168 1
a168 1
			      PPC_NULL, ch, file);
d180 1
a180 1
			      PPC_NULL, ch, file);
d192 1
a192 1
			      PPC_NULL, ch, file);
d465 1
a465 1
		ch = get_number(&num3, 0, PPC_NULL, ch, file, ", \t\n");
@


1.41
log
@unifdef some features we will always have. ok benno zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.40 2015/02/09 22:35:08 deraadt Exp $	*/
a18 6
 */

/* vix 26jan87 [RCS'd; rest of log is in RCS file]
 * vix 01jan87 [added line-level error recovery]
 * vix 31dec86 [added /step to the from-to range, per bob@@acornrc]
 * vix 30dec86 [written]
@


1.40
log
@correct copyright, upon approval from paul vixie via todd miller.  the
head copyright assertion was seperated from the remaining ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.39 2015/01/23 19:07:27 tedu Exp $	*/
a295 15
#ifndef LOGIN_CAP
	/* If login.conf is in use we will get the default PATH later. */
	if (!env_get("PATH", e->envp)) {
		if (snprintf(envstr, sizeof envstr, "PATH=%s", _PATH_DEFPATH) >=
		    sizeof(envstr))
			log_it("CRON", getpid(), "error", "can't set PATH");
		else {
			if ((tenvp = env_set(e->envp, envstr)) == NULL) {
				ecode = e_memory;
				goto eof;
			}
			e->envp = tenvp;
		}
	}
#endif /* LOGIN_CAP */
@


1.39
log
@braces to open a function go on their own line like god intended
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.38 2015/01/23 02:37:25 tedu Exp $	*/
a4 4
 * All rights reserved
 */

/*
@


1.38
log
@Remove the OK and ERR macros. They obfuscate the code and don't
help legibility. (unix system calls use 0 for ok, but hundreds of
other projects use 1 to indicate success.) Despite the name, many
system calls (e.g., open) also return not OK values for success.
It also cleans up some weird code like int crontab_fd = OK - 1;
This diff is mechanical in nature. Later I will fix the bugs it reveals.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.37 2015/01/23 01:01:06 tedu Exp $	*/
d59 2
a60 1
free_entry(entry *e) {
d73 2
a74 1
    char **envp) {
d515 2
a516 1
    const char *terms) {
d564 2
a565 1
set_element(bitstr_t *bits, int low, int high, int number) {
@


1.37
log
@remove debug code.
I think the level of debug code in cron is excessive for a program
that has reached feature complete. If cron needs to provide more
information to the user about its operational status, I think syslog
would be more appropriate. (The debug flags also disable forking
into the background, so they aren't even that useful for debugging a
live system.)
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.36 2015/01/22 22:38:55 tedu Exp $	*/
d567 1
a567 1
	return (OK);
@


1.36
log
@delete useless casts. ok deraadt guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.35 2015/01/14 17:27:51 millert Exp $	*/
a92 2
	Debug(DPARS, ("load_entry()...about to eat comments\n"))

a172 2
		Debug(DPARS, ("load_entry()...about to parse numerics\n"))

a246 1
		Debug(DPARS, ("load_entry()...about to parse username\n"))
a248 1
		Debug(DPARS, ("load_entry()...got %s\n",username))
a258 3
		Debug(DPARS, ("load_entry()...uid %lu, gid %lu\n",
			      (unsigned long)pw->pw_uid,
			      (unsigned long)pw->pw_gid))
a333 2
	Debug(DPARS, ("load_entry()...about to parse command\n"))

a374 2
	Debug(DPARS, ("load_entry()...returning successfully\n"))

a400 2
	Debug(DPARS|DEXT, ("get_list()...entered\n"))

a424 2
	Debug(DPARS|DEXT, ("get_list()...exiting w/ %02x\n", ch))

a437 2
	Debug(DPARS|DEXT, ("get_range()...entering, exit won't show\n"))

a546 3
				Debug(DPARS|DEXT,
					("get_num, compare(%s,%s)\n", names[i],
					temp))
a561 1
	Debug(DPARS|DEXT, ("set_element(?,%d,%d,%d)\n", low, high, number))
@


1.35
log
@Use HAVE_FOO for BSD-specific features instead of relying on the
BSD macro from sys/param.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.34 2014/08/25 07:50:26 doug Exp $	*/
d106 1
a106 1
	e = (entry *) calloc(sizeof(entry), sizeof(char));
@


1.34
log
@Delete secret or secret-derived data with explicit_bzero.

concept ok deraadt@@
diff looks ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.33 2011/05/19 15:00:17 phessler Exp $	*/
a331 1
#if defined(BSD) || defined(__linux)
a341 1
#endif
@


1.33
log
@Fix some possible NULL pointer dereferences, and a little bit of cleanup.

From Lawrence Teo (thanks!)

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.32 2009/10/29 18:56:47 markus Exp $	*/
d274 1
a274 1
	bzero(e->pwd->pw_passwd, strlen(e->pwd->pw_passwd));
@


1.32
log
@do not discard the first character of the command after the -q option
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.31 2009/10/27 23:59:51 deraadt Exp $	*/
d62 2
a63 1
	env_free(e->envp);
d107 4
d395 2
a396 7
	if (e->envp)
		env_free(e->envp);
	if (e->pwd)
		free(e->pwd);
	if (e->cmd)
		free(e->cmd);
	free(e);
@


1.31
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.30 2005/01/30 20:44:50 millert Exp $	*/
d344 2
a345 1
	while ((ch = get_char(file)) == '-') {
@


1.30
log
@fix some whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.29 2004/06/22 21:02:19 avsm Exp $	*/
a23 4

#if !defined(lint) && !defined(LINT)
static char const rcsid[] = "$OpenBSD: entry.c,v 1.29 2004/06/22 21:02:19 avsm Exp $";
#endif
@


1.29
log
@Recent glue_strings change reversed a few checks; fix up conditionals
to check for overflow as others do by convention.

Noticed by Andreas Kahari <ak+openbsd at freeshell.org>, millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.28 2004/06/22 03:15:33 avsm Exp $	*/
d26 1
a26 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.28 2004/06/22 03:15:33 avsm Exp $";
d74 2
a75 1
load_entry(FILE *file, void (*error_func)(const char *), struct passwd *pw, char **envp) {
@


1.28
log
@use snprintf(3) instead of home-grown glue_strings() function
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.27 2004/06/17 22:11:55 millert Exp $	*/
d26 1
a26 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.27 2004/06/17 22:11:55 millert Exp $";
d283 3
a285 1
		    sizeof(envstr)) {
d291 1
a291 2
		} else
			log_it("CRON", getpid(), "error", "can't set SHELL");
d295 3
a297 1
		    sizeof(envstr)) {
d303 1
a303 2
		} else
			log_it("CRON", getpid(), "error", "can't set HOME");
d309 3
a311 1
		    sizeof(envstr)) {
d317 1
a317 2
		} else
			log_it("CRON", getpid(), "error", "can't set PATH");
d321 3
a323 1
		sizeof(envstr)) {
d329 1
a329 2
	} else
		log_it("CRON", getpid(), "error", "can't set LOGNAME");
d332 3
a334 1
		sizeof(envstr)) {
d340 1
a340 2
	} else
		log_it("CRON", getpid(), "error", "can't set USER");
@


1.27
log
@UUpdate ISC copyright year to 2004
Remove unused macros Skip_Line and MkLower
Remove trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.26 2003/06/26 00:13:38 deraadt Exp $	*/
d26 1
a26 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.26 2003/06/26 00:13:38 deraadt Exp $";
d282 2
a283 2
		if (glue_strings(envstr, sizeof envstr, "SHELL",
				 _PATH_BSHELL, '=')) {
d293 2
a294 2
		if (glue_strings(envstr, sizeof envstr, "HOME",
				 pw->pw_dir, '=')) {
d306 2
a307 2
		if (glue_strings(envstr, sizeof envstr, "PATH",
				 _PATH_DEFPATH, '=')) {
d317 2
a318 2
	if (glue_strings(envstr, sizeof envstr, "LOGNAME",
			 pw->pw_name, '=')) {
d327 2
a328 2
	if (glue_strings(envstr, sizeof envstr, "USER",
			 pw->pw_name, '=')) {
@


1.26
log
@two missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.25 2003/04/17 14:10:47 millert Exp $	*/
d9 1
d16 7
a22 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
d26 1
a26 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.25 2003/04/17 14:10:47 millert Exp $";
d263 3
a265 2
		Debug(DPARS, ("load_entry()...uid %ld, gid %ld\n",
			      (long)pw->pw_uid, (long)pw->pw_gid))
d363 1
a363 1
	 */ 
d417 1
a417 1
	
@


1.25
log
@Change a few return values from char to int since these functions
can return EOF.  Fixes gcc warnings (and potential problems) on ppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.24 2003/03/12 18:15:55 millert Exp $	*/
d26 1
a26 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.24 2003/03/12 18:15:55 millert Exp $";
d74 1
a74 1
load_entry(FILE *file, void (*error_func)(), struct passwd *pw, char **envp) {
@


1.24
log
@Move range sanity check out of get_number() and into get_range() since
it was causing problems with symbolic names (and get_range() is really
where it belongs anyway).  Also allow a range to be followed by a ','
as pointed out by mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.23 2003/03/11 17:54:06 millert Exp $	*/
d26 1
a26 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.23 2003/03/11 17:54:06 millert Exp $";
d57 4
a60 4
static char	get_list(bitstr_t *, int, int, const char *[], char, FILE *),
		get_range(bitstr_t *, int, int, const char *[], char, FILE *),
		get_number(int *, int, const char *[], char, FILE *, const char *);
static int	set_element(bitstr_t *, int, int, int);
d400 1
a400 1
static char
d402 1
a402 1
	 char ch, FILE *file)
d444 1
a444 1
static char
d446 1
a446 1
	  char ch, FILE *file)
d528 2
a529 2
static char
get_number(int *numptr, int low, const char *names[], char ch, FILE *file,
@


1.23
log
@Catch more syntax errors that were previously ignored.  I've rewritten
get_number() to be more careful about what it accepts and to take
a string of terminating characters so it knows what is valid.  Also
added a range check so that ranges like "60-50" where the first
number is greater than the second are now flagged.
Thanks to mpech@@ for testing finding ways to abuse the parser :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.22 2003/03/10 15:18:25 millert Exp $	*/
d26 1
a26 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.22 2003/03/10 15:18:25 millert Exp $";
d485 2
a486 2
			ch = get_number(&num2, num1, names, ch, file, "/, \t\n");
			if (ch == EOF)
d505 1
a505 1
		ch = get_number(&num3, 0, PPC_NULL, ch, file, " \t\n");
a549 2
		if (*numptr < low)
			goto bad;
@


1.22
log
@Change a e_username to e_cmd.
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.21 2003/03/10 15:13:33 millert Exp $	*/
d26 1
a26 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.21 2003/03/10 15:13:33 millert Exp $";
d59 1
a59 1
		get_number(int *, int, const char *[], char, FILE *);
d464 2
a465 1
		if (EOF == (ch = get_number(&num1, low, names, ch, file)))
d485 1
a485 1
			ch = get_number(&num2, low, names, ch, file);
d505 1
a505 1
		ch = get_number(&num3, 0, PPC_NULL, ch, file);
d529 2
a530 1
get_number(int *numptr, int low, const char *names[], char ch, FILE *file) {
d532 1
a532 1
	int len, i, all_digits;
a533 2
	/* collect alphanumerics into our fixed-size temp array
	 */
d536 3
a538 2
	all_digits = TRUE;
	while (isalnum((unsigned char)ch)) {
a540 1

a541 4

		if (!isdigit((unsigned char)ch))
			all_digits = FALSE;

d545 9
a553 2
	if (len == 0)
		goto bad;
d555 1
a555 2
	/* try to find the name in the name list
	 */
d557 16
a572 6
		for (i = 0;  names[i] != NULL;  i++) {
			Debug(DPARS|DEXT,
				("get_num, compare(%s,%s)\n", names[i], temp))
			if (!strcasecmp(names[i], temp)) {
				*numptr = i+low;
				return (ch);
a576 8
	/* no name list specified, or there is one and our string isn't
	 * in it.  either way: if it's all digits, use its magnitude.
	 * otherwise, it's an error.
	 */
	if (all_digits) {
		*numptr = atoi(temp);
		return (ch);
	}
@


1.21
log
@Back out changes to get_number() that I didn't intend to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.19 2003/03/09 18:13:02 millert Exp $	*/
d26 1
a26 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.19 2003/03/09 18:13:02 millert Exp $";
d254 1
a254 1
			ecode = e_username;
@


1.20
log
@Do the check for missing command before the un_getchar(); otherwise
the error messages will say line 0.  This is because un_getchar('\n', file)
will decrement the line count.  Noticed by mpech@@
@
text
@d59 1
a59 1
		get_number(int *, int, const char *[], char, FILE *, const char *);
d464 1
a464 2
		ch = get_number(&num1, low, names, ch, file, ",- \t\n");
		if (ch == EOF)
d484 1
a484 1
			ch = get_number(&num2, low, names, ch, file, ",- \t\n");
d504 1
a504 1
		ch = get_number(&num3, 0, PPC_NULL, ch, file, ",- \t\n");
d528 1
a528 2
get_number(int *numptr, int low, const char *names[], char ch, FILE *file,
    const char *terms) {
d530 1
a530 1
	int len, i;
d532 2
d536 2
a537 3

	/* first look for a number */
	while (isdigit((unsigned char)ch)) {
d540 1
d542 4
d549 2
a550 7
	if (len != 0) {
		/* got a number, check for valid terminator */
		if (!strchr(terms, ch))
			goto bad;
		*numptr = atoi(temp);
		return (ch);
	}
d552 2
a553 1
	/* no numbers, look for a string if we have any */
d555 6
a560 16
		while (isalpha((unsigned char)ch)) {
			if (++len >= MAX_TEMPSTR)
				goto bad;
			*pc++ = ch;
			ch = get_char(file);
		}
		*pc = '\0';
		if (len != 0 && strchr(terms, ch)) {
			for (i = 0;  names[i] != NULL;  i++) {
				Debug(DPARS|DEXT,
					("get_num, compare(%s,%s)\n", names[i],
					temp))
				if (!strcasecmp(names[i], temp)) {
					*numptr = i+low;
					return (ch);
				}
d565 8
@


1.19
log
@Fix error line number reporting for syntax errors (noticed by mpech@@).
This is relatively tricky due to the way EOF is overloaded.  Seems to
give a correct line number for all errors I threw at it.
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.18 2003/03/04 21:47:08 millert Exp $	*/
d26 1
a26 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.18 2003/03/04 21:47:08 millert Exp $";
d59 1
a59 1
		get_number(int *, int, const char *[], char, FILE *);
d237 6
d253 1
a253 1
		if (ch == EOF) {
a266 6
	/* check for a command and catch a common typo (an extra '*') */
	if (ch == EOF || ch == '\n' || ch == '*') {
		ecode = e_cmd;
		goto eof;
	}

d464 2
a465 1
		if (EOF == (ch = get_number(&num1, low, names, ch, file)))
d485 1
a485 1
			ch = get_number(&num2, low, names, ch, file);
d505 1
a505 1
		ch = get_number(&num3, 0, PPC_NULL, ch, file);
d529 2
a530 1
get_number(int *numptr, int low, const char *names[], char ch, FILE *file) {
d532 1
a532 1
	int len, i, all_digits;
a533 2
	/* collect alphanumerics into our fixed-size temp array
	 */
d536 3
a538 2
	all_digits = TRUE;
	while (isalnum((unsigned char)ch)) {
a540 1

a541 4

		if (!isdigit((unsigned char)ch))
			all_digits = FALSE;

d545 7
a551 2
	if (len == 0)
		goto bad;
d553 1
a553 2
	/* try to find the name in the name list
	 */
d555 16
a570 6
		for (i = 0;  names[i] != NULL;  i++) {
			Debug(DPARS|DEXT,
				("get_num, compare(%s,%s)\n", names[i], temp))
			if (!strcasecmp(names[i], temp)) {
				*numptr = i+low;
				return (ch);
a574 8
	/* no name list specified, or there is one and our string isn't
	 * in it.  either way: if it's all digits, use its magnitude.
	 * otherwise, it's an error.
	 */
	if (all_digits) {
		*numptr = atoi(temp);
		return (ch);
	}
@


1.18
log
@Deref the correct passwd pointer in a Debug statement.
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.17 2003/02/27 15:02:44 millert Exp $	*/
d26 1
a26 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.17 2003/02/27 15:02:44 millert Exp $";
d77 1
a77 1
	 * EOF if for any reason the entry can't be read and parsed.
d168 1
a168 1
		if (ch == EOF) {
d244 1
a244 1
		ch = get_string(username, MAX_COMMAND, file, " \t");
d248 1
a248 1
			ecode = e_cmd;
d259 4
a262 1
	} else if (ch == '*') {
d352 4
d393 2
a396 2
	while (ch != EOF && ch != '\n')
		ch = get_char(file);
d425 2
a426 1
		ch = get_range(bits, low, high, names, ch, file);
d470 2
a471 1
			if (EOF == set_element(bits, low, high, num1))
d473 1
d519 2
a520 1
		if (EOF == set_element(bits, low, high, i))
d522 1
d539 1
a539 1
			return (EOF);
d550 1
a550 1
		return (EOF);
d573 2
a574 1

@


1.17
log
@Fix parsing of '0' and non-alphanumerics in steps; found by mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.16 2003/02/20 20:38:08 millert Exp $	*/
d26 1
a26 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.16 2003/02/20 20:38:08 millert Exp $";
d258 1
a258 1
			      (long)e->pwd->pw_uid, (long)e->pwd->pw_gid))
@


1.16
log
@Sync with ISC cron-current + my at(1) integration.
The at(1) code is now more tightly integrated into the cron codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.15 2002/08/10 20:28:51 millert Exp $	*/
d26 1
a26 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.15 2002/08/10 20:28:51 millert Exp $";
d495 1
a495 1
		if (ch == EOF)
d537 2
@


1.15
log
@Just zero out pw_passwd in the pw_dup()'d copy.  There's no need
to do this elsewhere and my previous commit in this area caused
problems on systems with an /etc/crontab file.
@
text
@d1 2
a2 1
/*	$OpenBSD: entry.c,v 1.14 2002/08/07 23:22:41 millert Exp $	*/
d26 1
a26 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.14 2002/08/07 23:22:41 millert Exp $";
d252 2
a253 1
		if ((pw = getpwnam(username)) == NULL) {
d299 2
a300 1
#ifdef LOGIN_CAP
d322 1
a322 1
#if defined(BSD)
d525 1
a525 1
	while (isalnum(ch)) {
d531 1
a531 1
		if (!isdigit(ch))
@


1.14
log
@paranoia: zero out pw_passwd since we don't need it
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.13 2002/07/15 19:13:29 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.13 2002/07/15 19:13:29 millert Exp $";
a254 1
		bzero(pw->pw_passwd, strlen(pw->pw_passwd));
d266 1
@


1.13
log
@Move atrun(8) functionality into cron(8) proper.  This fixes the
long-standing annoyance that atrun's granularity is 10 minutes.
Most at jobs run with a 1 minute granularity.  Jobs submitted via
"at now" or "batch" will run immediately.  Includes a rewritten
cron(8) man page.  at(1) will be integrated more closely into
cron at a future date.

Upgrading notes:
    the atrun job in root's crontab should be removed.
    the /var/at/spool directory is no longer used
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.12 2002/07/11 20:15:40 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.12 2002/07/11 20:15:40 millert Exp $";
d251 1
a251 2
		pw = getpwnam(username);
		if (pw == NULL) {
d255 1
@


1.12
log
@More syncing with my cron 4.0 patch tree, basically cosmetic:
o change an instance of e_none to e_memory that I missed (forgot?)
o kill some whitespace
o modify malloc failure recovery a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.11 2002/07/11 19:29:36 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.11 2002/07/11 19:29:36 millert Exp $";
d64 1
d257 1
a257 1
			      (long)e->uid, (long)e->gid))
d263 4
a266 2
	e->uid = pw->pw_uid;
	e->gid = pw->pw_gid;
d378 2
@


1.11
log
@Add a new error code for memory allocation failures, e_memory and
use that instead of e_none when we run out of memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.10 2002/07/08 18:11:02 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.10 2002/07/08 18:11:02 millert Exp $";
d362 1
a362 1
		ecode = e_none;
@


1.10
log
@Merge in some changes from Paul Vixie's tree; most are cosmetic
o ANSI function headers
o return (foo) not return foo
o add -oi to sendmail flags
o update email address in man pages
o make some strings const
o completely remove globbing cruft from popen.c
o whitespace changes
o add DOW_STAR to flags for "monthly", "weekly", and "daily" cron entries
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.9 2002/06/14 21:35:01 todd Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: entry.c,v 1.9 2002/06/14 21:35:01 todd Exp $";
d38 1
a38 1
	e_cmd, e_timespec, e_username, e_option
d52 2
a53 1
		"bad option"
d269 1
a269 1
		ecode = e_none;
d275 2
a276 4
			if ((tenvp = env_set(e->envp, envstr))) {
				e->envp = tenvp;
			} else {
				ecode = e_none;
d279 1
d286 2
a287 4
			if ((tenvp = env_set(e->envp, envstr))) {
				e->envp = tenvp;
			} else {
				ecode = e_none;
d290 1
d298 2
a299 4
			if ((tenvp = env_set(e->envp, envstr))) {
				e->envp = tenvp;
			} else {
				ecode = e_none;
d302 1
d309 2
a310 4
		if ((tenvp = env_set(e->envp, envstr))) {
			e->envp = tenvp;
		} else {
			ecode = e_none;
d313 1
d319 2
a320 4
		if ((tenvp = env_set(e->envp, envstr))) {
			e->envp = tenvp;
		} else {
			ecode = e_none;
d323 1
@


1.9
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: entry.c,v 1.8 2001/02/18 19:48:33 millert Exp $	*/
d25 1
a25 1
static char rcsid[] = "$OpenBSD: entry.c,v 1.8 2001/02/18 19:48:33 millert Exp $";
a33 1

a35 1

d55 3
a57 3
static char	get_list(bitstr_t *, int, int, const char *[], int, FILE *),
		get_range(bitstr_t *, int, int, const char *[], int, FILE *),
		get_number(int *, int, const char *[], int, FILE *);
d61 1
a61 3
free_entry(e)
	entry	*e;
{
a66 1

d71 1
a71 6
load_entry(file, error_func, pw, envp)
	FILE		*file;
	void		(*error_func)();
	struct passwd	*pw;
	char		**envp;
{
d86 5
a90 5
	entry	*e;
	int	ch;
	char	cmd[MAX_COMMAND];
	char	envstr[MAX_ENVSTR];
	char	**tenvp;
d98 1
a98 1
		return NULL;
d129 1
d136 1
d143 1
d374 1
a374 1
	return e;
d386 1
a386 1
	return NULL;
a388 1

d390 2
a391 6
get_list(bits, low, high, names, ch, file)
	bitstr_t	*bits;		/* one bit per flag, default=FALSE */
	int		low, high;	/* bounds, impl. offset for bitstr */
	const char	*names[];	/* NULL or *[] of names for these elements */
	int		ch;		/* current character being processed */
	FILE		*file;		/* file being read */
d428 1
a428 1
	return ch;
d433 2
a434 6
get_range(bits, low, high, names, ch, file)
	bitstr_t	*bits;		/* one bit per flag, default=FALSE */
	int		low, high;	/* bounds, impl. offset for bitstr */
	const char	*names[];	/* NULL or names of elements */
	int		ch;		/* current character being processed */
	FILE		*file;		/* file being read */
d439 1
a439 1
	int	i, num1, num2, num3;
d450 1
a450 1
			return EOF;
d453 1
a453 1
			return EOF;
d459 2
a460 2
				return EOF;
			return ch;
d466 1
a466 1
				return EOF;
d472 1
a472 1
				return EOF;
d483 1
a483 1
			return EOF;
d492 1
a492 1
			return EOF;
d506 1
a506 1
			return EOF;
d508 1
a508 1
	return ch;
a510 1

d512 3
a514 9
get_number(numptr, low, names, ch, file)
	int		*numptr;	/* where does the result go? */
	int		low;		/* offset applied to enum result */
	const char	*names[];	/* symbolic names, if any, for enums */
	int		ch;		/* current character */
	FILE		*file;		/* source */
{
	char	temp[MAX_TEMPSTR], *pc;
	int	len, i, all_digits;
d523 1
a523 1
			return EOF;
d542 1
a542 1
				return ch;
d553 1
a553 1
		return ch;
d556 1
a556 1
	return EOF;
a558 1

d560 1
a560 6
set_element(bits, low, high, number)
	bitstr_t	*bits; 		/* one bit per flag, default=FALSE */
	int		low;
	int		high;
	int		number;
{
d564 1
a564 1
		return EOF;
d567 1
a567 1
	return OK;
@


1.8
log
@Update to ISC cron 4.0b1 + our patches.  This is now under a BSD license.
I also fixed the signal handlers while I was at it.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d25 1
a25 1
static char rcsid[] = "$OpenBSD: entry.c,v 1.4 2000/01/02 20:53:41 vixie Exp $";
d235 1
a235 1
	/* make sundays equivilent */
d518 1
a518 1
	 * designed then implmented by paul vixie).
@


1.7
log
@snprintf sprinkles; solar@@false.com & I
@
text
@d1 3
a3 1
/* Copyright 1988,1990,1993,1994 by Paul Vixie
d5 4
d10 3
a12 8
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
d14 8
a21 3
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@@vix.com>          uunet!decwrl!vixie!paul
d25 1
a25 1
static char rcsid[] = "$Id: entry.c,v 1.6 2000/03/18 21:23:04 deraadt Exp $";
d40 1
a40 1
	e_cmd, e_timespec, e_username
d43 1
a43 6
static char	get_list __P((bitstr_t *, int, int, char *[], int, FILE *)),
		get_range __P((bitstr_t *, int, int, char *[], int, FILE *)),
		get_number __P((int *, int, char *[], int, FILE *));
static int	set_element __P((bitstr_t *, int, int, int));

static char *ecodes[] =
d54 1
d57 4
d261 2
a262 1
		Debug(DPARS, ("load_entry()...uid %d, gid %d\n",e->uid,e->gid))
d279 10
a288 7
		snprintf(envstr, sizeof envstr, "SHELL=%s", _PATH_BSHELL);
		if ((tenvp = env_set(e->envp, envstr))) {
			e->envp = tenvp;
		} else {
			ecode = e_none;
			goto eof;
		}
d291 27
a317 1
		snprintf(envstr, sizeof envstr, "HOME=%s", pw->pw_dir);
d324 5
a328 3
	}
	if (!env_get("PATH", e->envp)) {
		snprintf(envstr, sizeof envstr, "PATH=%s", _PATH_DEFPATH);
d335 2
a336 16
	}
	snprintf(envstr, sizeof envstr, "%s=%s", "LOGNAME", pw->pw_name);
	if ((tenvp = env_set(e->envp, envstr))) {
		e->envp = tenvp;
	} else {
		ecode = e_none;
		goto eof;
	}
#if defined(BSD)
	snprintf(envstr, sizeof envstr, "%s=%s", "USER", pw->pw_name);
	if ((tenvp = env_set(e->envp, envstr))) {
		e->envp = tenvp;
	} else {
		ecode = e_none;
		goto eof;
	}
d341 16
a359 1
	 * XXX - should use realloc().
d401 1
a401 1
	char		*names[];	/* NULL or *[] of names for these elements */
d405 1
a405 1
	register int	done;
d448 1
a448 1
	char		*names[];	/* NULL or names of elements */
d455 1
a455 2
	register int	i;
	auto int	num1, num2, num3;
d530 5
a534 5
	int	*numptr;	/* where does the result go? */
	int	low;		/* offset applied to result if symbolic enum used */
	char	*names[];	/* symbolic names, if any, for enums */
	int	ch;		/* current character */
	FILE	*file;		/* source */
@


1.6
log
@fix parsing of commands after @@ keywords and hourly bitmap handling;
sheldonh@@uunet.co.za
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: entry.c,v 1.5 1997/12/22 08:10:43 deraadt Exp $";
d290 1
a290 1
		sprintf(envstr, "PATH=%s", _PATH_DEFPATH);
@


1.5
log
@handle timing normally except when clock jumps between 1 and 3 hours. If it
jumps, attempt as best as possible to gaurantee that jobs DO run, but only
run ONCE; patch by thompson@@.tgsoft.com
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: entry.c,v 1.4 1996/12/16 18:40:53 deraadt Exp $";
d153 1
a153 1
			bit_set(e->hour, (LAST_HOUR-FIRST_HOUR+1));
d160 8
@


1.4
log
@avoid more oflows; at this stage paranoia exceeds reality by a lot since our passwd suite is fascist
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: entry.c,v 1.3 1996/12/14 20:20:42 millert Exp $";
d157 1
d165 2
d177 2
d249 2
a250 2
	    ecode = e_cmd;
	    goto eof;
@


1.3
log
@Check to make sure first char of command is not '*' since that will
alway be a syntax error.
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: entry.c,v 1.2 1996/11/01 23:27:32 millert Exp $";
d259 1
a259 1
		sprintf(envstr, "SHELL=%s", _PATH_BSHELL);
d268 1
a268 1
		sprintf(envstr, "HOME=%s", pw->pw_dir);
d285 1
a285 1
	sprintf(envstr, "%s=%s", "LOGNAME", pw->pw_name);
d293 1
a293 1
	sprintf(envstr, "%s=%s", "USER", pw->pw_name);
@


1.2
log
@Check malloc/strdup ret val and deal.
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: entry.c,v 1.1.1.1 1995/10/18 08:47:30 deraadt Exp $";
d243 3
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: entry.c,v 1.1.1.4 1994/01/20 02:47:23 jtc Exp $";
d94 1
d251 4
a254 1
	e->envp = env_copy(envp);
d257 6
a262 1
		e->envp = env_set(e->envp, envstr);
d266 6
a271 1
		e->envp = env_set(e->envp, envstr);
d275 6
a280 1
		e->envp = env_set(e->envp, envstr);
d283 6
a288 1
	e->envp = env_set(e->envp, envstr);
d291 6
a296 1
	e->envp = env_set(e->envp, envstr);
d317 4
a320 1
	e->cmd = strdup(cmd);
d329 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
