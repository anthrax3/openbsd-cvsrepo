head	1.74;
access;
symbols
	OPENBSD_6_1:1.74.0.8
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.74.0.4
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.74.0.2
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.52.0.6
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.44.0.8
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.44.0.6
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.44.0.2
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.43.0.6
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.4
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.2
	OPENBSD_5_0:1.42.0.4
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.41.0.4
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.40.0.6
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.40.0.2
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.39.0.8
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.6
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.4
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.39.0.2
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.38.0.4
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.36.0.6
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.36.0.4
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.36.0.2
	OPENBSD_3_6_BASE:1.36
	OPENBSD_3_5:1.32.0.6
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.32.0.4
	OPENBSD_3_4_BASE:1.32
	OPENBSD_3_3:1.32.0.2
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.74
date	2016.01.11.14.23.50;	author millert;	state Exp;
branches;
next	1.73;
commitid	fFP0tihUFMiVcTny;

1.73
date	2015.11.15.23.24.24;	author millert;	state Exp;
branches;
next	1.72;
commitid	4K3ElIFSUCsF9sYF;

1.72
date	2015.11.14.13.11.32;	author millert;	state Exp;
branches;
next	1.71;
commitid	vlec67MEsDjesgaR;

1.71
date	2015.11.14.13.09.14;	author millert;	state Exp;
branches;
next	1.70;
commitid	KNISMJYcyEJqWs74;

1.70
date	2015.11.12.21.12.05;	author millert;	state Exp;
branches;
next	1.69;
commitid	6PlWoK7FsQNDGZmn;

1.69
date	2015.11.12.13.42.42;	author millert;	state Exp;
branches;
next	1.68;
commitid	AAqNUppFHDG90rxe;

1.68
date	2015.11.11.17.19.22;	author millert;	state Exp;
branches;
next	1.67;
commitid	RKqdXm2nalY1uBoL;

1.67
date	2015.11.11.03.20.19;	author deraadt;	state Exp;
branches;
next	1.66;
commitid	k7AlPVNQ11MxkzxY;

1.66
date	2015.11.09.16.37.07;	author millert;	state Exp;
branches;
next	1.65;
commitid	ZJUG9DwHA5l6WcX2;

1.65
date	2015.11.09.15.57.39;	author millert;	state Exp;
branches;
next	1.64;
commitid	JJzvBekc1nrVHuHQ;

1.64
date	2015.11.09.01.12.27;	author millert;	state Exp;
branches;
next	1.63;
commitid	NbIbD3dCbvLEHSye;

1.63
date	2015.11.06.23.47.42;	author millert;	state Exp;
branches;
next	1.62;
commitid	8eaJrEU7qiymGijK;

1.62
date	2015.11.04.20.28.17;	author millert;	state Exp;
branches;
next	1.61;
commitid	6N0oXtYc5KM1a7DW;

1.61
date	2015.11.04.12.53.05;	author millert;	state Exp;
branches;
next	1.60;
commitid	2QMTGnuouMIAKrAq;

1.60
date	2015.10.31.12.14.16;	author millert;	state Exp;
branches;
next	1.59;
commitid	mULiWxUknwzu04t4;

1.59
date	2015.10.29.21.24.09;	author millert;	state Exp;
branches;
next	1.58;
commitid	W6mUaaYqUFrjIBIo;

1.58
date	2015.10.28.20.17.31;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	UvqbYTR2CmTeyJXL;

1.57
date	2015.10.26.15.16.30;	author millert;	state Exp;
branches;
next	1.56;
commitid	e24e7qBO9dHlxEtO;

1.56
date	2015.10.26.14.27.41;	author millert;	state Exp;
branches;
next	1.55;
commitid	k893fgzG4z9i5qIx;

1.55
date	2015.10.25.21.30.11;	author millert;	state Exp;
branches;
next	1.54;
commitid	Z2UkA4v651dEbyJ1;

1.54
date	2015.10.03.12.46.54;	author tedu;	state Exp;
branches;
next	1.53;
commitid	WlajD40E0eJCM3xO;

1.53
date	2015.08.25.20.09.27;	author millert;	state Exp;
branches;
next	1.52;
commitid	SFdjIC9WT8rSna3R;

1.52
date	2015.02.09.22.35.08;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	eGq01x6bjr83TVho;

1.51
date	2015.01.23.19.07.27;	author tedu;	state Exp;
branches;
next	1.50;
commitid	YJA2vmvfLuMfGdwZ;

1.50
date	2015.01.23.01.03.03;	author tedu;	state Exp;
branches;
next	1.49;
commitid	tWLCGXaX7sMf6hkJ;

1.49
date	2015.01.23.01.01.06;	author tedu;	state Exp;
branches;
next	1.48;
commitid	kzBIhYnXdVeOLxgw;

1.48
date	2015.01.22.22.38.55;	author tedu;	state Exp;
branches;
next	1.47;
commitid	F47ioXLOlSmeY3jW;

1.47
date	2015.01.14.17.27.29;	author millert;	state Exp;
branches;
next	1.46;
commitid	jXmo2gNqOzD6QEsx;

1.46
date	2014.11.26.18.34.52;	author millert;	state Exp;
branches;
next	1.45;
commitid	9QOFSShUOtA0kQLF;

1.45
date	2014.10.29.04.39.02;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	a5uifLuQvX2DkoEc;

1.44
date	2013.04.17.15.58.45;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2011.08.22.19.32.42;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2011.01.18.14.09.54;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2009.01.29.22.50.16;	author sobrado;	state Exp;
branches;
next	1.39;

1.39
date	2007.02.18.23.59.03;	author jmc;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.15.07.02.37;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.15.03.15.29;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.17.22.11.55;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2004.06.03.19.54.04;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.13.13.54.52;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.03.15.10.21;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.10.15.27.17;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.02.20.20.38.08;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.18.02.43.06;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.17.18.40.11;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.08.08.18.13.35;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.15.19.13.29;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.09.18.59.12;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.08.18.11.02;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.28.01.20.19;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.22.17.19.15;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.21.20.57.32;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.20.23.33.31;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.09.21.22.01;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.16.21.28.01;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.20.23.27.47;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.11.04.14.00;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.24.17.28.16;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.11.20.47.14;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.13.03.28.48;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.21.18.13.31;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.20.02.03.19;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.19.14.33.32;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.18.19.48.31;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.19.17.53.12;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.15.07.13.50;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.21.00.39.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.05.23.17.19.23;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	98.03.30.06.59.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.12.22.08.10.41;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.08.04.19.26.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.09.15.09.28.14;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.30;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.74
log
@When caching the mtime of the spool directory and system crontab files,
stash a struct timespec, not just a time_t.  Fixes a bug where cron
could skip re-reading the spool after two consecutive changes.
@
text
@/*	$OpenBSD: cron.c,v 1.73 2015/11/15 23:24:24 millert Exp $	*/

/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
 * Copyright (c) 1997,2000 by Internet Software Consortium, Inc.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/un.h>
#include <sys/wait.h>

#include <bitstring.h>
#include <err.h>
#include <errno.h>
#include <grp.h>
#include <locale.h>
#include <poll.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

#include "config.h"
#include "pathnames.h"
#include "macros.h"
#include "structs.h"
#include "funcs.h"
#include "globals.h"

enum timejump { negative, small, medium, large };

static	void	usage(void),
		run_reboot_jobs(cron_db *),
		find_jobs(time_t, cron_db *, int, int),
		set_time(int),
		cron_sleep(time_t, sigset_t *),
		sigchld_handler(int),
		sigchld_reaper(void),
		parse_args(int c, char *v[]);

static	int	open_socket(void);

static	volatile sig_atomic_t	got_sigchld;
static	time_t			timeRunning, virtualTime, clockTime;
static	int			cronSock;
static	long			GMToff;
static	cron_db			*database;
static	at_db			*at_database;
static	double			batch_maxload = BATCH_MAXLOAD;
static	int			NoFork;
static	time_t			StartTime;

static void
usage(void)
{

	fprintf(stderr, "usage: %s [-n] [-l load_avg]\n", __progname);
	exit(EXIT_FAILURE);
}

int
main(int argc, char *argv[])
{
	struct sigaction sact;
	sigset_t blocked, omask;

	setlocale(LC_ALL, "");

	setvbuf(stdout, NULL, _IOLBF, 0);
	setvbuf(stderr, NULL, _IOLBF, 0);

	parse_args(argc, argv);

	bzero((char *)&sact, sizeof sact);
	sigemptyset(&sact.sa_mask);
	sact.sa_flags = SA_RESTART;
	sact.sa_handler = sigchld_handler;
	(void) sigaction(SIGCHLD, &sact, NULL);
	sact.sa_handler = SIG_IGN;
	(void) sigaction(SIGHUP, &sact, NULL);
	(void) sigaction(SIGPIPE, &sact, NULL);

	openlog(__progname, LOG_PID, LOG_CRON);

	if (pledge("stdio rpath wpath cpath fattr getpw unix id dns proc exec",
	    NULL) == -1) {
		warn("pledge");
		syslog(LOG_ERR, "(CRON) PLEDGE (%m)");
		exit(EXIT_FAILURE);
	}

	cronSock = open_socket();

	if (putenv("PATH="_PATH_DEFPATH) < 0) {
		warn("putenv");
		syslog(LOG_ERR, "(CRON) DEATH (%m)");
		exit(EXIT_FAILURE);
	}

	if (NoFork == 0) {
		if (daemon(0, 0) == -1) {
			syslog(LOG_ERR, "(CRON) DEATH (%m)");
			exit(EXIT_FAILURE);
		}
		syslog(LOG_INFO, "(CRON) STARTUP (%s)", CRON_VERSION);
	}

	load_database(&database);
	scan_atjobs(&at_database, NULL);
	set_time(TRUE);
	run_reboot_jobs(database);
	timeRunning = virtualTime = clockTime;

	/*
	 * We block SIGHUP and SIGCHLD while running jobs and receive them
	 * only while sleeping in ppoll().  This ensures no signal is lost.
	 */
	sigemptyset(&blocked);
	sigaddset(&blocked, SIGCHLD);
	sigaddset(&blocked, SIGHUP);
	sigprocmask(SIG_BLOCK, &blocked, &omask);

	/*
	 * Too many clocks, not enough time (Al. Einstein)
	 * These clocks are in minutes since the epoch, adjusted for timezone.
	 * virtualTime: is the time it *would* be if we woke up
	 * promptly and nobody ever changed the clock. It is
	 * monotonically increasing... unless a timejump happens.
	 * At the top of the loop, all jobs for 'virtualTime' have run.
	 * timeRunning: is the time we last awakened.
	 * clockTime: is the time when set_time was last called.
	 */
	while (TRUE) {
		int timeDiff;
		enum timejump wakeupKind;

		/* ... wait for the time (in minutes) to change ... */
		do {
			cron_sleep(timeRunning + 1, &omask);
			set_time(FALSE);
		} while (clockTime == timeRunning);
		timeRunning = clockTime;

		/*
		 * Calculate how the current time differs from our virtual
		 * clock.  Classify the change into one of 4 cases.
		 */
		timeDiff = timeRunning - virtualTime;

		/* shortcut for the most common case */
		if (timeDiff == 1) {
			virtualTime = timeRunning;
			find_jobs(virtualTime, database, TRUE, TRUE);
		} else {
			if (timeDiff > (3*MINUTE_COUNT) ||
			    timeDiff < -(3*MINUTE_COUNT))
				wakeupKind = large;
			else if (timeDiff > 5)
				wakeupKind = medium;
			else if (timeDiff > 0)
				wakeupKind = small;
			else
				wakeupKind = negative;

			switch (wakeupKind) {
			case small:
				/*
				 * case 1: timeDiff is a small positive number
				 * (wokeup late) run jobs for each virtual
				 * minute until caught up.
				 */
				do {
					if (job_runqueue())
						sleep(10);
					virtualTime++;
					find_jobs(virtualTime, database,
					    TRUE, TRUE);
				} while (virtualTime < timeRunning);
				break;

			case medium:
				/*
				 * case 2: timeDiff is a medium-sized positive
				 * number, for example because we went to DST
				 * run wildcard jobs once, then run any
				 * fixed-time jobs that would otherwise be
				 * skipped if we use up our minute (possible,
				 * if there are a lot of jobs to run) go
				 * around the loop again so that wildcard jobs
				 * have a chance to run, and we do our
				 * housekeeping.
				 */
				/* run wildcard jobs for current minute */
				find_jobs(timeRunning, database, TRUE, FALSE);

				/* run fixed-time jobs for each minute missed */
				do {
					if (job_runqueue())
						sleep(10);
					virtualTime++;
					find_jobs(virtualTime, database,
					    FALSE, TRUE);
					set_time(FALSE);
				} while (virtualTime< timeRunning &&
				    clockTime == timeRunning);
				break;

			case negative:
				/*
				 * case 3: timeDiff is a small or medium-sized
				 * negative num, eg. because of DST ending.
				 * Just run the wildcard jobs. The fixed-time
				 * jobs probably have already run, and should
				 * not be repeated.  Virtual time does not
				 * change until we are caught up.
				 */
				find_jobs(timeRunning, database, TRUE, FALSE);
				break;
			default:
				/*
				 * other: time has changed a *lot*,
				 * jump virtual time, and run everything
				 */
				virtualTime = timeRunning;
				find_jobs(timeRunning, database, TRUE, TRUE);
			}
		}

		/* Jobs to be run (if any) are loaded; clear the queue. */
		job_runqueue();

		/* Run any jobs in the at queue. */
		atrun(at_database, batch_maxload,
		    timeRunning * SECONDS_PER_MINUTE - GMToff);

		/* Reload jobs as needed. */
		load_database(&database);
		scan_atjobs(&at_database, NULL);
	}
}

static void
run_reboot_jobs(cron_db *db)
{
	user *u;
	entry *e;

	TAILQ_FOREACH(u, &db->users, entries) {
		SLIST_FOREACH(e, &u->crontab, entries) {
			if (e->flags & WHEN_REBOOT)
				job_add(e, u);
		}
	}
	(void) job_runqueue();
}

static void
find_jobs(time_t vtime, cron_db *db, int doWild, int doNonWild)
{
	time_t virtualSecond  = vtime * SECONDS_PER_MINUTE;
	struct tm *tm = gmtime(&virtualSecond);
	int minute, hour, dom, month, dow;
	user *u;
	entry *e;

	/* make 0-based values out of these so we can use them as indices
	 */
	minute = tm->tm_min -FIRST_MINUTE;
	hour = tm->tm_hour -FIRST_HOUR;
	dom = tm->tm_mday -FIRST_DOM;
	month = tm->tm_mon +1 /* 0..11 -> 1..12 */ -FIRST_MONTH;
	dow = tm->tm_wday -FIRST_DOW;

	/* the dom/dow situation is odd.  '* * 1,15 * Sun' will run on the
	 * first and fifteenth AND every Sunday;  '* * * * Sun' will run *only*
	 * on Sundays;  '* * 1,15 * *' will run *only* the 1st and 15th.  this
	 * is why we keep 'e->dow_star' and 'e->dom_star'.  yes, it's bizarre.
	 * like many bizarre things, it's the standard.
	 */
	TAILQ_FOREACH(u, &db->users, entries) {
		SLIST_FOREACH(e, &u->crontab, entries) {
			if (bit_test(e->minute, minute) &&
			    bit_test(e->hour, hour) &&
			    bit_test(e->month, month) &&
			    ( ((e->flags & DOM_STAR) || (e->flags & DOW_STAR))
			      ? (bit_test(e->dow,dow) && bit_test(e->dom,dom))
			      : (bit_test(e->dow,dow) || bit_test(e->dom,dom))
			    )
			   ) {
				if ((doNonWild &&
				    !(e->flags & (MIN_STAR|HR_STAR))) ||
				    (doWild && (e->flags & (MIN_STAR|HR_STAR))))
					job_add(e, u);
			}
		}
	}
}

/*
 * Set StartTime and clockTime to the current time.
 * These are used for computing what time it really is right now.
 * Note that clockTime is a unix wallclock time converted to minutes.
 */
static void
set_time(int initialize)
{
	struct tm tm;
	static int isdst;

	StartTime = time(NULL);

	/* We adjust the time to GMT so we can catch DST changes. */
	tm = *localtime(&StartTime);
	if (initialize || tm.tm_isdst != isdst) {
		isdst = tm.tm_isdst;
		GMToff = get_gmtoff(&StartTime, &tm);
	}
	clockTime = (StartTime + GMToff) / (time_t)SECONDS_PER_MINUTE;
}

/*
 * Try to just hit the next minute.
 */
static void
cron_sleep(time_t target, sigset_t *mask)
{
	int fd, nfds;
	unsigned char poke;
	struct timespec t1, t2, timeout;
	struct sockaddr_un s_un;
	socklen_t sunlen;
	static struct pollfd pfd[1];

	clock_gettime(CLOCK_REALTIME, &t1);
	t1.tv_sec += GMToff;
	timeout.tv_sec = (target * SECONDS_PER_MINUTE - t1.tv_sec) + 1;
	timeout.tv_nsec = 0;

	pfd[0].fd = cronSock;
	pfd[0].events = POLLIN;

	while (timespecisset(&timeout) && timeout.tv_sec < 65) {
		poke = RELOAD_CRON | RELOAD_AT;

		/* Sleep until we time out, get a poke, or get a signal. */
		nfds = ppoll(pfd, 1, &timeout, mask);
		if (nfds == 0)
			break;		/* timer expired */
		if (nfds == -1 && errno != EINTR)
			break;		/* an error occurred */
		if (nfds > 0) {
			sunlen = sizeof(s_un);
			fd = accept4(cronSock, (struct sockaddr *)&s_un,
			    &sunlen, SOCK_NONBLOCK);
			if (fd >= 0) {
				(void) read(fd, &poke, 1);
				close(fd);
				if (poke & RELOAD_CRON) {
					timespecclear(&database->mtime);
					load_database(&database);
				}
				if (poke & RELOAD_AT) {
					/*
					 * We run any pending at jobs right
					 * away so that "at now" really runs
					 * jobs immediately.
					 */
					clock_gettime(CLOCK_REALTIME, &t2);
					timespecclear(&at_database->mtime);
					if (scan_atjobs(&at_database, &t2))
						atrun(at_database,
						    batch_maxload, t2.tv_sec);
				}
			}
		} else {
			/* Interrupted by a signal. */
			if (got_sigchld) {
				got_sigchld = 0;
				sigchld_reaper();
			}
		}

		/* Adjust tv and continue where we left off.  */
		clock_gettime(CLOCK_REALTIME, &t2);
		t2.tv_sec += GMToff;
		timespecsub(&t2, &t1, &t1);
		timespecsub(&timeout, &t1, &timeout);
		memcpy(&t1, &t2, sizeof(t1));
		if (timeout.tv_sec < 0)
			timeout.tv_sec = 0;
		if (timeout.tv_nsec < 0)
			timeout.tv_nsec = 0;
	}
}

/* int open_socket(void)
 *	opens a UNIX domain socket that crontab uses to poke cron.
 *	If the socket is already in use, return an error.
 */
static int
open_socket(void)
{
	int		   sock, rc;
	mode_t		   omask;
	struct group *grp;
	struct sockaddr_un s_un;

	if ((grp = getgrnam(CRON_GROUP)) == NULL)
		syslog(LOG_WARNING, "(CRON) STARTUP (can't find cron group)");

	sock = socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0);
	if (sock == -1) {
		warn("socket");
		syslog(LOG_ERR, "(CRON) DEATH (can't create socket)");
		exit(EXIT_FAILURE);
	}
	bzero(&s_un, sizeof(s_un));
	if (strlcpy(s_un.sun_path, _PATH_CRON_SOCK, sizeof(s_un.sun_path))
	    >= sizeof(s_un.sun_path)) {
		warnc(ENAMETOOLONG, _PATH_CRON_SOCK);
		syslog(LOG_ERR, "(CRON) DEATH (socket path too long)");
		exit(EXIT_FAILURE);
	}
	s_un.sun_family = AF_UNIX;

	if (connect(sock, (struct sockaddr *)&s_un, sizeof(s_un)) == 0) {
		warnx("already running");
		syslog(LOG_ERR, "(CRON) DEATH (already running)");
		exit(EXIT_FAILURE);
	}
	if (errno != ENOENT)
		unlink(s_un.sun_path);

	omask = umask(007);
	rc = bind(sock, (struct sockaddr *)&s_un, sizeof(s_un));
	umask(omask);
	if (rc != 0) {
		warn("bind");
		syslog(LOG_ERR, "(CRON) DEATH (can't bind socket)");
		exit(EXIT_FAILURE);
	}
	if (listen(sock, SOMAXCONN)) {
		warn("listen");
		syslog(LOG_ERR, "(CRON) DEATH (can't listen on socket)");
		exit(EXIT_FAILURE);
	}
	chmod(s_un.sun_path, 0660);
	if (grp != NULL) {
		/* pledge won't let us change files to a foreign group. */
		if (setegid(grp->gr_gid) == 0) {
			chown(s_un.sun_path, -1, grp->gr_gid);
			(void)setegid(getgid());
		}
	}

	return(sock);
}

static void
sigchld_handler(int x)
{
	got_sigchld = 1;
}

static void
sigchld_reaper(void)
{
	int waiter;
	pid_t pid;

	do {
		pid = waitpid(-1, &waiter, WNOHANG);
		switch (pid) {
		case -1:
			if (errno == EINTR)
				continue;
			break;
		case 0:
			break;
		default:
			break;
		}
	} while (pid > 0);
}

static void
parse_args(int argc, char *argv[])
{
	int argch;
	char *ep;

	while (-1 != (argch = getopt(argc, argv, "l:n"))) {
		switch (argch) {
		case 'l':
			errno = 0;
			batch_maxload = strtod(optarg, &ep);
			if (*ep != '\0' || ep == optarg || errno == ERANGE ||
			    batch_maxload < 0) {
				warnx("illegal load average: %s", optarg);
				usage();
			}
			break;
		case 'n':
			NoFork = 1;
			break;
		default:
			usage();
		}
	}
}
@


1.73
log
@Clean up the remaining uses of stderr and perror() and use warn/err
and/or syslog depending on whether stderr is hooked up at the time.
Also remove closelog() which is not needed since we are headed for exec.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.72 2015/11/14 13:11:32 millert Exp $	*/
d23 1
d377 1
a377 1
					database->mtime = 0;
d387 1
a387 1
					at_database->mtime = 0;
@


1.72
log
@Cleanup from unifdef: set sact.sa_flags to SA_RESTART instead of
clearing it and then ORin in SA_RESTART.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.71 2015/11/14 13:09:14 millert Exp $	*/
d27 1
d104 1
d112 1
d430 1
a430 2
		fprintf(stderr, "%s: can't create socket: %s\n",
		    __progname, strerror(errno));
d437 1
a437 1
		fprintf(stderr, "%s: path too long\n", _PATH_CRON_SOCK);
d444 1
a444 1
		fprintf(stderr, "%s: already running\n", __progname);
d455 1
a455 2
		fprintf(stderr, "%s: can't bind socket: %s\n",
		    __progname, strerror(errno));
d460 1
a460 2
		fprintf(stderr, "%s: can't listen on socket: %s\n",
		    __progname, strerror(errno));
d516 1
a516 2
				fprintf(stderr, "Illegal load average: %s\n",
				    optarg);
@


1.71
log
@Remove log_it() and call syslog(3) directly using the same format:
"(username) WHAT (details)".  Logs due to normal operation (e.g.
crontab operations or running commands) are logged at LOG_INFO like
before.  Actual errors are logged at LOG_ERR, less important things
are logged at LOG_WARNING OR LOG_NOTICE.  Also ignore SIGHUP now
that there is no log file to reopen.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.70 2015/11/12 21:12:05 millert Exp $	*/
d92 1
a92 2
	sact.sa_flags = 0;
	sact.sa_flags |= SA_RESTART;
@


1.70
log
@Use absolute paths in pathnames.h.  There is no longer a need to
chdir(2) to the cron dir and cron(8) now changes to / via daemon(3).
We no longer try to create/chmod the spool directories as they
should be set correctly at install time.  The setegid(crontab)
has been moved to open_socket() so it is closer to the chmod(2)
call that needs it.  OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.69 2015/11/12 13:42:42 millert Exp $	*/
d35 1
a53 1
		sighup_handler(int),
d59 1
a59 1
static	volatile sig_atomic_t	got_sighup, got_sigchld;
d96 1
a96 1
	sact.sa_handler = sighup_handler;
a97 1
	sact.sa_handler = SIG_IGN;
d100 2
d104 1
a104 1
		log_it("CRON", "pledge", strerror(errno));
d111 1
a111 1
		log_it("CRON", "DEATH", "can't malloc");
d117 1
a117 1
			log_it("CRON", "DEATH", "can't fork");
d120 1
a120 1
		log_it("CRON", "STARTUP", CRON_VERSION);
a391 4
			if (got_sighup) {
				got_sighup = 0;
				log_close();
			}
d424 1
a424 1
		log_it("CRON", "STARTUP", "can't find cron group");
d430 1
a430 1
		log_it("CRON", "DEATH", "can't create socket");
d437 1
a437 1
		log_it("CRON", "DEATH", "path too long");
d444 1
a444 1
		log_it("CRON", "DEATH", "already running");
d456 1
a456 1
		log_it("CRON", "DEATH", "can't bind socket");
d462 1
a462 1
		log_it("CRON", "DEATH", "can't listen on socket");
a474 6
}

static void
sighup_handler(int x)
{
	got_sighup = 1;
@


1.69
log
@Move cron socket to /var/run/cron.sock.  Client code will try the old
location if the new one doesn't exist for now.  In order to allow
the fchown() to succeed, cron now sets its effective gid to crontab.
OK jca@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.68 2015/11/11 17:19:22 millert Exp $	*/
d28 1
a100 2
	set_cron_cwd();

d115 1
a115 1
		if (daemon(1, 0) == -1) {
d423 1
d426 3
d437 1
a437 1
	if (strlcpy(s_un.sun_path, CRONSOCK, sizeof(s_un.sun_path))
d439 1
a439 1
		fprintf(stderr, "%s: path too long\n", CRONSOCK);
d469 7
a475 1
	chown(s_un.sun_path, -1, getegid());
@


1.68
log
@Niether cron nor crontab need flock permission.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.67 2015/11/11 03:20:19 deraadt Exp $	*/
d434 3
a436 3
	if (snprintf(s_un.sun_path, sizeof(s_un.sun_path), "%s/%s",
	      CRON_SPOOL, CRONSOCK) >= sizeof(s_un.sun_path)) {
		fprintf(stderr, "%s/%s: path too long\n", CRON_SPOOL, CRONSOCK);
d466 1
@


1.67
log
@exit on pledge failure, oops
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.66 2015/11/09 16:37:07 millert Exp $	*/
d102 1
a102 1
	if (pledge("stdio rpath wpath cpath fattr getpw unix flock id dns proc exec",
@


1.66
log
@Remove unused xpid argument to log_it().
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.65 2015/11/09 15:57:39 millert Exp $	*/
d103 1
a103 1
	    NULL) == -1)
d105 2
@


1.65
log
@Rename AT_DIR -> AT_SPOOL and SPOOL_DIR -> CRON_SPOOL to improve
readability.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.64 2015/11/09 01:12:27 millert Exp $	*/
d104 1
a104 1
		log_it("CRON", getpid(), "pledge", strerror(errno));
d109 1
a109 1
		log_it("CRON", getpid(), "DEATH", "can't malloc");
d115 1
a115 1
			log_it("CRON",getpid(),"DEATH","can't fork");
d118 1
a118 1
		log_it("CRON",getpid(),"STARTUP",CRON_VERSION);
d428 1
a428 1
		log_it("CRON", getpid(), "DEATH", "can't create socket");
d435 1
a435 1
		log_it("CRON", getpid(), "DEATH", "path too long");
d442 1
a442 1
		log_it("CRON", getpid(), "DEATH", "already running");
d454 1
a454 1
		log_it("CRON", getpid(), "DEATH", "can't bind socket");
d460 1
a460 1
		log_it("CRON", getpid(), "DEATH", "can't listen on socket");
@


1.64
log
@queue(3) instead of homegrown queues and lists.  This also fixes
some potential memory leaks in error paths.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.63 2015/11/06 23:47:42 millert Exp $	*/
d433 2
a434 2
	      SPOOL_DIR, CRONSOCK) >= sizeof(s_un.sun_path)) {
		fprintf(stderr, "%s/%s: path too long\n", SPOOL_DIR, CRONSOCK);
@


1.63
log
@Use __progname instead of the homegrown ProgramName.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.62 2015/11/04 20:28:17 millert Exp $	*/
d62 2
a63 2
static	cron_db			database;
static	at_db			at_database;
a120 3
	database.head = NULL;
	database.tail = NULL;
	database.mtime = 0;
a121 3
	at_database.head = NULL;
	at_database.tail = NULL;
	at_database.mtime = 0;
d124 1
a124 1
	run_reboot_jobs(&database);
d166 1
a166 1
			find_jobs(virtualTime, &database, TRUE, TRUE);
d189 1
a189 1
					find_jobs(virtualTime, &database,
d207 1
a207 1
				find_jobs(timeRunning, &database, TRUE, FALSE);
d214 1
a214 1
					find_jobs(virtualTime, &database,
d230 1
a230 1
				find_jobs(timeRunning, &database, TRUE, FALSE);
d238 1
a238 1
				find_jobs(timeRunning, &database, TRUE, TRUE);
d246 1
a246 1
		atrun(&at_database, batch_maxload,
d261 2
a262 2
	for (u = db->head; u != NULL; u = u->next) {
		for (e = u->crontab; e != NULL; e = e->next) {
d293 2
a294 2
	for (u = db->head; u != NULL; u = u->next) {
		for (e = u->crontab; e != NULL; e = e->next) {
d372 1
a372 1
					database.mtime = 0;
d382 1
a382 1
					at_database.mtime = 0;
d384 1
a384 1
						atrun(&at_database,
@


1.62
log
@Change cron from including all headers in every file to only including
what each .c file needs.  I have not removed cron.h since it will
be used in a future clean up of the cron's .h files.  OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.61 2015/11/04 12:53:05 millert Exp $	*/
a19 2
#define	MAIN_PROGRAM

d72 1
a72 1
	fprintf(stderr, "usage: %s [-n] [-l load_avg]\n", ProgramName);
a81 2
	ProgramName = argv[0];

d433 1
a433 1
		    ProgramName, strerror(errno));
d447 1
a447 1
		fprintf(stderr, "%s: already running\n", ProgramName);
d459 1
a459 1
		    ProgramName, strerror(errno));
d465 1
a465 1
		    ProgramName, strerror(errno));
@


1.61
log
@Change some globals from extern to static when they are not used
outside their respective .c files.  Also remove some unused defines.
OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.60 2015/10/31 12:14:16 millert Exp $	*/
d22 23
a44 1
#include "cron.h"
@


1.60
log
@open_socket() is only used by cron proper so move to cron.c
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.59 2015/10/29 21:24:09 millert Exp $	*/
d45 2
a68 1
	NoFork = 0;
@


1.59
log
@remove unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.58 2015/10/28 20:17:31 deraadt Exp $	*/
d36 2
d398 55
@


1.58
log
@pledge
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.57 2015/10/26 15:16:30 millert Exp $	*/
a56 1
	int fd;
@


1.57
log
@Use SOCK_NONBLOCK and SOCK_CLOEXEC instead of fcntl() calls.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.56 2015/10/26 14:27:41 millert Exp $	*/
d81 4
@


1.56
log
@Remove some useless defines and the set_cron_uid() function.
OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.55 2015/10/25 21:30:11 millert Exp $	*/
d348 3
a350 2
			fd = accept(cronSock, (struct sockaddr *)&s_un, &sunlen);
			if (fd >= 0 && fcntl(fd, F_SETFL, O_NONBLOCK) == 0) {
@


1.55
log
@Remove cron.pid support.  We still want to avoid multiple crons
running so verify that if the cron socket exists nothing is listening
on it.  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.54 2015/10/03 12:46:54 tedu Exp $	*/
a79 1
	set_cron_uid();
@


1.54
log
@unifdef some features we will always have. ok benno zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.53 2015/08/25 20:09:27 millert Exp $	*/
a33 1
		quit(int),
a76 3
	sact.sa_handler = quit;
	(void) sigaction(SIGINT, &sact, NULL);
	(void) sigaction(SIGTERM, &sact, NULL);
a79 1
	acquire_daemonlock(0);
d83 2
d91 1
a91 2
		switch (fork()) {
		case -1:
a93 16
			break;
		case 0:
			/* child process */
			(void) setsid();
			if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) >= 0) {
				(void) dup2(fd, STDIN_FILENO);
				(void) dup2(fd, STDOUT_FILENO);
				(void) dup2(fd, STDERR_FILENO);
				if (fd != STDERR_FILENO)
					(void) close(fd);
			}
			log_it("CRON",getpid(),"STARTUP",CRON_VERSION);
			break;
		default:
			/* parent process should just die */
			_exit(EXIT_SUCCESS);
d95 1
a97 2
	acquire_daemonlock(0);
	cronSock = open_socket();
a404 7
}

static void
quit(int x)
{
	(void) unlink(_PATH_CRON_PID);
	_exit(0);
@


1.53
log
@Use ppoll(2) instead of poll(2).  This has two benefits.  Firstly,
we can use struct timespec throughout and avoid any conversion
issues which might cause jobs to fire prematurely.  Secondly, it
eliminates a race condition that could delay us taking action on
SIGCHLD and SIGHUP.  OK deraadt@@ okan@@ ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.52 2015/02/09 22:35:08 deraadt Exp $	*/
a72 1
#ifdef SA_RESTART
a73 1
#endif
@


1.52
log
@correct copyright, upon approval from paul vixie via todd miller.  the
head copyright assertion was seperated from the remaining ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.51 2015/01/23 19:07:27 tedu Exp $	*/
d30 1
a30 1
		cron_sleep(time_t),
d57 1
d134 9
d158 1
a158 1
			cron_sleep(timeRunning + 1);
d255 1
a255 9
		/* Check to see if we received a signal while running jobs. */
		if (got_sighup) {
			got_sighup = 0;
			log_close();
		}
		if (got_sigchld) {
			got_sigchld = 0;
			sigchld_reaper();
		}
d344 1
a344 1
cron_sleep(time_t target)
d348 1
a348 1
	struct timeval t1, t2, tv;
d353 1
a353 1
	gettimeofday(&t1, NULL);
d355 2
a356 2
	tv.tv_sec = (target * SECONDS_PER_MINUTE - t1.tv_sec) + 1;
	tv.tv_usec = 0;
d361 1
a361 1
	while (timerisset(&tv) && tv.tv_sec < 65) {
d365 1
a365 1
		nfds = poll(pfd, 1, tv.tv_sec * 1000 + tv.tv_usec / 1000);
d386 1
a386 1
					gettimeofday(&t2, NULL);
d406 1
a406 1
		gettimeofday(&t2, NULL);
d408 2
a409 2
		timersub(&t2, &t1, &t1);
		timersub(&tv, &t1, &tv);
d411 4
a414 4
		if (tv.tv_sec < 0)
			tv.tv_sec = 0;
		if (tv.tv_usec < 0)
			tv.tv_usec = 0;
@


1.51
log
@braces to open a function go on their own line like god intended
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.50 2015/01/23 01:03:03 tedu Exp $	*/
a3 4
 * All rights reserved
 */

/*
@


1.50
log
@minor debug removal cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.49 2015/01/23 01:01:06 tedu Exp $	*/
d50 2
a51 1
usage(void) {
d58 2
a59 1
main(int argc, char *argv[]) {
d264 2
a265 1
run_reboot_jobs(cron_db *db) {
d279 2
a280 1
find_jobs(time_t vtime, cron_db *db, int doWild, int doNonWild) {
d326 2
a327 1
set_time(int initialize) {
d346 2
a347 1
cron_sleep(time_t target) {
d421 2
a422 1
sighup_handler(int x) {
d427 2
a428 1
sigchld_handler(int x) {
d433 2
a434 1
quit(int x) {
d440 2
a441 1
sigchld_reaper(void) {
d461 2
a462 1
parse_args(int argc, char *argv[]) {
@


1.49
log
@remove debug code.
I think the level of debug code in cron is excessive for a program
that has reached feature complete. If cron needs to provide more
information to the user about its operational status, I think syslog
would be more appropriate. (The debug flags also disable forking
into the background, so they aren't even that useful for debugging a
live system.)
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.48 2015/01/22 22:38:55 tedu Exp $	*/
d52 1
a52 3
	fprintf(stderr, "usage: %s [-n] [-l load_avg] [-x [", ProgramName);
	fprintf(stderr, "debugging flags (none supported in this build)]");
	fprintf(stderr, "]\n");
@


1.48
log
@delete useless casts. ok deraadt guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.47 2015/01/14 17:27:29 millert Exp $	*/
a50 3
#if DEBUGGING
	const char **dflags;
#endif
a52 4
#if DEBUGGING
	for (dflags = DebugFlagNames; *dflags; dflags++)
		fprintf(stderr, "%s%s", *dflags, dflags[1] ? "," : "]");
#else
a53 1
#endif
d98 1
a98 7
	/* if there are no debug flags turned on, fork as a daemon should.
	 */
	if (DebugFlags) {
#if DEBUGGING
		(void) fprintf(stderr, "[%ld] cron started\n", (long)getpid());
#endif
	} else if (NoFork == 0) {
a184 2
				Debug(DSCH, ("[%ld], normal case %d minutes to go\n",
				    (long)getpid(), timeDiff))
a205 2
				Debug(DSCH, ("[%ld], DST begins %d minutes to go\n",
				    (long)getpid(), timeDiff))
a229 2
				Debug(DSCH, ("[%ld], DST ends %d minutes to go\n",
				    (long)getpid(), timeDiff))
a236 2
				Debug(DSCH, ("[%ld], clock jumped\n",
				    (long)getpid()))
a292 4
	Debug(DSCH, ("[%ld] tick(%d,%d,%d,%d,%d) %s %s\n",
		     (long)getpid(), minute, hour, dom, month, dow,
		     doWild?" ":"No wildcard",doNonWild?" ":"Wildcard only"))

a300 3
			Debug(DSCH|DEXT, ("user [%s:%lu:%lu:...] cmd=\"%s\"\n",
			    e->pwd->pw_name, (unsigned long)e->pwd->pw_uid,
			    (unsigned long)e->pwd->pw_gid, e->cmd))
a334 2
		Debug(DSCH, ("[%ld] GMToff=%ld\n",
		    (long)getpid(), (long)GMToff))
a359 4
		Debug(DSCH, ("[%ld] Target time=%lld, sec-to-wait=%lld\n",
		    (long)getpid(), (long long)target*SECONDS_PER_MINUTE,
		    (long long)tv.tv_sec))

a368 2
			Debug(DSCH, ("[%ld] Got a poke on the socket\n",
			    (long)getpid()))
a442 3
			Debug(DPROC,
			      ("[%ld] sigchld...no children\n",
			       (long)getpid()))
a444 3
			Debug(DPROC,
			      ("[%ld] sigchld...no dead kids\n",
			       (long)getpid()))
a446 3
			Debug(DPROC,
			      ("[%ld] sigchld...pid #%ld died, stat=%d\n",
			       (long)getpid(), (long)pid, WEXITSTATUS(waiter)))
d457 1
a457 1
	while (-1 != (argch = getopt(argc, argv, "l:nx:"))) {
a470 4
			break;
		case 'x':
			if (!set_debug_flags(optarg))
				usage();
@


1.47
log
@Use standard types for wait, readdir, signals and pids.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.46 2014/11/26 18:34:52 millert Exp $	*/
d140 1
a140 1
	database.mtime = (time_t) 0;
d144 1
a144 1
	at_database.mtime = (time_t) 0;
d412 1
a412 1
					database.mtime = (time_t)0;
d422 1
a422 1
					at_database.mtime = (time_t)0;
@


1.46
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.45 2014/10/29 04:39:02 deraadt Exp $	*/
d471 2
a472 2
	WAIT_T waiter;
	PID_T pid;
@


1.45
log
@use poll() instead of the select malloc/free dance which was used to
avoid fd_set overflows.

Back when I was young, I fixed these throughout the tree, and the world
continued on ignoring the issue...  The malloc/free dance was used because
poll() was not very portable yet.  Now poll() is commonplace, and we should
use this safer API.

ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.44 2013/04/17 15:58:45 deraadt Exp $	*/
d75 2
a76 4
#if defined(BSD)
	setlinebuf(stdout);
	setlinebuf(stderr);
#endif
@


1.44
log
@Adapt cron and at for future large time_t and tv_sec types.  These were some
of the harder programs to adapt, so let me know if problems happen.
tested by guenther, gilles, chl, others
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.43 2011/08/22 19:32:42 millert Exp $	*/
d382 1
a382 1
	static fd_set *fdsr;
d389 2
a390 4
	if (fdsr == NULL) {
		fdsr = (fd_set *)calloc(howmany(cronSock + 1, NFDBITS),
		    sizeof(fd_mask));
	}
d398 1
a398 2
		if (fdsr)
			FD_SET(cronSock, fdsr);
d400 1
a400 1
		nfds = select(cronSock + 1, fdsr, NULL, NULL, &tv);
@


1.43
log
@Use standard EXIT_SUCCESS/EXIT_FAILURE and STD{IN,OUT,ERR}_FILENO
defines instead of using custom macros.  OK deraadt@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.42 2011/01/18 14:09:54 millert Exp $	*/
d32 1
a32 1
		find_jobs(int, cron_db *, int, int),
d34 1
a34 1
		cron_sleep(int),
d42 2
a43 1
static	int			timeRunning, virtualTime, clockTime, cronSock;
d302 1
a302 1
find_jobs(int vtime, cron_db *db, int doWild, int doNonWild) {
d376 1
a376 1
cron_sleep(int target) {
d395 3
a397 2
		Debug(DSCH, ("[%ld] Target time=%ld, sec-to-wait=%ld\n",
		    (long)getpid(), (long)target*SECONDS_PER_MINUTE, tv.tv_sec))
@


1.42
log
@Our crontab(1) hasn't used SIGUSR1 to signal cron in years, we now use
a Unix domain socket to trigger a reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.41 2009/10/27 23:59:51 deraadt Exp $	*/
d62 1
a62 1
	exit(ERROR_EXIT);
d104 1
a104 1
		exit(1);
d117 1
a117 1
			exit(0);
d123 4
a126 4
				(void) dup2(fd, STDIN);
				(void) dup2(fd, STDOUT);
				(void) dup2(fd, STDERR);
				if (fd != STDERR)
d133 1
a133 1
			_exit(0);
@


1.41
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.40 2009/01/29 22:50:16 sobrado Exp $	*/
a96 1
	(void) sigaction(SIGUSR1, &sact, NULL);	/* XXX */
@


1.40
log
@tweak usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.39 2007/02/18 23:59:03 jmc Exp $	*/
a22 4

#if !defined(lint) && !defined(LINT)
static const char rcsid[] = "$OpenBSD: cron.c,v 1.39 2007/02/18 23:59:03 jmc Exp $";
#endif
@


1.39
log
@tidy up synopsis and usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.38 2005/11/15 07:02:37 miod Exp $	*/
d25 1
a25 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.38 2005/11/15 07:02:37 miod Exp $";
d58 1
a58 1
	fprintf(stderr, "usage:  %s [-n] [-l load_avg] [-x [", ProgramName);
@


1.38
log
@More typos (especially indicies -> indices), checked with jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.37 2005/11/15 03:15:29 millert Exp $	*/
d25 1
a25 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.37 2005/11/15 03:15:29 millert Exp $";
d58 1
a58 1
	fprintf(stderr, "usage:  %s [-l load_avg] [-n] [-x [", ProgramName);
@


1.37
log
@If two or more changes are made withing a single second it is possible
that only the first change will be loaded due to the granularity of
st_mtime.  Work around this by zeroing the saved mtime when we get
a poke on the socket from crontab or at since that means there has been
a change.  Fix from Daniel Lucq.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.36 2004/06/17 22:11:55 millert Exp $	*/
d25 1
a25 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.36 2004/06/17 22:11:55 millert Exp $";
d313 1
a313 1
	/* make 0-based values out of these so we can use them as indicies
@


1.36
log
@UUpdate ISC copyright year to 2004
Remove unused macros Skip_Line and MkLower
Remove trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.35 2004/06/03 19:54:04 millert Exp $	*/
d25 1
a25 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.35 2004/06/03 19:54:04 millert Exp $";
d419 2
a420 1
				if (poke & RELOAD_CRON)
d422 1
d430 1
@


1.35
log
@More changes from Dmitry V. Levin:

Check return values for setgid, initgroups and setuid in code we don't compile.
Print the correct filename for the at job in mail sent.
Add some #if DEBUGGING in cron.c's usage().
Set sunlen each time before using it in accept().
Don't send mail at all if MAILTO is set but empty.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.34 2004/05/13 13:54:52 millert Exp $	*/
d8 1
d15 7
a21 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
d25 1
a25 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.34 2004/05/13 13:54:52 millert Exp $";
d232 1
a232 1
	
d244 1
a244 1
	
d333 3
a335 3
			Debug(DSCH|DEXT, ("user [%s:%ld:%ld:...] cmd=\"%s\"\n",
			    e->pwd->pw_name, (long)e->pwd->pw_uid,
			    (long)e->pwd->pw_gid, e->cmd))
@


1.34
log
@If we get EAGAIN reading from the cron socket check both cron and
at databases for jobs to run.  Jarno Huuskonen.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.33 2004/05/03 15:10:21 millert Exp $	*/
d25 1
a25 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.33 2004/05/03 15:10:21 millert Exp $";
d54 1
d56 1
d59 1
d62 3
d345 1
a345 1
				    !(e->flags & (MIN_STAR|HR_STAR))) || 
d414 1
@


1.33
log
@Make socket that reads reload requests from crontab be non-blocking.
Problem found by Jarno Huuskonen.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.32 2003/03/10 15:27:17 millert Exp $	*/
d25 1
a25 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.32 2003/03/10 15:27:17 millert Exp $";
d396 1
a396 1
		poke = 0;
@


1.32
log
@Log that cron started up after we detach from the controlling terminal
and dup fds to /dev/null, not before.  This may fix a possible race
when cron is started as the last thing in /etc/rc.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.31 2003/02/20 20:38:08 millert Exp $	*/
d25 1
a25 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.31 2003/02/20 20:38:08 millert Exp $";
d409 1
a409 1
			if (fd >= 0) {
@


1.31
log
@Sync with ISC cron-current + my at(1) integration.
The at(1) code is now more tightly integrated into the cron codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.30 2003/02/18 02:43:06 millert Exp $	*/
d25 1
a25 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.30 2003/02/18 02:43:06 millert Exp $";
a119 1
			log_it("CRON",getpid(),"STARTUP",CRON_VERSION);
d128 1
@


1.30
log
@correct a typo from earlier today
@
text
@d1 2
a2 1
/*	$OpenBSD: cron.c,v 1.29 2003/02/17 18:40:11 millert Exp $	*/
d25 1
a25 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.29 2003/02/17 18:40:11 millert Exp $";
a30 2
#include <sys/socket.h>
#include <sys/un.h>
d90 3
a95 3
	sact.sa_handler = quit;
	(void) sigaction(SIGINT, &sact, NULL);
	(void) sigaction(SIGTERM, &sact, NULL);
d101 2
a102 2
	if (putenv("PATH="_PATH_DEFPATH) == -1) {
		log_it("CRON",getpid(),"DEATH","can't malloc");
d146 1
a146 1
	set_time(1);
d167 1
a167 1
			set_time(0);
d234 1
a234 1
					set_time(0);
d328 2
a329 2
					  e->pwd->pw_name, (long)e->pwd->pw_uid,
					  (long)e->pwd->pw_gid, e->cmd))
d354 1
a354 1
	struct tm *tm;
d360 6
a365 4
	tm = localtime(&StartTime);
	if (initialize || tm->tm_isdst != isdst) {
		isdst = tm->tm_isdst;
		GMToff = get_gmtoff(&StartTime, tm);
d378 1
a378 1
	struct sockaddr_un sun;
d408 1
a408 1
			fd = accept(cronSock, (struct sockaddr *)&sun, &sunlen);
d468 1
a468 1
sigchld_reaper() {
@


1.29
log
@Add a -n flag and version string; from vixie
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.28 2002/08/08 18:13:35 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.28 2002/08/08 18:13:35 millert Exp $";
d121 1
a121 1
			log_it("CRON",getpid(),"STARTUP","CRON_VERSION");
@


1.28
log
@Make wakeupKind an enum for clarity at Vixie's request
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.27 2002/07/15 19:13:29 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.27 2002/07/15 19:13:29 millert Exp $";
d57 1
a57 1
	fprintf(stderr, "usage:  %s [-l load_avg] [-x [", ProgramName);
d78 1
d113 1
a113 1
	} else {
d121 1
a121 1
			log_it("CRON",getpid(),"STARTUP","fork ok");
d500 1
a500 1
	while (-1 != (argch = getopt(argc, argv, "l:x:"))) {
d511 3
@


1.27
log
@Move atrun(8) functionality into cron(8) proper.  This fixes the
long-standing annoyance that atrun's granularity is 10 minutes.
Most at jobs run with a 1 minute granularity.  Jobs submitted via
"at now" or "batch" will run immediately.  Includes a rewritten
cron(8) man page.  at(1) will be integrated more closely into
cron at a future date.

Upgrading notes:
    the atrun job in root's crontab should be removed.
    the /var/at/spool directory is no longer used
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.26 2002/07/09 18:59:12 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.26 2002/07/09 18:59:12 millert Exp $";
d33 2
d162 1
a162 1
		int wakeupKind;
d182 9
a190 9
			wakeupKind = -1;
			if (timeDiff > -(3*MINUTE_COUNT))
				wakeupKind = 0;
			if (timeDiff > 0)
				wakeupKind = 1;
			if (timeDiff > 5)
				wakeupKind = 2;
			if (timeDiff > (3*MINUTE_COUNT))
				wakeupKind = 3;
d193 1
a193 1
			case 1:
d210 1
a210 1
			case 2:
d239 1
a239 1
			case 0:
@


1.26
log
@o Add _PATH_CRON_PID which is built up from PIDDIR and PIDFILE via string
concatenation at compile time rather than run time.

o Some minor cosmetic changes to simplify diffing.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.25 2002/07/08 18:11:02 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.25 2002/07/08 18:11:02 millert Exp $";
a40 1
		check_sigs(int),
d48 2
d55 1
a55 1
	fprintf(stderr, "usage:  %s [-x [", ProgramName);
d140 4
a161 1
		check_sigs(TRUE);
d264 16
d326 2
a327 2
					  env_get("LOGNAME", e->envp),
					  (long)e->uid, (long)e->gid, e->cmd))
a370 1
	char c;
d372 1
a381 2
	Debug(DSCH, ("[%ld] Target time=%ld, sec-to-wait=%ld\n",
	    (long)getpid(), (long)target*SECONDS_PER_MINUTE, tv.tv_sec))
d389 4
d395 1
a395 1
		/* Sleep until we time out, get a crontab poke, or signal. */
d406 1
a406 2
				while (read(fd, &c, sizeof c) > 0)
					; /* suck up anything in the socket */
d408 23
d434 1
a434 6
		/*
		 * Check to see if we were interrupted by a signal or a poke
		 * on the socket.  If so, service the signal/poke, adjust tv
		 * and continue the select() where we left off.
		 */
		check_sigs(nfds > 0);
a492 14
check_sigs(int force_dbload) {
	if (got_sighup) {
		got_sighup = 0;
		log_close();
	}
	if (got_sigchld) {
		got_sigchld = 0;
		sigchld_reaper();
	}
	if (force_dbload)
		load_database(&database);
}

static void
d495 1
d497 1
a497 1
	while (-1 != (argch = getopt(argc, argv, "x:"))) {
d499 10
a508 2
		default:
			usage();
d513 2
@


1.25
log
@Merge in some changes from Paul Vixie's tree; most are cosmetic
o ANSI function headers
o return (foo) not return foo
o add -oi to sendmail flags
o update email address in man pages
o make some strings const
o completely remove globbing cruft from popen.c
o whitespace changes
o add DOW_STAR to flags for "monthly", "weekly", and "daily" cron entries
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.24 2002/05/28 01:20:19 deraadt Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: cron.c,v 1.24 2002/05/28 01:20:19 deraadt Exp $";
d119 1
a119 1
			if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {
d123 1
a123 1
				if (fd > STDERR)
d420 1
a420 5
	char	pidfile[MAX_FNAME];

	if (glue_strings(pidfile, sizeof pidfile, PIDDIR, PIDFILE, '/'))
		(void) unlink(pidfile);

d448 1
@


1.24
log
@use %ld (long) for pid
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.23 2002/05/22 17:19:15 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.23 2002/05/22 17:19:15 millert Exp $";
@


1.23
log
@Remove pid file if sent SIGINT or SIGTERM before exiting.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.22 2002/05/21 20:57:32 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.22 2002/05/21 20:57:32 millert Exp $";
d193 2
a194 2
				Debug(DSCH, ("[%d], normal case %d minutes to go\n",
				    getpid(), timeDiff))
d216 2
a217 2
				Debug(DSCH, ("[%d], DST begins %d minutes to go\n",
				    getpid(), timeDiff))
d242 2
a243 2
				Debug(DSCH, ("[%d], DST ends %d minutes to go\n",
				    getpid(), timeDiff))
d251 2
a252 1
				Debug(DSCH, ("[%d], clock jumped\n", getpid()))
@


1.22
log
@Better handling of negative timeval than last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.21 2002/05/20 23:33:31 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.21 2002/05/20 23:33:31 millert Exp $";
d42 1
d90 3
d415 10
@


1.21
log
@Add a check for negative values in struct timeval after the timersub().
Just treat it like a zero value.  Also check for errno != EINTR
when select() returns -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.20 2002/05/09 21:22:01 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.20 2002/05/09 21:22:01 millert Exp $";
d365 1
a365 1
	while ((tv.tv_sec > 0 || tv.tv_usec > 0) && tv.tv_sec < 65) {
d396 4
@


1.20
log
@crontab is no longer setuid root, it is now setgid crontab.
These changes were modelled after the Owl version of vixie-cron,
but developed independently.

Our crontab used to send cron SIGUSR1 to tell cron to reread the
spool dir.  Now that crontab is not setuid root this doesn't work.
Instead, crontab pokes cron via a Unix domain socket located in the
tabs dir.

Please note, after these changes, the owner on user crontab files
will have to be changed manually from root to the uid of the
corresponding user for crontab to be usable.  cron itself will accept
tab files owned by either root or the user.
Also, any /var/cron/{allow,deny} files must be readable by group crontab.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.19 2002/02/16 21:28:01 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.19 2002/02/16 21:28:01 millert Exp $";
d365 1
a365 1
	while (timerisset(&tv) && tv.tv_sec < 65) {
d372 2
@


1.19
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.18 2001/12/20 23:27:47 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.18 2001/12/20 23:27:47 millert Exp $";
d30 2
a39 1
		sigusr1_handler(int),
d44 2
a45 2
static	volatile sig_atomic_t	got_sighup, got_sigchld, got_sigusr1;
static	int			timeRunning, virtualTime, clockTime;
d86 3
d130 1
d346 18
a363 3
	time_t t1, t2;
	int seconds_to_wait;
	struct sigaction sact;
d365 17
a381 16
	bzero((char *)&sact, sizeof sact);
	sigemptyset(&sact.sa_mask);
	sact.sa_flags = 0;
#ifdef SA_RESTART
	sact.sa_flags |= SA_RESTART;
#endif
	sact.sa_handler = sigusr1_handler;
	(void) sigaction(SIGUSR1, &sact, NULL);

	t1 = time(NULL) + GMToff;
	seconds_to_wait = (int)(target * SECONDS_PER_MINUTE - t1) + 1;
	Debug(DSCH, ("[%ld] Target time=%ld, sec-to-wait=%d\n",
	    (long)getpid(), (long)target*SECONDS_PER_MINUTE, seconds_to_wait))

	while (seconds_to_wait > 0 && seconds_to_wait < 65) {
		sleep((unsigned int) seconds_to_wait);
d384 3
a386 3
		 * Check to see if we were interrupted by a signal.
		 * If so, service the signal(s) then continue sleeping
		 * where we left off.
d388 6
a393 4
		check_sigs(FALSE);
		t2 = time(NULL) + GMToff;
		seconds_to_wait -= (int)(t2 - t1);
		t1 = t2;
a394 3

	sact.sa_handler = SIG_DFL;
	(void) sigaction(SIGUSR1, &sact, NULL);
a407 5
sigusr1_handler(int x) {
	got_sigusr1 = 1;
}

static void
d445 1
a445 2
	if (got_sigusr1 || force_dbload) {
		got_sigusr1 = 0;
a446 1
	}
@


1.18
log
@Cause crontab to send SIGUSR1 when a user's crontab file has changed.
In cron, this interrupts the sleep() in cron_sleep() and causes cron
to check to see what signal woke it up and act appropriately.
This makes crontab changes take effect more or immediately.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.17 2001/12/11 04:14:00 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.17 2001/12/11 04:14:00 millert Exp $";
d33 3
a35 3
		find_jobs __P((int, cron_db *, int, int)),
		set_time __P((int)),
		cron_sleep __P((int)),
@


1.17
log
@If we receive a signal during the sleep(), run signal handlers as
needed and then go back to sleep.  This fixes the issue where processes
run by cron could hang around as zombies for a minute (ie: until we
were done sleeping).
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.16 2001/10/24 17:28:16 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.16 2001/10/24 17:28:16 millert Exp $";
d38 1
d40 1
a40 1
		check_sigs(void),
d43 1
a43 1
static	volatile sig_atomic_t	got_sighup, got_sigchld;
d46 1
a60 1
	cron_db	database;
d148 1
a148 2
		check_sigs();
		load_database(&database);
d343 10
d367 1
a367 1
		check_sigs();
d372 3
d388 5
d421 1
a421 1
check_sigs() {
d429 4
@


1.16
log
@When becoming a daemon, dup stdin, stdout, and stderr to /dev/null
Change an unsafe vfork() to fork()
Fix dup2() usage--must check for oldd == newd case and no need to close oldd
Fixes annoying messages from sendmail about stdout being closed.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.15 2001/08/11 20:47:14 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.15 2001/08/11 20:47:14 millert Exp $";
d39 1
d147 1
a147 9
		if (got_sighup) {
			got_sighup = 0;
			log_close();
		}
		if (got_sigchld) {
			got_sigchld = 0;
			sigchld_reaper();
		}

d341 1
a341 1
	time_t t;
d344 2
a345 2
	t = time(NULL) + GMToff;
	seconds_to_wait = (int)(target * SECONDS_PER_MINUTE - t) + 1;
d349 1
a349 1
	if (seconds_to_wait > 0 && seconds_to_wait < 65)
d351 11
d400 12
@


1.15
log
@If waitpid() returns -1, check for EINTR
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.14 2001/07/13 03:28:48 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.14 2001/07/13 03:28:48 millert Exp $";
d60 1
d109 7
@


1.14
log
@flags set in signal handlers should be volatile sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.13 2001/02/21 18:13:31 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.13 2001/02/21 18:13:31 millert Exp $";
d371 2
@


1.13
log
@Add back code in find_jobs() that got dropped in cron merge.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.12 2001/02/20 02:03:19 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.12 2001/02/20 02:03:19 millert Exp $";
d41 3
a43 3
static	int	got_sighup, got_sigchld;
static	int	timeRunning, virtualTime, clockTime;
static	long	GMToff;
@


1.12
log
@Turn get_gmtoff into a macro for OSes with tm_gmtoff (like OpenBSD).
Save the GMT offset in a global so cron_sleep can use it.  This means
the offset can only change in set_time() which is really what we want.
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.11 2001/02/19 14:33:32 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.11 2001/02/19 14:33:32 millert Exp $";
d304 6
a309 2
			   )
				job_add(e, u);
@


1.11
log
@Normalize the time in minutes to GMT so we can really catch DST changes
(since time() does not change during a DST switch).  This makes cron
correctly detect DST changes.  It does not fix the problem of wildcard
jobs running multiple times.  Also, don't rely on tm_gmtoff since that
is non-standard (but use it when we have it).
@
text
@d1 1
a1 1
/*	$OpenBSD: cron.c,v 1.10 2001/02/18 19:48:31 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.10 2001/02/18 19:48:31 millert Exp $";
d43 1
a317 1
	static long gmtoff;
d326 1
a326 1
		gmtoff = get_gmtoff(&StartTime);
d328 1
a328 1
	clockTime = (StartTime + gmtoff) / (time_t)SECONDS_PER_MINUTE;
a336 1
	struct tm *tm;
d339 1
a339 3
	t = time(NULL);
	tm = localtime(&t);
	t += tm->tm_gmtoff;
@


1.10
log
@Update to ISC cron 4.0b1 + our patches.  This is now under a BSD license.
I also fixed the signal handlers while I was at it.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: cron.c,v 1.4 2000/01/02 20:53:38 vixie Exp $";
d33 3
a35 3
		find_jobs __P((time_min, cron_db *, int, int)),
		set_time __P((void)),
		cron_sleep __P((time_min)),
d42 1
d119 1
a119 1
	set_time();
d125 1
a125 1
	 * These clocks are in minutes since the epoch (time()/60).
d134 1
a134 1
		time_min timeDiff;
d150 1
a150 1
			set_time();
d183 1
a183 1
				    getpid(), timeRunning - virtualTime))
d190 1
a190 1
				} while (virtualTime< timeRunning);
d206 1
a206 1
				    getpid(), timeRunning - virtualTime))
d217 1
a217 1
					set_time();
d225 5
a229 5
				 * negative num, eg. because of DST ending just
				 * run the wildcard jobs. The fixed-time jobs
				 * probably have already run, and should not be
				 * repeated.  Virtual time does not change until
				 * we are caught up.
d232 1
a232 1
				    getpid(), virtualTime - timeRunning))
d266 1
a266 1
find_jobs(time_min vtime, cron_db *db, int doWild, int doNonWild) {
d268 1
a268 1
	struct tm *tm = localtime(&virtualSecond);
d315 14
a328 4
set_time(void) {

	StartTime = time((time_t *)0);
	clockTime = StartTime / (unsigned long)SECONDS_PER_MINUTE;
d335 3
a337 1
cron_sleep(time_min target) {
d340 4
a343 1
	seconds_to_wait = (int)(target * SECONDS_PER_MINUTE - time(NULL)) + 1;
@


1.9
log
@mark remaining signal races which are difficult to fix
@
text
@d1 1
d4 4
d9 3
a11 8
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
d13 8
a20 3
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@@vix.com>          uunet!decwrl!vixie!paul
d24 1
a24 1
static char rcsid[] = "$Id: cron.c,v 1.8 2000/09/15 07:13:50 deraadt Exp $";
a26 1

a28 1

a29 6
#include <sys/signal.h>
#if SYS_TIME_H
# include <sys/time.h>
#else
# include <time.h>
#endif
d31 2
a32 3

static	void	usage __P((void)),
		run_reboot_jobs __P((cron_db *)),
d36 4
a39 5
#ifdef USE_SIGCHLD
		sigchld_handler __P((int)),
#endif
		sighup_handler __P((int)),
		parse_args __P((int c, char *v[]));
d41 1
d44 2
a45 2
usage() {
	char **dflags;
d48 1
a48 1
	for(dflags = DebugFlagNames; *dflags; dflags++)
a53 1

d55 1
a55 4
main(argc, argv)
	int	argc;
	char	*argv[];
{
d57 1
d61 2
d70 5
a74 4
#ifdef USE_SIGCHLD
	(void) signal(SIGCHLD, sigchld_handler);
#else
	(void) signal(SIGCLD, SIG_IGN);
d76 4
a79 1
	(void) signal(SIGHUP, sighup_handler);
d85 1
a85 2
#if defined(POSIX)
	if (setenv("PATH", _PATH_DEFPATH, 1) == -1) {
a88 1
#endif
a91 1

d94 1
a94 1
		(void) fprintf(stderr, "[%d] cron started\n", getpid());
a117 1

d123 1
a123 1
	 * too many clocks, not enough time (Al. Einstein)
d136 9
a145 1

d154 2
a155 3
		 * ... calculate how the current time differs from
		 * our virtual clock. Classify the change into one
		 * of 4 cases
d178 2
a179 2
				 * (wokeup late) run jobs for each virtual minute
				 * until caught up.
d187 2
a188 1
					find_jobs(virtualTime, &database, TRUE, TRUE);
d194 9
a202 7
				 * case 2: timeDiff is a medium-sized positive number,
				 * for example because we went to DST run wildcard
				 * jobs once, then run any fixed-time jobs that would
				 * otherwise be skipped if we use up our minute
				 * (possible, if there are a lot of jobs to run) go
				 * around the loop again so that wildcard jobs have
				 * a chance to run, and we do our housekeeping
d209 1
a209 1
				/* run fixed-time jobs for each minute missed */ 
d214 2
a215 1
					find_jobs(virtualTime, &database, FALSE, TRUE);
d224 5
a228 4
				 * negative num, eg. because of DST ending just run
				 * the wildcard jobs. The fixed-time jobs probably
				 * have already run, and should not be repeated
				 * virtual time does not change until we are caught up
d244 2
a245 1
		/* jobs to be run (if any) are loaded. clear the queue */
a249 1

d251 7
a257 9
run_reboot_jobs(db)
	cron_db *db;
{
	register user		*u;
	register entry		*e;

	for (u = db->head;  u != NULL;  u = u->next) {
		for (e = u->crontab;  e != NULL;  e = e->next) {
			if (e->flags & WHEN_REBOOT) {
a258 1
			}
a263 1

d265 6
a270 11
find_jobs(vtime, db, doWild, doNonWild)
	time_min vtime;
	cron_db	*db;
	int doWild;
	int doNonWild;
{
	time_t   virtualSecond  = vtime * SECONDS_PER_MINUTE;
	register struct tm	*tm = localtime(&virtualSecond);
	register int		minute, hour, dom, month, dow;
	register user		*u;
	register entry		*e;
d280 3
a282 3
	Debug(DSCH, ("[%d] tick(%d,%d,%d,%d,%d) %s %s\n",
		getpid(), minute, hour, dom, month, dow,
		doWild?" ":"No wildcard",doNonWild?" ":"Wildcard only"))
d290 5
a294 5
	for (u = db->head;  u != NULL;  u = u->next) {
		for (e = u->crontab;  e != NULL;  e = e->next) {
			Debug(DSCH|DEXT, ("user [%s:%d:%d:...] cmd=\"%s\"\n",
			    env_get("LOGNAME", e->envp),
			    e->uid, e->gid, e->cmd))
d300 4
a303 5
			      : (bit_test(e->dow,dow) || bit_test(e->dom,dom)))) {
				if ((doNonWild && !(e->flags & (MIN_STAR|HR_STAR)))
				    || (doWild && (e->flags & (MIN_STAR|HR_STAR))))
					job_add(e, u);
			}
a307 1

d309 3
a311 3
 * set StartTime and clockTime to the current time.
 * these are used for computing what time it really is right now.
 * note that clockTime is a unix wallclock time converted to minutes
d314 2
a315 2
set_time()
{
d321 1
a321 1
 * try to just hit the next minute
d324 6
a329 8
cron_sleep(target)
	time_min target;
{
	register int	seconds_to_wait;

	seconds_to_wait = (int)(target*SECONDS_PER_MINUTE - time((time_t*)0)) + 1;
	Debug(DSCH, ("[%d] TargetTime=%ld, sec-to-wait=%d\n",
	    getpid(), (long)target*SECONDS_PER_MINUTE, seconds_to_wait))
d331 1
a331 1
	if (seconds_to_wait > 0 && seconds_to_wait< 65)
d335 9
a344 1
#ifdef USE_SIGCHLD
d346 3
a348 4
sigchld_handler(x) {
	int save_errno = errno;
	WAIT_T		waiter;
	PID_T		pid;
d350 1
a350 2
	for (;;) {
#ifdef POSIX
a351 4
#else
		pid = wait3(&waiter, WNOHANG, (struct rusage *)0);
#endif
		/* XXX unsafe */
d355 3
a357 3
				("[%d] sigchld...no children\n", getpid()))
			errno = save_errno;
			return;
d360 3
a362 3
				("[%d] sigchld...no dead kids\n", getpid()))
			errno = save_errno;
			return;
d365 2
a366 2
				("[%d] sigchld...pid #%d died, stat=%d\n",
				getpid(), pid, WEXITSTATUS(waiter)))
d368 1
a368 13
	}
	errno = save_errno;
}
#endif /*USE_SIGCHLD*/


static void
sighup_handler(x) {
	int save_errno = errno;

	/* XXX unsafe */
	log_close();
	errno = save_errno;
a370 1

d372 2
a373 5
parse_args(argc, argv)
	int	argc;
	char	*argv[];
{
	int	argch;
@


1.8
log
@check return value for setenv(3) for failure, and deal appropriately
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: cron.c,v 1.7 2000/08/21 00:39:00 deraadt Exp $";
d355 1
d382 1
@


1.7
log
@save errno in handler
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: cron.c,v 1.6 1999/05/23 17:19:23 aaron Exp $";
d87 4
a90 1
	setenv("PATH", _PATH_DEFPATH, 1);
@


1.6
log
@getopt(3) returns -1, not EOF
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: cron.c,v 1.5 1998/03/30 06:59:42 deraadt Exp $";
d376 2
d379 1
@


1.5
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: cron.c,v 1.4 1997/12/22 08:10:41 deraadt Exp $";
d387 1
a387 1
	while (EOF != (argch = getopt(argc, argv, "x:"))) {
@


1.4
log
@handle timing normally except when clock jumps between 1 and 3 hours. If it
jumps, attempt as best as possible to gaurantee that jobs DO run, but only
run ONCE; patch by thompson@@.tgsoft.com
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: cron.c,v 1.3 1997/08/04 19:26:08 deraadt Exp $";
a328 1
	register struct tm *tm;
d332 1
a332 1
	    getpid(), target*SECONDS_PER_MINUTE, seconds_to_wait))
@


1.3
log
@save errno in sigchld handlers
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: cron.c,v 1.2 1996/09/15 09:28:14 deraadt Exp $";
d37 3
a39 3
		cron_tick __P((cron_db *)),
		cron_sync __P((void)),
		cron_sleep __P((void)),
d92 1
a92 1
# if DEBUGGING
d94 1
a94 3
# else
	if (0) {
# endif
d96 1
d119 2
d122 12
a133 1
	cron_sync();
d135 2
a136 4
# if DEBUGGING
		if (!(DebugFlags & DTEST))
# endif /*DEBUGGING*/
			cron_sleep();
d140 11
a150 1
		/* do this iteration
d152 1
a152 1
		cron_tick(&database);
d154 82
a235 3
		/* sleep 1 minute
		 */
		TargetTime += 60;
d259 2
a260 1
cron_tick(db)
d262 2
d265 2
a266 1
 	register struct tm	*tm = localtime(&TargetTime);
d279 3
a281 2
	Debug(DSCH, ("[%d] tick(%d,%d,%d,%d,%d)\n",
		getpid(), minute, hour, dom, month, dow))
d292 6
a297 6
					  env_get("LOGNAME", e->envp),
					  e->uid, e->gid, e->cmd))
			if (bit_test(e->minute, minute)
			 && bit_test(e->hour, hour)
			 && bit_test(e->month, month)
			 && ( ((e->flags & DOM_STAR) || (e->flags & DOW_STAR))
d299 4
a302 4
			      : (bit_test(e->dow,dow) || bit_test(e->dom,dom))
			    )
			   ) {
				job_add(e, u);
d309 4
a312 8
/* the task here is to figure out how long it's going to be until :00 of the
 * following minute and initialize TargetTime to this value.  TargetTime
 * will subsequently slide 60 seconds at a time, with correction applied
 * implicitly in cron_sleep().  it would be nice to let cron execute in
 * the "current minute" before going to sleep, but by restarting cron you
 * could then get it to execute a given minute's jobs more than once.
 * instead we have the chance of missing a minute's jobs completely, but
 * that's something sysadmin's know to expect what with crashing computers..
d315 4
a318 6
cron_sync() {
 	register struct tm	*tm;

	TargetTime = time((time_t*)0);
	tm = localtime(&TargetTime);
	TargetTime += (60 - tm->tm_sec);
d321 3
a323 1

d325 3
a327 1
cron_sleep() {
d329 1
d331 3
a333 15
	do {
		seconds_to_wait = (int) (TargetTime - time((time_t*)0));
		Debug(DSCH, ("[%d] TargetTime=%ld, sec-to-wait=%d\n",
			getpid(), TargetTime, seconds_to_wait))

		/* if we intend to sleep, this means that it's finally
		 * time to empty the job queue (execute it).
		 *
		 * if we run any jobs, we'll probably screw up our timing,
		 * so go recompute.
		 *
		 * note that we depend here on the left-to-right nature
		 * of &&, and the short-circuiting.
		 */
	} while (seconds_to_wait > 0 && job_runqueue());
d335 2
a336 5
	while (seconds_to_wait > 0) {
		Debug(DSCH, ("[%d] sleeping for %d seconds\n",
			getpid(), seconds_to_wait))
		seconds_to_wait = (int) sleep((unsigned int) seconds_to_wait);
	}
@


1.2
log
@print debugging flags in usage(); idea from freebsd
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: cron.c,v 1.1.1.1 1995/10/18 08:47:30 deraadt Exp $";
d255 1
d269 1
d274 1
d282 1
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: cron.c,v 1.1.1.4 1994/01/20 02:47:09 jtc Exp $";
d49 6
a54 1
	fprintf(stderr, "usage:  %s [-x debugflag[,...]]\n", ProgramName);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
