head	1.92;
access;
symbols
	OPENBSD_6_1_BASE:1.92
	OPENBSD_6_0:1.92.0.4
	OPENBSD_6_0_BASE:1.92
	OPENBSD_5_9:1.92.0.2
	OPENBSD_5_9_BASE:1.92
	OPENBSD_5_8:1.71.0.6
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.64.0.14
	OPENBSD_5_6_BASE:1.64
	OPENBSD_5_5:1.64.0.12
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.64.0.8
	OPENBSD_5_4_BASE:1.64
	OPENBSD_5_3:1.64.0.6
	OPENBSD_5_3_BASE:1.64
	OPENBSD_5_2:1.64.0.4
	OPENBSD_5_2_BASE:1.64
	OPENBSD_5_1_BASE:1.64
	OPENBSD_5_1:1.64.0.2
	OPENBSD_5_0:1.62.0.2
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.60.0.2
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.58.0.4
	OPENBSD_4_8_BASE:1.58
	OPENBSD_4_7:1.58.0.2
	OPENBSD_4_7_BASE:1.58
	OPENBSD_4_6:1.57.0.6
	OPENBSD_4_6_BASE:1.57
	OPENBSD_4_5:1.57.0.2
	OPENBSD_4_5_BASE:1.57
	OPENBSD_4_4:1.56.0.2
	OPENBSD_4_4_BASE:1.56
	OPENBSD_4_3:1.55.0.2
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.51.0.4
	OPENBSD_4_2_BASE:1.51
	OPENBSD_4_1:1.51.0.2
	OPENBSD_4_1_BASE:1.51
	OPENBSD_4_0:1.49.0.4
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.49.0.2
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.48.0.4
	OPENBSD_3_8_BASE:1.48
	OPENBSD_3_7:1.48.0.2
	OPENBSD_3_7_BASE:1.48
	OPENBSD_3_6:1.45.0.2
	OPENBSD_3_6_BASE:1.45
	OPENBSD_3_5:1.43.0.4
	OPENBSD_3_5_BASE:1.43
	OPENBSD_3_4:1.43.0.2
	OPENBSD_3_4_BASE:1.43
	OPENBSD_3_3:1.42.0.2
	OPENBSD_3_3_BASE:1.42
	OPENBSD_3_2:1.36.0.2
	OPENBSD_3_2_BASE:1.36
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.6
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.4
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.92
date	2016.01.11.14.23.50;	author millert;	state Exp;
branches;
next	1.91;
commitid	fFP0tihUFMiVcTny;

1.91
date	2015.11.17.21.56.57;	author millert;	state Exp;
branches;
next	1.90;
commitid	76tiMGadGCa0BEL5;

1.90
date	2015.11.14.13.09.14;	author millert;	state Exp;
branches;
next	1.89;
commitid	KNISMJYcyEJqWs74;

1.89
date	2015.11.12.21.12.05;	author millert;	state Exp;
branches;
next	1.88;
commitid	6PlWoK7FsQNDGZmn;

1.88
date	2015.11.11.21.20.51;	author millert;	state Exp;
branches;
next	1.87;
commitid	ejwGloCChkHcOyvl;

1.87
date	2015.11.11.17.19.22;	author millert;	state Exp;
branches;
next	1.86;
commitid	RKqdXm2nalY1uBoL;

1.86
date	2015.11.11.15.21.01;	author millert;	state Exp;
branches;
next	1.85;
commitid	81wCpbl26t2i6LTa;

1.85
date	2015.11.09.16.37.07;	author millert;	state Exp;
branches;
next	1.84;
commitid	ZJUG9DwHA5l6WcX2;

1.84
date	2015.11.09.15.57.39;	author millert;	state Exp;
branches;
next	1.83;
commitid	JJzvBekc1nrVHuHQ;

1.83
date	2015.11.06.23.47.42;	author millert;	state Exp;
branches;
next	1.82;
commitid	8eaJrEU7qiymGijK;

1.82
date	2015.11.04.20.28.17;	author millert;	state Exp;
branches;
next	1.81;
commitid	6N0oXtYc5KM1a7DW;

1.81
date	2015.11.03.21.10.08;	author millert;	state Exp;
branches;
next	1.80;
commitid	YEWExom5NAX9TPZZ;

1.80
date	2015.11.03.16.30.31;	author millert;	state Exp;
branches;
next	1.79;
commitid	8xDeg7NqeO274r3j;

1.79
date	2015.11.02.20.09.02;	author millert;	state Exp;
branches;
next	1.78;
commitid	qcvywequLNE0ocVW;

1.78
date	2015.10.31.12.13.01;	author millert;	state Exp;
branches;
next	1.77;
commitid	tLnu94klbVSaYhr3;

1.77
date	2015.10.29.23.14.30;	author millert;	state Exp;
branches;
next	1.76;
commitid	T93vMUCvVtMw40Ox;

1.76
date	2015.10.29.22.46.31;	author millert;	state Exp;
branches;
next	1.75;
commitid	8z5TMDcLbPQv5cII;

1.75
date	2015.10.28.20.17.31;	author deraadt;	state Exp;
branches;
next	1.74;
commitid	UvqbYTR2CmTeyJXL;

1.74
date	2015.10.26.15.50.06;	author millert;	state Exp;
branches;
next	1.73;
commitid	6fCJ9WlU832faffU;

1.73
date	2015.10.26.14.27.41;	author millert;	state Exp;
branches;
next	1.72;
commitid	k893fgzG4z9i5qIx;

1.72
date	2015.10.06.14.58.37;	author tedu;	state Exp;
branches;
next	1.71;
commitid	DORRwC1MyrO1Yl4N;

1.71
date	2015.02.09.22.35.08;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	eGq01x6bjr83TVho;

1.70
date	2015.01.23.19.07.27;	author tedu;	state Exp;
branches;
next	1.69;
commitid	YJA2vmvfLuMfGdwZ;

1.69
date	2015.01.23.02.37.25;	author tedu;	state Exp;
branches;
next	1.68;
commitid	UGPHvhzwRtnjrF9O;

1.68
date	2015.01.23.01.01.06;	author tedu;	state Exp;
branches;
next	1.67;
commitid	kzBIhYnXdVeOLxgw;

1.67
date	2015.01.14.17.27.29;	author millert;	state Exp;
branches;
next	1.66;
commitid	jXmo2gNqOzD6QEsx;

1.66
date	2015.01.14.17.27.13;	author millert;	state Exp;
branches;
next	1.65;
commitid	DFl2K6Llc1m42RPv;

1.65
date	2014.11.26.18.34.52;	author millert;	state Exp;
branches;
next	1.64;
commitid	9QOFSShUOtA0kQLF;

1.64
date	2011.08.22.19.32.42;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2011.08.19.20.53.36;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2011.05.19.15.00.17;	author phessler;	state Exp;
branches;
next	1.61;

1.61
date	2011.04.04.15.17.52;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2011.02.11.07.14.49;	author guenther;	state Exp;
branches;
next	1.59;

1.59
date	2011.01.31.18.02.56;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2009.10.27.23.52.16;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2009.01.29.22.50.16;	author sobrado;	state Exp;
branches;
next	1.56;

1.56
date	2008.05.10.15.11.08;	author okan;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.17.16.09.29;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2007.10.17.20.02.33;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.01.02.25.26;	author ray;	state Exp;
branches;
next	1.52;

1.52
date	2007.08.31.23.14.21;	author ray;	state Exp;
branches;
next	1.51;

1.51
date	2007.02.19.00.08.38;	author jmc;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.13.18.39.34;	author mglocker;	state Exp;
branches;
next	1.49;

1.49
date	2005.11.29.20.43.31;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2005.01.30.21.00.31;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2004.11.04.18.44.59;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2004.09.16.18.34.05;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2004.06.22.03.15.33;	author avsm;	state Exp;
branches;
next	1.44;

1.44
date	2004.06.17.22.11.55;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2003.07.30.20.20.01;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2003.03.15.00.39.01;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2003.03.09.18.11.15;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2003.02.20.20.38.08;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2003.02.20.19.12.16;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2003.02.18.02.25.39;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.17.18.40.11;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2002.08.10.20.28.51;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2002.08.07.23.22.41;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.15.19.13.29;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.07.11.20.17.04;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.07.09.18.58.25;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.08.18.11.02;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.09.22.14.37;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.09.21.22.01;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.08.22.57.58;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.16.21.28.01;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.20.23.27.47;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.07.22.33.09;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.17.19.48.40;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2001.10.24.17.28.16;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.19.18.30.38;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.11.20.47.14;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.09.07.05.00;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.18.19.48.32;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.21.21.08.55;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.21.21.04.22;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.21.21.03.25;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.11.20.20.45.16;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.05.29.18.51.12;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.05.23.17.19.23;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	98.07.12.08.23.47;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.04.12.17.50.17;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.04.12.14.51.22;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.04.12.09.39.58;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.12.25.19.08.09;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.12.25.01.56.14;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.11.01.23.27.30;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.10.31.03.10.55;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.16.17.19.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.10.02.34;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.07.06.18.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.30;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.92
log
@When caching the mtime of the spool directory and system crontab files,
stash a struct timespec, not just a time_t.  Fixes a bug where cron
could skip re-reading the spool after two consecutive changes.
@
text
@/*	$OpenBSD: crontab.c,v 1.91 2015/11/17 21:56:57 millert Exp $	*/

/* Copyright 1988,1990,1993,1994 by Paul Vixie
 * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
 * Copyright (c) 1997,2000 by Internet Software Consortium, Inc.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>

#include <bitstring.h>		/* for structs.h */
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <locale.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

#include "pathnames.h"
#include "macros.h"
#include "structs.h"
#include "funcs.h"
#include "globals.h"

#define NHEADER_LINES 3

enum opt_t	{ opt_unknown, opt_list, opt_delete, opt_edit, opt_replace };

static	gid_t		crontab_gid;
static	gid_t		user_gid;
static	char		User[MAX_UNAME], RealUser[MAX_UNAME];
static	char		Filename[PATH_MAX], TempFilename[PATH_MAX];
static	FILE		*NewCrontab;
static	int		CheckErrorCount;
static	enum opt_t	Option;
static	struct passwd	*pw;
int			editit(const char *);
static	void		list_cmd(void),
			delete_cmd(void),
			edit_cmd(void),
			check_error(const char *),
			parse_args(int c, char *v[]),
			copy_crontab(FILE *, FILE *),
			die(int);
static	int		replace_cmd(void);

static void
usage(const char *msg)
{
	if (msg != NULL)
		warnx("usage error: %s", msg);
	fprintf(stderr, "usage: %s [-u user] file\n", __progname);
	fprintf(stderr, "       %s [-e | -l | -r] [-u user]\n", __progname);
	fprintf(stderr,
	    "\t\t(default operation is replace, per 1003.2)\n"
	    "\t-e\t(edit user's crontab)\n"
	    "\t-l\t(list user's crontab)\n"
	    "\t-r\t(delete user's crontab)\n");
	exit(EXIT_FAILURE);
}

int
main(int argc, char *argv[])
{
	int exitstatus;

	if (pledge("stdio rpath wpath cpath fattr getpw unix id proc exec",
	    NULL) == -1) {
		err(EXIT_FAILURE, "pledge");
	}

	user_gid = getgid();
	crontab_gid = getegid();

	setlocale(LC_ALL, "");
	openlog(__progname, LOG_PID, LOG_CRON);

	setvbuf(stderr, NULL, _IOLBF, 0);
	parse_args(argc, argv);		/* sets many globals, opens a file */
	if (!allowed(RealUser, _PATH_CRON_ALLOW, _PATH_CRON_DENY)) {
		fprintf(stderr, "You do not have permission to use crontab\n");
		fprintf(stderr, "See crontab(1) for more information\n");
		syslog(LOG_WARNING, "(%s) AUTH (crontab command not allowed)",
		    RealUser);
		exit(EXIT_FAILURE);
	}
	exitstatus = EXIT_SUCCESS;
	switch (Option) {
	case opt_list:
		list_cmd();
		break;
	case opt_delete:
		delete_cmd();
		break;
	case opt_edit:
		edit_cmd();
		break;
	case opt_replace:
		if (replace_cmd() < 0)
			exitstatus = EXIT_FAILURE;
		break;
	default:
		exitstatus = EXIT_FAILURE;
		break;
	}
	exit(exitstatus);
	/*NOTREACHED*/
}

static void
parse_args(int argc, char *argv[])
{
	int argch;

	if (!(pw = getpwuid(getuid())))
		errx(EXIT_FAILURE, "your UID isn't in the password database");
	if (strlen(pw->pw_name) >= sizeof User)
		errx(EXIT_FAILURE, "username too long");
	strlcpy(User, pw->pw_name, sizeof(User));
	strlcpy(RealUser, User, sizeof(RealUser));
	Filename[0] = '\0';
	Option = opt_unknown;
	while ((argch = getopt(argc, argv, "u:ler")) != -1) {
		switch (argch) {
		case 'u':
			if (getuid() != 0)
				errx(EXIT_FAILURE,
				    "only the super user may use -u");
			if (!(pw = getpwnam(optarg)))
				errx(EXIT_FAILURE, "unknown user %s", optarg);
			if (strlcpy(User, optarg, sizeof User) >= sizeof User)
				usage("username too long");
			break;
		case 'l':
			if (Option != opt_unknown)
				usage("only one operation permitted");
			Option = opt_list;
			break;
		case 'r':
			if (Option != opt_unknown)
				usage("only one operation permitted");
			Option = opt_delete;
			break;
		case 'e':
			if (Option != opt_unknown)
				usage("only one operation permitted");
			Option = opt_edit;
			break;
		default:
			usage(NULL);
		}
	}

	endpwent();

	if (Option != opt_unknown) {
		if (argv[optind] != NULL)
			usage("no arguments permitted after this option");
	} else {
		if (argv[optind] != NULL) {
			Option = opt_replace;
			if (strlcpy(Filename, argv[optind], sizeof Filename)
			    >= sizeof Filename)
				usage("filename too long");
		} else
			usage("file name must be specified for replace");
	}

	if (Option == opt_replace) {
		/* XXX - no longer need to open the file early, move this. */
		if (!strcmp(Filename, "-"))
			NewCrontab = stdin;
		else {
			/* relinquish the setgid status of the binary during
			 * the open, lest nonroot users read files they should
			 * not be able to read.  we can't use access() here
			 * since there's a race condition.  thanks go out to
			 * Arnt Gulbrandsen <agulbra@@pvv.unit.no> for spotting
			 * the race.
			 */

			if (setegid(user_gid) < 0)
				err(EXIT_FAILURE, "setegid(user_gid)");
			if (!(NewCrontab = fopen(Filename, "r")))
				err(EXIT_FAILURE, "%s", Filename);
			if (setegid(crontab_gid) < 0)
				err(EXIT_FAILURE, "setegid(crontab_gid)");
		}
	}
}

static void
list_cmd(void)
{
	char n[PATH_MAX];
	FILE *f;

	syslog(LOG_INFO, "(%s) LIST (%s)", RealUser, User);
	if (snprintf(n, sizeof n, "%s/%s", _PATH_CRON_SPOOL, User) >= sizeof(n))
		errc(EXIT_FAILURE, ENAMETOOLONG, "%s/%s", _PATH_CRON_SPOOL, User);
	if (!(f = fopen(n, "r"))) {
		if (errno == ENOENT)
			warnx("no crontab for %s", User);
		else
			warn("%s", n);
		exit(EXIT_FAILURE);
	}

	/* file is open. copy to stdout, close.
	 */
	Set_LineNum(1)

	copy_crontab(f, stdout);
	fclose(f);
}

static void
delete_cmd(void)
{
	char n[PATH_MAX];

	syslog(LOG_INFO, "(%s) DELETE (%s)", RealUser, User);
	if (snprintf(n, sizeof n, "%s/%s", _PATH_CRON_SPOOL, User) >= sizeof(n))
		errc(EXIT_FAILURE, ENAMETOOLONG, "%s/%s", _PATH_CRON_SPOOL, User);
	if (unlink(n) != 0) {
		if (errno == ENOENT)
			warnx("no crontab for %s", User);
		else
			warn("%s", n);
		exit(EXIT_FAILURE);
	}
	poke_daemon(RELOAD_CRON);
}

static void
check_error(const char *msg)
{
	CheckErrorCount++;
	fprintf(stderr, "\"%s\":%d: %s\n", Filename, LineNumber-1, msg);
}

static void
edit_cmd(void)
{
	char n[PATH_MAX], q[MAX_TEMPSTR];
	FILE *f;
	int t;
	struct stat statbuf, xstatbuf;
	struct timespec ts[2];

	syslog(LOG_INFO, "(%s) BEGIN EDIT (%s)", RealUser, User);
	if (snprintf(n, sizeof n, "%s/%s", _PATH_CRON_SPOOL, User) >= sizeof(n))
		errc(EXIT_FAILURE, ENAMETOOLONG, "%s/%s", _PATH_CRON_SPOOL, User);
	if (!(f = fopen(n, "r"))) {
		if (errno != ENOENT)
			err(EXIT_FAILURE, "%s", n);
		warnx("creating new crontab for %s", User);
		if (!(f = fopen(_PATH_DEVNULL, "r")))
			err(EXIT_FAILURE, _PATH_DEVNULL);
	}

	if (fstat(fileno(f), &statbuf) < 0) {
		warn("fstat");
		goto fatal;
	}
	ts[0] = statbuf.st_atim;
	ts[1] = statbuf.st_mtim;

	/* Turn off signals. */
	(void)signal(SIGHUP, SIG_IGN);
	(void)signal(SIGINT, SIG_IGN);
	(void)signal(SIGQUIT, SIG_IGN);

	if (snprintf(Filename, sizeof Filename, "%scrontab.XXXXXXXXXX",
	    _PATH_TMP) >= sizeof(Filename)) {
		warnc(ENAMETOOLONG, "%scrontab.XXXXXXXXXX", _PATH_TMP);
		goto fatal;
	}
	t = mkstemp(Filename);
	if (t == -1) {
		warn("%s", Filename);
		goto fatal;
	}
	if (!(NewCrontab = fdopen(t, "r+"))) {
		warn("fdopen");
		goto fatal;
	}

	Set_LineNum(1)

	copy_crontab(f, NewCrontab);
	fclose(f);
	if (fflush(NewCrontab) < 0)
		err(EXIT_FAILURE, "%s", Filename);
	if (futimens(t, ts) == -1)
		warn("unable to set times on %s", Filename);
 again:
	rewind(NewCrontab);
	if (ferror(NewCrontab)) {
		warnx("error writing new crontab to %s", Filename);
 fatal:
		unlink(Filename);
		exit(EXIT_FAILURE);
	}

	/* we still have the file open.  editors will generally rewrite the
	 * original file rather than renaming/unlinking it and starting a
	 * new one; even backup files are supposed to be made by copying
	 * rather than by renaming.  if some editor does not support this,
	 * then don't use it.  the security problems are more severe if we
	 * close and reopen the file around the edit.
	 */
	if (editit(Filename) == -1) {
		warn("error starting editor");
		goto fatal;
	}

	if (fstat(t, &statbuf) < 0) {
		warn("fstat");
		goto fatal;
	}
	if (timespeccmp(&ts[1], &statbuf.st_mtim, ==)) {
		if (lstat(Filename, &xstatbuf) == 0 &&
		    statbuf.st_ino != xstatbuf.st_ino) {
			warnx("crontab temp file moved, editor "
			   "may create backup files improperly");
		}
		warnx("no changes made to crontab");
		goto remove;
	}
	warnx("installing new crontab");
	switch (replace_cmd()) {
	case 0:
		break;
	case -1:
		for (;;) {
			printf("Do you want to retry the same edit? ");
			fflush(stdout);
			q[0] = '\0';
			if (fgets(q, sizeof q, stdin) == NULL) {
				putchar('\n');
				goto abandon;
			}
			switch (q[0]) {
			case 'y':
			case 'Y':
				goto again;
			case 'n':
			case 'N':
				goto abandon;
			default:
				fprintf(stderr, "Enter Y or N\n");
			}
		}
		/*NOTREACHED*/
	case -2:
	abandon:
		warnx("edits left in %s", Filename);
		goto done;
	default:
		warnx("panic: bad switch() in replace_cmd()");
		goto fatal;
	}
 remove:
	unlink(Filename);
 done:
	syslog(LOG_INFO, "(%s) END EDIT (%s)", RealUser, User);
}

/* returns	0	on success
 *		-1	on syntax error
 *		-2	on install error
 */
static int
replace_cmd(void)
{
	char n[PATH_MAX], envstr[MAX_ENVSTR];
	FILE *tmp;
	int ch, eof, fd;
	int error = 0;
	entry *e;
	uid_t euid = geteuid();
	time_t now = time(NULL);
	char **envp = env_init();

	if (envp == NULL) {
		warn(NULL);		/* ENOMEM */
		return (-2);
	}
	if (snprintf(TempFilename, sizeof TempFilename, "%s/tmp.XXXXXXXXX",
	    _PATH_CRON_SPOOL) >= sizeof(TempFilename)) {
		TempFilename[0] = '\0';
		warnc(ENAMETOOLONG, "%s/tmp.XXXXXXXXX", _PATH_CRON_SPOOL);
		return (-2);
	}
	if (euid != pw->pw_uid) {
		if (seteuid(pw->pw_uid) == -1) {
			warn("unable to change uid to %u", pw->pw_uid);
			return (-2);
		}
	}
	fd = mkstemp(TempFilename);
	if (euid != pw->pw_uid) {
		if (seteuid(euid) == -1) {
			warn("unable to change uid to %u", euid);
			return (-2);
		}
	}
	if (fd == -1 || !(tmp = fdopen(fd, "w+"))) {
		warn("%s", TempFilename);
		if (fd != -1) {
			close(fd);
			unlink(TempFilename);
		}
		TempFilename[0] = '\0';
		return (-2);
	}

	(void) signal(SIGHUP, die);
	(void) signal(SIGINT, die);
	(void) signal(SIGQUIT, die);

	/* write a signature at the top of the file.
	 *
	 * VERY IMPORTANT: make sure NHEADER_LINES agrees with this code.
	 */
	fprintf(tmp, "# DO NOT EDIT THIS FILE - edit the master and reinstall.\n");
	fprintf(tmp, "# (%s installed on %-24.24s)\n", Filename, ctime(&now));
	fprintf(tmp, "# (Cron version %s)\n", CRON_VERSION);

	/* copy the crontab to the tmp
	 */
	rewind(NewCrontab);
	Set_LineNum(1)
	while (EOF != (ch = get_char(NewCrontab)))
		putc(ch, tmp);
	ftruncate(fileno(tmp), ftello(tmp));	/* XXX redundant with "w+"? */
	fflush(tmp);  rewind(tmp);

	if (ferror(tmp)) {
		warnx("error while writing new crontab to %s", TempFilename);
		fclose(tmp);
		error = -2;
		goto done;
	}

	/* check the syntax of the file being installed.
	 */

	/* BUG: was reporting errors after the EOF if there were any errors
	 * in the file proper -- kludged it by stopping after first error.
	 *		vix 31mar87
	 */
	Set_LineNum(1 - NHEADER_LINES)
	CheckErrorCount = 0;  eof = FALSE;
	while (!CheckErrorCount && !eof) {
		switch (load_env(envstr, tmp)) {
		case -1:
			/* check for data before the EOF */
			if (envstr[0] != '\0') {
				Set_LineNum(LineNumber + 1);
				check_error("premature EOF");
			}
			eof = TRUE;
			break;
		case FALSE:
			e = load_entry(tmp, check_error, pw, envp);
			if (e)
				free_entry(e);
			break;
		case TRUE:
			break;
		}
	}

	if (CheckErrorCount != 0) {
		warnx("errors in crontab file, unable to install");
		fclose(tmp);
		error = -1;
		goto done;
	}

	if (fclose(tmp) == EOF) {
		warn("fclose");
		error = -2;
		goto done;
	}

	if (snprintf(n, sizeof n, "%s/%s", _PATH_CRON_SPOOL, User) >= sizeof(n)) {
		warnc(ENAMETOOLONG, "%s/%s", _PATH_CRON_SPOOL, User);
		error = -2;
		goto done;
	}
	if (rename(TempFilename, n)) {
		warn("unable to rename %s to %s", TempFilename, n);
		error = -2;
		goto done;
	}
	TempFilename[0] = '\0';
	syslog(LOG_INFO, "(%s) REPLACE (%s)", RealUser, User);

	poke_daemon(RELOAD_CRON);

done:
	(void) signal(SIGHUP, SIG_DFL);
	(void) signal(SIGINT, SIG_DFL);
	(void) signal(SIGQUIT, SIG_DFL);
	if (TempFilename[0]) {
		(void) unlink(TempFilename);
		TempFilename[0] = '\0';
	}
	return (error);
}

/*
 * Execute an editor on the specified pathname, which is interpreted
 * from the shell.  This means flags may be included.
 *
 * Returns -1 on error, or the exit value on success.
 */
int
editit(const char *pathname)
{
	char *argp[] = {"sh", "-c", NULL, NULL}, *ed, *p;
	sig_t sighup, sigint, sigquit, sigchld;
	pid_t pid;
	int saved_errno, st, ret = -1;

	ed = getenv("VISUAL");
	if (ed == NULL || ed[0] == '\0')
		ed = getenv("EDITOR");
	if (ed == NULL || ed[0] == '\0')
		ed = _PATH_VI;
	if (asprintf(&p, "%s %s", ed, pathname) == -1)
		return (-1);
	argp[2] = p;

	sighup = signal(SIGHUP, SIG_IGN);
	sigint = signal(SIGINT, SIG_IGN);
	sigquit = signal(SIGQUIT, SIG_IGN);
	sigchld = signal(SIGCHLD, SIG_DFL);
	if ((pid = fork()) == -1)
		goto fail;
	if (pid == 0) {
		/* Drop setgid and exec the command. */
		if (setgid(user_gid) == -1) {
			warn("unable to set gid to %u", user_gid);
		} else {
			execv(_PATH_BSHELL, argp);
			warn("unable to execute %s", _PATH_BSHELL);
		}
		_exit(127);
	}
	while (waitpid(pid, &st, 0) == -1)
		if (errno != EINTR)
			goto fail;
	if (!WIFEXITED(st))
		errno = EINTR;
	else
		ret = WEXITSTATUS(st);

 fail:
	saved_errno = errno;
	(void)signal(SIGHUP, sighup);
	(void)signal(SIGINT, sigint);
	(void)signal(SIGQUIT, sigquit);
	(void)signal(SIGCHLD, sigchld);
	free(p);
	errno = saved_errno;
	return (ret);
}

static void
die(int x)
{
	if (TempFilename[0])
		(void) unlink(TempFilename);
	_exit(EXIT_FAILURE);
}

static void
copy_crontab(FILE *f, FILE *out)
{
	int ch, x;

	/* ignore the top few comments since we probably put them there.
	 */
	x = 0;
	while (EOF != (ch = get_char(f))) {
		if ('#' != ch) {
			putc(ch, out);
			break;
		}
		while (EOF != (ch = get_char(f)))
			if (ch == '\n')
				break;
		if (++x >= NHEADER_LINES)
			break;
	}

	/* copy out the rest of the crontab (if any)
	 */
	if (EOF != ch)
		while (EOF != (ch = get_char(f)))
			putc(ch, out);
}
@


1.91
log
@Check for setgid() failure before executing editor and warn if
exec of shell + editor fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.90 2015/11/14 13:09:14 millert Exp $	*/
d22 1
@


1.90
log
@Remove log_it() and call syslog(3) directly using the same format:
"(username) WHAT (details)".  Logs due to normal operation (e.g.
crontab operations or running commands) are logged at LOG_INFO like
before.  Actual errors are logged at LOG_ERR, less important things
are logged at LOG_WARNING OR LOG_NOTICE.  Also ignore SIGHUP now
that there is no log file to reopen.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.89 2015/11/12 21:12:05 millert Exp $	*/
d564 7
a570 3
		setgid(getgid());
		setuid(getuid());
		execv(_PATH_BSHELL, argp);
@


1.89
log
@Use absolute paths in pathnames.h.  There is no longer a need to
chdir(2) to the cron dir and cron(8) now changes to / via daemon(3).
We no longer try to create/chmod the spool directories as they
should be set correctly at install time.  The setegid(crontab)
has been moved to open_socket() so it is closer to the chmod(2)
call that needs it.  OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.88 2015/11/11 21:20:51 millert Exp $	*/
d34 1
a85 3
	user_gid = getgid();
	crontab_gid = getegid();

d91 3
d95 1
d102 2
a103 1
		log_it(RealUser, "AUTH", "crontab command not allowed");
d217 1
a217 1
	log_it(RealUser, "LIST", User);
d241 1
a241 1
	log_it(RealUser, "DELETE", User);
d270 1
a270 1
	log_it(RealUser, "BEGIN EDIT", User);
d386 1
a386 1
	log_it(RealUser, "END EDIT", User);
d519 1
a519 1
	log_it(RealUser, "REPLACE", User);
@


1.88
log
@Use warn/warnx and err/errx.  OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.87 2015/11/11 17:19:22 millert Exp $	*/
d27 1
d50 1
a50 1
static	char		Filename[MAX_FNAME], TempFilename[MAX_FNAME];
d97 1
a97 2
	set_cron_cwd();
	if (!allowed(RealUser, CRON_ALLOW, CRON_DENY)) {
d186 1
a186 4
		/* we have to open the file here because we're going to
		 * chdir(2) into /var/cron before we get around to
		 * reading the file.
		 */
d211 1
a211 1
	char n[MAX_FNAME];
d215 2
a216 2
	if (snprintf(n, sizeof n, "%s/%s", CRON_SPOOL, User) >= sizeof(n))
		errc(EXIT_FAILURE, ENAMETOOLONG, "%s/%s", CRON_SPOOL, User);
d236 1
a236 1
	char n[MAX_FNAME];
d239 2
a240 2
	if (snprintf(n, sizeof n, "%s/%s", CRON_SPOOL, User) >= sizeof(n))
		errc(EXIT_FAILURE, ENAMETOOLONG, "%s/%s", CRON_SPOOL, User);
d248 1
a248 1
	poke_daemon(CRON_SPOOL, RELOAD_CRON);
d261 1
a261 1
	char n[MAX_FNAME], q[MAX_TEMPSTR];
d268 2
a269 2
	if (snprintf(n, sizeof n, "%s/%s", CRON_SPOOL, User) >= sizeof(n))
		errc(EXIT_FAILURE, ENAMETOOLONG, "%s/%s", CRON_SPOOL, User);
d393 1
a393 1
	char n[MAX_FNAME], envstr[MAX_ENVSTR];
d407 1
a407 1
	    CRON_SPOOL) >= sizeof(TempFilename)) {
d409 1
a409 1
		warnc(ENAMETOOLONG, "%s/tmp.XXXXXXXXX", CRON_SPOOL);
d505 2
a506 2
	if (snprintf(n, sizeof n, "%s/%s", CRON_SPOOL, User) >= sizeof(n)) {
		warnc(ENAMETOOLONG, "%s/%s", CRON_SPOOL, User);
d518 1
a518 1
	poke_daemon(CRON_SPOOL, RELOAD_CRON);
@


1.87
log
@Niether cron nor crontab need flock permission.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.86 2015/11/11 15:21:01 millert Exp $	*/
d67 2
a68 1
	fprintf(stderr, "%s: usage error: %s\n", __progname, msg);
d89 1
a89 2
		perror("pledge");
		exit(EXIT_FAILURE);
d98 1
a98 3
		fprintf(stderr,
			"You (%s) are not allowed to use this program (%s)\n",
			User, __progname);
d131 4
a134 10
	if (!(pw = getpwuid(getuid()))) {
		fprintf(stderr, "%s: your UID isn't in the passwd file.\n",
			__progname);
		fprintf(stderr, "bailing out.\n");
		exit(EXIT_FAILURE);
	}
	if (strlen(pw->pw_name) >= sizeof User) {
		fprintf(stderr, "username too long\n");
		exit(EXIT_FAILURE);
	}
d142 5
a146 10
			if (getuid() != 0) {
				fprintf(stderr,
					"must be privileged to use -u\n");
				exit(EXIT_FAILURE);
			}
			if (!(pw = getpwnam(optarg))) {
				fprintf(stderr, "%s:  user `%s' unknown\n",
					__progname, optarg);
				exit(EXIT_FAILURE);
			}
d166 1
a166 1
			usage("unrecognized option");
d201 6
a206 12
			if (setegid(user_gid) < 0) {
				perror("setegid(user_gid)");
				exit(EXIT_FAILURE);
			}
			if (!(NewCrontab = fopen(Filename, "r"))) {
				perror(Filename);
				exit(EXIT_FAILURE);
			}
			if (setegid(crontab_gid) < 0) {
				perror("setegid(crontab_gid)");
				exit(EXIT_FAILURE);
			}
d218 2
a219 4
	if (snprintf(n, sizeof n, "%s/%s", CRON_SPOOL, User) >= sizeof(n)) {
		fprintf(stderr, "path too long\n");
		exit(EXIT_FAILURE);
	}
d222 1
a222 1
			fprintf(stderr, "no crontab for %s\n", User);
d224 1
a224 1
			perror(n);
d242 2
a243 4
	if (snprintf(n, sizeof n, "%s/%s", CRON_SPOOL, User) >= sizeof(n)) {
		fprintf(stderr, "path too long\n");
		exit(EXIT_FAILURE);
	}
d246 1
a246 1
			fprintf(stderr, "no crontab for %s\n", User);
d248 1
a248 1
			perror(n);
d271 2
a272 4
	if (snprintf(n, sizeof n, "%s/%s", CRON_SPOOL, User) >= sizeof(n)) {
		fprintf(stderr, "path too long\n");
		exit(EXIT_FAILURE);
	}
d274 5
a278 10
		if (errno != ENOENT) {
			perror(n);
			exit(EXIT_FAILURE);
		}
		fprintf(stderr, "no crontab for %s - using an empty one\n",
			User);
		if (!(f = fopen(_PATH_DEVNULL, "r"))) {
			perror(_PATH_DEVNULL);
			exit(EXIT_FAILURE);
		}
d282 1
a282 1
		perror("fstat");
d295 1
a295 1
		fprintf(stderr, "path too long\n");
d300 1
a300 1
		perror(Filename);
d304 1
a304 1
		perror("fdopen");
d312 4
a315 5
	if (fflush(NewCrontab) < 0) {
		perror(Filename);
		exit(EXIT_FAILURE);
	}
	(void)futimens(t, ts);
d319 1
a319 2
		fprintf(stderr, "%s: error while writing new crontab to %s\n",
			__progname, Filename);
d338 1
a338 1
		perror("fstat");
d344 2
a345 2
			fprintf(stderr, "%s: crontab temp file moved, editor "
			   "may create backup files improperly\n", __progname);
d347 1
a347 2
		fprintf(stderr, "%s: no changes made to crontab\n",
			__progname);
d350 1
a350 1
	fprintf(stderr, "%s: installing new crontab\n", __progname);
d377 1
a377 2
		fprintf(stderr, "%s: edits left in %s\n",
			__progname, Filename);
d380 1
a380 2
		fprintf(stderr, "%s: panic: bad switch() in replace_cmd()\n",
			__progname);
d406 1
a406 1
		fprintf(stderr, "%s: Cannot allocate memory.\n", __progname);
d412 1
a412 1
		fprintf(stderr, "path too long\n");
d417 1
a417 2
			fprintf(stderr, "%s: Unable to change uid to %u.\n",
			    __progname, pw->pw_uid);
d424 1
a424 2
			fprintf(stderr, "%s: Unable to change uid to %u.\n",
			    __progname, euid);
d429 1
a429 1
		perror(TempFilename);
d460 1
a460 2
		fprintf(stderr, "%s: error while writing new crontab to %s\n",
			__progname, TempFilename);
d496 1
a496 1
		fprintf(stderr, "errors in crontab file, can't install.\n");
d503 1
a503 1
		perror("fclose");
d509 1
a509 1
		fprintf(stderr, "path too long\n");
d514 1
a514 3
		fprintf(stderr, "%s: error renaming %s to %s\n",
			__progname, TempFilename, n);
		perror("rename");
@


1.86
log
@For "crontab -u user -e" change the euid for the mkstemp() call
instead of calling fchown() after the fact.  Fixes a pledge()
issue.  OK semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.85 2015/11/09 16:37:07 millert Exp $	*/
d86 1
a86 1
	if (pledge("stdio rpath wpath cpath fattr getpw unix flock id proc exec",
@


1.85
log
@Remove unused xpid argument to log_it().
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.84 2015/11/09 15:57:39 millert Exp $	*/
d436 1
d450 16
a465 1
	if ((fd = mkstemp(TempFilename)) == -1 || !(tmp = fdopen(fd, "w+"))) {
a536 7
		goto done;
	}

	if (fchown(fileno(tmp), pw->pw_uid, -1) < 0) {
		perror("fchown");
		fclose(tmp);
		error = -2;
@


1.84
log
@Rename AT_DIR -> AT_SPOOL and SPOOL_DIR -> CRON_SPOOL to improve
readability.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.83 2015/11/06 23:47:42 millert Exp $	*/
a45 1
static	pid_t		Pid;
a82 1
	Pid = getpid();
d102 1
a102 1
		log_it(RealUser, Pid, "AUTH", "crontab command not allowed");
d236 1
a236 1
	log_it(RealUser, Pid, "LIST", User);
d262 1
a262 1
	log_it(RealUser, Pid, "DELETE", User);
d293 1
a293 1
	log_it(RealUser, Pid, "BEGIN EDIT", User);
d421 1
a421 1
	log_it(RealUser, Pid, "END EDIT", User);
d550 1
a550 1
	log_it(RealUser, Pid, "REPLACE", User);
@


1.83
log
@Use __progname instead of the homegrown ProgramName.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.82 2015/11/04 20:28:17 millert Exp $	*/
d239 1
a239 1
	if (snprintf(n, sizeof n, "%s/%s", SPOOL_DIR, User) >= sizeof(n)) {
d265 1
a265 1
	if (snprintf(n, sizeof n, "%s/%s", SPOOL_DIR, User) >= sizeof(n)) {
d276 1
a276 1
	poke_daemon(SPOOL_DIR, RELOAD_CRON);
d296 1
a296 1
	if (snprintf(n, sizeof n, "%s/%s", SPOOL_DIR, User) >= sizeof(n)) {
d446 1
a446 1
	    SPOOL_DIR) >= sizeof(TempFilename)) {
d539 1
a539 1
	if (snprintf(n, sizeof n, "%s/%s", SPOOL_DIR, User) >= sizeof(n)) {
d554 1
a554 1
	poke_daemon(SPOOL_DIR, RELOAD_CRON);
@


1.82
log
@Change cron from including all headers in every file to only including
what each .c file needs.  I have not removed cron.h since it will
be used in a future clean up of the cron's .h files.  OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.81 2015/11/03 21:10:08 millert Exp $	*/
a19 2
#define	MAIN_PROGRAM

d68 3
a70 3
	fprintf(stderr, "%s: usage error: %s\n", ProgramName, msg);
	fprintf(stderr, "usage: %s [-u user] file\n", ProgramName);
	fprintf(stderr, "       %s [-e | -l | -r] [-u user]\n", ProgramName);
a86 1
	ProgramName = argv[0];
d102 1
a102 1
			User, ProgramName);
d137 1
a137 1
			ProgramName);
d159 1
a159 1
					ProgramName, optarg);
d353 1
a353 1
			ProgramName, Filename);
d379 1
a379 1
			   "may create backup files improperly\n", ProgramName);
d382 1
a382 1
			ProgramName);
d385 1
a385 1
	fprintf(stderr, "%s: installing new crontab\n", ProgramName);
d413 1
a413 1
			ProgramName, Filename);
d417 1
a417 1
			ProgramName);
d442 1
a442 1
		fprintf(stderr, "%s: Cannot allocate memory.\n", ProgramName);
d484 1
a484 1
			ProgramName, TempFilename);
d546 1
a546 1
			ProgramName, TempFilename, n);
@


1.81
log
@If pledge(2) fails use perror instead of log_it(RealUser, ...) since
RealUser has not been filled in yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.80 2015/11/03 16:30:31 millert Exp $	*/
a19 2
#include <err.h>

d22 21
a42 1
#include "cron.h"
a47 2
static char	*getoptargs = "u:ler";

d152 1
a152 1
	while (-1 != (argch = getopt(argc, argv, getoptargs))) {
@


1.80
log
@It is only necessary to swap the effective gid when reading a file.
Since we got rid of TMPDIR support there's no need to swap gids
when creating or unlinking the temporary file.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.79 2015/11/02 20:09:02 millert Exp $	*/
d77 2
a78 2
		log_it(RealUser, getpid(), "pledge", strerror(errno));
		exit(1);
@


1.79
log
@Use setegid() directly instead of swap_gids() / swap_gids_back().
OK jca@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.78 2015/10/31 12:13:01 millert Exp $	*/
a316 4
	if (setegid(user_gid) < 0) {
		perror("setegid(user_gid)");
		exit(EXIT_FAILURE);
	}
a317 4
	if (setegid(crontab_gid) < 0) {
		perror("setegid(crontab_gid)");
		exit(EXIT_FAILURE);
	}
a341 4
		if (setegid(user_gid) < 0) {
			perror("setegid(user_gid)");
			exit(EXIT_FAILURE);
		}
a342 4
		if (setegid(crontab_gid) < 0) {
			perror("setegid(crontab_gid)");
			exit(EXIT_FAILURE);
		}
a362 4
		if (setegid(user_gid) < 0) {
			perror("setegid(user_gid)");
			exit(EXIT_FAILURE);
		}
a367 4
		if (setegid(crontab_gid) < 0) {
			perror("setegid(crontab_gid)");
			exit(EXIT_FAILURE);
		}
a407 4
	if (setegid(user_gid) < 0) {
		perror("setegid(user_gid)");
		exit(EXIT_FAILURE);
	}
a408 4
	if (setegid(crontab_gid) < 0) {
		perror("setegid(crontab_gid)");
		exit(EXIT_FAILURE);
	}
@


1.78
log
@swap_gids and swap_gids_back are only used by crontab.c so
move them there.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.77 2015/10/29 23:14:30 millert Exp $	*/
d33 2
a34 1
static	gid_t		save_egid;
a50 11
static int swap_gids(void)
{
	save_egid = getegid();
	return (setegid(getgid()));
}

static int swap_gids_back(void)
{
	return (setegid(save_egid));
}

d71 2
d203 2
a204 2
			if (swap_gids() < 0) {
				perror("swapping gids");
d211 2
a212 2
			if (swap_gids_back() < 0) {
				perror("swapping gids back");
d317 2
a318 2
	if (swap_gids() < 0) {
		perror("swapping gids");
d322 2
a323 2
	if (swap_gids_back() < 0) {
		perror("swapping gids back");
d350 2
a351 2
		if (swap_gids() < 0) {
			perror("swapping gids");
d355 2
a356 2
		if (swap_gids_back() < 0) {
			perror("swapping gids back");
d379 2
a380 2
		if (swap_gids() < 0) {
			perror("swapping gids");
d388 2
a389 2
		if (swap_gids_back() < 0) {
			perror("swapping gids back");
d432 2
a433 2
	if (swap_gids() < 0) {
		perror("swapping gids");
d437 2
a438 2
	if (swap_gids_back() < 0) {
		perror("swapping gids back");
@


1.77
log
@Also need exec to run the editor of course.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.76 2015/10/29 22:46:31 millert Exp $	*/
d33 1
d49 11
@


1.76
log
@crontab needs "proc" for fork(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.75 2015/10/28 20:17:31 deraadt Exp $	*/
d71 1
a71 1
	if (pledge("stdio rpath wpath cpath fattr getpw unix flock proc id",
@


1.75
log
@pledge
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.74 2015/10/26 15:50:06 millert Exp $	*/
d71 1
a71 1
	if (pledge("stdio rpath wpath cpath fattr getpw unix flock id",
@


1.74
log
@Remove TMPDIR support, it is not really useful in crontab.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.73 2015/10/26 14:27:41 millert Exp $	*/
d70 6
@


1.73
log
@Remove some useless defines and the set_cron_uid() function.
OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.72 2015/10/06 14:58:37 tedu Exp $	*/
a266 1
	const char *tmpdir;
d302 2
a303 7
	tmpdir = getenv("TMPDIR");
	if (tmpdir == NULL || tmpdir[0] == '\0')
		tmpdir = _PATH_TMP;
	for (t = strlen(tmpdir); t != 0 && tmpdir[t - 1] == '/'; t--)
		continue;
	if (snprintf(Filename, sizeof Filename, "%.*s/crontab.XXXXXXXXXX",
	    t, tmpdir) >= sizeof(Filename)) {
@


1.72
log
@clear out some more legacy code and whatnot
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.71 2015/02/09 22:35:08 deraadt Exp $	*/
d129 1
a129 1
			if (getuid() != ROOT_UID) {
@


1.71
log
@correct copyright, upon approval from paul vixie via todd miller.  the
head copyright assertion was seperated from the remaining ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.70 2015/01/23 19:07:27 tedu Exp $	*/
a17 5
 */

/* crontab - install and manage per-user crontab files
 * vix 02may87 [RCS has the rest of the log]
 * vix 26jan87 [original]
@


1.70
log
@braces to open a function go on their own line like god intended
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.69 2015/01/23 02:37:25 tedu Exp $	*/
a3 4
 * All rights reserved
 */

/*
@


1.69
log
@Remove the OK and ERR macros. They obfuscate the code and don't
help legibility. (unix system calls use 0 for ok, but hundreds of
other projects use 1 to indicate success.) Despite the name, many
system calls (e.g., open) also return not OK values for success.
It also cleans up some weird code like int crontab_fd = OK - 1;
This diff is mechanical in nature. Later I will fix the bugs it reveals.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.68 2015/01/23 01:01:06 tedu Exp $	*/
d59 2
a60 1
usage(const char *msg) {
d73 2
a74 1
main(int argc, char *argv[]) {
d117 2
a118 1
parse_args(int argc, char *argv[]) {
d219 2
a220 1
list_cmd(void) {
d246 2
a247 1
delete_cmd(void) {
d266 2
a267 1
check_error(const char *msg) {
d273 2
a274 1
edit_cmd(void) {
d455 2
a456 1
replace_cmd(void) {
d646 2
a647 1
die(int x) {
d654 2
a655 1
copy_crontab(FILE *f, FILE *out) {
@


1.68
log
@remove debug code.
I think the level of debug code in cron is excessive for a program
that has reached feature complete. If cron needs to provide more
information to the user about its operational status, I think syslog
would be more appropriate. (The debug flags also disable forking
into the background, so they aren't even that useful for debugging a
live system.)
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.67 2015/01/14 17:27:29 millert Exp $	*/
d199 1
a199 1
			if (swap_gids() < OK) {
d207 1
a207 1
			if (swap_gids_back() < OK) {
d315 1
a315 1
	if (swap_gids() < OK) {
d320 1
a320 1
	if (swap_gids_back() < OK) {
d337 1
a337 1
	if (fflush(NewCrontab) < OK) {
d348 1
a348 1
		if (swap_gids() < OK) {
d353 1
a353 1
		if (swap_gids_back() < OK) {
d377 1
a377 1
		if (swap_gids() < OK) {
d386 1
a386 1
		if (swap_gids_back() < OK) {
d430 1
a430 1
	if (swap_gids() < OK) {
d435 1
a435 1
	if (swap_gids_back() < OK) {
d517 1
a517 1
		case ERR:
d542 1
a542 1
	if (fchown(fileno(tmp), pw->pw_uid, -1) < OK) {
@


1.67
log
@Use standard types for wait, readdir, signals and pids.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.66 2015/01/14 17:27:13 millert Exp $	*/
a38 4
#if DEBUGGING
static char	*Options[] = { "???", "list", "delete", "edit", "replace" };
static char	*getoptargs = "u:lerx:";
#else
a39 1
#endif
a133 6
#if DEBUGGING
		case 'x':
			if (!set_debug_flags(optarg))
				usage("bad debug option");
			break;
#endif
a212 3

	Debug(DMISC, ("user=%s, file=%s, option=%s\n",
		      User, Filename, Options[(int)Option]))
@


1.66
log
@Remove compatibility defines for ancient systems.  We assume a
reasonable level of POSIX compliance.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.65 2014/11/26 18:34:52 millert Exp $	*/
d46 1
a46 1
static	PID_T		Pid;
@


1.65
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.64 2011/08/22 19:32:42 millert Exp $	*/
d146 1
a146 1
			if (MY_UID(pw) != ROOT_UID) {
a555 1
#ifdef HAVE_FCHOWN
a561 8
#else
	if (chown(TempFilename, pw->pw_uid, -1) < OK) {
		perror("chown");
		fclose(tmp);
		error = -2;
		goto done;
	}
#endif
@


1.64
log
@Use standard EXIT_SUCCESS/EXIT_FAILURE and STD{IN,OUT,ERR}_FILENO
defines instead of using custom macros.  OK deraadt@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.63 2011/08/19 20:53:36 millert Exp $	*/
d85 1
a85 3
#if defined(BSD)
	setlinebuf(stderr);
#endif
@


1.63
log
@Use futimens() instead of futimes() to avoid converting to/from
struct timeval.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.62 2011/05/19 15:00:17 phessler Exp $	*/
d73 1
a73 1
	exit(ERROR_EXIT);
d96 1
a96 1
		exit(ERROR_EXIT);
d98 1
a98 1
	exitstatus = OK_EXIT;
d111 1
a111 1
			exitstatus = ERROR_EXIT;
d114 1
a114 1
		exitstatus = ERROR_EXIT;
d129 1
a129 1
		exit(ERROR_EXIT);
d133 1
a133 1
		exit(ERROR_EXIT);
d151 1
a151 1
				exit(ERROR_EXIT);
d156 1
a156 1
				exit(ERROR_EXIT);
d214 1
a214 1
				exit(ERROR_EXIT);
d218 1
a218 1
				exit(ERROR_EXIT);
d222 1
a222 1
				exit(ERROR_EXIT);
d239 1
a239 1
		exit(ERROR_EXIT);
d246 1
a246 1
		exit(ERROR_EXIT);
d264 1
a264 1
		exit(ERROR_EXIT);
d271 1
a271 1
		exit(ERROR_EXIT);
d294 1
a294 1
		exit(ERROR_EXIT);
d299 1
a299 1
			exit(ERROR_EXIT);
d305 1
a305 1
			exit(ERROR_EXIT);
d333 1
a333 1
		exit(ERROR_EXIT);
d338 1
a338 1
		exit(ERROR_EXIT);
d355 1
a355 1
		exit(ERROR_EXIT);
d366 1
a366 1
			exit(ERROR_EXIT);
d371 1
a371 1
			exit(ERROR_EXIT);
d373 1
a373 1
		exit(ERROR_EXIT);
d395 1
a395 1
			exit(ERROR_EXIT);
d404 1
a404 1
			exit(ERROR_EXIT);
d448 1
a448 1
		exit(ERROR_EXIT);
d453 1
a453 1
		exit(ERROR_EXIT);
d666 1
a666 1
	_exit(ERROR_EXIT);
@


1.62
log
@Fix some possible NULL pointer dereferences, and a little bit of cleanup.

From Lawrence Teo (thanks!)

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.61 2011/04/04 15:17:52 millert Exp $	*/
d289 1
a289 2
	struct timespec mtimespec;
	struct timeval tv[2];
d313 2
a314 7
	/*
	 * Note that timespec has higher precision than timeval so we
	 * store mtimespec using timeval precision so we can compare later.
	 */
	TIMESPEC_TO_TIMEVAL(&tv[0], &statbuf.st_atimespec);
	TIMESPEC_TO_TIMEVAL(&tv[1], &statbuf.st_mtimespec);
	TIMEVAL_TO_TIMESPEC(&tv[1], &mtimespec);
d357 1
a357 1
	(void)futimes(t, tv);
d392 1
a392 1
	if (timespeccmp(&mtimespec, &statbuf.st_mtimespec, -) == 0) {
@


1.61
log
@Remove unused variables; from Michael W. Bombardieri
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.60 2011/02/11 07:14:49 guenther Exp $	*/
d550 1
a550 1
				free(e);
@


1.60
log
@Make "crontab -l" not crash on crontab files that don't have the
expected three lines of comments.  Factor out the "copy a crontab"
logic and merge it into ignore_comments().

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.59 2011/01/31 18:02:56 millert Exp $	*/
a234 1
	int ch;
d287 1
a287 1
	int ch, t;
@


1.59
log
@Make "crontab -e" honor TMPDIR; from the Openwall project (ldv)
OK miod@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.58 2009/10/27 23:52:16 deraadt Exp $	*/
d59 1
a61 1
static	int		ignore_comments(FILE *);
d254 1
a254 6
	/* ignore the top few comments since we probably put them there.
	 */
	ch = ignore_comments(f);

	while (EOF != (ch = get_char(f)))
		putchar(ch);
d358 1
a358 9
	/* ignore the top few comments since we probably put them there.
	 */
	ch = ignore_comments(f);

	/* copy the rest of the crontab (if any) to the temp file.
	 */
	if (EOF != ch)
		while (EOF != (ch = get_char(f)))
			putc(ch, NewCrontab);
d676 2
a677 2
static int
ignore_comments(FILE *f) {
d680 2
d685 1
a685 1
			putc(ch, NewCrontab);
d695 5
a699 1
	return ch;
@


1.58
log
@using the rcsid is silly
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.57 2009/01/29 22:50:16 sobrado Exp $	*/
d291 1
d333 7
a339 2
	if (snprintf(Filename, sizeof Filename, "%scrontab.XXXXXXXXXX",
	    _PATH_TMP) >= sizeof(Filename)) {
d343 10
a352 1
	if (-1 == (t = mkstemp(Filename))) {
d384 4
d389 4
d413 4
d422 4
d466 4
d471 4
@


1.57
log
@tweak usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.56 2008/05/10 15:11:08 okan Exp $	*/
a23 2
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.56 2008/05/10 15:11:08 okan Exp $";

d484 1
a484 1
	fprintf(tmp, "# (Cron version %s -- %s)\n", CRON_VERSION, rcsid);
@


1.56
log
@from ray@@

- move the ignoring of the top few (3) comments into a function of its own.
- ignore these comments for crontab listings.

based on a patch from Slava Semushin

ok ray@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.55 2007/11/17 16:09:29 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.55 2007/11/17 16:09:29 millert Exp $";
d68 7
a74 6
	fprintf(stderr, "usage:\t%s [-u user] file\n", ProgramName);
	fprintf(stderr, "\t%s [ -e | -l | -r ] [-u user]\n", ProgramName);
	fprintf(stderr, "\t\t(default operation is replace, per 1003.2)\n");
	fprintf(stderr, "\t-e\t(edit user's crontab)\n");
	fprintf(stderr, "\t-l\t(list user's crontab)\n");
	fprintf(stderr, "\t-r\t(delete user's crontab)\n");
@


1.55
log
@Deal with timespec vs. timeval precision issues.  Fixes a problem
where the "no changes" case was not properly detected due to timespec
supporting nanosec resolution but timeval only supporting microsec
resolution.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.54 2007/10/17 20:02:33 deraadt Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.54 2007/10/17 20:02:33 deraadt Exp $";
d63 1
d254 5
d293 1
a293 1
	int ch, t, x;
d351 1
a351 12
	x = 0;
	while (EOF != (ch = get_char(f))) {
		if ('#' != ch) {
			putc(ch, NewCrontab);
			break;
		}
		while (EOF != (ch = get_char(f)))
			if (ch == '\n')
				break;
		if (++x >= NHEADER_LINES)
			break;
	}
d649 20
@


1.54
log
@- Be more careful about pre-existing SIGCHLD handlers (or SIG_IGN) by
  temporarily restoring default behaviour.  This is not 100% ideal.
  But this fixes editor handling in mail... bah, it is really unfortunate
  that got broken
- refactor the restoration code as well, to make it simpler
ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.53 2007/09/01 02:25:26 ray Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.53 2007/09/01 02:25:26 ray Exp $";
d314 4
a317 1
	memcpy(&mtimespec, &statbuf.st_mtimespec, sizeof(mtimespec));
d320 1
@


1.53
log
@Include err.h and remove unused variables.

OK millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.52 2007/08/31 23:14:21 ray Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.52 2007/08/31 23:14:21 ray Exp $";
d601 1
a601 1
	sig_t sighup, sigint, sigquit;
d603 1
a603 1
	int saved_errno, st;
d617 1
d629 1
a629 5
	free(p);
	(void)signal(SIGHUP, sighup);
	(void)signal(SIGINT, sigint);
	(void)signal(SIGQUIT, sigquit);
	if (!WIFEXITED(st)) {
d631 2
a632 3
		return (-1);
	}
	return (WEXITSTATUS(st));
d639 1
d642 1
a642 1
	return (-1);
@


1.52
log
@Copy editit() from sendbug, synchronizing editor calling code.

OK otto, millert, beck, mbalmer, deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.51 2007/02/19 00:08:38 jmc Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.51 2007/02/19 00:08:38 jmc Exp $";
d31 2
a290 2
	WAIT_T waiter;
	PID_T pid, xpid;
@


1.51
log
@tidy up synopsis and usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.50 2007/02/13 18:39:34 mglocker Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.50 2007/02/13 18:39:34 mglocker Exp $";
d53 1
d283 1
a283 1
	char n[MAX_FNAME], q[MAX_TEMPSTR], *editor;
a374 5
	if (((editor = getenv("VISUAL")) == NULL || *editor == '\0') &&
	    ((editor = getenv("EDITOR")) == NULL || *editor == '\0')) {
		editor = EDITOR;
	}

d382 2
a383 4

	switch (pid = fork()) {
	case -1:
		perror("fork");
a384 22
	case 0:
		/* child */
		if (setgid(MY_GID(pw)) < 0) {
			perror("setgid(getgid())");
			exit(ERROR_EXIT);
		}
		if (chdir(_PATH_TMP) < 0) {
			perror(_PATH_TMP);
			exit(ERROR_EXIT);
		}
		if (snprintf(q, sizeof q, "%s %s", editor, Filename) >= sizeof(q)) {
			fprintf(stderr, "%s: editor command line too long\n",
			    ProgramName);
			exit(ERROR_EXIT);
		}
		execlp(_PATH_BSHELL, _PATH_BSHELL, "-c", q, (char *)NULL);
		perror(editor);
		exit(ERROR_EXIT);
		/*NOTREACHED*/
	default:
		/* parent */
		break;
a386 29
	/* parent */
	for (;;) {
		xpid = waitpid(pid, &waiter, WUNTRACED);
		if (xpid == -1) {
			if (errno != EINTR)
				fprintf(stderr, "%s: waitpid() failed waiting for PID %ld from \"%s\": %s\n",
					ProgramName, (long)pid, editor, strerror(errno));
		} else if (xpid != pid) {
			fprintf(stderr, "%s: wrong PID (%ld != %ld) from \"%s\"\n",
				ProgramName, (long)xpid, (long)pid, editor);
			goto fatal;
		} else if (WIFSTOPPED(waiter)) {
			kill(getpid(), WSTOPSIG(waiter));
		} else if (WIFEXITED(waiter) && WEXITSTATUS(waiter)) {
			fprintf(stderr, "%s: \"%s\" exited with status %d\n",
				ProgramName, editor, WEXITSTATUS(waiter));
			goto fatal;
		} else if (WIFSIGNALED(waiter)) {
			fprintf(stderr,
				"%s: \"%s\" killed; signal %d (%score dumped)\n",
				ProgramName, editor, WTERMSIG(waiter),
				WCOREDUMP(waiter) ?"" :"no ");
			goto fatal;
		} else
			break;
	}
	(void)signal(SIGHUP, SIG_DFL);
	(void)signal(SIGINT, SIG_DFL);
	(void)signal(SIGQUIT, SIG_DFL);
d589 57
@


1.50
log
@crontab -e /tmp//crontab.ynUyD24939 versus /tmp/crontab.ynUyD24939.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.49 2005/11/29 20:43:31 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.49 2005/11/29 20:43:31 millert Exp $";
d65 1
a65 1
	fprintf(stderr, "\t%s [-u user] [ -e | -l | -r ]\n", ProgramName);
@


1.49
log
@crontab.c uses the rcsid in the crontab head comment so don't protect
it from lint.  Found by cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.48 2005/01/30 21:00:31 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.48 2005/01/30 21:00:31 millert Exp $";
d322 1
a322 1
	if (snprintf(Filename, sizeof Filename, "%s/crontab.XXXXXXXXXX",
@


1.48
log
@Detect editors that move the edited file out from underneath us and warn.
Based on an idea from Han Boetes.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.47 2004/11/04 18:44:59 millert Exp $	*/
d24 1
a24 3
#if !defined(lint) && !defined(LINT)
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.47 2004/11/04 18:44:59 millert Exp $";
#endif
@


1.47
log
@Treat EOF at prompt the same as 'n' instead of looping forever.
Noticed by mepch@@.  OK pedro@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.46 2004/09/16 18:34:05 deraadt Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.46 2004/09/16 18:34:05 deraadt Exp $";
d287 1
a287 1
	struct stat statbuf;
d451 5
@


1.46
log
@ftruncate() with ftello() instead of ftell(); ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.45 2004/06/22 03:15:33 avsm Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.45 2004/06/22 03:15:33 avsm Exp $";
d464 4
a467 1
			(void) fgets(q, sizeof q, stdin);
d514 2
a515 2
	if (snprintf(TempFilename, sizeof TempFilename, "%s/tmp.XXXXXXXXX", SPOOL_DIR) >=
		sizeof(TempFilename)) {
@


1.45
log
@use snprintf(3) instead of home-grown glue_strings() function
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.44 2004/06/17 22:11:55 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.44 2004/06/17 22:11:55 millert Exp $";
d545 1
a545 1
	ftruncate(fileno(tmp), ftell(tmp));	/* XXX redundant with "w+"? */
@


1.44
log
@UUpdate ISC copyright year to 2004
Remove unused macros Skip_Line and MkLower
Remove trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.43 2003/07/30 20:20:01 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.43 2003/07/30 20:20:01 millert Exp $";
d237 1
a237 1
	if (!glue_strings(n, sizeof n, SPOOL_DIR, User, '/')) {
d262 1
a262 1
	if (!glue_strings(n, sizeof n, SPOOL_DIR, User, '/')) {
d294 1
a294 1
	if (!glue_strings(n, sizeof n, SPOOL_DIR, User, '/')) {
d324 2
a325 2
	if (!glue_strings(Filename, sizeof Filename, _PATH_TMP,
	    "crontab.XXXXXXXXXX", '/')) {
d403 1
a403 1
		if (!glue_strings(q, sizeof q, editor, Filename, ' ')) {
d511 2
a512 2
	if (!glue_strings(TempFilename, sizeof TempFilename, SPOOL_DIR,
	    "tmp.XXXXXXXXXX", '/')) {
d614 1
a614 1
	if (!glue_strings(n, sizeof n, SPOOL_DIR, User, '/')) {
@


1.43
log
@Use (char *)NULL instead of (char *)0 in execl and execle; Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.42 2003/03/15 00:39:01 millert Exp $	*/
d8 1
d15 7
a21 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
 * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.42 2003/03/15 00:39:01 millert Exp $";
@


1.42
log
@Use strlcpy() instead of pre-checking the src len and using strcpy()
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.41 2003/03/09 18:11:15 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.41 2003/03/09 18:11:15 millert Exp $";
d408 1
a408 1
		execlp(_PATH_BSHELL, _PATH_BSHELL, "-c", q, (char *)0);
@


1.41
log
@Catch lines w/o EOF.  Previously they were silently ignored.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.40 2003/02/20 20:38:08 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.40 2003/02/20 20:38:08 millert Exp $";
d134 2
a135 2
	strcpy(User, pw->pw_name);
	strcpy(RealUser, User);
d157 1
a157 1
			if (strlen(optarg) >= sizeof User)
a158 1
			(void) strcpy(User, optarg);
d188 2
a189 1
			if (strlen(argv[optind]) >= sizeof Filename)
a190 1
			(void) strcpy (Filename, argv[optind]);
@


1.40
log
@Sync with ISC cron-current + my at(1) integration.
The at(1) code is now more tightly integrated into the cron codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.39 2003/02/20 19:12:16 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.39 2003/02/20 19:12:16 millert Exp $";
d569 5
@


1.39
log
@If there is no cron.allow or cron.deny file, only the superuser may run
the crontab command; for POSIX compliance.  Create an empty cron.deny
file to allow any user to run crontab:
    install -c -o root -g crontab -m 660 /dev/null /var/cron/cron.deny
@
text
@d1 2
a2 1
/*	$OpenBSD: crontab.c,v 1.38 2003/02/18 02:25:39 millert Exp $	*/
d25 1
a25 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.38 2003/02/18 02:25:39 millert Exp $";
a35 2
#include <sys/socket.h>
#include <sys/un.h>
a57 1
			poke_daemon(void),
d89 1
a89 1
	if (!allowed(RealUser, ALLOW_FILE, DENY_FILE)) {
d274 1
a274 1
	poke_daemon();
d625 1
a625 1
	poke_daemon();
a635 30
}

static void
poke_daemon() {
	int sock, flags;
	unsigned char poke;
	struct sockaddr_un sun;

	if (utime(SPOOL_DIR, NULL) < OK) {
		fprintf(stderr, "crontab: can't update mtime on spooldir\n");
		perror(SPOOL_DIR);
		return;
	}

	/* Failure to poke the daemon socket is not a fatal error. */
	(void) signal(SIGPIPE, SIG_IGN);
	if (glue_strings(sun.sun_path, sizeof sun.sun_path, SPOOL_DIR,
	    CRONSOCK, '/')) {
		sun.sun_family = AF_UNIX;
		sun.sun_len = SUN_LEN(&sun);
		if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
		    connect(sock, (struct sockaddr *)&sun, sizeof(sun)) == 0) {
			poke = RELOAD_CRON;
			write(sock, &poke, 1);
			close(sock);
		} else
			fprintf(stderr, "Warning, cron does not appear to be running.\n");

	}
	(void) signal(SIGPIPE, SIG_DFL);
@


1.38
log
@Use the SUN_LEN macro to set sun_len correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.37 2003/02/17 18:40:11 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.37 2003/02/17 18:40:11 millert Exp $";
d91 1
a91 1
	if (!allowed(User)) {
@


1.37
log
@Add a -n flag and version string; from vixie
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.36 2002/08/10 20:28:51 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.36 2002/08/10 20:28:51 millert Exp $";
d657 1
a657 1
		sun.sun_len = strlen(sun.sun_path);
@


1.36
log
@Just zero out pw_passwd in the pw_dup()'d copy.  There's no need
to do this elsewhere and my previous commit in this area caused
problems on systems with an /etc/crontab file.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.35 2002/08/07 23:22:41 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.35 2002/08/07 23:22:41 millert Exp $";
d115 2
a116 1
		exit(1);
d118 1
a118 1
	exit(0);
d540 1
a540 1
	fprintf(tmp, "# (Cron version -- %s)\n", rcsid);
@


1.35
log
@paranoia: zero out pw_passwd since we don't need it
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.34 2002/07/15 19:13:29 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.34 2002/07/15 19:13:29 millert Exp $";
a130 1
	bzero(pw->pw_passwd, strlen(pw->pw_passwd));
a157 1
			bzero(pw->pw_passwd, strlen(pw->pw_passwd));
@


1.34
log
@Move atrun(8) functionality into cron(8) proper.  This fixes the
long-standing annoyance that atrun's granularity is 10 minutes.
Most at jobs run with a 1 minute granularity.  Jobs submitted via
"at now" or "batch" will run immediately.  Includes a rewritten
cron(8) man page.  at(1) will be integrated more closely into
cron at a future date.

Upgrading notes:
    the atrun job in root's crontab should be removed.
    the /var/at/spool directory is no longer used
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.33 2002/07/11 20:17:04 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.33 2002/07/11 20:17:04 millert Exp $";
d131 1
d159 1
@


1.33
log
@No need to compare sizes of new/old crontab file now that we
stash the st_mtimespec of the original and use that to compare.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.32 2002/07/09 18:58:25 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.32 2002/07/09 18:58:25 millert Exp $";
d642 1
a657 2
		    (flags = fcntl(sock, F_GETFL)) >= 0 &&
		    fcntl(sock, F_SETFL, flags | O_NONBLOCK) >= 0 &&
d659 2
a660 1
			write(sock, "!", 1);
d662 3
a664 1
		}
@


1.32
log
@o Rename clean_turds() in crontab.c to die() and just _exit(ERROR_EXIT)
  instead of resetting the signal handler to SIG_DFL and redelivering.

o Use kill(2) instead of raise(3) (which is just a wrapper)
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.31 2002/07/08 18:11:02 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.31 2002/07/08 18:11:02 millert Exp $";
a291 1
	off_t size;
a316 1
	size = statbuf.st_size;
d452 1
a452 2
	if (timespeccmp(&mtimespec, &statbuf.st_mtimespec, -) == 0 &&
	    size == statbuf.st_size) {   
@


1.31
log
@Merge in some changes from Paul Vixie's tree; most are cosmetic
o ANSI function headers
o return (foo) not return foo
o add -oi to sendmail flags
o update email address in man pages
o make some strings const
o completely remove globbing cruft from popen.c
o whitespace changes
o add DOW_STAR to flags for "monthly", "weekly", and "daily" cron entries
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.30 2002/05/09 22:14:37 millert Exp $	*/
d24 1
a24 1
static char const rcsid[] = "$OpenBSD: crontab.c,v 1.30 2002/05/09 22:14:37 millert Exp $";
d61 2
a62 1
			parse_args(int c, char *v[]);
a63 1
static	void		clean_turds(int);
d412 1
a412 1
		execlp(_PATH_BSHELL, _PATH_BSHELL, "-c", q, (char *)NULL);
d433 1
a433 1
			raise(WSTOPSIG(waiter));
d532 3
a534 3
	(void) signal(SIGHUP, clean_turds);
	(void) signal(SIGINT, clean_turds);
	(void) signal(SIGQUIT, clean_turds);
d671 1
a671 5
clean_turds(signo)
	int signo;
{
	int save_errno = errno;

d674 1
a674 5
	if (signo) {
		(void) signal(signo, SIG_DFL);
		(void) raise(signo);
	}
	errno = save_errno;
@


1.30
log
@nuke unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.29 2002/05/09 21:22:01 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: crontab.c,v 1.29 2002/05/09 21:22:01 millert Exp $";
d79 1
a79 1
	int	exitstatus;
a231 1

d346 2
a347 4
	for (x = 0; x < NHEADER_LINES; x++) {
		ch = get_char(f);
		if (EOF == ch)
			break;
d355 1
a355 1
		if (EOF == ch)
d470 1
a470 1
			switch (islower(q[0]) ? q[0] : tolower(q[0])) {
d472 1
d475 1
a496 1

@


1.29
log
@crontab is no longer setuid root, it is now setgid crontab.
These changes were modelled after the Owl version of vixie-cron,
but developed independently.

Our crontab used to send cron SIGUSR1 to tell cron to reread the
spool dir.  Now that crontab is not setuid root this doesn't work.
Instead, crontab pokes cron via a Unix domain socket located in the
tabs dir.

Please note, after these changes, the owner on user crontab files
will have to be changed manually from root to the uid of the
corresponding user for crontab to be usable.  cron itself will accept
tab files owned by either root or the user.
Also, any /var/cron/{allow,deny} files must be readable by group crontab.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.28 2002/05/08 22:57:58 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: crontab.c,v 1.28 2002/05/08 22:57:58 millert Exp $";
a647 1
	FILE *fp;
@


1.28
log
@o Use proper #defines; It is HAVE_*, not HAS_*
o #ifdef out the -x flag getopt() stanza if not DEBUGGING
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.27 2002/02/16 21:28:01 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: crontab.c,v 1.27 2002/02/16 21:28:01 millert Exp $";
d35 2
a89 1
	set_cron_uid();
d205 1
a205 1
			/* relinquish the setuid status of the binary during
d213 2
a214 2
			if (swap_uids() < OK) {
				perror("swapping uids");
d221 2
a222 2
			if (swap_uids_back() < OK) {
				perror("swapping uids back");
a337 11
#ifdef HAVE_FCHOWN
	if (fchown(t, MY_UID(pw), MY_GID(pw)) < 0) {
		perror("fchown");
		goto fatal;
	}
#else
	if (chown(Filename, MY_UID(pw), MY_GID(pw)) < 0) {
		perror("chown");
		goto fatal;
	}
#endif
a405 4
		if (setuid(MY_UID(pw)) < 0) {
			perror("setuid(getuid())");
			exit(ERROR_EXIT);
		}
a512 1
	struct stat sb;
a593 3
	if (fstat(fileno(tmp), &sb))
		sb.st_gid = -1;

d595 1
a595 1
	if (fchown(fileno(tmp), ROOT_UID, sb.st_gid) < OK) {
d602 1
a602 1
	if (chown(TempFilename, ROOT_UID, sb.st_gid) < OK) {
a609 16
#ifdef HAVE_FCHMOD
	if (fchmod(fileno(tmp), 0600) < OK) {
		perror("fchmod");
		fclose(tmp);
		error = -2;
		goto done;
	}
#else
	if (chmod(TempFilename, 0600) < OK) {
		perror("chmod");
		fclose(tmp);
		error = -2;
		goto done;
	}
#endif

d646 2
a647 2
	char pidfile[MAX_FNAME];
	PID_T pid;
d655 14
a668 4
	if (glue_strings(pidfile, sizeof pidfile, PIDDIR, PIDFILE, '/')) {
		if ((fp = fopen(pidfile, "r")) &&
		    fscanf(fp, "%d", &pid) == 1)
			kill(pid, SIGUSR1);
d670 1
@


1.27
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.26 2001/12/20 23:27:47 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: crontab.c,v 1.26 2001/12/20 23:27:47 millert Exp $";
d140 1
d145 1
d337 1
a337 1
#ifdef HAS_FCHOWN
d612 1
a612 1
#ifdef HAS_FCHOWN
d628 1
a628 1
#ifdef HAS_FCHMOD
@


1.26
log
@Cause crontab to send SIGUSR1 when a user's crontab file has changed.
In cron, this interrupts the sleep() in cron_sleep() and causes cron
to check to see what signal woke it up and act appropriately.
This makes crontab changes take effect more or immediately.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.25 2001/12/07 22:33:09 deraadt Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: crontab.c,v 1.25 2001/12/07 22:33:09 deraadt Exp $";
d61 1
a61 1
static	void		clean_turds __P((int));
@


1.25
log
@do not call abort(), it is tasteless
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.24 2001/11/17 19:48:40 deraadt Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: crontab.c,v 1.24 2001/11/17 19:48:40 deraadt Exp $";
d678 4
d686 5
@


1.24
log
@save errno in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.23 2001/10/24 17:28:16 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: crontab.c,v 1.23 2001/10/24 17:28:16 millert Exp $";
d114 1
a114 1
		abort();
@


1.23
log
@When becoming a daemon, dup stdin, stdout, and stderr to /dev/null
Change an unsafe vfork() to fork()
Fix dup2() usage--must check for oldd == newd case and no need to close oldd
Fixes annoying messages from sendmail about stdout being closed.
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.22 2001/08/19 18:30:38 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: crontab.c,v 1.22 2001/08/19 18:30:38 millert Exp $";
d689 2
d697 1
@


1.22
log
@Better file change detection:
o when copying to temp file set utimes on temp file equal to original
o use st_mtimespec instead of st_mtime for better granularity
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.21 2001/08/11 20:47:14 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: crontab.c,v 1.21 2001/08/11 20:47:14 millert Exp $";
d306 2
a307 2
		if (!(f = fopen("/dev/null", "r"))) {
			perror("/dev/null");
@


1.21
log
@If waitpid() returns -1, check for EINTR
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.20 2001/07/09 07:05:00 deraadt Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: crontab.c,v 1.20 2001/07/09 07:05:00 deraadt Exp $";
d288 2
a289 1
	time_t mtime;
d312 9
d380 1
a389 6
	if (fstat(t, &statbuf) < 0) {
		perror("fstat");
		goto fatal;
	}
	mtime = statbuf.st_mtime;
	size = statbuf.st_size;
d469 2
a470 1
	if (mtime == statbuf.st_mtime && size == statbuf.st_size) {
@


1.20
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: crontab.c,v 1.19 2001/02/18 19:48:32 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: crontab.c,v 1.19 2001/02/18 19:48:32 millert Exp $";
d435 3
a437 2
			fprintf(stderr, "%s: waitpid() failed waiting for PID %ld from \"%s\": %s\n",
				ProgramName, (long)pid, editor, strerror(errno));
@


1.19
log
@Update to ISC cron 4.0b1 + our patches.  This is now under a BSD license.
I also fixed the signal handlers while I was at it.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD: crontab.c,v 1.4 2000/01/02 20:53:40 vixie Exp $";
d422 1
a422 1
		execlp(_PATH_BSHELL, _PATH_BSHELL, "-c", q, NULL);
@


1.18
log
@snprintf sprinkles; solar@@false.com & I
@
text
@d1 1
d4 4
d9 3
a11 8
 * Distribute freely, except: don't remove my name from the source or
 * documentation (don't take credit for my work), mark your changes (don't
 * get me blamed for your possible bugs), don't alter or remove this
 * notice.  May be sold if buildable source is provided to buyer.  No
 * warrantee of any kind, express or implied, is included with this
 * software; use at your own risk, responsibility for damages (if any) to
 * anyone resulting from the use of this software rests entirely with the
 * user.
d13 8
a20 3
 * Send bug reports, bug fixes, enhancements, requests, flames, etc., and
 * I'll try to keep a version up to date.  I can be reached as follows:
 * Paul Vixie          <paul@@vix.com>          uunet!decwrl!vixie!paul
d24 1
a24 1
static char rcsid[] = "$Id: crontab.c,v 1.17 2000/08/21 21:04:22 deraadt Exp $";
a31 1

a33 1

a34 15
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/file.h>
#include <sys/stat.h>
#ifdef USE_UTIMES
# include <sys/time.h>
#else
# include <time.h>
# include <utime.h>
#endif
#if defined(POSIX)
# include <locale.h>
#endif

a37 1

d42 3
a46 1

d49 1
a49 1
static	char		Filename[MAX_FNAME], *TempFilename;
d54 7
a60 7
static	void		list_cmd __P((void)),
			delete_cmd __P((void)),
			edit_cmd __P((void)),
			poke_daemon __P((void)),
			check_error __P((char *)),
			parse_args __P((int c, char *v[]));
static	int		replace_cmd __P((void));
a62 1

d64 1
a64 3
usage(msg)
	char *msg;
{
a74 1

d76 1
a76 4
main(argc, argv)
	int	argc;
	char	*argv[];
{
a81 1
#if defined(POSIX)
a82 1
#endif
d100 15
a114 9
	case opt_list:		list_cmd();
				break;
	case opt_delete:	delete_cmd();
				break;
	case opt_edit:		edit_cmd();
				break;
	case opt_replace:	if (replace_cmd() < 0)
					exitstatus = ERROR_EXIT;
				break;
a118 6
	
#if DEBUGGING
char *getoptarg = "u:lerx:";
#else
char *getoptarg = "u:ler";
#endif
d121 2
a122 5
parse_args(argc, argv)
	int	argc;
	char	*argv[];
{
	int		argch;
d130 5
a134 2
	(void) strncpy(User, pw->pw_name, (sizeof User)-1);
	User[(sizeof User)-1] = '\0';
d138 1
a138 2

	while (-1 != (argch = getopt(argc, argv, getoptarg))) {
a139 1
#if DEBUGGING
a142 1
			usage("unrecognized option");
a143 1
#endif
d145 1
a145 2
			if (getuid() != ROOT_UID)
			{
d150 1
a150 2
			if (!(pw = getpwnam(optarg)))
			{
d155 3
a157 2
			(void) strncpy(User, pw->pw_name, (sizeof User)-1);
			User[(sizeof User)-1] = '\0';
d182 1
a182 1
		if (argv[optind] != NULL) {
a183 1
		}
d187 4
a190 4
			(void) strncpy (Filename, argv[optind], (sizeof Filename)-1);
			Filename[(sizeof Filename)-1] = '\0';

		} else {
a191 1
		}
d199 1
a199 1
		if (!strcmp(Filename, "-")) {
d201 1
a201 1
		} else {
d231 4
a234 4
list_cmd() {
	char	n[MAX_FNAME];
	FILE	*f;
	int	ch;
d237 4
a240 1
	(void) snprintf(n, sizeof n, CRON_TAB(User));
a256 1

d258 2
a259 2
delete_cmd() {
	char	n[MAX_FNAME];
d262 5
a266 2
	(void) snprintf(n, sizeof n, CRON_TAB(User));
	if (unlink(n)) {
a275 1

d277 1
a277 3
check_error(msg)
	char	*msg;
{
a281 1

d283 9
a291 9
edit_cmd() {
	char		n[MAX_FNAME], q[MAX_TEMPSTR], *editor;
	FILE		*f;
	int		ch, t, x;
	struct stat	statbuf;
	time_t		mtime;
	off_t		size;
	WAIT_T		waiter;
	PID_T		pid, xpid;
d294 4
a297 1
	(void) snprintf(n, sizeof n, CRON_TAB(User));
d316 6
a321 2
	(void) snprintf(Filename, sizeof Filename, "/tmp/crontab.XXXXXXXXXX");
	if ((t = mkstemp(Filename)) == -1) {
d326 4
a329 1
	if (fchown(t, getuid(), getgid()) < 0) {
d331 2
a332 3
	if (chown(Filename, getuid(), getgid()) < 0) {
#endif
		perror("fchown");
d335 1
d375 2
a376 1
 fatal:		unlink(Filename);
d386 2
a387 3
	if ((!(editor = getenv("VISUAL")))
	 && (!(editor = getenv("EDITOR")))
	    ) {
d405 5
a409 1
		if (setuid(getuid()) < 0) {
d413 2
a414 2
		if (chdir("/tmp") < 0) {
			perror("chdir(\"/tmp\")");
d417 3
a419 3
		if (strlen(editor) + strlen(Filename) + 2 >= sizeof(q)) {
			fprintf(stderr, "%s: editor or filename too long\n",
				ProgramName);
a421 1
		snprintf(q, sizeof q, "%s %s", editor, Filename);
d432 1
a432 1
	while (1) {
d435 2
a436 2
			fprintf(stderr, "%s: waitpid() failed waiting for PID %d from \"%s\": %s\n",
				ProgramName, pid, editor, strerror(errno));
d438 2
a439 2
			fprintf(stderr, "%s: wrong PID (%d != %d) from \"%s\"\n",
				ProgramName, xpid, pid, editor);
d495 1
a495 1
		    ProgramName);
d503 1
a503 1
	
d510 9
a518 8
replace_cmd() {
	char	n[MAX_FNAME], envstr[MAX_ENVSTR];
	FILE	*tmp;
	int	ch, eof, fd;
	int	error = 0;
	entry	*e;
	time_t	now = time(NULL);
	char	**envp = env_init();
d524 4
a527 4

	TempFilename = strdup(__CONCAT(SPOOL_DIR,"/tmp.XXXXXXXXXX"));
	if (TempFilename == NULL) {
		fprintf(stderr, "%s: Cannot allocate memory.\n", ProgramName);
a532 2
			fprintf(stderr, "%s: Cannot allocate memory.\n",
			    ProgramName);
d536 1
d558 1
a558 1
	ftruncate(fileno(tmp), ftell(tmp));
d600 3
d604 6
a609 1
	if (fchown(fileno(tmp), ROOT_UID, -1) < OK)
d611 1
a611 3
	if (chown(TempFilename, ROOT_UID, -1) < OK)
#endif
	{
d617 1
d620 6
a625 1
	if (fchmod(fileno(tmp), 0600) < OK)
d627 2
a628 4
	if (chmod(TempFilename, 0600) < OK)
#endif
	{
		perror("chown");
d633 1
d641 6
a646 2
	if (snprintf(n, sizeof n, CRON_TAB(User)) >= sizeof n ||
	    rename(TempFilename, n)) {
d653 1
a653 1
	TempFilename = NULL;
d662 1
a662 1
	if (TempFilename) {
d664 1
a664 1
		free(TempFilename);
a668 1

a670 12
#ifdef USE_UTIMES
	struct timeval tvs[2];
	struct timezone tz;

	(void) gettimeofday(&tvs[0], &tz);
	tvs[1] = tvs[0];
	if (utimes(SPOOL_DIR, tvs) < OK) {
		fprintf(stderr, "crontab: can't update mtime on spooldir\n");
		perror(SPOOL_DIR);
		return;
	}
#else
a675 1
#endif /*USE_UTIMES*/
a677 1

d679 2
a680 2
clean_turds(sig)
	int sig;
d684 3
a686 3
	if (sig) {
		(void) signal(sig, SIG_DFL);
		(void) kill(getpid(), sig);
@


1.17
log
@correct tmp file path; solar@@false.com
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.16 2000/08/21 21:03:25 deraadt Exp $";
d135 1
a135 1
char *getoptarg = "u:lerx:"
d264 1
a264 1
	(void) sprintf(n, CRON_TAB(User));
d287 1
a287 1
	(void) sprintf(n, CRON_TAB(User));
d320 1
a320 1
	(void) sprintf(n, CRON_TAB(User));
d339 1
a339 1
	(void) sprintf(Filename, "/tmp/crontab.XXXXXXXXXX");
d361 1
a361 1
	for (x = 0;  x < NHEADER_LINES;  x++) {
d426 1
a426 1
			perror("chdir(/tmp)");
d429 1
a429 1
		if (strlen(editor) + strlen(Filename) + 2 >= MAX_TEMPSTR) {
d434 1
a434 1
		sprintf(q, "%s %s", editor, Filename);
d643 2
a644 2
	(void) sprintf(n, CRON_TAB(User));
	if (rename(TempFilename, n)) {
@


1.16
log
@swap_uids_back; solar@@false.com
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.15 1999/11/20 20:45:16 millert Exp $";
d537 1
a537 1
	TempFilename = strdup(__CONCAT(SPOOL_DIR,"tmp.XXXXXXXXXX"));
@


1.15
log
@Use mkstemp() for the temp file created in the tabs dir and
clean up the temp file nicely if we are interupted.
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.14 1999/05/29 18:51:12 millert Exp $";
d245 1
a245 1
			if (swap_uids() < OK) {
@


1.14
log
@Check size as well as mtime when deciding whether or not the file
was changed during edit.  Crontab patch from <andrew@@untraceable.net>.
It may be better to simply do a real compare inline.
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.13 1999/05/23 17:19:23 aaron Exp $";
d34 1
d60 1
a60 1
static	char		Filename[MAX_FNAME];
d72 1
d334 5
a414 4
	/* Turn off signals. */
	(void)signal(SIGHUP, SIG_IGN);
	(void)signal(SIGINT, SIG_IGN);
	(void)signal(SIGQUIT, SIG_IGN);
d524 1
a524 1
	char	n[MAX_FNAME], envstr[MAX_ENVSTR], tn[MAX_FNAME];
d526 2
a527 1
	int	ch, eof;
d537 13
a549 4
	(void) sprintf(n, "tmp.%d", Pid);
	(void) sprintf(tn, CRON_TAB(n));
	if (!(tmp = fopen(tn, "w+"))) {
		perror(tn);
d553 4
d576 4
a579 3
			ProgramName, tn);
		fclose(tmp);  unlink(tn);
		return (-2);
d608 3
a610 2
		fclose(tmp);  unlink(tn);
		return (-1);
d616 1
a616 1
	if (chown(tn, ROOT_UID, -1) < OK)
d620 3
a622 2
		fclose(tmp);  unlink(tn);
		return (-2);
d628 1
a628 1
	if (chmod(tn, 0600) < OK)
d632 3
a634 2
		fclose(tmp);  unlink(tn);
		return (-2);
d639 2
a640 2
		unlink(tn);
		return (-2);
d644 1
a644 1
	if (rename(tn, n)) {
d646 1
a646 1
			ProgramName, tn, n);
d648 2
a649 2
		unlink(tn);
		return (-2);
d651 1
d656 9
a664 1
	return (0);
d688 13
@


1.13
log
@getopt(3) returns -1, not EOF
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.12 1998/07/12 08:23:47 deraadt Exp $";
d313 1
d392 1
d473 1
a473 1
	if (mtime == statbuf.st_mtime) {
@


1.12
log
@disable debugging in crontab
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.11 1997/04/12 17:50:17 millert Exp $";
d157 1
a157 1
	while (EOF != (argch = getopt(argc, argv, getoptarg))) {
@


1.11
log
@waitpid() can return -1 -- give a useful error message if it does.
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.10 1997/04/12 14:51:22 deraadt Exp $";
d132 5
d156 2
a157 1
	while (EOF != (argch = getopt(argc, argv, "u:lerx:"))) {
d159 1
d163 1
d165 1
@


1.10
log
@ign some signals for editor
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.9 1997/04/12 09:39:58 deraadt Exp $";
d433 4
a436 1
		if (xpid != pid) {
@


1.9
log
@support SIGSTOP in editor, I cannot believe this has always been busted!
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.8 1996/12/25 19:08:09 mickey Exp $";
d397 4
d452 3
@


1.8
log
@no compile test after last change: no need for that umask too, i guess
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.7 1996/12/25 01:56:14 deraadt Exp $";
d427 20
a446 17
	xpid = wait(&waiter);
	if (xpid != pid) {
		fprintf(stderr, "%s: wrong PID (%d != %d) from \"%s\"\n",
			ProgramName, xpid, pid, editor);
		goto fatal;
	}
	if (WIFEXITED(waiter) && WEXITSTATUS(waiter)) {
		fprintf(stderr, "%s: \"%s\" exited with status %d\n",
			ProgramName, editor, WEXITSTATUS(waiter));
		goto fatal;
	}
	if (WIFSIGNALED(waiter)) {
		fprintf(stderr,
			"%s: \"%s\" killed; signal %d (%score dumped)\n",
			ProgramName, editor, WTERMSIG(waiter),
			WCOREDUMP(waiter) ?"" :"no ");
		goto fatal;
@


1.7
log
@do not need umask for mkstemp
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.6 1996/11/01 23:27:30 millert Exp $";
a324 1
		(void) umask(um);
@


1.6
log
@Check malloc/strdup ret val and deal.
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.5 1996/10/31 03:10:55 millert Exp $";
a305 1
	mode_t		um;
a321 1
	um = umask(077);
a327 1
	(void) umask(um);
@


1.5
log
@Proper strncpy() usage.
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.4 1996/09/16 17:19:54 millert Exp $";
d324 1
a324 1
	(void) sprintf(Filename, "/tmp/crontab.XXXXXXXX");
d507 5
@


1.4
log
@umask != file mode
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.3 1996/09/15 10:02:34 deraadt Exp $";
d146 2
a147 1
	strncpy(User, pw->pw_name, sizeof User);
d170 2
a171 1
			(void) strncpy(User, optarg, sizeof User);
d202 3
a204 1
			(void) strncpy (Filename, argv[optind], sizeof Filename);
@


1.3
log
@use mkstemp; mentioned by sirsyko@@ishiboo.com
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.2 1996/08/07 06:18:09 deraadt Exp $";
d319 1
a319 1
	um = umask(0600);
@


1.2
log
@buf oflow, nice error message; from freebsd
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.1.1.1 1995/10/18 08:47:30 deraadt Exp $";
d302 1
d319 3
a321 2
	(void) sprintf(Filename, "/tmp/crontab.%d", Pid);
	if (-1 == (t = open(Filename, O_CREAT|O_EXCL|O_RDWR, 0600))) {
d323 1
d326 1
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: crontab.c,v 1.2 1994/03/30 01:46:45 jtc Exp $";
d146 1
a146 1
	strcpy(User, pw->pw_name);
d169 1
a169 1
			(void) strcpy(User, optarg);
d200 1
a200 1
			(void) strcpy (Filename, argv[optind]);
d476 2
a477 1
		fprintf(stderr, "%s: panic: bad switch() in replace_cmd()\n");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
