head	1.69;
access;
symbols
	OPENBSD_6_1_BASE:1.69
	OPENBSD_6_0:1.68.0.2
	OPENBSD_6_0_BASE:1.68
	OPENBSD_5_9:1.65.0.2
	OPENBSD_5_9_BASE:1.65
	OPENBSD_5_8:1.63.0.6
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.62.0.6
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.62.0.4
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.59.0.16
	OPENBSD_5_4_BASE:1.59
	OPENBSD_5_3:1.59.0.14
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.59.0.12
	OPENBSD_5_2_BASE:1.59
	OPENBSD_5_1_BASE:1.59
	OPENBSD_5_1:1.59.0.10
	OPENBSD_5_0:1.59.0.8
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.59.0.6
	OPENBSD_4_9_BASE:1.59
	OPENBSD_4_8:1.59.0.4
	OPENBSD_4_8_BASE:1.59
	OPENBSD_4_7:1.59.0.2
	OPENBSD_4_7_BASE:1.59
	OPENBSD_4_6:1.58.0.8
	OPENBSD_4_6_BASE:1.58
	OPENBSD_4_5:1.58.0.4
	OPENBSD_4_5_BASE:1.58
	OPENBSD_4_4:1.58.0.2
	OPENBSD_4_4_BASE:1.58
	OPENBSD_4_3:1.57.0.2
	OPENBSD_4_3_BASE:1.57
	OPENBSD_4_2:1.56.0.4
	OPENBSD_4_2_BASE:1.56
	OPENBSD_4_1:1.56.0.2
	OPENBSD_4_1_BASE:1.56
	OPENBSD_4_0:1.53.0.2
	OPENBSD_4_0_BASE:1.53
	OPENBSD_3_9:1.52.0.10
	OPENBSD_3_9_BASE:1.52
	OPENBSD_3_8:1.52.0.8
	OPENBSD_3_8_BASE:1.52
	OPENBSD_3_7:1.52.0.6
	OPENBSD_3_7_BASE:1.52
	OPENBSD_3_6:1.52.0.4
	OPENBSD_3_6_BASE:1.52
	OPENBSD_3_5:1.52.0.2
	OPENBSD_3_5_BASE:1.52
	OPENBSD_3_4:1.51.0.2
	OPENBSD_3_4_BASE:1.51
	OPENBSD_3_3:1.47.0.4
	OPENBSD_3_3_BASE:1.47
	OPENBSD_3_2:1.47.0.2
	OPENBSD_3_2_BASE:1.47
	OPENBSD_3_1:1.43.0.2
	OPENBSD_3_1_BASE:1.43
	OPENBSD_3_0:1.39.0.2
	OPENBSD_3_0_BASE:1.39
	OPENBSD_2_9_BASE:1.38
	OPENBSD_2_9:1.38.0.6
	OPENBSD_2_8:1.38.0.4
	OPENBSD_2_8_BASE:1.38
	OPENBSD_2_7:1.38.0.2
	OPENBSD_2_7_BASE:1.38
	OPENBSD_2_6:1.37.0.4
	OPENBSD_2_6_BASE:1.37
	OPENBSD_2_5:1.37.0.2
	OPENBSD_2_5_BASE:1.37
	OPENBSD_2_4:1.36.0.2
	OPENBSD_2_4_BASE:1.36
	OPENBSD_2_3:1.34.0.2
	OPENBSD_2_3_BASE:1.34
	OPENBSD_2_2:1.29.0.2
	OPENBSD_2_2_BASE:1.29
	OPENBSD_2_1:1.25.0.2
	OPENBSD_2_1_BASE:1.25
	OPENBSD_2_0:1.12.0.2
	OPENBSD_2_0_BASE:1.12
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.69
date	2017.02.17.16.46.17;	author ajacoutot;	state Exp;
branches;
next	1.68;
commitid	jSwzSWIrXbAnTtM2;

1.68
date	2016.07.08.19.32.26;	author millert;	state Exp;
branches;
next	1.67;
commitid	GTG2XZhGjNgxusgr;

1.67
date	2016.07.05.16.41.40;	author jca;	state Exp;
branches;
next	1.66;
commitid	OXObvIEwrSg4aVOT;

1.66
date	2016.03.21.00.49.36;	author guenther;	state Exp;
branches;
next	1.65;
commitid	MSxcUg12B9iLaLLL;

1.65
date	2015.12.12.20.04.23;	author mmcc;	state Exp;
branches;
next	1.64;
commitid	qUunq6kWElREuvSB;

1.64
date	2015.08.20.22.39.30;	author deraadt;	state Exp;
branches;
next	1.63;
commitid	z3HrihslRYb4HqW9;

1.63
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	Uu5nFG3wCl0LACBb;

1.62
date	2014.01.21.23.05.09;	author jsg;	state Exp;
branches;
next	1.61;

1.61
date	2013.12.20.00.31.12;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2013.11.24.01.06.19;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2009.10.27.23.59.57;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2008.08.02.04.13.37;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2007.10.09.14.40.15;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2007.02.18.23.27.06;	author jmc;	state Exp;
branches;
next	1.55;

1.55
date	2007.01.02.20.12.01;	author otto;	state Exp;
branches;
next	1.54;

1.54
date	2007.01.02.20.10.48;	author otto;	state Exp;
branches;
next	1.53;

1.53
date	2006.04.02.01.29.51;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2004.02.20.11.57.17;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2003.08.19.22.10.08;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2003.07.15.06.10.45;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.25.21.45.47;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2003.06.02.04.00.17;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2002.09.06.19.46.53;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2002.07.20.12.14.51;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.29.07.32.15;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2002.05.30.19.09.06;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.16.21.28.11;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.29.00.50.29;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.05.00.08.34;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2001.07.27.20.34.36;	author pvalchev;	state Exp;
branches;
next	1.38;

1.38
date	2000.04.11.11.52.55;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	99.02.16.05.54.08;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	98.08.15.17.24.17;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	98.08.15.17.23.27;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	98.03.23.06.18.38;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	98.03.20.03.16.15;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	98.02.07.18.51.48;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	98.02.07.02.40.38;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	98.02.07.02.34.19;	author downsj;	state Exp;
branches;
next	1.29;

1.29
date	97.06.18.23.50.12;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	97.06.14.07.12.14;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	97.06.12.19.55.41;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	97.06.11.23.16.33;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	97.05.06.18.41.11;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.04.02.08.24.48;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	97.03.29.06.13.21;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.03.26.05.23.57;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.03.25.23.08.57;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.02.01.00.26.04;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.01.30.18.26.55;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.01.30.07.47.29;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.01.30.06.03.08;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.01.30.02.01.54;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.01.30.02.00.26;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.01.22.08.54.14;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.12.21.05.52.31;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.08.28.23.10.06;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.07.25.21.42.45;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.07.05.21.14.29;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.07.01.00.49.56;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.06.10.05.48.51;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.08.08.24.51;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.24.11.43.36;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.14.18.53.38;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.05.12.37.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.24.21.44.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.10.58.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.31;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.69
log
@ypbind(8) is not started automatically at boot time by /etc/rc if domainname
is set and the directory var/yp/binding exists.

ok deraadt@@
@
text
@/*	$OpenBSD: ypbind.c,v 1.68 2016/07/08 19:32:26 millert Exp $ */

/*
 * Copyright (c) 1992, 1993, 1996, 1997, 1998 Theo de Raadt <deraadt@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <sys/fcntl.h>
#include <sys/uio.h>
#include <sys/syslog.h>
#include <net/if.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <ctype.h>
#include <netdb.h>
#include <string.h>
#include <dirent.h>
#include <rpc/rpc.h>
#include <rpc/xdr.h>
#include <arpa/inet.h>
#include <rpc/pmap_clnt.h>
#include <rpc/pmap_prot.h>
#include <rpc/pmap_rmt.h>
#include <unistd.h>
#include <err.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>
#include <ifaddrs.h>
#include <poll.h>

#define SERVERSDIR	"/etc/yp"
#define BINDINGDIR	"/var/yp/binding"
#define YPBINDLOCK	"/var/run/ypbind.lock"

struct _dom_binding {
	struct _dom_binding *dom_pnext;
	char dom_domain[YPMAXDOMAIN + 1];
	struct sockaddr_in dom_server_addr;
	unsigned short int dom_server_port;
	int dom_socket;
	CLIENT *dom_client;
	long dom_vers;
	time_t dom_check_t;
	time_t dom_ask_t;
	int dom_lockfd;
	int dom_alive;
	u_int32_t dom_xid;
	char dom_servlist[PATH_MAX];
	FILE *dom_servlistfp;
};

void rpc_received(char *dom, struct sockaddr_in *raddrp, int force);
void checkwork(void);
enum clnt_stat handle_replies(void);
enum clnt_stat handle_ping(void);
int broadcast(struct _dom_binding *ypdb, char *, int);
int direct(struct _dom_binding *ypdb, char *, int);
int ping(struct _dom_binding *ypdb);
int pings(struct _dom_binding *ypdb);

char *domain;

struct _dom_binding *ypbindlist;
int check;

#define YPSET_NO	0
#define YPSET_LOCAL	1
#define YPSET_ALL	2
int ypsetmode = YPSET_NO;
int insecure = 0;

int rpcsock, pingsock;
struct rmtcallargs rmtca;
struct rmtcallres rmtcr;
bool_t rmtcr_outval;
u_long rmtcr_port;
SVCXPRT *udptransp, *tcptransp;
SVCXPRT *ludptransp, *ltcptransp;

struct _dom_binding *xid2ypdb(u_int32_t xid);
u_int32_t unique_xid(struct _dom_binding *ypdb);

/*
 * We name the local RPC functions ypbindproc_XXX_2x() instead
 * of ypbindproc_XXX_2() because we need to pass an additional
 * parameter. ypbindproc_setdom_2x() does a security check, and
 * hence needs the CLIENT *
 *
 * We are faced with either making ypbindprog_2() do the security
 * check before calling ypbindproc_setdom_2().. or we can simply
 * declare sun's interface insufficient and roll our own.
 */

/*ARGSUSED*/
static void *
ypbindproc_null_2x(SVCXPRT *transp, void *argp, CLIENT *clnt)
{
	static char res;

	memset(&res, 0, sizeof(res));
	return (void *)&res;
}

/*ARGSUSED*/
static struct ypbind_resp *
ypbindproc_domain_2x(SVCXPRT *transp, domainname *argp, CLIENT *clnt)
{
	static struct ypbind_resp res;
	struct _dom_binding *ypdb;
	char path[PATH_MAX];
	time_t now;
	int count = 0;

	if (strchr((char *)argp, '/'))
		return NULL;

	memset(&res, 0, sizeof(res));
	res.ypbind_status = YPBIND_FAIL_VAL;

	for (ypdb = ypbindlist; ypdb && count < 100; ypdb = ypdb->dom_pnext)
		count++;
	if (count >= 100)
		return NULL;	/* prevent DOS: sorry, you lose */

	for (ypdb = ypbindlist; ypdb; ypdb = ypdb->dom_pnext)
		if (!strcmp(ypdb->dom_domain, *argp))
			break;

	if (ypdb == NULL) {
		ypdb = malloc(sizeof *ypdb);
		if (ypdb == NULL)
			return NULL;
		memset(ypdb, 0, sizeof *ypdb);
		strncpy(ypdb->dom_domain, *argp, sizeof ypdb->dom_domain-1);
		ypdb->dom_domain[sizeof ypdb->dom_domain-1] = '\0';
		ypdb->dom_vers = YPVERS;
		ypdb->dom_alive = 0;
		ypdb->dom_lockfd = -1;
		snprintf(path, sizeof path, "%s/%s.%d", BINDINGDIR,
		    ypdb->dom_domain, (int)ypdb->dom_vers);
		unlink(path);
		snprintf(ypdb->dom_servlist, sizeof ypdb->dom_servlist,
		    "%s/%s", SERVERSDIR, ypdb->dom_domain);
		ypdb->dom_servlistfp = fopen(ypdb->dom_servlist, "r");
		ypdb->dom_xid = unique_xid(ypdb);
		ypdb->dom_pnext = ypbindlist;
		ypbindlist = ypdb;
		check++;
		return NULL;
	}

	if (ypdb->dom_alive == 0)
		return NULL;

#ifdef HEURISTIC
	time(&now);
	if (now < ypdb->dom_ask_t + 5) {
		/*
		 * Hmm. More than 2 requests in 5 seconds have indicated
		 * that my binding is possibly incorrect.
		 * Ok, do an immediate poll of the server.
		 */
		if (ypdb->dom_check_t >= now) {
			/* don't flood it */
			ypdb->dom_check_t = 0;
			check++;
		}
	}
	ypdb->dom_ask_t = now;
#endif

	res.ypbind_status = YPBIND_SUCC_VAL;
	memmove(&res.ypbind_resp_u.ypbind_bindinfo.ypbind_binding_addr,
	    &ypdb->dom_server_addr.sin_addr,
	    sizeof(res.ypbind_resp_u.ypbind_bindinfo.ypbind_binding_addr));
	memmove(&res.ypbind_resp_u.ypbind_bindinfo.ypbind_binding_port,
	    &ypdb->dom_server_port,
	    sizeof(res.ypbind_resp_u.ypbind_bindinfo.ypbind_binding_port));
#ifdef DEBUG
	printf("domain %s at %s/%d\n", ypdb->dom_domain,
	    inet_ntoa(ypdb->dom_server_addr.sin_addr),
	    ntohs(ypdb->dom_server_addr.sin_port));
#endif
	return &res;
}

/*ARGSUSED*/
static bool_t *
ypbindproc_setdom_2x(SVCXPRT *transp, struct ypbind_setdom *argp, CLIENT *clnt)
{
	struct sockaddr_in *fromsin, bindsin;
	static bool_t res = 1;

	fromsin = svc_getcaller(transp);

	switch (ypsetmode) {
	case YPSET_LOCAL:
		if (transp != ludptransp && transp != ltcptransp) {
			syslog(LOG_WARNING, "attempted spoof of ypsetme");
			svcerr_weakauth(transp);
			return NULL;
		}
		if (fromsin->sin_addr.s_addr != htonl(INADDR_LOOPBACK)) {
			svcerr_weakauth(transp);
			return NULL;
		}
		break;
	case YPSET_ALL:
		break;
	case YPSET_NO:
	default:
		svcerr_weakauth(transp);
		return NULL;
	}

	if (ntohs(fromsin->sin_port) >= IPPORT_RESERVED) {
		svcerr_weakauth(transp);
		return NULL;
	}

	if (argp->ypsetdom_vers != YPVERS) {
		svcerr_noprog(transp);
		return NULL;
	}

	memset(&bindsin, 0, sizeof bindsin);
	bindsin.sin_family = AF_INET;
	bindsin.sin_len = sizeof(bindsin);
	memcpy(&bindsin.sin_addr, &argp->ypsetdom_binding.ypbind_binding_addr,
	    sizeof(argp->ypsetdom_binding.ypbind_binding_addr));
	memcpy(&bindsin.sin_port, &argp->ypsetdom_binding.ypbind_binding_port,
	    sizeof(argp->ypsetdom_binding.ypbind_binding_port));
	rpc_received(argp->ypsetdom_domain, &bindsin, 1);

	return &res;
}

static void
ypbindprog_2(struct svc_req *rqstp, SVCXPRT *transp)
{
	union argument {
		domainname ypbindproc_domain_2_arg;
		struct ypbind_setdom ypbindproc_setdom_2_arg;
	} argument;
	struct authunix_parms *creds;
	char *result;
	xdrproc_t xdr_argument, xdr_result;
	char *(*local)(SVCXPRT *, union argument *, struct svc_req *);

	switch (rqstp->rq_proc) {
	case YPBINDPROC_NULL:
		xdr_argument = xdr_void;
		xdr_result = xdr_void;
		local = (char *(*)(SVCXPRT *, union argument *, struct svc_req *))
		    ypbindproc_null_2x;
		break;

	case YPBINDPROC_DOMAIN:
		xdr_argument = xdr_domainname;
		xdr_result = xdr_ypbind_resp;
		local = (char *(*)(SVCXPRT *, union argument *, struct svc_req *))
		    ypbindproc_domain_2x;
		break;

	case YPBINDPROC_SETDOM:
		switch (rqstp->rq_cred.oa_flavor) {
		case AUTH_UNIX:
			creds = (struct authunix_parms *)rqstp->rq_clntcred;
			if (creds->aup_uid != 0) {
				svcerr_auth(transp, AUTH_BADCRED);
				return;
			}
			break;
		default:
			svcerr_auth(transp, AUTH_TOOWEAK);
			return;
		}

		xdr_argument = xdr_ypbind_setdom;
		xdr_result = xdr_void;
		local = (char *(*)(SVCXPRT *, union argument *, struct svc_req *))
		    ypbindproc_setdom_2x;
		break;

	default:
		svcerr_noproc(transp);
		return;
	}
	memset(&argument, 0, sizeof(argument));
	if (!svc_getargs(transp, xdr_argument, (caddr_t)&argument)) {
		svcerr_decode(transp);
		return;
	}
	result = (*local)(transp, &argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, xdr_result, result)) {
		svcerr_systemerr(transp);
	}
	return;
}

static void
usage(void)
{
	fprintf(stderr, "usage: ypbind [-insecure] [-ypset] [-ypsetme]\n");
	exit(1);
}

int
main(int argc, char *argv[])
{
	char path[PATH_MAX];
	struct sockaddr_in sin;
	struct pollfd *pfd = NULL;
	int width = 0, nready, lockfd, lsock;
	socklen_t len;
	int evil = 0, one = 1;
	DIR *dirp;
	struct dirent *dent;

	yp_get_default_domain(&domain);
	if (domain[0] == '\0') {
		fprintf(stderr, "domainname not set. Aborting.\n");
		exit(1);
	}

	while (--argc) {
		++argv;
		if (!strcmp("-insecure", *argv))
			insecure = 1;
		else if (!strcmp("-ypset", *argv))
			ypsetmode = YPSET_ALL;
		else if (!strcmp("-ypsetme", *argv))
			ypsetmode = YPSET_LOCAL;
		else
			usage();
	}

	/* blow away everything in BINDINGDIR */
	dirp = opendir(BINDINGDIR);
	if (dirp) {
		while ((dent = readdir(dirp))) {
			if (!strcmp(dent->d_name, ".") ||
			    !strcmp(dent->d_name, ".."))
				continue;
			snprintf(path, sizeof(path), "%s/%s", BINDINGDIR,
			    dent->d_name);
			(void) unlink(path);
		}
		closedir(dirp);
	} else {
		(void)mkdir(BINDINGDIR, 0755);
	}

#ifdef O_SHLOCK
	if ((lockfd = open(YPBINDLOCK, O_CREAT|O_SHLOCK|O_RDWR|O_TRUNC,
	    0644)) == -1) {
		fprintf(stderr, "ypbind: cannot create %s\n", YPBINDLOCK);
		exit(1);
	}
#else
	if ((lockfd = open(YPBINDLOCK, O_CREAT|O_RDWR|O_TRUNC, 0644)) == -1) {
		fprintf(stderr, "ypbind: cannot create %s.\n", YPBINDLOCK);
		exit(1);
	}
	flock(lockfd, LOCK_SH);
#endif

	if (fchmod(lockfd, 0644) == -1)
		err(1, "fchmod");

	(void)pmap_unset(YPBINDPROG, YPBINDVERS);

	udptransp = svcudp_create(RPC_ANYSOCK);
	if (udptransp == NULL) {
		fprintf(stderr, "cannot create udp service.\n");
		exit(1);
	}
	if (!svc_register(udptransp, YPBINDPROG, YPBINDVERS, ypbindprog_2,
	    IPPROTO_UDP)) {
		fprintf(stderr,
		    "unable to register (YPBINDPROG, YPBINDVERS, udp).\n");
		exit(1);
	}

	tcptransp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (tcptransp == NULL) {
		fprintf(stderr, "cannot create tcp service.\n");
		exit(1);
	}
	if (!svc_register(tcptransp, YPBINDPROG, YPBINDVERS, ypbindprog_2,
	    IPPROTO_TCP)) {
		fprintf(stderr,
		    "unable to register (YPBINDPROG, YPBINDVERS, tcp).\n");
		exit(1);
	}

	if (ypsetmode == YPSET_LOCAL) {
		/* build UDP local port */
		if ((lsock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) {
			syslog(LOG_ERR, "cannot create local udp socket: %m");
			exit(1);
		}
		(void)setsockopt(lsock, SOL_SOCKET, SO_REUSEADDR, &one,
		    (socklen_t)sizeof one);
		len = sizeof(sin);
		if (getsockname(udptransp->xp_sock, (struct sockaddr *)&sin,
		    &len) == -1) {
			syslog(LOG_ERR, "cannot getsockname local udp: %m");
			exit(1);
		}
		sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
		sin.sin_port = htons(udptransp->xp_port);
		if (bind(lsock, (struct sockaddr *)&sin, len) != 0) {
			syslog(LOG_ERR, "cannot bind local udp: %m");
			exit(1);
		}
		if ((ludptransp = svcudp_create(lsock)) == NULL) {
			fprintf(stderr, "cannot create udp service.\n");
			exit(1);
		}

		/* build TCP local port */
		if ((lsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
			syslog(LOG_ERR, "cannot create udp socket: %m");
			exit(1);
		}
		(void)setsockopt(lsock, SOL_SOCKET, SO_REUSEADDR, &one,
		    (socklen_t)sizeof one);
		len = sizeof(sin);
		if (getsockname(tcptransp->xp_sock, (struct sockaddr *)&sin,
		    &len) == -1) {
			syslog(LOG_ERR, "cannot getsockname udp: %m");
			exit(1);
		}
		sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
		sin.sin_port = htons(tcptransp->xp_port);
		if (bind(lsock, (struct sockaddr *)&sin, len) == -1) {
			syslog(LOG_ERR, "cannot bind local tcp: %m");
			exit(1);
		}
		if ((ltcptransp = svctcp_create(lsock, 0, 0)) == NULL) {
			fprintf(stderr, "cannot create tcp service.\n");
			exit(1);
		}
	}

	if ((rpcsock = socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK, 0)) < 0) {
		perror("socket");
		return -1;
	}
	memset(&sin, 0, sizeof sin);
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = htonl(INADDR_ANY);
	sin.sin_port = 0;
	bindresvport(rpcsock, &sin);

	if ((pingsock = socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK, 0)) < 0) {
		perror("socket");
		return -1;
	}
	memset(&sin, 0, sizeof sin);
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = htonl(INADDR_ANY);
	sin.sin_port = 0;
	bindresvport(pingsock, &sin);

	setsockopt(rpcsock, SOL_SOCKET, SO_BROADCAST, &one,
	    (socklen_t)sizeof(one));
	rmtca.prog = YPPROG;
	rmtca.vers = YPVERS;
	rmtca.proc = YPPROC_DOMAIN_NONACK;
	rmtca.xdr_args = NULL;		/* set at call time */
	rmtca.args_ptr = NULL;		/* set at call time */
	rmtcr.port_ptr = &rmtcr_port;
	rmtcr.xdr_results = xdr_bool;
	rmtcr.results_ptr = (caddr_t)&rmtcr_outval;

	if (strchr(domain, '/'))
		errx(1, "bad domainname %s", domain);

	/* build initial domain binding, make it "unsuccessful" */
	ypbindlist = malloc(sizeof *ypbindlist);
	if (ypbindlist == NULL)
		errx(1, "no memory");
	memset(ypbindlist, 0, sizeof *ypbindlist);
	strncpy(ypbindlist->dom_domain, domain, sizeof ypbindlist->dom_domain-1);
	ypbindlist->dom_domain[sizeof (ypbindlist->dom_domain)-1] = '\0';
	ypbindlist->dom_vers = YPVERS;
	snprintf(ypbindlist->dom_servlist, sizeof ypbindlist->dom_servlist,
	    "%s/%s", SERVERSDIR, ypbindlist->dom_domain);
	ypbindlist->dom_servlistfp = fopen(ypbindlist->dom_servlist, "r");
	ypbindlist->dom_alive = 0;
	ypbindlist->dom_lockfd = -1;
	ypbindlist->dom_xid = unique_xid(ypbindlist);
	snprintf(path, sizeof path, "%s/%s.%d", BINDINGDIR,
	    ypbindlist->dom_domain, (int)ypbindlist->dom_vers);
	(void)unlink(path);

	checkwork();

	while (1) {
		if (pfd == NULL || width != svc_max_pollfd + 2) {
			width = svc_max_pollfd + 2;
			pfd = reallocarray(pfd, width, sizeof *pfd);
			if (pfd == NULL)
				err(1, NULL);
		}

		pfd[0].fd = rpcsock;
		pfd[0].events = POLLIN;
		pfd[1].fd = pingsock;
		pfd[1].events = POLLIN;
		memcpy(pfd + 2, svc_pollfd, sizeof(*pfd) * svc_max_pollfd);

		nready = poll(pfd, width, 1000);
		switch (nready) {
		case 0:
			checkwork();
			break;
		case -1:
			if (errno != EINTR)
				perror("poll");
			break;
		default:
			/* No need to check for POLLHUP on UDP sockets. */
			if (pfd[0].revents & POLLIN) {
				handle_replies();
				nready--;
			}
			if (pfd[1].revents & POLLIN) {
				handle_ping();
				nready--;
			}
			svc_getreq_poll(pfd + 2, nready);
			if (check)
				checkwork();
			break;
		}

#ifdef DAEMON
		if (!evil && ypbindlist->dom_alive) {
			evil = 1;
			daemon(0, 0);
		}
#endif
	}
}

/*
 * State transition is done like this:
 *
 * STATE	EVENT		ACTION			NEWSTATE	TIMEOUT
 * no binding	timeout		broadcast		no binding	5 sec
 * no binding	answer		--			binding		60 sec
 * binding	timeout		ping server		checking	5 sec
 * checking	timeout		ping server + broadcast	checking	5 sec
 * checking	answer		--			binding		60 sec
 */
void
checkwork(void)
{
	struct _dom_binding *ypdb;
	time_t t;

	time(&t);
	for (ypdb = ypbindlist; ypdb; ypdb = ypdb->dom_pnext) {
		if (ypdb->dom_check_t < t) {
			if (ypdb->dom_alive == 1)
				ping(ypdb);
			else
				pings(ypdb);
			time(&t);
			ypdb->dom_check_t = t + 5;
		}
	}
	check = 0;
}

int
ping(struct _dom_binding *ypdb)
{
	domainname dom = ypdb->dom_domain;
	struct rpc_msg msg;
	char buf[1400];
	enum clnt_stat st;
	int outlen;
	AUTH *rpcua;
	XDR xdr;

	memset(&xdr, 0, sizeof xdr);
	memset(&msg, 0, sizeof msg);

	rpcua = authunix_create_default();
	if (rpcua == (AUTH *)NULL) {
		/*printf("cannot get unix auth\n");*/
		return RPC_SYSTEMERROR;
	}
	msg.rm_direction = CALL;
	msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;
	msg.rm_call.cb_prog = YPPROG;
	msg.rm_call.cb_vers = YPVERS;
	msg.rm_call.cb_proc = YPPROC_DOMAIN_NONACK;
	msg.rm_call.cb_cred = rpcua->ah_cred;
	msg.rm_call.cb_verf = rpcua->ah_verf;

	msg.rm_xid = ypdb->dom_xid;
	xdrmem_create(&xdr, buf, sizeof buf, XDR_ENCODE);
	if (!xdr_callmsg(&xdr, &msg)) {
		st = RPC_CANTENCODEARGS;
		AUTH_DESTROY(rpcua);
		return st;
	}
	if (!xdr_domainname(&xdr, &dom)) {
		st = RPC_CANTENCODEARGS;
		AUTH_DESTROY(rpcua);
		return st;
	}
	outlen = (int)xdr_getpos(&xdr);
	xdr_destroy(&xdr);
	if (outlen < 1) {
		st = RPC_CANTENCODEARGS;
		AUTH_DESTROY(rpcua);
		return st;
	}
	AUTH_DESTROY(rpcua);

	ypdb->dom_alive = 2;
	if (sendto(pingsock, buf, outlen, 0,
	    (struct sockaddr *)&ypdb->dom_server_addr,
	    (socklen_t)sizeof ypdb->dom_server_addr) < 0)
		perror("sendto");
	return 0;

}

int
pings(struct _dom_binding *ypdb)
{
	domainname dom = ypdb->dom_domain;
	struct rpc_msg msg;
	struct sockaddr_in bindsin;
	char buf[1400];
	char path[PATH_MAX];
	enum clnt_stat st;
	int outlen;
	AUTH *rpcua;
	XDR xdr;

	rmtca.xdr_args = xdr_domainname;
	rmtca.args_ptr = (char *)&dom;

	memset(&xdr, 0, sizeof xdr);
	memset(&msg, 0, sizeof msg);

	rpcua = authunix_create_default();
	if (rpcua == (AUTH *)NULL) {
		/*printf("cannot get unix auth\n");*/
		return RPC_SYSTEMERROR;
	}
	msg.rm_direction = CALL;
	msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;
	msg.rm_call.cb_prog = PMAPPROG;
	msg.rm_call.cb_vers = PMAPVERS;
	msg.rm_call.cb_proc = PMAPPROC_CALLIT;
	msg.rm_call.cb_cred = rpcua->ah_cred;
	msg.rm_call.cb_verf = rpcua->ah_verf;

	msg.rm_xid = ypdb->dom_xid;
	xdrmem_create(&xdr, buf, sizeof buf, XDR_ENCODE);
	if (!xdr_callmsg(&xdr, &msg)) {
		st = RPC_CANTENCODEARGS;
		AUTH_DESTROY(rpcua);
		return st;
	}
	if (!xdr_rmtcall_args(&xdr, &rmtca)) {
		st = RPC_CANTENCODEARGS;
		AUTH_DESTROY(rpcua);
		return st;
	}
	outlen = (int)xdr_getpos(&xdr);
	xdr_destroy(&xdr);
	if (outlen < 1) {
		st = RPC_CANTENCODEARGS;
		AUTH_DESTROY(rpcua);
		return st;
	}
	AUTH_DESTROY(rpcua);

	if (ypdb->dom_lockfd != -1) {
		close(ypdb->dom_lockfd);
		ypdb->dom_lockfd = -1;
		snprintf(path, sizeof path, "%s/%s.%d", BINDINGDIR,
		    ypdb->dom_domain, (int)ypdb->dom_vers);
		unlink(path);
	}

	if (ypdb->dom_alive == 2) {
		/*
		 * This resolves the following situation:
		 * ypserver on other subnet was once bound,
		 * but rebooted and is now using a different port
		 */
		memset(&bindsin, 0, sizeof bindsin);
		bindsin.sin_family = AF_INET;
		bindsin.sin_len = sizeof(bindsin);
		bindsin.sin_port = htons(PMAPPORT);
		bindsin.sin_addr = ypdb->dom_server_addr.sin_addr;
		if (sendto(rpcsock, buf, outlen, 0, (struct sockaddr *)&bindsin,
		    (socklen_t)sizeof bindsin) < 0)
			perror("sendto");
	}
	if (ypdb->dom_servlistfp)
		return direct(ypdb, buf, outlen);
	return broadcast(ypdb, buf, outlen);
}

int
broadcast(struct _dom_binding *ypdb, char *buf, int outlen)
{
	struct ifaddrs *ifap, *ifa;
	struct sockaddr_in bindsin;
	struct in_addr in;

	memset(&bindsin, 0, sizeof bindsin);
	bindsin.sin_family = AF_INET;
	bindsin.sin_len = sizeof(bindsin);
	bindsin.sin_port = htons(PMAPPORT);

	if (getifaddrs(&ifap) != 0) {
		perror("getifaddrs");
		return -1;
	}
	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family != AF_INET)
			continue;
		if ((ifa->ifa_flags & IFF_UP) == 0)
			continue;

		switch (ifa->ifa_flags & (IFF_LOOPBACK | IFF_BROADCAST)) {
		case IFF_BROADCAST:
			if (!ifa->ifa_broadaddr)
				continue;
			if (ifa->ifa_broadaddr->sa_family != AF_INET)
				continue;
			in = ((struct sockaddr_in *)ifa->ifa_broadaddr)->sin_addr;
			break;
		case IFF_LOOPBACK:
			in = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr;
			break;
		default:
			continue;
		}

		bindsin.sin_addr = in;
		if (sendto(rpcsock, buf, outlen, 0, (struct sockaddr *)&bindsin,
		    (socklen_t)bindsin.sin_len) < 0)
			perror("sendto");
	}
	freeifaddrs(ifap);
	return 0;
}

int
direct(struct _dom_binding *ypdb, char *buf, int outlen)
{
	char line[1024], *p;
	struct hostent *hp;
	struct sockaddr_in bindsin;
	int i, c;
	struct stat fst, st;

	if (fstat(fileno(ypdb->dom_servlistfp), &fst) != -1 &&
	    stat(ypdb->dom_servlist, &st) != -1 &&
	    (st.st_dev != fst.st_dev || st.st_ino != fst.st_ino)) {
		FILE *fp;

		fp = fopen(ypdb->dom_servlist, "r");
		if (fp) {
			fclose(ypdb->dom_servlistfp);
			ypdb->dom_servlistfp = fp;
		}
	}
	(void) rewind(ypdb->dom_servlistfp);

	memset(&bindsin, 0, sizeof bindsin);
	bindsin.sin_family = AF_INET;
	bindsin.sin_len = sizeof(bindsin);
	bindsin.sin_port = htons(PMAPPORT);

	while (fgets(line, sizeof(line), ypdb->dom_servlistfp) != NULL) {
		/* skip lines that are too big */
		p = strchr(line, '\n');
		if (p == NULL) {
			while ((c = getc(ypdb->dom_servlistfp)) != '\n' && c != EOF)
				;
			continue;
		}
		*p = '\0';
		p = line;
		while (isspace((unsigned char)*p))
			p++;
		if (*p == '#')
			continue;
		hp = gethostbyname(p);
		if (!hp)
			continue;
		/* step through all addresses in case first is unavailable */
		for (i = 0; hp->h_addr_list[i]; i++) {
			memmove(&bindsin.sin_addr, hp->h_addr_list[0],
			    hp->h_length);
			if (sendto(rpcsock, buf, outlen, 0,
			    (struct sockaddr *)&bindsin,
			    (socklen_t)sizeof bindsin) < 0) {
				perror("sendto");
				continue;
			}
		}
	}
	return 0;
}

enum clnt_stat
handle_replies(void)
{
	char buf[1400];
	int inlen;
	socklen_t fromlen;
	struct _dom_binding *ypdb;
	struct sockaddr_in raddr;
	struct rpc_msg msg;
	XDR xdr;

recv_again:
	memset(&xdr, 0, sizeof(xdr));
	memset(&msg, 0, sizeof(msg));
	msg.acpted_rply.ar_verf = _null_auth;
	msg.acpted_rply.ar_results.where = (caddr_t)&rmtcr;
	msg.acpted_rply.ar_results.proc = xdr_rmtcallres;

try_again:
	fromlen = sizeof (struct sockaddr);
	inlen = recvfrom(rpcsock, buf, sizeof buf, 0,
	    (struct sockaddr *)&raddr, &fromlen);
	if (inlen < 0) {
		if (errno == EINTR)
			goto try_again;
		return RPC_CANTRECV;
	}
	if (inlen < sizeof(u_int32_t))
		goto recv_again;

	/*
	 * see if reply transaction id matches sent id.
	 * If so, decode the results.
	 */
	xdrmem_create(&xdr, buf, (u_int)inlen, XDR_DECODE);
	if (xdr_replymsg(&xdr, &msg)) {
		if ((msg.rm_reply.rp_stat == MSG_ACCEPTED) &&
		    (msg.acpted_rply.ar_stat == SUCCESS)) {
			raddr.sin_port = htons((u_short)rmtcr_port);
			ypdb = xid2ypdb(msg.rm_xid);
			if (ypdb)
				rpc_received(ypdb->dom_domain, &raddr, 0);
		}
	}
	xdr.x_op = XDR_FREE;
	msg.acpted_rply.ar_results.proc = xdr_void;
	xdr_destroy(&xdr);

	return RPC_SUCCESS;
}

enum clnt_stat
handle_ping(void)
{
	char buf[1400];
	int inlen;
	socklen_t fromlen;
	struct _dom_binding *ypdb;
	struct sockaddr_in raddr;
	struct rpc_msg msg;
	XDR xdr;
	bool_t res;

recv_again:
	memset(&xdr, 0, sizeof(xdr));
	memset(&msg, 0, sizeof(msg));
	msg.acpted_rply.ar_verf = _null_auth;
	msg.acpted_rply.ar_results.where = (caddr_t)&res;
	msg.acpted_rply.ar_results.proc = xdr_bool;

try_again:
	fromlen = sizeof (struct sockaddr);
	inlen = recvfrom(pingsock, buf, sizeof buf, 0,
	    (struct sockaddr *)&raddr, &fromlen);
	if (inlen < 0) {
		if (errno == EINTR)
			goto try_again;
		return RPC_CANTRECV;
	}
	if (inlen < sizeof(u_int32_t))
		goto recv_again;

	/*
	 * see if reply transaction id matches sent id.
	 * If so, decode the results.
	 */
	xdrmem_create(&xdr, buf, (u_int)inlen, XDR_DECODE);
	if (xdr_replymsg(&xdr, &msg)) {
		if ((msg.rm_reply.rp_stat == MSG_ACCEPTED) &&
		    (msg.acpted_rply.ar_stat == SUCCESS)) {
			ypdb = xid2ypdb(msg.rm_xid);
			if (ypdb)
				rpc_received(ypdb->dom_domain, &raddr, 0);
		}
	}
	xdr.x_op = XDR_FREE;
	msg.acpted_rply.ar_results.proc = xdr_void;
	xdr_destroy(&xdr);

	return RPC_SUCCESS;
}

/*
 * We prefer loopback connections.
 */
void
rpc_received(char *dom, struct sockaddr_in *raddrp, int force)
{
	struct _dom_binding *ypdb;
	struct iovec iov[2];
	struct ypbind_resp ybr;
	char path[PATH_MAX];
	int fd;

	if (strchr(dom, '/'))
		return;

#ifdef DEBUG
	printf("returned from %s about %s\n", inet_ntoa(raddrp->sin_addr), dom);
#endif

	if (dom == NULL)
		return;

	for (ypdb = ypbindlist; ypdb; ypdb = ypdb->dom_pnext)
		if (!strcmp(ypdb->dom_domain, dom))
			break;

	if (ypdb == NULL) {
		if (force == 0)
			return;
		ypdb = malloc(sizeof *ypdb);
		if (ypdb == NULL)
			return;
		memset(ypdb, 0, sizeof *ypdb);
		strncpy(ypdb->dom_domain, dom, sizeof ypdb->dom_domain-1);
		ypdb->dom_domain[sizeof (ypdb->dom_domain)-1] = '\0';
		ypdb->dom_lockfd = -1;
		ypdb->dom_xid = unique_xid(ypdb);
		ypdb->dom_pnext = ypbindlist;
		ypbindlist = ypdb;
	}

	/* we do not support sunos 3.0 insecure servers */
	if (insecure == 0 && ntohs(raddrp->sin_port) >= IPPORT_RESERVED)
		return;

	/* soft update, alive */
	if (ypdb->dom_alive == 1 && force == 0) {
		if (!memcmp(&ypdb->dom_server_addr, raddrp,
		    sizeof ypdb->dom_server_addr)) {
			ypdb->dom_alive = 1;
			/* recheck binding in 60 sec */
			ypdb->dom_check_t = time(NULL) + 60;
		}
		if (raddrp->sin_addr.s_addr == htonl(INADDR_LOOPBACK)) {
			/*
			 * we are alive and already have a binding, but
			 * after a broadcast we prefer the localhost
			 */
			memcpy(&ypdb->dom_server_addr, raddrp,
			    sizeof ypdb->dom_server_addr);
		}
		return;
	}

	memcpy(&ypdb->dom_server_addr, raddrp, sizeof ypdb->dom_server_addr);
	/* recheck binding in 60 seconds */
	ypdb->dom_check_t = time(NULL) + 60;
	ypdb->dom_vers = YPVERS;
	ypdb->dom_alive = 1;

	if (ypdb->dom_lockfd != -1)
		close(ypdb->dom_lockfd);

	snprintf(path, sizeof path, "%s/%s.%d", BINDINGDIR,
	    ypdb->dom_domain, (int)ypdb->dom_vers);
#ifdef O_SHLOCK
	if ((fd = open(path, O_CREAT|O_SHLOCK|O_RDWR|O_TRUNC, 0644)) == -1) {
		(void)mkdir(BINDINGDIR, 0755);
		if ((fd = open(path, O_CREAT|O_SHLOCK|O_RDWR|O_TRUNC,
		    0644)) == -1)
			return;
	}
#else
	if ((fd = open(path, O_CREAT|O_RDWR|O_TRUNC, 0644)) == -1) {
		(void)mkdir(BINDINGDIR, 0755);
		if ((fd = open(path, O_CREAT|O_RDWR|O_TRUNC, 0644)) == -1)
			return;
	}
	flock(fd, LOCK_SH);
#endif

	if (fchmod(fd, 0644) == -1)
		err(1, "fchmod");

	/*
	 * ok, if BINDINGDIR exists, and we can create the binding file,
	 * then write to it..
	 */
	ypdb->dom_lockfd = fd;

	iov[0].iov_base = (caddr_t)&(udptransp->xp_port);
	iov[0].iov_len = sizeof udptransp->xp_port;
	iov[1].iov_base = (caddr_t)&ybr;
	iov[1].iov_len = sizeof ybr;

	memset(&ybr, 0, sizeof ybr);
	ybr.ypbind_status = YPBIND_SUCC_VAL;
	memmove(&ybr.ypbind_resp_u.ypbind_bindinfo.ypbind_binding_addr,
	    &raddrp->sin_addr,
	    sizeof(ybr.ypbind_resp_u.ypbind_bindinfo.ypbind_binding_addr));
	memmove(&ybr.ypbind_resp_u.ypbind_bindinfo.ypbind_binding_port,
	    &raddrp->sin_port,
	    sizeof(ybr.ypbind_resp_u.ypbind_bindinfo.ypbind_binding_port));

	if (writev(ypdb->dom_lockfd, iov, 2) != iov[0].iov_len + iov[1].iov_len) {
		perror("write");
		close(ypdb->dom_lockfd);
		unlink(path);
		ypdb->dom_lockfd = -1;
		return;
	}
}

struct _dom_binding *
xid2ypdb(u_int32_t xid)
{
	struct _dom_binding *ypdb;

	for (ypdb = ypbindlist; ypdb; ypdb = ypdb->dom_pnext)
		if (ypdb->dom_xid == xid)
			break;
	return (ypdb);
}

u_int32_t
unique_xid(struct _dom_binding *ypdb)
{
	u_int32_t xid;

	xid = arc4random();
	while (xid2ypdb(xid) != NULL)
		xid++;

	return (xid);
}
@


1.68
log
@When making a copy of svc_pollfd, use the correct size.
Also pass the correct fd count to svc_getreq_poll().
OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.67 2016/07/05 16:41:40 jca Exp $ */
a377 3
		printf("Enabling yp client subsystem.\n");
		printf("To disable: kill ypbind and remove %s\n",
		    BINDINGDIR);
@


1.67
log
@Move to svc_getreq_poll/svc_pollfd.

Stop using select to avoid the weird workarounds for fd_set size.
Also replace calloc with reallocarray.  Prompted by a mail by Miod,
cluebat from guenther@@.

ok millert@@, prodding deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.66 2016/03/21 00:49:36 guenther Exp $ */
d341 1
a341 1
	int width = 0, lockfd, lsock;
d543 1
a543 1
		memcpy(pfd + 2, svc_pollfd, svc_max_pollfd);
d545 2
a546 1
		switch (poll(pfd, width, 1000)) {
d556 1
a556 1
			if (pfd[0].revents & POLLIN)
d558 3
a560 1
			if (pfd[1].revents & POLLIN)
d562 3
a564 1
			svc_getreq_poll(pfd + 2, svc_max_pollfd);
@


1.66
log
@Instead of creating a socket with socket() or accept() and then
setting the O_NONBLOCK flag on it with fcntl(F_SETFL) afterwards,
just pass SOCK_NONBLOCK to socket() or accept4() and get it right
to begin with.

ok millert@@ krw@@ beck@@ deraadt@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.65 2015/12/12 20:04:23 mmcc Exp $ */
d56 1
d340 2
a341 4
	struct timeval tv;
	fd_set *fdsrp = NULL;
	int fdsrl = 0;
	int width, lockfd, lsock;
d532 6
a537 21
		extern int __svc_fdsetsize;
		extern void *__svc_fdset;

		if (fdsrp == NULL || fdsrl != __svc_fdsetsize) {
			free(fdsrp);

			fdsrl = __svc_fdsetsize;
			width = __svc_fdsetsize;
			if (rpcsock > __svc_fdsetsize)
				width = rpcsock;
			if (pingsock > __svc_fdsetsize)
				width = pingsock;
			fdsrp = calloc(howmany(width+1, NFDBITS), sizeof(fd_mask));
			if (fdsrp == NULL)
				errx(1, "no memory");
		}

		bcopy(__svc_fdset, fdsrp, howmany(fdsrl+1, NFDBITS) *
		    sizeof(fd_mask));
		FD_SET(rpcsock, fdsrp);
		FD_SET(pingsock, fdsrp);
d539 5
a543 2
		tv.tv_sec = 1;
		tv.tv_usec = 0;
d545 1
a545 1
		switch (select(width+1, fdsrp, NULL, NULL, &tv)) {
d550 2
a551 1
			perror("select\n");
d554 2
a555 1
			if (FD_ISSET(rpcsock, fdsrp))
d557 1
a557 1
			if (FD_ISSET(pingsock, fdsrp))
d559 1
a559 1
			svc_getreqset2(fdsrp, width);
@


1.65
log
@Remove NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.64 2015/08/20 22:39:30 deraadt Exp $ */
d478 1
a478 1
	if ((rpcsock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
d488 1
a488 1
	if ((pingsock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
a497 2
	fcntl(rpcsock, F_SETFL, fcntl(rpcsock, F_GETFL, 0) | FNDELAY);
	fcntl(pingsock, F_SETFL, fcntl(pingsock, F_GETFL, 0) | FNDELAY);
@


1.64
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.63 2015/01/16 06:40:22 deraadt Exp $ */
d539 1
a539 2
			if (fdsrp)
				free(fdsrp);
@


1.63
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.62 2014/01/21 23:05:09 jsg Exp $ */
d156 1
a156 1
		ypdb = (struct _dom_binding *)malloc(sizeof *ypdb);
d515 1
a515 1
	ypbindlist = (struct _dom_binding *)malloc(sizeof *ypbindlist);
d548 1
a548 2
			fdsrp = (fd_set *)calloc(howmany(width+1, NFDBITS),
			    sizeof(fd_mask));
d992 1
a992 1
		ypdb = (struct _dom_binding *)malloc(sizeof *ypdb);
@


1.62
log
@add back ctype.h include for isspace()
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.61 2013/12/20 00:31:12 deraadt Exp $ */
d39 1
d74 1
a74 1
	char dom_servlist[MAXPATHLEN];
d136 1
a136 1
	char path[MAXPATHLEN];
d337 1
a337 1
	char path[MAXPATHLEN];
d683 1
a683 1
	char path[MAXPATHLEN];
d973 1
a973 1
	char path[MAXPATHLEN];
@


1.61
log
@delete 4 includes we do not need
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.60 2013/11/24 01:06:19 deraadt Exp $ */
d40 1
@


1.60
log
@more unsigned char casts for ctype
ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.59 2009/10/27 23:59:57 deraadt Exp $ */
a28 1
#include <sys/param.h>
a29 1
#include <sys/ioctl.h>
d36 1
a39 2
#include <ctype.h>
#include <dirent.h>
a44 1
#include <net/if.h>
@


1.59
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.58 2008/08/02 04:13:37 deraadt Exp $ */
d842 1
a842 1
		while (isspace(*p))
@


1.58
log
@usage() has to exit 1; Gleydson Soares
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.57 2007/10/09 14:40:15 deraadt Exp $ */
a27 4

#ifndef lint
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.57 2007/10/09 14:40:15 deraadt Exp $";
#endif
@


1.57
log
@missing newlines in printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.56 2007/02/18 23:27:06 jmc Exp $ */
d30 1
a30 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.56 2007/02/18 23:27:06 jmc Exp $";
d337 1
a337 1
	exit(0);
@


1.56
log
@tidy up synopsis and usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.55 2007/01/02 20:12:01 otto Exp $ */
d30 1
a30 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.55 2007/01/02 20:12:01 otto Exp $";
d399 1
a399 1
		fprintf(stderr, "ypbind: cannot create %s\n", YPBINDLOCK);
d412 1
a412 1
		fprintf(stderr, "cannot create udp service.");
d418 1
a418 1
		    "unable to register (YPBINDPROG, YPBINDVERS, udp).");
d424 1
a424 1
		fprintf(stderr, "cannot create tcp service.");
d430 1
a430 1
		    "unable to register (YPBINDPROG, YPBINDVERS, tcp).");
d455 1
a455 1
			fprintf(stderr, "cannot create udp service.");
d479 1
a479 1
			fprintf(stderr, "cannot create tcp service.");
@


1.55
log
@return proper server error on failed ypset. Inspired by freebsd; ok
deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.54 2007/01/02 20:10:48 otto Exp $ */
d30 1
a30 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.54 2007/01/02 20:10:48 otto Exp $";
d336 1
a336 1
	fprintf(stderr, "usage: ypbind [-ypset] [-ypsetme] [-insecure]\n");
@


1.54
log
@Fix setting up the more specific binding for the ypsetme
functionality. We want to bind to the same ports as the general
binding, but with a local address. with and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.53 2006/04/02 01:29:51 deraadt Exp $ */
d30 1
a30 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.53 2006/04/02 01:29:51 deraadt Exp $";
d224 1
a224 1
	static bool_t res;
a225 1
	memset(&res, 0, sizeof(res));
d232 6
a237 1
			return (bool_t *)NULL;
a238 2
		if (fromsin->sin_addr.s_addr != htonl(INADDR_LOOPBACK))
			return (bool_t *)NULL;
d244 2
a245 1
		return &res;
d248 4
a251 2
	if (ntohs(fromsin->sin_port) >= IPPORT_RESERVED)
		return &res;
d253 4
a256 2
	if (argp->ypsetdom_vers != YPVERS)
		return &res;
a266 1
	res = 1;
@


1.53
log
@#ifdef lint not LINT
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.52 2004/02/20 11:57:17 henning Exp $ */
d30 1
a30 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.52 2004/02/20 11:57:17 henning Exp $";
d443 1
a443 1
		sin.sin_port = 0;
d467 1
a467 1
		sin.sin_port = 0;
d469 1
a469 1
			syslog(LOG_ERR, "cannot bind udp: %m");
@


1.52
log
@ypbin creates /var/yp/binding/<domainname>.<version> and /var/run/ypbind.lock
using open(2) with mode 0644 - however, these files _have_ to be world
readable, and open's mode is subject to umask.
do an explicit fchmod after open to set the mode to 0644 regardless of umask.

ok maja@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.51 2003/08/19 22:10:08 deraadt Exp $ */
d29 2
a30 2
#ifndef LINT
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.51 2003/08/19 22:10:08 deraadt Exp $";
d126 1
d136 1
d219 1
d435 1
a435 1
		    sizeof one);
d459 1
a459 1
		    sizeof one);
d500 2
a501 1
	setsockopt(rpcsock, SOL_SOCKET, SO_BROADCAST, &one, sizeof(one));
d670 1
a670 1
	    sizeof ypdb->dom_server_addr) < 0)
d749 1
a749 1
		    sizeof bindsin) < 0)
d796 1
a796 1
		    bindsin.sin_len) < 0)
d852 2
a853 1
			    (struct sockaddr *)&bindsin, sizeof bindsin) < 0) {
@


1.51
log
@very hairy modifications for dynamic fd_set handling.  dynamic rpc fd_set's
are just nasty; ok matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.50 2003/07/15 06:10:45 deraadt Exp $ */
d30 1
a30 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.50 2003/07/15 06:10:45 deraadt Exp $";
d396 3
d1049 3
@


1.50
log
@protos and repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.49 2003/06/25 21:45:47 deraadt Exp $ */
d30 1
a30 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.49 2003/06/25 21:45:47 deraadt Exp $";
d337 2
a338 1
	fd_set fdsr;
d528 23
a550 10
		fdsr = svc_fdset;
		FD_SET(rpcsock, &fdsr);
		FD_SET(pingsock, &fdsr);

		width = svc_maxfd;
		if (rpcsock > width)
			width = rpcsock;
		if (pingsock > width)
			width = pingsock;
		width++;
d555 1
a555 1
		switch (select(width, &fdsr, NULL, NULL, &tv)) {
d563 1
a563 1
			if (FD_ISSET(rpcsock, &fdsr))
d565 1
a565 1
			if (FD_ISSET(pingsock, &fdsr))
d567 1
a567 1
			svc_getreqset(&fdsr);
@


1.49
log
@remove excess proto
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.48 2003/06/02 04:00:17 deraadt Exp $ */
d30 1
a30 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.48 2003/06/02 04:00:17 deraadt Exp $";
d126 1
a126 1
void *
d135 1
a135 1
struct ypbind_resp *
d217 1
a217 1
bool_t *
d264 1
a264 1
	union {
d270 2
a271 2
	bool_t (*xdr_argument)(), (*xdr_result)();
	char *(*local)();
d277 2
a278 1
		local = (char *(*)()) ypbindproc_null_2x;
d284 2
a285 1
		local = (char *(*)()) ypbindproc_domain_2x;
d304 2
a305 1
		local = (char *(*)()) ypbindproc_setdom_2x;
d324 1
a324 1
void
@


1.48
log
@remove terms 3 and 4 of some of my licences
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.47 2002/09/06 19:46:53 deraadt Exp $ */
d30 1
a30 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.47 2002/09/06 19:46:53 deraadt Exp $";
a82 4

extern bool_t xdr_domainname(), xdr_ypbind_resp();
extern bool_t xdr_ypreq_key(), xdr_ypresp_val();
extern bool_t xdr_ypbind_setdom();
@


1.47
log
@use more socklen_t; pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.46 2002/07/20 12:14:51 deraadt Exp $ */
d4 1
a4 3
 * Copyright (c) 1997,1998 Theo de Raadt <deraadt@@OpenBSD.org>
 * Copyright (c) 1996 Theo de Raadt <deraadt@@theos.com>
 * Copyright (c) 1992, 1993 Theo de Raadt <deraadt@@theos.com>
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
d30 1
a30 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.46 2002/07/20 12:14:51 deraadt Exp $";
@


1.46
log
@try to make pingsock and rpcsock resv too
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.45 2002/06/29 07:32:15 deraadt Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.45 2002/06/29 07:32:15 deraadt Exp $";
d347 2
a348 1
	int width, lockfd, len, lsock;
d853 2
a854 1
	int fromlen, inlen;
d904 2
a905 1
	int fromlen, inlen;
@


1.45
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.44 2002/05/30 19:09:06 deraadt Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.44 2002/05/30 19:09:06 deraadt Exp $";
d444 1
d468 1
d483 6
d493 5
@


1.44
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.43 2002/03/14 16:44:25 mpech Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.43 2002/03/14 16:44:25 mpech Exp $";
d132 1
a132 1
 * 
d139 1
a139 4
ypbindproc_null_2x(transp, argp, clnt)
	SVCXPRT *transp;
	void *argp;
	CLIENT *clnt;
d148 1
a148 4
ypbindproc_domain_2x(transp, argp, clnt)
	SVCXPRT *transp;
	domainname *argp;
	CLIENT *clnt;
d230 1
a230 4
ypbindproc_setdom_2x(transp, argp, clnt)
	SVCXPRT *transp;
	struct ypbind_setdom *argp;
	CLIENT *clnt;
d274 1
a274 3
ypbindprog_2(rqstp, transp)
	struct svc_req *rqstp;
	SVCXPRT *transp;
d334 1
a334 1
usage()
d341 1
a341 3
main(argc, argv)
	int argc;
	char *argv[];
d564 1
a564 1
 * State transition is done like this: 
d574 1
a574 1
checkwork()
d594 1
a594 2
ping(ypdb)
	struct _dom_binding *ypdb;
d642 1
a642 1
	if (sendto(pingsock, buf, outlen, 0, 
d651 1
a651 2
pings(ypdb)
	struct _dom_binding *ypdb;
d732 1
a732 4
broadcast(ypdb, buf, outlen)
	struct _dom_binding *ypdb;
	char *buf;
	int outlen;
d778 1
a778 4
direct(ypdb, buf, outlen)
	struct _dom_binding *ypdb;
	char *buf;
	int outlen;
d836 1
a836 1
handle_replies()
d886 1
a886 1
handle_ping()
d939 1
a939 4
rpc_received(dom, raddrp, force)
char *dom;
struct sockaddr_in *raddrp;
int force;
d1056 1
a1056 2
xid2ypdb(xid)
	u_int32_t xid;
d1067 1
a1067 2
unique_xid(ypdb)
	struct _dom_binding *ypdb;
@


1.43
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.42 2002/02/16 21:28:11 millert Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.42 2002/02/16 21:28:11 millert Exp $";
d580 1
a580 1
 * no binding	timeout		broadcast 		no binding	5 sec
d1022 1
a1022 1
	
@


1.42
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.41 2001/12/29 00:50:29 deraadt Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.41 2001/12/29 00:50:29 deraadt Exp $";
d285 1
a285 1
	register SVCXPRT *transp;
@


1.41
log
@forgotten xid setting for additional domains; gregs@@agilestorage.com, pr 2282
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.40 2001/11/05 00:08:34 deraadt Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.40 2001/11/05 00:08:34 deraadt Exp $";
d96 8
a103 8
void rpc_received __P((char *dom, struct sockaddr_in *raddrp, int force));
void checkwork __P((void));
enum clnt_stat handle_replies __P((void));
enum clnt_stat handle_ping __P((void));
int broadcast __P((struct _dom_binding *ypdb, char *, int));
int direct __P((struct _dom_binding *ypdb, char *, int));
int ping __P((struct _dom_binding *ypdb));
int pings __P((struct _dom_binding *ypdb));
d124 2
a125 2
struct _dom_binding *xid2ypdb __P((u_int32_t xid));
u_int32_t unique_xid __P((struct _dom_binding *ypdb));
@


1.40
log
@remove extra sys/signal.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.39 2001/07/27 20:34:36 pvalchev Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.39 2001/07/27 20:34:36 pvalchev Exp $";
d995 1
@


1.39
log
@Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.38 2000/04/11 11:52:55 itojun Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.38 2000/04/11 11:52:55 itojun Exp $";
a43 1
#include <sys/signal.h>
@


1.38
log
@avoid complex alignment constraint in SIOCGIFCONF,
by using getifaddrs(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.37 1999/02/16 05:54:08 deraadt Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.37 1999/02/16 05:54:08 deraadt Exp $";
a753 1
	int i, sock, len, inlen = 8192;
@


1.37
log
@handle sa_len being 0 in SIOCGIFCONF
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.36 1998/08/15 17:24:17 deraadt Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.36 1998/08/15 17:24:17 deraadt Exp $";
d70 1
d753 1
a753 1
	char *inbuf = NULL, *ninbuf;
a755 2
	struct ifconf ifc;
	struct ifreq ifreq, *ifr;
d763 2
a764 3
	/* find all networks and send the RPC packet out them all */
	if ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
		perror("socket");
d767 2
a768 35
	
	while (1) {
		ifc.ifc_len = inlen;
		ninbuf = realloc(inbuf, inlen);
		if (ninbuf == NULL) {
			if (inbuf)
				free(inbuf);
			close(sock);
			return (-1);
		}
		ifc.ifc_buf = inbuf = ninbuf;
		if (ioctl(sock, SIOCGIFCONF, (char *)&ifc) < 0) {
			(void) close(sock);
			free(inbuf);
			perror("ioctl(SIOCGIFCONF)");
			return (-1);
		}
		if (ifc.ifc_len + sizeof(ifreq) < inlen)
			break;
		inlen *= 2;
	}

	ifr = ifc.ifc_req;
	ifreq.ifr_name[0] = '\0';
	for (i = 0; i < ifc.ifc_len; i += len,
	    ifr = (struct ifreq *)((caddr_t)ifr + len)) {
#if defined(BSD) && BSD >= 199103
		len = sizeof(ifr->ifr_name) +
		    (ifr->ifr_addr.sa_len > sizeof(struct sockaddr) ?
		    ifr->ifr_addr.sa_len : sizeof(struct sockaddr));
#else
		len = sizeof ifc.ifc_len / sizeof(struct ifreq);
#endif
		ifreq = *ifr;
		if (ifreq.ifr_addr.sa_family != AF_INET)
d770 1
a770 5
		if (ioctl(sock, SIOCGIFFLAGS, &ifreq) < 0) {
			perror("ioctl(SIOCGIFFLAGS)");
			continue;
		}
		if ((ifreq.ifr_flags & IFF_UP) == 0)
d773 3
a775 5
		ifreq.ifr_flags &= (IFF_LOOPBACK | IFF_BROADCAST);
		if (ifreq.ifr_flags == IFF_BROADCAST) {
			ifreq.ifr_addr = ifr->ifr_addr;
			if (ioctl(sock, SIOCGIFBRDADDR, &ifreq) < 0) {
				perror("ioctl(SIOCGIFBRDADDR)");
d777 1
a777 5
			}
		} else if (ifreq.ifr_flags == IFF_LOOPBACK) {
			ifreq.ifr_addr = ifr->ifr_addr;
			if (ioctl(sock, SIOCGIFADDR, &ifreq) < 0) {
				perror("ioctl(SIOCGIFADDR)");
d779 6
a784 2
			}
		} else
d786 1
a787 1
		in = ((struct sockaddr_in *)&ifreq.ifr_addr)->sin_addr;
d790 1
a790 1
		    sizeof bindsin) < 0)
d793 1
a793 2
	close(sock);
	free(inbuf);
@


1.36
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.35 1998/08/15 17:23:27 deraadt Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.35 1998/08/15 17:23:27 deraadt Exp $";
d796 3
a798 1
		len = sizeof ifr->ifr_name + ifr->ifr_addr.sa_len;
@


1.35
log
@realloc misuse
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.34 1998/03/23 06:18:38 deraadt Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.34 1998/03/23 06:18:38 deraadt Exp $";
d779 1
a779 1
		inbuf = ninbuf;
@


1.34
log
@update copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.33 1998/03/20 03:16:15 angelos Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.33 1998/03/20 03:16:15 angelos Exp $";
d752 1
a752 1
	char *inbuf = NULL;
d772 4
a775 2
		ifc.ifc_buf = inbuf = realloc(inbuf, inlen);
		if (inbuf == NULL) {
d779 1
@


1.33
log
@Ifaliases.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.32 1998/02/07 18:51:48 deraadt Exp $ */
d4 1
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.32 1998/02/07 18:51:48 deraadt Exp $";
@


1.32
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.31 1998/02/07 02:40:38 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.31 1998/02/07 02:40:38 deraadt Exp $";
d808 1
d814 1
@


1.31
log
@snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.30 1998/02/07 02:34:19 downsj Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.30 1998/02/07 02:34:19 downsj Exp $";
d189 1
a189 1
		snprintf(ypdb->dom_servlist, sizeof, ypdb->dom_servlist,
@


1.30
log
@Add missing code to make /etc/yp/<domain> files actually work (in all cases).
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.29 1997/06/18 23:50:12 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.29 1997/06/18 23:50:12 deraadt Exp $";
d186 1
a186 1
		sprintf(path, "%s/%s.%d", BINDINGDIR,
d189 2
a190 2
		sprintf(ypdb->dom_servlist, "%s/%s",
		    SERVERSDIR, ypdb->dom_domain);
d521 2
a522 2
	sprintf(ypbindlist->dom_servlist, "%s/%s",
	    SERVERSDIR, ypbindlist->dom_domain);
d527 1
a527 1
	sprintf(path, "%s/%s.%d", BINDINGDIR,
d720 1
a720 1
		sprintf(path, "%s/%s.%d", BINDINGDIR,
d1067 1
a1067 1
	sprintf(path, "%s/%s.%d", BINDINGDIR,
@


1.29
log
@add -insecure flag for binding to non-reserved ypservs; problem from pjt@@bsd1.phxlab.allied.com; PR#232
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.28 1997/06/14 07:12:14 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.28 1997/06/14 07:12:14 deraadt Exp $";
d521 3
@


1.28
log
@i have made a mistake, and i do not yet understand how
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.26 1997/06/11 23:16:33 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.26 1997/06/11 23:16:33 deraadt Exp $";
d113 1
d346 1
a346 1
	fprintf(stderr, "usage: ypbind [-ypset] [-ypsetme]\n");
d372 3
a374 1
		if (!strcmp("-ypset", *argv))
d1033 1
a1033 1
	if (ntohs(raddrp->sin_port) >= IPPORT_RESERVED)
@


1.27
log
@if >100 doms requested, start killing old ones to avoid starvation problems
@
text
@a81 1
	time_t dom_first_t;
d168 2
a169 15
	if (count >= 100) {
		struct _dom_binding *ypdbo = NULL;
		
		/* OK, find an old inactive domain, and kill it */
		for (ypdb = ypbindlist; ypdb; ypdbo = ypdb, ypdb = ypdb->dom_pnext)
			if (ypdb->dom_alive == 0 && 
			    ypdb->dom_first_t + 120 < time(NULL)) {
				if (ypdb == ypbindlist)
					ypbindlist = ypdb->dom_pnext;
				else
					ypdbo->dom_pnext = ypdb->dom_pnext;
				free(ypdb);
				break;
			}
	}
@


1.26
log
@malloc checks. prevent starvation for > 100 active domain queries.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.25 1997/05/06 18:41:11 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.25 1997/05/06 18:41:11 deraadt Exp $";
d82 1
d169 15
a183 2
	if (count >= 100)
		return NULL;	/* prevent DOS: sorry, you lose */
@


1.25
log
@fcntl right
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.24 1997/04/02 08:24:48 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.24 1997/04/02 08:24:48 deraadt Exp $";
d158 1
d163 1
a163 1
	memset(&res, 0, sizeof res);
d166 5
d177 2
d512 2
d1019 2
@


1.24
log
@xid is a u_int32_t
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.23 1997/03/29 06:13:21 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.23 1997/03/29 06:13:21 deraadt Exp $";
d488 1
a488 1
	fcntl(pingsock, F_SETFL, fcntl(rpcsock, F_GETFL, 0) | FNDELAY);
@


1.23
log
@re-init width each time through the loop
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.22 1997/03/26 05:23:57 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.22 1997/03/26 05:23:57 deraadt Exp $";
d81 1
a81 1
	long int dom_vers;
d86 1
a86 1
	int dom_xid;
d122 2
a123 2
struct _dom_binding *xid2ypdb __P((int xid));
int unique_xid __P((struct _dom_binding *ypdb));
d1098 1
a1098 1
	int xid;
d1108 1
a1108 1
int
d1112 1
a1112 1
	int xid;
@


1.22
log
@correct a typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.21 1997/03/25 23:08:57 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.21 1997/03/25 23:08:57 deraadt Exp $";
a516 7
	width = svc_maxfd;
	if (rpcsock > width)
		width = rpcsock;
	if (pingsock > width)
		width = pingsock;
	width++;

d521 8
@


1.21
log
@careful with name lengths and the xid
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.20 1997/02/01 00:26:04 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.20 1997/02/01 00:26:04 deraadt Exp $";
d506 1
a506 1
	ypbindlist->dom_domain[sizeof ypbindlist->dom_domain)-1] = '\0';
d1010 1
a1010 1
		ypdb->dom_domain[sizeof ypdb->dom_domain)-1] = '\0';
@


1.20
log
@randomize xid mode
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.19 1997/01/30 18:26:55 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.19 1997/01/30 18:26:55 deraadt Exp $";
d172 2
a173 1
		strncpy(ypdb->dom_domain, *argp, sizeof ypdb->dom_domain);
d505 2
a506 1
	strncpy(ypbindlist->dom_domain, domain, sizeof ypbindlist->dom_domain);
d510 1
d1009 2
a1010 1
		strncpy(ypdb->dom_domain, dom, sizeof ypdb->dom_domain);
@


1.19
log
@avoid being too paranoid... make it work!
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.18 1997/01/30 07:47:29 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.18 1997/01/30 07:47:29 deraadt Exp $";
d1109 1
a1109 1
	xid = (int)ypdb;		/* XXX: & 0xffffffff; */
@


1.18
log
@if at first-request-for-a-domain we discover a file /etc/yp/$domainneme
to exist, use it as a list of valid servers instead of doing broadcasts.
However, do not change the semantics of -ypset or -ypsetme. Based on the
reasoning provided in netbsd pr#1759, lukem@@supp.cpr.itg.telecom.com.au
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.17 1997/01/30 06:03:08 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.17 1997/01/30 06:03:08 deraadt Exp $";
d159 1
a159 1
	if (strchr((char *)argp, '/') || strchr((char *)argp, '.'))
d498 1
a498 1
	if (strchr(domain, '/') || strchr(domain, '.'))
d987 1
a987 1
	if (strchr(dom, '/') || strchr(dom, '.'))
@


1.17
log
@no need to recalc width before each select
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.16 1997/01/30 02:01:54 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.16 1997/01/30 02:01:54 deraadt Exp $";
d66 1
d70 1
d87 2
d99 2
a100 1
int broadcast __P((struct _dom_binding *ypdb));
d102 1
d159 3
d176 2
a177 2
		sprintf(path, "%s/%s.%d", BINDINGDIR, ypdb->dom_domain,
		    (int)ypdb->dom_vers);
d179 3
d498 3
d508 2
a509 2
	sprintf(path, "%s/%s.%d", BINDINGDIR, ypbindlist->dom_domain,
	    (int)ypbindlist->dom_vers);
d577 1
a577 1
				broadcast(ypdb);
d644 1
a644 1
broadcast(ypdb)
d649 2
a650 1
	char buf[1400], *inbuf = NULL;
d653 1
a653 5
	int outlen, i, sock, len, inlen = 8192;
	struct sockaddr_in bindsin;
	struct ifconf ifc;
	struct ifreq ifreq, *ifr;
	struct in_addr in;
d700 2
a701 2
		sprintf(path, "%s/%s.%d", BINDINGDIR, ypdb->dom_domain,
		    (int)ypdb->dom_vers);
a704 5
	memset(&bindsin, 0, sizeof bindsin);
	bindsin.sin_family = AF_INET;
	bindsin.sin_len = sizeof(bindsin);
	bindsin.sin_port = htons(PMAPPORT);

d711 4
d720 23
d808 61
@


1.16
log
@i wish i tested before every commit
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.15 1997/01/30 02:00:26 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.15 1997/01/30 02:00:26 deraadt Exp $";
d499 7
a506 7
		width = svc_maxfd;
		if (rpcsock > width)
			width = rpcsock;
		if (pingsock > width)
			width = pingsock;
		width++;

@


1.15
log
@domainname care
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.14 1997/01/22 08:54:14 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.14 1997/01/22 08:54:14 deraadt Exp $";
d892 1
a892 1
	if (strchr(dom, "/") || strchr(dom, ".")
@


1.14
log
@SIOCGIFCONF more carefully
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.13 1996/12/21 05:52:31 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.13 1996/12/21 05:52:31 deraadt Exp $";
d891 3
@


1.13
log
@failures bomb, not seize
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.12 1996/08/28 23:10:06 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.12 1996/08/28 23:10:06 deraadt Exp $";
d634 1
a634 1
	char buf[1400], inbuf[8192];
d637 1
a637 1
	int outlen, i, sock, len;
d715 16
a730 6
	ifc.ifc_len = sizeof inbuf;
	ifc.ifc_buf = inbuf;
	if (ioctl(sock, SIOCGIFCONF, &ifc) < 0) {
		close(sock);
		perror("ioctl(SIOCGIFCONF)");
		return -1;
d732 1
d773 1
@


1.12
log
@fix warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.11 1996/07/25 21:42:45 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.11 1996/07/25 21:42:45 deraadt Exp $";
d237 1
a237 1
		return (bool_t *)NULL;
@


1.11
log
@rmtcr_outval used by xdr_bool, so must be bool_t
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.10 1996/07/05 21:14:29 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.10 1996/07/05 21:14:29 deraadt Exp $";
d45 1
d91 7
d168 1
a168 1
		    ypdb->dom_vers);
a196 1
answer:
d361 1
a361 1
		while (dent = readdir(dirp)) {
d494 1
a494 1
	    ypbindlist->dom_vers);
d550 1
d570 1
d628 1
d689 1
a689 1
		    ypdb->dom_vers);
d765 1
a765 1
/*enum clnt_stat*/
d815 1
a815 1
/*enum clnt_stat*/
d868 1
d935 1
a935 1
	    ypdb->dom_domain, ypdb->dom_vers);
@


1.10
log
@commit check finish after work done
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.9 1996/07/01 00:49:56 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.9 1996/07/01 00:49:56 deraadt Exp $";
d103 1
a103 1
char rmtcr_outval;
@


1.9
log
@bind to localhost for ypsetme
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.8 1996/06/10 05:48:51 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.8 1996/06/10 05:48:51 deraadt Exp $";
a547 2
	check = 0;

d559 1
@


1.8
log
@even closer to the yp.x file
@
text
@d1 1
a1 1
/*	$OpenBSD: ypbind.c,v 1.7 1996/06/08 08:24:51 deraadt Exp $ */
d4 2
a5 1
 * Copyright (c) 1992, 1993, 1996 Theo de Raadt <deraadt@@theos.com>
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.7 1996/06/08 08:24:51 deraadt Exp $";
d106 1
d219 4
d321 1
d327 1
d330 2
a331 2
	int width, lockfd;
	int evil = 0, one;
d410 48
d466 1
a466 1
	
a468 1
	one = 1;
d857 1
a857 1
 * LOOPBACK IS MORE IMPORTANT: PUT IN HACK
@


1.7
log
@mod headers
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d36 1
a36 1
static char rcsid[] = "$OpenBSD: ypbind.c,v 1.6 1996/05/24 11:43:36 deraadt Exp $";
d252 1
a252 1
		char ypbindproc_domain_2_arg[MAXHOSTNAMELEN];
@


1.6
log
@duh, duh, duh
@
text
@d1 2
d36 1
a36 1
static char rcsid[] = "$Id: ypbind.c,v 1.5 1996/05/14 18:53:38 deraadt Exp $";
@


1.5
log
@require ypserv to be on reserved port
@
text
@d34 1
a34 1
static char rcsid[] = "$Id: ypbind.c,v 1.4 1996/05/05 12:37:32 deraadt Exp $";
d836 1
a836 1
	if (ntohs(raddrp->sin_port) < IPPORT_RESERVED)
@


1.4
log
@ypbind will create /var/yp/binding automatically, prints a warning.
@
text
@d34 1
a34 1
static char rcsid[] = "$Id: ypbind.c,v 1.3 1996/04/24 21:44:45 deraadt Exp $";
d834 4
@


1.3
log
@uniquify xids; spell my name & address correctly; use yp.h instead of
yp_prot.h and deal with subsequent structure element name and type changes;
deal with xdr_domainname() and friends changing types; rename service
functions to *_2x() since they have non-standard calling interfaces; add
usage(); flush /var/yp/binding/ directory at startup; prefer talking to
a ypserv on the localhost
@
text
@d34 1
a34 1
static char rcsid[] = "$Id: ypbind.c,v 1.2 1995/10/18 10:58:58 deraadt Exp $";
d353 5
@


1.2
log
@stop doing ptr<-->xid conversions
@
text
@d2 1
a2 1
 * Copyright (c) 1992, 1993 Theo de Raadt <deraadt@@fsa.ca>
d34 1
a34 1
static char rcsid[] = "$Id: ypbind.c,v 1.18 1995/01/15 09:09:30 mycroft Exp $";
d53 1
d62 1
a62 1
#include <rpcsvc/yp_prot.h>
d87 1
a87 1
char *domainname;
d104 14
d119 1
a119 1
ypbindproc_null_2(transp, argp, clnt)
d131 1
a131 1
ypbindproc_domain_2(transp, argp, clnt)
d133 1
a133 1
	char *argp;
d145 1
a145 1
		if (!strcmp(ypdb->dom_domain, argp))
d151 1
a151 1
		strncpy(ypdb->dom_domain, argp, sizeof ypdb->dom_domain);
d155 2
a156 1
		sprintf(path, "%s/%s.%d", BINDINGDIR, ypdb->dom_domain, ypdb->dom_vers);
d158 1
d187 11
a197 7
	res.ypbind_respbody.ypbind_bindinfo.ypbind_binding_addr.s_addr =
		ypdb->dom_server_addr.sin_addr.s_addr;
	res.ypbind_respbody.ypbind_bindinfo.ypbind_binding_port =
		ypdb->dom_server_port;
	/*printf("domain %s at %s/%d\n", ypdb->dom_domain,
		inet_ntoa(ypdb->dom_server_addr.sin_addr),
		ntohs(ypdb->dom_server_addr.sin_port));*/
d202 1
a202 1
ypbindproc_setdom_2(transp, argp, clnt)
d234 4
a237 2
	bindsin.sin_addr = argp->ypsetdom_addr;
	bindsin.sin_port = argp->ypsetdom_port;
d262 1
a262 1
		local = (char *(*)()) ypbindproc_null_2;
d268 1
a268 1
		local = (char *(*)()) ypbindproc_domain_2;
d287 1
a287 1
		local = (char *(*)()) ypbindproc_setdom_2;
d306 7
d322 2
d325 2
a326 2
	yp_get_default_domain(&domainname);
	if (domainname[0] == '\0') {
d337 2
d342 12
d356 2
a357 1
	if ((lockfd = open(YPBINDLOCK, O_CREAT|O_SHLOCK|O_RDWR|O_TRUNC, 0644)) == -1) {
d378 2
a379 1
		fprintf(stderr, "unable to register (YPBINDPROG, YPBINDVERS, udp).");
d390 2
a391 1
		fprintf(stderr, "unable to register (YPBINDPROG, YPBINDVERS, tcp).");
d420 1
a420 1
	strncpy(ypbindlist->dom_domain, domainname, sizeof ypbindlist->dom_domain);
d425 1
a425 1
		ypbindlist->dom_vers);
d462 1
d467 1
d504 1
a504 1
	char *dom = ypdb->dom_domain;
d528 1
a528 1
	msg.rm_xid = ypdb->dom_xid = ypdb2xid(ypdb);
d535 1
a535 1
	if (!xdr_domainname(&xdr, dom)) {
d551 2
a552 2
		   (struct sockaddr *)&ypdb->dom_server_addr,
		   sizeof ypdb->dom_server_addr) < 0)
a557 22
int
ypdb2xid(ypdb)
	struct _dom_binding *ypdb;
{
	int xid;

	xid = (int)ypdb;		/* XXX: & 0xffffffff; */
	return (xid);
}

struct _dom_binding *
xid2ypdb(xid)
	int xid;
{
	struct _dom_binding *ypdb;

	for (ypdb = ypbindlist; ypdb; ypdb = ypdb->dom_pnext)
		if (ypdb->dom_xid == xid)
			break;
	return (ypdb);
}

d561 1
a561 1
	char *dom = ypdb->dom_domain;
d575 1
a575 1
	rmtca.args_ptr = dom;
d593 1
a593 1
	msg.rm_xid = ypdb->dom_xid = ypdb2xid(ypdb);
d617 2
a618 2
		sprintf(path, "%s/%s.%d", BINDINGDIR,
			ypdb->dom_domain, ypdb->dom_vers);
d635 1
a635 1
			   sizeof bindsin) < 0)
d653 2
a654 1
	for (i = 0; i < ifc.ifc_len; i += len, ifr = (struct ifreq *)((caddr_t)ifr + len)) {
d687 1
a687 1
			   sizeof bindsin) < 0)
d714 1
a714 1
		(struct sockaddr *)&raddr, &fromlen);
d765 1
a765 1
		(struct sockaddr *)&raddr, &fromlen);
d808 3
a810 1
	/*printf("returned from %s about %s\n", inet_ntoa(raddrp->sin_addr), dom);*/
d833 1
a833 1
			    sizeof ypdb->dom_server_addr)) {
d835 10
a844 1
			ypdb->dom_check_t = time(NULL) + 60; /* recheck binding in 60 sec */
d850 2
a851 1
	ypdb->dom_check_t = time(NULL) + 60;	/* recheck binding in 60 seconds */
d859 1
a859 1
		ypdb->dom_domain, ypdb->dom_vers);
d863 2
a864 1
		if ((fd = open(path, O_CREAT|O_SHLOCK|O_RDWR|O_TRUNC, 0644)) == -1)
d889 6
a894 2
	ybr.ypbind_respbody.ypbind_bindinfo.ypbind_binding_addr = raddrp->sin_addr;
	ybr.ypbind_respbody.ypbind_bindinfo.ypbind_binding_port = raddrp->sin_port;
d903 25
@


1.1
log
@Initial revision
@
text
@d34 1
a34 1
static char rcsid[] = "$Id: ypbind.c,v 1.19 1995/04/21 04:40:36 cgd Exp $";
d79 1
d477 1
a477 1
	msg.rm_xid = (long)dom;
d507 22
d564 1
a564 1
	msg.rm_xid = (long)dom;
d669 1
d702 3
a704 1
			rpc_received(msg.rm_xid, &raddr, 0);
d719 1
d752 3
a754 1
			rpc_received(msg.rm_xid, &raddr, 0);
a777 2
	/* XXX XXX USING POINTERS OVER THE NET LIKE THIS IS TOTALLY WRONG. */

a778 5

#ifdef __alpha__						/* XXX XXX */
	/* you _REALLY_ do not want to know... */		/* XXX XXX */
	dom = (char *)((u_long)dom | (u_long)0x100000000);	/* XXX XXX */
#endif								/* XXX XXX */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

