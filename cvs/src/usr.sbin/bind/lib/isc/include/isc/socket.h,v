head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.36
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.38
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.34
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.30
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.32
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.24
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.28
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.26
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.22
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.20
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.18
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.16
	OPENBSD_5_0:1.5.0.14
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.12
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.10
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.6
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.8
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.4
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	BIND_9_4_2_P1:1.1.1.3
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	BIND_9_4_2:1.1.1.3
	OPENBSD_4_2:1.3.0.12
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.10
	OPENBSD_4_1_BASE:1.3
	BIND_9_3_4:1.1.1.2
	BIND_9_3_3:1.1.1.2
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	BIND_9_3_2:1.1.1.2
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2008.08.04.16.34.20;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.09.13.39.44;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.28.17.14.07;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.12.18.40.15;	author canacar;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.07.38;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.38;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.44;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.09.12.34.13;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to BIND 9.4.2-P2 and adapt our dynamic select changes.  OK deraadt@@
@
text
@/*
 * Copyright (C) 2004-2006, 2008  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1998-2002  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: socket.h,v 1.57.18.6.46.4 2008/07/23 23:16:43 marka Exp $ */

#ifndef ISC_SOCKET_H
#define ISC_SOCKET_H 1

/*****
 ***** Module Info
 *****/

/*! \file
 * \brief Provides TCP and UDP sockets for network I/O.  The sockets are event
 * sources in the task system.
 *
 * When I/O completes, a completion event for the socket is posted to the
 * event queue of the task which requested the I/O.
 *
 * \li MP:
 *	The module ensures appropriate synchronization of data structures it
 *	creates and manipulates.
 *	Clients of this module must not be holding a socket's task's lock when
 *	making a call that affects that socket.  Failure to follow this rule
 *	can result in deadlock.
 *	The caller must ensure that isc_socketmgr_destroy() is called only
 *	once for a given manager.
 *
 * \li Reliability:
 *	No anticipated impact.
 *
 * \li Resources:
 *	TBS
 *
 * \li Security:
 *	No anticipated impact.
 *
 * \li Standards:
 *	None.
 */

/***
 *** Imports
 ***/

#include <isc/lang.h>
#include <isc/types.h>
#include <isc/event.h>
#include <isc/eventclass.h>
#include <isc/time.h>
#include <isc/region.h>
#include <isc/sockaddr.h>

ISC_LANG_BEGINDECLS

/***
 *** Constants
 ***/

/*%
 * Maximum number of buffers in a scatter/gather read/write.  The operating
 * system in use must support at least this number (plus one on some.)
 */
#define ISC_SOCKET_MAXSCATTERGATHER	8

/*%
 * In isc_socket_bind() set socket option SO_REUSEADDR prior to calling
 * bind() if a non zero port is specified (AF_INET and AF_INET6).
 */
#define ISC_SOCKET_REUSEADDRESS		0x01U

/***
 *** Types
 ***/

struct isc_socketevent {
	ISC_EVENT_COMMON(isc_socketevent_t);
	isc_result_t		result;		/*%< OK, EOF, whatever else */
	unsigned int		minimum;	/*%< minimum i/o for event */
	unsigned int		n;		/*%< bytes read or written */
	unsigned int		offset;		/*%< offset into buffer list */
	isc_region_t		region;		/*%< for single-buffer i/o */
	isc_bufferlist_t	bufferlist;	/*%< list of buffers */
	isc_sockaddr_t		address;	/*%< source address */
	isc_time_t		timestamp;	/*%< timestamp of packet recv */
	struct in6_pktinfo	pktinfo;	/*%< ipv6 pktinfo */
	isc_uint32_t		attributes;	/*%< see below */
	isc_eventdestructor_t   destroy;	/*%< original destructor */
};

typedef struct isc_socket_newconnev isc_socket_newconnev_t;
struct isc_socket_newconnev {
	ISC_EVENT_COMMON(isc_socket_newconnev_t);
	isc_socket_t *		newsocket;
	isc_result_t		result;		/*%< OK, EOF, whatever else */
	isc_sockaddr_t		address;	/*%< source address */
};

typedef struct isc_socket_connev isc_socket_connev_t;
struct isc_socket_connev {
	ISC_EVENT_COMMON(isc_socket_connev_t);
	isc_result_t		result;		/*%< OK, EOF, whatever else */
};

/*@@{*/
/*!
 * _ATTACHED:	Internal use only.
 * _TRUNC:	Packet was truncated on receive.
 * _CTRUNC:	Packet control information was truncated.  This can
 *		indicate that the packet is not complete, even though
 *		all the data is valid.
 * _TIMESTAMP:	The timestamp member is valid.
 * _PKTINFO:	The pktinfo member is valid.
 * _MULTICAST:	The UDP packet was received via a multicast transmission.
 */
#define ISC_SOCKEVENTATTR_ATTACHED		0x80000000U /* internal */
#define ISC_SOCKEVENTATTR_TRUNC			0x00800000U /* public */
#define ISC_SOCKEVENTATTR_CTRUNC		0x00400000U /* public */
#define ISC_SOCKEVENTATTR_TIMESTAMP		0x00200000U /* public */
#define ISC_SOCKEVENTATTR_PKTINFO		0x00100000U /* public */
#define ISC_SOCKEVENTATTR_MULTICAST		0x00080000U /* public */
/*@@}*/

#define ISC_SOCKEVENT_ANYEVENT  (0)
#define ISC_SOCKEVENT_RECVDONE	(ISC_EVENTCLASS_SOCKET + 1)
#define ISC_SOCKEVENT_SENDDONE	(ISC_EVENTCLASS_SOCKET + 2)
#define ISC_SOCKEVENT_NEWCONN	(ISC_EVENTCLASS_SOCKET + 3)
#define ISC_SOCKEVENT_CONNECT	(ISC_EVENTCLASS_SOCKET + 4)

/*
 * Internal events.
 */
#define ISC_SOCKEVENT_INTR	(ISC_EVENTCLASS_SOCKET + 256)
#define ISC_SOCKEVENT_INTW	(ISC_EVENTCLASS_SOCKET + 257)

typedef enum {
	isc_sockettype_udp = 1,
	isc_sockettype_tcp = 2,
	isc_sockettype_unix = 3
} isc_sockettype_t;

/*@@{*/
/*!
 * How a socket should be shutdown in isc_socket_shutdown() calls.
 */
#define ISC_SOCKSHUT_RECV	0x00000001	/*%< close read side */
#define ISC_SOCKSHUT_SEND	0x00000002	/*%< close write side */
#define ISC_SOCKSHUT_ALL	0x00000003	/*%< close them all */
/*@@}*/

/*@@{*/
/*!
 * What I/O events to cancel in isc_socket_cancel() calls.
 */
#define ISC_SOCKCANCEL_RECV	0x00000001	/*%< cancel recv */
#define ISC_SOCKCANCEL_SEND	0x00000002	/*%< cancel send */
#define ISC_SOCKCANCEL_ACCEPT	0x00000004	/*%< cancel accept */
#define ISC_SOCKCANCEL_CONNECT	0x00000008	/*%< cancel connect */
#define ISC_SOCKCANCEL_ALL	0x0000000f	/*%< cancel everything */
/*@@}*/

/*@@{*/
/*!
 * Flags for isc_socket_send() and isc_socket_recv() calls.
 */
#define ISC_SOCKFLAG_IMMEDIATE	0x00000001	/*%< send event only if needed */
#define ISC_SOCKFLAG_NORETRY	0x00000002	/*%< drop failed UDP sends */
/*@@}*/

/***
 *** Socket and Socket Manager Functions
 ***
 *** Note: all Ensures conditions apply only if the result is success for
 *** those functions which return an isc_result.
 ***/

isc_result_t
isc_socket_create(isc_socketmgr_t *manager,
		  int pf,
		  isc_sockettype_t type,
		  isc_socket_t **socketp);
/*%<
 * Create a new 'type' socket managed by 'manager'.
 *
 * Note:
 *
 *\li	'pf' is the desired protocol family, e.g. PF_INET or PF_INET6.
 *
 * Requires:
 *
 *\li	'manager' is a valid manager
 *
 *\li	'socketp' is a valid pointer, and *socketp == NULL
 *
 * Ensures:
 *
 *	'*socketp' is attached to the newly created socket
 *
 * Returns:
 *
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_NORESOURCES
 *\li	#ISC_R_UNEXPECTED
 */

void
isc_socket_cancel(isc_socket_t *sock, isc_task_t *task,
		  unsigned int how);
/*%<
 * Cancel pending I/O of the type specified by "how".
 *
 * Note: if "task" is NULL, then the cancel applies to all tasks using the
 * socket.
 *
 * Requires:
 *
 * \li	"socket" is a valid socket
 *
 * \li	"task" is NULL or a valid task
 *
 * "how" is a bitmask describing the type of cancelation to perform.
 * The type ISC_SOCKCANCEL_ALL will cancel all pending I/O on this
 * socket.
 *
 * \li ISC_SOCKCANCEL_RECV:
 *	Cancel pending isc_socket_recv() calls.
 *
 * \li ISC_SOCKCANCEL_SEND:
 *	Cancel pending isc_socket_send() and isc_socket_sendto() calls.
 *
 * \li ISC_SOCKCANCEL_ACCEPT:
 *	Cancel pending isc_socket_accept() calls.
 *
 * \li ISC_SOCKCANCEL_CONNECT:
 *	Cancel pending isc_socket_connect() call.
 */

void
isc_socket_shutdown(isc_socket_t *sock, unsigned int how);
/*%<
 * Shutdown 'socket' according to 'how'.
 *
 * Requires:
 *
 * \li	'socket' is a valid socket.
 *
 * \li	'task' is NULL or is a valid task.
 *
 * \li	If 'how' is 'ISC_SOCKSHUT_RECV' or 'ISC_SOCKSHUT_ALL' then
 *
 *		The read queue must be empty.
 *
 *		No further read requests may be made.
 *
 * \li	If 'how' is 'ISC_SOCKSHUT_SEND' or 'ISC_SOCKSHUT_ALL' then
 *
 *		The write queue must be empty.
 *
 *		No further write requests may be made.
 */

void
isc_socket_attach(isc_socket_t *sock, isc_socket_t **socketp);
/*%<
 * Attach *socketp to socket.
 *
 * Requires:
 *
 * \li	'socket' is a valid socket.
 *
 * \li	'socketp' points to a NULL socket.
 *
 * Ensures:
 *
 * \li	*socketp is attached to socket.
 */

void
isc_socket_detach(isc_socket_t **socketp);
/*%<
 * Detach *socketp from its socket.
 *
 * Requires:
 *
 * \li	'socketp' points to a valid socket.
 *
 * \li	If '*socketp' is the last reference to the socket,
 *	then:
 *
 *		There must be no pending I/O requests.
 *
 * Ensures:
 *
 * \li	*socketp is NULL.
 *
 * \li	If '*socketp' is the last reference to the socket,
 *	then:
 *
 *		The socket will be shutdown (both reading and writing)
 *		for all tasks.
 *
 *		All resources used by the socket have been freed
 */

isc_result_t
isc_socket_bind(isc_socket_t *sock, isc_sockaddr_t *addressp,
	        unsigned int options);
/*%<
 * Bind 'socket' to '*addressp'.
 *
 * Requires:
 *
 * \li	'socket' is a valid socket
 *
 * \li	'addressp' points to a valid isc_sockaddr.
 *
 * Returns:
 *
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_NOPERM
 * \li	ISC_R_ADDRNOTAVAIL
 * \li	ISC_R_ADDRINUSE
 * \li	ISC_R_BOUND
 * \li	ISC_R_UNEXPECTED
 */

isc_result_t
isc_socket_privsep(int);

isc_result_t
isc_socket_filter(isc_socket_t *sock, const char *filter);
/*%<
 * Inform the kernel that it should perform accept filtering.
 * If filter is NULL the current filter will be removed.:w
 */

isc_result_t
isc_socket_listen(isc_socket_t *sock, unsigned int backlog);
/*%<
 * Set listen mode on the socket.  After this call, the only function that
 * can be used (other than attach and detach) is isc_socket_accept().
 *
 * Notes:
 *
 * \li	'backlog' is as in the UNIX system call listen() and may be
 *	ignored by non-UNIX implementations.
 *
 * \li	If 'backlog' is zero, a reasonable system default is used, usually
 *	SOMAXCONN.
 *
 * Requires:
 *
 * \li	'socket' is a valid, bound TCP socket or a valid, bound UNIX socket.
 *
 * Returns:
 *
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_UNEXPECTED
 */

isc_result_t
isc_socket_accept(isc_socket_t *sock,
		  isc_task_t *task, isc_taskaction_t action, const void *arg);
/*%<
 * Queue accept event.  When a new connection is received, the task will
 * get an ISC_SOCKEVENT_NEWCONN event with the sender set to the listen
 * socket.  The new socket structure is sent inside the isc_socket_newconnev_t
 * event type, and is attached to the task 'task'.
 *
 * REQUIRES:
 * \li	'socket' is a valid TCP socket that isc_socket_listen() was called
 *	on.
 *
 * \li	'task' is a valid task
 *
 * \li	'action' is a valid action
 *
 * RETURNS:
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_NOMEMORY
 * \li	ISC_R_UNEXPECTED
 */

isc_result_t
isc_socket_connect(isc_socket_t *sock, isc_sockaddr_t *addressp,
		   isc_task_t *task, isc_taskaction_t action,
		   const void *arg);
/*%<
 * Connect 'socket' to peer with address *saddr.  When the connection
 * succeeds, or when an error occurs, a CONNECT event with action 'action'
 * and arg 'arg' will be posted to the event queue for 'task'.
 *
 * Requires:
 *
 * \li	'socket' is a valid TCP socket
 *
 * \li	'addressp' points to a valid isc_sockaddr
 *
 * \li	'task' is a valid task
 *
 * \li	'action' is a valid action
 *
 * Returns:
 *
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_NOMEMORY
 * \li	ISC_R_UNEXPECTED
 *
 * Posted event's result code:
 *
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_TIMEDOUT
 * \li	ISC_R_CONNREFUSED
 * \li	ISC_R_NETUNREACH
 * \li	ISC_R_UNEXPECTED
 */

isc_result_t
isc_socket_getpeername(isc_socket_t *sock, isc_sockaddr_t *addressp);
/*%<
 * Get the name of the peer connected to 'socket'.
 *
 * Requires:
 *
 * \li	'socket' is a valid TCP socket.
 *
 * Returns:
 *
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_TOOSMALL
 * \li	ISC_R_UNEXPECTED
 */

isc_result_t
isc_socket_getsockname(isc_socket_t *sock, isc_sockaddr_t *addressp);
/*%<
 * Get the name of 'socket'.
 *
 * Requires:
 *
 * \li	'socket' is a valid socket.
 *
 * Returns:
 *
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_TOOSMALL
 * \li	ISC_R_UNEXPECTED
 */

/*@@{*/
isc_result_t
isc_socket_recv(isc_socket_t *sock, isc_region_t *region,
		unsigned int minimum,
		isc_task_t *task, isc_taskaction_t action, const void *arg);
isc_result_t
isc_socket_recvv(isc_socket_t *sock, isc_bufferlist_t *buflist,
		 unsigned int minimum,
		 isc_task_t *task, isc_taskaction_t action, const void *arg);

isc_result_t
isc_socket_recv2(isc_socket_t *sock, isc_region_t *region,
		 unsigned int minimum, isc_task_t *task,
		 isc_socketevent_t *event, unsigned int flags);

/*!
 * Receive from 'socket', storing the results in region.
 *
 * Notes:
 *
 *\li	Let 'length' refer to the length of 'region' or to the sum of all
 *	available regions in the list of buffers '*buflist'.
 *
 *\li	If 'minimum' is non-zero and at least that many bytes are read,
 *	the completion event will be posted to the task 'task.'  If minimum
 *	is zero, the exact number of bytes requested in the region must
 * 	be read for an event to be posted.  This only makes sense for TCP
 *	connections, and is always set to 1 byte for UDP.
 *
 *\li	The read will complete when the desired number of bytes have been
 *	read, if end-of-input occurs, or if an error occurs.  A read done
 *	event with the given 'action' and 'arg' will be posted to the
 *	event queue of 'task'.
 *
 *\li	The caller may not modify 'region', the buffers which are passed
 *	into this function, or any data they refer to until the completion
 *	event is received.
 *
 *\li	For isc_socket_recvv():
 *	On successful completion, '*buflist' will be empty, and the list of
 *	all buffers will be returned in the done event's 'bufferlist'
 *	member.  On error return, '*buflist' will be unchanged.
 *
 *\li	For isc_socket_recv2():
 *	'event' is not NULL, and the non-socket specific fields are
 *	expected to be initialized.
 *
 *\li	For isc_socket_recv2():
 *	The only defined value for 'flags' is ISC_SOCKFLAG_IMMEDIATE.  If
 *	set and the operation completes, the return value will be
 *	ISC_R_SUCCESS and the event will be filled in and not sent.  If the
 *	operation does not complete, the return value will be
 *	ISC_R_INPROGRESS and the event will be sent when the operation
 *	completes.
 *
 * Requires:
 *
 *\li	'socket' is a valid, bound socket.
 *
 *\li	For isc_socket_recv():
 *	'region' is a valid region
 *
 *\li	For isc_socket_recvv():
 *	'buflist' is non-NULL, and '*buflist' contain at least one buffer.
 *
 *\li	'task' is a valid task
 *
 *\li	For isc_socket_recv() and isc_socket_recvv():
 *	action != NULL and is a valid action
 *
 *\li	For isc_socket_recv2():
 *	event != NULL
 *
 * Returns:
 *
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_INPROGRESS
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_UNEXPECTED
 *
 * Event results:
 *
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_UNEXPECTED
 *\li	XXX needs other net-type errors
 */
/*@@}*/

/*@@{*/
isc_result_t
isc_socket_send(isc_socket_t *sock, isc_region_t *region,
		isc_task_t *task, isc_taskaction_t action, const void *arg);
isc_result_t
isc_socket_sendto(isc_socket_t *sock, isc_region_t *region,
		  isc_task_t *task, isc_taskaction_t action, const void *arg,
		  isc_sockaddr_t *address, struct in6_pktinfo *pktinfo);
isc_result_t
isc_socket_sendv(isc_socket_t *sock, isc_bufferlist_t *buflist,
		 isc_task_t *task, isc_taskaction_t action, const void *arg);
isc_result_t
isc_socket_sendtov(isc_socket_t *sock, isc_bufferlist_t *buflist,
		   isc_task_t *task, isc_taskaction_t action, const void *arg,
		   isc_sockaddr_t *address, struct in6_pktinfo *pktinfo);
isc_result_t
isc_socket_sendto2(isc_socket_t *sock, isc_region_t *region,
		   isc_task_t *task,
		   isc_sockaddr_t *address, struct in6_pktinfo *pktinfo,
		   isc_socketevent_t *event, unsigned int flags);

/*!
 * Send the contents of 'region' to the socket's peer.
 *
 * Notes:
 *
 *\li	Shutting down the requestor's task *may* result in any
 *	still pending writes being dropped or completed, depending on the
 *	underlying OS implementation.
 *
 *\li	If 'action' is NULL, then no completion event will be posted.
 *
 *\li	The caller may not modify 'region', the buffers which are passed
 *	into this function, or any data they refer to until the completion
 *	event is received.
 *
 *\li	For isc_socket_sendv() and isc_socket_sendtov():
 *	On successful completion, '*buflist' will be empty, and the list of
 *	all buffers will be returned in the done event's 'bufferlist'
 *	member.  On error return, '*buflist' will be unchanged.
 *
 *\li	For isc_socket_sendto2():
 *	'event' is not NULL, and the non-socket specific fields are
 *	expected to be initialized.
 *
 *\li	For isc_socket_sendto2():
 *	The only defined values for 'flags' are ISC_SOCKFLAG_IMMEDIATE
 *	and ISC_SOCKFLAG_NORETRY.
 *
 *\li	If ISC_SOCKFLAG_IMMEDIATE is set and the operation completes, the
 *	return value will be ISC_R_SUCCESS and the event will be filled
 *	in and not sent.  If the operation does not complete, the return
 *	value will be ISC_R_INPROGRESS and the event will be sent when
 *	the operation completes.
 *
 *\li	ISC_SOCKFLAG_NORETRY can only be set for UDP sockets.  If set
 *	and the send operation fails due to a transient error, the send
 *	will not be retried and the error will be indicated in the event.
 *	Using this option along with ISC_SOCKFLAG_IMMEDIATE allows the caller
 *	to specify a region that is allocated on the stack.
 *
 * Requires:
 *
 *\li	'socket' is a valid, bound socket.
 *
 *\li	For isc_socket_send():
 *	'region' is a valid region
 *
 *\li	For isc_socket_sendv() and isc_socket_sendtov():
 *	'buflist' is non-NULL, and '*buflist' contain at least one buffer.
 *
 *\li	'task' is a valid task
 *
 *\li	For isc_socket_sendv(), isc_socket_sendtov(), isc_socket_send(), and
 *	isc_socket_sendto():
 *	action == NULL or is a valid action
 *
 *\li	For isc_socket_sendto2():
 *	event != NULL
 *
 * Returns:
 *
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_INPROGRESS
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_UNEXPECTED
 *
 * Event results:
 *
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_UNEXPECTED
 *\li	XXX needs other net-type errors
 */
/*@@}*/

isc_result_t
isc_socketmgr_create(isc_mem_t *mctx, isc_socketmgr_t **managerp);
/*%<
 * Create a socket manager.
 *
 * Notes:
 *
 *\li	All memory will be allocated in memory context 'mctx'.
 *
 * Requires:
 *
 *\li	'mctx' is a valid memory context.
 *
 *\li	'managerp' points to a NULL isc_socketmgr_t.
 *
 * Ensures:
 *
 *\li	'*managerp' is a valid isc_socketmgr_t.
 *
 * Returns:
 *
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_UNEXPECTED
 */

void
isc_socketmgr_destroy(isc_socketmgr_t **managerp);
/*%<
 * Destroy a socket manager.
 *
 * Notes:
 *
 *\li	This routine blocks until there are no sockets left in the manager,
 *	so if the caller holds any socket references using the manager, it
 *	must detach them before calling isc_socketmgr_destroy() or it will
 *	block forever.
 *
 * Requires:
 *
 *\li	'*managerp' is a valid isc_socketmgr_t.
 *
 *\li	All sockets managed by this manager are fully detached.
 *
 * Ensures:
 *
 *\li	*managerp == NULL
 *
 *\li	All resources used by the manager have been freed.
 */

isc_sockettype_t
isc_socket_gettype(isc_socket_t *sock);
/*%<
 * Returns the socket type for "sock."
 *
 * Requires:
 *
 *\li	"sock" is a valid socket.
 */

/*@@{*/
isc_boolean_t
isc_socket_isbound(isc_socket_t *sock);

void
isc_socket_ipv6only(isc_socket_t *sock, isc_boolean_t yes);
/*%<
 * If the socket is an IPv6 socket set/clear the IPV6_IPV6ONLY socket
 * option if the host OS supports this option.
 *
 * Requires:
 *\li	'sock' is a valid socket.
 */
/*@@}*/

void
isc_socket_cleanunix(isc_sockaddr_t *addr, isc_boolean_t active);

/*%<
 * Cleanup UNIX domain sockets in the file-system.  If 'active' is true
 * then just unlink the socket.  If 'active' is false try to determine
 * if there is a listener of the socket or not.  If no listener is found
 * then unlink socket.
 *
 * Prior to unlinking the path is tested to see if it a socket.
 *
 * Note: there are a number of race conditions which cannot be avoided
 *       both in the filesystem and any application using UNIX domain
 *	 sockets (e.g. socket is tested between bind() and listen(),
 *	 the socket is deleted and replaced in the file-system between
 *	 stat() and unlink()).
 */

isc_result_t
isc_socket_permunix(isc_sockaddr_t *sockaddr, isc_uint32_t perm,
                    isc_uint32_t owner, isc_uint32_t group);
/*%<
 * Set ownership and file permissions on the UNIX domain socket.
 *
 * Note: On Solaris and SunOS this secures the directory containing
 *       the socket as Solaris and SunOS do not honour the filesytem
 *	 permissions on the socket.
 *
 * Requires:
 * \li	'sockaddr' to be a valid UNIX domain sockaddr.
 *
 * Returns:
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_FAILURE
 */

void
isc__socketmgr_setreserved(isc_socketmgr_t *mgr, isc_uint32_t);
/*%<
 * Temporary.  For use by named only.
 */

ISC_LANG_ENDDECLS

#endif /* ISC_SOCKET_H */
@


1.4
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
d5 1
a5 1
 * Permission to use, copy, modify, and distribute this software for any
d18 1
a18 1
/* $ISC: socket.h,v 1.57.18.6 2006/06/07 00:29:45 marka Exp $ */
d80 6
d321 2
a322 1
isc_socket_bind(isc_socket_t *sock, isc_sockaddr_t *addressp);
d758 6
@


1.3
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: socket.h,v 1.54.12.4 2004/03/08 09:04:53 marka Exp $ */
d27 2
a28 4
/*
 * Sockets
 *
 * Provides TCP and UDP sockets for network I/O.  The sockets are event
d34 1
a34 1
 * MP:
a36 1
 *
a39 1
 *
d43 1
a43 1
 * Reliability:
d46 2
a47 2
 * Resources:
 *	<TBS>
d49 1
a49 1
 * Security:
d52 1
a52 1
 * Standards:
d74 1
a74 1
/*
d86 11
a96 10
	isc_result_t		result;		/* OK, EOF, whatever else */
	unsigned int		minimum;	/* minimum i/o for event */
	unsigned int		n;		/* bytes read or written */
	unsigned int		offset;		/* offset into buffer list */
	isc_region_t		region;		/* for single-buffer i/o */
	isc_bufferlist_t	bufferlist;	/* list of buffers */
	isc_sockaddr_t		address;	/* source address */
	isc_time_t		timestamp;	/* timestamp of packet recv */
	struct in6_pktinfo	pktinfo;	/* ipv6 pktinfo */
	isc_uint32_t		attributes;	/* see below */
d103 2
a104 2
	isc_result_t		result;		/* OK, EOF, whatever else */
	isc_sockaddr_t		address;	/* source address */
d110 1
a110 1
	isc_result_t		result;		/* OK, EOF, whatever else */
d113 2
a114 1
/*
d130 1
d146 2
a147 1
	isc_sockettype_tcp = 2
d150 2
a151 1
/*
d154 4
a157 3
#define ISC_SOCKSHUT_RECV	0x00000001	/* close read side */
#define ISC_SOCKSHUT_SEND	0x00000002	/* close write side */
#define ISC_SOCKSHUT_ALL	0x00000003	/* close them all */
d159 2
a160 1
/*
d163 6
a168 5
#define ISC_SOCKCANCEL_RECV	0x00000001	/* cancel recv */
#define ISC_SOCKCANCEL_SEND	0x00000002	/* cancel send */
#define ISC_SOCKCANCEL_ACCEPT	0x00000004	/* cancel accept */
#define ISC_SOCKCANCEL_CONNECT	0x00000008	/* cancel connect */
#define ISC_SOCKCANCEL_ALL	0x0000000f	/* cancel everything */
d170 2
a171 1
/*
d174 3
a176 2
#define ISC_SOCKFLAG_IMMEDIATE	0x00000001	/* send event only if needed */
#define ISC_SOCKFLAG_NORETRY	0x00000002	/* drop failed UDP sends */
d190 1
a190 1
/*
d195 1
a195 1
 *	'pf' is the desired protocol family, e.g. PF_INET or PF_INET6.
d199 1
a199 1
 *	'manager' is a valid manager
d201 1
a201 1
 *	'socketp' is a valid pointer, and *socketp == NULL
d209 4
a212 4
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
 *	ISC_R_NORESOURCES
 *	ISC_R_UNEXPECTED
d218 1
a218 1
/*
d226 1
a226 1
 *	"socket" is a valid socket
d228 1
a228 1
 *	"task" is NULL or a valid task
d234 1
a234 1
 * ISC_SOCKCANCEL_RECV:
d237 1
a237 1
 * ISC_SOCKCANCEL_SEND:
d240 1
a240 1
 * ISC_SOCKCANCEL_ACCEPT:
d243 1
a243 1
 * ISC_SOCKCANCEL_CONNECT:
d249 1
a249 1
/*
d254 1
a254 1
 *	'socket' is a valid socket.
d256 1
a256 1
 *	'task' is NULL or is a valid task.
d258 1
a258 1
 *	If 'how' is 'ISC_SOCKSHUT_RECV' or 'ISC_SOCKSHUT_ALL' then
d264 1
a264 1
 *	If 'how' is 'ISC_SOCKSHUT_SEND' or 'ISC_SOCKSHUT_ALL' then
d273 1
a273 1
/*
d278 1
a278 1
 *	'socket' is a valid socket.
d280 1
a280 1
 *	'socketp' points to a NULL socket.
d284 1
a284 1
 *	*socketp is attached to socket.
d289 1
a289 1
/*
d294 1
a294 1
 *	'socketp' points to a valid socket.
d296 1
a296 1
 *	If '*socketp' is the last reference to the socket,
d303 1
a303 1
 *	*socketp is NULL.
d305 1
a305 1
 *	If '*socketp' is the last reference to the socket,
d316 1
a316 1
/*
d321 1
a321 1
 *	'socket' is a valid socket
d323 1
a323 1
 *	'addressp' points to a valid isc_sockaddr.
d327 6
a332 6
 *	ISC_R_SUCCESS
 *	ISC_R_NOPERM
 *	ISC_R_ADDRNOTAVAIL
 *	ISC_R_ADDRINUSE
 *	ISC_R_BOUND
 *	ISC_R_UNEXPECTED
d340 1
a340 1
/*
d347 1
a347 1
/*
d353 1
a353 1
 *	'backlog' is as in the UNIX system call listen() and may be
d356 1
a356 1
 *	If 'backlog' is zero, a reasonable system default is used, usually
d361 1
a361 1
 *	'socket' is a valid, bound TCP socket.
d365 2
a366 2
 *	ISC_R_SUCCESS
 *	ISC_R_UNEXPECTED
d372 1
a372 1
/*
d379 1
a379 1
 *	'socket' is a valid TCP socket that isc_socket_listen() was called
d382 1
a382 1
 *	'task' is a valid task
d384 1
a384 1
 *	'action' is a valid action
d387 3
a389 3
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
 *	ISC_R_UNEXPECTED
d396 1
a396 1
/*
d403 1
a403 1
 *	'socket' is a valid TCP socket
d405 1
a405 1
 *	'addressp' points to a valid isc_sockaddr
d407 1
a407 1
 *	'task' is a valid task
d409 1
a409 1
 *	'action' is a valid action
d413 3
a415 3
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
 *	ISC_R_UNEXPECTED
d419 5
a423 5
 *	ISC_R_SUCCESS
 *	ISC_R_TIMEDOUT
 *	ISC_R_CONNREFUSED
 *	ISC_R_NETUNREACH
 *	ISC_R_UNEXPECTED
d428 1
a428 1
/*
d433 1
a433 1
 *	'socket' is a valid TCP socket.
d437 3
a439 3
 *	ISC_R_SUCCESS
 *	ISC_R_TOOSMALL
 *	ISC_R_UNEXPECTED
d444 1
a444 1
/*
d449 1
a449 1
 *	'socket' is a valid socket.
d453 3
a455 3
 *	ISC_R_SUCCESS
 *	ISC_R_TOOSMALL
 *	ISC_R_UNEXPECTED
d458 1
d473 1
a473 1
/*
d478 1
a478 1
 *	Let 'length' refer to the length of 'region' or to the sum of all
d481 1
a481 1
 *	If 'minimum' is non-zero and at least that many bytes are read,
d487 1
a487 1
 *	The read will complete when the desired number of bytes have been
d492 1
a492 1
 *	The caller may not modify 'region', the buffers which are passed
d496 1
a496 1
 *	For isc_socket_recvv():
d501 1
a501 1
 *	For isc_socket_recv2():
d505 1
a505 1
 *	For isc_socket_recv2():
d515 1
a515 1
 *	'socket' is a valid, bound socket.
d517 1
a517 1
 *	For isc_socket_recv():
d520 1
a520 1
 *	For isc_socket_recvv():
d523 1
a523 1
 *	'task' is a valid task
d525 1
a525 1
 *	For isc_socket_recv() and isc_socket_recvv():
d528 1
a528 1
 *	For isc_socket_recv2():
d533 4
a536 4
 *	ISC_R_SUCCESS
 *	ISC_R_INPROGRESS
 *	ISC_R_NOMEMORY
 *	ISC_R_UNEXPECTED
d540 3
a542 3
 *	ISC_R_SUCCESS
 *	ISC_R_UNEXPECTED
 *	XXX needs other net-type errors
d544 1
d546 1
d567 1
a567 1
/*
d572 1
a572 1
 *	Shutting down the requestor's task *may* result in any
d576 1
a576 1
 *	If 'action' is NULL, then no completion event will be posted.
d578 1
a578 1
 *	The caller may not modify 'region', the buffers which are passed
d582 1
a582 1
 *	For isc_socket_sendv() and isc_socket_sendtov():
d587 1
a587 1
 *	For isc_socket_sendto2():
d591 1
a591 1
 *	For isc_socket_sendto2():
d595 1
a595 1
 *	If ISC_SOCKFLAG_IMMEDIATE is set and the operation completes, the
d601 1
a601 1
 *	ISC_SOCKFLAG_NORETRY can only be set for UDP sockets.  If set
d609 1
a609 1
 *	'socket' is a valid, bound socket.
d611 1
a611 1
 *	For isc_socket_send():
d614 1
a614 1
 *	For isc_socket_sendv() and isc_socket_sendtov():
d617 1
a617 1
 *	'task' is a valid task
d619 1
a619 1
 *	For isc_socket_sendv(), isc_socket_sendtov(), isc_socket_send(), and
d623 1
a623 1
 *	For isc_socket_sendto2():
d628 4
a631 4
 *	ISC_R_SUCCESS
 *	ISC_R_INPROGRESS
 *	ISC_R_NOMEMORY
 *	ISC_R_UNEXPECTED
d635 3
a637 3
 *	ISC_R_SUCCESS
 *	ISC_R_UNEXPECTED
 *	XXX needs other net-type errors
d639 1
d643 1
a643 1
/*
d648 1
a648 1
 *	All memory will be allocated in memory context 'mctx'.
d652 1
a652 1
 *	'mctx' is a valid memory context.
d654 1
a654 1
 *	'managerp' points to a NULL isc_socketmgr_t.
d658 1
a658 1
 *	'*managerp' is a valid isc_socketmgr_t.
d662 3
a664 3
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
 *	ISC_R_UNEXPECTED
d669 1
a669 1
/*
d674 1
a674 1
 *	This routine blocks until there are no sockets left in the manager,
d681 1
a681 1
 *	'*managerp' is a valid isc_socketmgr_t.
d683 1
a683 1
 *	All sockets managed by this manager are fully detached.
d687 1
a687 1
 *	*managerp == NULL
d689 1
a689 1
 *	All resources used by the manager have been freed.
d694 1
a694 1
/*
d699 1
a699 1
 *	"sock" is a valid socket.
d702 1
d708 1
a708 1
/*
d713 38
a750 1
 *	'sock' is a valid socket.
@


1.2
log
@Privilege seperation for named. Allows named to handle address/interface
changes without restart. If you use non-standard ports in named configuration
make sure they are > 1024. Also /var/named/etc/rndc.key (if any) must be
readable by group named.

Initial work and testing by itojun@@, jakob@@, hints, help from henning@@,
avsm@@, beck@@. ok henning, beck, avsm, deraadt
@
text
@d2 2
a3 1
 * Copyright (C) 1998-2001  Internet Software Consortium.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: socket.h,v 1.54 2001/03/06 01:23:02 bwelling Exp $ */
d331 8
d694 10
@


1.1
log
@Initial revision
@
text
@d330 2
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1998-2002  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: socket.h,v 1.54.12.4 2004/03/08 09:04:53 marka Exp $ */
a329 7
isc_socket_filter(isc_socket_t *sock, const char *filter);
/*
 * Inform the kernel that it should perform accept filtering.
 * If filter is NULL the current filter will be removed.:w
 */

isc_result_t
a683 10

void
isc_socket_ipv6only(isc_socket_t *sock, isc_boolean_t yes);
/*
 * If the socket is an IPv6 socket set/clear the IPV6_IPV6ONLY socket
 * option if the host OS supports this option.
 *
 * Requires:
 *	'sock' is a valid socket.
 */
@


1.1.1.3
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: socket.h,v 1.57.18.6 2006/06/07 00:29:45 marka Exp $ */
d27 4
a30 2
/*! \file
 * \brief Provides TCP and UDP sockets for network I/O.  The sockets are event
d36 1
a36 1
 * \li MP:
d39 1
d43 1
d47 1
a47 1
 * \li Reliability:
d50 2
a51 2
 * \li Resources:
 *	TBS
d53 1
a53 1
 * \li Security:
d56 1
a56 1
 * \li Standards:
d78 1
a78 1
/*%
d90 10
a99 11
	isc_result_t		result;		/*%< OK, EOF, whatever else */
	unsigned int		minimum;	/*%< minimum i/o for event */
	unsigned int		n;		/*%< bytes read or written */
	unsigned int		offset;		/*%< offset into buffer list */
	isc_region_t		region;		/*%< for single-buffer i/o */
	isc_bufferlist_t	bufferlist;	/*%< list of buffers */
	isc_sockaddr_t		address;	/*%< source address */
	isc_time_t		timestamp;	/*%< timestamp of packet recv */
	struct in6_pktinfo	pktinfo;	/*%< ipv6 pktinfo */
	isc_uint32_t		attributes;	/*%< see below */
	isc_eventdestructor_t   destroy;	/*%< original destructor */
d106 2
a107 2
	isc_result_t		result;		/*%< OK, EOF, whatever else */
	isc_sockaddr_t		address;	/*%< source address */
d113 1
a113 1
	isc_result_t		result;		/*%< OK, EOF, whatever else */
d116 1
a116 2
/*@@{*/
/*!
a131 1
/*@@}*/
d147 1
a147 2
	isc_sockettype_tcp = 2,
	isc_sockettype_unix = 3
d150 1
a150 2
/*@@{*/
/*!
d153 3
a155 4
#define ISC_SOCKSHUT_RECV	0x00000001	/*%< close read side */
#define ISC_SOCKSHUT_SEND	0x00000002	/*%< close write side */
#define ISC_SOCKSHUT_ALL	0x00000003	/*%< close them all */
/*@@}*/
d157 1
a157 2
/*@@{*/
/*!
d160 5
a164 6
#define ISC_SOCKCANCEL_RECV	0x00000001	/*%< cancel recv */
#define ISC_SOCKCANCEL_SEND	0x00000002	/*%< cancel send */
#define ISC_SOCKCANCEL_ACCEPT	0x00000004	/*%< cancel accept */
#define ISC_SOCKCANCEL_CONNECT	0x00000008	/*%< cancel connect */
#define ISC_SOCKCANCEL_ALL	0x0000000f	/*%< cancel everything */
/*@@}*/
d166 1
a166 2
/*@@{*/
/*!
d169 2
a170 3
#define ISC_SOCKFLAG_IMMEDIATE	0x00000001	/*%< send event only if needed */
#define ISC_SOCKFLAG_NORETRY	0x00000002	/*%< drop failed UDP sends */
/*@@}*/
d184 1
a184 1
/*%<
d189 1
a189 1
 *\li	'pf' is the desired protocol family, e.g. PF_INET or PF_INET6.
d193 1
a193 1
 *\li	'manager' is a valid manager
d195 1
a195 1
 *\li	'socketp' is a valid pointer, and *socketp == NULL
d203 4
a206 4
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_NORESOURCES
 *\li	#ISC_R_UNEXPECTED
d212 1
a212 1
/*%<
d220 1
a220 1
 * \li	"socket" is a valid socket
d222 1
a222 1
 * \li	"task" is NULL or a valid task
d228 1
a228 1
 * \li ISC_SOCKCANCEL_RECV:
d231 1
a231 1
 * \li ISC_SOCKCANCEL_SEND:
d234 1
a234 1
 * \li ISC_SOCKCANCEL_ACCEPT:
d237 1
a237 1
 * \li ISC_SOCKCANCEL_CONNECT:
d243 1
a243 1
/*%<
d248 1
a248 1
 * \li	'socket' is a valid socket.
d250 1
a250 1
 * \li	'task' is NULL or is a valid task.
d252 1
a252 1
 * \li	If 'how' is 'ISC_SOCKSHUT_RECV' or 'ISC_SOCKSHUT_ALL' then
d258 1
a258 1
 * \li	If 'how' is 'ISC_SOCKSHUT_SEND' or 'ISC_SOCKSHUT_ALL' then
d267 1
a267 1
/*%<
d272 1
a272 1
 * \li	'socket' is a valid socket.
d274 1
a274 1
 * \li	'socketp' points to a NULL socket.
d278 1
a278 1
 * \li	*socketp is attached to socket.
d283 1
a283 1
/*%<
d288 1
a288 1
 * \li	'socketp' points to a valid socket.
d290 1
a290 1
 * \li	If '*socketp' is the last reference to the socket,
d297 1
a297 1
 * \li	*socketp is NULL.
d299 1
a299 1
 * \li	If '*socketp' is the last reference to the socket,
d310 1
a310 1
/*%<
d315 1
a315 1
 * \li	'socket' is a valid socket
d317 1
a317 1
 * \li	'addressp' points to a valid isc_sockaddr.
d321 6
a326 6
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_NOPERM
 * \li	ISC_R_ADDRNOTAVAIL
 * \li	ISC_R_ADDRINUSE
 * \li	ISC_R_BOUND
 * \li	ISC_R_UNEXPECTED
d331 1
a331 1
/*%<
d338 1
a338 1
/*%<
d344 1
a344 1
 * \li	'backlog' is as in the UNIX system call listen() and may be
d347 1
a347 1
 * \li	If 'backlog' is zero, a reasonable system default is used, usually
d352 1
a352 1
 * \li	'socket' is a valid, bound TCP socket or a valid, bound UNIX socket.
d356 2
a357 2
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_UNEXPECTED
d363 1
a363 1
/*%<
d370 1
a370 1
 * \li	'socket' is a valid TCP socket that isc_socket_listen() was called
d373 1
a373 1
 * \li	'task' is a valid task
d375 1
a375 1
 * \li	'action' is a valid action
d378 3
a380 3
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_NOMEMORY
 * \li	ISC_R_UNEXPECTED
d387 1
a387 1
/*%<
d394 1
a394 1
 * \li	'socket' is a valid TCP socket
d396 1
a396 1
 * \li	'addressp' points to a valid isc_sockaddr
d398 1
a398 1
 * \li	'task' is a valid task
d400 1
a400 1
 * \li	'action' is a valid action
d404 3
a406 3
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_NOMEMORY
 * \li	ISC_R_UNEXPECTED
d410 5
a414 5
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_TIMEDOUT
 * \li	ISC_R_CONNREFUSED
 * \li	ISC_R_NETUNREACH
 * \li	ISC_R_UNEXPECTED
d419 1
a419 1
/*%<
d424 1
a424 1
 * \li	'socket' is a valid TCP socket.
d428 3
a430 3
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_TOOSMALL
 * \li	ISC_R_UNEXPECTED
d435 1
a435 1
/*%<
d440 1
a440 1
 * \li	'socket' is a valid socket.
d444 3
a446 3
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_TOOSMALL
 * \li	ISC_R_UNEXPECTED
a448 1
/*@@{*/
d463 1
a463 1
/*!
d468 1
a468 1
 *\li	Let 'length' refer to the length of 'region' or to the sum of all
d471 1
a471 1
 *\li	If 'minimum' is non-zero and at least that many bytes are read,
d477 1
a477 1
 *\li	The read will complete when the desired number of bytes have been
d482 1
a482 1
 *\li	The caller may not modify 'region', the buffers which are passed
d486 1
a486 1
 *\li	For isc_socket_recvv():
d491 1
a491 1
 *\li	For isc_socket_recv2():
d495 1
a495 1
 *\li	For isc_socket_recv2():
d505 1
a505 1
 *\li	'socket' is a valid, bound socket.
d507 1
a507 1
 *\li	For isc_socket_recv():
d510 1
a510 1
 *\li	For isc_socket_recvv():
d513 1
a513 1
 *\li	'task' is a valid task
d515 1
a515 1
 *\li	For isc_socket_recv() and isc_socket_recvv():
d518 1
a518 1
 *\li	For isc_socket_recv2():
d523 4
a526 4
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_INPROGRESS
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_UNEXPECTED
d530 3
a532 3
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_UNEXPECTED
 *\li	XXX needs other net-type errors
a533 1
/*@@}*/
a534 1
/*@@{*/
d555 1
a555 1
/*!
d560 1
a560 1
 *\li	Shutting down the requestor's task *may* result in any
d564 1
a564 1
 *\li	If 'action' is NULL, then no completion event will be posted.
d566 1
a566 1
 *\li	The caller may not modify 'region', the buffers which are passed
d570 1
a570 1
 *\li	For isc_socket_sendv() and isc_socket_sendtov():
d575 1
a575 1
 *\li	For isc_socket_sendto2():
d579 1
a579 1
 *\li	For isc_socket_sendto2():
d583 1
a583 1
 *\li	If ISC_SOCKFLAG_IMMEDIATE is set and the operation completes, the
d589 1
a589 1
 *\li	ISC_SOCKFLAG_NORETRY can only be set for UDP sockets.  If set
d597 1
a597 1
 *\li	'socket' is a valid, bound socket.
d599 1
a599 1
 *\li	For isc_socket_send():
d602 1
a602 1
 *\li	For isc_socket_sendv() and isc_socket_sendtov():
d605 1
a605 1
 *\li	'task' is a valid task
d607 1
a607 1
 *\li	For isc_socket_sendv(), isc_socket_sendtov(), isc_socket_send(), and
d611 1
a611 1
 *\li	For isc_socket_sendto2():
d616 4
a619 4
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_INPROGRESS
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_UNEXPECTED
d623 3
a625 3
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_UNEXPECTED
 *\li	XXX needs other net-type errors
a626 1
/*@@}*/
d630 1
a630 1
/*%<
d635 1
a635 1
 *\li	All memory will be allocated in memory context 'mctx'.
d639 1
a639 1
 *\li	'mctx' is a valid memory context.
d641 1
a641 1
 *\li	'managerp' points to a NULL isc_socketmgr_t.
d645 1
a645 1
 *\li	'*managerp' is a valid isc_socketmgr_t.
d649 3
a651 3
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_UNEXPECTED
d656 1
a656 1
/*%<
d661 1
a661 1
 *\li	This routine blocks until there are no sockets left in the manager,
d668 1
a668 1
 *\li	'*managerp' is a valid isc_socketmgr_t.
d670 1
a670 1
 *\li	All sockets managed by this manager are fully detached.
d674 1
a674 1
 *\li	*managerp == NULL
d676 1
a676 1
 *\li	All resources used by the manager have been freed.
d681 1
a681 1
/*%<
d686 1
a686 1
 *\li	"sock" is a valid socket.
a688 1
/*@@{*/
d694 1
a694 1
/*%<
d699 1
a699 38
 *\li	'sock' is a valid socket.
 */
/*@@}*/

void
isc_socket_cleanunix(isc_sockaddr_t *addr, isc_boolean_t active);

/*%<
 * Cleanup UNIX domain sockets in the file-system.  If 'active' is true
 * then just unlink the socket.  If 'active' is false try to determine
 * if there is a listener of the socket or not.  If no listener is found
 * then unlink socket.
 *
 * Prior to unlinking the path is tested to see if it a socket.
 *
 * Note: there are a number of race conditions which cannot be avoided
 *       both in the filesystem and any application using UNIX domain
 *	 sockets (e.g. socket is tested between bind() and listen(),
 *	 the socket is deleted and replaced in the file-system between
 *	 stat() and unlink()).
 */

isc_result_t
isc_socket_permunix(isc_sockaddr_t *sockaddr, isc_uint32_t perm,
                    isc_uint32_t owner, isc_uint32_t group);
/*%<
 * Set ownership and file permissions on the UNIX domain socket.
 *
 * Note: On Solaris and SunOS this secures the directory containing
 *       the socket as Solaris and SunOS do not honour the filesytem
 *	 permissions on the socket.
 *
 * Requires:
 * \li	'sockaddr' to be a valid UNIX domain sockaddr.
 *
 * Returns:
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_FAILURE
@


