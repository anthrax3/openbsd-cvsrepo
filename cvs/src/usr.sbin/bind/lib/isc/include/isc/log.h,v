head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.38
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.40
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.36
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.32
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.34
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.26
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.30
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.28
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.24
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.22
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.20
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.18
	OPENBSD_5_0:1.4.0.16
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.14
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.12
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.8
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.10
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	BIND_9_4_2_P1:1.1.1.3
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	BIND_9_4_2:1.1.1.3
	OPENBSD_4_2:1.3.0.12
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.10
	OPENBSD_4_1_BASE:1.3
	BIND_9_3_4:1.1.1.2
	BIND_9_3_3:1.1.1.2
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	BIND_9_3_2:1.1.1.2
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2007.12.09.13.39.44;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.28.17.14.07;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.18.14.14.07;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.07.37;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.37;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.41;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.09.12.34.14;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.4
log
@resolve conflicts
@
text
@/*
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1999-2002  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: log.h,v 1.47.18.3 2005/04/29 00:16:58 marka Exp $ */

#ifndef ISC_LOG_H
#define ISC_LOG_H 1

/*! \file */

#include <stdio.h>
#include <stdarg.h>
#include <syslog.h> /* XXXDCL NT */

#include <isc/formatcheck.h>
#include <isc/lang.h>
#include <isc/platform.h>
#include <isc/types.h>

/*@@{*/
/*!
 * \brief Severity levels, patterned after Unix's syslog levels.
 *
 */
#define ISC_LOG_DEBUG(level)	(level)
/*!
 * #ISC_LOG_DYNAMIC can only be used for defining channels with
 * isc_log_createchannel(), not to specify a level in isc_log_write().
 */
#define ISC_LOG_DYNAMIC	  	  0
#define ISC_LOG_INFO		(-1)
#define ISC_LOG_NOTICE		(-2)
#define ISC_LOG_WARNING 	(-3)
#define ISC_LOG_ERROR		(-4)
#define ISC_LOG_CRITICAL	(-5)
/*@@}*/

/*@@{*/
/*!
 * \brief Destinations.
 */
#define ISC_LOG_TONULL		1
#define ISC_LOG_TOSYSLOG	2
#define ISC_LOG_TOFILE		3
#define ISC_LOG_TOFILEDESC	4
/*@@}*/

/*@@{*/
/*%
 * Channel flags.
 */
#define ISC_LOG_PRINTTIME	0x0001
#define ISC_LOG_PRINTLEVEL	0x0002
#define ISC_LOG_PRINTCATEGORY	0x0004
#define ISC_LOG_PRINTMODULE	0x0008
#define ISC_LOG_PRINTTAG	0x0010
#define ISC_LOG_PRINTALL	0x001F
#define ISC_LOG_DEBUGONLY	0x1000
#define ISC_LOG_OPENERR		0x8000		/* internal */
/*@@}*/

/*@@{*/
/*!
 * \brief Other options.
 *
 * XXXDCL INFINITE doesn't yet work.  Arguably it isn't needed, but
 *   since I am intend to make large number of versions work efficiently,
 *   INFINITE is going to be trivial to add to that.
 */
#define ISC_LOG_ROLLINFINITE	(-1)
#define ISC_LOG_ROLLNEVER	(-2)
/*@@}*/

/*!
 * \brief Used to name the categories used by a library.  
 *
 * An array of isc_logcategory
 * structures names each category, and the id value is initialized by calling
 * isc_log_registercategories.
 */
struct isc_logcategory {
	const char *name;
	unsigned int id;
};

/*%
 * Similar to isc_logcategory, but for all the modules a library defines.
 */
struct isc_logmodule {
	const char *name;
	unsigned int id;
};

/*%
 * The isc_logfile structure is initialized as part of an isc_logdestination
 * before calling isc_log_createchannel().  
 *
 * When defining an #ISC_LOG_TOFILE
 * channel the name, versions and maximum_size should be set before calling
 * isc_log_createchannel().  To define an #ISC_LOG_TOFILEDESC channel set only
 * the stream before the call.
 * 
 * Setting maximum_size to zero implies no maximum.
 */
typedef struct isc_logfile {
	FILE *stream;		/*%< Initialized to NULL for #ISC_LOG_TOFILE. */
	const char *name;	/*%< NULL for #ISC_LOG_TOFILEDESC. */
	int versions;	/* >= 0, #ISC_LOG_ROLLNEVER, #ISC_LOG_ROLLINFINITE. */
	/*%
	 * stdio's ftell is standardized to return a long, which may well not
	 * be big enough for the largest file supportable by the operating
	 * system (though it is _probably_ big enough for the largest log
	 * anyone would want).  st_size returned by fstat should be typedef'd
	 * to a size large enough for the largest possible file on a system.
	 */
	isc_offset_t maximum_size;
	isc_boolean_t maximum_reached; /*%< Private. */
} isc_logfile_t;

/*%
 * Passed to isc_log_createchannel to define the attributes of either
 * a stdio or a syslog log.
 */
typedef union isc_logdestination {
	isc_logfile_t file;
	int facility;		/* XXXDCL NT */
} isc_logdestination_t;

/*@@{*/
/*%
 * The built-in categories of libisc.
 *
 * Each library registering categories should provide library_LOGCATEGORY_name
 * definitions with indexes into its isc_logcategory structure corresponding to
 * the order of the names.
 */
LIBISC_EXTERNAL_DATA extern isc_logcategory_t isc_categories[];
LIBISC_EXTERNAL_DATA extern isc_log_t *isc_lctx;
LIBISC_EXTERNAL_DATA extern isc_logmodule_t isc_modules[];
/*@@}*/

/*@@{*/
/*%
 * Do not log directly to DEFAULT.  Use another category.  When in doubt,
 * use GENERAL.
 */
#define ISC_LOGCATEGORY_DEFAULT	(&isc_categories[0])
#define ISC_LOGCATEGORY_GENERAL	(&isc_categories[1])
/*@@}*/

#define ISC_LOGMODULE_SOCKET (&isc_modules[0])
#define ISC_LOGMODULE_TIME (&isc_modules[1])
#define ISC_LOGMODULE_INTERFACE (&isc_modules[2])
#define ISC_LOGMODULE_TIMER (&isc_modules[3])

ISC_LANG_BEGINDECLS

isc_result_t
isc_log_create(isc_mem_t *mctx, isc_log_t **lctxp, isc_logconfig_t **lcfgp);
/*%<
 * Establish a new logging context, with default channels.
 *
 * Notes:
 *\li	isc_log_create() calls isc_logconfig_create(), so see its comment
 *	below for more information.
 *
 * Requires:
 *\li	mctx is a valid memory context.
 *\li	lctxp is not null and *lctxp is null.
 *\li	lcfgp is null or lcfgp is not null and *lcfgp is null.
 *
 * Ensures:
 *\li	*lctxp will point to a valid logging context if all of the necessary
 *	memory was allocated, or NULL otherwise.
 *\li	*lcfgp will point to a valid logging configuration if all of the
 *	necessary memory was allocated, or NULL otherwise.
 *\li	On failure, no additional memory is allocated.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS		Success
 *\li	#ISC_R_NOMEMORY		Resource limit: Out of memory
 */

isc_result_t
isc_logconfig_create(isc_log_t *lctx, isc_logconfig_t **lcfgp);
/*%<
 * Create the data structure that holds all of the configurable information
 * about where messages are actually supposed to be sent -- the information
 * that could changed based on some configuration file, as opposed to the
 * the category/module specification of isc_log_[v]write[1] that is compiled
 * into a program, or the debug_level which is dynamic state information.
 *
 * Notes:
 *\li	It is necessary to specify the logging context the configuration
 * 	will be used with because the number of categories and modules
 *	needs to be known in order to set the configuration.  However,
 *	the configuration is not used by the logging context until the
 *	isc_logconfig_use function is called.
 *
 *\li	The memory context used for operations that allocate memory for
 *	the configuration is that of the logging context, as specified
 *	in the isc_log_create call.
 *
 *\li	Four default channels are established:
 *\verbatim
 *	    	default_syslog
 *		 - log to syslog's daemon facility #ISC_LOG_INFO or higher
 *		default_stderr
 *		 - log to stderr #ISC_LOG_INFO or higher
 *		default_debug
 *		 - log to stderr #ISC_LOG_DEBUG dynamically
 *		null
 *		 - log nothing
 *\endverbatim
 *
 * Requires:
 *\li 	lctx is a valid logging context.
 *\li	lcftp is not null and *lcfgp is null.
 *
 * Ensures:
 *\li	*lcfgp will point to a valid logging context if all of the necessary
 *	memory was allocated, or NULL otherwise.
 *\li	On failure, no additional memory is allocated.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS		Success
 *\li	#ISC_R_NOMEMORY		Resource limit: Out of memory
 */

isc_logconfig_t *
isc_logconfig_get(isc_log_t *lctx);
/*%<
 * Returns a pointer to the configuration currently in use by the log context.
 *
 * Requires:
 *\li	lctx is a valid context.
 *
 * Ensures:
 *\li	The configuration pointer is non-null.
 *
 * Returns:
 *\li	The configuration pointer.
 */

isc_result_t
isc_logconfig_use(isc_log_t *lctx, isc_logconfig_t *lcfg);
/*%<
 * Associate a new configuration with a logging context.
 *
 * Notes:
 *\li	This is thread safe.  The logging context will lock a mutex
 *	before attempting to swap in the new configuration, and isc_log_doit
 *	(the internal function used by all of isc_log_[v]write[1]) locks
 *	the same lock for the duration of its use of the configuration.
 *
 * Requires:
 *\li	lctx is a valid logging context.
 *\li	lcfg is a valid logging configuration.
 *\li	lctx is the same configuration given to isc_logconfig_create
 *		when the configuration was created.
 *
 * Ensures:
 *\li	Future calls to isc_log_write will use the new configuration.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS		Success
 *\li	#ISC_R_NOMEMORY		Resource limit: Out of memory
 */

void
isc_log_destroy(isc_log_t **lctxp);
/*%<
 * Deallocate the memory associated with a logging context.
 *
 * Requires:
 *\li	*lctx is a valid logging context.
 *
 * Ensures:
 *\li	All of the memory associated with the logging context is returned
 *	to the free memory pool.
 *
 *\li	Any open files are closed.
 *
 *\li	The logging context is marked as invalid.
 */

void
isc_logconfig_destroy(isc_logconfig_t **lcfgp);
/*%<
 * Destroy a logging configuration.
 *
 * Notes:
 *\li	This function cannot be used directly with the return value of
 *	isc_logconfig_get, because a logging context must always have
 *	a valid configuration associated with it.
 *
 * Requires:
 *\li	lcfgp is not null and *lcfgp is a valid logging configuration.
 *\li	The logging configuration is not in use by an existing logging context.
 *
 * Ensures:
 *\li	All memory allocated for the configuration is freed.
 *
 *\li	The configuration is marked as invalid.
 */

void
isc_log_registercategories(isc_log_t *lctx, isc_logcategory_t categories[]);
/*%<
 * Identify logging categories a library will use.
 *
 * Notes:
 *\li	A category should only be registered once, but no mechanism enforces
 *	this rule.
 *
 *\li	The end of the categories array is identified by a NULL name.
 *
 *\li	Because the name is used by #ISC_LOG_PRINTCATEGORY, it should not
 *	be altered or destroyed after isc_log_registercategories().
 *
 *\li	Because each element of the categories array is used by
 *	isc_log_categorybyname, it should not be altered or destroyed
 *	after registration.
 *
 *\li	The value of the id integer in each structure is overwritten
 *	by this function, and so id need not be initialized to any particular
 *	value prior to the function call.
 *
 *\li	A subsequent call to isc_log_registercategories with the same
 *	logging context (but new categories) will cause the last
 *	element of the categories array from the prior call to have
 *	its "name" member changed from NULL to point to the new
 *	categories array, and its "id" member set to UINT_MAX.
 *
 * Requires:
 *\li	lctx is a valid logging context.
 *\li	categories != NULL.
 *\li	categories[0].name != NULL.
 *
 * Ensures:
 * \li	There are references to each category in the logging context,
 * 	so they can be used with isc_log_usechannel() and isc_log_write().
 */

void
isc_log_registermodules(isc_log_t *lctx, isc_logmodule_t modules[]);
/*%<
 * Identify logging categories a library will use.
 *
 * Notes:
 *\li	A module should only be registered once, but no mechanism enforces
 *	this rule.
 *
 *\li	The end of the modules array is identified by a NULL name.
 *
 *\li	Because the name is used by #ISC_LOG_PRINTMODULE, it should not
 *	be altered or destroyed after isc_log_registermodules().
 *
 *\li	Because each element of the modules array is used by
 *	isc_log_modulebyname, it should not be altered or destroyed
 *	after registration.
 *
 *\li	The value of the id integer in each structure is overwritten
 *	by this function, and so id need not be initialized to any particular
 *	value prior to the function call.
 *
 *\li	A subsequent call to isc_log_registermodules with the same
 *	logging context (but new modules) will cause the last
 *	element of the modules array from the prior call to have
 *	its "name" member changed from NULL to point to the new
 *	modules array, and its "id" member set to UINT_MAX.
 *
 * Requires:
 *\li	lctx is a valid logging context.
 *\li	modules != NULL.
 *\li	modules[0].name != NULL;
 *
 * Ensures:
 *\li	Each module has a reference in the logging context, so they can be
 *	used with isc_log_usechannel() and isc_log_write().
 */

isc_result_t
isc_log_createchannel(isc_logconfig_t *lcfg, const char *name,
		      unsigned int type, int level,
		      const isc_logdestination_t *destination,
		      unsigned int flags);
/*%<
 * Specify the parameters of a logging channel.
 *
 * Notes:
 *\li	The name argument is copied to memory in the logging context, so
 *	it can be altered or destroyed after isc_log_createchannel().
 *
 *\li	Defining a very large number of channels will have a performance
 *	impact on isc_log_usechannel(), since the names are searched
 *	linearly until a match is made.  This same issue does not affect
 *	isc_log_write, however.
 *
 *\li	Channel names can be redefined; this is primarily useful for programs
 *	that want their own definition of default_syslog, default_debug
 *	and default_stderr.
 *
 *\li	Any channel that is redefined will not affect logging that was
 *	already directed to its original definition, _except_ for the
 *	default_stderr channel.  This case is handled specially so that
 *	the default logging category can be changed by redefining
 *	default_stderr.  (XXXDCL Though now that I think of it, the default
 *	logging category can be changed with only one additional function
 *	call by defining a new channel and then calling isc_log_usechannel()
 *	for #ISC_LOGCATEGORY_DEFAULT.)
 *
 *\li	Specifying #ISC_LOG_PRINTTIME or #ISC_LOG_PRINTTAG for syslog is allowed,
 *	but probably not what you wanted to do.
 *
 *	#ISC_LOG_DEBUGONLY will mark the channel as usable only when the
 *	debug level of the logging context (see isc_log_setdebuglevel)
 *	is non-zero.
 *
 * Requires:
 *\li	lcfg is a valid logging configuration.
 *
 *\li	name is not NULL.
 *
 *\li	type is #ISC_LOG_TOSYSLOG, #ISC_LOG_TOFILE, #ISC_LOG_TOFILEDESC or
 *		#ISC_LOG_TONULL.
 *
 *\li	destination is not NULL unless type is #ISC_LOG_TONULL.
 *
 *\li	level is >= #ISC_LOG_CRITICAL (the most negative logging level).
 *
 *\li	flags does not include any bits aside from the ISC_LOG_PRINT* bits
 *	or #ISC_LOG_DEBUGONLY.
 *
 * Ensures:
 *\li	#ISC_R_SUCCESS
 *		A channel with the given name is usable with
 *		isc_log_usechannel().
 *
 *\li	#ISC_R_NOMEMORY or #ISC_R_UNEXPECTED
 *		No additional memory is being used by the logging context.
 *		Any channel that previously existed with the given name
 *		is not redefined.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS		Success
 *\li	#ISC_R_NOMEMORY		Resource limit: Out of memory
 *\li	#ISC_R_UNEXPECTED	type was out of range and REQUIRE()
 *					was disabled.
 */

isc_result_t
isc_log_usechannel(isc_logconfig_t *lcfg, const char *name,
		   const isc_logcategory_t *category,
		   const isc_logmodule_t *module);
/*%<
 * Associate a named logging channel with a category and module that
 * will use it.
 *
 * Notes:
 *\li	The name is searched for linearly in the set of known channel names
 *	until a match is found.  (Note the performance impact of a very large
 *	number of named channels.)  When multiple channels of the same
 *	name are defined, the most recent definition is found.
 *
 *\li	Specifing a very large number of channels for a category will have
 *	a moderate impact on performance in isc_log_write(), as each
 *	call looks up the category for the start of a linked list, which
 *	it follows all the way to the end to find matching modules.  The
 *	test for matching modules is  integral, though.
 *
 *\li	If category is NULL, then the channel is associated with the indicated
 *	module for all known categories (including the "default" category).
 *
 *\li	If module is NULL, then the channel is associated with every module
 *	that uses that category.
 *
 *\li	Passing both category and module as NULL would make every log message
 *	use the indicated channel.
 *
 * \li	Specifying a channel that is #ISC_LOG_TONULL for a category/module pair
 *	has no effect on any other channels associated with that pair,
 *	regardless of ordering.  Thus you cannot use it to "mask out" one
 *	category/module pair when you have specified some other channel that
 * 	is also used by that category/module pair.
 *
 * Requires:
 *\li	lcfg is a valid logging configuration.
 *
 *\li	category is NULL or has an id that is in the range of known ids.
 *
 *	module is NULL or has an id that is in the range of known ids.
 *
 * Ensures:
 *\li	#ISC_R_SUCCESS
 *		The channel will be used by the indicated category/module
 *		arguments.
 *
 *\li	#ISC_R_NOMEMORY
 *		If assignment for a specific category has been requested,
 *		the channel has not been associated with the indicated
 *		category/module arguments and no additional memory is
 *		used by the logging context.
 *		If assignment for all categories has been requested
 *		then _some_ may have succeeded (starting with category
 *		"default" and progressing through the order of categories
 *		passed to isc_log_registercategories()) and additional memory
 *		is being used by whatever assignments succeeded.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS	Success
 *\li	#ISC_R_NOMEMORY	Resource limit: Out of memory
 */

/* Attention: next four comments PRECEED code */
/*! 
 *   \brief
 * Write a message to the log channels.
 *
 * Notes:
 *\li	Log messages containing natural language text should be logged with
 *	isc_log_iwrite() to allow for localization.
 *
 *\li	lctx can be NULL; this is allowed so that programs which use
 *	libraries that use the ISC logging system are not required to
 *	also use it.
 *
 *\li	The format argument is a printf(3) string, with additional arguments
 *	as necessary.
 *
 * Requires:
 *\li	lctx is a valid logging context.
 *
 *\li	The category and module arguments must have ids that are in the
 *	range of known ids, as estabished by isc_log_registercategories()
 *	and isc_log_registermodules().
 *
 *\li	level != #ISC_LOG_DYNAMIC.  ISC_LOG_DYNAMIC is used only to define
 *	channels, and explicit debugging level must be identified for
 *	isc_log_write() via ISC_LOG_DEBUG(level).
 *
 *\li	format != NULL.
 *
 * Ensures:
 *\li	The log message is written to every channel associated with the
 *	indicated category/module pair.
 *
 * Returns:
 *\li	Nothing.  Failure to log a message is not construed as a
 *	meaningful error.
 */
void
isc_log_write(isc_log_t *lctx, isc_logcategory_t *category,
	       isc_logmodule_t *module, int level,
	      const char *format, ...)

ISC_FORMAT_PRINTF(5, 6);

/*%
 * Write a message to the log channels.
 *
 * Notes:
 *\li	lctx can be NULL; this is allowed so that programs which use
 *	libraries that use the ISC logging system are not required to
 *	also use it.
 *
 *\li	The format argument is a printf(3) string, with additional arguments
 *	as necessary.
 *
 * Requires:
 *\li	lctx is a valid logging context.
 *
 *\li	The category and module arguments must have ids that are in the
 *	range of known ids, as estabished by isc_log_registercategories()
 *	and isc_log_registermodules().
 *
 *\li	level != #ISC_LOG_DYNAMIC.  ISC_LOG_DYNAMIC is used only to define
 *	channels, and explicit debugging level must be identified for
 *	isc_log_write() via ISC_LOG_DEBUG(level).
 *
 *\li	format != NULL.
 *
 * Ensures:
 *\li	The log message is written to every channel associated with the
 *	indicated category/module pair.
 *
 * Returns:
 *\li	Nothing.  Failure to log a message is not construed as a
 *	meaningful error.
 */
void
isc_log_vwrite(isc_log_t *lctx, isc_logcategory_t *category,
	       isc_logmodule_t *module, int level,
	       const char *format, va_list args)

ISC_FORMAT_PRINTF(5, 0);

/*%
 * Write a message to the log channels, pruning duplicates that occur within
 * a configurable amount of seconds (see isc_log_[sg]etduplicateinterval).
 * This function is otherwise identical to isc_log_write().
 */
void
isc_log_write1(isc_log_t *lctx, isc_logcategory_t *category,
	       isc_logmodule_t *module, int level, const char *format, ...)

ISC_FORMAT_PRINTF(5, 6);

/*%
 * Write a message to the log channels, pruning duplicates that occur within
 * a configurable amount of seconds (see isc_log_[sg]etduplicateinterval).
 * This function is otherwise identical to isc_log_vwrite().
 */
void
isc_log_vwrite1(isc_log_t *lctx, isc_logcategory_t *category,
		isc_logmodule_t *module, int level, const char *format,
		va_list args)

ISC_FORMAT_PRINTF(5, 0);

/*%
 * These are four internationalized versions of the the isc_log_[v]write[1]
 * functions.  
 *
 * The only difference is that they take arguments for a message
 * catalog, message set, and message number, all immediately preceding the
 * format argument.  The format argument becomes the default text, a la
 * isc_msgcat_get.  If the message catalog is NULL, no lookup is attempted
 * for a message -- which makes the message set and message number irrelevant,
 * and the non-internationalized call should have probably been used instead.
 *
 * Yes, that means there are now *eight* interfaces to logging a message.
 * Sheesh.   Make the madness stop!
 */
/*@@{*/
void
isc_log_iwrite(isc_log_t *lctx, isc_logcategory_t *category,
	      isc_logmodule_t *module, int level,
	      isc_msgcat_t *msgcat, int msgset, int message,
	      const char *format, ...)
ISC_FORMAT_PRINTF(8, 9);

void
isc_log_ivwrite(isc_log_t *lctx, isc_logcategory_t *category,
		isc_logmodule_t *module, int level,
		isc_msgcat_t *msgcat, int msgset, int message,
		const char *format, va_list args)
ISC_FORMAT_PRINTF(8, 0);

void
isc_log_iwrite1(isc_log_t *lctx, isc_logcategory_t *category,
		isc_logmodule_t *module, int level,
		isc_msgcat_t *msgcat, int msgset, int message,
		const char *format, ...)
ISC_FORMAT_PRINTF(8, 9);

void
isc_log_ivwrite1(isc_log_t *lctx, isc_logcategory_t *category,
		 isc_logmodule_t *module, int level,
		 isc_msgcat_t *msgcat, int msgset, int message,
		 const char *format, va_list args)
ISC_FORMAT_PRINTF(8, 0);
/*@@}*/

void
isc_log_setdebuglevel(isc_log_t *lctx, unsigned int level);
/*%<
 * Set the debugging level used for logging.
 *
 * Notes:
 *\li	Setting the debugging level to 0 disables debugging log messages.
 *
 * Requires:
 *\li	lctx is a valid logging context.
 *
 * Ensures:
 *\li	The debugging level is set to the requested value.
 */

unsigned int
isc_log_getdebuglevel(isc_log_t *lctx);
/*%<
 * Get the current debugging level.
 *
 * Notes:
 *\li	This is provided so that a program can have a notion of
 *	"increment debugging level" or "decrement debugging level"
 *	without needing to keep track of what the current level is.
 *
 *\li	A return value of 0 indicates that debugging messages are disabled.
 *
 * Requires:
 *\li	lctx is a valid logging context.
 *
 * Ensures:
 *\li	The current logging debugging level is returned.
 */

isc_boolean_t
isc_log_wouldlog(isc_log_t *lctx, int level);
/*%<
 * Determine whether logging something to 'lctx' at 'level' would
 * actually cause something to be logged somewhere.
 *
 * If #ISC_FALSE is returned, it is guaranteed that nothing would
 * be logged, allowing the caller to omit unnecessary
 * isc_log_write() calls and possible message preformatting.
 */

void
isc_log_setduplicateinterval(isc_logconfig_t *lcfg, unsigned int interval);
/*%<
 * Set the interval over which duplicate log messages will be ignored
 * by isc_log_[v]write1(), in seconds.
 *
 * Notes:
 *\li	Increasing the duplicate interval from X to Y will not necessarily
 *	filter out duplicates of messages logged in Y - X seconds since the
 *	increase.  (Example: Message1 is logged at midnight.  Message2
 *	is logged at 00:01:00, when the interval is only 30 seconds, causing
 *	Message1 to be expired from the log message history.  Then the interval
 *	is increased to 3000 (five minutes) and at 00:04:00 Message1 is logged
 *	again.  It will appear the second time even though less than five
 *	passed since the first occurrence.
 *
 * Requires:
 *\li	lctx is a valid logging context.
 */

unsigned int
isc_log_getduplicateinterval(isc_logconfig_t *lcfg);
/*%<
 * Get the current duplicate filtering interval.
 *
 * Requires:
 *\li	lctx is a valid logging context.
 *
 * Returns:
 *\li	The current duplicate filtering interval.
 */

isc_result_t
isc_log_settag(isc_logconfig_t *lcfg, const char *tag);
/*%<
 * Set the program name or other identifier for #ISC_LOG_PRINTTAG.
 *
 * Requires:
 *\li	lcfg is a valid logging configuration.
 *
 * Notes:
 *\li	If this function has not set the tag to a non-NULL, non-empty value,
 *	then the #ISC_LOG_PRINTTAG channel flag will not print anything.
 *	Unlike some implementations of syslog on Unix systems, you *must* set
 *	the tag in order to get it logged.  It is not implicitly derived from
 *	the program name (which is pretty impossible to infer portably).
 *
 *\li	Setting the tag to NULL or the empty string will also cause the
 *	#ISC_LOG_PRINTTAG channel flag to not print anything.  If tag equals the
 *	empty string, calls to isc_log_gettag will return NULL.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS	Success
 *\li	#ISC_R_NOMEMORY  Resource Limit: Out of memory
 *
 * XXXDCL when creating a new isc_logconfig_t, it might be nice if the tag
 * of the currently active isc_logconfig_t was inherited.  this does not
 * currently happen.
 */

char *
isc_log_gettag(isc_logconfig_t *lcfg);
/*%<
 * Get the current identifier printed with #ISC_LOG_PRINTTAG.
 *
 * Requires:
 *\li	lcfg is a valid logging configuration.
 *
 * Notes:
 *\li	Since isc_log_settag() will not associate a zero-length string
 *	with the logging configuration, attempts to do so will cause
 *	this function to return NULL.  However, a determined programmer
 *	will observe that (currently) a tag of length greater than zero
 *	could be set, and then modified to be zero length.
 *
 * Returns:
 *\li	A pointer to the current identifier, or NULL if none has been set.
 */

void
isc_log_opensyslog(const char *tag, int options, int facility);
/*%<
 * Initialize syslog logging.
 *
 * Notes:
 *\li	XXXDCL NT
 *	This is currently equivalent to openlog(), but is not going to remain
 *	that way.  In the meantime, the arguments are all identical to
 *	those used by openlog(3), as follows:
 *
 * \code
 *		tag: The string to use in the position of the program
 *			name in syslog messages.  Most (all?) syslogs
 *			will use basename(argv[0]) if tag is NULL.
 *
 *		options: LOG_CONS, LOG_PID, LOG_NDELAY ... whatever your
 *			syslog supports.
 *
 *		facility: The default syslog facility.  This is irrelevant
 *			since isc_log_write will ALWAYS use the channel's
 *			declared facility.
 * \endcode
 *
 *\li	Zero effort has been made (yet) to accomodate systems with openlog()
 *	that only takes two arguments, or to identify valid syslog
 *	facilities or options for any given architecture.
 *
 *\li	It is necessary to call isc_log_opensyslog() to initialize
 *	syslogging on machines which do not support network connections to
 *	syslogd because they require a Unix domain socket to be used.  Since
 *	this is a chore to determine at run-time, it is suggested that it
 *	always be called by programs using the ISC logging system.
 *
 * Requires:
 *\li	Nothing.
 *
 * Ensures:
 *\li	openlog() is called to initialize the syslog system.
 */

void
isc_log_closefilelogs(isc_log_t *lctx);
/*%<
 * Close all open files used by #ISC_LOG_TOFILE channels.
 *
 * Notes:
 *\li	This function is provided for programs that want to use their own
 *	log rolling mechanism rather than the one provided internally.
 *	For example, a program that wanted to keep daily logs would define
 *	a channel which used #ISC_LOG_ROLLNEVER, then once a day would
 *	rename the log file and call isc_log_closefilelogs().
 *
 *\li	#ISC_LOG_TOFILEDESC channels are unaffected.
 *
 * Requires:
 *\li	lctx is a valid context.
 *
 * Ensures:
 *\li	The open files are closed and will be reopened when they are
 *	next needed.
 */

isc_logcategory_t *
isc_log_categorybyname(isc_log_t *lctx, const char *name);
/*%<
 * Find a category by its name.
 *
 * Notes:
 *\li	The string name of a category is not required to be unique.
 *
 * Requires:
 *\li	lctx is a valid context.
 *\li	name is not NULL.
 *
 * Returns:
 *\li	A pointer to the _first_ isc_logcategory_t structure used by "name".
 *
 *\li	NULL if no category exists by that name.
 */

isc_logmodule_t *
isc_log_modulebyname(isc_log_t *lctx, const char *name);
/*%<
 * Find a module by its name.
 *
 * Notes:
 *\li	The string name of a module is not required to be unique.
 *
 * Requires:
 *\li	lctx is a valid context.
 *\li	name is not NULL.
 *
 * Returns:
 *\li	A pointer to the _first_ isc_logmodule_t structure used by "name".
 *
 *\li	NULL if no module exists by that name.
 */

void
isc_log_setcontext(isc_log_t *lctx);
/*%<
 * Sets the context used by the libisc for logging.
 *
 * Requires:
 *\li	lctx be a valid context.
 */

ISC_LANG_ENDDECLS

#endif /* ISC_LOG_H */
@


1.3
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: log.h,v 1.39.2.4.2.7 2004/04/10 04:31:40 marka Exp $ */
d23 2
d34 3
a36 2
/*
 * Severity levels, patterned after Unix's syslog levels.
d38 4
a41 1
 * ISC_LOG_DYNAMIC can only be used for defining channels with
a43 1
#define ISC_LOG_DEBUG(level)	(level)
d50 1
d52 3
a54 2
/*
 * Destinations.
d60 1
d62 2
a63 1
/*
d74 1
d76 4
a79 2
/*
 * Other options.
d86 1
d88 4
a91 2
/*
 * Used to name the categories used by a library.  An array of isc_logcategory
d100 2
a101 2
/*
 * Similar to isc_logcategory above, but for all the modules a library defines.
d108 1
a108 1
/*
d110 3
a112 1
 * before calling isc_log_createchannel().  When defining an ISC_LOG_TOFILE
d114 1
a114 1
 * isc_log_createchannel().  To define an ISC_LOG_TOFILEDESC channel set only
d120 4
a123 4
	FILE *stream;		/* Initialized to NULL for ISC_LOG_TOFILE. */
	const char *name;	/* NULL for ISC_LOG_TOFILEDESC. */
	int versions;	/* >= 0, ISC_LOG_ROLLNEVER, ISC_LOG_ROLLINFINITE. */
	/*
d131 1
a131 1
	isc_boolean_t maximum_reached; /* Private. */
d134 1
a134 1
/*
d143 2
a144 1
/*
d154 1
d156 2
a157 1
/*
d163 1
d174 1
a174 1
/*
d178 1
a178 1
 *	isc_log_create calls isc_logconfig_create, so see its comment
d182 3
a184 3
 *	mctx is a valid memory context.
 *	lctxp is not null and *lctxp is null.
 *	lcfgp is null or lcfgp is not null and *lcfgp is null.
d187 1
a187 1
 *	*lctxp will point to a valid logging context if all of the necessary
d189 1
a189 1
 *	*lcfgp will point to a valid logging configuration if all of the
d191 1
a191 1
 *	On failure, no additional memory is allocated.
d194 2
a195 2
 *	ISC_R_SUCCESS		Success
 *	ISC_R_NOMEMORY		Resource limit: Out of memory
d200 1
a200 1
/*
d208 1
a208 1
 *	It is necessary to specify the logging context the configuration
d214 1
a214 1
 *	The memory context used for operations that allocate memory for
d218 2
a219 1
 *	Four default channels are established:
d221 1
a221 1
 *		 - log to syslog's daemon facility ISC_LOG_INFO or higher
d223 1
a223 1
 *		 - log to stderr ISC_LOG_INFO or higher
d225 1
a225 1
 *		 - log to stderr ISC_LOG_DEBUG dynamically
d228 1
d231 2
a232 2
 * 	lctx is a valid logging context.
 *	lcftp is not null and *lcfgp is null.
d235 1
a235 1
 *	*lcfgp will point to a valid logging context if all of the necessary
d237 1
a237 1
 *	On failure, no additional memory is allocated.
d240 2
a241 2
 *	ISC_R_SUCCESS		Success
 *	ISC_R_NOMEMORY		Resource limit: Out of memory
d246 1
a246 1
/*
d250 1
a250 1
 *	lctx is a valid context.
d253 1
a253 1
 *	The configuration pointer is non-null.
d256 1
a256 1
 *	The configuration pointer.
d261 1
a261 1
/*
d265 1
a265 1
 *	This is thread safe.  The logging context will lock a mutex
d271 3
a273 3
 *	lctx is a valid logging context.
 *	lcfg is a valid logging configuration.
 *	lctx is the same configuration given to isc_logconfig_create
d277 1
a277 1
 *	Future calls to isc_log_write will use the new configuration.
d280 2
a281 2
 *	ISC_R_SUCCESS		Success
 *	ISC_R_NOMEMORY		Resource limit: Out of memory
d286 1
a286 1
/*
d290 1
a290 1
 *	*lctx is a valid logging context.
d293 1
a293 1
 *	All of the memory associated with the logging context is returned
d296 1
a296 1
 *	Any open files are closed.
d298 1
a298 1
 *	The logging context is marked as invalid.
d303 1
a303 1
/*
d307 1
a307 1
 *	This function cannot be used directly with the return value of
d312 2
a313 2
 *	lcfgp is not null and *lcfgp is a valid logging configuration.
 *	The logging configuration is not in use by an existing logging context.
d316 1
a316 1
 *	All memory allocated for the configuration is freed.
d318 1
a318 1
 *	The configuration is marked as invalid.
d323 1
a323 1
/*
d327 1
a327 1
 *	A category should only be registered once, but no mechanism enforces
d330 1
a330 1
 *	The end of the categories array is identified by a NULL name.
d332 1
a332 1
 *	Because the name is used by ISC_LOG_PRINTCATEGORY, it should not
d335 1
a335 1
 *	Because each element of the categories array is used by
d339 1
a339 1
 *	The value of the id integer in each structure is overwritten
d343 1
a343 1
 *	A subsequent call to isc_log_registercategories with the same
d350 3
a352 3
 *	lctx is a valid logging context.
 *	categories != NULL.
 *	categories[0].name != NULL.
d355 1
a355 1
 * 	There are references to each category in the logging context,
d361 1
a361 1
/*
d365 1
a365 1
 *	A module should only be registered once, but no mechanism enforces
d368 1
a368 1
 *	The end of the modules array is identified by a NULL name.
d370 1
a370 1
 *	Because the name is used by ISC_LOG_PRINTMODULE, it should not
d373 1
a373 1
 *	Because each element of the modules array is used by
d377 1
a377 1
 *	The value of the id integer in each structure is overwritten
d381 1
a381 1
 *	A subsequent call to isc_log_registermodules with the same
d388 3
a390 3
 *	lctx is a valid logging context.
 *	modules != NULL.
 *	modules[0].name != NULL;
d393 1
a393 1
 *	Each module has a reference in the logging context, so they can be
d402 1
a402 1
/*
d406 1
a406 1
 *	The name argument is copied to memory in the logging context, so
d409 1
a409 1
 *	Defining a very large number of channels will have a performance
d414 1
a414 1
 *	Channel names can be redefined; this is primarily useful for programs
d418 1
a418 1
 *	Any channel that is redefined will not affect logging that was
d425 1
a425 1
 *	for ISC_LOGCATEGORY_DEFAULT.)
d427 1
a427 1
 *	Specifying ISC_LOG_PRINTTIME or ISC_LOG_PRINTTAG for syslog is allowed,
d430 1
a430 1
 *	ISC_LOG_DEBUGONLY will mark the channel as usable only when the
d435 1
a435 1
 *	lcfg is a valid logging configuration.
d437 1
a437 1
 *	name is not NULL.
d439 2
a440 2
 *	type is ISC_LOG_TOSYSLOG, ISC_LOG_TOFILE, ISC_LOG_TOFILEDESC or
 *		ISC_LOG_TONULL.
d442 1
a442 1
 *	destination is not NULL unless type is ISC_LOG_TONULL.
d444 1
a444 1
 *	level is >= ISC_LOG_CRITICAL (the most negative logging level).
d446 2
a447 2
 *	flags does not include any bits aside from the ISC_LOG_PRINT* bits
 *	or ISC_LOG_DEBUGONLY.
d450 1
a450 1
 *	ISC_R_SUCCESS
d454 1
a454 1
 *	ISC_R_NOMEMORY or ISC_R_UNEXPECTED
a455 1
 *
d460 3
a462 3
 *	ISC_R_SUCCESS		Success
 *	ISC_R_NOMEMORY		Resource limit: Out of memory
 *	ISC_R_UNEXPECTED	type was out of range and REQUIRE()
d470 1
a470 1
/*
d475 1
a475 1
 *	The name is searched for linearly in the set of known channel names
d480 1
a480 1
 *	Specifing a very large number of channels for a category will have
d486 1
a486 1
 *	If category is NULL, then the channel is associated with the indicated
d489 1
a489 1
 *	If module is NULL, then the channel is associated with every module
d492 1
a492 1
 *	Passing both category and module as NULL would make every log message
d495 1
a495 1
 * 	Specifying a channel that is ISC_LOG_TONULL for a category/module pair
d502 1
a502 1
 *	lcfg is a valid logging configuration.
d504 1
a504 1
 *	category is NULL or has an id that is in the range of known ids.
d509 1
a509 1
 *	ISC_R_SUCCESS
d513 1
a513 1
 *	ISC_R_NOMEMORY
a517 1
 *
d521 1
a521 1
 *		passed to isc_log_registercategories) and additional memory
d525 2
a526 2
 *	ISC_R_SUCCESS	Success
 *	ISC_R_NOMEMORY	Resource limit: Out of memory
d529 3
a531 6
void
isc_log_write(isc_log_t *lctx, isc_logcategory_t *category,
	      isc_logmodule_t *module, int level,
	      const char *format, ...)
ISC_FORMAT_PRINTF(5, 6);
/*
d535 1
a535 1
 *	Log messages containing natural language text should be logged with
d538 1
a538 1
 *	lctx can be NULL; this is allowed so that programs which use
d542 1
a542 1
 *	The format argument is a printf(3) string, with additional arguments
d546 1
a546 1
 *	lctx is a valid logging context.
d548 1
a548 1
 *	The category and module arguments must have ids that are in the
d552 1
a552 1
 *	level != ISC_LOG_DYNAMIC.  ISC_LOG_DYNAMIC is used only to define
d556 1
a556 1
 *	format != NULL.
d559 1
a559 1
 *	The log message is written to every channel associated with the
d563 1
a563 1
 *	Nothing.  Failure to log a message is not construed as a
a565 1

d567 1
a567 1
isc_log_vwrite(isc_log_t *lctx, isc_logcategory_t *category,
d569 5
a573 3
	       const char *format, va_list args)
ISC_FORMAT_PRINTF(5, 0);
/*
d577 1
a577 1
 *	lctx can be NULL; this is allowed so that programs which use
d581 1
a581 1
 *	The format argument is a printf(3) string, with additional arguments
d585 1
a585 1
 *	lctx is a valid logging context.
d587 1
a587 1
 *	The category and module arguments must have ids that are in the
d591 1
a591 1
 *	level != ISC_LOG_DYNAMIC.  ISC_LOG_DYNAMIC is used only to define
d595 1
a595 1
 *	format != NULL.
d598 1
a598 1
 *	The log message is written to every channel associated with the
d602 1
a602 1
 *	Nothing.  Failure to log a message is not construed as a
d605 6
d612 5
d620 1
d622 2
a623 1
/*
d626 1
a626 1
 * This function is otherwise identical to isc_log_write().
a627 1

d632 1
d634 14
a647 4
/*
 * Write a message to the log channels, pruning duplicates that occur within
 * a configurable amount of seconds (see isc_log_[sg]etduplicateinterval).
 * This function is otherwise identical to isc_log_vwrite().
d649 1
a649 1

d677 1
a677 12
/*
 * These are four internationalized versions of the the isc_log_[v]write[1]
 * functions.  The only difference is that they take arguments for a message
 * catalog, message set, and message number, all immediately preceding the
 * format argument.  The format argument becomes the default text, a la
 * isc_msgcat_get.  If the message catalog is NULL, no lookup is attempted
 * for a message -- which makes the message set and message number irrelevant,
 * and the non-internationalized call should have probably been used instead.
 *
 * Yes, that means there are now *eight* interfaces to logging a message.
 * Sheesh.   Make the madness stop!
 */
d681 1
a681 1
/*
d685 1
a685 1
 *	Setting the debugging level to 0 disables debugging log messages.
d688 1
a688 1
 *	lctx is a valid logging context.
d691 1
a691 1
 *	The debugging level is set to the requested value.
d696 1
a696 1
/*
d700 1
a700 1
 *	This is provided so that a program can have a notion of
d704 1
a704 1
 *	A return value of 0 indicates that debugging messages are disabled.
d707 1
a707 1
 *	lctx is a valid logging context.
d710 1
a710 1
 *	The current logging debugging level is returned.
d715 1
a715 1
/*
d719 1
a719 1
 * If ISC_FALSE is returned, it is guaranteed that nothing would
d726 1
a726 1
/*
d731 1
a731 1
 *	Increasing the duplicate interval from X to Y will not necessarily
d741 1
a741 1
 *	lctx is a valid logging context.
d746 1
a746 1
/*
d750 1
a750 1
 *	lctx is a valid logging context.
d753 1
a753 1
 *	The current duplicate filtering interval.
d758 2
a759 2
/*
 * Set the program name or other identifier for ISC_LOG_PRINTTAG.
d762 1
a762 1
 *	lcfg is a valid logging configuration.
d765 2
a766 2
 *	If this function has not set the tag to a non-NULL, non-empty value,
 *	then the ISC_LOG_PRINTTAG channel flag will not print anything.
d771 2
a772 2
 *	Setting the tag to NULL or the empty string will also cause the
 *	ISC_LOG_PRINTTAG channel flag to not print anything.  If tag equals the
d776 2
a777 2
 *	ISC_R_SUCCESS	Success
 *	ISC_R_NOMEMORY  Resource Limit: Out of memory
d786 2
a787 2
/*
 * Get the current identifier printed with ISC_LOG_PRINTTAG.
d790 1
a790 1
 *	lcfg is a valid logging configuration.
d793 1
a793 1
 *	Since isc_log_settag() will not associate a zero-length string
d800 1
a800 1
 *	A pointer to the current identifier, or NULL if none has been set.
d805 1
a805 1
/*
d809 1
a809 1
 *	XXXDCL NT
d813 2
d825 1
d827 1
a827 1
 *	Zero effort has been made (yet) to accomodate systems with openlog()
d831 1
a831 1
 *	It is necessary to call isc_log_opensyslog() to initialize
d838 1
a838 1
 *	Nothing.
d841 1
a841 1
 *	openlog() is called to initialize the syslog system.
d846 2
a847 2
/*
 * Close all open files used by ISC_LOG_TOFILE channels.
d850 1
a850 1
 *	This function is provided for programs that want to use their own
d853 1
a853 1
 *	a channel which used ISC_LOG_ROLLNEVER, then once a day would
d856 1
a856 1
 *	ISC_LOG_TOFILEDESC channels are unaffected.
d859 1
a859 1
 *	lctx is a valid context.
d862 1
a862 1
 *	The open files are closed and will be reopened when they are
d868 1
a868 1
/*
d872 1
a872 1
 *	The string name of a category is not required to be unique.
d875 2
a876 2
 *	lctx is a valid context.
 *	name is not NULL.
d879 1
a879 1
 *	A pointer to the _first_ isc_logcategory_t structure used by "name".
d881 1
a881 1
 *	NULL if no category exists by that name.
d886 1
a886 1
/*
d890 1
a890 1
 *	The string name of a module is not required to be unique.
d893 2
a894 2
 *	lctx is a valid context.
 *	name is not NULL.
d897 1
a897 1
 *	A pointer to the _first_ isc_logmodule_t structure used by "name".
d899 1
a899 1
 *	NULL if no module exists by that name.
d904 1
a904 1
/*
d908 1
a908 1
 *	lctx be a valid context.
@


1.2
log
@update to BIND v9.2.3. ok todd@@
@
text
@d2 2
a3 1
 * Copyright (C) 1999-2003  Internet Software Consortium.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: log.h,v 1.39.2.4 2003/07/22 04:03:49 marka Exp $ */
d99 2
d146 2
a742 3
 *
 *	Because the name is used by ISC_LOG_PRINTTAG, it should not be
 *	altered or destroyed after isc_log_settag().
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2002  Internet Software Consortium.
d18 1
a18 1
/* $ISC: log.h,v 1.39.2.2 2002/08/05 06:57:15 marka Exp $ */
d64 1
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@a1 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: log.h,v 1.39.2.4.2.7 2004/04/10 04:31:40 marka Exp $ */
a63 1
#define ISC_LOG_OPENERR		0x8000		/* internal */
a97 2
 * 
 * Setting maximum_size to zero implies no maximum.
a142 2
#define ISC_LOGMODULE_INTERFACE (&isc_modules[2])
#define ISC_LOGMODULE_TIMER (&isc_modules[3])
d738 3
@


1.1.1.3
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: log.h,v 1.47.18.3 2005/04/29 00:16:58 marka Exp $ */
a22 2
/*! \file */

d32 2
a33 3
/*@@{*/
/*!
 * \brief Severity levels, patterned after Unix's syslog levels.
d35 2
a38 4
/*!
 * #ISC_LOG_DYNAMIC can only be used for defining channels with
 * isc_log_createchannel(), not to specify a level in isc_log_write().
 */
a44 1
/*@@}*/
d46 2
a47 3
/*@@{*/
/*!
 * \brief Destinations.
a52 1
/*@@}*/
d54 1
a54 2
/*@@{*/
/*%
a64 1
/*@@}*/
d66 2
a67 4
/*@@{*/
/*!
 * \brief Other options.
 *
a73 1
/*@@}*/
d75 2
a76 4
/*!
 * \brief Used to name the categories used by a library.  
 *
 * An array of isc_logcategory
d85 2
a86 2
/*%
 * Similar to isc_logcategory, but for all the modules a library defines.
d93 1
a93 1
/*%
d95 1
a95 3
 * before calling isc_log_createchannel().  
 *
 * When defining an #ISC_LOG_TOFILE
d97 1
a97 1
 * isc_log_createchannel().  To define an #ISC_LOG_TOFILEDESC channel set only
d103 4
a106 4
	FILE *stream;		/*%< Initialized to NULL for #ISC_LOG_TOFILE. */
	const char *name;	/*%< NULL for #ISC_LOG_TOFILEDESC. */
	int versions;	/* >= 0, #ISC_LOG_ROLLNEVER, #ISC_LOG_ROLLINFINITE. */
	/*%
d114 1
a114 1
	isc_boolean_t maximum_reached; /*%< Private. */
d117 1
a117 1
/*%
d126 1
a126 2
/*@@{*/
/*%
a135 1
/*@@}*/
d137 1
a137 2
/*@@{*/
/*%
a142 1
/*@@}*/
d153 1
a153 1
/*%<
d157 1
a157 1
 *\li	isc_log_create() calls isc_logconfig_create(), so see its comment
d161 3
a163 3
 *\li	mctx is a valid memory context.
 *\li	lctxp is not null and *lctxp is null.
 *\li	lcfgp is null or lcfgp is not null and *lcfgp is null.
d166 1
a166 1
 *\li	*lctxp will point to a valid logging context if all of the necessary
d168 1
a168 1
 *\li	*lcfgp will point to a valid logging configuration if all of the
d170 1
a170 1
 *\li	On failure, no additional memory is allocated.
d173 2
a174 2
 *\li	#ISC_R_SUCCESS		Success
 *\li	#ISC_R_NOMEMORY		Resource limit: Out of memory
d179 1
a179 1
/*%<
d187 1
a187 1
 *\li	It is necessary to specify the logging context the configuration
d193 1
a193 1
 *\li	The memory context used for operations that allocate memory for
d197 1
a197 2
 *\li	Four default channels are established:
 *\verbatim
d199 1
a199 1
 *		 - log to syslog's daemon facility #ISC_LOG_INFO or higher
d201 1
a201 1
 *		 - log to stderr #ISC_LOG_INFO or higher
d203 1
a203 1
 *		 - log to stderr #ISC_LOG_DEBUG dynamically
a205 1
 *\endverbatim
d208 2
a209 2
 *\li 	lctx is a valid logging context.
 *\li	lcftp is not null and *lcfgp is null.
d212 1
a212 1
 *\li	*lcfgp will point to a valid logging context if all of the necessary
d214 1
a214 1
 *\li	On failure, no additional memory is allocated.
d217 2
a218 2
 *\li	#ISC_R_SUCCESS		Success
 *\li	#ISC_R_NOMEMORY		Resource limit: Out of memory
d223 1
a223 1
/*%<
d227 1
a227 1
 *\li	lctx is a valid context.
d230 1
a230 1
 *\li	The configuration pointer is non-null.
d233 1
a233 1
 *\li	The configuration pointer.
d238 1
a238 1
/*%<
d242 1
a242 1
 *\li	This is thread safe.  The logging context will lock a mutex
d248 3
a250 3
 *\li	lctx is a valid logging context.
 *\li	lcfg is a valid logging configuration.
 *\li	lctx is the same configuration given to isc_logconfig_create
d254 1
a254 1
 *\li	Future calls to isc_log_write will use the new configuration.
d257 2
a258 2
 *\li	#ISC_R_SUCCESS		Success
 *\li	#ISC_R_NOMEMORY		Resource limit: Out of memory
d263 1
a263 1
/*%<
d267 1
a267 1
 *\li	*lctx is a valid logging context.
d270 1
a270 1
 *\li	All of the memory associated with the logging context is returned
d273 1
a273 1
 *\li	Any open files are closed.
d275 1
a275 1
 *\li	The logging context is marked as invalid.
d280 1
a280 1
/*%<
d284 1
a284 1
 *\li	This function cannot be used directly with the return value of
d289 2
a290 2
 *\li	lcfgp is not null and *lcfgp is a valid logging configuration.
 *\li	The logging configuration is not in use by an existing logging context.
d293 1
a293 1
 *\li	All memory allocated for the configuration is freed.
d295 1
a295 1
 *\li	The configuration is marked as invalid.
d300 1
a300 1
/*%<
d304 1
a304 1
 *\li	A category should only be registered once, but no mechanism enforces
d307 1
a307 1
 *\li	The end of the categories array is identified by a NULL name.
d309 1
a309 1
 *\li	Because the name is used by #ISC_LOG_PRINTCATEGORY, it should not
d312 1
a312 1
 *\li	Because each element of the categories array is used by
d316 1
a316 1
 *\li	The value of the id integer in each structure is overwritten
d320 1
a320 1
 *\li	A subsequent call to isc_log_registercategories with the same
d327 3
a329 3
 *\li	lctx is a valid logging context.
 *\li	categories != NULL.
 *\li	categories[0].name != NULL.
d332 1
a332 1
 * \li	There are references to each category in the logging context,
d338 1
a338 1
/*%<
d342 1
a342 1
 *\li	A module should only be registered once, but no mechanism enforces
d345 1
a345 1
 *\li	The end of the modules array is identified by a NULL name.
d347 1
a347 1
 *\li	Because the name is used by #ISC_LOG_PRINTMODULE, it should not
d350 1
a350 1
 *\li	Because each element of the modules array is used by
d354 1
a354 1
 *\li	The value of the id integer in each structure is overwritten
d358 1
a358 1
 *\li	A subsequent call to isc_log_registermodules with the same
d365 3
a367 3
 *\li	lctx is a valid logging context.
 *\li	modules != NULL.
 *\li	modules[0].name != NULL;
d370 1
a370 1
 *\li	Each module has a reference in the logging context, so they can be
d379 1
a379 1
/*%<
d383 1
a383 1
 *\li	The name argument is copied to memory in the logging context, so
d386 1
a386 1
 *\li	Defining a very large number of channels will have a performance
d391 1
a391 1
 *\li	Channel names can be redefined; this is primarily useful for programs
d395 1
a395 1
 *\li	Any channel that is redefined will not affect logging that was
d402 1
a402 1
 *	for #ISC_LOGCATEGORY_DEFAULT.)
d404 1
a404 1
 *\li	Specifying #ISC_LOG_PRINTTIME or #ISC_LOG_PRINTTAG for syslog is allowed,
d407 1
a407 1
 *	#ISC_LOG_DEBUGONLY will mark the channel as usable only when the
d412 1
a412 1
 *\li	lcfg is a valid logging configuration.
d414 1
a414 1
 *\li	name is not NULL.
d416 2
a417 2
 *\li	type is #ISC_LOG_TOSYSLOG, #ISC_LOG_TOFILE, #ISC_LOG_TOFILEDESC or
 *		#ISC_LOG_TONULL.
d419 1
a419 1
 *\li	destination is not NULL unless type is #ISC_LOG_TONULL.
d421 1
a421 1
 *\li	level is >= #ISC_LOG_CRITICAL (the most negative logging level).
d423 2
a424 2
 *\li	flags does not include any bits aside from the ISC_LOG_PRINT* bits
 *	or #ISC_LOG_DEBUGONLY.
d427 1
a427 1
 *\li	#ISC_R_SUCCESS
d431 1
a431 1
 *\li	#ISC_R_NOMEMORY or #ISC_R_UNEXPECTED
d433 1
d438 3
a440 3
 *\li	#ISC_R_SUCCESS		Success
 *\li	#ISC_R_NOMEMORY		Resource limit: Out of memory
 *\li	#ISC_R_UNEXPECTED	type was out of range and REQUIRE()
d448 1
a448 1
/*%<
d453 1
a453 1
 *\li	The name is searched for linearly in the set of known channel names
d458 1
a458 1
 *\li	Specifing a very large number of channels for a category will have
d464 1
a464 1
 *\li	If category is NULL, then the channel is associated with the indicated
d467 1
a467 1
 *\li	If module is NULL, then the channel is associated with every module
d470 1
a470 1
 *\li	Passing both category and module as NULL would make every log message
d473 1
a473 1
 * \li	Specifying a channel that is #ISC_LOG_TONULL for a category/module pair
d480 1
a480 1
 *\li	lcfg is a valid logging configuration.
d482 1
a482 1
 *\li	category is NULL or has an id that is in the range of known ids.
d487 1
a487 1
 *\li	#ISC_R_SUCCESS
d491 1
a491 1
 *\li	#ISC_R_NOMEMORY
d496 1
d500 1
a500 1
 *		passed to isc_log_registercategories()) and additional memory
d504 2
a505 2
 *\li	#ISC_R_SUCCESS	Success
 *\li	#ISC_R_NOMEMORY	Resource limit: Out of memory
d508 6
a513 3
/* Attention: next four comments PRECEED code */
/*! 
 *   \brief
d517 1
a517 1
 *\li	Log messages containing natural language text should be logged with
d520 1
a520 1
 *\li	lctx can be NULL; this is allowed so that programs which use
d524 1
a524 1
 *\li	The format argument is a printf(3) string, with additional arguments
d528 1
a528 1
 *\li	lctx is a valid logging context.
d530 1
a530 1
 *\li	The category and module arguments must have ids that are in the
d534 1
a534 1
 *\li	level != #ISC_LOG_DYNAMIC.  ISC_LOG_DYNAMIC is used only to define
d538 1
a538 1
 *\li	format != NULL.
d541 1
a541 1
 *\li	The log message is written to every channel associated with the
d545 1
a545 1
 *\li	Nothing.  Failure to log a message is not construed as a
d548 1
d550 1
a550 1
isc_log_write(isc_log_t *lctx, isc_logcategory_t *category,
d552 3
a554 5
	      const char *format, ...)

ISC_FORMAT_PRINTF(5, 6);

/*%
d558 1
a558 1
 *\li	lctx can be NULL; this is allowed so that programs which use
d562 1
a562 1
 *\li	The format argument is a printf(3) string, with additional arguments
d566 1
a566 1
 *\li	lctx is a valid logging context.
d568 1
a568 1
 *\li	The category and module arguments must have ids that are in the
d572 1
a572 1
 *\li	level != #ISC_LOG_DYNAMIC.  ISC_LOG_DYNAMIC is used only to define
d576 1
a576 1
 *\li	format != NULL.
d579 1
a579 1
 *\li	The log message is written to every channel associated with the
d583 1
a583 1
 *\li	Nothing.  Failure to log a message is not construed as a
a585 6
void
isc_log_vwrite(isc_log_t *lctx, isc_logcategory_t *category,
	       isc_logmodule_t *module, int level,
	       const char *format, va_list args)

ISC_FORMAT_PRINTF(5, 0);
a586 5
/*%
 * Write a message to the log channels, pruning duplicates that occur within
 * a configurable amount of seconds (see isc_log_[sg]etduplicateinterval).
 * This function is otherwise identical to isc_log_write().
 */
a589 1

d591 1
a591 2

/*%
d594 1
a594 1
 * This function is otherwise identical to isc_log_vwrite().
d596 1
a600 1

d602 5
a607 15
/*%
 * These are four internationalized versions of the the isc_log_[v]write[1]
 * functions.  
 *
 * The only difference is that they take arguments for a message
 * catalog, message set, and message number, all immediately preceding the
 * format argument.  The format argument becomes the default text, a la
 * isc_msgcat_get.  If the message catalog is NULL, no lookup is attempted
 * for a message -- which makes the message set and message number irrelevant,
 * and the non-internationalized call should have probably been used instead.
 *
 * Yes, that means there are now *eight* interfaces to logging a message.
 * Sheesh.   Make the madness stop!
 */
/*@@{*/
d635 12
a646 1
/*@@}*/
d650 1
a650 1
/*%<
d654 1
a654 1
 *\li	Setting the debugging level to 0 disables debugging log messages.
d657 1
a657 1
 *\li	lctx is a valid logging context.
d660 1
a660 1
 *\li	The debugging level is set to the requested value.
d665 1
a665 1
/*%<
d669 1
a669 1
 *\li	This is provided so that a program can have a notion of
d673 1
a673 1
 *\li	A return value of 0 indicates that debugging messages are disabled.
d676 1
a676 1
 *\li	lctx is a valid logging context.
d679 1
a679 1
 *\li	The current logging debugging level is returned.
d684 1
a684 1
/*%<
d688 1
a688 1
 * If #ISC_FALSE is returned, it is guaranteed that nothing would
d695 1
a695 1
/*%<
d700 1
a700 1
 *\li	Increasing the duplicate interval from X to Y will not necessarily
d710 1
a710 1
 *\li	lctx is a valid logging context.
d715 1
a715 1
/*%<
d719 1
a719 1
 *\li	lctx is a valid logging context.
d722 1
a722 1
 *\li	The current duplicate filtering interval.
d727 2
a728 2
/*%<
 * Set the program name or other identifier for #ISC_LOG_PRINTTAG.
d731 1
a731 1
 *\li	lcfg is a valid logging configuration.
d734 2
a735 2
 *\li	If this function has not set the tag to a non-NULL, non-empty value,
 *	then the #ISC_LOG_PRINTTAG channel flag will not print anything.
d740 2
a741 2
 *\li	Setting the tag to NULL or the empty string will also cause the
 *	#ISC_LOG_PRINTTAG channel flag to not print anything.  If tag equals the
d745 2
a746 2
 *\li	#ISC_R_SUCCESS	Success
 *\li	#ISC_R_NOMEMORY  Resource Limit: Out of memory
d755 2
a756 2
/*%<
 * Get the current identifier printed with #ISC_LOG_PRINTTAG.
d759 1
a759 1
 *\li	lcfg is a valid logging configuration.
d762 1
a762 1
 *\li	Since isc_log_settag() will not associate a zero-length string
d769 1
a769 1
 *\li	A pointer to the current identifier, or NULL if none has been set.
d774 1
a774 1
/*%<
d778 1
a778 1
 *\li	XXXDCL NT
a781 2
 *
 * \code
a791 1
 * \endcode
d793 1
a793 1
 *\li	Zero effort has been made (yet) to accomodate systems with openlog()
d797 1
a797 1
 *\li	It is necessary to call isc_log_opensyslog() to initialize
d804 1
a804 1
 *\li	Nothing.
d807 1
a807 1
 *\li	openlog() is called to initialize the syslog system.
d812 2
a813 2
/*%<
 * Close all open files used by #ISC_LOG_TOFILE channels.
d816 1
a816 1
 *\li	This function is provided for programs that want to use their own
d819 1
a819 1
 *	a channel which used #ISC_LOG_ROLLNEVER, then once a day would
d822 1
a822 1
 *\li	#ISC_LOG_TOFILEDESC channels are unaffected.
d825 1
a825 1
 *\li	lctx is a valid context.
d828 1
a828 1
 *\li	The open files are closed and will be reopened when they are
d834 1
a834 1
/*%<
d838 1
a838 1
 *\li	The string name of a category is not required to be unique.
d841 2
a842 2
 *\li	lctx is a valid context.
 *\li	name is not NULL.
d845 1
a845 1
 *\li	A pointer to the _first_ isc_logcategory_t structure used by "name".
d847 1
a847 1
 *\li	NULL if no category exists by that name.
d852 1
a852 1
/*%<
d856 1
a856 1
 *\li	The string name of a module is not required to be unique.
d859 2
a860 2
 *\li	lctx is a valid context.
 *\li	name is not NULL.
d863 1
a863 1
 *\li	A pointer to the _first_ isc_logmodule_t structure used by "name".
d865 1
a865 1
 *\li	NULL if no module exists by that name.
d870 1
a870 1
/*%<
d874 1
a874 1
 *\li	lctx be a valid context.
@


