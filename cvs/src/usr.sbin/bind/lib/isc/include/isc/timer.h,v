head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.36
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.38
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.34
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.30
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.32
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.24
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.28
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.26
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.22
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.20
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.18
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.16
	OPENBSD_5_0:1.2.0.14
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.12
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.8
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	BIND_9_4_2_P1:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	OPENBSD_4_3_BASE:1.1.1.4
	BIND_9_4_2:1.1.1.4
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	BIND_9_3_4:1.1.1.3
	BIND_9_3_3:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	BIND_9_3_2:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.6
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.4
	OPENBSD_3_8_BASE:1.1.1.2
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2008.08.04.16.34.20;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.07.38;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.38;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.45;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.04.05.16.44.17;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.12.09.12.34.13;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update to BIND 9.4.2-P2 and adapt our dynamic select changes.  OK deraadt@@
@
text
@/*
 * Copyright (C) 2004, 2005, 2008  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1998-2002  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: timer.h,v 1.31.18.3.52.2 2008/07/24 23:48:09 tbox Exp $ */

#ifndef ISC_TIMER_H
#define ISC_TIMER_H 1

/*****
 ***** Module Info
 *****/

/*! \file
 * \brief Provides timers which are event sources in the task system.
 *
 * Three types of timers are supported:
 *
 *\li	'ticker' timers generate a periodic tick event.
 *
 *\li	'once' timers generate an idle timeout event if they are idle for too
 *	long, and generate a life timeout event if their lifetime expires.
 *	They are used to implement both (possibly expiring) idle timers and
 *	'one-shot' timers.
 *
 *\li	'limited' timers generate a periodic tick event until they reach
 *	their lifetime when they generate a life timeout event.
 *
 *\li	'inactive' timers generate no events.
 *
 * Timers can change type.  It is typical to create a timer as
 * an 'inactive' timer and then change it into a 'ticker' or
 * 'once' timer.
 *
 *\li MP:
 *	The module ensures appropriate synchronization of data structures it
 *	creates and manipulates.
 *	Clients of this module must not be holding a timer's task's lock when
 *	making a call that affects that timer.  Failure to follow this rule
 *	can result in deadlock.
 *	The caller must ensure that isc_timermgr_destroy() is called only
 *	once for a given manager.
 *
 * \li Reliability:
 *	No anticipated impact.
 *
 * \li Resources:
 *	TBS
 *
 * \li Security:
 *	No anticipated impact.
 *
 * \li Standards:
 *	None.
 */


/***
 *** Imports
 ***/

#include <isc/types.h>
#include <isc/event.h>
#include <isc/eventclass.h>
#include <isc/lang.h>
#include <isc/time.h>

ISC_LANG_BEGINDECLS

/***
 *** Types
 ***/

/*% Timer Type */
typedef enum {
	isc_timertype_ticker = 0, 	/*%< Ticker */
	isc_timertype_once = 1, 	/*%< Once */
	isc_timertype_limited = 2, 	/*%< Limited */
	isc_timertype_inactive = 3 	/*%< Inactive */
} isc_timertype_t;

typedef struct isc_timerevent {
	struct isc_event	common;
	isc_time_t		due;
} isc_timerevent_t;

#define ISC_TIMEREVENT_FIRSTEVENT	(ISC_EVENTCLASS_TIMER + 0)
#define ISC_TIMEREVENT_TICK		(ISC_EVENTCLASS_TIMER + 1)
#define ISC_TIMEREVENT_IDLE		(ISC_EVENTCLASS_TIMER + 2)
#define ISC_TIMEREVENT_LIFE		(ISC_EVENTCLASS_TIMER + 3)
#define ISC_TIMEREVENT_LASTEVENT	(ISC_EVENTCLASS_TIMER + 65535)

/***
 *** Timer and Timer Manager Functions
 ***
 *** Note: all Ensures conditions apply only if the result is success for
 *** those functions which return an isc_result_t.
 ***/

isc_result_t
isc_timer_create(isc_timermgr_t *manager,
		 isc_timertype_t type,
		 isc_time_t *expires,
		 isc_interval_t *interval,
		 isc_task_t *task,
		 isc_taskaction_t action,
		 const void *arg,
		 isc_timer_t **timerp);
/*%<
 * Create a new 'type' timer managed by 'manager'.  The timers parameters
 * are specified by 'expires' and 'interval'.  Events will be posted to
 * 'task' and when dispatched 'action' will be called with 'arg' as the
 * arg value.  The new timer is returned in 'timerp'.
 *
 * Notes:
 *
 *\li	For ticker timers, the timer will generate a 'tick' event every
 *	'interval' seconds.  The value of 'expires' is ignored.
 *
 *\li	For once timers, 'expires' specifies the time when a life timeout
 *	event should be generated.  If 'expires' is 0 (the epoch), then no life
 *	timeout will be generated.  'interval' specifies how long the timer
 *	can be idle before it generates an idle timeout.  If 0, then no
 *	idle timeout will be generated.
 *
 *\li	If 'expires' is NULL, the epoch will be used.
 *
 *	If 'interval' is NULL, the zero interval will be used.
 *
 * Requires:
 *
 *\li	'manager' is a valid manager
 *
 *\li	'task' is a valid task
 *
 *\li	'action' is a valid action
 *
 *\li	'expires' points to a valid time, or is NULL.
 *
 *\li	'interval' points to a valid interval, or is NULL.
 *
 *\li	type == isc_timertype_inactive ||
 *	('expires' and 'interval' are not both 0)
 *
 *\li	'timerp' is a valid pointer, and *timerp == NULL
 *
 * Ensures:
 *
 *\li	'*timerp' is attached to the newly created timer
 *
 *\li	The timer is attached to the task
 *
 *\li	An idle timeout will not be generated until at least Now + the
 *	timer's interval if 'timer' is a once timer with a non-zero
 *	interval.
 *
 * Returns:
 *
 *\li	Success
 *\li	No memory
 *\li	Unexpected error
 */

isc_result_t
isc_timer_reset(isc_timer_t *timer,
		isc_timertype_t type,
		isc_time_t *expires,
		isc_interval_t *interval,
		isc_boolean_t purge);
/*%<
 * Change the timer's type, expires, and interval values to the given
 * values.  If 'purge' is TRUE, any pending events from this timer
 * are purged from its task's event queue.
 *
 * Notes:
 *
 *\li	If 'expires' is NULL, the epoch will be used.
 *
 *\li	If 'interval' is NULL, the zero interval will be used.
 *
 * Requires:
 *
 *\li	'timer' is a valid timer
 *
 *\li	The same requirements that isc_timer_create() imposes on 'type',
 *	'expires' and 'interval' apply.
 *
 * Ensures:
 *
 *\li	An idle timeout will not be generated until at least Now + the
 *	timer's interval if 'timer' is a once timer with a non-zero
 *	interval.
 *
 * Returns:
 *
 *\li	Success
 *\li	No memory
 *\li	Unexpected error
 */

isc_result_t
isc_timer_touch(isc_timer_t *timer);
/*%<
 * Set the last-touched time of 'timer' to the current time.
 *
 * Requires:
 *
 *\li	'timer' is a valid once timer.
 *
 * Ensures:
 *
 *\li	An idle timeout will not be generated until at least Now + the
 *	timer's interval if 'timer' is a once timer with a non-zero
 *	interval.
 *
 * Returns:
 *
 *\li	Success
 *\li	Unexpected error
 */

void
isc_timer_attach(isc_timer_t *timer, isc_timer_t **timerp);
/*%<
 * Attach *timerp to timer.
 *
 * Requires:
 *
 *\li	'timer' is a valid timer.
 *
 *\li	'timerp' points to a NULL timer.
 *
 * Ensures:
 *
 *\li	*timerp is attached to timer.
 */

void
isc_timer_detach(isc_timer_t **timerp);
/*%<
 * Detach *timerp from its timer.
 *
 * Requires:
 *
 *\li	'timerp' points to a valid timer.
 *
 * Ensures:
 *
 *\li	*timerp is NULL.
 *
 *\li	If '*timerp' is the last reference to the timer,
 *	then:
 *
 *\code
 *		The timer will be shutdown
 *
 *		The timer will detach from its task
 *
 *		All resources used by the timer have been freed
 *
 *		Any events already posted by the timer will be purged.
 *		Therefore, if isc_timer_detach() is called in the context
 *		of the timer's task, it is guaranteed that no more
 *		timer event callbacks will run after the call.
 *\endcode
 */

isc_timertype_t
isc_timer_gettype(isc_timer_t *timer);
/*%<
 * Return the timer type.
 *
 * Requires:
 *
 *\li	'timer' to be a valid timer.
 */

isc_result_t
isc_timermgr_create(isc_mem_t *mctx, isc_timermgr_t **managerp);
/*%<
 * Create a timer manager.
 *
 * Notes:
 *
 *\li	All memory will be allocated in memory context 'mctx'.
 *
 * Requires:
 *
 *\li	'mctx' is a valid memory context.
 *
 *\li	'managerp' points to a NULL isc_timermgr_t.
 *
 * Ensures:
 *
 *\li	'*managerp' is a valid isc_timermgr_t.
 *
 * Returns:
 *
 *\li	Success
 *\li	No memory
 *\li	Unexpected error
 */

void
isc_timermgr_destroy(isc_timermgr_t **managerp);
/*%<
 * Destroy a timer manager.
 *
 * Notes:
 *
 *\li	This routine blocks until there are no timers left in the manager,
 *	so if the caller holds any timer references using the manager, it
 *	must detach them before calling isc_timermgr_destroy() or it will
 *	block forever.
 *
 * Requires:
 *
 *\li	'*managerp' is a valid isc_timermgr_t.
 *
 * Ensures:
 *
 *\li	*managerp == NULL
 *
 *\li	All resources used by the manager have been freed.
 */

void isc_timermgr_poke(isc_timermgr_t *m);

ISC_LANG_ENDDECLS

#endif /* ISC_TIMER_H */
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
 * Copyright (C) 1998-2001  Internet Software Consortium.
d5 1
a5 1
 * Permission to use, copy, modify, and distribute this software for any
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: timer.h,v 1.28 2001/01/09 21:57:41 bwelling Exp $ */
d27 2
a28 4
/*
 * Timers
 *
 * Provides timers which are event sources in the task system.
d32 1
a32 1
 *	'ticker' timers generate a periodic tick event.
d34 1
a34 1
 *	'once' timers generate an idle timeout event if they are idle for too
d39 4
a42 1
 *	'inactive' timers generate no events.
d48 1
a48 1
 * MP:
a50 1
 *
a53 1
 *
d57 1
a57 1
 * Reliability:
d60 2
a61 2
 * Resources:
 *	<TBS>
d63 1
a63 1
 * Security:
d66 1
a66 1
 * Standards:
d79 1
d87 1
d89 4
a92 3
	isc_timertype_ticker = 0,
	isc_timertype_once = 1,
	isc_timertype_inactive = 2
d97 1
d122 1
a122 1
/*
d130 1
a130 1
 *	For ticker timers, the timer will generate a 'tick' event every
d133 1
a133 1
 *	For once timers, 'expires' specifies the time when a life timeout
d139 1
a139 1
 *	If 'expires' is NULL, the epoch will be used.
d145 1
a145 1
 *	'manager' is a valid manager
d147 1
a147 1
 *	'task' is a valid task
d149 1
a149 1
 *	'action' is a valid action
d151 1
a151 1
 *	'expires' points to a valid time, or is NULL.
d153 1
a153 1
 *	'interval' points to a valid interval, or is NULL.
d155 1
a155 1
 *	type == isc_timertype_inactive ||
d158 1
a158 1
 *	'timerp' is a valid pointer, and *timerp == NULL
d162 1
a162 1
 *	'*timerp' is attached to the newly created timer
d164 1
a164 1
 *	The timer is attached to the task
d166 1
a166 1
 *	An idle timeout will not be generated until at least Now + the
d172 3
a174 3
 *	Success
 *	No memory
 *	Unexpected error
d183 1
a183 1
/*
d190 1
a190 1
 *	If 'expires' is NULL, the epoch will be used.
d192 1
a192 1
 *	If 'interval' is NULL, the zero interval will be used.
d196 1
a196 1
 *	'timer' is a valid timer
d198 1
a198 1
 *	The same requirements that isc_timer_create() imposes on 'type',
d203 1
a203 1
 *	An idle timeout will not be generated until at least Now + the
d209 3
a211 3
 *	Success
 *	No memory
 *	Unexpected error
d216 1
a216 1
/*
d221 1
a221 1
 *	'timer' is a valid once timer.
d225 1
a225 1
 *	An idle timeout will not be generated until at least Now + the
d231 2
a232 2
 *	Success
 *	Unexpected error
d237 1
a237 1
/*
d242 1
a242 1
 *	'timer' is a valid timer.
d244 1
a244 1
 *	'timerp' points to a NULL timer.
d248 1
a248 1
 *	*timerp is attached to timer.
d253 1
a253 1
/*
d258 1
a258 1
 *	'timerp' points to a valid timer.
d262 1
a262 1
 *	*timerp is NULL.
d264 1
a264 1
 *	If '*timerp' is the last reference to the timer,
d267 1
d278 11
d293 1
a293 1
/*
d298 1
a298 1
 *	All memory will be allocated in memory context 'mctx'.
d302 1
a302 1
 *	'mctx' is a valid memory context.
d304 1
a304 1
 *	'managerp' points to a NULL isc_timermgr_t.
d308 1
a308 1
 *	'*managerp' is a valid isc_timermgr_t.
d312 3
a314 3
 *	Success
 *	No memory
 *	Unexpected error
d319 1
a319 1
/*
d324 1
a324 1
 *	This routine blocks until there are no timers left in the manager,
d331 1
a331 1
 *	'*managerp' is a valid isc_timermgr_t.
d335 1
a335 1
 *	*managerp == NULL
d337 1
a337 1
 *	All resources used by the manager have been freed.
d339 2
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1998-2002  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: timer.h,v 1.28.12.4 2004/03/08 09:04:53 marka Exp $ */
a40 3
 *	'limited' timers generate a periodic tick event until they reach
 *	their lifetime when they generate a life timeout event.
 *
d90 1
a90 2
	isc_timertype_limited = 2,
	isc_timertype_inactive = 3
a276 3
isc_timer_gettype(isc_timer_t *timer);

isc_result_t
a323 2

void isc_timermgr_poke(isc_timermgr_t *m);
@


1.1.1.3
log
@ISC BIND release 9.3.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: timer.h,v 1.28.12.6 2005/10/27 00:27:30 marka Exp $ */
d280 1
a280 1
isc_timertype_t
a281 7
/*%<
 * Return the timer type.
 *
 * Requires:
 *
 *\li	'timer' to be a valid timer.
 */
@


1.1.1.4
log
@ISC BIND release 9.4.2
@
text
@d18 1
a18 1
/* $ISC: timer.h,v 1.31.18.3 2005/10/26 06:50:50 marka Exp $ */
d27 4
a30 2
/*! \file
 * \brief Provides timers which are event sources in the task system.
d34 1
a34 1
 *\li	'ticker' timers generate a periodic tick event.
d36 1
a36 1
 *\li	'once' timers generate an idle timeout event if they are idle for too
d41 1
a41 1
 *\li	'limited' timers generate a periodic tick event until they reach
d44 1
a44 1
 *\li	'inactive' timers generate no events.
d50 1
a50 1
 *\li MP:
d53 1
d57 1
d61 1
a61 1
 * \li Reliability:
d64 2
a65 2
 * \li Resources:
 *	TBS
d67 1
a67 1
 * \li Security:
d70 1
a70 1
 * \li Standards:
a89 1
/*% Timer Type */
d91 4
a94 4
	isc_timertype_ticker = 0, 	/*%< Ticker */
	isc_timertype_once = 1, 	/*%< Once */
	isc_timertype_limited = 2, 	/*%< Limited */
	isc_timertype_inactive = 3 	/*%< Inactive */
d123 1
a123 1
/*%<
d131 1
a131 1
 *\li	For ticker timers, the timer will generate a 'tick' event every
d134 1
a134 1
 *\li	For once timers, 'expires' specifies the time when a life timeout
d140 1
a140 1
 *\li	If 'expires' is NULL, the epoch will be used.
d146 1
a146 1
 *\li	'manager' is a valid manager
d148 1
a148 1
 *\li	'task' is a valid task
d150 1
a150 1
 *\li	'action' is a valid action
d152 1
a152 1
 *\li	'expires' points to a valid time, or is NULL.
d154 1
a154 1
 *\li	'interval' points to a valid interval, or is NULL.
d156 1
a156 1
 *\li	type == isc_timertype_inactive ||
d159 1
a159 1
 *\li	'timerp' is a valid pointer, and *timerp == NULL
d163 1
a163 1
 *\li	'*timerp' is attached to the newly created timer
d165 1
a165 1
 *\li	The timer is attached to the task
d167 1
a167 1
 *\li	An idle timeout will not be generated until at least Now + the
d173 3
a175 3
 *\li	Success
 *\li	No memory
 *\li	Unexpected error
d184 1
a184 1
/*%<
d191 1
a191 1
 *\li	If 'expires' is NULL, the epoch will be used.
d193 1
a193 1
 *\li	If 'interval' is NULL, the zero interval will be used.
d197 1
a197 1
 *\li	'timer' is a valid timer
d199 1
a199 1
 *\li	The same requirements that isc_timer_create() imposes on 'type',
d204 1
a204 1
 *\li	An idle timeout will not be generated until at least Now + the
d210 3
a212 3
 *\li	Success
 *\li	No memory
 *\li	Unexpected error
d217 1
a217 1
/*%<
d222 1
a222 1
 *\li	'timer' is a valid once timer.
d226 1
a226 1
 *\li	An idle timeout will not be generated until at least Now + the
d232 2
a233 2
 *\li	Success
 *\li	Unexpected error
d238 1
a238 1
/*%<
d243 1
a243 1
 *\li	'timer' is a valid timer.
d245 1
a245 1
 *\li	'timerp' points to a NULL timer.
d249 1
a249 1
 *\li	*timerp is attached to timer.
d254 1
a254 1
/*%<
d259 1
a259 1
 *\li	'timerp' points to a valid timer.
d263 1
a263 1
 *\li	*timerp is NULL.
d265 1
a265 1
 *\li	If '*timerp' is the last reference to the timer,
a267 1
 *\code
a277 1
 *\endcode
d292 1
a292 1
/*%<
d297 1
a297 1
 *\li	All memory will be allocated in memory context 'mctx'.
d301 1
a301 1
 *\li	'mctx' is a valid memory context.
d303 1
a303 1
 *\li	'managerp' points to a NULL isc_timermgr_t.
d307 1
a307 1
 *\li	'*managerp' is a valid isc_timermgr_t.
d311 3
a313 3
 *\li	Success
 *\li	No memory
 *\li	Unexpected error
d318 1
a318 1
/*%<
d323 1
a323 1
 *\li	This routine blocks until there are no timers left in the manager,
d330 1
a330 1
 *\li	'*managerp' is a valid isc_timermgr_t.
d334 1
a334 1
 *\li	*managerp == NULL
d336 1
a336 1
 *\li	All resources used by the manager have been freed.
@


