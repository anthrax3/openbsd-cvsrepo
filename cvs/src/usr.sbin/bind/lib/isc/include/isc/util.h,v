head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.38
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.36
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.32
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.34
	OPENBSD_5_8_BASE:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.26
	OPENBSD_5_7_BASE:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.30
	OPENBSD_5_6_BASE:1.1.1.3
	OPENBSD_5_5:1.1.1.3.0.28
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.24
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.22
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.20
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.18
	OPENBSD_5_0:1.1.1.3.0.16
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.14
	OPENBSD_4_9_BASE:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.12
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.8
	OPENBSD_4_7_BASE:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.10
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.6
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	BIND_9_4_2_P1:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	OPENBSD_4_3_BASE:1.1.1.3
	BIND_9_4_2:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.12
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.10
	OPENBSD_4_1_BASE:1.1.1.2
	BIND_9_3_4:1.1.1.2
	BIND_9_3_3:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.8
	OPENBSD_4_0_BASE:1.1.1.2
	BIND_9_3_2:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.6
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.4
	OPENBSD_3_8_BASE:1.1.1.2
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.01.20.21.07.38;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.38;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.45;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.09.12.34.14;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (C) 1998-2001  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: util.h,v 1.21 2001/01/09 21:57:43 bwelling Exp $ */

#ifndef ISC_UTIL_H
#define ISC_UTIL_H 1

/*
 * NOTE:
 *
 * This file is not to be included from any <isc/???.h> (or other) library
 * files.
 *
 * Including this file puts several macros in your name space that are
 * not protected (as all the other ISC functions/macros do) by prepending
 * ISC_ or isc_ to the name.
 */

/***
 *** General Macros.
 ***/

/*
 * Use this to hide unused function arguments.
 *
 * int
 * foo(char *bar)
 * {
 *	UNUSED(bar);
 * }
 */
#define UNUSED(x)      (void)(x)

#define ISC_MAX(a, b)  ((a) > (b) ? (a) : (b))
#define ISC_MIN(a, b)  ((a) < (b) ? (a) : (b))

/*
 * Use this to remove the const qualifier of a variable to assign it to
 * a non-const variable or pass it as a non-const function argument ...
 * but only when you are sure it won't then be changed!
 * This is necessary to sometimes shut up some compilers
 * (as with gcc -Wcast-qual) when there is just no other good way to avoid the
 * situation.
 */
#define DE_CONST(konst, var) \
	do { \
		union { const void *k; void *v; } _u; \
		_u.k = konst; \
		var = _u.v; \
	} while (0)

/*
 * We use macros instead of calling the routines directly because
 * the capital letters make the locking stand out.
 *
 * We RUNTIME_CHECK for success since in general there's no way
 * for us to continue if they fail.
 */

#ifdef ISC_UTIL_TRACEON
#define ISC_UTIL_TRACE(a) a
#include <stdio.h>		/* Required for fprintf/stderr when tracing. */
#include <isc/msgs.h>		/* Required for isc_msgcat when tracing. */
#else
#define ISC_UTIL_TRACE(a)
#endif

#include <isc/result.h>		/* Contractual promise. */

#define LOCK(lp) do { \
	ISC_UTIL_TRACE(fprintf(stderr, "%s %p %s %d\n", \
			       isc_msgcat_get(isc_msgcat, ISC_MSGSET_UTIL, \
					      ISC_MSG_LOCKING, "LOCKING"), \
			       (lp), __FILE__, __LINE__)); \
	RUNTIME_CHECK(isc_mutex_lock((lp)) == ISC_R_SUCCESS); \
	ISC_UTIL_TRACE(fprintf(stderr, "%s %p %s %d\n", \
			       isc_msgcat_get(isc_msgcat, ISC_MSGSET_UTIL, \
					      ISC_MSG_LOCKED, "LOCKED"), \
			       (lp), __FILE__, __LINE__)); \
	} while (0)
#define UNLOCK(lp) do { \
	RUNTIME_CHECK(isc_mutex_unlock((lp)) == ISC_R_SUCCESS); \
	ISC_UTIL_TRACE(fprintf(stderr, "%s %p %s %d\n", \
			       isc_msgcat_get(isc_msgcat, ISC_MSGSET_UTIL, \
					      ISC_MSG_UNLOCKED, "UNLOCKED"), \
			       (lp), __FILE__, __LINE__)); \
	} while (0)
#define ISLOCKED(lp) (1)
#define DESTROYLOCK(lp) \
	RUNTIME_CHECK(isc_mutex_destroy((lp)) == ISC_R_SUCCESS)


#define BROADCAST(cvp) do { \
	ISC_UTIL_TRACE(fprintf(stderr, "%s %p %s %d\n", \
			       isc_msgcat_get(isc_msgcat, ISC_MSGSET_UTIL, \
					      ISC_MSG_BROADCAST, "BROADCAST"),\
			       (cvp), __FILE__, __LINE__)); \
	RUNTIME_CHECK(isc_condition_broadcast((cvp)) == ISC_R_SUCCESS); \
	} while (0)
#define SIGNAL(cvp) do { \
	ISC_UTIL_TRACE(fprintf(stderr, "%s %p %s %d\n", \
			       isc_msgcat_get(isc_msgcat, ISC_MSGSET_UTIL, \
					      ISC_MSG_SIGNAL, "SIGNAL"), \
			       (cvp), __FILE__, __LINE__)); \
	RUNTIME_CHECK(isc_condition_signal((cvp)) == ISC_R_SUCCESS); \
	} while (0)
#define WAIT(cvp, lp) do { \
	ISC_UTIL_TRACE(fprintf(stderr, "%s %p %s %p %s %d\n", \
			       isc_msgcat_get(isc_msgcat, ISC_MSGSET_UTIL, \
					      ISC_MSG_UTILWAIT, "WAIT"), \
			       (cvp), \
			       isc_msgcat_get(isc_msgcat, ISC_MSGSET_UTIL, \
					      ISC_MSG_LOCK, "LOCK"), \
			       (lp), __FILE__, __LINE__)); \
	RUNTIME_CHECK(isc_condition_wait((cvp), (lp)) == ISC_R_SUCCESS); \
	ISC_UTIL_TRACE(fprintf(stderr, "%s %p %s %p %s %d\n", \
			       isc_msgcat_get(isc_msgcat, ISC_MSGSET_UTIL, \
					      ISC_MSG_WAITED, "WAITED"), \
			       (cvp), \
			       isc_msgcat_get(isc_msgcat, ISC_MSGSET_UTIL, \
					      ISC_MSG_LOCKED, "LOCKED"), \
			       (lp), __FILE__, __LINE__)); \
	} while (0)

/*
 * isc_condition_waituntil can return ISC_R_TIMEDOUT, so we
 * don't RUNTIME_CHECK the result.
 *
 *  XXX Also, can't really debug this then...
 */

#define WAITUNTIL(cvp, lp, tp) \
	isc_condition_waituntil((cvp), (lp), (tp))

#define RWLOCK(lp, t) do { \
	ISC_UTIL_TRACE(fprintf(stderr, "%s %p, %d %s %d\n", \
			       isc_msgcat_get(isc_msgcat, ISC_MSGSET_UTIL, \
					      ISC_MSG_RWLOCK, "RWLOCK"), \
			       (lp), (t), __FILE__, __LINE__)); \
	RUNTIME_CHECK(isc_rwlock_lock((lp), (t)) == ISC_R_SUCCESS); \
	ISC_UTIL_TRACE(fprintf(stderr, "%s %p, %d %s %d\n", \
			       isc_msgcat_get(isc_msgcat, ISC_MSGSET_UTIL, \
					      ISC_MSG_RWLOCKED, "RWLOCKED"), \
			       (lp), (t), __FILE__, __LINE__)); \
	} while (0)
#define RWUNLOCK(lp, t) do { \
	ISC_UTIL_TRACE(fprintf(stderr, "%s %p, %d %s %d\n", \
			       isc_msgcat_get(isc_msgcat, ISC_MSGSET_UTIL, \
					      ISC_MSG_RWUNLOCK, "RWUNLOCK"), \
			       (lp), (t), __FILE__, __LINE__)); \
	RUNTIME_CHECK(isc_rwlock_unlock((lp), (t)) == ISC_R_SUCCESS); \
	} while (0)

/*
 * List Macros.
 */
#include <isc/list.h>		/* Contractual promise. */

#define LIST(type)			ISC_LIST(type)
#define INIT_LIST(type)			ISC_LIST_INIT(type)
#define LINK(type)			ISC_LINK(type)
#define INIT_LINK(elt, link)		ISC_LINK_INIT(elt, link)
#define HEAD(list)			ISC_LIST_HEAD(list)
#define TAIL(list)			ISC_LIST_TAIL(list)
#define EMPTY(list)			ISC_LIST_EMPTY(list)
#define PREV(elt, link)			ISC_LIST_PREV(elt, link)
#define NEXT(elt, link)			ISC_LIST_NEXT(elt, link)
#define APPEND(list, elt, link)		ISC_LIST_APPEND(list, elt, link)
#define PREPEND(list, elt, link)	ISC_LIST_PREPEND(list, elt, link)
#define UNLINK(list, elt, link)		ISC_LIST_UNLINK(list, elt, link)
#define ENQUEUE(list, elt, link)	ISC_LIST_APPEND(list, elt, link)
#define DEQUEUE(list, elt, link)	ISC_LIST_UNLINK(list, elt, link)
#define INSERTBEFORE(li, b, e, ln)	ISC_LIST_INSERTBEFORE(li, b, e, ln)
#define INSERTAFTER(li, a, e, ln)	ISC_LIST_INSERTAFTER(li, a, e, ln)
#define APPENDLIST(list1, list2, link)	ISC_LIST_APPENDLIST(list1, list2, link)

/*
 * Assertions
 */
#include <isc/assertions.h>	/* Contractual promise. */

#define REQUIRE(e)			ISC_REQUIRE(e)
#define ENSURE(e)			ISC_ENSURE(e)
#define INSIST(e)			ISC_INSIST(e)
#define INVARIANT(e)			ISC_INVARIANT(e)

/*
 * Errors
 */
#include <isc/error.h>		/* Contractual promise. */

#define UNEXPECTED_ERROR		isc_error_unexpected
#define FATAL_ERROR			isc_error_fatal
#define RUNTIME_CHECK(cond)		ISC_ERROR_RUNTIMECHECK(cond)

#endif /* ISC_UTIL_H */
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@a1 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: util.h,v 1.21.12.5 2004/03/08 09:04:53 marka Exp $ */
a67 6
 * Use this in translation units that would otherwise be empty, to
 * suppress compiler warnings.
 */
#define EMPTY_TRANSLATION_UNIT static void isc__empty(void) { isc__empty(); }

/*
a168 3
#define DESTROYMUTEXBLOCK(bp, n) \
	RUNTIME_CHECK(isc_mutexblock_destroy((bp), (n)) == ISC_R_SUCCESS)

a209 5

/*
 * Time
 */
#define TIME_NOW(tp) 	RUNTIME_CHECK(isc_time_now((tp)) == ISC_R_SUCCESS)
@


1.1.1.3
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: util.h,v 1.24.18.2 2005/04/29 00:17:04 marka Exp $ */
d23 1
a23 1
/*! \file util.h
a28 1
 * \brief
d38 1
a38 1
/*%
d40 1
a40 1
 * \code
a45 1
 * \endcode
d52 1
a52 1
/*%
d67 1
a67 1
/*%
d73 1
a73 1
/*%
d76 1
a205 1
/*% Require Assertion */
a206 1
/*% Ensure Assertion */
a207 1
/*% Insist Assertion */
a208 1
/*% Invariant Assertion */
a215 1
/*% Unexpected Error */
a216 1
/*% Fatal Error */
a217 1
/*% Runtime Check */
d220 1
a220 1
/*%
@


