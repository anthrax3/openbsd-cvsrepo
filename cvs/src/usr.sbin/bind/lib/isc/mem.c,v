head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.36
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.32
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.34
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.26
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.30
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.28
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.24
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.22
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.20
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.18
	OPENBSD_5_0:1.6.0.16
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.14
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.12
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.8
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.10
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.6
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	BIND_9_4_2_P1:1.1.1.4
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	BIND_9_4_2:1.1.1.4
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	BIND_9_3_4:1.1.1.3
	BIND_9_3_3:1.1.1.3
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	BIND_9_3_2:1.1.1.3
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2007.12.09.13.39.44;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.05.17.36.35;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.28.17.14.07;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.18.14.14.07;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.27.19.08.23;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.07.34;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.34;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.35;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.04.05.16.44.10;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.12.09.12.34.02;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.6
log
@resolve conflicts
@
text
@/*
 * Copyright (C) 2004-2007  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1997-2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: mem.c,v 1.116.18.18 2007/10/30 23:31:43 marka Exp $ */

/*! \file */

#include <config.h>

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

#include <limits.h>

#include <isc/magic.h>
#include <isc/mem.h>
#include <isc/msgs.h>
#include <isc/once.h>
#include <isc/ondestroy.h>
#include <isc/string.h>

#include <isc/mutex.h>
#include <isc/util.h>

#define MCTXLOCK(m, l) if (((m)->flags & ISC_MEMFLAG_NOLOCK) == 0) LOCK(l)
#define MCTXUNLOCK(m, l) if (((m)->flags & ISC_MEMFLAG_NOLOCK) == 0) UNLOCK(l)

#ifndef ISC_MEM_DEBUGGING
#define ISC_MEM_DEBUGGING 0
#endif
LIBISC_EXTERNAL_DATA unsigned int isc_mem_debugging = ISC_MEM_DEBUGGING;

/*
 * Constants.
 */

#define DEF_MAX_SIZE		1100
#define DEF_MEM_TARGET		4096
#define ALIGNMENT_SIZE		8		/*%< must be a power of 2 */
#define NUM_BASIC_BLOCKS	64		/*%< must be > 1 */
#define TABLE_INCREMENT		1024
#define DEBUGLIST_COUNT		1024

/*
 * Types.
 */
#if ISC_MEM_TRACKLINES
typedef struct debuglink debuglink_t;
struct debuglink {
	ISC_LINK(debuglink_t)	link;
	const void	       *ptr[DEBUGLIST_COUNT];
	unsigned int		size[DEBUGLIST_COUNT];
	const char	       *file[DEBUGLIST_COUNT];
	unsigned int		line[DEBUGLIST_COUNT];
	unsigned int		count;
};

#define FLARG_PASS	, file, line
#define FLARG		, const char *file, int line
#else
#define FLARG_PASS
#define FLARG
#endif

typedef struct element element;
struct element {
	element *		next;
};

typedef struct {
	/*!
	 * This structure must be ALIGNMENT_SIZE bytes.
	 */
	union {
		size_t		size;
		isc_mem_t	*ctx;
		char		bytes[ALIGNMENT_SIZE];
	} u;
} size_info;

struct stats {
	unsigned long		gets;
	unsigned long		totalgets;
	unsigned long		blocks;
	unsigned long		freefrags;
};

#define MEM_MAGIC		ISC_MAGIC('M', 'e', 'm', 'C')
#define VALID_CONTEXT(c)	ISC_MAGIC_VALID(c, MEM_MAGIC)

#if ISC_MEM_TRACKLINES
typedef ISC_LIST(debuglink_t)	debuglist_t;
#endif

/* List of all active memory contexts. */

static ISC_LIST(isc_mem_t)	contexts;
static isc_once_t		once = ISC_ONCE_INIT;
static isc_mutex_t		lock;

struct isc_mem {
	unsigned int		magic;
	isc_ondestroy_t		ondestroy;
	unsigned int		flags;
	isc_mutex_t		lock;
	isc_memalloc_t		memalloc;
	isc_memfree_t		memfree;
	void *			arg;
	size_t			max_size;
	isc_boolean_t		checkfree;
	struct stats *		stats;
	unsigned int		references;
	size_t			quota;
	size_t			total;
	size_t			inuse;
	size_t			maxinuse;
	size_t			hi_water;
	size_t			lo_water;
	isc_boolean_t		hi_called;
	isc_mem_water_t		water;
	void *			water_arg;
	ISC_LIST(isc_mempool_t)	pools;

	/*  ISC_MEMFLAG_INTERNAL */
	size_t			mem_target;
	element **		freelists;
	element *		basic_blocks;
	unsigned char **	basic_table;
	unsigned int		basic_table_count;
	unsigned int		basic_table_size;
	unsigned char *		lowest;
	unsigned char *		highest;

#if ISC_MEM_TRACKLINES
	debuglist_t *	 	debuglist;
#endif

	unsigned int		memalloc_failures;
	ISC_LINK(isc_mem_t)	link;
};

#define MEMPOOL_MAGIC		ISC_MAGIC('M', 'E', 'M', 'p')
#define VALID_MEMPOOL(c)	ISC_MAGIC_VALID(c, MEMPOOL_MAGIC)

struct isc_mempool {
	/* always unlocked */
	unsigned int	magic;		/*%< magic number */
	isc_mutex_t    *lock;		/*%< optional lock */
	isc_mem_t      *mctx;		/*%< our memory context */
	/*%< locked via the memory context's lock */
	ISC_LINK(isc_mempool_t)	link;	/*%< next pool in this mem context */
	/*%< optionally locked from here down */
	element	       *items;		/*%< low water item list */
	size_t		size;		/*%< size of each item on this pool */
	unsigned int	maxalloc;	/*%< max number of items allowed */
	unsigned int	allocated;	/*%< # of items currently given out */
	unsigned int	freecount;	/*%< # of items on reserved list */
	unsigned int	freemax;	/*%< # of items allowed on free list */
	unsigned int	fillcount;	/*%< # of items to fetch on each fill */
	/*%< Stats only. */
	unsigned int	gets;		/*%< # of requests to this pool */
	/*%< Debugging only. */
#if ISC_MEMPOOL_NAMES
	char		name[16];	/*%< printed name in stats reports */
#endif
};

/*
 * Private Inline-able.
 */

#if ! ISC_MEM_TRACKLINES
#define ADD_TRACE(a, b, c, d, e)
#define DELETE_TRACE(a, b, c, d, e)
#else
#define ADD_TRACE(a, b, c, d, e) \
	do { \
		if ((isc_mem_debugging & (ISC_MEM_DEBUGTRACE | \
					  ISC_MEM_DEBUGRECORD)) != 0 && \
		     b != NULL) \
		         add_trace_entry(a, b, c, d, e); \
	} while (0)
#define DELETE_TRACE(a, b, c, d, e)	delete_trace_entry(a, b, c, d, e)

static void
print_active(isc_mem_t *ctx, FILE *out);

/*!
 * mctx must be locked.
 */
static inline void
add_trace_entry(isc_mem_t *mctx, const void *ptr, unsigned int size
		FLARG)
{
	debuglink_t *dl;
	unsigned int i;

	if ((isc_mem_debugging & ISC_MEM_DEBUGTRACE) != 0)
		fprintf(stderr, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
					       ISC_MSG_ADDTRACE,
					       "add %p size %u "
					       "file %s line %u mctx %p\n"),
			ptr, size, file, line, mctx);

	if (mctx->debuglist == NULL)
		return;

	if (size > mctx->max_size)
		size = mctx->max_size;

	dl = ISC_LIST_HEAD(mctx->debuglist[size]);
	while (dl != NULL) {
		if (dl->count == DEBUGLIST_COUNT)
			goto next;
		for (i = 0; i < DEBUGLIST_COUNT; i++) {
			if (dl->ptr[i] == NULL) {
				dl->ptr[i] = ptr;
				dl->size[i] = size;
				dl->file[i] = file;
				dl->line[i] = line;
				dl->count++;
				return;
			}
		}
	next:
		dl = ISC_LIST_NEXT(dl, link);
	}

	dl = malloc(sizeof(debuglink_t));
	INSIST(dl != NULL);

	ISC_LINK_INIT(dl, link);
	for (i = 1; i < DEBUGLIST_COUNT; i++) {
		dl->ptr[i] = NULL;
		dl->size[i] = 0;
		dl->file[i] = NULL;
		dl->line[i] = 0;
	}

	dl->ptr[0] = ptr;
	dl->size[0] = size;
	dl->file[0] = file;
	dl->line[0] = line;
	dl->count = 1;

	ISC_LIST_PREPEND(mctx->debuglist[size], dl, link);
}

static inline void
delete_trace_entry(isc_mem_t *mctx, const void *ptr, unsigned int size,
		   const char *file, unsigned int line)
{
	debuglink_t *dl;
	unsigned int i;

	if ((isc_mem_debugging & ISC_MEM_DEBUGTRACE) != 0)
		fprintf(stderr, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
					       ISC_MSG_DELTRACE,
					       "del %p size %u "
					       "file %s line %u mctx %p\n"),
			ptr, size, file, line, mctx);

	if (mctx->debuglist == NULL)
		return;

	if (size > mctx->max_size)
		size = mctx->max_size;

	dl = ISC_LIST_HEAD(mctx->debuglist[size]);
	while (dl != NULL) {
		for (i = 0; i < DEBUGLIST_COUNT; i++) {
			if (dl->ptr[i] == ptr) {
				dl->ptr[i] = NULL;
				dl->size[i] = 0;
				dl->file[i] = NULL;
				dl->line[i] = 0;

				INSIST(dl->count > 0);
				dl->count--;
				if (dl->count == 0) {
					ISC_LIST_UNLINK(mctx->debuglist[size],
							dl, link);
					free(dl);
				}
				return;
			}
		}
		dl = ISC_LIST_NEXT(dl, link);
	}

	/*
	 * If we get here, we didn't find the item on the list.  We're
	 * screwed.
	 */
	INSIST(dl != NULL);
}
#endif /* ISC_MEM_TRACKLINES */

static inline size_t
rmsize(size_t size) {
	/*
 	 * round down to ALIGNMENT_SIZE
	 */
	return (size & (~(ALIGNMENT_SIZE - 1)));
}

static inline size_t
quantize(size_t size) {
	/*!
	 * Round up the result in order to get a size big
	 * enough to satisfy the request and be aligned on ALIGNMENT_SIZE
	 * byte boundaries.
	 */

	if (size == 0U)
		return (ALIGNMENT_SIZE);
	return ((size + ALIGNMENT_SIZE - 1) & (~(ALIGNMENT_SIZE - 1)));
}

static inline isc_boolean_t
more_basic_blocks(isc_mem_t *ctx) {
	void *new;
	unsigned char *curr, *next;
	unsigned char *first, *last;
	unsigned char **table;
	unsigned int table_size;
	size_t increment;
	int i;

	/* Require: we hold the context lock. */

	/*
	 * Did we hit the quota for this context?
	 */
	increment = NUM_BASIC_BLOCKS * ctx->mem_target;
	if (ctx->quota != 0U && ctx->total + increment > ctx->quota)
		return (ISC_FALSE);

	INSIST(ctx->basic_table_count <= ctx->basic_table_size);
	if (ctx->basic_table_count == ctx->basic_table_size) {
		table_size = ctx->basic_table_size + TABLE_INCREMENT;
		table = (ctx->memalloc)(ctx->arg,
					table_size * sizeof(unsigned char *));
		if (table == NULL) {
			ctx->memalloc_failures++;
			return (ISC_FALSE);
		}
		if (ctx->basic_table_size != 0) {
			memcpy(table, ctx->basic_table,
			       ctx->basic_table_size *
			       sizeof(unsigned char *));
			(ctx->memfree)(ctx->arg, ctx->basic_table);
		}
		ctx->basic_table = table;
		ctx->basic_table_size = table_size;
	}

	new = (ctx->memalloc)(ctx->arg, NUM_BASIC_BLOCKS * ctx->mem_target);
	if (new == NULL) {
		ctx->memalloc_failures++;
		return (ISC_FALSE);
	}
	ctx->total += increment;
	ctx->basic_table[ctx->basic_table_count] = new;
	ctx->basic_table_count++;

	curr = new;
	next = curr + ctx->mem_target;
	for (i = 0; i < (NUM_BASIC_BLOCKS - 1); i++) {
		((element *)curr)->next = (element *)next;
		curr = next;
		next += ctx->mem_target;
	}
	/*
	 * curr is now pointing at the last block in the
	 * array.
	 */
	((element *)curr)->next = NULL;
	first = new;
	last = first + NUM_BASIC_BLOCKS * ctx->mem_target - 1;
	if (first < ctx->lowest || ctx->lowest == NULL)
		ctx->lowest = first;
	if (last > ctx->highest)
		ctx->highest = last;
	ctx->basic_blocks = new;

	return (ISC_TRUE);
}

static inline isc_boolean_t
more_frags(isc_mem_t *ctx, size_t new_size) {
	int i, frags;
	size_t total_size;
	void *new;
	unsigned char *curr, *next;

	/*!
	 * Try to get more fragments by chopping up a basic block.
	 */

	if (ctx->basic_blocks == NULL) {
		if (!more_basic_blocks(ctx)) {
			/*
			 * We can't get more memory from the OS, or we've
			 * hit the quota for this context.
			 */
			/*
			 * XXXRTH  "At quota" notification here.
			 */
			return (ISC_FALSE);
		}
	}

	total_size = ctx->mem_target;
	new = ctx->basic_blocks;
	ctx->basic_blocks = ctx->basic_blocks->next;
	frags = total_size / new_size;
	ctx->stats[new_size].blocks++;
	ctx->stats[new_size].freefrags += frags;
	/*
	 * Set up a linked-list of blocks of size
	 * "new_size".
	 */
	curr = new;
	next = curr + new_size;
	total_size -= new_size;
	for (i = 0; i < (frags - 1); i++) {
		((element *)curr)->next = (element *)next;
		curr = next;
		next += new_size;
		total_size -= new_size;
	}
	/*
	 * Add the remaining fragment of the basic block to a free list.
	 */
	total_size = rmsize(total_size);
	if (total_size > 0U) {
		((element *)next)->next = ctx->freelists[total_size];
		ctx->freelists[total_size] = (element *)next;
		ctx->stats[total_size].freefrags++;
	}
	/*
	 * curr is now pointing at the last block in the
	 * array.
	 */
	((element *)curr)->next = NULL;
	ctx->freelists[new_size] = new;

	return (ISC_TRUE);
}

static inline void *
mem_getunlocked(isc_mem_t *ctx, size_t size) {
	size_t new_size = quantize(size);
	void *ret;

	if (size >= ctx->max_size || new_size >= ctx->max_size) {
		/*
		 * memget() was called on something beyond our upper limit.
		 */
		if (ctx->quota != 0U && ctx->total + size > ctx->quota) {
			ret = NULL;
			goto done;
		}
		ret = (ctx->memalloc)(ctx->arg, size);
		if (ret == NULL) {
			ctx->memalloc_failures++;
			goto done;
		}
		ctx->total += size;
		ctx->inuse += size;
		ctx->stats[ctx->max_size].gets++;
		ctx->stats[ctx->max_size].totalgets++;
		/*
		 * If we don't set new_size to size, then the
		 * ISC_MEM_FILL code might write over bytes we
		 * don't own.
		 */
		new_size = size;
		goto done;
	}

	/*
	 * If there are no blocks in the free list for this size, get a chunk
	 * of memory and then break it up into "new_size"-sized blocks, adding
	 * them to the free list.
	 */
	if (ctx->freelists[new_size] == NULL && !more_frags(ctx, new_size))
		return (NULL);

	/*
	 * The free list uses the "rounded-up" size "new_size".
	 */
	ret = ctx->freelists[new_size];
	ctx->freelists[new_size] = ctx->freelists[new_size]->next;

	/*
	 * The stats[] uses the _actual_ "size" requested by the
	 * caller, with the caveat (in the code above) that "size" >= the
	 * max. size (max_size) ends up getting recorded as a call to
	 * max_size.
	 */
	ctx->stats[size].gets++;
	ctx->stats[size].totalgets++;
	ctx->stats[new_size].freefrags--;
	ctx->inuse += new_size;

 done:

#if ISC_MEM_FILL
	if (ret != NULL)
		memset(ret, 0xbe, new_size); /* Mnemonic for "beef". */
#endif

	return (ret);
}

#if ISC_MEM_FILL && ISC_MEM_CHECKOVERRUN
static inline void
check_overrun(void *mem, size_t size, size_t new_size) {
	unsigned char *cp;

	cp = (unsigned char *)mem;
	cp += size;
	while (size < new_size) {
		INSIST(*cp == 0xbe);
		cp++;
		size++;
	}
}
#endif

static inline void
mem_putunlocked(isc_mem_t *ctx, void *mem, size_t size) {
	size_t new_size = quantize(size);

	if (size == ctx->max_size || new_size >= ctx->max_size) {
		/*
		 * memput() called on something beyond our upper limit.
		 */
#if ISC_MEM_FILL
		memset(mem, 0xde, size); /* Mnemonic for "dead". */
#endif
		(ctx->memfree)(ctx->arg, mem);
		INSIST(ctx->stats[ctx->max_size].gets != 0U);
		ctx->stats[ctx->max_size].gets--;
		INSIST(size <= ctx->total);
		ctx->inuse -= size;
		ctx->total -= size;
		return;
	}

#if ISC_MEM_FILL
#if ISC_MEM_CHECKOVERRUN
	check_overrun(mem, size, new_size);
#endif
	memset(mem, 0xde, new_size); /* Mnemonic for "dead". */
#endif

	/*
	 * The free list uses the "rounded-up" size "new_size".
	 */
	((element *)mem)->next = ctx->freelists[new_size];
	ctx->freelists[new_size] = (element *)mem;

	/*
	 * The stats[] uses the _actual_ "size" requested by the
	 * caller, with the caveat (in the code above) that "size" >= the
	 * max. size (max_size) ends up getting recorded as a call to
	 * max_size.
	 */
	INSIST(ctx->stats[size].gets != 0U);
	ctx->stats[size].gets--;
	ctx->stats[new_size].freefrags++;
	ctx->inuse -= new_size;
}

/*!
 * Perform a malloc, doing memory filling and overrun detection as necessary.
 */
static inline void *
mem_get(isc_mem_t *ctx, size_t size) {
	char *ret;

#if ISC_MEM_CHECKOVERRUN
	size += 1;
#endif

	ret = (ctx->memalloc)(ctx->arg, size);
	if (ret == NULL)
		ctx->memalloc_failures++;	

#if ISC_MEM_FILL
	if (ret != NULL)
		memset(ret, 0xbe, size); /* Mnemonic for "beef". */
#else
#  if ISC_MEM_CHECKOVERRUN
	if (ret != NULL)
		ret[size-1] = 0xbe;
#  endif
#endif

	return (ret);
}

/*!
 * Perform a free, doing memory filling and overrun detection as necessary.
 */
static inline void
mem_put(isc_mem_t *ctx, void *mem, size_t size) {
#if ISC_MEM_CHECKOVERRUN
	INSIST(((unsigned char *)mem)[size] == 0xbe);
#endif
#if ISC_MEM_FILL
	memset(mem, 0xde, size); /* Mnemonic for "dead". */
#else
	UNUSED(size);
#endif
	(ctx->memfree)(ctx->arg, mem);
}

/*!
 * Update internal counters after a memory get.
 */
static inline void
mem_getstats(isc_mem_t *ctx, size_t size) {
	ctx->total += size;
	ctx->inuse += size;

	if (size > ctx->max_size) {
		ctx->stats[ctx->max_size].gets++;
		ctx->stats[ctx->max_size].totalgets++;
	} else {
		ctx->stats[size].gets++;
		ctx->stats[size].totalgets++;
	}
}

/*!
 * Update internal counters after a memory put.
 */
static inline void
mem_putstats(isc_mem_t *ctx, void *ptr, size_t size) {
	UNUSED(ptr);

	INSIST(ctx->inuse >= size);
	ctx->inuse -= size;

	if (size > ctx->max_size) {
		INSIST(ctx->stats[ctx->max_size].gets > 0U);
		ctx->stats[ctx->max_size].gets--;
	} else {
		INSIST(ctx->stats[size].gets > 0U);
		ctx->stats[size].gets--;
	}
}

/*
 * Private.
 */

static void *
default_memalloc(void *arg, size_t size) {
	UNUSED(arg);
	if (size == 0U)
		size = 1;
	return (malloc(size));
}

static void
default_memfree(void *arg, void *ptr) {
	UNUSED(arg);
	free(ptr);
}

static void
initialize_action(void) {
	RUNTIME_CHECK(isc_mutex_init(&lock) == ISC_R_SUCCESS);
	ISC_LIST_INIT(contexts);
}

/*
 * Public.
 */

isc_result_t
isc_mem_createx(size_t init_max_size, size_t target_size,
		isc_memalloc_t memalloc, isc_memfree_t memfree, void *arg,
		isc_mem_t **ctxp)
{
	return (isc_mem_createx2(init_max_size, target_size, memalloc, memfree,
				 arg, ctxp, ISC_MEMFLAG_DEFAULT));
				 
}

isc_result_t
isc_mem_createx2(size_t init_max_size, size_t target_size,
		 isc_memalloc_t memalloc, isc_memfree_t memfree, void *arg,
		 isc_mem_t **ctxp, unsigned int flags)
{
	isc_mem_t *ctx;
	isc_result_t result;

	REQUIRE(ctxp != NULL && *ctxp == NULL);
	REQUIRE(memalloc != NULL);
	REQUIRE(memfree != NULL);

	INSIST((ALIGNMENT_SIZE & (ALIGNMENT_SIZE - 1)) == 0);

	RUNTIME_CHECK(isc_once_do(&once, initialize_action) == ISC_R_SUCCESS);

	ctx = (memalloc)(arg, sizeof(*ctx));
	if (ctx == NULL)
		return (ISC_R_NOMEMORY);

	if ((flags & ISC_MEMFLAG_NOLOCK) == 0) {
		result = isc_mutex_init(&ctx->lock);
		if (result != ISC_R_SUCCESS) {
			(memfree)(arg, ctx);
			return (result);
		}
	}

	if (init_max_size == 0U)
		ctx->max_size = DEF_MAX_SIZE;
	else
		ctx->max_size = init_max_size;
	ctx->flags = flags;
	ctx->references = 1;
	ctx->quota = 0;
	ctx->total = 0;
	ctx->inuse = 0;
	ctx->maxinuse = 0;
	ctx->hi_water = 0;
	ctx->lo_water = 0;
	ctx->hi_called = ISC_FALSE;
	ctx->water = NULL;
	ctx->water_arg = NULL;
	ctx->magic = MEM_MAGIC;
	isc_ondestroy_init(&ctx->ondestroy);
	ctx->memalloc = memalloc;
	ctx->memfree = memfree;
	ctx->arg = arg;
	ctx->stats = NULL;
	ctx->checkfree = ISC_TRUE;
#if ISC_MEM_TRACKLINES
	ctx->debuglist = NULL;
#endif
	ISC_LIST_INIT(ctx->pools);
	ctx->freelists = NULL;
	ctx->basic_blocks = NULL;
	ctx->basic_table = NULL;
	ctx->basic_table_count = 0;
	ctx->basic_table_size = 0;
	ctx->lowest = NULL;
	ctx->highest = NULL;

	ctx->stats = (memalloc)(arg,
				(ctx->max_size+1) * sizeof(struct stats));
	if (ctx->stats == NULL) {
		result = ISC_R_NOMEMORY;
		goto error;
	}
	memset(ctx->stats, 0, (ctx->max_size + 1) * sizeof(struct stats));

	if ((flags & ISC_MEMFLAG_INTERNAL) != 0) {
		if (target_size == 0U)
			ctx->mem_target = DEF_MEM_TARGET;
		else
			ctx->mem_target = target_size;
		ctx->freelists = (memalloc)(arg, ctx->max_size *
						 sizeof(element *));
		if (ctx->freelists == NULL) {
			result = ISC_R_NOMEMORY;
			goto error;
		}
		memset(ctx->freelists, 0,
		       ctx->max_size * sizeof(element *));
	}

#if ISC_MEM_TRACKLINES
	if ((isc_mem_debugging & ISC_MEM_DEBUGRECORD) != 0) {
		unsigned int i;

		ctx->debuglist = (memalloc)(arg,
				      (ctx->max_size+1) * sizeof(debuglist_t));
		if (ctx->debuglist == NULL) {
			result = ISC_R_NOMEMORY;
			goto error;
		}
		for (i = 0; i <= ctx->max_size; i++)
			ISC_LIST_INIT(ctx->debuglist[i]);
	}
#endif

	ctx->memalloc_failures = 0;

	LOCK(&lock);
	ISC_LIST_INITANDAPPEND(contexts, ctx, link);
	UNLOCK(&lock);

	*ctxp = ctx;
	return (ISC_R_SUCCESS);

  error:
	if (ctx != NULL) {
		if (ctx->stats != NULL)
			(memfree)(arg, ctx->stats);
		if (ctx->freelists != NULL)
			(memfree)(arg, ctx->freelists);
#if ISC_MEM_TRACKLINES
		if (ctx->debuglist != NULL)
			(ctx->memfree)(ctx->arg, ctx->debuglist);
#endif /* ISC_MEM_TRACKLINES */
		if ((ctx->flags & ISC_MEMFLAG_NOLOCK) == 0)
			DESTROYLOCK(&ctx->lock);
		(memfree)(arg, ctx);
	}

	return (result);
}

isc_result_t
isc_mem_create(size_t init_max_size, size_t target_size,
	       isc_mem_t **ctxp)
{
	return (isc_mem_createx2(init_max_size, target_size,
				 default_memalloc, default_memfree, NULL,
				 ctxp, ISC_MEMFLAG_DEFAULT));
}

isc_result_t
isc_mem_create2(size_t init_max_size, size_t target_size,
		isc_mem_t **ctxp, unsigned int flags)
{
	return (isc_mem_createx2(init_max_size, target_size,
				 default_memalloc, default_memfree, NULL,
				 ctxp, flags));
}

static void
destroy(isc_mem_t *ctx) {
	unsigned int i;
	isc_ondestroy_t ondest;

	ctx->magic = 0;

	LOCK(&lock);
	ISC_LIST_UNLINK(contexts, ctx, link);
	UNLOCK(&lock);

	INSIST(ISC_LIST_EMPTY(ctx->pools));

#if ISC_MEM_TRACKLINES
	if (ctx->debuglist != NULL) {
		if (ctx->checkfree) {
			for (i = 0; i <= ctx->max_size; i++) {
				if (!ISC_LIST_EMPTY(ctx->debuglist[i]))
					print_active(ctx, stderr);
				INSIST(ISC_LIST_EMPTY(ctx->debuglist[i]));
			}
		} else {
			debuglink_t *dl;

			for (i = 0; i <= ctx->max_size; i++)
				for (dl = ISC_LIST_HEAD(ctx->debuglist[i]);
				     dl != NULL;
				     dl = ISC_LIST_HEAD(ctx->debuglist[i])) {
					ISC_LIST_UNLINK(ctx->debuglist[i],
						 	dl, link);
					free(dl);
				}
		}
		(ctx->memfree)(ctx->arg, ctx->debuglist);
	}
#endif
	INSIST(ctx->references == 0);

	if (ctx->checkfree) {
		for (i = 0; i <= ctx->max_size; i++) {
#if ISC_MEM_TRACKLINES
			if (ctx->stats[i].gets != 0U)
				print_active(ctx, stderr);
#endif
			INSIST(ctx->stats[i].gets == 0U);
		}
	}

	(ctx->memfree)(ctx->arg, ctx->stats);

	if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
		for (i = 0; i < ctx->basic_table_count; i++)
			(ctx->memfree)(ctx->arg, ctx->basic_table[i]);
		(ctx->memfree)(ctx->arg, ctx->freelists);
		(ctx->memfree)(ctx->arg, ctx->basic_table);
	}

	ondest = ctx->ondestroy;

	if ((ctx->flags & ISC_MEMFLAG_NOLOCK) == 0)
		DESTROYLOCK(&ctx->lock);
	(ctx->memfree)(ctx->arg, ctx);

	isc_ondestroy_notify(&ondest, ctx);
}

void
isc_mem_attach(isc_mem_t *source, isc_mem_t **targetp) {
	REQUIRE(VALID_CONTEXT(source));
	REQUIRE(targetp != NULL && *targetp == NULL);

	MCTXLOCK(source, &source->lock);
	source->references++;
	MCTXUNLOCK(source, &source->lock);

	*targetp = source;
}

void
isc_mem_detach(isc_mem_t **ctxp) {
	isc_mem_t *ctx;
	isc_boolean_t want_destroy = ISC_FALSE;

	REQUIRE(ctxp != NULL);
	ctx = *ctxp;
	REQUIRE(VALID_CONTEXT(ctx));

	MCTXLOCK(ctx, &ctx->lock);
	INSIST(ctx->references > 0);
	ctx->references--;
	if (ctx->references == 0)
		want_destroy = ISC_TRUE;
	MCTXUNLOCK(ctx, &ctx->lock);

	if (want_destroy)
		destroy(ctx);

	*ctxp = NULL;
}

/*
 * isc_mem_putanddetach() is the equivalent of:
 *
 * mctx = NULL;
 * isc_mem_attach(ptr->mctx, &mctx);
 * isc_mem_detach(&ptr->mctx);
 * isc_mem_put(mctx, ptr, sizeof(*ptr);
 * isc_mem_detach(&mctx);
 */

void
isc__mem_putanddetach(isc_mem_t **ctxp, void *ptr, size_t size FLARG) {
	isc_mem_t *ctx;
	isc_boolean_t want_destroy = ISC_FALSE;
	size_info *si;
	size_t oldsize;

	REQUIRE(ctxp != NULL);
	ctx = *ctxp;
	REQUIRE(VALID_CONTEXT(ctx));
	REQUIRE(ptr != NULL);

	/*
	 * Must be before mem_putunlocked() as ctxp is usually within
	 * [ptr..ptr+size).
	 */
	*ctxp = NULL;

	if ((isc_mem_debugging & (ISC_MEM_DEBUGSIZE|ISC_MEM_DEBUGCTX)) != 0) {
		if ((isc_mem_debugging & ISC_MEM_DEBUGSIZE) != 0) {
			si = &(((size_info *)ptr)[-1]);
			oldsize = si->u.size - ALIGNMENT_SIZE;
			if ((isc_mem_debugging & ISC_MEM_DEBUGCTX) != 0)
				oldsize -= ALIGNMENT_SIZE;
			INSIST(oldsize == size);
		}
		isc__mem_free(ctx, ptr FLARG_PASS);

		MCTXLOCK(ctx, &ctx->lock);
		ctx->references--;
		if (ctx->references == 0)
			want_destroy = ISC_TRUE;
		MCTXUNLOCK(ctx, &ctx->lock);
		if (want_destroy)
			destroy(ctx);

		return;
	}

	if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
		MCTXLOCK(ctx, &ctx->lock);
		mem_putunlocked(ctx, ptr, size);
	} else {
		mem_put(ctx, ptr, size);
		MCTXLOCK(ctx, &ctx->lock);
		mem_putstats(ctx, ptr, size);
	}

	DELETE_TRACE(ctx, ptr, size, file, line);
	INSIST(ctx->references > 0);
	ctx->references--;
	if (ctx->references == 0)
		want_destroy = ISC_TRUE;

	MCTXUNLOCK(ctx, &ctx->lock);

	if (want_destroy)
		destroy(ctx);
}

void
isc_mem_destroy(isc_mem_t **ctxp) {
	isc_mem_t *ctx;

	/*
	 * This routine provides legacy support for callers who use mctxs
	 * without attaching/detaching.
	 */

	REQUIRE(ctxp != NULL);
	ctx = *ctxp;
	REQUIRE(VALID_CONTEXT(ctx));

	MCTXLOCK(ctx, &ctx->lock);
#if ISC_MEM_TRACKLINES
	if (ctx->references != 1)
		print_active(ctx, stderr);
#endif
	REQUIRE(ctx->references == 1);
	ctx->references--;
	MCTXUNLOCK(ctx, &ctx->lock);

	destroy(ctx);

	*ctxp = NULL;
}

isc_result_t
isc_mem_ondestroy(isc_mem_t *ctx, isc_task_t *task, isc_event_t **event) {
	isc_result_t res;

	MCTXLOCK(ctx, &ctx->lock);
	res = isc_ondestroy_register(&ctx->ondestroy, task, event);
	MCTXUNLOCK(ctx, &ctx->lock);

	return (res);
}


void *
isc__mem_get(isc_mem_t *ctx, size_t size FLARG) {
	void *ptr;
	isc_boolean_t call_water = ISC_FALSE;

	REQUIRE(VALID_CONTEXT(ctx));

	if ((isc_mem_debugging & (ISC_MEM_DEBUGSIZE|ISC_MEM_DEBUGCTX)) != 0)
		return (isc__mem_allocate(ctx, size FLARG_PASS));

	if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
		MCTXLOCK(ctx, &ctx->lock);
		ptr = mem_getunlocked(ctx, size);
	} else {
		ptr = mem_get(ctx, size);
		MCTXLOCK(ctx, &ctx->lock);
		if (ptr != NULL)
			mem_getstats(ctx, size);
	}

	ADD_TRACE(ctx, ptr, size, file, line);
	if (ctx->hi_water != 0U && !ctx->hi_called &&
	    ctx->inuse > ctx->hi_water) {
		ctx->hi_called = ISC_TRUE;
		call_water = ISC_TRUE;
	}
	if (ctx->inuse > ctx->maxinuse) {
		ctx->maxinuse = ctx->inuse;
		if (ctx->hi_water != 0U && ctx->inuse > ctx->hi_water &&
		    (isc_mem_debugging & ISC_MEM_DEBUGUSAGE) != 0)
			fprintf(stderr, "maxinuse = %lu\n",
				(unsigned long)ctx->inuse);
	}
	MCTXUNLOCK(ctx, &ctx->lock);

	if (call_water)
		(ctx->water)(ctx->water_arg, ISC_MEM_HIWATER);

	return (ptr);
}

void
isc__mem_put(isc_mem_t *ctx, void *ptr, size_t size FLARG)
{
	isc_boolean_t call_water = ISC_FALSE;
	size_info *si;
	size_t oldsize;

	REQUIRE(VALID_CONTEXT(ctx));
	REQUIRE(ptr != NULL);

	if ((isc_mem_debugging & (ISC_MEM_DEBUGSIZE|ISC_MEM_DEBUGCTX)) != 0) {
		if ((isc_mem_debugging & ISC_MEM_DEBUGSIZE) != 0) {
			si = &(((size_info *)ptr)[-1]);
			oldsize = si->u.size - ALIGNMENT_SIZE;
			if ((isc_mem_debugging & ISC_MEM_DEBUGCTX) != 0)
				oldsize -= ALIGNMENT_SIZE;
			INSIST(oldsize == size);
		}
		isc__mem_free(ctx, ptr FLARG_PASS);
		return;
	}

	if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
		MCTXLOCK(ctx, &ctx->lock);
		mem_putunlocked(ctx, ptr, size);
	} else {
		mem_put(ctx, ptr, size);
		MCTXLOCK(ctx, &ctx->lock);
		mem_putstats(ctx, ptr, size);
	}

	DELETE_TRACE(ctx, ptr, size, file, line);

	/*
	 * The check against ctx->lo_water == 0 is for the condition
	 * when the context was pushed over hi_water but then had
	 * isc_mem_setwater() called with 0 for hi_water and lo_water.
	 */
	if (ctx->hi_called && 
	    (ctx->inuse < ctx->lo_water || ctx->lo_water == 0U)) {
		ctx->hi_called = ISC_FALSE;

		if (ctx->water != NULL)
			call_water = ISC_TRUE;
	}
	MCTXUNLOCK(ctx, &ctx->lock);

	if (call_water)
		(ctx->water)(ctx->water_arg, ISC_MEM_LOWATER);
}

#if ISC_MEM_TRACKLINES
static void
print_active(isc_mem_t *mctx, FILE *out) {
	if (mctx->debuglist != NULL) {
		debuglink_t *dl;
		unsigned int i, j;
		const char *format;
		isc_boolean_t found;

		fprintf(out, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
					    ISC_MSG_DUMPALLOC,
					    "Dump of all outstanding "
					    "memory allocations:\n"));
		found = ISC_FALSE;
		format = isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
				        ISC_MSG_PTRFILELINE,
					"\tptr %p size %u file %s line %u\n");
		for (i = 0; i <= mctx->max_size; i++) {
			dl = ISC_LIST_HEAD(mctx->debuglist[i]);
			
			if (dl != NULL)
				found = ISC_TRUE;

			while (dl != NULL) {
				for (j = 0; j < DEBUGLIST_COUNT; j++)
					if (dl->ptr[j] != NULL)
						fprintf(out, format,
							dl->ptr[j],
							dl->size[j],
							dl->file[j],
							dl->line[j]);
				dl = ISC_LIST_NEXT(dl, link);
			}
		}
		if (!found)
			fprintf(out, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
						    ISC_MSG_NONE, "\tNone.\n"));
	}
}
#endif

/*
 * Print the stats[] on the stream "out" with suitable formatting.
 */
void
isc_mem_stats(isc_mem_t *ctx, FILE *out) {
	size_t i;
	const struct stats *s;
	const isc_mempool_t *pool;

	REQUIRE(VALID_CONTEXT(ctx));
	MCTXLOCK(ctx, &ctx->lock);

	for (i = 0; i <= ctx->max_size; i++) {
		s = &ctx->stats[i];

		if (s->totalgets == 0U && s->gets == 0U)
			continue;
		fprintf(out, "%s%5lu: %11lu gets, %11lu rem",
			(i == ctx->max_size) ? ">=" : "  ",
			(unsigned long) i, s->totalgets, s->gets);
		if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0 &&
		    (s->blocks != 0U || s->freefrags != 0U))
			fprintf(out, " (%lu bl, %lu ff)",
				s->blocks, s->freefrags);
		fputc('\n', out);
	}

	/*
	 * Note that since a pool can be locked now, these stats might be
	 * somewhat off if the pool is in active use at the time the stats
	 * are dumped.  The link fields are protected by the isc_mem_t's
	 * lock, however, so walking this list and extracting integers from
	 * stats fields is always safe.
	 */
	pool = ISC_LIST_HEAD(ctx->pools);
	if (pool != NULL) {
		fprintf(out, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
					    ISC_MSG_POOLSTATS,
					    "[Pool statistics]\n"));
		fprintf(out, "%15s %10s %10s %10s %10s %10s %10s %10s %1s\n",
			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
				       ISC_MSG_POOLNAME, "name"),
			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
				       ISC_MSG_POOLSIZE, "size"),
			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
				       ISC_MSG_POOLMAXALLOC, "maxalloc"),
			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
				       ISC_MSG_POOLALLOCATED, "allocated"),
			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
				       ISC_MSG_POOLFREECOUNT, "freecount"),
			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
				       ISC_MSG_POOLFREEMAX, "freemax"),
			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
				       ISC_MSG_POOLFILLCOUNT, "fillcount"),
			isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
				       ISC_MSG_POOLGETS, "gets"),
			"L");
	}
	while (pool != NULL) {
		fprintf(out, "%15s %10lu %10u %10u %10u %10u %10u %10u %s\n",
			pool->name, (unsigned long) pool->size, pool->maxalloc,
			pool->allocated, pool->freecount, pool->freemax,
			pool->fillcount, pool->gets,
			(pool->lock == NULL ? "N" : "Y"));
		pool = ISC_LIST_NEXT(pool, link);
	}

#if ISC_MEM_TRACKLINES
	print_active(ctx, out);
#endif

	MCTXUNLOCK(ctx, &ctx->lock);
}

/*
 * Replacements for malloc() and free() -- they implicitly remember the
 * size of the object allocated (with some additional overhead).
 */

static void *
isc__mem_allocateunlocked(isc_mem_t *ctx, size_t size) {
	size_info *si;

	size += ALIGNMENT_SIZE;
	if ((isc_mem_debugging & ISC_MEM_DEBUGCTX) != 0)
		size += ALIGNMENT_SIZE;

	if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0)
		si = mem_getunlocked(ctx, size);
	else
		si = mem_get(ctx, size);

	if (si == NULL)
		return (NULL);
	if ((isc_mem_debugging & ISC_MEM_DEBUGCTX) != 0) {
		si->u.ctx = ctx;
		si++;
	}
	si->u.size = size;
	return (&si[1]);
}

void *
isc__mem_allocate(isc_mem_t *ctx, size_t size FLARG) {
	size_info *si;
	isc_boolean_t call_water = ISC_FALSE;

	REQUIRE(VALID_CONTEXT(ctx));

	if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
		MCTXLOCK(ctx, &ctx->lock);
		si = isc__mem_allocateunlocked(ctx, size);
	} else {
		si = isc__mem_allocateunlocked(ctx, size);
		MCTXLOCK(ctx, &ctx->lock);
		if (si != NULL)
			mem_getstats(ctx, si[-1].u.size);
	}

#if ISC_MEM_TRACKLINES
	ADD_TRACE(ctx, si, si[-1].u.size, file, line);
#endif
	if (ctx->hi_water != 0U && !ctx->hi_called &&
	    ctx->inuse > ctx->hi_water) {
		ctx->hi_called = ISC_TRUE;
		call_water = ISC_TRUE;
	}
	if (ctx->inuse > ctx->maxinuse) {
		ctx->maxinuse = ctx->inuse;
		if (ctx->hi_water != 0U && ctx->inuse > ctx->hi_water &&
		    (isc_mem_debugging & ISC_MEM_DEBUGUSAGE) != 0)
			fprintf(stderr, "maxinuse = %lu\n",
				(unsigned long)ctx->inuse);
	}
	MCTXUNLOCK(ctx, &ctx->lock);

	if (call_water)
		(ctx->water)(ctx->water_arg, ISC_MEM_HIWATER);

	return (si);
}

void
isc__mem_free(isc_mem_t *ctx, void *ptr FLARG) {
	size_info *si;
	size_t size;
	isc_boolean_t call_water= ISC_FALSE;

	REQUIRE(VALID_CONTEXT(ctx));
	REQUIRE(ptr != NULL);

	if ((isc_mem_debugging & ISC_MEM_DEBUGCTX) != 0) {
		si = &(((size_info *)ptr)[-2]);
		REQUIRE(si->u.ctx == ctx);
		size = si[1].u.size;
	} else {
		si = &(((size_info *)ptr)[-1]);
		size = si->u.size;
	}

	if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
		MCTXLOCK(ctx, &ctx->lock);
		mem_putunlocked(ctx, si, size);
	} else {
		mem_put(ctx, si, size);
		MCTXLOCK(ctx, &ctx->lock);
		mem_putstats(ctx, si, size);
	}

	DELETE_TRACE(ctx, ptr, size, file, line);

	/*
	 * The check against ctx->lo_water == 0 is for the condition
	 * when the context was pushed over hi_water but then had
	 * isc_mem_setwater() called with 0 for hi_water and lo_water.
	 */
	if (ctx->hi_called && 
	    (ctx->inuse < ctx->lo_water || ctx->lo_water == 0U)) {
		ctx->hi_called = ISC_FALSE;

		if (ctx->water != NULL)
			call_water = ISC_TRUE;
	}
	MCTXUNLOCK(ctx, &ctx->lock);

	if (call_water)
		(ctx->water)(ctx->water_arg, ISC_MEM_LOWATER);
}


/*
 * Other useful things.
 */

char *
isc__mem_strdup(isc_mem_t *mctx, const char *s FLARG) {
	size_t len;
	char *ns;

	REQUIRE(VALID_CONTEXT(mctx));
	REQUIRE(s != NULL);

	len = strlen(s);

	ns = isc__mem_allocate(mctx, len + 1 FLARG_PASS);

	if (ns != NULL)
		strlcpy(ns, s, len + 1);

	return (ns);
}

void
isc_mem_setdestroycheck(isc_mem_t *ctx, isc_boolean_t flag) {
	REQUIRE(VALID_CONTEXT(ctx));
	MCTXLOCK(ctx, &ctx->lock);

	ctx->checkfree = flag;

	MCTXUNLOCK(ctx, &ctx->lock);
}

/*
 * Quotas
 */

void
isc_mem_setquota(isc_mem_t *ctx, size_t quota) {
	REQUIRE(VALID_CONTEXT(ctx));
	MCTXLOCK(ctx, &ctx->lock);

	ctx->quota = quota;

	MCTXUNLOCK(ctx, &ctx->lock);
}

size_t
isc_mem_getquota(isc_mem_t *ctx) {
	size_t quota;

	REQUIRE(VALID_CONTEXT(ctx));
	MCTXLOCK(ctx, &ctx->lock);

	quota = ctx->quota;

	MCTXUNLOCK(ctx, &ctx->lock);

	return (quota);
}

size_t
isc_mem_inuse(isc_mem_t *ctx) {
	size_t inuse;

	REQUIRE(VALID_CONTEXT(ctx));
	MCTXLOCK(ctx, &ctx->lock);

	inuse = ctx->inuse;

	MCTXUNLOCK(ctx, &ctx->lock);

	return (inuse);
}

void
isc_mem_setwater(isc_mem_t *ctx, isc_mem_water_t water, void *water_arg,
                 size_t hiwater, size_t lowater)
{
	isc_boolean_t callwater = ISC_FALSE;
	isc_mem_water_t oldwater;
	void *oldwater_arg;

	REQUIRE(VALID_CONTEXT(ctx));
	REQUIRE(hiwater >= lowater);

	MCTXLOCK(ctx, &ctx->lock);
	oldwater = ctx->water;
	oldwater_arg = ctx->water_arg;
	if (water == NULL) {
		callwater = ctx->hi_called;
		ctx->water = NULL;
		ctx->water_arg = NULL;
		ctx->hi_water = 0;
		ctx->lo_water = 0;
		ctx->hi_called = ISC_FALSE;
	} else {
		if (ctx->hi_called &&
		    (ctx->water != water || ctx->water_arg != water_arg ||
		     ctx->inuse < lowater || lowater == 0U))
			callwater = ISC_TRUE;
		ctx->water = water;
		ctx->water_arg = water_arg;
		ctx->hi_water = hiwater;
		ctx->lo_water = lowater;
		ctx->hi_called = ISC_FALSE;
	}
	MCTXUNLOCK(ctx, &ctx->lock);
	
	if (callwater && oldwater != NULL)
		(oldwater)(oldwater_arg, ISC_MEM_LOWATER);
}

/*
 * Memory pool stuff
 */

isc_result_t
isc_mempool_create(isc_mem_t *mctx, size_t size, isc_mempool_t **mpctxp) {
	isc_mempool_t *mpctx;

	REQUIRE(VALID_CONTEXT(mctx));
	REQUIRE(size > 0U);
	REQUIRE(mpctxp != NULL && *mpctxp == NULL);

	/*
	 * Allocate space for this pool, initialize values, and if all works
	 * well, attach to the memory context.
	 */
	mpctx = isc_mem_get(mctx, sizeof(isc_mempool_t));
	if (mpctx == NULL)
		return (ISC_R_NOMEMORY);

	mpctx->magic = MEMPOOL_MAGIC;
	mpctx->lock = NULL;
	mpctx->mctx = mctx;
	mpctx->size = size;
	mpctx->maxalloc = UINT_MAX;
	mpctx->allocated = 0;
	mpctx->freecount = 0;
	mpctx->freemax = 1;
	mpctx->fillcount = 1;
	mpctx->gets = 0;
#if ISC_MEMPOOL_NAMES
	mpctx->name[0] = 0;
#endif
	mpctx->items = NULL;

	*mpctxp = mpctx;

	MCTXLOCK(mctx, &mctx->lock);
	ISC_LIST_INITANDAPPEND(mctx->pools, mpctx, link);
	MCTXUNLOCK(mctx, &mctx->lock);

	return (ISC_R_SUCCESS);
}

void
isc_mempool_setname(isc_mempool_t *mpctx, const char *name) {
	REQUIRE(name != NULL);

#if ISC_MEMPOOL_NAMES
	if (mpctx->lock != NULL)
		LOCK(mpctx->lock);

	strlcpy(mpctx->name, name, sizeof(mpctx->name));

	if (mpctx->lock != NULL)
		UNLOCK(mpctx->lock);
#else
	UNUSED(mpctx);
	UNUSED(name);
#endif
}

void
isc_mempool_destroy(isc_mempool_t **mpctxp) {
	isc_mempool_t *mpctx;
	isc_mem_t *mctx;
	isc_mutex_t *lock;
	element *item;

	REQUIRE(mpctxp != NULL);
	mpctx = *mpctxp;
	REQUIRE(VALID_MEMPOOL(mpctx));
#if ISC_MEMPOOL_NAMES
	if (mpctx->allocated > 0)
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "isc_mempool_destroy(): mempool %s "
				 "leaked memory",
				 mpctx->name);
#endif
	REQUIRE(mpctx->allocated == 0);

	mctx = mpctx->mctx;

	lock = mpctx->lock;

	if (lock != NULL)
		LOCK(lock);

	/*
	 * Return any items on the free list
	 */
	MCTXLOCK(mctx, &mctx->lock);
	while (mpctx->items != NULL) {
		INSIST(mpctx->freecount > 0);
		mpctx->freecount--;
		item = mpctx->items;
		mpctx->items = item->next;

		if ((mctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
			mem_putunlocked(mctx, item, mpctx->size);
		} else {
			mem_put(mctx, item, mpctx->size);
			mem_putstats(mctx, item, mpctx->size);
		}
	}
	MCTXUNLOCK(mctx, &mctx->lock);

	/*
	 * Remove our linked list entry from the memory context.
	 */
	MCTXLOCK(mctx, &mctx->lock);
	ISC_LIST_UNLINK(mctx->pools, mpctx, link);
	MCTXUNLOCK(mctx, &mctx->lock);

	mpctx->magic = 0;

	isc_mem_put(mpctx->mctx, mpctx, sizeof(isc_mempool_t));

	if (lock != NULL)
		UNLOCK(lock);

	*mpctxp = NULL;
}

void
isc_mempool_associatelock(isc_mempool_t *mpctx, isc_mutex_t *lock) {
	REQUIRE(VALID_MEMPOOL(mpctx));
	REQUIRE(mpctx->lock == NULL);
	REQUIRE(lock != NULL);

	mpctx->lock = lock;
}

void *
isc__mempool_get(isc_mempool_t *mpctx FLARG) {
	element *item;
	isc_mem_t *mctx;
	unsigned int i;

	REQUIRE(VALID_MEMPOOL(mpctx));

	mctx = mpctx->mctx;

	if (mpctx->lock != NULL)
		LOCK(mpctx->lock);

	/*
	 * Don't let the caller go over quota
	 */
	if (mpctx->allocated >= mpctx->maxalloc) {
		item = NULL;
		goto out;
	}

	/*
	 * if we have a free list item, return the first here
	 */
	item = mpctx->items;
	if (item != NULL) {
		mpctx->items = item->next;
		INSIST(mpctx->freecount > 0);
		mpctx->freecount--;
		mpctx->gets++;
		mpctx->allocated++;
		goto out;
	}

	/*
	 * We need to dip into the well.  Lock the memory context here and
	 * fill up our free list.
	 */
	MCTXLOCK(mctx, &mctx->lock);
	for (i = 0; i < mpctx->fillcount; i++) {
		if ((mctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
			item = mem_getunlocked(mctx, mpctx->size);
		} else {
			item = mem_get(mctx, mpctx->size);
			if (item != NULL)
				mem_getstats(mctx, mpctx->size);
		}
		if (item == NULL)
			break;
		item->next = mpctx->items;
		mpctx->items = item;
		mpctx->freecount++;
	}
	MCTXUNLOCK(mctx, &mctx->lock);

	/*
	 * If we didn't get any items, return NULL.
	 */
	item = mpctx->items;
	if (item == NULL)
		goto out;

	mpctx->items = item->next;
	mpctx->freecount--;
	mpctx->gets++;
	mpctx->allocated++;

 out:
	if (mpctx->lock != NULL)
		UNLOCK(mpctx->lock);

#if ISC_MEM_TRACKLINES
	if (item != NULL) {
		MCTXLOCK(mctx, &mctx->lock);
		ADD_TRACE(mctx, item, mpctx->size, file, line);
		MCTXUNLOCK(mctx, &mctx->lock);
	}
#endif /* ISC_MEM_TRACKLINES */

	return (item);
}

void
isc__mempool_put(isc_mempool_t *mpctx, void *mem FLARG) {
	isc_mem_t *mctx;
	element *item;

	REQUIRE(VALID_MEMPOOL(mpctx));
	REQUIRE(mem != NULL);

	mctx = mpctx->mctx;

	if (mpctx->lock != NULL)
		LOCK(mpctx->lock);

	INSIST(mpctx->allocated > 0);
	mpctx->allocated--;

#if ISC_MEM_TRACKLINES
	MCTXLOCK(mctx, &mctx->lock);
	DELETE_TRACE(mctx, mem, mpctx->size, file, line);
	MCTXUNLOCK(mctx, &mctx->lock);
#endif /* ISC_MEM_TRACKLINES */

	/*
	 * If our free list is full, return this to the mctx directly.
	 */
	if (mpctx->freecount >= mpctx->freemax) {
		if ((mctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
			MCTXLOCK(mctx, &mctx->lock);
			mem_putunlocked(mctx, mem, mpctx->size);
			MCTXUNLOCK(mctx, &mctx->lock);
		} else {
			mem_put(mctx, mem, mpctx->size);
			MCTXLOCK(mctx, &mctx->lock);
			mem_putstats(mctx, mem, mpctx->size);
			MCTXUNLOCK(mctx, &mctx->lock);
		}
		if (mpctx->lock != NULL)
			UNLOCK(mpctx->lock);
		return;
	}

	/*
	 * Otherwise, attach it to our free list and bump the counter.
	 */
	mpctx->freecount++;
	item = (element *)mem;
	item->next = mpctx->items;
	mpctx->items = item;

	if (mpctx->lock != NULL)
		UNLOCK(mpctx->lock);
}

/*
 * Quotas
 */

void
isc_mempool_setfreemax(isc_mempool_t *mpctx, unsigned int limit) {
	REQUIRE(VALID_MEMPOOL(mpctx));

	if (mpctx->lock != NULL)
		LOCK(mpctx->lock);

	mpctx->freemax = limit;

	if (mpctx->lock != NULL)
		UNLOCK(mpctx->lock);
}

unsigned int
isc_mempool_getfreemax(isc_mempool_t *mpctx) {
	unsigned int freemax;

	REQUIRE(VALID_MEMPOOL(mpctx));

	if (mpctx->lock != NULL)
		LOCK(mpctx->lock);

	freemax = mpctx->freemax;

	if (mpctx->lock != NULL)
		UNLOCK(mpctx->lock);

	return (freemax);
}

unsigned int
isc_mempool_getfreecount(isc_mempool_t *mpctx) {
	unsigned int freecount;

	REQUIRE(VALID_MEMPOOL(mpctx));

	if (mpctx->lock != NULL)
		LOCK(mpctx->lock);

	freecount = mpctx->freecount;

	if (mpctx->lock != NULL)
		UNLOCK(mpctx->lock);

	return (freecount);
}

void
isc_mempool_setmaxalloc(isc_mempool_t *mpctx, unsigned int limit) {
	REQUIRE(limit > 0);

	REQUIRE(VALID_MEMPOOL(mpctx));

	if (mpctx->lock != NULL)
		LOCK(mpctx->lock);

	mpctx->maxalloc = limit;

	if (mpctx->lock != NULL)
		UNLOCK(mpctx->lock);
}

unsigned int
isc_mempool_getmaxalloc(isc_mempool_t *mpctx) {
	unsigned int maxalloc;

	REQUIRE(VALID_MEMPOOL(mpctx));

	if (mpctx->lock != NULL)
		LOCK(mpctx->lock);

	maxalloc = mpctx->maxalloc;

	if (mpctx->lock != NULL)
		UNLOCK(mpctx->lock);

	return (maxalloc);
}

unsigned int
isc_mempool_getallocated(isc_mempool_t *mpctx) {
	unsigned int allocated;

	REQUIRE(VALID_MEMPOOL(mpctx));

	if (mpctx->lock != NULL)
		LOCK(mpctx->lock);

	allocated = mpctx->allocated;

	if (mpctx->lock != NULL)
		UNLOCK(mpctx->lock);

	return (allocated);
}

void
isc_mempool_setfillcount(isc_mempool_t *mpctx, unsigned int limit) {
	REQUIRE(limit > 0);
	REQUIRE(VALID_MEMPOOL(mpctx));

	if (mpctx->lock != NULL)
		LOCK(mpctx->lock);

	mpctx->fillcount = limit;

	if (mpctx->lock != NULL)
		UNLOCK(mpctx->lock);
}

unsigned int
isc_mempool_getfillcount(isc_mempool_t *mpctx) {
	unsigned int fillcount;

	REQUIRE(VALID_MEMPOOL(mpctx));

	if (mpctx->lock != NULL)
		LOCK(mpctx->lock);

	fillcount = mpctx->fillcount;

	if (mpctx->lock != NULL)
		UNLOCK(mpctx->lock);

	return (fillcount);
}

void
isc_mem_printactive(isc_mem_t *ctx, FILE *file) {

	REQUIRE(VALID_CONTEXT(ctx));
	REQUIRE(file != NULL);

#if !ISC_MEM_TRACKLINES
	UNUSED(ctx);
	UNUSED(file);
#else
	print_active(ctx, file);
#endif
}

void
isc_mem_printallactive(FILE *file) {
#if !ISC_MEM_TRACKLINES
	UNUSED(file);
#else
	isc_mem_t *ctx;

	RUNTIME_CHECK(isc_once_do(&once, initialize_action) == ISC_R_SUCCESS);

	LOCK(&lock);
	for (ctx = ISC_LIST_HEAD(contexts);
	     ctx != NULL;
	     ctx = ISC_LIST_NEXT(ctx, link)) {
		fprintf(file, "context: %p\n", ctx);
		print_active(ctx, file);
	}
	UNLOCK(&lock);
#endif
}

void    
isc_mem_checkdestroyed(FILE *file) {

	RUNTIME_CHECK(isc_once_do(&once, initialize_action) == ISC_R_SUCCESS);

	LOCK(&lock);
	if (!ISC_LIST_EMPTY(contexts))  {
#if ISC_MEM_TRACKLINES
		isc_mem_t *ctx;

		for (ctx = ISC_LIST_HEAD(contexts);
		     ctx != NULL;
		     ctx = ISC_LIST_NEXT(ctx, link)) {
			fprintf(file, "context: %p\n", ctx);
			print_active(ctx, file);
		}
		fflush(file);
#endif
		INSIST(0);
	}
	UNLOCK(&lock);
}
@


1.5
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d5 1
a5 1
 * Permission to use, copy, modify, and distribute this software for any
d18 3
a20 1
/* $ISC: mem.c,v 1.98.2.7.2.7 2005/03/17 03:58:32 marka Exp $ */
d33 1
d40 3
a48 10
 * Define ISC_MEM_USE_INTERNAL_MALLOC=1 to use the internal malloc()
 * implementation in preference to the system one.  The internal malloc()
 * is very space-efficient, and quite fast on uniprocessor systems.  It
 * performs poorly on multiprocessor machines.
 */
#ifndef ISC_MEM_USE_INTERNAL_MALLOC
#define ISC_MEM_USE_INTERNAL_MALLOC 0
#endif

/*
d54 2
a55 2
#define ALIGNMENT_SIZE		8		/* must be a power of 2 */
#define NUM_BASIC_BLOCKS	64		/* must be > 1 */
d86 1
a86 1
	/*
d91 1
a98 1
#if ISC_MEM_USE_INTERNAL_MALLOC
a100 1
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d110 6
d119 1
d139 1
a139 1
#if ISC_MEM_USE_INTERNAL_MALLOC
a147 1
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d154 1
d162 16
a177 16
	unsigned int	magic;		/* magic number */
	isc_mutex_t    *lock;		/* optional lock */
	isc_mem_t      *mctx;		/* our memory context */
	/* locked via the memory context's lock */
	ISC_LINK(isc_mempool_t)	link;	/* next pool in this mem context */
	/* optionally locked from here down */
	element	       *items;		/* low water item list */
	size_t		size;		/* size of each item on this pool */
	unsigned int	maxalloc;	/* max number of items allowed */
	unsigned int	allocated;	/* # of items currently given out */
	unsigned int	freecount;	/* # of items on reserved list */
	unsigned int	freemax;	/* # of items allowed on free list */
	unsigned int	fillcount;	/* # of items to fetch on each fill */
	/* Stats only. */
	unsigned int	gets;		/* # of requests to this pool */
	/* Debugging only. */
d179 1
a179 1
	char		name[16];	/* printed name in stats reports */
d203 1
a203 1
/*
a313 1
#if ISC_MEM_USE_INTERNAL_MALLOC
d324 1
a324 1
	/*
d330 1
a330 1
	if (size == 0)
d351 1
a351 1
	if (ctx->quota != 0 && ctx->total + increment > ctx->quota)
d412 1
a412 1
	/*
d452 1
a452 1
	if (total_size > 0) {
d476 1
a476 1
		if (ctx->quota != 0 && ctx->total + size > ctx->quota) {
d560 1
a560 1
		INSIST(ctx->stats[ctx->max_size].gets != 0);
d587 1
a587 1
	INSIST(ctx->stats[size].gets != 0);
d593 1
a593 3
#else /* ISC_MEM_USE_INTERNAL_MALLOC */

/*
d621 1
a621 1
/*
d637 1
a637 1
/*
d654 1
a654 1
/*
a672 2
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */

d691 6
d706 10
d725 1
a725 3
#if !ISC_MEM_USE_INTERNAL_MALLOC
	UNUSED(target_size);
#endif
d731 6
a736 7
	if (isc_mutex_init(&ctx->lock) != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "isc_mutex_init() %s",
				 isc_msgcat_get(isc_msgcat, ISC_MSGSET_GENERAL,
						ISC_MSG_FAILED, "failed"));
		(memfree)(arg, ctx);
		return (ISC_R_UNEXPECTED);
d743 1
a764 2

#if ISC_MEM_USE_INTERNAL_MALLOC
d766 6
a771 1
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d781 13
a793 9
#if ISC_MEM_USE_INTERNAL_MALLOC
	if (target_size == 0)
		ctx->mem_target = DEF_MEM_TARGET;
	else
		ctx->mem_target = target_size;
	ctx->freelists = (memalloc)(arg, ctx->max_size * sizeof(element *));
	if (ctx->freelists == NULL) {
		result = ISC_R_NOMEMORY;
		goto error;
a794 9
	memset(ctx->freelists, 0,
	       ctx->max_size * sizeof(element *));
	ctx->basic_blocks = NULL;
	ctx->basic_table = NULL;
	ctx->basic_table_count = 0;
	ctx->basic_table_size = 0;
	ctx->lowest = NULL;
	ctx->highest = NULL;
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d813 4
a823 1
#if ISC_MEM_USE_INTERNAL_MALLOC
a825 1
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d830 2
a831 1
		DESTROYLOCK(&ctx->lock);
d842 12
a853 3
	return (isc_mem_createx(init_max_size, target_size,
				default_memalloc, default_memfree, NULL,
				ctxp));
d863 4
a866 1
#if ISC_MEM_USE_INTERNAL_MALLOC
a867 1
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d906 6
a911 6
#if ISC_MEM_USE_INTERNAL_MALLOC
	for (i = 0; i < ctx->basic_table_count; i++)
		(ctx->memfree)(ctx->arg, ctx->basic_table[i]);
	(ctx->memfree)(ctx->arg, ctx->freelists);
	(ctx->memfree)(ctx->arg, ctx->basic_table);
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d915 2
a916 1
	DESTROYLOCK(&ctx->lock);
d927 1
a927 1
	LOCK(&source->lock);
d929 1
a929 1
	UNLOCK(&source->lock);
d943 1
a943 1
	LOCK(&ctx->lock);
d948 1
a948 1
	UNLOCK(&ctx->lock);
d970 2
d984 29
a1012 8
#if ISC_MEM_USE_INTERNAL_MALLOC
	LOCK(&ctx->lock);
	mem_putunlocked(ctx, ptr, size);
#else /* ISC_MEM_USE_INTERNAL_MALLOC */
	mem_put(ctx, ptr, size);
	LOCK(&ctx->lock);
	mem_putstats(ctx, ptr, size);
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d1020 1
a1020 1
	UNLOCK(&ctx->lock);
d1039 1
a1039 1
	LOCK(&ctx->lock);
d1046 1
a1046 1
	UNLOCK(&ctx->lock);
d1057 1
a1057 1
	LOCK(&ctx->lock);
d1059 1
a1059 1
	UNLOCK(&ctx->lock);
d1072 12
a1083 9
#if ISC_MEM_USE_INTERNAL_MALLOC
	LOCK(&ctx->lock);
	ptr = mem_getunlocked(ctx, size);
#else /* ISC_MEM_USE_INTERNAL_MALLOC */
	ptr = mem_get(ctx, size);
	LOCK(&ctx->lock);
	if (ptr != NULL)
		mem_getstats(ctx, size);
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d1098 1
a1098 1
	UNLOCK(&ctx->lock);
d1110 2
d1116 20
a1135 8
#if ISC_MEM_USE_INTERNAL_MALLOC
	LOCK(&ctx->lock);
	mem_putunlocked(ctx, ptr, size);
#else /* ISC_MEM_USE_INTERNAL_MALLOC */
	mem_put(ctx, ptr, size);
	LOCK(&ctx->lock);
	mem_putstats(ctx, ptr, size);
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d1151 1
a1151 1
	UNLOCK(&ctx->lock);
d1208 1
a1208 1
	LOCK(&ctx->lock);
d1218 2
a1219 2
#if ISC_MEM_USE_INTERNAL_MALLOC
		if (s->blocks != 0 || s->freefrags != 0)
a1221 1
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d1269 1
a1269 1
	UNLOCK(&ctx->lock);
d1282 8
a1289 5
#if ISC_MEM_USE_INTERNAL_MALLOC
	si = mem_getunlocked(ctx, size);
#else /* ISC_MEM_USE_INTERNAL_MALLOC */
	si = mem_get(ctx, size);
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d1292 4
d1303 1
d1307 9
a1315 9
#if ISC_MEM_USE_INTERNAL_MALLOC
	LOCK(&ctx->lock);
	si = isc__mem_allocateunlocked(ctx, size);
#else /* ISC_MEM_USE_INTERNAL_MALLOC */
	si = isc__mem_allocateunlocked(ctx, size);
	LOCK(&ctx->lock);
	if (si != NULL)
		mem_getstats(ctx, si[-1].u.size);
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d1320 13
d1334 2
a1335 1
	UNLOCK(&ctx->lock);
d1344 1
d1349 8
a1356 2
	si = &(((size_info *)ptr)[-1]);
	size = si->u.size;
d1358 8
a1365 8
#if ISC_MEM_USE_INTERNAL_MALLOC
	LOCK(&ctx->lock);
	mem_putunlocked(ctx, si, size);
#else /* ISC_MEM_USE_INTERNAL_MALLOC */
	mem_put(ctx, si, size);
	LOCK(&ctx->lock);
	mem_putstats(ctx, si, size);
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d1369 16
a1384 1
	UNLOCK(&ctx->lock);
d1413 1
a1413 1
	LOCK(&ctx->lock);
d1417 1
a1417 1
	UNLOCK(&ctx->lock);
d1427 1
a1427 1
	LOCK(&ctx->lock);
d1431 1
a1431 1
	UNLOCK(&ctx->lock);
d1439 1
a1439 1
	LOCK(&ctx->lock);
d1443 1
a1443 1
	UNLOCK(&ctx->lock);
d1453 1
a1453 1
	LOCK(&ctx->lock);
d1457 1
a1457 1
	UNLOCK(&ctx->lock);
d1466 4
d1473 3
a1475 1
	LOCK(&ctx->lock);
d1477 1
d1484 4
d1494 4
a1497 1
	UNLOCK(&ctx->lock);
d1537 1
a1537 1
	LOCK(&mctx->lock);
d1539 1
a1539 1
	UNLOCK(&mctx->lock);
d1591 1
a1591 1
	LOCK(&mctx->lock);
d1598 6
a1603 6
#if ISC_MEM_USE_INTERNAL_MALLOC
		mem_putunlocked(mctx, item, mpctx->size);
#else /* ISC_MEM_USE_INTERNAL_MALLOC */
		mem_put(mctx, item, mpctx->size);
		mem_putstats(mctx, item, mpctx->size);
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d1605 1
a1605 1
	UNLOCK(&mctx->lock);
d1610 1
a1610 1
	LOCK(&mctx->lock);
d1612 1
a1612 1
	UNLOCK(&mctx->lock);
d1671 1
a1671 1
	LOCK(&mctx->lock);
d1673 7
a1679 7
#if ISC_MEM_USE_INTERNAL_MALLOC
		item = mem_getunlocked(mctx, mpctx->size);
#else /* ISC_MEM_USE_INTERNAL_MALLOC */
		item = mem_get(mctx, mpctx->size);
		if (item != NULL)
			mem_getstats(mctx, mpctx->size);
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d1686 1
a1686 1
	UNLOCK(&mctx->lock);
d1706 1
a1706 1
		LOCK(&mctx->lock);
d1708 1
a1708 1
		UNLOCK(&mctx->lock);
d1732 1
a1732 1
	LOCK(&mctx->lock);
d1734 1
a1734 1
	UNLOCK(&mctx->lock);
d1741 10
a1750 10
#if ISC_MEM_USE_INTERNAL_MALLOC
		LOCK(&mctx->lock);
		mem_putunlocked(mctx, mem, mpctx->size);
		UNLOCK(&mctx->lock);
#else /* ISC_MEM_USE_INTERNAL_MALLOC */
		mem_put(mctx, mem, mpctx->size);
		LOCK(&mctx->lock);
		mem_putstats(mctx, mem, mpctx->size);
		UNLOCK(&mctx->lock);
#endif /* ISC_MEM_USE_INTERNAL_MALLOC */
d1897 57
@


1.4
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: mem.c,v 1.98.2.7.2.5 2004/03/16 05:50:24 marka Exp $ */
d720 9
a786 9
	if (isc_mutex_init(&ctx->lock) != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "isc_mutex_init() %s",
				 isc_msgcat_get(isc_msgcat, ISC_MSGSET_GENERAL,
						ISC_MSG_FAILED, "failed"));
		result = ISC_R_UNEXPECTED;
		goto error;
	}

d808 2
a809 2
	if (ctx) {
		if (ctx->stats)
d812 1
a812 1
		if (ctx->freelists)
d816 1
a816 1
		if (ctx->debuglist)
d819 1
@


1.3
log
@update to BIND v9.2.3. ok todd@@
@
text
@d2 1
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: mem.c,v 1.98.2.8 2003/10/09 07:32:48 marka Exp $ */
d71 1
d111 4
d149 1
a149 2
	ISC_LIST(debuglink_t)	debuglist;
	unsigned int		debugging;
d190 6
a195 1
	do { if (b != NULL) add_trace_entry(a, b, c, d, e); } while (0)
a197 3
#define MEM_TRACE	((isc_mem_debugging & ISC_MEM_DEBUGTRACE) != 0)
#define MEM_RECORD	((mctx->debugging & ISC_MEM_DEBUGRECORD) != 0)

d211 1
a211 1
	if (MEM_TRACE)
d218 1
a218 1
	if (!MEM_RECORD)
d221 4
a224 1
	dl = ISC_LIST_HEAD(mctx->debuglist);
d228 1
a228 1
		for (i = 0 ; i < DEBUGLIST_COUNT ; i++) {
d231 1
d246 1
a246 1
	for (i = 1 ; i < DEBUGLIST_COUNT ; i++) {
d248 1
d254 1
d259 1
a259 1
	ISC_LIST_PREPEND(mctx->debuglist, dl, link);
d269 1
a269 1
	if (MEM_TRACE)
d276 1
a276 1
	if (!MEM_RECORD)
d279 4
a282 1
	dl = ISC_LIST_HEAD(mctx->debuglist);
d284 1
a284 1
		for (i = 0 ; i < DEBUGLIST_COUNT ; i++) {
d287 1
d294 1
a294 1
					ISC_LIST_UNLINK(mctx->debuglist,
d357 1
a357 1
					table_size * sizeof (unsigned char *));
d365 1
a365 1
			       sizeof (unsigned char *));
d716 1
a716 1
	ctx = (memalloc)(arg, sizeof *ctx);
d741 3
d751 1
a751 1
				(ctx->max_size+1) * sizeof (struct stats));
d756 1
a756 1
	memset(ctx->stats, 0, (ctx->max_size + 1) * sizeof (struct stats));
d763 1
a763 1
	ctx->freelists = (memalloc)(arg, ctx->max_size * sizeof (element *));
d769 1
a769 1
	       ctx->max_size * sizeof (element *));
d788 12
a799 2
	ISC_LIST_INIT(ctx->debuglist);
	ctx->debugging = isc_mem_debugging;
d815 4
d846 9
a854 6
	if (ctx->checkfree) {
		if (!ISC_LIST_EMPTY(ctx->debuglist))
			print_active(ctx, stderr);
		INSIST(ISC_LIST_EMPTY(ctx->debuglist));
	} else {
		debuglink_t *dl;
d856 8
a863 5
		for (dl = ISC_LIST_HEAD(ctx->debuglist);
		     dl != NULL;
		     dl = ISC_LIST_HEAD(ctx->debuglist)) {
			ISC_LIST_UNLINK(ctx->debuglist, dl, link);
			free(dl);
d865 1
d873 1
a873 1
			if (ctx->stats[i].gets != 0)
d1030 1
a1030 1
	if (ptr)
d1049 1
a1049 1
	if (call_water) {
a1050 1
	}
d1088 1
a1088 1
	if (call_water) {
a1089 1
	}
d1095 1
a1095 1
	if (MEM_RECORD) {
d1097 3
a1099 1
		unsigned int i;
d1105 22
a1126 2
		dl = ISC_LIST_HEAD(mctx->debuglist);
		if (dl == NULL)
d1128 1
a1128 16
						    ISC_MSG_NONE,
						    "\tNone.\n"));
		while (dl != NULL) {
			for (i = 0 ; i < DEBUGLIST_COUNT ; i++)
				if (dl->ptr[i] != NULL)
					fprintf(out,
						isc_msgcat_get(isc_msgcat,
							   ISC_MSGSET_MEM,
							   ISC_MSG_PTRFILELINE,
							   "\tptr %p "
							   "file %s "
							   "line %u\n"),
						dl->ptr[i], dl->file[i],
						dl->line[i]);
			dl = ISC_LIST_NEXT(dl, link);
		}
d1246 1
a1246 2
	if (si != NULL)
		ADD_TRACE(ctx, si, si[-1].u.size, file, line);
d1469 1
a1476 1
		LOCK(&mctx->lock);
a1477 1
		UNLOCK(&mctx->lock);
d1480 1
d1483 1
d1549 2
a1550 1
	for (i = 0 ; i < mpctx->fillcount ; i++) {
a1551 1
		LOCK(&mctx->lock);
a1552 1
		UNLOCK(&mctx->lock);
d1555 2
d1564 1
d1625 3
@


1.2
log
@string cleaning; "Put it in.  If it breaks, tough" Theo.
work by me, useful feedback from krw, jakob, tedu, and tholo
@
text
@d2 1
a2 1
 * Copyright (C) 1997-2002  Internet Software Consortium.
d18 1
a18 1
/* $ISC: mem.c,v 1.98.2.6 2002/07/10 06:10:45 marka Exp $ */
d650 1
a650 1
		INSIST(ctx->stats[ctx->max_size].gets > 0);
d653 1
a653 1
		INSIST(ctx->stats[size].gets > 0);
d667 1
a667 1
	if (size == 0)
d704 1
a704 1
	if (init_max_size == 0)
d836 1
a836 1
			INSIST(ctx->stats[i].gets == 0);
d995 1
a995 1
	if (ctx->hi_water != 0 && !ctx->hi_called &&
d1002 1
a1002 1
		if (ctx->hi_water != 0 && ctx->inuse > ctx->hi_water &&
d1041 1
a1041 1
	    (ctx->inuse < ctx->lo_water || ctx->lo_water == 0)) {
d1103 1
a1103 1
		if (s->totalgets == 0 && s->gets == 0)
d1343 1
a1343 1
	REQUIRE(size > 0);
@


1.1
log
@Initial revision
@
text
@d1253 1
a1253 1
		strncpy(ns, s, len + 1);
d1386 1
a1386 2
	strncpy(mpctx->name, name, sizeof(mpctx->name) - 1);
	mpctx->name[sizeof(mpctx->name) - 1] = '\0';
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1997-2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: mem.c,v 1.98.2.7.2.5 2004/03/16 05:50:24 marka Exp $ */
a70 1
	unsigned int		size[DEBUGLIST_COUNT];
a109 4
#if ISC_MEM_TRACKLINES
typedef ISC_LIST(debuglink_t)	debuglist_t;
#endif

d144 2
a145 1
	debuglist_t *	 	debuglist;
d186 1
a186 6
	do { \
		if ((isc_mem_debugging & (ISC_MEM_DEBUGTRACE | \
					  ISC_MEM_DEBUGRECORD)) != 0 && \
		     b != NULL) \
		         add_trace_entry(a, b, c, d, e); \
	} while (0)
d189 3
d205 1
a205 1
	if ((isc_mem_debugging & ISC_MEM_DEBUGTRACE) != 0)
d212 1
a212 1
	if (mctx->debuglist == NULL)
d215 1
a215 4
	if (size > mctx->max_size)
		size = mctx->max_size;

	dl = ISC_LIST_HEAD(mctx->debuglist[size]);
d219 1
a219 1
		for (i = 0; i < DEBUGLIST_COUNT; i++) {
a221 1
				dl->size[i] = size;
d236 1
a236 1
	for (i = 1; i < DEBUGLIST_COUNT; i++) {
a237 1
		dl->size[i] = 0;
a242 1
	dl->size[0] = size;
d247 1
a247 1
	ISC_LIST_PREPEND(mctx->debuglist[size], dl, link);
d257 1
a257 1
	if ((isc_mem_debugging & ISC_MEM_DEBUGTRACE) != 0)
d264 1
a264 1
	if (mctx->debuglist == NULL)
d267 1
a267 4
	if (size > mctx->max_size)
		size = mctx->max_size;

	dl = ISC_LIST_HEAD(mctx->debuglist[size]);
d269 1
a269 1
		for (i = 0; i < DEBUGLIST_COUNT; i++) {
a271 1
				dl->size[i] = 0;
d278 1
a278 1
					ISC_LIST_UNLINK(mctx->debuglist[size],
d341 1
a341 1
					table_size * sizeof(unsigned char *));
d349 1
a349 1
			       sizeof(unsigned char *));
d650 1
a650 1
		INSIST(ctx->stats[ctx->max_size].gets > 0U);
d653 1
a653 1
		INSIST(ctx->stats[size].gets > 0U);
d667 1
a667 1
	if (size == 0U)
d700 1
a700 1
	ctx = (memalloc)(arg, sizeof(*ctx));
d704 1
a704 1
	if (init_max_size == 0U)
a724 3
#if ISC_MEM_TRACKLINES
	ctx->debuglist = NULL;
#endif
d732 1
a732 1
				(ctx->max_size+1) * sizeof(struct stats));
d737 1
a737 1
	memset(ctx->stats, 0, (ctx->max_size + 1) * sizeof(struct stats));
d744 1
a744 1
	ctx->freelists = (memalloc)(arg, ctx->max_size * sizeof(element *));
d750 1
a750 1
	       ctx->max_size * sizeof(element *));
d769 2
a770 12
	if ((isc_mem_debugging & ISC_MEM_DEBUGRECORD) != 0) {
		unsigned int i;

		ctx->debuglist = (memalloc)(arg,
				      (ctx->max_size+1) * sizeof(debuglist_t));
		if (ctx->debuglist == NULL) {
			result = ISC_R_NOMEMORY;
			goto error;
		}
		for (i = 0; i <= ctx->max_size; i++)
			ISC_LIST_INIT(ctx->debuglist[i]);
	}
a785 4
#if ISC_MEM_TRACKLINES
		if (ctx->debuglist)
			(ctx->memfree)(ctx->arg, ctx->debuglist);
#endif /* ISC_MEM_TRACKLINES */
d813 6
a818 9
	if (ctx->debuglist != NULL) {
		if (ctx->checkfree) {
			for (i = 0; i <= ctx->max_size; i++) {
				if (!ISC_LIST_EMPTY(ctx->debuglist[i]))
					print_active(ctx, stderr);
				INSIST(ISC_LIST_EMPTY(ctx->debuglist[i]));
			}
		} else {
			debuglink_t *dl;
d820 5
a824 8
			for (i = 0; i <= ctx->max_size; i++)
				for (dl = ISC_LIST_HEAD(ctx->debuglist[i]);
				     dl != NULL;
				     dl = ISC_LIST_HEAD(ctx->debuglist[i])) {
					ISC_LIST_UNLINK(ctx->debuglist[i],
						 	dl, link);
					free(dl);
				}
a825 1
		(ctx->memfree)(ctx->arg, ctx->debuglist);
d833 1
a833 1
			if (ctx->stats[i].gets != 0U)
d836 1
a836 1
			INSIST(ctx->stats[i].gets == 0U);
d990 1
a990 1
	if (ptr != NULL)
d995 1
a995 1
	if (ctx->hi_water != 0U && !ctx->hi_called &&
d1002 1
a1002 1
		if (ctx->hi_water != 0U && ctx->inuse > ctx->hi_water &&
d1009 1
a1009 1
	if (call_water)
d1011 1
d1041 1
a1041 1
	    (ctx->inuse < ctx->lo_water || ctx->lo_water == 0U)) {
d1049 1
a1049 1
	if (call_water)
d1051 1
d1057 1
a1057 1
	if (mctx->debuglist != NULL) {
d1059 1
a1059 3
		unsigned int i, j;
		const char *format;
		isc_boolean_t found;
d1065 18
a1082 20
		found = ISC_FALSE;
		format = isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
				        ISC_MSG_PTRFILELINE,
					"\tptr %p size %u file %s line %u\n");
		for (i = 0; i <= mctx->max_size; i++) {
			dl = ISC_LIST_HEAD(mctx->debuglist[i]);
			
			if (dl != NULL)
				found = ISC_TRUE;

			while (dl != NULL) {
				for (j = 0; j < DEBUGLIST_COUNT; j++)
					if (dl->ptr[j] != NULL)
						fprintf(out, format,
							dl->ptr[j],
							dl->size[j],
							dl->file[j],
							dl->line[j]);
				dl = ISC_LIST_NEXT(dl, link);
			}
a1083 3
		if (!found)
			fprintf(out, isc_msgcat_get(isc_msgcat, ISC_MSGSET_MEM,
						    ISC_MSG_NONE, "\tNone.\n"));
d1103 1
a1103 1
		if (s->totalgets == 0U && s->gets == 0U)
d1201 2
a1202 1
	ADD_TRACE(ctx, si, si[-1].u.size, file, line);
d1343 1
a1343 1
	REQUIRE(size > 0U);
a1425 1
	LOCK(&mctx->lock);
d1433 1
d1435 1
a1437 1
		mem_putstats(mctx, item, mpctx->size);
a1439 1
	UNLOCK(&mctx->lock);
d1505 1
a1505 2
	LOCK(&mctx->lock);
	for (i = 0; i < mpctx->fillcount; i++) {
d1507 1
d1509 1
a1511 2
		if (item != NULL)
			mem_getstats(mctx, mpctx->size);
a1518 1
	UNLOCK(&mctx->lock);
a1578 3
		LOCK(&mctx->lock);
		mem_putstats(mctx, mem, mpctx->size);
		UNLOCK(&mctx->lock);
@


1.1.1.3
log
@ISC BIND release 9.3.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: mem.c,v 1.98.2.7.2.7 2005/03/17 03:58:32 marka Exp $ */
a719 9
	if (isc_mutex_init(&ctx->lock) != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "isc_mutex_init() %s",
				 isc_msgcat_get(isc_msgcat, ISC_MSGSET_GENERAL,
						ISC_MSG_FAILED, "failed"));
		(memfree)(arg, ctx);
		return (ISC_R_UNEXPECTED);
	}

d778 9
d808 2
a809 2
	if (ctx != NULL) {
		if (ctx->stats != NULL)
d812 1
a812 1
		if (ctx->freelists != NULL)
d816 1
a816 1
		if (ctx->debuglist != NULL)
a818 1
		DESTROYLOCK(&ctx->lock);
@


1.1.1.4
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2007  Internet Systems Consortium, Inc. ("ISC")
d5 1
a5 1
 * Permission to use, copy, modify, and/or distribute this software for any
d18 1
a18 3
/* $ISC: mem.c,v 1.116.18.18 2007/10/30 23:31:43 marka Exp $ */

/*! \file */
a30 1
#include <isc/once.h>
a36 3
#define MCTXLOCK(m, l) if (((m)->flags & ISC_MEMFLAG_NOLOCK) == 0) LOCK(l)
#define MCTXUNLOCK(m, l) if (((m)->flags & ISC_MEMFLAG_NOLOCK) == 0) UNLOCK(l)

d43 10
d58 2
a59 2
#define ALIGNMENT_SIZE		8		/*%< must be a power of 2 */
#define NUM_BASIC_BLOCKS	64		/*%< must be > 1 */
d90 1
a90 1
	/*!
a94 1
		isc_mem_t	*ctx;
d102 1
d105 1
a114 6
/* List of all active memory contexts. */

static ISC_LIST(isc_mem_t)	contexts;
static isc_once_t		once = ISC_ONCE_INIT;
static isc_mutex_t		lock;

a117 1
	unsigned int		flags;
d137 1
a137 1
	/*  ISC_MEMFLAG_INTERNAL */
d146 1
a152 1
	ISC_LINK(isc_mem_t)	link;
d160 16
a175 16
	unsigned int	magic;		/*%< magic number */
	isc_mutex_t    *lock;		/*%< optional lock */
	isc_mem_t      *mctx;		/*%< our memory context */
	/*%< locked via the memory context's lock */
	ISC_LINK(isc_mempool_t)	link;	/*%< next pool in this mem context */
	/*%< optionally locked from here down */
	element	       *items;		/*%< low water item list */
	size_t		size;		/*%< size of each item on this pool */
	unsigned int	maxalloc;	/*%< max number of items allowed */
	unsigned int	allocated;	/*%< # of items currently given out */
	unsigned int	freecount;	/*%< # of items on reserved list */
	unsigned int	freemax;	/*%< # of items allowed on free list */
	unsigned int	fillcount;	/*%< # of items to fetch on each fill */
	/*%< Stats only. */
	unsigned int	gets;		/*%< # of requests to this pool */
	/*%< Debugging only. */
d177 1
a177 1
	char		name[16];	/*%< printed name in stats reports */
d201 1
a201 1
/*!
d312 1
d323 1
a323 1
	/*!
d329 1
a329 1
	if (size == 0U)
d350 1
a350 1
	if (ctx->quota != 0U && ctx->total + increment > ctx->quota)
d411 1
a411 1
	/*!
d451 1
a451 1
	if (total_size > 0U) {
d475 1
a475 1
		if (ctx->quota != 0U && ctx->total + size > ctx->quota) {
d559 1
a559 1
		INSIST(ctx->stats[ctx->max_size].gets != 0U);
d586 1
a586 1
	INSIST(ctx->stats[size].gets != 0U);
d592 3
a594 1
/*!
d622 1
a622 1
/*!
d638 1
a638 1
/*!
d655 1
a655 1
/*!
d674 2
a693 6
static void
initialize_action(void) {
	RUNTIME_CHECK(isc_mutex_init(&lock) == ISC_R_SUCCESS);
	ISC_LIST_INIT(contexts);
}

a702 10
	return (isc_mem_createx2(init_max_size, target_size, memalloc, memfree,
				 arg, ctxp, ISC_MEMFLAG_DEFAULT));
				 
}

isc_result_t
isc_mem_createx2(size_t init_max_size, size_t target_size,
		 isc_memalloc_t memalloc, isc_memfree_t memfree, void *arg,
		 isc_mem_t **ctxp, unsigned int flags)
{
d712 3
a714 1
	RUNTIME_CHECK(isc_once_do(&once, initialize_action) == ISC_R_SUCCESS);
d720 7
a726 6
	if ((flags & ISC_MEMFLAG_NOLOCK) == 0) {
		result = isc_mutex_init(&ctx->lock);
		if (result != ISC_R_SUCCESS) {
			(memfree)(arg, ctx);
			return (result);
		}
a732 1
	ctx->flags = flags;
d754 2
d757 1
a757 6
	ctx->basic_blocks = NULL;
	ctx->basic_table = NULL;
	ctx->basic_table_count = 0;
	ctx->basic_table_size = 0;
	ctx->lowest = NULL;
	ctx->highest = NULL;
d767 9
a775 13
	if ((flags & ISC_MEMFLAG_INTERNAL) != 0) {
		if (target_size == 0U)
			ctx->mem_target = DEF_MEM_TARGET;
		else
			ctx->mem_target = target_size;
		ctx->freelists = (memalloc)(arg, ctx->max_size *
						 sizeof(element *));
		if (ctx->freelists == NULL) {
			result = ISC_R_NOMEMORY;
			goto error;
		}
		memset(ctx->freelists, 0,
		       ctx->max_size * sizeof(element *));
d777 9
a803 4
	LOCK(&lock);
	ISC_LIST_INITANDAPPEND(contexts, ctx, link);
	UNLOCK(&lock);

d811 1
d814 1
d819 1
a819 2
		if ((ctx->flags & ISC_MEMFLAG_NOLOCK) == 0)
			DESTROYLOCK(&ctx->lock);
d830 3
a832 12
	return (isc_mem_createx2(init_max_size, target_size,
				 default_memalloc, default_memfree, NULL,
				 ctxp, ISC_MEMFLAG_DEFAULT));
}

isc_result_t
isc_mem_create2(size_t init_max_size, size_t target_size,
		isc_mem_t **ctxp, unsigned int flags)
{
	return (isc_mem_createx2(init_max_size, target_size,
				 default_memalloc, default_memfree, NULL,
				 ctxp, flags));
d842 1
a842 4
	LOCK(&lock);
	ISC_LIST_UNLINK(contexts, ctx, link);
	UNLOCK(&lock);

d844 1
d883 6
a888 6
	if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
		for (i = 0; i < ctx->basic_table_count; i++)
			(ctx->memfree)(ctx->arg, ctx->basic_table[i]);
		(ctx->memfree)(ctx->arg, ctx->freelists);
		(ctx->memfree)(ctx->arg, ctx->basic_table);
	}
d892 1
a892 2
	if ((ctx->flags & ISC_MEMFLAG_NOLOCK) == 0)
		DESTROYLOCK(&ctx->lock);
d903 1
a903 1
	MCTXLOCK(source, &source->lock);
d905 1
a905 1
	MCTXUNLOCK(source, &source->lock);
d919 1
a919 1
	MCTXLOCK(ctx, &ctx->lock);
d924 1
a924 1
	MCTXUNLOCK(ctx, &ctx->lock);
a945 2
	size_info *si;
	size_t oldsize;
d958 8
a965 29
	if ((isc_mem_debugging & (ISC_MEM_DEBUGSIZE|ISC_MEM_DEBUGCTX)) != 0) {
		if ((isc_mem_debugging & ISC_MEM_DEBUGSIZE) != 0) {
			si = &(((size_info *)ptr)[-1]);
			oldsize = si->u.size - ALIGNMENT_SIZE;
			if ((isc_mem_debugging & ISC_MEM_DEBUGCTX) != 0)
				oldsize -= ALIGNMENT_SIZE;
			INSIST(oldsize == size);
		}
		isc__mem_free(ctx, ptr FLARG_PASS);

		MCTXLOCK(ctx, &ctx->lock);
		ctx->references--;
		if (ctx->references == 0)
			want_destroy = ISC_TRUE;
		MCTXUNLOCK(ctx, &ctx->lock);
		if (want_destroy)
			destroy(ctx);

		return;
	}

	if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
		MCTXLOCK(ctx, &ctx->lock);
		mem_putunlocked(ctx, ptr, size);
	} else {
		mem_put(ctx, ptr, size);
		MCTXLOCK(ctx, &ctx->lock);
		mem_putstats(ctx, ptr, size);
	}
d973 1
a973 1
	MCTXUNLOCK(ctx, &ctx->lock);
d992 1
a992 1
	MCTXLOCK(ctx, &ctx->lock);
d999 1
a999 1
	MCTXUNLOCK(ctx, &ctx->lock);
d1010 1
a1010 1
	MCTXLOCK(ctx, &ctx->lock);
d1012 1
a1012 1
	MCTXUNLOCK(ctx, &ctx->lock);
d1025 9
a1033 12
	if ((isc_mem_debugging & (ISC_MEM_DEBUGSIZE|ISC_MEM_DEBUGCTX)) != 0)
		return (isc__mem_allocate(ctx, size FLARG_PASS));

	if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
		MCTXLOCK(ctx, &ctx->lock);
		ptr = mem_getunlocked(ctx, size);
	} else {
		ptr = mem_get(ctx, size);
		MCTXLOCK(ctx, &ctx->lock);
		if (ptr != NULL)
			mem_getstats(ctx, size);
	}
d1048 1
a1048 1
	MCTXUNLOCK(ctx, &ctx->lock);
a1059 2
	size_info *si;
	size_t oldsize;
d1064 8
a1071 20
	if ((isc_mem_debugging & (ISC_MEM_DEBUGSIZE|ISC_MEM_DEBUGCTX)) != 0) {
		if ((isc_mem_debugging & ISC_MEM_DEBUGSIZE) != 0) {
			si = &(((size_info *)ptr)[-1]);
			oldsize = si->u.size - ALIGNMENT_SIZE;
			if ((isc_mem_debugging & ISC_MEM_DEBUGCTX) != 0)
				oldsize -= ALIGNMENT_SIZE;
			INSIST(oldsize == size);
		}
		isc__mem_free(ctx, ptr FLARG_PASS);
		return;
	}

	if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
		MCTXLOCK(ctx, &ctx->lock);
		mem_putunlocked(ctx, ptr, size);
	} else {
		mem_put(ctx, ptr, size);
		MCTXLOCK(ctx, &ctx->lock);
		mem_putstats(ctx, ptr, size);
	}
d1087 1
a1087 1
	MCTXUNLOCK(ctx, &ctx->lock);
d1144 1
a1144 1
	MCTXLOCK(ctx, &ctx->lock);
d1154 2
a1155 2
		if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0 &&
		    (s->blocks != 0U || s->freefrags != 0U))
d1158 1
d1206 1
a1206 1
	MCTXUNLOCK(ctx, &ctx->lock);
d1219 5
a1223 8
	if ((isc_mem_debugging & ISC_MEM_DEBUGCTX) != 0)
		size += ALIGNMENT_SIZE;

	if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0)
		si = mem_getunlocked(ctx, size);
	else
		si = mem_get(ctx, size);

a1225 4
	if ((isc_mem_debugging & ISC_MEM_DEBUGCTX) != 0) {
		si->u.ctx = ctx;
		si++;
	}
a1232 1
	isc_boolean_t call_water = ISC_FALSE;
d1236 9
a1244 9
	if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
		MCTXLOCK(ctx, &ctx->lock);
		si = isc__mem_allocateunlocked(ctx, size);
	} else {
		si = isc__mem_allocateunlocked(ctx, size);
		MCTXLOCK(ctx, &ctx->lock);
		if (si != NULL)
			mem_getstats(ctx, si[-1].u.size);
	}
a1248 13
	if (ctx->hi_water != 0U && !ctx->hi_called &&
	    ctx->inuse > ctx->hi_water) {
		ctx->hi_called = ISC_TRUE;
		call_water = ISC_TRUE;
	}
	if (ctx->inuse > ctx->maxinuse) {
		ctx->maxinuse = ctx->inuse;
		if (ctx->hi_water != 0U && ctx->inuse > ctx->hi_water &&
		    (isc_mem_debugging & ISC_MEM_DEBUGUSAGE) != 0)
			fprintf(stderr, "maxinuse = %lu\n",
				(unsigned long)ctx->inuse);
	}
	MCTXUNLOCK(ctx, &ctx->lock);
d1250 1
a1250 2
	if (call_water)
		(ctx->water)(ctx->water_arg, ISC_MEM_HIWATER);
a1258 1
	isc_boolean_t call_water= ISC_FALSE;
d1263 2
a1264 8
	if ((isc_mem_debugging & ISC_MEM_DEBUGCTX) != 0) {
		si = &(((size_info *)ptr)[-2]);
		REQUIRE(si->u.ctx == ctx);
		size = si[1].u.size;
	} else {
		si = &(((size_info *)ptr)[-1]);
		size = si->u.size;
	}
d1266 8
a1273 8
	if ((ctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
		MCTXLOCK(ctx, &ctx->lock);
		mem_putunlocked(ctx, si, size);
	} else {
		mem_put(ctx, si, size);
		MCTXLOCK(ctx, &ctx->lock);
		mem_putstats(ctx, si, size);
	}
d1277 1
a1277 16
	/*
	 * The check against ctx->lo_water == 0 is for the condition
	 * when the context was pushed over hi_water but then had
	 * isc_mem_setwater() called with 0 for hi_water and lo_water.
	 */
	if (ctx->hi_called && 
	    (ctx->inuse < ctx->lo_water || ctx->lo_water == 0U)) {
		ctx->hi_called = ISC_FALSE;

		if (ctx->water != NULL)
			call_water = ISC_TRUE;
	}
	MCTXUNLOCK(ctx, &ctx->lock);

	if (call_water)
		(ctx->water)(ctx->water_arg, ISC_MEM_LOWATER);
d1306 1
a1306 1
	MCTXLOCK(ctx, &ctx->lock);
d1310 1
a1310 1
	MCTXUNLOCK(ctx, &ctx->lock);
d1320 1
a1320 1
	MCTXLOCK(ctx, &ctx->lock);
d1324 1
a1324 1
	MCTXUNLOCK(ctx, &ctx->lock);
d1332 1
a1332 1
	MCTXLOCK(ctx, &ctx->lock);
d1336 1
a1336 1
	MCTXUNLOCK(ctx, &ctx->lock);
d1346 1
a1346 1
	MCTXLOCK(ctx, &ctx->lock);
d1350 1
a1350 1
	MCTXUNLOCK(ctx, &ctx->lock);
a1358 4
	isc_boolean_t callwater = ISC_FALSE;
	isc_mem_water_t oldwater;
	void *oldwater_arg;

d1362 1
a1362 3
	MCTXLOCK(ctx, &ctx->lock);
	oldwater = ctx->water;
	oldwater_arg = ctx->water_arg;
a1363 1
		callwater = ctx->hi_called;
a1369 4
		if (ctx->hi_called &&
		    (ctx->water != water || ctx->water_arg != water_arg ||
		     ctx->inuse < lowater || lowater == 0U))
			callwater = ISC_TRUE;
d1376 1
a1376 4
	MCTXUNLOCK(ctx, &ctx->lock);
	
	if (callwater && oldwater != NULL)
		(oldwater)(oldwater_arg, ISC_MEM_LOWATER);
d1416 1
a1416 1
	MCTXLOCK(mctx, &mctx->lock);
d1418 1
a1418 1
	MCTXUNLOCK(mctx, &mctx->lock);
d1471 1
a1471 1
	MCTXLOCK(mctx, &mctx->lock);
d1478 6
a1483 6
		if ((mctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
			mem_putunlocked(mctx, item, mpctx->size);
		} else {
			mem_put(mctx, item, mpctx->size);
			mem_putstats(mctx, item, mpctx->size);
		}
d1485 1
a1485 1
	MCTXUNLOCK(mctx, &mctx->lock);
d1490 1
a1490 1
	MCTXLOCK(mctx, &mctx->lock);
d1492 1
a1492 1
	MCTXUNLOCK(mctx, &mctx->lock);
d1551 1
a1551 1
	MCTXLOCK(mctx, &mctx->lock);
d1553 7
a1559 7
		if ((mctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
			item = mem_getunlocked(mctx, mpctx->size);
		} else {
			item = mem_get(mctx, mpctx->size);
			if (item != NULL)
				mem_getstats(mctx, mpctx->size);
		}
d1566 1
a1566 1
	MCTXUNLOCK(mctx, &mctx->lock);
d1586 1
a1586 1
		MCTXLOCK(mctx, &mctx->lock);
d1588 1
a1588 1
		MCTXUNLOCK(mctx, &mctx->lock);
d1612 1
a1612 1
	MCTXLOCK(mctx, &mctx->lock);
d1614 1
a1614 1
	MCTXUNLOCK(mctx, &mctx->lock);
d1621 10
a1630 10
		if ((mctx->flags & ISC_MEMFLAG_INTERNAL) != 0) {
			MCTXLOCK(mctx, &mctx->lock);
			mem_putunlocked(mctx, mem, mpctx->size);
			MCTXUNLOCK(mctx, &mctx->lock);
		} else {
			mem_put(mctx, mem, mpctx->size);
			MCTXLOCK(mctx, &mctx->lock);
			mem_putstats(mctx, mem, mpctx->size);
			MCTXUNLOCK(mctx, &mctx->lock);
		}
a1776 57
}

void
isc_mem_printactive(isc_mem_t *ctx, FILE *file) {

	REQUIRE(VALID_CONTEXT(ctx));
	REQUIRE(file != NULL);

#if !ISC_MEM_TRACKLINES
	UNUSED(ctx);
	UNUSED(file);
#else
	print_active(ctx, file);
#endif
}

void
isc_mem_printallactive(FILE *file) {
#if !ISC_MEM_TRACKLINES
	UNUSED(file);
#else
	isc_mem_t *ctx;

	RUNTIME_CHECK(isc_once_do(&once, initialize_action) == ISC_R_SUCCESS);

	LOCK(&lock);
	for (ctx = ISC_LIST_HEAD(contexts);
	     ctx != NULL;
	     ctx = ISC_LIST_NEXT(ctx, link)) {
		fprintf(file, "context: %p\n", ctx);
		print_active(ctx, file);
	}
	UNLOCK(&lock);
#endif
}

void    
isc_mem_checkdestroyed(FILE *file) {

	RUNTIME_CHECK(isc_once_do(&once, initialize_action) == ISC_R_SUCCESS);

	LOCK(&lock);
	if (!ISC_LIST_EMPTY(contexts))  {
#if ISC_MEM_TRACKLINES
		isc_mem_t *ctx;

		for (ctx = ISC_LIST_HEAD(contexts);
		     ctx != NULL;
		     ctx = ISC_LIST_NEXT(ctx, link)) {
			fprintf(file, "context: %p\n", ctx);
			print_active(ctx, file);
		}
		fflush(file);
#endif
		INSIST(0);
	}
	UNLOCK(&lock);
@


