head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.36
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.32
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.34
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.26
	OPENBSD_5_7_BASE:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.30
	OPENBSD_5_6_BASE:1.1.1.4
	OPENBSD_5_5:1.1.1.4.0.28
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.24
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.22
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.20
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.18
	OPENBSD_5_0:1.1.1.4.0.16
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.14
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.12
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.8
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.10
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.6
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.4
	OPENBSD_4_4_BASE:1.1.1.4
	BIND_9_4_2_P1:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	OPENBSD_4_3_BASE:1.1.1.4
	BIND_9_4_2:1.1.1.4
	OPENBSD_4_2:1.1.1.3.0.4
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.2
	OPENBSD_4_1_BASE:1.1.1.3
	BIND_9_3_4:1.1.1.3
	BIND_9_3_3:1.1.1.3
	OPENBSD_4_0:1.1.1.2.0.8
	OPENBSD_4_0_BASE:1.1.1.2
	BIND_9_3_2:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.6
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.4
	OPENBSD_3_8_BASE:1.1.1.2
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.01.20.21.07.46;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.46;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.57;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.01.10.18.20.19;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.12.09.12.33.51;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (C) 2000, 2001  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: cfg.h,v 1.30 2001/08/03 23:19:01 gson Exp $ */

#ifndef ISCCFG_CFG_H
#define ISCCFG_CFG_H 1

/*****
 ***** Module Info
 *****/

/*
 * This is the new, table-driven, YACC-free configuration file parser.
 */


/***
 *** Imports
 ***/

#include <isc/formatcheck.h>
#include <isc/lang.h>
#include <isc/types.h>
#include <isc/list.h>


/***
 *** Types
 ***/

typedef struct cfg_parser cfg_parser_t;
/*
 * A configuration parser.
 */

/*
 * A configuration type definition object.  There is a single
 * static cfg_type_t object for each data type supported by
 * the configuration parser.
 */
typedef struct cfg_type cfg_type_t;

/*
 * A configuration object.  This is the basic building block of the
 * configuration parse tree.  It contains a value (which may be
 * of one of several types) and information identifying the file
 * and line number the value came from, for printing error
 * messages.
 */
typedef struct cfg_obj cfg_obj_t;

/*
 * A configuration object list element.
 */
typedef struct cfg_listelt cfg_listelt_t;

/*
 * A callback function to be called when parsing an option 
 * that needs to be interpreted at parsing time, like
 * "directory".
 */
typedef isc_result_t
(*cfg_parsecallback_t)(const char *clausename, cfg_obj_t *obj, void *arg);

/***
 *** Functions
 ***/

ISC_LANG_BEGINDECLS

isc_result_t
cfg_parser_create(isc_mem_t *mctx, isc_log_t *lctx, cfg_parser_t **ret);
/*
 * Create a configuration file parser.  Any warning and error
 * messages will be logged to 'lctx'.
 *
 * The parser object returned can be used for a single call
 * to cfg_parse_file() or cfg_parse_buffer().  It must not
 * be reused for parsing multiple files or buffers.
 */

void
cfg_parser_setcallback(cfg_parser_t *pctx,
		       cfg_parsecallback_t callback,
		       void *arg);
/*
 * Make the parser call 'callback' whenever it encounters
 * a configuration clause with the callback attribute,
 * passing it the clause name, the clause value,
 * and 'arg' as arguments.
 *
 * To restore the default of not invoking callbacks, pass
 * callback==NULL and arg==NULL.
 */

isc_result_t
cfg_parse_file(cfg_parser_t *pctx, const char *filename,
	       const cfg_type_t *type, cfg_obj_t **ret);
isc_result_t
cfg_parse_buffer(cfg_parser_t *pctx, isc_buffer_t *buffer,
		 const cfg_type_t *type, cfg_obj_t **ret);
/*
 * Read a configuration containing data of type 'type'
 * and make '*ret' point to its parse tree.
 *
 * The configuration is read from the file 'filename'
 * (isc_parse_file()) or the buffer 'buffer'
 * (isc_parse_buffer()).
 *
 * Returns an error if the file does not parse correctly.
 * 
 * Requires:
 *      "filename" is valid.
 *      "mem" is valid.
 *	"type" is valid.
 *      "cfg" is non-NULL and "*cfg" is NULL.
 *
 * Returns:
 *      ISC_R_SUCCESS                 - success
 *      ISC_R_NOMEMORY                - no memory available
 *      ISC_R_INVALIDFILE             - file doesn't exist or is unreadable
 *      others	                      - file contains errors
 */

void
cfg_parser_destroy(cfg_parser_t **pctxp);
/*
 * Destroy a configuration parser.
 */

isc_boolean_t
cfg_obj_isvoid(cfg_obj_t *obj);
/*
 * Return true iff 'obj' is of void type (e.g., an optional 
 * value not specified).
 */

isc_boolean_t
cfg_obj_ismap(cfg_obj_t *obj);
/*
 * Return true iff 'obj' is of a map type.
 */

isc_result_t
cfg_map_get(cfg_obj_t *mapobj, const char* name, cfg_obj_t **obj);
/*
 * Extract an element from a configuration object, which
 * must be of a map type.
 *
 * Requires:
 *      'mapobj' points to a valid configuration object of a map type.
 *      'name' points to a null-terminated string.
 * 	'obj' is non-NULL and '*obj' is NULL.
 *
 * Returns:
 *      ISC_R_SUCCESS                  - success
 *      ISC_R_NOTFOUND                 - name not found in map
 */

cfg_obj_t *
cfg_map_getname(cfg_obj_t *mapobj);
/*
 * Get the name of a named map object, like a server "key" clause.
 *
 * Requires:
 *      'mapobj' points to a valid configuration object of a map type.
 *
 * Returns:
 *      A pointer to a configuration object naming the map object,
 *	or NULL if the map object does not have a name.
 */

isc_boolean_t
cfg_obj_istuple(cfg_obj_t *obj);
/*
 * Return true iff 'obj' is of a map type.
 */

cfg_obj_t *
cfg_tuple_get(cfg_obj_t *tupleobj, const char *name);
/*
 * Extract an element from a configuration object, which
 * must be of a tuple type.
 *
 * Requires:
 *      'tupleobj' points to a valid configuration object of a tuple type.
 *      'name' points to a null-terminated string naming one of the
 *	fields of said tuple type.
 */

isc_boolean_t
cfg_obj_isuint32(cfg_obj_t *obj);
/*
 * Return true iff 'obj' is of integer type.
 */

isc_uint32_t
cfg_obj_asuint32(cfg_obj_t *obj);
/*
 * Returns the value of a configuration object of 32-bit integer type.
 *
 * Requires:
 *      'obj' points to a valid configuration object of 32-bit integer type.
 *
 * Returns:
 *      A 32-bit unsigned integer.
 */

isc_boolean_t
cfg_obj_isuint64(cfg_obj_t *obj);
/*
 * Return true iff 'obj' is of integer type.
 */

isc_uint64_t
cfg_obj_asuint64(cfg_obj_t *obj);
/*
 * Returns the value of a configuration object of 64-bit integer type.
 *
 * Requires:
 *      'obj' points to a valid configuration object of 64-bit integer type.
 *
 * Returns:
 *      A 64-bit unsigned integer.
 */

isc_boolean_t
cfg_obj_isstring(cfg_obj_t *obj);
/*
 * Return true iff 'obj' is of string type.
 */

char *
cfg_obj_asstring(cfg_obj_t *obj);
/*
 * Returns the value of a configuration object of a string type
 * as a null-terminated string.
 *
 * Requires:
 *      'obj' points to a valid configuration object of a string type.
 *
 * Returns:
 *      A pointer to a null terminated string.
 */

isc_boolean_t
cfg_obj_isboolean(cfg_obj_t *obj);
/*
 * Return true iff 'obj' is of a boolean type.
 */

isc_boolean_t
cfg_obj_asboolean(cfg_obj_t *obj);
/*
 * Returns the value of a configuration object of a boolean type.
 *
 * Requires:
 *      'obj' points to a valid configuration object of a boolean type.
 *
 * Returns:
 *      A boolean value.
 */

isc_boolean_t
cfg_obj_issockaddr(cfg_obj_t *obj);
/*
 * Return true iff 'obj' is a socket address.
 */

isc_sockaddr_t *
cfg_obj_assockaddr(cfg_obj_t *obj);
/*
 * Returns the value of a configuration object representing a socket address.
 *
 * Requires:
 *      'obj' points to a valid configuration object of a socket address type.
 *
 * Returns:
 *      A pointer to a sockaddr.  The sockaddr must be copied by the caller
 *      if necessary.
 */

isc_boolean_t
cfg_obj_isnetprefix(cfg_obj_t *obj);
/*
 * Return true iff 'obj' is a network prefix.
 */

void
cfg_obj_asnetprefix(cfg_obj_t *obj, isc_netaddr_t *netaddr,
		    unsigned int *prefixlen);
/*
 * Gets the value of a configuration object representing a network
 * prefix.  The network address is returned through 'netaddr' and the
 * prefix length in bits through 'prefixlen'.
 *
 * Requires:
 *      'obj' points to a valid configuration object of network prefix type.
 *	'netaddr' and 'prefixlen' are non-NULL.
 */

isc_boolean_t
cfg_obj_islist(cfg_obj_t *obj);
/*
 * Return true iff 'obj' is of list type.
 */

cfg_listelt_t *
cfg_list_first(cfg_obj_t *obj);
/*
 * Returns the first list element in a configuration object of a list type.
 *
 * Requires:
 *      'obj' points to a valid configuration object of a list type or NULL.
 *
 * Returns:
 *      A pointer to a cfg_listelt_t representing the first list element,
 * 	or NULL if the list is empty or nonexistent.
 */

cfg_listelt_t *
cfg_list_next(cfg_listelt_t *elt);
/*
 * Returns the next element of a list of configuration objects.
 *
 * Requires:
 *      'elt' points to cfg_listelt_t obtained from cfg_list_first() or
 *	a previous call to cfg_list_next().
 *
 * Returns:
 *      A pointer to a cfg_listelt_t representing the next element,
 * 	or NULL if there are no more elements.
 */

cfg_obj_t *
cfg_listelt_value(cfg_listelt_t *elt);
/*
 * Returns the configuration object associated with cfg_listelt_t.
 *
 * Requires:
 *      'elt' points to cfg_listelt_t obtained from cfg_list_first() or
 *	cfg_list_next().
 *
 * Returns:
 *      A non-NULL pointer to a configuration object.
 */

void
cfg_print(cfg_obj_t *obj,
	  void (*f)(void *closure, const char *text, int textlen),
	  void *closure);
/*
 * Print the configuration object 'obj' by repeatedly calling the
 * function 'f', passing 'closure' and a region of text starting
 * at 'text' and comprising 'textlen' characters.
 */

void
cfg_print_grammar(const cfg_type_t *type,
	  void (*f)(void *closure, const char *text, int textlen),
	  void *closure);
/*
 * Print a summary of the grammar of the configuration type 'type'.
 */

isc_boolean_t
cfg_obj_istype(cfg_obj_t *obj, const cfg_type_t *type);
/*
 * Return true iff 'obj' is of type 'type'. 
 */

void cfg_obj_destroy(cfg_parser_t *pctx, cfg_obj_t **obj);
/*
 * Destroy a configuration object.
 */

void
cfg_obj_log(cfg_obj_t *obj, isc_log_t *lctx, int level, const char *fmt, ...)
	ISC_FORMAT_PRINTF(4, 5);
/*
 * Log a message concerning configuration object 'obj' to the logging
 * channel of 'pctx', at log level 'level'.  The message will be prefixed
 * with the file name(s) and line number where 'obj' was defined.
 */

/*
 * Configuration object types.
 */
LIBISCCFG_EXTERNAL_DATA extern cfg_type_t cfg_type_namedconf;
/* A complete named.conf file. */

LIBISCCFG_EXTERNAL_DATA extern cfg_type_t cfg_type_rndcconf;
/* A complete rndc.conf file. */

LIBISCCFG_EXTERNAL_DATA extern cfg_type_t cfg_type_rndckey;
/* A complete rndc.key file. */

LIBISCCFG_EXTERNAL_DATA extern cfg_type_t cfg_type_keyref;
/* A key reference, used as an ACL element */

ISC_LANG_ENDDECLS

#endif /* ISCCFG_CFG_H */
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 2000-2002  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: cfg.h,v 1.30.12.4 2004/03/08 09:05:07 marka Exp $ */
d31 1
a400 2
const char *
cfg_obj_file(cfg_obj_t *obj);
d402 1
a402 1
 * Return the file that defined this object.
d404 5
d410 2
a411 5
unsigned int
cfg_obj_line(cfg_obj_t *obj);
/*
 * Return the line in file where this object was defined.
 */
d413 2
@


1.1.1.3
log
@ISC BIND release 9.3.3
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: cfg.h,v 1.30.12.6 2006/03/02 00:37:20 marka Exp $ */
d77 1
a77 1
(*cfg_parsecallback_t)(const char *clausename, const cfg_obj_t *obj, void *arg);
d146 1
a146 1
cfg_obj_isvoid(const cfg_obj_t *obj);
d153 1
a153 1
cfg_obj_ismap(const cfg_obj_t *obj);
d159 1
a159 1
cfg_map_get(const cfg_obj_t *mapobj, const char* name, const cfg_obj_t **obj);
d174 2
a175 2
const cfg_obj_t *
cfg_map_getname(const cfg_obj_t *mapobj);
d188 1
a188 1
cfg_obj_istuple(const cfg_obj_t *obj);
d193 2
a194 2
const cfg_obj_t *
cfg_tuple_get(const cfg_obj_t *tupleobj, const char *name);
d206 1
a206 1
cfg_obj_isuint32(const cfg_obj_t *obj);
d212 1
a212 1
cfg_obj_asuint32(const cfg_obj_t *obj);
d224 1
a224 1
cfg_obj_isuint64(const cfg_obj_t *obj);
d230 1
a230 1
cfg_obj_asuint64(const cfg_obj_t *obj);
d242 1
a242 1
cfg_obj_isstring(const cfg_obj_t *obj);
d247 2
a248 2
const char *
cfg_obj_asstring(const cfg_obj_t *obj);
d261 1
a261 1
cfg_obj_isboolean(const cfg_obj_t *obj);
d267 1
a267 1
cfg_obj_asboolean(const cfg_obj_t *obj);
d279 1
a279 1
cfg_obj_issockaddr(const cfg_obj_t *obj);
d284 2
a285 2
const isc_sockaddr_t *
cfg_obj_assockaddr(const cfg_obj_t *obj);
d298 1
a298 1
cfg_obj_isnetprefix(const cfg_obj_t *obj);
d304 1
a304 1
cfg_obj_asnetprefix(const cfg_obj_t *obj, isc_netaddr_t *netaddr,
d317 1
a317 1
cfg_obj_islist(const cfg_obj_t *obj);
d322 2
a323 2
const cfg_listelt_t *
cfg_list_first(const cfg_obj_t *obj);
d335 2
a336 2
const cfg_listelt_t *
cfg_list_next(const cfg_listelt_t *elt);
d349 2
a350 2
const cfg_obj_t *
cfg_listelt_value(const cfg_listelt_t *elt);
d363 1
a363 1
cfg_print(const cfg_obj_t *obj,
d381 1
a381 1
cfg_obj_istype(const cfg_obj_t *obj, const cfg_type_t *type);
d392 1
a392 2
cfg_obj_log(const cfg_obj_t *obj, isc_log_t *lctx, int level,
            const char *fmt, ...)
d401 1
a401 1
cfg_obj_file(const cfg_obj_t *obj);
d407 1
a407 1
cfg_obj_line(const cfg_obj_t *obj);
@


1.1.1.4
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: cfg.h,v 1.34.18.5 2006/03/02 00:37:22 marka Exp $ */
d27 1
a27 2
/*! \file
 * \brief
d45 2
a46 1
/*%
a48 1
typedef struct cfg_parser cfg_parser_t;
d50 1
a50 1
/*%
d57 1
a57 1
/*%
d66 1
a66 1
/*%
d71 1
a71 1
/*%
d87 1
a87 1
/*%<
d100 1
a100 1
/*%<
d116 1
a116 1
/*%<
d127 4
a130 4
 *\li 	"filename" is valid.
 *\li 	"mem" is valid.
 *\li	"type" is valid.
 *\li 	"cfg" is non-NULL and "*cfg" is NULL.
d133 4
a136 4
 *     \li #ISC_R_SUCCESS                 - success
 *\li      #ISC_R_NOMEMORY                - no memory available
 *\li      #ISC_R_INVALIDFILE             - file doesn't exist or is unreadable
 *\li      others	                      - file contains errors
d141 1
a141 1
/*%<
d147 1
a147 1
/*%<
d154 1
a154 1
/*%<
d160 1
a160 1
/*%<
d165 3
a167 3
 * \li     'mapobj' points to a valid configuration object of a map type.
 * \li     'name' points to a null-terminated string.
 * \li	'obj' is non-NULL and '*obj' is NULL.
d170 2
a171 2
 * \li     #ISC_R_SUCCESS                  - success
 * \li     #ISC_R_NOTFOUND                 - name not found in map
d176 1
a176 1
/*%<
d180 1
a180 1
 *    \li  'mapobj' points to a valid configuration object of a map type.
d183 1
a183 1
 * \li     A pointer to a configuration object naming the map object,
d189 1
a189 1
/*%<
d195 1
a195 1
/*%<
d200 3
a202 3
 * \li     'tupleobj' points to a valid configuration object of a tuple type.
 * \li     'name' points to a null-terminated string naming one of the
 *\li	fields of said tuple type.
d207 1
a207 1
/*%<
d213 1
a213 1
/*%<
d217 1
a217 1
 * \li     'obj' points to a valid configuration object of 32-bit integer type.
d220 1
a220 1
 * \li     A 32-bit unsigned integer.
d225 1
a225 1
/*%<
d231 1
a231 1
/*%<
d235 1
a235 1
 * \li     'obj' points to a valid configuration object of 64-bit integer type.
d238 1
a238 1
 * \li     A 64-bit unsigned integer.
d243 1
a243 1
/*%<
d249 1
a249 1
/*%<
d254 1
a254 1
 * \li     'obj' points to a valid configuration object of a string type.
d257 1
a257 1
 * \li     A pointer to a null terminated string.
d262 1
a262 1
/*%<
d268 1
a268 1
/*%<
d272 1
a272 1
 * \li     'obj' points to a valid configuration object of a boolean type.
d275 1
a275 1
 * \li     A boolean value.
d280 1
a280 1
/*%<
d286 1
a286 1
/*%<
d290 1
a290 1
 * \li     'obj' points to a valid configuration object of a socket address type.
d293 1
a293 1
 * \li     A pointer to a sockaddr.  The sockaddr must be copied by the caller
d299 1
a299 1
/*%<
d306 1
a306 1
/*%<
d312 2
a313 2
 * \li     'obj' points to a valid configuration object of network prefix type.
 *\li	'netaddr' and 'prefixlen' are non-NULL.
d318 1
a318 1
/*%<
d324 1
a324 1
/*%<
d328 1
a328 1
 * \li     'obj' points to a valid configuration object of a list type or NULL.
d331 1
a331 1
 *   \li   A pointer to a cfg_listelt_t representing the first list element,
d337 1
a337 1
/*%<
d341 1
a341 1
 * \li     'elt' points to cfg_listelt_t obtained from cfg_list_first() or
d345 1
a345 1
 * \li     A pointer to a cfg_listelt_t representing the next element,
d351 1
a351 1
/*%<
d355 1
a355 1
 * \li     'elt' points to cfg_listelt_t obtained from cfg_list_first() or
d359 1
a359 1
 * \li     A non-NULL pointer to a configuration object.
d366 1
a366 1
/*%<
d376 1
a376 1
/*%<
d382 1
a382 1
/*%<
d387 1
a387 1
/*%<
d395 1
a395 1
/*%<
d403 1
a403 1
/*%<
d409 1
a409 1
/*%<
@


