head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.42
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.40
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.36
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.32
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.34
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.26
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.30
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.28
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.24
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.22
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.20
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.18
	OPENBSD_5_0:1.12.0.16
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.14
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.12
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.8
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.10
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.6
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	BIND_9_4_2_P1:1.1.1.4
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	BIND_9_4_2:1.1.1.4
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	BIND_9_3_4:1.1.1.3
	BIND_9_3_3:1.1.1.3
	OPENBSD_4_0:1.10.0.6
	OPENBSD_4_0_BASE:1.10
	BIND_9_3_2:1.1.1.2
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2007.12.09.13.39.44;	author jakob;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.10.19.07.59;	author jakob;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.28.10.12.58;	author moritz;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.28.17.14.08;	author jakob;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.08.23.39.35;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.08.21.39.08;	author pvalchev;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.18.14.14.08;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.22.19.49.28;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.08.22.34.46;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.15.13.20.17;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.05.09.18.33;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.07.46;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.46;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.56;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.01.10.18.20.19;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.12.09.12.33.51;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.12
log
@resolve conflicts
@
text
@/*
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 2000-2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: parser.c,v 1.112.18.11 2006/02/28 03:10:49 marka Exp $ */

/*! \file */

#include <config.h>

#include <isc/buffer.h>
#include <isc/dir.h>
#include <isc/formatcheck.h>
#include <isc/lex.h>
#include <isc/log.h>
#include <isc/mem.h>
#include <isc/net.h>
#include <isc/netaddr.h>
#include <isc/print.h>
#include <isc/string.h>
#include <isc/sockaddr.h>
#include <isc/netscope.h>
#include <isc/util.h>
#include <isc/symtab.h>

#include <isccfg/cfg.h>
#include <isccfg/grammar.h>
#include <isccfg/log.h>

/* Shorthand */
#define CAT CFG_LOGCATEGORY_CONFIG
#define MOD CFG_LOGMODULE_PARSER

#define MAP_SYM 1 	/* Unique type for isc_symtab */

#define TOKEN_STRING(pctx) (pctx->token.value.as_textregion.base)

/* Check a return value. */
#define CHECK(op) 						\
     	do { result = (op); 					\
		if (result != ISC_R_SUCCESS) goto cleanup; 	\
	} while (0)

/* Clean up a configuration object if non-NULL. */
#define CLEANUP_OBJ(obj) \
	do { if ((obj) != NULL) cfg_obj_destroy(pctx, &(obj)); } while (0)


/*
 * Forward declarations of static functions.
 */

static void
free_tuple(cfg_parser_t *pctx, cfg_obj_t *obj);

static isc_result_t
parse_list(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret);

static void
print_list(cfg_printer_t *pctx, const cfg_obj_t *obj);

static void
free_list(cfg_parser_t *pctx, cfg_obj_t *obj);

static isc_result_t
create_listelt(cfg_parser_t *pctx, cfg_listelt_t **eltp);

static isc_result_t
create_string(cfg_parser_t *pctx, const char *contents, const cfg_type_t *type,
	      cfg_obj_t **ret);

static void
free_string(cfg_parser_t *pctx, cfg_obj_t *obj);

static isc_result_t
create_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **objp);

static void
free_map(cfg_parser_t *pctx, cfg_obj_t *obj);

static isc_result_t
parse_symtab_elt(cfg_parser_t *pctx, const char *name,
		 cfg_type_t *elttype, isc_symtab_t *symtab,
		 isc_boolean_t callback);

static void
free_noop(cfg_parser_t *pctx, cfg_obj_t *obj);

static isc_result_t
cfg_getstringtoken(cfg_parser_t *pctx);

static void
parser_complain(cfg_parser_t *pctx, isc_boolean_t is_warning,
		unsigned int flags, const char *format, va_list args);

/*
 * Data representations.  These correspond to members of the
 * "value" union in struct cfg_obj (except "void", which does
 * not need a union member).
 */

cfg_rep_t cfg_rep_uint32 = { "uint32", free_noop };
cfg_rep_t cfg_rep_uint64 = { "uint64", free_noop };
cfg_rep_t cfg_rep_string = { "string", free_string };
cfg_rep_t cfg_rep_boolean = { "boolean", free_noop };
cfg_rep_t cfg_rep_map = { "map", free_map };
cfg_rep_t cfg_rep_list = { "list", free_list };
cfg_rep_t cfg_rep_tuple = { "tuple", free_tuple };
cfg_rep_t cfg_rep_sockaddr = { "sockaddr", free_noop };
cfg_rep_t cfg_rep_netprefix = { "netprefix", free_noop };
cfg_rep_t cfg_rep_void = { "void", free_noop };

/*
 * Configuration type definitions.
 */

/*%
 * An implicit list.  These are formed by clauses that occur multiple times.
 */
static cfg_type_t cfg_type_implicitlist = {
	"implicitlist", NULL, print_list, NULL, &cfg_rep_list, NULL };

/* Functions. */

void
cfg_print_obj(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	obj->type->print(pctx, obj);
}

void
cfg_print_chars(cfg_printer_t *pctx, const char *text, int len) {
	pctx->f(pctx->closure, text, len);
}

static void
print_open(cfg_printer_t *pctx) {
	cfg_print_chars(pctx, "{\n", 2);
	pctx->indent++;
}

static void
print_indent(cfg_printer_t *pctx) {
	int indent = pctx->indent;
	while (indent > 0) {
		cfg_print_chars(pctx, "\t", 1);
		indent--;
	}
}

static void
print_close(cfg_printer_t *pctx) {
	pctx->indent--;
	print_indent(pctx);
	cfg_print_chars(pctx, "}", 1);
}

isc_result_t
cfg_parse_obj(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	isc_result_t result;
	INSIST(ret != NULL && *ret == NULL);
	result = type->parse(pctx, type, ret);
	if (result != ISC_R_SUCCESS)
		return (result);
	INSIST(*ret != NULL);
	return (ISC_R_SUCCESS);
}

void
cfg_print(const cfg_obj_t *obj,
	  void (*f)(void *closure, const char *text, int textlen),
	  void *closure)
{
	cfg_printer_t pctx;
	pctx.f = f;
	pctx.closure = closure;
	pctx.indent = 0;
	obj->type->print(&pctx, obj);
}


/* Tuples. */
  
isc_result_t
cfg_create_tuple(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	isc_result_t result;
	const cfg_tuplefielddef_t *fields = type->of;
	const cfg_tuplefielddef_t *f;
	cfg_obj_t *obj = NULL;
	unsigned int nfields = 0;
	int i;

	for (f = fields; f->name != NULL; f++)
		nfields++;

	CHECK(cfg_create_obj(pctx, type, &obj));
	obj->value.tuple = isc_mem_get(pctx->mctx,
				       nfields * sizeof(cfg_obj_t *));
	if (obj->value.tuple == NULL) {
		result = ISC_R_NOMEMORY;
		goto cleanup;
	}
	for (f = fields, i = 0; f->name != NULL; f++, i++)
		obj->value.tuple[i] = NULL;
	*ret = obj;
	return (ISC_R_SUCCESS);

 cleanup:
	if (obj != NULL)
		isc_mem_put(pctx->mctx, obj, sizeof(*obj));
	return (result);
}

isc_result_t
cfg_parse_tuple(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret)
{
	isc_result_t result;
	const cfg_tuplefielddef_t *fields = type->of;
	const cfg_tuplefielddef_t *f;
	cfg_obj_t *obj = NULL;
	unsigned int i;

	CHECK(cfg_create_tuple(pctx, type, &obj));
	for (f = fields, i = 0; f->name != NULL; f++, i++)
		CHECK(cfg_parse_obj(pctx, f->type, &obj->value.tuple[i]));

	*ret = obj;
	return (ISC_R_SUCCESS);

 cleanup:
	CLEANUP_OBJ(obj);
	return (result);
}

void
cfg_print_tuple(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	unsigned int i;
	const cfg_tuplefielddef_t *fields = obj->type->of;
	const cfg_tuplefielddef_t *f;
	isc_boolean_t need_space = ISC_FALSE;

	for (f = fields, i = 0; f->name != NULL; f++, i++) {
		const cfg_obj_t *fieldobj = obj->value.tuple[i];
		if (need_space)
			cfg_print_chars(pctx, " ", 1);
		cfg_print_obj(pctx, fieldobj);
		need_space = ISC_TF(fieldobj->type->print != cfg_print_void);
	}
}

void
cfg_doc_tuple(cfg_printer_t *pctx, const cfg_type_t *type) {
	const cfg_tuplefielddef_t *fields = type->of;
	const cfg_tuplefielddef_t *f;
	isc_boolean_t need_space = ISC_FALSE;

	for (f = fields; f->name != NULL; f++) {
		if (need_space)
			cfg_print_chars(pctx, " ", 1);
		cfg_doc_obj(pctx, f->type);
		need_space = ISC_TF(f->type->print != cfg_print_void);
	}
}

static void
free_tuple(cfg_parser_t *pctx, cfg_obj_t *obj) {
	unsigned int i;
	const cfg_tuplefielddef_t *fields = obj->type->of;
	const cfg_tuplefielddef_t *f;
	unsigned int nfields = 0;

	if (obj->value.tuple == NULL)
		return;

	for (f = fields, i = 0; f->name != NULL; f++, i++) {
		CLEANUP_OBJ(obj->value.tuple[i]);
		nfields++;
	}
	isc_mem_put(pctx->mctx, obj->value.tuple,
		    nfields * sizeof(cfg_obj_t *));
}

isc_boolean_t
cfg_obj_istuple(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL);
	return (ISC_TF(obj->type->rep == &cfg_rep_tuple));
}

const cfg_obj_t *
cfg_tuple_get(const cfg_obj_t *tupleobj, const char* name) {
	unsigned int i;
	const cfg_tuplefielddef_t *fields;
	const cfg_tuplefielddef_t *f;
	
	REQUIRE(tupleobj != NULL && tupleobj->type->rep == &cfg_rep_tuple);

	fields = tupleobj->type->of;
	for (f = fields, i = 0; f->name != NULL; f++, i++) {
		if (strcmp(f->name, name) == 0)
			return (tupleobj->value.tuple[i]);
	}
	INSIST(0);
	return (NULL);
}

isc_result_t
cfg_parse_special(cfg_parser_t *pctx, int special) {
        isc_result_t result;
	CHECK(cfg_gettoken(pctx, 0));
	if (pctx->token.type == isc_tokentype_special &&
	    pctx->token.value.as_char == special)
		return (ISC_R_SUCCESS);

	cfg_parser_error(pctx, CFG_LOG_NEAR, "'%c' expected", special);
	return (ISC_R_UNEXPECTEDTOKEN);
 cleanup:
	return (result);
}

/*
 * Parse a required semicolon.  If it is not there, log
 * an error and increment the error count but continue
 * parsing.  Since the next token is pushed back,
 * care must be taken to make sure it is eventually
 * consumed or an infinite loop may result.
 */
static isc_result_t
parse_semicolon(cfg_parser_t *pctx) {
        isc_result_t result;
	CHECK(cfg_gettoken(pctx, 0));
	if (pctx->token.type == isc_tokentype_special &&
	    pctx->token.value.as_char == ';')
		return (ISC_R_SUCCESS);

	cfg_parser_error(pctx, CFG_LOG_BEFORE, "missing ';'");
	cfg_ungettoken(pctx);
 cleanup:
	return (result);
}

/*
 * Parse EOF, logging and returning an error if not there.
 */
static isc_result_t
parse_eof(cfg_parser_t *pctx) {
        isc_result_t result;
	CHECK(cfg_gettoken(pctx, 0));

	if (pctx->token.type == isc_tokentype_eof)
		return (ISC_R_SUCCESS);

	cfg_parser_error(pctx, CFG_LOG_NEAR, "syntax error");
	return (ISC_R_UNEXPECTEDTOKEN);
 cleanup:
	return (result);
}

/* A list of files, used internally for pctx->files. */

static cfg_type_t cfg_type_filelist = {
	"filelist", NULL, print_list, NULL, &cfg_rep_list,
	&cfg_type_qstring
};

isc_result_t
cfg_parser_create(isc_mem_t *mctx, isc_log_t *lctx, cfg_parser_t **ret) {
	isc_result_t result;
	cfg_parser_t *pctx;
	isc_lexspecials_t specials;

	REQUIRE(mctx != NULL);
	REQUIRE(ret != NULL && *ret == NULL);

	pctx = isc_mem_get(mctx, sizeof(*pctx));
	if (pctx == NULL)
		return (ISC_R_NOMEMORY);

	pctx->mctx = mctx;
	pctx->lctx = lctx;
	pctx->lexer = NULL;
	pctx->seen_eof = ISC_FALSE;
	pctx->ungotten = ISC_FALSE;
	pctx->errors = 0;
	pctx->warnings = 0;
	pctx->open_files = NULL;
	pctx->closed_files = NULL;
	pctx->line = 0;
	pctx->callback = NULL;
	pctx->callbackarg = NULL;
	pctx->token.type = isc_tokentype_unknown;

	memset(specials, 0, sizeof(specials));
	specials['{'] = 1;
	specials['}'] = 1;
	specials[';'] = 1;
	specials['/'] = 1;
	specials['"'] = 1;
	specials['!'] = 1;

	CHECK(isc_lex_create(pctx->mctx, 1024, &pctx->lexer));

	isc_lex_setspecials(pctx->lexer, specials);
	isc_lex_setcomments(pctx->lexer, (ISC_LEXCOMMENT_C |
					 ISC_LEXCOMMENT_CPLUSPLUS |
					 ISC_LEXCOMMENT_SHELL));

	CHECK(cfg_create_list(pctx, &cfg_type_filelist, &pctx->open_files));
	CHECK(cfg_create_list(pctx, &cfg_type_filelist, &pctx->closed_files));

	*ret = pctx;
	return (ISC_R_SUCCESS);

 cleanup:
	if (pctx->lexer != NULL)
		isc_lex_destroy(&pctx->lexer);
	CLEANUP_OBJ(pctx->open_files);
	CLEANUP_OBJ(pctx->closed_files);
	isc_mem_put(mctx, pctx, sizeof(*pctx));
	return (result);
}

static isc_result_t
parser_openfile(cfg_parser_t *pctx, const char *filename) {
	isc_result_t result;
	cfg_listelt_t *elt = NULL;
	cfg_obj_t *stringobj = NULL;

	result = isc_lex_openfile(pctx->lexer, filename);
	if (result != ISC_R_SUCCESS) {
		cfg_parser_error(pctx, 0, "open: %s: %s",
			     filename, isc_result_totext(result));
		goto cleanup;
	}

	CHECK(create_string(pctx, filename, &cfg_type_qstring, &stringobj));
	CHECK(create_listelt(pctx, &elt));
	elt->obj = stringobj;
	ISC_LIST_APPEND(pctx->open_files->value.list, elt, link);

	return (ISC_R_SUCCESS);
 cleanup:
	CLEANUP_OBJ(stringobj);
	return (result);
}

void
cfg_parser_setcallback(cfg_parser_t *pctx,
		       cfg_parsecallback_t callback,
		       void *arg)
{
	pctx->callback = callback;
	pctx->callbackarg = arg;
}

/*
 * Parse a configuration using a pctx where a lexer has already
 * been set up with a source.
 */
static isc_result_t
parse2(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	isc_result_t result;
	cfg_obj_t *obj = NULL;

	result = cfg_parse_obj(pctx, type, &obj);

	if (pctx->errors != 0) {
		/* Errors have been logged. */
		if (result == ISC_R_SUCCESS)
			result = ISC_R_FAILURE;
		goto cleanup;
	}

	if (result != ISC_R_SUCCESS) {
		/* Parsing failed but no errors have been logged. */
		cfg_parser_error(pctx, 0, "parsing failed");
		goto cleanup;
	}

	CHECK(parse_eof(pctx));

	*ret = obj;
	return (ISC_R_SUCCESS);

 cleanup:
	CLEANUP_OBJ(obj);
	return (result);
}

isc_result_t
cfg_parse_file(cfg_parser_t *pctx, const char *filename,
	       const cfg_type_t *type, cfg_obj_t **ret)
{
	isc_result_t result;

	REQUIRE(filename != NULL);

	CHECK(parser_openfile(pctx, filename));
	CHECK(parse2(pctx, type, ret));
 cleanup:
	return (result);
}


isc_result_t
cfg_parse_buffer(cfg_parser_t *pctx, isc_buffer_t *buffer,
	const cfg_type_t *type, cfg_obj_t **ret)
{
	isc_result_t result;
	REQUIRE(buffer != NULL);
	CHECK(isc_lex_openbuffer(pctx->lexer, buffer));	
	CHECK(parse2(pctx, type, ret));
 cleanup:
	return (result);
}

void
cfg_parser_destroy(cfg_parser_t **pctxp) {
	cfg_parser_t *pctx = *pctxp;
	isc_lex_destroy(&pctx->lexer);
	/*
	 * Cleaning up open_files does not
	 * close the files; that was already done
	 * by closing the lexer.
	 */
	CLEANUP_OBJ(pctx->open_files);
	CLEANUP_OBJ(pctx->closed_files);
	isc_mem_put(pctx->mctx, pctx, sizeof(*pctx));
	*pctxp = NULL;
}

/*
 * void
 */
isc_result_t
cfg_parse_void(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	UNUSED(type);
	return (cfg_create_obj(pctx, &cfg_type_void, ret));
}

void
cfg_print_void(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	UNUSED(pctx);
	UNUSED(obj);
}

void
cfg_doc_void(cfg_printer_t *pctx, const cfg_type_t *type) {
	UNUSED(pctx);
	UNUSED(type);
}

isc_boolean_t
cfg_obj_isvoid(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL);
	return (ISC_TF(obj->type->rep == &cfg_rep_void));
}

cfg_type_t cfg_type_void = {
	"void", cfg_parse_void, cfg_print_void, cfg_doc_void, &cfg_rep_void,
	NULL };


/*
 * uint32
 */
isc_result_t
cfg_parse_uint32(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
        isc_result_t result;
	cfg_obj_t *obj = NULL;
	UNUSED(type);

	CHECK(cfg_gettoken(pctx, ISC_LEXOPT_NUMBER | ISC_LEXOPT_CNUMBER));
	if (pctx->token.type != isc_tokentype_number) {
		cfg_parser_error(pctx, CFG_LOG_NEAR, "expected number");
		return (ISC_R_UNEXPECTEDTOKEN);
	}

	CHECK(cfg_create_obj(pctx, &cfg_type_uint32, &obj));

	obj->value.uint32 = pctx->token.value.as_ulong;
	*ret = obj;
 cleanup:
	return (result);
}

void
cfg_print_cstr(cfg_printer_t *pctx, const char *s) {
	cfg_print_chars(pctx, s, strlen(s));
}

void
cfg_print_rawuint(cfg_printer_t *pctx, unsigned int u) {
	char buf[32];
	snprintf(buf, sizeof(buf), "%u", u);
	cfg_print_cstr(pctx, buf);
}

void
cfg_print_uint32(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	cfg_print_rawuint(pctx, obj->value.uint32);
}

isc_boolean_t
cfg_obj_isuint32(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL);
	return (ISC_TF(obj->type->rep == &cfg_rep_uint32));
}

isc_uint32_t
cfg_obj_asuint32(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL && obj->type->rep == &cfg_rep_uint32);
	return (obj->value.uint32);
}

cfg_type_t cfg_type_uint32 = {
	"integer", cfg_parse_uint32, cfg_print_uint32, cfg_doc_terminal,
	&cfg_rep_uint32, NULL
};


/*
 * uint64
 */
isc_boolean_t
cfg_obj_isuint64(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL);
	return (ISC_TF(obj->type->rep == &cfg_rep_uint64));
}

isc_uint64_t
cfg_obj_asuint64(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL && obj->type->rep == &cfg_rep_uint64);
	return (obj->value.uint64);
}

void
cfg_print_uint64(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	char buf[32];
	snprintf(buf, sizeof(buf), "%" ISC_PRINT_QUADFORMAT "u",
		 obj->value.uint64);
	cfg_print_cstr(pctx, buf);
}

cfg_type_t cfg_type_uint64 = {
	"64_bit_integer", NULL, cfg_print_uint64, cfg_doc_terminal,
	&cfg_rep_uint64, NULL
};

/*
 * qstring (quoted string), ustring (unquoted string), astring
 * (any string)
 */

/* Create a string object from a null-terminated C string. */
static isc_result_t
create_string(cfg_parser_t *pctx, const char *contents, const cfg_type_t *type,
	      cfg_obj_t **ret)
{
	isc_result_t result;
	cfg_obj_t *obj = NULL;
	int len;

	CHECK(cfg_create_obj(pctx, type, &obj));
	len = strlen(contents);
	obj->value.string.length = len;
	obj->value.string.base = isc_mem_get(pctx->mctx, len + 1);
	if (obj->value.string.base == 0) {
		isc_mem_put(pctx->mctx, obj, sizeof(*obj));
		return (ISC_R_NOMEMORY);
	}
	memcpy(obj->value.string.base, contents, len);
	obj->value.string.base[len] = '\0';

	*ret = obj;
 cleanup:
	return (result);
}

isc_result_t
cfg_parse_qstring(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
        isc_result_t result;
	UNUSED(type);

	CHECK(cfg_gettoken(pctx, CFG_LEXOPT_QSTRING));
	if (pctx->token.type != isc_tokentype_qstring) {
		cfg_parser_error(pctx, CFG_LOG_NEAR, "expected quoted string");
		return (ISC_R_UNEXPECTEDTOKEN);
	}
	return (create_string(pctx,
			      TOKEN_STRING(pctx),
			      &cfg_type_qstring,
			      ret));
 cleanup:
	return (result);
}

static isc_result_t
parse_ustring(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
        isc_result_t result;
	UNUSED(type);

	CHECK(cfg_gettoken(pctx, 0));
	if (pctx->token.type != isc_tokentype_string) {
		cfg_parser_error(pctx, CFG_LOG_NEAR, "expected unquoted string");
		return (ISC_R_UNEXPECTEDTOKEN);
	}
	return (create_string(pctx,
			      TOKEN_STRING(pctx),
			      &cfg_type_ustring,
			      ret));
 cleanup:
	return (result);
}

isc_result_t
cfg_parse_astring(cfg_parser_t *pctx, const cfg_type_t *type,
		  cfg_obj_t **ret)
{
        isc_result_t result;
	UNUSED(type);

	CHECK(cfg_getstringtoken(pctx));
	return (create_string(pctx,
			      TOKEN_STRING(pctx),
			      &cfg_type_qstring,
			      ret));
 cleanup:
	return (result);
}

isc_boolean_t
cfg_is_enum(const char *s, const char *const *enums) {
	const char * const *p;
	for (p = enums; *p != NULL; p++) {
		if (strcasecmp(*p, s) == 0)
			return (ISC_TRUE);
	}
	return (ISC_FALSE);
}

static isc_result_t
check_enum(cfg_parser_t *pctx, cfg_obj_t *obj, const char *const *enums) {
	const char *s = obj->value.string.base;
	if (cfg_is_enum(s, enums))
		return (ISC_R_SUCCESS);
	cfg_parser_error(pctx, 0, "'%s' unexpected", s);
	return (ISC_R_UNEXPECTEDTOKEN);
}

isc_result_t
cfg_parse_enum(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
        isc_result_t result;
	cfg_obj_t *obj = NULL;
	CHECK(parse_ustring(pctx, NULL, &obj));
	CHECK(check_enum(pctx, obj, type->of));
	*ret = obj;
	return (ISC_R_SUCCESS);
 cleanup:
	CLEANUP_OBJ(obj);	
	return (result);
}

void
cfg_doc_enum(cfg_printer_t *pctx, const cfg_type_t *type) {
	const char * const *p;
	cfg_print_chars(pctx, "( ", 2);
	for (p = type->of; *p != NULL; p++) {
		cfg_print_cstr(pctx, *p);
		if (p[1] != NULL)
			cfg_print_chars(pctx, " | ", 3);
	}
	cfg_print_chars(pctx, " )", 2);
}

void
cfg_print_ustring(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	cfg_print_chars(pctx, obj->value.string.base, obj->value.string.length);
}

static void
print_qstring(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	cfg_print_chars(pctx, "\"", 1);
	cfg_print_ustring(pctx, obj);
	cfg_print_chars(pctx, "\"", 1);
}

static void
free_string(cfg_parser_t *pctx, cfg_obj_t *obj) {
	isc_mem_put(pctx->mctx, obj->value.string.base,
		    obj->value.string.length + 1);
}

isc_boolean_t
cfg_obj_isstring(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL);
	return (ISC_TF(obj->type->rep == &cfg_rep_string));
}

const char *
cfg_obj_asstring(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL && obj->type->rep == &cfg_rep_string);
	return (obj->value.string.base);
}

/* Quoted string only */
cfg_type_t cfg_type_qstring = {
	"quoted_string", cfg_parse_qstring, print_qstring, cfg_doc_terminal,
	&cfg_rep_string, NULL
};

/* Unquoted string only */
cfg_type_t cfg_type_ustring = {
	"string", parse_ustring, cfg_print_ustring, cfg_doc_terminal,
	&cfg_rep_string, NULL
};

/* Any string (quoted or unquoted); printed with quotes */
cfg_type_t cfg_type_astring = {
	"string", cfg_parse_astring, print_qstring, cfg_doc_terminal,
	&cfg_rep_string, NULL
};

/*
 * Booleans
 */

isc_boolean_t
cfg_obj_isboolean(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL);
	return (ISC_TF(obj->type->rep == &cfg_rep_boolean));
}

isc_boolean_t
cfg_obj_asboolean(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL && obj->type->rep == &cfg_rep_boolean);
	return (obj->value.boolean);
}

static isc_result_t
parse_boolean(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret)
{
        isc_result_t result;
	isc_boolean_t value;
	cfg_obj_t *obj = NULL;
	UNUSED(type);

	result = cfg_gettoken(pctx, 0);
	if (result != ISC_R_SUCCESS)
		return (result);

	if (pctx->token.type != isc_tokentype_string)
		goto bad_boolean;

	if ((strcasecmp(TOKEN_STRING(pctx), "true") == 0) ||
	    (strcasecmp(TOKEN_STRING(pctx), "yes") == 0) ||
	    (strcmp(TOKEN_STRING(pctx), "1") == 0)) {
		value = ISC_TRUE;
	} else if ((strcasecmp(TOKEN_STRING(pctx), "false") == 0) ||
		   (strcasecmp(TOKEN_STRING(pctx), "no") == 0) ||
		   (strcmp(TOKEN_STRING(pctx), "0") == 0)) {
		value = ISC_FALSE;
	} else {
		goto bad_boolean;
	}

	CHECK(cfg_create_obj(pctx, &cfg_type_boolean, &obj));
	obj->value.boolean = value;
	*ret = obj;
	return (result);

 bad_boolean:
	cfg_parser_error(pctx, CFG_LOG_NEAR, "boolean expected");
	return (ISC_R_UNEXPECTEDTOKEN);

 cleanup:
	return (result);
}

static void
print_boolean(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	if (obj->value.boolean)
		cfg_print_chars(pctx, "yes", 3);
	else
		cfg_print_chars(pctx, "no", 2);
}

cfg_type_t cfg_type_boolean = {
	"boolean", parse_boolean, print_boolean, cfg_doc_terminal,
	&cfg_rep_boolean, NULL
};

/*
 * Lists.
 */

isc_result_t
cfg_create_list(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **obj) {
	isc_result_t result;
	CHECK(cfg_create_obj(pctx, type, obj));
	ISC_LIST_INIT((*obj)->value.list);
 cleanup:
	return (result);
}

static isc_result_t
create_listelt(cfg_parser_t *pctx, cfg_listelt_t **eltp) {
	cfg_listelt_t *elt;
	elt = isc_mem_get(pctx->mctx, sizeof(*elt));
	if (elt == NULL)
		return (ISC_R_NOMEMORY);
	elt->obj = NULL;
	ISC_LINK_INIT(elt, link);
	*eltp = elt;
	return (ISC_R_SUCCESS);
}

static void
free_list_elt(cfg_parser_t *pctx, cfg_listelt_t *elt) {
	cfg_obj_destroy(pctx, &elt->obj);
	isc_mem_put(pctx->mctx, elt, sizeof(*elt));
}

static void
free_list(cfg_parser_t *pctx, cfg_obj_t *obj) {
	cfg_listelt_t *elt, *next;
	for (elt = ISC_LIST_HEAD(obj->value.list);
	     elt != NULL;
	     elt = next)
	{
		next = ISC_LIST_NEXT(elt, link);
		free_list_elt(pctx, elt);
	}
}

isc_result_t
cfg_parse_listelt(cfg_parser_t *pctx, const cfg_type_t *elttype,
		  cfg_listelt_t **ret)
{
	isc_result_t result;
	cfg_listelt_t *elt = NULL;
	cfg_obj_t *value = NULL;

	CHECK(create_listelt(pctx, &elt));

	result = cfg_parse_obj(pctx, elttype, &value);
	if (result != ISC_R_SUCCESS)
		goto cleanup;

	elt->obj = value;

	*ret = elt;
	return (ISC_R_SUCCESS);

 cleanup:
	isc_mem_put(pctx->mctx, elt, sizeof(*elt));
	return (result);
}

/*
 * Parse a homogeneous list whose elements are of type 'elttype'
 * and where each element is terminated by a semicolon.
 */
static isc_result_t
parse_list(cfg_parser_t *pctx, const cfg_type_t *listtype, cfg_obj_t **ret)
{
	cfg_obj_t *listobj = NULL;
	const cfg_type_t *listof = listtype->of;
	isc_result_t result;
	cfg_listelt_t *elt = NULL;

	CHECK(cfg_create_list(pctx, listtype, &listobj));

	for (;;) {
		CHECK(cfg_peektoken(pctx, 0));
		if (pctx->token.type == isc_tokentype_special &&
		    pctx->token.value.as_char == /*{*/ '}')
			break;
		CHECK(cfg_parse_listelt(pctx, listof, &elt));
		CHECK(parse_semicolon(pctx));
		ISC_LIST_APPEND(listobj->value.list, elt, link);
		elt = NULL;
	}
	*ret = listobj;
	return (ISC_R_SUCCESS);

 cleanup:
	if (elt != NULL)
		free_list_elt(pctx, elt);
	CLEANUP_OBJ(listobj);
	return (result);
}

static void
print_list(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	const cfg_list_t *list = &obj->value.list;
	const cfg_listelt_t *elt;

	for (elt = ISC_LIST_HEAD(*list);
	     elt != NULL;
	     elt = ISC_LIST_NEXT(elt, link)) {
		print_indent(pctx);
		cfg_print_obj(pctx, elt->obj);
		cfg_print_chars(pctx, ";\n", 2);
	}
}

isc_result_t
cfg_parse_bracketed_list(cfg_parser_t *pctx, const cfg_type_t *type,
		     cfg_obj_t **ret)
{
	isc_result_t result;
	CHECK(cfg_parse_special(pctx, '{'));
	CHECK(parse_list(pctx, type, ret));
	CHECK(cfg_parse_special(pctx, '}'));
 cleanup:
	return (result);
}

void
cfg_print_bracketed_list(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	print_open(pctx);
	print_list(pctx, obj);
	print_close(pctx);
}

void
cfg_doc_bracketed_list(cfg_printer_t *pctx, const cfg_type_t *type) {
	cfg_print_chars(pctx, "{ ", 2);
	cfg_doc_obj(pctx, type->of);
	cfg_print_chars(pctx, "; ... }", 7);
}

/*
 * Parse a homogeneous list whose elements are of type 'elttype'
 * and where elements are separated by space.  The list ends
 * before the first semicolon.
 */
isc_result_t
cfg_parse_spacelist(cfg_parser_t *pctx, const cfg_type_t *listtype,
		    cfg_obj_t **ret)
{
	cfg_obj_t *listobj = NULL;
	const cfg_type_t *listof = listtype->of;
	isc_result_t result;

	CHECK(cfg_create_list(pctx, listtype, &listobj));

	for (;;) {
		cfg_listelt_t *elt = NULL;

		CHECK(cfg_peektoken(pctx, 0));
		if (pctx->token.type == isc_tokentype_special &&
		    pctx->token.value.as_char == ';')
			break;
		CHECK(cfg_parse_listelt(pctx, listof, &elt));
		ISC_LIST_APPEND(listobj->value.list, elt, link);
	}
	*ret = listobj;
	return (ISC_R_SUCCESS);

 cleanup:
	CLEANUP_OBJ(listobj);
	return (result);
}

void
cfg_print_spacelist(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	const cfg_list_t *list = &obj->value.list;
	const cfg_listelt_t *elt;

	for (elt = ISC_LIST_HEAD(*list);
	     elt != NULL;
	     elt = ISC_LIST_NEXT(elt, link)) {
		cfg_print_obj(pctx, elt->obj);
		if (ISC_LIST_NEXT(elt, link) != NULL)
			cfg_print_chars(pctx, " ", 1);
	}
}

isc_boolean_t
cfg_obj_islist(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL);
	return (ISC_TF(obj->type->rep == &cfg_rep_list));
}

const cfg_listelt_t *
cfg_list_first(const cfg_obj_t *obj) {
	REQUIRE(obj == NULL || obj->type->rep == &cfg_rep_list);
	if (obj == NULL)
		return (NULL);
	return (ISC_LIST_HEAD(obj->value.list));
}

const cfg_listelt_t *
cfg_list_next(const cfg_listelt_t *elt) {
	REQUIRE(elt != NULL);
	return (ISC_LIST_NEXT(elt, link));
}

const cfg_obj_t *
cfg_listelt_value(const cfg_listelt_t *elt) {
	REQUIRE(elt != NULL);
	return (elt->obj);
}

/*
 * Maps.
 */

/*
 * Parse a map body.  That's something like
 *
 *   "foo 1; bar { glub; }; zap true; zap false;"
 *
 * i.e., a sequence of option names followed by values and
 * terminated by semicolons.  Used for the top level of
 * the named.conf syntax, as well as for the body of the
 * options, view, zone, and other statements.
 */
isc_result_t
cfg_parse_mapbody(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret)
{
	const cfg_clausedef_t * const *clausesets = type->of;
	isc_result_t result;
	const cfg_clausedef_t * const *clauseset;
	const cfg_clausedef_t *clause;
	cfg_obj_t *value = NULL;
	cfg_obj_t *obj = NULL;
	cfg_obj_t *eltobj = NULL;
	cfg_obj_t *includename = NULL;
	isc_symvalue_t symval;
	cfg_list_t *list = NULL;

	CHECK(create_map(pctx, type, &obj));

	obj->value.map.clausesets = clausesets;

	for (;;) {
		cfg_listelt_t *elt;

	redo:
		/*
		 * Parse the option name and see if it is known.
		 */
		CHECK(cfg_gettoken(pctx, 0));

		if (pctx->token.type != isc_tokentype_string) {
			cfg_ungettoken(pctx);
			break;
		}

		/*
		 * We accept "include" statements wherever a map body
		 * clause can occur.
		 */
		if (strcasecmp(TOKEN_STRING(pctx), "include") == 0) {
			/*
			 * Turn the file name into a temporary configuration
			 * object just so that it is not overwritten by the
			 * semicolon token.
			 */
			CHECK(cfg_parse_obj(pctx, &cfg_type_qstring, &includename));
			CHECK(parse_semicolon(pctx));
			CHECK(parser_openfile(pctx, includename->
					      value.string.base));
			 cfg_obj_destroy(pctx, &includename);
			 goto redo;
		}

		clause = NULL;
		for (clauseset = clausesets; *clauseset != NULL; clauseset++) {
			for (clause = *clauseset;
			     clause->name != NULL;
			     clause++) {
				if (strcasecmp(TOKEN_STRING(pctx),
					   clause->name) == 0)
					goto done;
			}
		}
	done:
		if (clause == NULL || clause->name == NULL) {
			cfg_parser_error(pctx, CFG_LOG_NOPREP, "unknown option");
			/*
			 * Try to recover by parsing this option as an unknown
			 * option and discarding it.
			 */
			CHECK(cfg_parse_obj(pctx, &cfg_type_unsupported, &eltobj));
			cfg_obj_destroy(pctx, &eltobj);
			CHECK(parse_semicolon(pctx));
			continue;
		}

		/* Clause is known. */

		/* Issue warnings if appropriate */
		if ((clause->flags & CFG_CLAUSEFLAG_OBSOLETE) != 0)
			cfg_parser_warning(pctx, 0, "option '%s' is obsolete",
				       clause->name);
		if ((clause->flags & CFG_CLAUSEFLAG_NOTIMP) != 0)
			cfg_parser_warning(pctx, 0, "option '%s' is "
				       "not implemented", clause->name);
		if ((clause->flags & CFG_CLAUSEFLAG_NYI) != 0)
			cfg_parser_warning(pctx, 0, "option '%s' is "
				       "not implemented", clause->name);
		/*
		 * Don't log options with CFG_CLAUSEFLAG_NEWDEFAULT
		 * set here - we need to log the *lack* of such an option,
		 * not its presence.
		 */

		/* See if the clause already has a value; if not create one. */
		result = isc_symtab_lookup(obj->value.map.symtab,
					   clause->name, 0, &symval);

		if ((clause->flags & CFG_CLAUSEFLAG_MULTI) != 0) {
			/* Multivalued clause */
			cfg_obj_t *listobj = NULL;
			if (result == ISC_R_NOTFOUND) {
				CHECK(cfg_create_list(pctx,
						  &cfg_type_implicitlist,
						  &listobj));
				symval.as_pointer = listobj;
				result = isc_symtab_define(obj->value.
						   map.symtab,
						   clause->name,
						   1, symval,
						   isc_symexists_reject);
				if (result != ISC_R_SUCCESS) {
					cfg_parser_error(pctx, CFG_LOG_NEAR,
						     "isc_symtab_define(%s) "
						     "failed", clause->name);
					isc_mem_put(pctx->mctx, list,
						    sizeof(cfg_list_t));
					goto cleanup;
				}
			} else {
				INSIST(result == ISC_R_SUCCESS);
				listobj = symval.as_pointer;
			}

			elt = NULL;
			CHECK(cfg_parse_listelt(pctx, clause->type, &elt));
			CHECK(parse_semicolon(pctx));

			ISC_LIST_APPEND(listobj->value.list, elt, link);
		} else {
			/* Single-valued clause */
			if (result == ISC_R_NOTFOUND) {
				isc_boolean_t callback =
					ISC_TF((clause->flags &
						CFG_CLAUSEFLAG_CALLBACK) != 0);
				CHECK(parse_symtab_elt(pctx, clause->name,
						       clause->type,
						       obj->value.map.symtab,
						       callback));
				CHECK(parse_semicolon(pctx));
			} else if (result == ISC_R_SUCCESS) {
				cfg_parser_error(pctx, CFG_LOG_NEAR, "'%s' redefined",
					     clause->name);
				result = ISC_R_EXISTS;
				goto cleanup;
			} else {
				cfg_parser_error(pctx, CFG_LOG_NEAR,
					     "isc_symtab_define() failed");
				goto cleanup;
			}
		}
	}


	*ret = obj;
	return (ISC_R_SUCCESS);

 cleanup:
	CLEANUP_OBJ(value);
	CLEANUP_OBJ(obj);
	CLEANUP_OBJ(eltobj);
	CLEANUP_OBJ(includename);
	return (result);
}

static isc_result_t
parse_symtab_elt(cfg_parser_t *pctx, const char *name,
		 cfg_type_t *elttype, isc_symtab_t *symtab,
		 isc_boolean_t callback)
{
	isc_result_t result;
	cfg_obj_t *obj = NULL;
	isc_symvalue_t symval;

	CHECK(cfg_parse_obj(pctx, elttype, &obj));

	if (callback && pctx->callback != NULL)
		CHECK(pctx->callback(name, obj, pctx->callbackarg));
	
	symval.as_pointer = obj;
	CHECK(isc_symtab_define(symtab, name,
				1, symval,
				isc_symexists_reject));
	return (ISC_R_SUCCESS);

 cleanup:
	CLEANUP_OBJ(obj);
	return (result);
}

/*
 * Parse a map; e.g., "{ foo 1; bar { glub; }; zap true; zap false; }"
 */
isc_result_t
cfg_parse_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	isc_result_t result;
	CHECK(cfg_parse_special(pctx, '{'));
	CHECK(cfg_parse_mapbody(pctx, type, ret));
	CHECK(cfg_parse_special(pctx, '}'));
 cleanup:
	return (result);
}

/*
 * Subroutine for cfg_parse_named_map() and cfg_parse_addressed_map().
 */
static isc_result_t
parse_any_named_map(cfg_parser_t *pctx, cfg_type_t *nametype, const cfg_type_t *type,
		    cfg_obj_t **ret)
{
	isc_result_t result;
	cfg_obj_t *idobj = NULL;
	cfg_obj_t *mapobj = NULL;

	CHECK(cfg_parse_obj(pctx, nametype, &idobj));
	CHECK(cfg_parse_map(pctx, type, &mapobj));
	mapobj->value.map.id = idobj;
	idobj = NULL;
	*ret = mapobj;
 cleanup:
	CLEANUP_OBJ(idobj);
	return (result);
}

/*
 * Parse a map identified by a string name.  E.g., "name { foo 1; }".  
 * Used for the "key" and "channel" statements.
 */
isc_result_t
cfg_parse_named_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	return (parse_any_named_map(pctx, &cfg_type_astring, type, ret));
}

/*
 * Parse a map identified by a network address.
 * Used to be used for the "server" statement.
 */
isc_result_t
cfg_parse_addressed_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	return (parse_any_named_map(pctx, &cfg_type_netaddr, type, ret));
}

/*
 * Parse a map identified by a network prefix.
 * Used for the "server" statement.
 */
isc_result_t
cfg_parse_netprefix_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	return (parse_any_named_map(pctx, &cfg_type_netprefix, type, ret));
}

void
cfg_print_mapbody(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	isc_result_t result = ISC_R_SUCCESS;

	const cfg_clausedef_t * const *clauseset;

	for (clauseset = obj->value.map.clausesets;
	     *clauseset != NULL;
	     clauseset++)
	{
		isc_symvalue_t symval;
		const cfg_clausedef_t *clause;

		for (clause = *clauseset;
		     clause->name != NULL;
		     clause++) {
			result = isc_symtab_lookup(obj->value.map.symtab,
						   clause->name, 0, &symval);
			if (result == ISC_R_SUCCESS) {
				cfg_obj_t *obj = symval.as_pointer;
				if (obj->type == &cfg_type_implicitlist) {
					/* Multivalued. */
					cfg_list_t *list = &obj->value.list;
					cfg_listelt_t *elt;
					for (elt = ISC_LIST_HEAD(*list);
					     elt != NULL;
					     elt = ISC_LIST_NEXT(elt, link)) {
						print_indent(pctx);
						cfg_print_cstr(pctx, clause->name);
						cfg_print_chars(pctx, " ", 1);
						cfg_print_obj(pctx, elt->obj);
						cfg_print_chars(pctx, ";\n", 2);
					}
				} else {
					/* Single-valued. */
					print_indent(pctx);
					cfg_print_cstr(pctx, clause->name);
					cfg_print_chars(pctx, " ", 1);
					cfg_print_obj(pctx, obj);
					cfg_print_chars(pctx, ";\n", 2);
				}
			} else if (result == ISC_R_NOTFOUND) {
				; /* do nothing */
			} else {
				INSIST(0);
			}
		}
	}
}

void
cfg_doc_mapbody(cfg_printer_t *pctx, const cfg_type_t *type) {
	const cfg_clausedef_t * const *clauseset;
	const cfg_clausedef_t *clause;
	
	for (clauseset = type->of; *clauseset != NULL; clauseset++) {
		for (clause = *clauseset;
		     clause->name != NULL;
		     clause++) {
			cfg_print_cstr(pctx, clause->name);
			cfg_print_chars(pctx, " ", 1);
			cfg_doc_obj(pctx, clause->type);
			cfg_print_chars(pctx, ";", 1);
			/* XXX print flags here? */
			cfg_print_chars(pctx, "\n\n", 2);
		}
	}
}

static struct flagtext {
	unsigned int flag;
	const char *text;
} flagtexts[] = {
	{ CFG_CLAUSEFLAG_NOTIMP, "not implemented" },
	{ CFG_CLAUSEFLAG_NYI, "not yet implemented" },
	{ CFG_CLAUSEFLAG_OBSOLETE, "obsolete" },
	{ CFG_CLAUSEFLAG_NEWDEFAULT, "default changed" },
	{ 0, NULL }
};

void
cfg_print_map(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	if (obj->value.map.id != NULL) {
		cfg_print_obj(pctx, obj->value.map.id);
		cfg_print_chars(pctx, " ", 1);
	}
	print_open(pctx);
	cfg_print_mapbody(pctx, obj);
	print_close(pctx);
}

static void
print_clause_flags(cfg_printer_t *pctx, unsigned int flags) {
	struct flagtext *p;
	isc_boolean_t first = ISC_TRUE;
	for (p = flagtexts; p->flag != 0; p++) {
		if ((flags & p->flag) != 0) {
			if (first)
				cfg_print_chars(pctx, " // ", 4);
			else
				cfg_print_chars(pctx, ", ", 2);
			cfg_print_cstr(pctx, p->text);
			first = ISC_FALSE;
		}
	}
}

void
cfg_doc_map(cfg_printer_t *pctx, const cfg_type_t *type) {
	const cfg_clausedef_t * const *clauseset;
	const cfg_clausedef_t *clause;
	
	if (type->parse == cfg_parse_named_map) {
		cfg_doc_obj(pctx, &cfg_type_astring);
		cfg_print_chars(pctx, " ", 1);
	} else if (type->parse == cfg_parse_addressed_map) {
		cfg_doc_obj(pctx, &cfg_type_netaddr);
		cfg_print_chars(pctx, " ", 1);
	} else if (type->parse == cfg_parse_netprefix_map) {
		cfg_doc_obj(pctx, &cfg_type_netprefix);
		cfg_print_chars(pctx, " ", 1);
	}
	
	print_open(pctx);
	
	for (clauseset = type->of; *clauseset != NULL; clauseset++) {
		for (clause = *clauseset;
		     clause->name != NULL;
		     clause++) {
			print_indent(pctx);
			cfg_print_cstr(pctx, clause->name);
			if (clause->type->print != cfg_print_void)
				cfg_print_chars(pctx, " ", 1);
			cfg_doc_obj(pctx, clause->type);
			cfg_print_chars(pctx, ";", 1);
			print_clause_flags(pctx, clause->flags);
			cfg_print_chars(pctx, "\n", 1);
		}
	}
	print_close(pctx);
}

isc_boolean_t
cfg_obj_ismap(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL);
	return (ISC_TF(obj->type->rep == &cfg_rep_map));
}

isc_result_t
cfg_map_get(const cfg_obj_t *mapobj, const char* name, const cfg_obj_t **obj) {
	isc_result_t result;
	isc_symvalue_t val;
	const cfg_map_t *map;
	
	REQUIRE(mapobj != NULL && mapobj->type->rep == &cfg_rep_map);
	REQUIRE(name != NULL);
	REQUIRE(obj != NULL && *obj == NULL);

	map = &mapobj->value.map;
	
	result = isc_symtab_lookup(map->symtab, name, MAP_SYM, &val);
	if (result != ISC_R_SUCCESS)
		return (result);
	*obj = val.as_pointer;
	return (ISC_R_SUCCESS);
}

const cfg_obj_t *
cfg_map_getname(const cfg_obj_t *mapobj) {
	REQUIRE(mapobj != NULL && mapobj->type->rep == &cfg_rep_map);
	return (mapobj->value.map.id);
}


/* Parse an arbitrary token, storing its raw text representation. */
static isc_result_t
parse_token(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	cfg_obj_t *obj = NULL;
        isc_result_t result;
	isc_region_t r;

	UNUSED(type);

	CHECK(cfg_create_obj(pctx, &cfg_type_token, &obj));
	CHECK(cfg_gettoken(pctx, CFG_LEXOPT_QSTRING));
	if (pctx->token.type == isc_tokentype_eof) {
		cfg_ungettoken(pctx);
		result = ISC_R_EOF;
		goto cleanup;
	}

	isc_lex_getlasttokentext(pctx->lexer, &pctx->token, &r);

	obj->value.string.base = isc_mem_get(pctx->mctx, r.length + 1);
	if (obj->value.string.base == NULL) {
		result = ISC_R_NOMEMORY;
		goto cleanup;
	}
	obj->value.string.length = r.length;
	memcpy(obj->value.string.base, r.base, r.length);
	obj->value.string.base[r.length] = '\0';
	*ret = obj;
	return (result);

 cleanup:
	if (obj != NULL)
		isc_mem_put(pctx->mctx, obj, sizeof(*obj));
	return (result);
}

cfg_type_t cfg_type_token = {
	"token", parse_token, cfg_print_ustring, cfg_doc_terminal,
	&cfg_rep_string, NULL
};

/*
 * An unsupported option.  This is just a list of tokens with balanced braces
 * ending in a semicolon.
 */

static isc_result_t
parse_unsupported(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	cfg_obj_t *listobj = NULL;
	isc_result_t result;
	int braces = 0;

	CHECK(cfg_create_list(pctx, type, &listobj));

	for (;;) {
		cfg_listelt_t *elt = NULL;

		CHECK(cfg_peektoken(pctx, 0));
		if (pctx->token.type == isc_tokentype_special) {
			if (pctx->token.value.as_char == '{')
				braces++;
			else if (pctx->token.value.as_char == '}')
				braces--;
			else if (pctx->token.value.as_char == ';')
				if (braces == 0)
					break;
		}
		if (pctx->token.type == isc_tokentype_eof || braces < 0) {
			cfg_parser_error(pctx, CFG_LOG_NEAR, "unexpected token");
			result = ISC_R_UNEXPECTEDTOKEN;
			goto cleanup;
		}

		CHECK(cfg_parse_listelt(pctx, &cfg_type_token, &elt));
		ISC_LIST_APPEND(listobj->value.list, elt, link);
	}
	INSIST(braces == 0);
	*ret = listobj;
	return (ISC_R_SUCCESS);

 cleanup:
	CLEANUP_OBJ(listobj);
	return (result);
}

cfg_type_t cfg_type_unsupported = {
	"unsupported", parse_unsupported, cfg_print_spacelist, cfg_doc_terminal,
	&cfg_rep_list, NULL
};

/*
 * Try interpreting the current token as a network address.
 *
 * If CFG_ADDR_WILDOK is set in flags, "*" can be used as a wildcard
 * and at least one of CFG_ADDR_V4OK and CFG_ADDR_V6OK must also be set.  The
 * "*" is interpreted as the IPv4 wildcard address if CFG_ADDR_V4OK is 
 * set (including the case where CFG_ADDR_V4OK and CFG_ADDR_V6OK are both set),
 * and the IPv6 wildcard address otherwise.
 */
static isc_result_t
token_addr(cfg_parser_t *pctx, unsigned int flags, isc_netaddr_t *na) {
	char *s;
	struct in_addr in4a;
	struct in6_addr in6a;

	if (pctx->token.type != isc_tokentype_string)
		return (ISC_R_UNEXPECTEDTOKEN);

	s = TOKEN_STRING(pctx);
	if ((flags & CFG_ADDR_WILDOK) != 0 && strcmp(s, "*") == 0) {
		if ((flags & CFG_ADDR_V4OK) != 0) {
			isc_netaddr_any(na);
			return (ISC_R_SUCCESS);
		} else if ((flags & CFG_ADDR_V6OK) != 0) {
			isc_netaddr_any6(na);
			return (ISC_R_SUCCESS);
		} else {
			INSIST(0);
		}
	} else {
		if ((flags & (CFG_ADDR_V4OK | CFG_ADDR_V4PREFIXOK)) != 0) {
			if (inet_pton(AF_INET, s, &in4a) == 1) {
				isc_netaddr_fromin(na, &in4a);
				return (ISC_R_SUCCESS);
			}
		}
		if ((flags & CFG_ADDR_V4PREFIXOK) != 0 &&
		    strlen(s) <= 15U) {
			char buf[64];
			int i;

			strlcpy(buf, s, sizeof(buf));
			for (i = 0; i < 3; i++) {
				strlcat(buf, ".0", sizeof(buf));
				if (inet_pton(AF_INET, buf, &in4a) == 1) {
					isc_netaddr_fromin(na, &in4a);
					return (ISC_R_SUCCESS);
				}
			}
		}
		if ((flags & CFG_ADDR_V6OK) != 0 &&
		    strlen(s) <= 127U) {
			char buf[128]; /* see lib/bind9/getaddresses.c */
			char *d; /* zone delimiter */
			isc_uint32_t zone = 0; /* scope zone ID */

			strlcpy(buf, s, sizeof(buf));
			d = strchr(buf, '%');
			if (d != NULL)
				*d = '\0';

			if (inet_pton(AF_INET6, buf, &in6a) == 1) {
				if (d != NULL) {
#ifdef ISC_PLATFORM_HAVESCOPEID
					isc_result_t result;

					result = isc_netscope_pton(AF_INET6,
								   d + 1,
								   &in6a,
								   &zone);
					if (result != ISC_R_SUCCESS)
						return (result);
#else
				return (ISC_R_BADADDRESSFORM);
#endif
				}

				isc_netaddr_fromin6(na, &in6a);
				isc_netaddr_setzone(na, zone);
				return (ISC_R_SUCCESS);
			}
		}
	}
	return (ISC_R_UNEXPECTEDTOKEN);
}

isc_result_t
cfg_parse_rawaddr(cfg_parser_t *pctx, unsigned int flags, isc_netaddr_t *na) {
	isc_result_t result;
	const char *wild = "";
	const char *prefix = "";

	CHECK(cfg_gettoken(pctx, 0));
	result = token_addr(pctx, flags, na);
	if (result == ISC_R_UNEXPECTEDTOKEN) {
		if ((flags & CFG_ADDR_WILDOK) != 0)
			wild = " or '*'";
		if ((flags & CFG_ADDR_V4PREFIXOK) != 0)
			wild = " or IPv4 prefix";
		if ((flags & CFG_ADDR_MASK) == CFG_ADDR_V4OK)
			cfg_parser_error(pctx, CFG_LOG_NEAR,
					 "expected IPv4 address%s%s",
					 prefix, wild);
		else if ((flags & CFG_ADDR_MASK) == CFG_ADDR_V6OK)
			cfg_parser_error(pctx, CFG_LOG_NEAR,
					 "expected IPv6 address%s%s",
					 prefix, wild);
		else
			cfg_parser_error(pctx, CFG_LOG_NEAR,
					 "expected IP address%s%s",
					 prefix, wild);
	}
 cleanup:
	return (result);
}

isc_boolean_t
cfg_lookingat_netaddr(cfg_parser_t *pctx, unsigned int flags) {
	isc_result_t result;
	isc_netaddr_t na_dummy;
	result = token_addr(pctx, flags, &na_dummy);
	return (ISC_TF(result == ISC_R_SUCCESS));
}

isc_result_t
cfg_parse_rawport(cfg_parser_t *pctx, unsigned int flags, in_port_t *port) {
	isc_result_t result;

	CHECK(cfg_gettoken(pctx, ISC_LEXOPT_NUMBER));

	if ((flags & CFG_ADDR_WILDOK) != 0 &&
	    pctx->token.type == isc_tokentype_string &&
	    strcmp(TOKEN_STRING(pctx), "*") == 0) {
		*port = 0;
		return (ISC_R_SUCCESS);
	}
	if (pctx->token.type != isc_tokentype_number) {
		cfg_parser_error(pctx, CFG_LOG_NEAR,
			     "expected port number or '*'");
		return (ISC_R_UNEXPECTEDTOKEN);
	}
	if (pctx->token.value.as_ulong >= 65536U) {
		cfg_parser_error(pctx, CFG_LOG_NEAR,
			     "port number out of range");
		return (ISC_R_UNEXPECTEDTOKEN);
	}
	*port = (in_port_t)(pctx->token.value.as_ulong);
	return (ISC_R_SUCCESS);
 cleanup:
	return (result);
}

void
cfg_print_rawaddr(cfg_printer_t *pctx, const isc_netaddr_t *na) {
	isc_result_t result;
	char text[128];
	isc_buffer_t buf;

	isc_buffer_init(&buf, text, sizeof(text));
	result = isc_netaddr_totext(na, &buf);
	RUNTIME_CHECK(result == ISC_R_SUCCESS);
	cfg_print_chars(pctx, isc_buffer_base(&buf), isc_buffer_usedlength(&buf));
}

/* netaddr */

static unsigned int netaddr_flags = CFG_ADDR_V4OK | CFG_ADDR_V6OK;
static unsigned int netaddr4_flags = CFG_ADDR_V4OK;
static unsigned int netaddr4wild_flags = CFG_ADDR_V4OK | CFG_ADDR_WILDOK;
static unsigned int netaddr6_flags = CFG_ADDR_V6OK;
static unsigned int netaddr6wild_flags = CFG_ADDR_V6OK | CFG_ADDR_WILDOK;

static isc_result_t
parse_netaddr(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	isc_result_t result;
	cfg_obj_t *obj = NULL;
	isc_netaddr_t netaddr;
	unsigned int flags = *(const unsigned int *)type->of;

	CHECK(cfg_create_obj(pctx, type, &obj));
	CHECK(cfg_parse_rawaddr(pctx, flags, &netaddr));
	isc_sockaddr_fromnetaddr(&obj->value.sockaddr, &netaddr, 0);
	*ret = obj;
	return (ISC_R_SUCCESS);
 cleanup:
	CLEANUP_OBJ(obj);
	return (result);
}

static void
cfg_doc_netaddr(cfg_printer_t *pctx, const cfg_type_t *type) {
	const unsigned int *flagp = type->of;
	int n = 0;
	if (*flagp != CFG_ADDR_V4OK && *flagp != CFG_ADDR_V6OK)
		cfg_print_chars(pctx, "( ", 2);
	if (*flagp & CFG_ADDR_V4OK) {
		cfg_print_cstr(pctx, "<ipv4_address>");
		n++;
	}
	if (*flagp & CFG_ADDR_V6OK) {
		if (n != 0)
			cfg_print_chars(pctx, " | ", 3);
		cfg_print_cstr(pctx, "<ipv6_address>");
		n++;			
	}
	if (*flagp & CFG_ADDR_WILDOK) {
		if (n != 0)
			cfg_print_chars(pctx, " | ", 3);
		cfg_print_chars(pctx, "*", 1);
		n++;
	}
	if (*flagp != CFG_ADDR_V4OK && *flagp != CFG_ADDR_V6OK)
		cfg_print_chars(pctx, " )", 2);
}

cfg_type_t cfg_type_netaddr = {
	"netaddr", parse_netaddr, cfg_print_sockaddr, cfg_doc_netaddr,
	&cfg_rep_sockaddr, &netaddr_flags
};

cfg_type_t cfg_type_netaddr4 = {
	"netaddr4", parse_netaddr, cfg_print_sockaddr, cfg_doc_netaddr,
	&cfg_rep_sockaddr, &netaddr4_flags
};

cfg_type_t cfg_type_netaddr4wild = {
	"netaddr4wild", parse_netaddr, cfg_print_sockaddr, cfg_doc_netaddr,
	&cfg_rep_sockaddr, &netaddr4wild_flags
};

cfg_type_t cfg_type_netaddr6 = {
	"netaddr6", parse_netaddr, cfg_print_sockaddr, cfg_doc_netaddr,
	&cfg_rep_sockaddr, &netaddr6_flags
};

cfg_type_t cfg_type_netaddr6wild = {
	"netaddr6wild", parse_netaddr, cfg_print_sockaddr, cfg_doc_netaddr,
	&cfg_rep_sockaddr, &netaddr6wild_flags
};

/* netprefix */

isc_result_t
cfg_parse_netprefix(cfg_parser_t *pctx, const cfg_type_t *type,
		    cfg_obj_t **ret)
{
	cfg_obj_t *obj = NULL;
	isc_result_t result;
	isc_netaddr_t netaddr;
	unsigned int addrlen, prefixlen;
	UNUSED(type);

	CHECK(cfg_parse_rawaddr(pctx, CFG_ADDR_V4OK | CFG_ADDR_V4PREFIXOK |
				CFG_ADDR_V6OK, &netaddr));
	switch (netaddr.family) {
	case AF_INET:
		addrlen = 32;
		break;
	case AF_INET6:
		addrlen = 128;
		break;
	default:
		addrlen = 0;
		INSIST(0);
		break;
	}
	CHECK(cfg_peektoken(pctx, 0));
	if (pctx->token.type == isc_tokentype_special &&
	    pctx->token.value.as_char == '/') {
		CHECK(cfg_gettoken(pctx, 0)); /* read "/" */
		CHECK(cfg_gettoken(pctx, ISC_LEXOPT_NUMBER));
		if (pctx->token.type != isc_tokentype_number) {
			cfg_parser_error(pctx, CFG_LOG_NEAR,
				     "expected prefix length");
			return (ISC_R_UNEXPECTEDTOKEN);
		}
		prefixlen = pctx->token.value.as_ulong;
		if (prefixlen > addrlen) {
			cfg_parser_error(pctx, CFG_LOG_NOPREP,
				     "invalid prefix length");
			return (ISC_R_RANGE);
		}
	} else {
		prefixlen = addrlen;
	}
	CHECK(cfg_create_obj(pctx, &cfg_type_netprefix, &obj));
	obj->value.netprefix.address = netaddr;
	obj->value.netprefix.prefixlen = prefixlen;
	*ret = obj;
	return (ISC_R_SUCCESS);
 cleanup:
	cfg_parser_error(pctx, CFG_LOG_NEAR, "expected network prefix");
	return (result);
}

static void
print_netprefix(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	const cfg_netprefix_t *p = &obj->value.netprefix;

	cfg_print_rawaddr(pctx, &p->address);
	cfg_print_chars(pctx, "/", 1);
	cfg_print_rawuint(pctx, p->prefixlen);
}

isc_boolean_t
cfg_obj_isnetprefix(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL);
	return (ISC_TF(obj->type->rep == &cfg_rep_netprefix));
}

void
cfg_obj_asnetprefix(const cfg_obj_t *obj, isc_netaddr_t *netaddr,
		    unsigned int *prefixlen) {
	REQUIRE(obj != NULL && obj->type->rep == &cfg_rep_netprefix);
	*netaddr = obj->value.netprefix.address;
	*prefixlen = obj->value.netprefix.prefixlen;
}

cfg_type_t cfg_type_netprefix = {
	"netprefix", cfg_parse_netprefix, print_netprefix, cfg_doc_terminal,
	&cfg_rep_netprefix, NULL
};

static isc_result_t
parse_sockaddrsub(cfg_parser_t *pctx, const cfg_type_t *type,
		  int flags, cfg_obj_t **ret)
{
	isc_result_t result;
	isc_netaddr_t netaddr;
	in_port_t port = 0;
	cfg_obj_t *obj = NULL;

	CHECK(cfg_create_obj(pctx, type, &obj));
	CHECK(cfg_parse_rawaddr(pctx, flags, &netaddr));
	CHECK(cfg_peektoken(pctx, 0));
	if (pctx->token.type == isc_tokentype_string &&
	    strcasecmp(TOKEN_STRING(pctx), "port") == 0) {
		CHECK(cfg_gettoken(pctx, 0)); /* read "port" */
		CHECK(cfg_parse_rawport(pctx, flags, &port));
	}
	isc_sockaddr_fromnetaddr(&obj->value.sockaddr, &netaddr, port);
	*ret = obj;
	return (ISC_R_SUCCESS);

 cleanup:
	CLEANUP_OBJ(obj);
	return (result);
}

static unsigned int sockaddr_flags = CFG_ADDR_V4OK | CFG_ADDR_V6OK;
cfg_type_t cfg_type_sockaddr = {
	"sockaddr", cfg_parse_sockaddr, cfg_print_sockaddr, cfg_doc_sockaddr,
	&cfg_rep_sockaddr, &sockaddr_flags
};

isc_result_t
cfg_parse_sockaddr(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	const unsigned int *flagp = type->of;
	return (parse_sockaddrsub(pctx, &cfg_type_sockaddr, *flagp, ret));
}

void
cfg_print_sockaddr(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	isc_netaddr_t netaddr;
	in_port_t port;
	char buf[ISC_NETADDR_FORMATSIZE];

	isc_netaddr_fromsockaddr(&netaddr, &obj->value.sockaddr);
	isc_netaddr_format(&netaddr, buf, sizeof(buf));
	cfg_print_cstr(pctx, buf);
	port = isc_sockaddr_getport(&obj->value.sockaddr);
	if (port != 0) {
		cfg_print_chars(pctx, " port ", 6);
		cfg_print_rawuint(pctx, port);
	}
}

void
cfg_doc_sockaddr(cfg_printer_t *pctx, const cfg_type_t *type) {
	const unsigned int *flagp = type->of;
	int n = 0;
	cfg_print_chars(pctx, "( ", 2);
	if (*flagp & CFG_ADDR_V4OK) {
		cfg_print_cstr(pctx, "<ipv4_address>");
		n++;
	}
	if (*flagp & CFG_ADDR_V6OK) {
		if (n != 0)
			cfg_print_chars(pctx, " | ", 3);
		cfg_print_cstr(pctx, "<ipv6_address>");
		n++;			
	}
	if (*flagp & CFG_ADDR_WILDOK) {
		if (n != 0)
			cfg_print_chars(pctx, " | ", 3);
		cfg_print_chars(pctx, "*", 1);
		n++;
	}
	cfg_print_chars(pctx, " ) ", 3);
	if (*flagp & CFG_ADDR_WILDOK) {
		cfg_print_cstr(pctx, "[ port ( <integer> | * ) ]");
	} else {
		cfg_print_cstr(pctx, "[ port <integer> ]");
	}
}

isc_boolean_t
cfg_obj_issockaddr(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL);
	return (ISC_TF(obj->type->rep == &cfg_rep_sockaddr));
}

const isc_sockaddr_t *
cfg_obj_assockaddr(const cfg_obj_t *obj) {
	REQUIRE(obj != NULL && obj->type->rep == &cfg_rep_sockaddr);
	return (&obj->value.sockaddr);
}

isc_result_t
cfg_gettoken(cfg_parser_t *pctx, int options) {
	isc_result_t result;

	if (pctx->seen_eof)
		return (ISC_R_SUCCESS);

	options |= (ISC_LEXOPT_EOF | ISC_LEXOPT_NOMORE);

 redo:
	pctx->token.type = isc_tokentype_unknown;
	result = isc_lex_gettoken(pctx->lexer, options, &pctx->token);
	pctx->ungotten = ISC_FALSE;
	pctx->line = isc_lex_getsourceline(pctx->lexer);

	switch (result) {
	case ISC_R_SUCCESS:
		if (pctx->token.type == isc_tokentype_eof) {
			result = isc_lex_close(pctx->lexer);
			INSIST(result == ISC_R_NOMORE ||
			       result == ISC_R_SUCCESS);

			if (isc_lex_getsourcename(pctx->lexer) != NULL) {
				/*
				 * Closed an included file, not the main file.
				 */
				cfg_listelt_t *elt;
				elt = ISC_LIST_TAIL(pctx->open_files->
						    value.list);
				INSIST(elt != NULL);
				ISC_LIST_UNLINK(pctx->open_files->
						value.list, elt, link);
				ISC_LIST_APPEND(pctx->closed_files->
						value.list, elt, link);
				goto redo;
			}
			pctx->seen_eof = ISC_TRUE;
		}
		break;

	case ISC_R_NOSPACE:
		/* More understandable than "ran out of space". */
		cfg_parser_error(pctx, CFG_LOG_NEAR, "token too big");
		break;

	case ISC_R_IOERROR:
		cfg_parser_error(pctx, 0, "%s",
				 isc_result_totext(result));
		break;

	default:
		cfg_parser_error(pctx, CFG_LOG_NEAR, "%s",
				 isc_result_totext(result));
		break;
	}
	return (result);
}

void
cfg_ungettoken(cfg_parser_t *pctx) {
	if (pctx->seen_eof)
		return;
	isc_lex_ungettoken(pctx->lexer, &pctx->token);
	pctx->ungotten = ISC_TRUE;
}

isc_result_t
cfg_peektoken(cfg_parser_t *pctx, int options) {
	isc_result_t result;
	CHECK(cfg_gettoken(pctx, options));
	cfg_ungettoken(pctx);
 cleanup:
	return (result);
}

/*
 * Get a string token, accepting both the quoted and the unquoted form.
 * Log an error if the next token is not a string.
 */
static isc_result_t
cfg_getstringtoken(cfg_parser_t *pctx) {
	isc_result_t result;

	result = cfg_gettoken(pctx, CFG_LEXOPT_QSTRING);
	if (result != ISC_R_SUCCESS)
		return (result);

	if (pctx->token.type != isc_tokentype_string &&
	    pctx->token.type != isc_tokentype_qstring) {
		cfg_parser_error(pctx, CFG_LOG_NEAR, "expected string");
		return (ISC_R_UNEXPECTEDTOKEN);
	}
	return (ISC_R_SUCCESS);
}

void
cfg_parser_error(cfg_parser_t *pctx, unsigned int flags, const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	parser_complain(pctx, ISC_FALSE, flags, fmt, args);
	va_end(args);
	pctx->errors++;
}

void
cfg_parser_warning(cfg_parser_t *pctx, unsigned int flags, const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	parser_complain(pctx, ISC_TRUE, flags, fmt, args);
	va_end(args);
	pctx->warnings++;
}

#define MAX_LOG_TOKEN 30 /* How much of a token to quote in log messages. */

static char *
current_file(cfg_parser_t *pctx) {
	static char none[] = "none";
	cfg_listelt_t *elt;
	cfg_obj_t *fileobj;

	if (pctx->open_files == NULL)
		return (none);
	elt = ISC_LIST_TAIL(pctx->open_files->value.list);
	if (elt == NULL)
	      return (none);

	fileobj = elt->obj;
	INSIST(fileobj->type == &cfg_type_qstring);
	return (fileobj->value.string.base);
}

static void
parser_complain(cfg_parser_t *pctx, isc_boolean_t is_warning,
		unsigned int flags, const char *format,
		va_list args)
{
	char tokenbuf[MAX_LOG_TOKEN + 10];
	static char where[ISC_DIR_PATHMAX + 100];
	static char message[2048];
	int level = ISC_LOG_ERROR;
	const char *prep = "";
	size_t len;

	if (is_warning)
		level = ISC_LOG_WARNING;

	snprintf(where, sizeof(where), "%s:%u: ",
		 current_file(pctx), pctx->line);

	len = vsnprintf(message, sizeof(message), format, args);
	if (len == -1 || len >= sizeof(message))
		FATAL_ERROR(__FILE__, __LINE__,
			    "error message would overflow");

	if ((flags & (CFG_LOG_NEAR|CFG_LOG_BEFORE|CFG_LOG_NOPREP)) != 0) {
		isc_region_t r;

		if (pctx->ungotten)
			(void)cfg_gettoken(pctx, 0);

		if (pctx->token.type == isc_tokentype_eof) {
			snprintf(tokenbuf, sizeof(tokenbuf), "end of file");
		} else if (pctx->token.type == isc_tokentype_unknown) {
			flags = 0;
			tokenbuf[0] = '\0';
		} else {
			isc_lex_getlasttokentext(pctx->lexer,
						 &pctx->token, &r);
			if (r.length > MAX_LOG_TOKEN)
				snprintf(tokenbuf, sizeof(tokenbuf),
					 "'%.*s...'", MAX_LOG_TOKEN, r.base);
			else
				snprintf(tokenbuf, sizeof(tokenbuf),
					 "'%.*s'", (int)r.length, r.base);
		}

		/* Choose a preposition. */
		if (flags & CFG_LOG_NEAR)
			prep = " near ";
		else if (flags & CFG_LOG_BEFORE)
			prep = " before ";
		else
			prep = " ";
	} else {
		tokenbuf[0] = '\0';
	}
	isc_log_write(pctx->lctx, CAT, MOD, level,
		      "%s%s%s%s", where, message, prep, tokenbuf);
}

void
cfg_obj_log(const cfg_obj_t *obj, isc_log_t *lctx, int level,
	    const char *fmt, ...) {
	va_list ap;
	char msgbuf[2048];

	if (! isc_log_wouldlog(lctx, level))
		return;

	va_start(ap, fmt);

	vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);
	isc_log_write(lctx, CAT, MOD, level,
		      "%s:%u: %s",
		      obj->file == NULL ? "<unknown file>" : obj->file,
		      obj->line, msgbuf);
	va_end(ap);
}

const char *
cfg_obj_file(const cfg_obj_t *obj) {
	return (obj->file);
}

unsigned int
cfg_obj_line(const cfg_obj_t *obj) {
	return (obj->line);
}

isc_result_t
cfg_create_obj(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	cfg_obj_t *obj;

	obj = isc_mem_get(pctx->mctx, sizeof(cfg_obj_t));
	if (obj == NULL)
		return (ISC_R_NOMEMORY);
	obj->type = type;
	obj->file = current_file(pctx);
	obj->line = pctx->line;
	*ret = obj;
	return (ISC_R_SUCCESS);
}

static void
map_symtabitem_destroy(char *key, unsigned int type,
		       isc_symvalue_t symval, void *userarg)
{
	cfg_obj_t *obj = symval.as_pointer;
	cfg_parser_t *pctx = (cfg_parser_t *)userarg;

	UNUSED(key);
	UNUSED(type);

	cfg_obj_destroy(pctx, &obj);
}


static isc_result_t
create_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	isc_result_t result;
	isc_symtab_t *symtab = NULL;
	cfg_obj_t *obj = NULL;

	CHECK(cfg_create_obj(pctx, type, &obj));
	CHECK(isc_symtab_create(pctx->mctx, 5, /* XXX */
				map_symtabitem_destroy,
				pctx, ISC_FALSE, &symtab));
	obj->value.map.symtab = symtab;
	obj->value.map.id = NULL;

	*ret = obj;
	return (ISC_R_SUCCESS);

 cleanup:
	if (obj != NULL)
		isc_mem_put(pctx->mctx, obj, sizeof(*obj));
	return (result);
}

static void
free_map(cfg_parser_t *pctx, cfg_obj_t *obj) {
	CLEANUP_OBJ(obj->value.map.id);
	isc_symtab_destroy(&obj->value.map.symtab);
}

isc_boolean_t
cfg_obj_istype(const cfg_obj_t *obj, const cfg_type_t *type) {
	return (ISC_TF(obj->type == type));
}

/*
 * Destroy 'obj', a configuration object created in 'pctx'.
 */
void
cfg_obj_destroy(cfg_parser_t *pctx, cfg_obj_t **objp) {
	cfg_obj_t *obj = *objp;
	obj->type->rep->free(pctx, obj);
	isc_mem_put(pctx->mctx, obj, sizeof(cfg_obj_t));
	*objp = NULL;
}

static void
free_noop(cfg_parser_t *pctx, cfg_obj_t *obj) {
	UNUSED(pctx);
	UNUSED(obj);
}

void
cfg_doc_obj(cfg_printer_t *pctx, const cfg_type_t *type) {
	type->doc(pctx, type);
}

void
cfg_doc_terminal(cfg_printer_t *pctx, const cfg_type_t *type) {
	cfg_print_chars(pctx, "<", 1);
	cfg_print_cstr(pctx, type->name);
	cfg_print_chars(pctx, ">", 1);
}

void
cfg_print_grammar(const cfg_type_t *type,
	void (*f)(void *closure, const char *text, int textlen),
	void *closure)
{
	cfg_printer_t pctx;
	pctx.f = f;
	pctx.closure = closure;
	pctx.indent = 0;
	cfg_doc_obj(&pctx, type);
}
@


1.11
log
@resolve conflicts and regen configure script
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")
d18 3
a20 1
/* $ISC: parser.c,v 1.70.2.20.2.21 2006/02/28 06:32:54 marka Exp $ */
d130 1
a130 1
/*
a1091 1

d1364 1
a1364 1
 * Used for the "server" statement.
d1371 9
d1498 3
d1733 3
d1738 18
a1755 2
	if (result == ISC_R_UNEXPECTEDTOKEN)
		cfg_parser_error(pctx, CFG_LOG_NEAR, "expected IP address");
d1810 6
d1821 2
a1822 1
	UNUSED(type);
d1824 1
a1824 1
	CHECK(cfg_parse_rawaddr(pctx, CFG_ADDR_V4OK | CFG_ADDR_V6OK, &netaddr));
d1833 26
d1860 22
a1881 2
	"netaddr", parse_netaddr, cfg_print_sockaddr, cfg_doc_terminal,
	&cfg_rep_sockaddr, NULL
@


1.10
log
@more vsnprintf checking. ok cloder@@
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: parser.c,v 1.70.2.20.2.18 2004/05/15 03:46:13 jinmei Exp $ */
d71 1
a71 1
print_list(cfg_printer_t *pctx, cfg_obj_t *obj);
d137 1
a137 1
cfg_print_obj(cfg_printer_t *pctx, cfg_obj_t *obj) {
d180 1
a180 1
cfg_print(cfg_obj_t *obj,
d246 1
a246 1
cfg_print_tuple(cfg_printer_t *pctx, cfg_obj_t *obj) {
d253 1
a253 1
		cfg_obj_t *fieldobj = obj->value.tuple[i];
d294 1
a294 1
cfg_obj_istuple(cfg_obj_t *obj) {
d299 2
a300 2
cfg_obj_t *
cfg_tuple_get(cfg_obj_t *tupleobj, const char* name) {
d551 1
a551 1
cfg_print_void(cfg_printer_t *pctx, cfg_obj_t *obj) {
d563 1
a563 1
cfg_obj_isvoid(cfg_obj_t *obj) {
d609 1
a609 1
cfg_print_uint32(cfg_printer_t *pctx, cfg_obj_t *obj) {
d614 1
a614 1
cfg_obj_isuint32(cfg_obj_t *obj) {
d620 1
a620 1
cfg_obj_asuint32(cfg_obj_t *obj) {
d635 1
a635 1
cfg_obj_isuint64(cfg_obj_t *obj) {
d641 1
a641 1
cfg_obj_asuint64(cfg_obj_t *obj) {
d647 1
a647 1
cfg_print_uint64(cfg_printer_t *pctx, cfg_obj_t *obj) {
d726 3
a728 1
cfg_parse_astring(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d786 1
a786 1
cfg_print_ustring(cfg_printer_t *pctx, cfg_obj_t *obj) {
d791 1
a791 1
print_qstring(cfg_printer_t *pctx, cfg_obj_t *obj) {
d804 1
a804 1
cfg_obj_isstring(cfg_obj_t *obj) {
d809 2
a810 2
char *
cfg_obj_asstring(cfg_obj_t *obj) {
d838 1
a838 1
cfg_obj_isboolean(cfg_obj_t *obj) {
d844 1
a844 1
cfg_obj_asboolean(cfg_obj_t *obj) {
d890 1
a890 1
print_boolean(cfg_printer_t *pctx, cfg_obj_t *obj) {
d1004 3
a1006 3
print_list(cfg_printer_t *pctx, cfg_obj_t *obj) {
	cfg_list_t *list = &obj->value.list;
	cfg_listelt_t *elt;
d1030 1
a1030 1
cfg_print_bracketed_list(cfg_printer_t *pctx, cfg_obj_t *obj) {
d1077 3
a1079 3
cfg_print_spacelist(cfg_printer_t *pctx, cfg_obj_t *obj) {
	cfg_list_t *list = &obj->value.list;
	cfg_listelt_t *elt;
d1092 1
a1092 1
cfg_obj_islist(cfg_obj_t *obj) {
d1097 2
a1098 2
cfg_listelt_t *
cfg_list_first(cfg_obj_t *obj) {
d1105 2
a1106 2
cfg_listelt_t *
cfg_list_next(cfg_listelt_t *elt) {
d1111 2
a1112 2
cfg_obj_t *
cfg_listelt_value(cfg_listelt_t *elt) {
d1371 1
a1371 1
cfg_print_mapbody(cfg_printer_t *pctx, cfg_obj_t *obj) {
d1451 1
a1451 1
cfg_print_map(cfg_printer_t *pctx, cfg_obj_t *obj) {
d1510 1
a1510 1
cfg_obj_ismap(cfg_obj_t *obj) {
d1516 1
a1516 1
cfg_map_get(cfg_obj_t *mapobj, const char* name, cfg_obj_t **obj) {
d1519 1
a1519 1
	cfg_map_t *map;
d1534 2
a1535 2
cfg_obj_t *
cfg_map_getname(cfg_obj_t *mapobj) {
d1561 4
d1569 1
d1572 2
d1765 1
a1765 1
cfg_print_rawaddr(cfg_printer_t *pctx, isc_netaddr_t *na) {
d1855 3
a1857 2
print_netprefix(cfg_printer_t *pctx, cfg_obj_t *obj) {
	cfg_netprefix_t *p = &obj->value.netprefix;
d1864 1
a1864 1
cfg_obj_isnetprefix(cfg_obj_t *obj) {
d1870 1
a1870 1
cfg_obj_asnetprefix(cfg_obj_t *obj, isc_netaddr_t *netaddr,
d1921 1
a1921 1
cfg_print_sockaddr(cfg_printer_t *pctx, cfg_obj_t *obj) {
a1941 2
		if (n != 0)
			cfg_print_chars(pctx, " | ", 3);
d1966 1
a1966 1
cfg_obj_issockaddr(cfg_obj_t *obj) {
d1971 2
a1972 2
isc_sockaddr_t *
cfg_obj_assockaddr(cfg_obj_t *obj) {
d2169 2
a2170 1
cfg_obj_log(cfg_obj_t *obj, isc_log_t *lctx, int level, const char *fmt, ...) {
d2188 1
a2188 1
cfg_obj_file(cfg_obj_t *obj) {
d2193 1
a2193 1
cfg_obj_line(cfg_obj_t *obj) {
a2234 1

d2254 1
a2254 1
cfg_obj_istype(cfg_obj_t *obj, const cfg_type_t *type) {
@


1.9
log
@resolve conflicts
@
text
@d2120 1
a2120 1
	if (len >= sizeof(message))
@


1.8
log
@back out last change since it was unnecessary, the last bind merge fixed the deeper issue
@
text
@d2 1
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: parser.c,v 1.70.2.22 2003/09/19 13:41:36 marka Exp $ */
d33 1
d38 1
a44 10
#define QSTRING (ISC_LEXOPT_QSTRING | ISC_LEXOPT_QSTRINGMULTILINE)

/*
 * Pass one of these flags to parser_error() to include the
 * token text in log message.
 */
#define LOG_NEAR    0x00000001	/* Say "near <token>" */
#define LOG_BEFORE  0x00000002	/* Say "before <token>" */
#define LOG_NOPREP  0x00000004	/* Say just "<token>" */

d47 1
a47 24
/* Clause may occur multiple times (e.g., "zone") */
#define CFG_CLAUSEFLAG_MULTI 		0x00000001
/* Clause is obsolete */
#define CFG_CLAUSEFLAG_OBSOLETE 	0x00000002
/* Clause is not implemented, and may never be */
#define CFG_CLAUSEFLAG_NOTIMP	 	0x00000004
/* Clause is not implemented yet */
#define CFG_CLAUSEFLAG_NYI 		0x00000008
/* Default value has changed since earlier release */
#define CFG_CLAUSEFLAG_NEWDEFAULT	0x00000010
/*
 * Clause needs to be interpreted during parsing
 * by calling a callback function, like the
 * "directory" option.
 */
#define CFG_CLAUSEFLAG_CALLBACK		0x00000020

/*
 * Flags defining whether to accept certain types of network addresses.
 */
#define V4OK 		0x00000001
#define V4PREFIXOK 	0x00000002
#define V6OK 		0x00000004
#define WILDOK		0x00000008
a59 163
typedef struct cfg_clausedef cfg_clausedef_t;
typedef struct cfg_tuplefielddef cfg_tuplefielddef_t;
typedef struct cfg_printer cfg_printer_t;
typedef ISC_LIST(cfg_listelt_t) cfg_list_t;
typedef struct cfg_map cfg_map_t;
typedef struct cfg_rep cfg_rep_t;

/*
 * Function types for configuration object methods
 */

typedef isc_result_t (*cfg_parsefunc_t)(cfg_parser_t *, const cfg_type_t *type,
					cfg_obj_t **);
typedef void	     (*cfg_printfunc_t)(cfg_printer_t *, cfg_obj_t *);
typedef void	     (*cfg_freefunc_t)(cfg_parser_t *, cfg_obj_t *);


/*
 * Structure definitions
 */

/* The parser object. */
struct cfg_parser {
	isc_mem_t *	mctx;
	isc_log_t *	lctx;
	isc_lex_t *	lexer;
	unsigned int    errors;
	unsigned int    warnings;
	isc_token_t     token;

	/* We are at the end of all input. */
	isc_boolean_t	seen_eof;

	/* The current token has been pushed back. */
	isc_boolean_t	ungotten;

	/*
	 * The stack of currently active files, represented
	 * as a configuration list of configuration strings.
	 * The head is the top-level file, subsequent elements 
	 * (if any) are the nested include files, and the 
	 * last element is the file currently being parsed.
	 */
	cfg_obj_t *	open_files;

	/*
	 * Names of files that we have parsed and closed
	 * and were previously on the open_file list.
	 * We keep these objects around after closing
	 * the files because the file names may still be
	 * referenced from other configuration objects
	 * for use in reporting semantic errors after
	 * parsing is complete.
	 */
	cfg_obj_t *	closed_files;

	/*
	 * Current line number.  We maintain our own
	 * copy of this so that it is available even
	 * when a file has just been closed.
	 */
	unsigned int	line;

	cfg_parsecallback_t callback;
	void *callbackarg;
};

/*
 * A configuration printer object.  This is an abstract
 * interface to a destination to which text can be printed
 * by calling the function 'f'.
 */
struct cfg_printer {
	void (*f)(void *closure, const char *text, int textlen);
	void *closure;
	int indent;
};

/* A clause definition. */

struct cfg_clausedef {
	const char      *name;
	cfg_type_t      *type;
	unsigned int	flags;
};

/* A tuple field definition. */

struct cfg_tuplefielddef {
	const char      *name;
	cfg_type_t      *type;
	unsigned int	flags;
};

/* A configuration object type definition. */
struct cfg_type {
	const char *name;	/* For debugging purposes only */
	cfg_parsefunc_t  parse;
	cfg_printfunc_t  print;
	cfg_rep_t *	 rep;	/* Data representation */
	const void *	 of;	/* For meta-types */
};

/* A keyword-type definition, for things like "port <integer>". */

typedef struct {
	const char *name;
	const cfg_type_t *type;
} keyword_type_t;

struct cfg_map {
	cfg_obj_t	 *id; /* Used for 'named maps' like keys, zones, &c */
	const cfg_clausedef_t * const *clausesets; /* The clauses that
						      can occur in this map;
						      used for printing */
	isc_symtab_t     *symtab;
};

typedef struct cfg_netprefix cfg_netprefix_t;

struct cfg_netprefix {
	isc_netaddr_t address; /* IP4/IP6 */
	unsigned int prefixlen;
};

/*
 * A configuration data representation.
 */
struct cfg_rep {
	const char *	name;	/* For debugging only */
	cfg_freefunc_t 	free;	/* How to free this kind of data. */
};

/*
 * A configuration object.  This is the main building block
 * of the configuration parse tree.
 */

struct cfg_obj {
	const cfg_type_t *type;
	union {
		isc_uint32_t  	uint32;
		isc_uint64_t  	uint64;
		isc_textregion_t string; /* null terminated, too */
		isc_boolean_t 	boolean;
		cfg_map_t	map;
		cfg_list_t	list;
		cfg_obj_t **	tuple;
		isc_sockaddr_t	sockaddr;
		cfg_netprefix_t netprefix;
	}               value;
	char *		file;
	unsigned int    line;
};


/* A list element. */

struct cfg_listelt {
	cfg_obj_t               *obj;
	ISC_LINK(cfg_listelt_t)  link;
};

d64 2
a65 2
static isc_result_t
create_cfgobj(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **objp);
d68 1
a68 1
create_list(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **objp);
d70 2
a71 2
static isc_result_t
create_listelt(cfg_parser_t *pctx, cfg_listelt_t **eltp);
d77 3
a88 3
static isc_result_t
create_tuple(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **objp);

a92 73
get_addr(cfg_parser_t *pctx, unsigned int flags, isc_netaddr_t *na);

static void
print(cfg_printer_t *pctx, const char *text, int len);

static void
print_void(cfg_printer_t *pctx, cfg_obj_t *obj);

static isc_result_t
parse_enum_or_other(cfg_parser_t *pctx, const cfg_type_t *enumtype,
		    const cfg_type_t *othertype, cfg_obj_t **ret);

static isc_result_t
parse_mapbody(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret);

static void
print_mapbody(cfg_printer_t *pctx, cfg_obj_t *obj);

static isc_result_t
parse_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret);

static void
print_map(cfg_printer_t *pctx, cfg_obj_t *obj);

static isc_result_t
parse_named_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret);

static isc_result_t
parse_addressed_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret);

static isc_result_t
parse_list(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret);

static void
print_list(cfg_printer_t *pctx, cfg_obj_t *obj);

static isc_result_t
parse_tuple(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret);

static void
print_tuple(cfg_printer_t *pctx, cfg_obj_t *obj);

static void
free_tuple(cfg_parser_t *pctx, cfg_obj_t *obj);

static isc_result_t
parse_spacelist(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret);

static void
print_spacelist(cfg_printer_t *pctx, cfg_obj_t *obj);

static void
print_sockaddr(cfg_printer_t *pctx, cfg_obj_t *obj);

static isc_result_t
parse_addrmatchelt(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret);

static isc_result_t
parse_bracketed_list(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret);

static void
print_bracketed_list(cfg_printer_t *pctx, cfg_obj_t *obj);

static isc_result_t
parse_keyvalue(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret);

static isc_result_t
parse_optional_keyvalue(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret);

static void
print_keyvalue(cfg_printer_t *pctx, cfg_obj_t *obj);

static isc_result_t
a100 9
cfg_gettoken(cfg_parser_t *pctx, int options);

static void
cfg_ungettoken(cfg_parser_t *pctx);

static isc_result_t
cfg_peektoken(cfg_parser_t *pctx, int options);

static isc_result_t
a103 8
parser_error(cfg_parser_t *pctx, unsigned int flags,
	     const char *fmt, ...) ISC_FORMAT_PRINTF(3, 4);

static void
parser_warning(cfg_parser_t *pctx, unsigned int flags,
	       const char *fmt, ...) ISC_FORMAT_PRINTF(3, 4);

static void
a106 9
static void
print_uint32(cfg_printer_t *pctx, cfg_obj_t *obj);

static void
print_ustring(cfg_printer_t *pctx, cfg_obj_t *obj);

static isc_result_t
parse_enum(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret);

a124 54
 * Forward declarations of configuration type definitions.
 * Additional types are declared publicly in cfg.h.
 */

static cfg_type_t cfg_type_boolean;
static cfg_type_t cfg_type_uint32;
static cfg_type_t cfg_type_qstring;
static cfg_type_t cfg_type_astring;
static cfg_type_t cfg_type_ustring;
static cfg_type_t cfg_type_optional_port;
static cfg_type_t cfg_type_bracketed_aml;
static cfg_type_t cfg_type_acl;
static cfg_type_t cfg_type_portiplist;
static cfg_type_t cfg_type_bracketed_sockaddrlist;
static cfg_type_t cfg_type_sockaddr;
static cfg_type_t cfg_type_netaddr;
static cfg_type_t cfg_type_optional_keyref;
static cfg_type_t cfg_type_options;
static cfg_type_t cfg_type_view;
static cfg_type_t cfg_type_viewopts;
static cfg_type_t cfg_type_key;
static cfg_type_t cfg_type_server;
static cfg_type_t cfg_type_controls;
static cfg_type_t cfg_type_bracketed_sockaddrkeylist;
static cfg_type_t cfg_type_querysource4;
static cfg_type_t cfg_type_querysource6;
static cfg_type_t cfg_type_querysource;
static cfg_type_t cfg_type_sockaddr4wild;
static cfg_type_t cfg_type_sockaddr6wild;
static cfg_type_t cfg_type_sockaddr;
static cfg_type_t cfg_type_netprefix;
static cfg_type_t cfg_type_zone;
static cfg_type_t cfg_type_zoneopts;
static cfg_type_t cfg_type_logging;
static cfg_type_t cfg_type_optional_facility;
static cfg_type_t cfg_type_void;
static cfg_type_t cfg_type_optional_class;
static cfg_type_t cfg_type_destinationlist;
static cfg_type_t cfg_type_size;
static cfg_type_t cfg_type_sizenodefault;
static cfg_type_t cfg_type_negated;
static cfg_type_t cfg_type_addrmatchelt;
static cfg_type_t cfg_type_unsupported;
static cfg_type_t cfg_type_token;
static cfg_type_t cfg_type_server_key_kludge;
static cfg_type_t cfg_type_optional_facility;
static cfg_type_t cfg_type_logseverity;
static cfg_type_t cfg_type_logfile;
static cfg_type_t cfg_type_lwres;
static cfg_type_t cfg_type_controls_sockaddr;
static cfg_type_t cfg_type_notifytype;
static cfg_type_t cfg_type_dialuptype;

/*
a127 270
/* tkey-dhkey */

static cfg_tuplefielddef_t tkey_dhkey_fields[] = {
	{ "name", &cfg_type_qstring, 0 },
	{ "keyid", &cfg_type_uint32, 0 },
	{ NULL, NULL, 0 }
};

static cfg_type_t cfg_type_tkey_dhkey = {
	"tkey-dhkey", parse_tuple, print_tuple, &cfg_rep_tuple,
	tkey_dhkey_fields
};

/* listen-on */

static cfg_tuplefielddef_t listenon_fields[] = {
	{ "port", &cfg_type_optional_port, 0 },
	{ "acl", &cfg_type_bracketed_aml, 0 },
	{ NULL, NULL, 0 }
};
static cfg_type_t cfg_type_listenon = {
	"listenon", parse_tuple, print_tuple, &cfg_rep_tuple, listenon_fields };

/* acl */

static cfg_tuplefielddef_t acl_fields[] = {
	{ "name", &cfg_type_astring, 0 },
	{ "value", &cfg_type_bracketed_aml, 0 },
	{ NULL, NULL, 0 }
};

static cfg_type_t cfg_type_acl = {
	"acl", parse_tuple, print_tuple, &cfg_rep_tuple, acl_fields };


/*
 * "sockaddrkeylist", a list of socket addresses with optional keys
 * and an optional default port, as used in the masters option.
 * E.g.,
 *   "port 1234 { 10.0.0.1 key foo; 1::2 port 69; }"
 */

static cfg_tuplefielddef_t sockaddrkey_fields[] = {
	{ "sockaddr", &cfg_type_sockaddr, 0 },
	{ "key", &cfg_type_optional_keyref, 0 },
	{ NULL, NULL, 0 },
};

static cfg_type_t cfg_type_sockaddrkey = {
	"sockaddrkey", parse_tuple, print_tuple, &cfg_rep_tuple,
	sockaddrkey_fields
};

static cfg_type_t cfg_type_bracketed_sockaddrkeylist = {
	"bracketed_sockaddrkeylist", parse_bracketed_list,
	print_bracketed_list, &cfg_rep_list, &cfg_type_sockaddrkey
};

static cfg_tuplefielddef_t sockaddrkeylist_fields[] = {
	{ "port", &cfg_type_optional_port, 0 },
	{ "addresses", &cfg_type_bracketed_sockaddrkeylist, 0 },
	{ NULL, NULL, 0 }
};
static cfg_type_t cfg_type_sockaddrkeylist = {
	"sockaddrkeylist", parse_tuple, print_tuple, &cfg_rep_tuple,
	sockaddrkeylist_fields
};

/*
 * A list of socket addresses with an optional default port,
 * as used in the also-notify option.  E.g.,
 * "port 1234 { 10.0.0.1; 1::2 port 69; }"
 */
static cfg_tuplefielddef_t portiplist_fields[] = {
	{ "port", &cfg_type_optional_port, 0 },
	{ "addresses", &cfg_type_bracketed_sockaddrlist, 0 },
	{ NULL, NULL, 0 }
};
static cfg_type_t cfg_type_portiplist = {
	"portiplist", parse_tuple, print_tuple, &cfg_rep_tuple,
	portiplist_fields
};

/*
 * A public key, as in the "pubkey" statement.
 */
static cfg_tuplefielddef_t pubkey_fields[] = {
	{ "flags", &cfg_type_uint32, 0 },
	{ "protocol", &cfg_type_uint32, 0 },
	{ "algorithm", &cfg_type_uint32, 0 },
	{ "key", &cfg_type_qstring, 0 },
	{ NULL, NULL, 0 }
};
static cfg_type_t cfg_type_pubkey = {
	"pubkey", parse_tuple, print_tuple, &cfg_rep_tuple, pubkey_fields };


/*
 * A list of RR types, used in grant statements.
 * Note that the old parser allows quotes around the RR type names.
 */
static cfg_type_t cfg_type_rrtypelist = {
	"rrtypelist", parse_spacelist, print_spacelist, &cfg_rep_list,
	&cfg_type_astring
};

static const char *mode_enums[] = { "grant", "deny", NULL };
static cfg_type_t cfg_type_mode = {
	"mode", parse_enum, print_ustring, &cfg_rep_string,
	&mode_enums
};

static const char *matchtype_enums[] = {
	"name", "subdomain", "wildcard", "self", NULL };
static cfg_type_t cfg_type_matchtype = {
	"matchtype", parse_enum, print_ustring, &cfg_rep_string,
	&matchtype_enums
};

/*
 * A grant statement, used in the update policy.
 */
static cfg_tuplefielddef_t grant_fields[] = {
	{ "mode", &cfg_type_mode, 0 },
	{ "identity", &cfg_type_astring, 0 }, /* domain name */ 
	{ "matchtype", &cfg_type_matchtype, 0 },
	{ "name", &cfg_type_astring, 0 }, /* domain name */
	{ "types", &cfg_type_rrtypelist, 0 },
	{ NULL, NULL, 0 }
};
static cfg_type_t cfg_type_grant = {
	"grant", parse_tuple, print_tuple, &cfg_rep_tuple, grant_fields };

static cfg_type_t cfg_type_updatepolicy = {
	"update_policy", parse_bracketed_list, print_bracketed_list,
	&cfg_rep_list, &cfg_type_grant
};

/*
 * A view statement.
 */
static cfg_tuplefielddef_t view_fields[] = {
	{ "name", &cfg_type_astring, 0 },
	{ "class", &cfg_type_optional_class, 0 },
	{ "options", &cfg_type_viewopts, 0 },
	{ NULL, NULL, 0 }
};
static cfg_type_t cfg_type_view = {
	"view", parse_tuple, print_tuple, &cfg_rep_tuple, view_fields };

/*
 * A zone statement.
 */
static cfg_tuplefielddef_t zone_fields[] = {
	{ "name", &cfg_type_astring, 0 },
	{ "class", &cfg_type_optional_class, 0 },
	{ "options", &cfg_type_zoneopts, 0 },
	{ NULL, NULL, 0 }
};
static cfg_type_t cfg_type_zone = {
	"zone", parse_tuple, print_tuple, &cfg_rep_tuple, zone_fields };

/*
 * A "category" clause in the "logging" statement.
 */
static cfg_tuplefielddef_t category_fields[] = {
	{ "name", &cfg_type_astring, 0 },
	{ "destinations", &cfg_type_destinationlist,0 },
	{ NULL, NULL, 0 }
};
static cfg_type_t cfg_type_category = {
	"category", parse_tuple, print_tuple, &cfg_rep_tuple, category_fields };


/*
 * A trusted key, as used in the "trusted-keys" statement.
 */
static cfg_tuplefielddef_t trustedkey_fields[] = {
	{ "name", &cfg_type_astring, 0 },
	{ "flags", &cfg_type_uint32, 0 },
	{ "protocol", &cfg_type_uint32, 0 },
	{ "algorithm", &cfg_type_uint32, 0 },
	{ "key", &cfg_type_qstring, 0 },
	{ NULL, NULL, 0 }
};
static cfg_type_t cfg_type_trustedkey = {
	"trustedkey", parse_tuple, print_tuple, &cfg_rep_tuple,
	trustedkey_fields
};


static keyword_type_t wild_class_kw = { "class", &cfg_type_ustring };

static cfg_type_t cfg_type_optional_wild_class = {
	"optional_wild_class", parse_optional_keyvalue,
	print_keyvalue, &cfg_rep_string, &wild_class_kw
};

static keyword_type_t wild_type_kw = { "type", &cfg_type_ustring };

static cfg_type_t cfg_type_optional_wild_type = {
	"optional_wild_type", parse_optional_keyvalue,
	print_keyvalue, &cfg_rep_string, &wild_type_kw
};

static keyword_type_t wild_name_kw = { "name", &cfg_type_qstring };

static cfg_type_t cfg_type_optional_wild_name = {
	"optional_wild_name", parse_optional_keyvalue,
	print_keyvalue, &cfg_rep_string, &wild_name_kw
};

/*
 * An rrset ordering element.
 */
static cfg_tuplefielddef_t rrsetorderingelement_fields[] = {
	{ "class", &cfg_type_optional_wild_class, 0 },
	{ "type", &cfg_type_optional_wild_type, 0 },
	{ "name", &cfg_type_optional_wild_name, 0 },
	{ "order", &cfg_type_ustring, 0 }, /* must be literal "order" */ 
	{ "ordering", &cfg_type_ustring, 0 },
	{ NULL, NULL, 0 }
};
static cfg_type_t cfg_type_rrsetorderingelement = {
	"rrsetorderingelement", parse_tuple, print_tuple, &cfg_rep_tuple,
	rrsetorderingelement_fields
};

/*
 * A global or view "check-names" option.  Note that the zone
 * "check-names" option has a different syntax.
 */
static cfg_tuplefielddef_t checknames_fields[] = {
	{ "type", &cfg_type_ustring, 0 },
	{ "mode", &cfg_type_ustring, 0 },
	{ NULL, NULL, 0 }
};
static cfg_type_t cfg_type_checknames = {
	"checknames", parse_tuple, print_tuple, &cfg_rep_tuple,
	checknames_fields
};

static cfg_type_t cfg_type_bracketed_sockaddrlist = {
	"bracketed_sockaddrlist", parse_bracketed_list, print_bracketed_list,
	&cfg_rep_list, &cfg_type_sockaddr
};

static cfg_type_t cfg_type_rrsetorder = {
	"rrsetorder", parse_bracketed_list, print_bracketed_list,
	&cfg_rep_list, &cfg_type_rrsetorderingelement
};

static keyword_type_t port_kw = { "port", &cfg_type_uint32 };

static cfg_type_t cfg_type_optional_port = {
	"optional_port", parse_optional_keyvalue, print_keyvalue,
	&cfg_rep_uint32, &port_kw
};

/* A list of keys, as in the "key" clause of the controls statement. */
static cfg_type_t cfg_type_keylist = {
	"keylist", parse_bracketed_list, print_bracketed_list, &cfg_rep_list,
	&cfg_type_astring
};

static cfg_type_t cfg_type_trustedkeys = {
	"trusted-keys", parse_bracketed_list, print_bracketed_list, &cfg_rep_list,
	&cfg_type_trustedkey
};

d132 1
a132 381
	"implicitlist", NULL, print_list, &cfg_rep_list, NULL };

static const char *forwardtype_enums[] = { "first", "only", NULL };
static cfg_type_t cfg_type_forwardtype = {
	"forwardtype", parse_enum, print_ustring, &cfg_rep_string,
	&forwardtype_enums
};

static const char *zonetype_enums[] = {
	"master", "slave", "stub", "hint", "forward", "delegation-only", NULL };
static cfg_type_t cfg_type_zonetype = {
	"zonetype", parse_enum, print_ustring, &cfg_rep_string,
	&zonetype_enums
};

static const char *loglevel_enums[] = {
	"critical", "error", "warning", "notice", "info", "dynamic", NULL };
static cfg_type_t cfg_type_loglevel = {
	"loglevel", parse_enum, print_ustring, &cfg_rep_string,
	&loglevel_enums
};

static const char *transferformat_enums[] = {
	"many-answers", "one-answer", NULL };
static cfg_type_t cfg_type_transferformat = {
	"transferformat", parse_enum, print_ustring, &cfg_rep_string,
	&transferformat_enums
};

/*
 * Clauses that can be found within the top level of the named.conf
 * file only.
 */
static cfg_clausedef_t
namedconf_clauses[] = {
	{ "options", &cfg_type_options, 0 },
	{ "controls", &cfg_type_controls, CFG_CLAUSEFLAG_MULTI },
	{ "acl", &cfg_type_acl, CFG_CLAUSEFLAG_MULTI },
	{ "logging", &cfg_type_logging, 0 },
	{ "view", &cfg_type_view, CFG_CLAUSEFLAG_MULTI },
	{ "lwres", &cfg_type_lwres, CFG_CLAUSEFLAG_MULTI },
	{ NULL, NULL, 0 }
};

/*
 * Clauses that can occur at the top level or in the view
 * statement, but not in the options block.
 */
static cfg_clausedef_t
namedconf_or_view_clauses[] = {
	{ "key", &cfg_type_key, CFG_CLAUSEFLAG_MULTI },
	{ "zone", &cfg_type_zone, CFG_CLAUSEFLAG_MULTI },
	{ "server", &cfg_type_server, CFG_CLAUSEFLAG_MULTI },
#ifdef ISC_RFC2535
	{ "trusted-keys", &cfg_type_trustedkeys, CFG_CLAUSEFLAG_MULTI },
#else
	{ "trusted-keys", &cfg_type_trustedkeys,
		 CFG_CLAUSEFLAG_MULTI|CFG_CLAUSEFLAG_OBSOLETE },
#endif
	{ NULL, NULL, 0 }
};

/*
 * Clauses that can be found within the 'options' statement.
 */
static cfg_clausedef_t
options_clauses[] = {
	{ "blackhole", &cfg_type_bracketed_aml, 0 },
	{ "coresize", &cfg_type_size, 0 },
	{ "datasize", &cfg_type_size, 0 },
	{ "deallocate-on-exit", &cfg_type_boolean, CFG_CLAUSEFLAG_OBSOLETE },
	{ "directory", &cfg_type_qstring, CFG_CLAUSEFLAG_CALLBACK },
	{ "dump-file", &cfg_type_qstring, 0 },
	{ "fake-iquery", &cfg_type_boolean, CFG_CLAUSEFLAG_OBSOLETE },
	{ "files", &cfg_type_size, 0 },
	{ "has-old-clients", &cfg_type_boolean, CFG_CLAUSEFLAG_OBSOLETE },
	{ "heartbeat-interval", &cfg_type_uint32, 0 },
	{ "host-statistics", &cfg_type_boolean, CFG_CLAUSEFLAG_NOTIMP },
	{ "interface-interval", &cfg_type_uint32, 0 },
	{ "listen-on", &cfg_type_listenon, CFG_CLAUSEFLAG_MULTI },
	{ "listen-on-v6", &cfg_type_listenon, CFG_CLAUSEFLAG_MULTI },
	{ "match-mapped-addresses", &cfg_type_boolean, 0 },
	{ "memstatistics-file", &cfg_type_qstring, CFG_CLAUSEFLAG_NOTIMP },
	{ "multiple-cnames", &cfg_type_boolean, CFG_CLAUSEFLAG_OBSOLETE },
	{ "named-xfer", &cfg_type_qstring, CFG_CLAUSEFLAG_OBSOLETE },
	{ "pid-file", &cfg_type_qstring, 0 },
	{ "port", &cfg_type_uint32, 0 },
	{ "random-device", &cfg_type_qstring, 0 },
	{ "recursive-clients", &cfg_type_uint32, 0 },
	{ "rrset-order", &cfg_type_rrsetorder, CFG_CLAUSEFLAG_NOTIMP },
	{ "serial-queries", &cfg_type_uint32, CFG_CLAUSEFLAG_OBSOLETE },
	{ "serial-query-rate", &cfg_type_uint32, 0 },
	{ "stacksize", &cfg_type_size, 0 },
	{ "statistics-file", &cfg_type_qstring, 0 },
	{ "statistics-interval", &cfg_type_uint32, CFG_CLAUSEFLAG_NYI },
	{ "tcp-clients", &cfg_type_uint32, 0 },
	{ "tkey-dhkey", &cfg_type_tkey_dhkey, 0 },
	{ "tkey-gssapi-credential", &cfg_type_qstring, 0 },
	{ "tkey-domain", &cfg_type_qstring, 0 },
	{ "transfers-per-ns", &cfg_type_uint32, 0 },
	{ "transfers-in", &cfg_type_uint32, 0 },
	{ "transfers-out", &cfg_type_uint32, 0 },
	{ "treat-cr-as-space", &cfg_type_boolean, CFG_CLAUSEFLAG_OBSOLETE },
	{ "use-id-pool", &cfg_type_boolean, CFG_CLAUSEFLAG_OBSOLETE },
	{ "use-ixfr", &cfg_type_boolean, 0 },
	{ "version", &cfg_type_qstring, 0 },
	{ NULL, NULL, 0 }
};


static cfg_type_t cfg_type_namelist = {
	"namelist", parse_bracketed_list, print_bracketed_list,
	&cfg_rep_list, &cfg_type_qstring };

static keyword_type_t exclude_kw = { "exclude", &cfg_type_namelist };

static cfg_type_t cfg_type_optional_exclude = {
	"optional_exclude", parse_optional_keyvalue, print_keyvalue,
	&cfg_rep_list, &exclude_kw };

/*
 * Clauses that can be found within the 'view' statement,
 * with defaults in the 'options' statement.
 */

static cfg_clausedef_t
view_clauses[] = {
	{ "allow-recursion", &cfg_type_bracketed_aml, 0 },
	{ "allow-v6-synthesis", &cfg_type_bracketed_aml, 0 },
	{ "sortlist", &cfg_type_bracketed_aml, 0 },
	{ "topology", &cfg_type_bracketed_aml, CFG_CLAUSEFLAG_NOTIMP },
	{ "auth-nxdomain", &cfg_type_boolean, CFG_CLAUSEFLAG_NEWDEFAULT },
	{ "minimal-responses", &cfg_type_boolean, 0 },
	{ "recursion", &cfg_type_boolean, 0 },
	{ "provide-ixfr", &cfg_type_boolean, 0 },
	{ "request-ixfr", &cfg_type_boolean, 0 },
	{ "fetch-glue", &cfg_type_boolean, CFG_CLAUSEFLAG_OBSOLETE },
	{ "rfc2308-type1", &cfg_type_boolean, CFG_CLAUSEFLAG_NYI },
	{ "additional-from-auth", &cfg_type_boolean, 0 },
	{ "additional-from-cache", &cfg_type_boolean, 0 },
	/*
	 * Note that the query-source option syntax is different
	 * from the other -source options.
	 */
	{ "query-source", &cfg_type_querysource4, 0 },
	{ "query-source-v6", &cfg_type_querysource6, 0 },
	{ "cleaning-interval", &cfg_type_uint32, 0 },
	{ "min-roots", &cfg_type_uint32, CFG_CLAUSEFLAG_NOTIMP },
	{ "lame-ttl", &cfg_type_uint32, 0 },
	{ "max-ncache-ttl", &cfg_type_uint32, 0 },
	{ "max-cache-ttl", &cfg_type_uint32, 0 },
	{ "transfer-format", &cfg_type_transferformat, 0 },
	{ "max-cache-size", &cfg_type_sizenodefault, 0 },
	{ "check-names", &cfg_type_checknames,
	  CFG_CLAUSEFLAG_MULTI | CFG_CLAUSEFLAG_NOTIMP },
	{ "cache-file", &cfg_type_qstring, 0 },
	{ "root-delegation-only",  &cfg_type_optional_exclude, 0 },
	{ NULL, NULL, 0 }
};

/*
 * Clauses that can be found within the 'view' statement only.
 */
static cfg_clausedef_t
view_only_clauses[] = {
	{ "match-clients", &cfg_type_bracketed_aml, 0 },
	{ "match-destinations", &cfg_type_bracketed_aml, 0 },
	{ "match-recursive-only", &cfg_type_boolean, 0 },
	{ NULL, NULL, 0 }
};

/*
 * Clauses that can be found in a 'zone' statement,
 * with defaults in the 'view' or 'options' statement.
 */
static cfg_clausedef_t
zone_clauses[] = {
	{ "allow-query", &cfg_type_bracketed_aml, 0 },
	{ "allow-transfer", &cfg_type_bracketed_aml, 0 },
	{ "allow-update-forwarding", &cfg_type_bracketed_aml, 0 },
	{ "allow-notify", &cfg_type_bracketed_aml, 0 },
	{ "notify", &cfg_type_notifytype, 0 },
	{ "notify-source", &cfg_type_sockaddr4wild, 0 },
	{ "notify-source-v6", &cfg_type_sockaddr6wild, 0 },
	{ "also-notify", &cfg_type_portiplist, 0 },
	{ "dialup", &cfg_type_dialuptype, 0 },
	{ "forward", &cfg_type_forwardtype, 0 },
	{ "forwarders", &cfg_type_portiplist, 0 },
	{ "maintain-ixfr-base", &cfg_type_boolean, CFG_CLAUSEFLAG_OBSOLETE },
	{ "max-ixfr-log-size", &cfg_type_size, CFG_CLAUSEFLAG_OBSOLETE },
	{ "transfer-source", &cfg_type_sockaddr4wild, 0 },
	{ "transfer-source-v6", &cfg_type_sockaddr6wild, 0 },
	{ "max-transfer-time-in", &cfg_type_uint32, 0 },
	{ "max-transfer-time-out", &cfg_type_uint32, 0 },
	{ "max-transfer-idle-in", &cfg_type_uint32, 0 },
	{ "max-transfer-idle-out", &cfg_type_uint32, 0 },
	{ "max-retry-time", &cfg_type_uint32, 0 },
	{ "min-retry-time", &cfg_type_uint32, 0 },
	{ "max-refresh-time", &cfg_type_uint32, 0 },
	{ "min-refresh-time", &cfg_type_uint32, 0 },
	{ "sig-validity-interval", &cfg_type_uint32, 0 },
	{ "zone-statistics", &cfg_type_boolean, 0 },
	{ NULL, NULL, 0 }
};

/*
 * Clauses that can be found in a 'zone' statement
 * only.
 */
static cfg_clausedef_t
zone_only_clauses[] = {
	{ "type", &cfg_type_zonetype, 0 },
	{ "allow-update", &cfg_type_bracketed_aml, 0 },
	{ "file", &cfg_type_qstring, 0 },
	{ "ixfr-base", &cfg_type_qstring, CFG_CLAUSEFLAG_OBSOLETE },
	{ "ixfr-tmp-file", &cfg_type_qstring, CFG_CLAUSEFLAG_OBSOLETE },
	{ "masters", &cfg_type_sockaddrkeylist, 0 },
	{ "pubkey", &cfg_type_pubkey,
	  CFG_CLAUSEFLAG_MULTI | CFG_CLAUSEFLAG_OBSOLETE },
	{ "update-policy", &cfg_type_updatepolicy, 0 },
	{ "database", &cfg_type_astring, 0 },
	{ "delegation-only", &cfg_type_boolean, 0 },
	/*
	 * Note that the format of the check-names option is different between
	 * the zone options and the global/view options.  Ugh.
	 */
	{ "check-names", &cfg_type_ustring, CFG_CLAUSEFLAG_NOTIMP },
	{ NULL, NULL, 0 }
};


/* The top-level named.conf syntax. */

static cfg_clausedef_t *
namedconf_clausesets[] = {
	namedconf_clauses,
	namedconf_or_view_clauses,
	NULL
};

LIBISCCFG_EXTERNAL_DATA cfg_type_t cfg_type_namedconf = {
	"namedconf", parse_mapbody, print_mapbody, &cfg_rep_map,
	namedconf_clausesets
};

/* The "options" statement syntax. */

static cfg_clausedef_t *
options_clausesets[] = {
	options_clauses,
	view_clauses,
	zone_clauses,
	NULL
};
static cfg_type_t cfg_type_options = {
	"options", parse_map, print_map, &cfg_rep_map, options_clausesets };

/* The "view" statement syntax. */

static cfg_clausedef_t *
view_clausesets[] = {
	view_only_clauses,
	namedconf_or_view_clauses,
	view_clauses,
	zone_clauses,
	NULL
};
static cfg_type_t cfg_type_viewopts = {
	"view", parse_map, print_map, &cfg_rep_map, view_clausesets };

/* The "zone" statement syntax. */

static cfg_clausedef_t *
zone_clausesets[] = {
	zone_only_clauses,
	zone_clauses,
	NULL
};
static cfg_type_t cfg_type_zoneopts = {
	"zoneopts", parse_map, print_map, &cfg_rep_map, zone_clausesets };

/*
 * Clauses that can be found within the 'key' statement.
 */
static cfg_clausedef_t
key_clauses[] = {
	{ "algorithm", &cfg_type_astring, 0 },
	{ "secret", &cfg_type_astring, 0 },
	{ NULL, NULL, 0 }
};

static cfg_clausedef_t *
key_clausesets[] = {
	key_clauses,
	NULL
};
static cfg_type_t cfg_type_key = {
	"key", parse_named_map, print_map, &cfg_rep_map, key_clausesets };


/*
 * Clauses that can be found in a 'server' statement.
 */
static cfg_clausedef_t
server_clauses[] = {
	{ "bogus", &cfg_type_boolean, 0 },
	{ "provide-ixfr", &cfg_type_boolean, 0 },
	{ "request-ixfr", &cfg_type_boolean, 0 },
	{ "support-ixfr", &cfg_type_boolean, CFG_CLAUSEFLAG_OBSOLETE },
	{ "transfers", &cfg_type_uint32, 0 },
	{ "transfer-format", &cfg_type_transferformat, 0 },
	{ "keys", &cfg_type_server_key_kludge, 0 },
	{ "edns", &cfg_type_boolean, 0 },
	{ NULL, NULL, 0 }
};
static cfg_clausedef_t *
server_clausesets[] = {
	server_clauses,
	NULL
};
static cfg_type_t cfg_type_server = {
	"server", parse_addressed_map, print_map, &cfg_rep_map,
	server_clausesets
};


/*
 * Clauses that can be found in a 'channel' clause in the
 * 'logging' statement.
 *
 * These have some additional constraints that need to be
 * checked after parsing:
 *  - There must exactly one of file/syslog/null/stderr
 *
 */
static cfg_clausedef_t
channel_clauses[] = {
	/* Destinations.  We no longer require these to be first. */
	{ "file", &cfg_type_logfile, 0 },
	{ "syslog", &cfg_type_optional_facility, 0 },
	{ "null", &cfg_type_void, 0 },
	{ "stderr", &cfg_type_void, 0 },
	/* Options.  We now accept these for the null channel, too. */
	{ "severity", &cfg_type_logseverity, 0 },
	{ "print-time", &cfg_type_boolean, 0 },
	{ "print-severity", &cfg_type_boolean, 0 },
	{ "print-category", &cfg_type_boolean, 0 },
	{ NULL, NULL, 0 }
};
static cfg_clausedef_t *
channel_clausesets[] = {
	channel_clauses,
	NULL
};
static cfg_type_t cfg_type_channel = {
	"channel", parse_named_map, print_map,
	&cfg_rep_map, channel_clausesets
};

/* A list of log destination, used in the "category" clause. */
static cfg_type_t cfg_type_destinationlist = {
	"destinationlist", parse_bracketed_list, print_bracketed_list,
	&cfg_rep_list, &cfg_type_astring };

/*
 * Clauses that can be found in a 'logging' statement.
 */
static cfg_clausedef_t
logging_clauses[] = {
	{ "channel", &cfg_type_channel, CFG_CLAUSEFLAG_MULTI },
	{ "category", &cfg_type_category, CFG_CLAUSEFLAG_MULTI },
	{ NULL, NULL, 0 }
};
static cfg_clausedef_t *
logging_clausesets[] = {
	logging_clauses,
	NULL
};
static cfg_type_t cfg_type_logging = {
	"logging", parse_map, print_map, &cfg_rep_map, logging_clausesets };

d136 2
a137 2
static void
print_obj(cfg_printer_t *pctx, cfg_obj_t *obj) {
d141 2
a142 2
static void
print(cfg_printer_t *pctx, const char *text, int len) {
d148 1
a148 1
	print(pctx, "{\n", 2);
d156 1
a156 1
		print(pctx, "\t", 1);
d165 1
a165 1
	print(pctx, "}", 1);
d168 2
a169 2
static isc_result_t
parse(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d194 2
a195 2
static isc_result_t
create_tuple(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d206 1
a206 1
	CHECK(create_cfgobj(pctx, type, &obj));
d224 2
a225 2
static isc_result_t
parse_tuple(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret)
d233 1
a233 1
	CHECK(create_tuple(pctx, type, &obj));
d235 1
a235 1
		CHECK(parse(pctx, f->type, &obj->value.tuple[i]));
d245 2
a246 2
static void
print_tuple(cfg_printer_t *pctx, cfg_obj_t *obj) {
d255 17
a271 3
			print(pctx, " ", 1);
		print_obj(pctx, fieldobj);
		need_space = ISC_TF(fieldobj->type->print != print_void);
d316 2
a317 5
/*
 * Parse a required special character.
 */
static isc_result_t
parse_special(cfg_parser_t *pctx, int special) {
d324 1
a324 1
	parser_error(pctx, LOG_NEAR, "'%c' expected", special);
d345 1
a345 1
	parser_error(pctx, LOG_BEFORE, "missing ';'");
d362 1
a362 1
	parser_error(pctx, LOG_NEAR, "syntax error");
d365 1
a365 1
	return(result);
d371 1
a371 1
	"filelist", NULL, print_list, &cfg_rep_list,
d376 1
a376 2
cfg_parser_create(isc_mem_t *mctx, isc_log_t *lctx, cfg_parser_t **ret)
{
d417 2
a418 2
	CHECK(create_list(pctx, &cfg_type_filelist, &pctx->open_files));
	CHECK(create_list(pctx, &cfg_type_filelist, &pctx->closed_files));
d440 1
a440 1
		parser_error(pctx, 0, "open: %s: %s",
d474 1
a474 1
	result = parse(pctx, type, &obj);
d485 1
a485 1
		parser_error(pctx, 0, "parsing failed");
d544 2
a545 2
static isc_result_t
parse_void(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d547 1
a547 1
	return (create_cfgobj(pctx, &cfg_type_void, ret));
d550 2
a551 2
static void
print_void(cfg_printer_t *pctx, cfg_obj_t *obj) {
d556 6
d568 3
a570 2
static cfg_type_t cfg_type_void = {
	"void", parse_void, print_void, &cfg_rep_void, NULL };
d576 2
a577 2
static isc_result_t
parse_uint32(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d584 1
a584 1
		parser_error(pctx, LOG_NEAR, "expected number");
d588 1
a588 1
	CHECK(create_cfgobj(pctx, &cfg_type_uint32, &obj));
d596 3
a598 3
static void
print_cstr(cfg_printer_t *pctx, const char *s) {
	print(pctx, s, strlen(s));
d601 2
a602 2
static void
print_uint(cfg_printer_t *pctx, unsigned int u) {
d605 1
a605 1
	print_cstr(pctx, buf);
d608 3
a610 3
static void
print_uint32(cfg_printer_t *pctx, cfg_obj_t *obj) {
	print_uint(pctx, obj->value.uint32);
d625 4
a628 2
static cfg_type_t cfg_type_uint32 = {
	"integer", parse_uint32, print_uint32, &cfg_rep_uint32, NULL };
d646 2
a647 41
static isc_result_t
parse_unitstring(char *str, isc_resourcevalue_t *valuep) {
	char *endp;
	unsigned int len;
	isc_uint64_t value;
	isc_uint64_t unit;

	value = isc_string_touint64(str, &endp, 10);
	if (*endp == 0) {
		*valuep = value;
		return (ISC_R_SUCCESS);
	}

	len = strlen(str);
	if (len < 2 || endp[1] != '\0')
		return (ISC_R_FAILURE);

	switch (str[len - 1]) {
	case 'k':
	case 'K':
		unit = 1024;
		break;
	case 'm':
	case 'M':
		unit = 1024 * 1024;
		break;
	case 'g':
	case 'G':
		unit = 1024 * 1024 * 1024;
		break;
	default:
		return (ISC_R_FAILURE);
	}
	if (value > ISC_UINT64_MAX / unit)
		return (ISC_R_FAILURE);
	*valuep = value * unit;
	return (ISC_R_SUCCESS);
}

static void
print_uint64(cfg_printer_t *pctx, cfg_obj_t *obj) {
d651 1
a651 1
	print_cstr(pctx, buf);
d654 3
a656 46
static cfg_type_t cfg_type_uint64 = {
	"64_bit_integer", NULL, print_uint64, &cfg_rep_uint64, NULL };

static isc_result_t
parse_sizeval(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	isc_result_t result;
	cfg_obj_t *obj = NULL;
	isc_uint64_t val;

	UNUSED(type);

	CHECK(cfg_gettoken(pctx, 0));
	if (pctx->token.type != isc_tokentype_string) {
		result = ISC_R_UNEXPECTEDTOKEN;
		goto cleanup;
	}
	CHECK(parse_unitstring(pctx->token.value.as_pointer, &val));

	CHECK(create_cfgobj(pctx, &cfg_type_uint64, &obj));
	obj->value.uint64 = val;
	*ret = obj;
	return (ISC_R_SUCCESS);

 cleanup:
	parser_error(pctx, LOG_NEAR, "expected integer and optional unit");
	return (result);
}

/*
 * A size value (number + optional unit).
 */
static cfg_type_t cfg_type_sizeval = {
	"sizeval", parse_sizeval, print_uint64, &cfg_rep_uint64, NULL };

/*
 * A size, "unlimited", or "default".
 */

static isc_result_t
parse_size(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	return (parse_enum_or_other(pctx, type, &cfg_type_sizeval, ret));
}

static const char *size_enums[] = { "unlimited", "default", NULL };
static cfg_type_t cfg_type_size = {
	"size", parse_size, print_ustring, &cfg_rep_string, size_enums
d660 2
a661 60
 * A size or "unlimited", but not "default".
 */
static const char *sizenodefault_enums[] = { "unlimited", NULL };
static cfg_type_t cfg_type_sizenodefault = {
	"size_no_default", parse_size, print_ustring, &cfg_rep_string,
	sizenodefault_enums
};

/*
 * optional_keyvalue
 */
static isc_result_t
parse_maybe_optional_keyvalue(cfg_parser_t *pctx, const cfg_type_t *type,
			      isc_boolean_t optional, cfg_obj_t **ret)
{
        isc_result_t result;
	cfg_obj_t *obj = NULL;
	const keyword_type_t *kw = type->of;

	CHECK(cfg_peektoken(pctx, 0));
	if (pctx->token.type == isc_tokentype_string &&
	    strcasecmp(pctx->token.value.as_pointer, kw->name) == 0) {
		CHECK(cfg_gettoken(pctx, 0));
		CHECK(kw->type->parse(pctx, kw->type, &obj));
		obj->type = type; /* XXX kludge */
	} else {
		if (optional) {
			CHECK(parse_void(pctx, NULL, &obj));
		} else {
			parser_error(pctx, LOG_NEAR, "expected '%s'",
				     kw->name);
			result = ISC_R_UNEXPECTEDTOKEN;
			goto cleanup;
		}
	}
	*ret = obj;
 cleanup:
	return (result);
}

static isc_result_t
parse_keyvalue(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	return (parse_maybe_optional_keyvalue(pctx, type, ISC_FALSE, ret));
}

static isc_result_t
parse_optional_keyvalue(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	return (parse_maybe_optional_keyvalue(pctx, type, ISC_TRUE, ret));
}

static void
print_keyvalue(cfg_printer_t *pctx, cfg_obj_t *obj) {
	const keyword_type_t *kw = obj->type->of;
	print_cstr(pctx, kw->name);
	print(pctx, " ", 1);
	kw->type->print(pctx, obj);
}

/*
 * qstring, ustring, astring
d673 1
a673 1
	CHECK(create_cfgobj(pctx, type, &obj));
d689 2
a690 2
static isc_result_t
parse_qstring(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d694 1
a694 1
	CHECK(cfg_gettoken(pctx, QSTRING));
d696 1
a696 1
		parser_error(pctx, LOG_NEAR, "expected quoted string");
d700 1
a700 1
			      pctx->token.value.as_pointer,
d714 1
a714 1
		parser_error(pctx, LOG_NEAR, "expected unquoted string");
d718 1
a718 1
			      pctx->token.value.as_pointer,
d725 2
a726 2
static isc_result_t
parse_astring(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d732 1
a732 1
			      pctx->token.value.as_pointer,
d739 2
a740 2
static isc_boolean_t
is_enum(const char *s, const char *const *enums) {
d752 1
a752 1
	if (is_enum(s, enums))
d754 1
a754 1
	parser_error(pctx, 0, "'%s' unexpected", s);
d758 2
a759 2
static isc_result_t
parse_enum(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d767 1
a767 17
	CLEANUP_OBJ(obj);	
	return (result);
}

static isc_result_t
parse_enum_or_other(cfg_parser_t *pctx, const cfg_type_t *enumtype,
		    const cfg_type_t *othertype, cfg_obj_t **ret)
{
        isc_result_t result;
	CHECK(cfg_peektoken(pctx, 0));
	if (pctx->token.type == isc_tokentype_string &&
	    is_enum(pctx->token.value.as_pointer, enumtype->of)) {
		CHECK(parse_enum(pctx, enumtype, ret));
	} else {
		CHECK(parse(pctx, othertype, ret));
	}
 cleanup:
d771 11
d783 3
a785 6
/*
 * Print a string object.
 */
static void
print_ustring(cfg_printer_t *pctx, cfg_obj_t *obj) {
	print(pctx, obj->value.string.base, obj->value.string.length);
d790 3
a792 3
	print(pctx, "\"", 1);
	print_ustring(pctx, obj);
	print(pctx, "\"", 1);
d813 22
a846 16
/* Quoted string only */
static cfg_type_t cfg_type_qstring = {
	"quoted_string", parse_qstring, print_qstring, &cfg_rep_string, NULL };

/* Unquoted string only */
static cfg_type_t cfg_type_ustring = {
	"string", parse_ustring, print_ustring, &cfg_rep_string, NULL };

/* Any string (quoted or unquoted); printed with quotes */
static cfg_type_t cfg_type_astring = {
	"string", parse_astring, print_qstring, &cfg_rep_string, NULL };


/*
 * boolean
 */
d862 3
a864 3
	if ((strcasecmp(pctx->token.value.as_pointer, "true") == 0) ||
	    (strcasecmp(pctx->token.value.as_pointer, "yes") == 0) ||
	    (strcmp(pctx->token.value.as_pointer, "1") == 0)) {
d866 3
a868 3
	} else if ((strcasecmp(pctx->token.value.as_pointer, "false") == 0) ||
		   (strcasecmp(pctx->token.value.as_pointer, "no") == 0) ||
		   (strcmp(pctx->token.value.as_pointer, "0") == 0)) {
d874 1
a874 1
	CHECK(create_cfgobj(pctx, &cfg_type_boolean, &obj));
d880 1
a880 1
	parser_error(pctx, LOG_NEAR, "boolean expected");
d890 1
a890 1
		print(pctx, "yes", 3);
d892 1
a892 1
		print(pctx, "no", 2);
d895 3
a897 34
static cfg_type_t cfg_type_boolean = {
	"boolean", parse_boolean, print_boolean, &cfg_rep_boolean, NULL };

static const char *dialup_enums[] = {
	"notify", "notify-passive", "refresh", "passive", NULL };
static isc_result_t
parse_dialup_type(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	return (parse_enum_or_other(pctx, type, &cfg_type_boolean, ret));
}
static cfg_type_t cfg_type_dialuptype = {
	"dialuptype", parse_dialup_type, print_ustring, 
	&cfg_rep_string, dialup_enums
};

static const char *notify_enums[] = { "explicit", NULL };
static isc_result_t
parse_notify_type(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	return (parse_enum_or_other(pctx, type, &cfg_type_boolean, ret));
}
static cfg_type_t cfg_type_notifytype = {
	"notifytype", parse_notify_type, print_ustring, 
	&cfg_rep_string, notify_enums,
};

static keyword_type_t key_kw = { "key", &cfg_type_astring };

LIBISCCFG_EXTERNAL_DATA cfg_type_t cfg_type_keyref = {
	"keyref", parse_keyvalue, print_keyvalue,
	&cfg_rep_string, &key_kw
};

static cfg_type_t cfg_type_optional_keyref = {
	"optional_keyref", parse_optional_keyvalue, print_keyvalue,
	&cfg_rep_string, &key_kw
a899 1

d904 2
a905 2
static isc_result_t
create_list(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **obj) {
d907 1
a907 1
	CHECK(create_cfgobj(pctx, type, obj));
d943 3
a945 3
static isc_result_t
parse_list_elt(cfg_parser_t *pctx, const cfg_type_t *elttype,
	       cfg_listelt_t **ret)
d953 1
a953 1
	result = parse(pctx, elttype, &value);
d979 1
a979 1
	CHECK(create_list(pctx, listtype, &listobj));
d986 1
a986 1
		CHECK(parse_list_elt(pctx, listof, &elt));
d1010 2
a1011 2
		print_obj(pctx, elt->obj);
		print(pctx, ";\n", 2);
d1015 3
a1017 2
static isc_result_t
parse_bracketed_list(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret)
d1020 1
a1020 1
	CHECK(parse_special(pctx, '{'));
d1022 1
a1022 1
	CHECK(parse_special(pctx, '}'));
d1027 2
a1028 2
static void
print_bracketed_list(cfg_printer_t *pctx, cfg_obj_t *obj) {
d1034 7
d1046 3
a1048 2
static isc_result_t
parse_spacelist(cfg_parser_t *pctx, const cfg_type_t *listtype, cfg_obj_t **ret)
d1054 1
a1054 1
	CHECK(create_list(pctx, listtype, &listobj));
d1063 1
a1063 1
		CHECK(parse_list_elt(pctx, listof, &elt));
d1074 2
a1075 2
static void
print_spacelist(cfg_printer_t *pctx, cfg_obj_t *obj) {
d1082 1
a1082 1
		print_obj(pctx, elt->obj);
d1084 1
a1084 1
			print(pctx, " ", 1);
d1088 1
d1129 2
a1130 2
static isc_result_t
parse_mapbody(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret)
d1165 1
a1165 1
		if (strcasecmp(pctx->token.value.as_pointer, "include") == 0) {
d1171 1
a1171 1
			CHECK(parse(pctx, &cfg_type_qstring, &includename));
d1184 1
a1184 1
				if (strcasecmp(pctx->token.value.as_pointer,
d1191 1
a1191 1
			parser_error(pctx, LOG_NOPREP, "unknown option");
d1196 4
a1199 4
			 CHECK(parse(pctx, &cfg_type_unsupported, &eltobj));
			 cfg_obj_destroy(pctx, &eltobj);
			 CHECK(parse_semicolon(pctx));
			 continue;
d1206 1
a1206 1
			parser_warning(pctx, 0, "option '%s' is obsolete",
d1209 1
a1209 1
			parser_warning(pctx, 0, "option '%s' is "
d1212 1
a1212 1
			parser_warning(pctx, 0, "option '%s' is "
d1228 1
a1228 1
				CHECK(create_list(pctx,
d1238 1
a1238 1
					parser_error(pctx, LOG_NEAR,
d1251 1
a1251 1
			CHECK(parse_list_elt(pctx, clause->type, &elt));
d1267 1
a1267 1
				parser_error(pctx, LOG_NEAR, "'%s' redefined",
d1272 1
a1272 1
				parser_error(pctx, LOG_NEAR,
d1300 1
a1300 1
	CHECK(parse(pctx, elttype, &obj));
d1319 2
a1320 3
static isc_result_t
parse_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret)
{
d1322 3
a1324 3
	CHECK(parse_special(pctx, '{'));
	CHECK(parse_mapbody(pctx, type, ret));
	CHECK(parse_special(pctx, '}'));
d1330 1
a1330 1
 * Subroutine for parse_named_map() and parse_addressed_map().
d1340 2
a1341 2
	CHECK(parse(pctx, nametype, &idobj));
	CHECK(parse_map(pctx, type, &mapobj));
d1354 2
a1355 2
static isc_result_t
parse_named_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d1363 2
a1364 2
static isc_result_t
parse_addressed_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d1368 2
a1369 2
static void
print_mapbody(cfg_printer_t *pctx, cfg_obj_t *obj) {
d1396 4
a1399 4
						print_cstr(pctx, clause->name);
						print(pctx, " ", 1);
						print_obj(pctx, elt->obj);
						print(pctx, ";\n", 2);
d1404 4
a1407 4
					print_cstr(pctx, clause->name);
					print(pctx, " ", 1);
					print_obj(pctx, obj);
					print(pctx, ";\n", 2);
d1418 41
d1460 26
a1485 4
print_map(cfg_printer_t *pctx, cfg_obj_t *obj) {
	if (obj->value.map.id != NULL) {
		print_obj(pctx, obj->value.map.id);
		print(pctx, " ", 1);
d1487 1
d1489 15
a1503 1
	print_mapbody(pctx, obj);
d1548 2
a1549 2
	CHECK(create_cfgobj(pctx, &cfg_type_token, &obj));
	CHECK(cfg_gettoken(pctx, QSTRING));
d1568 4
a1571 2
static cfg_type_t cfg_type_token = {
	"token", parse_token, print_ustring, &cfg_rep_string, NULL };
d1584 1
a1584 1
	CHECK(create_list(pctx, type, &listobj));
d1600 1
a1600 1
			parser_error(pctx, LOG_NEAR, "unexpected token");
d1605 1
a1605 1
		CHECK(parse_list_elt(pctx, &cfg_type_token, &elt));
d1617 2
a1618 2
static cfg_type_t cfg_type_unsupported = {
	"unsupported", parse_unsupported, print_spacelist,
a1622 67
 * A "controls" statement is represented as a map with the multivalued
 * "inet" and "unix" clauses.  Inet controls are tuples; unix controls
 * are cfg_unsupported_t objects.
 */

static keyword_type_t controls_allow_kw = {
	"allow", &cfg_type_bracketed_aml };
static cfg_type_t cfg_type_controls_allow = {
	"controls_allow", parse_keyvalue,
	print_keyvalue, &cfg_rep_list, &controls_allow_kw
};

static keyword_type_t controls_keys_kw = {
	"keys", &cfg_type_keylist };
static cfg_type_t cfg_type_controls_keys = {
	"controls_keys", parse_optional_keyvalue,
	print_keyvalue, &cfg_rep_list, &controls_keys_kw
};

static cfg_tuplefielddef_t inetcontrol_fields[] = {
	{ "address", &cfg_type_controls_sockaddr, 0 },
	{ "allow", &cfg_type_controls_allow, 0 },
	{ "keys", &cfg_type_controls_keys, 0 },
	{ NULL, NULL, 0 }
};
static cfg_type_t cfg_type_inetcontrol = {
	"inetcontrol", parse_tuple, print_tuple, &cfg_rep_tuple,
	inetcontrol_fields
};

static cfg_clausedef_t
controls_clauses[] = {
	{ "inet", &cfg_type_inetcontrol, CFG_CLAUSEFLAG_MULTI },
	{ "unix", &cfg_type_unsupported,
	  CFG_CLAUSEFLAG_MULTI|CFG_CLAUSEFLAG_NOTIMP },
	{ NULL, NULL, 0 }
};
static cfg_clausedef_t *
controls_clausesets[] = {
	controls_clauses,
	NULL
};
static cfg_type_t cfg_type_controls = {
	"controls", parse_map, print_map, &cfg_rep_map,	&controls_clausesets
};

/*
 * An optional class, as used in view and zone statements.
 */
static isc_result_t
parse_optional_class(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	isc_result_t result;
	UNUSED(type);
	CHECK(cfg_peektoken(pctx, 0));
	if (pctx->token.type == isc_tokentype_string)
		CHECK(parse(pctx, &cfg_type_ustring, ret));
	else
		CHECK(parse(pctx, &cfg_type_void, ret));
 cleanup:
	return (result);
}

static cfg_type_t cfg_type_optional_class = {
	"optional_class", parse_optional_class, NULL, NULL, NULL };


/*
d1625 4
a1628 4
 * If WILDOK is set in flags, "*" can be used as a wildcard
 * and at least one of V4OK and V6OK must also be set.  The
 * "*" is interpreted as the IPv4 wildcard address if V4OK is 
 * set (including the case where V4OK and V6OK are both set),
d1640 3
a1642 3
	s = pctx->token.value.as_pointer;
	if ((flags & WILDOK) != 0 && strcmp(s, "*") == 0) {
		if ((flags & V4OK) != 0) {
d1645 1
a1645 1
		} else if ((flags & V6OK) != 0) {
d1652 1
a1652 1
		if ((flags & (V4OK | V4PREFIXOK)) != 0) {
d1658 1
a1658 1
		if ((flags & V4PREFIXOK) != 0 &&
d1672 27
a1698 2
		if (flags & V6OK) {
			if (inet_pton(AF_INET6, s, &in6a) == 1) {
d1700 1
d1708 2
a1709 2
static isc_result_t
get_addr(cfg_parser_t *pctx, unsigned int flags, isc_netaddr_t *na) {
d1714 1
a1714 1
		parser_error(pctx, LOG_NEAR, "expected IP address");
d1719 2
a1720 2
static isc_boolean_t
looking_at_netaddr(cfg_parser_t *pctx, unsigned int flags) {
d1727 2
a1728 2
static isc_result_t
get_port(cfg_parser_t *pctx, unsigned int flags, in_port_t *port) {
d1733 1
a1733 1
	if ((flags & WILDOK) != 0 &&
d1735 1
a1735 1
	    strcmp(pctx->token.value.as_pointer, "*") == 0) {
d1740 1
a1740 1
		parser_error(pctx, LOG_NEAR,
d1745 1
a1745 1
		parser_error(pctx, LOG_NEAR,
d1755 2
a1756 74
static isc_result_t
parse_querysource(cfg_parser_t *pctx, int flags, cfg_obj_t **ret) {
	isc_result_t result;
	cfg_obj_t *obj = NULL;
	isc_netaddr_t netaddr;
	in_port_t port;
	unsigned int have_address = 0;
	unsigned int have_port = 0;

	if ((flags & V4OK) != 0)
		isc_netaddr_any(&netaddr);
	else if ((flags & V6OK) != 0)
		isc_netaddr_any6(&netaddr);
	else
		INSIST(0);

	port = 0;

	CHECK(create_cfgobj(pctx, &cfg_type_querysource, &obj));
	for (;;) {
		CHECK(cfg_peektoken(pctx, 0));
		if (pctx->token.type == isc_tokentype_string) {
			if (strcasecmp(pctx->token.value.as_pointer,
				       "address") == 0)
			{
				/* read "address" */
				CHECK(cfg_gettoken(pctx, 0)); 
				CHECK(get_addr(pctx, flags|WILDOK, &netaddr));
				have_address++;
			} else if (strcasecmp(pctx->token.value.as_pointer,
					      "port") == 0)
			{
				/* read "port" */
				CHECK(cfg_gettoken(pctx, 0)); 
				CHECK(get_port(pctx, WILDOK, &port));
				have_port++;
			} else {
				parser_error(pctx, LOG_NEAR,
					     "expected 'address' or 'port'");
				return (ISC_R_UNEXPECTEDTOKEN);
			}
		} else
			break;
	}
	if (have_address > 1 || have_port > 1 ||
	    have_address + have_port == 0) {
		parser_error(pctx, 0, "expected one address and/or port");
		return (ISC_R_UNEXPECTEDTOKEN);
	}

	isc_sockaddr_fromnetaddr(&obj->value.sockaddr, &netaddr, port);
	*ret = obj;
	return (ISC_R_SUCCESS);

 cleanup:
	parser_error(pctx, LOG_NEAR, "invalid query source");
	CLEANUP_OBJ(obj);
	return (result);
}

static isc_result_t
parse_querysource4(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	UNUSED(type);
	return (parse_querysource(pctx, V4OK, ret));
}

static isc_result_t
parse_querysource6(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	UNUSED(type);
	return (parse_querysource(pctx, V6OK, ret));
}

static void
print_isc_netaddr(cfg_printer_t *pctx, isc_netaddr_t *na) {
d1764 1
a1764 1
	print(pctx, isc_buffer_base(&buf), isc_buffer_usedlength(&buf));
a1766 17
static void
print_querysource(cfg_printer_t *pctx, cfg_obj_t *obj) {
	isc_netaddr_t na;
	isc_netaddr_fromsockaddr(&na, &obj->value.sockaddr);
	print(pctx, "address ", 8);
	print_isc_netaddr(pctx, &na);
	print(pctx, " port ", 6);
	print_uint(pctx, isc_sockaddr_getport(&obj->value.sockaddr));
}

static cfg_type_t cfg_type_querysource4 = {
	"querysource4", parse_querysource4, NULL, NULL, NULL };
static cfg_type_t cfg_type_querysource6 = {
	"querysource6", parse_querysource6, NULL, NULL, NULL };
static cfg_type_t cfg_type_querysource = {
	"querysource", NULL, print_querysource, &cfg_rep_sockaddr, NULL };

d1775 2
a1776 2
	CHECK(create_cfgobj(pctx, type, &obj));
	CHECK(get_addr(pctx, V4OK|V6OK, &netaddr));
d1785 4
a1788 2
static cfg_type_t cfg_type_netaddr = {
	"netaddr", parse_netaddr, print_sockaddr, &cfg_rep_sockaddr, NULL };
d1792 4
a1795 2
static isc_result_t
parse_netprefix(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d1802 2
a1803 1
	CHECK(get_addr(pctx, V4OK|V4PREFIXOK|V6OK, &netaddr));
d1822 1
a1822 1
			parser_error(pctx, LOG_NEAR,
d1828 1
a1828 1
			parser_error(pctx, LOG_NOPREP,
d1835 5
a1839 72
	CHECK(create_cfgobj(pctx, &cfg_type_netprefix, &obj));
	obj->value.netprefix.address = netaddr;
	obj->value.netprefix.prefixlen = prefixlen;
	*ret = obj;
	return (ISC_R_SUCCESS);
 cleanup:
	parser_error(pctx, LOG_NEAR, "expected network prefix");
	return (result);
}

static void
print_netprefix(cfg_printer_t *pctx, cfg_obj_t *obj) {
	cfg_netprefix_t *p = &obj->value.netprefix;
	print_isc_netaddr(pctx, &p->address);
	print(pctx, "/", 1);
	print_uint(pctx, p->prefixlen);
}

isc_boolean_t
cfg_obj_isnetprefix(cfg_obj_t *obj) {
	REQUIRE(obj != NULL);
	return (ISC_TF(obj->type->rep == &cfg_rep_netprefix));
}

void
cfg_obj_asnetprefix(cfg_obj_t *obj, isc_netaddr_t *netaddr,
		    unsigned int *prefixlen) {
	REQUIRE(obj != NULL && obj->type->rep == &cfg_rep_netprefix);
	*netaddr = obj->value.netprefix.address;
	*prefixlen = obj->value.netprefix.prefixlen;
}

static cfg_type_t cfg_type_netprefix = {
	"netprefix", parse_netprefix, print_netprefix, &cfg_rep_netprefix, NULL };

/* addrmatchelt */

static isc_result_t
parse_addrmatchelt(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
        isc_result_t result;
	UNUSED(type);

	CHECK(cfg_peektoken(pctx, QSTRING));

	if (pctx->token.type == isc_tokentype_string ||
	    pctx->token.type == isc_tokentype_qstring) {
		if (pctx->token.type == isc_tokentype_string &&
		    (strcasecmp(pctx->token.value.as_pointer, "key") == 0)) {
			CHECK(parse(pctx, &cfg_type_keyref, ret));
		} else {
			if (looking_at_netaddr(pctx, V4OK|V4PREFIXOK|V6OK)) {
				CHECK(parse_netprefix(pctx, NULL, ret));
			} else {
				CHECK(parse_astring(pctx, NULL, ret));
			}
		}
	} else if (pctx->token.type == isc_tokentype_special) {
		if (pctx->token.value.as_char == '{') {
			/* Nested match list. */
			CHECK(parse(pctx, &cfg_type_bracketed_aml, ret));
		} else if (pctx->token.value.as_char == '!') {
			CHECK(cfg_gettoken(pctx, 0)); /* read "!" */
			CHECK(parse(pctx, &cfg_type_negated, ret));
		} else {
			goto bad;
		}
	} else {
	bad:
		parser_error(pctx, LOG_NEAR,
			     "expected IP match list element");
		return (ISC_R_UNEXPECTEDTOKEN);
	}
d1841 1
a1844 11
/*
 * A negated address match list element (like "! 10.0.0.1").
 * Somewhat sneakily, the caller is expected to parse the
 * "!", but not to print it.
 */

static cfg_tuplefielddef_t negated_fields[] = {
	{ "value", &cfg_type_addrmatchelt, 0 },
	{ NULL, NULL, 0 }
};

d1846 5
a1850 3
print_negated(cfg_printer_t *pctx, cfg_obj_t *obj) {
	print(pctx, "!", 1);
	print_tuple(pctx, obj);
d1853 5
a1857 4
static cfg_type_t cfg_type_negated = {
	"negated", parse_tuple, print_negated, &cfg_rep_tuple,
	&negated_fields
};
d1859 7
a1865 1
/* an address match list element */
d1867 3
a1869 5
static cfg_type_t cfg_type_addrmatchelt = {
	"address_match_element", parse_addrmatchelt, NULL, NULL, NULL };
static cfg_type_t cfg_type_bracketed_aml = {
	"bracketed_aml", parse_bracketed_list, print_bracketed_list,
	&cfg_rep_list, &cfg_type_addrmatchelt
d1881 2
a1882 2
	CHECK(create_cfgobj(pctx, type, &obj));
	CHECK(get_addr(pctx, flags, &netaddr));
d1885 1
a1885 1
	    strcasecmp(pctx->token.value.as_pointer, "port") == 0) {
d1887 1
a1887 1
		CHECK(get_port(pctx, flags, &port));
d1898 8
a1905 2
static isc_result_t
parse_sockaddr(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d1907 1
a1907 1
	return (parse_sockaddrsub(pctx, &cfg_type_sockaddr4wild, *flagp, ret));
d1910 2
a1911 2
static void
print_sockaddr(cfg_printer_t *pctx, cfg_obj_t *obj) {
d1918 1
a1918 1
	print_cstr(pctx, buf);
d1921 33
a1953 2
		print(pctx, " port ", 6);
		print_uint(pctx, port);
d1969 1
a1969 338
/* An IPv4/IPv6 address with optional port, "*" accepted as wildcard. */
static unsigned int sockaddr4wild_flags = WILDOK|V4OK;
static cfg_type_t cfg_type_sockaddr4wild = {
	"sockaddr4wild", parse_sockaddr, print_sockaddr,
	&cfg_rep_sockaddr, &sockaddr4wild_flags
};

static unsigned int sockaddr6wild_flags = WILDOK|V6OK;
static cfg_type_t cfg_type_sockaddr6wild = {
	"v6addrportwild", parse_sockaddr, print_sockaddr,
	&cfg_rep_sockaddr, &sockaddr6wild_flags
};

static unsigned int sockaddr_flags = V4OK|V6OK;
static cfg_type_t cfg_type_sockaddr = {
	"sockaddr", parse_sockaddr, print_sockaddr,
	&cfg_rep_sockaddr, &sockaddr_flags
};

/*
 * The socket address syntax in the "controls" statement is silly.
 * It allows both socket address families, but also allows "*",
 * whis is gratuitously interpreted as the IPv4 wildcard address.
 */
static unsigned int controls_sockaddr_flags = V4OK|V6OK|WILDOK;
static cfg_type_t cfg_type_controls_sockaddr = {
	"controls_sockaddr", parse_sockaddr, print_sockaddr,
	&cfg_rep_sockaddr, &controls_sockaddr_flags };


/*
 * Handle the special kludge syntax of the "keys" clause in the "server"
 * statement, which takes a single key with our without braces and semicolon.
 */
static isc_result_t
parse_server_key_kludge(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret)
{
	isc_result_t result;
	isc_boolean_t braces = ISC_FALSE;
	UNUSED(type);

	/* Allow opening brace. */
	CHECK(cfg_peektoken(pctx, 0));
	if (pctx->token.type == isc_tokentype_special &&
	    pctx->token.value.as_char == '{') {
		result = cfg_gettoken(pctx, 0);
		braces = ISC_TRUE;
	}

	CHECK(parse(pctx, &cfg_type_astring, ret));

	if (braces) {
		/* Skip semicolon if present. */
		CHECK(cfg_peektoken(pctx, 0));
		if (pctx->token.type == isc_tokentype_special &&
		    pctx->token.value.as_char == ';')
			CHECK(cfg_gettoken(pctx, 0));

		CHECK(parse_special(pctx, '}'));
	}
 cleanup:
	return (result);
}
static cfg_type_t cfg_type_server_key_kludge = {
	"server_key", parse_server_key_kludge, NULL, NULL, NULL };


/*
 * An optional logging facility.
 */

static isc_result_t
parse_optional_facility(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret)
{
	isc_result_t result;
	UNUSED(type);

	CHECK(cfg_peektoken(pctx, QSTRING));
	if (pctx->token.type == isc_tokentype_string ||
	    pctx->token.type == isc_tokentype_qstring) {
		CHECK(parse(pctx, &cfg_type_astring, ret));
	} else {
		CHECK(parse(pctx, &cfg_type_void, ret));
	}
 cleanup:
	return (result);
}

static cfg_type_t cfg_type_optional_facility = {
	"optional_facility", parse_optional_facility, NULL, NULL, NULL };


/*
 * A log severity.  Return as a string, except "debug N",
 * which is returned as a keyword object.
 */

static keyword_type_t debug_kw = { "debug", &cfg_type_uint32 };
static cfg_type_t cfg_type_debuglevel = {
	"debuglevel", parse_keyvalue,
	print_keyvalue, &cfg_rep_uint32, &debug_kw
};

static isc_result_t
parse_logseverity(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	isc_result_t result;
	UNUSED(type);

	CHECK(cfg_peektoken(pctx, 0));
	if (pctx->token.type == isc_tokentype_string &&
	    strcasecmp(pctx->token.value.as_pointer, "debug") == 0) {
		CHECK(cfg_gettoken(pctx, 0)); /* read "debug" */
		CHECK(cfg_peektoken(pctx, ISC_LEXOPT_NUMBER));
		if (pctx->token.type == isc_tokentype_number) {
			CHECK(parse_uint32(pctx, NULL, ret));
		} else {
			/*
			 * The debug level is optional and defaults to 1.
			 * This makes little sense, but we support it for
			 * compatibility with BIND 8.
			 */
			CHECK(create_cfgobj(pctx, &cfg_type_uint32, ret));
			(*ret)->value.uint32 = 1;
		}
		(*ret)->type = &cfg_type_debuglevel; /* XXX kludge */
	} else {
		CHECK(parse(pctx, &cfg_type_loglevel, ret));
	}
 cleanup:
	return (result);
}

static cfg_type_t cfg_type_logseverity = {
	"logseverity", parse_logseverity, NULL, NULL, NULL };

/*
 * The "file" clause of the "channel" statement.
 * This is yet another special case.
 */

static const char *logversions_enums[] = { "unlimited", NULL };
static isc_result_t
parse_logversions(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	return (parse_enum_or_other(pctx, type, &cfg_type_uint32, ret));
}
static cfg_type_t cfg_type_logversions = {
	"logversions", parse_logversions, print_ustring, 
	&cfg_rep_string, logversions_enums
};

static cfg_tuplefielddef_t logfile_fields[] = {
	{ "file", &cfg_type_qstring, 0 },
	{ "versions", &cfg_type_logversions, 0 },
	{ "size", &cfg_type_size, 0 },
	{ NULL, NULL, 0 }
};

static isc_result_t
parse_logfile(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	isc_result_t result;
	cfg_obj_t *obj = NULL;
	const cfg_tuplefielddef_t *fields = type->of;	

	CHECK(create_tuple(pctx, type, &obj));	

	/* Parse the mandatory "file" field */
	CHECK(parse(pctx, fields[0].type, &obj->value.tuple[0]));

	/* Parse "versions" and "size" fields in any order. */
	for (;;) {
		CHECK(cfg_peektoken(pctx, 0));
		if (pctx->token.type == isc_tokentype_string) {
			CHECK(cfg_gettoken(pctx, 0));		
			if (strcasecmp(pctx->token.value.as_pointer,
				       "versions") == 0 &&
			    obj->value.tuple[1] == NULL) {
				CHECK(parse(pctx, fields[1].type,
					    &obj->value.tuple[1]));
			} else if (strcasecmp(pctx->token.value.as_pointer,
					      "size") == 0 &&
				   obj->value.tuple[2] == NULL) {
				CHECK(parse(pctx, fields[2].type,
					    &obj->value.tuple[2]));
			} else {
				break;
			}
		} else {
			break;
		}
	}

	/* Create void objects for missing optional values. */
	if (obj->value.tuple[1] == NULL)
		CHECK(parse_void(pctx, NULL, &obj->value.tuple[1]));
	if (obj->value.tuple[2] == NULL)
		CHECK(parse_void(pctx, NULL, &obj->value.tuple[2]));

	*ret = obj;
	return (ISC_R_SUCCESS);

 cleanup:
	CLEANUP_OBJ(obj);	
	return (result);
}

static void
print_logfile(cfg_printer_t *pctx, cfg_obj_t *obj) {
	print_obj(pctx, obj->value.tuple[0]); /* file */
	if (obj->value.tuple[1]->type->print != print_void) {
		print(pctx, " versions ", 10);
		print_obj(pctx, obj->value.tuple[1]);
	}
	if (obj->value.tuple[2]->type->print != print_void) {
		print(pctx, " size ", 6);
		print_obj(pctx, obj->value.tuple[2]);
	}
}

static cfg_type_t cfg_type_logfile = {
	"logfile", parse_logfile, print_logfile, &cfg_rep_tuple,
	logfile_fields
};


/*
 * lwres
 */

static cfg_tuplefielddef_t lwres_view_fields[] = {
	{ "name", &cfg_type_astring, 0 },
	{ "class", &cfg_type_optional_class, 0 },
	{ NULL, NULL, 0 }
};
static cfg_type_t cfg_type_lwres_view = {
	"lwres_view", parse_tuple, print_tuple, &cfg_rep_tuple,
	lwres_view_fields
};

static cfg_type_t cfg_type_lwres_searchlist = {
	"lwres_searchlist", parse_bracketed_list, print_bracketed_list,
	&cfg_rep_list, &cfg_type_astring };

static cfg_clausedef_t
lwres_clauses[] = {
	{ "listen-on", &cfg_type_portiplist, 0 },
	{ "view", &cfg_type_lwres_view, 0 },
	{ "search", &cfg_type_lwres_searchlist, 0 },
	{ "ndots", &cfg_type_uint32, 0 },
	{ NULL, NULL, 0 }
};

static cfg_clausedef_t *
lwres_clausesets[] = {
	lwres_clauses,
	NULL
};
static cfg_type_t cfg_type_lwres = {
	"lwres", parse_map, print_map, &cfg_rep_map, lwres_clausesets };

/*
 * rndc
 */

static cfg_clausedef_t
rndcconf_options_clauses[] = {
	{ "default-server", &cfg_type_astring, 0 },
	{ "default-key", &cfg_type_astring, 0 },
	{ "default-port", &cfg_type_uint32, 0 },
	{ NULL, NULL, 0 }
};

static cfg_clausedef_t *
rndcconf_options_clausesets[] = {
	rndcconf_options_clauses,
	NULL
};

static cfg_type_t cfg_type_rndcconf_options = {
	"rndcconf_options", parse_map, print_map, &cfg_rep_map,
	rndcconf_options_clausesets
};

static cfg_clausedef_t
rndcconf_server_clauses[] = {
	{ "key", &cfg_type_astring, 0 },
	{ "port", &cfg_type_uint32, 0 },
	{ NULL, NULL, 0 }
};

static cfg_clausedef_t *
rndcconf_server_clausesets[] = {
	rndcconf_server_clauses,
	NULL
};

static cfg_type_t cfg_type_rndcconf_server = {
	"rndcconf_server", parse_named_map, print_map, &cfg_rep_map,
	rndcconf_server_clausesets
};

static cfg_clausedef_t
rndcconf_clauses[] = {
	{ "key", &cfg_type_key, CFG_CLAUSEFLAG_MULTI },
	{ "server", &cfg_type_rndcconf_server, CFG_CLAUSEFLAG_MULTI },
	{ "options", &cfg_type_rndcconf_options, 0 },
	{ NULL, NULL, 0 }
};

static cfg_clausedef_t *
rndcconf_clausesets[] = {
	rndcconf_clauses,
	NULL
};

LIBISCCFG_EXTERNAL_DATA cfg_type_t cfg_type_rndcconf = {
	"rndcconf", parse_mapbody, print_mapbody, &cfg_rep_map,
	rndcconf_clausesets
};

static cfg_clausedef_t
rndckey_clauses[] = {
	{ "key", &cfg_type_key, 0 },
	{ NULL, NULL, 0 }
};

static cfg_clausedef_t *
rndckey_clausesets[] = {
	rndckey_clauses,
	NULL
};

LIBISCCFG_EXTERNAL_DATA cfg_type_t cfg_type_rndckey = {
	"rndckey", parse_mapbody, print_mapbody, &cfg_rep_map,
	rndckey_clausesets
};


static isc_result_t
d2011 1
a2011 1
		parser_error(pctx, LOG_NEAR, "token too big");
d2015 1
a2015 1
		parser_error(pctx, 0, "%s",
d2020 2
a2021 2
		parser_error(pctx, LOG_NEAR, "%s",
			     isc_result_totext(result));
d2027 1
a2027 1
static void
d2035 1
a2035 1
static isc_result_t
d2052 1
a2052 1
	result = cfg_gettoken(pctx, QSTRING);
d2058 1
a2058 1
		parser_error(pctx, LOG_NEAR, "expected string");
d2064 2
a2065 2
static void
parser_error(cfg_parser_t *pctx, unsigned int flags, const char *fmt, ...) {
d2073 2
a2074 2
static void
parser_warning(cfg_parser_t *pctx, unsigned int flags, const char *fmt, ...) {
d2124 1
a2124 1
	if ((flags & (LOG_NEAR|LOG_BEFORE|LOG_NOPREP)) != 0) {
d2147 1
a2147 1
		if (flags & LOG_NEAR)
d2149 1
a2149 1
		else if (flags & LOG_BEFORE)
d2178 12
a2189 2
static isc_result_t
create_cfgobj(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d2222 1
a2222 1
	CHECK(create_cfgobj(pctx, type, &obj));
d2267 3
a2269 28
/*
 * Data and functions for printing grammar summaries.
 */
static struct flagtext {
	unsigned int flag;
	const char *text;
} flagtexts[] = {
	{ CFG_CLAUSEFLAG_NOTIMP, "not implemented" },
	{ CFG_CLAUSEFLAG_NYI, "not yet implemented" },
	{ CFG_CLAUSEFLAG_OBSOLETE, "obsolete" },
	{ CFG_CLAUSEFLAG_NEWDEFAULT, "default changed" },
	{ 0, NULL }
};

static void
print_clause_flags(cfg_printer_t *pctx, unsigned int flags) {
	struct flagtext *p;
	isc_boolean_t first = ISC_TRUE;
	for (p = flagtexts; p->flag != 0; p++) {
		if ((flags & p->flag) != 0) {
			if (first)
				print(pctx, " // ", 4);
			else
				print(pctx, ", ", 2);
			print_cstr(pctx, p->text);
			first = ISC_FALSE;
		}
	}
d2272 5
a2276 115
static void
print_grammar(cfg_printer_t *pctx, const cfg_type_t *type) {
	if (type->print == print_mapbody) {
		const cfg_clausedef_t * const *clauseset;
		const cfg_clausedef_t *clause;

		for (clauseset = type->of; *clauseset != NULL; clauseset++) {
			for (clause = *clauseset;
			     clause->name != NULL;
		     clause++) {
				print_cstr(pctx, clause->name);
				print(pctx, " ", 1);
				print_grammar(pctx, clause->type);
				print(pctx, ";", 1);
				/* XXX print flags here? */
				print(pctx, "\n\n", 2);
			}
		}
	} else if (type->print == print_map) {
		const cfg_clausedef_t * const *clauseset;
		const cfg_clausedef_t *clause;

		if (type->parse == parse_named_map) {
			print_grammar(pctx, &cfg_type_astring);
			print(pctx, " ", 1);
		}
		
		print_open(pctx);

		for (clauseset = type->of; *clauseset != NULL; clauseset++) {
			for (clause = *clauseset;
			     clause->name != NULL;
			     clause++) {
				print_indent(pctx);
				print_cstr(pctx, clause->name);
				if (clause->type->print != print_void)
					print(pctx, " ", 1);
				print_grammar(pctx, clause->type);
				print(pctx, ";", 1);
				print_clause_flags(pctx, clause->flags);
				print(pctx, "\n", 1);
			}
		}
		print_close(pctx);
	} else if (type->print == print_tuple) {
		const cfg_tuplefielddef_t *fields = type->of;
		const cfg_tuplefielddef_t *f;
		isc_boolean_t need_space = ISC_FALSE;

		for (f = fields; f->name != NULL; f++) {
			if (need_space)
				print(pctx, " ", 1);
			print_grammar(pctx, f->type);
			need_space = ISC_TF(f->type->print != print_void);
		}
	} else if (type->parse == parse_enum) {
		const char * const *p;
		print(pctx, "( ", 2);
		for (p = type->of; *p != NULL; p++) {
			print_cstr(pctx, *p);
			if (p[1] != NULL)
				print(pctx, " | ", 3);
		}
		print(pctx, " )", 2);
	} else if (type->print == print_bracketed_list) {
		print(pctx, "{ ", 2);
		print_grammar(pctx, type->of);
		print(pctx, "; ... }", 7);
	} else if (type->parse == parse_keyvalue) {
		const keyword_type_t *kw = type->of;
		print_cstr(pctx, kw->name);
		print(pctx, " ", 1);
		print_grammar(pctx, kw->type);
	} else if (type->parse == parse_optional_keyvalue) {
		const keyword_type_t *kw = type->of;
		print(pctx, "[ ", 2);
		print_cstr(pctx, kw->name);
		print(pctx, " ", 1);
		print_grammar(pctx, kw->type);
		print(pctx, " ]", 2);
	} else if (type->parse == parse_sockaddr) {
		const unsigned int *flagp = type->of;
		int n = 0;
		print(pctx, "( ", 2);
		if (*flagp & V4OK) {
			if (n != 0)
				print(pctx, " | ", 3);
			print_cstr(pctx, "<ipv4_address>");
			n++;
		}
		if (*flagp & V6OK) {
			if (n != 0)
				print(pctx, " | ", 3);
			print_cstr(pctx, "<ipv6_address>");
			n++;			
		}
		if (*flagp & WILDOK) {
			if (n != 0)
				print(pctx, " | ", 3);
			print(pctx, "*", 1);
			n++;
		}
		print(pctx, " ) ", 3);
		if (*flagp & WILDOK) {
			print_cstr(pctx, "[ port ( <integer> | * ) ]");
		} else {
			print_cstr(pctx, "[ port <integer> ]");
		}
	} else if (type->print == print_void) {
		/* Print nothing. */
	} else {
		print(pctx, "<", 1);
		print_cstr(pctx, type->name);
		print(pctx, ">", 1);
	}
d2288 1
a2288 1
	print_grammar(&pctx, type);
@


1.7
log
@64-bit fix; ok/idea jakob
@
text
@d1667 1
a1667 1
		 (isc_uint64_t)obj->value.uint64);
@


1.6
log
@update to BIND v9.2.3. ok todd@@
@
text
@d1667 1
a1667 1
		 obj->value.uint64);
@


1.5
log
@sync with 9.2.2-P3; new zone type "delegation-only"
discussed with deraadt@@, millert@@ and todd@@
@
text
@d18 1
a18 1
/* $ISC: parser.c,v 1.70.2.14.4.2 2003/02/17 07:05:10 marka Exp $ */
d858 11
d905 1
d1216 2
a1217 1
	CLEANUP_OBJ(obj);
d1683 4
d1796 1
a1796 1
		CLEANUP_OBJ(obj);
d2129 1
a2133 2
		cfg_listelt_t *elt = NULL;

d2136 1
a2136 1
		    pctx->token.value.as_char == '}')
d2141 1
d2147 2
a2450 1
	obj = NULL;
d2789 1
a2789 1
		    strlen(s) <= 15) {
d2848 1
a2848 1
	if (pctx->token.value.as_ulong >= 65536) {
d3782 2
a3783 1
	CLEANUP_OBJ(obj);
@


1.4
log
@replace strcpy with strlcpy and some strdup.
ok rohee@@ tdeval@@ dhartmei@@
requested by deraadt@@
@
text
@d758 1
a758 1
	"master", "slave", "stub", "hint", "forward", NULL };
d958 1
@


1.3
log
@first sprintf pass from todd@@ and ISC-Bugs #5614.
@
text
@d2774 1
a2774 1
			strcpy(buf, s);
d2776 1
a2776 1
				strcat(buf, ".0");
@


1.2
log
@update to BIND 9.2.2-release. ok millert@@
@
text
@d1652 2
a1653 1
	sprintf(buf, "%" ISC_PRINT_QUADFORMAT "u", obj->value.uint64);
d3650 1
d3655 2
a3656 1
	sprintf(where, "%s:%u: ", current_file(pctx), pctx->line);
d3658 2
a3659 1
	if ((unsigned int)vsprintf(message, format, args) >= sizeof message)
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (C) 2000-2002  Internet Software Consortium.
d18 1
a18 1
/* $ISC: parser.c,v 1.70.2.14 2002/02/08 03:57:47 marka Exp $ */
d802 1
d804 4
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 2000-2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: parser.c,v 1.70.2.20.2.18 2004/05/15 03:46:13 jinmei Exp $ */
a32 1
#include <isc/netscope.h>
a36 1
#include <isccfg/grammar.h>
d43 10
d55 24
a78 1
#define TOKEN_STRING(pctx) (pctx->token.value.as_textregion.base)
d91 163
d258 44
d303 13
a315 1
free_tuple(cfg_parser_t *pctx, cfg_obj_t *obj);
d323 15
d339 1
a339 1
free_list(cfg_parser_t *pctx, cfg_obj_t *obj);
d342 1
a342 1
create_listelt(cfg_parser_t *pctx, cfg_listelt_t **eltp);
d345 1
a345 2
create_string(cfg_parser_t *pctx, const char *contents, const cfg_type_t *type,
	      cfg_obj_t **ret);
d348 4
a351 1
free_string(cfg_parser_t *pctx, cfg_obj_t *obj);
d354 1
a354 1
create_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **objp);
d357 1
a357 1
free_map(cfg_parser_t *pctx, cfg_obj_t *obj);
d368 9
d380 8
d391 9
d418 54
d475 270
d749 363
a1111 1
	"implicitlist", NULL, print_list, NULL, &cfg_rep_list, NULL };
d1115 2
a1116 2
void
cfg_print_obj(cfg_printer_t *pctx, cfg_obj_t *obj) {
d1120 2
a1121 2
void
cfg_print_chars(cfg_printer_t *pctx, const char *text, int len) {
d1127 1
a1127 1
	cfg_print_chars(pctx, "{\n", 2);
d1135 1
a1135 1
		cfg_print_chars(pctx, "\t", 1);
d1144 1
a1144 1
	cfg_print_chars(pctx, "}", 1);
d1147 2
a1148 2
isc_result_t
cfg_parse_obj(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d1173 2
a1174 2
isc_result_t
cfg_create_tuple(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d1185 1
a1185 1
	CHECK(cfg_create_obj(pctx, type, &obj));
d1198 1
a1198 2
	if (obj != NULL)
		isc_mem_put(pctx->mctx, obj, sizeof(*obj));
d1202 2
a1203 2
isc_result_t
cfg_parse_tuple(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret)
d1211 1
a1211 1
	CHECK(cfg_create_tuple(pctx, type, &obj));
d1213 1
a1213 1
		CHECK(cfg_parse_obj(pctx, f->type, &obj->value.tuple[i]));
d1223 2
a1224 2
void
cfg_print_tuple(cfg_printer_t *pctx, cfg_obj_t *obj) {
d1233 3
a1235 17
			cfg_print_chars(pctx, " ", 1);
		cfg_print_obj(pctx, fieldobj);
		need_space = ISC_TF(fieldobj->type->print != cfg_print_void);
	}
}

void
cfg_doc_tuple(cfg_printer_t *pctx, const cfg_type_t *type) {
	const cfg_tuplefielddef_t *fields = type->of;
	const cfg_tuplefielddef_t *f;
	isc_boolean_t need_space = ISC_FALSE;

	for (f = fields; f->name != NULL; f++) {
		if (need_space)
			cfg_print_chars(pctx, " ", 1);
		cfg_doc_obj(pctx, f->type);
		need_space = ISC_TF(f->type->print != cfg_print_void);
d1280 5
a1284 2
isc_result_t
cfg_parse_special(cfg_parser_t *pctx, int special) {
d1291 1
a1291 1
	cfg_parser_error(pctx, CFG_LOG_NEAR, "'%c' expected", special);
d1312 1
a1312 1
	cfg_parser_error(pctx, CFG_LOG_BEFORE, "missing ';'");
d1329 1
a1329 1
	cfg_parser_error(pctx, CFG_LOG_NEAR, "syntax error");
d1332 1
a1332 1
	return (result);
d1338 1
a1338 1
	"filelist", NULL, print_list, NULL, &cfg_rep_list,
d1343 2
a1344 1
cfg_parser_create(isc_mem_t *mctx, isc_log_t *lctx, cfg_parser_t **ret) {
d1385 2
a1386 2
	CHECK(cfg_create_list(pctx, &cfg_type_filelist, &pctx->open_files));
	CHECK(cfg_create_list(pctx, &cfg_type_filelist, &pctx->closed_files));
d1408 1
a1408 1
		cfg_parser_error(pctx, 0, "open: %s: %s",
d1442 1
a1442 1
	result = cfg_parse_obj(pctx, type, &obj);
d1453 1
a1453 1
		cfg_parser_error(pctx, 0, "parsing failed");
d1512 2
a1513 2
isc_result_t
cfg_parse_void(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d1515 1
a1515 1
	return (cfg_create_obj(pctx, &cfg_type_void, ret));
d1518 2
a1519 2
void
cfg_print_void(cfg_printer_t *pctx, cfg_obj_t *obj) {
a1523 6
void
cfg_doc_void(cfg_printer_t *pctx, const cfg_type_t *type) {
	UNUSED(pctx);
	UNUSED(type);
}

d1530 2
a1531 3
cfg_type_t cfg_type_void = {
	"void", cfg_parse_void, cfg_print_void, cfg_doc_void, &cfg_rep_void,
	NULL };
d1537 2
a1538 2
isc_result_t
cfg_parse_uint32(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d1545 1
a1545 1
		cfg_parser_error(pctx, CFG_LOG_NEAR, "expected number");
d1549 1
a1549 1
	CHECK(cfg_create_obj(pctx, &cfg_type_uint32, &obj));
d1557 3
a1559 3
void
cfg_print_cstr(cfg_printer_t *pctx, const char *s) {
	cfg_print_chars(pctx, s, strlen(s));
d1562 2
a1563 2
void
cfg_print_rawuint(cfg_printer_t *pctx, unsigned int u) {
d1566 1
a1566 1
	cfg_print_cstr(pctx, buf);
d1569 3
a1571 3
void
cfg_print_uint32(cfg_printer_t *pctx, cfg_obj_t *obj) {
	cfg_print_rawuint(pctx, obj->value.uint32);
d1586 2
a1587 4
cfg_type_t cfg_type_uint32 = {
	"integer", cfg_parse_uint32, cfg_print_uint32, cfg_doc_terminal,
	&cfg_rep_uint32, NULL
};
d1605 41
a1645 2
void
cfg_print_uint64(cfg_printer_t *pctx, cfg_obj_t *obj) {
d1647 2
a1648 3
	snprintf(buf, sizeof(buf), "%" ISC_PRINT_QUADFORMAT "u",
		 obj->value.uint64);
	cfg_print_cstr(pctx, buf);
d1651 42
a1692 3
cfg_type_t cfg_type_uint64 = {
	"64_bit_integer", NULL, cfg_print_uint64, cfg_doc_terminal,
	&cfg_rep_uint64, NULL
d1696 60
a1755 2
 * qstring (quoted string), ustring (unquoted string), astring
 * (any string)
d1767 1
a1767 1
	CHECK(cfg_create_obj(pctx, type, &obj));
d1772 1
a1772 1
		isc_mem_put(pctx->mctx, obj, sizeof(*obj));
d1783 2
a1784 2
isc_result_t
cfg_parse_qstring(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d1788 1
a1788 1
	CHECK(cfg_gettoken(pctx, CFG_LEXOPT_QSTRING));
d1790 1
a1790 1
		cfg_parser_error(pctx, CFG_LOG_NEAR, "expected quoted string");
d1794 1
a1794 1
			      TOKEN_STRING(pctx),
d1808 1
a1808 1
		cfg_parser_error(pctx, CFG_LOG_NEAR, "expected unquoted string");
d1812 1
a1812 1
			      TOKEN_STRING(pctx),
d1819 2
a1820 2
isc_result_t
cfg_parse_astring(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d1826 1
a1826 1
			      TOKEN_STRING(pctx),
d1833 2
a1834 2
isc_boolean_t
cfg_is_enum(const char *s, const char *const *enums) {
d1846 1
a1846 1
	if (cfg_is_enum(s, enums))
d1848 1
a1848 1
	cfg_parser_error(pctx, 0, "'%s' unexpected", s);
d1852 2
a1853 2
isc_result_t
cfg_parse_enum(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d1859 18
a1876 1
	return (ISC_R_SUCCESS);
a1877 1
	CLEANUP_OBJ(obj);	
a1880 11
void
cfg_doc_enum(cfg_printer_t *pctx, const cfg_type_t *type) {
	const char * const *p;
	cfg_print_chars(pctx, "( ", 2);
	for (p = type->of; *p != NULL; p++) {
		cfg_print_cstr(pctx, *p);
		if (p[1] != NULL)
			cfg_print_chars(pctx, " | ", 3);
	}
	cfg_print_chars(pctx, " )", 2);
}
d1882 6
a1887 3
void
cfg_print_ustring(cfg_printer_t *pctx, cfg_obj_t *obj) {
	cfg_print_chars(pctx, obj->value.string.base, obj->value.string.length);
d1892 3
a1894 3
	cfg_print_chars(pctx, "\"", 1);
	cfg_print_ustring(pctx, obj);
	cfg_print_chars(pctx, "\"", 1);
a1914 22
/* Quoted string only */
cfg_type_t cfg_type_qstring = {
	"quoted_string", cfg_parse_qstring, print_qstring, cfg_doc_terminal,
	&cfg_rep_string, NULL
};

/* Unquoted string only */
cfg_type_t cfg_type_ustring = {
	"string", parse_ustring, cfg_print_ustring, cfg_doc_terminal,
	&cfg_rep_string, NULL
};

/* Any string (quoted or unquoted); printed with quotes */
cfg_type_t cfg_type_astring = {
	"string", cfg_parse_astring, print_qstring, cfg_doc_terminal,
	&cfg_rep_string, NULL
};

/*
 * Booleans
 */

d1927 16
d1958 3
a1960 3
	if ((strcasecmp(TOKEN_STRING(pctx), "true") == 0) ||
	    (strcasecmp(TOKEN_STRING(pctx), "yes") == 0) ||
	    (strcmp(TOKEN_STRING(pctx), "1") == 0)) {
d1962 3
a1964 3
	} else if ((strcasecmp(TOKEN_STRING(pctx), "false") == 0) ||
		   (strcasecmp(TOKEN_STRING(pctx), "no") == 0) ||
		   (strcmp(TOKEN_STRING(pctx), "0") == 0)) {
d1970 1
a1970 1
	CHECK(cfg_create_obj(pctx, &cfg_type_boolean, &obj));
d1976 1
a1976 1
	cfg_parser_error(pctx, CFG_LOG_NEAR, "boolean expected");
d1986 1
a1986 1
		cfg_print_chars(pctx, "yes", 3);
d1988 21
a2008 1
		cfg_print_chars(pctx, "no", 2);
d2010 4
d2015 10
a2024 3
cfg_type_t cfg_type_boolean = {
	"boolean", parse_boolean, print_boolean, cfg_doc_terminal,
	&cfg_rep_boolean, NULL
d2027 1
d2032 2
a2033 2
isc_result_t
cfg_create_list(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **obj) {
d2035 1
a2035 1
	CHECK(cfg_create_obj(pctx, type, obj));
d2071 3
a2073 3
isc_result_t
cfg_parse_listelt(cfg_parser_t *pctx, const cfg_type_t *elttype,
		  cfg_listelt_t **ret)
d2081 1
a2081 1
	result = cfg_parse_obj(pctx, elttype, &value);
a2104 1
	cfg_listelt_t *elt = NULL;
d2106 1
a2106 1
	CHECK(cfg_create_list(pctx, listtype, &listobj));
d2109 2
d2113 1
a2113 1
		    pctx->token.value.as_char == /*{*/ '}')
d2115 1
a2115 1
		CHECK(cfg_parse_listelt(pctx, listof, &elt));
a2117 1
		elt = NULL;
a2122 2
	if (elt != NULL)
		free_list_elt(pctx, elt);
d2136 2
a2137 2
		cfg_print_obj(pctx, elt->obj);
		cfg_print_chars(pctx, ";\n", 2);
d2141 2
a2142 3
isc_result_t
cfg_parse_bracketed_list(cfg_parser_t *pctx, const cfg_type_t *type,
		     cfg_obj_t **ret)
d2145 1
a2145 1
	CHECK(cfg_parse_special(pctx, '{'));
d2147 1
a2147 1
	CHECK(cfg_parse_special(pctx, '}'));
d2152 2
a2153 2
void
cfg_print_bracketed_list(cfg_printer_t *pctx, cfg_obj_t *obj) {
a2158 7
void
cfg_doc_bracketed_list(cfg_printer_t *pctx, const cfg_type_t *type) {
	cfg_print_chars(pctx, "{ ", 2);
	cfg_doc_obj(pctx, type->of);
	cfg_print_chars(pctx, "; ... }", 7);
}

d2164 2
a2165 3
isc_result_t
cfg_parse_spacelist(cfg_parser_t *pctx, const cfg_type_t *listtype,
		    cfg_obj_t **ret)
d2171 1
a2171 1
	CHECK(cfg_create_list(pctx, listtype, &listobj));
d2180 1
a2180 1
		CHECK(cfg_parse_listelt(pctx, listof, &elt));
d2191 2
a2192 2
void
cfg_print_spacelist(cfg_printer_t *pctx, cfg_obj_t *obj) {
d2199 1
a2199 1
		cfg_print_obj(pctx, elt->obj);
d2201 1
a2201 1
			cfg_print_chars(pctx, " ", 1);
a2204 1

d2245 2
a2246 2
isc_result_t
cfg_parse_mapbody(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret)
d2281 1
a2281 1
		if (strcasecmp(TOKEN_STRING(pctx), "include") == 0) {
d2287 1
a2287 1
			CHECK(cfg_parse_obj(pctx, &cfg_type_qstring, &includename));
d2300 1
a2300 1
				if (strcasecmp(TOKEN_STRING(pctx),
d2307 1
a2307 1
			cfg_parser_error(pctx, CFG_LOG_NOPREP, "unknown option");
d2312 4
a2315 4
			CHECK(cfg_parse_obj(pctx, &cfg_type_unsupported, &eltobj));
			cfg_obj_destroy(pctx, &eltobj);
			CHECK(parse_semicolon(pctx));
			continue;
d2322 1
a2322 1
			cfg_parser_warning(pctx, 0, "option '%s' is obsolete",
d2325 1
a2325 1
			cfg_parser_warning(pctx, 0, "option '%s' is "
d2328 1
a2328 1
			cfg_parser_warning(pctx, 0, "option '%s' is "
d2344 1
a2344 1
				CHECK(cfg_create_list(pctx,
d2354 1
a2354 1
					cfg_parser_error(pctx, CFG_LOG_NEAR,
d2367 1
a2367 1
			CHECK(cfg_parse_listelt(pctx, clause->type, &elt));
d2383 1
a2383 1
				cfg_parser_error(pctx, CFG_LOG_NEAR, "'%s' redefined",
d2388 1
a2388 1
				cfg_parser_error(pctx, CFG_LOG_NEAR,
d2416 1
a2416 1
	CHECK(cfg_parse_obj(pctx, elttype, &obj));
d2425 1
d2436 3
a2438 2
isc_result_t
cfg_parse_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d2440 3
a2442 3
	CHECK(cfg_parse_special(pctx, '{'));
	CHECK(cfg_parse_mapbody(pctx, type, ret));
	CHECK(cfg_parse_special(pctx, '}'));
d2448 1
a2448 1
 * Subroutine for cfg_parse_named_map() and cfg_parse_addressed_map().
d2458 2
a2459 2
	CHECK(cfg_parse_obj(pctx, nametype, &idobj));
	CHECK(cfg_parse_map(pctx, type, &mapobj));
d2472 2
a2473 2
isc_result_t
cfg_parse_named_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d2481 2
a2482 2
isc_result_t
cfg_parse_addressed_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d2486 2
a2487 2
void
cfg_print_mapbody(cfg_printer_t *pctx, cfg_obj_t *obj) {
d2514 4
a2517 4
						cfg_print_cstr(pctx, clause->name);
						cfg_print_chars(pctx, " ", 1);
						cfg_print_obj(pctx, elt->obj);
						cfg_print_chars(pctx, ";\n", 2);
d2522 4
a2525 4
					cfg_print_cstr(pctx, clause->name);
					cfg_print_chars(pctx, " ", 1);
					cfg_print_obj(pctx, obj);
					cfg_print_chars(pctx, ";\n", 2);
d2536 2
a2537 32
void
cfg_doc_mapbody(cfg_printer_t *pctx, const cfg_type_t *type) {
	const cfg_clausedef_t * const *clauseset;
	const cfg_clausedef_t *clause;
	
	for (clauseset = type->of; *clauseset != NULL; clauseset++) {
		for (clause = *clauseset;
		     clause->name != NULL;
		     clause++) {
			cfg_print_cstr(pctx, clause->name);
			cfg_print_chars(pctx, " ", 1);
			cfg_doc_obj(pctx, clause->type);
			cfg_print_chars(pctx, ";", 1);
			/* XXX print flags here? */
			cfg_print_chars(pctx, "\n\n", 2);
		}
	}
}

static struct flagtext {
	unsigned int flag;
	const char *text;
} flagtexts[] = {
	{ CFG_CLAUSEFLAG_NOTIMP, "not implemented" },
	{ CFG_CLAUSEFLAG_NYI, "not yet implemented" },
	{ CFG_CLAUSEFLAG_OBSOLETE, "obsolete" },
	{ CFG_CLAUSEFLAG_NEWDEFAULT, "default changed" },
	{ 0, NULL }
};

void
cfg_print_map(cfg_printer_t *pctx, cfg_obj_t *obj) {
d2539 2
a2540 35
		cfg_print_obj(pctx, obj->value.map.id);
		cfg_print_chars(pctx, " ", 1);
	}
	print_open(pctx);
	cfg_print_mapbody(pctx, obj);
	print_close(pctx);
}

static void
print_clause_flags(cfg_printer_t *pctx, unsigned int flags) {
	struct flagtext *p;
	isc_boolean_t first = ISC_TRUE;
	for (p = flagtexts; p->flag != 0; p++) {
		if ((flags & p->flag) != 0) {
			if (first)
				cfg_print_chars(pctx, " // ", 4);
			else
				cfg_print_chars(pctx, ", ", 2);
			cfg_print_cstr(pctx, p->text);
			first = ISC_FALSE;
		}
	}
}

void
cfg_doc_map(cfg_printer_t *pctx, const cfg_type_t *type) {
	const cfg_clausedef_t * const *clauseset;
	const cfg_clausedef_t *clause;
	
	if (type->parse == cfg_parse_named_map) {
		cfg_doc_obj(pctx, &cfg_type_astring);
		cfg_print_chars(pctx, " ", 1);
	} else if (type->parse == cfg_parse_addressed_map) {
		cfg_doc_obj(pctx, &cfg_type_netaddr);
		cfg_print_chars(pctx, " ", 1);
a2541 1
	
d2543 1
a2543 15
	
	for (clauseset = type->of; *clauseset != NULL; clauseset++) {
		for (clause = *clauseset;
		     clause->name != NULL;
		     clause++) {
			print_indent(pctx);
			cfg_print_cstr(pctx, clause->name);
			if (clause->type->print != cfg_print_void)
				cfg_print_chars(pctx, " ", 1);
			cfg_doc_obj(pctx, clause->type);
			cfg_print_chars(pctx, ";", 1);
			print_clause_flags(pctx, clause->flags);
			cfg_print_chars(pctx, "\n", 1);
		}
	}
d2588 2
a2589 2
	CHECK(cfg_create_obj(pctx, &cfg_type_token, &obj));
	CHECK(cfg_gettoken(pctx, CFG_LEXOPT_QSTRING));
d2608 2
a2609 4
cfg_type_t cfg_type_token = {
	"token", parse_token, cfg_print_ustring, cfg_doc_terminal,
	&cfg_rep_string, NULL
};
d2622 1
a2622 1
	CHECK(cfg_create_list(pctx, type, &listobj));
d2638 1
a2638 1
			cfg_parser_error(pctx, CFG_LOG_NEAR, "unexpected token");
d2643 1
a2643 1
		CHECK(cfg_parse_listelt(pctx, &cfg_type_token, &elt));
d2655 2
a2656 2
cfg_type_t cfg_type_unsupported = {
	"unsupported", parse_unsupported, cfg_print_spacelist, cfg_doc_terminal,
d2661 67
d2730 4
a2733 4
 * If CFG_ADDR_WILDOK is set in flags, "*" can be used as a wildcard
 * and at least one of CFG_ADDR_V4OK and CFG_ADDR_V6OK must also be set.  The
 * "*" is interpreted as the IPv4 wildcard address if CFG_ADDR_V4OK is 
 * set (including the case where CFG_ADDR_V4OK and CFG_ADDR_V6OK are both set),
d2745 3
a2747 3
	s = TOKEN_STRING(pctx);
	if ((flags & CFG_ADDR_WILDOK) != 0 && strcmp(s, "*") == 0) {
		if ((flags & CFG_ADDR_V4OK) != 0) {
d2750 1
a2750 1
		} else if ((flags & CFG_ADDR_V6OK) != 0) {
d2757 1
a2757 1
		if ((flags & (CFG_ADDR_V4OK | CFG_ADDR_V4PREFIXOK)) != 0) {
d2763 2
a2764 2
		if ((flags & CFG_ADDR_V4PREFIXOK) != 0 &&
		    strlen(s) <= 15U) {
d2777 2
a2778 27
		if ((flags & CFG_ADDR_V6OK) != 0 &&
		    strlen(s) <= 127U) {
			char buf[128]; /* see lib/bind9/getaddresses.c */
			char *d; /* zone delimiter */
			isc_uint32_t zone = 0; /* scope zone ID */

			strcpy(buf, s);
			d = strchr(buf, '%');
			if (d != NULL)
				*d = '\0';

			if (inet_pton(AF_INET6, buf, &in6a) == 1) {
				if (d != NULL) {
#ifdef ISC_PLATFORM_HAVESCOPEID
					isc_result_t result;

					result = isc_netscope_pton(AF_INET6,
								   d + 1,
								   &in6a,
								   &zone);
					if (result != ISC_R_SUCCESS)
						return (result);
#else
				return (ISC_R_BADADDRESSFORM);
#endif
				}

a2779 1
				isc_netaddr_setzone(na, zone);
d2787 2
a2788 2
isc_result_t
cfg_parse_rawaddr(cfg_parser_t *pctx, unsigned int flags, isc_netaddr_t *na) {
d2793 1
a2793 1
		cfg_parser_error(pctx, CFG_LOG_NEAR, "expected IP address");
d2798 2
a2799 2
isc_boolean_t
cfg_lookingat_netaddr(cfg_parser_t *pctx, unsigned int flags) {
d2806 2
a2807 2
isc_result_t
cfg_parse_rawport(cfg_parser_t *pctx, unsigned int flags, in_port_t *port) {
d2812 1
a2812 1
	if ((flags & CFG_ADDR_WILDOK) != 0 &&
d2814 1
a2814 1
	    strcmp(TOKEN_STRING(pctx), "*") == 0) {
d2819 1
a2819 1
		cfg_parser_error(pctx, CFG_LOG_NEAR,
d2823 2
a2824 2
	if (pctx->token.value.as_ulong >= 65536U) {
		cfg_parser_error(pctx, CFG_LOG_NEAR,
d2834 74
a2907 2
void
cfg_print_rawaddr(cfg_printer_t *pctx, isc_netaddr_t *na) {
d2915 11
a2925 1
	cfg_print_chars(pctx, isc_buffer_base(&buf), isc_buffer_usedlength(&buf));
d2928 7
d2943 2
a2944 2
	CHECK(cfg_create_obj(pctx, type, &obj));
	CHECK(cfg_parse_rawaddr(pctx, CFG_ADDR_V4OK | CFG_ADDR_V6OK, &netaddr));
d2953 2
a2954 4
cfg_type_t cfg_type_netaddr = {
	"netaddr", parse_netaddr, cfg_print_sockaddr, cfg_doc_terminal,
	&cfg_rep_sockaddr, NULL
};
d2958 2
a2959 4
isc_result_t
cfg_parse_netprefix(cfg_parser_t *pctx, const cfg_type_t *type,
		    cfg_obj_t **ret)
{
d2966 1
a2966 2
	CHECK(cfg_parse_rawaddr(pctx, CFG_ADDR_V4OK | CFG_ADDR_V4PREFIXOK |
				CFG_ADDR_V6OK, &netaddr));
d2985 1
a2985 1
			cfg_parser_error(pctx, CFG_LOG_NEAR,
d2991 1
a2991 1
			cfg_parser_error(pctx, CFG_LOG_NOPREP,
d2998 1
a2998 1
	CHECK(cfg_create_obj(pctx, &cfg_type_netprefix, &obj));
d3000 70
a3069 3
	obj->value.netprefix.prefixlen = prefixlen;
	*ret = obj;
	return (ISC_R_SUCCESS);
a3070 1
	cfg_parser_error(pctx, CFG_LOG_NEAR, "expected network prefix");
d3074 11
d3086 3
a3088 5
print_netprefix(cfg_printer_t *pctx, cfg_obj_t *obj) {
	cfg_netprefix_t *p = &obj->value.netprefix;
	cfg_print_rawaddr(pctx, &p->address);
	cfg_print_chars(pctx, "/", 1);
	cfg_print_rawuint(pctx, p->prefixlen);
d3091 4
a3094 5
isc_boolean_t
cfg_obj_isnetprefix(cfg_obj_t *obj) {
	REQUIRE(obj != NULL);
	return (ISC_TF(obj->type->rep == &cfg_rep_netprefix));
}
d3096 1
a3096 7
void
cfg_obj_asnetprefix(cfg_obj_t *obj, isc_netaddr_t *netaddr,
		    unsigned int *prefixlen) {
	REQUIRE(obj != NULL && obj->type->rep == &cfg_rep_netprefix);
	*netaddr = obj->value.netprefix.address;
	*prefixlen = obj->value.netprefix.prefixlen;
}
d3098 5
a3102 3
cfg_type_t cfg_type_netprefix = {
	"netprefix", cfg_parse_netprefix, print_netprefix, cfg_doc_terminal,
	&cfg_rep_netprefix, NULL
d3114 2
a3115 2
	CHECK(cfg_create_obj(pctx, type, &obj));
	CHECK(cfg_parse_rawaddr(pctx, flags, &netaddr));
d3118 1
a3118 1
	    strcasecmp(TOKEN_STRING(pctx), "port") == 0) {
d3120 1
a3120 1
		CHECK(cfg_parse_rawport(pctx, flags, &port));
d3131 2
a3132 8
static unsigned int sockaddr_flags = CFG_ADDR_V4OK | CFG_ADDR_V6OK;
cfg_type_t cfg_type_sockaddr = {
	"sockaddr", cfg_parse_sockaddr, cfg_print_sockaddr, cfg_doc_sockaddr,
	&cfg_rep_sockaddr, &sockaddr_flags
};

isc_result_t
cfg_parse_sockaddr(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d3134 1
a3134 1
	return (parse_sockaddrsub(pctx, &cfg_type_sockaddr, *flagp, ret));
d3137 2
a3138 2
void
cfg_print_sockaddr(cfg_printer_t *pctx, cfg_obj_t *obj) {
d3145 1
a3145 1
	cfg_print_cstr(pctx, buf);
d3148 2
a3149 33
		cfg_print_chars(pctx, " port ", 6);
		cfg_print_rawuint(pctx, port);
	}
}

void
cfg_doc_sockaddr(cfg_printer_t *pctx, const cfg_type_t *type) {
	const unsigned int *flagp = type->of;
	int n = 0;
	cfg_print_chars(pctx, "( ", 2);
	if (*flagp & CFG_ADDR_V4OK) {
		if (n != 0)
			cfg_print_chars(pctx, " | ", 3);
		cfg_print_cstr(pctx, "<ipv4_address>");
		n++;
	}
	if (*flagp & CFG_ADDR_V6OK) {
		if (n != 0)
			cfg_print_chars(pctx, " | ", 3);
		cfg_print_cstr(pctx, "<ipv6_address>");
		n++;			
	}
	if (*flagp & CFG_ADDR_WILDOK) {
		if (n != 0)
			cfg_print_chars(pctx, " | ", 3);
		cfg_print_chars(pctx, "*", 1);
		n++;
	}
	cfg_print_chars(pctx, " ) ", 3);
	if (*flagp & CFG_ADDR_WILDOK) {
		cfg_print_cstr(pctx, "[ port ( <integer> | * ) ]");
	} else {
		cfg_print_cstr(pctx, "[ port <integer> ]");
d3165 338
a3502 1
isc_result_t
d3544 1
a3544 1
		cfg_parser_error(pctx, CFG_LOG_NEAR, "token too big");
d3548 1
a3548 1
		cfg_parser_error(pctx, 0, "%s",
d3553 2
a3554 2
		cfg_parser_error(pctx, CFG_LOG_NEAR, "%s",
				 isc_result_totext(result));
d3560 1
a3560 1
void
d3568 1
a3568 1
isc_result_t
d3585 1
a3585 1
	result = cfg_gettoken(pctx, CFG_LEXOPT_QSTRING);
d3591 1
a3591 1
		cfg_parser_error(pctx, CFG_LOG_NEAR, "expected string");
d3597 2
a3598 2
void
cfg_parser_error(cfg_parser_t *pctx, unsigned int flags, const char *fmt, ...) {
d3606 2
a3607 2
void
cfg_parser_warning(cfg_parser_t *pctx, unsigned int flags, const char *fmt, ...) {
a3643 1
	size_t len;
d3648 1
a3648 2
	snprintf(where, sizeof(where), "%s:%u: ",
		 current_file(pctx), pctx->line);
d3650 1
a3650 2
	len = vsnprintf(message, sizeof(message), format, args);
	if (len >= sizeof(message))
d3654 1
a3654 1
	if ((flags & (CFG_LOG_NEAR|CFG_LOG_BEFORE|CFG_LOG_NOPREP)) != 0) {
d3677 1
a3677 1
		if (flags & CFG_LOG_NEAR)
d3679 1
a3679 1
		else if (flags & CFG_LOG_BEFORE)
d3708 2
a3709 12
const char *
cfg_obj_file(cfg_obj_t *obj) {
	return (obj->file);
}

unsigned int
cfg_obj_line(cfg_obj_t *obj) {
	return (obj->line);
}

isc_result_t
cfg_create_obj(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
d3742 1
a3742 1
	CHECK(cfg_create_obj(pctx, type, &obj));
d3754 1
a3754 2
	if (obj != NULL)
		isc_mem_put(pctx->mctx, obj, sizeof(*obj));
d3786 28
a3813 3
void
cfg_doc_obj(cfg_printer_t *pctx, const cfg_type_t *type) {
	type->doc(pctx, type);
d3816 115
a3930 5
void
cfg_doc_terminal(cfg_printer_t *pctx, const cfg_type_t *type) {
	cfg_print_chars(pctx, "<", 1);
	cfg_print_cstr(pctx, type->name);
	cfg_print_chars(pctx, ">", 1);
d3942 1
a3942 1
	cfg_doc_obj(&pctx, type);
@


1.1.1.3
log
@ISC BIND release 9.3.3
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: parser.c,v 1.70.2.20.2.21 2006/02/28 06:32:54 marka Exp $ */
d71 1
a71 1
print_list(cfg_printer_t *pctx, const cfg_obj_t *obj);
d137 1
a137 1
cfg_print_obj(cfg_printer_t *pctx, const cfg_obj_t *obj) {
d180 1
a180 1
cfg_print(const cfg_obj_t *obj,
d246 1
a246 1
cfg_print_tuple(cfg_printer_t *pctx, const cfg_obj_t *obj) {
d253 1
a253 1
		const cfg_obj_t *fieldobj = obj->value.tuple[i];
d294 1
a294 1
cfg_obj_istuple(const cfg_obj_t *obj) {
d299 2
a300 2
const cfg_obj_t *
cfg_tuple_get(const cfg_obj_t *tupleobj, const char* name) {
d551 1
a551 1
cfg_print_void(cfg_printer_t *pctx, const cfg_obj_t *obj) {
d563 1
a563 1
cfg_obj_isvoid(const cfg_obj_t *obj) {
d609 1
a609 1
cfg_print_uint32(cfg_printer_t *pctx, const cfg_obj_t *obj) {
d614 1
a614 1
cfg_obj_isuint32(const cfg_obj_t *obj) {
d620 1
a620 1
cfg_obj_asuint32(const cfg_obj_t *obj) {
d635 1
a635 1
cfg_obj_isuint64(const cfg_obj_t *obj) {
d641 1
a641 1
cfg_obj_asuint64(const cfg_obj_t *obj) {
d647 1
a647 1
cfg_print_uint64(cfg_printer_t *pctx, const cfg_obj_t *obj) {
d726 1
a726 3
cfg_parse_astring(cfg_parser_t *pctx, const cfg_type_t *type,
		  cfg_obj_t **ret)
{
d784 1
a784 1
cfg_print_ustring(cfg_printer_t *pctx, const cfg_obj_t *obj) {
d789 1
a789 1
print_qstring(cfg_printer_t *pctx, const cfg_obj_t *obj) {
d802 1
a802 1
cfg_obj_isstring(const cfg_obj_t *obj) {
d807 2
a808 2
const char *
cfg_obj_asstring(const cfg_obj_t *obj) {
d836 1
a836 1
cfg_obj_isboolean(const cfg_obj_t *obj) {
d842 1
a842 1
cfg_obj_asboolean(const cfg_obj_t *obj) {
d888 1
a888 1
print_boolean(cfg_printer_t *pctx, const cfg_obj_t *obj) {
d1002 3
a1004 3
print_list(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	const cfg_list_t *list = &obj->value.list;
	const cfg_listelt_t *elt;
d1028 1
a1028 1
cfg_print_bracketed_list(cfg_printer_t *pctx, const cfg_obj_t *obj) {
d1075 3
a1077 3
cfg_print_spacelist(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	const cfg_list_t *list = &obj->value.list;
	const cfg_listelt_t *elt;
d1090 1
a1090 1
cfg_obj_islist(const cfg_obj_t *obj) {
d1095 2
a1096 2
const cfg_listelt_t *
cfg_list_first(const cfg_obj_t *obj) {
d1103 2
a1104 2
const cfg_listelt_t *
cfg_list_next(const cfg_listelt_t *elt) {
d1109 2
a1110 2
const cfg_obj_t *
cfg_listelt_value(const cfg_listelt_t *elt) {
d1369 1
a1369 1
cfg_print_mapbody(cfg_printer_t *pctx, const cfg_obj_t *obj) {
d1449 1
a1449 1
cfg_print_map(cfg_printer_t *pctx, const cfg_obj_t *obj) {
d1508 1
a1508 1
cfg_obj_ismap(const cfg_obj_t *obj) {
d1514 1
a1514 1
cfg_map_get(const cfg_obj_t *mapobj, const char* name, const cfg_obj_t **obj) {
d1517 1
a1517 1
	const cfg_map_t *map;
d1532 2
a1533 2
const cfg_obj_t *
cfg_map_getname(const cfg_obj_t *mapobj) {
a1558 4
	if (obj->value.string.base == NULL) {
		result = ISC_R_NOMEMORY;
		goto cleanup;
	}
a1562 1
	return (result);
a1564 2
	if (obj != NULL)
		isc_mem_put(pctx->mctx, obj, sizeof(*obj));
d1756 1
a1756 1
cfg_print_rawaddr(cfg_printer_t *pctx, const isc_netaddr_t *na) {
d1846 2
a1847 3
print_netprefix(cfg_printer_t *pctx, const cfg_obj_t *obj) {
	const cfg_netprefix_t *p = &obj->value.netprefix;

d1854 1
a1854 1
cfg_obj_isnetprefix(const cfg_obj_t *obj) {
d1860 1
a1860 1
cfg_obj_asnetprefix(const cfg_obj_t *obj, isc_netaddr_t *netaddr,
d1911 1
a1911 1
cfg_print_sockaddr(cfg_printer_t *pctx, const cfg_obj_t *obj) {
d1932 2
d1958 1
a1958 1
cfg_obj_issockaddr(const cfg_obj_t *obj) {
d1963 2
a1964 2
const isc_sockaddr_t *
cfg_obj_assockaddr(const cfg_obj_t *obj) {
d2161 1
a2161 2
cfg_obj_log(const cfg_obj_t *obj, isc_log_t *lctx, int level,
	    const char *fmt, ...) {
d2179 1
a2179 1
cfg_obj_file(const cfg_obj_t *obj) {
d2184 1
a2184 1
cfg_obj_line(const cfg_obj_t *obj) {
d2226 1
d2246 1
a2246 1
cfg_obj_istype(const cfg_obj_t *obj, const cfg_type_t *type) {
@


1.1.1.4
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 3
/* $ISC: parser.c,v 1.112.18.11 2006/02/28 03:10:49 marka Exp $ */

/*! \file */
d128 1
a128 1
/*%
d1090 1
d1363 1
a1363 1
 * Used to be used for the "server" statement.
a1369 9
/*
 * Parse a map identified by a network prefix.
 * Used for the "server" statement.
 */
isc_result_t
cfg_parse_netprefix_map(cfg_parser_t *pctx, const cfg_type_t *type, cfg_obj_t **ret) {
	return (parse_any_named_map(pctx, &cfg_type_netprefix, type, ret));
}

a1487 3
	} else if (type->parse == cfg_parse_netprefix_map) {
		cfg_doc_obj(pctx, &cfg_type_netprefix);
		cfg_print_chars(pctx, " ", 1);
a1719 3
	const char *wild = "";
	const char *prefix = "";

d1722 2
a1723 18
	if (result == ISC_R_UNEXPECTEDTOKEN) {
		if ((flags & CFG_ADDR_WILDOK) != 0)
			wild = " or '*'";
		if ((flags & CFG_ADDR_V4PREFIXOK) != 0)
			wild = " or IPv4 prefix";
		if ((flags & CFG_ADDR_MASK) == CFG_ADDR_V4OK)
			cfg_parser_error(pctx, CFG_LOG_NEAR,
					 "expected IPv4 address%s%s",
					 prefix, wild);
		else if ((flags & CFG_ADDR_MASK) == CFG_ADDR_V6OK)
			cfg_parser_error(pctx, CFG_LOG_NEAR,
					 "expected IPv6 address%s%s",
					 prefix, wild);
		else
			cfg_parser_error(pctx, CFG_LOG_NEAR,
					 "expected IP address%s%s",
					 prefix, wild);
	}
a1777 6
static unsigned int netaddr_flags = CFG_ADDR_V4OK | CFG_ADDR_V6OK;
static unsigned int netaddr4_flags = CFG_ADDR_V4OK;
static unsigned int netaddr4wild_flags = CFG_ADDR_V4OK | CFG_ADDR_WILDOK;
static unsigned int netaddr6_flags = CFG_ADDR_V6OK;
static unsigned int netaddr6wild_flags = CFG_ADDR_V6OK | CFG_ADDR_WILDOK;

d1783 1
a1783 2
	unsigned int flags = *(const unsigned int *)type->of;

d1785 1
a1785 1
	CHECK(cfg_parse_rawaddr(pctx, flags, &netaddr));
a1793 26
static void
cfg_doc_netaddr(cfg_printer_t *pctx, const cfg_type_t *type) {
	const unsigned int *flagp = type->of;
	int n = 0;
	if (*flagp != CFG_ADDR_V4OK && *flagp != CFG_ADDR_V6OK)
		cfg_print_chars(pctx, "( ", 2);
	if (*flagp & CFG_ADDR_V4OK) {
		cfg_print_cstr(pctx, "<ipv4_address>");
		n++;
	}
	if (*flagp & CFG_ADDR_V6OK) {
		if (n != 0)
			cfg_print_chars(pctx, " | ", 3);
		cfg_print_cstr(pctx, "<ipv6_address>");
		n++;			
	}
	if (*flagp & CFG_ADDR_WILDOK) {
		if (n != 0)
			cfg_print_chars(pctx, " | ", 3);
		cfg_print_chars(pctx, "*", 1);
		n++;
	}
	if (*flagp != CFG_ADDR_V4OK && *flagp != CFG_ADDR_V6OK)
		cfg_print_chars(pctx, " )", 2);
}

d1795 2
a1796 22
	"netaddr", parse_netaddr, cfg_print_sockaddr, cfg_doc_netaddr,
	&cfg_rep_sockaddr, &netaddr_flags
};

cfg_type_t cfg_type_netaddr4 = {
	"netaddr4", parse_netaddr, cfg_print_sockaddr, cfg_doc_netaddr,
	&cfg_rep_sockaddr, &netaddr4_flags
};

cfg_type_t cfg_type_netaddr4wild = {
	"netaddr4wild", parse_netaddr, cfg_print_sockaddr, cfg_doc_netaddr,
	&cfg_rep_sockaddr, &netaddr4wild_flags
};

cfg_type_t cfg_type_netaddr6 = {
	"netaddr6", parse_netaddr, cfg_print_sockaddr, cfg_doc_netaddr,
	&cfg_rep_sockaddr, &netaddr6_flags
};

cfg_type_t cfg_type_netaddr6wild = {
	"netaddr6wild", parse_netaddr, cfg_print_sockaddr, cfg_doc_netaddr,
	&cfg_rep_sockaddr, &netaddr6wild_flags
@


