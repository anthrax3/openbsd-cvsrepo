head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.36
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.32
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.34
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.26
	OPENBSD_5_7_BASE:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.30
	OPENBSD_5_6_BASE:1.1.1.4
	OPENBSD_5_5:1.1.1.4.0.28
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.24
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.22
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.20
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.18
	OPENBSD_5_0:1.1.1.4.0.16
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.14
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.12
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.8
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.10
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.6
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.4
	OPENBSD_4_4_BASE:1.1.1.4
	BIND_9_4_2_P1:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	OPENBSD_4_3_BASE:1.1.1.4
	BIND_9_4_2:1.1.1.4
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	BIND_9_3_4:1.1.1.3
	BIND_9_3_3:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	BIND_9_3_2:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.6
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.4
	OPENBSD_3_8_BASE:1.1.1.2
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2003.01.20.21.07.49;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.49;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.36.03;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.04.05.16.44.30;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.12.09.12.33.58;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook V4.1//EN">
<!--
 - Copyright (C) 2001  Internet Software Consortium.
 -
 - Permission to use, copy, modify, and distribute this software for any
 - purpose with or without fee is hereby granted, provided that the above
 - copyright notice and this permission notice appear in all copies.
 -
 - THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 - DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 - IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 - INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 - INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 - FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 - NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 - WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-->

<!-- $ISC: lwres.docbook,v 1.3 2001/04/10 21:51:14 bwelling Exp $ -->

<refentry>
<refentryinfo>

<date>Jun 30, 2000</date>
</refentryinfo>
<refmeta>
<refentrytitle>lwres</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>BIND9</refmiscinfo>
</refmeta>
<refnamediv>
<refname>lwres</refname>
<refpurpose>introduction to the lightweight resolver library</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>#include &lt;lwres/lwres.h&gt;</funcsynopsisinfo>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>DESCRIPTION</title>
<para>
The BIND 9 lightweight resolver library is a simple, name service
independent stub resolver library.  It provides hostname-to-address
and address-to-hostname lookup services to applications by
transmitting lookup requests to a resolver daemon
<command>lwresd</command>
running on the local host. The resover daemon performs the
lookup using the DNS or possibly other name service protocols,
and returns the results to the application through the library.  
The library and resolver daemon communicate using a simple
UDP-based protocol.
</para>
</refsect1>

<refsect1>
<title>OVERVIEW</title>
<para>
The lwresd library implements multiple name service APIs.
The standard
<function>gethostbyname()</function>,
<function>gethostbyaddr()</function>,
<function>gethostbyname_r()</function>,
<function>gethostbyaddr_r()</function>,
<function>getaddrinfo()</function>,
<function>getipnodebyname()</function>,
and
<function>getipnodebyaddr()</function>
functions are all supported.  To allow the lwres library to coexist
with system libraries that define functions of the same name,
the library defines these functions with names prefixed by
<literal>lwres_</literal>.
To define the standard names, applications must include the
header file
<filename>&lt;lwres/netdb.h&gt;</filename>
which contains macro definitions mapping the standard function names
into
<literal>lwres_</literal>
prefixed ones.  Operating system vendors who integrate the lwres
library into their base distributions should rename the functions
in the library proper so that the renaming macros are not needed.
</para>
<para>
The library also provides a native API consisting of the functions
<function>lwres_getaddrsbyname()</function>
and
<function>lwres_getnamebyaddr()</function>.
These may be called by applications that require more detailed
control over the lookup process than the standard functions
provide.
</para>
<para>
In addition to these name service independent address lookup
functions, the library implements a new, experimental API
for looking up arbitrary DNS resource records, using the
<function>lwres_getaddrsbyname()</function>
function.
</para>
<para>
Finally, there is a low-level API for converting lookup
requests and responses to and from raw lwres protocol packets.  
This API can be used by clients requiring nonblocking operation, 
and is also used when implementing the server side of the lwres
protocol, for example in the
<command>lwresd</command>
resolver daemon.  The use of this low-level API in clients
and servers is outlined in the following sections.
</para>
</refsect1>
<refsect1>
<title>CLIENT-SIDE LOW-LEVEL API CALL FLOW</title>
<para>
When a client program wishes to make an lwres request using the
native low-level API, it typically performs the following 
sequence of actions.
</para>
<para>
(1) Allocate or use an existing <type>lwres_packet_t</type>,
called <varname>pkt</varname> below.
</para>
<para>
(2) Set <structfield>pkt.recvlength</structfield> to the maximum length we will accept.  
This is done so the receiver of our packets knows how large our receive 
buffer is.  The "default" is a constant in
<filename>lwres.h</filename>: <constant>LWRES_RECVLENGTH = 4096</constant>.
</para>
<para>
(3) Set <structfield>pkt.serial</structfield>
to a unique serial number.  This value is echoed
back to the application by the remote server.
</para>
<para>
(4) Set <structfield>pkt.pktflags</structfield>.  Usually this is set to 0.
</para>
<para>
(5) Set <structfield>pkt.result</structfield> to 0.
</para>
<para>
(6) Call <function>lwres_*request_render()</function>, 
or marshall in the data using the primitives
such as <function>lwres_packet_render()</function>
and storing the packet data.
</para>
<para>
(7) Transmit the resulting buffer.
</para>
<para>
(8) Call <function>lwres_*response_parse()</function>
to parse any packets received.
</para>
<para>
(9) Verify that the opcode and serial match a request, and process the
packet specific information contained in the body.
</para>
</refsect1>
<refsect1>
<title>SERVER-SIDE LOW-LEVEL API CALL FLOW</title>
<para>
When implementing the server side of the lightweight resolver
protocol using the lwres library, a sequence of actions like the
following is typically involved in processing each request packet.
</para>
<para>
Note that the same <type>lwres_packet_t</type> is used
in both the <function>_parse()</function> and <function>_render()</function> calls,
with only a few modifications made
to the packet header's contents between uses.  This method is recommended
as it keeps the serial, opcode, and other fields correct.
</para>
<para>
(1) When a packet is received, call <function>lwres_*request_parse()</function> to
unmarshall it.  This returns a <type>lwres_packet_t</type> (also called <varname>pkt</varname>, below)
as well as a data specific type, such as <type>lwres_gabnrequest_t</type>.
</para>
<para>
(2) Process the request in the data specific type.
</para>
<para>
(3) Set the <structfield>pkt.result</structfield>,
<structfield>pkt.recvlength</structfield> as above.  All other fields can
be left untouched since they were filled in by the <function>*_parse()</function> call
above.  If using <function>lwres_*response_render()</function>,
<structfield>pkt.pktflags</structfield> will be set up
properly.  Otherwise, the <constant>LWRES_LWPACKETFLAG_RESPONSE</constant> bit should be
set.
</para>
<para>
(4) Call the data specific rendering function, such as
<function>lwres_gabnresponse_render()</function>.
</para>
<para>
(5) Send the resulting packet to the client.
</para>
<para>
</para>
</refsect1>
<refsect1>
<title>SEE ALSO</title>
<para>
<citerefentry>
<refentrytitle>lwres_gethostent</refentrytitle><manvolnum>3</manvolnum>
</citerefentry>,

<citerefentry>
<refentrytitle>lwres_getipnode</refentrytitle><manvolnum>3</manvolnum>
</citerefentry>,

<citerefentry>
<refentrytitle>lwres_getnameinfo</refentrytitle><manvolnum>3</manvolnum>
</citerefentry>,

<citerefentry>
<refentrytitle>lwres_noop</refentrytitle><manvolnum>3</manvolnum>
</citerefentry>,

<citerefentry>
<refentrytitle>lwres_gabn</refentrytitle><manvolnum>3</manvolnum>
</citerefentry>,

<citerefentry>
<refentrytitle>lwres_gnba</refentrytitle><manvolnum>3</manvolnum>
</citerefentry>,

<citerefentry>
<refentrytitle>lwres_context</refentrytitle><manvolnum>3</manvolnum>
</citerefentry>,

<citerefentry>
<refentrytitle>lwres_config</refentrytitle><manvolnum>3</manvolnum>
</citerefentry>,

<citerefentry>
<refentrytitle>resolver</refentrytitle><manvolnum>5</manvolnum>
</citerefentry>,

<citerefentry>
<refentrytitle>lwresd</refentrytitle><manvolnum>8</manvolnum>
</citerefentry>.

</para>
</refsect1>
</refentry>
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@a2 1
 - Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d9 8
a16 7
 - THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 - REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 - AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 - INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 - LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 - OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 - PERFORMANCE OF THIS SOFTWARE.
d19 1
a19 1
<!-- $ISC: lwres.docbook,v 1.3.206.1 2004/03/06 08:15:37 marka Exp $ -->
@


1.1.1.3
log
@ISC BIND release 9.3.2
@
text
@d1 1
a1 3
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.0//EN"
               "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd"
	       [<!ENTITY mdash "&#8212;">]>
d3 2
a4 2
 - Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
 - Copyright (C) 2000, 2001  Internet Software Consortium.
d19 1
a19 1
<!-- $ISC: lwres.docbook,v 1.3.206.3 2005/05/12 21:36:11 sra Exp $ -->
a30 14

  <docinfo>
    <copyright>
      <year>2004</year>
      <year>2005</year>
      <holder>Internet Systems Consortium, Inc. ("ISC")</holder>
    </copyright>
    <copyright>
      <year>2000</year>
      <year>2001</year>
      <holder>Internet Software Consortium.</holder>
    </copyright>
  </docinfo>

@


1.1.1.4
log
@ISC BIND release 9.4.2
@
text
@d1 2
a2 2
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
               "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
d5 1
a5 1
 - Copyright (C) 2004, 2005, 2007  Internet Systems Consortium, Inc. ("ISC")
d8 1
a8 1
 - Permission to use, copy, modify, and/or distribute this software for any
d21 2
a22 1
<!-- $ISC: lwres.docbook,v 1.4.18.6 2007/08/28 07:20:06 tbox Exp $ -->
d24 1
d26 7
a32 13
  <refentryinfo>
    <date>Jun 30, 2000</date>
  </refentryinfo>

  <refmeta>
    <refentrytitle>lwres</refentrytitle>
    <manvolnum>3</manvolnum>
    <refmiscinfo>BIND9</refmiscinfo>
  </refmeta>
  <refnamediv>
    <refname>lwres</refname>
    <refpurpose>introduction to the lightweight resolver library</refpurpose>
  </refnamediv>
a37 1
      <year>2007</year>
d47 7
a53 2
  <refsynopsisdiv>
    <funcsynopsis>
d56 1
a56 1
  </refsynopsisdiv>
d58 203
a260 209
  <refsect1>
    <title>DESCRIPTION</title>
    <para>
      The BIND 9 lightweight resolver library is a simple, name service
      independent stub resolver library.  It provides hostname-to-address
      and address-to-hostname lookup services to applications by
      transmitting lookup requests to a resolver daemon
      <command>lwresd</command>
      running on the local host. The resover daemon performs the
      lookup using the DNS or possibly other name service protocols,
      and returns the results to the application through the library.
      The library and resolver daemon communicate using a simple
      UDP-based protocol.
    </para>
  </refsect1>

  <refsect1>
    <title>OVERVIEW</title>
    <para>
      The lwresd library implements multiple name service APIs.
      The standard
      <function>gethostbyname()</function>,
      <function>gethostbyaddr()</function>,
      <function>gethostbyname_r()</function>,
      <function>gethostbyaddr_r()</function>,
      <function>getaddrinfo()</function>,
      <function>getipnodebyname()</function>,
      and
      <function>getipnodebyaddr()</function>
      functions are all supported.  To allow the lwres library to coexist
      with system libraries that define functions of the same name,
      the library defines these functions with names prefixed by
      <literal>lwres_</literal>.
      To define the standard names, applications must include the
      header file
      <filename>&lt;lwres/netdb.h&gt;</filename>
      which contains macro definitions mapping the standard function names
      into
      <literal>lwres_</literal>
      prefixed ones.  Operating system vendors who integrate the lwres
      library into their base distributions should rename the functions
      in the library proper so that the renaming macros are not needed.
    </para>
    <para>
      The library also provides a native API consisting of the functions
      <function>lwres_getaddrsbyname()</function>
      and
      <function>lwres_getnamebyaddr()</function>.
      These may be called by applications that require more detailed
      control over the lookup process than the standard functions
      provide.
    </para>
    <para>
      In addition to these name service independent address lookup
      functions, the library implements a new, experimental API
      for looking up arbitrary DNS resource records, using the
      <function>lwres_getaddrsbyname()</function>
      function.
    </para>
    <para>
      Finally, there is a low-level API for converting lookup
      requests and responses to and from raw lwres protocol packets.
      This API can be used by clients requiring nonblocking operation,
      and is also used when implementing the server side of the lwres
      protocol, for example in the
      <command>lwresd</command>
      resolver daemon.  The use of this low-level API in clients
      and servers is outlined in the following sections.
    </para>
  </refsect1>
  <refsect1>
    <title>CLIENT-SIDE LOW-LEVEL API CALL FLOW</title>
    <para>
      When a client program wishes to make an lwres request using the
      native low-level API, it typically performs the following
      sequence of actions.
    </para>
    <para>
      (1) Allocate or use an existing <type>lwres_packet_t</type>,
      called <varname>pkt</varname> below.
    </para>
    <para>
      (2) Set <structfield>pkt.recvlength</structfield> to the maximum length
      we will accept.
      This is done so the receiver of our packets knows how large our receive
      buffer is.  The "default" is a constant in
      <filename>lwres.h</filename>: <constant>LWRES_RECVLENGTH = 4096</constant>.
    </para>
    <para>
      (3) Set <structfield>pkt.serial</structfield>
      to a unique serial number.  This value is echoed
      back to the application by the remote server.
    </para>
    <para>
      (4) Set <structfield>pkt.pktflags</structfield>.  Usually this is set to
      0.
    </para>
    <para>
      (5) Set <structfield>pkt.result</structfield> to 0.
    </para>
    <para>
      (6) Call <function>lwres_*request_render()</function>,
      or marshall in the data using the primitives
      such as <function>lwres_packet_render()</function>
      and storing the packet data.
    </para>
    <para>
      (7) Transmit the resulting buffer.
    </para>
    <para>
      (8) Call <function>lwres_*response_parse()</function>
      to parse any packets received.
    </para>
    <para>
      (9) Verify that the opcode and serial match a request, and process the
      packet specific information contained in the body.
    </para>
  </refsect1>
  <refsect1>
    <title>SERVER-SIDE LOW-LEVEL API CALL FLOW</title>
    <para>
      When implementing the server side of the lightweight resolver
      protocol using the lwres library, a sequence of actions like the
      following is typically involved in processing each request packet.
    </para>
    <para>
      Note that the same <type>lwres_packet_t</type> is used
      in both the <function>_parse()</function> and <function>_render()</function> calls,
      with only a few modifications made
      to the packet header's contents between uses.  This method is
      recommended
      as it keeps the serial, opcode, and other fields correct.
    </para>
    <para>
      (1) When a packet is received, call <function>lwres_*request_parse()</function> to
      unmarshall it.  This returns a <type>lwres_packet_t</type> (also called <varname>pkt</varname>, below)
      as well as a data specific type, such as <type>lwres_gabnrequest_t</type>.
    </para>
    <para>
      (2) Process the request in the data specific type.
    </para>
    <para>
      (3) Set the <structfield>pkt.result</structfield>,
      <structfield>pkt.recvlength</structfield> as above.  All other fields
      can
      be left untouched since they were filled in by the <function>*_parse()</function> call
      above.  If using <function>lwres_*response_render()</function>,
      <structfield>pkt.pktflags</structfield> will be set up
      properly.  Otherwise, the <constant>LWRES_LWPACKETFLAG_RESPONSE</constant> bit should be
      set.
    </para>
    <para>
      (4) Call the data specific rendering function, such as
      <function>lwres_gabnresponse_render()</function>.
    </para>
    <para>
      (5) Send the resulting packet to the client.
    </para>
    <para></para>
  </refsect1>
  <refsect1>
    <title>SEE ALSO</title>
    <para><citerefentry>
        <refentrytitle>lwres_gethostent</refentrytitle><manvolnum>3</manvolnum>
      </citerefentry>,

      <citerefentry>
        <refentrytitle>lwres_getipnode</refentrytitle><manvolnum>3</manvolnum>
      </citerefentry>,

      <citerefentry>
        <refentrytitle>lwres_getnameinfo</refentrytitle><manvolnum>3</manvolnum>
      </citerefentry>,

      <citerefentry>
        <refentrytitle>lwres_noop</refentrytitle><manvolnum>3</manvolnum>
      </citerefentry>,

      <citerefentry>
        <refentrytitle>lwres_gabn</refentrytitle><manvolnum>3</manvolnum>
      </citerefentry>,

      <citerefentry>
        <refentrytitle>lwres_gnba</refentrytitle><manvolnum>3</manvolnum>
      </citerefentry>,

      <citerefentry>
        <refentrytitle>lwres_context</refentrytitle><manvolnum>3</manvolnum>
      </citerefentry>,

      <citerefentry>
        <refentrytitle>lwres_config</refentrytitle><manvolnum>3</manvolnum>
      </citerefentry>,

      <citerefentry>
        <refentrytitle>resolver</refentrytitle><manvolnum>5</manvolnum>
      </citerefentry>,

      <citerefentry>
        <refentrytitle>lwresd</refentrytitle><manvolnum>8</manvolnum>
      </citerefentry>.

    </para>
  </refsect1>
</refentry><!--
 - Local variables:
 - mode: sgml
 - End:
-->
@


