head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.40
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.36
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.32
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.34
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.26
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.30
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.28
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.24
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.22
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.20
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.18
	OPENBSD_5_0:1.6.0.16
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.14
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.12
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.8
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.10
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.6
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	BIND_9_4_2_P1:1.1.1.5
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	BIND_9_4_2:1.1.1.5
	OPENBSD_4_2:1.5.0.4
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	BIND_9_3_4:1.1.1.4
	BIND_9_3_3:1.1.1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	BIND_9_3_2:1.1.1.3
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.2.0.8
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.6
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.4
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2007.12.09.13.39.44;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.10.19.07.59;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.05.17.36.35;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.28.17.14.08;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.05.09.18.33;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.07.49;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.49;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.36.03;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.04.05.16.44.30;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.01.10.18.20.24;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2007.12.09.12.33.55;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.6
log
@resolve conflicts
@
text
@<!--
 - Copyright (C) 2004, 2005, 2007 Internet Systems Consortium, Inc. ("ISC")
 - Copyright (C) 2000, 2001 Internet Software Consortium.
 - 
 - Permission to use, copy, modify, and distribute this software for any
 - purpose with or without fee is hereby granted, provided that the above
 - copyright notice and this permission notice appear in all copies.
 - 
 - THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 - REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 - AND FITNESS. IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 - INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 - LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 - OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 - PERFORMANCE OF THIS SOFTWARE.
-->
<!-- $ISC: lwres.html,v 1.5.18.18 2007/01/30 00:23:45 marka Exp $ -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>lwres</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.71.1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="refentry" lang="en">
<a name="id2476275"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2>Name</h2>
<p>lwres &#8212; introduction to the lightweight resolver library</p>
</div>
<div class="refsynopsisdiv">
<h2>Synopsis</h2>
<div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;lwres/lwres.h&gt;</pre></div>
</div>
<div class="refsect1" lang="en">
<a name="id2543348"></a><h2>DESCRIPTION</h2>
<p>
      The BIND 9 lightweight resolver library is a simple, name service
      independent stub resolver library.  It provides hostname-to-address
      and address-to-hostname lookup services to applications by
      transmitting lookup requests to a resolver daemon
      <span><strong class="command">lwresd</strong></span>
      running on the local host. The resover daemon performs the
      lookup using the DNS or possibly other name service protocols,
      and returns the results to the application through the library.
      The library and resolver daemon communicate using a simple
      UDP-based protocol.
    </p>
</div>
<div class="refsect1" lang="en">
<a name="id2543361"></a><h2>OVERVIEW</h2>
<p>
      The lwresd library implements multiple name service APIs.
      The standard
      <code class="function">gethostbyname()</code>,
      <code class="function">gethostbyaddr()</code>,
      <code class="function">gethostbyname_r()</code>,
      <code class="function">gethostbyaddr_r()</code>,
      <code class="function">getaddrinfo()</code>,
      <code class="function">getipnodebyname()</code>,
      and
      <code class="function">getipnodebyaddr()</code>
      functions are all supported.  To allow the lwres library to coexist
      with system libraries that define functions of the same name,
      the library defines these functions with names prefixed by
      <code class="literal">lwres_</code>.
      To define the standard names, applications must include the
      header file
      <code class="filename">&lt;lwres/netdb.h&gt;</code>
      which contains macro definitions mapping the standard function names
      into
      <code class="literal">lwres_</code>
      prefixed ones.  Operating system vendors who integrate the lwres
      library into their base distributions should rename the functions
      in the library proper so that the renaming macros are not needed.
    </p>
<p>
      The library also provides a native API consisting of the functions
      <code class="function">lwres_getaddrsbyname()</code>
      and
      <code class="function">lwres_getnamebyaddr()</code>.
      These may be called by applications that require more detailed
      control over the lookup process than the standard functions
      provide.
    </p>
<p>
      In addition to these name service independent address lookup
      functions, the library implements a new, experimental API
      for looking up arbitrary DNS resource records, using the
      <code class="function">lwres_getaddrsbyname()</code>
      function.
    </p>
<p>
      Finally, there is a low-level API for converting lookup
      requests and responses to and from raw lwres protocol packets.
      This API can be used by clients requiring nonblocking operation,
      and is also used when implementing the server side of the lwres
      protocol, for example in the
      <span><strong class="command">lwresd</strong></span>
      resolver daemon.  The use of this low-level API in clients
      and servers is outlined in the following sections.
    </p>
</div>
<div class="refsect1" lang="en">
<a name="id2543425"></a><h2>CLIENT-SIDE LOW-LEVEL API CALL FLOW</h2>
<p>
      When a client program wishes to make an lwres request using the
      native low-level API, it typically performs the following
      sequence of actions.
    </p>
<p>
      (1) Allocate or use an existing <span class="type">lwres_packet_t</span>,
      called <code class="varname">pkt</code> below.
    </p>
<p>
      (2) Set <em class="structfield"><code>pkt.recvlength</code></em> to the maximum length
      we will accept.
      This is done so the receiver of our packets knows how large our receive
      buffer is.  The "default" is a constant in
      <code class="filename">lwres.h</code>: <code class="constant">LWRES_RECVLENGTH = 4096</code>.
    </p>
<p>
      (3) Set <em class="structfield"><code>pkt.serial</code></em>
      to a unique serial number.  This value is echoed
      back to the application by the remote server.
    </p>
<p>
      (4) Set <em class="structfield"><code>pkt.pktflags</code></em>.  Usually this is set to
      0.
    </p>
<p>
      (5) Set <em class="structfield"><code>pkt.result</code></em> to 0.
    </p>
<p>
      (6) Call <code class="function">lwres_*request_render()</code>,
      or marshall in the data using the primitives
      such as <code class="function">lwres_packet_render()</code>
      and storing the packet data.
    </p>
<p>
      (7) Transmit the resulting buffer.
    </p>
<p>
      (8) Call <code class="function">lwres_*response_parse()</code>
      to parse any packets received.
    </p>
<p>
      (9) Verify that the opcode and serial match a request, and process the
      packet specific information contained in the body.
    </p>
</div>
<div class="refsect1" lang="en">
<a name="id2543573"></a><h2>SERVER-SIDE LOW-LEVEL API CALL FLOW</h2>
<p>
      When implementing the server side of the lightweight resolver
      protocol using the lwres library, a sequence of actions like the
      following is typically involved in processing each request packet.
    </p>
<p>
      Note that the same <span class="type">lwres_packet_t</span> is used
      in both the <code class="function">_parse()</code> and <code class="function">_render()</code> calls,
      with only a few modifications made
      to the packet header's contents between uses.  This method is
      recommended
      as it keeps the serial, opcode, and other fields correct.
    </p>
<p>
      (1) When a packet is received, call <code class="function">lwres_*request_parse()</code> to
      unmarshall it.  This returns a <span class="type">lwres_packet_t</span> (also called <code class="varname">pkt</code>, below)
      as well as a data specific type, such as <span class="type">lwres_gabnrequest_t</span>.
    </p>
<p>
      (2) Process the request in the data specific type.
    </p>
<p>
      (3) Set the <em class="structfield"><code>pkt.result</code></em>,
      <em class="structfield"><code>pkt.recvlength</code></em> as above.  All other fields
      can
      be left untouched since they were filled in by the <code class="function">*_parse()</code> call
      above.  If using <code class="function">lwres_*response_render()</code>,
      <em class="structfield"><code>pkt.pktflags</code></em> will be set up
      properly.  Otherwise, the <code class="constant">LWRES_LWPACKETFLAG_RESPONSE</code> bit should be
      set.
    </p>
<p>
      (4) Call the data specific rendering function, such as
      <code class="function">lwres_gabnresponse_render()</code>.
    </p>
<p>
      (5) Send the resulting packet to the client.
    </p>
<p></p>
</div>
<div class="refsect1" lang="en">
<a name="id2543656"></a><h2>SEE ALSO</h2>
<p><span class="citerefentry"><span class="refentrytitle">lwres_gethostent</span>(3)</span>,

      <span class="citerefentry"><span class="refentrytitle">lwres_getipnode</span>(3)</span>,

      <span class="citerefentry"><span class="refentrytitle">lwres_getnameinfo</span>(3)</span>,

      <span class="citerefentry"><span class="refentrytitle">lwres_noop</span>(3)</span>,

      <span class="citerefentry"><span class="refentrytitle">lwres_gabn</span>(3)</span>,

      <span class="citerefentry"><span class="refentrytitle">lwres_gnba</span>(3)</span>,

      <span class="citerefentry"><span class="refentrytitle">lwres_context</span>(3)</span>,

      <span class="citerefentry"><span class="refentrytitle">lwres_config</span>(3)</span>,

      <span class="citerefentry"><span class="refentrytitle">resolver</span>(5)</span>,

      <span class="citerefentry"><span class="refentrytitle">lwresd</span>(8)</span>.

    </p>
</div>
</div></body>
</html>
@


1.5
log
@resolve conflicts and regen configure script
@
text
@d2 1
a2 1
 - Copyright (C) 2004, 2005 Internet Systems Consortium, Inc. ("ISC")
d17 1
a17 1
<!-- $ISC: lwres.html,v 1.4.2.1.4.12 2006/06/29 13:02:31 marka Exp $ -->
d22 1
a22 1
<meta name="generator" content="DocBook XSL Stylesheets V1.70.1">
d25 1
a25 1
<a name="id2482688"></a><div class="titlepage"></div>
d35 1
a35 1
<a name="id2549397"></a><h2>DESCRIPTION</h2>
d37 11
a47 11
The BIND 9 lightweight resolver library is a simple, name service
independent stub resolver library.  It provides hostname-to-address
and address-to-hostname lookup services to applications by
transmitting lookup requests to a resolver daemon
<span><strong class="command">lwresd</strong></span>
running on the local host. The resover daemon performs the
lookup using the DNS or possibly other name service protocols,
and returns the results to the application through the library.  
The library and resolver daemon communicate using a simple
UDP-based protocol.
</p>
d50 1
a50 1
<a name="id2549410"></a><h2>OVERVIEW</h2>
d52 50
a101 50
The lwresd library implements multiple name service APIs.
The standard
<code class="function">gethostbyname()</code>,
<code class="function">gethostbyaddr()</code>,
<code class="function">gethostbyname_r()</code>,
<code class="function">gethostbyaddr_r()</code>,
<code class="function">getaddrinfo()</code>,
<code class="function">getipnodebyname()</code>,
and
<code class="function">getipnodebyaddr()</code>
functions are all supported.  To allow the lwres library to coexist
with system libraries that define functions of the same name,
the library defines these functions with names prefixed by
<code class="literal">lwres_</code>.
To define the standard names, applications must include the
header file
<code class="filename">&lt;lwres/netdb.h&gt;</code>
which contains macro definitions mapping the standard function names
into
<code class="literal">lwres_</code>
prefixed ones.  Operating system vendors who integrate the lwres
library into their base distributions should rename the functions
in the library proper so that the renaming macros are not needed.
</p>
<p>
The library also provides a native API consisting of the functions
<code class="function">lwres_getaddrsbyname()</code>
and
<code class="function">lwres_getnamebyaddr()</code>.
These may be called by applications that require more detailed
control over the lookup process than the standard functions
provide.
</p>
<p>
In addition to these name service independent address lookup
functions, the library implements a new, experimental API
for looking up arbitrary DNS resource records, using the
<code class="function">lwres_getaddrsbyname()</code>
function.
</p>
<p>
Finally, there is a low-level API for converting lookup
requests and responses to and from raw lwres protocol packets.  
This API can be used by clients requiring nonblocking operation, 
and is also used when implementing the server side of the lwres
protocol, for example in the
<span><strong class="command">lwresd</strong></span>
resolver daemon.  The use of this low-level API in clients
and servers is outlined in the following sections.
</p>
d104 1
a104 1
<a name="id2549474"></a><h2>CLIENT-SIDE LOW-LEVEL API CALL FLOW</h2>
d106 44
a149 42
When a client program wishes to make an lwres request using the
native low-level API, it typically performs the following 
sequence of actions.
</p>
<p>
(1) Allocate or use an existing <span class="type">lwres_packet_t</span>,
called <code class="varname">pkt</code> below.
</p>
<p>
(2) Set <em class="structfield"><code>pkt.recvlength</code></em> to the maximum length we will accept.  
This is done so the receiver of our packets knows how large our receive 
buffer is.  The "default" is a constant in
<code class="filename">lwres.h</code>: <code class="constant">LWRES_RECVLENGTH = 4096</code>.
</p>
<p>
(3) Set <em class="structfield"><code>pkt.serial</code></em>
to a unique serial number.  This value is echoed
back to the application by the remote server.
</p>
<p>
(4) Set <em class="structfield"><code>pkt.pktflags</code></em>.  Usually this is set to 0.
</p>
<p>
(5) Set <em class="structfield"><code>pkt.result</code></em> to 0.
</p>
<p>
(6) Call <code class="function">lwres_*request_render()</code>, 
or marshall in the data using the primitives
such as <code class="function">lwres_packet_render()</code>
and storing the packet data.
</p>
<p>
(7) Transmit the resulting buffer.
</p>
<p>
(8) Call <code class="function">lwres_*response_parse()</code>
to parse any packets received.
</p>
<p>
(9) Verify that the opcode and serial match a request, and process the
packet specific information contained in the body.
</p>
d152 1
a152 1
<a name="id2549689"></a><h2>SERVER-SIDE LOW-LEVEL API CALL FLOW</h2>
d154 38
a191 37
When implementing the server side of the lightweight resolver
protocol using the lwres library, a sequence of actions like the
following is typically involved in processing each request packet.
</p>
<p>
Note that the same <span class="type">lwres_packet_t</span> is used
in both the <code class="function">_parse()</code> and <code class="function">_render()</code> calls,
with only a few modifications made
to the packet header's contents between uses.  This method is recommended
as it keeps the serial, opcode, and other fields correct.
</p>
<p>
(1) When a packet is received, call <code class="function">lwres_*request_parse()</code> to
unmarshall it.  This returns a <span class="type">lwres_packet_t</span> (also called <code class="varname">pkt</code>, below)
as well as a data specific type, such as <span class="type">lwres_gabnrequest_t</span>.
</p>
<p>
(2) Process the request in the data specific type.
</p>
<p>
(3) Set the <em class="structfield"><code>pkt.result</code></em>,
<em class="structfield"><code>pkt.recvlength</code></em> as above.  All other fields can
be left untouched since they were filled in by the <code class="function">*_parse()</code> call
above.  If using <code class="function">lwres_*response_render()</code>,
<em class="structfield"><code>pkt.pktflags</code></em> will be set up
properly.  Otherwise, the <code class="constant">LWRES_LWPACKETFLAG_RESPONSE</code> bit should be
set.
</p>
<p>
(4) Call the data specific rendering function, such as
<code class="function">lwres_gabnresponse_render()</code>.
</p>
<p>
(5) Send the resulting packet to the client.
</p>
<p>
</p>
d194 2
a195 3
<a name="id2549774"></a><h2>SEE ALSO</h2>
<p>
<span class="citerefentry"><span class="refentrytitle">lwres_gethostent</span>(3)</span>,
d197 1
a197 1
<span class="citerefentry"><span class="refentrytitle">lwres_getipnode</span>(3)</span>,
d199 1
a199 1
<span class="citerefentry"><span class="refentrytitle">lwres_getnameinfo</span>(3)</span>,
d201 1
a201 1
<span class="citerefentry"><span class="refentrytitle">lwres_noop</span>(3)</span>,
d203 1
a203 1
<span class="citerefentry"><span class="refentrytitle">lwres_gabn</span>(3)</span>,
d205 1
a205 1
<span class="citerefentry"><span class="refentrytitle">lwres_gnba</span>(3)</span>,
d207 1
a207 1
<span class="citerefentry"><span class="refentrytitle">lwres_context</span>(3)</span>,
d209 1
a209 1
<span class="citerefentry"><span class="refentrytitle">lwres_config</span>(3)</span>,
d211 1
a211 1
<span class="citerefentry"><span class="refentrytitle">resolver</span>(5)</span>,
d213 1
a213 1
<span class="citerefentry"><span class="refentrytitle">lwresd</span>(8)</span>.
d215 1
a215 1
</p>
@


1.4
log
@resolve conflicts
@
text
@d17 1
a17 1
<!-- $ISC: lwres.html,v 1.4.2.1.4.9 2005/10/13 02:33:54 marka Exp $ -->
d22 1
a22 1
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
d25 1
a25 1
<a name="id2463721"></a><div class="titlepage"></div>
d35 1
a35 1
<a name="id2525832"></a><h2>DESCRIPTION</h2>
d50 1
a50 1
<a name="id2525845"></a><h2>OVERVIEW</h2>
d104 1
a104 1
<a name="id2525909"></a><h2>CLIENT-SIDE LOW-LEVEL API CALL FLOW</h2>
d150 1
a150 1
<a name="id2526056"></a><h2>SERVER-SIDE LOW-LEVEL API CALL FLOW</h2>
d191 1
a191 1
<a name="id2526141"></a><h2>SEE ALSO</h2>
@


1.3
log
@resolve conflicts
@
text
@d2 3
a4 3
 - Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 - Copyright (C) 2001  Internet Software Consortium.
 -
d8 1
a8 1
 -
d11 1
a11 1
 - AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
d17 21
a37 61

<!-- $ISC: lwres.html,v 1.4.2.1.4.2 2004/08/22 23:39:02 marka Exp $ -->

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>lwres</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"></HEAD
><BODY
CLASS="REFENTRY"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><H1
><A
NAME="AEN1"
></A
>lwres</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN8"
></A
><H2
>Name</H2
>lwres&nbsp;--&nbsp;introduction to the lightweight resolver library</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN11"
></A
><H2
>Synopsis</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><A
NAME="AEN12"
></A
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &lt;lwres/lwres.h&gt;</PRE
><P
></P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN14"
></A
><H2
>DESCRIPTION</H2
><P
>The BIND 9 lightweight resolver library is a simple, name service
d41 1
a41 4
<B
CLASS="COMMAND"
>lwresd</B
>
d46 7
a52 11
UDP-based protocol.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN18"
></A
><H2
>OVERVIEW</H2
><P
>The lwresd library implements multiple name service APIs.
d54 6
a59 24
<CODE
CLASS="FUNCTION"
>gethostbyname()</CODE
>,
<CODE
CLASS="FUNCTION"
>gethostbyaddr()</CODE
>,
<CODE
CLASS="FUNCTION"
>gethostbyname_r()</CODE
>,
<CODE
CLASS="FUNCTION"
>gethostbyaddr_r()</CODE
>,
<CODE
CLASS="FUNCTION"
>getaddrinfo()</CODE
>,
<CODE
CLASS="FUNCTION"
>getipnodebyname()</CODE
>,
d61 1
a61 4
<CODE
CLASS="FUNCTION"
>getipnodebyaddr()</CODE
>
d65 1
a65 4
<VAR
CLASS="LITERAL"
>lwres_</VAR
>.
d68 1
a68 4
<TT
CLASS="FILENAME"
>&lt;lwres/netdb.h&gt;</TT
>
d71 1
a71 4
<VAR
CLASS="LITERAL"
>lwres_</VAR
>
d74 5
a78 7
in the library proper so that the renaming macros are not needed.</P
><P
>The library also provides a native API consisting of the functions
<CODE
CLASS="FUNCTION"
>lwres_getaddrsbyname()</CODE
>
d80 1
a80 4
<CODE
CLASS="FUNCTION"
>lwres_getnamebyaddr()</CODE
>.
d83 4
a86 3
provide.</P
><P
>In addition to these name service independent address lookup
d89 5
a93 7
<CODE
CLASS="FUNCTION"
>lwres_getaddrsbyname()</CODE
>
function.</P
><P
>Finally, there is a low-level API for converting lookup
d98 1
a98 4
<B
CLASS="COMMAND"
>lwresd</B
>
d100 7
a106 11
and servers is outlined in the following sections.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN38"
></A
><H2
>CLIENT-SIDE LOW-LEVEL API CALL FLOW</H2
><P
>When a client program wishes to make an lwres request using the
d108 8
a115 15
sequence of actions.</P
><P
>(1) Allocate or use an existing <SPAN
CLASS="TYPE"
>lwres_packet_t</SPAN
>,
called <VAR
CLASS="VARNAME"
>pkt</VAR
> below.</P
><P
>(2) Set <CODE
CLASS="STRUCTFIELD"
>pkt.recvlength</CODE
> to the maximum length we will accept.  
d118 4
a121 12
<TT
CLASS="FILENAME"
>lwres.h</TT
>: <CODE
CLASS="CONSTANT"
>LWRES_RECVLENGTH = 4096</CODE
>.</P
><P
>(3) Set <CODE
CLASS="STRUCTFIELD"
>pkt.serial</CODE
>
d123 10
a132 16
back to the application by the remote server.</P
><P
>(4) Set <CODE
CLASS="STRUCTFIELD"
>pkt.pktflags</CODE
>.  Usually this is set to 0.</P
><P
>(5) Set <CODE
CLASS="STRUCTFIELD"
>pkt.result</CODE
> to 0.</P
><P
>(6) Call <CODE
CLASS="FUNCTION"
>lwres_*request_render()</CODE
>, 
d134 19
a152 26
such as <CODE
CLASS="FUNCTION"
>lwres_packet_render()</CODE
>
and storing the packet data.</P
><P
>(7) Transmit the resulting buffer.</P
><P
>(8) Call <CODE
CLASS="FUNCTION"
>lwres_*response_parse()</CODE
>
to parse any packets received.</P
><P
>(9) Verify that the opcode and serial match a request, and process the
packet specific information contained in the body.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN61"
></A
><H2
>SERVER-SIDE LOW-LEVEL API CALL FLOW</H2
><P
>When implementing the server side of the lightweight resolver
d154 5
a158 13
following is typically involved in processing each request packet.</P
><P
>Note that the same <SPAN
CLASS="TYPE"
>lwres_packet_t</SPAN
> is used
in both the <CODE
CLASS="FUNCTION"
>_parse()</CODE
> and <CODE
CLASS="FUNCTION"
>_render()</CODE
> calls,
d161 56
a216 147
as it keeps the serial, opcode, and other fields correct.</P
><P
>(1) When a packet is received, call <CODE
CLASS="FUNCTION"
>lwres_*request_parse()</CODE
> to
unmarshall it.  This returns a <SPAN
CLASS="TYPE"
>lwres_packet_t</SPAN
> (also called <VAR
CLASS="VARNAME"
>pkt</VAR
>, below)
as well as a data specific type, such as <SPAN
CLASS="TYPE"
>lwres_gabnrequest_t</SPAN
>.</P
><P
>(2) Process the request in the data specific type.</P
><P
>(3) Set the <CODE
CLASS="STRUCTFIELD"
>pkt.result</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>pkt.recvlength</CODE
> as above.  All other fields can
be left untouched since they were filled in by the <CODE
CLASS="FUNCTION"
>*_parse()</CODE
> call
above.  If using <CODE
CLASS="FUNCTION"
>lwres_*response_render()</CODE
>,
<CODE
CLASS="STRUCTFIELD"
>pkt.pktflags</CODE
> will be set up
properly.  Otherwise, the <CODE
CLASS="CONSTANT"
>LWRES_LWPACKETFLAG_RESPONSE</CODE
> bit should be
set.</P
><P
>(4) Call the data specific rendering function, such as
<CODE
CLASS="FUNCTION"
>lwres_gabnresponse_render()</CODE
>.</P
><P
>(5) Send the resulting packet to the client.</P
><P
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN85"
></A
><H2
>SEE ALSO</H2
><P
><SPAN
CLASS="CITEREFENTRY"
><SPAN
CLASS="REFENTRYTITLE"
>lwres_gethostent</SPAN
>(3)</SPAN
>,

<SPAN
CLASS="CITEREFENTRY"
><SPAN
CLASS="REFENTRYTITLE"
>lwres_getipnode</SPAN
>(3)</SPAN
>,

<SPAN
CLASS="CITEREFENTRY"
><SPAN
CLASS="REFENTRYTITLE"
>lwres_getnameinfo</SPAN
>(3)</SPAN
>,

<SPAN
CLASS="CITEREFENTRY"
><SPAN
CLASS="REFENTRYTITLE"
>lwres_noop</SPAN
>(3)</SPAN
>,

<SPAN
CLASS="CITEREFENTRY"
><SPAN
CLASS="REFENTRYTITLE"
>lwres_gabn</SPAN
>(3)</SPAN
>,

<SPAN
CLASS="CITEREFENTRY"
><SPAN
CLASS="REFENTRYTITLE"
>lwres_gnba</SPAN
>(3)</SPAN
>,

<SPAN
CLASS="CITEREFENTRY"
><SPAN
CLASS="REFENTRYTITLE"
>lwres_context</SPAN
>(3)</SPAN
>,

<SPAN
CLASS="CITEREFENTRY"
><SPAN
CLASS="REFENTRYTITLE"
>lwres_config</SPAN
>(3)</SPAN
>,

<SPAN
CLASS="CITEREFENTRY"
><SPAN
CLASS="REFENTRYTITLE"
>resolver</SPAN
>(5)</SPAN
>,

<SPAN
CLASS="CITEREFENTRY"
><SPAN
CLASS="REFENTRYTITLE"
>lwresd</SPAN
>(8)</SPAN
>.&#13;</P
></DIV
></BODY
></HTML
>
@


1.2
log
@update to BIND 9.2.2-release. ok millert@@
@
text
@d2 3
a4 2
 - Copyright (C) 2000, 2001  Internet Software Consortium.
 - 
d8 8
a15 9
 - 
 - THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 - DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 - IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 - INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 - INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 - FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 - NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 - WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d17 4
d27 1
a27 2
CONTENT="Modular DocBook HTML Stylesheet Version 1.73
"></HEAD
d38 2
a39 2
>lwres</A
></H1
d57 2
a61 2
><P
></P
d101 1
a101 1
<TT
d103 1
a103 1
>gethostbyname()</TT
d105 1
a105 1
<TT
d107 1
a107 1
>gethostbyaddr()</TT
d109 1
a109 1
<TT
d111 1
a111 1
>gethostbyname_r()</TT
d113 1
a113 1
<TT
d115 1
a115 1
>gethostbyaddr_r()</TT
d117 1
a117 1
<TT
d119 1
a119 1
>getaddrinfo()</TT
d121 1
a121 1
<TT
d123 1
a123 1
>getipnodebyname()</TT
d126 1
a126 1
<TT
d128 1
a128 1
>getipnodebyaddr()</TT
d133 1
a133 1
<TT
d135 1
a135 1
>lwres_</TT
d145 1
a145 1
<TT
d147 1
a147 1
>lwres_</TT
d154 1
a154 1
<TT
d156 1
a156 1
>lwres_getaddrsbyname()</TT
d159 1
a159 1
<TT
d161 1
a161 1
>lwres_getnamebyaddr()</TT
d170 1
a170 1
<TT
d172 1
a172 1
>lwres_getaddrsbyname()</TT
d204 1
a204 1
called <TT
d206 1
a206 1
>pkt</TT
d209 1
a209 1
>(2) Set <TT
d211 1
a211 3
><I
>pkt.recvlength</I
></TT
d218 1
a218 1
>: <TT
d220 1
a220 1
>LWRES_RECVLENGTH = 4096</TT
d223 1
a223 1
>(3) Set <TT
d225 1
a225 3
><I
>pkt.serial</I
></TT
d230 1
a230 1
>(4) Set <TT
d232 1
a232 3
><I
>pkt.pktflags</I
></TT
d235 1
a235 1
>(5) Set <TT
d237 1
a237 3
><I
>pkt.result</I
></TT
d240 1
a240 1
>(6) Call <TT
d242 1
a242 1
>lwres_*request_render()</TT
d245 1
a245 1
such as <TT
d247 1
a247 1
>lwres_packet_render()</TT
d253 1
a253 1
>(8) Call <TT
d255 1
a255 1
>lwres_*response_parse()</TT
d278 1
a278 1
in both the <TT
d280 2
a281 2
>_parse()</TT
> and <TT
d283 1
a283 1
>_render()</TT
d289 1
a289 1
>(1) When a packet is received, call <TT
d291 1
a291 1
>lwres_*request_parse()</TT
d296 1
a296 1
> (also called <TT
d298 1
a298 1
>pkt</TT
d307 1
a307 1
>(3) Set the <TT
d309 1
a309 3
><I
>pkt.result</I
></TT
d311 1
a311 1
<TT
d313 1
a313 3
><I
>pkt.recvlength</I
></TT
d315 1
a315 1
be left untouched since they were filled in by the <TT
d317 1
a317 1
>*_parse()</TT
d319 1
a319 1
above.  If using <TT
d321 1
a321 1
>lwres_*response_render()</TT
d323 1
a323 1
<TT
d325 1
a325 3
><I
>pkt.pktflags</I
></TT
d327 1
a327 1
properly.  Otherwise, the <TT
d329 1
a329 1
>LWRES_LWPACKETFLAG_RESPONSE</TT
d334 1
a334 1
<TT
d336 1
a336 1
>lwres_gabnresponse_render()</TT
@


1.1
log
@Initial revision
@
text
@d23 1
a23 1
CONTENT="Modular DocBook HTML Stylesheet Version 1.61
d444 1
a444 1
>@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 2
a3 3
 - Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 - Copyright (C) 2001  Internet Software Consortium.
 -
d7 9
a15 8
 -
 - THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 - REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 - AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 - INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 - LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 - OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 - PERFORMANCE OF THIS SOFTWARE.
a16 4

<!-- $ISC: lwres.html,v 1.4.2.1.4.2 2004/08/22 23:39:02 marka Exp $ -->

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
d23 2
a24 1
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"></HEAD
d35 2
a36 2
></A
>lwres</H1
a53 2
><P
></P
d57 2
d98 1
a98 1
<CODE
d100 1
a100 1
>gethostbyname()</CODE
d102 1
a102 1
<CODE
d104 1
a104 1
>gethostbyaddr()</CODE
d106 1
a106 1
<CODE
d108 1
a108 1
>gethostbyname_r()</CODE
d110 1
a110 1
<CODE
d112 1
a112 1
>gethostbyaddr_r()</CODE
d114 1
a114 1
<CODE
d116 1
a116 1
>getaddrinfo()</CODE
d118 1
a118 1
<CODE
d120 1
a120 1
>getipnodebyname()</CODE
d123 1
a123 1
<CODE
d125 1
a125 1
>getipnodebyaddr()</CODE
d130 1
a130 1
<VAR
d132 1
a132 1
>lwres_</VAR
d142 1
a142 1
<VAR
d144 1
a144 1
>lwres_</VAR
d151 1
a151 1
<CODE
d153 1
a153 1
>lwres_getaddrsbyname()</CODE
d156 1
a156 1
<CODE
d158 1
a158 1
>lwres_getnamebyaddr()</CODE
d167 1
a167 1
<CODE
d169 1
a169 1
>lwres_getaddrsbyname()</CODE
d201 1
a201 1
called <VAR
d203 1
a203 1
>pkt</VAR
d206 1
a206 1
>(2) Set <CODE
d208 3
a210 1
>pkt.recvlength</CODE
d217 1
a217 1
>: <CODE
d219 1
a219 1
>LWRES_RECVLENGTH = 4096</CODE
d222 1
a222 1
>(3) Set <CODE
d224 3
a226 1
>pkt.serial</CODE
d231 1
a231 1
>(4) Set <CODE
d233 3
a235 1
>pkt.pktflags</CODE
d238 1
a238 1
>(5) Set <CODE
d240 3
a242 1
>pkt.result</CODE
d245 1
a245 1
>(6) Call <CODE
d247 1
a247 1
>lwres_*request_render()</CODE
d250 1
a250 1
such as <CODE
d252 1
a252 1
>lwres_packet_render()</CODE
d258 1
a258 1
>(8) Call <CODE
d260 1
a260 1
>lwres_*response_parse()</CODE
d283 1
a283 1
in both the <CODE
d285 2
a286 2
>_parse()</CODE
> and <CODE
d288 1
a288 1
>_render()</CODE
d294 1
a294 1
>(1) When a packet is received, call <CODE
d296 1
a296 1
>lwres_*request_parse()</CODE
d301 1
a301 1
> (also called <VAR
d303 1
a303 1
>pkt</VAR
d312 1
a312 1
>(3) Set the <CODE
d314 3
a316 1
>pkt.result</CODE
d318 1
a318 1
<CODE
d320 3
a322 1
>pkt.recvlength</CODE
d324 1
a324 1
be left untouched since they were filled in by the <CODE
d326 1
a326 1
>*_parse()</CODE
d328 1
a328 1
above.  If using <CODE
d330 1
a330 1
>lwres_*response_render()</CODE
d332 1
a332 1
<CODE
d334 3
a336 1
>pkt.pktflags</CODE
d338 1
a338 1
properly.  Otherwise, the <CODE
d340 1
a340 1
>LWRES_LWPACKETFLAG_RESPONSE</CODE
d345 1
a345 1
<CODE
d347 1
a347 1
>lwres_gabnresponse_render()</CODE
d444 1
a444 1
>
@


1.1.1.3
log
@ISC BIND release 9.3.2
@
text
@d2 3
a4 3
 - Copyright (C) 2004, 2005 Internet Systems Consortium, Inc. ("ISC")
 - Copyright (C) 2000, 2001 Internet Software Consortium.
 - 
d8 1
a8 1
 - 
d11 1
a11 1
 - AND FITNESS. IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
d17 61
a77 21
<!-- $ISC: lwres.html,v 1.4.2.1.4.9 2005/10/13 02:33:54 marka Exp $ -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>lwres</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="refentry" lang="en">
<a name="id2463721"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2>Name</h2>
<p>lwres &#8212; introduction to the lightweight resolver library</p>
</div>
<div class="refsynopsisdiv">
<h2>Synopsis</h2>
<div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;lwres/lwres.h&gt;</pre></div>
</div>
<div class="refsect1" lang="en">
<a name="id2525832"></a><h2>DESCRIPTION</h2>
<p>
The BIND 9 lightweight resolver library is a simple, name service
d81 4
a84 1
<span><strong class="command">lwresd</strong></span>
d89 11
a99 7
UDP-based protocol.
</p>
</div>
<div class="refsect1" lang="en">
<a name="id2525845"></a><h2>OVERVIEW</h2>
<p>
The lwresd library implements multiple name service APIs.
d101 24
a124 6
<code class="function">gethostbyname()</code>,
<code class="function">gethostbyaddr()</code>,
<code class="function">gethostbyname_r()</code>,
<code class="function">gethostbyaddr_r()</code>,
<code class="function">getaddrinfo()</code>,
<code class="function">getipnodebyname()</code>,
d126 4
a129 1
<code class="function">getipnodebyaddr()</code>
d133 4
a136 1
<code class="literal">lwres_</code>.
d139 4
a142 1
<code class="filename">&lt;lwres/netdb.h&gt;</code>
d145 4
a148 1
<code class="literal">lwres_</code>
d151 7
a157 5
in the library proper so that the renaming macros are not needed.
</p>
<p>
The library also provides a native API consisting of the functions
<code class="function">lwres_getaddrsbyname()</code>
d159 4
a162 1
<code class="function">lwres_getnamebyaddr()</code>.
d165 3
a167 4
provide.
</p>
<p>
In addition to these name service independent address lookup
d170 7
a176 5
<code class="function">lwres_getaddrsbyname()</code>
function.
</p>
<p>
Finally, there is a low-level API for converting lookup
d181 4
a184 1
<span><strong class="command">lwresd</strong></span>
d186 11
a196 7
and servers is outlined in the following sections.
</p>
</div>
<div class="refsect1" lang="en">
<a name="id2525909"></a><h2>CLIENT-SIDE LOW-LEVEL API CALL FLOW</h2>
<p>
When a client program wishes to make an lwres request using the
d198 15
a212 8
sequence of actions.
</p>
<p>
(1) Allocate or use an existing <span class="type">lwres_packet_t</span>,
called <code class="varname">pkt</code> below.
</p>
<p>
(2) Set <em class="structfield"><code>pkt.recvlength</code></em> to the maximum length we will accept.  
d215 12
a226 4
<code class="filename">lwres.h</code>: <code class="constant">LWRES_RECVLENGTH = 4096</code>.
</p>
<p>
(3) Set <em class="structfield"><code>pkt.serial</code></em>
d228 16
a243 10
back to the application by the remote server.
</p>
<p>
(4) Set <em class="structfield"><code>pkt.pktflags</code></em>.  Usually this is set to 0.
</p>
<p>
(5) Set <em class="structfield"><code>pkt.result</code></em> to 0.
</p>
<p>
(6) Call <code class="function">lwres_*request_render()</code>, 
d245 26
a270 19
such as <code class="function">lwres_packet_render()</code>
and storing the packet data.
</p>
<p>
(7) Transmit the resulting buffer.
</p>
<p>
(8) Call <code class="function">lwres_*response_parse()</code>
to parse any packets received.
</p>
<p>
(9) Verify that the opcode and serial match a request, and process the
packet specific information contained in the body.
</p>
</div>
<div class="refsect1" lang="en">
<a name="id2526056"></a><h2>SERVER-SIDE LOW-LEVEL API CALL FLOW</h2>
<p>
When implementing the server side of the lightweight resolver
d272 13
a284 5
following is typically involved in processing each request packet.
</p>
<p>
Note that the same <span class="type">lwres_packet_t</span> is used
in both the <code class="function">_parse()</code> and <code class="function">_render()</code> calls,
d287 147
a433 56
as it keeps the serial, opcode, and other fields correct.
</p>
<p>
(1) When a packet is received, call <code class="function">lwres_*request_parse()</code> to
unmarshall it.  This returns a <span class="type">lwres_packet_t</span> (also called <code class="varname">pkt</code>, below)
as well as a data specific type, such as <span class="type">lwres_gabnrequest_t</span>.
</p>
<p>
(2) Process the request in the data specific type.
</p>
<p>
(3) Set the <em class="structfield"><code>pkt.result</code></em>,
<em class="structfield"><code>pkt.recvlength</code></em> as above.  All other fields can
be left untouched since they were filled in by the <code class="function">*_parse()</code> call
above.  If using <code class="function">lwres_*response_render()</code>,
<em class="structfield"><code>pkt.pktflags</code></em> will be set up
properly.  Otherwise, the <code class="constant">LWRES_LWPACKETFLAG_RESPONSE</code> bit should be
set.
</p>
<p>
(4) Call the data specific rendering function, such as
<code class="function">lwres_gabnresponse_render()</code>.
</p>
<p>
(5) Send the resulting packet to the client.
</p>
<p>
</p>
</div>
<div class="refsect1" lang="en">
<a name="id2526141"></a><h2>SEE ALSO</h2>
<p>
<span class="citerefentry"><span class="refentrytitle">lwres_gethostent</span>(3)</span>,

<span class="citerefentry"><span class="refentrytitle">lwres_getipnode</span>(3)</span>,

<span class="citerefentry"><span class="refentrytitle">lwres_getnameinfo</span>(3)</span>,

<span class="citerefentry"><span class="refentrytitle">lwres_noop</span>(3)</span>,

<span class="citerefentry"><span class="refentrytitle">lwres_gabn</span>(3)</span>,

<span class="citerefentry"><span class="refentrytitle">lwres_gnba</span>(3)</span>,

<span class="citerefentry"><span class="refentrytitle">lwres_context</span>(3)</span>,

<span class="citerefentry"><span class="refentrytitle">lwres_config</span>(3)</span>,

<span class="citerefentry"><span class="refentrytitle">resolver</span>(5)</span>,

<span class="citerefentry"><span class="refentrytitle">lwresd</span>(8)</span>.

</p>
</div>
</div></body>
</html>
@


1.1.1.4
log
@ISC BIND release 9.3.3
@
text
@d17 1
a17 1
<!-- $ISC: lwres.html,v 1.4.2.1.4.12 2006/06/29 13:02:31 marka Exp $ -->
d22 1
a22 1
<meta name="generator" content="DocBook XSL Stylesheets V1.70.1">
d25 1
a25 1
<a name="id2482688"></a><div class="titlepage"></div>
d35 1
a35 1
<a name="id2549397"></a><h2>DESCRIPTION</h2>
d50 1
a50 1
<a name="id2549410"></a><h2>OVERVIEW</h2>
d104 1
a104 1
<a name="id2549474"></a><h2>CLIENT-SIDE LOW-LEVEL API CALL FLOW</h2>
d150 1
a150 1
<a name="id2549689"></a><h2>SERVER-SIDE LOW-LEVEL API CALL FLOW</h2>
d191 1
a191 1
<a name="id2549774"></a><h2>SEE ALSO</h2>
@


1.1.1.5
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 - Copyright (C) 2004, 2005, 2007 Internet Systems Consortium, Inc. ("ISC")
d17 1
a17 1
<!-- $ISC: lwres.html,v 1.5.18.18 2007/01/30 00:23:45 marka Exp $ -->
d22 1
a22 1
<meta name="generator" content="DocBook XSL Stylesheets V1.71.1">
d25 1
a25 1
<a name="id2476275"></a><div class="titlepage"></div>
d35 1
a35 1
<a name="id2543348"></a><h2>DESCRIPTION</h2>
d37 11
a47 11
      The BIND 9 lightweight resolver library is a simple, name service
      independent stub resolver library.  It provides hostname-to-address
      and address-to-hostname lookup services to applications by
      transmitting lookup requests to a resolver daemon
      <span><strong class="command">lwresd</strong></span>
      running on the local host. The resover daemon performs the
      lookup using the DNS or possibly other name service protocols,
      and returns the results to the application through the library.
      The library and resolver daemon communicate using a simple
      UDP-based protocol.
    </p>
d50 1
a50 1
<a name="id2543361"></a><h2>OVERVIEW</h2>
d52 50
a101 50
      The lwresd library implements multiple name service APIs.
      The standard
      <code class="function">gethostbyname()</code>,
      <code class="function">gethostbyaddr()</code>,
      <code class="function">gethostbyname_r()</code>,
      <code class="function">gethostbyaddr_r()</code>,
      <code class="function">getaddrinfo()</code>,
      <code class="function">getipnodebyname()</code>,
      and
      <code class="function">getipnodebyaddr()</code>
      functions are all supported.  To allow the lwres library to coexist
      with system libraries that define functions of the same name,
      the library defines these functions with names prefixed by
      <code class="literal">lwres_</code>.
      To define the standard names, applications must include the
      header file
      <code class="filename">&lt;lwres/netdb.h&gt;</code>
      which contains macro definitions mapping the standard function names
      into
      <code class="literal">lwres_</code>
      prefixed ones.  Operating system vendors who integrate the lwres
      library into their base distributions should rename the functions
      in the library proper so that the renaming macros are not needed.
    </p>
<p>
      The library also provides a native API consisting of the functions
      <code class="function">lwres_getaddrsbyname()</code>
      and
      <code class="function">lwres_getnamebyaddr()</code>.
      These may be called by applications that require more detailed
      control over the lookup process than the standard functions
      provide.
    </p>
<p>
      In addition to these name service independent address lookup
      functions, the library implements a new, experimental API
      for looking up arbitrary DNS resource records, using the
      <code class="function">lwres_getaddrsbyname()</code>
      function.
    </p>
<p>
      Finally, there is a low-level API for converting lookup
      requests and responses to and from raw lwres protocol packets.
      This API can be used by clients requiring nonblocking operation,
      and is also used when implementing the server side of the lwres
      protocol, for example in the
      <span><strong class="command">lwresd</strong></span>
      resolver daemon.  The use of this low-level API in clients
      and servers is outlined in the following sections.
    </p>
d104 1
a104 1
<a name="id2543425"></a><h2>CLIENT-SIDE LOW-LEVEL API CALL FLOW</h2>
d106 42
a147 44
      When a client program wishes to make an lwres request using the
      native low-level API, it typically performs the following
      sequence of actions.
    </p>
<p>
      (1) Allocate or use an existing <span class="type">lwres_packet_t</span>,
      called <code class="varname">pkt</code> below.
    </p>
<p>
      (2) Set <em class="structfield"><code>pkt.recvlength</code></em> to the maximum length
      we will accept.
      This is done so the receiver of our packets knows how large our receive
      buffer is.  The "default" is a constant in
      <code class="filename">lwres.h</code>: <code class="constant">LWRES_RECVLENGTH = 4096</code>.
    </p>
<p>
      (3) Set <em class="structfield"><code>pkt.serial</code></em>
      to a unique serial number.  This value is echoed
      back to the application by the remote server.
    </p>
<p>
      (4) Set <em class="structfield"><code>pkt.pktflags</code></em>.  Usually this is set to
      0.
    </p>
<p>
      (5) Set <em class="structfield"><code>pkt.result</code></em> to 0.
    </p>
<p>
      (6) Call <code class="function">lwres_*request_render()</code>,
      or marshall in the data using the primitives
      such as <code class="function">lwres_packet_render()</code>
      and storing the packet data.
    </p>
<p>
      (7) Transmit the resulting buffer.
    </p>
<p>
      (8) Call <code class="function">lwres_*response_parse()</code>
      to parse any packets received.
    </p>
<p>
      (9) Verify that the opcode and serial match a request, and process the
      packet specific information contained in the body.
    </p>
d150 1
a150 1
<a name="id2543573"></a><h2>SERVER-SIDE LOW-LEVEL API CALL FLOW</h2>
d152 37
a188 38
      When implementing the server side of the lightweight resolver
      protocol using the lwres library, a sequence of actions like the
      following is typically involved in processing each request packet.
    </p>
<p>
      Note that the same <span class="type">lwres_packet_t</span> is used
      in both the <code class="function">_parse()</code> and <code class="function">_render()</code> calls,
      with only a few modifications made
      to the packet header's contents between uses.  This method is
      recommended
      as it keeps the serial, opcode, and other fields correct.
    </p>
<p>
      (1) When a packet is received, call <code class="function">lwres_*request_parse()</code> to
      unmarshall it.  This returns a <span class="type">lwres_packet_t</span> (also called <code class="varname">pkt</code>, below)
      as well as a data specific type, such as <span class="type">lwres_gabnrequest_t</span>.
    </p>
<p>
      (2) Process the request in the data specific type.
    </p>
<p>
      (3) Set the <em class="structfield"><code>pkt.result</code></em>,
      <em class="structfield"><code>pkt.recvlength</code></em> as above.  All other fields
      can
      be left untouched since they were filled in by the <code class="function">*_parse()</code> call
      above.  If using <code class="function">lwres_*response_render()</code>,
      <em class="structfield"><code>pkt.pktflags</code></em> will be set up
      properly.  Otherwise, the <code class="constant">LWRES_LWPACKETFLAG_RESPONSE</code> bit should be
      set.
    </p>
<p>
      (4) Call the data specific rendering function, such as
      <code class="function">lwres_gabnresponse_render()</code>.
    </p>
<p>
      (5) Send the resulting packet to the client.
    </p>
<p></p>
d191 3
a193 2
<a name="id2543656"></a><h2>SEE ALSO</h2>
<p><span class="citerefentry"><span class="refentrytitle">lwres_gethostent</span>(3)</span>,
d195 1
a195 1
      <span class="citerefentry"><span class="refentrytitle">lwres_getipnode</span>(3)</span>,
d197 1
a197 1
      <span class="citerefentry"><span class="refentrytitle">lwres_getnameinfo</span>(3)</span>,
d199 1
a199 1
      <span class="citerefentry"><span class="refentrytitle">lwres_noop</span>(3)</span>,
d201 1
a201 1
      <span class="citerefentry"><span class="refentrytitle">lwres_gabn</span>(3)</span>,
d203 1
a203 1
      <span class="citerefentry"><span class="refentrytitle">lwres_gnba</span>(3)</span>,
d205 1
a205 1
      <span class="citerefentry"><span class="refentrytitle">lwres_context</span>(3)</span>,
d207 1
a207 1
      <span class="citerefentry"><span class="refentrytitle">lwres_config</span>(3)</span>,
d209 1
a209 1
      <span class="citerefentry"><span class="refentrytitle">resolver</span>(5)</span>,
d211 1
a211 1
      <span class="citerefentry"><span class="refentrytitle">lwresd</span>(8)</span>.
d213 1
a213 1
    </p>
@


