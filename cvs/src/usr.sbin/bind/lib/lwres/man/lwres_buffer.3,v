head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.5.0.40
	OPENBSD_6_1_BASE:1.1.1.5
	OPENBSD_6_0:1.1.1.5.0.36
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.32
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.34
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.26
	OPENBSD_5_7_BASE:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.30
	OPENBSD_5_6_BASE:1.1.1.5
	OPENBSD_5_5:1.1.1.5.0.28
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.24
	OPENBSD_5_4_BASE:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.22
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.20
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.18
	OPENBSD_5_0:1.1.1.5.0.16
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.14
	OPENBSD_4_9_BASE:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.12
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.8
	OPENBSD_4_7_BASE:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.10
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.6
	OPENBSD_4_5_BASE:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.4
	OPENBSD_4_4_BASE:1.1.1.5
	BIND_9_4_2_P1:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.2
	OPENBSD_4_3_BASE:1.1.1.5
	BIND_9_4_2:1.1.1.5
	OPENBSD_4_2:1.1.1.4.0.4
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.2
	OPENBSD_4_1_BASE:1.1.1.4
	BIND_9_3_4:1.1.1.4
	BIND_9_3_3:1.1.1.4
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	BIND_9_3_2:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.6
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.4
	OPENBSD_3_8_BASE:1.1.1.2
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@.\" @;


1.1
date	2003.01.20.21.07.49;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.49;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.36.03;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.04.05.16.44.30;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.01.10.18.20.24;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2007.12.09.12.33.58;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@.\"
.\" Copyright (C) 2000, 2001  Internet Software Consortium.
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
.\" DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
.\" INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
.\" INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
.\" FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
.\" NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
.\" WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.TH "LWRES_BUFFER" "3" "Jun 30, 2000" "BIND9" ""
.SH NAME
lwres_buffer_init, lwres_buffer_invalidate, lwres_buffer_add, lwres_buffer_subtract, lwres_buffer_clear, lwres_buffer_first, lwres_buffer_forward, lwres_buffer_back, lwres_buffer_getuint8, lwres_buffer_putuint8, lwres_buffer_getuint16, lwres_buffer_putuint16, lwres_buffer_getuint32, lwres_buffer_putuint32, lwres_buffer_putmem, lwres_buffer_getmem \- lightweight resolver buffer management
.SH SYNOPSIS
\fB#include <lwres/lwbuffer.h>
.sp
.na
void
lwres_buffer_init(lwres_buffer_t *b, void *base, unsigned int length);
.ad
.sp
.na
void
lwres_buffer_invalidate(lwres_buffer_t *b);
.ad
.sp
.na
void
lwres_buffer_add(lwres_buffer_t *b, unsigned int n);
.ad
.sp
.na
void
lwres_buffer_subtract(lwres_buffer_t *b, unsigned int n);
.ad
.sp
.na
void
lwres_buffer_clear(lwres_buffer_t *b);
.ad
.sp
.na
void
lwres_buffer_first(lwres_buffer_t *b);
.ad
.sp
.na
void
lwres_buffer_forward(lwres_buffer_t *b, unsigned int n);
.ad
.sp
.na
void
lwres_buffer_back(lwres_buffer_t *b, unsigned int n);
.ad
.sp
.na
lwres_uint8_t
lwres_buffer_getuint8(lwres_buffer_t *b);
.ad
.sp
.na
void
lwres_buffer_putuint8(lwres_buffer_t *b, lwres_uint8_t val);
.ad
.sp
.na
lwres_uint16_t
lwres_buffer_getuint16(lwres_buffer_t *b);
.ad
.sp
.na
void
lwres_buffer_putuint16(lwres_buffer_t *b, lwres_uint16_t val);
.ad
.sp
.na
lwres_uint32_t
lwres_buffer_getuint32(lwres_buffer_t *b);
.ad
.sp
.na
void
lwres_buffer_putuint32(lwres_buffer_t *b, lwres_uint32_t val);
.ad
.sp
.na
void
lwres_buffer_putmem(lwres_buffer_t *b, const unsigned char *base, unsigned int length);
.ad
.sp
.na
void
lwres_buffer_getmem(lwres_buffer_t *b, unsigned char *base, unsigned int length);
.ad
\fR
.SH "DESCRIPTION"
.PP
These functions provide bounds checked access to a region of memory
where data is being read or written.
They are based on, and similar to, the
isc_buffer_
functions in the ISC library.
.PP
A buffer is a region of memory, together with a set of related
subregions.
The \fBused region\fR and the
\fBavailable\fR region are disjoint, and
their union is the buffer's region.
The used region extends from the beginning of the buffer region to the
last used byte.
The available region extends from one byte greater than the last used
byte to the end of the buffer's region.
The size of the used region can be changed using various
buffer commands.
Initially, the used region is empty.
.PP
The used region is further subdivided into two disjoint regions: the
\fBconsumed region\fR and the \fBremaining region\fR.
The union of these two regions is the used region.
The consumed region extends from the beginning of the used region to
the byte before the \fBcurrent\fR offset (if any).
The \fBremaining\fR region the current pointer to the end of the used
region.
The size of the consumed region can be changed using various
buffer commands.
Initially, the consumed region is empty.
.PP
The \fBactive region\fR is an (optional) subregion of the remaining
region.
It extends from the current offset to an offset in the
remaining region.
Initially, the active region is empty.
If the current offset advances beyond the chosen offset,
the active region will also be empty.
.PP
.sp
.nf
 
   /------------entire length---------------\\\\
   /----- used region -----\\\\/-- available --\\\\
   +----------------------------------------+
   | consumed  | remaining |                |
   +----------------------------------------+
   a           b     c     d                e
 
  a == base of buffer.
  b == current pointer.  Can be anywhere between a and d.
  c == active pointer.  Meaningful between b and d.
  d == used pointer.
  e == length of buffer.
 
  a-e == entire length of buffer.
  a-d == used region.
  a-b == consumed region.
  b-d == remaining region.
  b-c == optional active region.
.sp
.fi
.PP
\fBlwres_buffer_init()\fR
initializes the
\fBlwres_buffer_t\fR
\fI*b\fR
and assocates it with the memory region of size
\fIlength\fR
bytes starting at location
\fIbase.\fR
.PP
\fBlwres_buffer_invalidate()\fR
marks the buffer
\fI*b\fR
as invalid. Invalidating a buffer after use is not required,
but makes it possible to catch its possible accidental use.
.PP
The functions
\fBlwres_buffer_add()\fR
and
\fBlwres_buffer_subtract()\fR
respectively increase and decrease the used space in
buffer
\fI*b\fR
by
\fIn\fR
bytes.
\fBlwres_buffer_add()\fR
checks for buffer overflow and
\fBlwres_buffer_subtract()\fR
checks for underflow.
These functions do not allocate or deallocate memory.
They just change the value of
\fBused\fR.
.PP
A buffer is re-initialised by
\fBlwres_buffer_clear()\fR.
The function sets
\fBused\fR ,
\fBcurrent\fR
and
\fBactive\fR
to zero.
.PP
\fBlwres_buffer_first\fR
makes the consumed region of buffer
\fI*p\fR
empty by setting
\fBcurrent\fR
to zero (the start of the buffer).
.PP
\fBlwres_buffer_forward()\fR
increases the consumed region of buffer
\fI*b\fR
by
\fIn\fR
bytes, checking for overflow.
Similarly,
\fBlwres_buffer_back()\fR
decreases buffer
\fIb\fR's
consumed region by
\fIn\fR
bytes and checks for underflow.
.PP
\fBlwres_buffer_getuint8()\fR
reads an unsigned 8-bit integer from
\fI*b\fR
and returns it.
\fBlwres_buffer_putuint8()\fR
writes the unsigned 8-bit integer
\fIval\fR
to buffer
\fI*b\fR.
.PP
\fBlwres_buffer_getuint16()\fR
and
\fBlwres_buffer_getuint32()\fR
are identical to
\fBlwres_buffer_putuint8()\fR
except that they respectively read an unsigned 16-bit or 32-bit integer 
in network byte order from
\fIb\fR.
Similarly,
\fBlwres_buffer_putuint16()\fR
and
\fBlwres_buffer_putuint32()\fR
writes the unsigned 16-bit or 32-bit integer
\fIval\fR
to buffer
\fIb\fR,
in network byte order.
.PP
Arbitrary amounts of data are read or written from a lightweight
resolver buffer with
\fBlwres_buffer_getmem()\fR
and
\fBlwres_buffer_putmem()\fR
respectively.
\fBlwres_buffer_putmem()\fR
copies
\fIlength\fR
bytes of memory at
\fIbase\fR
to
\fIb\fR.
Conversely,
\fBlwres_buffer_getmem()\fR
copies
\fIlength\fR
bytes of memory from
\fIb\fR
to
\fIbase\fR.
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d1 1
a1 1
.\" Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d8 8
a15 9
.\" THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
.\" REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
.\" AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
.\" INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
.\" LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
.\" OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
.\" PERFORMANCE OF THIS SOFTWARE.
.\"
.\" $ISC: lwres_buffer.3,v 1.12.2.1.8.1 2004/03/06 07:41:42 marka Exp $
@


1.1.1.3
log
@ISC BIND release 9.3.2
@
text
@d1 3
a3 3
.\" Copyright (C) 2004, 2005 Internet Systems Consortium, Inc. ("ISC")
.\" Copyright (C) 2000, 2001 Internet Software Consortium.
.\" 
d7 1
a7 1
.\" 
d10 1
a10 1
.\" AND FITNESS. IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
d16 1
a16 1
.\" $ISC: lwres_buffer.3,v 1.12.2.1.8.5 2005/10/13 02:33:58 marka Exp $
d18 2
a19 12
.hy 0
.ad l
.\" ** You probably do not want to edit this file directly **
.\" It was generated using the DocBook XSL Stylesheets (version 1.69.1).
.\" Instead of manually editing it, you probably should edit the DocBook XML
.\" source for it and then use the DocBook XSL Stylesheets to regenerate it.
.TH "LWRES_BUFFER" "3" "Jun 30, 2000" "BIND9" "BIND9"
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.SH "NAME"
d21 83
a103 36
.SH "SYNOPSIS"
.nf
#include <lwres/lwbuffer.h>
.fi
.HP 23
\fBvoid\ \fBlwres_buffer_init\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB, \fR\fBvoid\ *base\fR\fB, \fR\fBunsigned\ int\ length\fR\fB);\fR
.HP 29
\fBvoid\ \fBlwres_buffer_invalidate\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB);\fR
.HP 22
\fBvoid\ \fBlwres_buffer_add\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB, \fR\fBunsigned\ int\ n\fR\fB);\fR
.HP 27
\fBvoid\ \fBlwres_buffer_subtract\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB, \fR\fBunsigned\ int\ n\fR\fB);\fR
.HP 24
\fBvoid\ \fBlwres_buffer_clear\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB);\fR
.HP 24
\fBvoid\ \fBlwres_buffer_first\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB);\fR
.HP 26
\fBvoid\ \fBlwres_buffer_forward\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB, \fR\fBunsigned\ int\ n\fR\fB);\fR
.HP 23
\fBvoid\ \fBlwres_buffer_back\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB, \fR\fBunsigned\ int\ n\fR\fB);\fR
.HP 36
\fBlwres_uint8_t\ \fBlwres_buffer_getuint8\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB);\fR
.HP 27
\fBvoid\ \fBlwres_buffer_putuint8\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB, \fR\fBlwres_uint8_t\ val\fR\fB);\fR
.HP 38
\fBlwres_uint16_t\ \fBlwres_buffer_getuint16\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB);\fR
.HP 28
\fBvoid\ \fBlwres_buffer_putuint16\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB, \fR\fBlwres_uint16_t\ val\fR\fB);\fR
.HP 38
\fBlwres_uint32_t\ \fBlwres_buffer_getuint32\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB);\fR
.HP 28
\fBvoid\ \fBlwres_buffer_putuint32\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB, \fR\fBlwres_uint32_t\ val\fR\fB);\fR
.HP 25
\fBvoid\ \fBlwres_buffer_putmem\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB, \fR\fBconst\ unsigned\ char\ *base\fR\fB, \fR\fBunsigned\ int\ length\fR\fB);\fR
.HP 25
\fBvoid\ \fBlwres_buffer_getmem\fR\fR\fB(\fR\fBlwres_buffer_t\ *b\fR\fB, \fR\fBunsigned\ char\ *base\fR\fB, \fR\fBunsigned\ int\ length\fR\fB);\fR
d106 3
a108 1
These functions provide bounds checked access to a region of memory where data is being read or written. They are based on, and similar to, the
d112 12
a123 5
A buffer is a region of memory, together with a set of related subregions. The
\fIused region\fR
and the
\fIavailable\fR
region are disjoint, and their union is the buffer's region. The used region extends from the beginning of the buffer region to the last used byte. The available region extends from one byte greater than the last used byte to the end of the buffer's region. The size of the used region can be changed using various buffer commands. Initially, the used region is empty.
d126 17
a142 11
\fIconsumed region\fR
and the
\fIremaining region\fR. The union of these two regions is the used region. The consumed region extends from the beginning of the used region to the byte before the
\fIcurrent\fR
offset (if any). The
\fIremaining\fR
region the current pointer to the end of the used region. The size of the consumed region can be changed using various buffer commands. Initially, the consumed region is empty.
.PP
The
\fIactive region\fR
is an (optional) subregion of the remaining region. It extends from the current offset to an offset in the remaining region. Initially, the active region is empty. If the current offset advances beyond the chosen offset, the active region will also be empty.
d144 1
d146 4
a149 3
   /\-\-\-\-\-\-\-\-\-\-\-\-entire length\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\\\\
   /\-\-\-\-\- used region \-\-\-\-\-\\\\/\-\- available \-\-\\\\
   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
d151 1
a151 1
   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
d153 1
d159 7
a165 5
  a\-e == entire length of buffer.
  a\-d == used region.
  a\-b == consumed region.
  b\-d == remaining region.
  b\-c == optional active region.
a166 1
.sp
d170 2
a171 1
\fBlwres_buffer_t\fR\fI*b\fR
d180 2
a181 1
as invalid. Invalidating a buffer after use is not required, but makes it possible to catch its possible accidental use.
d187 2
a188 1
respectively increase and decrease the used space in buffer
d196 10
a205 8
checks for underflow. These functions do not allocate or deallocate memory. They just change the value of
used.
.PP
A buffer is re\-initialised by
\fBlwres_buffer_clear()\fR. The function sets
used
,
current
d207 1
a207 1
active
d214 1
a214 1
current
d222 2
a223 1
bytes, checking for overflow. Similarly,
d226 2
a227 1
\fIb\fR's consumed region by
d232 1
a232 1
reads an unsigned 8\-bit integer from
d236 1
a236 1
writes the unsigned 8\-bit integer
d246 4
a249 2
except that they respectively read an unsigned 16\-bit or 32\-bit integer in network byte order from
\fIb\fR. Similarly,
d253 1
a253 1
writes the unsigned 16\-bit or 32\-bit integer
d256 2
a257 1
\fIb\fR, in network byte order.
d259 2
a260 1
Arbitrary amounts of data are read or written from a lightweight resolver buffer with
d271 2
a272 1
\fIb\fR. Conversely,
@


1.1.1.4
log
@ISC BIND release 9.3.3
@
text
@d16 1
a16 1
.\" $ISC: lwres_buffer.3,v 1.12.2.1.8.6 2006/06/29 13:02:31 marka Exp $
d20 4
a23 7
.\"     Title: lwres_buffer
.\"    Author: 
.\" Generator: DocBook XSL Stylesheets v1.70.1 <http://docbook.sf.net/>
.\"      Date: Jun 30, 2000
.\"    Manual: BIND9
.\"    Source: BIND9
.\"
d36 1
a36 1
.BI "void lwres_buffer_init(lwres_buffer_t\ *b, void\ *base, unsigned\ int\ length);"
d38 1
a38 1
.BI "void lwres_buffer_invalidate(lwres_buffer_t\ *b);"
d40 1
a40 1
.BI "void lwres_buffer_add(lwres_buffer_t\ *b, unsigned\ int\ n);"
d42 1
a42 1
.BI "void lwres_buffer_subtract(lwres_buffer_t\ *b, unsigned\ int\ n);"
d44 1
a44 1
.BI "void lwres_buffer_clear(lwres_buffer_t\ *b);"
d46 1
a46 1
.BI "void lwres_buffer_first(lwres_buffer_t\ *b);"
d48 1
a48 1
.BI "void lwres_buffer_forward(lwres_buffer_t\ *b, unsigned\ int\ n);"
d50 1
a50 1
.BI "void lwres_buffer_back(lwres_buffer_t\ *b, unsigned\ int\ n);"
d52 1
a52 1
.BI "lwres_uint8_t lwres_buffer_getuint8(lwres_buffer_t\ *b);"
d54 1
a54 1
.BI "void lwres_buffer_putuint8(lwres_buffer_t\ *b, lwres_uint8_t\ val);"
d56 1
a56 1
.BI "lwres_uint16_t lwres_buffer_getuint16(lwres_buffer_t\ *b);"
d58 1
a58 1
.BI "void lwres_buffer_putuint16(lwres_buffer_t\ *b, lwres_uint16_t\ val);"
d60 1
a60 1
.BI "lwres_uint32_t lwres_buffer_getuint32(lwres_buffer_t\ *b);"
d62 1
a62 1
.BI "void lwres_buffer_putuint32(lwres_buffer_t\ *b, lwres_uint32_t\ val);"
d64 1
a64 1
.BI "void lwres_buffer_putmem(lwres_buffer_t\ *b, const\ unsigned\ char\ *base, unsigned\ int\ length);"
d66 1
a66 1
.BI "void lwres_buffer_getmem(lwres_buffer_t\ *b, unsigned\ char\ *base, unsigned\ int\ length);"
a91 2
.sp
.RS 3n
a109 1
.RE
d114 1
a114 2
\fBlwres_buffer_t\fR
\fI*b\fR
a211 2
.SH "COPYRIGHT"
Copyright \(co 2004, 2005 Internet Systems Consortium, Inc. ("ISC")
@


1.1.1.5
log
@ISC BIND release 9.4.2
@
text
@d1 1
a1 1
.\" Copyright (C) 2004, 2005, 2007 Internet Systems Consortium, Inc. ("ISC")
d16 1
a16 1
.\" $ISC: lwres_buffer.3,v 1.15.18.11 2007/01/30 00:23:45 marka Exp $
d22 1
a22 1
.\" Generator: DocBook XSL Stylesheets v1.71.1 <http://docbook.sf.net/>
d39 1
a39 1
.BI "void lwres_buffer_init(lwres_buffer_t\ *" "b" ", void\ *" "base" ", unsigned\ int\ " "length" ");"
d41 1
a41 1
.BI "void lwres_buffer_invalidate(lwres_buffer_t\ *" "b" ");"
d43 1
a43 1
.BI "void lwres_buffer_add(lwres_buffer_t\ *" "b" ", unsigned\ int\ " "n" ");"
d45 1
a45 1
.BI "void lwres_buffer_subtract(lwres_buffer_t\ *" "b" ", unsigned\ int\ " "n" ");"
d47 1
a47 1
.BI "void lwres_buffer_clear(lwres_buffer_t\ *" "b" ");"
d49 1
a49 1
.BI "void lwres_buffer_first(lwres_buffer_t\ *" "b" ");"
d51 1
a51 1
.BI "void lwres_buffer_forward(lwres_buffer_t\ *" "b" ", unsigned\ int\ " "n" ");"
d53 1
a53 1
.BI "void lwres_buffer_back(lwres_buffer_t\ *" "b" ", unsigned\ int\ " "n" ");"
d55 1
a55 1
.BI "lwres_uint8_t lwres_buffer_getuint8(lwres_buffer_t\ *" "b" ");"
d57 1
a57 1
.BI "void lwres_buffer_putuint8(lwres_buffer_t\ *" "b" ", lwres_uint8_t\ " "val" ");"
d59 1
a59 1
.BI "lwres_uint16_t lwres_buffer_getuint16(lwres_buffer_t\ *" "b" ");"
d61 1
a61 1
.BI "void lwres_buffer_putuint16(lwres_buffer_t\ *" "b" ", lwres_uint16_t\ " "val" ");"
d63 1
a63 1
.BI "lwres_uint32_t lwres_buffer_getuint32(lwres_buffer_t\ *" "b" ");"
d65 1
a65 1
.BI "void lwres_buffer_putuint32(lwres_buffer_t\ *" "b" ", lwres_uint32_t\ " "val" ");"
d67 1
a67 1
.BI "void lwres_buffer_putmem(lwres_buffer_t\ *" "b" ", const\ unsigned\ char\ *" "base" ", unsigned\ int\ " "length" ");"
d69 1
a69 1
.BI "void lwres_buffer_getmem(lwres_buffer_t\ *" "b" ", unsigned\ char\ *" "base" ", unsigned\ int\ " "length" ");"
d95 2
a96 1
.RS 4
a103 6
.fi
.RE
.sp
.PP
.RS 4
.nf
a108 6
.fi
.RE
.sp
.PP
.RS 4
.nf
d149 2
a150 1
used,
d220 1
a220 4
Copyright \(co 2004, 2005, 2007 Internet Systems Consortium, Inc. ("ISC")
.br
Copyright \(co 2000, 2001 Internet Software Consortium.
.br
@


