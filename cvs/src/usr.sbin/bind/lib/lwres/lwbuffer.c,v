head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.3.0.36
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.32
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.34
	OPENBSD_5_8_BASE:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.26
	OPENBSD_5_7_BASE:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.30
	OPENBSD_5_6_BASE:1.1.1.3
	OPENBSD_5_5:1.1.1.3.0.28
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.24
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.22
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.20
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.18
	OPENBSD_5_0:1.1.1.3.0.16
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.14
	OPENBSD_4_9_BASE:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.12
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.8
	OPENBSD_4_7_BASE:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.10
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.6
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	BIND_9_4_2_P1:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	OPENBSD_4_3_BASE:1.1.1.3
	BIND_9_4_2:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.12
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.10
	OPENBSD_4_1_BASE:1.1.1.2
	BIND_9_3_4:1.1.1.2
	BIND_9_3_3:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.8
	OPENBSD_4_0_BASE:1.1.1.2
	BIND_9_3_2:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.6
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.4
	OPENBSD_3_8_BASE:1.1.1.2
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.01.20.21.07.47;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.47;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.59;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.09.12.33.53;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (C) 2000, 2001  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: lwbuffer.c,v 1.10 2001/01/09 21:59:23 bwelling Exp $ */

#include <config.h>

#include <string.h>

#include <lwres/lwbuffer.h>

#include "assert_p.h"

void
lwres_buffer_init(lwres_buffer_t *b, void *base, unsigned int length)
{
	/*
	 * Make 'b' refer to the 'length'-byte region starting at base.
	 */

	REQUIRE(b != NULL);

	b->magic = LWRES_BUFFER_MAGIC;
	b->base = base;
	b->length = length;
	b->used = 0;
	b->current = 0;
	b->active = 0;
}

void
lwres_buffer_invalidate(lwres_buffer_t *b)
{
	/*
	 * Make 'b' an invalid buffer.
	 */

	REQUIRE(LWRES_BUFFER_VALID(b));

	b->magic = 0;
	b->base = NULL;
	b->length = 0;
	b->used = 0;
	b->current = 0;
	b->active = 0;
}

void
lwres_buffer_add(lwres_buffer_t *b, unsigned int n)
{
	/*
	 * Increase the 'used' region of 'b' by 'n' bytes.
	 */

	REQUIRE(LWRES_BUFFER_VALID(b));
	REQUIRE(b->used + n <= b->length);

	b->used += n;
}

void
lwres_buffer_subtract(lwres_buffer_t *b, unsigned int n)
{
	/*
	 * Decrease the 'used' region of 'b' by 'n' bytes.
	 */

	REQUIRE(LWRES_BUFFER_VALID(b));
	REQUIRE(b->used >= n);

	b->used -= n;
	if (b->current > b->used)
		b->current = b->used;
	if (b->active > b->used)
		b->active = b->used;
}

void
lwres_buffer_clear(lwres_buffer_t *b)
{
	/*
	 * Make the used region empty.
	 */

	REQUIRE(LWRES_BUFFER_VALID(b));

	b->used = 0;
	b->current = 0;
	b->active = 0;
}

void
lwres_buffer_first(lwres_buffer_t *b)
{
	/*
	 * Make the consumed region empty.
	 */

	REQUIRE(LWRES_BUFFER_VALID(b));

	b->current = 0;
}

void
lwres_buffer_forward(lwres_buffer_t *b, unsigned int n)
{
	/*
	 * Increase the 'consumed' region of 'b' by 'n' bytes.
	 */

	REQUIRE(LWRES_BUFFER_VALID(b));
	REQUIRE(b->current + n <= b->used);

	b->current += n;
}

void
lwres_buffer_back(lwres_buffer_t *b, unsigned int n)
{
	/*
	 * Decrease the 'consumed' region of 'b' by 'n' bytes.
	 */

	REQUIRE(LWRES_BUFFER_VALID(b));
	REQUIRE(n <= b->current);

	b->current -= n;
}

lwres_uint8_t
lwres_buffer_getuint8(lwres_buffer_t *b)
{
	unsigned char *cp;
	lwres_uint8_t result;

	/*
	 * Read an unsigned 8-bit integer from 'b' and return it.
	 */

	REQUIRE(LWRES_BUFFER_VALID(b));
	REQUIRE(b->used - b->current >= 1);

	cp = b->base;
	cp += b->current;
	b->current += 1;
	result = ((unsigned int)(cp[0]));

	return (result);
}

void
lwres_buffer_putuint8(lwres_buffer_t *b, lwres_uint8_t val)
{
	unsigned char *cp;

	REQUIRE(LWRES_BUFFER_VALID(b));
	REQUIRE(b->used + 1 <= b->length);

	cp = b->base;
	cp += b->used;
	b->used += 1;
	cp[0] = (val & 0x00ff);
}

lwres_uint16_t
lwres_buffer_getuint16(lwres_buffer_t *b)
{
	unsigned char *cp;
	lwres_uint16_t result;

	/*
	 * Read an unsigned 16-bit integer in network byte order from 'b',
	 * convert it to host byte order, and return it.
	 */

	REQUIRE(LWRES_BUFFER_VALID(b));
	REQUIRE(b->used - b->current >= 2);

	cp = b->base;
	cp += b->current;
	b->current += 2;
	result = ((unsigned int)(cp[0])) << 8;
	result |= ((unsigned int)(cp[1]));

	return (result);
}

void
lwres_buffer_putuint16(lwres_buffer_t *b, lwres_uint16_t val)
{
	unsigned char *cp;

	REQUIRE(LWRES_BUFFER_VALID(b));
	REQUIRE(b->used + 2 <= b->length);

	cp = b->base;
	cp += b->used;
	b->used += 2;
	cp[0] = (val & 0xff00) >> 8;
	cp[1] = (val & 0x00ff);
}

lwres_uint32_t
lwres_buffer_getuint32(lwres_buffer_t *b)
{
	unsigned char *cp;
	lwres_uint32_t result;

	/*
	 * Read an unsigned 32-bit integer in network byte order from 'b',
	 * convert it to host byte order, and return it.
	 */

	REQUIRE(LWRES_BUFFER_VALID(b));
	REQUIRE(b->used - b->current >= 4);

	cp = b->base;
	cp += b->current;
	b->current += 4;
	result = ((unsigned int)(cp[0])) << 24;
	result |= ((unsigned int)(cp[1])) << 16;
	result |= ((unsigned int)(cp[2])) << 8;
	result |= ((unsigned int)(cp[3]));

	return (result);
}

void
lwres_buffer_putuint32(lwres_buffer_t *b, lwres_uint32_t val)
{
	unsigned char *cp;

	REQUIRE(LWRES_BUFFER_VALID(b));
	REQUIRE(b->used + 4 <= b->length);

	cp = b->base;
	cp += b->used;
	b->used += 4;
	cp[0] = (unsigned char)((val & 0xff000000) >> 24);
	cp[1] = (unsigned char)((val & 0x00ff0000) >> 16);
	cp[2] = (unsigned char)((val & 0x0000ff00) >> 8);
	cp[3] = (unsigned char)(val & 0x000000ff);
}

void
lwres_buffer_putmem(lwres_buffer_t *b, const unsigned char *base,
		    unsigned int length)
{
	unsigned char *cp;

	REQUIRE(LWRES_BUFFER_VALID(b));
	REQUIRE(b->used + length <= b->length);

	cp = (unsigned char *)b->base + b->used;
	memcpy(cp, base, length);
	b->used += length;
}

void
lwres_buffer_getmem(lwres_buffer_t *b, unsigned char *base,
		    unsigned int length)
{
	unsigned char *cp;

	REQUIRE(LWRES_BUFFER_VALID(b));
	REQUIRE(b->used - b->current >= length);

	cp = b->base;
	cp += b->current;
	b->current += length;

	memcpy(base, cp, length);
}
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@a1 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: lwbuffer.c,v 1.10.206.1 2004/03/06 08:15:31 marka Exp $ */
@


1.1.1.3
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 93
/* $ISC: lwbuffer.c,v 1.11.18.2 2005/04/29 00:17:18 marka Exp $ */

/*! \file */

/**
 *    These functions provide bounds checked access to a region of memory
 *    where data is being read or written. They are based on, and similar
 *    to, the isc_buffer_ functions in the ISC library.
 * 
 *    A buffer is a region of memory, together with a set of related
 *    subregions. The used region and the available region are disjoint, and
 *    their union is the buffer's region. The used region extends from the
 *    beginning of the buffer region to the last used byte. The available
 *    region extends from one byte greater than the last used byte to the
 *    end of the buffer's region. The size of the used region can be changed
 *    using various buffer commands. Initially, the used region is empty.
 * 
 *    The used region is further subdivided into two disjoint regions: the
 *    consumed region and the remaining region. The union of these two
 *    regions is the used region. The consumed region extends from the
 *    beginning of the used region to the byte before the current offset (if
 *    any). The remaining region the current pointer to the end of the used
 *    region. The size of the consumed region can be changed using various
 *    buffer commands. Initially, the consumed region is empty.
 * 
 *    The active region is an (optional) subregion of the remaining region.
 *    It extends from the current offset to an offset in the remaining
 *    region. Initially, the active region is empty. If the current offset
 *    advances beyond the chosen offset, the active region will also be
 *    empty.
 * 
 * 
 * \verbatim
 *    /------------entire length---------------\\
 *    /----- used region -----\\/-- available --\\
 *    +----------------------------------------+
 *    | consumed  | remaining |                |
 *    +----------------------------------------+
 *    a           b     c     d                e
 * 
 *   a == base of buffer.
 *   b == current pointer.  Can be anywhere between a and d.
 *   c == active pointer.  Meaningful between b and d.
 *   d == used pointer.
 *   e == length of buffer.
 * 
 *   a-e == entire length of buffer.
 *   a-d == used region.
 *   a-b == consumed region.
 *   b-d == remaining region.
 *   b-c == optional active region.
 * \endverbatim
 * 
 *    lwres_buffer_init() initializes the lwres_buffer_t *b and assocates it
 *    with the memory region of size length bytes starting at location base.
 * 
 *    lwres_buffer_invalidate() marks the buffer *b as invalid. Invalidating
 *    a buffer after use is not required, but makes it possible to catch its
 *    possible accidental use.
 * 
 *    The functions lwres_buffer_add() and lwres_buffer_subtract()
 *    respectively increase and decrease the used space in buffer *b by n
 *    bytes. lwres_buffer_add() checks for buffer overflow and
 *    lwres_buffer_subtract() checks for underflow. These functions do not
 *    allocate or deallocate memory. They just change the value of used.
 * 
 *    A buffer is re-initialised by lwres_buffer_clear(). The function sets
 *    used , current and active to zero.
 * 
 *    lwres_buffer_first() makes the consumed region of buffer *p empty by
 *    setting current to zero (the start of the buffer).
 * 
 *    lwres_buffer_forward() increases the consumed region of buffer *b by n
 *    bytes, checking for overflow. Similarly, lwres_buffer_back() decreases
 *    buffer b's consumed region by n bytes and checks for underflow.
 * 
 *    lwres_buffer_getuint8() reads an unsigned 8-bit integer from *b and
 *    returns it. lwres_buffer_putuint8() writes the unsigned 8-bit integer
 *    val to buffer *b.
 * 
 *    lwres_buffer_getuint16() and lwres_buffer_getuint32() are identical to
 *    lwres_buffer_putuint8() except that they respectively read an unsigned
 *    16-bit or 32-bit integer in network byte order from b. Similarly,
 *    lwres_buffer_putuint16() and lwres_buffer_putuint32() writes the
 *    unsigned 16-bit or 32-bit integer val to buffer b, in network byte
 *    order.
 * 
 *    Arbitrary amounts of data are read or written from a lightweight
 *    resolver buffer with lwres_buffer_getmem() and lwres_buffer_putmem()
 *    respectively. lwres_buffer_putmem() copies length bytes of memory at
 *    base to b. Conversely, lwres_buffer_getmem() copies length bytes of
 *    memory from b to base.
 */
a44 1
/*  Make 'b' an invalid buffer. */
d48 3
a61 1
/* Increase the 'used' region of 'b' by 'n' bytes. */
d65 3
a74 1
/* Decrease the 'used' region of 'b' by 'n' bytes. */
d78 3
a91 1
/* Make the used region empty. */
d95 3
a105 1
/* Make the consumed region empty. */
d109 3
a117 1
/* Increase the 'consumed' region of 'b' by 'n' bytes. */
d121 3
a130 1
/* Decrease the 'consumed' region of 'b' by 'n' bytes. */
d134 3
a143 1
/* Read an unsigned 8-bit integer from 'b' and return it. */
d150 3
a164 1
/* Put an unsigned 8-bit integer */
a178 1
/*  Read an unsigned 16-bit integer in network byte order from 'b', convert it to host byte order, and return it. */
d185 4
a201 1
/* Put an unsigned 16-bit integer. */
a216 1
/*  Read an unsigned 32-bit integer in network byte order from 'b', convert it to host byte order, and return it. */
d223 5
a241 1
/* Put an unsigned 32-bit integer. */
a258 1
/* copies length bytes of memory at base to b */
a272 1
/* copies length bytes of memory at b to base */
@


