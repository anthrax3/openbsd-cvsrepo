head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.36
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.32
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.34
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.26
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.30
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.28
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.24
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.22
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.20
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.18
	OPENBSD_5_0:1.7.0.16
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.14
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.12
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.8
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.10
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.6
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	BIND_9_4_2_P1:1.1.1.3
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	BIND_9_4_2:1.1.1.3
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	BIND_9_3_4:1.1.1.2
	BIND_9_3_3:1.1.1.2
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	BIND_9_3_2:1.1.1.2
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2007.12.09.13.39.44;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.28.17.14.08;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.18.14.14.08;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.06.05.08.33;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.08.22.34.46;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.15.13.20.17;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.07.47;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.47;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.59;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.09.12.33.54;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.7
log
@resolve conflicts
@
text
@/*
 * Portions Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
 * Portions Copyright (C) 1999-2001, 2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: getnameinfo.c,v 1.34.18.3 2005/04/29 00:17:18 marka Exp $ */

/*! \file */

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * XXX
 * Issues to be discussed:
 * - Return values.  There seems to be no standard for return value (RFC2553)
 *   but INRIA implementation returns EAI_xxx defined for getaddrinfo().
 */


/**
 *    This function is equivalent to the getnameinfo(3) function defined in
 *    RFC2133. lwres_getnameinfo() returns the hostname for the struct
 *    sockaddr sa which is salen bytes long. The hostname is of length
 *    hostlen and is returned via *host. The maximum length of the hostname
 *    is 1025 bytes: #NI_MAXHOST.
 * 
 *    The name of the service associated with the port number in sa is
 *    returned in *serv. It is servlen bytes long. The maximum length of the
 *    service name is #NI_MAXSERV - 32 bytes.
 * 
 *    The flags argument sets the following bits:
 * 
 * \li   #NI_NOFQDN:
 *           A fully qualified domain name is not required for local hosts.
 *           The local part of the fully qualified domain name is returned
 *           instead.
 * 
 * \li   #NI_NUMERICHOST
 *           Return the address in numeric form, as if calling inet_ntop(),
 *           instead of a host name.
 * 
 * \li   #NI_NAMEREQD
 *           A name is required. If the hostname cannot be found in the DNS
 *           and this flag is set, a non-zero error code is returned. If the
 *           hostname is not found and the flag is not set, the address is
 *           returned in numeric form.
 * 
 * \li   #NI_NUMERICSERV
 *           The service name is returned as a digit string representing the
 *           port number.
 * 
 * \li   #NI_DGRAM
 *           Specifies that the service being looked up is a datagram
 *           service, and causes getservbyport() to be called with a second
 *           argument of "udp" instead of its default of "tcp". This is
 *           required for the few ports (512-514) that have different
 *           services for UDP and TCP.
 * 
 * \section getnameinfo_return Return Values
 * 
 *    lwres_getnameinfo() returns 0 on success or a non-zero error code if
 *    an error occurs.
 * 
 * \section getname_see See Also
 * 
 *    RFC2133, getservbyport(), 
 *    lwres_getnamebyaddr(). lwres_net_ntop().
 * 
 * \section getnameinfo_bugs Bugs
 * 
 *    RFC2133 fails to define what the nonzero return values of
 *    getnameinfo() are.
 */

#include <config.h>

#include <stdio.h>
#include <string.h>

#include <lwres/lwres.h>
#include <lwres/net.h>
#include <lwres/netdb.h>
#include "print_p.h"

#include "assert_p.h"

#define SUCCESS 0

/*% afd structure definition */
static struct afd {
	int a_af;
	size_t a_addrlen;
	size_t a_socklen;
} afdl [] = {
	/*!
	 * First entry is linked last...
	 */
	{ AF_INET, sizeof(struct in_addr), sizeof(struct sockaddr_in) },
	{ AF_INET6, sizeof(struct in6_addr), sizeof(struct sockaddr_in6) },
	{0, 0, 0},
};

#define ENI_NOSERVNAME	1
#define ENI_NOHOSTNAME	2
#define ENI_MEMORY	3
#define ENI_SYSTEM	4
#define ENI_FAMILY	5
#define ENI_SALEN	6
#define ENI_NOSOCKET 	7

/*!
 * The test against 0 is there to keep the Solaris compiler
 * from complaining about "end-of-loop code not reached".
 */
#define ERR(code) \
	do { result = (code);			\
		if (result != 0) goto cleanup;	\
	} while (0)

/*% lightweight resolver socket address structure to hostname and service name */
int
lwres_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,
		  size_t hostlen, char *serv, size_t servlen, int flags)
{
	struct afd *afd;
	struct servent *sp;
	unsigned short port;
#ifdef LWRES_PLATFORM_HAVESALEN
	size_t len;
#endif
	int family, i;
	const void *addr;
	char *p;
#if 0
	unsigned long v4a;
	unsigned char pfx;
#endif
	char numserv[sizeof("65000")];
	char numaddr[sizeof("abcd:abcd:abcd:abcd:abcd:abcd:255.255.255.255")
		    + 1 + sizeof("4294967295")];
	const char *proto;
	lwres_uint32_t lwf = 0;
	lwres_context_t *lwrctx = NULL;
	lwres_gnbaresponse_t *by = NULL;
	int result = SUCCESS;
	int n;

	if (sa == NULL)
		ERR(ENI_NOSOCKET);

#ifdef LWRES_PLATFORM_HAVESALEN
	len = sa->sa_len;
	if (len != salen)
		ERR(ENI_SALEN);
#endif

	family = sa->sa_family;
	for (i = 0; afdl[i].a_af; i++)
		if (afdl[i].a_af == family) {
			afd = &afdl[i];
			goto found;
		}
	ERR(ENI_FAMILY);

 found:
	if (salen != afd->a_socklen)
		ERR(ENI_SALEN);

	switch (family) {
	case AF_INET:
		port = ((const struct sockaddr_in *)sa)->sin_port;
		addr = &((const struct sockaddr_in *)sa)->sin_addr.s_addr;
		break;

	case AF_INET6:
		port = ((const struct sockaddr_in6 *)sa)->sin6_port;
		addr = ((const struct sockaddr_in6 *)sa)->sin6_addr.s6_addr;
		break;

	default:
		port = 0;
		addr = NULL;
		INSIST(0);
	}
	proto = (flags & NI_DGRAM) ? "udp" : "tcp";

	if (serv == NULL || servlen == 0U) {
		/*
		 * Caller does not want service.
		 */
	} else if ((flags & NI_NUMERICSERV) != 0 ||
		   (sp = getservbyport(port, proto)) == NULL) {
		snprintf(numserv, sizeof(numserv), "%d", ntohs(port));
		if ((strlen(numserv) + 1) > servlen)
			ERR(ENI_MEMORY);
		strlcpy(serv, numserv, servlen);
	} else {
		if ((strlen(sp->s_name) + 1) > servlen)
			ERR(ENI_MEMORY);
		strlcpy(serv, sp->s_name, servlen);
	}

#if 0
	switch (sa->sa_family) {
	case AF_INET:
		v4a = ((struct sockaddr_in *)sa)->sin_addr.s_addr;
		if (IN_MULTICAST(v4a) || IN_EXPERIMENTAL(v4a))
			flags |= NI_NUMERICHOST;
		v4a >>= IN_CLASSA_NSHIFT;
		if (v4a == 0 || v4a == IN_LOOPBACKNET)
			flags |= NI_NUMERICHOST;
		break;

	case AF_INET6:
		pfx = ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[0];
		if (pfx == 0 || pfx == 0xfe || pfx == 0xff)
			flags |= NI_NUMERICHOST;
		break;
	}
#endif

	if (host == NULL || hostlen == 0U) {
		/*
		 * What should we do?
		 */
	} else if (flags & NI_NUMERICHOST) {
		if (lwres_net_ntop(afd->a_af, addr, numaddr, sizeof(numaddr))
		    == NULL)
			ERR(ENI_SYSTEM);
#if defined(LWRES_HAVE_SIN6_SCOPE_ID)
		if (afd->a_af == AF_INET6 &&
		    ((const struct sockaddr_in6 *)sa)->sin6_scope_id) {
			char *p = numaddr + strlen(numaddr);
			const char *stringscope = NULL;
#if 0
			if ((flags & NI_NUMERICSCOPE) == 0) {
				/*
				 * Vendors may want to add support for
				 * non-numeric scope identifier.
				 */
				stringscope = foo;
			}
#endif
			if (stringscope == NULL) {
				snprintf(p, sizeof(numaddr) - (p - numaddr),
				    "%%%u",
				    ((const struct sockaddr_in6 *)sa)->sin6_scope_id);
			} else {
				snprintf(p, sizeof(numaddr) - (p - numaddr),
				    "%%%s", stringscope);
			}
		}
#endif
		if (strlen(numaddr) + 1 > hostlen)
			ERR(ENI_MEMORY);
		strlcpy(host, numaddr, hostlen);
	} else {
		switch (family) {
		case AF_INET:
			lwf = LWRES_ADDRTYPE_V4;
			break;
		case AF_INET6:
			lwf = LWRES_ADDRTYPE_V6;
			break;
		default:
			INSIST(0);
		}

		n = lwres_context_create(&lwrctx, NULL, NULL, NULL, 0);
		if (n == 0)
			(void) lwres_conf_parse(lwrctx, lwres_resolv_conf);

		if (n == 0)
			n = lwres_getnamebyaddr(lwrctx, lwf,
						(lwres_uint16_t)afd->a_addrlen,
						addr, &by);
		if (n == 0) {
			if (flags & NI_NOFQDN) {
				p = strchr(by->realname, '.');
				if (p)
					*p = '\0';
			}
			if ((strlen(by->realname) + 1) > hostlen)
				ERR(ENI_MEMORY);
			strlcpy(host, by->realname, hostlen);
		} else {
			if (flags & NI_NAMEREQD)
				ERR(ENI_NOHOSTNAME);
			if (lwres_net_ntop(afd->a_af, addr, numaddr,
					   sizeof(numaddr))
			    == NULL)
				ERR(ENI_NOHOSTNAME);
			if ((strlen(numaddr) + 1) > hostlen)
				ERR(ENI_MEMORY);
			strlcpy(host, numaddr, hostlen);
		}
	}
	result = SUCCESS;
 cleanup:
	if (by != NULL)
		lwres_gnbaresponse_free(lwrctx, &by);
	if (lwrctx != NULL) {
		lwres_conf_clear(lwrctx);
		lwres_context_destroy(&lwrctx);
	}
	return (result);
}
@


1.6
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Portions Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 3
a20 1
/* $ISC: getnameinfo.c,v 1.30.2.3.2.4 2004/08/28 06:25:24 marka Exp $ */
d58 56
d128 1
d134 1
a134 1
	/*
d150 1
a150 1
/*
d159 1
@


1.5
log
@update to BIND v9.2.3. ok todd@@
@
text
@d2 1
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: getnameinfo.c,v 1.30.2.3 2003/07/23 06:57:56 marka Exp $ */
d64 1
@


1.4
log
@WIDE uses 3-term now; itojun ok
@
text
@d2 1
a2 1
 * Portions Copyright (C) 1999-2001  Internet Software Consortium.
d18 1
a18 1
/* $ISC: getnameinfo.c,v 1.30 2001/07/10 18:25:43 gson Exp $ */
d165 1
a165 1
	if (serv == NULL || servlen == 0) {
d200 1
a200 1
	if (host == NULL || hostlen == 0) {
@


1.3
log
@replace strcpy with strlcpy and some strdup.
ok rohee@@ tdeval@@ dhartmei@@
requested by deraadt@@
@
text
@d32 1
a32 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by WIDE Project and
 *    its contributors.
 * 4. Neither the name of the project nor the names of its contributors
@


1.2
log
@first sprintf pass from todd@@ and ISC-Bugs #5614.
@
text
@d178 1
a178 1
		strcpy(serv, numserv);
d182 1
a182 1
		strcpy(serv, sp->s_name);
d238 1
a238 1
		strcpy(host, numaddr);
d267 1
a267 1
			strcpy(host, by->realname);
d277 1
a277 1
			strcpy(host, numaddr);
@


1.1
log
@Initial revision
@
text
@d175 1
a175 1
		sprintf(numserv, "%d", ntohs(port));
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Portions Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Portions Copyright (C) 1999-2001, 2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: getnameinfo.c,v 1.30.2.3.2.4 2004/08/28 06:25:24 marka Exp $ */
d32 5
a36 1
 * 3. Neither the name of the project nor the names of its contributors
a67 1
#include "print_p.h"
d169 1
a169 1
	if (serv == NULL || servlen == 0U) {
d175 1
a175 1
		snprintf(numserv, sizeof(numserv), "%d", ntohs(port));
d204 1
a204 1
	if (host == NULL || hostlen == 0U) {
@


1.1.1.3
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Portions Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 3
/* $ISC: getnameinfo.c,v 1.34.18.3 2005/04/29 00:17:18 marka Exp $ */

/*! \file */
a55 56

/**
 *    This function is equivalent to the getnameinfo(3) function defined in
 *    RFC2133. lwres_getnameinfo() returns the hostname for the struct
 *    sockaddr sa which is salen bytes long. The hostname is of length
 *    hostlen and is returned via *host. The maximum length of the hostname
 *    is 1025 bytes: #NI_MAXHOST.
 * 
 *    The name of the service associated with the port number in sa is
 *    returned in *serv. It is servlen bytes long. The maximum length of the
 *    service name is #NI_MAXSERV - 32 bytes.
 * 
 *    The flags argument sets the following bits:
 * 
 * \li   #NI_NOFQDN:
 *           A fully qualified domain name is not required for local hosts.
 *           The local part of the fully qualified domain name is returned
 *           instead.
 * 
 * \li   #NI_NUMERICHOST
 *           Return the address in numeric form, as if calling inet_ntop(),
 *           instead of a host name.
 * 
 * \li   #NI_NAMEREQD
 *           A name is required. If the hostname cannot be found in the DNS
 *           and this flag is set, a non-zero error code is returned. If the
 *           hostname is not found and the flag is not set, the address is
 *           returned in numeric form.
 * 
 * \li   #NI_NUMERICSERV
 *           The service name is returned as a digit string representing the
 *           port number.
 * 
 * \li   #NI_DGRAM
 *           Specifies that the service being looked up is a datagram
 *           service, and causes getservbyport() to be called with a second
 *           argument of "udp" instead of its default of "tcp". This is
 *           required for the few ports (512-514) that have different
 *           services for UDP and TCP.
 * 
 * \section getnameinfo_return Return Values
 * 
 *    lwres_getnameinfo() returns 0 on success or a non-zero error code if
 *    an error occurs.
 * 
 * \section getname_see See Also
 * 
 *    RFC2133, getservbyport(), 
 *    lwres_getnamebyaddr(). lwres_net_ntop().
 * 
 * \section getnameinfo_bugs Bugs
 * 
 *    RFC2133 fails to define what the nonzero return values of
 *    getnameinfo() are.
 */

a69 1
/*% afd structure definition */
d75 1
a75 1
	/*!
d91 1
a91 1
/*!
a99 1
/*% lightweight resolver socket address structure to hostname and service name */
@


