head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.36
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.32
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.34
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.26
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.30
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.28
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.24
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.22
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.20
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.18
	OPENBSD_5_0:1.4.0.16
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.14
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.12
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.8
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.10
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	BIND_9_4_2_P1:1.1.1.3
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	BIND_9_4_2:1.1.1.3
	OPENBSD_4_2:1.3.0.12
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.10
	OPENBSD_4_1_BASE:1.3
	BIND_9_3_4:1.1.1.2
	BIND_9_3_3:1.1.1.2
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	BIND_9_3_2:1.1.1.2
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2007.12.09.13.39.44;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.28.17.14.06;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.18.14.14.06;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.07.17;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.17;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.10;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.09.12.34.47;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.4
log
@resolve conflicts
@
text
@/*
 * Copyright (C) 2004, 2005, 2007  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1999-2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: db.h,v 1.76.18.10 2007/08/28 07:20:05 tbox Exp $ */

#ifndef DNS_DB_H
#define DNS_DB_H 1

/*****
 ***** Module Info
 *****/

/*! \file
 * \brief
 * The DNS DB interface allows named rdatasets to be stored and retrieved.
 *
 * The dns_db_t type is like a "virtual class".  To actually use
 * DBs, an implementation of the class is required.
 *
 * XXX more XXX
 *
 * MP:
 * \li	The module ensures appropriate synchronization of data structures it
 *	creates and manipulates.
 *
 * Reliability:
 * \li	No anticipated impact.
 *
 * Resources:
 * \li	TBS
 *
 * Security:
 * \li	No anticipated impact.
 *
 * Standards:
 * \li	None.
 */

/*****
 ***** Imports
 *****/

#include <isc/lang.h>
#include <isc/magic.h>
#include <isc/ondestroy.h>
#include <isc/stdtime.h>

#include <dns/name.h>
#include <dns/types.h>

ISC_LANG_BEGINDECLS

/*****
 ***** Types
 *****/

typedef struct dns_dbmethods {
	void		(*attach)(dns_db_t *source, dns_db_t **targetp);
	void		(*detach)(dns_db_t **dbp);
	isc_result_t	(*beginload)(dns_db_t *db, dns_addrdatasetfunc_t *addp,
				     dns_dbload_t **dbloadp);
	isc_result_t	(*endload)(dns_db_t *db, dns_dbload_t **dbloadp);
	isc_result_t	(*dump)(dns_db_t *db, dns_dbversion_t *version,
				const char *filename,
				dns_masterformat_t masterformat);
	void		(*currentversion)(dns_db_t *db,
					  dns_dbversion_t **versionp);
	isc_result_t	(*newversion)(dns_db_t *db,
				      dns_dbversion_t **versionp);
	void		(*attachversion)(dns_db_t *db, dns_dbversion_t *source,
					 dns_dbversion_t **targetp);
	void		(*closeversion)(dns_db_t *db,
					dns_dbversion_t **versionp,
					isc_boolean_t commit);
	isc_result_t	(*findnode)(dns_db_t *db, dns_name_t *name,
				    isc_boolean_t create,
				    dns_dbnode_t **nodep);
	isc_result_t	(*find)(dns_db_t *db, dns_name_t *name,
				dns_dbversion_t *version,
				dns_rdatatype_t type, unsigned int options,
				isc_stdtime_t now,
				dns_dbnode_t **nodep, dns_name_t *foundname,
				dns_rdataset_t *rdataset,
				dns_rdataset_t *sigrdataset);
	isc_result_t	(*findzonecut)(dns_db_t *db, dns_name_t *name,
				       unsigned int options, isc_stdtime_t now,
				       dns_dbnode_t **nodep,
				       dns_name_t *foundname,
				       dns_rdataset_t *rdataset,
				       dns_rdataset_t *sigrdataset);
	void		(*attachnode)(dns_db_t *db,
				      dns_dbnode_t *source,
				      dns_dbnode_t **targetp);
	void		(*detachnode)(dns_db_t *db,
				      dns_dbnode_t **targetp);
	isc_result_t	(*expirenode)(dns_db_t *db, dns_dbnode_t *node,
				      isc_stdtime_t now);
	void		(*printnode)(dns_db_t *db, dns_dbnode_t *node,
				     FILE *out);
	isc_result_t 	(*createiterator)(dns_db_t *db,
					  isc_boolean_t relative_names,
					  dns_dbiterator_t **iteratorp);
	isc_result_t	(*findrdataset)(dns_db_t *db, dns_dbnode_t *node,
					dns_dbversion_t *version,
					dns_rdatatype_t type,
					dns_rdatatype_t covers,
					isc_stdtime_t now,
					dns_rdataset_t *rdataset,
					dns_rdataset_t *sigrdataset);
	isc_result_t	(*allrdatasets)(dns_db_t *db, dns_dbnode_t *node,
					dns_dbversion_t *version,
					isc_stdtime_t now,
					dns_rdatasetiter_t **iteratorp);
	isc_result_t	(*addrdataset)(dns_db_t *db, dns_dbnode_t *node,
				       dns_dbversion_t *version,
				       isc_stdtime_t now,
				       dns_rdataset_t *rdataset,
				       unsigned int options,
				       dns_rdataset_t *addedrdataset);
	isc_result_t	(*subtractrdataset)(dns_db_t *db, dns_dbnode_t *node,
					    dns_dbversion_t *version,
					    dns_rdataset_t *rdataset,
					    unsigned int options,
					    dns_rdataset_t *newrdataset);
	isc_result_t	(*deleterdataset)(dns_db_t *db, dns_dbnode_t *node,
					  dns_dbversion_t *version,
					  dns_rdatatype_t type,
					  dns_rdatatype_t covers);
	isc_boolean_t	(*issecure)(dns_db_t *db);
	unsigned int	(*nodecount)(dns_db_t *db);
	isc_boolean_t	(*ispersistent)(dns_db_t *db);
	void		(*overmem)(dns_db_t *db, isc_boolean_t overmem);
	void		(*settask)(dns_db_t *db, isc_task_t *);
	isc_result_t	(*getoriginnode)(dns_db_t *db, dns_dbnode_t **nodep);
} dns_dbmethods_t;

typedef isc_result_t
(*dns_dbcreatefunc_t)(isc_mem_t *mctx, dns_name_t *name,
		      dns_dbtype_t type, dns_rdataclass_t rdclass,
		      unsigned int argc, char *argv[], void *driverarg,
		      dns_db_t **dbp);
					
#define DNS_DB_MAGIC		ISC_MAGIC('D','N','S','D')
#define DNS_DB_VALID(db)	ISC_MAGIC_VALID(db, DNS_DB_MAGIC)

/*%
 * This structure is actually just the common prefix of a DNS db
 * implementation's version of a dns_db_t.
 * \brief
 * Direct use of this structure by clients is forbidden.  DB implementations
 * may change the structure.  'magic' must be DNS_DB_MAGIC for any of the
 * dns_db_ routines to work.  DB implementations must maintain all DB
 * invariants.
 */
struct dns_db {
	unsigned int			magic;
	unsigned int			impmagic;
	dns_dbmethods_t *		methods;
	isc_uint16_t			attributes;
	dns_rdataclass_t		rdclass;
	dns_name_t			origin;
	isc_ondestroy_t			ondest;
	isc_mem_t *			mctx;
};

#define DNS_DBATTR_CACHE		0x01
#define DNS_DBATTR_STUB			0x02

/*@@{*/
/*%
 * Options that can be specified for dns_db_find().
 */
#define DNS_DBFIND_GLUEOK		0x01
#define DNS_DBFIND_VALIDATEGLUE		0x02
#define DNS_DBFIND_NOWILD		0x04
#define DNS_DBFIND_PENDINGOK		0x08
#define DNS_DBFIND_NOEXACT		0x10
#define DNS_DBFIND_FORCENSEC		0x20
#define DNS_DBFIND_COVERINGNSEC		0x40
/*@@}*/

/*@@{*/
/*%
 * Options that can be specified for dns_db_addrdataset().
 */
#define DNS_DBADD_MERGE			0x01
#define DNS_DBADD_FORCE			0x02
#define DNS_DBADD_EXACT			0x04
#define DNS_DBADD_EXACTTTL		0x08
/*@@}*/

/*%
 * Options that can be specified for dns_db_subtractrdataset().
 */
#define DNS_DBSUB_EXACT			0x01

/*****
 ***** Methods
 *****/

/***
 *** Basic DB Methods
 ***/

isc_result_t
dns_db_create(isc_mem_t *mctx, const char *db_type, dns_name_t *origin,
	      dns_dbtype_t type, dns_rdataclass_t rdclass,
	      unsigned int argc, char *argv[], dns_db_t **dbp);
/*%<
 * Create a new database using implementation 'db_type'.
 *
 * Notes:
 * \li	All names in the database must be subdomains of 'origin' and in class
 *	'rdclass'.  The database makes its own copy of the origin, so the
 *	caller may do whatever they like with 'origin' and its storage once the
 *	call returns.
 *
 * \li	DB implementation-specific parameters are passed using argc and argv.
 *
 * Requires:
 *
 * \li	dbp != NULL and *dbp == NULL
 *
 * \li	'origin' is a valid absolute domain name.
 *
 * \li	mctx is a valid memory context
 *
 * Ensures:
 *
 * \li	A copy of 'origin' has been made for the databases use, and the
 *	caller is free to do whatever they want with the name and storage
 *	associated with 'origin'.
 *
 * Returns:
 *
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOMEMORY
 * \li	#ISC_R_NOTFOUND				db_type not found
 *
 * \li	Many other errors are possible, depending on what db_type was
 *	specified.
 */

void
dns_db_attach(dns_db_t *source, dns_db_t **targetp);
/*%<
 * Attach *targetp to source.
 *
 * Requires:
 *
 * \li	'source' is a valid database.
 *
 * \li	'targetp' points to a NULL dns_db_t *.
 *
 * Ensures:
 *
 * \li	*targetp is attached to source.
 */

void
dns_db_detach(dns_db_t **dbp);
/*%<
 * Detach *dbp from its database.
 *
 * Requires:
 *
 * \li	'dbp' points to a valid database.
 *
 * Ensures:
 *
 * \li	*dbp is NULL.
 *
 * \li	If '*dbp' is the last reference to the database,
 *		all resources used by the database will be freed
 */

isc_result_t
dns_db_ondestroy(dns_db_t *db, isc_task_t *task, isc_event_t **eventp);
/*%<
 * Causes 'eventp' to be sent to be sent to 'task' when the database is
 * destroyed.
 *
 * Note; ownership of the eventp is taken from the caller (and *eventp is
 * set to NULL). The sender field of the event is set to 'db' before it is
 * sent to the task.
 */

isc_boolean_t
dns_db_iscache(dns_db_t *db);
/*%<
 * Does 'db' have cache semantics?
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * Returns:
 * \li	#ISC_TRUE	'db' has cache semantics
 * \li	#ISC_FALSE	otherwise
 */

isc_boolean_t
dns_db_iszone(dns_db_t *db);
/*%<
 * Does 'db' have zone semantics?
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * Returns:
 * \li	#ISC_TRUE	'db' has zone semantics
 * \li	#ISC_FALSE	otherwise
 */

isc_boolean_t
dns_db_isstub(dns_db_t *db);
/*%<
 * Does 'db' have stub semantics?
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * Returns:
 * \li	#ISC_TRUE	'db' has zone semantics
 * \li	#ISC_FALSE	otherwise
 */

isc_boolean_t
dns_db_issecure(dns_db_t *db);
/*%<
 * Is 'db' secure?
 *
 * Requires:
 *
 * \li	'db' is a valid database with zone semantics.
 *
 * Returns:
 * \li	#ISC_TRUE	'db' is secure.
 * \li	#ISC_FALSE	'db' is not secure.
 */

dns_name_t *
dns_db_origin(dns_db_t *db);
/*%<
 * The origin of the database.
 *
 * Note: caller must not try to change this name.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * Returns:
 *
 * \li	The origin of the database.
 */

dns_rdataclass_t
dns_db_class(dns_db_t *db);
/*%<
 * The class of the database.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * Returns:
 *
 * \li	The class of the database.
 */

isc_result_t
dns_db_beginload(dns_db_t *db, dns_addrdatasetfunc_t *addp,
		 dns_dbload_t **dbloadp);
/*%<
 * Begin loading 'db'.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * \li	This is the first attempt to load 'db'.
 *
 * \li	addp != NULL && *addp == NULL
 *
 * \li	dbloadp != NULL && *dbloadp == NULL
 *
 * Ensures:
 *
 * \li	On success, *addp will be a valid dns_addrdatasetfunc_t suitable
 *	for loading 'db'.  *dbloadp will be a valid DB load context which
 *	should be used as 'arg' when *addp is called.
 *
 * Returns:
 *
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOMEMORY
 *
 * \li	Other results are possible, depending upon the database
 *	implementation used, syntax errors in the master file, etc.
 */

isc_result_t
dns_db_endload(dns_db_t *db, dns_dbload_t **dbloadp);
/*%<
 * Finish loading 'db'.
 *
 * Requires:
 *
 * \li	'db' is a valid database that is being loaded.
 *
 * \li	dbloadp != NULL and *dbloadp is a valid database load context.
 *
 * Ensures:
 *
 * \li	*dbloadp == NULL
 *
 * Returns:
 *
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOMEMORY
 *
 * \li	Other results are possible, depending upon the database
 *	implementation used, syntax errors in the master file, etc.
 */

isc_result_t
dns_db_load(dns_db_t *db, const char *filename);

isc_result_t
dns_db_load2(dns_db_t *db, const char *filename, dns_masterformat_t format);
/*%<
 * Load master file 'filename' into 'db'.
 *
 * Notes:
 * \li	This routine is equivalent to calling
 *
 *\code
 *		dns_db_beginload();
 *		dns_master_loadfile();
 *		dns_db_endload();
 *\endcode
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * \li	This is the first attempt to load 'db'.
 *
 * Returns:
 *
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOMEMORY
 *
 * \li	Other results are possible, depending upon the database
 *	implementation used, syntax errors in the master file, etc.
 */

isc_result_t
dns_db_dump(dns_db_t *db, dns_dbversion_t *version, const char *filename);

isc_result_t
dns_db_dump2(dns_db_t *db, dns_dbversion_t *version, const char *filename,
	     dns_masterformat_t masterformat);
/*%<
 * Dump version 'version' of 'db' to master file 'filename'.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * \li	'version' is a valid version.
 *
 * Returns:
 *
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOMEMORY
 *
 * \li	Other results are possible, depending upon the database
 *	implementation used, OS file errors, etc.
 */

/***
 *** Version Methods
 ***/

void
dns_db_currentversion(dns_db_t *db, dns_dbversion_t **versionp);
/*%<
 * Open the current version for reading.
 *
 * Requires:
 *
 * \li	'db' is a valid database with zone semantics.
 *
 * \li	versionp != NULL && *verisonp == NULL
 *
 * Ensures:
 *
 * \li	On success, '*versionp' is attached to the current version.
 *
 */

isc_result_t
dns_db_newversion(dns_db_t *db, dns_dbversion_t **versionp);
/*%<
 * Open a new version for reading and writing.
 *
 * Requires:
 *
 * \li	'db' is a valid database with zone semantics.
 *
 * \li	versionp != NULL && *verisonp == NULL
 *
 * Ensures:
 *
 * \li	On success, '*versionp' is attached to the current version.
 *
 * Returns:
 *
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOMEMORY
 *
 * \li	Other results are possible, depending upon the database
 *	implementation used.
 */

void
dns_db_attachversion(dns_db_t *db, dns_dbversion_t *source,
		     dns_dbversion_t **targetp);
/*%<
 * Attach '*targetp' to 'source'.
 *
 * Requires:
 *
 * \li	'db' is a valid database with zone semantics.
 *
 * \li	source is a valid open version
 *
 * \li	targetp != NULL && *targetp == NULL
 *
 * Ensures:
 *
 * \li	'*targetp' is attached to source.
 */

void
dns_db_closeversion(dns_db_t *db, dns_dbversion_t **versionp,
		    isc_boolean_t commit);
/*%<
 * Close version '*versionp'.
 *
 * Note: if '*versionp' is a read-write version and 'commit' is ISC_TRUE,
 * then all changes made in the version will take effect, otherwise they
 * will be rolled back.  The value if 'commit' is ignored for read-only
 * versions.
 *
 * Requires:
 *
 * \li	'db' is a valid database with zone semantics.
 *
 * \li	'*versionp' refers to a valid version.
 *
 * \li	If committing a writable version, then there must be no other
 *	outstanding references to the version (e.g. an active rdataset
 *	iterator).
 *
 * Ensures:
 *
 * \li	*versionp == NULL
 *
 * \li	If *versionp is a read-write version, and commit is ISC_TRUE, then
 *	the version will become the current version.  If !commit, then all
 *	changes made in the version will be undone, and the version will
 *	not become the current version.
 */

/***
 *** Node Methods
 ***/

isc_result_t
dns_db_findnode(dns_db_t *db, dns_name_t *name, isc_boolean_t create,
		dns_dbnode_t **nodep);
/*%<
 * Find the node with name 'name'.
 *
 * Notes:
 * \li	If 'create' is ISC_TRUE and no node with name 'name' exists, then
 *	such a node will be created.
 *
 * \li	This routine is for finding or creating a node with the specified
 *	name.  There are no partial matches.  It is not suitable for use
 *	in building responses to ordinary DNS queries; clients which wish
 *	to do that should use dns_db_find() instead.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * \li	'name' is a valid, non-empty, absolute name.
 *
 * \li	nodep != NULL && *nodep == NULL
 *
 * Ensures:
 *
 * \li	On success, *nodep is attached to the node with name 'name'.
 *
 * Returns:
 *
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOTFOUND			If !create and name not found.
 * \li	#ISC_R_NOMEMORY		        Can only happen if create is ISC_TRUE.
 *
 * \li	Other results are possible, depending upon the database
 *	implementation used.
 */

isc_result_t
dns_db_find(dns_db_t *db, dns_name_t *name, dns_dbversion_t *version,
	    dns_rdatatype_t type, unsigned int options, isc_stdtime_t now,
	    dns_dbnode_t **nodep, dns_name_t *foundname,
	    dns_rdataset_t *rdataset, dns_rdataset_t *sigrdataset);
/*%<
 * Find the best match for 'name' and 'type' in version 'version' of 'db'.
 *
 * Notes:
 *
 * \li	If type == dns_rdataset_any, then rdataset will not be bound.
 *
 * \li	If 'options' does not have #DNS_DBFIND_GLUEOK set, then no glue will
 *	be returned.  For zone databases, glue is as defined in RFC2181.
 *	For cache databases, glue is any rdataset with a trust of
 *	dns_trust_glue.
 *
 * \li	If 'options' does not have #DNS_DBFIND_PENDINGOK set, then no
 *	pending data will be returned.  This option is only meaningful for
 *	cache databases.
 *
 * \li	If the #DNS_DBFIND_NOWILD option is set, then wildcard matching will
 *	be disabled.  This option is only meaningful for zone databases.
 *
 * \li	If the #DNS_DBFIND_FORCENSEC option is set, the database is assumed to
 *	have NSEC records, and these will be returned when appropriate.  This
 *	is only necessary when querying a database that was not secure
 *	when created.
 *
 * \li	If the DNS_DBFIND_COVERINGNSEC option is set, then look for a
 *	NSEC record that potentially covers 'name' if a answer cannot
 *	be found.  Note the returned NSEC needs to be checked to ensure
 *	that it is correct.  This only affects answers returned from the
 *	cache.
 *
 * \li	To respond to a query for SIG records, the caller should create a
 *	rdataset iterator and extract the signatures from each rdataset.
 *
 * \li	Making queries of type ANY with #DNS_DBFIND_GLUEOK is not recommended,
 *	because the burden of determining whether a given rdataset is valid
 *	glue or not falls upon the caller.
 *
 * \li	The 'now' field is ignored if 'db' is a zone database.  If 'db' is a
 *	cache database, an rdataset will not be found unless it expires after
 *	'now'.  Any ANY query will not match unless at least one rdataset at
 *	the node expires after 'now'.  If 'now' is zero, then the current time
 *	will be used.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * \li	'type' is not SIG, or a meta-RR type other than 'ANY' (e.g. 'OPT').
 *
 * \li	'nodep' is NULL, or nodep is a valid pointer and *nodep == NULL.
 *
 * \li	'foundname' is a valid name with a dedicated buffer.
 *
 * \li	'rdataset' is NULL, or is a valid unassociated rdataset.
 *
 * Ensures,
 *	on a non-error completion:
 *
 *	\li	If nodep != NULL, then it is bound to the found node.
 *
 *	\li	If foundname != NULL, then it contains the full name of the
 *		found node.
 *
 *	\li	If rdataset != NULL and type != dns_rdatatype_any, then
 *		rdataset is bound to the found rdataset.
 *
 *	Non-error results are:
 *
 *	\li	#ISC_R_SUCCESS			The desired node and type were
 *						found.
 *
 *	\li	#DNS_R_WILDCARD			The desired node and type were
 *						found after performing
 *						wildcard matching.  This is
 *						only returned if the
 *						#DNS_DBFIND_INDICATEWILD
 *						option is set; otherwise
 *						#ISC_R_SUCCESS is returned.
 *
 *	\li	#DNS_R_GLUE			The desired node and type were
 *						found, but are glue.  This
 *						result can only occur if
 *						the DNS_DBFIND_GLUEOK option
 *						is set.  This result can only
 *						occur if 'db' is a zone
 *						database.  If type ==
 *						dns_rdatatype_any, then the
 *						node returned may contain, or
 *						consist entirely of invalid
 *						glue (i.e. data occluded by a
 *						zone cut).  The caller must
 *						take care not to return invalid
 *						glue to a client.
 *
 *	\li	#DNS_R_DELEGATION		The data requested is beneath
 *						a zone cut.  node, foundname,
 *						and rdataset reference the
 *						NS RRset of the zone cut.
 *						If 'db' is a cache database,
 *						then this is the deepest known
 *						delegation.
 *
 *	\li	#DNS_R_ZONECUT			type == dns_rdatatype_any, and
 *						the desired node is a zonecut.
 *						The caller must take care not
 *						to return inappropriate glue
 *						to a client.  This result can
 *						only occur if 'db' is a zone
 *						database and DNS_DBFIND_GLUEOK
 *						is set.
 *
 *	\li	#DNS_R_DNAME			The data requested is beneath
 *						a DNAME.  node, foundname,
 *						and rdataset reference the
 *						DNAME RRset.
 *
 *	\li	#DNS_R_CNAME			The rdataset requested was not
 *						found, but there is a CNAME
 *						at the desired name.  node,
 *						foundname, and rdataset
 *						reference the CNAME RRset.
 *
 *	\li	#DNS_R_NXDOMAIN			The desired name does not
 *						exist.
 *
 *	\li	#DNS_R_NXRRSET			The desired name exists, but
 *						the desired type does not.
 *
 *	\li	#ISC_R_NOTFOUND			The desired name does not
 *						exist, and no delegation could
 *						be found.  This result can only
 *						occur if 'db' is a cache
 *						database.  The caller should
 *						use its nameserver(s) of last
 *						resort (e.g. root hints).
 *
 *	\li	#DNS_R_NCACHENXDOMAIN		The desired name does not
 *						exist.  'node' is bound to the
 *						cache node with the desired
 *						name, and 'rdataset' contains
 *						the negative caching proof.
 *
 *	\li	#DNS_R_NCACHENXRRSET		The desired type does not
 *						exist.  'node' is bound to the
 *						cache node with the desired
 *						name, and 'rdataset' contains
 *						the negative caching proof.
 *
 *	\li	#DNS_R_EMPTYNAME			The name exists but there is
 *						no data at the name. 
 *
 *	\li	#DNS_R_COVERINGNSEC		The returned data is a NSEC
 *						that potentially covers 'name'.
 *
 *	Error results:
 *
 *	\li	#ISC_R_NOMEMORY
 *
 *	\li	#DNS_R_BADDB			Data that is required to be
 *						present in the DB, e.g. an NSEC
 *						record in a secure zone, is not
 *						present.
 *
 *	\li	Other results are possible, and should all be treated as
 *		errors.
 */

isc_result_t
dns_db_findzonecut(dns_db_t *db, dns_name_t *name,
		   unsigned int options, isc_stdtime_t now,
		   dns_dbnode_t **nodep, dns_name_t *foundname,
		   dns_rdataset_t *rdataset, dns_rdataset_t *sigrdataset);
/*%<
 * Find the deepest known zonecut which encloses 'name' in 'db'.
 *
 * Notes:
 *
 * \li	If the #DNS_DBFIND_NOEXACT option is set, then the zonecut returned
 *	(if any) will be the deepest known ancestor of 'name'.
 *
 * \li	If 'now' is zero, then the current time will be used.
 *
 * Requires:
 *
 * \li	'db' is a valid database with cache semantics.
 *
 * \li	'nodep' is NULL, or nodep is a valid pointer and *nodep == NULL.
 *
 * \li	'foundname' is a valid name with a dedicated buffer.
 *
 * \li	'rdataset' is NULL, or is a valid unassociated rdataset.
 *
 * Ensures, on a non-error completion:
 *
 * \li	If nodep != NULL, then it is bound to the found node.
 *
 * \li	If foundname != NULL, then it contains the full name of the
 *	found node.
 *
 * \li	If rdataset != NULL and type != dns_rdatatype_any, then
 *	rdataset is bound to the found rdataset.
 *
 * Non-error results are:
 *
 * \li	#ISC_R_SUCCESS
 *
 * \li	#ISC_R_NOTFOUND
 *
 * \li	Other results are possible, and should all be treated as
 *	errors.
 */

void
dns_db_attachnode(dns_db_t *db, dns_dbnode_t *source, dns_dbnode_t **targetp);
/*%<
 * Attach *targetp to source.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * \li	'source' is a valid node.
 *
 * \li	'targetp' points to a NULL dns_dbnode_t *.
 *
 * Ensures:
 *
 * \li	*targetp is attached to source.
 */

void
dns_db_detachnode(dns_db_t *db, dns_dbnode_t **nodep);
/*%<
 * Detach *nodep from its node.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * \li	'nodep' points to a valid node.
 *
 * Ensures:
 *
 * \li	*nodep is NULL.
 */

isc_result_t
dns_db_expirenode(dns_db_t *db, dns_dbnode_t *node, isc_stdtime_t now);
/*%<
 * Mark as stale all records at 'node' which expire at or before 'now'.
 *
 * Note: if 'now' is zero, then the current time will be used.
 *
 * Requires:
 *
 * \li	'db' is a valid cache database.
 *
 * \li	'node' is a valid node.
 */

void
dns_db_printnode(dns_db_t *db, dns_dbnode_t *node, FILE *out);
/*%<
 * Print a textual representation of the contents of the node to
 * 'out'.
 *
 * Note: this function is intended for debugging, not general use.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * \li	'node' is a valid node.
 */

/***
 *** DB Iterator Creation
 ***/

isc_result_t
dns_db_createiterator(dns_db_t *db, isc_boolean_t relative_names,
		      dns_dbiterator_t **iteratorp);
/*%<
 * Create an iterator for version 'version' of 'db'.
 *
 * Notes:
 *
 * \li	If 'relative_names' is ISC_TRUE, then node names returned by the
 *	iterator will be relative to the iterator's current origin.  If
 *	#ISC_FALSE, then the node names will be absolute.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * \li	iteratorp != NULL && *iteratorp == NULL
 *
 * Ensures:
 *
 * \li	On success, *iteratorp will be a valid database iterator.
 *
 * Returns:
 *
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOMEMORY
 */

/***
 *** Rdataset Methods
 ***/

/*
 * XXXRTH  Should we check for glue and pending data in dns_db_findrdataset()?
 */

isc_result_t
dns_db_findrdataset(dns_db_t *db, dns_dbnode_t *node, dns_dbversion_t *version,
		    dns_rdatatype_t type, dns_rdatatype_t covers,
		    isc_stdtime_t now, dns_rdataset_t *rdataset,
		    dns_rdataset_t *sigrdataset);
/*%<
 * Search for an rdataset of type 'type' at 'node' that are in version
 * 'version' of 'db'.  If found, make 'rdataset' refer to it.
 *
 * Notes:
 *
 * \li	If 'version' is NULL, then the current version will be used.
 *
 * \li	Care must be used when using this routine to build a DNS response:
 *	'node' should have been found with dns_db_find(), not
 *	dns_db_findnode().  No glue checking is done.  No checking for
 *	pending data is done.
 *
 * \li	The 'now' field is ignored if 'db' is a zone database.  If 'db' is a
 *	cache database, an rdataset will not be found unless it expires after
 *	'now'.  If 'now' is zero, then the current time will be used.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * \li	'node' is a valid node.
 *
 * \li	'rdataset' is a valid, disassociated rdataset.
 *
 * \li	'sigrdataset' is a valid, disassociated rdataset, or it is NULL.
 *
 * \li	If 'covers' != 0, 'type' must be SIG.
 *
 * \li	'type' is not a meta-RR type such as 'ANY' or 'OPT'.
 *
 * Ensures:
 *
 * \li	On success, 'rdataset' is associated with the found rdataset.
 *
 * Returns:
 *
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOTFOUND
 *
 * \li	Other results are possible, depending upon the database
 *	implementation used.
 */

isc_result_t
dns_db_allrdatasets(dns_db_t *db, dns_dbnode_t *node, dns_dbversion_t *version,
		    isc_stdtime_t now, dns_rdatasetiter_t **iteratorp);
/*%<
 * Make '*iteratorp' an rdataset iteratator for all rdatasets at 'node' in
 * version 'version' of 'db'.
 *
 * Notes:
 *
 * \li	If 'version' is NULL, then the current version will be used.
 *
 * \li	The 'now' field is ignored if 'db' is a zone database.  If 'db' is a
 *	cache database, an rdataset will not be found unless it expires after
 *	'now'.  Any ANY query will not match unless at least one rdataset at
 *	the node expires after 'now'.  If 'now' is zero, then the current time
 *	will be used.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * \li	'node' is a valid node.
 *
 * \li	iteratorp != NULL && *iteratorp == NULL
 *
 * Ensures:
 *
 * \li	On success, '*iteratorp' is a valid rdataset iterator.
 *
 * Returns:
 *
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOTFOUND
 *
 * \li	Other results are possible, depending upon the database
 *	implementation used.
 */

isc_result_t
dns_db_addrdataset(dns_db_t *db, dns_dbnode_t *node, dns_dbversion_t *version,
		   isc_stdtime_t now, dns_rdataset_t *rdataset,
		   unsigned int options, dns_rdataset_t *addedrdataset);
/*%<
 * Add 'rdataset' to 'node' in version 'version' of 'db'.
 *
 * Notes:
 *
 * \li	If the database has zone semantics, the #DNS_DBADD_MERGE option is set,
 *	and an rdataset of the same type as 'rdataset' already exists at
 *	'node' then the contents of 'rdataset' will be merged with the existing
 *	rdataset.  If the option is not set, then rdataset will replace any
 *	existing rdataset of the same type.  If not merging and the
 *	#DNS_DBADD_FORCE option is set, then the data will update the database
 *	without regard to trust levels.  If not forcing the data, then the
 *	rdataset will only be added if its trust level is >= the trust level of
 *	any existing rdataset.  Forcing is only meaningful for cache databases.
 *	If #DNS_DBADD_EXACT is set then there must be no rdata in common between
 *	the old and new rdata sets.  If #DNS_DBADD_EXACTTTL is set then both
 *	the old and new rdata sets must have the same ttl.
 *
 * \li	The 'now' field is ignored if 'db' is a zone database.  If 'db' is
 *	a cache database, then the added rdataset will expire no later than
 *	now + rdataset->ttl.
 *
 * \li	If 'addedrdataset' is not NULL, then it will be attached to the
 *	resulting new rdataset in the database, or to the existing data if
 *	the existing data was better.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * \li	'node' is a valid node.
 *
 * \li	'rdataset' is a valid, associated rdataset with the same class
 *	as 'db'.
 *
 * \li	'addedrdataset' is NULL, or a valid, unassociated rdataset.
 *
 * \li	The database has zone semantics and 'version' is a valid
 *	read-write version, or the database has cache semantics
 *	and version is NULL.
 *
 * \li	If the database has cache semantics, the #DNS_DBADD_MERGE option must
 *	not be set.
 *
 * Returns:
 *
 * \li	#ISC_R_SUCCESS
 * \li	#DNS_R_UNCHANGED			The operation did not change anything.
 * \li	#ISC_R_NOMEMORY
 * \li	#DNS_R_NOTEXACT
 *
 * \li	Other results are possible, depending upon the database
 *	implementation used.
 */

isc_result_t
dns_db_subtractrdataset(dns_db_t *db, dns_dbnode_t *node,
			dns_dbversion_t *version, dns_rdataset_t *rdataset,
			unsigned int options, dns_rdataset_t *newrdataset);
/*%<
 * Remove any rdata in 'rdataset' from 'node' in version 'version' of
 * 'db'.
 *
 * Notes:
 *
 * \li	If 'newrdataset' is not NULL, then it will be attached to the
 *	resulting new rdataset in the database, unless the rdataset has
 *	become nonexistent.  If DNS_DBSUB_EXACT is set then all elements
 *	of 'rdataset' must exist at 'node'.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * \li	'node' is a valid node.
 *
 * \li	'rdataset' is a valid, associated rdataset with the same class
 *	as 'db'.
 *
 * \li	'newrdataset' is NULL, or a valid, unassociated rdataset.
 *
 * \li	The database has zone semantics and 'version' is a valid
 *	read-write version.
 *
 * Returns:
 *
 * \li	#ISC_R_SUCCESS
 * \li	#DNS_R_UNCHANGED			The operation did not change anything.
 * \li	#DNS_R_NXRRSET			All rdata of the same type as those
 *					in 'rdataset' have been deleted.
 * \li	#DNS_R_NOTEXACT			Some part of 'rdataset' did not
 *					exist and DNS_DBSUB_EXACT was set.
 *
 * \li	Other results are possible, depending upon the database
 *	implementation used.
 */

isc_result_t
dns_db_deleterdataset(dns_db_t *db, dns_dbnode_t *node,
		      dns_dbversion_t *version, dns_rdatatype_t type,
		      dns_rdatatype_t covers);
/*%<
 * Make it so that no rdataset of type 'type' exists at 'node' in version
 * version 'version' of 'db'.
 *
 * Notes:
 *
 * \li	If 'type' is dns_rdatatype_any, then no rdatasets will exist in
 *	'version' (provided that the dns_db_deleterdataset() isn't followed
 *	by one or more dns_db_addrdataset() calls).
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * \li	'node' is a valid node.
 *
 * \li	The database has zone semantics and 'version' is a valid
 *	read-write version, or the database has cache semantics
 *	and version is NULL.
 *
 * \li	'type' is not a meta-RR type, except for dns_rdatatype_any, which is
 *	allowed.
 *
 * \li	If 'covers' != 0, 'type' must be SIG.
 *
 * Returns:
 *
 * \li	#ISC_R_SUCCESS
 * \li	#DNS_R_UNCHANGED			No rdatasets of 'type' existed before
 *					the operation was attempted.
 *
 * \li	Other results are possible, depending upon the database
 *	implementation used.
 */

isc_result_t
dns_db_getsoaserial(dns_db_t *db, dns_dbversion_t *ver, isc_uint32_t *serialp);
/*%<
 * Get the current SOA serial number from a zone database.
 *
 * Requires:
 * \li	'db' is a valid database with zone semantics.
 * \li	'ver' is a valid version.
 */

void
dns_db_overmem(dns_db_t *db, isc_boolean_t overmem);
/*%<
 * Enable / disable agressive cache cleaning.
 */

unsigned int
dns_db_nodecount(dns_db_t *db);
/*%<
 * Count the number of nodes in 'db'.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * Returns:
 * \li	The number of nodes in the database
 */

void
dns_db_settask(dns_db_t *db, isc_task_t *task);
/*%<
 * If task is set then the final detach maybe performed asynchronously.
 *
 * Requires:
 * \li	'db' is a valid database.
 * \li	'task' to be valid or NULL.
 */

isc_boolean_t
dns_db_ispersistent(dns_db_t *db);
/*%<
 * Is 'db' persistent?  A persistent database does not need to be loaded
 * from disk or written to disk.
 *
 * Requires:
 *
 * \li	'db' is a valid database.
 *
 * Returns:
 * \li	#ISC_TRUE	'db' is persistent.
 * \li	#ISC_FALSE	'db' is not persistent.
 */

isc_result_t
dns_db_register(const char *name, dns_dbcreatefunc_t create, void *driverarg,
		isc_mem_t *mctx, dns_dbimplementation_t **dbimp);

/*%<
 * Register a new database implementation and add it to the list of
 * supported implementations.
 *
 * Requires:
 *
 * \li 	'name' is not NULL
 * \li	'order' is a valid function pointer
 * \li	'mctx' is a valid memory context
 * \li	dbimp != NULL && *dbimp == NULL
 *
 * Returns:
 * \li	#ISC_R_SUCCESS	The registration succeeded
 * \li	#ISC_R_NOMEMORY	Out of memory
 * \li	#ISC_R_EXISTS	A database implementation with the same name exists
 *
 * Ensures:
 *
 * \li	*dbimp points to an opaque structure which must be passed to
 *	dns_db_unregister().
 */

void
dns_db_unregister(dns_dbimplementation_t **dbimp);
/*%<
 * Remove a database implementation from the the list of supported
 * implementations.  No databases of this type can be active when this
 * is called.
 *
 * Requires:
 * \li 	dbimp != NULL && *dbimp == NULL
 *
 * Ensures:
 *
 * \li	Any memory allocated in *dbimp will be freed.
 */

isc_result_t
dns_db_getoriginnode(dns_db_t *db, dns_dbnode_t **nodep);
/*%<
 * Get the origin DB node corresponding to the DB's zone.  This function
 * should typically succeed unless the underlying DB implementation doesn't
 * support the feature.
 *
 * Requires:
 *
 * \li	'db' is a valid zone database.
 * \li	'nodep' != NULL && '*nodep' == NULL
 *
 * Ensures:
 * \li	On success, '*nodep' will point to the DB node of the zone's origin.
 *
 * Returns:
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOTFOUND - the DB implementation does not support this feature.
 */

ISC_LANG_ENDDECLS

#endif /* DNS_DB_H */
@


1.3
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d5 1
a5 1
 * Permission to use, copy, modify, and distribute this software for any
d18 1
a18 1
/* $ISC: db.h,v 1.67.12.8 2004/05/14 05:06:41 marka Exp $ */
d27 2
a28 3
/*
 * DNS DB
 *
d34 1
a34 1
 * XXX <more> XXX
d37 1
a37 1
 *	The module ensures appropriate synchronization of data structures it
d41 1
a41 1
 *	No anticipated impact.
d44 1
a44 1
 *	<TBS>
d47 1
a47 1
 *	No anticipated impact.
d50 1
a50 1
 *	None.
d78 2
a79 1
				const char *filename);
d148 1
d160 1
a160 1
/*
d163 1
a163 1
 *
d183 2
a184 1
/*
d194 1
d196 2
a197 1
/*
d204 1
d206 1
a206 1
/*
d223 1
a223 1
/*
d227 1
a227 1
 *	All names in the database must be subdomains of 'origin' and in class
d232 1
a232 1
 *	DB implementation-specific parameters are passed using argc and argv.
d236 1
a236 1
 *	dbp != NULL and *dbp == NULL
d238 1
a238 1
 *	'origin' is a valid absolute domain name.
d240 1
a240 1
 *	mctx is a valid memory context
d244 1
a244 1
 *	A copy of 'origin' has been made for the databases use, and the
d250 3
a252 3
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
 *	ISC_R_NOTFOUND				db_type not found
d254 1
a254 1
 *	Many other errors are possible, depending on what db_type was
d260 1
a260 1
/*
d265 1
a265 1
 *	'source' is a valid database.
d267 1
a267 1
 *	'targetp' points to a NULL dns_db_t *.
d271 1
a271 1
 *	*targetp is attached to source.
d276 1
a276 1
/*
d281 1
a281 1
 *	'dbp' points to a valid database.
d285 1
a285 3
 *	*dbp is NULL.
 *
 *	If '*dbp' is the last reference to the database,
d287 2
a288 1
 *		All resources used by the database will be freed
d293 1
a293 1
/*
d304 1
a304 1
/*
d309 1
a309 1
 *	'db' is a valid database.
d312 2
a313 2
 *	ISC_TRUE	'db' has cache semantics
 *	ISC_FALSE	otherwise
d318 1
a318 1
/*
d323 1
a323 1
 *	'db' is a valid database.
d326 2
a327 2
 *	ISC_TRUE	'db' has zone semantics
 *	ISC_FALSE	otherwise
d332 1
a332 1
/*
d337 1
a337 1
 *	'db' is a valid database.
d340 2
a341 2
 *	ISC_TRUE	'db' has zone semantics
 *	ISC_FALSE	otherwise
d346 1
a346 1
/*
d351 1
a351 1
 *	'db' is a valid database with zone semantics.
d354 2
a355 2
 *	ISC_TRUE	'db' is secure.
 *	ISC_FALSE	'db' is not secure.
d360 1
a360 1
/*
d367 1
a367 1
 *	'db' is a valid database.
d371 1
a371 1
 *	The origin of the database.
d376 1
a376 1
/*
d381 1
a381 1
 *	'db' is a valid database.
d385 1
a385 1
 *	The class of the database.
d391 1
a391 1
/*
d396 1
a396 1
 *	'db' is a valid database.
d398 1
a398 1
 *	This is the first attempt to load 'db'.
d400 1
a400 1
 *	addp != NULL && *addp == NULL
d402 1
a402 1
 *	dbloadp != NULL && *dbloadp == NULL
d406 1
a406 1
 *	On success, *addp will be a valid dns_addrdatasetfunc_t suitable
d412 2
a413 2
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
d415 1
a415 1
 *	Other results are possible, depending upon the database
d421 1
a421 1
/*
d426 1
a426 1
 *	'db' is a valid database that is being loaded.
d428 1
a428 1
 *	dbloadp != NULL and *dbloadp is a valid database load context.
d432 1
a432 1
 *	*dbloadp == NULL
d436 2
a437 2
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
d439 1
a439 1
 *	Other results are possible, depending upon the database
d445 4
a448 1
/*
d452 1
a452 1
 *	This routine is equivalent to calling
d454 1
d458 1
d462 1
a462 1
 *	'db' is a valid database.
d464 1
a464 1
 *	This is the first attempt to load 'db'.
d468 2
a469 2
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
d471 1
a471 1
 *	Other results are possible, depending upon the database
d477 5
a481 1
/*
d486 1
a486 1
 *	'db' is a valid database.
d488 1
a488 1
 *	'version' is a valid version.
d492 2
a493 2
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
d495 1
a495 1
 *	Other results are possible, depending upon the database
d505 1
a505 1
/*
d510 1
a510 1
 *	'db' is a valid database with zone semantics.
d512 1
a512 1
 *	versionp != NULL && *verisonp == NULL
d516 1
a516 1
 *	On success, '*versionp' is attached to the current version.
d522 1
a522 1
/*
d527 1
a527 1
 *	'db' is a valid database with zone semantics.
d529 1
a529 1
 *	versionp != NULL && *verisonp == NULL
d533 1
a533 1
 *	On success, '*versionp' is attached to the current version.
d537 2
a538 2
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
d540 1
a540 1
 *	Other results are possible, depending upon the database
d547 1
a547 1
/*
d552 1
a552 1
 *	'db' is a valid database with zone semantics.
d554 1
a554 1
 *	source is a valid open version
d556 1
a556 1
 *	targetp != NULL && *targetp == NULL
d560 1
a560 1
 *	'*targetp' is attached to source.
d566 1
a566 1
/*
d576 1
a576 1
 *	'db' is a valid database with zone semantics.
d578 1
a578 1
 *	'*versionp' refers to a valid version.
d580 1
a580 1
 *	If committing a writable version, then there must be no other
d586 1
a586 1
 *	*versionp == NULL
d588 1
a588 1
 *	If *versionp is a read-write version, and commit is ISC_TRUE, then
d601 1
a601 1
/*
d605 1
a605 1
 *	If 'create' is ISC_TRUE and no node with name 'name' exists, then
d608 1
a608 1
 *	This routine is for finding or creating a node with the specified
d615 1
a615 1
 *	'db' is a valid database.
d617 1
a617 1
 *	'name' is a valid, non-empty, absolute name.
d619 1
a619 1
 *	nodep != NULL && *nodep == NULL
d623 1
a623 1
 *	On success, *nodep is attached to the node with name 'name'.
d627 3
a629 3
 *	ISC_R_SUCCESS
 *	ISC_R_NOTFOUND			If !create and name not found.
 *	ISC_R_NOMEMORY		        Can only happen if create is ISC_TRUE.
d631 1
a631 1
 *	Other results are possible, depending upon the database
d640 1
a640 1
/*
d645 1
a645 1
 *	If type == dns_rdataset_any, then rdataset will not be bound.
d647 2
a648 2
 *	If 'options' does not have DNS_DBFIND_GLUEOK set, then no glue will
 *	be returned.  For zone databases, glue is as defined in RFC 2181.
d652 1
a652 1
 *	If 'options' does not have DNS_DBFIND_PENDINGOK set, then no
d656 1
a656 1
 *	If the DNS_DBFIND_NOWILD option is set, then wildcard matching will
d659 1
a659 1
 *	If the DNS_DBFIND_FORCENSEC option is set, the database is assumed to
d664 1
a664 1
 *	If the DNS_DBFIND_COVERINGNSEC option is set, then look for a
d670 1
a670 1
 *	To respond to a query for SIG records, the caller should create a
d673 1
a673 1
 *	Making queries of type ANY with DNS_DBFIND_GLUEOK is not recommended,
d677 1
a677 1
 *	The 'now' field is ignored if 'db' is a zone database.  If 'db' is a
d685 1
a685 1
 *	'db' is a valid database.
d687 1
a687 1
 *	'type' is not SIG, or a meta-RR type other than 'ANY' (e.g. 'OPT').
d689 1
a689 1
 *	'nodep' is NULL, or nodep is a valid pointer and *nodep == NULL.
d691 1
a691 1
 *	'foundname' is a valid name with a dedicated buffer.
d693 1
a693 1
 *	'rdataset' is NULL, or is a valid unassociated rdataset.
d695 2
a696 2
 * Ensures:
 *	On a non-error completion:
d698 1
a698 1
 *		If nodep != NULL, then it is bound to the found node.
d700 1
a700 1
 *		If foundname != NULL, then it contains the full name of the
d703 1
a703 1
 *		If rdataset != NULL and type != dns_rdatatype_any, then
a705 2
 * Returns:
 *
d708 1
a708 1
 *		ISC_R_SUCCESS			The desired node and type were
d711 1
a711 1
 *		DNS_R_WILDCARD			The desired node and type were
d715 1
a715 1
 *						DNS_DBFIND_INDICATEWILD
d717 1
a717 1
 *						ISC_R_SUCCESS is returned.
d719 1
a719 1
 *		DNS_R_GLUE			The desired node and type were
d734 1
a734 1
 *		DNS_R_DELEGATION		The data requested is beneath
d742 1
a742 1
 *		DNS_R_ZONECUT			type == dns_rdatatype_any, and
d751 1
a751 1
 *		DNS_R_DNAME			The data requested is beneath
d756 1
a756 1
 *		DNS_R_CNAME			The rdataset requested was not
d762 1
a762 1
 *		DNS_R_NXDOMAIN			The desired name does not
d765 1
a765 1
 *		DNS_R_NXRRSET			The desired name exists, but
d768 1
a768 1
 *		ISC_R_NOTFOUND			The desired name does not
d776 1
a776 1
 *		DNS_R_NCACHENXDOMAIN		The desired name does not
d782 1
a782 1
 *		DNS_R_NCACHENXRRSET		The desired type does not
d788 1
a788 1
 *		DNS_R_EMPTYNAME			The name exists but there is
d791 1
a791 1
 *		DNS_R_COVERINGNSEC		The returned data is a NSEC
d796 1
a796 1
 *		ISC_R_NOMEMORY
d798 1
a798 1
 *		DNS_R_BADDB			Data that is required to be
d803 1
a803 1
 *		Other results are possible, and should all be treated as
d812 1
a812 1
/*
d817 1
a817 1
 *	If the DNS_DBFIND_NOEXACT option is set, then the zonecut returned
d820 1
a820 1
 *	If 'now' is zero, then the current time will be used.
d824 1
a824 1
 *	'db' is a valid database with cache semantics.
d826 1
a826 1
 *	'nodep' is NULL, or nodep is a valid pointer and *nodep == NULL.
d828 1
a828 1
 *	'foundname' is a valid name with a dedicated buffer.
d830 1
a830 1
 *	'rdataset' is NULL, or is a valid unassociated rdataset.
d832 1
a832 2
 * Ensures:
 *	On a non-error completion:
d834 1
a834 1
 *		If nodep != NULL, then it is bound to the found node.
d836 2
a837 2
 *		If foundname != NULL, then it contains the full name of the
 *		found node.
d839 2
a840 2
 *		If rdataset != NULL and type != dns_rdatatype_any, then
 *		rdataset is bound to the found rdataset.
d842 1
a842 1
 * Returns:
d844 1
a844 3
 *	Non-error results are:
 *
 *		ISC_R_SUCCESS
d846 1
a846 1
 *		ISC_R_NOTFOUND
d848 2
a849 2
 *		Other results are possible, and should all be treated as
 *		errors.
d854 1
a854 1
/*
d859 1
a859 1
 *	'db' is a valid database.
d861 1
a861 1
 *	'source' is a valid node.
d863 1
a863 1
 *	'targetp' points to a NULL dns_node_t *.
d867 1
a867 1
 *	*targetp is attached to source.
d872 1
a872 1
/*
d877 1
a877 1
 *	'db' is a valid database.
d879 1
a879 1
 *	'nodep' points to a valid node.
d883 1
a883 1
 *	*nodep is NULL.
d888 1
a888 1
/*
d895 1
a895 1
 *	'db' is a valid cache database.
d897 1
a897 1
 *	'node' is a valid node.
d902 1
a902 1
/*
d910 1
a910 1
 *	'db' is a valid database.
d912 1
a912 1
 *	'node' is a valid node.
d922 1
a922 1
/*
d927 1
a927 1
 *	If 'relative_names' is ISC_TRUE, then node names returned by the
d929 1
a929 1
 *	ISC_FALSE, then the node names will be absolute.
d933 1
a933 1
 *	'db' is a valid database.
d935 1
a935 1
 *	iteratorp != NULL && *iteratorp == NULL
d939 1
a939 1
 *	On success, *iteratorp will be a valid database iterator.
d943 2
a944 2
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
d960 1
a960 1
/*
d966 1
a966 1
 *	If 'version' is NULL, then the current version will be used.
d968 1
a968 1
 *	Care must be used when using this routine to build a DNS response:
d973 1
a973 1
 *	The 'now' field is ignored if 'db' is a zone database.  If 'db' is a
d979 1
a979 1
 *	'db' is a valid database.
d981 1
a981 1
 *	'node' is a valid node.
d983 1
a983 1
 *	'rdataset' is a valid, disassociated rdataset.
d985 1
a985 1
 *	'sigrdataset' is a valid, disassociated rdataset, or it is NULL.
d987 1
a987 1
 *	If 'covers' != 0, 'type' must be SIG.
d989 1
a989 1
 *	'type' is not a meta-RR type such as 'ANY' or 'OPT'.
d993 1
a993 1
 *	On success, 'rdataset' is associated with the found rdataset.
d997 2
a998 2
 *	ISC_R_SUCCESS
 *	ISC_R_NOTFOUND
d1000 1
a1000 1
 *	Other results are possible, depending upon the database
d1007 1
a1007 1
/*
d1013 1
a1013 1
 *	If 'version' is NULL, then the current version will be used.
d1015 1
a1015 1
 *	The 'now' field is ignored if 'db' is a zone database.  If 'db' is a
d1023 1
a1023 1
 *	'db' is a valid database.
d1025 1
a1025 1
 *	'node' is a valid node.
d1027 1
a1027 1
 *	iteratorp != NULL && *iteratorp == NULL
d1031 1
a1031 1
 *	On success, '*iteratorp' is a valid rdataset iterator.
d1035 2
a1036 2
 *	ISC_R_SUCCESS
 *	ISC_R_NOTFOUND
d1038 1
a1038 1
 *	Other results are possible, depending upon the database
d1046 1
a1046 1
/*
d1051 1
a1051 1
 *	If the database has zone semantics, the DNS_DBADD_MERGE option is set,
d1056 1
a1056 1
 *	DNS_DBADD_FORCE option is set, then the data will update the database
d1060 2
a1061 2
 *	If DNS_DBADD_EXACT is set then there must be no rdata in common between
 *	the old and new rdata sets.  If DNS_DBADD_EXACTTTL is set then both
d1064 1
a1064 1
 *	The 'now' field is ignored if 'db' is a zone database.  If 'db' is
d1068 1
a1068 1
 *	If 'addedrdataset' is not NULL, then it will be attached to the
d1074 1
a1074 1
 *	'db' is a valid database.
d1076 1
a1076 1
 *	'node' is a valid node.
d1078 1
a1078 1
 *	'rdataset' is a valid, associated rdataset with the same class
d1081 1
a1081 1
 *	'addedrdataset' is NULL, or a valid, unassociated rdataset.
d1083 1
a1083 1
 *	The database has zone semantics and 'version' is a valid
d1087 1
a1087 1
 *	If the database has cache semantics, the DNS_DBADD_MERGE option must
d1092 4
a1095 4
 *	ISC_R_SUCCESS
 *	DNS_R_UNCHANGED			The operation did not change anything.
 *	ISC_R_NOMEMORY
 *	DNS_R_NOTEXACT
d1097 1
a1097 1
 *	Other results are possible, depending upon the database
d1105 1
a1105 1
/*
d1111 1
a1111 1
 *	If 'newrdataset' is not NULL, then it will be attached to the
d1118 1
a1118 1
 *	'db' is a valid database.
d1120 1
a1120 1
 *	'node' is a valid node.
d1122 1
a1122 1
 *	'rdataset' is a valid, associated rdataset with the same class
d1125 1
a1125 1
 *	'newrdataset' is NULL, or a valid, unassociated rdataset.
d1127 1
a1127 1
 *	The database has zone semantics and 'version' is a valid
d1132 3
a1134 3
 *	ISC_R_SUCCESS
 *	DNS_R_UNCHANGED			The operation did not change anything.
 *	DNS_R_NXRRSET			All rdata of the same type as those
d1136 1
a1136 1
 *	DNS_R_NOTEXACT			Some part of 'rdataset' did not
d1139 1
a1139 1
 *	Other results are possible, depending upon the database
d1147 1
a1147 1
/*
d1153 1
a1153 1
 *	If 'type' is dns_rdatatype_any, then no rdatasets will exist in
d1159 1
a1159 1
 *	'db' is a valid database.
d1161 1
a1161 1
 *	'node' is a valid node.
d1163 1
a1163 1
 *	The database has zone semantics and 'version' is a valid
d1167 1
a1167 1
 *	'type' is not a meta-RR type, except for dns_rdatatype_any, which is
d1170 1
a1170 1
 *	If 'covers' != 0, 'type' must be SIG.
d1174 2
a1175 2
 *	ISC_R_SUCCESS
 *	DNS_R_UNCHANGED			No rdatasets of 'type' existed before
d1178 1
a1178 1
 *	Other results are possible, depending upon the database
d1184 1
a1184 1
/*
d1188 2
a1189 2
 *      'db' is a valid database with zone semantics.
 *      'ver' is a valid version.
d1194 1
a1194 1
/*
d1200 1
a1200 1
/*
d1205 1
a1205 1
 *	'db' is a valid database.
d1208 1
a1208 1
 * 	The number of nodes in the database
d1213 1
a1213 1
/*
d1217 2
a1218 2
 *	'db' is a valid database.
 *	'task' to be valid or NULL.
d1223 1
a1223 1
/*
d1229 1
a1229 1
 *	'db' is a valid database.
d1232 2
a1233 2
 *	ISC_TRUE	'db' is persistent.
 *	ISC_FALSE	'db' is not persistent.
d1240 1
a1240 1
/*
d1246 4
a1249 4
 * 	'name' is not NULL
 * 	'order' is a valid function pointer
 * 	'mctx' is a valid memory context
 * 	dbimp != NULL && *dbimp == NULL
d1252 3
a1254 3
 * 	ISC_R_SUCCESS	The registration succeeded
 * 	ISC_R_NOMEMORY	Out of memory
 * 	ISC_R_EXISTS	A database implementation with the same name exists
d1258 1
a1258 1
 *	*dbimp points to an opaque structure which must be passed to
d1264 1
a1264 1
/*
d1270 1
a1270 1
 * 	dbimp != NULL && *dbimp == NULL
d1274 21
a1294 1
 * 	Any memory allocated in *dbimp will be freed.
@


1.2
log
@update to BIND v9.2.3. ok todd@@
@
text
@d2 2
a3 1
 * Copyright (C) 1999-2001, 2003  Internet Software Consortium.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: db.h,v 1.67.2.2 2003/10/09 07:32:39 marka Exp $ */
d147 1
d190 2
d293 1
a293 1
 * Note; ownrship of the eventp is taken from the caller (and *eventp is
d646 11
d700 8
d777 6
d788 1
a788 1
 *						present in the DB, e.g. an NXT
d1201 10
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2001  Internet Software Consortium.
d18 1
a18 1
/* $ISC: db.h,v 1.67 2001/08/28 03:58:13 marka Exp $ */
d601 1
a601 2
 *	'name' is a valid, non-empty, absolute name that is a subdomain of
 *	the database's origin.  (It need not be a proper subdomain.)
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1999-2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: db.h,v 1.67.12.8 2004/05/14 05:06:41 marka Exp $ */
a146 1
	void		(*settask)(dns_db_t *db, isc_task_t *);
a188 2
#define DNS_DBFIND_FORCENSEC		0x20
#define DNS_DBFIND_COVERINGNSEC		0x40
d290 1
a290 1
 * Note; ownership of the eventp is taken from the caller (and *eventp is
d601 2
a602 1
 *	'name' is a valid, non-empty, absolute name.
a643 11
 *	If the DNS_DBFIND_FORCENSEC option is set, the database is assumed to
 *	have NSEC records, and these will be returned when appropriate.  This
 *	is only necessary when querying a database that was not secure
 *	when created.
 *
 *	If the DNS_DBFIND_COVERINGNSEC option is set, then look for a
 *	NSEC record that potentially covers 'name' if a answer cannot
 *	be found.  Note the returned NSEC needs to be checked to ensure
 *	that it is correct.  This only affects answers returned from the
 *	cache.
 *
a686 8
 *		DNS_R_WILDCARD			The desired node and type were
 *						found after performing
 *						wildcard matching.  This is
 *						only returned if the
 *						DNS_DBFIND_INDICATEWILD
 *						option is set; otherwise
 *						ISC_R_SUCCESS is returned.
 *
a755 6
 *		DNS_R_EMPTYNAME			The name exists but there is
 *						no data at the name. 
 *
 *		DNS_R_COVERINGNSEC		The returned data is a NSEC
 *						that potentially covers 'name'.
 *
d761 1
a761 1
 *						present in the DB, e.g. an NSEC
a1173 10
 */

void
dns_db_settask(dns_db_t *db, isc_task_t *task);
/*
 * If task is set then the final detach maybe performed asynchronously.
 *
 * Requires:
 *	'db' is a valid database.
 *	'task' to be valid or NULL.
@


1.1.1.3
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005, 2007  Internet Systems Consortium, Inc. ("ISC")
d5 1
a5 1
 * Permission to use, copy, modify, and/or distribute this software for any
d18 1
a18 1
/* $ISC: db.h,v 1.76.18.10 2007/08/28 07:20:05 tbox Exp $ */
d27 3
a29 2
/*! \file
 * \brief
d35 1
a35 1
 * XXX more XXX
d38 1
a38 1
 * \li	The module ensures appropriate synchronization of data structures it
d42 1
a42 1
 * \li	No anticipated impact.
d45 1
a45 1
 * \li	TBS
d48 1
a48 1
 * \li	No anticipated impact.
d51 1
a51 1
 * \li	None.
d79 1
a79 2
				const char *filename,
				dns_masterformat_t masterformat);
a147 1
	isc_result_t	(*getoriginnode)(dns_db_t *db, dns_dbnode_t **nodep);
d159 1
a159 1
/*%
d162 1
a162 1
 * \brief
d182 1
a182 2
/*@@{*/
/*%
a191 1
/*@@}*/
d193 1
a193 2
/*@@{*/
/*%
a199 1
/*@@}*/
d201 1
a201 1
/*%
d218 1
a218 1
/*%<
d222 1
a222 1
 * \li	All names in the database must be subdomains of 'origin' and in class
d227 1
a227 1
 * \li	DB implementation-specific parameters are passed using argc and argv.
d231 1
a231 1
 * \li	dbp != NULL and *dbp == NULL
d233 1
a233 1
 * \li	'origin' is a valid absolute domain name.
d235 1
a235 1
 * \li	mctx is a valid memory context
d239 1
a239 1
 * \li	A copy of 'origin' has been made for the databases use, and the
d245 3
a247 3
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOMEMORY
 * \li	#ISC_R_NOTFOUND				db_type not found
d249 1
a249 1
 * \li	Many other errors are possible, depending on what db_type was
d255 1
a255 1
/*%<
d260 1
a260 1
 * \li	'source' is a valid database.
d262 1
a262 1
 * \li	'targetp' points to a NULL dns_db_t *.
d266 1
a266 1
 * \li	*targetp is attached to source.
d271 1
a271 1
/*%<
d276 1
a276 1
 * \li	'dbp' points to a valid database.
d280 3
a282 1
 * \li	*dbp is NULL.
d284 1
a284 2
 * \li	If '*dbp' is the last reference to the database,
 *		all resources used by the database will be freed
d289 1
a289 1
/*%<
d300 1
a300 1
/*%<
d305 1
a305 1
 * \li	'db' is a valid database.
d308 2
a309 2
 * \li	#ISC_TRUE	'db' has cache semantics
 * \li	#ISC_FALSE	otherwise
d314 1
a314 1
/*%<
d319 1
a319 1
 * \li	'db' is a valid database.
d322 2
a323 2
 * \li	#ISC_TRUE	'db' has zone semantics
 * \li	#ISC_FALSE	otherwise
d328 1
a328 1
/*%<
d333 1
a333 1
 * \li	'db' is a valid database.
d336 2
a337 2
 * \li	#ISC_TRUE	'db' has zone semantics
 * \li	#ISC_FALSE	otherwise
d342 1
a342 1
/*%<
d347 1
a347 1
 * \li	'db' is a valid database with zone semantics.
d350 2
a351 2
 * \li	#ISC_TRUE	'db' is secure.
 * \li	#ISC_FALSE	'db' is not secure.
d356 1
a356 1
/*%<
d363 1
a363 1
 * \li	'db' is a valid database.
d367 1
a367 1
 * \li	The origin of the database.
d372 1
a372 1
/*%<
d377 1
a377 1
 * \li	'db' is a valid database.
d381 1
a381 1
 * \li	The class of the database.
d387 1
a387 1
/*%<
d392 1
a392 1
 * \li	'db' is a valid database.
d394 1
a394 1
 * \li	This is the first attempt to load 'db'.
d396 1
a396 1
 * \li	addp != NULL && *addp == NULL
d398 1
a398 1
 * \li	dbloadp != NULL && *dbloadp == NULL
d402 1
a402 1
 * \li	On success, *addp will be a valid dns_addrdatasetfunc_t suitable
d408 2
a409 2
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOMEMORY
d411 1
a411 1
 * \li	Other results are possible, depending upon the database
d417 1
a417 1
/*%<
d422 1
a422 1
 * \li	'db' is a valid database that is being loaded.
d424 1
a424 1
 * \li	dbloadp != NULL and *dbloadp is a valid database load context.
d428 1
a428 1
 * \li	*dbloadp == NULL
d432 2
a433 2
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOMEMORY
d435 1
a435 1
 * \li	Other results are possible, depending upon the database
d441 1
a441 4

isc_result_t
dns_db_load2(dns_db_t *db, const char *filename, dns_masterformat_t format);
/*%<
d445 1
a445 1
 * \li	This routine is equivalent to calling
a446 1
 *\code
a449 1
 *\endcode
d453 1
a453 1
 * \li	'db' is a valid database.
d455 1
a455 1
 * \li	This is the first attempt to load 'db'.
d459 2
a460 2
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOMEMORY
d462 1
a462 1
 * \li	Other results are possible, depending upon the database
d468 1
a468 5

isc_result_t
dns_db_dump2(dns_db_t *db, dns_dbversion_t *version, const char *filename,
	     dns_masterformat_t masterformat);
/*%<
d473 1
a473 1
 * \li	'db' is a valid database.
d475 1
a475 1
 * \li	'version' is a valid version.
d479 2
a480 2
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOMEMORY
d482 1
a482 1
 * \li	Other results are possible, depending upon the database
d492 1
a492 1
/*%<
d497 1
a497 1
 * \li	'db' is a valid database with zone semantics.
d499 1
a499 1
 * \li	versionp != NULL && *verisonp == NULL
d503 1
a503 1
 * \li	On success, '*versionp' is attached to the current version.
d509 1
a509 1
/*%<
d514 1
a514 1
 * \li	'db' is a valid database with zone semantics.
d516 1
a516 1
 * \li	versionp != NULL && *verisonp == NULL
d520 1
a520 1
 * \li	On success, '*versionp' is attached to the current version.
d524 2
a525 2
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOMEMORY
d527 1
a527 1
 * \li	Other results are possible, depending upon the database
d534 1
a534 1
/*%<
d539 1
a539 1
 * \li	'db' is a valid database with zone semantics.
d541 1
a541 1
 * \li	source is a valid open version
d543 1
a543 1
 * \li	targetp != NULL && *targetp == NULL
d547 1
a547 1
 * \li	'*targetp' is attached to source.
d553 1
a553 1
/*%<
d563 1
a563 1
 * \li	'db' is a valid database with zone semantics.
d565 1
a565 1
 * \li	'*versionp' refers to a valid version.
d567 1
a567 1
 * \li	If committing a writable version, then there must be no other
d573 1
a573 1
 * \li	*versionp == NULL
d575 1
a575 1
 * \li	If *versionp is a read-write version, and commit is ISC_TRUE, then
d588 1
a588 1
/*%<
d592 1
a592 1
 * \li	If 'create' is ISC_TRUE and no node with name 'name' exists, then
d595 1
a595 1
 * \li	This routine is for finding or creating a node with the specified
d602 1
a602 1
 * \li	'db' is a valid database.
d604 1
a604 1
 * \li	'name' is a valid, non-empty, absolute name.
d606 1
a606 1
 * \li	nodep != NULL && *nodep == NULL
d610 1
a610 1
 * \li	On success, *nodep is attached to the node with name 'name'.
d614 3
a616 3
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOTFOUND			If !create and name not found.
 * \li	#ISC_R_NOMEMORY		        Can only happen if create is ISC_TRUE.
d618 1
a618 1
 * \li	Other results are possible, depending upon the database
d627 1
a627 1
/*%<
d632 1
a632 1
 * \li	If type == dns_rdataset_any, then rdataset will not be bound.
d634 2
a635 2
 * \li	If 'options' does not have #DNS_DBFIND_GLUEOK set, then no glue will
 *	be returned.  For zone databases, glue is as defined in RFC2181.
d639 1
a639 1
 * \li	If 'options' does not have #DNS_DBFIND_PENDINGOK set, then no
d643 1
a643 1
 * \li	If the #DNS_DBFIND_NOWILD option is set, then wildcard matching will
d646 1
a646 1
 * \li	If the #DNS_DBFIND_FORCENSEC option is set, the database is assumed to
d651 1
a651 1
 * \li	If the DNS_DBFIND_COVERINGNSEC option is set, then look for a
d657 1
a657 1
 * \li	To respond to a query for SIG records, the caller should create a
d660 1
a660 1
 * \li	Making queries of type ANY with #DNS_DBFIND_GLUEOK is not recommended,
d664 1
a664 1
 * \li	The 'now' field is ignored if 'db' is a zone database.  If 'db' is a
d672 1
a672 1
 * \li	'db' is a valid database.
d674 1
a674 1
 * \li	'type' is not SIG, or a meta-RR type other than 'ANY' (e.g. 'OPT').
d676 1
a676 1
 * \li	'nodep' is NULL, or nodep is a valid pointer and *nodep == NULL.
d678 1
a678 1
 * \li	'foundname' is a valid name with a dedicated buffer.
d680 1
a680 1
 * \li	'rdataset' is NULL, or is a valid unassociated rdataset.
d682 2
a683 2
 * Ensures,
 *	on a non-error completion:
d685 1
a685 1
 *	\li	If nodep != NULL, then it is bound to the found node.
d687 1
a687 1
 *	\li	If foundname != NULL, then it contains the full name of the
d690 1
a690 1
 *	\li	If rdataset != NULL and type != dns_rdatatype_any, then
d693 2
d697 1
a697 1
 *	\li	#ISC_R_SUCCESS			The desired node and type were
d700 1
a700 1
 *	\li	#DNS_R_WILDCARD			The desired node and type were
d704 1
a704 1
 *						#DNS_DBFIND_INDICATEWILD
d706 1
a706 1
 *						#ISC_R_SUCCESS is returned.
d708 1
a708 1
 *	\li	#DNS_R_GLUE			The desired node and type were
d723 1
a723 1
 *	\li	#DNS_R_DELEGATION		The data requested is beneath
d731 1
a731 1
 *	\li	#DNS_R_ZONECUT			type == dns_rdatatype_any, and
d740 1
a740 1
 *	\li	#DNS_R_DNAME			The data requested is beneath
d745 1
a745 1
 *	\li	#DNS_R_CNAME			The rdataset requested was not
d751 1
a751 1
 *	\li	#DNS_R_NXDOMAIN			The desired name does not
d754 1
a754 1
 *	\li	#DNS_R_NXRRSET			The desired name exists, but
d757 1
a757 1
 *	\li	#ISC_R_NOTFOUND			The desired name does not
d765 1
a765 1
 *	\li	#DNS_R_NCACHENXDOMAIN		The desired name does not
d771 1
a771 1
 *	\li	#DNS_R_NCACHENXRRSET		The desired type does not
d777 1
a777 1
 *	\li	#DNS_R_EMPTYNAME			The name exists but there is
d780 1
a780 1
 *	\li	#DNS_R_COVERINGNSEC		The returned data is a NSEC
d785 1
a785 1
 *	\li	#ISC_R_NOMEMORY
d787 1
a787 1
 *	\li	#DNS_R_BADDB			Data that is required to be
d792 1
a792 1
 *	\li	Other results are possible, and should all be treated as
d801 1
a801 1
/*%<
d806 1
a806 1
 * \li	If the #DNS_DBFIND_NOEXACT option is set, then the zonecut returned
d809 1
a809 1
 * \li	If 'now' is zero, then the current time will be used.
d813 1
a813 1
 * \li	'db' is a valid database with cache semantics.
d815 1
a815 1
 * \li	'nodep' is NULL, or nodep is a valid pointer and *nodep == NULL.
d817 1
a817 1
 * \li	'foundname' is a valid name with a dedicated buffer.
d819 1
a819 1
 * \li	'rdataset' is NULL, or is a valid unassociated rdataset.
d821 2
a822 1
 * Ensures, on a non-error completion:
d824 1
a824 1
 * \li	If nodep != NULL, then it is bound to the found node.
d826 2
a827 2
 * \li	If foundname != NULL, then it contains the full name of the
 *	found node.
d829 2
a830 2
 * \li	If rdataset != NULL and type != dns_rdatatype_any, then
 *	rdataset is bound to the found rdataset.
d832 1
a832 1
 * Non-error results are:
d834 3
a836 1
 * \li	#ISC_R_SUCCESS
d838 1
a838 1
 * \li	#ISC_R_NOTFOUND
d840 2
a841 2
 * \li	Other results are possible, and should all be treated as
 *	errors.
d846 1
a846 1
/*%<
d851 1
a851 1
 * \li	'db' is a valid database.
d853 1
a853 1
 * \li	'source' is a valid node.
d855 1
a855 1
 * \li	'targetp' points to a NULL dns_dbnode_t *.
d859 1
a859 1
 * \li	*targetp is attached to source.
d864 1
a864 1
/*%<
d869 1
a869 1
 * \li	'db' is a valid database.
d871 1
a871 1
 * \li	'nodep' points to a valid node.
d875 1
a875 1
 * \li	*nodep is NULL.
d880 1
a880 1
/*%<
d887 1
a887 1
 * \li	'db' is a valid cache database.
d889 1
a889 1
 * \li	'node' is a valid node.
d894 1
a894 1
/*%<
d902 1
a902 1
 * \li	'db' is a valid database.
d904 1
a904 1
 * \li	'node' is a valid node.
d914 1
a914 1
/*%<
d919 1
a919 1
 * \li	If 'relative_names' is ISC_TRUE, then node names returned by the
d921 1
a921 1
 *	#ISC_FALSE, then the node names will be absolute.
d925 1
a925 1
 * \li	'db' is a valid database.
d927 1
a927 1
 * \li	iteratorp != NULL && *iteratorp == NULL
d931 1
a931 1
 * \li	On success, *iteratorp will be a valid database iterator.
d935 2
a936 2
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOMEMORY
d952 1
a952 1
/*%<
d958 1
a958 1
 * \li	If 'version' is NULL, then the current version will be used.
d960 1
a960 1
 * \li	Care must be used when using this routine to build a DNS response:
d965 1
a965 1
 * \li	The 'now' field is ignored if 'db' is a zone database.  If 'db' is a
d971 1
a971 1
 * \li	'db' is a valid database.
d973 1
a973 1
 * \li	'node' is a valid node.
d975 1
a975 1
 * \li	'rdataset' is a valid, disassociated rdataset.
d977 1
a977 1
 * \li	'sigrdataset' is a valid, disassociated rdataset, or it is NULL.
d979 1
a979 1
 * \li	If 'covers' != 0, 'type' must be SIG.
d981 1
a981 1
 * \li	'type' is not a meta-RR type such as 'ANY' or 'OPT'.
d985 1
a985 1
 * \li	On success, 'rdataset' is associated with the found rdataset.
d989 2
a990 2
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOTFOUND
d992 1
a992 1
 * \li	Other results are possible, depending upon the database
d999 1
a999 1
/*%<
d1005 1
a1005 1
 * \li	If 'version' is NULL, then the current version will be used.
d1007 1
a1007 1
 * \li	The 'now' field is ignored if 'db' is a zone database.  If 'db' is a
d1015 1
a1015 1
 * \li	'db' is a valid database.
d1017 1
a1017 1
 * \li	'node' is a valid node.
d1019 1
a1019 1
 * \li	iteratorp != NULL && *iteratorp == NULL
d1023 1
a1023 1
 * \li	On success, '*iteratorp' is a valid rdataset iterator.
d1027 2
a1028 2
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOTFOUND
d1030 1
a1030 1
 * \li	Other results are possible, depending upon the database
d1038 1
a1038 1
/*%<
d1043 1
a1043 1
 * \li	If the database has zone semantics, the #DNS_DBADD_MERGE option is set,
d1048 1
a1048 1
 *	#DNS_DBADD_FORCE option is set, then the data will update the database
d1052 2
a1053 2
 *	If #DNS_DBADD_EXACT is set then there must be no rdata in common between
 *	the old and new rdata sets.  If #DNS_DBADD_EXACTTTL is set then both
d1056 1
a1056 1
 * \li	The 'now' field is ignored if 'db' is a zone database.  If 'db' is
d1060 1
a1060 1
 * \li	If 'addedrdataset' is not NULL, then it will be attached to the
d1066 1
a1066 1
 * \li	'db' is a valid database.
d1068 1
a1068 1
 * \li	'node' is a valid node.
d1070 1
a1070 1
 * \li	'rdataset' is a valid, associated rdataset with the same class
d1073 1
a1073 1
 * \li	'addedrdataset' is NULL, or a valid, unassociated rdataset.
d1075 1
a1075 1
 * \li	The database has zone semantics and 'version' is a valid
d1079 1
a1079 1
 * \li	If the database has cache semantics, the #DNS_DBADD_MERGE option must
d1084 4
a1087 4
 * \li	#ISC_R_SUCCESS
 * \li	#DNS_R_UNCHANGED			The operation did not change anything.
 * \li	#ISC_R_NOMEMORY
 * \li	#DNS_R_NOTEXACT
d1089 1
a1089 1
 * \li	Other results are possible, depending upon the database
d1097 1
a1097 1
/*%<
d1103 1
a1103 1
 * \li	If 'newrdataset' is not NULL, then it will be attached to the
d1110 1
a1110 1
 * \li	'db' is a valid database.
d1112 1
a1112 1
 * \li	'node' is a valid node.
d1114 1
a1114 1
 * \li	'rdataset' is a valid, associated rdataset with the same class
d1117 1
a1117 1
 * \li	'newrdataset' is NULL, or a valid, unassociated rdataset.
d1119 1
a1119 1
 * \li	The database has zone semantics and 'version' is a valid
d1124 3
a1126 3
 * \li	#ISC_R_SUCCESS
 * \li	#DNS_R_UNCHANGED			The operation did not change anything.
 * \li	#DNS_R_NXRRSET			All rdata of the same type as those
d1128 1
a1128 1
 * \li	#DNS_R_NOTEXACT			Some part of 'rdataset' did not
d1131 1
a1131 1
 * \li	Other results are possible, depending upon the database
d1139 1
a1139 1
/*%<
d1145 1
a1145 1
 * \li	If 'type' is dns_rdatatype_any, then no rdatasets will exist in
d1151 1
a1151 1
 * \li	'db' is a valid database.
d1153 1
a1153 1
 * \li	'node' is a valid node.
d1155 1
a1155 1
 * \li	The database has zone semantics and 'version' is a valid
d1159 1
a1159 1
 * \li	'type' is not a meta-RR type, except for dns_rdatatype_any, which is
d1162 1
a1162 1
 * \li	If 'covers' != 0, 'type' must be SIG.
d1166 2
a1167 2
 * \li	#ISC_R_SUCCESS
 * \li	#DNS_R_UNCHANGED			No rdatasets of 'type' existed before
d1170 1
a1170 1
 * \li	Other results are possible, depending upon the database
d1176 1
a1176 1
/*%<
d1180 2
a1181 2
 * \li	'db' is a valid database with zone semantics.
 * \li	'ver' is a valid version.
d1186 1
a1186 1
/*%<
d1192 1
a1192 1
/*%<
d1197 1
a1197 1
 * \li	'db' is a valid database.
d1200 1
a1200 1
 * \li	The number of nodes in the database
d1205 1
a1205 1
/*%<
d1209 2
a1210 2
 * \li	'db' is a valid database.
 * \li	'task' to be valid or NULL.
d1215 1
a1215 1
/*%<
d1221 1
a1221 1
 * \li	'db' is a valid database.
d1224 2
a1225 2
 * \li	#ISC_TRUE	'db' is persistent.
 * \li	#ISC_FALSE	'db' is not persistent.
d1232 1
a1232 1
/*%<
d1238 4
a1241 4
 * \li 	'name' is not NULL
 * \li	'order' is a valid function pointer
 * \li	'mctx' is a valid memory context
 * \li	dbimp != NULL && *dbimp == NULL
d1244 3
a1246 3
 * \li	#ISC_R_SUCCESS	The registration succeeded
 * \li	#ISC_R_NOMEMORY	Out of memory
 * \li	#ISC_R_EXISTS	A database implementation with the same name exists
d1250 1
a1250 1
 * \li	*dbimp points to an opaque structure which must be passed to
d1256 1
a1256 1
/*%<
d1262 1
a1262 1
 * \li 	dbimp != NULL && *dbimp == NULL
d1266 1
a1266 21
 * \li	Any memory allocated in *dbimp will be freed.
 */

isc_result_t
dns_db_getoriginnode(dns_db_t *db, dns_dbnode_t **nodep);
/*%<
 * Get the origin DB node corresponding to the DB's zone.  This function
 * should typically succeed unless the underlying DB implementation doesn't
 * support the feature.
 *
 * Requires:
 *
 * \li	'db' is a valid zone database.
 * \li	'nodep' != NULL && '*nodep' == NULL
 *
 * Ensures:
 * \li	On success, '*nodep' will point to the DB node of the zone's origin.
 *
 * Returns:
 * \li	#ISC_R_SUCCESS
 * \li	#ISC_R_NOTFOUND - the DB implementation does not support this feature.
@


