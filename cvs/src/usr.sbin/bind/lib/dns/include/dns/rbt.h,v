head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.4.0.38
	OPENBSD_6_2_BASE:1.1.1.4
	OPENBSD_6_1:1.1.1.4.0.40
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.36
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.32
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.34
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.26
	OPENBSD_5_7_BASE:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.30
	OPENBSD_5_6_BASE:1.1.1.4
	OPENBSD_5_5:1.1.1.4.0.28
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.24
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.22
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.20
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.18
	OPENBSD_5_0:1.1.1.4.0.16
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.14
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.12
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.8
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.10
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.6
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.4
	OPENBSD_4_4_BASE:1.1.1.4
	BIND_9_4_2_P1:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	OPENBSD_4_3_BASE:1.1.1.4
	BIND_9_4_2:1.1.1.4
	OPENBSD_4_2:1.1.1.3.0.10
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.8
	OPENBSD_4_1_BASE:1.1.1.3
	BIND_9_3_4:1.1.1.3
	BIND_9_3_3:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.6
	OPENBSD_4_0_BASE:1.1.1.3
	BIND_9_3_2:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.4
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.2
	OPENBSD_3_8_BASE:1.1.1.3
	BIND_9_3_1:1.1.1.3
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.01.20.21.07.20;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.20;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.14;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.03.22.16.38.05;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.12.09.12.34.49;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (C) 1999-2001  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: rbt.h,v 1.55 2001/06/01 03:07:54 halley Exp $ */

#ifndef DNS_RBT_H
#define DNS_RBT_H 1

#include <isc/lang.h>

#include <dns/types.h>

ISC_LANG_BEGINDECLS

#define DNS_RBT_USEHASH 1

/*
 * Option values for dns_rbt_findnode() and dns_rbt_findname().
 * These are used to form a bitmask.
 */
#define DNS_RBTFIND_NOOPTIONS			0x00
#define DNS_RBTFIND_EMPTYDATA			0x01
#define DNS_RBTFIND_NOEXACT			0x02
#define DNS_RBTFIND_NOPREDECESSOR		0x04

/*
 * These should add up to 30.
 */
#define DNS_RBT_LOCKLENGTH			10
#define DNS_RBT_REFLENGTH			20

/*
 * This is the structure that is used for each node in the red/black
 * tree of trees.  NOTE WELL:  the implementation manages this as a variable
 * length structure, with the actual wire-format name and other data
 * appended to this structure.  Allocating a contiguous block of memory for
 * multiple dns_rbtnode structures will not work.
 */
typedef struct dns_rbtnode {
	struct dns_rbtnode *parent;
	struct dns_rbtnode *left;
	struct dns_rbtnode *right;
	struct dns_rbtnode *down;
#ifdef DNS_RBT_USEHASH
	struct dns_rbtnode *hashnext;
#endif
	/*
	 * The following bitfields add up to a total bitwidth of 32.
	 * The range of values necessary for each item is indicated,
	 * but in the case of "attributes" the field is wider to accomodate
	 * possible future expansion.  "offsetlen" could be one bit
	 * narrower by always adjusting its value by 1 to find the real
	 * offsetlen, but doing so does not gain anything (except perhaps
	 * another bit for "attributes", which doesn't yet need any more).
	 *
	 * In each case below the "range" indicated is what's _necessary_ for
	 * the bitfield to hold, not what it actually _can_ hold.
	 */
	unsigned int is_root : 1;	/* range is 0..1 */
	unsigned int color : 1;		/* range is 0..1 */
	unsigned int find_callback : 1;	/* range is 0..1 */
	unsigned int attributes : 4;	/* range is 0..2 */
	unsigned int namelen : 8;	/* range is 1..255 */
	unsigned int offsetlen : 8;	/* range is 1..128 */
	unsigned int padbytes : 9;	/* range is 0..380 */

#ifdef DNS_RBT_USEHASH
	unsigned int hashval;
#endif

	/*
	 * These values are used in the RBT DB implementation.  The appropriate
	 * node lock must be held before accessing them.
	 */
	void *data;
	unsigned int dirty:1;
	unsigned int wild:1;
	unsigned int locknum:DNS_RBT_LOCKLENGTH;
	unsigned int references:DNS_RBT_REFLENGTH;
} dns_rbtnode_t;

typedef isc_result_t (*dns_rbtfindcallback_t)(dns_rbtnode_t *node,
					      dns_name_t *name,
					      void *callback_arg);

/*****
 *****	Chain Info
 *****/

/*
 * A chain is used to keep track of the sequence of nodes to reach any given
 * node from the root of the tree.  Originally nodes did not have parent
 * pointers in them (for memory usage reasons) so there was no way to find
 * the path back to the root from any given node.  Now that nodes have parent
 * pointers, chains might be going away in a future release, though the
 * movement functionality would remain.
 *
 * In any event, parent information, whether via parent pointers or chains, is
 * necessary information for iterating through the tree or for basic internal
 * tree maintenance issues (ie, the rotations that are done to rebalance the
 * tree when a node is added).  The obvious implication of this is that for a
 * chain to remain valid, the tree has to be locked down against writes for the
 * duration of the useful life of the chain, because additions or removals can
 * change the path from the root to the node the chain has targetted.
 *
 * The dns_rbtnodechain_ functions _first, _last, _prev and _next all take
 * dns_name_t parameters for the name and the origin, which can be NULL.  If
 * non-NULL, 'name' will end up pointing to the name data and offsets that are
 * stored at the node (and thus it will be read-only), so it should be a
 * regular dns_name_t that has been initialized with dns_name_init.  When
 * 'origin' is non-NULL, it will get the name of the origin stored in it, so it
 * needs to have its own buffer space and offsets, which is most easily
 * accomplished with a dns_fixedname_t.  It is _not_ necessary to reinitialize
 * either 'name' or 'origin' between calls to the chain functions.
 *
 * NOTE WELL: even though the name data at the root of the tree of trees will
 * be absolute (typically just "."), it will will be made into a relative name
 * with an origin of "." -- an empty name when the node is ".".  This is
 * because a common on operation on 'name' and 'origin' is to use
 * dns_name_concatenate() on them to generate the complete name.  An empty name
 * can be detected when dns_name_countlabels == 0, and is printed by
 * dns_name_totext()/dns_name_format() as "@@", consistent with RFC1035's
 * definition of "@@" as the current origin.
 *
 * dns_rbtnodechain_current is similar to the _first, _last, _prev and _next
 * functions but additionally can provide the node to which the chain points.  */

/*
 * The number of level blocks to allocate at a time.  Currently the maximum
 * number of levels is allocated directly in the structure, but future
 * revisions of this code might have a static initial block with dynamic
 * growth.  Allocating space for 256 levels when the tree is almost never that
 * deep is wasteful, but it's not clear that it matters, since the waste is
 * only 2MB for 1000 concurrently active chains on a system with 64-bit
 * pointers.
 */
#define DNS_RBT_LEVELBLOCK 254

typedef struct dns_rbtnodechain {
	unsigned int		magic;
	isc_mem_t *		mctx;
	/*
	 * The terminal node of the chain.  It is not in levels[].
	 * This is ostensibly private ... but in a pinch it could be
	 * used tell that the chain points nowhere without needing to
	 * call dns_rbtnodechain_current().
	 */
	dns_rbtnode_t *		end;
	/*
	 * The maximum number of labels in a name is 128; bitstrings mean
	 * a conceptually very large number (which I have not bothered to
	 * compute) of logical levels because splitting can potentially occur
	 * at each bit.  However, DNSSEC restricts the number of "logical"
	 * labels in a name to 255, meaning only 254 pointers are needed
	 * in the worst case.
	 */
	dns_rbtnode_t *		levels[DNS_RBT_LEVELBLOCK];
	/*
	 * level_count indicates how deep the chain points into the
	 * tree of trees, and is the index into the levels[] array.
	 * Thus, levels[level_count - 1] is the last level node stored.
	 * A chain that points to the top level of the tree of trees has
	 * a level_count of 0, the first level has a level_count of 1, and
	 * so on.
	 */
	unsigned int		level_count;
	/*
	 * level_matches tells how many levels matched above the node
	 * returned by dns_rbt_findnode().  A match (partial or exact) found
	 * in the first level thus results in level_matches being set to 1.
	 * This is used by the rbtdb to set the start point for a recursive
	 * search of superdomains until the RR it is looking for is found.
	 */
	unsigned int		level_matches;
} dns_rbtnodechain_t;

/*****
 ***** Public interfaces.
 *****/

isc_result_t
dns_rbt_create(isc_mem_t *mctx, void (*deleter)(void *, void *),
	       void *deleter_arg, dns_rbt_t **rbtp);
/*
 * Initialize a red-black tree of trees.
 *
 * Notes:
 *	The deleter argument, if non-null, points to a function that is
 *	responsible for cleaning up any memory associated with the data
 *	pointer of a node when the node is deleted.  It is passed the
 *	deleted node's data pointer as its first argument and deleter_arg
 *	as its second argument.
 *
 * Requires:
 * 	mctx is a pointer to a valid memory context.
 *	rbtp != NULL && *rbtp == NULL
 *	arg == NULL iff deleter == NULL
 *
 * Ensures:
 *	If result is ISC_R_SUCCESS:
 *		*rbtp points to a valid red-black tree manager
 *
 *	If result is failure:
 *		*rbtp does not point to a valid red-black tree manager.
 *
 * Returns:
 *	ISC_R_SUCCESS	Success
 *	ISC_R_NOMEMORY	Resource limit: Out of Memory
 */

isc_result_t
dns_rbt_addname(dns_rbt_t *rbt, dns_name_t *name, void *data);
/*
 * Add 'name' to the tree of trees, associated with 'data'.
 *
 * Notes:
 *	'data' is never required to be non-NULL, but specifying it
 *	when the name is added is faster than searching for 'name'
 *	again and then setting the data pointer.  The lack of a data pointer
 *	for a node also has other ramifications regarding whether
 *	dns_rbt_findname considers a node to exist, or dns_rbt_deletename
 *	joins nodes.
 *
 * Requires:
 *	rbt is a valid rbt manager.
 *	dns_name_isabsolute(name) == TRUE
 *
 * Ensures:
 *	'name' is not altered in any way.
 *
 *	Any external references to nodes in the tree are unaffected by
 *	node splits that are necessary to insert the new name.
 *
 *	If result is ISC_R_SUCCESS:
 *		'name' is findable in the red/black tree of trees in O(log N).
 *
 *		The data pointer of the node for 'name' is set to 'data'.
 *
 *	If result is ISC_R_EXISTS or ISC_R_NOSPACE:
 *		The tree of trees is unaltered.
 *
 *	If result is ISC_R_NOMEMORY:
 *		No guarantees.
 *
 * Returns:
 *	ISC_R_SUCCESS	Success
 *	ISC_R_EXISTS	The name already exists with associated data.
 *	ISC_R_NOSPACE 	The name had more logical labels than are allowed.
 *	ISC_R_NOMEMORY	Resource Limit: Out of Memory
 */

isc_result_t
dns_rbt_addnode(dns_rbt_t *rbt, dns_name_t *name, dns_rbtnode_t **nodep);

/*
 * Just like dns_rbt_addname, but returns the address of the node.
 *
 * Requires:
 *	rbt is a valid rbt structure.
 *	dns_name_isabsolute(name) == TRUE
 *	nodep != NULL && *nodep == NULL
 *
 * Ensures:
 *	'name' is not altered in any way.
 *
 *	Any external references to nodes in the tree are unaffected by
 *	node splits that are necessary to insert the new name.
 *
 *	If result is ISC_R_SUCCESS:
 *		'name' is findable in the red/black tree of trees in O(log N).
 *
 *		*nodep is the node that was added for 'name'.
 *
 *	If result is ISC_R_EXISTS:
 *		The tree of trees is unaltered.
 *
 *		*nodep is the existing node for 'name'.
 *
 *	If result is ISC_R_NOMEMORY:
 *		No guarantees.
 *
 * Returns:
 *	ISC_R_SUCCESS	Success
 *	ISC_R_EXISTS	The name already exists, possibly without data.
 *	ISC_R_NOMEMORY	Resource Limit: Out of Memory
 */

isc_result_t
dns_rbt_findname(dns_rbt_t *rbt, dns_name_t *name, unsigned int options,
		 dns_name_t *foundname, void **data);
/*
 * Get the data pointer associated with 'name'.
 *
 * Notes:
 *	When DNS_RBTFIND_NOEXACT is set, the closest matching superdomain is
 *      returned (also subject to DNS_RBTFIND_EMPTYDATA), even when there is
 *	an exact match in the tree.
 *
 *      A node that has no data is considered not to exist for this function,
 *      unless the DNS_RBTFIND_EMPTYDATA option is set.
 *
 * Requires:
 *	rbt is a valid rbt manager.
 *	dns_name_isabsolute(name) == TRUE
 *	data != NULL && *data == NULL
 *
 * Ensures:
 *	'name' and the tree are not altered in any way.
 *
 *	If result is ISC_R_SUCCESS:
 *		*data is the data associated with 'name'.
 *
 *	If result is DNS_R_PARTIALMATCH:
 *		*data is the data associated with the deepest superdomain
 * 		of 'name' which has data.
 *
 *	If result is ISC_R_NOTFOUND:
 *		Neither the name nor a superdomain was found with data.
 *
 * Returns:
 *	ISC_R_SUCCESS		Success
 *	DNS_R_PARTIALMATCH	Superdomain found with data
 *	ISC_R_NOTFOUND		No match
 *	ISC_R_NOSPACE		Concatenating nodes to form foundname failed
 */

isc_result_t
dns_rbt_findnode(dns_rbt_t *rbt, dns_name_t *name, dns_name_t *foundname,
		 dns_rbtnode_t **node, dns_rbtnodechain_t *chain,
		 unsigned int options, dns_rbtfindcallback_t callback,
		 void *callback_arg);
/*
 * Find the node for 'name'.
 *
 * Notes:
 *	A node that has no data is considered not to exist for this function,
 *	unless the DNS_RBTFIND_EMPTYDATA option is set.  This applies to both
 *	exact matches and partial matches.
 *
 *	If the chain parameter is non-NULL, then the path through the tree
 *	to the DNSSEC predecessor of the searched for name is maintained,
 *	unless the DNS_RBTFIND_NOPREDECESSOR or DNS_RBTFIND_NOEXACT option
 *	is used. (For more details on those options, see below.)
 *
 *	If there is no predecessor, then the chain will point to nowhere, as
 *	indicated by chain->end being NULL or dns_rbtnodechain_current
 *	returning ISC_R_NOTFOUND.  Note that in a normal Internet DNS RBT
 *	there will always be a predecessor for all names except the root
 *	name, because '.' will exist and '.' is the predecessor of
 *	everything.  But you can certainly construct a trivial tree and a
 *	search for it that has no predecessor.
 *
 *	Within the chain structure, the 'levels' member of the structure holds
 *	the root node of each level except the first.
 *
 *	The 'level_count' of the chain indicates how deep the chain to the
 *	predecessor name is, as an index into the 'levels[]' array.  It does
 *	not count name elements, per se, but only levels of the tree of trees,
 *	the distinction arrising because multiple labels from a name can be
 *	stored on only one level.  It is also does not include the level
 *	that has the node, since that level is not stored in levels[].
 *
 *	The chain's 'level_matches' is not directly related to the predecessor.
 *	It is the number of levels above the level of the found 'node',
 *	regardless of whether it was a partial match or exact match.  When
 *	the node is found in the top level tree, or no node is found at all,
 *	level_matches is 0.
 *
 *	When DNS_RBTFIND_NOEXACT is set, the closest matching superdomain is
 *      returned (also subject to DNS_RBTFIND_EMPTYDATA), even when
 *      there is an exact match in the tree.  In this case, the chain
 *	will not point to the DNSSEC predecessor, but will instead point
 *	to the exact match, if there was any.  Thus the preceding paragraphs
 *	should have "exact match" substituted for "predecessor" to describe
 *	how the various elements of the chain are set.  This was done to
 * 	ensure that the chain's state was sane, and to prevent problems that
 *	occurred when running the predecessor location code under conditions
 *	it was not designed for.  It is not clear *where* the chain should
 *	point when DNS_RBTFIND_NOEXACT is set, so if you end up using a chain
 *	with this option because you want a particular node, let us know
 *	where you want the chain pointed, so this can be made more firm.
 *
 * Requires:
 *	rbt is a valid rbt manager.
 *	dns_name_isabsolute(name) == TRUE.
 *	node != NULL && *node == NULL.
 *	DNS_RBTFIND_NOEXACT and DNS_RBTFIND_NOPREDECESSOR are mutally
 *		exclusive.
 *
 * Ensures:
 *	'name' and the tree are not altered in any way.
 *
 *	If result is ISC_R_SUCCESS:
 *		*node is the terminal node for 'name'.
 *
 *		'foundname' and 'name' represent the same name (though not
 *		the same memory).
 *
 *		'chain' points to the DNSSEC predecessor, if any, of 'name'.
 *
 *		chain->level_matches and chain->level_count are equal.
 *
 * 	If result is DNS_R_PARTIALMATCH:
 *		*node is the data associated with the deepest superdomain
 * 		of 'name' which has data.
 *
 *		'foundname' is the name of deepest superdomain (which has
 *		data, unless the DNS_RBTFIND_EMPTYDATA option is set).
 *
 *		'chain' points to the DNSSEC predecessor, if any, of 'name'.
 *
 *	If result is ISC_R_NOTFOUND:
 *		Neither the name nor a superdomain was found.  *node is NULL.
 *
 *		'chain' points to the DNSSEC predecessor, if any, of 'name'.
 *
 *		chain->level_matches is 0.
 *
 * Returns:
 *	ISC_R_SUCCESS		Success
 *	DNS_R_PARTIALMATCH	Superdomain found with data
 *	ISC_R_NOTFOUND		No match, or superdomain with no data
 *	ISC_R_NOSPACE Concatenating nodes to form foundname failed
 */

isc_result_t
dns_rbt_deletename(dns_rbt_t *rbt, dns_name_t *name, isc_boolean_t recurse);
/*
 * Delete 'name' from the tree of trees.
 *
 * Notes:
 *	When 'name' is removed, if recurse is ISC_TRUE then all of its
 *      subnames are removed too.
 *
 * Requires:
 *	rbt is a valid rbt manager.
 *	dns_name_isabsolute(name) == TRUE
 *
 * Ensures:
 *	'name' is not altered in any way.
 *
 *	Does NOT ensure that any external references to nodes in the tree
 *	are unaffected by node joins.
 *
 *	If result is ISC_R_SUCCESS:
 *		'name' does not appear in the tree with data; however,
 *		the node for the name might still exist which can be
 *		found with dns_rbt_findnode (but not dns_rbt_findname).
 *
 *	If result is ISC_R_NOTFOUND:
 *		'name' does not appear in the tree with data, because
 *		it did not appear in the tree before the function was called.
 *
 *	If result is something else:
 *		See result codes for dns_rbt_findnode (if it fails, the
 *		node is not deleted) or dns_rbt_deletenode (if it fails,
 *		the node is deleted, but the tree is not optimized when
 *		it could have been).
 *
 * Returns:
 *	ISC_R_SUCCESS	Success
 *	ISC_R_NOTFOUND	No match
 *	something_else	Any return code from dns_rbt_findnode except
 *			DNS_R_PARTIALMATCH (which causes ISC_R_NOTFOUND
 *			to be returned instead), and any code from
 *			dns_rbt_deletenode.
 */

isc_result_t
dns_rbt_deletenode(dns_rbt_t *rbt, dns_rbtnode_t *node, isc_boolean_t recurse);
/*
 * Delete 'node' from the tree of trees.
 *
 * Notes:
 *	When 'node' is removed, if recurse is ISC_TRUE then all nodes
 *	in levels down from it are removed too.
 *
 * Requires:
 *	rbt is a valid rbt manager.
 *	node != NULL.
 *
 * Ensures:
 *	Does NOT ensure that any external references to nodes in the tree
 *	are unaffected by node joins.
 *
 *	If result is ISC_R_SUCCESS:
 *		'node' does not appear in the tree with data; however,
 *		the node might still exist if it serves as a pointer to
 *		a lower tree level as long as 'recurse' was false, hence
 *		the node could can be found with dns_rbt_findnode whem
 *		that function's empty_data_ok parameter is true.
 *
 *	If result is ISC_R_NOMEMORY or ISC_R_NOSPACE:
 *		The node was deleted, but the tree structure was not
 *		optimized.
 *
 * Returns:
 *	ISC_R_SUCCESS	Success
 *	ISC_R_NOMEMORY	Resource Limit: Out of Memory when joining nodes.
 *	ISC_R_NOSPACE	dns_name_concatenate failed when joining nodes.
 */

void
dns_rbt_namefromnode(dns_rbtnode_t *node, dns_name_t *name);
/*
 * Convert the sequence of labels stored at 'node' into a 'name'.
 *
 * Notes:
 *	This function does not return the full name, from the root, but
 *	just the labels at the indicated node.
 *
 *	The name data pointed to by 'name' is the information stored
 *	in the node, not a copy.  Altering the data at this pointer
 *	will likely cause grief.
 *
 * Requires:
 *	name->offsets == NULL
 *
 * Ensures:
 *	'name' is DNS_NAMEATTR_READONLY.
 *
 *	'name' will point directly to the labels stored after the
 *	dns_rbtnode_t struct.
 *
 *	'name' will have offsets that also point to the information stored
 *	as part of the node.
 */

isc_result_t
dns_rbt_fullnamefromnode(dns_rbtnode_t *node, dns_name_t *name);
/*
 * Like dns_rbt_namefromnode, but returns the full name from the root.
 *
 * Notes:
 *	Unlike dns_rbt_namefromnode, the name will not point directly
 *	to node data.  Rather, dns_name_concatenate will be used to copy
 *	the name data from each node into the 'name' argument.
 *
 * Requires:
 *	name != NULL
 *	name has a dedicated buffer.
 *
 * Returns:
 *	ISC_R_SUCCESS
 *	ISC_R_NOSPACE		(possible via dns_name_concatenate)
 *	DNS_R_NAMETOOLONG	(possible via dns_name_concatenate)
 */

char *
dns_rbt_formatnodename(dns_rbtnode_t *node, char *printname,
		       unsigned int size);
/*
 * Format the full name of a node for printing, using dns_name_format().
 *
 * Notes:
 *	'size' is the length of the printname buffer.  This should be
 *	DNS_NAME_FORMATSIZE or larger.
 *
 * Requires:
 *	node and printname are not NULL.
 *
 * Returns:
 *	The 'printname' pointer.
 */

unsigned int
dns_rbt_nodecount(dns_rbt_t *rbt);
/*
 * Obtain the number of nodes in the tree of trees.
 *
 * Requires:
 *	rbt is a valid rbt manager.
 */

void
dns_rbt_destroy(dns_rbt_t **rbtp);
/*
 * Stop working with a red-black tree of trees.
 *
 * Requires:
 * 	*rbt is a valid rbt manager.
 *
 * Ensures:
 *	All space allocated by the RBT library has been returned.
 *
 *	*rbt is invalidated as an rbt manager.
 */

void
dns_rbt_printall(dns_rbt_t *rbt);
/*
 * Print an ASCII representation of the internal structure of the red-black
 * tree of trees.
 *
 * Notes:
 *	The name stored at each node, along with the node's color, is printed.
 *	Then the down pointer, left and right pointers are displayed
 *	recursively in turn.  NULL down pointers are silently omitted;
 *	NULL left and right pointers are printed.
 */

/*****
 ***** Chain Functions
 *****/

void
dns_rbtnodechain_init(dns_rbtnodechain_t *chain, isc_mem_t *mctx);
/*
 * Initialize 'chain'.
 *
 * Requires:
 *	'chain' is a valid pointer.
 *
 *	'mctx' is a valid memory context.
 *
 * Ensures:
 *	'chain' is suitable for use.
 */

void
dns_rbtnodechain_reset(dns_rbtnodechain_t *chain);
/*
 * Free any dynamic storage associated with 'chain', and then reinitialize
 * 'chain'.
 *
 * Requires:
 *	'chain' is a valid pointer.
 *
 * Ensures:
 *	'chain' is suitable for use, and uses no dynamic storage.
 */

void
dns_rbtnodechain_invalidate(dns_rbtnodechain_t *chain);
/*
 * Free any dynamic storage associated with 'chain', and then invalidates it.
 *
 * Notes:
 * 	Future calls to any dns_rbtnodechain_ function will need to call
 * 	dns_rbtnodechain_init on the chain first (except, of course,
 *	dns_rbtnodechain_init itself).
 *
 * Requires:
 *	'chain' is a valid chain.
 *
 * Ensures:
 *	'chain' is no longer suitable for use, and uses no dynamic storage.
 */

isc_result_t
dns_rbtnodechain_current(dns_rbtnodechain_t *chain, dns_name_t *name,
			 dns_name_t *origin, dns_rbtnode_t **node);
/*
 * Provide the name, origin and node to which the chain is currently pointed.
 *
 * Notes:
 *	The tree need not have be locked against additions for the chain
 *	to remain valid, however there are no guarantees if any deletion
 *	has been made since the chain was established.
 *
 * Requires:
 *	'chain' is a valid chain.
 *
 * Ensures:
 *	'node', if non-NULL, is the node to which the chain was pointed
 *	by dns_rbt_findnode, dns_rbtnodechain_first or dns_rbtnodechain_last.
 *	If none were called for the chain since it was initialized or reset,
 *	or if the was no predecessor to the name searched for with
 *	dns_rbt_findnode, then '*node' is NULL and ISC_R_NOTFOUND is returned.
 *
 *	'name', if non-NULL, is the name stored at the terminal level of
 *	the chain.  This is typically a single label, like the "www" of
 *	"www.isc.org", but need not be so.  At the root of the tree of trees,
 *	if the node is "." then 'name' is ".", otherwise it is relative to ".".
 *	(Minimalist and atypical case:  if the tree has just the name
 *	"isc.org." then the root node's stored name is "isc.org." but 'name'
 *	will be "isc.org".)
 *
 *	'origin', if non-NULL, is the sequence of labels in the levels
 *	above the terminal level, such as "isc.org." in the above example.
 *	'origin' is always "." for the root node.
 *
 *
 * Returns:
 *	ISC_R_SUCCESS		name, origin & node were successfully set.
 *	ISC_R_NOTFOUND		The chain does not point to any node.
 *	<something_else>	Any error return from dns_name_concatenate.
 */

isc_result_t
dns_rbtnodechain_first(dns_rbtnodechain_t *chain, dns_rbt_t *rbt,
		       dns_name_t *name, dns_name_t *origin);
/*
 * Set the chain to the lexically first node in the tree of trees.
 *
 * Notes:
 *	By the definition of ordering for DNS names, the root of the tree of
 *	trees is the very first node, since everything else in the megatree
 *	uses it as a common suffix.
 *
 * Requires:
 *	'chain' is a valid chain.
 *	'rbt' is a valid rbt manager.
 *
 * Ensures:
 *	The chain points to the very first node of the tree.
 *
 *	'name' and 'origin', if non-NULL, are set as described for
 *	dns_rbtnodechain_current.  Thus 'origin' will always be ".".
 *
 * Returns:
 *	DNS_R_NEWORIGIN		The name & origin were successfully set.
 *	<something_else>	Any error result from dns_rbtnodechain_current.
 */

isc_result_t
dns_rbtnodechain_last(dns_rbtnodechain_t *chain, dns_rbt_t *rbt,
		       dns_name_t *name, dns_name_t *origin);
/*
 * Set the chain to the lexically last node in the tree of trees.
 *
 * Requires:
 *	'chain' is a valid chain.
 *	'rbt' is a valid rbt manager.
 *
 * Ensures:
 *	The chain points to the very last node of the tree.
 *
 *	'name' and 'origin', if non-NULL, are set as described for
 *	dns_rbtnodechain_current.
 *
 * Returns:
 *	DNS_R_NEWORIGIN		The name & origin were successfully set.
 *	ISC_R_NOMEMORY		Resource Limit: Out of Memory building chain.
 *	<something_else>	Any error result from dns_name_concatenate.
 */

isc_result_t
dns_rbtnodechain_prev(dns_rbtnodechain_t *chain, dns_name_t *name,
		      dns_name_t *origin);
/*
 * Adjusts chain to point the DNSSEC predecessor of the name to which it
 * is currently pointed.
 *
 * Requires:
 *	'chain' is a valid chain.
 *	'chain' has been pointed somewhere in the tree with dns_rbt_findnode,
 *	dns_rbtnodechain_first or dns_rbtnodechain_last -- and remember that
 *	dns_rbt_findnode is not guaranteed to point the chain somewhere,
 *	since there may have been no predecessor to the searched for name.
 *
 * Ensures:
 *	The chain is pointed to the predecessor of its current target.
 *
 *	'name' and 'origin', if non-NULL, are set as described for
 *	dns_rbtnodechain_current.
 *
 *	'origin' is only if a new origin was found.
 *
 * Returns:
 *	ISC_R_SUCCESS		The predecessor was found and 'name' was set.
 *	DNS_R_NEWORIGIN		The predecessor was found with a different
 *				origin and 'name' and 'origin' were set.
 *	ISC_R_NOMORE		There was no predecessor.
 *	<something_else>	Any error result from dns_rbtnodechain_current.
 */

isc_result_t
dns_rbtnodechain_next(dns_rbtnodechain_t *chain, dns_name_t *name,
		      dns_name_t *origin);
/*
 * Adjusts chain to point the DNSSEC successor of the name to which it
 * is currently pointed.
 *
 * Requires:
 *	'chain' is a valid chain.
 *	'chain' has been pointed somewhere in the tree with dns_rbt_findnode,
 *	dns_rbtnodechain_first or dns_rbtnodechain_last -- and remember that
 *	dns_rbt_findnode is not guaranteed to point the chain somewhere,
 *	since there may have been no predecessor to the searched for name.
 *
 * Ensures:
 *	The chain is pointed to the successor of its current target.
 *
 *	'name' and 'origin', if non-NULL, are set as described for
 *	dns_rbtnodechain_current.
 *
 *	'origin' is only if a new origin was found.
 *
 * Returns:
 *	ISC_R_SUCCESS		The successor was found and 'name' was set.
 *	DNS_R_NEWORIGIN		The successor was found with a different
 *				origin and 'name' and 'origin' were set.
 *	ISC_R_NOMORE		There was no successor.
 *	<something_else>	Any error result from dns_name_concatenate.
 */

ISC_LANG_ENDDECLS

#endif /* DNS_RBT_H */
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1999-2002  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: rbt.h,v 1.55.12.5 2004/03/08 09:04:38 marka Exp $ */
a23 1
#include <isc/magic.h>
a45 7
#define DNS_RBTNODE_MAGIC		ISC_MAGIC('R','B','N','O')
#if DNS_RBT_USEMAGIC
#define DNS_RBTNODE_VALID(n)		ISC_MAGIC_VALID(n, DNS_RBTNODE_MAGIC)
#else
#define DNS_RBTNODE_VALID(n)		ISC_TRUE
#endif

a53 3
#if DNS_RBT_USEMAGIC
	unsigned int magic;
#endif
d140 1
a140 2
 * functions but additionally can provide the node to which the chain points.
 */
a590 2
isc_result_t
dns_rbt_destroy2(dns_rbt_t **rbtp, unsigned int quantum);
d592 1
a592 4
 * Stop working with a red-black tree of trees.  Once dns_rbt_destroy2()
 * has been called on a 'rbt' only dns_rbt_destroy() or dns_rbt_destroy2()
 * may be used on the tree.  If 'quantum' is zero then the entire tree will
 * be destroyed.
a600 4
 *
 * Returns:
 *	ISC_R_SUCCESS
 *	ISC_R_QUOTA if 'quantum' nodes have been destroyed.
@


1.1.1.3
log
@ISC BIND release 9.3.1. ok deraadt@@
@
text
@d18 1
a18 1
/* $ISC: rbt.h,v 1.55.12.6 2004/10/11 05:55:51 marka Exp $ */
d606 5
a610 8
 * Stop working with a red-black tree of trees. 
 * If 'quantum' is zero then the entire tree will be destroyed.
 * If 'quantum' is non zero then up to 'quantum' nodes will be destroyed
 * allowing the rbt to be incrementally destroyed by repeated calls to
 * dns_rbt_destroy2().  Once dns_rbt_destroy2() has been called no other
 * operations than dns_rbt_destroy()/dns_rbt_destroy2() should be
 * performed on the tree of trees.
 * 
d614 1
a614 1
 * Ensures on ISC_R_SUCCESS:
@


1.1.1.4
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: rbt.h,v 1.59.18.5 2005/10/13 01:26:07 marka Exp $ */
a22 2
/*! \file */

a24 1
#include <isc/refcount.h>
d32 1
a32 2
/*@@{*/
/*%
a39 7
/*@@}*/

#ifndef DNS_RBT_USEISCREFCOUNT
#ifdef ISC_REFCOUNT_HAVEATOMIC
#define DNS_RBT_USEISCREFCOUNT 1
#endif
#endif
d54 1
a54 1
/*%
d72 1
a72 2
	/*@@{*/
	/*!
d84 7
a90 8
	unsigned int is_root : 1;	/*%< range is 0..1 */
	unsigned int color : 1;		/*%< range is 0..1 */
	unsigned int find_callback : 1;	/*%< range is 0..1 */
	unsigned int attributes : 4;	/*%< range is 0..2 */
	unsigned int namelen : 8;	/*%< range is 1..255 */
	unsigned int offsetlen : 8;	/*%< range is 1..128 */
	unsigned int padbytes : 9;	/*%< range is 0..380 */
	/*@@}*/
d96 1
a96 2
	/*@@{*/
	/*!
a103 1
#ifndef DNS_RBT_USEISCREFCOUNT
a104 4
#else
	isc_refcount_t references; /* note that this is not in the bitfield */
#endif
	/*@@}*/
d115 1
a115 1
/*!
d154 1
a154 1
/*%
d168 1
a168 1
	/*%
d175 1
a175 1
	/*%
d184 1
a184 1
	/*%
d193 1
a193 1
	/*%
d206 1
d210 1
a210 1
/*%<
d214 1
a214 1
 *\li	The deleter argument, if non-null, points to a function that is
d221 3
a223 3
 * \li	mctx is a pointer to a valid memory context.
 *\li	rbtp != NULL && *rbtp == NULL
 *\li	arg == NULL iff deleter == NULL
d226 1
a226 1
 *\li	If result is ISC_R_SUCCESS:
d229 1
a229 1
 *\li	If result is failure:
d233 2
a234 2
 *\li	#ISC_R_SUCCESS	Success
 *\li	#ISC_R_NOMEMORY	Resource limit: Out of Memory
d239 1
a239 1
/*%<
d243 1
a243 1
 *\li	'data' is never required to be non-NULL, but specifying it
d251 2
a252 2
 *\li	rbt is a valid rbt manager.
 *\li	dns_name_isabsolute(name) == TRUE
d255 1
a255 1
 *\li	'name' is not altered in any way.
d257 1
a257 1
 *\li	Any external references to nodes in the tree are unaffected by
d260 1
a260 1
 *\li	If result is #ISC_R_SUCCESS:
d262 1
d265 1
a265 1
 *\li	If result is #ISC_R_EXISTS or #ISC_R_NOSPACE:
d268 1
a268 1
 *\li	If result is #ISC_R_NOMEMORY:
d272 4
a275 4
 *\li	#ISC_R_SUCCESS	Success
 *\li	#ISC_R_EXISTS	The name already exists with associated data.
 *\li	#ISC_R_NOSPACE 	The name had more logical labels than are allowed.
 *\li	#ISC_R_NOMEMORY	Resource Limit: Out of Memory
d281 1
a281 1
/*%<
d285 3
a287 3
 *\li	rbt is a valid rbt structure.
 *\li	dns_name_isabsolute(name) == TRUE
 *\li	nodep != NULL && *nodep == NULL
d290 1
a290 1
 *\li	'name' is not altered in any way.
d292 1
a292 1
 *\li	Any external references to nodes in the tree are unaffected by
d295 1
a295 1
 *\li	If result is ISC_R_SUCCESS:
d297 1
d300 1
a300 1
 *\li	If result is ISC_R_EXISTS:
d302 1
d305 1
a305 1
 *\li	If result is ISC_R_NOMEMORY:
d309 3
a311 3
 *\li	#ISC_R_SUCCESS	Success
 *\li	#ISC_R_EXISTS	The name already exists, possibly without data.
 *\li	#ISC_R_NOMEMORY	Resource Limit: Out of Memory
d317 1
a317 1
/*%<
d321 2
a322 2
 *\li	When #DNS_RBTFIND_NOEXACT is set, the closest matching superdomain is
 *      returned (also subject to #DNS_RBTFIND_EMPTYDATA), even when there is
d325 2
a326 2
 *\li   A node that has no data is considered not to exist for this function,
 *      unless the #DNS_RBTFIND_EMPTYDATA option is set.
d329 3
a331 3
 *\li	rbt is a valid rbt manager.
 *\li	dns_name_isabsolute(name) == TRUE
 *\li	data != NULL && *data == NULL
d334 1
a334 1
 *\li	'name' and the tree are not altered in any way.
d336 1
a336 1
 *\li	If result is ISC_R_SUCCESS:
d339 1
a339 1
 *\li	If result is DNS_R_PARTIALMATCH:
d343 1
a343 1
 *\li	If result is ISC_R_NOTFOUND:
d347 4
a350 4
 *\li	#ISC_R_SUCCESS		Success
 *\li	#DNS_R_PARTIALMATCH	Superdomain found with data
 *\li	#ISC_R_NOTFOUND		No match
 *\li	#ISC_R_NOSPACE		Concatenating nodes to form foundname failed
d358 1
a358 1
/*%<
d362 1
a362 1
 *\li	A node that has no data is considered not to exist for this function,
d366 1
a366 1
 *\li	If the chain parameter is non-NULL, then the path through the tree
d371 1
a371 1
 *\li	If there is no predecessor, then the chain will point to nowhere, as
d379 1
a379 1
 *\li	Within the chain structure, the 'levels' member of the structure holds
d382 1
a382 1
 *\li	The 'level_count' of the chain indicates how deep the chain to the
d389 1
a389 1
 *\li	The chain's 'level_matches' is not directly related to the predecessor.
d395 1
a395 1
 *\li	When DNS_RBTFIND_NOEXACT is set, the closest matching superdomain is
d410 4
a413 4
 *\li	rbt is a valid rbt manager.
 *\li	dns_name_isabsolute(name) == TRUE.
 *\li	node != NULL && *node == NULL.
 *\li	#DNS_RBTFIND_NOEXACT and DNS_RBTFIND_NOPREDECESSOR are mutally
d417 1
a417 1
 *\li	'name' and the tree are not altered in any way.
d419 1
a419 2
 *\li	If result is ISC_R_SUCCESS:
 *\verbatim
d421 1
a421 1

d424 1
a424 1

a427 1
 *\endverbatim
a429 1
 *\verbatim
a436 1
 *\endverbatim
d438 1
a438 2
 *\li	If result is ISC_R_NOTFOUND:
 *\verbatim
a443 1
 *\endverbatim
d446 4
a449 4
 *\li	#ISC_R_SUCCESS		Success
 *\li	#DNS_R_PARTIALMATCH	Superdomain found with data
 *\li	#ISC_R_NOTFOUND		No match, or superdomain with no data
 *\li	#ISC_R_NOSPACE Concatenating nodes to form foundname failed
d454 1
a454 1
/*%<
d458 1
a458 1
 *\li	When 'name' is removed, if recurse is ISC_TRUE then all of its
d462 2
a463 2
 *\li	rbt is a valid rbt manager.
 *\li	dns_name_isabsolute(name) == TRUE
d466 1
a466 1
 *\li	'name' is not altered in any way.
d468 1
a468 1
 *\li	Does NOT ensure that any external references to nodes in the tree
d471 1
a471 1
 *\li	If result is ISC_R_SUCCESS:
d476 1
a476 1
 *\li	If result is ISC_R_NOTFOUND:
d480 1
a480 1
 *\li	If result is something else:
d487 3
a489 3
 *\li	#ISC_R_SUCCESS	Success
 *\li	#ISC_R_NOTFOUND	No match
 *\li	something_else	Any return code from dns_rbt_findnode except
d497 1
a497 1
/*%<
d501 1
a501 1
 *\li	When 'node' is removed, if recurse is ISC_TRUE then all nodes
d505 2
a506 2
 *\li	rbt is a valid rbt manager.
 *\li	node != NULL.
d509 1
a509 1
 *\li	Does NOT ensure that any external references to nodes in the tree
d512 1
a512 1
 *\li	If result is ISC_R_SUCCESS:
d519 1
a519 1
 *\li	If result is ISC_R_NOMEMORY or ISC_R_NOSPACE:
d524 3
a526 3
 *\li	#ISC_R_SUCCESS	Success
 *\li	#ISC_R_NOMEMORY	Resource Limit: Out of Memory when joining nodes.
 *\li	#ISC_R_NOSPACE	dns_name_concatenate failed when joining nodes.
d531 1
a531 1
/*%<
d535 1
a535 1
 *\li	This function does not return the full name, from the root, but
d538 1
a538 1
 *\li	The name data pointed to by 'name' is the information stored
d543 1
a543 1
 * \li	name->offsets == NULL
d546 1
a546 1
 * \li	'name' is DNS_NAMEATTR_READONLY.
d548 1
a548 1
 * \li	'name' will point directly to the labels stored after the
d551 1
a551 1
 * \li	'name' will have offsets that also point to the information stored
d557 1
a557 1
/*%<
d561 1
a561 1
 * \li	Unlike dns_rbt_namefromnode, the name will not point directly
d566 2
a567 2
 * \li	name != NULL
 * \li	name has a dedicated buffer.
d570 3
a572 3
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_NOSPACE		(possible via dns_name_concatenate)
 * \li	DNS_R_NAMETOOLONG	(possible via dns_name_concatenate)
d578 1
a578 1
/*%<
d582 1
a582 1
 * \li	'size' is the length of the printname buffer.  This should be
d586 1
a586 1
 * \li	node and printname are not NULL.
d589 1
a589 1
 * \li	The 'printname' pointer.
d594 1
a594 1
/*%<
d598 1
a598 1
 * \li	rbt is a valid rbt manager.
d605 1
a605 1
/*%<
d615 1
a615 1
 * \li	*rbt is a valid rbt manager.
d618 1
a618 1
 * \li	All space allocated by the RBT library has been returned.
d620 1
a620 1
 * \li	*rbt is invalidated as an rbt manager.
d623 2
a624 2
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_QUOTA if 'quantum' nodes have been destroyed.
d629 1
a629 1
/*%<
d634 1
a634 1
 * \li	The name stored at each node, along with the node's color, is printed.
d646 1
a646 1
/*%<
d650 1
a650 1
 *\li	'chain' is a valid pointer.
d652 1
a652 1
 *\li	'mctx' is a valid memory context.
d655 1
a655 1
 *\li	'chain' is suitable for use.
d660 1
a660 1
/*%<
d665 1
a665 1
 *\li	'chain' is a valid pointer.
d668 1
a668 1
 *\li	'chain' is suitable for use, and uses no dynamic storage.
d673 1
a673 1
/*%<
d677 1
a677 1
 *\li 	Future calls to any dns_rbtnodechain_ function will need to call
d682 1
a682 1
 *\li	'chain' is a valid chain.
d685 1
a685 1
 *\li	'chain' is no longer suitable for use, and uses no dynamic storage.
d691 1
a691 1
/*%<
d695 1
a695 1
 *\li	The tree need not have be locked against additions for the chain
d700 1
a700 1
 *\li	'chain' is a valid chain.
d703 1
a703 1
 *\li	'node', if non-NULL, is the node to which the chain was pointed
d709 1
a709 1
 *\li	'name', if non-NULL, is the name stored at the terminal level of
d717 1
a717 1
 *\li	'origin', if non-NULL, is the sequence of labels in the levels
d723 3
a725 3
 *\li	#ISC_R_SUCCESS		name, origin & node were successfully set.
 *\li	#ISC_R_NOTFOUND		The chain does not point to any node.
 *\li	&lt;something_else>	Any error return from dns_name_concatenate.
d731 1
a731 1
/*%<
d735 1
a735 1
 *\li	By the definition of ordering for DNS names, the root of the tree of
d740 2
a741 2
 *\li	'chain' is a valid chain.
 *\li	'rbt' is a valid rbt manager.
d744 1
a744 1
 *\li	The chain points to the very first node of the tree.
d746 1
a746 1
 *\li	'name' and 'origin', if non-NULL, are set as described for
d750 2
a751 2
 *\li	#DNS_R_NEWORIGIN		The name & origin were successfully set.
 *\li	&lt;something_else>	Any error result from dns_rbtnodechain_current.
d757 1
a757 1
/*%<
d761 2
a762 2
 *\li	'chain' is a valid chain.
 *\li	'rbt' is a valid rbt manager.
d765 1
a765 1
 *\li	The chain points to the very last node of the tree.
d767 1
a767 1
 *\li	'name' and 'origin', if non-NULL, are set as described for
d771 3
a773 3
 *\li	#DNS_R_NEWORIGIN		The name & origin were successfully set.
 *\li	#ISC_R_NOMEMORY		Resource Limit: Out of Memory building chain.
 *\li	&lt;something_else>	Any error result from dns_name_concatenate.
d779 1
a779 1
/*%<
d784 2
a785 2
 *\li	'chain' is a valid chain.
 *\li	'chain' has been pointed somewhere in the tree with dns_rbt_findnode,
d791 1
a791 1
 *\li	The chain is pointed to the predecessor of its current target.
d793 1
a793 1
 *\li	'name' and 'origin', if non-NULL, are set as described for
d796 1
a796 1
 *\li	'origin' is only if a new origin was found.
d799 2
a800 2
 *\li	#ISC_R_SUCCESS		The predecessor was found and 'name' was set.
 *\li	#DNS_R_NEWORIGIN		The predecessor was found with a different
d802 2
a803 2
 *\li	#ISC_R_NOMORE		There was no predecessor.
 *\li	&lt;something_else>	Any error result from dns_rbtnodechain_current.
d809 1
a809 1
/*%<
d814 2
a815 2
 *\li	'chain' is a valid chain.
 *\li	'chain' has been pointed somewhere in the tree with dns_rbt_findnode,
d821 1
a821 1
 *\li	The chain is pointed to the successor of its current target.
d823 1
a823 1
 *\li	'name' and 'origin', if non-NULL, are set as described for
d826 1
a826 1
 *\li	'origin' is only if a new origin was found.
d829 2
a830 2
 *\li	#ISC_R_SUCCESS		The successor was found and 'name' was set.
 *\li	#DNS_R_NEWORIGIN		The successor was found with a different
d832 2
a833 2
 *\li	#ISC_R_NOMORE		There was no successor.
 *\li	&lt;something_else>	Any error result from dns_name_concatenate.
a834 57

/*
 * Wrapper macros for manipulating the rbtnode reference counter:
 *   Since we selectively use isc_refcount_t for the reference counter of
 *   a rbtnode, operations on the counter depend on the actual type of it.
 *   The following macros provide a common interface to these operations,
 *   hiding the back-end.  The usage is the same as that of isc_refcount_xxx().
 */
#ifdef DNS_RBT_USEISCREFCOUNT
#define dns_rbtnode_refinit(node, n)				\
	do {							\
 		isc_refcount_init(&(node)->references, (n));	\
	} while (0) 
#define dns_rbtnode_refdestroy(node)				\
	do {							\
		isc_refcount_destroy(&(node)->references);	\
	} while (0) 
#define dns_rbtnode_refcurrent(node)				\
	isc_refcount_current(&(node)->references)
#define dns_rbtnode_refincrement0(node, refs)			\
	do {							\
		isc_refcount_increment0(&(node)->references, (refs)); \
	} while (0) 
#define dns_rbtnode_refincrement(node, refs)			\
	do {							\
		isc_refcount_increment(&(node)->references, (refs)); \
	} while (0) 
#define dns_rbtnode_refdecrement(node, refs)			\
	do {							\
		isc_refcount_decrement(&(node)->references, (refs)); \
	} while (0) 
#else  /* DNS_RBT_USEISCREFCOUNT */
#define dns_rbtnode_refinit(node, n)	((node)->references = (n))
#define dns_rbtnode_refdestroy(node)	(REQUIRE((node)->references == 0))
#define dns_rbtnode_refcurrent(node)	((node)->references)
#define dns_rbtnode_refincrement0(node, refs)			\
	do {							\
		unsigned int *_tmp = (unsigned int *)(refs);	\
		(node)->references++;				\
		if ((_tmp) != NULL)				\
			(*_tmp) = (node)->references;		\
	} while (0) 
#define dns_rbtnode_refincrement(node, refs)			\
	do {							\
		REQUIRE((node)->references > 0);		\
		(node)->references++;				\
		if ((refs) != NULL)				\
			(*refs) = (node)->references;		\
	} while (0) 
#define dns_rbtnode_refdecrement(node, refs)			\
	do {							\
		REQUIRE((node)->references > 0);		\
		(node)->references--;				\
		if ((refs) != NULL)				\
			(*refs) = (node)->references;		\
	} while (0) 
#endif /* DNS_RBT_USEISCREFCOUNT */
@


