head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.4.0.38
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.36
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.32
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.34
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.26
	OPENBSD_5_7_BASE:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.30
	OPENBSD_5_6_BASE:1.1.1.4
	OPENBSD_5_5:1.1.1.4.0.28
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.24
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.22
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.20
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.18
	OPENBSD_5_0:1.1.1.4.0.16
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.14
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.12
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.8
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.10
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.6
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.4
	OPENBSD_4_4_BASE:1.1.1.4
	BIND_9_4_2_P1:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	OPENBSD_4_3_BASE:1.1.1.4
	BIND_9_4_2:1.1.1.4
	OPENBSD_4_2:1.1.1.3.0.4
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.2
	OPENBSD_4_1_BASE:1.1.1.3
	BIND_9_3_4:1.1.1.3
	BIND_9_3_3:1.1.1.3
	OPENBSD_4_0:1.1.1.2.0.8
	OPENBSD_4_0_BASE:1.1.1.2
	BIND_9_3_2:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.6
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.4
	OPENBSD_3_8_BASE:1.1.1.2
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.2
	OPENBSD_3_7_BASE:1.1.1.2
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.01.20.21.07.18;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.18;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.11;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.01.10.18.19.51;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.12.09.12.34.45;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (C) 2000, 2001  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: keytable.h,v 1.10 2001/01/09 21:52:55 bwelling Exp $ */

#ifndef DNS_KEYTABLE_H
#define DNS_KEYTABLE_H 1

/*****
 ***** Module Info
 *****/

/*
 * Key Tables
 *
 * The keytable module provides services for storing and retrieving DNSSEC
 * trusted keys, as well as the ability to find the deepest matching key
 * for a given domain name.
 *
 * MP:
 *	The module ensures appropriate synchronization of data structures it
 *	creates and manipulates.
 *
 * Resources:
 *	<TBS>
 *
 * Security:
 *	No anticipated impact.
 */

#include <isc/lang.h>

#include <dns/types.h>

#include <dst/dst.h>

ISC_LANG_BEGINDECLS

isc_result_t
dns_keytable_create(isc_mem_t *mctx, dns_keytable_t **keytablep);
/*
 * Create a keytable.
 *
 * Requires:
 *
 *	'mctx' is a valid memory context.
 *
 *	keytablep != NULL && *keytablep == NULL
 *
 * Ensures:
 *
 *	On success, *keytablep is a valid, empty key table.
 *
 * Returns:
 *
 *	ISC_R_SUCCESS
 *
 *	Any other result indicates failure.
 */


void
dns_keytable_attach(dns_keytable_t *source, dns_keytable_t **targetp);
/*
 * Attach *targetp to source.
 *
 * Requires:
 *
 *	'source' is a valid keytable.
 *
 *	'targetp' points to a NULL dns_keytable_t *.
 *
 * Ensures:
 *
 *	*targetp is attached to source.
 */

void
dns_keytable_detach(dns_keytable_t **keytablep);
/*
 * Detach *keytablep from its keytable.
 *
 * Requires:
 *
 *	'keytablep' points to a valid keytable.
 *
 * Ensures:
 *
 *	*keytablep is NULL.
 *
 *	If '*keytablep' is the last reference to the keytable,
 *
 *		All resources used by the keytable will be freed
 */

isc_result_t
dns_keytable_add(dns_keytable_t *keytable, dst_key_t **keyp);
/*
 * Add '*keyp' to 'keytable'.
 *
 * Notes:
 *
 *	Ownership of *keyp is transferred to the keytable.
 *
 * Requires:
 *
 *	keyp != NULL && *keyp is a valid dst_key_t *.
 *
 * Ensures:
 *
 *	On success, *keyp == NULL
 *
 * Returns:
 *
 *	ISC_R_SUCCESS
 *
 *	Any other result indicates failure.
 */

isc_result_t
dns_keytable_findkeynode(dns_keytable_t *keytable, dns_name_t *name,
			 dns_secalg_t algorithm, dns_keytag_t tag,
			 dns_keynode_t **keynodep);
/*
 * Search for a key named 'name', matching 'algorithm' and 'tag' in
 * 'keytable'.
 *
 * Requires:
 *
 *	'keytable' is a valid keytable.
 *
 *	'name' is a valid absolute name.
 *
 *	keynodep != NULL && *keynodep == NULL
 *
 * Returns:
 *
 *	ISC_R_SUCCESS
 *	ISC_R_NOTFOUND
 *
 *	Any other result indicates an error.
 */

isc_result_t
dns_keytable_findnextkeynode(dns_keytable_t *keytable, dns_keynode_t *keynode,
		                             dns_keynode_t **nextnodep);
/*
 * Search for the next key with the same properties as 'keynode' in
 * 'keytable'.
 *
 * Requires:
 *
 *	'keytable' is a valid keytable.
 *
 *	'keynode' is a valid keynode.
 *
 *	nextnodep != NULL && *nextnodep == NULL
 *
 * Returns:
 *
 *	ISC_R_SUCCESS
 *	ISC_R_NOTFOUND
 *
 *	Any other result indicates an error.
 */

isc_result_t
dns_keytable_finddeepestmatch(dns_keytable_t *keytable, dns_name_t *name,
			      dns_name_t *foundname);
/*
 * Search for the deepest match of 'name' in 'keytable'.
 *
 * Requires:
 *
 *	'keytable' is a valid keytable.
 *
 *	'name' is a valid absolute name.
 *
 *	'foundname' is a name with a dedicated buffer.
 *
 * Returns:
 *
 *	ISC_R_SUCCESS
 *	ISC_R_NOTFOUND
 *
 *	Any other result indicates an error.
 */

void
dns_keytable_detachkeynode(dns_keytable_t *keytable,
			   dns_keynode_t **keynodep);
/*
 * Give back a keynode found via dns_keytable_findkeynode().
 *
 * Requires:
 *
 *	'keytable' is a valid keytable.
 *
 *	*keynodep is a valid keynode returned by a call to
 *	dns_keytable_findkeynode().
 *
 * Ensures:
 *
 *	*keynodep == NULL
 */

isc_result_t
dns_keytable_issecuredomain(dns_keytable_t *keytable, dns_name_t *name,
			    isc_boolean_t *wantdnssecp);
/*
 * Is 'name' at or beneath a trusted key?
 *
 * Requires:
 *
 *	'keytable' is a valid keytable.
 *
 *	'name' is a valid absolute name.
 *
 *	'*wantsdnssecp' is a valid isc_boolean_t.
 *
 * Ensures:
 *
 *	On success, *wantsdnssecp will be ISC_TRUE if and only if 'name'
 *	is at or beneath a trusted key.
 *
 * Returns:
 *
 *	ISC_R_SUCCESS
 *
 *	Any other result is an error.
 */

dst_key_t *
dns_keynode_key(dns_keynode_t *keynode);
/*
 * Get the DST key associated with keynode.
 */

ISC_LANG_ENDDECLS

#endif /* DNS_KEYTABLE_H */
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@a1 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: keytable.h,v 1.10.206.1 2004/03/06 08:13:56 marka Exp $ */
@


1.1.1.3
log
@ISC BIND release 9.3.3
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: keytable.h,v 1.10.206.3 2006/01/06 00:01:42 marka Exp $ */
d140 1
a140 2
 * 'keytable'.  This finds the first instance which matches.  Use
 * dns_keytable_findnextkeynode() to find other instances.
a152 1
 *	DNS_R_PARTIALMATCH	the name existed in the keytable.
d163 1
a163 1
 * 'keytable' as found by dns_keytable_findkeynode().
@


1.1.1.4
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: keytable.h,v 1.11.18.3 2005/12/05 00:00:03 marka Exp $ */
d27 3
a29 2
/*! \file
 * \brief
d35 1
a35 1
 *\li	The module ensures appropriate synchronization of data structures it
d39 1
a39 1
 *\li	TBS
d42 1
a42 1
 *\li	No anticipated impact.
d55 1
a55 1
/*%<
d60 1
a60 1
 *\li	'mctx' is a valid memory context.
d62 1
a62 1
 *\li	keytablep != NULL && *keytablep == NULL
d66 1
a66 1
 *\li	On success, *keytablep is a valid, empty key table.
d70 1
a70 1
 *\li	ISC_R_SUCCESS
d72 1
a72 1
 *\li	Any other result indicates failure.
d78 1
a78 1
/*%<
d83 1
a83 1
 *\li	'source' is a valid keytable.
d85 1
a85 1
 *\li	'targetp' points to a NULL dns_keytable_t *.
d89 1
a89 1
 *\li	*targetp is attached to source.
d94 1
a94 1
/*%<
d99 1
a99 1
 *\li	'keytablep' points to a valid keytable.
d103 3
a105 1
 *\li	*keytablep is NULL.
d107 1
a107 2
 *\li	If '*keytablep' is the last reference to the keytable,
 *		all resources used by the keytable will be freed
d112 1
a112 1
/*%<
d117 1
a117 1
 *\li	Ownership of *keyp is transferred to the keytable.
d121 1
a121 1
 *\li	keyp != NULL && *keyp is a valid dst_key_t *.
d125 1
a125 1
 *\li	On success, *keyp == NULL
d129 1
a129 1
 *\li	ISC_R_SUCCESS
d131 1
a131 1
 *\li	Any other result indicates failure.
d138 1
a138 1
/*%<
d145 1
a145 1
 *\li	'keytable' is a valid keytable.
d147 1
a147 1
 *\li	'name' is a valid absolute name.
d149 1
a149 1
 *\li	keynodep != NULL && *keynodep == NULL
d153 3
a155 3
 *\li	ISC_R_SUCCESS
 *\li	DNS_R_PARTIALMATCH	the name existed in the keytable.
 *\li	ISC_R_NOTFOUND
d157 1
a157 1
 *\li	Any other result indicates an error.
d163 1
a163 1
/*%<
d169 1
a169 1
 *\li	'keytable' is a valid keytable.
d171 1
a171 1
 *\li	'keynode' is a valid keynode.
d173 1
a173 1
 *\li	nextnodep != NULL && *nextnodep == NULL
d177 2
a178 2
 *\li	ISC_R_SUCCESS
 *\li	ISC_R_NOTFOUND
d180 1
a180 1
 *\li	Any other result indicates an error.
d186 1
a186 1
/*%<
d191 1
a191 1
 *\li	'keytable' is a valid keytable.
d193 1
a193 1
 *\li	'name' is a valid absolute name.
d195 1
a195 1
 *\li	'foundname' is a name with a dedicated buffer.
d199 2
a200 2
 *\li	ISC_R_SUCCESS
 *\li	ISC_R_NOTFOUND
d202 1
a202 1
 *\li	Any other result indicates an error.
d208 1
a208 1
/*%<
d213 1
a213 1
 *\li	'keytable' is a valid keytable.
d215 1
a215 1
 *\li	*keynodep is a valid keynode returned by a call to
d220 1
a220 1
 *\li	*keynodep == NULL
d226 1
a226 1
/*%<
d231 1
a231 1
 *\li	'keytable' is a valid keytable.
d233 1
a233 1
 *\li	'name' is a valid absolute name.
d235 1
a235 1
 *\li	'*wantsdnssecp' is a valid isc_boolean_t.
d239 1
a239 1
 *\li	On success, *wantsdnssecp will be ISC_TRUE if and only if 'name'
d244 1
a244 1
 *\li	ISC_R_SUCCESS
d246 1
a246 1
 *\li	Any other result is an error.
d251 1
a251 1
/*%<
@


