head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.42
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.40
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.36
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.32
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.34
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.26
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.30
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.28
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.24
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.22
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.20
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.18
	OPENBSD_5_0:1.4.0.16
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.14
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.12
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.8
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.10
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	BIND_9_4_2_P1:1.1.1.3
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	BIND_9_4_2:1.1.1.3
	OPENBSD_4_2:1.3.0.12
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.10
	OPENBSD_4_1_BASE:1.3
	BIND_9_3_4:1.1.1.2
	BIND_9_3_3:1.1.1.2
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	BIND_9_3_2:1.1.1.2
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2007.12.09.13.39.44;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.28.17.14.06;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.18.14.14.06;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.07.16;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.16;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.09;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.09.12.34.48;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.4
log
@resolve conflicts
@
text
@/*
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1999-2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: adb.h,v 1.76.18.3 2005/06/23 04:23:16 marka Exp $ */

#ifndef DNS_ADB_H
#define DNS_ADB_H 1

/*****
 ***** Module Info
 *****/

/*! \file
 *\brief
 * DNS Address Database
 *
 * This module implements an address database (ADB) for mapping a name
 * to an isc_sockaddr_t. It also provides statistical information on
 * how good that address might be.
 *
 * A client will pass in a dns_name_t, and the ADB will walk through
 * the rdataset looking up addresses associated with the name.  If it
 * is found on the internal lists, a structure is filled in with the
 * address information and stats for found addresses.
 *
 * If the name cannot be found on the internal lists, a new entry will
 * be created for a name if all the information needed can be found
 * in the zone table or cache.  This new address will then be returned.
 *
 * If a request must be made to remote servers to satisfy a name lookup,
 * this module will start fetches to try to complete these addresses.  When
 * at least one more completes, an event is sent to the caller.  If none of
 * them resolve before the fetch times out, an event indicating this is
 * sent instead.
 *
 * Records are stored internally until a timer expires. The timer is the
 * smaller of the TTL or signature validity period.
 *
 * Lameness is stored per <qname,qtype> tuple, and this data hangs off each
 * address field.  When an address is marked lame for a given tuple the address
 * will not be returned to a caller.
 *
 *
 * MP:
 *
 *\li	The ADB takes care of all necessary locking.
 *
 *\li	Only the task which initiated the name lookup can cancel the lookup.
 *
 *
 * Security:
 *
 *\li	None, since all data stored is required to be pre-filtered.
 *	(Cache needs to be sane, fetches return bounds-checked and sanity-
 *       checked data, caller passes a good dns_name_t for the zone, etc)
 */

/***
 *** Imports
 ***/

#include <isc/lang.h>
#include <isc/magic.h>
#include <isc/mem.h>
#include <isc/sockaddr.h>

#include <dns/types.h>
#include <dns/view.h>

ISC_LANG_BEGINDECLS

/***
 *** Magic number checks
 ***/

#define DNS_ADBFIND_MAGIC	  ISC_MAGIC('a','d','b','H')
#define DNS_ADBFIND_VALID(x)	  ISC_MAGIC_VALID(x, DNS_ADBFIND_MAGIC)
#define DNS_ADBADDRINFO_MAGIC	  ISC_MAGIC('a','d','A','I')
#define DNS_ADBADDRINFO_VALID(x)  ISC_MAGIC_VALID(x, DNS_ADBADDRINFO_MAGIC)


/***
 *** TYPES
 ***/

typedef struct dns_adbname		dns_adbname_t;

/*! 
 *\brief
 * Represents a lookup for a single name.
 *
 * On return, the client can safely use "list", and can reorder the list.
 * Items may not be _deleted_ from this list, however, or added to it
 * other than by using the dns_adb_*() API.
 */
struct dns_adbfind {
	/* Public */
	unsigned int			magic;		/*%< RO: magic */
	dns_adbaddrinfolist_t		list;		/*%< RO: list of addrs */
	unsigned int			query_pending;	/*%< RO: partial list */
	unsigned int			partial_result;	/*%< RO: addrs missing */
	unsigned int			options;	/*%< RO: options */
	isc_result_t			result_v4;	/*%< RO: v4 result */
	isc_result_t			result_v6;	/*%< RO: v6 result */
	ISC_LINK(dns_adbfind_t)		publink;	/*%< RW: client use */

	/* Private */
	isc_mutex_t			lock;		/* locks all below */
	in_port_t			port;
	int				name_bucket;
	unsigned int			flags;
	dns_adbname_t		       *adbname;
	dns_adb_t		       *adb;
	isc_event_t			event;
	ISC_LINK(dns_adbfind_t)		plink;
};

/*
 * _INET:
 * _INET6:
 *	return addresses of that type.
 *
 * _EMPTYEVENT:
 *	Only schedule an event if no addresses are known.
 *	Must set _WANTEVENT for this to be meaningful.
 *
 * _WANTEVENT:
 *	An event is desired.  Check this bit in the returned find to see
 *	if one will actually be generated.
 *
 * _AVOIDFETCHES:
 *	If set, fetches will not be generated unless no addresses are
 *	available in any of the address families requested.
 *
 * _STARTATZONE:
 *	Fetches will start using the closest zone data or use the root servers.
 *	This is useful for reestablishing glue that has expired.
 *
 * _GLUEOK:
 * _HINTOK:
 *	Glue or hints are ok.  These are used when matching names already
 *	in the adb, and when dns databases are searched.
 *
 * _RETURNLAME:
 *	Return lame servers in a find, so that all addresses are returned.
 *
 * _LAMEPRUNED:
 *	At least one address was omitted from the list because it was lame.
 *	This bit will NEVER be set if _RETURNLAME is set in the createfind().
 */
/*% Return addresses of type INET. */
#define DNS_ADBFIND_INET		0x00000001
/*% Return addresses of type INET6. */
#define DNS_ADBFIND_INET6		0x00000002
#define DNS_ADBFIND_ADDRESSMASK		0x00000003
/*%
 *      Only schedule an event if no addresses are known.
 *      Must set _WANTEVENT for this to be meaningful.
 */
#define DNS_ADBFIND_EMPTYEVENT		0x00000004
/*%
 *	An event is desired.  Check this bit in the returned find to see
 *	if one will actually be generated.
 */
#define DNS_ADBFIND_WANTEVENT		0x00000008
/*%
 *	If set, fetches will not be generated unless no addresses are
 *	available in any of the address families requested.
 */
#define DNS_ADBFIND_AVOIDFETCHES	0x00000010
/*%
 *	Fetches will start using the closest zone data or use the root servers.
 *	This is useful for reestablishing glue that has expired.
 */
#define DNS_ADBFIND_STARTATZONE		0x00000020
/*%
 *	Glue or hints are ok.  These are used when matching names already
 *	in the adb, and when dns databases are searched.
 */
#define DNS_ADBFIND_GLUEOK		0x00000040
/*%
 *	Glue or hints are ok.  These are used when matching names already
 *	in the adb, and when dns databases are searched.
 */
#define DNS_ADBFIND_HINTOK		0x00000080
/*%
 *	Return lame servers in a find, so that all addresses are returned.
 */
#define DNS_ADBFIND_RETURNLAME		0x00000100
/*%
 *      Only schedule an event if no addresses are known.
 *      Must set _WANTEVENT for this to be meaningful.
 */
#define DNS_ADBFIND_LAMEPRUNED		0x00000200

/*%
 * The answers to queries come back as a list of these.
 */
struct dns_adbaddrinfo {
	unsigned int			magic;		/*%< private */

	isc_sockaddr_t			sockaddr;	/*%< [rw] */
	unsigned int			srtt;		/*%< [rw] microseconds */
	unsigned int			flags;		/*%< [rw] */
	dns_adbentry_t		       *entry;		/*%< private */
	ISC_LINK(dns_adbaddrinfo_t)	publink;
};

/*!< 
 * The event sent to the caller task is just a plain old isc_event_t.  It
 * contains no data other than a simple status, passed in the "type" field
 * to indicate that another address resolved, or all partially resolved
 * addresses have failed to resolve.
 *
 * "sender" is the dns_adbfind_t used to issue this query.
 *
 * This is simply a standard event, with the "type" set to:
 *
 *\li	#DNS_EVENT_ADBMOREADDRESSES   -- another address resolved.
 *\li	#DNS_EVENT_ADBNOMOREADDRESSES -- all pending addresses failed,
 *					were canceled, or otherwise will
 *					not be usable.
 *\li	#DNS_EVENT_ADBCANCELED	     -- The request was canceled by a
 *					3rd party.
 *\li	#DNS_EVENT_ADBNAMEDELETED     -- The name was deleted, so this request
 *					was canceled.
 *
 * In each of these cases, the addresses returned by the initial call
 * to dns_adb_createfind() can still be used until they are no longer needed.
 */

/****
 **** FUNCTIONS
 ****/


isc_result_t
dns_adb_create(isc_mem_t *mem, dns_view_t *view, isc_timermgr_t *tmgr,
	       isc_taskmgr_t *taskmgr, dns_adb_t **newadb);
/*%<
 * Create a new ADB.
 *
 * Notes:
 *
 *\li	Generally, applications should not create an ADB directly, but
 *	should instead call dns_view_createresolver().
 *
 * Requires:
 *
 *\li	'mem' must be a valid memory context.
 *
 *\li	'view' be a pointer to a valid view.
 *
 *\li	'tmgr' be a pointer to a valid timer manager.
 *
 *\li	'taskmgr' be a pointer to a valid task manager.
 *
 *\li	'newadb' != NULL && '*newadb' == NULL.
 *
 * Returns:
 *
 *\li	#ISC_R_SUCCESS	after happiness.
 *\li	#ISC_R_NOMEMORY	after resource allocation failure.
 */

void
dns_adb_attach(dns_adb_t *adb, dns_adb_t **adbp);
/*%
 * Attach to an 'adb' to 'adbp'.
 *
 * Requires:
 *\li	'adb' to be a valid dns_adb_t, created via dns_adb_create().
 *\li	'adbp' to be a valid pointer to a *dns_adb_t which is initialized
 *	to NULL.
 */

void
dns_adb_detach(dns_adb_t **adb);
/*%
 * Delete the ADB. Sets *ADB to NULL. Cancels any outstanding requests.
 *
 * Requires:
 *
 *\li	'adb' be non-NULL and '*adb' be a valid dns_adb_t, created via
 *	dns_adb_create().
 */

void
dns_adb_whenshutdown(dns_adb_t *adb, isc_task_t *task, isc_event_t **eventp);
/*%
 * Send '*eventp' to 'task' when 'adb' has shutdown.
 *
 * Requires:
 *
 *\li	'*adb' is a valid dns_adb_t.
 *
 *\li	eventp != NULL && *eventp is a valid event.
 *
 * Ensures:
 *
 *\li	*eventp == NULL
 *
 *\li	The event's sender field is set to the value of adb when the event
 *	is sent.
 */

void
dns_adb_shutdown(dns_adb_t *adb);
/*%<
 * Shutdown 'adb'.
 *
 * Requires:
 *
 * \li	'*adb' is a valid dns_adb_t.
 */

isc_result_t
dns_adb_createfind(dns_adb_t *adb, isc_task_t *task, isc_taskaction_t action,
		   void *arg, dns_name_t *name, dns_name_t *qname,
		   dns_rdatatype_t qtype, unsigned int options,
		   isc_stdtime_t now, dns_name_t *target,
		   in_port_t port, dns_adbfind_t **find);
/*%<
 * Main interface for clients. The adb will look up the name given in
 * "name" and will build up a list of found addresses, and perhaps start
 * internal fetches to resolve names that are unknown currently.
 *
 * If other addresses resolve after this call completes, an event will
 * be sent to the <task, taskaction, arg> with the sender of that event
 * set to a pointer to the dns_adbfind_t returned by this function.
 *
 * If no events will be generated, the *find->result_v4 and/or result_v6
 * members may be examined for address lookup status.  The usual #ISC_R_SUCCESS,
 * #ISC_R_FAILURE, and #DNS_R_NX{DOMAIN,RRSET} are returned, along with
 * #ISC_R_NOTFOUND meaning the ADB has not _yet_ found the values.  In this
 * latter case, retrying may produce more addresses.
 *
 * If events will be returned, the result_v[46] members are only valid
 * when that event is actually returned.
 *
 * The list of addresses returned is unordered.  The caller must impose
 * any ordering required.  The list will not contain "known bad" addresses,
 * however.  For instance, it will not return hosts that are known to be
 * lame for the zone in question.
 *
 * The caller cannot (directly) modify the contents of the address list's
 * fields other than the "link" field.  All values can be read at any
 * time, however.
 *
 * The "now" parameter is used only for determining which entries that
 * have a specific time to live or expire time should be removed from
 * the running database.  If specified as zero, the current time will
 * be retrieved and used.
 *
 * If 'target' is not NULL and 'name' is an alias (i.e. the name is
 * CNAME'd or DNAME'd to another name), then 'target' will be updated with
 * the domain name that 'name' is aliased to.
 *
 * All addresses returned will have the sockaddr's port set to 'port.'
 * The caller may change them directly in the dns_adbaddrinfo_t since
 * they are copies of the internal address only.
 *
 * XXXMLG  Document options, especially the flags which control how
 *         events are sent.
 *
 * Requires:
 *
 *\li	*adb be a valid isc_adb_t object.
 *
 *\li	If events are to be sent, *task be a valid task,
 *	and isc_taskaction_t != NULL.
 *
 *\li	*name is a valid dns_name_t.
 *
 *\li	qname != NULL and *qname be a valid dns_name_t.
 *
 *\li	target == NULL or target is a valid name with a buffer.
 *
 *\li	find != NULL && *find == NULL.
 *
 * Returns:
 *
 *\li	#ISC_R_SUCCESS	Addresses might have been returned, and events will be
 *			delivered for unresolved addresses.
 *\li	#ISC_R_NOMORE	Addresses might have been returned, but no events
 *			will ever be posted for this context.  This is only
 *			returned if task != NULL.
 *\li	#ISC_R_NOMEMORY	insufficient resources
 *\li	#DNS_R_ALIAS	'name' is an alias for another name.
 *
 * Calls, and returns error codes from:
 *
 *\li	isc_stdtime_get()
 *
 * Notes:
 *
 *\li	No internal reference to "name" exists after this function
 *	returns.
 */

void
dns_adb_cancelfind(dns_adbfind_t *find);
/*%<
 * Cancels the find, and sends the event off to the caller.
 *
 * It is an error to call dns_adb_cancelfind() on a find where
 * no event is wanted, or will ever be sent.
 *
 * Note:
 *
 *\li	It is possible that the real completion event was posted just
 *	before the dns_adb_cancelfind() call was made.  In this case,
 *	dns_adb_cancelfind() will do nothing.  The event callback needs
 *	to be prepared to find this situation (i.e. result is valid but
 *	the caller expects it to be canceled).
 *
 * Requires:
 *
 *\li	'find' be a valid dns_adbfind_t pointer.
 *
 *\li	events would have been posted to the task.  This can be checked
 *	with (find->options & DNS_ADBFIND_WANTEVENT).
 *
 * Ensures:
 *
 *\li	The event was posted to the task.
 */

void
dns_adb_destroyfind(dns_adbfind_t **find);
/*%<
 * Destroys the find reference.
 *
 * Note:
 *
 *\li	This can only be called after the event was delivered for a
 *	find.  Additionally, the event MUST have been freed via
 *	isc_event_free() BEFORE this function is called.
 *
 * Requires:
 *
 *\li	'find' != NULL and *find be valid dns_adbfind_t pointer.
 *
 * Ensures:
 *
 *\li	No "address found" events will be posted to the originating task
 *	after this function returns.
 */

void
dns_adb_dump(dns_adb_t *adb, FILE *f);
/*%<
 * This function is only used for debugging.  It will dump as much of the
 * state of the running system as possible.
 *
 * Requires:
 *
 *\li	adb be valid.
 *
 *\li	f != NULL, and is a file open for writing.
 */

void
dns_adb_dumpfind(dns_adbfind_t *find, FILE *f);
/*%<
 * This function is only used for debugging.  Dump the data associated
 * with a find.
 *
 * Requires:
 *
 *\li	find is valid.
 *
 * \li	f != NULL, and is a file open for writing.
 */

isc_result_t
dns_adb_marklame(dns_adb_t *adb, dns_adbaddrinfo_t *addr, dns_name_t *qname,
		 dns_rdatatype_t type, isc_stdtime_t expire_time);
/*%<
 * Mark the given address as lame for the <qname,qtype>.  expire_time should
 * be set to the time when the entry should expire.  That is, if it is to
 * expire 10 minutes in the future, it should set it to (now + 10 * 60).
 *
 * Requires:
 *
 *\li	adb be valid.
 *
 *\li	addr be valid.
 *
 *\li	qname be the qname used in the dns_adb_createfind() call.
 *
 * Returns:
 *
 *\li	#ISC_R_SUCCESS		-- all is well.
 *\li	#ISC_R_NOMEMORY		-- could not mark address as lame.
 */

/*
 * A reasonable default for RTT adjustments
 */
#define DNS_ADB_RTTADJDEFAULT		7	/*%< default scale */
#define DNS_ADB_RTTADJREPLACE		0	/*%< replace with our rtt */
#define DNS_ADB_RTTADJAGE		10	/*%< age this rtt */

void
dns_adb_adjustsrtt(dns_adb_t *adb, dns_adbaddrinfo_t *addr,
		   unsigned int rtt, unsigned int factor);
/*%<
 * Mix the round trip time into the existing smoothed rtt.  

 * The formula used
 * (where srtt is the existing rtt value, and rtt and factor are arguments to
 * this function):
 *
 *\code
 *	new_srtt = (old_srtt / 10 * factor) + (rtt / 10 * (10 - factor));
 *\endcode
 *
 * XXXRTH  Do we want to publish the formula?  What if we want to change how
 *         this works later on?  Recommend/require that the units are
 *	   microseconds?
 *
 * Requires:
 *
 *\li	adb be valid.
 *
 *\li	addr be valid.
 *
 *\li	0 <= factor <= 10
 *
 * Note:
 *
 *\li	The srtt in addr will be updated to reflect the new global
 *	srtt value.  This may include changes made by others.
 */

void
dns_adb_changeflags(dns_adb_t *adb, dns_adbaddrinfo_t *addr,
		    unsigned int bits, unsigned int mask);
/*%
 * Change Flags.
 *
 * Set the flags as given by:
 *
 *\li	newflags = (oldflags & ~mask) | (bits & mask);
 *
 * Requires:
 *
 *\li	adb be valid.
 *
 *\li	addr be valid.
 */

isc_result_t
dns_adb_findaddrinfo(dns_adb_t *adb, isc_sockaddr_t *sa,
		     dns_adbaddrinfo_t **addrp, isc_stdtime_t now);
/*%<
 * Return a dns_adbaddrinfo_t that is associated with address 'sa'.
 *
 * Requires:
 *
 *\li	adb is valid.
 *
 *\li	sa is valid.
 *
 *\li	addrp != NULL && *addrp == NULL
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_SHUTTINGDOWN
 */

void
dns_adb_freeaddrinfo(dns_adb_t *adb, dns_adbaddrinfo_t **addrp);
/*%<
 * Free a dns_adbaddrinfo_t allocated by dns_adb_findaddrinfo().
 *
 * Requires:
 *
 *\li	adb is valid.
 *
 *\li	*addrp is a valid dns_adbaddrinfo_t *.
 */

void
dns_adb_flush(dns_adb_t *adb);
/*%<
 * Flushes all cached data from the adb.
 *
 * Requires:
 *\li 	adb is valid.
 */

void
dns_adb_setadbsize(dns_adb_t *adb, isc_uint32_t size);
/*%<
 * Set a target memory size.  If memory usage exceeds the target
 * size entries will be removed before they would have expired on
 * a random basis.
 *
 * If 'size' is 0 then memory usage is unlimited.
 *
 * Requires:
 *\li	'adb' is valid.
 */

void
dns_adb_flushname(dns_adb_t *adb, dns_name_t *name);
/*%<
 * Flush 'name' from the adb cache.
 * 
 * Requires:
 *\li	'adb' is valid.
 *\li	'name' is valid.
 */


ISC_LANG_ENDDECLS

#endif /* DNS_ADB_H */
@


1.3
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: adb.h,v 1.66.2.5.2.4 2004/03/06 08:13:50 marka Exp $ */
d27 2
a28 1
/*
d53 3
a55 3
 * Lameness is stored per-zone, and this data hangs off each address field.
 * When an address is marked lame for a given zone the address will not
 * be returned to a caller.
d60 1
a60 1
 *	The ADB takes care of all necessary locking.
d62 1
a62 1
 *	Only the task which initiated the name lookup can cancel the lookup.
d67 1
a67 1
 *	None, since all data stored is required to be pre-filtered.
d102 2
a103 2
/* dns_adbfind_t
 *
d112 8
a119 8
	unsigned int			magic;		/* RO: magic */
	dns_adbaddrinfolist_t		list;		/* RO: list of addrs */
	unsigned int			query_pending;	/* RO: partial list */
	unsigned int			partial_result;	/* RO: addrs missing */
	unsigned int			options;	/* RO: options */
	isc_result_t			result_v4;	/* RO: v4 result */
	isc_result_t			result_v6;	/* RO: v6 result */
	ISC_LINK(dns_adbfind_t)		publink;	/* RW: client use */
d165 1
d167 1
d170 4
a173 1

d175 4
d180 4
d185 4
d190 4
d195 4
d200 3
d204 4
d210 1
a210 2
/* dns_adbaddrinfo_t
 *
d214 1
a214 1
	unsigned int			magic;		/* private */
d216 4
a219 4
	isc_sockaddr_t			sockaddr;	/* [rw] */
	unsigned int			srtt;		/* [rw] microseconds */
	unsigned int			flags;		/* [rw] */
	dns_adbentry_t		       *entry;		/* private */
d223 1
a223 1
/*
d233 2
a234 2
 *	DNS_EVENT_ADBMOREADDRESSES   -- another address resolved.
 *	DNS_EVENT_ADBNOMOREADDRESSES -- all pending addresses failed,
d237 1
a237 1
 *	DNS_EVENT_ADBCANCELED	     -- The request was canceled by a
d239 1
a239 1
 *	DNS_EVENT_ADBNAMEDELETED     -- The name was deleted, so this request
d254 1
a254 1
/*
d259 1
a259 1
 *	Generally, applications should not create an ADB directly, but
d264 1
a264 1
 *	'mem' must be a valid memory context.
d266 1
a266 1
 *	'view' be a pointer to a valid view.
d268 1
a268 1
 *	'tmgr' be a pointer to a valid timer manager.
d270 1
a270 1
 *	'taskmgr' be a pointer to a valid task manager.
d272 1
a272 1
 *	'newadb' != NULL && '*newadb' == NULL.
d276 2
a277 2
 *	ISC_R_SUCCESS	after happiness.
 *	ISC_R_NOMEMORY	after resource allocation failure.
d282 1
a282 1
/*
d286 2
a287 2
 *	'adb' to be a valid dns_adb_t, created via dns_adb_create().
 *	'adbp' to be a valid pointer to a *dns_adb_t which is initialized
d293 1
a293 1
/*
d298 1
a298 1
 *	'adb' be non-NULL and '*adb' be a valid dns_adb_t, created via
d304 1
a304 1
/*
d309 1
a309 1
 *	'*adb' is a valid dns_adb_t.
d311 1
a311 1
 *	eventp != NULL && *eventp is a valid event.
d315 1
a315 1
 *	*eventp == NULL
d317 1
a317 1
 *	The event's sender field is set to the value of adb when the event
d323 1
a323 1
/*
d328 1
a328 1
 * 	'*adb' is a valid dns_adb_t.
d333 3
a335 2
		   void *arg, dns_name_t *name, dns_name_t *zone,
		   unsigned int options, isc_stdtime_t now, dns_name_t *target,
d337 1
a337 1
/*
d347 3
a349 3
 * members may be examined for address lookup status.  The usual ISC_R_SUCCESS,
 * ISC_R_FAILURE, and DNS_R_NX{DOMAIN,RRSET} are returned, along with
 * ISC_R_NOTFOUND meaning the ADB has not _yet_ found the values.  In this
d382 1
a382 1
 *	*adb be a valid isc_adb_t object.
d384 1
a384 1
 *	If events are to be sent, *task be a valid task,
d387 1
a387 1
 *	*name is a valid dns_name_t.
d389 1
a389 1
 *	zone != NULL and *zone be a valid dns_name_t.
d391 1
a391 1
 *	target == NULL or target is a valid name with a buffer.
d393 1
a393 1
 *	find != NULL && *find == NULL.
d397 1
a397 1
 *	ISC_R_SUCCESS	Addresses might have been returned, and events will be
d399 1
a399 1
 *	ISC_R_NOMORE	Addresses might have been returned, but no events
d402 2
a403 2
 *	ISC_R_NOMEMORY	insufficient resources
 *	DNS_R_ALIAS	'name' is an alias for another name.
d407 1
a407 1
 *	isc_stdtime_get()
d411 1
a411 1
 *	No internal reference to "name" exists after this function
d417 1
a417 1
/*
d425 1
a425 1
 *	It is possible that the real completion event was posted just
d433 1
a433 1
 *	'find' be a valid dns_adbfind_t pointer.
d435 1
a435 1
 *	events would have been posted to the task.  This can be checked
d440 1
a440 1
 *	The event was posted to the task.
d445 1
a445 1
/*
d450 1
a450 1
 *	This can only be called after the event was delivered for a
d456 1
a456 1
 *	'find' != NULL and *find be valid dns_adbfind_t pointer.
d460 1
a460 1
 *	No "address found" events will be posted to the originating task
d466 1
a466 1
/*
d472 1
a472 1
 *	adb be valid.
d474 1
a474 1
 *	f != NULL, and is a file open for writing.
d479 1
a479 1
/*
d485 1
a485 1
 *	find is valid.
d487 1
a487 1
 * 	f != NULL, and is a file open for writing.
d491 4
a494 4
dns_adb_marklame(dns_adb_t *adb, dns_adbaddrinfo_t *addr, dns_name_t *zone,
		 isc_stdtime_t expire_time);
/*
 * Mark the given address as lame for the zone "zone".  expire_time should
d500 1
a500 1
 *	adb be valid.
d502 1
a502 1
 *	addr be valid.
d504 1
a504 1
 *	zone be the zone used in the dns_adb_createfind() call.
d508 2
a509 2
 *	ISC_R_SUCCESS		-- all is well.
 *	ISC_R_NOMEMORY		-- could not mark address as lame.
d515 3
a517 3
#define DNS_ADB_RTTADJDEFAULT		7	/* default scale */
#define DNS_ADB_RTTADJREPLACE		0	/* replace with our rtt */
#define DNS_ADB_RTTADJAGE		10	/* age this rtt */
d522 4
a525 2
/*
 * Mix the round trip time into the existing smoothed rtt.  The formula used
d529 1
d531 1
d539 1
a539 1
 *	adb be valid.
d541 1
a541 1
 *	addr be valid.
d543 1
a543 1
 *	0 <= factor <= 10
d547 1
a547 1
 *	The srtt in addr will be updated to reflect the new global
d554 3
a556 1
/*
d559 1
a559 1
 *	newflags = (oldflags & ~mask) | (bits & mask);
d563 1
a563 1
 *	adb be valid.
d565 1
a565 1
 *	addr be valid.
d571 1
a571 1
/*
d576 1
a576 1
 *	adb is valid.
d578 1
a578 1
 *	sa is valid.
d580 1
a580 1
 *	addrp != NULL && *addrp == NULL
d583 3
a585 3
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
 *	ISC_R_SHUTTINGDOWN
d590 1
a590 1
/*
d595 1
a595 1
 *	adb is valid.
d597 1
a597 1
 *	*addrp is a valid dns_adbaddrinfo_t *.
d602 1
a602 1
/*
d606 1
a606 1
 * 	adb is valid.
d611 1
a611 1
/*
d619 1
a619 1
 *	'adb' is valid.
d624 1
a624 1
/*
d628 2
a629 2
 *	'adb' is valid.
 *	'name' is valid.
@


1.2
log
@update to BIND v9.2.3. ok todd@@
@
text
@d2 1
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: adb.h,v 1.66.2.5 2003/07/22 04:03:45 marka Exp $ */
d50 1
a50 3
 * smaller of the TTL or signature validity period. For A6 records, the timer
 * is the smallest of all the TTL or signature validity periods in the A6
 * chain.
d256 1
a256 1
 *		to NULL.
d569 24
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2002  Internet Software Consortium.
d18 1
a18 1
/* $ISC: adb.h,v 1.66.2.3 2002/08/05 06:57:13 marka Exp $ */
d150 3
a152 3
 * _STARTATROOT:
 *	Fetches will start at the root nameservers, instead of the closest
 *	ancestor.  This is useful for reestablishing glue that has expired.
d173 1
a173 1
#define DNS_ADBFIND_STARTATROOT		0x00000020
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1999-2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: adb.h,v 1.66.2.5.2.4 2004/03/06 08:13:50 marka Exp $ */
d50 3
a52 1
 * smaller of the TTL or signature validity period.
d150 3
a152 3
 * _STARTATZONE:
 *	Fetches will start using the closest zone data or use the root servers.
 *	This is useful for reestablishing glue that has expired.
d173 1
a173 1
#define DNS_ADBFIND_STARTATZONE		0x00000020
d258 1
a258 1
 *	to NULL.
a570 24

void
dns_adb_setadbsize(dns_adb_t *adb, isc_uint32_t size);
/*
 * Set a target memory size.  If memory usage exceeds the target
 * size entries will be removed before they would have expired on
 * a random basis.
 *
 * If 'size' is 0 then memory usage is unlimited.
 *
 * Requires:
 *	'adb' is valid.
 */

void
dns_adb_flushname(dns_adb_t *adb, dns_name_t *name);
/*
 * Flush 'name' from the adb cache.
 * 
 * Requires:
 *	'adb' is valid.
 *	'name' is valid.
 */

@


1.1.1.3
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: adb.h,v 1.76.18.3 2005/06/23 04:23:16 marka Exp $ */
d27 1
a27 2
/*! \file
 *\brief
d52 3
a54 3
 * Lameness is stored per <qname,qtype> tuple, and this data hangs off each
 * address field.  When an address is marked lame for a given tuple the address
 * will not be returned to a caller.
d59 1
a59 1
 *\li	The ADB takes care of all necessary locking.
d61 1
a61 1
 *\li	Only the task which initiated the name lookup can cancel the lookup.
d66 1
a66 1
 *\li	None, since all data stored is required to be pre-filtered.
d101 2
a102 2
/*! 
 *\brief
d111 8
a118 8
	unsigned int			magic;		/*%< RO: magic */
	dns_adbaddrinfolist_t		list;		/*%< RO: list of addrs */
	unsigned int			query_pending;	/*%< RO: partial list */
	unsigned int			partial_result;	/*%< RO: addrs missing */
	unsigned int			options;	/*%< RO: options */
	isc_result_t			result_v4;	/*%< RO: v4 result */
	isc_result_t			result_v6;	/*%< RO: v6 result */
	ISC_LINK(dns_adbfind_t)		publink;	/*%< RW: client use */
a163 1
/*% Return addresses of type INET. */
a164 1
/*% Return addresses of type INET6. */
d167 1
a167 4
/*%
 *      Only schedule an event if no addresses are known.
 *      Must set _WANTEVENT for this to be meaningful.
 */
a168 4
/*%
 *	An event is desired.  Check this bit in the returned find to see
 *	if one will actually be generated.
 */
a169 4
/*%
 *	If set, fetches will not be generated unless no addresses are
 *	available in any of the address families requested.
 */
a170 4
/*%
 *	Fetches will start using the closest zone data or use the root servers.
 *	This is useful for reestablishing glue that has expired.
 */
a171 4
/*%
 *	Glue or hints are ok.  These are used when matching names already
 *	in the adb, and when dns databases are searched.
 */
a172 4
/*%
 *	Glue or hints are ok.  These are used when matching names already
 *	in the adb, and when dns databases are searched.
 */
a173 3
/*%
 *	Return lame servers in a find, so that all addresses are returned.
 */
a174 4
/*%
 *      Only schedule an event if no addresses are known.
 *      Must set _WANTEVENT for this to be meaningful.
 */
d177 2
a178 1
/*%
d182 1
a182 1
	unsigned int			magic;		/*%< private */
d184 4
a187 4
	isc_sockaddr_t			sockaddr;	/*%< [rw] */
	unsigned int			srtt;		/*%< [rw] microseconds */
	unsigned int			flags;		/*%< [rw] */
	dns_adbentry_t		       *entry;		/*%< private */
d191 1
a191 1
/*!< 
d201 2
a202 2
 *\li	#DNS_EVENT_ADBMOREADDRESSES   -- another address resolved.
 *\li	#DNS_EVENT_ADBNOMOREADDRESSES -- all pending addresses failed,
d205 1
a205 1
 *\li	#DNS_EVENT_ADBCANCELED	     -- The request was canceled by a
d207 1
a207 1
 *\li	#DNS_EVENT_ADBNAMEDELETED     -- The name was deleted, so this request
d222 1
a222 1
/*%<
d227 1
a227 1
 *\li	Generally, applications should not create an ADB directly, but
d232 1
a232 1
 *\li	'mem' must be a valid memory context.
d234 1
a234 1
 *\li	'view' be a pointer to a valid view.
d236 1
a236 1
 *\li	'tmgr' be a pointer to a valid timer manager.
d238 1
a238 1
 *\li	'taskmgr' be a pointer to a valid task manager.
d240 1
a240 1
 *\li	'newadb' != NULL && '*newadb' == NULL.
d244 2
a245 2
 *\li	#ISC_R_SUCCESS	after happiness.
 *\li	#ISC_R_NOMEMORY	after resource allocation failure.
d250 1
a250 1
/*%
d254 2
a255 2
 *\li	'adb' to be a valid dns_adb_t, created via dns_adb_create().
 *\li	'adbp' to be a valid pointer to a *dns_adb_t which is initialized
d261 1
a261 1
/*%
d266 1
a266 1
 *\li	'adb' be non-NULL and '*adb' be a valid dns_adb_t, created via
d272 1
a272 1
/*%
d277 1
a277 1
 *\li	'*adb' is a valid dns_adb_t.
d279 1
a279 1
 *\li	eventp != NULL && *eventp is a valid event.
d283 1
a283 1
 *\li	*eventp == NULL
d285 1
a285 1
 *\li	The event's sender field is set to the value of adb when the event
d291 1
a291 1
/*%<
d296 1
a296 1
 * \li	'*adb' is a valid dns_adb_t.
d301 2
a302 3
		   void *arg, dns_name_t *name, dns_name_t *qname,
		   dns_rdatatype_t qtype, unsigned int options,
		   isc_stdtime_t now, dns_name_t *target,
d304 1
a304 1
/*%<
d314 3
a316 3
 * members may be examined for address lookup status.  The usual #ISC_R_SUCCESS,
 * #ISC_R_FAILURE, and #DNS_R_NX{DOMAIN,RRSET} are returned, along with
 * #ISC_R_NOTFOUND meaning the ADB has not _yet_ found the values.  In this
d349 1
a349 1
 *\li	*adb be a valid isc_adb_t object.
d351 1
a351 1
 *\li	If events are to be sent, *task be a valid task,
d354 1
a354 1
 *\li	*name is a valid dns_name_t.
d356 1
a356 1
 *\li	qname != NULL and *qname be a valid dns_name_t.
d358 1
a358 1
 *\li	target == NULL or target is a valid name with a buffer.
d360 1
a360 1
 *\li	find != NULL && *find == NULL.
d364 1
a364 1
 *\li	#ISC_R_SUCCESS	Addresses might have been returned, and events will be
d366 1
a366 1
 *\li	#ISC_R_NOMORE	Addresses might have been returned, but no events
d369 2
a370 2
 *\li	#ISC_R_NOMEMORY	insufficient resources
 *\li	#DNS_R_ALIAS	'name' is an alias for another name.
d374 1
a374 1
 *\li	isc_stdtime_get()
d378 1
a378 1
 *\li	No internal reference to "name" exists after this function
d384 1
a384 1
/*%<
d392 1
a392 1
 *\li	It is possible that the real completion event was posted just
d400 1
a400 1
 *\li	'find' be a valid dns_adbfind_t pointer.
d402 1
a402 1
 *\li	events would have been posted to the task.  This can be checked
d407 1
a407 1
 *\li	The event was posted to the task.
d412 1
a412 1
/*%<
d417 1
a417 1
 *\li	This can only be called after the event was delivered for a
d423 1
a423 1
 *\li	'find' != NULL and *find be valid dns_adbfind_t pointer.
d427 1
a427 1
 *\li	No "address found" events will be posted to the originating task
d433 1
a433 1
/*%<
d439 1
a439 1
 *\li	adb be valid.
d441 1
a441 1
 *\li	f != NULL, and is a file open for writing.
d446 1
a446 1
/*%<
d452 1
a452 1
 *\li	find is valid.
d454 1
a454 1
 * \li	f != NULL, and is a file open for writing.
d458 4
a461 4
dns_adb_marklame(dns_adb_t *adb, dns_adbaddrinfo_t *addr, dns_name_t *qname,
		 dns_rdatatype_t type, isc_stdtime_t expire_time);
/*%<
 * Mark the given address as lame for the <qname,qtype>.  expire_time should
d467 1
a467 1
 *\li	adb be valid.
d469 1
a469 1
 *\li	addr be valid.
d471 1
a471 1
 *\li	qname be the qname used in the dns_adb_createfind() call.
d475 2
a476 2
 *\li	#ISC_R_SUCCESS		-- all is well.
 *\li	#ISC_R_NOMEMORY		-- could not mark address as lame.
d482 3
a484 3
#define DNS_ADB_RTTADJDEFAULT		7	/*%< default scale */
#define DNS_ADB_RTTADJREPLACE		0	/*%< replace with our rtt */
#define DNS_ADB_RTTADJAGE		10	/*%< age this rtt */
d489 2
a490 4
/*%<
 * Mix the round trip time into the existing smoothed rtt.  

 * The formula used
a493 1
 *\code
a494 1
 *\endcode
d502 1
a502 1
 *\li	adb be valid.
d504 1
a504 1
 *\li	addr be valid.
d506 1
a506 1
 *\li	0 <= factor <= 10
d510 1
a510 1
 *\li	The srtt in addr will be updated to reflect the new global
d517 1
a517 3
/*%
 * Change Flags.
 *
d520 1
a520 1
 *\li	newflags = (oldflags & ~mask) | (bits & mask);
d524 1
a524 1
 *\li	adb be valid.
d526 1
a526 1
 *\li	addr be valid.
d532 1
a532 1
/*%<
d537 1
a537 1
 *\li	adb is valid.
d539 1
a539 1
 *\li	sa is valid.
d541 1
a541 1
 *\li	addrp != NULL && *addrp == NULL
d544 3
a546 3
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_SHUTTINGDOWN
d551 1
a551 1
/*%<
d556 1
a556 1
 *\li	adb is valid.
d558 1
a558 1
 *\li	*addrp is a valid dns_adbaddrinfo_t *.
d563 1
a563 1
/*%<
d567 1
a567 1
 *\li 	adb is valid.
d572 1
a572 1
/*%<
d580 1
a580 1
 *\li	'adb' is valid.
d585 1
a585 1
/*%<
d589 2
a590 2
 *\li	'adb' is valid.
 *\li	'name' is valid.
@


