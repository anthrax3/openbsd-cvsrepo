head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.38
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.36
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.32
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.34
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.26
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.30
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.28
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.24
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.22
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.20
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.18
	OPENBSD_5_0:1.6.0.16
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.14
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.12
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.8
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.10
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.6
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	BIND_9_4_2_P1:1.1.1.5
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	BIND_9_4_2:1.1.1.5
	OPENBSD_4_2:1.5.0.4
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	BIND_9_3_4:1.1.1.4
	BIND_9_3_3:1.1.1.4
	OPENBSD_4_0:1.4.0.6
	OPENBSD_4_0_BASE:1.4
	BIND_9_3_2:1.1.1.3
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	BIND_9_3_1:1.1.1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2007.12.09.13.39.44;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.10.19.07.59;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.22.16.52.39;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.28.17.14.06;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.18.14.14.07;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.07.20;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.20;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.13;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.03.22.16.38.04;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.01.10.18.19.52;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2007.12.09.12.34.45;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.6
log
@resolve conflicts
@
text
@/*
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1998-2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: name.h,v 1.107.18.15 2006/03/02 00:37:21 marka Exp $ */

#ifndef DNS_NAME_H
#define DNS_NAME_H 1

/*****
 ***** Module Info
 *****/

/*! \file
 * \brief
 * Provides facilities for manipulating DNS names and labels, including
 * conversions to and from wire format and text format.
 *
 * Given the large number of names possible in a nameserver, and because
 * names occur in rdata, it was important to come up with a very efficient
 * way of storing name data, but at the same time allow names to be
 * manipulated.  The decision was to store names in uncompressed wire format,
 * and not to make them fully abstracted objects; i.e. certain parts of the
 * server know names are stored that way.  This saves a lot of memory, and
 * makes adding names to messages easy.  Having much of the server know
 * the representation would be perilous, and we certainly don't want each
 * user of names to be manipulating such a low-level structure.  This is
 * where the Names and Labels module comes in.  The module allows name or
 * label handles to be created and attached to uncompressed wire format
 * regions.  All name operations and conversions are done through these
 * handles.
 *
 * MP:
 *\li	Clients of this module must impose any required synchronization.
 *
 * Reliability:
 *\li	This module deals with low-level byte streams.  Errors in any of
 *	the functions are likely to crash the server or corrupt memory.
 *
 * Resources:
 *\li	None.
 *
 * Security:
 *
 *\li	*** WARNING ***
 *
 *\li	dns_name_fromwire() deals with raw network data.  An error in
 *	this routine could result in the failure or hijacking of the server.
 *
 * Standards:
 *\li	RFC1035
 *\li	Draft EDNS0 (0)
 *\li	Draft Binary Labels (2)
 *
 */

/***
 *** Imports
 ***/

#include <stdio.h>

#include <isc/boolean.h>
#include <isc/lang.h>
#include <isc/magic.h>
#include <isc/region.h>		/* Required for storage size of dns_label_t. */

#include <dns/types.h>

ISC_LANG_BEGINDECLS

/*****
 ***** Labels
 *****
 ***** A 'label' is basically a region.  It contains one DNS wire format
 ***** label of type 00 (ordinary).
 *****/

/*****
 ***** Names
 *****
 ***** A 'name' is a handle to a binary region.  It contains a sequence of one
 ***** or more DNS wire format labels of type 00 (ordinary).
 ***** Note that all names are not required to end with the root label,
 ***** as they are in the actual DNS wire protocol.
 *****/

/***
 *** Compression pointer chaining limit
 ***/

#define DNS_POINTER_MAXHOPS		16

/***
 *** Types
 ***/

/*%
 * Clients are strongly discouraged from using this type directly,  with
 * the exception of the 'link' and 'list' fields which may be used directly
 * for whatever purpose the client desires.
 */
struct dns_name {
	unsigned int			magic;
	unsigned char *			ndata;
	unsigned int			length;
	unsigned int			labels;
	unsigned int			attributes;
	unsigned char *			offsets;
	isc_buffer_t *			buffer;
	ISC_LINK(dns_name_t)		link;
	ISC_LIST(dns_rdataset_t)	list;
};

#define DNS_NAME_MAGIC			ISC_MAGIC('D','N','S','n')

#define DNS_NAMEATTR_ABSOLUTE		0x0001
#define DNS_NAMEATTR_READONLY		0x0002
#define DNS_NAMEATTR_DYNAMIC		0x0004
#define DNS_NAMEATTR_DYNOFFSETS		0x0008
/*
 * Attributes below 0x0100 reserved for name.c usage.
 */
#define DNS_NAMEATTR_CACHE		0x0100		/*%< Used by resolver. */
#define DNS_NAMEATTR_ANSWER		0x0200		/*%< Used by resolver. */
#define DNS_NAMEATTR_NCACHE		0x0400		/*%< Used by resolver. */
#define DNS_NAMEATTR_CHAINING		0x0800		/*%< Used by resolver. */
#define DNS_NAMEATTR_CHASE		0x1000		/*%< Used by resolver. */
#define DNS_NAMEATTR_WILDCARD		0x2000		/*%< Used by server. */

#define DNS_NAME_DOWNCASE		0x0001
#define DNS_NAME_CHECKNAMES		0x0002		/*%< Used by rdata. */
#define DNS_NAME_CHECKNAMESFAIL		0x0004		/*%< Used by rdata. */
#define DNS_NAME_CHECKREVERSE		0x0008		/*%< Used by rdata. */
#define DNS_NAME_CHECKMX		0x0010		/*%< Used by rdata. */
#define DNS_NAME_CHECKMXFAIL		0x0020		/*%< Used by rdata. */

LIBDNS_EXTERNAL_DATA extern dns_name_t *dns_rootname;
LIBDNS_EXTERNAL_DATA extern dns_name_t *dns_wildcardname;

/*%
 * Standard size of a wire format name
 */
#define DNS_NAME_MAXWIRE 255

/*
 * Text output filter procedure.
 * 'target' is the buffer to be converted.  The region to be converted
 * is from 'buffer'->base + 'used_org' to the end of the used region.
 */
typedef isc_result_t (*dns_name_totextfilter_t)(isc_buffer_t *target,
						unsigned int used_org,
						isc_boolean_t absolute);

/***
 *** Initialization
 ***/

void
dns_name_init(dns_name_t *name, unsigned char *offsets);
/*%<
 * Initialize 'name'.
 *
 * Notes:
 * \li	'offsets' is never required to be non-NULL, but specifying a
 *	dns_offsets_t for 'offsets' will improve the performance of most
 *	name operations if the name is used more than once.
 *
 * Requires:
 * \li	'name' is not NULL and points to a struct dns_name.
 *
 * \li	offsets == NULL or offsets is a dns_offsets_t.
 *
 * Ensures:
 * \li	'name' is a valid name.
 * \li	dns_name_countlabels(name) == 0
 * \li	dns_name_isabsolute(name) == ISC_FALSE
 */

void
dns_name_reset(dns_name_t *name);
/*%<
 * Reinitialize 'name'.
 *
 * Notes:
 * \li	This function distinguishes itself from dns_name_init() in two
 *	key ways:
 *
 * \li	+ If any buffer is associated with 'name' (via dns_name_setbuffer()
 *	  or by being part of a dns_fixedname_t) the link to the buffer
 *	  is retained but the buffer itself is cleared.
 *
 * \li	+ Of the attributes associated with 'name', all are retained except
 *	  DNS_NAMEATTR_ABSOLUTE.
 *
 * Requires:
 * \li	'name' is a valid name.
 *
 * Ensures:
 * \li	'name' is a valid name.
 * \li	dns_name_countlabels(name) == 0
 * \li	dns_name_isabsolute(name) == ISC_FALSE
 */

void
dns_name_invalidate(dns_name_t *name);
/*%<
 * Make 'name' invalid.
 *
 * Requires:
 * \li	'name' is a valid name.
 *
 * Ensures:
 * \li	If assertion checking is enabled, future attempts to use 'name'
 *	without initializing it will cause an assertion failure.
 *
 * \li	If the name had a dedicated buffer, that association is ended.
 */


/***
 *** Dedicated Buffers
 ***/

void
dns_name_setbuffer(dns_name_t *name, isc_buffer_t *buffer);
/*%<
 * Dedicate a buffer for use with 'name'.
 *
 * Notes:
 * \li	Specification of a target buffer in dns_name_fromwire(),
 *	dns_name_fromtext(), and dns_name_concatentate() is optional if
 *	'name' has a dedicated buffer.
 *
 * \li	The caller must not write to buffer until the name has been
 *	invalidated or is otherwise known not to be in use.
 *
 * \li	If buffer is NULL and the name previously had a dedicated buffer,
 *	than that buffer is no longer dedicated to use with this name.
 *	The caller is responsible for ensuring that the storage used by
 *	the name remains valid.
 *
 * Requires:
 * \li	'name' is a valid name.
 *
 * \li	'buffer' is a valid binary buffer and 'name' doesn't have a
 *	dedicated buffer already, or 'buffer' is NULL.
 */

isc_boolean_t
dns_name_hasbuffer(const dns_name_t *name);
/*%<
 * Does 'name' have a dedicated buffer?
 *
 * Requires:
 * \li	'name' is a valid name.
 *
 * Returns:
 * \li	ISC_TRUE	'name' has a dedicated buffer.
 * \li	ISC_FALSE	'name' does not have a dedicated buffer.
 */

/***
 *** Properties
 ***/

isc_boolean_t
dns_name_isabsolute(const dns_name_t *name);
/*%<
 * Does 'name' end in the root label?
 *
 * Requires:
 * \li	'name' is a valid name
 *
 * Returns:
 * \li	TRUE		The last label in 'name' is the root label.
 * \li	FALSE		The last label in 'name' is not the root label.
 */

isc_boolean_t
dns_name_iswildcard(const dns_name_t *name);
/*%<
 * Is 'name' a wildcard name?
 *
 * Requires:
 * \li	'name' is a valid name
 *
 * \li	dns_name_countlabels(name) > 0
 *
 * Returns:
 * \li	TRUE		The least significant label of 'name' is '*'.
 * \li	FALSE		The least significant label of 'name' is not '*'.
 */

unsigned int
dns_name_hash(dns_name_t *name, isc_boolean_t case_sensitive);
/*%<
 * Provide a hash value for 'name'.
 *
 * Note: if 'case_sensitive' is ISC_FALSE, then names which differ only in
 * case will have the same hash value.
 *
 * Requires:
 * \li	'name' is a valid name
 *
 * Returns:
 * \li	A hash value
 */

unsigned int
dns_name_fullhash(dns_name_t *name, isc_boolean_t case_sensitive);
/*%<
 * Provide a hash value for 'name'.  Unlike dns_name_hash(), this function
 * always takes into account of the entire name to calculate the hash value.
 *
 * Note: if 'case_sensitive' is ISC_FALSE, then names which differ only in
 * case will have the same hash value.
 *
 * Requires:
 *\li	'name' is a valid name
 *
 * Returns:
 *\li	A hash value
 */

unsigned int
dns_name_hashbylabel(dns_name_t *name, isc_boolean_t case_sensitive);
/*%<
 * Provide a hash value for 'name', where the hash value is the sum
 * of the hash values of each label.
 *
 * Note: if 'case_sensitive' is ISC_FALSE, then names which differ only in
 * case will have the same hash value.
 *
 * Requires:
 *\li	'name' is a valid name
 *
 * Returns:
 *\li	A hash value
 */

/*
 *** Comparisons
 ***/

dns_namereln_t
dns_name_fullcompare(const dns_name_t *name1, const dns_name_t *name2,
		     int *orderp, unsigned int *nlabelsp);
/*%<
 * Determine the relative ordering under the DNSSEC order relation of
 * 'name1' and 'name2', and also determine the hierarchical
 * relationship of the names.
 *
 * Note: It makes no sense for one of the names to be relative and the
 * other absolute.  If both names are relative, then to be meaningfully
 * compared the caller must ensure that they are both relative to the
 * same domain.
 *
 * Requires:
 *\li	'name1' is a valid name
 *
 *\li	dns_name_countlabels(name1) > 0
 *
 *\li	'name2' is a valid name
 *
 *\li	dns_name_countlabels(name2) > 0
 *
 *\li	orderp and nlabelsp are valid pointers.
 *
 *\li	Either name1 is absolute and name2 is absolute, or neither is.
 *
 * Ensures:
 *
 *\li	*orderp is < 0 if name1 < name2, 0 if name1 = name2, > 0 if
 *	name1 > name2.
 *
 *\li	*nlabelsp is the number of common significant labels.
 *
 * Returns:
 *\li	dns_namereln_none		There's no hierarchical relationship
 *					between name1 and name2.
 *\li	dns_namereln_contains		name1 properly contains name2; i.e.
 *					name2 is a proper subdomain of name1.
 *\li	dns_namereln_subdomain		name1 is a proper subdomain of name2.
 *\li	dns_namereln_equal		name1 and name2 are equal.
 *\li	dns_namereln_commonancestor	name1 and name2 share a common
 *					ancestor.
 */

int
dns_name_compare(const dns_name_t *name1, const dns_name_t *name2);
/*%<
 * Determine the relative ordering under the DNSSEC order relation of
 * 'name1' and 'name2'.
 *
 * Note: It makes no sense for one of the names to be relative and the
 * other absolute.  If both names are relative, then to be meaningfully
 * compared the caller must ensure that they are both relative to the
 * same domain.
 *
 * Requires:
 * \li	'name1' is a valid name
 *
 * \li	'name2' is a valid name
 *
 * \li	Either name1 is absolute and name2 is absolute, or neither is.
 *
 * Returns:
 * \li	< 0		'name1' is less than 'name2'
 * \li	0		'name1' is equal to 'name2'
 * \li	> 0		'name1' is greater than 'name2'
 */

isc_boolean_t
dns_name_equal(const dns_name_t *name1, const dns_name_t *name2);
/*%<
 * Are 'name1' and 'name2' equal?
 *
 * Notes:
 * \li	Because it only needs to test for equality, dns_name_equal() can be
 *	significantly faster than dns_name_fullcompare() or dns_name_compare().
 *
 * \li	Offsets tables are not used in the comparision.
 *
 * \li	It makes no sense for one of the names to be relative and the
 *	other absolute.  If both names are relative, then to be meaningfully
 * 	compared the caller must ensure that they are both relative to the
 * 	same domain.
 *
 * Requires:
 * \li	'name1' is a valid name
 *
 * \li	'name2' is a valid name
 *
 * \li	Either name1 is absolute and name2 is absolute, or neither is.
 *
 * Returns:
 * \li	ISC_TRUE	'name1' and 'name2' are equal
 * \li	ISC_FALSE	'name1' and 'name2' are not equal
 */

isc_boolean_t
dns_name_caseequal(const dns_name_t *name1, const dns_name_t *name2);
/*%<
 * Case sensitive version of dns_name_equal().
 */

int
dns_name_rdatacompare(const dns_name_t *name1, const dns_name_t *name2);
/*%<
 * Compare two names as if they are part of rdata in DNSSEC canonical
 * form.
 *
 * Requires:
 * \li	'name1' is a valid absolute name
 *
 * \li	dns_name_countlabels(name1) > 0
 *
 * \li	'name2' is a valid absolute name
 *
 * \li	dns_name_countlabels(name2) > 0
 *
 * Returns:
 * \li	< 0		'name1' is less than 'name2'
 * \li	0		'name1' is equal to 'name2'
 * \li	> 0		'name1' is greater than 'name2'
 */

isc_boolean_t
dns_name_issubdomain(const dns_name_t *name1, const dns_name_t *name2);
/*%<
 * Is 'name1' a subdomain of 'name2'?
 *
 * Notes:
 * \li	name1 is a subdomain of name2 if name1 is contained in name2, or
 *	name1 equals name2.
 *
 * \li	It makes no sense for one of the names to be relative and the
 *	other absolute.  If both names are relative, then to be meaningfully
 *	compared the caller must ensure that they are both relative to the
 *	same domain.
 *
 * Requires:
 * \li	'name1' is a valid name
 *
 * \li	'name2' is a valid name
 *
 * \li	Either name1 is absolute and name2 is absolute, or neither is.
 *
 * Returns:
 * \li	TRUE		'name1' is a subdomain of 'name2'
 * \li	FALSE		'name1' is not a subdomain of 'name2'
 */

isc_boolean_t
dns_name_matcheswildcard(const dns_name_t *name, const dns_name_t *wname);
/*%<
 * Does 'name' match the wildcard specified in 'wname'?
 *
 * Notes:
 * \li	name matches the wildcard specified in wname if all labels
 *	following the wildcard in wname are identical to the same number
 *	of labels at the end of name.
 *
 * \li	It makes no sense for one of the names to be relative and the
 *	other absolute.  If both names are relative, then to be meaningfully
 *	compared the caller must ensure that they are both relative to the
 *	same domain.
 *
 * Requires:
 * \li	'name' is a valid name
 *
 * \li	dns_name_countlabels(name) > 0
 *
 * \li	'wname' is a valid name
 *
 * \li	dns_name_countlabels(wname) > 0
 *
 * \li	dns_name_iswildcard(wname) is true
 *
 * \li	Either name is absolute and wname is absolute, or neither is.
 *
 * Returns:
 * \li	TRUE		'name' matches the wildcard specified in 'wname'
 * \li	FALSE		'name' does not match the wildcard specified in 'wname'
 */

/***
 *** Labels
 ***/

unsigned int
dns_name_countlabels(const dns_name_t *name);
/*%<
 * How many labels does 'name' have?
 *
 * Notes:
 * \li	In this case, as in other places, a 'label' is an ordinary label.
 *
 * Requires:
 * \li	'name' is a valid name
 *
 * Ensures:
 * \li	The result is <= 128.
 *
 * Returns:
 * \li	The number of labels in 'name'.
 */

void
dns_name_getlabel(const dns_name_t *name, unsigned int n, dns_label_t *label);
/*%<
 * Make 'label' refer to the 'n'th least significant label of 'name'.
 *
 * Notes:
 * \li	Numbering starts at 0.
 *
 * \li	Given "rc.vix.com.", the label 0 is "rc", and label 3 is the
 *	root label.
 *
 * \li	'label' refers to the same memory as 'name', so 'name' must not
 *	be changed while 'label' is still in use.
 *
 * Requires:
 * \li	n < dns_name_countlabels(name)
 */

void
dns_name_getlabelsequence(const dns_name_t *source, unsigned int first,
			  unsigned int n, dns_name_t *target);
/*%<
 * Make 'target' refer to the 'n' labels including and following 'first'
 * in 'source'.
 *
 * Notes:
 * \li	Numbering starts at 0.
 *
 * \li	Given "rc.vix.com.", the label 0 is "rc", and label 3 is the
 *	root label.
 *
 * \li	'target' refers to the same memory as 'source', so 'source'
 *	must not be changed while 'target' is still in use.
 *
 * Requires:
 * \li	'source' and 'target' are valid names.
 *
 * \li	first < dns_name_countlabels(name)
 *
 * \li	first + n <= dns_name_countlabels(name)
 */


void
dns_name_clone(const dns_name_t *source, dns_name_t *target);
/*%<
 * Make 'target' refer to the same name as 'source'.
 *
 * Notes:
 *
 * \li	'target' refers to the same memory as 'source', so 'source'
 *	must not be changed while 'target' is still in use.
 *
 * \li	This call is functionally equivalent to:
 *
 * \code
 *		dns_name_getlabelsequence(source, 0,
 *					  dns_name_countlabels(source),
 *					  target);
 * \endcode
 *
 *	but is more efficient.  Also, dns_name_clone() works even if 'source'
 *	is empty.
 *
 * Requires:
 *
 * \li	'source' is a valid name.
 *
 * \li	'target' is a valid name that is not read-only.
 */

/***
 *** Conversions
 ***/

void
dns_name_fromregion(dns_name_t *name, const isc_region_t *r);
/*%<
 * Make 'name' refer to region 'r'.
 *
 * Note:
 * \li	If the conversion encounters a root label before the end of the
 *	region the conversion stops and the length is set to the length
 *	so far converted.  A maximum of 255 bytes is converted.
 *
 * Requires:
 * \li	The data in 'r' is a sequence of one or more type 00 or type 01000001
 *	labels.
 */

void
dns_name_toregion(dns_name_t *name, isc_region_t *r);
/*%<
 * Make 'r' refer to 'name'.
 *
 * Requires:
 *
 * \li	'name' is a valid name.
 *
 * \li	'r' is a valid region.
 */

isc_result_t
dns_name_fromwire(dns_name_t *name, isc_buffer_t *source,
		  dns_decompress_t *dctx, unsigned int options,
		  isc_buffer_t *target);
/*%<
 * Copy the possibly-compressed name at source (active region) into target,
 * decompressing it.
 *
 * Notes:
 * \li	Decompression policy is controlled by 'dctx'.
 *
 * \li	If DNS_NAME_DOWNCASE is set, any uppercase letters in 'source' will be
 *	downcased when they are copied into 'target'.
 *
 * Security:
 *
 * \li	*** WARNING ***
 *
 * \li	This routine will often be used when 'source' contains raw network
 *	data.  A programming error in this routine could result in a denial
 *	of service, or in the hijacking of the server.
 *
 * Requires:
 *
 * \li	'name' is a valid name.
 *
 * \li	'source' is a valid buffer and the first byte of the active
 *	region should be the first byte of a DNS wire format domain name.
 *
 * \li	'target' is a valid buffer or 'target' is NULL and 'name' has
 *	a dedicated buffer.
 *
 * \li	'dctx' is a valid decompression context.
 *
 * Ensures:
 *
 *	If result is success:
 * \li	 	If 'target' is not NULL, 'name' is attached to it.
 *
 * \li		Uppercase letters are downcased in the copy iff
 *		DNS_NAME_DOWNCASE is set in options.
 *
 * \li		The current location in source is advanced, and the used space
 *		in target is updated.
 *
 * Result:
 * \li	Success
 * \li	Bad Form: Label Length
 * \li	Bad Form: Unknown Label Type
 * \li	Bad Form: Name Length
 * \li	Bad Form: Compression type not allowed
 * \li	Bad Form: Bad compression pointer
 * \li	Bad Form: Input too short
 * \li	Resource Limit: Too many compression pointers
 * \li	Resource Limit: Not enough space in buffer
 */

isc_result_t
dns_name_towire(const dns_name_t *name, dns_compress_t *cctx,
	        isc_buffer_t *target);
/*%<
 * Convert 'name' into wire format, compressing it as specified by the
 * compression context 'cctx', and storing the result in 'target'.
 *
 * Notes:
 * \li	If the compression context allows global compression, then the
 *	global compression table may be updated.
 *
 * Requires:
 * \li	'name' is a valid name
 *
 * \li	dns_name_countlabels(name) > 0
 *
 * \li	dns_name_isabsolute(name) == TRUE
 *
 * \li	target is a valid buffer.
 *
 * \li	Any offsets specified in a global compression table are valid
 *	for buffer.
 *
 * Ensures:
 *
 *	If the result is success:
 *
 * \li		The used space in target is updated.
 *
 * Returns:
 * \li	Success
 * \li	Resource Limit: Not enough space in buffer
 */

isc_result_t
dns_name_fromtext(dns_name_t *name, isc_buffer_t *source,
		  dns_name_t *origin, unsigned int options,
		  isc_buffer_t *target);
/*%<
 * Convert the textual representation of a DNS name at source
 * into uncompressed wire form stored in target.
 *
 * Notes:
 * \li	Relative domain names will have 'origin' appended to them
 *	unless 'origin' is NULL, in which case relative domain names
 *	will remain relative.
 *
 * \li	If DNS_NAME_DOWNCASE is set in 'options', any uppercase letters
 *	in 'source' will be downcased when they are copied into 'target'.
 *
 * Requires:
 *
 * \li	'name' is a valid name.
 *
 * \li	'source' is a valid buffer.
 *
 * \li	'target' is a valid buffer or 'target' is NULL and 'name' has
 *	a dedicated buffer.
 *
 * Ensures:
 *
 *	If result is success:
 * \li	 	If 'target' is not NULL, 'name' is attached to it.
 *
 * \li		Uppercase letters are downcased in the copy iff
 *		DNS_NAME_DOWNCASE is set in 'options'.
 *
 * \li		The current location in source is advanced, and the used space
 *		in target is updated.
 *
 * Result:
 *\li	#ISC_R_SUCCESS
 *\li	#DNS_R_EMPTYLABEL
 *\li	#DNS_R_LABELTOOLONG
 *\li	#DNS_R_BADESCAPE
 *\li	(#DNS_R_BADBITSTRING: should not be returned)
 *\li	(#DNS_R_BITSTRINGTOOLONG: should not be returned)
 *\li	#DNS_R_BADDOTTEDQUAD
 *\li	#ISC_R_NOSPACE
 *\li	#ISC_R_UNEXPECTEDEND
 */

isc_result_t
dns_name_totext(dns_name_t *name, isc_boolean_t omit_final_dot,
		isc_buffer_t *target);
/*%<
 * Convert 'name' into text format, storing the result in 'target'.
 *
 * Notes:
 *\li	If 'omit_final_dot' is true, then the final '.' in absolute
 *	names other than the root name will be omitted.
 *
 *\li	If dns_name_countlabels == 0, the name will be "@@", representing the
 *	current origin as described by RFC1035.
 *
 *\li	The name is not NUL terminated.
 *
 * Requires:
 *
 *\li	'name' is a valid name
 *
 *\li	'target' is a valid buffer.
 *
 *\li	if dns_name_isabsolute == FALSE, then omit_final_dot == FALSE
 *
 * Ensures:
 *
 *\li	If the result is success:
 *		the used space in target is updated.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOSPACE
 */

#define DNS_NAME_MAXTEXT 1023
/*%<
 * The maximum length of the text representation of a domain
 * name as generated by dns_name_totext().  This does not
 * include space for a terminating NULL.
 *
 * This definition is conservative - the actual maximum 
 * is 1004, derived as follows:
 *
 *   A backslash-decimal escaped character takes 4 bytes.
 *   A wire-encoded name can be up to 255 bytes and each
 *   label is one length byte + at most 63 bytes of data.
 *   Maximizing the label lengths gives us a name of
 *   three 63-octet labels, one 61-octet label, and the
 *   root label:
 *
 *      1 + 63 + 1 + 63 + 1 + 63 + 1 + 61 + 1 = 255
 *
 *   When printed, this is (3 * 63 + 61) * 4
 *   bytes for the escaped label data + 4 bytes for the
 *   dot terminating each label = 1004 bytes total.
 */

isc_result_t
dns_name_tofilenametext(dns_name_t *name, isc_boolean_t omit_final_dot,
			isc_buffer_t *target);
/*%<
 * Convert 'name' into an alternate text format appropriate for filenames,
 * storing the result in 'target'.  The name data is downcased, guaranteeing
 * that the filename does not depend on the case of the converted name.
 *
 * Notes:
 *\li	If 'omit_final_dot' is true, then the final '.' in absolute
 *	names other than the root name will be omitted.
 *
 *\li	The name is not NUL terminated.
 *
 * Requires:
 *
 *\li	'name' is a valid absolute name
 *
 *\li	'target' is a valid buffer.
 *
 * Ensures:
 *
 *\li	If the result is success:
 *		the used space in target is updated.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOSPACE
 */

isc_result_t
dns_name_downcase(dns_name_t *source, dns_name_t *name,
		  isc_buffer_t *target);
/*%<
 * Downcase 'source'.
 *
 * Requires:
 *
 *\li	'source' and 'name' are valid names.
 *
 *\li	If source == name, then
 *		'source' must not be read-only
 *
 *\li	Otherwise,
 *		'target' is a valid buffer or 'target' is NULL and
 *		'name' has a dedicated buffer.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOSPACE
 *
 * Note: if source == name, then the result will always be ISC_R_SUCCESS.
 */

isc_result_t
dns_name_concatenate(dns_name_t *prefix, dns_name_t *suffix,
		     dns_name_t *name, isc_buffer_t *target);
/*%<
 *	Concatenate 'prefix' and 'suffix'.
 *
 * Requires:
 *
 *\li	'prefix' is a valid name or NULL.
 *
 *\li	'suffix' is a valid name or NULL.
 *
 *\li	'name' is a valid name or NULL.
 *
 *\li	'target' is a valid buffer or 'target' is NULL and 'name' has
 *	a dedicated buffer.
 *
 *\li	If 'prefix' is absolute, 'suffix' must be NULL or the empty name.
 *
 * Ensures:
 *
 *\li	On success,
 *	 	If 'target' is not NULL and 'name' is not NULL, then 'name'
 *		is attached to it.
 *		The used space in target is updated.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOSPACE
 *\li	#DNS_R_NAMETOOLONG
 */

void
dns_name_split(dns_name_t *name, unsigned int suffixlabels,
	       dns_name_t *prefix, dns_name_t *suffix);
/*%<
 *
 * Split 'name' into two pieces on a label boundary.
 *
 * Notes:
 * \li     'name' is split such that 'suffix' holds the most significant
 *      'suffixlabels' labels.  All other labels are stored in 'prefix'. 
 *
 *\li	Copying name data is avoided as much as possible, so 'prefix'
 *	and 'suffix' will end up pointing at the data for 'name'.
 *
 *\li	It is legitimate to pass a 'prefix' or 'suffix' that has
 *	its name data stored someplace other than the dedicated buffer.
 *	This is useful to avoid name copying in the calling function.
 *
 *\li	It is also legitimate to pass a 'prefix' or 'suffix' that is
 *	the same dns_name_t as 'name'.
 *
 * Requires:
 *\li	'name' is a valid name.
 *
 *\li	'suffixlabels' cannot exceed the number of labels in 'name'.
 *
 * \li	'prefix' is a valid name or NULL, and cannot be read-only.
 *
 *\li	'suffix' is a valid name or NULL, and cannot be read-only.
 *
 *\li	If non-NULL, 'prefix' and 'suffix' must have dedicated buffers.
 *
 *\li	'prefix' and 'suffix' cannot point to the same buffer.
 *
 * Ensures:
 *
 *\li	On success:
 *		If 'prefix' is not NULL it will contain the least significant
 *		labels.
 *		If 'suffix' is not NULL it will contain the most significant
 *		labels.  dns_name_countlabels(suffix) will be equal to
 *		suffixlabels.
 *
 *\li	On failure:
 *		Either 'prefix' or 'suffix' is invalidated (depending
 *		on which one the problem was encountered with).
 *
 * Returns:
 *\li	#ISC_R_SUCCESS	No worries.  (This function should always success).
 */

isc_result_t
dns_name_dup(const dns_name_t *source, isc_mem_t *mctx,
	     dns_name_t *target);
/*%<
 * Make 'target' a dynamically allocated copy of 'source'.
 *
 * Requires:
 *
 *\li	'source' is a valid non-empty name.
 *
 *\li	'target' is a valid name that is not read-only.
 *
 *\li	'mctx' is a valid memory context.
 */

isc_result_t
dns_name_dupwithoffsets(dns_name_t *source, isc_mem_t *mctx,
			dns_name_t *target);
/*%<
 * Make 'target' a read-only dynamically allocated copy of 'source'.
 * 'target' will also have a dynamically allocated offsets table.
 *
 * Requires:
 *
 *\li	'source' is a valid non-empty name.
 *
 *\li	'target' is a valid name that is not read-only.
 *
 *\li	'target' has no offsets table.
 *
 *\li	'mctx' is a valid memory context.
 */

void
dns_name_free(dns_name_t *name, isc_mem_t *mctx);
/*%<
 * Free 'name'.
 *
 * Requires:
 *
 *\li	'name' is a valid name created previously in 'mctx' by dns_name_dup().
 *
 *\li	'mctx' is a valid memory context.
 *
 * Ensures:
 *
 *\li	All dynamic resources used by 'name' are freed and the name is
 *	invalidated.
 */

isc_result_t
dns_name_digest(dns_name_t *name, dns_digestfunc_t digest, void *arg);
/*%<
 * Send 'name' in DNSSEC canonical form to 'digest'.
 *
 * Requires:
 *
 *\li	'name' is a valid name.
 *
 *\li	'digest' is a valid dns_digestfunc_t.
 *
 * Ensures:
 *
 *\li	If successful, the DNSSEC canonical form of 'name' will have been
 *	sent to 'digest'.
 *
 *\li	If digest() returns something other than ISC_R_SUCCESS, that result
 *	will be returned as the result of dns_name_digest().
 *
 * Returns:
 *
 *\li	#ISC_R_SUCCESS
 *
 *\li	Many other results are possible if not successful.
 *
 */

isc_boolean_t
dns_name_dynamic(dns_name_t *name);
/*%<
 * Returns whether there is dynamic memory associated with this name.
 *
 * Requires:
 *
 *\li	'name' is a valid name.
 *
 * Returns:
 *
 *\li	'ISC_TRUE' if the name is dynamic othewise 'ISC_FALSE'.
 */

isc_result_t
dns_name_print(dns_name_t *name, FILE *stream);
/*%<
 * Print 'name' on 'stream'.
 *
 * Requires:
 *
 *\li	'name' is a valid name.
 *
 *\li	'stream' is a valid stream.
 *
 * Returns:
 *
 *\li	#ISC_R_SUCCESS
 *
 *\li	Any error that dns_name_totext() can return.
 */

void
dns_name_format(dns_name_t *name, char *cp, unsigned int size);
/*%<
 * Format 'name' as text appropriate for use in log messages.
 *
 * Store the formatted name at 'cp', writing no more than
 * 'size' bytes.  The resulting string is guaranteed to be
 * null terminated.
 *
 * The formatted name will have a terminating dot only if it is
 * the root.
 *
 * This function cannot fail, instead any errors are indicated
 * in the returned text.
 *
 * Requires:
 *
 *\li	'name' is a valid name.
 *
 *\li	'cp' points a valid character array of size 'size'.
 *
 *\li	'size' > 0.
 *
 */

isc_result_t
dns_name_settotextfilter(dns_name_totextfilter_t proc);
/*%<
 * Set / clear a thread specific function 'proc' to be called at the
 * end of dns_name_totext().
 *
 * Note: Under Windows you need to call "dns_name_settotextfilter(NULL);"
 * prior to exiting the thread otherwise memory will be leaked.
 * For other platforms, which are pthreads based, this is still a good
 * idea but not required.
 *
 * Returns
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_UNEXPECTED
 */

#define DNS_NAME_FORMATSIZE (DNS_NAME_MAXTEXT + 1)
/*%<
 * Suggested size of buffer passed to dns_name_format().
 * Includes space for the terminating NULL.
 */

isc_result_t
dns_name_copy(dns_name_t *source, dns_name_t *dest, isc_buffer_t *target);
/*%<
 * Makes 'dest' refer to a copy of the name in 'source'.  The data are
 * either copied to 'target' or the dedicated buffer in 'dest'.
 *
 * Requires:
 * \li	'source' is a valid name.
 *
 * \li	'dest' is an initialized name with a dedicated buffer.
 *
 * \li	'target' is NULL or an initialized buffer.
 *
 * \li	Either dest has a dedicated buffer or target != NULL.
 *
 * Ensures:
 *
 *\li	On success, the used space in target is updated.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOSPACE
 */

isc_boolean_t
dns_name_ishostname(const dns_name_t *name, isc_boolean_t wildcard);
/*%<
 * Return if 'name' is a valid hostname.  RFC 952 / RFC 1123.
 * If 'wildcard' is ISC_TRUE then allow the first label of name to
 * be a wildcard.
 * The root is also accepted.
 *
 * Requires:
 *	'name' to be valid.
 */
 

isc_boolean_t
dns_name_ismailbox(const dns_name_t *name);
/*%<
 * Return if 'name' is a valid mailbox.  RFC 821.
 *
 * Requires:
 * \li	'name' to be valid.
 */

isc_boolean_t
dns_name_internalwildcard(const dns_name_t *name);
/*%<
 * Return if 'name' contains a internal wildcard name.
 *
 * Requires:
 * \li	'name' to be valid.
 */

void
dns_name_destroy(void);
/*%<
 * Cleanup dns_name_settotextfilter() / dns_name_totext() state.
 *
 * This should be called as part of the final cleanup process.
 *
 * Note: dns_name_settotextfilter(NULL); should be called for all
 * threads which have called dns_name_settotextfilter() with a
 * non-NULL argument prior to calling dns_name_destroy();
 */

ISC_LANG_ENDDECLS

/*
 *** High Peformance Macros
 ***/

/*
 * WARNING:  Use of these macros by applications may require recompilation
 *           of the application in some situations where calling the function
 *           would not.
 *
 * WARNING:  No assertion checking is done for these macros.
 */

#define DNS_NAME_INIT(n, o) \
do { \
	(n)->magic = DNS_NAME_MAGIC; \
	(n)->ndata = NULL; \
	(n)->length = 0; \
	(n)->labels = 0; \
	(n)->attributes = 0; \
	(n)->offsets = (o); \
	(n)->buffer = NULL; \
	ISC_LINK_INIT((n), link); \
	ISC_LIST_INIT((n)->list); \
} while (0)

#define DNS_NAME_RESET(n) \
do { \
	(n)->ndata = NULL; \
	(n)->length = 0; \
	(n)->labels = 0; \
	(n)->attributes &= ~DNS_NAMEATTR_ABSOLUTE; \
	if ((n)->buffer != NULL) \
		isc_buffer_clear((n)->buffer); \
} while (0)

#define DNS_NAME_SETBUFFER(n, b) \
	(n)->buffer = (b)

#define DNS_NAME_ISABSOLUTE(n) \
	(((n)->attributes & DNS_NAMEATTR_ABSOLUTE) != 0 ? ISC_TRUE : ISC_FALSE)

#define DNS_NAME_COUNTLABELS(n) \
	((n)->labels)

#define DNS_NAME_TOREGION(n, r) \
do { \
	(r)->base = (n)->ndata; \
	(r)->length = (n)->length; \
} while (0)

#define DNS_NAME_SPLIT(n, l, p, s) \
do { \
	dns_name_t *_n = (n); \
	dns_name_t *_p = (p); \
	dns_name_t *_s = (s); \
	unsigned int _l = (l); \
	if (_p != NULL) \
		dns_name_getlabelsequence(_n, 0, _n->labels - _l, _p); \
	if (_s != NULL) \
		dns_name_getlabelsequence(_n, _n->labels - _l, _l, _s); \
} while (0)

#ifdef DNS_NAME_USEINLINE

#define dns_name_init(n, o)		DNS_NAME_INIT(n, o)
#define dns_name_reset(n)		DNS_NAME_RESET(n)
#define dns_name_setbuffer(n, b)	DNS_NAME_SETBUFFER(n, b)
#define dns_name_countlabels(n)		DNS_NAME_COUNTLABELS(n)
#define dns_name_isabsolute(n)		DNS_NAME_ISABSOLUTE(n)
#define dns_name_toregion(n, r)		DNS_NAME_TOREGION(n, r)
#define dns_name_split(n, l, p, s)	DNS_NAME_SPLIT(n, l, p, s)

#endif /* DNS_NAME_USEINLINE */

#endif /* DNS_NAME_H */
@


1.5
log
@resolve conflicts and regen configure script
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: name.h,v 1.95.2.3.2.14 2006/03/02 00:37:20 marka Exp $ */
d27 2
a28 3
/*
 * DNS Names and Labels
 *
d47 1
a47 1
 *	Clients of this module must impose any required synchronization.
d50 1
a50 1
 *	This module deals with low-level byte streams.  Errors in any of
d54 1
a54 1
 *	None.
d58 1
a58 1
 *	*** WARNING ***
d60 1
a60 1
 *	dns_name_fromwire() deals with raw network data.  An error in
d64 3
a66 3
 *	RFC 1035
 *	Draft EDNS0 (0)
 *	Draft Binary Labels (2)
d111 1
a111 1
/*
d137 6
a142 6
#define DNS_NAMEATTR_CACHE		0x0100		/* Used by resolver. */
#define DNS_NAMEATTR_ANSWER		0x0200		/* Used by resolver. */
#define DNS_NAMEATTR_NCACHE		0x0400		/* Used by resolver. */
#define DNS_NAMEATTR_CHAINING		0x0800		/* Used by resolver. */
#define DNS_NAMEATTR_CHASE		0x1000		/* Used by resolver. */
#define DNS_NAMEATTR_WILDCARD		0x2000		/* Used by server. */
d145 5
a149 3
#define DNS_NAME_CHECKNAMES		0x0002		/* Used by rdata. */
#define DNS_NAME_CHECKNAMESFAIL		0x0004		/* Used by rdata. */
#define DNS_NAME_CHECKREVERSE		0x0008		/* Used by rdata. */
d154 1
a154 1
/*
d159 9
d174 1
a174 1
/*
d178 1
a178 1
 *	'offsets' is never required to be non-NULL, but specifying a
d183 1
a183 1
 *	'name' is not NULL and points to a struct dns_name.
d185 1
a185 1
 *	offsets == NULL or offsets is a dns_offsets_t.
d188 3
a190 3
 *	'name' is a valid name.
 *	dns_name_countlabels(name) == 0
 *	dns_name_isabsolute(name) == ISC_FALSE
d195 1
a195 1
/*
d199 1
a199 1
 *	This function distinguishes itself from dns_name_init() in two
d202 1
a202 1
 *	+ If any buffer is associated with 'name' (via dns_name_setbuffer()
d206 1
a206 1
 *	+ Of the attributes associated with 'name', all are retained except
d210 1
a210 1
 *	'name' is a valid name.
d213 3
a215 3
 *	'name' is a valid name.
 *	dns_name_countlabels(name) == 0
 *	dns_name_isabsolute(name) == ISC_FALSE
d220 1
a220 1
/*
d224 1
a224 1
 *	'name' is a valid name.
d227 1
a227 1
 *	If assertion checking is enabled, future attempts to use 'name'
d230 1
a230 1
 *	If the name had a dedicated buffer, that association is ended.
d240 1
a240 1
/*
d244 1
a244 1
 *	Specification of a target buffer in dns_name_fromwire(),
d248 1
a248 1
 *	The caller must not write to buffer until the name has been
d251 1
a251 1
 *	If buffer is NULL and the name previously had a dedicated buffer,
d257 1
a257 1
 *	'name' is a valid name.
d259 1
a259 1
 *	'buffer' is a valid binary buffer and 'name' doesn't have a
d265 1
a265 1
/*
d269 1
a269 1
 *	'name' is a valid name.
d272 2
a273 2
 *	ISC_TRUE	'name' has a dedicated buffer.
 *	ISC_FALSE	'name' does not have a dedicated buffer.
a275 1

d282 1
a282 1
/*
d286 1
a286 1
 *	'name' is a valid name
d289 2
a290 2
 *	TRUE		The last label in 'name' is the root label.
 *	FALSE		The last label in 'name' is not the root label.
d295 1
a295 1
/*
d299 1
a299 1
 *	'name' is a valid name
d301 1
a301 1
 *	dns_name_countlabels(name) > 0
d304 2
a305 2
 *	TRUE		The least significant label of 'name' is '*'.
 *	FALSE		The least significant label of 'name' is not '*'.
d310 1
a310 1
/*
d317 1
a317 1
 *	'name' is a valid name
d320 1
a320 1
 *	A hash value
d325 1
a325 1
/*
d333 1
a333 1
 *	'name' is a valid name
d336 1
a336 1
 *	A hash value
d341 1
a341 1
/*
d349 1
a349 1
 *	'name' is a valid name
d352 1
a352 1
 *	A hash value
d355 1
a355 1
/***
d362 1
a362 1
/*
d373 1
a373 1
 *	'name1' is a valid name
d375 1
a375 1
 *	dns_name_countlabels(name1) > 0
d377 1
a377 1
 *	'name2' is a valid name
d379 1
a379 1
 *	dns_name_countlabels(name2) > 0
d381 1
a381 1
 *	orderp and nlabelsp are valid pointers.
d383 1
a383 1
 *	Either name1 is absolute and name2 is absolute, or neither is.
d387 1
a387 1
 *	*orderp is < 0 if name1 < name2, 0 if name1 = name2, > 0 if
d390 1
a390 1
 *	*nlabelsp is the number of common significant labels.
d393 1
a393 1
 *	dns_namereln_none		There's no hierarchical relationship
d395 1
a395 1
 *	dns_namereln_contains		name1 properly contains name2; i.e.
d397 3
a399 3
 *	dns_namereln_subdomain		name1 is a proper subdomain of name2.
 *	dns_namereln_equal		name1 and name2 are equal.
 *	dns_namereln_commonancestor	name1 and name2 share a common
d405 1
a405 1
/*
d415 1
a415 1
 *	'name1' is a valid name
d417 1
a417 1
 *	'name2' is a valid name
d419 1
a419 1
 *	Either name1 is absolute and name2 is absolute, or neither is.
d422 3
a424 3
 *	< 0		'name1' is less than 'name2'
 *	0		'name1' is equal to 'name2'
 *	> 0		'name1' is greater than 'name2'
d429 1
a429 1
/*
d433 1
a433 1
 *	Because it only needs to test for equality, dns_name_equal() can be
d436 1
a436 1
 *	Offsets tables are not used in the comparision.
d438 1
a438 1
 * 	It makes no sense for one of the names to be relative and the
d444 1
a444 1
 *	'name1' is a valid name
d446 1
a446 1
 *	'name2' is a valid name
d448 1
a448 1
 *	Either name1 is absolute and name2 is absolute, or neither is.
d451 8
a458 2
 *	ISC_TRUE	'name1' and 'name2' are equal
 *	ISC_FALSE	'name1' and 'name2' are not equal
d463 1
a463 1
/*
d468 1
a468 1
 *	'name1' is a valid absolute name
d470 1
a470 1
 *	dns_name_countlabels(name1) > 0
d472 1
a472 1
 *	'name2' is a valid absolute name
d474 1
a474 1
 *	dns_name_countlabels(name2) > 0
d477 3
a479 3
 *	< 0		'name1' is less than 'name2'
 *	0		'name1' is equal to 'name2'
 *	> 0		'name1' is greater than 'name2'
d484 1
a484 1
/*
d488 1
a488 1
 *	name1 is a subdomain of name2 if name1 is contained in name2, or
d491 1
a491 1
 *	It makes no sense for one of the names to be relative and the
d497 1
a497 1
 *	'name1' is a valid name
d499 1
a499 1
 *	'name2' is a valid name
d501 1
a501 1
 *	Either name1 is absolute and name2 is absolute, or neither is.
d504 2
a505 2
 *	TRUE		'name1' is a subdomain of 'name2'
 *	FALSE		'name1' is not a subdomain of 'name2'
d510 1
a510 1
/*
d514 1
a514 1
 *	name matches the wildcard specified in wname if all labels
d518 1
a518 1
 *	It makes no sense for one of the names to be relative and the
d524 1
a524 1
 *	'name' is a valid name
d526 1
a526 1
 *	dns_name_countlabels(name) > 0
d528 1
a528 1
 *	'wname' is a valid name
d530 1
a530 1
 *	dns_name_countlabels(wname) > 0
d532 1
a532 1
 *	dns_name_iswildcard(wname) is true
d534 1
a534 1
 *	Either name is absolute and wname is absolute, or neither is.
d537 2
a538 2
 *	TRUE		'name' matches the wildcard specified in 'wname'
 *	FALSE		'name' does not match the wildcard specified in 'wname'
d547 1
a547 1
/*
d551 1
a551 1
 *	In this case, as in other places, a 'label' is an ordinary label.
d554 1
a554 1
 *	'name' is a valid name
d557 1
a557 1
 *	The result is <= 128.
d560 1
a560 1
 *	The number of labels in 'name'.
d565 1
a565 1
/*
d569 1
a569 1
 *	Numbering starts at 0.
d571 1
a571 1
 *	Given "rc.vix.com.", the label 0 is "rc", and label 3 is the
d574 1
a574 1
 *	'label' refers to the same memory as 'name', so 'name' must not
d578 1
a578 1
 *	n < dns_name_countlabels(name)
d584 1
a584 1
/*
d589 1
a589 1
 *	Numbering starts at 0.
d591 1
a591 1
 *	Given "rc.vix.com.", the label 0 is "rc", and label 3 is the
d594 1
a594 1
 *	'target' refers to the same memory as 'source', so 'source'
d598 1
a598 1
 *	'source' and 'target' are valid names.
d600 1
a600 1
 *	first < dns_name_countlabels(name)
d602 1
a602 1
 *	first + n <= dns_name_countlabels(name)
d608 1
a608 1
/*
d613 1
a613 1
 *	'target' refers to the same memory as 'source', so 'source'
d616 1
a616 1
 *	This call is functionally equivalent to:
d618 1
d622 1
d629 1
a629 1
 *	'source' is a valid name.
d631 1
a631 1
 *	'target' is a valid name that is not read-only.
d640 1
a640 1
/*
d644 1
a644 1
 *	If the conversion encounters a root label before the end of the
d649 1
a649 1
 *	The data in 'r' is a sequence of one or more type 00 or type 01000001
d655 1
a655 1
/*
d660 1
a660 1
 *	'name' is a valid name.
d662 1
a662 1
 *	'r' is a valid region.
d669 1
a669 1
/*
d674 1
a674 1
 *	Decompression policy is controlled by 'dctx'.
d676 1
a676 1
 *	If DNS_NAME_DOWNCASE is set, any uppercase letters in 'source' will be
d681 1
a681 1
 *	*** WARNING ***
d683 1
a683 1
 *	This routine will often be used when 'source' contains raw network
d689 1
a689 1
 *	'name' is a valid name.
d691 1
a691 1
 *	'source' is a valid buffer and the first byte of the active
d694 1
a694 1
 *	'target' is a valid buffer or 'target' is NULL and 'name' has
d697 1
a697 1
 *	'dctx' is a valid decompression context.
d702 1
a702 1
 *	 	If 'target' is not NULL, 'name' is attached to it.
d704 1
a704 1
 *		Uppercase letters are downcased in the copy iff
d707 1
a707 1
 *		The current location in source is advanced, and the used space
d711 9
a719 9
 *	Success
 *	Bad Form: Label Length
 *	Bad Form: Unknown Label Type
 *	Bad Form: Name Length
 *	Bad Form: Compression type not allowed
 *	Bad Form: Bad compression pointer
 *	Bad Form: Input too short
 *	Resource Limit: Too many compression pointers
 *	Resource Limit: Not enough space in buffer
d724 2
a725 2
		isc_buffer_t *target);
/*
d730 1
a730 1
 *	If the compression context allows global compression, then the
d734 1
a734 1
 *	'name' is a valid name
d736 1
a736 1
 *	dns_name_countlabels(name) > 0
d738 1
a738 1
 *	dns_name_isabsolute(name) == TRUE
d740 1
a740 1
 *	target is a valid buffer.
d742 1
a742 1
 *	Any offsets specified in a global compression table are valid
d749 1
a749 1
 *		The used space in target is updated.
d752 2
a753 2
 *	Success
 *	Resource Limit: Not enough space in buffer
d760 1
a760 1
/*
d765 1
a765 1
 *	Relative domain names will have 'origin' appended to them
d769 1
a769 1
 *	If DNS_NAME_DOWNCASE is set in 'options', any uppercase letters
d774 1
a774 1
 *	'name' is a valid name.
d776 1
a776 1
 *	'source' is a valid buffer.
d778 1
a778 1
 *	'target' is a valid buffer or 'target' is NULL and 'name' has
d784 1
a784 1
 *	 	If 'target' is not NULL, 'name' is attached to it.
d786 1
a786 1
 *		Uppercase letters are downcased in the copy iff
d789 1
a789 1
 *		The current location in source is advanced, and the used space
d793 9
a801 9
 *	ISC_R_SUCCESS
 *	DNS_R_EMPTYLABEL
 *	DNS_R_LABELTOOLONG
 *	DNS_R_BADESCAPE
 *	(DNS_R_BADBITSTRING: should not be returned)
 *	(DNS_R_BITSTRINGTOOLONG: should not be returned)
 *	DNS_R_BADDOTTEDQUAD
 *	ISC_R_NOSPACE
 *	ISC_R_UNEXPECTEDEND
d807 1
a807 1
/*
d811 1
a811 1
 *	If 'omit_final_dot' is true, then the final '.' in absolute
d814 2
a815 2
 *	If dns_name_countlabels == 0, the name will be "@@", representing the
 *	current origin as described by RFC 1035.
d817 1
a817 1
 *	The name is not NUL terminated.
d821 1
a821 1
 *	'name' is a valid name
d823 1
a823 1
 *	'target' is a valid buffer.
d825 1
a825 1
 *	if dns_name_isabsolute == FALSE, then omit_final_dot == FALSE
d829 2
a830 3
 *	If the result is success:
 *
 *		The used space in target is updated.
d833 2
a834 2
 *	ISC_R_SUCCESS
 *	ISC_R_NOSPACE
d838 1
a838 1
/*
d863 1
a863 1
/*
d869 1
a869 1
 *	If 'omit_final_dot' is true, then the final '.' in absolute
d872 1
a872 1
 *	The name is not NUL terminated.
d876 1
a876 1
 *	'name' is a valid absolute name
d878 1
a878 1
 *	'target' is a valid buffer.
d882 2
a883 3
 *	If the result is success:
 *
 *		The used space in target is updated.
d886 2
a887 2
 *	ISC_R_SUCCESS
 *	ISC_R_NOSPACE
d893 1
a893 1
/*
d898 1
a898 3
 *	'source' and 'name' are valid names.
 *
 *	If source == name, then
d900 1
d903 1
a903 2
 *	Otherwise,
 *
d908 2
a909 2
 *	ISC_R_SUCCESS
 *	ISC_R_NOSPACE
d917 1
a917 1
/*
d922 1
a922 1
 *	'prefix' is a valid name or NULL.
d924 1
a924 1
 *	'suffix' is a valid name or NULL.
d926 1
a926 1
 *	'name' is a valid name or NULL.
d928 1
a928 1
 *	'target' is a valid buffer or 'target' is NULL and 'name' has
d931 1
a931 1
 *	If 'prefix' is absolute, 'suffix' must be NULL or the empty name.
d935 1
a935 1
 *	On success,
a937 1
 *
d941 3
a943 3
 *	ISC_R_SUCCESS
 *	ISC_R_NOSPACE
 *	DNS_R_NAMETOOLONG
d949 1
a949 1
/*
d954 1
a954 1
 *      'name' is split such that 'suffix' holds the most significant
d957 1
a957 1
 *	Copying name data is avoided as much as possible, so 'prefix'
d960 1
a960 1
 *	It is legitimate to pass a 'prefix' or 'suffix' that has
d964 1
a964 1
 *	It is also legitimate to pass a 'prefix' or 'suffix' that is
d968 1
a968 1
 *	'name' is a valid name.
d970 1
a970 1
 * 	'suffixlabels' cannot exceed the number of labels in 'name'.
d972 1
a972 1
 *	'prefix' is a valid name or NULL, and cannot be read-only.
d974 1
a974 1
 *	'suffix' is a valid name or NULL, and cannot be read-only.
d976 1
a976 1
 *	If non-NULL, 'prefix' and 'suffix' must have dedicated buffers.
d978 1
a978 1
 *	'prefix' and 'suffix' cannot point to the same buffer.
d982 1
a982 1
 *	On success:
a984 1
 *
d989 1
a989 1
 *	On failure:
d994 1
a994 1
 *	ISC_R_SUCCESS	No worries.  (This function should always success).
d998 3
a1000 2
dns_name_dup(const dns_name_t *source, isc_mem_t *mctx, dns_name_t *target);
/*
d1005 1
a1005 1
 *	'source' is a valid non-empty name.
d1007 1
a1007 1
 *	'target' is a valid name that is not read-only.
d1009 1
a1009 1
 *	'mctx' is a valid memory context.
d1015 1
a1015 1
/*
d1021 1
a1021 1
 *	'source' is a valid non-empty name.
d1023 1
a1023 1
 *	'target' is a valid name that is not read-only.
d1025 1
a1025 1
 *	'target' has no offsets table.
d1027 1
a1027 1
 *	'mctx' is a valid memory context.
d1032 1
a1032 1
/*
d1037 1
a1037 1
 *	'name' is a valid name created previously in 'mctx' by dns_name_dup().
d1039 1
a1039 1
 *	'mctx' is a valid memory context.
d1043 1
a1043 1
 *	All dynamic resources used by 'name' are freed and the name is
d1049 1
a1049 1
/*
d1054 1
a1054 1
 *	'name' is a valid name.
d1056 1
a1056 1
 *	'digest' is a valid dns_digestfunc_t.
d1060 1
a1060 1
 *	If successful, the DNSSEC canonical form of 'name' will have been
d1063 1
a1063 1
 *	If digest() returns something other than ISC_R_SUCCESS, that result
d1068 1
a1068 1
 *	ISC_R_SUCCESS
d1070 1
a1070 1
 *	Many other results are possible if not successful.
d1076 1
a1076 1
/*
d1081 1
a1081 1
 *	'name' is a valid name.
d1085 1
a1085 1
 *	'ISC_TRUE' if the name is dynamic othewise 'ISC_FALSE'.
d1090 1
a1090 1
/*
d1095 1
a1095 1
 *	'name' is a valid name.
d1097 1
a1097 1
 *	'stream' is a valid stream.
d1101 1
a1101 1
 *	ISC_R_SUCCESS
d1103 1
a1103 1
 *	Any error that dns_name_totext() can return.
d1108 1
a1108 1
/*
d1123 1
a1123 1
 *	'name' is a valid name.
d1125 1
a1125 1
 *	'cp' points a valid character array of size 'size'.
d1127 1
a1127 1
 *	'size' > 0.
d1131 16
d1148 1
a1148 1
/*
d1155 1
a1155 1
/*
d1160 1
a1160 1
 * 	'source' is a valid name.
d1162 1
a1162 1
 * 	'dest' is an initialized name with a dedicated buffer.
d1164 1
a1164 1
 * 	'target' is NULL or an initialized buffer.
d1166 1
a1166 1
 * 	Either dest has a dedicated buffer or target != NULL.
d1170 1
a1170 1
 *	On success, the used space in target is updated.
d1173 2
a1174 2
 *	ISC_R_SUCCESS
 *	ISC_R_NOSPACE
d1179 1
a1179 1
/*
d1192 1
a1192 1
/*
d1196 22
a1217 1
 *	'name' to be valid.
d1222 1
a1222 1
/***
@


1.4
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: name.h,v 1.95.2.3.2.12 2004/09/08 00:29:34 marka Exp $ */
a345 16
unsigned int
dns_fullname_hash(dns_name_t *name, isc_boolean_t case_sensitive);
/*
 * Provide a hash value for 'name'.  Unlike dns_name_hash(), this function
 * always takes into account of the entire name to calculate the hash value.
 *
 * Note: if 'case_sensitive' is ISC_FALSE, then names which differ only in
 * case will have the same hash value.
 *
 * Requires:
 *	'name' is a valid name
 *
 * Returns:
 *	A hash value
 */

d592 1
a592 1
dns_name_clone(dns_name_t *source, dns_name_t *target);
d706 2
a707 1
dns_name_towire(dns_name_t *name, dns_compress_t *cctx, isc_buffer_t *target);
d987 1
a987 1
dns_name_dup(dns_name_t *source, isc_mem_t *mctx, dns_name_t *target);
@


1.3
log
@resolve conflicts
@
text
@d18 1
a18 1
/* $ISC: name.h,v 1.95.2.3.2.11 2004/09/01 05:19:59 marka Exp $ */
d579 1
a579 1
 *	n < dns_label_countlabels(name)
d601 1
a601 1
 *	first < dns_label_countlabels(name)
d603 1
a603 1
 *	first + n <= dns_label_countlabels(name)
d620 1
a620 1
 *					  dns_label_countlabels(source),
@


1.2
log
@update to BIND v9.2.3. ok todd@@
@
text
@d2 1
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: name.h,v 1.95.2.4 2003/10/09 07:32:39 marka Exp $ */
d90 1
a90 1
 ***** label of either type 00 (ordinary) or type 01000001 (bitstring).
a92 70
/***
 *** Extended Label Types
 ***/

#define DNS_LABELTYPE_BITSTRING		0x41

/***
 *** Properties
 ***/

dns_labeltype_t
dns_label_type(dns_label_t *label);
/*
 * Get the type of 'label'.
 *
 * Requires:
 *	'label' is a valid label (i.e. not NULL, points to a
 *	struct dns_label)
 *	'label' is a type 00 or type 01000001 label (i.e. not compressed).
 *
 * Returns:
 *	dns_labeltype_ordinary		type 00 label
 *	dns_labeltype_bitstring		type 01000001 label
 */

/***
 *** Bitstring Labels
 ***/

unsigned int
dns_label_countbits(dns_label_t *label);
/*
 * The number of bits in a bitstring label.
 *
 * Requires:
 *	'label' is a valid label
 *
 *	dns_label_type(label) == dns_labeltype_bitstring
 *
 * Ensures:
 *	Result is <= 256.
 *
 * Returns:
 *	The number of bits in the bitstring label.
 */

dns_bitlabel_t
dns_label_getbit(dns_label_t *label, unsigned int n);
/*
 * The 'n'th most significant bit of 'label'.
 *
 * Notes:
 *	Numbering starts at 0.
 *
 * Require:
 *	n < dns_label_countbits(label)
 *
 * Returns:
 *	dns_bitlabel_0		The bit was 0.
 *	dns_bitlabel_1		The bit was 1.
 */

/***
 *** Note
 ***
 *** Some provision still needs to be made for splitting bitstring labels.
 ***/



d97 3
a99 3
 ***** or more DNS wire format labels of either type 00 (ordinary) or type
 ***** 01000001 (bitstring).  Note that all names are not required to end
 ***** with the root label, as they are in the actual DNS wire protocol.
d143 6
d151 1
a151 1
extern dns_name_t *dns_wildcardname;
d299 2
a300 2
isc_boolean_t
dns_name_requiresedns(const dns_name_t *name);
d302 4
a305 1
 * Does 'name' require EDNS for transmission?
d310 15
a324 1
 *	dns_name_countlabels(name) > 0
d327 1
a327 2
 *	TRUE		The name requires EDNS to be transmitted.
 *	FALSE		The name does not require EDNS to be transmitted.
d331 1
a331 1
dns_name_hash(dns_name_t *name, isc_boolean_t case_sensitive);
d333 2
a334 1
 * Provide a hash value for 'name'.
d368 1
a368 2
		     int *orderp,
		     unsigned int *nlabelsp, unsigned int *nbitsp);
d388 1
a388 1
 *	orderp, nlabelsp, and nbitsp are valid pointers.
a398 4
 *	If *nbitsp is non-zero, then the least-signficant of the
 *	common significant labels is a bitstring label, and the
 *	two names have *nbitsp significant bits in common.
 *
a541 20
unsigned int
dns_name_depth(const dns_name_t *name);
/*
 * The depth of 'name'.
 *
 * Notes:
 *	The "depth" of a name represents how far down the DNS tree of trees
 *	the name is.  For each wire-encoding label in name, the depth is
 *	increased by 1 for an ordinary label, and by the number of bits in
 *	a bitstring label.
 *
 *	Depth is used when creating or validating DNSSEC signatures.
 *
 * Requires:
 *	'name' is a valid name
 *
 * Returns:
 *	The depth of 'name'.
 */

d552 1
a552 3
 *	In this case, as in other places, a 'label' is an ordinary label
 *	or a bitstring label.  The term is not meant to refer to individual
 *	bit labels.  For that purpose, use dns_name_depth().
d592 3
d638 1
a638 1
dns_name_fromregion(dns_name_t *name, isc_region_t *r);
d666 1
a666 1
		  dns_decompress_t *dctx, isc_boolean_t downcase,
d675 1
a675 1
 *	If 'downcase' is true, any uppercase letters in 'source' will be
d703 2
a704 5
 *		Uppercase letters are downcased in the copy iff. 'downcase' is
 *		true.
 *
 *		Any bitstring labels in source are canonicalized.
 *		(i.e. maximally packed and any padding bits zeroed.)
d756 1
a756 1
		  dns_name_t *origin, isc_boolean_t downcase,
d767 2
a768 2
 *	If 'downcase' is true, any uppercase letters in 'source' will be
 *	downcased when they are copied into 'target'.
d784 2
a785 4
 *		Any bitstring labels in source are canonicalized.
 *
 *		Uppercase letters are downcased in the copy iff. 'downcase' is
 *		true.
d795 2
a796 2
 *	DNS_R_BADBITSTRING
 *	DNS_R_BITSTRINGTOOLONG
a940 2
 *		Any bitstring labels are in canonical form.
 *
d949 2
a950 3
isc_result_t
dns_name_split(dns_name_t *name,
	       unsigned int suffixlabels, unsigned int nbits,
d954 1
a954 1
 * Split 'name' into two pieces on a label or bitlabel boundary.
d958 1
a958 4
 *      'suffixlabels' labels, except that if the least significant
 *      suffix label is a bitstring label, then only the 'nbits' most
 *      significant bits of that label are included in 'suffix'.  All 
 *      other labels and bits are stored in 'prefix'.
d961 1
a961 4
 *	and 'suffix' will usually end up pointing at the data for 'name',
 *	except when 'nbits' > 0.  The name data is copied to the
 *	the dedicated buffers when splitting on bitlabel boundaries
 *	because of the bit fiddling that must be done.
d968 1
a968 2
 *	the same dns_name_t as 'name', but note well the requirement
 *	below if splitting on a bitlabel boundary.
a974 5
 *	'nbits' can be greater than zero only when the least significant
 *	label of 'suffix' is a bitstring label.
 *
 *	'nbits' cannot exceed the number of bits in the bitstring label.
 *
a982 3
 *	If 'nbits' > 0 and 'prefix' and 'suffix' are both non-NULL,
 *	the buffer for 'prefix' cannot be storing the labels for 'name'.
 *
d987 1
a987 1
 *		labels and bits.
d990 2
a991 2
 *		labels and bits.  dns_name_countlabels(suffix) will be
 *		equal to suffixlabels.
d998 1
a998 37
 *	ISC_R_SUCCESS	No worries.
 *	ISC_R_NOSPACE	An attempt was made to split a name on a bitlabel
 *			boundary but either 'prefix' or 'suffix' did not
 *			have enough room to receive the split name.
 */

isc_result_t
dns_name_splitatdepth(dns_name_t *name, unsigned int depth,
		      dns_name_t *prefix, dns_name_t *suffix);
/*
 * Split 'name' into two pieces at a certain depth.
 *
 * Requires:
 *	'name' is a valid non-empty name.
 *
 *	depth > 0
 *
 *	depth <= dns_name_depth(name)
 *
 *	The preconditions of dns_name_split() apply to 'prefix' and 'suffix'.
 *
 * Ensures:
 *
 *	On success:
 *		If 'prefix' is not NULL it will contain the least significant
 *		labels and bits.
 *
 *		If 'suffix' is not NULL it will contain the most significant
 *		labels and bits.  dns_name_countlabels(suffix) will be
 *		equal to suffixlabels.
 *
 *	On failure:
 *		Either 'prefix' or 'suffix' is invalidated (depending
 *		on which one the problem was encountered with).
 *
 * Returns:
 *	The possible result codes are the same as those of dns_name_split().
d1164 22
d1236 1
a1236 1
} while (0);
d1238 11
d1258 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (C) 1998-2002  Internet Software Consortium.
d18 1
a18 1
/* $ISC: name.h,v 1.95.2.2 2002/04/23 02:28:51 marka Exp $ */
d382 16
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1998-2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: name.h,v 1.95.2.3.2.11 2004/09/01 05:19:59 marka Exp $ */
d90 1
a90 1
 ***** label of type 00 (ordinary).
d93 70
d167 3
a169 3
 ***** or more DNS wire format labels of type 00 (ordinary).
 ***** Note that all names are not required to end with the root label,
 ***** as they are in the actual DNS wire protocol.
a212 6
#define DNS_NAMEATTR_WILDCARD		0x2000		/* Used by server. */

#define DNS_NAME_DOWNCASE		0x0001
#define DNS_NAME_CHECKNAMES		0x0002		/* Used by rdata. */
#define DNS_NAME_CHECKNAMESFAIL		0x0004		/* Used by rdata. */
#define DNS_NAME_CHECKREVERSE		0x0008		/* Used by rdata. */
d215 1
a215 1
LIBDNS_EXTERNAL_DATA extern dns_name_t *dns_wildcardname;
d363 2
a364 2
unsigned int
dns_name_hash(dns_name_t *name, isc_boolean_t case_sensitive);
d366 1
a366 4
 * Provide a hash value for 'name'.
 *
 * Note: if 'case_sensitive' is ISC_FALSE, then names which differ only in
 * case will have the same hash value.
d371 1
a371 15
 * Returns:
 *	A hash value
 */

unsigned int
dns_name_fullhash(dns_name_t *name, isc_boolean_t case_sensitive);
/*
 * Provide a hash value for 'name'.  Unlike dns_name_hash(), this function
 * always takes into account of the entire name to calculate the hash value.
 *
 * Note: if 'case_sensitive' is ISC_FALSE, then names which differ only in
 * case will have the same hash value.
 *
 * Requires:
 *	'name' is a valid name
d374 2
a375 1
 *	A hash value
d379 1
a379 1
dns_name_hashbylabel(dns_name_t *name, isc_boolean_t case_sensitive);
d381 1
a381 2
 * Provide a hash value for 'name', where the hash value is the sum
 * of the hash values of each label.
d399 2
a400 1
		     int *orderp, unsigned int *nlabelsp);
d420 1
a420 1
 *	orderp and nlabelsp are valid pointers.
d431 4
d578 20
d608 3
a610 1
 *	In this case, as in other places, a 'label' is an ordinary label.
a649 3
 *	Given "rc.vix.com.", the label 0 is "rc", and label 3 is the
 *	root label.
 *
d693 1
a693 1
dns_name_fromregion(dns_name_t *name, const isc_region_t *r);
d721 1
a721 1
		  dns_decompress_t *dctx, unsigned int options,
d730 1
a730 1
 *	If DNS_NAME_DOWNCASE is set, any uppercase letters in 'source' will be
d758 5
a762 2
 *		Uppercase letters are downcased in the copy iff
 *		DNS_NAME_DOWNCASE is set in options.
d814 1
a814 1
		  dns_name_t *origin, unsigned int options,
d825 2
a826 2
 *	If DNS_NAME_DOWNCASE is set in 'options', any uppercase letters
 *	in 'source' will be downcased when they are copied into 'target'.
d842 4
a845 2
 *		Uppercase letters are downcased in the copy iff
 *		DNS_NAME_DOWNCASE is set in 'options'.
d855 2
a856 2
 *	(DNS_R_BADBITSTRING: should not be returned)
 *	(DNS_R_BITSTRINGTOOLONG: should not be returned)
d1001 2
d1011 3
a1013 2
void
dns_name_split(dns_name_t *name, unsigned int suffixlabels,
d1017 1
a1017 1
 * Split 'name' into two pieces on a label boundary.
d1021 4
a1024 1
 *      'suffixlabels' labels.  All other labels are stored in 'prefix'. 
d1027 4
a1030 1
 *	and 'suffix' will end up pointing at the data for 'name'.
d1037 2
a1038 1
 *	the same dns_name_t as 'name'.
d1045 5
d1058 39
d1101 1
a1101 1
 *		labels.
d1104 2
a1105 2
 *		labels.  dns_name_countlabels(suffix) will be equal to
 *		suffixlabels.
d1112 1
a1112 1
 *	ISC_R_SUCCESS	No worries.  (This function should always success).
a1277 22
isc_boolean_t
dns_name_ishostname(const dns_name_t *name, isc_boolean_t wildcard);
/*
 * Return if 'name' is a valid hostname.  RFC 952 / RFC 1123.
 * If 'wildcard' is ISC_TRUE then allow the first label of name to
 * be a wildcard.
 * The root is also accepted.
 *
 * Requires:
 *	'name' to be valid.
 */
 

isc_boolean_t
dns_name_ismailbox(const dns_name_t *name);
/*
 * Return if 'name' is a valid mailbox.  RFC 821.
 *
 * Requires:
 *	'name' to be valid.
 */

d1328 1
a1328 1
} while (0)
a1329 11
#define DNS_NAME_SPLIT(n, l, p, s) \
do { \
	dns_name_t *_n = (n); \
	dns_name_t *_p = (p); \
	dns_name_t *_s = (s); \
	unsigned int _l = (l); \
	if (_p != NULL) \
		dns_name_getlabelsequence(_n, 0, _n->labels - _l, _p); \
	if (_s != NULL) \
		dns_name_getlabelsequence(_n, _n->labels - _l, _l, _s); \
} while (0)
a1338 1
#define dns_name_split(n, l, p, s)	DNS_NAME_SPLIT(n, l, p, s)
@


1.1.1.3
log
@ISC BIND release 9.3.1. ok deraadt@@
@
text
@d18 1
a18 1
/* $ISC: name.h,v 1.95.2.3.2.12 2004/09/08 00:29:34 marka Exp $ */
d563 1
a563 1
 *	n < dns_name_countlabels(name)
d585 1
a585 1
 *	first < dns_name_countlabels(name)
d587 1
a587 1
 *	first + n <= dns_name_countlabels(name)
d604 1
a604 1
 *					  dns_name_countlabels(source),
@


1.1.1.4
log
@ISC BIND release 9.3.3
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: name.h,v 1.95.2.3.2.14 2006/03/02 00:37:20 marka Exp $ */
d592 1
a592 1
dns_name_clone(const dns_name_t *source, dns_name_t *target);
d706 1
a706 2
dns_name_towire(const dns_name_t *name, dns_compress_t *cctx,
		isc_buffer_t *target);
d986 1
a986 1
dns_name_dup(const dns_name_t *source, isc_mem_t *mctx, dns_name_t *target);
@


1.1.1.5
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: name.h,v 1.107.18.15 2006/03/02 00:37:21 marka Exp $ */
d27 3
a29 2
/*! \file
 * \brief
d48 1
a48 1
 *\li	Clients of this module must impose any required synchronization.
d51 1
a51 1
 *\li	This module deals with low-level byte streams.  Errors in any of
d55 1
a55 1
 *\li	None.
d59 1
a59 1
 *\li	*** WARNING ***
d61 1
a61 1
 *\li	dns_name_fromwire() deals with raw network data.  An error in
d65 3
a67 3
 *\li	RFC1035
 *\li	Draft EDNS0 (0)
 *\li	Draft Binary Labels (2)
d112 1
a112 1
/*%
d138 6
a143 6
#define DNS_NAMEATTR_CACHE		0x0100		/*%< Used by resolver. */
#define DNS_NAMEATTR_ANSWER		0x0200		/*%< Used by resolver. */
#define DNS_NAMEATTR_NCACHE		0x0400		/*%< Used by resolver. */
#define DNS_NAMEATTR_CHAINING		0x0800		/*%< Used by resolver. */
#define DNS_NAMEATTR_CHASE		0x1000		/*%< Used by resolver. */
#define DNS_NAMEATTR_WILDCARD		0x2000		/*%< Used by server. */
d146 3
a148 5
#define DNS_NAME_CHECKNAMES		0x0002		/*%< Used by rdata. */
#define DNS_NAME_CHECKNAMESFAIL		0x0004		/*%< Used by rdata. */
#define DNS_NAME_CHECKREVERSE		0x0008		/*%< Used by rdata. */
#define DNS_NAME_CHECKMX		0x0010		/*%< Used by rdata. */
#define DNS_NAME_CHECKMXFAIL		0x0020		/*%< Used by rdata. */
d153 1
a153 1
/*%
a157 9
/*
 * Text output filter procedure.
 * 'target' is the buffer to be converted.  The region to be converted
 * is from 'buffer'->base + 'used_org' to the end of the used region.
 */
typedef isc_result_t (*dns_name_totextfilter_t)(isc_buffer_t *target,
						unsigned int used_org,
						isc_boolean_t absolute);

d164 1
a164 1
/*%<
d168 1
a168 1
 * \li	'offsets' is never required to be non-NULL, but specifying a
d173 1
a173 1
 * \li	'name' is not NULL and points to a struct dns_name.
d175 1
a175 1
 * \li	offsets == NULL or offsets is a dns_offsets_t.
d178 3
a180 3
 * \li	'name' is a valid name.
 * \li	dns_name_countlabels(name) == 0
 * \li	dns_name_isabsolute(name) == ISC_FALSE
d185 1
a185 1
/*%<
d189 1
a189 1
 * \li	This function distinguishes itself from dns_name_init() in two
d192 1
a192 1
 * \li	+ If any buffer is associated with 'name' (via dns_name_setbuffer()
d196 1
a196 1
 * \li	+ Of the attributes associated with 'name', all are retained except
d200 1
a200 1
 * \li	'name' is a valid name.
d203 3
a205 3
 * \li	'name' is a valid name.
 * \li	dns_name_countlabels(name) == 0
 * \li	dns_name_isabsolute(name) == ISC_FALSE
d210 1
a210 1
/*%<
d214 1
a214 1
 * \li	'name' is a valid name.
d217 1
a217 1
 * \li	If assertion checking is enabled, future attempts to use 'name'
d220 1
a220 1
 * \li	If the name had a dedicated buffer, that association is ended.
d230 1
a230 1
/*%<
d234 1
a234 1
 * \li	Specification of a target buffer in dns_name_fromwire(),
d238 1
a238 1
 * \li	The caller must not write to buffer until the name has been
d241 1
a241 1
 * \li	If buffer is NULL and the name previously had a dedicated buffer,
d247 1
a247 1
 * \li	'name' is a valid name.
d249 1
a249 1
 * \li	'buffer' is a valid binary buffer and 'name' doesn't have a
d255 1
a255 1
/*%<
d259 1
a259 1
 * \li	'name' is a valid name.
d262 2
a263 2
 * \li	ISC_TRUE	'name' has a dedicated buffer.
 * \li	ISC_FALSE	'name' does not have a dedicated buffer.
d266 1
d273 1
a273 1
/*%<
d277 1
a277 1
 * \li	'name' is a valid name
d280 2
a281 2
 * \li	TRUE		The last label in 'name' is the root label.
 * \li	FALSE		The last label in 'name' is not the root label.
d286 1
a286 1
/*%<
d290 1
a290 1
 * \li	'name' is a valid name
d292 1
a292 1
 * \li	dns_name_countlabels(name) > 0
d295 2
a296 2
 * \li	TRUE		The least significant label of 'name' is '*'.
 * \li	FALSE		The least significant label of 'name' is not '*'.
d301 1
a301 1
/*%<
d308 1
a308 1
 * \li	'name' is a valid name
d311 1
a311 1
 * \li	A hash value
d316 1
a316 1
/*%<
d324 1
a324 1
 *\li	'name' is a valid name
d327 1
a327 1
 *\li	A hash value
d332 1
a332 1
/*%<
d340 1
a340 1
 *\li	'name' is a valid name
d343 1
a343 1
 *\li	A hash value
d346 1
a346 1
/*
d353 1
a353 1
/*%<
d364 1
a364 1
 *\li	'name1' is a valid name
d366 1
a366 1
 *\li	dns_name_countlabels(name1) > 0
d368 1
a368 1
 *\li	'name2' is a valid name
d370 1
a370 1
 *\li	dns_name_countlabels(name2) > 0
d372 1
a372 1
 *\li	orderp and nlabelsp are valid pointers.
d374 1
a374 1
 *\li	Either name1 is absolute and name2 is absolute, or neither is.
d378 1
a378 1
 *\li	*orderp is < 0 if name1 < name2, 0 if name1 = name2, > 0 if
d381 1
a381 1
 *\li	*nlabelsp is the number of common significant labels.
d384 1
a384 1
 *\li	dns_namereln_none		There's no hierarchical relationship
d386 1
a386 1
 *\li	dns_namereln_contains		name1 properly contains name2; i.e.
d388 3
a390 3
 *\li	dns_namereln_subdomain		name1 is a proper subdomain of name2.
 *\li	dns_namereln_equal		name1 and name2 are equal.
 *\li	dns_namereln_commonancestor	name1 and name2 share a common
d396 1
a396 1
/*%<
d406 1
a406 1
 * \li	'name1' is a valid name
d408 1
a408 1
 * \li	'name2' is a valid name
d410 1
a410 1
 * \li	Either name1 is absolute and name2 is absolute, or neither is.
d413 3
a415 3
 * \li	< 0		'name1' is less than 'name2'
 * \li	0		'name1' is equal to 'name2'
 * \li	> 0		'name1' is greater than 'name2'
d420 1
a420 1
/*%<
d424 1
a424 1
 * \li	Because it only needs to test for equality, dns_name_equal() can be
d427 1
a427 1
 * \li	Offsets tables are not used in the comparision.
d429 1
a429 1
 * \li	It makes no sense for one of the names to be relative and the
d435 1
a435 1
 * \li	'name1' is a valid name
d437 1
a437 1
 * \li	'name2' is a valid name
d439 1
a439 1
 * \li	Either name1 is absolute and name2 is absolute, or neither is.
d442 2
a443 8
 * \li	ISC_TRUE	'name1' and 'name2' are equal
 * \li	ISC_FALSE	'name1' and 'name2' are not equal
 */

isc_boolean_t
dns_name_caseequal(const dns_name_t *name1, const dns_name_t *name2);
/*%<
 * Case sensitive version of dns_name_equal().
d448 1
a448 1
/*%<
d453 1
a453 1
 * \li	'name1' is a valid absolute name
d455 1
a455 1
 * \li	dns_name_countlabels(name1) > 0
d457 1
a457 1
 * \li	'name2' is a valid absolute name
d459 1
a459 1
 * \li	dns_name_countlabels(name2) > 0
d462 3
a464 3
 * \li	< 0		'name1' is less than 'name2'
 * \li	0		'name1' is equal to 'name2'
 * \li	> 0		'name1' is greater than 'name2'
d469 1
a469 1
/*%<
d473 1
a473 1
 * \li	name1 is a subdomain of name2 if name1 is contained in name2, or
d476 1
a476 1
 * \li	It makes no sense for one of the names to be relative and the
d482 1
a482 1
 * \li	'name1' is a valid name
d484 1
a484 1
 * \li	'name2' is a valid name
d486 1
a486 1
 * \li	Either name1 is absolute and name2 is absolute, or neither is.
d489 2
a490 2
 * \li	TRUE		'name1' is a subdomain of 'name2'
 * \li	FALSE		'name1' is not a subdomain of 'name2'
d495 1
a495 1
/*%<
d499 1
a499 1
 * \li	name matches the wildcard specified in wname if all labels
d503 1
a503 1
 * \li	It makes no sense for one of the names to be relative and the
d509 1
a509 1
 * \li	'name' is a valid name
d511 1
a511 1
 * \li	dns_name_countlabels(name) > 0
d513 1
a513 1
 * \li	'wname' is a valid name
d515 1
a515 1
 * \li	dns_name_countlabels(wname) > 0
d517 1
a517 1
 * \li	dns_name_iswildcard(wname) is true
d519 1
a519 1
 * \li	Either name is absolute and wname is absolute, or neither is.
d522 2
a523 2
 * \li	TRUE		'name' matches the wildcard specified in 'wname'
 * \li	FALSE		'name' does not match the wildcard specified in 'wname'
d532 1
a532 1
/*%<
d536 1
a536 1
 * \li	In this case, as in other places, a 'label' is an ordinary label.
d539 1
a539 1
 * \li	'name' is a valid name
d542 1
a542 1
 * \li	The result is <= 128.
d545 1
a545 1
 * \li	The number of labels in 'name'.
d550 1
a550 1
/*%<
d554 1
a554 1
 * \li	Numbering starts at 0.
d556 1
a556 1
 * \li	Given "rc.vix.com.", the label 0 is "rc", and label 3 is the
d559 1
a559 1
 * \li	'label' refers to the same memory as 'name', so 'name' must not
d563 1
a563 1
 * \li	n < dns_name_countlabels(name)
d569 1
a569 1
/*%<
d574 1
a574 1
 * \li	Numbering starts at 0.
d576 1
a576 1
 * \li	Given "rc.vix.com.", the label 0 is "rc", and label 3 is the
d579 1
a579 1
 * \li	'target' refers to the same memory as 'source', so 'source'
d583 1
a583 1
 * \li	'source' and 'target' are valid names.
d585 1
a585 1
 * \li	first < dns_name_countlabels(name)
d587 1
a587 1
 * \li	first + n <= dns_name_countlabels(name)
d593 1
a593 1
/*%<
d598 1
a598 1
 * \li	'target' refers to the same memory as 'source', so 'source'
d601 1
a601 1
 * \li	This call is functionally equivalent to:
a602 1
 * \code
a605 1
 * \endcode
d612 1
a612 1
 * \li	'source' is a valid name.
d614 1
a614 1
 * \li	'target' is a valid name that is not read-only.
d623 1
a623 1
/*%<
d627 1
a627 1
 * \li	If the conversion encounters a root label before the end of the
d632 1
a632 1
 * \li	The data in 'r' is a sequence of one or more type 00 or type 01000001
d638 1
a638 1
/*%<
d643 1
a643 1
 * \li	'name' is a valid name.
d645 1
a645 1
 * \li	'r' is a valid region.
d652 1
a652 1
/*%<
d657 1
a657 1
 * \li	Decompression policy is controlled by 'dctx'.
d659 1
a659 1
 * \li	If DNS_NAME_DOWNCASE is set, any uppercase letters in 'source' will be
d664 1
a664 1
 * \li	*** WARNING ***
d666 1
a666 1
 * \li	This routine will often be used when 'source' contains raw network
d672 1
a672 1
 * \li	'name' is a valid name.
d674 1
a674 1
 * \li	'source' is a valid buffer and the first byte of the active
d677 1
a677 1
 * \li	'target' is a valid buffer or 'target' is NULL and 'name' has
d680 1
a680 1
 * \li	'dctx' is a valid decompression context.
d685 1
a685 1
 * \li	 	If 'target' is not NULL, 'name' is attached to it.
d687 1
a687 1
 * \li		Uppercase letters are downcased in the copy iff
d690 1
a690 1
 * \li		The current location in source is advanced, and the used space
d694 9
a702 9
 * \li	Success
 * \li	Bad Form: Label Length
 * \li	Bad Form: Unknown Label Type
 * \li	Bad Form: Name Length
 * \li	Bad Form: Compression type not allowed
 * \li	Bad Form: Bad compression pointer
 * \li	Bad Form: Input too short
 * \li	Resource Limit: Too many compression pointers
 * \li	Resource Limit: Not enough space in buffer
d707 2
a708 2
	        isc_buffer_t *target);
/*%<
d713 1
a713 1
 * \li	If the compression context allows global compression, then the
d717 1
a717 1
 * \li	'name' is a valid name
d719 1
a719 1
 * \li	dns_name_countlabels(name) > 0
d721 1
a721 1
 * \li	dns_name_isabsolute(name) == TRUE
d723 1
a723 1
 * \li	target is a valid buffer.
d725 1
a725 1
 * \li	Any offsets specified in a global compression table are valid
d732 1
a732 1
 * \li		The used space in target is updated.
d735 2
a736 2
 * \li	Success
 * \li	Resource Limit: Not enough space in buffer
d743 1
a743 1
/*%<
d748 1
a748 1
 * \li	Relative domain names will have 'origin' appended to them
d752 1
a752 1
 * \li	If DNS_NAME_DOWNCASE is set in 'options', any uppercase letters
d757 1
a757 1
 * \li	'name' is a valid name.
d759 1
a759 1
 * \li	'source' is a valid buffer.
d761 1
a761 1
 * \li	'target' is a valid buffer or 'target' is NULL and 'name' has
d767 1
a767 1
 * \li	 	If 'target' is not NULL, 'name' is attached to it.
d769 1
a769 1
 * \li		Uppercase letters are downcased in the copy iff
d772 1
a772 1
 * \li		The current location in source is advanced, and the used space
d776 9
a784 9
 *\li	#ISC_R_SUCCESS
 *\li	#DNS_R_EMPTYLABEL
 *\li	#DNS_R_LABELTOOLONG
 *\li	#DNS_R_BADESCAPE
 *\li	(#DNS_R_BADBITSTRING: should not be returned)
 *\li	(#DNS_R_BITSTRINGTOOLONG: should not be returned)
 *\li	#DNS_R_BADDOTTEDQUAD
 *\li	#ISC_R_NOSPACE
 *\li	#ISC_R_UNEXPECTEDEND
d790 1
a790 1
/*%<
d794 1
a794 1
 *\li	If 'omit_final_dot' is true, then the final '.' in absolute
d797 2
a798 2
 *\li	If dns_name_countlabels == 0, the name will be "@@", representing the
 *	current origin as described by RFC1035.
d800 1
a800 1
 *\li	The name is not NUL terminated.
d804 1
a804 1
 *\li	'name' is a valid name
d806 1
a806 1
 *\li	'target' is a valid buffer.
d808 1
a808 1
 *\li	if dns_name_isabsolute == FALSE, then omit_final_dot == FALSE
d812 3
a814 2
 *\li	If the result is success:
 *		the used space in target is updated.
d817 2
a818 2
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOSPACE
d822 1
a822 1
/*%<
d847 1
a847 1
/*%<
d853 1
a853 1
 *\li	If 'omit_final_dot' is true, then the final '.' in absolute
d856 1
a856 1
 *\li	The name is not NUL terminated.
d860 1
a860 1
 *\li	'name' is a valid absolute name
d862 1
a862 1
 *\li	'target' is a valid buffer.
d866 3
a868 2
 *\li	If the result is success:
 *		the used space in target is updated.
d871 2
a872 2
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOSPACE
d878 1
a878 1
/*%<
d883 3
a885 1
 *\li	'source' and 'name' are valid names.
a886 1
 *\li	If source == name, then
d889 2
a890 1
 *\li	Otherwise,
d895 2
a896 2
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOSPACE
d904 1
a904 1
/*%<
d909 1
a909 1
 *\li	'prefix' is a valid name or NULL.
d911 1
a911 1
 *\li	'suffix' is a valid name or NULL.
d913 1
a913 1
 *\li	'name' is a valid name or NULL.
d915 1
a915 1
 *\li	'target' is a valid buffer or 'target' is NULL and 'name' has
d918 1
a918 1
 *\li	If 'prefix' is absolute, 'suffix' must be NULL or the empty name.
d922 1
a922 1
 *\li	On success,
d925 1
d929 3
a931 3
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOSPACE
 *\li	#DNS_R_NAMETOOLONG
d937 1
a937 1
/*%<
d942 1
a942 1
 * \li     'name' is split such that 'suffix' holds the most significant
d945 1
a945 1
 *\li	Copying name data is avoided as much as possible, so 'prefix'
d948 1
a948 1
 *\li	It is legitimate to pass a 'prefix' or 'suffix' that has
d952 1
a952 1
 *\li	It is also legitimate to pass a 'prefix' or 'suffix' that is
d956 1
a956 1
 *\li	'name' is a valid name.
d958 1
a958 1
 *\li	'suffixlabels' cannot exceed the number of labels in 'name'.
d960 1
a960 1
 * \li	'prefix' is a valid name or NULL, and cannot be read-only.
d962 1
a962 1
 *\li	'suffix' is a valid name or NULL, and cannot be read-only.
d964 1
a964 1
 *\li	If non-NULL, 'prefix' and 'suffix' must have dedicated buffers.
d966 1
a966 1
 *\li	'prefix' and 'suffix' cannot point to the same buffer.
d970 1
a970 1
 *\li	On success:
d973 1
d978 1
a978 1
 *\li	On failure:
d983 1
a983 1
 *\li	#ISC_R_SUCCESS	No worries.  (This function should always success).
d987 2
a988 3
dns_name_dup(const dns_name_t *source, isc_mem_t *mctx,
	     dns_name_t *target);
/*%<
d993 1
a993 1
 *\li	'source' is a valid non-empty name.
d995 1
a995 1
 *\li	'target' is a valid name that is not read-only.
d997 1
a997 1
 *\li	'mctx' is a valid memory context.
d1003 1
a1003 1
/*%<
d1009 1
a1009 1
 *\li	'source' is a valid non-empty name.
d1011 1
a1011 1
 *\li	'target' is a valid name that is not read-only.
d1013 1
a1013 1
 *\li	'target' has no offsets table.
d1015 1
a1015 1
 *\li	'mctx' is a valid memory context.
d1020 1
a1020 1
/*%<
d1025 1
a1025 1
 *\li	'name' is a valid name created previously in 'mctx' by dns_name_dup().
d1027 1
a1027 1
 *\li	'mctx' is a valid memory context.
d1031 1
a1031 1
 *\li	All dynamic resources used by 'name' are freed and the name is
d1037 1
a1037 1
/*%<
d1042 1
a1042 1
 *\li	'name' is a valid name.
d1044 1
a1044 1
 *\li	'digest' is a valid dns_digestfunc_t.
d1048 1
a1048 1
 *\li	If successful, the DNSSEC canonical form of 'name' will have been
d1051 1
a1051 1
 *\li	If digest() returns something other than ISC_R_SUCCESS, that result
d1056 1
a1056 1
 *\li	#ISC_R_SUCCESS
d1058 1
a1058 1
 *\li	Many other results are possible if not successful.
d1064 1
a1064 1
/*%<
d1069 1
a1069 1
 *\li	'name' is a valid name.
d1073 1
a1073 1
 *\li	'ISC_TRUE' if the name is dynamic othewise 'ISC_FALSE'.
d1078 1
a1078 1
/*%<
d1083 1
a1083 1
 *\li	'name' is a valid name.
d1085 1
a1085 1
 *\li	'stream' is a valid stream.
d1089 1
a1089 1
 *\li	#ISC_R_SUCCESS
d1091 1
a1091 1
 *\li	Any error that dns_name_totext() can return.
d1096 1
a1096 1
/*%<
d1111 1
a1111 1
 *\li	'name' is a valid name.
d1113 1
a1113 1
 *\li	'cp' points a valid character array of size 'size'.
d1115 1
a1115 1
 *\li	'size' > 0.
a1118 16
isc_result_t
dns_name_settotextfilter(dns_name_totextfilter_t proc);
/*%<
 * Set / clear a thread specific function 'proc' to be called at the
 * end of dns_name_totext().
 *
 * Note: Under Windows you need to call "dns_name_settotextfilter(NULL);"
 * prior to exiting the thread otherwise memory will be leaked.
 * For other platforms, which are pthreads based, this is still a good
 * idea but not required.
 *
 * Returns
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_UNEXPECTED
 */

d1120 1
a1120 1
/*%<
d1127 1
a1127 1
/*%<
d1132 1
a1132 1
 * \li	'source' is a valid name.
d1134 1
a1134 1
 * \li	'dest' is an initialized name with a dedicated buffer.
d1136 1
a1136 1
 * \li	'target' is NULL or an initialized buffer.
d1138 1
a1138 1
 * \li	Either dest has a dedicated buffer or target != NULL.
d1142 1
a1142 1
 *\li	On success, the used space in target is updated.
d1145 2
a1146 2
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOSPACE
d1151 1
a1151 1
/*%<
d1164 1
a1164 1
/*%<
d1168 1
a1168 22
 * \li	'name' to be valid.
 */

isc_boolean_t
dns_name_internalwildcard(const dns_name_t *name);
/*%<
 * Return if 'name' contains a internal wildcard name.
 *
 * Requires:
 * \li	'name' to be valid.
 */

void
dns_name_destroy(void);
/*%<
 * Cleanup dns_name_settotextfilter() / dns_name_totext() state.
 *
 * This should be called as part of the final cleanup process.
 *
 * Note: dns_name_settotextfilter(NULL); should be called for all
 * threads which have called dns_name_settotextfilter() with a
 * non-NULL argument prior to calling dns_name_destroy();
d1173 1
a1173 1
/*
@


