head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.36
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.32
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.34
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.26
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.30
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.28
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.24
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.22
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.20
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.18
	OPENBSD_5_0:1.4.0.16
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.14
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.12
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.8
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.10
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	BIND_9_4_2_P1:1.1.1.3
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	BIND_9_4_2:1.1.1.3
	OPENBSD_4_2:1.3.0.12
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.10
	OPENBSD_4_1_BASE:1.3
	BIND_9_3_4:1.1.1.2
	BIND_9_3_3:1.1.1.2
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	BIND_9_3_2:1.1.1.2
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2007.12.09.13.39.44;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.28.17.14.06;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.18.14.14.07;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.07.20;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.20;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.14;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.09.12.34.46;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.4
log
@resolve conflicts
@
text
@/*
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1998-2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: rdata.h,v 1.60.18.3 2005/05/19 04:59:56 marka Exp $ */

#ifndef DNS_RDATA_H
#define DNS_RDATA_H 1

/*****
 ***** Module Info
 *****/

/*! \file
 * \brief
 * Provides facilities for manipulating DNS rdata, including conversions to
 * and from wire format and text format.
 *
 * Given the large amount of rdata possible in a nameserver, it was important
 * to come up with a very efficient way of storing rdata, but at the same
 * time allow it to be manipulated.
 *
 * The decision was to store rdata in uncompressed wire format,
 * and not to make it a fully abstracted object; i.e. certain parts of the
 * server know rdata is stored that way.  This saves a lot of memory, and
 * makes adding rdata to messages easy.  Having much of the server know
 * the representation would be perilous, and we certainly don't want each
 * user of rdata to be manipulating such a low-level structure.  This is
 * where the rdata module comes in.  The module allows rdata handles to be
 * created and attached to uncompressed wire format regions.  All rdata
 * operations and conversions are done through these handles.
 *
 * Implementation Notes:
 *
 *\li	The routines in this module are expected to be synthesized by the
 *	build process from a set of source files, one per rdata type.  For
 *	portability, it's probably best that the building be done by a C
 *	program.  Adding a new rdata type will be a simple matter of adding
 *	a file to a directory and rebuilding the server.  *All* knowlege of
 *	the format of a particular rdata type is in this file.
 *
 * MP:
 *\li	Clients of this module must impose any required synchronization.
 *
 * Reliability:
 *\li	This module deals with low-level byte streams.  Errors in any of
 *	the functions are likely to crash the server or corrupt memory.
 *
 *\li	Rdata is typed, and the caller must know what type of rdata it has.
 *	A caller that gets this wrong could crash the server.
 *
 *\li	The fromstruct() and tostruct() routines use a void * pointer to
 *	represent the structure.  The caller must ensure that it passes a
 *	pointer to the appropriate type, or the server could crash or memory
 *	could be corrupted.
 *
 * Resources:
 *\li	None.
 *
 * Security:
 *
 *\li	*** WARNING ***
 *	dns_rdata_fromwire() deals with raw network data.  An error in
 *	this routine could result in the failure or hijacking of the server.
 *
 * Standards:
 *\li	RFC1035
 *\li	Draft EDNS0 (0)
 *\li	Draft EDNS1 (0)
 *\li	Draft Binary Labels (2)
 *\li	Draft Local Compression (1)
 *\li	Various RFCs for particular types; these will be documented in the
 *	 sources files of the types.
 *
 */

/***
 *** Imports
 ***/

#include <isc/lang.h>

#include <dns/types.h>
#include <dns/name.h>

ISC_LANG_BEGINDECLS


/***
 *** Types
 ***/

/*%
 ***** An 'rdata' is a handle to a binary region.  The handle has an RR
 ***** class and type, and the data in the binary region is in the format
 ***** of the given class and type.
 *****/
/*%
 * Clients are strongly discouraged from using this type directly, with
 * the exception of the 'link' field which may be used directly for whatever
 * purpose the client desires.
 */
struct dns_rdata {
	unsigned char *			data;
	unsigned int			length;
	dns_rdataclass_t		rdclass;
	dns_rdatatype_t			type;
	unsigned int			flags;
	ISC_LINK(dns_rdata_t)		link;
};

#define DNS_RDATA_INIT { NULL, 0, 0, 0, 0, {(void*)(-1), (void *)(-1)}}

#define DNS_RDATA_UPDATE	0x0001		/*%< update pseudo record */

/*
 * Flags affecting rdata formatting style.  Flags 0xFFFF0000
 * are used by masterfile-level formatting and defined elsewhere.
 * See additional comments at dns_rdata_tofmttext().
 */

/*% Split the rdata into multiple lines to try to keep it
 within the "width". */
#define DNS_STYLEFLAG_MULTILINE		0x00000001U

/*% Output explanatory comments. */
#define DNS_STYLEFLAG_COMMENT		0x00000002U

#define DNS_RDATA_DOWNCASE		DNS_NAME_DOWNCASE
#define DNS_RDATA_CHECKNAMES		DNS_NAME_CHECKNAMES
#define DNS_RDATA_CHECKNAMESFAIL	DNS_NAME_CHECKNAMESFAIL
#define DNS_RDATA_CHECKREVERSE		DNS_NAME_CHECKREVERSE
#define DNS_RDATA_CHECKMX		DNS_NAME_CHECKMX
#define DNS_RDATA_CHECKMXFAIL		DNS_NAME_CHECKMXFAIL

/***
 *** Initialization
 ***/

void
dns_rdata_init(dns_rdata_t *rdata);
/*%<
 * Make 'rdata' empty.
 *
 * Requires:
 *	'rdata' is a valid rdata (i.e. not NULL, points to a struct dns_rdata)
 */

void
dns_rdata_reset(dns_rdata_t *rdata);
/*%<
 * Make 'rdata' empty.
 *
 * Requires:
 *\li	'rdata' is a previously initialized rdata and is not linked.
 */

void
dns_rdata_clone(const dns_rdata_t *src, dns_rdata_t *target);
/*%<
 * Clone 'target' from 'src'.
 *
 * Requires:
 *\li	'src' to be initialized.
 *\li	'target' to be initialized.
 */

/***
 *** Comparisons
 ***/

int
dns_rdata_compare(const dns_rdata_t *rdata1, const dns_rdata_t *rdata2);
/*%<
 * Determine the relative ordering under the DNSSEC order relation of
 * 'rdata1' and 'rdata2'.
 *
 * Requires:
 *
 *\li	'rdata1' is a valid, non-empty rdata
 *
 *\li	'rdata2' is a valid, non-empty rdata
 *
 * Returns:
 *\li	< 0		'rdata1' is less than 'rdata2'
 *\li	0		'rdata1' is equal to 'rdata2'
 *\li	> 0		'rdata1' is greater than 'rdata2'
 */

/***
 *** Conversions
 ***/

void
dns_rdata_fromregion(dns_rdata_t *rdata, dns_rdataclass_t rdclass,
		     dns_rdatatype_t type, isc_region_t *r);
/*%<
 * Make 'rdata' refer to region 'r'.
 *
 * Requires:
 *
 *\li	The data in 'r' is properly formatted for whatever type it is.
 */

void
dns_rdata_toregion(const dns_rdata_t *rdata, isc_region_t *r);
/*%<
 * Make 'r' refer to 'rdata'.
 */

isc_result_t
dns_rdata_fromwire(dns_rdata_t *rdata, dns_rdataclass_t rdclass,
		   dns_rdatatype_t type, isc_buffer_t *source,
		   dns_decompress_t *dctx, unsigned int options,
		   isc_buffer_t *target);
/*%<
 * Copy the possibly-compressed rdata at source into the target region.
 *
 * Notes:
 *\li	Name decompression policy is controlled by 'dctx'.
 *
 *	'options'
 *\li	DNS_RDATA_DOWNCASE	downcase domain names when they are copied
 *				into target.
 *
 * Requires:
 *
 *\li	'rdclass' and 'type' are valid.
 *
 *\li	'source' is a valid buffer, and the active region of 'source'
 *	references the rdata to be processed.
 *
 *\li	'target' is a valid buffer.
 *
 *\li	'dctx' is a valid decompression context.
 *
 * Ensures,
 *	if result is success:
 *	\li 	If 'rdata' is not NULL, it is attached to the target.
 *	\li	The conditions dns_name_fromwire() ensures for names hold
 *		for all names in the rdata.
 *	\li	The current location in source is advanced, and the used space
 *		in target is updated.
 *
 * Result:
 *\li	Success
 *\li	Any non-success status from dns_name_fromwire()
 *\li	Various 'Bad Form' class failures depending on class and type
 *\li	Bad Form: Input too short
 *\li	Resource Limit: Not enough space
 */

isc_result_t
dns_rdata_towire(dns_rdata_t *rdata, dns_compress_t *cctx,
		 isc_buffer_t *target);
/*%<
 * Convert 'rdata' into wire format, compressing it as specified by the
 * compression context 'cctx', and storing the result in 'target'.
 *
 * Notes:
 *\li	If the compression context allows global compression, then the
 *	global compression table may be updated.
 *
 * Requires:
 *\li	'rdata' is a valid, non-empty rdata
 *
 *\li	target is a valid buffer
 *
 *\li	Any offsets specified in a global compression table are valid
 *	for target.
 *
 * Ensures,
 *	if the result is success:
 *	\li	The used space in target is updated.
 *
 * Returns:
 *\li	Success
 *\li	Any non-success status from dns_name_towire()
 *\li	Resource Limit: Not enough space
 */

isc_result_t
dns_rdata_fromtext(dns_rdata_t *rdata, dns_rdataclass_t rdclass,
		   dns_rdatatype_t type, isc_lex_t *lexer, dns_name_t *origin,
		   unsigned int options, isc_mem_t *mctx,
		   isc_buffer_t *target, dns_rdatacallbacks_t *callbacks);
/*%<
 * Convert the textual representation of a DNS rdata into uncompressed wire
 * form stored in the target region.  Tokens constituting the text of the rdata
 * are taken from 'lexer'.
 *
 * Notes:
 *\li	Relative domain names in the rdata will have 'origin' appended to them.
 *	A NULL origin implies "origin == dns_rootname".
 *
 *
 *	'options'
 *\li	DNS_RDATA_DOWNCASE	downcase domain names when they are copied
 *				into target.
 *\li	DNS_RDATA_CHECKNAMES 	perform checknames checks.
 *\li	DNS_RDATA_CHECKNAMESFAIL fail if the checknames check fail.  If
 *				not set a warning will be issued.
 *\li	DNS_RDATA_CHECKREVERSE  this should set if the owner name ends
 *				in IP6.ARPA, IP6.INT or IN-ADDR.ARPA.
 *
 * Requires:
 *
 *\li	'rdclass' and 'type' are valid.
 *
 *\li	'lexer' is a valid isc_lex_t.
 *
 *\li	'mctx' is a valid isc_mem_t.
 *
 *\li	'target' is a valid region.
 *
 *\li	'origin' if non NULL it must be absolute.
 *	
 *\li	'callbacks' to be NULL or callbacks->warn and callbacks->error be
 *	initialized.
 *
 * Ensures, 
 *	if result is success:
 *\li	 	If 'rdata' is not NULL, it is attached to the target.

 *\li		The conditions dns_name_fromtext() ensures for names hold
 *		for all names in the rdata.

 *\li		The used space in target is updated.
 *
 * Result:
 *\li	Success
 *\li	Translated result codes from isc_lex_gettoken
 *\li	Various 'Bad Form' class failures depending on class and type
 *\li	Bad Form: Input too short
 *\li	Resource Limit: Not enough space
 *\li	Resource Limit: Not enough memory
 */

isc_result_t
dns_rdata_totext(dns_rdata_t *rdata, dns_name_t *origin, isc_buffer_t *target);
/*%<
 * Convert 'rdata' into text format, storing the result in 'target'.
 * The text will consist of a single line, with fields separated by
 * single spaces.
 *
 * Notes:
 *\li	If 'origin' is not NULL, then any names in the rdata that are
 *	subdomains of 'origin' will be made relative it.
 *
 *\li	XXX Do we *really* want to support 'origin'?  I'm inclined towards "no"
 *	at the moment.
 *
 * Requires:
 *
 *\li	'rdata' is a valid, non-empty rdata
 *
 *\li	'origin' is NULL, or is a valid name
 *
 *\li	'target' is a valid text buffer
 *
 * Ensures,
 *	if the result is success:
 *
 *	\li	The used space in target is updated.
 *
 * Returns:
 *\li	Success
 *\li	Any non-success status from dns_name_totext()
 *\li	Resource Limit: Not enough space
 */

isc_result_t
dns_rdata_tofmttext(dns_rdata_t *rdata, dns_name_t *origin, unsigned int flags,
		    unsigned int width, char *linebreak, isc_buffer_t *target);
/*%<
 * Like dns_rdata_totext, but do formatted output suitable for
 * database dumps.  This is intended for use by dns_db_dump();
 * library users are discouraged from calling it directly.
 *
 * If (flags & #DNS_STYLEFLAG_MULTILINE) != 0, attempt to stay
 * within 'width' by breaking the text into multiple lines.
 * The string 'linebreak' is inserted between lines, and parentheses
 * are added when necessary.  Because RRs contain unbreakable elements
 * such as domain names whose length is variable, unpredictable, and
 * potentially large, there is no guarantee that the lines will
 * not exceed 'width' anyway.
 *
 * If (flags & #DNS_STYLEFLAG_MULTILINE) == 0, the rdata is always
 * printed as a single line, and no parentheses are used.
 * The 'width' and 'linebreak' arguments are ignored.
 *
 * If (flags & #DNS_STYLEFLAG_COMMENT) != 0, output explanatory
 * comments next to things like the SOA timer fields.  Some
 * comments (e.g., the SOA ones) are only printed when multiline
 * output is selected.
 */

isc_result_t
dns_rdata_fromstruct(dns_rdata_t *rdata, dns_rdataclass_t rdclass,
		     dns_rdatatype_t type, void *source, isc_buffer_t *target);
/*%<
 * Convert the C structure representation of an rdata into uncompressed wire
 * format in 'target'.
 *
 * XXX  Should we have a 'size' parameter as a sanity check on target?
 *
 * Requires:
 *
 *\li	'rdclass' and 'type' are valid.
 *
 *\li	'source' points to a valid C struct for the class and type.
 *
 *\li	'target' is a valid buffer.
 *
 *\li	All structure pointers to memory blocks should be NULL if their
 *	corresponding length values are zero.
 *
 * Ensures,
 *	if result is success:
 *	\li 	If 'rdata' is not NULL, it is attached to the target.
 *
 *	\li	The used space in 'target' is updated.
 *
 * Result:
 *\li	Success
 *\li	Various 'Bad Form' class failures depending on class and type
 *\li	Resource Limit: Not enough space
 */

isc_result_t
dns_rdata_tostruct(dns_rdata_t *rdata, void *target, isc_mem_t *mctx);
/*%<
 * Convert an rdata into its C structure representation.
 *
 * If 'mctx' is NULL then 'rdata' must persist while 'target' is being used.
 *
 * If 'mctx' is non NULL then memory will be allocated if required.
 *
 * Requires:
 *
 *\li	'rdata' is a valid, non-empty rdata.
 *
 *\li	'target' to point to a valid pointer for the type and class.
 *
 * Result:
 *\li	Success
 *\li	Resource Limit: Not enough memory
 */

void
dns_rdata_freestruct(void *source);
/*%<
 * Free dynamic memory attached to 'source' (if any).
 *
 * Requires:
 *
 *\li	'source' to point to the structure previously filled in by
 *	dns_rdata_tostruct().
 */

isc_boolean_t
dns_rdatatype_ismeta(dns_rdatatype_t type);
/*%<
 * Return true iff the rdata type 'type' is a meta-type
 * like ANY or AXFR.
 */

isc_boolean_t
dns_rdatatype_issingleton(dns_rdatatype_t type);
/*%<
 * Return true iff the rdata type 'type' is a singleton type,
 * like CNAME or SOA.
 *
 * Requires:
 * \li	'type' is a valid rdata type.
 *
 */

isc_boolean_t
dns_rdataclass_ismeta(dns_rdataclass_t rdclass);
/*%<
 * Return true iff the rdata class 'rdclass' is a meta-class
 * like ANY or NONE.
 */

isc_boolean_t
dns_rdatatype_isdnssec(dns_rdatatype_t type);
/*%<
 * Return true iff 'type' is one of the DNSSEC
 * rdata types that may exist alongside a CNAME record.
 *
 * Requires:
 * \li	'type' is a valid rdata type.
 */

isc_boolean_t
dns_rdatatype_iszonecutauth(dns_rdatatype_t type);
/*%<
 * Return true iff rdata of type 'type' is considered authoritative
 * data (not glue) in the NSEC chain when it occurs in the parent zone
 * at a zone cut.
 *
 * Requires:
 * \li	'type' is a valid rdata type.
 *
 */

isc_boolean_t
dns_rdatatype_isknown(dns_rdatatype_t type);
/*%<
 * Return true iff the rdata type 'type' is known.
 *
 * Requires:
 * \li	'type' is a valid rdata type.
 *
 */


isc_result_t
dns_rdata_additionaldata(dns_rdata_t *rdata, dns_additionaldatafunc_t add,
			 void *arg);
/*%<
 * Call 'add' for each name and type from 'rdata' which is subject to
 * additional section processing.
 *
 * Requires:
 *
 *\li	'rdata' is a valid, non-empty rdata.
 *
 *\li	'add' is a valid dns_additionalfunc_t.
 *
 * Ensures:
 *
 *\li	If successful, then add() will have been called for each name
 *	and type subject to additional section processing.
 *
 *\li	If add() returns something other than #ISC_R_SUCCESS, that result
 *	will be returned as the result of dns_rdata_additionaldata().
 *
 * Returns:
 *
 *\li	ISC_R_SUCCESS
 *
 *\li	Many other results are possible if not successful.
 */

isc_result_t
dns_rdata_digest(dns_rdata_t *rdata, dns_digestfunc_t digest, void *arg);
/*%<
 * Send 'rdata' in DNSSEC canonical form to 'digest'.
 *
 * Note:
 *\li	'digest' may be called more than once by dns_rdata_digest().  The
 *	concatenation of all the regions, in the order they were given
 *	to 'digest', will be the DNSSEC canonical form of 'rdata'.
 *
 * Requires:
 *
 *\li	'rdata' is a valid, non-empty rdata.
 *
 *\li	'digest' is a valid dns_digestfunc_t.
 *
 * Ensures:
 *
 *\li	If successful, then all of the rdata's data has been sent, in
 *	DNSSEC canonical form, to 'digest'.
 *
 *\li	If digest() returns something other than ISC_R_SUCCESS, that result
 *	will be returned as the result of dns_rdata_digest().
 *
 * Returns:
 *
 *\li	ISC_R_SUCCESS
 *
 *\li	Many other results are possible if not successful.
 */

isc_boolean_t
dns_rdatatype_questiononly(dns_rdatatype_t type);
/*%<
 * Return true iff rdata of type 'type' can only appear in the question
 * section of a properly formatted message.
 *
 * Requires:
 * \li	'type' is a valid rdata type.
 *
 */

isc_boolean_t
dns_rdatatype_notquestion(dns_rdatatype_t type);
/*%<
 * Return true iff rdata of type 'type' can not appear in the question
 * section of a properly formatted message.
 *
 * Requires:
 * \li	'type' is a valid rdata type.
 *
 */

isc_boolean_t
dns_rdatatype_atparent(dns_rdatatype_t type);
/*%<
 * Return true iff rdata of type 'type' should appear at the parent of
 * a zone cut.
 *
 * Requires:
 * \li	'type' is a valid rdata type.
 *
 */

unsigned int
dns_rdatatype_attributes(dns_rdatatype_t rdtype);
/*%<
 * Return attributes for the given type.
 *
 * Requires:
 *\li	'rdtype' are known.
 *
 * Returns:
 *\li	a bitmask consisting of the following flags.
 */

/*% only one may exist for a name */
#define DNS_RDATATYPEATTR_SINGLETON		0x00000001U
/*% requires no other data be present */
#define DNS_RDATATYPEATTR_EXCLUSIVE		0x00000002U
/*% Is a meta type */
#define DNS_RDATATYPEATTR_META			0x00000004U
/*% Is a DNSSEC type, like RRSIG or NSEC */
#define DNS_RDATATYPEATTR_DNSSEC		0x00000008U
/*% Is a zone cut authority type */
#define DNS_RDATATYPEATTR_ZONECUTAUTH		0x00000010U
/*% Is reserved (unusable) */
#define DNS_RDATATYPEATTR_RESERVED		0x00000020U
/*% Is an unknown type */
#define DNS_RDATATYPEATTR_UNKNOWN		0x00000040U
/*% Is META, and can only be in a question section */
#define DNS_RDATATYPEATTR_QUESTIONONLY		0x00000080U
/*% is META, and can NOT be in a question section */
#define DNS_RDATATYPEATTR_NOTQUESTION		0x00000100U
/*% Is present at zone cuts in the parent, not the child */
#define DNS_RDATATYPEATTR_ATPARENT		0x00000200U

dns_rdatatype_t
dns_rdata_covers(dns_rdata_t *rdata);
/*%<
 * Return the rdatatype that this type covers.
 *
 * Requires:
 *\li	'rdata' is a valid, non-empty rdata.
 *
 *\li	'rdata' is a type that covers other rdata types.
 *
 * Returns:
 *\li	The type covered.
 */

isc_boolean_t
dns_rdata_checkowner(dns_name_t* name, dns_rdataclass_t rdclass,
		     dns_rdatatype_t type, isc_boolean_t wildcard);
/*
 * Returns whether this is a valid ownername for this <type,class>.
 * If wildcard is true allow the first label to be a wildcard if
 * appropriate.
 *
 * Requires:
 *	'name' is a valid name.
 */

isc_boolean_t
dns_rdata_checknames(dns_rdata_t *rdata, dns_name_t *owner, dns_name_t *bad);
/*
 * Returns whether 'rdata' contains valid domain names.  The checks are
 * sensitive to the owner name.
 *
 * If 'bad' is non-NULL and a domain name fails the check the
 * the offending name will be return in 'bad' by cloning from
 * the 'rdata' contents.
 *
 * Requires:
 *	'rdata' to be valid.
 *	'owner' to be valid.
 *	'bad'	to be NULL or valid.
 */

ISC_LANG_ENDDECLS

#endif /* DNS_RDATA_H */
@


1.3
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: rdata.h,v 1.51.2.3.2.4 2004/03/08 02:08:01 marka Exp $ */
d27 2
a28 3
/*
 * DNS Rdata
 *
d48 1
a48 1
 *	The routines in this module are expected to be synthesized by the
d56 1
a56 1
 *	Clients of this module must impose any required synchronization.
d59 1
a59 1
 *	This module deals with low-level byte streams.  Errors in any of
d62 1
a62 1
 *	Rdata is typed, and the caller must know what type of rdata it has.
d65 1
a65 1
 *	The fromstruct() and tostruct() routines use a void * pointer to
d71 1
a71 1
 *	None.
d75 1
a75 2
 *	*** WARNING ***
 *
d80 7
a86 7
 *	RFC 1035
 *	Draft EDNS0 (0)
 *	Draft EDNS1 (0)
 *	Draft Binary Labels (2)
 *	Draft Local Compression (1)
 *	<Various RFCs for particular types; these will be documented in the
 *	 sources files of the types.>
a100 7
/*****
 ***** RData
 *****
 ***** An 'rdata' is a handle to a binary region.  The handle has an RR
 ***** class and type, and the data in the binary region is in the format
 ***** of the given class and type.
 *****/
d106 6
a111 1
/*
d127 1
a127 1
#define DNS_RDATA_UPDATE	0x0001		/* update pseudo record */
d135 1
a135 1
/* Split the rdata into multiple lines to try to keep it
d139 1
a139 1
/* Output explanatory comments. */
d146 2
d155 1
a155 1
/*
d164 1
a164 1
/*
d168 1
a168 1
 *	'rdata' is a previously initialized rdata and is not linked.
d173 1
a173 1
/*
d177 2
a178 2
 *	'src' to be initialized.
 *	'target' to be initialized.
d187 1
a187 1
/*
d193 1
a193 1
 *	'rdata1' is a valid, non-empty rdata
d195 1
a195 1
 *	'rdata2' is a valid, non-empty rdata
d198 3
a200 3
 *	< 0		'rdata1' is less than 'rdata2'
 *	0		'rdata1' is equal to 'rdata2'
 *	> 0		'rdata1' is greater than 'rdata2'
d210 1
a210 1
/*
d215 1
a215 1
 *	The data in 'r' is properly formatted for whatever type it is.
d220 1
a220 1
/*
d229 1
a229 1
/*
d233 1
a233 1
 *	Name decompression policy is controlled by 'dctx'.
d236 1
a236 1
 *	DNS_RDATA_DOWNCASE	downcase domain names when they are copied
d241 1
a241 1
 *	'rdclass' and 'type' are valid.
d243 1
a243 1
 *	'source' is a valid buffer, and the active region of 'source'
d246 1
a246 1
 *	'target' is a valid buffer.
d248 1
a248 1
 *	'dctx' is a valid decompression context.
d250 4
a253 6
 * Ensures:
 *
 *	If result is success:
 *	 	If 'rdata' is not NULL, it is attached to the target.
 *
 *		The conditions dns_name_fromwire() ensures for names hold
d255 1
a255 2
 *
 *		The current location in source is advanced, and the used space
d259 5
a263 5
 *	Success
 *	<Any non-success status from dns_name_fromwire()>
 *	<Various 'Bad Form' class failures depending on class and type>
 *	Bad Form: Input too short
 *	Resource Limit: Not enough space
d269 1
a269 1
/*
d274 1
a274 1
 *	If the compression context allows global compression, then the
d278 1
a278 1
 *	'rdata' is a valid, non-empty rdata
d280 1
a280 1
 *	target is a valid buffer
d282 1
a282 1
 *	Any offsets specified in a global compression table are valid
d285 3
a287 3
 * Ensures:
 *	If the result is success:
 *		The used space in target is updated.
d290 3
a292 3
 *	Success
 *	<Any non-success status from dns_name_towire()>
 *	Resource Limit: Not enough space
d300 1
a300 1
/*
d306 1
a306 1
 *	Relative domain names in the rdata will have 'origin' appended to them.
d311 1
a311 1
 *	DNS_RDATA_DOWNCASE	downcase domain names when they are copied
d313 2
a314 2
 *	DNS_RDATA_CHECKNAMES 	perform checknames checks.
 *	DNS_RDATA_CHECKNAMESFAIL fail if the checknames check fail.  If
d316 1
a316 1
 *	DNS_RDATA_CHECKREVERSE  this should set if the owner name ends
d321 1
a321 1
 *	'rdclass' and 'type' are valid.
d323 1
a323 1
 *	'lexer' is a valid isc_lex_t.
d325 1
a325 1
 *	'mctx' is a valid isc_mem_t.
d327 1
a327 1
 *	'target' is a valid region.
d329 1
a329 1
 *	'origin' if non NULL it must be absolute.
d331 1
a331 1
 *	'callbacks' to be NULL or callbacks->warn and callbacks->error be
d334 5
a338 5
 * Ensures:
 *	If result is success:
 *	 	If 'rdata' is not NULL, it is attached to the target.
 *
 *		The conditions dns_name_fromtext() ensures for names hold
d340 2
a341 2
 *
 *		The used space in target is updated.
d344 6
a349 6
 *	Success
 *	<Translated result codes from isc_lex_gettoken>
 *	<Various 'Bad Form' class failures depending on class and type>
 *	Bad Form: Input too short
 *	Resource Limit: Not enough space
 *	Resource Limit: Not enough memory
d354 1
a354 1
/*
d360 1
a360 1
 *	If 'origin' is not NULL, then any names in the rdata that are
d363 1
a363 1
 *	XXX Do we *really* want to support 'origin'?  I'm inclined towards "no"
d368 1
a368 1
 *	'rdata' is a valid, non-empty rdata
d370 1
a370 1
 *	'origin' is NULL, or is a valid name
d372 1
a372 1
 *	'target' is a valid text buffer
d374 2
a375 2
 * Ensures:
 *	If the result is success:
d377 1
a377 1
 *		The used space in target is updated.
d380 3
a382 3
 *	Success
 *	<Any non-success status from dns_name_totext()>
 *	Resource Limit: Not enough space
d388 1
a388 1
/*
d393 1
a393 1
 * If (flags & DNS_STYLEFLAG_MULTILINE) != 0, attempt to stay
d401 1
a401 1
 * If (flags & DNS_STYLEFLAG_MULTILINE) == 0, the rdata is always
d405 1
a405 1
 * If (flags & DNS_STYLEFLAG_COMMENT) != 0, output explanatory
d414 1
a414 1
/*
d422 1
a422 1
 *	'rdclass' and 'type' are valid.
d424 1
a424 1
 *	'source' points to a valid C struct for the class and type.
d426 1
a426 1
 *	'target' is a valid buffer.
d428 1
a428 1
 *	All structure pointers to memory blocks should be NULL if their
d431 3
a433 3
 * Ensures:
 *	If result is success:
 *	 	If 'rdata' is not NULL, it is attached to the target.
d435 1
a435 1
 *		The used space in 'target' is updated.
d438 3
a440 3
 *	Success
 *	<Various 'Bad Form' class failures depending on class and type>
 *	Resource Limit: Not enough space
d445 1
a445 1
/*
d454 1
a454 1
 *	'rdata' is a valid, non-empty rdata.
d456 1
a456 1
 *	'target' to point to a valid pointer for the type and class.
d459 2
a460 2
 *	Success
 *	Resource Limit: Not enough memory
d465 1
a465 1
/*
d470 1
a470 1
 *	'source' to point to the structure previously filled in by
d476 1
a476 1
/*
d483 1
a483 1
/*
d488 1
a488 1
 * 	'type' is a valid rdata type.
d494 1
a494 1
/*
d501 1
a501 1
/*
d506 1
a506 1
 * 	'type' is a valid rdata type.
d511 1
a511 1
/*
d517 1
a517 1
 * 	'type' is a valid rdata type.
d523 1
a523 1
/*
d527 1
a527 1
 * 	'type' is a valid rdata type.
d535 1
a535 1
/*
d541 1
a541 1
 *	'rdata' is a valid, non-empty rdata.
d543 1
a543 1
 *	'add' is a valid dns_additionalfunc_t.
d547 1
a547 1
 *	If successful, then add() will have been called for each name
d550 1
a550 1
 *	If add() returns something other than ISC_R_SUCCESS, that result
d555 1
a555 1
 *	ISC_R_SUCCESS
d557 1
a557 1
 *	Many other results are possible if not successful.
d562 1
a562 1
/*
d566 1
a566 1
 *	'digest' may be called more than once by dns_rdata_digest().  The
d572 1
a572 1
 *	'rdata' is a valid, non-empty rdata.
d574 1
a574 1
 *	'digest' is a valid dns_digestfunc_t.
d578 1
a578 1
 *	If successful, then all of the rdata's data has been sent, in
d581 1
a581 1
 *	If digest() returns something other than ISC_R_SUCCESS, that result
d586 1
a586 1
 *	ISC_R_SUCCESS
d588 1
a588 1
 *	Many other results are possible if not successful.
d593 1
a593 1
/*
d598 1
a598 1
 * 	'type' is a valid rdata type.
d604 1
a604 1
/*
d609 1
a609 1
 * 	'type' is a valid rdata type.
d615 1
a615 1
/*
d620 1
a620 1
 * 	'type' is a valid rdata type.
d626 1
a626 1
/*
d630 1
a630 1
 *	'rdtype' are known.
d633 1
a633 1
 *	a bitmask consisting of the following flags.
d636 1
a636 1
/* only one may exist for a name */
d638 1
a638 1
/* requires no other data be present */
d640 1
a640 1
/* Is a meta type */
d642 1
a642 1
/* Is a DNSSEC type, like RRSIG or NSEC */
d644 1
a644 1
/* Is a zone cut authority type */
d646 1
a646 1
/* Is reserved (unusable) */
d648 1
a648 1
/* Is an unknown type */
d650 1
a650 1
/* Is META, and can only be in a question section */
d652 1
a652 1
/* is META, and can NOT be in a question section */
d654 1
a654 1
/* Is present at zone cuts in the parent, not the child */
d659 1
a659 1
/*
d663 1
a663 1
 *	'rdata' is a valid, non-empty rdata.
d665 1
a665 1
 *	'rdata' is a type that covers other rdata types.
d668 1
a668 1
 *	The type covered.
@


1.2
log
@update to BIND v9.2.3. ok todd@@
@
text
@d2 1
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: rdata.h,v 1.51.2.4 2003/10/09 07:32:39 marka Exp $ */
d99 1
d146 5
d229 1
a229 2
		   dns_decompress_t *dctx,
		   isc_boolean_t downcase,
d237 3
a239 2
 *	If 'downcase' is true, any uppercase letters in domain names in
 * 	'source' will be downcased when they are copied into 'target'.
d303 1
a303 1
		   isc_boolean_t downcase, isc_mem_t *mctx,
d314 9
a322 2
 *	If 'downcase' is true, any uppercase letters in domain names in
 * 	'source' will be downcased when they are copied into 'target'.
d518 1
a518 1
 * data (not glue) in the NXT chain when it occurs in the parent zone
d618 11
d647 1
a647 1
/* Is a DNSSEC type, like SIG or NXT */
d659 2
d674 28
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (C) 1998-2002  Internet Software Consortium.
d18 1
a18 1
/* $ISC: rdata.h,v 1.51.2.2 2002/02/20 02:17:25 marka Exp $ */
a470 4
 *
 * Requires:
 * 	'type' is a valid rdata type.
 *
a488 4
 *
 * Requires:
 * 	'rdclass' is a valid rdata class.
 *
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1998-2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: rdata.h,v 1.51.2.3.2.4 2004/03/08 02:08:01 marka Exp $ */
a98 1
#include <dns/name.h>
a144 5
#define DNS_RDATA_DOWNCASE		DNS_NAME_DOWNCASE
#define DNS_RDATA_CHECKNAMES		DNS_NAME_CHECKNAMES
#define DNS_RDATA_CHECKNAMESFAIL	DNS_NAME_CHECKNAMESFAIL
#define DNS_RDATA_CHECKREVERSE		DNS_NAME_CHECKREVERSE

d223 2
a224 1
		   dns_decompress_t *dctx, unsigned int options,
d232 2
a233 3
 *	'options'
 *	DNS_RDATA_DOWNCASE	downcase domain names when they are copied
 *				into target.
d297 1
a297 1
		   unsigned int options, isc_mem_t *mctx,
d308 2
a309 9
 *
 *	'options'
 *	DNS_RDATA_DOWNCASE	downcase domain names when they are copied
 *				into target.
 *	DNS_RDATA_CHECKNAMES 	perform checknames checks.
 *	DNS_RDATA_CHECKNAMESFAIL fail if the checknames check fail.  If
 *				not set a warning will be issued.
 *	DNS_RDATA_CHECKREVERSE  this should set if the owner name ends
 *				in IP6.ARPA, IP6.INT or IN-ADDR.ARPA.
d471 4
d493 4
d513 1
a513 1
 * data (not glue) in the NSEC chain when it occurs in the parent zone
a612 11
isc_boolean_t
dns_rdatatype_atparent(dns_rdatatype_t type);
/*
 * Return true iff rdata of type 'type' should appear at the parent of
 * a zone cut.
 *
 * Requires:
 * 	'type' is a valid rdata type.
 *
 */

d631 1
a631 1
/* Is a DNSSEC type, like RRSIG or NSEC */
a642 2
/* Is present at zone cuts in the parent, not the child */
#define DNS_RDATATYPEATTR_ATPARENT		0x00000200U
a655 28
 */

isc_boolean_t
dns_rdata_checkowner(dns_name_t* name, dns_rdataclass_t rdclass,
		     dns_rdatatype_t type, isc_boolean_t wildcard);
/*
 * Returns whether this is a valid ownername for this <type,class>.
 * If wildcard is true allow the first label to be a wildcard if
 * appropriate.
 *
 * Requires:
 *	'name' is a valid name.
 */

isc_boolean_t
dns_rdata_checknames(dns_rdata_t *rdata, dns_name_t *owner, dns_name_t *bad);
/*
 * Returns whether 'rdata' contains valid domain names.  The checks are
 * sensitive to the owner name.
 *
 * If 'bad' is non-NULL and a domain name fails the check the
 * the offending name will be return in 'bad' by cloning from
 * the 'rdata' contents.
 *
 * Requires:
 *	'rdata' to be valid.
 *	'owner' to be valid.
 *	'bad'	to be NULL or valid.
@


1.1.1.3
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: rdata.h,v 1.60.18.3 2005/05/19 04:59:56 marka Exp $ */
d27 3
a29 2
/*! \file
 * \brief
d49 1
a49 1
 *\li	The routines in this module are expected to be synthesized by the
d57 1
a57 1
 *\li	Clients of this module must impose any required synchronization.
d60 1
a60 1
 *\li	This module deals with low-level byte streams.  Errors in any of
d63 1
a63 1
 *\li	Rdata is typed, and the caller must know what type of rdata it has.
d66 1
a66 1
 *\li	The fromstruct() and tostruct() routines use a void * pointer to
d72 1
a72 1
 *\li	None.
d76 2
a77 1
 *\li	*** WARNING ***
d82 7
a88 7
 *\li	RFC1035
 *\li	Draft EDNS0 (0)
 *\li	Draft EDNS1 (0)
 *\li	Draft Binary Labels (2)
 *\li	Draft Local Compression (1)
 *\li	Various RFCs for particular types; these will be documented in the
 *	 sources files of the types.
d103 7
d115 1
a115 6
/*%
 ***** An 'rdata' is a handle to a binary region.  The handle has an RR
 ***** class and type, and the data in the binary region is in the format
 ***** of the given class and type.
 *****/
/*%
d131 1
a131 1
#define DNS_RDATA_UPDATE	0x0001		/*%< update pseudo record */
d139 1
a139 1
/*% Split the rdata into multiple lines to try to keep it
d143 1
a143 1
/*% Output explanatory comments. */
a149 2
#define DNS_RDATA_CHECKMX		DNS_NAME_CHECKMX
#define DNS_RDATA_CHECKMXFAIL		DNS_NAME_CHECKMXFAIL
d157 1
a157 1
/*%<
d166 1
a166 1
/*%<
d170 1
a170 1
 *\li	'rdata' is a previously initialized rdata and is not linked.
d175 1
a175 1
/*%<
d179 2
a180 2
 *\li	'src' to be initialized.
 *\li	'target' to be initialized.
d189 1
a189 1
/*%<
d195 1
a195 1
 *\li	'rdata1' is a valid, non-empty rdata
d197 1
a197 1
 *\li	'rdata2' is a valid, non-empty rdata
d200 3
a202 3
 *\li	< 0		'rdata1' is less than 'rdata2'
 *\li	0		'rdata1' is equal to 'rdata2'
 *\li	> 0		'rdata1' is greater than 'rdata2'
d212 1
a212 1
/*%<
d217 1
a217 1
 *\li	The data in 'r' is properly formatted for whatever type it is.
d222 1
a222 1
/*%<
d231 1
a231 1
/*%<
d235 1
a235 1
 *\li	Name decompression policy is controlled by 'dctx'.
d238 1
a238 1
 *\li	DNS_RDATA_DOWNCASE	downcase domain names when they are copied
d243 1
a243 1
 *\li	'rdclass' and 'type' are valid.
d245 1
a245 1
 *\li	'source' is a valid buffer, and the active region of 'source'
d248 1
a248 1
 *\li	'target' is a valid buffer.
d250 1
a250 1
 *\li	'dctx' is a valid decompression context.
d252 6
a257 4
 * Ensures,
 *	if result is success:
 *	\li 	If 'rdata' is not NULL, it is attached to the target.
 *	\li	The conditions dns_name_fromwire() ensures for names hold
d259 2
a260 1
 *	\li	The current location in source is advanced, and the used space
d264 5
a268 5
 *\li	Success
 *\li	Any non-success status from dns_name_fromwire()
 *\li	Various 'Bad Form' class failures depending on class and type
 *\li	Bad Form: Input too short
 *\li	Resource Limit: Not enough space
d274 1
a274 1
/*%<
d279 1
a279 1
 *\li	If the compression context allows global compression, then the
d283 1
a283 1
 *\li	'rdata' is a valid, non-empty rdata
d285 1
a285 1
 *\li	target is a valid buffer
d287 1
a287 1
 *\li	Any offsets specified in a global compression table are valid
d290 3
a292 3
 * Ensures,
 *	if the result is success:
 *	\li	The used space in target is updated.
d295 3
a297 3
 *\li	Success
 *\li	Any non-success status from dns_name_towire()
 *\li	Resource Limit: Not enough space
d305 1
a305 1
/*%<
d311 1
a311 1
 *\li	Relative domain names in the rdata will have 'origin' appended to them.
d316 1
a316 1
 *\li	DNS_RDATA_DOWNCASE	downcase domain names when they are copied
d318 2
a319 2
 *\li	DNS_RDATA_CHECKNAMES 	perform checknames checks.
 *\li	DNS_RDATA_CHECKNAMESFAIL fail if the checknames check fail.  If
d321 1
a321 1
 *\li	DNS_RDATA_CHECKREVERSE  this should set if the owner name ends
d326 1
a326 1
 *\li	'rdclass' and 'type' are valid.
d328 1
a328 1
 *\li	'lexer' is a valid isc_lex_t.
d330 1
a330 1
 *\li	'mctx' is a valid isc_mem_t.
d332 1
a332 1
 *\li	'target' is a valid region.
d334 1
a334 1
 *\li	'origin' if non NULL it must be absolute.
d336 1
a336 1
 *\li	'callbacks' to be NULL or callbacks->warn and callbacks->error be
d339 5
a343 5
 * Ensures, 
 *	if result is success:
 *\li	 	If 'rdata' is not NULL, it is attached to the target.

 *\li		The conditions dns_name_fromtext() ensures for names hold
d345 2
a346 2

 *\li		The used space in target is updated.
d349 6
a354 6
 *\li	Success
 *\li	Translated result codes from isc_lex_gettoken
 *\li	Various 'Bad Form' class failures depending on class and type
 *\li	Bad Form: Input too short
 *\li	Resource Limit: Not enough space
 *\li	Resource Limit: Not enough memory
d359 1
a359 1
/*%<
d365 1
a365 1
 *\li	If 'origin' is not NULL, then any names in the rdata that are
d368 1
a368 1
 *\li	XXX Do we *really* want to support 'origin'?  I'm inclined towards "no"
d373 1
a373 1
 *\li	'rdata' is a valid, non-empty rdata
d375 1
a375 1
 *\li	'origin' is NULL, or is a valid name
d377 1
a377 1
 *\li	'target' is a valid text buffer
d379 2
a380 2
 * Ensures,
 *	if the result is success:
d382 1
a382 1
 *	\li	The used space in target is updated.
d385 3
a387 3
 *\li	Success
 *\li	Any non-success status from dns_name_totext()
 *\li	Resource Limit: Not enough space
d393 1
a393 1
/*%<
d398 1
a398 1
 * If (flags & #DNS_STYLEFLAG_MULTILINE) != 0, attempt to stay
d406 1
a406 1
 * If (flags & #DNS_STYLEFLAG_MULTILINE) == 0, the rdata is always
d410 1
a410 1
 * If (flags & #DNS_STYLEFLAG_COMMENT) != 0, output explanatory
d419 1
a419 1
/*%<
d427 1
a427 1
 *\li	'rdclass' and 'type' are valid.
d429 1
a429 1
 *\li	'source' points to a valid C struct for the class and type.
d431 1
a431 1
 *\li	'target' is a valid buffer.
d433 1
a433 1
 *\li	All structure pointers to memory blocks should be NULL if their
d436 3
a438 3
 * Ensures,
 *	if result is success:
 *	\li 	If 'rdata' is not NULL, it is attached to the target.
d440 1
a440 1
 *	\li	The used space in 'target' is updated.
d443 3
a445 3
 *\li	Success
 *\li	Various 'Bad Form' class failures depending on class and type
 *\li	Resource Limit: Not enough space
d450 1
a450 1
/*%<
d459 1
a459 1
 *\li	'rdata' is a valid, non-empty rdata.
d461 1
a461 1
 *\li	'target' to point to a valid pointer for the type and class.
d464 2
a465 2
 *\li	Success
 *\li	Resource Limit: Not enough memory
d470 1
a470 1
/*%<
d475 1
a475 1
 *\li	'source' to point to the structure previously filled in by
d481 1
a481 1
/*%<
d488 1
a488 1
/*%<
d493 1
a493 1
 * \li	'type' is a valid rdata type.
d499 1
a499 1
/*%<
d506 1
a506 1
/*%<
d511 1
a511 1
 * \li	'type' is a valid rdata type.
d516 1
a516 1
/*%<
d522 1
a522 1
 * \li	'type' is a valid rdata type.
d528 1
a528 1
/*%<
d532 1
a532 1
 * \li	'type' is a valid rdata type.
d540 1
a540 1
/*%<
d546 1
a546 1
 *\li	'rdata' is a valid, non-empty rdata.
d548 1
a548 1
 *\li	'add' is a valid dns_additionalfunc_t.
d552 1
a552 1
 *\li	If successful, then add() will have been called for each name
d555 1
a555 1
 *\li	If add() returns something other than #ISC_R_SUCCESS, that result
d560 1
a560 1
 *\li	ISC_R_SUCCESS
d562 1
a562 1
 *\li	Many other results are possible if not successful.
d567 1
a567 1
/*%<
d571 1
a571 1
 *\li	'digest' may be called more than once by dns_rdata_digest().  The
d577 1
a577 1
 *\li	'rdata' is a valid, non-empty rdata.
d579 1
a579 1
 *\li	'digest' is a valid dns_digestfunc_t.
d583 1
a583 1
 *\li	If successful, then all of the rdata's data has been sent, in
d586 1
a586 1
 *\li	If digest() returns something other than ISC_R_SUCCESS, that result
d591 1
a591 1
 *\li	ISC_R_SUCCESS
d593 1
a593 1
 *\li	Many other results are possible if not successful.
d598 1
a598 1
/*%<
d603 1
a603 1
 * \li	'type' is a valid rdata type.
d609 1
a609 1
/*%<
d614 1
a614 1
 * \li	'type' is a valid rdata type.
d620 1
a620 1
/*%<
d625 1
a625 1
 * \li	'type' is a valid rdata type.
d631 1
a631 1
/*%<
d635 1
a635 1
 *\li	'rdtype' are known.
d638 1
a638 1
 *\li	a bitmask consisting of the following flags.
d641 1
a641 1
/*% only one may exist for a name */
d643 1
a643 1
/*% requires no other data be present */
d645 1
a645 1
/*% Is a meta type */
d647 1
a647 1
/*% Is a DNSSEC type, like RRSIG or NSEC */
d649 1
a649 1
/*% Is a zone cut authority type */
d651 1
a651 1
/*% Is reserved (unusable) */
d653 1
a653 1
/*% Is an unknown type */
d655 1
a655 1
/*% Is META, and can only be in a question section */
d657 1
a657 1
/*% is META, and can NOT be in a question section */
d659 1
a659 1
/*% Is present at zone cuts in the parent, not the child */
d664 1
a664 1
/*%<
d668 1
a668 1
 *\li	'rdata' is a valid, non-empty rdata.
d670 1
a670 1
 *\li	'rdata' is a type that covers other rdata types.
d673 1
a673 1
 *\li	The type covered.
@


