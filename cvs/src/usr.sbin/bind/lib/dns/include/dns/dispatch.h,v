head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.36
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.38
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.34
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.30
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.32
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.24
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.28
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.26
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.22
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.20
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.18
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.16
	OPENBSD_5_0:1.7.0.14
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.12
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.10
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.6
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.8
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	BIND_9_4_2_P1:1.1.1.4
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	BIND_9_4_2:1.1.1.3
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	BIND_9_3_4:1.1.1.2
	BIND_9_3_3:1.1.1.2
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	BIND_9_3_2:1.1.1.2
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.4
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2008.08.04.16.34.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2008.07.09.19.02.52;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.09.13.39.44;	author jakob;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2004.09.28.17.14.06;	author jakob;	state Exp;
branches
	1.4.12.1;
next	1.3;

1.3
date	2003.11.18.14.14.06;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.05.09.18.32;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.07.17;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.17;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.10;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.09.12.34.49;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.07.09.18.44.56;	author jakob;	state Exp;
branches;
next	;

1.4.12.1
date	2008.07.23.17.59.55;	author brad;	state Exp;
branches;
next	;

1.5.2.1
date	2008.07.23.17.39.39;	author brad;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to BIND 9.4.2-P2 and adapt our dynamic select changes.  OK deraadt@@
@
text
@/*
 * Copyright (C) 2004, 2005, 2007, 2008  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1999-2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: dispatch.h,v 1.48.18.5.12.2 2008/07/23 07:28:56 tbox Exp $ */

#ifndef DNS_DISPATCH_H
#define DNS_DISPATCH_H 1

/*****
 ***** Module Info
 *****/

/*! \file
 * \brief
 * DNS Dispatch Management
 * 	Shared UDP and single-use TCP dispatches for queries and responses.
 *
 * MP:
 *
 *\li     	All locking is performed internally to each dispatch.
 * 	Restrictions apply to dns_dispatch_removeresponse().
 *
 * Reliability:
 *
 * Resources:
 *
 * Security:
 *
 *\li	Depends on the isc_socket_t and dns_message_t for prevention of
 *	buffer overruns.
 *
 * Standards:
 *
 *\li	None.
 */

/***
 *** Imports
 ***/

#include <isc/buffer.h>
#include <isc/lang.h>
#include <isc/socket.h>
#include <dns/types.h>

#include <dns/types.h>

ISC_LANG_BEGINDECLS

/*%
 * This event is sent to a task when a response comes in.
 * No part of this structure should ever be modified by the caller,
 * other than parts of the buffer.  The holy parts of the buffer are
 * the base and size of the buffer.  All other parts of the buffer may
 * be used.  On event delivery the used region contains the packet.
 *
 * "id" is the received message id,
 *
 * "addr" is the host that sent it to us,
 *
 * "buffer" holds state on the received data.
 *
 * The "free" routine for this event will clean up itself as well as
 * any buffer space allocated from common pools.
 */

struct dns_dispatchevent {
	ISC_EVENT_COMMON(dns_dispatchevent_t);	/*%< standard event common */
	isc_result_t		result;		/*%< result code */
	isc_int32_t		id;		/*%< message id */
	isc_sockaddr_t		addr;		/*%< address recv'd from */
	struct in6_pktinfo	pktinfo;	/*%< reply info for v6 */
	isc_buffer_t	        buffer;		/*%< data buffer */
	isc_uint32_t		attributes;	/*%< mirrored from socket.h */
};

/*@@{*/
/*%
 * Attributes for added dispatchers.
 *
 * Values with the mask 0xffff0000 are application defined.
 * Values with the mask 0x0000ffff are library defined.
 *
 * Insane values (like setting both TCP and UDP) are not caught.  Don't
 * do that.
 *
 * _PRIVATE
 *	The dispatcher cannot be shared.
 *
 * _TCP, _UDP
 *	The dispatcher is a TCP or UDP socket.
 *
 * _IPV4, _IPV6
 *	The dispatcher uses an ipv4 or ipv6 socket.
 *
 * _NOLISTEN
 *	The dispatcher should not listen on the socket.
 *
 * _MAKEQUERY
 *	The dispatcher can be used to issue queries to other servers, and
 *	accept replies from them.
 *
 * _RANDOMPORT
 *	Allocate UDP port randomly.
 */
#define DNS_DISPATCHATTR_PRIVATE	0x00000001U
#define DNS_DISPATCHATTR_TCP		0x00000002U
#define DNS_DISPATCHATTR_UDP		0x00000004U
#define DNS_DISPATCHATTR_IPV4		0x00000008U
#define DNS_DISPATCHATTR_IPV6		0x00000010U
#define DNS_DISPATCHATTR_NOLISTEN	0x00000020U
#define DNS_DISPATCHATTR_MAKEQUERY	0x00000040U
#define DNS_DISPATCHATTR_CONNECTED	0x00000080U
#define DNS_DISPATCHATTR_RANDOMPORT	0x00000100U
/*@@}*/

isc_result_t
dns_dispatchmgr_create(isc_mem_t *mctx, isc_entropy_t *entropy,
		       dns_dispatchmgr_t **mgrp);
/*%<
 * Creates a new dispatchmgr object.
 *
 * Requires:
 *\li	"mctx" be a valid memory context.
 *
 *\li	mgrp != NULL && *mgrp == NULL
 *
 *\li	"entropy" may be NULL, in which case an insecure random generator
 *	will be used.  If it is non-NULL, it must be a valid entropy
 *	source.
 *
 * Returns:
 *\li	ISC_R_SUCCESS	-- all ok
 *
 *\li	anything else	-- failure
 */


void
dns_dispatchmgr_destroy(dns_dispatchmgr_t **mgrp);
/*%<
 * Destroys the dispatchmgr when it becomes empty.  This could be
 * immediately.
 *
 * Requires:
 *\li	mgrp != NULL && *mgrp is a valid dispatchmgr.
 */


void
dns_dispatchmgr_setblackhole(dns_dispatchmgr_t *mgr, dns_acl_t *blackhole);
/*%<
 * Sets the dispatcher's "blackhole list," a list of addresses that will
 * be ignored by all dispatchers created by the dispatchmgr.
 *
 * Requires:
 * \li	mgrp is a valid dispatchmgr
 * \li	blackhole is a valid acl
 */


dns_acl_t *
dns_dispatchmgr_getblackhole(dns_dispatchmgr_t *mgr);
/*%<
 * Gets a pointer to the dispatcher's current blackhole list,
 * without incrementing its reference count.
 *
 * Requires:
 *\li 	mgr is a valid dispatchmgr
 * Returns:
 *\li	A pointer to the current blackhole list, or NULL.
 */

void
dns_dispatchmgr_setblackportlist(dns_dispatchmgr_t *mgr,
                                 dns_portlist_t *portlist);
/*%<
 * Sets a list of UDP ports that won't be used when creating a udp
 * dispatch with a wildcard port.
 *
 * Requires:
 *\li	mgr is a valid dispatchmgr
 *\li	portlist to be NULL or a valid port list.
 */

dns_portlist_t *
dns_dispatchmgr_getblackportlist(dns_dispatchmgr_t *mgr);
/*%<
 * Return the current port list.
 *
 * Requires:
 *\li	mgr is a valid dispatchmgr
 */



isc_result_t
dns_dispatch_getudp(dns_dispatchmgr_t *mgr, isc_socketmgr_t *sockmgr,
		    isc_taskmgr_t *taskmgr, isc_sockaddr_t *localaddr,
		    unsigned int buffersize,
		    unsigned int maxbuffers, unsigned int maxrequests,
		    unsigned int buckets, unsigned int increment,
		    unsigned int attributes, unsigned int mask,
		    dns_dispatch_t **dispp);
/*%<
 * Attach to existing dns_dispatch_t if one is found with dns_dispatchmgr_find,
 * otherwise create a new UDP dispatch.
 *
 * Requires:
 *\li	All pointer parameters be valid for their respective types.
 *
 *\li	dispp != NULL && *disp == NULL
 *
 *\li	512 <= buffersize <= 64k
 *
 *\li	maxbuffers > 0
 *
 *\li	buckets < 2097169
 *
 *\li	increment > buckets
 *
 *\li	(attributes & DNS_DISPATCHATTR_TCP) == 0
 *
 * Returns:
 *\li	ISC_R_SUCCESS	-- success.
 *
 *\li	Anything else	-- failure.
 */

isc_result_t
dns_dispatch_createtcp(dns_dispatchmgr_t *mgr, isc_socket_t *sock,
		       isc_taskmgr_t *taskmgr, unsigned int buffersize,
		       unsigned int maxbuffers, unsigned int maxrequests,
		       unsigned int buckets, unsigned int increment,
		       unsigned int attributes, dns_dispatch_t **dispp);
/*%<
 * Create a new dns_dispatch and attach it to the provided isc_socket_t.
 *
 * For all dispatches, "buffersize" is the maximum packet size we will
 * accept.
 *
 * "maxbuffers" and "maxrequests" control the number of buffers in the
 * overall system and the number of buffers which can be allocated to
 * requests.
 *
 * "buckets" is the number of buckets to use, and should be prime.
 *
 * "increment" is used in a collision avoidance function, and needs to be
 * a prime > buckets, and not 2.
 *
 * Requires:
 *
 *\li	mgr is a valid dispatch manager.
 *
 *\li	sock is a valid.
 *
 *\li	task is a valid task that can be used internally to this dispatcher.
 *
 * \li	512 <= buffersize <= 64k
 *
 *\li	maxbuffers > 0.
 *
 *\li	maxrequests <= maxbuffers.
 *
 *\li	buckets < 2097169 (the next prime after 65536 * 32)
 *
 *\li	increment > buckets (and prime).
 *
 *\li	attributes includes #DNS_DISPATCHATTR_TCP and does not include
 *	#DNS_DISPATCHATTR_UDP.
 *
 * Returns:
 *\li	ISC_R_SUCCESS	-- success.
 *
 *\li	Anything else	-- failure.
 */

void
dns_dispatch_attach(dns_dispatch_t *disp, dns_dispatch_t **dispp);
/*%<
 * Attach to a dispatch handle.
 *
 * Requires:
 *\li	disp is valid.
 *
 *\li	dispp != NULL && *dispp == NULL
 */

void
dns_dispatch_detach(dns_dispatch_t **dispp);
/*%<
 * Detaches from the dispatch.
 *
 * Requires:
 *\li	dispp != NULL and *dispp be a valid dispatch.
 */

void
dns_dispatch_starttcp(dns_dispatch_t *disp);
/*%<
 * Start processing of a TCP dispatch once the socket connects.
 *
 * Requires:
 *\li	'disp' is valid.
 */

isc_result_t
dns_dispatch_addresponse(dns_dispatch_t *disp, isc_sockaddr_t *dest,
			 isc_task_t *task, isc_taskaction_t action, void *arg,
			 isc_uint16_t *idp, dns_dispentry_t **resp);
/*%<
 * Add a response entry for this dispatch.
 *
 * "*idp" is filled in with the assigned message ID, and *resp is filled in
 * to contain the magic token used to request event flow stop.
 *
 * Arranges for the given task to get a callback for response packets.  When
 * the event is delivered, it must be returned using dns_dispatch_freeevent()
 * or through dns_dispatch_removeresponse() for another to be delivered.
 *
 * Requires:
 *\li	"idp" be non-NULL.
 *
 *\li	"task" "action" and "arg" be set as appropriate.
 *
 *\li	"dest" be non-NULL and valid.
 *
 *\li	"resp" be non-NULL and *resp be NULL
 *
 * Ensures:
 *
 *\li	&lt;id, dest> is a unique tuple.  That means incoming messages
 *	are identifiable.
 *
 * Returns:
 *
 *\li	ISC_R_SUCCESS		-- all is well.
 *\li	ISC_R_NOMEMORY		-- memory could not be allocated.
 *\li	ISC_R_NOMORE		-- no more message ids can be allocated
 *				   for this destination.
 */


void
dns_dispatch_removeresponse(dns_dispentry_t **resp,
			    dns_dispatchevent_t **sockevent);
/*%<
 * Stops the flow of responses for the provided id and destination.
 * If "sockevent" is non-NULL, the dispatch event and associated buffer is
 * also returned to the system.
 *
 * Requires:
 *\li	"resp" != NULL and "*resp" contain a value previously allocated
 *	by dns_dispatch_addresponse();
 *
 *\li	May only be called from within the task given as the 'task' 
 * 	argument to dns_dispatch_addresponse() when allocating '*resp'.
 */


isc_socket_t *
dns_dispatch_getsocket(dns_dispatch_t *disp);
/*%<
 * Return the socket associated with this dispatcher.
 *
 * Requires:
 *\li	disp is valid.
 *
 * Returns:
 *\li	The socket the dispatcher is using.
 */

isc_result_t 
dns_dispatch_getlocaladdress(dns_dispatch_t *disp, isc_sockaddr_t *addrp);
/*%<
 * Return the local address for this dispatch.
 * This currently only works for dispatches using UDP sockets.
 *
 * Requires:
 *\li	disp is valid.
 *\li	addrp to be non null.
 *
 * Returns:
 *\li	ISC_R_SUCCESS	
 *\li	ISC_R_NOTIMPLEMENTED
 */

void
dns_dispatch_cancel(dns_dispatch_t *disp);
/*%<
 * cancel outstanding clients
 *
 * Requires:
 *\li	disp is valid.
 */

void
dns_dispatch_changeattributes(dns_dispatch_t *disp,
			      unsigned int attributes, unsigned int mask);
/*%<
 * Set the bits described by "mask" to the corresponding values in
 * "attributes".
 *
 * That is:
 *
 * \code
 *	new = (old & ~mask) | (attributes & mask)
 * \endcode
 *
 * This function has a side effect when #DNS_DISPATCHATTR_NOLISTEN changes. 
 * When the flag becomes off, the dispatch will start receiving on the
 * corresponding socket.  When the flag becomes on, receive events on the
 * corresponding socket will be canceled.
 *
 * Requires:
 *\li	disp is valid.
 *
 *\li	attributes are reasonable for the dispatch.  That is, setting the UDP
 *	attribute on a TCP socket isn't reasonable.
 */

void
dns_dispatch_importrecv(dns_dispatch_t *disp, isc_event_t *event);
/*%<
 * Inform the dispatcher of a socket receive.  This is used for sockets
 * shared between dispatchers and clients.  If the dispatcher fails to copy
 * or send the event, nothing happens.
 *
 * Requires:
 *\li 	disp is valid, and the attribute DNS_DISPATCHATTR_NOLISTEN is set.
 * 	event != NULL
 */

ISC_LANG_ENDDECLS

#endif /* DNS_DISPATCH_H */
@


1.6
log
@merge and resolve conflicts introduced by 9.4.2-P1
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005, 2007  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: dispatch.h,v 1.48.18.5.12.1 2008/05/22 21:28:06 each Exp $ */
@


1.5
log
@resolve conflicts
@
text
@d18 1
a18 1
/* $ISC: dispatch.h,v 1.48.18.5 2007/08/28 07:20:05 tbox Exp $ */
d116 3
d128 1
a445 7
 */

void
dns_dispatch_hash(void *data, size_t len);
/*%<
 * Feed 'data' to the dispatch query id generator where 'len' is the size
 * of 'data'.
@


1.5.2.1
log
@Vendor patch to add port randomization to deal with the DNS cache
poisoning attack.

Dynamically allocate fd_sets so we are not limited to FD_SETSIZE
connections.

From djm@@
@
text
@a115 3
 *
 * _RANDOMPORT
 *	Allocate UDP port randomly.
a124 1
#define DNS_DISPATCHATTR_RANDOMPORT	0x00000100U
d442 7
@


1.4
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d5 1
a5 1
 * Permission to use, copy, modify, and distribute this software for any
d18 1
a18 1
/* $ISC: dispatch.h,v 1.45.2.2.4.2 2004/03/06 08:13:55 marka Exp $ */
d27 2
a28 1
/*
a29 1
 *
d34 1
a34 1
 *     	All locking is performed internally to each dispatch.
d43 1
a43 1
 *	Depends on the isc_socket_t and dns_message_t for prevention of
d48 1
a48 1
 *	None.
d64 1
a64 1
/*
d82 7
a88 7
	ISC_EVENT_COMMON(dns_dispatchevent_t);	/* standard event common */
	isc_result_t		result;		/* result code */
	isc_int32_t		id;		/* message id */
	isc_sockaddr_t		addr;		/* address recv'd from */
	struct in6_pktinfo	pktinfo;	/* reply info for v6 */
	isc_buffer_t	        buffer;		/* data buffer */
	isc_uint32_t		attributes;	/* mirrored from socket.h */
d91 2
a92 1
/*
d125 1
d130 1
a130 1
/*
d134 1
a134 1
 *	"mctx" be a valid memory context.
d136 1
a136 1
 *	mgrp != NULL && *mgrp == NULL
d138 1
a138 1
 *	"entropy" may be NULL, in which case an insecure random generator
d143 1
a143 1
 *	ISC_R_SUCCESS	-- all ok
d145 1
a145 1
 *	anything else	-- failure
d151 1
a151 1
/*
d156 1
a156 1
 *	mgrp != NULL && *mgrp is a valid dispatchmgr.
d162 1
a162 1
/*
d167 2
a168 2
 * 	mgrp is a valid dispatchmgr
 * 	blackhole is a valid acl
d174 1
a174 1
/*
d179 1
a179 1
 * 	mgr is a valid dispatchmgr
d181 1
a181 1
 *	A pointer to the current blackhole list, or NULL.
d187 1
a187 1
/*
d192 2
a193 2
 *	mgr is a valid dispatchmgr
 *	portlist to be NULL or a valid port list.
d198 1
a198 1
/*
d202 1
a202 1
 *	mgr is a valid dispatchmgr
d215 1
a215 1
/*
d220 1
a220 1
 *	All pointer parameters be valid for their respective types.
d222 1
a222 1
 *	dispp != NULL && *disp == NULL
d224 1
a224 1
 *	512 <= buffersize <= 64k
d226 1
a226 1
 *	maxbuffers > 0
d228 1
a228 1
 *	buckets < 2097169
d230 1
a230 1
 *	increment > buckets
d232 1
a232 1
 *	(attributes & DNS_DISPATCHATTR_TCP) == 0
d235 1
a235 1
 *	ISC_R_SUCCESS	-- success.
d237 1
a237 1
 *	Anything else	-- failure.
d246 1
a246 1
/*
d263 1
a263 1
 *	mgr is a valid dispatch manager.
d265 1
a265 1
 *	sock is a valid.
d267 1
a267 1
 *	task is a valid task that can be used internally to this dispatcher.
d269 1
a269 1
 * 	512 <= buffersize <= 64k
d271 1
a271 1
 *	maxbuffers > 0.
d273 1
a273 1
 *	maxrequests <= maxbuffers.
d275 1
a275 1
 *	buckets < 2097169 (the next prime after 65536 * 32)
d277 1
a277 1
 *	increment > buckets (and prime).
d279 2
a280 2
 *	attributes includes DNS_DISPATCHATTR_TCP and does not include
 *	DNS_DISPATCHATTR_UDP.
d283 1
a283 1
 *	ISC_R_SUCCESS	-- success.
d285 1
a285 1
 *	Anything else	-- failure.
d290 1
a290 1
/*
d294 1
a294 1
 *	disp is valid.
d296 1
a296 1
 *	dispp != NULL && *dispp == NULL
d301 1
a301 1
/*
d305 1
a305 1
 *	dispp != NULL and *dispp be a valid dispatch.
d310 1
a310 1
/*
d314 1
a314 1
 *	'disp' is valid.
d321 1
a321 1
/*
d332 1
a332 1
 *	"idp" be non-NULL.
d334 1
a334 1
 *	"task" "action" and "arg" be set as appropriate.
d336 1
a336 1
 *	"dest" be non-NULL and valid.
d338 1
a338 1
 *	"resp" be non-NULL and *resp be NULL
d342 1
a342 1
 *	<id, dest> is a unique tuple.  That means incoming messages
d347 3
a349 3
 *	ISC_R_SUCCESS		-- all is well.
 *	ISC_R_NOMEMORY		-- memory could not be allocated.
 *	ISC_R_NOMORE		-- no more message ids can be allocated
d357 1
a357 1
/*
d363 1
a363 1
 *	"resp" != NULL and "*resp" contain a value previously allocated
d366 1
a366 1
 *	May only be called from within the task given as the 'task' 
d373 1
a373 1
/*
d377 1
a377 1
 *	disp is valid.
d380 1
a380 1
 *	The socket the dispatcher is using.
d385 1
a385 1
/*
d390 2
a391 2
 *	disp is valid.
 *	addrp to be non null.
d394 2
a395 2
 *	ISC_R_SUCCESS	
 *	ISC_R_NOTIMPLEMENTED
d400 1
a400 1
/*
d404 1
a404 1
 *	disp is valid.
d410 1
a410 1
/*
d416 1
d418 1
d420 1
a420 1
 * This function has a side effect when DNS_DISPATCHATTR_NOLISTEN changes. 
d426 1
a426 1
 *	disp is valid.
d428 1
a428 1
 *	attributes are reasonable for the dispatch.  That is, setting the UDP
d434 1
a434 1
/*
d440 1
a440 1
 * 	disp is valid, and the attribute DNS_DISPATCHATTR_NOLISTEN is set.
d442 7
@


1.4.12.1
log
@Vendor patch to add port randomization to deal with the DNS cache
poisoning attack.

Dynamically allocate fd_sets so we are not limited to FD_SETSIZE
connections.

Replacement Knuth shuffle algorithm for DNS id generation.

From djm@@
@
text
@a114 3
 *
 * _RANDOMPORT
 *	Allocate UDP port randomly.
a123 1
#define DNS_DISPATCHATTR_RANDOMPORT	0x00000100U
@


1.3
log
@update to BIND v9.2.3. ok todd@@
@
text
@d2 2
a3 1
 * Copyright (C) 1999-2001, 2003  Internet Software Consortium.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: dispatch.h,v 1.45.2.2 2003/03/06 04:38:22 marka Exp $ */
d181 22
@


1.2
log
@update to BIND 9.2.2-release. ok millert@@
@
text
@d18 1
a18 1
/* $ISC: dispatch.h,v 1.45.22.2 2003/02/17 07:05:10 marka Exp $ */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2001  Internet Software Consortium.
d18 1
a18 1
/* $ISC: dispatch.h,v 1.45 2001/04/30 18:09:28 gson Exp $ */
d393 5
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1999-2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: dispatch.h,v 1.45.2.2.4.2 2004/03/06 08:13:55 marka Exp $ */
a181 22
void
dns_dispatchmgr_setblackportlist(dns_dispatchmgr_t *mgr,
                                 dns_portlist_t *portlist);
/*
 * Sets a list of UDP ports that won't be used when creating a udp
 * dispatch with a wildcard port.
 *
 * Requires:
 *	mgr is a valid dispatchmgr
 *	portlist to be NULL or a valid port list.
 */

dns_portlist_t *
dns_dispatchmgr_getblackportlist(dns_dispatchmgr_t *mgr);
/*
 * Return the current port list.
 *
 * Requires:
 *	mgr is a valid dispatchmgr
 */


a392 5
 *
 * This function has a side effect when DNS_DISPATCHATTR_NOLISTEN changes. 
 * When the flag becomes off, the dispatch will start receiving on the
 * corresponding socket.  When the flag becomes on, receive events on the
 * corresponding socket will be canceled.
@


1.1.1.3
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005, 2007  Internet Systems Consortium, Inc. ("ISC")
d5 1
a5 1
 * Permission to use, copy, modify, and/or distribute this software for any
d18 1
a18 1
/* $ISC: dispatch.h,v 1.48.18.5 2007/08/28 07:20:05 tbox Exp $ */
d27 1
a27 2
/*! \file
 * \brief
d29 1
d34 1
a34 1
 *\li     	All locking is performed internally to each dispatch.
d43 1
a43 1
 *\li	Depends on the isc_socket_t and dns_message_t for prevention of
d48 1
a48 1
 *\li	None.
d64 1
a64 1
/*%
d82 7
a88 7
	ISC_EVENT_COMMON(dns_dispatchevent_t);	/*%< standard event common */
	isc_result_t		result;		/*%< result code */
	isc_int32_t		id;		/*%< message id */
	isc_sockaddr_t		addr;		/*%< address recv'd from */
	struct in6_pktinfo	pktinfo;	/*%< reply info for v6 */
	isc_buffer_t	        buffer;		/*%< data buffer */
	isc_uint32_t		attributes;	/*%< mirrored from socket.h */
d91 1
a91 2
/*@@{*/
/*%
a123 1
/*@@}*/
d128 1
a128 1
/*%<
d132 1
a132 1
 *\li	"mctx" be a valid memory context.
d134 1
a134 1
 *\li	mgrp != NULL && *mgrp == NULL
d136 1
a136 1
 *\li	"entropy" may be NULL, in which case an insecure random generator
d141 1
a141 1
 *\li	ISC_R_SUCCESS	-- all ok
d143 1
a143 1
 *\li	anything else	-- failure
d149 1
a149 1
/*%<
d154 1
a154 1
 *\li	mgrp != NULL && *mgrp is a valid dispatchmgr.
d160 1
a160 1
/*%<
d165 2
a166 2
 * \li	mgrp is a valid dispatchmgr
 * \li	blackhole is a valid acl
d172 1
a172 1
/*%<
d177 1
a177 1
 *\li 	mgr is a valid dispatchmgr
d179 1
a179 1
 *\li	A pointer to the current blackhole list, or NULL.
d185 1
a185 1
/*%<
d190 2
a191 2
 *\li	mgr is a valid dispatchmgr
 *\li	portlist to be NULL or a valid port list.
d196 1
a196 1
/*%<
d200 1
a200 1
 *\li	mgr is a valid dispatchmgr
d213 1
a213 1
/*%<
d218 1
a218 1
 *\li	All pointer parameters be valid for their respective types.
d220 1
a220 1
 *\li	dispp != NULL && *disp == NULL
d222 1
a222 1
 *\li	512 <= buffersize <= 64k
d224 1
a224 1
 *\li	maxbuffers > 0
d226 1
a226 1
 *\li	buckets < 2097169
d228 1
a228 1
 *\li	increment > buckets
d230 1
a230 1
 *\li	(attributes & DNS_DISPATCHATTR_TCP) == 0
d233 1
a233 1
 *\li	ISC_R_SUCCESS	-- success.
d235 1
a235 1
 *\li	Anything else	-- failure.
d244 1
a244 1
/*%<
d261 1
a261 1
 *\li	mgr is a valid dispatch manager.
d263 1
a263 1
 *\li	sock is a valid.
d265 1
a265 1
 *\li	task is a valid task that can be used internally to this dispatcher.
d267 1
a267 1
 * \li	512 <= buffersize <= 64k
d269 1
a269 1
 *\li	maxbuffers > 0.
d271 1
a271 1
 *\li	maxrequests <= maxbuffers.
d273 1
a273 1
 *\li	buckets < 2097169 (the next prime after 65536 * 32)
d275 1
a275 1
 *\li	increment > buckets (and prime).
d277 2
a278 2
 *\li	attributes includes #DNS_DISPATCHATTR_TCP and does not include
 *	#DNS_DISPATCHATTR_UDP.
d281 1
a281 1
 *\li	ISC_R_SUCCESS	-- success.
d283 1
a283 1
 *\li	Anything else	-- failure.
d288 1
a288 1
/*%<
d292 1
a292 1
 *\li	disp is valid.
d294 1
a294 1
 *\li	dispp != NULL && *dispp == NULL
d299 1
a299 1
/*%<
d303 1
a303 1
 *\li	dispp != NULL and *dispp be a valid dispatch.
d308 1
a308 1
/*%<
d312 1
a312 1
 *\li	'disp' is valid.
d319 1
a319 1
/*%<
d330 1
a330 1
 *\li	"idp" be non-NULL.
d332 1
a332 1
 *\li	"task" "action" and "arg" be set as appropriate.
d334 1
a334 1
 *\li	"dest" be non-NULL and valid.
d336 1
a336 1
 *\li	"resp" be non-NULL and *resp be NULL
d340 1
a340 1
 *\li	&lt;id, dest> is a unique tuple.  That means incoming messages
d345 3
a347 3
 *\li	ISC_R_SUCCESS		-- all is well.
 *\li	ISC_R_NOMEMORY		-- memory could not be allocated.
 *\li	ISC_R_NOMORE		-- no more message ids can be allocated
d355 1
a355 1
/*%<
d361 1
a361 1
 *\li	"resp" != NULL and "*resp" contain a value previously allocated
d364 1
a364 1
 *\li	May only be called from within the task given as the 'task' 
d371 1
a371 1
/*%<
d375 1
a375 1
 *\li	disp is valid.
d378 1
a378 1
 *\li	The socket the dispatcher is using.
d383 1
a383 1
/*%<
d388 2
a389 2
 *\li	disp is valid.
 *\li	addrp to be non null.
d392 2
a393 2
 *\li	ISC_R_SUCCESS	
 *\li	ISC_R_NOTIMPLEMENTED
d398 1
a398 1
/*%<
d402 1
a402 1
 *\li	disp is valid.
d408 1
a408 1
/*%<
a413 1
 * \code
a414 1
 * \endcode
d416 1
a416 1
 * This function has a side effect when #DNS_DISPATCHATTR_NOLISTEN changes. 
d422 1
a422 1
 *\li	disp is valid.
d424 1
a424 1
 *\li	attributes are reasonable for the dispatch.  That is, setting the UDP
d430 1
a430 1
/*%<
d436 1
a436 1
 *\li 	disp is valid, and the attribute DNS_DISPATCHATTR_NOLISTEN is set.
a437 7
 */

void
dns_dispatch_hash(void *data, size_t len);
/*%<
 * Feed 'data' to the dispatch query id generator where 'len' is the size
 * of 'data'.
@


1.1.1.4
log
@ISC BIND release 9.4.2-P1
@
text
@d18 1
a18 1
/* $ISC: dispatch.h,v 1.48.18.5.12.1 2008/05/22 21:28:06 each Exp $ */
a115 3
 *
 * _RANDOMPORT
 *	Allocate UDP port randomly.
a124 1
#define DNS_DISPATCHATTR_RANDOMPORT	0x00000100U
d442 7
@


