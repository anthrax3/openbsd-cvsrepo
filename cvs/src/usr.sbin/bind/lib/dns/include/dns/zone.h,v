head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.38
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.36
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.32
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.34
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.26
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.30
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.28
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.24
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.22
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.20
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.18
	OPENBSD_5_0:1.8.0.16
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.14
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.12
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.8
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.10
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.6
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	BIND_9_4_2_P1:1.1.1.5
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	BIND_9_4_2:1.1.1.5
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	BIND_9_3_4:1.1.1.4
	BIND_9_3_3:1.1.1.4
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	BIND_9_3_2:1.1.1.3
	OPENBSD_3_9:1.5.0.4
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	BIND_9_3_1:1.1.1.3
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.4
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2007.12.09.13.39.44;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.10.19.07.59;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.18.18.18.26;	author mk;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.22.16.52.39;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.28.17.14.06;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.18.14.14.07;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.05.09.18.32;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.07.22;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.22;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.35.17;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.03.22.16.38.08;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.01.10.18.19.56;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2007.12.09.12.34.44;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.8
log
@resolve conflicts
@
text
@/*
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1999-2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: zone.h,v 1.126.18.19 2006/08/01 03:45:21 marka Exp $ */

#ifndef DNS_ZONE_H
#define DNS_ZONE_H 1

/*! \file */

/***
 ***	Imports
 ***/

#include <stdio.h>

#include <isc/formatcheck.h>
#include <isc/lang.h>
#include <isc/rwlock.h>

#include <dns/masterdump.h>
#include <dns/types.h>

typedef enum {
	dns_zone_none,
	dns_zone_master,
	dns_zone_slave,
	dns_zone_stub
} dns_zonetype_t;

#define DNS_ZONEOPT_SERVERS	  0x00000001U	/*%< perform server checks */
#define DNS_ZONEOPT_PARENTS	  0x00000002U	/*%< perform parent checks */
#define DNS_ZONEOPT_CHILDREN	  0x00000004U	/*%< perform child checks */
#define DNS_ZONEOPT_NOTIFY	  0x00000008U	/*%< perform NOTIFY */
#define DNS_ZONEOPT_MANYERRORS	  0x00000010U	/*%< return many errors on load */
#define DNS_ZONEOPT_IXFRFROMDIFFS 0x00000020U	/*%< calculate differences */
#define DNS_ZONEOPT_NOMERGE	  0x00000040U	/*%< don't merge journal */
#define DNS_ZONEOPT_CHECKNS	  0x00000080U	/*%< check if NS's are addresses */
#define DNS_ZONEOPT_FATALNS	  0x00000100U	/*%< DNS_ZONEOPT_CHECKNS is fatal */
#define DNS_ZONEOPT_MULTIMASTER	  0x00000200U	/*%< this zone has multiple masters */
#define DNS_ZONEOPT_USEALTXFRSRC  0x00000400U	/*%< use alternate transfer sources */
#define DNS_ZONEOPT_CHECKNAMES	  0x00000800U	/*%< check-names */
#define DNS_ZONEOPT_CHECKNAMESFAIL 0x00001000U	/*%< fatal check-name failures */
#define DNS_ZONEOPT_CHECKWILDCARD 0x00002000U	/*%< check for internal wildcards */
#define DNS_ZONEOPT_CHECKMX	  0x00004000U	/*%< check-mx */
#define DNS_ZONEOPT_CHECKMXFAIL   0x00008000U	/*%< fatal check-mx failures */
#define DNS_ZONEOPT_CHECKINTEGRITY 0x00010000U	/*%< perform integrity checks */
#define DNS_ZONEOPT_CHECKSIBLING  0x00020000U	/*%< perform sibling glue checks */
#define DNS_ZONEOPT_NOCHECKNS	  0x00040000U	/*%< disable IN NS address checks */
#define DNS_ZONEOPT_WARNMXCNAME	  0x00080000U	/*%< warn on MX CNAME check */
#define DNS_ZONEOPT_IGNOREMXCNAME 0x00100000U	/*%< ignore MX CNAME check */
#define DNS_ZONEOPT_WARNSRVCNAME  0x00200000U	/*%< warn on SRV CNAME check */
#define DNS_ZONEOPT_IGNORESRVCNAME 0x00400000U	/*%< ignore SRV CNAME check */
#define DNS_ZONEOPT_UPDATECHECKKSK 0x00800000U	/*%< check dnskey KSK flag */

#ifndef NOMINUM_PUBLIC
/*
 * Nominum specific options build down.
 */
#define DNS_ZONEOPT_NOTIFYFORWARD 0x80000000U	/* forward notify to master */
#endif /* NOMINUM_PUBLIC */

#ifndef DNS_ZONE_MINREFRESH
#define DNS_ZONE_MINREFRESH		    300	/*%< 5 minutes */
#endif
#ifndef DNS_ZONE_MAXREFRESH
#define DNS_ZONE_MAXREFRESH		2419200	/*%< 4 weeks */
#endif
#ifndef DNS_ZONE_DEFAULTREFRESH
#define DNS_ZONE_DEFAULTREFRESH		   3600	/*%< 1 hour */
#endif
#ifndef DNS_ZONE_MINRETRY
#define DNS_ZONE_MINRETRY		    300	/*%< 5 minutes */
#endif
#ifndef DNS_ZONE_MAXRETRY
#define DNS_ZONE_MAXRETRY		1209600	/*%< 2 weeks */
#endif
#ifndef DNS_ZONE_DEFAULTRETRY
#define DNS_ZONE_DEFAULTRETRY		     60	/*%< 1 minute, subject to
						   exponential backoff */
#endif

#define DNS_ZONESTATE_XFERRUNNING	1
#define DNS_ZONESTATE_XFERDEFERRED	2
#define DNS_ZONESTATE_SOAQUERY		3
#define DNS_ZONESTATE_ANY		4

ISC_LANG_BEGINDECLS

/***
 ***	Functions
 ***/

isc_result_t
dns_zone_create(dns_zone_t **zonep, isc_mem_t *mctx);
/*%<
 *	Creates a new empty zone and attach '*zonep' to it.
 *
 * Requires:
 *\li	'zonep' to point to a NULL pointer.
 *\li	'mctx' to be a valid memory context.
 *
 * Ensures:
 *\li	'*zonep' refers to a valid zone.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_UNEXPECTED
 */

void
dns_zone_setclass(dns_zone_t *zone, dns_rdataclass_t rdclass);
/*%<
 *	Sets the class of a zone.  This operation can only be performed
 *	once on a zone.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	dns_zone_setclass() not to have been called since the zone was
 *	created.
 *\li	'rdclass' != dns_rdataclass_none.
 */

dns_rdataclass_t
dns_zone_getclass(dns_zone_t *zone);
/*%<
 *	Returns the current zone class.
 *
 * Requires:
 *\li	'zone' to be a valid zone.
 */

void
dns_zone_settype(dns_zone_t *zone, dns_zonetype_t type);
/*%<
 *	Sets the zone type. This operation can only be performed once on
 *	a zone.
 *
 * Requires:
 *\li	'zone' to be a valid zone.
 *\li	dns_zone_settype() not to have been called since the zone was
 *	created.
 *\li	'type' != dns_zone_none
 */

void
dns_zone_setview(dns_zone_t *zone, dns_view_t *view);
/*%<
 *	Associate the zone with a view.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

dns_view_t *
dns_zone_getview(dns_zone_t *zone);
/*%<
 *	Returns the zone's associated view.
 *
 * Requires:
 *\li	'zone' to be a valid zone.
 */

isc_result_t
dns_zone_setorigin(dns_zone_t *zone, const dns_name_t *origin);
/*%<
 *	Sets the zones origin to 'origin'.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'origin' to be non NULL.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 *\li 	#ISC_R_NOMEMORY
 */

dns_name_t *
dns_zone_getorigin(dns_zone_t *zone);
/*%<
 *	Returns the value of the origin.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

isc_result_t
dns_zone_setfile(dns_zone_t *zone, const char *file);

isc_result_t
dns_zone_setfile2(dns_zone_t *zone, const char *file,
		  dns_masterformat_t format);
/*%<
 *    Sets the name of the master file in the format of 'format' from which
 *    the zone loads its database to 'file'.
 *
 *    For zones that have no associated master file, 'file' will be NULL.
 *
 *	For zones with persistent databases, the file name
 *	setting is ignored.
 *
 *    dns_zone_setfile() is a backward-compatible form of
 *    dns_zone_setfile2(), which always specifies the
 *    dns_masterformat_text (RFC1035) format.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *
 * Returns:
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_SUCCESS
 */

const char *
dns_zone_getfile(dns_zone_t *zone);
/*%<
 * 	Gets the name of the zone's master file, if any.
 *
 * Requires:
 *\li	'zone' to be valid initialised zone.
 *
 * Returns:
 *\li	Pointer to null-terminated file name, or NULL.
 */

isc_result_t
dns_zone_load(dns_zone_t *zone);

isc_result_t
dns_zone_loadnew(dns_zone_t *zone);
/*%<
 *	Cause the database to be loaded from its backing store.
 *	Confirm that the minimum requirements for the zone type are
 *	met, otherwise DNS_R_BADZONE is returned.
 *
 *	dns_zone_loadnew() only loads zones that are not yet loaded.
 *	dns_zone_load() also loads zones that are already loaded and
 *	and whose master file has changed since the last load.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *
 * Returns:
 *\li	#ISC_R_UNEXPECTED
 *\li	#ISC_R_SUCCESS
 *\li	DNS_R_CONTINUE	  Incremental load has been queued.
 *\li	DNS_R_UPTODATE	  The zone has already been loaded based on
 *			  file system timestamps.
 *\li	DNS_R_BADZONE
 *\li	Any result value from dns_db_load().
 */

void
dns_zone_attach(dns_zone_t *source, dns_zone_t **target);
/*%<
 *	Attach '*target' to 'source' incrementing its external
 * 	reference count.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'target' to be non NULL and '*target' to be NULL.
 */

void
dns_zone_detach(dns_zone_t **zonep);
/*%<
 *	Detach from a zone decrementing its external reference count.
 *	If this was the last external reference to the zone it will be
 * 	shut down and eventually freed.
 *
 * Require:
 *\li	'zonep' to point to a valid zone.
 */

void
dns_zone_iattach(dns_zone_t *source, dns_zone_t **target);
/*%<
 *	Attach '*target' to 'source' incrementing its internal
 * 	reference count.  This is intended for use by operations
 * 	such as zone transfers that need to prevent the zone
 * 	object from being freed but not from shutting down.
 *
 * Require:
 *\li	The caller is running in the context of the zone's task.
 *\li	'zone' to be a valid zone.
 *\li	'target' to be non NULL and '*target' to be NULL.
 */

void
dns_zone_idetach(dns_zone_t **zonep);
/*%<
 *	Detach from a zone decrementing its internal reference count.
 *	If there are no more internal or external references to the
 * 	zone, it will be freed.
 *
 * Require:
 *\li	The caller is running in the context of the zone's task.
 *\li	'zonep' to point to a valid zone.
 */

void
dns_zone_setflag(dns_zone_t *zone, unsigned int flags, isc_boolean_t value);
/*%<
 *	Sets ('value' == 'ISC_TRUE') / clears ('value' == 'IS_FALSE')
 *	zone flags.  Valid flag bits are DNS_ZONE_F_*.
 *
 * Requires
 *\li	'zone' to be a valid zone.
 */

isc_result_t
dns_zone_getdb(dns_zone_t *zone, dns_db_t **dbp);
/*%<
 * 	Attach '*dbp' to the database to if it exists otherwise
 *	return DNS_R_NOTLOADED.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'dbp' to be != NULL && '*dbp' == NULL.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 *\li	DNS_R_NOTLOADED
 */

isc_result_t
dns_zone_setdbtype(dns_zone_t *zone,
		   unsigned int dbargc, const char * const *dbargv);
/*%<
 *	Sets the database type to dbargv[0] and database arguments
 *	to subsequent dbargv elements.
 *	'db_type' is not checked to see if it is a valid database type.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'database' to be non NULL.
 *\li	'dbargc' to be >= 1
 *\li	'dbargv' to point to dbargc NULL-terminated strings
 *
 * Returns:
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_SUCCESS
 */

isc_result_t
dns_zone_getdbtype(dns_zone_t *zone, char ***argv, isc_mem_t *mctx);
/*%<
 *	Returns the current dbtype.  isc_mem_free() should be used
 * 	to free 'argv' after use.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'argv' to be non NULL and *argv to be NULL.
 *\li	'mctx' to be valid.
 *
 * Returns:
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_SUCCESS
 */

void
dns_zone_markdirty(dns_zone_t *zone);
/*%<
 *	Mark a zone as 'dirty'.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

void
dns_zone_expire(dns_zone_t *zone);
/*%<
 *	Mark the zone as expired.  If the zone requires dumping cause it to
 *	be initiated.  Set the refresh and retry intervals to there default
 *	values and unload the zone.
 *
 * Require
 *\li	'zone' to be a valid zone.
 */

void
dns_zone_refresh(dns_zone_t *zone);
/*%<
 *	Initiate zone up to date checks.  The zone must already be being
 *	managed.
 *
 * Require
 *\li	'zone' to be a valid zone.
 */

isc_result_t
dns_zone_flush(dns_zone_t *zone);
/*%<
 *	Write the zone to database if there are uncommited changes.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

isc_result_t
dns_zone_dump(dns_zone_t *zone);
/*%<
 *	Write the zone to database.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

isc_result_t
dns_zone_dumptostream(dns_zone_t *zone, FILE *fd);

isc_result_t
dns_zone_dumptostream2(dns_zone_t *zone, FILE *fd, dns_masterformat_t format,
		       const dns_master_style_t *style);
/*%<
 *    Write the zone to stream 'fd' in the specified 'format'.
 *    If the 'format' is dns_masterformat_text (RFC1035), 'style' also
 *    specifies the file style (e.g., &dns_master_style_default).
 *
 *    dns_zone_dumptostream() is a backward-compatible form of
 *    dns_zone_dumptostream2(), which always uses the dns_masterformat_text
 *    format and the dns_master_style_default style.
 *
 *    Note that dns_zone_dumptostream2() is the most flexible form.  It
 *    can also provide the functionality of dns_zone_fulldumptostream().
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'fd' to be a stream open for writing.
 */

isc_result_t
dns_zone_fulldumptostream(dns_zone_t *zone, FILE *fd);
/*%<
 *	The same as dns_zone_dumptostream, but dumps the zone with
 *	different dump settings (dns_master_style_full).
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'fd' to be a stream open for writing.
 */

void
dns_zone_maintenance(dns_zone_t *zone);
/*%<
 *	Perform regular maintenace on the zone.  This is called as a
 *	result of a zone being managed.
 *
 * Require
 *\li	'zone' to be a valid zone.
 */

isc_result_t
dns_zone_setmasters(dns_zone_t *zone, const isc_sockaddr_t *masters,
		    isc_uint32_t count);
isc_result_t
dns_zone_setmasterswithkeys(dns_zone_t *zone,
			    const isc_sockaddr_t *masters,
			    dns_name_t **keynames,
			    isc_uint32_t count);
/*%<
 *	Set the list of master servers for the zone.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'masters' array of isc_sockaddr_t with port set or NULL.
 *\li	'count' the number of masters.
 *\li      'keynames' array of dns_name_t's for tsig keys or NULL.
 *
 *  \li    dns_zone_setmasters() is just a wrapper to setmasterswithkeys(),
 *      passing NULL in the keynames field.
 *
 * \li	If 'masters' is NULL then 'count' must be zero.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOMEMORY
 *\li      Any result dns_name_dup() can return, if keynames!=NULL
 */

isc_result_t
dns_zone_setalsonotify(dns_zone_t *zone, const isc_sockaddr_t *notify,
		       isc_uint32_t count);
/*%<
 *	Set the list of additional servers to be notified when
 *	a zone changes.	 To clear the list use 'count = 0'.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'notify' to be non-NULL if count != 0.
 *\li	'count' to be the number of notifyees.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOMEMORY
 */

void
dns_zone_unload(dns_zone_t *zone);
/*%<
 *	detach the database from the zone structure.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

void
dns_zone_setoption(dns_zone_t *zone, unsigned int option, isc_boolean_t value);
/*%<
 *	Set given options on ('value' == ISC_TRUE) or off ('value' ==
 *	#ISC_FALSE).
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

unsigned int
dns_zone_getoptions(dns_zone_t *zone);
/*%<
 *	Returns the current zone options.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

void
dns_zone_setminrefreshtime(dns_zone_t *zone, isc_uint32_t val);
/*%<
 *	Set the minimum refresh time.
 *
 * Requires:
 *\li	'zone' is valid.
 *\li	val > 0.
 */

void
dns_zone_setmaxrefreshtime(dns_zone_t *zone, isc_uint32_t val);
/*%<
 *	Set the maximum refresh time.
 *
 * Requires:
 *\li	'zone' is valid.
 *\li	val > 0.
 */

void
dns_zone_setminretrytime(dns_zone_t *zone, isc_uint32_t val);
/*%<
 *	Set the minimum retry time.
 *
 * Requires:
 *\li	'zone' is valid.
 *\li	val > 0.
 */

void
dns_zone_setmaxretrytime(dns_zone_t *zone, isc_uint32_t val);
/*%<
 *	Set the maximum retry time.
 *
 * Requires:
 *\li	'zone' is valid.
 *	val > 0.
 */

isc_result_t
dns_zone_setxfrsource4(dns_zone_t *zone, const isc_sockaddr_t *xfrsource);
isc_result_t
dns_zone_setaltxfrsource4(dns_zone_t *zone,
			  const isc_sockaddr_t *xfrsource);
/*%<
 * 	Set the source address to be used in IPv4 zone transfers.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'xfrsource' to contain the address.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 */

isc_sockaddr_t *
dns_zone_getxfrsource4(dns_zone_t *zone);
isc_sockaddr_t *
dns_zone_getaltxfrsource4(dns_zone_t *zone);
/*%<
 *	Returns the source address set by a previous dns_zone_setxfrsource4
 *	call, or the default of inaddr_any, port 0.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

isc_result_t
dns_zone_setxfrsource6(dns_zone_t *zone, const isc_sockaddr_t *xfrsource);
isc_result_t
dns_zone_setaltxfrsource6(dns_zone_t *zone,
			  const isc_sockaddr_t *xfrsource);
/*%<
 * 	Set the source address to be used in IPv6 zone transfers.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'xfrsource' to contain the address.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 */

isc_sockaddr_t *
dns_zone_getxfrsource6(dns_zone_t *zone);
isc_sockaddr_t *
dns_zone_getaltxfrsource6(dns_zone_t *zone);
/*%<
 *	Returns the source address set by a previous dns_zone_setxfrsource6
 *	call, or the default of in6addr_any, port 0.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

isc_result_t
dns_zone_setnotifysrc4(dns_zone_t *zone, const isc_sockaddr_t *notifysrc);
/*%<
 * 	Set the source address to be used with IPv4 NOTIFY messages.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'notifysrc' to contain the address.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 */

isc_sockaddr_t *
dns_zone_getnotifysrc4(dns_zone_t *zone);
/*%<
 *	Returns the source address set by a previous dns_zone_setnotifysrc4
 *	call, or the default of inaddr_any, port 0.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

isc_result_t
dns_zone_setnotifysrc6(dns_zone_t *zone, const isc_sockaddr_t *notifysrc);
/*%<
 * 	Set the source address to be used with IPv6 NOTIFY messages.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'notifysrc' to contain the address.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 */

isc_sockaddr_t *
dns_zone_getnotifysrc6(dns_zone_t *zone);
/*%<
 *	Returns the source address set by a previous dns_zone_setnotifysrc6
 *	call, or the default of in6addr_any, port 0.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

void
dns_zone_setnotifyacl(dns_zone_t *zone, dns_acl_t *acl);
/*%<
 *	Sets the notify acl list for the zone.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'acl' to be a valid acl.
 */

void
dns_zone_setqueryacl(dns_zone_t *zone, dns_acl_t *acl);
/*%<
 *	Sets the query acl list for the zone.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'acl' to be a valid acl.
 */

void
dns_zone_setupdateacl(dns_zone_t *zone, dns_acl_t *acl);
/*%<
 *	Sets the update acl list for the zone.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'acl' to be valid acl.
 */

void
dns_zone_setforwardacl(dns_zone_t *zone, dns_acl_t *acl);
/*%<
 *	Sets the forward unsigned updates acl list for the zone.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'acl' to be valid acl.
 */

void
dns_zone_setxfracl(dns_zone_t *zone, dns_acl_t *acl);
/*%<
 *	Sets the transfer acl list for the zone.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'acl' to be valid acl.
 */

dns_acl_t *
dns_zone_getnotifyacl(dns_zone_t *zone);
/*%<
 * 	Returns the current notify acl or NULL.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *
 * Returns:
 *\li	acl a pointer to the acl.
 *\li	NULL
 */

dns_acl_t *
dns_zone_getqueryacl(dns_zone_t *zone);
/*%<
 * 	Returns the current query acl or NULL.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *
 * Returns:
 *\li	acl a pointer to the acl.
 *\li	NULL
 */

dns_acl_t *
dns_zone_getupdateacl(dns_zone_t *zone);
/*%<
 * 	Returns the current update acl or NULL.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *
 * Returns:
 *\li	acl a pointer to the acl.
 *\li	NULL
 */

dns_acl_t *
dns_zone_getforwardacl(dns_zone_t *zone);
/*%<
 * 	Returns the current forward unsigned updates acl or NULL.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *
 * Returns:
 *\li	acl a pointer to the acl.
 *\li	NULL
 */

dns_acl_t *
dns_zone_getxfracl(dns_zone_t *zone);
/*%<
 * 	Returns the current transfer acl or NULL.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *
 * Returns:
 *\li	acl a pointer to the acl.
 *\li	NULL
 */

void
dns_zone_clearupdateacl(dns_zone_t *zone);
/*%<
 *	Clear the current update acl.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

void
dns_zone_clearforwardacl(dns_zone_t *zone);
/*%<
 *	Clear the current forward unsigned updates acl.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

void
dns_zone_clearnotifyacl(dns_zone_t *zone);
/*%<
 *	Clear the current notify acl.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

void
dns_zone_clearqueryacl(dns_zone_t *zone);
/*%<
 *	Clear the current query acl.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

void
dns_zone_clearxfracl(dns_zone_t *zone);
/*%<
 *	Clear the current transfer acl.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

isc_boolean_t
dns_zone_getupdatedisabled(dns_zone_t *zone);
/*%<
 * Return update disabled.
 */

void
dns_zone_setupdatedisabled(dns_zone_t *zone, isc_boolean_t state);
/*%<
 * Set update disabled.
 */

isc_boolean_t
dns_zone_getzeronosoattl(dns_zone_t *zone);
/*%<
 * Return zero-no-soa-ttl status.
 */

void
dns_zone_setzeronosoattl(dns_zone_t *zone, isc_boolean_t state);
/*%<
 * Set zero-no-soa-ttl status.
 */

void
dns_zone_setchecknames(dns_zone_t *zone, dns_severity_t severity);
/*%<
 * 	Set the severity of name checking when loading a zone.
 *
 * Require:
 * \li     'zone' to be a valid zone.
 */

dns_severity_t
dns_zone_getchecknames(dns_zone_t *zone);
/*%<
 *	Return the current severity of name checking.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 */

void
dns_zone_setjournalsize(dns_zone_t *zone, isc_int32_t size);
/*%<
 *	Sets the journal size for the zone.
 *
 * Requires:
 *\li	'zone' to be a valid zone.
 */

isc_int32_t
dns_zone_getjournalsize(dns_zone_t *zone);
/*%<
 *	Return the journal size as set with a previous call to
 *	dns_zone_setjournalsize().
 *
 * Requires:
 *\li	'zone' to be a valid zone.
 */

isc_result_t
dns_zone_notifyreceive(dns_zone_t *zone, isc_sockaddr_t *from,
		       dns_message_t *msg);
/*%<
 *	Tell the zone that it has recieved a NOTIFY message from another
 *	server.  This may cause some zone maintainence activity to occur.
 *
 * Requires:
 *\li	'zone' to be a valid zone.
 *\li	'*from' to contain the address of the server from which 'msg'
 *		was recieved.
 *\li	'msg' a message with opcode NOTIFY and qr clear.
 *
 * Returns:
 *\li	DNS_R_REFUSED
 *\li	DNS_R_NOTIMP
 *\li	DNS_R_FORMERR
 *\li	DNS_R_SUCCESS
 */

void
dns_zone_setmaxxfrin(dns_zone_t *zone, isc_uint32_t maxxfrin);
/*%<
 * Set the maximum time (in seconds) that a zone transfer in (AXFR/IXFR)
 * of this zone will use before being aborted.
 *
 * Requires:
 * \li	'zone' to be valid initialised zone.
 */

isc_uint32_t
dns_zone_getmaxxfrin(dns_zone_t *zone);
/*%<
 * Returns the maximum transfer time for this zone.  This will be
 * either the value set by the last call to dns_zone_setmaxxfrin() or
 * the default value of 1 hour.
 *
 * Requires:
 *\li	'zone' to be valid initialised zone.
 */

void
dns_zone_setmaxxfrout(dns_zone_t *zone, isc_uint32_t maxxfrout);
/*%<
 * Set the maximum time (in seconds) that a zone transfer out (AXFR/IXFR)
 * of this zone will use before being aborted.
 *
 * Requires:
 * \li	'zone' to be valid initialised zone.
 */

isc_uint32_t
dns_zone_getmaxxfrout(dns_zone_t *zone);
/*%<
 * Returns the maximum transfer time for this zone.  This will be
 * either the value set by the last call to dns_zone_setmaxxfrout() or
 * the default value of 1 hour.
 *
 * Requires:
 *\li	'zone' to be valid initialised zone.
 */

isc_result_t
dns_zone_setjournal(dns_zone_t *zone, const char *journal);
/*%<
 * Sets the filename used for journaling updates / IXFR transfers.
 * The default journal name is set by dns_zone_setfile() to be
 * "file.jnl".  If 'journal' is NULL, the zone will have no
 * journal name.
 *
 * Requires:
 *\li	'zone' to be a valid zone.
 *
 * Returns:
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOMEMORY
 */

char *
dns_zone_getjournal(dns_zone_t *zone);
/*%<
 * Returns the journal name associated with this zone.
 * If no journal has been set this will be NULL.
 *
 * Requires:
 *\li	'zone' to be valid initialised zone.
 */

dns_zonetype_t
dns_zone_gettype(dns_zone_t *zone);
/*%<
 * Returns the type of the zone (master/slave/etc.)
 *
 * Requires:
 *\li	'zone' to be valid initialised zone.
 */

void
dns_zone_settask(dns_zone_t *zone, isc_task_t *task);
/*%<
 * Give a zone a task to work with.  Any current task will be detached.
 *
 * Requires:
 *\li	'zone' to be valid.
 *\li	'task' to be valid.
 */

void
dns_zone_gettask(dns_zone_t *zone, isc_task_t **target);
/*%<
 * Attach '*target' to the zone's task.
 *
 * Requires:
 *\li	'zone' to be valid initialised zone.
 *\li	'zone' to have a task.
 *\li	'target' to be != NULL && '*target' == NULL.
 */

void
dns_zone_notify(dns_zone_t *zone);
/*%<
 * Generate notify events for this zone.
 *
 * Requires:
 *\li	'zone' to be a valid zone.
 */

isc_result_t
dns_zone_replacedb(dns_zone_t *zone, dns_db_t *db, isc_boolean_t dump);
/*%<
 * Replace the database of "zone" with a new database "db".
 *
 * If "dump" is ISC_TRUE, then the new zone contents are dumped
 * into to the zone's master file for persistence.  When replacing
 * a zone database by one just loaded from a master file, set
 * "dump" to ISC_FALSE to avoid a redunant redump of the data just
 * loaded.  Otherwise, it should be set to ISC_TRUE.
 *
 * If the "diff-on-reload" option is enabled in the configuration file,
 * the differences between the old and the new database are added to the
 * journal file, and the master file dump is postponed.
 *
 * Requires:
 * \li	'zone' to be a valid zone.
 *
 * Returns:
 * \li	DNS_R_SUCCESS
 * \li	DNS_R_BADZONE	zone failed basic consistancy checks:
 *			* a single SOA must exist
 *			* some NS records must exist.
 *	Others
 */

isc_uint32_t
dns_zone_getidlein(dns_zone_t *zone);
/*%<
 * Requires:
 * \li	'zone' to be a valid zone.
 *
 * Returns:
 * \li	number of seconds of idle time before we abort the transfer in.
 */

void
dns_zone_setidlein(dns_zone_t *zone, isc_uint32_t idlein);
/*%<
 * \li	Set the idle timeout for transfer the.
 * \li	Zero set the default value, 1 hour.
 *
 * Requires:
 * \li	'zone' to be a valid zone.
 */

isc_uint32_t
dns_zone_getidleout(dns_zone_t *zone);
/*%<
 *
 * Requires:
 * \li	'zone' to be a valid zone.
 *
 * Returns:
 * \li	number of seconds of idle time before we abort a transfer out.
 */

void
dns_zone_setidleout(dns_zone_t *zone, isc_uint32_t idleout);
/*%<
 * \li	Set the idle timeout for transfers out.
 * \li	Zero set the default value, 1 hour.
 *
 * Requires:
 * \li	'zone' to be a valid zone.
 */

void
dns_zone_getssutable(dns_zone_t *zone, dns_ssutable_t **table);
/*%<
 * Get the simple-secure-update policy table.
 *
 * Requires:
 * \li	'zone' to be a valid zone.
 */

void
dns_zone_setssutable(dns_zone_t *zone, dns_ssutable_t *table);
/*%<
 * Set / clear the simple-secure-update policy table.
 *
 * Requires:
 * \li	'zone' to be a valid zone.
 */

isc_mem_t *
dns_zone_getmctx(dns_zone_t *zone);
/*%<
 * Get the memory context of a zone.
 *
 * Requires:
 * \li	'zone' to be a valid zone.
 */

dns_zonemgr_t *
dns_zone_getmgr(dns_zone_t *zone);
/*%<
 *	If 'zone' is managed return the zone manager otherwise NULL.
 *
 * Requires:
 * \li	'zone' to be a valid zone.
 */

void
dns_zone_setsigvalidityinterval(dns_zone_t *zone, isc_uint32_t interval);
/*%<
 * Set the zone's SIG validity interval.  This is the length of time
 * for which DNSSEC signatures created as a result of dynamic updates
 * to secure zones will remain valid, in seconds.
 *
 * Requires:
 * \li	'zone' to be a valid zone.
 */

isc_uint32_t
dns_zone_getsigvalidityinterval(dns_zone_t *zone);
/*%<
 * Get the zone's SIG validity interval.
 *
 * Requires:
 * \li	'zone' to be a valid zone.
 */

void
dns_zone_setnotifytype(dns_zone_t *zone, dns_notifytype_t notifytype);
/*%<
 * Sets zone notify method to "notifytype"
 */

isc_result_t
dns_zone_forwardupdate(dns_zone_t *zone, dns_message_t *msg,
                       dns_updatecallback_t callback, void *callback_arg);
/*%<
 * Forward 'msg' to each master in turn until we get an answer or we
 * have exausted the list of masters. 'callback' will be called with
 * ISC_R_SUCCESS if we get an answer and the returned message will be
 * passed as 'answer_message', otherwise a non ISC_R_SUCCESS result code
 * will be passed and answer_message will be NULL.  The callback function
 * is responsible for destroying 'answer_message'.
 *		(callback)(callback_arg, result, answer_message);
 *
 * Require:
 *\li	'zone' to be valid
 *\li	'msg' to be valid.
 *\li	'callback' to be non NULL.
 * Returns:
 *\li	#ISC_R_SUCCESS if the message has been forwarded,
 *\li	#ISC_R_NOMEMORY
 *\li	Others
 */

isc_result_t
dns_zone_next(dns_zone_t *zone, dns_zone_t **next);
/*%<
 * Find the next zone in the list of managed zones.
 *
 * Requires:
 *\li	'zone' to be valid
 *\li	The zone manager for the indicated zone MUST be locked
 *	by the caller.  This is not checked.
 *\li	'next' be non-NULL, and '*next' be NULL.
 *
 * Ensures:
 *\li	'next' points to a valid zone (result ISC_R_SUCCESS) or to NULL
 *	(result ISC_R_NOMORE).
 */

isc_result_t
dns_zone_first(dns_zonemgr_t *zmgr, dns_zone_t **first);
/*%<
 * Find the first zone in the list of managed zones.
 *
 * Requires:
 *\li	'zonemgr' to be valid
 *\li	The zone manager for the indicated zone MUST be locked
 *	by the caller.  This is not checked.
 *\li	'first' be non-NULL, and '*first' be NULL
 *
 * Ensures:
 *\li	'first' points to a valid zone (result ISC_R_SUCCESS) or to NULL
 *	(result ISC_R_NOMORE).
 */

isc_result_t
dns_zone_setkeydirectory(dns_zone_t *zone, const char *directory);
/*%<
 *	Sets the name of the directory where private keys used for
 *	online signing of dynamic zones are found.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *
 * Returns:
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_SUCCESS
 */

const char *
dns_zone_getkeydirectory(dns_zone_t *zone);
/*%<
 * 	Gets the name of the directory where private keys used for
 *	online signing of dynamic zones are found.
 *
 * Requires:
 *\li	'zone' to be valid initialised zone.
 *
 * Returns:
 *	Pointer to null-terminated file name, or NULL.
 */


isc_result_t
dns_zonemgr_create(isc_mem_t *mctx, isc_taskmgr_t *taskmgr,
		   isc_timermgr_t *timermgr, isc_socketmgr_t *socketmgr,
		   dns_zonemgr_t **zmgrp);
/*%<
 * Create a zone manager.
 *
 * Requires:
 *\li	'mctx' to be a valid memory context.
 *\li	'taskmgr' to be a valid task manager.
 *\li	'timermgr' to be a valid timer manager.
 *\li	'zmgrp'	to point to a NULL pointer.
 */

isc_result_t
dns_zonemgr_managezone(dns_zonemgr_t *zmgr, dns_zone_t *zone);
/*%<
 *	Bring the zone under control of a zone manager.
 *
 * Require:
 *\li	'zmgr' to be a valid zone manager.
 *\li	'zone' to be a valid zone.
 */

isc_result_t
dns_zonemgr_forcemaint(dns_zonemgr_t *zmgr);
/*%<
 * Force zone maintenance of all zones managed by 'zmgr' at its
 * earliest conveniene.
 */

void
dns_zonemgr_resumexfrs(dns_zonemgr_t *zmgr);
/*%<
 * Attempt to start any stalled zone transfers.
 */

void
dns_zonemgr_shutdown(dns_zonemgr_t *zmgr);
/*%<
 *	Shut down the zone manager.
 *
 * Requires:
 *\li	'zmgr' to be a valid zone manager.
 */

void
dns_zonemgr_attach(dns_zonemgr_t *source, dns_zonemgr_t **target);
/*%<
 *	Attach '*target' to 'source' incrementing its external
 * 	reference count.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'target' to be non NULL and '*target' to be NULL.
 */

void
dns_zonemgr_detach(dns_zonemgr_t **zmgrp);
/*%<
 *	 Detach from a zone manager.
 *
 * Requires:
 *\li	'*zmgrp' is a valid, non-NULL zone manager pointer.
 *
 * Ensures:
 *\li	'*zmgrp' is NULL.
 */

void
dns_zonemgr_releasezone(dns_zonemgr_t *zmgr, dns_zone_t *zone);
/*%<
 *	Release 'zone' from the managed by 'zmgr'.  'zmgr' is implicitly
 *	detached from 'zone'.
 *
 * Requires:
 *\li	'zmgr' to be a valid zone manager.
 *\li	'zone' to be a valid zone.
 *\li	'zmgr' == 'zone->zmgr'
 *
 * Ensures:
 *\li	'zone->zmgr' == NULL;
 */

void
dns_zonemgr_settransfersin(dns_zonemgr_t *zmgr, isc_uint32_t value);
/*%<
 *	Set the maximum number of simultaneous transfers in allowed by
 *	the zone manager.
 *
 * Requires:
 *\li	'zmgr' to be a valid zone manager.
 */

isc_uint32_t
dns_zonemgr_getttransfersin(dns_zonemgr_t *zmgr);
/*%<
 *	Return the the maximum number of simultaneous transfers in allowed.
 *
 * Requires:
 *\li	'zmgr' to be a valid zone manager.
 */

void
dns_zonemgr_settransfersperns(dns_zonemgr_t *zmgr, isc_uint32_t value);
/*%<
 *	Set the number of zone transfers allowed per nameserver.
 *
 * Requires:
 *\li	'zmgr' to be a valid zone manager
 */

isc_uint32_t
dns_zonemgr_getttransfersperns(dns_zonemgr_t *zmgr);
/*%<
 *	Return the number of transfers allowed per nameserver.
 *
 * Requires:
 *\li	'zmgr' to be a valid zone manager.
 */

void
dns_zonemgr_setiolimit(dns_zonemgr_t *zmgr, isc_uint32_t iolimit);
/*%<
 *	Set the number of simultaneous file descriptors available for 
 *	reading and writing masterfiles.
 *
 * Requires:
 *\li	'zmgr' to be a valid zone manager.
 *\li	'iolimit' to be positive.
 */

isc_uint32_t
dns_zonemgr_getiolimit(dns_zonemgr_t *zmgr);
/*%<
 *	Get the number of simultaneous file descriptors available for 
 *	reading and writing masterfiles.
 *
 * Requires:
 *\li	'zmgr' to be a valid zone manager.
 */

void
dns_zonemgr_setserialqueryrate(dns_zonemgr_t *zmgr, unsigned int value);
/*%<
 *	Set the number of SOA queries sent per second.
 *
 * Requires:
 *\li	'zmgr' to be a valid zone manager
 */

unsigned int
dns_zonemgr_getserialqueryrate(dns_zonemgr_t *zmgr);
/*%<
 *	Return the number of SOA queries sent per second.
 *
 * Requires:
 *\li	'zmgr' to be a valid zone manager.
 */

unsigned int
dns_zonemgr_getcount(dns_zonemgr_t *zmgr, int state);
/*%<
 *	Returns the number of zones in the specified state.
 *
 * Requires:
 *\li	'zmgr' to be a valid zone manager.
 *\li	'state' to be a valid DNS_ZONESTATE_ constant.
 */

void
dns_zone_forcereload(dns_zone_t *zone);
/*%<
 *      Force a reload of specified zone.
 *
 * Requires:
 *\li      'zone' to be a valid zone.
 */

isc_boolean_t
dns_zone_isforced(dns_zone_t *zone);
/*%<
 *      Check if the zone is waiting a forced reload.
 *
 * Requires:
 * \li     'zone' to be a valid zone.
 */

isc_result_t
dns_zone_setstatistics(dns_zone_t *zone, isc_boolean_t on);
/*%<
 *      Make the zone keep or not keep an array of statistics
 * 	counter.
 *
 * Requires:
 *   \li   zone be a valid zone.
 */

isc_uint64_t *
dns_zone_getstatscounters(dns_zone_t *zone);
/*%<
 * Requires:
 *      zone be a valid zone.
 *
 * Returns:
 * \li     A pointer to the zone's array of statistics counters,
 *	or NULL if it has none.
 */

void
dns_zone_dialup(dns_zone_t *zone);
/*%<
 * Perform dialup-time maintenance on 'zone'.
 */

void
dns_zone_setdialup(dns_zone_t *zone, dns_dialuptype_t dialup);
/*%<
 * Set the dialup type of 'zone' to 'dialup'.
 *
 * Requires:
 * \li	'zone' to be valid initialised zone.
 *\li	'dialup' to be a valid dialup type.
 */

void
dns_zone_log(dns_zone_t *zone, int level, const char *msg, ...)
	ISC_FORMAT_PRINTF(3, 4);
/*%<
 * Log the message 'msg...' at 'level', including text that identifies
 * the message as applying to 'zone'.
 */

void
dns_zone_logc(dns_zone_t *zone, isc_logcategory_t *category, int level,
	      const char *msg, ...) ISC_FORMAT_PRINTF(4, 5);
/*%<
 * Log the message 'msg...' at 'level', including text that identifies
 * the message as applying to 'zone'.
 */

void
dns_zone_name(dns_zone_t *zone, char *buf, size_t len);
/*%<
 * Return the name of the zone with class and view.
 * 
 * Requires:
 *\li	'zone' to be valid.
 *\li	'buf' to be non NULL.
 */

isc_result_t
dns_zone_checknames(dns_zone_t *zone, dns_name_t *name, dns_rdata_t *rdata);
/*
 * Check if this record meets the check-names policy.
 *
 * Requires:
 *	'zone' to be valid.
 *	'name' to be valid.
 *	'rdata' to be valid.
 *
 * Returns:
 *	DNS_R_SUCCESS		passed checks.
 *	DNS_R_BADOWNERNAME	failed ownername checks.
 *	DNS_R_BADNAME		failed rdata checks.
 */

void
dns_zone_setacache(dns_zone_t *zone, dns_acache_t *acache);
/*
 *	Associate the zone with an additional cache.
 *
 * Require:
 *	'zone' to be a valid zone.
 *	'acache' to be a non NULL pointer.
 *
 * Ensures:
 *	'zone' will have a reference to 'acache'
 */

void
dns_zone_setcheckmx(dns_zone_t *zone, dns_checkmxfunc_t checkmx);
/*
 *	Set the post load integrity callback function 'checkmx'.
 *	'checkmx' will be called if the MX is not within the zone.
 *
 * Require:
 *	'zone' to be a valid zone.
 */

void
dns_zone_setchecksrv(dns_zone_t *zone, dns_checkmxfunc_t checksrv);
/*
 *	Set the post load integrity callback function 'checksrv'.
 *	'checksrv' will be called if the SRV TARGET is not within the zone.
 *
 * Require:
 *	'zone' to be a valid zone.
 */

void
dns_zone_setcheckns(dns_zone_t *zone, dns_checknsfunc_t checkns);
/*
 *	Set the post load integrity callback function 'checkmx'.
 *	'checkmx' will be called if the MX is not within the zone.
 *
 * Require:
 *	'zone' to be a valid zone.
 */

void
dns_zone_setnotifydelay(dns_zone_t *zone, isc_uint32_t delay);
/*
 * Set the minimum delay between sets of notify messages.
 *
 * Requires:
 *	'zone' to be valid.
 */

isc_uint32_t
dns_zone_getnotifydelay(dns_zone_t *zone);
/*
 * Get the minimum delay between sets of notify messages.
 *
 * Requires:
 *	'zone' to be valid.
 */

void
dns_zone_setisself(dns_zone_t *zone, dns_isselffunc_t isself, void *arg);
/*
 * Set the isself callback function and argument.
 *
 * isc_boolean_t
 * isself(dns_view_t *myview, dns_tsigkey_t *mykey, isc_netaddr_t *srcaddr,
 *	  isc_netaddr_t *destaddr, dns_rdataclass_t rdclass, void *arg);
 *
 * 'isself' returns ISC_TRUE if a non-recursive query from 'srcaddr' to
 * 'destaddr' with optional key 'mykey' for class 'rdclass' would be
 * delivered to 'myview'.
 */

ISC_LANG_ENDDECLS

#endif /* DNS_ZONE_H */
@


1.7
log
@resolve conflicts and regen configure script
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: zone.h,v 1.106.2.7.4.18 2006/08/01 03:44:00 marka Exp $ */
d23 2
d35 1
d45 24
a68 13
#define DNS_ZONEOPT_SERVERS	  0x00000001U	/* perform server checks */
#define DNS_ZONEOPT_PARENTS	  0x00000002U	/* perform parent checks */
#define DNS_ZONEOPT_CHILDREN	  0x00000004U	/* perform child checks */
#define DNS_ZONEOPT_NOTIFY	  0x00000008U	/* perform NOTIFY */
#define DNS_ZONEOPT_MANYERRORS	  0x00000010U	/* return many errors on load */
#define DNS_ZONEOPT_IXFRFROMDIFFS 0x00000020U	/* calculate differences */
#define DNS_ZONEOPT_NOMERGE	  0x00000040U	/* don't merge journal */
#define DNS_ZONEOPT_CHECKNS	  0x00000080U	/* check if NS's are addresses */
#define DNS_ZONEOPT_FATALNS	  0x00000100U	/* DNS_ZONEOPT_CHECKNS is fatal */
#define DNS_ZONEOPT_MULTIMASTER	  0x00000200U	/* this zone has multiple masters */
#define DNS_ZONEOPT_USEALTXFRSRC  0x00000400U	/* use alternate transfer sources */
#define DNS_ZONEOPT_CHECKNAMES	  0x00000800U	/* check-names */
#define DNS_ZONEOPT_CHECKNAMESFAIL 0x00001000U	/* fatal check-name failures */
d78 1
a78 1
#define DNS_ZONE_MINREFRESH		    300	/* 5 minutes */
d81 1
a81 1
#define DNS_ZONE_MAXREFRESH		2419200	/* 4 weeks */
d84 1
a84 1
#define DNS_ZONE_DEFAULTREFRESH		   3600	/* 1 hour */
d87 1
a87 1
#define DNS_ZONE_MINRETRY		    300	/* 5 minutes */
d90 1
a90 1
#define DNS_ZONE_MAXRETRY		1209600	/* 2 weeks */
d93 1
a93 1
#define DNS_ZONE_DEFAULTRETRY		     60	/* 1 minute, subject to
d110 1
a110 1
/*
d114 2
a115 2
 *	'zonep' to point to a NULL pointer.
 *	'mctx' to be a valid memory context.
d118 1
a118 1
 *	'*zonep' refers to a valid zone.
d121 3
a123 3
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
 *	ISC_R_UNEXPECTED
d128 1
a128 1
/*
d133 2
a134 2
 *	'zone' to be a valid zone.
 *	dns_zone_setclass() not to have been called since the zone was
d136 1
a136 1
 *	'rdclass' != dns_rdataclass_none.
d141 1
a141 1
/*
d145 1
a145 1
 *	'zone' to be a valid zone.
d150 1
a150 1
/*
d155 2
a156 2
 *	'zone' to be a valid zone.
 *	dns_zone_settype() not to have been called since the zone was
d158 1
a158 1
 *	'type' != dns_zone_none
d163 1
a163 1
/*
d167 1
a167 1
 *	'zone' to be a valid zone.
d172 1
a172 1
/*
d176 1
a176 1
 *	'zone' to be a valid zone.
d181 1
a181 1
/*
d185 2
a186 2
 *	'zone' to be a valid zone.
 *	'origin' to be non NULL.
d189 2
a190 2
 *	ISC_R_SUCCESS
 * 	ISC_R_NOMEMORY
d195 1
a195 1
/*
d199 1
a199 1
 *	'zone' to be a valid zone.
d204 9
a212 4
/*
 *	Sets the name of the master file from which the zone
 *	loads its database to 'file'.  For zones that have
 *	no associated master file, 'file' will be NULL.
d217 4
d222 1
a222 1
 *	'zone' to be a valid zone.
d225 2
a226 2
 *	ISC_R_NOMEMORY
 *	ISC_R_SUCCESS
d231 1
a231 1
/*
d235 1
a235 1
 *	'zone' to be valid initialised zone.
d238 1
a238 1
 *	Pointer to null-terminated file name, or NULL.
d246 1
a246 1
/*
d256 1
a256 1
 *	'zone' to be a valid zone.
d259 4
a262 4
 *	ISC_R_UNEXPECTED
 *	ISC_R_SUCCESS
 *	DNS_R_CONTINUE	  Incremental load has been queued.
 *	DNS_R_UPTODATE	  The zone has already been loaded based on
d264 2
a265 2
 *	DNS_R_BADZONE
 *	Any result value from dns_db_load().
d270 1
a270 1
/*
d275 2
a276 2
 *	'zone' to be a valid zone.
 *	'target' to be non NULL and '*target' to be NULL.
d281 1
a281 1
/*
d287 1
a287 1
 *	'zonep' to point to a valid zone.
d292 1
a292 1
/*
d299 3
a301 3
 *	The caller is running in the context of the zone's task.
 *	'zone' to be a valid zone.
 *	'target' to be non NULL and '*target' to be NULL.
d306 1
a306 1
/*
d312 2
a313 2
 *	The caller is running in the context of the zone's task.
 *	'zonep' to point to a valid zone.
d318 1
a318 1
/*
d323 1
a323 1
 *	'zone' to be a valid zone.
d328 1
a328 1
/*
d333 2
a334 2
 *	'zone' to be a valid zone.
 *	'dbp' to be != NULL && '*dbp' == NULL.
d337 2
a338 2
 *	ISC_R_SUCCESS
 *	DNS_R_NOTLOADED
d344 1
a344 1
/*
d350 20
a369 4
 *	'zone' to be a valid zone.
 *	'database' to be non NULL.
 *	'dbargc' to be >= 1
 *	'dbargv' to point to dbargc NULL-terminated strings
d372 2
a373 2
 *	ISC_R_NOMEMORY
 *	ISC_R_SUCCESS
d378 1
a378 1
/*
d382 1
a382 1
 *	'zone' to be a valid zone.
d387 1
a387 1
/*
d393 1
a393 1
 *	'zone' to be a valid zone.
d398 1
a398 1
/*
d403 1
a403 1
 *	'zone' to be a valid zone.
d408 1
a408 1
/*
d412 1
a412 1
 *	'zone' to be a valid zone.
d417 1
a417 1
/*
d421 1
a421 1
 *	'zone' to be a valid zone.
d426 15
a440 2
/*
 *	Write the zone to stream 'fd'.
d443 2
a444 2
 *	'zone' to be a valid zone.
 *	'fd' to be a stream open for writing.
d449 1
a449 1
/*
d454 2
a455 2
 *	'zone' to be a valid zone.
 *	'fd' to be a stream open for writing.
d460 1
a460 1
/*
d465 1
a465 1
 *	'zone' to be a valid zone.
d476 1
a476 1
/*
d480 4
a483 4
 *	'zone' to be a valid zone.
 *	'masters' array of isc_sockaddr_t with port set or NULL.
 *	'count' the number of masters.
 *      'keynames' array of dns_name_t's for tsig keys or NULL.
d485 1
a485 1
 *      dns_zone_setmasters() is just a wrapper to setmasterswithkeys(),
d488 1
a488 1
 * 	If 'masters' is NULL then 'count' must be zero.
d491 3
a493 3
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
 *      Any result dns_name_dup() can return, if keynames!=NULL
d499 1
a499 1
/*
d504 3
a506 3
 *	'zone' to be a valid zone.
 *	'notify' to be non-NULL if count != 0.
 *	'count' to be the number of notifyees.
d509 2
a510 2
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
d515 1
a515 1
/*
d519 1
a519 1
 *	'zone' to be a valid zone.
d524 1
a524 1
/*
d526 1
a526 1
 *	ISC_FALSE).
d529 1
a529 1
 *	'zone' to be a valid zone.
d534 1
a534 1
/*
d538 1
a538 1
 *	'zone' to be a valid zone.
d543 1
a543 1
/*
d547 2
a548 2
 *	'zone' is valid.
 *	val > 0.
d553 1
a553 1
/*
d557 2
a558 2
 *	'zone' is valid.
 *	val > 0.
d563 1
a563 1
/*
d567 2
a568 2
 *	'zone' is valid.
 *	val > 0.
d573 1
a573 1
/*
d577 1
a577 1
 *	'zone' is valid.
d586 1
a586 1
/*
d590 2
a591 2
 *	'zone' to be a valid zone.
 *	'xfrsource' to contain the address.
d594 1
a594 1
 *	ISC_R_SUCCESS
d601 1
a601 1
/*
d606 1
a606 1
 *	'zone' to be a valid zone.
d613 2
a614 2
			 const isc_sockaddr_t *xfrsource);
/*
d618 2
a619 2
 *	'zone' to be a valid zone.
 *	'xfrsource' to contain the address.
d622 1
a622 1
 *	ISC_R_SUCCESS
d629 1
a629 1
/*
d634 1
a634 1
 *	'zone' to be a valid zone.
d639 1
a639 1
/*
d643 2
a644 2
 *	'zone' to be a valid zone.
 *	'notifysrc' to contain the address.
d647 1
a647 1
 *	ISC_R_SUCCESS
d652 1
a652 1
/*
d657 1
a657 1
 *	'zone' to be a valid zone.
d662 1
a662 1
/*
d666 2
a667 2
 *	'zone' to be a valid zone.
 *	'notifysrc' to contain the address.
d670 1
a670 1
 *	ISC_R_SUCCESS
d675 1
a675 1
/*
d680 1
a680 1
 *	'zone' to be a valid zone.
d685 1
a685 1
/*
d689 2
a690 2
 *	'zone' to be a valid zone.
 *	'acl' to be a valid acl.
d695 1
a695 1
/*
d699 2
a700 2
 *	'zone' to be a valid zone.
 *	'acl' to be a valid acl.
d705 1
a705 1
/*
d709 2
a710 2
 *	'zone' to be a valid zone.
 *	'acl' to be valid acl.
d715 1
a715 1
/*
d719 2
a720 2
 *	'zone' to be a valid zone.
 *	'acl' to be valid acl.
d725 1
a725 1
/*
d729 2
a730 2
 *	'zone' to be a valid zone.
 *	'acl' to be valid acl.
d735 1
a735 1
/*
d739 1
a739 1
 *	'zone' to be a valid zone.
d742 2
a743 2
 *	acl a pointer to the acl.
 *	NULL
d748 1
a748 1
/*
d752 1
a752 1
 *	'zone' to be a valid zone.
d755 2
a756 2
 *	acl a pointer to the acl.
 *	NULL
d761 1
a761 1
/*
d765 1
a765 1
 *	'zone' to be a valid zone.
d768 2
a769 2
 *	acl a pointer to the acl.
 *	NULL
d774 1
a774 1
/*
d778 1
a778 1
 *	'zone' to be a valid zone.
d781 2
a782 2
 *	acl a pointer to the acl.
 *	NULL
d787 1
a787 1
/*
d791 1
a791 1
 *	'zone' to be a valid zone.
d794 2
a795 2
 *	acl a pointer to the acl.
 *	NULL
d800 1
a800 1
/*
d804 1
a804 1
 *	'zone' to be a valid zone.
d809 1
a809 1
/*
d813 1
a813 1
 *	'zone' to be a valid zone.
d818 1
a818 1
/*
d822 1
a822 1
 *	'zone' to be a valid zone.
d827 1
a827 1
/*
d831 1
a831 1
 *	'zone' to be a valid zone.
d836 1
a836 1
/*
d840 1
a840 1
 *	'zone' to be a valid zone.
d845 3
d851 15
d869 1
a869 1
/*
d873 1
a873 1
 *      'zone' to be a valid zone.
d878 1
a878 1
/*
d882 1
a882 1
 *	'zone' to be a valid zone.
d887 1
a887 1
/*
d891 1
a891 1
 *	'zone' to be a valid zone.
d896 1
a896 1
/*
d901 1
a901 1
 *	'zone' to be a valid zone.
d907 1
a907 1
/*
d912 2
a913 2
 *	'zone' to be a valid zone.
 *	'*from' to contain the address of the server from which 'msg'
d915 1
a915 1
 *	'msg' a message with opcode NOTIFY and qr clear.
d918 4
a921 4
 *	DNS_R_REFUSED
 *	DNS_R_NOTIMP
 *	DNS_R_FORMERR
 *	DNS_R_SUCCESS
d926 1
a926 1
/*
d931 1
a931 1
 * 	'zone' to be valid initialised zone.
d936 1
a936 1
/*
d942 1
a942 1
 *	'zone' to be valid initialised zone.
d947 1
a947 1
/*
d952 1
a952 1
 * 	'zone' to be valid initialised zone.
d957 1
a957 1
/*
d963 1
a963 1
 *	'zone' to be valid initialised zone.
d968 1
a968 1
/*
d975 1
a975 1
 *	'zone' to be a valid zone.
d978 2
a979 2
 *	ISC_R_SUCCESS
 *	ISC_R_NOMEMORY
d984 1
a984 1
/*
d989 1
a989 1
 *	'zone' to be valid initialised zone.
d994 1
a994 1
/*
d998 1
a998 1
 *	'zone' to be valid initialised zone.
d1003 1
a1003 1
/*
d1007 2
a1008 2
 *	'zone' to be valid.
 *	'task' to be valid.
d1013 1
a1013 1
/*
d1017 3
a1019 3
 *	'zone' to be valid initialised zone.
 *	'zone' to have a task.
 *	'target' to be != NULL && '*target' == NULL.
d1024 1
a1024 1
/*
d1028 1
a1028 1
 *	'zone' to be a valid zone.
d1033 1
a1033 1
/*
d1047 1
a1047 1
 *	'zone' to be a valid zone.
d1050 2
a1051 2
 *	DNS_R_SUCCESS
 *	DNS_R_BADZONE	zone failed basic consistancy checks:
d1059 1
a1059 1
/*
d1061 1
a1061 1
 *	'zone' to be a valid zone.
d1064 1
a1064 1
 *	number of seconds of idle time before we abort the transfer in.
d1069 3
a1071 3
/*
 *	Set the idle timeout for transfer the.
 *	Zero set the default value, 1 hour.
d1074 1
a1074 1
 *	'zone' to be a valid zone.
d1079 1
a1079 1
/*
d1082 1
a1082 1
 *	'zone' to be a valid zone.
d1085 1
a1085 1
 *	number of seconds of idle time before we abort a transfer out.
d1090 3
a1092 3
/*
 *	Set the idle timeout for transfers out.
 *	Zero set the default value, 1 hour.
d1095 1
a1095 1
 *	'zone' to be a valid zone.
d1100 1
a1100 1
/*
d1104 1
a1104 1
 *	'zone' to be a valid zone.
d1109 1
a1109 1
/*
d1113 1
a1113 1
 *	'zone' to be a valid zone.
d1118 1
a1118 1
/*
d1122 1
a1122 1
 *	'zone' to be a valid zone.
d1127 1
a1127 1
/*
d1131 1
a1131 1
 *	'zone' to be a valid zone.
d1136 1
a1136 1
/*
d1142 1
a1142 1
 *	'zone' to be a valid zone.
d1147 1
a1147 1
/*
d1151 1
a1151 1
 *	'zone' to be a valid zone.
d1156 1
a1156 1
/*
d1163 1
a1163 1
/*
d1173 7
a1179 7
 *	'zone' to be valid
 *	'msg' to be valid.
 *	'callback' to be non NULL.
 * Returns:
 *	ISC_R_SUCCESS if the message has been forwarded,
 *	ISC_R_NOMEMORY
 *	Others
d1184 1
a1184 1
/*
d1188 2
a1189 2
 *	'zone' to be valid
 *	The zone manager for the indicated zone MUST be locked
d1191 1
a1191 1
 *	'next' be non-NULL, and '*next' be NULL.
d1194 1
a1194 1
 *	'next' points to a valid zone (result ISC_R_SUCCESS) or to NULL
d1200 1
a1200 1
/*
d1204 2
a1205 2
 *	'zonemgr' to be valid
 *	The zone manager for the indicated zone MUST be locked
d1207 1
a1207 1
 *	'first' be non-NULL, and '*first' be NULL
d1210 1
a1210 1
 *	'first' points to a valid zone (result ISC_R_SUCCESS) or to NULL
d1216 1
a1216 1
/*
d1221 1
a1221 1
 *	'zone' to be a valid zone.
d1224 2
a1225 2
 *	ISC_R_NOMEMORY
 *	ISC_R_SUCCESS
d1230 1
a1230 1
/*
d1235 1
a1235 1
 *	'zone' to be valid initialised zone.
d1246 1
a1246 1
/*
d1250 4
a1253 4
 *	'mctx' to be a valid memory context.
 *	'taskmgr' to be a valid task manager.
 *	'timermgr' to be a valid timer manager.
 *	'zmgrp'	to point to a NULL pointer.
d1258 1
a1258 1
/*
d1262 2
a1263 2
 *	'zmgr' to be a valid zone manager.
 *	'zone' to be a valid zone.
d1268 1
a1268 1
/*
d1275 1
a1275 1
/*
d1281 1
a1281 1
/*
d1285 1
a1285 1
 *	'zmgr' to be a valid zone manager.
d1290 1
a1290 1
/*
d1295 2
a1296 2
 *	'zone' to be a valid zone.
 *	'target' to be non NULL and '*target' to be NULL.
d1301 1
a1301 1
/*
d1305 1
a1305 1
 *	'*zmgrp' is a valid, non-NULL zone manager pointer.
d1308 1
a1308 1
 *	'*zmgrp' is NULL.
d1313 1
a1313 1
/*
d1318 3
a1320 3
 *	'zmgr' to be a valid zone manager.
 *	'zone' to be a valid zone.
 *	'zmgr' == 'zone->zmgr'
d1323 1
a1323 1
 *	'zone->zmgr' == NULL;
d1328 1
a1328 1
/*
d1333 1
a1333 1
 *	'zmgr' to be a valid zone manager.
d1338 1
a1338 1
/*
d1342 1
a1342 1
 *	'zmgr' to be a valid zone manager.
d1347 1
a1347 1
/*
d1351 1
a1351 1
 *	'zmgr' to be a valid zone manager
d1356 1
a1356 1
/*
d1360 1
a1360 1
 *	'zmgr' to be a valid zone manager.
d1365 1
a1365 1
/*
d1370 2
a1371 2
 *	'zmgr' to be a valid zone manager.
 *	'iolimit' to be positive.
d1376 1
a1376 1
/*
d1381 1
a1381 1
 *	'zmgr' to be a valid zone manager.
d1386 1
a1386 1
/*
d1390 1
a1390 1
 *	'zmgr' to be a valid zone manager
d1395 1
a1395 1
/*
d1399 1
a1399 1
 *	'zmgr' to be a valid zone manager.
d1404 1
a1404 1
/*
d1408 2
a1409 2
 *	'zmgr' to be a valid zone manager.
 *	'state' to be a valid DNS_ZONESTATE_ constant.
d1414 1
a1414 1
/*
d1418 1
a1418 1
 *      'zone' to be a valid zone.
d1423 1
a1423 1
/*
d1427 1
a1427 1
 *      'zone' to be a valid zone.
d1432 1
a1432 1
/*
d1437 1
a1437 1
 *      zone be a valid zone.
d1442 1
a1442 1
/*
d1447 1
a1447 1
 *      A pointer to the zone's array of statistics counters,
d1453 1
a1453 1
/*
d1459 1
a1459 1
/*
d1463 2
a1464 2
 * 	'zone' to be valid initialised zone.
 *	'dialup' to be a valid dialup type.
d1470 1
a1470 1
/*
d1478 1
a1478 1
/*
d1485 1
a1485 1
/*
d1489 2
a1490 2
 *	'zone' to be valid.
 *	'buf' to be non NULL.
d1507 75
@


1.6
log
@Tyop fix: simultanious
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: zone.h,v 1.106.2.7.4.15 2004/10/26 02:08:43 marka Exp $ */
d166 1
a166 1
dns_zone_setorigin(dns_zone_t *zone, dns_name_t *origin);
d417 1
a417 1
dns_zone_setmasters(dns_zone_t *zone, isc_sockaddr_t *masters,
d420 4
a423 2
dns_zone_setmasterswithkeys(dns_zone_t *zone, isc_sockaddr_t *masters,
			    dns_name_t **keynames, isc_uint32_t count);
d445 1
a445 1
dns_zone_setalsonotify(dns_zone_t *zone, isc_sockaddr_t *notify,
d530 1
a530 1
dns_zone_setxfrsource4(dns_zone_t *zone, isc_sockaddr_t *xfrsource);
d532 2
a533 1
dns_zone_setaltxfrsource4(dns_zone_t *zone, isc_sockaddr_t *xfrsource);
d558 1
a558 1
dns_zone_setxfrsource6(dns_zone_t *zone, isc_sockaddr_t *xfrsource);
d560 2
a561 1
dns_zone_setaltxfrsource6(dns_zone_t *zone, isc_sockaddr_t *xfrsource);
d586 1
a586 1
dns_zone_setnotifysrc4(dns_zone_t *zone, isc_sockaddr_t *notifysrc);
d609 1
a609 1
dns_zone_setnotifysrc6(dns_zone_t *zone, isc_sockaddr_t *notifysrc);
@


1.5
log
@resolve conflicts
@
text
@d1255 1
a1255 1
 *	Set the maximum number of simultanious transfers in allowed by
d1265 1
a1265 1
 *	Return the the maximum number of simultanious transfers in allowed.
@


1.4
log
@resolve conflicts
@
text
@d18 1
a18 1
/* $ISC: zone.h,v 1.106.2.7.4.14 2004/03/06 08:14:01 marka Exp $ */
d974 7
@


1.3
log
@update to BIND v9.2.3. ok todd@@
@
text
@d2 1
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: zone.h,v 1.106.2.7 2003/03/06 04:38:22 marka Exp $ */
d42 13
a54 6
#define DNS_ZONEOPT_SERVERS	0x00000001U	/* perform server checks */
#define DNS_ZONEOPT_PARENTS	0x00000002U	/* perform parent checks */
#define DNS_ZONEOPT_CHILDREN	0x00000004U	/* perform child checks */
#define DNS_ZONEOPT_NOTIFY	0x00000008U	/* perform NOTIFY */
#define DNS_ZONEOPT_MANYERRORS	0x00000010U	/* return many errors on load */
#define DNS_ZONEOPT_NOMERGE	0x00000040U	/* don't merge journal */
d238 3
d395 11
d452 1
a452 1
 *	'count' to be the number of notifyees
d529 2
d544 2
d556 2
d571 2
d787 6
d1134 28
d1193 6
d1392 34
@


1.2
log
@update to BIND 9.2.2-release. ok millert@@
@
text
@d18 1
a18 1
/* $ISC: zone.h,v 1.106.2.5.4.2 2003/02/17 07:05:10 marka Exp $ */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2002  Internet Software Consortium.
d18 1
a18 1
/* $ISC: zone.h,v 1.106.2.5 2002/07/11 05:44:08 marka Exp $ */
d218 1
a218 1
 *	Confirm that the mimimum requirements for the zone type are
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1999-2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: zone.h,v 1.106.2.7.4.14 2004/03/06 08:14:01 marka Exp $ */
d42 6
a47 13
#define DNS_ZONEOPT_SERVERS	  0x00000001U	/* perform server checks */
#define DNS_ZONEOPT_PARENTS	  0x00000002U	/* perform parent checks */
#define DNS_ZONEOPT_CHILDREN	  0x00000004U	/* perform child checks */
#define DNS_ZONEOPT_NOTIFY	  0x00000008U	/* perform NOTIFY */
#define DNS_ZONEOPT_MANYERRORS	  0x00000010U	/* return many errors on load */
#define DNS_ZONEOPT_IXFRFROMDIFFS 0x00000020U	/* calculate differences */
#define DNS_ZONEOPT_NOMERGE	  0x00000040U	/* don't merge journal */
#define DNS_ZONEOPT_CHECKNS	  0x00000080U	/* check if NS's are addresses */
#define DNS_ZONEOPT_FATALNS	  0x00000100U	/* DNS_ZONEOPT_CHECKNS is fatal */
#define DNS_ZONEOPT_MULTIMASTER	  0x00000200U	/* this zone has multiple masters */
#define DNS_ZONEOPT_USEALTXFRSRC  0x00000400U	/* use alternate transfer sources */
#define DNS_ZONEOPT_CHECKNAMES	  0x00000800U	/* check-names */
#define DNS_ZONEOPT_CHECKNAMESFAIL 0x00001000U	/* fatal check-name failures */
d218 1
a218 1
 *	Confirm that the minimum requirements for the zone type are
a230 3
 *	DNS_R_CONTINUE	  Incremental load has been queued.
 *	DNS_R_UPTODATE	  The zone has already been loaded based on
 *			  file system timestamps.
a384 11
isc_result_t
dns_zone_fulldumptostream(dns_zone_t *zone, FILE *fd);
/*
 *	The same as dns_zone_dumptostream, but dumps the zone with
 *	different dump settings (dns_master_style_full).
 *
 * Require:
 *	'zone' to be a valid zone.
 *	'fd' to be a stream open for writing.
 */

d431 1
a431 1
 *	'count' to be the number of notifyees.
a507 2
isc_result_t
dns_zone_setaltxfrsource4(dns_zone_t *zone, isc_sockaddr_t *xfrsource);
a520 2
isc_sockaddr_t *
dns_zone_getaltxfrsource4(dns_zone_t *zone);
a530 2
isc_result_t
dns_zone_setaltxfrsource6(dns_zone_t *zone, isc_sockaddr_t *xfrsource);
a543 2
isc_sockaddr_t *
dns_zone_getaltxfrsource6(dns_zone_t *zone);
a757 6
isc_boolean_t
dns_zone_getupdatedisabled(dns_zone_t *zone);

void
dns_zone_setupdatedisabled(dns_zone_t *zone, isc_boolean_t state);

a1098 28
dns_zone_setkeydirectory(dns_zone_t *zone, const char *directory);
/*
 *	Sets the name of the directory where private keys used for
 *	online signing of dynamic zones are found.
 *
 * Require:
 *	'zone' to be a valid zone.
 *
 * Returns:
 *	ISC_R_NOMEMORY
 *	ISC_R_SUCCESS
 */

const char *
dns_zone_getkeydirectory(dns_zone_t *zone);
/*
 * 	Gets the name of the directory where private keys used for
 *	online signing of dynamic zones are found.
 *
 * Requires:
 *	'zone' to be valid initialised zone.
 *
 * Returns:
 *	Pointer to null-terminated file name, or NULL.
 */


isc_result_t
a1129 6
dns_zonemgr_resumexfrs(dns_zonemgr_t *zmgr);
/*
 * Attempt to start any stalled zone transfers.
 */

void
a1322 34
 */

void
dns_zone_logc(dns_zone_t *zone, isc_logcategory_t *category, int level,
	      const char *msg, ...) ISC_FORMAT_PRINTF(4, 5);
/*
 * Log the message 'msg...' at 'level', including text that identifies
 * the message as applying to 'zone'.
 */

void
dns_zone_name(dns_zone_t *zone, char *buf, size_t len);
/*
 * Return the name of the zone with class and view.
 * 
 * Requires:
 *	'zone' to be valid.
 *	'buf' to be non NULL.
 */

isc_result_t
dns_zone_checknames(dns_zone_t *zone, dns_name_t *name, dns_rdata_t *rdata);
/*
 * Check if this record meets the check-names policy.
 *
 * Requires:
 *	'zone' to be valid.
 *	'name' to be valid.
 *	'rdata' to be valid.
 *
 * Returns:
 *	DNS_R_SUCCESS		passed checks.
 *	DNS_R_BADOWNERNAME	failed ownername checks.
 *	DNS_R_BADNAME		failed rdata checks.
@


1.1.1.3
log
@ISC BIND release 9.3.1. ok deraadt@@
@
text
@d18 1
a18 1
/* $ISC: zone.h,v 1.106.2.7.4.15 2004/10/26 02:08:43 marka Exp $ */
a973 7
 *
 * Returns:
 *	DNS_R_SUCCESS
 *	DNS_R_BADZONE	zone failed basic consistancy checks:
 *			* a single SOA must exist
 *			* some NS records must exist.
 *	Others
@


1.1.1.4
log
@ISC BIND release 9.3.3
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: zone.h,v 1.106.2.7.4.18 2006/08/01 03:44:00 marka Exp $ */
d166 1
a166 1
dns_zone_setorigin(dns_zone_t *zone, const dns_name_t *origin);
d417 1
a417 1
dns_zone_setmasters(dns_zone_t *zone, const isc_sockaddr_t *masters,
d420 2
a421 4
dns_zone_setmasterswithkeys(dns_zone_t *zone,
			    const isc_sockaddr_t *masters,
			    dns_name_t **keynames,
			    isc_uint32_t count);
d443 1
a443 1
dns_zone_setalsonotify(dns_zone_t *zone, const isc_sockaddr_t *notify,
d528 1
a528 1
dns_zone_setxfrsource4(dns_zone_t *zone, const isc_sockaddr_t *xfrsource);
d530 1
a530 2
dns_zone_setaltxfrsource4(dns_zone_t *zone,
			  const isc_sockaddr_t *xfrsource);
d555 1
a555 1
dns_zone_setxfrsource6(dns_zone_t *zone, const isc_sockaddr_t *xfrsource);
d557 1
a557 2
dns_zone_setaltxfrsource6(dns_zone_t *zone,
			 const isc_sockaddr_t *xfrsource);
d582 1
a582 1
dns_zone_setnotifysrc4(dns_zone_t *zone, const isc_sockaddr_t *notifysrc);
d605 1
a605 1
dns_zone_setnotifysrc6(dns_zone_t *zone, const isc_sockaddr_t *notifysrc);
d1255 1
a1255 1
 *	Set the maximum number of simultaneous transfers in allowed by
d1265 1
a1265 1
 *	Return the the maximum number of simultaneous transfers in allowed.
@


1.1.1.5
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: zone.h,v 1.126.18.19 2006/08/01 03:45:21 marka Exp $ */
a22 2
/*! \file */

a32 1
#include <dns/masterdump.h>
d42 13
a54 24
#define DNS_ZONEOPT_SERVERS	  0x00000001U	/*%< perform server checks */
#define DNS_ZONEOPT_PARENTS	  0x00000002U	/*%< perform parent checks */
#define DNS_ZONEOPT_CHILDREN	  0x00000004U	/*%< perform child checks */
#define DNS_ZONEOPT_NOTIFY	  0x00000008U	/*%< perform NOTIFY */
#define DNS_ZONEOPT_MANYERRORS	  0x00000010U	/*%< return many errors on load */
#define DNS_ZONEOPT_IXFRFROMDIFFS 0x00000020U	/*%< calculate differences */
#define DNS_ZONEOPT_NOMERGE	  0x00000040U	/*%< don't merge journal */
#define DNS_ZONEOPT_CHECKNS	  0x00000080U	/*%< check if NS's are addresses */
#define DNS_ZONEOPT_FATALNS	  0x00000100U	/*%< DNS_ZONEOPT_CHECKNS is fatal */
#define DNS_ZONEOPT_MULTIMASTER	  0x00000200U	/*%< this zone has multiple masters */
#define DNS_ZONEOPT_USEALTXFRSRC  0x00000400U	/*%< use alternate transfer sources */
#define DNS_ZONEOPT_CHECKNAMES	  0x00000800U	/*%< check-names */
#define DNS_ZONEOPT_CHECKNAMESFAIL 0x00001000U	/*%< fatal check-name failures */
#define DNS_ZONEOPT_CHECKWILDCARD 0x00002000U	/*%< check for internal wildcards */
#define DNS_ZONEOPT_CHECKMX	  0x00004000U	/*%< check-mx */
#define DNS_ZONEOPT_CHECKMXFAIL   0x00008000U	/*%< fatal check-mx failures */
#define DNS_ZONEOPT_CHECKINTEGRITY 0x00010000U	/*%< perform integrity checks */
#define DNS_ZONEOPT_CHECKSIBLING  0x00020000U	/*%< perform sibling glue checks */
#define DNS_ZONEOPT_NOCHECKNS	  0x00040000U	/*%< disable IN NS address checks */
#define DNS_ZONEOPT_WARNMXCNAME	  0x00080000U	/*%< warn on MX CNAME check */
#define DNS_ZONEOPT_IGNOREMXCNAME 0x00100000U	/*%< ignore MX CNAME check */
#define DNS_ZONEOPT_WARNSRVCNAME  0x00200000U	/*%< warn on SRV CNAME check */
#define DNS_ZONEOPT_IGNORESRVCNAME 0x00400000U	/*%< ignore SRV CNAME check */
#define DNS_ZONEOPT_UPDATECHECKKSK 0x00800000U	/*%< check dnskey KSK flag */
d64 1
a64 1
#define DNS_ZONE_MINREFRESH		    300	/*%< 5 minutes */
d67 1
a67 1
#define DNS_ZONE_MAXREFRESH		2419200	/*%< 4 weeks */
d70 1
a70 1
#define DNS_ZONE_DEFAULTREFRESH		   3600	/*%< 1 hour */
d73 1
a73 1
#define DNS_ZONE_MINRETRY		    300	/*%< 5 minutes */
d76 1
a76 1
#define DNS_ZONE_MAXRETRY		1209600	/*%< 2 weeks */
d79 1
a79 1
#define DNS_ZONE_DEFAULTRETRY		     60	/*%< 1 minute, subject to
d96 1
a96 1
/*%<
d100 2
a101 2
 *\li	'zonep' to point to a NULL pointer.
 *\li	'mctx' to be a valid memory context.
d104 1
a104 1
 *\li	'*zonep' refers to a valid zone.
d107 3
a109 3
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_UNEXPECTED
d114 1
a114 1
/*%<
d119 2
a120 2
 *\li	'zone' to be a valid zone.
 *\li	dns_zone_setclass() not to have been called since the zone was
d122 1
a122 1
 *\li	'rdclass' != dns_rdataclass_none.
d127 1
a127 1
/*%<
d131 1
a131 1
 *\li	'zone' to be a valid zone.
d136 1
a136 1
/*%<
d141 2
a142 2
 *\li	'zone' to be a valid zone.
 *\li	dns_zone_settype() not to have been called since the zone was
d144 1
a144 1
 *\li	'type' != dns_zone_none
d149 1
a149 1
/*%<
d153 1
a153 1
 *\li	'zone' to be a valid zone.
d158 1
a158 1
/*%<
d162 1
a162 1
 *\li	'zone' to be a valid zone.
d167 1
a167 1
/*%<
d171 2
a172 2
 *\li	'zone' to be a valid zone.
 *\li	'origin' to be non NULL.
d175 2
a176 2
 *\li	#ISC_R_SUCCESS
 *\li 	#ISC_R_NOMEMORY
d181 1
a181 1
/*%<
d185 1
a185 1
 *\li	'zone' to be a valid zone.
d190 4
a193 9

isc_result_t
dns_zone_setfile2(dns_zone_t *zone, const char *file,
		  dns_masterformat_t format);
/*%<
 *    Sets the name of the master file in the format of 'format' from which
 *    the zone loads its database to 'file'.
 *
 *    For zones that have no associated master file, 'file' will be NULL.
a197 4
 *    dns_zone_setfile() is a backward-compatible form of
 *    dns_zone_setfile2(), which always specifies the
 *    dns_masterformat_text (RFC1035) format.
 *
d199 1
a199 1
 *\li	'zone' to be a valid zone.
d202 2
a203 2
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_SUCCESS
d208 1
a208 1
/*%<
d212 1
a212 1
 *\li	'zone' to be valid initialised zone.
d215 1
a215 1
 *\li	Pointer to null-terminated file name, or NULL.
d223 1
a223 1
/*%<
d233 1
a233 1
 *\li	'zone' to be a valid zone.
d236 4
a239 4
 *\li	#ISC_R_UNEXPECTED
 *\li	#ISC_R_SUCCESS
 *\li	DNS_R_CONTINUE	  Incremental load has been queued.
 *\li	DNS_R_UPTODATE	  The zone has already been loaded based on
d241 2
a242 2
 *\li	DNS_R_BADZONE
 *\li	Any result value from dns_db_load().
d247 1
a247 1
/*%<
d252 2
a253 2
 *\li	'zone' to be a valid zone.
 *\li	'target' to be non NULL and '*target' to be NULL.
d258 1
a258 1
/*%<
d264 1
a264 1
 *\li	'zonep' to point to a valid zone.
d269 1
a269 1
/*%<
d276 3
a278 3
 *\li	The caller is running in the context of the zone's task.
 *\li	'zone' to be a valid zone.
 *\li	'target' to be non NULL and '*target' to be NULL.
d283 1
a283 1
/*%<
d289 2
a290 2
 *\li	The caller is running in the context of the zone's task.
 *\li	'zonep' to point to a valid zone.
d295 1
a295 1
/*%<
d300 1
a300 1
 *\li	'zone' to be a valid zone.
d305 1
a305 1
/*%<
d310 2
a311 2
 *\li	'zone' to be a valid zone.
 *\li	'dbp' to be != NULL && '*dbp' == NULL.
d314 2
a315 2
 *\li	#ISC_R_SUCCESS
 *\li	DNS_R_NOTLOADED
d321 1
a321 1
/*%<
d327 4
a330 4
 *\li	'zone' to be a valid zone.
 *\li	'database' to be non NULL.
 *\li	'dbargc' to be >= 1
 *\li	'dbargv' to point to dbargc NULL-terminated strings
d333 2
a334 18
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_SUCCESS
 */

isc_result_t
dns_zone_getdbtype(dns_zone_t *zone, char ***argv, isc_mem_t *mctx);
/*%<
 *	Returns the current dbtype.  isc_mem_free() should be used
 * 	to free 'argv' after use.
 *
 * Require:
 *\li	'zone' to be a valid zone.
 *\li	'argv' to be non NULL and *argv to be NULL.
 *\li	'mctx' to be valid.
 *
 * Returns:
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_SUCCESS
d339 1
a339 1
/*%<
d343 1
a343 1
 *\li	'zone' to be a valid zone.
d348 1
a348 1
/*%<
d354 1
a354 1
 *\li	'zone' to be a valid zone.
d359 1
a359 1
/*%<
d364 1
a364 1
 *\li	'zone' to be a valid zone.
d369 1
a369 1
/*%<
d373 1
a373 1
 *\li	'zone' to be a valid zone.
d378 1
a378 1
/*%<
d382 1
a382 1
 *\li	'zone' to be a valid zone.
d387 2
a388 15

isc_result_t
dns_zone_dumptostream2(dns_zone_t *zone, FILE *fd, dns_masterformat_t format,
		       const dns_master_style_t *style);
/*%<
 *    Write the zone to stream 'fd' in the specified 'format'.
 *    If the 'format' is dns_masterformat_text (RFC1035), 'style' also
 *    specifies the file style (e.g., &dns_master_style_default).
 *
 *    dns_zone_dumptostream() is a backward-compatible form of
 *    dns_zone_dumptostream2(), which always uses the dns_masterformat_text
 *    format and the dns_master_style_default style.
 *
 *    Note that dns_zone_dumptostream2() is the most flexible form.  It
 *    can also provide the functionality of dns_zone_fulldumptostream().
d391 2
a392 2
 *\li	'zone' to be a valid zone.
 *\li	'fd' to be a stream open for writing.
d397 1
a397 1
/*%<
d402 2
a403 2
 *\li	'zone' to be a valid zone.
 *\li	'fd' to be a stream open for writing.
d408 1
a408 1
/*%<
d413 1
a413 1
 *\li	'zone' to be a valid zone.
d424 1
a424 1
/*%<
d428 4
a431 4
 *\li	'zone' to be a valid zone.
 *\li	'masters' array of isc_sockaddr_t with port set or NULL.
 *\li	'count' the number of masters.
 *\li      'keynames' array of dns_name_t's for tsig keys or NULL.
d433 1
a433 1
 *  \li    dns_zone_setmasters() is just a wrapper to setmasterswithkeys(),
d436 1
a436 1
 * \li	If 'masters' is NULL then 'count' must be zero.
d439 3
a441 3
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOMEMORY
 *\li      Any result dns_name_dup() can return, if keynames!=NULL
d447 1
a447 1
/*%<
d452 3
a454 3
 *\li	'zone' to be a valid zone.
 *\li	'notify' to be non-NULL if count != 0.
 *\li	'count' to be the number of notifyees.
d457 2
a458 2
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOMEMORY
d463 1
a463 1
/*%<
d467 1
a467 1
 *\li	'zone' to be a valid zone.
d472 1
a472 1
/*%<
d474 1
a474 1
 *	#ISC_FALSE).
d477 1
a477 1
 *\li	'zone' to be a valid zone.
d482 1
a482 1
/*%<
d486 1
a486 1
 *\li	'zone' to be a valid zone.
d491 1
a491 1
/*%<
d495 2
a496 2
 *\li	'zone' is valid.
 *\li	val > 0.
d501 1
a501 1
/*%<
d505 2
a506 2
 *\li	'zone' is valid.
 *\li	val > 0.
d511 1
a511 1
/*%<
d515 2
a516 2
 *\li	'zone' is valid.
 *\li	val > 0.
d521 1
a521 1
/*%<
d525 1
a525 1
 *\li	'zone' is valid.
d534 1
a534 1
/*%<
d538 2
a539 2
 *\li	'zone' to be a valid zone.
 *\li	'xfrsource' to contain the address.
d542 1
a542 1
 *\li	#ISC_R_SUCCESS
d549 1
a549 1
/*%<
d554 1
a554 1
 *\li	'zone' to be a valid zone.
d561 2
a562 2
			  const isc_sockaddr_t *xfrsource);
/*%<
d566 2
a567 2
 *\li	'zone' to be a valid zone.
 *\li	'xfrsource' to contain the address.
d570 1
a570 1
 *\li	#ISC_R_SUCCESS
d577 1
a577 1
/*%<
d582 1
a582 1
 *\li	'zone' to be a valid zone.
d587 1
a587 1
/*%<
d591 2
a592 2
 *\li	'zone' to be a valid zone.
 *\li	'notifysrc' to contain the address.
d595 1
a595 1
 *\li	#ISC_R_SUCCESS
d600 1
a600 1
/*%<
d605 1
a605 1
 *\li	'zone' to be a valid zone.
d610 1
a610 1
/*%<
d614 2
a615 2
 *\li	'zone' to be a valid zone.
 *\li	'notifysrc' to contain the address.
d618 1
a618 1
 *\li	#ISC_R_SUCCESS
d623 1
a623 1
/*%<
d628 1
a628 1
 *\li	'zone' to be a valid zone.
d633 1
a633 1
/*%<
d637 2
a638 2
 *\li	'zone' to be a valid zone.
 *\li	'acl' to be a valid acl.
d643 1
a643 1
/*%<
d647 2
a648 2
 *\li	'zone' to be a valid zone.
 *\li	'acl' to be a valid acl.
d653 1
a653 1
/*%<
d657 2
a658 2
 *\li	'zone' to be a valid zone.
 *\li	'acl' to be valid acl.
d663 1
a663 1
/*%<
d667 2
a668 2
 *\li	'zone' to be a valid zone.
 *\li	'acl' to be valid acl.
d673 1
a673 1
/*%<
d677 2
a678 2
 *\li	'zone' to be a valid zone.
 *\li	'acl' to be valid acl.
d683 1
a683 1
/*%<
d687 1
a687 1
 *\li	'zone' to be a valid zone.
d690 2
a691 2
 *\li	acl a pointer to the acl.
 *\li	NULL
d696 1
a696 1
/*%<
d700 1
a700 1
 *\li	'zone' to be a valid zone.
d703 2
a704 2
 *\li	acl a pointer to the acl.
 *\li	NULL
d709 1
a709 1
/*%<
d713 1
a713 1
 *\li	'zone' to be a valid zone.
d716 2
a717 2
 *\li	acl a pointer to the acl.
 *\li	NULL
d722 1
a722 1
/*%<
d726 1
a726 1
 *\li	'zone' to be a valid zone.
d729 2
a730 2
 *\li	acl a pointer to the acl.
 *\li	NULL
d735 1
a735 1
/*%<
d739 1
a739 1
 *\li	'zone' to be a valid zone.
d742 2
a743 2
 *\li	acl a pointer to the acl.
 *\li	NULL
d748 1
a748 1
/*%<
d752 1
a752 1
 *\li	'zone' to be a valid zone.
d757 1
a757 1
/*%<
d761 1
a761 1
 *\li	'zone' to be a valid zone.
d766 1
a766 1
/*%<
d770 1
a770 1
 *\li	'zone' to be a valid zone.
d775 1
a775 1
/*%<
d779 1
a779 1
 *\li	'zone' to be a valid zone.
d784 1
a784 1
/*%<
d788 1
a788 1
 *\li	'zone' to be a valid zone.
a792 3
/*%<
 * Return update disabled.
 */
a795 15
/*%<
 * Set update disabled.
 */

isc_boolean_t
dns_zone_getzeronosoattl(dns_zone_t *zone);
/*%<
 * Return zero-no-soa-ttl status.
 */

void
dns_zone_setzeronosoattl(dns_zone_t *zone, isc_boolean_t state);
/*%<
 * Set zero-no-soa-ttl status.
 */
d799 1
a799 1
/*%<
d803 1
a803 1
 * \li     'zone' to be a valid zone.
d808 1
a808 1
/*%<
d812 1
a812 1
 *\li	'zone' to be a valid zone.
d817 1
a817 1
/*%<
d821 1
a821 1
 *\li	'zone' to be a valid zone.
d826 1
a826 1
/*%<
d831 1
a831 1
 *\li	'zone' to be a valid zone.
d837 1
a837 1
/*%<
d842 2
a843 2
 *\li	'zone' to be a valid zone.
 *\li	'*from' to contain the address of the server from which 'msg'
d845 1
a845 1
 *\li	'msg' a message with opcode NOTIFY and qr clear.
d848 4
a851 4
 *\li	DNS_R_REFUSED
 *\li	DNS_R_NOTIMP
 *\li	DNS_R_FORMERR
 *\li	DNS_R_SUCCESS
d856 1
a856 1
/*%<
d861 1
a861 1
 * \li	'zone' to be valid initialised zone.
d866 1
a866 1
/*%<
d872 1
a872 1
 *\li	'zone' to be valid initialised zone.
d877 1
a877 1
/*%<
d882 1
a882 1
 * \li	'zone' to be valid initialised zone.
d887 1
a887 1
/*%<
d893 1
a893 1
 *\li	'zone' to be valid initialised zone.
d898 1
a898 1
/*%<
d905 1
a905 1
 *\li	'zone' to be a valid zone.
d908 2
a909 2
 *\li	#ISC_R_SUCCESS
 *\li	#ISC_R_NOMEMORY
d914 1
a914 1
/*%<
d919 1
a919 1
 *\li	'zone' to be valid initialised zone.
d924 1
a924 1
/*%<
d928 1
a928 1
 *\li	'zone' to be valid initialised zone.
d933 1
a933 1
/*%<
d937 2
a938 2
 *\li	'zone' to be valid.
 *\li	'task' to be valid.
d943 1
a943 1
/*%<
d947 3
a949 3
 *\li	'zone' to be valid initialised zone.
 *\li	'zone' to have a task.
 *\li	'target' to be != NULL && '*target' == NULL.
d954 1
a954 1
/*%<
d958 1
a958 1
 *\li	'zone' to be a valid zone.
d963 1
a963 1
/*%<
d977 1
a977 1
 * \li	'zone' to be a valid zone.
d980 2
a981 2
 * \li	DNS_R_SUCCESS
 * \li	DNS_R_BADZONE	zone failed basic consistancy checks:
d989 1
a989 1
/*%<
d991 1
a991 1
 * \li	'zone' to be a valid zone.
d994 1
a994 1
 * \li	number of seconds of idle time before we abort the transfer in.
d999 3
a1001 3
/*%<
 * \li	Set the idle timeout for transfer the.
 * \li	Zero set the default value, 1 hour.
d1004 1
a1004 1
 * \li	'zone' to be a valid zone.
d1009 1
a1009 1
/*%<
d1012 1
a1012 1
 * \li	'zone' to be a valid zone.
d1015 1
a1015 1
 * \li	number of seconds of idle time before we abort a transfer out.
d1020 3
a1022 3
/*%<
 * \li	Set the idle timeout for transfers out.
 * \li	Zero set the default value, 1 hour.
d1025 1
a1025 1
 * \li	'zone' to be a valid zone.
d1030 1
a1030 1
/*%<
d1034 1
a1034 1
 * \li	'zone' to be a valid zone.
d1039 1
a1039 1
/*%<
d1043 1
a1043 1
 * \li	'zone' to be a valid zone.
d1048 1
a1048 1
/*%<
d1052 1
a1052 1
 * \li	'zone' to be a valid zone.
d1057 1
a1057 1
/*%<
d1061 1
a1061 1
 * \li	'zone' to be a valid zone.
d1066 1
a1066 1
/*%<
d1072 1
a1072 1
 * \li	'zone' to be a valid zone.
d1077 1
a1077 1
/*%<
d1081 1
a1081 1
 * \li	'zone' to be a valid zone.
d1086 1
a1086 1
/*%<
d1093 1
a1093 1
/*%<
d1103 7
a1109 7
 *\li	'zone' to be valid
 *\li	'msg' to be valid.
 *\li	'callback' to be non NULL.
 * Returns:
 *\li	#ISC_R_SUCCESS if the message has been forwarded,
 *\li	#ISC_R_NOMEMORY
 *\li	Others
d1114 1
a1114 1
/*%<
d1118 2
a1119 2
 *\li	'zone' to be valid
 *\li	The zone manager for the indicated zone MUST be locked
d1121 1
a1121 1
 *\li	'next' be non-NULL, and '*next' be NULL.
d1124 1
a1124 1
 *\li	'next' points to a valid zone (result ISC_R_SUCCESS) or to NULL
d1130 1
a1130 1
/*%<
d1134 2
a1135 2
 *\li	'zonemgr' to be valid
 *\li	The zone manager for the indicated zone MUST be locked
d1137 1
a1137 1
 *\li	'first' be non-NULL, and '*first' be NULL
d1140 1
a1140 1
 *\li	'first' points to a valid zone (result ISC_R_SUCCESS) or to NULL
d1146 1
a1146 1
/*%<
d1151 1
a1151 1
 *\li	'zone' to be a valid zone.
d1154 2
a1155 2
 *\li	#ISC_R_NOMEMORY
 *\li	#ISC_R_SUCCESS
d1160 1
a1160 1
/*%<
d1165 1
a1165 1
 *\li	'zone' to be valid initialised zone.
d1176 1
a1176 1
/*%<
d1180 4
a1183 4
 *\li	'mctx' to be a valid memory context.
 *\li	'taskmgr' to be a valid task manager.
 *\li	'timermgr' to be a valid timer manager.
 *\li	'zmgrp'	to point to a NULL pointer.
d1188 1
a1188 1
/*%<
d1192 2
a1193 2
 *\li	'zmgr' to be a valid zone manager.
 *\li	'zone' to be a valid zone.
d1198 1
a1198 1
/*%<
d1205 1
a1205 1
/*%<
d1211 1
a1211 1
/*%<
d1215 1
a1215 1
 *\li	'zmgr' to be a valid zone manager.
d1220 1
a1220 1
/*%<
d1225 2
a1226 2
 *\li	'zone' to be a valid zone.
 *\li	'target' to be non NULL and '*target' to be NULL.
d1231 1
a1231 1
/*%<
d1235 1
a1235 1
 *\li	'*zmgrp' is a valid, non-NULL zone manager pointer.
d1238 1
a1238 1
 *\li	'*zmgrp' is NULL.
d1243 1
a1243 1
/*%<
d1248 3
a1250 3
 *\li	'zmgr' to be a valid zone manager.
 *\li	'zone' to be a valid zone.
 *\li	'zmgr' == 'zone->zmgr'
d1253 1
a1253 1
 *\li	'zone->zmgr' == NULL;
d1258 1
a1258 1
/*%<
d1263 1
a1263 1
 *\li	'zmgr' to be a valid zone manager.
d1268 1
a1268 1
/*%<
d1272 1
a1272 1
 *\li	'zmgr' to be a valid zone manager.
d1277 1
a1277 1
/*%<
d1281 1
a1281 1
 *\li	'zmgr' to be a valid zone manager
d1286 1
a1286 1
/*%<
d1290 1
a1290 1
 *\li	'zmgr' to be a valid zone manager.
d1295 1
a1295 1
/*%<
d1300 2
a1301 2
 *\li	'zmgr' to be a valid zone manager.
 *\li	'iolimit' to be positive.
d1306 1
a1306 1
/*%<
d1311 1
a1311 1
 *\li	'zmgr' to be a valid zone manager.
d1316 1
a1316 1
/*%<
d1320 1
a1320 1
 *\li	'zmgr' to be a valid zone manager
d1325 1
a1325 1
/*%<
d1329 1
a1329 1
 *\li	'zmgr' to be a valid zone manager.
d1334 1
a1334 1
/*%<
d1338 2
a1339 2
 *\li	'zmgr' to be a valid zone manager.
 *\li	'state' to be a valid DNS_ZONESTATE_ constant.
d1344 1
a1344 1
/*%<
d1348 1
a1348 1
 *\li      'zone' to be a valid zone.
d1353 1
a1353 1
/*%<
d1357 1
a1357 1
 * \li     'zone' to be a valid zone.
d1362 1
a1362 1
/*%<
d1367 1
a1367 1
 *   \li   zone be a valid zone.
d1372 1
a1372 1
/*%<
d1377 1
a1377 1
 * \li     A pointer to the zone's array of statistics counters,
d1383 1
a1383 1
/*%<
d1389 1
a1389 1
/*%<
d1393 2
a1394 2
 * \li	'zone' to be valid initialised zone.
 *\li	'dialup' to be a valid dialup type.
d1400 1
a1400 1
/*%<
d1408 1
a1408 1
/*%<
d1415 1
a1415 1
/*%<
d1419 2
a1420 2
 *\li	'zone' to be valid.
 *\li	'buf' to be non NULL.
a1436 75
 */

void
dns_zone_setacache(dns_zone_t *zone, dns_acache_t *acache);
/*
 *	Associate the zone with an additional cache.
 *
 * Require:
 *	'zone' to be a valid zone.
 *	'acache' to be a non NULL pointer.
 *
 * Ensures:
 *	'zone' will have a reference to 'acache'
 */

void
dns_zone_setcheckmx(dns_zone_t *zone, dns_checkmxfunc_t checkmx);
/*
 *	Set the post load integrity callback function 'checkmx'.
 *	'checkmx' will be called if the MX is not within the zone.
 *
 * Require:
 *	'zone' to be a valid zone.
 */

void
dns_zone_setchecksrv(dns_zone_t *zone, dns_checkmxfunc_t checksrv);
/*
 *	Set the post load integrity callback function 'checksrv'.
 *	'checksrv' will be called if the SRV TARGET is not within the zone.
 *
 * Require:
 *	'zone' to be a valid zone.
 */

void
dns_zone_setcheckns(dns_zone_t *zone, dns_checknsfunc_t checkns);
/*
 *	Set the post load integrity callback function 'checkmx'.
 *	'checkmx' will be called if the MX is not within the zone.
 *
 * Require:
 *	'zone' to be a valid zone.
 */

void
dns_zone_setnotifydelay(dns_zone_t *zone, isc_uint32_t delay);
/*
 * Set the minimum delay between sets of notify messages.
 *
 * Requires:
 *	'zone' to be valid.
 */

isc_uint32_t
dns_zone_getnotifydelay(dns_zone_t *zone);
/*
 * Get the minimum delay between sets of notify messages.
 *
 * Requires:
 *	'zone' to be valid.
 */

void
dns_zone_setisself(dns_zone_t *zone, dns_isselffunc_t isself, void *arg);
/*
 * Set the isself callback function and argument.
 *
 * isc_boolean_t
 * isself(dns_view_t *myview, dns_tsigkey_t *mykey, isc_netaddr_t *srcaddr,
 *	  isc_netaddr_t *destaddr, dns_rdataclass_t rdclass, void *arg);
 *
 * 'isself' returns ISC_TRUE if a non-recursive query from 'srcaddr' to
 * 'destaddr' with optional key 'mykey' for class 'rdclass' would be
 * delivered to 'myview'.
@


