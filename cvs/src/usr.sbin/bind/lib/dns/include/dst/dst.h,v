head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.38
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.40
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.36
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.32
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.34
	OPENBSD_5_8_BASE:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.26
	OPENBSD_5_7_BASE:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.30
	OPENBSD_5_6_BASE:1.1.1.2
	OPENBSD_5_5:1.1.1.2.0.28
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.24
	OPENBSD_5_4_BASE:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.22
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.20
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.18
	OPENBSD_5_0:1.1.1.2.0.16
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.14
	OPENBSD_4_9_BASE:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.12
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.8
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.10
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	BIND_9_4_2_P1:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	OPENBSD_4_3_BASE:1.1.1.2
	BIND_9_4_2:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.10
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.8
	OPENBSD_4_1_BASE:1.1.1.1
	BIND_9_3_4:1.1.1.1
	BIND_9_3_3:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.6
	OPENBSD_4_0_BASE:1.1.1.1
	BIND_9_3_2:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.4
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.2
	OPENBSD_3_8_BASE:1.1.1.1
	BIND_9_3_1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2005.03.22.16.38.08;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2005.03.22.16.38.08;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.12.09.12.34.43;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 2000-2002  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: dst.h,v 1.1.4.1 2004/12/09 04:07:19 marka Exp $ */

#ifndef DST_DST_H
#define DST_DST_H 1

#include <isc/lang.h>

#include <dns/types.h>

ISC_LANG_BEGINDECLS

/***
 *** Types
 ***/

/*
 * The dst_key structure is opaque.  Applications should use the accessor
 * functions provided to retrieve key attributes.  If an application needs
 * to set attributes, new accessor functions will be written.
 */

typedef struct dst_key		dst_key_t;
typedef struct dst_context 	dst_context_t;

/* DST algorithm codes */
#define DST_ALG_UNKNOWN		0
#define DST_ALG_RSAMD5		1
#define DST_ALG_RSA		DST_ALG_RSAMD5	/* backwards compatibility */
#define DST_ALG_DH		2
#define DST_ALG_DSA		3
#define DST_ALG_ECC		4
#define DST_ALG_RSASHA1		5
#define DST_ALG_HMACMD5		157
#define DST_ALG_GSSAPI		160
#define DST_ALG_PRIVATE		254
#define DST_ALG_EXPAND		255
#define DST_MAX_ALGS		255

/* A buffer of this size is large enough to hold any key */
#define DST_KEY_MAXSIZE		1280

/*
 * A buffer of this size is large enough to hold the textual representation
 * of any key
 */
#define DST_KEY_MAXTEXTSIZE	2048

/* 'Type' for dst_read_key() */
#define DST_TYPE_KEY		0x1000000	/* KEY key */
#define DST_TYPE_PRIVATE	0x2000000
#define DST_TYPE_PUBLIC		0x4000000

/***
 *** Functions
 ***/

isc_result_t
dst_lib_init(isc_mem_t *mctx, isc_entropy_t *ectx, unsigned int eflags);
/*
 * Initializes the DST subsystem.
 *
 * Requires:
 * 	"mctx" is a valid memory context
 * 	"ectx" is a valid entropy context
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	ISC_R_NOMEMORY
 *
 * Ensures:
 * 	DST is properly initialized.
 */

void
dst_lib_destroy(void);
/*
 * Releases all resources allocated by DST.
 */

isc_boolean_t
dst_algorithm_supported(unsigned int alg);
/*
 * Checks that a given algorithm is supported by DST.
 *
 * Returns:
 * 	ISC_TRUE
 * 	ISC_FALSE
 */

isc_result_t
dst_context_create(dst_key_t *key, isc_mem_t *mctx, dst_context_t **dctxp);
/*
 * Creates a context to be used for a sign or verify operation.
 *
 * Requires:
 *	"key" is a valid key.
 * 	"mctx" is a valid memory context.
 * 	dctxp != NULL && *dctxp == NULL
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	ISC_R_NOMEMORY
 *
 * Ensures:
 *	*dctxp will contain a usable context.
 */

void
dst_context_destroy(dst_context_t **dctxp);
/*
 * Destroys all memory associated with a context.
 *
 * Requires:
 * 	*dctxp != NULL && *dctxp == NULL
 *
 * Ensures:
 *	*dctxp == NULL
 */

isc_result_t
dst_context_adddata(dst_context_t *dctx, const isc_region_t *data);
/*
 * Incrementally adds data to the context to be used in a sign or verify
 * operation.
 *
 * Requires:
 * 	"dctx" is a valid context
 * 	"data" is a valid region
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	DST_R_SIGNFAILURE
 * 	all other errors indicate failure
 */

isc_result_t
dst_context_sign(dst_context_t *dctx, isc_buffer_t *sig);
/*
 * Computes a signature using the data and key stored in the context.
 *
 * Requires:
 * 	"dctx" is a valid context.
 *	"sig" is a valid buffer.
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	DST_R_VERIFYFAILURE
 * 	all other errors indicate failure
 *
 * Ensures:
 *	"sig" will contain the signature
 */

isc_result_t
dst_context_verify(dst_context_t *dctx, isc_region_t *sig);
/*
 * Verifies the signature using the data and key stored in the context.
 *
 * Requires:
 * 	"dctx" is a valid context.
 *	"sig" is a valid region.
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	all other errors indicate failure
 *
 * Ensures:
 *	"sig" will contain the signature
 */

isc_result_t
dst_key_computesecret(const dst_key_t *pub, const dst_key_t *priv,
		      isc_buffer_t *secret);
/*
 * Computes a shared secret from two (Diffie-Hellman) keys.
 *
 * Requires:
 *     "pub" is a valid key that can be used to derive a shared secret
 *     "priv" is a valid private key that can be used to derive a shared secret
 *     "secret" is a valid buffer
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	any other result indicates failure
 *
 * Ensures:
 *      If successful, secret will contain the derived shared secret.
 */

isc_result_t
dst_key_fromfile(dns_name_t *name, dns_keytag_t id, unsigned int alg, int type,
		 const char *directory, isc_mem_t *mctx, dst_key_t **keyp);
/*
 * Reads a key from permanent storage.  The key can either be a public or
 * private key, and is specified by name, algorithm, and id.  If a private key
 * is specified, the public key must also be present.  If directory is NULL,
 * the current directory is assumed.
 *
 * Requires:
 *	"name" is a valid absolute dns name.
 *	"id" is a valid key tag identifier.
 *	"alg" is a supported key algorithm.
 *	"type" is DST_TYPE_PUBLIC, DST_TYPE_PRIVATE, or the bitwise union.
 *		  DST_TYPE_KEY look for a KEY record otherwise DNSKEY
 *	"mctx" is a valid memory context.
 *	"keyp" is not NULL and "*keyp" is NULL.
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	any other result indicates failure
 *
 * Ensures:
 *	If successful, *keyp will contain a valid key.
 */

isc_result_t
dst_key_fromnamedfile(const char *filename, int type, isc_mem_t *mctx,
		      dst_key_t **keyp);
/*
 * Reads a key from permanent storage.  The key can either be a public or
 * key, and is specified by filename.  If a private key is specified, the
 * public key must also be present.
 *
 * Requires:
 * 	"filename" is not NULL
 *	"type" is DST_TYPE_PUBLIC, DST_TYPE_PRIVATE, or the bitwise union
 *		  DST_TYPE_KEY look for a KEY record otherwise DNSKEY
 *	"mctx" is a valid memory context
 *	"keyp" is not NULL and "*keyp" is NULL.
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	any other result indicates failure
 *
 * Ensures:
 *	If successful, *keyp will contain a valid key.
 */

isc_result_t
dst_key_tofile(const dst_key_t *key, int type, const char *directory);
/*
 * Writes a key to permanent storage.  The key can either be a public or
 * private key.  Public keys are written in DNS format and private keys
 * are written as a set of base64 encoded values.  If directory is NULL,
 * the current directory is assumed.
 *
 * Requires:
 *	"key" is a valid key.
 *	"type" is DST_TYPE_PUBLIC, DST_TYPE_PRIVATE, or the bitwise union
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	any other result indicates failure
 */

isc_result_t
dst_key_fromdns(dns_name_t *name, dns_rdataclass_t rdclass,
		isc_buffer_t *source, isc_mem_t *mctx, dst_key_t **keyp);
/*
 * Converts a DNS KEY record into a DST key.
 *
 * Requires:
 *	"name" is a valid absolute dns name.
 *	"source" is a valid buffer.  There must be at least 4 bytes available.
 *	"mctx" is a valid memory context.
 *	"keyp" is not NULL and "*keyp" is NULL.
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	any other result indicates failure
 *
 * Ensures:
 *	If successful, *keyp will contain a valid key, and the consumed
 *	pointer in data will be advanced.
 */

isc_result_t
dst_key_todns(const dst_key_t *key, isc_buffer_t *target);
/*
 * Converts a DST key into a DNS KEY record.
 *
 * Requires:
 *	"key" is a valid key.
 *	"target" is a valid buffer.  There must be at least 4 bytes unused.
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	any other result indicates failure
 *
 * Ensures:
 *	If successful, the used pointer in 'target' is advanced by at least 4.
 */

isc_result_t
dst_key_frombuffer(dns_name_t *name, unsigned int alg,
		   unsigned int flags, unsigned int protocol,
		   dns_rdataclass_t rdclass,
		   isc_buffer_t *source, isc_mem_t *mctx, dst_key_t **keyp);
/*
 * Converts a buffer containing DNS KEY RDATA into a DST key.
 *
 * Requires:
 *	"name" is a valid absolute dns name.
 *	"alg" is a supported key algorithm.
 *	"source" is a valid buffer.
 *	"mctx" is a valid memory context.
 *	"keyp" is not NULL and "*keyp" is NULL.
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	any other result indicates failure
 *
 * Ensures:
 *	If successful, *keyp will contain a valid key, and the consumed
 *	pointer in source will be advanced.
 */

isc_result_t
dst_key_tobuffer(const dst_key_t *key, isc_buffer_t *target);
/*
 * Converts a DST key into DNS KEY RDATA format.
 *
 * Requires:
 *	"key" is a valid key.
 *	"target" is a valid buffer.
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	any other result indicates failure
 *
 * Ensures:
 *	If successful, the used pointer in 'target' is advanced.
 */

isc_result_t
dst_key_privatefrombuffer(dst_key_t *key, isc_buffer_t *buffer);
/*
 * Converts a public key into a private key, reading the private key
 * information from the buffer.  The buffer should contain the same data
 * as the .private key file would.
 *
 * Requires:
 * 	"key" is a valid public key.
 *	"buffer" is not NULL.
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	any other result indicates failure
 *
 * Ensures:
 *	If successful, key will contain a valid private key.
 */


isc_result_t
dst_key_fromgssapi(dns_name_t *name, void *opaque, isc_mem_t *mctx,
		                   dst_key_t **keyp);
/*
 * Converts a GSSAPI opaque context id into a DST key.
 *
 * Requires:
 *	"name" is a valid absolute dns name.
 *	"opaque" is a GSSAPI context id.
 *	"mctx" is a valid memory context.
 *	"keyp" is not NULL and "*keyp" is NULL.
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	any other result indicates failure
 *
 * Ensures:
 *	If successful, *keyp will contain a valid key and be responsible for
 *	the context id.
 */

isc_result_t
dst_key_generate(dns_name_t *name, unsigned int alg,
		 unsigned int bits, unsigned int param,
		 unsigned int flags, unsigned int protocol,
		 dns_rdataclass_t rdclass,
		 isc_mem_t *mctx, dst_key_t **keyp);
/*
 * Generate a DST key (or keypair) with the supplied parameters.  The
 * interpretation of the "param" field depends on the algorithm:
 * 	RSA:	exponent
 * 		0	use exponent 3
 * 		!0	use Fermat4 (2^16 + 1)
 * 	DH:	generator
 * 		0	default - use well known prime if bits == 768 or 1024,
 * 			otherwise use 2 as the generator.
 * 		!0	use this value as the generator.
 * 	DSA:	unused
 * 	HMACMD5: entropy
 *		0	default - require good entropy
 *		!0	lack of good entropy is ok
 *
 * Requires:
 *	"name" is a valid absolute dns name.
 *	"keyp" is not NULL and "*keyp" is NULL.
 *
 * Returns:
 * 	ISC_R_SUCCESS
 * 	any other result indicates failure
 *
 * Ensures:
 *	If successful, *keyp will contain a valid key.
 */

isc_boolean_t
dst_key_compare(const dst_key_t *key1, const dst_key_t *key2);
/*
 * Compares two DST keys.
 *
 * Requires:
 *	"key1" is a valid key.
 *	"key2" is a valid key.
 *
 * Returns:
 * 	ISC_TRUE
 * 	ISC_FALSE
 */

isc_boolean_t
dst_key_paramcompare(const dst_key_t *key1, const dst_key_t *key2);
/*
 * Compares the parameters of two DST keys.  This is used to determine if
 * two (Diffie-Hellman) keys can be used to derive a shared secret.
 *
 * Requires:
 *	"key1" is a valid key.
 *	"key2" is a valid key.
 *
 * Returns:
 * 	ISC_TRUE
 * 	ISC_FALSE
 */

void
dst_key_free(dst_key_t **keyp);
/*
 * Release all memory associated with the key.
 *
 * Requires:
 *	"keyp" is not NULL and "*keyp" is a valid key.
 *
 * Ensures:
 *	All memory associated with "*keyp" will be freed.
 *	*keyp == NULL
 */

/*
 * Accessor functions to obtain key fields.
 *
 * Require:
 *	"key" is a valid key.
 */
dns_name_t *
dst_key_name(const dst_key_t *key);

unsigned int
dst_key_size(const dst_key_t *key);

unsigned int
dst_key_proto(const dst_key_t *key);

unsigned int
dst_key_alg(const dst_key_t *key);

isc_uint32_t
dst_key_flags(const dst_key_t *key);

dns_keytag_t
dst_key_id(const dst_key_t *key);

dns_rdataclass_t
dst_key_class(const dst_key_t *key);

isc_boolean_t
dst_key_isprivate(const dst_key_t *key);

isc_boolean_t
dst_key_iszonekey(const dst_key_t *key);

isc_boolean_t
dst_key_isnullkey(const dst_key_t *key);

isc_result_t
dst_key_buildfilename(const dst_key_t *key, int type,
		      const char *directory, isc_buffer_t *out);
/*
 * Generates the filename used by dst to store the specified key.
 * If directory is NULL, the current directory is assumed.
 *
 * Requires:
 *	"key" is a valid key
 *	"type" is either DST_TYPE_PUBLIC, DST_TYPE_PRIVATE, or 0 for no suffix.
 *	"out" is a valid buffer
 *
 * Ensures:
 *	the file name will be written to "out", and the used pointer will
 *		be advanced.
 */

isc_result_t
dst_key_sigsize(const dst_key_t *key, unsigned int *n);
/*
 * Computes the size of a signature generated by the given key.
 *
 * Requires:
 *	"key" is a valid key.
 *	"n" is not NULL
 *
 * Returns:
 *	ISC_R_SUCCESS
 *	DST_R_UNSUPPORTEDALG
 *
 * Ensures:
 * 	"n" stores the size of a generated signature
 */

isc_result_t
dst_key_secretsize(const dst_key_t *key, unsigned int *n);
/*
 * Computes the size of a shared secret generated by the given key.
 *
 * Requires:
 *	"key" is a valid key.
 *	"n" is not NULL
 *
 * Returns:
 *	ISC_R_SUCCESS
 *	DST_R_UNSUPPORTEDALG
 *
 * Ensures:
 * 	"n" stores the size of a generated shared secret
 */

isc_uint16_t
dst_region_computeid(const isc_region_t *source, unsigned int alg);
/*
 * Computes the key id of the key stored in the provided region with the
 * given algorithm.
 *
 * Requires:
 * 	"source" contains a valid, non-NULL region.
 *
 * Returns:
 * 	the key id
 */

ISC_LANG_ENDDECLS

#endif /* DST_DST_H */
@


1.1.1.1
log
@ISC BIND release 9.3.1. ok deraadt@@
@
text
@@


1.1.1.2
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: dst.h,v 1.1.6.5 2006/01/27 23:57:44 marka Exp $ */
a22 2
/*! \file */

d33 1
a33 1
/*%
d45 1
a45 1
#define DST_ALG_RSA		DST_ALG_RSAMD5	/*%< backwards compatibility */
a51 5
#define DST_ALG_HMACSHA1	161	/* XXXMPA */
#define DST_ALG_HMACSHA224	162	/* XXXMPA */
#define DST_ALG_HMACSHA256	163	/* XXXMPA */
#define DST_ALG_HMACSHA384	164	/* XXXMPA */
#define DST_ALG_HMACSHA512	165	/* XXXMPA */
d56 1
a56 1
/*% A buffer of this size is large enough to hold any key */
d59 1
a59 1
/*%
d65 1
a65 1
/*% 'Type' for dst_read_key() */
d76 1
a76 1
/*%<
d80 2
a81 2
 * \li 	"mctx" is a valid memory context
 * \li	"ectx" is a valid entropy context
d84 2
a85 2
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_NOMEMORY
d88 1
a88 1
 * \li	DST is properly initialized.
d93 1
a93 1
/*%<
d99 1
a99 1
/*%<
d103 2
a104 2
 * \li	ISC_TRUE
 * \li	ISC_FALSE
d109 1
a109 1
/*%<
d113 3
a115 3
 * \li	"key" is a valid key.
 * \li	"mctx" is a valid memory context.
 * \li	dctxp != NULL && *dctxp == NULL
d118 2
a119 2
 * \li	ISC_R_SUCCESS
 * \li	ISC_R_NOMEMORY
d122 1
a122 1
 * \li	*dctxp will contain a usable context.
d127 1
a127 1
/*%<
d131 1
a131 1
 * \li	*dctxp != NULL && *dctxp == NULL
d134 1
a134 1
 * \li	*dctxp == NULL
d139 1
a139 1
/*%<
d144 2
a145 2
 * \li	"dctx" is a valid context
 * \li	"data" is a valid region
d148 3
a150 3
 * \li	ISC_R_SUCCESS
 * \li	DST_R_SIGNFAILURE
 * \li	all other errors indicate failure
d155 1
a155 1
/*%<
d159 2
a160 2
 * \li	"dctx" is a valid context.
 * \li	"sig" is a valid buffer.
d163 3
a165 3
 * \li	ISC_R_SUCCESS
 * \li	DST_R_VERIFYFAILURE
 * \li	all other errors indicate failure
d168 1
a168 1
 * \li	"sig" will contain the signature
d173 1
a173 1
/*%<
d177 2
a178 2
 * \li	"dctx" is a valid context.
 * \li	"sig" is a valid region.
d181 2
a182 2
 * \li	ISC_R_SUCCESS
 * \li	all other errors indicate failure
d185 1
a185 1
 * \li	"sig" will contain the signature
d191 1
a191 1
/*%<
d195 3
a197 3
 * \li	"pub" is a valid key that can be used to derive a shared secret
 * \li	"priv" is a valid private key that can be used to derive a shared secret
 * \li	"secret" is a valid buffer
d200 2
a201 2
 * \li	ISC_R_SUCCESS
 * \li	any other result indicates failure
d204 1
a204 1
 * \li	If successful, secret will contain the derived shared secret.
d210 1
a210 1
/*%<
d217 4
a220 4
 * \li	"name" is a valid absolute dns name.
 * \li	"id" is a valid key tag identifier.
 * \li	"alg" is a supported key algorithm.
 * \li	"type" is DST_TYPE_PUBLIC, DST_TYPE_PRIVATE, or the bitwise union.
d222 2
a223 2
 * \li	"mctx" is a valid memory context.
 * \li	"keyp" is not NULL and "*keyp" is NULL.
d226 2
a227 2
 * \li	ISC_R_SUCCESS
 * \li	any other result indicates failure
d230 1
a230 1
 * \li	If successful, *keyp will contain a valid key.
d236 1
a236 1
/*%<
d242 2
a243 2
 * \li	"filename" is not NULL
 * \li	"type" is DST_TYPE_PUBLIC, DST_TYPE_PRIVATE, or the bitwise union
d245 2
a246 2
 * \li	"mctx" is a valid memory context
 * \li	"keyp" is not NULL and "*keyp" is NULL.
d249 2
a250 2
 * \li	ISC_R_SUCCESS
 * \li	any other result indicates failure
d253 1
a253 24
 * \li	If successful, *keyp will contain a valid key.
 */


isc_result_t
dst_key_read_public(const char *filename, int type,
		    isc_mem_t *mctx, dst_key_t **keyp);
/*%<
 * Reads a public key from permanent storage.  The key must be a public key.
 *
 * Requires:
 * \li	"filename" is not NULL
 * \li	"type" is DST_TYPE_KEY look for a KEY record otherwise DNSKEY
 * \li	"mctx" is a valid memory context
 * \li	"keyp" is not NULL and "*keyp" is NULL.
 *
 * Returns:
 * \li	ISC_R_SUCCESS
 * \li	DST_R_BADKEYTYPE if the key type is not the expected one
 * \li	ISC_R_UNEXPECTEDTOKEN if the file can not be parsed as a public key
 * \li	any other result indicates failure
 *
 * Ensures:
 * \li	If successful, *keyp will contain a valid key.
d258 1
a258 1
/*%<
d265 2
a266 2
 * \li	"key" is a valid key.
 * \li	"type" is DST_TYPE_PUBLIC, DST_TYPE_PRIVATE, or the bitwise union
d269 2
a270 2
 * \li	ISC_R_SUCCESS
 * \li	any other result indicates failure
d276 1
a276 1
/*%<
d280 4
a283 4
 * \li	"name" is a valid absolute dns name.
 * \li	"source" is a valid buffer.  There must be at least 4 bytes available.
 * \li	"mctx" is a valid memory context.
 * \li	"keyp" is not NULL and "*keyp" is NULL.
d286 2
a287 2
 * \li	ISC_R_SUCCESS
 * \li	any other result indicates failure
d290 1
a290 1
 * \li	If successful, *keyp will contain a valid key, and the consumed
d296 1
a296 1
/*%<
d300 2
a301 2
 * \li	"key" is a valid key.
 * \li	"target" is a valid buffer.  There must be at least 4 bytes unused.
d304 2
a305 2
 * \li	ISC_R_SUCCESS
 * \li	any other result indicates failure
d308 1
a308 1
 * \li	If successful, the used pointer in 'target' is advanced by at least 4.
d316 1
a316 1
/*%<
d320 5
a324 5
 *\li	"name" is a valid absolute dns name.
 *\li	"alg" is a supported key algorithm.
 *\li	"source" is a valid buffer.
 *\li	"mctx" is a valid memory context.
 *\li	"keyp" is not NULL and "*keyp" is NULL.
d327 2
a328 2
 *\li 	ISC_R_SUCCESS
 * \li	any other result indicates failure
d331 1
a331 1
 *\li	If successful, *keyp will contain a valid key, and the consumed
d337 1
a337 1
/*%<
d341 2
a342 2
 *\li	"key" is a valid key.
 *\li	"target" is a valid buffer.
d345 2
a346 2
 *\li 	ISC_R_SUCCESS
 * \li	any other result indicates failure
d349 1
a349 1
 *\li	If successful, the used pointer in 'target' is advanced.
d354 1
a354 1
/*%<
d360 2
a361 2
 *\li	"key" is a valid public key.
 *\li	"buffer" is not NULL.
d364 2
a365 2
 *\li 	ISC_R_SUCCESS
 * \li	any other result indicates failure
d368 1
a368 1
 *\li	If successful, key will contain a valid private key.
d375 1
a375 1
/*%<
d379 4
a382 4
 *\li	"name" is a valid absolute dns name.
 *\li	"opaque" is a GSSAPI context id.
 *\li	"mctx" is a valid memory context.
 *\li	"keyp" is not NULL and "*keyp" is NULL.
d385 2
a386 2
 *\li 	ISC_R_SUCCESS
 * \li	any other result indicates failure
d389 1
a389 1
 *\li	If successful, *keyp will contain a valid key and be responsible for
d399 1
a399 1
/*%<
a401 1
 * \code
a412 1
 *\endcode
d415 2
a416 2
 *\li	"name" is a valid absolute dns name.
 *\li	"keyp" is not NULL and "*keyp" is NULL.
d419 2
a420 2
 *\li 	ISC_R_SUCCESS
 * \li	any other result indicates failure
d423 1
a423 1
 *\li	If successful, *keyp will contain a valid key.
d428 1
a428 1
/*%<
d432 2
a433 2
 *\li	"key1" is a valid key.
 *\li	"key2" is a valid key.
d436 2
a437 2
 *\li 	ISC_TRUE
 * \li	ISC_FALSE
d442 1
a442 1
/*%<
d447 2
a448 2
 *\li	"key1" is a valid key.
 *\li	"key2" is a valid key.
d451 2
a452 2
 *\li 	ISC_TRUE
 * \li	ISC_FALSE
d457 1
a457 1
/*%<
d461 1
a461 1
 *\li	"keyp" is not NULL and "*keyp" is a valid key.
d464 2
a465 2
 *\li	All memory associated with "*keyp" will be freed.
 *\li	*keyp == NULL
d468 1
a468 1
/*%<
d472 1
a472 1
 *\li	"key" is a valid key.
d507 1
a507 1
/*%<
d512 3
a514 3
 *\li	"key" is a valid key
 *\li	"type" is either DST_TYPE_PUBLIC, DST_TYPE_PRIVATE, or 0 for no suffix.
 *\li	"out" is a valid buffer
d517 1
a517 1
 *\li	the file name will be written to "out", and the used pointer will
d523 1
a523 1
/*%<
d527 2
a528 2
 *\li	"key" is a valid key.
 *\li	"n" is not NULL
d531 2
a532 2
 *\li	#ISC_R_SUCCESS
 *\li	DST_R_UNSUPPORTEDALG
d535 1
a535 1
 *\li	"n" stores the size of a generated signature
d540 1
a540 1
/*%<
d544 2
a545 2
 *\li	"key" is a valid key.
 *\li	"n" is not NULL
d548 2
a549 2
 *\li	#ISC_R_SUCCESS
 *\li	DST_R_UNSUPPORTEDALG
d552 1
a552 1
 *\li	"n" stores the size of a generated shared secret
d557 1
a557 1
/*%<
d562 1
a562 1
 *\li	"source" contains a valid, non-NULL region.
d565 1
a565 19
 *\li 	the key id
 */

isc_uint16_t
dst_key_getbits(const dst_key_t *key);
/*
 * Get the number of digest bits required (0 == MAX).
 *
 * Requires:
 *	"key" is a valid key.
 */

void
dst_key_setbits(dst_key_t *key, isc_uint16_t bits);
/*
 * Set the number of digest bits required (0 == MAX).
 *
 * Requires:
 *	"key" is a valid key.
@

