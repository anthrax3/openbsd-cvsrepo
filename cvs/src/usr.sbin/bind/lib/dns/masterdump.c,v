head	1.8;
access;
symbols
	OPENBSD_6_0:1.8.0.36
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.32
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.34
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.26
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.30
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.28
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.24
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.22
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.20
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.18
	OPENBSD_5_0:1.8.0.16
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.14
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.12
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.8
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.10
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.6
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	BIND_9_4_2_P1:1.1.1.4
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	BIND_9_4_2:1.1.1.4
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	BIND_9_3_4:1.1.1.3
	BIND_9_3_3:1.1.1.3
	OPENBSD_4_0:1.6.0.6
	OPENBSD_4_0_BASE:1.6
	BIND_9_3_2:1.1.1.2
	OPENBSD_3_9:1.6.0.4
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2007.12.09.13.39.43;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.10.19.07.59;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.16.17.11.36;	author cloder;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.28.17.14.05;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.18.14.14.06;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.30.19.54.28;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.15.13.20.17;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.07.00;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.07.00;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.34.44;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.01.10.18.19.31;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.12.09.12.34.24;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.8
log
@resolve conflicts
@
text
@/*
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1999-2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: masterdump.c,v 1.73.18.14 2006/08/08 06:39:36 marka Exp $ */

/*! \file */

#include <config.h>

#include <stdlib.h>

#include <isc/event.h>
#include <isc/file.h>
#include <isc/magic.h>
#include <isc/mem.h>
#include <isc/print.h>
#include <isc/stdio.h>
#include <isc/string.h>
#include <isc/task.h>
#include <isc/time.h>
#include <isc/util.h>

#include <dns/db.h>
#include <dns/dbiterator.h>
#include <dns/events.h>
#include <dns/fixedname.h>
#include <dns/lib.h>
#include <dns/log.h>
#include <dns/master.h>
#include <dns/masterdump.h>
#include <dns/rdata.h>
#include <dns/rdataclass.h>
#include <dns/rdataset.h>
#include <dns/rdatasetiter.h>
#include <dns/rdatatype.h>
#include <dns/result.h>
#include <dns/time.h>
#include <dns/ttl.h>

#define DNS_DCTX_MAGIC		ISC_MAGIC('D', 'c', 't', 'x')
#define DNS_DCTX_VALID(d)	ISC_MAGIC_VALID(d, DNS_DCTX_MAGIC)

#define RETERR(x) do { \
	isc_result_t _r = (x); \
	if (_r != ISC_R_SUCCESS) \
		return (_r); \
	} while (0)

struct dns_master_style {
	unsigned int flags;		/* DNS_STYLEFLAG_* */
	unsigned int ttl_column;
	unsigned int class_column;
	unsigned int type_column;
	unsigned int rdata_column;
	unsigned int line_length;
	unsigned int tab_width;
};

/*%
 * The maximum length of the newline+indentation that is output
 * when inserting a line break in an RR.  This effectively puts an
 * upper limits on the value of "rdata_column", because if it is
 * very large, the tabs and spaces needed to reach it will not fit.
 */
#define DNS_TOTEXT_LINEBREAK_MAXLEN 100

/*%
 * Context structure for a masterfile dump in progress.
 */
typedef struct dns_totext_ctx {
	dns_master_style_t	style;
	isc_boolean_t 		class_printed;
	char *			linebreak;
	char 			linebreak_buf[DNS_TOTEXT_LINEBREAK_MAXLEN];
	dns_name_t *		origin;
	dns_name_t *		neworigin;
	dns_fixedname_t		origin_fixname;
	isc_uint32_t 		current_ttl;
	isc_boolean_t 		current_ttl_valid;
} dns_totext_ctx_t;

LIBDNS_EXTERNAL_DATA const dns_master_style_t
dns_master_style_default = {
	DNS_STYLEFLAG_OMIT_OWNER |
	DNS_STYLEFLAG_OMIT_CLASS |
	DNS_STYLEFLAG_REL_OWNER |
	DNS_STYLEFLAG_REL_DATA |
	DNS_STYLEFLAG_OMIT_TTL |
	DNS_STYLEFLAG_TTL |
	DNS_STYLEFLAG_COMMENT |
	DNS_STYLEFLAG_MULTILINE,
	24, 24, 24, 32, 80, 8
};

LIBDNS_EXTERNAL_DATA const dns_master_style_t
dns_master_style_full = {
	DNS_STYLEFLAG_COMMENT,
	46, 46, 46, 64, 120, 8
};

LIBDNS_EXTERNAL_DATA const dns_master_style_t
dns_master_style_explicitttl = {
	DNS_STYLEFLAG_OMIT_OWNER |
	DNS_STYLEFLAG_OMIT_CLASS |
	DNS_STYLEFLAG_REL_OWNER |
	DNS_STYLEFLAG_REL_DATA |
	DNS_STYLEFLAG_COMMENT |
	DNS_STYLEFLAG_MULTILINE,
	24, 32, 32, 40, 80, 8
};

LIBDNS_EXTERNAL_DATA const dns_master_style_t
dns_master_style_cache = {
	DNS_STYLEFLAG_OMIT_OWNER |
	DNS_STYLEFLAG_OMIT_CLASS |
	DNS_STYLEFLAG_MULTILINE |
	DNS_STYLEFLAG_TRUST |
	DNS_STYLEFLAG_NCACHE,
	24, 32, 32, 40, 80, 8
};

LIBDNS_EXTERNAL_DATA const dns_master_style_t
dns_master_style_simple = {
	0,
	24, 32, 32, 40, 80, 8
};

/*%
 * A style suitable for dns_rdataset_totext().
 */
LIBDNS_EXTERNAL_DATA const dns_master_style_t
dns_master_style_debug = {
	DNS_STYLEFLAG_REL_OWNER,
	24, 32, 40, 48, 80, 8
};


#define N_SPACES 10
static char spaces[N_SPACES+1] = "          ";

#define N_TABS 10
static char tabs[N_TABS+1] = "\t\t\t\t\t\t\t\t\t\t";

struct dns_dumpctx {
	unsigned int		magic;
	isc_mem_t		*mctx;
	isc_mutex_t		lock;
	unsigned int		references;
	isc_boolean_t		canceled;
	isc_boolean_t		first;
	isc_boolean_t		do_date;
	isc_stdtime_t		now;
	FILE			*f;
	dns_db_t		*db;
	dns_dbversion_t		*version;
	dns_dbiterator_t	*dbiter;
	dns_totext_ctx_t	tctx;
	isc_task_t		*task;
	dns_dumpdonefunc_t	done;
	void			*done_arg;
	unsigned int		nodes;
	/* dns_master_dumpinc() */
	char			*file;
	char 			*tmpfile;
	dns_masterformat_t	format;
	isc_result_t		(*dumpsets)(isc_mem_t *mctx, dns_name_t *name,
					    dns_rdatasetiter_t *rdsiter,
					    dns_totext_ctx_t *ctx,
					    isc_buffer_t *buffer, FILE *f);
};

#define NXDOMAIN(x) (((x)->attributes & DNS_RDATASETATTR_NXDOMAIN) != 0) 

/*%
 * Output tabs and spaces to go from column '*current' to
 * column 'to', and update '*current' to reflect the new
 * current column.
 */
static isc_result_t
indent(unsigned int *current, unsigned int to, int tabwidth,
       isc_buffer_t *target)
{
	isc_region_t r;
	unsigned char *p;
	unsigned int from;
	int ntabs, nspaces, t;

	from = *current;

	if (to < from + 1)
		to = from + 1;

	ntabs = to / tabwidth - from / tabwidth;
	if (ntabs < 0)
		ntabs = 0;

	if (ntabs > 0) {
		isc_buffer_availableregion(target, &r);
		if (r.length < (unsigned) ntabs)
			return (ISC_R_NOSPACE);
		p = r.base;

		t = ntabs;
		while (t) {
			int n = t;
			if (n > N_TABS)
				n = N_TABS;
			memcpy(p, tabs, n);
			p += n;
			t -= n;
		}
		isc_buffer_add(target, ntabs);
		from = (to / tabwidth) * tabwidth;
	}

	nspaces = to - from;
	INSIST(nspaces >= 0);

	isc_buffer_availableregion(target, &r);
	if (r.length < (unsigned) nspaces)
		return (ISC_R_NOSPACE);
	p = r.base;

	t = nspaces;
	while (t) {
		int n = t;
		if (n > N_SPACES)
			n = N_SPACES;
		memcpy(p, spaces, n);
		p += n;
		t -= n;
	}
	isc_buffer_add(target, nspaces);

	*current = to;
	return (ISC_R_SUCCESS);
}

static isc_result_t
totext_ctx_init(const dns_master_style_t *style, dns_totext_ctx_t *ctx) {
	isc_result_t result;

	REQUIRE(style->tab_width != 0);

	ctx->style = *style;
	ctx->class_printed = ISC_FALSE;

	dns_fixedname_init(&ctx->origin_fixname);

	/*
	 * Set up the line break string if needed.
	 */
	if ((ctx->style.flags & DNS_STYLEFLAG_MULTILINE) != 0) {
		isc_buffer_t buf;
		isc_region_t r;
		unsigned int col = 0;

		isc_buffer_init(&buf, ctx->linebreak_buf,
				sizeof(ctx->linebreak_buf));

		isc_buffer_availableregion(&buf, &r);
		if (r.length < 1)
			return (DNS_R_TEXTTOOLONG);
		r.base[0] = '\n';
		isc_buffer_add(&buf, 1);

		result = indent(&col, ctx->style.rdata_column,
				ctx->style.tab_width, &buf);
		/*
		 * Do not return ISC_R_NOSPACE if the line break string
		 * buffer is too small, because that would just make
		 * dump_rdataset() retry indenfinitely with ever
		 * bigger target buffers.  That's a different buffer,
		 * so it won't help.  Use DNS_R_TEXTTOOLONG as a substitute.
		 */
		if (result == ISC_R_NOSPACE)
			return (DNS_R_TEXTTOOLONG);
		if (result != ISC_R_SUCCESS)
			return (result);

		isc_buffer_availableregion(&buf, &r);
		if (r.length < 1)
			return (DNS_R_TEXTTOOLONG);
		r.base[0] = '\0';
		isc_buffer_add(&buf, 1);
		ctx->linebreak = ctx->linebreak_buf;
	} else {
		ctx->linebreak = NULL;
	}

	ctx->origin = NULL;
	ctx->neworigin = NULL;
	ctx->current_ttl = 0;
	ctx->current_ttl_valid = ISC_FALSE;

	return (ISC_R_SUCCESS);
}

#define INDENT_TO(col) \
	do { \
		 if ((result = indent(&column, ctx->style.col, \
				      ctx->style.tab_width, target)) \
		     != ISC_R_SUCCESS) \
			    return (result); \
	} while (0)


static isc_result_t
str_totext(const char *source, isc_buffer_t *target) {
	unsigned int l;
	isc_region_t region;

	isc_buffer_availableregion(target, &region);
	l = strlen(source);

	if (l > region.length)
		return (ISC_R_NOSPACE);

	memcpy(region.base, source, l);
	isc_buffer_add(target, l);
	return (ISC_R_SUCCESS);
}

/*
 * Convert 'rdataset' to master file text format according to 'ctx',
 * storing the result in 'target'.  If 'owner_name' is NULL, it
 * is omitted; otherwise 'owner_name' must be valid and have at least
 * one label.
 */

static isc_result_t
rdataset_totext(dns_rdataset_t *rdataset,
		dns_name_t *owner_name,
		dns_totext_ctx_t *ctx,
		isc_boolean_t omit_final_dot,
		isc_buffer_t *target)
{
	isc_result_t result;
	unsigned int column;
	isc_boolean_t first = ISC_TRUE;
	isc_uint32_t current_ttl;
	isc_boolean_t current_ttl_valid;
	dns_rdatatype_t type;

	REQUIRE(DNS_RDATASET_VALID(rdataset));

	rdataset->attributes |= DNS_RDATASETATTR_LOADORDER;
	result = dns_rdataset_first(rdataset);
	REQUIRE(result == ISC_R_SUCCESS);

	current_ttl = ctx->current_ttl;
	current_ttl_valid = ctx->current_ttl_valid;

	do {
		column = 0;

		/*
		 * Owner name.
		 */
		if (owner_name != NULL &&
		    ! ((ctx->style.flags & DNS_STYLEFLAG_OMIT_OWNER) != 0 &&
		       !first))
		{
			unsigned int name_start = target->used;
			RETERR(dns_name_totext(owner_name,
					       omit_final_dot,
					       target));
			column += target->used - name_start;
		}

		/*
		 * TTL.
		 */
		if ((ctx->style.flags & DNS_STYLEFLAG_NO_TTL) == 0 &&
		    !((ctx->style.flags & DNS_STYLEFLAG_OMIT_TTL) != 0 &&
		      current_ttl_valid &&
		      rdataset->ttl == current_ttl))
		{
			char ttlbuf[64];
			isc_region_t r;
			int length;

			INDENT_TO(ttl_column);
			length = snprintf(ttlbuf, sizeof(ttlbuf), "%u",
					  rdataset->ttl);
			INSIST(length != -1 && (size_t)length < sizeof(ttlbuf));
			isc_buffer_availableregion(target, &r);
			if (r.length < (unsigned int)length)
				return (ISC_R_NOSPACE);
			memcpy(r.base, ttlbuf, (size_t)length);
			isc_buffer_add(target, (unsigned int)length);
			column += (unsigned int)length;

			/*
			 * If the $TTL directive is not in use, the TTL we
			 * just printed becomes the default for subsequent RRs.
			 */
			if ((ctx->style.flags & DNS_STYLEFLAG_TTL) == 0) {
				current_ttl = rdataset->ttl;
				current_ttl_valid = ISC_TRUE;
			}
		}

		/*
		 * Class.
		 */
		if ((ctx->style.flags & DNS_STYLEFLAG_NO_CLASS) == 0 &&
		    ((ctx->style.flags & DNS_STYLEFLAG_OMIT_CLASS) == 0 ||
		     ctx->class_printed == ISC_FALSE))
		{
			unsigned int class_start;
			INDENT_TO(class_column);
			class_start = target->used;
			result = dns_rdataclass_totext(rdataset->rdclass,
						       target);
			if (result != ISC_R_SUCCESS)
				return (result);
			column += (target->used - class_start);
		}

		/*
		 * Type.
		 */

		if (rdataset->type == 0) {
			type = rdataset->covers;
		} else {
			type = rdataset->type;
		}

		{
			unsigned int type_start;
			INDENT_TO(type_column);
			type_start = target->used;
			if (rdataset->type == 0)
				RETERR(str_totext("\\-", target));
			result = dns_rdatatype_totext(type, target);
			if (result != ISC_R_SUCCESS)
				return (result);
			column += (target->used - type_start);
		}

		/*
		 * Rdata.
		 */
		INDENT_TO(rdata_column);
		if (rdataset->type == 0) {
			if (NXDOMAIN(rdataset))
				RETERR(str_totext(";-$NXDOMAIN\n", target));
			else
				RETERR(str_totext(";-$NXRRSET\n", target));
		} else {
			dns_rdata_t rdata = DNS_RDATA_INIT;
			isc_region_t r;

			dns_rdataset_current(rdataset, &rdata);

			RETERR(dns_rdata_tofmttext(&rdata,
						   ctx->origin,
						   ctx->style.flags,
						   ctx->style.line_length -
						       ctx->style.rdata_column,
						   ctx->linebreak,
						   target));

			isc_buffer_availableregion(target, &r);
			if (r.length < 1)
				return (ISC_R_NOSPACE);
			r.base[0] = '\n';
			isc_buffer_add(target, 1);
		}

		first = ISC_FALSE;
		result = dns_rdataset_next(rdataset);
	} while (result == ISC_R_SUCCESS);

	if (result != ISC_R_NOMORE)
		return (result);

	/*
	 * Update the ctx state to reflect what we just printed.
	 * This is done last, only when we are sure we will return
	 * success, because this function may be called multiple
	 * times with increasing buffer sizes until it succeeds,
	 * and failed attempts must not update the state prematurely.
	 */
	ctx->class_printed = ISC_TRUE;
	ctx->current_ttl= current_ttl;
	ctx->current_ttl_valid = current_ttl_valid;

	return (ISC_R_SUCCESS);
}

/*
 * Print the name, type, and class of an empty rdataset,
 * such as those used to represent the question section
 * of a DNS message.
 */
static isc_result_t
question_totext(dns_rdataset_t *rdataset,
		dns_name_t *owner_name,
		dns_totext_ctx_t *ctx,
		isc_boolean_t omit_final_dot,
		isc_buffer_t *target)
{
	unsigned int column;
	isc_result_t result;
	isc_region_t r;

	REQUIRE(DNS_RDATASET_VALID(rdataset));
	result = dns_rdataset_first(rdataset);
	REQUIRE(result == ISC_R_NOMORE);

	column = 0;

	/* Owner name */
	{
		unsigned int name_start = target->used;
		RETERR(dns_name_totext(owner_name,
				       omit_final_dot,
				       target));
		column += target->used - name_start;
	}

	/* Class */
	{
		unsigned int class_start;
		INDENT_TO(class_column);
		class_start = target->used;
		result = dns_rdataclass_totext(rdataset->rdclass, target);
		if (result != ISC_R_SUCCESS)
			return (result);
		column += (target->used - class_start);
	}

	/* Type */
	{
		unsigned int type_start;
		INDENT_TO(type_column);
		type_start = target->used;
		result = dns_rdatatype_totext(rdataset->type, target);
		if (result != ISC_R_SUCCESS)
			return (result);
		column += (target->used - type_start);
	}

	isc_buffer_availableregion(target, &r);
	if (r.length < 1)
		return (ISC_R_NOSPACE);
	r.base[0] = '\n';
	isc_buffer_add(target, 1);

	return (ISC_R_SUCCESS);
}

isc_result_t
dns_rdataset_totext(dns_rdataset_t *rdataset,
		    dns_name_t *owner_name,
		    isc_boolean_t omit_final_dot,
		    isc_boolean_t question,
		    isc_buffer_t *target)
{
	dns_totext_ctx_t ctx;
	isc_result_t result;
	result = totext_ctx_init(&dns_master_style_debug, &ctx);
	if (result != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "could not set master file style");
		return (ISC_R_UNEXPECTED);
	}

	/*
	 * The caller might want to give us an empty owner
	 * name (e.g. if they are outputting into a master
	 * file and this rdataset has the same name as the
	 * previous one.)
	 */
	if (dns_name_countlabels(owner_name) == 0)
		owner_name = NULL;

	if (question)
		return (question_totext(rdataset, owner_name, &ctx,
					omit_final_dot, target));
	else
		return (rdataset_totext(rdataset, owner_name, &ctx,
					omit_final_dot, target));
}

isc_result_t
dns_master_rdatasettotext(dns_name_t *owner_name,
			  dns_rdataset_t *rdataset,
			  const dns_master_style_t *style,
			  isc_buffer_t *target)
{
	dns_totext_ctx_t ctx;
	isc_result_t result;
	result = totext_ctx_init(style, &ctx);
	if (result != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "could not set master file style");
		return (ISC_R_UNEXPECTED);
	}

	return (rdataset_totext(rdataset, owner_name, &ctx,
				ISC_FALSE, target));
}

isc_result_t
dns_master_questiontotext(dns_name_t *owner_name,
			  dns_rdataset_t *rdataset,
			  const dns_master_style_t *style,
			  isc_buffer_t *target)
{
	dns_totext_ctx_t ctx;
	isc_result_t result;
	result = totext_ctx_init(style, &ctx);
	if (result != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "could not set master file style");
		return (ISC_R_UNEXPECTED);
	}

	return (question_totext(rdataset, owner_name, &ctx,
				ISC_FALSE, target));
}

/*
 * Print an rdataset.  'buffer' is a scratch buffer, which must have been
 * dynamically allocated by the caller.  It must be large enough to
 * hold the result from dns_ttl_totext().  If more than that is needed,
 * the buffer will be grown automatically.
 */

static isc_result_t
dump_rdataset(isc_mem_t *mctx, dns_name_t *name, dns_rdataset_t *rdataset,
	      dns_totext_ctx_t *ctx,
	      isc_buffer_t *buffer, FILE *f)
{
	isc_region_t r;
	isc_result_t result;

	REQUIRE(buffer->length > 0);

	/*
	 * Output a $TTL directive if needed.
	 */

	if ((ctx->style.flags & DNS_STYLEFLAG_TTL) != 0) {
		if (ctx->current_ttl_valid == ISC_FALSE ||
		    ctx->current_ttl != rdataset->ttl)
		{
			if ((ctx->style.flags & DNS_STYLEFLAG_COMMENT) != 0)
			{
				isc_buffer_clear(buffer);
				result = dns_ttl_totext(rdataset->ttl,
							ISC_TRUE, buffer);
				INSIST(result == ISC_R_SUCCESS);
				isc_buffer_usedregion(buffer, &r);
				fprintf(f, "$TTL %u\t; %.*s\n", rdataset->ttl,
					(int) r.length, (char *) r.base);
			} else {
				fprintf(f, "$TTL %u\n", rdataset->ttl);
			}
			ctx->current_ttl = rdataset->ttl;
			ctx->current_ttl_valid = ISC_TRUE;
		}
	}

	isc_buffer_clear(buffer);

	/*
	 * Generate the text representation of the rdataset into
	 * the buffer.  If the buffer is too small, grow it.
	 */
	for (;;) {
		int newlength;
		void *newmem;
		result = rdataset_totext(rdataset, name, ctx,
					 ISC_FALSE, buffer);
		if (result != ISC_R_NOSPACE)
			break;

		newlength = buffer->length * 2;
		newmem = isc_mem_get(mctx, newlength);
		if (newmem == NULL)
			return (ISC_R_NOMEMORY);
		isc_mem_put(mctx, buffer->base, buffer->length);
		isc_buffer_init(buffer, newmem, newlength);
	}
	if (result != ISC_R_SUCCESS)
		return (result);

	/*
	 * Write the buffer contents to the master file.
	 */
	isc_buffer_usedregion(buffer, &r);
	result = isc_stdio_write(r.base, 1, (size_t)r.length, f, NULL);

	if (result != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "master file write failed: %s",
				 isc_result_totext(result));
		return (result);
	}

	return (ISC_R_SUCCESS);
}

/*
 * Define the order in which rdatasets should be printed in zone
 * files.  We will print SOA and NS records before others, SIGs
 * immediately following the things they sign, and order everything
 * else by RR number.  This is all just for aesthetics and
 * compatibility with buggy software that expects the SOA to be first;
 * the DNS specifications allow any order.
 */

static int
dump_order(const dns_rdataset_t *rds) {
	int t;
	int sig;
	if (rds->type == dns_rdatatype_rrsig) {
		t = rds->covers;
		sig = 1;
	} else {
		t = rds->type;
		sig = 0;
	}
	switch (t) {
	case dns_rdatatype_soa:
		t = 0;
		break;
	case dns_rdatatype_ns:
		t = 1;
		break;
	default:
		t += 2;
		break;
	}
	return (t << 1) + sig;
}

static int
dump_order_compare(const void *a, const void *b) {
	return (dump_order(*((const dns_rdataset_t * const *) a)) -
		dump_order(*((const dns_rdataset_t * const *) b)));
}

/*
 * Dump all the rdatasets of a domain name to a master file.  We make
 * a "best effort" attempt to sort the RRsets in a nice order, but if
 * there are more than MAXSORT RRsets, we punt and only sort them in
 * groups of MAXSORT.  This is not expected to ever happen in practice
 * since much less than 64 RR types have been registered with the
 * IANA, so far, and the output will be correct (though not
 * aesthetically pleasing) even if it does happen.
 */

#define MAXSORT 64

static const char *trustnames[] = {
	"none",
	"pending",
	"additional",
	"glue",
	"answer",
	"authauthority",
	"authanswer",
	"secure",
	"local" /* aka ultimate */
};

static isc_result_t
dump_rdatasets_text(isc_mem_t *mctx, dns_name_t *name,
		    dns_rdatasetiter_t *rdsiter, dns_totext_ctx_t *ctx,
		    isc_buffer_t *buffer, FILE *f)
{
	isc_result_t itresult, dumpresult;
	isc_region_t r;
	dns_rdataset_t rdatasets[MAXSORT];
	dns_rdataset_t *sorted[MAXSORT];
	int i, n;

	itresult = dns_rdatasetiter_first(rdsiter);
	dumpresult = ISC_R_SUCCESS;

	if (itresult == ISC_R_SUCCESS && ctx->neworigin != NULL) {
		isc_buffer_clear(buffer);
		itresult = dns_name_totext(ctx->neworigin, ISC_FALSE, buffer);
		RUNTIME_CHECK(itresult == ISC_R_SUCCESS);
		isc_buffer_usedregion(buffer, &r);
		fprintf(f, "$ORIGIN %.*s\n", (int) r.length, (char *) r.base);
		ctx->neworigin = NULL;
	}

 again:
	for (i = 0;
	     itresult == ISC_R_SUCCESS && i < MAXSORT;
	     itresult = dns_rdatasetiter_next(rdsiter), i++) {
		dns_rdataset_init(&rdatasets[i]);
		dns_rdatasetiter_current(rdsiter, &rdatasets[i]);
		sorted[i] = &rdatasets[i];
	}
	n = i;
	INSIST(n <= MAXSORT);

	qsort(sorted, n, sizeof(sorted[0]), dump_order_compare);

	for (i = 0; i < n; i++) {
		dns_rdataset_t *rds = sorted[i];
		if (ctx->style.flags & DNS_STYLEFLAG_TRUST) {
			unsigned int trust = rds->trust;
			INSIST(trust < (sizeof(trustnames) /
					sizeof(trustnames[0])));
			fprintf(f, "; %s\n", trustnames[trust]);
		}
		if (rds->type == 0 &&
		    (ctx->style.flags & DNS_STYLEFLAG_NCACHE) == 0) {
			/* Omit negative cache entries */
		} else {
			isc_result_t result =
				dump_rdataset(mctx, name, rds, ctx,
					       buffer, f);
			if (result != ISC_R_SUCCESS)
				dumpresult = result;
			if ((ctx->style.flags & DNS_STYLEFLAG_OMIT_OWNER) != 0)
				name = NULL;
		}
		dns_rdataset_disassociate(rds);
	}

	if (dumpresult != ISC_R_SUCCESS)
		return (dumpresult);

	/*
	 * If we got more data than could be sorted at once,
	 * go handle the rest.
	 */
	if (itresult == ISC_R_SUCCESS)
		goto again;

	if (itresult == ISC_R_NOMORE)
		itresult = ISC_R_SUCCESS;

	return (itresult);
}

/*
 * Dump given RRsets in the "raw" format.
 */
static isc_result_t
dump_rdataset_raw(isc_mem_t *mctx, dns_name_t *name, dns_rdataset_t *rdataset,
		  isc_buffer_t *buffer, FILE *f)
{
	isc_result_t result;
	isc_uint32_t totallen;
	isc_uint16_t dlen;
	isc_region_t r, r_hdr;

	REQUIRE(buffer->length > 0);
	REQUIRE(DNS_RDATASET_VALID(rdataset));

 restart:
	totallen = 0;
	result = dns_rdataset_first(rdataset);
	REQUIRE(result == ISC_R_SUCCESS);

	isc_buffer_clear(buffer);

	/*
	 * Common header and owner name (length followed by name)
	 * These fields should be in a moderate length, so we assume we
	 * can store all of them in the initial buffer.
	 */
	isc_buffer_availableregion(buffer, &r_hdr);
	INSIST(r_hdr.length >= sizeof(dns_masterrawrdataset_t));
	isc_buffer_putuint32(buffer, totallen);	/* XXX: leave space */
	isc_buffer_putuint16(buffer, rdataset->rdclass); /* 16-bit class */
	isc_buffer_putuint16(buffer, rdataset->type); /* 16-bit type */
	isc_buffer_putuint16(buffer, rdataset->covers);	/* same as type */
	isc_buffer_putuint32(buffer, rdataset->ttl); /* 32-bit TTL */
	isc_buffer_putuint32(buffer, dns_rdataset_count(rdataset));
	totallen = isc_buffer_usedlength(buffer);
	INSIST(totallen <= sizeof(dns_masterrawrdataset_t));

	dns_name_toregion(name, &r);
	INSIST(isc_buffer_availablelength(buffer) >=
	       (sizeof(dlen) + r.length));
	dlen = (isc_uint16_t)r.length;
	isc_buffer_putuint16(buffer, dlen);
	isc_buffer_copyregion(buffer, &r);
	totallen += sizeof(dlen) + r.length;

	do {
		dns_rdata_t rdata = DNS_RDATA_INIT;
		isc_region_t r;

		dns_rdataset_current(rdataset, &rdata);
		dns_rdata_toregion(&rdata, &r);
		INSIST(r.length <= 0xffffU);
		dlen = (isc_uint16_t)r.length;

		/*
		 * Copy the rdata into the buffer.  If the buffer is too small,
		 * grow it.  This should be rare, so we'll simply restart the
		 * entire procedure (or should we copy the old data and
		 * continue?).
		 */
		if (isc_buffer_availablelength(buffer) <
						 sizeof(dlen) + r.length) {
			int newlength;
			void *newmem;

			newlength = buffer->length * 2;
			newmem = isc_mem_get(mctx, newlength);
			if (newmem == NULL)
				return (ISC_R_NOMEMORY);
			isc_mem_put(mctx, buffer->base, buffer->length);
			isc_buffer_init(buffer, newmem, newlength);
			goto restart;
		}
		isc_buffer_putuint16(buffer, dlen);
		isc_buffer_copyregion(buffer, &r);
		totallen += sizeof(dlen) + r.length;

		result = dns_rdataset_next(rdataset);
	} while (result == ISC_R_SUCCESS);

	if (result != ISC_R_NOMORE)
		return (result);

	/*
	 * Fill in the total length field.
	 * XXX: this is a bit tricky.  Since we have already "used" the space
	 * for the total length in the buffer, we first remember the entire
	 * buffer length in the region, "rewind", and then write the value.
	 */
	isc_buffer_usedregion(buffer, &r);
	isc_buffer_clear(buffer);
	isc_buffer_putuint32(buffer, totallen);
	INSIST(isc_buffer_usedlength(buffer) < totallen);

	/*
	 * Write the buffer contents to the raw master file.
	 */
	result = isc_stdio_write(r.base, 1, (size_t)r.length, f, NULL);

	if (result != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "raw master file write failed: %s",
				 isc_result_totext(result));
		return (result);
	}

	return (result);
}

static isc_result_t
dump_rdatasets_raw(isc_mem_t *mctx, dns_name_t *name,
		   dns_rdatasetiter_t *rdsiter, dns_totext_ctx_t *ctx,
		   isc_buffer_t *buffer, FILE *f)
{
	isc_result_t result;
	dns_rdataset_t rdataset;

	for (result = dns_rdatasetiter_first(rdsiter);
	     result == ISC_R_SUCCESS;
	     result = dns_rdatasetiter_next(rdsiter)) {

		dns_rdataset_init(&rdataset);
		dns_rdatasetiter_current(rdsiter, &rdataset);

		if (rdataset.type == 0 &&
		    (ctx->style.flags & DNS_STYLEFLAG_NCACHE) == 0) {
			/* Omit negative cache entries */
		} else {
			result = dump_rdataset_raw(mctx, name, &rdataset,
						   buffer, f);
		}
		dns_rdataset_disassociate(&rdataset);
	}

	if (result == ISC_R_NOMORE)
		result = ISC_R_SUCCESS;

	return (result);
}

/*
 * Initial size of text conversion buffer.  The buffer is used
 * for several purposes: converting origin names, rdatasets,
 * $DATE timestamps, and comment strings for $TTL directives.
 *
 * When converting rdatasets, it is dynamically resized, but
 * when converting origins, timestamps, etc it is not.  Therefore,
 * the initial size must large enough to hold the longest possible
 * text representation of any domain name (for $ORIGIN).
 */
static const int initial_buffer_length = 1200;

static isc_result_t
dumptostreaminc(dns_dumpctx_t *dctx);

static void
dumpctx_destroy(dns_dumpctx_t *dctx) {

	dctx->magic = 0;
	DESTROYLOCK(&dctx->lock);
	if (dctx->version != NULL)
		dns_db_closeversion(dctx->db, &dctx->version, ISC_FALSE);
	dns_dbiterator_destroy(&dctx->dbiter);
	dns_db_detach(&dctx->db);
	if (dctx->task != NULL)
		isc_task_detach(&dctx->task);
	if (dctx->file != NULL)
		isc_mem_free(dctx->mctx, dctx->file);
	if (dctx->tmpfile != NULL)
		isc_mem_free(dctx->mctx, dctx->tmpfile);
	isc_mem_putanddetach(&dctx->mctx, dctx, sizeof(*dctx));
}

void
dns_dumpctx_attach(dns_dumpctx_t *source, dns_dumpctx_t **target) {

	REQUIRE(DNS_DCTX_VALID(source));
	REQUIRE(target != NULL && *target == NULL);

	LOCK(&source->lock);
	INSIST(source->references > 0);
	source->references++;
	INSIST(source->references != 0);	/* Overflow? */
	UNLOCK(&source->lock);

	*target = source;
}

void
dns_dumpctx_detach(dns_dumpctx_t **dctxp) {
	dns_dumpctx_t *dctx;
	isc_boolean_t need_destroy = ISC_FALSE;

	REQUIRE(dctxp != NULL);
	dctx = *dctxp;
	REQUIRE(DNS_DCTX_VALID(dctx));

	*dctxp = NULL;

	LOCK(&dctx->lock);
	INSIST(dctx->references != 0);
	dctx->references--;
	if (dctx->references == 0)
		need_destroy = ISC_TRUE;
	UNLOCK(&dctx->lock);
	if (need_destroy)
		dumpctx_destroy(dctx);
}

dns_dbversion_t *
dns_dumpctx_version(dns_dumpctx_t *dctx) {
        REQUIRE(DNS_DCTX_VALID(dctx));
	return (dctx->version);
}

dns_db_t *
dns_dumpctx_db(dns_dumpctx_t *dctx) {
        REQUIRE(DNS_DCTX_VALID(dctx));
	return (dctx->db);
}

void
dns_dumpctx_cancel(dns_dumpctx_t *dctx) {
	REQUIRE(DNS_DCTX_VALID(dctx));

	LOCK(&dctx->lock);
	dctx->canceled = ISC_TRUE;
	UNLOCK(&dctx->lock);
}

static isc_result_t
closeandrename(FILE *f, isc_result_t result, const char *temp, const char *file)
{
	isc_result_t tresult;
	isc_boolean_t logit = ISC_TF(result == ISC_R_SUCCESS);

	if (result == ISC_R_SUCCESS)
		result = isc_stdio_sync(f);
	if (result != ISC_R_SUCCESS && logit) {
		isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
			      DNS_LOGMODULE_MASTERDUMP, ISC_LOG_ERROR,
			      "dumping master file: %s: fsync: %s",
			      temp, isc_result_totext(result));
		logit = ISC_FALSE;
	}
	tresult = isc_stdio_close(f);
	if (result == ISC_R_SUCCESS)
		result = tresult;
	if (result != ISC_R_SUCCESS && logit) {
		isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
			      DNS_LOGMODULE_MASTERDUMP, ISC_LOG_ERROR,
			      "dumping master file: %s: fclose: %s",
			      temp, isc_result_totext(result));
		logit = ISC_FALSE;
	}
	if (result == ISC_R_SUCCESS)
		result = isc_file_rename(temp, file);
	else
		(void)isc_file_remove(temp);
	if (result != ISC_R_SUCCESS && logit) {
		isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
			      DNS_LOGMODULE_MASTERDUMP, ISC_LOG_ERROR,
			      "dumping master file: rename: %s: %s",
			      file, isc_result_totext(result));
	}
	return (result);
}

static void
dump_quantum(isc_task_t *task, isc_event_t *event) {
	isc_result_t result;
	isc_result_t tresult;
	dns_dumpctx_t *dctx;

	REQUIRE(event != NULL);
	dctx = event->ev_arg;
	REQUIRE(DNS_DCTX_VALID(dctx));
	if (dctx->canceled)
		result = ISC_R_CANCELED;
	else
		result = dumptostreaminc(dctx);
	if (result == DNS_R_CONTINUE) {
		event->ev_arg = dctx;
		isc_task_send(task, &event);
		return;
	}

	if (dctx->file != NULL) {
		tresult = closeandrename(dctx->f, result,
					 dctx->tmpfile, dctx->file);
		if (tresult != ISC_R_SUCCESS && result == ISC_R_SUCCESS)
			result = tresult;
	}
	(dctx->done)(dctx->done_arg, result);
	isc_event_free(&event);
	dns_dumpctx_detach(&dctx);
}

static isc_result_t
task_send(dns_dumpctx_t *dctx) {
	isc_event_t *event;

	event = isc_event_allocate(dctx->mctx, NULL, DNS_EVENT_DUMPQUANTUM,
				   dump_quantum, dctx, sizeof(*event));
	if (event == NULL)
		return (ISC_R_NOMEMORY);
	isc_task_send(dctx->task, &event);
	return (ISC_R_SUCCESS);
}

static isc_result_t
dumpctx_create(isc_mem_t *mctx, dns_db_t *db, dns_dbversion_t *version,
	       const dns_master_style_t *style, FILE *f, dns_dumpctx_t **dctxp,
	       dns_masterformat_t format)
{
	dns_dumpctx_t *dctx;
	isc_result_t result;
	isc_boolean_t relative;

	dctx = isc_mem_get(mctx, sizeof(*dctx));
	if (dctx == NULL)
		return (ISC_R_NOMEMORY);

	dctx->mctx = NULL;
	dctx->f = f;
	dctx->dbiter = NULL;
	dctx->db = NULL;
	dctx->version = NULL;
	dctx->done = NULL;
	dctx->done_arg = NULL;
	dctx->task = NULL;
	dctx->nodes = 0;
	dctx->first = ISC_TRUE;
	dctx->canceled = ISC_FALSE;
	dctx->file = NULL;
	dctx->tmpfile = NULL;
	dctx->format = format;

	switch (format) {
	case dns_masterformat_text:
		dctx->dumpsets = dump_rdatasets_text;
		break;
	case dns_masterformat_raw:
		dctx->dumpsets = dump_rdatasets_raw;
		break;
	default:
		INSIST(0);
		break;
	}

	result = totext_ctx_init(style, &dctx->tctx);
	if (result != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "could not set master file style");
		goto cleanup;
	}

	isc_stdtime_get(&dctx->now);
	dns_db_attach(db, &dctx->db);

	dctx->do_date = dns_db_iscache(dctx->db);

	if (dctx->format == dns_masterformat_text &&
	    (dctx->tctx.style.flags & DNS_STYLEFLAG_REL_OWNER) != 0) {
		relative = ISC_TRUE;
	} else
		relative = ISC_FALSE;
	result = dns_db_createiterator(dctx->db, relative, &dctx->dbiter);
	if (result != ISC_R_SUCCESS)
		goto cleanup;

	result = isc_mutex_init(&dctx->lock);
	if (result != ISC_R_SUCCESS)
		goto cleanup;
	if (version != NULL)
		dns_db_attachversion(dctx->db, version, &dctx->version);
	else if (!dns_db_iscache(db))
		dns_db_currentversion(dctx->db, &dctx->version);
	isc_mem_attach(mctx, &dctx->mctx);
	dctx->references = 1;
	dctx->magic = DNS_DCTX_MAGIC;
	*dctxp = dctx;
	return (ISC_R_SUCCESS);

 cleanup:
	if (dctx->dbiter != NULL)
		dns_dbiterator_destroy(&dctx->dbiter);
	if (dctx->db != NULL)
		dns_db_detach(&dctx->db);
	if (dctx != NULL)
		isc_mem_put(mctx, dctx, sizeof(*dctx));
	return (result);
}

static isc_result_t
dumptostreaminc(dns_dumpctx_t *dctx) {
	isc_result_t result;
	isc_buffer_t buffer;
	char *bufmem;
	isc_region_t r;
	dns_name_t *name;
	dns_fixedname_t fixname;
	unsigned int nodes;
	dns_masterrawheader_t rawheader;
	isc_uint32_t now32;
	isc_time_t start;

	bufmem = isc_mem_get(dctx->mctx, initial_buffer_length);
	if (bufmem == NULL)
		return (ISC_R_NOMEMORY);

	isc_buffer_init(&buffer, bufmem, initial_buffer_length);

	dns_fixedname_init(&fixname);
	name = dns_fixedname_name(&fixname);

	if (dctx->first) {
		switch (dctx->format) {
		case dns_masterformat_text:
			/*
			 * If the database has cache semantics, output an
			 * RFC2540 $DATE directive so that the TTLs can be
			 * adjusted when it is reloaded.  For zones it is not
			 * really needed, and it would make the file
			 * incompatible with pre-RFC2540 software, so we omit
			 * it in the zone case.
			 */
			if (dctx->do_date) {
				result = dns_time32_totext(dctx->now, &buffer);
				RUNTIME_CHECK(result == ISC_R_SUCCESS);
				isc_buffer_usedregion(&buffer, &r);
				fprintf(dctx->f, "$DATE %.*s\n",
					(int) r.length, (char *) r.base);
			}
			break;
		case dns_masterformat_raw:
			r.base = (unsigned char *)&rawheader;
			r.length = sizeof(rawheader);
			isc_buffer_region(&buffer, &r);
			isc_buffer_putuint32(&buffer, dns_masterformat_raw);
			isc_buffer_putuint32(&buffer, DNS_RAWFORMAT_VERSION);
			if (sizeof(now32) != sizeof(dctx->now)) {
				/*
				 * We assume isc_stdtime_t is a 32-bit integer,
				 * which should be the case on most cases.
				 * If it turns out to be uncommon, we'll need
				 * to bump the version number and revise the
				 * header format.
				 */
				isc_log_write(dns_lctx,
					      ISC_LOGCATEGORY_GENERAL,
					      DNS_LOGMODULE_MASTERDUMP,
					      ISC_LOG_INFO,
					      "dumping master file in raw "
					      "format: stdtime is not 32bits");
				now32 = 0;
			} else
				now32 = dctx->now;
			isc_buffer_putuint32(&buffer, now32);
			INSIST(isc_buffer_usedlength(&buffer) <=
			       sizeof(rawheader));
			result = isc_stdio_write(buffer.base, 1,
						 isc_buffer_usedlength(&buffer),
						 dctx->f, NULL);
			if (result != ISC_R_SUCCESS)
				return (result);
			isc_buffer_clear(&buffer);
			break;
		default:
			INSIST(0);
		}

		result = dns_dbiterator_first(dctx->dbiter);
		dctx->first = ISC_FALSE;
	} else
		result = ISC_R_SUCCESS;

	nodes = dctx->nodes;
	isc_time_now(&start);
	while (result == ISC_R_SUCCESS && (dctx->nodes == 0 || nodes--)) {
		dns_rdatasetiter_t *rdsiter = NULL;
		dns_dbnode_t *node = NULL;

		result = dns_dbiterator_current(dctx->dbiter, &node, name);
		if (result != ISC_R_SUCCESS && result != DNS_R_NEWORIGIN)
			break;
		if (result == DNS_R_NEWORIGIN) {
			dns_name_t *origin =
				dns_fixedname_name(&dctx->tctx.origin_fixname);
			result = dns_dbiterator_origin(dctx->dbiter, origin);
			RUNTIME_CHECK(result == ISC_R_SUCCESS);
			if ((dctx->tctx.style.flags & DNS_STYLEFLAG_REL_DATA) != 0)
				dctx->tctx.origin = origin;
			dctx->tctx.neworigin = origin;
		}
		result = dns_db_allrdatasets(dctx->db, node, dctx->version,
					     dctx->now, &rdsiter);
		if (result != ISC_R_SUCCESS) {
			dns_db_detachnode(dctx->db, &node);
			goto fail;
		}
		result = (dctx->dumpsets)(dctx->mctx, name, rdsiter,
					  &dctx->tctx, &buffer, dctx->f);
		dns_rdatasetiter_destroy(&rdsiter);
		if (result != ISC_R_SUCCESS) {
			dns_db_detachnode(dctx->db, &node);
			goto fail;
		}
		dns_db_detachnode(dctx->db, &node);
		result = dns_dbiterator_next(dctx->dbiter);
	}

	/*
	 * Work out how many nodes can be written in the time between
	 * two requests to the nameserver.  Smooth the resulting number and
	 * use it as a estimate for the number of nodes to be written in the
	 * next iteration.
	 */
	if (dctx->nodes != 0 && result == ISC_R_SUCCESS) {
		unsigned int pps = dns_pps;	/* packets per second */
		unsigned int interval;
		isc_uint64_t usecs;
		isc_time_t end;

		isc_time_now(&end);
		if (pps < 100)
			pps = 100;
		interval = 1000000 / pps;	/* interval in usecs */
		if (interval == 0)
			interval = 1;
		usecs = isc_time_microdiff(&end, &start);
		if (usecs == 0) {
			dctx->nodes = dctx->nodes * 2;
			if (dctx->nodes > 1000)
				dctx->nodes = 1000;
		} else {
			nodes = dctx->nodes * interval;
			nodes /= (unsigned int)usecs;
			if (nodes == 0)
				nodes = 1;
			else if (nodes > 1000)
				nodes = 1000;

			/* Smooth and assign. */
			dctx->nodes = (nodes + dctx->nodes * 7) / 8;

			isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
				      DNS_LOGMODULE_MASTERDUMP,
				      ISC_LOG_DEBUG(1),
				      "dumptostreaminc(%p) new nodes -> %d\n",
				      dctx, dctx->nodes);
		}
		result = dns_dbiterator_pause(dctx->dbiter);
		RUNTIME_CHECK(result == ISC_R_SUCCESS);
		result = DNS_R_CONTINUE;
	} else if (result == ISC_R_NOMORE)
		result = ISC_R_SUCCESS;
 fail:
	isc_mem_put(dctx->mctx, buffer.base, buffer.length);
	return (result);
}

isc_result_t
dns_master_dumptostreaminc(isc_mem_t *mctx, dns_db_t *db,
			   dns_dbversion_t *version,
			   const dns_master_style_t *style,
			   FILE *f, isc_task_t *task,
			   dns_dumpdonefunc_t done, void *done_arg,
			   dns_dumpctx_t **dctxp)
{
	dns_dumpctx_t *dctx = NULL;
	isc_result_t result;

	REQUIRE(task != NULL);
	REQUIRE(f != NULL);
	REQUIRE(done != NULL);

	result = dumpctx_create(mctx, db, version, style, f, &dctx,
				dns_masterformat_text);
	if (result != ISC_R_SUCCESS)
		return (result);
	isc_task_attach(task, &dctx->task);
	dctx->done = done;
	dctx->done_arg = done_arg;
	dctx->nodes = 100;

	result = task_send(dctx);
	if (result == ISC_R_SUCCESS) {
		dns_dumpctx_attach(dctx, dctxp);
		return (DNS_R_CONTINUE);
	}

	dns_dumpctx_detach(&dctx);
	return (result);
}

/*
 * Dump an entire database into a master file.
 */
isc_result_t
dns_master_dumptostream(isc_mem_t *mctx, dns_db_t *db,
			dns_dbversion_t *version,
			const dns_master_style_t *style,
			FILE *f)
{
	return (dns_master_dumptostream2(mctx, db, version, style,
					 dns_masterformat_text, f));
}

isc_result_t
dns_master_dumptostream2(isc_mem_t *mctx, dns_db_t *db,
			 dns_dbversion_t *version,
			 const dns_master_style_t *style,
			 dns_masterformat_t format, FILE *f)
{
	dns_dumpctx_t *dctx = NULL;
	isc_result_t result;

	result = dumpctx_create(mctx, db, version, style, f, &dctx, format);
	if (result != ISC_R_SUCCESS)
		return (result);

	result = dumptostreaminc(dctx);
	INSIST(result != DNS_R_CONTINUE);
	dns_dumpctx_detach(&dctx);
	return (result);
}

static isc_result_t
opentmp(isc_mem_t *mctx, const char *file, char **tempp, FILE **fp) {
	FILE *f = NULL;
	isc_result_t result;
	char *tempname = NULL;
	int tempnamelen;

	tempnamelen = strlen(file) + 20;
	tempname = isc_mem_allocate(mctx, tempnamelen);
	if (tempname == NULL)
		return (ISC_R_NOMEMORY);

	result = isc_file_mktemplate(file, tempname, tempnamelen);
	if (result != ISC_R_SUCCESS)
		goto cleanup;

	result = isc_file_openunique(tempname, &f);
	if (result != ISC_R_SUCCESS) {
		isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
			      DNS_LOGMODULE_MASTERDUMP, ISC_LOG_ERROR,
			      "dumping master file: %s: open: %s",
			      tempname, isc_result_totext(result));
		goto cleanup;
	}
	*tempp = tempname;
	*fp = f;
	return (ISC_R_SUCCESS);

cleanup:
	isc_mem_free(mctx, tempname);
	return (result);
}

isc_result_t
dns_master_dumpinc(isc_mem_t *mctx, dns_db_t *db, dns_dbversion_t *version,
		   const dns_master_style_t *style, const char *filename,
		   isc_task_t *task, dns_dumpdonefunc_t done, void *done_arg,
		   dns_dumpctx_t **dctxp)
{
	return (dns_master_dumpinc2(mctx, db, version, style, filename, task,
				    done, done_arg, dctxp,
				    dns_masterformat_text));
}

isc_result_t
dns_master_dumpinc2(isc_mem_t *mctx, dns_db_t *db, dns_dbversion_t *version,
		    const dns_master_style_t *style, const char *filename,
		    isc_task_t *task, dns_dumpdonefunc_t done, void *done_arg,
		    dns_dumpctx_t **dctxp, dns_masterformat_t format)
{
	FILE *f = NULL;
	isc_result_t result;
	char *tempname = NULL;
	char *file = NULL;
	dns_dumpctx_t *dctx = NULL;

	file = isc_mem_strdup(mctx, filename);
	if (file == NULL)
		return (ISC_R_NOMEMORY);

	result = opentmp(mctx, filename, &tempname, &f);
	if (result != ISC_R_SUCCESS)
		goto cleanup;

	result = dumpctx_create(mctx, db, version, style, f, &dctx, format);
	if (result != ISC_R_SUCCESS) {
		(void)isc_stdio_close(f);
		(void)isc_file_remove(tempname);
		goto cleanup;
	}

	isc_task_attach(task, &dctx->task);
	dctx->done = done;
	dctx->done_arg = done_arg;
	dctx->nodes = 100;
	dctx->file = file;
	file = NULL;
	dctx->tmpfile = tempname;
	tempname = NULL;

	result = task_send(dctx);
	if (result == ISC_R_SUCCESS) {
		dns_dumpctx_attach(dctx, dctxp);
		return (DNS_R_CONTINUE);
	}

 cleanup:
	if (dctx != NULL)
		dns_dumpctx_detach(&dctx);
	if (file != NULL)
		isc_mem_free(mctx, file);
	if (tempname != NULL)
		isc_mem_free(mctx, tempname);
	return (result);
}

isc_result_t
dns_master_dump(isc_mem_t *mctx, dns_db_t *db, dns_dbversion_t *version,
		const dns_master_style_t *style, const char *filename)
{
	return (dns_master_dump2(mctx, db, version, style, filename,
				 dns_masterformat_text));
}

isc_result_t
dns_master_dump2(isc_mem_t *mctx, dns_db_t *db, dns_dbversion_t *version,
		 const dns_master_style_t *style, const char *filename,
		 dns_masterformat_t format)
{
	FILE *f = NULL;
	isc_result_t result;
	char *tempname;
	dns_dumpctx_t *dctx = NULL;

	result = opentmp(mctx, filename, &tempname, &f);
	if (result != ISC_R_SUCCESS)
		return (result);

	result = dumpctx_create(mctx, db, version, style, f, &dctx, format);
	if (result != ISC_R_SUCCESS)
		goto cleanup;

	result = dumptostreaminc(dctx);
	INSIST(result != DNS_R_CONTINUE);
	dns_dumpctx_detach(&dctx);

	result = closeandrename(f, result, tempname, filename);

 cleanup:
	isc_mem_free(mctx, tempname);
	return (result);
}

/*
 * Dump a database node into a master file.
 * XXX: this function assumes the text format.
 */
isc_result_t
dns_master_dumpnodetostream(isc_mem_t *mctx, dns_db_t *db,
			    dns_dbversion_t *version,
			    dns_dbnode_t *node, dns_name_t *name,
			    const dns_master_style_t *style,
			    FILE *f)
{
	isc_result_t result;
	isc_buffer_t buffer;
	char *bufmem;
	isc_stdtime_t now;
	dns_totext_ctx_t ctx;
	dns_rdatasetiter_t *rdsiter = NULL;

	result = totext_ctx_init(style, &ctx);
	if (result != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "could not set master file style");
		return (ISC_R_UNEXPECTED);
	}

	isc_stdtime_get(&now);

	bufmem = isc_mem_get(mctx, initial_buffer_length);
	if (bufmem == NULL)
		return (ISC_R_NOMEMORY);

	isc_buffer_init(&buffer, bufmem, initial_buffer_length);

	result = dns_db_allrdatasets(db, node, version, now, &rdsiter);
	if (result != ISC_R_SUCCESS)
		goto failure;
	result = dump_rdatasets_text(mctx, name, rdsiter, &ctx, &buffer, f);
	if (result != ISC_R_SUCCESS)
		goto failure;
	dns_rdatasetiter_destroy(&rdsiter);

	result = ISC_R_SUCCESS;

 failure:
	isc_mem_put(mctx, buffer.base, buffer.length);
	return (result);
}

isc_result_t
dns_master_dumpnode(isc_mem_t *mctx, dns_db_t *db, dns_dbversion_t *version,
		    dns_dbnode_t *node, dns_name_t *name,
		    const dns_master_style_t *style, const char *filename)
{
	FILE *f = NULL;
	isc_result_t result;

	result = isc_stdio_open(filename, "w", &f);
	if (result != ISC_R_SUCCESS) {
		isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
			      DNS_LOGMODULE_MASTERDUMP, ISC_LOG_ERROR,
			      "dumping node to file: %s: open: %s", filename,
			      isc_result_totext(result));
		return (ISC_R_UNEXPECTED);
	}

	result = dns_master_dumpnodetostream(mctx, db, version, node, name,
					     style, f);

	result = isc_stdio_close(f);
	if (result != ISC_R_SUCCESS) {
		isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
			      DNS_LOGMODULE_MASTERDUMP, ISC_LOG_ERROR,
			      "dumping master file: %s: close: %s", filename,
			      isc_result_totext(result));
		return (ISC_R_UNEXPECTED);
	}

	return (result);
}

isc_result_t
dns_master_stylecreate(dns_master_style_t **stylep, unsigned int flags,
                       unsigned int ttl_column, unsigned int class_column,
                       unsigned int type_column, unsigned int rdata_column,
                       unsigned int line_length, unsigned int tab_width,
                       isc_mem_t *mctx)
{
	dns_master_style_t *style;

	REQUIRE(stylep != NULL && *stylep == NULL);
	style = isc_mem_get(mctx, sizeof(*style));
	if (style == NULL)
		return (ISC_R_NOMEMORY);

	style->flags = flags;
	style->ttl_column = ttl_column;
	style->class_column = class_column;
	style->type_column = type_column;
	style->rdata_column = rdata_column;
	style->line_length = line_length;
	style->tab_width = tab_width;

	*stylep = style;
	return (ISC_R_SUCCESS);
}

void
dns_master_styledestroy(dns_master_style_t **stylep, isc_mem_t *mctx) {
	dns_master_style_t *style;

	REQUIRE(stylep != NULL && *stylep != NULL);
	style = *stylep;
	*stylep = NULL;
	isc_mem_put(mctx, style, sizeof(*style));
}
@


1.7
log
@resolve conflicts and regen configure script
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")
d18 3
a20 1
/* $ISC: masterdump.c,v 1.56.2.5.2.15 2006/03/10 00:17:21 marka Exp $ */
d34 1
d41 1
d43 1
d73 1
a73 1
/*
d81 1
a81 1
/*
d142 1
a142 1
/*
d179 5
d188 1
a188 1
/*
d361 1
d788 3
a790 3
dump_rdatasets(isc_mem_t *mctx, dns_name_t *name, dns_rdatasetiter_t *rdsiter,
	       dns_totext_ctx_t *ctx,
	       isc_buffer_t *buffer, FILE *f)
d862 140
d1010 1
a1010 1
 * the  initial size must large enough to hold the longest possible
d1175 2
a1176 1
	       const dns_master_style_t *style, FILE *f, dns_dumpctx_t **dctxp)
d1199 13
d1225 5
a1229 2
	relative = ((dctx->tctx.style.flags & DNS_STYLEFLAG_REL_OWNER) != 0) ?
			ISC_TRUE : ISC_FALSE;
d1266 3
d1280 53
a1332 13
		/*
		 * If the database has cache semantics, output an RFC2540
		 * $DATE directive so that the TTLs can be adjusted when
		 * it is reloaded.  For zones it is not really needed, and
		 * it would make the file incompatible with pre-RFC2540
		 * software, so we omit it in the zone case.
		 */
		if (dctx->do_date) {
			result = dns_time32_totext(dctx->now, &buffer);
			RUNTIME_CHECK(result == ISC_R_SUCCESS);
			isc_buffer_usedregion(&buffer, &r);
			fprintf(dctx->f, "$DATE %.*s\n",
				(int) r.length, (char *) r.base);
d1334 1
d1341 1
d1364 2
a1365 2
		result = dump_rdatasets(dctx->mctx, name, rdsiter, &dctx->tctx,
					&buffer, dctx->f);
d1375 6
d1382 33
d1440 2
a1441 1
	result = dumpctx_create(mctx, db, version, style, f, &dctx);
d1468 10
d1481 1
a1481 1
	result = dumpctx_create(mctx, db, version, style, f, &dctx);
d1530 11
d1555 1
a1555 1
	result = dumpctx_create(mctx, db, version, style, f, &dctx);
d1591 9
d1609 1
a1609 1
	result = dumpctx_create(mctx, db, version, style, f, &dctx);
d1626 1
d1660 1
a1660 1
	result = dump_rdatasets(mctx, name, rdsiter, &ctx, &buffer, f);
a1738 1

@


1.6
log
@Be more careful with snprintf return value handling.  Some of these are
from Han Boetes (thanks), some with modifications by me.  OK from and
corrections from niallo@@
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: masterdump.c,v 1.56.2.5.2.12 2004/08/28 06:25:19 marka Exp $ */
d1163 2
a1164 1
		dns_dbiterator_pause(dctx->dbiter);
a1200 2
	if (dctx != NULL)
		dns_dumpctx_detach(&dctx);
d1202 1
@


1.5
log
@resolve conflicts
@
text
@d384 1
a384 1
			unsigned int length;
d389 1
a389 1
			INSIST(length <= sizeof(ttlbuf));
d391 1
a391 1
			if (r.length < length)
d393 3
a395 3
			memcpy(r.base, ttlbuf, length);
			isc_buffer_add(target, length);
			column += length;
@


1.4
log
@update to BIND v9.2.3. ok todd@@
@
text
@d2 2
a3 1
 * Copyright (C) 1999-2001, 2003  Internet Software Consortium.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: masterdump.c,v 1.56.2.5 2003/07/22 04:03:41 marka Exp $ */
d24 1
d26 1
d28 1
d31 1
d36 1
d49 3
a68 50
 * Flags affecting master file formatting.  Flags 0x0000FFFF
 * define the formatting of the rdata part and are defined in
 * rdata.h.
 */

/* Omit the owner name when possible. */
#define DNS_STYLEFLAG_OMIT_OWNER	0x00010000U

/*
 * Omit the TTL when possible.  If DNS_STYLEFLAG_TTL is
 * also set, this means no TTLs are ever printed
 * because $TTL directives are generated before every
 * change in the TTL.  In this case, no columns need to
 * be reserved for the TTL.  Master files generated with
 * these options will be rejected by BIND 4.x because it
 * does not recognize the $TTL directive.
 *
 * If DNS_STYLEFLAG_TTL is not also set, the TTL will be
 * omitted when it is equal to the previous TTL.
 * This is correct according to RFC1035, but the
 * TTLs may be silently misinterpreted by older
 * versions of BIND which use the SOA MINTTL as a
 * default TTL value.
 */
#define DNS_STYLEFLAG_OMIT_TTL		0x00020000U

/* Omit the class when possible. */
#define DNS_STYLEFLAG_OMIT_CLASS	0x00040000U

/* Output $TTL directives. */
#define DNS_STYLEFLAG_TTL		0x00080000U

/*
 * Output $ORIGIN directives and print owner names relative to
 * the origin when possible.
 */
#define DNS_STYLEFLAG_REL_OWNER		0x00100000U

/* Print domain names in RR data in relative form when possible.
   For this to take effect, DNS_STYLEFLAG_REL_OWNER must also be set. */
#define DNS_STYLEFLAG_REL_DATA		0x00200000U

/* Print the trust level of each rdataset. */
#define DNS_STYLEFLAG_TRUST		0x00400000U

/* Print negative caching entries. */
#define DNS_STYLEFLAG_NCACHE		0x00800000U


/*
d105 6
d121 1
a121 1
const dns_master_style_t
d131 1
a131 1
const dns_master_style_t
a136 1

d153 24
a176 1
#define NXDOMAIN(x) (((x)->attributes & DNS_RDATASETATTR_NXDOMAIN) != 0)
d377 4
a380 3
		if (! ((ctx->style.flags & DNS_STYLEFLAG_OMIT_TTL) != 0 &&
		       current_ttl_valid &&
		       rdataset->ttl == current_ttl))
d389 1
a389 1
			INSIST(length < sizeof ttlbuf);
d410 3
a412 2
		if ((ctx->style.flags & DNS_STYLEFLAG_OMIT_CLASS) == 0 ||
		    ctx->class_printed == ISC_FALSE)
d725 1
a725 1
	if (rds->type == dns_rdatatype_sig) {
d864 161
a1024 8
/*
 * Dump an entire database into a master file.
 */
isc_result_t
dns_master_dumptostream(isc_mem_t *mctx, dns_db_t *db,
			dns_dbversion_t *version,
			const dns_master_style_t *style,
			FILE *f)
d1026 1
a1026 3
	dns_fixedname_t fixname;
	dns_name_t *name;
	dns_dbiterator_t *dbiter = NULL;
d1028 19
a1046 5
	isc_buffer_t buffer;
	char *bufmem;
	isc_stdtime_t now;
	isc_region_t r;
	dns_totext_ctx_t ctx;
d1048 1
a1048 1
	result = totext_ctx_init(style, &ctx);
d1052 1
a1052 1
		return (ISC_R_UNEXPECTED);
d1055 33
a1087 2
	dns_fixedname_init(&fixname);
	name = dns_fixedname_name(&fixname);
d1089 9
a1097 1
	isc_stdtime_get(&now);
d1099 1
a1099 1
	bufmem = isc_mem_get(mctx, initial_buffer_length);
d1105 2
a1106 13
	/*
	 * If the database has cache semantics, output an RFC2540
	 * $DATE directive so that the TTLs can be adjusted when
	 * it is reloaded.  For zones it is not really needed, and
	 * it would make the file incompatible with pre-RFC2540
	 * software, so we omit it in the zone case.
	 */
	if (dns_db_iscache(db)) {
		result = dns_time32_totext(now, &buffer);
		RUNTIME_CHECK(result == ISC_R_SUCCESS);
		isc_buffer_usedregion(&buffer, &r);
		fprintf(f, "$DATE %.*s\n", (int) r.length, (char *) r.base);
	}
d1108 19
a1126 6
	result = dns_db_createiterator(db,
		       ((ctx.style.flags & DNS_STYLEFLAG_REL_OWNER) != 0) ?
			   ISC_TRUE : ISC_FALSE,
		       &dbiter);
	if (result != ISC_R_SUCCESS)
		goto create_iter_failure;
d1128 2
a1129 3
	result = dns_dbiterator_first(dbiter);

	while (result == ISC_R_SUCCESS) {
d1132 2
a1133 1
		result = dns_dbiterator_current(dbiter, &node, name);
d1138 2
a1139 2
				dns_fixedname_name(&ctx.origin_fixname);
			result = dns_dbiterator_origin(dbiter, origin);
d1141 3
a1143 3
			if ((ctx.style.flags & DNS_STYLEFLAG_REL_DATA) != 0)
				ctx.origin = origin;
			ctx.neworigin = origin;
d1145 2
a1146 1
		result = dns_db_allrdatasets(db, node, version, now, &rdsiter);
d1148 2
a1149 2
			dns_db_detachnode(db, &node);
			goto iter_failure;
d1151 3
a1153 2
		result = dump_rdatasets(mctx, name, rdsiter, &ctx,
					&buffer, f);
d1155 2
a1156 2
			dns_db_detachnode(db, &node);
			goto iter_failure;
d1158 2
a1159 3
		dns_rdatasetiter_destroy(&rdsiter);
		dns_db_detachnode(db, &node);
		result = dns_dbiterator_next(dbiter);
a1160 2
	if (result != ISC_R_NOMORE)
		goto iter_failure;
d1162 24
a1185 1
	result = ISC_R_SUCCESS;
d1187 15
a1201 2
 iter_failure:
	dns_dbiterator_destroy(&dbiter);
a1202 2
 create_iter_failure:
	isc_mem_put(mctx, buffer.base, buffer.length);
d1206 3
a1208 1

d1210 4
a1213 2
dns_master_dump(isc_mem_t *mctx, dns_db_t *db, dns_dbversion_t *version,
		const dns_master_style_t *style, const char *filename)
d1215 15
d1232 1
a1232 1
	char *tempname;
d1235 2
a1236 2
	tempnamelen = strlen(filename) + 20;
	tempname = isc_mem_get(mctx, tempnamelen);
d1240 1
a1240 1
	result = isc_file_mktemplate(filename, tempname, tempnamelen);
d1252 20
d1273 9
a1281 1
	result = dns_master_dumptostream(mctx, db, version, style, f);
a1282 4
		isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
			      DNS_LOGMODULE_MASTERDUMP, ISC_LOG_ERROR,
			      "dumping master file: %s: %s",
			      tempname, isc_result_totext(result));
d1288 13
a1300 9
	result = isc_stdio_sync(f);
	if (result != ISC_R_SUCCESS) {
		isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
			      DNS_LOGMODULE_MASTERDUMP, ISC_LOG_ERROR,
			      "dumping master file: %s: fsync: %s",
			      tempname, isc_result_totext(result));
		(void)isc_stdio_close(f);
		(void)isc_file_remove(tempname);
		goto cleanup;
d1303 25
a1327 7
	result = isc_stdio_close(f);
	if (result != ISC_R_SUCCESS) {
		isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
			      DNS_LOGMODULE_MASTERDUMP, ISC_LOG_ERROR,
			      "dumping master file: %s: close: %s",
			      tempname, isc_result_totext(result));
		(void)isc_file_remove(tempname);
a1328 1
	}
d1330 5
a1334 8
	result = isc_file_rename(tempname, filename);
	if (result != ISC_R_SUCCESS) {
		isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
			      DNS_LOGMODULE_MASTERDUMP, ISC_LOG_ERROR,
			      "dumping master file: rename: %s: %s",
			      filename, isc_result_totext(result));
		goto cleanup;		
	}
d1337 1
a1337 1
	isc_mem_put(mctx, tempname, tempnamelen);
d1419 37
@


1.3
log
@string cleaning; ok jakob, tedu
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2001  Internet Software Consortium.
d18 1
a18 1
/* $ISC: masterdump.c,v 1.56.2.2 2001/10/30 01:53:24 marka Exp $ */
d127 1
d190 1
a190 1

d310 1
d463 4
a466 1
			RETERR(str_totext(";-$\n", target));
d794 1
d802 9
a946 6
			isc_buffer_clear(&buffer);
			result = dns_name_totext(origin, ISC_FALSE, &buffer);
			RUNTIME_CHECK(result == ISC_R_SUCCESS);
			isc_buffer_usedregion(&buffer, &r);
			fprintf(f, "$ORIGIN %.*s\n", (int) r.length,
				(char *) r.base);
d949 1
@


1.2
log
@first sprintf pass from todd@@ and ISC-Bugs #5614.
@
text
@d400 1
a400 1
			INSIST(length <= sizeof ttlbuf);
@


1.1
log
@Initial revision
@
text
@d398 2
a399 1
			length = sprintf(ttlbuf, "%u", rdataset->ttl);
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1999-2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: masterdump.c,v 1.56.2.5.2.12 2004/08/28 06:25:19 marka Exp $ */
a23 1
#include <isc/event.h>
a24 1
#include <isc/magic.h>
a25 1
#include <isc/print.h>
a27 1
#include <isc/task.h>
a31 1
#include <dns/events.h>
a43 3
#define DNS_DCTX_MAGIC		ISC_MAGIC('D', 'c', 't', 'x')
#define DNS_DCTX_VALID(d)	ISC_MAGIC_VALID(d, DNS_DCTX_MAGIC)

d61 50
a126 1
	dns_name_t *		neworigin;
a145 6
dns_master_style_full = {
	DNS_STYLEFLAG_COMMENT,
	46, 46, 46, 64, 120, 8
};

LIBDNS_EXTERNAL_DATA const dns_master_style_t
d156 1
a156 1
LIBDNS_EXTERNAL_DATA const dns_master_style_t
d166 1
a166 1
LIBDNS_EXTERNAL_DATA const dns_master_style_t
d172 1
a188 22
struct dns_dumpctx {
	unsigned int		magic;
	isc_mem_t		*mctx;
	isc_mutex_t		lock;
	unsigned int		references;
	isc_boolean_t		canceled;
	isc_boolean_t		first;
	isc_boolean_t		do_date;
	isc_stdtime_t		now;
	FILE			*f;
	dns_db_t		*db;
	dns_dbversion_t		*version;
	dns_dbiterator_t	*dbiter;
	dns_totext_ctx_t	tctx;
	isc_task_t		*task;
	dns_dumpdonefunc_t	done;
	void			*done_arg;
	unsigned int		nodes;
	/* dns_master_dumpinc() */
	char			*file;
	char 			*tmpfile;
};
a189 1
#define NXDOMAIN(x) (((x)->attributes & DNS_RDATASETATTR_NXDOMAIN) != 0) 
a308 1
	ctx->neworigin = NULL;
d389 3
a391 4
		if ((ctx->style.flags & DNS_STYLEFLAG_NO_TTL) == 0 &&
		    !((ctx->style.flags & DNS_STYLEFLAG_OMIT_TTL) != 0 &&
		      current_ttl_valid &&
		      rdataset->ttl == current_ttl))
d398 2
a399 3
			length = snprintf(ttlbuf, sizeof(ttlbuf), "%u",
					  rdataset->ttl);
			INSIST(length <= sizeof(ttlbuf));
d420 2
a421 3
		if ((ctx->style.flags & DNS_STYLEFLAG_NO_CLASS) == 0 &&
		    ((ctx->style.flags & DNS_STYLEFLAG_OMIT_CLASS) == 0 ||
		     ctx->class_printed == ISC_FALSE))
d460 1
a460 4
			if (NXDOMAIN(rdataset))
				RETERR(str_totext(";-$NXDOMAIN\n", target));
			else
				RETERR(str_totext(";-$NXRRSET\n", target));
d731 1
a731 1
	if (rds->type == dns_rdatatype_rrsig) {
a787 1
	isc_region_t r;
a794 9
	if (itresult == ISC_R_SUCCESS && ctx->neworigin != NULL) {
		isc_buffer_clear(buffer);
		itresult = dns_name_totext(ctx->neworigin, ISC_FALSE, buffer);
		RUNTIME_CHECK(itresult == ISC_R_SUCCESS);
		isc_buffer_usedregion(buffer, &r);
		fprintf(f, "$ORIGIN %.*s\n", (int) r.length, (char *) r.base);
		ctx->neworigin = NULL;
	}

d860 8
a867 80
static isc_result_t
dumptostreaminc(dns_dumpctx_t *dctx);

static void
dumpctx_destroy(dns_dumpctx_t *dctx) {

	dctx->magic = 0;
	DESTROYLOCK(&dctx->lock);
	if (dctx->version != NULL)
		dns_db_closeversion(dctx->db, &dctx->version, ISC_FALSE);
	dns_dbiterator_destroy(&dctx->dbiter);
	dns_db_detach(&dctx->db);
	if (dctx->task != NULL)
		isc_task_detach(&dctx->task);
	if (dctx->file != NULL)
		isc_mem_free(dctx->mctx, dctx->file);
	if (dctx->tmpfile != NULL)
		isc_mem_free(dctx->mctx, dctx->tmpfile);
	isc_mem_putanddetach(&dctx->mctx, dctx, sizeof(*dctx));
}

void
dns_dumpctx_attach(dns_dumpctx_t *source, dns_dumpctx_t **target) {

	REQUIRE(DNS_DCTX_VALID(source));
	REQUIRE(target != NULL && *target == NULL);

	LOCK(&source->lock);
	INSIST(source->references > 0);
	source->references++;
	INSIST(source->references != 0);	/* Overflow? */
	UNLOCK(&source->lock);

	*target = source;
}

void
dns_dumpctx_detach(dns_dumpctx_t **dctxp) {
	dns_dumpctx_t *dctx;
	isc_boolean_t need_destroy = ISC_FALSE;

	REQUIRE(dctxp != NULL);
	dctx = *dctxp;
	REQUIRE(DNS_DCTX_VALID(dctx));

	*dctxp = NULL;

	LOCK(&dctx->lock);
	INSIST(dctx->references != 0);
	dctx->references--;
	if (dctx->references == 0)
		need_destroy = ISC_TRUE;
	UNLOCK(&dctx->lock);
	if (need_destroy)
		dumpctx_destroy(dctx);
}

dns_dbversion_t *
dns_dumpctx_version(dns_dumpctx_t *dctx) {
        REQUIRE(DNS_DCTX_VALID(dctx));
	return (dctx->version);
}

dns_db_t *
dns_dumpctx_db(dns_dumpctx_t *dctx) {
        REQUIRE(DNS_DCTX_VALID(dctx));
	return (dctx->db);
}

void
dns_dumpctx_cancel(dns_dumpctx_t *dctx) {
	REQUIRE(DNS_DCTX_VALID(dctx));

	LOCK(&dctx->lock);
	dctx->canceled = ISC_TRUE;
	UNLOCK(&dctx->lock);
}

static isc_result_t
closeandrename(FILE *f, isc_result_t result, const char *temp, const char *file)
d869 3
a871 37
	isc_result_t tresult;
	isc_boolean_t logit = ISC_TF(result == ISC_R_SUCCESS);

	if (result == ISC_R_SUCCESS)
		result = isc_stdio_sync(f);
	if (result != ISC_R_SUCCESS && logit) {
		isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
			      DNS_LOGMODULE_MASTERDUMP, ISC_LOG_ERROR,
			      "dumping master file: %s: fsync: %s",
			      temp, isc_result_totext(result));
		logit = ISC_FALSE;
	}
	tresult = isc_stdio_close(f);
	if (result == ISC_R_SUCCESS)
		result = tresult;
	if (result != ISC_R_SUCCESS && logit) {
		isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
			      DNS_LOGMODULE_MASTERDUMP, ISC_LOG_ERROR,
			      "dumping master file: %s: fclose: %s",
			      temp, isc_result_totext(result));
		logit = ISC_FALSE;
	}
	if (result == ISC_R_SUCCESS)
		result = isc_file_rename(temp, file);
	else
		(void)isc_file_remove(temp);
	if (result != ISC_R_SUCCESS && logit) {
		isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
			      DNS_LOGMODULE_MASTERDUMP, ISC_LOG_ERROR,
			      "dumping master file: rename: %s: %s",
			      file, isc_result_totext(result));
	}
	return (result);
}

static void
dump_quantum(isc_task_t *task, isc_event_t *event) {
d873 5
a877 2
	isc_result_t tresult;
	dns_dumpctx_t *dctx;
d879 1
a879 63
	REQUIRE(event != NULL);
	dctx = event->ev_arg;
	REQUIRE(DNS_DCTX_VALID(dctx));
	if (dctx->canceled)
		result = ISC_R_CANCELED;
	else
		result = dumptostreaminc(dctx);
	if (result == DNS_R_CONTINUE) {
		event->ev_arg = dctx;
		isc_task_send(task, &event);
		return;
	}

	if (dctx->file != NULL) {
		tresult = closeandrename(dctx->f, result,
					 dctx->tmpfile, dctx->file);
		if (tresult != ISC_R_SUCCESS && result == ISC_R_SUCCESS)
			result = tresult;
	}
	(dctx->done)(dctx->done_arg, result);
	isc_event_free(&event);
	dns_dumpctx_detach(&dctx);
}

static isc_result_t
task_send(dns_dumpctx_t *dctx) {
	isc_event_t *event;

	event = isc_event_allocate(dctx->mctx, NULL, DNS_EVENT_DUMPQUANTUM,
				   dump_quantum, dctx, sizeof(*event));
	if (event == NULL)
		return (ISC_R_NOMEMORY);
	isc_task_send(dctx->task, &event);
	return (ISC_R_SUCCESS);
}

static isc_result_t
dumpctx_create(isc_mem_t *mctx, dns_db_t *db, dns_dbversion_t *version,
	       const dns_master_style_t *style, FILE *f, dns_dumpctx_t **dctxp)
{
	dns_dumpctx_t *dctx;
	isc_result_t result;
	isc_boolean_t relative;

	dctx = isc_mem_get(mctx, sizeof(*dctx));
	if (dctx == NULL)
		return (ISC_R_NOMEMORY);

	dctx->mctx = NULL;
	dctx->f = f;
	dctx->dbiter = NULL;
	dctx->db = NULL;
	dctx->version = NULL;
	dctx->done = NULL;
	dctx->done_arg = NULL;
	dctx->task = NULL;
	dctx->nodes = 0;
	dctx->first = ISC_TRUE;
	dctx->canceled = ISC_FALSE;
	dctx->file = NULL;
	dctx->tmpfile = NULL;

	result = totext_ctx_init(style, &dctx->tctx);
d883 1
a883 1
		goto cleanup;
d886 2
a887 2
	isc_stdtime_get(&dctx->now);
	dns_db_attach(db, &dctx->db);
d889 1
a889 1
	dctx->do_date = dns_db_iscache(dctx->db);
d891 1
a891 40
	relative = ((dctx->tctx.style.flags & DNS_STYLEFLAG_REL_OWNER) != 0) ?
			ISC_TRUE : ISC_FALSE;
	result = dns_db_createiterator(dctx->db, relative, &dctx->dbiter);
	if (result != ISC_R_SUCCESS)
		goto cleanup;

	result = isc_mutex_init(&dctx->lock);
	if (result != ISC_R_SUCCESS)
		goto cleanup;
	if (version != NULL)
		dns_db_attachversion(dctx->db, version, &dctx->version);
	else if (!dns_db_iscache(db))
		dns_db_currentversion(dctx->db, &dctx->version);
	isc_mem_attach(mctx, &dctx->mctx);
	dctx->references = 1;
	dctx->magic = DNS_DCTX_MAGIC;
	*dctxp = dctx;
	return (ISC_R_SUCCESS);

 cleanup:
	if (dctx->dbiter != NULL)
		dns_dbiterator_destroy(&dctx->dbiter);
	if (dctx->db != NULL)
		dns_db_detach(&dctx->db);
	if (dctx != NULL)
		isc_mem_put(mctx, dctx, sizeof(*dctx));
	return (result);
}

static isc_result_t
dumptostreaminc(dns_dumpctx_t *dctx) {
	isc_result_t result;
	isc_buffer_t buffer;
	char *bufmem;
	isc_region_t r;
	dns_name_t *name;
	dns_fixedname_t fixname;
	unsigned int nodes;

	bufmem = isc_mem_get(dctx->mctx, initial_buffer_length);
d897 20
a916 2
	dns_fixedname_init(&fixname);
	name = dns_fixedname_name(&fixname);
d918 1
a918 19
	if (dctx->first) {
		/*
		 * If the database has cache semantics, output an RFC2540
		 * $DATE directive so that the TTLs can be adjusted when
		 * it is reloaded.  For zones it is not really needed, and
		 * it would make the file incompatible with pre-RFC2540
		 * software, so we omit it in the zone case.
		 */
		if (dctx->do_date) {
			result = dns_time32_totext(dctx->now, &buffer);
			RUNTIME_CHECK(result == ISC_R_SUCCESS);
			isc_buffer_usedregion(&buffer, &r);
			fprintf(dctx->f, "$DATE %.*s\n",
				(int) r.length, (char *) r.base);
		}
		result = dns_dbiterator_first(dctx->dbiter);
		dctx->first = ISC_FALSE;
	} else
		result = ISC_R_SUCCESS;
d920 1
a920 2
	nodes = dctx->nodes;
	while (result == ISC_R_SUCCESS && (dctx->nodes == 0 || nodes--)) {
d923 1
a923 2

		result = dns_dbiterator_current(dctx->dbiter, &node, name);
d928 2
a929 2
				dns_fixedname_name(&dctx->tctx.origin_fixname);
			result = dns_dbiterator_origin(dctx->dbiter, origin);
d931 8
a938 3
			if ((dctx->tctx.style.flags & DNS_STYLEFLAG_REL_DATA) != 0)
				dctx->tctx.origin = origin;
			dctx->tctx.neworigin = origin;
d940 1
a940 2
		result = dns_db_allrdatasets(dctx->db, node, dctx->version,
					     dctx->now, &rdsiter);
d942 2
a943 2
			dns_db_detachnode(dctx->db, &node);
			goto fail;
d945 2
a946 3
		result = dump_rdatasets(dctx->mctx, name, rdsiter, &dctx->tctx,
					&buffer, dctx->f);
		dns_rdatasetiter_destroy(&rdsiter);
d948 2
a949 2
			dns_db_detachnode(dctx->db, &node);
			goto fail;
d951 3
a953 2
		dns_db_detachnode(dctx->db, &node);
		result = dns_dbiterator_next(dctx->dbiter);
d955 2
d958 1
a958 9
	if (dctx->nodes != 0 && result == ISC_R_SUCCESS) {
		dns_dbiterator_pause(dctx->dbiter);
		result = DNS_R_CONTINUE;
	} else if (result == ISC_R_NOMORE)
		result = ISC_R_SUCCESS;
 fail:
	isc_mem_put(dctx->mctx, buffer.base, buffer.length);
	return (result);
}
d960 2
a961 30
isc_result_t
dns_master_dumptostreaminc(isc_mem_t *mctx, dns_db_t *db,
			   dns_dbversion_t *version,
			   const dns_master_style_t *style,
			   FILE *f, isc_task_t *task,
			   dns_dumpdonefunc_t done, void *done_arg,
			   dns_dumpctx_t **dctxp)
{
	dns_dumpctx_t *dctx = NULL;
	isc_result_t result;

	REQUIRE(task != NULL);
	REQUIRE(f != NULL);
	REQUIRE(done != NULL);

	result = dumpctx_create(mctx, db, version, style, f, &dctx);
	if (result != ISC_R_SUCCESS)
		return (result);
	isc_task_attach(task, &dctx->task);
	dctx->done = done;
	dctx->done_arg = done_arg;
	dctx->nodes = 100;

	result = task_send(dctx);
	if (result == ISC_R_SUCCESS) {
		dns_dumpctx_attach(dctx, dctxp);
		return (DNS_R_CONTINUE);
	}
	if (dctx != NULL)
		dns_dumpctx_detach(&dctx);
d963 2
d968 1
a968 3
/*
 * Dump an entire database into a master file.
 */
d970 2
a971 4
dns_master_dumptostream(isc_mem_t *mctx, dns_db_t *db,
			dns_dbversion_t *version,
			const dns_master_style_t *style,
			FILE *f)
a972 15
	dns_dumpctx_t *dctx = NULL;
	isc_result_t result;

	result = dumpctx_create(mctx, db, version, style, f, &dctx);
	if (result != ISC_R_SUCCESS)
		return (result);

	result = dumptostreaminc(dctx);
	INSIST(result != DNS_R_CONTINUE);
	dns_dumpctx_detach(&dctx);
	return (result);
}

static isc_result_t
opentmp(isc_mem_t *mctx, const char *file, char **tempp, FILE **fp) {
d975 1
a975 1
	char *tempname = NULL;
d978 2
a979 2
	tempnamelen = strlen(file) + 20;
	tempname = isc_mem_allocate(mctx, tempnamelen);
d983 1
a983 1
	result = isc_file_mktemplate(file, tempname, tempnamelen);
a994 3
	*tempp = tempname;
	*fp = f;
	return (ISC_R_SUCCESS);
d996 8
a1003 23
cleanup:
	isc_mem_free(mctx, tempname);
	return (result);
}

isc_result_t
dns_master_dumpinc(isc_mem_t *mctx, dns_db_t *db, dns_dbversion_t *version,
		   const dns_master_style_t *style, const char *filename,
		   isc_task_t *task, dns_dumpdonefunc_t done, void *done_arg,
		   dns_dumpctx_t **dctxp)
{
	FILE *f = NULL;
	isc_result_t result;
	char *tempname = NULL;
	char *file = NULL;
	dns_dumpctx_t *dctx = NULL;

	file = isc_mem_strdup(mctx, filename);
	if (file == NULL)
		return (ISC_R_NOMEMORY);

	result = opentmp(mctx, filename, &tempname, &f);
	if (result != ISC_R_SUCCESS)
d1005 1
d1007 1
a1007 1
	result = dumpctx_create(mctx, db, version, style, f, &dctx);
d1009 4
d1018 8
a1025 13
	isc_task_attach(task, &dctx->task);
	dctx->done = done;
	dctx->done_arg = done_arg;
	dctx->nodes = 100;
	dctx->file = file;
	file = NULL;
	dctx->tmpfile = tempname;
	tempname = NULL;

	result = task_send(dctx);
	if (result == ISC_R_SUCCESS) {
		dns_dumpctx_attach(dctx, dctxp);
		return (DNS_R_CONTINUE);
d1028 8
a1035 32
 cleanup:
	if (dctx != NULL)
		dns_dumpctx_detach(&dctx);
	if (file != NULL)
		isc_mem_free(mctx, file);
	if (tempname != NULL)
		isc_mem_free(mctx, tempname);
	return (result);
}

isc_result_t
dns_master_dump(isc_mem_t *mctx, dns_db_t *db, dns_dbversion_t *version,
		const dns_master_style_t *style, const char *filename)
{
	FILE *f = NULL;
	isc_result_t result;
	char *tempname;
	dns_dumpctx_t *dctx = NULL;

	result = opentmp(mctx, filename, &tempname, &f);
	if (result != ISC_R_SUCCESS)
		return (result);

	result = dumpctx_create(mctx, db, version, style, f, &dctx);
	if (result != ISC_R_SUCCESS)
		goto cleanup;

	result = dumptostreaminc(dctx);
	INSIST(result != DNS_R_CONTINUE);
	dns_dumpctx_detach(&dctx);

	result = closeandrename(f, result, tempname, filename);
d1038 1
a1038 1
	isc_mem_free(mctx, tempname);
a1119 37

isc_result_t
dns_master_stylecreate(dns_master_style_t **stylep, unsigned int flags,
                       unsigned int ttl_column, unsigned int class_column,
                       unsigned int type_column, unsigned int rdata_column,
                       unsigned int line_length, unsigned int tab_width,
                       isc_mem_t *mctx)
{
	dns_master_style_t *style;

	REQUIRE(stylep != NULL && *stylep == NULL);
	style = isc_mem_get(mctx, sizeof(*style));
	if (style == NULL)
		return (ISC_R_NOMEMORY);

	style->flags = flags;
	style->ttl_column = ttl_column;
	style->class_column = class_column;
	style->type_column = type_column;
	style->rdata_column = rdata_column;
	style->line_length = line_length;
	style->tab_width = tab_width;

	*stylep = style;
	return (ISC_R_SUCCESS);
}

void
dns_master_styledestroy(dns_master_style_t **stylep, isc_mem_t *mctx) {
	dns_master_style_t *style;

	REQUIRE(stylep != NULL && *stylep != NULL);
	style = *stylep;
	*stylep = NULL;
	isc_mem_put(mctx, style, sizeof(*style));
}

@


1.1.1.3
log
@ISC BIND release 9.3.3
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: masterdump.c,v 1.56.2.5.2.15 2006/03/10 00:17:21 marka Exp $ */
d1163 1
a1163 2
		result = dns_dbiterator_pause(dctx->dbiter);
		RUNTIME_CHECK(result == ISC_R_SUCCESS);
d1200 2
a1202 1
	dns_dumpctx_detach(&dctx);
@


1.1.1.4
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 3
/* $ISC: masterdump.c,v 1.73.18.14 2006/08/08 06:39:36 marka Exp $ */

/*! \file */
a31 1
#include <isc/time.h>
a37 1
#include <dns/lib.h>
a38 1
#include <dns/master.h>
d68 1
a68 1
/*%
d76 1
a76 1
/*%
d137 1
a137 1
/*%
a173 5
	dns_masterformat_t	format;
	isc_result_t		(*dumpsets)(isc_mem_t *mctx, dns_name_t *name,
					    dns_rdatasetiter_t *rdsiter,
					    dns_totext_ctx_t *ctx,
					    isc_buffer_t *buffer, FILE *f);
d178 1
a178 1
/*%
a350 1
	rdataset->attributes |= DNS_RDATASETATTR_LOADORDER;
d777 3
a779 3
dump_rdatasets_text(isc_mem_t *mctx, dns_name_t *name,
		    dns_rdatasetiter_t *rdsiter, dns_totext_ctx_t *ctx,
		    isc_buffer_t *buffer, FILE *f)
a850 140
/*
 * Dump given RRsets in the "raw" format.
 */
static isc_result_t
dump_rdataset_raw(isc_mem_t *mctx, dns_name_t *name, dns_rdataset_t *rdataset,
		  isc_buffer_t *buffer, FILE *f)
{
	isc_result_t result;
	isc_uint32_t totallen;
	isc_uint16_t dlen;
	isc_region_t r, r_hdr;

	REQUIRE(buffer->length > 0);
	REQUIRE(DNS_RDATASET_VALID(rdataset));

 restart:
	totallen = 0;
	result = dns_rdataset_first(rdataset);
	REQUIRE(result == ISC_R_SUCCESS);

	isc_buffer_clear(buffer);

	/*
	 * Common header and owner name (length followed by name)
	 * These fields should be in a moderate length, so we assume we
	 * can store all of them in the initial buffer.
	 */
	isc_buffer_availableregion(buffer, &r_hdr);
	INSIST(r_hdr.length >= sizeof(dns_masterrawrdataset_t));
	isc_buffer_putuint32(buffer, totallen);	/* XXX: leave space */
	isc_buffer_putuint16(buffer, rdataset->rdclass); /* 16-bit class */
	isc_buffer_putuint16(buffer, rdataset->type); /* 16-bit type */
	isc_buffer_putuint16(buffer, rdataset->covers);	/* same as type */
	isc_buffer_putuint32(buffer, rdataset->ttl); /* 32-bit TTL */
	isc_buffer_putuint32(buffer, dns_rdataset_count(rdataset));
	totallen = isc_buffer_usedlength(buffer);
	INSIST(totallen <= sizeof(dns_masterrawrdataset_t));

	dns_name_toregion(name, &r);
	INSIST(isc_buffer_availablelength(buffer) >=
	       (sizeof(dlen) + r.length));
	dlen = (isc_uint16_t)r.length;
	isc_buffer_putuint16(buffer, dlen);
	isc_buffer_copyregion(buffer, &r);
	totallen += sizeof(dlen) + r.length;

	do {
		dns_rdata_t rdata = DNS_RDATA_INIT;
		isc_region_t r;

		dns_rdataset_current(rdataset, &rdata);
		dns_rdata_toregion(&rdata, &r);
		INSIST(r.length <= 0xffffU);
		dlen = (isc_uint16_t)r.length;

		/*
		 * Copy the rdata into the buffer.  If the buffer is too small,
		 * grow it.  This should be rare, so we'll simply restart the
		 * entire procedure (or should we copy the old data and
		 * continue?).
		 */
		if (isc_buffer_availablelength(buffer) <
						 sizeof(dlen) + r.length) {
			int newlength;
			void *newmem;

			newlength = buffer->length * 2;
			newmem = isc_mem_get(mctx, newlength);
			if (newmem == NULL)
				return (ISC_R_NOMEMORY);
			isc_mem_put(mctx, buffer->base, buffer->length);
			isc_buffer_init(buffer, newmem, newlength);
			goto restart;
		}
		isc_buffer_putuint16(buffer, dlen);
		isc_buffer_copyregion(buffer, &r);
		totallen += sizeof(dlen) + r.length;

		result = dns_rdataset_next(rdataset);
	} while (result == ISC_R_SUCCESS);

	if (result != ISC_R_NOMORE)
		return (result);

	/*
	 * Fill in the total length field.
	 * XXX: this is a bit tricky.  Since we have already "used" the space
	 * for the total length in the buffer, we first remember the entire
	 * buffer length in the region, "rewind", and then write the value.
	 */
	isc_buffer_usedregion(buffer, &r);
	isc_buffer_clear(buffer);
	isc_buffer_putuint32(buffer, totallen);
	INSIST(isc_buffer_usedlength(buffer) < totallen);

	/*
	 * Write the buffer contents to the raw master file.
	 */
	result = isc_stdio_write(r.base, 1, (size_t)r.length, f, NULL);

	if (result != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "raw master file write failed: %s",
				 isc_result_totext(result));
		return (result);
	}

	return (result);
}

static isc_result_t
dump_rdatasets_raw(isc_mem_t *mctx, dns_name_t *name,
		   dns_rdatasetiter_t *rdsiter, dns_totext_ctx_t *ctx,
		   isc_buffer_t *buffer, FILE *f)
{
	isc_result_t result;
	dns_rdataset_t rdataset;

	for (result = dns_rdatasetiter_first(rdsiter);
	     result == ISC_R_SUCCESS;
	     result = dns_rdatasetiter_next(rdsiter)) {

		dns_rdataset_init(&rdataset);
		dns_rdatasetiter_current(rdsiter, &rdataset);

		if (rdataset.type == 0 &&
		    (ctx->style.flags & DNS_STYLEFLAG_NCACHE) == 0) {
			/* Omit negative cache entries */
		} else {
			result = dump_rdataset_raw(mctx, name, &rdataset,
						   buffer, f);
		}
		dns_rdataset_disassociate(&rdataset);
	}

	if (result == ISC_R_NOMORE)
		result = ISC_R_SUCCESS;

	return (result);
}
d859 1
a859 1
 * the initial size must large enough to hold the longest possible
d1024 1
a1024 2
	       const dns_master_style_t *style, FILE *f, dns_dumpctx_t **dctxp,
	       dns_masterformat_t format)
a1046 13
	dctx->format = format;

	switch (format) {
	case dns_masterformat_text:
		dctx->dumpsets = dump_rdatasets_text;
		break;
	case dns_masterformat_raw:
		dctx->dumpsets = dump_rdatasets_raw;
		break;
	default:
		INSIST(0);
		break;
	}
d1060 2
a1061 5
	if (dctx->format == dns_masterformat_text &&
	    (dctx->tctx.style.flags & DNS_STYLEFLAG_REL_OWNER) != 0) {
		relative = ISC_TRUE;
	} else
		relative = ISC_FALSE;
a1097 3
	dns_masterrawheader_t rawheader;
	isc_uint32_t now32;
	isc_time_t start;
d1109 13
a1121 53
		switch (dctx->format) {
		case dns_masterformat_text:
			/*
			 * If the database has cache semantics, output an
			 * RFC2540 $DATE directive so that the TTLs can be
			 * adjusted when it is reloaded.  For zones it is not
			 * really needed, and it would make the file
			 * incompatible with pre-RFC2540 software, so we omit
			 * it in the zone case.
			 */
			if (dctx->do_date) {
				result = dns_time32_totext(dctx->now, &buffer);
				RUNTIME_CHECK(result == ISC_R_SUCCESS);
				isc_buffer_usedregion(&buffer, &r);
				fprintf(dctx->f, "$DATE %.*s\n",
					(int) r.length, (char *) r.base);
			}
			break;
		case dns_masterformat_raw:
			r.base = (unsigned char *)&rawheader;
			r.length = sizeof(rawheader);
			isc_buffer_region(&buffer, &r);
			isc_buffer_putuint32(&buffer, dns_masterformat_raw);
			isc_buffer_putuint32(&buffer, DNS_RAWFORMAT_VERSION);
			if (sizeof(now32) != sizeof(dctx->now)) {
				/*
				 * We assume isc_stdtime_t is a 32-bit integer,
				 * which should be the case on most cases.
				 * If it turns out to be uncommon, we'll need
				 * to bump the version number and revise the
				 * header format.
				 */
				isc_log_write(dns_lctx,
					      ISC_LOGCATEGORY_GENERAL,
					      DNS_LOGMODULE_MASTERDUMP,
					      ISC_LOG_INFO,
					      "dumping master file in raw "
					      "format: stdtime is not 32bits");
				now32 = 0;
			} else
				now32 = dctx->now;
			isc_buffer_putuint32(&buffer, now32);
			INSIST(isc_buffer_usedlength(&buffer) <=
			       sizeof(rawheader));
			result = isc_stdio_write(buffer.base, 1,
						 isc_buffer_usedlength(&buffer),
						 dctx->f, NULL);
			if (result != ISC_R_SUCCESS)
				return (result);
			isc_buffer_clear(&buffer);
			break;
		default:
			INSIST(0);
a1122 1

a1128 1
	isc_time_now(&start);
d1151 2
a1152 2
		result = (dctx->dumpsets)(dctx->mctx, name, rdsiter,
					  &dctx->tctx, &buffer, dctx->f);
a1161 6
	/*
	 * Work out how many nodes can be written in the time between
	 * two requests to the nameserver.  Smooth the resulting number and
	 * use it as a estimate for the number of nodes to be written in the
	 * next iteration.
	 */
a1162 33
		unsigned int pps = dns_pps;	/* packets per second */
		unsigned int interval;
		isc_uint64_t usecs;
		isc_time_t end;

		isc_time_now(&end);
		if (pps < 100)
			pps = 100;
		interval = 1000000 / pps;	/* interval in usecs */
		if (interval == 0)
			interval = 1;
		usecs = isc_time_microdiff(&end, &start);
		if (usecs == 0) {
			dctx->nodes = dctx->nodes * 2;
			if (dctx->nodes > 1000)
				dctx->nodes = 1000;
		} else {
			nodes = dctx->nodes * interval;
			nodes /= (unsigned int)usecs;
			if (nodes == 0)
				nodes = 1;
			else if (nodes > 1000)
				nodes = 1000;

			/* Smooth and assign. */
			dctx->nodes = (nodes + dctx->nodes * 7) / 8;

			isc_log_write(dns_lctx, ISC_LOGCATEGORY_GENERAL,
				      DNS_LOGMODULE_MASTERDUMP,
				      ISC_LOG_DEBUG(1),
				      "dumptostreaminc(%p) new nodes -> %d\n",
				      dctx, dctx->nodes);
		}
d1188 1
a1188 2
	result = dumpctx_create(mctx, db, version, style, f, &dctx,
				dns_masterformat_text);
a1214 10
	return (dns_master_dumptostream2(mctx, db, version, style,
					 dns_masterformat_text, f));
}

isc_result_t
dns_master_dumptostream2(isc_mem_t *mctx, dns_db_t *db,
			 dns_dbversion_t *version,
			 const dns_master_style_t *style,
			 dns_masterformat_t format, FILE *f)
{
d1218 1
a1218 1
	result = dumpctx_create(mctx, db, version, style, f, &dctx, format);
a1266 11
	return (dns_master_dumpinc2(mctx, db, version, style, filename, task,
				    done, done_arg, dctxp,
				    dns_masterformat_text));
}

isc_result_t
dns_master_dumpinc2(isc_mem_t *mctx, dns_db_t *db, dns_dbversion_t *version,
		    const dns_master_style_t *style, const char *filename,
		    isc_task_t *task, dns_dumpdonefunc_t done, void *done_arg,
		    dns_dumpctx_t **dctxp, dns_masterformat_t format)
{
d1281 1
a1281 1
	result = dumpctx_create(mctx, db, version, style, f, &dctx, format);
a1316 9
	return (dns_master_dump2(mctx, db, version, style, filename,
				 dns_masterformat_text));
}

isc_result_t
dns_master_dump2(isc_mem_t *mctx, dns_db_t *db, dns_dbversion_t *version,
		 const dns_master_style_t *style, const char *filename,
		 dns_masterformat_t format)
{
d1326 1
a1326 1
	result = dumpctx_create(mctx, db, version, style, f, &dctx, format);
a1342 1
 * XXX: this function assumes the text format.
d1376 1
a1376 1
	result = dump_rdatasets_text(mctx, name, rdsiter, &ctx, &buffer, f);
d1455 1
@


