head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.36
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.32
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.34
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.26
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.30
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.28
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.24
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.22
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.20
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.18
	OPENBSD_5_0:1.6.0.16
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.14
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.12
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.8
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.10
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.6
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	BIND_9_4_2_P1:1.1.1.4
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	BIND_9_4_2:1.1.1.4
	OPENBSD_4_2:1.5.0.4
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	BIND_9_3_4:1.1.1.3
	BIND_9_3_3:1.1.1.3
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	BIND_9_3_2:1.1.1.2
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2007.12.09.13.39.43;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.10.19.07.59;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.28.17.14.05;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.18.14.14.06;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.05.23.10.09;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.06.58;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.06.58;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.34.40;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.01.10.18.19.28;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.12.09.12.34.28;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.6
log
@resolve conflicts
@
text
@/*
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1998-2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: gen.c,v 1.73.18.6 2006/10/02 06:36:43 marka Exp $ */

/*! \file */

#ifdef WIN32
/*
 * Silence compiler warnings about using strcpy and friends.
 */
#define _CRT_SECURE_NO_DEPRECATE 1
#endif

#include <sys/types.h>

#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef WIN32
#include "gen-win32.h"
#else
#include "gen-unix.h"
#endif

#define FROMTEXTARGS "rdclass, type, lexer, origin, options, target, callbacks"
#define FROMTEXTCLASS "rdclass"
#define FROMTEXTTYPE "type"
#define FROMTEXTDEF "result = DNS_R_UNKNOWN"

#define TOTEXTARGS "rdata, tctx, target"
#define TOTEXTCLASS "rdata->rdclass"
#define TOTEXTTYPE "rdata->type"
#define TOTEXTDEF "use_default = ISC_TRUE"

#define FROMWIREARGS "rdclass, type, source, dctx, options, target"
#define FROMWIRECLASS "rdclass"
#define FROMWIRETYPE "type"
#define FROMWIREDEF "use_default = ISC_TRUE"

#define TOWIREARGS "rdata, cctx, target"
#define TOWIRECLASS "rdata->rdclass"
#define TOWIRETYPE "rdata->type"
#define TOWIREDEF "use_default = ISC_TRUE"

#define FROMSTRUCTARGS "rdclass, type, source, target"
#define FROMSTRUCTCLASS "rdclass"
#define FROMSTRUCTTYPE "type"
#define FROMSTRUCTDEF "use_default = ISC_TRUE"

#define TOSTRUCTARGS "rdata, target, mctx"
#define TOSTRUCTCLASS "rdata->rdclass"
#define TOSTRUCTTYPE "rdata->type"
#define TOSTRUCTDEF "use_default = ISC_TRUE"

#define FREESTRUCTARGS "source"
#define FREESTRUCTCLASS "common->rdclass"
#define FREESTRUCTTYPE "common->rdtype"
#define FREESTRUCTDEF NULL

#define COMPAREARGS "rdata1, rdata2"
#define COMPARECLASS "rdata1->rdclass"
#define COMPARETYPE "rdata1->type"
#define COMPAREDEF "use_default = ISC_TRUE"

#define ADDITIONALDATAARGS "rdata, add, arg"
#define ADDITIONALDATACLASS "rdata->rdclass"
#define ADDITIONALDATATYPE "rdata->type"
#define ADDITIONALDATADEF "use_default = ISC_TRUE"

#define DIGESTARGS "rdata, digest, arg"
#define DIGESTCLASS "rdata->rdclass"
#define DIGESTTYPE "rdata->type"
#define DIGESTDEF "use_default = ISC_TRUE"

#define CHECKOWNERARGS "name, rdclass, type, wildcard"
#define CHECKOWNERCLASS "rdclass"
#define CHECKOWNERTYPE "type"
#define CHECKOWNERDEF "result = ISC_TRUE"

#define CHECKNAMESARGS "rdata, owner, bad"
#define CHECKNAMESCLASS "rdata->rdclass"
#define CHECKNAMESTYPE "rdata->type"
#define CHECKNAMESDEF "result = ISC_TRUE"

const char copyright[] =
"/*\n"
" * Copyright (C) 2004%s Internet Systems Consortium, Inc. (\"ISC\")\n"
" * Copyright (C) 1998-2003 Internet Software Consortium.\n"
" *\n"
" * Permission to use, copy, modify, and distribute this software for any\n"
" * purpose with or without fee is hereby granted, provided that the above\n"
" * copyright notice and this permission notice appear in all copies.\n"
" *\n"
" * THE SOFTWARE IS PROVIDED \"AS IS\" AND ISC DISCLAIMS ALL WARRANTIES WITH\n"
" * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n"
" * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,\n"
" * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n"
" * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n"
" * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n"
" * PERFORMANCE OF THIS SOFTWARE.\n"
" */\n"
"\n"
"/***************\n"
" ***************\n"
" ***************   THIS FILE IS AUTOMATICALLY GENERATED BY gen.c.\n"
" ***************   DO NOT EDIT!\n"
" ***************\n"
" ***************/\n"
"\n"
"/*! \\file */\n"
"\n";

#define TYPENAMES 256

struct cc {
	struct cc *next;
	int rdclass;
	char classname[11];
} *classes;

struct tt {
	struct tt *next;
	int rdclass;
	int type;
	char classname[11];
	char typename[11];
	char dirname[256];		/* XXX Should be max path length */
} *types;

struct ttnam {
	char typename[11];
	char macroname[11];
	char attr[256];
	unsigned int sorted;
	int type;
} typenames[TYPENAMES];

int maxtype = -1;

char *
upper(char *);
char *
funname(const char *, char *);
void
doswitch(const char *, const char *, const char *, const char *,
	 const char *, const char *);
void
dodecl(char *, char *, char *);
void
add(int, const char *, int, const char *, const char *);
void
sd(int, const char *, const char *, char);
void
insert_into_typenames(int, const char *, const char *);

/*%
 * If you use more than 10 of these in, say, a printf(), you'll have problems.
 */
char *
upper(char *s) {
	static int buf_to_use = 0;
	static char buf[10][256];
	char *b;
	int c;

	buf_to_use++;
	if (buf_to_use > 9)
		buf_to_use = 0;

	b = buf[buf_to_use];
	memset(b, 0, 256);

	while ((c = (*s++) & 0xff))
		*b++ = islower(c) ? toupper(c) : c;
	*b = '\0';
	return (buf[buf_to_use]);
}

char *
funname(const char *s, char *buf) {
	char *b = buf;
	char c;

	while ((c = *s++)) {
		*b++ = (c == '-') ? '_' : c;
	}
	*b = '\0';
	return (buf);
}

void
doswitch(const char *name, const char *function, const char *args,
	 const char *tsw, const char *csw, const char *res)
{
	struct tt *tt;
	int first = 1;
	int lasttype = 0;
	int subswitch = 0;
	char buf1[11], buf2[11];
	const char *result = " result =";

	if (res == NULL)
		result = "";

	for (tt = types; tt != NULL; tt = tt->next) {
		if (first) {
			fprintf(stdout, "\n#define %s \\\n", name);
			fprintf(stdout, "\tswitch (%s) { \\\n" /*}*/, tsw);
			first = 0;
		}
		if (tt->type != lasttype && subswitch) {
			if (res == NULL)
				fprintf(stdout, "\t\tdefault: break; \\\n");
			else
				fprintf(stdout,
					"\t\tdefault: %s; break; \\\n", res);
			fputs(/*{*/ "\t\t} \\\n", stdout);
			fputs("\t\tbreak; \\\n", stdout);
			subswitch = 0;
		}
		if (tt->rdclass && tt->type != lasttype) {
			fprintf(stdout, "\tcase %d: switch (%s) { \\\n" /*}*/,
				tt->type, csw);
			subswitch = 1;
		}
		if (tt->rdclass == 0)
			fprintf(stdout,
				"\tcase %d:%s %s_%s(%s); break;",
				tt->type, result, function,
				funname(tt->typename, buf1), args);
		else
			fprintf(stdout,
				"\t\tcase %d:%s %s_%s_%s(%s); break;",
				tt->rdclass, result, function,
				funname(tt->classname, buf1),
				funname(tt->typename, buf2), args);
		fputs(" \\\n", stdout);
		lasttype = tt->type;
	}
	if (subswitch) {
		if (res == NULL)
			fprintf(stdout, "\t\tdefault: break; \\\n");
		else
			fprintf(stdout, "\t\tdefault: %s; break; \\\n", res);
		fputs(/*{*/ "\t\t} \\\n", stdout);
		fputs("\t\tbreak; \\\n", stdout);
	}
	if (first) {
		if (res == NULL)
			fprintf(stdout, "\n#define %s\n", name);
		else
			fprintf(stdout, "\n#define %s %s;\n", name, res);
	} else {
		if (res == NULL)
			fprintf(stdout, "\tdefault: break; \\\n");
		else
			fprintf(stdout, "\tdefault: %s; break; \\\n", res);
		fputs(/*{*/ "\t}\n", stdout);
	}
}

void
dodecl(char *type, char *function, char *args) {
	struct tt *tt;
	char buf1[11], buf2[11];

	fputs("\n", stdout);
	for (tt = types; tt; tt = tt->next)
		if (tt->rdclass)
			fprintf(stdout,
				"static inline %s %s_%s_%s(%s);\n",
				type, function,
				funname(tt->classname, buf1),
				funname(tt->typename, buf2), args);
		else
			fprintf(stdout,
				"static inline %s %s_%s(%s);\n",
				type, function,
				funname(tt->typename, buf1), args);
}

static struct ttnam *
find_typename(int type) {
	int i;

	for (i = 0; i < TYPENAMES; i++) {
		if (typenames[i].typename[0] != 0 &&
		    typenames[i].type == type)
			return (&typenames[i]);
	}
	return (NULL);
}

void
insert_into_typenames(int type, const char *typename, const char *attr) {
	struct ttnam *ttn = NULL;
	int c, i;
	char tmp[256];

	for (i = 0; i < TYPENAMES; i++) {
		if (typenames[i].typename[0] != 0 &&
		    typenames[i].type == type &&
		    strcmp(typename, typenames[i].typename) != 0) {
			fprintf(stderr,
				"Error:  type %d has two names: %s, %s\n",
				type, typenames[i].typename, typename);
			exit(1);
		}
		if (typenames[i].typename[0] == 0 && ttn == NULL)
			ttn = &typenames[i];
	}
	if (ttn == NULL) {
		fprintf(stderr, "Error: typenames array too small\n");
		exit(1);
	}
	
	if (strlen(typename) > sizeof(ttn->typename) - 1) {
		fprintf(stderr, "Error:  type name %s is too long\n",
			typename);
		exit(1);
	}
	strlcpy(ttn->typename, typename, sizeof(ttn->typename));
	ttn->type = type;

	strlcpy(ttn->macroname, ttn->typename, sizeof(ttn->macroname));
	c = strlen(ttn->macroname);
	while (c > 0) {
		if (ttn->macroname[c - 1] == '-')
			ttn->macroname[c - 1] = '_';
		c--;
	}

	if (attr == NULL) {
		snprintf(tmp, sizeof(tmp), "RRTYPE_%s_ATTRIBUTES", upper(ttn->macroname));
		attr = tmp;
	}

	if (ttn->attr[0] != 0 && strcmp(attr, ttn->attr) != 0) {
		fprintf(stderr, "Error:  type %d has different attributes: "
			"%s, %s\n", type, ttn->attr, attr);
		exit(1);
	}

	if (strlen(attr) > sizeof(ttn->attr) - 1) {
		fprintf(stderr, "Error:  attr (%s) [name %s] is too long\n",
			attr, typename);
		exit(1);
	}
	strlcpy(ttn->attr, attr, sizeof(ttn->attr));
	ttn->sorted = 0;
	if (maxtype < type)
		maxtype = type;
}

void
add(int rdclass, const char *classname, int type, const char *typename,
    const char *dirname)
{
	struct tt *newtt = (struct tt *)malloc(sizeof(*newtt));
	struct tt *tt, *oldtt;
	struct cc *newcc;
	struct cc *cc, *oldcc;

	insert_into_typenames(type, typename, NULL);

	if (newtt == NULL) {
		fprintf(stderr, "malloc() failed\n");
		exit(1);
	}

	newtt->next = NULL;
	newtt->rdclass = rdclass;
	newtt->type = type;
	strlcpy(newtt->classname, classname, sizeof(newtt->classname));
	strlcpy(newtt->typename, typename, sizeof(newtt->typename));
	strlcpy(newtt->dirname, dirname, sizeof(newtt->dirname));

	tt = types;
	oldtt = NULL;

	while ((tt != NULL) && (tt->type < type)) {
		oldtt = tt;
		tt = tt->next;
	}

	while ((tt != NULL) && (tt->type == type) && (tt->rdclass < rdclass)) {
		if (strcmp(tt->typename, typename) != 0)
			exit(1);
		oldtt = tt;
		tt = tt->next;
	}

	if ((tt != NULL) && (tt->type == type) && (tt->rdclass == rdclass))
		exit(1);

	newtt->next = tt;
	if (oldtt != NULL)
		oldtt->next = newtt;
	else
		types = newtt;

	/*
	 * Do a class switch for this type.
	 */
	if (rdclass == 0)
		return;

	newcc = (struct cc *)malloc(sizeof(*newcc));
	newcc->rdclass = rdclass;
	strlcpy(newcc->classname, classname, sizeof(newcc->classname));
	cc = classes;
	oldcc = NULL;

	while ((cc != NULL) && (cc->rdclass < rdclass)) {
		oldcc = cc;
		cc = cc->next;
	}

	if ((cc != NULL) && cc->rdclass == rdclass) {
		free((char *)newcc);
		return;
	}

	newcc->next = cc;
	if (oldcc != NULL)
		oldcc->next = newcc;
	else
		classes = newcc;
}

void
sd(int rdclass, const char *classname, const char *dirname, char filetype) {
	char buf[sizeof("0123456789_65535.h")];
	char fmt[sizeof("%10[-0-9a-z]_%d.h")];
	int type;
	char typename[11];
	isc_dir_t dir;

	if (!start_directory(dirname, &dir))
		return;

	snprintf(fmt, sizeof(fmt), "%s%c", "%10[-0-9a-z]_%d.", filetype);
	while (next_file(&dir)) {
		if (sscanf(dir.filename, fmt, typename, &type) != 2)
			continue;
		if ((type > 65535) || (type < 0))
			continue;

		snprintf(buf, sizeof(buf), "%s_%d.%c", typename, type, filetype);
		if (strcmp(buf, dir.filename) != 0)
			continue;
		add(rdclass, classname, type, typename, dirname);
	}

	end_directory(&dir);
}

static unsigned int
HASH(char *string) {
	unsigned int n;
	unsigned char a, b;

	n = strlen(string);
	if (n == 0) {
		fprintf(stderr, "n == 0?\n");
		exit(1);
	}
	a = tolower((unsigned char)string[0]);
	b = tolower((unsigned char)string[n - 1]);

	return ((a + n) * b) % 256;
}

int
main(int argc, char **argv) {
	char buf[256];			/* XXX Should be max path length */
	char srcdir[256];		/* XXX Should be max path length */
	int rdclass;
	char classname[11];
	struct tt *tt;
	struct cc *cc;
	struct ttnam *ttn, *ttn2;
	unsigned int hash;
	struct tm *tm;
	time_t now;
	char year[11];
	int lasttype;
	int code = 1;
	int class_enum = 0;
	int type_enum = 0;
	int structs = 0;
	int depend = 0;
	int c, i, j;
	char buf1[11];
	char filetype = 'c';
	FILE *fd;
	char *prefix = NULL;
	char *suffix = NULL;
	char *file = NULL;
	isc_dir_t dir;

	for (i = 0; i < TYPENAMES; i++)
		memset(&typenames[i], 0, sizeof(typenames[i]));

	strlcpy(srcdir, "", sizeof(srcdir));
	while ((c = isc_commandline_parse(argc, argv, "cdits:F:P:S:")) != -1)
		switch (c) {
		case 'c':
			code = 0;
			depend = 0;
			type_enum = 0;
			class_enum = 1;
			filetype = 'c';
			structs = 0;
			break;
		case 'd':
			code = 0;
			depend = 1;
			class_enum = 0;
			type_enum = 0;
			structs = 0;
			filetype = 'h';
			break;
		case 't':
			code = 0;
			depend = 0;
			class_enum = 0;
			type_enum = 1;
			filetype = 'c';
			structs = 0;
			break;
		case 'i':
			code = 0;
			depend = 0;
			class_enum = 0;
			type_enum = 0;
			structs = 1;
			filetype = 'h';
			break;
		case 's':
			snprintf(srcdir, sizeof(srcdir), "%s/", isc_commandline_argument);
			break;
		case 'F':
			file = isc_commandline_argument;
			break;
		case 'P':
			prefix = isc_commandline_argument;
			break;
		case 'S':
			suffix = isc_commandline_argument;
			break;
		case '?':
			exit(1);
		}

	snprintf(buf, sizeof(buf), "%srdata", srcdir);

	if (!start_directory(buf, &dir))
		exit(1);

	while (next_file(&dir)) {
		if (sscanf(dir.filename, "%10[0-9a-z]_%d",
			   classname, &rdclass) != 2)
			continue;
		if ((rdclass > 65535) || (rdclass < 0))
			continue;

		snprintf(buf, sizeof(buf), "%srdata/%s_%d", srcdir, classname, rdclass);
		if (strcmp(buf + 6 + strlen(srcdir), dir.filename) != 0)
			continue;
		sd(rdclass, classname, buf, filetype);
	}
	end_directory(&dir);
	snprintf(buf, sizeof(buf), "%srdata/generic", srcdir);
	sd(0, "", buf, filetype);

	if (time(&now) != -1) {
		if ((tm = localtime(&now)) != NULL && tm->tm_year > 104)
			snprintf(year, sizeof(year), "-%d", tm->tm_year + 1900);
		else
			year[0] = 0;
	} else
		year[0] = 0;

	if (!depend) fprintf(stdout, copyright, year);

	if (code) {
		fputs("#ifndef DNS_CODE_H\n", stdout);
		fputs("#define DNS_CODE_H 1\n\n", stdout);

		fputs("#include <isc/boolean.h>\n", stdout);
		fputs("#include <isc/result.h>\n\n", stdout);
		fputs("#include <dns/name.h>\n\n", stdout);

		for (tt = types; tt != NULL; tt = tt->next)
			fprintf(stdout, "#include \"%s/%s_%d.c\"\n",
				tt->dirname, tt->typename, tt->type);

		fputs("\n\n", stdout);

		doswitch("FROMTEXTSWITCH", "fromtext", FROMTEXTARGS,
			 FROMTEXTTYPE, FROMTEXTCLASS, FROMTEXTDEF);
		doswitch("TOTEXTSWITCH", "totext", TOTEXTARGS,
			 TOTEXTTYPE, TOTEXTCLASS, TOTEXTDEF);
		doswitch("FROMWIRESWITCH", "fromwire", FROMWIREARGS,
			 FROMWIRETYPE, FROMWIRECLASS, FROMWIREDEF);
		doswitch("TOWIRESWITCH", "towire", TOWIREARGS,
			 TOWIRETYPE, TOWIRECLASS, TOWIREDEF);
		doswitch("COMPARESWITCH", "compare", COMPAREARGS,
			  COMPARETYPE, COMPARECLASS, COMPAREDEF);
		doswitch("FROMSTRUCTSWITCH", "fromstruct", FROMSTRUCTARGS,
			  FROMSTRUCTTYPE, FROMSTRUCTCLASS, FROMSTRUCTDEF);
		doswitch("TOSTRUCTSWITCH", "tostruct", TOSTRUCTARGS,
			  TOSTRUCTTYPE, TOSTRUCTCLASS, TOSTRUCTDEF);
		doswitch("FREESTRUCTSWITCH", "freestruct", FREESTRUCTARGS,
			  FREESTRUCTTYPE, FREESTRUCTCLASS, FREESTRUCTDEF);
		doswitch("ADDITIONALDATASWITCH", "additionaldata",
			 ADDITIONALDATAARGS, ADDITIONALDATATYPE,
			 ADDITIONALDATACLASS, ADDITIONALDATADEF);
		doswitch("DIGESTSWITCH", "digest",
			 DIGESTARGS, DIGESTTYPE,
			 DIGESTCLASS, DIGESTDEF);
		doswitch("CHECKOWNERSWITCH", "checkowner",
			CHECKOWNERARGS, CHECKOWNERTYPE,
			CHECKOWNERCLASS, CHECKOWNERDEF);
		doswitch("CHECKNAMESSWITCH", "checknames",
			CHECKNAMESARGS, CHECKNAMESTYPE,
			CHECKNAMESCLASS, CHECKNAMESDEF);

		/*
		 * From here down, we are processing the rdata names and
		 * attributes.
		 */

#define PRINT_COMMA(x) (x == maxtype ? "" : ",")

#define METANOTQUESTION  "DNS_RDATATYPEATTR_META | " \
			 "DNS_RDATATYPEATTR_NOTQUESTION"
#define METAQUESTIONONLY "DNS_RDATATYPEATTR_META | " \
			 "DNS_RDATATYPEATTR_QUESTIONONLY"
#define RESERVED "DNS_RDATATYPEATTR_RESERVED"

		/*
		 * Add in reserved/special types.  This will let us
		 * sort them without special cases.
		 */
		insert_into_typenames(0, "reserved0", RESERVED);
		insert_into_typenames(31, "eid", RESERVED);
		insert_into_typenames(32, "nimloc", RESERVED);
		insert_into_typenames(34, "atma", RESERVED);
		insert_into_typenames(100, "uinfo", RESERVED);
		insert_into_typenames(101, "uid", RESERVED);
		insert_into_typenames(102, "gid", RESERVED);
		insert_into_typenames(251, "ixfr", METAQUESTIONONLY);
		insert_into_typenames(252, "axfr", METAQUESTIONONLY);
		insert_into_typenames(253, "mailb", METAQUESTIONONLY);
		insert_into_typenames(254, "maila", METAQUESTIONONLY);
		insert_into_typenames(255, "any", METAQUESTIONONLY);

		/*
		 * Spit out a quick and dirty hash function.  Here,
		 * we walk through the list of type names, and calculate
		 * a hash.  This isn't perfect, but it will generate "pretty
		 * good" estimates.  Lowercase the characters before
		 * computing in all cases.
		 *
		 * Here, walk the list from top to bottom, calculating
		 * the hash (mod 256) for each name.
		 */
		fprintf(stdout, "#define RDATATYPE_COMPARE(_s, _d, _tn, _n, _tp) \\\n");
		fprintf(stdout, "\tdo { \\\n");
		fprintf(stdout, "\t\tif (sizeof(_s) - 1 == _n && \\\n"
				"\t\t    strncasecmp(_s,(_tn),"
				"(sizeof(_s) - 1)) == 0) { \\\n");
		fprintf(stdout, "\t\t\tif ((dns_rdatatype_attributes(_d) & "
		       		  "DNS_RDATATYPEATTR_RESERVED) != 0) \\\n");
		fprintf(stdout, "\t\t\t\treturn (ISC_R_NOTIMPLEMENTED); \\\n");
		fprintf(stdout, "\t\t\t*(_tp) = _d; \\\n");
		fprintf(stdout, "\t\t\treturn (ISC_R_SUCCESS); \\\n");
		fprintf(stdout, "\t\t} \\\n");
		fprintf(stdout, "\t} while (0)\n\n");

		fprintf(stdout, "#define RDATATYPE_FROMTEXT_SW(_hash,"
				"_typename,_length,_typep) \\\n");
		fprintf(stdout, "\tswitch (_hash) { \\\n");
		for (i = 0; i <= maxtype; i++) {
			ttn = find_typename(i);
			if (ttn == NULL)
				continue;

			/*
			 * Skip entries we already processed.
			 */
			if (ttn->sorted != 0)
				continue;

			hash = HASH(ttn->typename);
			fprintf(stdout, "\t\tcase %u: \\\n", hash);

			/*
			 * Find all other entries that happen to match
			 * this hash.
			 */
			for (j = 0; j <= maxtype; j++) {
				ttn2 = find_typename(j);
				if (ttn2 == NULL)
					continue;
				if (hash == HASH(ttn2->typename)) {
					fprintf(stdout, "\t\t\tRDATATYPE_COMPARE"
					       "(\"%s\", %u, "
					       "_typename, _length, _typep); \\\n",
					       ttn2->typename, ttn2->type);
					ttn2->sorted = 1;
				}
			}
			fprintf(stdout, "\t\t\tbreak; \\\n");
		}
		fprintf(stdout, "\t}\n");

		fprintf(stdout, "#define RDATATYPE_ATTRIBUTE_SW \\\n");
		fprintf(stdout, "\tswitch (type) { \\\n");
		for (i = 0; i <= maxtype; i++) {
			ttn = find_typename(i);
			if (ttn == NULL)
				continue;
			fprintf(stdout, "\tcase %u: return (%s); \\\n",
			        i, upper(ttn->attr));
		}
		fprintf(stdout, "\t}\n");

		fprintf(stdout, "#define RDATATYPE_TOTEXT_SW \\\n");
		fprintf(stdout, "\tswitch (type) { \\\n");
		for (i = 0; i <= maxtype; i++) {
			ttn = find_typename(i);
			if (ttn == NULL)
				continue;
			fprintf(stdout, "\tcase %u: return "
				"(str_totext(\"%s\", target)); \\\n",
			        i, upper(ttn->typename));
		}
		fprintf(stdout, "\t}\n");

		fputs("#endif /* DNS_CODE_H */\n", stdout);
	} else if (type_enum) {
		char *s;

		fprintf(stdout, "#ifndef DNS_ENUMTYPE_H\n");
		fprintf(stdout, "#define DNS_ENUMTYPE_H 1\n\n");

		fprintf(stdout, "enum {\n");
		fprintf(stdout, "\tdns_rdatatype_none = 0,\n");

		lasttype = 0;
		for (tt = types; tt != NULL; tt = tt->next)
			if (tt->type != lasttype)
				fprintf(stdout,
					"\tdns_rdatatype_%s = %d,\n",
					funname(tt->typename, buf1),
					lasttype = tt->type);

		fprintf(stdout, "\tdns_rdatatype_ixfr = 251,\n");
		fprintf(stdout, "\tdns_rdatatype_axfr = 252,\n");
		fprintf(stdout, "\tdns_rdatatype_mailb = 253,\n");
		fprintf(stdout, "\tdns_rdatatype_maila = 254,\n");
		fprintf(stdout, "\tdns_rdatatype_any = 255\n");

		fprintf(stdout, "};\n\n");

		fprintf(stdout, "#define dns_rdatatype_none\t"
			"((dns_rdatatype_t)dns_rdatatype_none)\n");

		for (tt = types; tt != NULL; tt = tt->next)
			if (tt->type != lasttype) {
				s = funname(tt->typename, buf1);
				fprintf(stdout,
					"#define dns_rdatatype_%s\t%s"
					"((dns_rdatatype_t)dns_rdatatype_%s)"
					"\n",
					s, strlen(s) < 2U ? "\t" : "", s);
				lasttype = tt->type;
			}

		fprintf(stdout, "#define dns_rdatatype_ixfr\t"
			"((dns_rdatatype_t)dns_rdatatype_ixfr)\n");
		fprintf(stdout, "#define dns_rdatatype_axfr\t"
			"((dns_rdatatype_t)dns_rdatatype_axfr)\n");
		fprintf(stdout, "#define dns_rdatatype_mailb\t"
			"((dns_rdatatype_t)dns_rdatatype_mailb)\n");
		fprintf(stdout, "#define dns_rdatatype_maila\t"
			"((dns_rdatatype_t)dns_rdatatype_maila)\n");
		fprintf(stdout, "#define dns_rdatatype_any\t"
			"((dns_rdatatype_t)dns_rdatatype_any)\n");

		fprintf(stdout, "\n#endif /* DNS_ENUMTYPE_H */\n");

	} else if (class_enum) {
		char *s;
		int classnum;

		fprintf(stdout, "#ifndef DNS_ENUMCLASS_H\n");
		fprintf(stdout, "#define DNS_ENUMCLASS_H 1\n\n");

		fprintf(stdout, "enum {\n");

		fprintf(stdout, "\tdns_rdataclass_reserved0 = 0,\n");
		fprintf(stdout, "#define dns_rdataclass_reserved0 \\\n\t\t\t\t"
			"((dns_rdataclass_t)dns_rdataclass_reserved0)\n");

#define PRINTCLASS(name, num) \
	do { \
		s = funname(name, buf1); \
		classnum = num; \
		fprintf(stdout, "\tdns_rdataclass_%s = %d%s\n", s, classnum, \
		       classnum != 255 ? "," : ""); \
		fprintf(stdout, "#define dns_rdataclass_%s\t" \
		       "((dns_rdataclass_t)dns_rdataclass_%s)\n", s, s); \
	} while (0)

		for (cc = classes; cc != NULL; cc = cc->next) {
			if (cc->rdclass == 3)
				PRINTCLASS("chaos", 3);
			else if (cc->rdclass == 255)
				PRINTCLASS("none", 254);
			PRINTCLASS(cc->classname, cc->rdclass);
		}

#undef PRINTCLASS

		fprintf(stdout, "};\n\n");
		fprintf(stdout, "#endif /* DNS_ENUMCLASS_H */\n");
	} else if (structs) {
		if (prefix != NULL) {
			if ((fd = fopen(prefix,"r")) != NULL) {
				while (fgets(buf, sizeof(buf), fd) != NULL)
					fputs(buf, stdout);
				fclose(fd);
			}
		}
		for (tt = types; tt != NULL; tt = tt->next) {
			snprintf(buf, sizeof(buf), "%s/%s_%d.h",
				tt->dirname, tt->typename, tt->type);
			if ((fd = fopen(buf,"r")) != NULL) {
				while (fgets(buf, sizeof(buf), fd) != NULL)
					fputs(buf, stdout);
				fclose(fd);
			}
		}
		if (suffix != NULL) {
			if ((fd = fopen(suffix,"r")) != NULL) {
				while (fgets(buf, sizeof(buf), fd) != NULL)
					fputs(buf, stdout);
				fclose(fd);
			}
		}
	} else if (depend) {
		for (tt = types; tt != NULL; tt = tt->next)
			fprintf(stdout, "%s:\t%s/%s_%d.h\n", file,
				tt->dirname, tt->typename, tt->type);
	}

	if (ferror(stdout) != 0)
		exit(1);

	return (0);
}
@


1.5
log
@resolve conflicts and regen configure script
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")
d18 3
a20 1
/* $ISC: gen.c,v 1.65.2.5.2.9 2006/10/02 06:31:26 marka Exp $ */
d128 2
d175 1
a175 1
/*
d839 1
a839 2
			if (cc->rdclass == 4) {
				PRINTCLASS("ch", 3);
d841 1
a841 2

			} else if (cc->rdclass == 255) {
a842 1
			}
@


1.4
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: gen.c,v 1.65.2.5.2.6 2004/03/15 01:02:54 marka Exp $ */
d20 6
a25 1
#include <config.h>
@


1.3
log
@update to BIND v9.2.3. ok todd@@
@
text
@d2 1
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: gen.c,v 1.65.2.5 2003/07/23 06:57:48 marka Exp $ */
d37 1
a37 1
#define FROMTEXTARGS "rdclass, type, lexer, origin, downcase, target, callbacks"
d47 1
a47 1
#define FROMWIREARGS "rdclass, type, source, dctx, downcase, target"
d87 10
d99 2
a100 1
" * Copyright (C) 1998%s Internet Software Consortium.\n"
d106 7
a112 8
" * THE SOFTWARE IS PROVIDED \"AS IS\" AND INTERNET SOFTWARE CONSORTIUM\n"
" * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL\n"
" * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL\n"
" * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,\n"
" * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING\n"
" * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n"
" * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n"
" * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
d215 1
a215 1
	for (tt = types; tt != NULL ; tt = tt->next) {
d278 1
a278 1
	for (tt = types; tt ; tt = tt->next)
d326 1
a326 1

d369 1
a369 1
	struct tt *newtt = (struct tt *)malloc(sizeof *newtt);
d418 1
a418 1
	newcc = (struct cc *)malloc(sizeof *newcc);
d443 2
a444 2
	char buf[sizeof "0123456789_65535.h"];
	char fmt[sizeof "%10[-0-9a-z]_%d.h"];
d512 1
a512 1
	for (i = 0; i < TYPENAMES ; i++)
d588 1
a588 1
		if ((tm = localtime(&now)) != NULL && tm->tm_year > 98)
d605 1
a605 1
		for (tt = types; tt != NULL ; tt = tt->next)
d633 6
a669 25
		fprintf(stdout, "\ntypedef struct {\n");
		fprintf(stdout, "\tconst char *name;\n");
		fprintf(stdout, "\tunsigned int flags;\n");
		fprintf(stdout, "} typeattr_t;\n");
		fprintf(stdout, "static typeattr_t typeattr[] = {\n");
		for (i = 0; i <= maxtype ; i++) {
			ttn = find_typename(i);
			if (ttn == NULL) {
				const char *attrs;
				if (i >= 128 && i < 255)
					attrs = "DNS_RDATATYPEATTR_UNKNOWN | "
						"DNS_RDATATYPEATTR_META";
				else
					attrs = "DNS_RDATATYPEATTR_UNKNOWN";
				fprintf(stdout, "\t{ \"TYPE%d\", %s}%s\n",
					i, attrs, PRINT_COMMA(i));
			} else {
				fprintf(stdout, "\t{ \"%s\", %s }%s\n",
				       upper(ttn->typename),
				       upper(ttn->attr),
				       PRINT_COMMA(i));
			}
		}
		fprintf(stdout, "};\n");

d685 1
a685 1
		fprintf(stdout, "\t\t\tif ((typeattr[_d].flags & "
d696 1
a696 1
		for (i = 0; i <= maxtype ; i++) {
d714 1
a714 1
			for (j = 0; j <= maxtype ; j++) {
d730 23
d764 1
a764 1
		for (tt = types; tt != NULL ; tt = tt->next)
d782 1
a782 1
		for (tt = types; tt != NULL ; tt = tt->next)
d847 1
a847 1
				while (fgets(buf, sizeof buf, fd) != NULL)
d852 1
a852 1
		for (tt = types; tt != NULL ; tt = tt->next) {
d856 1
a856 1
				while (fgets(buf, sizeof buf, fd) != NULL)
d863 1
a863 1
				while (fgets(buf, sizeof buf, fd) != NULL)
d869 1
a869 1
		for (tt = types; tt != NULL ; tt = tt->next)
@


1.2
log
@string fixes.  ok krw pvalchev
@
text
@d2 1
a2 1
 * Copyright (C) 1998-2002  Internet Software Consortium.
d18 1
a18 1
/* $ISC: gen.c,v 1.65.2.2 2002/03/26 00:54:54 marka Exp $ */
d113 2
d135 4
a138 1
} typenames[256];
d282 12
d296 2
a297 2
	struct ttnam *ttn;
	int c;
d300 7
a306 5
	ttn = &typenames[type];
	if (ttn->typename[0] == 0) {
		if (strlen(typename) > sizeof(ttn->typename) - 1) {
			fprintf(stderr, "Error:  type name %s is too long\n",
				typename);
d309 11
a319 4
		strlcpy(ttn->typename, typename, sizeof(ttn->typename));
	} else if (strcmp(typename, ttn->typename) != 0) {
		fprintf(stderr, "Error:  type %d has two names: %s, %s\n",
			type, ttn->typename, typename);
d322 2
d351 2
d502 1
a502 1
	for (i = 0 ; i <= 255 ; i++)
d629 1
a629 1
#define PRINT_COMMA(x) (x == 255 ? "" : ",")
d659 3
a661 3
		for (i = 0 ; i <= 255 ; i++) {
			ttn = &typenames[i];
			if (ttn->typename[0] == 0) {
d669 1
a669 1
				       i, attrs, PRINT_COMMA(i));
a679 10
		 * Run through the list of types and pre-mark the unused
		 * ones as "sorted" so we simply ignore them below.
		 */
		for (i = 0 ; i <= 255 ; i++) {
			ttn = &typenames[i];
			if (ttn->typename[0] == 0)
				ttn->sorted = 1;
		}

		/*
d705 4
a708 2
		for (i = 0 ; i <= 255 ; i++) {
			ttn = &typenames[i];
d723 3
a725 3
			for (j = 0 ; j <= 255 ; j++) {
				ttn2 = &typenames[j];
				if (ttn2->sorted != 0)
d731 1
a731 1
					       ttn2->typename, j);
d775 1
a775 1
					s, strlen(s) < 2 ? "\t" : "", s);
@


1.1
log
@Initial revision
@
text
@d290 1
a290 1
		strcpy(ttn->typename, typename);
d297 1
a297 1
	strcpy(ttn->macroname, ttn->typename);
d306 1
a306 1
		sprintf(tmp, "RRTYPE_%s_ATTRIBUTES", upper(ttn->macroname));
d321 1
a321 1
	strcpy(ttn->attr, attr);
d344 3
a346 3
	strcpy(newtt->classname, classname);
	strcpy(newtt->typename, typename);
	strcpy(newtt->dirname, dirname);
d380 1
a380 1
	strcpy(newcc->classname, classname);
d412 1
a412 1
	sprintf(fmt,"%s%c", "%10[-0-9a-z]_%d.", filetype);
d419 1
a419 1
		sprintf(buf, "%s_%d.%c", typename, type, filetype);
d475 1
a475 1
	strcpy(srcdir, "");
d511 1
a511 1
			sprintf(srcdir, "%s/", isc_commandline_argument);
d526 1
a526 1
	sprintf(buf, "%srdata", srcdir);
d538 1
a538 1
		sprintf(buf, "%srdata/%s_%d", srcdir, classname, rdclass);
d544 1
a544 1
	sprintf(buf, "%srdata/generic", srcdir);
d549 1
a549 1
			sprintf(year, "-%d", tm->tm_year + 1900);
d817 1
a817 1
			sprintf(buf, "%s/%s_%d.h",
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1998-2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: gen.c,v 1.65.2.5.2.6 2004/03/15 01:02:54 marka Exp $ */
d37 1
a37 1
#define FROMTEXTARGS "rdclass, type, lexer, origin, options, target, callbacks"
d47 1
a47 1
#define FROMWIREARGS "rdclass, type, source, dctx, options, target"
a86 10
#define CHECKOWNERARGS "name, rdclass, type, wildcard"
#define CHECKOWNERCLASS "rdclass"
#define CHECKOWNERTYPE "type"
#define CHECKOWNERDEF "result = ISC_TRUE"

#define CHECKNAMESARGS "rdata, owner, bad"
#define CHECKNAMESCLASS "rdata->rdclass"
#define CHECKNAMESTYPE "rdata->type"
#define CHECKNAMESDEF "result = ISC_TRUE"

d89 1
a89 2
" * Copyright (C) 2004%s Internet Systems Consortium, Inc. (\"ISC\")\n"
" * Copyright (C) 1998-2003 Internet Software Consortium.\n"
d95 8
a102 7
" * THE SOFTWARE IS PROVIDED \"AS IS\" AND ISC DISCLAIMS ALL WARRANTIES WITH\n"
" * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n"
" * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,\n"
" * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n"
" * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n"
" * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n"
" * PERFORMANCE OF THIS SOFTWARE.\n"
a112 2
#define TYPENAMES 256

d133 1
a133 4
	int type;
} typenames[TYPENAMES];

int maxtype = -1;
d200 1
a200 1
	for (tt = types; tt != NULL; tt = tt->next) {
d263 1
a263 1
	for (tt = types; tt; tt = tt->next)
a276 12
static struct ttnam *
find_typename(int type) {
	int i;

	for (i = 0; i < TYPENAMES; i++) {
		if (typenames[i].typename[0] != 0 &&
		    typenames[i].type == type)
			return (&typenames[i]);
	}
	return (NULL);
}

d279 2
a280 2
	struct ttnam *ttn = NULL;
	int c, i;
d283 5
a287 7
	for (i = 0; i < TYPENAMES; i++) {
		if (typenames[i].typename[0] != 0 &&
		    typenames[i].type == type &&
		    strcmp(typename, typenames[i].typename) != 0) {
			fprintf(stderr,
				"Error:  type %d has two names: %s, %s\n",
				type, typenames[i].typename, typename);
d290 4
a293 11
		if (typenames[i].typename[0] == 0 && ttn == NULL)
			ttn = &typenames[i];
	}
	if (ttn == NULL) {
		fprintf(stderr, "Error: typenames array too small\n");
		exit(1);
	}
	
	if (strlen(typename) > sizeof(ttn->typename) - 1) {
		fprintf(stderr, "Error:  type name %s is too long\n",
			typename);
a295 2
	strcpy(ttn->typename, typename);
	ttn->type = type;
a322 2
	if (maxtype < type)
		maxtype = type;
d329 1
a329 1
	struct tt *newtt = (struct tt *)malloc(sizeof(*newtt));
d378 1
a378 1
	newcc = (struct cc *)malloc(sizeof(*newcc));
d403 2
a404 2
	char buf[sizeof("0123456789_65535.h")];
	char fmt[sizeof("%10[-0-9a-z]_%d.h")];
d472 1
a472 1
	for (i = 0; i < TYPENAMES; i++)
d548 1
a548 1
		if ((tm = localtime(&now)) != NULL && tm->tm_year > 104) 
d565 1
a565 1
		for (tt = types; tt != NULL; tt = tt->next)
a592 6
		doswitch("CHECKOWNERSWITCH", "checkowner",
			CHECKOWNERARGS, CHECKOWNERTYPE,
			CHECKOWNERCLASS, CHECKOWNERDEF);
		doswitch("CHECKNAMESSWITCH", "checknames",
			CHECKNAMESARGS, CHECKNAMESTYPE,
			CHECKNAMESCLASS, CHECKNAMESDEF);
d599 1
a599 1
#define PRINT_COMMA(x) (x == maxtype ? "" : ",")
d624 35
d674 1
a674 1
		fprintf(stdout, "\t\t\tif ((dns_rdatatype_attributes(_d) & "
d685 2
a686 4
		for (i = 0; i <= maxtype; i++) {
			ttn = find_typename(i);
			if (ttn == NULL)
				continue;
d701 3
a703 3
			for (j = 0; j <= maxtype; j++) {
				ttn2 = find_typename(j);
				if (ttn2 == NULL)
d709 1
a709 1
					       ttn2->typename, ttn2->type);
a716 23
		fprintf(stdout, "#define RDATATYPE_ATTRIBUTE_SW \\\n");
		fprintf(stdout, "\tswitch (type) { \\\n");
		for (i = 0; i <= maxtype; i++) {
			ttn = find_typename(i);
			if (ttn == NULL)
				continue;
			fprintf(stdout, "\tcase %u: return (%s); \\\n",
			        i, upper(ttn->attr));
		}
		fprintf(stdout, "\t}\n");

		fprintf(stdout, "#define RDATATYPE_TOTEXT_SW \\\n");
		fprintf(stdout, "\tswitch (type) { \\\n");
		for (i = 0; i <= maxtype; i++) {
			ttn = find_typename(i);
			if (ttn == NULL)
				continue;
			fprintf(stdout, "\tcase %u: return "
				"(str_totext(\"%s\", target)); \\\n",
			        i, upper(ttn->typename));
		}
		fprintf(stdout, "\t}\n");

d728 1
a728 1
		for (tt = types; tt != NULL; tt = tt->next)
d746 1
a746 1
		for (tt = types; tt != NULL; tt = tt->next)
d753 1
a753 1
					s, strlen(s) < 2U ? "\t" : "", s);
d811 1
a811 1
				while (fgets(buf, sizeof(buf), fd) != NULL)
d816 1
a816 1
		for (tt = types; tt != NULL; tt = tt->next) {
d820 1
a820 1
				while (fgets(buf, sizeof(buf), fd) != NULL)
d827 1
a827 1
				while (fgets(buf, sizeof(buf), fd) != NULL)
d833 1
a833 1
		for (tt = types; tt != NULL; tt = tt->next)
@


1.1.1.3
log
@ISC BIND release 9.3.3
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: gen.c,v 1.65.2.5.2.9 2006/10/02 06:31:26 marka Exp $ */
d20 1
a20 6
#ifdef WIN32
/*
 * Silence compiler warnings about using strcpy and friends.
 */
#define _CRT_SECURE_NO_DEPRECATE 1
#endif
@


1.1.1.4
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 3
/* $ISC: gen.c,v 1.73.18.6 2006/10/02 06:36:43 marka Exp $ */

/*! \file */
a125 2
"\n"
"/*! \\file */\n"
d171 1
a171 1
/*%
d835 2
a836 1
			if (cc->rdclass == 3)
d838 2
a839 1
			else if (cc->rdclass == 255)
d841 1
@


