head	1.9;
access;
symbols
	OPENBSD_5_6:1.8.0.28
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.26
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.22
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.20
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.18
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.16
	OPENBSD_5_0:1.8.0.14
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.12
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.10
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.6
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.8
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.4
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	BIND_9_4_2_P1:1.1.1.5
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	BIND_9_4_2:1.1.1.5
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	BIND_9_3_4:1.1.1.4
	BIND_9_3_3:1.1.1.4
	OPENBSD_4_0:1.4.0.6
	OPENBSD_4_0_BASE:1.4
	BIND_9_3_2:1.1.1.3
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	BIND_9_3_1:1.1.1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.2.0.8
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.6
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.4
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.08.25.07.08.32;	author brad;	state dead;
branches;
next	1.8;
commitid	zKogyOACFMOV70QE;

1.8
date	2008.08.04.16.34.20;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2007.12.09.13.39.42;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.10.19.07.58;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.01.21.30.46;	author aanriot;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.22.16.52.38;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.28.17.14.03;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.26.12.36.14;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.06.08;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.06.08;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.32.57;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.03.22.16.36.21;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2007.01.10.18.18.23;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2007.12.09.12.33.11;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Start removing unused documentation and the server and related binaries source
code.
@
text
@/*
 * Copyright (C) 2004-2008  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 2001-2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: config.c,v 1.47.18.32.10.3 2008/07/23 23:48:17 tbox Exp $ */

/*! \file */

#include <config.h>

#include <stdlib.h>

#include <isc/buffer.h>
#include <isc/log.h>
#include <isc/mem.h>
#include <isc/parseint.h>
#include <isc/region.h>
#include <isc/result.h>
#include <isc/sockaddr.h>
#include <isc/string.h>
#include <isc/util.h>

#include <isccfg/namedconf.h>

#include <dns/fixedname.h>
#include <dns/name.h>
#include <dns/rdataclass.h>
#include <dns/rdatatype.h>
#include <dns/tsig.h>
#include <dns/zone.h>

#include <named/config.h>
#include <named/globals.h>

/*% default configuration */
static char defaultconf[] = "\
options {\n\
#	blackhole {none;};\n"
#ifndef WIN32
"	coresize default;\n\
	datasize default;\n\
	files unlimited;\n\
	stacksize default;\n"
#endif
"	deallocate-on-exit true;\n\
#	directory <none>\n\
	dump-file \"tmp/named_dump.db\";\n\
	fake-iquery no;\n\
	has-old-clients false;\n\
	heartbeat-interval 60;\n\
	host-statistics no;\n\
	interface-interval 60;\n\
	listen-on {any;};\n\
	listen-on-v6 {any;};\n\
	match-mapped-addresses no;\n\
	memstatistics-file \"tmp/named.memstats\";\n\
	multiple-cnames no;\n\
#	named-xfer <obsolete>;\n\
#	pid-file \"" NS_LOCALSTATEDIR "/named.pid\"; /* or /lwresd.pid */\n\
	port 53;\n\
	recursing-file \"tmp/named.recursing\";\n\
"
#ifdef PATH_RANDOMDEV
"\
	random-device \"" PATH_RANDOMDEV "\";\n\
"
#endif
"\
	recursive-clients 1000;\n\
	rrset-order {type NS order random; order cyclic; };\n\
	serial-queries 20;\n\
	serial-query-rate 20;\n\
	server-id none;\n\
	statistics-file \"tmp/named.stats\";\n\
	statistics-interval 60;\n\
	tcp-clients 100;\n\
	tcp-listen-queue 3;\n\
#	tkey-dhkey <none>\n\
#	tkey-gssapi-credential <none>\n\
#	tkey-domain <none>\n\
	transfers-per-ns 2;\n\
	transfers-in 10;\n\
	transfers-out 10;\n\
	treat-cr-as-space true;\n\
	use-id-pool true;\n\
	use-ixfr true;\n\
	edns-udp-size 4096;\n\
	max-udp-size 4096;\n\
	reserved-sockets 512;\n\
\n\
	/* view */\n\
	allow-notify {none;};\n\
	allow-update-forwarding {none;};\n\
	allow-query-cache { localnets; localhost; };\n\
	allow-recursion { localnets; localhost; };\n\
#	allow-v6-synthesis <obsolete>;\n\
#	sortlist <none>\n\
#	topology <none>\n\
	auth-nxdomain false;\n\
	minimal-responses false;\n\
	recursion true;\n\
	provide-ixfr true;\n\
	request-ixfr true;\n\
	fetch-glue no;\n\
	rfc2308-type1 no;\n\
	additional-from-auth true;\n\
	additional-from-cache true;\n\
	query-source address *;\n\
	query-source-v6 address *;\n\
	notify-source *;\n\
	notify-source-v6 *;\n\
	cleaning-interval 60;\n\
	min-roots 2;\n\
	lame-ttl 600;\n\
	max-ncache-ttl 10800; /* 3 hours */\n\
	max-cache-ttl 604800; /* 1 week */\n\
	transfer-format many-answers;\n\
	max-cache-size 0;\n\
	check-names master fail;\n\
	check-names slave warn;\n\
	check-names response ignore;\n\
	check-mx warn;\n\
	acache-enable no;\n\
	acache-cleaning-interval 60;\n\
	max-acache-size 0;\n\
	dnssec-enable yes;\n\
	dnssec-validation no; /* Make yes for 9.5. */ \n\
	dnssec-accept-expired no;\n\
	clients-per-query 10;\n\
	max-clients-per-query 100;\n\
	zero-no-soa-ttl-cache no;\n\
"

"	/* zone */\n\
	allow-query {any;};\n\
	allow-transfer {any;};\n\
	notify yes;\n\
#	also-notify <none>\n\
	notify-delay 5;\n\
	dialup no;\n\
#	forward <none>\n\
#	forwarders <none>\n\
	maintain-ixfr-base no;\n\
#	max-ixfr-log-size <obsolete>\n\
	transfer-source *;\n\
	transfer-source-v6 *;\n\
	alt-transfer-source *;\n\
	alt-transfer-source-v6 *;\n\
	max-transfer-time-in 120;\n\
	max-transfer-time-out 120;\n\
	max-transfer-idle-in 60;\n\
	max-transfer-idle-out 60;\n\
	max-retry-time 1209600; /* 2 weeks */\n\
	min-retry-time 500;\n\
	max-refresh-time 2419200; /* 4 weeks */\n\
	min-refresh-time 300;\n\
	multi-master no;\n\
	sig-validity-interval 30; /* days */\n\
	zone-statistics false;\n\
	max-journal-size unlimited;\n\
	ixfr-from-differences false;\n\
	check-wildcard yes;\n\
	check-sibling yes;\n\
	check-integrity yes;\n\
	check-mx-cname warn;\n\
	check-srv-cname warn;\n\
	zero-no-soa-ttl yes;\n\
	update-check-ksk yes;\n\
};\n\
"

"#\n\
#  Zones in the \"_bind\" view are NOT counted in the count of zones.\n\
#\n\
view \"_bind\" chaos {\n\
	recursion no;\n\
	notify no;\n\
\n\
	zone \"version.bind\" chaos {\n\
		type master;\n\
		database \"_builtin version\";\n\
	};\n\
\n\
	zone \"hostname.bind\" chaos {\n\
		type master;\n\
		database \"_builtin hostname\";\n\
	};\n\
\n\
	zone \"authors.bind\" chaos {\n\
		type master;\n\
		database \"_builtin authors\";\n\
	};\n\
	zone \"id.server\" chaos {\n\
		type master;\n\
		database \"_builtin id\";\n\
	};\n\
};\n\
";

isc_result_t
ns_config_parsedefaults(cfg_parser_t *parser, cfg_obj_t **conf) {
	isc_buffer_t b;

	isc_buffer_init(&b, defaultconf, sizeof(defaultconf) - 1);
	isc_buffer_add(&b, sizeof(defaultconf) - 1);
	return (cfg_parse_buffer(parser, &b, &cfg_type_namedconf, conf));
}

isc_result_t
ns_config_get(const cfg_obj_t **maps, const char *name, const cfg_obj_t **obj) {
	int i;

	for (i = 0;; i++) {
		if (maps[i] == NULL)
			return (ISC_R_NOTFOUND);
		if (cfg_map_get(maps[i], name, obj) == ISC_R_SUCCESS)
			return (ISC_R_SUCCESS);
	}
}

isc_result_t
ns_checknames_get(const cfg_obj_t **maps, const char *which,
		  const cfg_obj_t **obj)
{
	const cfg_listelt_t *element;
	const cfg_obj_t *checknames;
	const cfg_obj_t *type;
	const cfg_obj_t *value;
	int i;

	for (i = 0;; i++) {
		if (maps[i] == NULL)
			return (ISC_R_NOTFOUND);
		checknames = NULL;
		if (cfg_map_get(maps[i], "check-names", &checknames) == ISC_R_SUCCESS) {
			/*
			 * Zone map entry is not a list.
			 */
			if (checknames != NULL && !cfg_obj_islist(checknames)) {
				*obj = checknames;
				return (ISC_R_SUCCESS);
			}
			for (element = cfg_list_first(checknames);
			     element != NULL;
			     element = cfg_list_next(element)) {
				value = cfg_listelt_value(element);
				type = cfg_tuple_get(value, "type");
				if (strcasecmp(cfg_obj_asstring(type), which) == 0) {
					*obj = cfg_tuple_get(value, "mode");
					return (ISC_R_SUCCESS);
				}
			}

		}
	}
}

int
ns_config_listcount(const cfg_obj_t *list) {
	const cfg_listelt_t *e;
	int i = 0;

	for (e = cfg_list_first(list); e != NULL; e = cfg_list_next(e))
		i++;

	return (i);
}

isc_result_t
ns_config_getclass(const cfg_obj_t *classobj, dns_rdataclass_t defclass,
		   dns_rdataclass_t *classp) {
	isc_textregion_t r;
	isc_result_t result;

	if (!cfg_obj_isstring(classobj)) {
		*classp = defclass;
		return (ISC_R_SUCCESS);
	}
	DE_CONST(cfg_obj_asstring(classobj), r.base);
	r.length = strlen(r.base);
	result = dns_rdataclass_fromtext(classp, &r);
	if (result != ISC_R_SUCCESS)
		cfg_obj_log(classobj, ns_g_lctx, ISC_LOG_ERROR,
			    "unknown class '%s'", r.base);
	return (result);
}

isc_result_t
ns_config_gettype(const cfg_obj_t *typeobj, dns_rdatatype_t deftype,
		   dns_rdatatype_t *typep) {
	isc_textregion_t r;
	isc_result_t result;

	if (!cfg_obj_isstring(typeobj)) {
		*typep = deftype;
		return (ISC_R_SUCCESS);
	}
	DE_CONST(cfg_obj_asstring(typeobj), r.base);
	r.length = strlen(r.base);
	result = dns_rdatatype_fromtext(typep, &r);
	if (result != ISC_R_SUCCESS)
		cfg_obj_log(typeobj, ns_g_lctx, ISC_LOG_ERROR,
			    "unknown type '%s'", r.base);
	return (result);
}

dns_zonetype_t
ns_config_getzonetype(const cfg_obj_t *zonetypeobj) {
	dns_zonetype_t ztype = dns_zone_none;
	const char *str;

	str = cfg_obj_asstring(zonetypeobj);
	if (strcasecmp(str, "master") == 0)
		ztype = dns_zone_master;
	else if (strcasecmp(str, "slave") == 0)
		ztype = dns_zone_slave;
	else if (strcasecmp(str, "stub") == 0)
		ztype = dns_zone_stub;
	else
		INSIST(0);
	return (ztype);
}

isc_result_t
ns_config_getiplist(const cfg_obj_t *config, const cfg_obj_t *list,
		    in_port_t defport, isc_mem_t *mctx,
		    isc_sockaddr_t **addrsp, isc_uint32_t *countp)
{
	int count, i = 0;
	const cfg_obj_t *addrlist;
	const cfg_obj_t *portobj;
	const cfg_listelt_t *element;
	isc_sockaddr_t *addrs;
	in_port_t port;
	isc_result_t result;

	INSIST(addrsp != NULL && *addrsp == NULL);
	INSIST(countp != NULL);

	addrlist = cfg_tuple_get(list, "addresses");
	count = ns_config_listcount(addrlist);

	portobj = cfg_tuple_get(list, "port");
	if (cfg_obj_isuint32(portobj)) {
		isc_uint32_t val = cfg_obj_asuint32(portobj);
		if (val > ISC_UINT16_MAX) {
			cfg_obj_log(portobj, ns_g_lctx, ISC_LOG_ERROR,
				    "port '%u' out of range", val);
			return (ISC_R_RANGE);
		}
		port = (in_port_t) val;
	} else if (defport != 0)
		port = defport;
	else {
		result = ns_config_getport(config, &port);
		if (result != ISC_R_SUCCESS)
			return (result);
	}

	addrs = isc_mem_get(mctx, count * sizeof(isc_sockaddr_t));
	if (addrs == NULL)
		return (ISC_R_NOMEMORY);

	for (element = cfg_list_first(addrlist);
	     element != NULL;
	     element = cfg_list_next(element), i++)
	{
		INSIST(i < count);
		addrs[i] = *cfg_obj_assockaddr(cfg_listelt_value(element));
		if (isc_sockaddr_getport(&addrs[i]) == 0)
			isc_sockaddr_setport(&addrs[i], port);
	}
	INSIST(i == count);

	*addrsp = addrs;
	*countp = count;

	return (ISC_R_SUCCESS);
}

void
ns_config_putiplist(isc_mem_t *mctx, isc_sockaddr_t **addrsp,
		    isc_uint32_t count)
{
	INSIST(addrsp != NULL && *addrsp != NULL);

	isc_mem_put(mctx, *addrsp, count * sizeof(isc_sockaddr_t));
	*addrsp = NULL;
}

static isc_result_t
get_masters_def(const cfg_obj_t *cctx, const char *name,
	        const cfg_obj_t **ret)
{
	isc_result_t result;
	const cfg_obj_t *masters = NULL;
	const cfg_listelt_t *elt;

	result = cfg_map_get(cctx, "masters", &masters);
	if (result != ISC_R_SUCCESS)
		return (result);
	for (elt = cfg_list_first(masters);
	     elt != NULL;
	     elt = cfg_list_next(elt)) {
		const cfg_obj_t *list;
		const char *listname;

		list = cfg_listelt_value(elt);
		listname = cfg_obj_asstring(cfg_tuple_get(list, "name"));

		if (strcasecmp(listname, name) == 0) {
			*ret = list;
			return (ISC_R_SUCCESS);
		}
	}
	return (ISC_R_NOTFOUND);
}

isc_result_t
ns_config_getipandkeylist(const cfg_obj_t *config, const cfg_obj_t *list,
			  isc_mem_t *mctx, isc_sockaddr_t **addrsp,
			  dns_name_t ***keysp, isc_uint32_t *countp)
{
	isc_uint32_t addrcount = 0, keycount = 0, i = 0;
	isc_uint32_t listcount = 0, l = 0, j;
	isc_uint32_t stackcount = 0, pushed = 0;
	isc_result_t result;
	const cfg_listelt_t *element;
	const cfg_obj_t *addrlist;
	const cfg_obj_t *portobj;
	in_port_t port;
	dns_fixedname_t fname;
	isc_sockaddr_t *addrs = NULL;
	dns_name_t **keys = NULL;
	struct { const char *name; } *lists = NULL;
	struct {
		const cfg_listelt_t *element;
		in_port_t port;
	} *stack = NULL;

	REQUIRE(addrsp != NULL && *addrsp == NULL);
	REQUIRE(keysp != NULL && *keysp == NULL);
	REQUIRE(countp != NULL);

 newlist:
	addrlist = cfg_tuple_get(list, "addresses");
	portobj = cfg_tuple_get(list, "port");
	if (cfg_obj_isuint32(portobj)) {
		isc_uint32_t val = cfg_obj_asuint32(portobj);
		if (val > ISC_UINT16_MAX) {
			cfg_obj_log(portobj, ns_g_lctx, ISC_LOG_ERROR,
				    "port '%u' out of range", val);
			result = ISC_R_RANGE;
			goto cleanup;
		}
		port = (in_port_t) val;
	} else {
		result = ns_config_getport(config, &port);
		if (result != ISC_R_SUCCESS)
			goto cleanup;
	}

	result = ISC_R_NOMEMORY;

	element = cfg_list_first(addrlist);
 resume:
	for ( ;
	     element != NULL;
	     element = cfg_list_next(element))
	{
		const cfg_obj_t *addr;
		const cfg_obj_t *key;
		const char *keystr;
		isc_buffer_t b;

		addr = cfg_tuple_get(cfg_listelt_value(element),
				     "masterselement");
		key = cfg_tuple_get(cfg_listelt_value(element), "key");

		if (!cfg_obj_issockaddr(addr)) {
			const char *listname = cfg_obj_asstring(addr);
			isc_result_t tresult;

			/* Grow lists? */
			if (listcount == l) {
				void * new;
				isc_uint32_t newlen = listcount + 16;
				size_t newsize, oldsize;

				newsize = newlen * sizeof(*lists);
				oldsize = listcount * sizeof(*lists);
				new = isc_mem_get(mctx, newsize);
				if (new == NULL)
					goto cleanup;
				if (listcount != 0) {
					memcpy(new, lists, oldsize);
					isc_mem_put(mctx, lists, oldsize);
				}
				lists = new;
				listcount = newlen;
			}
			/* Seen? */
			for (j = 0; j < l; j++)
				if (strcasecmp(lists[j].name, listname) == 0)
					break;
			if (j < l)
				continue;
			tresult = get_masters_def(config, listname, &list);
			if (tresult == ISC_R_NOTFOUND) {
				cfg_obj_log(addr, ns_g_lctx, ISC_LOG_ERROR,
                                    "masters \"%s\" not found", listname);

				result = tresult;
				goto cleanup;
			}
			if (tresult != ISC_R_SUCCESS)
				goto cleanup;
			lists[l++].name = listname;
			/* Grow stack? */
			if (stackcount == pushed) {
				void * new;
				isc_uint32_t newlen = stackcount + 16;
				size_t newsize, oldsize;

				newsize = newlen * sizeof(*stack);
				oldsize = stackcount * sizeof(*stack);
				new = isc_mem_get(mctx, newsize);
				if (new == NULL)
					goto cleanup;
				if (stackcount != 0) {
					memcpy(new, stack, oldsize);
					isc_mem_put(mctx, stack, oldsize);
				}
				stack = new;
				stackcount = newlen;
			}
			/*
			 * We want to resume processing this list on the
			 * next element.
			 */
			stack[pushed].element = cfg_list_next(element);
			stack[pushed].port = port;
			pushed++;
			goto newlist;
		}

		if (i == addrcount) {
			void * new;
			isc_uint32_t newlen = addrcount + 16;
			size_t newsize, oldsize;

			newsize = newlen * sizeof(isc_sockaddr_t);
			oldsize = addrcount * sizeof(isc_sockaddr_t);
			new = isc_mem_get(mctx, newsize);
			if (new == NULL)
				goto cleanup;
			if (addrcount != 0) {
				memcpy(new, addrs, oldsize);
				isc_mem_put(mctx, addrs, oldsize);
			}
			addrs = new;
			addrcount = newlen;

			newsize = newlen * sizeof(dns_name_t *);
			oldsize = keycount * sizeof(dns_name_t *);
			new = isc_mem_get(mctx, newsize);
			if (new == NULL)
				goto cleanup;
			if (keycount != 0) {
				memcpy(new, keys, oldsize);
				isc_mem_put(mctx, keys, oldsize);
			}
			keys = new;
			keycount = newlen;
		}

		addrs[i] = *cfg_obj_assockaddr(addr);
		if (isc_sockaddr_getport(&addrs[i]) == 0)
			isc_sockaddr_setport(&addrs[i], port);
		keys[i] = NULL;
		if (!cfg_obj_isstring(key)) {
			i++;
			continue;
		}
		keys[i] = isc_mem_get(mctx, sizeof(dns_name_t));
		if (keys[i] == NULL)
			goto cleanup;
		dns_name_init(keys[i], NULL);
		
		keystr = cfg_obj_asstring(key);
		isc_buffer_init(&b, keystr, strlen(keystr));
		isc_buffer_add(&b, strlen(keystr));
		dns_fixedname_init(&fname);
		result = dns_name_fromtext(dns_fixedname_name(&fname), &b,
					   dns_rootname, ISC_FALSE, NULL);
		if (result != ISC_R_SUCCESS)
			goto cleanup;
		result = dns_name_dup(dns_fixedname_name(&fname), mctx,
				      keys[i]);
		if (result != ISC_R_SUCCESS)
			goto cleanup;
		i++;
	}
	if (pushed != 0) {
		pushed--;
		element = stack[pushed].element;
		port = stack[pushed].port;
		goto resume;
	}
	if (i < addrcount) {
		void * new;
		size_t newsize, oldsize;

		newsize = i * sizeof(isc_sockaddr_t);
		oldsize = addrcount * sizeof(isc_sockaddr_t);
		if (i != 0) {
			new = isc_mem_get(mctx, newsize);
			if (new == NULL)
				goto cleanup;
			memcpy(new, addrs, newsize);
		} else
			new = NULL;
		isc_mem_put(mctx, addrs, oldsize);
		addrs = new;
		addrcount = i;

		newsize = i * sizeof(dns_name_t *);
		oldsize = keycount * sizeof(dns_name_t *);
		if (i != 0) {
			new = isc_mem_get(mctx, newsize);
			if (new == NULL)
				goto cleanup;
			memcpy(new, keys,  newsize);
		} else
			new = NULL;
		isc_mem_put(mctx, keys, oldsize);
		keys = new;
		keycount = i;
	}

	if (lists != NULL)
		isc_mem_put(mctx, lists, listcount * sizeof(*lists));
	if (stack != NULL)
		isc_mem_put(mctx, stack, stackcount * sizeof(*stack));
	
	INSIST(keycount == addrcount);

	*addrsp = addrs;
	*keysp = keys;
	*countp = addrcount;

	return (ISC_R_SUCCESS);

 cleanup:
	if (addrs != NULL)
		isc_mem_put(mctx, addrs, addrcount * sizeof(isc_sockaddr_t));
	if (keys != NULL) {
		for (j = 0; j <= i; j++) {
			if (keys[j] == NULL)
				continue;
			if (dns_name_dynamic(keys[j]))
				dns_name_free(keys[j], mctx);
			isc_mem_put(mctx, keys[j], sizeof(dns_name_t));
		}
		isc_mem_put(mctx, keys, keycount * sizeof(dns_name_t *));
	}
	if (lists != NULL)
		isc_mem_put(mctx, lists, listcount * sizeof(*lists));
	if (stack != NULL)
		isc_mem_put(mctx, stack, stackcount * sizeof(*stack));
	return (result);
}

void
ns_config_putipandkeylist(isc_mem_t *mctx, isc_sockaddr_t **addrsp,
			  dns_name_t ***keysp, isc_uint32_t count)
{
	unsigned int i;
	dns_name_t **keys = *keysp;

	INSIST(addrsp != NULL && *addrsp != NULL);

	isc_mem_put(mctx, *addrsp, count * sizeof(isc_sockaddr_t));
	for (i = 0; i < count; i++) {
		if (keys[i] == NULL)
			continue;
		if (dns_name_dynamic(keys[i]))
			dns_name_free(keys[i], mctx);
		isc_mem_put(mctx, keys[i], sizeof(dns_name_t));
	}
	isc_mem_put(mctx, *keysp, count * sizeof(dns_name_t *));
	*addrsp = NULL;
	*keysp = NULL;
}

isc_result_t
ns_config_getport(const cfg_obj_t *config, in_port_t *portp) {
	const cfg_obj_t *maps[3];
	const cfg_obj_t *options = NULL;
	const cfg_obj_t *portobj = NULL;
	isc_result_t result;
	int i;

	(void)cfg_map_get(config, "options", &options);
	i = 0;
	if (options != NULL)
		maps[i++] = options;
	maps[i++] = ns_g_defaults;
	maps[i] = NULL;

	result = ns_config_get(maps, "port", &portobj);
	INSIST(result == ISC_R_SUCCESS);
	if (cfg_obj_asuint32(portobj) >= ISC_UINT16_MAX) {
		cfg_obj_log(portobj, ns_g_lctx, ISC_LOG_ERROR,
			    "port '%u' out of range",
			    cfg_obj_asuint32(portobj));
		return (ISC_R_RANGE);
	}
	*portp = (in_port_t)cfg_obj_asuint32(portobj);
	return (ISC_R_SUCCESS);
}

struct keyalgorithms {
	const char *str;
	enum { hmacnone, hmacmd5, hmacsha1, hmacsha224,
	       hmacsha256, hmacsha384, hmacsha512 } hmac;
	isc_uint16_t size;
} algorithms[] = {
	{ "hmac-md5", hmacmd5, 128 },
	{ "hmac-md5.sig-alg.reg.int", hmacmd5, 0 },
	{ "hmac-md5.sig-alg.reg.int.", hmacmd5, 0 },
	{ "hmac-sha1", hmacsha1, 160 },
	{ "hmac-sha224", hmacsha224, 224 },
	{ "hmac-sha256", hmacsha256, 256 },
	{ "hmac-sha384", hmacsha384, 384 },
	{ "hmac-sha512", hmacsha512, 512 },
	{  NULL, hmacnone, 0 }
};

isc_result_t
ns_config_getkeyalgorithm(const char *str, dns_name_t **name,
			  isc_uint16_t *digestbits)
{
	int i;
	size_t len = 0;
	isc_uint16_t bits;
	isc_result_t result;

	for (i = 0; algorithms[i].str != NULL; i++) {
		len = strlen(algorithms[i].str);
		if (strncasecmp(algorithms[i].str, str, len) == 0 &&
		    (str[len] == '\0' ||
		     (algorithms[i].size != 0 && str[len] == '-')))
			break;
	}
	if (algorithms[i].str == NULL)
		return (ISC_R_NOTFOUND);
	if (str[len] == '-') {
		result = isc_parse_uint16(&bits, str + len + 1, 10);
		if (result != ISC_R_SUCCESS)
			return (result);
		if (bits > algorithms[i].size)
			return (ISC_R_RANGE);
	} else if (algorithms[i].size == 0)
		bits = 128;
	else
		bits = algorithms[i].size;

	if (name != NULL) {
		switch (algorithms[i].hmac) {
		case hmacmd5: *name = dns_tsig_hmacmd5_name; break;
		case hmacsha1: *name = dns_tsig_hmacsha1_name; break;
		case hmacsha224: *name = dns_tsig_hmacsha224_name; break;
		case hmacsha256: *name = dns_tsig_hmacsha256_name; break;
		case hmacsha384: *name = dns_tsig_hmacsha384_name; break;
		case hmacsha512: *name = dns_tsig_hmacsha512_name; break;
		default:
			INSIST(0);
		}
	}
	if (digestbits != NULL)
		*digestbits = bits;
	return (ISC_R_SUCCESS);
}
@


1.8
log
@Update to BIND 9.4.2-P2 and adapt our dynamic select changes.  OK deraadt@@
@
text
@@


1.7
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2007  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: config.c,v 1.47.18.32 2007/09/13 05:04:01 each Exp $ */
d55 1
a55 1
	files default;\n\
d102 1
@


1.6
log
@resolve conflicts and regen configure script
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")
d5 1
a5 1
 * Permission to use, copy, modify, and distribute this software for any
d18 3
a20 1
/* $ISC: config.c,v 1.11.2.4.8.32 2006/02/28 06:32:53 marka Exp $ */
a24 1
#include <string.h>
d29 1
d33 1
d48 1
d83 1
a83 1
	rrset-order {order cyclic;};\n\
d101 1
d106 2
a107 1
	allow-recursion {any;};\n\
d134 10
a143 1
	dnssec-enable no; /* Make yes for 9.4. */ \n\
d151 1
d174 7
d185 1
a185 1
#  Zones in the \"_bind\" view are NOT counted is the count of zones.\n\
a283 1
	const char *str;
d291 2
a292 3
	str = cfg_obj_asstring(classobj);
	DE_CONST(str, r.base);
	r.length = strlen(str);
d296 1
a296 1
			    "unknown class '%s'", str);
a302 1
	const char *str;
d310 2
a311 3
	str = cfg_obj_asstring(typeobj);
	DE_CONST(str, r.base);
	r.length = strlen(str);
d315 1
a315 1
			    "unknown type '%s'", str);
d405 1
a405 1
		const cfg_obj_t **ret)
d447 1
a447 1
	const char **lists = NULL;
d516 1
a516 1
				if (strcasecmp(lists[j], listname) == 0)
d530 1
a530 1
			lists[l++] = listname;
d735 17
d753 2
a754 1
ns_config_getkeyalgorithm(const char *str, dns_name_t **name)
d756 36
a791 7
	if (strcasecmp(str, "hmac-md5") == 0 ||
	    strcasecmp(str, "hmac-md5.sig-alg.reg.int") == 0 ||
	    strcasecmp(str, "hmac-md5.sig-alg.reg.int.") == 0)
	{
		if (name != NULL)
			*name = dns_tsig_hmacmd5_name;
		return (ISC_R_SUCCESS);
d793 3
a795 1
	return (ISC_R_NOTFOUND);
@


1.5
log
@rndc will now create output files of 'rndc dumpdb', 'rndc
stats' and 'rndc recursing' commands in /var/named/tmp (instead of
/var/named), which is writable by the 'named' user.

feedback and ok jakob@@ deraadt@@, also agreed by fkr@@ and msf@@
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: config.c,v 1.11.2.4.8.29 2004/10/05 02:52:26 marka Exp $ */
d199 1
a199 1
ns_config_get(cfg_obj_t **maps, const char *name, cfg_obj_t **obj) {
d211 7
a217 5
ns_checknames_get(cfg_obj_t **maps, const char *which, cfg_obj_t **obj) {
	cfg_listelt_t *element;
	cfg_obj_t *checknames;
	cfg_obj_t *type;
	cfg_obj_t *value;
d248 2
a249 2
ns_config_listcount(cfg_obj_t *list) {
	cfg_listelt_t *e;
d259 1
a259 1
ns_config_getclass(cfg_obj_t *classobj, dns_rdataclass_t defclass,
d261 1
a261 1
	char *str;
d270 1
a270 1
	r.base = str;
d280 1
a280 1
ns_config_gettype(cfg_obj_t *typeobj, dns_rdatatype_t deftype,
d282 1
a282 1
	char *str;
d291 1
a291 1
	r.base = str;
d301 1
a301 1
ns_config_getzonetype(cfg_obj_t *zonetypeobj) {
d303 1
a303 1
	char *str;
d318 1
a318 1
ns_config_getiplist(cfg_obj_t *config, cfg_obj_t *list,
d323 3
a325 3
	cfg_obj_t *addrlist;
	cfg_obj_t *portobj;
	cfg_listelt_t *element;
d385 3
a387 1
get_masters_def(cfg_obj_t *cctx, char *name, cfg_obj_t **ret) {
d389 2
a390 2
	cfg_obj_t *masters = NULL;
	cfg_listelt_t *elt;
d398 1
a398 1
		cfg_obj_t *list;
d413 3
a415 3
ns_config_getipandkeylist(cfg_obj_t *config, cfg_obj_t *list, isc_mem_t *mctx,
			  isc_sockaddr_t **addrsp, dns_name_t ***keysp,
			  isc_uint32_t *countp)
d421 3
a423 3
	cfg_listelt_t *element;
	cfg_obj_t *addrlist;
	cfg_obj_t *portobj;
d428 1
a428 1
	char **lists = NULL;
d430 1
a430 1
		cfg_listelt_t *element;
d446 2
a447 1
			return (ISC_R_RANGE);
d453 1
a453 1
			return (result);
d464 3
a466 3
		cfg_obj_t *addr;
		cfg_obj_t *key;
		char *keystr;
d474 1
a474 1
			char *listname = cfg_obj_asstring(addr);
a613 1
			isc_mem_put(mctx, addrs, oldsize);
d616 1
a626 1
			isc_mem_put(mctx, keys, oldsize);
d629 1
d690 4
a693 4
ns_config_getport(cfg_obj_t *config, in_port_t *portp) {
	cfg_obj_t *maps[3];
	cfg_obj_t *options = NULL;
	cfg_obj_t *portobj = NULL;
@


1.4
log
@resolve conflicts
@
text
@d56 1
a56 1
	dump-file \"named_dump.db\";\n\
d65 1
a65 1
	memstatistics-file \"named.memstats\";\n\
d70 1
a70 1
	recursing-file \"named.recursing\";\n\
d83 1
a83 1
	statistics-file \"named.stats\";\n\
@


1.3
log
@resolve conflicts
@
text
@d18 1
a18 1
/* $ISC: config.c,v 1.11.2.4.8.28 2004/08/28 05:41:42 marka Exp $ */
d558 2
a559 2
				memcpy(new, keys, newsize);
				isc_mem_put(mctx, keys, newsize);
@


1.2
log
@listen to IPv6 interfaces by default
@
text
@d2 2
a3 1
 * Copyright (C) 2001, 2002  Internet Software Consortium.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: config.c,v 1.11.2.4 2002/03/20 20:32:41 marka Exp $ */
d33 1
a33 1
#include <isccfg/cfg.h>
d38 1
d47 3
a49 2
#	blackhole {none;};\n\
	coresize default;\n\
d51 4
a54 1
	deallocate-on-exit true;\n\
a57 1
	files default;\n\
d70 1
d82 1
a82 1
	stacksize default;\n\
d86 1
d96 1
a96 1
	version \""VERSION"\";\n\
d102 1
a102 1
	allow-v6-synthesis {none;};\n\
d125 2
a126 2
	check-names master ignore;\n\
	check-names slave ignore;\n\
d128 4
a131 2
\n\
	/* zone */\n\
d143 2
d153 1
d156 32
a187 1
};";
d199 1
a199 1
ns_config_get(cfg_obj_t **maps, const char* name, cfg_obj_t **obj) {
d202 1
a202 1
	for (i = 0; ; i++) {
d210 35
d277 21
d329 1
d382 26
d413 3
a415 1
	isc_uint32_t count, i = 0;
d424 9
d434 1
a434 2
	INSIST(addrsp != NULL && *addrsp == NULL);

a435 2
	count = ns_config_listcount(addrlist);

d453 3
a455 9
	addrs = isc_mem_get(mctx, count * sizeof(isc_sockaddr_t));
	if (addrs == NULL)
		goto cleanup;

	keys = isc_mem_get(mctx, count * sizeof(dns_name_t *));
	if (keys == NULL)
		goto cleanup;

	for (element = cfg_list_first(addrlist);
d457 1
a457 1
	     element = cfg_list_next(element), i++)
d464 70
a533 1
		INSIST(i < count);
d535 29
a563 2
		addr = cfg_tuple_get(cfg_listelt_value(element), "sockaddr");
		key = cfg_tuple_get(cfg_listelt_value(element), "key");
a567 1

d569 2
a570 1
		if (!cfg_obj_isstring(key))
d572 1
d590 7
d598 37
a634 1
	INSIST(i == count);
d638 1
a638 1
	*countp = count;
d644 1
a644 1
		isc_mem_put(mctx, addrs, count * sizeof(isc_sockaddr_t));
d646 1
a646 2
		unsigned int j;
		for (j = 0 ; j <= i; j++) {
d653 1
a653 1
		isc_mem_put(mctx, keys, count * sizeof(dns_name_t *));
d655 4
d692 1
a692 1
	cfg_map_get(config, "options", &options);
@


1.1
log
@Initial revision
@
text
@d59 1
a59 1
	listen-on-v6 {none;};\n\
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 2001-2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: config.c,v 1.11.2.4.8.28 2004/08/28 05:41:42 marka Exp $ */
d33 1
a33 1
#include <isccfg/namedconf.h>
a37 1
#include <dns/rdatatype.h>
d46 2
a47 3
#	blackhole {none;};\n"
#ifndef WIN32
"	coresize default;\n\
d49 1
a49 4
	files default;\n\
	stacksize default;\n"
#endif
"	deallocate-on-exit true;\n\
d53 1
a65 1
	recursing-file \"named.recursing\";\n\
d77 1
a77 1
	server-id none;\n\
a80 1
	tcp-listen-queue 3;\n\
d90 1
a90 1
	edns-udp-size 4096;\n\
d96 1
a96 1
#	allow-v6-synthesis <obsolete>;\n\
d119 2
a120 2
	check-names master fail;\n\
	check-names slave warn;\n\
d122 2
a123 4
	dnssec-enable no; /* Make yes for 9.4. */ \n\
"

"	/* zone */\n\
a134 2
	alt-transfer-source *;\n\
	alt-transfer-source-v6 *;\n\
a142 1
	multi-master no;\n\
d145 1
a145 32
	max-journal-size unlimited;\n\
	ixfr-from-differences false;\n\
};\n\
"

"#\n\
#  Zones in the \"_bind\" view are NOT counted is the count of zones.\n\
#\n\
view \"_bind\" chaos {\n\
	recursion no;\n\
	notify no;\n\
\n\
	zone \"version.bind\" chaos {\n\
		type master;\n\
		database \"_builtin version\";\n\
	};\n\
\n\
	zone \"hostname.bind\" chaos {\n\
		type master;\n\
		database \"_builtin hostname\";\n\
	};\n\
\n\
	zone \"authors.bind\" chaos {\n\
		type master;\n\
		database \"_builtin authors\";\n\
	};\n\
	zone \"id.server\" chaos {\n\
		type master;\n\
		database \"_builtin id\";\n\
	};\n\
};\n\
";
d157 1
a157 1
ns_config_get(cfg_obj_t **maps, const char *name, cfg_obj_t **obj) {
d160 1
a160 1
	for (i = 0;; i++) {
a167 35
isc_result_t
ns_checknames_get(cfg_obj_t **maps, const char *which, cfg_obj_t **obj) {
	cfg_listelt_t *element;
	cfg_obj_t *checknames;
	cfg_obj_t *type;
	cfg_obj_t *value;
	int i;

	for (i = 0;; i++) {
		if (maps[i] == NULL)
			return (ISC_R_NOTFOUND);
		checknames = NULL;
		if (cfg_map_get(maps[i], "check-names", &checknames) == ISC_R_SUCCESS) {
			/*
			 * Zone map entry is not a list.
			 */
			if (checknames != NULL && !cfg_obj_islist(checknames)) {
				*obj = checknames;
				return (ISC_R_SUCCESS);
			}
			for (element = cfg_list_first(checknames);
			     element != NULL;
			     element = cfg_list_next(element)) {
				value = cfg_listelt_value(element);
				type = cfg_tuple_get(value, "type");
				if (strcasecmp(cfg_obj_asstring(type), which) == 0) {
					*obj = cfg_tuple_get(value, "mode");
					return (ISC_R_SUCCESS);
				}
			}

		}
	}
}

a199 21
isc_result_t
ns_config_gettype(cfg_obj_t *typeobj, dns_rdatatype_t deftype,
		   dns_rdatatype_t *typep) {
	char *str;
	isc_textregion_t r;
	isc_result_t result;

	if (!cfg_obj_isstring(typeobj)) {
		*typep = deftype;
		return (ISC_R_SUCCESS);
	}
	str = cfg_obj_asstring(typeobj);
	r.base = str;
	r.length = strlen(str);
	result = dns_rdatatype_fromtext(typep, &r);
	if (result != ISC_R_SUCCESS)
		cfg_obj_log(typeobj, ns_g_lctx, ISC_LOG_ERROR,
			    "unknown type '%s'", str);
	return (result);
}

a230 1
	INSIST(countp != NULL);
a282 26
static isc_result_t
get_masters_def(cfg_obj_t *cctx, char *name, cfg_obj_t **ret) {
	isc_result_t result;
	cfg_obj_t *masters = NULL;
	cfg_listelt_t *elt;

	result = cfg_map_get(cctx, "masters", &masters);
	if (result != ISC_R_SUCCESS)
		return (result);
	for (elt = cfg_list_first(masters);
	     elt != NULL;
	     elt = cfg_list_next(elt)) {
		cfg_obj_t *list;
		const char *listname;

		list = cfg_listelt_value(elt);
		listname = cfg_obj_asstring(cfg_tuple_get(list, "name"));

		if (strcasecmp(listname, name) == 0) {
			*ret = list;
			return (ISC_R_SUCCESS);
		}
	}
	return (ISC_R_NOTFOUND);
}

d288 1
a288 3
	isc_uint32_t addrcount = 0, keycount = 0, i = 0;
	isc_uint32_t listcount = 0, l = 0, j;
	isc_uint32_t stackcount = 0, pushed = 0;
a296 9
	char **lists = NULL;
	struct {
		cfg_listelt_t *element;
		in_port_t port;
	} *stack = NULL;

	REQUIRE(addrsp != NULL && *addrsp == NULL);
	REQUIRE(keysp != NULL && *keysp == NULL);
	REQUIRE(countp != NULL);
d298 2
a299 1
 newlist:
d301 2
d320 9
a328 3
	element = cfg_list_first(addrlist);
 resume:
	for ( ;
d330 1
a330 1
	     element = cfg_list_next(element))
d337 3
a339 2
		addr = cfg_tuple_get(cfg_listelt_value(element),
				     "masterselement");
a341 97
		if (!cfg_obj_issockaddr(addr)) {
			char *listname = cfg_obj_asstring(addr);
			isc_result_t tresult;

			/* Grow lists? */
			if (listcount == l) {
				void * new;
				isc_uint32_t newlen = listcount + 16;
				size_t newsize, oldsize;

				newsize = newlen * sizeof(*lists);
				oldsize = listcount * sizeof(*lists);
				new = isc_mem_get(mctx, newsize);
				if (new == NULL)
					goto cleanup;
				if (listcount != 0) {
					memcpy(new, lists, oldsize);
					isc_mem_put(mctx, lists, oldsize);
				}
				lists = new;
				listcount = newlen;
			}
			/* Seen? */
			for (j = 0; j < l; j++)
				if (strcasecmp(lists[j], listname) == 0)
					break;
			if (j < l)
				continue;
			tresult = get_masters_def(config, listname, &list);
			if (tresult == ISC_R_NOTFOUND) {
				cfg_obj_log(addr, ns_g_lctx, ISC_LOG_ERROR,
                                    "masters \"%s\" not found", listname);

				result = tresult;
				goto cleanup;
			}
			if (tresult != ISC_R_SUCCESS)
				goto cleanup;
			lists[l++] = listname;
			/* Grow stack? */
			if (stackcount == pushed) {
				void * new;
				isc_uint32_t newlen = stackcount + 16;
				size_t newsize, oldsize;

				newsize = newlen * sizeof(*stack);
				oldsize = stackcount * sizeof(*stack);
				new = isc_mem_get(mctx, newsize);
				if (new == NULL)
					goto cleanup;
				if (stackcount != 0) {
					memcpy(new, stack, oldsize);
					isc_mem_put(mctx, stack, oldsize);
				}
				stack = new;
				stackcount = newlen;
			}
			/*
			 * We want to resume processing this list on the
			 * next element.
			 */
			stack[pushed].element = cfg_list_next(element);
			stack[pushed].port = port;
			pushed++;
			goto newlist;
		}

		if (i == addrcount) {
			void * new;
			isc_uint32_t newlen = addrcount + 16;
			size_t newsize, oldsize;

			newsize = newlen * sizeof(isc_sockaddr_t);
			oldsize = addrcount * sizeof(isc_sockaddr_t);
			new = isc_mem_get(mctx, newsize);
			if (new == NULL)
				goto cleanup;
			if (addrcount != 0) {
				memcpy(new, addrs, oldsize);
				isc_mem_put(mctx, addrs, oldsize);
			}
			addrs = new;
			addrcount = newlen;

			newsize = newlen * sizeof(dns_name_t *);
			oldsize = keycount * sizeof(dns_name_t *);
			new = isc_mem_get(mctx, newsize);
			if (new == NULL)
				goto cleanup;
			if (keycount != 0) {
				memcpy(new, keys, newsize);
				isc_mem_put(mctx, keys, newsize);
			}
			keys = new;
			keycount = newlen;
		}

d345 1
d347 1
a347 2
		if (!cfg_obj_isstring(key)) {
			i++;
a348 1
		}
a365 37
		i++;
	}
	if (pushed != 0) {
		pushed--;
		element = stack[pushed].element;
		port = stack[pushed].port;
		goto resume;
	}
	if (i < addrcount) {
		void * new;
		size_t newsize, oldsize;

		newsize = i * sizeof(isc_sockaddr_t);
		oldsize = addrcount * sizeof(isc_sockaddr_t);
		if (i != 0) {
			new = isc_mem_get(mctx, newsize);
			if (new == NULL)
				goto cleanup;
			memcpy(new, addrs, newsize);
			isc_mem_put(mctx, addrs, oldsize);
		} else
			new = NULL;
		addrs = new;
		addrcount = i;

		newsize = i * sizeof(dns_name_t *);
		oldsize = keycount * sizeof(dns_name_t *);
		if (i != 0) {
			new = isc_mem_get(mctx, newsize);
			if (new == NULL)
				goto cleanup;
			memcpy(new, keys,  newsize);
			isc_mem_put(mctx, keys, oldsize);
		} else
			new = NULL;
		keys = new;
		keycount = i;
d367 1
a367 7

	if (lists != NULL)
		isc_mem_put(mctx, lists, listcount * sizeof(*lists));
	if (stack != NULL)
		isc_mem_put(mctx, stack, stackcount * sizeof(*stack));
	
	INSIST(keycount == addrcount);
d371 1
a371 1
	*countp = addrcount;
d377 1
a377 1
		isc_mem_put(mctx, addrs, addrcount * sizeof(isc_sockaddr_t));
d379 2
a380 1
		for (j = 0; j <= i; j++) {
d387 1
a387 1
		isc_mem_put(mctx, keys, keycount * sizeof(dns_name_t *));
a388 4
	if (lists != NULL)
		isc_mem_put(mctx, lists, listcount * sizeof(*lists));
	if (stack != NULL)
		isc_mem_put(mctx, stack, stackcount * sizeof(*stack));
d422 1
a422 1
	(void)cfg_map_get(config, "options", &options);
@


1.1.1.3
log
@ISC BIND release 9.3.1. ok deraadt@@
@
text
@d18 1
a18 1
/* $ISC: config.c,v 1.11.2.4.8.29 2004/10/05 02:52:26 marka Exp $ */
d558 2
a559 2
				memcpy(new, keys, oldsize);
				isc_mem_put(mctx, keys, oldsize);
@


1.1.1.4
log
@ISC BIND release 9.3.3
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: config.c,v 1.11.2.4.8.32 2006/02/28 06:32:53 marka Exp $ */
d199 1
a199 1
ns_config_get(const cfg_obj_t **maps, const char *name, const cfg_obj_t **obj) {
d211 5
a215 7
ns_checknames_get(const cfg_obj_t **maps, const char *which,
		  const cfg_obj_t **obj)
{
	const cfg_listelt_t *element;
	const cfg_obj_t *checknames;
	const cfg_obj_t *type;
	const cfg_obj_t *value;
d246 2
a247 2
ns_config_listcount(const cfg_obj_t *list) {
	const cfg_listelt_t *e;
d257 1
a257 1
ns_config_getclass(const cfg_obj_t *classobj, dns_rdataclass_t defclass,
d259 1
a259 1
	const char *str;
d268 1
a268 1
	DE_CONST(str, r.base);
d278 1
a278 1
ns_config_gettype(const cfg_obj_t *typeobj, dns_rdatatype_t deftype,
d280 1
a280 1
	const char *str;
d289 1
a289 1
	DE_CONST(str, r.base);
d299 1
a299 1
ns_config_getzonetype(const cfg_obj_t *zonetypeobj) {
d301 1
a301 1
	const char *str;
d316 1
a316 1
ns_config_getiplist(const cfg_obj_t *config, const cfg_obj_t *list,
d321 3
a323 3
	const cfg_obj_t *addrlist;
	const cfg_obj_t *portobj;
	const cfg_listelt_t *element;
d383 1
a383 3
get_masters_def(const cfg_obj_t *cctx, const char *name,
		const cfg_obj_t **ret)
{
d385 2
a386 2
	const cfg_obj_t *masters = NULL;
	const cfg_listelt_t *elt;
d394 1
a394 1
		const cfg_obj_t *list;
d409 3
a411 3
ns_config_getipandkeylist(const cfg_obj_t *config, const cfg_obj_t *list,
			  isc_mem_t *mctx, isc_sockaddr_t **addrsp,
			  dns_name_t ***keysp, isc_uint32_t *countp)
d417 3
a419 3
	const cfg_listelt_t *element;
	const cfg_obj_t *addrlist;
	const cfg_obj_t *portobj;
d424 1
a424 1
	const char **lists = NULL;
d426 1
a426 1
		const cfg_listelt_t *element;
d442 1
a442 2
			result = ISC_R_RANGE;
			goto cleanup;
d448 1
a448 1
			goto cleanup;
d459 3
a461 3
		const cfg_obj_t *addr;
		const cfg_obj_t *key;
		const char *keystr;
d469 1
a469 1
			const char *listname = cfg_obj_asstring(addr);
d609 1
a611 1
		isc_mem_put(mctx, addrs, oldsize);
d622 1
a624 1
		isc_mem_put(mctx, keys, oldsize);
d685 4
a688 4
ns_config_getport(const cfg_obj_t *config, in_port_t *portp) {
	const cfg_obj_t *maps[3];
	const cfg_obj_t *options = NULL;
	const cfg_obj_t *portobj = NULL;
@


1.1.1.5
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2007  Internet Systems Consortium, Inc. ("ISC")
d5 1
a5 1
 * Permission to use, copy, modify, and/or distribute this software for any
d18 1
a18 3
/* $ISC: config.c,v 1.47.18.32 2007/09/13 05:04:01 each Exp $ */

/*! \file */
d23 1
a27 1
#include <isc/parseint.h>
a30 1
#include <isc/string.h>
a44 1
/*% default configuration */
d79 1
a79 1
	rrset-order {type NS order random; order cyclic; };\n\
a96 1
	max-udp-size 4096;\n\
d101 1
a101 2
	allow-query-cache { localnets; localhost; };\n\
	allow-recursion { localnets; localhost; };\n\
d128 1
a128 10
	check-mx warn;\n\
	acache-enable no;\n\
	acache-cleaning-interval 60;\n\
	max-acache-size 0;\n\
	dnssec-enable yes;\n\
	dnssec-validation no; /* Make yes for 9.5. */ \n\
	dnssec-accept-expired no;\n\
	clients-per-query 10;\n\
	max-clients-per-query 100;\n\
	zero-no-soa-ttl-cache no;\n\
a135 1
	notify-delay 5;\n\
a157 7
	check-wildcard yes;\n\
	check-sibling yes;\n\
	check-integrity yes;\n\
	check-mx-cname warn;\n\
	check-srv-cname warn;\n\
	zero-no-soa-ttl yes;\n\
	update-check-ksk yes;\n\
d162 1
a162 1
#  Zones in the \"_bind\" view are NOT counted in the count of zones.\n\
d261 1
d269 3
a271 2
	DE_CONST(cfg_obj_asstring(classobj), r.base);
	r.length = strlen(r.base);
d275 1
a275 1
			    "unknown class '%s'", r.base);
d282 1
d290 3
a292 2
	DE_CONST(cfg_obj_asstring(typeobj), r.base);
	r.length = strlen(r.base);
d296 1
a296 1
			    "unknown type '%s'", r.base);
d386 1
a386 1
	        const cfg_obj_t **ret)
d428 1
a428 1
	struct { const char *name; } *lists = NULL;
d497 1
a497 1
				if (strcasecmp(lists[j].name, listname) == 0)
d511 1
a511 1
			lists[l++].name = listname;
a715 17
struct keyalgorithms {
	const char *str;
	enum { hmacnone, hmacmd5, hmacsha1, hmacsha224,
	       hmacsha256, hmacsha384, hmacsha512 } hmac;
	isc_uint16_t size;
} algorithms[] = {
	{ "hmac-md5", hmacmd5, 128 },
	{ "hmac-md5.sig-alg.reg.int", hmacmd5, 0 },
	{ "hmac-md5.sig-alg.reg.int.", hmacmd5, 0 },
	{ "hmac-sha1", hmacsha1, 160 },
	{ "hmac-sha224", hmacsha224, 224 },
	{ "hmac-sha256", hmacsha256, 256 },
	{ "hmac-sha384", hmacsha384, 384 },
	{ "hmac-sha512", hmacsha512, 512 },
	{  NULL, hmacnone, 0 }
};

d717 1
a717 2
ns_config_getkeyalgorithm(const char *str, dns_name_t **name,
			  isc_uint16_t *digestbits)
d719 7
a725 36
	int i;
	size_t len = 0;
	isc_uint16_t bits;
	isc_result_t result;

	for (i = 0; algorithms[i].str != NULL; i++) {
		len = strlen(algorithms[i].str);
		if (strncasecmp(algorithms[i].str, str, len) == 0 &&
		    (str[len] == '\0' ||
		     (algorithms[i].size != 0 && str[len] == '-')))
			break;
	}
	if (algorithms[i].str == NULL)
		return (ISC_R_NOTFOUND);
	if (str[len] == '-') {
		result = isc_parse_uint16(&bits, str + len + 1, 10);
		if (result != ISC_R_SUCCESS)
			return (result);
		if (bits > algorithms[i].size)
			return (ISC_R_RANGE);
	} else if (algorithms[i].size == 0)
		bits = 128;
	else
		bits = algorithms[i].size;

	if (name != NULL) {
		switch (algorithms[i].hmac) {
		case hmacmd5: *name = dns_tsig_hmacmd5_name; break;
		case hmacsha1: *name = dns_tsig_hmacsha1_name; break;
		case hmacsha224: *name = dns_tsig_hmacsha224_name; break;
		case hmacsha256: *name = dns_tsig_hmacsha256_name; break;
		case hmacsha384: *name = dns_tsig_hmacsha384_name; break;
		case hmacsha512: *name = dns_tsig_hmacsha512_name; break;
		default:
			INSIST(0);
		}
d727 1
a727 3
	if (digestbits != NULL)
		*digestbits = bits;
	return (ISC_R_SUCCESS);
@


