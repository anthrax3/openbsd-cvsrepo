head	1.19;
access;
symbols
	OPENBSD_5_6:1.18.0.18
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.16
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.12
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.10
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.8
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.6
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.17.0.12
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.8
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.10
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.6
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	BIND_9_4_2_P1:1.1.1.6
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	BIND_9_4_2:1.1.1.6
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	BIND_9_3_4:1.1.1.5
	BIND_9_3_3:1.1.1.5
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	BIND_9_3_2:1.1.1.4
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	BIND_9_3_1:1.1.1.3
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.08.25.07.08.32;	author brad;	state dead;
branches;
next	1.18;
commitid	zKogyOACFMOV70QE;

1.18
date	2010.12.31.21.22.42;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.09.13.39.42;	author jakob;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.10.19.07.58;	author jakob;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.05.17.36.33;	author jakob;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.14.09.11.11;	author jakob;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.22.16.52.38;	author jakob;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.16.19.18.13;	author david;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.19.15.37.36;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.28.17.14.03;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.12.18.40.15;	author canacar;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.18.14.14.05;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.23.06.56.12;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.20.22.22.45;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.20.22.12.21;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.20.22.05.09;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.20.22.03.58;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.20.21.52.46;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.06.10;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.06.10;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.33.01;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.03.22.16.36.25;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.04.05.16.42.11;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2007.01.10.18.18.26;	author jakob;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2007.12.09.12.33.10;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Start removing unused documentation and the server and related binaries source
code.
@
text
@/*
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1999-2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: main.c,v 1.136.18.17 2006/11/10 18:51:14 marka Exp $ */

/*! \file */

#include <config.h>

#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include <isc/app.h>
#include <isc/commandline.h>
#include <isc/dir.h>
#include <isc/entropy.h>
#include <isc/file.h>
#include <isc/hash.h>
#include <isc/net.h>
#include <isc/os.h>
#include <isc/platform.h>
#include <isc/privsep.h>
#include <isc/resource.h>
#include <isc/stdio.h>
#include <isc/string.h>
#include <isc/task.h>
#include <isc/timer.h>
#include <isc/util.h>

#include <isccc/result.h>

#include <dns/dispatch.h>
#include <dns/name.h>
#include <dns/result.h>
#include <dns/view.h>

#include <dst/result.h>

/*
 * Defining NS_MAIN provides storage declarations (rather than extern)
 * for variables in named/globals.h.
 */
#define NS_MAIN 1

#include <named/builtin.h>
#include <named/control.h>
#include <named/globals.h>	/* Explicit, though named/log.h includes it. */
#include <named/interfacemgr.h>
#include <named/log.h>
#include <named/os.h>
#include <named/server.h>
#include <named/lwresd.h>
#include <named/main.h>
#ifdef HAVE_LIBSCF
#include <named/ns_smf_globals.h>
#endif

/*
 * Include header files for database drivers here.
 */
/* #include "xxdb.h" */

/*
 * Include DLZ drivers if appropriate.
 */
#ifdef DLZ
#include <dlz/dlz_drivers.h>
#endif

static isc_boolean_t	want_stats = ISC_FALSE;
static char		program_name[ISC_DIR_NAMEMAX] = "named";
static char		absolute_conffile[ISC_DIR_PATHMAX];
static char		saved_command_line[512];
static char		version[512];

void
ns_main_earlywarning(const char *format, ...) {
	va_list args;

	va_start(args, format);
	if (ns_g_lctx != NULL) {
		isc_log_vwrite(ns_g_lctx, NS_LOGCATEGORY_GENERAL,
			       NS_LOGMODULE_MAIN, ISC_LOG_WARNING,
			       format, args);
	} else {
		fprintf(stderr, "%s: ", program_name);
		vfprintf(stderr, format, args);
		fprintf(stderr, "\n");
		fflush(stderr);
	}
	va_end(args);
}

void
ns_main_earlyfatal(const char *format, ...) {
	va_list args;

	va_start(args, format);
	if (ns_g_lctx != NULL) {
		isc_log_vwrite(ns_g_lctx, NS_LOGCATEGORY_GENERAL,
			       NS_LOGMODULE_MAIN, ISC_LOG_CRITICAL,
			       format, args);
		isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL,
			       NS_LOGMODULE_MAIN, ISC_LOG_CRITICAL,
			       "exiting (due to early fatal error)");
	} else {
		fprintf(stderr, "%s: ", program_name);
		vfprintf(stderr, format, args);
		fprintf(stderr, "\n");
		fflush(stderr);
	}
	va_end(args);

	exit(1);
}

static void
assertion_failed(const char *file, int line, isc_assertiontype_t type,
		 const char *cond)
{
	/*
	 * Handle assertion failures.
	 */

	if (ns_g_lctx != NULL) {
		/*
		 * Reset the assetion callback in case it is the log
		 * routines causing the assertion.
		 */
		isc_assertion_setcallback(NULL);

		isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL,
			      NS_LOGMODULE_MAIN, ISC_LOG_CRITICAL,
			      "%s:%d: %s(%s) failed", file, line,
			      isc_assertion_typetotext(type), cond);
		isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL,
			      NS_LOGMODULE_MAIN, ISC_LOG_CRITICAL,
			      "exiting (due to assertion failure)");
	} else {
		fprintf(stderr, "%s:%d: %s(%s) failed\n",
			file, line, isc_assertion_typetotext(type), cond);
		fflush(stderr);
	}

	if (ns_g_coreok)
		abort();
	exit(1);
}

static void
library_fatal_error(const char *file, int line, const char *format,
		    va_list args) ISC_FORMAT_PRINTF(3, 0);

static void
library_fatal_error(const char *file, int line, const char *format,
		    va_list args)
{
	/*
	 * Handle isc_error_fatal() calls from our libraries.
	 */

	if (ns_g_lctx != NULL) {
		/*
		 * Reset the error callback in case it is the log
		 * routines causing the assertion.
		 */
		isc_error_setfatal(NULL);

		isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL,
			      NS_LOGMODULE_MAIN, ISC_LOG_CRITICAL,
			      "%s:%d: fatal error:", file, line);
		isc_log_vwrite(ns_g_lctx, NS_LOGCATEGORY_GENERAL,
			       NS_LOGMODULE_MAIN, ISC_LOG_CRITICAL,
			       format, args);
		isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL,
			      NS_LOGMODULE_MAIN, ISC_LOG_CRITICAL,
			      "exiting (due to fatal error in library)");
	} else {
		fprintf(stderr, "%s:%d: fatal error: ", file, line);
		vfprintf(stderr, format, args);
		fprintf(stderr, "\n");
		fflush(stderr);
	}

	if (ns_g_coreok)
		abort();
	exit(1);
}

static void
library_unexpected_error(const char *file, int line, const char *format,
			 va_list args) ISC_FORMAT_PRINTF(3, 0);

static void
library_unexpected_error(const char *file, int line, const char *format,
			 va_list args)
{
	/*
	 * Handle isc_error_unexpected() calls from our libraries.
	 */

	if (ns_g_lctx != NULL) {
		isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL,
			      NS_LOGMODULE_MAIN, ISC_LOG_ERROR,
			      "%s:%d: unexpected error:", file, line);
		isc_log_vwrite(ns_g_lctx, NS_LOGCATEGORY_GENERAL,
			       NS_LOGMODULE_MAIN, ISC_LOG_ERROR,
			       format, args);
	} else {
		fprintf(stderr, "%s:%d: fatal error: ", file, line);
		vfprintf(stderr, format, args);
		fprintf(stderr, "\n");
		fflush(stderr);
	}
}

static void
lwresd_usage(void) {
	fprintf(stderr,
		"usage: lwresd [-4|-6] [-c conffile | -C resolvconffile] "
		"[-d debuglevel]\n"
		"              [-f|-g] [-n number_of_cpus] [-p port] "
		"[-P listen-port] [-s]\n"
		"              [-t chrootdir] [-u username] [-i pidfile]\n"
		"              [-m {usage|trace|record|size|mctx}]\n");
}

static void
usage(void) {
	if (ns_g_lwresdonly) {
		lwresd_usage();
		return;
	}
	fprintf(stderr,
		"usage: named [-4|-6] [-c conffile] [-d debuglevel] "
		"[-f|-g] [-n number_of_cpus]\n"
		"             [-p port] [-s] [-t chrootdir] [-u username] [-i pidfile]\n"
		"             [-m {usage|trace|record|size|mctx}]\n");
}

static void
save_command_line(int argc, char *argv[]) {
	int i;
	char *src;
	char *dst;
	char *eob;
	const char truncated[] = "...";
	isc_boolean_t quoted = ISC_FALSE;

	dst = saved_command_line;
	eob = saved_command_line + sizeof(saved_command_line);

	for (i = 1; i < argc && dst < eob; i++) {
		*dst++ = ' ';

		src = argv[i];
		while (*src != '\0' && dst < eob) {
			/*
			 * This won't perfectly produce a shell-independent
			 * pastable command line in all circumstances, but
			 * comes close, and for practical purposes will
			 * nearly always be fine.
			 */
			if (quoted || isalnum(*src & 0xff) ||
			    *src == '-' || *src == '_' ||
			    *src == '.' || *src == '/') {
				*dst++ = *src++;
				quoted = ISC_FALSE;
			} else {
				*dst++ = '\\';
				quoted = ISC_TRUE;
			}
		}
	}

	INSIST(sizeof(saved_command_line) >= sizeof(truncated));

	if (dst == eob)
		strlcpy(eob - sizeof(truncated), truncated, sizeof(truncated));
	else
		*dst = '\0';
}

static int
parse_int(char *arg, const char *desc) {
	char *endp;
	int tmp;
	long int ltmp;

	ltmp = strtol(arg, &endp, 10);
	tmp = (int) ltmp;
	if (*endp != '\0')
		ns_main_earlyfatal("%s '%s' must be numeric", desc, arg);
	if (tmp < 0 || tmp != ltmp)
		ns_main_earlyfatal("%s '%s' out of range", desc, arg);
	return (tmp);
}

static struct flag_def {
	const char *name;
	unsigned int value;
} mem_debug_flags[] = {
	{ "trace",  ISC_MEM_DEBUGTRACE },
	{ "record", ISC_MEM_DEBUGRECORD },
	{ "usage", ISC_MEM_DEBUGUSAGE },
	{ "size", ISC_MEM_DEBUGSIZE },
	{ "mctx", ISC_MEM_DEBUGCTX },
	{ NULL, 0 }
};

static void
set_flags(const char *arg, struct flag_def *defs, unsigned int *ret) {
	for (;;) {
		const struct flag_def *def;
		const char *end = strchr(arg, ',');
		int arglen;
		if (end == NULL)
			end = arg + strlen(arg);
		arglen = end - arg;
		for (def = defs; def->name != NULL; def++) {
			if (arglen == (int)strlen(def->name) &&
			    memcmp(arg, def->name, arglen) == 0) {
				*ret |= def->value;
				goto found;
			}
		}
		ns_main_earlyfatal("unrecognized flag '%.*s'", arglen, arg);
	 found:
		if (*end == '\0')
			break;
		arg = end + 1;
	}
}

static void
parse_command_line(int argc, char *argv[]) {
	int ch;
	int port;
	isc_boolean_t disable6 = ISC_FALSE;
	isc_boolean_t disable4 = ISC_FALSE;

	save_command_line(argc, argv);

	isc_commandline_errprint = ISC_FALSE;
	while ((ch = isc_commandline_parse(argc, argv,
			           "46c:C:d:fgi:lm:n:N:p:P:st:u:vx:")) != -1) {
		switch (ch) {
		case '4':
			if (disable4)
				ns_main_earlyfatal("cannot specify -4 and -6");
			if (isc_net_probeipv4() != ISC_R_SUCCESS)
				ns_main_earlyfatal("IPv4 not supported by OS");
			isc_net_disableipv6();
			disable6 = ISC_TRUE;
			break;
		case '6':
			if (disable6)
				ns_main_earlyfatal("cannot specify -4 and -6");
			if (isc_net_probeipv6() != ISC_R_SUCCESS)
				ns_main_earlyfatal("IPv6 not supported by OS");
			isc_net_disableipv4();
			disable4 = ISC_TRUE;
			break;
		case 'c':
			ns_g_conffile = isc_commandline_argument;
			lwresd_g_conffile = isc_commandline_argument;
			if (lwresd_g_useresolvconf)
				ns_main_earlyfatal("cannot specify -c and -C");
			ns_g_conffileset = ISC_TRUE;
			break;
		case 'C':
			lwresd_g_resolvconffile = isc_commandline_argument;
			if (ns_g_conffileset)
				ns_main_earlyfatal("cannot specify -c and -C");
			lwresd_g_useresolvconf = ISC_TRUE;
			break;
		case 'd':
			ns_g_debuglevel = parse_int(isc_commandline_argument,
						    "debug level");
			break;
		case 'f':
			ns_g_foreground = ISC_TRUE;
			break;
		case 'g':
			ns_g_foreground = ISC_TRUE;
			ns_g_logstderr = ISC_TRUE;
			break;
		case 'i':
			ns_g_pidfile = isc_commandline_argument;
			break;
		case 'l':
			ns_g_lwresdonly = ISC_TRUE;
			break;
		case 'm':
			set_flags(isc_commandline_argument, mem_debug_flags,
				  &isc_mem_debugging);
			break;
		case 'N': /* Deprecated. */
		case 'n':
			ns_g_cpus = parse_int(isc_commandline_argument,
					      "number of cpus");
			if (ns_g_cpus == 0)
				ns_g_cpus = 1;
			break;
		case 'p':
			port = parse_int(isc_commandline_argument, "port");
			if (port < 1 || port > 65535)
				ns_main_earlyfatal("port '%s' out of range",
						   isc_commandline_argument);
			ns_g_port = port;
			break;
		/* XXXBEW Should -P be removed? */
		case 'P':
			port = parse_int(isc_commandline_argument, "port");
			if (port < 1 || port > 65535)
				ns_main_earlyfatal("port '%s' out of range",
						   isc_commandline_argument);
			lwresd_g_listenport = port;
			break;
		case 's':
			/* XXXRTH temporary syntax */
			want_stats = ISC_TRUE;
			break;
		case 't':
			/* XXXJAB should we make a copy? */
			ns_g_chrootdir = isc_commandline_argument;
			break;
		case 'u':
			ns_g_username = isc_commandline_argument;
			break;
		case 'v':
			printf("BIND %s\n", ns_g_version);
			exit(0);
		case '?':
			usage();
			ns_main_earlyfatal("unknown option '-%c'",
					   isc_commandline_option);
		default:
			ns_main_earlyfatal("parsing options returned %d", ch);
		}
	}

	argc -= isc_commandline_index;
	argv += isc_commandline_index;

	if (argc > 0) {
		usage();
		ns_main_earlyfatal("extra command line arguments");
	}
}

static isc_result_t
create_managers(void) {
	isc_result_t result;
#ifdef ISC_PLATFORM_USETHREADS
	unsigned int cpus_detected;
#endif

#ifdef ISC_PLATFORM_USETHREADS
	cpus_detected = isc_os_ncpus();
	if (ns_g_cpus == 0)
		ns_g_cpus = cpus_detected;
	isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL, NS_LOGMODULE_SERVER,
		      ISC_LOG_INFO, "found %u CPU%s, using %u worker thread%s",
		      cpus_detected, cpus_detected == 1 ? "" : "s",
		      ns_g_cpus, ns_g_cpus == 1 ? "" : "s");
#else
	ns_g_cpus = 1;
#endif
	result = isc_taskmgr_create(ns_g_mctx, ns_g_cpus, 0, &ns_g_taskmgr);
	if (result != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "isc_taskmgr_create() failed: %s",
				 isc_result_totext(result));
		return (ISC_R_UNEXPECTED);
	}

	result = isc_timermgr_create(ns_g_mctx, &ns_g_timermgr);
	if (result != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "isc_timermgr_create() failed: %s",
				 isc_result_totext(result));
		return (ISC_R_UNEXPECTED);
	}

	result = isc_socketmgr_create(ns_g_mctx, &ns_g_socketmgr);
	if (result != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "isc_socketmgr_create() failed: %s",
				 isc_result_totext(result));
		return (ISC_R_UNEXPECTED);
	}

	result = isc_entropy_create(ns_g_mctx, &ns_g_entropy);
	if (result != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "isc_entropy_create() failed: %s",
				 isc_result_totext(result));
		return (ISC_R_UNEXPECTED);
	}

	result = isc_hash_create(ns_g_mctx, ns_g_entropy, DNS_NAME_MAXWIRE);
	if (result != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "isc_hash_create() failed: %s",
				 isc_result_totext(result));
		return (ISC_R_UNEXPECTED);
	}

	return (ISC_R_SUCCESS);
}

static void
destroy_managers(void) {
	ns_lwresd_shutdown();

	isc_entropy_detach(&ns_g_entropy);
	if (ns_g_fallbackentropy != NULL)
		isc_entropy_detach(&ns_g_fallbackentropy);

	/*
	 * isc_taskmgr_destroy() will block until all tasks have exited,
	 */
	isc_taskmgr_destroy(&ns_g_taskmgr);
	isc_timermgr_destroy(&ns_g_timermgr);
	isc_socketmgr_destroy(&ns_g_socketmgr);

	/*
	 * isc_hash_destroy() cannot be called as long as a resolver may be
	 * running.  Calling this after isc_taskmgr_destroy() ensures the
	 * call is safe.
	 */
	isc_hash_destroy();
}

static void
setup(void) {
	isc_result_t result;
#ifdef HAVE_LIBSCF
	char *instance = NULL;
#endif

        /*
	 * Write pidfile before chroot if specified on the command line
	 */
	if (ns_g_pidfile != NULL)
		ns_os_preopenpidfile(ns_g_pidfile);

	/*
	 * Get the user and group information before changing the root
	 * directory, so the administrator does not need to keep a copy
	 * of the user and group databases in the chroot'ed environment.
	 */
	ns_os_inituserinfo(ns_g_username);

	/*
	 * Initialize time conversion information
	 */
	ns_os_tzset();

	ns_os_opendevnull();

#ifdef HAVE_LIBSCF
	/* Check if named is under smf control, before chroot. */
	result = ns_smf_get_instance(&instance, 0, ns_g_mctx);
	/* We don't care about instance, just check if we got one. */
	if (result == ISC_R_SUCCESS)
		ns_smf_got_instance = 1;
	else
		ns_smf_got_instance = 0;
	if (instance != NULL)
		isc_mem_free(ns_g_mctx, instance);
#endif /* HAVE_LIBSCF */

#ifdef PATH_RANDOMDEV
	/*
	 * Initialize system's random device as fallback entropy source
	 * if running chroot'ed.
	 */
	if (1) { /* Always chroot due to privsep */
		result = isc_entropy_create(ns_g_mctx, &ns_g_fallbackentropy);
		if (result != ISC_R_SUCCESS)
			ns_main_earlyfatal("isc_entropy_create() failed: %s",
					   isc_result_totext(result));

		result = isc_entropy_createfilesource(ns_g_fallbackentropy,
						      PATH_RANDOMDEV);
		if (result != ISC_R_SUCCESS) {
			ns_main_earlywarning("could not open pre-chroot "
					     "entropy source %s: %s",
					     PATH_RANDOMDEV,
					     isc_result_totext(result));
			isc_entropy_detach(&ns_g_fallbackentropy);
		}
	}
#endif

#if 0	/* Not used due to privsep */
	ns_os_chroot(ns_g_chrootdir);
#endif

	/*
	 * For operating systems which have a capability mechanism, now
	 * is the time to switch to minimal privs and change our user id.
	 * On traditional UNIX systems, this call will be a no-op, and we
	 * will change the user ID after reading the config file the first
	 * time.  (We need to read the config file to know which possibly
	 * privileged ports to bind() to.)
	 */
	ns_os_minprivs();

	result = ns_log_init(ISC_TF(ns_g_username != NULL));
	if (result != ISC_R_SUCCESS)
		ns_main_earlyfatal("ns_log_init() failed: %s",
				   isc_result_totext(result));

	/*
	 * Now is the time to daemonize (if we're not running in the
	 * foreground).  We waited until now because we wanted to get
	 * a valid logging context setup.  We cannot daemonize any later,
	 * because calling create_managers() will create threads, which
	 * would be lost after fork().
	 */
	if (!ns_g_foreground)
		ns_os_daemonize();

	/*
	 * Privilege separation
	 */
	isc_priv_init(ns_g_logstderr);
	isc_drop_privs(ns_g_username, ns_g_chrootdir);
	isc_socket_privsep(1);

	/* process is now unprivileged and inside a chroot */

	/*
	 * We call isc_app_start() here as some versions of FreeBSD's fork()
	 * destroys all the signal handling it sets up.
	 */
	result = isc_app_start();
	if (result != ISC_R_SUCCESS)
		ns_main_earlyfatal("isc_app_start() failed: %s",
				   isc_result_totext(result));

	isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL, NS_LOGMODULE_MAIN,
		      ISC_LOG_NOTICE, "starting BIND %s%s", ns_g_version,
		      saved_command_line);

	/*
	 * Get the initial resource limits.
	 */
	(void)isc_resource_getlimit(isc_resource_stacksize,
				    &ns_g_initstacksize);
	(void)isc_resource_getlimit(isc_resource_datasize,
				    &ns_g_initdatasize);
	(void)isc_resource_getlimit(isc_resource_coresize,
				    &ns_g_initcoresize);
	(void)isc_resource_getlimit(isc_resource_openfiles,
				    &ns_g_initopenfiles);

	/*
	 * If the named configuration filename is relative, prepend the current
	 * directory's name before possibly changing to another directory.
	 */
	if (! isc_file_isabsolute(ns_g_conffile)) {
		result = isc_file_absolutepath(ns_g_conffile,
					       absolute_conffile,
					       sizeof(absolute_conffile));
		if (result != ISC_R_SUCCESS)
			ns_main_earlyfatal("could not construct absolute path of "
					   "configuration file: %s", 
					   isc_result_totext(result));
		ns_g_conffile = absolute_conffile;
	}

	result = create_managers();
	if (result != ISC_R_SUCCESS)
		ns_main_earlyfatal("create_managers() failed: %s",
				   isc_result_totext(result));

	ns_builtin_init();

	/*
	 * Add calls to register sdb drivers here.
	 */
	/* xxdb_init(); */

#ifdef DLZ
	/*
	 * Registyer any DLZ drivers.
	 */
	result = dlz_drivers_init();
	if (result != ISC_R_SUCCESS)
		ns_main_earlyfatal("dlz_drivers_init() failed: %s",
				   isc_result_totext(result));
#endif

	ns_server_create(ns_g_mctx, &ns_g_server);
}

static void
cleanup(void) {
	destroy_managers();

	ns_server_destroy(&ns_g_server);

	ns_builtin_deinit();

	/*
	 * Add calls to unregister sdb drivers here.
	 */
	/* xxdb_clear(); */

#ifdef DLZ
	/*
	 * Unregister any DLZ drivers.
	 */
	dlz_drivers_clear();
#endif

	dns_name_destroy();

	isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL, NS_LOGMODULE_MAIN,
		      ISC_LOG_NOTICE, "exiting");
	ns_log_shutdown();
}

static char *memstats = NULL;

void
ns_main_setmemstats(const char *filename) {
	/*
	 * Caller has to ensure locking.
	 */

	if (memstats != NULL) {
		free(memstats);
		memstats = NULL;
	}
	if (filename == NULL)
		return;
	memstats = malloc(strlen(filename) + 1);
	if (memstats)
		strlcpy(memstats, filename, strlen(filename) + 1);
}

#ifdef HAVE_LIBSCF
/*
 * Get FMRI for the named process.
 */
isc_result_t
ns_smf_get_instance(char **ins_name, int debug, isc_mem_t *mctx) {
	scf_handle_t *h = NULL;
	int namelen;
	char *instance;

	REQUIRE(ins_name != NULL && *ins_name == NULL);

	if ((h = scf_handle_create(SCF_VERSION)) == NULL) {
		if (debug)
			UNEXPECTED_ERROR(__FILE__, __LINE__,
					 "scf_handle_create() failed: %s",
			 		 scf_strerror(scf_error()));
		return (ISC_R_FAILURE);
	}

	if (scf_handle_bind(h) == -1) {
		if (debug)
			UNEXPECTED_ERROR(__FILE__, __LINE__,
					 "scf_handle_bind() failed: %s",
					 scf_strerror(scf_error()));
		scf_handle_destroy(h);
		return (ISC_R_FAILURE);
	}

	if ((namelen = scf_myname(h, NULL, 0)) == -1) {
		if (debug)
			UNEXPECTED_ERROR(__FILE__, __LINE__,
					 "scf_myname() failed: %s",
					 scf_strerror(scf_error()));
		scf_handle_destroy(h);
		return (ISC_R_FAILURE);
	}

	if ((instance = isc_mem_allocate(mctx, namelen + 1)) == NULL) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "ns_smf_get_instance memory "
				 "allocation failed: %s",
				 isc_result_totext(ISC_R_NOMEMORY));
		scf_handle_destroy(h);
		return (ISC_R_FAILURE);
	}

	if (scf_myname(h, instance, namelen + 1) == -1) {
		if (debug)
			UNEXPECTED_ERROR(__FILE__, __LINE__,
					 "scf_myname() failed: %s",
					 scf_strerror(scf_error()));
		scf_handle_destroy(h);
		isc_mem_free(mctx, instance);
		return (ISC_R_FAILURE);
	}

	scf_handle_destroy(h);
	*ins_name = instance;
	return (ISC_R_SUCCESS);
}
#endif /* HAVE_LIBSCF */

int
main(int argc, char *argv[]) {
	isc_result_t result;
#ifdef HAVE_LIBSCF
	char *instance = NULL;
#endif

	/*
	 * Record version in core image.
	 * strings named.core | grep "named version:"
	 */
	strlcat(version,
		"named version: BIND " VERSION,
		sizeof(version));
	result = isc_file_progname(*argv, program_name, sizeof(program_name));
	if (result != ISC_R_SUCCESS)
		ns_main_earlyfatal("program name too long");

	if (strcmp(program_name, "lwresd") == 0)
		ns_g_lwresdonly = ISC_TRUE;

	isc_assertion_setcallback(assertion_failed);
	isc_error_setfatal(library_fatal_error);
	isc_error_setunexpected(library_unexpected_error);

	ns_os_init(program_name);

	dns_result_register();
	dst_result_register();
	isccc_result_register();

	parse_command_line(argc, argv);

	/*
	 * Warn about common configuration error.
	 */
	if (ns_g_chrootdir != NULL) {
		int len = strlen(ns_g_chrootdir);
		if (strncmp(ns_g_chrootdir, ns_g_conffile, len) == 0 &&
		    (ns_g_conffile[len] == '/' || ns_g_conffile[len] == '\\'))
			ns_main_earlywarning("config filename (-c %s) contains "
					     "chroot path (-t %s)",
					     ns_g_conffile, ns_g_chrootdir);
	}

	result = isc_mem_create(0, 0, &ns_g_mctx);
	if (result != ISC_R_SUCCESS)
		ns_main_earlyfatal("isc_mem_create() failed: %s",
				   isc_result_totext(result));

	setup();

	/*
	 * Start things running and then wait for a shutdown request
	 * or reload.
	 */
	do {
		result = isc_app_run();

		if (result == ISC_R_RELOAD) {
			ns_server_reloadwanted(ns_g_server);
		} else if (result != ISC_R_SUCCESS) {
			UNEXPECTED_ERROR(__FILE__, __LINE__,
					 "isc_app_run(): %s",
					 isc_result_totext(result));
			/*
			 * Force exit.
			 */
			result = ISC_R_SUCCESS;
		}
	} while (result != ISC_R_SUCCESS);

#ifdef HAVE_LIBSCF
	if (ns_smf_want_disable == 1) {
		result = ns_smf_get_instance(&instance, 1, ns_g_mctx);
		if (result == ISC_R_SUCCESS && instance != NULL) {
			if (smf_disable_instance(instance, 0) != 0)
				UNEXPECTED_ERROR(__FILE__, __LINE__,
						 "smf_disable_instance() "
						 "failed for %s : %s",
						 instance,
						 scf_strerror(scf_error()));
		}
		if (instance != NULL)
			isc_mem_free(ns_g_mctx, instance);
	}
#endif /* HAVE_LIBSCF */

	cleanup();

	if (want_stats) {
		isc_mem_stats(ns_g_mctx, stdout);
		isc_mutex_stats(stdout);
	}
	if (memstats != NULL) {
		FILE *fp = NULL;
		result = isc_stdio_open(memstats, "w", &fp);
		if (result == ISC_R_SUCCESS) {
			isc_mem_stats(ns_g_mctx, fp);
			isc_mutex_stats(fp);
			isc_stdio_close(fp);
		}
	}
	isc_mem_destroy(&ns_g_mctx);
	isc_mem_checkdestroyed(stderr);

	ns_main_setmemstats(NULL);

	isc_app_finish();

	ns_os_closedevnull();

	ns_os_shutdown();

	return (0);
}
@


1.18
log
@Add missing #includes instead of assuming that some system header pulls in
the needed bits

ok deraadt@@, millert@@
@
text
@@


1.17
log
@resolve conflicts
@
text
@d34 1
@


1.16
log
@resolve conflicts and regen configure script
@
text
@d18 3
a20 1
/* $ISC: main.c,v 1.119.2.3.2.25 2006/11/10 18:51:06 marka Exp $ */
d77 7
d239 1
a239 1
		"              [-m {usage|trace|record}]\n");
d252 1
a252 1
		"             [-m {usage|trace|record}]\n");
d320 2
d702 10
d728 9
d928 1
@


1.15
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: main.c,v 1.119.2.3.2.22 2005/04/29 01:04:47 marka Exp $ */
d476 1
a476 1
				 "ns_taskmgr_create() failed: %s",
d484 1
a484 1
				 "ns_timermgr_create() failed: %s",
d872 1
a872 1
						 "smf_disable_instance() ",
@


1.14
log
@since we chroot by default, always init fallback entropy source
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: main.c,v 1.119.2.3.2.17 2004/10/25 00:42:54 marka Exp $ */
a50 4
#ifdef HAVE_LIBSCF
#include <libscf.h>
#endif

d66 3
d542 3
d566 12
d733 1
a733 1
 * Get FMRI for the current named process
d735 2
a736 2
static char *
scf_get_ins_name(void) {
d739 3
a741 1
	char *ins_name;
d744 5
a748 4
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "scf_handle_create() failed: %s",
				 scf_strerror(scf_error()));
		return (NULL);
d752 4
a755 3
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "scf_handle_bind() failed: %s",
				 scf_strerror(scf_error()));
d757 1
a757 1
		return (NULL);
d761 4
a764 4
		isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL,
			      NS_LOGMODULE_MAIN, ISC_LOG_INFO,
			      "scf_myname() failed: %s",
			      scf_strerror(scf_error()));
d766 1
a766 1
		return (NULL);
d769 1
a769 1
	if ((ins_name = malloc(namelen + 1)) == NULL) {
d771 1
a771 1
				 "scf_get_ins_named() memory "
d775 1
a775 1
		return (NULL);
d778 5
a782 4
	if (scf_myname(h, ins_name, namelen + 1) == -1) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "scf_myname() failed: %s",
				 scf_strerror(scf_error()));
d784 2
a785 2
		free(ins_name);
		return (NULL);
d789 2
a790 29
	isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL, NS_LOGMODULE_MAIN,
		      ISC_LOG_INFO, "instance name:%s", ins_name);

	return (ins_name);
}

static void
scf_cleanup(void) {
	char *s;
	char *ins_name;

	if ((ins_name = scf_get_ins_name()) != NULL) {
		if ((s = smf_get_state(ins_name)) != NULL) {
			if ((strcmp(SCF_STATE_STRING_ONLINE, s) == 0) ||
			    (strcmp(SCF_STATE_STRING_DEGRADED, s) == 0)) {
				if (smf_disable_instance(ins_name, 0) != 0) {
				    UNEXPECTED_ERROR(__FILE__, __LINE__,
					"smf_disable_instance() failed: %s",
					scf_strerror(scf_error()));
				}
			}
			free(s);
		} else {
			UNEXPECTED_ERROR(__FILE__, __LINE__,
					 "smf_get_state() failed: %s",
					 scf_strerror(scf_error()));
		}
		free(ins_name);
	}
d792 1
a792 1
#endif
d797 3
d867 14
a880 2
	scf_cleanup();
#endif
@


1.13
log
@resolve conflicts
@
text
@d569 1
a569 1
	if (ns_g_chrootdir != NULL) {
@


1.12
log
@zap compilation date from the binary; ok millert@@ deraadt@@
@
text
@d18 1
a18 1
/* $ISC: main.c,v 1.119.2.3.2.16 2004/09/01 07:16:35 marka Exp $ */
d625 9
a824 5

	result = isc_app_start();
	if (result != ISC_R_SUCCESS)
		ns_main_earlyfatal("isc_app_start() failed: %s",
				   isc_result_totext(result));
@


1.11
log
@unbreak -t; ok jakob, henning
@
text
@a801 3
#ifdef __DATE__
		"named version: BIND " VERSION " (" __DATE__ ")",
#else
a802 1
#endif
@


1.10
log
@resolve conflicts
@
text
@d620 1
a620 1
	isc_drop_privs(ns_g_username);
@


1.9
log
@Privilege seperation for named. Allows named to handle address/interface
changes without restart. If you use non-standard ports in named configuration
make sure they are > 1024. Also /var/named/etc/rndc.key (if any) must be
readable by group named.

Initial work and testing by itojun@@, jakob@@, hints, help from henning@@,
avsm@@, beck@@. ok henning, beck, avsm, deraadt
@
text
@d2 1
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: main.c,v 1.119.2.5 2003/10/09 07:32:33 marka Exp $ */
d36 2
d51 4
d61 1
d79 2
a80 1
static char    		saved_command_line[512];
d226 3
a228 3
		"usage: lwresd [-c conffile | -C resolvconffile] "
		"[-d debuglevel] [-f|-g]\n"
		"              [-n number_of_cpus] [-p port]"
d230 2
a231 1
		"              [-t chrootdir] [-u username] [-i pidfile]\n");
d241 1
a241 1
		"usage: named [-c conffile] [-d debuglevel] "
d243 2
a244 1
		"             [-p port] [-s] [-t chrootdir] [-u username] [-i pidfile]\n");
d305 34
d343 2
d350 1
a350 2
					   "c:C:d:fgi:ln:N:p:P:st:u:vx:")) !=
	       -1) {
d352 16
d398 4
a453 2

	
d459 3
d464 1
d466 5
a470 1
		ns_g_cpus = isc_os_ncpus();
a473 3
	isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL, NS_LOGMODULE_SERVER,
		      ISC_LOG_INFO, "using %u CPU%s",
		      ns_g_cpus, ns_g_cpus == 1 ? "" : "s");
d522 1
a522 1
	if (ns_g_fallbackentropy != NULL) {
d524 1
a524 1
	}
d558 1
a558 1
	 * Initialize time conversion information and /dev/null
d561 1
d564 1
a568 5
	result = isc_entropy_create(ns_g_mctx, &ns_g_fallbackentropy);
	if (result != ISC_R_SUCCESS)
		ns_main_earlyfatal("isc_entropy_create() failed: %s",
				   isc_result_totext(result));
#ifdef PATH_RANDOMDEV
d570 5
d577 1
a577 1
		if (result != ISC_R_SUCCESS)
d582 2
d661 2
d677 2
d689 104
d797 11
a825 5
	result = isc_mem_create(0, 0, &ns_g_mctx);
	if (result != ISC_R_SUCCESS)
		ns_main_earlyfatal("isc_mem_create() failed: %s",
				   isc_result_totext(result));

d832 17
d871 4
d881 9
d891 2
@


1.8
log
@update to BIND v9.2.3. ok todd@@
@
text
@d34 1
d515 1
d517 1
d543 9
@


1.7
log
@more snprintf and strlcpy/strlcat fixes. from todd@@ and tedu@@.
@
text
@d2 1
a2 1
 * Copyright (C) 1999-2002  Internet Software Consortium.
d18 1
a18 1
/* $ISC: main.c,v 1.119.2.2 2002/08/05 06:57:01 marka Exp $ */
d31 1
d42 1
d437 8
d462 7
@


1.6
log
@write pid-file before chroot (also specifiable via -i on the command line).
@
text
@d272 1
a272 1
		strcpy(eob - sizeof(truncated), truncated);
@


1.5
log
@fall back to system random device if chroot
@
text
@d231 1
a231 1
		"             [-p port] [-s] [-t chrootdir] [-u username]\n");
a327 1
		/* XXXBEW -i should be removed */
d329 1
a329 1
			lwresd_g_defaultpidfile = isc_commandline_argument;
d457 6
@


1.4
log
@close /dev/null on shutdown
@
text
@d444 3
d471 20
@


1.3
log
@open /dev/null before chroot
@
text
@d621 2
@


1.2
log
@call tzset() before chroot
@
text
@d464 1
a464 1
	 * Initialize time conversion information
d467 1
@


1.1
log
@Initial revision
@
text
@d463 5
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 1999-2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: main.c,v 1.119.2.3.2.16 2004/09/01 07:16:35 marka Exp $ */
a30 1
#include <isc/hash.h>
a33 2
#include <isc/stdio.h>
#include <isc/string.h>
a40 1
#include <dns/name.h>
a45 4
#ifdef HAVE_LIBSCF
#include <libscf.h>
#endif

a51 1
#include <named/builtin.h>
d69 1
a69 2
static char		saved_command_line[512];
static char		version[512];
d215 3
a217 3
		"usage: lwresd [-4|-6] [-c conffile | -C resolvconffile] "
		"[-d debuglevel]\n"
		"              [-f|-g] [-n number_of_cpus] [-p port] "
d219 1
a219 2
		"              [-t chrootdir] [-u username] [-i pidfile]\n"
		"              [-m {usage|trace|record}]\n");
d229 1
a229 1
		"usage: named [-4|-6] [-c conffile] [-d debuglevel] "
d231 1
a231 2
		"             [-p port] [-s] [-t chrootdir] [-u username]\n"
		"             [-m {usage|trace|record}]\n");
a291 34
static struct flag_def {
	const char *name;
	unsigned int value;
} mem_debug_flags[] = {
	{ "trace",  ISC_MEM_DEBUGTRACE },
	{ "record", ISC_MEM_DEBUGRECORD },
	{ "usage", ISC_MEM_DEBUGUSAGE },
	{ NULL, 0 }
};

static void
set_flags(const char *arg, struct flag_def *defs, unsigned int *ret) {
	for (;;) {
		const struct flag_def *def;
		const char *end = strchr(arg, ',');
		int arglen;
		if (end == NULL)
			end = arg + strlen(arg);
		arglen = end - arg;
		for (def = defs; def->name != NULL; def++) {
			if (arglen == (int)strlen(def->name) &&
			    memcmp(arg, def->name, arglen) == 0) {
				*ret |= def->value;
				goto found;
			}
		}
		ns_main_earlyfatal("unrecognized flag '%.*s'", arglen, arg);
	 found:
		if (*end == '\0')
			break;
		arg = end + 1;
	}
}

a295 2
	isc_boolean_t disable6 = ISC_FALSE;
	isc_boolean_t disable4 = ISC_FALSE;
d301 2
a302 1
			           "46c:C:d:fgi:lm:n:N:p:P:st:u:vx:")) != -1) {
a303 16
		case '4':
			if (disable4)
				ns_main_earlyfatal("cannot specify -4 and -6");
			if (isc_net_probeipv4() != ISC_R_SUCCESS)
				ns_main_earlyfatal("IPv4 not supported by OS");
			isc_net_disableipv6();
			disable6 = ISC_TRUE;
			break;
		case '6':
			if (disable6)
				ns_main_earlyfatal("cannot specify -4 and -6");
			if (isc_net_probeipv6() != ISC_R_SUCCESS)
				ns_main_earlyfatal("IPv6 not supported by OS");
			isc_net_disableipv4();
			disable4 = ISC_TRUE;
			break;
a334 4
		case 'm':
			set_flags(isc_commandline_argument, mem_debug_flags,
				  &isc_mem_debugging);
			break;
d387 2
a393 3
#ifdef ISC_PLATFORM_USETHREADS
	unsigned int cpus_detected;
#endif
a395 1
	cpus_detected = isc_os_ncpus();
d397 1
a397 5
		ns_g_cpus = cpus_detected;
	isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL, NS_LOGMODULE_SERVER,
		      ISC_LOG_INFO, "found %u CPU%s, using %u worker thread%s",
		      cpus_detected, cpus_detected == 1 ? "" : "s",
		      ns_g_cpus, ns_g_cpus == 1 ? "" : "s");
d401 3
a435 8
	result = isc_hash_create(ns_g_mctx, ns_g_entropy, DNS_NAME_MAXWIRE);
	if (result != ISC_R_SUCCESS) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "isc_hash_create() failed: %s",
				 isc_result_totext(result));
		return (ISC_R_UNEXPECTED);
	}

a443 3
	if (ns_g_fallbackentropy != NULL)
		isc_entropy_detach(&ns_g_fallbackentropy);

a449 7

	/*
	 * isc_hash_destroy() cannot be called as long as a resolver may be
	 * running.  Calling this after isc_taskmgr_destroy() ensures the
	 * call is safe.
	 */
	isc_hash_destroy();
a462 30
	/*
	 * Initialize time conversion information
	 */
	ns_os_tzset();

	ns_os_opendevnull();

#ifdef PATH_RANDOMDEV
	/*
	 * Initialize system's random device as fallback entropy source
	 * if running chroot'ed.
	 */
	if (ns_g_chrootdir != NULL) {
		result = isc_entropy_create(ns_g_mctx, &ns_g_fallbackentropy);
		if (result != ISC_R_SUCCESS)
			ns_main_earlyfatal("isc_entropy_create() failed: %s",
					   isc_result_totext(result));

		result = isc_entropy_createfilesource(ns_g_fallbackentropy,
						      PATH_RANDOMDEV);
		if (result != ISC_R_SUCCESS) {
			ns_main_earlywarning("could not open pre-chroot "
					     "entropy source %s: %s",
					     PATH_RANDOMDEV,
					     isc_result_totext(result));
			isc_entropy_detach(&ns_g_fallbackentropy);
		}
	}
#endif

a525 2
	ns_builtin_init();

a539 2
	ns_builtin_deinit();

a549 104
static char *memstats = NULL;

void
ns_main_setmemstats(const char *filename) {
	/*
	 * Caller has to ensure locking.
	 */

	if (memstats != NULL) {
		free(memstats);
		memstats = NULL;
	}
	if (filename == NULL)
		return;
	memstats = malloc(strlen(filename) + 1);
	if (memstats)
		strcpy(memstats, filename);
}

#ifdef HAVE_LIBSCF
/*
 * Get FMRI for the current named process
 */
static char *
scf_get_ins_name(void) {
	scf_handle_t *h = NULL;
	int namelen;
	char *ins_name;

	if ((h = scf_handle_create(SCF_VERSION)) == NULL) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "scf_handle_create() failed: %s",
				 scf_strerror(scf_error()));
		return (NULL);
	}

	if (scf_handle_bind(h) == -1) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "scf_handle_bind() failed: %s",
				 scf_strerror(scf_error()));
		scf_handle_destroy(h);
		return (NULL);
	}

	if ((namelen = scf_myname(h, NULL, 0)) == -1) {
		isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL,
			      NS_LOGMODULE_MAIN, ISC_LOG_INFO,
			      "scf_myname() failed: %s",
			      scf_strerror(scf_error()));
		scf_handle_destroy(h);
		return (NULL);
	}

	if ((ins_name = malloc(namelen + 1)) == NULL) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "scf_get_ins_named() memory "
				 "allocation failed: %s",
				 isc_result_totext(ISC_R_NOMEMORY));
		scf_handle_destroy(h);
		return (NULL);
	}

	if (scf_myname(h, ins_name, namelen + 1) == -1) {
		UNEXPECTED_ERROR(__FILE__, __LINE__,
				 "scf_myname() failed: %s",
				 scf_strerror(scf_error()));
		scf_handle_destroy(h);
		free(ins_name);
		return (NULL);
	}

	scf_handle_destroy(h);
	isc_log_write(ns_g_lctx, NS_LOGCATEGORY_GENERAL, NS_LOGMODULE_MAIN,
		      ISC_LOG_INFO, "instance name:%s", ins_name);

	return (ins_name);
}

static void
scf_cleanup(void) {
	char *s;
	char *ins_name;

	if ((ins_name = scf_get_ins_name()) != NULL) {
		if ((s = smf_get_state(ins_name)) != NULL) {
			if ((strcmp(SCF_STATE_STRING_ONLINE, s) == 0) ||
			    (strcmp(SCF_STATE_STRING_DEGRADED, s) == 0)) {
				if (smf_disable_instance(ins_name, 0) != 0) {
				    UNEXPECTED_ERROR(__FILE__, __LINE__,
					"smf_disable_instance() failed: %s",
					scf_strerror(scf_error()));
				}
			}
			free(s);
		} else {
			UNEXPECTED_ERROR(__FILE__, __LINE__,
					 "smf_get_state() failed: %s",
					 scf_strerror(scf_error()));
		}
		free(ins_name);
	}
}
#endif

a553 11
	/*
	 * Record version in core image.
	 * strings named.core | grep "named version:"
	 */
	strlcat(version,
#ifdef __DATE__
		"named version: BIND " VERSION " (" __DATE__ ")",
#else
		"named version: BIND " VERSION,
#endif
		sizeof(version));
d572 5
a582 17
	/*
	 * Warn about common configuration error.
	 */
	if (ns_g_chrootdir != NULL) {
		int len = strlen(ns_g_chrootdir);
		if (strncmp(ns_g_chrootdir, ns_g_conffile, len) == 0 &&
		    (ns_g_conffile[len] == '/' || ns_g_conffile[len] == '\\'))
			ns_main_earlywarning("config filename (-c %s) contains "
					     "chroot path (-t %s)",
					     ns_g_conffile, ns_g_chrootdir);
	}

	result = isc_mem_create(0, 0, &ns_g_mctx);
	if (result != ISC_R_SUCCESS)
		ns_main_earlyfatal("isc_mem_create() failed: %s",
				   isc_result_totext(result));

a604 4
#ifdef HAVE_LIBSCF
	scf_cleanup();
#endif

a610 9
	if (memstats != NULL) {
		FILE *fp = NULL;
		result = isc_stdio_open(memstats, "w", &fp);
		if (result == ISC_R_SUCCESS) {
			isc_mem_stats(ns_g_mctx, fp);
			isc_mutex_stats(fp);
			isc_stdio_close(fp);
		}
	}
a612 2
	ns_main_setmemstats(NULL);

a613 2

	ns_os_closedevnull();
@


1.1.1.3
log
@ISC BIND release 9.3.1. ok deraadt@@
@
text
@d18 1
a18 1
/* $ISC: main.c,v 1.119.2.3.2.17 2004/10/25 00:42:54 marka Exp $ */
a607 9
	/*
	 * We call isc_app_start() here as some versions of FreeBSD's fork()
	 * destroys all the signal handling it sets up.
	 */
	result = isc_app_start();
	if (result != ISC_R_SUCCESS)
		ns_main_earlyfatal("isc_app_start() failed: %s",
				   isc_result_totext(result));

d803 5
@


1.1.1.4
log
@ISC BIND release 9.3.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: main.c,v 1.119.2.3.2.22 2005/04/29 01:04:47 marka Exp $ */
d50 4
a68 3
#ifdef HAVE_LIBSCF
#include <named/ns_smf_globals.h>
#endif
a542 3
#ifdef HAVE_LIBSCF
	char *instance = NULL;
#endif
a557 12
#ifdef HAVE_LIBSCF
	/* Check if named is under smf control, before chroot. */
	result = ns_smf_get_instance(&instance, 0, ns_g_mctx);
	/* We don't care about instance, just check if we got one. */
	if (result == ISC_R_SUCCESS)
		ns_smf_got_instance = 1;
	else
		ns_smf_got_instance = 0;
	if (instance != NULL)
		isc_mem_free(ns_g_mctx, instance);
#endif /* HAVE_LIBSCF */

d702 1
a702 1
 * Get FMRI for the named process.
d704 2
a705 2
isc_result_t
ns_smf_get_instance(char **ins_name, int debug, isc_mem_t *mctx) {
d708 1
a708 3
	char *instance;

	REQUIRE(ins_name != NULL && *ins_name == NULL);
d711 4
a714 5
		if (debug)
			UNEXPECTED_ERROR(__FILE__, __LINE__,
					 "scf_handle_create() failed: %s",
			 		 scf_strerror(scf_error()));
		return (ISC_R_FAILURE);
d718 3
a720 4
		if (debug)
			UNEXPECTED_ERROR(__FILE__, __LINE__,
					 "scf_handle_bind() failed: %s",
					 scf_strerror(scf_error()));
d722 1
a722 1
		return (ISC_R_FAILURE);
d726 4
a729 4
		if (debug)
			UNEXPECTED_ERROR(__FILE__, __LINE__,
					 "scf_myname() failed: %s",
					 scf_strerror(scf_error()));
d731 1
a731 1
		return (ISC_R_FAILURE);
d734 1
a734 1
	if ((instance = isc_mem_allocate(mctx, namelen + 1)) == NULL) {
d736 1
a736 1
				 "ns_smf_get_instance memory "
d740 1
a740 1
		return (ISC_R_FAILURE);
d743 4
a746 5
	if (scf_myname(h, instance, namelen + 1) == -1) {
		if (debug)
			UNEXPECTED_ERROR(__FILE__, __LINE__,
					 "scf_myname() failed: %s",
					 scf_strerror(scf_error()));
d748 2
a749 2
		isc_mem_free(mctx, instance);
		return (ISC_R_FAILURE);
d753 29
a781 2
	*ins_name = instance;
	return (ISC_R_SUCCESS);
d783 1
a783 1
#endif /* HAVE_LIBSCF */
a787 3
#ifdef HAVE_LIBSCF
	char *instance = NULL;
#endif
d859 2
a860 14
	if (ns_smf_want_disable == 1) {
		result = ns_smf_get_instance(&instance, 1, ns_g_mctx);
		if (result == ISC_R_SUCCESS && instance != NULL) {
			if (smf_disable_instance(instance, 0) != 0)
				UNEXPECTED_ERROR(__FILE__, __LINE__,
						 "smf_disable_instance() ",
						 "failed for %s : %s",
						 instance,
						 scf_strerror(scf_error()));
		}
		if (instance != NULL)
			isc_mem_free(ns_g_mctx, instance);
	}
#endif /* HAVE_LIBSCF */
@


1.1.1.5
log
@ISC BIND release 9.3.3
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: main.c,v 1.119.2.3.2.25 2006/11/10 18:51:06 marka Exp $ */
d476 1
a476 1
				 "isc_taskmgr_create() failed: %s",
d484 1
a484 1
				 "isc_timermgr_create() failed: %s",
d859 1
a859 1
						 "smf_disable_instance() "
@


1.1.1.6
log
@ISC BIND release 9.4.2
@
text
@d18 1
a18 3
/* $ISC: main.c,v 1.136.18.17 2006/11/10 18:51:14 marka Exp $ */

/*! \file */
a73 7
/*
 * Include DLZ drivers if appropriate.
 */
#ifdef DLZ
#include <dlz/dlz_drivers.h>
#endif

d229 1
a229 1
		"              [-m {usage|trace|record|size|mctx}]\n");
d242 1
a242 1
		"             [-m {usage|trace|record|size|mctx}]\n");
a309 2
	{ "size", ISC_MEM_DEBUGSIZE },
	{ "mctx", ISC_MEM_DEBUGCTX },
a673 10
#ifdef DLZ
	/*
	 * Registyer any DLZ drivers.
	 */
	result = dlz_drivers_init();
	if (result != ISC_R_SUCCESS)
		ns_main_earlyfatal("dlz_drivers_init() failed: %s",
				   isc_result_totext(result));
#endif

a689 9
#ifdef DLZ
	/*
	 * Unregister any DLZ drivers.
	 */
	dlz_drivers_clear();
#endif

	dns_name_destroy();

a884 1
	isc_mem_checkdestroyed(stderr);
@


