head	1.5;
access;
symbols
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	BIND_9_3_1:1.1.1.2
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2006.04.05.17.36.33;	author jakob;	state dead;
branches;
next	1.4;

1.4
date	2004.09.28.17.14.03;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.18.14.14.05;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.23.06.56.12;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.06.05;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.06.05;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.32.52;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.5
log
@resolve conflicts
@
text
@/*
 * Portions Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Portions Copyright (C) 2000-2003  Internet Software Consortium.
 * Portions Copyright (C) 1995-2000 by Network Associates, Inc.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC AND NETWORK ASSOCIATES DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
 * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: dnssec-signkey.c,v 1.50.2.2.2.7 2004/08/28 06:25:28 marka Exp $ */

#include <config.h>

#include <stdlib.h>

#include <isc/string.h>
#include <isc/commandline.h>
#include <isc/entropy.h>
#include <isc/mem.h>
#include <isc/print.h>
#include <isc/util.h>

#include <dns/db.h>
#include <dns/dbiterator.h>
#include <dns/diff.h>
#include <dns/dnssec.h>
#include <dns/fixedname.h>
#include <dns/log.h>
#include <dns/rdata.h>
#include <dns/rdataclass.h>
#include <dns/rdataset.h>
#include <dns/rdatasetiter.h>
#include <dns/rdatastruct.h>
#include <dns/result.h>
#include <dns/secalg.h>

#include <dst/dst.h>

#include "dnssectool.h"

const char *program = "dnssec-signkey";
int verbose;

typedef struct keynode keynode_t;
struct keynode {
	dst_key_t *key;
	isc_boolean_t verified;
	ISC_LINK(keynode_t) link;
};
typedef ISC_LIST(keynode_t) keylist_t;

static isc_stdtime_t starttime = 0, endtime = 0, now;

static isc_mem_t *mctx = NULL;
static isc_entropy_t *ectx = NULL;
static keylist_t keylist;

static void
usage(void) {
	fprintf(stderr, "Usage:\n");
	fprintf(stderr, "\t%s [options] keyset keys\n", program);

	fprintf(stderr, "\n");

	fprintf(stderr, "Version: %s\n", VERSION);

	fprintf(stderr, "Options: (default value in parenthesis) \n");
	fprintf(stderr, "\t-a\n");
	fprintf(stderr, "\t\tverify generated signatures\n");
	fprintf(stderr, "\t-c class (IN)\n");
	fprintf(stderr, "\t-s YYYYMMDDHHMMSS|+offset:\n");
	fprintf(stderr, "\t\tSIG start time - absolute|offset (from keyset)\n");
	fprintf(stderr, "\t-e YYYYMMDDHHMMSS|+offset|\"now\"+offset]:\n");
	fprintf(stderr, "\t\tSIG end time  - absolute|from start|from now "
		"(from keyset)\n");
	fprintf(stderr, "\t-v level:\n");
	fprintf(stderr, "\t\tverbose level (0)\n");
	fprintf(stderr, "\t-p\n");
	fprintf(stderr, "\t\tuse pseudorandom data (faster but less secure)\n");
	fprintf(stderr, "\t-r randomdev:\n");
	fprintf(stderr, "\t\ta file containing random data\n");

	fprintf(stderr, "\n");

	fprintf(stderr, "keyset:\n");
	fprintf(stderr, "\tfile with keyset to be signed (keyset-<name>)\n");
	fprintf(stderr, "keys:\n");
	fprintf(stderr, "\tkeyfile (Kname+alg+tag)\n");

	fprintf(stderr, "\n");
	fprintf(stderr, "Output:\n");
	fprintf(stderr, "\tsigned keyset (signedkey-<name>)\n");
	exit(0);
}

static void
loadkeys(dns_name_t *name, dns_rdataset_t *rdataset) {
	dst_key_t *key;
	dns_rdata_t rdata = DNS_RDATA_INIT;
	keynode_t *keynode;
	isc_result_t result;

	ISC_LIST_INIT(keylist);
	result = dns_rdataset_first(rdataset);
	check_result(result, "dns_rdataset_first");
	for (; result == ISC_R_SUCCESS; result = dns_rdataset_next(rdataset)) {
		dns_rdata_reset(&rdata);
		dns_rdataset_current(rdataset, &rdata);
		key = NULL;
		result = dns_dnssec_keyfromrdata(name, &rdata, mctx, &key);
		if (result != ISC_R_SUCCESS)
			continue;
		if (!dst_key_iszonekey(key)) {
			dst_key_free(&key);
			continue;
		}
		keynode = isc_mem_get(mctx, sizeof(keynode_t));
		if (keynode == NULL)
			fatal("out of memory");
		keynode->key = key;
		keynode->verified = ISC_FALSE;
		ISC_LIST_INITANDAPPEND(keylist, keynode, link);
	}
	if (result != ISC_R_NOMORE)
		fatal("failure traversing key list");
}

static dst_key_t *
findkey(dns_rdata_rrsig_t *sig) {
	keynode_t *keynode;
	for (keynode = ISC_LIST_HEAD(keylist);
	     keynode != NULL;
	     keynode = ISC_LIST_NEXT(keynode, link))
	{
		if (dst_key_id(keynode->key) == sig->keyid &&
		    dst_key_alg(keynode->key) == sig->algorithm) {
			keynode->verified = ISC_TRUE;
			return (keynode->key);
		}
	}
	fatal("signature generated by non-zone or missing key");
	return (NULL);
}

int
main(int argc, char *argv[]) {
	int i, ch;
	char *startstr = NULL, *endstr = NULL, *classname = NULL;
	char tdomain[1025];
	dns_fixedname_t fdomain;
	dns_name_t *domain;
	char *output = NULL;
	char *endp;
	unsigned char data[65536];
	dns_db_t *db;
	dns_dbnode_t *node;
	dns_dbversion_t *version;
	dns_diff_t diff;
	dns_difftuple_t *tuple;
	dns_dbiterator_t *dbiter;
	dns_rdatasetiter_t *rdsiter;
	dst_key_t *key = NULL;
	dns_rdata_t rdata = DNS_RDATA_INIT;
	dns_rdata_t sigrdata = DNS_RDATA_INIT;
	dns_rdataset_t rdataset, sigrdataset;
	dns_rdata_rrsig_t sig;
	isc_result_t result;
	isc_buffer_t b;
	isc_log_t *log = NULL;
	keynode_t *keynode;
	isc_boolean_t pseudorandom = ISC_FALSE;
	unsigned int eflags;
	dns_rdataclass_t rdclass;
	isc_boolean_t tryverify = ISC_FALSE;
	isc_boolean_t settime = ISC_FALSE;
	size_t len;

	result = isc_mem_create(0, 0, &mctx);
	check_result(result, "isc_mem_create()");

	dns_result_register();

	while ((ch = isc_commandline_parse(argc, argv, "ac:s:e:pr:v:h")) != -1)
	{
		switch (ch) {
		case 'a':
			tryverify = ISC_TRUE;
			break;
		case 'c':
			classname = isc_commandline_argument;
			break;

		case 's':
			startstr = isc_commandline_argument;
			break;
						
		case 'e':
			endstr = isc_commandline_argument;
			break;

		case 'p':
			pseudorandom = ISC_TRUE;
			break;

		case 'r':
			setup_entropy(mctx, isc_commandline_argument, &ectx);
			break;

		case 'v':
			endp = NULL;
			verbose = strtol(isc_commandline_argument, &endp, 0);
			if (*endp != '\0')
				fatal("verbose level must be numeric");
			break;

		case 'h':
		default:
			usage();

		}
	}

	argc -= isc_commandline_index;
	argv += isc_commandline_index;

	if (argc < 2)
		usage();

	rdclass = strtoclass(classname);

	if (ectx == NULL)
		setup_entropy(mctx, NULL, &ectx);
	eflags = ISC_ENTROPY_BLOCKING;
	if (!pseudorandom)
		eflags |= ISC_ENTROPY_GOODONLY;
	result = dst_lib_init(mctx, ectx, eflags);
	if (result != ISC_R_SUCCESS)
		fatal("could not initialize dst: %s", 
		      isc_result_totext(result));

	isc_stdtime_get(&now);

	if ((startstr == NULL || endstr == NULL) &&
	    !(startstr == NULL && endstr == NULL))
		fatal("if -s or -e is specified, both must be");

	if (startstr != NULL) {
		starttime = strtotime(startstr, now, now);
		endtime = strtotime(endstr, now, starttime);
		settime = ISC_TRUE;
	}

	setup_logging(verbose, mctx, &log);

	if (strlen(argv[0]) < 8U || strncmp(argv[0], "keyset-", 7) != 0)
		fatal("keyset file '%s' must start with keyset-", argv[0]);

	db = NULL;
	result = dns_db_create(mctx, "rbt", dns_rootname, dns_dbtype_zone,
			       rdclass, 0, NULL, &db);
	check_result(result, "dns_db_create()");

	result = dns_db_load(db, argv[0]);
	if (result != ISC_R_SUCCESS && result != DNS_R_SEENINCLUDE)
		fatal("failed to load database from '%s': %s", argv[0],
		      isc_result_totext(result));

	dns_fixedname_init(&fdomain);
	domain = dns_fixedname_name(&fdomain);

	dbiter = NULL;
	result = dns_db_createiterator(db, ISC_FALSE, &dbiter);
	check_result(result, "dns_db_createiterator()");

	result = dns_dbiterator_first(dbiter);
	check_result(result, "dns_dbiterator_first()");
	while (result == ISC_R_SUCCESS) {
		node = NULL;
		dns_dbiterator_current(dbiter, &node, domain);
		rdsiter = NULL;
		result = dns_db_allrdatasets(db, node, NULL, 0, &rdsiter);
		check_result(result, "dns_db_allrdatasets()");
		result = dns_rdatasetiter_first(rdsiter);
		dns_rdatasetiter_destroy(&rdsiter);
		if (result == ISC_R_SUCCESS)
			break;
		dns_db_detachnode(db, &node);
		result = dns_dbiterator_next(dbiter);
	}
	dns_dbiterator_destroy(&dbiter);
	if (result != ISC_R_SUCCESS)
		fatal("failed to find data in keyset file");

	isc_buffer_init(&b, tdomain, sizeof(tdomain) - 1);
	result = dns_name_tofilenametext(domain, ISC_FALSE, &b);
	check_result(result, "dns_name_tofilenametext()");
	isc_buffer_putuint8(&b, 0);

	len = strlen("signedkey-") + strlen(tdomain);
	output = isc_mem_allocate(mctx, len + 1);
	if (output == NULL)
		fatal("out of memory");
	strlcpy(output, "signedkey-", len + 1);
	strlcat(output, tdomain, len + 1);

	version = NULL;
	dns_db_newversion(db, &version);

	dns_rdataset_init(&rdataset);
	dns_rdataset_init(&sigrdataset);
	result = dns_db_findrdataset(db, node, version, dns_rdatatype_dnskey, 0,
				     0, &rdataset, &sigrdataset);
	if (result != ISC_R_SUCCESS) {
		char domainstr[DNS_NAME_FORMATSIZE];
		dns_name_format(domain, domainstr, sizeof(domainstr));
		fatal("failed to find rdataset '%s KEY': %s",
		      domainstr, isc_result_totext(result));
	}

	loadkeys(domain, &rdataset);

	dns_diff_init(mctx, &diff);

	if (!dns_rdataset_isassociated(&sigrdataset))
		fatal("no SIG KEY set present");

	result = dns_rdataset_first(&sigrdataset);
	check_result(result, "dns_rdataset_first()");
	do {
		dns_rdataset_current(&sigrdataset, &sigrdata);
		result = dns_rdata_tostruct(&sigrdata, &sig, mctx);
		check_result(result, "dns_rdata_tostruct()");
		key = findkey(&sig);
		result = dns_dnssec_verify(domain, &rdataset, key,
					   ISC_TRUE, mctx, &sigrdata);
		if (result != ISC_R_SUCCESS) {
			char keystr[KEY_FORMATSIZE];
			key_format(key, keystr, sizeof(keystr));
			fatal("signature by key '%s' did not verify: %s",
			      keystr, isc_result_totext(result));
		}
		if (!settime) {
			starttime = sig.timesigned;
			endtime = sig.timeexpire;
			settime = ISC_TRUE;
		}
		dns_rdata_freestruct(&sig);
		dns_rdata_reset(&sigrdata);
		result = dns_rdataset_next(&sigrdataset);
	} while (result == ISC_R_SUCCESS);

	for (keynode = ISC_LIST_HEAD(keylist);
	     keynode != NULL;
	     keynode = ISC_LIST_NEXT(keynode, link))
		if (!keynode->verified)
			fatal("not all zone keys self signed the key set");

	argc -= 1;
	argv += 1;

	for (i = 0; i < argc; i++) {
		key = NULL;
		result = dst_key_fromnamedfile(argv[i],
					       DST_TYPE_PUBLIC |
					       DST_TYPE_PRIVATE,
					       mctx, &key);
		if (result != ISC_R_SUCCESS)
			fatal("failed to read key %s from disk: %s",
			      argv[i], isc_result_totext(result));

		dns_rdata_reset(&rdata);
		isc_buffer_init(&b, data, sizeof(data));
		result = dns_dnssec_sign(domain, &rdataset, key,
					 &starttime, &endtime,
					 mctx, &b, &rdata);
		isc_entropy_stopcallbacksources(ectx);
		if (result != ISC_R_SUCCESS) {
			char keystr[KEY_FORMATSIZE];
			key_format(key, keystr, sizeof(keystr));
			fatal("key '%s' failed to sign data: %s",
			      keystr, isc_result_totext(result));
		}
		if (tryverify) {
			result = dns_dnssec_verify(domain, &rdataset, key,
						   ISC_TRUE, mctx, &rdata);
			if (result != ISC_R_SUCCESS) {
				char keystr[KEY_FORMATSIZE];
				key_format(key, keystr, sizeof(keystr));
				fatal("signature from key '%s' failed to "
				      "verify: %s",
				      keystr, isc_result_totext(result));
			}
		}
		tuple = NULL;
		result = dns_difftuple_create(mctx, DNS_DIFFOP_ADD,
					      domain, rdataset.ttl,
					      &rdata, &tuple);
		check_result(result, "dns_difftuple_create");
		dns_diff_append(&diff, &tuple);
		dst_key_free(&key);
	}

	result = dns_db_deleterdataset(db, node, version, dns_rdatatype_rrsig,
				       dns_rdatatype_dnskey);
	check_result(result, "dns_db_deleterdataset");

	result = dns_diff_apply(&diff, db, version);
	check_result(result, "dns_diff_apply");
	dns_diff_clear(&diff);

	dns_db_detachnode(db, &node);
	dns_db_closeversion(db, &version, ISC_TRUE);
	result = dns_db_dump(db, version, output);
	if (result != ISC_R_SUCCESS)
		fatal("failed to write database to '%s': %s",
		      output, isc_result_totext(result));

	printf("%s\n", output);

	dns_rdataset_disassociate(&rdataset);
	dns_rdataset_disassociate(&sigrdataset);

	dns_db_detach(&db);

	while (!ISC_LIST_EMPTY(keylist)) {
		keynode = ISC_LIST_HEAD(keylist);
		ISC_LIST_UNLINK(keylist, keynode, link);
		dst_key_free(&keynode->key);
		isc_mem_put(mctx, keynode, sizeof(keynode_t));
	}

	cleanup_logging(&log);

	isc_mem_free(mctx, output);
	cleanup_entropy(&ectx);
	dst_lib_destroy();
	if (verbose > 10)
		isc_mem_stats(mctx, stdout);
	isc_mem_destroy(&mctx);
	return (0);
}
@


1.4
log
@resolve conflicts
@
text
@@


1.3
log
@update to BIND v9.2.3. ok todd@@
@
text
@d2 2
a3 1
 * Portions Copyright (C) 2000, 2001, 2003  Internet Software Consortium.
d10 7
a16 9
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM AND
 * NETWORK ASSOCIATES DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE CONSORTIUM OR NETWORK
 * ASSOCIATES BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d19 1
a19 1
/* $ISC: dnssec-signkey.c,v 1.50.2.3 2003/10/09 07:32:31 marka Exp $ */
d29 1
d34 1
a39 1
#include <dns/rdatalist.h>
a52 2
#define BUFSIZE 2048

d74 2
d122 2
a123 1
		if (!dst_key_iszonekey(key))
d125 2
a126 1
		keynode = isc_mem_get(mctx, sizeof (keynode_t));
d138 1
a138 1
findkey(dns_rdata_sig_t *sig) {
d163 1
a163 2
	unsigned char *data;
	char *randomfile = NULL;
d167 2
d172 1
a172 1
	dns_rdata_t *rdata;
d174 2
a175 3
	dns_rdatalist_t sigrdatalist;
	dns_rdataset_t rdataset, sigrdataset, newsigrdataset;
	dns_rdata_sig_t sig;
a177 1
	isc_textregion_t tr;
d183 2
a184 1
	static isc_boolean_t tryverify = ISC_FALSE;
d215 1
a215 1
			randomfile = isc_commandline_argument;
d238 1
a238 8
	if (classname != NULL) {
		tr.base = classname;
		tr.length = strlen(classname);
		result = dns_rdataclass_fromtext(&rdclass, &tr);
		if (result != ISC_R_SUCCESS)
			fatal("unknown class %s",classname);
	} else
		rdclass = dns_rdataclass_in;
d240 2
a241 1
	setup_entropy(mctx, randomfile, &ectx);
d256 6
d308 2
a309 2
	len = strlen("signedkey-") + strlen(tdomain) + 1;
	output = isc_mem_allocate(mctx, len);
d312 2
a313 2
	strlcpy(output, "signedkey-", len);
	strlcat(output, tdomain, len);
d320 1
a320 1
	result = dns_db_findrdataset(db, node, version, dns_rdatatype_key, 0,
d324 1
a324 1
		dns_name_format(domain, domainstr, sizeof domainstr);
d331 2
d347 1
a347 1
			key_format(key, keystr, sizeof keystr);
d351 6
a357 1
		dns_rdata_freestruct(&sig);
a360 9
	if (startstr != NULL) {
		starttime = strtotime(startstr, now, now);
		endtime = strtotime(endstr, now, starttime);
	} else {
		starttime = sig.timesigned;
		endtime = sig.timeexpire;
	}


d365 1
a365 9
			fatal("Not all zone keys self signed the key set");

	result = dns_rdataset_first(&sigrdataset);
	check_result(result, "dns_rdataset_first()");
	dns_rdataset_current(&sigrdataset, &sigrdata);
	result = dns_rdata_tostruct(&sigrdata, &sig, mctx);
	check_result(result, "dns_rdata_tostruct()");

	dns_rdataset_disassociate(&sigrdataset);
a369 6
	dns_rdatalist_init(&sigrdatalist);
	sigrdatalist.rdclass = rdataset.rdclass;
	sigrdatalist.type = dns_rdatatype_sig;
	sigrdatalist.covers = dns_rdatatype_key;
	sigrdatalist.ttl = rdataset.ttl;

d380 2
a381 8
		rdata = isc_mem_get(mctx, sizeof(dns_rdata_t));
		if (rdata == NULL)
			fatal("out of memory");
		dns_rdata_init(rdata);
		data = isc_mem_get(mctx, BUFSIZE);
		if (data == NULL)
			fatal("out of memory");
		isc_buffer_init(&b, data, BUFSIZE);
d384 1
a384 1
					 mctx, &b, rdata);
d388 1
a388 1
			key_format(key, keystr, sizeof keystr);
d394 1
a394 1
						   ISC_TRUE, mctx, rdata);
d397 1
a397 1
				key_format(key, keystr, sizeof keystr);
d403 6
a408 1
		ISC_LIST_APPEND(sigrdatalist.rdata, rdata, link);
d412 7
a418 6
	dns_rdataset_init(&newsigrdataset);
	result = dns_rdatalist_tordataset(&sigrdatalist, &newsigrdataset);
	check_result (result, "dns_rdatalist_tordataset()");

	dns_db_addrdataset(db, node, version, 0, &newsigrdataset, 0, NULL);
	check_result (result, "dns_db_addrdataset()");
d430 1
a430 10
	dns_rdataset_disassociate(&newsigrdataset);

	dns_rdata_freestruct(&sig);

	while (!ISC_LIST_EMPTY(sigrdatalist.rdata)) {
		rdata = ISC_LIST_HEAD(sigrdatalist.rdata);
		ISC_LIST_UNLINK(sigrdatalist.rdata, rdata, link);
		isc_mem_put(mctx, rdata->data, BUFSIZE);
		isc_mem_put(mctx, rdata, sizeof *rdata);
	}
@


1.2
log
@more snprintf and strlcpy/strlcat fixes. from todd@@ and tedu@@.
@
text
@d2 1
a2 1
 * Portions Copyright (C) 2000, 2001  Internet Software Consortium.
d20 1
a20 1
/* $ISC: dnssec-signkey.c,v 1.50.2.1 2001/10/05 00:21:46 bwelling Exp $ */
d262 1
a262 1
	if (strlen(argv[0]) < 8 || strncmp(argv[0], "keyset-", 7) != 0)
@


1.1
log
@Initial revision
@
text
@d183 1
d306 2
a307 2
	output = isc_mem_allocate(mctx,
				  strlen("signedkey-") + strlen(tdomain) + 1);
d310 2
a311 2
	strcpy(output, "signedkey-");
	strcat(output, tdomain);
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Portions Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Portions Copyright (C) 2000-2003  Internet Software Consortium.
d9 9
a17 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC AND NETWORK ASSOCIATES DISCLAIMS
 * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
 * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d20 1
a20 1
/* $ISC: dnssec-signkey.c,v 1.50.2.2.2.7 2004/08/28 06:25:28 marka Exp $ */
a29 1
#include <isc/print.h>
a33 1
#include <dns/diff.h>
d39 1
d53 2
a75 2
	fprintf(stderr, "Version: %s\n", VERSION);

d122 1
a122 2
		if (!dst_key_iszonekey(key)) {
			dst_key_free(&key);
d124 1
a124 2
		}
		keynode = isc_mem_get(mctx, sizeof(keynode_t));
d136 1
a136 1
findkey(dns_rdata_rrsig_t *sig) {
d161 2
a162 1
	unsigned char data[65536];
a165 2
	dns_diff_t diff;
	dns_difftuple_t *tuple;
d169 1
a169 1
	dns_rdata_t rdata = DNS_RDATA_INIT;
d171 3
a173 2
	dns_rdataset_t rdataset, sigrdataset;
	dns_rdata_rrsig_t sig;
d176 1
d182 1
a182 2
	isc_boolean_t tryverify = ISC_FALSE;
	isc_boolean_t settime = ISC_FALSE;
d212 1
a212 1
			setup_entropy(mctx, isc_commandline_argument, &ectx);
d235 8
a242 1
	rdclass = strtoclass(classname);
d244 1
a244 2
	if (ectx == NULL)
		setup_entropy(mctx, NULL, &ectx);
a258 6
	if (startstr != NULL) {
		starttime = strtotime(startstr, now, now);
		endtime = strtotime(endstr, now, starttime);
		settime = ISC_TRUE;
	}

d261 1
a261 1
	if (strlen(argv[0]) < 8U || strncmp(argv[0], "keyset-", 7) != 0)
d309 2
a310 1
	sprintf(output, "signedkey-%s", tdomain);
d317 1
a317 1
	result = dns_db_findrdataset(db, node, version, dns_rdatatype_dnskey, 0,
d321 1
a321 1
		dns_name_format(domain, domainstr, sizeof(domainstr));
a327 2
	dns_diff_init(mctx, &diff);

d342 1
a342 1
			key_format(key, keystr, sizeof(keystr));
d346 1
a346 5
		if (!settime) {
			starttime = sig.timesigned;
			endtime = sig.timeexpire;
			settime = ISC_TRUE;
		}
a347 1
		dns_rdata_reset(&sigrdata);
d351 9
d364 9
a372 1
			fatal("not all zone keys self signed the key set");
d377 6
d393 8
a400 2
		dns_rdata_reset(&rdata);
		isc_buffer_init(&b, data, sizeof(data));
d403 1
a403 1
					 mctx, &b, &rdata);
d407 1
a407 1
			key_format(key, keystr, sizeof(keystr));
d413 1
a413 1
						   ISC_TRUE, mctx, &rdata);
d416 1
a416 1
				key_format(key, keystr, sizeof(keystr));
d422 1
a422 6
		tuple = NULL;
		result = dns_difftuple_create(mctx, DNS_DIFFOP_ADD,
					      domain, rdataset.ttl,
					      &rdata, &tuple);
		check_result(result, "dns_difftuple_create");
		dns_diff_append(&diff, &tuple);
d426 6
a431 7
	result = dns_db_deleterdataset(db, node, version, dns_rdatatype_rrsig,
				       dns_rdatatype_dnskey);
	check_result(result, "dns_db_deleterdataset");

	result = dns_diff_apply(&diff, db, version);
	check_result(result, "dns_diff_apply");
	dns_diff_clear(&diff);
d443 10
a452 1
	dns_rdataset_disassociate(&sigrdataset);
@

