head	1.17;
access;
symbols
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.14.0.26
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.18
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.22
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.20
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.16
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	BIND_9_4_2_P1:1.1.1.6
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	BIND_9_4_2:1.1.1.6
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	BIND_9_3_4:1.1.1.5
	BIND_9_3_3:1.1.1.5
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	BIND_9_3_2:1.1.1.4
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	BIND_9_3_1:1.1.1.3
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.06.05.15.09.17;	author tedu;	state Exp;
branches;
next	1.16;
commitid	9Lvqk0s3F3HnvGAQ;

1.16
date	2015.11.11.02.52.46;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	6fvHpVQjE6wYuHzb;

1.15
date	2015.10.25.07.44.42;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	M6VL9l5lhUhU7DsW;

1.14
date	2009.08.16.13.17.44;	author stsp;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.09.13.39.42;	author jakob;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.10.19.07.58;	author jakob;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.10.21.38.16;	author cloder;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.05.17.36.32;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.14.02.27.44;	author cloder;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.14.02.15.23;	author cloder;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.22.16.52.38;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.28.17.14.02;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.18.14.14.05;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.27.19.08.22;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.23.06.56.12;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.20.21.36.59;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.06.02;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.06.02;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.32.43;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.03.22.16.36.12;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.04.05.16.41.59;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2007.01.10.18.18.16;	author jakob;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2007.12.09.12.33.19;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.17
log
@reduce confusion about -p option. parse it, but only permit port 53, and
make it an error otherwise instead of a warning that may be overlooked.
reported by Peter van Dijk
ok deraadt
@
text
@/*
 * Copyright (C) 2004-2007  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 2000-2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: dig.c,v 1.186.18.29 2007/08/28 07:19:55 tbox Exp $ */

/*! \file */

#include <config.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <ctype.h>

#include <isc/app.h>
#include <isc/netaddr.h>
#include <isc/parseint.h>
#include <isc/print.h>
#include <isc/string.h>
#include <isc/util.h>
#include <isc/task.h>

#include <dns/byaddr.h>
#include <dns/fixedname.h>
#include <dns/masterdump.h>
#include <dns/message.h>
#include <dns/name.h>
#include <dns/rdata.h>
#include <dns/rdataset.h>
#include <dns/rdatatype.h>
#include <dns/rdataclass.h>
#include <dns/result.h>
#include <dns/tsig.h>

#include <bind9/getaddresses.h>

#include <dig/dig.h>

#define ADD_STRING(b, s) { 				\
	if (strlen(s) >= isc_buffer_availablelength(b)) \
 		return (ISC_R_NOSPACE); 		\
	else 						\
		isc_buffer_putstr(b, s); 		\
}

#define DIG_MAX_ADDRESSES 20

dig_lookup_t *default_lookup = NULL;

static char *batchname = NULL;
static FILE *batchfp = NULL;
static char *argv0;
static int addresscount = 0;

static char domainopt[DNS_NAME_MAXTEXT];

static isc_boolean_t short_form = ISC_FALSE, printcmd = ISC_TRUE,
	ip6_int = ISC_FALSE, plusquest = ISC_FALSE, pluscomm = ISC_FALSE,
	multiline = ISC_FALSE, nottl = ISC_FALSE, noclass = ISC_FALSE;

/*% opcode text */
static const char *opcodetext[] = {
	"QUERY",
	"IQUERY",
	"STATUS",
	"RESERVED3",
	"NOTIFY",
	"UPDATE",
	"RESERVED6",
	"RESERVED7",
	"RESERVED8",
	"RESERVED9",
	"RESERVED10",
	"RESERVED11",
	"RESERVED12",
	"RESERVED13",
	"RESERVED14",
	"RESERVED15"
};

/*% return code text */
static const char *rcodetext[] = {
	"NOERROR",
	"FORMERR",
	"SERVFAIL",
	"NXDOMAIN",
	"NOTIMP",
	"REFUSED",
	"YXDOMAIN",
	"YXRRSET",
	"NXRRSET",
	"NOTAUTH",
	"NOTZONE",
	"RESERVED11",
	"RESERVED12",
	"RESERVED13",
	"RESERVED14",
	"RESERVED15",
	"BADVERS"
};

/*% print usage */
static void
print_usage(FILE *fp) {
	fputs(
"Usage:  dig [@@global-server] [domain] [q-type] [q-class] {q-opt}\n"
"            {global-d-opt} host [@@local-server] {local-d-opt}\n"
"            [ host [@@local-server] {local-d-opt} [...]]\n", fp);
}

static void
usage(void) {
	print_usage(stderr);
	fputs("\nUse \"dig -h\" (or \"dig -h | more\") "
	      "for complete list of options\n", stderr);
	exit(1);
}

/*% version */
static void
version(void) {
	fputs("DiG " VERSION "\n", stderr);
}

/*% help */
static void
help(void) {
	print_usage(stdout);
	fputs(
"Where:  domain	  is in the Domain Name System\n"
"        q-class  is one of (in,hs,ch,...) [default: in]\n"
"        q-type   is one of (a,any,mx,ns,soa,hinfo,axfr,txt,...) [default:a]\n"
"                 (Use ixfr=version for type ixfr)\n"
"        q-opt    is one of:\n"
"                 -x dot-notation     (shortcut for in-addr lookups)\n"
"                 -i                  (IP6.INT reverse IPv6 lookups)\n"
"                 -f filename         (batch mode)\n"
"                 -b address[#port]   (bind to source address/port)\n"
"                 -q name             (specify query name)\n"
"                 -t type             (specify query type)\n"
"                 -c class            (specify query class)\n"
"                 -k keyfile          (specify tsig key file)\n"
"                 -y [hmac:]name:key  (specify named base64 tsig key)\n"
"                 -4                  (use IPv4 query transport only)\n"
"                 -6                  (use IPv6 query transport only)\n"
"        d-opt    is of the form +keyword[=value], where keyword is:\n"
"                 +[no]vc             (TCP mode)\n"
"                 +[no]tcp            (TCP mode, alternate syntax)\n"
"                 +time=###           (Set query timeout) [5]\n"
"                 +tries=###          (Set number of UDP attempts) [3]\n"
"                 +retry=###          (Set number of UDP retries) [2]\n"
"                 +domain=###         (Set default domainname)\n"
"                 +bufsize=###        (Set EDNS0 Max UDP packet size)\n"
"                 +ndots=###          (Set NDOTS value)\n"
"                 +edns=###           (Set EDNS version)\n"
"                 +[no]search         (Set whether to use searchlist)\n"
"                 +[no]showsearch     (Search with intermediate results)\n"
"                 +[no]defname        (Ditto)\n"
"                 +[no]recurse        (Recursive mode)\n"
"                 +[no]ignore         (Don't revert to TCP for TC responses.)"
"\n"
"                 +[no]fail           (Don't try next server on SERVFAIL)\n"
"                 +[no]besteffort     (Try to parse even illegal messages)\n"
"                 +[no]aaonly         (Set AA flag in query (+[no]aaflag))\n"
"                 +[no]adflag         (Set AD flag in query)\n"
"                 +[no]cdflag         (Set CD flag in query)\n"
"                 +[no]cl             (Control display of class in records)\n"
"                 +[no]cmd            (Control display of command line)\n"
"                 +[no]comments       (Control display of comment lines)\n"
"                 +[no]question       (Control display of question)\n"
"                 +[no]answer         (Control display of answer)\n"
"                 +[no]authority      (Control display of authority)\n"
"                 +[no]additional     (Control display of additional)\n"
"                 +[no]stats          (Control display of statistics)\n"
"                 +[no]short          (Disable everything except short\n"
"                                      form of answer)\n"
"                 +[no]ttlid          (Control display of ttls in records)\n"
"                 +[no]all            (Set or clear all display flags)\n"
"                 +[no]qr             (Print question before sending)\n"
"                 +[no]nssearch       (Search all authoritative nameservers)\n"
"                 +[no]identify       (ID responders in short answers)\n"
"                 +[no]trace          (Trace delegation down from root)\n"
"                 +[no]dnssec         (Request DNSSEC records)\n"
#ifdef DIG_SIGCHASE
"                 +[no]sigchase       (Chase DNSSEC signatures)\n"
"                 +trusted-key=####   (Trusted Key when chasing DNSSEC sigs)\n"
#if DIG_SIGCHASE_TD
"                 +[no]topdown        (Do DNSSEC validation top down mode)\n"
#endif
#endif
"                 +[no]multiline      (Print records in an expanded format)\n"
"        global d-opts and servers (before host name) affect all queries.\n"
"        local d-opts and servers (after host name) affect only that lookup.\n"
"        -h                           (print help and exit)\n"
"        -v                           (print version and exit)\n",
	stdout);
}

/*%
 * Callback from dighost.c to print the received message.
 */
void
received(int bytes, isc_sockaddr_t *from, dig_query_t *query) {
	isc_uint64_t diff;
	isc_time_t now;
	time_t tnow;
	char fromtext[ISC_SOCKADDR_FORMATSIZE];

	isc_sockaddr_format(from, fromtext, sizeof(fromtext));

	TIME_NOW(&now);

	if (query->lookup->stats && !short_form) {
		diff = isc_time_microdiff(&now, &query->time_sent);
		printf(";; Query time: %ld msec\n", (long int)diff/1000);
		printf(";; SERVER: %s(%s)\n", fromtext, query->servname);
		time(&tnow);
		printf(";; WHEN: %s", ctime(&tnow));
		if (query->lookup->doing_xfr) {
			printf(";; XFR size: %u records (messages %u, "
			       "bytes %" ISC_PRINT_QUADFORMAT "u)\n",
			       query->rr_count, query->msg_count,
			       query->byte_count);
		} else {
			printf(";; MSG SIZE  rcvd: %u\n", bytes);

		}
		if (key != NULL) {
			if (!validated)
				puts(";; WARNING -- Some TSIG could not "
				     "be validated");
		}
		if ((key == NULL) && (keysecret[0] != 0)) {
			puts(";; WARNING -- TSIG key was not used.");
		}
		puts("");
	} else if (query->lookup->identify && !short_form) {
		diff = isc_time_microdiff(&now, &query->time_sent);
		printf(";; Received %" ISC_PRINT_QUADFORMAT "u bytes "
		       "from %s(%s) in %d ms\n\n",
		       query->lookup->doing_xfr ?
				query->byte_count : (isc_uint64_t)bytes,
		       fromtext, query->servname,
		       (int)diff/1000);
	}
}

/*
 * Callback from dighost.c to print that it is trying a server.
 * Not used in dig.
 * XXX print_trying
 */
void
trying(char *frm, dig_lookup_t *lookup) {
	UNUSED(frm);
	UNUSED(lookup);
}

/*%
 * Internal print routine used to print short form replies.
 */
static isc_result_t
say_message(dns_rdata_t *rdata, dig_query_t *query, isc_buffer_t *buf) {
	isc_result_t result;
	isc_uint64_t diff;
	isc_time_t now;
	char store[sizeof("12345678901234567890")];

	if (query->lookup->trace || query->lookup->ns_search_only) {
		result = dns_rdatatype_totext(rdata->type, buf);
		if (result != ISC_R_SUCCESS)
			return (result);
		ADD_STRING(buf, " ");
	}
	result = dns_rdata_totext(rdata, NULL, buf);
	check_result(result, "dns_rdata_totext");
	if (query->lookup->identify) {
		TIME_NOW(&now);
		diff = isc_time_microdiff(&now, &query->time_sent);
		ADD_STRING(buf, " from server ");
		ADD_STRING(buf, query->servname);
		snprintf(store, 19, " in %d ms.", (int)diff/1000);
		ADD_STRING(buf, store);
	}
	ADD_STRING(buf, "\n");
	return (ISC_R_SUCCESS);
}

/*%
 * short_form message print handler.  Calls above say_message()
 */
static isc_result_t
short_answer(dns_message_t *msg, dns_messagetextflag_t flags,
	     isc_buffer_t *buf, dig_query_t *query)
{
	dns_name_t *name;
	dns_rdataset_t *rdataset;
	isc_buffer_t target;
	isc_result_t result, loopresult;
	dns_name_t empty_name;
	char t[4096];
	dns_rdata_t rdata = DNS_RDATA_INIT;

	UNUSED(flags);

	dns_name_init(&empty_name, NULL);
	result = dns_message_firstname(msg, DNS_SECTION_ANSWER);
	if (result == ISC_R_NOMORE)
		return (ISC_R_SUCCESS);
	else if (result != ISC_R_SUCCESS)
		return (result);

	for (;;) {
		name = NULL;
		dns_message_currentname(msg, DNS_SECTION_ANSWER, &name);

		isc_buffer_init(&target, t, sizeof(t));

		for (rdataset = ISC_LIST_HEAD(name->list);
		     rdataset != NULL;
		     rdataset = ISC_LIST_NEXT(rdataset, link)) {
			loopresult = dns_rdataset_first(rdataset);
			while (loopresult == ISC_R_SUCCESS) {
				dns_rdataset_current(rdataset, &rdata);
				result = say_message(&rdata, query,
						     buf);
				check_result(result, "say_message");
				loopresult = dns_rdataset_next(rdataset);
				dns_rdata_reset(&rdata);
			}
		}
		result = dns_message_nextname(msg, DNS_SECTION_ANSWER);
		if (result == ISC_R_NOMORE)
			break;
		else if (result != ISC_R_SUCCESS)
			return (result);
	}

	return (ISC_R_SUCCESS);
}
#ifdef DIG_SIGCHASE
isc_result_t
printrdataset(dns_name_t *owner_name, dns_rdataset_t *rdataset,
	      isc_buffer_t *target)
{
	isc_result_t result;
	dns_master_style_t *style = NULL;
	unsigned int styleflags = 0;

	if (rdataset == NULL || owner_name == NULL || target == NULL)
		return(ISC_FALSE);

	styleflags |= DNS_STYLEFLAG_REL_OWNER;
	if (nottl)
		styleflags |= DNS_STYLEFLAG_NO_TTL;
	if (noclass)
		styleflags |= DNS_STYLEFLAG_NO_CLASS;
	if (multiline) {
		styleflags |= DNS_STYLEFLAG_OMIT_OWNER;
		styleflags |= DNS_STYLEFLAG_OMIT_CLASS;
		styleflags |= DNS_STYLEFLAG_REL_DATA;
		styleflags |= DNS_STYLEFLAG_OMIT_TTL;
		styleflags |= DNS_STYLEFLAG_TTL;
		styleflags |= DNS_STYLEFLAG_MULTILINE;
		styleflags |= DNS_STYLEFLAG_COMMENT;
	}
	if (multiline || (nottl && noclass))
		result = dns_master_stylecreate(&style, styleflags,
						24, 24, 24, 32, 80, 8, mctx);
	else if (nottl || noclass)
		result = dns_master_stylecreate(&style, styleflags,
						24, 24, 32, 40, 80, 8, mctx);
	else 
		result = dns_master_stylecreate(&style, styleflags,
						24, 32, 40, 48, 80, 8, mctx);
	check_result(result, "dns_master_stylecreate");

	result = dns_master_rdatasettotext(owner_name, rdataset, style, target);

	if (style != NULL)
		dns_master_styledestroy(&style, mctx);
  
	return(result);
}
#endif

/*
 * Callback from dighost.c to print the reply from a server
 */
isc_result_t
printmessage(dig_query_t *query, dns_message_t *msg, isc_boolean_t headers) {
	isc_result_t result;
	dns_messagetextflag_t flags;
	isc_buffer_t *buf = NULL;
	unsigned int len = OUTPUTBUF;
	dns_master_style_t *style = NULL;
	unsigned int styleflags = 0;

	styleflags |= DNS_STYLEFLAG_REL_OWNER;
	if (nottl)
		styleflags |= DNS_STYLEFLAG_NO_TTL;
	if (noclass)
		styleflags |= DNS_STYLEFLAG_NO_CLASS;
	if (multiline) {
		styleflags |= DNS_STYLEFLAG_OMIT_OWNER;
		styleflags |= DNS_STYLEFLAG_OMIT_CLASS;
		styleflags |= DNS_STYLEFLAG_REL_DATA;
		styleflags |= DNS_STYLEFLAG_OMIT_TTL;
		styleflags |= DNS_STYLEFLAG_TTL;
		styleflags |= DNS_STYLEFLAG_MULTILINE;
		styleflags |= DNS_STYLEFLAG_COMMENT;
	}
	if (multiline || (nottl && noclass))
		result = dns_master_stylecreate(&style, styleflags,
						24, 24, 24, 32, 80, 8, mctx);
	else if (nottl || noclass)
		result = dns_master_stylecreate(&style, styleflags,
						24, 24, 32, 40, 80, 8, mctx);
	else 
		result = dns_master_stylecreate(&style, styleflags,
						24, 32, 40, 48, 80, 8, mctx);
	check_result(result, "dns_master_stylecreate");

	if (query->lookup->cmdline[0] != 0) {
		if (!short_form)
			fputs(query->lookup->cmdline, stdout);
		query->lookup->cmdline[0]=0;
	}
	debug("printmessage(%s %s %s)", headers ? "headers" : "noheaders",
	      query->lookup->comments ? "comments" : "nocomments",
	      short_form ? "short_form" : "long_form");

	flags = 0;
	if (!headers) {
		flags |= DNS_MESSAGETEXTFLAG_NOHEADERS;
		flags |= DNS_MESSAGETEXTFLAG_NOCOMMENTS;
	}
	if (!query->lookup->comments)
		flags |= DNS_MESSAGETEXTFLAG_NOCOMMENTS;

	result = ISC_R_SUCCESS;

	result = isc_buffer_allocate(mctx, &buf, len);
	check_result(result, "isc_buffer_allocate");

	if (query->lookup->comments && !short_form) {
		if (query->lookup->cmdline[0] != 0)
			printf("; %s\n", query->lookup->cmdline);
		if (msg == query->lookup->sendmsg)
			printf(";; Sending:\n");
		else
			printf(";; Got answer:\n");

		if (headers) {
			printf(";; ->>HEADER<<- opcode: %s, status: %s, "
			       "id: %u\n",
			       opcodetext[msg->opcode], rcodetext[msg->rcode],
			       msg->id);
			printf(";; flags:");
			if ((msg->flags & DNS_MESSAGEFLAG_QR) != 0)
				printf(" qr");
			if ((msg->flags & DNS_MESSAGEFLAG_AA) != 0)
				printf(" aa");
			if ((msg->flags & DNS_MESSAGEFLAG_TC) != 0)
				printf(" tc");
			if ((msg->flags & DNS_MESSAGEFLAG_RD) != 0)
				printf(" rd");
			if ((msg->flags & DNS_MESSAGEFLAG_RA) != 0)
				printf(" ra");
			if ((msg->flags & DNS_MESSAGEFLAG_AD) != 0)
				printf(" ad");
			if ((msg->flags & DNS_MESSAGEFLAG_CD) != 0)
				printf(" cd");

			printf("; QUERY: %u, ANSWER: %u, "
			       "AUTHORITY: %u, ADDITIONAL: %u\n",
			       msg->counts[DNS_SECTION_QUESTION],
			       msg->counts[DNS_SECTION_ANSWER],
			       msg->counts[DNS_SECTION_AUTHORITY],
			       msg->counts[DNS_SECTION_ADDITIONAL]);

			if (msg != query->lookup->sendmsg &&
			    (msg->flags & DNS_MESSAGEFLAG_RD) != 0 &&
			    (msg->flags & DNS_MESSAGEFLAG_RA) == 0)
				printf(";; WARNING: recursion requested "
				       "but not available\n");
		}
		if (msg != query->lookup->sendmsg && extrabytes != 0U)
			printf(";; WARNING: Messages has %u extra byte%s at "
			       "end\n", extrabytes, extrabytes != 0 ? "s" : "");
	}

repopulate_buffer:

	if (query->lookup->comments && headers && !short_form) {
		result = dns_message_pseudosectiontotext(msg,
			 DNS_PSEUDOSECTION_OPT,
			 style, flags, buf);
		if (result == ISC_R_NOSPACE) {
buftoosmall:
			len += OUTPUTBUF;
			isc_buffer_free(&buf);
			result = isc_buffer_allocate(mctx, &buf, len);
			if (result == ISC_R_SUCCESS)
				goto repopulate_buffer;
			else
				goto cleanup;
		}
		check_result(result,
		     "dns_message_pseudosectiontotext");
	}

	if (query->lookup->section_question && headers) {
		if (!short_form) {
			result = dns_message_sectiontotext(msg,
						       DNS_SECTION_QUESTION,
						       style, flags, buf);
			if (result == ISC_R_NOSPACE)
				goto buftoosmall;
			check_result(result, "dns_message_sectiontotext");
		}
	}
	if (query->lookup->section_answer) {
		if (!short_form) {
			result = dns_message_sectiontotext(msg,
						       DNS_SECTION_ANSWER,
						       style, flags, buf);
			if (result == ISC_R_NOSPACE)
				goto buftoosmall;
			check_result(result, "dns_message_sectiontotext");
		} else {
			result = short_answer(msg, flags, buf, query);
			if (result == ISC_R_NOSPACE)
				goto buftoosmall;
			check_result(result, "short_answer");
		}
	}
	if (query->lookup->section_authority) {
		if (!short_form) {
			result = dns_message_sectiontotext(msg,
						       DNS_SECTION_AUTHORITY,
						       style, flags, buf);
			if (result == ISC_R_NOSPACE)
				goto buftoosmall;
			check_result(result, "dns_message_sectiontotext");
		}
	}
	if (query->lookup->section_additional) {
		if (!short_form) {
			result = dns_message_sectiontotext(msg,
						      DNS_SECTION_ADDITIONAL,
						      style, flags, buf);
			if (result == ISC_R_NOSPACE)
				goto buftoosmall;
			check_result(result, "dns_message_sectiontotext");
			/*
			 * Only print the signature on the first record.
			 */
			if (headers) {
				result = dns_message_pseudosectiontotext(
						   msg,
						   DNS_PSEUDOSECTION_TSIG,
						   style, flags, buf);
				if (result == ISC_R_NOSPACE)
					goto buftoosmall;
				check_result(result,
					  "dns_message_pseudosectiontotext");
				result = dns_message_pseudosectiontotext(
						   msg,
						   DNS_PSEUDOSECTION_SIG0,
						   style, flags, buf);
				if (result == ISC_R_NOSPACE)
					goto buftoosmall;
				check_result(result,
					   "dns_message_pseudosectiontotext");
			}
		}
	}

	if (headers && query->lookup->comments && !short_form)
		printf("\n");

	printf("%.*s", (int)isc_buffer_usedlength(buf),
	       (char *)isc_buffer_base(buf));
	isc_buffer_free(&buf);

cleanup:
	if (style != NULL)
		dns_master_styledestroy(&style, mctx);
	return (result);
}

/*%
 * print the greeting message when the program first starts up.
 */
static void
printgreeting(int argc, char **argv, dig_lookup_t *lookup) {
	int i;
	static isc_boolean_t first = ISC_TRUE;
	char append[MXNAME];

	if (printcmd) {
		lookup->cmdline[sizeof(lookup->cmdline) - 1] = 0;
		snprintf(lookup->cmdline, sizeof(lookup->cmdline),
			 "%s; <<>> DiG " VERSION " <<>>",
			 first?"\n":"");
		i = 1;
		while (i < argc) {
			snprintf(append, sizeof(append), " %s", argv[i++]);
			strlcat(lookup->cmdline, append, sizeof(lookup->cmdline));
		}
		strlcat(lookup->cmdline, "\n", sizeof(lookup->cmdline));
		if (first && addresscount != 0) {
			snprintf(append, sizeof(append),
				 "; (%d server%s found)\n",
				 addresscount,
				 addresscount > 1 ? "s" : "");
			strlcat(lookup->cmdline, append, sizeof(lookup->cmdline));
		}
		if (first) {
			snprintf(append, sizeof(append), 
				 ";; global options: %s %s\n",
			       short_form ? "short_form" : "",
			       printcmd ? "printcmd" : "");
			first = ISC_FALSE;
			strlcat(lookup->cmdline, append, sizeof(lookup->cmdline));
		}
	}
}

static isc_uint32_t
parse_uint(char *arg, const char *desc, isc_uint32_t max) {
	isc_result_t result;
	isc_uint32_t tmp;

	result = isc_parse_uint32(&tmp, arg, 10);
	if (result == ISC_R_SUCCESS && tmp > max)
		result = ISC_R_RANGE;
	if (result != ISC_R_SUCCESS)
		fatal("%s '%s': %s", desc, arg, isc_result_totext(result));
	return (tmp);
}

/*%
 * We're not using isc_commandline_parse() here since the command line
 * syntax of dig is quite a bit different from that which can be described
 * by that routine.
 * XXX doc options
 */

static void
plus_option(char *option, isc_boolean_t is_batchfile,
	    dig_lookup_t *lookup)
{
	char option_store[256];
	char *cmd, *value, *ptr;
	isc_boolean_t state = ISC_TRUE;
#ifdef DIG_SIGCHASE
	size_t n;
#endif

	strlcpy(option_store, option, sizeof(option_store));
	ptr = option_store;
	cmd = next_token(&ptr,"=");
	if (cmd == NULL) {
		printf(";; Invalid option %s\n", option_store);
		return;
	}
	value = ptr;
	if (strncasecmp(cmd, "no", 2)==0) {
		cmd += 2;
		state = ISC_FALSE;
	}

#define FULLCHECK(A) \
	do { \
		size_t _l = strlen(cmd); \
		if (_l >= sizeof(A) || strncasecmp(cmd, A, _l) != 0) \
			goto invalid_option; \
	} while (0)
#define FULLCHECK2(A, B) \
	do { \
		size_t _l = strlen(cmd); \
		if ((_l >= sizeof(A) || strncasecmp(cmd, A, _l) != 0) && \
		    (_l >= sizeof(B) || strncasecmp(cmd, B, _l) != 0)) \
			goto invalid_option; \
	} while (0)

	switch (cmd[0]) {
	case 'a':
		switch (cmd[1]) {
		case 'a': /* aaonly / aaflag */
			FULLCHECK2("aaonly", "aaflag");
			lookup->aaonly = state;
			break;
		case 'd': 
			switch (cmd[2]) {
			case 'd': /* additional */
				FULLCHECK("additional");
				lookup->section_additional = state;
				break;
			case 'f': /* adflag */
				FULLCHECK("adflag");
				lookup->adflag = state;
				break;
			default:
				goto invalid_option;
			}
			break;
		case 'l': /* all */
			FULLCHECK("all");
			lookup->section_question = state;
			lookup->section_authority = state;
			lookup->section_answer = state;
			lookup->section_additional = state;
			lookup->comments = state;
			lookup->stats = state;
			printcmd = state;
			break;
		case 'n': /* answer */
			FULLCHECK("answer");
			lookup->section_answer = state;
			break;
		case 'u': /* authority */
			FULLCHECK("authority");
			lookup->section_authority = state;
			break;
		default:
			goto invalid_option;
		}
		break;
	case 'b':
		switch (cmd[1]) {
		case 'e':/* besteffort */
			FULLCHECK("besteffort");
			lookup->besteffort = state;
			break;
		case 'u':/* bufsize */
			FULLCHECK("bufsize");
			if (value == NULL)
				goto need_value;
			if (!state)
				goto invalid_option;
			lookup->udpsize = (isc_uint16_t) parse_uint(value,
						    "buffer size", COMMSIZE);
			break;
		default:
			goto invalid_option;
		}
		break;
	case 'c':
		switch (cmd[1]) {
		case 'd':/* cdflag */
			FULLCHECK("cdflag");
			lookup->cdflag = state;
			break;
		case 'l': /* cl */
			FULLCHECK("cl");
			noclass = ISC_TF(!state);
			break;
		case 'm': /* cmd */
			FULLCHECK("cmd");
			printcmd = state;
			break;
		case 'o': /* comments */
			FULLCHECK("comments");
			lookup->comments = state;
			if (lookup == default_lookup)
				pluscomm = state;
			break;
		default:
			goto invalid_option;
		}
		break;
	case 'd':
		switch (cmd[1]) {
		case 'e': /* defname */
			FULLCHECK("defname");
			usesearch = state;
			break;
		case 'n': /* dnssec */	
			FULLCHECK("dnssec");
			if (state && lookup->edns == -1)
				lookup->edns = 0;
			lookup->dnssec = state;
			break;
		case 'o': /* domain */	
			FULLCHECK("domain");
			if (value == NULL)
				goto need_value;
			if (!state)
				goto invalid_option;
			strlcpy(domainopt, value, sizeof(domainopt));
			break;
		default:
			goto invalid_option;
		}
		break;
	case 'e':
		FULLCHECK("edns");
		if (!state) {
			lookup->edns = -1;
			break;
		}
		if (value == NULL)
			goto need_value;
		lookup->edns = (isc_int16_t) parse_uint(value, "edns", 255);
		break;
	case 'f': /* fail */
		FULLCHECK("fail");
		lookup->servfail_stops = state;
		break;
	case 'i':
		switch (cmd[1]) {
		case 'd': /* identify */
			FULLCHECK("identify");
			lookup->identify = state;
			break;
		case 'g': /* ignore */
		default: /* Inherets default for compatibility */
			FULLCHECK("ignore");
			lookup->ignore = ISC_TRUE;
		}
		break;
	case 'm': /* multiline */
		FULLCHECK("multiline");
		multiline = state;
		break;
	case 'n':
		switch (cmd[1]) {
		case 'd': /* ndots */
			FULLCHECK("ndots");
			if (value == NULL)
				goto need_value;
			if (!state)
				goto invalid_option;
			ndots = parse_uint(value, "ndots", MAXNDOTS);
			break;
		case 's': /* nssearch */
			FULLCHECK("nssearch");
			lookup->ns_search_only = state;
			if (state) {
				lookup->trace_root = ISC_TRUE;
				lookup->recurse = ISC_TRUE;
				lookup->identify = ISC_TRUE;
				lookup->stats = ISC_FALSE;
				lookup->comments = ISC_FALSE;
				lookup->section_additional = ISC_FALSE;
				lookup->section_authority = ISC_FALSE;
				lookup->section_question = ISC_FALSE;
				lookup->rdtype = dns_rdatatype_ns;
				lookup->rdtypeset = ISC_TRUE;
				short_form = ISC_TRUE;
			}
			break;
		default:
			goto invalid_option;
		}
		break;
	case 'q': 
		switch (cmd[1]) {
		case 'r': /* qr */
			FULLCHECK("qr");
			qr = state;
			break;
		case 'u': /* question */
			FULLCHECK("question");
			lookup->section_question = state;
			if (lookup == default_lookup)
				plusquest = state;
			break;
		default:
			goto invalid_option;
		}
		break;
	case 'r':
		switch (cmd[1]) {
		case 'e':
			switch (cmd[2]) {
			case 'c': /* recurse */
				FULLCHECK("recurse");
				lookup->recurse = state;
				break;
			case 't': /* retry / retries */
				FULLCHECK2("retry", "retries");
				if (value == NULL)
					goto need_value;
				if (!state)
					goto invalid_option;
				lookup->retries = parse_uint(value, "retries",
						       MAXTRIES - 1);
				lookup->retries++;
				break;
			default:
				goto invalid_option;
			}
			break;
		default:
			goto invalid_option;
		}
		break;
	case 's':
		switch (cmd[1]) {
		case 'e': /* search */
			FULLCHECK("search");
			usesearch = state;
			break;
		case 'h':
			if (cmd[2] != 'o')
				goto invalid_option;
			switch (cmd[3]) {
			case 'r': /* short */
				FULLCHECK("short");
				short_form = state;
				if (state) {
					printcmd = ISC_FALSE;
					lookup->section_additional = ISC_FALSE;
					lookup->section_answer = ISC_TRUE;
					lookup->section_authority = ISC_FALSE;
					lookup->section_question = ISC_FALSE;
					lookup->comments = ISC_FALSE;
					lookup->stats = ISC_FALSE;
				}
				break;
			case 'w': /* showsearch */
				FULLCHECK("showsearch");
				showsearch = state;
				usesearch = state;
				break;
			default:
				goto invalid_option;
			}
			break;
#ifdef DIG_SIGCHASE
		case 'i': /* sigchase */
		        FULLCHECK("sigchase");
			lookup->sigchase = state;
			if (lookup->sigchase)
				lookup->dnssec = ISC_TRUE;
			break;	
#endif
		case 't': /* stats */
			FULLCHECK("stats");
			lookup->stats = state;
			break;
		default:
			goto invalid_option;
		}
		break;
	case 't':
		switch (cmd[1]) {
		case 'c': /* tcp */
			FULLCHECK("tcp");
			if (!is_batchfile)
				lookup->tcp_mode = state;
			break;
		case 'i': /* timeout */
			FULLCHECK("timeout");
			if (value == NULL)
				goto need_value;
			if (!state)
				goto invalid_option;
			timeout = parse_uint(value, "timeout", MAXTIMEOUT);
			if (timeout == 0)
				timeout = 1;
			break;
#if DIG_SIGCHASE_TD
		case 'o': /* topdown */	
			FULLCHECK("topdown");
			lookup->do_topdown = state;
			break;
#endif
		case 'r':
			switch (cmd[2]) {
			case 'a': /* trace */
				FULLCHECK("trace");
				lookup->trace = state;
				lookup->trace_root = state;
				if (state) {
					lookup->recurse = ISC_FALSE;
					lookup->identify = ISC_TRUE;
					lookup->comments = ISC_FALSE;
					lookup->stats = ISC_FALSE;
					lookup->section_additional = ISC_FALSE;
					lookup->section_authority = ISC_TRUE;
					lookup->section_question = ISC_FALSE;
				}
				break;
			case 'i': /* tries */
				FULLCHECK("tries");
				if (value == NULL)
					goto need_value;
				if (!state)
					goto invalid_option;
				lookup->retries = parse_uint(value, "tries",
							     MAXTRIES);
				if (lookup->retries == 0)
					lookup->retries = 1;
				break;
#ifdef DIG_SIGCHASE
			case 'u': /* trusted-key */
				FULLCHECK("trusted-key");
			  	if (value == NULL) 
					goto need_value;
				if (!state)
					goto invalid_option;
				n = strlcpy(trustedkey, ptr,
					    sizeof(trustedkey));
				if (n >= sizeof(trustedkey))
					fatal("trusted key too large");
				break;
#endif
			default:
				goto invalid_option;
			}
			break;
		case 't': /* ttlid */
			FULLCHECK("ttlid");
			nottl = ISC_TF(!state);
			break;
		default:
			goto invalid_option;
		}
		break;
	case 'v':
		FULLCHECK("vc");
		if (!is_batchfile)
			lookup->tcp_mode = state;
		break;
	default:
	invalid_option:
	need_value:
		fprintf(stderr, "Invalid option: +%s\n",
			 option);
		usage();
	}
	return;
}

/*%
 * #ISC_TRUE returned if value was used
 */
static const char *single_dash_opts = "46dhimnv";
static const char *dash_opts = "46bcdfhikmnptvyx";
static isc_boolean_t
dash_option(char *option, char *next, dig_lookup_t **lookup,
	    isc_boolean_t *open_type_class, isc_boolean_t *need_clone,
	    isc_boolean_t config_only, int argc, char **argv,
	    isc_boolean_t *firstarg)
{
	char opt, *value, *ptr, *ptr2, *ptr3;
	isc_result_t result;
	isc_boolean_t value_from_next;
	isc_textregion_t tr;
	dns_rdatatype_t rdtype;
	dns_rdataclass_t rdclass;
	char textname[MXNAME];
	struct in_addr in4;
	struct in6_addr in6;
	in_port_t srcport;
	char *hash, *cmd;

	while (strpbrk(option, single_dash_opts) == &option[0]) {
		/*
		 * Since the -[46dhimnv] options do not take an argument,
		 * account for them (in any number and/or combination)
		 * if they appear as the first character(s) of a q-opt.
		 */
		opt = option[0];
		switch (opt) {
		case '4':
			if (have_ipv4) {
				isc_net_disableipv6();
				have_ipv6 = ISC_FALSE;
			} else {
				fatal("can't find IPv4 networking");
				return (ISC_FALSE);
			}
			break;
		case '6':
			if (have_ipv6) {
				isc_net_disableipv4();
				have_ipv4 = ISC_FALSE;
			} else {
				fatal("can't find IPv6 networking");
				return (ISC_FALSE);
			}
			break;
		case 'd':
			ptr = strpbrk(&option[1], dash_opts);
			if (ptr != &option[1]) {
				cmd = option;
				FULLCHECK("debug");
				debugging = ISC_TRUE;
				return (ISC_FALSE);
			} else
				debugging = ISC_TRUE;
			break;
		case 'h':
			help();
			exit(0);
			break;
		case 'i':
			ip6_int = ISC_TRUE;
			break;
		case 'm': /* memdebug */
			/* memdebug is handled in preparse_args() */
			break;
		case 'n':
			/* deprecated */
			break;
		case 'v':
			version();
			exit(0);
			break;
		}
		if (strlen(option) > 1U)
			option = &option[1];
		else
			return (ISC_FALSE);
	}
	opt = option[0];
	if (strlen(option) > 1U) {
		value_from_next = ISC_FALSE;
		value = &option[1];
	} else {
		value_from_next = ISC_TRUE;
		value = next;
	}
	if (value == NULL)
		goto invalid_option;
	switch (opt) {
	case 'b':
		hash = strchr(value, '#');
		if (hash != NULL) {
			srcport = (in_port_t)
			  	parse_uint(hash + 1,
					   "port number", MAXPORT);
			*hash = '\0';
		} else
			srcport = 0;
		if (have_ipv6 && inet_pton(AF_INET6, value, &in6) == 1) {
			isc_sockaddr_fromin6(&bind_address, &in6, srcport);
			isc_net_disableipv4();
		} else if (have_ipv4 && inet_pton(AF_INET, value, &in4) == 1) {
			isc_sockaddr_fromin(&bind_address, &in4, srcport);
			isc_net_disableipv6();
		} else {
			if (hash != NULL)
				*hash = '#';
			fatal("invalid address %s", value);
		}
		if (hash != NULL)
			*hash = '#';
		specified_source = ISC_TRUE;
		return (value_from_next);
	case 'c':
		if ((*lookup)->rdclassset) {
			fprintf(stderr, ";; Warning, extra class option\n");
		}
		*open_type_class = ISC_FALSE;
		tr.base = value;
		tr.length = strlen(value);
		result = dns_rdataclass_fromtext(&rdclass,
						 (isc_textregion_t *)&tr);
		if (result == ISC_R_SUCCESS) {
			(*lookup)->rdclass = rdclass;
			(*lookup)->rdclassset = ISC_TRUE;
		} else
			fprintf(stderr, ";; Warning, ignoring "
				"invalid class %s\n",
				value);
		return (value_from_next);
	case 'f':
		batchname = value;
		return (value_from_next);
	case 'k':
		strlcpy(keyfile, value, sizeof(keyfile));
		return (value_from_next);
	case 'p':
		if (parse_uint(value, "port number", MAXPORT) != 53) {
			fprintf(stderr, ";; Error, only port 53 supported\n");
			exit(1);
		}
		return (value_from_next);
	case 'q':
		if (!config_only) {
			if (*need_clone)
				(*lookup) = clone_lookup(default_lookup,
							 ISC_TRUE);
			*need_clone = ISC_TRUE;
			strncpy((*lookup)->textname, value, 
				sizeof((*lookup)->textname));
			(*lookup)->textname[sizeof((*lookup)->textname)-1]=0;
			(*lookup)->trace_root = ISC_TF((*lookup)->trace  ||
						     (*lookup)->ns_search_only);
			(*lookup)->new_search = ISC_TRUE;
			if (*firstarg) {
				printgreeting(argc, argv, *lookup);
				*firstarg = ISC_FALSE;
			}
			ISC_LIST_APPEND(lookup_list, (*lookup), link);
			debug("looking up %s", (*lookup)->textname);
		}
		return (value_from_next);
	case 't':
		*open_type_class = ISC_FALSE;
		if (strncasecmp(value, "ixfr=", 5) == 0) {
			rdtype = dns_rdatatype_ixfr;
			result = ISC_R_SUCCESS;
		} else {
			tr.base = value;
			tr.length = strlen(value);
			result = dns_rdatatype_fromtext(&rdtype,
						(isc_textregion_t *)&tr);
			if (result == ISC_R_SUCCESS &&
			    rdtype == dns_rdatatype_ixfr) {
				result = DNS_R_UNKNOWN;
			}
		}
		if (result == ISC_R_SUCCESS) {
			if ((*lookup)->rdtypeset) {
				fprintf(stderr, ";; Warning, "
						"extra type option\n");
			}
			if (rdtype == dns_rdatatype_ixfr) {
				(*lookup)->rdtype = dns_rdatatype_ixfr;
				(*lookup)->rdtypeset = ISC_TRUE;
				(*lookup)->ixfr_serial =
					parse_uint(&value[5], "serial number",
					  	MAXSERIAL);
				(*lookup)->section_question = plusquest;
				(*lookup)->comments = pluscomm;
			} else {
				(*lookup)->rdtype = rdtype;
				(*lookup)->rdtypeset = ISC_TRUE;
				if (rdtype == dns_rdatatype_axfr) {
					(*lookup)->section_question = plusquest;
					(*lookup)->comments = pluscomm;
				}
				(*lookup)->ixfr_serial = ISC_FALSE;
			}
		} else
			fprintf(stderr, ";; Warning, ignoring "
				 "invalid type %s\n",
				 value);
		return (value_from_next);
	case 'y':
		ptr = next_token(&value,":");	/* hmac type or name */
		if (ptr == NULL) {
			usage();
		}
		ptr2 = next_token(&value, ":");	/* name or secret */
		if (ptr2 == NULL)
			usage();
		ptr3 = next_token(&value,":"); /* secret or NULL */
		if (ptr3 != NULL) {	
			if (strcasecmp(ptr, "hmac-md5") == 0) {
				hmacname = DNS_TSIG_HMACMD5_NAME;
				digestbits = 0;
			} else if (strncasecmp(ptr, "hmac-md5-", 9) == 0) {
				hmacname = DNS_TSIG_HMACMD5_NAME;
				digestbits = parse_uint(&ptr[9],
							"digest-bits [0..128]",
							128);
				digestbits = (digestbits + 7) & ~0x7U;
			} else if (strcasecmp(ptr, "hmac-sha1") == 0) {
				hmacname = DNS_TSIG_HMACSHA1_NAME;
				digestbits = 0;
			} else if (strncasecmp(ptr, "hmac-sha1-", 10) == 0) {
				hmacname = DNS_TSIG_HMACSHA1_NAME;
				digestbits = parse_uint(&ptr[10],
							"digest-bits [0..160]",
							160);
				digestbits = (digestbits + 7) & ~0x7U;
			} else if (strcasecmp(ptr, "hmac-sha224") == 0) {
				hmacname = DNS_TSIG_HMACSHA224_NAME;
				digestbits = 0;
			} else if (strncasecmp(ptr, "hmac-sha224-", 12) == 0) {
				hmacname = DNS_TSIG_HMACSHA224_NAME;
				digestbits = parse_uint(&ptr[12],
							"digest-bits [0..224]",
							224);
				digestbits = (digestbits + 7) & ~0x7U;
			} else if (strcasecmp(ptr, "hmac-sha256") == 0) {
				hmacname = DNS_TSIG_HMACSHA256_NAME;
				digestbits = 0;
			} else if (strncasecmp(ptr, "hmac-sha256-", 12) == 0) {
				hmacname = DNS_TSIG_HMACSHA256_NAME;
				digestbits = parse_uint(&ptr[12],
							"digest-bits [0..256]",
							256);
				digestbits = (digestbits + 7) & ~0x7U;
			} else if (strcasecmp(ptr, "hmac-sha384") == 0) {
				hmacname = DNS_TSIG_HMACSHA384_NAME;
				digestbits = 0;
			} else if (strncasecmp(ptr, "hmac-sha384-", 12) == 0) {
				hmacname = DNS_TSIG_HMACSHA384_NAME;
				digestbits = parse_uint(&ptr[12],
							"digest-bits [0..384]",
							384);
				digestbits = (digestbits + 7) & ~0x7U;
			} else if (strcasecmp(ptr, "hmac-sha512") == 0) {
				hmacname = DNS_TSIG_HMACSHA512_NAME;
				digestbits = 0;
			} else if (strncasecmp(ptr, "hmac-sha512-", 12) == 0) {
				hmacname = DNS_TSIG_HMACSHA512_NAME;
				digestbits = parse_uint(&ptr[12],
							"digest-bits [0..512]",
							512);
				digestbits = (digestbits + 7) & ~0x7U;
			} else {
				fprintf(stderr, ";; Warning, ignoring "
					"invalid TSIG algorithm %s\n", ptr);
				return (value_from_next);
			}
			ptr = ptr2;
			ptr2 = ptr3;
		} else  {
			hmacname = DNS_TSIG_HMACMD5_NAME;
			digestbits = 0;
		}
		strlcpy(keynametext, ptr, sizeof(keynametext));
		keynametext[sizeof(keynametext)-1]=0;
		strlcpy(keysecret, ptr2, sizeof(keysecret));
		keysecret[sizeof(keysecret)-1]=0;
		return (value_from_next);
	case 'x':
		if (*need_clone)
			*lookup = clone_lookup(default_lookup, ISC_TRUE);
		*need_clone = ISC_TRUE;
		if (get_reverse(textname, sizeof(textname), value,
				ip6_int, ISC_FALSE) == ISC_R_SUCCESS) {
			strlcpy((*lookup)->textname, textname,
				sizeof((*lookup)->textname));
			debug("looking up %s", (*lookup)->textname);
			(*lookup)->trace_root = ISC_TF((*lookup)->trace  ||
						(*lookup)->ns_search_only);
			(*lookup)->ip6_int = ip6_int;
			if (!(*lookup)->rdtypeset)
				(*lookup)->rdtype = dns_rdatatype_ptr;
			if (!(*lookup)->rdclassset)
				(*lookup)->rdclass = dns_rdataclass_in;
			(*lookup)->new_search = ISC_TRUE;
			if (*firstarg) {
				printgreeting(argc, argv, *lookup);
				*firstarg = ISC_FALSE;
			}
			ISC_LIST_APPEND(lookup_list, *lookup, link);
		} else {
			fprintf(stderr, "Invalid IP address %s\n", value);
			exit(1);
		}
		return (value_from_next);
	invalid_option:
	default:
		fprintf(stderr, "Invalid option: -%s\n", option);
		usage();
	}
	return (ISC_FALSE);
}

/*%
 * Because we may be trying to do memory allocation recording, we're going
 * to need to parse the arguments for the -m *before* we start the main
 * argument parsing routine.
 *
 * I'd prefer not to have to do this, but I am not quite sure how else to
 * fix the problem.  Argument parsing in dig involves memory allocation
 * by its nature, so it can't be done in the main argument parser.
 */
static void
preparse_args(int argc, char **argv) {
	int rc;
	char **rv;
	char *option;

	rc = argc;
	rv = argv;
	for (rc--, rv++; rc > 0; rc--, rv++) {
		if (rv[0][0] != '-')
			continue;
		option = &rv[0][1];
		while (strpbrk(option, single_dash_opts) == &option[0]) {
			if (option[0] == 'm') {
				memdebugging = ISC_TRUE;
				isc_mem_debugging = ISC_MEM_DEBUGTRACE |
					ISC_MEM_DEBUGRECORD;
				return;
			}
			option = &option[1];
		}
	}
}

static void
getaddresses(dig_lookup_t *lookup, const char *host) {
	isc_result_t result;
	isc_sockaddr_t sockaddrs[DIG_MAX_ADDRESSES];
	isc_netaddr_t netaddr;
	int count, i;
	dig_server_t *srv;
	char tmp[ISC_NETADDR_FORMATSIZE];

	result = bind9_getaddresses(host, 0, sockaddrs,
				    DIG_MAX_ADDRESSES, &count);   
	if (result != ISC_R_SUCCESS)
	fatal("couldn't get address for '%s': %s",
	      host, isc_result_totext(result));

	for (i = 0; i < count; i++) {
		isc_netaddr_fromsockaddr(&netaddr, &sockaddrs[i]);
		isc_netaddr_format(&netaddr, tmp, sizeof(tmp));
		srv = make_server(tmp, 0, host);
		ISC_LIST_APPEND(lookup->my_server_list, srv, link);
	}
	addresscount = count;
}

static void
parse_args(isc_boolean_t is_batchfile, isc_boolean_t config_only,
	   int argc, char **argv) {
	isc_result_t result;
	isc_textregion_t tr;
	isc_boolean_t firstarg = ISC_TRUE;
	dig_lookup_t *lookup = NULL;
	dns_rdatatype_t rdtype;
	dns_rdataclass_t rdclass;
	isc_boolean_t open_type_class = ISC_TRUE;
	char batchline[MXNAME];
	int bargc;
	char *bargv[64];
	int rc;
	char **rv;
#ifndef NOPOSIX
	char *homedir;
	char rcfile[256];
#endif
	char *input;
	int i;
	isc_boolean_t need_clone = ISC_TRUE;

	/*
	 * The semantics for parsing the args is a bit complex; if
	 * we don't have a host yet, make the arg apply globally,
	 * otherwise make it apply to the latest host.  This is
	 * a bit different than the previous versions, but should
	 * form a consistent user interface.
	 *
	 * First, create a "default lookup" which won't actually be used
	 * anywhere, except for cloning into new lookups
	 */

	debug("parse_args()");
	if (!is_batchfile) {
		debug("making new lookup");
		default_lookup = make_empty_lookup();

#ifndef NOPOSIX
		/*
		 * Treat ${HOME}/.digrc as a special batchfile
		 */
		INSIST(batchfp == NULL);
		homedir = getenv("HOME");
		if (homedir != NULL) {
			int n;
			n = snprintf(rcfile, sizeof(rcfile), "%s/.digrc",
			             homedir);
			if ((size_t)n < sizeof(rcfile) && n != -1)
				batchfp = fopen(rcfile, "r");
		}
		if (batchfp != NULL) {
			while (fgets(batchline, sizeof(batchline),
				     batchfp) != NULL) {
				debug("config line %s", batchline);
				bargc = 1;
				input = batchline;
				bargv[bargc] = next_token(&input, " \t\r\n");
				while ((bargv[bargc] != NULL) &&
				       (bargc < 62)) {
					bargc++;
					bargv[bargc] =
						next_token(&input, " \t\r\n");
				}

				bargv[0] = argv[0];
				argv0 = argv[0];

				for(i = 0; i < bargc; i++)
					debug(".digrc argv %d: %s",
					      i, bargv[i]);
				parse_args(ISC_TRUE, ISC_TRUE, bargc,
					   (char **)bargv);
			}
			fclose(batchfp);
		}
#endif
	}

	if (is_batchfile && !config_only) {
		/* Processing '-f batchfile'. */
		lookup = clone_lookup(default_lookup, ISC_TRUE);
		need_clone = ISC_FALSE;
	} else
		lookup = default_lookup;

	rc = argc;
	rv = argv;
	for (rc--, rv++; rc > 0; rc--, rv++) {
		debug("main parsing %s", rv[0]);
		if (strncmp(rv[0], "%", 1) == 0)
			break;
		if (strncmp(rv[0], "@@", 1) == 0) {
			getaddresses(lookup, &rv[0][1]);
		} else if (rv[0][0] == '+') {
			plus_option(&rv[0][1], is_batchfile,
				    lookup);
		} else if (rv[0][0] == '-') {
			if (rc <= 1) {
				if (dash_option(&rv[0][1], NULL,
						&lookup, &open_type_class,
						&need_clone, config_only,
						argc, argv, &firstarg)) {
					rc--;
					rv++;
				}
			} else {
				if (dash_option(&rv[0][1], rv[1],
						&lookup, &open_type_class,
						&need_clone, config_only,
						argc, argv, &firstarg)) {
					rc--;
					rv++;
				}
			}
		} else {
			/*
			 * Anything which isn't an option
			 */
			if (open_type_class) {
				if (strncasecmp(rv[0], "ixfr=", 5) == 0) {
					rdtype = dns_rdatatype_ixfr;
					result = ISC_R_SUCCESS;
				} else {
					tr.base = rv[0];
					tr.length = strlen(rv[0]);
					result = dns_rdatatype_fromtext(&rdtype,
					     	(isc_textregion_t *)&tr);
					if (result == ISC_R_SUCCESS &&
					    rdtype == dns_rdatatype_ixfr) {
						result = DNS_R_UNKNOWN;
						fprintf(stderr, ";; Warning, "
							"ixfr requires a "
							"serial number\n");
						continue;
					}
				}
				if (result == ISC_R_SUCCESS) {
					if (lookup->rdtypeset) {
						fprintf(stderr, ";; Warning, "
							"extra type option\n");
					}
					if (rdtype == dns_rdatatype_ixfr) {
						lookup->rdtype =
							dns_rdatatype_ixfr;
						lookup->rdtypeset = ISC_TRUE;
						lookup->ixfr_serial =
							parse_uint(&rv[0][5],
							  	"serial number",
							  	MAXSERIAL);
						lookup->section_question =
							plusquest;
						lookup->comments = pluscomm;
					} else {
						lookup->rdtype = rdtype;
						lookup->rdtypeset = ISC_TRUE;
						if (rdtype ==
						    dns_rdatatype_axfr) {
						    lookup->section_question =
								plusquest;
						    lookup->comments = pluscomm;
						}
						lookup->ixfr_serial = ISC_FALSE;
					}
					continue;
				}
				result = dns_rdataclass_fromtext(&rdclass,
						     (isc_textregion_t *)&tr);
				if (result == ISC_R_SUCCESS) {
					if (lookup->rdclassset) {
						fprintf(stderr, ";; Warning, "
							"extra class option\n");
					}
					lookup->rdclass = rdclass;
					lookup->rdclassset = ISC_TRUE;
					continue;
				}
			}

			if (!config_only) {
				if (need_clone)
					lookup = clone_lookup(default_lookup,
								      ISC_TRUE);
				need_clone = ISC_TRUE;
				strlcpy(lookup->textname, rv[0], 
					sizeof(lookup->textname));
				lookup->trace_root = ISC_TF(lookup->trace  ||
						     lookup->ns_search_only);
				lookup->new_search = ISC_TRUE;
				if (firstarg) {
					printgreeting(argc, argv, lookup);
					firstarg = ISC_FALSE;
				}
				ISC_LIST_APPEND(lookup_list, lookup, link);
				debug("looking up %s", lookup->textname);
			}
			/* XXX Error message */
		}
	}

	/*
	 * If we have a batchfile, seed the lookup list with the
	 * first entry, then trust the callback in dighost_shutdown
	 * to get the rest
	 */
	if ((batchname != NULL) && !(is_batchfile)) {
		if (strcmp(batchname, "-") == 0)
			batchfp = stdin;
		else
			batchfp = fopen(batchname, "r");
		if (batchfp == NULL) {
			perror(batchname);
			if (exitcode < 8)
				exitcode = 8;
			fatal("couldn't open specified batch file");
		}
		/* XXX Remove code dup from shutdown code */
	next_line:
		if (fgets(batchline, sizeof(batchline), batchfp) != NULL) {
			bargc = 1;
			debug("batch line %s", batchline);
			if (batchline[0] == '\r' || batchline[0] == '\n'
			    || batchline[0] == '#' || batchline[0] == ';')
				goto next_line;
			input = batchline;
			bargv[bargc] = next_token(&input, " \t\r\n");
			while ((bargv[bargc] != NULL) && (bargc < 14)) {
				bargc++;
				bargv[bargc] = next_token(&input, " \t\r\n");
			}

			bargv[0] = argv[0];
			argv0 = argv[0];

			for(i = 0; i < bargc; i++)
				debug("batch argv %d: %s", i, bargv[i]);
			parse_args(ISC_TRUE, ISC_FALSE, bargc, (char **)bargv);
			return;
		}
		return;
	}
	/*
	 * If no lookup specified, search for root
	 */
	if ((lookup_list.head == NULL) && !config_only) {
		if (need_clone)
			lookup = clone_lookup(default_lookup, ISC_TRUE);
		need_clone = ISC_TRUE;
		lookup->trace_root = ISC_TF(lookup->trace ||
					    lookup->ns_search_only);
		lookup->new_search = ISC_TRUE;
		strlcpy(lookup->textname, ".", sizeof(lookup->textname));
		lookup->rdtype = dns_rdatatype_ns;
		lookup->rdtypeset = ISC_TRUE;
		if (firstarg) {
			printgreeting(argc, argv, lookup);
			firstarg = ISC_FALSE;
		}
		ISC_LIST_APPEND(lookup_list, lookup, link);
	}
	if (!need_clone)
		destroy_lookup(lookup);
}

/*
 * Callback from dighost.c to allow program-specific shutdown code.
 * Here, we're possibly reading from a batch file, then shutting down
 * for real if there's nothing in the batch file to read.
 */
void
dighost_shutdown(void) {
	char batchline[MXNAME];
	int bargc;
	char *bargv[16];
	char *input;
	int i;

	if (batchname == NULL) {
		isc_app_shutdown();
		return;
	}

	fflush(stdout);
	if (feof(batchfp)) {
		batchname = NULL;
		isc_app_shutdown();
		if (batchfp != stdin)
			fclose(batchfp);
		return;
	}

	if (fgets(batchline, sizeof(batchline), batchfp) != NULL) {
		debug("batch line %s", batchline);
		bargc = 1;
		input = batchline;
		bargv[bargc] = next_token(&input, " \t\r\n");
		while ((bargv[bargc] != NULL) && (bargc < 14)) {
			bargc++;
			bargv[bargc] = next_token(&input, " \t\r\n");
		}

		bargv[0] = argv0;

		for(i = 0; i < bargc; i++)
			debug("batch argv %d: %s", i, bargv[i]);
		parse_args(ISC_TRUE, ISC_FALSE, bargc, (char **)bargv);
		start_lookup();
	} else {
		batchname = NULL;
		if (batchfp != stdin)
			fclose(batchfp);
		isc_app_shutdown();
		return;
	}
}

/*% Main processing routine for dig */
int
main(int argc, char **argv) {
	isc_result_t result;

	ISC_LIST_INIT(lookup_list);
	ISC_LIST_INIT(server_list);
	ISC_LIST_INIT(search_list);

	if (pledge("stdio rpath dns", NULL) == -1) {
		perror("pledge");
		exit(1);
	}

	debug("main()");
	preparse_args(argc, argv);
	progname = argv[0];
	result = isc_app_start();
	check_result(result, "isc_app_start");
	setup_libs();
	parse_args(ISC_FALSE, ISC_FALSE, argc, argv);

	if (pledge("stdio dns", NULL) == -1) {
		perror("pledge");
		exit(1);
	}

	setup_system();
	if (domainopt[0] != '\0') {
		set_search_domain(domainopt);
		usesearch = ISC_TRUE;
	}
	result = isc_app_onrun(mctx, global_task, onrun_callback, NULL);
	check_result(result, "isc_app_onrun");
	isc_app_run();
	destroy_lookup(default_lookup);
	if (batchname != NULL) {
		if (batchfp != stdin)
			fclose(batchfp);
		batchname = NULL;
	}
#ifdef DIG_SIGCHASE
	clean_trustedkey();
#endif
	cancel_all();
	destroy_libs();
	isc_app_finish();
	return (exitcode);
}
@


1.16
log
@exit() after perror() for pledge failure.  Perhaps this got introduced
as a test idiom, either when pledge was young or during the transition
to strings.... dunno
@
text
@a151 1
"                 -p port             (specify port number)\n"
d1194 4
a1197 2
		fprintf(stderr, ";; Warning, -p option ignored\n");
		/* port = (in_port_t) parse_uint(value, "port number", MAXPORT); */
@


1.15
log
@pledge bind(1), dig(1), and nslookup(1).  This modifies the underlying
ISC library to use socket(2) with the SOCK_DNS flag.  As a result, the
port commands are disabled (such practice is rare in the wild these days,
and pretty incompatible with the DNS vs regular socket concept in pledge..)
ok bluhm phessler reyk, etc
@
text
@d1758 1
a1758 1
	if (pledge("stdio rpath dns", NULL) == -1)
d1760 2
d1771 1
a1771 1
	if (pledge("stdio dns", NULL) == -1)
d1773 2
@


1.14
log
@parse "nameserver [host]:port" syntax in /etc/resolv.conf

ok deraadt@@
@
text
@d24 1
d1195 2
a1196 1
		port = (in_port_t) parse_uint(value, "port number", MAXPORT);
d1758 3
d1768 4
@


1.13
log
@resolve conflicts
@
text
@d1424 1
a1424 1
		srv = make_server(tmp, host);
@


1.12
log
@resolve conflicts and regen configure script
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
d5 1
a5 1
 * Permission to use, copy, modify, and distribute this software for any
d18 3
a20 1
/* $ISC: dig.c,v 1.157.2.13.2.31 2006/07/22 23:52:57 marka Exp $ */
d45 1
d73 1
d93 1
d114 1
d131 1
d137 1
d152 1
d156 1
a156 1
"                 -y name:key         (specify named base64 tsig key)\n"
d168 1
d170 1
d212 1
a212 1
/*
d233 4
a236 2
			printf(";; XFR size: %u records (messages %u)\n",
			       query->rr_count, query->msg_count);
d238 1
a238 1
			printf(";; MSG SIZE  rcvd: %d\n", bytes);
d252 5
a256 2
		printf(";; Received %u bytes from %s(%s) in %d ms\n\n",
		       bytes, fromtext, query->servname,
d272 1
a272 1
/*
d302 1
a302 1
/*
d494 10
a503 1
		}
d606 1
a606 1
/*
a643 36
/*
 * Reorder an argument list so that server names all come at the end.
 * This is a bit of a hack, to allow batch-mode processing to properly
 * handle the server options.
 */
static void
reorder_args(int argc, char *argv[]) {
	int i, j;
	char *ptr;
	int end;

	debug("reorder_args()");
	end = argc - 1;
	while (argv[end][0] == '@@') {
		end--;
		if (end == 0)
			return;
	}
	debug("arg[end]=%s", argv[end]);
	for (i = 1; i < end - 1; i++) {
		if (argv[i][0] == '@@') {
			debug("arg[%d]=%s", i, argv[i]);
			ptr = argv[i];
			for (j = i + 1; j < end; j++) {
				debug("Moving %s to %d", argv[j], j - 1);
				argv[j - 1] = argv[j];
			}
			debug("moving %s to end, %d", ptr, end - 1);
			argv[end - 1] = ptr;
			end--;
			if (end < 1)
				return;
		}
	}
}

d657 1
a657 1
/*
d796 2
d812 10
d921 24
a944 11
		case 'h': /* short */
			FULLCHECK("short");
			short_form = state;
			if (state) {
				printcmd = ISC_FALSE;
				lookup->section_additional = ISC_FALSE;
				lookup->section_answer = ISC_TRUE;
				lookup->section_authority = ISC_FALSE;
				lookup->section_question = ISC_FALSE;
				lookup->comments = ISC_FALSE;
				lookup->stats = ISC_FALSE;
d1053 2
a1054 2
/*
 * ISC_TRUE returned if value was used
d1060 3
a1062 1
	    isc_boolean_t *open_type_class)
d1064 1
a1064 1
	char opt, *value, *ptr;
d1196 20
d1259 1
a1259 1
		ptr = next_token(&value,":");
d1263 70
d1334 3
a1336 4
		ptr = next_token(&value, "");
		if (ptr == NULL)
			usage();
		strlcpy(keysecret, ptr, sizeof(keysecret));
d1339 3
a1341 1
		*lookup = clone_lookup(default_lookup, ISC_TRUE);
d1355 4
d1373 1
a1373 1
/*
d1377 1
d1450 2
d1499 3
a1501 1
				reorder_args(bargc, (char **)bargv);
d1510 6
a1515 1
	lookup = default_lookup;
d1531 3
a1533 1
						&lookup, &open_type_class)) {
d1539 3
a1541 1
						&lookup, &open_type_class)) {
d1609 1
d1611 4
a1614 2
				lookup = clone_lookup(default_lookup,
						      ISC_TRUE);
d1620 4
d1630 1
d1665 2
a1666 1
			reorder_args(bargc, (char **)bargv);
d1668 1
d1670 1
d1676 3
a1678 1
		lookup = clone_lookup(default_lookup, ISC_TRUE);
a1689 3
	} else if (!config_only && firstarg) {
			printgreeting(argc, argv, lookup);
			firstarg = ISC_FALSE;
d1691 2
d1706 1
a1706 1

d1734 2
a1735 1
		reorder_args(bargc, (char **)bargv);
d1747 1
a1750 1
	dig_server_t *s, *s2;
d1771 1
a1771 10
	s = ISC_LIST_HEAD(default_lookup->my_server_list);
	while (s != NULL) {
		debug("freeing server %p belonging to %p",
		      s, default_lookup);
		s2 = s;
		s = ISC_LIST_NEXT(s, link);
		ISC_LIST_DEQUEUE(default_lookup->my_server_list, s2, link);
		isc_mem_free(mctx, s2);
	}
	isc_mem_free(mctx, default_lookup);
@


1.11
log
@fgets(3) returns NULL on error, not 0. No functional change, but it makes
the code easier to read.
OK deraadt
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: dig.c,v 1.157.2.13.2.29 2005/10/14 01:38:40 marka Exp $ */
d1426 1
a1426 1
				if (strncmp(rv[0], "ixfr=", 5) == 0) {
@


1.10
log
@resolve conflicts
@
text
@d1370 1
a1370 1
				     batchfp) != 0) {
d1516 1
a1516 1
		if (fgets(batchline, sizeof(batchline), batchfp) != 0) {
d1585 1
a1585 1
	if (fgets(batchline, sizeof(batchline), batchfp) != 0) {
@


1.9
log
@Do this correctly, and silence a sign comparison warning.
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: dig.c,v 1.157.2.13.2.25 2004/09/16 02:14:14 marka Exp $ */
a47 4
extern ISC_LIST(dig_lookup_t) lookup_list;
extern dig_serverlist_t server_list;
extern ISC_LIST(dig_searchlist_t) search_list;

a56 22
extern isc_boolean_t have_ipv4, have_ipv6, specified_source,
	usesearch, qr;
extern in_port_t port;
extern unsigned int timeout;
extern isc_mem_t *mctx;
extern dns_messageid_t id;
extern int sendcount;
extern int ndots;
extern int lookup_counter;
extern int exitcode;
extern isc_sockaddr_t bind_address;
extern char keynametext[MXNAME];
extern char keyfile[MXNAME];
extern char keysecret[MXNAME];
#ifdef DIG_SIGCHASE
extern char trustedkey[MXNAME];
#endif
extern dns_tsigkey_t *key;
extern isc_boolean_t validated;
extern isc_taskmgr_t *taskmgr;
extern isc_task_t *global_task;
extern isc_boolean_t free_now;
a58 1
extern isc_boolean_t debugging, memdebugging;
a108 2
extern char *progname;

d567 1
d783 1
a783 1
			noclass = !state;
d856 1
a856 1
				lookup->recurse = ISC_FALSE;
d1018 1
a1018 1
			nottl = !state;
@


1.8
log
@Check snprintf for truncation and failure.  From Han Boetes (thanks).
@
text
@d1393 1
a1393 1
			if (n < sizeof(rcfile) && n != 0)
@


1.7
log
@resolve conflicts
@
text
@d1390 1
a1390 1
			unsigned int n;
d1393 1
a1393 1
			if (n < sizeof(rcfile))
@


1.6
log
@resolve conflicts
@
text
@d18 1
a18 1
/* $ISC: dig.c,v 1.157.2.13.2.20 2004/06/23 04:19:40 marka Exp $ */
d44 2
d59 1
d89 1
d629 7
d1013 1
a1013 1
				lookup->section_question = ISC_FALSE;
d1029 1
d1074 1
a1074 2
	    isc_boolean_t *open_type_class, isc_boolean_t *firstarg,
	    int argc, char **argv)
a1275 4
			if (*lookup && *firstarg) {
				printgreeting(argc, argv, *lookup);
				*firstarg = ISC_FALSE;
			}
d1323 24
a1351 1
	dig_server_t *srv = NULL;
d1431 1
a1431 3
			srv = make_server(&rv[0][1]);
			ISC_LIST_APPEND(lookup->my_server_list,
					srv, link);
d1438 1
a1438 2
						&lookup, &open_type_class,
						&firstarg, argc, argv)) {
d1444 1
a1444 2
						&lookup, &open_type_class,
						&firstarg, argc, argv)) {
a1514 4
				if (firstarg) {
					printgreeting(argc, argv, lookup);
					firstarg = ISC_FALSE;
				}
d1580 3
@


1.5
log
@update to BIND v9.2.3. ok todd@@
@
text
@d2 1
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: dig.c,v 1.157.2.13 2003/07/30 00:42:25 marka Exp $ */
d27 1
a65 1
extern int tries;
d72 3
d91 1
a91 1
	multiline = ISC_FALSE;
d138 2
a139 2
"        {global-d-opt} host [@@local-server] {local-d-opt}\n"
"        [ host [@@local-server] {local-d-opt} [...]]\n", fp);
d151 5
d159 1
a159 1
"Where:  domain	  are in the Domain Name System\n"
d167 1
a167 1
"                 -b address          (bind to source address)\n"
d173 2
a174 2
"                 -4                  (force IPv4 query transport)\n"
"                 -6                  (force IPv6 query transport)\n"
d180 1
d191 1
a191 1
"                 +[no]aaonly         (Set AA flag in query)\n"
d194 1
d204 1
d211 7
d220 3
a222 1
"        local d-opts and servers (after host name) affect only that lookup.\n",
a232 1
	isc_result_t result;
d238 1
a238 2
	result = isc_time_now(&now);
	check_result(result, "isc_time_now");
d247 2
a248 2
			printf(";; XFR size: %d records\n",
			       query->rr_count);
d300 1
a300 3
		result = isc_time_now(&now);
		if (result != ISC_R_SUCCESS)
			return (result);
d363 45
d418 2
a419 1
	const dns_master_style_t *style;
d421 24
a444 4
	if (multiline)
		style = &dns_master_style_default;
	else
		style = &dns_master_style_debug;
d508 1
a508 2
	if (query->lookup->comments && headers && !short_form)
	{
d520 1
a520 1
				return (result);
d598 4
a610 1
	int remaining;
d622 3
a624 7
			remaining = sizeof(lookup->cmdline) -
				    strlen(lookup->cmdline) - 1;
			strncat(lookup->cmdline, append, remaining);
		}
		remaining = sizeof(lookup->cmdline) -
			    strlen(lookup->cmdline) - 1;
		strncat(lookup->cmdline, "\n", remaining);
d626 1
a626 1
			snprintf(append, sizeof (append), 
d631 1
a631 3
			remaining = sizeof(lookup->cmdline) -
				    strlen(lookup->cmdline) - 1;
			strncat(lookup->cmdline, append, remaining);
d674 1
a674 1
	char *endp;
d677 5
a681 5
	tmp = strtoul(arg, &endp, 10);
	if (*endp != '\0')
		fatal("%s '%s' must be numeric", desc, arg);
	if (tmp > max)
		fatal("%s '%s' out of range", desc, arg);
d699 3
a703 1
	option_store[sizeof(option_store)-1]=0;
d705 1
a705 1
	cmd=next_token(&ptr,"=");
d707 1
a707 1
		printf(";; Invalid option %s\n",option_store);
d710 2
a711 2
	value=ptr;
	if (strncasecmp(cmd,"no",2)==0) {
d715 15
d733 2
a734 1
		case 'a': /* aaflag */
d740 1
d744 1
d752 1
d762 1
d766 1
d776 1
d780 1
d795 1
d798 4
d803 1
d807 1
d819 1
d823 1
d827 1
d839 1
d845 1
d850 1
d855 1
d861 1
d869 1
d892 1
d896 1
d905 25
a929 2
	case 'r': /* recurse */
		lookup->recurse = state;
d934 1
d938 1
d950 8
d959 1
d969 1
d974 1
d983 6
d992 1
d1002 1
a1002 1
					lookup->section_question = ISC_FALSE;
d1006 1
d1011 2
a1012 2
				lookup->retries = parse_uint(value, "retries",
						       MAXTRIES);
d1016 12
d1032 4
d1041 1
d1058 2
d1062 2
a1063 3
	    isc_boolean_t *open_type_class,
		isc_boolean_t *firstarg,
		int argc, char **argv)
d1065 1
a1065 1
	char cmd, *value, *ptr;
d1074 2
d1077 60
a1136 1
	cmd = option[0];
a1143 30
	switch (cmd) {
	case 'd':
		debugging = ISC_TRUE;
		return (ISC_FALSE);
	case 'h':
		help();
		exit(0);
		break;
	case 'i':
		ip6_int = ISC_TRUE;
		return (ISC_FALSE);
	case 'm': /* memdebug */
		/* memdebug is handled in preparse_args() */
		return (ISC_FALSE);
	case 'n':
		/* deprecated */
		return (ISC_FALSE);
	case '4':
		if (have_ipv4)
			have_ipv6 = ISC_FALSE;
		else
			fatal("can't find v4 networking");
		return (ISC_FALSE);
	case '6':
		if (have_ipv6)
			have_ipv4 = ISC_FALSE;
		else
			fatal("can't find v6 networking");
		return (ISC_FALSE);
	}
d1146 1
a1146 1
	switch (cmd) {
d1148 17
a1164 5
		if (have_ipv6 && inet_pton(AF_INET6, value, &in6) == 1)
			isc_sockaddr_fromin6(&bind_address, &in6, 0);
		else if (have_ipv4 && inet_pton(AF_INET, value, &in4) == 1)
			isc_sockaddr_fromin(&bind_address, &in4, 0);
		else
d1166 3
d1208 1
a1208 2
			    rdtype == dns_rdatatype_ixfr)
			{
d1252 2
a1253 3
		if (get_reverse(textname, value, ip6_int, ISC_TRUE)
		    == ISC_R_SUCCESS)
		{
d1265 1
a1265 2
			if (*lookup && *firstarg)
			{
d1295 1
d1300 11
a1310 5
		if (strcmp(rv[0], "-m") == 0) {
			memdebugging = ISC_TRUE;
			isc_mem_debugging = ISC_MEM_DEBUGTRACE |
				ISC_MEM_DEBUGRECORD;
			return;
a1314 1

d1355 1
a1355 1
		 * Treat .digrc as a special batchfile
d1357 1
d1359 7
a1365 5
		if (homedir != NULL)
			snprintf(rcfile, sizeof(rcfile), "%s/.digrc", homedir);
		else
			strlcpy(rcfile, ".digrc", sizeof(rcfile));
		batchfp = fopen(rcfile, "r");
d1376 2
a1377 1
					bargv[bargc] = next_token(&input, " \t\r\n");
d1435 1
a1435 1
						     	(isc_textregion_t *)&tr);
d1437 1
a1437 2
					    rdtype == dns_rdatatype_ixfr)
					{
d1445 1
a1445 2
				if (result == ISC_R_SUCCESS)
				{
d1451 2
a1452 1
						lookup->rdtype = dns_rdatatype_ixfr;
d1458 2
a1459 1
						lookup->section_question = plusquest;
d1464 3
a1466 2
						if (rdtype == dns_rdatatype_axfr) {
							lookup->section_question =
d1468 1
a1468 1
							lookup->comments = pluscomm;
d1518 1
a1518 1
			fatal("Couldn't open specified batch file");
d1562 3
a1564 3
 * Callback from dighost.c to allow program-specific shutdown code.  Here,
 * Here, we're possibly reading from a batch file, then shutting down for
 * real if there's nothing in the batch file to read.
d1579 1
d1651 3
@


1.4
log
@string cleaning; "Put it in.  If it breaks, tough" Theo.
work by me, useful feedback from krw, jakob, tedu, and tholo
@
text
@d2 1
a2 1
 * Copyright (C) 2000-2002  Internet Software Consortium.
d18 1
a18 1
/* $ISC: dig.c,v 1.157.2.7 2002/03/12 03:55:57 marka Exp $ */
d87 1
a87 1
	nibble = ISC_FALSE, plusquest = ISC_FALSE, pluscomm = ISC_FALSE,
d157 1
a157 1
"                 -n                  (nibble form for reverse IPv6 lookups)\n"
d177 1
a177 1
"                 +[no]recursive      (Recursive mode)\n"
a683 2
			if (lookup->udpsize > COMMSIZE)
				lookup->udpsize = COMMSIZE;
d893 1
a893 1
	if (strlen(option) > 1) {
d908 3
d915 1
a915 1
		nibble = ISC_TRUE;
d1024 3
a1026 1
		if (get_reverse(textname, value, nibble) == ISC_R_SUCCESS) {
d1032 1
a1032 1
			(*lookup)->nibble = nibble;
@


1.3
log
@more snprintf and strlcpy/strlcat fixes. from todd@@ and tedu@@.
@
text
@d622 1
a622 1
	strncpy(option_store, option, sizeof(option_store));
d721 1
a721 2
			strncpy(domainopt, value, sizeof(domainopt));
			domainopt[sizeof(domainopt)-1] = '\0';
d962 1
a962 2
		strncpy(keyfile, value, sizeof(keyfile));
		keyfile[sizeof(keyfile)-1]=0;
d1015 1
a1015 2
		strncpy(keynametext, ptr, sizeof(keynametext));
		keynametext[sizeof(keynametext)-1]=0;
d1019 1
a1019 2
		strncpy(keysecret, ptr, sizeof(keysecret));
		keysecret[sizeof(keysecret)-1]=0;
d1024 1
a1024 1
			strncpy((*lookup)->textname, textname,
d1253 1
a1253 1
				strncpy(lookup->textname, rv[0], 
a1254 1
				lookup->textname[sizeof(lookup->textname)-1]=0;
@


1.2
log
@add option to force IPv4/IPv6
@
text
@d1130 1
a1130 1
			strcpy(rcfile, ".digrc");
d1315 1
a1315 1
		strcpy(lookup->textname, ".");
@


1.1
log
@Initial revision
@
text
@d165 2
d916 12
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 2000-2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: dig.c,v 1.157.2.13.2.20 2004/06/23 04:19:40 marka Exp $ */
a26 1
#include <isc/parseint.h>
d65 1
a71 3
#ifdef DIG_SIGCHASE
extern char trustedkey[MXNAME];
#endif
d87 2
a88 2
	ip6_int = ISC_FALSE, plusquest = ISC_FALSE, pluscomm = ISC_FALSE,
	multiline = ISC_FALSE, nottl = ISC_FALSE, noclass = ISC_FALSE;
d135 2
a136 2
"            {global-d-opt} host [@@local-server] {local-d-opt}\n"
"            [ host [@@local-server] {local-d-opt} [...]]\n", fp);
a147 5
version(void) {
	fputs("DiG " VERSION "\n", stderr);
}

static void
d151 1
a151 1
"Where:  domain	  is in the Domain Name System\n"
d157 1
a157 1
"                 -i                  (IP6.INT reverse IPv6 lookups)\n"
d159 1
a159 1
"                 -b address[#port]   (bind to source address/port)\n"
a164 2
"                 -4                  (use IPv4 query transport only)\n"
"                 -6                  (use IPv6 query transport only)\n"
a169 1
"                 +retry=###          (Set number of UDP retries) [2]\n"
d175 1
a175 1
"                 +[no]recurse        (Recursive mode)\n"
d180 1
a180 1
"                 +[no]aaonly         (Set AA flag in query (+[no]aaflag))\n"
a182 1
"                 +[no]cl             (Control display of class in records)\n"
a191 1
"                 +[no]ttlid          (Control display of ttls in records)\n"
a197 7
#ifdef DIG_SIGCHASE
"                 +[no]sigchase       (Chase DNSSEC signatures)\n"
"                 +trusted-key=####   (Trusted Key when chasing DNSSEC sigs)\n"
#if DIG_SIGCHASE_TD
"                 +[no]topdown        (Do DNSSEC validation top down mode)\n"
#endif
#endif
d200 1
a200 3
"        local d-opts and servers (after host name) affect only that lookup.\n"
"        -h                           (print help and exit)\n"
"        -v                           (print version and exit)\n",
d211 1
d217 2
a218 1
	TIME_NOW(&now);
d227 2
a228 2
			printf(";; XFR size: %u records (messages %u)\n",
			       query->rr_count, query->msg_count);
d280 3
a282 1
		TIME_NOW(&now);
a344 45
#ifdef DIG_SIGCHASE
isc_result_t
printrdataset(dns_name_t *owner_name, dns_rdataset_t *rdataset,
	      isc_buffer_t *target)
{
	isc_result_t result;
	dns_master_style_t *style = NULL;
	unsigned int styleflags = 0;

	if (rdataset == NULL || owner_name == NULL || target == NULL)
		return(ISC_FALSE);

	styleflags |= DNS_STYLEFLAG_REL_OWNER;
	if (nottl)
		styleflags |= DNS_STYLEFLAG_NO_TTL;
	if (noclass)
		styleflags |= DNS_STYLEFLAG_NO_CLASS;
	if (multiline) {
		styleflags |= DNS_STYLEFLAG_OMIT_OWNER;
		styleflags |= DNS_STYLEFLAG_OMIT_CLASS;
		styleflags |= DNS_STYLEFLAG_REL_DATA;
		styleflags |= DNS_STYLEFLAG_OMIT_TTL;
		styleflags |= DNS_STYLEFLAG_TTL;
		styleflags |= DNS_STYLEFLAG_MULTILINE;
		styleflags |= DNS_STYLEFLAG_COMMENT;
	}
	if (multiline || (nottl && noclass))
		result = dns_master_stylecreate(&style, styleflags,
						24, 24, 24, 32, 80, 8, mctx);
	else if (nottl || noclass)
		result = dns_master_stylecreate(&style, styleflags,
						24, 24, 32, 40, 80, 8, mctx);
	else 
		result = dns_master_stylecreate(&style, styleflags,
						24, 32, 40, 48, 80, 8, mctx);
	check_result(result, "dns_master_stylecreate");

	result = dns_master_rdatasettotext(owner_name, rdataset, style, target);

	if (style != NULL)
		dns_master_styledestroy(&style, mctx);
  
	return(result);
}
#endif
d355 1
a355 2
	dns_master_style_t *style = NULL;
	unsigned int styleflags = 0;
d357 4
a360 24
	styleflags |= DNS_STYLEFLAG_REL_OWNER;
	if (nottl)
		styleflags |= DNS_STYLEFLAG_NO_TTL;
	if (noclass)
		styleflags |= DNS_STYLEFLAG_NO_CLASS;
	if (multiline) {
		styleflags |= DNS_STYLEFLAG_OMIT_OWNER;
		styleflags |= DNS_STYLEFLAG_OMIT_CLASS;
		styleflags |= DNS_STYLEFLAG_REL_DATA;
		styleflags |= DNS_STYLEFLAG_OMIT_TTL;
		styleflags |= DNS_STYLEFLAG_TTL;
		styleflags |= DNS_STYLEFLAG_MULTILINE;
		styleflags |= DNS_STYLEFLAG_COMMENT;
	}
	if (multiline || (nottl && noclass))
		result = dns_master_stylecreate(&style, styleflags,
						24, 24, 24, 32, 80, 8, mctx);
	else if (nottl || noclass)
		result = dns_master_stylecreate(&style, styleflags,
						24, 24, 32, 40, 80, 8, mctx);
	else 
		result = dns_master_stylecreate(&style, styleflags,
						24, 32, 40, 48, 80, 8, mctx);
	check_result(result, "dns_master_stylecreate");
d424 2
a425 1
	if (query->lookup->comments && headers && !short_form) {
d437 1
a437 1
				goto cleanup;
a514 4

cleanup:
	if (style != NULL)
		dns_master_styledestroy(&style, mctx);
d544 1
a544 1
			snprintf(append, sizeof(append), 
d594 1
a594 1
	isc_result_t result;
d597 5
a601 5
	result = isc_parse_uint32(&tmp, arg, 10);
	if (result == ISC_R_SUCCESS && tmp > max)
		result = ISC_R_RANGE;
	if (result != ISC_R_SUCCESS)
		fatal("%s '%s': %s", desc, arg, isc_result_totext(result));
a618 3
#ifdef DIG_SIGCHASE
	size_t n;
#endif
d623 1
a623 1
	cmd = next_token(&ptr,"=");
d625 1
a625 1
		printf(";; Invalid option %s\n", option_store);
d628 2
a629 2
	value = ptr;
	if (strncasecmp(cmd, "no", 2)==0) {
a632 15

#define FULLCHECK(A) \
	do { \
		size_t _l = strlen(cmd); \
		if (_l >= sizeof(A) || strncasecmp(cmd, A, _l) != 0) \
			goto invalid_option; \
	} while (0)
#define FULLCHECK2(A, B) \
	do { \
		size_t _l = strlen(cmd); \
		if ((_l >= sizeof(A) || strncasecmp(cmd, A, _l) != 0) && \
		    (_l >= sizeof(B) || strncasecmp(cmd, B, _l) != 0)) \
			goto invalid_option; \
	} while (0)

d636 1
a636 2
		case 'a': /* aaonly / aaflag */
			FULLCHECK2("aaonly", "aaflag");
a641 1
				FULLCHECK("additional");
a644 1
				FULLCHECK("adflag");
a651 1
			FULLCHECK("all");
a660 1
			FULLCHECK("answer");
a663 1
			FULLCHECK("authority");
a672 1
			FULLCHECK("besteffort");
a675 1
			FULLCHECK("bufsize");
d682 2
a691 1
			FULLCHECK("cdflag");
a693 4
		case 'l': /* cl */
			FULLCHECK("cl");
			noclass = !state;
			break;
a694 1
			FULLCHECK("cmd");
a697 1
			FULLCHECK("comments");
a708 1
			FULLCHECK("defname");
a711 1
			FULLCHECK("dnssec");
a714 1
			FULLCHECK("domain");
a726 1
		FULLCHECK("fail");
a731 1
			FULLCHECK("identify");
a735 1
			FULLCHECK("ignore");
a739 1
		FULLCHECK("multiline");
a744 1
			FULLCHECK("ndots");
a751 1
			FULLCHECK("nssearch");
a773 1
			FULLCHECK("qr");
a776 1
			FULLCHECK("question");
d785 2
a786 25
	case 'r':
		switch (cmd[1]) {
		case 'e':
			switch (cmd[2]) {
			case 'c': /* recurse */
				FULLCHECK("recurse");
				lookup->recurse = state;
				break;
			case 't': /* retry / retries */
				FULLCHECK2("retry", "retries");
				if (value == NULL)
					goto need_value;
				if (!state)
					goto invalid_option;
				lookup->retries = parse_uint(value, "retries",
						       MAXTRIES - 1);
				lookup->retries++;
				break;
			default:
				goto invalid_option;
			}
			break;
		default:
			goto invalid_option;
		}
a790 1
			FULLCHECK("search");
a793 1
			FULLCHECK("short");
a804 8
#ifdef DIG_SIGCHASE
		case 'i': /* sigchase */
		        FULLCHECK("sigchase");
			lookup->sigchase = state;
			if (lookup->sigchase)
				lookup->dnssec = ISC_TRUE;
			break;	
#endif
a805 1
			FULLCHECK("stats");
a814 1
			FULLCHECK("tcp");
a818 1
			FULLCHECK("timeout");
a826 6
#if DIG_SIGCHASE_TD
		case 'o': /* topdown */	
			FULLCHECK("topdown");
			lookup->do_topdown = state;
			break;
#endif
a829 1
				FULLCHECK("trace");
d839 1
a839 1
				lookup->section_question = ISC_FALSE;
a842 1
				FULLCHECK("tries");
d847 2
a848 2
				lookup->retries = parse_uint(value, "tries",
							     MAXTRIES);
a851 12
#ifdef DIG_SIGCHASE
			case 'u': /* trusted-key */
			  	if (value == NULL) 
					goto need_value;
				if (!state)
					goto invalid_option;
				n = strlcpy(trustedkey, ptr,
					    sizeof(trustedkey));
				if (n >= sizeof(trustedkey))
					fatal("trusted key too large");
				break;
#endif
a855 4
		case 't': /* ttlid */
			FULLCHECK("ttlid");
			nottl = !state;
			break;
a860 1
		FULLCHECK("vc");
a876 2
static const char *single_dash_opts = "46dhimnv";
static const char *dash_opts = "46bcdfhikmnptvyx";
d879 3
a881 2
	    isc_boolean_t *open_type_class, isc_boolean_t *firstarg,
	    int argc, char **argv)
d883 1
a883 1
	char opt, *value, *ptr;
a891 2
	in_port_t srcport;
	char *hash, *cmd;
d893 2
a894 61
	while (strpbrk(option, single_dash_opts) == &option[0]) {
		/*
		 * Since the -[46dhimnv] options do not take an argument,
		 * account for them (in any number and/or combination)
		 * if they appear as the first character(s) of a q-opt.
		 */
		opt = option[0];
		switch (opt) {
		case '4':
			if (have_ipv4) {
				isc_net_disableipv6();
				have_ipv6 = ISC_FALSE;
			} else {
				fatal("can't find IPv4 networking");
				return (ISC_FALSE);
			}
			break;
		case '6':
			if (have_ipv6) {
				isc_net_disableipv4();
				have_ipv4 = ISC_FALSE;
			} else {
				fatal("can't find IPv6 networking");
				return (ISC_FALSE);
			}
			break;
		case 'd':
			ptr = strpbrk(&option[1], dash_opts);
			if (ptr != &option[1]) {
				cmd = option;
				FULLCHECK("debug");
				debugging = ISC_TRUE;
				return (ISC_FALSE);
			} else
				debugging = ISC_TRUE;
			break;
		case 'h':
			help();
			exit(0);
			break;
		case 'i':
			ip6_int = ISC_TRUE;
			break;
		case 'm': /* memdebug */
			/* memdebug is handled in preparse_args() */
			break;
		case 'n':
			/* deprecated */
			break;
		case 'v':
			version();
			exit(0);
			break;
		}
		if (strlen(option) > 1U)
			option = &option[1];
		else
			return (ISC_FALSE);
	}
	opt = option[0];
	if (strlen(option) > 1U) {
d901 15
d918 1
a918 1
	switch (opt) {
d920 5
a924 17
		hash = strchr(value, '#');
		if (hash != NULL) {
			srcport = (in_port_t)
			  	parse_uint(hash + 1,
					   "port number", MAXPORT);
			*hash = '\0';
		} else
			srcport = 0;
		if (have_ipv6 && inet_pton(AF_INET6, value, &in6) == 1) {
			isc_sockaddr_fromin6(&bind_address, &in6, srcport);
			isc_net_disableipv4();
		} else if (have_ipv4 && inet_pton(AF_INET, value, &in4) == 1) {
			isc_sockaddr_fromin(&bind_address, &in4, srcport);
			isc_net_disableipv6();
		} else {
			if (hash != NULL)
				*hash = '#';
a925 3
		}
		if (hash != NULL)
			*hash = '#';
d966 2
a967 1
			    rdtype == dns_rdatatype_ixfr) {
d1013 1
a1013 2
		if (get_reverse(textname, sizeof(textname), value,
				ip6_int, ISC_FALSE) == ISC_R_SUCCESS) {
d1019 1
a1019 1
			(*lookup)->ip6_int = ip6_int;
d1025 2
a1026 1
			if (*lookup && *firstarg) {
a1055 1
	char *option;
d1060 5
a1064 11
		if (rv[0][0] != '-')
			continue;
		option = &rv[0][1];
		while (strpbrk(option, single_dash_opts) == &option[0]) {
			if (option[0] == 'm') {
				memdebugging = ISC_TRUE;
				isc_mem_debugging = ISC_MEM_DEBUGTRACE |
					ISC_MEM_DEBUGRECORD;
				return;
			}
			option = &option[1];
d1069 1
d1110 1
a1110 1
		 * Treat ${HOME}/.digrc as a special batchfile
a1111 1
		INSIST(batchfp == NULL);
d1113 5
a1117 7
		if (homedir != NULL) {
			unsigned int n;
			n = snprintf(rcfile, sizeof(rcfile), "%s/.digrc",
			             homedir);
			if (n < sizeof(rcfile))
				batchfp = fopen(rcfile, "r");
		}
d1128 1
a1128 2
					bargv[bargc] =
						next_token(&input, " \t\r\n");
d1186 1
a1186 1
					     	(isc_textregion_t *)&tr);
d1188 2
a1189 1
					    rdtype == dns_rdatatype_ixfr) {
d1197 2
a1198 1
				if (result == ISC_R_SUCCESS) {
d1204 1
a1204 2
						lookup->rdtype =
							dns_rdatatype_ixfr;
d1210 1
a1210 2
						lookup->section_question =
							plusquest;
d1215 2
a1216 3
						if (rdtype ==
						    dns_rdatatype_axfr) {
						    lookup->section_question =
d1218 1
a1218 1
						    lookup->comments = pluscomm;
d1269 1
a1269 1
			fatal("couldn't open specified batch file");
d1313 3
a1315 3
 * Callback from dighost.c to allow program-specific shutdown code.
 * Here, we're possibly reading from a batch file, then shutting down
 * for real if there's nothing in the batch file to read.
a1329 1
	fflush(stdout);
a1400 3
#ifdef DIG_SIGCHASE
	clean_trustedkey();
#endif
@


1.1.1.3
log
@ISC BIND release 9.3.1. ok deraadt@@
@
text
@d18 1
a18 1
/* $ISC: dig.c,v 1.157.2.13.2.25 2004/09/16 02:14:14 marka Exp $ */
a43 2
#include <bind9/getaddresses.h>

a56 1
#define DIG_MAX_ADDRESSES 20
a85 1
static int addresscount = 0;
a629 9
		if (first && addresscount != 0) {
			snprintf(append, sizeof(append),
				 "; (%d server%s found)\n",
				 addresscount,
				 addresscount > 1 ? "s" : "");
			remaining = sizeof(lookup->cmdline) -
				    strlen(lookup->cmdline) - 1;
			strncat(lookup->cmdline, append, remaining);
		}
d1011 1
a1011 1
					lookup->section_question = ISC_FALSE;
a1026 1
				FULLCHECK("trusted-key");
d1071 2
a1072 1
	    isc_boolean_t *open_type_class)
d1277 4
a1327 24
getaddresses(dig_lookup_t *lookup, const char *host) {
	isc_result_t result;
	isc_sockaddr_t sockaddrs[DIG_MAX_ADDRESSES];
	isc_netaddr_t netaddr;
	int count, i;
	dig_server_t *srv;
	char tmp[ISC_NETADDR_FORMATSIZE];

	result = bind9_getaddresses(host, 0, sockaddrs,
				    DIG_MAX_ADDRESSES, &count);   
	if (result != ISC_R_SUCCESS)
	fatal("couldn't get address for '%s': %s",
	      host, isc_result_totext(result));

	for (i = 0; i < count; i++) {
		isc_netaddr_fromsockaddr(&netaddr, &sockaddrs[i]);
		isc_netaddr_format(&netaddr, tmp, sizeof(tmp));
		srv = make_server(tmp, host);
		ISC_LIST_APPEND(lookup->my_server_list, srv, link);
	}
	addresscount = count;
}

static void
d1333 1
d1413 3
a1415 1
			getaddresses(lookup, &rv[0][1]);
d1422 2
a1423 1
						&lookup, &open_type_class)) {
d1429 2
a1430 1
						&lookup, &open_type_class)) {
d1501 4
a1570 3
	} else if (!config_only && firstarg) {
			printgreeting(argc, argv, lookup);
			firstarg = ISC_FALSE;
@


1.1.1.4
log
@ISC BIND release 9.3.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: dig.c,v 1.157.2.13.2.29 2005/10/14 01:38:40 marka Exp $ */
d48 4
d61 22
d85 1
d136 2
a595 1

d821 1
a821 1
			noclass = ISC_TF(!state);
d895 1
a895 1
				lookup->recurse = ISC_TRUE;
d1057 1
a1057 1
			nottl = ISC_TF(!state);
@


1.1.1.5
log
@ISC BIND release 9.3.3
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: dig.c,v 1.157.2.13.2.31 2006/07/22 23:52:57 marka Exp $ */
d1440 1
a1440 1
				if (strncasecmp(rv[0], "ixfr=", 5) == 0) {
@


1.1.1.6
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2007  Internet Systems Consortium, Inc. ("ISC")
d5 1
a5 1
 * Permission to use, copy, modify, and/or distribute this software for any
d18 1
a18 3
/* $ISC: dig.c,v 1.186.18.29 2007/08/28 07:19:55 tbox Exp $ */

/*! \file */
a42 1
#include <dns/tsig.h>
a69 1
/*% opcode text */
a88 1
/*% return code text */
a108 1
/*% print usage */
a124 1
/*% version */
a129 1
/*% help */
a143 1
"                 -q name             (specify query name)\n"
d147 1
a147 1
"                 -y [hmac:]name:key  (specify named base64 tsig key)\n"
a158 1
"                 +edns=###           (Set EDNS version)\n"
a159 1
"                 +[no]showsearch     (Search with intermediate results)\n"
d201 1
a201 1
/*%
d222 2
a223 4
			printf(";; XFR size: %u records (messages %u, "
			       "bytes %" ISC_PRINT_QUADFORMAT "u)\n",
			       query->rr_count, query->msg_count,
			       query->byte_count);
d225 1
a225 1
			printf(";; MSG SIZE  rcvd: %u\n", bytes);
d239 2
a240 5
		printf(";; Received %" ISC_PRINT_QUADFORMAT "u bytes "
		       "from %s(%s) in %d ms\n\n",
		       query->lookup->doing_xfr ?
				query->byte_count : (isc_uint64_t)bytes,
		       fromtext, query->servname,
d256 1
a256 1
/*%
d286 1
a286 1
/*%
d478 1
a478 10

			if (msg != query->lookup->sendmsg &&
			    (msg->flags & DNS_MESSAGEFLAG_RD) != 0 &&
			    (msg->flags & DNS_MESSAGEFLAG_RA) == 0)
				printf(";; WARNING: recursion requested "
				       "but not available\n");
		}
		if (msg != query->lookup->sendmsg && extrabytes != 0U)
			printf(";; WARNING: Messages has %u extra byte%s at "
			       "end\n", extrabytes, extrabytes != 0 ? "s" : "");
d581 1
a581 1
/*%
d628 36
d677 1
a677 1
/*%
a816 2
			if (state && lookup->edns == -1)
				lookup->edns = 0;
a831 10
	case 'e':
		FULLCHECK("edns");
		if (!state) {
			lookup->edns = -1;
			break;
		}
		if (value == NULL)
			goto need_value;
		lookup->edns = (isc_int16_t) parse_uint(value, "edns", 255);
		break;
d931 11
a941 24
		case 'h':
			if (cmd[2] != 'o')
				goto invalid_option;
			switch (cmd[3]) {
			case 'r': /* short */
				FULLCHECK("short");
				short_form = state;
				if (state) {
					printcmd = ISC_FALSE;
					lookup->section_additional = ISC_FALSE;
					lookup->section_answer = ISC_TRUE;
					lookup->section_authority = ISC_FALSE;
					lookup->section_question = ISC_FALSE;
					lookup->comments = ISC_FALSE;
					lookup->stats = ISC_FALSE;
				}
				break;
			case 'w': /* showsearch */
				FULLCHECK("showsearch");
				showsearch = state;
				usesearch = state;
				break;
			default:
				goto invalid_option;
d1050 2
a1051 2
/*%
 * #ISC_TRUE returned if value was used
d1057 1
a1057 3
	    isc_boolean_t *open_type_class, isc_boolean_t *need_clone,
	    isc_boolean_t config_only, int argc, char **argv,
	    isc_boolean_t *firstarg)
d1059 1
a1059 1
	char opt, *value, *ptr, *ptr2, *ptr3;
a1191 20
	case 'q':
		if (!config_only) {
			if (*need_clone)
				(*lookup) = clone_lookup(default_lookup,
							 ISC_TRUE);
			*need_clone = ISC_TRUE;
			strncpy((*lookup)->textname, value, 
				sizeof((*lookup)->textname));
			(*lookup)->textname[sizeof((*lookup)->textname)-1]=0;
			(*lookup)->trace_root = ISC_TF((*lookup)->trace  ||
						     (*lookup)->ns_search_only);
			(*lookup)->new_search = ISC_TRUE;
			if (*firstarg) {
				printgreeting(argc, argv, *lookup);
				*firstarg = ISC_FALSE;
			}
			ISC_LIST_APPEND(lookup_list, (*lookup), link);
			debug("looking up %s", (*lookup)->textname);
		}
		return (value_from_next);
d1235 1
a1235 1
		ptr = next_token(&value,":");	/* hmac type or name */
a1238 70
		ptr2 = next_token(&value, ":");	/* name or secret */
		if (ptr2 == NULL)
			usage();
		ptr3 = next_token(&value,":"); /* secret or NULL */
		if (ptr3 != NULL) {	
			if (strcasecmp(ptr, "hmac-md5") == 0) {
				hmacname = DNS_TSIG_HMACMD5_NAME;
				digestbits = 0;
			} else if (strncasecmp(ptr, "hmac-md5-", 9) == 0) {
				hmacname = DNS_TSIG_HMACMD5_NAME;
				digestbits = parse_uint(&ptr[9],
							"digest-bits [0..128]",
							128);
				digestbits = (digestbits + 7) & ~0x7U;
			} else if (strcasecmp(ptr, "hmac-sha1") == 0) {
				hmacname = DNS_TSIG_HMACSHA1_NAME;
				digestbits = 0;
			} else if (strncasecmp(ptr, "hmac-sha1-", 10) == 0) {
				hmacname = DNS_TSIG_HMACSHA1_NAME;
				digestbits = parse_uint(&ptr[10],
							"digest-bits [0..160]",
							160);
				digestbits = (digestbits + 7) & ~0x7U;
			} else if (strcasecmp(ptr, "hmac-sha224") == 0) {
				hmacname = DNS_TSIG_HMACSHA224_NAME;
				digestbits = 0;
			} else if (strncasecmp(ptr, "hmac-sha224-", 12) == 0) {
				hmacname = DNS_TSIG_HMACSHA224_NAME;
				digestbits = parse_uint(&ptr[12],
							"digest-bits [0..224]",
							224);
				digestbits = (digestbits + 7) & ~0x7U;
			} else if (strcasecmp(ptr, "hmac-sha256") == 0) {
				hmacname = DNS_TSIG_HMACSHA256_NAME;
				digestbits = 0;
			} else if (strncasecmp(ptr, "hmac-sha256-", 12) == 0) {
				hmacname = DNS_TSIG_HMACSHA256_NAME;
				digestbits = parse_uint(&ptr[12],
							"digest-bits [0..256]",
							256);
				digestbits = (digestbits + 7) & ~0x7U;
			} else if (strcasecmp(ptr, "hmac-sha384") == 0) {
				hmacname = DNS_TSIG_HMACSHA384_NAME;
				digestbits = 0;
			} else if (strncasecmp(ptr, "hmac-sha384-", 12) == 0) {
				hmacname = DNS_TSIG_HMACSHA384_NAME;
				digestbits = parse_uint(&ptr[12],
							"digest-bits [0..384]",
							384);
				digestbits = (digestbits + 7) & ~0x7U;
			} else if (strcasecmp(ptr, "hmac-sha512") == 0) {
				hmacname = DNS_TSIG_HMACSHA512_NAME;
				digestbits = 0;
			} else if (strncasecmp(ptr, "hmac-sha512-", 12) == 0) {
				hmacname = DNS_TSIG_HMACSHA512_NAME;
				digestbits = parse_uint(&ptr[12],
							"digest-bits [0..512]",
							512);
				digestbits = (digestbits + 7) & ~0x7U;
			} else {
				fprintf(stderr, ";; Warning, ignoring "
					"invalid TSIG algorithm %s\n", ptr);
				return (value_from_next);
			}
			ptr = ptr2;
			ptr2 = ptr3;
		} else  {
			hmacname = DNS_TSIG_HMACMD5_NAME;
			digestbits = 0;
		}
d1241 4
a1244 1
		strncpy(keysecret, ptr2, sizeof(keysecret));
d1248 1
a1248 3
		if (*need_clone)
			*lookup = clone_lookup(default_lookup, ISC_TRUE);
		*need_clone = ISC_TRUE;
a1261 4
			if (*firstarg) {
				printgreeting(argc, argv, *lookup);
				*firstarg = ISC_FALSE;
			}
d1276 1
a1276 1
/*%
a1279 1
 *
a1351 2
	int i;
	isc_boolean_t need_clone = ISC_TRUE;
d1399 1
a1399 3
				for(i = 0; i < bargc; i++)
					debug(".digrc argv %d: %s",
					      i, bargv[i]);
d1408 1
a1408 6
	if (is_batchfile && !config_only) {
		/* Processing '-f batchfile'. */
		lookup = clone_lookup(default_lookup, ISC_TRUE);
		need_clone = ISC_FALSE;
	} else
		lookup = default_lookup;
d1424 1
a1424 3
						&lookup, &open_type_class,
						&need_clone, config_only,
						argc, argv, &firstarg)) {
d1430 1
a1430 3
						&lookup, &open_type_class,
						&need_clone, config_only,
						argc, argv, &firstarg)) {
a1497 1

d1499 2
a1500 4
				if (need_clone)
					lookup = clone_lookup(default_lookup,
								      ISC_TRUE);
				need_clone = ISC_TRUE;
a1506 4
				if (firstarg) {
					printgreeting(argc, argv, lookup);
					firstarg = ISC_FALSE;
				}
a1512 1

d1547 1
a1547 2
			for(i = 0; i < bargc; i++)
				debug("batch argv %d: %s", i, bargv[i]);
a1548 1
			return;
a1549 1
		return;
d1555 1
a1555 3
		if (need_clone)
			lookup = clone_lookup(default_lookup, ISC_TRUE);
		need_clone = ISC_TRUE;
d1567 3
a1570 2
	if (!need_clone)
		destroy_lookup(lookup);
d1584 1
a1584 1
	int i;
d1612 1
a1612 2
		for(i = 0; i < bargc; i++)
			debug("batch argv %d: %s", i, bargv[i]);
a1623 1
/*% Main processing routine for dig */
d1627 1
d1648 10
a1657 1
	destroy_lookup(default_lookup);
@


