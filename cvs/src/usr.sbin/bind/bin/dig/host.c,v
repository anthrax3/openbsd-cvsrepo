head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.10
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.8
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.8.0.34
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.26
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.30
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.28
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.24
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.22
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.20
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.18
	OPENBSD_5_0:1.8.0.16
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.14
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.12
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.8
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.10
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.6
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	BIND_9_4_2_P1:1.1.1.6
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	BIND_9_4_2:1.1.1.6
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	BIND_9_3_4:1.1.1.5
	BIND_9_3_3:1.1.1.5
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	BIND_9_3_2:1.1.1.4
	OPENBSD_3_9:1.5.0.4
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	BIND_9_3_1:1.1.1.3
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	BIND_9_3_0:1.1.1.2
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	BIND_9_2_2_RC1:1.1.1.1
	ISC:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.11.11.02.52.46;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	6fvHpVQjE6wYuHzb;

1.9
date	2015.10.25.07.44.42;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	M6VL9l5lhUhU7DsW;

1.8
date	2007.12.09.13.39.42;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.10.19.07.58;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.05.17.36.32;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.22.16.52.38;	author jakob;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.28.17.14.03;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.18.14.14.05;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.27.19.08.22;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.20.21.06.04;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.01.20.21.06.04;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.09.28.16.32.49;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.03.22.16.36.15;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.04.05.16.42.02;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2007.01.10.18.18.19;	author jakob;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2007.12.09.12.33.20;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.10
log
@exit() after perror() for pledge failure.  Perhaps this got introduced
as a test idiom, either when pledge was young or during the transition
to strings.... dunno
@
text
@/*
 * Copyright (C) 2004-2007  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 2000-2003  Internet Software Consortium.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* $ISC: host.c,v 1.94.18.19 2007/08/28 07:19:55 tbox Exp $ */

/*! \file */

#include <config.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>

#ifdef HAVE_LOCALE_H
#include <locale.h>
#endif

#ifdef WITH_IDN
#include <idn/result.h>
#include <idn/log.h>
#include <idn/resconf.h>
#include <idn/api.h>
#endif

#include <isc/app.h>
#include <isc/commandline.h>
#include <isc/netaddr.h>
#include <isc/print.h>
#include <isc/string.h>
#include <isc/util.h>
#include <isc/task.h>
#include <isc/stdlib.h>

#include <dns/byaddr.h>
#include <dns/fixedname.h>
#include <dns/message.h>
#include <dns/name.h>
#include <dns/rdata.h>
#include <dns/rdataclass.h>
#include <dns/rdataset.h>
#include <dns/rdatatype.h>
#include <dns/rdatastruct.h>

#include <dig/dig.h>

static isc_boolean_t short_form = ISC_TRUE, listed_server = ISC_FALSE;
static isc_boolean_t default_lookups = ISC_TRUE;
static int seen_error = -1;
static isc_boolean_t list_addresses = ISC_TRUE;
static dns_rdatatype_t list_type = dns_rdatatype_a;
static isc_boolean_t printed_server = ISC_FALSE;

static const char *opcodetext[] = {
	"QUERY",
	"IQUERY",
	"STATUS",
	"RESERVED3",
	"NOTIFY",
	"UPDATE",
	"RESERVED6",
	"RESERVED7",
	"RESERVED8",
	"RESERVED9",
	"RESERVED10",
	"RESERVED11",
	"RESERVED12",
	"RESERVED13",
	"RESERVED14",
	"RESERVED15"
};

static const char *rcodetext[] = {
	"NOERROR",
	"FORMERR",
	"SERVFAIL",
	"NXDOMAIN",
	"NOTIMP",
	"REFUSED",
	"YXDOMAIN",
	"YXRRSET",
	"NXRRSET",
	"NOTAUTH",
	"NOTZONE",
	"RESERVED11",
	"RESERVED12",
	"RESERVED13",
	"RESERVED14",
	"RESERVED15",
	"BADVERS"
};

struct rtype {
	unsigned int type;
	const char *text;
};

struct rtype rtypes[] = {
	{ 1, 	"has address" },
	{ 2, 	"name server" },
	{ 5, 	"is an alias for" },
	{ 11,	"has well known services" },
	{ 12,	"domain name pointer" },
	{ 13,	"host information" },
	{ 15,	"mail is handled by" },
	{ 16,	"descriptive text" },
	{ 19,	"x25 address" },
	{ 20,	"ISDN address" },
	{ 24,	"has signature" },
	{ 25,	"has key" },
	{ 28,	"has IPv6 address" },
	{ 29,	"location" },
	{ 0, NULL }
};

static void
show_usage(void) {
	fputs(
"Usage: host [-aCdlriTwv] [-c class] [-N ndots] [-t type] [-W time]\n"
"            [-R number] [-m flag] hostname [server]\n"
"       -a is equivalent to -v -t ANY\n"
"       -c specifies query class for non-IN data\n"
"       -C compares SOA records on authoritative nameservers\n"
"       -d is equivalent to -v\n"
"       -l lists all hosts in a domain, using AXFR\n"
"       -i IP6.INT reverse lookups\n"
"       -N changes the number of dots allowed before root lookup is done\n"
"       -r disables recursive processing\n"
"       -R specifies number of retries for UDP packets\n"
"       -s a SERVFAIL response should stop query\n"
"       -t specifies the query type\n"
"       -T enables TCP/IP mode\n"
"       -v enables verbose output\n"
"       -w specifies to wait forever for a reply\n"
"       -W specifies how long to wait for a reply\n"
"       -4 use IPv4 query transport only\n"
"       -6 use IPv6 query transport only\n"
"       -m set memory debugging flag (trace|record|usage)\n", stderr);
	exit(1);
}

void
dighost_shutdown(void) {
	isc_app_shutdown();
}

void
received(int bytes, isc_sockaddr_t *from, dig_query_t *query) {
	isc_time_t now;
	int diff;

	if (!short_form) {
		char fromtext[ISC_SOCKADDR_FORMATSIZE];
		isc_sockaddr_format(from, fromtext, sizeof(fromtext));
		TIME_NOW(&now);
		diff = (int) isc_time_microdiff(&now, &query->time_sent);
		printf("Received %u bytes from %s in %d ms\n",
		       bytes, fromtext, diff/1000);
	}
}

void
trying(char *frm, dig_lookup_t *lookup) {
	UNUSED(lookup);

	if (!short_form)
		printf("Trying \"%s\"\n", frm);
}

static void
say_message(dns_name_t *name, const char *msg, dns_rdata_t *rdata,
	    dig_query_t *query)
{
	isc_buffer_t *b = NULL;
	char namestr[DNS_NAME_FORMATSIZE];
	isc_region_t r;
	isc_result_t result;
	unsigned int bufsize = BUFSIZ;

	dns_name_format(name, namestr, sizeof(namestr));
 retry:
	result = isc_buffer_allocate(mctx, &b, bufsize);
	check_result(result, "isc_buffer_allocate");
	result = dns_rdata_totext(rdata, NULL, b);
	if (result == ISC_R_NOSPACE) {
		isc_buffer_free(&b);
		bufsize *= 2;
		goto retry;
	}
	check_result(result, "dns_rdata_totext");
	isc_buffer_usedregion(b, &r);
	if (query->lookup->identify_previous_line) {
		printf("Nameserver %s:\n\t",
			query->servname);
	}
	printf("%s %s %.*s", namestr,
	       msg, (int)r.length, (char *)r.base);
	if (query->lookup->identify) {
		printf(" on server %s", query->servname);
	}
	printf("\n");
	isc_buffer_free(&b);
}
#ifdef DIG_SIGCHASE
/* Just for compatibility : not use in host program */
isc_result_t
printrdataset(dns_name_t *owner_name, dns_rdataset_t *rdataset,
	      isc_buffer_t *target)
{
  UNUSED(owner_name);
  UNUSED(rdataset);
  UNUSED(target);
  return(ISC_FALSE);
}
#endif
static isc_result_t
printsection(dns_message_t *msg, dns_section_t sectionid,
	     const char *section_name, isc_boolean_t headers,
	     dig_query_t *query)
{
	dns_name_t *name, *print_name;
	dns_rdataset_t *rdataset;
	dns_rdata_t rdata = DNS_RDATA_INIT;
	isc_buffer_t target;
	isc_result_t result, loopresult;
	isc_region_t r;
	dns_name_t empty_name;
	char t[4096];
	isc_boolean_t first;
	isc_boolean_t no_rdata;

	if (sectionid == DNS_SECTION_QUESTION)
		no_rdata = ISC_TRUE;
	else
		no_rdata = ISC_FALSE;

	if (headers)
		printf(";; %s SECTION:\n", section_name);

	dns_name_init(&empty_name, NULL);

	result = dns_message_firstname(msg, sectionid);
	if (result == ISC_R_NOMORE)
		return (ISC_R_SUCCESS);
	else if (result != ISC_R_SUCCESS)
		return (result);

	for (;;) {
		name = NULL;
		dns_message_currentname(msg, sectionid, &name);

		isc_buffer_init(&target, t, sizeof(t));
		first = ISC_TRUE;
		print_name = name;

		for (rdataset = ISC_LIST_HEAD(name->list);
		     rdataset != NULL;
		     rdataset = ISC_LIST_NEXT(rdataset, link)) {
			if (query->lookup->rdtype == dns_rdatatype_axfr &&
			    !((!list_addresses &&
			       (list_type == dns_rdatatype_any ||
			        rdataset->type == list_type)) ||
			      (list_addresses &&
			       (rdataset->type == dns_rdatatype_a ||
			        rdataset->type == dns_rdatatype_aaaa ||
				rdataset->type == dns_rdatatype_ns ||
				rdataset->type == dns_rdatatype_ptr))))
				continue;
			if (!short_form) {
				result = dns_rdataset_totext(rdataset,
							     print_name,
							     ISC_FALSE,
							     no_rdata,
							     &target);
				if (result != ISC_R_SUCCESS)
					return (result);
#ifdef USEINITALWS
				if (first) {
					print_name = &empty_name;
					first = ISC_FALSE;
				}
#else
				UNUSED(first); /* Shut up compiler. */
#endif
			} else {
				loopresult = dns_rdataset_first(rdataset);
				while (loopresult == ISC_R_SUCCESS) {
					struct rtype *t;
					const char *rtt;
					char typebuf[DNS_RDATATYPE_FORMATSIZE];
					char typebuf2[DNS_RDATATYPE_FORMATSIZE
						     + 20];
					dns_rdataset_current(rdataset, &rdata);

					for (t = rtypes; t->text != NULL; t++) {
						if (t->type == rdata.type) {
							rtt = t->text;
							goto found;
						}
					}

					dns_rdatatype_format(rdata.type,
							     typebuf,
							     sizeof(typebuf));
					snprintf(typebuf2, sizeof(typebuf2),
						 "has %s record", typebuf);
					rtt = typebuf2;
				found:
					say_message(print_name, rtt,
						    &rdata, query);
					dns_rdata_reset(&rdata);
					loopresult =
						dns_rdataset_next(rdataset);
				}
			}
		}
		if (!short_form) {
			isc_buffer_usedregion(&target, &r);
			if (no_rdata)
				printf(";%.*s", (int)r.length,
				       (char *)r.base);
			else
				printf("%.*s", (int)r.length, (char *)r.base);
		}

		result = dns_message_nextname(msg, sectionid);
		if (result == ISC_R_NOMORE)
			break;
		else if (result != ISC_R_SUCCESS)
			return (result);
	}

	return (ISC_R_SUCCESS);
}

static isc_result_t
printrdata(dns_message_t *msg, dns_rdataset_t *rdataset, dns_name_t *owner,
	   const char *set_name, isc_boolean_t headers)
{
	isc_buffer_t target;
	isc_result_t result;
	isc_region_t r;
	char t[4096];

	UNUSED(msg);
	if (headers)
		printf(";; %s SECTION:\n", set_name);

	isc_buffer_init(&target, t, sizeof(t));

	result = dns_rdataset_totext(rdataset, owner, ISC_FALSE, ISC_FALSE,
				     &target);
	if (result != ISC_R_SUCCESS)
		return (result);
	isc_buffer_usedregion(&target, &r);
	printf("%.*s", (int)r.length, (char *)r.base);

	return (ISC_R_SUCCESS);
}

static void
chase_cnamechain(dns_message_t *msg, dns_name_t *qname) {
	isc_result_t result;
	dns_rdataset_t *rdataset;
	dns_rdata_cname_t cname;
	dns_rdata_t rdata = DNS_RDATA_INIT;
	unsigned int i = msg->counts[DNS_SECTION_ANSWER];

 	while (i-- > 0) {
		rdataset = NULL;
		result = dns_message_findname(msg, DNS_SECTION_ANSWER, qname,
					      dns_rdatatype_cname, 0, NULL,
					      &rdataset);
		if (result != ISC_R_SUCCESS)
			return;
		result = dns_rdataset_first(rdataset);
		check_result(result, "dns_rdataset_first");
		dns_rdata_reset(&rdata);
		dns_rdataset_current(rdataset, &rdata);
		result = dns_rdata_tostruct(&rdata, &cname, NULL);
		check_result(result, "dns_rdata_tostruct");
		dns_name_copy(&cname.cname, qname, NULL);
		dns_rdata_freestruct(&cname);
	}
}

isc_result_t
printmessage(dig_query_t *query, dns_message_t *msg, isc_boolean_t headers) {
	isc_boolean_t did_flag = ISC_FALSE;
	dns_rdataset_t *opt, *tsig = NULL;
	dns_name_t *tsigname;
	isc_result_t result = ISC_R_SUCCESS;
	int force_error;

	UNUSED(headers);

	/*
	 * We get called multiple times.
	 * Preserve any existing error status.
	 */
	force_error = (seen_error == 1) ? 1 : 0;
	seen_error = 1;
	if (listed_server && !printed_server) {
		char sockstr[ISC_SOCKADDR_FORMATSIZE];

		printf("Using domain server:\n");
		printf("Name: %s\n", query->userarg);
		isc_sockaddr_format(&query->sockaddr, sockstr,
				    sizeof(sockstr));
		printf("Address: %s\n", sockstr);
		printf("Aliases: \n\n");
		printed_server = ISC_TRUE;
	}

	if (msg->rcode != 0) {
		char namestr[DNS_NAME_FORMATSIZE];
		dns_name_format(query->lookup->name, namestr, sizeof(namestr));
		printf("Host %s not found: %d(%s)\n",
		       (msg->rcode != dns_rcode_nxdomain) ? namestr :
		       query->lookup->textname, msg->rcode,
		       rcodetext[msg->rcode]);
		return (ISC_R_SUCCESS);
	}

	if (default_lookups && query->lookup->rdtype == dns_rdatatype_a) {
		char namestr[DNS_NAME_FORMATSIZE];
		dig_lookup_t *lookup;
		dns_fixedname_t fixed;
		dns_name_t *name;

		/* Add AAAA and MX lookups. */
		dns_fixedname_init(&fixed);
		name = dns_fixedname_name(&fixed);
		dns_name_copy(query->lookup->name, name, NULL);
		chase_cnamechain(msg, name);
		dns_name_format(name, namestr, sizeof(namestr));
		lookup = clone_lookup(query->lookup, ISC_FALSE);
		if (lookup != NULL) {
			strlcpy(lookup->textname, namestr,
				sizeof(lookup->textname));
			lookup->rdtype = dns_rdatatype_aaaa;
                        lookup->rdtypeset = ISC_TRUE;
			lookup->origin = NULL;
			lookup->retries = tries;
			ISC_LIST_APPEND(lookup_list, lookup, link);
		}
		lookup = clone_lookup(query->lookup, ISC_FALSE);
		if (lookup != NULL) {
			strlcpy(lookup->textname, namestr,
				sizeof(lookup->textname));
			lookup->rdtype = dns_rdatatype_mx;
                        lookup->rdtypeset = ISC_TRUE;
			lookup->origin = NULL;
			lookup->retries = tries;
			ISC_LIST_APPEND(lookup_list, lookup, link);
		}
	}

	if (!short_form) {
		printf(";; ->>HEADER<<- opcode: %s, status: %s, id: %u\n",
		       opcodetext[msg->opcode], rcodetext[msg->rcode],
		       msg->id);
		printf(";; flags: ");
		if ((msg->flags & DNS_MESSAGEFLAG_QR) != 0) {
			printf("qr");
			did_flag = ISC_TRUE;
		}
		if ((msg->flags & DNS_MESSAGEFLAG_AA) != 0) {
			printf("%saa", did_flag ? " " : "");
			did_flag = ISC_TRUE;
		}
		if ((msg->flags & DNS_MESSAGEFLAG_TC) != 0) {
			printf("%stc", did_flag ? " " : "");
			did_flag = ISC_TRUE;
		}
		if ((msg->flags & DNS_MESSAGEFLAG_RD) != 0) {
			printf("%srd", did_flag ? " " : "");
			did_flag = ISC_TRUE;
		}
		if ((msg->flags & DNS_MESSAGEFLAG_RA) != 0) {
			printf("%sra", did_flag ? " " : "");
			did_flag = ISC_TRUE;
		}
		if ((msg->flags & DNS_MESSAGEFLAG_AD) != 0) {
			printf("%sad", did_flag ? " " : "");
			did_flag = ISC_TRUE;
		}
		if ((msg->flags & DNS_MESSAGEFLAG_CD) != 0) {
			printf("%scd", did_flag ? " " : "");
			did_flag = ISC_TRUE;
		}
		printf("; QUERY: %u, ANSWER: %u, "
		       "AUTHORITY: %u, ADDITIONAL: %u\n",
		       msg->counts[DNS_SECTION_QUESTION],
		       msg->counts[DNS_SECTION_ANSWER],
		       msg->counts[DNS_SECTION_AUTHORITY],
		       msg->counts[DNS_SECTION_ADDITIONAL]);
		opt = dns_message_getopt(msg);
		if (opt != NULL)
			printf(";; EDNS: version: %u, udp=%u\n",
			       (unsigned int)((opt->ttl & 0x00ff0000) >> 16),
			       (unsigned int)opt->rdclass);
		tsigname = NULL;
		tsig = dns_message_gettsig(msg, &tsigname);
		if (tsig != NULL)
			printf(";; PSEUDOSECTIONS: TSIG\n");
	}
	if (! ISC_LIST_EMPTY(msg->sections[DNS_SECTION_QUESTION]) &&
	    !short_form) {
		printf("\n");
		result = printsection(msg, DNS_SECTION_QUESTION, "QUESTION",
				      ISC_TRUE, query);
		if (result != ISC_R_SUCCESS)
			return (result);
	}
	if (! ISC_LIST_EMPTY(msg->sections[DNS_SECTION_ANSWER])) {
		if (!short_form)
			printf("\n");
		result = printsection(msg, DNS_SECTION_ANSWER, "ANSWER",
				      ISC_TF(!short_form), query);
		if (result != ISC_R_SUCCESS)
			return (result);
	}

	if (! ISC_LIST_EMPTY(msg->sections[DNS_SECTION_AUTHORITY]) &&
	    !short_form) {
		printf("\n");
		result = printsection(msg, DNS_SECTION_AUTHORITY, "AUTHORITY",
				      ISC_TRUE, query);
		if (result != ISC_R_SUCCESS)
			return (result);
	}
	if (! ISC_LIST_EMPTY(msg->sections[DNS_SECTION_ADDITIONAL]) &&
	    !short_form) {
		printf("\n");
		result = printsection(msg, DNS_SECTION_ADDITIONAL,
				      "ADDITIONAL", ISC_TRUE, query);
		if (result != ISC_R_SUCCESS)
			return (result);
	}
	if ((tsig != NULL) && !short_form) {
		printf("\n");
		result = printrdata(msg, tsig, tsigname,
				    "PSEUDOSECTION TSIG", ISC_TRUE);
		if (result != ISC_R_SUCCESS)
			return (result);
	}
	if (!short_form)
		printf("\n");

	if (short_form && !default_lookups &&
	    ISC_LIST_EMPTY(msg->sections[DNS_SECTION_ANSWER])) {
		char namestr[DNS_NAME_FORMATSIZE];
		char typestr[DNS_RDATATYPE_FORMATSIZE];
		dns_name_format(query->lookup->name, namestr, sizeof(namestr));
		dns_rdatatype_format(query->lookup->rdtype, typestr,
				     sizeof(typestr));
		printf("%s has no %s record\n", namestr, typestr);
	}
	seen_error = force_error;
	return (result);
}

static const char * optstring = "46ac:dilnm:rst:vwCDN:R:TW:";

static void
pre_parse_args(int argc, char **argv) {
	int c;

	while ((c = isc_commandline_parse(argc, argv, optstring)) != -1) {
		switch (c) {
		case 'm':
			memdebugging = ISC_TRUE;
			if (strcasecmp("trace", isc_commandline_argument) == 0)
				isc_mem_debugging |= ISC_MEM_DEBUGTRACE;
			else if (!strcasecmp("record",
					     isc_commandline_argument) == 0)
				isc_mem_debugging |= ISC_MEM_DEBUGRECORD;
			else if (strcasecmp("usage",
					    isc_commandline_argument) == 0)
				isc_mem_debugging |= ISC_MEM_DEBUGUSAGE;
			break;

		case '4': break;
		case '6': break;
		case 'a': break;
		case 'c': break;
		case 'd': break;
		case 'i': break;
		case 'l': break;
		case 'n': break;
		case 'r': break;
		case 's': break;
		case 't': break;
		case 'v': break;
		case 'w': break;
		case 'C': break;
		case 'D': break;
		case 'N': break;
		case 'R': break;
		case 'T': break;
		case 'W': break;
		default:
			show_usage();
		}
	}
	isc_commandline_reset = ISC_TRUE;
	isc_commandline_index = 1;
}

static void
parse_args(isc_boolean_t is_batchfile, int argc, char **argv) {
	char hostname[MXNAME];
	dig_lookup_t *lookup;
	int c;
	char store[MXNAME];
	isc_textregion_t tr;
	isc_result_t result = ISC_R_SUCCESS;
	dns_rdatatype_t rdtype;
	dns_rdataclass_t rdclass;
	isc_uint32_t serial = 0;

	UNUSED(is_batchfile);

	lookup = make_empty_lookup();

	lookup->servfail_stops = ISC_FALSE;
	lookup->comments = ISC_FALSE;

	while ((c = isc_commandline_parse(argc, argv, optstring)) != -1) {
		switch (c) {
		case 'l':
			lookup->tcp_mode = ISC_TRUE;
			lookup->rdtype = dns_rdatatype_axfr;
			lookup->rdtypeset = ISC_TRUE;
			fatalexit = 3;
			break;
		case 'v':
		case 'd':
			short_form = ISC_FALSE;
			break;
		case 'r':
			lookup->recurse = ISC_FALSE;
			break;
		case 't':
			if (strncasecmp(isc_commandline_argument,
					"ixfr=", 5) == 0) {
				rdtype = dns_rdatatype_ixfr;
				/* XXXMPA add error checking */
				serial = strtoul(isc_commandline_argument + 5,
						 NULL, 10);
				result = ISC_R_SUCCESS;
			} else {
				tr.base = isc_commandline_argument;
				tr.length = strlen(isc_commandline_argument);
				result = dns_rdatatype_fromtext(&rdtype,
						   (isc_textregion_t *)&tr);
			}

			if (result != ISC_R_SUCCESS) {
				fatalexit = 2;
				fatal("invalid type: %s\n",
				      isc_commandline_argument);
			}
			if (!lookup->rdtypeset ||
			    lookup->rdtype != dns_rdatatype_axfr)
				lookup->rdtype = rdtype;
			lookup->rdtypeset = ISC_TRUE;
#ifdef WITH_IDN
			idnoptions = 0;
#endif
			if (rdtype == dns_rdatatype_axfr) {
				/* -l -t any -v */
				list_type = dns_rdatatype_any;
				short_form = ISC_FALSE;
				lookup->tcp_mode = ISC_TRUE;
			} else if (rdtype == dns_rdatatype_ixfr) {
				lookup->ixfr_serial = serial;
				list_type = rdtype;
#ifdef WITH_IDN
			} else if (rdtype == dns_rdatatype_a ||
				   rdtype == dns_rdatatype_aaaa ||
				   rdtype == dns_rdatatype_mx) {
				idnoptions = IDN_ASCCHECK;
				list_type = rdtype;
#endif
			} else
				list_type = rdtype;
			list_addresses = ISC_FALSE;
			default_lookups = ISC_FALSE;
			break;
		case 'c':
			tr.base = isc_commandline_argument;
			tr.length = strlen(isc_commandline_argument);
			result = dns_rdataclass_fromtext(&rdclass,
						   (isc_textregion_t *)&tr);

			if (result != ISC_R_SUCCESS) {
				fatalexit = 2;
				fatal("invalid class: %s\n",
				      isc_commandline_argument);
			} else {
				lookup->rdclass = rdclass;
				lookup->rdclassset = ISC_TRUE;
			}
			default_lookups = ISC_FALSE;
			break;
		case 'a':
			if (!lookup->rdtypeset ||
			    lookup->rdtype != dns_rdatatype_axfr)
				lookup->rdtype = dns_rdatatype_any;
			list_type = dns_rdatatype_any;
			list_addresses = ISC_FALSE;
			lookup->rdtypeset = ISC_TRUE;
			short_form = ISC_FALSE;
			default_lookups = ISC_FALSE;
			break;
		case 'i':
			lookup->ip6_int = ISC_TRUE;
			break;
		case 'n':
			/* deprecated */
			break;
		case 'm':
			/* Handled by pre_parse_args(). */
			break;
		case 'w':
			/*
			 * The timer routines are coded such that
			 * timeout==MAXINT doesn't enable the timer
			 */
			timeout = INT_MAX;
			break;
		case 'W':
			timeout = atoi(isc_commandline_argument);
			if (timeout < 1)
				timeout = 1;
			break;
		case 'R':
			tries = atoi(isc_commandline_argument) + 1;
			if (tries < 2)
				tries = 2;
			break;
		case 'T':
			lookup->tcp_mode = ISC_TRUE;
			break;
		case 'C':
			debug("showing all SOAs");
			lookup->rdtype = dns_rdatatype_ns;
			lookup->rdtypeset = ISC_TRUE;
			lookup->rdclass = dns_rdataclass_in;
			lookup->rdclassset = ISC_TRUE;
			lookup->ns_search_only = ISC_TRUE;
			lookup->trace_root = ISC_TRUE;
			lookup->identify_previous_line = ISC_TRUE;
			default_lookups = ISC_FALSE;
			break;
		case 'N':
			debug("setting NDOTS to %s",
			      isc_commandline_argument);
			ndots = atoi(isc_commandline_argument);
			break;
		case 'D':
			debugging = ISC_TRUE;
			break;
		case '4':
			if (have_ipv4) {
				isc_net_disableipv6();
				have_ipv6 = ISC_FALSE;
			} else
				fatal("can't find IPv4 networking");
			break;
		case '6':
			if (have_ipv6) {
				isc_net_disableipv4();
				have_ipv4 = ISC_FALSE;
			} else
				fatal("can't find IPv6 networking");
			break;
		case 's':
			lookup->servfail_stops = ISC_TRUE;
			break;
		}
	}

	lookup->retries = tries;

	if (isc_commandline_index >= argc)
		show_usage();

	strlcpy(hostname, argv[isc_commandline_index], sizeof(hostname));
	if (argc > isc_commandline_index + 1) {
		set_nameserver(argv[isc_commandline_index+1]);
		debug("server is %s", argv[isc_commandline_index+1]);
		listed_server = ISC_TRUE;
	} else
		check_ra = ISC_TRUE;

	lookup->pending = ISC_FALSE;
	if (get_reverse(store, sizeof(store), hostname,
			lookup->ip6_int, ISC_TRUE) == ISC_R_SUCCESS) {
		strlcpy(lookup->textname, store, sizeof(lookup->textname));
		lookup->rdtype = dns_rdatatype_ptr;
		lookup->rdtypeset = ISC_TRUE;
		default_lookups = ISC_FALSE;
	} else {
		strlcpy(lookup->textname, hostname, sizeof(lookup->textname));
	}
	lookup->new_search = ISC_TRUE;
	ISC_LIST_APPEND(lookup_list, lookup, link);

	usesearch = ISC_TRUE;
}

int
main(int argc, char **argv) {
	isc_result_t result;

	tries = 2;

	ISC_LIST_INIT(lookup_list);
	ISC_LIST_INIT(server_list);
	ISC_LIST_INIT(search_list);
	
	fatalexit = 1;
#ifdef WITH_IDN
	idnoptions = IDN_ASCCHECK;
#endif

	if (pledge("stdio rpath dns inet", NULL) == -1) {
		perror("pledge");
		exit(1);
	}

	debug("main()");
	progname = argv[0];
	pre_parse_args(argc, argv);
	result = isc_app_start();
	check_result(result, "isc_app_start");
	setup_libs();
	parse_args(ISC_FALSE, argc, argv);

	if (pledge("stdio dns", NULL) == -1) {
		perror("pledge");
		exit(1);
	}

	setup_system();
	result = isc_app_onrun(mctx, global_task, onrun_callback, NULL);
	check_result(result, "isc_app_onrun");
	isc_app_run();
	cancel_all();
	destroy_libs();
	isc_app_finish();
	return ((seen_error == 0) ? 0 : 1);
}
@


1.9
log
@pledge bind(1), dig(1), and nslookup(1).  This modifies the underlying
ISC library to use socket(2) with the SOCK_DNS flag.  As a result, the
port commands are disabled (such practice is rare in the wild these days,
and pretty incompatible with the DNS vs regular socket concept in pledge..)
ok bluhm phessler reyk, etc
@
text
@d842 1
a842 1
	if (pledge("stdio rpath dns inet", NULL) == -1)
d844 2
d855 1
a855 1
	if (pledge("stdio dns", NULL) == -1)
d857 2
@


1.8
log
@resolve conflicts
@
text
@d24 1
d842 3
d852 4
@


1.7
log
@resolve conflicts and regen configure script
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
d5 1
a5 1
 * Permission to use, copy, modify, and distribute this software for any
d18 3
a20 1
/* $ISC: host.c,v 1.76.2.5.2.16 2006/05/23 04:43:47 marka Exp $ */
d23 1
d26 11
d131 2
a132 2
"            [-R number] hostname [server]\n"
"       -a is equivalent to -v -t *\n"
d141 1
d148 2
a149 1
"       -6 use IPv6 query transport only\n", stderr);
d429 4
a432 2
		printf("Host %s not found: %d(%s)\n", namestr,
		       msg->rcode, rcodetext[msg->rcode]);
d575 47
d638 4
a641 2
	while ((c = isc_commandline_parse(argc, argv, "lvwrdt:c:aTCN:R:W:Dni46"))
	       != EOF) {
d680 3
d691 7
d735 3
d791 3
d807 2
a808 1
	}
d837 3
d843 1
a856 1

@


1.6
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: host.c,v 1.76.2.5.2.13 2005/07/04 03:29:45 marka Exp $ */
d40 1
d49 1
d356 26
d398 1
a398 1
	if (listed_server) {
d407 1
d421 2
d425 5
a429 2

		dns_name_format(query->lookup->name, namestr, sizeof(namestr));
@


1.5
log
@resolve conflicts
@
text
@d2 1
a2 1
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: host.c,v 1.76.2.5.2.10 2004/09/06 01:33:05 marka Exp $ */
a42 15
extern ISC_LIST(dig_lookup_t) lookup_list;
extern dig_serverlist_t server_list;
extern ISC_LIST(dig_searchlist_t) search_list;

extern isc_boolean_t have_ipv4, have_ipv6;
extern isc_boolean_t usesearch;
extern isc_boolean_t debugging;
extern unsigned int timeout;
extern isc_mem_t *mctx;
extern int ndots;
extern int tries;
extern char *progname;
extern isc_task_t *global_task;
extern int fatalexit;

d590 1
@


1.4
log
@resolve conflicts
@
text
@d18 1
a18 1
/* $ISC: host.c,v 1.76.2.5.2.9 2004/04/13 03:00:06 marka Exp $ */
d389 1
a389 1
		printf("Name: %s\n", query->servname);
@


1.3
log
@update to BIND v9.2.3. ok todd@@
@
text
@d2 1
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: host.c,v 1.76.2.5 2003/07/25 04:36:44 marka Exp $ */
a20 1
#include <stdlib.h>
d26 1
d30 1
d44 1
a44 1
extern ISC_LIST(dig_server_t) server_list;
d47 1
d59 2
d103 4
a106 104
static const char *rtypetext[] = {
	"zero",				/* 0 */
	"has address",			/* 1 */
	"name server",			/* 2 */
	"MD",				/* 3 */
	"MF",				/* 4 */
	"is an alias for",		/* 5 */
	"SOA",				/* 6 */
	"MB",				/* 7 */
	"MG",				/* 8 */
	"MR",				/* 9 */
	"NULL",				/* 10 */
	"has well known services",	/* 11 */
	"domain name pointer",		/* 12 */
	"host information",		/* 13 */
	"MINFO",			/* 14 */
	"mail is handled by",	       	/* 15 */
	"text",				/* 16 */
	"RP",				/* 17 */
	"AFSDB",			/* 18 */
	"x25 address",			/* 19 */
	"isdn address",			/* 20 */
	"RT",				/* 21 */
	"NSAP",				/* 22 */
	"NSAP_PTR",			/* 23 */
	"has signature",		/* 24 */
	"has key",			/* 25 */
	"PX",				/* 26 */
	"GPOS",				/* 27 */
	"has AAAA address",		/* 28 */
	"LOC",				/* 29 */
	"has next record",		/* 30 */
	"EID",				/* 31 */
	"NIMLOC",			/* 32 */
	"SRV",				/* 33 */
	"ATMA",				/* 34 */
	"NAPTR",			/* 35 */
	"KX",				/* 36 */
	"CERT",				/* 37 */
	"has v6 address",		/* 38 */
	"DNAME",			/* 39 */
	"has optional information",	/* 41 */
	"has 42 record",       		/* 42 */
	"has 43 record",       		/* 43 */
	"has 44 record",       		/* 44 */
	"has 45 record",       		/* 45 */
	"has 46 record",       		/* 46 */
	"has 47 record",       		/* 47 */
	"has 48 record",       		/* 48 */
	"has 49 record",       		/* 49 */
	"has 50 record",       		/* 50 */
	"has 51 record",       		/* 51 */
	"has 52 record",       		/* 52 */
	"has 53 record",       		/* 53 */
	"has 54 record",       		/* 54 */
	"has 55 record",       		/* 55 */
	"has 56 record",       		/* 56 */
	"has 57 record",       		/* 57 */
	"has 58 record",       		/* 58 */
	"has 59 record",       		/* 59 */
	"has 60 record",       		/* 60 */
	"has 61 record",       		/* 61 */
	"has 62 record",       		/* 62 */
	"has 63 record",       		/* 63 */
	"has 64 record",       		/* 64 */
	"has 65 record",       		/* 65 */
	"has 66 record",       		/* 66 */
	"has 67 record",       		/* 67 */
	"has 68 record",       		/* 68 */
	"has 69 record",       		/* 69 */
	"has 70 record",       		/* 70 */
	"has 71 record",       		/* 71 */
	"has 72 record",       		/* 72 */
	"has 73 record",       		/* 73 */
	"has 74 record",       		/* 74 */
	"has 75 record",       		/* 75 */
	"has 76 record",       		/* 76 */
	"has 77 record",       		/* 77 */
	"has 78 record",       		/* 78 */
	"has 79 record",       		/* 79 */
	"has 80 record",       		/* 80 */
	"has 81 record",       		/* 81 */
	"has 82 record",       		/* 82 */
	"has 83 record",       		/* 83 */
	"has 84 record",       		/* 84 */
	"has 85 record",       		/* 85 */
	"has 86 record",       		/* 86 */
	"has 87 record",       		/* 87 */
	"has 88 record",       		/* 88 */
	"has 89 record",       		/* 89 */
	"has 90 record",       		/* 90 */
	"has 91 record",       		/* 91 */
	"has 92 record",       		/* 92 */
	"has 93 record",       		/* 93 */
	"has 94 record",       		/* 94 */
	"has 95 record",       		/* 95 */
	"has 96 record",       		/* 96 */
	"has 97 record",       		/* 97 */
	"has 98 record",       		/* 98 */
	"has 99 record",       		/* 99 */
	"UINFO",			/* 100 */
	"UID",				/* 101 */
	"GID",				/* 102 */
	"UNSPEC"};			/* 103 */
d108 17
d129 1
a129 1
"Usage: host [-aCdlrTwv] [-c class] [-n] [-N ndots] [-t type] [-W time]\n"
d136 1
a136 1
"       -i Use the old IN6.INT form of IPv6 reverse lookup\n"
d144 3
a146 1
"       -W specifies how long to wait for a reply\n", stderr);
d156 1
a156 2
received(int bytes, isc_sockaddr_t *from, dig_query_t *query)
{
a157 1
	isc_result_t result;
d163 1
a163 2
		result = isc_time_now(&now);
		check_result(result, "isc_time_now");
d212 12
a223 2


a238 1
	const char *rtt;
d296 5
d302 15
a316 8
					if (rdata.type <= 103)
						rtt = rtypetext[rdata.type];
					else if (rdata.type == 249)
						rtt = "key";
					else if (rdata.type == 250)
						rtt = "signature";
					else
						rtt = "unknown";
d375 1
d379 6
d403 30
d525 10
a540 1
	dig_server_t *srv;
d548 1
d554 1
a554 1
	while ((c = isc_commandline_parse(argc, argv, "ilvwrdt:c:aTCN:R:W:Dn"))
d571 11
a581 3
			tr.base = isc_commandline_argument;
			tr.length = strlen(isc_commandline_argument);
			result = dns_rdatatype_fromtext(&rdtype,
d583 1
d589 1
a589 1
			} 
d593 1
d599 3
d620 1
d630 1
d636 1
d651 3
a653 3
			tries = atoi(isc_commandline_argument);
			if (tries < 1)
				tries = 1;
d667 1
d677 14
d693 4
a696 1
	if (isc_commandline_index >= argc) {
d698 1
a698 1
	}
d701 2
a702 3
		srv = make_server(argv[isc_commandline_index+1]);
		debug("server is %s", srv->servername);
		ISC_LIST_APPEND(server_list, srv, link);
d707 2
a708 3
	if (get_reverse(store, hostname, lookup->ip6_int, ISC_TRUE)
	    == ISC_R_SUCCESS)
	{
d712 1
d726 2
d747 1
a747 1
	return (0);
@


1.2
log
@string cleaning; "Put it in.  If it breaks, tough" Theo.
work by me, useful feedback from krw, jakob, tedu, and tholo
@
text
@d2 1
a2 1
 * Copyright (C) 2000-2002  Internet Software Consortium.
d18 1
a18 1
/* $ISC: host.c,v 1.76.2.2 2002/02/08 03:57:04 marka Exp $ */
d54 1
d57 2
d215 1
a215 1
"       -n Use the nibble form of IPv6 reverse lookup\n"
d338 10
d558 1
a558 1
	isc_result_t result;
d566 1
a566 1
	while ((c = isc_commandline_parse(argc, argv, "lvwrdt:c:aTCN:R:W:Dn"))
d573 1
d588 7
a594 4
			if (result != ISC_R_SUCCESS)
				fprintf(stderr,"Warning: invalid type: %s\n",
					isc_commandline_argument);
			else {
d596 8
a603 2
				lookup->rdtypeset = ISC_TRUE;
			}
d611 5
a615 4
			if (result != ISC_R_SUCCESS)
				fprintf(stderr,"Warning: invalid class: %s\n",
					isc_commandline_argument);
			else {
d621 5
a625 1
			lookup->rdtype = dns_rdatatype_any;
d629 3
a632 1
			lookup->nibble = ISC_TRUE;
d686 3
a688 1
	if (get_reverse(store, hostname, lookup->nibble) == ISC_R_SUCCESS) {
d708 2
@


1.1
log
@Initial revision
@
text
@d647 1
a647 2
	strncpy(hostname, argv[isc_commandline_index], sizeof(hostname));
	hostname[sizeof(hostname)-1]=0;
d657 1
a657 2
		strncpy(lookup->textname, store, sizeof(lookup->textname));
		lookup->textname[sizeof(lookup->textname)-1] = 0;
d661 1
a661 2
		strncpy(lookup->textname, hostname, sizeof(lookup->textname));
		lookup->textname[sizeof(lookup->textname)-1]=0;
@


1.1.1.1
log
@ISC BIND version 9.2.2rc1
@
text
@@


1.1.1.2
log
@ISC BIND version 9.3.0. ok deraadt@@
@
text
@d2 1
a2 2
 * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
 * Copyright (C) 2000-2003  Internet Software Consortium.
d8 8
a15 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 1
a18 1
/* $ISC: host.c,v 1.76.2.5.2.9 2004/04/13 03:00:06 marka Exp $ */
d21 1
a26 1
#include <isc/print.h>
a29 1
#include <isc/stdlib.h>
d43 1
a43 1
extern dig_serverlist_t server_list;
a45 1
extern isc_boolean_t have_ipv4, have_ipv6;
a53 1
extern int fatalexit;
a55 4
static isc_boolean_t default_lookups = ISC_TRUE;
static int seen_error = -1;
static isc_boolean_t list_addresses = ISC_TRUE;
static dns_rdatatype_t list_type = dns_rdatatype_a;
d96 104
a199 4
struct rtype {
	unsigned int type;
	const char *text;
};
a200 17
struct rtype rtypes[] = {
	{ 1, 	"has address" },
	{ 2, 	"name server" },
	{ 5, 	"is an alias for" },
	{ 11,	"has well known services" },
	{ 12,	"domain name pointer" },
	{ 13,	"host information" },
	{ 15,	"mail is handled by" },
	{ 16,	"descriptive text" },
	{ 19,	"x25 address" },
	{ 20,	"ISDN address" },
	{ 24,	"has signature" },
	{ 25,	"has key" },
	{ 28,	"has IPv6 address" },
	{ 29,	"location" },
	{ 0, NULL }
};
d205 1
a205 1
"Usage: host [-aCdlriTwv] [-c class] [-N ndots] [-t type] [-W time]\n"
d212 1
a212 1
"       -i IP6.INT reverse lookups\n"
d220 1
a220 3
"       -W specifies how long to wait for a reply\n"
"       -4 use IPv4 query transport only\n"
"       -6 use IPv6 query transport only\n", stderr);
d230 2
a231 1
received(int bytes, isc_sockaddr_t *from, dig_query_t *query) {
d233 1
d239 2
a240 1
		TIME_NOW(&now);
d289 2
a290 12
#ifdef DIG_SIGCHASE
/* Just for compatibility : not use in host program */
isc_result_t
printrdataset(dns_name_t *owner_name, dns_rdataset_t *rdataset,
	      isc_buffer_t *target)
{
  UNUSED(owner_name);
  UNUSED(rdataset);
  UNUSED(target);
  return(ISC_FALSE);
}
#endif
d306 1
a334 10
			if (query->lookup->rdtype == dns_rdatatype_axfr &&
			    !((!list_addresses &&
			       (list_type == dns_rdatatype_any ||
			        rdataset->type == list_type)) ||
			      (list_addresses &&
			       (rdataset->type == dns_rdatatype_a ||
			        rdataset->type == dns_rdatatype_aaaa ||
				rdataset->type == dns_rdatatype_ns ||
				rdataset->type == dns_rdatatype_ptr))))
				continue;
a353 5
					struct rtype *t;
					const char *rtt;
					char typebuf[DNS_RDATATYPE_FORMATSIZE];
					char typebuf2[DNS_RDATATYPE_FORMATSIZE
						     + 20];
d355 8
a362 15

					for (t = rtypes; t->text != NULL; t++) {
						if (t->type == rdata.type) {
							rtt = t->text;
							goto found;
						}
					}

					dns_rdatatype_format(rdata.type,
							     typebuf,
							     sizeof(typebuf));
					snprintf(typebuf2, sizeof(typebuf2),
						 "has %s record", typebuf);
					rtt = typebuf2;
				found:
a420 1
	int force_error;
a423 6
	/*
	 * We get called multiple times.
	 * Preserve any existing error status.
	 */
	force_error = (seen_error == 1) ? 1 : 0;
	seen_error = 1;
a441 32

	if (default_lookups && query->lookup->rdtype == dns_rdatatype_a) {
		char namestr[DNS_NAME_FORMATSIZE];
		dig_lookup_t *lookup;

		/* Add AAAA and MX lookups. */

		dns_name_format(query->lookup->name, namestr, sizeof(namestr));
		lookup = clone_lookup(query->lookup, ISC_FALSE);
		if (lookup != NULL) {
			strncpy(lookup->textname, namestr,
				sizeof(lookup->textname));
			lookup->textname[sizeof(lookup->textname)-1] = 0;
			lookup->rdtype = dns_rdatatype_aaaa;
                        lookup->rdtypeset = ISC_TRUE;
			lookup->origin = NULL;
			lookup->retries = tries;
			ISC_LIST_APPEND(lookup_list, lookup, link);
		}
		lookup = clone_lookup(query->lookup, ISC_FALSE);
		if (lookup != NULL) {
			strncpy(lookup->textname, namestr,
				sizeof(lookup->textname));
			lookup->textname[sizeof(lookup->textname)-1] = 0;
			lookup->rdtype = dns_rdatatype_mx;
                        lookup->rdtypeset = ISC_TRUE;
			lookup->origin = NULL;
			lookup->retries = tries;
			ISC_LIST_APPEND(lookup_list, lookup, link);
		}
	}

a533 10
	if (short_form && !default_lookups &&
	    ISC_LIST_EMPTY(msg->sections[DNS_SECTION_ANSWER])) {
		char namestr[DNS_NAME_FORMATSIZE];
		char typestr[DNS_RDATATYPE_FORMATSIZE];
		dns_name_format(query->lookup->name, namestr, sizeof(namestr));
		dns_rdatatype_format(query->lookup->rdtype, typestr,
				     sizeof(typestr));
		printf("%s has no %s record\n", namestr, typestr);
	}
	seen_error = force_error;
d540 1
d545 1
a545 1
	isc_result_t result = ISC_R_SUCCESS;
a547 1
	isc_uint32_t serial = 0;
d553 1
a553 1
	while ((c = isc_commandline_parse(argc, argv, "lvwrdt:c:aTCN:R:W:Dni46"))
a559 1
			fatalexit = 3;
d569 3
a571 11
			if (strncasecmp(isc_commandline_argument,
					"ixfr=", 5) == 0) {
				rdtype = dns_rdatatype_ixfr;
				/* XXXMPA add error checking */
				serial = strtoul(isc_commandline_argument + 5,
						 NULL, 10);
				result = ISC_R_SUCCESS;
			} else {
				tr.base = isc_commandline_argument;
				tr.length = strlen(isc_commandline_argument);
				result = dns_rdatatype_fromtext(&rdtype,
a572 1
			}
d574 6
a579 4
			if (result != ISC_R_SUCCESS) {
				fatalexit = 2;
				fatal("invalid type: %s\n",
				      isc_commandline_argument);
a580 15
			if (!lookup->rdtypeset ||
			    lookup->rdtype != dns_rdatatype_axfr)
				lookup->rdtype = rdtype;
			lookup->rdtypeset = ISC_TRUE;
			if (rdtype == dns_rdatatype_axfr) {
				/* -l -t any -v */
				list_type = dns_rdatatype_any;
				short_form = ISC_FALSE;
				lookup->tcp_mode = ISC_TRUE;
			} else if (rdtype == dns_rdatatype_ixfr) {
				lookup->ixfr_serial = serial;
				list_type = rdtype;
			} else
				list_type = rdtype;
			list_addresses = ISC_FALSE;
d588 4
a591 5
			if (result != ISC_R_SUCCESS) {
				fatalexit = 2;
				fatal("invalid class: %s\n",
				      isc_commandline_argument);
			} else {
a594 1
			default_lookups = ISC_FALSE;
d597 1
a597 5
			if (!lookup->rdtypeset ||
			    lookup->rdtype != dns_rdatatype_axfr)
				lookup->rdtype = dns_rdatatype_any;
			list_type = dns_rdatatype_any;
			list_addresses = ISC_FALSE;
a599 4
			default_lookups = ISC_FALSE;
			break;
		case 'i':
			lookup->ip6_int = ISC_TRUE;
d602 1
a602 1
			/* deprecated */
d617 3
a619 3
			tries = atoi(isc_commandline_argument) + 1;
			if (tries < 2)
				tries = 2;
a632 1
			default_lookups = ISC_FALSE;
a641 14
		case '4':
			if (have_ipv4) {
				isc_net_disableipv6();
				have_ipv6 = ISC_FALSE;
			} else
				fatal("can't find IPv4 networking");
			break;
		case '6':
			if (have_ipv6) {
				isc_net_disableipv4();
				have_ipv4 = ISC_FALSE;
			} else
				fatal("can't find IPv6 networking");
			break;
d644 1
a644 4

	lookup->retries = tries;

	if (isc_commandline_index >= argc)
d646 1
a646 1

d650 3
a652 2
		set_nameserver(argv[isc_commandline_index+1]);
		debug("server is %s", argv[isc_commandline_index+1]);
d657 1
a657 2
	if (get_reverse(store, sizeof(store), hostname,
			lookup->ip6_int, ISC_TRUE) == ISC_R_SUCCESS) {
a661 1
		default_lookups = ISC_FALSE;
a675 2
	tries = 2;

a678 2
	
	fatalexit = 1;
d693 1
a693 1
	return ((seen_error == 0) ? 0 : 1);
@


1.1.1.3
log
@ISC BIND release 9.3.1. ok deraadt@@
@
text
@d18 1
a18 1
/* $ISC: host.c,v 1.76.2.5.2.10 2004/09/06 01:33:05 marka Exp $ */
d389 1
a389 1
		printf("Name: %s\n", query->userarg);
@


1.1.1.4
log
@ISC BIND release 9.3.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: host.c,v 1.76.2.5.2.13 2005/07/04 03:29:45 marka Exp $ */
d43 15
a606 1
			default_lookups = ISC_FALSE;
@


1.1.1.5
log
@ISC BIND release 9.3.3
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")
d18 1
a18 1
/* $ISC: host.c,v 1.76.2.5.2.16 2006/05/23 04:43:47 marka Exp $ */
a39 1
#include <dns/rdatastruct.h>
a47 1
static isc_boolean_t printed_server = ISC_FALSE;
a353 26
static void
chase_cnamechain(dns_message_t *msg, dns_name_t *qname) {
	isc_result_t result;
	dns_rdataset_t *rdataset;
	dns_rdata_cname_t cname;
	dns_rdata_t rdata = DNS_RDATA_INIT;
	unsigned int i = msg->counts[DNS_SECTION_ANSWER];

 	while (i-- > 0) {
		rdataset = NULL;
		result = dns_message_findname(msg, DNS_SECTION_ANSWER, qname,
					      dns_rdatatype_cname, 0, NULL,
					      &rdataset);
		if (result != ISC_R_SUCCESS)
			return;
		result = dns_rdataset_first(rdataset);
		check_result(result, "dns_rdataset_first");
		dns_rdata_reset(&rdata);
		dns_rdataset_current(rdataset, &rdata);
		result = dns_rdata_tostruct(&rdata, &cname, NULL);
		check_result(result, "dns_rdata_tostruct");
		dns_name_copy(&cname.cname, qname, NULL);
		dns_rdata_freestruct(&cname);
	}
}

d370 1
a370 1
	if (listed_server && !printed_server) {
a378 1
		printed_server = ISC_TRUE;
a391 2
		dns_fixedname_t fixed;
		dns_name_t *name;
d394 2
a395 5
		dns_fixedname_init(&fixed);
		name = dns_fixedname_name(&fixed);
		dns_name_copy(query->lookup->name, name, NULL);
		chase_cnamechain(msg, name);
		dns_name_format(name, namestr, sizeof(namestr));
@


1.1.1.6
log
@ISC BIND release 9.4.2
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2007  Internet Systems Consortium, Inc. ("ISC")
d5 1
a5 1
 * Permission to use, copy, modify, and/or distribute this software for any
d18 1
a18 3
/* $ISC: host.c,v 1.94.18.19 2007/08/28 07:19:55 tbox Exp $ */

/*! \file */
a20 1
#include <stdlib.h>
a22 11
#ifdef HAVE_LOCALE_H
#include <locale.h>
#endif

#ifdef WITH_IDN
#include <idn/result.h>
#include <idn/log.h>
#include <idn/resconf.h>
#include <idn/api.h>
#endif

d117 2
a118 2
"            [-R number] [-m flag] hostname [server]\n"
"       -a is equivalent to -v -t ANY\n"
a126 1
"       -s a SERVFAIL response should stop query\n"
d133 1
a133 2
"       -6 use IPv6 query transport only\n"
"       -m set memory debugging flag (trace|record|usage)\n", stderr);
d413 2
a414 4
		printf("Host %s not found: %d(%s)\n",
		       (msg->rcode != dns_rcode_nxdomain) ? namestr :
		       query->lookup->textname, msg->rcode,
		       rcodetext[msg->rcode]);
a558 47
static const char * optstring = "46ac:dilnm:rst:vwCDN:R:TW:";

static void
pre_parse_args(int argc, char **argv) {
	int c;

	while ((c = isc_commandline_parse(argc, argv, optstring)) != -1) {
		switch (c) {
		case 'm':
			memdebugging = ISC_TRUE;
			if (strcasecmp("trace", isc_commandline_argument) == 0)
				isc_mem_debugging |= ISC_MEM_DEBUGTRACE;
			else if (!strcasecmp("record",
					     isc_commandline_argument) == 0)
				isc_mem_debugging |= ISC_MEM_DEBUGRECORD;
			else if (strcasecmp("usage",
					    isc_commandline_argument) == 0)
				isc_mem_debugging |= ISC_MEM_DEBUGUSAGE;
			break;

		case '4': break;
		case '6': break;
		case 'a': break;
		case 'c': break;
		case 'd': break;
		case 'i': break;
		case 'l': break;
		case 'n': break;
		case 'r': break;
		case 's': break;
		case 't': break;
		case 'v': break;
		case 'w': break;
		case 'C': break;
		case 'D': break;
		case 'N': break;
		case 'R': break;
		case 'T': break;
		case 'W': break;
		default:
			show_usage();
		}
	}
	isc_commandline_reset = ISC_TRUE;
	isc_commandline_index = 1;
}

d575 2
a576 4
	lookup->servfail_stops = ISC_FALSE;
	lookup->comments = ISC_FALSE;

	while ((c = isc_commandline_parse(argc, argv, optstring)) != -1) {
a614 3
#ifdef WITH_IDN
			idnoptions = 0;
#endif
a622 7
#ifdef WITH_IDN
			} else if (rdtype == dns_rdatatype_a ||
				   rdtype == dns_rdatatype_aaaa ||
				   rdtype == dns_rdatatype_mx) {
				idnoptions = IDN_ASCCHECK;
				list_type = rdtype;
#endif
a659 3
		case 'm':
			/* Handled by pre_parse_args(). */
			break;
a712 3
		case 's':
			lookup->servfail_stops = ISC_TRUE;
			break;
d727 1
a727 2
	} else
		check_ra = ISC_TRUE;
a757 3
#ifdef WITH_IDN
	idnoptions = IDN_ASCCHECK;
#endif
a760 1
	pre_parse_args(argc, argv);
d774 1
@


