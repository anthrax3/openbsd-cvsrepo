head	1.13;
access;
symbols
	OPENBSD_6_1:1.12.0.6
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.7.0.28
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.26
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.22
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.20
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.18
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.16
	OPENBSD_5_0:1.7.0.14
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.12
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.10
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.6
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.8
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.6.0.4
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.5.0.20
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.18
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.16
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.14
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.12
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.10
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2;
locks; strict;
comment	@ * @;


1.13
date	2017.05.03.09.51.39;	author mestre;	state Exp;
branches;
next	1.12;
commitid	CaQOrlCeSyj26bDl;

1.12
date	2016.03.22.00.06.55;	author bluhm;	state Exp;
branches;
next	1.11;
commitid	Gzc43BxEpE4ag17x;

1.11
date	2016.02.12.00.10.59;	author mmcc;	state Exp;
branches;
next	1.10;
commitid	H1y6J8Pu7KRkMwvV;

1.10
date	2015.12.22.21.01.07;	author mmcc;	state Exp;
branches;
next	1.9;
commitid	2fFDLAOGZEyS0nuD;

1.9
date	2015.02.09.23.00.14;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	822YD61EeG0Xl9Na;

1.8
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	Uu5nFG3wCl0LACBb;

1.7
date	2008.07.09.19.58.28;	author sobrado;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.15.22.33.22;	author jmc;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.27.06.33.51;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.06.51.42;	author mpech;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.24.13.06.36;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.20.20.08.22;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.20.02.08.09;	author millert;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Use the safe idiom of cleaning sensitive data from memory with explicit_bzero,
instead of relying on other methods, after readpassphrase. Some programs on
this diff won't benefit that much since it happens near the terminal path, but
someone might copy the unsafe idiom to another program and place it where it
may leak sensitive data.

Discussed aeons ago with tb@@, OK deraadt@@ and beck@@
@
text
@/*	$OpenBSD: tokeninit.c,v 1.12 2016/03/22 00:06:55 bluhm Exp $	*/

/*-
 * Copyright (c) 1995 Migration Associates Corp. All Rights Reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Berkeley Software Design,
 *      Inc.
 * 4. The name of Berkeley Software Design, Inc.  may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BERKELEY SOFTWARE DESIGN, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL BERKELEY SOFTWARE DESIGN, INC. BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	BSDI $From: tokeninit.c,v 1.1 1996/08/26 20:27:28 prb Exp
 */

#include <sys/signal.h>
#include <sys/resource.h>
#include <sys/time.h>

#include <err.h>
#include <stdio.h>
#include <syslog.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <string.h>
#include <readpassphrase.h>

#include "token.h"
#include "tokendb.h"

static	char	*prompt_for_secret(int, char*);
static	int	parse_secret(int, char *, unsigned char *);

int
main(int argc, char **argv)
{
	unsigned int cmd = TOKEN_INITUSER;
	int	c;
	int	errors = 0;
	int	verbose = 0;
	int	hexformat = 0;
	int	modes = 0;
	char	seed[80];
	unsigned char	secret[9];
	char	*optstr;
	char	*p = NULL;

	struct rlimit cds;

	(void)signal(SIGQUIT, SIG_IGN);
	(void)signal(SIGINT, SIG_IGN);
	(void)setpriority(PRIO_PROCESS, 0, 0);

	openlog(NULL, LOG_ODELAY, LOG_AUTH);

	/*
	 * Make sure we never dump core as we might have a
	 * valid user shared-secret in memory.
	 */

	cds.rlim_cur = 0;
	cds.rlim_max = 0;
	if (setrlimit(RLIMIT_CORE, &cds) < 0)
		syslog(LOG_ERR, "couldn't set core dump size to 0: %m");

	if (pledge("stdio rpath wpath cpath fattr flock getpw tty", NULL) == -1)
		err(1, "pledge");

	if (token_init(argv[0]) < 0) {
		syslog(LOG_ERR, "unknown token type");
		errx(1, "unknown token type");
	}

	if (tt->options & TOKEN_HEXINIT)
		optstr = "fhm:sv";
	else
		optstr = "fm:sv";

	while ((c = getopt(argc, argv, optstr)) != -1)
		switch (c) {
		case 'f':	/* force initialize existing user account */
			cmd |= TOKEN_FORCEINIT;
			break;

		case 'h':
			hexformat = 1;
			break;

		case 'm':
			if ((c = token_mode(optarg)))
				modes |= c;
			else
				errx(1, "unknown mode");
			break;

		case 's':	/* generate seed during initialization */
			cmd |= TOKEN_GENSECRET;
			break;

		case 'v':	/* verbose */
			verbose = 1;
			break;
		default:
			fprintf(stderr,
			   "usage: %sinit [-f%ssv] [-m mode] user ...\n",
			    tt->name, (tt->options & TOKEN_HEXINIT) ? "h" : "");
			exit(1);
		}

	if ((modes & ~TOKEN_RIM) == 0)
		modes |= tt->defmode;

	argc -= optind;
	argv = &argv[optind];

	while (argc--) {
		if (verbose) {
			printf("Adding %s to %s database\n", *argv, tt->proper);
			fflush(stdout);
		}
		if (!(cmd & TOKEN_GENSECRET)) {
			p = prompt_for_secret(hexformat, *argv);
			if (!readpassphrase(p, seed, sizeof(seed), RPP_ECHO_ON) ||
			    seed[0] == '\0') {
				fprintf(stderr,
				    "%sinit: No seed supplied for token.\n",
				    tt->name);
				exit(1);
			}
			explicit_bzero(secret, sizeof(secret));
			if (parse_secret(hexformat, seed, secret)) {
				fprintf(stderr,
				    "%sinit: Invalid secret entered.\n",
				    tt->name);
				exit(1);
			}
		}
		switch (tokenuserinit(cmd, *argv, secret, modes)) {
		case 0:
			syslog(LOG_INFO, "User %s initialized in %s database",
			    *argv, tt->proper);
			break;
		case 1:
			warnx("%s already exists in %s database!",
			    *argv, tt->proper);
			syslog(LOG_INFO, "%s already exists in %s database",
			    *argv, tt->proper);
			errors++;
			break;
		case -1:
			warnx("Error initializing user %s in %s database.",
			    *argv, tt->proper);
			syslog(LOG_INFO,
			    "Error initializing user %s in %s database: %m",
			    *argv, tt->proper);
			errors++;
		}
		argv++;
	}
	exit(errors);
}

/*
 * Parse the 8 octal numbers or a 16 digit hex string into a token secret
 */

static	int
parse_secret(int hexformat, char *seed, unsigned char *secret)
{
	int i;
	unsigned int tmp[8];

	if (hexformat) {
		if ((i = sscanf(seed, "%02x %02x %02x %02x %02x %02x %02x %02x",
		    &tmp[0], &tmp[1], &tmp[2], &tmp[3],
		    &tmp[4], &tmp[5], &tmp[6], &tmp[7])) != 8)
			return (-1);
	} else {
		if ((i = sscanf(seed, "%o %o %o %o %o %o %o %o",
		    &tmp[0], &tmp[1], &tmp[2], &tmp[3],
		    &tmp[4], &tmp[5], &tmp[6], &tmp[7])) != 8)
			return (-1);
	}
	for (i=0; i < 8; i++)
		secret[i] = tmp[i] & 0xff;

	return (0);
}

/*
 * Prompt user for seed for token
 */

static	char *
prompt_for_secret(int hexformat, char* username)
{
	static char prompt[1024];
	if (hexformat)
		snprintf(prompt, sizeof prompt,
		    "Enter a 16 digit hexadecimal number "
		    "as a seed for %s\'s token:\n", username);
	else
		snprintf(prompt, sizeof prompt,
		    "Enter a series of 8 3-digit octal numbers "
		    "as a seed for %s\'s token:\n", username);
	return prompt;
}
@


1.12
log
@tokenadm(8) is already pledged, do the same for tokeninit(8).
- bring comment in both programms in line
- tokeninit(8) needs "tty" for readpassphrase(3)
- call token_init() after pledge(2)
- fix whitespace
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tokeninit.c,v 1.11 2016/02/12 00:10:59 mmcc Exp $	*/
d152 1
a152 1
			memset(secret, 0, sizeof(secret));
@


1.11
log
@hexidecimal -> hexadecimal
@
text
@d1 1
a1 1
/*	$OpenBSD: tokeninit.c,v 1.10 2015/12/22 21:01:07 mmcc Exp $	*/
d78 5
d88 3
d101 1
a101 1
    	while ((c = getopt(argc, argv, optstr)) != -1)
@


1.10
log
@assign pointers to NULL rather than 0
@
text
@d1 1
a1 1
/*	$OpenBSD: tokeninit.c,v 1.9 2015/02/09 23:00:14 deraadt Exp $	*/
d214 1
a214 1
		    "Enter a 16 digit hexidecimal number "
@


1.9
log
@clean up flags++ instances around getopt()
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: tokeninit.c,v 1.8 2015/01/16 06:40:22 deraadt Exp $	*/
d68 1
a68 1
	char	*p = 0;
@


1.8
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: tokeninit.c,v 1.7 2008/07/09 19:58:28 sobrado Exp $	*/
d100 1
a100 1
			hexformat++;
d115 1
a115 1
			verbose++;
@


1.7
log
@an ellipsis is not an optional argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: tokeninit.c,v 1.6 2007/03/15 22:33:22 jmc Exp $	*/
d37 1
a37 1
#include <sys/param.h>
d46 1
@


1.6
log
@simplify synopsis/usage() and sort options;
from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: tokeninit.c,v 1.5 2002/05/27 06:33:51 deraadt Exp $	*/
d118 1
a118 1
			   "usage: %sinit [-f%ssv] [-m mode] user [...]\n",
@


1.5
log
@unsigned to unsigned int
@
text
@d1 1
a1 1
/*	$OpenBSD: tokeninit.c,v 1.4 2002/03/14 06:51:42 mpech Exp $	*/
d118 1
a118 1
			   "Usage: %sinit [-f%ssv] username [ username ... ]\n",
@


1.4
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tokeninit.c,v 1.3 2001/10/24 13:06:36 mpech Exp $	*/
d58 1
a58 1
	unsigned cmd = TOKEN_INITUSER;
d184 1
a184 1
	unsigned tmp[8];
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tokeninit.c,v 1.2 2000/12/20 20:08:22 markus Exp $	*/
d157 1
a157 1
			warnx("%s already exists in %s database!\n",
d164 1
a164 1
			warnx("Error initializing user %s in %s database.\n",
@


1.2
log
@use arc4random, clear secrets, use readpassphrase in tokeninit; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tokeninit.c,v 1.1 2000/12/20 02:08:09 millert Exp $	*/
d92 1
a92 1
    	while ((c = getopt(argc, argv, optstr)) != EOF)
@


1.1
log
@Commands for manipulating the token database (ActivCard, CRYPTOCard, or SNK-004)
from BSDi.  Will be enabled when BSD authentication is turned on (login_token).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
d52 1
a52 2
static	void	strip_crlf(char *);
static	void	prompt_for_secret(int, char*);
d67 1
d135 3
a137 10
			prompt_for_secret(hexformat, *argv);

			if (fgets(seed, sizeof(seed), stdin) == NULL) {
				fprintf(stderr,
			    	    "%sinit: No seed supplied for token.\n",
				    tt->name);
				exit(1);
			}
			strip_crlf(seed);
			if (strlen(seed) == 0) {
a176 16
 * Strip trailing cr/lf from a line of text
 */

void
strip_crlf(char *buf)
{
        char *cp;

        if((cp = strchr(buf,'\r')) != NULL)
                *cp = '\0';

        if((cp = strchr(buf,'\n')) != NULL)
                *cp = '\0';
}

/*
d207 1
a207 1
static	void
d210 1
d212 3
a214 2
		printf("Enter a 16 digit hexidecimal number "
			"as a seed for %s\'s token:\n", username);
d216 4
a219 2
		printf("Enter a series of 8 3-digit octal numbers "
			"as a seed for %s\'s token:\n", username);
@

