head	1.12;
access;
symbols
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.14
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.12
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2007.06.04.14.59.45;	author henning;	state dead;
branches;
next	1.11;

1.11
date	2003.04.04.20.25.07;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.01.19.31.37;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.11.18.49.18;	author hin;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.26.09.25.21;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.17.19.42.38;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.28.07;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.05.08.04.52.25;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.01.17.20.30.22;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.09.05.04.32.39;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.12.23.13.22.42;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.07.20.12.02.09;	author joshd;	state Exp;
branches;
next	;


desc
@@


1.12
log
@bye bye ipx
@
text
@/*	$OpenBSD: ipxcp.c,v 1.11 2003/04/04 20:25:07 deraadt Exp $	*/

/*
 * ipxcp.c - PPP IPX Control Protocol.
 *
 * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name "Carnegie Mellon University" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For permission or any legal
 *    details, please contact
 *      Office of Technology Transfer
 *      Carnegie Mellon University
 *      5000 Forbes Avenue
 *      Pittsburgh, PA  15213-3890
 *      (412) 268-4387, fax: (412) 268-7395
 *      tech-transfer@@andrew.cmu.edu
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Computing Services
 *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
 *
 * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef IPX_CHANGE
#ifndef lint
#if 0
static char rcsid[] = "Id: ipxcp.c,v 1.6 1998/03/25 03:08:16 paulus Exp $";
#else
static char rcsid[] = "$OpenBSD: ipxcp.c,v 1.11 2003/04/04 20:25:07 deraadt Exp $";
#endif
#endif

/*
 * TODO:
 */

#include <stdio.h>
#include <string.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

#include "pppd.h"
#include "fsm.h"
#include "ipxcp.h"
#include "magic.h"
#include "pathnames.h"

/* global vars */
ipxcp_options ipxcp_wantoptions[NUM_PPP];	/* Options that we want to request */
ipxcp_options ipxcp_gotoptions[NUM_PPP];	/* Options that peer ack'd */
ipxcp_options ipxcp_allowoptions[NUM_PPP];	/* Options we allow peer to request */
ipxcp_options ipxcp_hisoptions[NUM_PPP];	/* Options that we ack'd */

#define wo (&ipxcp_wantoptions[0])
#define ao (&ipxcp_allowoptions[0])
#define go (&ipxcp_gotoptions[0])
#define ho (&ipxcp_hisoptions[0])

/*
 * Callbacks for fsm code.  (CI = Configuration Information)
 */
static void ipxcp_resetci(fsm *);	/* Reset our CI */
static int  ipxcp_cilen(fsm *);		/* Return length of our CI */
static void ipxcp_addci(fsm *, u_char *, int *); /* Add our CI */
static int  ipxcp_ackci(fsm *, u_char *, int);	/* Peer ack'd our CI */
static int  ipxcp_nakci(fsm *, u_char *, int);	/* Peer nak'd our CI */
static int  ipxcp_rejci(fsm *, u_char *, int);	/* Peer rej'd our CI */
static int  ipxcp_reqci(fsm *, u_char *, int *, int); /* Rcv CI */
static void ipxcp_up(fsm *);		/* We're UP */
static void ipxcp_down(fsm *);		/* We're DOWN */
static void ipxcp_script(fsm *, char *); /* Run an up/down script */

fsm ipxcp_fsm[NUM_PPP];		/* IPXCP fsm structure */

static fsm_callbacks ipxcp_callbacks = { /* IPXCP callback routines */
    ipxcp_resetci,		/* Reset our Configuration Information */
    ipxcp_cilen,		/* Length of our Configuration Information */
    ipxcp_addci,		/* Add our Configuration Information */
    ipxcp_ackci,		/* ACK our Configuration Information */
    ipxcp_nakci,		/* NAK our Configuration Information */
    ipxcp_rejci,		/* Reject our Configuration Information */
    ipxcp_reqci,		/* Request peer's Configuration Information */
    ipxcp_up,			/* Called when fsm reaches OPENED state */
    ipxcp_down,			/* Called when fsm leaves OPENED state */
    NULL,			/* Called when we want the lower layer up */
    NULL,			/* Called when we want the lower layer down */
    NULL,			/* Called when Protocol-Reject received */
    NULL,			/* Retransmission is necessary */
    NULL,			/* Called to handle protocol-specific codes */
    "IPXCP"			/* String name of protocol */
};

/*
 * Protocol entry points.
 */

static void ipxcp_init(int);
static void ipxcp_open(int);
static void ipxcp_close(int, char *);
static void ipxcp_lowerup(int);
static void ipxcp_lowerdown(int);
static void ipxcp_input(int, u_char *, int);
static void ipxcp_protrej(int);
static int  ipxcp_printpkt(u_char *, int,
    void (*)(void *, char *, ...), void *);

struct protent ipxcp_protent = {
    PPP_IPXCP,
    ipxcp_init,
    ipxcp_input,
    ipxcp_protrej,
    ipxcp_lowerup,
    ipxcp_lowerdown,
    ipxcp_open,
    ipxcp_close,
    ipxcp_printpkt,
    NULL,
    0,
    "IPXCP",
    NULL,
    NULL,
    NULL
};

/*
 * Lengths of configuration options.
 */

#define CILEN_VOID	2
#define CILEN_COMPLETE	2	/* length of complete option */
#define CILEN_NETN	6	/* network number length option */
#define CILEN_NODEN	8	/* node number length option */
#define CILEN_PROTOCOL	4	/* Minimum length of routing protocol */
#define CILEN_NAME	3	/* Minimum length of router name */
#define CILEN_COMPRESS	4	/* Minimum length of compression protocol */

#define CODENAME(x)	((x) == CONFACK ? "ACK" : \
			 (x) == CONFNAK ? "NAK" : "REJ")

/* Used in printing the node number */
#define NODE(base) base[0], base[1], base[2], base[3], base[4], base[5]

/* Used to generate the proper bit mask */
#define BIT(num)   (1 << (num))

/*
 * Convert from internal to external notation
 */

static short int
to_external(internal)
short int internal;
{
    short int  external;

    if (internal & IPX_NONE)
	external = IPX_NONE;
    else
	external = RIP_SAP;

    return external;
}

/*
 * Make a string representation of a network IP address.
 */

char *
ipx_ntoa(ipxaddr)
u_int32_t ipxaddr;
{
    static char b[64];

    snprintf(b, sizeof b, "%x", ipxaddr);
    return b;
}


/*
 * ipxcp_init - Initialize IPXCP.
 */
static void
ipxcp_init(unit)
    int unit;
{
    fsm *f = &ipxcp_fsm[unit];

    f->unit	 = unit;
    f->protocol	 = PPP_IPXCP;
    f->callbacks = &ipxcp_callbacks;
    fsm_init(&ipxcp_fsm[unit]);

    memset (wo->name,	  0, sizeof (wo->name));
    memset (wo->our_node, 0, sizeof (wo->our_node));
    memset (wo->his_node, 0, sizeof (wo->his_node));

    wo->neg_nn	       = 1;
    wo->neg_complete   = 1;
    wo->network	       = 0;

    ao->neg_node       = 1;
    ao->neg_nn	       = 1;
    ao->neg_name       = 1;
    ao->neg_complete   = 1;
    ao->neg_router     = 1;

    ao->accept_local   = 0;
    ao->accept_remote  = 0;
    ao->accept_network = 0;

    wo->tried_rip      = 0;
    wo->tried_nlsp     = 0;
}

/*
 * Copy the node number
 */

static void
copy_node (src, dst)
u_char *src, *dst;
{
    memcpy (dst, src, sizeof (ipxcp_wantoptions[0].our_node));
}

/*
 * Compare node numbers
 */

static int
compare_node (src, dst)
u_char *src, *dst;
{
    return memcmp (dst, src, sizeof (ipxcp_wantoptions[0].our_node)) == 0;
}

/*
 * Is the node number zero?
 */

static int
zero_node (node)
u_char *node;
{
    int indx;
    for (indx = 0; indx < sizeof (ipxcp_wantoptions[0].our_node); ++indx)
	if (node [indx] != 0)
	    return 0;
    return 1;
}

/*
 * Increment the node number
 */

static void
inc_node (node)
u_char *node;
{
    u_char   *outp;
    u_int32_t magic_num;

    outp      = node;
    magic_num = magic();
    *outp++   = '\0';
    *outp++   = '\0';
    PUTLONG (magic_num, outp);
}

/*
 * ipxcp_open - IPXCP is allowed to come up.
 */
static void
ipxcp_open(unit)
    int unit;
{
    fsm_open(&ipxcp_fsm[unit]);
}

/*
 * ipxcp_close - Take IPXCP down.
 */
static void
ipxcp_close(unit, reason)
    int unit;
    char *reason;
{
    fsm_close(&ipxcp_fsm[unit], reason);
}


/*
 * ipxcp_lowerup - The lower layer is up.
 */
static void
ipxcp_lowerup(unit)
    int unit;
{
    fsm_lowerup(&ipxcp_fsm[unit]);
}


/*
 * ipxcp_lowerdown - The lower layer is down.
 */
static void
ipxcp_lowerdown(unit)
    int unit;
{
    fsm_lowerdown(&ipxcp_fsm[unit]);
}


/*
 * ipxcp_input - Input IPXCP packet.
 */
static void
ipxcp_input(unit, p, len)
    int unit;
    u_char *p;
    int len;
{
    fsm_input(&ipxcp_fsm[unit], p, len);
}


/*
 * ipxcp_protrej - A Protocol-Reject was received for IPXCP.
 *
 * Pretend the lower layer went down, so we shut up.
 */
static void
ipxcp_protrej(unit)
    int unit;
{
    fsm_lowerdown(&ipxcp_fsm[unit]);
}


/*
 * ipxcp_resetci - Reset our CI.
 */
static void
ipxcp_resetci(f)
    fsm *f;
{

    wo->req_node = wo->neg_node && ao->neg_node;
    wo->req_nn	 = wo->neg_nn	&& ao->neg_nn;

    if (wo->our_network == 0) {
	wo->neg_node	   = 1;
	ao->accept_network = 1;
    }
/*
 * If our node number is zero then change it.
 */
    if (zero_node (wo->our_node)) {
	inc_node (wo->our_node);
	ao->accept_local = 1;
	wo->neg_node	 = 1;
    }
/*
 * If his node number is zero then change it.
 */
    if (zero_node (wo->his_node)) {
	inc_node (wo->his_node);
	ao->accept_remote = 1;
    }
/*
 * If no routing agent was specified then we do RIP/SAP according to the
 * RFC documents. If you have specified something then OK. Otherwise, we
 * do RIP/SAP.
 */
    if (ao->router == 0) {
	ao->router |= BIT(RIP_SAP);
	wo->router |= BIT(RIP_SAP);
    }

    /* Always specify a routing protocol unless it was REJected. */
    wo->neg_router = 1;
/*
 * Start with these default values
 */
    *go = *wo;
}

/*
 * ipxcp_cilen - Return length of our CI.
 */

static int
ipxcp_cilen(f)
    fsm *f;
{
    int len;

    len	 = go->neg_nn	    ? CILEN_NETN     : 0;
    len += go->neg_node	    ? CILEN_NODEN    : 0;
    len += go->neg_name	    ? CILEN_NAME + strlen (go->name) - 1 : 0;

    /* RFC says that defaults should not be included. */
    if (go->neg_router && to_external(go->router) != RIP_SAP)
	len += CILEN_PROTOCOL;

    return (len);
}


/*
 * ipxcp_addci - Add our desired CIs to a packet.
 */
static void
ipxcp_addci(f, ucp, lenp)
    fsm *f;
    u_char *ucp;
    int *lenp;
{
/*
 * Add the options to the record.
 */
    if (go->neg_nn) {
	PUTCHAR (IPX_NETWORK_NUMBER, ucp);
	PUTCHAR (CILEN_NETN, ucp);
	PUTLONG (go->our_network, ucp);
    }

    if (go->neg_node) {
	int indx;
	PUTCHAR (IPX_NODE_NUMBER, ucp);
	PUTCHAR (CILEN_NODEN, ucp);
	for (indx = 0; indx < sizeof (go->our_node); ++indx)
	    PUTCHAR (go->our_node[indx], ucp);
    }

    if (go->neg_name) {
	int cilen = strlen (go->name);
	int indx;
	PUTCHAR (IPX_ROUTER_NAME, ucp);
	PUTCHAR (CILEN_NAME + cilen - 1, ucp);
	for (indx = 0; indx < cilen; ++indx)
	    PUTCHAR (go->name [indx], ucp);
    }

    if (go->neg_router) {
	short external = to_external (go->router);
	if (external != RIP_SAP) {
	    PUTCHAR  (IPX_ROUTER_PROTOCOL, ucp);
	    PUTCHAR  (CILEN_PROTOCOL,      ucp);
	    PUTSHORT (external,            ucp);
	}
    }
}

/*
 * ipxcp_ackci - Ack our CIs.
 *
 * Returns:
 *	0 - Ack was bad.
 *	1 - Ack was good.
 */
static int
ipxcp_ackci(f, p, len)
    fsm *f;
    u_char *p;
    int len;
{
    u_short cilen, citype, cishort;
    u_char cichar;
    u_int32_t cilong;

#define ACKCIVOID(opt, neg) \
    if (neg) { \
	if ((len -= CILEN_VOID) < 0) \
	    break; \
	GETCHAR(citype, p); \
	GETCHAR(cilen, p); \
	if (cilen != CILEN_VOID || \
	    citype != opt) \
	    break; \
    }

#define ACKCICOMPLETE(opt,neg)	ACKCIVOID(opt, neg)

#define ACKCICHARS(opt, neg, val, cnt) \
    if (neg) { \
	int indx, count = cnt; \
	len -= (count + 2); \
	if (len < 0) \
	    break; \
	GETCHAR(citype, p); \
	GETCHAR(cilen, p); \
	if (cilen != (count + 2) || \
	    citype != opt) \
	    break; \
	for (indx = 0; indx < count; ++indx) {\
	    GETCHAR(cichar, p); \
	    if (cichar != ((u_char *) &val)[indx]) \
	       break; \
	}\
	if (indx != count) \
	    break; \
    }

#define ACKCINODE(opt,neg,val) ACKCICHARS(opt,neg,val,sizeof(val))
#define ACKCINAME(opt,neg,val) ACKCICHARS(opt,neg,val,strlen(val))

#define ACKCINETWORK(opt, neg, val) \
    if (neg) { \
	if ((len -= CILEN_NETN) < 0) \
	    break; \
	GETCHAR(citype, p); \
	GETCHAR(cilen, p); \
	if (cilen != CILEN_NETN || \
	    citype != opt) \
	    break; \
	GETLONG(cilong, p); \
	if (cilong != val) \
	    break; \
    }

#define ACKCIPROTO(opt, neg, val) \
    if (neg) { \
	if (len < 2) \
	    break; \
	GETCHAR(citype, p); \
	GETCHAR(cilen, p); \
	if (cilen != CILEN_PROTOCOL || citype != opt) \
	    break; \
	len -= cilen; \
	if (len < 0) \
	    break; \
	GETSHORT(cishort, p); \
	if (cishort != to_external (val) || cishort == RIP_SAP) \
	    break; \
      }
/*
 * Process the ACK frame in the order in which the frame was assembled
 */
    do {
	ACKCINETWORK  (IPX_NETWORK_NUMBER,  go->neg_nn,	    go->our_network);
	ACKCINODE     (IPX_NODE_NUMBER,	    go->neg_node,   go->our_node);
	ACKCINAME     (IPX_ROUTER_NAME,	    go->neg_name,   go->name);
	ACKCIPROTO    (IPX_ROUTER_PROTOCOL, go->neg_router, go->router);
	ACKCIPROTO    (IPX_ROUTER_PROTOCOL, go->neg_router, go->router);
	ACKCIPROTO    (IPX_ROUTER_PROTOCOL, go->neg_router, go->router);
/*
 * This is the end of the record.
 */
	if (len == 0)
	    return (1);
    } while (0);
/*
 * The frame is invalid
 */
    IPXCPDEBUG((LOG_INFO, "ipxcp_ackci: received bad Ack!"));
    return (0);
}

/*
 * ipxcp_nakci - Peer has sent a NAK for some of our CIs.
 * This should not modify any state if the Nak is bad
 * or if IPXCP is in the OPENED state.
 *
 * Returns:
 *	0 - Nak was bad.
 *	1 - Nak was good.
 */

static int
ipxcp_nakci(f, p, len)
    fsm *f;
    u_char *p;
    int len;
{
    u_char citype, cilen, *next;
    u_short s;
    u_int32_t l;
    ipxcp_options no;		/* options we've seen Naks for */
    ipxcp_options try;		/* options to request next time */

    BZERO(&no, sizeof(no));
    try = *go;

    while (len > CILEN_VOID) {
	GETCHAR (citype, p);
	GETCHAR (cilen,	 p);
	len -= cilen;
	if (len < 0)
	    goto bad;
	next = &p [cilen - CILEN_VOID];

	switch (citype) {
	case IPX_NETWORK_NUMBER:
	    if (!go->neg_nn || no.neg_nn || (cilen != CILEN_NETN))
		goto bad;
	    no.neg_nn = 1;

	    GETLONG(l, p);
	    IPXCPDEBUG((LOG_INFO, "local IP address %d", l));
	    if (l && ao->accept_network)
		try.our_network = l;
	    break;

	case IPX_NODE_NUMBER:
	    if (!go->neg_node || no.neg_node || (cilen != CILEN_NODEN))
		goto bad;
	    no.neg_node = 1;

	    IPXCPDEBUG((LOG_INFO,
			"local node number %02X%02X%02X%02X%02X%02X",
			NODE(p)));

	    if (!zero_node (p) && ao->accept_local &&
		! compare_node (p, ho->his_node))
		copy_node (p, try.our_node);
	    break;

	    /* This has never been sent. Ignore the NAK frame */
	case IPX_COMPRESSION_PROTOCOL:
	    goto bad;

	case IPX_ROUTER_PROTOCOL:
	    if (!go->neg_router || (cilen < CILEN_PROTOCOL))
		goto bad;

	    GETSHORT (s, p);
	    if (s > 15)		/* This is just bad, but ignore for now. */
		break;

	    s = BIT(s);
	    if (no.router & s)	/* duplicate NAKs are always bad */
		goto bad;

	    if (no.router == 0) /* Reset on first NAK only */
		try.router = 0;

	    no.router      |= s;
	    try.router     |= s;
	    try.neg_router  = 1;

	    IPXCPDEBUG((LOG_INFO, "Router protocol number %d", s));
	    break;

	    /* These, according to the RFC, must never be NAKed. */
	case IPX_ROUTER_NAME:
	case IPX_COMPLETE:
	    goto bad;

	    /* These are for options which we have not seen. */
	default:
	    break;
	}
	p = next;
    }

    /* If there is still anything left, this packet is bad. */
    if (len != 0)
	goto bad;

    /*
     * Do not permit the peer to force a router protocol which we do not
     * support. However, default to the condition that will accept "NONE".
     */
    try.router &= (ao->router | BIT(IPX_NONE));
    if (try.router == 0 && ao->router != 0)
	try.router = BIT(IPX_NONE);

    if (try.router != 0)
        try.neg_router = 1;

    /*
     * OK, the Nak is good.  Now we can update state.
     */
    if (f->state != OPENED)
	*go = try;

    return 1;

bad:
    IPXCPDEBUG((LOG_INFO, "ipxcp_nakci: received bad Nak!"));
    return 0;
}

/*
 * ipxcp_rejci - Reject some of our CIs.
 */
static int
ipxcp_rejci(f, p, len)
    fsm *f;
    u_char *p;
    int len;
{
    u_short cilen, citype, cishort;
    u_char cichar;
    u_int32_t cilong;
    ipxcp_options try;		/* options to request next time */

#define REJCINETWORK(opt, neg, val) \
    if (neg && p[0] == opt) { \
	if ((len -= CILEN_NETN) < 0) \
	    break; \
	GETCHAR(citype, p); \
	GETCHAR(cilen, p); \
	if (cilen != CILEN_NETN || \
	    citype != opt) \
	    break; \
	GETLONG(cilong, p); \
	if (cilong != val) \
	    break; \
	IPXCPDEBUG((LOG_INFO,"ipxcp_rejci rejected long opt %d", opt)); \
	neg = 0; \
    }

#define REJCICHARS(opt, neg, val, cnt) \
    if (neg && p[0] == opt) { \
	int indx, count = cnt; \
	len -= (count + 2); \
	if (len < 0) \
	    break; \
	GETCHAR(citype, p); \
	GETCHAR(cilen, p); \
	if (cilen != (count + 2) || \
	    citype != opt) \
	    break; \
	for (indx = 0; indx < count; ++indx) {\
	    GETCHAR(cichar, p); \
	    if (cichar != ((u_char *) &val)[indx]) \
	       break; \
	}\
	if (indx != count) \
	    break; \
	IPXCPDEBUG((LOG_INFO,"ipxcp_rejci rejected opt %d", opt)); \
	neg = 0; \
    }

#define REJCINODE(opt,neg,val) REJCICHARS(opt,neg,val,sizeof(val))
#define REJCINAME(opt,neg,val) REJCICHARS(opt,neg,val,strlen(val))

#define REJCIVOID(opt, neg) \
    if (neg && p[0] == opt) { \
	if ((len -= CILEN_VOID) < 0) \
	    break; \
	GETCHAR(citype, p); \
	GETCHAR(cilen, p); \
	if (cilen != CILEN_VOID || citype != opt) \
	    break; \
	IPXCPDEBUG((LOG_INFO, "ipxcp_rejci rejected void opt %d", opt)); \
	neg = 0; \
    }

/* a reject for RIP/SAP is invalid since we don't send it and you can't
   reject something which is not sent. (You can NAK, but you can't REJ.) */
#define REJCIPROTO(opt, neg, val, bit) \
    if (neg && p[0] == opt) { \
	if ((len -= CILEN_PROTOCOL) < 0) \
	    break; \
	GETCHAR(citype, p); \
	GETCHAR(cilen, p); \
	if (cilen != CILEN_PROTOCOL) \
	    break; \
	GETSHORT(cishort, p); \
	if (cishort != to_external (val) || cishort == RIP_SAP) \
	    break; \
	IPXCPDEBUG((LOG_INFO, "ipxcp_rejci short opt %d", opt)); \
	neg = 0; \
    }
/*
 * Any Rejected CIs must be in exactly the same order that we sent.
 * Check packet length and CI length at each step.
 * If we find any deviations, then this packet is bad.
 */
    try = *go;

    do {
	REJCINETWORK (IPX_NETWORK_NUMBER,  try.neg_nn,	   try.our_network);
	REJCINODE    (IPX_NODE_NUMBER,	   try.neg_node,   try.our_node);
	REJCINAME    (IPX_ROUTER_NAME,	   try.neg_name,   try.name);
	REJCIPROTO   (IPX_ROUTER_PROTOCOL, try.neg_router, try.router, 0);
/*
 * This is the end of the record.
 */
	if (len == 0) {
	    if (f->state != OPENED)
		*go = try;
	    return (1);
	}
    } while (0);
/*
 * The frame is invalid at this point.
 */
    IPXCPDEBUG((LOG_INFO, "ipxcp_rejci: received bad Reject!"));
    return 0;
}

/*
 * ipxcp_reqci - Check the peer's requested CIs and send appropriate response.
 *
 * Returns: CONFACK, CONFNAK or CONFREJ and input packet modified
 * appropriately.  If reject_if_disagree is non-zero, doesn't return
 * CONFNAK; returns CONFREJ if it can't return CONFACK.
 */
static int
ipxcp_reqci(f, inp, len, reject_if_disagree)
    fsm *f;
    u_char *inp;		/* Requested CIs */
    int *len;			/* Length of requested CIs */
    int reject_if_disagree;
{
    u_char *cip, *next;		/* Pointer to current and next CIs */
    u_short cilen, citype;	/* Parsed len, type */
    u_short cishort;		/* Parsed short value */
    u_int32_t tl, cinetwork;	/* Parsed address values */
    int rc = CONFACK;		/* Final packet return code */
    int orc;			/* Individual option return code */
    u_char *p;			/* Pointer to next char to parse */
    u_char *ucp = inp;		/* Pointer to current output char */
    int l = *len;		/* Length left */

    /*
     * Reset all his options.
     */
    BZERO(ho, sizeof(*ho));

    /*
     * Process all his options.
     */
    next = inp;
    while (l) {
	orc = CONFACK;			/* Assume success */
	cip = p = next;			/* Remember begining of CI */
	if (l < 2 ||			/* Not enough data for CI header or */
	    p[1] < 2 ||			/*  CI length too small or */
	    p[1] > l) {			/*  CI length too big? */
	    IPXCPDEBUG((LOG_INFO, "ipxcp_reqci: bad CI length!"));
	    orc = CONFREJ;		/* Reject bad CI */
	    cilen = l;			/* Reject till end of packet */
	    l = 0;			/* Don't loop again */
	    goto endswitch;
	}
	GETCHAR(citype, p);		/* Parse CI type */
	GETCHAR(cilen, p);		/* Parse CI length */
	l -= cilen;			/* Adjust remaining length */
	next += cilen;			/* Step to next CI */

	switch (citype) {		/* Check CI type */
/*
 * The network number must match. Choose the larger of the two.
 */
	case IPX_NETWORK_NUMBER:
	    IPXCPDEBUG((LOG_INFO, "ipxcp: received Network Number request"));
	
	    /* if we wont negotiate the network number or the length is wrong
	       then reject the option */
	    if ( !ao->neg_nn || cilen != CILEN_NETN ) {
		orc = CONFREJ;
		break;		
	    }
	    GETLONG(cinetwork, p);
	    IPXCPDEBUG((LOG_INFO,"Remote proposed IPX network number is %8x",tl));

	    /* If the network numbers match then acknowledge them. */
	    if (cinetwork != 0) {
		ho->his_network = cinetwork;
		ho->neg_nn	= 1;
		if (wo->our_network == cinetwork)
		    break;
/*
 * If the network number is not given or we don't accept their change or
 * the network number is too small then NAK it.
 */
		if (! ao->accept_network || cinetwork < wo->our_network) {
		    DECPTR (sizeof (u_int32_t), p);
		    PUTLONG (wo->our_network, p);
		    orc = CONFNAK;
		}
		break;
	    }
/*
 * The peer sent '0' for the network. Give it ours if we have one.
 */
	    if (go->our_network != 0) {
		DECPTR (sizeof (u_int32_t), p);
		PUTLONG (wo->our_network, p);
		orc = CONFNAK;
/*
 * We don't have one. Reject the value.
 */
	    } else
		orc = CONFREJ;

	    break;
/*
 * The node number is required
 */
	case IPX_NODE_NUMBER:
	    IPXCPDEBUG((LOG_INFO, "ipxcp: received Node Number request"));

	    /* if we wont negotiate the node number or the length is wrong
	       then reject the option */
	    if ( cilen != CILEN_NODEN ) {
		orc = CONFREJ;
		break;
	    }

	    copy_node (p, ho->his_node);
	    ho->neg_node = 1;
/*
 * If the remote does not have a number and we do then NAK it with the value
 * which we have for it. (We never have a default value of zero.)
 */
	    if (zero_node (ho->his_node)) {
		orc = CONFNAK;
		copy_node (wo->his_node, p);
		INCPTR (sizeof (wo->his_node), p);
		break;
	    }
/*
 * If you have given me the expected network node number then I'll accept
 * it now.
 */
	    if (compare_node (wo->his_node, ho->his_node)) {
		orc = CONFACK;
		ho->neg_node = 1;
		INCPTR (sizeof (wo->his_node), p);
		break;
	    }
/*
 * If his node number is the same as ours then ask him to try the next
 * value.
 */
	    if (compare_node (ho->his_node, go->our_node)) {
		inc_node (ho->his_node);
		orc = CONFNAK;
		copy_node (ho->his_node, p);
		INCPTR (sizeof (wo->his_node), p);
		break;
	    }
/*
 * If we don't accept a new value then NAK it.
 */
	    if (! ao->accept_remote) {
		copy_node (wo->his_node, p);
		INCPTR (sizeof (wo->his_node), p);
		orc = CONFNAK;
		break;
	    }
	    orc = CONFACK;
	    ho->neg_node = 1;
	    INCPTR (sizeof (wo->his_node), p);
	    break;
/*
 * Compression is not desired at this time. It is always rejected.
 */
	case IPX_COMPRESSION_PROTOCOL:
	    IPXCPDEBUG((LOG_INFO, "ipxcp: received Compression Protocol request "));
	    orc = CONFREJ;
	    break;
/*
 * The routing protocol is a bitmask of various types. Any combination
 * of the values RIP_SAP and NLSP are permissible. 'IPX_NONE' for no
 * routing protocol must be specified only once.
 */
	case IPX_ROUTER_PROTOCOL:
	    if ( !ao->neg_router || cilen < CILEN_PROTOCOL ) {
		orc = CONFREJ;
		break;		
	    }

	    GETSHORT (cishort, p);
	    IPXCPDEBUG((LOG_INFO,
			"Remote router protocol number 0x%04x",
			cishort));

	    if (wo->neg_router == 0) {
		wo->neg_router = 1;
		wo->router     = BIT(IPX_NONE);
	    }

	    if ((cishort == IPX_NONE && ho->router != 0) ||
		(ho->router & BIT(IPX_NONE))) {
		orc = CONFREJ;
		break;
	    }

	    cishort = BIT(cishort);
	    if (ho->router & cishort) {
		orc = CONFREJ;
		break;
	    }

	    ho->router    |= cishort;
	    ho->neg_router = 1;

	    /* Finally do not allow a router protocol which we do not
	       support. */

	    if ((cishort & (ao->router | BIT(IPX_NONE))) == 0) {
		int protocol;

		if (cishort == BIT(NLSP) &&
		    (ao->router & BIT(RIP_SAP)) &&
		    !wo->tried_rip) {
		    protocol      = RIP_SAP;
		    wo->tried_rip = 1;
		} else
		    protocol = IPX_NONE;

		DECPTR (sizeof (u_int16_t), p);
		PUTSHORT (protocol, p);
		orc = CONFNAK;
	    }
	    break;
/*
 * The router name is advisorary. Just accept it if it is not too large.
 */
	case IPX_ROUTER_NAME:
	    IPXCPDEBUG((LOG_INFO, "ipxcp: received Router Name request"));
	    if (cilen >= CILEN_NAME) {
		int name_size = cilen - CILEN_NAME;
		if (name_size > sizeof (ho->name))
		    name_size = sizeof (ho->name) - 1;
		memset (ho->name, 0, sizeof (ho->name));
		memcpy (ho->name, p, name_size);
		ho->name [name_size] = '\0';
		ho->neg_name = 1;
		orc = CONFACK;
		break;
	    }
	    orc = CONFREJ;
	    break;
/*
 * This is advisorary.
 */
	case IPX_COMPLETE:
	    IPXCPDEBUG((LOG_INFO, "ipxcp: received Complete request"));
	    if (cilen != CILEN_COMPLETE)
		orc = CONFREJ;
	    else {
		ho->neg_complete = 1;
		orc = CONFACK;
	    }
	    break;
/*
 * All other entries are not known at this time.
 */
	default:
	    IPXCPDEBUG((LOG_INFO, "ipxcp: received Complete request"));
	    orc = CONFREJ;
	    break;
	}

endswitch:
	IPXCPDEBUG((LOG_INFO, " (%s)\n", CODENAME(orc)));

	if (orc == CONFACK &&		/* Good CI */
	    rc != CONFACK)		/*  but prior CI wasnt? */
	    continue;			/* Don't send this one */

	if (orc == CONFNAK) {		/* Nak this CI? */
	    if (reject_if_disagree)	/* Getting fed up with sending NAKs? */
		orc = CONFREJ;		/* Get tough if so */
	    if (rc == CONFREJ)		/* Rejecting prior CI? */
		continue;		/* Don't send this one */
	    if (rc == CONFACK) {	/* Ack'd all prior CIs? */
		rc  = CONFNAK;		/* Not anymore... */
		ucp = inp;		/* Backup */
	    }
	}

	if (orc == CONFREJ &&		/* Reject this CI */
	    rc != CONFREJ) {		/*  but no prior ones? */
	    rc = CONFREJ;
	    ucp = inp;			/* Backup */
	}

	/* Need to move CI? */
	if (ucp != cip)
	    BCOPY(cip, ucp, cilen);	/* Move it */

	/* Update output pointer */
	INCPTR(cilen, ucp);
    }

    /*
     * If we aren't rejecting this packet, and we want to negotiate
     * their address, and they didn't send their address, then we
     * send a NAK with a IPX_NODE_NUMBER option appended. We assume the
     * input buffer is long enough that we can append the extra
     * option safely.
     */

    if (rc != CONFREJ && !ho->neg_node &&
	wo->req_nn && !reject_if_disagree) {
	if (rc == CONFACK) {
	    rc = CONFNAK;
	    wo->req_nn = 0;		/* don't ask again */
	    ucp = inp;			/* reset pointer */
	}

	if (zero_node (wo->his_node))
	    inc_node (wo->his_node);

	PUTCHAR (IPX_NODE_NUMBER, ucp);
	PUTCHAR (CILEN_NODEN, ucp);
	copy_node (wo->his_node, ucp);
	INCPTR (sizeof (wo->his_node), ucp);
    }

    *len = ucp - inp;			/* Compute output length */
    IPXCPDEBUG((LOG_INFO, "ipxcp: returning Configure-%s", CODENAME(rc)));
    return (rc);			/* Return final code */
}

/*
 * ipxcp_up - IPXCP has come UP.
 *
 * Configure the IP network interface appropriately and bring it up.
 */

static void
ipxcp_up(f)
    fsm *f;
{
    int unit = f->unit;

    IPXCPDEBUG((LOG_INFO, "ipxcp: up"));

    /* The default router protocol is RIP/SAP. */
    if (ho->router == 0)
	ho->router = BIT(RIP_SAP);

    if (go->router == 0)
	go->router = BIT(RIP_SAP);

    /* Fetch the network number */
    if (!ho->neg_nn)
	ho->his_network = wo->his_network;

    if (!ho->neg_node)
	copy_node (wo->his_node, ho->his_node);

    if (!wo->neg_node && !go->neg_node)
	copy_node (wo->our_node, go->our_node);

    if (zero_node (go->our_node)) {
	static char errmsg[] = "Could not determine local IPX node address";
	IPXCPDEBUG((LOG_ERR, errmsg));
	ipxcp_close(f->unit, errmsg);
	return;
    }

    go->network = go->our_network;
    if (ho->his_network != 0 && ho->his_network > go->network)
	go->network = ho->his_network;

    if (go->network == 0) {
	static char errmsg[] = "Can not determine network number";
	IPXCPDEBUG((LOG_ERR, errmsg));
	ipxcp_close (unit, errmsg);
	return;
    }

    /* bring the interface up */
    if (!sifup(unit)) {
	IPXCPDEBUG((LOG_WARNING, "sifup failed"));
	ipxcp_close(unit, "Interface configuration failed");
	return;
    }

    /* set the network number for IPX */
    if (!sipxfaddr(unit, go->network, go->our_node)) {
	IPXCPDEBUG((LOG_WARNING, "sipxfaddr failed"));
	ipxcp_close(unit, "Interface configuration failed");
	return;
    }

    /*
     * Execute the ipx-up script, like this:
     *	/etc/ppp/ipx-up interface tty speed local-IPX remote-IPX
     */

    ipxcp_script (f, _PATH_IPXUP);
}

/*
 * ipxcp_down - IPXCP has gone DOWN.
 *
 * Take the IP network interface down, clear its addresses
 * and delete routes through it.
 */

static void
ipxcp_down(f)
    fsm *f;
{

    IPXCPDEBUG((LOG_INFO, "ipxcp: down"));

    cipxfaddr (f->unit);
    sifdown(f->unit);
    ipxcp_script (f, _PATH_IPXDOWN);
}


/*
 * ipxcp_script - Execute a script with arguments
 * interface-name tty-name speed local-IPX remote-IPX networks.
 */
static void
ipxcp_script(f, script)
    fsm *f;
    char *script;
{
    char strspeed[32],	 strlocal[32],	   strremote[32];
    char strnetwork[32], strpid[32];
    char *argv[14],	 strproto_lcl[32], strproto_rmt[32];

    snprintf(strpid, sizeof strpid, "%ld", (long)getpid());
    snprintf(strspeed, sizeof strspeed, "%d", baud_rate);

    strproto_lcl[0] = '\0';
    if (go->neg_router && ((go->router & BIT(IPX_NONE)) == 0)) {
	if (go->router & BIT(RIP_SAP))
	    strlcpy (strproto_lcl, "RIP ", sizeof strproto_lcl);
	if (go->router & BIT(NLSP))
	    strlcat (strproto_lcl, "NLSP ", sizeof strproto_lcl);
    }

    if (strproto_lcl[0] == '\0')
	strlcpy (strproto_lcl, "NONE ", sizeof strproto_lcl);

    strproto_rmt[0] = '\0';
    if (ho->neg_router && ((ho->router & BIT(IPX_NONE)) == 0)) {
	if (ho->router & BIT(RIP_SAP))
	    strlcpy (strproto_rmt, "RIP ", sizeof strproto_rmt);
	if (ho->router & BIT(NLSP))
	    strlcat (strproto_rmt, "NLSP ", sizeof strproto_rmt);
    }

    if (strproto_rmt[0] == '\0')
	strlcpy (strproto_rmt, "NONE ", sizeof strproto_rmt);

    strlcpy (strnetwork, ipx_ntoa (go->network), sizeof strnetwork);

    snprintf (strlocal, sizeof strlocal,
	     "%02X%02X%02X%02X%02X%02X",
	     NODE(go->our_node));

    snprintf (strremote, sizeof strremote,
	     "%02X%02X%02X%02X%02X%02X",
	     NODE(ho->his_node));

    argv[0]  = script;
    argv[1]  = ifname;
    argv[2]  = devnam;
    argv[3]  = strspeed;
    argv[4]  = strnetwork;
    argv[5]  = strlocal;
    argv[6]  = strremote;
    argv[7]  = strproto_lcl;
    argv[8]  = strproto_rmt;
    argv[9]  = go->name;
    argv[10] = ho->name;
    argv[11] = ipparam;
    argv[12] = strpid;
    argv[13] = NULL;
    run_program(script, argv, 0);
}

/*
 * ipxcp_printpkt - print the contents of an IPXCP packet.
 */
static char *ipxcp_codenames[] = {
    "ConfReq", "ConfAck", "ConfNak", "ConfRej",
    "TermReq", "TermAck", "CodeRej"
};

static int
ipxcp_printpkt(p, plen, printer, arg)
    u_char *p;
    int plen;
    void (*printer)(void *, char *, ...);
    void *arg;
{
    int code, id, len, olen;
    u_char *pstart, *optend;
    u_short cishort;
    u_int32_t cilong;

    if (plen < HEADERLEN)
	return 0;
    pstart = p;
    GETCHAR(code, p);
    GETCHAR(id, p);
    GETSHORT(len, p);
    if (len < HEADERLEN || len > plen)
	return 0;

    if (code >= 1 && code <= sizeof(ipxcp_codenames) / sizeof(char *))
	printer(arg, " %s", ipxcp_codenames[code-1]);
    else
	printer(arg, " code=0x%x", code);
    printer(arg, " id=0x%x", id);
    len -= HEADERLEN;
    switch (code) {
    case CONFREQ:
    case CONFACK:
    case CONFNAK:
    case CONFREJ:
	/* print option list */
	while (len >= 2) {
	    GETCHAR(code, p);
	    GETCHAR(olen, p);
	    p -= 2;
	    if (olen < CILEN_VOID || olen > len) {
		break;
	    }
	    printer(arg, " <");
	    len -= olen;
	    optend = p + olen;
	    switch (code) {
	    case IPX_NETWORK_NUMBER:
		if (olen == CILEN_NETN) {
		    p += CILEN_VOID;
		    GETLONG(cilong, p);
		    printer (arg, "network %s", ipx_ntoa (cilong));
		}
		break;
	    case IPX_NODE_NUMBER:
		if (olen == CILEN_NODEN) {
		    p += CILEN_VOID;
		    printer (arg, "node ");
		    while (p < optend) {
			GETCHAR(code, p);
			printer(arg, "%.2x", code);
		    }
		}
		break;
	    case IPX_COMPRESSION_PROTOCOL:
		if (olen == CILEN_COMPRESS) {
		    p += CILEN_VOID;
		    GETSHORT (cishort, p);
		    printer (arg, "compression %d", (int) cishort);
		}
		break;
	    case IPX_ROUTER_PROTOCOL:
		if (olen == CILEN_PROTOCOL) {
		    p += CILEN_VOID;
		    GETSHORT (cishort, p);
		    printer (arg, "router proto %d", (int) cishort);
		}
		break;
	    case IPX_ROUTER_NAME:
		if (olen >= CILEN_NAME) {
		    p += CILEN_VOID;
		    printer (arg, "router name \"");
		    while (p < optend) {
			GETCHAR(code, p);
			if (code >= 0x20 && code <= 0x7E)
			    printer (arg, "%c", (int) (unsigned int) (unsigned char) code);
			else
			    printer (arg, " \\%.2x", (int) (unsigned int) (unsigned char) code);
		    }
		    printer (arg, "\"");
		}
		break;
	    case IPX_COMPLETE:
		if (olen == CILEN_COMPLETE) {
		    p += CILEN_VOID;
		    printer (arg, "complete");
		}
		break;
	    default:
		break;
	    }

	    while (p < optend) {
		GETCHAR(code, p);
		printer(arg, " %.2x", (int) (unsigned int) (unsigned char) code);
	    }
	    printer(arg, ">");
	}
	break;

    case TERMACK:
    case TERMREQ:
	if (len > 0 && *p >= ' ' && *p < 0x7f) {
	    printer(arg, " ");
	    print_string(p, len, printer, arg);
	    p += len;
	    len = 0;
	}
	break;
    }

    /* print the rest of the bytes in the packet */
    for (; len > 0; --len) {
	GETCHAR(code, p);
	printer(arg, " %.2x", (int) (unsigned int) (unsigned char) code);
    }

    return p - pstart;
}
#endif /* ifdef IPX_CHANGE */
@


1.11
log
@strlcpy and snprintf; various people ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipxcp.c,v 1.10 2002/07/01 19:31:37 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ipxcp.c,v 1.10 2002/07/01 19:31:37 deraadt Exp $";
@


1.10
log
@license update of CMU parts.  due to communication with wcw+@@andrew.cmu.edu,
pushed for by tygs@@netcologne.de.  Apparently we also now known how to talk
to the lawyers there, if we were so mad.  Note that a few other copyright
issues in pppd still remain, so this does not close this story.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipxcp.c,v 1.9 2002/06/11 18:49:18 hin Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ipxcp.c,v 1.9 2002/06/11 18:49:18 hin Exp $";
d197 2
a198 1
    sprintf(b, "%x", ipxaddr);
d1243 2
a1244 2
    sprintf (strpid,   "%ld", (long)getpid());
    sprintf (strspeed, "%d", baud_rate);
d1249 1
a1249 1
	    strcpy (strproto_lcl, "RIP ");
d1251 1
a1251 1
	    strcat (strproto_lcl, "NLSP ");
d1255 1
a1255 3
	strcpy (strproto_lcl, "NONE ");

    strproto_lcl[strlen (strproto_lcl)-1] = '\0';
d1260 1
a1260 1
	    strcpy (strproto_rmt, "RIP ");
d1262 1
a1262 1
	    strcat (strproto_rmt, "NLSP ");
d1266 1
a1266 3
	strcpy (strproto_rmt, "NONE ");

    strproto_rmt[strlen (strproto_rmt)-1] = '\0';
d1268 1
a1268 1
    strcpy (strnetwork, ipx_ntoa (go->network));
d1270 1
a1270 1
    sprintf (strlocal,
d1274 1
a1274 1
    sprintf (strremote,
@


1.9
log
@-Wall cleanup

ok millert@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipxcp.c,v 1.8 2002/05/26 09:25:21 deraadt Exp $	*/
d6 1
a6 2
 * Copyright (c) 1989 Carnegie Mellon University.
 * All rights reserved.
d8 35
a42 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Carnegie Mellon University.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d50 1
a50 1
static char rcsid[] = "$OpenBSD: ipxcp.c,v 1.8 2002/05/26 09:25:21 deraadt Exp $";
@


1.8
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ipxcp.c,v 1.7 2002/02/17 19:42:38 millert Exp $	*/
d27 1
a27 1
static char rcsid[] = "$OpenBSD: ipxcp.c,v 1.7 2002/02/17 19:42:38 millert Exp $";
d41 1
@


1.7
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipxcp.c,v 1.6 2002/02/16 21:28:07 millert Exp $	*/
d27 1
a27 1
static char rcsid[] = "$OpenBSD: ipxcp.c,v 1.6 2002/02/16 21:28:07 millert Exp $";
d1218 1
a1218 1
    sprintf (strpid,   "%d", getpid());
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipxcp.c,v 1.5 1998/05/08 04:52:25 millert Exp $	*/
d27 1
a27 1
static char rcsid[] = "$OpenBSD: ipxcp.c,v 1.5 1998/05/08 04:52:25 millert Exp $";
d104 2
a105 2
static int  ipxcp_printpkt __P((u_char *, int,
				void (*)(void *, char *, ...), void *));
@


1.5
log
@pppd 2.3.5
@
text
@d1 1
a1 1
/*	$OpenBSD: ipxcp.c,v 1.4 1998/01/17 20:30:22 millert Exp $	*/
d27 1
a27 1
static char rcsid[] = "$OpenBSD: ipxcp.c,v 1.4 1998/01/17 20:30:22 millert Exp $";
d62 10
a71 10
static void ipxcp_resetci __P((fsm *));	/* Reset our CI */
static int  ipxcp_cilen __P((fsm *));		/* Return length of our CI */
static void ipxcp_addci __P((fsm *, u_char *, int *)); /* Add our CI */
static int  ipxcp_ackci __P((fsm *, u_char *, int));	/* Peer ack'd our CI */
static int  ipxcp_nakci __P((fsm *, u_char *, int));	/* Peer nak'd our CI */
static int  ipxcp_rejci __P((fsm *, u_char *, int));	/* Peer rej'd our CI */
static int  ipxcp_reqci __P((fsm *, u_char *, int *, int)); /* Rcv CI */
static void ipxcp_up __P((fsm *));		/* We're UP */
static void ipxcp_down __P((fsm *));		/* We're DOWN */
static void ipxcp_script __P((fsm *, char *)); /* Run an up/down script */
d97 7
a103 7
static void ipxcp_init __P((int));
static void ipxcp_open __P((int));
static void ipxcp_close __P((int, char *));
static void ipxcp_lowerup __P((int));
static void ipxcp_lowerdown __P((int));
static void ipxcp_input __P((int, u_char *, int));
static void ipxcp_protrej __P((int));
d105 1
a105 1
				void (*) __P((void *, char *, ...)), void *));
d1286 1
a1286 1
    void (*printer) __P((void *, char *, ...));
@


1.4
log
@ppp-2.3.3 + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: ipxcp.c,v 1.3 1997/09/05 04:32:39 millert Exp $	*/
d25 1
a25 1
static char rcsid[] = "Id: ipxcp.c,v 1.5 1997/03/04 03:39:32 paulus Exp";
d27 1
a27 1
static char rcsid[] = "$OpenBSD: ipxcp.c,v 1.3 1997/09/05 04:32:39 millert Exp $";
d1364 1
a1364 1
			    printer (arg, "%c", code);
d1366 1
a1366 1
			    printer (arg, " \\%.2x", code);
d1383 1
a1383 1
		printer(arg, " %.2x", code);
d1403 1
a1403 1
	printer(arg, " %.2x", code);
@


1.3
log
@ppp 2.3.1
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d27 1
a27 1
static char rcsid[] = "$OpenBSD: ipxcp.c,v 1.2 1996/12/23 13:22:42 mickey Exp $";
d45 1
d173 1
a173 1
    sprintf(b, "%lx", ipxaddr);
a345 2
    u_int32_t network;
    int unit = f->unit;
a394 1
    int unit = f->unit;
a417 2
    int len = *lenp;
    int unit = f->unit;
a466 1
    int unit = f->unit;
a574 1
    int unit = f->unit;
a692 1
    int unit = f->unit;
a808 1
    int unit = f->unit;
d811 2
a812 2
    u_short cishort, ts;	/* Parsed short value */
    u_int32_t tl, cinetwork, outnet;/* Parsed address values */
a817 1
    u_char maxslotindex, cflag;
d859 1
a859 1
	    IPXCPDEBUG((LOG_INFO,"Remote proposed IPX network number is %8Lx",tl));
a1093 1
	u_char *ps;
a1195 1
    u_int32_t ournn, network;
a1213 1
    int	 unit = f->unit;
@


1.2
log
@pppd 2.3b3 import. some minor buf oflow fixes and so.
try it out ppl, but i've got it running talking to cisco w/ all the AFs
enabled in kernel.
@
text
@d1 2
d24 5
a28 1
static char rcsid[] = "$OpenBSD$";
a123 1

d146 18
d208 3
d371 3
a373 1
 * Unless router protocol is suppressed then assume that we can do RIP.
d375 7
a381 8
    if (! (wo->router & BIT(0)))
	wo->router |= BIT(2);
/*
 * Router protocol is only negotiated if requested. Others force the
 * negotiation.
 */
    if (wo->router & (BIT(2) | BIT(4)))
	wo->neg_router = 1;
d391 1
d402 4
a405 14
    len += go->neg_complete ? CILEN_COMPLETE : 0;
/*
 * Router protocol 0 is mutually exclusive with the others.
 */
    if (go->neg_router) {
	if (go->router & BIT(0))
	    len += CILEN_PROTOCOL;
	else {
	    if (go->router & BIT(2))
		len += CILEN_PROTOCOL;
	    if (go->router & BIT(4))
		len += CILEN_PROTOCOL;
	}
    }
d448 3
a450 1
    if (go->neg_router && (go->router & (BIT(0) | BIT(2) | BIT(4)))) {
d452 3
a454 7
	    PUTCHAR  (CILEN_PROTOCOL,	   ucp);
	PUTSHORT (go->router,          ucp);
    }

    if (go->neg_complete) {
	PUTCHAR (IPX_COMPLETE,	 ucp);
	PUTCHAR (CILEN_COMPLETE, ucp);
d527 10
a536 4
    if (neg && p[1] == CILEN_PROTOCOL && len >= p[1] && p[0] == opt) \
      { \
	INCPTR(2, p); \
	len -= CILEN_PROTOCOL; \
d538 1
a538 1
	if (cishort != (val)) \
d549 2
a550 1
	ACKCICOMPLETE (IPX_COMPLETE,	    go->neg_complete);
d624 1
a624 1
	    /* These have never been sent. Ignore the NAK frame */
d633 2
a634 2
	    if ((s != 0) && (s != 2) && (s != 4))
		goto bad;
d636 2
a637 1
	    if (no.router & BIT(s))
d642 3
a644 2
	    no.router      |= BIT(s);
	    try.router     |= BIT(s);
d668 1
a668 1
     * support.
d670 5
a674 2
    try.router &= go->router;
    if (try.router == 0 && go->router != 0) {
d676 1
a676 3
	try.router     = BIT(0);
    }
    
d706 8
a713 4
    if (neg && p[1] == CILEN_NETN && len >= p[1] && p[0] == opt) { \
	neg = 0; \
	INCPTR(2, p); \
	len -= CILEN_NETN; \
d717 2
a718 1
	IPXCPDEBUG((LOG_INFO,"ipxcp_rejci rejected network 0x%08x", val)); \
d722 1
a722 1
    if (neg && p[1] == cnt + 2 && p[1] >= len && p[0] == opt) { \
d724 8
a731 3
	neg = 0; \
	INCPTR(2, p); \
	len -= (cnt + 2); \
d740 1
d747 8
a754 1
    if (neg && p[1] == CILEN_VOID && len >= p[1] && p[0] == opt) { \
a755 3
	INCPTR(2, p); \
	len -= CILEN_VOID; \
	IPXCPDEBUG((LOG_INFO, "ipxcp_rejci rejected void opt %d", opt)); \
d758 10
a767 5
#define REJCIPROTO(opt, neg, val) \
    if (neg && p[1] == CILEN_PROTOCOL && len >= p[1] && p[0] == opt) \
      { \
	INCPTR(2, p); \
	len -= CILEN_PROTOCOL; \
d769 1
a769 2
	IPXCPDEBUG((LOG_INFO, "ipxcp_rejci rejected router proto 0x%04x", cishort)); \
        if ((cishort & val) == 0) \
d771 3
a773 5
	val &= ~cishort; \
	if (val == 0) \
	    neg = 0; \
      }

a783 1
	REJCIPROTO   (IPX_ROUTER_PROTOCOL, try.neg_router, try.router);
d785 1
a785 1
	REJCIVOID    (IPX_COMPLETE,	   try.neg_complete);
d832 1
a832 1
    
d860 1
a860 1
	    
d969 2
a970 2
 * of the values 2 and 4 are permissible. '0' for no routing protocol must
 * be specified only once.
d980 1
a980 1
			"Remote router protocol number %d",
d983 3
a985 3
	    if ((cishort == 0 && ho->router != 0) || (ho->router & BIT(0))) {
		orc = CONFREJ;
		break;		
d988 2
a989 1
	    if (cishort != 0 && cishort != 2 && cishort != 4) {
d994 2
a995 1
	    if (ho->router & BIT (cishort)) {
d1000 1
a1000 1
	    ho->router	  |= BIT (cishort);
d1002 19
d1138 8
d1156 3
a1158 2
	IPXCPDEBUG((LOG_ERR, "Could not determine local IPX node address"));
	ipxcp_close(f->unit, "Could not determine local IPX node address");
d1167 3
a1169 2
	IPXCPDEBUG((LOG_ERR, "Could not determine network number"));
	ipxcp_close (unit, "Could not determine network number");
d1234 2
a1235 2
    if (go->neg_router) {
	if (go->router & BIT(2))
d1237 2
a1238 2
	if (go->router & BIT(4))
	    strcpy (strproto_lcl, "NLSP ");
d1247 2
a1248 2
    if (ho->neg_router) {
	if (ho->router & BIT(2))
d1250 2
a1251 2
	if (ho->router & BIT(4))
	    strcpy (strproto_rmt, "NLSP ");
d1359 1
a1359 1
		    printer (arg, "compression %d", cishort);
d1366 1
a1366 1
		    printer (arg, "router proto %d", cishort);
d1375 1
a1375 1
			if (code >= 0x20 && code < 0x7E)
@


1.1
log
@Update pppd to 2.3a4:
Add redo option error-reporting, add PAM, add microsoft compatibility
kludges, bzero stuff at important places, add one or two options
other generic enhancements.  From: Paul.Mackerras@@cs.anu.edu.au
@
text
@d22 1
a22 1
static char rcsid[] = "$Id: ipxcp.c,v 1.2 1996/07/01 01:14:25 paulus Exp $";
a430 1
	if (go->router & BIT(0)) {
d433 1
a433 14
	    PUTSHORT (0,		   ucp);
	} else {
	    if (go->router & BIT(2)) {
		PUTCHAR	 (IPX_ROUTER_PROTOCOL, ucp);
		PUTCHAR	 (CILEN_PROTOCOL,      ucp);
		PUTSHORT (2,		       ucp);
	    }
	    
	    if (go->router & BIT(4)) {
		PUTCHAR	 (IPX_ROUTER_PROTOCOL, ucp);
		PUTCHAR	 (CILEN_PROTOCOL,      ucp);
		PUTSHORT (4,		       ucp);
	    }
	}
d510 2
a511 2
#define ACKCIPROTO(opt, neg, val, bit) \
    if (neg && (val & BIT(bit))) \
d513 2
a514 9
	if (len < 2) \
	    break; \
	GETCHAR(citype, p); \
	GETCHAR(cilen, p); \
	if (cilen != CILEN_PROTOCOL || citype != opt) \
	    break; \
	len -= cilen; \
	if (len < 0) \
	    break; \
d516 1
a516 1
	if (cishort != (bit)) \
d526 1
a526 3
	ACKCIPROTO    (IPX_ROUTER_PROTOCOL, go->neg_router, go->router, 0);
	ACKCIPROTO    (IPX_ROUTER_PROTOCOL, go->neg_router, go->router, 2);
	ACKCIPROTO    (IPX_ROUTER_PROTOCOL, go->neg_router, go->router, 4);
d680 1
a680 1
    if (neg) { \
d682 2
a683 7
	if ((len -= CILEN_NETN) < 0) \
	    break; \
	GETCHAR(citype, p); \
	GETCHAR(cilen, p); \
	if (cilen != CILEN_NETN || \
	    citype != opt) \
	    break; \
d687 1
a687 1
	IPXCPDEBUG((LOG_INFO,"ipxcp_rejci rejected long opt %d", opt)); \
d691 1
a691 1
    if (neg) { \
d694 2
a695 8
	len -= (count + 2); \
	if (len < 0) \
	    break; \
	GETCHAR(citype, p); \
	GETCHAR(cilen, p); \
	if (cilen != (count + 2) || \
	    citype != opt) \
	    break; \
d710 1
a710 1
    if (neg) { \
d712 2
a713 6
	if ((len -= CILEN_VOID) < 0) \
	    break; \
	GETCHAR(citype, p); \
	GETCHAR(cilen, p); \
	if (cilen != CILEN_VOID || citype != opt) \
	    break; \
d717 2
a718 2
#define REJCIPROTO(opt, neg, val, bit) \
    if (neg && (val & BIT(bit))) \
d720 2
a721 9
	if (len < 2) \
	    break; \
	GETCHAR(citype, p); \
	GETCHAR(cilen, p); \
	if (cilen != CILEN_PROTOCOL || citype != opt) \
	    break; \
	len -= cilen; \
	if (len < 0) \
	    break; \
d723 2
a724 1
	if (cishort != (bit)) \
d726 1
a726 2
	IPXCPDEBUG((LOG_INFO, "ipxcp_rejci rejected router proto %d", bit)); \
	val &= ~BIT(bit); \
d741 1
a741 3
	REJCIPROTO   (IPX_ROUTER_PROTOCOL, try.neg_router, try.router, 0);
	REJCIPROTO   (IPX_ROUTER_PROTOCOL, try.neg_router, try.router, 2);
	REJCIPROTO   (IPX_ROUTER_PROTOCOL, try.neg_router, try.router, 4);
d1119 1
a1119 1
    ipxcp_script (f, "/etc/ppp/ipx-up");
d1139 1
a1139 1
    ipxcp_script (f, "/etc/ppp/ipx-down");
d1225 1
a1225 1
    void (*printer)();
@
