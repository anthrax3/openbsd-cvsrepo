head	1.29;
access;
symbols
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.26.0.6
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.8
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.6
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.4
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.2
	OPENBSD_5_0:1.24.0.8
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.6
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.10
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.20.0.4
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.10
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.8
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.12
	OPENBSD_2_8:1.12.0.10
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.8
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2015.12.06.12.00.16;	author tobias;	state Exp;
branches;
next	1.28;
commitid	CoyY8UEEpJPwBza5;

1.28
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	Uu5nFG3wCl0LACBb;

1.27
date	2014.12.10.03.39.54;	author jsg;	state Exp;
branches;
next	1.26;
commitid	HP8TIuL2tpcRHIlo;

1.26
date	2013.10.27.18.49.25;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2011.10.02.06.25.53;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.17.20.10.44;	author chl;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.04.14.59.45;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2007.03.06.03.06.41;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.25.22.41.54;	author moritz;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.04.20.25.07;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.23.21.07.43;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.01.19.31.37;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.28.07;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.09.22.21.54;	author pjanzen;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.23.15.34.02;	author lebel;	state Exp;
branches;
next	1.12;

1.12
date	98.05.08.04.52.29;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.01.17.20.30.26;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.10.25.05.09.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.09.05.04.32.43;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.25.20.12.15;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.01.02.10.50.20;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.12.23.13.22.45;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.12.15.23.20.34;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.07.20.12.02.13;	author joshd;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.41.23;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.51;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.59;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.59;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Use __progname instead of manually handling argv[0].

ok deraadt, mmcc, tedu
@
text
@/*	$OpenBSD: options.c,v 1.28 2015/01/16 06:40:19 deraadt Exp $	*/

/*
 * options.c - handles option processing for PPP.
 *
 * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name "Carnegie Mellon University" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For permission or any legal
 *    details, please contact
 *      Office of Technology Transfer
 *      Carnegie Mellon University
 *      5000 Forbes Avenue
 *      Pittsburgh, PA  15213-3890
 *      (412) 268-4387, fax: (412) 268-7395
 *      tech-transfer@@andrew.cmu.edu
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Computing Services
 *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
 *
 * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <ctype.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <limits.h>
#include <stdlib.h>
#include <termios.h>
#include <syslog.h>
#include <string.h>
#include <netdb.h>
#include <pwd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#ifdef PPP_FILTER
#include <pcap.h>
#include <pcap-int.h>	/* XXX: To get struct pcap */
#endif

#include "pppd.h"
#include "pathnames.h"
#include "patchlevel.h"
#include "fsm.h"
#include "lcp.h"
#include "ipcp.h"
#include "upap.h"
#include "chap.h"
#include "ccp.h"
#ifdef CBCP_SUPPORT
#include "cbcp.h"
#endif

#include <net/ppp-comp.h>

#define FALSE	0
#define TRUE	1

#if defined(ultrix) || defined(NeXT)
char *strdup(char *);
#endif

#ifndef GIDSET_TYPE
#define GIDSET_TYPE	gid_t
#endif

/*
 * Option variables and default values.
 */
#ifdef PPP_FILTER
int	dflag = 0;		/* Tell libpcap we want debugging */
#endif
int	debug = 0;		/* Debug flag */
int	kdebugflag = 0;		/* Tell kernel to print debug messages */
int	default_device = 1;	/* Using /dev/tty or equivalent */
char	devnam[PATH_MAX] = "/dev/tty";	/* Device name */
int	crtscts = 0;		/* Use hardware flow control */
int	modem = 1;		/* Use modem control lines */
int	modem_chat = 0;		/* Use modem control lines during chat */
int	inspeed = 0;		/* Input/Output speed requested */
u_int32_t netmask = 0;		/* IP netmask to set on interface */
int	lockflag = 0;		/* Create lock file to lock the serial dev */
int	nodetach = 0;		/* Don't detach from controlling tty */
char	*connector = NULL;	/* Script to establish physical link */
char	*disconnector = NULL;	/* Script to disestablish physical link */
char	*welcomer = NULL;	/* Script to run after phys link estab. */
int	maxconnect = 0;		/* Maximum connect time */
char	user[MAXNAMELEN];	/* Username for PAP */
char	passwd[MAXSECRETLEN];	/* Password for PAP */
int	auth_required = 0;	/* Peer is required to authenticate */
int	persist = 0;		/* Reopen link after it goes down */
int	uselogin = 0;		/* Use /etc/passwd for checking PAP */
int	lcp_echo_interval = 0; 	/* Interval between LCP echo-requests */
int	lcp_echo_fails = 0;	/* Tolerance to unanswered echo-requests */
char	our_name[MAXNAMELEN];	/* Our name for authentication purposes */
char	remote_name[MAXNAMELEN]; /* Peer's name for authentication */
int	explicit_remote = 0;	/* User specified explicit remote name */
int	usehostname = 0;	/* Use hostname for our_name */
int	disable_defaultip = 0;	/* Don't use hostname for default IP adrs */
int	demand = 0;		/* do dial-on-demand */
char	*ipparam = NULL;	/* Extra parameter for ip up/down scripts */
int	cryptpap;		/* Passwords in pap-secrets are encrypted */
int	idle_time_limit = 0;	/* Disconnect if idle for this many seconds */
int	holdoff = 30;		/* # seconds to pause before reconnecting */
int	refuse_pap = 0;		/* Set to say we won't do PAP */
int	refuse_chap = 0;	/* Set to say we won't do CHAP */

#ifdef MSLANMAN
int	ms_lanman = 0;    	/* Nonzero if use LanMan password instead of NT */
			  	/* Has meaning only with MS-CHAP challenges */
#endif

struct option_info auth_req_info;
struct option_info connector_info;
struct option_info disconnector_info;
struct option_info welcomer_info;
struct option_info devnam_info;
#ifdef PPP_FILTER
struct	bpf_program pass_filter;/* Filter program for packets to pass */
struct	bpf_program active_filter; /* Filter program for link-active pkts */
pcap_t  pc;			/* Fake struct pcap so we can compile expr */
#endif

/*
 * Prototypes
 */
static int setdevname(char *, int);
static int setipaddr(char *);
static int setspeed(char *);
static int setdebug(char **);
static int setkdebug(char **);
static int setpassive(char **);
static int setsilent(char **);
static int noopt(char **);
static int setnovj(char **);
static int setnovjccomp(char **);
static int setvjslots(char **);
static int reqpap(char **);
static int nopap(char **);
static int nochap(char **);
static int reqchap(char **);
static int noaccomp(char **);
static int noasyncmap(char **);
static int noip(char **);
static int nomagicnumber(char **);
static int setasyncmap(char **);
static int setescape(char **);
static int setmru(char **);
static int setmtu(char **);
#ifdef CBCP_SUPPORT
static int setcbcp(char **);
#endif
static int nomru(char **);
static int nopcomp(char **);
static int setconnector(char **);
static int setdisconnector(char **);
static int setwelcomer(char **);
static int setmaxconnect(char **);
static int setdomain(char **);
static int setnetmask(char **);
static int setcrtscts(char **);
static int setnocrtscts(char **);
static int setxonxoff(char **);
static int setnodetach(char **);
static int setupdetach(char **);
static int setmodem(char **);
static int setmodem_chat(char **);
static int setlocal(char **);
static int setlock(char **);
static int setname(char **);
static int setuser(char **);
static int setremote(char **);
static int setauth(char **);
static int setnoauth(char **);
static int readfile(char **);
static int callfile(char **);
static int setdefaultroute(char **);
static int setnodefaultroute(char **);
static int setproxyarp(char **);
static int setnoproxyarp(char **);
static int setpersist(char **);
static int setnopersist(char **);
static int setdologin(char **);
static int setusehostname(char **);
static int setnoipdflt(char **);
static int setlcptimeout(char **);
static int setlcpterm(char **);
static int setlcpconf(char **);
static int setlcpfails(char **);
static int setipcptimeout(char **);
static int setipcpterm(char **);
static int setipcpconf(char **);
static int setipcpfails(char **);
static int setpaptimeout(char **);
static int setpapreqs(char **);
static int setpapreqtime(char **);
static int setchaptimeout(char **);
static int setchapchal(char **);
static int setchapintv(char **);
static int setipcpaccl(char **);
static int setipcpaccr(char **);
static int setlcpechointv(char **);
static int setlcpechofails(char **);
static int noccp(char **);
static int setbsdcomp(char **);
static int setnobsdcomp(char **);
static int setdeflate(char **);
static int setnodeflate(char **);
static int setnodeflatedraft(char **);
static int setdemand(char **);
static int setpred1comp(char **);
static int setnopred1comp(char **);
static int setipparam(char **);
static int setpapcrypt(char **);
static int setidle(char **);
static int setholdoff(char **);
static int setdnsaddr(char **);
static int setwinsaddr(char **);
static int showversion(char **);
static int showhelp(char **);

#ifdef PPP_FILTER
static int setpdebug(char **);
static int setpassfilter(char **);
static int setactivefilter(char **);
#endif

#ifdef MSLANMAN
static int setmslanman(char **);
#endif

static int number_option(char *, u_int32_t *, int);
static int int_option(char *, int *);
static int readable(int fd);

/*
 * Valid arguments.
 */
static struct cmd {
    char *cmd_name;
    int num_args;
    int (*cmd_func)(char **);
} cmds[] = {
    {"-all", 0, noopt},		/* Don't request/allow any options (useless) */
    {"noaccomp", 0, noaccomp},	/* Disable Address/Control compression */
    {"-ac", 0, noaccomp},	/* Disable Address/Control compress */
    {"default-asyncmap", 0, noasyncmap}, /* Disable asyncmap negoatiation */
    {"-am", 0, noasyncmap},	/* Disable asyncmap negotiation */
    {"-as", 1, setasyncmap},	/* set the desired async map */
    {"-d", 0, setdebug},	/* Increase debugging level */
    {"nodetach", 0, setnodetach}, /* Don't detach from controlling tty */
    {"-detach", 0, setnodetach}, /* don't fork */
    {"updetach", 0, setupdetach}, /* Detach once an NP has come up */
    {"noip", 0, noip},		/* Disable IP and IPCP */
    {"-ip", 0, noip},		/* Disable IP and IPCP */
    {"nomagic", 0, nomagicnumber}, /* Disable magic number negotiation */
    {"-mn", 0, nomagicnumber},	/* Disable magic number negotiation */
    {"default-mru", 0, nomru},	/* Disable MRU negotiation */
    {"-mru", 0, nomru},		/* Disable mru negotiation */
    {"-p", 0, setpassive},	/* Set passive mode */
    {"nopcomp", 0, nopcomp},	/* Disable protocol field compression */
    {"-pc", 0, nopcomp},	/* Disable protocol field compress */
    {"require-pap", 0, reqpap},	/* Require PAP authentication from peer */
    {"+pap", 0, reqpap},	/* Require PAP auth from peer */
    {"refuse-pap", 0, nopap},	/* Don't agree to auth to peer with PAP */
    {"-pap", 0, nopap},		/* Don't allow UPAP authentication with peer */
    {"require-chap", 0, reqchap}, /* Require CHAP authentication from peer */
    {"+chap", 0, reqchap},	/* Require CHAP authentication from peer */
    {"refuse-chap", 0, nochap},	/* Don't agree to auth to peer with CHAP */
    {"-chap", 0, nochap},	/* Don't allow CHAP authentication with peer */
    {"novj", 0, setnovj},	/* Disable VJ compression */
    {"-vj", 0, setnovj},	/* disable VJ compression */
    {"novjccomp", 0, setnovjccomp}, /* disable VJ connection-ID compression */
    {"-vjccomp", 0, setnovjccomp}, /* disable VJ connection-ID compression */
    {"vj-max-slots", 1, setvjslots}, /* Set maximum VJ header slots */
    {"asyncmap", 1, setasyncmap}, /* set the desired async map */
    {"escape", 1, setescape},	/* set chars to escape on transmission */
    {"connect", 1, setconnector}, /* A program to set up a connection */
    {"disconnect", 1, setdisconnector},	/* program to disconnect serial dev. */
    {"welcome", 1, setwelcomer},/* Script to welcome client */
    {"maxconnect", 1, setmaxconnect},  /* specify a maximum connect time */
    {"crtscts", 0, setcrtscts},	/* set h/w flow control */
    {"nocrtscts", 0, setnocrtscts}, /* clear h/w flow control */
    {"-crtscts", 0, setnocrtscts}, /* clear h/w flow control */
    {"xonxoff", 0, setxonxoff},	/* set s/w flow control */
    {"debug", 0, setdebug},	/* Increase debugging level */
    {"kdebug", 1, setkdebug},	/* Enable kernel-level debugging */
    {"domain", 1, setdomain},	/* Add given domain name to hostname*/
    {"mru", 1, setmru},		/* Set MRU value for negotiation */
    {"mtu", 1, setmtu},		/* Set our MTU */
#ifdef CBCP_SUPPORT
    {"callback", 1, setcbcp},	/* Ask for callback */
#endif
    {"netmask", 1, setnetmask},	/* set netmask */
    {"passive", 0, setpassive},	/* Set passive mode */
    {"silent", 0, setsilent},	/* Set silent mode */
    {"modem", 0, setmodem},	/* Use modem control lines */
    {"modem_chat", 0, setmodem_chat}, /* Use modem control lines during chat */
    {"local", 0, setlocal},	/* Don't use modem control lines */
    {"lock", 0, setlock},	/* Lock serial device (with lock file) */
    {"name", 1, setname},	/* Set local name for authentication */
    {"user", 1, setuser},	/* Set name for auth with peer */
    {"usehostname", 0, setusehostname},	/* Must use hostname for auth. */
    {"remotename", 1, setremote}, /* Set remote name for authentication */
    {"auth", 0, setauth},	/* Require authentication from peer */
    {"noauth", 0, setnoauth},	/* Don't require peer to authenticate */
    {"file", 1, readfile},	/* Take options from a file */
    {"call", 1, callfile},	/* Take options from a privileged file */
    {"defaultroute", 0, setdefaultroute}, /* Add default route */
    {"nodefaultroute", 0, setnodefaultroute}, /* disable defaultroute option */
    {"-defaultroute", 0, setnodefaultroute}, /* disable defaultroute option */
    {"proxyarp", 0, setproxyarp}, /* Add proxy ARP entry */
    {"noproxyarp", 0, setnoproxyarp}, /* disable proxyarp option */
    {"-proxyarp", 0, setnoproxyarp}, /* disable proxyarp option */
    {"persist", 0, setpersist},	/* Keep on reopening connection after close */
    {"nopersist", 0, setnopersist},  /* Turn off persist option */
    {"demand", 0, setdemand},	/* Dial on demand */
    {"login", 0, setdologin},	/* Use system password database for UPAP */
    {"noipdefault", 0, setnoipdflt}, /* Don't use name for default IP adrs */
    {"lcp-echo-failure", 1, setlcpechofails}, /* consecutive echo failures */
    {"lcp-echo-interval", 1, setlcpechointv}, /* time for lcp echo events */
    {"lcp-restart", 1, setlcptimeout}, /* Set timeout for LCP */
    {"lcp-max-terminate", 1, setlcpterm}, /* Set max #xmits for term-reqs */
    {"lcp-max-configure", 1, setlcpconf}, /* Set max #xmits for conf-reqs */
    {"lcp-max-failure", 1, setlcpfails}, /* Set max #conf-naks for LCP */
    {"ipcp-restart", 1, setipcptimeout}, /* Set timeout for IPCP */
    {"ipcp-max-terminate", 1, setipcpterm}, /* Set max #xmits for term-reqs */
    {"ipcp-max-configure", 1, setipcpconf}, /* Set max #xmits for conf-reqs */
    {"ipcp-max-failure", 1, setipcpfails}, /* Set max #conf-naks for IPCP */
    {"pap-restart", 1, setpaptimeout},	/* Set retransmit timeout for PAP */
    {"pap-max-authreq", 1, setpapreqs}, /* Set max #xmits for auth-reqs */
    {"pap-timeout", 1, setpapreqtime},	/* Set time limit for peer PAP auth. */
    {"chap-restart", 1, setchaptimeout}, /* Set timeout for CHAP */
    {"chap-max-challenge", 1, setchapchal}, /* Set max #xmits for challenge */
    {"chap-interval", 1, setchapintv}, /* Set interval for rechallenge */
    {"ipcp-accept-local", 0, setipcpaccl}, /* Accept peer's address for us */
    {"ipcp-accept-remote", 0, setipcpaccr}, /* Accept peer's address for it */
    {"noccp", 0, noccp},		/* Disable CCP negotiation */
    {"-ccp", 0, noccp},			/* Disable CCP negotiation */
    {"bsdcomp", 1, setbsdcomp},		/* request BSD-Compress */
    {"nobsdcomp", 0, setnobsdcomp},	/* don't allow BSD-Compress */
    {"-bsdcomp", 0, setnobsdcomp},	/* don't allow BSD-Compress */
    {"deflate", 1, setdeflate},		/* request Deflate compression */
    {"nodeflate", 0, setnodeflate},	/* don't allow Deflate compression */
    {"-deflate", 0, setnodeflate},	/* don't allow Deflate compression */
    {"nodeflatedraft", 0, setnodeflatedraft}, /* don't use draft deflate # */
    {"predictor1", 0, setpred1comp},	/* request Predictor-1 */
    {"nopredictor1", 0, setnopred1comp},/* don't allow Predictor-1 */
    {"-predictor1", 0, setnopred1comp},	/* don't allow Predictor-1 */
    {"ipparam", 1, setipparam},		/* set ip script parameter */
    {"papcrypt", 0, setpapcrypt},	/* PAP passwords encrypted */
    {"idle", 1, setidle},		/* idle time limit (seconds) */
    {"holdoff", 1, setholdoff},		/* set holdoff time (seconds) */
    {"ms-dns", 1, setdnsaddr},		/* DNS address for the peer's use */
    {"ms-wins", 1, setwinsaddr},	/* Nameserver for SMB over TCP/IP for peer */
    {"--version", 0, showversion},	/* Show version number */
    {"--help", 0, showhelp},		/* Show brief listing of options */
    {"-h", 0, showhelp},		/* ditto */

#ifdef PPP_FILTER
    {"pdebug", 1, setpdebug},		/* libpcap debugging */
    {"pass-filter", 1, setpassfilter},	/* set filter for packets to pass */
    {"active-filter", 1, setactivefilter}, /* set filter for active pkts */
#endif

#ifdef MSLANMAN
    {"ms-lanman", 0, setmslanman},	/* Use LanMan psswd when using MS-CHAP */
#endif

    {NULL, 0, NULL}
};


#ifndef IMPLEMENTATION
#define IMPLEMENTATION ""
#endif

static const char usage_string[] = "\
pppd version %s patch level %d%s\n\
Usage: %s [ options ], where options are:\n\
	<device>	Communicate over the named device\n\
	<speed>		Set the baud rate to <speed>\n\
	<loc>:<rem>	Set the local and/or remote interface IP\n\
			addresses.  Either one may be omitted.\n\
	asyncmap <n>	Set the desired async map to hex <n>\n\
	auth		Require authentication from peer\n\
        connect <p>     Invoke shell command <p> to set up the serial line\n\
	crtscts		Use hardware RTS/CTS flow control\n\
	defaultroute	Add default route through interface\n\
	file <f>	Take options from file <f>\n\
	modem		Use modem control lines\n\
	modem_chat	Use modem control lines during chat\n\
	mru <n>		Set MRU value to <n> for negotiation\n\
	netmask <n>	Set interface netmask to <n>\n\
See pppd(8) for more options.\n\
";

static char *current_option;	/* the name of the option being parsed */
static int privileged_option;	/* set iff the current option came from root */
static char *option_source;	/* string saying where the option came from */

/*
 * parse_args - parse a string of arguments from the command line.
 */
int
parse_args(argc, argv)
    int argc;
    char **argv;
{
    char *arg;
    struct cmd *cmdp;
    int ret;

    privileged_option = privileged;
    option_source = "command line";
    while (argc > 0) {
	arg = *argv++;
	--argc;

	/*
	 * First see if it's a command.
	 */
	for (cmdp = cmds; cmdp->cmd_name; cmdp++)
	    if (!strcmp(arg, cmdp->cmd_name))
		break;

	if (cmdp->cmd_name != NULL) {
	    if (argc < cmdp->num_args) {
		option_error("too few parameters for option %s", arg);
		return 0;
	    }
	    current_option = arg;
	    if (!(*cmdp->cmd_func)(argv))
		return 0;
	    argc -= cmdp->num_args;
	    argv += cmdp->num_args;

	} else {
	    /*
	     * Maybe a tty name, speed or IP address?
	     */
	    if ((ret = setdevname(arg, 0)) == 0
		&& (ret = setspeed(arg)) == 0
		&& (ret = setipaddr(arg)) == 0) {
		option_error("unrecognized option '%s'", arg);
		usage();
		return 0;
	    }
	    if (ret < 0)	/* error */
		return 0;
	}
    }
    return 1;
}

/*
 * scan_args - scan the command line arguments to get the tty name,
 * if specified.
 */
void
scan_args(argc, argv)
    int argc;
    char **argv;
{
    char *arg;
    struct cmd *cmdp;

    while (argc > 0) {
	arg = *argv++;
	--argc;

	/* Skip options and their arguments */
	for (cmdp = cmds; cmdp->cmd_name; cmdp++)
	    if (!strcmp(arg, cmdp->cmd_name))
		break;

	if (cmdp->cmd_name != NULL) {
	    argc -= cmdp->num_args;
	    argv += cmdp->num_args;
	    continue;
	}

	/* Check if it's a tty name and copy it if so */
	(void) setdevname(arg, 1);
    }
}

/*
 * usage - print out a message telling how to use the program.
 */
void
usage()
{
    if (phase == PHASE_INITIALIZE)
	fprintf(stderr, usage_string, VERSION, PATCHLEVEL, IMPLEMENTATION,
		__progname);
}

/*
 * showhelp - print out usage message and exit.
 */
static int
showhelp(argv)
    char **argv;
{
    if (phase == PHASE_INITIALIZE) {
	usage();
	exit(0);
    }
    return 0;
}

/*
 * showversion - print out the version number and exit.
 */
static int
showversion(argv)
    char **argv;
{
    if (phase == PHASE_INITIALIZE) {
	fprintf(stderr, "pppd version %s patch level %d%s\n",
		VERSION, PATCHLEVEL, IMPLEMENTATION);
	exit(0);
    }
    return 0;
}

/*
 * options_from_file - Read a string of options from a file,
 * and interpret them.
 */
int
options_from_file(filename, must_exist, check_prot, priv)
    char *filename;
    int must_exist;
    int check_prot;
    int priv;
{
    FILE *f;
    int i, newline, ret;
    struct cmd *cmdp;
    int oldpriv;
    char *argv[MAXARGS];
    char args[MAXARGS][MAXWORDLEN];
    char cmd[MAXWORDLEN];

    if ((f = fopen(filename, "r")) == NULL) {
	if (!must_exist && errno == ENOENT)
	    return 1;
	option_error("Can't open options file %s: %m", filename);
	return 0;
    }
    if (check_prot && !readable(fileno(f))) {
	option_error("Can't open options file %s: access denied", filename);
	fclose(f);
	return 0;
    }

    oldpriv = privileged_option;
    privileged_option = priv;
    ret = 0;
    while (getword(f, cmd, &newline, filename)) {
	/*
	 * First see if it's a command.
	 */
	for (cmdp = cmds; cmdp->cmd_name; cmdp++)
	    if (!strcmp(cmd, cmdp->cmd_name))
		break;

	if (cmdp->cmd_name != NULL) {
	    for (i = 0; i < cmdp->num_args; ++i) {
		if (!getword(f, args[i], &newline, filename)) {
		    option_error(
			"In file %s: too few parameters for option '%s'",
			filename, cmd);
		    goto err;
		}
		argv[i] = args[i];
	    }
	    current_option = cmd;
	    if (!(*cmdp->cmd_func)(argv))
		goto err;

	} else {
	    /*
	     * Maybe a tty name, speed or IP address?
	     */
	    if ((i = setdevname(cmd, 0)) == 0
		&& (i = setspeed(cmd)) == 0
		&& (i = setipaddr(cmd)) == 0) {
		option_error("In file %s: unrecognized option '%s'",
			     filename, cmd);
		goto err;
	    }
	    if (i < 0)		/* error */
		goto err;
	}
    }
    ret = 1;

err:
    fclose(f);
    privileged_option = oldpriv;
    return ret;
}

/*
 * options_from_user - See if the use has a ~/.ppprc file,
 * and if so, interpret options from it.
 */
int
options_from_user()
{
    char *user, *path, *file;
    int ret;
    struct passwd *pw;

    pw = getpwuid(getuid());
    if (pw == NULL || (user = pw->pw_dir) == NULL || user[0] == 0)
	return 1;
    file = _PATH_USEROPT;
    if (asprintf(&path, "%s/%s", user, file) == -1)
	novm("init file name");
    ret = options_from_file(path, 0, 1, privileged);
    free(path);
    return ret;
}

/*
 * options_for_tty - See if an options file exists for the serial
 * device, and if so, interpret options from it.
 */
int
options_for_tty()
{
    char *dev, *path;
    int ret;

    dev = devnam;
    if (strncmp(dev, "/dev/", 5) == 0)
	dev += 5;
    if (strcmp(dev, "tty") == 0)
	return 1;		/* don't look for /etc/ppp/options.tty */
    if (asprintf(&path, "%s%s", _PATH_TTYOPT, dev) == -1)
	novm("tty init file name");
    ret = options_from_file(path, 0, 0, 1);
    free(path);
    return ret;
}

/*
 * option_error - print a message about an error in an option.
 * The message is logged, and also sent to
 * stderr if phase == PHASE_INITIALIZE.
 */
void
option_error(char *fmt, ...)
{
    va_list args;
    char buf[256];

    va_start(args, fmt);
    vfmtmsg(buf, sizeof(buf), fmt, args);
    va_end(args);
    if (phase == PHASE_INITIALIZE)
	fprintf(stderr, "%s: %s\n", __progname, buf);
    syslog(LOG_ERR, "%s", buf);
}

/*
 * readable - check if a file is readable by the real user.
 */
static int
readable(fd)
    int fd;
{
    uid_t uid;
    int ngroups, i;
    struct stat sbuf;
    GIDSET_TYPE groups[NGROUPS_MAX];

    uid = getuid();
    if (uid == 0)
	return 1;
    if (fstat(fd, &sbuf) != 0)
	return 0;
    if (sbuf.st_uid == uid)
	return sbuf.st_mode & S_IRUSR;
    if (sbuf.st_gid == getgid())
	return sbuf.st_mode & S_IRGRP;
    ngroups = getgroups(NGROUPS_MAX, groups);
    for (i = 0; i < ngroups; ++i)
	if (sbuf.st_gid == groups[i])
	    return sbuf.st_mode & S_IRGRP;
    return sbuf.st_mode & S_IROTH;
}

/*
 * Read a word from a file.
 * Words are delimited by white-space or by quotes (" or ').
 * Quotes, white-space and \ may be escaped with \.
 * \<newline> is ignored.
 */
int
getword(f, word, newlinep, filename)
    FILE *f;
    char *word;
    int *newlinep;
    char *filename;
{
    int c, len, escape;
    int quoted, comment;
    int value, digit, got, n;

#define isoctal(c) ((c) >= '0' && (c) < '8')

    *newlinep = 0;
    len = 0;
    escape = 0;
    comment = 0;

    /*
     * First skip white-space and comments.
     */
    for (;;) {
	c = getc(f);
	if (c == EOF)
	    break;

	/*
	 * A newline means the end of a comment; backslash-newline
	 * is ignored.  Note that we cannot have escape && comment.
	 */
	if (c == '\n') {
	    if (!escape) {
		*newlinep = 1;
		comment = 0;
	    } else
		escape = 0;
	    continue;
	}

	/*
	 * Ignore characters other than newline in a comment.
	 */
	if (comment)
	    continue;

	/*
	 * If this character is escaped, we have a word start.
	 */
	if (escape)
	    break;

	/*
	 * If this is the escape character, look at the next character.
	 */
	if (c == '\\') {
	    escape = 1;
	    continue;
	}

	/*
	 * If this is the start of a comment, ignore the rest of the line.
	 */
	if (c == '#') {
	    comment = 1;
	    continue;
	}

	/*
	 * A non-whitespace character is the start of a word.
	 */
	if (!isspace(c))
	    break;
    }

    /*
     * Save the delimiter for quoted strings.
     */
    if (!escape && (c == '"' || c == '\'')) {
        quoted = c;
	c = getc(f);
    } else
        quoted = 0;

    /*
     * Process characters until the end of the word.
     */
    while (c != EOF) {
	if (escape) {
	    /*
	     * This character is escaped: backslash-newline is ignored,
	     * various other characters indicate particular values
	     * as for C backslash-escapes.
	     */
	    escape = 0;
	    if (c == '\n') {
	        c = getc(f);
		continue;
	    }

	    got = 0;
	    switch (c) {
	    case 'a':
		value = '\a';
		break;
	    case 'b':
		value = '\b';
		break;
	    case 'f':
		value = '\f';
		break;
	    case 'n':
		value = '\n';
		break;
	    case 'r':
		value = '\r';
		break;
	    case 's':
		value = ' ';
		break;
	    case 't':
		value = '\t';
		break;

	    default:
		if (isoctal(c)) {
		    /*
		     * \ddd octal sequence
		     */
		    value = 0;
		    for (n = 0; n < 3 && isoctal(c); ++n) {
			value = (value << 3) + (c & 07);
			c = getc(f);
		    }
		    got = 1;
		    break;
		}

		if (c == 'x') {
		    /*
		     * \x<hex_string> sequence
		     */
		    value = 0;
		    c = getc(f);
		    for (n = 0; n < 2 && isxdigit(c); ++n) {
			digit = toupper(c) - '0';
			if (digit > 10)
			    digit += '0' + 10 - 'A';
			value = (value << 4) + digit;
			c = getc (f);
		    }
		    got = 1;
		    break;
		}

		/*
		 * Otherwise the character stands for itself.
		 */
		value = c;
		break;
	    }

	    /*
	     * Store the resulting character for the escape sequence.
	     */
	    if (len < MAXWORDLEN) {
		word[len] = value;
		++len;
	    }

	    if (!got)
		c = getc(f);
	    continue;

	}

	/*
	 * Not escaped: see if we've reached the end of the word.
	 */
	if (quoted) {
	    if (c == quoted)
		break;
	} else {
	    if (isspace(c) || c == '#') {
		ungetc (c, f);
		break;
	    }
	}

	/*
	 * Backslash starts an escape sequence.
	 */
	if (c == '\\') {
	    escape = 1;
	    c = getc(f);
	    continue;
	}

	/*
	 * An ordinary character: store it in the word and get another.
	 */
	if (len < MAXWORDLEN) {
	    word[len] = c;
	    ++len;
	}

	c = getc(f);
    }

    /*
     * End of the word: check for errors.
     */
    if (c == EOF) {
	if (ferror(f)) {
	    if (errno == 0)
		errno = EIO;
	    option_error("Error reading %s: %m", filename);
	    die(1);
	}
	/*
	 * If len is zero, then we didn't find a word before the
	 * end of the file.
	 */
	if (len == 0)
	    return 0;
    }

    /*
     * Warn if the word was too long, and append a terminating null.
     */
    if (len >= MAXWORDLEN) {
	option_error("warning: word in file %s too long (%.20s...)",
		     filename, word);
	len = MAXWORDLEN - 1;
    }
    word[len] = 0;

    return 1;

#undef isoctal

}

/*
 * number_option - parse an unsigned numeric parameter for an option.
 */
static int
number_option(str, valp, base)
    char *str;
    u_int32_t *valp;
    int base;
{
    char *ptr;

    *valp = strtoul(str, &ptr, base);
    if (ptr == str) {
	option_error("invalid numeric parameter '%s' for %s option",
		     str, current_option);
	return 0;
    }
    return 1;
}


/*
 * int_option - like number_option, but valp is int *,
 * the base is assumed to be 0, and *valp is not changed
 * if there is an error.
 */
static int
int_option(str, valp)
    char *str;
    int *valp;
{
    u_int32_t v;

    if (!number_option(str, &v, 0))
	return 0;
    *valp = (int) v;
    return 1;
}


/*
 * The following procedures parse options.
 */

/*
 * readfile - take commands from a file.
 */
static int
readfile(argv)
    char **argv;
{
    return options_from_file(*argv, 1, 1, privileged_option);
}

/*
 * callfile - take commands from /etc/ppp/peers/<name>.
 * Name may not contain /../, start with / or ../, or end in /..
 */
static int
callfile(argv)
    char **argv;
{
    char *fname, *arg, *p;
    int l, ok;

    arg = *argv;
    ok = 1;
    if (arg[0] == '/' || arg[0] == 0)
	ok = 0;
    else {
	for (p = arg; *p != 0; ) {
	    if (p[0] == '.' && p[1] == '.' && (p[2] == '/' || p[2] == 0)) {
		ok = 0;
		break;
	    }
	    while (*p != '/' && *p != 0)
		++p;
	    if (*p == '/')
		++p;
	}
    }
    if (!ok) {
	option_error("call option value may not contain .. or start with /");
	return 0;
    }

    l = strlen(arg) + strlen(_PATH_PEERFILES) + 1;
    if ((fname = (char *) malloc(l)) == NULL)
	novm("call file name");
    strlcpy(fname, _PATH_PEERFILES, l);
    strlcat(fname, arg, l);

    ok = options_from_file(fname, 1, 1, 1);

    free(fname);
    return ok;
}


/*
 * setdebug - Set debug (command line argument).
 */
static int
setdebug(argv)
    char **argv;
{
    debug++;
    return (1);
}

/*
 * setkdebug - Set kernel debugging level.
 */
static int
setkdebug(argv)
    char **argv;
{
    return int_option(*argv, &kdebugflag);
}

#ifdef PPP_FILTER
/*
 * setpdebug - Set libpcap debugging level.
 */
static int
setpdebug(argv)
    char **argv;
{
    return int_option(*argv, &dflag);
}

/*
 * setpassfilter - Set the pass filter for packets
 */
static int
setpassfilter(argv)
    char **argv;
{
    pc.linktype = DLT_PPP;
    pc.snapshot = PPP_HDRLEN;
 
    if (pcap_compile(&pc, &pass_filter, *argv, 1, netmask) == 0)
	return 1;
    option_error("error in pass-filter expression: %s\n", pcap_geterr(&pc));
    return 0;
}

/*
 * setactivefilter - Set the active filter for packets
 */
static int
setactivefilter(argv)
    char **argv;
{
    pc.linktype = DLT_PPP;
    pc.snapshot = PPP_HDRLEN;
 
    if (pcap_compile(&pc, &active_filter, *argv, 1, netmask) == 0)
	return 1;
    option_error("error in active-filter expression: %s\n", pcap_geterr(&pc));
    return 0;
}
#endif

/*
 * noopt - Disable all options.
 */
static int
noopt(argv)
    char **argv;
{
    BZERO((char *) &lcp_wantoptions[0], sizeof (struct lcp_options));
    BZERO((char *) &lcp_allowoptions[0], sizeof (struct lcp_options));
    BZERO((char *) &ipcp_wantoptions[0], sizeof (struct ipcp_options));
    BZERO((char *) &ipcp_allowoptions[0], sizeof (struct ipcp_options));

    return (1);
}

/*
 * noaccomp - Disable Address/Control field compression negotiation.
 */
static int
noaccomp(argv)
    char **argv;
{
    lcp_wantoptions[0].neg_accompression = 0;
    lcp_allowoptions[0].neg_accompression = 0;
    return (1);
}


/*
 * noasyncmap - Disable async map negotiation.
 */
static int
noasyncmap(argv)
    char **argv;
{
    lcp_wantoptions[0].neg_asyncmap = 0;
    lcp_allowoptions[0].neg_asyncmap = 0;
    return (1);
}


/*
 * noip - Disable IP and IPCP.
 */
static int
noip(argv)
    char **argv;
{
    ipcp_protent.enabled_flag = 0;
    return (1);
}


/*
 * nomagicnumber - Disable magic number negotiation.
 */
static int
nomagicnumber(argv)
    char **argv;
{
    lcp_wantoptions[0].neg_magicnumber = 0;
    lcp_allowoptions[0].neg_magicnumber = 0;
    return (1);
}


/*
 * nomru - Disable mru negotiation.
 */
static int
nomru(argv)
    char **argv;
{
    lcp_wantoptions[0].neg_mru = 0;
    lcp_allowoptions[0].neg_mru = 0;
    return (1);
}


/*
 * setmru - Set MRU for negotiation.
 */
static int
setmru(argv)
    char **argv;
{
    u_int32_t mru;

    if (!number_option(*argv, &mru, 0))
	return 0;
    lcp_wantoptions[0].mru = mru;
    lcp_wantoptions[0].neg_mru = 1;
    return (1);
}


/*
 * setmru - Set the largest MTU we'll use.
 */
static int
setmtu(argv)
    char **argv;
{
    u_int32_t mtu;

    if (!number_option(*argv, &mtu, 0))
	return 0;
    if (mtu < MINMRU || mtu > MAXMRU) {
	option_error("mtu option value of %u is too %s", mtu,
		     (mtu < MINMRU? "small": "large"));
	return 0;
    }
    lcp_allowoptions[0].mru = mtu;
    return (1);
}

#ifdef CBCP_SUPPORT
static int
setcbcp(argv)
    char **argv;
{
    lcp_wantoptions[0].neg_cbcp = 1;
    cbcp_protent.enabled_flag = 1;
    cbcp[0].us_number = strdup(*argv);
    if (cbcp[0].us_number == 0)
	novm("callback number");
    cbcp[0].us_type |= (1 << CB_CONF_USER);
    cbcp[0].us_type |= (1 << CB_CONF_ADMIN);
    return (1);
}
#endif

/*
 * nopcomp - Disable Protocol field compression negotiation.
 */
static int
nopcomp(argv)
    char **argv;
{
    lcp_wantoptions[0].neg_pcompression = 0;
    lcp_allowoptions[0].neg_pcompression = 0;
    return (1);
}


/*
 * setpassive - Set passive mode (don't give up if we time out sending
 * LCP configure-requests).
 */
static int
setpassive(argv)
    char **argv;
{
    lcp_wantoptions[0].passive = 1;
    return (1);
}


/*
 * setsilent - Set silent mode (don't start sending LCP configure-requests
 * until we get one from the peer).
 */
static int
setsilent(argv)
    char **argv;
{
    lcp_wantoptions[0].silent = 1;
    return 1;
}


/*
 * nopap - Disable PAP authentication with peer.
 */
static int
nopap(argv)
    char **argv;
{
    refuse_pap = 1;
    return (1);
}


/*
 * reqpap - Require PAP authentication from peer.
 */
static int
reqpap(argv)
    char **argv;
{
    lcp_wantoptions[0].neg_upap = 1;
    setauth(NULL);
    return 1;
}

/*
 * nochap - Disable CHAP authentication with peer.
 */
static int
nochap(argv)
    char **argv;
{
    refuse_chap = 1;
    return (1);
}


/*
 * reqchap - Require CHAP authentication from peer.
 */
static int
reqchap(argv)
    char **argv;
{
    lcp_wantoptions[0].neg_chap = 1;
    setauth(NULL);
    return (1);
}


/*
 * setnovj - disable vj compression
 */
static int
setnovj(argv)
    char **argv;
{
    ipcp_wantoptions[0].neg_vj = 0;
    ipcp_allowoptions[0].neg_vj = 0;
    return (1);
}


/*
 * setnovjccomp - disable VJ connection-ID compression
 */
static int
setnovjccomp(argv)
    char **argv;
{
    ipcp_wantoptions[0].cflag = 0;
    ipcp_allowoptions[0].cflag = 0;
    return 1;
}


/*
 * setvjslots - set maximum number of connection slots for VJ compression
 */
static int
setvjslots(argv)
    char **argv;
{
    int value;

    if (!int_option(*argv, &value))
	return 0;
    if (value < 2 || value > 16) {
	option_error("vj-max-slots value must be between 2 and 16");
	return 0;
    }
    ipcp_wantoptions [0].maxslotindex =
        ipcp_allowoptions[0].maxslotindex = value - 1;
    return 1;
}


/*
 * setconnector - Set a program to connect to a serial line
 */
static int
setconnector(argv)
    char **argv;
{
    connector = strdup(*argv);
    if (connector == NULL)
	novm("connect script");
    connector_info.priv = privileged_option;
    connector_info.source = option_source;

    return (1);
}

/*
 * setdisconnector - Set a program to disconnect from the serial line
 */
static int
setdisconnector(argv)
    char **argv;
{
    disconnector = strdup(*argv);
    if (disconnector == NULL)
	novm("disconnect script");
    disconnector_info.priv = privileged_option;
    disconnector_info.source = option_source;
  
    return (1);
}

/*
 * setwelcomer - Set a program to welcome a client after connection
 */
static int
setwelcomer(argv)
    char **argv;
{
    welcomer = strdup(*argv);
    if (welcomer == NULL)
	novm("welcome script");
    welcomer_info.priv = privileged_option;
    welcomer_info.source = option_source;

    return (1);
}

/*
 * setmaxconnect - Set the maximum connect time
 */
static int
setmaxconnect(argv)
    char **argv;
{
    int value;

    if (!int_option(*argv, &value))
	return 0;
    if (value < 0) {
	option_error("maxconnect time must be positive");
	return 0;
    }
    if (maxconnect > 0 && (value == 0 || value > maxconnect)) {
	option_error("maxconnect time cannot be increased");
	return 0;
    }
    maxconnect = value;
    return 1;
}

/*
 * setdomain - Set domain name to append to hostname 
 */
static int
setdomain(argv)
    char **argv;
{
    if (!privileged_option) {
	option_error("using the domain option requires root privilege");
	return 0;
    }
    gethostname(hostname, MAXNAMELEN);
    if (**argv != 0) {
	if (**argv != '.')
	    strlcat(hostname, ".", MAXNAMELEN);
	strlcat(hostname, *argv, MAXNAMELEN);
    }
    hostname[MAXNAMELEN-1] = 0;
    return (1);
}


/*
 * setasyncmap - add bits to asyncmap (what we request peer to escape).
 */
static int
setasyncmap(argv)
    char **argv;
{
    u_int32_t asyncmap;

    if (!number_option(*argv, &asyncmap, 16))
	return 0;
    lcp_wantoptions[0].asyncmap |= asyncmap;
    lcp_wantoptions[0].neg_asyncmap = 1;
    return(1);
}


/*
 * setescape - add chars to the set we escape on transmission.
 */
static int
setescape(argv)
    char **argv;
{
    int n, ret;
    char *p, *endp;

    p = *argv;
    ret = 1;
    while (*p) {
	n = strtol(p, &endp, 16);
	if (p == endp) {
	    option_error("escape parameter contains invalid hex number '%s'",
			 p);
	    return 0;
	}
	p = endp;
	if (n < 0 || (0x20 <= n && n <= 0x3F) || n == 0x5E || n > 0xFF) {
	    option_error("can't escape character 0x%x", n);
	    ret = 0;
	} else
	    xmit_accm[0][n >> 5] |= 1 << (n & 0x1F);
	while (*p == ',' || *p == ' ')
	    ++p;
    }
    return ret;
}


/*
 * setspeed - Set the speed.
 */
static int
setspeed(arg)
    char *arg;
{
    char *ptr;
    int spd;

    spd = strtol(arg, &ptr, 0);
    if (ptr == arg || *ptr != 0 || spd == 0)
	return 0;
    inspeed = spd;
    return 1;
}


/*
 * setdevname - Set the device name.
 */
static int
setdevname(cp, quiet)
    char *cp;
    int quiet;
{
    struct stat statbuf;
    char dev[PATH_MAX];

    if (*cp == 0)
	return 0;

    if (strncmp("/dev/", cp, 5) != 0) {
	strlcpy(dev, "/dev/", sizeof dev);
	strlcat(dev, cp, sizeof dev);
	cp = dev;
    }

    /*
     * Check if there is a device by this name.
     */
    if (stat(cp, &statbuf) < 0) {
	if (errno == ENOENT || quiet)
	    return 0;
	option_error("Couldn't stat %s: %m", cp);
	return -1;
    }

    (void) strlcpy(devnam, cp, PATH_MAX);
    default_device = FALSE;
    devnam_info.priv = privileged_option;
    devnam_info.source = option_source;
  
    return 1;
}


/*
 * setipaddr - Set the IP address
 */
static int
setipaddr(arg)
    char *arg;
{
    struct hostent *hp;
    char *colon;
    struct in_addr ina;
    u_int32_t local, remote;
    ipcp_options *wo = &ipcp_wantoptions[0];
  
    /*
     * IP address pair separated by ":".
     */
    if ((colon = strchr(arg, ':')) == NULL)
	return 0;
  
    /*
     * If colon first character, then no local addr.
     */
    if (colon != arg) {
	*colon = '\0';
	if (inet_aton(arg, &ina) == 0) {
	    if ((hp = gethostbyname(arg)) == NULL) {
		option_error("unknown host: %s", arg);
		return -1;
	    } else {
		local = *(u_int32_t *)hp->h_addr;
		if (our_name[0] == 0)
		    strlcpy(our_name, arg, MAXNAMELEN);
	    }
	} else
	    local = ina.s_addr;
	if (bad_ip_adrs(local)) {
	    option_error("bad local IP address %s", ip_ntoa(local));
	    return -1;
	}
	if (local != 0)
	    wo->ouraddr = local;
	*colon = ':';
    }
  
    /*
     * If colon last character, then no remote addr.
     */
    if (*++colon != '\0') {
	if (inet_aton(colon, &ina) == 0) {
	    if ((hp = gethostbyname(colon)) == NULL) {
		option_error("unknown host: %s", colon);
		return -1;
	    } else {
		remote = *(u_int32_t *)hp->h_addr;
		if (remote_name[0] == 0)
		    strlcpy(remote_name, colon, MAXNAMELEN);
	    }
	} else
	    remote = ina.s_addr;
	if (bad_ip_adrs(remote)) {
	    option_error("bad remote IP address %s", ip_ntoa(remote));
	    return -1;
	}
	if (remote != 0)
	    wo->hisaddr = remote;
    }

    return 1;
}


/*
 * setnoipdflt - disable setipdefault()
 */
static int
setnoipdflt(argv)
    char **argv;
{
    disable_defaultip = 1;
    return 1;
}


/*
 * setipcpaccl - accept peer's idea of our address
 */
static int
setipcpaccl(argv)
    char **argv;
{
    ipcp_wantoptions[0].accept_local = 1;
    return 1;
}


/*
 * setipcpaccr - accept peer's idea of its address
 */
static int
setipcpaccr(argv)
    char **argv;
{
    ipcp_wantoptions[0].accept_remote = 1;
    return 1;
}


/*
 * setnetmask - set the netmask to be used on the interface.
 */
static int
setnetmask(argv)
    char **argv;
{
    struct in_addr ina;

    if (inet_aton(*argv, &ina) == 0 || (netmask & ~ina.s_addr) != 0) {
	option_error("invalid netmask value '%s'", *argv);
	return (0);
    }

    netmask = ina.s_addr;
    return (1);
}

static int
setcrtscts(argv)
    char **argv;
{
    crtscts = 1;
    return (1);
}

static int
setnocrtscts(argv)
    char **argv;
{
    crtscts = -1;
    return (1);
}

static int
setxonxoff(argv)
    char **argv;
{
    lcp_wantoptions[0].asyncmap |= 0x000A0000;	/* escape ^S and ^Q */
    lcp_wantoptions[0].neg_asyncmap = 1;

    crtscts = -2;
    return (1);
}

static int
setnodetach(argv)
    char **argv;
{
    nodetach = 1;
    return (1);
}

static int
setupdetach(argv)
    char **argv;
{
    nodetach = -1;
    return (1);
}

static int
setdemand(argv)
    char **argv;
{
    demand = 1;
    persist = 1;
    return 1;
}

static int
setmodem(argv)
    char **argv;
{
    modem = 1;
    return 1;
}

static int
setmodem_chat(argv)
    char **argv;
{
    modem_chat = 1;
    return 1;
}

static int
setlocal(argv)
    char **argv;
{
    modem = 0;
    return 1;
}

static int
setlock(argv)
    char **argv;
{
    lockflag = 1;
    return 1;
}

static int
setusehostname(argv)
    char **argv;
{
    usehostname = 1;
    return 1;
}

static int
setname(argv)
    char **argv;
{
    if (!privileged_option) {
	option_error("using the name option requires root privilege");
	return 0;
    }
    strlcpy(our_name, argv[0], MAXNAMELEN);
    return 1;
}

static int
setuser(argv)
    char **argv;
{
    strlcpy(user, argv[0], MAXNAMELEN);
    return 1;
}

static int
setremote(argv)
    char **argv;
{
    strlcpy(remote_name, argv[0], MAXNAMELEN);
    return 1;
}

static int
setauth(argv)
    char **argv;
{
    auth_required = 1;
    if (privileged_option > auth_req_info.priv) {
	auth_req_info.priv = privileged_option;
	auth_req_info.source = option_source;
    }
    return 1;
}

static int
setnoauth(argv)
    char **argv;
{
    if (auth_required && privileged_option < auth_req_info.priv) {
	if (auth_req_info.source == NULL)
	    option_error("cannot override default auth option");
	else
	    option_error("cannot override auth option set by %s",
	        auth_req_info.source);
	return 0;
    }
    auth_required = 0;
    return 1;
}

static int
setdefaultroute(argv)
    char **argv;
{
    if (!ipcp_allowoptions[0].default_route) {
	option_error("defaultroute option is disabled");
	return 0;
    }
    ipcp_wantoptions[0].default_route = 1;
    return 1;
}

static int
setnodefaultroute(argv)
    char **argv;
{
    ipcp_allowoptions[0].default_route = 0;
    ipcp_wantoptions[0].default_route = 0;
    return 1;
}

static int
setproxyarp(argv)
    char **argv;
{
    if (!ipcp_allowoptions[0].proxy_arp) {
	option_error("proxyarp option is disabled");
	return 0;
    }
    ipcp_wantoptions[0].proxy_arp = 1;
    return 1;
}

static int
setnoproxyarp(argv)
    char **argv;
{
    ipcp_wantoptions[0].proxy_arp = 0;
    ipcp_allowoptions[0].proxy_arp = 0;
    return 1;
}

static int
setpersist(argv)
    char **argv;
{
    persist = 1;
    return 1;
}

static int
setnopersist(argv)
    char **argv;
{
    persist = 0;
    return 1;
}

static int
setdologin(argv)
    char **argv;
{
    uselogin = 1;
    return 1;
}

/*
 * Functions to set the echo interval for modem-less monitors
 */

static int
setlcpechointv(argv)
    char **argv;
{
    return int_option(*argv, &lcp_echo_interval);
}

static int
setlcpechofails(argv)
    char **argv;
{
    return int_option(*argv, &lcp_echo_fails);
}

/*
 * Functions to set timeouts, max transmits, etc.
 */
static int
setlcptimeout(argv)
    char **argv;
{
    return int_option(*argv, &lcp_fsm[0].timeouttime);
}

static int
setlcpterm(argv)
    char **argv;
{
    return int_option(*argv, &lcp_fsm[0].maxtermtransmits);
}

static int
setlcpconf(argv)
    char **argv;
{
    return int_option(*argv, &lcp_fsm[0].maxconfreqtransmits);
}

static int
setlcpfails(argv)
    char **argv;
{
    return int_option(*argv, &lcp_fsm[0].maxnakloops);
}

static int
setipcptimeout(argv)
    char **argv;
{
    return int_option(*argv, &ipcp_fsm[0].timeouttime);
}

static int
setipcpterm(argv)
    char **argv;
{
    return int_option(*argv, &ipcp_fsm[0].maxtermtransmits);
}

static int
setipcpconf(argv)
    char **argv;
{
    return int_option(*argv, &ipcp_fsm[0].maxconfreqtransmits);
}

static int
setipcpfails(argv)
    char **argv;
{
    return int_option(*argv, &lcp_fsm[0].maxnakloops);
}

static int
setpaptimeout(argv)
    char **argv;
{
    return int_option(*argv, &upap[0].us_timeouttime);
}

static int
setpapreqtime(argv)
    char **argv;
{
    return int_option(*argv, &upap[0].us_reqtimeout);
}

static int
setpapreqs(argv)
    char **argv;
{
    return int_option(*argv, &upap[0].us_maxtransmits);
}

static int
setchaptimeout(argv)
    char **argv;
{
    return int_option(*argv, &chap[0].timeouttime);
}

static int
setchapchal(argv)
    char **argv;
{
    return int_option(*argv, &chap[0].max_transmits);
}

static int
setchapintv(argv)
    char **argv;
{
    return int_option(*argv, &chap[0].chal_interval);
}

static int
noccp(argv)
    char **argv;
{
    ccp_protent.enabled_flag = 0;
    return 1;
}

static int
setbsdcomp(argv)
    char **argv;
{
    int rbits, abits;
    char *str, *endp;

    str = *argv;
    abits = rbits = strtol(str, &endp, 0);
    if (endp != str && *endp == ',') {
	str = endp + 1;
	abits = strtol(str, &endp, 0);
    }
    if (*endp != 0 || endp == str) {
	option_error("invalid parameter '%s' for bsdcomp option", *argv);
	return 0;
    }
    if ((rbits != 0 && (rbits < BSD_MIN_BITS || rbits > BSD_MAX_BITS))
	|| (abits != 0 && (abits < BSD_MIN_BITS || abits > BSD_MAX_BITS))) {
	option_error("bsdcomp option values must be 0 or %d .. %d",
		     BSD_MIN_BITS, BSD_MAX_BITS);
	return 0;
    }
    if (rbits > 0) {
	ccp_wantoptions[0].bsd_compress = 1;
	ccp_wantoptions[0].bsd_bits = rbits;
    } else
	ccp_wantoptions[0].bsd_compress = 0;
    if (abits > 0) {
	ccp_allowoptions[0].bsd_compress = 1;
	ccp_allowoptions[0].bsd_bits = abits;
    } else
	ccp_allowoptions[0].bsd_compress = 0;
    return 1;
}

static int
setnobsdcomp(argv)
    char **argv;
{
    ccp_wantoptions[0].bsd_compress = 0;
    ccp_allowoptions[0].bsd_compress = 0;
    return 1;
}

static int
setdeflate(argv)
    char **argv;
{
    int rbits, abits;
    char *str, *endp;

    str = *argv;
    abits = rbits = strtol(str, &endp, 0);
    if (endp != str && *endp == ',') {
	str = endp + 1;
	abits = strtol(str, &endp, 0);
    }
    if (*endp != 0 || endp == str) {
	option_error("invalid parameter '%s' for deflate option", *argv);
	return 0;
    }
    if ((rbits != 0 && (rbits < DEFLATE_MIN_SIZE || rbits > DEFLATE_MAX_SIZE))
	|| (abits != 0 && (abits < DEFLATE_MIN_SIZE
			  || abits > DEFLATE_MAX_SIZE))) {
	option_error("deflate option values must be 0 or %d .. %d",
		     DEFLATE_MIN_SIZE, DEFLATE_MAX_SIZE);
	return 0;
    }
    if (rbits > 0) {
	ccp_wantoptions[0].deflate = 1;
	ccp_wantoptions[0].deflate_size = rbits;
    } else
	ccp_wantoptions[0].deflate = 0;
    if (abits > 0) {
	ccp_allowoptions[0].deflate = 1;
	ccp_allowoptions[0].deflate_size = abits;
    } else
	ccp_allowoptions[0].deflate = 0;
    return 1;
}

static int
setnodeflate(argv)
    char **argv;
{
    ccp_wantoptions[0].deflate = 0;
    ccp_allowoptions[0].deflate = 0;
    return 1;
}

static int
setnodeflatedraft(argv)
    char **argv;
{
    ccp_wantoptions[0].deflate_draft = 0;
    ccp_allowoptions[0].deflate_draft = 0;
    return 1;
}

static int
setpred1comp(argv)
    char **argv;
{
    ccp_wantoptions[0].predictor_1 = 1;
    ccp_allowoptions[0].predictor_1 = 1;
    return 1;
}

static int
setnopred1comp(argv)
    char **argv;
{
    ccp_wantoptions[0].predictor_1 = 0;
    ccp_allowoptions[0].predictor_1 = 0;
    return 1;
}

static int
setipparam(argv)
    char **argv;
{
    ipparam = strdup(*argv);
    if (ipparam == NULL)
	novm("ipparam string");

    return 1;
}

static int
setpapcrypt(argv)
    char **argv;
{
    cryptpap = 1;
    return 1;
}

static int
setidle(argv)
    char **argv;
{
    return int_option(*argv, &idle_time_limit);
}

static int
setholdoff(argv)
    char **argv;
{
    return int_option(*argv, &holdoff);
}

/*
 * setdnsaddr - set the dns address(es)
 */
static int
setdnsaddr(argv)
    char **argv;
{
    struct in_addr ina;
    struct hostent *hp;

    if (inet_aton(*argv, &ina) == 0) {
	if ((hp = gethostbyname(*argv)) == NULL) {
	    option_error("invalid address parameter '%s' for ms-dns option",
			 *argv);
	    return (0);
	}
	ina.s_addr = *(u_int32_t *)hp->h_addr;
    }

    /* if there is no primary then update it. */
    if (ipcp_allowoptions[0].dnsaddr[0] == 0)
	ipcp_allowoptions[0].dnsaddr[0] = ina.s_addr;

    /* always set the secondary address value to the same value. */
    ipcp_allowoptions[0].dnsaddr[1] = ina.s_addr;

    return (1);
}

/*
 * setwinsaddr - set the wins address(es)
 * This is primrarly used with the Samba package under UNIX or for pointing
 * the caller to the existing WINS server on a Windows NT platform.
 */
static int
setwinsaddr(argv)
    char **argv;
{
    struct in_addr ina;
    struct hostent *hp;

    if (inet_aton(*argv, &ina) == 0) {
	if ((hp = gethostbyname(*argv)) == NULL) {
	    option_error("invalid address parameter '%s' for ms-wins option",
			 *argv);
	    return (0);
	}
	ina.s_addr = *(u_int32_t *)hp->h_addr;
    }

    /* if there is no primary then update it. */
    if (ipcp_allowoptions[0].winsaddr[0] == 0)
	ipcp_allowoptions[0].winsaddr[0] = ina.s_addr;

    /* always set the secondary address value to the same value. */
    ipcp_allowoptions[0].winsaddr[1] = ina.s_addr;

    return (1);
}

#ifdef MSLANMAN
static int
setmslanman(argv)
    char **argv;
{
    ms_lanman = 1;
    return (1);
}
#endif
@


1.28
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.27 2014/12/10 03:39:54 jsg Exp $	*/
d520 1
a520 1
		progname);
d690 1
a690 1
	fprintf(stderr, "%s: %s\n", progname, buf);
@


1.27
log
@Fix a potential integer overflow in pppd options file parsing.
From Paul Mackerras in 7658e8257183f062dc01f87969c140707c7e52cb
This issue is CVE-2014-3158.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.26 2013/10/27 18:49:25 guenther Exp $	*/
d100 1
a100 1
char	devnam[MAXPATHLEN] = "/dev/tty";	/* Device name */
d1570 1
a1570 1
    char dev[MAXPATHLEN];
d1591 1
a1591 1
    (void) strlcpy(devnam, cp, MAXPATHLEN);
@


1.26
log
@If a constant string needs a name, use a static const array instead of a
pointer or non-const array, as that minimizes the symbols, maximizes the
placement into read-only memory, and avoids warnings from gcc -Wformat=2
when they're used as format strings.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.25 2011/10/02 06:25:53 nicm Exp $	*/
d892 1
a892 1
	    if (len < MAXWORDLEN-1)
d894 2
a895 1
	    ++len;
d928 1
a928 1
	if (len < MAXWORDLEN-1)
d930 2
a931 1
	++len;
@


1.25
log
@Delete unused variables, from Michael W Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.24 2009/10/27 23:59:53 deraadt Exp $	*/
d402 1
a402 1
static char *usage_string = "\
@


1.24
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.23 2007/10/17 20:10:44 chl Exp $	*/
a114 2
int	defaultroute = 0;	/* assign default route through interface */
int	proxyarp = 0;		/* Set up proxy ARP entry for peer */
@


1.23
log
@remove "unused variable" warnings

tested by deraadt@@ on a gcc2 arch

looks ok ray@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.22 2007/06/04 14:59:45 henning Exp $	*/
a43 8

#ifndef lint
#if 0
static char rcsid[] = "Id: options.c,v 1.42 1998/03/26 04:46:06 paulus Exp $";
#else
static char rcsid[] = "$OpenBSD: options.c,v 1.22 2007/06/04 14:59:45 henning Exp $";
#endif
#endif
@


1.22
log
@bye bye ipx
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.21 2007/03/06 03:06:41 ray Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: options.c,v 1.21 2007/03/06 03:06:41 ray Exp $";
d670 1
a670 1
    char *dev, *path, *p;
@


1.21
log
@Remove code that's been commented out since '96.

From Charles Longeau.

OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.20 2006/01/25 22:41:54 moritz Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: options.c,v 1.20 2006/01/25 22:41:54 moritz Exp $";
a85 4
#ifdef IPX_CHANGE
#include "ipxcp.h"
#endif /* IPX_CHANGE */

a251 1
static int resetipxproto(char **);
a261 15
#ifdef IPX_CHANGE
static int setipxproto(char **);
static int setipxanet(char **);
static int setipxalcl(char **);
static int setipxarmt(char **);
static int setipxnetwork(char **);
static int setipxnode(char **);
static int setipxrouter(char **);
static int setipxname(char **);
static int setipxcptimeout(char **);
static int setipxcpterm(char **);
static int setipxcpconf(char **);
static int setipxcpfails(char **);
#endif /* IPX_CHANGE */

a389 2
    {"noipx",  0, resetipxproto},	/* Disable IPXCP (and IPX) */
    {"-ipx",   0, resetipxproto},	/* Disable IPXCP (and IPX) */
a399 19
#ifdef IPX_CHANGE
    {"ipx-network",          1, setipxnetwork}, /* IPX network number */
    {"ipxcp-accept-network", 0, setipxanet},    /* Accept peer netowrk */
    {"ipx-node",             1, setipxnode},    /* IPX node number */
    {"ipxcp-accept-local",   0, setipxalcl},    /* Accept our address */
    {"ipxcp-accept-remote",  0, setipxarmt},    /* Accept peer's address */
    {"ipx-routing",          1, setipxrouter},  /* IPX routing proto number */
    {"ipx-router-name",      1, setipxname},    /* IPX router name */
    {"ipxcp-restart",        1, setipxcptimeout}, /* Set timeout for IPXCP */
    {"ipxcp-max-terminate",  1, setipxcpterm},  /* max #xmits for term-reqs */
    {"ipxcp-max-configure",  1, setipxcpconf},  /* max #xmits for conf-reqs */
    {"ipxcp-max-failure",    1, setipxcpfails}, /* max #conf-naks for IPXCP */
#if 0
    {"ipx-compression", 1, setipxcompression}, /* IPX compression number */
#endif
    {"ipx",		     0, setipxproto},	/* Enable IPXCP (and IPX) */
    {"+ipx",		     0, setipxproto},	/* Enable IPXCP (and IPX) */
#endif /* IPX_CHANGE */

a1153 5
#ifdef IPX_CHANGE
    BZERO((char *) &ipxcp_wantoptions[0], sizeof (struct ipxcp_options));
    BZERO((char *) &ipxcp_allowoptions[0], sizeof (struct ipxcp_options));
#endif /* IPX_CHANGE */

a2283 185

#ifdef IPX_CHANGE
static int
setipxrouter (argv)
    char **argv;
{
    ipxcp_wantoptions[0].neg_router  = 1;
    ipxcp_allowoptions[0].neg_router = 1;
    return int_option(*argv, &ipxcp_wantoptions[0].router); 
}

static int
setipxname (argv)
    char **argv;
{
    char *dest = ipxcp_wantoptions[0].name;
    char *src  = *argv;
    int  count;
    char ch;

    ipxcp_wantoptions[0].neg_name  = 1;
    ipxcp_allowoptions[0].neg_name = 1;
    memset (dest, '\0', sizeof (ipxcp_wantoptions[0].name));

    count = 0;
    while (*src) {
        ch = *src++;
	if (! isalnum (ch) && ch != '_') {
	    option_error("IPX router name must be alphanumeric or _");
	    return 0;
	}

	if (count >= sizeof (ipxcp_wantoptions[0].name)) {
	    option_error("IPX router name is limited to %d characters",
			 sizeof (ipxcp_wantoptions[0].name) - 1);
	    return 0;
	}

	dest[count++] = toupper (ch);
    }

    return 1;
}

static int
setipxcptimeout (argv)
    char **argv;
{
    return int_option(*argv, &ipxcp_fsm[0].timeouttime);
}

static int
setipxcpterm (argv)
    char **argv;
{
    return int_option(*argv, &ipxcp_fsm[0].maxtermtransmits);
}

static int
setipxcpconf (argv)
    char **argv;
{
    return int_option(*argv, &ipxcp_fsm[0].maxconfreqtransmits);
}

static int
setipxcpfails (argv)
    char **argv;
{
    return int_option(*argv, &ipxcp_fsm[0].maxnakloops);
}

static int
setipxnetwork(argv)
    char **argv;
{
    u_int32_t v;

    if (!number_option(*argv, &v, 16))
	return 0;

    ipxcp_wantoptions[0].our_network = (int) v;
    ipxcp_wantoptions[0].neg_nn      = 1;
    return 1;
}

static int
setipxanet(argv)
    char **argv;
{
    ipxcp_wantoptions[0].accept_network = 1;
    ipxcp_allowoptions[0].accept_network = 1;
    return 1;
}

static int
setipxalcl(argv)
    char **argv;
{
    ipxcp_wantoptions[0].accept_local = 1;
    ipxcp_allowoptions[0].accept_local = 1;
    return 1;
}

static int
setipxarmt(argv)
    char **argv;
{
    ipxcp_wantoptions[0].accept_remote = 1;
    ipxcp_allowoptions[0].accept_remote = 1;
    return 1;
}

static u_char *
setipxnodevalue(src,dst)
u_char *src, *dst;
{
    int indx;
    int item;

    for (;;) {
        if (!isxdigit (*src))
	    break;
	
	for (indx = 0; indx < 5; ++indx) {
	    dst[indx] <<= 4;
	    dst[indx] |= (dst[indx + 1] >> 4) & 0x0F;
	}

	item = toupper (*src) - '0';
	if (item > 9)
	    item -= 7;

	dst[5] = (dst[5] << 4) | item;
	++src;
    }
    return src;
}

static int
setipxnode(argv)
    char **argv;
{
    char *end;

    memset (&ipxcp_wantoptions[0].our_node[0], 0, 6);
    memset (&ipxcp_wantoptions[0].his_node[0], 0, 6);

    end = setipxnodevalue (*argv, &ipxcp_wantoptions[0].our_node[0]);
    if (*end == ':')
	end = setipxnodevalue (++end, &ipxcp_wantoptions[0].his_node[0]);

    if (*end == '\0') {
        ipxcp_wantoptions[0].neg_node = 1;
        return 1;
    }

    option_error("invalid parameter '%s' for ipx-node option", *argv);
    return 0;
}

static int
setipxproto(argv)
    char **argv;
{
    ipxcp_protent.enabled_flag = 1;
    return 1;
}

static int
resetipxproto(argv)
    char **argv;
{
    ipxcp_protent.enabled_flag = 0;
    return 1;
}
#else

static int
resetipxproto(argv)
    char **argv;
{
    return 1;
}
#endif /* IPX_CHANGE */
@


1.20
log
@Fix an off-by-one in pppd(8)'s option handling. ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.19 2003/04/04 20:25:07 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: options.c,v 1.19 2003/04/04 20:25:07 deraadt Exp $";
a177 3
#ifdef OLD_OPTIONS
static int setupapfile(char **);
#endif
a316 3
#if OLD_OPTIONS
    {"+ua", 1, setupapfile},	/* Get PAP user and password from file */
#endif
a1381 44

#if OLD_OPTIONS
/*
 * setupapfile - specifies UPAP info for authenticating with peer.
 */
static int
setupapfile(argv)
    char **argv;
{
    FILE * ufile;
    int l;

    lcp_allowoptions[0].neg_upap = 1;

    /* open user info file */
    if ((ufile = fopen(*argv, "r")) == NULL) {
	option_error("unable to open user login data file %s", *argv);
	return 0;
    }
    if (!readable(fileno(ufile))) {
	option_error("%s: access denied", *argv);
	return 0;
    }
    check_access(ufile, *argv);

    /* get username */
    if (fgets(user, MAXNAMELEN - 1, ufile) == NULL
	|| fgets(passwd, MAXSECRETLEN - 1, ufile) == NULL){
	option_error("unable to read user login data file %s", *argv);
	return 0;
    }
    fclose(ufile);

    /* get rid of newlines */
    l = strlen(user);
    if (l > 0 && user[l-1] == '\n')
	user[l-1] = 0;
    l = strlen(passwd);
    if (l > 0 && passwd[l-1] == '\n')
	passwd[l-1] = 0;

    return (1);
}
#endif
@


1.19
log
@strlcpy and snprintf; various people ok
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.18 2002/12/23 21:07:43 mickey Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: options.c,v 1.18 2002/12/23 21:07:43 mickey Exp $";
d1590 2
a1591 2
	    strncat(hostname, ".", MAXNAMELEN - strlen(hostname));
	strncat(hostname, *argv, MAXNAMELEN - strlen(hostname));
@


1.18
log
@avoid null deref in calling option_erro(); pt out by hunter@@comsys.com.ua
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.17 2002/07/01 19:31:37 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: options.c,v 1.17 2002/07/01 19:31:37 deraadt Exp $";
d703 1
a703 2
    path = malloc(strlen(user) + strlen(file) + 2);
    if (path == NULL)
a704 3
    strcpy(path, user);
    strcat(path, "/");
    strcat(path, file);
d725 1
a725 2
    path = malloc(strlen(_PATH_TTYOPT) + strlen(dev) + 1);
    if (path == NULL)
a726 5
    strcpy(path, _PATH_TTYOPT);
    /* Turn slashes into dots, for Solaris case (e.g. /dev/term/a) */
    for (p = path + strlen(path); *dev != 0; ++dev)
	*p++ = (*dev == '/'? '.': *dev);
    *p = 0;
d1114 2
a1115 2
    strcpy(fname, _PATH_PEERFILES);
    strcat(fname, arg);
d1680 2
a1681 3
	strcpy(dev, "/dev/");
	strncat(dev, cp, MAXPATHLEN - 5);
	dev[MAXPATHLEN-1] = 0;
@


1.17
log
@license update of CMU parts.  due to communication with wcw+@@andrew.cmu.edu,
pushed for by tygs@@netcologne.de.  Apparently we also now known how to talk
to the lawyers there, if we were so mad.  Note that a few other copyright
issues in pppd still remain, so this does not close this story.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.16 2002/02/19 19:39:40 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: options.c,v 1.16 2002/02/19 19:39:40 millert Exp $";
d1977 5
a1981 2
	option_error("cannot override auth option set by %s",
		     auth_req_info.source);
@


1.16
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.15 2002/02/16 21:28:07 millert Exp $	*/
d6 1
a6 2
 * Copyright (c) 1989 Carnegie Mellon University.
 * All rights reserved.
d8 35
a42 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Carnegie Mellon University.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d49 1
a49 1
static char rcsid[] = "$OpenBSD: options.c,v 1.15 2002/02/16 21:28:07 millert Exp $";
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.14 2001/07/09 22:21:54 pjanzen Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: options.c,v 1.14 2001/07/09 22:21:54 pjanzen Exp $";
d725 1
a725 1
option_error __V((char *fmt, ...))
a729 1
#ifdef __STDC__
a730 5
#else
    char *fmt;
    va_start(args);
    fmt = va_arg(args, char *);
#endif
@


1.14
log
@remove extraneous braces
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.13 2001/06/23 15:34:02 lebel Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: options.c,v 1.13 2001/06/23 15:34:02 lebel Exp $";
d73 1
a73 1
char *strdup __P((char *));
d142 13
a154 13
static int setdevname __P((char *, int));
static int setipaddr __P((char *));
static int setspeed __P((char *));
static int setdebug __P((char **));
static int setkdebug __P((char **));
static int setpassive __P((char **));
static int setsilent __P((char **));
static int noopt __P((char **));
static int setnovj __P((char **));
static int setnovjccomp __P((char **));
static int setvjslots __P((char **));
static int reqpap __P((char **));
static int nopap __P((char **));
d156 1
a156 1
static int setupapfile __P((char **));
d158 10
a167 10
static int nochap __P((char **));
static int reqchap __P((char **));
static int noaccomp __P((char **));
static int noasyncmap __P((char **));
static int noip __P((char **));
static int nomagicnumber __P((char **));
static int setasyncmap __P((char **));
static int setescape __P((char **));
static int setmru __P((char **));
static int setmtu __P((char **));
d169 1
a169 1
static int setcbcp __P((char **));
d171 69
a239 69
static int nomru __P((char **));
static int nopcomp __P((char **));
static int setconnector __P((char **));
static int setdisconnector __P((char **));
static int setwelcomer __P((char **));
static int setmaxconnect __P((char **));
static int setdomain __P((char **));
static int setnetmask __P((char **));
static int setcrtscts __P((char **));
static int setnocrtscts __P((char **));
static int setxonxoff __P((char **));
static int setnodetach __P((char **));
static int setupdetach __P((char **));
static int setmodem __P((char **));
static int setmodem_chat __P((char **));
static int setlocal __P((char **));
static int setlock __P((char **));
static int setname __P((char **));
static int setuser __P((char **));
static int setremote __P((char **));
static int setauth __P((char **));
static int setnoauth __P((char **));
static int readfile __P((char **));
static int callfile __P((char **));
static int setdefaultroute __P((char **));
static int setnodefaultroute __P((char **));
static int setproxyarp __P((char **));
static int setnoproxyarp __P((char **));
static int setpersist __P((char **));
static int setnopersist __P((char **));
static int setdologin __P((char **));
static int setusehostname __P((char **));
static int setnoipdflt __P((char **));
static int setlcptimeout __P((char **));
static int setlcpterm __P((char **));
static int setlcpconf __P((char **));
static int setlcpfails __P((char **));
static int setipcptimeout __P((char **));
static int setipcpterm __P((char **));
static int setipcpconf __P((char **));
static int setipcpfails __P((char **));
static int setpaptimeout __P((char **));
static int setpapreqs __P((char **));
static int setpapreqtime __P((char **));
static int setchaptimeout __P((char **));
static int setchapchal __P((char **));
static int setchapintv __P((char **));
static int setipcpaccl __P((char **));
static int setipcpaccr __P((char **));
static int setlcpechointv __P((char **));
static int setlcpechofails __P((char **));
static int noccp __P((char **));
static int setbsdcomp __P((char **));
static int setnobsdcomp __P((char **));
static int setdeflate __P((char **));
static int setnodeflate __P((char **));
static int setnodeflatedraft __P((char **));
static int setdemand __P((char **));
static int setpred1comp __P((char **));
static int setnopred1comp __P((char **));
static int setipparam __P((char **));
static int setpapcrypt __P((char **));
static int setidle __P((char **));
static int setholdoff __P((char **));
static int setdnsaddr __P((char **));
static int resetipxproto __P((char **));
static int setwinsaddr __P((char **));
static int showversion __P((char **));
static int showhelp __P((char **));
d242 3
a244 3
static int setpdebug __P((char **));
static int setpassfilter __P((char **));
static int setactivefilter __P((char **));
d248 12
a259 12
static int setipxproto __P((char **));
static int setipxanet __P((char **));
static int setipxalcl __P((char **));
static int setipxarmt __P((char **));
static int setipxnetwork __P((char **));
static int setipxnode __P((char **));
static int setipxrouter __P((char **));
static int setipxname __P((char **));
static int setipxcptimeout __P((char **));
static int setipxcpterm __P((char **));
static int setipxcpconf __P((char **));
static int setipxcpfails __P((char **));
d263 1
a263 1
static int setmslanman __P((char **));
d266 3
a268 3
static int number_option __P((char *, u_int32_t *, int));
static int int_option __P((char *, int *));
static int readable __P((int fd));
d276 1
a276 1
    int (*cmd_func) __P((char **));
@


1.13
log
@use strlcpy vs strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.12 1998/05/08 04:52:29 millert Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: options.c,v 1.12 1998/05/08 04:52:29 millert Exp $";
d1728 1
a1728 1
		if (our_name[0] == 0) {
a1729 1
		}
d1752 1
a1752 1
		if (remote_name[0] == 0) {
a1753 1
		}
@


1.12
log
@pppd 2.3.5
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.11 1998/01/17 20:30:26 millert Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: options.c,v 1.11 1998/01/17 20:30:26 millert Exp $";
d1689 1
a1689 2
    (void) strncpy(devnam, cp, MAXPATHLEN - 1);
    devnam[MAXPATHLEN - 1] = '\0';
d1729 1
a1729 2
		    strncpy(our_name, arg, MAXNAMELEN - 1);
		    our_name[MAXNAMELEN - 1] = '\0';
d1754 1
a1754 2
		    strncpy(remote_name, colon, MAXNAMELEN - 1);
		    remote_name[MAXNAMELEN - 1] = '\0';
d1925 1
a1925 2
    strncpy(our_name, argv[0], MAXNAMELEN - 1);
    our_name[MAXNAMELEN - 1] = '\0';
d1933 1
a1933 2
    strncpy(user, argv[0], MAXNAMELEN - 1);
    user[MAXNAMELEN - 1] = '\0';
d1941 1
a1941 2
    strncpy(remote_name, argv[0], MAXNAMELEN - 1);
    remote_name[MAXNAMELEN - 1] = '\0';
@


1.11
log
@ppp-2.3.3 + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.10 1997/10/25 05:09:57 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "Id: options.c,v 1.40 1997/11/27 06:09:34 paulus Exp $";
d26 1
a26 1
static char rcsid[] = "$OpenBSD: options.c,v 1.10 1997/10/25 05:09:57 millert Exp $";
d183 1
d227 1
d287 1
d383 1
d1864 8
d2261 9
d2339 2
a2340 1
    if (ipcp_allowoptions[0].dnsaddr[0] == 0) {
d2342 3
a2344 3
    } else {
	ipcp_allowoptions[0].dnsaddr[1] = ina.s_addr;
    }
d2370 2
a2371 1
    if (ipcp_allowoptions[0].winsaddr[0] == 0) {
d2373 3
a2375 3
    } else {
	ipcp_allowoptions[0].winsaddr[1] = ina.s_addr;
    }
@


1.10
log
@Set CLOCAL for chat script by default.  Add new option "modem_chat"
to override the default for people using cua devices who want chat
to detect loss of carrier.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.9 1997/09/05 04:32:43 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "Id: options.c,v 1.39 1997/07/14 03:53:34 paulus Exp";
d26 1
a26 1
static char rcsid[] = "$OpenBSD: options.c,v 1.9 1997/09/05 04:32:43 millert Exp $";
d169 1
a169 1
static int setcbcp __P((char *));
d261 1
a261 1
static int setmslanman __P((void));
d2448 1
d2457 1
d2466 1
d2544 2
a2545 1
setmslanman()
@


1.9
log
@ppp 2.3.1
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.8 1997/07/25 20:12:15 mickey Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: options.c,v 1.8 1997/07/25 20:12:15 mickey Exp $";
d92 1
d184 1
d332 1
d446 1
d1873 8
@


1.8
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.7 1997/01/02 10:50:20 mickey Exp $	*/
d23 5
a27 1
static char rcsid[] = "$OpenBSD: options.c,v 1.7 1997/01/02 10:50:20 mickey Exp $";
d45 4
d83 3
d111 1
d119 7
a125 2
int   refuse_pap = 0;         /* Set to say we won't do PAP */
int   refuse_chap = 0;        /* Set to say we won't do CHAP */
d132 5
d143 2
a144 1
static int setdebug __P((void));
d146 5
a150 5
static int setpassive __P((void));
static int setsilent __P((void));
static int noopt __P((void));
static int setnovj __P((void));
static int setnovjccomp __P((void));
d152 2
a153 2
static int reqpap __P((void));
static int nopap __P((void));
d157 6
a162 7
static int nochap __P((void));
static int reqchap __P((void));
static int setspeed __P((char *));
static int noaccomp __P((void));
static int noasyncmap __P((void));
static int noip __P((void));
static int nomagicnumber __P((void));
d168 1
a168 1
static int setcbcp __P((char **));
d170 2
a171 2
static int nomru __P((void));
static int nopcomp __P((void));
d178 7
a184 7
static int setcrtscts __P((void));
static int setnocrtscts __P((void));
static int setxonxoff __P((void));
static int setnodetach __P((void));
static int setmodem __P((void));
static int setlocal __P((void));
static int setlock __P((void));
d188 2
a189 2
static int setauth __P((void));
static int setnoauth __P((void));
d192 9
a200 9
static int setdefaultroute __P((void));
static int setnodefaultroute __P((void));
static int setproxyarp __P((void));
static int setnoproxyarp __P((void));
static int setpersist __P((void));
static int setnopersist __P((void));
static int setdologin __P((void));
static int setusehostname __P((void));
static int setnoipdflt __P((void));
d215 2
a216 2
static int setipcpaccl __P((void));
static int setipcpaccr __P((void));
d219 1
a219 1
static int noccp __P((void));
d221 1
a221 1
static int setnobsdcomp __P((void));
d223 4
a226 4
static int setnodeflate __P((void));
static int setdemand __P((void));
static int setpred1comp __P((void));
static int setnopred1comp __P((void));
d228 1
a228 1
static int setpapcrypt __P((void));
d232 10
a241 1
static int resetipxproto __P((void));
d244 4
a247 4
static int setipxproto __P((void));
static int setipxanet __P((void));
static int setipxalcl __P((void));
static int setipxarmt __P((void));
d258 4
d272 1
a272 1
    int (*cmd_func)();
d274 2
a275 2
    {"-all", 0, noopt},               /* Don't request/allow any options (useless) */
    {"noaccomp", 0, noaccomp},        /* Disable Address/Control compression */
d283 1
a283 1
    {"noip", 0, noip},                /* Disable IP and IPCP */
d287 1
a287 1
    {"default-mru", 0, nomru},        /* Disable MRU negotiation */
d290 1
a290 1
    {"nopcomp", 0, nopcomp},  /* Disable protocol field compression */   
d297 1
a297 1
    {"refuse-pap", 0, nopap}, /* Don't agree to auth to peer with PAP */
d301 1
a301 1
    {"refuse-chap", 0, nochap},       /* Don't agree to auth to peer with CHAP */
d303 1
a303 1
    {"novj", 0, setnovj},     /* Disable VJ compression */
d369 1
a369 1
    {"noccp", 0, noccp},              /* Disable CCP negotiation */
d372 1
a372 1
    {"nobsdcomp", 0, setnobsdcomp},   /* don't allow BSD-Compress */
d375 1
a375 1
    {"nodeflate", 0, setnodeflate},   /* don't allow Deflate compression */
d385 1
d388 9
d413 1
a413 1
    {"ipx",                0, setipxproto},   /* Enable IPXCP (and IPX) */
d417 4
d448 1
a448 1
static char *current_option;  /* the name of the option being parsed */
d479 1
a479 1
                option_error("too few parameters for option %s", arg);
d482 1
a482 1
            current_option = arg; 
d492 1
a492 1
            if ((ret = setdevname(arg, 0)) == 0
d495 1
a495 1
                option_error("unrecognized option '%s'", arg);
d519 16
a534 16
        arg = *argv++;
        --argc;
                
        /* Skip options and their arguments */
        for (cmdp = cmds; cmdp->cmd_name; cmdp++)
            if (!strcmp(arg, cmdp->cmd_name))
                break;
                
        if (cmdp->cmd_name != NULL) {
            argc -= cmdp->num_args;
            argv += cmdp->num_args;
            continue;
        }
  
        /* Check if it's a tty name and copy it if so */
        (void) setdevname(arg, 1);
d536 1
a536 2
}   

d545 31
a575 2
    fprintf(stderr, usage_string, VERSION, PATCHLEVEL, IMPLEMENTATION,
	    progname);
d600 1
a600 1
        option_error("Can't open options file %s: %m", filename);
d604 1
a604 1
        option_error("Can't open options file %s: access denied", filename);
d623 3
a625 3
                    option_error(
                        "In file %s: too few parameters for option '%s'",
			    filename, cmd);
d630 1
a630 1
            current_option = cmd;
d641 2
a642 2
                option_error("In file %s: unrecognized option '%s'",
			filename, cmd);
d712 1
a712 1
 * option_error - print a message about an error in an option.   
a719 1
    int n;
d721 1
a721 1
          
d732 1
a732 1
        fprintf(stderr, "%s: %s\n", progname, buf);
a735 1

d983 1
a983 1
            option_error("Error reading %s: %m", filename);
d998 2
a999 2
        option_error("warning: word in file %s too long (%.20s...)",
                     filename, word);
d1023 2
a1024 2
        option_error("invalid numeric parameter '%s' for %s option",
                     str, current_option);
d1113 2
a1114 1
setdebug()
d1130 44
d1178 2
a1179 1
noopt()
d1198 2
a1199 1
noaccomp()
d1211 2
a1212 1
noasyncmap()
d1224 2
a1225 1
noip()
d1236 2
a1237 1
nomagicnumber()
d1249 2
a1250 1
nomru()
d1287 2
a1288 2
        option_error("mtu option value of %u is too %s", mtu,
		(mtu < MINMRU? "small": "large"));
d1315 2
a1316 1
nopcomp()
d1329 2
a1330 1
setpassive()
d1342 2
a1343 1
setsilent()
d1354 2
a1355 1
nopap()
d1366 2
a1367 1
reqpap()
d1370 1
a1370 1
    setauth();
a1373 1

a1417 1

d1422 2
a1423 1
nochap()
d1434 2
a1435 1
reqchap()
d1438 1
a1438 1
    setauth();
d1447 2
a1448 1
setnovj()
d1460 2
a1461 1
setnovjccomp()
d1481 1
a1481 1
        option_error("vj-max-slots value must be between 2 and 16");
d1502 1
a1502 1
  
d1534 1
a1534 1
  
d1548 1
a1548 1
      return 0;
d1550 2
a1551 2
      option_error("maxconnect time must be positive");
      return 0;
d1615 2
a1616 2
            option_error("escape parameter contains invalid hex number '%s'",
                         p);
d1620 2
a1621 2
	if (n < 0 || 0x20 <= n && n <= 0x3F || n == 0x5E || n > 0xFF) {
            option_error("can't escape character 0x%x", n);
d1656 1
a1656 1
    int quiet; 
d1662 1
a1662 1
      return 0; 
d1675 1
a1675 1
        if (errno == ENOENT || quiet)
d1677 1
a1677 1
        option_error("Couldn't stat %s: %m", cp);
d1680 3
a1682 3
  
    (void) strncpy(devnam, cp, MAXPATHLEN);
    devnam[MAXPATHLEN-1] = 0;
d1717 1
a1717 1
                option_error("unknown host: %s", arg);
d1722 2
a1723 2
		    strncpy(our_name, arg, MAXNAMELEN);
		    our_name[MAXNAMELEN-1] = 0;
d1729 1
a1729 1
            option_error("bad local IP address %s", ip_ntoa(local));
d1743 1
a1743 1
                option_error("unknown host: %s", colon);
d1748 2
a1749 2
		    strncpy(remote_name, colon, MAXNAMELEN);
		    remote_name[MAXNAMELEN-1] = 0;
d1755 1
a1755 1
            option_error("bad remote IP address %s", ip_ntoa(remote));
d1770 2
a1771 1
setnoipdflt()
d1782 2
a1783 1
setipcpaccl()
d1794 2
a1795 1
setipcpaccr()
d1812 2
a1813 2
        option_error("invalid netmask value '%s'", *argv);
	return 0;
d1821 2
a1822 1
setcrtscts()
d1829 2
a1830 1
setnocrtscts()
d1837 2
a1838 1
setxonxoff()
d1848 2
a1849 1
setnodetach()
d1856 2
a1857 1
setdemand()
d1865 2
a1866 1
setmodem()
d1873 2
a1874 1
setlocal()
d1881 2
a1882 1
setlock()
d1889 2
a1890 1
setusehostname()
d1904 2
a1905 2
	strncpy(our_name, argv[0], MAXNAMELEN);
	our_name[MAXNAMELEN-1] = 0;
d1913 2
a1914 2
    strncpy(user, argv[0], MAXNAMELEN);
    user[MAXNAMELEN-1] = 0;
d1922 2
a1923 2
    strncpy(remote_name, argv[0], MAXNAMELEN);
    remote_name[MAXNAMELEN-1] = 0;
d1928 2
a1929 1
setauth()
d1940 2
a1941 1
setnoauth()
d1953 2
a1954 1
setdefaultroute()
d1957 1
a1957 1
        option_error("defaultroute option is disabled");
d1965 2
a1966 1
setnodefaultroute()
d1974 2
a1975 1
setproxyarp()
d1978 1
a1978 1
        option_error("proxyarp option is disabled");
d1986 2
a1987 1
setnoproxyarp()
d1995 2
a1996 1
setpersist()
d2003 2
a2004 1
setnopersist()
d2011 2
a2012 1
setdologin()
d2138 2
a2139 1
noccp()
d2159 1
a2159 1
        option_error("invalid parameter '%s' for bsdcomp option", *argv);
d2162 4
a2165 4
    if (rbits != 0 && (rbits < BSD_MIN_BITS || rbits > BSD_MAX_BITS)
	|| abits != 0 && (abits < BSD_MIN_BITS || abits > BSD_MAX_BITS)) {
        option_error("bsdcomp option values must be 0 or %d .. %d",
                     BSD_MIN_BITS, BSD_MAX_BITS);
d2182 2
a2183 1
setnobsdcomp()
d2204 1
a2204 1
        option_error("invalid parameter '%s' for deflate option", *argv);
d2207 5
a2211 5
    if (rbits != 0 && (rbits < DEFLATE_MIN_SIZE || rbits > DEFLATE_MAX_SIZE)
	|| abits != 0 && (abits < DEFLATE_MIN_SIZE
			  || abits > DEFLATE_MAX_SIZE)) {
        option_error("deflate option values must be 0 or %d .. %d",
                     DEFLATE_MIN_SIZE, DEFLATE_MAX_SIZE);
d2228 2
a2229 1
setnodeflate()
d2237 2
a2238 1
setpred1comp()
d2246 2
a2247 1
setnopred1comp()
d2266 2
a2267 1
setpapcrypt()
d2301 1
a2301 1
	    return 0;
d2315 30
d2372 1
a2372 1
            option_error("IPX router name must be alphanumeric or _");
d2377 2
a2378 2
            option_error("IPX router name is limited to %d characters",
		     sizeof (ipxcp_wantoptions[0].name) - 1);
d2420 8
a2427 2
    ipxcp_wantoptions[0].neg_nn = 1;
    return int_option(*argv, &ipxcp_wantoptions[0].our_network); 
d2431 2
a2432 1
setipxanet()
d2439 2
a2440 1
setipxalcl()
d2447 2
a2448 1
setipxarmt()
d2503 2
a2504 1
setipxproto()
d2511 2
a2512 1
resetipxproto()
d2520 2
a2521 1
resetipxproto()
d2526 9
@


1.7
log
@inet_addr --> inet_aton
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.6 1996/12/23 13:22:45 mickey Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: options.c,v 1.6 1996/12/23 13:22:45 mickey Exp $";
d646 1
a646 1
#if __STDC__
@


1.6
log
@pppd 2.3b3 import. some minor buf oflow fixes and so.
try it out ppl, but i've got it running talking to cisco w/ all the AFs
enabled in kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.5 1996/12/15 23:20:34 millert Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: options.c,v 1.5 1996/12/15 23:20:34 millert Exp $";
d1567 1
d1582 1
a1582 1
	if ((local = inet_addr(arg)) == -1) {
d1588 3
d1593 2
d1608 1
a1608 1
	if ((remote = inet_addr(colon)) == -1) {
d1619 2
a1620 1
	}
d1673 1
a1673 1
    u_int32_t mask;
d1675 1
a1675 1
    if ((mask = inet_addr(*argv)) == -1 || (netmask & ~mask) != 0) {
d1680 1
a1680 1
    netmask = mask;
d2134 1
a2134 1
    u_int32_t dns;
d2137 1
a2137 2
    dns = inet_addr(*argv);
    if (dns == -1) {
d2141 1
a2141 1
    return 0;
d2143 1
a2143 1
	dns = *(u_int32_t *)hp->h_addr;
d2147 1
a2147 1
	ipcp_allowoptions[0].dnsaddr[0] = dns;
d2149 1
a2149 1
	ipcp_allowoptions[0].dnsaddr[1] = dns;
@


1.5
log
@Use inet_aton() instead of inet_addr()
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.4 1996/07/20 12:02:13 joshd Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: options.c,v 1.4 1996/07/20 12:02:13 joshd Exp $";
d51 3
a53 1
#include "bpf_compile.h"
a106 2
struct	bpf_program pass_filter;/* Filter program for packets to pass */
struct	bpf_program active_filter; /* Filter program for link-active pkts */
d110 5
d145 3
d167 1
d169 1
d175 1
d209 2
a210 2
static int setpassfilter __P((char **));
static int setactivefilter __P((char **));
a213 1
static int resetipxproto __P((void));
a226 4
#ifdef USE_MS_DNS
static int setdnsaddr __P((char **));
#endif

a229 3
static void option_error __P((char *fmt, ...));

void usage();
a255 1
#ifdef  OLD_OPTIONS
d257 1
a257 3
#endif
    {"require-pap", 0, reqpap},       /* Require PAP authentication from peer */
#ifdef OLD_OPTIONS
d260 1
d288 3
d298 1
a298 1
    {"user", 1, setuser},	/* Set username for PAP auth with peer */
d302 1
d304 1
d312 1
d349 3
a351 2
    {"pass-filter", 1, setpassfilter},	/* set filter for packets to pass */
    {"active-filter", 1, setactivefilter}, /* set filter for active pkts */
a368 1
    {"noipx",              0, resetipxproto}, /* Disable IPXCP (and IPX) */
a369 1
    {"-ipx",		     0, resetipxproto},	/* Disable IPXCP (and IPX) */
a371 8
#ifdef _linux_
    {"idle-disconnect", 1, setidle}, /* seconds for disconnect of idle IP */
#endif

#ifdef USE_MS_DNS
    {"ms-dns", 1, setdnsaddr},	/* DNS address(es) for the peer's use */
#endif

d400 2
a401 1

d404 1
a404 2
 * parse_args - parse a string of arguments, from the command
 * line or from a file.
d415 2
d506 1
a506 1
options_from_file(filename, must_exist, check_prot)
d510 1
d515 1
d532 3
d549 1
a549 2
		    fclose(f);
		    return 0;
d554 2
a555 4
	    if (!(*cmdp->cmd_func)(argv)) {
		fclose(f);
		return 0;
	    }
d561 3
a563 3
            if ((ret = setdevname(cmd, 0)) == 0
		&& (ret = setspeed(cmd)) == 0
		&& (ret = setipaddr(cmd)) == 0) {
d566 1
a566 2
		fclose(f);
		return 0;
d568 2
a569 2
	    if (ret < 0)	/* error */
		return 0;
d572 6
a577 1
    return 1;
d601 1
a601 1
    ret = options_from_file(path, 0, 1);
d629 1
a629 1
    ret = options_from_file(path, 0, 0);
d976 1
a976 1
 * The following procedures execute commands.
d986 1
a986 1
    return options_from_file(*argv, 1, 1);
d990 45
d1169 15
d1239 1
a1239 1
    auth_required = 1;
d1259 1
a1259 1
	fprintf(stderr, "unable to open user login data file %s\n", *argv);
d1263 1
a1263 1
        option_error("unable to open user login data file %s", *argv);
d1271 1
a1271 1
        option_error("%s: access denied", *argv);
d1307 1
a1307 1
    auth_required = 1;
d1367 2
d1383 2
d1399 2
d1420 4
d1435 4
d1551 2
a1566 1
    struct in_addr ina;
d1581 1
a1581 1
	if (inet_aton(arg, &ina) == 0) {
a1586 3
		if (our_name[0] == 0) {
		    strncpy(our_name, arg, MAXNAMELEN);
		    our_name[MAXNAMELEN-1] = 0;
a1588 2
	} else
	    local = ina.s_addr;
d1602 1
a1602 1
	if (inet_aton(colon, &ina) == 0) {
d1613 1
a1613 2
	} else
	    remote = ina.s_addr;
d1666 1
a1666 1
    struct in_addr ina;
d1668 1
a1668 1
    if (inet_aton(*argv, &ina) == 0 || (netmask & ~ina.s_addr) != 0) {
d1673 1
a1673 1
    netmask = ina.s_addr;
d1712 1
d1748 4
a1751 1
    if (our_name[0] == 0) {
a1753 1
    }
d1779 16
d1844 7
d2120 3
d2124 1
a2124 1
setpassfilter(argv)
d2127 8
a2134 4
    if (bpf_compile(&pass_filter, *argv, 1) == 0)
	return 1;
    fprintf(stderr, "%s: error in pass-filter expression: %s\n",
	    progname, bpf_geterr());
d2136 9
a2144 1
}
d2146 1
a2146 9
static int
setactivefilter(argv)
    char **argv;
{
    if (bpf_compile(&active_filter, *argv, 1) == 0)
	return 1;
    fprintf(stderr, "%s: error in active-filter expression: %s\n",
	    progname, bpf_geterr());
    return 0;
d2310 1
a2310 6
#endif /* IPX_CHANGE */

#ifdef USE_MS_DNS
/*
 * setdnsaddr - set the dns address(es)
 */
d2313 1
a2313 2
setdnsaddr(argv)
    char **argv;
d2315 1
a2315 19
    u_int32_t dns;
    struct hostent *hp;

    if (inet_aton(*argv, &dns) == 0) {
	if ((hp = gethostbyname(*argv)) == NULL) {
            option_error("invalid address parameter '%s' for ms-dns option",
                         *argv);
	    return 0;
	}
	dns = *(u_int32_t *)hp->h_addr;
    }

    if (ipcp_allowoptions[0].dnsaddr[0] == 0) {
	ipcp_allowoptions[0].dnsaddr[0] = dns;
    } else {
	ipcp_allowoptions[0].dnsaddr[1] = dns;
    }

    return (1);
d2317 1
a2317 1
#endif /* USE_MS_DNS */
@


1.4
log
@Update pppd to 2.3a4:
Add redo option error-reporting, add PAM, add microsoft compatibility
kludges, bzero stuff at important places, add one or two options
other generic enhancements.  From: Paul.Mackerras@@cs.anu.edu.au
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.3 1996/04/21 23:41:23 deraadt Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: options.c,v 1.3 1996/04/21 23:41:23 deraadt Exp $";
d1485 1
d1500 1
a1500 1
	if ((local = inet_addr(arg)) == -1) {
d1511 2
a1512 1
	}
d1526 1
a1526 1
	if ((remote = inet_addr(colon)) == -1) {
d1537 2
a1538 1
	}
d1591 1
a1591 1
    u_int32_t mask;
d1593 1
a1593 1
    if ((mask = inet_addr(*argv)) == -1 || (netmask & ~mask) != 0) {
d1598 1
a1598 1
    netmask = mask;
d2216 1
a2216 2
    dns = inet_addr(*argv);
    if (dns == -1) {
@


1.3
log
@sync to netbsd 960418
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.2 1996/03/25 15:55:51 niklas Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: options.c,v 1.2 1996/03/25 15:55:51 niklas Exp $";
d107 3
d114 1
a114 1
static int setdevname __P((char *));
d126 1
d128 1
d222 1
d224 1
d236 2
a237 1
    {"-all", 0, noopt},		/* Don't request/allow any options */
d239 1
d243 1
d245 1
d247 1
d249 1
d252 2
d255 3
d259 1
d261 1
d263 1
d265 1
d267 1
d269 1
d279 1
d300 1
d303 1
d327 1
d330 1
d333 1
d336 1
d360 2
d384 1
a384 1
Usage: %s [ arguments ], where arguments are:\n\
d401 2
d430 1
a430 1
		fprintf(stderr, "Too few parameters for command %s\n", arg);
d433 1
d443 1
a443 1
	    if ((ret = setdevname(arg)) == 0
d446 1
a446 1
		fprintf(stderr, "%s: unrecognized command\n", arg);
d458 33
d496 1
d521 1
a521 1
	perror(filename);
d525 1
a525 1
	fprintf(stderr, "%s: access denied\n", filename);
d541 2
a542 2
		    fprintf(stderr,
			    "In file %s: too few parameters for command %s\n",
d549 1
d559 1
a559 1
	    if ((ret = setdevname(cmd)) == 0
d562 1
a562 1
		fprintf(stderr, "In file %s: unrecognized command %s\n",
d629 27
d902 1
a902 1
	    perror(filename);
d917 2
a918 2
	fprintf(stderr, "%s: warning: word in file %s too long (%.20s...)\n",
		progname, filename, word);
d942 2
a943 1
	fprintf(stderr, "%s: invalid number: %s\n", progname, str);
d1110 1
a1110 1
	fprintf(stderr, "mtu option value of %ld is too %s\n", mtu,
d1161 1
a1161 1
    lcp_allowoptions[0].neg_upap = 0;
d1178 1
d1197 1
a1197 1
	fprintf(stderr, "%s: access denied\n", *argv);
d1205 1
a1205 1
	fprintf(stderr, "Unable to read user login data file %s.\n", *argv);
d1220 1
d1229 1
a1229 1
    lcp_allowoptions[0].neg_chap = 0;
d1282 1
a1282 1
	fprintf(stderr, "pppd: vj-max-slots value must be between 2 and 16\n");
d1345 1
a1345 1
      fprintf(stderr, "pppd: maxconnect time must be positive\n");
d1402 2
a1403 1
	    fprintf(stderr, "%s: invalid hex number: %s\n", progname, p);
d1408 1
a1408 1
	    fprintf(stderr, "%s: can't escape character 0x%x\n", progname, n);
d1441 1
a1441 1
setdevname(cp)
d1443 1
d1447 4
a1450 1
  
d1462 1
a1462 1
	if (errno == ENOENT)
d1464 1
a1464 1
	syslog(LOG_ERR, cp);
d1501 1
a1501 1
		fprintf(stderr, "unknown host: %s\n", arg);
d1512 1
a1512 1
	    fprintf(stderr, "bad local IP address %s\n", ip_ntoa(local));
d1526 1
a1526 1
		fprintf(stderr, "unknown host: %s\n", colon);
d1537 1
a1537 1
	    fprintf(stderr, "bad remote IP address %s\n", ip_ntoa(remote));
d1591 1
a1591 1
	fprintf(stderr, "Invalid netmask %s\n", *argv);
d1705 1
a1705 1
	fprintf(stderr, "%s: defaultroute option is disabled\n", progname);
d1724 1
a1724 1
	fprintf(stderr, "%s: proxyarp option is disabled\n", progname);
d1893 1
a1893 2
	fprintf(stderr, "%s: invalid argument format for bsdcomp option\n",
		progname);
d1898 2
a1899 2
	fprintf(stderr, "%s: bsdcomp option values must be 0 or %d .. %d\n",
		progname, BSD_MIN_BITS, BSD_MAX_BITS);
d1937 1
a1937 2
	fprintf(stderr, "%s: invalid argument format for deflate option\n",
		progname);
d1943 2
a1944 2
	fprintf(stderr, "%s: deflate option values must be 0 or %d .. %d\n",
		progname, DEFLATE_MIN_SIZE, DEFLATE_MAX_SIZE);
d2065 1
a2065 3
	    fprintf (stderr,
		     "%s: IPX router name must be alphanumeric or _\n",
		     progname);
d2070 1
a2070 3
	    fprintf (stderr,
		     "%s: IPX router name is limited to %d characters\n",
		     progname,
d2182 1
a2182 2
    fprintf(stderr, "%s: invalid argument for ipx-node option\n",
	    progname);
d2189 1
a2189 1
    ipx_enabled = 1;		/* Enable IPXCP and IPX protocol */
d2196 1
a2196 1
    ipx_enabled = 0;		/* Disable IPXCP and IPX protocol */
d2216 2
a2217 1
	    fprintf(stderr, "Invalid DNS Address %s\n", *argv);
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD$";
d181 1
d300 1
d1764 7
@


1.1
log
@Initial revision
@
text
@d1 2
d23 1
a23 1
static char rcsid[] = "$Id: options.c,v 1.11 1995/08/17 12:03:58 paulus Exp $";
d26 1
d40 1
d51 5
d85 2
d100 1
d103 4
a106 5

#ifdef _linux_
int idle_time_limit = 0;
static int setidle __P((char **));
#endif
d111 2
d129 1
a129 1
static int noipaddr __P((void));
d139 2
d183 5
d190 24
d234 1
a234 1
    {"-ip", 0, noipaddr},	/* Disable IP address negotiation */
d251 2
d278 1
d301 4
d307 24
d334 5
d376 1
a376 1
    char *arg, *val;
d534 1
a534 1
    char *dev, *path;
d537 3
a539 5
    dev = strrchr(devnam, '/');
    if (dev == NULL)
	dev = devnam;
    else
	++dev;
d546 4
a549 1
    strcat(path, dev);
a588 1

d912 6
d946 1
a946 1
 * noipaddr - Disable IP address negotiation.
d949 1
a949 1
noipaddr()
d951 1
a951 2
    ipcp_wantoptions[0].neg_addr = 0;
    ipcp_allowoptions[0].neg_addr = 0;
d1197 1
a1197 1
	novm("connector string");
d1211 1
a1211 1
	novm("disconnector string");
d1216 32
d1336 1
a1336 1
int
a1340 1
    char *tty, *ttyname();
d1371 1
a1371 1
int
a1473 30
 * setipdefault - default our local IP address based on our hostname.
 */
void
setipdefault()
{
    struct hostent *hp;
    u_int32_t local;
    ipcp_options *wo = &ipcp_wantoptions[0];

    /*
     * If local IP address already given, don't bother.
     */
    if (wo->ouraddr != 0 || disable_defaultip)
	return;

    /*
     * Look up our hostname (possibly with domain name appended)
     * and take the first IP address as our local IP address.
     * If there isn't an IP address for our hostname, too bad.
     */
    wo->accept_local = 1;	/* don't insist on this default value */
    if ((hp = gethostbyname(hostname)) == NULL)
	return;
    local = *(u_int32_t *)hp->h_addr;
    if (local != 0 && !bad_ip_adrs(local))
	wo->ouraddr = local;
}


/*
d1511 1
a1511 1
    crtscts = 2;
d1523 7
d1810 62
d1889 2
a1890 2
#ifdef _linux_
static int setidle (argv)
d1895 228
a2122 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
