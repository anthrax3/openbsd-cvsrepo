head	1.21;
access;
symbols
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.16
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.14
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.10
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.16
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.14
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.10
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.12
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.16
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.14
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.12
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.10
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.10.0.14
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.12
	OPENBSD_2_8:1.10.0.10
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.8
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.6
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2015.12.06.12.00.16;	author tobias;	state Exp;
branches;
next	1.20;
commitid	CoyY8UEEpJPwBza5;

1.20
date	2015.09.12.12.42.36;	author miod;	state Exp;
branches;
next	1.19;
commitid	n51KcXXBtD80qiFU;

1.19
date	2015.06.12.14.18.25;	author mikeb;	state Exp;
branches;
next	1.18;
commitid	AcnUd3Ja0KwlGRE9;

1.18
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Uu5nFG3wCl0LACBb;

1.17
date	2011.04.30.18.49.38;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.04.14.59.45;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.25.23.24.32;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.01.19.31.37;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.17.19.42.38;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.28.07;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.07.12.04.34.42;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	98.05.08.04.52.32;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.01.17.20.30.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.10.25.05.09.56;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.05.04.32.45;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.07.25.20.12.17;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.12.23.13.22.48;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.07.20.12.02.14;	author joshd;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.55;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.00;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Use __progname instead of manually handling argv[0].

ok deraadt, mmcc, tedu
@
text
@/*	$OpenBSD: pppd.h,v 1.20 2015/09/12 12:42:36 miod Exp $	*/

/*
 * pppd.h - PPP daemon global declarations.
 *
 * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name "Carnegie Mellon University" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For permission or any legal
 *    details, please contact
 *      Office of Technology Transfer
 *      Carnegie Mellon University
 *      5000 Forbes Avenue
 *      Pittsburgh, PA  15213-3890
 *      (412) 268-4387, fax: (412) 268-7395
 *      tech-transfer@@andrew.cmu.edu
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Computing Services
 *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
 *
 * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * TODO:
 */

#ifndef __PPPD_H__
#define __PPPD_H__

#include <sys/types.h>		/* for u_int32_t, if defined */
#include <sys/time.h>		/* for struct timeval */
#include <net/ppp_defs.h>
#include <stdio.h>		/* for FILE */
#include <stdarg.h>

/*
 * Limits.
 */

#define NUM_PPP		1	/* One PPP interface supported (per process) */
#define MAXWORDLEN	1024	/* max length of word in file (incl null) */
#define MAXARGS		1	/* max # args to a command */
#define MAXNAMELEN	256	/* max length of hostname or name for auth */
#define MAXSECRETLEN	256	/* max length of password or secret */

/*
 * Global variables.
 */

extern int	hungup;		/* Physical layer has disconnected */
extern int	ifunit;		/* Interface unit number */
extern char	ifname[];	/* Interface name */
extern int	ttyfd;		/* Serial device file descriptor */
extern char	hostname[];	/* Our hostname */
extern u_char	outpacket_buf[]; /* Buffer for outgoing packets */
extern int	phase;		/* Current state of link - see values below */
extern int	baud_rate;	/* Current link speed in bits/sec */
extern char	*__progname;	/* Name of this program */
extern int	redirect_stderr;/* Connector's stderr should go to file */
extern char	peer_authname[];/* Authenticated name of peer */
extern int	privileged;	/* We were run by real-uid root */
extern int	need_holdoff;	/* Need holdoff period after link terminates */
extern char	**script_env;	/* Environment variables for scripts */
extern int	detached;	/* Have detached from controlling tty */

/*
 * Variables set by command-line options.
 */

extern int	debug;		/* Debug flag */
extern int	kdebugflag;	/* Tell kernel to print debug messages */
extern int	default_device;	/* Using /dev/tty or equivalent */
extern char	devnam[];	/* Device name */
extern int	crtscts;	/* Use hardware flow control */
extern int	modem;		/* Use modem control lines */
extern int	modem_chat;	/* Watch carrier detect in chat script */
extern int	inspeed;	/* Input/Output speed requested */
extern u_int32_t netmask;	/* IP netmask to set on interface */
extern int	lockflag;	/* Create lock file to lock the serial dev */
extern int	nodetach;	/* Don't detach from controlling tty */
extern char	*connector;	/* Script to establish physical link */
extern char	*disconnector;	/* Script to disestablish physical link */
extern char	*welcomer;	/* Script to welcome client after connection */
extern int	maxconnect;	/* Maximum connect time (seconds) */
extern char	user[];		/* Our name for authenticating ourselves */
extern char	passwd[];	/* Password for PAP */
extern int	auth_required;	/* Peer is required to authenticate */
extern int	proxyarp;	/* Set up proxy ARP entry for peer */
extern int	persist;	/* Reopen link after it goes down */
extern int	uselogin;	/* Use /etc/passwd for checking PAP */
extern int	lcp_echo_interval; /* Interval between LCP echo-requests */
extern int	lcp_echo_fails;	/* Tolerance to unanswered echo-requests */
extern char	our_name[];	/* Our name for authentication purposes */
extern char	remote_name[];	/* Peer's name for authentication */
extern int	explicit_remote;/* remote_name specified with remotename opt */
extern int	usehostname;	/* Use hostname for our_name */
extern int	disable_defaultip; /* Don't use hostname for default IP adrs */
extern int	demand;		/* Do dial-on-demand */
extern char	*ipparam;	/* Extra parameter for ip up/down scripts */
extern int	cryptpap;	/* Others' PAP passwords are encrypted */
extern int	idle_time_limit;/* Shut down link if idle for this long */
extern int	holdoff;	/* Dead time before restarting */
extern int	refuse_pap;	/* Don't wanna auth. ourselves with PAP */
extern int	refuse_chap;	/* Don't wanna auth. ourselves with CHAP */
#ifdef PPP_FILTER
extern struct	bpf_program pass_filter;   /* Filter for pkts to pass */
extern struct	bpf_program active_filter; /* Filter for link-active pkts */
#endif

#ifdef MSLANMAN
extern int	ms_lanman;	/* Nonzero if use LanMan password instead of NT */
				/* Has meaning only with MS-CHAP challenges */
#endif

/*
 * Values for phase.
 */
#define PHASE_DEAD		0
#define PHASE_INITIALIZE	1
#define PHASE_DORMANT		2
#define PHASE_ESTABLISH		3
#define PHASE_AUTHENTICATE	4
#define PHASE_CALLBACK		5
#define PHASE_NETWORK		6
#define PHASE_TERMINATE		7
#define PHASE_HOLDOFF		8

/*
 * The following struct gives the addresses of procedures to call
 * for a particular protocol.
 */
struct protent {
    u_short protocol;		/* PPP protocol number */
    /* Initialization procedure */
    void (*init)(int unit);
    /* Process a received packet */
    void (*input)(int unit, u_char *pkt, int len);
    /* Process a received protocol-reject */
    void (*protrej)(int unit);
    /* Lower layer has come up */
    void (*lowerup)(int unit);
    /* Lower layer has gone down */
    void (*lowerdown)(int unit);
    /* Open the protocol */
    void (*open)(int unit);
    /* Close the protocol */
    void (*close)(int unit, char *reason);
    /* Print a packet in readable form */
    int  (*printpkt)(u_char *pkt, int len,
	void (*printer)(void *, char *, ...), void *arg);
    /* Process a received data packet */
    void (*datainput)(int unit, u_char *pkt, int len);
    int  enabled_flag;		/* 0 iff protocol is disabled */
    char *name;			/* Text name of protocol */
    /* Check requested options, assign defaults */
    void (*check_options)(void);
    /* Configure interface for demand-dial */
    int  (*demand_conf)(int unit);
    /* Say whether to bring up link for this pkt */
    int  (*active_pkt)(u_char *pkt, int len);
};

/* Table of pointers to supported protocols */
extern struct protent *protocols[];

/*
 * Prototypes.
 */

/* Procedures exported from main.c. */
void detach(void);		/* Detach from controlling tty */
void die(int);			/* Cleanup and exit */
void quit(void);		/* like die(1) */
void novm(char *);		/* Say we ran out of memory, and die */
void timeout(void (*func)(void *), void *arg, int t);
				/* Call func(arg) after t seconds */
void untimeout(void (*func)(void *), void *arg);
				/* Cancel call to func(arg) */
int run_program(char *prog, char **args, int must_exist);
				/* Run program prog with args in child */
void demuxprotrej(int, int);
				/* Demultiplex a Protocol-Reject */
void format_packet(u_char *, int, void (*) (void *, char *, ...), void *);
				/* Format a packet in human-readable form */
void log_packet(u_char *, int, char *, int);
				/* Format a packet and log it with syslog */
void print_string(char *, int,  void (*) (void *, char *, ...), void *);
				/* Format a string for output */
int fmtmsg(char *, int, char *, ...);		/* snprintf++ */
int vfmtmsg(char *, int, char *, va_list);	/* vsnprintf++ */
void script_setenv(char *, char *);	/* set script env var */

/* Procedures exported from auth.c */
void link_required(int);	/* we are starting to use the link */
void link_terminated(int);	/* we are finished with the link */
void link_down(int);		/* the LCP layer has left the Opened state */
void link_established(int);	/* the link is up; authenticate now */
void np_up(int, int);		/* a network protocol has come up */
void np_down(int, int);		/* a network protocol has gone down */
void np_finished(int, int);	/* a network protocol no longer needs link */
void auth_peer_fail(int, int);
				/* peer failed to authenticate itself */
void auth_peer_success(int, int, char *, int);
				/* peer successfully authenticated itself */
void auth_withpeer_fail(int, int);
				/* we failed to authenticate ourselves */
void auth_withpeer_success(int, int);
				/* we successfully authenticated ourselves */
void auth_check_options(void);
				/* check authentication options supplied */
void auth_reset(int);		/* check what secrets we have */
int  check_passwd(int, char *, int, char *, int, char **, int *);
				/* Check peer-supplied username/password */
int  get_secret(int, char *, char *, char *, int *, int);
				/* get "secret" for chap */
int  auth_ip_addr(int, u_int32_t);
				/* check if IP address is authorized */
int  bad_ip_adrs(u_int32_t);
				/* check if IP address is unreasonable */
void check_access(FILE *, char *);
				/* check permissions on secrets file */

/* Procedures exported from demand.c */
void demand_conf(void);		/* config interface(s) for demand-dial */
void demand_drop(void); 	/* set all NPs to drop packets */
void demand_unblock(void);	/* set all NPs to pass packets */
void demand_rexmit(int);	/* retransmit saved frames for an NP */
int  loop_chars(unsigned char *, int); /* process chars from loopback */
int  loop_frame(unsigned char *, int); /* process frame from loopback */

/* Procedures exported from sys-*.c */
void sys_init(void);		/* Do system-dependent initialization */
void sys_cleanup(void);		/* Restore system state before exiting */
void sys_check_options(void);	/* Check options specified */
void sys_close(void);		/* Clean up in a child before execing */
int  ppp_available(void);	/* Test whether ppp kernel support exists */
void open_ppp_loopback(void);	/* Open loopback for demand-dialling */
void establish_ppp(int);	/* Turn serial port into a ppp interface */
void restore_loop(void);	/* Transfer ppp unit back to loopback */
void disestablish_ppp(int);	/* Restore port to normal operation */
void clean_check(void);		/* Check if line was 8-bit clean */
void set_up_tty(int, int);	/* Set up port's speed, parameters, etc. */
void restore_tty(int);		/* Restore port's original parameters */
void setdtr(int, int);		/* Raise or lower port's DTR line */
void output(int, u_char *, int); /* Output a PPP packet */
void wait_input(struct timeval *);
				/* Wait for input, with timeout */
void wait_loop_output(struct timeval *);
				/* Wait for pkt from loopback, with timeout */
void wait_time(struct timeval *); /* Wait for given length of time */
int  read_packet(u_char *);	/* Read PPP packet */
int  get_loop_output(void);	/* Read pkts from loopback */
void ppp_send_config(int, int, u_int32_t, int, int);
				/* Configure i/f transmit parameters */
void ppp_set_xaccm(int, ext_accm);
				/* Set extended transmit ACCM */
void ppp_recv_config(int, int, u_int32_t, int, int);
				/* Configure i/f receive parameters */
int  ccp_test(int, u_char *, int, int);
				/* Test support for compression scheme */
void ccp_flags_set(int, int, int);
				/* Set kernel CCP state */
int  ccp_fatal_error(int);	/* Test for fatal decomp error in kernel */
int  get_idle_time(int, struct ppp_idle *);
				/* Find out how long link has been idle */
int  sifvjcomp(int, int, int, int);
				/* Configure VJ TCP header compression */
int  sifup(int);		/* Configure i/f up (for IP) */
int  sifnpmode(int u, int proto, enum NPmode mode);
				/* Set mode for handling packets for proto */
int  sifdown(int);		/* Configure i/f down (for IP) */
int  sifaddr(int, u_int32_t, u_int32_t, u_int32_t);
				/* Configure IP addresses for i/f */
int  cifaddr(int, u_int32_t, u_int32_t);
				/* Reset i/f IP addresses */
int  sifdefaultroute(int, u_int32_t, u_int32_t);
				/* Create default route through i/f */
int  cifdefaultroute(int, u_int32_t, u_int32_t);
				/* Delete default route through i/f */
int  sifproxyarp(int, u_int32_t);
				/* Add proxy ARP entry for peer */
int  cifproxyarp(int, u_int32_t);
				/* Delete proxy ARP entry for peer */
u_int32_t GetMask(u_int32_t);	/* Get appropriate netmask for address */
int  lock(char *);		/* Create lock file for device */
void unlock(void);		/* Delete previously-created lock file */
int  daemon(int, int);		/* Detach us from terminal session */
void logwtmp(const char *, const char *, const char *);
				/* Write entry to wtmp file */
#ifdef PPP_FILTER
int  set_filters(struct bpf_program *pass, struct bpf_program *active);
				/* Set filter programs in kernel */
#endif

/* Procedures exported from options.c */
int  parse_args(int argc, char **argv);
				/* Parse options from arguments given */
void usage(void);		/* Print a usage message */
int  options_from_file(char *filename, int must_exist, int check_prot,
		       int privileged);
				/* Parse options from an options file */
int  options_from_user(void);	/* Parse options from user's .ppprc */
int  options_for_tty(void);	/* Parse options from /etc/ppp/options.tty */
void scan_args(int argc, char **argv);
				/* Look for tty name in command-line args */
int  getword(FILE *f, char *word, int *newlinep, char *filename);
				/* Read a word from a file */
void option_error(char *fmt, ...);
				/* Print an error message about an option */

/*
 * This structure is used to store information about certain
 * options, such as where the option value came from (/etc/ppp/options,
 * command line, etc.) and whether it came from a privileged source.
 */

struct option_info {
    int	    priv;		/* was value set by sysadmin? */
    char    *source;		/* where option came from */
};

extern struct option_info auth_req_info;
extern struct option_info connector_info;
extern struct option_info disconnector_info;
extern struct option_info welcomer_info;
extern struct option_info devnam_info;

/*
 * Inline versions of get/put char/short/long.
 * Pointer is advanced; we assume that both arguments
 * are lvalues and will already be in registers.
 * cp MUST be u_char *.
 */
#define GETCHAR(c, cp) { \
	(c) = *(cp)++; \
}
#define PUTCHAR(c, cp) { \
	*(cp)++ = (u_char) (c); \
}


#define GETSHORT(s, cp) { \
	(s) = *(cp)++ << 8; \
	(s) |= *(cp)++; \
}
#define PUTSHORT(s, cp) { \
	*(cp)++ = (u_char) ((s) >> 8); \
	*(cp)++ = (u_char) (s); \
}

#define GETLONG(l, cp) { \
	(l) = *(cp)++ << 8; \
	(l) |= *(cp)++; (l) <<= 8; \
	(l) |= *(cp)++; (l) <<= 8; \
	(l) |= *(cp)++; \
}
#define PUTLONG(l, cp) { \
	*(cp)++ = (u_char) ((l) >> 24); \
	*(cp)++ = (u_char) ((l) >> 16); \
	*(cp)++ = (u_char) ((l) >> 8); \
	*(cp)++ = (u_char) (l); \
}

#define INCPTR(n, cp)	((cp) += (n))
#define DECPTR(n, cp)	((cp) -= (n))

#undef  FALSE
#define FALSE	0
#undef  TRUE
#define TRUE	1

/*
 * System dependent definitions for user-level 4.3BSD UNIX implementation.
 */

#define DEMUXPROTREJ(u, p)	demuxprotrej(u, p)

#define TIMEOUT(r, f, t)	timeout((r), (f), (t))
#define UNTIMEOUT(r, f)		untimeout((r), (f))

#define BCOPY(s, d, l)		memcpy(d, s, l)
#define BMOVE(s, d, l)		memmove(d, s, l)
#define BZERO(s, n)		memset(s, 0, n)
#define EXIT(u)			quit()

#define PRINTMSG(m, l)	{ m[l] = '\0'; syslog(LOG_INFO, "Remote message: %s", m); }

/*
 * MAKEHEADER - Add Header fields to a packet.
 */
#define MAKEHEADER(p, t) { \
    PUTCHAR(PPP_ALLSTATIONS, p); \
    PUTCHAR(PPP_UI, p); \
    PUTSHORT(t, p); }


#ifdef DEBUGALL
#define DEBUGMAIN	1
#define DEBUGFSM	1
#define DEBUGLCP	1
#define DEBUGIPCP	1
#define DEBUGUPAP	1
#define DEBUGCHAP	1
#endif

#ifndef LOG_PPP			/* we use LOG_LOCAL2 for syslog by default */
#if defined(DEBUGMAIN) || defined(DEBUGFSM) || defined(DEBUGSYS) \
  || defined(DEBUGLCP) || defined(DEBUGIPCP) || defined(DEBUGUPAP) \
  || defined(DEBUGCHAP) || defined(DEBUG)
#define LOG_PPP LOG_LOCAL2
#else
#define LOG_PPP LOG_DAEMON
#endif
#endif /* LOG_PPP */

#ifdef DEBUGMAIN
#define MAINDEBUG(x)	if (debug) syslog x
#else
#define MAINDEBUG(x)
#endif

#ifdef DEBUGSYS
#define SYSDEBUG(x)	if (debug) syslog x
#else
#define SYSDEBUG(x)
#endif

#ifdef DEBUGFSM
#define FSMDEBUG(x)	if (debug) syslog x
#else
#define FSMDEBUG(x)
#endif

#ifdef DEBUGLCP
#define LCPDEBUG(x)	if (debug) syslog x
#else
#define LCPDEBUG(x)
#endif

#ifdef DEBUGIPCP
#define IPCPDEBUG(x)	if (debug) syslog x
#else
#define IPCPDEBUG(x)
#endif

#ifdef DEBUGUPAP
#define UPAPDEBUG(x)	if (debug) syslog x
#else
#define UPAPDEBUG(x)
#endif

#ifdef DEBUGCHAP
#define CHAPDEBUG(x)	if (debug) syslog x
#else
#define CHAPDEBUG(x)
#endif

#ifndef SIGTYPE
#if defined(sun) || defined(SYSV) || defined(POSIX_SOURCE)
#define SIGTYPE void
#else
#define SIGTYPE int
#endif /* defined(sun) || defined(SYSV) || defined(POSIX_SOURCE) */
#endif /* SIGTYPE */

#ifndef MIN
#define MIN(a, b)	((a) < (b)? (a): (b))
#endif
#ifndef MAX
#define MAX(a, b)	((a) > (b)? (a): (b))
#endif

#endif /* __PPP_H__ */
@


1.20
log
@Remove dead get_host_seed() function; Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.19 2015/06/12 14:18:25 mikeb Exp $	*/
d80 1
a80 1
extern char	*progname;	/* Name of this program */
@


1.19
log
@Perform a copy with a memmove for potentially overlapping regions.

Reported and fixed by Sergey Ryazanov <ryazanov ! s ! a at gmail ! com>,
thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.18 2015/01/16 06:40:19 deraadt Exp $	*/
a311 1
int  get_host_seed(void);	/* Get host-dependent random number seed */
@


1.18
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.17 2011/04/30 18:49:38 nicm Exp $	*/
d405 1
@


1.17
log
@Remove some unused code, from Michael W Bombardieri. ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.16 2007/06/04 14:59:45 henning Exp $	*/
a51 3
#include <stdio.h>		/* for FILE */
#include <stdarg.h>
#include <sys/param.h>		/* for MAXPATHLEN and BSD4_4, if defined */
d55 2
@


1.16
log
@bye bye ipx
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.15 2003/04/25 23:24:32 deraadt Exp $	*/
a214 1
void script_unsetenv(char *);		/* unset script env var */
a247 1
void demand_block(void);	/* set all NPs to queue up packets */
a249 1
void demand_discard(void);	/* set all NPs to discard packets */
@


1.15
log
@comment cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.14 2002/07/01 19:31:37 deraadt Exp $	*/
a481 6
#endif

#ifdef DEBUGIPXCP
#define IPXCPDEBUG(x)	if (debug) syslog x
#else
#define IPXCPDEBUG(x)
@


1.14
log
@license update of CMU parts.  due to communication with wcw+@@andrew.cmu.edu,
pushed for by tygs@@netcologne.de.  Apparently we also now known how to talk
to the lawyers there, if we were so mad.  Note that a few other copyright
issues in pppd still remain, so this does not close this story.
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.13 2002/02/19 19:39:40 millert Exp $	*/
d212 2
a213 2
int fmtmsg(char *, int, char *, ...);		/* sprintf++ */
int vfmtmsg(char *, int, char *, va_list);	/* vsprintf++ */
@


1.13
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.12 2002/02/17 19:42:38 millert Exp $	*/
d6 1
a6 2
 * Copyright (c) 1989 Carnegie Mellon University.
 * All rights reserved.
d8 3
a10 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Carnegie Mellon University.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d12 31
a42 1
 * Id: pppd.h,v 1.21 1998/03/26 04:46:08 paulus Exp $
@


1.12
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.11 2002/02/16 21:28:07 millert Exp $	*/
d32 1
a36 9

#ifdef __STDC__
#include <stdarg.h>
#define __V(x)        x
#else
#include <varargs.h>
#define __V(x)        (va_alist) va_dcl
#define const
#endif
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.10 1998/07/12 04:34:42 angelos Exp $	*/
d159 2
a160 3
    int  (*printpkt) __P((u_char *pkt, int len,
			  void (*printer)(void *, char *, ...),
			  void *arg));
d185 1
a185 1
void timeout __P((void (*func)(void *), void *arg, int t));
d187 1
a187 1
void untimeout __P((void (*func)(void *), void *arg));
d193 2
a194 2
void format_packet __P((u_char *, int, void (*) (void *, char *, ...),
		void *));	/* Format a packet in human-readable form */
d197 2
a198 2
void print_string __P((char *, int,  void (*) (void *, char *, ...),
		void *));	/* Format a string for output */
d313 2
a314 2
int  options_from_file __P((char *filename, int must_exist, int check_prot,
			    int privileged));
@


1.10
log
@Implement demand_drop() for demand mode pppd; try to avoid mbuf
exhaustion while setting up a connection.
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.9 1998/05/08 04:52:32 millert Exp $	*/
d145 1
a145 1
    void (*init) __P((int unit));
d147 1
a147 1
    void (*input) __P((int unit, u_char *pkt, int len));
d149 1
a149 1
    void (*protrej) __P((int unit));
d151 1
a151 1
    void (*lowerup) __P((int unit));
d153 1
a153 1
    void (*lowerdown) __P((int unit));
d155 1
a155 1
    void (*open) __P((int unit));
d157 1
a157 1
    void (*close) __P((int unit, char *reason));
d160 1
a160 1
			  void (*printer) __P((void *, char *, ...)),
d163 1
a163 1
    void (*datainput) __P((int unit, u_char *pkt, int len));
d167 1
a167 1
    void (*check_options) __P((void));
d169 1
a169 1
    int  (*demand_conf) __P((int unit));
d171 1
a171 1
    int  (*active_pkt) __P((u_char *pkt, int len));
d182 4
a185 4
void detach __P((void));	/* Detach from controlling tty */
void die __P((int));		/* Cleanup and exit */
void quit __P((void));		/* like die(1) */
void novm __P((char *));	/* Say we ran out of memory, and die */
d190 1
a190 1
int run_program __P((char *prog, char **args, int must_exist));
d192 1
a192 1
void demuxprotrej __P((int, int));
d196 1
a196 1
void log_packet __P((u_char *, int, char *, int));
d200 4
a203 4
int fmtmsg __P((char *, int, char *, ...));		/* sprintf++ */
int vfmtmsg __P((char *, int, char *, va_list));	/* vsprintf++ */
void script_setenv __P((char *, char *));	/* set script env var */
void script_unsetenv __P((char *));		/* unset script env var */
d206 8
a213 8
void link_required __P((int));	  /* we are starting to use the link */
void link_terminated __P((int));  /* we are finished with the link */
void link_down __P((int));	  /* the LCP layer has left the Opened state */
void link_established __P((int)); /* the link is up; authenticate now */
void np_up __P((int, int));	  /* a network protocol has come up */
void np_down __P((int, int));	  /* a network protocol has gone down */
void np_finished __P((int, int)); /* a network protocol no longer needs link */
void auth_peer_fail __P((int, int));
d215 1
a215 1
void auth_peer_success __P((int, int, char *, int));
d217 1
a217 1
void auth_withpeer_fail __P((int, int));
d219 1
a219 1
void auth_withpeer_success __P((int, int));
d221 1
a221 1
void auth_check_options __P((void));
d223 2
a224 2
void auth_reset __P((int));	/* check what secrets we have */
int  check_passwd __P((int, char *, int, char *, int, char **, int *));
d226 1
a226 1
int  get_secret __P((int, char *, char *, char *, int *, int));
d228 1
a228 1
int  auth_ip_addr __P((int, u_int32_t));
d230 1
a230 1
int  bad_ip_adrs __P((u_int32_t));
d232 1
a232 1
void check_access __P((FILE *, char *));
d236 8
a243 8
void demand_conf __P((void));	/* config interface(s) for demand-dial */
void demand_block __P((void));	/* set all NPs to queue up packets */
void demand_drop __P((void)); 	/* set all NPs to drop packets */
void demand_unblock __P((void)); /* set all NPs to pass packets */
void demand_discard __P((void)); /* set all NPs to discard packets */
void demand_rexmit __P((int));	/* retransmit saved frames for an NP */
int  loop_chars __P((unsigned char *, int)); /* process chars from loopback */
int  loop_frame __P((unsigned char *, int)); /* process frame from loopback */
d246 15
a260 15
void sys_init __P((void));	/* Do system-dependent initialization */
void sys_cleanup __P((void));	/* Restore system state before exiting */
void sys_check_options __P((void)); /* Check options specified */
void sys_close __P((void));	/* Clean up in a child before execing */
int  ppp_available __P((void));	/* Test whether ppp kernel support exists */
void open_ppp_loopback __P((void)); /* Open loopback for demand-dialling */
void establish_ppp __P((int));	/* Turn serial port into a ppp interface */
void restore_loop __P((void));	/* Transfer ppp unit back to loopback */
void disestablish_ppp __P((int)); /* Restore port to normal operation */
void clean_check __P((void));	/* Check if line was 8-bit clean */
void set_up_tty __P((int, int)); /* Set up port's speed, parameters, etc. */
void restore_tty __P((int));	/* Restore port's original parameters */
void setdtr __P((int, int));	/* Raise or lower port's DTR line */
void output __P((int, u_char *, int)); /* Output a PPP packet */
void wait_input __P((struct timeval *));
d262 1
a262 1
void wait_loop_output __P((struct timeval *));
d264 4
a267 4
void wait_time __P((struct timeval *)); /* Wait for given length of time */
int  read_packet __P((u_char *)); /* Read PPP packet */
int  get_loop_output __P((void)); /* Read pkts from loopback */
void ppp_send_config __P((int, int, u_int32_t, int, int));
d269 1
a269 1
void ppp_set_xaccm __P((int, ext_accm));
d271 1
a271 1
void ppp_recv_config __P((int, int, u_int32_t, int, int));
d273 1
a273 1
int  ccp_test __P((int, u_char *, int, int));
d275 1
a275 1
void ccp_flags_set __P((int, int, int));
d277 2
a278 2
int  ccp_fatal_error __P((int)); /* Test for fatal decomp error in kernel */
int  get_idle_time __P((int, struct ppp_idle *));
d280 1
a280 1
int  sifvjcomp __P((int, int, int, int));
d282 2
a283 2
int  sifup __P((int));		/* Configure i/f up (for IP) */
int  sifnpmode __P((int u, int proto, enum NPmode mode));
d285 2
a286 2
int  sifdown __P((int));	/* Configure i/f down (for IP) */
int  sifaddr __P((int, u_int32_t, u_int32_t, u_int32_t));
d288 1
a288 1
int  cifaddr __P((int, u_int32_t, u_int32_t));
d290 1
a290 1
int  sifdefaultroute __P((int, u_int32_t, u_int32_t));
d292 1
a292 1
int  cifdefaultroute __P((int, u_int32_t, u_int32_t));
d294 1
a294 1
int  sifproxyarp __P((int, u_int32_t));
d296 1
a296 1
int  cifproxyarp __P((int, u_int32_t));
d298 5
a302 5
u_int32_t GetMask __P((u_int32_t)); /* Get appropriate netmask for address */
int  lock __P((char *));	/* Create lock file for device */
void unlock __P((void));	/* Delete previously-created lock file */
int  daemon __P((int, int));	/* Detach us from terminal session */
void logwtmp __P((const char *, const char *, const char *));
d304 1
a304 1
int  get_host_seed __P((void));	/* Get host-dependent random number seed */
d306 1
a306 1
int  set_filters __P((struct bpf_program *pass, struct bpf_program *active));
d311 1
a311 1
int  parse_args __P((int argc, char **argv));
d313 1
a313 1
void usage __P((void));		/* Print a usage message */
d317 3
a319 3
int  options_from_user __P((void)); /* Parse options from user's .ppprc */
int  options_for_tty __P((void)); /* Parse options from /etc/ppp/options.tty */
void scan_args __P((int argc, char **argv));
d321 1
a321 1
int  getword __P((FILE *f, char *word, int *newlinep, char *filename));
d323 1
a323 1
void option_error __P((char *fmt, ...));
@


1.9
log
@pppd 2.3.5
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.8 1998/01/17 20:30:28 millert Exp $	*/
d238 1
@


1.8
log
@ppp-2.3.3 + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.7 1997/10/25 05:09:56 millert Exp $	*/
d21 1
a21 1
 * Id: pppd.h,v 1.19 1997/04/30 05:56:55 paulus Exp
d73 2
d182 1
d202 2
d303 1
@


1.7
log
@Set CLOCAL for chat script by default.  Add new option "modem_chat"
to override the default for people using cua devices who want chat
to detect loss of carrier.
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.6 1997/09/05 04:32:45 millert Exp $	*/
d183 1
a183 1
void timeout __P((void (*func)(caddr_t), caddr_t arg, int t));
d185 1
a185 1
void untimeout __P((void (*func)(caddr_t), caddr_t arg));
@


1.6
log
@ppp 2.3.1
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.5 1997/07/25 20:12:17 mickey Exp $	*/
d84 1
@


1.5
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.4 1996/12/23 13:22:48 mickey Exp $	*/
d20 2
d43 1
d102 1
d110 6
a115 2
extern int    refuse_pap;     /* Don't wanna auth. ourselves with PAP */
extern int    refuse_chap;    /* Don't wanna auth. ourselves with CHAP */
d117 4
d126 4
a129 4
#define PHASE_INITIALIZE      1
#define PHASE_DORMANT         2
#define PHASE_ESTABLISH               3
#define PHASE_AUTHENTICATE    4
d143 1
a143 1
    /* Process a received packet */ 
d149 1
a149 1
    /* Lower layer has gone down */   
d157 2
a158 2
                        void (*printer) __P((void *, char *, ...)),
                        void *arg));
d182 1
a182 1
void timeout __P((void (*func)(), caddr_t arg, int t));
d184 1
a184 1
void untimeout __P((void (*func)(), caddr_t arg));
d192 1
a192 1
void log_packet __P((u_char *, int, char *));
d196 2
a197 3
int fmtmsg __P((char *, int, char *, ...));           /* sprintf++ */
int vfmtmsg __P((char *, int, char *, va_list));      /* vsprintf++ */

d217 1
a217 2
void auth_reset __P((int));     /* check what secrets we have */

d283 1
a283 1
int  sifdefaultroute __P((int, u_int32_t));
d285 1
a285 1
int  cifdefaultroute __P((int, u_int32_t));
d295 1
a295 1
int  logwtmp __P((char *, char *, char *));
d297 4
d307 1
a307 1
                            int privileged));
d312 1
a312 1
                                /* Look for tty name in command-line args */
@


1.4
log
@pppd 2.3b3 import. some minor buf oflow fixes and so.
try it out ppl, but i've got it running talking to cisco w/ all the AFs
enabled in kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.3 1996/07/20 12:02:14 joshd Exp $	*/
d35 1
a35 1
#if __STDC__
@


1.3
log
@Update pppd to 2.3a4:
Add redo option error-reporting, add PAM, add microsoft compatibility
kludges, bzero stuff at important places, add one or two options
other generic enhancements.  From: Paul.Mackerras@@cs.anu.edu.au
@
text
@d1 1
a1 1
/*	$OpenBSD: pppd.h,v 1.2 1996/03/25 15:55:55 niklas Exp $	*/
a33 1
#include <net/bpf.h>
a42 2
#define NUM_PPP	1		/* One PPP interface supported (per process) */

d47 1
d66 4
a69 2
extern int    redirect_stderr;  /* Connector's stderr should go to file */
extern char   peer_authname[];  /* Authenticated name of peer */
d88 2
a89 2
extern int	maxconnect;	/* maximum number of seconds for a connection */
extern char	user[];		/* Username for PAP */
a105 2
extern struct	bpf_program pass_filter;   /* Filter for pkts to pass */
extern struct	bpf_program active_filter; /* Filter for link-active pkts */
d118 4
a121 3
#define PHASE_NETWORK         5
#define PHASE_TERMINATE               6
#define PHASE_HOLDOFF         7
a232 1
void note_debug_level __P((void)); /* Note change in debug level */
a286 2
int  set_filters __P((struct bpf_program *pass, struct bpf_program *active));
				/* Set filter programs in kernel */
d292 2
a293 1
int  options_from_file __P((char *filename, int must_exist, int check_prot));
a298 1

d301 19
d448 6
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 8
d68 2
d108 3
d116 7
a122 6
#define PHASE_DORMANT		1
#define PHASE_ESTABLISH		2
#define PHASE_AUTHENTICATE	3
#define PHASE_NETWORK		4
#define PHASE_TERMINATE		5
#define PHASE_HOLDOFF		6
d130 20
a149 9
    void (*init)();		/* Initialization procedure */
    void (*input)();		/* Process a received packet */
    void (*protrej)();		/* Process a received protocol-reject */
    void (*lowerup)();		/* Lower layer has come up */
    void (*lowerdown)();	/* Lower layer has gone down */
    void (*open)();		/* Open the protocol */
    void (*close)();		/* Close the protocol */
    int  (*printpkt)();		/* Print a packet in readable form */
    void (*datainput)();	/* Process a received data packet */
d152 6
a157 2
    void (*check_options)();	/* Check requested options, assign dflts */
    int  (*demand_conf)();	/* Configure interface for demand-dial */
d185 3
d199 1
a199 1
void auth_peer_success __P((int, int));
d207 2
d300 3
@


1.1
log
@Initial revision
@
text
@d1 2
a19 2
 *
 * $Id: pppd.h,v 1.7 1995/07/04 23:48:05 paulus Exp $
d29 1
d32 1
d34 1
d54 1
a54 1
extern int	fd;		/* Serial device file descriptor */
d77 2
d91 1
d94 4
d103 30
a132 4
#define PHASE_ESTABLISH		1
#define PHASE_AUTHENTICATE	2
#define PHASE_NETWORK		3
#define PHASE_TERMINATE		4
d137 11
a147 7
void quit __P((void));	/* Cleanup and exit */
void timeout __P((void (*)(), caddr_t, int));
				/* Look-alike of kernel's timeout() */
void untimeout __P((void (*)(), caddr_t));
				/* Look-alike of kernel's untimeout() */
void output __P((int, u_char *, int));
				/* Output a PPP packet */
d150 25
d179 89
a267 2
u_int32_t GetMask __P((u_int32_t)); /* get netmask for address */
void die __P((int));
d347 1
a347 1
#if defined(DEBUGMAIN) || defined(DEBUGFSM) || defined(DEBUG) \
d349 1
a349 1
  || defined(DEBUGCHAP) 
d360 6
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
