head	1.35;
access;
symbols
	OPENBSD_6_0:1.35.0.2
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.30.0.8
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.6
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.28.0.10
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.8
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.6
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.23.0.10
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.22.0.16
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.14
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.12
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.10
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.8
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.6
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.4
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.6
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2016.04.05.21.24.02;	author krw;	state Exp;
branches;
next	1.34;
commitid	3qdWFFf70QZsgEH7;

1.34
date	2016.03.16.15.41.11;	author krw;	state Exp;
branches;
next	1.33;
commitid	JEVxsRygqcjPtWTf;

1.33
date	2016.01.25.21.24.17;	author gsoares;	state Exp;
branches;
next	1.32;
commitid	gXg2PrQyUUoB2wHF;

1.32
date	2015.08.20.22.46.32;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	bryBnuht7UhcZOWL;

1.31
date	2015.02.09.23.00.14;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	822YD61EeG0Xl9Na;

1.30
date	2013.04.21.17.50.29;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2013.04.20.20.32.37;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.12.02.00.28;	author kevlo;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.08.18.36.34;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.08.14.09.34;	author sobrado;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.19.15.33.06;	author martynas;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.11.16.30.59;	author gilles;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.26.17.46.24;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.25.23.23.50;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.04.22.38.49;	author avsm;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.03.18.53.50;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.02.22.22.56;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.29.19.23.34;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.17.19.42.38;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.28.07;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.05.22.32.46;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.12.02.02.32.29;	author d;	state Exp;
branches;
next	1.11;

1.11
date	99.12.02.02.22.56;	author d;	state Exp;
branches;
next	1.10;

1.10
date	98.10.30.18.04.59;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	98.09.12.14.06.52;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	98.08.04.17.50.58;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.05.08.04.52.36;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.01.17.20.30.33;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.11.16.21.16.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.09.19.18.00.58;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.09.01.21.48.28;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.05.21.20.53.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.00;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Move more fcntl(,F_GETFL,0) -> fcntl(,F_GETFL).

No functional change.

ok guenther@@
@
text
@/*	$OpenBSD: chat.c,v 1.34 2016/03/16 15:41:11 krw Exp $	*/

/*
 *	Chat -- a program for automatic session establishment (i.e. dial
 *		the phone and log in).
 *
 * Standard termination codes:
 *  0 - successful completion of the script
 *  1 - invalid argument, expect string too large, etc.
 *  2 - error on an I/O operation or fatal error condition.
 *  3 - timeout waiting for a simple string.
 *  4 - the first string declared as "ABORT"
 *  5 - the second string declared as "ABORT"
 *  6 - ... and so on for successive ABORT strings.
 *
 *	This software is in the public domain.
 *
 * -----------------
 *	added -T and -U option and \T and \U substitution to pass a phone
 *	number into chat script. Two are needed for some ISDN TA applications.
 *	Keith Dart <kdart@@cisco.com>
 *	
 *
 *	Added SAY keyword to send output to stderr.
 *      This allows to turn ECHO OFF and to output specific, user selected,
 *      text to give progress messages. This best works when stderr
 *      exists (i.e.: pppd in nodetach mode).
 *
 * 	Added HANGUP directives to allow for us to be called
 *      back. When HANGUP is set to NO, chat will not hangup at HUP signal.
 *      We rely on timeouts in that case.
 *
 *      Added CLR_ABORT to clear previously set ABORT string. This has been
 *      dictated by the HANGUP above as "NO CARRIER" (for example) must be
 *      an ABORT condition until we know the other host is going to close
 *      the connection for call back. As soon as we have completed the
 *      first stage of the call back sequence, "NO CARRIER" is a valid, non
 *      fatal string. As soon as we got called back (probably get "CONNECT"),
 *      we should re-arm the ABORT "NO CARRIER". Hence the CLR_ABORT command.
 *      Note that CLR_ABORT packs the abort_strings[] array so that we do not
 *      have unused entries not being reclaimed.
 *
 *      In the same vein as above, added CLR_REPORT keyword.
 *
 *      Allow for comments. Line starting with '#' are comments and are
 *      ignored. If a '#' is to be expected as the first character, the 
 *      expect string must be quoted.
 *
 *
 *		Francis Demierre <Francis@@SwissMail.Com>
 * 		Thu May 15 17:15:40 MET DST 1997
 *
 *
 *      Added -r "report file" switch & REPORT keyword.
 *              Robert Geer <bgeer@@xmission.com>
 *
 *      Added -s "use stderr" and -S "don't use syslog" switches.
 *              June 18, 1997
 *              Karl O. Pinc <kop@@meme.com>
 *
 *
 *	Added -e "echo" switch & ECHO keyword
 *		Dick Streefland <dicks@@tasking.nl>
 *
 *
 *	Considerable updates and modifications by
 *		Al Longyear <longyear@@pobox.com>
 *		Paul Mackerras <paulus@@cs.anu.edu.au>
 *
 *
 *	The original author is:
 *
 *		Karl Fox <karl@@MorningStar.Com>
 *		Morning Star Technologies, Inc.
 *		1760 Zollinger Road
 *		Columbus, OH  43221
 *		(614)451-1883
 *
 *
 */

#include <stdio.h>
#include <ctype.h>
#include <time.h>
#include <fcntl.h>
#include <signal.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <syslog.h>
#include <stdarg.h>

#ifndef TERMIO
#undef	TERMIOS
#define TERMIOS
#endif

#ifdef TERMIO
#include <termio.h>
#endif
#ifdef TERMIOS
#include <termios.h>
#endif

#define	STR_LEN	1024

#ifndef SIGTYPE
#define SIGTYPE void
#endif

#ifndef O_NONBLOCK
#define O_NONBLOCK	O_NDELAY
#endif

#ifdef SUNOS
extern int sys_nerr;
extern char *sys_errlist[];
#define memmove(to, from, n)	bcopy(from, to, n)
#define strerror(n)		((unsigned)(n) < sys_nerr? sys_errlist[(n)] :\
				 "unknown error")
#endif

#define	MAX_ABORTS		50
#define	MAX_REPORTS		50
#define	DEFAULT_CHAT_TIMEOUT	45

int echo          = 0;
int verbose       = 0;
int to_log        = 1;
int to_stderr     = 0;
int Verbose       = 0;
int quiet         = 0;
int report        = 0;
int exit_code     = 0;
FILE* report_fp   = (FILE *) 0;
char *report_file = (char *) 0;
char *chat_file   = (char *) 0;
char *phone_num   = (char *) 0;
char *phone_num2  = (char *) 0;
int timeout       = DEFAULT_CHAT_TIMEOUT;

int have_tty_parameters = 0;

extern char *__progname;

#ifdef TERMIO
#define term_parms struct termio
#define get_term_param(param) ioctl(0, TCGETA, param)
#define set_term_param(param) ioctl(0, TCSETA, param)
struct termio saved_tty_parameters;
#endif

#ifdef TERMIOS
#define term_parms struct termios
#define get_term_param(param) tcgetattr(0, param)
#define set_term_param(param) tcsetattr(0, TCSANOW, param)
struct termios saved_tty_parameters;
#endif

char *abort_string[MAX_ABORTS], *fail_reason = NULL,
	fail_buffer[50];
int n_aborts = 0, abort_next = 0, timeout_next = 0, echo_next = 0;
int clear_abort_next = 0;

char *report_string[MAX_REPORTS] ;
char  report_buffer[50] ;
int n_reports = 0, report_next = 0, report_gathering = 0 ; 
int clear_report_next = 0;

int say_next = 0, hup_next = 0;

void *dup_mem(void *b, size_t c);
void *copy_of(char *s);
void usage(void);
void logmsg(const char *fmt, ...);
void fatal(int code, const char *fmt, ...);
SIGTYPE sigalrm(int signo);
SIGTYPE sigint(int signo);
SIGTYPE sigterm(int signo);
SIGTYPE sighup(int signo);
void unalarm(void);
void init(void);
void set_tty_parameters(void);
void echo_stderr(int);
void break_sequence(void);
void terminate(int status);
void do_file(char *chat_file);
int  get_string(register char *string);
int  put_string(register char *s);
int  write_char(int c);
int  put_char(int c);
int  get_char(void);
void chat_send(register char *s);
char *character(int c);
void chat_expect(register char *s);
char *clean(register char *s, int sending);
void break_sequence(void);
void terminate(int status);
void pack_array(char **array, int end);
char *expect_strtok(char *, char *);
int vfmtmsg(char *, int, const char *, va_list);	/* vsnprintf++ */

int main(int, char *[]);

void *dup_mem(b, c)
void *b;
size_t c;
{
    void *ans = malloc (c);
    if (!ans)
	fatal(2, "memory error!");

    memcpy (ans, b, c);
    return ans;
}

void *copy_of (s)
char *s;
{
    return dup_mem (s, strlen (s) + 1);
}

/*
 * chat [ -v ] [-T number] [-U number] [ -t timeout ] [ -f chat-file ] \
 * [ -r report-file ] \
 *		[...[[expect[-say[-expect...]] say expect[-say[-expect]] ...]]]
 *
 *	Perform a UUCP-dialer-like chat script on stdin and stdout.
 */
int
main(argc, argv)
     int argc;
     char **argv;
{
    int option;

    tzset();

    while ((option = getopt(argc, argv, "esSvVt:r:f:T:U:")) != -1) {
	switch (option) {
	case 'e':
	    echo = 1;
	    break;

	case 'v':
	    verbose = 1;
	    break;

	case 'V':
	    Verbose = 1;
	    break;

	case 's':
	    to_stderr = 1;
	    break;

	case 'S':
	    to_log = 0;
	    break;

	case 'f':
	    chat_file = copy_of(optarg);
	    break;

	case 't':
	    timeout = atoi(optarg);
	    break;

	case 'r':
	    if (report_fp != NULL)
		fclose (report_fp);
	    report_file = copy_of (optarg);
	    report_fp   = fopen (report_file, "a");
	    if (report_fp != NULL) {
		if (verbose)
		    fprintf (report_fp, "Opening \"%s\"...\n",
			     report_file);
		report = 1;
	    }
	    break;

	case 'T':
	    phone_num = copy_of(optarg);
	    break;

	case 'U':
	    phone_num2 = copy_of(optarg);
	    break;

	case ':':
	    fprintf(stderr, "Option -%c requires an argument\n",
		optopt);

	default:
	    usage();
	    break;
	}
    }
    argc -= optind;
    argv += optind;
/*
 * Default the report file to the stderr location
 */
    if (report_fp == NULL)
	report_fp = stderr;

    if (to_log) {
#ifdef ultrix
	openlog("chat", LOG_PID);
#else
	openlog("chat", LOG_PID | LOG_NDELAY, LOG_LOCAL2);

	if (verbose)
	    setlogmask(LOG_UPTO(LOG_INFO));
	else
	    setlogmask(LOG_UPTO(LOG_WARNING));
#endif
    }

    init();
    
    if (chat_file != NULL) {
	if (argc > 0)
	    usage();
	else
	    do_file (chat_file);
    } else {
	while (argc-- > 0) {
	    chat_expect(*argv++);

	    if (argc-- > 0) {
		chat_send(*argv++);
	    }
	}
    }

    terminate(0);
    return 0;
}

/*
 *  Process a chat script when read from a file.
 */

void do_file (chat_file)
char *chat_file;
{
    int linect, sendflg;
    char *sp, *arg, quote;
    char buf [STR_LEN];
    FILE *cfp;

    cfp = fopen (chat_file, "r");
    if (cfp == NULL)
	fatal(1, "%s -- open failed: %m", chat_file);

    linect = 0;
    sendflg = 0;

    while (fgets(buf, STR_LEN, cfp) != NULL) {
	buf[strcspn(buf, "\n")] = '\0';

	linect++;
	sp = buf;

        /* lines starting with '#' are comments. If a real '#'
           is to be expected, it should be quoted .... */
        if ( *sp == '#' )
	    continue;

	while (*sp != '\0') {
	    if (*sp == ' ' || *sp == '\t') {
		++sp;
		continue;
	    }

	    if (*sp == '"' || *sp == '\'') {
		quote = *sp++;
		arg = sp;
		while (*sp != quote) {
		    if (*sp == '\0')
			fatal(1, "unterminated quote (line %d)", linect);

		    if (*sp++ == '\\') {
			if (*sp != '\0')
			    ++sp;
		    }
		}
	    }
	    else {
		arg = sp;
		while (*sp != '\0' && *sp != ' ' && *sp != '\t')
		    ++sp;
	    }

	    if (*sp != '\0')
		*sp++ = '\0';

	    if (sendflg)
		chat_send (arg);
	    else
		chat_expect (arg);
	    sendflg = !sendflg;
	}
    }
    fclose (cfp);
}

/*
 *	We got an error parsing the command line.
 */
void usage()
{
    fprintf(stderr, "\
usage: %s [-eSsVv] [-f chat_file] [-r report_file] [-T phone_number]\n\
            [-t timeout] [-U phone_number_2] script\n",
     __progname);
    exit(1);
}

char line[1024];

/*
 * Send a message to syslog and/or stderr.
 */
void logmsg(const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    vfmtmsg(line, sizeof(line), fmt, args);
    va_end(args);
    if (to_log)
	syslog(LOG_INFO, "%s", line);
    if (to_stderr)
	fprintf(stderr, "%s\n", line);
}

/*
 *	Print an error message and terminate.
 */

void fatal(int code, const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    vfmtmsg(line, sizeof(line), fmt, args);
    va_end(args);
    if (to_log)
	syslog(LOG_ERR, "%s", line);
    if (to_stderr)
	fprintf(stderr, "%s\n", line);
    terminate(code);
}

int alarmed = 0;

SIGTYPE sigalrm(signo)
int signo;
{
    int flags;

    alarm(1);
    alarmed = 1;		/* Reset alarm to avoid race window */
    signal(SIGALRM, sigalrm);	/* that can cause hanging in read() */

    if ((flags = fcntl(0, F_GETFL)) == -1)
	fatal(2, "Can't get file mode flags on stdin: %m");

    if (fcntl(0, F_SETFL, flags | O_NONBLOCK) == -1)
	fatal(2, "Can't set file mode flags on stdin: %m");

    if (verbose)
	logmsg("alarm");
}

void unalarm()
{
    int flags;

    if ((flags = fcntl(0, F_GETFL)) == -1)
	fatal(2, "Can't get file mode flags on stdin: %m");

    if (fcntl(0, F_SETFL, flags & ~O_NONBLOCK) == -1)
	fatal(2, "Can't set file mode flags on stdin: %m");
}

SIGTYPE sigint(signo)
int signo;
{
    fatal(2, "SIGINT");
}

SIGTYPE sigterm(signo)
int signo;
{
    fatal(2, "SIGTERM");
}

SIGTYPE sighup(signo)
int signo;
{
    fatal(2, "SIGHUP");
}

void init()
{
    signal(SIGINT, sigint);
    signal(SIGTERM, sigterm);
    signal(SIGHUP, sighup);

    set_tty_parameters();
    signal(SIGALRM, sigalrm);
    alarm(0);
    alarmed = 0;
}

void set_tty_parameters()
{
#if defined(get_term_param)
    term_parms t;

    if (get_term_param (&t) < 0)
	fatal(2, "Can't get terminal parameters: %m");

    saved_tty_parameters = t;
    have_tty_parameters  = 1;

    t.c_iflag     |= IGNBRK | ISTRIP | IGNPAR;
    t.c_oflag      = 0;
    t.c_lflag      = 0;
    t.c_cc[VERASE] =
    t.c_cc[VKILL]  = 0;
    t.c_cc[VMIN]   = 1;
    t.c_cc[VTIME]  = 0;

    if (set_term_param (&t) < 0)
	fatal(2, "Can't set terminal parameters: %m");
#endif
}

void break_sequence()
{
#ifdef TERMIOS
    tcsendbreak (0, 0);
#endif
}

void terminate(status)
int status;
{
    echo_stderr(-1);
    if (report_file != (char *) 0 && report_fp != (FILE *) NULL) {
/*
 * Allow the last of the report string to be gathered before we terminate.
 */
	if (report_gathering) {
	    int c, rep_len;

	    rep_len = strlen(report_buffer);
	    while (rep_len + 1 <= sizeof(report_buffer)) {
		alarm(1);
		c = get_char();
		alarm(0);
		if (c < 0 || iscntrl(c))
		    break;
		report_buffer[rep_len] = c;
		++rep_len;
	    }
	    report_buffer[rep_len] = 0;
	    fprintf (report_fp, "chat:  %s\n", report_buffer);
	}
	if (verbose)
	    fprintf (report_fp, "Closing \"%s\".\n", report_file);
	fclose (report_fp);
	report_fp = (FILE *) NULL;
    }

#if defined(get_term_param)
    if (have_tty_parameters) {
	if (set_term_param (&saved_tty_parameters) < 0)
	    fatal(2, "Can't restore terminal parameters: %m");
    }
#endif

    exit(status);
}

/*
 *	'Clean up' this string.
 */
char *clean(s, sending)
register char *s;
int sending;  /* set to 1 when sending (putting) this string. */
{
    char *ret, *t, cur_chr;
    int new_length;
    register char *s1, *phchar;
    int add_return = sending;
#define isoctal(chr) (((chr) >= '0') && ((chr) <= '7'))

    /* Overestimate new length: */
    new_length = 0;
    for (t = s; *t; t++)
	if (*t == '^' && *(t+1) != '\0') {
	    t++;
	    new_length++;
	} else if (*t != '\\') {
	    new_length++;
	} else {
	    t++;
	    switch (*t) {
	    case 'c':
	    case 'b':
	    case 'r':
	    case 'n':
	    case 's':
	    case 't':
		new_length++;
		break;
	    case 'K':
	    case 'p':
	    case 'd':
	    case '\0':
	    case '\\':
	    case 'N':
		new_length += 2;
		break;
	    case 'T':
		new_length += sending && phone_num ? strlen(phone_num) : 2;
		break;
	    case 'U':
		new_length += sending && phone_num2 ? strlen(phone_num2) : 2;
		break;
	    default:
		if (isoctal(*t)) {
		    t++;
		    if (isoctal(*t)) {
			t++;
			if (isoctal(*t)) 
			    t++;
		    }
		}
		t--;
		new_length += 2;	/* Could become \\ */
	    }
	    if (*t == '\0')
		break;
	}

    new_length += 3;	/* \r and two nuls */

    ret = malloc(new_length);
    if (ret == NULL)
	    fatal(2, "cannot allocate memory");

    s1 = ret;
    while (*s) {
	cur_chr = *s++;
	if (cur_chr == '^') {
	    cur_chr = *s++;
	    if (cur_chr == '\0') {
		*s1++ = '^';
		break;
	    }
	    cur_chr &= 0x1F;
	    if (cur_chr != 0) {
		*s1++ = cur_chr;
	    }
	    continue;
	}

	if (cur_chr != '\\') {
	    *s1++ = cur_chr;
	    continue;
	}

	cur_chr = *s++;
	if (cur_chr == '\0') {
	    if (sending) {
		*s1++ = '\\';
		*s1++ = '\\';
	    }
	    break;
	}

	switch (cur_chr) {
	case 'b':
	    *s1++ = '\b';
	    break;

	case 'c':
	    if (sending && *s == '\0')
		add_return = 0;
	    else
		*s1++ = cur_chr;
	    break;

	case '\\':
	case 'K':
	case 'p':
	case 'd':
	    if (sending)
		*s1++ = '\\';

	    *s1++ = cur_chr;
	    break;

	case 'T':
	    if (sending && phone_num) {
		for ( phchar = phone_num; *phchar != '\0'; phchar++) 
		    *s1++ = *phchar;
	    }
	    else {
		*s1++ = '\\';
		*s1++ = 'T';
	    }
	    break;

	case 'U':
	    if (sending && phone_num2) {
		for ( phchar = phone_num2; *phchar != '\0'; phchar++) 
		    *s1++ = *phchar;
	    }
	    else {
		*s1++ = '\\';
		*s1++ = 'U';
	    }
	    break;

	case 'q':
	    quiet = 1;
	    break;

	case 'r':
	    *s1++ = '\r';
	    break;

	case 'n':
	    *s1++ = '\n';
	    break;

	case 's':
	    *s1++ = ' ';
	    break;

	case 't':
	    *s1++ = '\t';
	    break;

	case 'N':
	    if (sending) {
		*s1++ = '\\';
		*s1++ = '\0';
	    }
	    else
		*s1++ = 'N';
	    break;
	    
	default:
	    if (isoctal (cur_chr)) {
		cur_chr &= 0x07;
		if (isoctal (*s)) {
		    cur_chr <<= 3;
		    cur_chr |= *s++ - '0';
		    if (isoctal (*s)) {
			cur_chr <<= 3;
			cur_chr |= *s++ - '0';
		    }
		}

		if (cur_chr != 0 || sending) {
		    if (sending && (cur_chr == '\\' || cur_chr == 0))
			*s1++ = '\\';
		    *s1++ = cur_chr;
		}
		break;
	    }

	    if (sending)
		*s1++ = '\\';
	    *s1++ = cur_chr;
	    break;
	}
    }

    if (add_return)
	*s1++ = '\r';

    *s1++ = '\0'; /* guarantee closure */
    *s1++ = '\0'; /* terminate the string */

#ifdef DEBUG
    fprintf(stderr, "clean(): guessed %d and used %d\n", new_length, s1-ret);
#endif
    if (new_length < s1 - ret)
	logmsg("clean(): new_length too short! %d < %d: \"%s\" -> \"%s\"", 
	       new_length, s1 - ret, s, ret);

    return ret;
}

/*
 * A modified version of 'strtok'. This version skips \ sequences.
 */

char *expect_strtok (s, term)
     char *s, *term;
{
    static  char *str   = "";
    int	    escape_flag = 0;
    char   *result;

/*
 * If a string was specified then do initial processing.
 */
    if (s)
	str = s;

/*
 * If this is the escape flag then reset it and ignore the character.
 */
    if (*str)
	result = str;
    else
	result = (char *) 0;

    while (*str) {
	if (escape_flag) {
	    escape_flag = 0;
	    ++str;
	    continue;
	}

	if (*str == '\\') {
	    ++str;
	    escape_flag = 1;
	    continue;
	}

/*
 * If this is not in the termination string, continue.
 */
	if (strchr (term, *str) == (char *) 0) {
	    ++str;
	    continue;
	}

/*
 * This is the terminator. Mark the end of the string and stop.
 */
	*str++ = '\0';
	break;
    }
    return (result);
}

/*
 * Process the expect string
 */

void chat_expect (s)
char *s;
{
    char *expect;
    char *reply;

    if (strcmp(s, "HANGUP") == 0) {
	++hup_next;
        return;
    }
 
    if (strcmp(s, "ABORT") == 0) {
	++abort_next;
	return;
    }

    if (strcmp(s, "CLR_ABORT") == 0) {
	++clear_abort_next;
	return;
    }

    if (strcmp(s, "REPORT") == 0) {
	++report_next;
	return;
    }

    if (strcmp(s, "CLR_REPORT") == 0) {
	++clear_report_next;
	return;
    }

    if (strcmp(s, "TIMEOUT") == 0) {
	++timeout_next;
	return;
    }

    if (strcmp(s, "ECHO") == 0) {
	++echo_next;
	return;
    }

    if (strcmp(s, "SAY") == 0) {
	++say_next;
	return;
    }

/*
 * Fetch the expect and reply string.
 */
    for (;;) {
	expect = expect_strtok (s, "-");
	s      = (char *) 0;

	if (expect == (char *) 0)
	    return;

	reply = expect_strtok (s, "-");

/*
 * Handle the expect string. If successful then exit.
 */
	if (get_string (expect))
	    return;

/*
 * If there is a sub-reply string then send it. Otherwise any condition
 * is terminal.
 */
	if (reply == (char *) 0 || exit_code != 3)
	    break;

	chat_send (reply);
    }

/*
 * The expectation did not occur. This is terminal.
 */
    if (fail_reason)
	logmsg("Failed (%s)", fail_reason);
    else
	logmsg("Failed");
    terminate(exit_code);
}

/*
 * Translate the input character to the appropriate string for printing
 * the data.
 */

char *character(c)
int c;
{
    static char string[10];
    char *meta;

    meta = (c & 0x80) ? "M-" : "";
    c &= 0x7F;

    if (c < 32)
	snprintf(string, sizeof string, "%s^%c", meta, (int)c + '@@');
    else if (c == 127)
	snprintf(string, sizeof string, "%s^?", meta);
    else
	snprintf(string, sizeof string, "%s%c", meta, c);

    return (string);
}

/*
 *  process the reply string
 */
void chat_send (s)
register char *s;
{
    if (say_next) {
	say_next = 0;
	s = clean(s,0);
	write(STDERR_FILENO, s, strlen(s));
        free(s);
	return;
    }

    if (hup_next) {
        hup_next = 0;
	if (strcmp(s, "OFF") == 0)
           signal(SIGHUP, SIG_IGN);
        else
           signal(SIGHUP, sighup);
        return;
    }

    if (echo_next) {
	echo_next = 0;
	echo = (strcmp(s, "ON") == 0);
	return;
    }

    if (abort_next) {
	char *s1;
	
	abort_next = 0;
	
	if (n_aborts >= MAX_ABORTS)
	    fatal(2, "Too many ABORT strings");
	
	s1 = clean(s, 0);
	
	if (strlen(s1) > strlen(s)
	    || strlen(s1) + 1 > sizeof(fail_buffer))
	    fatal(1, "Illegal or too-long ABORT string ('%v')", s);

	abort_string[n_aborts++] = s1;

	if (verbose)
	    logmsg("abort on (%v)", s);
	return;
    }

    if (clear_abort_next) {
	char *s1;
	int   i;
        int   old_max;
	int   pack = 0;
	
	clear_abort_next = 0;
	
	s1 = clean(s, 0);
	
	if (strlen(s1) > strlen(s)
	    || strlen(s1) + 1 > sizeof(fail_buffer))
	    fatal(1, "Illegal or too-long CLR_ABORT string ('%v')", s);

        old_max = n_aborts;
	for (i=0; i < n_aborts; i++) {
	    if ( strcmp(s1,abort_string[i]) == 0 ) {
		free(abort_string[i]);
		abort_string[i] = NULL;
		pack++;
		n_aborts--;
		if (verbose)
		    logmsg("clear abort on (%v)", s);
	    }
	}
        free(s1);
	if (pack)
	    pack_array(abort_string,old_max);
	return;
    }

    if (report_next) {
	char *s1;
	
	report_next = 0;
	if (n_reports >= MAX_REPORTS)
	    fatal(2, "Too many REPORT strings");
	
	s1 = clean(s, 0);
	
	if (strlen(s1) > strlen(s) || strlen(s1) > sizeof fail_buffer - 1)
	    fatal(1, "Illegal or too-long REPORT string ('%v')", s);
	
	report_string[n_reports++] = s1;
	
	if (verbose)
	    logmsg("report (%v)", s);
	return;
    }

    if (clear_report_next) {
	char *s1;
	int   i;
	int   old_max;
	int   pack = 0;
	
	clear_report_next = 0;
	
	s1 = clean(s, 0);
	
	if (strlen(s1) > strlen(s) || strlen(s1) > sizeof fail_buffer - 1)
	    fatal(1, "Illegal or too-long REPORT string ('%v')", s);

	old_max = n_reports;
	for (i=0; i < n_reports; i++) {
	    if ( strcmp(s1,report_string[i]) == 0 ) {
		free(report_string[i]);
		report_string[i] = NULL;
		pack++;
		n_reports--;
		if (verbose)
		    logmsg("clear report (%v)", s);
	    }
	}
        free(s1);
        if (pack)
	    pack_array(report_string,old_max);
	
	return;
    }

    if (timeout_next) {
	timeout_next = 0;
	timeout = atoi(s);
	
	if (timeout <= 0)
	    timeout = DEFAULT_CHAT_TIMEOUT;

	if (verbose)
	    logmsg("timeout set to %d seconds", timeout);

	return;
    }

    if (strcmp(s, "EOT") == 0)
	s = "^D\\c";
    else if (strcmp(s, "BREAK") == 0)
	s = "\\K\\c";

    if (!put_string(s))
	fatal(1, "Failed");
}

int get_char()
{
    int status;
    char c;

    status = read(0, &c, 1);

    switch (status) {
    case 1:
	return ((int)c & 0x7F);

    default:
	logmsg("warning: read() on stdin returned %d", status);

    case -1:
	if ((status = fcntl(0, F_GETFL)) == -1)
	    fatal(2, "Can't get file mode flags on stdin: %m");

	if (fcntl(0, F_SETFL, status & ~O_NONBLOCK) == -1)
	    fatal(2, "Can't set file mode flags on stdin: %m");
	
	return (-1);
    }
}

int put_char(c)
int c;
{
    int status;
    char ch = c;

    usleep(10000);		/* inter-character typing delay (?) */

    status = write(STDOUT_FILENO, &ch, 1);

    switch (status) {
    case 1:
	return (0);
	
    default:
	logmsg("warning: write() on stdout returned %d", status);
	
    case -1:
	if ((status = fcntl(0, F_GETFL)) == -1)
	    fatal(2, "Can't get file mode flags on stdin, %m");

	if (fcntl(0, F_SETFL, status & ~O_NONBLOCK) == -1)
	    fatal(2, "Can't set file mode flags on stdin: %m");
	
	return (-1);
    }
}

int write_char (c)
int c;
{
    if (alarmed || put_char(c) < 0) {
	alarm(0);
	alarmed = 0;

	if (verbose) {
	    if (errno == EINTR || errno == EWOULDBLOCK)
		logmsg(" -- write timed out");
	    else
		logmsg(" -- write failed: %m");
	}
	return (0);
    }
    return (1);
}

int put_string (s)
register char *s;
{
    quiet = 0;
    s = clean(s, 1);

    if (verbose) {
	if (quiet)
	    logmsg("send (hidden)");
	else
	    logmsg("send (%v)", s);
    }

    alarm(timeout); alarmed = 0;

    while (*s) {
	register char c = *s++;

	if (c != '\\') {
	    if (!write_char (c))
		return 0;
	    continue;
	}

	c = *s++;
	switch (c) {
	case 'd':
	    sleep(1);
	    break;

	case 'K':
	    break_sequence();
	    break;

	case 'p':
	    usleep(10000); 	/* 1/100th of a second (arg is microseconds) */
	    break;

	default:
	    if (!write_char (c))
		return 0;
	    break;
	}
    }

    alarm(0);
    alarmed = 0;
    return (1);
}

/*
 *	Echo a character to stderr.
 *	When called with -1, a '\n' character is generated when
 *	the cursor is not at the beginning of a line.
 */
void echo_stderr(n)
int n;
{
    static int need_lf;
    char *s;

    switch (n) {
    case '\r':		/* ignore '\r' */
	break;
    case -1:
	if (need_lf == 0)
	    break;
	/* fall through */
    case '\n':
	write(STDERR_FILENO, "\n", 1);
	need_lf = 0;
	break;
    default:
	s = character(n);
	write(STDERR_FILENO, s, strlen(s));
	need_lf = 1;
	break;
    }
}

/*
 *	'Wait for' this string to appear on this file descriptor.
 */
int get_string(string)
register char *string;
{
    char temp[STR_LEN];
    int c, printed = 0, len, minlen;
    register char *s = temp, *end = s + STR_LEN;
    char *logged = temp;

    fail_reason = NULL;
    string = clean(string, 0);
    len = strlen(string);
    minlen = (len > sizeof(fail_buffer)? len: sizeof(fail_buffer)) - 1;

    if (verbose)
	logmsg("expect (%v)", string);

    if (len > STR_LEN) {
	logmsg("expect string is too long");
	exit_code = 1;
	return 0;
    }

    if (len == 0) {
	if (verbose)
	    logmsg("got it");
	return (1);
    }

    alarm(timeout);
    alarmed = 0;

    while ( ! alarmed && (c = get_char()) >= 0) {
	int n, abort_len, report_len;

	if (echo)
	    echo_stderr(c);
	if (verbose && c == '\n') {
	    if (s == logged)
		logmsg("");	/* blank line */
	    else
		logmsg("%0.*v", s - logged, logged);
	    logged = s + 1;
	}

	*s++ = c;

	if (verbose && s >= logged + 80) {
	    logmsg("%0.*v", s - logged, logged);
	    logged = s;
	}

	if (Verbose) {
	   if (c == '\n')
	       fputc( '\n', stderr );
	   else if (c != '\r')
	       fprintf( stderr, "%s", character(c) );
	}

	if (!report_gathering) {
	    for (n = 0; n < n_reports; ++n) {
		if ((report_string[n] != (char*) NULL) &&
		    s - temp >= (report_len = strlen(report_string[n])) &&
		    strncmp(s - report_len, report_string[n], report_len) == 0) {
		    time_t time_now   = time (NULL);
		    struct tm* tm_now = localtime (&time_now);

		    strftime (report_buffer, 20, "%b %d %H:%M:%S ", tm_now);
		    strlcat (report_buffer, report_string[n], sizeof(report_buffer));

		    report_string[n] = (char *) NULL;
		    report_gathering = 1;
		    break;
		}
	    }
	}
	else {
	    if (!iscntrl (c)) {
		int rep_len = strlen (report_buffer);
		report_buffer[rep_len]     = c;
		report_buffer[rep_len + 1] = '\0';
	    }
	    else {
		report_gathering = 0;
		fprintf (report_fp, "chat:  %s\n", report_buffer);
	    }
	}

	if (s - temp >= len &&
	    c == string[len - 1] &&
	    strncmp(s - len, string, len) == 0) {
	    if (verbose) {
		if (s > logged)
		    logmsg("%0.*v", s - logged, logged);
		logmsg(" -- got it\n");
	    }

	    alarm(0);
	    alarmed = 0;
	    return (1);
	}

	for (n = 0; n < n_aborts; ++n) {
	    if (s - temp >= (abort_len = strlen(abort_string[n])) &&
		strncmp(s - abort_len, abort_string[n], abort_len) == 0) {
		if (verbose) {
		    if (s > logged)
			logmsg("%0.*v", s - logged, logged);
		    logmsg(" -- failed");
		}

		alarm(0);
		alarmed = 0;
		exit_code = n + 4;
		strlcpy(fail_buffer, abort_string[n], sizeof fail_buffer);
		fail_reason = fail_buffer;
		return (0);
	    }
	}

	if (s >= end) {
	    if (logged < s - minlen) {
		logmsg("%0.*v", s - logged, logged);
		logged = s;
	    }
	    s -= minlen;
	    memmove(temp, s, minlen);
	    logged = temp + (logged - s);
	    s = temp + minlen;
	}

	if (alarmed && verbose)
	    logmsg("warning: alarm synchronization problem");
    }

    alarm(0);
    
    if (verbose && printed) {
	if (alarmed)
	    logmsg(" -- read timed out");
	else
	    logmsg(" -- read failed: %m");
    }

    exit_code = 3;
    alarmed   = 0;
    return (0);
}

void
pack_array (array, end)
    char **array; /* The address of the array of string pointers */
    int    end;   /* The index of the next free entry before CLR_ */
{
    int i, j;

    for (i = 0; i < end; i++) {
	if (array[i] == NULL) {
	    for (j = i+1; j < end; ++j)
		if (array[j] != NULL)
		    array[i++] = array[j];
	    for (; i < end; ++i)
		array[i] = NULL;
	    break;
	}
    }
}

/*
 * vfmtmsg - format a message into a buffer.  Like vsnprintf except we
 * also specify the length of the output buffer, and we handle the
 * %m (error message) format.
 * Doesn't do floating-point formats.
 * Returns the number of chars put into buf.
 */
#define OUTCHAR(c)	(buflen > 0? (--buflen, *buf++ = (c)): 0)

int
vfmtmsg(buf, buflen, fmt, args)
    char *buf;
    int buflen;
    const char *fmt;
    va_list args;
{
    int c, i, n;
    int width, prec, fillch;
    int base, len, neg, quoted;
    unsigned long val = 0;
    char *str, *buf0;
    const char *f;
    unsigned char *p;
    char num[32];
    static char hexchars[] = "0123456789abcdef";

    buf0 = buf;
    --buflen;
    while (buflen > 0) {
	for (f = fmt; *f != '%' && *f != 0; ++f)
	    ;
	if (f > fmt) {
	    len = f - fmt;
	    if (len > buflen)
		len = buflen;
	    memcpy(buf, fmt, len);
	    buf += len;
	    buflen -= len;
	    fmt = f;
	}
	if (*fmt == 0)
	    break;
	c = *++fmt;
	width = prec = 0;
	fillch = ' ';
	if (c == '0') {
	    fillch = '0';
	    c = *++fmt;
	}
	if (c == '*') {
	    width = va_arg(args, int);
	    c = *++fmt;
	} else {
	    while (isdigit(c)) {
		width = width * 10 + c - '0';
		c = *++fmt;
	    }
	}
	if (c == '.') {
	    c = *++fmt;
	    if (c == '*') {
		prec = va_arg(args, int);
		c = *++fmt;
	    } else {
		while (isdigit(c)) {
		    prec = prec * 10 + c - '0';
		    c = *++fmt;
		}
	    }
	}
	str = 0;
	base = 0;
	neg = 0;
	++fmt;
	switch (c) {
	case 'd':
	    i = va_arg(args, int);
	    if (i < 0) {
		neg = 1;
		val = -i;
	    } else
		val = i;
	    base = 10;
	    break;
	case 'o':
	    val = va_arg(args, unsigned int);
	    base = 8;
	    break;
	case 'x':
	    val = va_arg(args, unsigned int);
	    base = 16;
	    break;
	case 'p':
	    val = (unsigned long) va_arg(args, void *);
	    base = 16;
	    neg = 2;
	    break;
	case 's':
	    str = va_arg(args, char *);
	    break;
	case 'c':
	    num[0] = va_arg(args, int);
	    num[1] = 0;
	    str = num;
	    break;
	case 'm':
	    str = strerror(errno);
	    break;
	case 'v':		/* "visible" string */
	case 'q':		/* quoted string */
	    quoted = c == 'q';
	    p = va_arg(args, unsigned char *);
	    if (fillch == '0' && prec > 0) {
		n = prec;
	    } else {
		n = strlen((char *)p);
		if (prec > 0 && prec < n)
		    n = prec;
	    }
	    while (n > 0 && buflen > 0) {
		c = *p++;
		--n;
		if (!quoted && c >= 0x80) {
		    OUTCHAR('M');
		    OUTCHAR('-');
		    c -= 0x80;
		}
		if (quoted && (c == '"' || c == '\\'))
		    OUTCHAR('\\');
		if (c < 0x20 || (0x7f <= c && c < 0xa0)) {
		    if (quoted) {
			OUTCHAR('\\');
			switch (c) {
			case '\t':	OUTCHAR('t');	break;
			case '\n':	OUTCHAR('n');	break;
			case '\b':	OUTCHAR('b');	break;
			case '\f':	OUTCHAR('f');	break;
			default:
			    OUTCHAR('x');
			    OUTCHAR(hexchars[c >> 4]);
			    OUTCHAR(hexchars[c & 0xf]);
			}
		    } else {
			if (c == '\t')
			    OUTCHAR(c);
			else {
			    OUTCHAR('^');
			    OUTCHAR(c ^ 0x40);
			}
		    }
		} else
		    OUTCHAR(c);
	    }
	    continue;
	default:
	    *buf++ = '%';
	    if (c != '%')
		--fmt;		/* so %z outputs %z etc. */
	    --buflen;
	    continue;
	}
	if (base != 0) {
	    str = num + sizeof(num);
	    *--str = 0;
	    while (str > num + neg) {
		*--str = hexchars[val % base];
		val = val / base;
		if (--prec <= 0 && val == 0)
		    break;
	    }
	    switch (neg) {
	    case 1:
		*--str = '-';
		break;
	    case 2:
		*--str = 'x';
		*--str = '0';
		break;
	    }
	    len = num + sizeof(num) - 1 - str;
	} else {
	    len = strlen(str);
	    if (prec > 0 && len > prec)
		len = prec;
	}
	if (width > 0) {
	    if (width > buflen)
		width = buflen;
	    if ((n = width - len) > 0) {
		buflen -= n;
		for (; n > 0; --n)
		    *buf++ = fillch;
	    }
	}
	if (len > buflen)
	    len = buflen;
	memcpy(buf, str, len);
	buf += len;
	buflen -= len;
    }
    *buf = 0;
    return buf - buf0;
}
@


1.34
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.33 2016/01/25 21:24:17 gsoares Exp $	*/
d471 1
a471 1
    if ((flags = fcntl(0, F_GETFL, 0)) == -1)
d485 1
a485 1
    if ((flags = fcntl(0, F_GETFL, 0)) == -1)
d1142 1
a1142 1
	if ((status = fcntl(0, F_GETFL, 0)) == -1)
d1170 1
a1170 1
	if ((status = fcntl(0, F_GETFL, 0)) == -1)
@


1.33
log
@(hidden) is more readable than (??????) and avoid trigraph

suggested by & OK claudio@@
OK daniel@@ jsg@@

initial review millert@@ and tb@@ thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.32 2015/08/20 22:46:32 deraadt Exp $	*/
d163 1
a163 1
char *abort_string[MAX_ABORTS], *fail_reason = (char *)0,
d1289 1
a1289 1
    fail_reason = (char *)0;
@


1.32
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.31 2015/02/09 23:00:14 deraadt Exp $	*/
d1206 1
a1206 1
	    logmsg("send (??????)");
@


1.31
log
@clean up flags++ instances around getopt()
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.30 2013/04/21 17:50:29 tedu Exp $	*/
d657 1
a657 1
    ret = (char *)malloc(new_length);
@


1.30
log
@delete (uncompiled) hacked usleep function.
young minds should not be exposed to such code.
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.29 2013/04/20 20:32:37 deraadt Exp $	*/
d245 1
a245 1
	    ++echo;
d249 1
a249 1
	    ++verbose;
d253 1
a253 1
	    ++Verbose;
d257 1
a257 1
	    ++to_stderr;
@


1.29
log
@casts of (time_t *) lead to bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.28 2010/08/12 02:00:28 kevlo Exp $	*/
a1427 37

/*
 * Gross kludge to handle Solaris versions >= 2.6 having usleep.
 */
#ifdef SOL2
#include <sys/param.h>
#if MAXUID > 65536		/* then this is Solaris 2.6 or later */
#undef NO_USLEEP
#endif
#endif /* SOL2 */

#ifdef NO_USLEEP
#include <sys/types.h>
#include <sys/time.h>

/*
  usleep -- support routine for 4.2BSD system call emulations
  last edit:  29-Oct-1984     D A Gwyn
  */

extern int	  select();

int
usleep( usec )				  /* returns 0 if ok, else -1 */
    long		usec;		/* delay in microseconds */
{
    static struct {		/* `timeval' */
	long	tv_sec;		/* seconds */
	long	tv_usec;	/* microsecs */
    } delay;	    		/* _select() timeout */

    delay.tv_sec  = usec / 1000000L;
    delay.tv_usec = usec % 1000000L;

    return select(0, (long *)0, (long *)0, (long *)0, &delay);
}
#endif
@


1.28
log
@Use symbolic names for the file descriptors rather than numeric values.
Some from damien@@, millert@@

ok phessler@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.27 2009/10/27 23:59:53 deraadt Exp $	*/
d1344 1
a1344 1
		    time_t time_now   = time ((time_t*) NULL);
@


1.27
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.26 2009/08/08 18:36:34 jmc Exp $	*/
d983 1
a983 1
	write(2, s, strlen(s));
d1160 1
a1160 1
    status = write(1, &ch, 1);
d1267 1
a1267 1
	write(2, "\n", 1);
d1272 1
a1272 1
	write(2, s, strlen(s));
@


1.26
log
@better synopsis;
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.25 2009/08/08 14:09:34 sobrado Exp $	*/
a80 8

#ifndef lint
#if 0
static char rcsid[] = "Id: chat.c,v 1.19 1998/03/24 23:57:48 paulus Exp $";
#else
static char rcsid[] = "$OpenBSD: chat.c,v 1.25 2009/08/08 14:09:34 sobrado Exp $";
#endif
#endif
@


1.25
log
@add a real synopsis to chat(8); synchronize synopsis and usage;
sort flags in the DESCRIPTION section of the manual page.

synopsis tweaked by jmc@@

ok jmc@@, martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.24 2009/07/19 15:33:06 martynas Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.24 2009/07/19 15:33:06 martynas Exp $";
d426 2
a427 2
usage: %s [-eSsVv] [-r report_file] [-T phone_number] [-t timeout]\n\
            [-U phone_number_2] -f chat_file | script\n",
@


1.24
log
@missing va_end in pppd;  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.23 2007/09/11 16:30:59 gilles Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.23 2007/09/11 16:30:59 gilles Exp $";
d426 2
a427 2
Usage: %s [-e] [-s] [-S] [-v] [-V] [-t timeout] [-r report-file]\n\
     [-T phone-number] [-U phone-number2] {-f chat-file | chat-script}\n",
@


1.23
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.22 2004/02/26 17:46:24 deraadt Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.22 2004/02/26 17:46:24 deraadt Exp $";
d460 1
@


1.22
log
@logf -> logmsg; daniel@@lucq.org
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.21 2003/04/25 23:23:50 deraadt Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.21 2003/04/25 23:23:50 deraadt Exp $";
d372 1
a372 3
	sp = strchr (buf, '\n');
	if (sp)
	    *sp = '\0';
@


1.21
log
@comment cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.20 2003/04/04 22:38:49 avsm Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.20 2003/04/04 22:38:49 avsm Exp $";
d186 1
a186 1
void logf(const char *fmt, ...);
d439 1
a439 1
void logf(const char *fmt, ...)
d487 1
a487 1
	logf("alarm");
d810 2
a811 2
	logf("clean(): new_length too short! %d < %d: \"%s\" -> \"%s\"", 
	    new_length, s1 - ret, s, ret);
d953 1
a953 1
	logf("Failed (%s)", fail_reason);
d955 1
a955 1
	logf("Failed");
d1029 1
a1029 1
	    logf("abort on (%v)", s);
d1055 1
a1055 1
		    logf("clear abort on (%v)", s);
d1079 1
a1079 1
	    logf("report (%v)", s);
d1104 1
a1104 1
		    logf("clear report (%v)", s);
d1122 1
a1122 1
	    logf("timeout set to %d seconds", timeout);
d1148 1
a1148 1
	logf("warning: read() on stdin returned %d", status);
d1176 1
a1176 1
	logf("warning: write() on stdout returned %d", status);
d1198 1
a1198 1
		logf(" -- write timed out");
d1200 1
a1200 1
		logf(" -- write failed: %m");
d1215 1
a1215 1
	    logf("send (??????)");
d1217 1
a1217 1
	    logf("send (%v)", s);
d1304 1
a1304 1
	logf("expect (%v)", string);
d1307 1
a1307 1
	logf("expect string is too long");
d1314 1
a1314 1
	    logf("got it");
d1328 1
a1328 1
		logf("");	/* blank line */
d1330 1
a1330 1
		logf("%0.*v", s - logged, logged);
d1337 1
a1337 1
	    logf("%0.*v", s - logged, logged);
d1382 2
a1383 2
		    logf("%0.*v", s - logged, logged);
		logf(" -- got it\n");
d1396 2
a1397 2
			logf("%0.*v", s - logged, logged);
		    logf(" -- failed");
d1411 1
a1411 1
		logf("%0.*v", s - logged, logged);
d1421 1
a1421 1
	    logf("warning: alarm synchronization problem");
d1428 1
a1428 1
	    logf(" -- read timed out");
d1430 1
a1430 1
	    logf(" -- read failed: %m");
@


1.20
log
@strcat->strlcat, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.19 2003/04/03 18:53:50 deraadt Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.19 2003/04/03 18:53:50 deraadt Exp $";
d212 1
a212 1
int vfmtmsg(char *, int, const char *, va_list);	/* vsprintf++ */
d1495 1
a1495 1
 * vfmtmsg - format a message into a buffer.  Like vsprintf except we
@


1.19
log
@more snprintf; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.18 2002/07/02 22:22:56 millert Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.18 2002/07/02 22:22:56 millert Exp $";
d1357 1
a1357 1
		    strcat (report_buffer, report_string[n]);
@


1.18
log
@Check malloc() return value; Chad Loder
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.17 2002/05/29 19:23:34 deraadt Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.17 2002/05/29 19:23:34 deraadt Exp $";
d974 1
a974 1
	sprintf(string, "%s^%c", meta, (int)c + '@@');
d976 1
a976 1
	sprintf(string, "%s^?", meta);
d978 1
a978 1
	sprintf(string, "%s%c", meta, c);
@


1.17
log
@more strlcat
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.16 2002/02/19 19:39:40 millert Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.16 2002/02/19 19:39:40 millert Exp $";
d667 2
@


1.16
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.15 2002/02/17 19:42:38 millert Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.15 2002/02/17 19:42:38 millert Exp $";
d1401 2
a1402 1
		strcpy(fail_reason = fail_buffer, abort_string[n]);
@


1.15
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.14 2002/02/16 21:28:07 millert Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.14 2002/02/16 21:28:07 millert Exp $";
d102 1
a121 11
#undef __V

#ifdef __STDC__
#include <stdarg.h>
#define __V(x)	x
#else
#include <varargs.h>
#define __V(x)	(va_alist) va_dcl
#define const
#endif

d439 1
a439 1
void logf __V((const char *fmt, ...))
a442 1
#ifdef __STDC__
a443 6
#else
    char *fmt;
    va_start(args);
    fmt = va_arg(args, char *);
#endif

d456 1
a456 1
void fatal __V((int code, const char *fmt, ...))
a459 1
#ifdef __STDC__
a460 8
#else
    int code;
    char *fmt;
    va_start(args);
    code = va_arg(args, int);
    fmt = va_arg(args, char *);
#endif

@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.13 2001/09/05 22:32:46 deraadt Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.13 2001/09/05 22:32:46 deraadt Exp $";
a120 1
#undef __P
a125 1
#define __P(x)	x
a128 1
#define __P(x)	()
@


1.13
log
@make sure that va_start() has matching va_end()
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.12 1999/12/02 02:32:29 d Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.12 1999/12/02 02:32:29 d Exp $";
d196 30
a225 30
void *dup_mem __P((void *b, size_t c));
void *copy_of __P((char *s));
void usage __P((void));
void logf __P((const char *fmt, ...));
void fatal __P((int code, const char *fmt, ...));
SIGTYPE sigalrm __P((int signo));
SIGTYPE sigint __P((int signo));
SIGTYPE sigterm __P((int signo));
SIGTYPE sighup __P((int signo));
void unalarm __P((void));
void init __P((void));
void set_tty_parameters __P((void));
void echo_stderr __P((int));
void break_sequence __P((void));
void terminate __P((int status));
void do_file __P((char *chat_file));
int  get_string __P((register char *string));
int  put_string __P((register char *s));
int  write_char __P((int c));
int  put_char __P((int c));
int  get_char __P((void));
void chat_send __P((register char *s));
char *character __P((int c));
void chat_expect __P((register char *s));
char *clean __P((register char *s, int sending));
void break_sequence __P((void));
void terminate __P((int status));
void pack_array __P((char **array, int end));
char *expect_strtok __P((char *, char *));
int vfmtmsg __P((char *, int, const char *, va_list));	/* vsprintf++ */
d227 1
a227 1
int main __P((int, char *[]));
@


1.12
log
@paranoia, add_return may change
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.11 1999/12/02 02:22:56 d Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.11 1999/12/02 02:22:56 d Exp $";
d465 1
@


1.11
log
@fix one possible buffer overrun; inspired by kris@@hub.freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.10 1998/10/30 18:04:59 mickey Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.10 1998/10/30 18:04:59 mickey Exp $";
d692 1
a692 4
    if (add_return)
	new_length++;

    new_length += 2;	/* Two nuls terminate */
@


1.10
log
@fix usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.9 1998/09/12 14:06:52 provos Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.9 1998/09/12 14:06:52 provos Exp $";
d637 2
a638 1
    char temp[STR_LEN], cur_chr;
d643 57
a699 1
    s1 = temp;
d834 9
a842 1
    return dup_mem (temp, (size_t) (s1 - temp)); /* may have embedded nuls */
@


1.9
log
@Insert missing flags -s and -S, probably lost during move from 'mini getopt'
to the real getopt.
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.8 1998/08/04 17:50:58 millert Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.8 1998/08/04 17:50:58 millert Exp $";
d441 3
a443 2
Usage: %s [-e] [-v] [-V] [-t timeout] [-r report-file] [-T phone-number]\n\
     [-U phone-number2] {-f chat-file | chat-script}\n", __progname);
@


1.8
log
@fix parsing on chat script when passed on the command line; problem noted by fgsch@@olimpo.com.br but different fix committed.
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.7 1998/05/08 04:52:36 millert Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.7 1998/05/08 04:52:36 millert Exp $";
d263 1
a263 1
    while ((option = getopt(argc, argv, "evVt:r:f:T:U:")) != -1) {
@


1.7
log
@pppd 2.3.5
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.6 1998/01/17 20:30:33 millert Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.6 1998/01/17 20:30:33 millert Exp $";
d352 2
a353 2
	while (*argv != NULL) {
	    chat_expect(*argv);
d355 3
a357 2
	    if (*(++argv) != NULL)
		chat_send(*argv);
a358 1
	argv++;
@


1.6
log
@ppp-2.3.3 + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.5 1997/11/16 21:16:49 millert Exp $	*/
d84 1
a84 1
static char rcsid[] = "Id: chat.c,v 1.17 1997/11/27 06:37:15 paulus Exp $";
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.5 1997/11/16 21:16:49 millert Exp $";
d1399 10
@


1.5
log
@Replace "micro getopt" with real getopt for readability's sake.
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.4 1997/09/19 18:00:58 deraadt Exp $	*/
d10 1
a10 1
 *  2 - error on an I/O operation or fatal error condtion.
d19 4
d57 4
d84 1
a84 1
static char rcsid[] = "Id: chat.c,v 1.15 1997/07/14 03:50:22 paulus Exp $";
d86 1
a86 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.4 1997/09/19 18:00:58 deraadt Exp $";
d121 3
d125 2
a126 1
#undef __P
d129 2
d139 8
d153 2
d162 2
d199 2
a200 4
void logf __P((const char *str));
void logflush __P((void));
void fatal __P((const char *msg));
void sysfatal __P((const char *msg));
a222 1
void die __P((void));
d225 1
d232 1
a232 1
    {
d235 2
a236 3
        {
	fatal ("memory error!\n");
        }
d239 1
a239 1
    }
d243 1
a243 1
    {
d245 1
a245 1
    }
d248 2
a249 1
 *	chat [ -v ] [ -t timeout ] [ -f chat-file ] [ -r report-file ] \
d256 3
a258 3
int argc;
char **argv;
    {
d263 5
a267 7
    while ((option = getopt(argc, argv, "evVt:r:f:")) != -1)
        {
	switch (option)
	    {
	    case 'e':
		++echo;
		break;
d269 3
a271 3
	    case 'v':
		++verbose;
		break;
d273 3
a275 3
	    case 'V':
	        ++Verbose;
		break;
d277 3
a279 3
	    case 'f':
		chat_file = copy_of(optarg);
		break;
d281 3
a283 3
	    case 't':
		timeout = atoi(optarg);
		break;
d285 3
a287 17
	    case 'r':
		if (report_fp != NULL)
		    {
		    fclose (report_fp);
		    }
		report_file = copy_of (optarg);
		report_fp   = fopen (report_file, "a");
		if (report_fp != NULL)
		    {
		    if (verbose)
			{
			fprintf (report_fp, "Opening \"%s\"...\n",
				 report_file);
			}
		    report = 1;
		    }
		break;
d289 3
a291 3
	    case ':':
		fprintf(stderr, "Option -%c requires an argument\n",
		    optopt);
d293 10
a302 3
	    default:
		usage();
		break;
d304 21
a324 3
      }
      argc -= optind;
      argv += optind;
a328 1
        {
a329 1
        }
d331 1
d333 1
a333 1
    openlog("chat", LOG_PID);
d335 1
a335 1
    openlog("chat", LOG_PID | LOG_NDELAY, LOG_LOCAL2);
d337 4
a340 8
    if (verbose)
        {
	setlogmask(LOG_UPTO(LOG_INFO));
        }
    else
        {
	setlogmask(LOG_UPTO(LOG_WARNING));
        }
d342 1
d346 1
a346 2
    if (chat_file != NULL)
	{
a347 1
	    {
a348 1
	    }
a349 1
	    {
d351 2
a352 6
	    }
	}
    else
	{
	while (*argv != NULL)
	    {
a355 1
	        {
a356 3
	        }
	    }
	    argv++;
d358 2
d363 1
a363 1
    }
d371 1
a371 1
    {
d379 1
a379 4
	{
	syslog (LOG_ERR, "%s -- open failed: %m", chat_file);
	terminate (1);
	}
d384 1
a384 2
    while (fgets(buf, STR_LEN, cfp) != NULL)
	{
a386 1
	    {
a387 1
	    }
d394 2
a395 1
        if ( *sp == '#' ) continue;
d397 2
a398 4
	while (*sp != '\0')
	    {
	    if (*sp == ' ' || *sp == '\t')
		{
d401 1
a401 1
		}
d403 1
a403 2
	    if (*sp == '"' || *sp == '\'')
		{
d406 1
a406 2
		while (*sp != quote)
		    {
d408 3
a410 8
			{
			syslog (LOG_ERR, "unterminated quote (line %d)",
				linect);
			terminate (1);
			}
		    
		    if (*sp++ == '\\')
		        {
a411 1
			    {
a412 2
			    }
		        }
d415 2
a416 2
	    else
		{
a418 1
		    {
d420 1
a420 2
		    }
		}
a422 1
	        {
a423 1
	        }
a425 1
		{
a426 1
		}
a427 1
		{
a428 1
		}
a429 1
	    }
d431 1
d433 1
a433 1
    }
d439 4
a442 3
    {
    fprintf(stderr, "Usage: %s [-e] [-v] [-V] [-t timeout] [-r report-file]"
	"{-f chat-file | chat-script}\n", __progname);
d444 1
a444 1
    }
d446 1
a446 1
char line[256];
d448 4
a451 2
void logf (str)
const char *str;
d453 1
a453 1
    int l = strlen(line);
d455 10
a464 1
    if (l + strlen(str) >= sizeof(line)) {
d466 2
a467 8
	l = 0;
    }
    strcpy(line + l, str);

    if (str[strlen(str)-1] == '\n') {
	syslog (LOG_INFO, "%s", line);
	line[0] = 0;
    }
a469 17
void logflush()
    {
    if (line[0] != 0)
	{
	syslog(LOG_INFO, "%s", line);
	line[0] = 0;
        }
    }

/*
 *	Terminate with an error.
 */
void die()
    {
    terminate(1);
    }

d474 3
a476 6
void fatal (msg)
const char *msg;
    {
    syslog(LOG_ERR, "%s", msg);
    terminate(2);
    }
d478 9
a486 4
/*
 *	Print an error message along with the system error message and
 *	terminate.
 */
d488 7
a494 6
void sysfatal (msg)
const char *msg;
    {
    syslog(LOG_ERR, "%s: %m", msg);
    terminate(2);
    }
d500 1
a500 1
    {
a506 1
    logflush();
d508 4
a511 10
        {
	sysfatal("Can't get file mode flags on stdin");
        }
    else
        {
	if (fcntl(0, F_SETFL, flags | O_NONBLOCK) == -1)
	    {
	    sysfatal("Can't set file mode flags on stdin");
	    }
        }
d514 2
a515 4
	{
	syslog(LOG_INFO, "alarm");
	}
    }
d518 1
a518 1
    {
d522 5
a526 11
        {
	sysfatal("Can't get file mode flags on stdin");
        }
    else
        {
	if (fcntl(0, F_SETFL, flags & ~O_NONBLOCK) == -1)
	    {
	    sysfatal("Can't set file mode flags on stdin");
	    }
        }
    }
d530 3
a532 3
    {
    fatal("SIGINT");
    }
d536 3
a538 3
    {
    fatal("SIGTERM");
    }
d542 3
a544 3
    {
    fatal("SIGHUP");
    }
d547 1
a547 1
    {
d556 1
a556 1
    }
d559 1
a559 1
    {
d564 1
a564 3
        {
	sysfatal("Can't get terminal parameters");
        }
d578 1
a578 3
        {
	sysfatal("Can't set terminal parameters");
        }
d580 1
a580 1
    }
d583 1
a583 1
    {
d587 1
a587 1
    }
d591 1
a591 1
    {
d593 1
a593 2
    if (report_file != (char *) 0 && report_fp != (FILE *) NULL)
	{
a613 1
	    {
a614 1
	    }
d617 1
a617 1
        }
d620 1
a620 2
    if (have_tty_parameters)
        {
d622 2
a623 5
	    {
	    syslog(LOG_ERR, "Can't restore terminal parameters: %m");
	    exit(1);
	    }
        }
d627 1
a627 1
    }
d634 2
a635 2
int sending;
    {
d637 1
a637 1
    register char *s1;
d642 1
a642 2
    while (*s)
	{
d644 1
a644 2
	if (cur_chr == '^')
	    {
d646 1
a646 2
	    if (cur_chr == '\0')
		{
d649 1
a649 1
		}
d651 1
a651 2
	    if (cur_chr != 0)
	        {
d653 1
a653 1
	        }
d655 1
a655 1
	    }
d657 1
a657 2
	if (cur_chr != '\\')
	    {
d660 1
a660 1
	    }
d663 2
a664 4
	if (cur_chr == '\0')
	    {
	    if (sending)
		{
d667 1
a667 1
		}
d669 1
a669 1
	    }
d671 1
a671 2
	switch (cur_chr)
	    {
a677 1
	        {
a678 1
	        }
a679 1
	        {
a680 1
	        }
a687 1
	        {
a688 1
	        }
d693 22
d736 1
a736 2
	    if (sending)
		{
d739 1
a739 1
		}
a740 1
	        {
a741 1
	        }
d745 1
a745 2
	    if (isoctal (cur_chr))
		{
d747 1
a747 2
		if (isoctal (*s))
		    {
d750 1
a750 2
		    if (isoctal (*s))
			{
a752 1
			}
d754 1
d756 1
a756 2
		if (cur_chr != 0 || sending)
		    {
a757 1
		        {
a758 1
		        }
d760 1
a760 1
		    }
d762 1
a762 1
		}
a764 1
	        {
a765 1
	        }
a767 1
	    }
d769 1
a771 1
        {
a772 1
        }
d777 1
a777 1
    }
d784 2
a785 2
char *s, *term;
    {
d789 1
a793 1
	{
d795 1
a795 1
	}
a799 1
        {
a800 1
        }
a801 1
        {
a802 1
        }
d804 2
a805 4
    while (*str)
	{
	if (escape_flag)
	    {
d809 1
a809 1
	    }
d811 1
a811 2
	if (*str == '\\')
	    {
d815 2
a816 1
	    }
d820 1
a820 2
	if (strchr (term, *str) == (char *) 0)
	    {
d823 2
a824 1
	    }
d830 1
a830 1
	}
d832 1
a832 1
    }
d840 1
a840 1
    {
d844 1
a844 2
    if (strcmp(s, "HANGUP") == 0)
        {
d847 1
a847 1
        }
d849 1
a849 2
    if (strcmp(s, "ABORT") == 0)
	{
d852 1
a852 1
	}
d854 1
a854 2
    if (strcmp(s, "CLR_ABORT") == 0)
	{
d857 1
a857 1
	}
d859 1
a859 2
    if (strcmp(s, "REPORT") == 0)
	{
d862 1
a862 1
	}
d864 1
a864 2
    if (strcmp(s, "CLR_REPORT") == 0)
	{
d867 1
a867 1
	}
d869 1
a869 2
    if (strcmp(s, "TIMEOUT") == 0)
	{
d872 1
a872 1
	}
d874 1
a874 2
    if (strcmp(s, "ECHO") == 0)
	{
d877 3
a879 3
	}
    if (strcmp(s, "SAY") == 0)
	{
d882 2
a883 1
	}
d887 1
a887 2
    for (;;)
	{
a891 1
	    {
a892 1
	    }
d895 1
a899 1
	    {
d901 1
a901 1
	    }
a906 1
	    {
a907 1
	    }
d910 2
a911 1
	}
d916 1
a916 3
	{
	syslog(LOG_INFO, "Failed (%s)", fail_reason);
	}
d918 1
a918 3
	{
	syslog(LOG_INFO, "Failed");
	}
d920 1
a920 1
    }
d929 1
a929 1
    {
a936 1
        {
d938 2
a939 1
        }
d941 1
a941 10
        {
	if (c == 127)
	    {
	    sprintf(string, "%s^?", meta);
	    }
	else
	    {
	    sprintf(string, "%s%c", meta, c);
	    }
        }
d944 1
a944 1
    }
d951 2
a952 3
    {
    if (say_next)
	{
d958 3
a960 3
	}
    if (hup_next)
        {
d967 3
a969 3
        }
    if (echo_next)
	{
d973 3
a975 3
	}
    if (abort_next)
        {
d981 1
a981 3
	    {
	    fatal("Too many ABORT strings");
	    }
d987 1
a987 4
	    {
	    syslog(LOG_WARNING, "Illegal or too-long ABORT string ('%s')", s);
	    die();
	    }
d992 1
a992 10
	    {
	    logf("abort on (");

	    for (s1 = s; *s1; ++s1)
	        {
		logf(character(*s1));
	        }

	    logf(")\n");
	    }
d994 1
a994 1
	}
d996 1
a996 2
    if (clear_abort_next)
        {
a997 1
	char *s2 = s;
d1008 1
a1008 4
	    {
	    syslog(LOG_WARNING, "Illegal or too-long CLR_ABORT string ('%s')", s);
	    die();
	    }
d1011 8
a1018 20
	for (i=0; i < n_aborts; i++)
	    {
		if ( strcmp(s1,abort_string[i]) == 0 )
		    {
                        free(abort_string[i]);
			abort_string[i] = NULL;
			pack++;
                        n_aborts--;
			if (verbose)
	    		{
	    		logf("clear abort on (");
		
	    		for (s2 = s; *s2; ++s2)
	        		{
				logf(character(*s2));
	        		}
		
	    		logf(")\n");
	    		}
	    	    }
d1020 1
d1022 2
a1023 1
	if (pack) pack_array(abort_string,old_max);
d1025 1
a1025 1
	}
d1027 1
a1027 2
    if (report_next)
        {
d1032 1
a1032 3
	    {
	    fatal("Too many REPORT strings");
	    }
d1037 1
a1037 4
	    {
	    syslog(LOG_WARNING, "Illegal or too-long REPORT string ('%s')", s);
	    die();
	    }
d1042 1
a1042 10
	    {
	    logf("report (");
	    s1 = s;
	    while (*s1)
	        {
		logf(character(*s1));
		++s1;
	        }
	    logf(")\n");
	    }
d1044 1
a1044 1
        }
d1046 1
a1046 2
    if (clear_report_next)
        {
a1047 1
        char *s2 = s;
d1057 1
a1057 4
	    {
	    syslog(LOG_WARNING, "Illegal or too-long REPORT string ('%s')", s);
	    die();
	    }
d1060 8
a1067 20
	for (i=0; i < n_reports; i++)
	    {
		if ( strcmp(s1,report_string[i]) == 0 )
		    {
			free(report_string[i]);
			report_string[i] = NULL;
			pack++;
			n_reports--;
			if (verbose)
	    		{
	    		logf("clear report (");
		
	    		for (s2 = s; *s2; ++s2)
	        		{
				logf(character(*s2));
	        		}
		
	    		logf(")\n");
	    		}
	    	    }
d1069 1
d1071 2
a1072 1
        if (pack) pack_array(report_string,old_max);
d1075 1
a1075 1
        }
d1077 1
a1077 2
    if (timeout_next)
        {
a1081 1
	    {
a1082 1
	    }
d1085 2
a1086 3
	    {
	    syslog(LOG_INFO, "timeout set to %d seconds", timeout);
	    }
d1088 1
a1088 1
        }
a1090 1
        {
d1092 2
a1093 8
        }
    else
        {
	if (strcmp(s, "BREAK") == 0)
	    {
	    s = "\\K\\c";
	    }
        }
d1096 2
a1097 5
        {
	syslog(LOG_INFO, "Failed");
	terminate(1);
        }
    }
d1100 1
a1100 1
    {
d1106 1
a1106 2
    switch (status)
        {
d1111 1
a1111 2
	syslog(LOG_WARNING, "warning: read() on stdin returned %d",
	       status);
d1115 4
a1118 10
	    {
	    sysfatal("Can't get file mode flags on stdin");
	    }
	else
	    {
	    if (fcntl(0, F_SETFL, status & ~O_NONBLOCK) == -1)
	        {
		sysfatal("Can't set file mode flags on stdin");
	        }
	    }
a1120 1
        }
d1122 1
d1126 1
a1126 1
    {
d1134 1
a1134 2
    switch (status)
        {
d1139 1
a1139 2
	syslog(LOG_WARNING, "warning: write() on stdout returned %d",
	       status);
d1143 4
a1146 10
	    {
	    sysfatal("Can't get file mode flags on stdin");
	    }
	else
	    {
	    if (fcntl(0, F_SETFL, status & ~O_NONBLOCK) == -1)
	        {
		sysfatal("Can't set file mode flags on stdin");
	        }
	    }
a1148 1
        }
d1150 1
d1154 2
a1155 5
    {
    if (alarmed || put_char(c) < 0)
	{
	extern int errno;

d1159 1
a1159 2
	if (verbose)
	    {
d1161 1
a1161 3
	        {
		syslog(LOG_INFO, " -- write timed out");
	        }
d1163 2
a1164 4
	        {
		syslog(LOG_INFO, " -- write failed: %m");
	        }
	    }
d1166 1
a1166 1
	}
d1168 1
a1168 1
    }
d1172 1
a1172 1
    {
d1176 1
a1176 4
    if (verbose)
	{
	logf("send (");

d1178 1
a1178 3
	    {
	    logf("??????");
	    }
d1180 2
a1181 11
	    {
	    register char *s1 = s;

	    for (s1 = s; *s1; ++s1)
	        {
		logf(character(*s1));
	        }
	    }

	logf(")\n");
	}
d1185 1
a1185 2
    while (*s)
	{
d1188 1
a1188 2
	if (c != '\\')
	    {
a1189 1
	        {
a1190 1
	        }
d1192 1
a1192 1
	    }
d1195 1
a1195 2
	switch (c)
	    {
a1211 1
	    }
d1213 1
d1218 1
a1218 1
    }
d1227 9
a1235 7
    {
	static int need_lf;
	char *s;

	switch (n)
	    {
	case '\r':		/* ignore '\r' */
d1237 10
a1246 14
	case -1:
	    if (need_lf == 0)
		break;
	    /* fall through */
	case '\n':
	    write(2, "\n", 1);
	    need_lf = 0;
	    break;
	default:
	    s = character(n);
	    write(2, s, strlen(s));
	    need_lf = 1;
	    break;
	    }
d1248 1
d1255 1
a1255 1
    {
d1259 1
d1267 1
a1267 12
	{
	register char *s1;

	logf("expect (");

	for (s1 = string; *s1; ++s1)
	    {
	    logf(character(*s1));
	    }

	logf(")\n");
	}
d1269 2
a1270 3
    if (len > STR_LEN)
	{
	syslog(LOG_INFO, "expect string is too long");
d1273 1
a1273 1
	}
d1275 1
a1275 2
    if (len == 0)
	{
d1277 1
a1277 4
	    {
	    syslog(LOG_INFO, "got it");
	    }

d1279 1
a1279 1
	}
d1284 1
a1284 2
    while ( ! alarmed && (c = get_char()) >= 0)
	{
a1287 1
	    {
d1289 3
a1291 7
	    }
	if (verbose)
	    {
	    if (c == '\n')
	        {
		logf("\n");
	        }
d1293 10
a1302 4
	        {
		logf(character(c));
	        }
	    }
d1305 4
a1308 2
	   if (c == '\n')      fputc( '\n', stderr );
	   else if (c != '\r') fprintf( stderr, "%s", character(c) );
d1311 2
a1312 6
	*s++ = c;

	if (!report_gathering)
	    {
	    for (n = 0; n < n_reports; ++n)
	        {
d1315 1
a1315 2
		    strncmp(s - report_len, report_string[n], report_len) == 0)
		    {
d1325 1
a1325 2
		    }
	        }
d1327 3
a1329 4
	else
	    {
	    if (!iscntrl (c))
	        {
d1333 2
a1334 3
	        }
	    else
	        {
a1336 1
	        }
d1338 1
d1342 4
a1345 4
	    strncmp(s - len, string, len) == 0)
	    {
	    if (verbose)
		{
d1347 1
a1347 1
		}
d1352 1
a1352 1
	    }
d1354 1
a1354 2
	for (n = 0; n < n_aborts; ++n)
	    {
d1356 7
a1362 7
		strncmp(s - abort_len, abort_string[n], abort_len) == 0)
	        {
		if (verbose)
		    {
		    logf(" -- failed\n");
		    }
		
a1367 1
	        }
d1369 1
d1371 8
a1378 3
	if (s >= end)
	    {
	    strncpy (temp, s - minlen, minlen);
d1380 1
a1380 1
	    }
d1383 2
a1384 4
	    {
	    syslog(LOG_WARNING, "warning: alarm synchronization problem");
	    }
	}
d1388 1
a1388 2
    if (verbose && printed)
	{
d1390 1
a1390 3
	    {
	    logf(" -- read timed out\n");
	    }
d1392 2
a1393 5
	    {
	    logflush();
	    syslog(LOG_INFO, " -- read failed: %m");
	    }
	}
d1398 1
a1398 1
    }
d1415 1
a1415 2
    static struct			/* `timeval' */
        {
d1418 1
a1418 1
        } delay;	    /* _select() timeout */
d1423 1
a1423 1
    return select( 0, (long *)0, (long *)0, (long *)0, &delay );
d1444 204
@


1.4
log
@never before have i deleted an unused global variable out of a file with
such prejudice (long story)
@
text
@d1 1
a1 1
/*	$OpenBSD: chat.c,v 1.3 1997/09/01 21:48:28 millert Exp $	*/
d78 1
a78 1
static char rcsid[] = "$OpenBSD: chat.c,v 1.3 1997/09/01 21:48:28 millert Exp $";
a124 14
/*************** Micro getopt() *********************************************/
#define	OPTION(c,v)	(_O&2&&**v?*(*v)++:!c||_O&4?0:(!(_O&1)&& \
				(--c,++v),_O=4,c&&**v=='-'&&v[0][1]?*++*v=='-'\
				&&!v[0][1]?(--c,++v,0):(_O=2,*(*v)++):0))
#define	OPTARG(c,v)	(_O&2?**v||(++v,--c)?(_O=1,--c,*v++): \
				(_O=4,(char*)0):(char*)0)
#define	OPTONLYARG(c,v)	(_O&2&&**v?(_O=1,--c,*v++):(char*)0)
#define	ARG(c,v)	(c?(--c,*v++):(char*)0)

static int _O = 0;		/* Internal state */
/*************** Micro getopt() *********************************************/

char *program_name;

d142 2
a235 1
    char *arg;
a236 1
    program_name = *argv;
d239 1
a239 1
    while ((option = OPTION(argc, argv)) != 0)
d256 1
a256 8
		if ((arg = OPTARG(argc, argv)) != NULL)
		    {
		    chat_file = copy_of(arg);
		    }
		else
		    {
		    usage();
		    }
d260 5
a264 1
		if ((arg = OPTARG(argc, argv)) != NULL)
d266 1
a266 1
		    timeout = atoi(arg);
d268 3
a270 1
		else
d272 6
a277 1
		    usage();
d281 3
a283 21
	    case 'r':
		arg = OPTARG (argc, argv);
		if (arg)
		    {
		    if (report_fp != NULL)
		        {
			fclose (report_fp);
		        }
		    report_file = copy_of (arg);
		    report_fp   = fopen (report_file, "a");
		    if (report_fp != NULL)
		        {
			if (verbose)
			    {
			    fprintf (report_fp, "Opening \"%s\"...\n",
				     report_file);
			    }
			report = 1;
		        }
		    }
		break;
d290 2
d319 1
a319 2
	arg = ARG(argc, argv);
	if (arg != NULL)
d330 1
a330 1
	while ((arg = ARG(argc, argv)) != NULL)
d332 1
a332 1
	    chat_expect(arg);
d334 1
a334 1
	    if ((arg = ARG(argc, argv)) != NULL)
d336 1
a336 1
		chat_send(arg);
d339 1
d353 1
a353 1
    int linect, len, sendflg;
d446 2
a447 3
    fprintf(stderr, "\
Usage: %s [-e] [-v] [-t timeout] [-r report-file] {-f chat-file | chat-script}\n",
	    program_name);
@


1.3
log
@Update from ppp 3.2.1
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 1
a78 1
static char rcsid[] = "$OpenBSD$";
a478 1
char *p;
@


1.2
log
@allow comments in script; netbsd pr#2450; ksulliva@@psc.edu
@
text
@d1 2
d18 30
a47 1
 *	Please send all bug reports, requests for information, etc. to:
a48 2
 *		Al Longyear (longyear@@netcom.com)
 *		(I was the last person to change this code.)
d53 10
d71 1
d74 7
a80 1
static char rcsid[] = "$Id: chat.c,v 1.1.1.1 1995/10/18 08:48:00 deraadt Exp $";
d83 1
d90 1
d143 1
d145 1
d172 2
a173 1
int n_aborts = 0, abort_next = 0, timeout_next = 0;
d178 3
d196 1
d212 4
d253 1
a253 1
    while (option = OPTION(argc, argv))
d257 4
d265 4
d270 1
a270 1
		if (arg = OPTARG(argc, argv))
d281 1
a281 1
		if (arg = OPTARG(argc, argv))
d357 1
a357 1
	while (arg = ARG(argc, argv))
d361 1
a361 1
	    if (arg = ARG(argc, argv))
d369 1
d404 5
a408 2
	if ( *sp == '#')
		continue;
d473 1
a473 1
Usage: %s [-v] [-t timeout] [-r report-file] {-f chat-file | chat-script}\n",
d483 8
a490 3
    {
    p = line + strlen(line);
    strcat (p, str);
d492 1
a492 2
    if (str[strlen(str)-1] == '\n')
	{
a494 1
	}
d496 1
d653 1
d655 20
a674 1
        {
d680 1
a680 1
	report_fp = (FILE*) NULL;
d776 1
a776 1
	    quiet = ! quiet;
d853 61
d916 3
a918 2
void chat_expect(s)
register char *s;
d920 9
d935 6
d947 6
d959 14
a972 1
    while (*s)
d974 2
a975 1
	register char *hyphen;
d977 1
a977 1
	for (hyphen = s; *hyphen; ++hyphen)
d979 1
a979 7
	    if (*hyphen == '-')
	        {
		if (hyphen == s || hyphen[-1] != '\\')
		    {
		    break;
		    }
	        }
d981 6
a986 2
	
	if (*hyphen == '-')
d988 1
a988 34
	    *hyphen = '\0';

	    if (get_string(s))
	        {
		return;
	        }
	    else
		{
		s = hyphen + 1;

		for (hyphen = s; *hyphen; ++hyphen)
		    {
		    if (*hyphen == '-')
		        {
			if (hyphen == s || hyphen[-1] != '\\')
			    {
			    break;
			    }
		        }
		    }

		if (*hyphen == '-')
		    {
		    *hyphen = '\0';

		    chat_send(s);
		    s = hyphen + 1;
		    }
		else
		    {
		    chat_send(s);
		    return;
		    }
		}
d990 5
a994 1
	else
d996 2
a997 14
	    if (get_string(s))
	        {
		return;
	        }
	    else
		{
		if (fail_reason)
		    {
		    syslog(LOG_INFO, "Failed (%s)", fail_reason);
		    }
		else
		    {
		    syslog(LOG_INFO, "Failed");
		    }
d999 12
a1010 3
		terminate(exit_code);
		}
	    }
d1012 1
d1015 5
d1054 23
d1113 46
d1193 46
d1373 1
d1440 31
d1523 4
d1539 5
a1545 32
	if (s - temp >= len &&
	    c == string[len - 1] &&
	    strncmp(s - len, string, len) == 0)
	    {
	    if (verbose)
		{
		logf(" -- got it\n");
		}

	    alarm(0);
	    alarmed = 0;
	    return (1);
	    }

	for (n = 0; n < n_aborts; ++n)
	    {
	    if (s - temp >= (abort_len = strlen(abort_string[n])) &&
		strncmp(s - abort_len, abort_string[n], abort_len) == 0)
	        {
		if (verbose)
		    {
		    logf(" -- failed\n");
		    }
		
		alarm(0);
		alarmed = 0;
		exit_code = n + 4;
		strcpy(fail_reason = fail_buffer, abort_string[n]);
		return (0);
	        }
	    }

d1581 32
d1672 19
@


1.1
log
@Initial revision
@
text
@d34 1
a34 1
static char rcsid[] = "$Id: chat.c,v 1.6 1995/07/04 23:36:23 paulus Exp $";
d336 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
