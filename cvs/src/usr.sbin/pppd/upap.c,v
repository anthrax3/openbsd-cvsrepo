head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.30
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.28
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.24
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.26
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.18
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.22
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.20
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.16
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.32
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.28
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.26
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.24
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.22
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.20
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.18
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.16
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.14
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.12
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.10
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.8
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.6.0.16
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.14
	OPENBSD_2_8:1.6.0.12
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.10
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.8
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.01.19.31.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.17.19.42.38;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.28.07;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.01.17.20.30.30;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.09.05.04.32.46;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.12.23.13.22.49;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.07.20.12.02.14;	author joshd;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.58;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.00;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@/*	$OpenBSD: upap.c,v 1.9 2002/07/01 19:31:37 deraadt Exp $	*/

/*
 * upap.c - User/Password Authentication Protocol.
 *
 * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name "Carnegie Mellon University" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For permission or any legal
 *    details, please contact
 *      Office of Technology Transfer
 *      Carnegie Mellon University
 *      5000 Forbes Avenue
 *      Pittsburgh, PA  15213-3890
 *      (412) 268-4387, fax: (412) 268-7395
 *      tech-transfer@@andrew.cmu.edu
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Computing Services
 *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
 *
 * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * TODO:
 */

#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/time.h>
#include <syslog.h>

#include "pppd.h"
#include "upap.h"

/*
 * Protocol entry points.
 */
static void upap_init(int);
static void upap_lowerup(int);
static void upap_lowerdown(int);
static void upap_input(int, u_char *, int);
static void upap_protrej(int);
static int  upap_printpkt(u_char *, int, void (*)(void *, char *, ...), void *);

struct protent pap_protent = {
    PPP_PAP,
    upap_init,
    upap_input,
    upap_protrej,
    upap_lowerup,
    upap_lowerdown,
    NULL,
    NULL,
    upap_printpkt,
    NULL,
    1,
    "PAP",
    NULL,
    NULL,
    NULL
};

upap_state upap[NUM_PPP];		/* UPAP state; one for each unit */

static void upap_timeout(void *);
static void upap_reqtimeout(void *);
static void upap_rauthreq(upap_state *, u_char *, int, int);
static void upap_rauthack(upap_state *, u_char *, int, int);
static void upap_rauthnak(upap_state *, u_char *, int, int);
static void upap_sauthreq(upap_state *);
static void upap_sresp(upap_state *, int, int, char *, int);


/*
 * upap_init - Initialize a UPAP unit.
 */
static void
upap_init(unit)
    int unit;
{
    upap_state *u = &upap[unit];

    u->us_unit = unit;
    u->us_user = NULL;
    u->us_userlen = 0;
    u->us_passwd = NULL;
    u->us_passwdlen = 0;
    u->us_clientstate = UPAPCS_INITIAL;
    u->us_serverstate = UPAPSS_INITIAL;
    u->us_id = 0;
    u->us_timeouttime = UPAP_DEFTIMEOUT;
    u->us_maxtransmits = 10;
    u->us_reqtimeout = UPAP_DEFREQTIME;
}


/*
 * upap_authwithpeer - Authenticate us with our peer (start client).
 *
 * Set new state and send authenticate's.
 */
void
upap_authwithpeer(unit, user, password)
    int unit;
    char *user, *password;
{
    upap_state *u = &upap[unit];

    /* Save the username and password we're given */
    u->us_user = user;
    u->us_userlen = strlen(user);
    u->us_passwd = password;
    u->us_passwdlen = strlen(password);
    u->us_transmits = 0;

    /* Lower layer up yet? */
    if (u->us_clientstate == UPAPCS_INITIAL ||
	u->us_clientstate == UPAPCS_PENDING) {
	u->us_clientstate = UPAPCS_PENDING;
	return;
    }

    upap_sauthreq(u);			/* Start protocol */
}


/*
 * upap_authpeer - Authenticate our peer (start server).
 *
 * Set new state.
 */
void
upap_authpeer(unit)
    int unit;
{
    upap_state *u = &upap[unit];

    /* Lower layer up yet? */
    if (u->us_serverstate == UPAPSS_INITIAL ||
	u->us_serverstate == UPAPSS_PENDING) {
	u->us_serverstate = UPAPSS_PENDING;
	return;
    }

    u->us_serverstate = UPAPSS_LISTEN;
    if (u->us_reqtimeout > 0)
	TIMEOUT(upap_reqtimeout, u, u->us_reqtimeout);
}


/*
 * upap_timeout - Retransmission timer for sending auth-reqs expired.
 */
static void
upap_timeout(arg)
    void *arg;
{
    upap_state *u = (upap_state *) arg;

    if (u->us_clientstate != UPAPCS_AUTHREQ)
	return;

    if (u->us_transmits >= u->us_maxtransmits) {
	/* give up in disgust */
	syslog(LOG_ERR, "No response to PAP authenticate-requests");
	u->us_clientstate = UPAPCS_BADAUTH;
	auth_withpeer_fail(u->us_unit, PPP_PAP);
	return;
    }

    upap_sauthreq(u);		/* Send Authenticate-Request */
}


/*
 * upap_reqtimeout - Give up waiting for the peer to send an auth-req.
 */
static void
upap_reqtimeout(arg)
    void *arg;
{
    upap_state *u = (upap_state *) arg;

    if (u->us_serverstate != UPAPSS_LISTEN)
	return;			/* huh?? */

    auth_peer_fail(u->us_unit, PPP_PAP);
    u->us_serverstate = UPAPSS_BADAUTH;
}


/*
 * upap_lowerup - The lower layer is up.
 *
 * Start authenticating if pending.
 */
static void
upap_lowerup(unit)
    int unit;
{
    upap_state *u = &upap[unit];

    if (u->us_clientstate == UPAPCS_INITIAL)
	u->us_clientstate = UPAPCS_CLOSED;
    else if (u->us_clientstate == UPAPCS_PENDING) {
	upap_sauthreq(u);	/* send an auth-request */
    }

    if (u->us_serverstate == UPAPSS_INITIAL)
	u->us_serverstate = UPAPSS_CLOSED;
    else if (u->us_serverstate == UPAPSS_PENDING) {
	u->us_serverstate = UPAPSS_LISTEN;
	if (u->us_reqtimeout > 0)
	    TIMEOUT(upap_reqtimeout, u, u->us_reqtimeout);
    }
}


/*
 * upap_lowerdown - The lower layer is down.
 *
 * Cancel all timeouts.
 */
static void
upap_lowerdown(unit)
    int unit;
{
    upap_state *u = &upap[unit];

    if (u->us_clientstate == UPAPCS_AUTHREQ)	/* Timeout pending? */
	UNTIMEOUT(upap_timeout, u);	/* Cancel timeout */
    if (u->us_serverstate == UPAPSS_LISTEN && u->us_reqtimeout > 0)
	UNTIMEOUT(upap_reqtimeout, u);

    u->us_clientstate = UPAPCS_INITIAL;
    u->us_serverstate = UPAPSS_INITIAL;
}


/*
 * upap_protrej - Peer doesn't speak this protocol.
 *
 * This shouldn't happen.  In any case, pretend lower layer went down.
 */
static void
upap_protrej(unit)
    int unit;
{
    upap_state *u = &upap[unit];

    if (u->us_clientstate == UPAPCS_AUTHREQ) {
	syslog(LOG_ERR, "PAP authentication failed due to protocol-reject");
	auth_withpeer_fail(unit, PPP_PAP);
    }
    if (u->us_serverstate == UPAPSS_LISTEN) {
	syslog(LOG_ERR, "PAP authentication of peer failed (protocol-reject)");
	auth_peer_fail(unit, PPP_PAP);
    }
    upap_lowerdown(unit);
}


/*
 * upap_input - Input UPAP packet.
 */
static void
upap_input(unit, inpacket, l)
    int unit;
    u_char *inpacket;
    int l;
{
    upap_state *u = &upap[unit];
    u_char *inp;
    u_char code, id;
    int len;

    /*
     * Parse header (code, id and length).
     * If packet too short, drop it.
     */
    inp = inpacket;
    if (l < UPAP_HEADERLEN) {
	UPAPDEBUG((LOG_INFO, "pap_input: rcvd short header."));
	return;
    }
    GETCHAR(code, inp);
    GETCHAR(id, inp);
    GETSHORT(len, inp);
    if (len < UPAP_HEADERLEN) {
	UPAPDEBUG((LOG_INFO, "pap_input: rcvd illegal length."));
	return;
    }
    if (len > l) {
	UPAPDEBUG((LOG_INFO, "pap_input: rcvd short packet."));
	return;
    }
    len -= UPAP_HEADERLEN;

    /*
     * Action depends on code.
     */
    switch (code) {
    case UPAP_AUTHREQ:
	upap_rauthreq(u, inp, id, len);
	break;

    case UPAP_AUTHACK:
	upap_rauthack(u, inp, id, len);
	break;

    case UPAP_AUTHNAK:
	upap_rauthnak(u, inp, id, len);
	break;

    default:				/* XXX Need code reject */
	break;
    }
}


/*
 * upap_rauth - Receive Authenticate.
 */
static void
upap_rauthreq(u, inp, id, len)
    upap_state *u;
    u_char *inp;
    int id;
    int len;
{
    u_char ruserlen, rpasswdlen;
    char *ruser, *rpasswd;
    int retcode;
    char *msg;
    int msglen;

    UPAPDEBUG((LOG_INFO, "pap_rauth: Rcvd id %d.", id));

    if (u->us_serverstate < UPAPSS_LISTEN)
	return;

    /*
     * If we receive a duplicate authenticate-request, we are
     * supposed to return the same status as for the first request.
     */
    if (u->us_serverstate == UPAPSS_OPEN) {
	upap_sresp(u, UPAP_AUTHACK, id, "", 0);	/* return auth-ack */
	return;
    }
    if (u->us_serverstate == UPAPSS_BADAUTH) {
	upap_sresp(u, UPAP_AUTHNAK, id, "", 0);	/* return auth-nak */
	return;
    }

    /*
     * Parse user/passwd.
     */
    if (len < sizeof (u_char)) {
	UPAPDEBUG((LOG_INFO, "pap_rauth: rcvd short packet."));
	return;
    }
    GETCHAR(ruserlen, inp);
    len -= sizeof (u_char) + ruserlen + sizeof (u_char);
    if (len < 0) {
	UPAPDEBUG((LOG_INFO, "pap_rauth: rcvd short packet."));
	return;
    }
    ruser = (char *) inp;
    INCPTR(ruserlen, inp);
    GETCHAR(rpasswdlen, inp);
    if (len < rpasswdlen) {
	UPAPDEBUG((LOG_INFO, "pap_rauth: rcvd short packet."));
	return;
    }
    rpasswd = (char *) inp;

    /*
     * Check the username and password given.
     */
    retcode = check_passwd(u->us_unit, ruser, ruserlen, rpasswd,
			   rpasswdlen, &msg, &msglen);
    BZERO(rpasswd, rpasswdlen);

    upap_sresp(u, retcode, id, msg, msglen);

    if (retcode == UPAP_AUTHACK) {
	u->us_serverstate = UPAPSS_OPEN;
	auth_peer_success(u->us_unit, PPP_PAP, ruser, ruserlen);
    } else {
	u->us_serverstate = UPAPSS_BADAUTH;
	auth_peer_fail(u->us_unit, PPP_PAP);
    }

    if (u->us_reqtimeout > 0)
	UNTIMEOUT(upap_reqtimeout, u);
}


/*
 * upap_rauthack - Receive Authenticate-Ack.
 */
static void
upap_rauthack(u, inp, id, len)
    upap_state *u;
    u_char *inp;
    int id;
    int len;
{
    u_char msglen;
    char *msg;

    UPAPDEBUG((LOG_INFO, "pap_rauthack: Rcvd id %d.", id));
    if (u->us_clientstate != UPAPCS_AUTHREQ) /* XXX */
	return;

    /*
     * Parse message.
     */
    if (len < sizeof (u_char)) {
	UPAPDEBUG((LOG_INFO, "pap_rauthack: rcvd short packet."));
	return;
    }
    GETCHAR(msglen, inp);
    len -= sizeof (u_char);
    if (len < msglen) {
	UPAPDEBUG((LOG_INFO, "pap_rauthack: rcvd short packet."));
	return;
    }
    msg = (char *) inp;
    PRINTMSG(msg, msglen);

    u->us_clientstate = UPAPCS_OPEN;

    auth_withpeer_success(u->us_unit, PPP_PAP);
}


/*
 * upap_rauthnak - Receive Authenticate-Nakk.
 */
static void
upap_rauthnak(u, inp, id, len)
    upap_state *u;
    u_char *inp;
    int id;
    int len;
{
    u_char msglen;
    char *msg;

    UPAPDEBUG((LOG_INFO, "pap_rauthnak: Rcvd id %d.", id));
    if (u->us_clientstate != UPAPCS_AUTHREQ) /* XXX */
	return;

    /*
     * Parse message.
     */
    if (len < sizeof (u_char)) {
	UPAPDEBUG((LOG_INFO, "pap_rauthnak: rcvd short packet."));
	return;
    }
    GETCHAR(msglen, inp);
    len -= sizeof (u_char);
    if (len < msglen) {
	UPAPDEBUG((LOG_INFO, "pap_rauthnak: rcvd short packet."));
	return;
    }
    msg = (char *) inp;
    PRINTMSG(msg, msglen);

    u->us_clientstate = UPAPCS_BADAUTH;

    syslog(LOG_ERR, "PAP authentication failed");
    auth_withpeer_fail(u->us_unit, PPP_PAP);
}


/*
 * upap_sauthreq - Send an Authenticate-Request.
 */
static void
upap_sauthreq(u)
    upap_state *u;
{
    u_char *outp;
    int outlen;

    outlen = UPAP_HEADERLEN + 2 * sizeof (u_char) +
	u->us_userlen + u->us_passwdlen;
    outp = outpacket_buf;
    
    MAKEHEADER(outp, PPP_PAP);

    PUTCHAR(UPAP_AUTHREQ, outp);
    PUTCHAR(++u->us_id, outp);
    PUTSHORT(outlen, outp);
    PUTCHAR(u->us_userlen, outp);
    BCOPY(u->us_user, outp, u->us_userlen);
    INCPTR(u->us_userlen, outp);
    PUTCHAR(u->us_passwdlen, outp);
    BCOPY(u->us_passwd, outp, u->us_passwdlen);

    output(u->us_unit, outpacket_buf, outlen + PPP_HDRLEN);

    UPAPDEBUG((LOG_INFO, "pap_sauth: Sent id %d.", u->us_id));

    TIMEOUT(upap_timeout, u, u->us_timeouttime);
    ++u->us_transmits;
    u->us_clientstate = UPAPCS_AUTHREQ;
}


/*
 * upap_sresp - Send a response (ack or nak).
 */
static void
upap_sresp(u, code, id, msg, msglen)
    upap_state *u;
    u_char code, id;
    char *msg;
    int msglen;
{
    u_char *outp;
    int outlen;

    outlen = UPAP_HEADERLEN + sizeof (u_char) + msglen;
    outp = outpacket_buf;
    MAKEHEADER(outp, PPP_PAP);

    PUTCHAR(code, outp);
    PUTCHAR(id, outp);
    PUTSHORT(outlen, outp);
    PUTCHAR(msglen, outp);
    BCOPY(msg, outp, msglen);
    output(u->us_unit, outpacket_buf, outlen + PPP_HDRLEN);

    UPAPDEBUG((LOG_INFO, "pap_sresp: Sent code %d, id %d.", code, id));
}

/*
 * upap_printpkt - print the contents of a PAP packet.
 */
static char *upap_codenames[] = {
    "AuthReq", "AuthAck", "AuthNak"
};

static int
upap_printpkt(p, plen, printer, arg)
    u_char *p;
    int plen;
    void (*printer)(void *, char *, ...);
    void *arg;
{
    int code, id, len;
    int mlen, ulen, wlen;
    char *user, *pwd, *msg;
    u_char *pstart;

    if (plen < UPAP_HEADERLEN)
	return 0;
    pstart = p;
    GETCHAR(code, p);
    GETCHAR(id, p);
    GETSHORT(len, p);
    if (len < UPAP_HEADERLEN || len > plen)
	return 0;

    if (code >= 1 && code <= sizeof(upap_codenames) / sizeof(char *))
	printer(arg, " %s", upap_codenames[code-1]);
    else
	printer(arg, " code=0x%x", code);
    printer(arg, " id=0x%x", id);
    len -= UPAP_HEADERLEN;
    switch (code) {
    case UPAP_AUTHREQ:
	if (len < 1)
	    break;
	ulen = p[0];
	if (len < ulen + 2)
	    break;
	wlen = p[ulen + 1];
	if (len < ulen + wlen + 2)
	    break;
	user = (char *) (p + 1);
	pwd = (char *) (p + ulen + 2);
	p += ulen + wlen + 2;
	len -= ulen + wlen + 2;
	printer(arg, " user=");
	print_string(user, ulen, printer, arg);
	printer(arg, " password=");
	print_string(pwd, wlen, printer, arg);
	break;
    case UPAP_AUTHACK:
    case UPAP_AUTHNAK:
	if (len < 1)
	    break;
	mlen = p[0];
	if (len < mlen + 1)
	    break;
	msg = (char *) (p + 1);
	p += mlen + 1;
	len -= mlen + 1;
	printer(arg, " ");
	print_string(msg, mlen, printer, arg);
	break;
    }

    /* print the rest of the bytes in the packet */
    for (; len > 0; --len) {
	GETCHAR(code, p);
	printer(arg, " %.2x", code);
    }

    return p - pstart;
}
@


1.9
log
@license update of CMU parts.  due to communication with wcw+@@andrew.cmu.edu,
pushed for by tygs@@netcologne.de.  Apparently we also now known how to talk
to the lawyers there, if we were so mad.  Note that a few other copyright
issues in pppd still remain, so this does not close this story.
@
text
@d1 1
a1 1
/*	$OpenBSD: upap.c,v 1.8 2002/02/17 19:42:38 millert Exp $	*/
a43 8

#ifndef lint
#if 0
static char rcsid[] = "Id: upap.c,v 1.11 1997/04/30 05:59:56 paulus Exp";
#else
static char rcsid[] = "$OpenBSD: upap.c,v 1.8 2002/02/17 19:42:38 millert Exp $";
#endif
#endif
@


1.8
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: upap.c,v 1.7 2002/02/16 21:28:07 millert Exp $	*/
d6 1
a6 2
 * Copyright (c) 1989 Carnegie Mellon University.
 * All rights reserved.
d8 35
a42 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Carnegie Mellon University.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d49 1
a49 1
static char rcsid[] = "$OpenBSD: upap.c,v 1.7 2002/02/16 21:28:07 millert Exp $";
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: upap.c,v 1.6 1998/01/17 20:30:30 millert Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: upap.c,v 1.6 1998/01/17 20:30:30 millert Exp $";
d51 1
a51 2
static int  upap_printpkt __P((u_char *, int,
			       void (*)(void *, char *, ...), void *));
@


1.6
log
@ppp-2.3.3 + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: upap.c,v 1.5 1997/09/05 04:32:46 millert Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: upap.c,v 1.5 1997/09/05 04:32:46 millert Exp $";
d46 5
a50 5
static void upap_init __P((int));
static void upap_lowerup __P((int));
static void upap_lowerdown __P((int));
static void upap_input __P((int, u_char *, int));
static void upap_protrej __P((int));
d52 1
a52 1
			       void (*) __P((void *, char *, ...)), void *));
d74 7
a80 7
static void upap_timeout __P((void *));
static void upap_reqtimeout __P((void *));
static void upap_rauthreq __P((upap_state *, u_char *, int, int));
static void upap_rauthack __P((upap_state *, u_char *, int, int));
static void upap_rauthnak __P((upap_state *, u_char *, int, int));
static void upap_sauthreq __P((upap_state *));
static void upap_sresp __P((upap_state *, int, int, char *, int));
d560 1
a560 1
    void (*printer) __P((void *, char *, ...));
@


1.5
log
@ppp 2.3.1
@
text
@d1 1
a1 1
/*	$OpenBSD: upap.c,v 1.4 1996/12/23 13:22:49 mickey Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: upap.c,v 1.4 1996/12/23 13:22:49 mickey Exp $";
d74 2
a75 2
static void upap_timeout __P((caddr_t));
static void upap_reqtimeout __P((caddr_t));
d156 1
a156 1
	TIMEOUT(upap_reqtimeout, (caddr_t) u, u->us_reqtimeout);
d165 1
a165 1
    caddr_t arg;
d189 1
a189 1
    caddr_t arg;
d223 1
a223 1
	    TIMEOUT(upap_reqtimeout, (caddr_t) u, u->us_reqtimeout);
d240 1
a240 1
	UNTIMEOUT(upap_timeout, (caddr_t) u);	/* Cancel timeout */
d242 1
a242 1
	UNTIMEOUT(upap_reqtimeout, (caddr_t) u);
d404 1
a404 1
	UNTIMEOUT(upap_reqtimeout, (caddr_t) u);
d516 1
a516 1
    TIMEOUT(upap_timeout, (caddr_t) u, u->us_timeouttime);
@


1.4
log
@pppd 2.3b3 import. some minor buf oflow fixes and so.
try it out ppl, but i've got it running talking to cisco w/ all the AFs
enabled in kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: upap.c,v 1.3 1996/07/20 12:02:14 joshd Exp $	*/
d23 5
a27 1
static char rcsid[] = "$OpenBSD: upap.c,v 1.3 1996/07/20 12:02:14 joshd Exp $";
d52 1
a52 1
                               void (*) __P((void *, char *, ...)), void *));
a69 1

d391 1
a392 1
    BZERO(rpasswd, rpasswdlen);
d397 1
a397 1
        auth_peer_success(u->us_unit, PPP_PAP, ruser, ruserlen);
@


1.3
log
@Update pppd to 2.3a4:
Add redo option error-reporting, add PAM, add microsoft compatibility
kludges, bzero stuff at important places, add one or two options
other generic enhancements.  From: Paul.Mackerras@@cs.anu.edu.au
@
text
@d1 1
a1 1
/*	$OpenBSD: upap.c,v 1.2 1996/03/25 15:55:58 niklas Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: upap.c,v 1.2 1996/03/25 15:55:58 niklas Exp $";
d289 1
a289 1
	UPAPDEBUG((LOG_INFO, "upap_input: rcvd short header."));
d296 1
a296 1
	UPAPDEBUG((LOG_INFO, "upap_input: rcvd illegal length."));
d300 1
a300 1
	UPAPDEBUG((LOG_INFO, "upap_input: rcvd short packet."));
d343 1
a343 1
    UPAPDEBUG((LOG_INFO, "upap_rauth: Rcvd id %d.", id));
d365 1
a365 1
	UPAPDEBUG((LOG_INFO, "upap_rauth: rcvd short packet."));
d371 1
a371 1
	UPAPDEBUG((LOG_INFO, "upap_rauth: rcvd short packet."));
d378 1
a378 1
	UPAPDEBUG((LOG_INFO, "upap_rauth: rcvd short packet."));
d418 1
a418 1
    UPAPDEBUG((LOG_INFO, "upap_rauthack: Rcvd id %d.", id));
d426 1
a426 1
	UPAPDEBUG((LOG_INFO, "upap_rauthack: rcvd short packet."));
d432 1
a432 1
	UPAPDEBUG((LOG_INFO, "upap_rauthack: rcvd short packet."));
d457 1
a457 1
    UPAPDEBUG((LOG_INFO, "upap_rauthnak: Rcvd id %d.", id));
d465 1
a465 1
	UPAPDEBUG((LOG_INFO, "upap_rauthnak: rcvd short packet."));
d471 1
a471 1
	UPAPDEBUG((LOG_INFO, "upap_rauthnak: rcvd short packet."));
d511 1
a511 1
    UPAPDEBUG((LOG_INFO, "upap_sauth: Sent id %d.", u->us_id));
d543 1
a543 1
    UPAPDEBUG((LOG_INFO, "upap_sresp: Sent code %d, id %d.", code, id));
d609 1
a609 1
	printer(arg, "msg=");
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD$";
d39 11
d51 16
a66 3
    PPP_PAP, upap_init, upap_input, upap_protrej,
    upap_lowerup, upap_lowerdown, NULL, NULL,
    upap_printpkt, NULL, 1, "PAP", NULL, NULL
d83 1
a83 1
void
d203 1
a203 1
void
d230 1
a230 1
void
d251 1
a251 1
void
d272 1
a272 1
void
d389 1
d394 1
a394 1
	auth_peer_success(u->us_unit, PPP_PAP);
d549 1
a549 1
char *upap_codenames[] = {
d553 1
a553 1
int
@


1.1
log
@Initial revision
@
text
@d1 2
d23 1
a23 1
static char rcsid[] = "$Id: upap.c,v 1.6 1995/07/04 23:48:10 paulus Exp $";
d39 5
a45 1

@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
