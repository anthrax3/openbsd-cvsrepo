head	1.54;
access;
symbols
	OPENBSD_6_1:1.54.0.4
	OPENBSD_6_1_BASE:1.54
	OPENBSD_6_0:1.54.0.2
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.51.0.6
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.51.0.2
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.49.0.16
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.49.0.14
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.49.0.10
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.49.0.8
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.49.0.6
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.4
	OPENBSD_5_0:1.49.0.2
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.48.0.6
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.48.0.4
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.47.0.10
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.47.0.6
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.47.0.4
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.45.0.8
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.45.0.6
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.45.0.4
	OPENBSD_3_9_BASE:1.45
	OPENBSD_3_8:1.45.0.2
	OPENBSD_3_8_BASE:1.45
	OPENBSD_3_7:1.44.0.6
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.44.0.4
	OPENBSD_3_6_BASE:1.44
	OPENBSD_3_5:1.44.0.2
	OPENBSD_3_5_BASE:1.44
	OPENBSD_3_4:1.42.0.2
	OPENBSD_3_4_BASE:1.42
	OPENBSD_3_3:1.39.0.4
	OPENBSD_3_3_BASE:1.39
	OPENBSD_3_2:1.39.0.2
	OPENBSD_3_2_BASE:1.39
	OPENBSD_3_1:1.34.0.2
	OPENBSD_3_1_BASE:1.34
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9_BASE:1.30
	OPENBSD_2_9:1.30.0.2
	OPENBSD_2_8:1.29.0.2
	OPENBSD_2_8_BASE:1.29
	OPENBSD_2_7:1.28.0.2
	OPENBSD_2_7_BASE:1.28
	OPENBSD_2_6:1.27.0.2
	OPENBSD_2_6_BASE:1.27
	OPENBSD_2_5:1.25.0.4
	OPENBSD_2_5_BASE:1.25
	OPENBSD_2_4:1.25.0.2
	OPENBSD_2_4_BASE:1.25
	OPENBSD_2_3:1.21.0.2
	OPENBSD_2_3_BASE:1.21
	OPENBSD_2_2:1.19.0.2
	OPENBSD_2_2_BASE:1.19
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.54
date	2016.03.17.19.40.43;	author krw;	state Exp;
branches;
next	1.53;
commitid	aCmYZrmRmWHLuztW;

1.53
date	2015.12.06.12.00.16;	author tobias;	state Exp;
branches;
next	1.52;
commitid	CoyY8UEEpJPwBza5;

1.52
date	2015.10.26.11.10.53;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	DbsU1wQomSTexhPS;

1.51
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	Uu5nFG3wCl0LACBb;

1.50
date	2014.10.08.04.51.29;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	YErr3g6fMQa31Ok4;

1.49
date	2011.04.30.18.49.38;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.02.15.19.39;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.04.14.59.45;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.03.03.42.16;	author djm;	state Exp;
branches;
next	1.44;

1.44
date	2004.02.09.19.59.15;	author canacar;	state Exp;
branches;
next	1.43;

1.43
date	2004.02.08.07.09.56;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2003.04.25.23.24.04;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2003.04.14.03.14.59;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2003.04.04.20.25.07;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2002.07.29.22.02.38;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.01.19.31.37;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.26.09.25.21;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.08.22.30.55;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.06.19.35.26;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2002.02.16.21.28.07;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.05.09.58.13;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.15.19.56.06;	author deraadt;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2001.03.09.03.24.09;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2000.09.15.07.13.51;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.12.09.46.59;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	99.08.06.20.41.07;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.05.03.21.38.08;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	98.07.12.04.34.41;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	98.07.10.08.06.45;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.07.09.06.33.28;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	98.05.08.04.52.27;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	98.01.17.20.30.25;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	97.11.14.00.16.14;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.10.25.05.09.56;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	97.09.05.04.32.42;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.08.04.19.26.18;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.07.25.20.12.16;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.03.29.04.17.22;	author dgregor;	state Exp;
branches;
next	1.14;

1.14
date	97.01.23.02.18.05;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	96.12.23.13.22.44;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	96.12.22.03.29.01;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.08.20.04.48.27;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.07.27.12.38.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.07.20.12.02.11;	author joshd;	state Exp;
branches;
next	1.8;

1.8
date	96.06.17.07.20.53;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.11.15.41.24;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.23.41.21;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.03.25.15.55.49;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.04.19.39.39;	author hannken;	state Exp;
branches;
next	1.3;

1.3
date	96.01.07.09.55.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.28.14.05.06;	author hannken;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.59;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.59;	author deraadt;	state Exp;
branches;
next	;

1.31.2.1
date	2002.07.30.07.29.13;	author miod;	state Exp;
branches;
next	;

1.34.2.1
date	2002.07.30.14.46.12;	author jason;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Last parameter to execl[e]() functions *must* be cast to a pointer.
Just NULL is not good practise as NULL is theoretically allowed to
be an integer rather than a pointer.

Use (char *)NULL consistently instead of scattering a few (char *)0
and (void *)NULL into the mix.

Prompted by and probably ok deraadt@@ millert@@ kettenis@@

Definitely ok mestre@@ ratchov@@
@
text
@/*	$OpenBSD: main.c,v 1.53 2015/12/06 12:00:16 tobias Exp $	*/

/*
 * main.c - Point-to-Point Protocol main module
 *
 * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name "Carnegie Mellon University" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For permission or any legal
 *    details, please contact
 *      Office of Technology Transfer
 *      Carnegie Mellon University
 *      5000 Forbes Avenue
 *      Pittsburgh, PA  15213-3890
 *      (412) 268-4387, fax: (412) 268-7395
 *      tech-transfer@@andrew.cmu.edu
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Computing Services
 *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
 *
 * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <net/if.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <syslog.h>
#include <netdb.h>
#include <utmp.h>
#include <pwd.h>

#include "pppd.h"
#include "magic.h"
#include "fsm.h"
#include "lcp.h"
#include "ipcp.h"
#include "upap.h"
#include "chap.h"
#include "ccp.h"
#include "pathnames.h"
#include "patchlevel.h"

#ifdef CBCP_SUPPORT
#include "cbcp.h"
#endif

#if defined(SUNOS4)
extern char *strerror();
#endif

#ifdef AT_CHANGE
#include "atcp.h"
#endif

/* interface vars */
char ifname[IFNAMSIZ];		/* Interface name */
int ifunit;			/* Interface unit number */

char hostname[HOST_NAME_MAX+1];	/* Our hostname */
static char default_devnam[PATH_MAX];	/* name of default device */
static pid_t pid;		/* Our pid */
static uid_t uid;		/* Our real user-id */
static int conn_running;	/* we have a [dis]connector running */
static int crashed = 0;

int ttyfd = -1;			/* Serial port file descriptor */
mode_t tty_mode = -1;		/* Original access permissions to tty */
int baud_rate;			/* Actual bits/second for serial device */
int hungup;			/* terminal has been hung up */
int privileged;			/* we're running as real uid root */
int need_holdoff;		/* need holdoff period before restarting */
int detached;			/* have detached from terminal */

int phase;			/* where the link is at */
int kill_link;
int open_ccp_flag;

char **script_env;		/* Env. variable values for scripts */
int s_env_nalloc;		/* # words avail at script_env */

u_char outpacket_buf[PPP_MRU+PPP_HDRLEN]; /* buffer for outgoing packet */
u_char inpacket_buf[PPP_MRU+PPP_HDRLEN]; /* buffer for incoming packet */

static int n_children;		/* # child processes still running */

static int locked;		/* lock() has succeeded */

char *no_ppp_msg = "Sorry - this system lacks PPP kernel support\n";

/* Prototypes for procedures local to this file. */

static void cleanup(void);
static void close_tty(void);
static void get_input(void);
static void calltimeout(void);
static struct timeval *timeleft(struct timeval *);
static void kill_my_pg(int);
static void hup(int);
static void term(int);
static void chld(int);
static void toggle_debug(int);
static void open_ccp(int);
static void bad_signal(int);
static void holdoff_end(void *);
static int device_script(char *, int, int);
static void reap_kids(void);
static void pr_log(void *, char *, ...);

extern	char	*ttyname(int);
extern	char	*getlogin(void);
int main(int, char *[]);

#ifdef ultrix
#undef	O_NONBLOCK
#define	O_NONBLOCK	O_NDELAY
#endif

#ifdef ULTRIX
#define setlogmask(x)
#endif

/*
 * PPP Data Link Layer "protocol" table.
 * One entry per supported protocol.
 * The last entry must be NULL.
 */
struct protent *protocols[] = {
    &lcp_protent,
    &pap_protent,
    &chap_protent,
#ifdef CBCP_SUPPORT
    &cbcp_protent,
#endif
    &ipcp_protent,
    &ccp_protent,
#ifdef AT_CHANGE
    &atcp_protent,
#endif
    NULL
};

int
main(argc, argv)
    int argc;
    char *argv[];
{
    int i, fdflags;
    struct sigaction sa;
    char *p;
    struct passwd *pw;
    struct timeval timo;
    sigset_t mask;
    struct protent *protp;
    struct stat statbuf;
    char numbuf[16];

    phase = PHASE_INITIALIZE;
    p = ttyname(0);
    if (p)
	strlcpy(devnam, p, PATH_MAX);
    strlcpy(default_devnam, devnam, sizeof default_devnam);

    script_env = NULL;

    /* Initialize syslog facilities */
#ifdef ULTRIX
    openlog("pppd", LOG_PID);
#else
    openlog("pppd", LOG_PID | LOG_NDELAY, LOG_PPP);
    setlogmask(LOG_UPTO(LOG_INFO));
#endif

    if (gethostname(hostname, sizeof hostname) < 0 ) {
	option_error("Couldn't get hostname: %m");
	die(1);
    }

    uid = getuid();
    privileged = uid == 0;
    snprintf(numbuf, sizeof numbuf, "%u", uid);
    script_setenv("UID", numbuf);

    /*
     * Initialize to the standard option set, then parse, in order,
     * the system options file, the user's options file,
     * the tty's options file, and the command line arguments.
     */
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
	(*protp->init)(0);

    if (!options_from_file(_PATH_SYSOPTIONS, !privileged, 0, 1)
	|| !options_from_user())
	exit(1);
    scan_args(argc-1, argv+1);	/* look for tty name on command line */
    if (!options_for_tty()
	|| !parse_args(argc-1, argv+1))
	exit(1);

    /*
     * Check that we are running as root.
     */
    if (geteuid() != 0) {
	option_error("must be root to run %s, since it is not setuid-root",
		     argv[0]);
	die(1);
    }

    if (!ppp_available()) {
	option_error(no_ppp_msg);
	exit(1);
    }

    /*
     * Check that the options given are valid and consistent.
     */
    sys_check_options();
    auth_check_options();
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
	if (protp->check_options != NULL)
	    (*protp->check_options)();
    if (demand && connector == 0) {
	option_error("connect script required for demand-dialling\n");
	exit(1);
    }

    script_setenv("DEVICE", devnam);
    snprintf(numbuf, sizeof numbuf, "%d", baud_rate);
    script_setenv("SPEED", numbuf);

    /*
     * If the user has specified the default device name explicitly,
     * pretend they hadn't.
     */
    if (!default_device && strcmp(devnam, default_devnam) == 0)
	default_device = 1;
    if (default_device)
	nodetach = 1;

    /*
     * Initialize system-dependent stuff and magic number package.
     */
    sys_init();
    magic_init();
    if (debug)
	setlogmask(LOG_UPTO(LOG_DEBUG));

    /*
     * Detach ourselves from the terminal, if required,
     * and identify who is running us.
     */
    if (nodetach == 0)
	detach();
    pid = getpid();
    p = getlogin();
    if (p == NULL) {
	pw = getpwuid(uid);
	if (pw != NULL && pw->pw_name != NULL)
	    p = pw->pw_name;
	else
	    p = "(unknown)";
    }
    syslog(LOG_NOTICE, "pppd %s.%d%s started by %s, uid %u",
	   VERSION, PATCHLEVEL, IMPLEMENTATION, p, uid);

    /*
     * Compute mask of all interesting signals and install signal handlers
     * for each.  Only one signal handler may be active at a time.  Therefore,
     * all other signals should be masked when any handler is executing.
     */
    sigemptyset(&mask);
    sigaddset(&mask, SIGHUP);
    sigaddset(&mask, SIGINT);
    sigaddset(&mask, SIGTERM);
    sigaddset(&mask, SIGCHLD);

#define SIGNAL(s, handler)	{ \
	sa.sa_handler = handler; \
	if (sigaction(s, &sa, NULL) < 0) { \
	    syslog(LOG_ERR, "Couldn't establish signal handler (%d): %m", s); \
	    die(1); \
	} \
    }

    sa.sa_mask = mask;
    sa.sa_flags = 0;
    SIGNAL(SIGHUP, hup);		/* Hangup */
    SIGNAL(SIGINT, term);		/* Interrupt */
    SIGNAL(SIGTERM, term);		/* Terminate */
    SIGNAL(SIGCHLD, chld);

    SIGNAL(SIGUSR1, toggle_debug);	/* Toggle debug flag */
    SIGNAL(SIGUSR2, open_ccp);		/* Reopen CCP */

    /*
     * Install a handler for other signals which would otherwise
     * cause pppd to exit without cleaning up.
     */
    SIGNAL(SIGABRT, bad_signal);
    SIGNAL(SIGALRM, bad_signal);
    SIGNAL(SIGFPE, bad_signal);
    SIGNAL(SIGILL, bad_signal);
    SIGNAL(SIGPIPE, bad_signal);
    SIGNAL(SIGQUIT, bad_signal);
#if SIGSEGV_CHECK
    SIGNAL(SIGSEGV, bad_signal);
#endif
#ifdef SIGBUS
    SIGNAL(SIGBUS, bad_signal);
#endif
#ifdef SIGEMT
    SIGNAL(SIGEMT, bad_signal);
#endif
#ifdef SIGPOLL
    SIGNAL(SIGPOLL, bad_signal);
#endif
#ifdef SIGPROF
    SIGNAL(SIGPROF, bad_signal);
#endif
#ifdef SIGSYS
    SIGNAL(SIGSYS, bad_signal);
#endif
#ifdef SIGTRAP
    SIGNAL(SIGTRAP, bad_signal);
#endif
#ifdef SIGVTALRM
    SIGNAL(SIGVTALRM, bad_signal);
#endif
#ifdef SIGXCPU
    SIGNAL(SIGXCPU, bad_signal);
#endif
#ifdef SIGXFSZ
    SIGNAL(SIGXFSZ, bad_signal);
#endif

    /*
     * Apparently we can get a SIGPIPE when we call syslog, if
     * syslogd has died and been restarted.  Ignoring it seems
     * be sufficient.
     */
    signal(SIGPIPE, SIG_IGN);

    /*
     * If we're doing dial-on-demand, set up the interface now.
     */
    if (demand) {
	/*
	 * Open the loopback channel and set it up to be the ppp interface.
	 */
	open_ppp_loopback();

	syslog(LOG_INFO, "Using interface ppp%d", ifunit);
	(void) snprintf(ifname, sizeof ifname, "ppp%d", ifunit);
	script_setenv("IFNAME", ifname);

	/*
	 * Configure the interface and mark it up, etc.
	 */
	demand_conf();
    }

    for (;;) {

	need_holdoff = 1;

	if (demand) {
	    /*
	     * Don't do anything until we see some activity.
	     */
	    phase = PHASE_DORMANT;
	    kill_link = 0;
	    demand_unblock();
	    for (;;) {
		wait_loop_output(timeleft(&timo));
		calltimeout();
		if (kill_link) {
		    if (!persist)
			die(0);
		    kill_link = 0;
		}
		if (get_loop_output())
		    break;
		reap_kids();
	    }

	    /*
	     * Now we want to bring up the link.
	     */
	    demand_drop();
	    syslog(LOG_INFO, "Starting link");
	}

	/*
	 * Lock the device if we've been asked to.
	 */
	if (lockflag && !default_device) {
	    if (lock(devnam) < 0)
		goto fail;
	    locked = 1;
	}

	/*
	 * Open the serial device and set it up to be the ppp interface.
	 * First we open it in non-blocking mode so we can set the
	 * various termios flags appropriately.  If we aren't dialling
	 * out and we want to use the modem lines, we reopen it later
	 * in order to wait for the carrier detect signal from the modem.
	 */
	while ((ttyfd = open(devnam, O_NONBLOCK | O_RDWR, 0)) < 0) {
	    if (errno != EINTR)
		syslog(LOG_ERR, "Failed to open %s: %m", devnam);
	    if (!persist || errno != EINTR)
		goto fail;
	}
	if ((fdflags = fcntl(ttyfd, F_GETFL)) == -1
	    || fcntl(ttyfd, F_SETFL, fdflags & ~O_NONBLOCK) < 0)
	    syslog(LOG_WARNING,
		   "Couldn't reset non-blocking mode on device: %m");

	hungup = 0;
	kill_link = 0;

	/*
	 * Do the equivalent of `mesg n' to stop broadcast messages.
	 */
	if (fstat(ttyfd, &statbuf) < 0
	    || fchmod(ttyfd, statbuf.st_mode & ~(S_IWGRP | S_IWOTH)) < 0) {
	    syslog(LOG_WARNING,
		   "Couldn't restrict write permissions to %s: %m", devnam);
	} else
	    tty_mode = statbuf.st_mode;

	/* run connection script */
	if (connector && connector[0]) {
	    MAINDEBUG((LOG_INFO, "Connecting with <%s>", connector));

	    /*
	     * Set line speed, flow control, etc.
	     * On most systems we set CLOCAL for now so that we can talk
	     * to the modem before carrier comes up.  But this has the
	     * side effect that we might miss it if CD drops before we
	     * get to clear CLOCAL below.  On systems where we can talk
	     * successfully to the modem with CLOCAL clear and CD down,
	     * we can clear CLOCAL at this point.
	     */
	    set_up_tty(ttyfd, (modem_chat == 0));

	    /* drop dtr to hang up in case modem is off hook */
	    if (!default_device && modem) {
		setdtr(ttyfd, FALSE);
		sleep(1);
		setdtr(ttyfd, TRUE);
	    }

	    if (device_script(connector, ttyfd, ttyfd) < 0) {
		syslog(LOG_ERR, "Connect script failed");
		setdtr(ttyfd, FALSE);
		goto fail;
	    }

	    syslog(LOG_INFO, "Serial connection established.");
	    sleep(1);		/* give it time to set up its terminal */
	}

	set_up_tty(ttyfd, 0);

	/* reopen tty if necessary to wait for carrier */
	if (connector == NULL && modem) {
	    while ((i = open(devnam, O_RDWR)) < 0) {
		if (errno != EINTR)
		    syslog(LOG_ERR, "Failed to reopen %s: %m", devnam);
		if (!persist || errno != EINTR || hungup || kill_link)
		    goto fail;
	    }
	    close(i);
	}

	/* run welcome script, if any */
	if (welcomer && welcomer[0]) {
	    if (device_script(welcomer, ttyfd, ttyfd) < 0)
		syslog(LOG_WARNING, "Welcome script failed");
	}

	/* set up the serial device as a ppp interface */
	establish_ppp(ttyfd);

	if (!demand) {

	    syslog(LOG_INFO, "Using interface ppp%d", ifunit);
	    (void) snprintf(ifname, sizeof ifname, "ppp%d", ifunit);
	    script_setenv("IFNAME", ifname);
	}

	/*
	 * Start opening the connection and wait for
	 * incoming events (reply, timeout, etc.).
	 */
	syslog(LOG_NOTICE, "Connect: %s <--> %s", ifname, devnam);
	lcp_lowerup(0);
	lcp_open(0);		/* Start protocol */
	for (phase = PHASE_ESTABLISH; phase != PHASE_DEAD; ) {
	    wait_input(timeleft(&timo));
	    calltimeout();
	    get_input();
	    if (kill_link) {
		lcp_close(0, "User request");
		kill_link = 0;
	    }
	    if (open_ccp_flag) {
		if (phase == PHASE_NETWORK) {
		    ccp_fsm[0].flags = OPT_RESTART; /* clears OPT_SILENT */
		    (*ccp_protent.open)(0);
		}
		open_ccp_flag = 0;
	    }
	    reap_kids();	/* Don't leave dead kids lying around */
	}

	/*
	 * If we may want to bring the link up again, transfer
	 * the ppp unit back to the loopback.  Set the
	 * real serial device back to its normal mode of operation.
	 */
	clean_check();
	if (demand)
	    restore_loop();
	disestablish_ppp(ttyfd);

	/*
	 * Run disconnector script, if requested.
	 * XXX we may not be able to do this if the line has hung up!
	 */
	if (disconnector && !hungup) {
	    set_up_tty(ttyfd, 1);
	    if (device_script(disconnector, ttyfd, ttyfd) < 0) {
		syslog(LOG_WARNING, "disconnect script failed");
	    } else {
		syslog(LOG_INFO, "Serial link disconnected.");
	    }
	}

    fail:
	if (ttyfd >= 0)
	    close_tty();
	if (locked) {
	    unlock();
	    locked = 0;
	}

	if (!persist)
	    die(1);

	if (holdoff > 0 && need_holdoff) {
	    phase = PHASE_HOLDOFF;
	    TIMEOUT(holdoff_end, NULL, holdoff);
	    do {
		wait_time(timeleft(&timo));
		calltimeout();
		if (kill_link) {
		    if (!persist)
			die(0);
		    kill_link = 0;
		    phase = PHASE_DORMANT; /* allow signal to end holdoff */
		}
		reap_kids();
	    } while (phase == PHASE_HOLDOFF);
	}
    }

    die(0);
    return 0;
}

/*
 * detach - detach us from the controlling terminal.
 */
void
detach()
{
    if (detached)
	return;
    if (daemon(0, 0) < 0) {
	perror("Couldn't detach from controlling terminal");
	die(1);
    }
    detached = 1;
    pid = getpid();
}

/*
 * holdoff_end - called via a timeout when the holdoff period ends.
 */
static void
holdoff_end(arg)
    void *arg;
{
    phase = PHASE_DORMANT;
}

/*
 * get_input - called when incoming data is available.
 */
static void
get_input()
{
    int len, i;
    u_char *p;
    u_short protocol;
    struct protent *protp;

    p = inpacket_buf;	/* point to beginning of packet buffer */

    len = read_packet(inpacket_buf);
    if (len < 0)
	return;

    if (len == 0) {
	syslog(LOG_NOTICE, "Modem hangup");
	hungup = 1;
	lcp_lowerdown(0);	/* serial link is no longer available */
	link_terminated(0);
	return;
    }

    if (debug /*&& (debugflags & DBG_INPACKET)*/)
	log_packet(p, len, "rcvd ", LOG_DEBUG);

    if (len < PPP_HDRLEN) {
	MAINDEBUG((LOG_INFO, "io(): Received short packet."));
	return;
    }

    p += 2;				/* Skip address and control */
    GETSHORT(protocol, p);
    len -= PPP_HDRLEN;

    /*
     * Toss all non-LCP packets unless LCP is OPEN.
     */
    if (protocol != PPP_LCP && lcp_fsm[0].state != OPENED) {
	MAINDEBUG((LOG_INFO,
		   "get_input: Received non-LCP packet when LCP not open."));
	return;
    }

    /*
     * Until we get past the authentication phase, toss all packets
     * except LCP, LQR and authentication packets.
     */
    if (phase <= PHASE_AUTHENTICATE
	&& !(protocol == PPP_LCP || protocol == PPP_LQR
	|| protocol == PPP_PAP || protocol == PPP_CHAP)) {
	MAINDEBUG((LOG_INFO, "get_input: discarding proto 0x%x in phase %d",
		   protocol, phase));
	return;
    }

    /*
     * Upcall the proper protocol input routine.
     */
    for (i = 0; (protp = protocols[i]) != NULL; ++i) {
	if (protp->protocol == protocol && protp->enabled_flag) {
	    (*protp->input)(0, p, len);
	    return;
	}
	if (protocol == (protp->protocol & ~0x8000) && protp->enabled_flag
	    && protp->datainput != NULL) {
	    (*protp->datainput)(0, p, len);
	    return;
	}
    }

    if (debug)
    	syslog(LOG_WARNING, "Unsupported protocol (0x%x) received", protocol);
    lcp_sprotrej(0, p - PPP_HDRLEN, len + PPP_HDRLEN);
}


/*
 * quit - Clean up state and exit (with an error indication).
 */
void
quit()
{
    die(1);
}

/*
 * die - like quit, except we can specify an exit status.
 */
void
die(status)
    int status;
{
    struct syslog_data sdata = SYSLOG_DATA_INIT;

    cleanup();
    syslog_r(LOG_INFO, &sdata, "Exit.");
    _exit(status);
}

/*
 * cleanup - restore anything which needs to be restored before we exit
 */
/* ARGSUSED */
static void
cleanup()
{
    sys_cleanup();

    if (ttyfd >= 0)
	close_tty();

    if (locked)
	unlock();
}

/*
 * close_tty - restore the terminal device and close it.
 */
static void
close_tty()
{
    disestablish_ppp(ttyfd);

    /* drop dtr to hang up */
    if (modem) {
	setdtr(ttyfd, FALSE);
	/*
	 * This sleep is in case the serial port has CLOCAL set by default,
	 * and consequently will reassert DTR when we close the device.
	 */
	sleep(1);
    }

    restore_tty(ttyfd);

    if (tty_mode != (mode_t) -1)
	fchmod(ttyfd, tty_mode);

    close(ttyfd);
    ttyfd = -1;
}


struct	callout {
    struct timeval	c_time;		/* time at which to call routine */
    void		*c_arg;		/* argument to routine */
    void		(*c_func)(void *); /* routine */
    struct		callout *c_next;
};

static struct callout *callout = NULL;	/* Callout list */
static struct timeval timenow;		/* Current time */

/*
 * timeout - Schedule a timeout.
 *
 * Note that this timeout takes the number of seconds, NOT hz (as in
 * the kernel).
 */
void
timeout(func, arg, time)
    void (*func)(void *);
    void *arg;
    int time;
{
    struct callout *newp, *p, **pp;

    MAINDEBUG((LOG_DEBUG, "Timeout %lx:%lx in %d seconds.",
	       (long) func, (long) arg, time));

    /*
     * Allocate timeout.
     */
    if ((newp = (struct callout *) malloc(sizeof(struct callout))) == NULL) {
	syslog(LOG_ERR, "Out of memory in timeout()!");
	die(1);
    }
    newp->c_arg = arg;
    newp->c_func = func;
    gettimeofday(&timenow, NULL);
    newp->c_time.tv_sec = timenow.tv_sec + time;
    newp->c_time.tv_usec = timenow.tv_usec;

    /*
     * Find correct place and link it in.
     */
    for (pp = &callout; (p = *pp); pp = &p->c_next)
	if (newp->c_time.tv_sec < p->c_time.tv_sec
	    || (newp->c_time.tv_sec == p->c_time.tv_sec
		&& newp->c_time.tv_usec < p->c_time.tv_sec))
	    break;
    newp->c_next = p;
    *pp = newp;
}


/*
 * untimeout - Unschedule a timeout.
 */
void
untimeout(func, arg)
    void (*func)(void *);
    void *arg;
{
    struct callout **copp, *freep;

    MAINDEBUG((LOG_DEBUG, "Untimeout %lx:%lx.", (long) func, (long) arg));

    /*
     * Find first matching timeout and remove it from the list.
     */
    for (copp = &callout; (freep = *copp); copp = &freep->c_next)
	if (freep->c_func == func && freep->c_arg == arg) {
	    *copp = freep->c_next;
	    (void) free((char *) freep);
	    break;
	}
}


/*
 * calltimeout - Call any timeout routines which are now due.
 */
static void
calltimeout()
{
    struct callout *p;

    while (callout != NULL) {
	p = callout;

	if (gettimeofday(&timenow, NULL) < 0) {
	    syslog(LOG_ERR, "Failed to get time of day: %m");
	    die(1);
	}
	if (!(p->c_time.tv_sec < timenow.tv_sec
	      || (p->c_time.tv_sec == timenow.tv_sec
		  && p->c_time.tv_usec <= timenow.tv_usec)))
	    break;		/* no, it's not time yet */

	callout = p->c_next;
	(*p->c_func)(p->c_arg);

	free((char *) p);
    }
}


/*
 * timeleft - return the length of time until the next timeout is due.
 */
static struct timeval *
timeleft(tvp)
    struct timeval *tvp;
{
    if (callout == NULL)
	return NULL;

    gettimeofday(&timenow, NULL);
    tvp->tv_sec = callout->c_time.tv_sec - timenow.tv_sec;
    tvp->tv_usec = callout->c_time.tv_usec - timenow.tv_usec;
    if (tvp->tv_usec < 0) {
	tvp->tv_usec += 1000000;
	tvp->tv_sec -= 1;
    }
    if (tvp->tv_sec < 0)
	tvp->tv_sec = tvp->tv_usec = 0;

    return tvp;
}


/*
 * kill_my_pg - send a signal to our process group, and ignore it ourselves.
 */
static void
kill_my_pg(sig)
    int sig;
{
    struct sigaction act, oldact;

    act.sa_handler = SIG_IGN;
    act.sa_flags = 0;
    kill(0, sig);
    sigaction(sig, &act, &oldact);
    sigaction(sig, &oldact, NULL);
}


/*
 * hup - Catch SIGHUP signal.
 *
 * Indicates that the physical layer has been disconnected.
 * We don't rely on this indication; if the user has sent this
 * signal, we just take the link down.
 */
static void
hup(sig)
    int sig;
{
    int save_errno = errno;
    struct syslog_data sdata = SYSLOG_DATA_INIT;

    if (crashed)
	_exit(127);
    syslog_r(LOG_INFO, &sdata, "Hangup (SIGHUP)");
    kill_link = 1;
    if (conn_running)
	/* Send the signal to the [dis]connector process(es) also */
	kill_my_pg(sig);
    errno = save_errno;
}


/*
 * term - Catch SIGTERM signal and SIGINT signal (^C/del).
 *
 * Indicates that we should initiate a graceful disconnect and exit.
 */
/*ARGSUSED*/
static void
term(sig)
    int sig;
{
    int save_errno = errno;
    struct syslog_data sdata = SYSLOG_DATA_INIT;

    if (crashed)
	_exit(127);
    syslog_r(LOG_INFO, &sdata, "Terminating on signal %d.", sig);
    persist = 0;		/* don't try to restart */
    kill_link = 1;
    if (conn_running)
	/* Send the signal to the [dis]connector process(es) also */
	kill_my_pg(sig);
    errno = save_errno;
}


/*
 * chld - Catch SIGCHLD signal.
 * Calls reap_kids to get status for any dead kids.
 */
static void
chld(sig)
    int sig;
{
    int save_errno = errno;

    reap_kids();		/* XXX somewhat unsafe */
    errno = save_errno;
}


/*
 * toggle_debug - Catch SIGUSR1 signal.
 *
 * Toggle debug flag.
 */
/*ARGSUSED*/
static void
toggle_debug(sig)
    int sig;
{
    debug = !debug;
    if (debug) {
	setlogmask(LOG_UPTO(LOG_DEBUG));	/* XXX safe, but wrong */
    } else {
	setlogmask(LOG_UPTO(LOG_WARNING));	/* XXX safe, but wrong */
    }
}


/*
 * open_ccp - Catch SIGUSR2 signal.
 *
 * Try to (re)negotiate compression.
 */
/*ARGSUSED*/
static void
open_ccp(sig)
    int sig;
{
    open_ccp_flag = 1;
}


/*
 * bad_signal - We've caught a fatal signal.  Clean up state and exit.
 */
static void
bad_signal(sig)
    int sig;
{
    struct syslog_data sdata = SYSLOG_DATA_INIT;

    if (crashed)
	_exit(127);
    crashed = 1;
    syslog_r(LOG_ERR, &sdata, "Fatal signal %d", sig);
    if (conn_running)
	kill_my_pg(SIGTERM);
    die(1);					/* XXX unsafe! */
}


/*
 * device_script - run a program to connect or disconnect the
 * serial device.
 */
static int
device_script(program, in, out)
    char *program;
    int in, out;
{
    pid_t pid;
    int status;
    int errfd;
    gid_t gid;
    uid_t uid;

    conn_running = 1;
    pid = fork();

    if (pid < 0) {
	conn_running = 0;
	syslog(LOG_ERR, "Failed to create child process: %m");
	die(1);
    }

    if (pid == 0) {
	sys_close();
	closelog();
	if (in == out) {
	    if (in != 0) {
		dup2(in, 0);
		close(in);
	    }
	    dup2(0, 1);
	} else {
	    if (out == 0)
		out = dup(out);
	    if (in != 0) {
		dup2(in, 0);
		close(in);
	    }
	    if (out != 1) {
		dup2(out, 1);
		close(out);
	    }
	}
	if (nodetach == 0) {
	    close(2);
	    errfd = open(_PATH_CONNERRS, O_WRONLY | O_APPEND | O_CREAT, 0600);
	    if (errfd >= 0 && errfd != 2) {
		dup2(errfd, 2);
		close(errfd);
	    }
	}

	/* revoke privs */
	gid = getgid();
	uid = getuid();
	if (setresgid(gid, gid, gid) == -1 || setresuid(uid, uid, uid) == -1) {
		syslog(LOG_ERR, "revoke privileges: %s", strerror(errno));
		_exit(1);
	}

	execl("/bin/sh", "sh", "-c", program, (char *)NULL);
	syslog(LOG_ERR, "could not exec /bin/sh: %m");
	_exit(99);
	/* NOTREACHED */
    }

    while (waitpid(pid, &status, 0) < 0) {
	if (errno == EINTR)
	    continue;
	syslog(LOG_ERR, "error waiting for (dis)connection process: %m");
	die(1);
    }
    conn_running = 0;

    return (status == 0 ? 0 : -1);
}


/*
 * run-program - execute a program with given arguments,
 * but don't wait for it.
 * If the program can't be executed, logs an error unless
 * must_exist is 0 and the program file doesn't exist.
 */
int
run_program(prog, args, must_exist)
    char *prog;
    char **args;
    int must_exist;
{
    pid_t pid;
    uid_t uid;
    gid_t gid;

    pid = fork();
    if (pid == -1) {
	syslog(LOG_ERR, "Failed to create child process for %s: %m", prog);
	return -1;
    }
    if (pid == 0) {
	int new_fd;

	/* Leave the current location */
	(void) setsid();    /* No controlling tty. */
	(void) umask (S_IRWXG|S_IRWXO);
	(void) chdir ("/"); /* no current directory. */

	/* revoke privs */
	uid = getuid();
	gid = getgid();
	if (setresgid(gid, gid, gid) == -1 || setresuid(uid, uid, uid) == -1) {
		syslog(LOG_ERR, "revoke privileges: %s", strerror(errno));
		_exit(1);
	}

	/* Ensure that nothing of our device environment is inherited. */
	sys_close();
	closelog();
	close (0);
	close (1);
	close (2);
	close (ttyfd);  /* tty interface to the ppp device */

	/* Don't pass handles to the PPP device, even by accident. */
	new_fd = open (_PATH_DEVNULL, O_RDWR);
	if (new_fd >= 0) {
	    if (new_fd != 0) {
		dup2  (new_fd, 0); /* stdin <- /dev/null */
		close (new_fd);
	    }
	    dup2 (0, 1); /* stdout -> /dev/null */
	    dup2 (0, 2); /* stderr -> /dev/null */
	}

	/* Force the priority back to zero if pppd is running higher. */
	if (setpriority (PRIO_PROCESS, 0, 0) < 0)
	    syslog (LOG_WARNING, "can't reset priority to 0: %m");

	/* SysV recommends a second fork at this point. */

	/* run the program; give it a null environment */
	execve(prog, args, script_env);
	if (must_exist || errno != ENOENT)
	    syslog(LOG_WARNING, "Can't execute %s: %m", prog);
	_exit(1);
    }
    MAINDEBUG((LOG_DEBUG, "Script %s started; pid = %ld", prog, (long)pid));
    ++n_children;
    return 0;
}


/*
 * reap_kids - get status from any dead child processes,
 * and log a message for abnormal terminations.
 */
static void
reap_kids()
{
    int status;
    pid_t pid;

    if (n_children == 0)
	return;
    if ((pid = waitpid(-1, &status, WNOHANG)) == -1) {
	if (errno != ECHILD)
	    syslog(LOG_ERR, "Error waiting for child process: %m");
	return;
    }
    if (pid > 0) {
	--n_children;
	if (WIFSIGNALED(status)) {
	    syslog(LOG_WARNING, "Child process %ld terminated with signal %d",
		   (long)pid, WTERMSIG(status));
	}
    }
}


/*
 * log_packet - format a packet and log it.
 */

char line[256];			/* line to be logged accumulated here */
char *linep;

void
log_packet(p, len, prefix, level)
    u_char *p;
    int len;
    char *prefix;
    int level;
{
    strlcpy(line, prefix, sizeof line);
    linep = line + strlen(line);
    format_packet(p, len, pr_log, NULL);
    if (linep != line)
	syslog(level, "%s", line);
}

/*
 * format_packet - make a readable representation of a packet,
 * calling `printer(arg, format, ...)' to output it.
 */
void
format_packet(p, len, printer, arg)
    u_char *p;
    int len;
    void (*printer)(void *, char *, ...);
    void *arg;
{
    int i, n;
    u_short proto;
    u_char x;
    struct protent *protp;

    if (len >= PPP_HDRLEN && p[0] == PPP_ALLSTATIONS && p[1] == PPP_UI) {
	p += 2;
	GETSHORT(proto, p);
	len -= PPP_HDRLEN;
	for (i = 0; (protp = protocols[i]) != NULL; ++i)
	    if (proto == protp->protocol)
		break;
	if (protp != NULL) {
	    printer(arg, "[%s", protp->name);
	    n = (*protp->printpkt)(p, len, printer, arg);
	    printer(arg, "]");
	    p += n;
	    len -= n;
	} else {
	    printer(arg, "[proto=0x%x]", proto);
	}
    }

    for (; len > 0; --len) {
	GETCHAR(x, p);
	printer(arg, " %.2x", x);
    }
}

static void
pr_log(void *arg, char *fmt, ...)
{
    int n;
    va_list pvar;
    char buf[256];

    va_start(pvar, fmt);

    n = vfmtmsg(buf, sizeof(buf), fmt, pvar);
    va_end(pvar);

    if (linep + n + 1 > line + sizeof(line)) {
	syslog(LOG_DEBUG, "%s", line);
	linep = line;
    }
    strlcpy(linep, buf, line + sizeof line - linep);
    linep += n;
}

/*
 * print_string - print a readable representation of a string using
 * printer.
 */
void
print_string(p, len, printer, arg)
    char *p;
    int len;
    void (*printer)(void *, char *, ...);
    void *arg;
{
    int c;

    printer(arg, "\"");
    for (; len > 0; --len) {
	c = *p++;
	if (' ' <= c && c <= '~') {
	    if (c == '\\' || c == '"')
		printer(arg, "\\");
	    printer(arg, "%c", c);
	} else {
	    switch (c) {
	    case '\n':
		printer(arg, "\\n");
		break;
	    case '\r':
		printer(arg, "\\r");
		break;
	    case '\t':
		printer(arg, "\\t");
		break;
	    default:
		printer(arg, "\\%.3o", c);
	    }
	}
    }
    printer(arg, "\"");
}

/*
 * novm - log an error message saying we ran out of memory, and die.
 */
void
novm(msg)
    char *msg;
{
    syslog(LOG_ERR, "Virtual memory exhausted allocating %s", msg);
    die(1);
}

/*
 * fmtmsg - format a message into a buffer.  Like snprintf except we
 * also specify the length of the output buffer, and we handle
 * %m (error message) and %I (IP address) formats.
 * Doesn't do floating-point formats.
 * Returns the number of chars put into buf.
 */
int
fmtmsg(char *buf, int buflen, char *fmt, ...)
{
    va_list args;
    int n;

    va_start(args, fmt);
    n = vfmtmsg(buf, buflen, fmt, args);
    va_end(args);
    return n;
}

/*
 * vfmtmsg - like fmtmsg, takes a va_list instead of a list of args.
 */
#define OUTCHAR(c)	(buflen > 0? (--buflen, *buf++ = (c)): 0)

int
vfmtmsg(buf, buflen, fmt, args)
    char *buf;
    int buflen;
    char *fmt;
    va_list args;
{
    int c, i, n;
    int width, prec, fillch;
    int base, len, neg, quoted;
    unsigned long val = 0;
    char *str, *f, *buf0;
    unsigned char *p;
    char num[32];
    time_t t;
    static char hexchars[] = "0123456789abcdef";

    buf0 = buf;
    --buflen;
    while (buflen > 0) {
	for (f = fmt; *f != '%' && *f != 0; ++f)
	    ;
	if (f > fmt) {
	    len = f - fmt;
	    if (len > buflen)
		len = buflen;
	    memcpy(buf, fmt, len);
	    buf += len;
	    buflen -= len;
	    fmt = f;
	}
	if (*fmt == 0)
	    break;
	c = *++fmt;
	width = prec = 0;
	fillch = ' ';
	if (c == '0') {
	    fillch = '0';
	    c = *++fmt;
	}
	if (c == '*') {
	    width = va_arg(args, int);
	    c = *++fmt;
	} else {
	    while (isdigit(c)) {
		width = width * 10 + c - '0';
		c = *++fmt;
	    }
	}
	if (c == '.') {
	    c = *++fmt;
	    if (c == '*') {
		prec = va_arg(args, int);
		c = *++fmt;
	    } else {
		while (isdigit(c)) {
		    prec = prec * 10 + c - '0';
		    c = *++fmt;
		}
	    }
	}
	str = 0;
	base = 0;
	neg = 0;
	++fmt;
	switch (c) {
	case 'd':
	    i = va_arg(args, int);
	    if (i < 0) {
		neg = 1;
		val = -i;
	    } else
		val = i;
	    base = 10;
	    break;
	case 'o':
	    val = va_arg(args, unsigned int);
	    base = 8;
	    break;
	case 'x':
	    val = va_arg(args, unsigned int);
	    base = 16;
	    break;
	case 'p':
	    val = (unsigned long) va_arg(args, void *);
	    base = 16;
	    neg = 2;
	    break;
	case 's':
	    str = va_arg(args, char *);
	    break;
	case 'c':
	    num[0] = va_arg(args, int);
	    num[1] = 0;
	    str = num;
	    break;
	case 'm':
	    str = strerror(errno);
	    break;
	case 'I':
	    str = ip_ntoa(va_arg(args, u_int32_t));
	    break;
	case 't':
	    time(&t);
	    str = ctime(&t);
	    str += 4;		/* chop off the day name */
	    str[15] = 0;	/* chop off year and newline */
	    break;
	case 'v':		/* "visible" string */
	case 'q':		/* quoted string */
	    quoted = c == 'q';
	    p = va_arg(args, unsigned char *);
	    if (fillch == '0' && prec > 0) {
		n = prec;
	    } else {
		n = strlen((char *)p);
		if (prec > 0 && prec < n)
		    n = prec;
	    }
	    while (n > 0 && buflen > 0) {
		c = *p++;
		--n;
		if (!quoted && c >= 0x80) {
		    OUTCHAR('M');
		    OUTCHAR('-');
		    c -= 0x80;
		}
		if (quoted && (c == '"' || c == '\\'))
		    OUTCHAR('\\');
		if (c < 0x20 || (0x7f <= c && c < 0xa0)) {
		    if (quoted) {
			OUTCHAR('\\');
			switch (c) {
			case '\t':	OUTCHAR('t');	break;
			case '\n':	OUTCHAR('n');	break;
			case '\b':	OUTCHAR('b');	break;
			case '\f':	OUTCHAR('f');	break;
			default:
			    OUTCHAR('x');
			    OUTCHAR(hexchars[c >> 4]);
			    OUTCHAR(hexchars[c & 0xf]);
			}
		    } else {
			if (c == '\t')
			    OUTCHAR(c);
			else {
			    OUTCHAR('^');
			    OUTCHAR(c ^ 0x40);
			}
		    }
		} else
		    OUTCHAR(c);
	    }
	    continue;
	default:
	    *buf++ = '%';
	    if (c != '%')
		--fmt;		/* so %z outputs %z etc. */
	    --buflen;
	    continue;
	}
	if (base != 0) {
	    str = num + sizeof(num);
	    *--str = 0;
	    while (str > num + neg) {
		*--str = hexchars[val % base];
		val = val / base;
		if (--prec <= 0 && val == 0)
		    break;
	    }
	    switch (neg) {
	    case 1:
		*--str = '-';
		break;
	    case 2:
		*--str = 'x';
		*--str = '0';
		break;
	    }
	    len = num + sizeof(num) - 1 - str;
	} else {
	    len = strlen(str);
	    if (prec > 0 && len > prec)
		len = prec;
	}
	if (width > 0) {
	    if (width > buflen)
		width = buflen;
	    if ((n = width - len) > 0) {
		buflen -= n;
		for (; n > 0; --n)
		    *buf++ = fillch;
	    }
	}
	if (len > buflen)
	    len = buflen;
	memcpy(buf, str, len);
	buf += len;
	buflen -= len;
    }
    *buf = 0;
    return buf - buf0;
}

/*
 * script_setenv - set an environment variable value to be used
 * for scripts that we run (e.g. ip-up, auth-up, etc.)
 */
void
script_setenv(var, value)
    char *var, *value;
{
    int vl = strlen(var);
    int i;
    char *p, *newstring;

    if (asprintf(&newstring, "%s=%s", var, value) == -1)
	novm("script_setenv");

    /* check if this variable is already set */
    if (script_env != 0) {
	for (i = 0; (p = script_env[i]) != 0; ++i) {
	    if (strncmp(p, var, vl) == 0 && p[vl] == '=') {
		free(p);
		script_env[i] = newstring;
		return;
	    }
	}
    } else {
	i = 0;
	script_env = (char **) calloc(16, sizeof(char *));
	if (script_env == 0)
	    novm("script_setenv");
	s_env_nalloc = 16;
    }

    /* reallocate script_env with more space if needed */
    if (i + 1 >= s_env_nalloc) {
	int new_n = i + 17;
	char **newenv = reallocarray(script_env,
	    new_n, sizeof(char *));
	if (newenv == 0)
	    novm("script_setenv");
	script_env = newenv;
	s_env_nalloc = new_n;
    }

    script_env[i] = newstring;
    script_env[i+1] = 0;
}
@


1.53
log
@Use __progname instead of manually handling argv[0].

ok deraadt, mmcc, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.52 2015/10/26 11:10:53 deraadt Exp $	*/
d1104 1
a1104 1
	execl("/bin/sh", "sh", "-c", program, (char *)0);
@


1.52
log
@stop saving a pidfile; ok jung zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.51 2015/01/16 06:40:19 deraadt Exp $	*/
a92 1
char *progname;			/* Name of this program */
a223 2

    progname = *argv;
@


1.51
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.50 2014/10/08 04:51:29 deraadt Exp $	*/
a94 1
static char pidfilename[PATH_MAX];	/* name of pid file */
a126 1
static void create_pidfile(void);
a391 2
	create_pidfile();	/* write pid to file */

a527 2

	    create_pidfile();	/* write pid to file */
a585 7
	if (!demand) {
	    if (pidfilename[0] != 0
		&& unlink(pidfilename) < 0 && errno != ENOENT)
		syslog(LOG_WARNING, "unable to delete pid file: %m");
	    pidfilename[0] = 0;
	}

a623 22
    /* update pid file if it has been written already */
    if (pidfilename[0])
	create_pidfile();
}

/*
 * Create a file containing our process ID.
 */
static void
create_pidfile()
{
    FILE *pidfile;

    (void) snprintf(pidfilename, sizeof pidfilename,
	"%s%s.pid", _PATH_VARRUN, ifname);
    if ((pidfile = fopen(pidfilename, "w")) != NULL) {
	fprintf(pidfile, "%ld\n", (long)pid);
	(void) fclose(pidfile);
    } else {
	syslog(LOG_ERR, "Failed to create pid file %s: %m", pidfilename);
	pidfilename[0] = 0;
    }
a748 4

    if (pidfilename[0] != 0 && unlink(pidfilename) < 0 && errno != ENOENT)
	syslog(LOG_WARNING, "unable to delete pid file: %m");
    pidfilename[0] = 0;
@


1.50
log
@easy obvious use of reallocarray(); ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.49 2011/04/30 18:49:38 nicm Exp $	*/
d45 7
d57 1
a64 8
#include <sys/param.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <net/if.h>
d94 3
a96 3
char hostname[MAXHOSTNAMELEN];	/* Our hostname */
static char pidfilename[MAXPATHLEN];	/* name of pid file */
static char default_devnam[MAXPATHLEN];	/* name of default device */
d197 1
a197 1
	strlcpy(devnam, p, MAXPATHLEN);
a1219 1
#ifdef BSD
a1222 1
#endif
@


1.49
log
@Remove some unused code, from Michael W Bombardieri. ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.48 2009/10/27 23:59:53 deraadt Exp $	*/
d1661 2
a1662 2
	char **newenv = (char **) realloc((void *)script_env,
					  new_n * sizeof(char *));
@


1.48
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2007/09/02 15:19:39 deraadt Exp $	*/
a1670 24
}

/*
 * script_unsetenv - remove a variable from the environment
 * for scripts.
 */
void
script_unsetenv(var)
    char *var;
{
    int vl = strlen(var);
    int i;
    char *p;

    if (script_env == 0)
	return;
    for (i = 0; (p = script_env[i]) != 0; ++i) {
	if (strncmp(p, var, vl) == 0 && p[vl] == '=') {
	    free(p);
	    while ((script_env[i] = script_env[i+1]) != 0)
		++i;
	    break;
	}
    }
@


1.47
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.46 2007/06/04 14:59:45 henning Exp $	*/
a43 8

#ifndef lint
#if 0
static char rcsid[] = "Id: main.c,v 1.49 1998/05/05 05:24:17 paulus Exp $";
#else
static char rcsid[] = "$OpenBSD: main.c,v 1.46 2007/06/04 14:59:45 henning Exp $";
#endif
#endif
@


1.46
log
@bye bye ipx
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.45 2005/05/03 03:42:16 djm Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: main.c,v 1.45 2005/05/03 03:42:16 djm Exp $";
d1660 1
a1660 1
	script_env = (char **) malloc(16 * sizeof(char *));
@


1.45
log
@setres[ug]id; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 2004/02/09 19:59:15 canacar Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: main.c,v 1.44 2004/02/09 19:59:15 canacar Exp $";
a92 3
#ifdef IPX_CHANGE
#include "ipxcp.h"
#endif /* IPX_CHANGE */
a180 3
#ifdef IPX_CHANGE
    &ipxcp_protent,
#endif
@


1.44
log
@Remove unused %r (recursive) format option.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.43 2004/02/08 07:09:56 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: main.c,v 1.43 2004/02/08 07:09:56 deraadt Exp $";
d1110 2
d1151 1
d1153 7
a1159 4
	seteuid(getuid());
	setuid(getuid());
	setegid(getgid());
	setgid(getgid());
d1191 2
d1206 8
a1213 2
	setuid(geteuid());
	setgid(getegid());
@


1.43
log
@amd64 needs the same hack as powerpc; but this code really needs to be
deleted/replaced.  anyone want to step up?
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.42 2003/04/25 23:24:04 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: main.c,v 1.42 2003/04/25 23:24:04 deraadt Exp $";
d1401 1
a1401 1
 * %r (recursive format), %m (error message) and %I (IP address) formats.
a1523 11
	case 'r':
	    f = va_arg(args, char *);
#if !defined(__powerpc__) && !defined(__x86_64__)
	    n = vfmtmsg(buf, buflen + 1, f, va_arg(args, va_list));
#else
	    /* On the powerpc, a va_list is an array of 1 structure */
	    n = vfmtmsg(buf, buflen + 1, f, va_arg(args, void *));
#endif
	    buf += n;
	    buflen -= n;
	    continue;
@


1.42
log
@comment cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.41 2003/04/14 03:14:59 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: main.c,v 1.41 2003/04/14 03:14:59 deraadt Exp $";
d1526 1
a1526 1
#ifndef __powerpc__
@


1.41
log
@obvious spring cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.40 2003/04/04 20:25:07 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: main.c,v 1.40 2003/04/04 20:25:07 deraadt Exp $";
d1399 1
a1399 1
 * fmtmsg - format a message into a buffer.  Like sprintf except we
@


1.40
log
@strlcpy and snprintf; various people ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.39 2002/07/29 22:02:38 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: main.c,v 1.39 2002/07/29 22:02:38 millert Exp $";
d1344 1
a1344 1
    strcpy(linep, buf);
@


1.39
log
@Replace an instance of chmod() with fchmod()
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 2002/07/01 19:31:37 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: main.c,v 1.38 2002/07/01 19:31:37 deraadt Exp $";
d211 2
a212 2
	strcpy(devnam, p);
    strcpy(default_devnam, devnam);
d231 1
a231 1
    sprintf(numbuf, "%u", uid);
d280 1
a280 1
    sprintf(numbuf, "%d", baud_rate);
d405 1
a405 1
	(void) sprintf(ifname, "ppp%d", ifunit);
d544 1
a544 1
	    (void) sprintf(ifname, "ppp%d", ifunit);
d664 2
a665 1
    (void) sprintf(pidfilename, "%s%s.pid", _PATH_VARRUN, ifname);
d1281 1
a1281 1
    strcpy(line, prefix);
d1649 1
a1649 2
    newstring = (char *) malloc(vl + strlen(value) + 2);
    if (newstring == 0)
a1650 3
    strcpy(newstring, var);
    newstring[vl] = '=';
    strcpy(newstring+vl+1, value);
@


1.38
log
@license update of CMU parts.  due to communication with wcw+@@andrew.cmu.edu,
pushed for by tygs@@netcologne.de.  Apparently we also now known how to talk
to the lawyers there, if we were so mad.  Note that a few other copyright
issues in pppd still remain, so this does not close this story.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 2002/05/26 09:25:21 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: main.c,v 1.37 2002/05/26 09:25:21 deraadt Exp $";
d827 1
a827 1
	chmod(devnam, tty_mode);
@


1.37
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 2002/05/08 22:30:55 deraadt Exp $	*/
d6 1
a6 2
 * Copyright (c) 1989 Carnegie Mellon University.
 * All rights reserved.
d8 35
a42 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Carnegie Mellon University.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d49 1
a49 1
static char rcsid[] = "$OpenBSD: main.c,v 1.36 2002/05/08 22:30:55 deraadt Exp $";
@


1.36
log
@be even more clear
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 2002/05/06 19:35:26 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.35 2002/05/06 19:35:26 deraadt Exp $";
d643 1
a643 1
	fprintf(pidfile, "%d\n", pid);
d1083 1
a1083 1
    int pid;
d1160 1
a1160 1
    int pid;
d1210 1
a1210 1
    MAINDEBUG((LOG_DEBUG, "Script %s started; pid = %d", prog, pid));
d1223 2
a1224 1
    int pid, status;
d1236 2
a1237 2
	    syslog(LOG_WARNING, "Child process %d terminated with signal %d",
		   pid, WTERMSIG(status));
@


1.35
log
@do not install a SIGSEGV handler
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2002/02/19 19:39:40 millert Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.34 2002/02/19 19:39:40 millert Exp $";
d334 1
a334 1
#if 0
@


1.34
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2002/02/16 21:28:07 millert Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.33 2002/02/16 21:28:07 millert Exp $";
d334 1
d336 1
@


1.34.2.1
log
@Pull in patch from current:
Fix (millert), errata 011:
Replace an instance of chmod() with fchmod()
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2002/02/19 19:39:40 millert Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.34 2002/02/19 19:39:40 millert Exp $";
d802 1
a802 1
	fchmod(ttyfd, tty_mode);
@


1.33
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2001/11/05 09:58:13 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.32 2001/11/05 09:58:13 deraadt Exp $";
d1302 1
a1302 1
pr_log __V((void *arg, char *fmt, ...))
a1307 1
#ifdef __STDC__
a1308 7
#else
    void *arg;
    char *fmt;
    va_start(pvar);
    arg = va_arg(pvar, void *);
    fmt = va_arg(pvar, char *);
#endif
d1379 1
a1379 1
fmtmsg __V((char *buf, int buflen, char *fmt, ...))
a1383 1
#ifdef __STDC__
a1384 9
#else
    char *buf;
    int buflen;
    char *fmt;
    va_start(args);
    buf = va_arg(args, char *);
    buflen = va_arg(args, int);
    fmt = va_arg(args, char *);
#endif
@


1.32
log
@some syslog_r uses in signal handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2001/05/15 19:56:06 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.31 2001/05/15 19:56:06 deraadt Exp $";
d116 21
a136 21
static void create_pidfile __P((void));
static void cleanup __P((void));
static void close_tty __P((void));
static void get_input __P((void));
static void calltimeout __P((void));
static struct timeval *timeleft __P((struct timeval *));
static void kill_my_pg __P((int));
static void hup __P((int));
static void term __P((int));
static void chld __P((int));
static void toggle_debug __P((int));
static void open_ccp __P((int));
static void bad_signal __P((int));
static void holdoff_end __P((void *));
static int device_script __P((char *, int, int));
static void reap_kids __P((void));
static void pr_log __P((void *, char *, ...));

extern	char	*ttyname __P((int));
extern	char	*getlogin __P((void));
int main __P((int, char *[]));
d812 1
a812 1
    void		(*c_func) __P((void *)); /* routine */
d827 1
a827 1
    void (*func) __P((void *));
d867 1
a867 1
    void (*func) __P((void *));
d1269 1
a1269 1
    void (*printer) __P((void *, char *, ...));
d1337 1
a1337 1
    void (*printer) __P((void *, char *, ...));
@


1.31
log
@the signal handlers can many illegal functions.  try to at least be cautious.
parts from mickey, parts from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2001/03/09 03:24:09 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.30 2001/03/09 03:24:09 deraadt Exp $";
d754 2
d757 2
a758 2
    syslog(LOG_INFO, "Exit.");
    exit(status);
d967 1
d971 1
a971 1
    syslog(LOG_INFO, "Hangup (SIGHUP)");		/* XXX unsafe */
d991 1
d995 1
a995 1
    syslog(LOG_INFO, "Terminating on signal %d.", sig);	/* XXX unsafe */
d1060 2
d1065 1
a1065 1
    syslog(LOG_ERR, "Fatal signal %d", sig);	/* XXX unsafe */
@


1.31.2.1
log
@Errata #028 (millert):
Replace an instance of chmod() with fchmod()
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2001/05/15 19:56:06 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.31 2001/05/15 19:56:06 deraadt Exp $";
d800 1
a800 1
	fchmod(ttyfd, tty_mode);
@


1.30
log
@exit(-#) is wrong
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2000/09/15 07:13:51 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.29 2000/09/15 07:13:51 deraadt Exp $";
d88 1
d964 5
a968 1
    syslog(LOG_INFO, "Hangup (SIGHUP)");
d973 1
d987 5
a991 1
    syslog(LOG_INFO, "Terminating on signal %d.", sig);
d997 1
d1011 1
a1011 1
    reap_kids();
d1028 1
a1028 1
	setlogmask(LOG_UPTO(LOG_DEBUG));
d1030 1
a1030 1
	setlogmask(LOG_UPTO(LOG_WARNING));
a1055 2
    static int crashed = 0;

d1059 1
a1059 1
    syslog(LOG_ERR, "Fatal signal %d", sig);
d1062 1
a1062 1
    die(1);
@


1.29
log
@check return value for setenv(3) for failure, and deal appropriately
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2000/02/12 09:46:59 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.28 2000/02/12 09:46:59 deraadt Exp $";
d1191 1
a1191 1
	_exit(-1);
@


1.28
log
@handle direct lines correctly; rees
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 1999/08/06 20:41:07 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.27 1999/08/06 20:41:07 deraadt Exp $";
d1627 1
a1627 1
	return;
d1645 1
a1645 1
	    return;
d1655 1
a1655 1
	    return;
@


1.27
log
@uid_t and gid_t, and use %u
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 1999/05/03 21:38:08 mickey Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.26 1999/05/03 21:38:08 mickey Exp $";
d493 1
a493 3
	/* clear CLOCAL if modem option set and we set CLOCAL above */
	if (modem && !modem_chat)
		set_up_tty(ttyfd, 0);
@


1.26
log
@drop packets silently while the link is down, which is a better approximation
to the real networks, ie simulating an open wire w/ tokens falling down
angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 1998/07/12 04:34:41 angelos Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.25 1998/07/12 04:34:41 angelos Exp $";
d207 1
a207 1
    sprintf(numbuf, "%d", uid);
d291 1
a291 1
    syslog(LOG_NOTICE, "pppd %s.%d%s started by %s, uid %d",
@


1.25
log
@Implement demand_drop() for demand mode pppd; try to avoid mbuf
exhaustion while setting up a connection.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 1998/07/10 08:06:45 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.24 1998/07/10 08:06:45 deraadt Exp $";
d417 1
a417 1
	    demand_discard();
@


1.24
log
@do not syslog() with "\n"; skipped smtpd/named/ipmon; 12 minutes of dabbling
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 1998/07/09 06:33:28 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.23 1998/07/09 06:33:28 deraadt Exp $";
d417 1
a417 1
	    demand_block();
a591 2
	if (demand)
	    demand_discard();
@


1.23
log
@hostnames are MAXHOSTNAMELEN, not MAXNAMELEN
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 1998/05/08 04:52:27 millert Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.22 1998/05/08 04:52:27 millert Exp $";
d1364 1
a1364 1
    syslog(LOG_ERR, "Virtual memory exhausted allocating %s\n", msg);
@


1.22
log
@pppd 2.3.5
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 1998/01/17 20:30:25 millert Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.21 1998/01/17 20:30:25 millert Exp $";
d82 1
a82 1
char hostname[MAXNAMELEN];	/* Our hostname */
d200 1
a200 1
    if (gethostname(hostname, MAXNAMELEN) < 0 ) {
a203 1
    hostname[MAXNAMELEN-1] = 0;
@


1.21
log
@ppp-2.3.3 + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 1997/11/14 00:16:14 millert Exp $	*/
d24 1
a24 1
static char rcsid[] = "Id: main.c,v 1.43 1997/11/27 06:09:20 paulus Exp $";
d26 1
a26 1
static char rcsid[] = "$OpenBSD: main.c,v 1.20 1997/11/14 00:16:14 millert Exp $";
d95 1
d100 3
a102 1
int redirect_stderr;		/* Connector's stderr should go to file */
d115 1
a175 1
    FILE *pidfile;
d182 1
d190 2
d208 2
d256 4
d266 2
a267 1
    redirect_stderr = !nodetach || default_device;
d281 2
a282 4
    if (!default_device && !nodetach && daemon(0, 0) < 0) {
	perror("Couldn't detach from controlling terminal");
	exit(1);
    }
d381 1
d383 1
a383 9
	/* write pid to file */
	(void) sprintf(pidfilename, "%s%s.pid", _PATH_VARRUN, ifname);
	if ((pidfile = fopen(pidfilename, "w")) != NULL) {
	    fprintf(pidfile, "%d\n", pid);
	    (void) fclose(pidfile);
	} else {
	    syslog(LOG_ERR, "Failed to create pid file %s: %m", pidfilename);
	    pidfilename[0] = 0;
	}
d522 1
d524 1
a524 10
	    /* write pid to file */
	    (void) sprintf(pidfilename, "%s%s.pid", _PATH_VARRUN, ifname);
	    if ((pidfile = fopen(pidfilename, "w")) != NULL) {
		fprintf(pidfile, "%d\n", pid);
		(void) fclose(pidfile);
	    } else {
		syslog(LOG_ERR, "Failed to create pid file %s: %m",
		       pidfilename);
		pidfilename[0] = 0;
	    }
d617 37
d1050 5
d1105 1
a1105 1
	if (redirect_stderr) {
d1107 1
a1107 1
	    errfd = open(_PATH_CONNERRS, O_WRONLY | O_APPEND | O_CREAT, 0644);
a1148 1
    char *nullenv[1];
d1193 1
a1193 2
	nullenv[0] = NULL;
	execve(prog, args, nullenv);
d1308 1
a1308 1
    vsprintf(buf, fmt, pvar);
a1310 1
    n = strlen(buf);
d1616 75
@


1.20
log
@clear CLOCAL if modem is set but modem_chat is not.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 1997/10/25 05:09:56 millert Exp $	*/
d23 5
a27 1
static char rcsid[] = "$OpenBSD: main.c,v 1.19 1997/10/25 05:09:56 millert Exp $";
d124 1
a124 1
static void holdoff_end __P((caddr_t));
d170 1
a170 1
    int i, nonblock, fdflags;
d444 1
a457 8
	/*
	 * Set line speed, flow control, etc.
	 * Note that unless modem_chat is set the chat script has
	 * no way of noticing if carrier drops.  This is a necessary
	 * evil for systems without cua devices.
	 */
	set_up_tty(ttyfd, (modem_chat == 0));

d462 11
d595 1
a595 1
	    break;
d625 1
a625 1
    caddr_t arg;
d780 2
a781 2
    caddr_t		c_arg;		/* argument to routine */
    void		(*c_func) __P((caddr_t)); /* routine */
d796 2
a797 2
    void (*func) __P((caddr_t));
    caddr_t arg;
d836 2
a837 2
    void (*func) __P((caddr_t));
    caddr_t arg;
@


1.19
log
@Set CLOCAL for chat script by default.  Add new option "modem_chat"
to override the default for people using cua devices who want chat
to detect loss of carrier.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 1997/09/05 04:32:42 millert Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: main.c,v 1.18 1997/09/05 04:32:42 millert Exp $";
d481 4
@


1.18
log
@ppp 2.3.1
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 1997/08/04 19:26:18 deraadt Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: main.c,v 1.17 1997/08/04 19:26:18 deraadt Exp $";
d455 3
a457 3
	 * Previously, if we had a connection script, we would set CLOCAL
	 * while the script was running.  But then, if CD was negated
	 * before the script finished, we would miss it.
d459 1
a459 1
	set_up_tty(ttyfd, 0);
@


1.17
log
@save errno in sigchld handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 1997/07/25 20:12:16 mickey Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: main.c,v 1.16 1997/07/25 20:12:16 mickey Exp $";
d27 1
d69 3
d86 3
a88 3
mode_t tty_mode = -1;           /* Original access permissions to tty */
int baud_rate;                  /* Actual bits/second for serial device */
int hungup;                     /* terminal has been hung up */
d95 1
a95 1
int redirect_stderr;          /* Connector's stderr should go to file */
a110 1
static void connect_time_expired __P((caddr_t));
d113 1
d120 1
a120 1
static void holdoff_end __P((void *));
d127 1
d155 3
d205 2
a206 2
        (*protp->init)(0);
  
d210 3
a212 3
        || !options_from_user())
        exit(1);
    scan_args(argc-1, argv+1);  /* look for tty name on command line */
d214 1
a214 1
        || !parse_args(argc-1, argv+1))
a216 5
    if (!ppp_available()) {
	option_error(no_ppp_msg);
	exit(1);
    }

d226 5
a251 1

d258 1
a258 2
      setlogmask(LOG_UPTO(LOG_DEBUG));

d277 2
a278 2
    syslog(LOG_NOTICE, "pppd %s.%d started by %s, uid %d",
	   VERSION, PATCHLEVEL, p, uid);
d425 4
a428 3
	 * If we're dialling out, or we don't want to use the modem lines,
	 * we open it in non-blocking mode, but then we need to clear
	 * the non-blocking I/O bit.
d430 5
a434 10
	nonblock = (connector || !modem)? O_NONBLOCK: 0;
	if ((ttyfd = open(devnam, nonblock | O_RDWR, 0)) < 0) {
	    syslog(LOG_ERR, "Failed to open %s: %m", devnam);
	    goto fail;
	}
	if (nonblock) {
	    if ((fdflags = fcntl(ttyfd, F_GETFL)) == -1
		|| fcntl(ttyfd, F_SETFL, fdflags & ~O_NONBLOCK) < 0)
		syslog(LOG_WARNING,
		       "Couldn't reset non-blocking mode on device: %m");
d436 4
d443 17
a459 9
        /*
         * Do the equivalent of `mesg n' to stop broadcast messages.
         */
        if (fstat(ttyfd, &statbuf) < 0
            || fchmod(ttyfd, statbuf.st_mode & ~(S_IWGRP | S_IWOTH)) < 0) {
            syslog(LOG_WARNING,
                   "Couldn't restrict write permissions to %s: %m", devnam);
        } else
            tty_mode = statbuf.st_mode;
a464 3
	    /* set line speed, flow control, etc.; set CLOCAL for now */
	    set_up_tty(ttyfd, 1);

d482 10
a491 2
	/* set line speed, flow control, etc.; clear CLOCAL if modem option */
	set_up_tty(ttyfd, 0);
d503 1
a503 1
	    
d506 1
a506 1
	    
a519 7
	 * Set a timeout to close the connection once the maximum
	 * connect time has expired.
	 */
	if (maxconnect > 0)
	    TIMEOUT(connect_time_expired, 0, maxconnect);

	/*
d537 1
a537 1
                    (*ccp_protent.open)(0);
d568 2
a569 1
	close_tty();
d576 2
a577 2
            if (pidfilename[0] != 0
                && unlink(pidfilename) < 0 && errno != ENOENT)
d605 1
d613 1
a613 1
    void *arg;
d644 1
a644 1
	log_packet(p, len, "rcvd ");
d660 13
a672 1
		   "io(): Received non-LCP packet when LCP not open."));
d684 1
a684 1
        if (protocol == (protp->protocol & ~0x8000) && protp->enabled_flag
d700 1
a700 1
void 
a718 11
 * connect_time_expired - log a message and close the connection.
 */
static void
connect_time_expired(arg)
    caddr_t arg;
{
    syslog(LOG_INFO, "Connect time expired");
    lcp_close(0, "Connect time expired");	/* Close connection */
}

/*
d730 1
a730 1
    if (pidfilename[0] != 0 && unlink(pidfilename) < 0 && errno != ENOENT) 
d759 1
a759 1
      chmod(devnam, tty_mode);
d769 1
a769 1
    void		(*c_func)();	/* routine */
d784 1
a784 1
    void (*func)();
d789 1
a789 1
  
d792 1
a792 1
  
d805 1
a805 1
  
d824 1
a824 1
    void (*func)();
d828 1
a828 1
  
d830 1
a830 1
  
d893 1
a893 1
    
d906 1
a907 1
    kill(-getpgrp(), sig);
d977 1
a977 1
      setlogmask(LOG_UPTO(LOG_DEBUG));
d979 1
a979 1
      setlogmask(LOG_UPTO(LOG_WARNING));
d1036 27
a1062 27
        closelog();
        if (in == out) {   
            if (in != 0) {
                dup2(in, 0);
                close(in);
            }
            dup2(0, 1);
        } else {
            if (out == 0)
                out = dup(out);
            if (in != 0) {
                dup2(in, 0);
                close(in);
            }
            if (out != 1) {
	        dup2(out, 1);
                close(out);
            }
        }
        if (redirect_stderr) {
            close(2);
            errfd = open(_PATH_CONNERRS, O_WRONLY | O_APPEND | O_CREAT, 0644);
            if (errfd >= 0 && errfd != 2) {
	        dup2(errfd, 2);
                close(errfd);
            }
        }
d1118 1
a1118 1
        closelog();  
d1124 1
a1124 1
        /* Don't pass handles to the PPP device, even by accident. */
d1128 1
a1128 1
	        dup2  (new_fd, 0); /* stdin <- /dev/null */
d1138 1
a1138 1
	    syslog (LOG_WARNING, "can't reset priority to 0: %m"); 
d1143 1
a1143 1
        /* run the program; give it a null environment */
d1190 1
a1190 1
log_packet(p, len, prefix)
d1194 1
d1200 1
a1200 1
	syslog(LOG_DEBUG, "%s", line);
d1288 3
a1290 3
        if (' ' <= c && c <= '~') {
            if (c == '\\' || c == '"')
                printer(arg, "\\");
d1292 15
a1306 15
        } else {
            switch (c) {
            case '\n':
                printer(arg, "\\n");
                break;
            case '\r':
                printer(arg, "\\r");
                break;   
            case '\t':
                printer(arg, "\\t");
                break;
            default:
	        printer(arg, "\\%.3o", c);
            }
      }
a1307 1

d1334 1
a1334 1
                
d1350 1
a1350 1
 
d1354 2
a1355 2
#define OUTCHAR(c)      (buflen > 0? (--buflen, *buf++ = (c)): 0)
   
d1366 1
a1366 1
    unsigned long val;  
a1368 1
    va_list a;
d1372 1
a1372 1
    
d1376 190
a1565 190
        for (f = fmt; *f != '%' && *f != 0; ++f)
            ;
        if (f > fmt) {
            len = f - fmt;
            if (len > buflen)
                len = buflen;
            memcpy(buf, fmt, len);
            buf += len;
            buflen -= len;
            fmt = f;
        }
        if (*fmt == 0)
            break;
        c = *++fmt;
        width = prec = 0;
        fillch = ' ';   
        if (c == '0') {  
            fillch = '0';
            c = *++fmt;
        }
        if (c == '*') {
            width = va_arg(args, int);
            c = *++fmt;
        } else {
            while (isdigit(c)) {
                width = width * 10 + c - '0';
                c = *++fmt;
            }
        }
        if (c == '.') {   
            c = *++fmt;
            if (c == '*') {  
                prec = va_arg(args, int);
                c = *++fmt;
            } else {
                while (isdigit(c)) {
                    prec = prec * 10 + c - '0';
                    c = *++fmt;
                } 
            }
        }
        str = 0;
        base = 0;
        neg = 0;
        ++fmt;
        switch (c) {
        case 'd':
            i = va_arg(args, int);
            if (i < 0) {
                neg = 1;
                val = -i;
            } else
                val = i;   
            base = 10;
            break;
        case 'o':
            val = va_arg(args, unsigned int);
            base = 8;
            break;
        case 'x':
            val = va_arg(args, unsigned int);
            base = 16;
            break;
        case 'p':
            val = (unsigned long) va_arg(args, void *);
            base = 16;
            neg = 2;
            break;
        case 's':
            str = va_arg(args, char *);
            break;
        case 'c':   
            num[0] = va_arg(args, int);
            num[1] = 0;
            str = num;  
            break;
        case 'm':
            str = strerror(errno);
            break;
        case 'I':
            str = ip_ntoa(va_arg(args, u_int32_t));
            break;
        case 'r':
            f = va_arg(args, char *);
	    /*
	     * XXX We assume a va_list is either a pointer or an array, so
	     * what gets passed for a va_list is like a void * in some sense.
	     */
	    a = va_arg(args, va_list);
            n = vfmtmsg(buf, buflen + 1, f, a);
            buf += n;
            buflen -= n;
            continue;
        case 't':
            time(&t);
            str = ctime(&t);
            str += 4;           /* chop off the day name */
            str[15] = 0;        /* chop off year and newline */
            break;
        case 'v':               /* "visible" string */
        case 'q':               /* quoted string */
            quoted = c == 'q';
            p = va_arg(args, unsigned char *);
            if (fillch == '0' && prec > 0) {
                n = prec;
            } else {
                n = strlen((char *)p);
                if (prec > 0 && prec < n)
                    n = prec;
            }
            while (n > 0 && buflen > 0) {
                c = *p++;
                --n;
                if (!quoted && c >= 0x80) {
                    OUTCHAR('M');
                    OUTCHAR('-');
                    c -= 0x80;
                }
                if (quoted && (c == '"' || c == '\\'))
                    OUTCHAR('\\');
                if (c < 0x20 || 0x7f <= c && c < 0xa0) {
                    if (quoted) {
                        OUTCHAR('\\');
                        switch (c) {
                        case '\t':      OUTCHAR('t');   break;
                        case '\n':      OUTCHAR('n');   break;
                        case '\b':      OUTCHAR('b');   break;
                        case '\f':      OUTCHAR('f');   break;
                        default:
                            OUTCHAR('x');   
                            OUTCHAR(hexchars[c >> 4]);
                            OUTCHAR(hexchars[c & 0xf]);
                        }
                    } else {
                        if (c == '\t')
                            OUTCHAR(c);
                        else {
                            OUTCHAR('^');
                            OUTCHAR(c ^ 0x40);
                        }
                    }
                } else
                    OUTCHAR(c);
            }
            continue;
        default:
            *buf++ = '%';
            if (c != '%')
                --fmt;          /* so %z outputs %z etc. */
            --buflen;
            continue;
        }
        if (base != 0) {
            str = num + sizeof(num);
            *--str = 0;
            while (str > num + neg) {
                *--str = hexchars[val % base];
                val = val / base;
                if (--prec <= 0 && val == 0)
                    break;  
            }
            switch (neg) {
            case 1:
                *--str = '-';
                break;
            case 2:
                *--str = 'x';
                *--str = '0';
                break;
            }
            len = num + sizeof(num) - 1 - str;
        } else {
            len = strlen(str);
            if (prec > 0 && len > prec)
                len = prec;
        }
        if (width > 0) {
            if (width > buflen)
                width = buflen;
            if ((n = width - len) > 0) {
                buflen -= n;
                for (; n > 0; --n)   
                    *buf++ = fillch;
            }
        }
        if (len > buflen)   
            len = buflen;
        memcpy(buf, str, len);
        buf += len;
        buflen -= len;
@


1.16
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 1997/03/29 04:17:22 dgregor Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: main.c,v 1.15 1997/03/29 04:17:22 dgregor Exp $";
d943 2
d946 1
@


1.15
log
@Changed definition of 'a' in vfmtmsg from void * to va_list.
Possible fix for PR#130.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 1997/01/23 02:18:05 niklas Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: main.c,v 1.14 1997/01/23 02:18:05 niklas Exp $";
d1231 1
a1231 1
#if __STDC__
d1317 1
a1317 1
#if __STDC__
@


1.14
log
@Pedantic removal of extra spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 1996/12/23 13:22:44 mickey Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: main.c,v 1.13 1996/12/23 13:22:44 mickey Exp $";
d1351 1
a1351 1
    void *a;
d1447 1
a1447 1
	    a = va_arg(args, void *);
@


1.13
log
@pppd 2.3b3 import. some minor buf oflow fixes and so.
try it out ppl, but i've got it running talking to cisco w/ all the AFs
enabled in kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 1996/12/22 03:29:01 deraadt Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: main.c,v 1.12 1996/12/22 03:29:01 deraadt Exp $";
d273 1
a273 1
  
@


1.12
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 1996/08/20 04:48:27 deraadt Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: main.c,v 1.11 1996/08/20 04:48:27 deraadt Exp $";
d57 8
a68 8
/*
 * If REQ_SYSOPTIONS is defined to 1, pppd will not run unless
 * /etc/ppp/options exists.
 */
#ifndef	REQ_SYSOPTIONS
#define REQ_SYSOPTIONS	1
#endif

d79 1
d85 2
a86 1

a95 1
int hungup;			/* terminal has been hung up */
a97 2
int baud_rate;			/* Actual bits/second for serial device */

a101 5
static char *restricted_environ[] = {
	"PATH=" _PATH_STDPATH,
	NULL
};

d129 1
a129 1
#ifdef PRIMITIVE_SYSLOG 
d142 3
d175 1
a175 1
#ifdef PRIMITIVE_SYSLOG
d183 1
a183 1
        syslog(LOG_ERR, "couldn't get hostname: %m");
d189 1
d201 1
a201 1
    if (!options_from_file(_PATH_SYSOPTIONS, REQ_SYSOPTIONS, 0)
d210 1
a210 1
	fprintf(stderr, no_ppp_msg);
d215 9
d232 1
a232 2
	fprintf(stderr, "%s: connect script required for demand-dialling\n",
		progname);
d379 2
a519 1
		phase = PHASE_TERMINATE;
d570 1
a570 1
	    die(1);
d574 1
a574 1
	if (holdoff > 0) {
a699 2

    phase = PHASE_TERMINATE;
d881 17
d910 3
d929 3
d988 2
d1007 1
d1011 1
d1062 1
d1081 1
d1126 2
a1127 1
        execve(prog, args, restricted_environ);
d1339 5
a1343 1
vfmtmsg(char *buf, int buflen, char *fmt, va_list args)
d1351 1
a1351 1
    va_list a; 
d1354 1
a1354 1
    static char hexchars[16] = "0123456789abcdef";
d1443 5
a1447 1
            a = va_arg(args, va_list);
a1552 1
                
@


1.11
log
@exit 1 for failure if -detach; netbsd pr#2705; jbernard@@tater.Mines.EDU
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 1996/07/27 12:38:06 deraadt Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 1996/07/27 12:38:06 deraadt Exp $";
d1013 2
d1016 1
@


1.10
log
@pass a minimal environment ($PATH)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1996/07/20 12:02:11 joshd Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: main.c,v 1.9 1996/07/20 12:02:11 joshd Exp $";
d563 1
a563 1
	    break;
@


1.9
log
@Update pppd to 2.3a4:
Add redo option error-reporting, add PAM, add microsoft compatibility
kludges, bzero stuff at important places, add one or two options
other generic enhancements.  From: Paul.Mackerras@@cs.anu.edu.au
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1996/06/17 07:20:53 deraadt Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 1996/06/17 07:20:53 deraadt Exp $";
d103 5
a1044 2
    char *nullenv[1];   

d1089 1
a1089 2
        nullenv[0] = NULL;
        execve(prog, args, nullenv);
@


1.8
log
@parse args before tty options file; netbsd pr#2554; from Davyd.Norris@@fcollins.com.au
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 1996/05/11 15:41:24 deraadt Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: main.c,v 1.7 1996/05/11 15:41:24 deraadt Exp $";
d81 4
d89 1
d130 4
d164 1
d166 1
d172 8
d181 1
a181 1
	perror("couldn't get hostname");
d190 2
a191 2
     * the system options file, the user's options file, and the command
     * line arguments.
d198 6
a203 4
    if (!options_from_file(_PATH_SYSOPTIONS, REQ_SYSOPTIONS, 0) ||
	!options_from_user() ||
	!parse_args(argc-1, argv+1) ||
	!options_for_tty() )
d231 2
d239 3
d332 7
d424 10
d513 1
a513 1
		    ccp_open(0);
d551 2
a552 1
	    if (pidfilename[0] != 0 && unlink(pidfilename) < 0 && errno != ENOENT) 
d733 3
d925 5
a929 1
    note_debug_level();
d981 27
a1007 5
	dup2(in, 0);
	dup2(out, 1);
	errfd = open(_PATH_CONNERRS, O_WRONLY | O_APPEND | O_CREAT, 0644);
	if (errfd >= 0)
	    dup2(errfd, 2);
d1040 2
d1060 1
d1085 3
a1087 1
	execv(prog, args);
a1183 3
#ifdef __STDC__
#include <stdarg.h>

d1185 1
a1185 1
pr_log(void *arg, char *fmt, ...)
d1191 1
d1193 7
a1199 24
    vsprintf(buf, fmt, pvar);
    va_end(pvar);

    n = strlen(buf);
    if (linep + n + 1 > line + sizeof(line)) {
	syslog(LOG_DEBUG, "%s", line);
	linep = line;
    }
    strcpy(linep, buf);
    linep += n;
}

#else /* __STDC__ */
#include <varargs.h>

static void
pr_log(arg, fmt, va_alist)
void *arg;
char *fmt;
va_dcl
{
    int n;
    va_list pvar;
    char buf[256];
a1200 1
    va_start(pvar);
a1211 1
#endif
d1229 3
a1231 1
	if (' ' <= c && c <= '~')
d1233 15
a1247 2
	else
	    printer(arg, "\\%.3o", c);
d1249 1
d1263 243
@


1.7
log
@check before unlinking pidfile
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1996/03/25 15:55:49 niklas Exp $	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 1996/03/25 15:55:49 niklas Exp $";
a179 1
	!options_for_tty() ||
d181 2
a182 1
	!parse_args(argc-1, argv+1))
@


1.6
log
@sync to netbsd 960418
@
text
@d508 1
a508 1
	    if (unlink(pidfilename) < 0 && errno != ENOENT) 
@


1.5
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d23 1
a23 1
static char rcsid[] = "$OpenBSD$";
d142 1
a142 1
void
d1009 1
a1009 1
	execve(prog, args);
@


1.4
log
@sleep() call not needed (from NetBSD).
@
text
@d1 2
d23 1
a23 1
static char rcsid[] = "$Id: main.c,v 1.3 1996/01/07 09:55:33 deraadt Exp $";
d29 1
d57 4
d77 1
a77 2
static pid_t	pid;		/* Our pid */
static pid_t	pgrpid;		/* Process Group ID */
d80 1
a80 1
int fd = -1;			/* Device file descriptor */
a85 2
static int initfdflags = -1;	/* Initial file descriptor flags */

d87 1
a87 1
static u_char inpacket_buf[PPP_MRU+PPP_HDRLEN]; /* buffer for incoming packet */
d92 3
a94 1
int baud_rate;
d98 8
a105 1
/* prototypes */
d112 4
a115 15

static void get_input __P((void));
void establish_ppp __P((void));
void calltimeout __P((void));
struct timeval *timeleft __P((struct timeval *));
void reap_kids __P((void));
void cleanup __P((int, caddr_t));
void close_fd __P((void));
void die __P((int));
void novm __P((char *));

void log_packet __P((u_char *, int, char *));
void format_packet __P((u_char *, int,
			   void (*) (void *, char *, ...), void *));
void pr_log __P((void *, char *, ...));
d128 1
d130 10
a139 19
static struct protent {
    u_short protocol;
    void (*init)();
    void (*input)();
    void (*protrej)();
    int  (*printpkt)();
    void (*datainput)();
    char *name;
} prottbl[] = {
    { PPP_LCP, lcp_init, lcp_input, lcp_protrej,
	  lcp_printpkt, NULL, "LCP" },
    { PPP_IPCP, ipcp_init, ipcp_input, ipcp_protrej,
	  ipcp_printpkt, NULL, "IPCP" },
    { PPP_PAP, upap_init, upap_input, upap_protrej,
	  upap_printpkt, NULL, "PAP" },
    { PPP_CHAP, ChapInit, ChapInput, ChapProtocolReject,
	  ChapPrintPkt, NULL, "CHAP" },
    { PPP_CCP, ccp_init, ccp_input, ccp_protrej,
	  ccp_printpkt, ccp_datainput, "CCP" },
d142 1
a142 2
#define N_PROTO		(sizeof(prottbl) / sizeof(prottbl[0]))

d147 1
a147 1
    int i, nonblock;
a148 1
    struct cmd *cmdp;
d154 1
a168 5
    if (!ppp_available()) {
	fprintf(stderr, no_ppp_msg);
	exit(1);
    }

d174 2
a175 2
    for (i = 0; i < N_PROTO; i++)
	(*prottbl[i].init)(0);
d180 1
d182 21
a202 5
	!parse_args(argc-1, argv+1) ||
	!options_for_tty())
	die(1);
    check_auth_options();
    setipdefault();
d306 1
a306 1
     * Lock the device if we've been asked to.
d308 53
a360 3
    if (lockflag && !default_device)
	if (lock(devnam) < 0)
	    die(1);
d362 8
a369 1
    do {
d378 1
a378 1
	if ((fd = open(devnam, nonblock | O_RDWR, 0)) < 0) {
d380 1
a380 5
	    die(1);
	}
	if ((initfdflags = fcntl(fd, F_GETFL)) == -1) {
	    syslog(LOG_ERR, "Couldn't get device fd flags: %m");
	    die(1);
d383 4
a386 2
	    initfdflags &= ~O_NONBLOCK;
	    fcntl(fd, F_SETFL, initfdflags);
d396 1
a396 1
	    set_up_tty(fd, 1);
d400 1
a400 1
		setdtr(fd, FALSE);
d402 1
a402 1
		setdtr(fd, TRUE);
d405 1
a405 1
	    if (device_script(connector, fd, fd) < 0) {
d407 2
a408 2
		setdtr(fd, FALSE);
		die(1);
d416 7
a422 1
	set_up_tty(fd, 0);
d425 1
a425 1
	establish_ppp();
d427 15
a441 11
	syslog(LOG_INFO, "Using interface ppp%d", ifunit);
	(void) sprintf(ifname, "ppp%d", ifunit);

	/* write pid to file */
	(void) sprintf(pidfilename, "%s%s.pid", _PATH_VARRUN, ifname);
	if ((pidfile = fopen(pidfilename, "w")) != NULL) {
	    fprintf(pidfile, "%d\n", pid);
	    (void) fclose(pidfile);
	} else {
	    syslog(LOG_ERR, "Failed to create pid file %s: %m", pidfilename);
	    pidfilename[0] = 0;
d445 2
a446 1
	 * Set device for non-blocking reads.
d448 3
a450 5
	if (fcntl(fd, F_SETFL, initfdflags | O_NONBLOCK) == -1) {
	    syslog(LOG_ERR, "Couldn't set device to non-blocking mode: %m");
	    die(1);
	}
  
d452 1
a452 1
	 * Block all signals, start opening the connection, and wait for
d463 2
a464 1
		lcp_close(0);
d478 10
a488 1
	 * First we need to reset non-blocking mode.
d491 3
a493 6
	if (initfdflags != -1 && fcntl(fd, F_SETFL, initfdflags) >= 0)
	    initfdflags = -1;
	disestablish_ppp();
	if (disconnector) {
	    set_up_tty(fd, 1);
	    if (device_script(disconnector, fd, fd) < 0) {
d500 12
a511 4
	close_fd();
	if (unlink(pidfilename) < 0 && errno != ENOENT) 
	    syslog(LOG_WARNING, "unable to delete pid file: %m");
	pidfilename[0] = 0;
d513 21
a533 1
    } while (persist);
d538 9
d557 1
d569 1
a569 1
	phase = PHASE_DEAD;
d597 3
a599 3
    for (i = 0; i < sizeof (prottbl) / sizeof (struct protent); i++) {
	if (prottbl[i].protocol == protocol) {
	    (*prottbl[i].input)(0, p, len);
d602 3
a604 3
        if (protocol == (prottbl[i].protocol & ~0x8000)
	    && prottbl[i].datainput != NULL) {
	    (*prottbl[i].datainput)(0, p, len);
d610 1
a610 1
    	syslog(LOG_WARNING, "Unknown protocol (0x%x) received", protocol);
a615 36
 * demuxprotrej - Demultiplex a Protocol-Reject.
 */
void
demuxprotrej(unit, protocol)
    int unit;
    u_short protocol;
{
    int i;

    /*
     * Upcall the proper Protocol-Reject routine.
     */
    for (i = 0; i < sizeof (prottbl) / sizeof (struct protent); i++)
	if (prottbl[i].protocol == protocol) {
	    (*prottbl[i].protrej)(unit);
	    return;
	}

    syslog(LOG_WARNING,
	   "demuxprotrej: Unrecognized Protocol-Reject for protocol 0x%x",
	   protocol);
}


/*
 * bad_signal - We've caught a fatal signal.  Clean up state and exit.
 */
static void
bad_signal(sig)
    int sig;
{
    syslog(LOG_ERR, "Fatal signal %d", sig);
    die(1);
}

/*
d631 1
a631 1
    cleanup(0, NULL);
d637 13
d653 2
a654 4
void
cleanup(status, arg)
    int status;
    caddr_t arg;
d656 4
a659 2
    if (fd >= 0)
	close_fd();
d665 1
a665 1
    if (lockflag && !default_device)
d670 1
a670 1
 * close_fd - restore the terminal device and close it.
d672 2
a673 2
void
close_fd()
d675 1
a675 1
    disestablish_ppp();
d679 5
a683 1
	setdtr(fd, FALSE);
d687 1
a687 3
    if (initfdflags != -1 && fcntl(fd, F_SETFL, initfdflags) < 0)
	syslog(LOG_WARNING, "Couldn't restore device fd flags: %m");
    initfdflags = -1;
d689 2
a690 4
    restore_tty();

    close(fd);
    fd = -1;
a754 1
    struct itimerval itv;
a755 1
    int reschedule = 0;
d774 1
a774 1
void
d802 1
a802 1
struct timeval *
d897 12
d912 1
a912 1
int
d929 1
d984 1
d988 1
a988 2
	close (fd);  /* tty interface to the ppp device */
	/* XXX should call sysdep cleanup procedure here */
d1024 1
a1024 1
void
d1080 1
d1086 2
a1087 2
	for (i = 0; i < N_PROTO; ++i)
	    if (proto == prottbl[i].protocol)
d1089 3
a1091 3
	if (i < N_PROTO) {
	    printer(arg, "[%s", prottbl[i].name);
	    n = (*prottbl[i].printpkt)(p, len, printer, arg);
d1109 1
a1109 1
void
d1132 1
a1132 1
void
@


1.3
log
@pass a useful environment to ip-up/ip-down scripts; this is not a
security problem
different fix than from banshee@@gabriella.resort.com; netbsd pr#1866
@
text
@d21 1
a21 1
static char rcsid[] = "$Id: main.c,v 1.2 1995/12/28 14:05:06 hannken Exp $";
a584 1
    sleep(1);
@


1.2
log
@Leave DTR down for one second on exit so modem may catch the DTR to false
transition. (from hannken@@eis.cs.tu-bs.de)
@
text
@d21 1
a21 1
static char rcsid[] = "$Id: main.c,v 1.1.1.1 1995/10/18 08:47:59 deraadt Exp $";
a865 1
    char *nullenv[1];
d908 1
a908 3
	/* run the program; give it a null environment */
	nullenv[0] = NULL;
	execve(prog, args, nullenv);
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
static char rcsid[] = "$Id: main.c,v 1.15 1995/08/17 12:03:57 paulus Exp $";
d585 1
d588 1
a588 1
    if (modem)
d590 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
