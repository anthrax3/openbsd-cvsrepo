head	1.18;
access;
symbols
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.12
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.8
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.4
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.13.0.16
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.12
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.10
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.28
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.24
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.22
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.20
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.18
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.16
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.14
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.12
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.10
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.14
	OPENBSD_2_8:1.7.0.12
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.10
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2015.01.15.23.19.48;	author tedu;	state Exp;
branches;
next	1.17;
commitid	Czp0ooDmHxEWQBA1;

1.17
date	2014.05.17.20.31.07;	author chl;	state Exp;
branches;
next	1.16;

1.16
date	2014.01.21.23.54.50;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2014.01.21.22.56.31;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2013.09.29.16.24.21;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.04.20.25.07;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.13.00.12.10;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.17.19.42.38;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.28.07;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.23.15.34.02;	author lebel;	state Exp;
branches;
next	1.7;

1.7
date	98.01.17.20.30.19;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.05.04.32.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.01.03.20.32.11;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.12.23.13.22.39;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.07.20.12.02.06;	author joshd;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.35;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.58;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.58;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@fully remove disabled mschap support, which does weird DES things.
(already won't build for some time since the removal of md4)
ok naddy
@
text
@/*	$OpenBSD: chap.c,v 1.17 2014/05/17 20:31:07 chl Exp $	*/

/*
 * chap.c - Challenge Handshake Authentication Protocol.
 *
 * Copyright (c) 1989-2002 Paul Mackerras. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name(s) of the authors of this software must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission.
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Paul Mackerras
 *     <paulus@@samba.org>".
 *
 * THE AUTHORS OF THIS SOFTWARE DISCLAIM ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Copyright (c) 1991 Gregory M. Christy.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Gregory M. Christy.  The name of the author may not be used to
 * endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
 * TODO:
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/time.h>
#include <syslog.h>
#include <md5.h>

#include "pppd.h"
#include "chap.h"

/*
 * Protocol entry points.
 */
static void ChapInit(int);
static void ChapLowerUp(int);
static void ChapLowerDown(int);
static void ChapInput(int, u_char *, int);
static void ChapProtocolReject(int);
static int  ChapPrintPkt(u_char *, int, void (*)(void *, char *, ...), void *);

struct protent chap_protent = {
    PPP_CHAP,
    ChapInit,
    ChapInput,
    ChapProtocolReject,
    ChapLowerUp,
    ChapLowerDown,
    NULL,
    NULL,
    ChapPrintPkt,
    NULL,
    1,
    "CHAP",
    NULL,
    NULL,
    NULL
};

chap_state chap[NUM_PPP];		/* CHAP state; one for each unit */

static void ChapChallengeTimeout(void *);
static void ChapResponseTimeout(void *);
static void ChapReceiveChallenge(chap_state *, u_char *, int, int);
static void ChapRechallenge(void *);
static void ChapReceiveResponse(chap_state *, u_char *, int, int);
static void ChapReceiveSuccess(chap_state *, u_char *, int, int);
static void ChapReceiveFailure(chap_state *, u_char *, int, int);
static void ChapSendStatus(chap_state *, int);
static void ChapSendChallenge(chap_state *);
static void ChapSendResponse(chap_state *);
static void ChapGenChallenge(chap_state *);

/*
 * ChapInit - Initialize a CHAP unit.
 */
static void
ChapInit(unit)
    int unit;
{
    chap_state *cstate = &chap[unit];

    BZERO(cstate, sizeof(*cstate));
    cstate->unit = unit;
    cstate->clientstate = CHAPCS_INITIAL;
    cstate->serverstate = CHAPSS_INITIAL;
    cstate->timeouttime = CHAP_DEFTIMEOUT;
    cstate->max_transmits = CHAP_DEFTRANSMITS;
    /* random number generator is initialized in magic_init */
}


/*
 * ChapAuthWithPeer - Authenticate us with our peer (start client).
 *
 */
void
ChapAuthWithPeer(unit, our_name, digest)
    int unit;
    char *our_name;
    int digest;
{
    chap_state *cstate = &chap[unit];

    cstate->resp_name = our_name;
    cstate->resp_type = digest;

    if (cstate->clientstate == CHAPCS_INITIAL ||
	cstate->clientstate == CHAPCS_PENDING) {
	/* lower layer isn't up - wait until later */
	cstate->clientstate = CHAPCS_PENDING;
	return;
    }

    /*
     * We get here as a result of LCP coming up.
     * So even if CHAP was open before, we will
     * have to re-authenticate ourselves.
     */
    cstate->clientstate = CHAPCS_LISTEN;
}


/*
 * ChapAuthPeer - Authenticate our peer (start server).
 */
void
ChapAuthPeer(unit, our_name, digest)
    int unit;
    char *our_name;
    int digest;
{
    chap_state *cstate = &chap[unit];

    cstate->chal_name = our_name;
    cstate->chal_type = digest;

    if (cstate->serverstate == CHAPSS_INITIAL ||
	cstate->serverstate == CHAPSS_PENDING) {
	/* lower layer isn't up - wait until later */
	cstate->serverstate = CHAPSS_PENDING;
	return;
    }

    ChapGenChallenge(cstate);
    ChapSendChallenge(cstate);		/* crank it up dude! */
    cstate->serverstate = CHAPSS_INITIAL_CHAL;
}


/*
 * ChapChallengeTimeout - Timeout expired on sending challenge.
 */
static void
ChapChallengeTimeout(arg)
    void *arg;
{
    chap_state *cstate = (chap_state *) arg;

    /* if we aren't sending challenges, don't worry.  then again we */
    /* probably shouldn't be here either */
    if (cstate->serverstate != CHAPSS_INITIAL_CHAL &&
	cstate->serverstate != CHAPSS_RECHALLENGE)
	return;

    if (cstate->chal_transmits >= cstate->max_transmits) {
	/* give up on peer */
	syslog(LOG_ERR, "Peer failed to respond to CHAP challenge");
	cstate->serverstate = CHAPSS_BADAUTH;
	auth_peer_fail(cstate->unit, PPP_CHAP);
	return;
    }

    ChapSendChallenge(cstate);		/* Re-send challenge */
}


/*
 * ChapResponseTimeout - Timeout expired on sending response.
 */
static void
ChapResponseTimeout(arg)
    void *arg;
{
    chap_state *cstate = (chap_state *) arg;

    /* if we aren't sending a response, don't worry. */
    if (cstate->clientstate != CHAPCS_RESPONSE)
	return;

    ChapSendResponse(cstate);		/* re-send response */
}


/*
 * ChapRechallenge - Time to challenge the peer again.
 */
static void
ChapRechallenge(arg)
    void *arg;
{
    chap_state *cstate = (chap_state *) arg;

    /* if we aren't sending a response, don't worry. */
    if (cstate->serverstate != CHAPSS_OPEN)
	return;

    ChapGenChallenge(cstate);
    ChapSendChallenge(cstate);
    cstate->serverstate = CHAPSS_RECHALLENGE;
}


/*
 * ChapLowerUp - The lower layer is up.
 *
 * Start up if we have pending requests.
 */
static void
ChapLowerUp(unit)
    int unit;
{
    chap_state *cstate = &chap[unit];

    if (cstate->clientstate == CHAPCS_INITIAL)
	cstate->clientstate = CHAPCS_CLOSED;
    else if (cstate->clientstate == CHAPCS_PENDING)
	cstate->clientstate = CHAPCS_LISTEN;

    if (cstate->serverstate == CHAPSS_INITIAL)
	cstate->serverstate = CHAPSS_CLOSED;
    else if (cstate->serverstate == CHAPSS_PENDING) {
	ChapGenChallenge(cstate);
	ChapSendChallenge(cstate);
	cstate->serverstate = CHAPSS_INITIAL_CHAL;
    }
}


/*
 * ChapLowerDown - The lower layer is down.
 *
 * Cancel all timeouts.
 */
static void
ChapLowerDown(unit)
    int unit;
{
    chap_state *cstate = &chap[unit];

    /* Timeout(s) pending?  Cancel if so. */
    if (cstate->serverstate == CHAPSS_INITIAL_CHAL ||
	cstate->serverstate == CHAPSS_RECHALLENGE)
	UNTIMEOUT(ChapChallengeTimeout, cstate);
    else if (cstate->serverstate == CHAPSS_OPEN
	     && cstate->chal_interval != 0)
	UNTIMEOUT(ChapRechallenge, cstate);
    if (cstate->clientstate == CHAPCS_RESPONSE)
	UNTIMEOUT(ChapResponseTimeout, cstate);

    cstate->clientstate = CHAPCS_INITIAL;
    cstate->serverstate = CHAPSS_INITIAL;
}


/*
 * ChapProtocolReject - Peer doesn't grok CHAP.
 */
static void
ChapProtocolReject(unit)
    int unit;
{
    chap_state *cstate = &chap[unit];

    if (cstate->serverstate != CHAPSS_INITIAL &&
	cstate->serverstate != CHAPSS_CLOSED)
	auth_peer_fail(unit, PPP_CHAP);
    if (cstate->clientstate != CHAPCS_INITIAL &&
	cstate->clientstate != CHAPCS_CLOSED)
	auth_withpeer_fail(unit, PPP_CHAP);
    ChapLowerDown(unit);		/* shutdown chap */
}


/*
 * ChapInput - Input CHAP packet.
 */
static void
ChapInput(unit, inpacket, packet_len)
    int unit;
    u_char *inpacket;
    int packet_len;
{
    chap_state *cstate = &chap[unit];
    u_char *inp;
    u_char code, id;
    int len;

    /*
     * Parse header (code, id and length).
     * If packet too short, drop it.
     */
    inp = inpacket;
    if (packet_len < CHAP_HEADERLEN) {
	CHAPDEBUG((LOG_INFO, "ChapInput: rcvd short header."));
	return;
    }
    GETCHAR(code, inp);
    GETCHAR(id, inp);
    GETSHORT(len, inp);
    if (len < CHAP_HEADERLEN) {
	CHAPDEBUG((LOG_INFO, "ChapInput: rcvd illegal length."));
	return;
    }
    if (len > packet_len) {
	CHAPDEBUG((LOG_INFO, "ChapInput: rcvd short packet."));
	return;
    }
    len -= CHAP_HEADERLEN;

    /*
     * Action depends on code (as in fact it usually does :-).
     */
    switch (code) {
    case CHAP_CHALLENGE:
	ChapReceiveChallenge(cstate, inp, id, len);
	break;

    case CHAP_RESPONSE:
	ChapReceiveResponse(cstate, inp, id, len);
	break;

    case CHAP_FAILURE:
	ChapReceiveFailure(cstate, inp, id, len);
	break;

    case CHAP_SUCCESS:
	ChapReceiveSuccess(cstate, inp, id, len);
	break;

    default:				/* Need code reject? */
	syslog(LOG_WARNING, "Unknown CHAP code (%d) received.", code);
	break;
    }
}


/*
 * ChapReceiveChallenge - Receive Challenge and send Response.
 */
static void
ChapReceiveChallenge(cstate, inp, id, len)
    chap_state *cstate;
    u_char *inp;
    int id;
    int len;
{
    int rchallenge_len;
    u_char *rchallenge;
    int secret_len;
    char secret[MAXSECRETLEN];
    char rhostname[256];
    MD5_CTX mdContext;
    u_char hash[MD5_SIGNATURE_SIZE];

    CHAPDEBUG((LOG_INFO, "ChapReceiveChallenge: Rcvd id %d.", id));
    if (cstate->clientstate == CHAPCS_CLOSED ||
	cstate->clientstate == CHAPCS_PENDING) {
	CHAPDEBUG((LOG_INFO, "ChapReceiveChallenge: in state %d",
		   cstate->clientstate));
	return;
    }

    if (len < 2) {
	CHAPDEBUG((LOG_INFO, "ChapReceiveChallenge: rcvd short packet."));
	return;
    }

    GETCHAR(rchallenge_len, inp);
    len -= sizeof (u_char) + rchallenge_len;	/* now name field length */
    if (len < 0) {
	CHAPDEBUG((LOG_INFO, "ChapReceiveChallenge: rcvd short packet."));
	return;
    }
    rchallenge = inp;
    INCPTR(rchallenge_len, inp);

    if (len >= sizeof(rhostname))
	len = sizeof(rhostname) - 1;
    BCOPY(inp, rhostname, len);
    rhostname[len] = '\000';

    CHAPDEBUG((LOG_INFO, "ChapReceiveChallenge: received name field '%s'",
	rhostname));

    /* Microsoft doesn't send their name back in the PPP packet */
    if (remote_name[0] != 0 && (explicit_remote || rhostname[0] == 0)) {
	strlcpy(rhostname, remote_name, sizeof(rhostname));
	CHAPDEBUG((LOG_INFO, "ChapReceiveChallenge: using '%s' as remote name",
		  rhostname));
    }

    /* get secret for authenticating ourselves with the specified host */
    if (!get_secret(cstate->unit, cstate->resp_name, rhostname,
		    secret, &secret_len, 0)) {
	secret_len = 0;		/* assume null secret if can't find one */
	syslog(LOG_WARNING, "No CHAP secret found for authenticating us to %s",
	       rhostname);
    }

    /* cancel response send timeout if necessary */
    if (cstate->clientstate == CHAPCS_RESPONSE)
	UNTIMEOUT(ChapResponseTimeout, cstate);

    cstate->resp_id = id;
    cstate->resp_transmits = 0;

    /*  generate MD based on negotiated type */
    switch (cstate->resp_type) {

    case CHAP_DIGEST_MD5:
	MD5Init(&mdContext);
	MD5Update(&mdContext, &cstate->resp_id, 1);
	MD5Update(&mdContext, secret, secret_len);
	MD5Update(&mdContext, rchallenge, rchallenge_len);
	MD5Final(hash, &mdContext);
	BCOPY(hash, cstate->response, MD5_SIGNATURE_SIZE);
	cstate->resp_length = MD5_SIGNATURE_SIZE;
	break;

    default:
	CHAPDEBUG((LOG_INFO, "unknown digest type %d", cstate->resp_type));
	return;
    }

    BZERO(secret, sizeof(secret));
    ChapSendResponse(cstate);
}


/*
 * ChapReceiveResponse - Receive and process response.
 */
static void
ChapReceiveResponse(cstate, inp, id, len)
    chap_state *cstate;
    u_char *inp;
    int id;
    int len;
{
    u_char *remmd, remmd_len;
    int secret_len, old_state;
    int code;
    char rhostname[256];
    MD5_CTX mdContext;
    char secret[MAXSECRETLEN];
    u_char hash[MD5_SIGNATURE_SIZE];

    CHAPDEBUG((LOG_INFO, "ChapReceiveResponse: Rcvd id %d.", id));

    if (cstate->serverstate == CHAPSS_CLOSED ||
	cstate->serverstate == CHAPSS_PENDING) {
	CHAPDEBUG((LOG_INFO, "ChapReceiveResponse: in state %d",
		   cstate->serverstate));
	return;
    }

    if (id != cstate->chal_id)
	return;			/* doesn't match ID of last challenge */

    /*
     * If we have received a duplicate or bogus Response,
     * we have to send the same answer (Success/Failure)
     * as we did for the first Response we saw.
     */
    if (cstate->serverstate == CHAPSS_OPEN) {
	ChapSendStatus(cstate, CHAP_SUCCESS);
	return;
    }
    if (cstate->serverstate == CHAPSS_BADAUTH) {
	ChapSendStatus(cstate, CHAP_FAILURE);
	return;
    }

    if (len < 2) {
	CHAPDEBUG((LOG_INFO, "ChapReceiveResponse: rcvd short packet."));
	return;
    }
    GETCHAR(remmd_len, inp);		/* get length of MD */
    remmd = inp;			/* get pointer to MD */
    INCPTR(remmd_len, inp);

    len -= sizeof (u_char) + remmd_len;
    if (len < 0) {
	CHAPDEBUG((LOG_INFO, "ChapReceiveResponse: rcvd short packet."));
	return;
    }

    UNTIMEOUT(ChapChallengeTimeout, cstate);

    if (len >= sizeof(rhostname))
	len = sizeof(rhostname) - 1;
    BCOPY(inp, rhostname, len);
    rhostname[len] = '\000';

    CHAPDEBUG((LOG_INFO, "ChapReceiveResponse: received name field: %s",
	       rhostname));

    /*
     * Get secret for authenticating them with us,
     * do the hash ourselves, and compare the result.
     */
    code = CHAP_FAILURE;
    if (!get_secret(cstate->unit, rhostname, cstate->chal_name,
		   secret, &secret_len, 1)) {
	syslog(LOG_WARNING, "No CHAP secret found for authenticating %s",
	       rhostname);
    } else {

	/*  generate MD based on negotiated type */
	switch (cstate->chal_type) {

	case CHAP_DIGEST_MD5:		/* only MD5 is defined for now */
	    if (remmd_len != MD5_SIGNATURE_SIZE)
		break;			/* it's not even the right length */
	    MD5Init(&mdContext);
	    MD5Update(&mdContext, &cstate->chal_id, 1);
	    MD5Update(&mdContext, secret, secret_len);
	    MD5Update(&mdContext, cstate->challenge, cstate->chal_len);
	    MD5Final(hash, &mdContext);

	    /* compare local and remote MDs and send the appropriate status */
	    if (memcmp (hash, remmd, MD5_SIGNATURE_SIZE) == 0)
		code = CHAP_SUCCESS;	/* they are the same! */
	    break;

	default:
	    CHAPDEBUG((LOG_INFO, "unknown digest type %d", cstate->chal_type));
	}
    }

    BZERO(secret, sizeof(secret));
    ChapSendStatus(cstate, code);

    if (code == CHAP_SUCCESS) {
	old_state = cstate->serverstate;
	cstate->serverstate = CHAPSS_OPEN;
	if (old_state == CHAPSS_INITIAL_CHAL) {
            auth_peer_success(cstate->unit, PPP_CHAP, rhostname, len);
	}
	if (cstate->chal_interval != 0)
	    TIMEOUT(ChapRechallenge, cstate, cstate->chal_interval);
	syslog(LOG_NOTICE, "CHAP peer authentication succeeded for %s",
		rhostname);

    } else {
	syslog(LOG_ERR, "CHAP peer authentication failed for remote host %s",
		rhostname);
	cstate->serverstate = CHAPSS_BADAUTH;
	auth_peer_fail(cstate->unit, PPP_CHAP);
    }
}

/*
 * ChapReceiveSuccess - Receive Success
 */
static void
ChapReceiveSuccess(cstate, inp, id, len)
    chap_state *cstate;
    u_char *inp;
    u_char id;
    int len;
{

    CHAPDEBUG((LOG_INFO, "ChapReceiveSuccess: Rcvd id %d.", id));

    if (cstate->clientstate == CHAPCS_OPEN)
	/* presumably an answer to a duplicate response */
	return;

    if (cstate->clientstate != CHAPCS_RESPONSE) {
	/* don't know what this is */
	CHAPDEBUG((LOG_INFO, "ChapReceiveSuccess: in state %d\n",
		   cstate->clientstate));
	return;
    }

    UNTIMEOUT(ChapResponseTimeout, cstate);

    /*
     * Print message.
     */
    if (len > 0)
	PRINTMSG(inp, len);

    cstate->clientstate = CHAPCS_OPEN;

    auth_withpeer_success(cstate->unit, PPP_CHAP);
}


/*
 * ChapReceiveFailure - Receive failure.
 */
static void
ChapReceiveFailure(cstate, inp, id, len)
    chap_state *cstate;
    u_char *inp;
    u_char id;
    int len;
{
    CHAPDEBUG((LOG_INFO, "ChapReceiveFailure: Rcvd id %d.", id));

    if (cstate->clientstate != CHAPCS_RESPONSE) {
	/* don't know what this is */
	CHAPDEBUG((LOG_INFO, "ChapReceiveFailure: in state %d\n",
		   cstate->clientstate));
	return;
    }

    UNTIMEOUT(ChapResponseTimeout, cstate);

    /*
     * Print message.
     */
    if (len > 0)
	PRINTMSG(inp, len);

    syslog(LOG_ERR, "CHAP authentication failed");
    auth_withpeer_fail(cstate->unit, PPP_CHAP);
}


/*
 * ChapSendChallenge - Send an Authenticate challenge.
 */
static void
ChapSendChallenge(cstate)
    chap_state *cstate;
{
    u_char *outp;
    int chal_len, name_len;
    int outlen;

    chal_len = cstate->chal_len;
    name_len = strlen(cstate->chal_name);
    outlen = CHAP_HEADERLEN + sizeof (u_char) + chal_len + name_len;
    outp = outpacket_buf;

    MAKEHEADER(outp, PPP_CHAP);		/* paste in a CHAP header */

    PUTCHAR(CHAP_CHALLENGE, outp);
    PUTCHAR(cstate->chal_id, outp);
    PUTSHORT(outlen, outp);

    PUTCHAR(chal_len, outp);		/* put length of challenge */
    BCOPY(cstate->challenge, outp, chal_len);
    INCPTR(chal_len, outp);

    BCOPY(cstate->chal_name, outp, name_len);	/* append hostname */

    output(cstate->unit, outpacket_buf, outlen + PPP_HDRLEN);

    CHAPDEBUG((LOG_INFO, "ChapSendChallenge: Sent id %d.", cstate->chal_id));

    TIMEOUT(ChapChallengeTimeout, cstate, cstate->timeouttime);
    ++cstate->chal_transmits;
}


/*
 * ChapSendStatus - Send a status response (ack or nak).
 */
static void
ChapSendStatus(cstate, code)
    chap_state *cstate;
    int code;
{
    u_char *outp;
    int outlen, msglen;
    char msg[256];

    if (code == CHAP_SUCCESS)
	snprintf(msg, sizeof msg, "Welcome to %s.", hostname);
    else
	snprintf(msg, sizeof msg, "I don't like you.  Go 'way.");
    msglen = strlen(msg);

    outlen = CHAP_HEADERLEN + msglen;
    outp = outpacket_buf;

    MAKEHEADER(outp, PPP_CHAP);	/* paste in a header */

    PUTCHAR(code, outp);
    PUTCHAR(cstate->chal_id, outp);
    PUTSHORT(outlen, outp);
    BCOPY(msg, outp, msglen);
    output(cstate->unit, outpacket_buf, outlen + PPP_HDRLEN);

    CHAPDEBUG((LOG_INFO, "ChapSendStatus: Sent code %d, id %d.", code,
	       cstate->chal_id));
}

/*
 * ChapGenChallenge is used to generate a pseudo-random challenge string of
 * a pseudo-random length between min_len and max_len.  The challenge
 * string and its length are stored in *cstate, and various other fields of
 * *cstate are initialized.
 */

static void
ChapGenChallenge(cstate)
    chap_state *cstate;
{
    int chal_len;

    /* pick a random challenge length >= MIN_CHALLENGE_LENGTH and
       <= MAX_CHALLENGE_LENGTH */
    chal_len = MIN_CHALLENGE_LENGTH +
	arc4random_uniform(MAX_CHALLENGE_LENGTH - MIN_CHALLENGE_LENGTH + 1);
			    
    cstate->chal_len = chal_len;
    cstate->chal_id = ++cstate->id;
    cstate->chal_transmits = 0;

    /* generate a random string */
    arc4random_buf(cstate->challenge, chal_len);
}

/*
 * ChapSendResponse - send a response packet with values as specified
 * in *cstate.
 */
/* ARGSUSED */
static void
ChapSendResponse(cstate)
    chap_state *cstate;
{
    u_char *outp;
    int outlen, md_len, name_len;

    md_len = cstate->resp_length;
    name_len = strlen(cstate->resp_name);
    outlen = CHAP_HEADERLEN + sizeof (u_char) + md_len + name_len;
    outp = outpacket_buf;

    MAKEHEADER(outp, PPP_CHAP);

    PUTCHAR(CHAP_RESPONSE, outp);	/* we are a response */
    PUTCHAR(cstate->resp_id, outp);	/* copy id from challenge packet */
    PUTSHORT(outlen, outp);		/* packet length */

    PUTCHAR(md_len, outp);		/* length of MD */
    BCOPY(cstate->response, outp, md_len);	/* copy MD to buffer */
    INCPTR(md_len, outp);

    BCOPY(cstate->resp_name, outp, name_len); /* append our name */

    /* send the packet */
    output(cstate->unit, outpacket_buf, outlen + PPP_HDRLEN);

    cstate->clientstate = CHAPCS_RESPONSE;
    TIMEOUT(ChapResponseTimeout, cstate, cstate->timeouttime);
    ++cstate->resp_transmits;
}

/*
 * ChapPrintPkt - print the contents of a CHAP packet.
 */
static char *ChapCodenames[] = {
    "Challenge", "Response", "Success", "Failure"
};

static int
ChapPrintPkt(p, plen, printer, arg)
    u_char *p;
    int plen;
    void (*printer)(void *, char *, ...);
    void *arg;
{
    int code, id, len;
    int clen, nlen;
    u_char x;

    if (plen < CHAP_HEADERLEN)
	return 0;
    GETCHAR(code, p);
    GETCHAR(id, p);
    GETSHORT(len, p);
    if (len < CHAP_HEADERLEN || len > plen)
	return 0;

    if (code >= 1 && code <= sizeof(ChapCodenames) / sizeof(char *))
	printer(arg, " %s", ChapCodenames[code-1]);
    else
	printer(arg, " code=0x%x", code);
    printer(arg, " id=0x%x", id);
    len -= CHAP_HEADERLEN;
    switch (code) {
    case CHAP_CHALLENGE:
    case CHAP_RESPONSE:
	if (len < 1)
	    break;
	clen = p[0];
	if (len < clen + 1)
	    break;
	++p;
	nlen = len - clen - 1;
	printer(arg, " <");
	for (; clen > 0; --clen) {
	    GETCHAR(x, p);
	    printer(arg, "%.2x", x);
	}
	printer(arg, ">, name = ");
	print_string((char *)p, nlen, printer, arg);
	break;
    case CHAP_FAILURE:
    case CHAP_SUCCESS:
	printer(arg, " ");
	print_string((char *)p, len, printer, arg);
	break;
    default:
	for (clen = len; clen > 0; --clen) {
	    GETCHAR(x, p);
	    printer(arg, " %.2x", x);
	}
    }

    return len + CHAP_HEADERLEN;
}
@


1.17
log
@remove unused variable

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.16 2014/01/21 23:54:50 deraadt Exp $	*/
a68 4
#ifdef CHAPMS
#include "chap_ms.h"
#endif

a466 6

#ifdef CHAPMS
    case CHAP_MICROSOFT:
	ChapMS(cstate, rchallenge, rchallenge_len, secret, secret_len);
	break;
#endif
@


1.16
log
@use arc4random for chap generation; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.15 2014/01/21 22:56:31 jsg Exp $	*/
a762 2
    u_char *ptr = cstate->challenge;
    unsigned int i;
@


1.15
log
@include stdlib.h for drand48()
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.14 2013/09/29 16:24:21 deraadt Exp $	*/
d766 5
a770 5
    /* pick a random challenge length between MIN_CHALLENGE_LENGTH and
       MAX_CHALLENGE_LENGTH */
    chal_len =  (unsigned) ((drand48() *
			     (MAX_CHALLENGE_LENGTH - MIN_CHALLENGE_LENGTH)) +
			    MIN_CHALLENGE_LENGTH);
d776 1
a776 2
    for (i = 0; i < chal_len; i++ )
	*ptr++ = (char) (drand48() * 0xff);
@


1.14
log
@purge compat junk related to drand48; ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.13 2009/10/27 23:59:53 deraadt Exp $	*/
d59 1
@


1.13
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.12 2003/04/04 20:25:07 deraadt Exp $	*/
a112 3

extern double drand48(void);
extern void srand48(long);
@


1.12
log
@strlcpy and snprintf; various people ok
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.11 2002/09/13 00:12:10 deraadt Exp $	*/
a52 8

#ifndef lint
#if 0
static char rcsid[] = "Id: chap.c,v 1.15 1997/11/27 06:07:48 paulus Exp $";
#else
static char rcsid[] = "$OpenBSD: chap.c,v 1.11 2002/09/13 00:12:10 deraadt Exp $";
#endif
#endif
@


1.11
log
@Paul Mackerras and the Australian National University have worked things
out, and as a result, Paul now owns copyright on all these files, with the
proper terms.
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.10 2002/02/17 19:42:38 millert Exp $	*/
d58 1
a58 1
static char rcsid[] = "$OpenBSD: chap.c,v 1.10 2002/02/17 19:42:38 millert Exp $";
d741 1
a741 1
	sprintf(msg, "Welcome to %s.", hostname);
d743 1
a743 1
	sprintf(msg, "I don't like you.  Go 'way.");
@


1.10
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.9 2002/02/16 21:28:07 millert Exp $	*/
d6 22
a27 2
 * Copyright (c) 1993 The Australian National University.
 * All rights reserved.
d29 7
a35 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Australian National University.  The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d58 1
a58 1
static char rcsid[] = "$OpenBSD: chap.c,v 1.9 2002/02/16 21:28:07 millert Exp $";
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.8 2001/06/23 15:34:02 lebel Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: chap.c,v 1.8 2001/06/23 15:34:02 lebel Exp $";
d72 1
a72 2
static int  ChapPrintPkt __P((u_char *, int,
			      void (*)(void *, char *, ...), void *));
@


1.8
log
@use strlcpy vs strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.7 1998/01/17 20:30:19 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: chap.c,v 1.7 1998/01/17 20:30:19 millert Exp $";
d67 5
a71 5
static void ChapInit __P((int));
static void ChapLowerUp __P((int));
static void ChapLowerDown __P((int));
static void ChapInput __P((int, u_char *, int));
static void ChapProtocolReject __P((int));
d73 1
a73 1
			      void (*) __P((void *, char *, ...)), void *));
d95 11
a105 11
static void ChapChallengeTimeout __P((void *));
static void ChapResponseTimeout __P((void *));
static void ChapReceiveChallenge __P((chap_state *, u_char *, int, int));
static void ChapRechallenge __P((void *));
static void ChapReceiveResponse __P((chap_state *, u_char *, int, int));
static void ChapReceiveSuccess __P((chap_state *, u_char *, int, int));
static void ChapReceiveFailure __P((chap_state *, u_char *, int, int));
static void ChapSendStatus __P((chap_state *, int));
static void ChapSendChallenge __P((chap_state *));
static void ChapSendResponse __P((chap_state *));
static void ChapGenChallenge __P((chap_state *));
d107 2
a108 2
extern double drand48 __P((void));
extern void srand48 __P((long));
d823 1
a823 1
    void (*printer) __P((void *, char *, ...));
@


1.7
log
@ppp-2.3.3 + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.6 1997/09/05 04:32:35 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: chap.c,v 1.6 1997/09/05 04:32:35 millert Exp $";
d434 1
a434 2
	strncpy(rhostname, remote_name, sizeof(rhostname) - 1);
	rhostname[sizeof(rhostname) - 1] = 0;
@


1.6
log
@ppp 2.3.1
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.5 1997/01/03 20:32:11 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "Id: chap.c,v 1.14 1997/04/30 05:51:08 paulus Exp";
d42 1
a42 1
static char rcsid[] = "$OpenBSD: chap.c,v 1.5 1997/01/03 20:32:11 millert Exp $";
d95 2
a96 2
static void ChapChallengeTimeout __P((caddr_t));
static void ChapResponseTimeout __P((caddr_t));
d98 1
a98 1
static void ChapRechallenge __P((caddr_t));
d192 1
a192 1
    caddr_t arg;
d219 1
a219 1
    caddr_t arg;
d236 1
a236 1
    caddr_t arg;
d290 1
a290 1
	UNTIMEOUT(ChapChallengeTimeout, (caddr_t) cstate);
d293 1
a293 1
	UNTIMEOUT(ChapRechallenge, (caddr_t) cstate);
d295 1
a295 1
	UNTIMEOUT(ChapResponseTimeout, (caddr_t) cstate);
d450 1
a450 1
	UNTIMEOUT(ChapResponseTimeout, (caddr_t) cstate);
d542 1
a542 1
    UNTIMEOUT(ChapChallengeTimeout, (caddr_t) cstate);
d595 3
a597 1
	    TIMEOUT(ChapRechallenge, (caddr_t) cstate, cstate->chal_interval);
d600 2
a601 1
	syslog(LOG_ERR, "CHAP peer authentication failed");
d631 1
a631 1
    UNTIMEOUT(ChapResponseTimeout, (caddr_t) cstate);
d664 1
a664 1
    UNTIMEOUT(ChapResponseTimeout, (caddr_t) cstate);
d709 1
a709 1
    TIMEOUT(ChapChallengeTimeout, (caddr_t) cstate, cstate->timeouttime);
d809 1
a809 1
    TIMEOUT(ChapResponseTimeout, (caddr_t) cstate, cstate->timeouttime);
@


1.5
log
@Use correct md5 API for libc md5 routines.  Pointed out by niklas.
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.4 1996/12/23 13:22:39 mickey Exp $	*/
d39 5
a43 1
static char rcsid[] = "$OpenBSD: chap.c,v 1.4 1996/12/23 13:22:39 mickey Exp $";
d63 1
a63 1
   
d81 1
a81 1
    ChapLowerDown, 
a92 1

d98 1
d153 1
a153 1
     * So even if CHAP was open before, we will 
d170 1
a170 1
  
d195 1
a195 1
  
d260 1
a260 1
  
d286 1
a286 1
  
d334 1
a334 1
  
d356 1
a356 1
  
d364 1
a364 1
    
d368 1
a368 1
    
d400 2
a401 1
 
d433 5
a437 4
    if (rhostname[0] == 0 && cstate->resp_type == CHAP_MICROSOFT) {
        strcpy(rhostname, remote_name);
        CHAPDEBUG((LOG_INFO, "ChapReceiveChallenge: using '%s' as remote name",
                   rhostname));
d456 1
a456 1
    switch (cstate->resp_type) { 
d463 2
a464 1
	MD5Final(cstate->response, &mdContext);
d469 3
a471 3
    case CHAP_MICROSOFT:   
        ChapMS(cstate, rchallenge, rchallenge_len, secret, secret_len);
        break;
d500 1
a500 1
    unsigned char digest[MD5_SIGNATURE_SIZE];
d564 1
a564 1
	switch (cstate->chal_type) { 
d573 1
a573 1
	    MD5Final(digest, &mdContext); 
d576 1
a576 1
	    if (memcmp (digest, remmd, MD5_SIGNATURE_SIZE) == 0)
d703 1
a703 1
  
d733 1
a733 1
  
d739 1
a739 1
  
d759 2
a760 2
    /* pick a random challenge length between MIN_CHALLENGE_LENGTH and 
       MAX_CHALLENGE_LENGTH */  
@


1.4
log
@pppd 2.3b3 import. some minor buf oflow fixes and so.
try it out ppl, but i've got it running talking to cisco w/ all the AFs
enabled in kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.3 1996/07/20 12:02:06 joshd Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: chap.c,v 1.3 1996/07/20 12:02:06 joshd Exp $";
d51 1
a54 1
#include "md5.h"
d457 1
a457 2
	MD5Final(&mdContext);
	BCOPY(mdContext.digest, cstate->response, MD5_SIGNATURE_SIZE);
d493 1
d566 1
a566 1
	    MD5Final(&mdContext); 
d569 1
a569 1
	    if (memcmp (mdContext.digest, remmd, MD5_SIGNATURE_SIZE) == 0)
@


1.3
log
@Update pppd to 2.3a4:
Add redo option error-reporting, add PAM, add microsoft compatibility
kludges, bzero stuff at important places, add one or two options
other generic enhancements.  From: Paul.Mackerras@@cs.anu.edu.au
@
text
@d1 1
a1 1
/*	$OpenBSD: chap.c,v 1.2 1996/03/25 15:55:35 niklas Exp $	*/
d4 16
a19 1
 * chap.c - Crytographic Handshake Authentication Protocol.
d39 1
a39 1
static char rcsid[] = "$OpenBSD: chap.c,v 1.2 1996/03/25 15:55:35 niklas Exp $";
d69 1
a69 2
                              void (*) __P((void *, char *, ...)), void
*));
d452 1
a452 1
    case CHAP_DIGEST_MD5:		/* only MD5 is defined for now */
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d24 1
a24 1
static char rcsid[] = "$OpenBSD$";
d41 16
d58 15
a72 3
    PPP_CHAP, ChapInit, ChapInput, ChapProtocolReject,
    ChapLowerUp, ChapLowerDown, NULL, NULL,
    ChapPrintPkt, NULL, 1, "CHAP", NULL, NULL
d75 1
d95 1
a95 1
void
d237 1
a237 1
void
d263 1
a263 1
void
d287 1
a287 1
void
d306 1
a306 1
void
d410 9
a418 2
    CHAPDEBUG((LOG_INFO, "ChapReceiveChallenge: received name field: %s",
	       rhostname));
d448 6
d459 1
d564 1
d571 1
a571 1
	    auth_peer_success(cstate->unit, PPP_CHAP);
d792 1
a792 1
char *ChapCodenames[] = {
d796 1
a796 1
int
@


1.1
log
@Initial revision
@
text
@d1 2
d24 1
a24 1
static char rcsid[] = "$Id: chap.c,v 1.6 1995/07/04 23:47:35 paulus Exp $";
d41 6
a434 1
    u_char buf[256];
a435 1
    u_char msg[256];
a586 3
    u_char msglen;
    u_char *msg;
  
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
