head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.6
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.8
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.26
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.18
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.22
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.20
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.16
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.14
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.12
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.10
	OPENBSD_5_0:1.26.0.8
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.6
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.24.0.6
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.12
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.10
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.8
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.6
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.4
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.12
	OPENBSD_2_8:1.14.0.10
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.8
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.14.0.6
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.09.12.12.42.36;	author miod;	state Exp;
branches;
next	1.26;
commitid	n51KcXXBtD80qiFU;

1.26
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2008.10.08.18.42.21;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.04.14.59.45;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.26.14.22.54;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.19.22.19.07;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.14.02.02.56;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.04.20.25.07;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.13.00.12.10;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.01.19.31.37;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.26.09.25.21;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.16.21.28.07;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.23.15.34.02;	author lebel;	state Exp;
branches;
next	1.14;

1.14
date	98.05.08.04.52.33;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.03.20.03.10.03;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	98.01.17.20.30.29;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.12.17.08.49.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.11.30.00.36.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.09.28.21.44.37;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.09.05.04.32.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.06.27.02.16.23;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.04.27.21.45.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.12.23.13.22.49;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.07.14.00.27.09;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.41.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.57;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.00;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Remove dead get_host_seed() function; Martin Natano
@
text
@/*	$OpenBSD: sys-bsd.c,v 1.26 2009/10/27 23:59:53 deraadt Exp $	*/

/*
 * sys-bsd.c - System-dependent procedures for setting up
 * PPP interfaces on bsd-4.4-ish systems (including 386BSD, NetBSD, etc.)
 *
 * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name "Carnegie Mellon University" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For permission or any legal
 *    details, please contact
 *      Office of Technology Transfer
 *      Carnegie Mellon University
 *      5000 Forbes Avenue
 *      Pittsburgh, PA  15213-3890
 *      (412) 268-4387, fax: (412) 268-7395
 *      tech-transfer@@andrew.cmu.edu
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Computing Services
 *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
 *
 * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Copyright (c) 1989-2002 Paul Mackerras. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name(s) of the authors of this software must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission.
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Paul Mackerras
 *     <paulus@@samba.org>".
 *
 * THE AUTHORS OF THIS SOFTWARE DISCLAIM ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * TODO:
 */

#include <stdio.h>
#include <syslog.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <termios.h>
#include <signal.h>
#include <util.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <ifaddrs.h>

#ifdef PPP_FILTER
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/ppp_defs.h>
#include <net/if_ppp.h>
#include <net/route.h>
#include <net/if_dl.h>
#include <netinet/in.h>

#if RTM_VERSION >= 3
#include <sys/param.h>
#if defined(NetBSD) && (NetBSD >= 199703)
#include <netinet/if_inarp.h>
#else	/* NetBSD 1.2D or later */
#if defined(__FreeBSD__) || defined(__OpenBSD__)
#include <netinet/if_ether.h>
#else
#include <net/if_ether.h>
#endif
#endif
#endif

#include "pppd.h"
#include "fsm.h"
#include "ipcp.h"

#define ok_error(num) ((num)==EIO)

static int initdisc = -1;	/* Initial TTY discipline for ppp_fd */
static int initfdflags = -1;	/* Initial file descriptor flags for ppp_fd */
static int ppp_fd = -1;		/* fd which is set to PPP discipline */
static int rtm_seq;

static int restore_term;	/* 1 => we've munged the terminal */
static struct termios inittermios; /* Initial TTY termios */
static struct winsize wsinfo;	/* Initial window size info */

static char *lock_file;		/* name of lock file created */

static int loop_slave = -1;
static int loop_master;
static char loop_name[20];

static unsigned char inbuf[512]; /* buffer for chars read from loopback */

static int sockfd;		/* socket for doing interface ioctls */

static int if_is_up;		/* the interface is currently up */
static u_int32_t ifaddrs[2];	/* local and remote addresses we set */
static u_int32_t default_route_gateway;	/* gateway addr for default route */
static u_int32_t proxy_arp_addr;	/* remote addr for proxy arp */

/* Prototypes for procedures local to this file. */
static int dodefaultroute(u_int32_t, int);
static int get_ether_addr(u_int32_t, struct sockaddr_dl *);


/*
 * sys_init - System-dependent initialization.
 */
void
sys_init()
{
    /* Get an internet socket for doing socket ioctl's on. */
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
	syslog(LOG_ERR, "Couldn't create IP socket: %m");
	die(1);
    }
}

/*
 * sys_cleanup - restore any system state we modified before exiting:
 * mark the interface down, delete default route and/or proxy arp entry.
 * This should call die() because it's called from die().
 */
void
sys_cleanup()
{
    struct ifreq ifr;

    if (if_is_up) {
	strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
	if (ioctl(sockfd, SIOCGIFFLAGS, &ifr) >= 0
	    && ((ifr.ifr_flags & IFF_UP) != 0)) {
	    ifr.ifr_flags &= ~IFF_UP;
	    ioctl(sockfd, SIOCSIFFLAGS, &ifr);
	}
    }
    if (ifaddrs[0] != 0)
	cifaddr(0, ifaddrs[0], ifaddrs[1]);
    if (default_route_gateway)
	cifdefaultroute(0, 0, default_route_gateway);
    if (proxy_arp_addr)
	cifproxyarp(0, proxy_arp_addr);
}

/*
 * sys_close - Clean up in a child process before execing.
 */
void
sys_close()
{
    close(sockfd);
    if (loop_slave >= 0) {
	close(loop_slave);
	close(loop_master);
    }
}

/*
 * sys_check_options - check the options that the user specified
 */
void
sys_check_options()
{
}

/*
 * ppp_available - check whether the system has any ppp interfaces
 * (in fact we check whether we can do an ioctl on ppp0).
 */
int
ppp_available()
{
    int s, ok;
    struct ifreq ifr;
    extern char *no_ppp_msg;

    if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
	return 1;		/* can't tell */

    strlcpy(ifr.ifr_name, "ppp0", sizeof(ifr.ifr_name));
    ok = ioctl(s, SIOCGIFFLAGS, (caddr_t) &ifr) >= 0;
    close(s);

    no_ppp_msg = "\
PPP device not available. Make sure the device is created with\n\
ifconfig and that the kernel supports PPP. See ifconfig(8) and ppp(4).";
    return ok;
}

/*
 * establish_ppp - Turn the serial port into a ppp interface.
 */
void
establish_ppp(fd)
    int fd;
{
    int pppdisc = PPPDISC;
    int x;

    if (demand) {
	/*
	 * Demand mode - prime the old ppp device to relinquish the unit.
	 */
	if (ioctl(ppp_fd, PPPIOCXFERUNIT, 0) < 0) {
	    syslog(LOG_ERR, "ioctl(transfer ppp unit): %m");
	    die(1);
	}
    }

    /*
     * Save the old line discipline of fd, and set it to PPP.
     */
    if (ioctl(fd, TIOCGETD, &initdisc) < 0) {
	syslog(LOG_ERR, "ioctl(TIOCGETD): %m");
	die(1);
    }
    if (ioctl(fd, TIOCSETD, &pppdisc) < 0) {
	syslog(LOG_ERR, "ioctl(TIOCSETD): %m");
	die(1);
    }

    if (!demand) {
	/*
	 * Find out which interface we were given.
	 */
	if (ioctl(fd, PPPIOCGUNIT, &ifunit) < 0) {	
	    syslog(LOG_ERR, "ioctl(PPPIOCGUNIT): %m");
	    die(1);
	}
    } else {
	/*
	 * Check that we got the same unit again.
	 */
	if (ioctl(fd, PPPIOCGUNIT, &x) < 0) {	
	    syslog(LOG_ERR, "ioctl(PPPIOCGUNIT): %m");
	    die(1);
	}
	if (x != ifunit) {
	    syslog(LOG_ERR, "transfer_ppp failed: wanted unit %d, got %d",
		   ifunit, x);
	    die(1);
	}
	x = TTYDISC;
	ioctl(loop_slave, TIOCSETD, &x);
    }

    ppp_fd = fd;

    /*
     * Enable debug in the driver if requested.
     */
    if (kdebugflag) {
	if (ioctl(fd, PPPIOCGFLAGS, (caddr_t) &x) < 0) {
	    syslog(LOG_WARNING, "ioctl (PPPIOCGFLAGS): %m");
	} else {
	    x |= (kdebugflag & 0xFF) * SC_DEBUG;
	    if (ioctl(fd, PPPIOCSFLAGS, (caddr_t) &x) < 0)
		syslog(LOG_WARNING, "ioctl(PPPIOCSFLAGS): %m");
	}
    }

    /*
     * Set device for non-blocking reads.
     */
    if ((initfdflags = fcntl(fd, F_GETFL)) == -1
	|| fcntl(fd, F_SETFL, initfdflags | O_NONBLOCK) == -1) {
	syslog(LOG_WARNING, "Couldn't set device to non-blocking mode: %m");
    }
}

/*
 * restore_loop - reattach the ppp unit to the loopback.
 */
void
restore_loop()
{
    int x;

    /*
     * Transfer the ppp interface back to the loopback.
     */
    if (ioctl(ppp_fd, PPPIOCXFERUNIT, 0) < 0) {
	syslog(LOG_ERR, "ioctl(transfer ppp unit): %m");
	die(1);
    }
    x = PPPDISC;
    if (ioctl(loop_slave, TIOCSETD, &x) < 0) {
	syslog(LOG_ERR, "ioctl(TIOCSETD): %m");
	die(1);
    }

    /*
     * Check that we got the same unit again.
     */
    if (ioctl(loop_slave, PPPIOCGUNIT, &x) < 0) {	
	syslog(LOG_ERR, "ioctl(PPPIOCGUNIT): %m");
	die(1);
    }
    if (x != ifunit) {
	syslog(LOG_ERR, "transfer_ppp failed: wanted unit %d, got %d",
	       ifunit, x);
	die(1);
    }
    ppp_fd = loop_slave;
}

/*
 * disestablish_ppp - Restore the serial port to normal operation.
 * This shouldn't call die() because it's called from die().
 */
void
disestablish_ppp(fd)
    int fd;
{
    /* Reset non-blocking mode on fd. */
    if (initfdflags != -1 && fcntl(fd, F_SETFL, initfdflags) < 0)
	syslog(LOG_WARNING, "Couldn't restore device fd flags: %m");
    initfdflags = -1;

    /* Restore old line discipline. */
    if (initdisc >= 0 && ioctl(fd, TIOCSETD, &initdisc) < 0)
	syslog(LOG_ERR, "ioctl(TIOCSETD): %m");
    initdisc = -1;

    if (fd == ppp_fd)
	ppp_fd = -1;
}

/*
 * Check whether the link seems not to be 8-bit clean.
 */
void
clean_check()
{
    int x;
    char *s;

    if (ioctl(ppp_fd, PPPIOCGFLAGS, (caddr_t) &x) == 0) {
	s = NULL;
	switch (~x & (SC_RCV_B7_0|SC_RCV_B7_1|SC_RCV_EVNP|SC_RCV_ODDP)) {
	case SC_RCV_B7_0:
	    s = "bit 7 set to 1";
	    break;
	case SC_RCV_B7_1:
	    s = "bit 7 set to 0";
	    break;
	case SC_RCV_EVNP:
	    s = "odd parity";
	    break;
	case SC_RCV_ODDP:
	    s = "even parity";
	    break;
	}
	if (s != NULL) {
	    syslog(LOG_WARNING, "Serial link is not 8-bit clean:");
	    syslog(LOG_WARNING, "All received characters had %s", s);
	}
    }
}

/*
 * set_up_tty: Set up the serial port on `fd' for 8 bits, no parity,
 * at the requested speed, etc.  If `local' is true, set CLOCAL
 * regardless of whether the modem option was specified.
 *
 * For *BSD, we assume that speed_t values numerically equal bits/second.
 */
void
set_up_tty(fd, local)
    int fd, local;
{
    struct termios tios;

    if (tcgetattr(fd, &tios) < 0) {
	syslog(LOG_ERR, "tcgetattr: %m");
	die(1);
    }

    if (!restore_term) {
	inittermios = tios;
	ioctl(fd, TIOCGWINSZ, &wsinfo);
    }

    tios.c_cflag &= ~(CSIZE | CSTOPB | PARENB | CLOCAL);
    if (crtscts > 0 && modem)
	tios.c_cflag |= CRTSCTS;
    else if (crtscts < 0)
	tios.c_cflag &= ~CRTSCTS;

    tios.c_cflag |= CS8 | CREAD | HUPCL;
    if (local || !modem)
	tios.c_cflag |= CLOCAL;
    tios.c_iflag = IGNBRK | IGNPAR;
    tios.c_oflag = 0;
    tios.c_lflag = 0;
    tios.c_cc[VMIN] = 1;
    tios.c_cc[VTIME] = 0;

    if (crtscts == -2) {
	tios.c_iflag |= IXON | IXOFF;
	tios.c_cc[VSTOP] = 0x13;	/* DC3 = XOFF = ^S */
	tios.c_cc[VSTART] = 0x11;	/* DC1 = XON  = ^Q */
    }

    if (inspeed) {
	cfsetospeed(&tios, inspeed);
	cfsetispeed(&tios, inspeed);
    } else {
	inspeed = cfgetospeed(&tios);
	/*
	 * We can't proceed if the serial port speed is 0,
	 * since that implies that the serial port is disabled.
	 */
	if (inspeed == 0) {
	    syslog(LOG_ERR, "Baud rate for %s is 0; need explicit baud rate",
		   devnam);
	    die(1);
	}
    }
    baud_rate = inspeed;

    if (tcsetattr(fd, TCSAFLUSH, &tios) < 0) {
	syslog(LOG_ERR, "tcsetattr: %m");
	die(1);
    }

    restore_term = 1;
}

/*
 * restore_tty - restore the terminal to the saved settings.
 */
void
restore_tty(fd)
    int fd;
{
    if (restore_term) {
	if (!default_device) {
	    /*
	     * Turn off echoing, because otherwise we can get into
	     * a loop with the tty and the modem echoing to each other.
	     * We presume we are the sole user of this tty device, so
	     * when we close it, it will revert to its defaults anyway.
	     */
	    inittermios.c_lflag &= ~(ECHO | ECHONL);
	}
	if (tcsetattr(fd, TCSAFLUSH, &inittermios) < 0)
	    if (errno != ENXIO)
		syslog(LOG_WARNING, "tcsetattr: %m");
	ioctl(fd, TIOCSWINSZ, &wsinfo);
	restore_term = 0;
    }
}

/*
 * setdtr - control the DTR line on the serial port.
 * This is called from die(), so it shouldn't call die().
 */
void
setdtr(fd, on)
int fd, on;
{
    int modembits = TIOCM_DTR;

    ioctl(fd, (on? TIOCMBIS: TIOCMBIC), &modembits);
}


/*
 * open_ppp_loopback - open the device we use for getting
 * packets in demand mode, and connect it to a ppp interface.
 * Here we use a pty.
 */
void
open_ppp_loopback()
{
    int flags;
    struct termios tios;
    int pppdisc = PPPDISC;

    if (openpty(&loop_master, &loop_slave, loop_name, NULL, NULL) < 0) {
	syslog(LOG_ERR, "No free pty for loopback");
	die(1);
    }
    SYSDEBUG((LOG_DEBUG, "using %s for loopback", loop_name));

    if (tcgetattr(loop_slave, &tios) == 0) {
	tios.c_cflag &= ~(CSIZE | CSTOPB | PARENB);
	tios.c_cflag |= CS8 | CREAD;
	tios.c_iflag = IGNPAR;
	tios.c_oflag = 0;
	tios.c_lflag = 0;
	if (tcsetattr(loop_slave, TCSAFLUSH, &tios) < 0)
	    syslog(LOG_WARNING, "couldn't set attributes on loopback: %m");
    }

    if ((flags = fcntl(loop_master, F_GETFL)) != -1) 
	if (fcntl(loop_master, F_SETFL, flags | O_NONBLOCK) == -1)
	    syslog(LOG_WARNING, "couldn't set loopback to nonblock: %m");

    ppp_fd = loop_slave;
    if (ioctl(ppp_fd, TIOCSETD, &pppdisc) < 0) {
	syslog(LOG_ERR, "ioctl(TIOCSETD): %m");
	die(1);
    }

    /*
     * Find out which interface we were given.
     */
    if (ioctl(ppp_fd, PPPIOCGUNIT, &ifunit) < 0) {	
	syslog(LOG_ERR, "ioctl(PPPIOCGUNIT): %m");
	die(1);
    }

    /*
     * Enable debug in the driver if requested.
     */
    if (kdebugflag) {
	if (ioctl(ppp_fd, PPPIOCGFLAGS, (caddr_t) &flags) < 0) {
	    syslog(LOG_WARNING, "ioctl (PPPIOCGFLAGS): %m");
	} else {
	    flags |= (kdebugflag & 0xFF) * SC_DEBUG;
	    if (ioctl(ppp_fd, PPPIOCSFLAGS, (caddr_t) &flags) < 0)
		syslog(LOG_WARNING, "ioctl(PPPIOCSFLAGS): %m");
	}
    }

}


/*
 * output - Output PPP packet.
 */
void
output(unit, p, len)
    int unit;
    u_char *p;
    int len;
{
    if (debug)
	log_packet(p, len, "sent ", LOG_DEBUG);

    if (write(ttyfd, p, len) < 0) {
	if (errno != EIO)
	    syslog(LOG_ERR, "write: %m");
    }
}


/*
 * wait_input - wait until there is data available on ttyfd,
 * for the length of time specified by *timo (indefinite
 * if timo is NULL).
 */
void
wait_input(timo)
    struct timeval *timo;
{
    fd_set *fdsp = NULL;
    int fdsn;
    int n;

    fdsn = howmany(ttyfd+1, NFDBITS) * sizeof(fd_mask);
    if ((fdsp = (fd_set *)malloc(fdsn)) == NULL)
	err(1, "malloc");
    memset(fdsp, 0, fdsn);
    FD_SET(ttyfd, fdsp);

    n = select(ttyfd+1, fdsp, NULL, fdsp, timo);
    if (n < 0 && errno != EINTR) {
	syslog(LOG_ERR, "select: %m");
	free(fdsp);
	die(1);
    }
    free(fdsp);
}


/*
 * wait_loop_output - wait until there is data available on the
 * loopback, for the length of time specified by *timo (indefinite
 * if timo is NULL).
 */
void
wait_loop_output(timo)
    struct timeval *timo;
{
    fd_set *fdsp = NULL;
    int fdsn;
    int n;

    fdsn = howmany(loop_master+1, NFDBITS) * sizeof(fd_mask);
    if ((fdsp = (fd_set *)malloc(fdsn)) == NULL)
	err(1, "malloc");
    memset(fdsp, 0, fdsn);
    FD_SET(loop_master, fdsp);

    n = select(loop_master + 1, fdsp, NULL, fdsp, timo);
    if (n < 0 && errno != EINTR) {
	syslog(LOG_ERR, "select: %m");
	free(fdsp);
	die(1);
    }
    free(fdsp);
}


/*
 * wait_time - wait for a given length of time or until a
 * signal is received.
 */
void
wait_time(timo)
    struct timeval *timo;
{
    int n;

    n = select(0, NULL, NULL, NULL, timo);
    if (n < 0 && errno != EINTR) {
	syslog(LOG_ERR, "select: %m");
	die(1);
    }
}


/*
 * read_packet - get a PPP packet from the serial device.
 */
int
read_packet(buf)
    u_char *buf;
{
    int len;

    if ((len = read(ttyfd, buf, PPP_MTU + PPP_HDRLEN)) < 0) {
	if (errno == EWOULDBLOCK || errno == EINTR)
	    return -1;
	syslog(LOG_ERR, "read: %m");
	die(1);
    }
    return len;
}


/*
 * get_loop_output - read characters from the loopback, form them
 * into frames, and detect when we want to bring the real link up.
 * Return value is 1 if we need to bring up the link, 0 otherwise.
 */
int
get_loop_output()
{
    int rv = 0;
    int n;

    while ((n = read(loop_master, inbuf, sizeof(inbuf))) >= 0) {
	if (loop_chars(inbuf, n))
	    rv = 1;
    }

    if (n == 0) {
	syslog(LOG_ERR, "eof on loopback");
	die(1);
    } else if (errno != EWOULDBLOCK){
	syslog(LOG_ERR, "read from loopback: %m");
	die(1);
    }

    return rv;
}


/*
 * ppp_send_config - configure the transmit characteristics of
 * the ppp interface.
 */
void
ppp_send_config(unit, mtu, asyncmap, pcomp, accomp)
    int unit, mtu;
    u_int32_t asyncmap;
    int pcomp, accomp;
{
    u_int x;
    struct ifreq ifr;

    strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
    ifr.ifr_mtu = mtu;
    if (ioctl(sockfd, SIOCSIFMTU, (caddr_t) &ifr) < 0) {
	syslog(LOG_ERR, "ioctl(SIOCSIFMTU): %m");
	quit();
    }

    if (ioctl(ppp_fd, PPPIOCSASYNCMAP, (caddr_t) &asyncmap) < 0) {
	syslog(LOG_ERR, "ioctl(PPPIOCSASYNCMAP): %m");
	quit();
    }

    if (ioctl(ppp_fd, PPPIOCGFLAGS, (caddr_t) &x) < 0) {
	syslog(LOG_ERR, "ioctl (PPPIOCGFLAGS): %m");
	quit();
    }
    x = pcomp? x | SC_COMP_PROT: x &~ SC_COMP_PROT;
    x = accomp? x | SC_COMP_AC: x &~ SC_COMP_AC;
    if (ioctl(ppp_fd, PPPIOCSFLAGS, (caddr_t) &x) < 0) {
	syslog(LOG_ERR, "ioctl(PPPIOCSFLAGS): %m");
	quit();
    }
}


/*
 * ppp_set_xaccm - set the extended transmit ACCM for the interface.
 */
void
ppp_set_xaccm(unit, accm)
    int unit;
    ext_accm accm;
{
    if (ioctl(ppp_fd, PPPIOCSXASYNCMAP, accm) < 0 && errno != ENOTTY)
	syslog(LOG_WARNING, "ioctl(set extended ACCM): %m");
}


/*
 * ppp_recv_config - configure the receive-side characteristics of
 * the ppp interface.
 */
void
ppp_recv_config(unit, mru, asyncmap, pcomp, accomp)
    int unit, mru;
    u_int32_t asyncmap;
    int pcomp, accomp;
{
    int x;

    if (ioctl(ppp_fd, PPPIOCSMRU, (caddr_t) &mru) < 0) {
	syslog(LOG_ERR, "ioctl(PPPIOCSMRU): %m");
	quit();
    }
    if (ioctl(ppp_fd, PPPIOCSRASYNCMAP, (caddr_t) &asyncmap) < 0) {
	syslog(LOG_ERR, "ioctl(PPPIOCSRASYNCMAP): %m");
	quit();
    }
    if (ioctl(ppp_fd, PPPIOCGFLAGS, (caddr_t) &x) < 0) {
	syslog(LOG_ERR, "ioctl (PPPIOCGFLAGS): %m");
	quit();
    }
    x = !accomp? x | SC_REJ_COMP_AC: x &~ SC_REJ_COMP_AC;
    if (ioctl(ppp_fd, PPPIOCSFLAGS, (caddr_t) &x) < 0) {
	syslog(LOG_ERR, "ioctl(PPPIOCSFLAGS): %m");
	quit();
    }
}

/*
 * ccp_test - ask kernel whether a given compression method
 * is acceptable for use.  Returns 1 if the method and parameters
 * are OK, 0 if the method is known but the parameters are not OK
 * (e.g. code size should be reduced), or -1 if the method is unknown.
 */
int
ccp_test(unit, opt_ptr, opt_len, for_transmit)
    int unit, opt_len, for_transmit;
    u_char *opt_ptr;
{
    struct ppp_option_data data;

    data.ptr = opt_ptr;
    data.length = opt_len;
    data.transmit = for_transmit;
    if (ioctl(ttyfd, PPPIOCSCOMPRESS, (caddr_t) &data) >= 0)
	return 1;
    return (errno == ENOBUFS)? 0: -1;
}

/*
 * ccp_flags_set - inform kernel about the current state of CCP.
 */
void
ccp_flags_set(unit, isopen, isup)
    int unit, isopen, isup;
{
    int x;

    if (ioctl(ppp_fd, PPPIOCGFLAGS, (caddr_t) &x) < 0) {
	syslog(LOG_ERR, "ioctl (PPPIOCGFLAGS): %m");
	return;
    }
    x = isopen? x | SC_CCP_OPEN: x &~ SC_CCP_OPEN;
    x = isup? x | SC_CCP_UP: x &~ SC_CCP_UP;
    if (ioctl(ppp_fd, PPPIOCSFLAGS, (caddr_t) &x) < 0)
	syslog(LOG_ERR, "ioctl(PPPIOCSFLAGS): %m");
}

/*
 * ccp_fatal_error - returns 1 if decompression was disabled as a
 * result of an error detected after decompression of a packet,
 * 0 otherwise.  This is necessary because of patent nonsense.
 */
int
ccp_fatal_error(unit)
    int unit;
{
    int x;

    if (ioctl(ppp_fd, PPPIOCGFLAGS, (caddr_t) &x) < 0) {
	syslog(LOG_ERR, "ioctl(PPPIOCGFLAGS): %m");
	return 0;
    }
    return x & SC_DC_FERROR;
}

/*
 * get_idle_time - return how long the link has been idle.
 */
int
get_idle_time(u, ip)
    int u;
    struct ppp_idle *ip;
{
    return ioctl(ppp_fd, PPPIOCGIDLE, ip) >= 0;
}


#ifdef PPP_FILTER
/*
 * set_filters - transfer the pass and active filters to the kernel.
 */
int
set_filters(pass, active)
    struct bpf_program *pass, *active;
{
    int ret = 1;

    if (pass->bf_len > 0) {
	if (ioctl(ppp_fd, PPPIOCSPASS, pass) < 0) {
	    syslog(LOG_ERR, "Couldn't set pass-filter in kernel: %m");
	    ret = 0;
	}
    }
    if (active->bf_len > 0) {
	if (ioctl(ppp_fd, PPPIOCSACTIVE, active) < 0) {
	    syslog(LOG_ERR, "Couldn't set active-filter in kernel: %m");
	    ret = 0;
	}
    }
    return ret;
}
#endif

/*
 * sifvjcomp - config tcp header compression
 */
int
sifvjcomp(u, vjcomp, cidcomp, maxcid)
    int u, vjcomp, cidcomp, maxcid;
{
    u_int x;

    if (ioctl(ppp_fd, PPPIOCGFLAGS, (caddr_t) &x) < 0) {
	syslog(LOG_ERR, "ioctl (PPPIOCGFLAGS): %m");
	return 0;
    }
    x = vjcomp ? x | SC_COMP_TCP: x &~ SC_COMP_TCP;
    x = cidcomp? x & ~SC_NO_TCP_CCID: x | SC_NO_TCP_CCID;
    if (ioctl(ppp_fd, PPPIOCSFLAGS, (caddr_t) &x) < 0) {
	syslog(LOG_ERR, "ioctl(PPPIOCSFLAGS): %m");
	return 0;
    }
    if (vjcomp && ioctl(ppp_fd, PPPIOCSMAXCID, (caddr_t) &maxcid) < 0) {
	syslog(LOG_ERR, "ioctl(PPPIOCSFLAGS): %m");
	return 0;
    }
    return 1;
}

/*
 * sifup - Config the interface up and enable IP packets to pass.
 */
int
sifup(u)
    int u;
{
    struct ifreq ifr;

    strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
    if (ioctl(sockfd, SIOCGIFFLAGS, (caddr_t) &ifr) < 0) {
	syslog(LOG_ERR, "ioctl (SIOCGIFFLAGS): %m");
	return 0;
    }
    ifr.ifr_flags |= IFF_UP;
    if (ioctl(sockfd, SIOCSIFFLAGS, (caddr_t) &ifr) < 0) {
	syslog(LOG_ERR, "ioctl(SIOCSIFFLAGS): %m");
	return 0;
    }
    if_is_up = 1;
    return 1;
}

/*
 * sifnpmode - Set the mode for handling packets for a given NP.
 */
int
sifnpmode(u, proto, mode)
    int u;
    int proto;
    enum NPmode mode;
{
    struct npioctl npi;

    npi.protocol = proto;
    npi.mode = mode;
    if (ioctl(ppp_fd, PPPIOCSNPMODE, &npi) < 0) {
	syslog(LOG_ERR, "ioctl(set NP %d mode to %d): %m", proto, mode);
	return 0;
    }
    return 1;
}

/*
 * sifdown - Config the interface down and disable IP.
 */
int
sifdown(u)
    int u;
{
    struct ifreq ifr;
    int rv;
    struct npioctl npi;

    rv = 1;
    npi.protocol = PPP_IP;
    npi.mode = NPMODE_ERROR;
    ioctl(ppp_fd, PPPIOCSNPMODE, (caddr_t) &npi);
    /* ignore errors, because ppp_fd might have been closed by now. */

    strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
    if (ioctl(sockfd, SIOCGIFFLAGS, (caddr_t) &ifr) < 0) {
	syslog(LOG_ERR, "ioctl (SIOCGIFFLAGS): %m");
	rv = 0;
    } else {
	ifr.ifr_flags &= ~IFF_UP;
	if (ioctl(sockfd, SIOCSIFFLAGS, (caddr_t) &ifr) < 0) {
	    syslog(LOG_ERR, "ioctl(SIOCSIFFLAGS): %m");
	    rv = 0;
	} else
	    if_is_up = 0;
    }
    return rv;
}

/*
 * SET_SA_FAMILY - set the sa_family field of a struct sockaddr,
 * if it exists.
 */
#define SET_SA_FAMILY(addr, family)		\
    BZERO((char *) &(addr), sizeof(addr));	\
    addr.sa_family = (family); 			\
    addr.sa_len = sizeof(addr);

/*
 * sifaddr - Config the interface IP addresses and netmask.
 */
int
sifaddr(u, o, h, m)
    int u;
    u_int32_t o, h, m;
{
    struct ifaliasreq ifra;
    struct ifreq ifr;
    char s1[64], s2[64];

    strlcpy(ifra.ifra_name, ifname, sizeof(ifra.ifra_name));
    SET_SA_FAMILY(ifra.ifra_addr, AF_INET);
    ((struct sockaddr_in *) &ifra.ifra_addr)->sin_addr.s_addr = o;
    SET_SA_FAMILY(ifra.ifra_broadaddr, AF_INET);
    ((struct sockaddr_in *) &ifra.ifra_broadaddr)->sin_addr.s_addr = h;
    if (m != 0) {
	SET_SA_FAMILY(ifra.ifra_mask, AF_INET);
	((struct sockaddr_in *) &ifra.ifra_mask)->sin_addr.s_addr = m;
    } else
	BZERO(&ifra.ifra_mask, sizeof(ifra.ifra_mask));
    BZERO(&ifr, sizeof(ifr));
    strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
    if (ioctl(sockfd, SIOCDIFADDR, (caddr_t) &ifr) < 0) {
	if (errno != EADDRNOTAVAIL)
	    syslog(LOG_WARNING, "Couldn't remove interface address: %m");
    }
    if (ioctl(sockfd, SIOCAIFADDR, (caddr_t) &ifra) < 0) {
	if (errno != EEXIST) {
	    syslog(LOG_ERR, "Couldn't set interface address: %m");
	    return 0;
	}
	strlcpy(s1, ip_ntoa(o), sizeof(s1));
	strlcpy(s2, ip_ntoa(h), sizeof(s2));
	syslog(LOG_WARNING,
	       "Couldn't set interface address: "
	       "Address %s or destination %s already exists", s1, s2);
    }
    ifaddrs[0] = o;
    ifaddrs[1] = h;
    return 1;
}

/*
 * cifaddr - Clear the interface IP addresses, and delete routes
 * through the interface if possible.
 */
int
cifaddr(u, o, h)
    int u;
    u_int32_t o, h;
{
    struct ifaliasreq ifra;

    ifaddrs[0] = 0;
    strlcpy(ifra.ifra_name, ifname, sizeof(ifra.ifra_name));
    SET_SA_FAMILY(ifra.ifra_addr, AF_INET);
    ((struct sockaddr_in *) &ifra.ifra_addr)->sin_addr.s_addr = o;
    SET_SA_FAMILY(ifra.ifra_broadaddr, AF_INET);
    ((struct sockaddr_in *) &ifra.ifra_broadaddr)->sin_addr.s_addr = h;
    BZERO(&ifra.ifra_mask, sizeof(ifra.ifra_mask));
    if (ioctl(sockfd, SIOCDIFADDR, (caddr_t) &ifra) < 0) {
	if (errno != EADDRNOTAVAIL)
	    syslog(LOG_WARNING, "Couldn't delete interface address: %m");
	return 0;
    }
    return 1;
}

/*
 * sifdefaultroute - assign a default route through the address given.
 */
int
sifdefaultroute(u, l, g)
    int u;
    u_int32_t l, g;
{
    return dodefaultroute(g, 's');
}

/*
 * cifdefaultroute - delete a default route through the address given.
 */
int
cifdefaultroute(u, l, g)
    int u;
    u_int32_t l, g;
{
    return dodefaultroute(g, 'c');
}

/*
 * dodefaultroute - talk to a routing socket to add/delete a default route.
 */
static int
dodefaultroute(g, cmd)
    u_int32_t g;
    int cmd;
{
    int routes;
    struct {
	struct rt_msghdr	hdr;
	struct sockaddr_in	dst;
	struct sockaddr_in	gway;
	struct sockaddr_in	mask;
    } rtmsg;

    if ((routes = socket(PF_ROUTE, SOCK_RAW, AF_INET)) < 0) {
	syslog(LOG_ERR, "Couldn't %s default route: socket: %m",
	       cmd=='s'? "add": "delete");
	return 0;
    }

    memset(&rtmsg, 0, sizeof(rtmsg));
    rtmsg.hdr.rtm_type = cmd == 's'? RTM_ADD: RTM_DELETE;
    rtmsg.hdr.rtm_flags = RTF_UP | RTF_GATEWAY;
    rtmsg.hdr.rtm_version = RTM_VERSION;
    rtmsg.hdr.rtm_seq = ++rtm_seq;
    rtmsg.hdr.rtm_addrs = RTA_DST | RTA_GATEWAY | RTA_NETMASK;
    rtmsg.dst.sin_len = sizeof(rtmsg.dst);
    rtmsg.dst.sin_family = AF_INET;
    rtmsg.gway.sin_len = sizeof(rtmsg.gway);
    rtmsg.gway.sin_family = AF_INET;
    rtmsg.gway.sin_addr.s_addr = g;
    rtmsg.mask.sin_len = sizeof(rtmsg.dst);
    rtmsg.mask.sin_family = AF_INET;

    rtmsg.hdr.rtm_msglen = sizeof(rtmsg);
    if (write(routes, &rtmsg, sizeof(rtmsg)) < 0) {
	syslog(LOG_ERR, "Couldn't %s default route: %m",
	       cmd=='s'? "add": "delete");
	close(routes);
	return 0;
    }

    close(routes);
    default_route_gateway = (cmd == 's')? g: 0;
    return 1;
}

#if RTM_VERSION >= 3

/*
 * sifproxyarp - Make a proxy ARP entry for the peer.
 */
static struct {
    struct rt_msghdr		hdr;
    struct sockaddr_inarp	dst;
    struct sockaddr_dl		hwa;
    char			extra[128];
} arpmsg;

static int arpmsg_valid;

int
sifproxyarp(unit, hisaddr)
    int unit;
    u_int32_t hisaddr;
{
    int routes;

    /*
     * Get the hardware address of an interface on the same subnet
     * as our local address.
     */
    memset(&arpmsg, 0, sizeof(arpmsg));
    if (!get_ether_addr(hisaddr, &arpmsg.hwa)) {
	syslog(LOG_ERR, "Cannot determine ethernet address for proxy ARP");
	return 0;
    }

    if ((routes = socket(PF_ROUTE, SOCK_RAW, AF_INET)) < 0) {
	syslog(LOG_ERR, "Couldn't add proxy arp entry: socket: %m");
	return 0;
    }

    arpmsg.hdr.rtm_type = RTM_ADD;
    arpmsg.hdr.rtm_flags = RTF_ANNOUNCE | RTF_HOST | RTF_STATIC;
    arpmsg.hdr.rtm_version = RTM_VERSION;
    arpmsg.hdr.rtm_seq = ++rtm_seq;
    arpmsg.hdr.rtm_addrs = RTA_DST | RTA_GATEWAY;
    arpmsg.hdr.rtm_inits = RTV_EXPIRE;
    arpmsg.dst.sin_len = sizeof(struct sockaddr_inarp);
    arpmsg.dst.sin_family = AF_INET;
    arpmsg.dst.sin_addr.s_addr = hisaddr;
    arpmsg.dst.sin_other = SIN_PROXY;

    arpmsg.hdr.rtm_msglen = (char *) &arpmsg.hwa - (char *) &arpmsg
	+ arpmsg.hwa.sdl_len;
    if (write(routes, &arpmsg, arpmsg.hdr.rtm_msglen) < 0) {
	syslog(LOG_ERR, "Couldn't add proxy arp entry: %m");
	close(routes);
	return 0;
    }

    close(routes);
    arpmsg_valid = 1;
    proxy_arp_addr = hisaddr;
    return 1;
}

/*
 * cifproxyarp - Delete the proxy ARP entry for the peer.
 */
int
cifproxyarp(unit, hisaddr)
    int unit;
    u_int32_t hisaddr;
{
    int routes;

    if (!arpmsg_valid)
	return 0;
    arpmsg_valid = 0;

    arpmsg.hdr.rtm_type = RTM_DELETE;
    arpmsg.hdr.rtm_seq = ++rtm_seq;

    if ((routes = socket(PF_ROUTE, SOCK_RAW, AF_INET)) < 0) {
	syslog(LOG_ERR, "Couldn't delete proxy arp entry: socket: %m");
	return 0;
    }

    if (write(routes, &arpmsg, arpmsg.hdr.rtm_msglen) < 0) {
	syslog(LOG_ERR, "Couldn't delete proxy arp entry: %m");
	close(routes);
	return 0;
    }

    close(routes);
    proxy_arp_addr = 0;
    return 1;
}

#else	/* RTM_VERSION */

/*
 * sifproxyarp - Make a proxy ARP entry for the peer.
 */
int
sifproxyarp(unit, hisaddr)
    int unit;
    u_int32_t hisaddr;
{
    struct arpreq arpreq;
    struct {
	struct sockaddr_dl	sdl;
	char			space[128];
    } dls;

    BZERO(&arpreq, sizeof(arpreq));

    /*
     * Get the hardware address of an interface on the same subnet
     * as our local address.
     */
    if (!get_ether_addr(hisaddr, &dls.sdl)) {
	syslog(LOG_ERR, "Cannot determine ethernet address for proxy ARP");
	return 0;
    }

    arpreq.arp_ha.sa_len = sizeof(struct sockaddr);
    arpreq.arp_ha.sa_family = AF_UNSPEC;
    BCOPY(LLADDR(&dls.sdl), arpreq.arp_ha.sa_data, dls.sdl.sdl_alen);
    SET_SA_FAMILY(arpreq.arp_pa, AF_INET);
    ((struct sockaddr_in *) &arpreq.arp_pa)->sin_addr.s_addr = hisaddr;
    arpreq.arp_flags = ATF_PERM | ATF_PUBL;
    if (ioctl(sockfd, SIOCSARP, (caddr_t)&arpreq) < 0) {
	syslog(LOG_ERR, "Couldn't add proxy arp entry: %m");
	return 0;
    }

    proxy_arp_addr = hisaddr;
    return 1;
}

/*
 * cifproxyarp - Delete the proxy ARP entry for the peer.
 */
int
cifproxyarp(unit, hisaddr)
    int unit;
    u_int32_t hisaddr;
{
    struct arpreq arpreq;

    BZERO(&arpreq, sizeof(arpreq));
    SET_SA_FAMILY(arpreq.arp_pa, AF_INET);
    ((struct sockaddr_in *) &arpreq.arp_pa)->sin_addr.s_addr = hisaddr;
    if (ioctl(sockfd, SIOCDARP, (caddr_t)&arpreq) < 0) {
	syslog(LOG_WARNING, "Couldn't delete proxy arp entry: %m");
	return 0;
    }
    proxy_arp_addr = 0;
    return 1;
}
#endif	/* RTM_VERSION */


/*
 * get_ether_addr - get the hardware address of an interface on the
 * the same subnet as ipaddr.
 */
#define MAX_IFS		32

static int
get_ether_addr(ipaddr, hwaddr)
    u_int32_t ipaddr;
    struct sockaddr_dl *hwaddr;
{
    u_int32_t ina, mask;
    struct sockaddr_dl *dla;
    struct ifaddrs *ifap, *ifa, *ifp;

    if (getifaddrs(&ifap) != 0) {
	syslog(LOG_ERR, "getifaddrs: %m");
	return 0;
    }

    /*
     * Scan through looking for an interface with an Internet
     * address on the same subnet as `ipaddr'.
     */
    for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
	if (ifa->ifa_addr->sa_family == AF_INET) {
	    ina = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr;
	    /*
	     * Check that the interface is up, and not point-to-point
	     * or loopback.
	     */
	    if ((ifa->ifa_flags &
		 (IFF_UP|IFF_BROADCAST|IFF_POINTOPOINT|IFF_LOOPBACK|IFF_NOARP))
		 != (IFF_UP|IFF_BROADCAST))
		continue;
	    /*
	     * Get its netmask and check that it's on the right subnet.
	     */
	    mask = ((struct sockaddr_in *)ifa->ifa_netmask)->sin_addr.s_addr;
	    if ((ipaddr & mask) != (ina & mask))
		continue;

	    break;
	}
    }

    if (ifa == NULL) {
	freeifaddrs(ifap);
	return 0;
    }
    syslog(LOG_INFO, "found interface %s for proxy arp", ifa->ifa_name);

    /*
     * Now scan through again looking for a link-level address
     * for this interface.
     */
    ifp = ifa;
    for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
	if (strcmp(ifp->ifa_name, ifa->ifa_name) == 0
	    && ifa->ifa_addr->sa_family == AF_LINK) {
	    /*
	     * Found the link-level address - copy it out
	     */
	    dla = (struct sockaddr_dl *)ifa->ifa_addr;
	    BCOPY(dla, hwaddr, dla->sdl_len);
	    return 1;
	}
    }

    freeifaddrs(ifap);
    return 0;
}

/*
 * Return user specified netmask, modified by any mask we might determine
 * for address `addr' (in network byte order).
 * Here we scan through the system's list of interfaces, looking for
 * any non-point-to-point interfaces which might appear to be on the same
 * network as `addr'.  If we find any, we OR in their netmask to the
 * user-specified netmask.
 */
u_int32_t
GetMask(addr)
    u_int32_t addr;
{
    u_int32_t mask, nmask, ina;
    struct ifaddrs *ifap, *ifa;

    addr = ntohl(addr);
    if (IN_CLASSA(addr))	/* determine network mask for address class */
	nmask = IN_CLASSA_NET;
    else if (IN_CLASSB(addr))
	nmask = IN_CLASSB_NET;
    else
	nmask = IN_CLASSC_NET;
    /* class D nets are disallowed by bad_ip_adrs */
    mask = netmask | htonl(nmask);

    /*
     * Scan through the system's network interfaces.
     */
    if (getifaddrs(&ifap) != 0) {
	syslog(LOG_WARNING, "getifaddrs: %m");
	return mask;
    }
    for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
	/*
	 * Check the interface's internet address.
	 */
	if (ifa->ifa_addr->sa_family != AF_INET)
	    continue;
	ina = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr;
	if ((ntohl(ina) & nmask) != (addr & nmask))
	    continue;
	/*
	 * Check that the interface is up, and not point-to-point or loopback.
	 */
	if ((ifa->ifa_flags & (IFF_UP|IFF_POINTOPOINT|IFF_LOOPBACK))
	    != IFF_UP)
	    continue;
	/*
	 * Get its netmask and OR it into our mask.
	 */
	mask |= ((struct sockaddr_in *)ifa->ifa_netmask)->sin_addr.s_addr;
    }

    freeifaddrs(ifap);
    return mask;
}

/*
 * lock - create a lock file for the named lock device
 */
#define	LOCK_PREFIX	"/var/spool/lock/LCK.."

int
lock(dev)
    char *dev;
{
    char hdb_lock_buffer[12];
    int fd, n;
    pid_t pid;
    char *p;

    if ((p = strrchr(dev, '/')) != NULL)
	dev = p + 1;
    if (asprintf(&lock_file, "%s%s", LOCK_PREFIX, dev) == -1)
	novm("lock file name");

    while ((fd = open(lock_file, O_EXCL | O_CREAT | O_RDWR, 0644)) < 0) {
	if (errno == EEXIST
	    && (fd = open(lock_file, O_RDONLY, 0)) >= 0) {
	    /* Read the lock file to find out who has the device locked */
	    n = read(fd, hdb_lock_buffer, 11);
	    if (n <= 0) {
		syslog(LOG_ERR, "Can't read pid from lock file %s", lock_file);
		close(fd);
	    } else {
		hdb_lock_buffer[n] = 0;
		pid = atoi(hdb_lock_buffer);
		if (kill(pid, 0) == -1 && errno == ESRCH) {
		    /* pid no longer exists - remove the lock file */
		    if (unlink(lock_file) == 0) {
			close(fd);
			syslog(LOG_NOTICE, "Removed stale lock on %s (pid %ld)",
			       dev, (long)pid);
			continue;
		    } else
			syslog(LOG_WARNING, "Couldn't remove stale lock on %s",
			       dev);
		} else
		    syslog(LOG_NOTICE, "Device %s is locked by pid %ld",
			   dev, (long)pid);
	    }
	    close(fd);
	} else
	    syslog(LOG_ERR, "Can't create lock file %s: %m", lock_file);
	free(lock_file);
	lock_file = NULL;
	return -1;
    }

    snprintf(hdb_lock_buffer, sizeof hdb_lock_buffer, "%10ld\n", (long)getpid());
    write(fd, hdb_lock_buffer, 11);

    close(fd);
    return 0;
}

/*
 * unlock - remove our lockfile
 */
void
unlock()
{
    if (lock_file) {
	unlink(lock_file);
	free(lock_file);
	lock_file = NULL;
    }
}
@


1.26
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.25 2008/10/08 18:42:21 claudio Exp $	*/
a1439 9
}

/*
 * Use the hostid as part of the random number seed.
 */
int
get_host_seed()
{
    return gethostid();
@


1.25
log
@SIOCAIFADDR can fail with EEXIST either if the local or the destination
address already exists so mention both addresses in the error message.
From PR4584 (alexander at beard dot se) I just tuned the error message a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.24 2007/06/04 14:59:45 henning Exp $	*/
a75 8

#ifndef lint
#if 0
static char rcsid[] = "Id: sys-bsd.c,v 1.31 1998/04/02 12:04:19 paulus Exp $";
#else
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.24 2007/06/04 14:59:45 henning Exp $";
#endif
#endif
@


1.24
log
@bye bye ipx
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.23 2004/05/26 14:22:54 otto Exp $	*/
d81 1
a81 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.23 2004/05/26 14:22:54 otto Exp $";
d1030 1
d1053 2
d1056 2
a1057 2
	       "Couldn't set interface address: Address %s already exists",
	       ip_ntoa(o));
@


1.23
log
@Better message if interface is not available. Hint from Daniel Polak.
ok henning@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.22 2003/08/19 22:19:07 itojun Exp $	*/
d81 1
a81 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.22 2003/08/19 22:19:07 itojun Exp $";
a133 6
#ifdef IPX_CHANGE
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
#include "ipxcp.h"
#endif

a364 95

#ifdef IPX_CHANGE
/*
 * sipxfaddr - Config the interface IPX networknumber
 */
int
sipxfaddr(unit, network, node)
	  int unit;
	  u_int32_t network;
	  u_char * node;
{
	int    skfd; 
	int    result = 1;
	struct ifreq         ifr;
	struct sockaddr_ipx *sipx = (struct sockaddr_ipx *) &ifr.ifr_addr;

	skfd = socket (AF_IPX, SOCK_DGRAM, 0);
	if (skfd < 0) { 
		if (!ok_error (errno))
			syslog (LOG_DEBUG, "socket(AF_IPX): %m(%d)", errno);
		result = 0;
	} else {
		bzero (&ifr, sizeof(ifr));
		strlcpy (ifr.ifr_name, ifname, sizeof(ifr.ifr_name));

		sipx->sipx_len     = sizeof(*sipx);
		sipx->sipx_family  = AF_IPX;
		sipx->sipx_type    = IPX_ETHERTYPE_II;
		sipx->sipx_port    = 0;
		sipx->sipx_network = htonl (network);
		memcpy (sipx->sipx_node, node, IPX_HOSTADDRLEN);

		/*
		 *  Set the IPX device
		 */
		if (ioctl(skfd, SIOCSIFADDR, (caddr_t) &ifr) < 0) {
			result = 0;
			if (errno != EEXIST && !ok_error (errno)) {
				syslog (LOG_DEBUG,
					"ioctl(SIOCAIFADDR, CRTITF): %m(%d)",
					errno);
			} else {
				syslog (LOG_WARNING,
					"ioctl(SIOCAIFADDR, CRTITF): Address already exists");
			}
		}
		close (skfd);
	}

	return result;
}

/*
 * cipxfaddr - Clear the information for the IPX network. The IPX routes
 *	       are removed and the device is no longer able to pass IPX
 *	       frames.
 */
int
cipxfaddr(unit)
	int unit;
{
	int    skfd; 
	int    result = 1;
	struct ifreq         ifr;
	struct sockaddr_ipx *sipx = (struct sockaddr_ipx *) &ifr.ifr_addr;

	skfd = socket (AF_IPX, SOCK_DGRAM, 0);
	if (skfd < 0) {
		if (! ok_error (errno))
			syslog (LOG_DEBUG, "socket(AF_IPX): %m(%d)", errno);
		result = 0;
	} else {
		bzero (&ifr, sizeof(ifr));
		strlcpy (ifr.ifr_name, ifname, sizeof(ifr.ifr_name));

		sipx->sipx_len     = sizeof(*sipx);
		sipx->sipx_family  = AF_IPX;
		sipx->sipx_type    = IPX_ETHERTYPE_II;

		/*
		 *  Set the IPX device
		 */
		if (ioctl(skfd, SIOCDIFADDR, (caddr_t) &ifr) < 0) {
			if (!ok_error (errno))
				syslog (LOG_INFO,
					"ioctl(SIOCAIFADDR, IPX_DLTITF): %m(%d)",
					errno);
			result = 0;
		}
		close (skfd);
	}

	return result;
}
#endif
@


1.22
log
@rewrite SIOCGIFCONF into getifaddrs.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.21 2003/05/14 02:02:56 itojun Exp $	*/
d81 1
a81 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.21 2003/05/14 02:02:56 itojun Exp $";
d250 2
a251 4
This system lacks kernel support for PPP.  To include PPP support\n\
in the kernel, please add a line\n\
\tpseudo-device ppp 1\n\
to your kernel config file and build a new kernel.\n";
@


1.21
log
@move ETHERTYPE_xx declarations to <net/ethertypes.h>.  meets netbsd practice.
deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.20 2003/04/04 20:25:07 deraadt Exp $	*/
d81 1
a81 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.20 2003/04/04 20:25:07 deraadt Exp $";
d105 1
a1430 1
    struct ifreq *ifr, *ifend, *ifp;
d1433 4
a1436 8
    struct ifreq ifreq;
    struct ifconf ifc;
    struct ifreq ifs[MAX_IFS];

    ifc.ifc_len = sizeof(ifs);
    ifc.ifc_req = ifs;
    if (ioctl(sockfd, SIOCGIFCONF, &ifc) < 0) {
	syslog(LOG_ERR, "ioctl(SIOCGIFCONF): %m");
d1444 3
a1446 6
    ifend = (struct ifreq *) (ifc.ifc_buf + ifc.ifc_len);
    for (ifr = ifc.ifc_req; ifr < ifend; ifr = (struct ifreq *)
	 	((char *)&ifr->ifr_addr + ifr->ifr_addr.sa_len)) {
	if (ifr->ifr_addr.sa_family == AF_INET) {
	    ina = ((struct sockaddr_in *) &ifr->ifr_addr)->sin_addr.s_addr;
	    strlcpy(ifreq.ifr_name, ifr->ifr_name, sizeof(ifreq.ifr_name));
d1451 1
a1451 3
	    if (ioctl(sockfd, SIOCGIFFLAGS, &ifreq) < 0)
		continue;
	    if ((ifreq.ifr_flags &
d1458 1
a1458 4
	    ifreq.ifr_addr = ifr->ifr_addr;
	    if (ioctl(sockfd, SIOCGIFNETMASK, &ifreq) < 0)
		continue;
	    mask = ((struct sockaddr_in *) &ifreq.ifr_addr)->sin_addr.s_addr;
d1466 2
a1467 1
    if (ifr >= ifend)
d1469 2
a1470 1
    syslog(LOG_INFO, "found interface %s for proxy arp", ifr->ifr_name);
d1476 4
a1479 4
    ifp = ifr;
    for (ifr = ifc.ifc_req; ifr < ifend; ) {
	if (strcmp(ifp->ifr_name, ifr->ifr_name) == 0
	    && ifr->ifr_addr.sa_family == AF_LINK) {
d1483 1
a1483 1
	    dla = (struct sockaddr_dl *) &ifr->ifr_addr;
a1486 1
	ifr = (struct ifreq *) ((char *)&ifr->ifr_addr + ifr->ifr_addr.sa_len);
d1489 1
d1506 1
a1506 3
    struct ifreq *ifr, *ifend, ifreq;
    struct ifconf ifc;
    struct ifreq ifs[MAX_IFS];
d1521 2
a1522 4
    ifc.ifc_len = sizeof(ifs);
    ifc.ifc_req = ifs;
    if (ioctl(sockfd, SIOCGIFCONF, &ifc) < 0) {
	syslog(LOG_WARNING, "ioctl(SIOCGIFCONF): %m");
d1525 1
a1525 3
    ifend = (struct ifreq *) (ifc.ifc_buf + ifc.ifc_len);
    for (ifr = ifc.ifc_req; ifr < ifend; ifr = (struct ifreq *)
	 	((char *)&ifr->ifr_addr + ifr->ifr_addr.sa_len)) {
d1529 1
a1529 1
	if (ifr->ifr_addr.sa_family != AF_INET)
d1531 1
a1531 1
	ina = ((struct sockaddr_in *) &ifr->ifr_addr)->sin_addr.s_addr;
d1537 1
a1537 4
	strlcpy(ifreq.ifr_name, ifr->ifr_name, sizeof(ifreq.ifr_name));
	if (ioctl(sockfd, SIOCGIFFLAGS, &ifreq) < 0)
	    continue;
	if ((ifreq.ifr_flags & (IFF_UP|IFF_POINTOPOINT|IFF_LOOPBACK))
d1543 1
a1543 4
	ifreq.ifr_addr = ifr->ifr_addr;
	if (ioctl(sockfd, SIOCGIFNETMASK, &ifreq) < 0)
	    continue;
	mask |= ((struct sockaddr_in *)&ifreq.ifr_addr)->sin_addr.s_addr;
d1546 1
@


1.20
log
@strlcpy and snprintf; various people ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.19 2002/09/13 00:12:10 deraadt Exp $	*/
d81 1
a81 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.19 2002/09/13 00:12:10 deraadt Exp $";
d399 1
a399 1
		sipx->sipx_type    = ETHERTYPE_II;
d449 1
a449 1
		sipx->sipx_type    = ETHERTYPE_II;
@


1.19
log
@Paul Mackerras and the Australian National University have worked things
out, and as a result, Paul now owns copyright on all these files, with the
proper terms.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.18 2002/07/01 19:31:37 deraadt Exp $	*/
d81 1
a81 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.18 2002/07/01 19:31:37 deraadt Exp $";
d1596 1
a1596 2
    lock_file = malloc(strlen(LOCK_PREFIX) + strlen(dev) + 1);
    if (lock_file == NULL)
a1597 1
    strcat(strcpy(lock_file, LOCK_PREFIX), dev);
d1632 1
a1632 1
    sprintf(hdb_lock_buffer, "%10ld\n", (long)getpid());
@


1.18
log
@license update of CMU parts.  due to communication with wcw+@@andrew.cmu.edu,
pushed for by tygs@@netcologne.de.  Apparently we also now known how to talk
to the lawyers there, if we were so mad.  Note that a few other copyright
issues in pppd still remain, so this does not close this story.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.17 2002/05/26 09:25:21 deraadt Exp $	*/
d45 1
a45 2
 * Copyright (c) 1995 The Australian National University.
 * All rights reserved.
d47 28
a74 12
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Carnegie Mellon University and The Australian National University.
 * The names of the Universities may not be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d81 1
a81 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.17 2002/05/26 09:25:21 deraadt Exp $";
@


1.17
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.16 2002/02/16 21:28:07 millert Exp $	*/
d7 38
a44 1
 * Copyright (c) 1989 Carnegie Mellon University.
d66 1
a66 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.16 2002/02/16 21:28:07 millert Exp $";
@


1.16
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.15 2001/06/23 15:34:02 lebel Exp $	*/
d29 1
a29 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.15 2001/06/23 15:34:02 lebel Exp $";
d1538 2
a1539 1
    int fd, pid, n;
d1564 2
a1565 2
			syslog(LOG_NOTICE, "Removed stale lock on %s (pid %d)",
			       dev, pid);
d1571 2
a1572 2
		    syslog(LOG_NOTICE, "Device %s is locked by pid %d",
			   dev, pid);
d1582 1
a1582 1
    sprintf(hdb_lock_buffer, "%10d\n", getpid());
@


1.15
log
@use strlcpy vs strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.14 1998/05/08 04:52:33 millert Exp $	*/
d29 1
a29 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.14 1998/05/08 04:52:33 millert Exp $";
d114 2
a115 2
static int dodefaultroute __P((u_int32_t, int));
static int get_ether_addr __P((u_int32_t, struct sockaddr_dl *));
@


1.14
log
@pppd 2.3.5
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.13 1998/03/20 03:10:03 angelos Exp $	*/
d29 1
a29 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.13 1998/03/20 03:10:03 angelos Exp $";
d142 1
a142 2
	strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);
	ifr.ifr_name[sizeof(ifr.ifr_name) - 1] = '\0';
d192 1
a192 2
    strncpy(ifr.ifr_name, "ppp0", sizeof(ifr.ifr_name) - 1);
    ifr.ifr_name[sizeof(ifr.ifr_name) - 1] = '\0';
d343 1
a343 2
		strncpy (ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
		ifr.ifr_name[sizeof(ifr.ifr_name) - 1] = '\0';
d393 1
a393 2
		strncpy (ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);
		ifr.ifr_name[sizeof(ifr.ifr_name) - 1] = '\0';
d795 1
a795 2
    strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);
    ifr.ifr_name[sizeof(ifr.ifr_name) - 1] = '\0';
d995 1
a995 2
    strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);
    ifr.ifr_name[sizeof(ifr.ifr_name) - 1] = '\0';
d1046 1
a1046 2
    strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);
    ifr.ifr_name[sizeof(ifr.ifr_name) - 1] = '\0';
d1081 1
a1081 2
    strncpy(ifra.ifra_name, ifname, sizeof(ifra.ifra_name) - 1);
    ifra.ifra_name[sizeof(ifra.ifra_name) - 1] = '\0';
d1092 1
a1092 2
    strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);
    ifr.ifr_name[sizeof(ifr.ifr_name) - 1] = '\0';
d1123 1
a1123 2
    strncpy(ifra.ifra_name, ifname, sizeof(ifra.ifra_name) - 1);
    ifra.ifra_name[sizeof(ifra.ifra_name) - 1] = '\0';
d1401 1
a1401 2
	    strncpy(ifreq.ifr_name, ifr->ifr_name, sizeof(ifreq.ifr_name) - 1);
	    ifreq.ifr_name[sizeof(ifreq.ifr_name) - 1] = '\0';
d1501 1
a1501 2
	strncpy(ifreq.ifr_name, ifr->ifr_name, sizeof(ifreq.ifr_name) - 1);
	ifreq.ifr_name[sizeof(ifreq.ifr_name) - 1] = '\0';
@


1.13
log
@Aliases...
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.12 1998/01/17 20:30:29 millert Exp $	*/
d27 1
a27 1
static char rcsid[] = "Id: sys-bsd.c,v 1.29 1997/11/27 06:10:04 paulus Exp $";
d29 1
a29 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.12 1998/01/17 20:30:29 millert Exp $";
a52 1
#include <sys/param.h>
d65 5
d71 4
d1529 9
@


1.12
log
@ppp-2.3.3 + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.11 1997/12/17 08:49:46 deraadt Exp $	*/
d29 1
a29 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.11 1997/12/17 08:49:46 deraadt Exp $";
d1418 1
d1514 1
@


1.11
log
@do not let fd_set overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.10 1997/11/30 00:36:21 millert Exp $	*/
d27 1
a27 1
static char rcsid[] = "Id: sys-bsd.c,v 1.28 1997/04/30 05:57:46 paulus Exp";
d29 1
a29 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.10 1997/11/30 00:36:21 millert Exp $";
d42 1
a326 1
	struct sockaddr_ipx  ipx_addr;
a377 1
	struct sockaddr_ipx  ipx_addr;
@


1.10
log
@Fix setting of crtscts.  It was not being set in set_up_tty() if the
local var "local" is set.  This is a problem since that is set
during chat.  Use the "modem" var instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.9 1997/09/28 21:44:37 millert Exp $	*/
d29 1
a29 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.9 1997/09/28 21:44:37 millert Exp $";
d665 2
a666 1
    fd_set ready;
d669 7
a675 3
    FD_ZERO(&ready);
    FD_SET(ttyfd, &ready);
    n = select(ttyfd+1, &ready, NULL, &ready, timo);
d678 1
d681 1
d694 2
a695 1
    fd_set ready;
d698 7
a704 3
    FD_ZERO(&ready);
    FD_SET(loop_master, &ready);
    n = select(loop_master + 1, &ready, NULL, &ready, timo);
d707 1
d710 1
@


1.9
log
@Allow pppd to change interface addr when demand dialing & dynamic addressing.
Fix from Dave Huang <khym@@bga.com> based on what ifconfig does.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.8 1997/09/05 04:32:45 millert Exp $	*/
d29 1
a29 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.8 1997/09/05 04:32:45 millert Exp $";
d491 1
a491 1
    if (crtscts > 0 && !local)
@


1.8
log
@ppp 2.3.1
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.7 1997/06/27 02:16:23 deraadt Exp $	*/
d29 1
a29 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.7 1997/06/27 02:16:23 deraadt Exp $";
d1065 1
d1078 7
@


1.7
log
@long nightmares
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.6 1997/04/27 21:45:16 deraadt Exp $	*/
d26 5
a30 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.6 1997/04/27 21:45:16 deraadt Exp $";
d46 1
d52 1
d54 3
d70 1
a114 5
    openlog("pppd", LOG_PID | LOG_NDELAY, LOG_PPP);
    setlogmask(LOG_UPTO(LOG_INFO));
    if (debug)
	setlogmask(LOG_UPTO(LOG_DEBUG));

d133 2
a134 1
	strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
d144 1
a144 1
	cifdefaultroute(0, default_route_gateway);
a159 1
    closelog();
a169 1

d184 2
a185 1
    strncpy(ifr.ifr_name, "ppp0", sizeof (ifr.ifr_name));
d336 1
a336 1
		bzero (&ifr, sizeof (ifr));
d338 1
d388 3
a390 2
		bzero (&ifr, sizeof (ifr));
		strncpy (ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
d647 1
a647 1
	log_packet(p, len, "sent ");
d778 2
a779 1
    strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
d918 26
d979 2
a980 1
    strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
d1031 2
a1032 1
    strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
d1066 2
a1067 1
    strncpy(ifra.ifra_name, ifname, sizeof(ifra.ifra_name));
d1083 2
a1084 1
	       "Couldn't set interface address: Address already exists");
d1103 2
a1104 1
    strncpy(ifra.ifra_name, ifname, sizeof(ifra.ifra_name));
d1122 1
a1122 1
sifdefaultroute(u, g)
d1124 1
a1124 1
    u_int32_t g;
d1133 1
a1133 1
cifdefaultroute(u, g)
d1135 1
a1135 1
    u_int32_t g;
d1382 2
a1383 1
	    strncpy(ifreq.ifr_name, ifr->ifr_name, sizeof(ifreq.ifr_name));
d1482 2
a1483 1
	strncpy(ifreq.ifr_name, ifr->ifr_name, sizeof(ifreq.ifr_name));
@


1.6
log
@better failure msg; martin@@rumolt.teuto.de
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.5 1996/12/23 13:22:49 mickey Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.5 1996/12/23 13:22:49 mickey Exp $";
d316 1
a316 1
	  u_long network;
@


1.5
log
@pppd 2.3b3 import. some minor buf oflow fixes and so.
try it out ppl, but i've got it running talking to cisco w/ all the AFs
enabled in kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.4 1996/07/14 00:27:09 downsj Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.4 1996/07/14 00:27:09 downsj Exp $";
d186 3
a188 2
in the kernel, please follow the steps detailed in the README.bsd\n\
file in the ppp-2.2 distribution.\n";
@


1.4
log
@netbsd pr#2623: fix VJ compression and active filter, John Kohl
<jtk@@kolvir.arlington.ma.us>
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.3 1996/04/21 23:41:29 deraadt Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.3 1996/04/21 23:41:29 deraadt Exp $";
d60 9
a166 14
 * note_debug_level - note a change in the debug level.
 */
void
note_debug_level()
{
    if (debug) {
	syslog(LOG_INFO, "Debug turned ON, Level %d", debug);
	setlogmask(LOG_UPTO(LOG_DEBUG));
    } else {
	setlogmask(LOG_UPTO(LOG_WARNING));
    }
}

/*
d308 96
a738 1
    struct ppp_idle idle;
d752 1
a752 10
    if (get_idle_time(0, &idle)) {
	/* somebody sent a packet which poked the active filter. */
	/* VJ compression may result in get_loop_output() never
	   matching the idle filter since it's applied here in user space
	   after the kernel has compressed the packet.
	   The kernel applies the active filter before the VJ compression. */
	if (idle.xmit_idle < idle_time_limit)
	    rv = 1;
	SYSDEBUG((LOG_DEBUG, "xmit idle %d", idle.xmit_idle));
    }
a909 25
 * set_filters - transfer the pass and active filters to the kernel.
 */
int
set_filters(pass, active)
    struct bpf_program *pass, *active;
{
    int ret = 1;

    if (pass->bf_len > 0) {
	if (ioctl(ppp_fd, PPPIOCSPASS, pass) < 0) {
	    syslog(LOG_ERR, "Couldn't set pass-filter in kernel: %m");
	    ret = 0;
	}
    }
    if (active->bf_len > 0) {
	if (ioctl(ppp_fd, PPPIOCSACTIVE, active) < 0) {
	    syslog(LOG_ERR, "Couldn't set active-filter in kernel: %m");
	    ret = 0;
	}
    }
    return ret;
}


/*
d928 1
a928 1
    if (ioctl(ppp_fd, PPPIOCSMAXCID, (caddr_t) &maxcid) < 0) {
a942 1
    struct npioctl npi;
a954 6
    npi.protocol = PPP_IP;
    npi.mode = NPMODE_PASS;
    if (ioctl(ppp_fd, PPPIOCSNPMODE, &npi) < 0) {
	syslog(LOG_ERR, "ioctl(set IP mode to PASS): %m");
	return 0;
    }
@


1.3
log
@sync to netbsd 960418
@
text
@d1 1
a1 1
/*	$OpenBSD: sys-bsd.c,v 1.2 1996/03/25 15:55:57 niklas Exp $	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD: sys-bsd.c,v 1.2 1996/03/25 15:55:57 niklas Exp $";
d648 1
d662 10
a671 1

@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
static char rcsid[] = "$OpenBSD$";
d81 1
d126 2
a127 1

d988 2
d1004 1
@


1.1
log
@Initial revision
@
text
@d1 2
d8 1
d16 4
a19 3
 * by Carnegie Mellon University.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
d26 1
a26 1
static char rcsid[] = "$Id: sys-bsd.c,v 1.10 1995/08/17 12:04:03 paulus Exp $";
d37 1
d41 1
d61 3
a63 1
static int initdisc = -1;	/* Initial TTY discipline */
d66 1
a66 1
static int	restore_term;	/* 1 => we've munged the terminal */
d72 16
a87 1
int sockfd;			/* socket for doing interface ioctls */
d108 48
d198 2
a199 1
establish_ppp()
d204 13
d226 23
a248 6
    /*
     * Find out which interface we were given.
     */
    if (ioctl(fd, PPPIOCGUNIT, &ifunit) < 0) {	
	syslog(LOG_ERR, "ioctl(PPPIOCGUNIT): %m");
	die(1);
d251 2
d265 44
d317 22
a338 1
disestablish_ppp()
d343 19
a361 24
    if (initdisc >= 0) {
	/*
	 * Check whether the link seems not to be 8-bit clean.
	 */
	if (ioctl(fd, PPPIOCGFLAGS, (caddr_t) &x) == 0) {
	    s = NULL;
	    switch (~x & (SC_RCV_B7_0|SC_RCV_B7_1|SC_RCV_EVNP|SC_RCV_ODDP)) {
	    case SC_RCV_B7_0:
		s = "bit 7 set to 1";
		break;
	    case SC_RCV_B7_1:
		s = "bit 7 set to 0";
		break;
	    case SC_RCV_EVNP:
		s = "odd parity";
		break;
	    case SC_RCV_ODDP:
		s = "even parity";
		break;
	    }
	    if (s != NULL) {
		syslog(LOG_WARNING, "Serial link is not 8-bit clean:");
		syslog(LOG_WARNING, "All received characters had %s", s);
	    }
a362 2
	if (ioctl(fd, TIOCSETD, &initdisc) < 0)
	    syslog(LOG_ERR, "ioctl(TIOCSETD): %m");
a365 1

d373 1
d390 1
a390 1
    if (crtscts > 0)
d404 2
a405 2
    if (crtscts == 2) {
	tios.c_iflag |= IXOFF;
d439 2
a440 1
restore_tty()
d464 1
d475 62
a544 2
    if (unit != 0)
	MAINDEBUG((LOG_WARNING, "output: unit != 0!"));
d548 3
a550 3
    if (write(fd, p, len) < 0) {
	syslog(LOG_ERR, "write: %m");
	die(1);
d556 1
a556 1
 * wait_input - wait until there is data available on fd,
d560 1
d568 42
a609 2
    FD_SET(fd, &ready);
    n = select(fd+1, &ready, NULL, &ready, timo);
d626 1
a626 1
    if ((len = read(fd, buf, PPP_MTU + PPP_HDRLEN)) < 0) {
d629 1
a629 1
	syslog(LOG_ERR, "read(fd): %m");
d637 28
d684 1
a684 1
    if (ioctl(fd, PPPIOCSASYNCMAP, (caddr_t) &asyncmap) < 0) {
d689 1
a689 1
    if (ioctl(fd, PPPIOCGFLAGS, (caddr_t) &x) < 0) {
d695 1
a695 1
    if (ioctl(fd, PPPIOCSFLAGS, (caddr_t) &x) < 0) {
d710 1
a710 1
    if (ioctl(fd, PPPIOCSXASYNCMAP, accm) < 0 && errno != ENOTTY)
d727 1
a727 1
    if (ioctl(fd, PPPIOCSMRU, (caddr_t) &mru) < 0) {
d731 1
a731 1
    if (ioctl(fd, PPPIOCSRASYNCMAP, (caddr_t) &asyncmap) < 0) {
d735 1
a735 1
    if (ioctl(fd, PPPIOCGFLAGS, (caddr_t) &x) < 0) {
d740 1
a740 1
    if (ioctl(fd, PPPIOCSFLAGS, (caddr_t) &x) < 0) {
d748 3
a750 1
 * is acceptable for use.
d752 1
d762 3
a764 1
    return ioctl(fd, PPPIOCSCOMPRESS, (caddr_t) &data) >= 0;
d776 1
a776 1
    if (ioctl(fd, PPPIOCGFLAGS, (caddr_t) &x) < 0) {
d782 1
a782 1
    if (ioctl(fd, PPPIOCSFLAGS, (caddr_t) &x) < 0)
d797 1
a797 1
    if (ioctl(fd, PPPIOCGFLAGS, (caddr_t) &x) < 0) {
d805 37
d850 1
a850 1
    if (ioctl(fd, PPPIOCGFLAGS, (caddr_t) &x) < 0) {
d856 1
a856 1
    if (ioctl(fd, PPPIOCSFLAGS, (caddr_t) &x) < 0) {
d860 1
a860 1
    if (ioctl(fd, PPPIOCSMAXCID, (caddr_t) &maxcid) < 0) {
a869 4
#ifndef SC_ENABLE_IP
#define SC_ENABLE_IP	0x100	/* compat for old versions of kernel code */
#endif

a874 1
    u_int x;
d887 1
d890 23
a912 15
    if (ioctl(fd, PPPIOCSNPMODE, &npi) < 0) {
	if (errno != ENOTTY) {
	    syslog(LOG_ERR, "ioctl(PPPIOCSNPMODE): %m");
	    return 0;
	}
	/* for backwards compatibility */
	if (ioctl(fd, PPPIOCGFLAGS, (caddr_t) &x) < 0) {
	    syslog(LOG_ERR, "ioctl (PPPIOCGFLAGS): %m");
	    return 0;
	}
	x |= SC_ENABLE_IP;
	if (ioctl(fd, PPPIOCSFLAGS, (caddr_t) &x) < 0) {
	    syslog(LOG_ERR, "ioctl(PPPIOCSFLAGS): %m");
	    return 0;
	}
a924 1
    u_int x;
d931 2
a932 18
    if (ioctl(fd, PPPIOCSNPMODE, (caddr_t) &npi) < 0) {
	if (errno != ENOTTY) {
	    syslog(LOG_ERR, "ioctl(PPPIOCSNPMODE): %m");
	    rv = 0;
	} else {
	    /* backwards compatibility */
	    if (ioctl(fd, PPPIOCGFLAGS, (caddr_t) &x) < 0) {
		syslog(LOG_ERR, "ioctl (PPPIOCGFLAGS): %m");
		rv = 0;
	    } else {
		x &= ~SC_ENABLE_IP;
		if (ioctl(fd, PPPIOCSFLAGS, (caddr_t) &x) < 0) {
		    syslog(LOG_ERR, "ioctl(PPPIOCSFLAGS): %m");
		    rv = 0;
		}
	    }
	}
    }
d943 2
a944 1
	}
d980 1
a980 1
	    syslog(LOG_ERR, "ioctl(SIOCAIFADDR): %m");
d983 2
a984 1
	syslog(LOG_WARNING, "ioctl(SIOCAIFADDR): Address already exists");
d1007 2
a1008 1
	syslog(LOG_WARNING, "ioctl(SIOCDIFADDR): %m");
d1039 1
a1039 1
int
d1053 2
a1054 1
	syslog(LOG_ERR, "%cifdefaultroute: opening routing socket: %m", cmd);
d1074 2
a1075 1
	syslog(LOG_ERR, "%s default route: %m", cmd=='s'? "add": "delete");
d1081 1
a1104 1
    int l;
d1117 1
a1117 1
	syslog(LOG_ERR, "sifproxyarp: opening routing socket: %m");
d1135 1
a1135 1
	syslog(LOG_ERR, "add proxy arp entry: %m");
d1142 1
d1164 1
a1164 1
	syslog(LOG_ERR, "sifproxyarp: opening routing socket: %m");
d1169 1
a1169 1
	syslog(LOG_ERR, "delete proxy arp entry: %m");
d1175 1
d1213 1
a1213 1
	syslog(LOG_ERR, "ioctl(SIOCSARP): %m");
d1217 1
d1235 1
a1235 1
	syslog(LOG_WARNING, "ioctl(SIOCDARP): %m");
d1238 1
d1250 1
a1250 1
int
a1418 4
	    if (n > 0) {
		hdb_lock_buffer[n] = 0;
		pid = atoi(hdb_lock_buffer);
	    }
d1423 2
d1457 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

