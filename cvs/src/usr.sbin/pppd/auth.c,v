head	1.38;
access;
symbols
	OPENBSD_6_1:1.38.0.4
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.2
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.32.0.14
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.12
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.8
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.6
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.4
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.2
	OPENBSD_5_0:1.31.0.8
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.6
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.4
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.30.0.26
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.22
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.20
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.18
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.16
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.14
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.12
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.30.0.10
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.8
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.6
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.4
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_8:1.16.0.6
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.4
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.15.0.4
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2016.06.24.17.22.56;	author tedu;	state Exp;
branches;
next	1.37;
commitid	nNHG6Aih0Egq9cuS;

1.37
date	2016.05.17.20.51.56;	author tedu;	state Exp;
branches;
next	1.36;
commitid	8wsa4FlyaxyXNUha;

1.36
date	2016.05.09.17.32.24;	author tedu;	state Exp;
branches;
next	1.35;
commitid	jD65F2KOBWuM2fDR;

1.35
date	2015.12.26.20.51.35;	author guenther;	state Exp;
branches;
next	1.34;
commitid	ixyMcIFPirO2EXOW;

1.34
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	Uu5nFG3wCl0LACBb;

1.33
date	2014.11.13.06.19.51;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	XjyLihmW5reOAzDd;

1.32
date	2011.10.02.06.25.53;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.26.06.01.42;	author pvalchev;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.16.07.44.04;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.16.01.39.27;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.04.20.25.07;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.18.13.14.43;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.13.00.12.10;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.18.19.02.13;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.01.19.31.37;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.17.19.42.38;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.16.21.28.07;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.09.22.21.54;	author pjanzen;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.23.15.34.02;	author lebel;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.02.04.15.58;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.01.09.30.42;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	99.08.06.20.41.07;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.05.08.04.52.18;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.04.25.00.30.26;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.04.25.00.12.08;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.01.17.20.30.17;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.09.28.15.35.50;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.09.05.04.32.33;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.06.08.17.57.24;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.04.06.19.17.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.01.02.10.50.18;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.12.23.13.22.37;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.12.15.23.20.33;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.07.20.12.02.04;	author joshd;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.41.16;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.15.55.30;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.58;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.58;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.38
log
@use crypt_checkpass to simplify password checking logic.
@
text
@/*	$OpenBSD: auth.c,v 1.37 2016/05/17 20:51:56 tedu Exp $	*/

/*
 * auth.c - PPP authentication and phase control.
 *
 * Copyright (c) 1989-2002 Paul Mackerras. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name(s) of the authors of this software must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission.
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Paul Mackerras
 *     <paulus@@samba.org>".
 *
 * THE AUTHORS OF THIS SOFTWARE DISCLAIM ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Copyright (c) 1984-2000 Carnegie Mellon University. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The name "Carnegie Mellon University" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For permission or any legal
 *    details, please contact
 *      Office of Technology Transfer
 *      Carnegie Mellon University
 *      5000 Forbes Avenue
 *      Pittsburgh, PA  15213-3890
 *      (412) 268-4387, fax: (412) 268-7395
 *      tech-transfer@@andrew.cmu.edu
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Computing Services
 *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
 *
 * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <syslog.h>
#include <pwd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <utmp.h>
#include <fcntl.h>
#if defined(_PATH_LASTLOG) && defined(_linux_)
#include <lastlog.h>
#endif

#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>



#include "pppd.h"
#include "fsm.h"
#include "lcp.h"
#include "ipcp.h"
#include "upap.h"
#include "chap.h"
#ifdef CBCP_SUPPORT
#include "cbcp.h"
#endif
#include "pathnames.h"

/* Used for storing a sequence of words.  Usually malloced. */
struct wordlist {
    struct wordlist	*next;
    char		word[1];
};

/* Bits in scan_authfile return value */
#define NONWILD_SERVER	1
#define NONWILD_CLIENT	2

#define ISWILD(word)	(word[0] == '*' && word[1] == 0)

#define FALSE	0
#define TRUE	1

/* The name by which the peer authenticated itself to us. */
char peer_authname[MAXNAMELEN];

/* Records which authentication operations haven't completed yet. */
static int auth_pending[NUM_PPP];

/* Set if we have successfully called plogin() */
static int logged_in;

/* Set if we have run the /etc/ppp/auth-up script. */
static int did_authup;

/* List of addresses which the peer may use. */
static struct wordlist *addresses[NUM_PPP];

/* Number of network protocols which we have opened. */
static int num_np_open;

/* Number of network protocols which have come up. */
static int num_np_up;

/* Set if we got the contents of passwd[] from the pap-secrets file. */
static int passwd_from_file;

/* Bits in auth_pending[] */
#define PAP_WITHPEER	1
#define PAP_PEER	2
#define CHAP_WITHPEER	4
#define CHAP_PEER	8

extern char *crypt(const char *, const char *);

/* Prototypes for procedures local to this file. */

static void network_phase(int);
static void check_idle(void *);
static void connect_time_expired(void *);
static int  plogin(char *, char *, char **, int *);
static void plogout(void);
static int  null_login(int);
static int  get_pap_passwd(char *);
static int  have_pap_secret(void);
static int  have_chap_secret(char *, char *, u_int32_t);
static int  ip_addr_check(u_int32_t, struct wordlist *);
static int  scan_authfile(FILE *, char *, char *, u_int32_t, char *,
		struct wordlist **, char *);
static void free_wordlist(struct wordlist *);
static void auth_script(char *);
static void set_allowed_addrs(int, struct wordlist *);

/*
 * An Open on LCP has requested a change from Dead to Establish phase.
 * Do what's necessary to bring the physical layer up.
 */
void
link_required(unit)
    int unit;
{
}

/*
 * LCP has terminated the link; go to the Dead phase and take the
 * physical layer down.
 */
void
link_terminated(unit)
    int unit;
{
    if (phase == PHASE_DEAD)
	return;
    if (logged_in)
	plogout();
    phase = PHASE_DEAD;
    syslog(LOG_NOTICE, "Connection terminated.");
}

/*
 * LCP has gone down; it will either die or try to re-establish.
 */
void
link_down(unit)
    int unit;
{
    int i;
    struct protent *protp;

    if (did_authup) {
	auth_script(_PATH_AUTHDOWN);
	did_authup = 0;
    }
    for (i = 0; (protp = protocols[i]) != NULL; ++i) {
	if (!protp->enabled_flag)
	    continue;
        if (protp->protocol != PPP_LCP && protp->lowerdown != NULL)
	    (*protp->lowerdown)(unit);
        if (protp->protocol < 0xC000 && protp->close != NULL)
	    (*protp->close)(unit, "LCP down");
    }
    num_np_open = 0;
    num_np_up = 0;
    if (phase != PHASE_DEAD)
	phase = PHASE_TERMINATE;
}

/*
 * The link is established.
 * Proceed to the Dead, Authenticate or Network phase as appropriate.
 */
void
link_established(unit)
    int unit;
{
    int auth;
    lcp_options *wo = &lcp_wantoptions[unit];
    lcp_options *go = &lcp_gotoptions[unit];
    lcp_options *ho = &lcp_hisoptions[unit];
    int i;
    struct protent *protp;

    /*
     * Tell higher-level protocols that LCP is up.
     */
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
        if (protp->protocol != PPP_LCP && protp->enabled_flag
	    && protp->lowerup != NULL)
	    (*protp->lowerup)(unit);

    if (auth_required && !(go->neg_chap || go->neg_upap)) {
	/*
	 * We wanted the peer to authenticate itself, and it refused:
	 * treat it as though it authenticated with PAP using a username
	 * of "" and a password of "".  If that's not OK, boot it out.
	 */
	if (!wo->neg_upap || !null_login(unit)) {
	    syslog(LOG_WARNING, "peer refused to authenticate");
	    lcp_close(unit, "peer refused to authenticate");
	    return;
	}
    }

    phase = PHASE_AUTHENTICATE;
    auth = 0;
    if (go->neg_chap) {
	ChapAuthPeer(unit, our_name, go->chap_mdtype);
	auth |= CHAP_PEER;
    } else if (go->neg_upap) {
	upap_authpeer(unit);
	auth |= PAP_PEER;
    }
    if (ho->neg_chap) {
	ChapAuthWithPeer(unit, user, ho->chap_mdtype);
	auth |= CHAP_WITHPEER;
    } else if (ho->neg_upap) {
	if (passwd[0] == 0) {
	    passwd_from_file = 1;
	    if (!get_pap_passwd(passwd))
		syslog(LOG_ERR, "No secret found for PAP login");
	}
	upap_authwithpeer(unit, user, passwd);
	auth |= PAP_WITHPEER;
    }
    auth_pending[unit] = auth;

    if (!auth)
	network_phase(unit);
}

/*
 * Proceed to the network phase.
 */
static void
network_phase(unit)
    int unit;
{
    int i;
    struct protent *protp;
    lcp_options *go = &lcp_gotoptions[unit];

    /*
     * If the peer had to authenticate, run the auth-up script now.
     */
    if ((go->neg_chap || go->neg_upap) && !did_authup) {
	auth_script(_PATH_AUTHUP);
	did_authup = 1;
    }

#ifdef CBCP_SUPPORT
    /*
     * If we negotiated callback, do it now.
     */
    if (go->neg_cbcp) {
	phase = PHASE_CALLBACK;
	(*cbcp_protent.open)(unit);
	return;
    }
#endif

    phase = PHASE_NETWORK;
#if 0
    if (!demand)
	set_filters(&pass_filter, &active_filter);
#endif
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
        if (protp->protocol < 0xC000 && protp->enabled_flag
	    && protp->open != NULL) {
	    (*protp->open)(unit);
	    if (protp->protocol != PPP_CCP)
		++num_np_open;
	}

    if (num_np_open == 0)
	/* nothing to do */
	lcp_close(0, "No network protocols running");
}

/*
 * The peer has failed to authenticate himself using `protocol'.
 */
void
auth_peer_fail(unit, protocol)
    int unit, protocol;
{
    /*
     * Authentication failure: take the link down
     */
    lcp_close(unit, "Authentication failed");
}

/*
 * The peer has been successfully authenticated using `protocol'.
 */
void
auth_peer_success(unit, protocol, name, namelen)
    int unit, protocol;
    char *name;
    int namelen;
{
    int bit;

    switch (protocol) {
    case PPP_CHAP:
	bit = CHAP_PEER;
	break;
    case PPP_PAP:
	bit = PAP_PEER;
	break;
    default:
	syslog(LOG_WARNING, "auth_peer_success: unknown protocol %x",
	       protocol);
	return;
    }

    /*
     * Save the authenticated name of the peer for later.
     */
    if (namelen > sizeof(peer_authname) - 1)
	namelen = sizeof(peer_authname) - 1;
    BCOPY(name, peer_authname, namelen);
    peer_authname[namelen] = 0;
    script_setenv("PEERNAME", peer_authname);

    /*
     * If there is no more authentication still to be done,
     * proceed to the network (or callback) phase.
     */
    if ((auth_pending[unit] &= ~bit) == 0)
        network_phase(unit);
}

/*
 * We have failed to authenticate ourselves to the peer using `protocol'.
 */
void
auth_withpeer_fail(unit, protocol)
    int unit, protocol;
{
    if (passwd_from_file)
	BZERO(passwd, MAXSECRETLEN);
    /*
     * We've failed to authenticate ourselves to our peer.
     * He'll probably take the link down, and there's not much
     * we can do except wait for that.
     */
}

/*
 * We have successfully authenticated ourselves with the peer using `protocol'.
 */
void
auth_withpeer_success(unit, protocol)
    int unit, protocol;
{
    int bit;

    switch (protocol) {
    case PPP_CHAP:
	bit = CHAP_WITHPEER;
	break;
    case PPP_PAP:
	if (passwd_from_file)
	    BZERO(passwd, MAXSECRETLEN);
	bit = PAP_WITHPEER;
	break;
    default:
	syslog(LOG_WARNING, "auth_peer_success: unknown protocol %x",
	       protocol);
	bit = 0;
    }

    /*
     * If there is no more authentication still being done,
     * proceed to the network (or callback) phase.
     */
    if ((auth_pending[unit] &= ~bit) == 0)
	network_phase(unit);
}


/*
 * np_up - a network protocol has come up.
 */
void
np_up(unit, proto)
    int unit, proto;
{
    if (num_np_up == 0) {
	/*
	 * At this point we consider that the link has come up successfully.
	 */
	need_holdoff = 0;

	if (idle_time_limit > 0)
	    TIMEOUT(check_idle, NULL, idle_time_limit);

	/*
	 * Set a timeout to close the connection once the maximum
	 * connect time has expired.
	 */
	if (maxconnect > 0)
	    TIMEOUT(connect_time_expired, 0, maxconnect);

	/*
	 * Detach now, if the updetach option was given.
	 */
	if (nodetach == -1)
	    detach();
    }
    ++num_np_up;
}

/*
 * np_down - a network protocol has gone down.
 */
void
np_down(unit, proto)
    int unit, proto;
{
    if (--num_np_up == 0 && idle_time_limit > 0) {
	UNTIMEOUT(check_idle, NULL);
    }
}

/*
 * np_finished - a network protocol has finished using the link.
 */
void
np_finished(unit, proto)
    int unit, proto;
{
    if (--num_np_open <= 0) {
	/* no further use for the link: shut up shop. */
	lcp_close(0, "No network protocols running");
    }
}

/*
 * check_idle - check whether the link has been idle for long
 * enough that we can shut it down.
 */
static void
check_idle(arg)
    void *arg;
{
    struct ppp_idle idle;
    time_t itime;

    if (!get_idle_time(0, &idle))
	return;
    itime = MIN(idle.xmit_idle, idle.recv_idle);
    if (itime >= idle_time_limit) {
	/* link is idle: shut it down. */
	syslog(LOG_INFO, "Terminating connection due to lack of activity.");
	lcp_close(0, "Link inactive");
    } else {
	TIMEOUT(check_idle, NULL, idle_time_limit - itime);
    }
}

/*
 * connect_time_expired - log a message and close the connection.
 */
static void
connect_time_expired(arg)
    void *arg;
{
    syslog(LOG_INFO, "Connect time expired");
    lcp_close(0, "Connect time expired");	/* Close connection */
}

/*
 * auth_check_options - called to check authentication options.
 */
void
auth_check_options()
{
    lcp_options *wo = &lcp_wantoptions[0];
    int can_auth;
    ipcp_options *ipwo = &ipcp_wantoptions[0];
    u_int32_t remote;

    /* Default our_name to hostname, and user to our_name */
    if (our_name[0] == 0 || usehostname)
	strlcpy(our_name, hostname, HOST_NAME_MAX+1);
    if (user[0] == 0)
	strlcpy(user, our_name, MAXNAMELEN);

    /* If authentication is required, ask peer for CHAP or PAP. */
    if (auth_required && !wo->neg_chap && !wo->neg_upap) {
	wo->neg_chap = 1;
	wo->neg_upap = 1;
    }

    /*
     * Check whether we have appropriate secrets to use
     * to authenticate the peer.
     */
    can_auth = wo->neg_upap && (uselogin || have_pap_secret());
    if (!can_auth && wo->neg_chap) {
	remote = ipwo->accept_remote? 0: ipwo->hisaddr;
	can_auth = have_chap_secret(remote_name, our_name, remote);
    }

    if (auth_required && !can_auth) {
	option_error("peer authentication required but no suitable secret(s) found\n");
	if (remote_name[0] == 0)
	    option_error("for authenticating any peer to us (%s)\n", our_name);
	else
	    option_error("for authenticating peer %s to us (%s)\n",
			 remote_name, our_name);
	exit(1);
    }

    /*
     * Check whether the user tried to override certain values
     * set by root.
     */
    if (!auth_required && auth_req_info.priv > 0) {
	if (!default_device && devnam_info.priv == 0) {
	    option_error("can't override device name when noauth option used");
	    exit(1);
	}
	if ((connector != NULL && connector_info.priv == 0)
	    || (disconnector != NULL && disconnector_info.priv == 0)
	    || (welcomer != NULL && welcomer_info.priv == 0)) {
	    option_error("can't override connect, disconnect or welcome");
	    option_error("option values when noauth option used");
	    exit(1);
	}
    }
}

/*
 * auth_reset - called when LCP is starting negotiations to recheck
 * authentication options, i.e. whether we have appropriate secrets
 * to use for authenticating ourselves and/or the peer.
 */
void
auth_reset(unit)
    int unit;
{
    lcp_options *go = &lcp_gotoptions[unit];
    lcp_options *ao = &lcp_allowoptions[0];
    ipcp_options *ipwo = &ipcp_wantoptions[0];
    u_int32_t remote;

    ao->neg_upap = !refuse_pap && (passwd[0] != 0 || get_pap_passwd(NULL));
    ao->neg_chap = !refuse_chap
	&& have_chap_secret(user, remote_name, (u_int32_t)0);

    if (go->neg_upap && !uselogin && !have_pap_secret())
	go->neg_upap = 0;
    if (go->neg_chap) {
	remote = ipwo->accept_remote? 0: ipwo->hisaddr;
	if (!have_chap_secret(remote_name, our_name, remote))
	    go->neg_chap = 0;
    }
}


/*
 * check_passwd - Check the user name and passwd against the PAP secrets
 * file.  If requested, also check against the system password database,
 * and login the user if OK.
 *
 * returns:
 *	UPAP_AUTHNAK: Authentication failed.
 *	UPAP_AUTHACK: Authentication succeeded.
 * In either case, msg points to an appropriate message.
 */
int
check_passwd(unit, auser, userlen, apasswd, passwdlen, msg, msglen)
    int unit;
    char *auser;
    int userlen;
    char *apasswd;
    int passwdlen;
    char **msg;
    int *msglen;
{
    int ret;
    char *filename;
    FILE *f;
    struct wordlist *addrs;
    u_int32_t remote;
    ipcp_options *ipwo = &ipcp_wantoptions[unit];
    char passwd[256], user[256];
    char secret[MAXWORDLEN];
    static int attempts = 0;

    /*
     * Make copies of apasswd and auser, then null-terminate them.
     */
    BCOPY(apasswd, passwd, passwdlen);
    passwd[passwdlen] = '\0';
    BCOPY(auser, user, userlen);
    user[userlen] = '\0';
    *msg = (char *) 0;

    /*
     * Open the file of pap secrets and scan for a suitable secret
     * for authenticating this user.
     */
    filename = _PATH_UPAPFILE;
    addrs = NULL;
    ret = UPAP_AUTHACK;
    f = fopen(filename, "r");
    if (f == NULL) {
	syslog(LOG_ERR, "Can't open PAP password file %s: %m", filename);
	ret = UPAP_AUTHNAK;
    } else {
	check_access(f, filename);
	remote = ipwo->accept_remote? 0: ipwo->hisaddr;
	if (scan_authfile(f, user, our_name, remote,
			  secret, &addrs, filename) < 0
	    || (secret[0] != 0 && (cryptpap || strcmp(passwd, secret) != 0)
		&& strcmp(crypt(passwd, secret), secret) != 0)) {
	    syslog(LOG_WARNING, "PAP authentication failure for %s", user);
	    ret = UPAP_AUTHNAK;
	}
	fclose(f);
    }

    if (uselogin && ret == UPAP_AUTHACK) {
	ret = plogin(user, passwd, msg, msglen);
	if (ret == UPAP_AUTHNAK) {
	    syslog(LOG_WARNING, "PAP login failure for %s", user);
	}
    }

    if (ret == UPAP_AUTHNAK) {
        if (*msg == (char *) 0)
	    *msg = "Login incorrect";
	*msglen = strlen(*msg);
	/*
	 * Frustrate passwd stealer programs.
	 * Allow 10 tries, but start backing off after 3 (stolen from login).
	 * On 10'th, drop the connection.
	 */
	if (attempts++ >= 10) {
	    syslog(LOG_WARNING, "%d LOGIN FAILURES ON %s, %s",
		   attempts, devnam, user);
	    quit();
	}
	if (attempts > 3)
	    sleep((u_int) (attempts - 3) * 5);
	if (addrs != NULL)
	    free_wordlist(addrs);

    } else {
	attempts = 0;			/* Reset count */
	if (*msg == (char *) 0)
	    *msg = "Login ok";
	*msglen = strlen(*msg);
	set_allowed_addrs(unit, addrs);
    }

    BZERO(passwd, sizeof(passwd));
    BZERO(secret, sizeof(secret));

    return ret;
}

/*
 * plogin - Check the user name and password against the system
 * password database, and login the user if OK.
 *
 * returns:
 *	UPAP_AUTHNAK: Login failed.
 *	UPAP_AUTHACK: Login succeeded.
 * In either case, msg points to an appropriate message.
 */

static int
plogin(user, passwd, msg, msglen)
    char *user;
    char *passwd;
    char **msg;
    int *msglen;
{
    struct passwd *pw;
    char *tty;

    pw = getpwnam_shadow(user);
    if (crypt_checkpass(passwd, pw ? pw->pw_passwd : NULL))
	    return UPAP_AUTHNAK;

    /*
     * Write a wtmp entry for this user.
     */

    tty = devnam;
    if (strncmp(tty, "/dev/", 5) == 0)
	tty += 5;
    logwtmp(tty, user, remote_name);		/* Add wtmp login entry */

#if defined(_PATH_LASTLOG)
    {
	    struct lastlog ll;
	    int fd;

	    if ((fd = open(_PATH_LASTLOG, O_RDWR)) >= 0) {
		memset(&ll, 0, sizeof(ll));
		(void)time(&ll.ll_time);
		(void)strncpy(ll.ll_line, tty, sizeof(ll.ll_line));
		(void)pwrite(fd, &ll, sizeof(ll), (off_t)pw->pw_uid *
		    sizeof(ll));
		(void)close(fd);
	    }
    }
#endif


    syslog(LOG_INFO, "user %s logged in", user);
    logged_in = TRUE;

    return (UPAP_AUTHACK);
}

/*
 * plogout - Logout the user.
 */
static void
plogout()
{
    char *tty;

    tty = devnam;
    if (strncmp(tty, "/dev/", 5) == 0)
	tty += 5;
    logwtmp(tty, "", "");		/* Wipe out utmp logout entry */

    logged_in = FALSE;
}


/*
 * null_login - Check if a username of "" and a password of "" are
 * acceptable, and iff so, set the list of acceptable IP addresses
 * and return 1.
 */
static int
null_login(unit)
    int unit;
{
    char *filename;
    FILE *f;
    int i, ret;
    struct wordlist *addrs;
    char secret[MAXWORDLEN];

    /*
     * Open the file of pap secrets and scan for a suitable secret.
     * We don't accept a wildcard client.
     */
    filename = _PATH_UPAPFILE;
    addrs = NULL;
    f = fopen(filename, "r");
    if (f == NULL)
	return 0;
    check_access(f, filename);

    i = scan_authfile(f, "", our_name, (u_int32_t)0, secret, &addrs, filename);
    ret = i >= 0 && (i & NONWILD_CLIENT) != 0 && secret[0] == 0;
    BZERO(secret, sizeof(secret));

    if (ret)
	set_allowed_addrs(unit, addrs);
    else
	free_wordlist(addrs);

    fclose(f);
    return ret;
}


/*
 * get_pap_passwd - get a password for authenticating ourselves with
 * our peer using PAP.  Returns 1 on success, 0 if no suitable password
 * could be found.
 */
static int
get_pap_passwd(passwd)
    char *passwd;
{
    char *filename;
    FILE *f;
    int ret;
    char secret[MAXWORDLEN];

    filename = _PATH_UPAPFILE;
    f = fopen(filename, "r");
    if (f == NULL)
	return 0;
    check_access(f, filename);
    ret = scan_authfile(f, user,
			remote_name[0]? remote_name: NULL,
			(u_int32_t)0, secret, NULL, filename);
    fclose(f);
    if (ret < 0)
	return 0;
    if (passwd != NULL)
	strlcpy(passwd, secret, MAXSECRETLEN);
    BZERO(secret, sizeof(secret));
    return 1;
}


/*
 * have_pap_secret - check whether we have a PAP file with any
 * secrets that we could possibly use for authenticating the peer.
 */
static int
have_pap_secret()
{
    FILE *f;
    int ret;
    char *filename;
    ipcp_options *ipwo = &ipcp_wantoptions[0];
    u_int32_t remote;

    filename = _PATH_UPAPFILE;
    f = fopen(filename, "r");
    if (f == NULL)
	return 0;

    remote = ipwo->accept_remote? 0: ipwo->hisaddr;
    ret = scan_authfile(f, NULL, our_name, remote, NULL, NULL, filename);
    fclose(f);
    if (ret < 0)
	return 0;

    return 1;
}


/*
 * have_chap_secret - check whether we have a CHAP file with a
 * secret that we could possibly use for authenticating `client'
 * on `server'.  Either can be the null string, meaning we don't
 * know the identity yet.
 */
static int
have_chap_secret(client, server, remote)
    char *client;
    char *server;
    u_int32_t remote;
{
    FILE *f;
    int ret;
    char *filename;

    filename = _PATH_CHAPFILE;
    f = fopen(filename, "r");
    if (f == NULL)
	return 0;

    if (client[0] == 0)
	client = NULL;
    else if (server[0] == 0)
	server = NULL;

    ret = scan_authfile(f, client, server, remote, NULL, NULL, filename);
    fclose(f);
    if (ret < 0)
	return 0;

    return 1;
}


/*
 * get_secret - open the CHAP secret file and return the secret
 * for authenticating the given client on the given server.
 * (We could be either client or server).
 */
int
get_secret(unit, client, server, secret, secret_len, save_addrs)
    int unit;
    char *client;
    char *server;
    char *secret;
    int *secret_len;
    int save_addrs;
{
    FILE *f;
    int ret, len;
    char *filename;
    struct wordlist *addrs;
    char secbuf[MAXWORDLEN];

    filename = _PATH_CHAPFILE;
    addrs = NULL;
    secbuf[0] = 0;

    f = fopen(filename, "r");
    if (f == NULL) {
	syslog(LOG_ERR, "Can't open chap secret file %s: %m", filename);
	return 0;
    }
    check_access(f, filename);

    ret = scan_authfile(f, client, server, (u_int32_t)0,
			secbuf, &addrs, filename);
    fclose(f);
    if (ret < 0)
	return 0;

    if (save_addrs)
	set_allowed_addrs(unit, addrs);

    len = strlen(secbuf);
    if (len > MAXSECRETLEN) {
	syslog(LOG_ERR, "Secret for %s on %s is too long", client, server);
	len = MAXSECRETLEN;
    }
    BCOPY(secbuf, secret, len);
    BZERO(secbuf, sizeof(secbuf));
    *secret_len = len;

    return 1;
}

/*
 * set_allowed_addrs() - set the list of allowed addresses.
 */
static void
set_allowed_addrs(unit, addrs)
    int unit;
    struct wordlist *addrs;
{
    if (addresses[unit] != NULL)
	free_wordlist(addresses[unit]);
    addresses[unit] = addrs;

    /*
     * If there's only one authorized address we might as well
     * ask our peer for that one right away
     */
    if (addrs != NULL && addrs->next == NULL) {
	char *p = addrs->word;
	struct ipcp_options *wo = &ipcp_wantoptions[unit];
	struct in_addr ina;
	struct hostent *hp;

	if (*p != '!' && *p != '-' && !ISWILD(p) && strchr(p, '/') == NULL) {
	    hp = gethostbyname(p);
	    if (hp != NULL && hp->h_addrtype == AF_INET)
		wo->hisaddr = *(u_int32_t *)hp->h_addr;
	    else if (inet_aton(p, &ina) == 1)
		wo->hisaddr = ina.s_addr;
	}
    }
}

/*
 * auth_ip_addr - check whether the peer is authorized to use
 * a given IP address.  Returns 1 if authorized, 0 otherwise.
 */
int
auth_ip_addr(unit, addr)
    int unit;
    u_int32_t addr;
{
    return ip_addr_check(addr, addresses[unit]);
}

static int
ip_addr_check(addr, addrs)
    u_int32_t addr;
    struct wordlist *addrs;
{
    u_int32_t mask, ah;
    struct in_addr ina;
    int accept, r = 1;
    char *ptr_word, *ptr_mask;
    struct hostent *hp;

    /* don't allow loopback or multicast address */
    if (bad_ip_adrs(addr))
	return 0;

    if (addrs == NULL)
	return !auth_required;		/* no addresses authorized */

    for (; addrs != NULL; addrs = addrs->next) {
	/* "-" means no addresses authorized, "*" means any address allowed */
	ptr_word = addrs->word;
	if (strcmp(ptr_word, "-") == 0)
	    break;
	if (strcmp(ptr_word, "*") == 0)
	    return 1;

	accept = 1;
	if (*ptr_word == '!') {
	    accept = 0;
	    ++ptr_word;
	}

	mask = ~ (u_int32_t) 0;
	ptr_mask = strchr (ptr_word, '/');
	if (ptr_mask != NULL) {
	    int bit_count;

	    bit_count = (int) strtol (ptr_mask+1, (char **) 0, 10);
	    if (bit_count <= 0 || bit_count > 32) {
		syslog (LOG_WARNING,
			"invalid address length %s in auth. address list",
			ptr_mask);
		continue;
	    }
	    *ptr_mask = '\0';
	    mask <<= 32 - bit_count;
	}

	hp = gethostbyname(ptr_word);
	if (hp != NULL && hp->h_addrtype == AF_INET) {
	    ina.s_addr = *(u_int32_t *)hp->h_addr;
	} else {
	    r = inet_aton (ptr_word, &ina);
	    if (ptr_mask == NULL) {
		/* calculate appropriate mask for net */
		ah = ntohl(ina.s_addr);
		if (IN_CLASSA(ah))
		    mask = IN_CLASSA_NET;
		else if (IN_CLASSB(ah))
		    mask = IN_CLASSB_NET;
		else if (IN_CLASSC(ah))
		    mask = IN_CLASSC_NET;
	    }
	}

	if (ptr_mask != NULL)
	    *ptr_mask = '/';

	if (r == 0)
	    syslog (LOG_WARNING,
		    "unknown host %s in auth. address list",
		    addrs->word);
	else
	    /* Here ina.s_addr and addr are in network byte order,
	       and mask is in host order. */
	    if (((addr ^ ina.s_addr) & htonl(mask)) == 0)
		return accept;
    }
    return 0;			/* not in list => can't have it */
}

/*
 * bad_ip_adrs - return 1 if the IP address is one we don't want
 * to use, such as an address in the loopback net or a multicast address.
 * addr is in network byte order.
 */
int
bad_ip_adrs(addr)
    u_int32_t addr;
{
    addr = ntohl(addr);
    return (addr >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET
	|| IN_MULTICAST(addr) || IN_BADCLASS(addr);
}

/*
 * check_access - complain if a secret file has too-liberal permissions.
 */
void
check_access(f, filename)
    FILE *f;
    char *filename;
{
    struct stat sbuf;

    if (fstat(fileno(f), &sbuf) < 0) {
	syslog(LOG_WARNING, "cannot stat secret file %s: %m", filename);
    } else if ((sbuf.st_mode & (S_IRWXG | S_IRWXO)) != 0) {
	syslog(LOG_WARNING, "Warning - secret file %s has world and/or group access", filename);
    }
}


/*
 * scan_authfile - Scan an authorization file for a secret suitable
 * for authenticating `client' on `server'.  The return value is -1
 * if no secret is found, otherwise >= 0.  The return value has
 * NONWILD_CLIENT set if the secret didn't have "*" for the client, and
 * NONWILD_SERVER set if the secret didn't have "*" for the server.
 * Any following words on the line (i.e. address authorization
 * info) are placed in a wordlist and returned in *addrs.
 */
static int
scan_authfile(f, client, server, ipaddr, secret, addrs, filename)
    FILE *f;
    char *client;
    char *server;
    u_int32_t ipaddr;
    char *secret;
    struct wordlist **addrs;
    char *filename;
{
    int newline, xxx;
    int got_flag, best_flag;
    FILE *sf;
    struct wordlist *ap, *addr_list, *alist, *alast;
    char word[MAXWORDLEN];
    char atfile[MAXWORDLEN];
    char lsecret[MAXWORDLEN];

    if (addrs != NULL)
	*addrs = NULL;
    addr_list = NULL;
    if (!getword(f, word, &newline, filename))
	return -1;		/* file is empty??? */
    newline = 1;
    best_flag = -1;
    for (;;) {
	/*
	 * Skip until we find a word at the start of a line.
	 */
	while (!newline && getword(f, word, &newline, filename))
	    ;
	if (!newline)
	    break;		/* got to end of file */

	/*
	 * Got a client - check if it's a match or a wildcard.
	 */
	got_flag = 0;
	if (client != NULL && strcmp(word, client) != 0 && !ISWILD(word)) {
	    newline = 0;
	    continue;
	}
	if (!ISWILD(word))
	    got_flag = NONWILD_CLIENT;

	/*
	 * Now get a server and check if it matches.
	 */
	if (!getword(f, word, &newline, filename))
	    break;
	if (newline)
	    continue;
	if (server != NULL && strcmp(word, server) != 0 && !ISWILD(word))
	    continue;
	if (!ISWILD(word))
	    got_flag |= NONWILD_SERVER;

	/*
	 * Got some sort of a match - see if it's better than what
	 * we have already.
	 */
	if (got_flag <= best_flag)
	    continue;

	/*
	 * Get the secret.
	 */
	if (!getword(f, word, &newline, filename))
	    break;
	if (newline)
	    continue;

	/*
	 * Special syntax: @@filename means read secret from file.
	 */
	if (word[0] == '@@') {
	    strlcpy(atfile, word+1, sizeof atfile);
	    if ((sf = fopen(atfile, "r")) == NULL) {
		syslog(LOG_WARNING, "can't open indirect secret file %s",
		       atfile);
		continue;
	    }
	    check_access(sf, atfile);
	    if (!getword(sf, word, &xxx, atfile)) {
		syslog(LOG_WARNING, "no secret in indirect secret file %s",
		       atfile);
		fclose(sf);
		continue;
	    }
	    fclose(sf);
	}
	if (secret != NULL)
	    strlcpy(lsecret, word, sizeof lsecret);

	/*
	 * Now read address authorization info and make a wordlist.
	 */
	alist = alast = NULL;
	for (;;) {
	    size_t wordlen;

	    if (!getword(f, word, &newline, filename) || newline)
		break;
	    wordlen = strlen(word);	/* NUL in struct wordlist */
	    ap = (struct wordlist *) malloc(sizeof(struct wordlist) +
		wordlen);

	    if (ap == NULL)
		novm("authorized addresses");
	    ap->next = NULL;
	    strlcpy(ap->word, word, wordlen + 1);
	    if (alist == NULL)
		alist = ap;
	    else
		alast->next = ap;
	    alast = ap;
	}

	/*
	 * Check if the given IP address is allowed by the wordlist.
	 */
	if (ipaddr != 0 && !ip_addr_check(ipaddr, alist)) {
	    free_wordlist(alist);
	    continue;
	}

	/*
	 * This is the best so far; remember it.
	 */
	best_flag = got_flag;
	if (addr_list)
	    free_wordlist(addr_list);
	addr_list = alist;
	if (secret != NULL)
	    strlcpy(secret, lsecret, MAXWORDLEN);

	if (!newline)
	    break;
    }

    if (addrs != NULL)
	*addrs = addr_list;
    else if (addr_list != NULL)
	free_wordlist(addr_list);

    return best_flag;
}

/*
 * free_wordlist - release memory allocated for a wordlist.
 */
static void
free_wordlist(wp)
    struct wordlist *wp;
{
    struct wordlist *next;

    while (wp != NULL) {
	next = wp->next;
	free(wp);
	wp = next;
    }
}

/*
 * auth_script - execute a script with arguments
 * interface-name peer-name real-user tty speed
 */
static void
auth_script(script)
    char *script;
{
    char strspeed[32];
    struct passwd *pw;
    char struid[32];
    char *user_name;
    char *argv[8];

    if ((pw = getpwuid(getuid())) != NULL && pw->pw_name != NULL)
	user_name = pw->pw_name;
    else {
	snprintf(struid, sizeof struid, "%u", getuid());
	user_name = struid;
    }
    snprintf(strspeed, sizeof strspeed, "%d", baud_rate);

    argv[0] = script;
    argv[1] = ifname;
    argv[2] = peer_authname;
    argv[3] = user_name;
    argv[4] = devnam;
    argv[5] = strspeed;
    argv[6] = NULL;

    run_program(script, argv, 0);
}
@


1.37
log
@remove pam and shadow code that's not used. ok deraadt jca
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.36 2016/05/09 17:32:24 tedu Exp $	*/
a743 2


a746 1

d748 2
a749 12
    endpwent();
    if (pw == NULL) {
	return (UPAP_AUTHNAK);
    }


    /*
     * If no passwd, don't let them login.
     */
    if (pw->pw_passwd == NULL || *pw->pw_passwd == '\0'
	|| strcmp(crypt(passwd, pw->pw_passwd), pw->pw_passwd) != 0)
	return (UPAP_AUTHNAK);
@


1.36
log
@need to use shadow passwd function here, reminded by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.35 2015/12/26 20:51:35 guenther Exp $	*/
a96 3
#ifdef USE_PAM
#include <security/pam_appl.h>
#endif
a97 6
#ifdef HAS_SHADOW
#include <shadow.h>
#ifndef PW_PPP
#define PW_PPP PW_LOGIN
#endif
#endif
a727 69
 * This function is needed for PAM.
 */

#ifdef USE_PAM
static char *PAM_username = "";
static char *PAM_password = "";

#ifdef PAM_ESTABLISH_CRED       /* new PAM defines :(^ */
#define MY_PAM_STRERROR(err_code)  (char *) pam_strerror(pamh,err_code)
#else
#define MY_PAM_STRERROR(err_code)  (char *) pam_strerror(err_code)
#endif

static int pam_conv (int num_msg,
                     const struct pam_message **msg,
                     struct pam_response **resp,
                     void *appdata_ptr)
{
    int count = 0, replies = 0;
    struct pam_response *reply = NULL;
    int size = 0;

    for (count = 0; count < num_msg; count++)
      {
	struct pam_response *newreply;
	int newsize = size + sizeof (struct pam_response);
	newreply = realloc (reply, newsize); /* ANSI: is malloc() if reply==NULL */
	if (!newreply) {
	    free(reply);
	    reply = NULL;
	    return PAM_CONV_ERR;
	}
	reply = newreply;
	size = newsize;

	switch (msg[count]->msg_style)
	  {
	case PAM_PROMPT_ECHO_ON:
	    reply[replies].resp_retcode = PAM_SUCCESS;
	    reply[replies++].resp = strdup(PAM_username); /* never NULL */
	    break;

	case PAM_PROMPT_ECHO_OFF:
	    reply[replies].resp_retcode = PAM_SUCCESS;
	    reply[replies++].resp = strdup(PAM_password); /* never NULL */
	    break;

	case PAM_TEXT_INFO:
	    reply[replies].resp_retcode = PAM_SUCCESS;
	    reply[replies++].resp = NULL;
	    break;

	case PAM_ERROR_MSG:
	default:
	    free (reply);
	    return PAM_CONV_ERR;
	  }
      }

    if (resp)
        *resp = reply;
    else
        free (reply);

    return PAM_SUCCESS;
}
#endif

/*
a744 50
#ifdef USE_PAM

    struct pam_conv pam_conversation;
    pam_handle_t *pamh;
    int pam_error;
/*
 * Fill the pam_conversion structure
 */
    memset (&pam_conversation, '\0', sizeof (struct pam_conv));
    pam_conversation.conv = &pam_conv;

    pam_error = pam_start ("ppp", user, &pam_conversation, &pamh);

    if (pam_error != PAM_SUCCESS) {
	*msg = MY_PAM_STRERROR (pam_error);
	return UPAP_AUTHNAK;
    }
/*
 * Define the fields for the credential validation
 */
    (void) pam_set_item (pamh, PAM_TTY, devnam);
    PAM_username = user;
    PAM_password = passwd;
/*
 * Validate the user
 */
    pam_error = pam_authenticate (pamh, PAM_SILENT);
    if (pam_error == PAM_SUCCESS) {
        pam_error = pam_acct_mgmt (pamh, PAM_SILENT);

	/* start a session for this user. Session closed when link ends. */
	if (pam_error == PAM_SUCCESS)
	    (void) pam_open_session (pamh, PAM_SILENT);
    }

    *msg = MY_PAM_STRERROR (pam_error);

    PAM_username =
    PAM_password = "";
/*
 * Clean up the mess
 */
    (void) pam_end (pamh, pam_error);

    if (pam_error != PAM_SUCCESS)
        return UPAP_AUTHNAK;
/*
 * Use the non-PAM methods directly
 */
#else /* #ifdef USE_PAM */
a748 4
#ifdef HAS_SHADOW
    struct spwd *spwd;
    struct spwd *getspnam();
#endif
a755 17
#ifdef HAS_SHADOW
    spwd = getspnam(user);
    endspent();
    if (spwd) {
	/* check the age of the password entry */
	long now = time(NULL) / 86400L;

	if ((spwd->sp_expire > 0 && now >= spwd->sp_expire)
	    || ((spwd->sp_max >= 0 && spwd->sp_max < 10000)
		&& spwd->sp_lstchg >= 0
		&& now >= spwd->sp_lstchg + spwd->sp_max)) {
	    syslog(LOG_WARNING, "Password for %s has expired", user);
	    return (UPAP_AUTHNAK);
	}
	pw->pw_passwd = spwd->sp_pwdp;
    }
#endif
a763 6
    /* These functions are not enabled for PAM. The reason for this is that */
    /* there is not necessarily a "passwd" entry for this user. That is     */
    /* real purpose of 'PAM' -- to virtualize the account data from the     */
    /* application. If you want to do the same thing, write the entry in    */
    /* the 'session' hook.                                                  */

a788 1
#endif /* #ifdef USE_PAM */
a801 20
#ifdef USE_PAM
    struct pam_conv pam_conversation;
    pam_handle_t *pamh;
    int pam_error;
/*
 * Fill the pam_conversion structure. The PAM specification states that the
 * session must be able to be closed by a totally different handle from which
 * it was created. Hold the PAM group to their own specification!
 */
    memset (&pam_conversation, '\0', sizeof (struct pam_conv));
    pam_conversation.conv = &pam_conv;

    pam_error = pam_start ("ppp", user, &pam_conversation, &pamh);
    if (pam_error == PAM_SUCCESS) {
        (void) pam_set_item (pamh, PAM_TTY, devnam);
        (void) pam_close_session (pamh, PAM_SILENT);
	(void) pam_end (pamh, PAM_SUCCESS);
    }

#else
a807 1
#endif
@


1.35
log
@Use pread/pwrite instead separate lseek+read/write for lastlog.
Cast to off_t before multiplication to avoid truncation on ILP32

ok kettenis@@ mmcc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.34 2015/01/16 06:40:19 deraadt Exp $	*/
d882 1
a882 1
    pw = getpwnam(user);
@


1.34
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.33 2014/11/13 06:19:51 schwarze Exp $	*/
d933 2
a934 3
	    if ((fd = open(_PATH_LASTLOG, O_RDWR, 0)) >= 0) {
		(void)lseek(fd, (off_t)(pw->pw_uid * sizeof(ll)), SEEK_SET);
		memset((void *)&ll, 0, sizeof(ll));
d937 2
a938 1
		(void)write(fd, (char *)&ll, sizeof(ll));
@


1.33
log
@remove networks(5) support; it wasn't even documented to exist;
"just go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.32 2011/10/02 06:25:53 nicm Exp $	*/
d80 1
d556 1
a556 1
	strlcpy(our_name, hostname, MAXHOSTNAMELEN);
@


1.32
log
@Delete unused variables, from Michael W Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.31 2009/10/27 23:59:53 deraadt Exp $	*/
a1229 1
    struct netent *np;
d1272 1
a1272 5
	    np = getnetbyname (ptr_word);
	    if (np != NULL && np->n_addrtype == AF_INET)
		ina.s_addr = htonl (np->n_net);
	    else
		r = inet_aton (ptr_word, &ina);
@


1.31
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.30 2003/09/26 06:01:42 pvalchev Exp $	*/
a1040 1
    struct wordlist *addrs;
a1043 1
    addrs = NULL;
@


1.30
log
@realloc fixes; ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.29 2003/04/16 07:44:04 tedu Exp $	*/
a74 8

#ifndef lint
#if 0
static char rcsid[] = "Id: auth.c,v 1.37 1998/03/26 04:46:03 paulus Exp $";
#else
static char rcsid[] = "$OpenBSD: auth.c,v 1.29 2003/04/16 07:44:04 tedu Exp $";
#endif
#endif
@


1.29
log
@small fix to compile. spot by marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.28 2003/04/16 01:39:27 deraadt Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.28 2003/04/16 01:39:27 deraadt Exp $";
d768 6
a773 3
	size += sizeof (struct pam_response);
	reply = realloc (reply, size); /* ANSI: is malloc() if reply==NULL */
	if (!reply)
d775 3
@


1.28
log
@string cleaning; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.27 2003/04/04 20:25:07 deraadt Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.27 2003/04/04 20:25:07 deraadt Exp $";
d1456 1
@


1.27
log
@strlcpy and snprintf; various people ok
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.26 2003/02/18 13:14:43 jmc Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.26 2003/02/18 13:14:43 jmc Exp $";
d1450 2
d1454 3
a1456 2
	    ap = (struct wordlist *) malloc(sizeof(struct wordlist)
					    + strlen(word));
d1460 1
a1460 1
	    strcpy(ap->word, word);
@


1.26
log
@intial -> initial;

the great intial witch hunt, as prompted by tdeval@@

os-aix-dso.c: ok henning@@
ab.C: ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.25 2002/09/13 00:12:10 deraadt Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.25 2002/09/13 00:12:10 deraadt Exp $";
d563 1
a563 1
	strcpy(our_name, hostname);
d565 1
a565 1
	strcpy(user, our_name);
d1427 1
a1427 1
	    strcpy(atfile, word+1);
d1443 1
a1443 1
	    strcpy(lsecret, word);
d1481 1
a1481 1
	    strcpy(secret, lsecret);
d1528 1
a1528 1
	sprintf(struid, "%u", getuid());
d1531 1
a1531 1
    sprintf(strspeed, "%d", baud_rate);
@


1.25
log
@Paul Mackerras and the Australian National University have worked things
out, and as a result, Paul now owns copyright on all these files, with the
proper terms.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.24 2002/07/18 19:02:13 deraadt Exp $	*/
d80 1
a80 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.24 2002/07/18 19:02:13 deraadt Exp $";
d842 1
a842 1
 * Define the fields for the credintial validation
@


1.24
log
@use inet_aton() instead of inet_addr(); millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.23 2002/07/01 19:31:37 deraadt Exp $	*/
d6 1
a6 2
 * Copyright (c) 1993 The Australian National University.
 * All rights reserved.
d8 28
a35 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Australian National University.  The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d80 1
a80 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.23 2002/07/01 19:31:37 deraadt Exp $";
@


1.23
log
@license update of CMU parts.  due to communication with wcw+@@andrew.cmu.edu,
pushed for by tygs@@netcologne.de.  Apparently we also now known how to talk
to the lawyers there, if we were so mad.  Note that a few other copyright
issues in pppd still remain, so this does not close this story.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.22 2002/02/17 19:42:38 millert Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.22 2002/02/17 19:42:38 millert Exp $";
d1183 1
a1183 1
	u_int32_t a;
d1189 3
a1191 5
		a = *(u_int32_t *)hp->h_addr;
	    else
		a = inet_addr(p);
	    if (a != (u_int32_t) -1)
		wo->hisaddr = a;
@


1.22
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.21 2002/02/16 21:28:07 millert Exp $	*/
d21 29
a49 2
 * Copyright (c) 1989 Carnegie Mellon University.
 * All rights reserved.
d51 7
a57 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Carnegie Mellon University.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d64 1
a64 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.21 2002/02/16 21:28:07 millert Exp $";
@


1.21
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.20 2001/07/09 22:21:54 pjanzen Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.20 2001/07/09 22:21:54 pjanzen Exp $";
d146 2
a147 2
static int  scan_authfile __P((FILE *, char *, char *, u_int32_t, char *,
			       struct wordlist **, char *));
@


1.20
log
@remove extraneous braces
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.19 2001/06/23 15:34:02 lebel Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.19 2001/06/23 15:34:02 lebel Exp $";
d132 1
a132 1
extern char *crypt __P((const char *, const char *));
d136 10
a145 10
static void network_phase __P((int));
static void check_idle __P((void *));
static void connect_time_expired __P((void *));
static int  plogin __P((char *, char *, char **, int *));
static void plogout __P((void));
static int  null_login __P((int));
static int  get_pap_passwd __P((char *));
static int  have_pap_secret __P((void));
static int  have_chap_secret __P((char *, char *, u_int32_t));
static int  ip_addr_check __P((u_int32_t, struct wordlist *));
d148 3
a150 3
static void free_wordlist __P((struct wordlist *));
static void auth_script __P((char *));
static void set_allowed_addrs __P((int, struct wordlist *));
@


1.19
log
@use strlcpy vs strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.18 2001/01/02 04:15:58 angelos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.18 2001/01/02 04:15:58 angelos Exp $";
d1019 1
a1019 1
    if (passwd != NULL) {
a1020 1
    }
@


1.18
log
@Fine, I'm convinced -- don't set the mask to ~0.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.17 2001/01/01 09:30:42 angelos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.17 2001/01/01 09:30:42 angelos Exp $";
d1020 1
a1020 2
	strncpy(passwd, secret, MAXSECRETLEN - 1);
	passwd[MAXSECRETLEN - 1] = '\0';
@


1.17
log
@Force mask to ~0 only if hostname (kudos to james@@squish.net)
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.16 1999/08/06 20:41:07 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.16 1999/08/06 20:41:07 deraadt Exp $";
d1239 1
a1239 1
	if (hp != NULL && hp->h_addrtype == AF_INET && hp->h_name != NULL) {
a1240 1
	    mask = ~ (u_int32_t) 0;	/* are we sure we want this? */
@


1.16
log
@uid_t and gid_t, and use %u
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.15 1998/05/08 04:52:18 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.15 1998/05/08 04:52:18 millert Exp $";
d1239 1
a1239 1
	if (hp != NULL && hp->h_addrtype == AF_INET) {
@


1.15
log
@pppd 2.3.5
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.14 1998/04/25 00:30:26 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.14 1998/04/25 00:30:26 millert Exp $";
d1494 1
a1494 1
	sprintf(struid, "%d", getuid());
@


1.14
log
@Use ISWILD macro, not bare '*'
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.13 1998/04/25 00:12:08 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "Id: auth.c,v 1.35 1997/11/27 06:49:15 paulus Exp $";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.13 1998/04/25 00:12:08 deraadt Exp $";
a66 1
#include <security/pam_modules.h>
a70 3
#ifndef SVR4
#include <shadow/pwauth.h>
#endif
d361 1
d442 6
a597 1

d705 1
a705 2
 * This function is needed for PAM. However, it should not be called.
 * If it is, return the error code.
d709 55
a763 4
static int pam_conv(int num_msg, const struct pam_message **msg,
		    struct pam_response **resp, void *appdata_ptr)
{
    return PAM_CONV_ERR;
a783 1
    char *tty;
d786 1
a789 2
    char *pass;
    char *dev;
d797 1
d799 1
a799 1
	*msg = (char *) pam_strerror (pam_error);
a804 1
    (void) pam_set_item (pamh, PAM_AUTHTOK, passwd);
d806 2
d812 1
a812 1
    if (pam_error == PAM_SUCCESS)
d815 9
a823 1
    *msg = (char *) pam_strerror (pam_error);
d837 1
a841 1
    extern int isexpired (struct passwd *, struct spwd *); /* in libshadow.a */
d845 1
d855 7
a861 2
	if (isexpired(pw, spwd)) {
	    syslog(LOG_WARNING,"Expired password for %s",user);
d875 5
a879 3
#endif /* #ifdef USE_PAM */

    syslog(LOG_INFO, "user %s logged in", user);
d884 1
d890 1
a890 1
#ifdef _PATH_LASTLOG
d905 4
d920 20
d945 3
a947 1
    logwtmp(tty, "", "");		/* Wipe out wtmp logout entry */
d1165 1
a1165 2
	if (wo->hisaddr == 0 && *p != '!' && *p != '-' && !ISWILD(p) &&
	    strchr(p, '/') == NULL) {
@


1.13
log
@do not lookup hostname "*"; khym@@bga.com
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.12 1998/01/17 20:30:17 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.12 1998/01/17 20:30:17 millert Exp $";
d1070 2
a1071 2
	if (wo->hisaddr == 0 && *p != '!' && *p != '-' && *p != '*'
	    && strchr(p, '/') == NULL) {
@


1.12
log
@ppp-2.3.3 + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.11 1997/09/28 15:35:50 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.11 1997/09/28 15:35:50 deraadt Exp $";
d1070 1
a1070 1
	if (wo->hisaddr == 0 && *p != '!' && *p != '-'
@


1.11
log
@write lastlog; mason@@primenet.com.au
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.10 1997/09/05 04:32:33 millert Exp $	*/
d39 1
a39 1
static char rcsid[] = "Id: auth.c,v 1.32 1997/07/14 03:52:33 paulus Exp";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.10 1997/09/05 04:32:33 millert Exp $";
a50 2
#include <utmp.h>
#include <fcntl.h>
d55 5
d112 1
a112 1
/* Set if we have successfully called login() */
d141 4
a144 4
static void check_idle __P((caddr_t));
static void connect_time_expired __P((caddr_t));
static int  login __P((char *, char *, char **, int *));
static void logout __P((void));
a154 3
#ifdef CBCP_SUPPORT
static void callback_phase __P((int));
#endif
d177 1
a177 1
	logout();
d480 1
a480 1
    caddr_t arg;
d502 1
a502 1
    caddr_t arg;
d647 2
a648 4
	if (!uselogin) {
	    syslog(LOG_ERR, "Can't open PAP password file %s: %m", filename);
	    ret = UPAP_AUTHNAK;
	}
d663 1
a663 1
	ret = login(user, passwd, msg, msglen);
d716 1
a716 1
 * login - Check the user name and password against the system
d726 1
a726 1
login(user, passwd, msg, msglen)
d822 12
a833 11
{
    struct lastlog ll;
    int fd;

    if ((fd = open(_PATH_LASTLOG, O_RDWR, 0)) >= 0) {
	(void)lseek(fd, (off_t)pw->pw_uid * sizeof(ll), SEEK_SET);
	memset(&ll, 0, sizeof(ll));
	time(&ll.ll_time);
	strncpy(ll.ll_line, tty, sizeof(ll.ll_line));
	write(fd, (char *)&ll, sizeof(ll));
	close(fd);
a834 1
}
d842 1
a842 1
 * logout - Logout the user.
d845 1
a845 1
logout()
@


1.10
log
@ppp 2.3.1
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.9 1997/06/08 17:57:24 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.9 1997/06/08 17:57:24 deraadt Exp $";
d51 2
d822 16
@


1.9
log
@FILE * leak; d@@fnarg.net.au, PR#216
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.8 1997/04/06 19:17:06 millert Exp $	*/
d38 5
a42 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.8 1997/04/06 19:17:06 millert Exp $";
a62 1
int isexpired (struct passwd *, struct spwd *);
d67 1
d69 1
a85 4
#if defined(sun) && defined(sparc)
#include <alloca.h>
#endif /*sparc*/

d131 2
d137 1
d149 1
d191 2
a192 2
        auth_script(_PATH_AUTHDOWN);
        did_authup = 0;
d204 2
a205 1
    phase = PHASE_TERMINATE;
d257 5
a261 5
        if (passwd[0] == 0) {
            passwd_from_file = 1;
            if (!get_pap_passwd(passwd))
                syslog(LOG_ERR, "No secret found for PAP login");
        }
d286 2
a287 2
      auth_script(_PATH_AUTHUP);
      did_authup = 1;
d295 3
a297 3
       phase = PHASE_CALLBACK;
       (*cbcp_protent.open)(unit);
       return;
d313 4
d360 1
a360 1
        namelen = sizeof(peer_authname) - 1;
d380 1
a380 2
        BZERO(passwd, MAXSECRETLEN);

d402 2
a403 2
        if (passwd_from_file)
            BZERO(passwd, MAXSECRETLEN);
d428 15
a442 2
    if (num_np_up == 0 && idle_time_limit > 0) {
	TIMEOUT(check_idle, NULL, idle_time_limit);
a488 1
        need_holdoff = 0;
d496 11
d535 2
a536 2
        remote = ipwo->accept_remote? 0: ipwo->hisaddr;
        can_auth = have_chap_secret(remote_name, our_name, remote);
d540 6
a545 6
        option_error("peer authentication required but no suitable secret(s) found\n");
        if (remote_name[0] == 0)
            option_error("for authenticating any peer to us (%s)\n", our_name);
        else
            option_error("for authenticating peer %s to us (%s)\n",
                         remote_name, our_name);
d558 3
a560 3
	if (connector != NULL && connector_info.priv == 0
	    || disconnector != NULL && disconnector_info.priv == 0
	    || welcomer != NULL && welcomer_info.priv == 0) {
d581 1
a581 1
    
d585 1
a585 1
    
d587 1
a587 1
        go->neg_upap = 0;
d589 3
a591 3
        remote = ipwo->accept_remote? 0: ipwo->hisaddr;
        if (!have_chap_secret(remote_name, our_name, remote))
            go->neg_chap = 0;
a648 1

d690 1
a690 1
        if (*msg == (char *) 0)
d693 1
a693 3
	if (addresses[unit] != NULL)
	    free_wordlist(addresses[unit]);
	addresses[unit] = addrs;
d696 1
a696 1
    BZERO(passwd, sizeof(passwd));   
a701 61
#ifdef HAS_SHADOW
/**************
 * This function was lifted from the shadow-3.3.2 version by John Haugh II.
 * It is included because the function was not in the standard libshadow
 * library. If it is included in the library then I can remove it from here.
 */
        
#define DAY     (24L*3600L)
/*
 * isexpired - determine if account is expired yet
 *
 *      isexpired calculates the expiration date based on the
 *      password expiration criteria.
 */
           
/*ARGSUSED*/
int
isexpired (pw, sp)
struct  passwd  *pw;
struct  spwd    *sp;
{
        long    clock;
 
        clock = time ((time_t *) 0) / DAY;
   
        /*
         * Quick and easy - there is an expired account field
         * along with an inactive account field.  Do the expired
         * one first since it is worse.
         */
 
        if (sp->sp_expire > 0 && sp->sp_expire < clock)
                return 3;

        if (sp->sp_inact > 0 && sp->sp_lstchg > 0 && sp->sp_max > 0 &&
                        sp->sp_inact + sp->sp_lstchg + sp->sp_max < clock)
                return 2;
 
        /*
         * The last and max fields must be present for an account
         * to have an expired password.  A maximum of >10000 days
         * is considered to be infinite.
         */

        if (sp->sp_lstchg == -1 ||
                        sp->sp_max == -1 || sp->sp_max >= 10000L)
                return 0;
        
        /*
         * Calculate today's day and the day on which the password
         * is going to expire.  If that date has already passed,
         * the password has expired.
         */
         
        if (sp->sp_lstchg + sp->sp_max < clock)
                return 1;
 
        return 0;
}
#endif

d706 1
a706 1
         
d709 1
a709 1
                    struct pam_response **resp, void *appdata_ptr)
d713 1
a713 2
#endif  

d745 1
a745 1
    
d748 2
a749 2
        *msg = (char *) pam_strerror (pam_error);
        return UPAP_AUTHNAK;
d751 1
a751 1
/*        
d762 1
a762 1
    
d768 1
a768 1
   
d771 1
a771 1
/*  
d775 1
a775 1
        
d777 1
a777 2
    char *epasswd;
     
d781 1
d783 1
a783 1
       
d786 4
a789 4
        return (UPAP_AUTHNAK);
    }   
    
#ifdef HAS_SHADOW 
d798 1
a798 1
        pw->pw_passwd = spwd->sp_pwdp;
d801 1
a801 1
    
d803 1
a803 1
     * XXX If no passwd, let them login without one.
d805 5
a809 7
    if (pw->pw_passwd != NULL && *pw->pw_passwd != '\0') {
    epasswd = crypt(passwd, pw->pw_passwd);
	if (strcmp(epasswd, pw->pw_passwd) != 0) {
        return (UPAP_AUTHNAK);
    }
    }
#endif /* #ifdef USE_PAM */   
d871 4
a874 5
    if (ret) {
	if (addresses[unit] != NULL)
	    free_wordlist(addresses[unit]);
	addresses[unit] = addrs;
    }
d892 1
d902 5
a906 4
    if (scan_authfile(f, user,
                      remote_name[0]? remote_name: NULL,
                      (u_int32_t)0, secret, NULL, filename) < 0) {
	fclose(f);
d908 3
a911 5
    fclose(f);
    if (passwd != NULL) {
        strncpy(passwd, secret, MAXSECRETLEN);
        passwd[MAXSECRETLEN-1] = 0;
    }   
d1017 2
a1018 5
    if (save_addrs) {
	if (addresses[unit] != NULL)
	    free_wordlist(addresses[unit]);
	addresses[unit] = addrs;
    }
d1033 35
d1096 1
a1096 1
	return 1;		/* no restriction */
d1099 1
a1099 1
	/* "-" means no addresses authorized */
d1103 2
d1158 2
d1205 1
a1205 1
 * info) are placed in a wordlist and returned in *addrs.  
d1378 1
a1378 1
    char *user_name; 
d1380 1
a1380 1
    
d1382 1
a1382 1
        user_name = pw->pw_name; 
d1384 2
a1385 2
        sprintf(struid, "%d", getuid());
        user_name = struid;
d1388 1
a1388 1
        
d1396 1
a1396 1
   
a1398 1

@


1.8
log
@Fix mangling in assignment of np->n_net to ina.s_addr.
Presumably this was added to deal with 64-bit machines but
it is a) wrong and b) not necesary now that we use in_addr_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.7 1997/01/02 10:50:18 mickey Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.7 1997/01/02 10:50:18 mickey Exp $";
d939 2
a940 1
                      (u_int32_t)0, secret, NULL, filename) < 0)
d942 2
@


1.7
log
@inet_addr --> inet_aton
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.6 1996/12/23 13:22:37 mickey Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.6 1996/12/23 13:22:37 mickey Exp $";
d1134 1
a1134 1
		ina.s_addr = htonl (*(u_int32_t *)np->n_net);
@


1.6
log
@pppd 2.3b3 import. some minor buf oflow fixes and so.
try it out ppl, but i've got it running talking to cisco w/ all the AFs
enabled in kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.5 1996/12/15 23:20:33 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.5 1996/12/15 23:20:33 millert Exp $";
d1085 3
a1087 2
    u_int32_t a, mask, ah;
    int accept;
d1129 1
a1129 1
	    a    = *(u_int32_t *)hp->h_addr;
d1134 1
a1134 1
		a = htonl (*(u_int32_t *)np->n_net);
d1136 1
a1136 1
		a = inet_addr (ptr_word);
d1139 1
a1139 1
		ah = ntohl(a);
d1152 1
a1152 1
	if (a == -1L)
d1157 1
a1157 1
	    if (((addr ^ a) & htonl(mask)) == 0)
@


1.5
log
@Use inet_aton() instead of inet_addr()
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.4 1996/07/20 12:02:04 joshd Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.4 1996/07/20 12:02:04 joshd Exp $";
d59 1
d76 3
d125 2
a126 2
#define UPAP_WITHPEER	1
#define UPAP_PEER	2
d137 2
a138 2
static int  get_upap_passwd __P((char *));
static int  have_upap_secret __P((void));
d145 3
a147 1

d195 1
a195 2
	    (*protp->close)(unit, "LCP link down");

a233 1
	    phase = PHASE_TERMINATE;
d245 1
a245 1
	auth |= UPAP_PEER;
d248 1
a248 1
	ChapAuthWithPeer(unit, our_name, ho->chap_mdtype);
d253 1
a253 1
            if (!get_upap_passwd(passwd))
d257 1
a257 1
	auth |= UPAP_WITHPEER;
d284 11
a319 1
    phase = PHASE_TERMINATE;
d338 1
a338 1
	bit = UPAP_PEER;
d356 1
a356 1
     * proceed to the network phase.
d395 1
a395 1
	bit = UPAP_WITHPEER;
d405 1
a405 1
     * proceed to the network phase.
d467 1
a481 1
    lcp_options *ao = &lcp_allowoptions[0];
d499 1
a499 1
     * to authenticate ourselves and/or the peer.
d501 4
a504 10
    if (ao->neg_upap && passwd[0] == 0 && !get_upap_passwd(passwd))
	ao->neg_upap = 0;
    if (wo->neg_upap && !uselogin && !have_upap_secret())
	wo->neg_upap = 0;
    if (ao->neg_chap && !have_chap_secret(our_name, remote_name, (u_int32_t)0))
	ao->neg_chap = 0;
    if (wo->neg_chap) {
	remote = ipwo->accept_remote? 0: ipwo->hisaddr;
	if (!have_chap_secret(remote_name, our_name, remote))
	    wo->neg_chap = 0;
d507 7
a513 3
    if (auth_required && !wo->neg_chap && !wo->neg_upap) {
	fprintf(stderr, "\
pppd: peer authentication required but no suitable secret(s) found\n");
d517 17
d550 1
a550 1
    ao->neg_upap = !refuse_pap && (passwd[0] != 0 || get_upap_passwd(NULL));
d552 1
a552 1
        && have_chap_secret(our_name, remote_name, (u_int32_t)0);
d554 1
a554 1
    if (go->neg_upap && !uselogin && !have_upap_secret())
a603 1

d605 1
a605 1
     * Open the file of upap secrets and scan for a suitable secret
d817 2
a818 1
    if ((pw = getpwnam(user)) == NULL) {
d823 8
a830 3
    if ((spwd = getspnam(user)) == NULL) {   
        pw->pw_passwd = "";
    } else {
d838 1
a838 22
    if (pw->pw_passwd == '\0') {
        return (UPAP_AUTHACK);
    }   
    
#ifdef HAS_SHADOW 
    if (pw->pw_passwd) {
        if (pw->pw_passwd[0] == '@@') {
            if (pw_auth (pw->pw_passwd+1, pw->pw_name, PW_PPP, NULL)) {
                return (UPAP_AUTHNAK);
            }
        } else {
            epasswd = pw_encrypt(passwd, pw->pw_passwd);
            if (strcmp(epasswd, pw->pw_passwd)) {
                return (UPAP_AUTHNAK);
            }
        }
        /* check the age of the password entry */
        if (spwd && (isexpired (pw, spwd) != 0)) {
            return (UPAP_AUTHNAK);
        }
    }
#else
d840 1
a840 1
    if (strcmp(epasswd, pw->pw_passwd)) {
d843 1
a843 1
#endif
d892 1
a892 1
     * Open the file of upap secrets and scan for a suitable secret.
d918 1
a918 1
 * get_upap_passwd - get a password for authenticating ourselves with
d923 2
a924 2
get_upap_passwd(passwd)
char *passwd;
d951 1
a951 1
 * have_upap_secret - check whether we have a PAP file with any
d955 1
a955 1
have_upap_secret()
d1062 1
d1085 2
a1086 3
    u_int32_t mask, ah;
    struct in_addr ina;
    int accept, r = 1;
d1128 1
a1128 1
	    ina.s_addr = *(u_int32_t *)hp->h_addr;
d1133 1
a1133 1
		ina.s_addr = htonl (*(u_int32_t *)np->n_net);
d1135 1
a1135 1
		r = inet_aton (ptr_word, &ina);
d1138 1
a1138 1
		ah = ntohl(ina.s_addr);
d1151 1
a1151 1
        if (r == 0)
d1156 1
a1156 1
	    if (((addr ^ ina.s_addr) & htonl(mask)) == 0)
@


1.4
log
@Update pppd to 2.3a4:
Add redo option error-reporting, add PAM, add microsoft compatibility
kludges, bzero stuff at important places, add one or two options
other generic enhancements.  From: Paul.Mackerras@@cs.anu.edu.au
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.3 1996/04/21 23:41:16 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.3 1996/04/21 23:41:16 deraadt Exp $";
d1071 3
a1073 2
    u_int32_t a, mask, ah;
    int accept;
d1115 1
a1115 1
	    a    = *(u_int32_t *)hp->h_addr;
d1120 1
a1120 1
		a = htonl (*(u_int32_t *)np->n_net);
d1122 1
a1122 1
		a = inet_addr (ptr_word);
d1125 1
a1125 1
		ah = ntohl(a);
d1138 1
a1138 1
        if (a == -1L)
d1143 1
a1143 1
	    if (((addr ^ a) & htonl(mask)) == 0)
@


1.3
log
@sync to netbsd 960418
@
text
@d1 1
a1 1
/*	$OpenBSD: auth.c,v 1.2 1996/03/25 15:55:30 niklas Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: auth.c,v 1.2 1996/03/25 15:55:30 niklas Exp $";
d56 5
d96 3
d105 3
d117 3
d133 1
a133 1
static int  get_upap_passwd __P((void));
d140 2
d179 4
d190 1
d247 5
d270 9
d281 1
d284 1
d312 1
a312 1
auth_peer_success(unit, protocol)
d314 2
d333 8
d355 3
d379 2
d466 1
d487 1
a487 1
    if (ao->neg_upap && passwd[0] == 0 && !get_upap_passwd())
d507 28
d573 2
d611 2
a612 1
	*msg = "Login incorrect";
d631 2
a632 1
	*msg = "Login ok";
d639 3
d645 74
d729 1
d737 44
d783 1
a783 2
    char *tty;

d788 1
a788 1

d790 5
a794 5
	return (UPAP_AUTHNAK);
    }

#ifdef HAS_SHADOW
    if ((spwd = getspnam(user)) == NULL) {
d797 1
a797 1
	pw->pw_passwd = spwd->sp_pwdp;
d800 1
a800 1

d805 19
a823 8
	return (UPAP_AUTHACK);
    }

#ifdef HAS_SHADOW
    if ((pw->pw_passwd && pw->pw_passwd[0] == '@@'
	 && pw_auth (pw->pw_passwd+1, pw->pw_name, PW_PPP, NULL))
	|| !valid (passwd, pw)) {
	return (UPAP_AUTHNAK);
d828 1
a828 1
	return (UPAP_AUTHNAK);
d831 1
d891 1
d910 2
a911 1
get_upap_passwd()
d924 3
a926 2
    if (scan_authfile(f, user, remote_name, (u_int32_t)0,
		      secret, NULL, filename) < 0)
d928 5
a932 2
    strncpy(passwd, secret, MAXSECRETLEN);
    passwd[MAXSECRETLEN-1] = 0;
d1137 1
a1137 1
	if (a == 0xffffffff)
d1348 34
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD$";
d169 1
a169 1
	    (*protp->close)(unit);
d913 1
a913 1
	if (a == -1L)
@


1.1
log
@Initial revision
@
text
@d1 2
d38 1
a38 1
static char rcsid[] = "$Id: auth.c,v 1.10 1995/08/17 12:03:51 paulus Exp $";
d44 1
d50 1
d67 1
a69 2
#include "ipcp.h"
#include "ccp.h"
d93 2
d96 2
d100 6
d112 1
a112 2
/* Prototypes */
void check_access __P((FILE *, char *));
d115 1
d121 4
a124 3
static int  have_chap_secret __P((char *, char *));
static int  scan_authfile __P((FILE *, char *, char *, char *,
				  struct wordlist **, char *));
a126 2
extern char *crypt __P((char *, char *));

d160 13
a172 2
    ipcp_close(0);
    ccp_close(0);
d188 10
d207 1
a207 1
	    lcp_close(unit);
d242 3
d246 9
a254 2
    ipcp_open(unit);
    ccp_open(unit);
d267 1
a267 1
    lcp_close(unit);
d297 2
a298 5
    if ((auth_pending[unit] &= ~bit) == 0) {
	phase = PHASE_NETWORK;
	ipcp_open(unit);
	ccp_open(unit);
    }
d347 26
a372 1
 * check_auth_options - called to check authentication options.
d375 37
a411 1
check_auth_options()
d415 2
d438 1
a438 1
    if (ao->neg_chap && !have_chap_secret(our_name, remote_name))
d440 5
a444 2
    if (wo->neg_chap && !have_chap_secret(remote_name, our_name))
	wo->neg_chap = 0;
d448 1
a448 1
pppd: peer authentication required but no authentication files accessible\n");
d479 2
d503 1
a503 1
	    syslog(LOG_ERR, "Can't open upap password file %s: %m", filename);
d509 3
a511 1
	if (scan_authfile(f, user, our_name, secret, &addrs, filename) < 0
d514 1
a514 1
	    syslog(LOG_WARNING, "upap authentication failure for %s", user);
d523 1
a523 1
	    syslog(LOG_WARNING, "upap login failure for %s", user);
d623 1
a623 1
    logwtmp(tty, user, "");		/* Add wtmp login entry */
d671 1
a671 1
    i = scan_authfile(f, "", our_name, secret, &addrs, filename);
d704 2
a705 1
    if (scan_authfile(f, user, remote_name, secret, NULL, filename) < 0)
d723 2
d731 2
a732 1
    ret = scan_authfile(f, NULL, our_name, NULL, NULL, filename);
d748 1
a748 1
have_chap_secret(client, server)
d751 1
d767 1
a767 1
    ret = scan_authfile(f, client, server, NULL, NULL, filename);
d807 2
a808 1
    ret = scan_authfile(f, client, server, secbuf, &addrs, filename);
d839 11
a849 1
    u_int32_t a;
d851 1
a851 1
    struct wordlist *addrs;
d857 1
a857 1
    if ((addrs = addresses[unit]) == NULL)
d862 2
a863 1
	if (strcmp(addrs->word, "-") == 0)
d865 17
a881 4
	if ((a = inet_addr(addrs->word)) == -1) {
	    if ((hp = gethostbyname(addrs->word)) == NULL) {
		syslog(LOG_WARNING, "unknown host %s in auth. address list",
		       addrs->word);
d883 3
a885 2
	    } else
		a = *(u_int32_t *)hp->h_addr;
d887 33
a919 2
	if (addr == a)
	    return 1;
d966 1
a966 1
scan_authfile(f, client, server, secret, addrs, filename)
d970 1
d978 1
a978 1
    struct wordlist *ap, *addr_list, *addr_last;
d981 1
d1057 1
a1057 3
	    strcpy(secret, word);
		
	best_flag = got_flag;
d1062 1
a1062 3
	if (addr_list)
	    free_wordlist(addr_list);
	addr_list = addr_last = NULL;
d1072 2
a1073 2
	    if (addr_list == NULL)
		addr_list = ap;
d1075 10
a1084 2
		addr_last->next = ap;
	    addr_last = ap;
d1086 11
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
