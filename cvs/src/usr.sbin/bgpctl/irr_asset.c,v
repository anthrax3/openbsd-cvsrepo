head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.14
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.12
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.8
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.18
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.16
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.14
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.12
	OPENBSD_5_0:1.8.0.10
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.8
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.6
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.8
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.6
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6;
locks; strict;
comment	@ * @;


1.11
date	2015.01.16.06.40.15;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	Uu5nFG3wCl0LACBb;

1.10
date	2014.10.08.16.15.37;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	8hXaK4f2GeAALziF;

1.9
date	2013.11.22.15.15.16;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.14.21.10.54;	author jj;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.31.12.46.55;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.06.16.45.34;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.05.21.08.22;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.05.19.30.46;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.05.15.02.05;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.03.15.26.46;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.03.11.45.30;	author henning;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: irr_asset.c,v 1.10 2014/10/08 16:15:37 deraadt Exp $ */

/*
 * Copyright (c) 2007 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>

#include "irrfilter.h"

int		 as_set_compare(struct as_set *, struct as_set *);
struct as_set	*as_set_find(char *);

RB_HEAD(as_set_h, as_set)	as_set_h;
RB_PROTOTYPE(as_set_h, as_set, entry, as_set_compare)
RB_GENERATE(as_set_h, as_set, entry, as_set_compare)

enum obj_type {
	T_UNKNOWN,
	T_ASSET,
	T_AUTNUM
};

struct as_set	*curass;

struct as_set	*asset_get(char *);
enum obj_type	 asset_membertype(char *);
void		 asset_resolve(struct as_set *);
int		 asset_merge(struct as_set *, struct as_set *);
int		 asset_add_as(struct as_set *, char *);
int		 asset_add_asset(struct as_set *, char *);

struct as_set *
asset_expand(char *s)
{
	struct as_set	*ass;
	char		*name;
	size_t		 i;

	if ((name = calloc(1, strlen(s) + 1)) == NULL)
		err(1, "asset_expand calloc");
	for (i = 0; i < strlen(s); i++)
		name[i] = toupper((unsigned char)s[i]);

	ass = asset_get(name);
	asset_resolve(ass);

	free(name);
	return (ass);
}

struct as_set *
asset_get(char *name)
{
	struct as_set	*ass, *mas;
	u_int		 i;

	/*
	 * the caching prevents the endless recursion.
	 * MUST have the RB_INSERT before calling self again.
	 */

	/* cached? then things are easy */
	if ((ass = as_set_find(name)) != NULL)
		return ass;

	if ((ass = calloc(1, sizeof(*ass))) == NULL)
		err(1, "expand_as_set calloc");
	if ((ass->name = strdup(name)) == NULL)
		err(1, "expand_as_set strdup");
	RB_INSERT(as_set_h, &as_set_h, ass);

	switch (asset_membertype(name)) {
	case T_ASSET:
		/* as-set */
		if (irrverbose >= 3) {
			fprintf(stdout, "query AS-SET %s... ", name);
			fflush(stdout);
		}
		curass = ass;
		if (whois(name, QTYPE_ASSET) == -1)
			errx(1, "whois error, asset_get %s", name);
		curass = NULL;
		if (irrverbose >= 3)
			fprintf(stdout, "done\n");
		break;
	case T_AUTNUM:
		/*
		 * make a dummy as-set with the AS both as name
		 * and its only member
		 */
		asset_add_as(ass, name);
		return (ass);
	default:
		fprintf(stderr, "asset_get: %s: unknown object type\n", name);
		break;
	}


	for (i = 0; i < ass->n_members; i++) {
		mas = asset_get(ass->members[i]);
		if (mas->n_members == 0 && mas->n_as == 0)
			fprintf(stderr, "%s: can't resolve member %s\n",
			    name, ass->members[i]);
		else
			asset_add_asset(ass, ass->members[i]);
	}

	return (ass);
}

enum obj_type
asset_membertype(char *name)
{
	char	*s;

	if (!strncmp(name, "AS-", 3))
		return (T_ASSET);

	if ((s = strchr(name, ':')) != NULL) {
		/* this must be an as-set. one component has to start w/ AS- */
		for (s = name; s != NULL; s = strchr(s, ':'))
			if (!strncmp(++s, "AS-", 3))
				return (T_ASSET);
		return (T_UNKNOWN);
	}

	/* neither plain nor hierachical set definition, might be aut-num */
	if (!strncmp(name, "AS", 2) && strlen(name) > 2 &&
	    isdigit((unsigned char)name[2]))
		return (T_AUTNUM);

	return (T_UNKNOWN);
}

void
asset_resolve(struct as_set *ass)
{
	struct as_set	*mas;
	u_int		 i;

	/*
	 * traverse all as_set members and fold their
	 * members as into this as_set.
	 * ass->n_as_set is a moving target, it grows
	 * as member as-sets' member as-sets are beeing
	 * added.
	 * remove processed member as-sets (all!) only
	 * after we are done, they're needed for dupe
	 * detection
	 */

	for (i = 0; i < ass->n_as_set; i++) {
		if ((mas = as_set_find(ass->as_set[i])) == NULL)
			errx(1, "asset_get %s: %s unresolved?!?",
			    ass->name, ass->as_set[i]);
		if (asset_merge(ass, mas) == -1)
			errx(1, "asset_merge failed");
	}

	for (i = 0; i < ass->n_as_set; i++) {
		free(ass->as_set[i]);
		ass->as_set[i] = NULL;
	}
	free(ass->as_set);
	ass->as_set = NULL;
	ass->n_as_set = 0;
}

int
asset_merge(struct as_set *ass, struct as_set *mas)
{
	u_int	i, j;

	/* merge ASes from the member into the parent */
	for (i = 0; i < mas->n_as; i++) {
		for (j = 0; j < ass->n_as && strcmp(ass->as[j],
		    mas->as[i]); j++)
			; /* nothing */
		if (j == ass->n_as)
			if (asset_add_as(ass, mas->as[i]) == -1)
				return (-1);
	}

	/* merge as-set members from the member into the parent */
	for (i = 0; i < mas->n_as_set; i++) {
		if (!strcmp(ass->name, mas->as_set[i]))		/* skip self! */
			continue;
		for (j = 0; j < ass->n_as_set && strcmp(ass->as_set[j],
		    mas->as_set[i]); j++)
			; /* nothing */
		if (j == ass->n_as_set)
			if (asset_add_asset(ass, mas->as_set[i]) == -1)
				return (-1);
	}

	return (0);
}

int
asset_addmember(char *s)
{
	void	*p;
	char	*as;
	size_t	 i;

	/* convert to uppercase on the fly */
	if ((as = calloc(1, strlen(s) + 1)) == NULL)
		err(1, "asset_addmember strdup");
	for (i = 0; i < strlen(s); i++)
		as[i] = toupper((unsigned char)s[i]);

	if ((p = reallocarray(curass->members,
	    curass->n_members + 1, sizeof(char *))) == NULL)
		err(1, "asset_addmember strdup");
	curass->members = p;
	curass->n_members++;
	curass->members[curass->n_members - 1] = as;

	return (0);
}

int
asset_add_as(struct as_set *ass, char *s)
{
	void *p;

	if ((p = reallocarray(ass->as,
	    ass->n_as + 1, sizeof(char *))) == NULL)
		err(1, "asset_add_as strdup");
	ass->as = p;
	ass->n_as++;

	if ((ass->as[ass->n_as - 1] =
	    strdup(s)) == NULL)
		err(1, "asset_add_as strdup");

	return (0);
}

int
asset_add_asset(struct as_set *ass, char *s)
{
	void *p;

	if ((p = reallocarray(ass->as_set,
	    ass->n_as_set + 1, sizeof(char *))) == NULL)
		err(1, "asset_add_asset strdup");
	ass->as_set = p;
	ass->n_as_set++;

	if ((ass->as_set[ass->n_as_set - 1] =
	    strdup(s)) == NULL)
		err(1, "asset_add_asset strdup");

	return (0);
}

/* RB helpers */
int
as_set_compare(struct as_set *a, struct as_set *b)
{
	return (strcmp(a->name, b->name));
}

struct as_set *
as_set_find(char *name)
{
	struct as_set	s;

	s.name = name;
	return (RB_FIND(as_set_h, &as_set_h, &s));
}
@


1.10
log
@Use reallocarray() throughout to spot multiplicative int overflow.
ok henning benno
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_asset.c,v 1.9 2013/11/22 15:15:16 deraadt Exp $ */
a19 1
#include <sys/param.h>
@


1.9
log
@unsigned char casts where needed for for ctype.h
checked by florian
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_asset.c,v 1.8 2009/04/14 21:10:54 jj Exp $ */
d232 2
a233 2
	if ((p = realloc(curass->members,
	    (curass->n_members + 1) * sizeof(char *))) == NULL)
d247 2
a248 2
	if ((p = realloc(ass->as,
	    (ass->n_as + 1) * sizeof(char *))) == NULL)
d265 2
a266 2
	if ((p = realloc(ass->as_set,
	    (ass->n_as_set + 1) * sizeof(char *))) == NULL)
@


1.8
log
@Fixed a few the-the misspellings in comments. Skipped a bunch in binutils,gcc and so on. ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_asset.c,v 1.7 2007/03/31 12:46:55 henning Exp $ */
d62 1
a62 1
		name[i] = toupper(s[i]);
d148 2
a149 1
	if (!strncmp(name, "AS", 2) && strlen(name) > 2 && isdigit(name[2]))
d230 1
a230 1
		as[i] = toupper(s[i]);
@


1.7
log
@some KNF, partially pt out by  rivo nurges <rix@@estpak.ee>
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_asset.c,v 1.6 2007/03/06 16:45:34 henning Exp $ */
d108 1
a108 1
		 * make a dummy as-set with the the AS both as name
@


1.6
log
@prepare, but leave disabled, verbose operation so that you can see what is
going on (helps when the damn thing runs for hours). will be enabled with
a -v somewhen in the future
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_asset.c,v 1.5 2007/03/05 21:08:22 henning Exp $ */
a151 1
	
@


1.5
log
@correctly deal with hierarchical as-set names.
everything we run into as members that is hierarchical (contains :) has to
be an as-set. RPSL requires one component to have the AS- prefix; we check
that.
now the huge AS-TELIANET correctly resolves - into 15128 unique ASes, takes
12m47.11s real     0m8.62s user     0m1.07s system
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_asset.c,v 1.4 2007/03/05 19:30:46 henning Exp $ */
d95 4
d103 2
@


1.4
log
@convert all members of an as-set to uppercase on the fly.
do the same in asset_expand() for the head as-set or aut-num reference from
the policy.
fixes duplicate ASes with mixed case seen after set resolution and saves
some str(n)casecmp on the way (or rather allows a whole bunch of strcmp to
stay)
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_asset.c,v 1.3 2007/03/05 15:02:05 henning Exp $ */
d37 6
d46 1
d92 10
a101 4
	if (!strncmp(name, "AS", 2) &&
	    strlen(name) > 2 && isdigit(name[2])) {
		/* 
		 * this must be an aut-num
d107 4
a111 8
	} else if (!strncmp(name, "AS-", 3)) {
		/* as-set */
		curass = ass;
		if (whois(name, QTYPE_ASSET) == -1)
			errx(1, "whois error, asset_get %s", name);
		curass = NULL;
	} else
		fprintf(stderr, "asset_get: %s: unknown object type\n", name);
d123 24
@


1.3
log
@unused vars, lint
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_asset.c,v 1.2 2007/03/03 15:26:46 henning Exp $ */
d46 1
a46 1
asset_expand(char *name)
d49 7
d60 1
d85 1
a85 1
	if (!strncasecmp(name, "AS", 2) &&
d95 1
a95 1
	} else if (!strncasecmp(name, "AS-", 3)) {
d183 9
a191 1
	void *p;
d198 1
a198 4

	if ((curass->members[curass->n_members - 1] =
	    strdup(s)) == NULL)
		err(1, "asset_addmember strdup");
@


1.2
log
@as-sets always begin with AS-, and aut-nums with AS[0-9], mandated by the
RPSL spec and enforced by the IRR databases.
teach asset_get this fact. only send queries for the as-set members for
as-sets.
since we now always fake an as-set for aut-nums, we don't need to
escape the recursive as-set resolution process when we run into aut-num
members.
complain about and then ignore unresolvable as-set members.
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_asset.c,v 1.1 2007/03/03 11:45:30 henning Exp $ */
a60 2
	int		 r;

d90 1
a90 1
		if ((r = whois(name, QTYPE_ASSET)) == -1)
@


1.1
log
@add irrfilter mode.
generates bgpd filter rules from the Internet Routing Registry aka IRR aka
the aut-num, as-set and route objects in the RIPE, ARIN, APNIC ... databases
accessed via whois, using the Routing Policy Specificaion Language RPSL.
implement the whois query interface, an RPSL parser (of course only the
parts we need), recursive as-set resolver, prefixes per AS lookup,
and an ouput module to make up the rules.
work in progress, not ready for general consumption yet.
import agreed by theo & claudio
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d26 1
d79 9
a87 4
	curass = ass;
	if ((r = whois(name, QTYPE_ASSET)) == -1)
		errx(1, "whois error, asset_get %s", name);
	curass = NULL;
d89 8
a96 7
	/*
	 * if there are no members, this is an aut-num.
	 * if thsi was specified directly in the policy,
	 * make a dummy as-set with the the AS as name
	 * and its only member */
	if (ass->n_members == 0)
		asset_add_as(ass, name);
d100 3
a102 2
		if (mas->n_members == 0)
			asset_add_as(ass, ass->members[i]);
@

