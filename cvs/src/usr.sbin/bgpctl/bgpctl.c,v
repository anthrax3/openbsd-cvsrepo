head	1.193;
access;
symbols
	OPENBSD_6_1_BASE:1.193
	OPENBSD_6_0:1.188.0.2
	OPENBSD_6_0_BASE:1.188
	OPENBSD_5_9:1.187.0.2
	OPENBSD_5_9_BASE:1.187
	OPENBSD_5_8:1.180.0.4
	OPENBSD_5_8_BASE:1.180
	OPENBSD_5_7:1.177.0.2
	OPENBSD_5_7_BASE:1.177
	OPENBSD_5_6:1.174.0.4
	OPENBSD_5_6_BASE:1.174
	OPENBSD_5_5:1.173.0.4
	OPENBSD_5_5_BASE:1.173
	OPENBSD_5_4:1.170.0.2
	OPENBSD_5_4_BASE:1.170
	OPENBSD_5_3:1.168.0.2
	OPENBSD_5_3_BASE:1.168
	OPENBSD_5_2:1.164.0.2
	OPENBSD_5_2_BASE:1.164
	OPENBSD_5_1_BASE:1.163
	OPENBSD_5_1:1.163.0.2
	OPENBSD_5_0:1.161.0.4
	OPENBSD_5_0_BASE:1.161
	OPENBSD_4_9:1.161.0.2
	OPENBSD_4_9_BASE:1.161
	OPENBSD_4_8:1.160.0.2
	OPENBSD_4_8_BASE:1.160
	OPENBSD_4_7:1.157.0.2
	OPENBSD_4_7_BASE:1.157
	OPENBSD_4_6:1.142.0.4
	OPENBSD_4_6_BASE:1.142
	OPENBSD_4_5:1.138.0.2
	OPENBSD_4_5_BASE:1.138
	OPENBSD_4_4:1.134.0.2
	OPENBSD_4_4_BASE:1.134
	OPENBSD_4_3:1.132.0.2
	OPENBSD_4_3_BASE:1.132
	OPENBSD_4_2:1.126.0.2
	OPENBSD_4_2_BASE:1.126
	OPENBSD_4_1:1.117.0.2
	OPENBSD_4_1_BASE:1.117
	OPENBSD_4_0:1.110.0.2
	OPENBSD_4_0_BASE:1.110
	OPENBSD_3_9:1.100.0.2
	OPENBSD_3_9_BASE:1.100
	OPENBSD_3_8:1.88.0.2
	OPENBSD_3_8_BASE:1.88
	OPENBSD_3_7:1.76.0.2
	OPENBSD_3_7_BASE:1.76
	OPENBSD_3_6:1.61.0.2
	OPENBSD_3_6_BASE:1.61
	OPENBSD_3_5:1.48.0.2
	OPENBSD_3_5_BASE:1.48;
locks; strict;
comment	@ * @;


1.193
date	2017.01.23.23.38.51;	author claudio;	state Exp;
branches;
next	1.192;
commitid	NNd2kg4EXqhz6Wty;

1.192
date	2017.01.23.23.35.42;	author benno;	state Exp;
branches;
next	1.191;
commitid	cxk8fdSAwAQJMAxb;

1.191
date	2017.01.13.18.59.12;	author phessler;	state Exp;
branches;
next	1.190;
commitid	3Jvf15B19ysa8i2W;

1.190
date	2016.10.14.16.05.35;	author phessler;	state Exp;
branches;
next	1.189;
commitid	Ai7XVOgXw9ZLovz1;

1.189
date	2016.10.14.09.40.54;	author phessler;	state Exp;
branches;
next	1.188;
commitid	KNxXpJ0LyaMRrOPv;

1.188
date	2016.06.03.17.36.37;	author benno;	state Exp;
branches;
next	1.187;
commitid	utIafqBHH3dRVCSC;

1.187
date	2015.12.05.13.17.05;	author claudio;	state Exp;
branches;
next	1.186;
commitid	P5J7weK3n4eQp4i6;

1.186
date	2015.11.01.21.20.46;	author benno;	state Exp;
branches;
next	1.185;
commitid	5lBVBpOEjTnCW5Y5;

1.185
date	2015.10.24.11.54.50;	author claudio;	state Exp;
branches;
next	1.184;
commitid	wU7VZinVexd3bJ0P;

1.184
date	2015.10.24.11.41.03;	author claudio;	state Exp;
branches;
next	1.183;
commitid	7oZ9btcdmbz0DTwg;

1.183
date	2015.10.11.19.53.57;	author sthen;	state Exp;
branches;
next	1.182;
commitid	23dXwNO8fbGA7yVS;

1.182
date	2015.09.16.20.25.41;	author stsp;	state Exp;
branches;
next	1.181;
commitid	DdIYNjrFkyhcmdeI;

1.181
date	2015.09.13.11.13.12;	author deraadt;	state Exp;
branches;
next	1.180;
commitid	HmZqjbpn4mjxGSj3;

1.180
date	2015.07.19.06.57.27;	author guenther;	state Exp;
branches;
next	1.179;
commitid	mtpMduVQYjOlLkZB;

1.179
date	2015.07.18.16.12.03;	author claudio;	state Exp;
branches;
next	1.178;
commitid	VIFjsS517JGMvs2e;

1.178
date	2015.04.17.07.51.09;	author phessler;	state Exp;
branches;
next	1.177;
commitid	FgmHx68AdtL9Wg33;

1.177
date	2015.02.11.23.47.25;	author phessler;	state Exp;
branches;
next	1.176;
commitid	aRokbG5fZmlXavYN;

1.176
date	2015.02.04.23.30.37;	author henning;	state Exp;
branches;
next	1.175;
commitid	J8skOrXb4sbmDKoK;

1.175
date	2014.10.02.16.37.50;	author benno;	state Exp;
branches;
next	1.174;
commitid	fXKaJsuYNZpplI9e;

1.174
date	2014.03.18.13.47.14;	author florian;	state Exp;
branches;
next	1.173;

1.173
date	2013.11.13.22.52.41;	author sthen;	state Exp;
branches;
next	1.172;

1.172
date	2013.10.09.08.56.38;	author phessler;	state Exp;
branches;
next	1.171;

1.171
date	2013.08.18.16.32.24;	author guenther;	state Exp;
branches;
next	1.170;

1.170
date	2013.04.09.14.51.33;	author gilles;	state Exp;
branches;
next	1.169;

1.169
date	2013.03.07.21.28.34;	author claudio;	state Exp;
branches;
next	1.168;

1.168
date	2012.11.27.05.38.08;	author guenther;	state Exp;
branches;
next	1.167;

1.167
date	2012.11.15.19.55.08;	author sthen;	state Exp;
branches;
next	1.166;

1.166
date	2012.09.18.10.11.23;	author claudio;	state Exp;
branches;
next	1.165;

1.165
date	2012.09.12.05.57.10;	author claudio;	state Exp;
branches;
next	1.164;

1.164
date	2012.05.27.18.53.50;	author claudio;	state Exp;
branches;
next	1.163;

1.163
date	2011.09.21.10.37.51;	author claudio;	state Exp;
branches;
next	1.162;

1.162
date	2011.09.21.08.52.55;	author claudio;	state Exp;
branches;
next	1.161;

1.161
date	2010.09.02.14.03.21;	author sobrado;	state Exp;
branches;
next	1.160;

1.160
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.159;

1.159
date	2010.05.03.13.11.41;	author claudio;	state Exp;
branches;
next	1.158;

1.158
date	2010.04.13.09.10.50;	author claudio;	state Exp;
branches;
next	1.157;

1.157
date	2010.03.08.17.02.19;	author claudio;	state Exp;
branches;
next	1.156;

1.156
date	2010.02.11.12.25.12;	author claudio;	state Exp;
branches;
next	1.155;

1.155
date	2010.01.10.00.16.23;	author claudio;	state Exp;
branches;
next	1.154;

1.154
date	2009.12.16.15.42.19;	author claudio;	state Exp;
branches;
next	1.153;

1.153
date	2009.12.08.17.36.12;	author claudio;	state Exp;
branches;
next	1.152;

1.152
date	2009.12.08.15.10.29;	author claudio;	state Exp;
branches;
next	1.151;

1.151
date	2009.12.08.14.04.54;	author claudio;	state Exp;
branches;
next	1.150;

1.150
date	2009.12.01.14.29.40;	author claudio;	state Exp;
branches;
next	1.149;

1.149
date	2009.11.02.20.38.45;	author claudio;	state Exp;
branches;
next	1.148;

1.148
date	2009.10.23.16.00.28;	author claudio;	state Exp;
branches;
next	1.147;

1.147
date	2009.09.15.09.45.12;	author sthen;	state Exp;
branches;
next	1.146;

1.146
date	2009.09.14.11.49.25;	author claudio;	state Exp;
branches;
next	1.145;

1.145
date	2009.07.23.14.55.25;	author claudio;	state Exp;
branches;
next	1.144;

1.144
date	2009.07.21.11.49.36;	author henning;	state Exp;
branches;
next	1.143;

1.143
date	2009.07.20.15.04.50;	author claudio;	state Exp;
branches;
next	1.142;

1.142
date	2009.06.06.06.33.15;	author eric;	state Exp;
branches;
next	1.141;

1.141
date	2009.06.06.06.05.41;	author claudio;	state Exp;
branches;
next	1.140;

1.140
date	2009.05.17.13.23.08;	author claudio;	state Exp;
branches;
next	1.139;

1.139
date	2009.05.17.12.27.16;	author claudio;	state Exp;
branches;
next	1.138;

1.138
date	2009.02.01.17.21.21;	author sobrado;	state Exp;
branches;
next	1.137;

1.137
date	2008.12.12.23.15.39;	author claudio;	state Exp;
branches;
next	1.136;

1.136
date	2008.12.10.23.57.10;	author sthen;	state Exp;
branches;
next	1.135;

1.135
date	2008.12.06.13.18.12;	author sobrado;	state Exp;
branches;
next	1.134;

1.134
date	2008.06.07.20.23.15;	author henning;	state Exp;
branches;
next	1.133;

1.133
date	2008.06.07.18.14.41;	author henning;	state Exp;
branches;
next	1.132;

1.132
date	2008.02.24.21.02.11;	author claudio;	state Exp;
branches;
next	1.131;

1.131
date	2008.01.23.08.18.11;	author claudio;	state Exp;
branches;
next	1.130;

1.130
date	2007.12.23.18.26.13;	author henning;	state Exp;
branches;
next	1.129;

1.129
date	2007.12.20.17.08.48;	author henning;	state Exp;
branches;
next	1.128;

1.128
date	2007.10.15.02.16.35;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	2007.09.11.17.08.49;	author henning;	state Exp;
branches;
next	1.126;

1.126
date	2007.08.06.19.16.06;	author sobrado;	state Exp;
branches;
next	1.125;

1.125
date	2007.05.31.04.21.43;	author claudio;	state Exp;
branches;
next	1.124;

1.124
date	2007.05.30.01.13.19;	author otto;	state Exp;
branches;
next	1.123;

1.123
date	2007.04.23.13.05.35;	author claudio;	state Exp;
branches;
next	1.122;

1.122
date	2007.04.06.18.36.32;	author claudio;	state Exp;
branches;
next	1.121;

1.121
date	2007.04.06.18.14.48;	author claudio;	state Exp;
branches;
next	1.120;

1.120
date	2007.03.31.12.46.55;	author henning;	state Exp;
branches;
next	1.119;

1.119
date	2007.03.28.12.34.08;	author henning;	state Exp;
branches;
next	1.118;

1.118
date	2007.03.16.20.48.38;	author claudio;	state Exp;
branches;
next	1.117;

1.117
date	2007.03.03.12.43.08;	author henning;	state Exp;
branches;
next	1.116;

1.116
date	2007.03.03.11.45.30;	author henning;	state Exp;
branches;
next	1.115;

1.115
date	2007.02.22.08.38.19;	author henning;	state Exp;
branches;
next	1.114;

1.114
date	2007.02.02.15.53.39;	author claudio;	state Exp;
branches;
next	1.113;

1.113
date	2007.01.27.19.03.07;	author claudio;	state Exp;
branches;
next	1.112;

1.112
date	2006.11.28.19.21.15;	author reyk;	state Exp;
branches;
next	1.111;

1.111
date	2006.11.10.14.46.46;	author henning;	state Exp;
branches;
next	1.110;

1.110
date	2006.08.28.05.28.49;	author henning;	state Exp;
branches;
next	1.109;

1.109
date	2006.08.23.08.21.11;	author claudio;	state Exp;
branches;
next	1.108;

1.108
date	2006.07.25.09.38.05;	author henning;	state Exp;
branches;
next	1.107;

1.107
date	2006.06.15.10.05.18;	author claudio;	state Exp;
branches;
next	1.106;

1.106
date	2006.06.14.17.10.42;	author claudio;	state Exp;
branches;
next	1.105;

1.105
date	2006.05.27.21.25.06;	author claudio;	state Exp;
branches;
next	1.104;

1.104
date	2006.05.23.12.14.34;	author henning;	state Exp;
branches;
next	1.103;

1.103
date	2006.04.06.12.33.17;	author claudio;	state Exp;
branches;
next	1.102;

1.102
date	2006.03.22.10.25.49;	author claudio;	state Exp;
branches;
next	1.101;

1.101
date	2006.03.22.09.05.40;	author claudio;	state Exp;
branches;
next	1.100;

1.100
date	2006.01.24.15.28.03;	author henning;	state Exp;
branches;
next	1.99;

1.99
date	2006.01.24.10.01.14;	author henning;	state Exp;
branches;
next	1.98;

1.98
date	2006.01.05.16.01.09;	author claudio;	state Exp;
branches;
next	1.97;

1.97
date	2006.01.04.12.46.52;	author claudio;	state Exp;
branches;
next	1.96;

1.96
date	2006.01.03.22.51.14;	author claudio;	state Exp;
branches;
next	1.95;

1.95
date	2006.01.03.22.20.59;	author claudio;	state Exp;
branches;
next	1.94;

1.94
date	2006.01.03.22.05.13;	author claudio;	state Exp;
branches;
next	1.93;

1.93
date	2005.11.17.11.14.51;	author henning;	state Exp;
branches;
next	1.92;

1.92
date	2005.10.19.12.32.17;	author henning;	state Exp;
branches;
next	1.91;

1.91
date	2005.09.20.14.40.32;	author henning;	state Exp;
branches;
next	1.90;

1.90
date	2005.09.20.13.51.05;	author henning;	state Exp;
branches;
next	1.89;

1.89
date	2005.09.20.13.31.53;	author henning;	state Exp;
branches;
next	1.88;

1.88
date	2005.07.01.18.59.14;	author fgsch;	state Exp;
branches;
next	1.87;

1.87
date	2005.06.13.08.16.30;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2005.06.10.08.30.38;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2005.06.07.17.45.28;	author claudio;	state Exp;
branches;
next	1.84;

1.84
date	2005.06.06.17.15.07;	author henning;	state Exp;
branches;
next	1.83;

1.83
date	2005.06.06.00.00.33;	author henning;	state Exp;
branches;
next	1.82;

1.82
date	2005.06.05.00.24.18;	author henning;	state Exp;
branches;
next	1.81;

1.81
date	2005.06.04.23.38.07;	author henning;	state Exp;
branches;
next	1.80;

1.80
date	2005.05.27.17.10.29;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2005.05.23.20.08.59;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2005.04.18.11.09.51;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2005.04.13.08.35.22;	author claudio;	state Exp;
branches;
next	1.76;

1.76
date	2005.03.14.12.36.27;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2005.03.14.12.26.37;	author henning;	state Exp;
branches;
next	1.74;

1.74
date	2005.02.09.12.35.20;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2005.02.02.18.52.32;	author henning;	state Exp;
branches;
next	1.72;

1.72
date	2004.12.23.17.55.59;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2004.12.23.17.26.51;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2004.11.18.16.57.28;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2004.11.02.11.46.17;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2004.10.26.13.12.22;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2004.10.26.11.46.08;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2004.10.26.11.44.06;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2004.09.23.02.05.29;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2004.09.21.18.29.47;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2004.09.16.22.36.18;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2004.09.16.17.40.10;	author henning;	state Exp;
branches;
next	1.61;

1.61
date	2004.08.20.15.49.35;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2004.08.06.11.53.12;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2004.05.21.11.52.32;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2004.05.20.12.17.04;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2004.05.06.14.29.12;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2004.05.01.17.08.04;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2004.04.28.00.56.49;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2004.04.27.04.06.10;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2004.04.25.23.31.16;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2004.04.25.20.04.37;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2004.04.25.18.53.09;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2004.04.16.04.41.49;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2004.04.13.22.55.01;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.11.18.56.34;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.11.16.39.34;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.11.15.08.46;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.11.14.49.08;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.02.20.00.14;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.02.19.32.43;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.26.16.19.58;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.24.13.12.24;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2004.01.29.12.02.13;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.27.22.11.23;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.27.21.56.47;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.27.21.26.52;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.27.16.50.20;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.22.03.09.29;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.21.23.47.35;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.21.23.45.18;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.20.13.11.39;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.20.13.03.39;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.20.12.50.52;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2004.01.19.10.41.34;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.17.18.27.37;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.17.18.06.04;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.11.02.36.48;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.11.01.05.16;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.10.21.04.37;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.09.19.09.45;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.09.13.48.10;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.07.02.00.05;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.06.23.23.49;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.06.19.24.37;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.06.18.01.48;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.05.16.29.20;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.04.23.44.17;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.04.21.45.05;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.04.20.21.56;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.04.20.07.30;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.04.19.44.27;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.04.18.51.23;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.04.17.55.19;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.04.02.51.24;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.04.02.13.52;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.03.22.27.06;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.03.20.39.51;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.03.16.46.08;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.03.16.13.49;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.03.14.06.42;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.03.13.55.18;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.02.02.22.52;	author henning;	state Exp;
branches;
next	;


desc
@@


1.193
log
@Mission accomplished, bgpctl is now fatal free.
@
text
@/*	$OpenBSD: bgpctl.c,v 1.192 2017/01/23 23:35:42 benno Exp $ */

/*
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2016 Job Snijders <job@@instituut.net>
 * Copyright (c) 2016 Peter Hessler <phessler@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <net/if.h>
#include <net/if_media.h>
#include <net/if_types.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include "bgpd.h"
#include "session.h"
#include "rde.h"
#include "parser.h"
#include "irrfilter.h"
#include "mrtparser.h"

enum neighbor_views {
	NV_DEFAULT,
	NV_TIMERS
};

int		 main(int, char *[]);
char		*fmt_peer(const char *, const struct bgpd_addr *, int, int);
void		 show_summary_head(void);
int		 show_summary_msg(struct imsg *, int);
int		 show_summary_terse_msg(struct imsg *, int);
int		 show_neighbor_terse(struct imsg *);
int		 show_neighbor_msg(struct imsg *, enum neighbor_views);
void		 print_neighbor_capa_mp(struct peer *);
void		 print_neighbor_capa_restart(struct peer *);
void		 print_neighbor_msgstats(struct peer *);
void		 print_timer(const char *, time_t);
static char	*fmt_timeframe(time_t t);
static char	*fmt_timeframe_core(time_t t);
void		 show_fib_head(void);
void		 show_fib_tables_head(void);
void		 show_network_head(void);
void		 show_fib_flags(u_int16_t);
int		 show_fib_msg(struct imsg *);
void		 show_nexthop_head(void);
int		 show_nexthop_msg(struct imsg *);
void		 show_interface_head(void);
uint64_t	 ift2ifm(uint8_t);
const char *	 get_media_descr(uint64_t);
const char *	 get_linkstate(uint8_t, int);
const char *	 get_baudrate(u_int64_t, char *);
int		 show_interface_msg(struct imsg *);
void		 show_rib_summary_head(void);
void		 print_prefix(struct bgpd_addr *, u_int8_t, u_int8_t);
const char *	 print_origin(u_int8_t, int);
void		 print_flags(u_int8_t, int);
int		 show_rib_summary_msg(struct imsg *);
int		 show_rib_detail_msg(struct imsg *, int);
void		 show_rib_brief(struct ctl_show_rib *, u_char *);
void		 show_rib_detail(struct ctl_show_rib *, u_char *, int);
void		 show_attr(void *, u_int16_t);
void		 show_community(u_char *, u_int16_t);
void		 show_large_community(u_char *, u_int16_t);
void		 show_ext_community(u_char *, u_int16_t);
char		*fmt_mem(int64_t);
int		 show_rib_memory_msg(struct imsg *);
void		 send_filterset(struct imsgbuf *, struct filter_set_head *);
const char	*get_errstr(u_int8_t, u_int8_t);
int		 show_result(struct imsg *);
void		 show_mrt_dump(struct mrt_rib *, struct mrt_peer *, void *);
void		 network_mrt_dump(struct mrt_rib *, struct mrt_peer *, void *);
void		 show_mrt_state(struct mrt_bgp_state *, void *);
void		 show_mrt_msg(struct mrt_bgp_msg *, void *);
void		 mrt_to_bgpd_addr(union mrt_addr *, struct bgpd_addr *);
const char	*msg_type(u_int8_t);
void		 network_bulk(struct parse_result *);
const char	*print_auth_method(enum auth_method);

struct imsgbuf	*ibuf;
struct mrt_parser show_mrt = { show_mrt_dump, show_mrt_state, show_mrt_msg };
struct mrt_parser net_mrt = { network_mrt_dump, NULL, NULL };

__dead void
usage(void)
{
	extern char	*__progname;

	fprintf(stderr, "usage: %s [-n] [-s socket] command [argument ...]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct sockaddr_un	 sun;
	int			 fd, n, done, ch, nodescr = 0, verbose = 0;
	struct imsg		 imsg;
	struct network_config	 net;
	struct parse_result	*res;
	struct ctl_neighbor	 neighbor;
	struct ctl_show_rib_request	ribreq;
	char			*sockname;
	enum imsg_type		 type;

	if (pledge("stdio rpath wpath cpath unix inet dns", NULL) == -1)
		err(1, "pledge");

	sockname = SOCKET_NAME;
	while ((ch = getopt(argc, argv, "ns:")) != -1) {
		switch (ch) {
		case 'n':
			if (++nodescr > 1)
				usage();
			break;
		case 's':
			sockname = optarg;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;

	if ((res = parse(argc, argv)) == NULL)
		exit(1);

	if (res->action == IRRFILTER) {
		if (!(res->flags & (F_IPV4|F_IPV6)))
			res->flags |= (F_IPV4|F_IPV6);
		irr_main(res->as.as, res->flags, res->irr_outdir);
	}

	if (pledge("stdio rpath wpath unix", NULL) == -1)
		err(1, "pledge");

	memcpy(&neighbor.addr, &res->peeraddr, sizeof(neighbor.addr));
	strlcpy(neighbor.descr, res->peerdesc, sizeof(neighbor.descr));
	strlcpy(neighbor.shutcomm, res->shutcomm, sizeof(neighbor.shutcomm));

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "control_init: socket");

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, sockname, sizeof(sun.sun_path)) >=
	    sizeof(sun.sun_path))
		errx(1, "socket name too long");
	if (connect(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1)
		err(1, "connect: %s", sockname);

	if (pledge("stdio rpath wpath", NULL) == -1)
		err(1, "pledge");

	if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
		err(1, NULL);
	imsg_init(ibuf, fd);
	done = 0;

	switch (res->action) {
	case NONE:
	case IRRFILTER:
		usage();
		/* NOTREACHED */
	case SHOW:
	case SHOW_SUMMARY:
		imsg_compose(ibuf, IMSG_CTL_SHOW_NEIGHBOR, 0, 0, -1, NULL, 0);
		show_summary_head();
		break;
	case SHOW_SUMMARY_TERSE:
		imsg_compose(ibuf, IMSG_CTL_SHOW_TERSE, 0, 0, -1, NULL, 0);
		break;
	case SHOW_FIB:
		if (!res->addr.aid) {
			struct ibuf	*msg;
			sa_family_t	 af;

			af = aid2af(res->aid);
			if ((msg = imsg_create(ibuf, IMSG_CTL_KROUTE,
			    res->rtableid, 0, sizeof(res->flags) +
			    sizeof(af))) == NULL)
				errx(1, "imsg_create failure");
			if (imsg_add(msg, &res->flags, sizeof(res->flags)) ==
			    -1 ||
			    imsg_add(msg, &af, sizeof(af)) == -1)
				errx(1, "imsg_add failure");
			imsg_close(ibuf, msg);
		} else
			imsg_compose(ibuf, IMSG_CTL_KROUTE_ADDR, res->rtableid,
			    0, -1, &res->addr, sizeof(res->addr));
		show_fib_head();
		break;
	case SHOW_FIB_TABLES:
		imsg_compose(ibuf, IMSG_CTL_SHOW_FIB_TABLES, 0, 0, -1, NULL, 0);
		show_fib_tables_head();
		break;
	case SHOW_NEXTHOP:
		imsg_compose(ibuf, IMSG_CTL_SHOW_NEXTHOP, res->rtableid, 0, -1,
		    NULL, 0);
		show_nexthop_head();
		break;
	case SHOW_INTERFACE:
		imsg_compose(ibuf, IMSG_CTL_SHOW_INTERFACE, 0, 0, -1, NULL, 0);
		show_interface_head();
		break;
	case SHOW_NEIGHBOR:
	case SHOW_NEIGHBOR_TIMERS:
	case SHOW_NEIGHBOR_TERSE:
		neighbor.show_timers = (res->action == SHOW_NEIGHBOR_TIMERS);
		if (res->peeraddr.aid || res->peerdesc[0])
			imsg_compose(ibuf, IMSG_CTL_SHOW_NEIGHBOR, 0, 0, -1,
			    &neighbor, sizeof(neighbor));
		else
			imsg_compose(ibuf, IMSG_CTL_SHOW_NEIGHBOR, 0, 0, -1,
			    NULL, 0);
		break;
	case SHOW_RIB:
		bzero(&ribreq, sizeof(ribreq));
		type = IMSG_CTL_SHOW_RIB;
		if (res->as.type != AS_NONE) {
			memcpy(&ribreq.as, &res->as, sizeof(res->as));
			type = IMSG_CTL_SHOW_RIB_AS;
		}
		if (res->addr.aid) {
			memcpy(&ribreq.prefix, &res->addr, sizeof(res->addr));
			ribreq.prefixlen = res->prefixlen;
			type = IMSG_CTL_SHOW_RIB_PREFIX;
		}
		if (res->community.as != COMMUNITY_UNSET &&
		    res->community.type != COMMUNITY_UNSET) {
			memcpy(&ribreq.community, &res->community,
			    sizeof(res->community));
			type = IMSG_CTL_SHOW_RIB_COMMUNITY;
		}
		if (res->large_community.as != COMMUNITY_UNSET &&
		    res->large_community.ld1 != COMMUNITY_UNSET &&
		    res->large_community.ld2 != COMMUNITY_UNSET) {
			memcpy(&ribreq.large_community, &res->large_community,
			    sizeof(res->large_community));
			type = IMSG_CTL_SHOW_RIB_LARGECOMMUNITY;
		}
		memcpy(&ribreq.neighbor, &neighbor, sizeof(ribreq.neighbor));
		strlcpy(ribreq.rib, res->rib, sizeof(ribreq.rib));
		ribreq.aid = res->aid;
		ribreq.flags = res->flags;
		imsg_compose(ibuf, type, 0, 0, -1, &ribreq, sizeof(ribreq));
		if (!(res->flags & F_CTL_DETAIL))
			show_rib_summary_head();
		break;
	case SHOW_MRT:
		close(fd);
		bzero(&ribreq, sizeof(ribreq));
		if (res->as.type != AS_NONE)
			memcpy(&ribreq.as, &res->as, sizeof(res->as));
		if (res->addr.aid) {
			memcpy(&ribreq.prefix, &res->addr, sizeof(res->addr));
			ribreq.prefixlen = res->prefixlen;
		}
		if (res->community.as != COMMUNITY_UNSET &&
		    res->community.type != COMMUNITY_UNSET)
			memcpy(&ribreq.community, &res->community,
			    sizeof(res->community));
		if (res->large_community.as != COMMUNITY_UNSET &&
		    res->large_community.ld1 != COMMUNITY_UNSET &&
		    res->large_community.ld2 != COMMUNITY_UNSET)
			memcpy(&ribreq.large_community, &res->large_community,
			    sizeof(res->large_community));
		memcpy(&ribreq.neighbor, &neighbor, sizeof(ribreq.neighbor));
		ribreq.aid = res->aid;
		ribreq.flags = res->flags;
		show_mrt.arg = &ribreq;
		if (!(res->flags & F_CTL_DETAIL))
			show_rib_summary_head();
		mrt_parse(res->mrtfd, &show_mrt, 1);
		exit(0);
	case SHOW_RIB_MEM:
		imsg_compose(ibuf, IMSG_CTL_SHOW_RIB_MEM, 0, 0, -1, NULL, 0);
		break;
	case RELOAD:
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, -1, NULL, 0);
		printf("reload request sent.\n");
		break;
	case FIB:
		errx(1, "action==FIB");
		break;
	case FIB_COUPLE:
		imsg_compose(ibuf, IMSG_CTL_FIB_COUPLE, res->rtableid, 0, -1,
		    NULL, 0);
		printf("couple request sent.\n");
		done = 1;
		break;
	case FIB_DECOUPLE:
		imsg_compose(ibuf, IMSG_CTL_FIB_DECOUPLE, res->rtableid, 0, -1,
		    NULL, 0);
		printf("decouple request sent.\n");
		done = 1;
		break;
	case NEIGHBOR:
		errx(1, "action==NEIGHBOR");
		break;
	case NEIGHBOR_UP:
		imsg_compose(ibuf, IMSG_CTL_NEIGHBOR_UP, 0, 0, -1,
		    &neighbor, sizeof(neighbor));
		break;
	case NEIGHBOR_DOWN:
		imsg_compose(ibuf, IMSG_CTL_NEIGHBOR_DOWN, 0, 0, -1,
		    &neighbor, sizeof(neighbor));
		break;
	case NEIGHBOR_CLEAR:
		imsg_compose(ibuf, IMSG_CTL_NEIGHBOR_CLEAR, 0, 0, -1,
		    &neighbor, sizeof(neighbor));
		break;
	case NEIGHBOR_RREFRESH:
		imsg_compose(ibuf, IMSG_CTL_NEIGHBOR_RREFRESH, 0, 0, -1,
		    &neighbor, sizeof(neighbor));
		break;
	case NEIGHBOR_DESTROY:
		imsg_compose(ibuf, IMSG_CTL_NEIGHBOR_DESTROY, 0, 0, -1,
		    &neighbor, sizeof(neighbor));
		break;
	case NETWORK_BULK_ADD:
	case NETWORK_BULK_REMOVE:
		network_bulk(res);
		printf("requests sent.\n");
		done = 1;
		break;
	case NETWORK_ADD:
	case NETWORK_REMOVE:
		bzero(&net, sizeof(net));
		memcpy(&net.prefix, &res->addr, sizeof(res->addr));
		net.prefixlen = res->prefixlen;
		/* attribute sets are not supported */
		if (res->action == NETWORK_ADD) {
			imsg_compose(ibuf, IMSG_NETWORK_ADD, 0, 0, -1,
			    &net, sizeof(net));
			send_filterset(ibuf, &res->set);
			imsg_compose(ibuf, IMSG_NETWORK_DONE, 0, 0, -1,
			    NULL, 0);
		} else
			imsg_compose(ibuf, IMSG_NETWORK_REMOVE, 0, 0, -1,
			    &net, sizeof(net));
		printf("request sent.\n");
		done = 1;
		break;
	case NETWORK_FLUSH:
		imsg_compose(ibuf, IMSG_NETWORK_FLUSH, 0, 0, -1, NULL, 0);
		printf("request sent.\n");
		done = 1;
		break;
	case NETWORK_SHOW:
		bzero(&ribreq, sizeof(ribreq));
		ribreq.aid = res->aid;
		strlcpy(ribreq.rib, res->rib, sizeof(ribreq.rib));
		imsg_compose(ibuf, IMSG_CTL_SHOW_NETWORK, 0, 0, -1,
		    &ribreq, sizeof(ribreq));
		show_network_head();
		break;
	case NETWORK_MRT:
		bzero(&ribreq, sizeof(ribreq));
		if (res->as.type != AS_NONE)
			memcpy(&ribreq.as, &res->as, sizeof(res->as));
		if (res->addr.aid) {
			memcpy(&ribreq.prefix, &res->addr, sizeof(res->addr));
			ribreq.prefixlen = res->prefixlen;
		}
		if (res->community.as != COMMUNITY_UNSET &&
		    res->community.type != COMMUNITY_UNSET)
			memcpy(&ribreq.community, &res->community,
			    sizeof(res->community));
		if (res->large_community.as != COMMUNITY_UNSET &&
		    res->large_community.ld1 != COMMUNITY_UNSET &&
		    res->large_community.ld2 != COMMUNITY_UNSET)
			memcpy(&ribreq.large_community, &res->large_community,
			    sizeof(res->large_community));
		memcpy(&ribreq.neighbor, &neighbor, sizeof(ribreq.neighbor));
		ribreq.aid = res->aid;
		ribreq.flags = res->flags;
		net_mrt.arg = &ribreq;
		mrt_parse(res->mrtfd, &net_mrt, 1);
		done = 1;
		break;
	case LOG_VERBOSE:
		verbose = 1;
		/* FALLTHROUGH */
	case LOG_BRIEF:
		imsg_compose(ibuf, IMSG_CTL_LOG_VERBOSE, 0, 0, -1,
		    &verbose, sizeof(verbose));
		printf("logging request sent.\n");
		done = 1;
		break;
	}

	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
			err(1, "write error");

	while (!done) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			err(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");

		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				err(1, "imsg_get error");
			if (n == 0)
				break;

			if (imsg.hdr.type == IMSG_CTL_RESULT) {
				done = show_result(&imsg);
				imsg_free(&imsg);
				continue;
			}

			switch (res->action) {
			case SHOW:
			case SHOW_SUMMARY:
				done = show_summary_msg(&imsg, nodescr);
				break;
			case SHOW_SUMMARY_TERSE:
				done = show_summary_terse_msg(&imsg, nodescr);
				break;
			case SHOW_FIB:
			case SHOW_FIB_TABLES:
			case NETWORK_SHOW:
				done = show_fib_msg(&imsg);
				break;
			case SHOW_NEXTHOP:
				done = show_nexthop_msg(&imsg);
				break;
			case SHOW_INTERFACE:
				done = show_interface_msg(&imsg);
				break;
			case SHOW_NEIGHBOR:
				done = show_neighbor_msg(&imsg, NV_DEFAULT);
				break;
			case SHOW_NEIGHBOR_TIMERS:
				done = show_neighbor_msg(&imsg, NV_TIMERS);
				break;
			case SHOW_NEIGHBOR_TERSE:
				done = show_neighbor_terse(&imsg);
				break;
			case SHOW_RIB:
				if (res->flags & F_CTL_DETAIL)
					done = show_rib_detail_msg(&imsg,
					    nodescr);
				else
					done = show_rib_summary_msg(&imsg);
				break;
			case SHOW_RIB_MEM:
				done = show_rib_memory_msg(&imsg);
				break;
			case NEIGHBOR:
			case NEIGHBOR_UP:
			case NEIGHBOR_DOWN:
			case NEIGHBOR_CLEAR:
			case NEIGHBOR_RREFRESH:
			case NEIGHBOR_DESTROY:
			case NONE:
			case RELOAD:
			case FIB:
			case FIB_COUPLE:
			case FIB_DECOUPLE:
			case NETWORK_ADD:
			case NETWORK_REMOVE:
			case NETWORK_FLUSH:
			case NETWORK_BULK_ADD:
			case NETWORK_BULK_REMOVE:
			case IRRFILTER:
			case LOG_VERBOSE:
			case LOG_BRIEF:
			case SHOW_MRT:
			case NETWORK_MRT:
				break;
			}
			imsg_free(&imsg);
		}
	}
	close(fd);
	free(ibuf);

	exit(0);
}

char *
fmt_peer(const char *descr, const struct bgpd_addr *remote_addr,
    int masklen, int nodescr)
{
	const char	*ip;
	char		*p;

	if (descr[0] && !nodescr) {
		if ((p = strdup(descr)) == NULL)
			err(1, NULL);
		return (p);
	}

	ip = log_addr(remote_addr);
	if (masklen != -1 && ((remote_addr->aid == AID_INET && masklen != 32) ||
	    (remote_addr->aid == AID_INET6 && masklen != 128))) {
		if (asprintf(&p, "%s/%u", ip, masklen) == -1)
			err(1, NULL);
	} else {
		if ((p = strdup(ip)) == NULL)
			err(1, NULL);
	}

	return (p);
}

void
show_summary_head(void)
{
	printf("%-20s %8s %10s %10s %5s %-8s %s\n", "Neighbor", "AS",
	    "MsgRcvd", "MsgSent", "OutQ", "Up/Down", "State/PrfRcvd");
}

int
show_summary_msg(struct imsg *imsg, int nodescr)
{
	struct peer		*p;
	char			*s;
	const char		*a;
	size_t			alen;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_NEIGHBOR:
		p = imsg->data;
		s = fmt_peer(p->conf.descr, &p->conf.remote_addr,
		    p->conf.remote_masklen, nodescr);

		a = log_as(p->conf.remote_as);
		alen = strlen(a);
		/* max displayed lenght of the peers name is 28 */
		if (alen < 28) {
			if (strlen(s) > 28 - alen)
				s[28 - alen] = 0;
		} else
			alen = 0;

		printf("%-*s %s %10llu %10llu %5u %-8s ",
		    (28 - (int)alen), s, a,
		    p->stats.msg_rcvd_open + p->stats.msg_rcvd_notification +
		    p->stats.msg_rcvd_update + p->stats.msg_rcvd_keepalive +
		    p->stats.msg_rcvd_rrefresh,
		    p->stats.msg_sent_open + p->stats.msg_sent_notification +
		    p->stats.msg_sent_update + p->stats.msg_sent_keepalive +
		    p->stats.msg_sent_rrefresh,
		    p->wbuf.queued,
		    fmt_timeframe(p->stats.last_updown));
		if (p->state == STATE_ESTABLISHED) {
			printf("%6u", p->stats.prefix_cnt);
			if (p->conf.max_prefix != 0)
				printf("/%u", p->conf.max_prefix);
		} else if (p->conf.template)
			printf("Template");
		else
			printf("%s", statenames[p->state]);
		printf("\n");
		free(s);
		break;
	case IMSG_CTL_END:
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_summary_terse_msg(struct imsg *imsg, int nodescr)
{
	struct peer		*p;
	char			*s;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_NEIGHBOR:
		p = imsg->data;
		s = fmt_peer(p->conf.descr, &p->conf.remote_addr,
		    p->conf.remote_masklen, nodescr);
		printf("%s %s %s\n", s, log_as(p->conf.remote_as),
		    p->conf.template ? "Template" : statenames[p->state]);
		free(s);
		break;
	case IMSG_CTL_END:
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_neighbor_terse(struct imsg *imsg)
{
	struct peer		*p;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_NEIGHBOR:
		p = imsg->data;
		printf("%llu %llu %llu %llu %llu %llu %llu "
		    "%llu %llu %llu %u %u %llu %llu %llu %llu\n",
		    p->stats.msg_sent_open, p->stats.msg_rcvd_open,
		    p->stats.msg_sent_notification,
		    p->stats.msg_rcvd_notification,
		    p->stats.msg_sent_update, p->stats.msg_rcvd_update,
		    p->stats.msg_sent_keepalive, p->stats.msg_rcvd_keepalive,
		    p->stats.msg_sent_rrefresh, p->stats.msg_rcvd_rrefresh,
		    p->stats.prefix_cnt, p->conf.max_prefix,
		    p->stats.prefix_sent_update, p->stats.prefix_rcvd_update,
		    p->stats.prefix_sent_withdraw,
		    p->stats.prefix_rcvd_withdraw);
		break;
	case IMSG_CTL_END:
		return (1);
	default:
		break;
	}

	return (0);
}

const char *
print_auth_method(enum auth_method method)
{
	switch (method) {
	case AUTH_MD5SIG:
		return ", using md5sig";
	case AUTH_IPSEC_MANUAL_ESP:
		return ", using ipsec manual esp";
	case AUTH_IPSEC_MANUAL_AH:
		return ", using ipsec manual ah";
	case AUTH_IPSEC_IKE_ESP:
		return ", using ipsec ike esp";
	case AUTH_IPSEC_IKE_AH:
		return ", using ipsec ike ah";
	case AUTH_NONE:	/* FALLTHROUGH */
	default:
		return "";
	}
}

int
show_neighbor_msg(struct imsg *imsg, enum neighbor_views nv)
{
	struct peer		*p;
	struct ctl_timer	*t;
	struct in_addr		 ina;
	char			 buf[NI_MAXHOST], pbuf[NI_MAXSERV], *s;
	int			 hascapamp = 0;
	u_int8_t		 i;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_NEIGHBOR:
		p = imsg->data;
		if ((p->conf.remote_addr.aid == AID_INET &&
		    p->conf.remote_masklen != 32) ||
		    (p->conf.remote_addr.aid == AID_INET6 &&
		    p->conf.remote_masklen != 128)) {
			if (asprintf(&s, "%s/%u",
			    log_addr(&p->conf.remote_addr),
			    p->conf.remote_masklen) == -1)
				err(1, NULL);
		} else
			if ((s = strdup(log_addr(&p->conf.remote_addr))) ==
			    NULL)
				err(1, "strdup");

		ina.s_addr = p->remote_bgpid;
		printf("BGP neighbor is %s, ", s);
		free(s);
		if (p->conf.remote_as == 0 && p->conf.template)
			printf("remote AS: accept any");
		else
			printf("remote AS %s", log_as(p->conf.remote_as));
		if (p->conf.template)
			printf(", Template");
		if (p->template)
			printf(", Cloned");
		if (p->conf.passive)
			printf(", Passive");
		if (p->conf.ebgp && p->conf.distance > 1)
			printf(", Multihop (%u)", (int)p->conf.distance);
		printf("\n");
		if (p->conf.descr[0])
			printf(" Description: %s\n", p->conf.descr);
		if (p->conf.max_prefix) {
			printf(" Max-prefix: %u", p->conf.max_prefix);
			if (p->conf.max_prefix_restart)
				printf(" (restart %u)",
				    p->conf.max_prefix_restart);
			printf("\n");
		}
		printf("  BGP version 4, remote router-id %s",
		    inet_ntoa(ina));
		printf("%s\n", print_auth_method(p->auth.method));
		printf("  BGP state = %s", statenames[p->state]);
		if (p->conf.down) {
			printf(", marked down");
			if (*(p->conf.shutcomm)) {
				printf(" with shutdown reason \"%s\"",
				    log_shutcomm(p->conf.shutcomm));
			}
		}
		if (p->stats.last_updown != 0)
			printf(", %s for %s",
			    p->state == STATE_ESTABLISHED ? "up" : "down",
			    fmt_timeframe(p->stats.last_updown));
		printf("\n");
		printf("  Last read %s, holdtime %us, keepalive interval %us\n",
		    fmt_timeframe(p->stats.last_read),
		    p->holdtime, p->holdtime/3);
		for (i = 0; i < AID_MAX; i++)
			if (p->capa.peer.mp[i])
				hascapamp = 1;
		if (hascapamp || p->capa.peer.refresh ||
		    p->capa.peer.grestart.restart || p->capa.peer.as4byte) {
			printf("  Neighbor capabilities:\n");
			if (hascapamp) {
				printf("    Multiprotocol extensions: ");
				print_neighbor_capa_mp(p);
				printf("\n");
			}
			if (p->capa.peer.refresh)
				printf("    Route Refresh\n");
			if (p->capa.peer.grestart.restart) {
				printf("    Graceful Restart");
				print_neighbor_capa_restart(p);
				printf("\n");
			}
			if (p->capa.peer.as4byte)
				printf("    4-byte AS numbers\n");
		}
		printf("\n");
		if (nv == NV_TIMERS)
			break;
		print_neighbor_msgstats(p);
		printf("\n");
		if (*(p->stats.last_shutcomm)) {
			printf("  Last received shutdown reason: \"%s\"\n",
			    log_shutcomm(p->stats.last_shutcomm));
		}
		if (p->state == STATE_IDLE) {
			static const char	*errstr;

			errstr = get_errstr(p->stats.last_sent_errcode,
			    p->stats.last_sent_suberr);
			if (errstr)
				printf("  Last error: %s\n\n", errstr);
		} else {
			if (getnameinfo((struct sockaddr *)&p->sa_local,
			    (socklen_t)p->sa_local.ss_len,
			    buf, sizeof(buf), pbuf, sizeof(pbuf),
			    NI_NUMERICHOST | NI_NUMERICSERV)) {
				strlcpy(buf, "(unknown)", sizeof(buf));
				strlcpy(pbuf, "", sizeof(pbuf));
			}
			printf("  Local host:  %20s, Local port:  %5s\n", buf,
			    pbuf);

			if (getnameinfo((struct sockaddr *)&p->sa_remote,
			    (socklen_t)p->sa_remote.ss_len,
			    buf, sizeof(buf), pbuf, sizeof(pbuf),
			    NI_NUMERICHOST | NI_NUMERICSERV)) {
				strlcpy(buf, "(unknown)", sizeof(buf));
				strlcpy(pbuf, "", sizeof(pbuf));
			}
			printf("  Remote host: %20s, Remote port: %5s\n", buf,
			    pbuf);
			printf("\n");
		}
		break;
	case IMSG_CTL_SHOW_TIMER:
		t = imsg->data;
		if (t->type > 0 && t->type < Timer_Max)
			print_timer(timernames[t->type], t->val);
		break;
	case IMSG_CTL_END:
		return (1);
		break;
	default:
		break;
	}

	return (0);
}

void
print_neighbor_capa_mp(struct peer *p)
{
	int		comma;
	u_int8_t	i;

	for (i = 0, comma = 0; i < AID_MAX; i++)
		if (p->capa.peer.mp[i]) {
			printf("%s%s", comma ? ", " : "", aid2str(i));
			comma = 1;
		}
}

void
print_neighbor_capa_restart(struct peer *p)
{
	int		comma;
	u_int8_t	i;

	if (p->capa.peer.grestart.timeout)
		printf(": Timeout: %d, ", p->capa.peer.grestart.timeout);
	for (i = 0, comma = 0; i < AID_MAX; i++)
		if (p->capa.peer.grestart.flags[i] & CAPA_GR_PRESENT) {
			if (!comma &&
			    p->capa.peer.grestart.flags[i] & CAPA_GR_RESTART)
				printf("restarted, ");
			if (comma)
				printf(", ");
			printf("%s", aid2str(i));
			if (p->capa.peer.grestart.flags[i] & CAPA_GR_FORWARD)
				printf(" (preserved)");
			comma = 1;
		}
}

void
print_neighbor_msgstats(struct peer *p)
{
	printf("  Message statistics:\n");
	printf("  %-15s %-10s %-10s\n", "", "Sent", "Received");
	printf("  %-15s %10llu %10llu\n", "Opens",
	    p->stats.msg_sent_open, p->stats.msg_rcvd_open);
	printf("  %-15s %10llu %10llu\n", "Notifications",
	    p->stats.msg_sent_notification, p->stats.msg_rcvd_notification);
	printf("  %-15s %10llu %10llu\n", "Updates",
	    p->stats.msg_sent_update, p->stats.msg_rcvd_update);
	printf("  %-15s %10llu %10llu\n", "Keepalives",
	    p->stats.msg_sent_keepalive, p->stats.msg_rcvd_keepalive);
	printf("  %-15s %10llu %10llu\n", "Route Refresh",
	    p->stats.msg_sent_rrefresh, p->stats.msg_rcvd_rrefresh);
	printf("  %-15s %10llu %10llu\n\n", "Total",
	    p->stats.msg_sent_open + p->stats.msg_sent_notification +
	    p->stats.msg_sent_update + p->stats.msg_sent_keepalive +
	    p->stats.msg_sent_rrefresh,
	    p->stats.msg_rcvd_open + p->stats.msg_rcvd_notification +
	    p->stats.msg_rcvd_update + p->stats.msg_rcvd_keepalive +
	    p->stats.msg_rcvd_rrefresh);
	printf("  Update statistics:\n");
	printf("  %-15s %-10s %-10s\n", "", "Sent", "Received");
	printf("  %-15s %10llu %10llu\n", "Updates",
	    p->stats.prefix_sent_update, p->stats.prefix_rcvd_update);
	printf("  %-15s %10llu %10llu\n", "Withdraws",
	    p->stats.prefix_sent_withdraw, p->stats.prefix_rcvd_withdraw);
	printf("  %-15s %10llu %10llu\n", "End-of-Rib",
	    p->stats.prefix_sent_eor, p->stats.prefix_rcvd_eor);
}

void
print_timer(const char *name, time_t d)
{
	printf("  %-20s ", name);

	if (d <= 0)
		printf("%-20s\n", "due");
	else
		printf("due in %-13s\n", fmt_timeframe_core(d));
}

#define TF_BUFS	8
#define TF_LEN	9

static char *
fmt_timeframe(time_t t)
{
	if (t == 0)
		return ("Never");
	else
		return (fmt_timeframe_core(time(NULL) - t));
}

static char *
fmt_timeframe_core(time_t t)
{
	char		*buf;
	static char	 tfbuf[TF_BUFS][TF_LEN];	/* ring buffer */
	static int	 idx = 0;
	unsigned int	 sec, min, hrs, day;
	unsigned long long	week;

	buf = tfbuf[idx++];
	if (idx == TF_BUFS)
		idx = 0;

	week = t;

	sec = week % 60;
	week /= 60;
	min = week % 60;
	week /= 60;
	hrs = week % 24;
	week /= 24;
	day = week % 7;
	week /= 7;

	if (week > 0)
		snprintf(buf, TF_LEN, "%02lluw%01ud%02uh", week, day, hrs);
	else if (day > 0)
		snprintf(buf, TF_LEN, "%01ud%02uh%02um", day, hrs, min);
	else
		snprintf(buf, TF_LEN, "%02u:%02u:%02u", hrs, min, sec);

	return (buf);
}

void
show_fib_head(void)
{
	printf("flags: "
	    "* = valid, B = BGP, C = Connected, S = Static, D = Dynamic\n");
	printf("       "
	    "N = BGP Nexthop reachable via this route R = redistributed\n");
	printf("       r = reject route, b = blackhole route\n\n");
	printf("flags prio destination          gateway\n");
}

void
show_fib_tables_head(void)
{
	printf("%-5s %-20s %-8s\n", "Table", "Description", "State");
}

void
show_network_head(void)
{
	printf("flags: S = Static\n");
	printf("flags destination\n");
}

void
show_fib_flags(u_int16_t flags)
{
	if (flags & F_DOWN)
		printf(" ");
	else
		printf("*");

	if (flags & F_BGPD_INSERTED)
		printf("B");
	else if (flags & F_CONNECTED)
		printf("C");
	else if (flags & F_STATIC)
		printf("S");
	else if (flags & F_DYNAMIC)
		printf("D");
	else
		printf(" ");

	if (flags & F_NEXTHOP)
		printf("N");
	else
		printf(" ");

	if (flags & F_REDISTRIBUTED)
		printf("R");
	else
		printf(" ");

	if (flags & F_REJECT && flags & F_BLACKHOLE)
		printf("f");
	else if (flags & F_REJECT)
		printf("r");
	else if (flags & F_BLACKHOLE)
		printf("b");
	else
		printf(" ");

	printf(" ");
}

int
show_fib_msg(struct imsg *imsg)
{
	struct kroute_full	*kf;
	struct ktable		*kt;
	char			*p;

	switch (imsg->hdr.type) {
	case IMSG_CTL_KROUTE:
	case IMSG_CTL_SHOW_NETWORK:
		if (imsg->hdr.len < IMSG_HEADER_SIZE + sizeof(*kf))
			errx(1, "wrong imsg len");
		kf = imsg->data;

		show_fib_flags(kf->flags);

		if (asprintf(&p, "%s/%u", log_addr(&kf->prefix),
		    kf->prefixlen) == -1)
			err(1, NULL);
		printf("%4i %-20s ", kf->priority, p);
		free(p);

		if (kf->flags & F_CONNECTED)
			printf("link#%u", kf->ifindex);
		else
			printf("%s", log_addr(&kf->nexthop));
		printf("\n");

		break;
	case IMSG_CTL_SHOW_FIB_TABLES:
		if (imsg->hdr.len < IMSG_HEADER_SIZE + sizeof(*kt))
			errx(1, "wrong imsg len");
		kt = imsg->data;

		printf("%5i %-20s %-8s%s\n", kt->rtableid, kt->descr,
		    kt->fib_sync ? "coupled" : "decoupled",
		    kt->fib_sync != kt->fib_conf ? "*" : "");

		break;
	case IMSG_CTL_END:
		return (1);
	default:
		break;
	}

	return (0);
}

void
show_nexthop_head(void)
{
	printf("Flags: * = nexthop valid\n");
	printf("\n  %-15s %-19s%-4s %-15s %-20s\n", "Nexthop", "Route",
	     "Prio", "Gateway", "Iface");
}

int
show_nexthop_msg(struct imsg *imsg)
{
	struct ctl_show_nexthop	*p;
	struct kroute		*k;
	struct kroute6		*k6;
	char			*s;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_NEXTHOP:
		p = imsg->data;
		printf("%s %-15s ", p->valid ? "*" : " ", log_addr(&p->addr));
		if (!p->krvalid) {
			printf("\n");
			return (0);
		}
		switch (p->addr.aid) {
		case AID_INET:
			k = &p->kr.kr4;
			if (asprintf(&s, "%s/%u", inet_ntoa(k->prefix),
			    k->prefixlen) == -1)
				err(1, NULL);
			printf("%-20s", s);
			free(s);
			printf("%3i %-15s ", k->priority,
			    k->flags & F_CONNECTED ? "connected" :
			    inet_ntoa(k->nexthop));
			break;
		case AID_INET6:
			k6 = &p->kr.kr6;
			if (asprintf(&s, "%s/%u", log_in6addr(&k6->prefix),
			    k6->prefixlen) == -1)
				err(1, NULL);
			printf("%-20s", s);
			free(s);
			printf("%3i %-15s ", k6->priority,
			    k6->flags & F_CONNECTED ? "connected" :
			    log_in6addr(&k6->nexthop));
			break;
		default:
			printf("unknown address family\n");
			return (0);
		}
		if (p->kif.ifname[0]) {
			char *s1;
			if (p->kif.baudrate) {
				if (asprintf(&s1, ", %s",
				    get_baudrate(p->kif.baudrate,
				    "bps")) == -1)
					err(1, NULL);
			} else if (asprintf(&s1, ", %s", get_linkstate(
			    p->kif.if_type, p->kif.link_state)) == -1)
					err(1, NULL);
			if (asprintf(&s, "%s (%s%s)", p->kif.ifname,
			    p->kif.flags & IFF_UP ? "UP" : "DOWN", s1) == -1)
				err(1, NULL);
			printf("%-15s", s);
			free(s1);
			free(s);
		}
		printf("\n");
		break;
	case IMSG_CTL_END:
		return (1);
		break;
	default:
		break;
	}

	return (0);
}


void
show_interface_head(void)
{
	printf("%-15s%-15s%-15s%s\n", "Interface", "Nexthop state", "Flags",
	    "Link state");
}

const struct if_status_description
		if_status_descriptions[] = LINK_STATE_DESCRIPTIONS;
const struct ifmedia_description
		ifm_type_descriptions[] = IFM_TYPE_DESCRIPTIONS;

uint64_t
ift2ifm(uint8_t if_type)
{
	switch (if_type) {
	case IFT_ETHER:
		return (IFM_ETHER);
	case IFT_FDDI:
		return (IFM_FDDI);
	case IFT_CARP:
		return (IFM_CARP);
	case IFT_IEEE80211:
		return (IFM_IEEE80211);
	default:
		return (0);
	}
}

const char *
get_media_descr(uint64_t media_type)
{
	const struct ifmedia_description	*p;

	for (p = ifm_type_descriptions; p->ifmt_string != NULL; p++)
		if (media_type == p->ifmt_word)
			return (p->ifmt_string);

	return ("unknown media");
}

const char *
get_linkstate(uint8_t if_type, int link_state)
{
	const struct if_status_description *p;
	static char buf[8];

	for (p = if_status_descriptions; p->ifs_string != NULL; p++) {
		if (LINK_STATE_DESC_MATCH(p, if_type, link_state))
			return (p->ifs_string);
	}
	snprintf(buf, sizeof(buf), "[#%d]", link_state);
	return (buf);
}

const char *
get_baudrate(u_int64_t baudrate, char *unit)
{
	static char bbuf[16];

	if (baudrate > IF_Gbps(1))
		snprintf(bbuf, sizeof(bbuf), "%llu G%s",
		    baudrate / IF_Gbps(1), unit);
	else if (baudrate > IF_Mbps(1))
		snprintf(bbuf, sizeof(bbuf), "%llu M%s",
		    baudrate / IF_Mbps(1), unit);
	else if (baudrate > IF_Kbps(1))
		snprintf(bbuf, sizeof(bbuf), "%llu K%s",
		    baudrate / IF_Kbps(1), unit);
	else
		snprintf(bbuf, sizeof(bbuf), "%llu %s",
		    baudrate, unit);

	return (bbuf);
}

int
show_interface_msg(struct imsg *imsg)
{
	struct kif	*k;
	uint64_t	 ifms_type;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_INTERFACE:
		k = imsg->data;
		printf("%-15s", k->ifname);
		printf("%-15s", k->nh_reachable ? "ok" : "invalid");
		printf("%-15s", k->flags & IFF_UP ? "UP" : "");

		if ((ifms_type = ift2ifm(k->if_type)) != 0)
			printf("%s, ", get_media_descr(ifms_type));

		printf("%s", get_linkstate(k->if_type, k->link_state));

		if (k->link_state != LINK_STATE_DOWN && k->baudrate > 0)
			printf(", %s", get_baudrate(k->baudrate, "Bit/s"));
		printf("\n");
		break;
	case IMSG_CTL_END:
		return (1);
		break;
	default:
		break;
	}

	return (0);
}

void
show_rib_summary_head(void)
{
	printf("flags: * = Valid, > = Selected, I = via IBGP, A = Announced, "
	    "S = Stale\n");
	printf("origin: i = IGP, e = EGP, ? = Incomplete\n\n");
	printf("%-5s %-20s %-15s  %5s %5s %s\n", "flags", "destination",
	    "gateway", "lpref", "med", "aspath origin");
}

void
print_prefix(struct bgpd_addr *prefix, u_int8_t prefixlen, u_int8_t flags)
{
	char			*p;

	print_flags(flags, 1);
	if (asprintf(&p, "%s/%u", log_addr(prefix), prefixlen) == -1)
		err(1, NULL);
	printf("%-20s", p);
	free(p);
}

const char *
print_origin(u_int8_t origin, int sum)
{
	switch (origin) {
	case ORIGIN_IGP:
		return (sum ? "i" : "IGP");
	case ORIGIN_EGP:
		return (sum ? "e" : "EGP");
	case ORIGIN_INCOMPLETE:
		return (sum ? "?" : "incomplete");
	default:
		return (sum ? "X" : "bad origin");
	}
}

void
print_flags(u_int8_t flags, int sum)
{
	char	 flagstr[5];
	char	*p = flagstr;

	if (sum) {
		if (flags & F_PREF_ANNOUNCE)
			*p++ = 'A';
		if (flags & F_PREF_INTERNAL)
			*p++ = 'I';
		if (flags & F_PREF_STALE)
			*p++ = 'S';
		if (flags & F_PREF_ELIGIBLE)
			*p++ = '*';
		if (flags & F_PREF_ACTIVE)
			*p++ = '>';
		*p = '\0';
		printf("%-5s ", flagstr);
	} else {
		if (flags & F_PREF_INTERNAL)
			printf("internal");
		else
			printf("external");
		if (flags & F_PREF_STALE)
			printf(", stale");
		if (flags & F_PREF_ELIGIBLE)
			printf(", valid");
		if (flags & F_PREF_ACTIVE)
			printf(", best");
		if (flags & F_PREF_ANNOUNCE)
			printf(", announced");
	}
}

int
show_rib_summary_msg(struct imsg *imsg)
{
	struct ctl_show_rib	 rib;
	u_char			*asdata;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_RIB:
		memcpy(&rib, imsg->data, sizeof(rib));
		asdata = imsg->data;
		asdata += sizeof(struct ctl_show_rib);
		show_rib_brief(&rib, asdata);
		break;
	case IMSG_CTL_END:
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_rib_detail_msg(struct imsg *imsg, int nodescr)
{
	struct ctl_show_rib	 rib;
	u_char			*asdata;
	u_int16_t		 ilen;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_RIB:
		memcpy(&rib, imsg->data, sizeof(rib));
		asdata = imsg->data;
		asdata += sizeof(struct ctl_show_rib);
		show_rib_detail(&rib, asdata, nodescr);
		break;
	case IMSG_CTL_SHOW_RIB_ATTR:
		ilen = imsg->hdr.len - IMSG_HEADER_SIZE;
		if (ilen < 3)
			errx(1, "bad IMSG_CTL_SHOW_RIB_ATTR received");
		show_attr(imsg->data, ilen);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

void
show_rib_brief(struct ctl_show_rib *r, u_char *asdata)
{
	char			*aspath;

	print_prefix(&r->prefix, r->prefixlen, r->flags);
	printf(" %-15s ", log_addr(&r->exit_nexthop));
	printf(" %5u %5u ", r->local_pref, r->med);

	if (aspath_asprint(&aspath, asdata, r->aspath_len) == -1)
		err(1, NULL);
	if (strlen(aspath) > 0)
		printf("%s ", aspath);
	free(aspath);

	printf("%s\n", print_origin(r->origin, 1));
}

void
show_rib_detail(struct ctl_show_rib *r, u_char *asdata, int nodescr)
{
	struct in_addr		 id;
	char			*aspath, *s;
	time_t			 now;

	printf("\nBGP routing table entry for %s/%u\n",
	    log_addr(&r->prefix), r->prefixlen);

	if (aspath_asprint(&aspath, asdata, r->aspath_len) == -1)
		err(1, NULL);
	if (strlen(aspath) > 0)
		printf("    %s\n", aspath);
	free(aspath);

	s = fmt_peer(r->descr, &r->remote_addr, -1, nodescr);
	printf("    Nexthop %s ", log_addr(&r->exit_nexthop));
	printf("(via %s) from %s (", log_addr(&r->true_nexthop), s);
	free(s);
	id.s_addr = htonl(r->remote_id);
	printf("%s)\n", inet_ntoa(id));

	printf("    Origin %s, metric %u, localpref %u, weight %u, ",
	    print_origin(r->origin, 0), r->med, r->local_pref, r->weight);
	print_flags(r->flags, 0);

	now = time(NULL);
	if (now > r->lastchange)
		now -= r->lastchange;
	else
		now = 0;

	printf("\n    Last update: %s ago\n", fmt_timeframe_core(now));
}

void
show_attr(void *b, u_int16_t len)
{
	char		*data = b;
	struct in_addr	 id;
	u_int32_t	 as;
	u_int16_t	 alen, ioff;
	u_int8_t	 flags, type;
	int		 i;

	if (len < 3)
		errx(1, "show_attr: too short bgp attr");

	flags = data[0];
	type = data[1];

	/* get the attribute length */
	if (flags & ATTR_EXTLEN) {
		if (len < 4)
			errx(1, "show_attr: too short bgp attr");
		memcpy(&alen, data+2, sizeof(u_int16_t));
		alen = ntohs(alen);
		data += 4;
		len -= 4;
	} else {
		alen = (u_char)data[2];
		data += 3;
		len -= 3;
	}

	/* bad imsg len how can that happen!? */
	if (alen > len)
		errx(1, "show_attr: bad length");

	switch (type) {
	case ATTR_COMMUNITIES:
		printf("    Communities: ");
		show_community(data, alen);
		printf("\n");
		break;
	case ATTR_LARGE_COMMUNITIES:
		printf("    Large Communities: ");
		show_large_community(data, alen);
		printf("\n");
		break;
	case ATTR_AGGREGATOR:
		memcpy(&as, data, sizeof(as));
		memcpy(&id, data + sizeof(as), sizeof(id));
		printf("    Aggregator: %s [%s]\n",
		    log_as(ntohl(as)), inet_ntoa(id));
		break;
	case ATTR_ORIGINATOR_ID:
		memcpy(&id, data, sizeof(id));
		printf("    Originator Id: %s\n", inet_ntoa(id));
		break;
	case ATTR_CLUSTER_LIST:
		printf("    Cluster ID List:");
		for (ioff = 0; ioff + sizeof(id) <= alen;
		    ioff += sizeof(id)) {
			memcpy(&id, data + ioff, sizeof(id));
			printf(" %s", inet_ntoa(id));
		}
		printf("\n");
		break;
	case ATTR_EXT_COMMUNITIES:
		printf("    Ext. communities: ");
		show_ext_community(data, alen);
		printf("\n");
		break;
	case ATTR_ATOMIC_AGGREGATE:
		/* ignore */
		break;
	default:
		/* ignore unknown attributes */
		printf("    Unknown Attribute #%u", type);
		if (flags) {
			printf(" flags [");
			if (flags & ATTR_OPTIONAL)
				printf("O");
			if (flags & ATTR_TRANSITIVE)
				printf("T");
			if (flags & ATTR_PARTIAL)
				printf("P");
			printf("]");
		}
		printf(" len %u", alen);
		if (alen) {
			printf(":");
			for (i=0; i < alen; i++)
				printf(" %02x", *(data+i) & 0xFF);
		}
		printf("\n");
		break;
	}
}

void
show_community(u_char *data, u_int16_t len)
{
	u_int16_t	a, v;
	u_int16_t	i;

	if (len & 0x3)
		return;

	for (i = 0; i < len; i += 4) {
		memcpy(&a, data + i, sizeof(a));
		memcpy(&v, data + i + 2, sizeof(v));
		a = ntohs(a);
		v = ntohs(v);
		if (a == COMMUNITY_WELLKNOWN)
			switch (v) {
			case COMMUNITY_NO_EXPORT:
				printf("NO_EXPORT");
				break;
			case COMMUNITY_NO_ADVERTISE:
				printf("NO_ADVERTISE");
				break;
			case COMMUNITY_NO_EXPSUBCONFED:
				printf("NO_EXPORT_SUBCONFED");
				break;
			case COMMUNITY_NO_PEER:
				printf("NO_PEER");
				break;
			case COMMUNITY_BLACKHOLE:
				printf("BLACKHOLE");
				break;
			default:
				printf("WELLKNOWN:%hu", v);
				break;
			}
		else
			printf("%hu:%hu", a, v);

		if (i + 4 < len)
			printf(" ");
	}
}

void
show_large_community(u_char *data, u_int16_t len)
{
	u_int32_t	a, l1, l2;
	u_int16_t	i;

	if (len % 12)
		return;

	for (i = 0; i < len; i += 12) {
		memcpy(&a, data + i, sizeof(a));
		memcpy(&l1, data + i + 4, sizeof(l1));
		memcpy(&l2, data + i + 8, sizeof(l2));
		a = ntohl(a);
		l1 = ntohl(l1);
		l2 = ntohl(l2);
		printf("%u:%u:%u", a, l1, l2);

		if (i + 12 < len)
			printf(" ");
	}
}

void
show_ext_community(u_char *data, u_int16_t len)
{
	u_int64_t	ext;
	struct in_addr	ip;
	u_int32_t	as4, u32;
	u_int16_t	i, as2, u16;
	u_int8_t	type, subtype;

	if (len & 0x7)
		return;

	for (i = 0; i < len; i += 8) {
		type = data[i];
		subtype = data[i + 1];

		switch (type & EXT_COMMUNITY_VALUE) {
		case EXT_COMMUNITY_TWO_AS:
			memcpy(&as2, data + i + 2, sizeof(as2));
			memcpy(&u32, data + i + 4, sizeof(u32));
			printf("%s %s:%u", log_ext_subtype(subtype),
			    log_as(ntohs(as2)), ntohl(u32));
			break;
		case EXT_COMMUNITY_IPV4:
			memcpy(&ip, data + i + 2, sizeof(ip));
			memcpy(&u16, data + i + 6, sizeof(u16));
			printf("%s %s:%hu", log_ext_subtype(subtype),
			    inet_ntoa(ip), ntohs(u16));
			break;
		case EXT_COMMUNITY_FOUR_AS:
			memcpy(&as4, data + i + 2, sizeof(as4));
			memcpy(&u16, data + i + 6, sizeof(u16));
			printf("%s %s:%hu", log_ext_subtype(subtype),
			    log_as(ntohl(as4)), ntohs(u16));
			break;
		case EXT_COMMUNITY_OPAQUE:
			memcpy(&ext, data + i, sizeof(ext));
			ext = betoh64(ext) & 0xffffffffffffLL;
			printf("%s 0x%llx", log_ext_subtype(subtype), ext);
			break;
		default:
			memcpy(&ext, data + i, sizeof(ext));
			printf("0x%llx", betoh64(ext));
		}
		if (i + 8 < len)
			printf(", ");
	}
}

char *
fmt_mem(int64_t num)
{
	static char	buf[16];

	if (fmt_scaled(num, buf) == -1)
		snprintf(buf, sizeof(buf), "%lldB", (long long)num);

	return (buf);
}

size_t  pt_sizes[AID_MAX] = AID_PTSIZE;

int
show_rib_memory_msg(struct imsg *imsg)
{
	struct rde_memstats	stats;
	size_t			pts = 0;
	int			i;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_RIB_MEM:
		memcpy(&stats, imsg->data, sizeof(stats));
		printf("RDE memory statistics\n");
		for (i = 0; i < AID_MAX; i++) {
			if (stats.pt_cnt[i] == 0)
				continue;
			pts += stats.pt_cnt[i] * pt_sizes[i];
			printf("%10lld %s network entries using %s of memory\n",
			    (long long)stats.pt_cnt[i], aid_vals[i].name,
			    fmt_mem(stats.pt_cnt[i] * pt_sizes[i]));
		}
		printf("%10lld rib entries using %s of memory\n",
		    (long long)stats.rib_cnt, fmt_mem(stats.rib_cnt *
		    sizeof(struct rib_entry)));
		printf("%10lld prefix entries using %s of memory\n",
		    (long long)stats.prefix_cnt, fmt_mem(stats.prefix_cnt *
		    sizeof(struct prefix)));
		printf("%10lld BGP path attribute entries using %s of memory\n",
		    (long long)stats.path_cnt, fmt_mem(stats.path_cnt *
		    sizeof(struct rde_aspath)));
		printf("%10lld BGP AS-PATH attribute entries using "
		    "%s of memory,\n\t   and holding %lld references\n",
		    (long long)stats.aspath_cnt, fmt_mem(stats.aspath_size),
		    (long long)stats.aspath_refs);
		printf("%10lld BGP attributes entries using %s of memory\n",
		    (long long)stats.attr_cnt, fmt_mem(stats.attr_cnt *
		    sizeof(struct attr)));
		printf("\t   and holding %lld references\n",
		    (long long)stats.attr_refs);
		printf("%10lld BGP attributes using %s of memory\n",
		    (long long)stats.attr_dcnt, fmt_mem(stats.attr_data));
		printf("RIB using %s of memory\n", fmt_mem(pts +
		    stats.prefix_cnt * sizeof(struct prefix) +
		    stats.rib_cnt * sizeof(struct rib_entry) +
		    stats.path_cnt * sizeof(struct rde_aspath) +
		    stats.aspath_size + stats.attr_cnt * sizeof(struct attr) +
		    stats.attr_data));
		break;
	default:
		break;
	}

	return (1);
}

void
send_filterset(struct imsgbuf *i, struct filter_set_head *set)
{
	struct filter_set	*s;

	while ((s = TAILQ_FIRST(set)) != NULL) {
		imsg_compose(i, IMSG_FILTER_SET, 0, 0, -1, s,
		    sizeof(struct filter_set));
		TAILQ_REMOVE(set, s, entry);
		free(s);
	}
}

const char *
get_errstr(u_int8_t errcode, u_int8_t subcode)
{
	static const char	*errstr = NULL;

	if (errcode && errcode < sizeof(errnames)/sizeof(char *))
		errstr = errnames[errcode];

	switch (errcode) {
	case ERR_HEADER:
		if (subcode &&
		    subcode < sizeof(suberr_header_names)/sizeof(char *))
			errstr = suberr_header_names[subcode];
		break;
	case ERR_OPEN:
		if (subcode &&
		    subcode < sizeof(suberr_open_names)/sizeof(char *))
			errstr = suberr_open_names[subcode];
		break;
	case ERR_UPDATE:
		if (subcode &&
		    subcode < sizeof(suberr_update_names)/sizeof(char *))
			errstr = suberr_update_names[subcode];
		break;
	case ERR_HOLDTIMEREXPIRED:
	case ERR_FSM:
	case ERR_CEASE:
		break;
	default:
		return ("unknown error code");
	}

	return (errstr);
}

int
show_result(struct imsg *imsg)
{
	u_int	rescode;

	if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(rescode))
		errx(1, "got IMSG_CTL_RESULT with wrong len");
	memcpy(&rescode, imsg->data, sizeof(rescode));

	if (rescode == 0)
		printf("request processed\n");
	else {
		if (rescode >
		    sizeof(ctl_res_strerror)/sizeof(ctl_res_strerror[0]))
			printf("unknown result error code %u\n", rescode);
		else
			printf("%s\n", ctl_res_strerror[rescode]);
	}

	return (1);
}

void
network_bulk(struct parse_result *res)
{
	struct network_config net;
	struct filter_set *s = NULL;
	struct bgpd_addr h;
	char *b, *buf, *lbuf;
	size_t slen;
	u_int8_t len;
	FILE *f;

	if ((f = fdopen(STDIN_FILENO, "r")) != NULL) {
		while ((buf = fgetln(f, &slen))) {
			lbuf = NULL;
			if (buf[slen - 1] == '\n')
				buf[slen - 1] = '\0';
			else {
				if ((lbuf = malloc(slen + 1)) == NULL)
					err(1, NULL);
				memcpy(lbuf, buf, slen);
				lbuf[slen] = '\0';
				buf = lbuf;
			}

			while ((b = strsep(&buf, " \t")) != NULL) {
				/* Don't process commented entries */
				if (strchr(b, '#') != NULL)
					break;
				bzero(&net, sizeof(net));
				parse_prefix(b, strlen(b), &h, &len);
				memcpy(&net.prefix, &h, sizeof(h));
				net.prefixlen = len;

				if (res->action == NETWORK_BULK_ADD) {
					imsg_compose(ibuf, IMSG_NETWORK_ADD,
					    0, 0, -1, &net, sizeof(net));
					TAILQ_FOREACH(s, &res->set, entry) {
						imsg_compose(ibuf,
						    IMSG_FILTER_SET,
						    0, 0, -1, s, sizeof(*s));
					}
					imsg_compose(ibuf, IMSG_NETWORK_DONE,
					    0, 0, -1, NULL, 0);
				} else
					imsg_compose(ibuf, IMSG_NETWORK_REMOVE,
					     0, 0, -1, &net, sizeof(net));
			}
			free(lbuf);
		}
		fclose(f);
	} else {
		err(1, "Failed to open stdin\n");
	}
}

void
show_mrt_dump(struct mrt_rib *mr, struct mrt_peer *mp, void *arg)
{
	struct ctl_show_rib		 ctl;
	struct ctl_show_rib_request	*req = arg;
	struct mrt_rib_entry		*mre;
	u_int16_t			 i, j;

	for (i = 0; i < mr->nentries; i++) {
		mre = &mr->entries[i];
		bzero(&ctl, sizeof(ctl));
		mrt_to_bgpd_addr(&mr->prefix, &ctl.prefix);
		ctl.prefixlen = mr->prefixlen;
		ctl.lastchange = mre->originated;
		mrt_to_bgpd_addr(&mre->nexthop, &ctl.true_nexthop);
		mrt_to_bgpd_addr(&mre->nexthop, &ctl.exit_nexthop);
		ctl.origin = mre->origin;
		ctl.local_pref = mre->local_pref;
		ctl.med = mre->med;
		/* weight is not part of the mrt dump so it can't be set */
		ctl.aspath_len = mre->aspath_len;

		if (mre->peer_idx < mp->npeers) {
			mrt_to_bgpd_addr(&mp->peers[mre->peer_idx].addr,
			    &ctl.remote_addr);
			ctl.remote_id = mp->peers[mre->peer_idx].bgp_id;
		}

		/* filter by neighbor */
		if (req->neighbor.addr.aid != AID_UNSPEC &&
		    memcmp(&req->neighbor.addr, &ctl.remote_addr,
		    sizeof(ctl.remote_addr)) != 0) 
			continue;
		/* filter by AF */
		if (req->aid && req->aid != ctl.prefix.aid)
			return;
		/* filter by prefix */
		if (req->prefix.aid != AID_UNSPEC) {
			if (!prefix_compare(&req->prefix, &ctl.prefix,
			    req->prefixlen)) {
				if (req->flags & F_LONGER) {
					if (req->prefixlen > ctl.prefixlen)
						return;
				} else if (req->prefixlen != ctl.prefixlen)
					return;
			} else
				return;
		}
		/* filter by AS */
		if (req->as.type != AS_NONE &&
		   !aspath_match(mre->aspath, mre->aspath_len,
		   &req->as, req->as.as))
			continue;

		if (req->flags & F_CTL_DETAIL) {
			show_rib_detail(&ctl, mre->aspath, 1);
			for (j = 0; j < mre->nattrs; j++)
				show_attr(mre->attrs[j].attr,
					mre->attrs[j].attr_len);
		} else
			show_rib_brief(&ctl, mre->aspath);
	}
}

void
network_mrt_dump(struct mrt_rib *mr, struct mrt_peer *mp, void *arg)
{
	struct ctl_show_rib		 ctl;
	struct network_config		 net;
	struct ctl_show_rib_request	*req = arg;
	struct mrt_rib_entry		*mre;
	struct ibuf			*msg;
	u_int16_t			 i, j;

	for (i = 0; i < mr->nentries; i++) {
		mre = &mr->entries[i];
		bzero(&ctl, sizeof(ctl));
		mrt_to_bgpd_addr(&mr->prefix, &ctl.prefix);
		ctl.prefixlen = mr->prefixlen;
		ctl.lastchange = mre->originated;
		mrt_to_bgpd_addr(&mre->nexthop, &ctl.true_nexthop);
		mrt_to_bgpd_addr(&mre->nexthop, &ctl.exit_nexthop);
		ctl.origin = mre->origin;
		ctl.local_pref = mre->local_pref;
		ctl.med = mre->med;
		ctl.aspath_len = mre->aspath_len;

		if (mre->peer_idx < mp->npeers) {
			mrt_to_bgpd_addr(&mp->peers[mre->peer_idx].addr,
			    &ctl.remote_addr);
			ctl.remote_id = mp->peers[mre->peer_idx].bgp_id;
		}

		/* filter by neighbor */
		if (req->neighbor.addr.aid != AID_UNSPEC &&
		    memcmp(&req->neighbor.addr, &ctl.remote_addr,
		    sizeof(ctl.remote_addr)) != 0) 
			continue;
		/* filter by AF */
		if (req->aid && req->aid != ctl.prefix.aid)
			return;
		/* filter by prefix */
		if (req->prefix.aid != AID_UNSPEC) {
			if (!prefix_compare(&req->prefix, &ctl.prefix,
			    req->prefixlen)) {
				if (req->flags & F_LONGER) {
					if (req->prefixlen > ctl.prefixlen)
						return;
				} else if (req->prefixlen != ctl.prefixlen)
					return;
			} else
				return;
		}
		/* filter by AS */
		if (req->as.type != AS_NONE &&
		   !aspath_match(mre->aspath, mre->aspath_len,
		   &req->as, req->as.as))
			continue;

		bzero(&net, sizeof(net));
		memcpy(&net.prefix, &ctl.prefix, sizeof(net.prefix));
		net.prefixlen = ctl.prefixlen;
		net.type = NETWORK_MRTCLONE;
		/* XXX rtableid */

		imsg_compose(ibuf, IMSG_NETWORK_ADD, 0, 0, -1,
		    &net, sizeof(net));
		if ((msg = imsg_create(ibuf, IMSG_NETWORK_ASPATH,
		    0, 0, sizeof(ctl) + mre->aspath_len)) == NULL)
			errx(1, "imsg_create failure");
		if (imsg_add(msg, &ctl, sizeof(ctl)) == -1 ||
		    imsg_add(msg, mre->aspath, mre->aspath_len) == -1)
			errx(1, "imsg_add failure");
		imsg_close(ibuf, msg);
		for (j = 0; j < mre->nattrs; j++)
			imsg_compose(ibuf, IMSG_NETWORK_ATTR, 0, 0, -1,
			    mre->attrs[j].attr, mre->attrs[j].attr_len);
		imsg_compose(ibuf, IMSG_NETWORK_DONE, 0, 0, -1, NULL, 0);

		while (ibuf->w.queued) {
			if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
				err(1, "write error");
		}
	}
}

void
show_mrt_state(struct mrt_bgp_state *ms, void *arg)
{
	struct bgpd_addr src, dst;

	mrt_to_bgpd_addr(&ms->src, &src);
	mrt_to_bgpd_addr(&ms->dst, &dst);
	printf("%s[%u] -> ", log_addr(&src), ms->src_as);
	printf("%s[%u]: %s -> %s\n", log_addr(&dst), ms->dst_as,
	    statenames[ms->old_state], statenames[ms->new_state]);
}

void
show_mrt_msg(struct mrt_bgp_msg *mm, void *arg)
{
	struct bgpd_addr src, dst;

	mrt_to_bgpd_addr(&mm->src, &src);
	mrt_to_bgpd_addr(&mm->dst, &dst);
	printf("%s[%u] -> ", log_addr(&src), mm->src_as);
	printf("%s[%u]: size %u\n", log_addr(&dst), mm->dst_as, mm->msg_len);
}

void
mrt_to_bgpd_addr(union mrt_addr *ma, struct bgpd_addr *ba)
{
	switch (ma->sa.sa_family) {
	case AF_INET:
	case AF_INET6:
		sa2addr(&ma->sa, ba);
		break;
	case AF_VPNv4:
		bzero(ba, sizeof(*ba));
		ba->aid = AID_VPN_IPv4;
		ba->vpn4.rd = ma->svpn4.sv_rd;
		ba->vpn4.addr.s_addr = ma->svpn4.sv_addr.s_addr;
		memcpy(ba->vpn4.labelstack, ma->svpn4.sv_label,
		    sizeof(ba->vpn4.labelstack));
		break;
	}
}

const char *
msg_type(u_int8_t type)
{
	if (type >= sizeof(msgtypenames)/sizeof(msgtypenames[0]))
		return "BAD";
	return (msgtypenames[type]);
}
@


1.192
log
@cleanup log* functions that break with bgpd reacharound
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.191 2017/01/13 18:59:12 phessler Exp $ */
a101 9
/*
 * XXX Your Mission, Should You Choose To Accept It
 * is to get rid of the reacharound into bgpd XXX
 */
__dead void fatal(const char *, ...)
	__attribute__((__format__ (printf, 1, 2)));
__dead void fatalx(const char *, ...)
	__attribute__((__format__ (printf, 1, 2)));

a2015 22

/* XXX get rid of the reacharound XXX */
void
fatal(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	verr(1, emsg, ap);
	va_end(ap);
}

void
fatalx(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	verrx(1, emsg, ap);
	va_end(ap);
}

@


1.191
log
@Add support for draft-ietf-idr-shutdown

    BGP state = Idle, marked down with shutdown reason "goodbye, we are
    upgrading to openbsd 6.1", down for 00:00:17

developed by Peter van Dijk <peter.van.dijk@@powerdns.com> and Job
Snijders <job@@ntt.net>, thank you!

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.190 2016/10/14 16:05:35 phessler Exp $ */
a40 1
#include "log.h"
d102 9
d2026 1
a2026 1
/* following functions are necessary for the imsg framework */
d2028 1
a2028 1
log_warnx(const char *emsg, ...)
d2033 1
a2033 11
	vwarnx(emsg, ap);
	va_end(ap);
}

void
log_warn(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vwarn(emsg, ap);
d2038 1
a2038 1
fatal(const char *emsg, ...)
d2043 1
a2043 1
	verr(1, emsg, ap);
a2046 5
void
fatalx(const char *emsg)
{
	errx(1, "%s", emsg);
}
@


1.190
log
@Add support for draft-ietf-idr-large-community

Joint work with Job Snijders, many thanks!
OK benno@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.189 2016/10/14 09:40:54 phessler Exp $ */
d165 1
d726 7
d767 4
@


1.189
log
@when looking at the details of a prefix, show any unknown attributes and
what we know about it.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.188 2016/06/03 17:36:37 benno Exp $ */
d5 2
d87 1
d260 7
d288 5
d395 5
d1448 5
d1543 23
@


1.188
log
@Add operators =, !=, - (range), >< (exclsive range) to the as-path
filters (AS, peer-as, source-as, transit-as).

Add a use case (block illegal AS numbers) to the bgpd.conf example.

feedback from claudio, sthen, florian,
ok florian@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.187 2015/12/05 13:17:05 claudio Exp $ */
d1396 1
d1452 3
d1457 18
@


1.187
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.186 2015/11/01 21:20:46 benno Exp $ */
d1791 1
a1791 1
		   req->as.type, req->as.as))
d1856 1
a1856 1
		   req->as.type, req->as.as))
@


1.186
log
@pledge in bgpctl.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.185 2015/10/24 11:54:50 claudio Exp $ */
d403 1
a403 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.185
log
@Implement the missing bits to parse the other MRT message types.
Printing bgp messages is still missing lots but at least it is a start.
I onced abused tcpdump's bgp protocol handler for this but that is an ugly hack.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.184 2015/10/24 11:41:03 claudio Exp $ */
d127 3
d157 3
d173 3
@


1.184
log
@Print if a route is redistributed or not at least for static & connected.
With phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.183 2015/10/11 19:53:57 sthen Exp $ */
d89 1
a89 1
static const char	*get_errstr(u_int8_t, u_int8_t);
d96 1
d1619 1
a1619 1
static const char *
d1880 7
a1886 1
	printf("show_mrt_state\n");
d1892 6
a1897 1
	printf("show_mrt_msg\n");
d1919 9
a1927 1
/* following functions are necessary for imsg framework */
@


1.183
log
@Handle the blackhole well-known community in bgpctl as well (print it
symbolically, and don't deny its use in 'bgpctl sh rib comm 65535:6666').
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.182 2015/09/16 20:25:41 stsp Exp $ */
d903 2
a904 1
	printf("       N = BGP Nexthop reachable via this route\n");
d946 5
d960 1
a960 1
	printf("  ");
@


1.182
log
@Another ifmedia64 fix, this time for bgpd's ift2ifm().
And rename struct kif's media_type to if_type to avoid confusion with
ifmedia's media type. Same rename in other daemons will follow.
ok claudio henning benno
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.181 2015/09/13 11:13:12 deraadt Exp $ */
d1468 3
@


1.181
log
@match a few if_media uint64_t conversions; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.180 2015/07/19 06:57:27 guenther Exp $ */
d70 1
a70 1
int		 ift2ifm(int);
d72 1
a72 1
const char *	 get_linkstate(uint64_t, int);
d1064 1
a1064 1
			    p->kif.media_type, p->kif.link_state)) == -1)
d1098 2
a1099 2
int
ift2ifm(int media_type)
d1101 1
a1101 1
	switch (media_type) {
d1128 1
a1128 1
get_linkstate(uint64_t media_type, int link_state)
d1134 1
a1134 1
		if (LINK_STATE_DESC_MATCH(p, media_type, link_state))
d1166 1
a1166 1
	int		 ifms_type;
d1175 1
a1175 1
		if ((ifms_type = ift2ifm(k->media_type)) != 0)
d1178 1
a1178 1
		printf("%s", get_linkstate(k->media_type, k->link_state));
@


1.180
log
@Match change to fatal()'s prototype in bgpd

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.179 2015/07/18 16:12:03 claudio Exp $ */
d71 2
a72 2
const char *	 get_media_descr(int);
const char *	 get_linkstate(int, int);
d1116 1
a1116 1
get_media_descr(int media_type)
d1128 1
a1128 1
get_linkstate(int media_type, int link_state)
@


1.179
log
@Tag dynamic routes with a D so I do not get confused when seeing dynamic
routes because of PMTU in the show fib output.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.178 2015/04/17 07:51:09 phessler Exp $ */
d1920 1
a1920 1
fatal(const char *emsg)
d1922 5
a1926 1
	err(1, "%s", emsg);
@


1.178
log
@parse_prefix in parse.c got changed but the declaration in bgpctl.c
wasn't updated, so we would crash when doing `bgpctl net bulk` commands.

Fix by moving parse_prefix into a header, since we use it in more than
one file.

crash found by henning@@
underlying problem found by blambert@@

OK sthen@@ deraadt@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.177 2015/02/11 23:47:25 phessler Exp $ */
d901 2
a902 1
	printf("flags: * = valid, B = BGP, C = Connected, S = Static\n");
d935 2
@


1.177
log
@show if we are using a transport security mechanism other than "none"

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.176 2015/02/04 23:30:37 henning Exp $ */
a98 3
/* parser.c */
int		 parse_prefix(const char *, struct bgpd_addr *, u_int8_t *);

d1692 1
a1692 1
				parse_prefix(b, &h, &len);
@


1.176
log
@potential double free in while-loop
Benjamin Baier <ben at netzbasis dot de>
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.174 2014/03/18 13:47:14 florian Exp $ */
d97 1
d623 20
d694 1
a694 1
		printf("  BGP version 4, remote router-id %s\n",
d696 1
@


1.175
log
@bgpctl show summary output: enlarge columns for 4-byte ASN display
diff by Gregor Best (gbe AT ring0 DOT de), i just tweaked the column
calculation based on comments from claudio@@

ok sthen@@ henning@@
@
text
@a1655 1
		lbuf = NULL;
d1657 1
@


1.174
log
@Correctly parse attribute length form imsg. While there don't assign
data twice.
From rivo nurges ris _AT_ estpak _DOT_ ee, thanks!
OK sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.173 2013/11/13 22:52:41 sthen Exp $ */
d520 2
d528 12
a539 4
		if (strlen(s) >= 20)
			s[20] = 0;
		printf("%-20s %8s %10llu %10llu %5u %-8s ",
		    s, log_as(p->conf.remote_as),
@


1.173
log
@handle msgbuf_write() returning EAGAIN, looks right to deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.172 2013/10/09 08:56:38 phessler Exp $ */
a1348 1
	data = b;
d1364 1
a1364 1
		alen = data[2];
@


1.172
log
@Allow us to bulk add / delete routes with the same attributes.  Really
useful for distributing IP lists.

OK beck@@, claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.171 2013/08/18 16:32:24 guenther Exp $ */
d27 1
d391 1
a391 1
		if (msgbuf_write(&ibuf->w) < 0)
d1830 1
a1830 1
			if (msgbuf_write(&ibuf->w) < 0)
@


1.171
log
@Fix calls to printf-like functions which passed a non-fixed string
as the format and no variable args.
Replace "%#0.*X" with "%#.*X": the zero-fill flag is ignored/implied
on numeric conversions when a precision is specified.

ok jung@@ millert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.170 2013/04/09 14:51:33 gilles Exp $ */
d27 1
d95 4
d322 6
d463 2
d1632 55
@


1.170
log
@do not store a time_t or the result of a time_t division in an int

prompted by deraadt@@, ok claudio@@ chl@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.169 2013/03/07 21:28:34 claudio Exp $ */
d1822 1
a1822 1
	err(1, emsg);
d1828 1
a1828 1
	errx(1, emsg);
@


1.169
log
@Implement a bgpctl nei foo destroy that will remove the specified cloned
neighbor. The neighbor must be set down before calling this function.
OK phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.168 2012/11/27 05:38:08 guenther Exp $ */
d827 2
a828 1
	unsigned int	 sec, min, hrs, day, week;
d846 1
a846 1
		snprintf(buf, TF_LEN, "%02uw%01ud%02uh", week, day, hrs);
@


1.168
log
@Fix type typo

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.167 2012/11/15 19:55:08 sthen Exp $ */
d313 4
d443 1
d633 1
a633 1
		if (p->conf.cloned)
d1612 3
a1614 2
			errx(1, "illegal error code %u", rescode);
		printf("%s\n", ctl_res_strerror[rescode]);
@


1.167
log
@If max-prefix/restart are used, display the values in "bgpctl sh nei" output.
ok henning claudio benno
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.166 2012/09/18 10:11:23 claudio Exp $ */
d794 1
a794 1
print_timer(const char *name, timer_t d)
@


1.166
log
@Print the wieght in the show rib detail output. OK sthen@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.165 2012/09/12 05:57:10 claudio Exp $ */
d637 7
@


1.165
log
@bgpctl bits for the GR support added to bgpd.
OK sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.164 2012/05/27 18:53:50 claudio Exp $ */
d1300 2
a1301 2
	printf("    Origin %s, metric %u, localpref %u, ",
	    print_origin(r->origin, 0), r->med, r->local_pref);
d1626 1
@


1.164
log
@Make it possible to load mrt table dumps into bgpd. This is a debug tool but
it  allows anyone to use MRT table dumps to load prefixes into a bgpd instance.
For example you can download the RIPE dumps and load full-feeds onto your
laptop until the poor thing dies.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.163 2011/09/21 10:37:51 claudio Exp $ */
d55 1
d172 1
a172 1
		/* not reached */
d652 1
a652 1
		    p->capa.peer.restart || p->capa.peer.as4byte) {
d661 5
a665 2
			if (p->capa.peer.restart)
				printf("    Graceful Restart\n");
d733 22
d782 2
d1138 2
a1139 2
	printf(
	    "flags: * = Valid, > = Selected, I = via IBGP, A = Announced\n");
d1183 2
d1196 2
@


1.163
log
@Make it possible to parse MRT table dumps (all 3 formats) and display
them like the show rib / show rib detail output. It is also possible
to filter the output. e.g.
   bgpctl show mrt file ./bview.20110914.1600 as 22512 204.209.0.0/16 all
OK sthen@@, put it in henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.162 2011/09/21 08:52:55 claudio Exp $ */
d89 1
d96 1
d343 19
d450 1
d1626 1
a1626 1
			return;
d1635 82
@


1.162
log
@Unbreak the tree. I forgot to add a fatalx() stub to bgpctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.161 2010/09/02 14:03:21 sobrado Exp $ */
d40 1
d78 3
d88 4
d94 1
d240 1
a240 2
		memcpy(&ribreq.neighbor, &neighbor,
		    sizeof(ribreq.neighbor));
d248 21
d428 1
a1156 1
	char			*aspath;
a1161 6

		print_prefix(&rib.prefix, rib.prefixlen, rib.flags);
		printf(" %-15s ", log_addr(&rib.exit_nexthop));

		printf(" %5u %5u ", rib.local_pref, rib.med);

d1164 1
a1164 7
		if (aspath_asprint(&aspath, asdata, rib.aspath_len) == -1)
			err(1, NULL);
		if (strlen(aspath) > 0)
			printf("%s ", aspath);
		free(aspath);

		printf("%s\n", print_origin(rib.origin, 1));
d1179 2
a1180 7
	struct in_addr		 id;
	char			*aspath, *s;
	u_char			*data;
	u_int32_t		 as;
	u_int16_t		 ilen, alen, ioff;
	u_int8_t		 flags, type;
	time_t			 now;
d1185 3
a1187 31

		printf("\nBGP routing table entry for %s/%u\n",
		    log_addr(&rib.prefix), rib.prefixlen);

		data = imsg->data;
		data += sizeof(struct ctl_show_rib);
		if (aspath_asprint(&aspath, data, rib.aspath_len) == -1)
			err(1, NULL);
		if (strlen(aspath) > 0)
			printf("    %s\n", aspath);
		free(aspath);

		s = fmt_peer(rib.descr, &rib.remote_addr, -1, nodescr);
		printf("    Nexthop %s ", log_addr(&rib.exit_nexthop));
		printf("(via %s) from %s (", log_addr(&rib.true_nexthop), s);
		free(s);
		id.s_addr = htonl(rib.remote_id);
		printf("%s)\n", inet_ntoa(id));

		printf("    Origin %s, metric %u, localpref %u, ",
		    print_origin(rib.origin, 0), rib.med, rib.local_pref);
		print_flags(rib.flags, 0);

		now = time(NULL);
		if (now > rib.lastchange)
			now -= rib.lastchange;
		else
			now = 0;

		printf("\n    Last update: %s ago\n",
		    fmt_timeframe_core(now));
d1193 1
a1193 55
		data = imsg->data;
		flags = data[0];
		type = data[1];

		/* get the attribute length */
		if (flags & ATTR_EXTLEN) {
			if (ilen < 4)
				errx(1, "bad IMSG_CTL_SHOW_RIB_ATTR received");
			memcpy(&alen, data+2, sizeof(u_int16_t));
			alen = ntohs(alen);
			data += 4;
			ilen -= 4;
		} else {
			alen = data[2];
			data += 3;
			ilen -= 3;
		}
		/* bad imsg len how can that happen!? */
		if (alen != ilen)
			errx(1, "bad IMSG_CTL_SHOW_RIB_ATTR received");

		switch (type) {
		case ATTR_COMMUNITIES:
			printf("    Communities: ");
			show_community(data, alen);
			printf("\n");
			break;
		case ATTR_AGGREGATOR:
			memcpy(&as, data, sizeof(as));
			memcpy(&id, data + sizeof(as), sizeof(id));
			printf("    Aggregator: %s [%s]\n",
			    log_as(ntohl(as)), inet_ntoa(id));
			break;
		case ATTR_ORIGINATOR_ID:
			memcpy(&id, data, sizeof(id));
			printf("    Originator Id: %s\n", inet_ntoa(id));
			break;
		case ATTR_CLUSTER_LIST:
			printf("    Cluster ID List:");
			for (ioff = 0; ioff + sizeof(id) <= ilen;
			    ioff += sizeof(id)) {
				memcpy(&id, data + ioff, sizeof(id));
				printf(" %s", inet_ntoa(id));
			}
			printf("\n");
			break;
		case ATTR_EXT_COMMUNITIES:
			printf("    Ext. communities: ");
			show_ext_community(data, alen);
			printf("\n");
			break;
		default:
			/* ignore unknown attributes */
			break;
		}
d1205 2
a1206 2
char *
fmt_mem(int64_t num)
d1208 5
a1212 1
	static char	buf[16];
d1214 5
a1218 2
	if (fmt_scaled(num, buf) == -1)
		snprintf(buf, sizeof(buf), "%lldB", (long long)num);
d1220 1
a1220 1
	return (buf);
d1223 35
a1257 1
size_t  pt_sizes[AID_MAX] = AID_PTSIZE;
d1259 2
a1260 2
int
show_rib_memory_msg(struct imsg *imsg)
d1262 26
a1287 3
	struct rde_memstats	stats;
	size_t			pts = 0;
	int			i;
d1289 26
a1314 11
	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_RIB_MEM:
		memcpy(&stats, imsg->data, sizeof(stats));
		printf("RDE memory statistics\n");
		for (i = 0; i < AID_MAX; i++) {
			if (stats.pt_cnt[i] == 0)
				continue;
			pts += stats.pt_cnt[i] * pt_sizes[i];
			printf("%10lld %s network entries using %s of memory\n",
			    (long long)stats.pt_cnt[i], aid_vals[i].name,
			    fmt_mem(stats.pt_cnt[i] * pt_sizes[i]));
d1316 6
a1321 26
		printf("%10lld rib entries using %s of memory\n",
		    (long long)stats.rib_cnt, fmt_mem(stats.rib_cnt *
		    sizeof(struct rib_entry)));
		printf("%10lld prefix entries using %s of memory\n",
		    (long long)stats.prefix_cnt, fmt_mem(stats.prefix_cnt *
		    sizeof(struct prefix)));
		printf("%10lld BGP path attribute entries using %s of memory\n",
		    (long long)stats.path_cnt, fmt_mem(stats.path_cnt *
		    sizeof(struct rde_aspath)));
		printf("%10lld BGP AS-PATH attribute entries using "
		    "%s of memory,\n\t   and holding %lld references\n",
		    (long long)stats.aspath_cnt, fmt_mem(stats.aspath_size),
		    (long long)stats.aspath_refs);
		printf("%10lld BGP attributes entries using %s of memory\n",
		    (long long)stats.attr_cnt, fmt_mem(stats.attr_cnt *
		    sizeof(struct attr)));
		printf("\t   and holding %lld references\n",
		    (long long)stats.attr_refs);
		printf("%10lld BGP attributes using %s of memory\n",
		    (long long)stats.attr_dcnt, fmt_mem(stats.attr_data));
		printf("RIB using %s of memory\n", fmt_mem(pts +
		    stats.prefix_cnt * sizeof(struct prefix) +
		    stats.rib_cnt * sizeof(struct rib_entry) +
		    stats.path_cnt * sizeof(struct rde_aspath) +
		    stats.aspath_size + stats.attr_cnt * sizeof(struct attr) +
		    stats.attr_data));
d1324 1
a1326 2

	return (1);
d1418 66
d1551 94
@


1.161
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.160 2010/05/26 13:56:07 nicm Exp $ */
d1524 6
@


1.160
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.159 2010/05/03 13:11:41 claudio Exp $ */
d927 1
a927 1
			if (asprintf(&s, "%s (%s%s)", p->kif.ifname, 
d1239 1
a1239 1
			printf("    Aggregator: %s [%s]\n", 
d1419 1
a1419 1
			printf("%s 0x%llx", log_ext_subtype(subtype), ext); 
d1423 1
a1423 1
			printf("0x%llx", betoh64(ext)); 
@


1.159
log
@Adjustments for multiple kroute table support. This adds a few new command
arguments (show tables and show fib table 1, etc).
Tested by sthen@@, OK to move on by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.158 2010/04/13 09:10:50 claudio Exp $ */
d171 1
a171 1
			struct buf	*msg;
@


1.158
log
@Sync with last bgpd commit, there are no AF_INET and AF_INET6 specific
kroute messages anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.157 2010/03/08 17:02:19 claudio Exp $ */
d59 1
d175 3
a177 2
			if ((msg = imsg_create(ibuf, IMSG_CTL_KROUTE, 0, 0,
			    sizeof(res->flags) + sizeof(af))) == NULL)
d185 2
a186 2
			imsg_compose(ibuf, IMSG_CTL_KROUTE_ADDR, 0, 0, -1,
			    &res->addr, sizeof(res->addr));
d189 4
d194 2
a195 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_NEXTHOP, 0, 0, -1, NULL, 0);
d251 2
a252 1
		imsg_compose(ibuf, IMSG_CTL_FIB_COUPLE, 0, 0, -1, NULL, 0);
d257 2
a258 1
		imsg_compose(ibuf, IMSG_CTL_FIB_DECOUPLE, 0, 0, -1, NULL, 0);
d354 2
a382 3
			case NETWORK_SHOW:
				done = show_fib_msg(&imsg);
				break;
d772 6
d822 1
d847 10
d1099 1
a1099 1
		if (flags & F_RIB_ANNOUNCE)
d1101 1
a1101 1
		if (flags & F_RIB_INTERNAL)
d1103 1
a1103 1
		if (flags & F_RIB_ELIGIBLE)
d1105 1
a1105 1
		if (flags & F_RIB_ACTIVE)
d1110 1
a1110 1
		if (flags & F_RIB_INTERNAL)
d1114 1
a1114 1
		if (flags & F_RIB_ELIGIBLE)
d1116 1
a1116 1
		if (flags & F_RIB_ACTIVE)
d1118 1
a1118 1
		if (flags & F_RIB_ANNOUNCE)
@


1.157
log
@res.flags is not only used by the irrfilter so initializing them with
irrfilter flags is causing strange behaviour on other commands (like show fib).
Set the IPV4 and IPV6 flags at the end unless one of them got already set.
OK henning, sthen, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.156 2010/02/11 12:25:12 claudio Exp $ */
d807 1
a807 2
	struct kroute		*k;
	struct kroute6		*k6;
d813 1
a813 1
		if (imsg->hdr.len < IMSG_HEADER_SIZE + sizeof(struct kroute))
d815 1
a815 1
		k = imsg->data;
d817 1
a817 1
		show_fib_flags(k->flags);
d819 2
a820 2
		if (asprintf(&p, "%s/%u", inet_ntoa(k->prefix), k->prefixlen) ==
		    -1)
d822 1
a822 1
		printf("%4i %-20s ", k->priority, p);
d825 4
a828 25
		if (k->nexthop.s_addr)
			printf("%s", inet_ntoa(k->nexthop));
		else if (k->flags & F_CONNECTED)
			printf("link#%u", k->ifindex);
		printf("\n");

		break;
	case IMSG_CTL_KROUTE6:
	case IMSG_CTL_SHOW_NETWORK6:
		if (imsg->hdr.len < IMSG_HEADER_SIZE + sizeof(struct kroute6))
			errx(1, "wrong imsg len");
		k6 = imsg->data;

		show_fib_flags(k6->flags);

		if (asprintf(&p, "%s/%u", log_in6addr(&k6->prefix),
		    k6->prefixlen) == -1)
			err(1, NULL);
		printf("%4i %-20s ", k6->priority, p);
		free(p);

		if (!IN6_IS_ADDR_UNSPECIFIED(&k6->nexthop))
			printf("%s", log_in6addr(&k6->nexthop));
		else if (k6->flags & F_CONNECTED)
			printf("link#%u", k6->ifindex);
a833 1
		break;
@


1.156
log
@Force a space between address and nexthop. IPv6 is overflowing all size
restrictions and 2001:4bf8:bad:beef::/64fe80::20a:e4ff:fe39:5583 is not
acceptable.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.155 2010/01/10 00:16:23 claudio Exp $ */
d130 3
a132 1
	if (res->action == IRRFILTER)
d134 1
@


1.155
log
@ribreq uses now a AID, use AID also on the parsing side and convert to
AF when necessary. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.154 2009/12/16 15:42:19 claudio Exp $ */
d1056 1
a1056 1
	printf("%-5s %-20s%-15s  %5s %5s %s\n", "flags", "destination",
d1130 1
a1130 1
		printf("%-15s ", log_addr(&rib.exit_nexthop));
@


1.154
log
@Use log_ext_subtype() instead of the homebrew version (which actually got
moved to bgpd but that does not matter).
OK henning and sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.153 2009/12/08 17:36:12 claudio Exp $ */
d168 1
d170 1
d172 1
a172 1
			    sizeof(res->flags) + sizeof(res->af))) == NULL)
d176 1
a176 1
			    imsg_add(msg, &res->af, sizeof(res->af)) == -1)
d224 1
a224 1
		ribreq.af = res->af;
d294 1
a294 1
		ribreq.af = res->af;
@


1.153
log
@Must byte-swap extended community data before printing since it is in
network byte order. Found and tested by Pete Vickers.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.152 2009/12/08 15:10:29 claudio Exp $ */
a76 1
const char	*get_ext_subtype(u_int8_t);
a1373 24
const char *
get_ext_subtype(u_int8_t type)
{
	static char etype[6];

	switch (type) {
	case EXT_COMMUNITY_ROUTE_TGT:
		return "rt";	/* route target */
	case EXT_CUMMUNITY_ROUTE_ORIG:
		return "soo";	/* source of origin */
	case EXT_COMMUNITY_OSPF_DOM_ID:
		return "odi";	/* ospf domain id */
	case EXT_COMMUNITY_OSPF_RTR_TYPE:
		return "ort";	/* ospf route type */
	case EXT_COMMUNITY_OSPF_RTR_ID:
		return "ori";	/* ospf router id */
	case EXT_COMMUNITY_BGP_COLLECT:
		return "bdc";	/* bgp data collection */
	default:
		snprintf(etype, sizeof(etype), "[%i]", (int)type);
		return etype;
	}
}

d1394 1
a1394 1
			printf("%s %s:%u", get_ext_subtype(subtype),
d1400 1
a1400 1
			printf("%s %s:%hu", get_ext_subtype(subtype),
d1406 1
a1406 1
			printf("%s %s:%hu", get_ext_subtype(subtype),
d1412 1
a1412 1
			printf("%s 0x%llx", get_ext_subtype(subtype), ext); 
@


1.152
log
@Split out some code into own function to make the code a bit nicer.
OK henning@@ upon his request
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.151 2009/12/08 14:04:54 claudio Exp $ */
d1234 1
a1234 1
			    log_as(htonl(as)), inet_ntoa(id));
d1419 2
a1420 1
			printf("%s %hu:%u", get_ext_subtype(subtype), as2, u32);
d1426 1
a1426 1
			    inet_ntoa(ip), u16);
d1432 1
a1432 1
			    log_as(as4), u16);
@


1.151
log
@Big AID change part 2 bgpctl part. Cope with the changes in bgpd, more to
follow.  OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.150 2009/12/01 14:29:40 claudio Exp $ */
d53 1
d535 1
a535 1
	int			 comma, hascapamp = 0;
d589 1
a589 1
			if (hascapamp)
d591 2
a592 6
			for (i = 0, comma = 0; i < AID_MAX; i++) {
				if (p->capa.peer.mp[i]) {
					printf("%s%s", comma ? ", " : "",
					    aid2str(i));
					comma = 1;
				}
a593 2
			if (hascapamp)
				printf("\n");
d649 13
@


1.150
log
@Update code to use the new AID address ids so that this works again with
bgpd. Reads OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.149 2009/11/02 20:38:45 claudio Exp $ */
a52 1
void		 print_neighbor_capa_mp_safi(u_int8_t);
d534 2
d582 5
a586 3
		if (p->capa.peer.mp_v4 || p->capa.peer.mp_v6 ||
		    p->capa.peer.refresh || p->capa.peer.restart ||
		    p->capa.peer.as4byte) {
d588 8
a595 7
			if (p->capa.peer.mp_v4) {
				printf("    Multiprotocol extensions: IPv4");
				print_neighbor_capa_mp_safi(p->capa.peer.mp_v4);
			}
			if (p->capa.peer.mp_v6) {
				printf("    Multiprotocol extensions: IPv6");
				print_neighbor_capa_mp_safi(p->capa.peer.mp_v6);
d597 2
a653 17
}

void
print_neighbor_capa_mp_safi(u_int8_t safi)
{
	switch (safi) {
	case SAFI_UNICAST:
		printf(" Unicast");
		break;
	case SAFI_MULTICAST:
		printf(" Multicast");
		break;
	default:
		printf(" unknown (%u)", safi);
		break;
	}
	printf("\n");
@


1.149
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging. henning, sthen, michele like the idea
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.148 2009/10/23 16:00:28 claudio Exp $ */
d167 1
a167 1
		if (!res->addr.af) {
d195 1
a195 1
		if (res->peeraddr.af || res->peerdesc[0])
d209 1
a209 1
		if (res->addr.af) {
d412 2
a413 2
	if (masklen != -1 && ((remote_addr->af == AF_INET && masklen != 32) ||
	    (remote_addr->af == AF_INET6 && masklen != 128))) {
d539 1
a539 1
		if ((p->conf.remote_addr.af == AF_INET &&
d541 1
a541 1
		    (p->conf.remote_addr.af == AF_INET6 &&
d887 2
a888 2
		switch (p->addr.af) {
		case AF_INET:
d899 1
a899 1
		case AF_INET6:
d911 1
a911 1
			printf("unknown address familiy %d\n", p->addr.af);
d1283 2
d1289 2
d1296 8
a1303 7
		printf("%10lld IPv4 network entries using %s of memory\n",
		    (long long)stats.pt4_cnt, fmt_mem(stats.pt4_cnt *
		    sizeof(struct pt_entry4)));
		if (stats.pt6_cnt != 0)
			printf("%10lld IPv6 network entries using "
			    "%s of memory\n", (long long)stats.pt6_cnt,
			    fmt_mem(stats.pt6_cnt * sizeof(struct pt_entry6)));
d1324 1
a1324 3
		printf("RIB using %s of memory\n", fmt_mem(
		    stats.pt4_cnt * sizeof(struct pt_entry4) +
		    stats.pt6_cnt * sizeof(struct pt_entry6) +
@


1.148
log
@errx -> err since the errno is set.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.147 2009/09/15 09:45:12 sthen Exp $ */
d101 1
a101 1
	int			 fd, n, done, ch, nodescr = 0;
d299 9
d385 2
@


1.147
log
@In bgpctl sh nei, display whether a neighbour is set to use passive
mode and/or E-BGP multihop. Ok and suggestions from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.146 2009/09/14 11:49:25 claudio Exp $ */
d307 1
a307 1
			errx(1, "imsg_read error");
d313 1
a313 1
				errx(1, "imsg_get error");
@


1.146
log
@Switch the various link state printing codes to use the new if_media
independent LINK_STATE_DESCRIPTIONS. Code is now more or less a one to
one copy of get_linkstate() in route/route.c.
OK henning, michele, sthen, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.145 2009/07/23 14:55:25 claudio Exp $ */
d552 4
@


1.145
log
@Update bgpctl show next to show all necessary info. This time OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.144 2009/07/21 11:49:36 henning Exp $ */
a862 1
	int			 ifms_type;
d901 7
a907 13
			ifms_type = ift2ifm(p->kif.media_type);
			if (LINK_STATE_IS_UP(p->kif.link_state)) {
				if (p->kif.baudrate) {
					if (asprintf(&s1, ", %s",
					    get_baudrate(p->kif.baudrate,
					    "bps")) == -1)
						err(1, NULL);
				} else if (asprintf(&s1, ", %s", get_linkstate(
				    ifms_type, p->kif.link_state)) == -1)
						err(1, NULL);
			} else if (ifms_type)
				if (asprintf(&s1, ", %s", get_linkstate(
				    ifms_type, p->kif.link_state)) == -1)
d936 2
a937 3
const int	ifm_status_valid_list[] = IFM_STATUS_VALID_LIST;
const struct ifmedia_status_description
		ifm_status_descriptions[] = IFM_STATUS_DESCRIPTIONS;
d973 2
a974 2
	const struct ifmedia_status_description	*p;
	int					 i;
d976 6
a981 14
	if (link_state == LINK_STATE_UNKNOWN)
		return ("unknown");

	for (i = 0; ifm_status_valid_list[i] != 0; i++)
		for (p = ifm_status_descriptions; p->ifms_valid != 0; p++) {
			if (p->ifms_type != media_type ||
			    p->ifms_valid != ifm_status_valid_list[i])
				continue;
			if (LINK_STATE_IS_UP(link_state))
				return (p->ifms_string[1]);
			return (p->ifms_string[0]);
		}

	return ("unknown link state");
d1019 3
a1021 6
			printf("%s, %s", get_media_descr(ifms_type),
			    get_linkstate(ifms_type, k->link_state));
		else if (k->link_state == LINK_STATE_UNKNOWN)
			printf("unknown");
		else
			printf("link state %u", k->link_state);
d1023 1
a1023 1
		if (k->link_state != LINK_STATE_DOWN && k->baudrate > 0) {
a1024 1
		}
@


1.144
log
@sorry, but showing a diff, getting an explicit "not ok" and then committing
anyway without oks is not our process
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.142 2009/06/06 06:33:15 eric Exp $ */
d68 1
a68 1
void		 print_baudrate(u_int64_t);
d851 3
a853 1
	printf("%-20s %-10s\n", "Nexthop", "State");
d860 3
d868 32
a899 2
		printf("%-20s %-10s", log_addr(&p->addr),
		    p->valid ? "valid" : "invalid");
d901 3
a903 9
			printf("%-8s", p->kif.ifname);
			if (p->kif.flags & IFF_UP) {
				printf("UP");
				ifms_type = ift2ifm(p->kif.media_type);
				if (ifms_type != 0)
					printf(", %s, %s",
					    get_media_descr(ifms_type),
					    get_linkstate(ifms_type,
					    p->kif.link_state));
d905 17
a921 4
					printf(", ");
					print_baudrate(p->kif.baudrate);
				}
			}
d1000 2
a1001 2
void
print_baudrate(u_int64_t baudrate)
d1003 2
d1006 2
a1007 1
		printf("%llu GBit/s", baudrate / IF_Gbps(1));
d1009 2
a1010 1
		printf("%llu MBit/s", baudrate / IF_Mbps(1));
d1012 2
a1013 1
		printf("%llu KBit/s", baudrate / IF_Kbps(1));
d1015 4
a1018 1
		printf("%llu Bit/s", baudrate);
d1043 1
a1043 2
			printf(", ");
			print_baudrate(k->baudrate);
@


1.143
log
@Try to show a more usable nexthop output. It may still change but at least
it is better than what we had till now and syncs up with the last bgpd change.
@
text
@d851 1
a851 2
	printf("%-20s %-20s %-10s %-10s %s\n", "Nexthop", "Gateway", "State",
	    "Interface", "Link State");
d863 1
a863 3
		printf("%-20s ", log_addr(&p->addr));
		printf("%-20s %-10s ",
		    p->connected ? "connected" : log_addr(&p->gateway),
d866 1
a866 1
			printf("%-10s ", p->kif.ifname);
d868 1
d870 4
a873 2
				if (ifms_type)
					printf("%s", get_linkstate(ifms_type,
d875 5
a879 4
				else
					printf("up, unknown");
			} else
				printf("admin down");
@


1.142
log
@sync bgpd/bgpctl with the common imsg code, making it lib ready as well.

ok claudio@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.141 2009/06/06 06:05:41 claudio Exp $ */
d851 2
a852 1
	printf("%-20s %-10s\n", "Nexthop", "State");
d864 3
a866 1
		printf("%-20s %-10s", log_addr(&p->addr),
d869 1
a869 1
			printf("%-8s", p->kif.ifname);
a870 1
				printf("UP");
d872 2
a873 4
				if (ifms_type != 0)
					printf(", %s, %s",
					    get_media_descr(ifms_type),
					    get_linkstate(ifms_type,
d875 4
a878 5
				if (p->kif.baudrate) {
					printf(", ");
					print_baudrate(p->kif.baudrate);
				}
			}
@


1.141
log
@bgpctl part of allowing alternate RIBs to be shown. Had to use the
keyword table because show rib rib foo is strange.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.140 2009/05/17 13:23:08 claudio Exp $ */
d177 1
a177 2
			if (imsg_close(ibuf, msg) < 0)
				errx(1, "imsg_close error");
@


1.140
log
@Adjust for IMSG_CTL_SHOW_NETWORK change in the RDE. IMSG_CTL_SHOW_NETWORK is
now using the same payload as IMSG_CTL_SHOW_RIB.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.139 2009/05/17 12:27:16 claudio Exp $ */
d223 1
d295 1
@


1.139
log
@Adjust show rib memory output after the monster commit to bgpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.138 2009/02/01 17:21:21 sobrado Exp $ */
d292 2
d295 1
a295 1
		    &res->af, sizeof(res->af));
@


1.138
log
@embellish the output of bgpctl(8).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.137 2008/12/12 23:15:39 claudio Exp $ */
d1252 3
d1276 1
@


1.137
log
@Make bgpctl priority aware.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.136 2008/12/10 23:57:10 sthen Exp $ */
d413 1
a413 1
	printf("%-20s %-8s %-10s %-10s %-5s %-8s %s\n", "Neighbor", "AS",
@


1.136
log
@convert the aggregator's AS number into host byte order when
displayed in "show rib detail".

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.135 2008/12/06 13:18:12 sobrado Exp $ */
d741 1
a741 1
	printf("flags destination          gateway\n");
d804 1
a804 1
		printf("%-20s ", p);
d825 1
a825 1
		printf("%-20s ", p);
@


1.135
log
@the ellipsis allows more than one argument being specified.

discussed with gilles@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.134 2008/06/07 20:23:15 henning Exp $ */
d1189 2
a1190 2
			printf("    Aggregator: %s [%s]\n", log_as(as),
			   inet_ntoa(id));
@


1.134
log
@repair usage, jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.133 2008/06/07 18:14:41 henning Exp $ */
d92 2
a93 2
	fprintf(stderr, "usage: %s [-n] [-s socket] "
	    "command [arguments ...]\n", __progname);
@


1.133
log
@teach the command lineparser about getopt style options after commands
use that for irrfilter mode.
hints from theo a year ago, code by me a year ago, ok claudio a year ago
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.132 2008/02/24 21:02:11 claudio Exp $ */
d92 2
a93 2
	fprintf(stderr, "usage: %s [-s socket] [-n] "
	    "<command> [arg [...]]\n", __progname);
@


1.132
log
@Add missing space when printing ext. communities.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.131 2008/01/23 08:18:11 claudio Exp $ */
a45 1
__dead void	 usage(void);
d92 2
a93 2
	fprintf(stderr, "usage: %s [-n] [-o directory] [-s socket] "
	    "command [arguments ...]\n", __progname);
d107 1
a107 1
	char			*sockname, *outdir;
d111 1
a111 2
	outdir = getcwd(NULL, 0);
	while ((ch = getopt(argc, argv, "no:s:")) != -1) {
a116 3
		case 'o':
			outdir = optarg;
			break;
d132 1
a132 1
		irr_main(res->as.as, res->flags, outdir);
@


1.131
log
@extend bgpctl show rib detail output to include more attributes in the output.
In addition to communities bgpctl now prints the aggregator, originator id,
cluster list and extended communities if available.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.130 2007/12/23 18:26:13 henning Exp $ */
d1211 1
a1211 1
			printf("    Ext. communities:");
@


1.130
log
@send timers for bgpctlshow neighbor foo timer in seperate messages after
the peer data. makes bgpctl display code independent from timer
implementation internals. only running timers are displayed now, stopped
ones are skipped.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.129 2007/12/20 17:08:48 henning Exp $ */
d78 2
d1120 2
a1121 1
	u_int16_t		 ilen, alen;
d1163 1
a1163 1
			break;
d1167 40
a1206 12
		if (type == ATTR_COMMUNITIES) {
			if (flags & ATTR_EXTLEN) {
				if (ilen < 4)
					break;
				memcpy(&alen, data+2, sizeof(u_int16_t));
				alen = ntohs(alen);
				data += 4;
				ilen -= 4;
			} else {
				alen = data[2];
				data += 3;
				ilen -= 3;
a1207 4
			if (alen != ilen)
				break;
			printf("    Community: ");
			show_community(data, alen);
d1209 9
d1326 72
@


1.129
log
@rework timers.
stop changing tienmr values directly, always use new
timer_(get/set/stop/running) functions. preparation for more to come :)
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.128 2007/10/15 02:16:35 deraadt Exp $ */
d56 1
a56 2
void		 print_neighbor_timers(struct peer *);
void		 print_timer(const char *, struct peer *, enum Timer, u_int);
d198 1
d521 1
d586 1
a586 3
		switch (nv) {
		case NV_DEFAULT:
			print_neighbor_msgstats(p);
d588 1
a588 4
		case NV_TIMERS:
			print_neighbor_timers(p);
			break;
		}
d620 5
d683 1
a683 1
print_neighbor_timers(struct peer *p)
a684 13
	print_timer("IdleHoldTimer:", p, Timer_IdleHold, p->IdleHoldTime);
	print_timer("ConnectRetryTimer:", p, Timer_ConnectRetry,
	    INTERVAL_CONNECTRETRY);
	print_timer("HoldTimer:", p, Timer_Hold, (u_int)p->holdtime);
	print_timer("KeepaliveTimer:", p, Timer_Keepalive, (u_int)p->holdtime/3);
}

void
print_timer(const char *name, struct peer *p, enum Timer timer, u_int interval)
{
	time_t	d;
	int	running = timer_running(p, timer, &d);

d687 2
a688 4
	if (running == 0)
		printf("%-20s", "not running");
	else if (d <= 0)
		printf("%-20s", "due");
d690 1
a690 3
		printf("due in %-13s", fmt_timeframe_core(d));

	printf("Interval: %5us\n", interval);
@


1.128
log
@specifying int instead of just unsigned is better style
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.127 2007/09/11 17:08:49 henning Exp $ */
d57 1
a57 1
void		 print_timer(const char *, time_t, u_int);
d684 2
a685 2
	print_timer("IdleHoldTimer:", p->IdleHoldTimer, p->IdleHoldTime);
	print_timer("ConnectRetryTimer:", p->ConnectRetryTimer,
d687 2
a688 2
	print_timer("HoldTimer:", p->HoldTimer, (u_int)p->holdtime);
	print_timer("KeepaliveTimer:", p->KeepaliveTimer, (u_int)p->holdtime/3);
d692 1
a692 1
print_timer(const char *name, time_t val, u_int interval)
d694 2
a695 1
	int	d;
a696 1
	d = val - time(NULL);
d699 1
a699 1
	if (val == 0)
@


1.127
log
@baudrate is 64bit now, plus print w/ %llu
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.126 2007/08/06 19:16:06 sobrado Exp $ */
d727 1
a727 1
	unsigned	 sec, min, hrs, day, week;
@


1.126
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.125 2007/05/31 04:21:43 claudio Exp $ */
d70 1
a70 1
void		 print_baudrate(u_long);
d975 1
a975 1
print_baudrate(u_long baudrate)
d978 1
a978 1
		printf("%lu GBit/s", baudrate / IF_Gbps(1));
d980 1
a980 1
		printf("%lu MBit/s", baudrate / IF_Mbps(1));
d982 1
a982 1
		printf("%lu KBit/s", baudrate / IF_Kbps(1));
d984 1
a984 1
		printf("%lu Bit/s", baudrate);
@


1.125
log
@Use COMMUNITY_UNSET in bgpctl as well. This makes it possible to filter
on communities with 0 in them.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.124 2007/05/30 01:13:19 otto Exp $ */
d92 2
a93 2
	fprintf(stderr, "usage: %s [-s socket] [-o path] [-n] "
	    "<command> [arg [...]]\n", __progname);
@


1.124
log
@bad henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.123 2007/04/23 13:05:35 claudio Exp $ */
d218 2
a219 1
		if (res->community.as != 0 && res->community.type != 0) {
@


1.123
log
@bgpctl needs to know about 4-byte AS numbers as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.122 2007/04/06 18:36:32 claudio Exp $ */
a929 2
	case IFT_ISO88025:
		return (IFM_TOKEN);
@


1.122
log
@Implement "bgpctl show neighbor <peer> terse" this will print all statistics
in an easily parseable form. This output can be used to implement SNMP MIBs
or rrdtool/mrtg update scripts. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.121 2007/04/06 18:14:48 claudio Exp $ */
d415 2
a416 2
	printf("%-20s %-5s %-10s %-10s %-5s %-8s %s\n", "Neighbor", "AS",
	    "MsgRcvd", "MsgSent", "OutQ", "Up/Down", "State/PrefixRcvd");
d432 2
a433 2
		printf("%-20s %5u %10llu %10llu %5u %-8s ",
		    s, p->conf.remote_as,
d473 1
a473 1
		printf("%s %u %s\n", s, p->conf.remote_as,
d545 1
a545 1
			printf("remote AS %u", p->conf.remote_as);
d565 2
a566 1
		    p->capa.peer.refresh || p->capa.peer.restart) {
d580 2
@


1.121
log
@Include update statistics in the bgpctl show neighbor output.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.120 2007/03/31 12:46:55 henning Exp $ */
d52 1
d198 1
d345 3
d476 30
@


1.120
log
@some KNF, partially pt out by  rivo nurges <rix@@estpak.ee>
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.119 2007/03/28 12:34:08 henning Exp $ */
d627 1
a627 1
	printf("  %-15s %10llu %10llu\n", "Total",
d634 6
@


1.119
log
@add support for bgpctl show rib community <community>
mostly from rivo nurges <rix@@estpak.ee>, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.118 2007/03/16 20:48:38 claudio Exp $ */
d217 2
a218 2
		    memcpy(&ribreq.community, &res->community,
				sizeof(res->community));
@


1.118
log
@Missed to remove SAFI_BOTH here. Informed about it by Steven Mestdagh.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.117 2007/03/03 12:43:08 henning Exp $ */
d215 5
@


1.117
log
@allow the directory for generated filter files to be set. defaults to cwd
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.116 2007/03/03 11:45:30 henning Exp $ */
a598 3
		break;
	case SAFI_BOTH:
		printf(" Unicast and Multicast");
@


1.116
log
@add irrfilter mode.
generates bgpd filter rules from the Internet Routing Registry aka IRR aka
the aut-num, as-set and route objects in the RIPE, ARIN, APNIC ... databases
accessed via whois, using the Routing Policy Specificaion Language RPSL.
implement the whois query interface, an RPSL parser (of course only the
parts we need), recursive as-set resolver, prefixes per AS lookup,
and an ouput module to make up the rules.
work in progress, not ready for general consumption yet.
import agreed by theo & claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.115 2007/02/22 08:38:19 henning Exp $ */
d91 1
a91 1
	fprintf(stderr, "usage: %s [-s socket] [-n] "
d111 1
a111 1
	while ((ch = getopt(argc, argv, "ns:")) != -1) {
d116 3
@


1.115
log
@minor KNF bits here too
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.114 2007/02/02 15:53:39 claudio Exp $ */
d39 1
d106 1
a106 1
	char			*sockname;
d110 1
d131 3
d155 1
d361 1
@


1.114
log
@Print neighbor templates with a state of Template. Makes the difference
between templates and real sessions more obvious. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.113 2007/01/27 19:03:07 claudio Exp $ */
d485 2
a486 1
			if ((s = strdup(log_addr(&p->conf.remote_addr))) == NULL)
@


1.113
log
@Make sure that the graceful restart capability is printed in any case.
The printf() was only reachable if one of the other capabilities were set.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.112 2006/11/28 19:21:15 reyk Exp $ */
d426 3
a428 1
		} else
d454 1
a454 1
		    statenames[p->state]);
@


1.112
log
@add additional link states to report the half duplex / full duplex
state, if known by the driver. this is required to check the full
duplex state without depending on the ifmedia ioctl which can't be
called in the kernel without process context.

ok henning@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.111 2006/11/10 14:46:46 henning Exp $ */
d512 1
a512 1
		    p->capa.peer.refresh) {
@


1.111
log
@cast to (long long) for %lld printfs
apparently from Jeff Rizzo <riz@@NetBSD.org> via "Thomas E. Spanjaard"
<tgen@@netphreax.net>, with changes from me (as far as I remember, this is
kinda old stuff). claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.110 2006/08/28 05:28:49 henning Exp $ */
d908 3
a910 1
			return (p->ifms_string[link_state == LINK_STATE_UP]);
@


1.110
log
@indicate when the peer announced the Graceful Restart capability, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.109 2006/08/23 08:21:11 claudio Exp $ */
d1156 1
a1156 1
		snprintf(buf, sizeof(buf), "%lldB", num);
d1171 1
a1171 1
		    stats.pt4_cnt, fmt_mem(stats.pt4_cnt *
d1175 1
a1175 1
			    "%s of memory\n", stats.pt6_cnt,
d1178 1
a1178 1
		    stats.prefix_cnt, fmt_mem(stats.prefix_cnt *
d1181 1
a1181 1
		    stats.path_cnt, fmt_mem(stats.path_cnt *
d1185 2
a1186 2
		    stats.aspath_cnt, fmt_mem(stats.aspath_size),
		    stats.aspath_refs);
d1188 1
a1188 1
		    stats.attr_cnt, fmt_mem(stats.attr_cnt *
d1190 2
a1191 1
		printf("\t   and holding %lld references\n", stats.attr_refs);
d1193 1
a1193 1
		    stats.attr_dcnt, fmt_mem(stats.attr_data));
@


1.109
log
@Extend show rib command. Following new options are added:
 in: show the unfiltered input of a neighbor aka adj-rib-in
 out: show only the prefixes that are sent to a specified neighbor (adj-rib-out)
 neighbor <IP>: limit the output of the command to prefixes sent by the
                specified neighbor

OK henning@@ manpage with help by jmc@@ but the show rib section needs some
rework because it starts to be confusing. Actually the parser needs to get
smarter.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.108 2006/07/25 09:38:05 henning Exp $ */
d524 2
@


1.108
log
@kill redundant prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.107 2006/06/15 10:05:18 claudio Exp $ */
d129 1
a129 1
	memcpy(&neighbor.addr, &res->addr, sizeof(neighbor.addr));
d188 1
a188 1
		if (res->addr.af || res->peerdesc[0])
d207 2
@


1.107
log
@Use new struct ctl_show_rib_request for show rib requests. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.106 2006/06/14 17:10:42 claudio Exp $ */
a81 3
void		 log_warnx(const char *, ...);
void		 log_warn(const char *, ...);
void		 fatal(const char *);
@


1.106
log
@bgpctl show rib shows now the exit nexthop per default and not the true
nexthop as before. The detailed output includes both nexthops. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.105 2006/05/27 21:25:06 claudio Exp $ */
d107 1
d109 1
d199 14
a212 15
		if (res->as.type != AS_NONE)
			imsg_compose(ibuf, IMSG_CTL_SHOW_RIB_AS, 0, 0, -1,
			    &res->as, sizeof(res->as));
		else if (res->addr.af) {
			struct ctl_show_rib_prefix	msg;

			bzero(&msg, sizeof(msg));
			memcpy(&msg.prefix, &res->addr, sizeof(res->addr));
			msg.prefixlen = res->prefixlen;
			msg.flags = res->flags;
			imsg_compose(ibuf, IMSG_CTL_SHOW_RIB_PREFIX, 0, 0, -1,
			    &msg, sizeof(msg));
		} else
			imsg_compose(ibuf, IMSG_CTL_SHOW_RIB, 0, 0, -1,
			    &res->af, sizeof(res->af));
@


1.105
log
@Wait for a response from bgpd on reloads.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.104 2006/05/23 12:14:34 henning Exp $ */
d1042 1
a1042 1
		printf("%-15s ", log_addr(&rib.nexthop));
d1092 2
a1093 1
		printf("    Nexthop %s from %s (", log_addr(&rib.nexthop), s);
@


1.104
log
@support requesting route refresh from a neighbor
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.103 2006/04/06 12:33:17 claudio Exp $ */
a220 1
		done = 1;
@


1.103
log
@Add missing break. Now bgpctl show rib det source-as 8271 shows all announced
prefixes not only the first one.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.102 2006/03/22 10:25:49 claudio Exp $ */
d251 4
d347 1
@


1.102
log
@Detailed RIB output including communities. Detailed output is enabled via
the "detailed" keyword. Currently only works for IP or prefix lookups like
"bgpctl show rib detail 199.185.137.3". Requested by many, looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.101 2006/03/22 09:05:40 claudio Exp $ */
d1132 1
@


1.101
log
@Change fmt_peer() so that it can be used by the upcomming detailed RIB output.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.100 2006/01/24 15:28:03 henning Exp $ */
d73 1
d75 2
d212 2
a213 1
		show_rib_summary_head();
d327 5
a331 1
				done = show_rib_summary_msg(&imsg);
a970 1
	char			 flagstr[5];
d973 1
a973 11
	p = flagstr;
	if (flags & F_RIB_ANNOUNCE)
		*p++ = 'A';
	if (flags & F_RIB_INTERNAL)
		*p++ = 'I';
	if (flags & F_RIB_ELIGIBLE)
		*p++ = '*';
	if (flags & F_RIB_ACTIVE)
		*p++ = '>';
	*p = '\0';

d976 1
a976 1
	printf("%-5s %-20s", flagstr, p);
d995 31
d1061 81
d1198 40
@


1.100
log
@introduce "bgpctl show summary terse", shows summary in an easy to parse
format, intended for monitoring puposes. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.99 2006/01/24 10:01:14 henning Exp $ */
d47 1
a47 1
char		*fmt_peer(const struct peer_config *, int);
d355 2
a356 1
fmt_peer(const struct peer_config *peer, int nodescr)
d361 2
a362 2
	if (peer->descr[0] && !nodescr) {
		if ((p = strdup(peer->descr)) == NULL)
d367 4
a370 4
	ip = log_addr(&peer->remote_addr);
	if ((peer->remote_addr.af == AF_INET && peer->remote_masklen != 32) ||
	    (peer->remote_addr.af == AF_INET6 && peer->remote_masklen != 128)) {
		if (asprintf(&p, "%s/%u", ip, peer->remote_masklen) == -1)
d396 2
a397 1
		s = fmt_peer(&p->conf, nodescr);
d437 2
a438 1
		s = fmt_peer(&p->conf, nodescr);
@


1.99
log
@make bgpctl deal with IMSG_CTL_RESULT no matter what request was sent
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.98 2006/01/05 16:01:09 claudio Exp $ */
d50 1
d155 3
d304 3
d415 23
@


1.98
log
@Show attribute cache total reference count.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.97 2006/01/04 12:46:52 claudio Exp $ */
d288 7
a327 2
				done = show_result(&imsg);
				break;
@


1.97
log
@Use new BGP attribute counter.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.96 2006/01/03 22:51:14 claudio Exp $ */
d1035 1
@


1.96
log
@Show RIB statistics via "bgpctl show rib mem".
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.95 2006/01/03 22:20:59 claudio Exp $ */
d1036 1
a1036 1
		    stats.attr_cnt, fmt_mem(stats.attr_data));
@


1.95
log
@Cope with new util.c
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.94 2006/01/03 22:05:13 claudio Exp $ */
d32 1
d73 2
d207 3
d311 3
a959 1

d993 57
@


1.94
log
@Don't use fatal() and friend in bgpctl. The log system does not work here.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.93 2005/11/17 11:14:51 henning Exp $ */
d75 3
d1054 27
@


1.93
log
@missing strdup() check, From: David Hill <dhill@@mindcry.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.92 2005/10/19 12:32:17 henning Exp $ */
d135 1
a135 1
		fatal(NULL);
d338 1
a338 1
			fatal(NULL);
d346 1
a346 1
			fatal(NULL);
d349 1
a349 1
			fatal(NULL);
@


1.92
log
@for "bgpctl neighbor foo up/down/clear", make bgpctl not exit after sending
the request, but wait for the new IMSG_CTL_RESULT message, which contains
a status code to indicate wether the request was processed successfully
or wether an error occured and if so what kind of error.
no more "IMSG_CTL_NEIGHBOR_ with unknown neighbor foobaz" in the log
when you mistyped foobar - no bgpctl itself complains
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.91 2005/09/20 14:40:32 henning Exp $ */
d421 2
a422 1
			s = strdup(log_addr(&p->conf.remote_addr));
@


1.91
log
@allow "show rib" to be limited to an address family too
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.90 2005/09/20 13:51:05 henning Exp $ */
d74 1
a224 2
		printf("request sent.\n");
		done = 1;
a228 2
		printf("request sent.\n");
		done = 1;
a232 2
		printf("request sent.\n");
		done = 1;
d305 6
a315 4
			case NEIGHBOR:
			case NEIGHBOR_UP:
			case NEIGHBOR_DOWN:
			case NEIGHBOR_CLEAR:
d1029 21
@


1.90
log
@don't try to print v6 nexthops as v4 address
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.89 2005/09/20 13:31:53 henning Exp $ */
d197 1
a197 1
			    NULL, 0);
@


1.89
log
@let "bgpctl network show" print v6 addresses correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.88 2005/07/01 18:59:14 fgsch Exp $ */
d757 1
a757 1
		printf("%-20s %-10s", inet_ntoa(p->addr.v4),
@


1.88
log
@fix breakage; if this proves to be wrong, will be fixed later. at least
make build will work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.87 2005/06/13 08:16:30 claudio Exp $ */
d263 2
a264 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_NETWORK, 0, 0, -1, NULL, 0);
d712 1
@


1.87
log
@Properly align the show rib output. flags is 5 chars long not 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.86 2005/06/10 08:30:38 claudio Exp $ */
d989 1
a989 1
	while ((s = SIMPLEQ_FIRST(set)) != NULL) {
d992 1
a992 1
		SIMPLEQ_REMOVE_HEAD(set, entry);
@


1.86
log
@As we no longer send IMSG_CTL_SHOW_RIB_PREFIX from bgpd to bgpctl simplify
show_rib_summary_msg().
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.85 2005/06/07 17:45:28 claudio Exp $ */
d906 1
a906 1
	printf("%-4s %-20s%-15s  %5s %5s %s\n", "flags", "destination",
d929 1
a929 1
	printf("%-4s %-20s", flagstr, p);
@


1.85
log
@For show rib -- show_rib_summary_msg() and print_prefix() -- use log_addr()
to print prefixes and nexthops and suddenly we can print IPv6 addresses that
are stored in the RIB. Makes the code even simpler. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.84 2005/06/06 17:15:07 henning Exp $ */
a947 2
char			*aspath = NULL;
struct ctl_show_rib	*rib = NULL;
d952 3
a954 2
	struct ctl_show_rib_prefix	*p;
	u_char				*asdata;
d958 1
a958 8
		if (rib != NULL) {
			free(rib);
			rib = NULL;
		}
		if (aspath != NULL) {
			free(aspath);
			aspath = NULL;
		}
d960 2
a961 3
		if ((rib = malloc(imsg->hdr.len - IMSG_HEADER_SIZE)) == NULL)
			err(1, NULL);
		memcpy(rib, imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE);
d963 1
a963 4
		print_prefix(&rib->prefix, rib->prefixlen, rib->flags);
		printf("%-15s ", log_addr(&rib->nexthop));

		printf(" %5u %5u ", rib->local_pref, rib->med);
d967 1
a967 1
		if (aspath_asprint(&aspath, asdata, rib->aspath_len) == -1)
d971 1
d973 1
a973 17
		printf("%s\n", print_origin(rib->origin, 1));
		break;
	case IMSG_CTL_SHOW_RIB_PREFIX:
		p = imsg->data;
		if (rib == NULL)
			/* unexpected packet */
			return (0);

		print_prefix(&p->prefix, p->prefixlen, p->flags);
		printf("%-15s ", log_addr(&rib->nexthop));

		printf(" %5u %5u ", rib->local_pref, rib->med);

		if (strlen(aspath) > 0)
			printf("%s ", aspath);

		printf("%s\n", print_origin(rib->origin, 1));
a975 9
		if (rib != NULL) {
			free(rib);
			rib = NULL;
		}
		if (aspath != NULL) {
			free(aspath);
			aspath = NULL;
		}

a977 9
		if (rib != NULL) {
			free(rib);
			rib = NULL;
		}
		if (aspath != NULL) {
			free(aspath);
			aspath = NULL;
		}

@


1.84
log
@allow show fib to be limited to inet or inet6 families, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.83 2005/06/06 00:00:33 henning Exp $ */
d927 1
a927 1
	if (asprintf(&p, "%s/%u", inet_ntoa(prefix->v4), prefixlen) == -1)
d973 1
a973 1
		printf("%-15s ", inet_ntoa(rib->nexthop.v4));
d993 1
a993 1
		printf("%-15s ", inet_ntoa(rib->nexthop.v4));
@


1.83
log
@let "show fib" print out both the v4 and the v6 routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.82 2005/06/05 00:24:18 henning Exp $ */
d148 13
a160 4
		if (!res->addr.af)
			imsg_compose(ibuf, IMSG_CTL_KROUTE, 0, 0, -1,
			    &res->flags, sizeof(res->flags));
		else
@


1.82
log
@print the error for the last notification sent when we're IDLE in the
neighbor detail display
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.81 2005/06/04 23:38:07 henning Exp $ */
d58 1
d638 34
d676 1
d686 1
a686 27
		if (k->flags & F_DOWN)
			printf(" ");
		else
			printf("*");

		if (k->flags & F_BGPD_INSERTED)
			printf("B");
		else if (k->flags & F_CONNECTED)
			printf("C");
		else if (k->flags & F_STATIC)
			printf("S");
		else
			printf(" ");

		if (k->flags & F_NEXTHOP)
			printf("N");
		else
			printf(" ");

		if (k->flags & F_REJECT && k->flags & F_BLACKHOLE)
			printf("f");
		else if (k->flags & F_REJECT)
			printf("r");
		else if (k->flags & F_BLACKHOLE)
			printf("b");
		else
			printf(" ");
a687 1
		printf("  ");
d698 20
@


1.81
log
@do not print the tcp connection details when the session is IDLE, we
have no connection in that case
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.80 2005/05/27 17:10:29 claudio Exp $ */
d72 1
d464 8
a471 1
		if (p->state != STATE_IDLE) {
d1004 34
@


1.80
log
@Add a flag for specifying the socket to open to talk to bgpd.
Needed for upcomming spamd madness.  Requested and OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.79 2005/05/23 20:08:59 claudio Exp $ */
d463 10
a472 8
		if (getnameinfo((struct sockaddr *)&p->sa_local,
		    (socklen_t)p->sa_local.ss_len,
		    buf, sizeof(buf), pbuf, sizeof(pbuf),
		    NI_NUMERICHOST | NI_NUMERICSERV)) {
			strlcpy(buf, "(unknown)", sizeof(buf));
			strlcpy(pbuf, "", sizeof(pbuf));
		}
		printf("  Local host:  %20s, Local port:  %5s\n", buf, pbuf);
d474 10
a483 6
		if (getnameinfo((struct sockaddr *)&p->sa_remote,
		    (socklen_t)p->sa_remote.ss_len,
		    buf, sizeof(buf), pbuf, sizeof(pbuf),
		    NI_NUMERICHOST | NI_NUMERICSERV)) {
			strlcpy(buf, "(unknown)", sizeof(buf));
			strlcpy(pbuf, "", sizeof(pbuf));
a484 2
		printf("  Remote host: %20s, Remote port: %5s\n", buf, pbuf);
		printf("\n");
@


1.79
log
@Make it possible to dynamicaly add networks with attributes like communities
or metrics. Requested by beck@@ OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.78 2005/04/18 11:09:51 claudio Exp $ */
d80 2
a81 1
	fprintf(stderr, "usage: %s [-n] <command> [arg [...]]\n", __progname);
d94 1
d96 2
a97 1
	while ((ch = getopt(argc, argv, "n")) != -1) {
d103 3
d125 3
a127 1
	strlcpy(sun.sun_path, SOCKET_NAME, sizeof(sun.sun_path));
d129 1
a129 1
		err(1, "connect: %s", SOCKET_NAME);
@


1.78
log
@Static routes are flagged with F_STATIC and not with F_KERNEL. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.77 2005/04/13 08:35:22 claudio Exp $ */
d71 1
d229 1
d969 13
@


1.77
log
@Show if a route is rejected or blackholed in show fib output. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.76 2005/03/14 12:36:27 henning Exp $ */
d637 1
a637 1
		else if (k->flags & F_KERNEL)
@


1.76
log
@add IFT_/IFM_IEE80211 to ift2ifm so we can pretty-print link state and
such for those as well, pointed out by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.75 2005/03/14 12:26:37 henning Exp $ */
d603 2
a604 1
	printf("       N = BGP Nexthop reachable via this route\n\n");
d647 10
a656 1
		printf("   ");
@


1.75
log
@print interface and some stuff about it with the nexthops so it is easier
to see why a nexthop is treated invalid, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.74 2005/02/09 12:35:20 claudio Exp $ */
d741 2
@


1.74
log
@need to send IMSG_NETWORK_DONE after sending networks announcement.
Similar to the fix commited by henning@@ a few hours ago. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.73 2005/02/02 18:52:32 henning Exp $ */
d62 1
d673 1
a673 1
	printf("%-20s %s\n", "Nexthop", "State");
d680 1
d685 1
a685 1
		printf("%-20s %s\n", inet_ntoa(p->addr.v4),
d687 17
d729 17
a790 1

a802 17
		switch (k->media_type) {
		case IFT_ETHER:
			ifms_type = IFM_ETHER;
			break;
		case IFT_FDDI:
			ifms_type = IFM_FDDI;
			break;
		case IFT_ISO88025:
			ifms_type = IFM_TOKEN;
			break;
		case IFT_CARP:
			ifms_type = IFM_CARP;
			break;
		default:
			ifms_type = 0;
			break;
		}
d804 1
a804 1
		if (ifms_type)
@


1.73
log
@usage() is __dead
pt out by Alexander v Gernler
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.72 2004/12/23 17:55:59 henning Exp $ */
d224 1
a224 1
		if (res->action == NETWORK_ADD)
d227 3
a229 1
		else
@


1.72
log
@allo the "bgpctl show neighbor " commands to take the neighbor descr
too, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.71 2004/12/23 17:26:51 henning Exp $ */
d44 1
a44 1
void		 usage(void);
d73 1
a73 1
void
@


1.71
log
@allow "bgpctl neighbor" to take the peer's descr as argument as well
as its address
so "bgpctl neighbor upstream1 clear" now works and you don't have to
remember IPs
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.70 2004/11/18 16:57:28 henning Exp $ */
d154 1
a154 1
		if (res->addr.af)
d156 1
a156 1
			    &res->addr, sizeof(res->addr));
@


1.70
log
@cope with changes in capabilities announcement shitz
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.69 2004/11/02 11:46:17 henning Exp $ */
d90 1
d109 3
d202 1
a202 1
		    &res->addr, sizeof(res->addr));
d208 1
a208 1
		    &res->addr, sizeof(res->addr));
d214 1
a214 1
		    &res->addr, sizeof(res->addr));
@


1.69
log
@now that carp media descriptions are available through the ifmedia framework
print carp interface status correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.68 2004/10/26 13:12:22 henning Exp $ */
d422 2
a423 1
		if (p->capa.mp_v4 || p->capa.mp_v6 || p->capa.refresh) {
d425 1
a425 1
			if (p->capa.mp_v4) {
d427 1
a427 1
				print_neighbor_capa_mp_safi(p->capa.mp_v4);
d429 1
a429 1
			if (p->capa.mp_v6) {
d431 1
a431 1
				print_neighbor_capa_mp_safi(p->capa.mp_v6);
d433 1
a433 1
			if (p->capa.refresh)
@


1.68
log
@ease the parser a bit.
parse() now wants the first argv member to be the first argument it parses,
i. e. it does not skip over argv[0] any more, caller has to account for that.
the caller does the usual getopt followed by argv += optind; argc -= optind;
dance so this is accounted for.
in parse() don't use a seperate curarg counter, just in/decrease argv/argc
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.67 2004/10/26 11:46:08 henning Exp $ */
d770 3
@


1.67
log
@in the "show summary" view print the peer descr instead of the IP (if a descr
is given in the config, fall back to IP otherwise)
new -n switch to force display of IPs
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.65 2004/09/23 02:05:29 henning Exp $ */
d102 2
a103 2
	argc -= (optind - 1);
	argv += (optind - 1);
@


1.66
log
@do /%u instead of /%6u for max_prefix, looks better, claudio ok
@
text
@d46 1
d48 1
a48 1
int		 show_summary_msg(struct imsg *);
d78 1
a78 1
	fprintf(stderr, "usage: %s <command> [arg [...]]\n", __progname);
d86 1
a86 1
	int			 fd, n, done;
d91 14
d258 1
a258 1
				done = show_summary_msg(&imsg);
d304 25
d337 1
a337 1
show_summary_msg(struct imsg *imsg)
d345 3
a347 13
		if ((p->conf.remote_addr.af == AF_INET &&
		    p->conf.remote_masklen != 32) ||
		    (p->conf.remote_addr.af == AF_INET6 &&
		    p->conf.remote_masklen != 128)) {
			if (asprintf(&s, "%s/%u",
			    log_addr(&p->conf.remote_addr),
			    p->conf.remote_masklen) == -1)
				err(1, NULL);
		} else
			if ((s = strdup(log_addr(&p->conf.remote_addr))) ==
			    NULL)
				err(1, NULL);

@


1.65
log
@cosmetics
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.64 2004/09/21 18:29:47 claudio Exp $ */
d331 1
a331 1
				printf("/%6u", p->conf.max_prefix);
@


1.64
log
@Don't pad the prefix count with 0. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.63 2004/09/16 22:36:18 henning Exp $ */
d331 1
a331 1
				printf("/%u", p->conf.max_prefix);
@


1.63
log
@malloc ibuf instead of having it statically
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.62 2004/09/16 17:40:10 henning Exp $ */
d329 1
a329 1
			printf("%06u", p->stats.prefix_cnt);
@


1.62
log
@cope with imsg API change
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.61 2004/08/20 15:49:35 henning Exp $ */
d70 1
a70 1
struct imsgbuf	ibuf;
d102 3
a104 1
	imsg_init(&ibuf, fd);
d113 1
a113 1
		imsg_compose(&ibuf, IMSG_CTL_SHOW_NEIGHBOR, 0, 0, -1, NULL, 0);
d118 1
a118 1
			imsg_compose(&ibuf, IMSG_CTL_KROUTE, 0, 0, -1,
d121 1
a121 1
			imsg_compose(&ibuf, IMSG_CTL_KROUTE_ADDR, 0, 0, -1,
d126 1
a126 1
		imsg_compose(&ibuf, IMSG_CTL_SHOW_NEXTHOP, 0, 0, -1, NULL, 0);
d130 1
a130 1
		imsg_compose(&ibuf, IMSG_CTL_SHOW_INTERFACE, 0, 0, -1, NULL, 0);
d136 1
a136 1
			imsg_compose(&ibuf, IMSG_CTL_SHOW_NEIGHBOR, 0, 0, -1,
d139 1
a139 1
			imsg_compose(&ibuf, IMSG_CTL_SHOW_NEIGHBOR, 0, 0, -1,
d144 1
a144 1
			imsg_compose(&ibuf, IMSG_CTL_SHOW_RIB_AS, 0, 0, -1,
d153 1
a153 1
			imsg_compose(&ibuf, IMSG_CTL_SHOW_RIB_PREFIX, 0, 0, -1,
d156 1
a156 1
			imsg_compose(&ibuf, IMSG_CTL_SHOW_RIB, 0, 0, -1,
d161 1
a161 1
		imsg_compose(&ibuf, IMSG_CTL_RELOAD, 0, 0, -1, NULL, 0);
d169 1
a169 1
		imsg_compose(&ibuf, IMSG_CTL_FIB_COUPLE, 0, 0, -1, NULL, 0);
d174 1
a174 1
		imsg_compose(&ibuf, IMSG_CTL_FIB_DECOUPLE, 0, 0, -1, NULL, 0);
d182 1
a182 1
		imsg_compose(&ibuf, IMSG_CTL_NEIGHBOR_UP, 0, 0, -1,
d188 1
a188 1
		imsg_compose(&ibuf, IMSG_CTL_NEIGHBOR_DOWN, 0, 0, -1,
d194 1
a194 1
		imsg_compose(&ibuf, IMSG_CTL_NEIGHBOR_CLEAR, 0, 0, -1,
d206 1
a206 1
			imsg_compose(&ibuf, IMSG_NETWORK_ADD, 0, 0, -1,
d209 1
a209 1
			imsg_compose(&ibuf, IMSG_NETWORK_REMOVE, 0, 0, -1,
d215 1
a215 1
		imsg_compose(&ibuf, IMSG_NETWORK_FLUSH, 0, 0, -1, NULL, 0);
d220 1
a220 1
		imsg_compose(&ibuf, IMSG_CTL_SHOW_NETWORK, 0, 0, -1, NULL, 0);
d225 2
a226 2
	while (ibuf.w.queued)
		if (msgbuf_write(&ibuf.w) < 0)
d230 1
a230 1
		if ((n = imsg_read(&ibuf)) == -1)
d236 1
a236 1
			if ((n = imsg_get(&ibuf, &imsg)) == -1)
d284 1
@


1.61
log
@add support for "bgpctl neighbor 1.2.3.4 clear", takes session down & up again
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.60 2004/08/06 11:53:12 claudio Exp $ */
d111 1
a111 1
		imsg_compose(&ibuf, IMSG_CTL_SHOW_NEIGHBOR, 0, NULL, 0);
d116 2
a117 2
			imsg_compose(&ibuf, IMSG_CTL_KROUTE, 0, &res->flags,
			    sizeof(res->flags));
d119 2
a120 2
			imsg_compose(&ibuf, IMSG_CTL_KROUTE_ADDR, 0, &res->addr,
			    sizeof(res->addr));
d124 1
a124 1
		imsg_compose(&ibuf, IMSG_CTL_SHOW_NEXTHOP, 0, NULL, 0);
d128 1
a128 1
		imsg_compose(&ibuf, IMSG_CTL_SHOW_INTERFACE, 0, NULL, 0);
d134 1
a134 1
			imsg_compose(&ibuf, IMSG_CTL_SHOW_NEIGHBOR, 0,
d137 2
a138 1
			imsg_compose(&ibuf, IMSG_CTL_SHOW_NEIGHBOR, 0, NULL, 0);
d142 1
a142 1
			imsg_compose(&ibuf, IMSG_CTL_SHOW_RIB_AS, 0,
d151 1
a151 1
			imsg_compose(&ibuf, IMSG_CTL_SHOW_RIB_PREFIX, 0,
d154 2
a155 1
			imsg_compose(&ibuf, IMSG_CTL_SHOW_RIB, 0, NULL, 0);
d159 1
a159 1
		imsg_compose(&ibuf, IMSG_CTL_RELOAD, 0, NULL, 0);
d167 1
a167 1
		imsg_compose(&ibuf, IMSG_CTL_FIB_COUPLE, 0, NULL, 0);
d172 1
a172 1
		imsg_compose(&ibuf, IMSG_CTL_FIB_DECOUPLE, 0, NULL, 0);
d180 1
a180 1
		imsg_compose(&ibuf, IMSG_CTL_NEIGHBOR_UP, 0,
d186 1
a186 1
		imsg_compose(&ibuf, IMSG_CTL_NEIGHBOR_DOWN, 0,
d192 1
a192 1
		imsg_compose(&ibuf, IMSG_CTL_NEIGHBOR_CLEAR, 0,
d204 1
a204 1
			imsg_compose(&ibuf, IMSG_NETWORK_ADD, 0,
d207 1
a207 1
			imsg_compose(&ibuf, IMSG_NETWORK_REMOVE, 0,
d213 1
a213 1
		imsg_compose(&ibuf, IMSG_NETWORK_FLUSH, 0, NULL, 0);
d218 1
a218 1
		imsg_compose(&ibuf, IMSG_CTL_SHOW_NETWORK, 0, NULL, 0);
d326 1
a326 1
			printf("%u", p->stats.prefix_cnt);
@


1.60
log
@In bgpctl show summary report the current and max prefix count if state is
established. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.59 2004/05/21 11:52:32 claudio Exp $ */
d189 6
d270 1
@


1.59
log
@Make it possible to add, delete, flush and show network announcements.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.58 2004/05/20 12:17:04 henning Exp $ */
d281 1
a281 1
	    "MsgRcvd", "MsgSent", "OutQ", "Up/Down", "State");
d306 1
a306 1
		printf("%-20s %5u %10llu %10llu %5u %-8s %s\n",
d315 8
a322 2
		    fmt_timeframe(p->stats.last_updown),
		    statenames[p->state]);
@


1.58
log
@check for strdup(3) failure was missing in one case, catched by
Andrey Matveev <andrushock@@korovino.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.57 2004/05/06 14:29:12 henning Exp $ */
d56 1
d87 1
d189 24
d253 3
d264 3
d551 7
d566 1
@


1.57
log
@print Multiprotocol capabilities slightly nicer
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.56 2004/05/01 17:08:04 deraadt Exp $ */
d270 3
a272 1
			s = strdup(log_addr(&p->conf.remote_addr));
@


1.56
log
@becuase lint says so; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.55 2004/04/28 00:56:49 henning Exp $ */
d343 1
a343 1
				printf("    Multiprotocol extensions: IPv4:");
d347 1
a347 1
				printf("    Multiprotocol extensions: IPv6:");
d403 1
a403 1
		printf(" Unicast Multicast");
@


1.55
log
@keep route refresh counters into account when building sums, and
print route refresh counters in the neighbor view
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.54 2004/04/27 04:06:10 henning Exp $ */
a286 1
		break;
d364 1
a364 1
		    p->sa_local.ss_len,
d373 1
a373 1
		    p->sa_remote.ss_len,
d442 2
a443 2
	print_timer("HoldTimer:", p->HoldTimer, p->holdtime);
	print_timer("KeepaliveTimer:", p->KeepaliveTimer, p->holdtime/3);
@


1.54
log
@print route refresh capability if present
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.53 2004/04/25 23:31:16 henning Exp $ */
d275 2
a276 1
		    p->stats.msg_rcvd_update + p->stats.msg_rcvd_keepalive,
d278 2
a279 1
		    p->stats.msg_sent_update + p->stats.msg_sent_keepalive,
d426 2
d430 2
a431 1
	    p->stats.msg_sent_update + p->stats.msg_sent_keepalive,
d433 2
a434 1
	    p->stats.msg_rcvd_update + p->stats.msg_rcvd_keepalive);
@


1.53
log
@there's a slight difference between teh local and the remote sockaddr...
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.52 2004/04/25 20:04:37 henning Exp $ */
d339 1
a339 1
		if (p->capa.mp_v4 || p->capa.mp_v6) {
d349 2
@


1.52
log
@correctly pritn netmask with template neighbors, prettify output overall,
and print Template / Cloned flags in the neigbor view, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.51 2004/04/25 18:53:09 henning Exp $ */
d369 2
a370 2
		if (getnameinfo((struct sockaddr *)&p->sa_local,
		    p->sa_local.ss_len,
@


1.51
log
@use getnameinfo here too, itojun & markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.50 2004/04/16 04:41:49 henning Exp $ */
a43 1

d248 1
a248 1
	printf("%-15s %-5s %-10s %-10s %-5s %-8s %s\n", "Neighbor", "AS",
d256 1
d261 13
a273 3
		printf("%-15s %5u %10llu %10llu %5u %-8s %s\n",
		    log_addr(&p->conf.remote_addr),
		    p->conf.remote_as,
d281 1
d298 1
a298 1
	char			 buf[NI_MAXHOST], pbuf[NI_MAXSERV];
d303 11
d315 11
a325 3
		printf("BGP neighbor is %s, remote AS %u\n",
		    log_addr(&p->conf.remote_addr),
		    p->conf.remote_as);
@


1.50
log
@in the neighbor view, add support for local/remote addr beeing v6 ones
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.49 2004/04/13 22:55:01 henning Exp $ */
d25 1
d27 1
d287 1
a287 1
	char			 buf[48];
d330 8
a337 23
		if (inet_ntop(p->sa_local.ss_family, &p->sa_local,
		    buf, sizeof(buf)) == NULL)
			strlcpy(buf, "????????", sizeof(buf));
		if (p->sa_local.ss_family == AF_INET)
			printf("  Local host:   %20s, Local port:   %5u\n",
			    buf, ntohs(((struct sockaddr_in *)
			    &p->sa_local)->sin_port));
		if (p->sa_local.ss_family == AF_INET6)
			printf("  Local host:   %20s, Local port:   %5u\n",
			    buf, ntohs(((struct sockaddr_in6 *)
			    &p->sa_local)->sin6_port));

		if (inet_ntop(p->sa_remote.ss_family, &p->sa_remote,
		    buf, sizeof(buf)) == NULL)
			strlcpy(buf, "????????", sizeof(buf));
		if (p->sa_remote.ss_family == AF_INET)
			printf("  Remote host: %20s, Remote port: %5u\n",
			    buf, ntohs(((struct sockaddr_in *)
			    &p->sa_remote)->sin_port));
		if (p->sa_remote.ss_family == AF_INET6)
			printf("  Remote host: %20s, Remote port: %5u\n",
			    buf, ntohs(((struct sockaddr_in6 *)
			    &p->sa_remote)->sin6_port));
d339 8
@


1.49
log
@print the MP capabilities as the neighbor announced in the show neighbor
display, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.48 2004/03/11 18:56:34 claudio Exp $ */
a283 1
	struct sockaddr_in	*sa_in;
d285 1
d328 4
a331 2
		if (p->sa_local.ss_family == AF_INET) {
			sa_in = (struct sockaddr_in *)&p->sa_local;
d333 19
a351 9
			    inet_ntoa(sa_in->sin_addr),
			    ntohs(sa_in->sin_port));
		}
		if (p->sa_remote.ss_family == AF_INET) {
			sa_in = (struct sockaddr_in *)&p->sa_remote;
			printf("  Foreign host: %20s, Foreign port: %5u\n",
			    inet_ntoa(sa_in->sin_addr),
			    ntohs(sa_in->sin_port));
		}
@


1.48
log
@Plugging memory leaks is OK but don't break intended behaviour. So this time
do it correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.47 2004/03/11 16:39:34 claudio Exp $ */
d48 1
d307 11
d350 20
@


1.47
log
@Use aspath_asprint() instead of this malloc, aspath_snprint() mess. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.46 2004/03/11 15:08:46 claudio Exp $ */
a690 9
	if (rib != NULL) {
		free(rib);
		rib = NULL;
	}
	if (aspath != NULL) {
		free(aspath);
		aspath = NULL;
	}

d693 9
d737 9
a746 1
		break;
d748 9
@


1.46
log
@Plug another memory leak. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.45 2004/03/11 14:49:08 henning Exp $ */
d713 1
a713 2
		aspath = malloc(aspath_strlen(asdata, rib->aspath_len) + 1);
		if (aspath == NULL)
a714 2
		aspath_snprint(aspath, aspath_strlen(asdata,
		    rib->aspath_len) + 1, asdata, rib->aspath_len);
@


1.45
log
@check for malloc failure...
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.44 2004/03/02 20:00:14 henning Exp $ */
d691 9
a701 9
		if (rib != NULL) {
			free(rib);
			rib = NULL;
		}
		if (aspath != NULL) {
			free(aspath);
			aspath = NULL;
		}

@


1.44
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.43 2004/03/02 19:32:43 claudio Exp $ */
d702 2
a703 1
		rib = malloc(imsg->hdr.len - IMSG_HEADER_SIZE);
@


1.43
log
@show rib A.B.C.D and show rib A.B.C.D/N [all] support. Now the most important
show commands are available. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.42 2004/02/26 16:19:58 claudio Exp $ */
d246 2
a247 2
	printf("%-15s %-5s %-10s %-10s %-5s %-8s %s\n", "Neighbor", "AS", "MsgRcvd",
	    "MsgSent", "OutQ", "Up/Down", "State");
@


1.42
log
@Implement "show rib" and "show rib <astype> <AS>" commands to dump the
RIB. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.41 2004/02/24 13:12:24 henning Exp $ */
d136 1
a136 3
		if (res->as.type == AS_NONE)
			imsg_compose(&ibuf, IMSG_CTL_SHOW_RIB, 0, NULL, 0);
		else
d139 11
@


1.41
log
@print # of queued outgoing messages in show summary view, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.40 2004/01/29 12:02:13 henning Exp $ */
d33 1
d62 4
d135 8
d213 3
d624 115
@


1.40
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.39 2004/01/27 22:11:23 henning Exp $ */
d221 2
a222 2
	printf("%-15s %-5s %-10s %-10s %-8s %s\n", "Neighbor", "AS", "MsgRcvd",
	    "MsgSent", "Up/Down", "State");
d233 1
a233 1
		printf("%-15s %5u %10llu %10llu %-8s %s\n",
d240 1
@


1.39
log
@don't use log_ntoa, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.38 2004/01/27 21:56:47 henning Exp $ */
d215 1
a215 1
	exit (0);
@


1.38
log
@struct kroute changed, cope
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.37 2004/01/27 21:26:52 henning Exp $ */
d258 1
d263 1
d270 1
a270 1
		    log_ntoa(p->remote_bgpid));
@


1.37
log
@missing exit() at end of main
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.36 2004/01/27 16:50:20 henning Exp $ */
d445 1
a445 1
		if (asprintf(&p, "%s/%u", log_ntoa(k->prefix), k->prefixlen) ==
d451 2
a452 2
		if (k->nexthop)
			printf("%s", log_ntoa(k->nexthop));
@


1.36
log
@catch up with changes in struct peer_config, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.35 2004/01/22 03:09:29 henning Exp $ */
d214 2
@


1.35
log
@print the interface state wrt the nexthop verification in the show interface
output.
makes quite some sense so that not every reader has to know the algorithm
for deciding on the interface state...
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.32 2004/01/20 13:11:39 henning Exp $ */
d232 1
a232 1
		    inet_ntoa(p->conf.remote_addr.sin_addr),
d261 1
a261 1
		    inet_ntoa(p->conf.remote_addr.sin_addr),
d289 1
a289 1
			    log_ntoa(sa_in->sin_addr.s_addr),
d295 1
a295 1
			    log_ntoa(sa_in->sin_addr.s_addr),
@


1.34
log
@there's a "slight" difference between our log_err() and the system's err()...
the latter does not return, so we don't need to exit() afterwards.
one of the two spotted by jared
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.33 2004/01/21 23:45:18 henning Exp $ */
d497 2
a498 1
	printf("%-20s%-20s%-20s\n", "Interface", "Flags", "Link state");
d562 3
a564 2
		printf("%-20s", k->ifname);
		printf("%-20s", k->flags & IFF_UP ? "UP" : "");
@


1.33
log
@new parser.
completely table driven and not wired into the action code like the
previous parser...
i wanted to do this for some time, and now it was just due.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.32 2004/01/20 13:11:39 henning Exp $ */
d84 1
a84 1
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
a85 2
		exit(1);
	}
d90 1
a90 1
	if (connect(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
a91 2
		exit(1);
	}
@


1.32
log
@show usage if called without command
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.31 2004/01/20 13:03:39 henning Exp $ */
d34 1
a34 18

enum actions {
	NONE,
	SHOW,
	SHOW_SUMMARY,
	SHOW_NEIGHBOR,
	SHOW_NEIGHBOR_TIMERS,
	SHOW_FIB,
	SHOW_NEXTHOP,
	SHOW_INTERFACE,
	RELOAD,
	FIB,
	FIB_COUPLE,
	FIB_DECOUPLE,
	NEIGHBOR,
	NEIGHBOR_UP,
	NEIGHBOR_DOWN
};
a40 34
struct keywords {
	const char	*keyword;
	int		 value;
};

static const struct keywords keywords_main[] = {
	{ "reload",	RELOAD},
	{ "show",	SHOW},
	{ "fib",	FIB},
	{ "neighbor",	NEIGHBOR}
};

static const struct keywords keywords_show[] = {
	{ "neighbor",	SHOW_NEIGHBOR},
	{ "summary",	SHOW_SUMMARY},
	{ "fib",	SHOW_FIB},
	{ "nexthop",	SHOW_NEXTHOP},
	{ "interfaces",	SHOW_INTERFACE}
};

static const struct keywords keywords_show_neighbor[] = {
	{ "timers",	SHOW_NEIGHBOR_TIMERS},
	{ "messages",	SHOW_NEIGHBOR}
};

static const struct keywords keywords_fib[] = {
	{ "couple",	FIB_COUPLE},
	{ "decouple",	FIB_DECOUPLE}
};

static const struct keywords keywords_neighbor[] = {
	{ "up",		NEIGHBOR_UP},
	{ "down",	NEIGHBOR_DOWN}
};
a43 1
int		 match_keyword(const char *, const struct keywords [], size_t);
a51 1
int		 parse_addr(const char *, struct bgpd_addr *);
d70 1
a70 1
	exit (1);
a77 1
	int			 i, flags;
d79 4
a82 2
	enum actions		 action = NONE;
	struct bgpd_addr	 addr;
d100 1
a100 6
	if (argc >= 2)
		action = match_keyword(argv[1], keywords_main,
		    sizeof(keywords_main)/sizeof(keywords_main[0]));

again:
	switch (action) {
a104 6
		if (argc >= 3) {
			action = match_keyword(argv[2], keywords_show,
			    sizeof(keywords_show)/sizeof(keywords_show[0]));
			goto again;
		}
		/* fallthrough */
a105 2
		if (argc >= 4)
			errx(1, "\"show summary\" does not take arguments");
d110 3
a112 17
		flags = 0;
		bzero(&addr, sizeof(addr));
		for (i = 3; i < argc; i++)
			if (!strncmp(argv[i], "connected", strlen(argv[i])))
				flags |= F_CONNECTED;
			else if (!strncmp(argv[i], "static", strlen(argv[i])))
				flags |= F_STATIC;
			else if (!strncmp(argv[i], "bgp", strlen(argv[i])))
				flags |= F_BGPD_INSERTED;
			else if (!strncmp(argv[i], "nexthop", strlen(argv[i])))
				flags |= F_NEXTHOP;
			else if (!parse_addr(argv[i], &addr))
				errx(1, "usage: \"show fib connected|static|"
				    "bgp|nexthop|[address]");
		if (!addr.af)
			imsg_compose(&ibuf, IMSG_CTL_KROUTE, 0, &flags,
			    sizeof(flags));
d114 2
a115 2
			imsg_compose(&ibuf, IMSG_CTL_KROUTE_ADDR, 0, &addr,
			    sizeof(addr));
d128 1
a128 4
		/* get ip address of neighbor, limit query to that */
		if (argc >= 4) {
			if (!parse_addr(argv[3], &addr))
				errx(1, "%s: not an IP address", argv[3]);
d130 2
a131 2
			    &addr, sizeof(addr));
		} else
a132 5

		if (argc >= 5)
			action = match_keyword(argv[4], keywords_show_neighbor,
			    sizeof(keywords_show_neighbor)/
			    sizeof(keywords_show_neighbor[0]));
a134 2
		if (argc >= 3)
			errx(1, "\"reload\" takes no options");
d140 1
a140 6
		if (argc >= 3) {
			action = match_keyword(argv[2], keywords_fib,
			    sizeof(keywords_fib)/sizeof(keywords_fib[0]));
			goto again;
		} else
			errx(1, "fib [couple|decouple]");
a142 2
		if (argc >= 4)
			errx(1, "\"fib couple\" takes no options");
a147 2
		if (argc >= 4)
			errx(1, "\"fib decouple\" takes no options");
d153 1
a153 8
		if (argc < 4)
			errx(1, "usage: neighbor address command");
		if (!parse_addr(argv[2], &addr))
			errx(1, "%s: not an IP address", argv[2]);
		action = match_keyword(argv[3], keywords_neighbor,
			    sizeof(keywords_neighbor)/
			    sizeof(keywords_neighbor[0]));
		goto again;
d157 1
a157 1
		    &addr, sizeof(addr));
d163 1
a163 1
		    &addr, sizeof(addr));
d184 1
a184 1
			switch (action) {
a219 22
int
match_keyword(const char *word, const struct keywords table[], size_t cnt)
{
	u_int	match, res, i;

	match = res = 0;

	for (i = 0; i < cnt; i++)
		if (strncmp(word, table[i].keyword,
		    strlen(word)) == 0) {
			match++;
			res = table[i].value;
		}

	if (match > 1)
		errx(1, "ambigous command: %s", word);
	if (match < 1)
		errx(1, "unknown command: %s", word);

	return (res);
}

a404 17
}

int
parse_addr(const char *word, struct bgpd_addr *addr)
{
	struct in_addr	ina;

	bzero(addr, sizeof(struct bgpd_addr));
	bzero(&ina, sizeof(ina));

	if (inet_pton(AF_INET, word, &ina)) {
		addr->af = AF_INET;
		addr->v4 = ina;
		return (1);
	}

	return (0);
@


1.31
log
@args, unbreak
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.30 2004/01/20 12:50:52 henning Exp $ */
d36 1
d133 1
a133 1
	enum actions		 action = SHOW_SUMMARY;
d158 3
d309 1
@


1.30
log
@getopt & usage, prodded by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.29 2004/01/19 10:41:34 henning Exp $ */
a133 12
	int			 ch;

	while ((ch = getopt(argc, argv, "")) != -1) {
		switch (ch) {
		default:
			usage();
			/* not reached */
		}
	}

	argc -= optind;
	argv += optind;
@


1.29
log
@for show interface, print the link status and speed as well. we need
to do this depending on the media type, so print that as well if known.
design following a discussion with theo
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.28 2004/01/17 18:27:37 henning Exp $ */
d92 1
d116 9
d134 12
@


1.28
log
@print interface name instead of index
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.27 2004/01/17 18:06:04 henning Exp $ */
d23 2
d108 3
d577 1
a577 1
		   -1)
d630 1
a630 1
	printf("%-20s%s\n", "Interface", "Flags");
d633 52
d689 1
d695 28
a722 2
		if (k->flags & IFF_UP)
			printf("UP ");
a728 1
printf("beep");
@


1.27
log
@implement "show interfaces"
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.26 2004/01/11 02:36:48 henning Exp $ */
d636 1
a636 1
		printf("%-20u", k->ifindex);
@


1.26
log
@+ show nexthop
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.25 2004/01/11 01:05:16 henning Exp $ */
d22 1
d40 1
d71 2
a72 1
	{ "nexthop",	SHOW_NEXTHOP}
d105 2
d182 4
d281 3
d621 30
@


1.25
log
@print local/remote IP/port with the detailed neighbor view

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.24 2004/01/10 21:04:37 henning Exp $ */
d38 1
d68 2
a69 1
	{ "fib",	SHOW_FIB}
d100 2
d173 4
d269 3
d581 28
@


1.24
log
@as buf_close does not implictely writes any more, imsg_compose doesn't
either, so we need to call msgbuf_write explictely now.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.23 2004/01/09 19:09:45 henning Exp $ */
d343 1
d372 13
@


1.23
log
@show fib connected|static|bgp|nexthop|[address]

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.22 2004/01/09 13:48:10 henning Exp $ */
d237 4
@


1.22
log
@a sample "show fib" implementation

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.21 2004/01/07 02:00:05 henning Exp $ */
d106 1
d147 20
a166 3
		if (argc >= 4)
			errx(1, "\"show fib\" does not take arguments");
		imsg_compose(&ibuf, IMSG_CTL_KROUTE, 0, NULL, 0);
@


1.21
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.20 2004/01/06 23:23:49 henning Exp $ */
d24 1
d37 1
d66 2
a67 1
	{ "summary",	SHOW_SUMMARY}
d96 2
d145 6
d236 3
d467 63
@


1.20
log
@neighbor 1.2.3.4 up/down

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.19 2004/01/06 19:24:37 henning Exp $ */
d405 1
a405 1
		return(fmt_timeframe_core(time(NULL) - t));
@


1.19
log
@print intervals with the timers
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.18 2004/01/06 18:01:48 henning Exp $ */
d39 4
a42 1
	FIB_DECOUPLE
d58 2
a59 1
	{ "fib",	FIB}
d67 1
a67 1
static const struct keywords keywords_neighbor[] = {
d77 5
d152 3
a154 3
			action = match_keyword(argv[4], keywords_neighbor,
			    sizeof(keywords_neighbor)/
			    sizeof(keywords_neighbor[0]));
d185 22
d235 3
@


1.18
log
@StartTimer -> IdleHoldTimer
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.17 2004/01/05 16:29:20 henning Exp $ */
d80 1
a80 1
void		 print_timer(const char *, time_t);
d337 5
a341 4
	print_timer("IdleHoldTimer:", p->IdleHoldTimer);
	print_timer("ConnectRetryTimer:", p->ConnectRetryTimer);
	print_timer("HoldTimer:", p->HoldTimer);
	print_timer("KeepaliveTimer:", p->KeepaliveTimer);
d345 1
a345 1
print_timer(const char *name, time_t val)
d353 1
a353 1
		printf("not running\n");
d355 1
a355 1
		printf("due\n");
d357 3
a359 1
		printf("due in %s\n", fmt_timeframe_core(d));
@


1.17
log
@add support for couple/decouple
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.16 2004/01/04 23:44:17 henning Exp $ */
d337 1
a337 1
	print_timer("StartTimer:", p->StartTimer);
@


1.16
log
@when imsg_get has no imsg any more for us, do not set the done flag,
instead, break out of the inner loop so the outer loop gets us a new fix
via imsg_read
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.15 2004/01/04 21:45:05 henning Exp $ */
d36 4
a39 1
	RELOAD
d54 2
a55 1
	{ "show",	SHOW}
d68 5
d153 23
d201 3
@


1.15
log
@show da timers
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.14 2004/01/04 20:21:56 henning Exp $ */
d148 1
a148 1
			break;
d155 1
a155 2
			if (n == 0) {
				done = 1;
a156 1
			}
@


1.14
log
@show message statistics in the "show neighbor" view
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.13 2004/01/04 20:07:30 henning Exp $ */
d35 1
d39 5
d59 5
d68 4
a71 1
int		 show_neighbor_msg(struct imsg *);
d73 1
d123 1
d132 5
d165 4
a168 1
				done = show_neighbor_msg(&imsg);
d237 1
a237 1
show_neighbor_msg(struct imsg *imsg)
d260 9
a268 16
		printf("  Message statistics:\n");
		printf("  %-15s %-10s %-10s\n", "", "Sent", "Received");
		printf("  %-15s %10llu %10llu\n", "Opens",
		    p->stats.msg_sent_open, p->stats.msg_rcvd_open);
		printf("  %-15s %10llu %10llu\n", "Notifications",
		    p->stats.msg_sent_notification,
		    p->stats.msg_rcvd_notification);
		printf("  %-15s %10llu %10llu\n", "Updates",
		    p->stats.msg_sent_update, p->stats.msg_rcvd_update);
		printf("  %-15s %10llu %10llu\n", "Keepalives",
		    p->stats.msg_sent_keepalive, p->stats.msg_rcvd_keepalive);
		printf("  %-15s %10llu %10llu\n", "Total",
		    p->stats.msg_sent_open + p->stats.msg_sent_notification +
		    p->stats.msg_sent_update + p->stats.msg_sent_keepalive,
		    p->stats.msg_rcvd_open + p->stats.msg_rcvd_notification +
		    p->stats.msg_rcvd_update + p->stats.msg_rcvd_keepalive);
d281 45
d332 9
d350 1
a350 6
	if (t == 0) {
		snprintf(buf, TF_LEN, "%s", "Never");
		return (buf);
	}

	week = time(NULL) - t;
@


1.13
log
@keep seperate message counters for open/update/keepalive/notification
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.12 2004/01/04 19:44:27 henning Exp $ */
d236 16
d319 1
a319 1
	return (0);	
@


1.12
log
@new command "reload"
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.11 2004/01/04 18:51:23 henning Exp $ */
d192 1
a192 1
		printf("%-15s %5u %10llu %10llu %8s %s\n",
d194 6
a199 2
		    p->conf.remote_as, p->stats.msg_rcvd,
		    p->stats.msg_send, fmt_timeframe(p->stats.last_updown),
@


1.11
log
@allow "show neighbor" to be limited to one specific neighbor
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.10 2004/01/04 17:55:19 henning Exp $ */
d34 2
a35 1
	SHOW_NEIGHBOR
d44 1
d117 6
d145 2
@


1.10
log
@add infrastructure for command line parsing
to test that i had to add a "show neighbor" view...
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.9 2004/01/04 02:51:24 henning Exp $ */
d57 1
d68 1
d107 7
a113 1
		imsg_compose(&ibuf, IMSG_CTL_SHOW_NEIGHBOR, 0, NULL, 0);
d273 18
a290 1
}@


1.9
log
@print time since last up/down ninely
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.8 2004/01/04 02:13:52 henning Exp $ */
d31 20
d52 4
a55 2
void		 summary_head(void);
int		 summary_msg(struct imsg *);
a59 4
enum views {
	VIEW_SUMMARY
};

d66 1
a66 1
	enum views		 view = VIEW_SUMMARY;
d84 16
a99 2
	switch (view) {
	case VIEW_SUMMARY:
d101 6
a106 1
		summary_head();
d122 8
a129 3
			switch (view) {
			case VIEW_SUMMARY:
				done = summary_msg(&imsg);
d137 22
d160 1
a160 1
summary_head(void)
d167 1
a167 1
summary_msg(struct imsg *imsg)
d190 36
d242 1
a242 1
		snprintf(buf, TF_LEN, "%-8s", "Never");
@


1.8
log
@share statenames
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.7 2004/01/03 22:27:06 henning Exp $ */
d31 4
a34 3
int	main(int, char *[]);
void	summary_head(void);
int	summary_msg(struct imsg *);
d98 2
a99 2
	printf("%-15s %-5s %-10s %-10s %s\n", "Neighbor", "AS", "MsgRcvd",
	    "MsgSent", "State");
d110 1
a110 1
		printf("%-15s %5u %10llu %10llu %s\n",
d113 2
a114 1
		    p->stats.msg_send, statenames[p->state]);
d125 41
@


1.7
log
@print message counters
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.6 2004/01/03 20:39:51 henning Exp $ */
d29 1
a35 10

static const char *statenames[] = {
	"None",
	"Idle",
	"Connect",
	"Active",
	"OpenSent",
	"OpenConfirm",
	"Established"
};
@


1.6
log
@#include session.h
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.5 2004/01/03 16:46:08 henning Exp $ */
d106 2
a107 1
	printf("%-15s %-5s %s\n", "Neighbor", "AS", "State");
d118 1
a118 1
		printf("%-15s %5u %s\n",
d120 2
a121 1
		    p->conf.remote_as, statenames[p->state]);
@


1.5
log
@we'll have more than one view one day, strutural prepare for that
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.4 2004/01/03 16:13:49 henning Exp $ */
d28 1
@


1.4
log
@factor out the printing stuff and format nicer as well
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.3 2004/01/03 14:06:42 henning Exp $ */
d30 2
a31 2
void	print_summary_head(void);
void	print_summary(struct peer *);
d45 4
d55 1
a55 1
	struct peer		*p;
a70 2
	imsg_compose(&ibuf, IMSG_CTL_SHOW_NEIGHBOR, 0, NULL, 0);
	print_summary_head();
d73 6
d80 1
a80 1
		if((n = imsg_read(&ibuf)) == -1)
a81 1

a87 1

d92 3
a94 11

			switch (imsg.hdr.type) {
			case IMSG_CTL_SHOW_NEIGHBOR:
				p = imsg.data;
				print_summary(p);
				break;
			case IMSG_CTL_END:
				done = 1;
				break;
			default:
				break;
d96 1
d103 1
a103 1
print_summary_head(void)
d105 1
a105 1
	printf("%-15s %-5s %s\n", "Neighbor", "AS", "Status");
d108 2
a109 2
void
print_summary(struct peer *p)
d111 18
a128 3
	printf("%-15s %5u %s\n", inet_ntoa(p->conf.remote_addr.sin_addr),
	    p->conf.remote_as, statenames[p->state]);
}@


1.3
log
@cope with changed imsg_read semantics
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.2 2004/01/03 13:55:18 henning Exp $ */
d30 2
d68 1
d90 1
a90 3
				printf("%s: %s\n",
				    inet_ntoa(p->conf.remote_addr.sin_addr),
				    statenames[p->state]);
d102 13
@


1.2
log
@there is no guarantee we get all we wan with a single read(), so we
have to do the imsg_read in a loop as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.1 2004/01/02 02:22:52 henning Exp $ */
d69 1
a69 1
		if(imsg_read(&ibuf) == -1)
d71 3
@


1.1
log
@bring back bgpctl
ok and help theo
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpdctl.c,v 1.1 2004/01/01 23:51:40 henning Exp $ */
d47 1
a47 1
	int			 fd, n;
d66 1
a66 1
	imsg_read(&ibuf);
d68 2
a69 5
	for (;;) {
		if ((n = imsg_get(&ibuf, &imsg)) == -1)
			errx(1, "imsg_get error");

		if (n == 0)
d72 22
a93 9
		switch (imsg.hdr.type) {
		case IMSG_CTL_SHOW_NEIGHBOR:
			p = imsg.data;
			printf("%s: %s\n",
			    inet_ntoa(p->conf.remote_addr.sin_addr),
			    statenames[p->state]);
			break;
		default:
			break;
a95 1

@

