head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.6
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.6
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.14
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.10
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.8
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.6
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.4
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8;
locks; strict;
comment	@ * @;


1.14
date	2015.04.25.21.44.26;	author phessler;	state Exp;
branches;
next	1.13;
commitid	eLqpJ7aeEkdPSAbm;

1.13
date	2015.04.25.13.23.01;	author phessler;	state Exp;
branches;
next	1.12;
commitid	r7uZDNEfLiIpNUvP;

1.12
date	2015.01.16.06.40.15;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	Uu5nFG3wCl0LACBb;

1.11
date	2013.11.22.15.15.16;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.30.08.14.07;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.08.15.40.25;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.05.22.34.08;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.05.17.31.12;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.05.17.28.59;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.04.18.13.13;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.04.12.37.07;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.04.12.27.46;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.03.14.56.43;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.03.11.45.30;	author henning;	state Exp;
branches;
next	;


desc
@@


1.14
log
@some people are capitalizing keywords, so ignore case when we test the tokens

OK henning@@ benno@@
@
text
@/*	$OpenBSD: irr_parser.c,v 1.13 2015/04/25 13:23:01 phessler Exp $ */

/*
 * Copyright (c) 2007 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <ctype.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "irrfilter.h"

#define PARSEBUF_INCREMENT 4096

int	 lineno;
char	*parsebuf = NULL;
size_t	 parsebuflen = 0;

void	 grow_parsebuf(void);
char	*irr_getln(FILE *f);
int	 parse_policy(char *, char *);
int	 policy_additem(char *, struct policy_item *);
int	 parse_asset(char *, char *);
int	 parse_route(char *, char *);

/*
 * parse_response() return values:
 * -1	error
 * 0	object not found
 * >0	number of lines matched plus 1
 */
int
parse_response(FILE *f, enum qtype qtype)
{
	char	*key, *val;
	int	 cnt, n;

	lineno = 1;
	cnt = 1;
	while ((val = irr_getln(f)) != NULL) {
		if (!strncmp(val, "%ERROR:101:", 11))	/* no entries found */
			return (0);

		if (val[0] == '%') {
			warnx("message from whois server: %s", val);
			return (-1);
		}

		key = strsep(&val, ":");
		if (val == NULL) {
			warnx("%u: %s", lineno, key);
			warnx("no \":\" found!");
			return (-1);
		}
		EATWS(val);

		switch (qtype) {
		case QTYPE_OWNAS:
			if ((n = parse_policy(key, val)) == -1)
				return (-1);
			break;
		case QTYPE_ASSET:
			if ((n = parse_asset(key, val)) == -1)
				return (-1);
			break;
		case QTYPE_ROUTE:
		case QTYPE_ROUTE6:
			if ((n = parse_route(key, val)) == -1)
				return (-1);
			break;
		default:
			err(1, "king bula suffers from dementia");
		}
		cnt += n;
	}

	return (cnt);
}

void
grow_parsebuf(void)
{
	char	*p;
	size_t	 newlen;

	newlen = parsebuflen + PARSEBUF_INCREMENT;
	if ((p = realloc(parsebuf, newlen)) == NULL)
		err(1, "grow_parsebuf realloc");
	parsebuf = p;
	parsebuflen = newlen;

	if (0)
		fprintf(stderr, "parsebuf now %lu bytes\n", (ulong)parsebuflen);
}

char *
irr_getln(FILE *f)
{
	int	 c, next, last;
	char	*p;

	if (parsebuf == NULL)
		grow_parsebuf();
	p = parsebuf;
	last = -1;

	do {
		c = getc(f);

		if (p == parsebuf) {	/* beginning of new line */
			if (c == '%') {
				next = getc(f);
				switch (next) {
				case ' ':		/* comment. skip over */
					while ((c = getc(f)) != '\n' &&
					    c != EOF)
						; /* nothing */
					break;
				case '\n':
				case EOF:
					c = next;
					break;
				default:
					ungetc(next, f);
					break;
				}
			}
		}

		if (c == '#') /* skip until \n */
			while ((c = getc(f)) != '\n' && c != EOF)
				; /* nothing */

		if (c == '\n') {
			lineno++;
			next = getc(f);
			if (next == '+')	/* continuation, skip the + */
				c = getc(f);
			else if (ISWS(next))	/* continuation */
				c = next;
			else
				ungetc(next, f);
		}


		if (c == '\n' || c == EOF) {
			if (c == EOF)
				if (ferror(f))
					err(1, "ferror");
			if (p > parsebuf) {
				*p = '\0';
				return (parsebuf);
			}
		} else {
			if (!(ISWS(c) && ISWS(last))) {
				if (p + 1 >= parsebuf + parsebuflen - 1) {
					size_t	offset;

					offset = p - parsebuf;
					grow_parsebuf();
					p = parsebuf + offset;
				}
				if (ISWS(c)) /* equal opportunity whitespace */
					*p++ = ' ';
				else
					*p++ = (char)c;
			}
			last = c;
		}
	} while (c != EOF);

	return (NULL);
}

/*
 * parse the policy from an aut-num object
 */

enum policy_parser_st {
	PO_NONE,
	PO_PEER_KEY,
	PO_PEER_AS,
	PO_PEER_ADDR,
	PO_RTR_KEY,
	PO_RTR_ADDR,
	PO_ACTION_KEY,
	PO_ACTION_SPEC,
	PO_FILTER_KEY,
	PO_FILTER_SPEC
};

int
parse_policy(char *key, char *val)
{
	struct policy_item	*pi;
	enum pdir		 dir;
	enum policy_parser_st	 st = PO_NONE, nextst;
	char			*tok, *router = "", *p;

	if (!strcmp(key, "import"))
		dir = IMPORT;
	else if (!strcmp(key, "export"))
		dir = EXPORT;
	else				/* ignore! */
		return (0);

	if (dir == EXPORT && (irrflags & F_IMPORTONLY))
		return (0);

	if ((pi = calloc(1, sizeof(*pi))) == NULL)
		err(1, "parse_policy calloc");
	pi->dir = dir;

	while ((tok = strsep(&val, " ")) != NULL) {
		nextst = PO_NONE;
		if (dir == IMPORT) {
			if (!strcasecmp(tok, "from"))
				nextst = PO_PEER_KEY;
			else if (!strcasecmp(tok, "at"))
				nextst = PO_RTR_KEY;
			else if (!strcasecmp(tok, "action"))
				nextst = PO_ACTION_KEY;
			else if (!strcasecmp(tok, "accept"))
				nextst = PO_FILTER_KEY;
		} else if (dir == EXPORT) {
			if (!strcasecmp(tok, "to"))
				nextst = PO_PEER_KEY;
			else if (!strcasecmp(tok, "at"))
				nextst = PO_RTR_KEY;
			else if (!strcasecmp(tok, "action"))
				nextst = PO_ACTION_KEY;
			else if (!strcasecmp(tok, "announce"))
				nextst = PO_FILTER_KEY;
		}

		if (nextst == PO_FILTER_KEY) /* rest is filter spec */
			if ((pi->filter = strdup(val)) == NULL)
				err(1, NULL);

		if (nextst == PO_ACTION_KEY) {
			/* action list. ends after last ; */
			p = strrchr(val, ';');
			if (p == NULL || !ISWS(*++p))
				errx(1, "syntax error in action spec");
			*p = '\0';
			if ((pi->action = strdup(val)) == NULL)
				err(1, NULL);
			val = ++p;
			while (ISWS(*p))
				p++;
		}

		switch (st) {
		case PO_NONE:
			if (nextst != PO_PEER_KEY)
				goto ppoerr;
			st = nextst;
			break;
		case PO_PEER_KEY:
			if (pi->peer_as == 0) {
				const char	*errstr;

				if (nextst != PO_NONE)
					goto ppoerr;
				if (strlen(tok) < 3 ||
				    strncasecmp(tok, "AS", 2) ||
				    !isdigit((unsigned char)tok[2]))
					errx(1, "peering spec \"%s\": format "
					    "error, AS expected", tok);
				pi->peer_as = strtonum(tok + 2, 1, UINT_MAX,
				    &errstr);
				if (errstr)
					errx(1, "peering spec \"%s\": format "
					    "error: %s", tok, errstr);
			} else {
				switch (nextst) {
				case PO_NONE:
					if (!strcasecmp(tok, "and") ||
					    !strcasecmp(tok, "or") ||
					    !strcasecmp(tok, "not"))
						fprintf(stderr, "compound "
						    "peering statements are "
						    "not supported");
					 else	/* peer address */
						if ((pi->peer_addr =
						    strdup(tok)) == NULL)
							err(1, NULL);
					break;
				case PO_RTR_KEY:
				case PO_ACTION_KEY:
				case PO_FILTER_KEY:
					st = nextst;
					break;
				default:
					goto ppoerr;
				}
			}
			break;
		case PO_PEER_AS:
		case PO_PEER_ADDR:
			err(1, "state error");
			break;
		case PO_RTR_KEY:
			if (nextst != PO_NONE)
				goto ppoerr;
			/* rtr address */
			if ((router = strdup(tok)) == NULL)
				err(1, NULL);
			st = PO_RTR_ADDR;
			break;
		case PO_RTR_ADDR:
			if (nextst != PO_ACTION_KEY &&
			    nextst != PO_FILTER_KEY)
				goto ppoerr;
			st = nextst;
			break;
		case PO_ACTION_KEY:
			/* already handled, next must be FILTER_KEY */
			if (nextst != PO_FILTER_KEY)
				goto ppoerr;
			st = nextst;
			break;
		case PO_FILTER_KEY:
			/* already handled */
			break;
		case PO_ACTION_SPEC:
		case PO_FILTER_SPEC:
			err(1, "state error");
			break;
		}
	}

	if (st != PO_FILTER_KEY)
		err(1, "state error");

	if (policy_additem(router, pi) == -1)
		return (-1);

	return (1);

ppoerr:
	free(pi);
	fprintf(stderr, "%u: parse error\n", lineno);
	return (-1);
}

int
policy_additem(char *router, struct policy_item *pi)
{
	struct router	*r;

	for (r = TAILQ_FIRST(&router_head); r != NULL &&
	    strcmp(r->address, router); r = TAILQ_NEXT(r, entry))
		; /* nothing */

	if (r == NULL) {
		if ((r = calloc(1, sizeof(*r))) == NULL ||
		    (r->address = strdup(router)) == NULL)
			err(1, NULL);
		TAILQ_INIT(&r->policy_h);
		TAILQ_INSERT_TAIL(&router_head, r, entry);
	}

	TAILQ_INSERT_TAIL(&r->policy_h, pi, entry);

	return (0);
}

/*
 * parse as-set: get members
 */

int
parse_asset(char *key, char *val)
{
	char	*tok;

	if (strcmp(key, "members"))	/* ignore everything else */
		return (0);

	while ((tok = strsep(&val, ",")) != NULL) {
		EATWS(tok);
		if (tok[0] != '\0')
			asset_addmember(tok);
	}

	return (1);
}

/*
 * parse route obj: just get the prefix
 */
int
parse_route(char *key, char *val)
{
	if (strcmp(key, "route") && strcmp(key, "route6"))
		/* ignore everything else */
		return (0);

	/* route is single-value, but seen trailing , and \r in the wild */
	if (strlen(val) > 0 && (val[strlen(val) - 1] == ',' ||
	    val[strlen(val) - 1] == '\r'))
		val[strlen(val) - 1] = '\0';

	return (prefixset_addmember(val));
}
@


1.13
log
@handle an IRR record of "export ... action X" the same way we handle
"import ... action X".

OK benno@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_parser.c,v 1.12 2015/01/16 06:40:15 deraadt Exp $ */
d234 1
a234 1
			if (!strcmp(tok, "from"))
d236 1
a236 1
			else if (!strcmp(tok, "at"))
d238 1
a238 1
			else if (!strcmp(tok, "action"))
d240 1
a240 1
			else if (!strcmp(tok, "accept"))
d243 1
a243 1
			if (!strcmp(tok, "to"))
d245 1
a245 1
			else if (!strcmp(tok, "at"))
d247 1
a247 1
			else if (!strcmp(tok, "action"))
d249 1
a249 1
			else if (!strcmp(tok, "announce"))
@


1.12
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_parser.c,v 1.11 2013/11/22 15:15:16 deraadt Exp $ */
d247 2
@


1.11
log
@unsigned char casts where needed for for ctype.h
checked by florian
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_parser.c,v 1.10 2012/06/30 08:14:07 sthen Exp $ */
a19 1
#include <sys/param.h>
d26 1
@


1.10
log
@strip trailing \r from rpsl route: lines for irrfilter, they have been seen
in the wild and break parsing. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_parser.c,v 1.9 2009/09/08 15:40:25 claudio Exp $ */
d282 1
a282 1
				    !isdigit(tok[2]))
@


1.9
log
@Update irrfilter to support IPv6 and 4-byte AS numbers. IPv6 support based
on work by Tonnerre Lombard I just cleaned it up. OK henning, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_parser.c,v 1.8 2007/03/05 22:34:08 henning Exp $ */
d415 3
a417 2
	/* route is single-value, but seen trailing , in the wild */
	if (strlen(val) > 0 && val[strlen(val) - 1] == ',')
@


1.8
log
@RPSL spec says route: is single-valued... nontheless, in the APNIC db:
route:        203.94.216.0/21,
origin:       AS17813
so we need to cut trailing ',' away
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_parser.c,v 1.7 2007/03/05 17:31:12 henning Exp $ */
d84 1
d285 1
a285 1
				pi->peer_as = strtonum(tok + 2, 1, USHRT_MAX,
d411 2
a412 1
	if (strcmp(key, "route"))	/* ignore everything else */
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_parser.c,v 1.6 2007/03/05 17:28:59 henning Exp $ */
d412 4
@


1.6
log
@need to eat whitespace at both ends of val
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_parser.c,v 1.5 2007/03/04 18:13:13 henning Exp $ */
d266 1
a266 1
			
d295 3
a297 2
						fprintf(stderr, "compound peering "
						    "statements are not supported");
d299 2
a300 1
						if ((pi->peer_addr = strdup(tok)) == NULL)
d413 1
a413 1
	return(prefixset_addmember(val));
@


1.5
log
@store peer AS numerically
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_parser.c,v 1.4 2007/03/04 12:37:07 henning Exp $ */
d72 1
a72 2
		while (ISWS(*val))
			val++;
@


1.4
log
@fix cass where the specification does not give the router address by using
"" instead of defaulting to NULL, which is a pain to handle afterwards.
in the output function, treat empty string address like NULL address
problem noticed by rivo nurges <rix@@estpak.ee>
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_parser.c,v 1.3 2007/03/04 12:27:46 henning Exp $ */
d21 1
d275 3
a277 1
			if (pi->peer_as == NULL) {
d280 10
a289 2
				if ((pi->peer_as = strdup(tok)) == NULL)
					err(1, NULL);
@


1.3
log
@ran into an asset which has dangling , at eol in the member spec, leading
to us trying to add an empty-string AS, which asset_get later complains
about.
in parse_asset, check that we're no dealing with a empty string token
before calling asset_addmember
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_parser.c,v 1.2 2007/03/03 14:56:43 henning Exp $ */
d214 1
a214 1
	char			*tok, *router = NULL, *p;
@


1.2
log
@make parse_response (and thus whois) return 0 for no object found, and n+1
for object found with n matched attributes. this way we can distinguish
between no object found and object without relevant attributes
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_parser.c,v 1.1 2007/03/03 11:45:30 henning Exp $ */
d385 2
a386 1
		asset_addmember(tok);
@


1.1
log
@add irrfilter mode.
generates bgpd filter rules from the Internet Routing Registry aka IRR aka
the aut-num, as-set and route objects in the RIPE, ARIN, APNIC ... databases
accessed via whois, using the Routing Policy Specificaion Language RPSL.
implement the whois query interface, an RPSL parser (of course only the
parts we need), recursive as-set resolver, prefixes per AS lookup,
and an ouput module to make up the rules.
work in progress, not ready for general consumption yet.
import agreed by theo & claudio
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d42 6
d55 1
a55 1
	cnt = 0;
@

