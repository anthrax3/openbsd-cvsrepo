head	1.20;
access;
symbols
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.8
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.13.0.28
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.26
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.24
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.22
	OPENBSD_5_0:1.13.0.20
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.18
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.16
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.12
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.14
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.10
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13;
locks; strict;
comment	@ * @;


1.20
date	2015.11.18.16.47.04;	author mmcc;	state Exp;
branches;
next	1.19;
commitid	D2IS0EZs5FYyNtl4;

1.19
date	2015.10.05.14.18.33;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	QC0DB2Wb4abs7Ort;

1.18
date	2015.04.26.11.32.54;	author phessler;	state Exp;
branches;
next	1.17;
commitid	zpX3r1ooLaf6l7Gs;

1.17
date	2015.04.25.15.28.18;	author phessler;	state Exp;
branches;
next	1.16;
commitid	4yPC9ACFnDblFb1s;

1.16
date	2015.01.16.06.40.15;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	Uu5nFG3wCl0LACBb;

1.15
date	2013.11.22.15.15.16;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.27.18.49.25;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.05.17.28.21;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.05.15.02.05;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.05.11.07.47;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.05.10.10.40;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.04.20.31.22;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.04.20.05.11;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.04.18.40.08;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.04.18.13.13;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.04.17.47.31;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.04.17.03.01;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.04.12.37.07;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.03.12.41.13;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.03.11.45.30;	author henning;	state Exp;
branches;
next	;


desc
@@


1.20
log
@err(1, "foo") -> err(1, NULL) for strdup()
@
text
@/*	$OpenBSD: irr_output.c,v 1.19 2015/10/05 14:18:33 deraadt Exp $ */

/*
 * Copyright (c) 2007 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <ctype.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "bgpd.h"
#include "irrfilter.h"

int	 process_policies(FILE *, struct policy_head *);
void	 policy_prettyprint(FILE *, struct policy_item *);
void	 policy_torule(FILE *, struct policy_item *);
char	*action_torule(char *);
void	 print_rule(FILE *, struct policy_item *, char *, struct irr_prefix *);

#define allowed_in_address(x) \
	(isalnum((unsigned char)x) || x == '.' || x == ':' || x == '-')

int
write_filters(char *outpath)
{
	struct router	*r;
	char		*fn;
	int		 fd, ret = 0;
	u_int		 i;
	FILE		*fh;

	while ((r = TAILQ_FIRST(&router_head)) != NULL) {
		TAILQ_REMOVE(&router_head, r, entry);

		if (r->address != NULL && r->address[0] != '\0') {
			for (i = 0; i < strlen(r->address); i++)
				if (!allowed_in_address(r->address[i]))
					errx(1, "router address \"%s\" contains"
					    " illegal character \"%c\"",
					    r->address, r->address[i]);
			if (asprintf(&fn, "%s/bgpd-%s.filter",
			    outpath, r->address) == -1)
				err(1, "write_filters asprintf");
		} else
			if (asprintf(&fn, "%s/bgpd.filter",
			    outpath) == -1)
				err(1, "write_filters asprintf");

		fd = open(fn, O_RDWR|O_CREAT|O_EXCL, S_IRUSR|S_IWUSR);
		if (fd == -1)
			err(1, "error opening %s", fn);
		if ((fh = fdopen(fd, "w")) == NULL)
			err(1, "fdopen %s", fn);

		if (process_policies(fh, &r->policy_h) == -1)
			ret = -1;

		fclose(fh);
		close(fd);
		free(fn);
		free(r->address);
		free(r);
	}

	return (ret);
}

int
process_policies(FILE *fh, struct policy_head *head)
{
	struct policy_item	*pi;

	while ((pi = TAILQ_FIRST(head)) != NULL) {
		TAILQ_REMOVE(head, pi, entry);

		policy_prettyprint(fh, pi);
		policy_torule(fh, pi);
		fflush(fh);

		free(pi->peer_addr);
		free(pi->action);
		free(pi->filter);
		free(pi);
	}

	return (0);
}

void
policy_prettyprint(FILE *fh, struct policy_item *pi)
{
	if (pi->dir == IMPORT)
		fprintf(fh, "# import: from ");
	else
		fprintf(fh, "# export: to ");
	fprintf(fh, "AS%u ", pi->peer_as);
	if (pi->peer_addr)
		fprintf(fh, "%s ", pi->peer_addr);
	if (pi->action)
		fprintf(fh, "action %s ", pi->action);
	fprintf(fh, "%s %s\n", pi->dir == IMPORT ? "accept" : "announce",
	    pi->filter);
}

void
policy_torule(FILE *fh, struct policy_item *pi)
{
	struct as_set		*ass;
	struct prefix_set	*pfxs;
	char			*srcas;
	u_int			 i, j;

	if (pi->filter == NULL || !strcasecmp(pi->filter, "any"))
		print_rule(fh, pi, NULL, NULL);
	else {
		ass = asset_expand(pi->filter);

		for (i = 0; i < ass->n_as; i++) {
			pfxs = prefixset_get(ass->as[i]);

			/* ass->as[i] format and len have been checked before */
			if (strlen(ass->as[i]) < 3)
				errx(1, "%s not AS...", ass->as[i]);
			srcas = ass->as[i] + 2;
			for (j = 0; j < pfxs->prefixcnt; j++)
				print_rule(fh, pi, srcas, pfxs->prefix[j]);
		}
	}
}

/* XXX should really be parsed earlier! */
char *
action_torule(char *s)
{
	int		 cnt = 0;
	char		*key, *val, *pre, *tmp;
	static char	 abuf[8192];
	char		 ebuf[2048];

	if ((tmp = strdup(s)) == NULL)
		err(1, NULL);
	abuf[0] = '\0';
	while ((val = strsep(&tmp, ";")) != NULL && *val) {
		key = strsep(&val, "=");
		if (key == NULL || val == NULL)
			err(1, "format error in action spec\n");

		EATWS(key);
		EATWS(val);

		if (cnt++ == 0)
			pre = " set {";
		else
			pre = ",";

		if (!strcmp(key, "pref"))
			snprintf(ebuf, sizeof(ebuf),
			    "%s localpref %s", pre, val);
		else if (!strcmp(key, "med"))
			snprintf(ebuf, sizeof(ebuf),
			    "%s med %s", pre, val);
		else
			warnx("unknown action key \"%s\"", key);

		strlcat(abuf, ebuf, sizeof(abuf));
	}
	if (cnt > 0)
		strlcat(abuf, " }", sizeof(abuf));

	free(tmp);
	return (abuf);
}

void
print_rule(FILE *fh, struct policy_item *pi, char *sourceas,
    struct irr_prefix *prefix)
{
	char	 peer[PEER_DESCR_LEN];
	char	*action = "";
	char	*dir;
	char	*srcas[2] = { "", "" };
	char	 pbuf[8 + NI_MAXHOST + 4 + 14 + 3];
	size_t	 offset;

	if (pi->dir == IMPORT)
		dir = "from";
	else
		dir = "to";

	if (pi->peer_addr)
		snprintf(peer, PEER_DESCR_LEN, "%s", pi->peer_addr);
	else
		snprintf(peer, PEER_DESCR_LEN, "AS %s", log_as(pi->peer_as));

	if (pi->action)
		action = action_torule(pi->action);

	pbuf[0] = '\0';
	if (prefix != NULL) {
		strlcpy(pbuf, " prefix ", sizeof(pbuf));
		offset = strlen(pbuf);
		if (inet_ntop(prefix->af, &prefix->addr, pbuf + offset,
		    sizeof(pbuf) - offset) == NULL)
			err(1, "print_rule inet_ntop");
		offset = strlen(pbuf);
		if (snprintf(pbuf + offset, sizeof(pbuf) - offset,
		    "/%u", prefix->len) == -1)
			err(1, "print_rule snprintf");

		if (prefix->maxlen > prefix->len) {
			offset = strlen(pbuf);
			if (snprintf(pbuf + offset, sizeof(pbuf) - offset,
			    " prefixlen <= %u", prefix->maxlen) == -1)
				err(1, "print_rule snprintf");
		}

		if (pi->dir == IMPORT) {
			srcas[0] = " source-as ";
			srcas[1] = sourceas;
		}
	}

	fprintf(fh, "allow quick %s %s%s%s%s%s\n", dir, peer,
	    srcas[0], srcas[1], pbuf, action);
}
@


1.19
log
@these 3 files do not need sys/socket.h
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.18 2015/04/26 11:32:54 phessler Exp $ */
d162 1
a162 1
		err(1, "foo");
@


1.18
log
@for every policy we write out, flush the output so we don't get an
irritating partially written line
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.17 2015/04/25 15:28:18 phessler Exp $ */
a20 1
#include <sys/socket.h>
@


1.17
log
@allow us to write rules that match directly on the peer AS

...
allow from AS 1 prefix 192.0.2.0/24
...

Also adjust the IRR ruleset output to include the declared peer AS,
instead of hoping they listed their neighbor IP address!


OK benno@@
older version OK: claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.16 2015/01/16 06:40:15 deraadt Exp $ */
d100 1
@


1.16
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.15 2013/11/22 15:15:16 deraadt Exp $ */
d33 1
d199 1
a199 1
	char	*peer = "any";
d212 3
a214 1
		peer = pi->peer_addr;
@


1.15
log
@unsigned char casts where needed for for ctype.h
checked by florian
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.14 2013/10/27 18:49:25 guenther Exp $ */
a19 1
#include <sys/param.h>
@


1.14
log
@If a constant string needs a name, use a static const array instead of a
pointer or non-const array, as that minimizes the symbols, maximizes the
placement into read-only memory, and avoids warnings from gcc -Wformat=2
when they're used as format strings.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.13 2007/03/05 17:28:21 henning Exp $ */
d43 1
a43 1
	(isalnum(x) || x == '.' || x == ':' || x == '-')
@


1.13
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.12 2007/03/05 15:02:05 henning Exp $ */
a198 1
	char	*fmt = "allow quick %s %s%s%s%s%s\n";
d242 2
a243 1
	fprintf(fh, fmt, dir, peer, srcas[0], srcas[1], pbuf, action);
@


1.12
log
@unused vars, lint
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.11 2007/03/05 11:07:47 henning Exp $ */
d63 1
a63 1
			if(asprintf(&fn, "%s/bgpd-%s.filter",
d67 1
a67 1
			if(asprintf(&fn, "%s/bgpd.filter",
@


1.11
log
@store a maxlen with each prefix. if that is set, this prefix covers
multiple route objects (i. e. is the result of maksing out longer prefixes
or aggregation we'll do later).
if maxlen is > prefixlen, generate rules accordingly (prefixlen <= maxlen)
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.10 2007/03/05 10:10:40 henning Exp $ */
d157 1
a157 1
	char		*key, *val, *pre, *buf, *tmp;
a163 1
	buf = abuf;
@


1.10
log
@prevent re-use of shit in pbuf from previous rules
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.9 2007/03/04 20:31:22 henning Exp $ */
d205 1
a205 1
	char	 pbuf[8 + NI_MAXHOST + 4];
d230 7
@


1.9
log
@rename struct prefix -> irr_prefix
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.8 2007/03/04 20:05:11 henning Exp $ */
d219 1
@


1.8
log
@store prefixes in binary format. we'll need that for aggregation.
discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.7 2007/03/04 18:40:08 henning Exp $ */
d40 1
a40 1
void	 print_rule(FILE *, struct policy_item *, char *, struct prefix *);
d198 1
a198 1
    struct prefix *prefix)
@


1.7
log
@for import rules, filter by source-as too
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.6 2007/03/04 18:13:13 henning Exp $ */
d22 1
d30 3
d40 1
a40 1
void	 print_rule(FILE *, struct policy_item *, char *, char *);
d197 2
a198 1
print_rule(FILE *fh, struct policy_item *pi, char *sourceas, char *prefix)
d200 7
a206 6
	char			*fmt = "allow quick %s %s%s%s%s%s%s\n";
	char			*peer = "any";
	char			*action = "";
	char			*dir;
	char			*pfx[2] = { "", "" };
	char			*srcas[2] = { "", "" };
d220 10
a229 2
		pfx[0] = " prefix ";
		pfx[1] = prefix;
d236 1
a236 1
	fprintf(fh, fmt, dir, peer, srcas[0], srcas[1], pfx[0], pfx[1], action);
@


1.6
log
@store peer AS numerically
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.5 2007/03/04 17:47:31 henning Exp $ */
d36 1
a36 1
void	 print_rule(FILE *, struct policy_item *, char *);
d127 1
d131 1
a131 1
		print_rule(fh, pi, NULL);
d137 5
a141 1
			fprintf(fh, "# prefixes from %s\n", ass->as[i]);
d143 1
a143 1
				print_rule(fh, pi, pfxs->prefix[j]);
d193 1
a193 1
print_rule(FILE *fh, struct policy_item *pi, char *prefix)
d195 1
a195 1
	char			*fmt = "allow quick %s %s%s%s%s\n";
d199 2
d213 10
a222 4
	if (prefix == NULL)
		fprintf(fh, fmt, dir, peer, "", "", action);
	else
		fprintf(fh, fmt, dir, peer, " prefix ", prefix, action);
@


1.5
log
@pass pointer to struct policy_item down to print_rule() instead of 3 of its
members
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.4 2007/03/04 17:03:01 henning Exp $ */
a96 1
		free(pi->peer_as);
d113 1
a113 1
	fprintf(fh, "%s ", pi->peer_as);
@


1.4
log
@fix output format. spent too much time with RPSL...
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.3 2007/03/04 12:37:07 henning Exp $ */
d36 1
a36 1
void	 print_rule(FILE *, enum pdir, char *, char *, char *);
d131 1
a131 1
		print_rule(fh, pi->dir, pi->peer_addr, pi->action, NULL);
d139 1
a139 2
				print_rule(fh, pi->dir, pi->peer_addr,
				    pi->action, pfxs->prefix[j]);
d189 1
a189 2
print_rule(FILE *fh, enum pdir pdir, char *peerspec, char *actspec,
    char *prefix)
d196 1
a196 1
	if (pdir == IMPORT)
d201 2
a202 2
	if (peerspec)
		peer = peerspec;
d204 2
a205 2
	if (actspec)
		action = action_torule(actspec);
@


1.3
log
@fix cass where the specification does not give the router address by using
"" instead of defaulting to NULL, which is a pain to handle afterwards.
in the output function, treat empty string address like NULL address
problem noticed by rivo nurges <rix@@estpak.ee>
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.2 2007/03/03 12:41:13 henning Exp $ */
d173 1
a173 1
			    "%s localpref=%s", pre, val);
d176 1
a176 1
			    "%s med=%s", pre, val);
d210 1
a210 1
		fprintf(fh, fmt, dir, peer, action, "", "");
d212 1
a212 1
		fprintf(fh, fmt, dir, peer, action, " prefix ", prefix);
@


1.2
log
@write output to files instead of stdout
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_output.c,v 1.1 2007/03/03 11:45:30 henning Exp $ */
d53 1
a53 1
		if (r->address != NULL) {
@


1.1
log
@add irrfilter mode.
generates bgpd filter rules from the Internet Routing Registry aka IRR aka
the aut-num, as-set and route objects in the RIPE, ARIN, APNIC ... databases
accessed via whois, using the Routing Policy Specificaion Language RPSL.
implement the whois query interface, an RPSL parser (of course only the
parts we need), recursive as-set resolver, prefixes per AS lookup,
and an ouput module to make up the rules.
work in progress, not ready for general consumption yet.
import agreed by theo & claudio
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d21 1
d27 2
d32 1
a32 1
int	 process_policies(struct policy_head *, char *);
d38 3
d45 4
a48 1
	int		 ret = 0;
a51 1
		printf("\nRouter %s\n", r->address);
d53 21
a73 2
		if (process_policies(&r->policy_h,
		    r->address) == -1)
d76 3
d87 1
a87 1
process_policies(struct policy_head *head, char *router)
d94 2
a95 2
		policy_prettyprint(stdout, pi);
		policy_torule(stdout, pi);
d137 1
a137 1
			printf("#  prefixes from %s\n", ass->as[i]);
@

