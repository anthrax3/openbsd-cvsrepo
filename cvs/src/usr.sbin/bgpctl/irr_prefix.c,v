head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.6
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.18.0.20
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.18
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.14
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.12
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.10
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.8
	OPENBSD_5_0:1.18.0.6
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.15.0.12
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.8
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.6
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.4
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14;
locks; strict;
comment	@ * @;


1.21
date	2015.10.05.14.18.33;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	QC0DB2Wb4abs7Ort;

1.20
date	2015.01.16.06.40.15;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	Uu5nFG3wCl0LACBb;

1.19
date	2014.10.08.16.15.37;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	8hXaK4f2GeAALziF;

1.18
date	2010.05.10.02.00.50;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.08.16.11.36;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.08.15.40.25;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.27.18.54.25;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.06.16.45.34;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.06.00.27.33;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.05.22.10.50;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.05.16.43.24;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.05.16.40.10;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.05.16.16.42;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.05.15.06.35;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.05.13.57.59;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.05.13.45.52;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.05.12.57.56;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.04.20.36.39;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.04.20.31.22;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.04.20.05.11;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.03.11.45.30;	author henning;	state Exp;
branches;
next	;


desc
@@


1.21
log
@these 3 files do not need sys/socket.h
@
text
@/*	$OpenBSD: irr_prefix.c,v 1.20 2015/01/16 06:40:15 deraadt Exp $ */

/*
 * Copyright (c) 2007 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "irrfilter.h"
#include "bgpd.h"

void	 prefixset_aggregate(struct prefix_set *);
int	 prefix_aggregate(struct irr_prefix *, const struct irr_prefix *);
int	 irr_prefix_cmp(const void *, const void *);
int	 prefix_set_compare(struct prefix_set *, struct prefix_set *);
struct prefix_set
	*prefix_set_find(char *);

RB_HEAD(prefix_set_h, prefix_set)	prefix_set_h;
RB_PROTOTYPE(prefix_set_h, prefix_set, entry, prefix_set_compare)
RB_GENERATE(prefix_set_h, prefix_set, entry, prefix_set_compare)

struct prefix_set	*curpfxs = NULL;

struct prefix_set *
prefixset_get(char *as)
{
	struct prefix_set	*pfxs;

	if ((pfxs = prefix_set_find(as)) != NULL)
		return (pfxs);

	/* nothing found, resolve and store */
	if ((pfxs = calloc(1, sizeof(*pfxs))) == NULL)
		err(1, "get_prefixset calloc");
	if ((pfxs->as = strdup(as)) == NULL)
		err(1, "get_prefixset strdup");
	RB_INSERT(prefix_set_h, &prefix_set_h, pfxs);

	if (irrverbose >= 3) {
		fprintf(stdout, "query routes for %s... ", as);
		fflush(stdout);
	}
	curpfxs = pfxs;
	if ((irrflags & F_IPV4) && whois(as, QTYPE_ROUTE) == -1)
		errx(1, "whois error, prefixset_get %s", as);
	if ((irrflags & F_IPV6) && whois(as, QTYPE_ROUTE6) == -1)
		errx(1, "whois error, prefixset_get %s", as);
	if (whois(as, QTYPE_ROUTE6) == -1)
		errx(1, "whois error, prefixset_get %s", as);
	curpfxs = NULL;
	if (irrverbose >= 3)
		fprintf(stdout, "done\n");

	prefixset_aggregate(pfxs);

	return (pfxs);
}

int
prefixset_addmember(char *s)
{
	void			*p;
	u_int			 i;
	struct irr_prefix	*pfx;
	int			 len, ret;
	char			*slash;
	const char		*errstr;

	if ((slash = strchr(s, '/')) == NULL) {
		fprintf(stderr, "%s: prefix %s does not have the len "
		    "specified, ignoring\n", curpfxs->as, s);
		return (0);
	}

	if ((pfx = calloc(1, sizeof(*pfx))) == NULL)
		err(1, "prefixset_addmember calloc");

	if ((len = inet_net_pton(AF_INET, s, &pfx->addr.in,
	    sizeof(pfx->addr.in))) != -1) {
		pfx->af = AF_INET;
	} else {
		len = strtonum(slash + 1, 0, 128, &errstr);
		if (errstr)
			errx(1, "prefixset_addmember %s prefix %s: prefixlen "
			    "is %s", curpfxs->as, s, errstr);
		*slash = '\0';

		if ((ret = inet_pton(AF_INET6, s, &pfx->addr.in6)) == -1)
			err(1, "prefixset_addmember %s prefix \"%s\"",
			    curpfxs->as, s);
		else if (ret == 0) {
			fprintf(stderr, "prefixset_addmember %s prefix \"%s\": "
			    "No matching address family found", curpfxs->as, s);
			free(pfx);
			return (0);
		}
		pfx->af = AF_INET6;
	}
	pfx->len = pfx->maxlen = len;

	/* yes, there are dupes... e. g. from multiple sources */
	for (i = 0; i < curpfxs->prefixcnt; i++)
		if (irr_prefix_cmp(&curpfxs->prefix[i], &pfx) == 0) {
			free(pfx);
			return (0);
		}

	if ((p = reallocarray(curpfxs->prefix,
	    curpfxs->prefixcnt + 1, sizeof(void *))) == NULL)
		err(1, "prefixset_addmember realloc");
	curpfxs->prefix = p;
	curpfxs->prefixcnt++;
	curpfxs->prefix[curpfxs->prefixcnt - 1] = pfx;

	return (1);
}

void
prefixset_aggregate(struct prefix_set *pfxs)
{
	u_int			 i, cnt, newcnt;
	int			 res;
	struct irr_prefix	*cur, *last;
	void			*p;

	qsort(pfxs->prefix, pfxs->prefixcnt, sizeof(void *), irr_prefix_cmp);

	cnt = pfxs->prefixcnt;
	do {
		last = cur = NULL;
		for (i = 0, newcnt = 0; i < cnt; i++) {
			cur = pfxs->prefix[i];
			if (last != NULL && last->af == cur->af) {
				if (cur->af == AF_INET)
					res = prefix_aggregate(last, cur);
				else
					res = 0;

				if (res == 1) {	/* cur is covered by last */
					if (cur->len > last->maxlen)
						last->maxlen = cur->len;
					free(pfxs->prefix[i]);
					pfxs->prefix[i] = cur = NULL;
				}
			}

			if (cur != NULL) {
				pfxs->prefix[newcnt++] = cur;
				last = cur;
			}
		}
		cnt = newcnt;
	} while (newcnt < i);

	if (newcnt == pfxs->prefixcnt)
		return;

	if (irrverbose >= 2)
		printf("%s: prefix aggregation: %u -> %u\n",
		    pfxs->as, pfxs->prefixcnt, newcnt);

	if ((p = reallocarray(pfxs->prefix, newcnt, sizeof(void *))) == NULL)
		err(1, "prefixset_aggregate realloc");
	pfxs->prefix = p;
	pfxs->prefixcnt = newcnt;
}

int
prefix_aggregate(struct irr_prefix *a, const struct irr_prefix *b)
{
	in_addr_t	 mask;
	struct in6_addr	 ma;
	struct in6_addr	 mb;

	if (a->len == 0)
		return (1);

	if (a->af != b->af)
		/* We cannot aggregate addresses of different families. */
		return (0);

	if (a->af == AF_INET) {
		mask = htonl(prefixlen2mask(a->len));
		if ((a->addr.in.s_addr & mask) == (b->addr.in.s_addr & mask))
			return (1);
	} else if (a->af == AF_INET6) {
		inet6applymask(&ma, &a->addr.in6, a->len);
		inet6applymask(&mb, &b->addr.in6, a->len);
		if (IN6_ARE_ADDR_EQUAL(&ma, &mb))
			return (1);
	}

	/* see whether we can fold them in one */
	if (a->len == b->len && a->len > 1) {
		if (a->af == AF_INET) {
			mask = htonl(prefixlen2mask(a->len - 1));
			if ((a->addr.in.s_addr & mask) ==
			    (b->addr.in.s_addr & mask)) {
				a->len--;
				a->addr.in.s_addr &= mask;
				return (1);
			}
		} else if (a->af == AF_INET6) {
			inet6applymask(&ma, &a->addr.in6, a->len - 1);
			inet6applymask(&mb, &b->addr.in6, a->len - 1);

			if (IN6_ARE_ADDR_EQUAL(&ma, &mb)) {
				a->len--;
				memcpy(&a->addr.in6, &ma, sizeof(ma));
				return (1);
			}
		}
	}

	return (0);
}

int
irr_prefix_cmp(const void *a, const void *b)
{
	const struct irr_prefix	*pa;
	const struct irr_prefix	*pb;
	int			 r;

	pa = *((const struct irr_prefix	* const *)a);
	pb = *((const struct irr_prefix	* const *)b);

	if ((r = pa->af - pb->af) != 0)
		return (r);

	if (pa->af == AF_INET) {
		if (ntohl(pa->addr.in.s_addr) <
		    ntohl(pb->addr.in.s_addr))
			return (-1);
		if (ntohl(pa->addr.in.s_addr) >
		    ntohl(pb->addr.in.s_addr))
			return (1);
	} else if (pa->af == AF_INET6) {
		for (r = 0; r < 16; r++) {
			if (pa->addr.in6.s6_addr[r] < pb->addr.in6.s6_addr[r])
				return (-1);
			if (pa->addr.in6.s6_addr[r] > pb->addr.in6.s6_addr[r])
				return (1);
		}
	} else
		errx(1, "irr_prefix_cmp unknown af %u", pa->af);

	if ((r = pa->len - pb->len) != 0)
		return (r);

	return (0);
}

/* RB helpers */
int
prefix_set_compare(struct prefix_set *a, struct prefix_set *b)
{
	return (strcmp(a->as, b->as));
}

struct prefix_set *
prefix_set_find(char *as)
{
	struct prefix_set	s;

	s.as = as;
	return (RB_FIND(prefix_set_h, &prefix_set_h, &s));
}
@


1.20
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.19 2014/10/08 16:15:37 deraadt Exp $ */
a19 1
#include <sys/socket.h>
@


1.19
log
@Use reallocarray() throughout to spot multiplicative int overflow.
ok henning benno
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.18 2010/05/10 02:00:50 krw Exp $ */
a19 1
#include <sys/param.h>
@


1.18
log
@Various comment typos. 'wether' -> 'whether' (most popular), 'possiblity' ->
'possibility', 'optins' -> 'options', 'resposne' -> 'response', 'unecessary' -> 'unnecessary', 'desination' -> 'destination'. Collected from various misc@@
and tech@@ postings, many by Brad Tilley.
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.17 2009/09/08 16:11:36 sthen Exp $ */
d131 2
a132 2
	if ((p = realloc(curpfxs->prefix,
	    (curpfxs->prefixcnt + 1) * sizeof(void *))) == NULL)
d185 1
a185 1
	if ((p = realloc(pfxs->prefix, newcnt * sizeof(void *))) == NULL)
@


1.17
log
@Add -4 and -6 flags to irrfilter mode, allowing you to only fetch (you
guessed it) v4 or v6 from the IRR.  Reduces size of the filter file (and
thus router resource use) when you only speak IPv4 but you want to
filter peers who announce lots of v6 space.  ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.16 2009/09/08 15:40:25 claudio Exp $ */
d216 1
a216 1
	/* see wether we can fold them in one */
@


1.16
log
@Update irrfilter to support IPv6 and 4-byte AS numbers. IPv6 support based
on work by Tonnerre Lombard I just cleaned it up. OK henning, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.15 2007/05/27 18:54:25 henning Exp $ */
d67 3
a69 1
	if (whois(as, QTYPE_ROUTE) == -1)
@


1.15
log
@initialize pfx->pfx_maxlen too, rotting in my tree for some time
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.14 2007/03/06 16:45:34 henning Exp $ */
d32 1
d69 2
d86 3
a88 1
	int			 len;
d90 1
a90 1
	if (strchr(s, '/') == NULL) {
d100 11
a110 3
	    sizeof(pfx->addr.in))) == -1) {
		if (errno == ENOENT) {
			fprintf(stderr, "%s: prefix \"%s\": parse error\n",
d112 4
d117 2
a118 3
		} else
			err(1, "prefixset_addmember %s inet_net_pton \"%s\"",
			    curpfxs->as, s);
a119 2

	pfx->af = AF_INET;
d192 3
a194 1
	in_addr_t	mask;
d199 3
a201 1
	mask = htonl(0xffffffff << (32 - a->len));
d203 10
a212 2
	if ((a->addr.in.s_addr & mask) == (b->addr.in.s_addr & mask))
		return (1);
d216 17
a232 6
		mask = htonl(0xffffffff << (32 - (a->len - 1)));
		if ((a->addr.in.s_addr & mask) ==
		    (b->addr.in.s_addr & mask)) {
			a->len--;
			a->addr.in.s_addr &= mask;
			return (1);
d259 7
@


1.14
log
@prepare, but leave disabled, verbose operation so that you can see what is
going on (helps when the damn thing runs for hours). will be enabled with
a -v somewhen in the future
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.13 2007/03/06 00:27:33 henning Exp $ */
d106 1
a106 1
	pfx->len = len;
@


1.13
log
@another completely bogus route entry, this time openface in their own RR:
route:          198.73.251.0
no prefixlen...
overhaul error handling in prefixset_addmember(). for prefixes without
prefixlen or ones where inet_net_pton reports an invalid format, complain
and ignore the prefix, but don't err out completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.12 2007/03/05 22:10:50 henning Exp $ */
d61 4
d69 2
d165 1
a165 1
	if (0)
@


1.12
log
@better diagnostics on inet_net_pton failing
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.11 2007/03/05 16:43:24 henning Exp $ */
d23 1
d79 5
a83 2
	if (strchr(s, '/') == NULL)
		errx(1, "prefix %s does not have the len specified", s);
d89 9
a97 3
	    sizeof(pfx->addr.in))) == -1)
		err(1, "prefixset_addmember %s inet_net_pton \"%s\"",
		    curpfxs->as, s);
@


1.11
log
@gremlins keep putting tiny KNF violations in my code in the hope I don't
spot 'em
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.10 2007/03/05 16:40:10 henning Exp $ */
d86 2
a87 1
		err(1, "prefixset_addmember inet_net_pton \"%s\"", s);
@


1.10
log
@better error msg
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.9 2007/03/05 16:16:42 henning Exp $ */
d135 1
a135 1
			}	
@


1.9
log
@loop over the list calling prefix_aggregate until nothing can be aggregated
any more. since aggregated entries might be further aggregatable...
shaves of another 1200 lines (of ~16900) from the generated ruleset for my AS
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.7 2007/03/05 13:57:59 henning Exp $ */
d86 1
a86 1
		err(1, "inet_net_pton %s", s);
@


1.8
log
@lint happiness
@
text
@d111 1
a111 1
	u_int			 i, newcnt;
d118 10
a127 8
	last = cur = NULL;
	for (i = 0, newcnt = 0; i < pfxs->prefixcnt; i++) {
		cur = pfxs->prefix[i];
		if (last != NULL && last->af == cur->af) {
			if (cur->af == AF_INET)
				res = prefix_aggregate(last, cur);
			else
				res = 0;
d129 11
a139 5
			if (res == 1) {	/* cur is covered by last */
				if (cur->len > last->maxlen)
					last->maxlen = cur->len;
				free(pfxs->prefix[i]);
				pfxs->prefix[i] = cur = NULL;
d142 2
a143 6

		if (cur != NULL) {
			pfxs->prefix[newcnt++] = cur;
			last = cur;
		}
	}
@


1.7
log
@in prefix_aggregate(), when we look at two neighbor prefixes, see wether
they can be expressed as one with shorter prefixlen. if so, adjust the
first prefix accordingly and return 1 so the second gets removed.
shrinks the ruleset for my AS from 19533 to 16892 rules.
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.5 2007/03/05 12:57:56 henning Exp $ */
d34 1
a34 1
int	 prefix_compare(const void *, const void *);
a48 1
	int			 r;
d61 1
a61 1
	if ((r = whois(as, QTYPE_ROUTE)) == -1)
d93 1
a93 1
		if (prefix_compare(&curpfxs->prefix[i], &pfx) == 0) {
d116 1
a116 1
	qsort(pfxs->prefix, pfxs->prefixcnt, sizeof(void *), prefix_compare);
d182 1
a182 1
prefix_compare(const void *a, const void *b)
d202 1
a202 1
		errx(1, "prefix_compare unknown af %u", pa->af);
@


1.6
log
@do the prefix masking in network byte order
@
text
@d168 11
@


1.5
log
@sort out more specifics and mark the less specific covering them in a way
that the resulting rule allows more specifics. i. e.
10.0.0.0/16, 10.0.1/24, 10.0.128/17 -> prefix 10.0.0.0/16 prefixlen <= 24
implementation: sort prefixes per AS by address family, prefix, prefixlen.
for every entry, check wether the prefix with the previous entry's mask
applied matches the previous entry's prefix & mask. Only move the previous
pointer forward if not so. Fill the holes we create in the process on the
fly; shrink the array afterwards.
shrinks the generated filters for our AS from over 100k to under 20k lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.2 2007/03/04 20:05:11 henning Exp $ */
d163 1
a163 1
	mask = 0xffffffff << (32 - a->len);
d165 1
a165 1
	if ((ntohl(a->addr.in.s_addr) & mask) == (ntohl(b->addr.in.s_addr) & mask))
@


1.4
log
@correct include order
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.3 2007/03/04 20:31:22 henning Exp $ */
d32 2
d66 2
d94 1
a94 1
		if (prefix_compare(curpfxs->prefix[i], pfx) == 0) {
d109 62
d174 2
a175 2
	const struct irr_prefix	*pa = a;
	const struct irr_prefix	*pb = b;
d178 3
d183 1
d185 6
a190 3
		if ((r = ntohl(pa->addr.in.s_addr) -
		    ntohl(pb->addr.in.s_addr)) != 0)
			return (r);
@


1.3
log
@rename struct prefix -> irr_prefix
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.2 2007/03/04 20:05:11 henning Exp $ */
d27 1
a28 1
#include <netinet/in.h>
@


1.2
log
@store prefixes in binary format. we'll need that for aggregation.
discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: irr_prefix.c,v 1.1 2007/03/03 11:45:30 henning Exp $ */
d32 1
a32 1
int	 prefix_compare(void *, void *);
d70 4
a73 4
	void		*p;
	u_int		 i;
	struct prefix	*pfx;
	int		 len;
d106 1
a106 1
prefix_compare(void *a, void *b)
d108 3
a110 3
	struct prefix	*pa = a;
	struct prefix	*pb = b;
	int		 r;
d119 1
a119 1
		errx(1, "prefixcmp unknown af %u", pa->af);
@


1.1
log
@add irrfilter mode.
generates bgpd filter rules from the Internet Routing Registry aka IRR aka
the aut-num, as-set and route objects in the RIPE, ARIN, APNIC ... databases
accessed via whois, using the Routing Policy Specificaion Language RPSL.
implement the whois query interface, an RPSL parser (of course only the
parts we need), recursive as-set resolver, prefixes per AS lookup,
and an ouput module to make up the rules.
work in progress, not ready for general consumption yet.
import agreed by theo & claudio
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d21 1
d27 2
d32 1
d70 17
a86 2
	void	*p;
	u_int	 i;
d90 2
a91 1
		if (!strcmp(curpfxs->prefix[i], s))
d93 1
d96 2
a97 2
	    (curpfxs->prefixcnt + 1) * sizeof(char *))) == NULL)
		err(1, "prefixset_addmember strdup");
d100 1
a100 4

	if ((curpfxs->prefix[curpfxs->prefixcnt - 1] =
	    strdup(s)) == NULL)
		err(1, "prefixset_addmember strdup");
d105 21
@

