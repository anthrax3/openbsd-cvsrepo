head	1.77;
access;
symbols
	OPENBSD_6_1_BASE:1.77
	OPENBSD_6_0:1.73.0.4
	OPENBSD_6_0_BASE:1.73
	OPENBSD_5_9:1.73.0.2
	OPENBSD_5_9_BASE:1.73
	OPENBSD_5_8:1.70.0.4
	OPENBSD_5_8_BASE:1.70
	OPENBSD_5_7:1.69.0.2
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.68.0.6
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.68.0.4
	OPENBSD_5_5_BASE:1.68
	OPENBSD_5_4:1.66.0.2
	OPENBSD_5_4_BASE:1.66
	OPENBSD_5_3:1.65.0.4
	OPENBSD_5_3_BASE:1.65
	OPENBSD_5_2:1.65.0.2
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.63
	OPENBSD_5_1:1.63.0.2
	OPENBSD_5_0:1.62.0.6
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.62.0.4
	OPENBSD_4_9_BASE:1.62
	OPENBSD_4_8:1.62.0.2
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.61.0.2
	OPENBSD_4_7_BASE:1.61
	OPENBSD_4_6:1.54.0.4
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.51.0.2
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.50.0.2
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.40.0.2
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.34.0.2
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.77
date	2017.02.14.13.13.23;	author benno;	state Exp;
branches;
next	1.76;
commitid	FLT4Y9mdJDHJlvF2;

1.76
date	2017.02.13.14.48.44;	author phessler;	state Exp;
branches;
next	1.75;
commitid	UAS1mKyHLGdFBKFJ;

1.75
date	2017.01.13.18.59.12;	author phessler;	state Exp;
branches;
next	1.74;
commitid	3Jvf15B19ysa8i2W;

1.74
date	2016.10.14.16.05.35;	author phessler;	state Exp;
branches;
next	1.73;
commitid	Ai7XVOgXw9ZLovz1;

1.73
date	2015.10.11.19.53.57;	author sthen;	state Exp;
branches;
next	1.72;
commitid	23dXwNO8fbGA7yVS;

1.72
date	2015.10.11.19.21.44;	author phessler;	state Exp;
branches;
next	1.71;
commitid	YYeOOydTj48i98EL;

1.71
date	2015.10.05.14.18.33;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	QC0DB2Wb4abs7Ort;

1.70
date	2015.04.17.07.51.09;	author phessler;	state Exp;
branches;
next	1.69;
commitid	FgmHx68AdtL9Wg33;

1.69
date	2014.11.19.21.11.41;	author tedu;	state Exp;
branches;
next	1.68;
commitid	9iaXVutw5F5qkw5I;

1.68
date	2014.01.05.20.53.56;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2013.10.09.08.56.38;	author phessler;	state Exp;
branches;
next	1.66;

1.66
date	2013.03.07.21.28.34;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2012.05.27.18.53.50;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2012.03.27.18.24.11;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2011.09.21.10.37.51;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2010.05.03.13.11.41;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2010.03.08.17.02.19;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2010.01.13.06.04.00;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2010.01.10.00.16.23;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2009.12.01.14.29.40;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2009.11.02.20.38.45;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2009.09.08.16.11.36;	author sthen;	state Exp;
branches;
next	1.55;

1.55
date	2009.08.31.10.17.35;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.12.16.44.02;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.06.06.05.41;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2009.04.23.16.20.39;	author sthen;	state Exp;
branches;
next	1.51;

1.51
date	2008.08.31.08.29.35;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2008.06.15.09.58.43;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2008.06.11.03.19.39;	author tobias;	state Exp;
branches;
next	1.48;

1.48
date	2008.06.07.18.14.41;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2007.10.14.22.12.31;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.31.04.21.43;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.28.20.09.21;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2007.04.23.13.05.35;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2007.04.06.18.36.32;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2007.03.31.12.46.55;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2007.03.28.12.34.08;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2007.03.07.11.55.54;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.03.11.45.30;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2007.02.22.08.38.19;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2007.02.01.20.27.37;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2007.01.31.09.12.24;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2007.01.25.19.30.07;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2006.08.23.08.21.11;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.15.10.04.06;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2006.06.14.17.06.44;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.26.05.07.15;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.23.12.14.34;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.22.10.25.49;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.09.16.08.28;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.24.15.28.03;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2006.01.03.22.51.14;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.03.22.05.13;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.30.23.13.44;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.29.20.41.30;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.02.14.11.37;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.20.14.40.32;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2005.09.20.13.48.58;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2005.09.20.13.47.08;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.01.18.59.15;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.16.18.43.00;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.07.17.43.06;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.06.17.13.56;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.05.00.23.23;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.23.20.09.00;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.23.17.55.59;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.23.17.45.47;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.23.17.26.51;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.26.13.12.22;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.20.15.49.35;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.17.19.40.03;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.21.11.52.32;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.11.16.34.21;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.02.19.32.43;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.26.16.19.58;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.29.12.02.13;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.21.23.45.18;	author henning;	state Exp;
branches;
next	;


desc
@@


1.77
log
@fix a crash when parsing large community given on the command line
found by jsg@@, fixed by phessler@@ and strsep() by me.
fix memory leak jsg@@
ok jsg@@ phessler@@
@
text
@/*	$OpenBSD: parser.c,v 1.76 2017/02/13 14:48:44 phessler Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2016 Job Snijders <job@@instituut.net>
 * Copyright (c) 2016 Peter Hessler <phessler@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "parser.h"
#include "irrfilter.h"

enum token_type {
	NOTOKEN,
	ENDTOKEN,
	KEYWORD,
	ADDRESS,
	PEERADDRESS,
	FLAG,
	ASNUM,
	ASTYPE,
	PREFIX,
	PEERDESC,
	RIBNAME,
	SHUTDOWN_COMMUNICATION,
	COMMUNITY,
	LARGE_COMMUNITY,
	LOCALPREF,
	MED,
	NEXTHOP,
	PFTABLE,
	PREPNBR,
	PREPSELF,
	WEIGHT,
	FAMILY,
	GETOPT,
	RTABLE,
	FILENAME,
	BULK
};

enum getopts {
	GETOPT_NONE,
	GETOPT_IRRFILTER
};

struct token {
	enum token_type		 type;
	const char		*keyword;
	int			 value;
	const struct token	*next;
};

static const struct token t_main[];
static const struct token t_show[];
static const struct token t_show_summary[];
static const struct token t_show_fib[];
static const struct token t_show_rib[];
static const struct token t_show_mrt[];
static const struct token t_show_mrt_file[];
static const struct token t_show_rib_neigh[];
static const struct token t_show_mrt_neigh[];
static const struct token t_show_rib_rib[];
static const struct token t_show_neighbor[];
static const struct token t_show_neighbor_modifiers[];
static const struct token t_fib[];
static const struct token t_neighbor[];
static const struct token t_neighbor_modifiers[];
static const struct token t_show_rib_as[];
static const struct token t_show_mrt_as[];
static const struct token t_show_prefix[];
static const struct token t_show_ip[];
static const struct token t_show_community[];
static const struct token t_show_largecommunity[];
static const struct token t_network[];
static const struct token t_network_show[];
static const struct token t_prefix[];
static const struct token t_set[];
static const struct token t_community[];
static const struct token t_largecommunity[];
static const struct token t_localpref[];
static const struct token t_med[];
static const struct token t_nexthop[];
static const struct token t_pftable[];
static const struct token t_prepnbr[];
static const struct token t_prepself[];
static const struct token t_weight[];
static const struct token t_irrfilter[];
static const struct token t_irrfilter_opts[];
static const struct token t_log[];
static const struct token t_fib_table[];
static const struct token t_show_fib_table[];

static const struct token t_main[] = {
	{ KEYWORD,	"reload",	RELOAD,		NULL},
	{ KEYWORD,	"show",		SHOW,		t_show},
	{ KEYWORD,	"fib",		FIB,		t_fib},
	{ KEYWORD,	"neighbor",	NEIGHBOR,	t_neighbor},
	{ KEYWORD,	"network",	NONE,		t_network},
	{ KEYWORD,	"irrfilter",	IRRFILTER,	t_irrfilter},
	{ KEYWORD,	"log",		NONE,		t_log},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show[] = {
	{ NOTOKEN,	"",		NONE,		NULL},
	{ KEYWORD,	"fib",		SHOW_FIB,	t_show_fib},
	{ KEYWORD,	"interfaces",	SHOW_INTERFACE,	NULL},
	{ KEYWORD,	"neighbor",	SHOW_NEIGHBOR,	t_show_neighbor},
	{ KEYWORD,	"network",	NETWORK_SHOW,	t_network_show},
	{ KEYWORD,	"nexthop",	SHOW_NEXTHOP,	NULL},
	{ KEYWORD,	"rib",		SHOW_RIB,	t_show_rib},
	{ KEYWORD,	"tables",	SHOW_FIB_TABLES, NULL},
	{ KEYWORD,	"ip",		NONE,		t_show_ip},
	{ KEYWORD,	"summary",	SHOW_SUMMARY,	t_show_summary},
	{ KEYWORD,	"mrt",		SHOW_MRT,	t_show_mrt},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_summary[] = {
	{ NOTOKEN,	"",		NONE,			NULL},
	{ KEYWORD,	"terse",	SHOW_SUMMARY_TERSE,	NULL},
	{ ENDTOKEN,	"",		NONE,			NULL}
};

static const struct token t_show_fib[] = {
	{ NOTOKEN,	"",		NONE,		 NULL},
	{ FLAG,		"connected",	F_CONNECTED,	 t_show_fib},
	{ FLAG,		"static",	F_STATIC,	 t_show_fib},
	{ FLAG,		"bgp",		F_BGPD_INSERTED, t_show_fib},
	{ FLAG,		"nexthop",	F_NEXTHOP,	 t_show_fib},
	{ KEYWORD,	"table",	NONE,		 t_show_fib_table},
	{ FAMILY,	"",		NONE,		 t_show_fib},
	{ ADDRESS,	"",		NONE,		 NULL},
	{ ENDTOKEN,	"",		NONE,		 NULL}
};

static const struct token t_show_rib[] = {
	{ NOTOKEN,	"",		NONE,		NULL},
	{ ASTYPE,	"as",		AS_ALL,		t_show_rib_as},
	{ ASTYPE,	"source-as",	AS_SOURCE,	t_show_rib_as},
	{ ASTYPE,	"transit-as",	AS_TRANSIT,	t_show_rib_as},
	{ ASTYPE,	"peer-as",	AS_PEER,	t_show_rib_as},
	{ ASTYPE,	"empty-as",	AS_EMPTY,	t_show_rib},
	{ KEYWORD,	"community",	NONE,		t_show_community},
	{ KEYWORD,	"large-community", NONE,	t_show_largecommunity},
	{ FLAG,		"best",		F_CTL_ACTIVE,	t_show_rib},
	{ FLAG,		"selected",	F_CTL_ACTIVE,	t_show_rib},
	{ FLAG,		"detail",	F_CTL_DETAIL,	t_show_rib},
	{ FLAG,		"in",		F_CTL_ADJ_IN,	t_show_rib},
	{ FLAG,		"out",		F_CTL_ADJ_OUT,	t_show_rib},
	{ KEYWORD,	"neighbor",	NONE,		t_show_rib_neigh},
	{ KEYWORD,	"table",	NONE,		t_show_rib_rib},
	{ KEYWORD,	"summary",	SHOW_SUMMARY,	t_show_summary},
	{ KEYWORD,	"memory",	SHOW_RIB_MEM,	NULL},
	{ FAMILY,	"",		NONE,		t_show_rib},
	{ PREFIX,	"",		NONE,		t_show_prefix},
	{ ENDTOKEN,	"",		NONE,		NULL}
};


static const struct token t_show_mrt[] = {
	{ NOTOKEN,	"",		NONE,		NULL},
	{ ASTYPE,	"as",		AS_ALL,		t_show_mrt_as},
	{ ASTYPE,	"source-as",	AS_SOURCE,	t_show_mrt_as},
	{ ASTYPE,	"transit-as",	AS_TRANSIT,	t_show_mrt_as},
	{ ASTYPE,	"peer-as",	AS_PEER,	t_show_mrt_as},
	{ ASTYPE,	"empty-as",	AS_EMPTY,	t_show_mrt},
	{ FLAG,		"detail",	F_CTL_DETAIL,	t_show_mrt},
	{ KEYWORD,	"neighbor",	NONE,		t_show_mrt_neigh},
	{ KEYWORD,	"file",		NONE,		t_show_mrt_file},
	{ FAMILY,	"",		NONE,		t_show_mrt},
	{ PREFIX,	"",		NONE,		t_show_prefix},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_mrt_file[] = {
	{ FILENAME,	"",		NONE,		t_show_mrt},
	{ ENDTOKEN,	"",		NONE,	NULL}
};

static const struct token t_show_rib_neigh[] = {
	{ PEERADDRESS,	"",		NONE,	t_show_rib},
	{ PEERDESC,	"",		NONE,	t_show_rib},
	{ ENDTOKEN,	"",		NONE,	NULL}
};

static const struct token t_show_mrt_neigh[] = {
	{ PEERADDRESS,	"",		NONE,	t_show_mrt},
	{ ENDTOKEN,	"",		NONE,	NULL}
};

static const struct token t_show_rib_rib[] = {
	{ RIBNAME,	"",		NONE,	t_show_rib},
	{ ENDTOKEN,	"",		NONE,	NULL}
};

static const struct token t_show_neighbor[] = {
	{ NOTOKEN,	"",		NONE,	NULL},
	{ PEERADDRESS,	"",		NONE,	t_show_neighbor_modifiers},
	{ PEERDESC,	"",		NONE,	t_show_neighbor_modifiers},
	{ ENDTOKEN,	"",		NONE,	NULL}
};

static const struct token t_show_neighbor_modifiers[] = {
	{ NOTOKEN,	"",		NONE,			NULL},
	{ KEYWORD,	"timers",	SHOW_NEIGHBOR_TIMERS,	NULL},
	{ KEYWORD,	"messages",	SHOW_NEIGHBOR,		NULL},
	{ KEYWORD,	"terse",	SHOW_NEIGHBOR_TERSE,	NULL},
	{ ENDTOKEN,	"",		NONE,			NULL}
};

static const struct token t_fib[] = {
	{ KEYWORD,	"couple",	FIB_COUPLE,	NULL},
	{ KEYWORD,	"decouple",	FIB_DECOUPLE,	NULL},
	{ KEYWORD,	"table",	NONE,		t_fib_table},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_neighbor[] = {
	{ PEERADDRESS,	"",		NONE,		t_neighbor_modifiers},
	{ PEERDESC,	"",		NONE,		t_neighbor_modifiers},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_nei_mod_shutc[] = {
	{ NOTOKEN,	"",		NONE,		NULL},
	{ SHUTDOWN_COMMUNICATION, "",	NONE,		NULL},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_neighbor_modifiers[] = {
	{ KEYWORD,	"up",		NEIGHBOR_UP,		NULL},
	{ KEYWORD,	"down",		NEIGHBOR_DOWN,		t_nei_mod_shutc},
	{ KEYWORD,	"clear",	NEIGHBOR_CLEAR,		t_nei_mod_shutc},
	{ KEYWORD,	"refresh",	NEIGHBOR_RREFRESH,	NULL},
	{ KEYWORD,	"destroy",	NEIGHBOR_DESTROY,	NULL},
	{ ENDTOKEN,	"",		NONE,			NULL}
};

static const struct token t_show_rib_as[] = {
	{ ASNUM,	"",		NONE,		t_show_rib},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_mrt_as[] = {
	{ ASNUM,	"",		NONE,		t_show_mrt},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_prefix[] = {
	{ NOTOKEN,	"",		NONE,		NULL},
	{ FLAG,		"all",		F_LONGER,	NULL},
	{ FLAG,		"longer-prefixes", F_LONGER,	NULL},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_ip[] = {
	{ KEYWORD,	"bgp",		SHOW_RIB,	t_show_rib},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_community[] = {
	{ COMMUNITY,	"",		NONE,		t_show_rib},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_largecommunity[] = {
	{ LARGE_COMMUNITY,	"",	NONE,		t_show_rib},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_network[] = {
	{ KEYWORD,	"add",		NETWORK_ADD,	t_prefix},
	{ KEYWORD,	"delete",	NETWORK_REMOVE,	t_prefix},
	{ KEYWORD,	"flush",	NETWORK_FLUSH,	NULL},
	{ KEYWORD,	"show",		NETWORK_SHOW,	t_network_show},
	{ KEYWORD,	"mrt",		NETWORK_MRT,	t_show_mrt},
	{ KEYWORD,	"bulk",		NETWORK_BULK_ADD,	t_set},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_prefix[] = {
	{ PREFIX,	"",		NONE,		t_set},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_network_show[] = {
	{ NOTOKEN,	"",		NONE,			NULL},
	{ FAMILY,	"",		NONE,			NULL},
	{ ENDTOKEN,	"",		NONE,			NULL}
};

static const struct token t_set[] = {
	{ NOTOKEN,	"",			NONE,	NULL},
	{ KEYWORD,	"community",		NONE,	t_community},
	{ KEYWORD,	"large-community",	NONE,	t_largecommunity},
	{ KEYWORD,	"localpref",		NONE,	t_localpref},
	{ KEYWORD,	"med",			NONE,	t_med},
	{ KEYWORD,	"metric",		NONE,	t_med},
	{ KEYWORD,	"nexthop",		NONE,	t_nexthop},
	{ KEYWORD,	"pftable",		NONE,	t_pftable},
	{ KEYWORD,	"prepend-neighbor",	NONE,	t_prepnbr},
	{ KEYWORD,	"prepend-self",		NONE,	t_prepself},
	{ KEYWORD,	"weight",		NONE,	t_weight},
	{ KEYWORD,	"add",			NETWORK_BULK_ADD,	NULL},
	{ KEYWORD,	"delete",		NETWORK_BULK_REMOVE,	NULL},
	{ ENDTOKEN,	"",			NONE,	NULL}
};

static const struct token t_community[] = {
	{ COMMUNITY,	"",			NONE,	t_set},
	{ ENDTOKEN,	"",			NONE,	NULL}
};

static const struct token t_largecommunity[] = {
	{ LARGE_COMMUNITY,	"",		NONE,	t_set},
	{ ENDTOKEN,	"",			NONE,	NULL}
};

static const struct token t_localpref[] = {
	{ LOCALPREF,	"",			NONE,	t_set},
	{ ENDTOKEN,	"",			NONE,	NULL}
};

static const struct token t_med[] = {
	{ MED,		"",			NONE,	t_set},
	{ ENDTOKEN,	"",			NONE,	NULL}
};

static const struct token t_nexthop[] = {
	{ NEXTHOP,	"",			NONE,	t_set},
	{ ENDTOKEN,	"",			NONE,	NULL}
};

static const struct token t_pftable[] = {
	{ PFTABLE,	"",			NONE,	t_set},
	{ ENDTOKEN,	"",			NONE,	NULL}
};

static const struct token t_prepnbr[] = {
	{ PREPNBR,	"",			NONE,	t_set},
	{ ENDTOKEN,	"",			NONE,	NULL}
};

static const struct token t_prepself[] = {
	{ PREPSELF,	"",			NONE,	t_set},
	{ ENDTOKEN,	"",			NONE,	NULL}
};

static const struct token t_weight[] = {
	{ WEIGHT,	"",			NONE,	t_set},
	{ ENDTOKEN,	"",			NONE,	NULL}
};

static const struct token t_irrfilter[] = {
	{ GETOPT,	"",	GETOPT_IRRFILTER,	t_irrfilter},
	{ ASNUM,	"",	NONE,			t_irrfilter_opts},
	{ ENDTOKEN,	"",	NONE,			NULL}
};

static const struct token t_irrfilter_opts[] = {
	{ NOTOKEN,	"",		NONE,			NULL},
	{ FLAG,		"importonly",	F_IMPORTONLY,		t_irrfilter_opts},
	{ ENDTOKEN,	"",		NONE,			NULL}
};

static const struct token t_log[] = {
	{ KEYWORD,	"verbose",	LOG_VERBOSE,	NULL},
	{ KEYWORD,	"brief",	LOG_BRIEF,	NULL},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_fib_table[] = {
	{ RTABLE,	"",			NONE,	t_fib},
	{ ENDTOKEN,	"",			NONE,	NULL}
};

static const struct token t_show_fib_table[] = {
	{ RTABLE,	"",			NONE,	t_show_fib},
	{ ENDTOKEN,	"",			NONE,	NULL}
};

static struct parse_result	res;

const struct token	*match_token(int *argc, char **argv[],
			    const struct token []);
void			 show_valid_args(const struct token []);
int			 parse_addr(const char *, struct bgpd_addr *);
int			 parse_asnum(const char *, size_t, u_int32_t *);
int			 parse_number(const char *, struct parse_result *,
			     enum token_type);
int			 getcommunity(const char *);
int			 parse_community(const char *, struct parse_result *);
u_int			 getlargecommunity(const char *);
int			 parse_largecommunity(const char *, struct parse_result *);
int			 parse_nexthop(const char *, struct parse_result *);
int			 bgpctl_getopt(int *, char **[], int);

struct parse_result *
parse(int argc, char *argv[])
{
	const struct token	*table = t_main;
	const struct token	*match;

	bzero(&res, sizeof(res));
	res.community.as = COMMUNITY_UNSET;
	res.community.type = COMMUNITY_UNSET;
	res.large_community.as = COMMUNITY_UNSET;
	res.large_community.ld1 = COMMUNITY_UNSET;
	res.large_community.ld2 = COMMUNITY_UNSET;
	TAILQ_INIT(&res.set);
	if ((res.irr_outdir = getcwd(NULL, 0)) == NULL) {
		fprintf(stderr, "getcwd failed: %s\n", strerror(errno));
		return (NULL);
	}

	while (argc >= 0) {
		if ((match = match_token(&argc, &argv, table)) == NULL) {
			fprintf(stderr, "valid commands/args:\n");
			show_valid_args(table);
			return (NULL);
		}

		argc--;
		argv++;

		if (match->type == NOTOKEN || match->next == NULL)
			break;

		table = match->next;
	}

	if (argc > 0) {
		fprintf(stderr, "superfluous argument: %s\n", argv[0]);
		return (NULL);
	}

	return (&res);
}

const struct token *
match_token(int *argc, char **argv[], const struct token table[])
{
	u_int			 i, match;
	const struct token	*t = NULL;
	struct filter_set	*fs;
	const char		*word = *argv[0];
	size_t			wordlen = 0;

	match = 0;
	if (word != NULL)
		wordlen = strlen(word);
	for (i = 0; table[i].type != ENDTOKEN; i++) {
		switch (table[i].type) {
		case NOTOKEN:
			if (word == NULL || wordlen == 0) {
				match++;
				t = &table[i];
			}
			break;
		case KEYWORD:
			if (word != NULL && strncmp(word, table[i].keyword,
			    wordlen) == 0) {
				match++;
				t = &table[i];
				if (t->value)
					res.action = t->value;
			}
			break;
		case FLAG:
			if (word != NULL && strncmp(word, table[i].keyword,
			    wordlen) == 0) {
				match++;
				t = &table[i];
				res.flags |= t->value;
			}
			break;
		case FAMILY:
			if (word == NULL)
				break;
			if (!strcmp(word, "inet") ||
			    !strcasecmp(word, "IPv4")) {
				match++;
				t = &table[i];
				res.aid = AID_INET;
			}
			if (!strcmp(word, "inet6") ||
			    !strcasecmp(word, "IPv6")) {
				match++;
				t = &table[i];
				res.aid = AID_INET6;
			}
			if (!strcasecmp(word, "VPNv4")) {
				match++;
				t = &table[i];
				res.aid = AID_VPN_IPv4;
			}
			break;
		case ADDRESS:
			if (parse_addr(word, &res.addr)) {
				match++;
				t = &table[i];
				if (t->value)
					res.action = t->value;
			}
			break;
		case PEERADDRESS:
			if (parse_addr(word, &res.peeraddr)) {
				match++;
				t = &table[i];
				if (t->value)
					res.action = t->value;
			}
			break;
		case PREFIX:
			if (parse_prefix(word, wordlen, &res.addr, &res.prefixlen)) {
				match++;
				t = &table[i];
				if (t->value)
					res.action = t->value;
			}
			break;
		case ASTYPE:
			if (word != NULL && strncmp(word, table[i].keyword,
			    wordlen) == 0) {
				match++;
				t = &table[i];
				res.as.type = t->value;
			}
			break;
		case ASNUM:
			if (parse_asnum(word, wordlen, &res.as.as)) {
				match++;
				t = &table[i];
			}
			break;
		case PEERDESC:
			if (!match && word != NULL && wordlen > 0) {
				if (strlcpy(res.peerdesc, word,
				    sizeof(res.peerdesc)) >=
				    sizeof(res.peerdesc))
					errx(1, "neighbor description too "
					    "long");
				match++;
				t = &table[i];
			}
			break;
		case RIBNAME:
			if (!match && word != NULL && wordlen > 0) {
				if (strlcpy(res.rib, word, sizeof(res.rib)) >=
				    sizeof(res.rib))
					errx(1, "rib name too long");
				match++;
				t = &table[i];
			}
			break;
		case SHUTDOWN_COMMUNICATION:
			if (!match && word != NULL && wordlen > 0) {
				if (strlcpy(res.shutcomm, word,
				    sizeof(res.shutcomm)) >=
				    sizeof(res.shutcomm))
					errx(1, "shutdown reason too long");
				match++;
				t = &table[i];
			}
			break;
		case COMMUNITY:
			if (word != NULL && wordlen > 0 &&
			    parse_community(word, &res)) {
				match++;
				t = &table[i];
			}
			break;
		case LARGE_COMMUNITY:
			if (word != NULL && wordlen > 0 &&
			    parse_largecommunity(word, &res)) {
				match++;
				t = &table[i];
			}
			break;
		case LOCALPREF:
		case MED:
		case PREPNBR:
		case PREPSELF:
		case WEIGHT:
		case RTABLE:
			if (word != NULL && wordlen > 0 &&
			    parse_number(word, &res, table[i].type)) {
				match++;
				t = &table[i];
			}
			break;
		case NEXTHOP:
			if (word != NULL && wordlen > 0 &&
			    parse_nexthop(word, &res)) {
				match++;
				t = &table[i];
			}
			break;
		case PFTABLE:
			if (word != NULL && wordlen > 0) {
				if ((fs = calloc(1,
				    sizeof(struct filter_set))) == NULL)
					err(1, NULL);
				if (strlcpy(fs->action.pftable, word,
				    sizeof(fs->action.pftable)) >=
				    sizeof(fs->action.pftable))
					errx(1, "pftable name too long");
				TAILQ_INSERT_TAIL(&res.set, fs, entry);
				match++;
				t = &table[i];
			}
			break;
		case GETOPT:
			if (bgpctl_getopt(argc, argv, table[i].value)) {
				match++;
				t = &table[i];
			}
			break;
		case FILENAME:
			if (word != NULL && wordlen > 0) {
				if ((res.mrtfd = open(word, O_RDONLY)) == -1) {
					/*
					 * ignore error if path has no / and
					 * does not exist. In hope to print
					 * usage.
					 */
					if (errno == ENOENT &&
					    !strchr(word, '/'))
						break;
					err(1, "mrt open(%s)", word);
				}
				match++;
				t = &table[i];
			}
			break;
		case BULK:
			match++;
			t = &table[i];
			break;
		case ENDTOKEN:
			break;
		}
	}

	if (match != 1) {
		if (word == NULL)
			fprintf(stderr, "missing argument:\n");
		else if (match > 1)
			fprintf(stderr, "ambiguous argument: %s\n", word);
		else if (match < 1)
			fprintf(stderr, "unknown argument: %s\n", word);
		return (NULL);
	}

	return (t);
}

void
show_valid_args(const struct token table[])
{
	int	i;

	for (i = 0; table[i].type != ENDTOKEN; i++) {
		switch (table[i].type) {
		case NOTOKEN:
			fprintf(stderr, "  <cr>\n");
			break;
		case KEYWORD:
		case FLAG:
		case ASTYPE:
			fprintf(stderr, "  %s\n", table[i].keyword);
			break;
		case ADDRESS:
		case PEERADDRESS:
			fprintf(stderr, "  <address>\n");
			break;
		case PREFIX:
			fprintf(stderr, "  <address>[/<len>]\n");
			break;
		case ASNUM:
			fprintf(stderr, "  <asnum>\n");
			break;
		case PEERDESC:
			fprintf(stderr, "  <neighbor description>\n");
			break;
		case RIBNAME:
			fprintf(stderr, "  <rib name>\n");
			break;
		case SHUTDOWN_COMMUNICATION:
			fprintf(stderr, "  <shutdown reason>\n");
			break;
		case COMMUNITY:
			fprintf(stderr, "  <community>\n");
			break;
		case LARGE_COMMUNITY:
			fprintf(stderr, "  <large-community>\n");
			break;
		case LOCALPREF:
		case MED:
		case PREPNBR:
		case PREPSELF:
		case WEIGHT:
			fprintf(stderr, "  <number>\n");
			break;
		case RTABLE:
			fprintf(stderr, "  <rtableid>\n");
			break;
		case NEXTHOP:
			fprintf(stderr, "  <address>\n");
			break;
		case PFTABLE:
			fprintf(stderr, "  <pftable>\n");
			break;
		case FAMILY:
			fprintf(stderr, "  [ inet | inet6 | IPv4 | IPv6 | VPNv4 ]\n");
			break;
		case GETOPT:
			fprintf(stderr, "  <options>\n");
			break;
		case FILENAME:
			fprintf(stderr, "  <filename>\n");
			break;
		case BULK:
		case ENDTOKEN:
			break;
		}
	}
}

int
parse_addr(const char *word, struct bgpd_addr *addr)
{
	struct in_addr	ina;
	struct addrinfo	hints, *r;

	if (word == NULL)
		return (0);

	bzero(addr, sizeof(struct bgpd_addr));
	bzero(&ina, sizeof(ina));

	if (inet_net_pton(AF_INET, word, &ina, sizeof(ina)) != -1) {
		addr->aid = AID_INET;
		addr->v4 = ina;
		return (1);
	}

	bzero(&hints, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_DGRAM; /*dummy*/
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(word, "0", &hints, &r) == 0) {
		sa2addr(r->ai_addr, addr);
		freeaddrinfo(r);
		return (1);
	}

	return (0);
}

int
parse_prefix(const char *word, size_t wordlen, struct bgpd_addr *addr, u_int8_t *prefixlen)
{
	char		*p, *ps;
	const char	*errstr;
	int		 mask = -1;

	if (word == NULL)
		return (0);

	bzero(addr, sizeof(struct bgpd_addr));

	if ((p = strrchr(word, '/')) != NULL) {
		size_t plen = strlen(p);
		mask = strtonum(p + 1, 0, 128, &errstr);
		if (errstr)
			errx(1, "netmask %s", errstr);

		if ((ps = malloc(wordlen - plen + 1)) == NULL)
			err(1, "parse_prefix: malloc");
		strlcpy(ps, word, wordlen - plen + 1);

		if (parse_addr(ps, addr) == 0) {
			free(ps);
			return (0);
		}

		free(ps);
	} else
		if (parse_addr(word, addr) == 0)
			return (0);

	switch (addr->aid) {
	case AID_INET:
		if (mask == -1)
			mask = 32;
		if (mask > 32)
			errx(1, "invalid netmask: too large");
		addr->v4.s_addr = addr->v4.s_addr & htonl(prefixlen2mask(mask));
		break;
	case AID_INET6:
		if (mask == -1)
			mask = 128;
		inet6applymask(&addr->v6, &addr->v6, mask);
		break;
	default:
		return (0);
	}

	*prefixlen = mask;
	return (1);
}

int
parse_asnum(const char *word, size_t wordlen, u_int32_t *asnum)
{
	const char	*errstr;
	char		*dot;
	u_int32_t	 uval, uvalh = 0;

	if (word == NULL)
		return (0);

	if (wordlen < 1 || word[0] < '0' || word[0] > '9')
		return (0);

	if ((dot = strchr(word,'.')) != NULL) {
		*dot++ = '\0';
		uvalh = strtonum(word, 0, USHRT_MAX, &errstr);
		if (errstr)
			errx(1, "AS number is %s: %s", errstr, word);
		uval = strtonum(dot, 0, USHRT_MAX, &errstr);
		if (errstr)
			errx(1, "AS number is %s: %s", errstr, word);
	} else {
		uval = strtonum(word, 0, UINT_MAX, &errstr);
		if (errstr)
			errx(1, "AS number is %s: %s", errstr, word);
	}

	*asnum = uval | (uvalh << 16);
	return (1);
}

int
parse_number(const char *word, struct parse_result *r, enum token_type type)
{
	struct filter_set	*fs;
	const char		*errstr;
	u_int			 uval;

	if (word == NULL)
		return (0);

	uval = strtonum(word, 0, UINT_MAX, &errstr);
	if (errstr)
		errx(1, "number is %s: %s", errstr, word);

	/* number was parseable */
	if (type == RTABLE) {
		r->rtableid = uval;
		return (1);
	}

	if ((fs = calloc(1, sizeof(struct filter_set))) == NULL)
		err(1, NULL);
	switch (type) {
	case LOCALPREF:
		fs->type = ACTION_SET_LOCALPREF;
		fs->action.metric = uval;
		break;
	case MED:
		fs->type = ACTION_SET_MED;
		fs->action.metric = uval;
		break;
	case PREPNBR:
		if (uval > 128) {
			free(fs);
			return (0);
		}
		fs->type = ACTION_SET_PREPEND_PEER;
		fs->action.prepend = uval;
		break;
	case PREPSELF:
		if (uval > 128) {
			free(fs);
			return (0);
		}
		fs->type = ACTION_SET_PREPEND_SELF;
		fs->action.prepend = uval;
		break;
	case WEIGHT:
		fs->type = ACTION_SET_WEIGHT;
		fs->action.metric = uval;
		break;
	default:
		errx(1, "king bula sez bad things happen");
	}

	TAILQ_INSERT_TAIL(&r->set, fs, entry);
	return (1);
}

int
getcommunity(const char *s)
{
	const char	*errstr;
	u_int16_t	 uval;

	if (strcmp(s, "*") == 0)
		return (COMMUNITY_ANY);

	uval = strtonum(s, 0, USHRT_MAX, &errstr);
	if (errstr)
		errx(1, "Community is %s: %s", errstr, s);

	return (uval);
}

int
parse_community(const char *word, struct parse_result *r)
{
	struct filter_set	*fs;
	char			*p;
	int			 as, type;

	/* Well-known communities */
	if (strcasecmp(word, "NO_EXPORT") == 0) {
		as = COMMUNITY_WELLKNOWN;
		type = COMMUNITY_NO_EXPORT;
		goto done;
	} else if (strcasecmp(word, "NO_ADVERTISE") == 0) {
		as = COMMUNITY_WELLKNOWN;
		type = COMMUNITY_NO_ADVERTISE;
		goto done;
	} else if (strcasecmp(word, "NO_EXPORT_SUBCONFED") == 0) {
		as = COMMUNITY_WELLKNOWN;
		type = COMMUNITY_NO_EXPSUBCONFED;
		goto done;
	} else if (strcasecmp(word, "NO_PEER") == 0) {
		as = COMMUNITY_WELLKNOWN;
		type = COMMUNITY_NO_PEER;
		goto done;
	} else if (strcasecmp(word, "BLACKHOLE") == 0) {
		as = COMMUNITY_WELLKNOWN;
		type = COMMUNITY_BLACKHOLE;
		goto done;
	}

	if ((p = strchr(word, ':')) == NULL) {
		fprintf(stderr, "Bad community syntax\n");
		return (0);
	}
	*p++ = 0;

	as = getcommunity(word);
	type = getcommunity(p);

done:
	if (as == 0) {
		fprintf(stderr, "Invalid community\n");
		return (0);
	}
	if (as == COMMUNITY_WELLKNOWN)
		switch (type) {
		case COMMUNITY_NO_EXPORT:
		case COMMUNITY_NO_ADVERTISE:
		case COMMUNITY_NO_EXPSUBCONFED:
		case COMMUNITY_BLACKHOLE:
			/* valid */
			break;
		default:
			/* unknown */
			fprintf(stderr, "Unknown well-known community\n");
			return (0);
		}

	if ((fs = calloc(1, sizeof(struct filter_set))) == NULL)
		err(1, NULL);
	fs->type = ACTION_SET_COMMUNITY;
	fs->action.community.as = as;
	fs->action.community.type = type;

	r->community.as = as;
	r->community.type = type;

	TAILQ_INSERT_TAIL(&r->set, fs, entry);
	return (1);
}

u_int
getlargecommunity(const char *s)
{
	const char	*errstr;
	u_int32_t	 uval;

	if (strcmp(s, "*") == 0)
		return (COMMUNITY_ANY);

	uval = strtonum(s, 0, UINT_MAX, &errstr);
	if (errstr)
		errx(1, "Large Community is %s: %s", errstr, s);

	return (uval);
}

int
parse_largecommunity(const char *word, struct parse_result *r)
{
	struct filter_set *fs;
	char		*p, *po = strdup(word);
	char		*array[3] = { NULL, NULL, NULL };
	char		*val;
	int64_t		 as, ld1, ld2;
	int		 i = 0;

	p = po;
	while ((p != NULL) && (i < 3)) {
		val = strsep(&p, ":");
		array[i++] = val;
	}

	if ((p != NULL) || !(array[0] && array[1] && array[2]))
		errx(1, "Invalid Large-Community syntax");

	as   = getlargecommunity(array[0]);
	ld1  = getlargecommunity(array[1]);
	ld2  = getlargecommunity(array[2]);

	free(po);

	if ((fs = calloc(1, sizeof(struct filter_set))) == NULL)
		err(1, NULL);
	fs->type = ACTION_SET_LARGE_COMMUNITY;
	fs->action.large_community.as = as;
	fs->action.large_community.ld1 = ld1;
	fs->action.large_community.ld2 = ld2;

	r->large_community.as = as;
	r->large_community.ld1 = ld1;
	r->large_community.ld2 = ld2;

	TAILQ_INSERT_TAIL(&r->set, fs, entry);
	return (1);
}

int
parse_nexthop(const char *word, struct parse_result *r)
{
	struct filter_set	*fs;

	if ((fs = calloc(1, sizeof(struct filter_set))) == NULL)
		err(1, NULL);

	if (strcmp(word, "blackhole") == 0)
		fs->type = ACTION_SET_NEXTHOP_BLACKHOLE;
	else if (strcmp(word, "reject") == 0)
		fs->type = ACTION_SET_NEXTHOP_REJECT;
	else if (strcmp(word, "no-modify") == 0)
		fs->type = ACTION_SET_NEXTHOP_NOMODIFY;
	else if (parse_addr(word, &fs->action.nexthop)) {
		fs->type = ACTION_SET_NEXTHOP;
	} else {
		free(fs);
		return (0);
	}

	TAILQ_INSERT_TAIL(&r->set, fs, entry);
	return (1);
}

int
bgpctl_getopt(int *argc, char **argv[], int type)
{
	int	  ch;

	optind = optreset = 1;
	while ((ch = getopt((*argc) + 1, (*argv) - 1, "46o:")) != -1) {
		switch (ch) {
		case '4':
			res.flags = (res.flags | F_IPV4) & ~F_IPV6;
			break;
		case '6':
			res.flags = (res.flags | F_IPV6) & ~F_IPV4;
			break;
		case 'o':
			res.irr_outdir = optarg;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	if (optind > 1) {
		(*argc) -= (optind - 1);
		(*argv) += (optind - 1);

		/* need to move one backwards as calling code moves forward */
		(*argc)++;
		(*argv)--;
		return (1);
	} else
		return (0);
}
@


1.76
log
@draft-ietf-idr-shutdown extends to support a message on either of
"Administrative Shutdown" or "Administrative Reset"

patch submitted by Job Snijders, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.75 2017/01/13 18:59:12 phessler Exp $ */
d1036 3
a1038 2
	char		*p = strdup(word);
	char 		*array[3];
d1042 4
a1045 5
	while (p != NULL) {
		array[i++] = p;
		p = strchr(p, ':');
		if (p)
			*p++ = 0;
d1048 3
d1054 2
@


1.75
log
@Add support for draft-ietf-idr-shutdown

    BGP state = Idle, marked down with shutdown reason "goodbye, we are
    upgrading to openbsd 6.1", down for 00:00:17

developed by Peter van Dijk <peter.van.dijk@@powerdns.com> and Job
Snijders <job@@ntt.net>, thank you!

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.74 2016/10/14 16:05:35 phessler Exp $ */
d258 1
a258 1
	{ KEYWORD,	"clear",	NEIGHBOR_CLEAR,		NULL},
@


1.74
log
@Add support for draft-ietf-idr-large-community

Joint work with Job Snijders, many thanks!
OK benno@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.73 2015/10/11 19:53:57 sthen Exp $ */
d48 1
d249 6
d257 1
a257 1
	{ KEYWORD,	"down",		NEIGHBOR_DOWN,		NULL},
d581 10
d713 3
@


1.73
log
@Handle the blackhole well-known community in bgpctl as well (print it
symbolically, and don't deny its use in 'bgpctl sh rib comm 65535:6666').
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.72 2015/10/11 19:21:44 phessler Exp $ */
d5 2
d49 1
d96 1
d102 1
d168 1
d284 5
d313 1
d332 5
d411 2
d425 3
d581 7
d700 3
d991 51
@


1.72
log
@add "best" as an alias for "selected"
Helps finger memory for people used to Junipers

OK benno@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.71 2015/10/05 14:18:33 deraadt Exp $ */
d917 4
d942 1
@


1.71
log
@these 3 files do not need sys/socket.h
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.70 2015/04/17 07:51:09 phessler Exp $ */
d163 1
@


1.70
log
@parse_prefix in parse.c got changed but the declaration in bgpctl.c
wasn't updated, so we would crash when doing `bgpctl net bulk` commands.

Fix by moving parse_prefix into a header, since we use it in more than
one file.

crash found by henning@@
underlying problem found by blambert@@

OK sthen@@ deraadt@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.69 2014/11/19 21:11:41 tedu Exp $ */
a19 1
#include <sys/socket.h>
@


1.69
log
@reduce redundant strlen calls by calling it once and saving the value
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.68 2014/01/05 20:53:56 deraadt Exp $ */
a388 2
int			 parse_prefix(const char *, size_t, struct bgpd_addr *,
			     u_int8_t *);
@


1.68
log
@missing newline on error message
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.67 2013/10/09 08:56:38 phessler Exp $ */
d389 1
a389 1
int			 parse_prefix(const char *, struct bgpd_addr *,
d391 1
a391 1
int			 parse_asnum(const char *, u_int32_t *);
d445 1
d448 2
a449 1

d453 1
a453 1
			if (word == NULL || strlen(word) == 0) {
d460 1
a460 1
			    strlen(word)) == 0) {
d469 1
a469 1
			    strlen(word)) == 0) {
d513 1
a513 1
			if (parse_prefix(word, &res.addr, &res.prefixlen)) {
d522 1
a522 1
			    strlen(word)) == 0) {
d529 1
a529 1
			if (parse_asnum(word, &res.as.as)) {
d535 1
a535 1
			if (!match && word != NULL && strlen(word) > 0) {
d546 1
a546 1
			if (!match && word != NULL && strlen(word) > 0) {
d555 1
a555 1
			if (word != NULL && strlen(word) > 0 &&
d567 1
a567 1
			if (word != NULL && strlen(word) > 0 &&
d574 1
a574 1
			if (word != NULL && strlen(word) > 0 &&
d581 1
a581 1
			if (word != NULL && strlen(word) > 0) {
d601 1
a601 1
			if (word != NULL && strlen(word) > 0) {
d737 1
a737 1
parse_prefix(const char *word, struct bgpd_addr *addr, u_int8_t *prefixlen)
d749 1
d754 1
a754 1
		if ((ps = malloc(strlen(word) - strlen(p) + 1)) == NULL)
d756 1
a756 1
		strlcpy(ps, word, strlen(word) - strlen(p) + 1);
d790 1
a790 1
parse_asnum(const char *word, u_int32_t *asnum)
d799 1
a799 1
	if (strlen(word) < 1 || word[0] < '0' || word[0] > '9')
@


1.67
log
@Allow us to bulk add / delete routes with the same attributes.  Really
useful for distributing IP lists.

OK beck@@, claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.66 2013/03/07 21:28:34 claudio Exp $ */
d410 1
a410 1
		fprintf(stderr, "getcwd failed: %s", strerror(errno));
@


1.66
log
@Implement a bgpctl nei foo destroy that will remove the specified cloned
neighbor. The neighbor must be set down before calling this function.
OK phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.65 2012/05/27 18:53:50 claudio Exp $ */
d58 2
a59 1
	FILENAME
d284 1
d310 2
d615 4
d696 1
@


1.65
log
@Make it possible to load mrt table dumps into bgpd. This is a debug tool but
it  allows anyone to use MRT table dumps to load prefixes into a bgpd instance.
For example you can download the RIPE dumps and load full-feeds onto your
laptop until the poor thing dies.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.64 2012/03/27 18:24:11 claudio Exp $ */
d246 1
@


1.64
log
@Introduce "selected" as show rib attribute to only show selected routes.
Can be combined like: bgpctl show rib nei peer1 selected to only show
the routes that are used from neighbor peer1.
Requested by and OK deraadt@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.63 2011/09/21 10:37:51 claudio Exp $ */
d281 1
@


1.63
log
@Make it possible to parse MRT table dumps (all 3 formats) and display
them like the show rib / show rib detail output. It is also possible
to filter the output. e.g.
   bgpctl show mrt file ./bview.20110914.1600 as 22512 204.209.0.0/16 all
OK sthen@@, put it in henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.62 2010/05/03 13:11:41 claudio Exp $ */
d163 1
@


1.62
log
@Adjustments for multiple kroute table support. This adds a few new command
arguments (show tables and show fib table 1, etc).
Tested by sthen@@, OK to move on by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.61 2010/03/08 17:02:19 claudio Exp $ */
d24 1
d57 2
a58 1
	RTABLE
d78 2
d81 1
d88 2
a89 1
static const struct token t_show_as[];
d133 1
d157 4
a160 4
	{ ASTYPE,	"as",		AS_ALL,		t_show_as},
	{ ASTYPE,	"source-as",	AS_SOURCE,	t_show_as},
	{ ASTYPE,	"transit-as",	AS_TRANSIT,	t_show_as},
	{ ASTYPE,	"peer-as",	AS_PEER,	t_show_as},
d175 21
d202 5
d248 1
a248 1
static const struct token t_show_as[] = {
d253 5
d591 17
d682 3
d737 1
a737 1
			errx(1, "invalid netmask: %s", errstr);
@


1.61
log
@res.flags is not only used by the irrfilter so initializing them with
irrfilter flags is causing strange behaviour on other commands (like show fib).
Set the IPV4 and IPV6 flags at the end unless one of them got already set.
OK henning, sthen, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.60 2010/01/13 06:04:00 claudio Exp $ */
d55 2
a56 1
	GETOPT
d102 2
d124 1
d137 9
a145 8
	{ NOTOKEN,	"",		NONE,			NULL},
	{ FLAG,		"connected",	F_CONNECTED,		t_show_fib},
	{ FLAG,		"static",	F_STATIC,		t_show_fib},
	{ FLAG,		"bgp",		F_BGPD_INSERTED,	t_show_fib},
	{ FLAG,		"nexthop",	F_NEXTHOP,		t_show_fib},
	{ FAMILY,	"",		NONE,			t_show_fib},
	{ ADDRESS,	"",		NONE,			NULL},
	{ ENDTOKEN,	"",		NONE,			NULL}
d197 1
d328 10
d519 1
d612 3
d762 5
@


1.60
log
@Add VPNv4 to the understood address families in bgpctl.
OK henning@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.59 2010/01/10 00:16:23 claudio Exp $ */
a346 1
	res.flags = (F_IPV4 | F_IPV6);
@


1.59
log
@ribreq uses now a AID, use AID also on the parsing side and convert to
AF when necessary. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.58 2009/12/01 14:29:40 claudio Exp $ */
d416 2
a417 1
			if (!strcmp(word, "inet") || !strcmp(word, "IPv4")) {
d422 2
a423 1
			if (!strcmp(word, "inet6") || !strcmp(word, "IPv6")) {
d428 5
d603 1
a603 1
			fprintf(stderr, "  [ inet | inet6 | IPv4 | IPv6 ]\n");
@


1.58
log
@Update code to use the new AID address ids so that this works again with
bgpd. Reads OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.57 2009/11/02 20:38:45 claudio Exp $ */
d419 1
a419 1
				res.af = AF_INET;
d424 1
a424 1
				res.af = AF_INET6;
@


1.57
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging. henning, sthen, michele like the idea
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.56 2009/09/08 16:11:36 sthen Exp $ */
d620 1
a620 1
		addr->af = AF_INET;
d630 1
a630 7
		addr->af = AF_INET6;
		memcpy(&addr->v6,
		    &((struct sockaddr_in6 *)r->ai_addr)->sin6_addr,
		    sizeof(addr->v6));
		addr->scope_id =
		    ((struct sockaddr_in6 *)r->ai_addr)->sin6_scope_id;

d669 2
a670 2
	switch (addr->af) {
	case AF_INET:
d677 1
a677 1
	case AF_INET6:
@


1.56
log
@Add -4 and -6 flags to irrfilter mode, allowing you to only fetch (you
guessed it) v4 or v6 from the IRR.  Reduces size of the filter file (and
thus router resource use) when you only speak IPv4 but you want to
filter peers who announce lots of v6 space.  ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.55 2009/08/31 10:17:35 claudio Exp $ */
d100 1
d109 1
d314 6
@


1.55
log
@Just use UINT_MAX as the maximum 4-byte AS number. It is good enough here.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.54 2009/06/12 16:44:02 claudio Exp $ */
d339 1
d886 1
a886 1
	while ((ch = getopt((*argc) + 1, (*argv) - 1, "o:")) != -1) {
d888 6
@


1.54
log
@Kill copies of prefixlen2mask and inet6applymask their now in util.c
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.53 2009/06/06 06:05:41 claudio Exp $ */
d709 1
a709 1
		uval = strtonum(word, 0, ASNUM_MAX - 1, &errstr);
@


1.53
log
@bgpctl part of allowing alternate RIBs to be shown. Had to use the
keyword table because show rib rib foo is strange.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.52 2009/04/23 16:20:39 sthen Exp $ */
a876 27
}

/* XXX local copies from kroute.c, should go to a shared file */
in_addr_t
prefixlen2mask(u_int8_t prefixlen)
{
	if (prefixlen == 0)
		return (0);

	return (0xffffffff << (32 - prefixlen));
}

void
inet6applymask(struct in6_addr *dest, const struct in6_addr *src, int prefixlen)
{
	struct in6_addr	mask;
	int		i;

	bzero(&mask, sizeof(mask));
	for (i = 0; i < prefixlen / 8; i++)
		mask.s6_addr[i] = 0xff;
	i = prefixlen % 8;
	if (i)
		mask.s6_addr[prefixlen / 8] = 0xff00 >> i;

	for (i = 0; i < 16; i++)
		dest->s6_addr[i] = src->s6_addr[i] & mask.s6_addr[i];
@


1.52
log
@allow bgpctl and bgpd.conf to contain 32-bit ASN written in ASPLAIN
format (RFC5396). ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.51 2008/08/31 08:29:35 claudio Exp $ */
d45 1
d76 1
d153 1
d167 5
d467 9
d566 3
@


1.51
log
@Fix AS check in parse_community() -- well-known communities have the AS
part set to COMMUNITY_WELLKNOWN which is the same as USHRT_MAX.
Figured out by Greg Skinner
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.50 2008/06/15 09:58:43 claudio Exp $ */
d689 1
a689 1
		uval = strtonum(word, 0, USHRT_MAX - 1, &errstr);
@


1.50
log
@Fix minor mem leak in case parse_addr() fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.49 2008/06/11 03:19:39 tobias Exp $ */
d804 1
a804 1
	if (as == 0 || as == USHRT_MAX) {
d817 1
a817 1
			fprintf(stderr, "Invalid well-known community\n");
@


1.49
log
@getcwd can return NULL on error, so handle that case properly.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.48 2008/06/07 18:14:41 henning Exp $ */
d636 2
a637 1
		if (parse_addr(ps, addr) == 0)
d639 1
@


1.48
log
@teach the command lineparser about getopt style options after commands
use that for irrfilter mode.
hints from theo a year ago, code by me a year ago, ok claudio a year ago
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.47 2007/10/14 22:12:31 deraadt Exp $ */
d332 4
a335 1
	res.irr_outdir = getcwd(NULL, 0);
@


1.47
log
@do not fallthrough
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.46 2007/05/31 04:21:43 claudio Exp $ */
d29 1
d53 7
a59 1
	FAMILY
d295 3
a297 2
	{ ASNUM,	"",		NONE,		t_irrfilter_opts},
	{ ENDTOKEN,	"",		NONE,		NULL}
d308 2
a309 1
const struct token	*match_token(const char *, const struct token []);
d320 1
d332 1
d335 1
a335 1
		if ((match = match_token(argv[0], table)) == NULL) {
d359 1
a359 1
match_token(const char *word, const struct token table[])
d364 1
d495 6
d566 3
d879 29
@


1.46
log
@Use COMMUNITY_UNSET in bgpctl as well. This makes it possible to filter
on communities with 0 in them.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.45 2007/05/28 20:09:21 henning Exp $ */
d547 1
@


1.45
log
@parse_asnum must return 0 (no match) if word is not an as number instead
of bitching and erroring out.
worked so far because at the position it kicked in, only asnumor nothing
were allowed
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.44 2007/04/23 13:05:35 claudio Exp $ */
d319 2
@


1.44
log
@bgpctl needs to know about 4-byte AS numbers as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.43 2007/04/06 18:36:32 claudio Exp $ */
d646 3
@


1.43
log
@Implement "bgpctl show neighbor <peer> terse" this will print all statistics
in an easily parseable form. This output can be used to implement SNMP MIBs
or rrdtool/mrtg update scripts. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.42 2007/03/31 12:46:55 henning Exp $ */
d305 1
a305 1
int			 parse_asnum(const char *, u_int16_t *);
d639 1
a639 1
parse_asnum(const char *word, u_int16_t *asnum)
d642 2
a643 1
	u_int16_t	 uval;
d648 13
a660 3
	uval = strtonum(word, 0, USHRT_MAX - 1, &errstr);
	if (errstr)
		errx(1, "AS number is %s: %s", errstr, word);
d662 1
a662 1
	*asnum = uval;
@


1.42
log
@some KNF, partially pt out by  rivo nurges <rix@@estpak.ee>
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.41 2007/03/28 12:34:08 henning Exp $ */
d144 1
a144 1
	{ KEYWORD,	"summary",	SHOW_SUMMARY,	NULL},
d168 1
@


1.41
log
@add support for bgpctl show rib community <community>
mostly from rivo nurges <rix@@estpak.ee>, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.40 2007/03/07 11:55:54 henning Exp $ */
d139 1
a139 1
	{ KEYWORD, 	"community", 	NONE, 		t_show_community},
d209 2
a210 2
	{ COMMUNITY, 	"", 		NONE, 		t_show_rib},
	{ ENDTOKEN, 	"", 		NONE, 		NULL}
@


1.40
log
@support "bgpctl show rib peer-as NN", From: Armin Wolfermann <aw@@osn.de>
ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.39 2007/03/03 11:45:30 henning Exp $ */
d76 1
d139 1
d208 5
d782 3
@


1.39
log
@add irrfilter mode.
generates bgpd filter rules from the Internet Routing Registry aka IRR aka
the aut-num, as-set and route objects in the RIPE, ARIN, APNIC ... databases
accessed via whois, using the Routing Policy Specificaion Language RPSL.
implement the whois query interface, an RPSL parser (of course only the
parts we need), recursive as-set resolver, prefixes per AS lookup,
and an ouput module to make up the rules.
work in progress, not ready for general consumption yet.
import agreed by theo & claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.38 2007/02/22 08:38:19 henning Exp $ */
d136 1
@


1.38
log
@minor KNF bits here too
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.37 2007/02/01 20:27:37 claudio Exp $ */
d31 1
d88 2
d97 1
d278 10
@


1.37
log
@Correct function name in err() message.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.36 2007/01/31 09:12:24 claudio Exp $ */
d65 2
a66 2
static const struct token t_show_rib[]; 
static const struct token t_show_rib_neigh[]; 
a815 1

@


1.36
log
@Switch from strtoul() to strtonum() making the code easier to read.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.35 2007/01/25 19:30:07 claudio Exp $ */
d583 1
a583 1
			err(1, "host: malloc");
@


1.35
log
@Correctly detect missing arguments. Same diff as in ospfctl. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.34 2006/08/23 08:21:11 claudio Exp $ */
d618 2
a619 2
	u_long	 ulval;
	char	*ep;
d624 5
a628 9
	errno = 0;
	ulval = strtoul(word, &ep, 0);
	if (word[0] == '\0' || *ep != '\0')
		return (0);
	if (errno == ERANGE && ulval == ULONG_MAX)
		return (0);
	if (ulval > USHRT_MAX)
		return (0);
	*asnum = (u_int16_t)ulval;
d636 2
a637 2
	u_long			 ulval;
	char			*ep;
d642 3
a644 8
	errno = 0;
	ulval = strtoul(word, &ep, 0);
	if (word[0] == '\0' || *ep != '\0')
		return (0);
	if (errno == ERANGE && ulval == ULONG_MAX)
		return (0);
	if (ulval > UINT_MAX)
		return (0);
d652 1
a652 1
		fs->action.metric = ulval;
d656 1
a656 1
		fs->action.metric = ulval;
d659 1
a659 1
		if (ulval > 128) {
d664 1
a664 1
		fs->action.prepend = ulval;
d667 1
a667 1
		if (ulval > 128) {
d672 1
a672 1
		fs->action.prepend = ulval;
d676 1
a676 1
		fs->action.metric = ulval;
d689 2
a690 2
	char	*ep;
	u_long	 ulval;
d695 3
a697 8
	errno = 0;
	ulval = strtoul(s, &ep, 0);
	if (s[0] == '\0' || *ep != '\0')
		return (COMMUNITY_ERROR);
	if (errno == ERANGE && ulval == ULONG_MAX)
		return (COMMUNITY_ERROR);
	if (ulval > USHRT_MAX)
		return (COMMUNITY_ERROR);
d699 1
a699 1
	return (ulval);
d707 1
a707 2
	int			 i;
	u_int16_t		 as, type;
d734 2
a735 11
	if ((i = getcommunity(word)) == COMMUNITY_ERROR) {
		fprintf(stderr, "\"%s\" is not a number or too big", word);
		return (0);
	}
	as = i;

	if ((i = getcommunity(p)) == COMMUNITY_ERROR) {
		fprintf(stderr, "\"%s\" is not a number or too big", p);
		return (0);
	}
	type = i;
@


1.34
log
@Extend show rib command. Following new options are added:
 in: show the unfiltered input of a neighbor aka adj-rib-in
 out: show only the prefixes that are sent to a specified neighbor (adj-rib-out)
 neighbor <IP>: limit the output of the command to prefixes sent by the
                specified neighbor

OK henning@@ manpage with help by jmc@@ but the show rib section needs some
rework because it starts to be confusing. Actually the parser needs to get
smarter.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.33 2006/06/15 10:04:06 claudio Exp $ */
d298 1
a298 1
	while (argc > 0) {
d464 3
a466 1
		if (match > 1)
d468 1
a468 1
		if (match < 1)
@


1.33
log
@Move the PREFIX token to the end of the list. The other tokens are more
specific in what they match.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.32 2006/06/14 17:06:44 claudio Exp $ */
d37 1
d65 2
a66 1
static const struct token t_show_rib[];
d132 5
a136 1
	{ ASTYPE,	"empty-as",	AS_EMPTY,	NULL},
a137 1
	{ FLAG,		"detail",	F_CTL_DETAIL,	t_show_rib},
d139 1
a139 1
	{ FAMILY,	"",		NONE,		NULL},
d144 6
d152 1
a152 1
	{ ADDRESS,	"",		NONE,	t_show_neighbor_modifiers},
d171 1
a171 1
	{ ADDRESS,	"",		NONE,		t_neighbor_modifiers},
d185 1
a185 1
	{ ASNUM,	"",		NONE,		NULL},
d378 8
d490 1
@


1.32
log
@Use inet_net_pton() instead of inet_pton() so that it is possible to use
10/8 as prefix. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.31 2006/05/26 05:07:15 henning Exp $ */
a126 1
	{ PREFIX,	"",		NONE,		t_show_prefix},
d135 1
@


1.31
log
@change keyword for route refresh request to just refresh, discussed with
claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.30 2006/05/23 12:14:34 henning Exp $ */
d518 1
a518 1
	if (inet_pton(AF_INET, word, &ina) == 1) {
@


1.30
log
@support requesting route refresh from a neighbor
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.29 2006/03/22 10:25:49 claudio Exp $ */
d169 1
a169 1
	{ KEYWORD,	"rrefresh",	NEIGHBOR_RREFRESH,	NULL},
@


1.29
log
@Detailed RIB output including communities. Detailed output is enabled via
the "detailed" keyword. Currently only works for IP or prefix lookups like
"bgpctl show rib detail 199.185.137.3". Requested by many, looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.28 2006/02/09 16:08:28 claudio Exp $ */
d166 5
a170 4
	{ KEYWORD,	"up",		NEIGHBOR_UP,	NULL},
	{ KEYWORD,	"down",		NEIGHBOR_DOWN,	NULL},
	{ KEYWORD,	"clear",	NEIGHBOR_CLEAR,	NULL},
	{ ENDTOKEN,	"",		NONE,		NULL}
@


1.28
log
@inet_pton() may return 1, 0 or -1. Only 1 is success so check explicitly
for it. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.27 2006/01/24 15:28:03 henning Exp $ */
d133 1
@


1.27
log
@introduce "bgpctl show summary terse", shows summary in an easy to parse
format, intended for monitoring puposes. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.26 2006/01/03 22:51:14 claudio Exp $ */
d516 1
a516 1
	if (inet_pton(AF_INET, word, &ina)) {
@


1.26
log
@Show RIB statistics via "bgpctl show rib mem".
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.25 2006/01/03 22:05:13 claudio Exp $ */
d62 1
d104 1
a104 1
	{ KEYWORD,	"summary",	SHOW_SUMMARY,	NULL},
d106 6
@


1.25
log
@Don't use fatal() and friend in bgpctl. The log system does not work here.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.24 2005/12/30 23:13:44 claudio Exp $ */
d126 1
@


1.24
log
@Fix parse_prefix() for IPv4 addresses. Looks like fallout after IPv6 addition.
Now bgpctl show rib 129.128.5.191 works again.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.23 2005/11/29 20:41:30 claudio Exp $ */
d551 1
a551 1
			fatal("host: malloc");
@


1.23
log
@tabs on empty lines
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.22 2005/11/02 14:11:37 claudio Exp $ */
a535 1
	struct in_addr	 ina;
a543 1
	bzero(&ina, sizeof(ina));
d568 1
a568 1
		addr->v4.s_addr = ina.s_addr & htonl(prefixlen2mask(mask));
@


1.22
log
@Add IPv6 support for the address and prefix parser. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.21 2005/09/20 14:40:32 henning Exp $ */
d551 1
a551 1
		
d558 1
a558 1
		
@


1.21
log
@allow "show rib" to be limited to an address family too
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.20 2005/09/20 13:48:58 henning Exp $ */
d19 3
d25 1
d500 1
d514 16
d537 3
a539 1
	int		 bits = 32;
d547 10
a556 3
	if (strrchr(word, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, word,
		    &ina, sizeof(ina))) == -1)
d558 21
a578 7
		addr->af = AF_INET;
		addr->v4.s_addr = ina.s_addr & htonl(prefixlen2mask(bits));
		*prefixlen = bits;
		return (1);
	} else {
		*prefixlen = 32;
		return (parse_addr(word, addr));
d581 2
a582 1
	return (0);
d784 1
a784 1
/* XXX local copy from kroute.c, should go to a shared file */
d793 18
@


1.20
log
@for consistency, make "show network" and alias for "network show"
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.19 2005/09/20 13:47:08 henning Exp $ */
d122 1
@


1.19
log
@allow the "show network" output to be limited to a given address family
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.18 2005/07/01 18:59:15 fgsch Exp $ */
d95 1
@


1.18
log
@fix breakage; if this proves to be wrong, will be fixed later. at least
make build will work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.17 2005/06/16 18:43:00 henning Exp $ */
d69 1
d178 1
a178 1
	{ KEYWORD,	"show",		NETWORK_SHOW,	NULL},
d185 6
@


1.17
log
@use prefixlen2mask() instead of doing the bitshifting by hand; fixes the
zero prefixlen case (32 bit shift on 32 bit val -> undefined result)
spotted by Moritz Grimm and otto
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.16 2005/06/07 17:43:06 claudio Exp $ */
d262 1
a262 1
	SIMPLEQ_INIT(&res.set);
d411 1
a411 1
				SIMPLEQ_INSERT_TAIL(&res.set, fs, entry);
d607 1
a607 1
	SIMPLEQ_INSERT_TAIL(&r->set, fs, entry);
d701 1
a701 1
	SIMPLEQ_INSERT_TAIL(&r->set, fs, entry);
d726 1
a726 1
	SIMPLEQ_INSERT_TAIL(&r->set, fs, entry);
@


1.16
log
@In case strlcpy() indicates that a string was truncated fail with errx().
No need for other strange constructs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.15 2005/06/06 17:13:56 henning Exp $ */
d520 1
a520 1
		addr->v4.s_addr = ina.s_addr & htonl(0xffffffff << (32 - bits));
d728 10
@


1.15
log
@add support for a "family" token, allows to select address families
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.14 2005/06/05 00:23:23 henning Exp $ */
d371 2
a372 1
					err(1, "neighbor description too long");
d409 2
a410 6
				    sizeof(fs->action.pftable)) {
					fprintf(stderr,
					    "pftable name too long");
					free(fs);
					break;
				}
@


1.14
log
@grr, more whitespace KNF, more carrot for claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.13 2005/05/23 20:09:00 claudio Exp $ */
d45 2
a46 1
	WEIGHT
d107 1
d322 14
d478 2
@


1.13
log
@Make it possible to dynamicaly add networks with attributes like communities
or metrics. Requested by beck@@ OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.12 2004/12/23 17:55:59 henning Exp $ */
d621 1
a621 1
	char 			*p;
d685 1
a685 1
	
@


1.12
log
@allo the "bgpctl show neighbor " commands to take the neighbor descr
too, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.11 2004/12/23 17:45:47 henning Exp $ */
d37 9
a45 1
	PEERDESC
d67 6
d74 4
a77 1
static const struct token t_prefix[];
d84 1
a84 1
	{ KEYWORD,	"network",	NONE,		t_nexthop},
d171 1
a171 1
static const struct token t_nexthop[] = {
d180 1
a180 1
	{ PREFIX,	"",		NONE,		NULL},
d184 55
d247 5
d260 1
d291 1
d360 43
d446 16
d534 178
@


1.11
log
@must only try to match PEERDESC of nothing else matched, it's just a string
and will match almost everything...
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.10 2004/12/23 17:26:51 henning Exp $ */
d107 1
@


1.10
log
@allow "bgpctl neighbor" to take the peer's descr as argument as well
as its address
so "bgpctl neighbor upstream1 clear" now works and you don't have to
remember IPs
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.9 2004/10/26 13:12:22 henning Exp $ */
d271 1
a271 1
			if (word != NULL && strlen(word) > 0) {
@


1.9
log
@ease the parser a bit.
parse() now wants the first argv member to be the first argument it parses,
i. e. it does not skip over argv[0] any more, caller has to account for that.
the caller does the usual getopt followed by argv += optind; argc -= optind;
dance so this is accounted for.
in parse() don't use a seperate curarg counter, just in/decrease argv/argc
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.8 2004/08/20 15:49:35 henning Exp $ */
d36 2
a37 1
	PREFIX
d125 1
d270 10
d320 3
a396 1

@


1.8
log
@add support for "bgpctl neighbor 1.2.3.4 clear", takes session down & up again
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.7 2004/06/17 19:40:03 henning Exp $ */
a175 1
	int			 curarg = 1;
a177 1
	char			*word;
a179 2
	if (argc == 1)
		return (&res);
d181 2
a182 7
	for (;;) {
		if (argc > curarg)
			word = argv[curarg];
		else
			word = NULL;

		if ((match = match_token(word, table)) == NULL) {
d188 2
a189 4
		curarg++;

		if (match->type == NOTOKEN)
			break;
d191 1
a191 1
		if (match->next == NULL)
d197 2
a198 2
	if (curarg < argc) {
		fprintf(stderr, "superfluous argument: %s\n", argv[curarg]);
@


1.7
log
@print '<cr>' instead of '(nothing)' when we hit the end token in the
context-dependent usage help
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.6 2004/05/21 11:52:32 claudio Exp $ */
d130 1
@


1.6
log
@Make it possible to add, delete, flush and show network announcements.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.5 2004/03/11 16:34:21 henning Exp $ */
d302 1
a302 1
			fprintf(stderr, "  (nothing)\n");
@


1.5
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.4 2004/03/02 19:32:43 claudio Exp $ */
d58 2
d66 1
d147 13
@


1.4
log
@show rib A.B.C.D and show rib A.B.C.D/N [all] support. Now the most important
show commands are available. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.3 2004/02/26 16:19:58 claudio Exp $ */
d192 1
a192 1
		fprintf(stderr, "superflous argument: %s\n", argv[curarg]);
@


1.3
log
@Implement "show rib" and "show rib <astype> <AS>" commands to dump the
RIB. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.2 2004/01/29 12:02:13 henning Exp $ */
d19 1
d35 2
a36 1
	ASTYPE
d56 1
d91 1
d96 1
d135 7
d152 2
d240 8
d296 3
d323 28
@


1.2
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.1 2004/01/21 23:45:18 henning Exp $ */
d19 2
d22 1
d32 3
a34 1
	FLAG
d47 1
d53 2
d70 2
d86 9
d96 1
a96 1
	{ NOTOKEN,	"",		NONE,			NULL},
d125 10
d140 1
d170 1
a170 1
	
d226 14
d263 1
a263 1
		case NONE:
d268 1
d274 3
d302 22
@


1.1
log
@new parser.
completely table driven and not wired into the action code like the
previous parser...
i wanted to do this for some time, and now it was just due.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpctl.c,v 1.32 2004/01/20 13:11:39 henning Exp $ */
d140 1
a140 1
			
d142 1
a142 1
			break;		
@

