head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.8
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.12
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.8
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.6
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.14
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.12
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.10
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.24
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.22
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.20
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.18
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.16
	OPENBSD_2_8:1.3.0.14
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.12
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.7
date	2015.09.05.09.38.23;	author jsg;	state Exp;
branches;
next	1.6;
commitid	UpUFsGTtXuYYIcjh;

1.6
date	2013.04.19.05.06.21;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.27.23.59.54;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.06.21.26.14;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.09.17.23.09.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.08.10.21.06.41;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.07.20.05.02.36;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Avoid unintended problems with operator precedence when doing an
assignment and comparison.

ok deraadt@@ looks correct millert@@ jung@@
@
text
@/*	$OpenBSD: test.c,v 1.6 2013/04/19 05:06:21 deraadt Exp $	*/

#include <rpc/rpc.h>
#include <rpcsvc/nlm_prot.h>

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = {0, 0};

nlm_testres *
nlm_test_1(struct nlm_testargs *argp, CLIENT *clnt)
{
	static nlm_testres res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_TEST, xdr_nlm_testargs, argp, xdr_nlm_testres,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
}


nlm_res *
nlm_lock_1(struct nlm_lockargs *argp, CLIENT *clnt)
{
	enum clnt_stat st;
	static nlm_res res;

	bzero((char *) &res, sizeof(res));
	if ((st = clnt_call(clnt, NLM_LOCK, xdr_nlm_lockargs, argp, xdr_nlm_res,
	    &res, TIMEOUT)) != RPC_SUCCESS) {
		printf("clnt_call returns %d\n", st);
		clnt_perror(clnt, "humbug");
		return (NULL);
	}
	return (&res);
}


nlm_res *
nlm_cancel_1(struct nlm_cancargs *argp, CLIENT *clnt)
{
	static nlm_res res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_CANCEL, xdr_nlm_cancargs, argp, xdr_nlm_res,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
}


nlm_res *
nlm_unlock_1(struct nlm_unlockargs *argp, CLIENT *clnt)
{
	static nlm_res res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_UNLOCK, xdr_nlm_unlockargs, argp, xdr_nlm_res,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
}


nlm_res *
nlm_granted_1(struct nlm_testargs *argp, CLIENT *clnt)
{
	static nlm_res res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_GRANTED, xdr_nlm_testargs, argp, xdr_nlm_res,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
}


void   *
nlm_test_msg_1(struct nlm_testargs *argp, CLIENT *clnt)
{
	static char res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_TEST_MSG, xdr_nlm_testargs, argp, xdr_void,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *) &res);
}


void   *
nlm_lock_msg_1(struct nlm_lockargs *argp, CLIENT *clnt)
{
	static char res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_LOCK_MSG, xdr_nlm_lockargs, argp, xdr_void, NULL, TIMEOUT) != RPC_SUCCESS) {
		clnt_perror(clnt, "nlm_lock_msg_1");
		return (NULL);
	}
	return ((void *) &res);
}


void   *
nlm_cancel_msg_1(struct nlm_cancargs *argp, CLIENT *clnt)
{
	static char res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_CANCEL_MSG, xdr_nlm_cancargs, argp, xdr_void,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *) &res);
}


void   *
nlm_unlock_msg_1(struct nlm_unlockargs *argp, CLIENT *clnt)
{
	static char res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_UNLOCK_MSG, xdr_nlm_unlockargs, argp, xdr_void,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *) &res);
}


void   *
nlm_granted_msg_1(struct nlm_testargs *argp, CLIENT *clnt)
{
	static char res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_GRANTED_MSG, xdr_nlm_testargs, argp, xdr_void,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *) &res);
}


void   *
nlm_test_res_1(nlm_testres *argp, CLIENT *clnt)
{
	static char res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_TEST_RES, xdr_nlm_testres, argp, xdr_void,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *) &res);
}


void   *
nlm_lock_res_1(nlm_res *argp, CLIENT *clnt)
{
	static char res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_LOCK_RES, xdr_nlm_res, argp, xdr_void,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *) &res);
}


void   *
nlm_cancel_res_1(nlm_res *argp, CLIENT *clnt)
{
	static char res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_CANCEL_RES, xdr_nlm_res, argp, xdr_void,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *) &res);
}


void   *
nlm_unlock_res_1(nlm_res *argp, CLIENT *clnt)
{
	static char res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_UNLOCK_RES, xdr_nlm_res, argp, xdr_void,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *) &res);
}


void   *
nlm_granted_res_1(nlm_res *argp, CLIENT *clnt)
{
	static char res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_GRANTED_RES, xdr_nlm_res, argp, xdr_void,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *) &res);
}


nlm_shareres *
nlm_share_3(nlm_shareargs *argp, CLIENT *clnt)
{
	static nlm_shareres res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_SHARE, xdr_nlm_shareargs, argp, xdr_nlm_shareres,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
}


nlm_shareres *
nlm_unshare_3(nlm_shareargs *argp, CLIENT *clnt)
{
	static nlm_shareres res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_UNSHARE, xdr_nlm_shareargs, argp, xdr_nlm_shareres,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
}


nlm_res *
nlm_nm_lock_3(nlm_lockargs *argp, CLIENT *clnt)
{
	static nlm_res res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_NM_LOCK, xdr_nlm_lockargs, argp, xdr_nlm_res,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&res);
}


void   *
nlm_free_all_3(nlm_notify *argp, CLIENT *clnt)
{
	static char res;

	bzero((char *) &res, sizeof(res));
	if (clnt_call(clnt, NLM_FREE_ALL, xdr_nlm_notify, argp, xdr_void,
	    &res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *) &res);
}


int 
main(int argc, char **argv)
{
	CLIENT *cli;
	nlm_res res_block;
	nlm_res *out;
	nlm_lockargs arg;
	struct timeval tim;

	printf("Creating client for host %s\n", argv[1]);
	cli = clnt_create(argv[1], NLM_PROG, NLM_VERS, "udp");
	if (!cli) {
		printf("Failed to create client\n");
		exit(1);
	}
	clnt_control(cli, CLGET_TIMEOUT, &tim);
	printf("Default timeout was %lld.%ld\n", (long long)tim.tv_sec,
	    tim.tv_usec);
	tim.tv_usec = -1;
	tim.tv_sec = -1;
	clnt_control(cli, CLSET_TIMEOUT, &tim);
	clnt_control(cli, CLGET_TIMEOUT, &tim);
	printf("timeout now %lld.%ld\n", (long long)tim.tv_sec,
	    tim.tv_usec);

	arg.cookie.n_len = 4;
	arg.cookie.n_bytes = "hello";
	arg.block = 0;
	arg.exclusive = 0;
	arg.reclaim = 0;
	arg.state = 0x1234;
	arg.alock.caller_name = "localhost";
	arg.alock.fh.n_len = 32;
	arg.alock.fh.n_bytes = "\x04\x04\x02\x00\x01\x00\x00\x00\x0c\x00\x00\x00\xff\xff\xff\xd0\x16\x00\x00\x5b\x7c\xff\xff\xff\xec\x2f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x19\x54\xef\xbf\xd7\x94";
	arg.alock.oh.n_len = 8;
	arg.alock.oh.n_bytes = "\x00\x00\x02\xff\xff\xff\xd3";
	arg.alock.svid = 0x5678;
	arg.alock.l_offset = 0;
	arg.alock.l_len = 100;

	res_block.stat.stat = nlm_granted;
	res_block.cookie.n_bytes = "hello";
	res_block.cookie.n_len = 5;

#if 0
	if (nlm_lock_res_1(&res_block, cli))
		printf("Success!\n");
	else
		printf("Fail\n");
#else
	if (out = nlm_lock_msg_1(&arg, cli)) {
		printf("Success!\n");
		printf("out->stat = %d", out->stat);
	} else {
		printf("Fail\n");
	}
#endif

	return 0;
}
@


1.6
log
@print tv_sec properly
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.5 2009/10/27 23:59:54 deraadt Exp $	*/
d30 2
a31 2
	if (st = clnt_call(clnt, NLM_LOCK, xdr_nlm_lockargs, argp, xdr_nlm_res,
	    &res, TIMEOUT) != RPC_SUCCESS) {
@


1.5
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.4 2003/07/06 21:26:14 deraadt Exp $	*/
d294 2
a295 1
	printf("Default timeout was %d.%d\n", tim.tv_sec, tim.tv_usec);
d300 2
a301 2
	printf("timeout now %d.%d\n", tim.tv_sec, tim.tv_usec);

@


1.4
log
@protos and ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.3 1997/09/17 23:09:39 deraadt Exp $	*/
a4 5
#ifndef lint
/*static char sccsid[] = "from: @@(#)nlm_prot.x 1.8 87/09/21 Copyr 1987 Sun Micro";*/
/*static char sccsid[] = "from: * @@(#)nlm_prot.x	2.1 88/08/01 4.0 RPCSRC";*/
static char rcsid[] = "nlm_prot.x,v 1.1 1994/08/04 19:01:48 wollman Exp";
#endif				/* not lint */
@


1.3
log
@make this readable, so that i can think about actually coding it..
@
text
@d1 1
a1 1
/*	$OpenBSD: test.c,v 1.2 1997/08/10 21:06:41 millert Exp $	*/
d15 1
a15 3
nlm_test_1(argp, clnt)
	struct nlm_testargs *argp;
	CLIENT *clnt;
d20 2
a21 1
	if (clnt_call(clnt, NLM_TEST, xdr_nlm_testargs, argp, xdr_nlm_testres, &res, TIMEOUT) != RPC_SUCCESS) {
d29 1
a29 3
nlm_lock_1(argp, clnt)
	struct nlm_lockargs *argp;
	CLIENT *clnt;
d35 2
a36 1
	if (st = clnt_call(clnt, NLM_LOCK, xdr_nlm_lockargs, argp, xdr_nlm_res, &res, TIMEOUT) != RPC_SUCCESS) {
d46 1
a46 3
nlm_cancel_1(argp, clnt)
	struct nlm_cancargs *argp;
	CLIENT *clnt;
d51 2
a52 1
	if (clnt_call(clnt, NLM_CANCEL, xdr_nlm_cancargs, argp, xdr_nlm_res, &res, TIMEOUT) != RPC_SUCCESS) {
d60 1
a60 3
nlm_unlock_1(argp, clnt)
	struct nlm_unlockargs *argp;
	CLIENT *clnt;
d65 2
a66 1
	if (clnt_call(clnt, NLM_UNLOCK, xdr_nlm_unlockargs, argp, xdr_nlm_res, &res, TIMEOUT) != RPC_SUCCESS) {
d74 1
a74 3
nlm_granted_1(argp, clnt)
	struct nlm_testargs *argp;
	CLIENT *clnt;
d79 2
a80 1
	if (clnt_call(clnt, NLM_GRANTED, xdr_nlm_testargs, argp, xdr_nlm_res, &res, TIMEOUT) != RPC_SUCCESS) {
d88 1
a88 3
nlm_test_msg_1(argp, clnt)
	struct nlm_testargs *argp;
	CLIENT *clnt;
d93 2
a94 1
	if (clnt_call(clnt, NLM_TEST_MSG, xdr_nlm_testargs, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
d102 1
a102 3
nlm_lock_msg_1(argp, clnt)
	struct nlm_lockargs *argp;
	CLIENT *clnt;
d116 1
a116 3
nlm_cancel_msg_1(argp, clnt)
	struct nlm_cancargs *argp;
	CLIENT *clnt;
d121 2
a122 1
	if (clnt_call(clnt, NLM_CANCEL_MSG, xdr_nlm_cancargs, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
d130 1
a130 3
nlm_unlock_msg_1(argp, clnt)
	struct nlm_unlockargs *argp;
	CLIENT *clnt;
d135 2
a136 1
	if (clnt_call(clnt, NLM_UNLOCK_MSG, xdr_nlm_unlockargs, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
d144 1
a144 3
nlm_granted_msg_1(argp, clnt)
	struct nlm_testargs *argp;
	CLIENT *clnt;
d149 2
a150 1
	if (clnt_call(clnt, NLM_GRANTED_MSG, xdr_nlm_testargs, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
d158 1
a158 3
nlm_test_res_1(argp, clnt)
	nlm_testres *argp;
	CLIENT *clnt;
d163 2
a164 1
	if (clnt_call(clnt, NLM_TEST_RES, xdr_nlm_testres, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
d172 1
a172 3
nlm_lock_res_1(argp, clnt)
	nlm_res *argp;
	CLIENT *clnt;
d177 2
a178 1
	if (clnt_call(clnt, NLM_LOCK_RES, xdr_nlm_res, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
d186 1
a186 3
nlm_cancel_res_1(argp, clnt)
	nlm_res *argp;
	CLIENT *clnt;
d191 2
a192 1
	if (clnt_call(clnt, NLM_CANCEL_RES, xdr_nlm_res, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
d200 1
a200 3
nlm_unlock_res_1(argp, clnt)
	nlm_res *argp;
	CLIENT *clnt;
d205 2
a206 1
	if (clnt_call(clnt, NLM_UNLOCK_RES, xdr_nlm_res, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
d214 1
a214 3
nlm_granted_res_1(argp, clnt)
	nlm_res *argp;
	CLIENT *clnt;
d219 2
a220 1
	if (clnt_call(clnt, NLM_GRANTED_RES, xdr_nlm_res, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
d228 1
a228 3
nlm_share_3(argp, clnt)
	nlm_shareargs *argp;
	CLIENT *clnt;
d233 2
a234 1
	if (clnt_call(clnt, NLM_SHARE, xdr_nlm_shareargs, argp, xdr_nlm_shareres, &res, TIMEOUT) != RPC_SUCCESS) {
d242 1
a242 3
nlm_unshare_3(argp, clnt)
	nlm_shareargs *argp;
	CLIENT *clnt;
d247 2
a248 1
	if (clnt_call(clnt, NLM_UNSHARE, xdr_nlm_shareargs, argp, xdr_nlm_shareres, &res, TIMEOUT) != RPC_SUCCESS) {
d256 1
a256 3
nlm_nm_lock_3(argp, clnt)
	nlm_lockargs *argp;
	CLIENT *clnt;
d261 2
a262 1
	if (clnt_call(clnt, NLM_NM_LOCK, xdr_nlm_lockargs, argp, xdr_nlm_res, &res, TIMEOUT) != RPC_SUCCESS) {
d270 1
a270 3
nlm_free_all_3(argp, clnt)
	nlm_notify *argp;
	CLIENT *clnt;
d275 2
a276 1
	if (clnt_call(clnt, NLM_FREE_ALL, xdr_nlm_notify, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
@


1.2
log
@Pass -Wall and add OpenBSD tags.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d9 1
a9 1
#endif /* not lint */
d12 1
a12 1
static struct timeval TIMEOUT = { 0, 0 };
d21 1
a21 1
	bzero((char *)&res, sizeof(res));
d37 1
a37 1
	bzero((char *)&res, sizeof(res));
d54 1
a54 1
	bzero((char *)&res, sizeof(res));
d69 1
a69 1
	bzero((char *)&res, sizeof(res));
d84 1
a84 1
	bzero((char *)&res, sizeof(res));
d92 1
a92 1
void *
d99 1
a99 1
	bzero((char *)&res, sizeof(res));
d103 1
a103 1
	return ((void *)&res);
d107 1
a107 1
void *
d114 1
a114 1
	bzero((char *)&res, sizeof(res));
d119 1
a119 1
	return ((void *)&res);
d123 1
a123 1
void *
d130 1
a130 1
	bzero((char *)&res, sizeof(res));
d134 1
a134 1
	return ((void *)&res);
d138 1
a138 1
void *
d145 1
a145 1
	bzero((char *)&res, sizeof(res));
d149 1
a149 1
	return ((void *)&res);
d153 1
a153 1
void *
d160 1
a160 1
	bzero((char *)&res, sizeof(res));
d164 1
a164 1
	return ((void *)&res);
d168 1
a168 1
void *
d175 1
a175 1
	bzero((char *)&res, sizeof(res));
d179 1
a179 1
	return ((void *)&res);
d183 1
a183 1
void *
d190 1
a190 1
	bzero((char *)&res, sizeof(res));
d194 1
a194 1
	return ((void *)&res);
d198 1
a198 1
void *
d205 1
a205 1
	bzero((char *)&res, sizeof(res));
d209 1
a209 1
	return ((void *)&res);
d213 1
a213 1
void *
d220 1
a220 1
	bzero((char *)&res, sizeof(res));
d224 1
a224 1
	return ((void *)&res);
d228 1
a228 1
void *
d235 1
a235 1
	bzero((char *)&res, sizeof(res));
d239 1
a239 1
	return ((void *)&res);
d250 1
a250 1
	bzero((char *)&res, sizeof(res));
d265 1
a265 1
	bzero((char *)&res, sizeof(res));
d280 1
a280 1
	bzero((char *)&res, sizeof(res));
d288 1
a288 1
void *
d295 1
a295 1
	bzero((char *)&res, sizeof(res));
d299 1
a299 1
	return ((void *)&res);
d303 2
a304 1
int main(int argc, char **argv)
d306 39
a344 42
  CLIENT *cli;
  nlm_res res_block;
  nlm_res *out;
  nlm_lockargs arg;
  struct timeval tim;

  printf("Creating client for host %s\n", argv[1]);
  cli = clnt_create(argv[1], NLM_PROG, NLM_VERS, "udp");
  if (!cli)
  {
    printf("Failed to create client\n");
    exit(1);
  }


  clnt_control(cli, CLGET_TIMEOUT, &tim);
  printf("Default timeout was %d.%d\n", tim.tv_sec, tim.tv_usec);
  tim.tv_usec = -1;
  tim.tv_sec = -1;
  clnt_control(cli, CLSET_TIMEOUT, &tim);
  clnt_control(cli, CLGET_TIMEOUT, &tim);
  printf("timeout now %d.%d\n", tim.tv_sec, tim.tv_usec);
 

  arg.cookie.n_len = 4;
  arg.cookie.n_bytes = "hello";
  arg.block = 0;
  arg.exclusive = 0;
  arg.reclaim = 0;
  arg.state = 0x1234;
  arg.alock.caller_name = "localhost";
  arg.alock.fh.n_len = 32;
  arg.alock.fh.n_bytes = "\x04\x04\x02\x00\x01\x00\x00\x00\x0c\x00\x00\x00\xff\xff\xff\xd0\x16\x00\x00\x5b\x7c\xff\xff\xff\xec\x2f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x19\x54\xef\xbf\xd7\x94";
  arg.alock.oh.n_len = 8;
  arg.alock.oh.n_bytes = "\x00\x00\x02\xff\xff\xff\xd3";
  arg.alock.svid = 0x5678;
  arg.alock.l_offset = 0;
  arg.alock.l_len = 100;

  res_block.stat.stat = nlm_granted;
  res_block.cookie.n_bytes = "hello";
  res_block.cookie.n_len = 5;
d347 4
a350 2
  if (nlm_lock_res_1(&res_block, cli)) printf("Success!\n");
  else printf("Fail\n");  
d352 6
a357 9
  if (out = nlm_lock_msg_1(&arg, cli))
  {
    printf("Success!\n");
    printf("out->stat = %d", out->stat);
  }
  else
  {
    printf("Fail\n");  
  }
d360 1
a360 1
  return 0;
@


1.1
log
@rpc.lockd from freebsd; has a problem yet
@
text
@d1 2
@
