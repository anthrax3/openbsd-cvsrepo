head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.8
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.6
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.22
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.20
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.8
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.4
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.7.0.20
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.18
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.16
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.18
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.16
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.14
date	2015.04.18.18.28.38;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	6b2lLILbgCR1fvia;

1.13
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	Uu5nFG3wCl0LACBb;

1.12
date	2009.11.15.09.07.56;	author chl;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.15.04.48.03;	author sturm;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.13.23.56.28;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.13.21.32.26;	author sturm;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.17.23.31.52;	author sobrado;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.06.21.26.14;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.11.23.33.29;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.28.08;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.09.17.23.09.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.08.10.21.06.40;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.07.20.05.03.44;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.07.20.05.02.35;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@/*	$OpenBSD: lockd.c,v 1.13 2015/01/16 06:40:20 deraadt Exp $	*/

/*
 * Copyright (c) 1995
 *	A.R. Gordon (andrew.gordon@@net-tel.co.uk).  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the FreeBSD project
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ANDREW GORDON AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/socket.h>
#include <netinet/in.h>
#include <rpc/rpc.h>
#include <rpc/pmap_clnt.h>
#include <rpcsvc/sm_inter.h>
#include "nlm_prot.h"
#include <arpa/inet.h>
#include <stdio.h>
#include <syslog.h>
#include <stdlib.h>
#include <err.h>
#include <errno.h>
#include <signal.h>
#include <limits.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>

#include "lockd.h"

int debug_level = 0;	/* 0 = no debugging syslog() calls */
int _rpcsvcdirty = 0;
int grace_expired;

void nlm_prog_0(struct svc_req *, SVCXPRT *);
void nlm_prog_1(struct svc_req *, SVCXPRT *);
void nlm_prog_3(struct svc_req *, SVCXPRT *);
void nlm_prog_4(struct svc_req *, SVCXPRT *);

static void sigalarm_handler(int);
static void usage(void);

int
main(int argc, char *argv[])
{
	SVCXPRT *transp;
	const char *errstr;
	int ch;
	struct sigaction sigchild, sigalarm;
	int grace_period = 30;

	while ((ch = getopt(argc, argv, "d:g:")) != (-1)) {
		switch (ch) {
		case 'd':
			debug_level = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr) {
				usage();
				/* NOTREACHED */
			}
			break;
		case 'g':
			grace_period = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr) {
				usage();
				/* NOTREACHED */
			}
			break;
		default:
		case '?':
			usage();
			/* NOTREACHED */
		}
	}

	(void) pmap_unset(NLM_PROG, NLM_SM);
	(void) pmap_unset(NLM_PROG, NLM_VERS);
	(void) pmap_unset(NLM_PROG, NLM_VERSX);
	(void) pmap_unset(NLM_PROG, NLM_VERS4);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf(stderr, "cannot create udp service.\n");
		exit(1);
	}
	if (!svc_register(transp, NLM_PROG, NLM_SM,
	    (void (*) (struct svc_req *, SVCXPRT *)) nlm_prog_0, IPPROTO_UDP)) {
		fprintf(stderr, "unable to register (NLM_PROG, NLM_SM, udp).\n");
		exit(1);
	}
	if (!svc_register(transp, NLM_PROG, NLM_VERS,
	    (void (*) (struct svc_req *, SVCXPRT *)) nlm_prog_1, IPPROTO_UDP)) {
		fprintf(stderr, "unable to register (NLM_PROG, NLM_VERS, udp).\n");
		exit(1);
	}
	if (!svc_register(transp, NLM_PROG, NLM_VERSX,
	    (void (*) (struct svc_req *, SVCXPRT *)) nlm_prog_3, IPPROTO_UDP)) {
		fprintf(stderr, "unable to register (NLM_PROG, NLM_VERSX, udp).\n");
		exit(1);
	}
	if (!svc_register(transp, NLM_PROG, NLM_VERS4,
	    (void (*) (struct svc_req *, SVCXPRT *)) nlm_prog_4, IPPROTO_UDP)) {
		fprintf(stderr, "unable to register (NLM_PROG, NLM_VERS4, udp).\n");
		exit(1);
	}
	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf(stderr, "cannot create tcp service.\n");
		exit(1);
	}
	if (!svc_register(transp, NLM_PROG, NLM_VERS,
	    (void (*) (struct svc_req *, SVCXPRT *)) nlm_prog_1, IPPROTO_TCP)) {
		fprintf(stderr, "unable to register (NLM_PROG, NLM_VERS, tcp).\n");
		exit(1);
	}
	if (!svc_register(transp, NLM_PROG, NLM_VERSX,
	    (void (*) (struct svc_req *, SVCXPRT *)) nlm_prog_3, IPPROTO_TCP)) {
		fprintf(stderr, "unable to register (NLM_PROG, NLM_VERSX, tcp).\n");
		exit(1);
	}
	if (!svc_register(transp, NLM_PROG, NLM_VERS4,
	    (void (*) (struct svc_req *, SVCXPRT *)) nlm_prog_4, IPPROTO_TCP)) {
		fprintf(stderr, "unable to register (NLM_PROG, NLM_VERS4, tcp).\n");
		exit(1);
	}

	/*
	 * Note that it is NOT sensible to run this program from inetd - the
	 * protocol assumes that it will run immediately at boot time.
	 */
	if (daemon(0, 0) == -1) {
		err(1, "cannot fork");
		/* NOTREACHED */
	}

	openlog("rpc.lockd", 0, LOG_DAEMON);
	if (debug_level)
		syslog(LOG_INFO, "Starting, debug level %d", debug_level);
	else
		syslog(LOG_INFO, "Starting");

	sigchild.sa_handler = sigchild_handler;
	sigemptyset(&sigchild.sa_mask);
	sigchild.sa_flags = SA_RESTART;
	if (sigaction(SIGCHLD, &sigchild, NULL) != 0) {
		syslog(LOG_WARNING, "sigaction(SIGCHLD) failed (%m)");
		exit(1);
	}
	sigalarm.sa_handler = sigalarm_handler;
	sigemptyset(&sigalarm.sa_mask);
	sigalarm.sa_flags = SA_RESETHAND; /* should only happen once */
	sigalarm.sa_flags |= SA_RESTART;
	if (sigaction(SIGALRM, &sigalarm, NULL) != 0) {
		syslog(LOG_WARNING, "sigaction(SIGALRM) failed (%m)");
		exit(1);
	}
	grace_expired = 0;
	if (alarm(10) == (unsigned int)-1) {
		syslog(LOG_WARNING, "alarm failed (%m)");
		exit(1);
	}

	svc_run();		/* Should never return */
	return 1;
}

static void
/*ARGSUSED*/
sigalarm_handler(int s)
{
	grace_expired = 1;
}

static void
usage()
{
	errx(1, "usage: rpc.lockd [-d [debug_level]] [-g grace_period]");
}
@


1.13
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: lockd.c,v 1.12 2009/11/15 09:07:56 chl Exp $	*/
d49 1
d72 1
d80 2
a81 2
			debug_level = atoi(optarg);
			if (!debug_level) {
d87 2
a88 2
			grace_period = atoi(optarg);
			if (!grace_period) {
@


1.12
log
@add missing headers needed by err/errx(), alarm(), sigemptyset(), sigaction().

"go ahead" sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lockd.c,v 1.11 2008/06/15 04:48:03 sturm Exp $	*/
a35 1
#include <sys/param.h>
@


1.11
log
@add glue for rpc.lockd to talk to rpc.statd

"just get it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: lockd.c,v 1.10 2008/06/13 23:56:28 jmc Exp $	*/
d47 1
d49 1
d51 1
@


1.10
log
@tweak previous;
@
text
@d1 1
a1 1
/*	$OpenBSD: lockd.c,v 1.9 2008/06/13 21:32:26 sturm Exp $	*/
d57 1
d95 2
d104 5
@


1.9
log
@from NetBSD:
Implement file locking in lockd. All the stuff is done in userland, using
fhopen() and flock(). This means that if you kill lockd, all locks will
be relased.
Shared locks are not handled efficiently, they're serialised in lockd when
they could be granted.

tested against debian etch (linux 2.6.18)
not fully functional yet in mixed NFSv2/v3 environments
further development in-tree as discussed w/ deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: lockd.c,v 1.8 2008/05/17 23:31:52 sobrado Exp $	*/
d189 1
a189 1
	errx(1, "usage: rpc.lockd [-d <debuglevel>] [-g <grace period>]");
@


1.8
log
@documentation tweaks.

ok (some time ago) jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lockd.c,v 1.7 2003/07/06 21:26:14 deraadt Exp $	*/
d47 1
d53 7
a59 2
extern void nlm_prog_1(struct svc_req *, SVCXPRT *);
extern void nlm_prog_3(struct svc_req *, SVCXPRT *);
d61 2
a62 3
int     debug_level = 0;	/* Zero means no debugging syslog() calls	 */

int     _rpcsvcdirty;
d68 24
a91 6

	if (argc > 1) {
		if (strncmp(argv[1], "-d", 2)) {
			fprintf(stderr,
			    "usage: rpc.lockd [-d [debug_level]]\n");
			exit(1);
a92 6
		if (argc > 2)
			debug_level = atoi(argv[2]);
		else
			debug_level = atoi(argv[1] + 2);
		if (!debug_level)
			debug_level = 1;
d96 1
d113 5
d133 5
d139 7
a145 3
	if (daemon(0, 0)) {
		perror("cannot fork");
		exit(1);
d147 1
d154 36
a189 2
	svc_run();
	exit(1);
@


1.7
log
@protos and ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: lockd.c,v 1.6 2003/06/11 23:33:29 deraadt Exp $	*/
d66 2
a67 1
			fprintf(stderr, "Usage: rpc.lockd [-d debuglevel]\n");
@


1.6
log
@some ansification, some de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: lockd.c,v 1.5 2002/02/16 21:28:08 millert Exp $	*/
d52 2
a53 2
extern void nlm_prog_1(struct svc_req, SVCXPRT);
extern void nlm_prog_3(struct svc_req, SVCXPRT);
d60 1
a60 3
main(argc, argv)
	int     argc;
	char  **argv;
d85 1
a85 1
	    (void (*) ()) nlm_prog_1, IPPROTO_UDP)) {
d90 1
a90 1
	    (void (*) ()) nlm_prog_3, IPPROTO_UDP)) {
d100 1
a100 1
	    (void (*) ()) nlm_prog_1, IPPROTO_TCP)) {
d105 1
a105 1
	    (void (*) ()) nlm_prog_3, IPPROTO_TCP)) {
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: lockd.c,v 1.4 1997/09/17 23:09:36 deraadt Exp $	*/
d52 2
a53 2
extern void nlm_prog_1(struct svc_req, register SVCXPRT);
extern void nlm_prog_3(struct svc_req, register SVCXPRT);
@


1.4
log
@make this readable, so that i can think about actually coding it..
@
text
@d1 1
a1 1
/*	$OpenBSD: lockd.c,v 1.3 1997/08/10 21:06:40 millert Exp $	*/
d52 2
a53 2
extern void nlm_prog_1 __P((struct svc_req, register SVCXPRT));
extern void nlm_prog_3 __P((struct svc_req, register SVCXPRT));
@


1.3
log
@Pass -Wall and add OpenBSD tags.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 13
a48 4

/* main() function for NFS lock daemon.  Most of the code in this	*/
/* file was generated by running rpcgen /usr/include/rpcsvc/nlm_prot.x	*/
/* The actual program logic is in the file procs.c			*/
d55 1
a55 1
int debug_level = 0;	/* Zero means no debugging syslog() calls	*/
d57 1
a57 3
#if 1
int _rpcsvcdirty;
#endif
d61 2
a62 2
  int argc;
  char **argv;
d64 1
a64 1
  SVCXPRT *transp;
d66 55
a120 59
  if (argc > 1)
  {
    if (strncmp(argv[1], "-d", 2))
    {
      fprintf(stderr, "Usage: rpc.lockd [-d [<debuglevel>]]\n");
      exit(1);
    }
    if (argc > 2) debug_level = atoi(argv[2]);
    else debug_level = atoi(argv[1] + 2);
    /* Ensure at least some debug if -d with no specified level		*/
    if (!debug_level) debug_level = 1;
  }

  (void)pmap_unset(NLM_PROG, NLM_VERS);
  (void)pmap_unset(NLM_PROG, NLM_VERSX);

  transp = svcudp_create(RPC_ANYSOCK);
  if (transp == NULL)
  {
    (void)fprintf(stderr, "cannot create udp service.\n");
    exit(1);
  }
  if (!svc_register(transp, NLM_PROG, NLM_VERS, (void (*)())nlm_prog_1, IPPROTO_UDP))
  {
    (void)fprintf(stderr, "unable to register (NLM_PROG, NLM_VERS, udp).\n");
    exit(1);
  }
  if (!svc_register(transp, NLM_PROG, NLM_VERSX, (void (*)())nlm_prog_3, IPPROTO_UDP))
  {
    (void)fprintf(stderr, "unable to register (NLM_PROG, NLM_VERSX, udp).\n");
    exit(1);
  }

  transp = svctcp_create(RPC_ANYSOCK, 0, 0);
  if (transp == NULL)
  {
    (void)fprintf(stderr, "cannot create tcp service.\n");
    exit(1);
  }
  if (!svc_register(transp, NLM_PROG, NLM_VERS, (void (*)())nlm_prog_1, IPPROTO_TCP))
  {
    (void)fprintf(stderr, "unable to register (NLM_PROG, NLM_VERS, tcp).\n");
    exit(1);
  }
  if (!svc_register(transp, NLM_PROG, NLM_VERSX, (void (*)())nlm_prog_3, IPPROTO_TCP))
  {
    (void)fprintf(stderr, "unable to register (NLM_PROG, NLM_VERSX, tcp).\n");
    exit(1);
  }

  /* Note that it is NOT sensible to run this program from inetd - the 	*/
  /* protocol assumes that it will run immediately at boot time.	*/
  if (daemon(0,0)) {
    perror("cannot fork");
    exit(1);
  }
  openlog("rpc.lockd", 0, LOG_DAEMON);
  if (debug_level) syslog(LOG_INFO, "Starting, debug level %d", debug_level);
  else syslog(LOG_INFO, "Starting");
d122 2
a123 2
  svc_run();	/* Should never return					*/
  exit(1);
@


1.2
log
@compiles...
@
text
@d1 2
d52 4
a55 1
main(int argc, char **argv)
@


1.1
log
@rpc.lockd from freebsd; has a problem yet
@
text
@d46 3
@
