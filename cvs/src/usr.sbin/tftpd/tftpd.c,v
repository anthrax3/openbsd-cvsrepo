head	1.39;
access;
symbols
	OPENBSD_6_2:1.39.0.4
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.38.0.4
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.36.0.2
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8;
locks; strict;
comment	@ * @;


1.39
date	2017.05.26.17.38.46;	author florian;	state Exp;
branches;
next	1.38;
commitid	N0RkgiLeoGfW3Ylk;

1.38
date	2016.09.26.17.15.19;	author jca;	state Exp;
branches;
next	1.37;
commitid	cejVwQpY7FYSCLBx;

1.37
date	2016.09.04.14.41.49;	author florian;	state Exp;
branches;
next	1.36;
commitid	wInPE9HdxE47uT73;

1.36
date	2016.03.31.23.03.26;	author jca;	state Exp;
branches;
next	1.35;
commitid	dG2fo6mZWL3OAKZU;

1.35
date	2016.03.31.23.00.46;	author jca;	state Exp;
branches;
next	1.34;
commitid	1ZsuouG0dkA8ch53;

1.34
date	2015.12.14.16.34.55;	author semarie;	state Exp;
branches;
next	1.33;
commitid	y1sF4ogSQ4groIog;

1.33
date	2015.12.11.20.11.10;	author mmcc;	state Exp;
branches;
next	1.32;
commitid	eJ3p8PcnrnKHB6fs;

1.32
date	2015.10.18.03.54.22;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	rQB89Wup6ZhbwGpK;

1.31
date	2015.10.10.22.21.39;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	IgColQYeds5H84MV;

1.30
date	2015.10.06.06.03.11;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	LlI9LMLv3FgqiWkv;

1.29
date	2015.08.20.11.28.15;	author dlg;	state Exp;
branches;
next	1.28;
commitid	sxOsp2U3L2C4zGCI;

1.28
date	2015.07.20.04.28.03;	author dlg;	state Exp;
branches;
next	1.27;
commitid	X0dZSP2V35SYu4g2;

1.27
date	2015.07.18.05.32.56;	author mcbride;	state Exp;
branches;
next	1.26;
commitid	IHFyFilyaKpyproR;

1.26
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	Uu5nFG3wCl0LACBb;

1.25
date	2014.12.17.22.23.33;	author tedu;	state Exp;
branches;
next	1.24;
commitid	h2R8RbHIi8M2t7vH;

1.24
date	2014.11.25.23.52.09;	author dlg;	state Exp;
branches;
next	1.23;
commitid	2F0R8samZFzo0WyU;

1.23
date	2014.11.19.11.48.39;	author dlg;	state Exp;
branches;
next	1.22;
commitid	pwQhWkzcPOlH1cOm;

1.22
date	2014.08.13.17.41.58;	author tobias;	state Exp;
branches;
next	1.21;
commitid	p27SKtMCYw3foi8T;

1.21
date	2014.08.13.01.03.56;	author dlg;	state Exp;
branches;
next	1.20;
commitid	lPhHl4Oc86rL4cLO;

1.20
date	2014.08.13.01.00.16;	author dlg;	state Exp;
branches;
next	1.19;
commitid	Qr5ZpMMItP9MPEP7;

1.19
date	2014.04.21.04.02.52;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2013.11.26.21.47.16;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2013.11.12.22.27.13;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2013.08.13.12.39.02;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2013.06.01.21.06.39;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2013.05.07.00.26.34;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.17.09.48.36;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.15.13.13.10;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.15.12.52.03;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.15.12.36.11;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.15.12.20.11;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2012.07.13.02.31.46;	author gsoares;	state Exp;
branches
	1.8.2.1
	1.8.4.1;
next	1.7;

1.7
date	2012.07.10.07.25.37;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2012.07.10.07.21.34;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2012.03.15.07.18.35;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2012.03.07.22.24.01;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2012.03.02.16.39.22;	author jmc;	state Exp;
branches;
next	1.2;

1.2
date	2012.03.02.04.51.21;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2012.03.02.04.43.13;	author dlg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2012.03.02.04.43.13;	author dlg;	state Exp;
branches;
next	;

1.8.2.1
date	2013.03.21.05.20.32;	author dlg;	state Exp;
branches;
next	;

1.8.4.1
date	2013.06.12.10.34.18;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Sync the severity of the syslog_* functions shared between identd, slowcgi,
tftp-proxy and tftpd to the severity used in log.c style loggers.
This also fixes an issue where syslog_err and syslog_errx logged with
different severities.

Sure deraadt@@
@
text
@/*	$OpenBSD: tftpd.c,v 1.38 2016/09/26 17:15:19 jca Exp $	*/

/*
 * Copyright (c) 2012 David Gwynne <dlg@@uq.edu.au>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Trivial file transfer protocol server.
 *
 * This version is based on src/libexec/tftpd which includes many
 * modifications by Jim Guyton <guyton@@rand-unix>.
 *
 * It was restructured to be a persistent event driven daemon
 * supporting concurrent connections by dlg for use at the University
 * of Queensland in the Faculty of Engineering Architecture and
 * Information Technology.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <sys/un.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/tftp.h>
#include <netdb.h>

#include <err.h>
#include <ctype.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <paths.h>
#include <poll.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <syslog.h>
#include <unistd.h>
#include <limits.h>
#include <vis.h>

#define TIMEOUT		5		/* packet rexmt timeout */
#define TIMEOUT_MIN	1		/* minimal packet rexmt timeout */
#define TIMEOUT_MAX	255		/* maximal packet rexmt timeout */

#define RETRIES		5

#define SEEDPATH	"/etc/random.seed"

struct formats;

enum opt_enum {
	OPT_TSIZE = 0,
	OPT_TIMEOUT,
	OPT_BLKSIZE,
	NOPT
};

static char *opt_names[] = {
	"tsize",
	"timeout",
	"blksize"
};

struct opt_client {
	char *o_request;
	long long o_reply;
};


struct tftp_server {
	struct event ev;
	TAILQ_ENTRY(tftp_server) entry;
	int s;
};

TAILQ_HEAD(, tftp_server) tftp_servers;

struct tftp_client {
	char buf[SEGSIZE_MAX + 4];
	struct event sev;
	struct sockaddr_storage ss;

	struct timeval tv;

	TAILQ_ENTRY(tftp_client) entry;

	struct opt_client *options;

	size_t segment_size;
	size_t packet_size;
	size_t buflen;

	FILE *file;
	int (*fgetc)(struct tftp_client *);
	int (*fputc)(struct tftp_client *, int);

	u_int retries;
	u_int16_t block;

	int opcode;
	int newline;

	int sock;
};

__dead void	usage(void);
const char	*getip(void *);
int		rdaemon(int);

void		rewrite_connect(const char *);
void		rewrite_events(void);
void		rewrite_map(struct tftp_client *, const char *);
void		rewrite_req(int, short, void *);
void		rewrite_res(int, short, void *);

int		tftpd_listen(const char *, const char *, int);
void		tftpd_events(void);
void		tftpd_recv(int, short, void *);
int		retry(struct tftp_client *);
int		tftp_flush(struct tftp_client *);
void		tftp_end(struct tftp_client *);

void		tftp(struct tftp_client *, struct tftphdr *, size_t);
void		tftp_open(struct tftp_client *, const char *);
void		nak(struct tftp_client *, int);
int		oack(struct tftp_client *);
void		oack_done(int, short, void *);

void		sendfile(struct tftp_client *);
void		recvfile(struct tftp_client *);
int		fget_octet(struct tftp_client *);
int		fput_octet(struct tftp_client *, int);
int		fget_netascii(struct tftp_client *);
int		fput_netascii(struct tftp_client *, int);
void		file_read(struct tftp_client *);
int		tftp_wrq_ack_packet(struct tftp_client *);
void		tftp_rrq_ack(int, short, void *);
void		tftp_wrq_ack(struct tftp_client *client);
void		tftp_wrq(int, short, void *);
void		tftp_wrq_end(int, short, void *);

int		parse_options(struct tftp_client *, char *, size_t,
		    struct opt_client *);
int		validate_access(struct tftp_client *, const char *);

struct tftp_client *
		client_alloc(void);
void		client_free(struct tftp_client *client);

struct formats {
	const char	*f_mode;
	int (*f_getc)(struct tftp_client *);
	int (*f_putc)(struct tftp_client *, int);
} formats[] = {
	{ "octet",	fget_octet,	fput_octet },
	{ "netascii",	fget_netascii,	fput_netascii },
	{ NULL,		NULL }
};

struct errmsg {
	int		 e_code;
	const char	*e_msg;
} errmsgs[] = {
	{ EUNDEF,	"Undefined error code" },
	{ ENOTFOUND,	"File not found" },
	{ EACCESS,	"Access violation" },
	{ ENOSPACE,	"Disk full or allocation exceeded" },
	{ EBADOP,	"Illegal TFTP operation" },
	{ EBADID,	"Unknown transfer ID" },
	{ EEXISTS,	"File already exists" },
	{ ENOUSER,	"No such user" },
	{ EOPTNEG,	"Option negotiation failed" },
	{ -1,		NULL }
};

struct loggers {
	__dead void (*err)(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
	__dead void (*errx)(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
	void (*warn)(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
	void (*warnx)(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
	void (*info)(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
	void (*debug)(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
};

const struct loggers conslogger = {
	err,
	errx,
	warn,
	warnx,
	warnx, /* info */
	warnx /* debug */
};

__dead void	syslog_err(int, const char *, ...)
		    __attribute__((__format__ (printf, 2, 3)));
__dead void	syslog_errx(int, const char *, ...)
		    __attribute__((__format__ (printf, 2, 3)));
void		syslog_warn(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
void		syslog_warnx(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
void		syslog_info(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
void		syslog_debug(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
void		syslog_vstrerror(int, int, const char *, va_list)
		    __attribute__((__format__ (printf, 3, 0)));

const struct loggers syslogger = {
	syslog_err,
	syslog_errx,
	syslog_warn,
	syslog_warnx,
	syslog_info,
	syslog_debug
};

const struct loggers *logger = &conslogger;

#define lerr(_e, _f...) logger->err((_e), _f)
#define lerrx(_e, _f...) logger->errx((_e), _f)
#define lwarn(_f...) logger->warn(_f)
#define lwarnx(_f...) logger->warnx(_f)
#define linfo(_f...) logger->info(_f)
#define ldebug(_f...) logger->debug(_f)

__dead void
usage(void)
{
	extern char *__progname;
	fprintf(stderr, "usage: %s [-46cdv] [-l address] [-p port] [-r socket]"
	    " directory\n", __progname);
	exit(1);
}

int		  cancreate = 0;
int		  verbose = 0;
int		  debug = 0;

int
main(int argc, char *argv[])
{
	extern char *__progname;

	int		 c;
	struct passwd	*pw;

	char *dir = NULL;
	char *rewrite = NULL;

	char *addr = NULL;
	char *port = "tftp";
	int family = AF_UNSPEC;
	int devnull = -1;

	while ((c = getopt(argc, argv, "46cdl:p:r:v")) != -1) {
		switch (c) {
		case '4':
			family = AF_INET;
			break;
		case '6':
			family = AF_INET6;
			break;
		case 'c':
			cancreate = 1;
			break;
		case 'd':
			verbose = debug = 1;
			break;
		case 'l':
			addr = optarg;
			break;
		case 'p':
			port = optarg;
			break;
		case 'r':
			rewrite = optarg;
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	argc -= optind;
	argv += optind;

	if (argc != 1)
		usage();

	dir = argv[0];

	if (geteuid() != 0)
		errx(1, "need root privileges");

	pw = getpwnam("_tftpd");
	if (pw == NULL)
		errx(1, "no _tftpd user");

	if (!debug) {
		openlog(__progname, LOG_PID|LOG_NDELAY, LOG_DAEMON);
		tzset();
		logger = &syslogger;
		devnull = open(_PATH_DEVNULL, O_RDWR, 0);
		if (devnull == -1)
			err(1, "open %s", _PATH_DEVNULL);
	}

	if (rewrite != NULL)
		rewrite_connect(rewrite);

	tftpd_listen(addr, port, family);

	if (chroot(dir))
		err(1, "chroot %s", dir);
	if (chdir("/"))
		err(1, "chdir %s", dir);

	/* drop privs */
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		errx(1, "can't drop privileges");

	if (!debug && rdaemon(devnull) == -1)
		err(1, "unable to daemonize");

	if (pledge("stdio rpath wpath cpath fattr dns inet", NULL) == -1)
		lerr(1, "pledge");

	event_init();

	if (rewrite != NULL)
		rewrite_events();

	tftpd_events();

	event_dispatch();

	exit(0);
}

struct rewritemap {
	struct event wrev;
	struct event rdev;
	struct evbuffer *wrbuf;
	struct evbuffer *rdbuf;

	TAILQ_HEAD(, tftp_client) clients;

	int s;
};

struct rewritemap *rwmap = NULL;

void
rewrite_connect(const char *path)
{
	int s;
	struct sockaddr_un remote;
	size_t len;

	rwmap = malloc(sizeof(*rwmap));
	if (rwmap == NULL)
		err(1, "rewrite event malloc");

	rwmap->wrbuf = evbuffer_new();
	if (rwmap->wrbuf == NULL)
		err(1, "rewrite wrbuf");

	rwmap->rdbuf = evbuffer_new();
	if (rwmap->rdbuf == NULL)
		err(1, "rewrite rdbuf");

	TAILQ_INIT(&rwmap->clients);

	s = socket(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK, 0);
	if (s == -1)
		err(1, "rewrite socket");

	remote.sun_family = AF_UNIX;
	len = strlcpy(remote.sun_path, path, sizeof(remote.sun_path));
	if (len >= sizeof(remote.sun_path))
		errx(1, "rewrite socket path is too long");

	len += sizeof(remote.sun_family) + 1;
	if (connect(s, (struct sockaddr *)&remote, len) == -1)
		err(1, "%s", path);

	rwmap->s = s;
}

void
rewrite_events(void)
{
	event_set(&rwmap->wrev, rwmap->s, EV_WRITE, rewrite_req, NULL);
	event_set(&rwmap->rdev, rwmap->s, EV_READ | EV_PERSIST, rewrite_res, NULL);
	event_add(&rwmap->rdev, NULL);
}

void
rewrite_map(struct tftp_client *client, const char *filename)
{
	char *nicebuf;

	if (stravis(&nicebuf, filename, VIS_SAFE|VIS_OCTAL) == -1)
		lerr(1, "rwmap stravis");

	if (evbuffer_add_printf(rwmap->wrbuf, "%s %s %s\n", getip(&client->ss),
	    client->opcode == WRQ ? "write" : "read", nicebuf) == -1)
		lerr(1, "rwmap printf");

	free(nicebuf);

	TAILQ_INSERT_TAIL(&rwmap->clients, client, entry);

	event_add(&rwmap->wrev, NULL);
}

void
rewrite_req(int fd, short events, void *arg)
{
	if (evbuffer_write(rwmap->wrbuf, fd) == -1) {
		switch (errno) {
		case EINTR:
		case EAGAIN:
			event_add(&rwmap->wrev, NULL);
			return;
		}

		lerr(1, "rewrite socket write");
	}

	if (EVBUFFER_LENGTH(rwmap->wrbuf))
		event_add(&rwmap->wrev, NULL);
}

void
rewrite_res(int fd, short events, void *arg)
{
	struct tftp_client *client;
	char *filename;
	size_t len;

	switch (evbuffer_read(rwmap->rdbuf, fd, PATH_MAX)) {
	case -1:
		switch (errno) {
		case EINTR:
		case EAGAIN:
			return;
		}
		lerr(1, "rewrite socket read");
	case 0:
		lerrx(1, "rewrite socket closed");
	default:
		break;
	}

	while ((filename = evbuffer_readln(rwmap->rdbuf, &len,
	    EVBUFFER_EOL_LF)) != NULL) {
		client = TAILQ_FIRST(&rwmap->clients);
		if (client == NULL)
			lerrx(1, "unexpected rwmap reply");

		TAILQ_REMOVE(&rwmap->clients, client, entry);

		tftp_open(client, filename);

		free(filename);
	};
}

int
tftpd_listen(const char *addr, const char *port, int family)
{
	struct tftp_server *server;

	struct addrinfo hints, *res, *res0;
	int error;
	int s;

	int cerrno = EADDRNOTAVAIL;
	const char *cause = "getaddrinfo";

	int on = 1;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = family;
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_flags = AI_PASSIVE;

	TAILQ_INIT(&tftp_servers);

	error = getaddrinfo(addr, port, &hints, &res0);
	if (error) {
		errx(1, "%s:%s: %s", addr ? addr : "*", port,
		    gai_strerror(error));
	}

	for (res = res0; res != NULL; res = res->ai_next) {
		s = socket(res->ai_family, res->ai_socktype | SOCK_NONBLOCK,
		    res->ai_protocol);
		if (s == -1) {
			cause = "socket";
			cerrno = errno;
			continue;
		}

		if (bind(s, res->ai_addr, res->ai_addrlen) == -1) {
			cause = "bind";
			cerrno = errno;
			close(s);
			continue;
		}

		switch (res->ai_family) {
		case AF_INET:
			if (setsockopt(s, IPPROTO_IP, IP_RECVDSTADDR,
			    &on, sizeof(on)) == -1)
				err(1, "setsockopt(IP_RECVDSTADDR)");
			break;
		case AF_INET6:
			if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVPKTINFO,
			    &on, sizeof(on)) == -1)
				err(1, "setsockopt(IPV6_RECVPKTINFO)");
			break;
		}

		server = malloc(sizeof(*server));
		if (server == NULL)
			err(1, "malloc");

		server->s = s;
		TAILQ_INSERT_TAIL(&tftp_servers, server, entry);
	}

	if (TAILQ_EMPTY(&tftp_servers))
		errc(1, cerrno, "%s", cause);

	freeaddrinfo(res0);
	return (0);
}

void
tftpd_events(void)
{
	struct tftp_server *server;
	TAILQ_FOREACH(server, &tftp_servers, entry) {
		event_set(&server->ev, server->s, EV_READ | EV_PERSIST,
		    tftpd_recv, server);
		event_add(&server->ev, NULL);
	}
}

struct tftp_client *
client_alloc(void)
{
	struct tftp_client *client;

	client = calloc(1, sizeof(*client));
	if (client == NULL)
		return (NULL);

	client->segment_size = SEGSIZE;
	client->packet_size = SEGSIZE + 4;

	client->tv.tv_sec = TIMEOUT;
	client->tv.tv_usec = 0;

	client->sock = -1;
	client->file = NULL;
	client->newline = 0;

	return (client);
}

void
client_free(struct tftp_client *client)
{
	free(client->options);

	if (client->file != NULL)
		fclose(client->file);

	close(client->sock);

	free(client);
}

void
tftpd_recv(int fd, short events, void *arg)
{
	union {
		struct cmsghdr hdr;
		char	buf[CMSG_SPACE(sizeof(struct sockaddr_storage))];
	} cmsgbuf;
	struct cmsghdr *cmsg;
	struct msghdr msg;
	struct iovec iov;

	ssize_t n;
	struct sockaddr_storage s_in;
	int dobind = 1;
	int on = 1;

	struct tftphdr *tp;

	struct tftp_client *client;

	client = client_alloc();
	if (client == NULL) {
		char buf[SEGSIZE_MAX + 4];
		/* no memory! flush this request... */
		recv(fd, buf, SEGSIZE_MAX + 4, 0);
		/* dont care if it fails */
		return;
	}

	bzero(&msg, sizeof(msg));
	iov.iov_base = client->buf;
	iov.iov_len = client->packet_size;
	msg.msg_name = &client->ss;
	msg.msg_namelen = sizeof(client->ss);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = &cmsgbuf.buf;
	msg.msg_controllen = sizeof(cmsgbuf.buf);

	n = recvmsg(fd, &msg, 0);
	if (n == -1) {
		lwarn("recvmsg");
		goto err;
	}
	if (n < 4)
		goto err;

	client->sock = socket(client->ss.ss_family,
	    SOCK_DGRAM | SOCK_NONBLOCK, 0);
	if (client->sock == -1) {
		lwarn("socket");
		goto err;
	}
	memset(&s_in, 0, sizeof(s_in));
	s_in.ss_family = client->ss.ss_family;
	s_in.ss_len = client->ss.ss_len;

	/* get local address if possible */
	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;
	    cmsg = CMSG_NXTHDR(&msg, cmsg)) {
		if (cmsg->cmsg_level == IPPROTO_IP &&
		    cmsg->cmsg_type == IP_RECVDSTADDR) {
			memcpy(&((struct sockaddr_in *)&s_in)->sin_addr,
			    CMSG_DATA(cmsg), sizeof(struct in_addr));
			if (((struct sockaddr_in *)&s_in)->sin_addr.s_addr ==
			    INADDR_BROADCAST)
				dobind = 0;
			break;
		}
		if (cmsg->cmsg_level == IPPROTO_IPV6 &&
		    cmsg->cmsg_type == IPV6_PKTINFO) {
			struct in6_pktinfo *ipi;

			ipi = (struct in6_pktinfo *)CMSG_DATA(cmsg);
			memcpy(&((struct sockaddr_in6 *)&s_in)->sin6_addr,
			    &ipi->ipi6_addr, sizeof(struct in6_addr));
#ifdef __KAME__
			if (IN6_IS_ADDR_LINKLOCAL(&ipi->ipi6_addr))
				((struct sockaddr_in6 *)&s_in)->sin6_scope_id =
				    ipi->ipi6_ifindex;
#endif
			break;
		}
	}

	if (dobind) {
		setsockopt(client->sock, SOL_SOCKET, SO_REUSEADDR,
		    &on, sizeof(on));
		setsockopt(client->sock, SOL_SOCKET, SO_REUSEPORT,
		    &on, sizeof(on));

		if (bind(client->sock, (struct sockaddr *)&s_in,
		    s_in.ss_len) < 0) {
			lwarn("bind to %s", getip(&s_in));
			goto err;
		}
	}
	if (connect(client->sock, (struct sockaddr *)&client->ss,
	    client->ss.ss_len) == -1) {
		lwarn("connect to %s", getip(&client->ss));
		goto err;
	}

	tp = (struct tftphdr *)client->buf;
	client->opcode = ntohs(tp->th_opcode);
	if (client->opcode != RRQ && client->opcode != WRQ) {
		/* bad request */
		goto err;
	}

	tftp(client, tp, n);

	return;

err:
	client_free(client);
}

int
parse_options(struct tftp_client *client, char *cp, size_t size,
    struct opt_client *options)
{
	char *option;
	char *ccp;
	int has_options = 0;
	int i;

	while (++cp < client->buf + size) {
		for (i = 2, ccp = cp; i > 0; ccp++) {
			if (ccp >= client->buf + size) {
				/*
				 * Don't reject the request, just stop trying
				 * to parse the option and get on with it.
				 * Some Apple OpenFirmware versions have
				 * trailing garbage on the end of otherwise
				 * valid requests.
				 */
				return (has_options);
			} else if (*ccp == '\0')
				i--;
		}

		for (option = cp; *cp; cp++)
			*cp = tolower((unsigned char)*cp);

		for (i = 0; i < NOPT; i++) {
			if (strcmp(option, opt_names[i]) == 0) {
				options[i].o_request = ++cp;
				has_options = 1;
			}
		}
		cp = ccp - 1;
	}

	return (has_options);
}

/*
 * Handle initial connection protocol.
 */
void
tftp(struct tftp_client *client, struct tftphdr *tp, size_t size)
{
	struct opt_client *options;

	char		*cp;
	int		 i, first = 1, ecode, to;
	struct formats	*pf;
	char		*mode = NULL;
	char		 filename[PATH_MAX];
	const char	*errstr;

	if (size < 5) {
		ecode = EBADOP;
		goto error;
	}

	cp = tp->th_stuff;
again:
	while (cp < client->buf + size) {
		if (*cp == '\0')
			break;
		cp++;
	}
	if (*cp != '\0') {
		ecode = EBADOP;
		goto error;
	}
	i = cp - tp->th_stuff;
	if (i >= sizeof(filename)) {
		ecode = EBADOP;
		goto error;
	}
	memcpy(filename, tp->th_stuff, i);
	filename[i] = '\0';
	if (first) {
		mode = ++cp;
		first = 0;
		goto again;
	}
	for (cp = mode; *cp; cp++)
		*cp = tolower((unsigned char)*cp);

	for (pf = formats; pf->f_mode; pf++) {
		if (strcmp(pf->f_mode, mode) == 0)
			break;
	}
	if (pf->f_mode == 0) {
		ecode = EBADOP;
		goto error;
	}
	client->fgetc = pf->f_getc;
	client->fputc = pf->f_putc;

	client->options = options = calloc(NOPT, sizeof(*client->options));
	if (options == NULL) {
		ecode = 100 + ENOMEM;
		goto error;
	}

	if (parse_options(client, cp, size, options)) {
		if (options[OPT_TIMEOUT].o_request != NULL) {
			to = strtonum(options[OPT_TIMEOUT].o_request,
			    TIMEOUT_MIN, TIMEOUT_MAX, &errstr);
			if (errstr) {
				ecode = EBADOP;
				goto error;
			}
			options[OPT_TIMEOUT].o_reply = client->tv.tv_sec = to;
		}

		if (options[OPT_BLKSIZE].o_request) {
			client->segment_size = strtonum(
			    options[OPT_BLKSIZE].o_request,
			    SEGSIZE_MIN, SEGSIZE_MAX, &errstr);
			if (errstr) {
				ecode = EBADOP;
				goto error;
			}
			client->packet_size = client->segment_size + 4;
			options[OPT_BLKSIZE].o_reply = client->segment_size;
		}
	} else {
		free(options);
		client->options = NULL;
	}

	if (verbose) {
		char nicebuf[PATH_MAX];

		(void)strnvis(nicebuf, filename, PATH_MAX,
		    VIS_SAFE|VIS_OCTAL);

		linfo("%s: %s request for '%s'", getip(&client->ss),
		    client->opcode == WRQ ? "write" : "read", nicebuf);
	}

	if (rwmap != NULL)
		rewrite_map(client, filename);
	else
		tftp_open(client, filename);

	return;

error:
	nak(client, ecode);
}

void
tftp_open(struct tftp_client *client, const char *filename)
{
	int ecode;

	ecode = validate_access(client, filename);
	if (ecode)
		goto error;

	if (client->options) {
		if (oack(client) == -1)
			goto error;

		free(client->options);
		client->options = NULL;
	} else if (client->opcode == WRQ) {
		recvfile(client);
	} else
		sendfile(client);

	return;
error:
	nak(client, ecode);
}

/*
 * Validate file access.  Since we
 * have no uid or gid, for now require
 * file to exist and be publicly
 * readable/writable.
 * If we were invoked with arguments
 * from inetd then the file must also be
 * in one of the given directory prefixes.
 * Note also, full path name must be
 * given as we have no login directory.
 */
int
validate_access(struct tftp_client *client, const char *filename)
{
	int		 mode = client->opcode;
	struct opt_client *options = client->options;
	struct stat	 stbuf;
	int		 fd, wmode;
	const char	*errstr;

	if (strcmp(filename, SEEDPATH) == 0) {
		char *buf;
		if (mode != RRQ)
			return (EACCESS);

		buf = client->buf + sizeof(client->buf) - 512;
		arc4random_buf(buf, 512);
		client->file = fmemopen(buf, 512, "r");
		if (client->file == NULL)
			return (errno + 100);

		return (0);
	}

	/*
	 * We use a different permissions scheme if `cancreate' is
	 * set.
	 */
	wmode = O_TRUNC;
	if (stat(filename, &stbuf) < 0) {
		if (!cancreate)
			return (errno == ENOENT ? ENOTFOUND : EACCESS);
		else {
			if ((errno == ENOENT) && (mode != RRQ))
				wmode |= O_CREAT;
			else
				return (EACCESS);
		}
	} else {
		if (mode == RRQ) {
			if ((stbuf.st_mode & (S_IRUSR >> 6)) == 0)
				return (EACCESS);
		} else {
			if ((stbuf.st_mode & (S_IWUSR >> 6)) == 0)
				return (EACCESS);
		}
	}

	if (options != NULL && options[OPT_TSIZE].o_request) {
		if (mode == RRQ)
			options[OPT_TSIZE].o_reply = stbuf.st_size;
		else {
			/* allows writes of 65535 blocks * SEGSIZE_MAX bytes */
			options[OPT_TSIZE].o_reply =
			    strtonum(options[OPT_TSIZE].o_request,
			    1, 65535LL * SEGSIZE_MAX, &errstr);
			if (errstr)
				return (EOPTNEG);
		}
	}
	fd = open(filename, mode == RRQ ? O_RDONLY : (O_WRONLY|wmode), 0666);
	if (fd < 0)
		return (errno + 100);
	/*
	 * If the file was created, set default permissions.
	 */
	if ((wmode & O_CREAT) && fchmod(fd, 0666) < 0) {
		int serrno = errno;

		close(fd);
		unlink(filename);

		return (serrno + 100);
	}
	client->file = fdopen(fd, mode == RRQ ? "r" : "w");
	if (client->file == NULL) {
		close(fd);
		return (errno + 100);
	}

	return (0);
}

int
fget_octet(struct tftp_client *client)
{
	return (getc(client->file));
}

int
fput_octet(struct tftp_client *client, int c)
{
	return (putc(c, client->file));
}

int
fget_netascii(struct tftp_client *client)
{
	int c = -1;

	switch (client->newline) {
	case 0:
		c = getc(client->file);
		if (c == EOF)
			break;

		if (c == '\n' || c == '\r') {
			client->newline = c;
			c = '\r';
		}
		break;
	case '\n':
		client->newline = 0;
		c = '\n';
		break;
	case '\r':
		client->newline = 0;
		c = '\0';
		break;
	}

	return (c);
}

int
fput_netascii(struct tftp_client *client, int c)
{
	if (client->newline == '\r') {
		client->newline = 0;

		if (c == '\0')
			c = '\r';

	} else if (c == '\r') {
		client->newline = c;
		return (c);
	}

	return (putc(c, client->file));
}

void
sendfile(struct tftp_client *client)
{
	event_set(&client->sev, client->sock, EV_READ, tftp_rrq_ack, client);
	client->block = 1;

	file_read(client);
}

void
file_read(struct tftp_client *client)
{
	u_int8_t *buf;
	struct tftphdr *dp;
	int i;
	int c;

	dp = (struct tftphdr *)client->buf;
	dp->th_opcode = htons((u_short)DATA);
	dp->th_block = htons(client->block);
	buf = (u_int8_t *)dp->th_data;

	for (i = 0; i < client->segment_size; i++) {
		c = client->fgetc(client);
		if (c == EOF) {
			if (ferror(client->file)) {
				nak(client, 100 + EIO);
				return;
			}

			break;
		}
		buf[i] = c;
	}

	client->buflen = i + 4;
	client->retries = RETRIES;

	if (send(client->sock, client->buf, client->buflen, 0) == -1) {
		lwarn("send(block)");
		client_free(client);
		return;
	}

	event_add(&client->sev, &client->tv);
}

void
tftp_rrq_ack(int fd, short events, void *arg)
{
	struct tftp_client *client = arg;
	struct tftphdr *ap; /* ack packet */
	char rbuf[SEGSIZE_MIN];
	ssize_t n;

	if (events & EV_TIMEOUT) {
		if (retry(client) == -1) {
			lwarn("%s: retry", getip(&client->ss));
			goto done;
		}

		return;
	}

	n = recv(fd, rbuf, sizeof(rbuf), 0);
	if (n == -1) {
		switch (errno) {
		case EINTR:
		case EAGAIN:
			event_add(&client->sev, &client->tv);
			return;

		default:
			lwarn("%s: recv", getip(&client->ss));
			goto done;
		}
	}

	ap = (struct tftphdr *)rbuf;
	ap->th_opcode = ntohs((u_short)ap->th_opcode);
	ap->th_block = ntohs((u_short)ap->th_block);

	switch (ap->th_opcode) {
	case ERROR:
		goto done;
	case ACK:
		break;
	default:
		goto retry;
	}

	if (ap->th_block != client->block) {
		if (tftp_flush(client) == -1) {
			lwarnx("%s: flush", getip(&client->ss));
			goto done;
		}

		if (ap->th_block != (client->block - 1))
			goto done;

		goto retry;
	}

	if (client->buflen != client->packet_size) {
		/* this was the last packet in the stream */
		goto done;
	}

	client->block++;
	file_read(client);
	return;

retry:
	event_add(&client->sev, &client->tv);
	return;

done:
	client_free(client);
}

int
tftp_flush(struct tftp_client *client)
{
	char rbuf[SEGSIZE_MIN];
	ssize_t n;

	for (;;) {
		n = recv(client->sock, rbuf, sizeof(rbuf), 0);
		if (n == -1) {
			switch (errno) {
			case EAGAIN:
				return (0);

			case EINTR:
				break;

			default:
				return (-1);
			}
		}
	}
}

void
recvfile(struct tftp_client *client)
{
	event_set(&client->sev, client->sock, EV_READ, tftp_wrq, client);
	tftp_wrq_ack(client);
}

int
tftp_wrq_ack_packet(struct tftp_client *client)
{
	struct tftphdr *ap; /* ack packet */

	ap = (struct tftphdr *)client->buf;
	ap->th_opcode = htons((u_short)ACK);
	ap->th_block = htons(client->block);

	client->buflen = 4;
	client->retries = RETRIES;

	return (send(client->sock, client->buf, client->buflen, 0) != 4);
}

void
tftp_wrq_ack(struct tftp_client *client)
{
	if (tftp_wrq_ack_packet(client) != 0) {
		lwarn("tftp wrq ack");
		client_free(client);
		return;
	}

	client->block++;
	event_add(&client->sev, &client->tv);
}

void
tftp_wrq(int fd, short events, void *arg)
{
	char wbuf[SEGSIZE_MAX + 4];
	struct tftp_client *client = arg;
	struct tftphdr *dp;
	ssize_t n;
	int i;

	if (events & EV_TIMEOUT) {
		if (retry(client) == -1) {
			lwarn("%s", getip(&client->ss));
			goto done;
		}

		return;
	}

	n = recv(fd, wbuf, client->packet_size, 0);
	if (n == -1) {
		switch (errno) {
		case EINTR:
		case EAGAIN:
			goto retry;

		default:
			lwarn("tftp_wrq recv");
			goto done;
		}
	}

	if (n < 4)
		goto done;

	dp = (struct tftphdr *)wbuf;
	dp->th_opcode = ntohs((u_short)dp->th_opcode);
	dp->th_block = ntohs((u_short)dp->th_block);

	switch (dp->th_opcode) {
	case ERROR:
		goto done;
	case DATA:
		break;
	default:
		goto retry;
	}

	if (dp->th_block != client->block) {
		if (tftp_flush(client) == -1) {
			lwarnx("%s: flush", getip(&client->ss));
			goto done;
		}

		if (dp->th_block != (client->block - 1))
			goto done;

		goto retry;
	}

	for (i = 4; i < n; i++) {
		if (client->fputc(client, wbuf[i]) == EOF) {
			lwarn("tftp wrq");
			goto done;
		}
	}

	if (n < client->packet_size) {
		tftp_wrq_ack_packet(client);
		fclose(client->file);
		client->file = NULL;
		event_set(&client->sev, client->sock, EV_READ,
		    tftp_wrq_end, client);
		event_add(&client->sev, &client->tv);
		return;
	}

	tftp_wrq_ack(client);
	return;

retry:
	event_add(&client->sev, &client->tv);
	return;
done:
	client_free(client);
}

void
tftp_wrq_end(int fd, short events, void *arg)
{
	char wbuf[SEGSIZE_MAX + 4];
	struct tftp_client *client = arg;
	struct tftphdr *dp;
	ssize_t n;

	if (events & EV_TIMEOUT) {
		/* this was the last packet, we can clean up */
		goto done;
	}

	n = recv(fd, wbuf, client->packet_size, 0);
	if (n == -1) {
		switch (errno) {
		case EINTR:
		case EAGAIN:
			goto retry;

		default:
			lwarn("tftp_wrq_end recv");
			goto done;
		}
	}

	if (n < 4)
		goto done;

	dp = (struct tftphdr *)wbuf;
	dp->th_opcode = ntohs((u_short)dp->th_opcode);
	dp->th_block = ntohs((u_short)dp->th_block);

	switch (dp->th_opcode) {
	case ERROR:
		goto done;
	case DATA:
		break;
	default:
		goto retry;
	}

	if (dp->th_block != client->block)
		goto done;

retry:
	if (retry(client) == -1) {
		lwarn("%s", getip(&client->ss));
		goto done;
	}
	return;
done:
	client_free(client);
	return;
}


/*
 * Send a nak packet (error message).
 * Error code passed in is one of the
 * standard TFTP codes, or a UNIX errno
 * offset by 100.
 */
void
nak(struct tftp_client *client, int error)
{
	struct tftphdr	*tp;
	struct errmsg	*pe;
	size_t		 length;

	tp = (struct tftphdr *)client->buf;
	tp->th_opcode = htons((u_short)ERROR);
	tp->th_code = htons((u_short)error);

	for (pe = errmsgs; pe->e_code >= 0; pe++) {
		if (pe->e_code == error)
			break;
	}
	if (pe->e_code < 0) {
		pe->e_msg = strerror(error - 100);
		tp->th_code = htons(EUNDEF);   /* set 'undef' errorcode */
	}

	length = strlcpy(tp->th_msg, pe->e_msg, client->packet_size - 5) + 5;
	if (length > client->packet_size)
		length = client->packet_size;

	if (send(client->sock, client->buf, length, 0) != length)
		lwarn("nak");

	client_free(client);
}

/*
 * Send an oack packet (option acknowledgement).
 */
int
oack(struct tftp_client *client)
{
	struct opt_client *options = client->options;
	struct tftphdr *tp;
	char *bp;
	int i, n, size;

	tp = (struct tftphdr *)client->buf;
	bp = (char *)tp->th_stuff;
	size = sizeof(client->buf) - 2;

	tp->th_opcode = htons((u_short)OACK);
	for (i = 0; i < NOPT; i++) {
		if (options[i].o_request == NULL)
			continue;

		n = snprintf(bp, size, "%s%c%lld", opt_names[i], '\0',
		    options[i].o_reply);
		if (n == -1 || n >= size) {
			lwarnx("oack: no buffer space");
			goto error;
		}

		bp += n + 1;
		size -= n + 1;
		if (size < 0) {
			lwarnx("oack: no buffer space");
			goto error;
		}
	}

	client->buflen = bp - client->buf;
	client->retries = RETRIES;

	if (send(client->sock, client->buf, client->buflen, 0) == -1) {
		lwarn("oack");
		goto error;
	}

	/* no client ACK for write requests with options */
	if (client->opcode == WRQ) {
		client->block = 1;
		event_set(&client->sev, client->sock, EV_READ,
		    tftp_wrq, client);
	} else
		event_set(&client->sev, client->sock, EV_READ,
		    oack_done, client);

	event_add(&client->sev, &client->tv);
	return (0);

error:
	return (-1);
}

int
retry(struct tftp_client *client)
{
	if (--client->retries == 0) {
		errno = ETIMEDOUT;
		return (-1);
	}

	if (send(client->sock, client->buf, client->buflen, 0) == -1)
		return (-1);

	event_add(&client->sev, &client->tv);

	return (0);
}

void
oack_done(int fd, short events, void *arg)
{
	struct tftp_client *client = arg;
	struct tftphdr *ap;
	ssize_t n;

	if (events & EV_TIMEOUT) {
		if (retry(client) == -1) {
			lwarn("%s", getip(&client->ss));
			goto done;
		}

		return;
	}

	n = recv(client->sock, client->buf, client->packet_size, 0);
	if (n == -1) {
		switch (errno) {
		case EINTR:
		case EAGAIN:
			event_add(&client->sev, &client->tv);
			return;

		default:
			lwarn("%s: recv", getip(&client->ss));
			goto done;
		}
	}

	if (n < 4)
		goto done;

	ap = (struct tftphdr *)client->buf;
	ap->th_opcode = ntohs((u_short)ap->th_opcode);
	ap->th_block = ntohs((u_short)ap->th_block);

	if (ap->th_opcode != ACK || ap->th_block != 0)
		goto done;

	sendfile(client);
	return;

done:
	client_free(client);
}

const char *
getip(void *s)
{
	struct sockaddr *sa = s;
	static char hbuf[NI_MAXHOST];

	if (getnameinfo(sa, sa->sa_len, hbuf, sizeof(hbuf),
	    NULL, 0, NI_NUMERICHOST))
		strlcpy(hbuf, "0.0.0.0", sizeof(hbuf));

	return(hbuf);
}

/* daemon(3) clone, intended to be used in a "r"estricted environment */
int
rdaemon(int devnull)
{
	if (devnull == -1) {
		errno = EBADF;
		return (-1);
	}
	if (fcntl(devnull, F_GETFL) == -1)
		return (-1);

	switch (fork()) {
	case -1:
		return (-1);
	case 0:
		break;
	default:
		_exit(0);
	}

	if (setsid() == -1)
		return (-1);

	(void)dup2(devnull, STDIN_FILENO);
	(void)dup2(devnull, STDOUT_FILENO);
	(void)dup2(devnull, STDERR_FILENO);
	if (devnull > 2)
		(void)close(devnull);

	return (0);
}

void
syslog_vstrerror(int e, int priority, const char *fmt, va_list ap)
{
	char *s;

	if (vasprintf(&s, fmt, ap) == -1) {
		syslog(LOG_EMERG, "unable to alloc in syslog_vstrerror");
		exit(1);
	}

	syslog(priority, "%s: %s", s, strerror(e));

	free(s);
}

void
syslog_err(int ecode, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	syslog_vstrerror(errno, LOG_CRIT, fmt, ap);
	va_end(ap);

	exit(ecode);
}

void
syslog_errx(int ecode, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsyslog(LOG_CRIT, fmt, ap);
	va_end(ap);

	exit(ecode);
}

void
syslog_warn(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	syslog_vstrerror(errno, LOG_ERR, fmt, ap);
	va_end(ap);
}

void
syslog_warnx(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsyslog(LOG_ERR, fmt, ap);
	va_end(ap);
}

void
syslog_info(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsyslog(LOG_INFO, fmt, ap);
	va_end(ap);
}

void
syslog_debug(const char *fmt, ...)
{
	va_list ap;

	if (!debug)
		return;

	va_start(ap, fmt);
	vsyslog(LOG_DEBUG, fmt, ap);
	va_end(ap);
}
@


1.38
log
@Exit early from rdaemon() is the passed fd is invalid.

fd == -1 check suggested by deraadt@@, ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.37 2016/09/04 14:41:49 florian Exp $	*/
d1636 1
a1636 1
	syslog_vstrerror(errno, LOG_EMERG, fmt, ap);
d1648 1
a1648 1
	vsyslog(LOG_WARNING, fmt, ap);
d1660 1
a1660 1
	syslog_vstrerror(errno, LOG_WARNING, fmt, ap);
d1670 1
a1670 1
	vsyslog(LOG_WARNING, fmt, ap);
@


1.37
log
@Add format attribute to logger functions.
Add syslog_debug to keep in sync with others.
Input & OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.36 2016/03/31 23:03:26 jca Exp $	*/
d1587 6
@


1.36
log
@For consistency, omit the variable name in rdaemon() prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.35 2016/03/31 23:00:46 jca Exp $	*/
d225 12
a236 5
	void (*err)(int, const char *, ...);
	void (*errx)(int, const char *, ...);
	void (*warn)(const char *, ...);
	void (*warnx)(const char *, ...);
	void (*info)(const char *, ...);
d244 2
a245 1
	warnx
d248 14
a261 6
void	syslog_err(int, const char *, ...);
void	syslog_errx(int, const char *, ...);
void	syslog_warn(const char *, ...);
void	syslog_warnx(const char *, ...);
void	syslog_info(const char *, ...);
void	syslog_vstrerror(int, int, const char *, va_list);
d269 1
d279 1
d292 1
a297 1
	int debug = 0;
d1678 12
@


1.35
log
@Go in the background much later, to reduce possible silent failures.

rev. 1.34 moved the call to daemon() before the chroot, thus hiding
errors if the target directory or _tftpd user don't exist.  To go in the
background later we need to preopen /dev/null.  The code is put in
a daemon(3) like function that could be used in other daemons.

Lack of error reporting spotted by ajacoutot@@, initial diff from dlg@@.
rdaemon() "concept" discussed with semarie@@.  ok ajacoutot@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.34 2015/12/14 16:34:55 semarie Exp $	*/
d156 1
a156 1
int		rdaemon(int devnull);
@


1.34
log
@move daemon(3) call before chroot(2) in tftpd.

so daemon(3) will be able to redirect standard input, standard output and
standard error to /dev/null.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.33 2015/12/11 20:11:10 mmcc Exp $	*/
d77 1
d156 1
d290 1
d343 3
a352 3
	if (!debug && daemon(1, 0) == -1)
		err(1, "unable to daemonize");

d364 3
d368 1
a368 1
		err(1, "pledge");
d1563 26
@


1.33
log
@Remove NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.32 2015/10/18 03:54:22 deraadt Exp $	*/
d347 3
a359 3

	if (!debug && daemon(1, 0) == -1)
		err(1, "unable to daemonize");
@


1.32
log
@Add "dns" to the pledges.  Previously these worked because of "inet",
alas "dns" is now a mandatory statement if you want to do dns!
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.31 2015/10/10 22:21:39 deraadt Exp $	*/
d613 1
a613 2
	if (client->options != NULL)
		free(client->options);
@


1.31
log
@pledge "stdio rpath wpath cpath fattr inet" after chroot and such
appears to be good enough for the main loop processing.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.30 2015/10/06 06:03:11 deraadt Exp $	*/
d361 1
a361 1
	if (pledge("stdio rpath wpath cpath fattr inet", NULL) == -1)
@


1.30
log
@do not need ioctl.h
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.29 2015/08/20 11:28:15 dlg Exp $	*/
d360 3
@


1.29
log
@use SOCK_NONBLOCK when making a socket instead of ioctl FIONBIO.

for guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.28 2015/07/20 04:28:03 dlg Exp $	*/
d60 1
a60 1
#include <sys/ioctl.h>
@


1.28
log
@tweak the /etc/random.seed interception so it provides a FILE* via
fmemopen for the rest of the code to chew on, rather than having
special casing for seed generation in the sending code.

this also means our fake random.seed files will get proper netascii
encoding by being read via the fgetc api instead of directly from
a buffer.

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.27 2015/07/18 05:32:56 mcbride Exp $	*/
a391 1
	int on = 1;
d407 1
a407 1
	s = socket(AF_UNIX, SOCK_STREAM, 0);
a419 3
	if (ioctl(s, FIONBIO, &on) < 0)
		err(1, "rewrite ioctl(FIONBIO)");

d531 2
a532 1
		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
a545 3
		if (ioctl(s, FIONBIO, &on) < 0)
			err(1, "ioctl(FIONBIO)");

d668 2
a669 1
	client->sock = socket(client->ss.ss_family, SOCK_DGRAM, 0);
a722 3

	if (ioctl(client->sock, FIONBIO, &on) < 0)
		err(1, "client ioctl(FIONBIO)");
@


1.27
log
@Have tftpd provide a block of random data when clients request the file
/etc/random.seed.

This allows netbooted systems to inject entropy early in the kernel start.
pxeboot requests it already, so no configuration or change is needed on
the client side.

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.26 2015/01/16 06:40:22 deraadt Exp $	*/
a150 1
	int seed;
d943 2
a944 1
		if (mode != RRQ)	
d946 7
a952 1
		client->seed = 1;
d1095 6
a1100 17
	if (client->seed) {
		if (client->block * client->segment_size > SEGSIZE) {
			i = SEGSIZE % client->segment_size;
		} else {
			i = client->segment_size;
		}
		arc4random_buf(buf, i);
	} else {
		for (i = 0; i < client->segment_size; i++) {
			c = client->fgetc(client);
			if (c == EOF) {
				if (ferror(client->file)) {
					nak(client, 100 + EIO);
					return;
				}
	
				break;
d1102 2
a1103 1
			buf[i] = c;
d1105 1
d1319 1
a1319 2
		if (client->file != NULL)
			fclose(client->file);
@


1.26
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.25 2014/12/17 22:23:33 tedu Exp $	*/
d94 2
d151 1
d943 7
d1089 17
a1105 6
	for (i = 0; i < client->segment_size; i++) {
		c = client->fgetc(client);
		if (c == EOF) {
			if (ferror(client->file)) {
				nak(client, 100 + EIO);
				return;
d1107 1
a1107 2

			break;
a1108 1
		buf[i] = c;
d1322 2
a1323 1
		fclose(client->file);
@


1.25
log
@the easier way to put a buffer on the stack is to put it on the stack,
not with alloca(). found by dickman; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.24 2014/11/25 23:52:09 dlg Exp $	*/
a60 2
#include <sys/param.h>
#include <sys/types.h>
d85 1
d477 1
a477 1
	switch (evbuffer_read(rwmap->rdbuf, fd, MAXPATHLEN)) {
d796 1
a796 1
	char		 filename[MAXPATHLEN];
d875 1
a875 1
		char nicebuf[MAXPATHLEN];
d877 1
a877 1
		(void)strnvis(nicebuf, filename, MAXPATHLEN,
@


1.24
log
@evbuffer_read and evbuffer_write are wrappers around read and write,
so you have to check their return values in the same way and handle
errors the same way.

returning 0 from evbuffer_read means the other end of the socket
has gone away.

we should try again on both evbuffer_read and evbuffer_write if we
get EAGAIN or EINTR.

ok millert@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.23 2014/11/19 11:48:39 dlg Exp $	*/
d648 1
a648 1
		char *buf = alloca(SEGSIZE_MAX + 4);
@


1.23
log
@move to stravis so doug@@ will stop laughing at my misuse of strnvis.

ok doug@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.22 2014/08/13 17:41:58 tobias Exp $	*/
d456 10
a465 2
	if (evbuffer_write(rwmap->wrbuf, fd) == -1)
		lerr(1, "rwmap read");
d478 13
a490 2
	if (evbuffer_read(rwmap->rdbuf, fd, MAXPATHLEN) == -1)
		lerr(1, "rwmap read");
@


1.22
log
@Always call freeaddrinfo after getaddrinfo.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.21 2014/08/13 01:03:56 dlg Exp $	*/
d437 1
a437 1
	char nicebuf[MAXPATHLEN];
d439 2
a440 1
	(void)strnvis(nicebuf, filename, MAXPATHLEN, VIS_SAFE|VIS_OCTAL);
d445 2
@


1.21
log
@use errc instead of juggling errno values in tftpd_listen.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.20 2014/08/13 01:00:16 dlg Exp $	*/
d553 1
@


1.20
log
@setsockopt sets errno on failure, so we can use err instead of errx when
handling the error.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.19 2014/04/21 04:02:52 dlg Exp $	*/
d493 2
a494 2
	int saved_errno;
	const char *cause = NULL;
d515 1
d521 1
a521 1
			saved_errno = errno;
a522 1
			errno = saved_errno;
d551 1
a551 1
		err(1, "%s", cause);
@


1.19
log
@th_code is in network byte order
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.18 2013/11/26 21:47:16 deraadt Exp $	*/
d533 1
a533 1
				errx(1, "setsockopt(IP_RECVDSTADDR)");
d538 1
a538 1
				errx(1, "setsockopt(IPV6_RECVPKTINFO)");
@


1.18
log
@unsigned char for ctype
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.17 2013/11/12 22:27:13 deraadt Exp $	*/
d1379 1
a1379 1
		tp->th_code = EUNDEF;   /* set 'undef' errorcode */
@


1.17
log
@ensure there are prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.16 2013/08/13 12:39:02 dlg Exp $	*/
d748 1
a748 1
			*cp = tolower(*cp);
d806 1
a806 1
		*cp = tolower(*cp);
@


1.16
log
@when handling puts from a client (ie, tftpd is writing a file to
disk), we maintain the client state after we've finished writing
the file in case the client loses our ack of the last write.
unfortunately we didnt close the file we'd just written when we
knew it was finished, but only after we clean up the client state
after that wait.

because we use FILE stuff to write the file out, its likely some
io flushed to disk until we finish that wait and close the file as
part of cleaning up the client state. if something is coordinating
a bunch of uploads and expects the file to be there after the client
is happy its there, this can be "not good".

this closes the file after we know its finished before proceeding
to hang to handle lost acks to the client.

found by and ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.15 2013/06/01 21:06:39 deraadt Exp $	*/
d191 4
d568 1
a568 1
client_alloc()
@


1.15
log
@use the standardized names instead of S_IREAD and S_IWRITE
ok guenther dtucker
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.14 2013/05/07 00:26:34 dlg Exp $	*/
d1277 2
@


1.14
log
@getpwnam doesnt set errno on failure, so use errx, not err, to say it
failed.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.13 2013/03/17 09:48:36 dlg Exp $	*/
d930 1
a930 1
			if ((stbuf.st_mode & (S_IREAD >> 6)) == 0)
d933 1
a933 1
			if ((stbuf.st_mode & (S_IWRITE >> 6)) == 0)
@


1.13
log
@i missed the bit of maxime villards diff that took the client_free out of
oack on error.

his fix is better, so this marges all of it in.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.12 2013/03/15 13:13:10 dlg Exp $	*/
d329 1
a329 1
		err(1, "no _tftpd user");
@


1.12
log
@let oack use the full buffer space to build its packet, not just the size
negotiated for data tranfsers.

this lets people negotiate 2 byte transfers with other options too if they
want. im looking at you Maxime Villard.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.11 2013/03/15 12:52:03 dlg Exp $	*/
d875 2
a876 4
	if (ecode) {
		nak(client, ecode);
		return;
	}
d880 1
a880 1
			return;
d890 2
a1441 1
	client_free(client);
@


1.11
log
@"correct" the order of calloc arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.10 2013/03/15 12:36:11 dlg Exp $	*/
d1399 1
a1399 1
	size = client->packet_size - 2;
@


1.10
log
@fix up some lwarn()s that should be lwarnx()s
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.9 2013/03/15 12:20:11 dlg Exp $	*/
d568 1
a568 1
	client = calloc(sizeof(*client), 1);
d815 1
a815 1
	client->options = options = calloc(sizeof(*client->options), NOPT);
@


1.9
log
@fix a huge bug in tftpd.

there was a double free if an option ack failed. if oack fails, the client
gets freed, then the oack caller tries to free the options which were just
freed.

found by Maxime Villard who provided a fix. unfortunately his fix still
had a double free but it was pretty close.
ok MALLOC_OPTIONS=S
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.8 2012/07/13 02:31:46 gsoares Exp $	*/
d1409 1
a1409 1
			lwarn("oack: no buffer space");
d1416 1
a1416 1
			lwarn("oack: no buffer space");
@


1.8
log
@zap trailing whitespace; no binary change
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.7 2012/07/10 07:25:37 dlg Exp $	*/
d171 1
a171 1
void		oack(struct tftp_client *);
d875 4
a878 2
	if (ecode)
		goto error;
d881 2
a882 1
		oack(client);
a891 3

error:
	nak(client, ecode);
d1389 1
a1389 1
void
d1439 1
a1439 1
	return;
d1443 1
@


1.8.4.1
log
@errata for a DoS found by Maxime Villard.

inability to oack would cause tftpd to segfault due to a double free when
it tried to clean up.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.8.2.1 2013/03/21 05:20:32 dlg Exp $	*/
d171 1
a171 1
int		oack(struct tftp_client *);
d568 1
a568 1
	client = calloc(1, sizeof(*client));
d815 1
a815 1
	client->options = options = calloc(NOPT, sizeof(*client->options));
d879 1
a879 2
		if (oack(client) == -1)
			goto error;
d889 1
d1389 1
a1389 1
int
d1399 1
a1399 1
	size = sizeof(client->buf) - 2;
d1409 1
a1409 1
			lwarnx("oack: no buffer space");
d1416 1
a1416 1
			lwarnx("oack: no buffer space");
d1439 1
a1439 1
	return (0);
d1442 1
a1442 1
	return (-1);
@


1.8.2.1
log
@errata for a DoS found by Maxime Villard.

inability to oack would cause tftpd to segfault due to a double free when
it tried to clean up.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.13 2013/03/17 09:48:36 dlg Exp $	*/
d171 1
a171 1
int		oack(struct tftp_client *);
d568 1
a568 1
	client = calloc(1, sizeof(*client));
d815 1
a815 1
	client->options = options = calloc(NOPT, sizeof(*client->options));
d879 1
a879 2
		if (oack(client) == -1)
			goto error;
d889 1
d1389 1
a1389 1
int
d1399 1
a1399 1
	size = sizeof(client->buf) - 2;
d1409 1
a1409 1
			lwarnx("oack: no buffer space");
d1416 1
a1416 1
			lwarnx("oack: no buffer space");
d1439 1
a1439 1
	return (0);
d1442 1
a1442 1
	return (-1);
@


1.7
log
@fix the last outstanding functionality difference i could find between
libexec and usr.sbin tftpd.

libexec waitied around after finishing a wrq in case our ack for the last
write from a client got lost. this does the same dance, or an arguably
better version of it compared to libexec tftpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.5 2012/03/15 07:18:35 nicm Exp $	*/
d217 1
a217 1
struct loggers {   
d297 1
a297 1
			break;	
d1530 1
a1530 1
 
d1532 1
a1532 1
 
d1535 1
a1535 1
 
d1538 1
a1538 1
{  
@


1.6
log
@libexec/tftpd handled the case where we'd get an ack for the previous
block by flushing the data on the socket and waiting for a retransmit
by timeout to occur.

my stuff (usr.sbin/tftpd) had XXXs and failure in those places.

this diff fixes that.

this should address the problems that sthen and jcs have been having
(and which i was finally able to reproduce here).

it also avoids reusing the clients buffer to both send and recv
frames. we recv onto the stack now so retry always sends what we
originally built for the peer.

tested by and ok jcs@@ sthen@@
@
text
@d166 1
d185 1
d1277 4
a1280 1
		goto done;
d1292 57
@


1.5
log
@Add sys/queue.h. ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.4 2012/03/07 22:24:01 dlg Exp $	*/
d165 1
d1081 1
d1085 2
a1086 1
		if (retry(client) == -1)
d1088 1
d1093 1
a1093 1
	n = recv(fd, client->buf, client->packet_size, 0);
d1102 1
d1107 1
a1107 1
	ap = (struct tftphdr *)client->buf;
d1111 2
a1112 1
	if (ap->th_opcode == ERROR)
d1114 17
a1130 2
	if (ap->th_opcode != ACK || ap->th_block != client->block)
		goto done; /* XXX */
d1141 4
d1149 23
d1188 1
a1189 1
	client->buflen = 4;
d1210 1
d1217 2
a1218 1
		if (retry(client) == -1)
d1220 1
d1225 1
a1225 1
	n = recv(client->sock, client->buf, client->packet_size, 0);
d1241 1
a1241 1
	dp = (struct tftphdr *)client->buf;
d1245 2
a1246 1
	if (dp->th_opcode != DATA)
d1248 5
d1254 11
a1264 2
	if (dp->th_block != client->block)
		goto done;
d1267 1
a1267 1
		if (client->fputc(client, client->buf[i]) == EOF) {
d1386 2
a1387 1
	if (--client->retries == 0)
d1389 1
d1392 1
a1392 1
		return -1;
d1407 2
a1408 1
		if (retry(client) == -1)
d1410 1
d1424 1
a1424 1
			lwarn("recv");
@


1.4
log
@dont mix code and declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.3 2012/03/02 16:39:22 jmc Exp $	*/
d63 1
@


1.3
log
@tweaks;
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.2 2012/03/02 04:51:21 dlg Exp $	*/
d488 2
a493 2

	int on = 1;
@


1.2
log
@CFLAGS+= -Wall -Werror and the resulting cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: tftpd.c,v 1.63 2009/10/27 23:59:32 deraadt Exp $	*/
d256 1
a256 1
	fprintf(stderr, "usage: %s [-46cdv] [-l addr] [-p port] [-r sock]"
@


1.1
log
@Initial revision
@
text
@d270 1
a270 1
	int		 n = 0, i, c;
d462 2
a463 2
	while (filename = evbuffer_readln(rwmap->rdbuf, &len,
	    EVBUFFER_EOL_LF)) {
a612 1
	struct tftp_server *server = arg;
a760 1
	int has_options;
d765 1
a765 1
	char		*mode = NULL, *option, *ccp;
d907 1
a907 1
	int		 fd, wmode, serrno;
d984 1
a984 1
	int c;
a1133 1
	ssize_t n;
@


1.1.1.1
log
@a persistent event driven tftp daemon.

because tftpd out of inetd doesnt cope with a lot of concurrent requests.

ok deraadt@@ krw@@ henning@@
@
text
@@
