head	1.39;
access;
symbols
	OPENBSD_6_1:1.39.0.6
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.2
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.32.0.6
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.4
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.2
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.10
	OPENBSD_5_0:1.31.0.8
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.6
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.4
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.30.0.4
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.29.0.8
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.6
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.4
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.27.0.4
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.2
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.26.0.12
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.10
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.8
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.6
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	OPENBSD_3_3:1.22.0.4
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.12
	OPENBSD_2_8:1.10.0.10
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.8
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.6
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2016.03.17.05.27.10;	author bentley;	state Exp;
branches;
next	1.38;
commitid	0afdJPZPXUfvItJV;

1.38
date	2016.01.12.23.35.13;	author tb;	state Exp;
branches;
next	1.37;
commitid	6TIpGjc6KPGjJcnt;

1.37
date	2015.08.20.22.46.32;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	bryBnuht7UhcZOWL;

1.36
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	Uu5nFG3wCl0LACBb;

1.35
date	2014.05.21.18.38.42;	author pascal;	state Exp;
branches;
next	1.34;

1.34
date	2013.11.24.21.32.32;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2013.10.27.18.49.25;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.03.04.42.48;	author stevesk;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.08.23.11.37;	author stevesk;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.07.21.12.11;	author stevesk;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.08.02.16.06;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.23.36.53;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.13.19.57.02;	author pjanzen;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.12.20.53.22;	author pjanzen;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.05.10.42.54;	author avsm;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.09.21.58.46;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.09.21.42.02;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.09.03.44.50;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.08.23.23.24;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.08.01.53.43;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.28.18.16.03;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.20.23.13.50;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.01.18.02.32;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.30.17.38.13;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.30.17.23.59;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.29.21.43.18;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.22.15.27.19;	author lebel;	state Exp;
branches;
next	1.10;

1.10
date	98.06.23.22.40.34;	author millert;	state Exp;
branches
	1.10.10.1
	1.10.12.1;
next	1.9;

1.9
date	98.02.27.11.33.41;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.23.22.12.10;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.17.09.14.13;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.17.16.10.52;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.10.25.19.38.20;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.04.05.41.50;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	95.11.22.10.15.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.04.25.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.40;	author deraadt;	state Exp;
branches;
next	;

1.10.10.1
date	2001.08.30.05.04.06;	author miod;	state Exp;
branches;
next	;

1.10.12.1
date	2001.08.29.22.15.59;	author jason;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Switch (non-curses, non-ksh) programs that use COLUMNS to a single idiom.

Previously behaviors were all over the map. This changes them to
use COLUMNS first, and either terminal width or a hardcoded value
(typically 80) as appropriate.

ok deraadt@@; man bits ok jmc@@
@
text
@/*	$OpenBSD: displayq.c,v 1.38 2016/01/12 23:35:13 tb Exp $	*/
/*	$NetBSD: displayq.c,v 1.21 2001/08/30 00:51:50 itojun Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/stat.h>

#include <ctype.h>
#include <errno.h>
#include <dirent.h>
#include <fcntl.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <vis.h>

#include "lp.h"
#include "lp.local.h"
#include "pathnames.h"

/*
 * Routines to display the state of the queue.
 */
#define JOBCOL	40		/* column for job # in -l format */
#define OWNCOL	7		/* start of Owner column in normal */
#define SIZCOL	62		/* start of Size column in normal */

/*
 * Stuff for handling job specifications
 */
extern int	requ[];		/* job number of spool entries */
extern int	requests;	/* # of spool requests */
extern char    *user[];	        /* users to process */
extern int	users;		/* # of users in user array */

static int	termwidth;
static int	col;		/* column on screen */
static char	current[NAME_MAX]; /* current file being printed */
static char	file[NAME_MAX];	/* print file name */
static int	first;		/* first file in ``files'' column? */
static int	lflag;		/* long output option */
static off_t	totsize;	/* total print job size in bytes */

static const char head0[] = "Rank   Owner      Job  Files";
static const char head1[] = "Total Size\n";

static void	alarmer(int);
static void	blankfill(int);
static void	dump(char *, char *, int);
static void	header(void);
static void	inform(char *, int);
static int	inlist(char *, char *);
static void	ldump(char *, char *, int);
static void	nodaemon(void);
static void	prank(int);
static void	show(char *, char *, int);

/*
 * Display the current state of the queue. Format = 1 if long format.
 */
void
displayq(int format)
{
	struct queue *q;
	int i, rank, nitems, fd, ret, len;
	char *cp, *ecp, *p;
	struct queue **queue;
	struct winsize win;
	struct stat statb;
	FILE *fp;

	termwidth = 0;
	if ((p = getenv("COLUMNS")) != NULL)
		termwidth = strtonum(p, 1, INT_MAX, NULL);
	if (termwidth == 0 && ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == 0 &&
	    win.ws_col > 0)
		termwidth = win.ws_col;
	if (termwidth == 0)
		termwidth = 80;

	if (termwidth < 60)
		termwidth = 60;

	lflag = format;
	totsize = 0;
	if ((i = cgetent(&bp, printcapdb, printer)) == -2)
		fatal("can't open printer description file");
	else if (i == -1)
		fatal("unknown printer");
	else if (i == -3)
		fatal("potential reference loop detected in printcap file");
	if (cgetstr(bp, DEFLP, &LP) < 0)
		LP = _PATH_DEFDEVLP;
	if (cgetstr(bp, "rp", &RP) < 0)
		RP = DEFLP;
	if (cgetstr(bp, "sd", &SD) < 0)
		SD = _PATH_DEFSPOOL;
	if (cgetstr(bp, "lo", &LO) < 0)
		LO = DEFLOCK;
	if (cgetstr(bp, "st", &ST) < 0)
		ST = DEFSTAT;
	cgetstr(bp, "rm", &RM);
	if ((cp = checkremote()) != NULL)
		printf("Warning: %s\n", cp);

	/*
	 * Print out local queue
	 * Find all the control files in the spooling directory
	 */
	PRIV_START;
	if (chdir(SD) < 0)
		fatal("cannot chdir to spooling directory");
	PRIV_END;
	if ((nitems = getq(&queue)) < 0)
		fatal("cannot examine spooling area");
	PRIV_START;
	ret = stat(LO, &statb);
	PRIV_END;
	if (ret >= 0) {
		if (statb.st_mode & S_IXUSR) {
			if (remote)
				printf("%s: ", host);
			printf("Warning: %s is down: ", printer);
			PRIV_START;
			fd = safe_open(ST, O_RDONLY|O_NOFOLLOW, 0);
			PRIV_END;
			if (fd >= 0 && flock(fd, LOCK_SH) == 0) {
				while ((i = read(fd, line, sizeof(line))) > 0)
					(void)fwrite(line, 1, i, stdout);
				(void)close(fd);	/* unlocks as well */
			} else
				putchar('\n');
		}
		if (statb.st_mode & S_IXGRP) {
			if (remote)
				printf("%s: ", host);
			printf("Warning: %s queue is turned off\n", printer);
		}
	}

	if (nitems) {
		PRIV_START;
		fd = safe_open(LO, O_RDONLY|O_NOFOLLOW, 0);
		PRIV_END;
		if (fd < 0 || (fp = fdopen(fd, "r")) == NULL) {
			if (fd >= 0)
				close(fd);
			nodaemon();
		} else {
			/* get daemon pid */
			cp = current;
			ecp = cp + sizeof(current) - 1;
			while ((i = getc(fp)) != EOF && i != '\n') {
				if (cp < ecp)
					*cp++ = i;
			}
			*cp = '\0';
			i = atoi(current);
			if (i <= 0) {
				ret = -1;
			} else {
				PRIV_START;
				ret = kill(i, 0);
				PRIV_END;
			}
			if (ret < 0 && errno != EPERM) {
				nodaemon();
			} else {
				/* read current file name */
				cp = current;
		    		ecp = cp + sizeof(current) - 1;
				while ((i = getc(fp)) != EOF && i != '\n') {
					if (cp < ecp)
						*cp++ = i;
				}
				*cp = '\0';
				/*
				 * Print the status file.
				 */
				if (remote)
					printf("%s: ", host);
				PRIV_START;
				fd = safe_open(ST, O_RDONLY|O_NOFOLLOW, 0);
				PRIV_END;
				if (fd >= 0 && flock(fd, LOCK_SH) == 0) {
					while ((i = read(fd, line, sizeof(line))) > 0)
						(void)fwrite(line, 1, i, stdout);
					(void)close(fd);	/* unlocks as well */
				} else
					putchar('\n');
			}
			(void)fclose(fp);
		}
		/*
		 * Now, examine the control files and print out the jobs to
		 * be done for each user.
		 */
		if (!lflag)
			header();
		/* The currently printed job is treated specially. */
		if (!remote && current[0] != '\0')
			inform(current, 0);
		for (i = 0, rank = 1; i < nitems; i++) {
			q = queue[i];
			if (remote || strcmp(current, q->q_name) != 0)
				inform(q->q_name, rank++);
			free(q);
		}
	}
	free(queue);
	if (!remote) {
		if (nitems == 0)
			puts("no entries");
		return;
	}

	/*
	 * Print foreign queue
	 * Note that a file in transit may show up in either queue.
	 */
	if (nitems)
		putchar('\n');
	(void)snprintf(line, sizeof(line), "%c%s", format + '\3', RP);
	cp = line;
	cp += strlen(cp);
	for (i = 0; i < requests && cp - line < sizeof(line) - 1; i++) {
		len = line + sizeof(line) - cp;
		if (snprintf(cp, len, " %d", requ[i]) >= len) {
			cp += strlen(cp);
			break;
		}
		cp += strlen(cp);
	}
	for (i = 0; i < users && cp - line < sizeof(line) - 1; i++) {
		len = line + sizeof(line) - cp;
		if (snprintf(cp, len, " %s", user[i]) >= len) {
			cp += strlen(cp);
			break;
		}
	}
	if (cp-line < sizeof(line) - 1)
		strlcat(line, "\n", sizeof(line));
	else
		line[sizeof(line) - 2] = '\n';
	fd = getport(RM, 0);
	if (fd < 0) {
		if (from != host)
			printf("%s: ", host);
		(void)printf("connection to %s is down\n", RM);
	}
	else {
		struct sigaction osa, nsa;
		char *visline;
		int n = 0;

		i = strlen(line);
		if (write(fd, line, i) != i)
			fatal("Lost connection");
		memset(&nsa, 0, sizeof(nsa));
		nsa.sa_handler = alarmer;
		sigemptyset(&nsa.sa_mask);
		nsa.sa_flags = 0;
		(void)sigaction(SIGALRM, &nsa, &osa);
		alarm(wait_time);
		if ((visline = malloc(4 * sizeof(line) + 1)) == NULL)
			fatal("Out of memory");
		while ((i = read(fd, line, sizeof(line))) > 0) {
			n = strvisx(visline, line, i, VIS_SAFE|VIS_NOSLASH);
			(void)fwrite(visline, 1, n, stdout);
			alarm(wait_time);
		}
		/* XXX some LPR implementations may not end stream with '\n' */
		if (n > 0 && visline[n-1] != '\n')
			putchar('\n');
		alarm(0);
		(void)sigaction(SIGALRM, &osa, NULL);
		free(visline);
		(void)close(fd);
	}
}

static void
alarmer(int s)
{
	/* nothing */
}

/*
 * Print a warning message if there is no daemon present.
 */
static void
nodaemon(void)
{
	if (remote)
		printf("\n%s: ", host);
	puts("Warning: no daemon present");
	current[0] = '\0';
}

/*
 * Print the header for the short listing format
 */
static void
header(void)
{
	printf(head0);
	col = strlen(head0)+1;
	blankfill(termwidth - (80 - SIZCOL));
	printf(head1);
}

static void
inform(char *cf, int rank)
{
	int fd, j;
	FILE *cfp = NULL;

	/*
	 * There's a chance the control file has gone away
	 * in the meantime; if this is the case just keep going
	 */
	PRIV_START;
	fd = safe_open(cf, O_RDONLY|O_NOFOLLOW, 0);
	PRIV_END;
	if (fd < 0 || (cfp = fdopen(fd, "r")) == NULL) {
		if (fd >= 0)
			close(fd);
		return;
	}

	j = 0;
	while (get_line(cfp)) {
		switch (line[0]) {
		case 'P': /* Was this file specified in the user's list? */
			if (!inlist(line+1, cf)) {
				fclose(cfp);
				return;
			}
			if (lflag) {
				printf("\n%s: ", line+1);
				col = strlen(line+1) + 2;
				prank(rank);
				blankfill(JOBCOL);
				printf(" [job %s]\n", cf+3);
			} else {
				col = 0;
				prank(rank);
				blankfill(OWNCOL);
				printf("%-10s %-3d  ", line+1, atoi(cf+3));
				col += 16;
				first = 1;
			}
			continue;
		default: /* some format specifer and file name? */
			if (line[0] < 'a' || line[0] > 'z')
				continue;
			if (j == 0 || strcmp(file, line+1) != 0)
				(void)strlcpy(file, line+1, sizeof(file));
			j++;
			continue;
		case 'N':
			show(line+1, file, j);
			file[0] = '\0';
			j = 0;
		}
	}
	fclose(cfp);
	if (!lflag) {
		blankfill(termwidth - (80 - SIZCOL));
		printf("%lld bytes\n", (long long)totsize);
		totsize = 0;
	}
}

static int
inlist(char *name, char *file)
{
	int *r, n;
	char **u, *cp;

	if (users == 0 && requests == 0)
		return(1);
	/*
	 * Check to see if it's in the user list
	 */
	for (u = user; u < &user[users]; u++)
		if (!strcmp(*u, name))
			return(1);
	/*
	 * Check the request list
	 */
	for (n = 0, cp = file+3; isdigit((unsigned char)*cp); )
		n = n * 10 + (*cp++ - '0');
	for (r = requ; r < &requ[requests]; r++)
		if (*r == n && !strcmp(cp, from))
			return(1);
	return(0);
}

static void
show(char *nfile, char *file, int copies)
{
	if (strcmp(nfile, " ") == 0)
		nfile = "(standard input)";
	if (lflag)
		ldump(nfile, file, copies);
	else
		dump(nfile, file, copies);
}

/*
 * Fill the line with blanks to the specified column
 */
static void
blankfill(int n)
{
	while (col++ < n)
		putchar(' ');
}

/*
 * Give the abbreviated dump of the file names
 */
static void
dump(char *nfile, char *file, int copies)
{
	int n, fill;
	struct stat lbuf;

	/*
	 * Print as many files as will fit
	 *  (leaving room for the total size)
	 */
	 fill = first ? 0 : 2;	/* fill space for ``, '' */
	 if (((n = strlen(nfile)) + col + fill) >=
	     (termwidth - (80 - SIZCOL)) - 4) {
		if (col < (termwidth - (80 - SIZCOL))) {
			printf(" ..."), col += 4;
			blankfill(termwidth - (80 - SIZCOL));
		}
	} else {
		if (first)
			first = 0;
		else
			printf(", ");
		printf("%s", nfile);
		col += n+fill;
	}
	PRIV_START;
	if (*file && !stat(file, &lbuf))
		totsize += copies * lbuf.st_size;
	PRIV_END;
}

/*
 * Print the long info about the file
 */
static void
ldump(char *nfile, char *file, int copies)
{
	struct stat lbuf;
	int ret;

	putchar('\t');
	if (copies > 1)
		printf("%-2d copies of %-19s", copies, nfile);
	else
		printf("%-32s", nfile);
	PRIV_START;
	ret = stat(file, &lbuf);
	PRIV_END;
	if (*file && !ret)
		printf(" %lld bytes", (long long)lbuf.st_size);
	else
		printf(" ??? bytes");
	putchar('\n');
}

/*
 * Print the job's rank in the queue,
 *   update col for screen management
 */
static void
prank(int n)
{
	char rline[100];
	static char *r[] = {
		"th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th"
	};

	if (n == 0) {
		printf("active");
		col += 6;
		return;
	}
	if ((n/10)%10 == 1)
		(void)snprintf(rline, sizeof(rline), "%dth", n);
	else
		(void)snprintf(rline, sizeof(rline), "%d%s", n, r[n%10]);
	col += strlen(rline);
	printf("%s", rline);
}
@


1.38
log
@Move prototypes of local functions from lp.h to the .c files and make
functions static if possible.  Move delay() to lpd/printjob.c and fix
an annoying typo.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.37 2015/08/20 22:46:32 deraadt Exp $	*/
d104 9
a112 8
	termwidth = 80;
	if (isatty(STDOUT_FILENO)) {
		if ((p = getenv("COLUMNS")) != NULL)
			termwidth = atoi(p);
		else if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == 0 &&
		    win.ws_col > 0)
			termwidth = win.ws_col;
	}
@


1.37
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.36 2015/01/16 06:40:17 deraadt Exp $	*/
d80 3
d84 5
d322 1
a322 1
void
d334 1
a334 1
void
d406 1
a406 1
int
d431 1
a431 1
void
d445 1
a445 1
void
d455 1
a455 1
void
d489 1
a489 1
void
d514 1
a514 1
void
@


1.36
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.35 2014/05/21 18:38:42 pascal Exp $	*/
d288 1
a288 1
		if ((visline = (char *)malloc(4 * sizeof(line) + 1)) == NULL)
@


1.35
log
@stat(2) on the spool file needs privileges.  Fixes file size reported by
lpq -l.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.34 2013/11/24 21:32:32 deraadt Exp $	*/
a32 1
#include <sys/param.h>
d41 1
@


1.34
log
@more ctype cleanups
checked by jca
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.33 2013/10/27 18:49:25 guenther Exp $	*/
d485 1
d492 4
a495 1
	if (*file && !stat(file, &lbuf))
@


1.33
log
@If a constant string needs a name, use a static const array instead of a
pointer or non-const array, as that minimizes the symbols, maximizes the
placement into read-only memory, and avoids warnings from gcc -Wformat=2
when they're used as format strings.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.32 2012/03/04 04:05:15 fgsch Exp $	*/
d415 1
a415 1
	for (n = 0, cp = file+3; isdigit(*cp); )
@


1.32
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.31 2009/10/27 23:59:51 deraadt Exp $	*/
d76 2
a77 2
static const char *head0 = "Rank   Owner      Job  Files";
static const char *head1 = "Total Size\n";
@


1.31
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.30 2009/03/03 04:42:48 stevesk Exp $	*/
d355 1
a355 1
	while (getline(cfp)) {
@


1.30
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.29 2007/04/08 23:11:37 stevesk Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)displayq.c	8.4 (Berkeley) 4/28/95";
#else
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.29 2007/04/08 23:11:37 stevesk Exp $";
#endif
#endif /* not lint */
@


1.29
log
@I have an HP LaserJet (P2015dn) whose LPR implementation may not end
the send queue state command stream with '\n'; check for this case
and print '\n' if needed.  Without this you may see something like:

$ lpq
queue empty$

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.28 2007/04/07 21:12:11 stevesk Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.28 2007/04/07 21:12:11 stevesk Exp $";
d129 1
a129 1
	if (cgetstr(bp,"lo", &LO) < 0)
@


1.28
log
@trailing "\n" not needed in fatal(); ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.27 2006/04/08 02:16:06 ray Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.27 2006/04/08 02:16:06 ray Exp $";
d285 1
d299 2
a300 2
			i = strvisx(visline, line, i, VIS_SAFE|VIS_NOSLASH);
			(void)fwrite(visline, 1, i, stdout);
d303 3
@


1.27
log
@Plug memory leak when nitems == 0.

From NetBSD from Coverity CID 1752.

OK jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.26 2003/06/02 23:36:53 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.26 2003/06/02 23:36:53 millert Exp $";
d146 1
a146 1
		fatal("cannot examine spooling area\n");
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.25 2003/05/13 19:57:02 pjanzen Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.25 2003/05/13 19:57:02 pjanzen Exp $";
a239 1
		free(queue);
d241 1
@


1.25
log
@Don't reformat output beyond a minimum terminal width (60).
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.24 2003/05/12 20:53:22 pjanzen Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.24 2003/05/12 20:53:22 pjanzen Exp $";
@


1.24
log
@Do vis()-cleaning when displaying the print queue.
ok deraadt@@, ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.23 2003/04/05 10:42:54 avsm Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.23 2003/04/05 10:42:54 avsm Exp $";
d116 2
@


1.23
log
@trivial strlcat, tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.22 2002/06/09 21:58:46 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.22 2002/06/09 21:58:46 millert Exp $";
d59 1
d286 1
d297 2
d300 2
a301 1
			(void)fwrite(line, 1, i, stdout);
d306 1
@


1.22
log
@Better fix for correct queue printing when things have been moved around.
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.21 2002/06/09 21:42:02 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.21 2002/06/09 21:42:02 millert Exp $";
d274 1
a274 1
		strcat(line, "\n");
@


1.21
log
@Don't print jobs in transit to a remote queue as being "active"
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.20 2002/06/09 03:44:50 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.20 2002/06/09 03:44:50 millert Exp $";
d100 1
a100 1
	int i, nitems, fd, ret, len;
d232 4
a235 1
		for (i = 0; i < nitems; i++) {
d237 2
a238 10
			/*
			 * If this is a local job that is currently
			 * printing, use job #0 which inform() will
			 * convert to "active".  Otherwise, we start
			 * counting from 1...
			 */
			if (!remote && strcmp(current, q->q_name) == 0)
				inform(q->q_name, 0);
			else
				inform(q->q_name, i + 1);
@


1.20
log
@o Kill "garbage" global (unused)
o Kill "rank" global (doesn't need to be global)
o Make inform() static (local to displayq.c)
o Pass in rank to inform() based on index within sorted mtime array
o Simplify compar()
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.19 2002/06/08 23:23:24 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.19 2002/06/08 23:23:24 millert Exp $";
d234 7
a240 2
			/* active == 0, otherwise count starts at 1 */
			if (strcmp(current, q->q_name) == 0)
@


1.19
log
@o Replace some hard-coded octal constants w/ S_I*
o Remove some unneeded casts to char * when calling free()
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.18 2002/06/08 01:53:43 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.18 2002/06/08 01:53:43 millert Exp $";
a83 1
static int	garbage;	/* # of garbage cf files */
a84 1
static int	rank;		/* order to be printed (-1=none, 0=active) */
d91 1
a117 1
	rank = -1;
d234 5
a238 1
			inform(q->q_name);
d335 2
a336 2
void
inform(char *cf)
a353 4
	if (rank < 0)
		rank = 0;
	if (remote || garbage || strcmp(cf, current))
		rank++;
@


1.18
log
@Remove setuid root from lp*.  lpr needs to be setuid daemon so the
files it creates are not owned by the user spooling them but the
others (lpc, lpq, lprm) can get away with setgid daemon.  lpd runs
as user daemon for most things, only changing its uid to 0 for
things that must be done as root.

For the time being, don't require connections to come from a reserved
port since lpq/lpr/lprm can't acquire that w/o setuid root.  In the
near future we will have a mechanism for select non-root processes
to grab reserved ports.

The upshot of this is that spool directories must be writable by
group daemon and the files within the spool dirs must be owned by
daemon.
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.17 2002/05/28 18:16:03 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.17 2002/05/28 18:16:03 millert Exp $";
d154 1
a154 1
		if (statb.st_mode & 0100) {
d168 1
a168 1
		if (statb.st_mode & 010) {
@


1.17
log
@Remove useless sigaddset()
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.16 2002/05/20 23:13:50 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.16 2002/05/20 23:13:50 millert Exp $";
d46 2
a48 1
#include <sys/file.h>
d50 4
a54 4
#include <fcntl.h>
#include <sys/ioctl.h>
#include <dirent.h>
#include <unistd.h>
d58 2
a59 1
#include <ctype.h>
d144 1
a144 1
	seteuid(euid);
d147 1
a147 1
	seteuid(uid);
d150 1
a150 1
	seteuid(euid);
d152 1
a152 1
	seteuid(uid);
d158 4
a161 5
			seteuid(euid);
			fd = open(ST, O_RDONLY);
			seteuid(uid);
			if (fd >= 0) {
				(void)flock(fd, LOCK_SH);
d176 6
a181 4
		seteuid(euid);
		fp = fopen(LO, "r");
		seteuid(uid);
		if (fp == NULL)
d183 1
a183 1
		else {
d196 1
a196 1
				seteuid(euid);
d198 1
a198 1
				seteuid(uid);
d200 1
a200 1
			if (ret < 0) {
d216 4
a219 5
				seteuid(euid);
				fd = open(ST, O_RDONLY);
				seteuid(uid);
				if (fd >= 0) {
					(void)flock(fd, LOCK_SH);
d336 2
a337 2
	int j;
	FILE *cfp;
d343 6
a348 2
	seteuid(euid);
	if ((cfp = fopen(cf, "r")) == NULL)
d350 1
a350 1
	seteuid(uid);
d474 1
a474 1
	seteuid(euid);
d477 1
a477 1
	seteuid(uid);
@


1.16
log
@Pull in useful bits from NetBSD and make our lp* easier to diff and
do some minor cleanup of my own:

o IPv6 support
o ANSI function headers
o use getopt()
o synce usage() with man pages
o passes -Wall on both 32bit and 64bit platforms
o add an option to set the max number of children lpd will fork off
o add an lpd option to bind to specific addresses instead of INADDR_ANY.
o allow user to specify how long to wait for a connection to remote servers
o more strlcpy() and snprintf() usage
o Use FOO_FILENO constants instead of hard-coding 0-2
o Add some keeps to man the page SYNOPSIS to avoid options being split
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.14 2001/08/30 17:38:13 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.14 2001/08/30 17:38:13 millert Exp $";
a287 1
		sigaddset(&nsa.sa_mask, SIGALRM);
@


1.15
log
@displayq to honor the terminal width; millert@@ ok
@
text
@d2 1
a76 2
extern uid_t	uid, euid;

d85 4
a88 1
static long	totsize;	/* total print job size in bytes */
d90 1
a90 2
static char	*head0 = "Rank   Owner      Job  Files";
static char	*head1 = "Total Size\n";
d96 1
a96 2
displayq(format)
	int format;
d124 1
a124 1
	if (cgetstr(bp, "lp", &LP) < 0)
d135 1
a135 1
	if ((cp = checkremote()))
d160 1
a160 1
				(void) flock(fd, LOCK_SH);
d162 2
a163 2
					(void) fwrite(line, 1, i, stdout);
				(void) close(fd);	/* unlocks as well */
d217 1
a217 1
					(void) flock(fd, LOCK_SH);
d219 2
a220 2
						(void) fwrite(line, 1, i, stdout);
					(void) close(fd);	/* unlocks as well */
d224 1
a224 1
			(void) fclose(fp);
d251 1
a251 1
	(void) snprintf(line, sizeof line, "%c%s", format + '\3', RP);
d254 2
a255 2
	for (i = 0; i < requests && cp-line < sizeof(line) - 1; i++) {
		len = line + sizeof line - cp;
d262 2
a263 2
	for (i = 0; i < users && cp-line < sizeof(line) - 1; i++) {
		len = line + sizeof line - cp;
d269 1
a269 1
	if (cp-line < sizeof(line) - 1) {
d271 2
a272 3
	} else {
		line[sizeof line-2] = '\n';
	}
d277 1
a277 1
		printf("connection to %s is down\n", RM);
d280 2
d285 14
a298 3
		while ((i = read(fd, line, sizeof(line))) > 0)
			(void) fwrite(line, 1, i, stdout);
		(void) close(fd);
d302 6
d312 1
a312 1
nodaemon()
d324 1
a324 1
header()
d333 1
a333 2
inform(cf)
	char *cf;
d377 2
a378 3
			if (j == 0 || strcmp(file, line+1) != 0) {
				(void) strlcpy(file, line+1, sizeof(file));
			}
d390 1
a390 1
		printf("%ld bytes\n", totsize);
d396 1
a396 2
inlist(name, file)
	char *name, *file;
d421 1
a421 3
show(nfile, file, copies)
	char *nfile, *file;
	int copies;
d435 1
a435 2
blankfill(n)
	int n;
d445 1
a445 3
dump(nfile, file, copies)
	char *nfile, *file;
	int copies;
d479 1
a479 3
ldump(nfile, file, copies)
	char *nfile, *file;
	int copies;
d489 1
a489 1
		printf(" %qd bytes", lbuf.st_size);
d500 1
a500 2
prank(n)
	int n;
@


1.14
log
@o kill register
o add const to rcsid and copyright strings
o placate -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.13 2001/08/30 17:23:59 millert Exp $	*/
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: displayq.c,v 1.13 2001/08/30 17:23:59 millert Exp $";
d50 1
d78 1
d100 1
a100 1
	char *cp, *ecp;
d102 1
d106 9
d179 1
a179 1
			warn();
d198 1
a198 1
				warn();
d294 1
a294 1
warn()
d310 1
a310 1
	blankfill(SIZCOL);
d373 1
a373 1
		blankfill(SIZCOL);
d437 1
a437 1
	short n, fill;
d445 3
a447 2
	 if (((n = strlen(nfile)) + col + fill) >= SIZCOL-4) {
		if (col < SIZCOL) {
d449 1
a449 1
			blankfill(SIZCOL);
@


1.13
log
@Use NAME_MAX, not MAXPATHLEN for buffer sizes since they are not
full paths (cannot contain a slash).  From discussion with drosih@@rpi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.12 2001/08/29 21:43:18 millert Exp $	*/
d38 1
a38 1
static char sccsid[] = "@@(#)displayq.c	8.4 (Berkeley) 4/28/95";
d40 1
a40 1
static char rcsid[] = "$OpenBSD: displayq.c,v 1.12 2001/08/29 21:43:18 millert Exp $";
d96 3
a98 3
	register struct queue *q;
	register int i, nitems, fd, ret, len;
	register char	*cp, *ecp;
d306 1
a306 1
	register int j;
d371 2
a372 2
	register int *r, n;
	register char **u, *cp;
d395 1
a395 1
	register char *nfile, *file;
d411 1
a411 1
	register int n;
d425 1
a425 1
	register short n, fill;
@


1.12
log
@Fix buffer oflow reading from queue file.  While we are at it, crank
the size of buffers that can hold filenames to MAXPATHLEN.
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.11 2001/06/22 15:27:19 lebel Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: displayq.c,v 1.11 2001/06/22 15:27:19 lebel Exp $";
d78 2
a79 2
static char	current[MAXPATHLEN]; /* current file being printed */
static char	file[MAXPATHLEN]; /* print file name */
@


1.11
log
@use strlcpy vs strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.10 1998/06/23 22:40:34 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: displayq.c,v 1.10 1998/06/23 22:40:34 millert Exp $";
d78 2
a79 2
static char	current[40];	/* current file being printed */
static char	file[132];	/* print file name */
d98 1
a98 1
	register char	*cp;
d171 5
a175 2
			while ((i = getc(fp)) != EOF && i != '\n')
				*cp++ = i;
d190 5
a194 2
				while ((i = getc(fp)) != EOF && i != '\n')
					*cp++ = i;
@


1.10
log
@Fix snprintf return value usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.9 1998/02/27 11:33:41 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: displayq.c,v 1.9 1998/02/27 11:33:41 deraadt Exp $";
d343 1
a343 2
				(void) strncpy(file, line+1, sizeof(file) - 1);
				file[sizeof(file) - 1] = '\0';
@


1.10.10.1
log
@Errata #32 (millert):
A security hole exists in lpd(8) that may allow an attacker with line
printer access to gain root privileges. A machine must be running lpd
to be vulnerable (OpenBSD does not start lpd by default). Only machines
with line printer access (ie: listed in either /etc/hosts.lpd or
/etc/hosts.equiv) may be used to mount an attack.
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.10 1998/06/23 22:40:34 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: displayq.c,v 1.10 1998/06/23 22:40:34 millert Exp $";
d78 2
a79 2
static char	current[MAXPATHLEN]; /* current file being printed */
static char	file[MAXPATHLEN]; /* print file name */
d98 1
a98 1
	register char	*cp, *ecp;
d171 2
a172 5
			ecp = cp + sizeof(current) - 1;
			while ((i = getc(fp)) != EOF && i != '\n') {
				if (cp < ecp)
					*cp++ = i;
			}
d187 2
a188 5
		    		ecp = cp + sizeof(current) - 1;
				while ((i = getc(fp)) != EOF && i != '\n') {
					if (cp < ecp)
						*cp++ = i;
				}
@


1.10.12.1
log
@MFC Fix (millert):
Fix buffer oflow reading from queue file.  While we are at it, crank
the size of buffers that can hold filenames to MAXPATHLEN.
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.10 1998/06/23 22:40:34 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: displayq.c,v 1.10 1998/06/23 22:40:34 millert Exp $";
d78 2
a79 2
static char	current[MAXPATHLEN]; /* current file being printed */
static char	file[MAXPATHLEN]; /* print file name */
d98 1
a98 1
	register char	*cp, *ecp;
d171 2
a172 5
			ecp = cp + sizeof(current) - 1;
			while ((i = getc(fp)) != EOF && i != '\n') {
				if (cp < ecp)
					*cp++ = i;
			}
d187 2
a188 5
		    		ecp = cp + sizeof(current) - 1;
				while ((i = getc(fp)) != EOF && i != '\n') {
					if (cp < ecp)
						*cp++ = i;
				}
@


1.9
log
@be more paranoid.
By the way, the lp* tools are in need of a full test sometime in the
next two weeks.  I want to hear from someone who is running all of them
that they work 100% fine.  I do not own a printer, so I'm going to rely
on someone out there to take care of this..
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.8 1997/07/23 22:12:10 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: displayq.c,v 1.8 1997/07/23 22:12:10 deraadt Exp $";
d238 1
a238 1
		if (snprintf(cp, len, " %d", requ[i]) > len) {
d246 1
a246 1
		if (snprintf(cp, len, " %s", user[i]) > len) {
@


1.8
log
@1 byte oflows; millert
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.7 1997/07/17 09:14:13 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: displayq.c,v 1.7 1997/07/17 09:14:13 deraadt Exp $";
d97 1
a97 1
	register int i, nitems, fd, ret;
d235 7
a241 1
	for (i = 0; i < requests && cp-line+10 < sizeof(line) - 1; i++) {
a242 1
		(void) sprintf(cp, " %d", requ[i]);
d244 11
a254 5
	for (i = 0; i < users && cp-line+1+strlen(user[i]) <
	    sizeof(line) - 1; i++) {
		cp += strlen(cp);
		*cp++ = ' ';
		(void) strcpy(cp, user[i]);
a255 1
	strcat(line, "\n");
@


1.7
log
@Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.6 1997/01/17 16:10:52 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: displayq.c,v 1.6 1997/01/17 16:10:52 millert Exp $";
d235 1
a235 1
	for (i = 0; i < requests && cp-line+10 < sizeof line; i++) {
d240 1
a240 1
	    sizeof line; i++) {
@


1.6
log
@Possible buf oflow.
@
text
@d1 1
a1 1
/*	$OpenBSD: displayq.c,v 1.5.2.1 1995/11/19 00:41:30 pk Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: $";
d123 1
a123 1
	if (cp = checkremote())
@


1.5
log
@proactive bounds checking; help from millert
@
text
@d1 2
a2 1
/*	$NetBSD: displayq.c,v 1.5.2.1 1995/11/19 00:41:30 pk Exp $	*/
d37 1
d39 3
d332 4
a335 2
			if (j == 0 || strcmp(file, line+1) != 0)
				(void) strcpy(file, line+1);
@


1.4
log
@Integrated 4.4Lite2 source
Fixed potential problem pointed out by bitblt
@
text
@d228 1
a228 1
	(void) sprintf(line, "%c%s", format + '\3', RP);
d230 1
a230 1
	for (i = 0; i < requests; i++) {
d234 2
a235 1
	for (i = 0; i < users; i++) {
@


1.3
log
@from netbsd; {} mania
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)displayq.c	8.1 (Berkeley) 6/6/93";
d41 1
d136 1
a136 1
			if (sendtorem)
d151 1
a151 1
			if (sendtorem)
d166 2
a167 2
			while ((*cp = getc(fp)) != EOF && *cp != '\n')
				cp++;
d182 2
a183 2
				while ((*cp = getc(fp)) != EOF && *cp != '\n')
					cp++;
d188 1
a188 1
				if (sendtorem)
d216 1
a216 1
	if (!sendtorem) {
d240 1
a240 1
	fd = getport(RM);
d262 1
a262 1
	if (sendtorem)
d298 1
a298 1
	if (sendtorem || garbage || strcmp(cf, current))
@


1.2
log
@lprm failed to delete all files; from thomas@@cevis.uni-Bremen.de; netbsd pr#1756
@
text
@d1 1
d169 1
a169 1
			if (i <= 0)
d171 1
a171 1
			else {
d176 1
a176 1
			if (ret < 0)
d178 1
a178 1
			else {
@


1.1
log
@Initial revision
@
text
@d168 3
a170 1
			if (i <= 0) {
d175 3
a177 2
				ret = -1;
			if (ret < 0) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

