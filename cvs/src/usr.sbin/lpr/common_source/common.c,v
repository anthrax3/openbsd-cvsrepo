head	1.41;
access;
symbols
	OPENBSD_6_2_BASE:1.41
	OPENBSD_6_1:1.41.0.6
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.41.0.2
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.38.0.6
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.35.0.6
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.34.0.6
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.4
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.2
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.10
	OPENBSD_5_0:1.33.0.8
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.6
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.10
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.6
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.4
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.29.0.10
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.8
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.29.0.6
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.4
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.26.0.4
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.9.0.10
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2016.02.29.17.26.01;	author jca;	state Exp;
branches;
next	1.40;
commitid	aNWKwmYdfVagOC9V;

1.40
date	2016.01.12.23.35.13;	author tb;	state Exp;
branches;
next	1.39;
commitid	6TIpGjc6KPGjJcnt;

1.39
date	2015.08.20.22.46.32;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	bryBnuht7UhcZOWL;

1.38
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	Uu5nFG3wCl0LACBb;

1.37
date	2014.11.02.13.56.55;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	OS5fBmmjD243yRq8;

1.36
date	2014.10.16.04.17.48;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	60uZuoMIjsfCuZSC;

1.35
date	2013.12.10.16.38.04;	author naddy;	state Exp;
branches;
next	1.34;

1.34
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.02.15.19.38;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.03.16.20.03.48;	author stevesk;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.13.15.09.51;	author stevesk;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.17.02.31.30;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2004.09.28.20.26.27;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2004.09.28.15.54.50;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.26.06.01.41;	author pvalchev;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.23.36.53;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.07.22.55.50;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.13.06.48.40;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.09.03.56.28;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.09.03.44.50;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.08.18.19.34;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.08.03.35.48;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.08.01.53.43;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.20.23.13.50;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.28.03;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.06.03.12.30;	author ericj;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.23.03.58.17;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.30.17.38.13;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.05.16.59.49;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.04.13.10.14;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.06.28.02.22.13;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	98.02.15.15.51.48;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.07.25.20.12.11;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.07.24.01.10.33;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.07.19.07.11.41;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.16.11.35;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.10.25.19.38.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.07.04.05.41.49;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.40;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Move ckqueue() to common_source/common.c

Patch from Chris Bennett, ok tb@@
@
text
@/*	$OpenBSD: common.c,v 1.40 2016/01/12 23:35:13 tb Exp $	*/
/*	$NetBSD: common.c,v 1.21 2000/08/09 14:28:50 itojun Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/time.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <stdarg.h>
#include <ifaddrs.h>
#include "lp.h"
#include "pathnames.h"

/*
 * Routines and data common to all the line printer functions.
 */

char	*AF;		/* accounting file */
long	 BR;		/* baud rate if lp is a tty */
char	*CF;		/* name of cifplot filter (per job) */
char	*DF;		/* name of tex filter (per job) */
long	 DU;		/* daemon user-id */
char	*FF;		/* form feed string */
char	*GF;		/* name of graph(1G) filter (per job) */
long	 HL;		/* print header last */
char	*IF;		/* name of input filter (created per job) */
char	*LF;		/* log file for error messages */
char	*LO;		/* lock file name */
char	*LP;		/* line printer device name */
long	 MC;		/* maximum number of copies allowed */
char	*MS;		/* stty flags to set if lp is a tty */
long	 MX;		/* maximum number of blocks to copy */
char	*NF;		/* name of ditroff filter (per job) */
char	*OF;		/* name of output filter (created once) */
long	 PL;		/* page length */
long	 PW;		/* page width */
long	 PX;		/* page width in pixels */
long	 PY;		/* page length in pixels */
char	*RF;		/* name of fortran text filter (per job) */
char    *RG;		/* restricted group */
char	*RM;		/* remote machine name */
char	*RP;		/* remote printer name */
long	 RS;		/* restricted to those with local accounts */
long	 RW;		/* open LP for reading and writing */
long	 SB;		/* short banner instead of normal header */
long	 SC;		/* suppress multiple copies */
char	*SD;		/* spool directory */
long	 SF;		/* suppress FF on each print job */
long	 SH;		/* suppress header page */
char	*ST;		/* status file name */
char	*TF;		/* name of troff filter (per job) */
char	*TR;		/* trailer string to be output when Q empties */
char	*VF;		/* name of vplot filter (per job) */

char	line[BUFSIZ];
int	remote;		/* true if sending files to a remote host */

static int compar(const void *, const void *);

/*
 * Create a TCP connection to host "rhost" at port "rport".
 * If rport == 0, then use the printer service port.
 * Most of this code comes from rcmd.c.
 */
int
getport(char *rhost, int rport)
{
	struct addrinfo hints, *res, *r;
	u_int timo = 1;
	int s, lport = IPPORT_RESERVED - 1;
	int error;
	int refuse, trial;
	char pbuf[NI_MAXSERV];

	/*
	 * Get the host address and port number to connect to.
	 */
	if (rhost == NULL)
		fatal("no remote host to connect to");
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	if (rport)
		snprintf(pbuf, sizeof(pbuf), "%d", rport);
	else
		snprintf(pbuf, sizeof(pbuf), "printer");
	siginterrupt(SIGINT, 1);
	error = getaddrinfo(rhost, pbuf, &hints, &res);
	siginterrupt(SIGINT, 0);
	if (error)
		fatal("printer/tcp: %s", gai_strerror(error));

	/*
	 * Try connecting to the server.
	 */
retry:
	s = -1;
	refuse = trial = 0;
	for (r = res; r; r = r->ai_next) {
		trial++;
retryport:
		PRIV_START;
		s = rresvport_af(&lport, r->ai_family);
		PRIV_END;
		if (s < 0) {
			/* fall back to non-privileged port */
			if (errno != EACCES ||
			    (s = socket(r->ai_family, SOCK_STREAM, 0)) < 0) {
				freeaddrinfo(res);
				return(-1);
			}
		}
		siginterrupt(SIGINT, 1);
		if (connect(s, r->ai_addr, r->ai_addrlen) < 0) {
			error = errno;
			siginterrupt(SIGINT, 0);
			(void)close(s);
			s = -1;
			errno = error;
			if (errno == EADDRINUSE) {
				lport--;
				goto retryport;
			} else if (errno == ECONNREFUSED)
				refuse++;
			continue;
		} else {
			siginterrupt(SIGINT, 0);
			break;
		}
	}
	if (s < 0 && trial == refuse && timo <= 16) {
		sleep(timo);
		timo *= 2;
		goto retry;
	}
	if (res)
		freeaddrinfo(res);

	/* Don't worry if we get an error from setsockopt(). */
	trial = 1;
	setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &trial, sizeof(trial));

	return(s);
}

/*
 * Getline reads a line from the control file cfp, removes tabs, converts
 *  new-line to null and leaves it in line.
 * Returns 0 at EOF or the number of characters read.
 */
int
get_line(FILE *cfp)
{
	int linel = 0;
	char *lp = line;
	int c;

	while ((c = getc(cfp)) != '\n' && linel+1<sizeof(line)) {
		if (c == EOF)
			return(0);
		if (c == '\t') {
			do {
				*lp++ = ' ';
				linel++;
			} while ((linel & 07) != 0 && linel+1 < sizeof(line));
			continue;
		}
		*lp++ = c;
		linel++;
	}
	*lp++ = '\0';
	return(linel);
}

/*
 * Scan the current directory and make a list of daemon files sorted by
 * creation time.
 * Return the number of entries and a pointer to the list.
 */
int
getq(struct queue ***namelist)
{
	struct dirent *d;
	struct queue *q, **queue = NULL;
	size_t nitems = 0, arraysz;
	struct stat stbuf;
	DIR *dirp;

	PRIV_START;
	dirp = opendir(SD);
	PRIV_END;
	if (dirp == NULL)
		return(-1);
	if (fstat(dirfd(dirp), &stbuf) < 0)
		goto errdone;

	/*
	 * Estimate the array size by taking the size of the directory file
	 * and dividing it by a multiple of the minimum size entry. 
	 */
	arraysz = (stbuf.st_size / 24);
	queue = calloc(arraysz, sizeof(struct queue *));
	if (queue == NULL)
		goto errdone;

	while ((d = readdir(dirp)) != NULL) {
		if (d->d_name[0] != 'c' || d->d_name[1] != 'f')
			continue;	/* daemon control files only */
		PRIV_START;
		if (stat(d->d_name, &stbuf) < 0) {
			PRIV_END;
			continue;	/* Doesn't exist */
		}
		PRIV_END;
		q = malloc(sizeof(struct queue));
		if (q == NULL)
			goto errdone;
		q->q_time = stbuf.st_mtime;
		strlcpy(q->q_name, d->d_name, sizeof(q->q_name));

		/*
		 * Check to make sure the array has space left and
		 * realloc the maximum size.
		 */
		if (nitems == arraysz) {
			struct queue **newqueue;
			newqueue = reallocarray(queue,
			    arraysz, 2 * sizeof(struct queue *));
			if (newqueue == NULL) {
				free(q);
				goto errdone;
			}
			arraysz *= 2;
			queue = newqueue;
		}
		queue[nitems++] = q;
	}
	closedir(dirp);
	if (nitems)
		qsort(queue, nitems, sizeof(struct queue *), compar);
	*namelist = queue;
	return(nitems);

errdone:
	if (queue != NULL) {
		while (nitems--)
			free(queue[nitems]);
		free(queue);
	}
	closedir(dirp);
	return(-1);
}

/*
 * Compare modification times.
 */
static int
compar(const void *v1, const void *v2)
{
	struct queue *p1 = *(struct queue **)v1;
	struct queue *p2 = *(struct queue **)v2;

	return(p1->q_time - p2->q_time);
}

/*
 * Figure out whether the local machine is the same
 * as the remote machine (RM) entry (if it exists).
 */
char *
checkremote(void)
{
	char lname[NI_MAXHOST], rname[NI_MAXHOST];
	struct addrinfo hints, *res, *res0;
	static char errbuf[128];
	int error;
	struct ifaddrs *ifap, *ifa;
	const int niflags = NI_NUMERICHOST;
#ifdef __KAME__
	struct sockaddr_in6 sin6;
	struct sockaddr_in6 *sin6p;
#endif

	remote = 0;	/* assume printer is local on failure */

	if (RM == NULL || *RM == '\0')
		return NULL;

	/* get the local interface addresses */
	siginterrupt(SIGINT, 1);
	if (getifaddrs(&ifap) < 0) {
		(void)snprintf(errbuf, sizeof(errbuf),
		    "unable to get local interface address: %s",
		    strerror(errno));
		siginterrupt(SIGINT, 0);
		return errbuf;
	}
	siginterrupt(SIGINT, 0);

	/* get the remote host addresses (RM) */
	memset(&hints, 0, sizeof(hints));
	hints.ai_flags = AI_CANONNAME;
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	res = NULL;
	siginterrupt(SIGINT, 1);
	error = getaddrinfo(RM, NULL, &hints, &res0);
	siginterrupt(SIGINT, 0);
	if (error) {
		(void)snprintf(errbuf, sizeof(errbuf),
		    "unable to resolve remote machine %s: %s",
		    RM, gai_strerror(error));
		freeifaddrs(ifap);
		return errbuf;
	}

	remote = 1;	/* assume printer is remote */

	for (res = res0; res; res = res->ai_next) {
		siginterrupt(SIGINT, 1);
		error = getnameinfo(res->ai_addr, res->ai_addrlen,
		    rname, sizeof(rname), NULL, 0, niflags);
		siginterrupt(SIGINT, 0);
		if (error != 0)
			continue;
		for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
#ifdef __KAME__
			sin6p = (struct sockaddr_in6 *)ifa->ifa_addr;
			if (ifa->ifa_addr->sa_family == AF_INET6 &&
			    ifa->ifa_addr->sa_len == sizeof(sin6) &&
			    IN6_IS_ADDR_LINKLOCAL(&sin6p->sin6_addr) &&
			    *(u_int16_t *)&sin6p->sin6_addr.s6_addr[2]) {
				/* kame scopeid hack */
				memcpy(&sin6, ifa->ifa_addr, sizeof(sin6));
				sin6.sin6_scope_id =
				    ntohs(*(u_int16_t *)&sin6p->sin6_addr.s6_addr[2]);
				sin6.sin6_addr.s6_addr[2] = 0;
				sin6.sin6_addr.s6_addr[3] = 0;
				siginterrupt(SIGINT, 1);
				error = getnameinfo((struct sockaddr *)&sin6,
				    sin6.sin6_len, lname, sizeof(lname),
				    NULL, 0, niflags);
				siginterrupt(SIGINT, 0);
				if (error != 0)
					continue;
			} else
#endif
			siginterrupt(SIGINT, 1);
			error = getnameinfo(ifa->ifa_addr,
			    ifa->ifa_addr->sa_len, lname, sizeof(lname), NULL,
			    0, niflags);
			siginterrupt(SIGINT, 0);
			if (error != 0)
				continue;

			if (strcmp(rname, lname) == 0) {
				remote = 0;
				goto done;
			}
		}
	}
done:
	freeaddrinfo(res0);
	freeifaddrs(ifap);
	return NULL;
}

__dead void
fatal(const char *msg, ...)
{
	extern char *__progname;
	va_list ap;

	va_start(ap, msg);
	if (from != host)
		(void)printf("%s: ", host);
	(void)printf("%s: ", __progname);
	if (printer)
		(void)printf("%s: ", printer);
	(void)vprintf(msg, ap);
	va_end(ap);
	(void)putchar('\n');
	exit(1);
}

int
safe_open(const char *path, int flags, mode_t mode)
{
	int fd, serrno;
	struct stat stbuf;

	if ((fd = open(path, flags|O_NONBLOCK, mode)) < 0 ||
	    fstat(fd, &stbuf) < 0) {
		if (fd >= 0) {
			serrno = errno;
			close(fd);
			errno = serrno;
		}
		return (-1);
	}
	if (!S_ISREG(stbuf.st_mode)) {
		close(fd);
		errno = EACCES;
		return (-1);
	}
	if (mode)
		(void)fchmod(fd, mode);
	return (fd);
}

/*
 * Make sure there's some work to do before forking off a child - lpd
 * Check to see if anything in queue - lpq
 */
int
ckqueue(char *cap)
{
	struct dirent *d;
	DIR *dirp;
	char *spooldir;

	if (cgetstr(cap, "sd", &spooldir) >= 0) {
		dirp = opendir(spooldir);
		free(spooldir);
	} else
		dirp = opendir(_PATH_DEFSPOOL);

	if (dirp == NULL)
		return (-1);
	while ((d = readdir(dirp)) != NULL) {
		if (d->d_name[0] == 'c' && d->d_name[1] == 'f') {
			closedir(dirp);
			return (1);		/* found a cf file */
		}
	}
	closedir(dirp);
	return (0);
}
@


1.40
log
@Move prototypes of local functions from lp.h to the .c files and make
functions static if possible.  Move delay() to lpd/printjob.c and fix
an annoying typo.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.39 2015/08/20 22:46:32 deraadt Exp $	*/
d455 29
@


1.39
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.38 2015/01/16 06:40:17 deraadt Exp $	*/
a411 13
}

/* sleep n milliseconds */
void
delay(int n)
{
	struct timespec tdelay;

	if (n <= 0 || n > 10000)
		fatal("unreasonable delay period (%d)", n);
	tdelay.tv_sec = n / 1000;
	tdelay.tv_nsec = n * 1000000 % 1000000000;
	nanosleep(&tdelay, NULL);
@


1.38
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.37 2014/11/02 13:56:55 deraadt Exp $	*/
d248 1
a248 1
	queue = (struct queue **)calloc(arraysz, sizeof(struct queue *));
d261 1
a261 1
		q = (struct queue *)malloc(sizeof(struct queue));
@


1.37
log
@use nanosleep() instead of select(); ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.36 2014/10/16 04:17:48 deraadt Exp $	*/
a37 1
#include <sys/param.h>
d50 1
@


1.36
log
@reallocarray() obviously
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.35 2013/12/10 16:38:04 naddy Exp $	*/
d418 1
a418 1
	struct timeval tdelay;
d423 2
a424 2
	tdelay.tv_usec = n * 1000 % 1000000;
	(void) select(0, (fd_set *)0, (fd_set *)0, (fd_set *)0, &tdelay);
@


1.35
log
@Remove the printcap fc, fs, xc, xs capabilities from lpd that were used
to configure a tty by poking magic numbers into sgtty.  If needed, the
ms capability, which uses symbolic stty modes, can be used instead.
Better description of ms from FreeBSD.
ok beck@@, deraadt@@, jmc@@ (man page)
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.34 2012/03/04 04:05:15 fgsch Exp $	*/
d273 2
a274 3
			size_t newarraysz = arraysz * 2;
			newqueue = (struct queue **)realloc(queue,
				newarraysz * sizeof(struct queue *));
d279 1
a280 1
			arraysz = newarraysz;
@


1.34
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.33 2009/10/27 23:59:51 deraadt Exp $	*/
a68 1
long	 FC;		/* flags to clear if lp is a tty */
a69 1
long	 FS;		/* flags to set if lp is a tty */
a99 2
long	 XC;		/* flags to clear for local mode */
long	 XS;		/* flags to set for local mode */
@


1.33
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.32 2007/09/02 15:19:38 deraadt Exp $	*/
d202 1
a202 1
getline(FILE *cfp)
@


1.32
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.31 2007/03/16 20:03:48 stevesk Exp $	*/
a36 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)common.c	8.5 (Berkeley) 4/28/95";
#else
static const char rcsid[] = "$OpenBSD: common.c,v 1.31 2007/03/16 20:03:48 stevesk Exp $";
#endif
#endif /* not lint */
@


1.31
log
@remove unused variable; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.30 2007/03/13 15:09:51 stevesk Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.30 2007/03/13 15:09:51 stevesk Exp $";
d260 1
a260 1
	queue = (struct queue **)malloc(arraysz * sizeof(struct queue *));
@


1.30
log
@typos in comments; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.29 2004/11/17 02:31:30 itojun Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.29 2004/11/17 02:31:30 itojun Exp $";
a90 1
char	*PF;		/* name of vrast filter (per job) */
@


1.29
log
@NI_WITHSCOPEID is no more.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.28 2004/09/28 20:26:27 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.28 2004/09/28 20:26:27 millert Exp $";
d76 1
a76 1
long	 DU;		/* daeomon user-id */
d97 1
a97 1
char    *RG;		/* resricted group */
@


1.28
log
@Simpler loop to free queue items.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.27 2004/09/28 15:54:50 otto Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.27 2004/09/28 15:54:50 otto Exp $";
a337 3
#ifdef NI_WITHSCOPEID
	const int niflags = NI_NUMERICHOST | NI_WITHSCOPEID;
#else
a338 1
#endif
@


1.27
log
@Fix leaks in error paths. from Patrick Latifi. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.26 2003/09/26 06:01:41 pvalchev Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.26 2003/09/26 06:01:41 pvalchev Exp $";
d306 2
a307 4
		size_t i;

		for (i = 0; i < nitems; i++)
			free(queue[i]);
@


1.26
log
@realloc fixes; ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.25 2003/06/02 23:36:53 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.25 2003/06/02 23:36:53 millert Exp $";
d167 2
a168 1
			    (s = socket(r->ai_family, SOCK_STREAM, 0)) < 0)
d170 1
d243 2
a244 2
	struct queue *q, **queue;
	size_t nitems, arraysz;
a264 1
	nitems = 0;
d284 1
a284 1
		if (++nitems > arraysz) {
d290 1
a290 2
				free(queue);
				queue = NULL;
d296 1
a296 1
		queue[nitems-1] = q;
d305 7
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.24 2003/04/07 22:55:50 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.24 2003/04/07 22:55:50 deraadt Exp $";
d284 7
a290 4
			arraysz *= 2;
			queue = (struct queue **)realloc(queue,
				arraysz * sizeof(struct queue *));
			if (queue == NULL)
d292 3
@


1.24
log
@kill last strcpy; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.23 2002/06/13 06:48:40 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.23 2002/06/13 06:48:40 millert Exp $";
@


1.23
log
@Fixed some lpd bugs while on the plane from Calgary:
o mark fatal() as __dead
o add SIGINT to the signal mask when installing abort() as a handler.
  We can end up in abortpr() due to several different signals and since
  abortpr() kill()s itself with SIGINT we need to explicately protect
  against the current process receiving SIGINT while in abortpr()
o Don't leak the lock fd to children spawned by lpd
o Close the lock file (and thus unlocke immediately in abortpr().
  Otherwise, if there is an output filter the lock file only gets
  closed after we finish waiting for the output filter to die.
  This causes a race condition in lprm such that the per-printer
  daemon does not get restarted when lprm kills the active job
  (noticed during c2k2 with the mp3 printer spool ;-)
o Open the printcap file with privs raised just in case it is not
  world-readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.22 2002/06/09 03:56:28 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.22 2002/06/09 03:56:28 millert Exp $";
d277 1
a277 1
		q = (struct queue *)malloc(sizeof(time_t)+strlen(d->d_name)+1);
d281 2
a282 1
		strcpy(q->q_name, d->d_name);	/* safe */
@


1.22
log
@Convert remaining K&R function headers to ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.21 2002/06/09 03:44:50 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.21 2002/06/09 03:44:50 millert Exp $";
d437 1
a437 1
void
@


1.21
log
@o Kill "garbage" global (unused)
o Kill "rank" global (doesn't need to be global)
o Make inform() static (local to displayq.c)
o Pass in rank to inform() based on index within sorted mtime array
o Simplify compar()
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.20 2002/06/08 18:19:34 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.20 2002/06/08 18:19:34 millert Exp $";
d129 1
a129 3
getport(rhost, rport)
	char *rhost;
	int rport;
d213 1
a213 2
getline(cfp)
	FILE *cfp;
d242 1
a242 2
getq(namelist)
	struct queue *(*namelist[]);
d310 1
a310 2
compar(v1, v2)
	const void *v1, *v2;
@


1.20
log
@use the dirfd macro instead of reaching into the DIR and pulling out dd_fd
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.19 2002/06/08 03:35:48 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.19 2002/06/08 03:35:48 millert Exp $";
d314 2
a315 2
compar(p1, p2)
	const void *p1, *p2;
d317 4
a320 5
	if ((*(struct queue **)p1)->q_time < (*(struct queue **)p2)->q_time)
		return(-1);
	if ((*(struct queue **)p1)->q_time > (*(struct queue **)p2)->q_time)
		return(1);
	return(0);
@


1.19
log
@Remove some debugging code
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.18 2002/06/08 01:53:43 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.18 2002/06/08 01:53:43 millert Exp $";
d259 1
a259 1
	if (fstat(dirp->dd_fd, &stbuf) < 0)
@


1.18
log
@Remove setuid root from lp*.  lpr needs to be setuid daemon so the
files it creates are not owned by the user spooling them but the
others (lpc, lpq, lprm) can get away with setgid daemon.  lpd runs
as user daemon for most things, only changing its uid to 0 for
things that must be done as root.

For the time being, don't require connections to come from a reserved
port since lpq/lpr/lprm can't acquire that w/o setuid root.  In the
near future we will have a mechanism for select non-root processes
to grab reserved ports.

The upshot of this is that spool directories must be writable by
group daemon and the files within the spool dirs must be owned by
daemon.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.17 2002/05/20 23:13:50 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.17 2002/05/20 23:13:50 millert Exp $";
a349 5

	/* XXX */
	remote = 1;
	return NULL; /* XXX -- for local testing only! */
	/* XXX */
@


1.17
log
@Pull in useful bits from NetBSD and make our lp* easier to diff and
do some minor cleanup of my own:

o IPv6 support
o ANSI function headers
o use getopt()
o synce usage() with man pages
o passes -Wall on both 32bit and 64bit platforms
o add an option to set the max number of children lpd will fork off
o add an lpd option to bind to specific addresses instead of INADDR_ANY.
o allow user to specify how long to wait for a connection to remote servers
o more strlcpy() and snprintf() usage
o Use FOO_FILENO constants instead of hard-coding 0-2
o Add some keeps to man the page SYNOPSIS to avoid options being split
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.16 2002/02/19 19:39:40 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.16 2002/02/19 19:39:40 millert Exp $";
d61 1
d167 1
a167 1
		seteuid(euid);
d169 7
a175 3
		seteuid(uid);
		if (s < 0)
			return(-1);
d254 1
a254 1
	seteuid(euid);
d256 1
a256 1
	seteuid(uid);
d275 1
a275 1
		seteuid(euid);
d277 1
a277 1
			seteuid(uid);
d280 1
a280 1
		seteuid(uid);
d348 1
a348 1
	if (RM == NULL)
d351 5
d464 25
@


1.16
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 2
a2 1
/*	$OpenBSD: common.c,v 1.15 2002/02/16 21:28:03 millert Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.15 2002/02/16 21:28:03 millert Exp $";
d65 1
d67 1
a117 5
char	*bp;		/* pointer into printcap buffer. */
char	*printer;	/* printer name */
			/* host machine name */
char	host[MAXHOSTNAMELEN];
char	*from = host;	/* client's machine name */
a118 3
char	*printcapdb[2] = { _PATH_PRINTCAP, 0 };

extern uid_t	uid, euid;
d132 6
a137 5
	struct hostent *hp;
	struct servent *sp;
	struct sockaddr_in sin;
	int s, timo = 1, on = 1, lport = IPPORT_RESERVED - 1;
	int err;
d144 12
a155 25
	bzero((char *)&sin, sizeof(sin));
	if (inet_aton(rhost, &sin.sin_addr) == 1)
		sin.sin_family = AF_INET;
	else {
		siginterrupt(SIGINT, 1);
		hp = gethostbyname(rhost);
		if (hp == NULL) {
			if (errno == EINTR && gotintr) {
				siginterrupt(SIGINT, 0);
				return (-1);
			}
			siginterrupt(SIGINT, 0);
			fatal("unknown host %s", rhost);
		}
		siginterrupt(SIGINT, 0);
		bcopy(hp->h_addr, (caddr_t)&sin.sin_addr, hp->h_length);
		sin.sin_family = hp->h_addrtype;
	}
	if (rport == 0) {
		sp = getservbyname("printer", "tcp");
		if (sp == NULL)
			fatal("printer/tcp: unknown service");
		sin.sin_port = sp->s_port;
	} else
		sin.sin_port = htons(rport);
d161 26
a186 16
	seteuid(euid);
	siginterrupt(SIGINT, 1);
	s = rresvport(&lport);
	siginterrupt(SIGINT, 0);
	seteuid(uid);
	if (s < 0)
		return(-1);
	siginterrupt(SIGINT, 1);
	if (connect(s, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
		err = errno;
		(void) close(s);
		siginterrupt(SIGINT, 0);
		errno = err;
		if (errno == EINTR && gotintr) {
			close(s);
			return (-1);
a187 10
		if (errno == EADDRINUSE) {
			lport--;
			goto retry;
		}
		if (errno == ECONNREFUSED && timo <= 16) {
			sleep(timo);
			timo *= 2;
			goto retry;
		}
		return(-1);
d189 12
a200 4
		siginterrupt(SIGINT, 0);
	
	/* Don't bother if we get an error here.  */
	setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, (char *)&on, sizeof on);
d224 1
a224 1
			} while ((linel & 07) != 0 && linel+1<sizeof(line));
d245 1
a245 1
	int nitems;
a247 2
	int arraysz;
	
d252 1
a252 1
	if (dirp== NULL)
d280 1
a280 1
		strcpy(q->q_name, d->d_name);
d287 1
a287 1
			queue = (struct queue **)realloc((char *)queue,
d324 1
a324 1
checkremote()
d326 2
a327 2
	char name[MAXHOSTNAMELEN];
	struct hostent *hp;
d329 13
a341 1
	char *rp, *rp_b;
d343 34
a376 5
	remote = 0;	/* assume printer is local */
	if (RM != NULL) {
		/* get the official name of the local host */
		gethostname(name, sizeof(name));
		name[sizeof(name)-1] = '\0';
d378 22
a399 3
		hp = gethostbyname(name);
		if (hp == (struct hostent *) NULL) {
			if (errno == EINTR && gotintr) {
d401 8
a408 2
				return NULL;
			}
d410 2
a411 16
			(void) snprintf(errbuf, sizeof(errbuf),
			    "unable to get official name for local machine %s",
			    name);
			return errbuf;
		} else
			strlcpy(name, hp->h_name, sizeof name);
		siginterrupt(SIGINT, 0);

		/* get the official name of RM */
		hp = gethostbyname(RM);
		if (hp == (struct hostent *) NULL) {
		    (void) snprintf(errbuf, sizeof(errbuf),
			"unable to get official name for remote machine %s",
			RM);
		    return errbuf;
		}
d413 3
a415 17
		/*
		 * if the two hosts are not the same,
		 * then the printer must be remote.
		 */
		if (strcasecmp(name, hp->h_name) != 0)
			remote = 1;
		else if (cgetstr(bp, "rp", &rp) > 0) {
			if (cgetent(&rp_b, printcapdb, rp) == 0) {
				if (cgetmatch(rp_b, printer) != 0)
					remote = 1;
				free(rp_b);
			} else {
				(void) snprintf(errbuf, sizeof(errbuf),
					"can't find (local) remote printer %s",
					rp);
					free(rp);
					return errbuf;
a416 1
			free(rp);
d419 3
d427 1
a427 1
delay(n)
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.14 2001/12/06 03:12:30 ericj Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.14 2001/12/06 03:12:30 ericj Exp $";
d64 1
a408 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a409 1
#ifdef __STDC__
a410 5
#else
fatal(msg, va_alist)
	char *msg;
        va_dcl
#endif
d414 1
a414 1
#ifdef __STDC__
a415 3
#else
	va_start(ap);
#endif
@


1.14
log
@
use err/warn and friends instead of printf/exit.
also, remove fatal2() which is just errx anyway.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.13 2001/11/23 03:58:17 deraadt Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.13 2001/11/23 03:58:17 deraadt Exp $";
d124 1
a124 1
static int compar __P((const void *, const void *));
@


1.13
log
@use the same siginterrupt() trick in lpc(1) as in timedc(1). we have to hack
a global into the other programs since they share some source.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.12 2001/08/30 17:38:13 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.12 2001/08/30 17:38:13 millert Exp $";
a114 1
char	*name;		/* program name */
d423 1
d432 1
a432 1
	(void)printf("%s: ", name);
@


1.12
log
@o kill register
o add const to rcsid and copyright strings
o placate -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.11 2001/04/05 16:59:49 deraadt Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.11 2001/04/05 16:59:49 deraadt Exp $";
d152 1
d154 6
a159 1
		if (hp == NULL)
d161 2
d179 1
d181 1
d185 1
d189 1
d191 4
d206 1
d347 1
d350 12
a361 5
		    (void) snprintf(errbuf, sizeof(errbuf),
			"unable to get official name for local machine %s",
			name);
		    return errbuf;
		} else (void) strcpy(name, hp->h_name);
@


1.11
log
@another euid mixup; wiz@@danbala.ifoer.tuwien.ac.at
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.10 2001/04/04 13:10:14 deraadt Exp $	*/
d43 1
a43 1
static char sccsid[] = "@@(#)common.c	8.5 (Berkeley) 4/28/95";
d45 1
a45 1
static char rcsid[] = "$OpenBSD: common.c,v 1.10 2001/04/04 13:10:14 deraadt Exp $";
d205 3
a207 3
	register int linel = 0;
	register char *lp = line;
	register c;
d235 3
a237 3
	register struct dirent *d;
	register struct queue *q, **queue;
	register int nitems;
d321 1
a321 1
	register struct hostent *hp;
@


1.10
log
@missung euid swapout; j@@ida.interface-business.de
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.9 1998/06/28 02:22:13 angelos Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: common.c,v 1.9 1998/06/28 02:22:13 angelos Exp $";
d241 1
d244 3
a246 1
	if ((dirp = opendir(SD)) == NULL)
a249 1
	seteuid(uid);
@


1.9
log
@Treat a printer as remote iff RM is not us or RP is set and it doesn't match the
current printer;dwmalone@@maths.tcd.ie
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.8 1998/02/15 15:51:48 niklas Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: common.c,v 1.8 1998/02/15 15:51:48 niklas Exp $";
d263 2
a264 1
		if (stat(d->d_name, &stbuf) < 0)
d266 1
@


1.8
log
@Use keepalives as the protocol never notices if a networked printer
dies.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.7 1997/07/25 20:12:11 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: common.c,v 1.7 1997/07/25 20:12:11 mickey Exp $";
d319 1
d349 14
@


1.7
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.6 1997/07/24 01:10:33 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: common.c,v 1.6 1997/07/24 01:10:33 millert Exp $";
d140 1
a140 1
	int s, timo = 1, lport = IPPORT_RESERVED - 1;
d190 3
@


1.6
log
@inet_aton() returns 0 on error, not -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.5 1997/07/19 07:11:41 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: common.c,v 1.5 1997/07/19 07:11:41 deraadt Exp $";
d362 1
a362 1
#if __STDC__
d369 1
a369 1
#if __STDC__
d378 1
a378 1
#if __STDC__
@


1.5
log
@Wall cleanup; people running lpd should test!
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.4 1997/01/17 16:11:35 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: common.c,v 1.4 1997/01/17 16:11:35 millert Exp $";
d149 1
a149 1
	if (inet_aton(rhost, &sin.sin_addr) != -1)
@


1.4
log
@Add OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: $";
d55 1
d149 1
a149 2
	sin.sin_addr.s_addr = inet_addr(rhost);
	if (sin.sin_addr.s_addr != INADDR_NONE)
@


1.3
log
@proactive bounds checking; help from millert
@
text
@d1 2
d42 1
d44 3
@


1.2
log
@Integrated 4.4Lite2 source
Fixed potential problem pointed out by bitblt
@
text
@d200 1
a200 1
	while ((c = getc(cfp)) != '\n') {
d207 1
a207 1
			} while ((linel & 07) != 0);
@


1.1
log
@Initial revision
@
text
@d40 1
a40 1
static char sccsid[] = "@@(#)common.c	8.2 (Berkeley) 1/21/94";
d45 1
d113 1
a113 1
int	sendtorem;	/* are we sending to a remote? */
d121 2
a122 1
 * Create a connection to the remote printer server.
d126 1
a126 1
getport(rhost)
d128 1
a140 6
	hp = gethostbyname(rhost);
	if (hp == NULL)
		fatal("unknown host %s", rhost);
	sp = getservbyname("printer", "tcp");
	if (sp == NULL)
		fatal("printer/tcp: unknown service");
d142 17
a158 3
	bcopy(hp->h_addr, (caddr_t)&sin.sin_addr, hp->h_length);
	sin.sin_family = hp->h_addrtype;
	sin.sin_port = sp->s_port;
d267 1
d269 1
a269 1
				(stbuf.st_size/12) * sizeof(struct queue *));
d311 2
a312 2
	sendtorem = 0;	/* assume printer is local */
	if (RM != (char *)NULL) {
d337 2
a338 2
		if (strcmp(name, hp->h_name) != 0)
			sendtorem = 1;
d340 14
a353 1
	return (char *)0;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
