head	1.27;
access;
symbols
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.12
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.8
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.4
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.6
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.10
	OPENBSD_5_0:1.21.0.8
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.19.0.12
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.8
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.6
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.16
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.14
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.12
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.10
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.8
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.6
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.14
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.12
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.10
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.8
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.6
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.01.16.06.40.18;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	Uu5nFG3wCl0LACBb;

1.26
date	2013.12.29.14.26.22;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2013.11.24.21.32.32;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2012.11.29.02.15.44;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2012.03.22.01.44.19;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.29.20.11.09;	author sobrado;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.27.23.59.52;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.07.21.57.26;	author stevesk;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.23.36.53;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.08.01.53.43;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.20.23.13.50;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.28.03;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.30.17.38.13;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.25.04.47.13;	author pjanzen;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.25.04.08.35;	author pjanzen;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.22.15.27.20;	author lebel;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.21.07.22.53;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.25.18.57.24;	author grr;	state Exp;
branches;
next	1.8;

1.8
date	97.01.17.16.12.35;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.01.17.15.51.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.11.03.23.24.06;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.10.31.22.32.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.08.29.13.06.07;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.04.05.41.53;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.01.15.20.11.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.40;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: cmds.c,v 1.26 2013/12/29 14:26:22 krw Exp $	*/
/*	$NetBSD: cmds.c,v 1.12 1997/10/05 15:12:06 mrg Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * lpc -- line printer control program -- commands:
 */

#include <sys/time.h>
#include <sys/stat.h>
#include <sys/file.h>

#include <signal.h>
#include <fcntl.h>
#include <errno.h>
#include <dirent.h>
#include <unistd.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include "lp.h"
#include "lp.local.h"
#include "lpc.h"
#include "extern.h"
#include "pathnames.h"

static void	abortpr(int);
static void	cleanpr(void);
static void	disablepr(void);
static int	doarg(char *);
static int	doselect(const struct dirent *);
static void	enablepr(void);
static void	prstat(void);
static void	putmsg(int, char **);
static int	sortq(const struct dirent **, const struct dirent **);
static void	startpr(int);
static void	stoppr(void);
static int	touch(struct queue *);
static void	unlinkf(char *);
static void	upstat(char *);

/*
 * kill an existing daemon and disable printing.
 */
void
doabort(int argc, char **argv)
{
	int c, status;
	char *cp1, *cp2;
	char prbuf[100];

	if (argc == 1) {
		printf("usage: abort {all | printer ...}\n");
		return;
	}
	if (argc == 2 && strcmp(argv[1], "all") == 0) {
		printer = prbuf;
		while (cgetnext(&bp, printcapdb) > 0) {
			cp1 = prbuf;
			cp2 = bp;
			while ((c = *cp2++) && c != '|' && c != ':' &&
			    (cp1 - prbuf) < sizeof(prbuf) - 1)
				*cp1++ = c;
			*cp1 = '\0';
			abortpr(1);
		}
		return;
	}
	while (--argc) {
		printer = *++argv;
		if ((status = cgetent(&bp, printcapdb, printer)) == -2) {
			printf("cannot open printer description file\n");
			continue;
		} else if (status == -1) {
			printf("unknown printer %s\n", printer);
			continue;
		} else if (status == -3)
			fatal("potential reference loop detected in printcap file");
		abortpr(1);
	}
}

static void
abortpr(int dis)
{
	FILE *fp;
	struct stat stbuf;
	int pid, fd;

	if (cgetstr(bp, "sd", &SD) == -1)
		SD = _PATH_DEFSPOOL;
	if (cgetstr(bp, "lo", &LO) == -1)
		LO = DEFLOCK;
	(void)snprintf(line, sizeof(line), "%s/%s", SD, LO);
	printf("%s:\n", printer);

	PRIV_START;
	/*
	 * Turn on the owner execute bit of the lock file to disable printing.
	 */
	if (dis) {
		if (stat(line, &stbuf) >= 0) {
			stbuf.st_mode |= S_IXUSR;
			if (chmod(line, stbuf.st_mode & 0777) < 0)
				printf("\tcannot disable printing\n");
			else {
				upstat("printing disabled\n");
				printf("\tprinting disabled\n");
			}
		} else if (errno == ENOENT) {
			if ((fd = safe_open(line, O_WRONLY|O_CREAT|O_NOFOLLOW,
			    0760)) < 0)
				printf("\tcannot create lock file\n");
			else {
				(void)fchown(fd, DEFUID, -1);
				(void)close(fd);
				upstat("printing disabled\n");
				printf("\tprinting disabled\n");
				printf("\tno daemon to abort\n");
			}
			goto out;
		} else {
			printf("\tcannot stat lock file\n");
			goto out;
		}
	}
	/*
	 * Kill the current daemon to stop printing now.
	 */
	fd = safe_open(line, O_RDONLY|O_NOFOLLOW, 0);
	if (fd < 0 || (fp = fdopen(fd, "r")) == NULL) {
		if (fd >= 0)
			close(fd);
		printf("\tcannot open lock file\n");
		goto out;
	}
	if (!get_line(fp) || flock(fileno(fp), LOCK_SH|LOCK_NB) == 0) {
		(void)fclose(fp);	/* unlocks as well */
		printf("\tno daemon to abort\n");
		goto out;
	}
	(void)fclose(fp);
	if (kill(pid = atoi(line), SIGTERM) < 0) {
		if (errno == ESRCH)
			printf("\tno daemon to abort\n");
		else
			printf("\tWarning: daemon (pid %d) not killed\n", pid);
	} else
		printf("\tdaemon (pid %d) killed\n", pid);
out:
	PRIV_END;
}

/*
 * Write a message into the status file (assumes PRIV_START already called)
 */
static void
upstat(char *msg)
{
	int fd;
	char statfile[PATH_MAX];

	if (cgetstr(bp, "st", &ST) == -1)
		ST = DEFSTAT;
	(void)snprintf(statfile, sizeof(statfile), "%s/%s", SD, ST);
	fd = safe_open(statfile, O_WRONLY|O_CREAT|O_NOFOLLOW, 0660);
	if (fd < 0 || flock(fd, LOCK_EX) < 0) {
		printf("\tcannot create status file\n");
		if (fd >= 0)
			(void)close(fd);	/* unlocks as well */
		return;
	}
	(void)fchown(fd, DEFUID, -1);
	(void)ftruncate(fd, 0);
	if (msg == (char *)NULL)
		(void)write(fd, "\n", 1);
	else
		(void)write(fd, msg, strlen(msg));
	(void)close(fd);
}

/*
 * Remove all spool files and temporaries from the spooling area.
 */
void
clean(int argc, char **argv)
{
	int c, status;
	char *cp1, *cp2;
	char prbuf[100];

	if (argc == 1) {
		printf("usage: clean {all | printer ...}\n");
		return;
	}
	if (argc == 2 && strcmp(argv[1], "all") == 0) {
		printer = prbuf;
		while (cgetnext(&bp, printcapdb) > 0) {
			cp1 = prbuf;
			cp2 = bp;
			while ((c = *cp2++) && c != '|' && c != ':' &&
			    (cp1 - prbuf) < sizeof(prbuf) - 1)
				*cp1++ = c;
			*cp1 = '\0';
			cleanpr();
		}
		return;
	}
	while (--argc) {
		printer = *++argv;
		if ((status = cgetent(&bp, printcapdb, printer)) == -2) {
			printf("cannot open printer description file\n");
			continue;
		} else if (status == -1) {
			printf("unknown printer %s\n", printer);
			continue;
		} else if (status == -3)
			fatal("potential reference loop detected in printcap file");

		cleanpr();
	}
}

static int
doselect(const struct dirent *d)
{
	int c = d->d_name[0];

	if ((c == 't' || c == 'c' || c == 'd') && d->d_name[1] == 'f')
		return(1);
	return(0);
}

/*
 * Comparison routine for scandir. Sort by job number and machine, then
 * by `cf', `tf', or `df', then by the sequence letter A-Z, a-z.
 */
static int
sortq(const struct dirent **d1, const struct dirent **d2)
{
	int c1, c2;

	if ((c1 = strcmp((*d1)->d_name + 3, (*d2)->d_name + 3)) != 0)
		return(c1);
	c1 = (*d1)->d_name[0];
	c2 = (*d2)->d_name[0];
	if (c1 == c2)
		return((*d1)->d_name[2] - (*d2)->d_name[2]);
	if (c1 == 'c')
		return(-1);
	if (c1 == 'd' || c2 == 'c')
		return(1);
	return(-1);
}

/*
 * Remove incomplete jobs from spooling area.
 */
static void
cleanpr(void)
{
	int i, n;
	char *cp, *cp1, *lp;
	struct dirent **queue;
	int nitems;

	if (cgetstr(bp, "sd", &SD) == -1)
		SD = _PATH_DEFSPOOL;
	printf("%s:\n", printer);

	/* XXX depends on SD being non-NUL */
	for (lp = line, cp = SD; (lp - line) < sizeof(line) &&
	    (*lp++ = *cp++) != '\0'; )
		;
	lp[-1] = '/';
	if (lp - line >= sizeof(line)) {
		printf("\tspool directory name too long\n");
		return;
	}

	PRIV_START;
	nitems = scandir(SD, &queue, doselect, sortq);
	PRIV_END;
	if (nitems < 0) {
		printf("\tcannot examine spool directory\n");
		return;
	}
	if (nitems == 0)
		return;
	i = 0;
	do {
		cp = queue[i]->d_name;
		if (*cp == 'c') {
			n = 0;
			while (i + 1 < nitems) {
				cp1 = queue[i + 1]->d_name;
				if (*cp1 != 'd' || strcmp(cp + 3, cp1 + 3))
					break;
				i++;
				n++;
			}
			if (n == 0) {
				if (strlcpy(lp, cp, sizeof(line) - (lp - line))
				    >= sizeof(line) - (lp - line))
					printf("\tpath too long, %s/%s", SD, cp);
				else
					unlinkf(line);
			}
		} else {
			/*
			 * Must be a df with no cf (otherwise, it would have
			 * been skipped above) or a tf file (which can always
			 * be removed).
			 */
			if (strlcpy(lp, cp, sizeof(line) - (lp - line)) >=
			    sizeof(line) - (lp - line))
				printf("\tpath too long, %s/%s", SD, cp);
			else
				unlinkf(line);
		}
     	} while (++i < nitems);
}
 
static void
unlinkf(char *name)
{
	PRIV_START;
	if (unlink(name) < 0)
		printf("\tcannot remove %s\n", name);
	else
		printf("\tremoved %s\n", name);
	PRIV_END;
}

/*
 * Enable queuing to the printer (allow lpr's).
 */
void
enable(int argc, char **argv)
{
	int c, status;
	char *cp1, *cp2;
	char prbuf[100];

	if (argc == 1) {
		printf("usage: enable {all | printer ...}\n");
		return;
	}
	if (argc == 2 && strcmp(argv[1], "all") == 0) {
		printer = prbuf;
		while (cgetnext(&bp, printcapdb) > 0) {
			cp1 = prbuf;
			cp2 = bp;
			while ((c = *cp2++) && c != '|' && c != ':' &&
			    (cp1 - prbuf) < sizeof(prbuf) - 1)
				*cp1++ = c;
			*cp1 = '\0';
			enablepr();
		}
		return;
	}
	while (--argc) {
		printer = *++argv;
		if ((status = cgetent(&bp, printcapdb, printer)) == -2) {
			printf("cannot open printer description file\n");
			continue;
		} else if (status == -1) {
			printf("unknown printer %s\n", printer);
			continue;
		} else if (status == -3)
			fatal("potential reference loop detected in printcap file");

		enablepr();
	}
}

static void
enablepr(void)
{
	struct stat stbuf;

	if (cgetstr(bp, "sd", &SD) == -1)
		SD = _PATH_DEFSPOOL;
	if (cgetstr(bp, "lo", &LO) == -1)
		LO = DEFLOCK;
	(void)snprintf(line, sizeof(line), "%s/%s", SD, LO);
	printf("%s:\n", printer);

	/*
	 * Turn off the group execute bit of the lock file to enable queuing.
	 */
	PRIV_START;
	if (stat(line, &stbuf) >= 0) {
		stbuf.st_mode &= ~S_IXGRP;
		if (chmod(line, stbuf.st_mode & 0777) < 0)
			printf("\tcannot enable queuing\n");
		else
			printf("\tqueuing enabled\n");
	}
	PRIV_END;
}

/*
 * Disable queuing.
 */
void
disable(int argc, char **argv)
{
	int c, status;
	char *cp1, *cp2;
	char prbuf[100];

	if (argc == 1) {
		printf("usage: disable {all | printer ...}\n");
		return;
	}
	if (argc == 2 && strcmp(argv[1], "all") == 0) {
		printer = prbuf;
		while (cgetnext(&bp, printcapdb) > 0) {
			cp1 = prbuf;
			cp2 = bp;
			while ((c = *cp2++) && c != '|' && c != ':' &&
			    (cp1 - prbuf) < sizeof(prbuf) - 1)
				*cp1++ = c;
			*cp1 = '\0';
			disablepr();
		}
		return;
	}
	while (--argc) {
		printer = *++argv;
		if ((status = cgetent(&bp, printcapdb, printer)) == -2) {
			printf("cannot open printer description file\n");
			continue;
		} else if (status == -1) {
			printf("unknown printer %s\n", printer);
			continue;
		} else if (status == -3)
			fatal("potential reference loop detected in printcap file");

		disablepr();
	}
}

static void
disablepr(void)
{
	int fd;
	struct stat stbuf;

	if (cgetstr(bp, "sd", &SD) == -1)
		SD = _PATH_DEFSPOOL;
	if (cgetstr(bp, "lo", &LO) == -1)
		LO = DEFLOCK;
	(void)snprintf(line, sizeof(line), "%s/%s", SD, LO);
	printf("%s:\n", printer);
	/*
	 * Turn on the group execute bit of the lock file to disable queuing.
	 */
	PRIV_START;
	if (stat(line, &stbuf) >= 0) {
		stbuf.st_mode |= S_IXGRP;
		if (chmod(line, stbuf.st_mode & 0777) < 0)
			printf("\tcannot disable queuing\n");
		else
			printf("\tqueuing disabled\n");
	} else if (errno == ENOENT) {
		if ((fd = safe_open(line, O_WRONLY|O_CREAT|O_NOFOLLOW, 0670)) < 0)
			printf("\tcannot create lock file\n");
		else {
			(void)fchown(fd, DEFUID, -1);
			(void)close(fd);
			printf("\tqueuing disabled\n");
		}
	} else
		printf("\tcannot stat lock file\n");
	PRIV_END;
}

/*
 * Disable queuing and printing and put a message into the status file
 * (reason for being down).
 */
void
down(int argc, char **argv)
{
	int c, status;
	char *cp1, *cp2;
	char prbuf[100];

	if (argc == 1) {
		printf("usage: down {all | printer} [message ...]\n");
		return;
	}
	if (strcmp(argv[1], "all") == 0) {
		printer = prbuf;
		while (cgetnext(&bp, printcapdb) > 0) {
			cp1 = prbuf;
			cp2 = bp;
			while ((c = *cp2++) && c != '|' && c != ':' &&
			    (cp1 - prbuf) < sizeof(prbuf) - 1)
				*cp1++ = c;
			*cp1 = '\0';
			putmsg(argc - 2, argv + 2);
		}
		return;
	}
	printer = argv[1];
	if ((status = cgetent(&bp, printcapdb, printer)) == -2) {
		printf("cannot open printer description file\n");
		return;
	} else if (status == -1) {
		printf("unknown printer %s\n", printer);
		return;
	} else if (status == -3)
		fatal("potential reference loop detected in printcap file");

	putmsg(argc - 2, argv + 2);
}

static void
putmsg(int argc, char **argv)
{
	int fd;
	char *cp1, *cp2;
	char buf[1024];
	struct stat stbuf;

	if (cgetstr(bp, "sd", &SD) == -1)
		SD = _PATH_DEFSPOOL;
	if (cgetstr(bp, "lo", &LO) == -1)
		LO = DEFLOCK;
	if (cgetstr(bp, "st", &ST) == -1)
		ST = DEFSTAT;
	printf("%s:\n", printer);
	/*
	 * Turn on the group execute bit of the lock file to disable queuing and
	 * turn on the owner execute bit of the lock file to disable printing.
	 */
	(void)snprintf(line, sizeof(line), "%s/%s", SD, LO);
	PRIV_START;
	if (stat(line, &stbuf) >= 0) {
		stbuf.st_mode |= (S_IXGRP|S_IXUSR);
		if (chmod(line, stbuf.st_mode & 0777) < 0)
			printf("\tcannot disable queuing\n");
		else
			printf("\tprinter and queuing disabled\n");
	} else if (errno == ENOENT) {
		if ((fd = safe_open(line, O_WRONLY|O_CREAT|O_NOFOLLOW, 0770)) < 0)
			printf("\tcannot create lock file\n");
		else {
			(void)fchown(fd, DEFUID, -1);
			(void)close(fd);
			printf("\tprinter and queuing disabled\n");
		}
		PRIV_END;
		return;
	} else
		printf("\tcannot stat lock file\n");
	/*
	 * Write the message into the status file.
	 */
	(void)snprintf(line, sizeof(line), "%s/%s", SD, ST);
	fd = safe_open(line, O_WRONLY|O_CREAT|O_NOFOLLOW, 0660);
	if (fd < 0 || flock(fd, LOCK_EX) < 0) {
		printf("\tcannot create status file\n");
		if (fd >= 0)
			(void)close(fd);	/* unlocks as well */
		PRIV_END;
		return;
	}
	PRIV_END;
	(void)fchown(fd, DEFUID, -1);
	(void)ftruncate(fd, 0);
	if (argc <= 0) {
		(void)write(fd, "\n", 1);
		(void)close(fd);
		return;
	}
	cp1 = buf;
	while (--argc >= 0) {
		cp2 = *argv++;
		while ((cp1 - buf) < sizeof(buf) - 1 && (*cp1++ = *cp2++))
			;
		cp1[-1] = ' ';
	}
	cp1[-1] = '\n';
	*cp1 = '\0';
	(void)write(fd, buf, strlen(buf));
	(void)close(fd);
}

/*
 * Exit lpc
 */
void
quit(int argc, char **argv)
{
	exit(0);
}

/*
 * Kill and restart the daemon.
 */
void
restart(int argc, char **argv)
{
	int c, status;
	char *cp1, *cp2;
	char prbuf[100];

	if (argc == 1) {
		printf("usage: restart {all | printer ...}\n");
		return;
	}
	if (argc == 2 && strcmp(argv[1], "all") == 0) {
		printer = prbuf;
		while (cgetnext(&bp, printcapdb) > 0) {
			cp1 = prbuf;
			cp2 = bp;
			while ((c = *cp2++) && c != '|' && c != ':' &&
			    (cp1 - prbuf) < sizeof(prbuf) - 1)
				*cp1++ = c;
			*cp1 = '\0';
			abortpr(0);
			startpr(0);
		}
		return;
	}
	while (--argc) {
		printer = *++argv;
		if ((status = cgetent(&bp, printcapdb, printer)) == -2) {
			printf("cannot open printer description file\n");
			continue;
		} else if (status == -1) {
			printf("unknown printer %s\n", printer);
			continue;
		} else if (status == -3)
			fatal("potential reference loop detected in printcap file");

		abortpr(0);
		startpr(0);
	}
}

/*
 * Enable printing on the specified printer and startup the daemon.
 */
void
startcmd(int argc, char **argv)
{
	int c, status;
	char *cp1, *cp2;
	char prbuf[100];

	if (argc == 1) {
		printf("usage: start {all | printer ...}\n");
		return;
	}
	if (argc == 2 && strcmp(argv[1], "all") == 0) {
		printer = prbuf;
		while (cgetnext(&bp, printcapdb) > 0) {
			cp1 = prbuf;
			cp2 = bp;
			while ((c = *cp2++) && c != '|' && c != ':' &&
			    (cp1 - prbuf) < sizeof(prbuf) - 1)
				*cp1++ = c;
			*cp1 = '\0';
			startpr(1);
		}
		return;
	}
	while (--argc) {
		printer = *++argv;
		if ((status = cgetent(&bp, printcapdb, printer)) == -2) {
			printf("cannot open printer description file\n");
			continue;
		} else if (status == -1) {
			printf("unknown printer %s\n", printer);
			continue;
		} else if (status == -3)
			fatal("potential reference loop detected in printcap file");

		startpr(1);
	}
}

static void
startpr(int enable)
{
	struct stat stbuf;

	if (cgetstr(bp, "sd", &SD) == -1)
		SD = _PATH_DEFSPOOL;
	if (cgetstr(bp, "lo", &LO) == -1)
		LO = DEFLOCK;
	(void)snprintf(line, sizeof(line), "%s/%s", SD, LO);
	printf("%s:\n", printer);

	/*
	 * Turn off the owner execute bit of the lock file to enable printing.
	 * If we are marking the printer "up" also turn off group execute bit.
	 */
	PRIV_START;
	if (enable && stat(line, &stbuf) >= 0) {
		if (enable == 2)
			stbuf.st_mode &= ~(S_IXUSR|S_IXGRP);
		else
			stbuf.st_mode &= ~S_IXUSR;
		if (chmod(line, stbuf.st_mode & 0777) < 0)
			printf("\tcannot enable printing\n");
		else
			printf("\tprinting enabled\n");
	}
	PRIV_END;
	if (!startdaemon(printer))
		printf("\tcouldn't start daemon\n");
	else
		printf("\tdaemon started\n");
}

/*
 * Print the status of each queue listed or all the queues.
 */
void
status(int argc, char **argv)
{
	int c, status;
	char *cp1, *cp2;
	char prbuf[100];

	if (argc == 1 || (argc == 2 && strcmp(argv[1], "all") == 0)) {
		printer = prbuf;
		while (cgetnext(&bp, printcapdb) > 0) {
			cp1 = prbuf;
			cp2 = bp;
			while ((c = *cp2++) && c != '|' && c != ':' &&
			    (cp1 - prbuf) < sizeof(prbuf) - 1)
				*cp1++ = c;
			*cp1 = '\0';
			prstat();
		}
		return;
	}
	while (--argc) {
		printer = *++argv;
		if ((status = cgetent(&bp, printcapdb, printer)) == -2) {
			printf("cannot open printer description file\n");
			continue;
		} else if (status == -1) {
			printf("unknown printer %s\n", printer);
			continue;
		} else if (status == -3)
			fatal("potential reference loop detected in printcap file");

		prstat();
	}
}

/*
 * Print the status of the printer queue.
 */
static void
prstat(void)
{
	struct stat stbuf;
	int fd, i;
	struct dirent *dp;
	DIR *dirp;

	if (cgetstr(bp, "sd", &SD) == -1)
		SD = _PATH_DEFSPOOL;
	if (cgetstr(bp, "lo", &LO) == -1)
		LO = DEFLOCK;
	if (cgetstr(bp, "st", &ST) == -1)
		ST = DEFSTAT;
	printf("%s:\n", printer);
	(void)snprintf(line, sizeof(line), "%s/%s", SD, LO);
	PRIV_START;
	i = stat(line, &stbuf);
	PRIV_END;
	if (i >= 0) {
		printf("\tqueuing is %s\n",
			(stbuf.st_mode & 010) ? "disabled" : "enabled");
		printf("\tprinting is %s\n",
			(stbuf.st_mode & 0100) ? "disabled" : "enabled");
	} else {
		printf("\tqueuing is enabled\n");
		printf("\tprinting is enabled\n");
	}
	PRIV_START;
	dirp = opendir(SD);
	PRIV_END;
	if (dirp == NULL) {
		printf("\tcannot examine spool directory\n");
		return;
	}
	i = 0;
	while ((dp = readdir(dirp)) != NULL) {
		if (*dp->d_name == 'c' && dp->d_name[1] == 'f')
			i++;
	}
	closedir(dirp);
	if (i == 0)
		printf("\tno entries\n");
	else if (i == 1)
		printf("\t1 entry in spool area\n");
	else
		printf("\t%d entries in spool area\n", i);
	PRIV_START;
	fd = safe_open(line, O_RDONLY|O_NOFOLLOW, 0);
	PRIV_END;
	if (fd < 0 || flock(fd, LOCK_SH|LOCK_NB) == 0) {
		printf("\tprinter idle\n");
		if (fd >= 0)
			(void)close(fd);	/* unlocks as well */
		return;
	}
	(void)close(fd);
	(void)snprintf(line, sizeof(line), "%s/%s", SD, ST);
	PRIV_START;
	fd = safe_open(line, O_RDONLY|O_NOFOLLOW, 0);
	PRIV_END;
	if (fd >= 0) {
		(void)flock(fd, LOCK_SH);
		if (fstat(fd, &stbuf) == 0 && stbuf.st_size > 0) {
			putchar('\t');
			while ((i = read(fd, line, sizeof(line))) > 0)
				(void)fwrite(line, 1, i, stdout);
		}
		(void)close(fd);	/* unlocks as well */
	}
}

/*
 * Stop the specified daemon after completing the current job and disable
 * printing.
 */
void
stop(int argc, char **argv)
{
	int c, status;
	char *cp1, *cp2;
	char prbuf[100];

	if (argc == 1) {
		printf("usage: stop {all | printer ...}\n");
		return;
	}
	if (argc == 2 && strcmp(argv[1], "all") == 0) {
		printer = prbuf;
		while (cgetnext(&bp, printcapdb) > 0) {
			cp1 = prbuf;
			cp2 = bp;
			while ((c = *cp2++) && c != '|' && c != ':' &&
			    (cp1 - prbuf) < sizeof(prbuf) - 1)
				*cp1++ = c;
			*cp1 = '\0';
			stoppr();
		}
		return;
	}
	while (--argc) {
		printer = *++argv;
		if ((status = cgetent(&bp, printcapdb, printer)) == -2) {
			printf("cannot open printer description file\n");
			continue;
		} else if (status == -1) {
			printf("unknown printer %s\n", printer);
			continue;
		} else if (status == -3)
			fatal("potential reference loop detected in printcap file");

		stoppr();
	}
}

static void
stoppr(void)
{
	int fd;
	struct stat stbuf;

	if (cgetstr(bp, "sd", &SD) == -1)
		SD = _PATH_DEFSPOOL;
	if (cgetstr(bp, "lo", &LO) == -1)
		LO = DEFLOCK;
	(void)snprintf(line, sizeof(line), "%s/%s", SD, LO);
	printf("%s:\n", printer);

	/*
	 * Turn on the owner execute bit of the lock file to disable printing.
	 */
	PRIV_START;
	if (stat(line, &stbuf) >= 0) {
		stbuf.st_mode |= S_IXUSR;
		if (chmod(line, stbuf.st_mode & 0777) < 0)
			printf("\tcannot disable printing\n");
		else {
			upstat("printing disabled\n");
			printf("\tprinting disabled\n");
		}
	} else if (errno == ENOENT) {
		if ((fd = safe_open(line, O_WRONLY|O_CREAT|O_NOFOLLOW, 0760)) < 0)
			printf("\tcannot create lock file\n");
		else {
			(void)fchown(fd, DEFUID, -1);
			(void)close(fd);
			upstat("printing disabled\n");
			printf("\tprinting disabled\n");
		}
	} else
		printf("\tcannot stat lock file\n");
	PRIV_END;
}

struct	queue **queue;
int	nitems;
time_t	mtime;

/*
 * Put the specified jobs at the top of printer queue.
 */
void
topq(int argc, char **argv)
{
	int i;
	struct stat stbuf;
	int status, changed;

	if (argc < 3) {
		printf("usage: topq printer [jobnum ...] [user ...]\n");
		return;
	}

	--argc;
	printer = *++argv;
	status = cgetent(&bp, printcapdb, printer);
	if (status == -2) {
		printf("cannot open printer description file\n");
		return;
	} else if (status == -1) {
		printf("%s: unknown printer\n", printer);
		return;
	} else if (status == -3)
		fatal("potential reference loop detected in printcap file");

	if (cgetstr(bp, "sd", &SD) == -1)
		SD = _PATH_DEFSPOOL;
	if (cgetstr(bp, "lo", &LO) == -1)
		LO = DEFLOCK;
	printf("%s:\n", printer);

	PRIV_START;
	if (chdir(SD) < 0) {
		printf("\tcannot chdir to %s\n", SD);
		goto out;
	}
	PRIV_END;
	nitems = getq(&queue);
	if (nitems == 0)
		return;
	changed = 0;
	mtime = queue[0]->q_time;
	for (i = argc; --i; ) {
		if (doarg(argv[i]) == 0) {
			printf("\tjob %s is not in the queue\n", argv[i]);
			continue;
		} else
			changed++;
	}
	for (i = 0; i < nitems; i++)
		free(queue[i]);
	free(queue);
	if (!changed) {
		printf("\tqueue order unchanged\n");
		return;
	}
	/*
	 * Turn on the public execute bit of the lock file to
	 * get lpd to rebuild the queue after the current job.
	 */
	PRIV_START;
	if (changed && stat(LO, &stbuf) >= 0) {
		stbuf.st_mode |= S_IXOTH;
		(void)chmod(LO, stbuf.st_mode & 0777);
	}

out:
	PRIV_END;
} 

/*
 * Reposition the job by changing the modification time of
 * the control file.
 */
static int
touch(struct queue *q)
{
	struct timeval tvp[2];
	int ret;

	tvp[0].tv_sec = tvp[1].tv_sec = --mtime;
	tvp[0].tv_usec = tvp[1].tv_usec = 0;
	PRIV_START;
	ret = utimes(q->q_name, tvp);
	PRIV_END;
	return (ret);
}

/*
 * Checks if specified job name is in the printer's queue.
 * Returns:  negative (-1) if argument name is not in the queue.
 */
int
doarg(char *job)
{
	struct queue **qq;
	int jobnum, fd, n;
	char *cp, *machine;
	int cnt = 0;
	FILE *fp;

	/*
	 * Look for a job item consisting of system name, colon, number 
	 * (example: ucbarpa:114)  
	 */
	if ((cp = strchr(job, ':')) != NULL) {
		machine = job;
		*cp++ = '\0';
		job = cp;
	} else
		machine = NULL;

	/*
	 * Check for job specified by number (example: 112 or 235ucbarpa).
	 */
	if (isdigit((unsigned char)*job)) {
		jobnum = 0;
		do
			jobnum = jobnum * 10 + (*job++ - '0');
		while (isdigit((unsigned char)*job));
		for (qq = queue + nitems; --qq >= queue; ) {
			n = 0;
			for (cp = (*qq)->q_name+3; isdigit((unsigned char)*cp); )
				n = n * 10 + (*cp++ - '0');
			if (jobnum != n)
				continue;
			if (*job && strcmp(job, cp) != 0)
				continue;
			if (machine != NULL && strcmp(machine, cp) != 0)
				continue;
			if (touch(*qq) == 0) {
				printf("\tmoved %s\n", (*qq)->q_name);
				cnt++;
			}
		}
		return(cnt);
	}
	/*
	 * Process item consisting of owner's name (example: henry).
	 */
	for (qq = queue + nitems; --qq >= queue; ) {
		PRIV_START;
		fd = safe_open((*qq)->q_name, O_RDONLY|O_NOFOLLOW, 0);
		PRIV_END;
		if (fd < 0 || (fp = fdopen(fd, "r")) == NULL) {
			if (fd >= 0)
				close(fd);
			continue;
		}
		while (get_line(fp) > 0)
			if (line[0] == 'P')
				break;
		(void)fclose(fp);
		if (line[0] != 'P' || strcmp(job, line+1) != 0)
			continue;
		if (touch(*qq) == 0) {
			printf("\tmoved %s\n", (*qq)->q_name);
			cnt++;
		}
	}
	return(cnt);
}

/*
 * Enable everything and start printer (undo `down').
 */
void
up(int argc, char **argv)
{
	int c, status;
	char *cp1, *cp2;
	char prbuf[100];

	if (argc == 1) {
		printf("usage: up {all | printer ...}\n");
		return;
	}
	if (argc == 2 && strcmp(argv[1], "all") == 0) {
		printer = prbuf;
		while (cgetnext(&bp, printcapdb) > 0) {
			cp1 = prbuf;
			cp2 = bp;
			while ((c = *cp2++) && c != '|' && c != ':' &&
			    (cp1 - prbuf) < sizeof(prbuf) - 1)
				*cp1++ = c;
			*cp1 = '\0';
			startpr(2);
		}
		return;
	}
	while (--argc) {
		printer = *++argv;
		if ((status = cgetent(&bp, printcapdb, printer)) == -2) {
			printf("cannot open printer description file\n");
			continue;
		} else if (status == -1) {
			printf("unknown printer %s\n", printer);
			continue;
		} else if (status == -3)
			fatal("potential reference loop detected in printcap file");

		startpr(2);
	}
}
@


1.26
log
@Fix fd leaks when fd < 0 or flock() fails. Original diff from
NetBSD via Loganaden Velvindron out of cppcheck.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.25 2013/11/24 21:32:32 deraadt Exp $	*/
a37 1
#include <sys/param.h>
d47 1
d192 1
a192 1
	char statfile[MAXPATHLEN];
@


1.25
log
@more ctype cleanups
checked by jca
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.24 2012/11/29 02:15:44 guenther Exp $	*/
d200 2
d598 2
a844 1
		(void)close(fd);	/* unlocks as well */
d846 2
@


1.24
log
@Change scandir()'s 'select' argument from
	int (*)(struct dirent *)
to
	int (*)(const struct dirent *)
to match POSIX.

ok millert@@, ports check by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.23 2012/03/22 01:44:19 guenther Exp $	*/
d1064 1
a1064 1
	if (isdigit(*job)) {
d1068 1
a1068 1
		while (isdigit(*job));
d1071 1
a1071 1
			for (cp = (*qq)->q_name+3; isdigit(*cp); )
@


1.23
log
@Update alphasort() and scandir()'s argument types to match POSIX:
use "const struct dirent **" instead of "const void *".  Also, add
__restrict to readdir_r().

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.22 2012/03/04 04:05:15 fgsch Exp $	*/
d62 1
a62 1
static int	doselect(struct dirent *);
d254 1
a254 1
doselect(struct dirent *d)
@


1.22
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.21 2009/10/29 20:11:09 sobrado Exp $	*/
d66 1
a66 1
static int	sortq(const void *, const void *);
d268 1
a268 1
sortq(const void *a, const void *b)
a269 1
	const struct dirent **d1, **d2;
a271 2
	d1 = (const struct dirent **)a;
	d2 = (const struct dirent **)b;
@


1.21
log
@it is possible specifying more than one printer concurrently; use
.Op macros for options instead of hardcoding brackets; remove a few
superfluous .Ar macros before ellipsis; "usage:" is lower case;
while here, apply some spacing tweaks.

tweaked by jmc@@ for a synopsis with too many arguments.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.20 2009/10/27 23:59:52 deraadt Exp $	*/
d168 1
a168 1
	if (!getline(fp) || flock(fileno(fp), LOCK_SH|LOCK_NB) == 0) {
d1101 1
a1101 1
		while (getline(fp) > 0)
@


1.20
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.19 2007/04/07 21:57:26 stevesk Exp $	*/
d84 1
a84 1
		printf("Usage: abort {all | printer ...}\n");
d222 1
a222 1
		printf("Usage: clean {all | printer ...}\n");
d378 1
a378 1
		printf("Usage: enable {all | printer ...}\n");
d446 1
a446 1
		printf("Usage: disable {all | printer ...}\n");
d524 1
a524 1
		printf("Usage: down {all | printer} [message ...]\n");
d643 1
a643 1
		printf("Usage: restart {all | printer ...}\n");
d687 1
a687 1
		printf("Usage: start {all | printer ...}\n");
d876 1
a876 1
		printf("Usage: stop {all | printer ...}\n");
d961 1
a961 1
		printf("Usage: topq printer [jobnum ...] [user ...]\n");
d1126 1
a1126 1
		printf("Usage: up {all | printer ...}\n");
@


1.19
log
@KNF, spaces; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.18 2003/06/02 23:36:53 millert Exp $	*/
a32 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)cmds.c	8.2 (Berkeley) 4/28/95";
#else
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.18 2003/06/02 23:36:53 millert Exp $";
#endif
#endif /* not lint */
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.17 2002/06/08 01:53:43 millert Exp $	*/
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.17 2002/06/08 01:53:43 millert Exp $";
d562 1
a562 1
			fatal("potential reference loop detected in printcap file");
@


1.17
log
@Remove setuid root from lp*.  lpr needs to be setuid daemon so the
files it creates are not owned by the user spooling them but the
others (lpc, lpq, lprm) can get away with setgid daemon.  lpd runs
as user daemon for most things, only changing its uid to 0 for
things that must be done as root.

For the time being, don't require connections to come from a reserved
port since lpq/lpr/lprm can't acquire that w/o setuid root.  In the
near future we will have a mechanism for select non-root processes
to grab reserved ports.

The upshot of this is that spool directories must be writable by
group daemon and the files within the spool dirs must be owned by
daemon.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.16 2002/05/20 23:13:50 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.16 2002/05/20 23:13:50 millert Exp $";
@


1.16
log
@Pull in useful bits from NetBSD and make our lp* easier to diff and
do some minor cleanup of my own:

o IPv6 support
o ANSI function headers
o use getopt()
o synce usage() with man pages
o passes -Wall on both 32bit and 64bit platforms
o add an option to set the max number of children lpd will fork off
o add an lpd option to bind to specific addresses instead of INADDR_ANY.
o allow user to specify how long to wait for a connection to remote servers
o more strlcpy() and snprintf() usage
o Use FOO_FILENO constants instead of hard-coding 0-2
o Add some keeps to man the page SYNOPSIS to avoid options being split
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.15 2002/02/16 21:28:03 millert Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.15 2002/02/16 21:28:03 millert Exp $";
a75 2
extern uid_t	uid, euid;

d146 1
a150 1
		seteuid(euid);
d152 2
a153 1
			if (chmod(line, (stbuf.st_mode & 0777) | 0100) < 0)
d160 2
a161 1
			if ((fd = open(line, O_WRONLY|O_CREAT, 0760)) < 0)
d164 1
d179 4
a182 1
	if ((fp = fopen(line, "r")) == NULL) {
d200 1
a200 1
	seteuid(uid);
d204 1
a204 1
 * Write a message into the status file.
d215 1
a215 2
	umask(0);
	fd = open(statfile, O_WRONLY|O_CREAT, 0664);
d220 1
d331 1
a331 1
	seteuid(euid);
d333 1
a333 1
	seteuid(uid);
d377 1
a377 1
	seteuid(euid);
d382 1
a382 1
	seteuid(uid);
d442 1
a442 1
	seteuid(euid);
d444 2
a445 1
		if (chmod(line, stbuf.st_mode & 0767) < 0)
d450 1
a450 1
	seteuid(uid);
d510 1
a510 1
	seteuid(euid);
d512 2
a513 1
		if (chmod(line, (stbuf.st_mode & 0777) | 010) < 0)
d518 1
a518 1
		if ((fd = open(line, O_WRONLY|O_CREAT, 0670)) < 0)
d521 1
d527 1
a527 1
	seteuid(uid);
d591 1
a591 1
	seteuid(euid);
d593 2
a594 1
		if (chmod(line, (stbuf.st_mode & 0777) | 0110) < 0)
d599 1
a599 1
		if ((fd = open(line, O_WRONLY|O_CREAT, 0770)) < 0)
d602 1
d606 1
a606 1
		seteuid(uid);
d614 1
a614 1
	fd = open(line, O_WRONLY|O_CREAT, 0664);
d617 1
a617 1
		seteuid(uid);
d620 2
a621 1
	seteuid(uid);
d750 1
d752 1
a752 1
	seteuid(euid);
d754 5
a758 1
		if (chmod(line, stbuf.st_mode & (enable==2 ? 0666 : 0677)) < 0)
d763 1
a767 1
	seteuid(uid);
d827 4
a830 1
	if (stat(line, &stbuf) >= 0) {
d839 4
a842 1
	if ((dirp = opendir(SD)) == NULL) {
d858 3
a860 1
	fd = open(line, O_RDONLY);
d868 3
a870 1
	fd = open(line, O_RDONLY);
d941 1
a941 1
	seteuid(euid);
d943 2
a944 1
		if (chmod(line, (stbuf.st_mode & 0777) | 0100) < 0)
d951 1
a951 1
		if ((fd = open(line, O_WRONLY|O_CREAT, 0760)) < 0)
d954 1
d961 1
a961 1
	seteuid(uid);
d1001 1
a1001 1
	seteuid(euid);
d1006 1
a1006 1
	seteuid(uid);
d1030 5
a1034 3
	seteuid(euid);
	if (changed && stat(LO, &stbuf) >= 0)
		(void)chmod(LO, (stbuf.st_mode & 0777) | 01);
d1037 1
a1037 1
	seteuid(uid);
d1052 1
a1052 1
	seteuid(euid);
d1054 1
a1054 1
	seteuid(uid);
d1066 1
a1066 1
	int jobnum, n;
d1111 6
a1116 4
		seteuid(euid);
		fp = fopen((*qq)->q_name, "r");
		seteuid(uid);
		if (fp == NULL)
d1118 1
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 2
a2 1
/*	$OpenBSD: cmds.c,v 1.14 2001/08/30 17:38:13 millert Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.14 2001/08/30 17:38:13 millert Exp $";
d78 14
a91 14
void	abortpr(int);
void	cleanpr(void);
void	disablepr(void);
int	doarg(char *);
int	doselect(struct dirent *);
void	enablepr(void);
void	prstat(void);
void	putmsg(int, char **);
int	sortq(const void *, const void *);
void	startpr(int);
void	stoppr(void);
int	touch(struct queue *);
void	unlinkf(char *);
void	upstat(char *);
d97 1
a97 3
doabort(argc, argv)
	int argc;
	char *argv[];
d107 1
a107 1
	if (argc == 2 && !strcmp(argv[1], "all")) {
d134 2
a135 3
void
abortpr(dis)
	int dis;
d145 1
a145 1
	(void) snprintf(line, sizeof(line), "%s/%s", SD, LO);
d164 1
a164 1
				(void) close(fd);
d183 1
a183 1
		(void) fclose(fp);	/* unlocks as well */
d187 1
a187 1
	(void) fclose(fp);
d202 2
a203 3
void
upstat(msg)
	char *msg;
d210 1
a210 1
	(void) snprintf(statfile, sizeof(statfile), "%s/%s", SD, ST);
d217 1
a217 1
	(void) ftruncate(fd, 0);
d219 1
a219 1
		(void) write(fd, "\n", 1);
d221 2
a222 2
		(void) write(fd, msg, strlen(msg));
	(void) close(fd);
d229 1
a229 3
clean(argc, argv)
	int argc;
	char *argv[];
d239 1
a239 1
	if (argc == 2 && !strcmp(argv[1], "all")) {
d267 2
a268 3
int
doselect(d)
	struct dirent *d;
d281 2
a282 3
int
sortq(a, b)
	const void *a, *b;
d284 1
a284 1
	struct dirent **d1, **d2;
d287 3
a289 3
	d1 = (struct dirent **)a;
	d2 = (struct dirent **)b;
	if ((c1 = strcmp((*d1)->d_name + 3, (*d2)->d_name + 3)))
d305 2
a306 2
void
cleanpr()
d317 3
a319 1
	for (lp = line, cp = SD; (lp - line) < sizeof(line) && (*lp++ = *cp++);)
d349 2
a350 2
				if (strlcpy(lp, cp, sizeof(line) - (lp - line)) >=
				    sizeof(line) - (lp - line))
d370 2
a371 3
void
unlinkf(name)
	char	*name;
d385 1
a385 3
enable(argc, argv)
	int argc;
	char *argv[];
d395 1
a395 1
	if (argc == 2 && !strcmp(argv[1], "all")) {
d423 2
a424 2
void
enablepr()
d432 1
a432 1
	(void) snprintf(line, sizeof(line), "%s/%s", SD, LO);
d452 1
a452 3
disable(argc, argv)
	int argc;
	char *argv[];
d462 1
a462 1
	if (argc == 2 && !strcmp(argv[1], "all")) {
d490 2
a491 2
void
disablepr()
d500 1
a500 1
	(void) snprintf(line, sizeof(line), "%s/%s", SD, LO);
d515 1
a515 1
			(void) close(fd);
d528 1
a528 3
down(argc, argv)
	int argc;
	char *argv[];
d538 1
a538 1
	if (!strcmp(argv[1], "all")) {
d564 2
a565 4
void
putmsg(argc, argv)
	int argc;
	char **argv;
d583 1
a583 1
	(void) snprintf(line, sizeof(line), "%s/%s", SD, LO);
d594 1
a594 1
			(void) close(fd);
d604 1
a604 1
	(void) snprintf(line, sizeof(line), "%s/%s", SD, ST);
d612 1
a612 1
	(void) ftruncate(fd, 0);
d614 2
a615 2
		(void) write(fd, "\n", 1);
		(void) close(fd);
d627 2
a628 2
	(void) write(fd, buf, strlen(buf));
	(void) close(fd);
d635 1
a635 3
quit(argc, argv)
	int argc;
	char *argv[];
d644 1
a644 3
restart(argc, argv)
	int argc;
	char *argv[];
d654 1
a654 1
	if (argc == 2 && !strcmp(argv[1], "all")) {
d688 1
a688 3
startcmd(argc, argv)
	int argc;
	char *argv[];
d698 1
a698 1
	if (argc == 2 && !strcmp(argv[1], "all")) {
d726 2
a727 3
void
startpr(enable)
	int enable;
d735 1
a735 1
	(void) snprintf(line, sizeof(line), "%s/%s", SD, LO);
d759 1
a759 3
status(argc, argv)
	int argc;
	char *argv[];
d765 1
a765 1
	if (argc == 1 || (argc == 2 && !strcmp(argv[1], "all"))) {
d796 2
a797 2
void
prstat()
d811 1
a811 1
	(void) snprintf(line, sizeof(line), "%s/%s", SD, LO);
d839 1
a839 1
		(void) close(fd);	/* unlocks as well */
d843 2
a844 3
	(void) close(fd);
	putchar('\t');
	(void) snprintf(line, sizeof(line), "%s/%s", SD, ST);
d847 7
a853 4
		(void) flock(fd, LOCK_SH);
		while ((i = read(fd, line, sizeof(line))) > 0)
			(void) fwrite(line, 1, i, stdout);
		(void) close(fd);	/* unlocks as well */
d862 1
a862 3
stop(argc, argv)
	int argc;
	char *argv[];
d872 1
a872 1
	if (argc == 2 && !strcmp(argv[1], "all")) {
d900 2
a901 2
void
stoppr()
d910 1
a910 1
	(void) snprintf(line, sizeof(line), "%s/%s", SD, LO);
d928 1
a928 1
			(void) close(fd);
d945 1
a945 3
topq(argc, argv)
	int argc;
	char *argv[];
d1005 1
a1005 1
		(void) chmod(LO, (stbuf.st_mode & 0777) | 01);
d1015 2
a1016 3
int
touch(q)
	struct queue *q;
d1034 1
a1034 2
doarg(job)
	char *job;
d1090 1
a1090 1
		(void) fclose(fp);
d1105 1
a1105 3
up(argc, argv)
	int argc;
	char *argv[];
d1115 1
a1115 1
	if (argc == 2 && !strcmp(argv[1], "all")) {
@


1.14
log
@o kill register
o add const to rcsid and copyright strings
o placate -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.13 2001/06/25 04:47:13 pjanzen Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.13 2001/06/25 04:47:13 pjanzen Exp $";
d77 14
a90 14
void	abortpr __P((int));
void	cleanpr __P((void));
void	disablepr __P((void));
int	doarg __P((char *));
int	doselect __P((struct dirent *));
void	enablepr __P((void));
void	prstat __P((void));
void	putmsg __P((int, char **));
int	sortq __P((const void *, const void *));
void	startpr __P((int));
void	stoppr __P((void));
int	touch __P((struct queue *));
void	unlinkf __P((char *));
void	upstat __P((char *));
@


1.13
log
@Fix a bunch of one-byte possible overflows
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.12 2001/06/25 04:08:35 pjanzen Exp $	*/
d38 1
a38 1
static char copyright[] =
d45 1
a45 1
static char sccsid[] = "@@(#)cmds.c	8.2 (Berkeley) 4/28/95";
d47 1
a47 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.12 2001/06/25 04:08:35 pjanzen Exp $";
d100 2
a101 2
	register int c, status;
	register char *cp1, *cp2;
d139 1
a139 1
	register FILE *fp;
d208 1
a208 1
	register int fd;
d236 2
a237 2
	register int c, status;
	register char *cp1, *cp2;
d315 2
a316 2
	register int i, n;
	register char *cp, *cp1, *lp;
d395 2
a396 2
	register int c, status;
	register char *cp1, *cp2;
d464 2
a465 2
	register int c, status;
	register char *cp1, *cp2;
d503 1
a503 1
	register int fd;
d542 2
a543 2
	register int c, status;
	register char *cp1, *cp2;
d581 2
a582 2
	register int fd;
	register char *cp1, *cp2;
d664 2
a665 2
	register int c, status;
	register char *cp1, *cp2;
d710 2
a711 2
	register int c, status;
	register char *cp1, *cp2;
d784 2
a785 2
	register int c, status;
	register char *cp1, *cp2;
d788 1
a788 1
	if (argc == 1 || argc == 2 && !strcmp(argv[1], "all")) {
d823 2
a824 2
	register int fd, i;
	register struct dirent *dp;
d887 2
a888 2
	register int c, status;
	register char *cp1, *cp2;
d926 1
a926 1
	register int fd;
d972 1
a972 1
	register int i;
d1063 3
a1065 3
	register struct queue **qq;
	register int jobnum, n;
	register char *cp, *machine;
d1136 2
a1137 2
	register int c, status;
	register char *cp1, *cp2;
@


1.12
log
@A little more careful with buffers, only relevant if /etc/printcap was set
up insanely wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.11 2001/06/22 15:27:20 lebel Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.11 2001/06/22 15:27:20 lebel Exp $";
d114 1
a114 1
			    (cp1 - prbuf) < sizeof(prbuf))
d250 1
a250 1
			    (cp1 - prbuf) < sizeof(prbuf))
d409 1
a409 1
			    (cp1 - prbuf) < sizeof(prbuf))
d478 1
a478 1
			    (cp1 - prbuf) < sizeof(prbuf))
d556 1
a556 1
			    (cp1 - prbuf) < sizeof(prbuf))
d635 1
a635 1
		while ((cp1 - buf) < sizeof(buf) && (*cp1++ = *cp2++))
d678 1
a678 1
			    (cp1 - prbuf) < sizeof(prbuf))
d724 1
a724 1
			    (cp1 - prbuf) < sizeof(prbuf))
d794 1
a794 1
			    (cp1 - prbuf) < sizeof(prbuf))
d901 1
a901 1
			    (cp1 - prbuf) < sizeof(prbuf))
d1150 1
a1150 1
			    (cp1 - prbuf) < sizeof(prbuf))
@


1.11
log
@use strlcpy vs strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.10 2000/11/21 07:22:53 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.10 2000/11/21 07:22:53 deraadt Exp $";
d327 4
d354 5
a358 2
				strlcpy(lp, cp, sizeof(line) - strlen(line));
				unlinkf(line);
d366 5
a370 2
			strlcpy(lp, cp, sizeof(line) - strlen(line));
			unlinkf(line);
@


1.10
log
@sigjmp & statics begone
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.9 1997/07/25 18:57:24 grr Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.9 1997/07/25 18:57:24 grr Exp $";
d350 1
a350 2
				strncpy(lp, cp, sizeof(line) - strlen(line) - 1);
				line[sizeof(line) - 1] = '\0';
d359 1
a359 2
			strncpy(lp, cp, sizeof(line) - strlen(line) - 1);
			line[sizeof(line) - 1] = '\0';
@


1.9
log
@restore traditional "all" keyword option - see lpc(8)
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.8 1997/01/17 16:12:35 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.8 1997/01/17 16:12:35 millert Exp $";
d77 14
a90 14
static void	abortpr __P((int));
static void	cleanpr __P((void));
static void	disablepr __P((void));
static int	doarg __P((char *));
static int	doselect __P((struct dirent *));
static void	enablepr __P((void));
static void	prstat __P((void));
static void	putmsg __P((int, char **));
static int	sortq __P((const void *, const void *));
static void	startpr __P((int));
static void	stoppr __P((void));
static int	touch __P((struct queue *));
static void	unlinkf __P((char *));
static void	upstat __P((char *));
d135 1
a135 1
static void
d204 1
a204 1
static void
d272 1
a272 1
static int
d287 1
a287 1
static int
d312 1
a312 1
static void
d367 1
a367 1
static void
d423 1
a423 1
static void
d492 1
a492 1
static void
d568 1
a568 1
static void
d738 1
a738 1
static void
d811 1
a811 1
static void
d915 1
a915 1
static void
d1032 1
a1032 1
static int
d1051 1
a1051 1
static int
@


1.8
log
@Add OpenBSD tags (was in wrong dir for previous commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: $";
d780 1
a780 1
	if (argc == 1) {
@


1.7
log
@possible oflow
@
text
@d1 2
d44 1
d46 3
@


1.6
log
@Improve portability by using ANSI/POSIX interfaces when possible.
@
text
@d344 2
a345 1
				strcpy(lp, cp);
d354 2
a355 1
			strcpy(lp, cp);
@


1.5
log
@buf oflows pendantry
@
text
@d184 6
a189 3
	if (kill(pid = atoi(line), SIGTERM) < 0)
		printf("\tWarning: daemon (pid %d) not killed\n", pid);
	else
d1057 1
a1057 1
	if ((cp = index(job, ':')) != NULL) {
@


1.4
log
@hate warnings, kill warnings
@
text
@d107 2
a108 1
			while ((c = *cp2++) && c != '|' && c != ':')
d141 1
a141 1
	(void) sprintf(line, "%s/%s", SD, LO);
d200 1
a200 1
	char statfile[BUFSIZ];
d204 1
a204 1
	(void) sprintf(statfile, "%s/%s", SD, ST);
d240 2
a241 1
			while ((c = *cp2++) && c != '|' && c != ':')
d315 1
a315 1
	for (lp = line, cp = SD; (*lp++ = *cp++); )
d389 2
a390 1
			while ((c = *cp2++) && c != '|' && c != ':')
d421 1
a421 1
	(void) sprintf(line, "%s/%s", SD, LO);
d458 2
a459 1
			while ((c = *cp2++) && c != '|' && c != ':')
d491 1
a491 1
	(void) sprintf(line, "%s/%s", SD, LO);
d536 2
a537 1
			while ((c = *cp2++) && c != '|' && c != ':')
d578 1
a578 1
	(void) sprintf(line, "%s/%s", SD, LO);
d599 1
a599 1
	(void) sprintf(line, "%s/%s", SD, ST);
d616 1
a616 1
		while ((*cp1++ = *cp2++))
d658 2
a659 1
			while ((c = *cp2++) && c != '|' && c != ':')
d704 2
a705 1
			while ((c = *cp2++) && c != '|' && c != ':')
d737 1
a737 1
	(void) sprintf(line, "%s/%s", SD, LO);
d774 2
a775 1
			while ((c = *cp2++) && c != '|' && c != ':')
d815 1
a815 1
	(void) sprintf(line, "%s/%s", SD, LO);
d849 1
a849 1
	(void) sprintf(line, "%s/%s", SD, ST);
d881 2
a882 1
			while ((c = *cp2++) && c != '|' && c != ':')
d914 1
a914 1
	(void) sprintf(line, "%s/%s", SD, LO);
d1130 2
a1131 1
			while ((c = *cp2++) && c != '|' && c != ':')
@


1.3
log
@Integrated 4.4Lite2 source
Fixed potential problem pointed out by bitblt
@
text
@d134 1
a134 1
	int pid, fd, ret;
d285 1
a285 1
	if (c1 = strcmp((*d1)->d_name + 3, (*d2)->d_name + 3))
d313 1
a313 1
	for (lp = line, cp = SD; *lp++ = *cp++; )
d611 1
a611 1
		while (*cp1++ = *cp2++)
@


1.2
log
@from netbsd; More descriptive message for printer status. Addresses PR #509
@
text
@d42 1
a42 1
static char sccsid[] = "@@(#)cmds.c	8.1 (Berkeley) 6/6/93";
d52 1
@


1.1
log
@Initial revision
@
text
@d835 1
a835 1
		printf("\tno daemon present\n");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
