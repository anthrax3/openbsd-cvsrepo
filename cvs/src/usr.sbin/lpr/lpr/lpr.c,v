head	1.48;
access;
symbols
	OPENBSD_6_2_BASE:1.48
	OPENBSD_6_1:1.48.0.12
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.48.0.8
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.4
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.48.0.6
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.43.0.4
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.2
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.42.0.12
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.10
	OPENBSD_5_0:1.42.0.8
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.6
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.42.0.4
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.42.0.2
	OPENBSD_4_7_BASE:1.42
	OPENBSD_4_6:1.41.0.12
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.8
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.41.0.6
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.4
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.41.0.2
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.40.0.2
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.38.0.4
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.36.0.4
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.36.0.2
	OPENBSD_3_6_BASE:1.36
	OPENBSD_3_5:1.34.0.4
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	OPENBSD_3_3:1.31.0.2
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_9:1.19.0.16
	OPENBSD_2_8:1.19.0.14
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.19.0.12
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.19.0.10
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.19.0.8
	OPENBSD_2_5_BASE:1.19
	OPENBSD_2_4:1.19.0.6
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.19.0.4
	OPENBSD_2_3_BASE:1.19
	OPENBSD_2_2:1.19.0.2
	OPENBSD_2_2_BASE:1.19
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2015.02.09.23.00.14;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	822YD61EeG0Xl9Na;

1.47
date	2015.01.16.06.40.18;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	Uu5nFG3wCl0LACBb;

1.46
date	2014.05.20.01.25.24;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2013.11.24.21.32.32;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2013.08.08.03.16.14;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2013.02.15.08.28.08;	author mpi;	state Exp;
branches;
next	1.42;

1.42
date	2009.10.27.23.59.52;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2007.04.07.21.57.27;	author stevesk;	state Exp;
branches;
next	1.40;

1.40
date	2007.03.06.11.11.53;	author jmc;	state Exp;
branches;
next	1.39;

1.39
date	2006.10.11.20.56.59;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.12.00.54.15;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.25.16.54.17;	author jaredy;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.10.16.09.06;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.14.20.52.20;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.02.23.36.53;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.19.00.33.23;	author pjanzen;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.27.23.45.14;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.25.02.15.21;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.11.04.36.55;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.08.23.28.15;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.19.01.24.14;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.09.03.56.29;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.08.01.53.43;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.20.23.13.50;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.16.21.28.04;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.06.03.12.31;	author ericj;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.23.03.58.18;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.19.20.26.51;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.30.17.38.13;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.07.25.20.12.13;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.07.19.07.11.44;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.07.09.00.16.12;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.07.08.18.25.42;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.06.23.23.13.58;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	97.06.20.17.46.16;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	97.06.20.17.45.14;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	97.01.17.16.12.46;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	96.11.04.18.13.38;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	96.11.03.23.24.12;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.08.13.18.13.29;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.08.13.17.51.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.07.04.06.06.51;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.07.04.05.41.57;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.05.15.13.41.58;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	96.05.06.06.40.13;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	96.05.04.11.52.55;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.40.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.48
log
@clean up flags++ instances around getopt()
ok florian
@
text
@/*	$OpenBSD: lpr.c,v 1.47 2015/01/16 06:40:18 deraadt Exp $ */
/*	$NetBSD: lpr.c,v 1.19 2000/10/11 20:23:52 is Exp $	*/

/*
 * Copyright (c) 1983, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 *      lpr -- off line print
 *
 * Allows multiple printers and printers on remote machines by
 * using information from a printer data base.
 */

#include <sys/stat.h>
#include <sys/file.h>

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <syslog.h>
#include <pwd.h>
#include <grp.h>
#include <unistd.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <err.h>

#include "lp.h"
#include "lp.local.h"
#include "pathnames.h"

static char	*cfname;	/* daemon control files, linked from tf's */
static char	*class = host;	/* class title on header page */
static char	*dfname;	/* data files */
static char	*fonts[4];	/* troff font names */
static char	 format = 'f';	/* format char for printing files */
static int	 hdr = 1;	/* print header or not (default is yes) */
static int	 iflag;		/* indentation wanted */
static int	 inchar;	/* location to increment char in file names */
static int	 indent;	/* amount to indent */
static char	*jobname;	/* job name on header page */
static int	 mailflg;	/* send mail */
static int	 nact;		/* number of jobs to act on */
static int	 ncopies = 1;	/* # of copies to make */
static const char *person;	/* user name */
static int	 qflag;		/* q job, but don't exec daemon */
static int	 rflag;		/* remove files upon completion */	
static int	 sflag;		/* symbolic link flag */
static int	 tfd;		/* control file descriptor */
static char	*tfname;	/* tmp copy of cf before linking */
static char	*title;		/* pr'ing title */
static char	*width;		/* width for versatec printing */

static struct stat statb;

volatile sig_atomic_t gotintr;

static void	 card(int, const char *);
static void	 chkprinter(char *);
static void	 cleanup(int);
static void	 copy(int, char *);
static char	*itoa(int);
static char	*linked(char *);
static char	*lmktemp(char *, int);
static void	 mktemps(void);
static int	 nfile(char *);
static int	 test(char *);
static __dead void usage(void);

int
main(int argc, char **argv)
{
	struct passwd *pw;
	struct group *gptr;
	char *arg, *cp;
	char buf[PATH_MAX];
	int i, f, ch;
	struct stat stb;

	/*
	 * Simulate setuid daemon w/ PRIV_END called.
	 * We don't want lpr to actually be setuid daemon since that
	 * requires that the lpr binary be owned by user daemon, which
	 * is potentially unsafe.
	 */
	if ((pw = getpwuid(DEFUID)) == NULL)
		errx(1, "daemon uid (%u) not in password file", DEFUID);
	effective_uid = pw->pw_uid;
	real_uid = getuid();
	effective_gid = pw->pw_gid;
	real_gid = getgid();
	setresgid(real_gid, real_gid, effective_gid);
	setresuid(real_uid, real_uid, effective_uid);

	if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
		signal(SIGHUP, cleanup);
	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		signal(SIGINT, cleanup);
	if (signal(SIGQUIT, SIG_IGN) != SIG_IGN)
		signal(SIGQUIT, cleanup);
	if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
		signal(SIGTERM, cleanup);

	gethostname(host, sizeof (host));
	openlog("lpr", 0, LOG_LPR);

	while ((ch = getopt(argc, argv,
	    ":#:1:2:3:4:C:J:P:T:U:cdfghi:lmnpqrstvw:")) != -1) {
		switch (ch) {

		case '#':		/* n copies */
			if (isdigit((unsigned char)*optarg)) {
				i = atoi(optarg);
				if (i > 0)
					ncopies = i;
			}
			break;

		case '4':		/* troff fonts */
		case '3':
		case '2':
		case '1':
			fonts[ch - '1'] = optarg;
			break;

		case 'C':		/* classification spec */
			hdr++;
			class = optarg;
			break;

		case 'J':		/* job name */
			hdr++;
			jobname = optarg;
			break;

		case 'P':		/* specifiy printer name */
			printer = optarg;
			break;

		case 'T':		/* pr's title line */
			title = optarg;
			break;

		case 'U':		/* user name */
			hdr++;
			person = optarg;
			break;

		case 'c':		/* print cifplot output */
		case 'd':		/* print tex output (dvi files) */
		case 'g':		/* print graph(1G) output */
		case 'l':		/* literal output */
		case 'n':		/* print ditroff output */
		case 'p':		/* print using ``pr'' */
		case 't':		/* print troff output (cat files) */
		case 'v':		/* print vplot output */
			format = ch;
			break;

		case 'f':		/* print fortran output */
			format = 'r';
			break;

		case 'h':		/* toggle want of header page */
			hdr = !hdr;
			break;

		case 'i':		/* indent output */
			iflag++;
			indent = atoi(optarg);
			if (indent < 0)
				indent = 8;
			break;

		case 'm':		/* send mail when done */
			mailflg = 1;
			break;

		case 'q':		/* just q job */
			qflag = 1;
			break;

		case 'r':		/* remove file when done */
			rflag = 1;
			break;

		case 's':		/* try to link files */
			sflag = 1;
			break;

		case 'w':		/* versatec page width */
			width = optarg;
			break;

		case ':':               /* catch "missing argument" error */
			if (optopt == 'i') {
				iflag++; /* -i without args is valid */
				indent = 8;
			} else
				usage();
			break;

		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;
	if (printer == NULL && (printer = getenv("PRINTER")) == NULL)
		printer = DEFLP;
	chkprinter(printer);
	if (SC && ncopies > 1)
		errx(1, "multiple copies are not allowed");
	if (MC > 0 && ncopies > MC)
		errx(1, "only %ld copies are allowed", MC);
	/*
	 * Get the identity of the person doing the lpr using the same
	 * algorithm as lprm. 
	 */
	if (real_uid != DU || person == NULL) {
		if ((pw = getpwuid(real_uid)) == NULL)
			errx(1, "Who are you?");
		if ((person = strdup(pw->pw_name)) == NULL)
			err(1, NULL);
	}
	/*
	 * Check for restricted group access.
	 */
	if (RG != NULL && real_uid != DU) {
		if ((gptr = getgrnam(RG)) == NULL)
			errx(1, "Restricted group specified incorrectly");
		if (gptr->gr_gid != getgid()) {
			while (*gptr->gr_mem != NULL) {
				if ((strcmp(person, *gptr->gr_mem)) == 0)
					break;
				gptr->gr_mem++;
			}
			if (*gptr->gr_mem == NULL)
				errx(1, "Not a member of the restricted group");
		}
	}
	/*
	 * Check to make sure queuing is enabled if real_uid is not root.
	 */
	(void)snprintf(buf, sizeof(buf), "%s/%s", SD, LO);
	if (real_uid && stat(buf, &stb) == 0 && (stb.st_mode & 010))
		errx(1, "Printer queue is disabled");
	/*
	 * Initialize the control file.
	 */
	mktemps();
	tfd = nfile(tfname);
	card('H', host);
	card('P', person);
	if (hdr) {
		if (jobname == NULL) {
			if (argc == 0)
				jobname = "stdin";
			else
				jobname = (arg = strrchr(argv[0], '/')) ?
				    arg + 1 : argv[0];
		}
		card('J', jobname);
		card('C', class);
		if (!SH)
			card('L', person);
	}
	if (iflag)
		card('I', itoa(indent));
	if (mailflg)
		card('M', person);
	if (format == 't' || format == 'n' || format == 'd')
		for (i = 0; i < 4; i++)
			if (fonts[i] != NULL)
				card('1'+i, fonts[i]);
	if (width != NULL)
		card('W', width);

	/*
	 * Read the files and spool them.
	 */
	if (argc == 0)
		copy(0, " ");
	else while (argc--) {
		if (argv[0][0] == '-' && argv[0][1] == '\0') {
			/* use stdin */
			copy(0, " ");
			argv++;
			continue;
		}
		if ((f = test(arg = *argv++)) < 0)
			continue;	/* file unreasonable */

		if (sflag && (cp = linked(arg)) != NULL) {
			(void)snprintf(buf, sizeof(buf), "%d %llu",
			    statb.st_dev, (unsigned long long)statb.st_ino);
			card('S', buf);
			if (format == 'p')
				card('T', title ? title : arg);
			for (i = 0; i < ncopies; i++)
				card(format, &dfname[inchar-2]);
			card('U', &dfname[inchar-2]);
			if (f)
				card('U', cp);
			card('N', arg);
			dfname[inchar]++;
			nact++;
			continue;
		}
		if (sflag)
			warnx("%s: not linked, copying instead", arg);
		if ((i = safe_open(arg, O_RDONLY, 0)) < 0)
			warn("%s", arg);
		else {
			copy(i, arg);
			(void)close(i);
			if (f && unlink(arg) < 0)
				warnx("%s: not removed", arg);
		}
	}

	if (nact) {
		(void)close(tfd);
		tfname[inchar]--;
		/*
		 * Touch the control file to fix position in the queue.
		 */
		PRIV_START;
		if ((tfd = safe_open(tfname, O_RDWR|O_NOFOLLOW, 0)) >= 0) {
			char c;

			if (read(tfd, &c, 1) == 1 &&
			    lseek(tfd, (off_t)0, SEEK_SET) == 0 &&
			    write(tfd, &c, 1) != 1) {
				warn("%s", tfname);
				tfname[inchar]++;
				cleanup(0);
			}
			(void)close(tfd);
		}
		if (link(tfname, cfname) < 0) {
			warn("cannot rename %s", cfname);
			tfname[inchar]++;
			cleanup(0);
		}
		unlink(tfname);
		PRIV_END;
		if (qflag)		/* just q things up */
			exit(0);
		if (!startdaemon(printer))
			printf("jobs queued, but cannot start daemon.\n");
		exit(0);
	}
	cleanup(0);
	return (1);
	/* NOTREACHED */
}

/*
 * Create the file n and copy from file descriptor f.
 */
static void
copy(int f, char *n)
{
	int fd, i, nr, nc;
	char buf[BUFSIZ];

	if (format == 'p')
		card('T', title ? title : n);
	for (i = 0; i < ncopies; i++)
		card(format, &dfname[inchar-2]);
	card('U', &dfname[inchar-2]);
	card('N', n);
	fd = nfile(dfname);
	nr = nc = 0;
	while ((i = read(f, buf, sizeof(buf))) > 0) {
		if (write(fd, buf, i) != i) {
			warn("%s", n);
			break;
		}
		nc += i;
		if (nc >= sizeof(buf)) {
			nc -= sizeof(buf);
			nr++;
			if (MX > 0 && nr > MX) {
				warnx("%s: copy file is too large", n);
				break;
			}
		}
	}
	(void)close(fd);
	if (nc == 0 && nr == 0) 
		warnx("%s: empty input file", f ? n : "stdin");
	else
		nact++;
}

/*
 * Try and link the file to dfname. Return a pointer to the full
 * path name if successful.
 */
static char *
linked(char *file)
{
	char *cp;
	static char buf[PATH_MAX];
	int ret;

	if (*file != '/') {
		if (getcwd(buf, sizeof(buf)) == NULL)
			return(NULL);

		while (file[0] == '.') {
			switch (file[1]) {
			case '/':
				file += 2;
				continue;
			case '.':
				if (file[2] == '/') {
					if ((cp = strrchr(buf, '/')) != NULL)
						*cp = '\0';
					file += 3;
					continue;
				}
			}
			break;
		}
		if (strlcat(buf, "/", sizeof(buf)) >= sizeof(buf) ||
		    strlcat(buf, file, sizeof(buf)) >= sizeof(buf))
			return(NULL);
		file = buf;
	}
	PRIV_START;
	ret = symlink(file, dfname);
	PRIV_END;
	return(ret ? NULL : file);
}

/*
 * Put a line into the control file.
 */
static void
card(int c, const char *p2)
{
	char buf[BUFSIZ];
	char *p1 = buf;
	int len = 2;

	if (strlen(p2) > sizeof(buf) - 2)
		errx(1, "Internal error:  String longer than %ld",
		    (long)sizeof(buf));

	*p1++ = c;
	while ((c = *p2++) != '\0' && len < sizeof(buf)) {
		*p1++ = (c == '\n') ? ' ' : c;
		len++;
	}
	*p1++ = '\n';
	write(tfd, buf, len);
}

/*
 * Create a new file in the spool directory.
 */
static int
nfile(char *n)
{
	int f;
	int oldumask = umask(0);		/* should block signals */

	PRIV_START;
	f = open(n, O_WRONLY|O_EXCL|O_CREAT, FILMOD);
	(void)umask(oldumask);
	if (f < 0) {
		warn("%s", n);
		cleanup(0);
	}
	PRIV_END;
	if (++n[inchar] > 'z') {
		if (++n[inchar-2] == 't') {
			warnx("too many files - break up the job");
			cleanup(0);
		}
		n[inchar] = 'A';
	} else if (n[inchar] == '[')
		n[inchar] = 'a';
	return (f);
}

/*
 * Cleanup after interrupts and errors.
 */
static void
cleanup(int signo)
{
	int i;

	signal(SIGHUP, SIG_IGN);
	signal(SIGINT, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
	signal(SIGTERM, SIG_IGN);
	i = inchar;
	PRIV_START;
	if (tfname)
		do
			unlink(tfname);
		while (tfname[i]-- != 'A');
	if (cfname)
		do
			unlink(cfname);
		while (cfname[i]-- != 'A');
	if (dfname)
		do {
			do
				unlink(dfname);
			while (dfname[i]-- != 'A');
			dfname[i] = 'z';
		} while (dfname[i-2]-- != 'd');
	_exit(1);
}

/*
 * Test to see if this is a printable file.
 * Return -1 if it is not, 0 if its printable, and 1 if
 * we should remove it after printing.
 */
static int
test(char *file)
{
	int fd;
	char *cp;

	if ((fd = open(file, O_RDONLY|O_NONBLOCK)) < 0) {
		warn("cannot open %s", file);
		goto bad;
	}
	if (fstat(fd, &statb) < 0) {
		warn("cannot stat %s", file);
		goto bad;
	}
	if (S_ISDIR(statb.st_mode)) {
		warnx("%s is a directory", file);
		goto bad;
	}
	if (!S_ISREG(statb.st_mode)) {
		warnx("%s is not a regular file", file);
		goto bad;
	}
	if (statb.st_size == 0) {
		warnx("%s is an empty file", file);
		goto bad;
 	}
	(void)close(fd);
	if (rflag) {
		if ((cp = strrchr(file, '/')) == NULL) {
			if (access(".", 2) == 0)
				return(1);
		} else {
			if (cp == file) {
				fd = access("/", 2);
			} else {
				*cp = '\0';
				fd = access(file, 2);
				*cp = '/';
			}
			if (fd == 0)
				return(1);
		}
		warnx("%s is not removable by you", file);
	}
	return(0);
bad:
	return(-1);
}

/*
 * itoa - integer to string conversion
 */
static char *
itoa(int i)
{
	static char b[10] = "########";
	char *p;

	p = &b[8];
	do
		*p-- = i%10 + '0';
	while (i /= 10)
		;
	return(++p);
}

/*
 * Perform lookup for printer name or abbreviation --
 */
static void
chkprinter(char *s)
{
	int status;

	if ((status = cgetent(&bp, printcapdb, s)) == -2)
		errx(1, "cannot open printer description file");
	else if (status == -1)
		errx(1, "%s: unknown printer", s);
	if (cgetstr(bp, "sd", &SD) == -1)
		SD = _PATH_DEFSPOOL;
	if (cgetstr(bp, "lo", &LO) == -1)
		LO = DEFLOCK;
	cgetstr(bp, "rg", &RG);
	if (cgetnum(bp, "mx", &MX) < 0)
		MX = DEFMX;
	if (cgetnum(bp, "mc", &MC) < 0)
		MC = DEFMAXCOPIES;
	if (cgetnum(bp, "du", &DU) < 0)
		DU = DEFUID;
	SC = (cgetcap(bp, "sc", ':') != NULL);
	SH = (cgetcap(bp, "sh", ':') != NULL);
}

/*
 * Make the temp files.
 */
static void
mktemps(void)
{
	int len, fd, n;
	char *cp;
	char buf[BUFSIZ];
	struct stat stb;

	if (snprintf(buf, sizeof(buf), "%s/.seq", SD) >= sizeof(buf))
		errc(1, ENAMETOOLONG, "%s/.seq", SD);
	PRIV_START;
	if ((fd = safe_open(buf, O_RDWR|O_CREAT|O_NOFOLLOW, 0661)) < 0)
		err(1, "cannot open %s", buf);
	if (flock(fd, LOCK_EX))
		err(1, "cannot lock %s", buf);
	PRIV_END;
	n = 0;
	if ((len = read(fd, buf, sizeof(buf))) > 0) {
		for (cp = buf; len--; ) {
			if (*cp < '0' || *cp > '9')
				break;
			n = n * 10 + (*cp++ - '0');
		}
	}
	do {
		tfname = lmktemp("tf", n);
		cfname = lmktemp("cf", n);
		dfname = lmktemp("df", n);
		n = (n + 1) % 1000;
	} while (stat(tfname, &stb) == 0 || stat(cfname, &stb) == 0 ||
	    stat(dfname, &stb) == 0);
	inchar = strlen(SD) + 3;
	(void)lseek(fd, (off_t)0, SEEK_SET);
	snprintf(buf, sizeof(buf), "%03d\n", n);
	(void)write(fd, buf, strlen(buf));
	(void)close(fd);	/* unlocks as well */
}

/*
 * Make a temp file name.
 */
static char *
lmktemp(char *id, int num)
{
	char *s;

	if (asprintf(&s, "%s/%sA%03d%s", SD, id, num, host) == -1)
		err(1, NULL);

	return(s);
}

static __dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-cdfghlmnpqrstv] [-#num] [-1234 font] "
	    "[-C class] [-i [numcols]]\n"
	    "\t[-J job] [-Pprinter] [-T title] [-U user] "
	    "[-wnum] [name ...]\n", __progname);
	exit(1);
}
@


1.47
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.46 2014/05/20 01:25:24 guenther Exp $ */
d212 1
a212 1
			mailflg++;
d216 1
a216 1
			qflag++;
d220 1
a220 1
			rflag++;
d224 1
a224 1
			sflag++;
@


1.46
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.45 2013/11/24 21:32:32 deraadt Exp $ */
a45 1
#include <sys/param.h>
d57 1
d112 1
a112 1
	char buf[MAXPATHLEN];
d442 1
a442 1
	static char buf[MAXPATHLEN];
@


1.45
log
@more ctype cleanups
checked by jca
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.44 2013/08/08 03:16:14 guenther Exp $ */
d668 1
a668 1
		errx(1, "%s/.seq: %s", SD, strerror(ENAMETOOLONG));
@


1.44
log
@Prep for big ino_t: cast to unsigned long long and format with %ll or %q

httpd correction and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.43 2013/02/15 08:28:08 mpi Exp $ */
d148 1
a148 1
			if (isdigit(*optarg)) {
@


1.43
log
@Add missing break, reported by Jared S. Candelaria.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.42 2009/10/27 23:59:52 deraadt Exp $ */
d331 2
a332 2
			(void)snprintf(buf, sizeof(buf), "%d %d",
			    statb.st_dev, statb.st_ino);
@


1.42
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.41 2007/04/07 21:57:27 stevesk Exp $ */
d153 1
@


1.41
log
@KNF, spaces; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.40 2007/03/06 11:11:53 jmc Exp $ */
a37 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)lpr.c	8.4 (Berkeley) 4/28/95";
#else
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.40 2007/03/06 11:11:53 jmc Exp $";
#endif
#endif /* not lint */
@


1.40
log
@tidy up synopsis, usage(), and options list; from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.39 2006/10/11 20:56:59 deraadt Exp $ */
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.39 2006/10/11 20:56:59 deraadt Exp $";
d441 1
a441 1
	if (nc==0 && nr==0) 
d661 1
a661 1
	if (cgetnum(bp,"mc", &MC) < 0)
@


1.39
log
@use SEEK_SET; chl@@tuxfamily.org
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.38 2005/11/12 00:54:15 deraadt Exp $ */
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.38 2005/11/12 00:54:15 deraadt Exp $";
d730 4
a733 3
	    "usage: %s [-cdfghlmnpqrstv] [-Pprinter] [-#num] [-C class] "
	    "[-J job] [-T title]\n           [-U user] [-i [numcols]] "
	    "[-1234 font] [-wnum] [name ...]\n", __progname);
@


1.38
log
@use asprintf instead; dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.37 2005/03/25 16:54:17 jaredy Exp $ */
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.37 2005/03/25 16:54:17 jaredy Exp $";
d382 1
a382 1
			    lseek(tfd, (off_t)0, 0) == 0 &&
d704 1
a704 1
	(void)lseek(fd, (off_t)0, 0);
@


1.37
log
@Use the return value from getopt() instead of optopt in non-error
cases since optopt is not set in these cases, and it is not required
by POSIX that it should be.

ok millert otto
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.36 2004/05/10 16:09:06 otto Exp $ */
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.36 2004/05/10 16:09:06 otto Exp $";
d114 1
a114 1
static char	*lmktemp(char *, int, int);
a695 1
	len = strlen(SD) + strlen(host) + 8;
d697 3
a699 3
		tfname = lmktemp("tf", n, len);
		cfname = lmktemp("cf", n, len);
		dfname = lmktemp("df", n, len);
d714 1
a714 1
lmktemp(char *id, int num, int len)
d718 1
a718 1
	if ((s = malloc(len)) == NULL)
d720 1
a720 1
	(void)snprintf(s, len, "%s/%sA%03d%s", SD, id, num, host);
@


1.36
log
@Do not always print banner page.
ok henning@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.35 2004/04/14 20:52:20 millert Exp $ */
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.35 2004/04/14 20:52:20 millert Exp $";
d172 1
a172 1
			fonts[optopt - '1'] = optarg;
d206 1
a206 1
			format = optopt;
@


1.35
log
@Pass the job name to the input filter via the -j flag.  Some filters
(like foomatic) expect to be able to pass information from lpr via
the job name.  OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.34 2003/06/02 23:36:53 millert Exp $ */
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.34 2003/06/02 23:36:53 millert Exp $";
d314 2
a315 1
		card('L', person);
@


1.34
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.33 2003/05/19 00:33:23 pjanzen Exp $ */
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.33 2003/05/19 00:33:23 pjanzen Exp $";
d304 1
a304 1
	if (hdr && !SH) {
@


1.33
log
@No longer complain about printing a.out files; this sort of detection really
belongs in lpd filters.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.32 2003/03/27 23:45:14 millert Exp $ */
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d49 1
a49 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.32 2003/03/27 23:45:14 millert Exp $";
@


1.32
log
@Add -q to the getopt() string and document it; Brian Ginsbach
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.31 2003/03/25 02:15:21 millert Exp $ */
d53 1
a53 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.31 2003/03/25 02:15:21 millert Exp $";
a70 1
#include <a.out.h>
a581 1
	struct exec execb;
a604 7
	if (read(fd, &execb, sizeof(execb)) == sizeof(execb) &&
	    !N_BADMAG(execb)) {
			warnx("%s is an executable program and is unprintable",
				file);
			(void)close(fd);
			goto bad;
	}
@


1.31
log
@Fix last commit; to emulate setuid daemon + PRIV_END we need to
set the real & effective uids to the calling user and the saved
uid to daemon.  Fixes a problem where lpr could not print files
that were not world-readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.30 2003/03/11 04:36:55 millert Exp $ */
d53 1
a53 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.30 2003/03/11 04:36:55 millert Exp $";
d163 1
a163 1
	    ":#:1:2:3:4:C:J:P:T:U:cdfghi:lnmprstvw:")) != -1) {
d743 1
a743 1
	    "usage: %s [-cdfghlnmprstv] [-Pprinter] [-#num] [-C class] "
@


1.30
log
@Make lpr and lprm setuid root but drop to daemon very early.
Functionally this is the same as when lpr and lprm were setuid
daemon but the executable are now owned by root which is safer.
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.29 2003/03/08 23:28:15 millert Exp $ */
d53 1
a53 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.29 2003/03/08 23:28:15 millert Exp $";
d136 1
a136 1
	 * Simulate setuid daemon but with real and effective swapped.
d147 2
a148 2
	setresgid(effective_gid, real_gid, effective_gid);
	setresuid(effective_uid, real_uid, effective_uid);
@


1.29
log
@Honor the :sh: flag in the local printcap for remote printers too
instead of forcing the user to use lpr's "-h" flag.
Adapted from a patch in FreeBSD from Scott James Remnant.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.28 2002/06/19 01:24:14 deraadt Exp $ */
d53 1
a53 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.28 2002/06/19 01:24:14 deraadt Exp $";
d135 9
a143 1
	effective_uid = geteuid();
d145 1
a145 1
	effective_gid = getegid();
d147 2
a148 1
	PRIV_END;	/* be safe */
@


1.28
log
@stretch some ugly while();
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.27 2002/06/09 03:56:29 millert Exp $ */
d53 1
a53 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.27 2002/06/09 03:56:29 millert Exp $";
d300 1
a300 1
	if (hdr) {
d669 1
@


1.27
log
@Convert remaining K&R function headers to ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.26 2002/06/08 01:53:43 millert Exp $ */
d53 1
a53 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.26 2002/06/08 01:53:43 millert Exp $";
d640 2
a641 1
	while (i /= 10);
@


1.26
log
@Remove setuid root from lp*.  lpr needs to be setuid daemon so the
files it creates are not owned by the user spooling them but the
others (lpc, lpq, lprm) can get away with setgid daemon.  lpd runs
as user daemon for most things, only changing its uid to 0 for
things that must be done as root.

For the time being, don't require connections to come from a reserved
port since lpq/lpr/lprm can't acquire that w/o setuid root.  In the
near future we will have a mechanism for select non-root processes
to grab reserved ports.

The upshot of this is that spool directories must be writable by
group daemon and the files within the spool dirs must be owned by
daemon.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.25 2002/05/20 23:13:50 millert Exp $ */
d53 1
a53 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.25 2002/05/20 23:13:50 millert Exp $";
d116 1
a116 1
static void	 copy(int, char []);
d123 1
a123 1
static void	 usage(void);
d407 1
a407 3
copy(f, n)
	int f;
	char n[];
d447 1
a447 2
linked(file)
	char *file;
d487 1
a487 3
card(c, p2)
	int c;
	const char *p2;
d510 1
a510 2
nfile(n)
	char *n;
d538 1
a538 2
cleanup(signo)
	int signo;
d572 1
a572 2
test(file)
	char *file;
d632 1
a632 2
itoa(i)
	int i;
d648 1
a648 2
chkprinter(s)
	char *s;
d674 1
a674 1
mktemps()
d716 1
a716 3
lmktemp(id, num, len)
	char	*id;
	int	num, len;
d726 2
a727 2
static void
usage()
@


1.25
log
@Pull in useful bits from NetBSD and make our lp* easier to diff and
do some minor cleanup of my own:

o IPv6 support
o ANSI function headers
o use getopt()
o synce usage() with man pages
o passes -Wall on both 32bit and 64bit platforms
o add an option to set the max number of children lpd will fork off
o add an lpd option to bind to specific addresses instead of INADDR_ANY.
o allow user to specify how long to wait for a connection to remote servers
o more strlcpy() and snprintf() usage
o Use FOO_FILENO constants instead of hard-coding 0-2
o Add some keeps to man the page SYNOPSIS to avoid options being split
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.24 2002/02/16 21:28:04 millert Exp $ */
d53 1
a53 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.24 2002/02/16 21:28:04 millert Exp $";
d69 1
a106 1
static int	 userid;	/* user id */
d135 5
a139 3
	euid = geteuid();
	uid = getuid();
	seteuid(uid);
d265 2
a266 3
	userid = getuid();
	if (userid != DU || person == 0) {
		if ((pw = getpwuid(userid)) == NULL)
d268 2
a269 1
		person = pw->pw_name;
d274 1
a274 1
	if (RG != NULL && userid != DU) {
d288 1
a288 1
	 * Check to make sure queuing is enabled if userid is not root.
d291 1
a291 1
	if (userid && stat(buf, &stb) == 0 && (stb.st_mode & 010))
a297 3
	seteuid(euid);
	(void)fchown(tfd, DU, -1);	/* owned by daemon for protection */
	seteuid(uid);
d356 1
a356 1
		if ((i = open(arg, O_RDONLY)) < 0)
d372 2
a373 2
		seteuid(euid);
		if ((tfd = open(tfname, O_RDWR)) >= 0) {
d391 1
a391 1
		seteuid(uid);
d480 1
a480 1
	seteuid(euid);
d482 1
a482 1
	seteuid(uid);
d521 2
a522 2
	seteuid(euid);
	f = open(n, O_WRONLY | O_EXCL | O_CREAT, FILMOD);
d528 1
a528 5
	if (fchown(f, userid, -1) < 0) {
		warn("cannot chown %s", n);
		cleanup(0);	/* cleanup does exit */
	}
	seteuid(uid);
d554 1
a554 1
	seteuid(euid);
d586 2
a587 2
	if ((fd = open(file, O_RDONLY)) < 0) {
		warn("cannot open %s\n", file);
d591 1
a591 1
		warn("cannot stat %s\n", file);
d595 5
a599 1
		warnx("%s is a directory\n", file);
d603 1
a603 1
		warnx("%s is an empty file\n", file);
d689 1
d691 5
a695 4
	(void)snprintf(buf, sizeof(buf), "%s/.seq", SD);
	seteuid(euid);
	if ((fd = open(buf, O_RDWR|O_CREAT, 0661)) < 0)
		err(1, "cannot create %s", buf);
d698 1
a698 1
	seteuid(uid);
d708 7
a714 3
	tfname = lmktemp("tf", n, len);
	cfname = lmktemp("cf", n, len);
	dfname = lmktemp("df", n, len);
a715 1
	n = (n + 1) % 1000;
@


1.24
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 2
a2 2
/*	$OpenBSD: lpr.c,v 1.23 2001/12/06 03:12:31 ericj Exp $ */
/*	$NetBSD: lpr.c,v 1.10 1996/03/21 18:12:25 jtc Exp $	*/
d53 1
a53 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.23 2001/12/06 03:12:31 ericj Exp $";
d80 2
d99 1
a99 1
static char	*person;	/* user name */
d113 1
a113 1
static void	 card(int, char *);
d117 1
d123 1
a123 3
static char	*itoa(int);

uid_t	uid, euid;
d126 1
a126 3
main(argc, argv)
	int argc;
	char *argv[];
d131 2
a132 2
	char buf[BUFSIZ];
	int i, f;
d138 1
d149 1
a149 1
	openlog("lpd", 0, LOG_LPR);
d151 3
a153 4
	while (argc > 1 && argv[1][0] == '-') {
		argc--;
		arg = *++argv;
		switch (arg[1]) {
d155 5
a159 6
		case 'P':		/* specifiy printer name */
			if (arg[2])
				printer = &arg[2];
			else if (argc > 1) {
				argc--;
				printer = *++argv;
d161 6
d171 1
a171 6
			if (arg[2])
				class = &arg[2];
			else if (argc > 1) {
				argc--;
				class = *++argv;
			}
d174 1
a174 1
		case 'U':		/* user name */
d176 1
a176 6
			if (arg[2])
				person = &arg[2];
			else if (argc > 1) {
				argc--;
				person = *++argv;
			}
d179 2
a180 8
		case 'J':		/* job name */
			hdr++;
			if (arg[2])
				jobname = &arg[2];
			else if (argc > 1) {
				argc--;
				jobname = *++argv;
			}
d184 6
a189 6
			if (arg[2])
				title = &arg[2];
			else if (argc > 1) {
				argc--;
				title = *++argv;
			}
d192 3
d196 1
a198 4
		case 'n':		/* print ditroff output */
		case 'd':		/* print tex output (dvi files) */
		case 'g':		/* print graph(1G) output */
		case 'c':		/* print cifplot output */
d200 1
a200 1
			format = arg[1];
d207 2
a208 8
		case '4':		/* troff fonts */
		case '3':
		case '2':
		case '1':
			if (argc > 1) {
				argc--;
				fonts[arg[1] - '1'] = *++argv;
			}
d211 5
a215 2
		case 'w':		/* versatec page width */
			width = arg+2;
d218 2
a219 2
		case 'r':		/* remove file when done */
			rflag++;
d222 2
a223 2
		case 'm':		/* send mail when done */
			mailflg++;
d226 2
a227 2
		case 'h':		/* toggle want of header page */
			hdr = !hdr;
d234 2
a235 2
		case 'q':		/* just q job */
			qflag++;
d238 6
a243 3
		case 'i':		/* indent output */
			iflag++;
			indent = arg[2] ? atoi(&arg[2]) : 8;
d246 2
a247 6
		case '#':		/* n copies */
			if (isdigit(arg[2])) {
				i = atoi(&arg[2]);
				if (i > 0)
					ncopies = i;
			}
d250 3
a252 4

	if (printer == NULL) {
		char *p;

a253 3
		if ((p = getenv("PRINTER")) != NULL)
			printer = p;
	}
d258 1
a258 1
		errx(1, "only %d copies are allowed", MC);
d288 1
a288 1
	(void) snprintf(buf, sizeof(buf), "%s/%s", SD, LO);
d297 1
a297 1
	(void) fchown(tfd, DU, -1);	/* owned by daemon for protection */
d303 1
a303 1
			if (argc == 1)
d306 2
a307 1
				jobname = (arg = strrchr(argv[1], '/')) ? arg+1 : argv[1];
d327 1
a327 1
	if (argc == 1)
d329 8
a336 2
	else while (--argc) {
		if ((f = test(arg = *++argv)) < 0)
d340 2
a341 2
			(void) snprintf(buf, sizeof(buf), "%d %d", statb.st_dev,
					statb.st_ino);
d361 1
a361 1
			(void) close(i);
d368 1
a368 1
		(void) close(tfd);
d384 1
a384 1
			(void) close(tfd);
d423 1
a423 1
	while ((i = read(f, buf, BUFSIZ)) > 0) {
d429 2
a430 2
		if (nc >= BUFSIZ) {
			nc -= BUFSIZ;
d438 1
a438 1
	(void) close(fd);
d454 1
a454 1
	static char nfile[MAXPATHLEN];
d458 1
a458 1
		if (getcwd(nfile, sizeof(nfile)) == NULL)
d468 1
a468 1
					if ((cp = strrchr(nfile, '/')) != NULL)
d476 4
a479 3
		strncat(nfile, "/", sizeof(nfile) - strlen(nfile) - 1);
		strncat(nfile, file, sizeof(nfile) - strlen(nfile) - 1);
		file = nfile;
d493 1
a493 1
	char *p2;
d499 4
d524 1
a524 1
	(void) umask(oldumask);
d599 1
a599 1
	if ((statb.st_mode & S_IFMT) == S_IFDIR) {
d611 1
a611 1
			(void) close(fd);
d614 1
a614 1
	(void) close(fd);
a689 1
	char *lmktemp();
d691 1
a691 1
	(void) snprintf(buf, sizeof(buf), "%s/.seq", SD);
d712 1
a712 1
	(void) lseek(fd, (off_t)0, 0);
d714 2
a715 2
	(void) write(fd, buf, strlen(buf));
	(void) close(fd);	/* unlocks as well */
d730 1
a730 1
	(void) snprintf(s, len, "%s/%sA%03d%s", SD, id, num, host);
d732 12
@


1.23
log
@
use err/warn and friends instead of printf/exit.
also, remove fatal2() which is just errx anyway.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.22 2001/11/23 03:58:18 deraadt Exp $ */
d53 1
a53 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.22 2001/11/23 03:58:18 deraadt Exp $";
d111 10
a120 10
static void	 card __P((int, char *));
static void	 chkprinter __P((char *));
static void	 cleanup __P((int));
static void	 copy __P((int, char []));
static char	*linked __P((char *));
static char	*lmktemp __P((char *, int, int));
static void	 mktemps __P((void));
static int	 nfile __P((char *));
static int	 test __P((char *));
static char	*itoa __P((int));
@


1.22
log
@use the same siginterrupt() trick in lpc(1) as in timedc(1). we have to hack
a global into the other programs since they share some source.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.21 2001/11/19 20:26:51 deraadt Exp $ */
d53 1
a53 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.21 2001/11/19 20:26:51 deraadt Exp $";
a114 1
static void	 fatal2 __P((const char *, ...));
a147 1
	name = argv[0];
d276 1
a276 1
		fatal2("multiple copies are not allowed");
d278 1
a278 1
		fatal2("only %d copies are allowed", MC);
d286 1
a286 1
			fatal2("Who are you?");
d294 1
a294 1
			fatal2("Restricted group specified incorrectly");
d302 1
a302 1
				fatal2("Not a member of the restricted group");
d310 1
a310 1
		fatal2("Printer queue is disabled");
d369 4
a372 4
			printf("%s: %s: not linked, copying instead\n", name, arg);
		if ((i = open(arg, O_RDONLY)) < 0) {
			printf("%s: cannot open %s\n", name, arg);
		} else {
d376 1
a376 1
				printf("%s: %s: not removed\n", name, arg);
d393 1
a393 1
				printf("%s: cannot touch %s\n", name, tfname);
d400 1
a400 1
			printf("%s: cannot rename %s\n", name, cfname);
d438 1
a438 1
			printf("%s: %s: temp file write error\n", name, n);
d446 1
a446 2
				printf("%s: %s: copy file is too large\n",
				       name, n);
d453 1
a453 1
		printf("%s: %s: empty input file\n", name, f ? n : "stdin");
d534 1
a534 1
		printf("%s: cannot create %s\n", name, n);
d538 1
a538 1
		printf("%s: cannot chown %s\n", name, n);
d544 1
a544 1
			printf("too many files - break up the job\n");
d550 1
a550 1
	return(f);
d600 1
a600 1
		printf("%s: cannot open %s\n", name, file);
d604 1
a604 1
		printf("%s: cannot stat %s\n", name, file);
d608 1
a608 1
		printf("%s: %s is a directory\n", name, file);
d612 1
a612 1
		printf("%s: %s is an empty file\n", name, file);
d617 2
a618 2
			printf("%s: %s is an executable program and is unprintable",
				name, file);
d638 1
a638 1
		printf("%s: %s: is not removable by you\n", name, file);
d672 1
a672 1
		fatal2("cannot open printer description file");
d674 1
a674 1
		fatal2("%s: unknown printer", s);
d702 4
a705 8
	if ((fd = open(buf, O_RDWR|O_CREAT, 0661)) < 0) {
		printf("%s: cannot create %s\n", name, buf);
		exit(1);
	}
	if (flock(fd, LOCK_EX)) {
		printf("%s: cannot lock %s\n", name, buf);
		exit(1);
	}
d738 1
a738 1
		fatal2("out of memory");
a740 28
}

#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

static void
#ifdef __STDC__
fatal2(const char *msg, ...)
#else
fatal2(msg, va_alist)
	char *msg;
        va_dcl
#endif
{
	va_list ap;
#ifdef __STDC__
	va_start(ap, msg);
#else
	va_start(ap);
#endif
	printf("%s: ", name);
	vprintf(msg, ap);
	putchar('\n');
	va_end(ap);
	exit(1);
@


1.21
log
@use _exit in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.20 2001/08/30 17:38:13 millert Exp $ */
d53 1
a53 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.20 2001/08/30 17:38:13 millert Exp $";
d108 2
@


1.20
log
@o kill register
o add const to rcsid and copyright strings
o placate -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.19 1997/07/25 20:12:13 mickey Exp $ */
d53 1
a53 1
static const char rcsid[] = "$OpenBSD: lpr.c,v 1.19 1997/07/25 20:12:13 mickey Exp $";
d584 1
a584 1
	exit(1);
@


1.19
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.18 1997/07/19 07:11:44 deraadt Exp $ */
d44 1
a44 1
static char copyright[] =
d51 1
a51 1
static char sccsid[] = "@@(#)lpr.c	8.4 (Berkeley) 4/28/95";
d53 1
a53 1
static char rcsid[] = "$OpenBSD: lpr.c,v 1.18 1997/07/19 07:11:44 deraadt Exp $";
d130 1
a130 1
	register char *arg, *cp;
d425 1
a425 1
	register int fd, i, nr, nc;
d465 1
a465 1
	register char *file;
d467 1
a467 1
	register char *cp;
d469 1
a469 1
	register int ret;
d505 2
a506 2
	register int c;
	register char *p2;
d509 2
a510 2
	register char *p1 = buf;
	register int len = 2;
d528 1
a528 1
	register int f;
d561 1
a561 1
	register i;
d597 2
a598 2
	register int fd;
	register char *cp;
d651 1
a651 1
	register int i;
d654 1
a654 1
	register char *p;
d696 2
a697 2
	register int len, fd, n;
	register char *cp;
d740 1
a740 1
	register char *s;
@


1.18
log
@Wall cleanup; people running lpd should test!
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.17 1997/07/09 00:16:12 millert Exp $ */
d53 1
a53 1
static char rcsid[] = "$OpenBSD: lpr.c,v 1.17 1997/07/09 00:16:12 millert Exp $";
d748 1
a748 1
#if __STDC__
d755 1
a755 1
#if __STDC__
d764 1
a764 1
#if __STDC__
@


1.17
log
@Fix strncat(3) usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.16 1997/07/08 18:25:42 millert Exp $ */
d53 1
a53 1
static char rcsid[] = "$OpenBSD: lpr.c,v 1.16 1997/07/08 18:25:42 millert Exp $";
a113 1
static char	*itoa __P((int));
d119 1
a129 1
	extern char *itoa();
d413 1
@


1.16
log
@BUFSIZ -> MAXPATHLEN and strcat -> strncat.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.15 1997/06/23 23:13:58 kstailey Exp $ */
d53 1
a53 1
static char rcsid[] = "$OpenBSD: lpr.c,v 1.15 1997/06/23 23:13:58 kstailey Exp $";
d490 2
a491 2
		strncat(nfile, "/", sizeof(nfile) - strlen(nfile));
		strncat(nfile, file, sizeof(nfile) - strlen(nfile));
@


1.15
log
@It is not a reasonable default behavior to abort a printout because of its
size now that there's PostScript[tm].
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.14 1997/06/20 17:46:16 kstailey Exp $ */
d53 1
a53 1
static char rcsid[] = "$OpenBSD: lpr.c,v 1.14 1997/06/20 17:46:16 kstailey Exp $";
d468 1
a468 1
	static char buf[BUFSIZ];
d472 1
a472 1
		if (getcwd(buf, BUFSIZ) == NULL) {
d474 1
a474 1
		}
d482 1
a482 1
					if ((cp = strrchr(buf, '/')) != NULL)
d490 3
a492 3
		strcat(buf, "/");
		strcat(buf, file);
		file = buf;
@


1.14
log
@add newline to message
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.13 1997/06/20 17:45:14 kstailey Exp $ */
d53 1
a53 1
static char rcsid[] = "$OpenBSD: lpr.c,v 1.13 1997/06/20 17:45:14 kstailey Exp $";
a445 3
  /* XXX by now you have wasted a large amount of paper by printing half
   * a PostScript file you fool!  Can't this be evaluated earlier?
   */
a447 1
				printf("%s: %s: WARNING: I stupidly sent a bunch of stuff to the printer anyway\n", name, n);
@


1.13
log
@I wasted a lot of paper because of the way that printcap mx is handled.
I don't even have an mx in my printcap, the default is too small, a 45 page
PostScript file with some images should not barf because of the default mx.
I will deal with this in a better way later.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.12 1997/01/17 16:12:46 millert Exp $ */
d53 1
a53 1
static char rcsid[] = "$OpenBSD: lpr.c,v 1.12 1997/01/17 16:12:46 millert Exp $";
d451 1
a451 1
				printf("%s: %s: WARNING: I stupidly sent a bunch of stuff to the printer anyway", name, n);
@


1.12
log
@Add OpenBSD tags (was in wrong dir for previous commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.11 1996/11/04 18:13:38 millert Exp $ */
d53 1
a53 1
static char rcsid[] = "$OpenBSD: $";
d446 6
a451 1
				printf("%s: %s: copy file is too large\n", name, n);
@


1.11
log
@Don't use access(2) -- from Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.10 1996/11/03 23:24:12 millert Exp $ */
d50 1
d52 3
@


1.10
log
@Improve portability by using ANSI/POSIX interfaces when possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.9 1996/08/13 18:13:29 millert Exp $ */
d595 2
a596 2
	if (access(file, 4) < 0) {
		printf("%s: cannot access %s\n", name, file);
d599 1
a599 1
	if (stat(file, &statb) < 0) {
a610 4
	if ((fd = open(file, O_RDONLY)) < 0) {
		printf("%s: cannot open %s\n", name, file);
		goto bad;
	}
@


1.9
log
@More fixes from theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.8 1996/08/13 17:51:39 millert Exp $ */
d323 1
a323 1
				jobname = (arg = rindex(argv[1], '/')) ? arg+1 : argv[1];
d477 1
a477 1
					if ((cp = rindex(buf, '/')) != NULL)
d624 1
a624 1
		if ((cp = rindex(file, '/')) == NULL) {
@


1.8
log
@fix possible buff oflow
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.7 1996/07/04 06:06:51 tholo Exp $ */
a367 1
			seteuid(uid);
d369 5
a373 1
			continue;
a374 4
		copy(i, arg);
		(void) close(i);
		if (f && unlink(arg) < 0)
			printf("%s: %s: not removed\n", name, arg);
d508 1
a508 1
	while ((c = *p2++) != '\0') {
d743 1
a743 1
	(void) sprintf(s, "%s/%sA%03d%s", SD, id, num, host);
@


1.7
log
@Fix NetBSD PR bin/2597: lpr and NFS-non-root-exported fails
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.6 1996/07/04 05:41:57 tholo Exp $ */
d305 1
a305 1
	(void) sprintf(buf, "%s/%s", SD, LO);
d350 2
a351 1
			(void) sprintf(buf, "%d %d", statb.st_dev, statb.st_ino);
d701 1
a701 1
	(void) sprintf(buf, "%s/.seq", SD);
d727 1
a727 1
	sprintf(buf, "%03d\n", n);
@


1.6
log
@Integrated 4.4Lite2 source
Fixed potential problem pointed out by bitblt
@
text
@d1 1
a1 1
/*	$OpenBSD: lpr.c,v 1.2 1996/04/21 23:40:42 deraadt Exp $ */
a365 1
		seteuid(euid);
a374 1
		seteuid(uid);
a466 1
		seteuid(euid);
a467 1
			seteuid(uid);
a594 1
	seteuid(euid);
a641 1
	seteuid(uid);
@


1.5
log
@previous fix of NULL check reversed
@
text
@d50 1
a50 1
static char sccsid[] = "@@(#)lpr.c	8.3 (Berkeley) 3/30/94";
d62 1
@


1.4
log
@Missing ' == NULL)' added...
@
text
@d267 1
a267 1
		if ((p = getenv("PRINTER")) == NULL)
@


1.3
log
@correct -P, $PRINTER, and DEFLP interactions. bug reported by scott.burns@@labatt.com
@
text
@d267 1
a267 1
		if ((p = getenv("PRINTER"))
@


1.2
log
@sync to netbsd 960418
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d262 4
a265 1
	if (printer == NULL && (printer = getenv("PRINTER")) == NULL)
d267 3
@


1.1
log
@Initial revision
@
text
@d1 3
d118 1
a118 1
void
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
