head	1.64;
access;
symbols
	OPENBSD_6_1:1.64.0.4
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.64.0.2
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.58.0.6
	OPENBSD_5_8_BASE:1.58
	OPENBSD_5_7:1.58.0.2
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.54.0.4
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.51.0.2
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.50.0.14
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.50.0.12
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.10
	OPENBSD_5_0:1.50.0.8
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.50.0.6
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.50.0.4
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.50.0.2
	OPENBSD_4_7_BASE:1.50
	OPENBSD_4_6:1.49.0.8
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.49.0.4
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.49.0.2
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.44.0.12
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.44.0.10
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.44.0.8
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.44.0.6
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.44.0.4
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.44.0.2
	OPENBSD_3_6_BASE:1.44
	OPENBSD_3_5:1.43.0.2
	OPENBSD_3_5_BASE:1.43
	OPENBSD_3_4:1.40.0.2
	OPENBSD_3_4_BASE:1.40
	OPENBSD_3_3:1.38.0.4
	OPENBSD_3_3_BASE:1.38
	OPENBSD_3_2:1.38.0.2
	OPENBSD_3_2_BASE:1.38
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.12
	OPENBSD_2_8:1.16.0.10
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.8
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.16.0.6
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.4
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.15.0.4
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.64
date	2016.02.29.17.26.01;	author jca;	state Exp;
branches;
next	1.63;
commitid	aNWKwmYdfVagOC9V;

1.63
date	2015.12.19.19.59.07;	author mmcc;	state Exp;
branches;
next	1.62;
commitid	YXGNrKyasaP4pfxp;

1.62
date	2015.10.28.13.25.55;	author millert;	state Exp;
branches;
next	1.61;
commitid	bjmkhvj3DFyKVt2o;

1.61
date	2015.10.27.15.23.28;	author millert;	state Exp;
branches;
next	1.60;
commitid	JA3xh2v9rL58vfNr;

1.60
date	2015.10.11.20.23.49;	author guenther;	state Exp;
branches;
next	1.59;
commitid	i6P7pBlCuLlhNqfW;

1.59
date	2015.09.29.02.37.29;	author millert;	state Exp;
branches;
next	1.58;
commitid	9EjfuZoPWkUaNzWu;

1.58
date	2015.02.09.23.00.14;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	822YD61EeG0Xl9Na;

1.57
date	2015.01.16.06.40.18;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	Uu5nFG3wCl0LACBb;

1.56
date	2014.10.17.06.11.27;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	YCOYD1FY9oNQUXmz;

1.55
date	2014.10.11.03.01.58;	author doug;	state Exp;
branches;
next	1.54;
commitid	4KRDh7LDNX8ahGhm;

1.54
date	2014.07.12.02.56.01;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	aZ3tPT4lmW0mNcqU;

1.53
date	2014.04.20.22.35.10;	author ajacoutot;	state Exp;
branches;
next	1.52;

1.52
date	2013.11.24.21.32.32;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.27.23.59.52;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2008.05.26.06.30.35;	author otto;	state Exp;
branches;
next	1.48;

1.48
date	2008.05.22.08.06.57;	author otto;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.02.15.19.38;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.05.17.13.01;	author stevesk;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.01.16.32.06;	author stevesk;	state Exp;
branches;
next	1.44;

1.44
date	2004.04.07.14.09.35;	author aaron;	state Exp;
branches;
next	1.43;

1.43
date	2003.11.08.19.17.29;	author jmc;	state Exp;
branches;
next	1.42;

1.42
date	2003.10.16.03.39.12;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2003.09.26.06.01.42;	author pvalchev;	state Exp;
branches;
next	1.40;

1.40
date	2003.09.03.20.23.26;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.02.23.36.53;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2002.09.06.19.46.52;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.23.03.07.19;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.11.22.47.07;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.08.18.13.34;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.08.18.09.30;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.08.01.53.43;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.05.28.18.17.22;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.05.22.18.26.03;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.22.18.24.35;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.20.23.13.50;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.16.21.28.03;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.21.17.30.38;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.07.15.39.20;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.07.03.44.30;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.06.03.12.30;	author ericj;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.23.03.58.18;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.19.20.27.13;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.05.00.22.49;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.04.23.35.59;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.30.23.24.46;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.30.17.38.13;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.22.15.27.20;	author lebel;	state Exp;
branches;
next	1.16;

1.16
date	98.08.03.16.53.16;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.08.04.19.26.13;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.07.19.07.11.43;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.01.17.16.12.41;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	96.12.20.15.58.40;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.11.03.23.24.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	96.10.26.12.33.41;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.09.21.21.05.41;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.09.21.21.02.15;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.09.21.07.56.31;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.07.00.20.49;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.04.05.46.54;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.07.04.05.41.54;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.05.05.16.13.58;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.01.13.31.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.64
log
@Move ckqueue() to common_source/common.c

Patch from Chris Bennett, ok tb@@
@
text
@/*	$OpenBSD: lpd.c,v 1.63 2015/12/19 19:59:07 mmcc Exp $	*/
/*	$NetBSD: lpd.c,v 1.33 2002/01/21 14:42:29 wiz Exp $	*/

/*
 * Copyright (c) 1983, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * lpd -- line printer daemon.
 *
 * Listen for a connection and perform the requested operation.
 * Operations are:
 *	\1printer\n
 *		check the queue for jobs and print any found.
 *	\2printer\n
 *		receive a job from another machine and queue it.
 *	\3printer [users ...] [jobs ...]\n
 *		return the current state of the queue (short form).
 *	\4printer [users ...] [jobs ...]\n
 *		return the current state of the queue (long form).
 *	\5printer person [users ...] [jobs ...]\n
 *		remove jobs from the queue.
 *
 * Strategy to maintain protected spooling area:
 *	1. Spooling area is writable only by root and the group daemon.
 *	2. Files in spooling area are owned by user daemon, group daemon,
 *	   and are mode 660.
 *	3. lpd runs as root but spends most of its time with its effective
 *	   uid and gid set to the uid/gid specified in the passwd entry for
 *	   DEFUID (1, aka daemon).
 *	4. lpr and lprm run setuid daemon and setgrp daemon.  lpr opens
 *	   files to be printed with its real uid/gid and writes to
 *	   the spool dir with its effective uid/gid (i.e. daemon).
 *	   lprm need to run as user daemon so it can kill lpd.
 *	5. lpc and lpq run setgrp daemon.
 *
 * Users can't touch the spool w/o the help of one of the lp* programs.
 */

#include <sys/wait.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <limits.h>

#include "lp.h"
#include "lp.local.h"
#include "pathnames.h"
#include "extern.h"

int	lflag;				/* log requests flag */
int	rflag;				/* allow 'of' for remote printers */
int	sflag;				/* secure (no inet) flag */
int	from_remote;			/* from remote socket */
char	**blist;			/* list of addresses to bind(2) to */
int	blist_size;
int	blist_addrs;

volatile sig_atomic_t child_count;	/* number of kids forked */

static void		reapchild(int);
static void		mcleanup(int);
static void		doit(void);
static void		startup(void);
static void		chkhost(struct sockaddr *);
static __dead void	usage(void);
static int		*socksetup(int, int, const char *);

/* unused, needed for lpc */
volatile sig_atomic_t gotintr;

int
main(int argc, char **argv)
{
	fd_set defreadfds;
	struct passwd *pw;
	struct sockaddr_un un, fromunix;
	struct sockaddr_storage frominet;
	sigset_t mask, omask;
	int i, funix, *finet;
	int options, maxfd;
	long l;
	long child_max = 32;	/* more than enough to hose the system */
	struct servent *sp;
	const char *port = "printer";
	char *cp;

	if (geteuid() != 0)
		errx(1, "must run as root");

	/*
	 * We want to run with euid of daemon most of the time.
	 */
	if ((pw = getpwuid(DEFUID)) == NULL)
		errx(1, "daemon uid (%u) not in password file", DEFUID);
	real_uid = pw->pw_uid;
	real_gid = pw->pw_gid;
	effective_uid = 0;
	effective_gid = getegid();
	PRIV_END;	/* run as daemon for most things */

	options = 0;
	gethostname(host, sizeof(host));

	while ((i = getopt(argc, argv, "b:dln:rsw:W")) != -1) {
		switch (i) {
		case 'b':
			if (blist_addrs >= blist_size) {
				char **newblist;
				int newblist_size = blist_size +
				    sizeof(char *) * 4;
				newblist = realloc(blist, newblist_size);
				if (newblist == NULL) {
					free(blist);
					blist_size = 0;
					blist = NULL;
				}
				blist = newblist;
				blist_size = newblist_size;
				if (blist == NULL)
					err(1, "cant allocate bind addr list");
			}
			blist[blist_addrs] = strdup(optarg);
			if (blist[blist_addrs++] == NULL)
				err(1, NULL);
			break;
		case 'd':
			options |= SO_DEBUG;
			break;
		case 'l':
			lflag = 1;
			break;
		case 'n':
			child_max = strtol(optarg, &cp, 10);
			if (*cp != '\0' || child_max < 0 || child_max > 1024)
				errx(1, "invalid number of children: %s",
				    optarg);
			break;
		case 'r':
			rflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		case 'w':
			l = strtol(optarg, &cp, 10);
			if (*cp != '\0' || l < 0 || l >= INT_MAX)
				errx(1, "wait time must be postive integer: %s",
				    optarg);
			wait_time = (u_int)l;
			if (wait_time < 30)
				warnx("warning: wait time less than 30 seconds");
			break;
		case 'W':	/* XXX deprecate */
			break;
		default:
			usage();
			break;
		}
	}
	argc -= optind;
	argv += optind;

	switch (argc) {
	case 1:
		port = argv[0];
		l = strtol(port, &cp, 10);
		if (*cp != '\0' || l <= 0 || l > USHRT_MAX)
			errx(1, "port # %s is invalid", port);
		break;
	case 0:
		sp = getservbyname(port, "tcp");
		if (sp == NULL)
			errx(1, "%s/tcp: unknown service", port);
		break;
	default:
		usage();
	}

	funix = socket(AF_UNIX, SOCK_STREAM, 0);
	if (funix < 0)
		err(1, "socket");
	memset(&un, 0, sizeof(un));
	un.sun_family = AF_UNIX;
	strlcpy(un.sun_path, _PATH_SOCKETNAME, sizeof(un.sun_path));
	PRIV_START;
	if (connect(funix, (struct sockaddr *)&un, sizeof(un)) == 0)
		errx(1, "already running");
	if (errno != ENOENT)
		(void)unlink(un.sun_path);
	if (bind(funix, (struct sockaddr *)&un, sizeof(un)) < 0)
		err(1, "bind %s", un.sun_path);
	chmod(_PATH_SOCKETNAME, 0660);
	chown(_PATH_SOCKETNAME, -1, real_gid);
	PRIV_END;

#ifndef DEBUG
	/*
	 * Set up standard environment by detaching from the parent.
	 */
	daemon(0, 0);
#endif

	openlog("lpd", LOG_PID, LOG_LPR);
	syslog(LOG_INFO, "restarted");
	(void)umask(0);
	signal(SIGCHLD, reapchild);
	/*
	 * Restart all the printers.
	 */
	startup();

	sigemptyset(&mask);
	sigaddset(&mask, SIGHUP);
	sigaddset(&mask, SIGINT);
	sigaddset(&mask, SIGQUIT);
	sigaddset(&mask, SIGTERM);
	sigprocmask(SIG_BLOCK, &mask, &omask);

	signal(SIGHUP, mcleanup);
	signal(SIGINT, mcleanup);
	signal(SIGQUIT, mcleanup);
	signal(SIGTERM, mcleanup);
	sigprocmask(SIG_SETMASK, &omask, NULL);
	FD_ZERO(&defreadfds);
	FD_SET(funix, &defreadfds);
	listen(funix, 5);
	if (!sflag || blist_addrs)
		finet = socksetup(PF_UNSPEC, options, port);
	else
		finet = NULL;	/* pretend we couldn't open TCP socket. */

	if (blist != NULL) {
		for (i = 0; i < blist_addrs; i++)
			free(blist[i]);
		free(blist);
	}

	maxfd = funix;
	if (finet) {
		for (i = 1; i <= *finet; i++) {
			FD_SET(finet[i], &defreadfds);
			listen(finet[i], 5);
			if (finet[i] > maxfd)
				maxfd = finet[i];
		}
	}
	/*
	 * Main loop: accept, do a request, continue.
	 */
	memset(&frominet, 0, sizeof(frominet));
	memset(&fromunix, 0, sizeof(fromunix));
	for (;;) {
		int domain, nfds, s;
		socklen_t fromlen;
		fd_set readfds;
		short sleeptime = 10;	/* overflows in about 2 hours */

		while (child_max < child_count) {
			syslog(LOG_WARNING,
			    "too many children, sleeping for %d seconds",
			    sleeptime);
			sleep(sleeptime);
			sleeptime <<= 1;
			if (sleeptime < 0) {
				syslog(LOG_CRIT, "sleeptime overflowed! help!");
				sleeptime = 10;
			}
		}

		FD_COPY(&defreadfds, &readfds);
		nfds = select(maxfd + 1, &readfds, NULL, NULL, NULL);
		if (nfds <= 0) {
			if (nfds < 0 && errno != EINTR)
				syslog(LOG_WARNING, "select: %m");
			continue;
		}
		if (FD_ISSET(funix, &readfds)) {
			domain = AF_UNIX;
			fromlen = sizeof(fromunix);
			s = accept(funix,
			    (struct sockaddr *)&fromunix, &fromlen);
		} else {
			domain = AF_INET;
			s = -1;
			for (i = 1; i <= *finet; i++)
				if (FD_ISSET(finet[i], &readfds)) {
					in_port_t port;

					fromlen = sizeof(frominet);
					s = accept(finet[i],
					    (struct sockaddr *)&frominet,
					    &fromlen);
					switch (frominet.ss_family) {
					case AF_INET:
						port = ((struct sockaddr_in *)
						    &frominet)->sin_port;
						break;
					case AF_INET6:
						port = ((struct sockaddr_in6 *)
						    &frominet)->sin6_port;
						break;
					default:
						port = 0;
					}
					/* check for ftp bounce attack */
					if (port == htons(20)) {
						close(s);
						continue;
					}
				}
		}
		if (s < 0) {
			if (errno != EINTR && errno != EWOULDBLOCK &&
			    errno != ECONNABORTED)
				syslog(LOG_WARNING, "accept: %m");
			continue;
		}

		switch (fork()) {
		case 0:
			signal(SIGCHLD, SIG_DFL);
			signal(SIGHUP, SIG_IGN);
			signal(SIGINT, SIG_IGN);
			signal(SIGQUIT, SIG_IGN);
			signal(SIGTERM, SIG_IGN);
			(void)close(funix);
			if (!sflag && finet)
				for (i = 1; i <= *finet; i++)
					(void)close(finet[i]);
			if (s != STDOUT_FILENO) {
				dup2(s, STDOUT_FILENO);
				(void)close(s);
			}
			if (domain == AF_INET) {
				/* for both AF_INET and AF_INET6 */
				from_remote = 1;
				chkhost((struct sockaddr *)&frominet);
			} else
				from_remote = 0;
			doit();
			exit(0);
		case -1:
			syslog(LOG_WARNING, "fork: %m, sleeping for 10 seconds...");
			sleep(10);
			continue;
		default:
			child_count++;
		}
		(void)close(s);
	}
}

static void
reapchild(int signo)
{
	int save_errno = errno;
	int status;

	while (waitpid((pid_t)-1, &status, WNOHANG) > 0)
		child_count--;
	errno = save_errno;
}

static void
mcleanup(int signo)
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;

	if (lflag)
		syslog_r(LOG_INFO, &sdata, "exiting");
	PRIV_START;
	unlink(_PATH_SOCKETNAME);
	_exit(0);
}

/*
 * Stuff for handling job specifications
 */
char	*user[MAXUSERS];	/* users to process */
int	users;			/* # of users in user array */
int	requ[MAXREQUESTS];	/* job number of spool entries */
int	requests;		/* # of spool requests */
char	*person;		/* name of person doing lprm */

char	fromb[NI_MAXHOST];	/* buffer for client's machine name */
char	cbuf[BUFSIZ];		/* command line buffer */
char	*cmdnames[] = {
	"null",
	"printjob",
	"recvjob",
	"displayq short",
	"displayq long",
	"rmjob"
};

static void
doit(void)
{
	char *cp;
	int n;

	for (;;) {
		cp = cbuf;
		do {
			if (cp >= &cbuf[sizeof(cbuf) - 1])
				fatal("Command line too long");
			if ((n = read(STDOUT_FILENO, cp, 1)) != 1) {
				if (n < 0)
					fatal("Lost connection");
				return;
			}
		} while (*cp++ != '\n');
		*--cp = '\0';
		cp = cbuf;
		if (lflag) {
			if (*cp >= '\1' && *cp <= '\5') {
				syslog(LOG_INFO, "%s requests %s %s",
					from, cmdnames[(int)*cp], cp+1);
				setproctitle("serving %s: %s %s", from,
				    cmdnames[(int)*cp], cp+1);
			} else
				syslog(LOG_INFO, "bad request (%d) from %s",
					*cp, from);
		}
		switch (*cp++) {
		case '\1':	/* check the queue and print any jobs there */
			printer = cp;
			if (*printer == '\0')
				printer = DEFLP;
			printjob();
			break;
		case '\2':	/* receive files to be queued */
			if (!from_remote) {
				syslog(LOG_INFO, "illegal request (%d)", *cp);
				exit(1);
			}
			printer = cp;
			if (*printer == '\0')
				printer = DEFLP;
			recvjob();
			break;
		case '\3':	/* display the queue (short form) */
		case '\4':	/* display the queue (long form) */
			printer = cp;
			if (*printer == '\0')
				printer = DEFLP;
			while (*cp) {
				if (*cp != ' ') {
					cp++;
					continue;
				}
				*cp++ = '\0';
				while (isspace((unsigned char)*cp))
					cp++;
				if (*cp == '\0')
					break;
				if (isdigit((unsigned char)*cp)) {
					if (requests >= MAXREQUESTS)
						fatal("Too many requests");
					requ[requests++] = atoi(cp);
				} else {
					if (users >= MAXUSERS)
						fatal("Too many users");
					user[users++] = cp;
				}
			}
			displayq(cbuf[0] - '\3');
			exit(0);
		case '\5':	/* remove a job from the queue */
			if (!from_remote) {
				syslog(LOG_INFO, "illegal request (%d)", *cp);
				exit(1);
			}
			printer = cp;
			if (*printer == '\0')
				printer = DEFLP;
			while (*cp && *cp != ' ')
				cp++;
			if (!*cp)
				break;
			*cp++ = '\0';
			person = cp;
			while (*cp) {
				if (*cp != ' ') {
					cp++;
					continue;
				}
				*cp++ = '\0';
				while (isspace((unsigned char)*cp))
					cp++;
				if (*cp == '\0')
					break;
				if (isdigit((unsigned char)*cp)) {
					if (requests >= MAXREQUESTS)
						fatal("Too many requests");
					requ[requests++] = atoi(cp);
				} else {
					if (users >= MAXUSERS)
						fatal("Too many users");
					user[users++] = cp;
				}
			}
			rmjob();
			break;
		}
		fatal("Illegal service request");
	}
}

/*
 * Make a pass through the printcap database and start printing any
 * files left from the last time the machine went down.
 */
static void
startup(void)
{
	char *buf, *cp;

	/*
	 * Restart the daemons.
	 */
	while (cgetnext(&buf, printcapdb) > 0) {
		if (ckqueue(buf) <= 0) {
			free(buf);
			continue;	/* no work to do for this printer */
		}
		for (cp = buf; *cp; cp++)
			if (*cp == '|' || *cp == ':') {
				*cp = '\0';
				break;
			}
		if (lflag)
			syslog(LOG_INFO, "work for %s", buf);
		switch (fork()) {
		case -1:
			syslog(LOG_WARNING, "startup: cannot fork");
			mcleanup(0);
			/* NOTREACHED */
		case 0:
			printer = buf;
			setproctitle("working on printer %s", printer);
			cgetclose();
			printjob();
			/* NOTREACHED */
		default:
			child_count++;
			free(buf);
		}
	}
}

/*
 * Check to see if the from host has access to the line printer.
 */
static void
chkhost(struct sockaddr *f)
{
	struct addrinfo hints, *res, *r;
	FILE *hostf;
	int good = 0;
	char host[NI_MAXHOST], ip[NI_MAXHOST];
	char serv[NI_MAXSERV];
	int error;

	error = getnameinfo(f, f->sa_len, NULL, 0, serv, sizeof(serv),
	    NI_NUMERICSERV);
	if (error)
		fatal("Malformed from address");

	/* Need real hostname for temporary filenames */
	error = getnameinfo(f, f->sa_len, host, sizeof(host), NULL, 0,
	    NI_NAMEREQD);
	if (error) {
		error = getnameinfo(f, f->sa_len, host, sizeof(host), NULL, 0,
		    NI_NUMERICHOST);
		if (error)
			fatal("Host name for your address unknown");
		else
			fatal("Host name for your address (%s) unknown", host);
	}

	(void)strlcpy(fromb, host, sizeof(fromb));
	from = fromb;

	/* need address in stringform for comparison (no DNS lookup here) */
	error = getnameinfo(f, f->sa_len, host, sizeof(host), NULL, 0,
	    NI_NUMERICHOST);
	if (error)
		fatal("Cannot print address");

	/* Check for spoof, ala rlogind */
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
	error = getaddrinfo(fromb, NULL, &hints, &res);
	if (error) {
		fatal("hostname for your address (%s) unknown: %s", host,
		    gai_strerror(error));
	}
	for (good = 0, r = res; good == 0 && r; r = r->ai_next) {
		error = getnameinfo(r->ai_addr, r->ai_addrlen, ip, sizeof(ip),
		    NULL, 0, NI_NUMERICHOST);
		if (!error && !strcmp(host, ip))
			good = 1;
	}
	if (res)
		freeaddrinfo(res);
	if (good == 0)
		fatal("address for your hostname (%s) not matched", host);
	setproctitle("serving %s", from);
	PRIV_START;
	hostf = fopen(_PATH_HOSTSLPD, "r");
	PRIV_END;
	if (hostf) {
		if (allowedhost(hostf, f, f->sa_len) == 0) {
			(void)fclose(hostf);
			return;
		}
		(void)fclose(hostf);
		fatal("Your host does not have line printer access (/etc/hosts.lpd)");
	} else
		fatal("Your host does not have line printer access (no /etc/hosts.lpd)");
}

static __dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-dlrs] [-b bind-address] [-n maxchild] "
	    "[-w maxwait] [port]\n", __progname);
	exit(1);
}

/*
 * Setup server socket for specified address family.
 * If af is PF_UNSPEC more than one socket may be returned.
 * The returned list is dynamically allocated, so the caller needs to free it.
 */
int *
socksetup(int af, int options, const char *port)
{
	struct addrinfo hints, *res, *r;
	int error, maxs = 0, *s, *socks = NULL, *newsocks, blidx = 0;
	const int on = 1;

	do {
		memset(&hints, 0, sizeof(hints));
		hints.ai_flags = AI_PASSIVE;
		hints.ai_family = af;
		hints.ai_socktype = SOCK_STREAM;
		error = getaddrinfo((blist_addrs == 0) ? NULL : blist[blidx],
		    port ? port : "printer", &hints, &res);
		if (error) {
			if (blist_addrs)
				syslog(LOG_ERR, "%s: %s", blist[blidx],
				    gai_strerror(error));
			else
				syslog(LOG_ERR, "%s", gai_strerror(error));
			mcleanup(0);
		}

		/* Count max number of sockets we may open */
		for (r = res; r; r = r->ai_next, maxs++)
			;
		if (socks == NULL) {
			socks = calloc(maxs + 1, sizeof(int));
			if (socks)
				*socks = 0; /* num of sockets ctr at start */
		} else {
			newsocks = reallocarray(socks, maxs + 1, sizeof(int));
			if (newsocks)
				socks = newsocks;
			else {
				free(socks);
				socks = NULL;
			}
		}
		if (!socks) {
			syslog(LOG_ERR, "couldn't allocate memory for sockets");
			mcleanup(0);
		}

		s = socks + *socks + 1;
		for (r = res; r; r = r->ai_next) {
			*s = socket(r->ai_family, r->ai_socktype,
			            r->ai_protocol);
			if (*s < 0) {
				syslog(LOG_DEBUG, "socket(): %m");
				continue;
			}
			if (options & SO_DEBUG)
				if (setsockopt(*s, SOL_SOCKET, SO_DEBUG,
					       &on, sizeof(on)) < 0) {
					syslog(LOG_ERR,
					       "setsockopt (SO_DEBUG): %m");
					close (*s);
					continue;
				}
			PRIV_START;
			error = bind(*s, r->ai_addr, r->ai_addrlen);
			PRIV_END;
			if (error < 0) {
				syslog(LOG_DEBUG, "bind(): %m");
				close (*s);
				continue;
			}
			*socks = *socks + 1;
			s++;
		}

		if (res)
			freeaddrinfo(res);
	} while (++blidx < blist_addrs);

	if (socks == NULL || *socks == 0) {
		syslog(LOG_ERR, "Couldn't bind to any socket");
		free(socks);
		mcleanup(0);
	}
	return(socks);
}
@


1.63
log
@Remove NULL-check before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.62 2015/10/28 13:25:55 millert Exp $	*/
a109 1
static int		ckqueue(char *);
a594 29
}

/*
 * Make sure there's some work to do before forking off a child
 * XXX - could be common w/ lpq
 */
static int
ckqueue(char *cap)
{
	struct dirent *d;
	DIR *dirp;
	char *spooldir;

	if (cgetstr(cap, "sd", &spooldir) >= 0) {
		dirp = opendir(spooldir);
		free(spooldir);
	} else
		dirp = opendir(_PATH_DEFSPOOL);

	if (dirp == NULL)
		return (-1);
	while ((d = readdir(dirp)) != NULL) {
		if (d->d_name[0] == 'c' && d->d_name[1] == 'f') {
			closedir(dirp);
			return (1);		/* found a cf file */
		}
	}
	closedir(dirp);
	return (0);
@


1.62
log
@Remove support for lpd.pid file.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.61 2015/10/27 15:23:28 millert Exp $	*/
d793 1
a793 2
		if (socks != NULL)
			free(socks);
@


1.61
log
@Use AF_UNIX instead of AF_LOCAL.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.60 2015/10/11 20:23:49 guenther Exp $ */
d125 1
a125 1
	int lfd, i, f, funix, *finet;
d225 17
a251 19
	PRIV_START;
	lfd = open(_PATH_MASTERLOCK, O_WRONLY|O_CREAT|O_EXLOCK|O_NONBLOCK, 0644);
	PRIV_END;
	if (lfd < 0) {
		if (errno == EWOULDBLOCK)	/* active daemon present */
			exit(0);
		syslog(LOG_ERR, "%s: %m", _PATH_MASTERLOCK);
		exit(1);
	}
	ftruncate(lfd, 0);
	/*
	 * write process id for others to know
	 */
	(void)snprintf(line, sizeof(line), "%u\n", getpid());
	f = strlen(line);
	if (write(lfd, line, f) != f) {
		syslog(LOG_ERR, "%s: %m", _PATH_MASTERLOCK);
		exit(1);
	}
a256 8
	PRIV_START;
	(void)unlink(_PATH_SOCKETNAME);
	PRIV_END;
	funix = socket(AF_UNIX, SOCK_STREAM, 0);
	if (funix < 0) {
		syslog(LOG_ERR, "socket: %m");
		exit(1);
	}
a268 12
	memset(&un, 0, sizeof(un));
	un.sun_family = AF_UNIX;
	strlcpy(un.sun_path, _PATH_SOCKETNAME, sizeof(un.sun_path));
	PRIV_START;
	if (bind(funix, (struct sockaddr *)&un, sizeof(un)) < 0) {
		syslog(LOG_ERR, "ubind: %m");
		exit(1);
	}
	chmod(_PATH_SOCKETNAME, 0660);
	chown(_PATH_SOCKETNAME, -1, real_gid);
	PRIV_END;
	(void)umask(0);		/* XXX */
a418 1
	unlink(_PATH_MASTERLOCK);
@


1.60
log
@Userspace doesn't need to use SUN_LEN(): connect() and bind() must accept
sizeof(struct sockaddr_un), so do the simple, portable thing.
Also convert some strncpy() to strlcpy()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.59 2015/09/29 02:37:29 millert Exp $ */
d262 1
a262 1
	funix = socket(AF_LOCAL, SOCK_STREAM, 0);
d280 1
a280 1
	un.sun_family = AF_LOCAL;
d346 1
a346 1
			domain = AF_LOCAL;
@


1.59
log
@Replace call to __ivaliduser_sa() with a pared down version that
only checks the host name.  This clears the way for removal of
__ivaliduser_sa() and __ivaliduser() from libc.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.58 2015/02/09 23:00:14 deraadt Exp $ */
d283 1
a283 1
	if (bind(funix, (struct sockaddr *)&un, SUN_LEN(&un)) < 0) {
@


1.58
log
@clean up flags++ instances around getopt()
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.57 2015/01/16 06:40:18 deraadt Exp $ */
a113 3
extern int		__ivaliduser_sa(FILE *, struct sockaddr *, socklen_t,
			    const char *, const char *);

a649 2
#define DUMMY ":nobody::"

d713 1
a713 1
		if (__ivaliduser_sa(hostf, f, f->sa_len, DUMMY, DUMMY) == 0) {
@


1.57
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.56 2014/10/17 06:11:27 deraadt Exp $ */
d179 1
a179 1
			lflag++;
d188 1
a188 1
			rflag++;
d191 1
a191 1
			sflag++;
@


1.56
log
@Remove chunk special-casing malloc(siz) for realloc(NULL, siz).  Bit
tricky, but note the remembered size is in bss.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.55 2014/10/11 03:01:58 doug Exp $ */
a65 1
#include <sys/param.h>
d88 1
@


1.55
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@ (had same diff in tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.54 2014/07/12 02:56:01 deraadt Exp $ */
d157 8
a164 16
				if (blist == NULL) {
					blist_size += sizeof(char *) * 4;
					blist = malloc(blist_size);
				}
				else {
					char **newblist;
					int newblist_size = blist_size +
					    sizeof(char *) * 4;
					newblist = realloc(blist, newblist_size);
					if (newblist == NULL) {
						free(blist);
						blist_size = 0;
						blist = NULL;
					}
					blist = newblist;
					blist_size = newblist_size;
d166 2
@


1.54
log
@The hosts.lpd file must exist, or no permission is granted.  Change the
the log messages to clarify the reason for the failure to clarify the
condition.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.53 2014/04/20 22:35:10 ajacoutot Exp $ */
d780 1
a780 1
			newsocks = realloc(socks, (maxs + 1) * sizeof(int));
@


1.53
log
@Prevent lpd(8) from looking into hosts.equiv.
Access control is now done only using hosts.lpd.
See lpd(8) for more information about the format of this file.

"seems reasonable" tedu@@
"looks good" deraadt@@
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.52 2013/11/24 21:32:32 deraadt Exp $ */
d729 3
a731 2
	}
	fatal("Your host does not have line printer access");
@


1.52
log
@more ctype cleanups
checked by jca
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.51 2013/03/11 17:40:11 deraadt Exp $ */
a668 1
	int first = 1;
d721 1
a721 1
	hostf = fopen(_PATH_HOSTSEQUIV, "r");
a722 1
again:
a729 7
	if (first == 1) {
		first = 0;
		PRIV_START;
		hostf = fopen(_PATH_HOSTSLPD, "r");
		PRIV_END;
		goto again;
	}
a730 1
	/*NOTREACHED*/
@


1.51
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.50 2009/10/27 23:59:52 deraadt Exp $ */
d531 1
a531 1
				while (isspace(*cp))
d535 1
a535 1
				if (isdigit(*cp)) {
d567 1
a567 1
				while (isspace(*cp))
d571 1
a571 1
				if (isdigit(*cp)) {
@


1.50
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.49 2008/05/26 06:30:35 otto Exp $ */
d390 2
a391 1
			if (errno != EINTR)
@


1.49
log
@cgetstr(3) can also return 2 so handle that. Also restructre things a bit
to get rid of the flag var. ok deraadt@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.48 2008/05/22 08:06:57 otto Exp $ */
a32 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)lpd.c	8.7 (Berkeley) 5/10/95";
#else
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.48 2008/05/22 08:06:57 otto Exp $";
#endif
#endif /* not lint */
@


1.48
log
@Comparing string literals does not work as the author expected.
From  Adam Majer (debian maintaner); looks correct fgs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.47 2007/09/02 15:19:38 deraadt Exp $ */
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.47 2007/09/02 15:19:38 deraadt Exp $";
a652 1
	int free_spooldir = 1;
d654 2
a655 6
	if (cgetstr(cap, "sd", &spooldir) == -1) {
		spooldir = _PATH_DEFSPOOL;
		free_spooldir = 0;
	}
	dirp = opendir(spooldir);
	if (free_spooldir)
d657 3
@


1.47
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.46 2007/05/05 17:13:01 stevesk Exp $ */
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.46 2007/05/05 17:13:01 stevesk Exp $";
d653 1
d655 1
a655 1
	if (cgetstr(cap, "sd", &spooldir) == -1)
d657 2
d660 1
a660 1
	if (spooldir != _PATH_DEFSPOOL)
@


1.46
log
@remove code for -W, argument now a no-op; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.45 2007/05/01 16:32:06 stevesk Exp $ */
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.45 2007/05/01 16:32:06 stevesk Exp $";
d797 1
a797 1
			socks = malloc((maxs + 1) * sizeof(int));
@


1.45
log
@remove #ifndef SUN_LEN; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.44 2004/04/07 14:09:35 aaron Exp $ */
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.44 2004/04/07 14:09:35 aaron Exp $";
a108 2
#define	LPD_NOPORTCHK	0001		/* skip reserved-port check */

d123 1
a123 1
static void		chkhost(struct sockaddr *, int);
d143 1
a143 1
	int options, check_options, maxfd;
a163 1
	check_options = LPD_NOPORTCHK;		/* XXX - lp* not setuid root */
d222 1
a222 6
		case 'W':
			/*
			 * Allow connections coming from a non-reserved port.
			 * (done by some lpr-implementations for MS-Windows)
			 */
			check_options |= LPD_NOPORTCHK;
d427 1
a427 1
				chkhost((struct sockaddr *)&frominet, check_options);
d677 1
a677 1
chkhost(struct sockaddr *f, int check_opts)
a691 4
	if (!(check_opts & LPD_NOPORTCHK) &&
	    atoi(serv) >= IPPORT_RESERVED)
		fatal("Connect from invalid port (%s)", serv);

d760 1
a760 1
	fprintf(stderr, "usage: %s [-dlrsW] [-b bind-address] [-n maxchild] "
@


1.44
log
@Remove those option letters from the getopt string which do not have a case
handler below. millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.43 2003/11/08 19:17:29 jmc Exp $ */
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.43 2003/11/08 19:17:29 jmc Exp $";
a312 3
#ifndef SUN_LEN
#define SUN_LEN(unp) (strlen((unp)->sun_path) + 2)
#endif
@


1.43
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.42 2003/10/16 03:39:12 itojun Exp $ */
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.42 2003/10/16 03:39:12 itojun Exp $";
d170 1
a170 1
	while ((i = getopt(argc, argv, "b:cdln:rsw:W")) != -1) {
@


1.42
log
@safer realloc.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.41 2003/09/26 06:01:42 pvalchev Exp $ */
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.41 2003/09/26 06:01:42 pvalchev Exp $";
d147 1
a147 1
	long child_max = 32;	/* more then enough to hose the system */
@


1.41
log
@realloc fixes; ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.40 2003/09/03 20:23:26 tedu Exp $ */
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.40 2003/09/03 20:23:26 tedu Exp $";
d789 1
a789 1
	int error, maxs = 0, *s, *socks = NULL, blidx = 0;
d815 9
a823 2
		} else
			socks = realloc(socks, (maxs + 1) * sizeof(int));
@


1.40
log
@plug mem leaks, pr3425 from patrick latifi.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.39 2003/06/02 23:36:53 millert Exp $ */
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.39 2003/06/02 23:36:53 millert Exp $";
d174 2
a175 2
				blist_size += sizeof(char *) * 4;
				if (blist == NULL)
d177 14
a190 2
				else
					blist = realloc(blist, blist_size);
@


1.39
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.38 2002/09/06 19:46:52 deraadt Exp $ */
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.38 2002/09/06 19:46:52 deraadt Exp $";
d656 2
@


1.38
log
@use more socklen_t; pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.37 2002/06/23 03:07:19 deraadt Exp $ */
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.37 2002/06/23 03:07:19 deraadt Exp $";
@


1.37
log
@uid_t and gid_t are unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.36 2002/06/11 22:47:07 millert Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.36 2002/06/11 22:47:07 millert Exp $";
d347 2
a348 1
		int domain, nfds, s, fromlen;
@


1.36
log
@lprm needs to be setuid daemon after all
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.35 2002/06/08 18:13:34 millert Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.35 2002/06/08 18:13:34 millert Exp $";
d163 1
a163 1
		errx(1, "daemon uid (%d) not in password file", DEFUID);
@


1.35
log
@make this actually compile
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.34 2002/06/08 18:09:30 millert Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.34 2002/06/08 18:09:30 millert Exp $";
d75 1
a75 1
 *	4. lpr runs setuid daemon and setgrp daemon; it opens
d78 2
a79 1
 *	5. lpc, lpr and lprm run setgrp daemon.
@


1.34
log
@Force lpd socket to be mode 0660, group daemon
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.33 2002/06/08 01:53:43 millert Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.33 2002/06/08 01:53:43 millert Exp $";
d312 2
a313 2
	chmod(_PATH_SOCKETNAME, 0660)
	chown(_PATH_SOCKETNAME, -1, real_gid)
@


1.33
log
@Remove setuid root from lp*.  lpr needs to be setuid daemon so the
files it creates are not owned by the user spooling them but the
others (lpc, lpq, lprm) can get away with setgid daemon.  lpd runs
as user daemon for most things, only changing its uid to 0 for
things that must be done as root.

For the time being, don't require connections to come from a reserved
port since lpq/lpr/lprm can't acquire that w/o setuid root.  In the
near future we will have a mechanism for select non-root processes
to grab reserved ports.

The upshot of this is that spool directories must be writable by
group daemon and the files within the spool dirs must be owned by
daemon.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.32 2002/05/28 18:17:22 millert Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.32 2002/05/28 18:17:22 millert Exp $";
a296 1
	(void)umask(07);
d312 2
d315 1
a315 1
	(void)umask(0);
@


1.32
log
@Repair remote printing; maxfd was not set correctly for remote connections.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.31 2002/05/22 18:26:03 millert Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.31 2002/05/22 18:26:03 millert Exp $";
d69 12
a80 10
 *	1. Spooling area is writable only by daemon and spooling group
 *	2. lpr runs setuid root and setgrp spooling group; it uses
 *	   root to access any file it wants (verifying things before
 *	   with an access call) and group id to know how it should
 *	   set up ownership of files in the spooling area.
 *	3. Files in spooling area are owned by root, group spooling
 *	   group, with mode 660.
 *	4. lpd, lpq and lprm run setuid daemon and setgrp spooling group to
 *	   access files and printer.  Users can't get to anything
 *	   w/o help of lpq and lprm programs.
d99 1
d143 1
d155 16
a170 3
	euid = geteuid();	/* these shouldn't be different */
	uid = getuid();
	options = check_options = 0;
a172 3
	if (euid != 0)
		errx(1, "must run as root");

d257 1
d259 1
d281 1
d283 1
d308 1
d313 1
d461 1
d608 1
a608 2
	char *buf;
	char *cp;
d645 1
d656 2
a657 1
	if ((dirp = opendir(spooldir)) == NULL)
d660 4
a663 4
		if (d->d_name[0] != 'c' || d->d_name[1] != 'f')
			continue;	/* daemon control files only */
		closedir(dirp);
		return (1);		/* found something */
d735 1
d737 1
d748 1
d750 1
d825 4
a828 1
			if (bind(*s, r->ai_addr, r->ai_addrlen) < 0) {
@


1.31
log
@unlink lpd.pid if killed by a signal
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.30 2002/05/22 18:24:35 millert Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.30 2002/05/22 18:24:35 millert Exp $";
d153 1
a153 1
	maxfd = options = check_options = 0;
a297 2
	if (funix > maxfd)
		maxfd = funix;
d310 1
d315 2
d342 1
a342 1
		nfds = select(maxfd + 1, &readfds, 0, 0, 0);
@


1.30
log
@Use O_EXLOCK in open() instead of flock() to eliminate a potential locking
race on the pid file.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.29 2002/05/20 23:13:50 millert Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.29 2002/05/20 23:13:50 millert Exp $";
d441 1
@


1.29
log
@Pull in useful bits from NetBSD and make our lp* easier to diff and
do some minor cleanup of my own:

o IPv6 support
o ANSI function headers
o use getopt()
o synce usage() with man pages
o passes -Wall on both 32bit and 64bit platforms
o add an option to set the max number of children lpd will fork off
o add an lpd option to bind to specific addresses instead of INADDR_ANY.
o allow user to specify how long to wait for a connection to remote servers
o more strlcpy() and snprintf() usage
o Use FOO_FILENO constants instead of hard-coding 0-2
o Add some keeps to man the page SYNOPSIS to avoid options being split
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.28 2002/02/16 21:28:03 millert Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.28 2002/02/16 21:28:03 millert Exp $";
d243 1
a243 1
	lfd = open(_PATH_MASTERLOCK, O_WRONLY|O_CREAT, 0644);
a244 4
		syslog(LOG_ERR, "%s: %m", _PATH_MASTERLOCK);
		exit(1);
	}
	if (flock(lfd, LOCK_EX|LOCK_NB) < 0) {
@


1.28
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 2
a2 2
/*	$OpenBSD: lpd.c,v 1.27 2002/01/21 17:30:38 deraadt Exp $ */
/*	$NetBSD: lpd.c,v 1.7 1996/04/24 14:54:06 mrg Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.27 2002/01/21 17:30:38 deraadt Exp $";
d91 5
a96 2
#include <unistd.h>
#include <syslog.h>
a97 3
#include <errno.h>
#include <fcntl.h>
#include <dirent.h>
d101 3
a103 1
#include <ctype.h>
d109 1
a109 1
extern int __ivaliduser(FILE *, in_addr_t, const char *, const char *);
d112 2
d115 14
d130 2
a131 6
static void       reapchild(int);
static void       mcleanup(int);
static void       doit(void);
static void       startup(void);
static void       chkhost(struct sockaddr_in *);
static int	  ckqueue(char *);
a135 2
uid_t	uid, euid;

d137 1
a137 3
main(argc, argv)
	int argc;
	char **argv;
a138 1
	int f, lfd, funix, finet, options, fromlen;
a139 1
	int maxfd = 0;
d141 1
a141 1
	struct sockaddr_in sin, frominet;
d143 7
d153 1
a153 1
	options = 0;
d156 57
a212 3
	if (euid != 0) {
		fprintf(stderr,"lpd: must run as root\n");
		exit(1);
d214 2
d217 14
a230 11
	while (--argc > 0) {
		argv++;
		if (argv[0][0] == '-')
			switch (argv[0][1]) {
			case 'd':
				options |= SO_DEBUG;
				break;
			case 'l':
				lflag++;
				break;
			}
d242 1
a242 1
	(void) umask(0);
d258 1
a258 1
	sprintf(line, "%u\n", getpid());
d269 2
a270 2
	(void) unlink(_PATH_SOCKETNAME);
	funix = socket(AF_UNIX, SOCK_STREAM, 0);
d275 1
d282 2
a283 1
	(void) umask(07);
d289 2
a290 2
	un.sun_family = AF_UNIX;
	strcpy(un.sun_path, _PATH_SOCKETNAME);
d298 1
a298 1
	(void) umask(0);
d305 15
a319 24
	finet = socket(AF_INET, SOCK_STREAM, 0);
	if (finet >= 0) {
		struct servent *sp;

		if (options & SO_DEBUG) {
			if (setsockopt(finet, SOL_SOCKET, SO_DEBUG, 0, 0) < 0) {
				syslog(LOG_ERR, "setsockopt (SO_DEBUG): %m");
				mcleanup(0);
			}
		}
		f = 1;
		(void) setsockopt(finet, SOL_SOCKET, SO_REUSEADDR, &f,
		    sizeof(f));
		sp = getservbyname("printer", "tcp");
		if (sp == NULL) {
			syslog(LOG_ERR, "printer/tcp: unknown service");
			mcleanup(0);
		}
		memset(&sin, 0, sizeof(sin));
		sin.sin_family = AF_INET;
		sin.sin_port = sp->s_port;
		if (bind(finet, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
			syslog(LOG_ERR, "bind: %m");
			mcleanup(0);
a320 4
		FD_SET(finet, &defreadfds);
		if (finet > maxfd)
			maxfd = finet;
		listen(finet, 5);
d328 1
a328 1
		int domain, nfds, s;
d330 13
d352 2
a353 1
			domain = AF_UNIX, fromlen = sizeof(fromunix);
d356 29
a384 8
		} else /* if (FD_ISSET(finet, &readfds)) */  {
			domain = AF_INET, fromlen = sizeof(frominet);
			s = accept(finet,
			    (struct sockaddr *)&frominet, &fromlen);
			if (frominet.sin_port == htons(20)) {
				close(s);
				continue;
			}
d391 3
a393 1
		if (fork() == 0) {
d399 4
a402 2
			(void) close(funix);
			(void) close(finet);
d405 1
a405 1
				(void) close(s);
d408 1
d410 1
a410 1
				chkhost(&frominet);
d415 6
d422 1
a422 1
		(void) close(s);
d427 1
a427 2
reapchild(signo)
	int signo;
d433 1
a433 1
		;
d438 1
a438 2
mcleanup(signo)
	int signo;
d457 1
a457 1
char	fromb[MAXHOSTNAMELEN];	/* buffer for client's machine name */
d469 1
a469 1
doit()
d479 1
a479 1
			if ((n = read(1, cp, 1)) != 1) {
d488 1
a488 1
			if (*cp >= '\1' && *cp <= '\5')
d491 3
a493 1
			else
d500 2
d510 2
d517 2
d547 2
d587 1
a587 1
startup()
a590 1
	int pid;
d607 2
a608 1
		if ((pid = fork()) < 0) {
d611 2
a612 2
		}
		if (!pid) {
d614 1
d618 3
a621 1
		else free(buf);
d629 1
a629 2
ckqueue(cap)
	char *cap;
d655 1
a655 2
chkhost(f)
	struct sockaddr_in *f;
d657 1
a657 1
	struct hostent *hp;
d661 12
d675 10
a684 5
	hp = gethostbyaddr((char *)&f->sin_addr,
	    sizeof(struct in_addr), f->sin_family);
	if (hp == NULL)
		fatal("Host name for your address (%s) unknown",
			inet_ntoa(f->sin_addr));
d686 1
a686 1
	(void) strlcpy(fromb, hp->h_name, sizeof(fromb));
d689 6
d696 12
a707 7
	hp = gethostbyname(fromb);
	if (!hp)
		fatal("hostname for your address (%s) unknown",
		    inet_ntoa(f->sin_addr));
	for (; good == 0 && hp->h_addr_list[0] != NULL; hp->h_addr_list++) {
		if (!bcmp(hp->h_addr_list[0], (caddr_t)&f->sin_addr,
		    sizeof(f->sin_addr)))
d710 2
d713 2
a714 3
		fatal("address for your hostname (%s) not matched",
		    inet_ntoa(f->sin_addr));

d718 2
a719 3
		if (__ivaliduser(hostf, f->sin_addr.s_addr,
		    DUMMY, DUMMY) == 0) {
			(void) fclose(hostf);
d722 1
a722 1
		(void) fclose(hostf);
d731 90
@


1.27
log
@s/deamon/daemon/
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.26 2002/01/07 15:39:20 millert Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.26 2002/01/07 15:39:20 millert Exp $";
d107 1
a107 1
extern int __ivaliduser __P((FILE *, in_addr_t, const char *, const char *));
d112 6
a117 6
static void       reapchild __P((int));
static void       mcleanup __P((int));
static void       doit __P((void));
static void       startup __P((void));
static void       chkhost __P((struct sockaddr_in *));
static int	  ckqueue __P((char *));
@


1.26
log
@Revert local changes that should not have been committed
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.24 2001/12/06 03:12:30 ericj Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.24 2001/12/06 03:12:30 ericj Exp $";
d175 1
a175 1
		if (errno == EWOULDBLOCK)	/* active deamon present */
@


1.25
log
@To disable a SIGCHLD signal handler use SIG_DFL, *not* SIG_IGN
which now has a different meaning.
@
text
@a94 1
#include <err.h>
a101 1

d107 1
a107 1
#define	LPD_NOPORTCHK	0001		/* skip reserved-port check */
a109 2
int	rflag;				/* allow 'of' for remote printers */
int	sflag;				/* secure (no inet) flag */
a110 11
uid_t	uid;				/* real uid */
uid_t	euid;				/* effective uid */
volatile sig_atomic_t child_count;	/* number of kids forked */

static void        reapchild __P((int));
static void        mcleanup __P((int));
static void        doit __P((void));
static void        startup __P((void));
static void        chkhost __P((struct sockaddr_in *));
static int	   ckqueue __P((char *));
static __dead void usage __P((void));
d112 6
a117 1
extern int __ivaliduser __P((FILE *, in_addr_t, const char *, const char *));
d125 3
a127 1
main(int argc, char **argv)
d129 1
a129 1
	int f, funix, finet, options, check_options, fromlen, ch, lfd;
a130 1
	long child_max = 32;	/* more then enough to hose the system */
a131 1
	char *cp;
d138 1
a138 1
	options = check_options = 0;
d141 4
a144 2
	if (euid != 0)
		err(1, "must run as root");
d146 11
a156 38
	while ((ch = getopt(argc, argv, "dln:rsw:W")) != -1) {
		switch (ch) {
		case 'd':
			options |= SO_DEBUG;
			break;
		case 'l':
			lflag++;
			break;
		case 'n':
			child_max = strtol(optarg, &cp, 10);
			if (*cp != '\0' || child_max < 0 || child_max > 1024)
				errx(1, "invalid number of children: %s",
				    optarg);
		case 'r':
			rflag++;
			break;
		case 's':
			sflag++;
			break;
		case 'w':
			wait_time = strtol(optarg, &cp, 10);
			if (*cp != '\0' || wait_time < 0)
				errx(1, "wait time must be postive integer: %s",
				    optarg);
			if (wait_time < 30)
				warnx("warning: wait time less than 30 seconds");
			break;
		case 'W':
			/*
			 * Allow connections coming from a non-reserved port.
			 * (done by some lpr-implementations for MS-Windows)
			 */
			check_options |= LPD_NOPORTCHK;
			break;
		default:
			usage();
			break;
		}
a157 2
	argc -= optind;
	argv += optind;
d168 1
a168 1
	(void)umask(0);
d184 1
a184 1
	(void)snprintf(line, sizeof(line), "%u\n", getpid());
d195 2
a196 2
	(void)unlink(_PATH_SOCKETNAME);
	funix = socket(AF_LOCAL, SOCK_STREAM, 0);
d207 1
a207 1
	(void)umask(07);
d213 2
a214 2
	un.sun_family = AF_LOCAL;
	strlcpy(un.sun_path, _PATH_SOCKETNAME, sizeof(un.sun_path));
d222 1
a222 1
	(void)umask(0);
d229 1
a229 1
	finet = sflag ? -1 : socket(AF_INET, SOCK_STREAM, 0);
d240 1
a240 1
		(void)setsockopt(finet, SOL_SOCKET, SO_REUSEADDR, &f,
a266 13
		short sleeptime = 10;	/* overflows in about 2 hours */

		while (child_max < child_count) {
			syslog(LOG_WARNING,
			    "too many children, sleeping for %d seconds",
			    sleeptime);
			sleep(sleeptime);
			sleeptime <<= 1;
			if (sleeptime < 0) {
				syslog(LOG_CRIT, "sleeptime overflowed! help!");
				sleeptime = 10;
			}
		}
d276 1
a276 1
			domain = AF_LOCAL, fromlen = sizeof(fromunix);
d293 1
a293 2
		switch (fork()) {
		case 0:
d299 2
a300 3
			(void)close(funix);
			if (finet != -1)
				(void)close(finet);
d303 1
a303 1
				(void)close(s);
a311 6
		case -1:
			syslog(LOG_WARNING, "fork: %m, sleeping for 10 seconds...");
			sleep(10);
			continue;
		default:
			child_count++;
d313 1
a313 1
		(void)close(s);
d318 2
a319 1
reapchild(int signo)
d325 1
a325 1
		child_count--;
d330 2
a331 1
mcleanup(int signo)
d362 1
a362 1
doit(void)
d470 1
a470 1
startup(void)
d509 2
a510 1
ckqueue(char *cap)
d536 2
a537 1
chkhost(struct sockaddr_in *f)
d551 1
a551 1
	(void)strlcpy(fromb, hp->h_name, sizeof(fromb));
d573 1
a573 1
			(void)fclose(hostf);
d576 1
a576 1
		(void)fclose(hostf);
a584 9
}

static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-dls]\n", __progname);
	exit(1);
@


1.24
log
@
use err/warn and friends instead of printf/exit.
also, remove fatal2() which is just errx anyway.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.23 2001/11/23 03:58:18 deraadt Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.23 2001/11/23 03:58:18 deraadt Exp $";
d95 1
d103 1
d109 1
a109 1
extern int __ivaliduser __P((FILE *, in_addr_t, const char *, const char *));
d112 2
d115 11
d127 1
a127 6
static void       reapchild __P((int));
static void       mcleanup __P((int));
static void       doit __P((void));
static void       startup __P((void));
static void       chkhost __P((struct sockaddr_in *));
static int	  ckqueue __P((char *));
d135 1
a135 3
main(argc, argv)
	int argc;
	char **argv;
d137 1
a137 1
	int f, lfd, funix, finet, options, fromlen;
d139 1
d141 1
d148 1
a148 1
	options = 0;
d151 2
a152 4
	if (euid != 0) {
		fprintf(stderr,"lpd: must run as root\n");
		exit(1);
	}
d154 38
a191 11
	while (--argc > 0) {
		argv++;
		if (argv[0][0] == '-')
			switch (argv[0][1]) {
			case 'd':
				options |= SO_DEBUG;
				break;
			case 'l':
				lflag++;
				break;
			}
d193 2
d205 1
a205 1
	(void) umask(0);
d221 1
a221 1
	sprintf(line, "%u\n", getpid());
d232 2
a233 2
	(void) unlink(_PATH_SOCKETNAME);
	funix = socket(AF_UNIX, SOCK_STREAM, 0);
d244 1
a244 1
	(void) umask(07);
d250 2
a251 2
	un.sun_family = AF_UNIX;
	strcpy(un.sun_path, _PATH_SOCKETNAME);
d259 1
a259 1
	(void) umask(0);
d266 1
a266 1
	finet = socket(AF_INET, SOCK_STREAM, 0);
d277 1
a277 1
		(void) setsockopt(finet, SOL_SOCKET, SO_REUSEADDR, &f,
d304 13
d326 1
a326 1
			domain = AF_UNIX, fromlen = sizeof(fromunix);
d343 3
a345 2
		if (fork() == 0) {
			signal(SIGCHLD, SIG_IGN);
d350 3
a352 2
			(void) close(funix);
			(void) close(finet);
d355 1
a355 1
				(void) close(s);
d364 6
d371 1
a371 1
		(void) close(s);
d376 1
a376 2
reapchild(signo)
	int signo;
d382 1
a382 1
		;
d387 1
a387 2
mcleanup(signo)
	int signo;
d418 1
a418 1
doit()
d526 1
a526 1
startup()
d565 1
a565 2
ckqueue(cap)
	char *cap;
d591 1
a591 2
chkhost(f)
	struct sockaddr_in *f;
d605 1
a605 1
	(void) strlcpy(fromb, hp->h_name, sizeof(fromb));
d627 1
a627 1
			(void) fclose(hostf);
d630 1
a630 1
		(void) fclose(hostf);
d639 9
@


1.23
log
@use the same siginterrupt() trick in lpc(1) as in timedc(1). we have to hack
a global into the other programs since they share some source.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.22 2001/11/19 20:27:13 deraadt Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.22 2001/11/19 20:27:13 deraadt Exp $";
a139 2

	name = "lpd";
@


1.22
log
@only slight fixes needed in signal handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.21 2001/09/05 00:22:49 deraadt Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.21 2001/09/05 00:22:49 deraadt Exp $";
d118 3
@


1.21
log
@do not select(20, ...)
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.20 2001/09/04 23:35:59 millert Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.20 2001/09/04 23:35:59 millert Exp $";
d320 1
a321 1
	int save_errno = errno;
d332 2
d335 1
a335 1
		syslog(LOG_INFO, "exiting");
d337 1
a337 1
	exit(0);
@


1.20
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.19 2001/08/30 23:24:46 millert Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.19 2001/08/30 23:24:46 millert Exp $";
d128 1
d225 2
d254 2
d268 1
a268 1
		nfds = select(20, &readfds, 0, 0, 0);
@


1.19
log
@When using dup2() to make a socket be stdout, first check that it
is not already stdout (fd 1).  Otherwise we end up closing stdout
which is not the intention.  Also use STDOUT_FILENO instead of 1.
From a conversation with huntting@@glarp.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.18 2001/08/30 17:38:13 millert Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.18 2001/08/30 17:38:13 millert Exp $";
d126 1
a126 1
	int f, funix, finet, options, fromlen;
d130 1
a130 1
	int omask, lfd;
d199 6
a204 2
#define	mask(s)	(1 << ((s) - 1))
	omask = sigblock(mask(SIGHUP)|mask(SIGINT)|mask(SIGQUIT)|mask(SIGTERM));
d221 1
a221 1
	sigsetmask(omask);
@


1.18
log
@o kill register
o add const to rcsid and copyright strings
o placate -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.17 2001/06/22 15:27:20 lebel Exp $ */
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: lpd.c,v 1.17 2001/06/22 15:27:20 lebel Exp $";
d291 4
a294 2
			dup2(s, 1);
			(void) close(s);
@


1.17
log
@use strlcpy vs strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.16 1998/08/03 16:53:16 millert Exp $ */
d39 1
a39 1
static char copyright[] =
d46 1
a46 1
static char sccsid[] = "@@(#)lpd.c	8.7 (Berkeley) 5/10/95";
d48 1
a48 1
static char rcsid[] = "$OpenBSD: lpd.c,v 1.16 1998/08/03 16:53:16 millert Exp $";
d89 1
d350 2
a351 2
	register char *cp;
	register int n;
d459 1
a459 1
	register char *cp;
d498 1
a498 1
	register struct dirent *d;
d525 2
a526 2
	register struct hostent *hp;
	register FILE *hostf;
@


1.16
log
@Set SO_REUSEADDR on printer/tcp service (port 515); csapuntz@@clearviewtech.com
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.15 1997/08/04 19:26:13 deraadt Exp $ */
d48 1
a48 1
static char rcsid[] = "$OpenBSD: lpd.c,v 1.15 1997/08/04 19:26:13 deraadt Exp $";
d536 1
a536 2
	(void) strncpy(fromb, hp->h_name, sizeof(fromb)-1);
	from[sizeof(fromb) - 1] = '\0';
@


1.15
log
@save errno in sigchld handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.14 1997/07/19 07:11:43 deraadt Exp $ */
d48 1
a48 1
static char rcsid[] = "$OpenBSD: lpd.c,v 1.14 1997/07/19 07:11:43 deraadt Exp $";
d224 1
a224 1
		if (options & SO_DEBUG)
d229 4
@


1.14
log
@Wall cleanup; people running lpd should test!
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.13 1997/01/17 16:12:41 millert Exp $ */
d48 1
a48 1
static char rcsid[] = "$OpenBSD: lpd.c,v 1.13 1997/01/17 16:12:41 millert Exp $";
d305 1
d309 1
@


1.13
log
@Add OpenBSD tags (was in wrong dir for previous commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.12 1996/12/20 15:58:40 deraadt Exp $ */
d48 1
a48 1
static char rcsid[] = "$OpenBSD: $";
d106 2
d362 1
a362 1
					from, cmdnames[*cp], cp+1);
a520 1
	extern char *inet_ntoa();
@


1.12
log
@initialize name; is this the right hack?
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.11 1996/11/03 23:24:08 millert Exp $ */
d45 1
d47 3
@


1.11
log
@Improve portability by using ANSI/POSIX interfaces when possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.10 1996/10/26 12:33:41 deraadt Exp $ */
d129 2
@


1.10
log
@we are so ftp bounce paranoid, we checked twice!
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.9 1996/09/21 21:05:41 deraadt Exp $ */
d129 5
a133 1
	name = argv[0];
d296 1
a296 1
	union wait status;
d298 1
a298 1
	while (wait3((int *)&status, WNOHANG, 0) > 0)
@


1.9
log
@doh
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.8 1996/09/21 21:02:15 deraadt Exp $ */
a510 5

	f->sin_port = ntohs(f->sin_port);
	if (f->sin_family != AF_INET || f->sin_port >= IPPORT_RESERVED ||
	    f->sin_port == 20)
		fatal("Malformed from address");
@


1.8
log
@i so rarely forget htons & friends; this time i did -- warner caught me
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.7 1996/09/21 07:56:31 deraadt Exp $ */
d256 1
a256 1
			if (frominet.s_port == htons(20)) {
@


1.7
log
@oflow protection, ftp bounce protection, dns spoof protection
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.6 1996/08/07 00:20:49 deraadt Exp $ */
d256 1
a256 1
			if (frominet.s_port == 20) {
@


1.6
log
@ftp bounce protection
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.5 1996/07/04 05:46:54 tholo Exp $ */
d256 4
d510 1
d524 1
a524 1
	(void) strncpy(fromb, hp->h_name, sizeof(fromb));
d527 14
@


1.5
log
@Fix bogon in import
@
text
@d1 1
a1 1
/*	$OpenBSD: lpd.c,v 1.4 1996/07/04 05:41:54 tholo Exp $ */
d508 2
a509 1
	if (f->sin_family != AF_INET || f->sin_port >= IPPORT_RESERVED)
@


1.4
log
@Integrated 4.4Lite2 source
Fixed potential problem pointed out by bitblt
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a180 1
	(void) umask(07);
a185 1
	(void) umask(0);
d188 1
d203 1
@


1.3
log
@headers
@
text
@d45 1
a45 1
static char sccsid[] = "@@(#)lpd.c	8.4 (Berkeley) 4/17/94";
d83 1
d110 1
d181 1
d187 1
d443 4
d452 2
d462 1
d464 24
d489 2
@


1.2
log
@save some bytes of disk
@
text
@d1 3
@


1.1
log
@Initial revision
@
text
@a499 12












@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
