head	1.59;
access;
symbols
	OPENBSD_6_2_BASE:1.59
	OPENBSD_6_1:1.58.0.4
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.57.0.4
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.54.0.6
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.52.0.6
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.47.0.6
	OPENBSD_5_4_BASE:1.47
	OPENBSD_5_3:1.47.0.4
	OPENBSD_5_3_BASE:1.47
	OPENBSD_5_2:1.47.0.2
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.46
	OPENBSD_5_1:1.46.0.8
	OPENBSD_5_0:1.46.0.6
	OPENBSD_5_0_BASE:1.46
	OPENBSD_4_9:1.46.0.4
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.46.0.2
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.44.0.10
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.6
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.44.0.4
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.44.0.2
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.42.0.2
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.41.0.2
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.40.0.6
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.40.0.4
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.40.0.2
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.39.0.4
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	OPENBSD_3_5:1.37.0.4
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.37.0.2
	OPENBSD_3_4_BASE:1.37
	OPENBSD_3_3:1.36.0.4
	OPENBSD_3_3_BASE:1.36
	OPENBSD_3_2:1.36.0.2
	OPENBSD_3_2_BASE:1.36
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.19.0.12
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.19.0.10
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.19.0.8
	OPENBSD_2_5_BASE:1.19
	OPENBSD_2_4:1.19.0.6
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.19.0.4
	OPENBSD_2_3_BASE:1.19
	OPENBSD_2_2:1.19.0.2
	OPENBSD_2_2_BASE:1.19
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.59
date	2017.09.20.05.08.11;	author guenther;	state Exp;
branches;
next	1.58;
commitid	OJ6DHjqJx1OIIUVD;

1.58
date	2016.11.22.16.03.57;	author millert;	state Exp;
branches;
next	1.57;
commitid	Bw3s1MAC1sykKnNA;

1.57
date	2016.01.29.21.23.11;	author tb;	state Exp;
branches;
next	1.56;
commitid	nfYRi4ShtJzlEepu;

1.56
date	2016.01.12.23.35.13;	author tb;	state Exp;
branches;
next	1.55;
commitid	6TIpGjc6KPGjJcnt;

1.55
date	2015.08.20.22.46.32;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	bryBnuht7UhcZOWL;

1.54
date	2015.01.16.06.40.18;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	Uu5nFG3wCl0LACBb;

1.53
date	2014.12.16.03.35.49;	author millert;	state Exp;
branches;
next	1.52;
commitid	nQ60kcXwyMctmczv;

1.52
date	2014.02.07.23.06.21;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2014.01.20.19.52.45;	author tobias;	state Exp;
branches;
next	1.50;

1.50
date	2014.01.20.19.51.46;	author tobias;	state Exp;
branches;
next	1.49;

1.49
date	2013.12.10.16.38.04;	author naddy;	state Exp;
branches;
next	1.48;

1.48
date	2013.11.24.21.32.32;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.46;

1.46
date	2010.03.22.16.50.38;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.27.23.59.52;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.10.14.29.53;	author tobias;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.02.15.19.38;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2007.04.07.21.57.27;	author stevesk;	state Exp;
branches;
next	1.41;

1.41
date	2006.12.11.20.50.55;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2005.04.28.10.14.26;	author moritz;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.14.20.52.20;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.13.23.23.02;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.02.23.36.53;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2002.07.27.22.30.00;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.13.06.48.40;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.08.23.23.24;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.08.01.53.43;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.05.20.23.13.50;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.02.16.21.28.04;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.01.21.17.30.38;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.19.20.27.13;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2001.10.29.18.13.51;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.19.10.58.08;	author mpech;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.30.17.38.13;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.30.17.25.35;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.09.07.05.02;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.22.15.27.20;	author lebel;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.15.05.20.35;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.28.23.52.36;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.09.09.04.27.27;	author millert;	state Exp;
branches
	1.19.12.1;
next	1.18;

1.18
date	97.09.09.00.09.35;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.07.27.20.01.36;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.07.25.20.12.12;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.07.23.10.12.43;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.07.21.05.24.12;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.07.20.19.04.34;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.07.19.07.11.44;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.04.04.18.41.44;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.11.03.23.24.10;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.10.25.19.38.23;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.09.30.21.24.34;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.09.21.07.55.35;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.18.18.20.48;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.07.27.10.31.17;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.04.05.41.55;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.06.28.18.04.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.05.16.14.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.41;	author deraadt;	state Exp;
branches;
next	;

1.19.12.1
date	2000.10.07.04.03.31;	author jason;	state Exp;
branches;
next	;


desc
@@


1.59
log
@Avoid overflow/truncation during string->integer converion by eliminating
the 'int' temporary variable.

problem reported by Jacob Zimmermann (jacobz (at) senseofsecurity.com.au)
ok deraadt@@
@
text
@/*	$OpenBSD: printjob.c,v 1.58 2016/11/22 16:03:57 millert Exp $	*/
/*	$NetBSD: printjob.c,v 1.31 2002/01/21 14:42:30 wiz Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * printjob -- print jobs in the queue.
 *
 *	NOTE: the lock file is used to pass information to lpq and lprm.
 *	it does not need to be removed because file locks are dynamic.
 */

#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/file.h>

#include <pwd.h>
#include <unistd.h>
#include <signal.h>
#include <termios.h>
#include <syslog.h>
#include <fcntl.h>
#include <dirent.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>

#include "lp.h"
#include "lp.local.h"
#include "pathnames.h"
#include "extern.h"

#define DORETURN	0	/* absorb fork error */
#define DOABORT		1	/* abort if dofork fails */

/*
 * Error tokens
 */
#define REPRINT		-2
#define ERROR		-1
#define	OK		0
#define	FATALERR	1
#define	NOACCT		2
#define	FILTERERR	3
#define	ACCESS		4

static dev_t	 fdev;		/* device of file pointed to by symlink */
static ino_t	 fino;		/* inode of file pointed to by symlink */
static FILE	*cfp;		/* control file */
static pid_t	 child;		/* pid of any filters */
static int	 lfd;		/* lock file descriptor */
static int	 ofd;		/* output filter file descriptor */
static pid_t	 ofilter;	/* pid of output filter, if any */
static int	 pfd;		/* prstatic inter file descriptor */
static pid_t	 pid;		/* pid of lpd process */
static pid_t	 prchild;	/* pid of pr process */
static char	 title[80];	/* ``pr'' title */
static int	 tof;		/* true if at top of form */

static char	class[32];		/* classification field */
static char	fromhost[HOST_NAME_MAX+1]; /* user's host machine */
				/* indentation size in static characters */
static char	indent[10] = "-i0";
static char	jobname[NAME_MAX];	/* job or file name */
static char	length[10] = "-l";	/* page length in lines */
static char	logname[LOGIN_NAME_MAX];/* user's login name */
static char	pxlength[10] = "-y";	/* page length in pixels */
static char	pxwidth[10] = "-x";	/* page width in pixels */
static char	tempfile[] = "errsXXXXXXXXXX"; /* file name for filter output */
static char	width[10] = "-w";	/* page width in static characters */

static void       abortpr(int);
static void       banner(char *, char *);
static void       delay(int);
static pid_t      dofork(int);
static int        dropit(int);
static void       init(void);
static void       openpr(void);
static void       opennet(char *);
static void       opentty(void);
static void       openrem(void);
static int        print(int, char *);
static int        printit(char *);
static void       pstatus(const char *, ...)
	__attribute__((__format__(__printf__, 1, 2)));
static char       response(void);
static void       scan_out(int, char *, int);
static char      *scnline(int, char *, int);
static int        sendfile(int, char *);
static int        sendit(char *);
static void       sendmail(char *, int);
static void       setty(void);
static void       alarmer(int);

void
printjob(void)
{
	struct stat stb;
	struct queue *q, **qp;
	struct queue **queue;
	struct sigaction sa;
	int i, fd, nitems;
	off_t pidoff;
	int errcnt, count = 0;

	init();					/* set up capabilities */
	(void)write(STDOUT_FILENO, "", 1);	/* ack that daemon is started */
	PRIV_START;
	fd = open(LF, O_WRONLY|O_APPEND, 0664);	/* set up log file */
	PRIV_END;
	if (fd < 0) {
		syslog(LOG_ERR, "%s: %m", LF);
		if ((fd = open(_PATH_DEVNULL, O_WRONLY)) < 0)
			exit(1);
	}
	if (fd != STDERR_FILENO) {
		if (dup2(fd, STDERR_FILENO) < 0) {
			syslog(LOG_ERR, "dup2: %m");
			exit(1);
		}
		(void)close(fd);
	}
	setpgid(0, 0);

	/* we add SIGINT to the mask so abortpr() doesn't kill itself */
	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = abortpr;
	sa.sa_flags = SA_RESTART;
	sigemptyset(&sa.sa_mask);
	sigaddset(&sa.sa_mask, SIGINT);
	sigaction(SIGHUP, &sa, NULL);
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGQUIT, &sa, NULL);
	sigaction(SIGTERM, &sa, NULL);

	/* so we can use short form file names */
	if (chdir(SD) < 0) {
		syslog(LOG_ERR, "%s: %m", SD);
		exit(1);
	}

	(void)mktemp(tempfile);			/* safe */

	lfd = safe_open(LO, O_WRONLY|O_CREAT|O_NOFOLLOW|O_EXLOCK, 0640);
	if (lfd < 0) {
		if (errno == EWOULDBLOCK)	/* active daemon present */
			exit(0);
		syslog(LOG_ERR, "%s: %s: %m", printer, LO);
		exit(1);
	}
	if (fstat(lfd, &stb) == 0 && (stb.st_mode & S_IXUSR))
		exit(0);		/* printing disabled */
	ftruncate(lfd, 0);
	/*
	 * write process id for others to know
	 */
	pid = getpid();
	if ((pidoff = i = snprintf(line, sizeof(line), "%d\n", pid)) >=
	    sizeof(line) || pidoff == -1) {
		syslog(LOG_ERR, "impossibly large pid: %u", pid);
		exit(1);
	}
	if (write(lfd, line, i) != i) {
		syslog(LOG_ERR, "%s: %s: %m", printer, LO);
		exit(1);
	}
	/*
	 * search the spool directory for work and sort by queue order.
	 */
	if ((nitems = getq(&queue)) < 0) {
		syslog(LOG_ERR, "%s: can't scan %s", printer, SD);
		exit(1);
	}
	if (nitems == 0)		/* no work to do */
		exit(0);
	if (stb.st_mode & S_IXOTH) {		/* reset queue flag */
		stb.st_mode &= ~S_IXOTH;
		if (fchmod(lfd, stb.st_mode & 0777) < 0)
			syslog(LOG_ERR, "%s: %s: %m", printer, LO);
	}
	PRIV_START;
	openpr();			/* open printer or remote */
	PRIV_END;

again:
	/*
	 * we found something to do now do it --
	 *    write the name of the current control file into the lock file
	 *    so the spool queue program can tell what we're working on
	 */
	for (qp = queue; nitems--; free(q)) {
		q = *qp++;
		if (stat(q->q_name, &stb) < 0)
			continue;
		errcnt = 0;
	restart:
		fdev = (dev_t)-1;
		fino = (ino_t)-1;

		(void)lseek(lfd, pidoff, SEEK_SET);
		if ((i = snprintf(line, sizeof(line), "%s\n", q->q_name)) >=
		    sizeof(line) || i == -1)
			i = sizeof(line) - 1;	/* can't happen */
		if (write(lfd, line, i) != i)
			syslog(LOG_ERR, "%s: %s: %m", printer, LO);
		if (!remote)
			i = printit(q->q_name);
		else
			i = sendit(q->q_name);
		/*
		 * Check to see if we are supposed to stop printing or
		 * if we are to rebuild the queue.
		 */
		if (fstat(lfd, &stb) == 0) {
			/* stop printing before starting next job? */
			if (stb.st_mode & S_IXUSR)
				goto done;
			/* rebuild queue (after lpc topq) */
			if (stb.st_mode & S_IXOTH) {
				for (free(q); nitems--; free(q))
					q = *qp++;
				stb.st_mode &= ~S_IXOTH;
				if (fchmod(lfd, stb.st_mode & 0777) < 0)
					syslog(LOG_WARNING, "%s: %s: %m",
						printer, LO);
				break;
			}
		}
		if (i == OK)		/* file ok and printed */
			count++;
		else if (i == REPRINT && ++errcnt < 5) {
			/* try reprinting the job */
			syslog(LOG_INFO, "restarting %s", printer);
			if (ofilter > 0) {
				kill(ofilter, SIGCONT);	/* to be sure */
				(void)close(ofd);
				while ((i = wait(NULL)) > 0 && i != ofilter)
					;
				ofilter = 0;
			}
			(void)close(pfd);	/* close printer */
			if (ftruncate(lfd, pidoff) < 0)
				syslog(LOG_WARNING, "%s: %s: %m", printer, LO);
			PRIV_START;
			openpr();		/* try to reopen printer */
			PRIV_END;
			goto restart;
		} else {
			syslog(LOG_WARNING, "%s: job could not be %s (%s)", printer,
				remote ? "sent to remote host" : "printed", q->q_name);
			if (i == REPRINT) {
				/* ensure we don't attempt this job again */
				PRIV_START;
				(void)unlink(q->q_name);
				q->q_name[0] = 'd';
				(void)unlink(q->q_name);
				PRIV_END;
				if (logname[0])
					sendmail(logname, FATALERR);
			}
		}
	}
	free(queue);
	/*
	 * search the spool directory for more work.
	 */
	if ((nitems = getq(&queue)) < 0) {
		syslog(LOG_ERR, "%s: can't scan %s", printer, SD);
		exit(1);
	}
	if (nitems == 0) {		/* no more work to do */
	done:
		if (count > 0) {	/* Files actually printed */
			if (!SF && !tof)
				(void)write(ofd, FF, strlen(FF));
			if (TR != NULL)		/* output trailer */
				(void)write(ofd, TR, strlen(TR));
		}
		(void)close(ofd);
		(void)wait(NULL);
		(void)unlink(tempfile);
		exit(0);
	}
	goto again;
}

#define	FONTLEN	50
char	fonts[4][FONTLEN];	/* fonts for troff */

char ifonts[4][40] = {
	_PATH_VFONTR,
	_PATH_VFONTI,
	_PATH_VFONTB,
	_PATH_VFONTS,
};

/*
 * The remaining part is the reading of the control file (cf)
 * and performing the various actions.
 */
static int
printit(char *file)
{
	int i, fd;
	char *cp;
	int bombed = OK;

	/*
	 * open control file; ignore if no longer there.
	 */
	fd = safe_open(file, O_RDONLY|O_NOFOLLOW, 0);
	if (fd < 0 || (cfp = fdopen(fd, "r")) == NULL) {
		syslog(LOG_INFO, "%s: %s: %m", printer, file);
		if (fd >= 0)
			(void)close(fd);
		return(OK);
	}
	/*
	 * Reset troff fonts.
	 */
	for (i = 0; i < 4; i++)
		strlcpy(fonts[i], ifonts[i], FONTLEN);
	(void)snprintf(&width[2], sizeof(width) - 2, "%ld", PW);
	indent[2] = '0';
	indent[3] = '\0';

	/*
	 *      read the control file for work to do
	 *
	 *      file format -- first character in the line is a command
	 *      rest of the line is the argument.
	 *      valid commands are:
	 *
	 *		S -- "stat info" for symbolic link protection
	 *		J -- "job name" on banner page
	 *		C -- "class name" on banner page
	 *              L -- "literal" user's name to print on banner
	 *		T -- "title" for pr
	 *		H -- "host name" of machine where lpr was done
	 *              P -- "person" user's login name
	 *              I -- "indent" amount to indent output
	 *		R -- laser dpi "resolution"
	 *              f -- "file name" name of text file to print
	 *		l -- "file name" text file with control chars
	 *		p -- "file name" text file to print with pr(1)
	 *		t -- "file name" troff(1) file to print
	 *		n -- "file name" ditroff(1) file to print
	 *		d -- "file name" dvi file to print
	 *		g -- "file name" plot(1G) file to print
	 *		v -- "file name" plain raster file to print
	 *		c -- "file name" cifplot file to print
	 *		1 -- "R font file" for troff
	 *		2 -- "I font file" for troff
	 *		3 -- "B font file" for troff
	 *		4 -- "S font file" for troff
	 *		N -- "name" of file (used by lpq)
	 *              U -- "unlink" name of file to remove
	 *                    (after we print it. (Pass 2 only)).
	 *		M -- "mail" to user when done printing
	 *
	 *      get_line reads a line and expands tabs to blanks
	 */

	/* pass 1 */

	while (get_line(cfp))
		switch (line[0]) {
		case 'H':
			strlcpy(fromhost, line+1, sizeof(fromhost));
			if (class[0] == '\0')
				strlcpy(class, line+1, sizeof(class));
			continue;

		case 'P':
			strlcpy(logname, line+1, sizeof(logname));
			if (RS) {			/* restricted */
				if (getpwnam(logname) == NULL) {
					bombed = NOACCT;
					sendmail(line+1, bombed);
					goto pass2;
				}
			}
			continue;

		case 'S':
			cp = line+1;
			fdev = 0;
			while (*cp >= '0' && *cp <= '9')
				fdev = fdev * 10 + (*cp++ - '0');
			cp++;
			fino = 0;
			while (*cp >= '0' && *cp <= '9')
				fino = fino * 10 + (*cp++ - '0');
			continue;

		case 'J':
			if (line[1] != '\0')
				strlcpy(jobname, line+1, sizeof(jobname));
			else {
				jobname[0] = ' ';
				jobname[1] = '\0';
			}
			continue;

		case 'C':
			if (line[1] != '\0')
				strlcpy(class, line+1, sizeof(class));
			else if (class[0] == '\0')
				gethostname(class, sizeof(class));
			continue;

		case 'T':	/* header title for pr */
			strlcpy(title, line+1, sizeof(title));
			continue;

		case 'L':	/* identification line */
			if (!SH && !HL)
				banner(line+1, jobname);
			continue;

		case '1':	/* troff fonts */
		case '2':
		case '3':
		case '4':
			if (line[1] != '\0')
				strlcpy(fonts[line[0]-'1'], line+1, FONTLEN);
			continue;

		case 'W':	/* page width */
			strlcpy(width+2, line+1, sizeof(width) - 2);
			continue;

		case 'I':	/* indent amount */
			strlcpy(indent+2, line+1, sizeof(indent) - 2);
			continue;

		default:	/* some file to print */
			switch (i = print(line[0], line+1)) {
			case ERROR:
				if (bombed == OK)
					bombed = FATALERR;
				break;
			case REPRINT:
				(void)fclose(cfp);
				return(REPRINT);
			case FILTERERR:
			case ACCESS:
				bombed = i;
				sendmail(logname, bombed);
			}
			title[0] = '\0';
			continue;

		case 'N':
		case 'U':
		case 'M':
		case 'R':
			continue;
		}

	/* pass 2 */

pass2:
	fseek(cfp, 0L, SEEK_SET);
	while (get_line(cfp))
		switch (line[0]) {
		case 'L':	/* identification line */
			if (!SH && HL)
				banner(line+1, jobname);
			continue;

		case 'M':
			if (bombed < NOACCT)	/* already sent if >= NOACCT */
				sendmail(line+1, bombed);
			continue;

		case 'U':
			if (strchr(line+1, '/'))
				continue;
			(void)unlink(line+1);
		}
	/*
	 * clean-up in case another control file exists
	 */
	(void)fclose(cfp);
	(void)unlink(file);
	return(bombed == OK ? OK : ERROR);
}

/*
 * Print a file.
 * Set up the chain [ PR [ | {IF, OF} ] ] or {IF, RF, TF, NF, DF, CF, VF}.
 * Return -1 if a non-recoverable error occurred,
 * 2 if the filter detected some errors (but printed the job anyway),
 * 1 if we should try to reprint this job and
 * 0 if all is well.
 * Note: all filters take stdin as the file, stdout as the printer,
 * stderr as the log file, and must not ignore SIGINT.
 */
static int
print(int format, char *file)
{
	ssize_t nread;
	struct stat stb;
	pid_t pid;
	char *prog, *av[17], buf[BUFSIZ];
	int fd, status, serrno;
	int n, fi, fo, p[2], stopped = 0, nofile;

	if (fdev != (dev_t)-1 && fino != (ino_t)-1) {
		/* symbolic link */
		PRIV_START;
		fi = safe_open(file, O_RDONLY, 0);
		PRIV_END;
		if (fi != -1) {
			/*
			 * The symbolic link should still point to the same file
			 * or someone is trying to print something he shouldn't.
			 */
			if (fstat(fi, &stb) == -1 ||
			    stb.st_dev != fdev || stb.st_ino != fino) {
				close(fi);
				return(ACCESS);
			}
		}
	} else {
		/* regular file */
		PRIV_START;
		fi = safe_open(file, O_RDONLY|O_NOFOLLOW, 0);
		PRIV_END;
	}
	if (fi == -1)
		return(ERROR);
	if (!SF && !tof) {		/* start on a fresh page */
		(void)write(ofd, FF, strlen(FF));
		tof = 1;
	}
	if (IF == NULL && (format == 'f' || format == 'l' || format == 'o')) {
		tof = 0;
		while ((n = read(fi, buf, BUFSIZ)) > 0)
			if (write(ofd, buf, n) != n) {
				(void)close(fi);
				return(REPRINT);
			}
		(void)close(fi);
		return(OK);
	}
	switch (format) {
	case 'p':	/* print file using 'pr' */
		if (IF == NULL) {	/* use output filter */
			prog = _PATH_PR;
			av[0] = "pr";
			av[1] = width;
			av[2] = length;
			av[3] = "-h";
			av[4] = *title ? title : " ";
			av[5] = NULL;
			fo = ofd;
			goto start;
		}
		pipe(p);
		if ((prchild = dofork(DORETURN)) == 0) {	/* child */
			dup2(fi, 0);		/* file is stdin */
			dup2(p[1], 1);		/* pipe is stdout */
			closelog();
			nofile = sysconf(_SC_OPEN_MAX);
			for (n = 3; n < nofile; n++)
				(void)close(n);
			execl(_PATH_PR, "pr", width, length,
			    "-h", *title ? title : " ", (char *)NULL);
			syslog(LOG_ERR, "cannot execl %s", _PATH_PR);
			exit(2);
		}
		(void)close(p[1]);		/* close output side */
		(void)close(fi);
		if (prchild < 0) {
			prchild = 0;
			(void)close(p[0]);
			return(ERROR);
		}
		fi = p[0];			/* use pipe for input */
	case 'f':	/* print plain text file */
		prog = IF;
		av[1] = width;
		av[2] = length;
		av[3] = indent;
		n = 4;
		break;
	case 'o':       /* print postscript file */
		/*
		 * Treat this as a "plain file with control characters", and
		 * assume the standard LPF_INPUT filter will recognize that
		 * the data is postscript and know what to do with it.  These
		 * 'o'-file requests could come from MacOS 10.1 systems.
		 * (later versions of MacOS 10 will explicitly use 'l')
		 * A postscript file can contain binary data, which is why 'l'
		 * is somewhat more appropriate than 'f'.
		 */
		/* FALLTHROUGH */
	case 'l':	/* like 'f' but pass control characters */
		prog = IF;
		av[1] = "-c";
		av[2] = width;
		av[3] = length;
		av[4] = indent;
		n = 5;
		break;
	case 'r':	/* print a fortran text file */
		prog = RF;
		av[1] = width;
		av[2] = length;
		n = 3;
		break;
	case 't':	/* print troff output */
	case 'n':	/* print ditroff output */
	case 'd':	/* print tex output */
		(void)unlink(".railmag");
		if ((fo = open(".railmag", O_CREAT|O_WRONLY|O_EXCL, FILMOD)) < 0) {
			syslog(LOG_ERR, "%s: cannot create .railmag", printer);
			(void)unlink(".railmag");
		} else {
			for (n = 0; n < 4; n++) {
				if (fonts[n][0] != '/')
					(void)write(fo, _PATH_VFONT,
					    sizeof(_PATH_VFONT) - 1);
				(void)write(fo, fonts[n], strlen(fonts[n]));
				(void)write(fo, "\n", 1);
			}
			(void)close(fo);
		}
		prog = (format == 't') ? TF : (format == 'n') ? NF : DF;
		av[1] = pxwidth;
		av[2] = pxlength;
		n = 3;
		break;
	case 'c':	/* print cifplot output */
		prog = CF;
		av[1] = pxwidth;
		av[2] = pxlength;
		n = 3;
		break;
	case 'g':	/* print plot(1G) output */
		prog = GF;
		av[1] = pxwidth;
		av[2] = pxlength;
		n = 3;
		break;
	case 'v':	/* print raster output */
		prog = VF;
		av[1] = pxwidth;
		av[2] = pxlength;
		n = 3;
		break;
	default:
		(void)close(fi);
		syslog(LOG_ERR, "%s: illegal format character '%c'",
			printer, format);
		return(ERROR);
	}
	if (prog == NULL) {
		(void)close(fi);
		syslog(LOG_ERR,
		    "%s: no filter found in printcap for format character '%c'",
		    printer, format);
		return(ERROR);
	}
	if ((av[0] = strrchr(prog, '/')) != NULL)
		av[0]++;
	else
		av[0] = prog;
	av[n++] = "-n";
	av[n++] = logname;
	if (*jobname != '\0' && strcmp(jobname, " ") != 0) {
		av[n++] = "-j";
		av[n++] = jobname;
	}
	av[n++] = "-h";
	av[n++] = fromhost;
	av[n++] = AF;
	av[n] = 0;
	fo = pfd;
	if (ofilter > 0) {		/* stop output filter */
		write(ofd, "\031\1", 2);
		while ((pid = waitpid((pid_t)-1, &status, WUNTRACED)) > 0
		    && pid != ofilter)
			;
		if (WIFSTOPPED(status) == 0) {
			(void)close(fi);
			syslog(LOG_WARNING,
			    "%s: output filter died (retcode=%d termsig=%d)",
			    printer, WEXITSTATUS(status), WTERMSIG(status));
			return(REPRINT);
		}
		stopped++;
	}
start:
	if ((child = dofork(DORETURN)) == 0) {	/* child */
		dup2(fi, 0);
		dup2(fo, 1);
		unlink(tempfile);
		n = open(tempfile, O_WRONLY|O_CREAT|O_EXCL, 0664);
		if (n >= 0)
			dup2(n, 2);
		closelog();
		nofile = sysconf(_SC_OPEN_MAX);
		for (n = 3; n < nofile; n++)
			(void)close(n);
		execv(prog, av);
		syslog(LOG_ERR, "cannot execv %s", prog);
		_exit(2);
	}
	serrno = errno;
	(void)close(fi);
	errno = serrno;
	if (child < 0) {
		child = prchild = tof = 0;
		syslog(LOG_ERR, "cannot start child process: %m");
		return (ERROR);
	}
	while ((pid = wait(&status)) > 0 && pid != child)
		;
	child = 0;
	prchild = 0;
	if (stopped) {		/* restart output filter */
		if (kill(ofilter, SIGCONT) < 0) {
			syslog(LOG_ERR, "cannot restart output filter");
			exit(1);
		}
	}
	tof = 0;

	/* Copy filter output to "lf" logfile */
	fd = safe_open(tempfile, O_RDONLY|O_NOFOLLOW, 0);
	if (fd >= 0) {
		while ((nread = read(fd, buf, sizeof(buf))) > 0)
			(void)write(STDERR_FILENO, buf, nread);
		(void)close(fd);
	}

	if (!WIFEXITED(status)) {
		syslog(LOG_WARNING, "%s: filter '%c' terminated (termsig=%d)",
		    printer, format, WTERMSIG(status));
		return(ERROR);
	}
	switch (WEXITSTATUS(status)) {
	case 0:
		tof = 1;
		return(OK);
	case 1:
		return(REPRINT);
	case 2:
		return(ERROR);
	default:
		syslog(LOG_WARNING, "%s: filter '%c' exited (retcode=%d)",
		    printer, format, WEXITSTATUS(status));
		return(FILTERERR);
	}
}

/*
 * Send the daemon control file (cf) and any data files.
 * Return -1 if a non-recoverable error occurred, 1 if a recoverable error and
 * 0 if all is well.
 */
static int
sendit(char *file)
{
	int fd, i, err = OK;
	char *cp, last[BUFSIZ];

	/* open control file */
	fd = safe_open(file, O_RDONLY|O_NOFOLLOW, 0);
	if (fd < 0 || (cfp = fdopen(fd, "r")) == NULL)
		return(OK);
	/*
	 *      read the control file for work to do
	 *
	 *      file format -- first character in the line is a command
	 *      rest of the line is the argument.
	 *      commands of interest are:
	 *
	 *            a-z -- "file name" name of file to print
	 *              U -- "unlink" name of file to remove
	 *                    (after we print it. (Pass 2 only)).
	 */

	/*
	 * pass 1
	 */
	while (get_line(cfp)) {
	again:
		if (line[0] == 'S') {
			cp = line+1;
			fdev = 0;
			while (*cp >= '0' && *cp <= '9')
				fdev = fdev * 10 + (*cp++ - '0');
			cp++;
			fino = 0;
			while (*cp >= '0' && *cp <= '9')
				fino = fino * 10 + (*cp++ - '0');
			continue;
		}
		if (line[0] >= 'a' && line[0] <= 'z') {
			strlcpy(last, line, sizeof(last));
			while ((i = get_line(cfp)) != 0)
				if (strcmp(last, line))
					break;
			switch (sendfile('\3', last+1)) {
			case OK:
				if (i)
					goto again;
				break;
			case REPRINT:
				(void)fclose(cfp);
				return(REPRINT);
			case ACCESS:
				sendmail(logname, ACCESS);
			case ERROR:
				err = ERROR;
			}
			break;
		}
	}
	if (err == OK && sendfile('\2', file) > 0) {
		(void)fclose(cfp);
		return(REPRINT);
	}
	/*
	 * pass 2
	 */
	fseek(cfp, 0L, SEEK_SET);
	while (get_line(cfp))
		if (line[0] == 'U' && strchr(line+1, '/') == 0)
			(void)unlink(line+1);
	/*
	 * clean-up in case another control file exists
	 */
	(void)fclose(cfp);
	(void)unlink(file);
	return(err);
}

/*
 * Send a data file to the remote machine and spool it.
 * Return positive if we should try resending.
 */
static int
sendfile(int type, char *file)
{
	int f, i, amt;
	struct stat stb;
	char buf[BUFSIZ];
	int sizerr, resp;

	if (fdev != (dev_t)-1 && fino != (ino_t)-1) {
		/* symbolic link */
		PRIV_START;
		f = safe_open(file, O_RDONLY, 0);
		PRIV_END;
		if (f != -1) {
			/*
			 * The symbolic link should still point to the same file
			 * or someone is trying to print something he shouldn't.
			 */
			if (fstat(f, &stb) == -1 ||
			    stb.st_dev != fdev || stb.st_ino != fino) {
				close(f);
				return(ACCESS);
			}
		}
	} else {
		/* regular file */
		PRIV_START;
		f = safe_open(file, O_RDONLY|O_NOFOLLOW, 0);
		PRIV_END;
		if (fstat(f, &stb) == -1) {
			close(f);
			f = -1;
		}
	}
	if (f == -1)
		return(ERROR);
	if ((amt = snprintf(buf, sizeof(buf), "%c%lld %s\n", type,
	    (long long)stb.st_size, file)) >= sizeof(buf) || amt == -1)
		return (ACCESS);		/* XXX hack */
	for (i = 0;  ; i++) {
		if (write(pfd, buf, amt) != amt ||
		    (resp = response()) < 0 || resp == '\1') {
			(void)close(f);
			return(REPRINT);
		} else if (resp == '\0')
			break;
		if (i == 0)
			pstatus("no space on remote; waiting for queue to drain");
		if (i == 10)
			syslog(LOG_ALERT, "%s: can't send to %s; queue full",
				printer, RM);
		sleep(5 * 60);
	}
	if (i)
		pstatus("sending to %s", RM);
	sizerr = 0;
	for (i = 0; i < stb.st_size; i += BUFSIZ) {
		struct sigaction osa, nsa;

		amt = BUFSIZ;
		if (i + amt > stb.st_size)
			amt = stb.st_size - i;
		if (sizerr == 0 && read(f, buf, amt) != amt)
			sizerr = 1;
		memset(&nsa, 0, sizeof(nsa));
		nsa.sa_handler = alarmer;
		sigemptyset(&nsa.sa_mask);
		nsa.sa_flags = 0;
		(void)sigaction(SIGALRM, &nsa, &osa);
		alarm(wait_time);
		if (write(pfd, buf, amt) != amt) {
			alarm(0);
			(void)sigaction(SIGALRM, &osa, NULL);
			(void)close(f);
			return(REPRINT);
		}
		alarm(0);
		(void)sigaction(SIGALRM, &osa, NULL);
	}

	(void)close(f);
	if (sizerr) {
		syslog(LOG_INFO, "%s: %s: changed size", printer, file);
		/* tell recvjob to ignore this file */
		(void)write(pfd, "\1", 1);
		return(ERROR);
	}
	if (write(pfd, "", 1) != 1 || response())
		return(REPRINT);
	return(OK);
}

/*
 * Check to make sure there have been no errors and that both programs
 * are in sync with eachother.
 * Return non-zero if the connection was lost.
 */
static char
response(void)
{
	struct sigaction osa, nsa;
	char resp;

	memset(&nsa, 0, sizeof(nsa));
	nsa.sa_handler = alarmer;
	sigemptyset(&nsa.sa_mask);
	nsa.sa_flags = 0;
	(void)sigaction(SIGALRM, &nsa, &osa);
	alarm(wait_time);
	if (read(pfd, &resp, 1) != 1) {
		syslog(LOG_INFO, "%s: lost connection", printer);
		resp = -1;
	}
	alarm(0);
	(void)sigaction(SIGALRM, &osa, NULL);
	return (resp);
}

/*
 * Banner printing stuff
 */
static void
banner(char *name1, char *name2)
{
	time_t tvec;

	time(&tvec);
	if (!SF && !tof)
		(void)write(ofd, FF, strlen(FF));
	if (SB) {	/* short banner only */
		if (class[0]) {
			(void)write(ofd, class, strlen(class));
			(void)write(ofd, ":", 1);
		}
		(void)write(ofd, name1, strlen(name1));
		(void)write(ofd, "  Job: ", 7);
		(void)write(ofd, name2, strlen(name2));
		(void)write(ofd, "  Date: ", 8);
		(void)write(ofd, ctime(&tvec), 24);
		(void)write(ofd, "\n", 1);
	} else {	/* normal banner */
		(void)write(ofd, "\n\n\n", 3);
		scan_out(ofd, name1, '\0');
		(void)write(ofd, "\n\n", 2);
		scan_out(ofd, name2, '\0');
		if (class[0]) {
			(void)write(ofd, "\n\n\n", 3);
			scan_out(ofd, class, '\0');
		}
		(void)write(ofd, "\n\n\n\n\t\t\t\t\tJob:  ", 15);
		(void)write(ofd, name2, strlen(name2));
		(void)write(ofd, "\n\t\t\t\t\tDate: ", 12);
		(void)write(ofd, ctime(&tvec), 24);
		(void)write(ofd, "\n", 1);
	}
	if (!SF)
		(void)write(ofd, FF, strlen(FF));
	tof = 1;
}

static char *
scnline(int key, char *p, int c)
{
	int scnwidth;

	for (scnwidth = WIDTH; --scnwidth;) {
		key <<= 1;
		*p++ = key & 0200 ? c : BACKGND;
	}
	return (p);
}

#define TRC(q)	(((q)-' ')&0177)

static void
scan_out(int scfd, char *scsp, int dlm)
{
	char *strp;
	int nchrs, j;
	char outbuf[LINELEN+1], *sp, c, cc;
	int d, scnhgt;
	extern char scnkey[][HEIGHT];	/* in lpdchar.c */

	for (scnhgt = 0; scnhgt++ < HEIGHT+DROP; ) {
		strp = &outbuf[0];
		sp = scsp;
		for (nchrs = 0; ; ) {
			d = dropit(c = TRC(cc = *sp++));
			if ((!d && scnhgt > HEIGHT) || (scnhgt <= DROP && d))
				for (j = WIDTH; --j;)
					*strp++ = BACKGND;
			else
				strp = scnline(scnkey[(int)c][scnhgt-1-d],
				    strp, cc);
			if (*sp == dlm || *sp == '\0' ||
			    nchrs++ >= PW/(WIDTH+1)-1)
				break;
			*strp++ = BACKGND;
			*strp++ = BACKGND;
		}
		while (*--strp == BACKGND && strp >= outbuf)
			;
		strp++;
		*strp++ = '\n';	
		(void)write(scfd, outbuf, strp-outbuf);
	}
}

static int
dropit(int c)
{
	switch(c) {

	case TRC('_'):
	case TRC(';'):
	case TRC(','):
	case TRC('g'):
	case TRC('j'):
	case TRC('p'):
	case TRC('q'):
	case TRC('y'):
		return (DROP);

	default:
		return (0);
	}
}

/*
 * sendmail ---
 *   tell people about job completion
 */
static void
sendmail(char *user, int bombed)
{
	int i, p[2], s, nofile;
	char *cp = NULL;
	struct stat stb;
	FILE *fp;

	if (user[0] == '-' || user[0] == '/' || !isprint((unsigned char)user[0]))
		return;
	pipe(p);
	if ((s = dofork(DORETURN)) == 0) {		/* child */
		dup2(p[0], 0);
		closelog();
		nofile = sysconf(_SC_OPEN_MAX);
		for (i = 3; i < nofile; i++)
			(void)close(i);
		if ((cp = strrchr(_PATH_SENDMAIL, '/')) != NULL)
			cp++;
		else
			cp = _PATH_SENDMAIL;
		execl(_PATH_SENDMAIL, cp, "-t", (char *)NULL);
		_exit(0);
	} else if (s > 0) {				/* parent */
		dup2(p[1], 1);
		printf("Auto-Submitted: auto-generated\n");
		printf("To: %s@@%s\n", user, fromhost);
		printf("Subject: %s printer job \"%s\"\n", printer,
			*jobname ? jobname : "<unknown>");
		printf("Reply-To: root@@%s\n\n", host);
		printf("Your printer job ");
		if (*jobname)
			printf("(%s) ", jobname);
		switch (bombed) {
		case OK:
			printf("\ncompleted successfully\n");
			cp = "OK";
			break;
		default:
		case FATALERR:
			printf("\ncould not be printed\n");
			cp = "FATALERR";
			break;
		case NOACCT:
			printf("\ncould not be printed without an account on %s\n", host);
			cp = "NOACCT";
			break;
		case FILTERERR:
			cp = "FILTERERR";
			if (stat(tempfile, &stb) < 0 || stb.st_size == 0 ||
			    (fp = fopen(tempfile, "r")) == NULL) {
				printf("\nhad some errors and may not have printed\n");
				break;
			}
			printf("\nhad the following errors and may not have printed:\n");
			while ((i = getc(fp)) != EOF)
				putchar(i);
			(void)fclose(fp);
			break;
		case ACCESS:
			printf("\nwas not printed because it was not linked to the original file\n");
			cp = "ACCESS";
		}
		fflush(stdout);
		(void)close(1);
	} else {
		syslog(LOG_ERR, "fork for sendmail failed: %m");
	}
	(void)close(p[0]);
	(void)close(p[1]);
	if (s != -1) {
		wait(NULL);
		syslog(LOG_INFO,
		    "mail sent to user %s about job %s on printer %s (%s)",
		    user, *jobname ? jobname : "<unknown>", printer, cp);
	}
}

/* sleep n milliseconds */
static void
delay(int n)
{
	struct timespec tdelay;

	if (n <= 0 || n > 10000)
		fatal("unreasonable delay period (%d)", n);
	tdelay.tv_sec = n / 1000;
	tdelay.tv_nsec = n * 1000000 % 1000000000;
	nanosleep(&tdelay, NULL);
}

/*
 * dofork - fork with retries on failure
 */
static pid_t
dofork(int action)
{
	struct passwd *pw;
	pid_t pid;
	int i;

	for (i = 0; i < 20; i++) {
		if ((pid = fork()) < 0) {
			sleep((unsigned)(i*i));
			continue;
		}
		/*
		 * Child should run as daemon instead of root
		 */
		if (pid == 0) {
			(void)close(lfd);
			PRIV_START;
			pw = getpwuid(DU);
			if (pw == 0) {
				syslog(LOG_ERR, "uid %ld not in password file",
				    DU);
				break;
			}
			initgroups(pw->pw_name, pw->pw_gid);
			setgid(pw->pw_gid);
			setlogin("");
			setuid(DU);
		}
		return (pid);
	}
	syslog(LOG_ERR, "can't fork");

	switch (action) {
	case DORETURN:
		return (-1);
	default:
		syslog(LOG_ERR, "bad action (%d) to dofork", action);
		/*FALL THRU*/
	case DOABORT:
		exit(1);
	}
	/*NOTREACHED*/
}

/*
 * Kill child processes to abort current job.
 */
static void
abortpr(int signo)
{
	(void)close(lfd);
	(void)unlink(tempfile);
	(void)kill(0, SIGINT);
	if (ofilter > 0)
		kill(ofilter, SIGCONT);
	while (wait(NULL) > 0)
		;
	_exit(0);
}

static void
init(void)
{
	int status;
	char *s;

	PRIV_START;
	status = cgetent(&bp, printcapdb, printer);
	PRIV_END;

	switch (status) {
	case -1:
		syslog(LOG_ERR, "unknown printer: %s", printer);
		exit(1);
	case -2:
		syslog(LOG_ERR, "can't open printer description file");
		exit(1);
	case -3:
		fatal("potential reference loop detected in printcap file");
	default:
		break;
	}

	if (cgetstr(bp, DEFLP, &LP) == -1)
		LP = _PATH_DEFDEVLP;
	if (cgetstr(bp, "rp", &RP) == -1)
		RP = DEFLP;
	if (cgetstr(bp, "lo", &LO) == -1)
		LO = DEFLOCK;
	if (cgetstr(bp, "st", &ST) == -1)
		ST = DEFSTAT;
	if (cgetstr(bp, "lf", &LF) == -1)
		LF = _PATH_CONSOLE;
	if (cgetstr(bp, "sd", &SD) == -1)
		SD = _PATH_DEFSPOOL;
	if (cgetnum(bp, "du", &DU) < 0)
		DU = DEFUID;
	if (cgetstr(bp, "ff", &FF) == -1)
		FF = DEFFF;
	if (cgetnum(bp, "pw", &PW) < 0)
		PW = DEFWIDTH;
	(void)snprintf(&width[2], sizeof(width) - 2, "%ld", PW);
	if (cgetnum(bp, "pl", &PL) < 0)
		PL = DEFLENGTH;
	(void)snprintf(&length[2], sizeof(length) - 2, "%ld", PL);
	if (cgetnum(bp, "px", &PX) < 0)
		PX = 0;
	(void)snprintf(&pxwidth[2], sizeof(pxwidth) - 2, "%ld", PX);
	if (cgetnum(bp, "py", &PY) < 0)
		PY = 0;
	(void)snprintf(&pxlength[2], sizeof(pxlength) - 2, "%ld", PY);
	cgetstr(bp, "rm", &RM);
	if ((s = checkremote()) != NULL)
		syslog(LOG_WARNING, "%s", s);

	cgetstr(bp, "af", &AF);
	cgetstr(bp, "of", &OF);
	cgetstr(bp, "if", &IF);
	cgetstr(bp, "rf", &RF);
	cgetstr(bp, "tf", &TF);
	cgetstr(bp, "nf", &NF);
	cgetstr(bp, "df", &DF);
	cgetstr(bp, "gf", &GF);
	cgetstr(bp, "vf", &VF);
	cgetstr(bp, "cf", &CF);
	cgetstr(bp, "tr", &TR);

	RS = (cgetcap(bp, "rs", ':') != NULL);
	SF = (cgetcap(bp, "sf", ':') != NULL);
	SH = (cgetcap(bp, "sh", ':') != NULL);
	SB = (cgetcap(bp, "sb", ':') != NULL);
	HL = (cgetcap(bp, "hl", ':') != NULL);
	RW = (cgetcap(bp, "rw", ':') != NULL);

	cgetnum(bp, "br", &BR);
	cgetstr(bp, "ms", &MS);

	tof = (cgetcap(bp, "fo", ':') == NULL);
}

/*
 * Acquire line printer or remote connection.
 * XXX - should push down privs in here
 */
static void
openpr(void)
{
	int i, nofile;
	char *cp;
	extern int rflag;

	if (!remote && *LP) {
		if ((cp = strchr(LP, '@@')))
			opennet(cp);
		else
			opentty();
	} else if (remote) {
		openrem();
	} else {
		syslog(LOG_ERR, "%s: no line printer device or host name",
			printer);
		exit(1);
	}

	/*
	 * Start up an output filter, if needed.
	 */
	if ((!remote || rflag) && OF) {
		int p[2];

		pipe(p);
		if ((ofilter = dofork(DOABORT)) == 0) {	/* child */
			dup2(p[0], 0);		/* pipe is std in */
			dup2(pfd, 1);		/* printer is std out */
			closelog();
			nofile = sysconf(_SC_OPEN_MAX);
			for (i = 3; i < nofile; i++)
				(void)close(i);
			if ((cp = strrchr(OF, '/')) == NULL)
				cp = OF;
			else
				cp++;
			execl(OF, cp, width, length, (char *)NULL);
			syslog(LOG_ERR, "%s: %s: %m", printer, OF);
			exit(1);
		}
		(void)close(p[0]);		/* close input side */
		ofd = p[1];			/* use pipe for output */
	} else {
		ofd = pfd;
		ofilter = 0;
	}
}

/*
 * Printer connected directly to the network
 * or to a terminal server on the net
 */
static void
opennet(char *cp)
{
	int i;
	int resp, port;
	char save_ch;

	save_ch = *cp;
	*cp = '\0';
	port = atoi(LP);
	if (port <= 0) {
		syslog(LOG_ERR, "%s: bad port number: %s", printer, LP);
		exit(1);
	}
	*cp++ = save_ch;

	for (i = 1; ; i = i < 256 ? i << 1 : i) {
		resp = -1;
		pfd = getport(cp, port);
		if (pfd < 0 && errno == ECONNREFUSED)
			resp = 1;
		else if (pfd >= 0) {
			/*
			 * need to delay a bit for rs232 lines
			 * to stabilize in case printer is
			 * connected via a terminal server
			 */
			delay(500);
			break;
		}
		if (i == 1) {
		   if (resp < 0)
			pstatus("waiting for %s to come up", LP);
		   else
			pstatus("waiting for access to printer on %s", LP);
		}
		sleep(i);
	}
	pstatus("sending to %s port %d", cp, port);
}

/*
 * Printer is connected to an RS232 port on this host
 */
static void
opentty(void)
{
	int i;

	for (i = 1; ; i = i < 32 ? i << 1 : i) {
		pfd = open(LP, RW ? O_RDWR : O_WRONLY);
		if (pfd >= 0) {
			delay(500);
			break;
		}
		if (errno == ENOENT) {
			syslog(LOG_ERR, "%s: %m", LP);
			exit(1);
		}
		if (i == 1)
			pstatus("waiting for %s to become ready (offline ?)",
				printer);
		sleep(i);
	}
	if (isatty(pfd))
		setty();
	pstatus("%s is ready and printing", printer);
}

/*
 * Printer is on a remote host
 */
static void
openrem(void)
{
	int i, n;
	int resp;

	for (i = 1; ; i = i < 256 ? i << 1 : i) {
		resp = -1;
		pfd = getport(RM, 0);
		if (pfd >= 0) {
			if ((n = snprintf(line, sizeof(line), "\2%s\n", RP)) >=
			    sizeof(line) || n == -1)
				n = sizeof(line) - 1;
			if (write(pfd, line, n) == n &&
			    (resp = response()) == '\0')
				break;
			(void)close(pfd);
		}
		if (i == 1) {
			if (resp < 0)
				pstatus("waiting for %s to come up", RM);
			else {
				pstatus("waiting for queue to be enabled on %s",
					RM);
				i = 256;
			}
		}
		sleep(i);
	}
	pstatus("sending to %s", RM);
}

static void
alarmer(int s)
{
	/* nothing */
}

/*
 * setup tty lines.
 */
static void
setty(void)
{
	struct info i;
	char **argv, **ap, **ep, *p, *val;

	i.fd = pfd;
	i.set = i.wset = 0;
	if (ioctl(i.fd, TIOCEXCL, (char *)0) < 0) {
		syslog(LOG_ERR, "%s: ioctl(TIOCEXCL): %m", printer);
		exit(1);
	}
	if (tcgetattr(i.fd, &i.t) < 0) {
		syslog(LOG_ERR, "%s: tcgetattr: %m", printer);
		exit(1);
	}
	if (BR > 0) {
		cfsetspeed(&i.t, BR);
		i.set = 1;
	}
	if (MS) {
		if (ioctl(i.fd, TIOCGETD, &i.ldisc) < 0) {
			syslog(LOG_ERR, "%s: ioctl(TIOCGETD): %m", printer);
			exit(1);
		}
		if (ioctl(i.fd, TIOCGWINSZ, &i.win) < 0)
			syslog(LOG_INFO, "%s: ioctl(TIOCGWINSZ): %m",
			       printer);

		argv = calloc(256, sizeof(char *));
		if (argv == NULL) {
			syslog(LOG_ERR, "%s: malloc: %m", printer);
			exit(1);
		}
		p = strdup(MS);
		ap = argv;
		ep = argv + 255;
		while ((val = strsep(&p, " \t,")) != NULL) {
			if ((*ap++ = strdup(val)) == NULL) {
				syslog(LOG_ERR, "%s: strdup: %m", printer);
				exit(1);
			}
			if (ap == ep) {
				syslog(LOG_ERR, "%s: too many \"ms\" entries",
				    printer);
				exit(1);
			}
		}
		*ap = NULL;

		for (; *argv; ++argv) {
			if (ksearch(&argv, &i))
				continue;
			if (msearch(&argv, &i))
				continue;
			syslog(LOG_INFO, "%s: unknown stty flag: %s",
			       printer, *argv);
		}
	}

	if (i.set && tcsetattr(i.fd, TCSANOW, &i.t) < 0) {
		syslog(LOG_ERR, "%s: tcsetattr: %m", printer);
		exit(1);
	}
	if (i.wset && ioctl(i.fd, TIOCSWINSZ, &i.win) < 0)
		syslog(LOG_INFO, "%s: ioctl(TIOCSWINSZ): %m", printer);
	return;
}

static void
pstatus(const char *msg, ...)
{
	int fd, len;
	char buf[BUFSIZ];
	va_list ap;

	va_start(ap, msg);
	umask(0);
	fd = open(ST, O_WRONLY|O_CREAT|O_NOFOLLOW|O_EXLOCK, 0660);
	if (fd < 0) {
		syslog(LOG_ERR, "%s: %s: %m", printer, ST);
		exit(1);
	}
	ftruncate(fd, 0);
	len = vsnprintf(buf, sizeof(buf), msg, ap);
	va_end(ap);
	if (len == -1) {
		(void)close(fd);
		return;
	}
	if (len >= sizeof(buf))
		len = sizeof(buf) - 1;
	buf[len++] = '\n';		/* replace NUL with newline */
	(void)write(fd, buf, len);
	(void)close(fd);
}
@


1.58
log
@Fix printf of NULL for the FILTERERR case when the tempfile is empty
or missing.  From Sebastien Marie.
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.57 2016/01/29 21:23:11 tb Exp $	*/
d420 1
a420 1
			i = 0;
d422 1
a422 2
				i = i * 10 + (*cp++ - '0');
			fdev = i;
d424 1
a424 1
			i = 0;
d426 1
a426 2
				i = i * 10 + (*cp++ - '0');
			fino = i;
d827 1
a827 1
			i = 0;
d829 1
a829 2
				i = i * 10 + (*cp++ - '0');
			fdev = i;
d831 1
a831 1
			i = 0;
d833 1
a833 2
				i = i * 10 + (*cp++ - '0');
			fino = i;
@


1.57
log
@Remove code that has been disabled for almost 20 years:
No need for bauds structure, since handled by cfsetspeed.
From Chris Bennett, thanks!

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.56 2016/01/12 23:35:13 tb Exp $	*/
d1164 1
a1173 1
			cp = "FILTERERR";
@


1.56
log
@Move prototypes of local functions from lp.h to the .c files and make
functions static if possible.  Move delay() to lpd/printjob.c and fix
an annoying typo.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.55 2015/08/20 22:46:32 deraadt Exp $	*/
a1518 26
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
struct bauds {
	int	baud;
	int	speed;
} bauds[] = {
	50,	B50,
	75,	B75,
	110,	B110,
	134,	B134,
	150,	B150,
	200,	B200,
	300,	B300,
	600,	B600,
	1200,	B1200,
	1800,	B1800,
	2400,	B2400,
	4800,	B4800,
	9600,	B9600,
	19200,	B19200,
	38400,	B38400,
	57600,	B57600,
	115200,	B115200,
	0,	0
};
#endif

a1538 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1539 11
#else
		struct bauds *bp;
		for (bp = bauds; bp->baud; bp++)
			if (BR == bp->baud)
				break;
		if (!bp->baud) {
			syslog(LOG_ERR, "%s: illegal baud rate %d", printer, BR);
			exit(1);
		}
		cfsetspeed(&i.t, bp->speed);
#endif
@


1.55
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.54 2015/01/16 06:40:18 deraadt Exp $	*/
d107 1
d1192 13
@


1.54
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.53 2014/12/16 03:35:49 millert Exp $	*/
d1575 1
a1575 1
		argv = (char **)calloc(256, sizeof(char *));
@


1.53
log
@Replace setpgrp(0, getpid()) with setpgid(0, 0).  OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.52 2014/02/07 23:06:21 millert Exp $	*/
a40 1
#include <sys/param.h>
d56 1
d94 1
a94 1
static char	fromhost[MAXHOSTNAMELEN]; /* user's host machine */
d99 1
a99 1
static char	logname[MAXLOGNAME];	/* user's login name */
@


1.52
log
@Fix remote printing; broken in rev 1.50.  OK guenther@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.51 2014/01/20 19:52:45 tobias Exp $	*/
d155 1
a155 2
	pid = getpid();				/* for use with lprm */
	setpgrp(0, pid);
d189 1
@


1.51
log
@Use SEEK_SET instead of hardcoded 0.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.50 2014/01/20 19:51:46 tobias Exp $	*/
d912 4
@


1.50
log
@Fix race condition during symlink check.  If there was no symbolic link
requested, use O_NOFOLLOW, otherwise make sure afterwards that the
correct file has been referenced (device/inode supplied by 'S' line).

diff basically from and ok millert@@, ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.49 2013/12/10 16:38:04 naddy Exp $	*/
d232 1
a232 1
		(void)lseek(lfd, pidoff, 0);
@


1.49
log
@Remove the printcap fc, fs, xc, xs capabilities from lpd that were used
to configure a tty by poking magic numbers into sgtty.  If needed, the
ms capability, which uses symbolic stty modes, can be used instead.
Better description of ms from FreeBSD.
ok beck@@, deraadt@@, jmc@@ (man page)
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.48 2013/11/24 21:32:32 deraadt Exp $	*/
d229 3
d544 20
a563 2
	PRIV_START;
	if (lstat(file, &stb) < 0 || (fi = safe_open(file, O_RDONLY, 0)) < 0) {
d565 2
a567 10
	}
	PRIV_END;
	/*
	 * Check to see if data file is a symbolic link. If so, it should
	 * still point to the same file or someone is trying to print
	 * something he shouldn't.
	 */
	if (S_ISLNK(stb.st_mode) && fstat(fi, &stb) == 0 &&
	    (stb.st_dev != fdev || stb.st_ino != fino))
		return(ACCESS);
d891 20
a910 2
	PRIV_START;
	if (lstat(file, &stb) < 0 || (f = safe_open(file, O_RDONLY, 0)) < 0) {
d912 2
a914 10
	}
	PRIV_END;
	/*
	 * Check to see if data file is a symbolic link. If so, it should
	 * still point to the same file or someone is trying to print something
	 * he shouldn't.
	 */
	if (S_ISLNK(stb.st_mode) && fstat(f, &stb) == 0 &&
	    (stb.st_dev != fdev || stb.st_ino != fino))
		return(ACCESS);
@


1.48
log
@more ctype cleanups
checked by jca
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.47 2012/03/04 04:05:15 fgsch Exp $	*/
a1304 8
	if (cgetnum(bp, "fc", &FC) < 0)
		FC = 0;
	if (cgetnum(bp, "fs", &FS) < 0)
		FS = 0;
	if (cgetnum(bp, "xc", &XC) < 0)
		XC = 0;
	if (cgetnum(bp, "xs", &XS) < 0)
		XS = 0;
a1575 17
		}
	} else {
		if (FC) {
			sttyclearflags(&i.t, FC);
			i.set = 1;
		}
		if (FS) {
			sttysetflags(&i.t, FS);
			i.set = 1;
		}
		if (XC) {
			sttyclearlflags(&i.t, XC);
			i.set = 1;
		}
		if (XS) {
			sttysetlflags(&i.t, XS);
			i.set = 1;
@


1.47
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.46 2010/03/22 16:50:38 deraadt Exp $	*/
d1096 1
a1096 1
	if (user[0] == '-' || user[0] == '/' || !isprint(user[0]))
@


1.46
log
@Do not leak file descriptor `fd' on error path; from zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.45 2009/10/27 23:59:52 deraadt Exp $	*/
d390 1
a390 1
	 *      getline reads a line and expands tabs to blanks
d395 1
a395 1
	while (getline(cfp))
d496 1
a496 1
	while (getline(cfp))
d811 1
a811 1
	while (getline(cfp)) {
d828 1
a828 1
			while ((i = getline(cfp)) != 0)
d855 1
a855 1
	while (getline(cfp))
@


1.45
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.44 2007/09/10 14:29:53 tobias Exp $	*/
d1630 2
a1631 1
	if (len == -1)
d1633 1
@


1.44
log
@Proper use of fseek/fseeko macros.

OK joris@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.43 2007/09/02 15:19:38 deraadt Exp $	*/
a32 11

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static const char sccsid[] = "@@(#)printjob.c	8.7 (Berkeley) 5/10/95";
#endif /* not lint */

@


1.43
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.42 2007/04/07 21:57:27 stevesk Exp $	*/
d506 1
a506 1
	fseek(cfp, 0L, 0);
d865 1
a865 1
	fseek(cfp, 0L, 0);
@


1.42
log
@KNF, spaces; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.41 2006/12/11 20:50:55 deraadt Exp $	*/
d1567 1
a1567 1
		argv = (char **)malloc(256 * sizeof(char *));
@


1.41
log
@rfc 3834 support: Auto-Submitted: auto-generated on lots of things; from Tamas TEVESZ; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.40 2005/04/28 10:14:26 moritz Exp $	*/
d1013 1
a1013 1
			(void)write(ofd,"\n\n\n",3);
d1278 1
a1278 1
	if (cgetstr(bp,"ff", &FF) == -1)
d1286 1
a1286 1
	if (cgetnum(bp,"px", &PX) < 0)
@


1.40
log
@add vsnprintf error checking. ok cloder@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.39 2004/04/14 20:52:20 millert Exp $	*/
d1124 1
@


1.39
log
@Pass the job name to the input filter via the -j flag.  Some filters
(like foomatic) expect to be able to pass information from lpr via
the job name.  OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.38 2004/04/13 23:23:02 millert Exp $	*/
d1640 2
@


1.38
log
@Treat 'o' format files (PostScript) from MacOS 10.1 the same as 'l',
not 'f', since PostScript can contain binary data.  From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.37 2003/06/02 23:36:53 millert Exp $	*/
d548 1
a548 1
	char *prog, *av[15], buf[BUFSIZ];
d705 4
@


1.37
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.36 2002/07/27 22:30:00 deraadt Exp $	*/
d107 1
a107 1
static char	indent[10] = "-i0"; 
d570 1
a570 1
	if (IF == NULL && (format == 'f' || format == 'l')) {
a613 8
	case 'o':       /* print postscript file */
		/*
		 * For now, treat this as a plain-text file, and assume
		 * the standard LPF_INPUT filter will recognize that it
		 * is postscript and know what to do with it.  These
		 * 'o'-file requests could come from MacOS X systems.
		 */
		/* FALLTHROUGH */
d621 11
@


1.36
log
@merge if() and foo = snprintf checks better; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.35 2002/06/13 06:48:40 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.35
log
@Fixed some lpd bugs while on the plane from Calgary:
o mark fatal() as __dead
o add SIGINT to the signal mask when installing abort() as a handler.
  We can end up in abortpr() due to several different signals and since
  abortpr() kill()s itself with SIGINT we need to explicately protect
  against the current process receiving SIGINT while in abortpr()
o Don't leak the lock fd to children spawned by lpd
o Close the lock file (and thus unlocke immediately in abortpr().
  Otherwise, if there is an output filter the lock file only gets
  closed after we finish waiting for the output filter to die.
  This causes a race condition in lprm such that the per-printer
  daemon does not get restarted when lprm kills the active job
  (noticed during c2k2 with the mp3 printer spool ;-)
o Open the printcap file with privs raised just in case it is not
  world-readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.34 2002/06/08 23:23:24 millert Exp $	*/
d205 2
a206 2
	pidoff = i = snprintf(line, sizeof(line), "%d\n", pid);
	if (pidoff >= sizeof(line)) {
d245 2
a246 2
		i = snprintf(line, sizeof(line), "%s\n", q->q_name);
		if (i >= sizeof(line))
d900 2
a901 3
	amt = snprintf(buf, sizeof(buf), "%c%lld %s\n", type,
	    (long long)stb.st_size, file);
	if (amt >= sizeof(buf))
d1465 2
a1466 2
			n = snprintf(line, sizeof(line), "\2%s\n", RP);
			if (n >= sizeof(line))
@


1.34
log
@o Replace some hard-coded octal constants w/ S_I*
o Remove some unneeded casts to char * when calling free()
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.33 2002/06/08 01:53:43 millert Exp $	*/
d148 1
d168 1
a168 1
		close(fd);
d172 11
a182 4
	signal(SIGHUP, abortpr);
	signal(SIGINT, abortpr);
	signal(SIGQUIT, abortpr);
	signal(SIGTERM, abortpr);
d359 1
a359 1
			close(fd);
d766 1
a766 1
		close(fd);
d1193 1
d1228 1
d1230 1
a1230 1
	kill(0, SIGINT);
d1244 9
a1252 1
	if ((status = cgetent(&bp, printcapdb, printer)) == -2) {
d1255 1
a1255 4
	} else if (status == -1) {
		syslog(LOG_ERR, "unknown printer: %s", printer);
		exit(1);
	} else if (status == -3)
d1257 3
@


1.33
log
@Remove setuid root from lp*.  lpr needs to be setuid daemon so the
files it creates are not owned by the user spooling them but the
others (lpc, lpq, lprm) can get away with setgid daemon.  lpd runs
as user daemon for most things, only changing its uid to 0 for
things that must be done as root.

For the time being, don't require connections to come from a reserved
port since lpq/lpr/lprm can't acquire that w/o setuid root.  In the
near future we will have a mechanism for select non-root processes
to grab reserved ports.

The upshot of this is that spool directories must be writable by
group daemon and the files within the spool dirs must be owned by
daemon.
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.32 2002/05/20 23:13:50 millert Exp $	*/
d230 1
a230 1
	for (qp = queue; nitems--; free((char *) q)) {
d256 1
a256 1
				for (free((char *) q); nitems--; free((char *) q))
d299 1
a299 1
	free((char *) queue);
@


1.32
log
@Pull in useful bits from NetBSD and make our lp* easier to diff and
do some minor cleanup of my own:

o IPv6 support
o ANSI function headers
o use getopt()
o synce usage() with man pages
o passes -Wall on both 32bit and 64bit platforms
o add an option to set the max number of children lpd will fork off
o add an lpd option to bind to specific addresses instead of INADDR_ANY.
o allow user to specify how long to wait for a connection to remote servers
o more strlcpy() and snprintf() usage
o Use FOO_FILENO constants instead of hard-coding 0-2
o Add some keeps to man the page SYNOPSIS to avoid options being split
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.31 2002/02/19 19:39:40 millert Exp $	*/
d75 1
d98 1
a98 1
static int	 child;		/* id of any filters */
d101 1
a101 1
static int	 ofilter;	/* id of output filter, if any */
d103 2
a104 2
static int	 pid;		/* pid of lpd process */
static int	 prchild;	/* id of pr process */
d122 1
a122 1
static int        dofork(int);
d148 1
a148 1
	int i, nitems;
d154 4
a157 2
	(void)close(STDERR_FILENO);		/* set up log file */
	if (open(LF, O_WRONLY|O_APPEND, 0664) < 0) {
d159 9
a167 1
		(void)open(_PATH_DEVNULL, O_WRONLY);
a168 1
	setgid(getegid());
d176 1
a176 5
	(void)mktemp(tempfile);			/* safe */

	/*
	 * uses short form file names
	 */
d181 4
a184 3
	if (stat(LO, &stb) == 0 && (stb.st_mode & S_IXUSR))
		exit(0);		/* printing disabled */
	lfd = open(LO, O_WRONLY|O_CREAT, 0644);
a185 4
		syslog(LOG_ERR, "%s: %s: %m", printer, LO);
		exit(1);
	}
	if (flock(lfd, LOCK_EX|LOCK_NB) < 0) {
d191 2
d216 2
a217 1
		if (fchmod(lfd, stb.st_mode & 0776) < 0)
d220 1
d222 2
d258 2
a259 1
				if (fchmod(lfd, stb.st_mode & 0776) < 0)
d280 1
d282 1
d289 1
d293 1
d340 1
a340 1
	int i;
d347 2
a348 1
	if ((cfp = fopen(file, "r")) == NULL) {
d350 2
d541 1
a541 2
	FILE *fp;
	int status, serrno;
d543 1
d545 2
a546 1
	int n, fi, fo, pid, p[2], stopped = 0, nofile;
d548 3
a550 1
	if (lstat(file, &stb) < 0 || (fi = open(file, O_RDONLY)) < 0)
d552 2
d615 1
a615 1
		 * 'o'-file requests could come from MacOS 10.1 systems.
d643 1
a643 1
		if ((fo = creat(".railmag", FILMOD)) < 0) {
d722 1
a722 1
		n = open(tempfile, O_WRONLY|O_CREAT|O_TRUNC|O_EXCL, 0664);
d754 5
a758 4
	if ((fp = fopen(tempfile, "r")) != NULL) {
		while (fgets(buf, sizeof(buf), fp))
			fputs(buf, stderr);
		fclose(fp);
d776 1
a776 1
			printer, format, WEXITSTATUS(status));
d789 1
a789 1
	int i, err = OK;
d792 3
a794 4
	/*
	 * open control file
	 */
	if ((cfp = fopen(file, "r")) == NULL)
d878 3
a880 1
	if (lstat(file, &stb) < 0 || (f = open(file, O_RDONLY)) < 0)
d882 2
d1169 1
a1169 1
static int
a1171 1
	int i, pid;
d1173 2
d1185 1
d1310 1
d1509 1
a1509 1
	char **argv, **ap, *p, *val;
d1546 1
a1546 1
		argv = (char **)calloc(256, sizeof(char *));
d1548 1
a1548 1
			syslog(LOG_ERR, "%s: calloc: %m", printer);
d1553 1
d1559 5
d1565 1
d1612 2
a1613 2
	fd = open(ST, O_WRONLY|O_CREAT, 0664);
	if (fd < 0 || flock(fd, LOCK_EX) < 0) {
@


1.31
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 2
a2 2
/*	$OpenBSD: printjob.c,v 1.30 2002/02/16 21:28:04 millert Exp $ */
/*	$NetBSD: printjob.c,v 1.9.4.3 1996/07/12 22:31:39 jtc Exp $	*/
d130 2
a131 1
static void       pstatus(const char *, ...);
d139 1
d142 1
a142 1
printjob()
d152 2
a153 2
	(void) write(1, "", 1);			/* ack that daemon is started */
	(void) close(2);			/* set up log file */
d156 1
a156 1
		(void) open(_PATH_DEVNULL, O_WRONLY);
d166 1
a166 1
	(void) mktemp(tempfile);
d175 1
a175 1
	if (stat(LO, &stb) == 0 && (stb.st_mode & 0100))
d192 5
a196 2
	sprintf(line, "%d\n", pid);
	pidoff = i = strlen(line);
d210 1
a210 1
	if (stb.st_mode & 01) {		/* reset queue flag */
d227 4
a230 3
		(void) lseek(lfd, pidoff, 0);
		(void) snprintf(line, sizeof line, "%s\n", q->q_name);
		i = strlen(line);
d243 1
a243 1
			if (stb.st_mode & 0100)
d246 1
a246 1
			if (stb.st_mode & 01) {
d262 1
a262 1
				(void) close(ofd);
d267 1
a267 1
			(void) close(pfd);	/* close printer */
d277 1
a277 1
				(void) unlink(q->q_name);
d279 1
a279 1
				(void) unlink(q->q_name);
d297 1
a297 1
				(void) write(ofd, FF, strlen(FF));
d299 1
a299 1
				(void) write(ofd, TR, strlen(TR));
d301 3
a303 3
		(void) close(ofd);
		(void) wait(NULL);
		(void) unlink(tempfile);
d309 2
a310 1
char	fonts[4][50];	/* fonts for troff */
d324 1
a324 2
printit(file)
	char *file;
d341 4
a344 3
		strcpy(fonts[i], ifonts[i]);
	sprintf(&width[2], "%ld", PW);
	strcpy(indent+2, "0");
d389 1
a389 1
			if (class[0] == '\0') {
a390 1
			}
d418 1
a418 1
			if (line[1] != '\0') {
d420 4
a423 2
			} else
				strcpy(jobname, " ");
d446 2
a447 4
			if (line[1] != '\0') {
				strlcpy(fonts[line[0]-'1'], line+1,
				    50);
			}
d451 1
a451 1
			strlcpy(width+2, line+1, sizeof(width)-2);
d455 1
a455 1
			strlcpy(indent+2, line+1, sizeof(indent)-2);
d465 1
a465 1
				(void) fclose(cfp);
d501 1
a501 1
			(void) unlink(line+1);
d506 2
a507 2
	(void) fclose(cfp);
	(void) unlink(file);
d522 2
a523 7
print(format, file)
	int format;
	char *file;
{
	int n;
	char *prog;
	int fi, fo;
d525 1
a525 3
	char *av[15], buf[BUFSIZ];
	int pid, p[2], stopped = 0, nofile;
	union wait status;
d527 2
d537 1
a537 1
	if ((stb.st_mode & S_IFMT) == S_IFLNK && fstat(fi, &stb) == 0 &&
d541 1
a541 1
		(void) write(ofd, FF, strlen(FF));
d548 1
a548 1
				(void) close(fi);
d551 1
a551 1
		(void) close(fi);
d563 1
a563 1
			av[5] = 0;
d572 3
a574 2
			for (n = 3, nofile = sysconf(_SC_OPEN_MAX); n < nofile; n++)
				(void) close(n);
d580 2
a581 2
		(void) close(p[1]);		/* close output side */
		(void) close(fi);
d584 1
a584 1
			(void) close(p[0]);
d594 1
a594 1
		*/
d620 1
a620 1
		(void) unlink(".railmag");
d623 1
a623 1
			(void) unlink(".railmag");
d627 1
a627 1
					(void) write(fo, _PATH_VFONT,
d629 2
a630 2
				(void) write(fo, fonts[n], strlen(fonts[n]));
				(void) write(fo, "\n", 1);
d632 1
a632 1
			(void) close(fo);
d658 1
a658 1
		(void) close(fi);
d664 1
a664 1
		(void) close(fi);
d666 2
a667 2
		   "%s: no filter found in printcap for format character '%c'",
		   printer, format);
d683 1
a683 1
		while ((pid = waitpid((pid_t)-1, (int *)&status, WUNTRACED)) > 0
d686 2
a687 2
		if (status.w_stopval != WSTOPPED) {
			(void) close(fi);
d690 1
a690 1
			    printer, status.w_retcode, status.w_termsig);
d699 2
a700 1
		n = open(tempfile, O_WRONLY|O_CREAT|O_TRUNC, 0664);
d704 3
a706 2
		for (n = 3, nofile = sysconf(_SC_OPEN_MAX); n < nofile; n++)
			(void) close(n);
d709 9
a717 1
		exit(2);
d719 2
a720 6
	(void) close(fi);
	if (child < 0)
		status.w_retcode = 100;
	else
		while ((pid = wait((int *)&status)) > 0 && pid != child)
			;
d732 1
a732 1
	if ((fp = fopen(tempfile, "r"))) {
d740 1
a740 1
			printer, format, status.w_termsig);
d743 1
a743 1
	switch (status.w_retcode) {
d753 1
a753 1
			printer, format, status.w_retcode);
d764 1
a764 2
sendit(file)
	char *file;
d805 2
a806 2
			strcpy(last, line);
			while ((i = getline(cfp)))
d815 1
a815 1
				(void) fclose(cfp);
d826 1
a826 1
		(void) fclose(cfp);
d834 2
a835 2
		if (line[0] == 'U' && !strchr(line+1, '/'))
			(void) unlink(line+1);
d839 2
a840 2
	(void) fclose(cfp);
	(void) unlink(file);
d849 1
a849 3
sendfile(type, file)
	int type;
	char *file;
d863 1
a863 1
	if ((stb.st_mode & S_IFMT) == S_IFLNK && fstat(f, &stb) == 0 &&
d866 3
a868 2
	if (snprintf(buf, sizeof buf, "%c%qd %s\n", type,
	    stb.st_size, file) > sizeof buf-1)
a869 1
	amt = strlen(buf);
d873 1
a873 1
			(void) close(f);
d888 2
d895 6
d902 3
a904 1
			(void) close(f);
d907 2
d911 1
a911 1
	(void) close(f);
d915 1
a915 1
		(void) write(pfd, "\1", 1);
d929 1
a929 1
response()
d931 1
d934 6
d942 1
a942 1
		return(-1);
d944 3
a946 1
	return(resp);
d953 1
a953 2
banner(name1, name2)
	char *name1, *name2;
d959 1
a959 1
		(void) write(ofd, FF, strlen(FF));
d962 2
a963 2
			(void) write(ofd, class, strlen(class));
			(void) write(ofd, ":", 1);
d965 6
a970 6
		(void) write(ofd, name1, strlen(name1));
		(void) write(ofd, "  Job: ", 7);
		(void) write(ofd, name2, strlen(name2));
		(void) write(ofd, "  Date: ", 8);
		(void) write(ofd, ctime(&tvec), 24);
		(void) write(ofd, "\n", 1);
d972 1
a972 1
		(void) write(ofd, "\n\n\n", 3);
d974 1
a974 1
		(void) write(ofd, "\n\n", 2);
d977 1
a977 1
			(void) write(ofd,"\n\n\n",3);
d980 5
a984 5
		(void) write(ofd, "\n\n\n\n\t\t\t\t\tJob:  ", 15);
		(void) write(ofd, name2, strlen(name2));
		(void) write(ofd, "\n\t\t\t\t\tDate: ", 12);
		(void) write(ofd, ctime(&tvec), 24);
		(void) write(ofd, "\n", 1);
d987 1
a987 1
		(void) write(ofd, FF, strlen(FF));
d992 1
a992 4
scnline(key, p, c)
	int key;
	char *p;
	int c;
d1006 1
a1006 3
scan_out(scfd, scsp, dlm)
	int scfd, dlm;
	char *scsp;
d1023 4
a1026 2
				strp = scnline(scnkey[(int)c][scnhgt-1-d], strp, cc);
			if (*sp == dlm || *sp == '\0' || nchrs++ >= PW/(WIDTH+1)-1)
d1035 1
a1035 1
		(void) write(scfd, outbuf, strp-outbuf);
d1040 1
a1040 2
dropit(c)
	int c;
d1064 1
a1064 3
sendmail(user, bombed)
	char *user;
	int bombed;
d1066 1
a1066 2
	int i, nofile;
	int p[2], s;
d1077 3
a1079 2
		for (i = 3, nofile = sysconf(_SC_OPEN_MAX); i < nofile; i++)
			(void) close(i);
d1085 1
a1085 1
		exit(0);
d1118 1
a1118 1
			(void) fclose(fp);
d1126 3
a1128 1
		(void) close(1);
d1130 2
a1131 2
	(void) close(p[0]);
	(void) close(p[1]);
d1144 1
a1144 2
dofork(action)
	int action;
d1160 2
a1161 2
				syslog(LOG_ERR, "uid %u not in password file",
				    (uid_t)DU);
d1189 1
a1189 2
abortpr(signo)
	int signo;
d1191 1
a1191 1
	(void) unlink(tempfile);
d1201 1
a1201 1
init()
d1215 1
a1215 1
	if (cgetstr(bp, "lp", &LP) == -1)
d1233 1
a1233 1
	sprintf(&width[2], "%ld", PW);
d1236 1
a1236 1
	sprintf(&length[2], "%ld", PL);
d1239 1
a1239 1
	sprintf(&pxwidth[2], "%ld", PX);
d1242 1
a1242 1
	sprintf(&pxlength[2], "%ld", PY);
d1244 1
a1244 1
	if ((s = checkremote()))
d1284 1
a1284 1
openpr()
d1288 1
d1306 1
a1306 1
	if (!remote && OF) {
a1307 1
		char *cp;
d1314 3
a1316 2
			for (i = 3, nofile = sysconf(_SC_OPEN_MAX); i < nofile; i++)
				(void) close(i);
d1325 1
a1325 1
		(void) close(p[0]);		/* close input side */
d1338 1
a1338 2
opennet(cp)
	char *cp;
d1382 1
a1382 1
opentty()
d1410 1
a1410 1
openrem()
d1419 3
a1421 2
			(void) snprintf(line, sizeof line, "\2%s\n", RP);
			n = strlen(line);
d1425 1
a1425 1
			(void) close(pfd);
d1441 6
d1468 1
d1477 1
a1477 1
setty()
d1570 1
a1570 1
	int fd;
d1582 1
a1582 1
	(void)vsnprintf(buf, sizeof(buf) - 1, msg, ap);
d1584 5
a1588 3
	strcat(buf, "\n");
	(void) write(fd, buf, strlen(buf));
	(void) close(fd);
@


1.30
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.29 2002/01/21 17:30:38 deraadt Exp $ */
d73 1
a1539 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a1540 1
#ifdef __STDC__
a1541 5
#else
pstatus(msg, va_alist)
	char *msg;
        va_dcl
#endif
d1546 1
a1546 1
#ifdef __STDC__
a1547 4
#else
	va_start(ap);
#endif

@


1.29
log
@s/deamon/daemon/
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.28 2001/11/19 20:27:13 deraadt Exp $ */
d118 19
a136 19
static void       abortpr __P((int));
static void       banner __P((char *, char *));
static int        dofork __P((int));
static int        dropit __P((int));
static void       init __P((void));
static void       openpr __P((void));
static void       opennet __P((char *));
static void       opentty __P((void));
static void       openrem __P((void));
static int        print __P((int, char *));
static int        printit __P((char *));
static void       pstatus __P((const char *, ...));
static char       response __P((void));
static void       scan_out __P((int, char *, int));
static char      *scnline __P((int, char *, int));
static int        sendfile __P((int, char *));
static int        sendit __P((char *));
static void       sendmail __P((char *, int));
static void       setty __P((void));
@


1.28
log
@only slight fixes needed in signal handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.27 2001/10/29 18:13:51 deraadt Exp $ */
d180 1
a180 1
		if (errno == EWOULDBLOCK)	/* active deamon present */
@


1.27
log
@MacOS 10.1 lpr clients send a format character of "o" to indicate postscript; jabley@@automagic.org
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.26 2001/09/19 10:58:08 mpech Exp $ */
d1177 1
a1177 1
	exit(0);
@


1.26
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.25 2001/08/30 17:38:13 millert Exp $ */
d585 8
@


1.25
log
@o kill register
o add const to rcsid and copyright strings
o placate -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.24 2001/08/30 17:25:35 millert Exp $ */
d507 1
a507 1
 * Return -1 if a non-recoverable error occured,
d743 1
a743 1
 * Return -1 if a non-recoverable error occured, 1 if a recoverable error and
@


1.24
log
@Better buffer lengths (MAXFOO and FOO_MAX) based on a patch from
ianm@@cit.uws.edu.au.
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.23 2001/07/09 07:05:02 deraadt Exp $ */
d39 1
a39 1
static char copyright[] =
d45 1
a45 1
static char sccsid[] = "@@(#)printjob.c	8.7 (Berkeley) 5/10/95";
d73 1
d142 1
a142 1
	register struct queue *q, **qp;
d144 1
a144 1
	register int i, nitems;
d319 1
a319 1
	register int i;
d519 2
a520 2
	register int n;
	register char *prog;
d750 1
a750 1
	register int i, err = OK;
d837 1
a837 1
	register int f, i, amt;
d959 2
a960 2
	register int key;
	register char *p;
d963 1
a963 1
	register scnwidth;
d979 2
a980 2
	register char *strp;
	register nchrs, j;
d1038 1
a1038 1
	register int i, nofile;
d1040 1
a1040 1
	register char *cp = NULL;
d1117 1
a1117 1
	register int i, pid;
d1258 1
a1258 1
	register int i, nofile;
d1312 1
a1312 1
	register int i;
d1356 1
a1356 1
	register int i;
d1384 1
a1384 1
	register int i, n;
d1460 1
a1460 1
		register struct bauds *bp;
d1546 1
a1546 1
	register int fd;
@


1.23
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.22 2001/06/22 15:27:20 lebel Exp $ */
d106 1
a106 1
static char	fromhost[32];		/* user's host machine */
d109 1
a109 1
static char	jobname[100];		/* job or file name */
d111 1
a111 1
static char	logname[MAXLOGNAME];		/* user's login name */
@


1.22
log
@use strlcpy vs strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.21 2001/02/15 05:20:35 deraadt Exp $ */
d572 1
a572 1
			    "-h", *title ? title : " ", 0);
d1055 1
a1055 1
		execl(_PATH_SENDMAIL, cp, "-t", 0);
d1291 1
a1291 1
			execl(OF, cp, width, length, 0);
@


1.21
log
@MAXLOGNAME; ianm@@cit.uws.edu.au
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.20 2000/06/28 23:52:36 deraadt Exp $ */
d379 1
a379 2
			strncpy(fromhost, line+1, sizeof(fromhost)-1);
			fromhost[sizeof(fromhost)-1] = '\0';
d381 1
a381 2
				strncpy(class, line+1, sizeof(class)-1);
				class[sizeof(class)-1] = '\0';
d386 1
a386 2
			strncpy(logname, line+1, sizeof(logname)-1);
			logname[sizeof(logname)-1] = '\0';
d411 1
a411 2
				strncpy(jobname, line+1, sizeof(jobname)-1);
				jobname[sizeof(jobname)-1] = '\0';
d418 1
a418 1
				strncpy(class, line+1, sizeof(class)-1);
a420 1
			class[sizeof(class)-1] = '\0';
d424 1
a424 2
			strncpy(title, line+1, sizeof(title)-1);
			title[sizeof(title)-1] = '\0';
d437 2
a438 3
				strncpy(fonts[line[0]-'1'], line+1,
				    50-1);
				fonts[line[0]-'1'][50-1] = '\0';
d443 1
a443 2
			strncpy(width+2, line+1, sizeof(width)-3);
			width[2+sizeof(width)-3] = '\0';
d447 1
a447 2
			strncpy(indent+2, line+1, sizeof(indent)-3);
			indent[2+sizeof(indent)-3] = '\0';
@


1.20
log
@syslog should use %s
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.19 1997/09/09 04:27:27 millert Exp $ */
d111 1
a111 1
static char	logname[32];		/* user's login name */
@


1.19
log
@Use setlogin("") instead of setlogin(user) since target user is daemon.
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.18 1997/09/09 00:09:35 millert Exp $ */
d1225 1
a1225 1
		syslog(LOG_WARNING, s);
@


1.19.12.1
log
@Pull in patch from current:
Fix (deraadt):
syslog should use %s
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.20 2000/06/28 23:52:36 deraadt Exp $ */
d1225 1
a1225 1
		syslog(LOG_WARNING, "%s", s);
@


1.18
log
@Use setlogin(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.17 1997/07/27 20:01:36 deraadt Exp $ */
d1145 1
a1145 1
			setlogin(pw->pw_name);
@


1.17
log
@use sendmail -t
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.16 1997/07/25 20:12:12 mickey Exp $ */
d1145 1
@


1.16
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.15 1997/07/23 10:12:43 deraadt Exp $ */
a1048 1
	char buf[100];
d1064 1
a1064 2
		snprintf(buf, sizeof buf, "%s@@%s", user, fromhost);
		execl(_PATH_SENDMAIL, cp, buf, 0);
@


1.15
log
@1 byte oflow; Don.Lewis@@tsc.tdk.com
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.14 1997/07/21 05:24:12 deraadt Exp $ */
d1540 1
a1540 1
#if __STDC__
d1547 1
a1547 1
#if __STDC__
d1558 1
a1558 1
#if __STDC__
@


1.14
log
@careful about unlink; oliver
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.13 1997/07/20 19:04:34 deraadt Exp $ */
d1571 1
a1571 1
	(void)vsnprintf(buf, sizeof(buf), msg, ap);
@


1.13
log
@careful with usernames; oliver
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.12 1997/07/19 07:11:44 deraadt Exp $ */
d500 2
d826 1
a826 1
		if (line[0] == 'U')
@


1.12
log
@Wall cleanup; people running lpd should test!
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.11 1997/04/04 18:41:44 deraadt Exp $ */
d188 1
a188 1
	sprintf(line, "%u\n", pid);
d1051 2
d1110 6
a1115 3
	wait(NULL);
	syslog(LOG_INFO, "mail sent to user %s about job %s on printer %s (%s)",
		user, *jobname ? jobname : "<unknown>", printer, cp);
@


1.11
log
@when mktemp() is hard to fix, use 10 X
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.10 1996/11/03 23:24:10 millert Exp $ */
a134 1
static void       set_ttyflags __P((struct termios *));
d334 1
a334 1
	sprintf(&width[2], "%d", PW);
d721 1
a721 1
	if (fp = fopen(tempfile, "r")) {
d796 1
a796 1
			while (i = getline(cfp))
a927 1
	extern char *ctime();
d1000 1
a1000 1
				strp = scnline(scnkey[c][scnhgt-1-d], strp, cc);
d1046 1
a1046 1
	register char *cp;
d1059 1
a1059 1
	else
d1134 2
a1135 2
				syslog(LOG_ERR, "uid %d not in password file",
				    DU);
d1207 1
a1207 1
	sprintf(&width[2], "%d", PW);
d1210 1
a1210 1
	sprintf(&length[2], "%d", PL);
d1213 1
a1213 1
	sprintf(&pxwidth[2], "%d", PX);
d1216 1
a1216 1
	sprintf(&pxlength[2], "%d", PY);
d1218 1
a1218 1
	if (s = checkremote())
d1264 1
a1264 1
		if (cp = strchr(LP, '@@'))
a1358 1
	int resp, port;
d1387 1
a1387 1
	int resp, port;
@


1.10
log
@Improve portability by using ANSI/POSIX interfaces when possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.9 1996/10/25 19:38:23 deraadt Exp $ */
d114 1
a114 1
static char	tempfile[] = "errsXXXXXX"; /* file name for filter output */
@


1.9
log
@proactive bounds checking; help from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.8 1996/09/30 21:24:34 deraadt Exp $ */
d269 1
a269 1
				/* insure we don't attempt this job again */
d577 1
a577 1
			for (n = 3, nofile = getdtablesize(); n < nofile; n++)
d666 1
a666 1
	if ((av[0] = rindex(prog, '/')) != NULL)
d679 2
a680 2
		while ((pid =
		    wait3((int *)&status, WUNTRACED, 0)) > 0 && pid != ofilter)
d685 2
a686 2
				"%s: output filter died (retcode=%d termsig=%d)",
				printer, status.w_retcode, status.w_termsig);
d699 1
a699 1
		for (n = 3, nofile = getdtablesize(); n < nofile; n++)
a891 3



d1057 1
a1057 1
		for (i = 3, nofile = getdtablesize(); i < nofile; i++)
d1059 1
a1059 1
		if ((cp = rindex(_PATH_SENDMAIL, '/')) != NULL)
d1266 1
a1266 1
		if (cp = index(LP, '@@'))
d1290 1
a1290 1
			for (i = 3, nofile = getdtablesize(); i < nofile; i++)
d1292 1
a1292 1
			if ((cp = rindex(OF, '/')) == NULL)
d1494 4
a1497 1
			*ap++ = strdup(val);
@


1.8
log
@avoid NOFILE; from bde@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.7 1996/09/21 07:55:35 deraadt Exp $ */
d222 1
a222 1
		(void) sprintf(line, "%s\n", q->q_name);
d380 3
a382 2
			strcpy(fromhost, line+1);
			if (class[0] == '\0')
d384 2
d390 1
d414 1
a414 1
			if (line[1] != '\0')
d416 2
a417 1
			else
d426 1
d431 1
d443 5
a447 2
			if (line[1] != '\0')
				strcpy(fonts[line[0]-'1'], line+1);
d452 1
d457 1
d859 3
a861 1
	(void) sprintf(buf, "%c%qd %s\n", type, stb.st_size, file);
d1066 1
a1066 1
		sprintf(buf, "%s@@%s", user, fromhost);
d1399 1
a1399 1
			(void) sprintf(line, "\2%s\n", RP);
@


1.7
log
@support 57600, until we get better support
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.6 1996/08/18 18:20:48 tholo Exp $ */
d519 1
a519 1
	int pid, p[2], stopped = 0;
d565 1
a565 1
			for (n = 3; n < NOFILE; n++)
d687 1
a687 1
		for (n = 3; n < NOFILE; n++)
d1035 1
a1035 1
	register int i;
d1046 1
a1046 1
		for (i = 3; i < NOFILE; i++)
d1251 1
a1251 1
	register int i;
d1279 1
a1279 1
			for (i = 3; i < NOFILE; i++)
@


1.6
log
@Wait for an output filter to conmplete before starting the next print job;
from FreeBSD PR 739
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.5 1996/07/27 10:31:17 deraadt Exp $ */
d1426 1
@


1.5
log
@versatile baud rates; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: printjob.c,v 1.4 1996/07/04 05:41:55 tholo Exp $ */
d294 2
@


1.4
log
@Integrated 4.4Lite2 source
Fixed potential problem pointed out by bitblt
@
text
@d1 2
a2 2
/*	$OpenBSD: printjob.c,v 1.3 1996/06/28 18:04:18 deraadt Exp $ */
/*	$NetBSD: printjob.c,v 1.9 1996/04/30 00:07:00 jtc Exp $	*/
d1404 1
d1426 1
a1433 1
	register struct bauds *bp;
d1448 4
d1460 1
@


1.3
log
@closelog() before we trash syslog descriptor
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d45 1
a45 1
static char sccsid[] = "@@(#)printjob.c	8.2 (Berkeley) 4/16/94";
d60 1
a101 1
static int	 remote;	/* true if sending files to remote */
d123 3
d145 2
a146 2
	long pidoff;
	int count = 0;
d219 1
d221 1
a221 1
		(void) lseek(lfd, (off_t)pidoff, 0);
d250 2
a251 1
		else if (i == REPRINT) { /* try reprinting the job */
d256 1
a256 1
				while ((i = wait(0)) > 0 && i != ofilter)
d265 11
d351 1
d466 1
d645 7
d670 3
a672 2
			syslog(LOG_WARNING, "%s: output filter died (%d)",
				printer, status.w_retcode);
d715 1
a715 1
		syslog(LOG_WARNING, "%s: Daemon filter '%c' terminated (%d)",
d725 2
d728 1
a728 1
		syslog(LOG_WARNING, "%s: Daemon filter '%c' exited (%d)",
d730 1
a730 2
	case 2:
		return(ERROR);
d1056 3
a1058 1
		printf("Subject: printer job\n\n");
d1065 1
d1070 1
d1074 1
d1079 1
a1079 1
				printf("\nwas printed but had some errors\n");
d1082 1
a1082 1
			printf("\nwas printed but had the following errors:\n");
d1086 1
d1090 1
d1097 3
a1099 1
	wait(&s);
d1249 2
a1250 2
	register int i, n;
	int resp;
d1252 7
a1258 40
	if (!sendtorem && *LP) {
		for (i = 1; ; i = i < 32 ? i << 1 : i) {
			pfd = open(LP, RW ? O_RDWR : O_WRONLY);
			if (pfd >= 0)
				break;
			if (errno == ENOENT) {
				syslog(LOG_ERR, "%s: %m", LP);
				exit(1);
			}
			if (i == 1)
				pstatus("waiting for %s to become ready (offline ?)", printer);
			sleep(i);
		}
		if (isatty(pfd))
			setty();
		pstatus("%s is ready and printing", printer);
	} else if (RM != NULL) {
		for (i = 1; ; i = i < 256 ? i << 1 : i) {
			resp = -1;
			pfd = getport(RM);
			if (pfd >= 0) {
				(void) sprintf(line, "\2%s\n", RP);
				n = strlen(line);
				if (write(pfd, line, n) == n &&
				    (resp = response()) == '\0')
					break;
				(void) close(pfd);
			}
			if (i == 1) {
				if (resp < 0)
					pstatus("waiting for %s to come up", RM);
				else {
					pstatus("waiting for queue to be enabled on %s", RM);
					i = 256;
				}
			}
			sleep(i);
		}
		pstatus("sending to %s", RM);
		remote = 1;
d1264 1
d1295 109
d1519 1
a1519 1
void
@


1.2
log
@use XS (not XC) flags when setting tty flags; from <brook@@trillium.nmsu.edu>.
@
text
@d544 1
d658 1
d1016 1
d1272 1
@


1.1
log
@Initial revision
@
text
@d1 3
d1382 1
a1382 1
			sttysetlflags(&i.t, XC);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
