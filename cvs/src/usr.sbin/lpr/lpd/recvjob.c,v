head	1.26;
access;
symbols
	OPENBSD_6_0:1.26.0.8
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.4
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.22
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.20
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.16
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.14
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.12
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.10
	OPENBSD_5_0:1.25.0.8
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.23.0.22
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.20
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.18
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.16
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.14
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.12
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.10
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.8
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.6
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.4
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.22.0.4
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.12.0.14
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.12
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.10
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.8
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.6
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.4
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2015.01.16.06.40.18;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	Uu5nFG3wCl0LACBb;

1.25
date	2009.10.27.23.59.52;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2008.09.02.00.14.23;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.23.36.53;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.19.01.24.14;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.08.01.53.43;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.20.23.13.50;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.16.21.28.04;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.27.17.24.27;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.19.20.27.14;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.30.17.38.13;	author millert;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.06.22.15.27.20;	author lebel;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.07.20.40.46;	author todd;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	97.10.05.11.37.01;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.07.25.20.12.13;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.07.20.19.04.18;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.17.06.52.19;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.16.22.31.26;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.01.17.16.12.42;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.12.05.08.13.08;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.11.03.23.24.11;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.10.25.19.38.23;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.21.07.56.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.07.04.05.41.55;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.42;	author deraadt;	state Exp;
branches;
next	;

1.13.2.1
date	2001.11.29.16.01.27;	author miod;	state Exp;
branches;
next	;

1.15.2.1
date	2001.11.30.17.20.22;	author jason;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: recvjob.c,v 1.25 2009/10/27 23:59:52 deraadt Exp $	*/
/*	$NetBSD: recvjob.c,v 1.14 2001/12/04 22:52:44 christos Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Receive printer jobs from the network, queue them and
 * start the printer daemon.
 */
#include <sys/types.h>
#include <sys/mount.h>
#include <sys/stat.h>

#include <unistd.h>
#include <signal.h>
#include <fcntl.h>
#include <dirent.h>
#include <syslog.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <limits.h>
#include "lp.h"
#include "lp.local.h"
#include "extern.h"
#include "pathnames.h"

#define ack()	(void)write(STDOUT_FILENO, sp, 1);

static char	 dfname[NAME_MAX];	/* data files */
static int	 minfree;       /* keep at least minfree blocks available */
static char	*sp = "";
static char	 tfname[NAME_MAX];	/* tmp copy of cf before linking */

static int        chksize(int);
static void       frecverr(const char *, ...)
	__attribute__((__format__(__printf__, 1, 2)));
static int        noresponse(void);
static void       rcleanup(int);
static int        read_number(char *);
static int        readfile(char *, int);
static int        readjob(void);


void
recvjob(void)
{
	struct stat stb;
	int status;

	/*
	 * Perform lookup for printer name or abbreviation
	 */
	if ((status = cgetent(&bp, printcapdb, printer)) == -2)
		frecverr("cannot open printer description file");
	else if (status == -1)
		frecverr("unknown printer %s", printer);
	else if (status == -3)
		fatal("potential reference loop detected in printcap file");
	
	if (cgetstr(bp, "lf", &LF) == -1)
		LF = _PATH_CONSOLE;
	if (cgetstr(bp, "sd", &SD) == -1)
		SD = _PATH_DEFSPOOL;
	if (cgetstr(bp, "lo", &LO) == -1)
		LO = DEFLOCK;

	(void)close(2);			/* set up log file */
	PRIV_START;
	if (open(LF, O_WRONLY|O_APPEND, 0664) < 0) {
		syslog(LOG_ERR, "%s: %m", LF);
		(void)open(_PATH_DEVNULL, O_WRONLY);
	}
	PRIV_END;

	if (chdir(SD) < 0)
		frecverr("%s: %s: %m", printer, SD);
	if (stat(LO, &stb) == 0) {
		if (stb.st_mode & 010) {
			/* queue is disabled */
			putchar('\1');		/* return error code */
			exit(1);
		}
	} else if (stat(SD, &stb) < 0)
		frecverr("%s: %s: %m", printer, SD);

	minfree = 2 * read_number("minfree");	/* scale KB to 512 blocks */
	signal(SIGTERM, rcleanup);
	signal(SIGPIPE, rcleanup);

	if (readjob())
		printjob();
}

/*
 * Read printer jobs sent by lpd and copy them to the spooling directory.
 * Return the number of jobs successfully transferred.
 */
static int
readjob(void)
{
	int size, nfiles;
	char *cp;

	ack();
	nfiles = 0;
	for (;;) {
		/*
		 * Read a command to tell us what to do
		 */
		cp = line;
		do {
			if ((size = read(STDOUT_FILENO, cp, 1)) != 1) {
				if (size < 0)
					frecverr("%s: Lost connection",
					    printer);
				return(nfiles);
			}
		} while (*cp++ != '\n' && (cp - line + 1) < sizeof(line));
		if (cp - line + 1 >= sizeof(line))
			frecverr("readjob overflow");
		*--cp = '\0';
		cp = line;
		switch (*cp++) {
		case '\1':	/* cleanup because data sent was bad */
			rcleanup(0);
			continue;

		case '\2':	/* read cf file */
			size = 0;
			while (*cp >= '0' && *cp <= '9')
				size = size * 10 + (*cp++ - '0');
			if (*cp++ != ' ')
				break;
			/*
			 * host name has been authenticated, we use our
			 * view of the host name since we may be passed
			 * something different than what gethostbyaddr()
			 * returns
			 */
			strlcpy(cp + 6, from, sizeof(line) + line - cp - 6);
			if (strchr(cp, '/'))
				frecverr("readjob: %s: illegal path name", cp);
			strlcpy(tfname, cp, sizeof(tfname));
			tfname[0] = 't';
			if (!chksize(size)) {
				(void)write(STDOUT_FILENO, "\2", 1);
				continue;
			}
			/*
			 * XXX
			 * We blindly believe what the remote host puts
			 * for the path to the df file.  In general this
			 * is OK since we don't allow paths with '/' in
			 * them.  Still, it would be better to sanity
			 * check the cf file sent to us and make the
			 * df name match the cf name we used.  That way
			 * we avoid any possible collisions.
			 */
			if (!readfile(tfname, size)) {
				rcleanup(0);
				continue;
			}
			if (link(tfname, cp) < 0)
				frecverr("link %s %s: %m", tfname, cp);
			(void)unlink(tfname);
			tfname[0] = '\0';
			nfiles++;
			continue;

		case '\3':	/* read df file */
			size = 0;
			while (*cp >= '0' && *cp <= '9')
				size = size * 10 + (*cp++ - '0');
			if (*cp++ != ' ')
				break;
			if (strchr(cp, '/'))
				frecverr("readjob: %s: illegal path name", cp);
			if (!chksize(size)) {
				(void)write(STDOUT_FILENO, "\2", 1);
				continue;
			}
			(void)strlcpy(dfname, cp, sizeof(dfname));
			(void)readfile(dfname, size);
			continue;
		}
		frecverr("protocol screwup: %s", line);
	}
}

/*
 * Read files send by lpd and copy them to the spooling directory.
 */
static int
readfile(char *file, int size)
{
	char *cp;
	char buf[BUFSIZ];
	int i, j, amt;
	int fd, err;

	if ((fd = open(file, O_CREAT|O_EXCL|O_WRONLY, FILMOD)) < 0)
		frecverr("readfile: %s: illegal path name: %m", file);
	ack();
	err = 0;
	for (i = 0; i < size; i += BUFSIZ) {
		amt = BUFSIZ;
		cp = buf;
		if (i + amt > size)
			amt = size - i;
		do {
			j = read(STDOUT_FILENO, cp, amt);
			if (j <= 0)
				frecverr("Lost connection");
			amt -= j;
			cp += j;
		} while (amt > 0);
		amt = BUFSIZ;
		if (i + amt > size)
			amt = size - i;
		if (write(fd, buf, amt) != amt) {
			err++;
			break;
		}
	}
	(void)close(fd);
	if (err)
		frecverr("%s: write error", file);
	if (noresponse()) {		/* file sent had bad data in it */
		if (strchr(file, '/') == NULL)
			(void)unlink(file);
		return(0);
	}
	ack();
	return(1);
}

static int
noresponse(void)
{
	char resp;

	if (read(STDOUT_FILENO, &resp, 1) != 1)
		frecverr("Lost connection");
	if (resp == '\0')
		return(0);
	return(1);
}

/*
 * Check to see if there is enough space on the disk for size bytes.
 * 1 == OK, 0 == Not OK.
 */
static int
chksize(int size)
{
	int64_t spacefree;
	struct statfs sfb;

	if (size <= 0)
		return (0);
	if (statfs(".", &sfb) < 0) {
		syslog(LOG_ERR, "%s: %m", "statfs(\".\")");
		return (1);
	}
	spacefree = sfb.f_bavail * (sfb.f_bsize / 512);
	size = (size + 511) / 512;
	if (minfree + size > spacefree)
		return(0);
	return(1);
}

static int
read_number(char *fn)
{
	char lin[80];
	FILE *fp;

	if ((fp = fopen(fn, "r")) == NULL)
		return (0);
	if (fgets(lin, sizeof(lin), fp) == NULL) {
		fclose(fp);
		return (0);
	}
	fclose(fp);
	return (atoi(lin));
}

/*
 * Remove all the files associated with the current job being transferred.
 */
static void
rcleanup(int signo)
{
	int save_errno = errno;

	if (tfname[0] && strchr(tfname, '/') == NULL)
		(void)unlink(tfname);
	if (dfname[0] && strchr(dfname, '/') == NULL) {
		do {
			do
				(void)unlink(dfname);
			while (dfname[2]-- != 'A')
				;
			dfname[2] = 'z';
		} while (dfname[0]-- != 'd');
	}
	dfname[0] = '\0';
	errno = save_errno;
}

static void
frecverr(const char *msg, ...)
{
	extern char fromb[];
	va_list ap;

	va_start(ap, msg);
	rcleanup(0);
	syslog(LOG_ERR, "%s", fromb);
	vsyslog(LOG_ERR, msg, ap);
	va_end(ap);
	putchar('\1');		/* return error code */
	exit(1);
}
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.24 2008/09/02 00:14:23 deraadt Exp $	*/
d38 1
a38 1
#include <sys/param.h>
d52 1
@


1.24
log
@be more careful in checking disk space; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.23 2003/06/02 23:36:53 millert Exp $	*/
a32 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)recvjob.c	8.2 (Berkeley) 4/27/95";
#else
static const char rcsid[] = "$OpenBSD: recvjob.c,v 1.23 2003/06/02 23:36:53 millert Exp $";
#endif
#endif /* not lint */
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.22 2002/06/19 01:24:14 deraadt Exp $	*/
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: recvjob.c,v 1.22 2002/06/19 01:24:14 deraadt Exp $";
d300 1
a300 1
	int spacefree;
d303 2
@


1.22
log
@stretch some ugly while();
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.21 2002/06/08 01:53:43 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: recvjob.c,v 1.21 2002/06/08 01:53:43 millert Exp $";
@


1.21
log
@Remove setuid root from lp*.  lpr needs to be setuid daemon so the
files it creates are not owned by the user spooling them but the
others (lpc, lpq, lprm) can get away with setgid daemon.  lpd runs
as user daemon for most things, only changing its uid to 0 for
things that must be done as root.

For the time being, don't require connections to come from a reserved
port since lpq/lpr/lprm can't acquire that w/o setuid root.  In the
near future we will have a mechanism for select non-root processes
to grab reserved ports.

The upshot of this is that spool directories must be writable by
group daemon and the files within the spool dirs must be owned by
daemon.
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.20 2002/05/20 23:13:50 millert Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: recvjob.c,v 1.20 2002/05/20 23:13:50 millert Exp $";
d348 2
a349 1
			while (dfname[2]-- != 'A');
@


1.20
log
@Pull in useful bits from NetBSD and make our lp* easier to diff and
do some minor cleanup of my own:

o IPv6 support
o ANSI function headers
o use getopt()
o synce usage() with man pages
o passes -Wall on both 32bit and 64bit platforms
o add an option to set the max number of children lpd will fork off
o add an lpd option to bind to specific addresses instead of INADDR_ANY.
o allow user to specify how long to wait for a connection to remote servers
o more strlcpy() and snprintf() usage
o Use FOO_FILENO constants instead of hard-coding 0-2
o Add some keeps to man the page SYNOPSIS to avoid options being split
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.19 2002/02/19 19:39:40 millert Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: recvjob.c,v 1.19 2002/02/19 19:39:40 millert Exp $";
d116 1
d121 1
d133 1
d197 10
d212 1
a212 1
				frecverr("%s: %m", tfname);
d249 1
a249 2
	fd = open(file, O_CREAT|O_EXCL|O_WRONLY, FILMOD);
	if (fd < 0)
d326 1
a326 1
	if (fgets(lin, 80, fp) == NULL) {
@


1.19
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 2
a2 1
/*	$OpenBSD: recvjob.c,v 1.18 2002/02/16 21:28:04 millert Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: recvjob.c,v 1.18 2002/02/16 21:28:04 millert Exp $";
d75 1
a75 1
#define ack()	(void) write(1, sp, 1);
d83 2
a84 1
static void       frecverr(const char *, ...);
d93 1
a93 1
recvjob()
d115 1
a115 1
	(void) close(2);			/* set up log file */
d118 1
a118 1
		(void) open(_PATH_DEVNULL, O_WRONLY);
d144 1
a144 1
readjob()
d157 1
a157 1
			if ((size = read(1, cp, 1)) != 1) {
d163 2
a164 2
		} while (*cp++ != '\n' && (cp - line + 1) < sizeof line);
		if (cp - line + 1 >= sizeof line)
d188 1
a188 1
			strlcpy(tfname, cp, sizeof tfname);
d191 1
a191 1
				(void) write(1, "\2", 1);
d200 1
a200 1
			(void) unlink(tfname);
d214 1
a214 1
				(void) write(1, "\2", 1);
d217 2
a218 2
			(void) strlcpy(dfname, cp, sizeof dfname);
			(void) readfile(dfname, size);
d229 1
a229 3
readfile(file, size)
	char *file;
	int size;
d247 1
a247 1
			j = read(1, cp, amt);
d261 1
a261 1
	(void) close(fd);
d266 1
a266 1
			(void) unlink(file);
d274 1
a274 1
noresponse()
d278 1
a278 1
	if (read(1, &resp, 1) != 1)
d290 1
a290 2
chksize(size)
	int size;
d307 1
a307 2
read_number(fn)
	char *fn;
d326 1
a326 2
rcleanup(signo)
	int signo;
d331 1
a331 1
		(void) unlink(tfname);
d335 1
a335 1
				(void) unlink(dfname);
@


1.18
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.17 2001/11/27 17:24:27 millert Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: recvjob.c,v 1.17 2001/11/27 17:24:27 millert Exp $";
d68 1
a346 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a347 1
#ifdef __STDC__
a348 5
#else
frecverr(msg, va_alist)
	char *msg;
        va_dcl
#endif
d352 1
a352 1
#ifdef __STDC__
a353 3
#else
	va_start(ap);
#endif
@


1.17
log
@Fix check for '/' in cf file and change the check for '/' in df file
for consistency. Based on a patch from Sebastian Krahmer.
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.16 2001/11/19 20:27:14 deraadt Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: recvjob.c,v 1.16 2001/11/19 20:27:14 deraadt Exp $";
d80 7
a86 7
static int        chksize __P((int));
static void       frecverr __P((const char *, ...));
static int        noresponse __P((void));
static void       rcleanup __P((int));
static int        read_number __P((char *));
static int        readfile __P((char *, int));
static int        readjob __P((void));
@


1.16
log
@only slight fixes needed in signal handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.15 2001/08/30 17:38:13 millert Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: recvjob.c,v 1.15 2001/08/30 17:38:13 millert Exp $";
d183 2
a186 3
			if (strchr(tfname, '/'))
				frecverr("readjob: %s: illegal path name",
				    tfname);
d208 2
a214 3
			if (strchr(dfname, '/'))
				frecverr("readjob: %s: illegal path name",
					dfname);
@


1.15
log
@o kill register
o add const to rcsid and copyright strings
o placate -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.14 2001/06/22 15:27:20 lebel Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: recvjob.c,v 1.14 2001/06/22 15:27:20 lebel Exp $";
d65 1
d332 2
d345 1
@


1.15.2.1
log
@Pull in patch from current:
Fix (millert):
Fix check for '/' in cf file and change the check for '/' in df file
for consistency. Based on a patch from Sebastian Krahmer.
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.15 2001/08/30 17:38:13 millert Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: recvjob.c,v 1.15 2001/08/30 17:38:13 millert Exp $";
a181 2
			if (strchr(cp, '/'))
				frecverr("readjob: %s: illegal path name", cp);
d184 3
a207 2
			if (strchr(cp, '/'))
				frecverr("readjob: %s: illegal path name", cp);
d213 3
@


1.14
log
@use strlcpy vs strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.13 2001/02/07 20:40:46 todd Exp $	*/
d38 1
a38 1
static char copyright[] =
d45 1
a45 1
static char sccsid[] = "@@(#)recvjob.c	8.2 (Berkeley) 4/27/95";
d47 1
a47 1
static char rcsid[] = "$OpenBSD: recvjob.c,v 1.13 2001/02/07 20:40:46 todd Exp $";
d142 2
a143 2
	register int size, nfiles;
	register char *cp;
d231 1
a231 1
	register char *cp;
d233 1
a233 1
	register int i, j, amt;
d312 1
a312 1
	register FILE *fp;
@


1.13
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.11 1997/07/25 20:12:13 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: recvjob.c,v 1.11 1997/07/25 20:12:13 mickey Exp $";
d181 2
a182 4
			strncpy(cp + 6, from, sizeof(line) + line - cp - 7);
			line[sizeof(line) -1 ] = '\0';
			strncpy(tfname, cp, sizeof tfname-1);
			tfname[sizeof tfname-1] = '\0';
d212 1
a212 2
			(void) strncpy(dfname, cp, sizeof dfname-1);
			dfname[sizeof dfname-1] = '\0';
@


1.13.2.1
log
@Errata #17
Patch (millert):
Fix check for '/' in cf file and change the check for '/' in df file
for consistency. Based on a patch from Sebastian Krahmer.
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.13 2001/02/07 20:40:46 todd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: recvjob.c,v 1.13 2001/02/07 20:40:46 todd Exp $";
a182 2
			if (strchr(cp, '/'))
				frecverr("readjob: %s: illegal path name", cp);
d186 3
a209 2
			if (strchr(cp, '/'))
				frecverr("readjob: %s: illegal path name", cp);
d216 3
@


1.12
log
@be more paranoid; based on problem report by mhpower@@MIT.EDU
@
text
@d137 1
a137 1
 * Return the number of jobs successfully transfered.
d328 1
a328 1
 * Remove all the files associated with the current job being transfered.
@


1.11
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.10 1997/07/20 19:04:18 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: recvjob.c,v 1.10 1997/07/20 19:04:18 deraadt Exp $";
d268 2
a269 1
		(void) unlink(file);
d334 1
a334 1
	if (tfname[0])
d336 1
a336 1
	if (dfname[0])
d343 1
@


1.10
log
@careful with link paths; oliver
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.9 1997/07/17 06:52:19 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: recvjob.c,v 1.9 1997/07/17 06:52:19 millert Exp $";
d345 1
a345 1
#if __STDC__
d352 1
a352 1
#if __STDC__
d362 1
a362 1
#if __STDC__
@


1.9
log
@Change a strcpy() -> strncpy() because I'm paranoid.
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.8 1997/07/16 22:31:26 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: recvjob.c,v 1.8 1997/07/16 22:31:26 deraadt Exp $";
d186 3
@


1.8
log
@crank dfname/tfname; freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: recvjob.c,v 1.7 1997/01/17 16:12:42 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: recvjob.c,v 1.7 1997/01/17 16:12:42 millert Exp $";
d181 2
a182 1
			strcpy(cp + 6, from);
@


1.7
log
@Add OpenBSD tags (was in wrong dir for previous commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: $";
d74 1
a74 1
static char	 dfname[40];	/* data files */
d77 1
a77 1
static char	 tfname[40];	/* tmp copy of cf before linking */
@


1.6
log
@inverted logic
@
text
@d1 2
d44 1
d46 3
@


1.5
log
@Improve portability by using ANSI/POSIX interfaces when possible.
@
text
@d154 1
a154 1
		if (cp - line + 1 < sizeof line)
@


1.4
log
@proactive bounds checking; help from millert
@
text
@d206 1
a206 1
			if (index(dfname, '/'))
@


1.3
log
@overflow protection
@
text
@d153 3
a155 1
		} while (*cp++ != '\n');
@


1.2
log
@Integrated 4.4Lite2 source
Fixed potential problem pointed out by bitblt
@
text
@d149 2
a150 1
					frecverr("%s: Lost connection",printer);
d174 2
a175 1
			strcpy(tfname, cp);
d202 2
a203 1
			(void) strcpy(dfname, cp);
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char sccsid[] = "@@(#)recvjob.c	8.1 (Berkeley) 6/6/93";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
