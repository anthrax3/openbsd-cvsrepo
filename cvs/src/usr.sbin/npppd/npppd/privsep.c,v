head	1.23;
access;
symbols
	OPENBSD_6_1:1.22.0.6
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.9.0.8
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.1.0.6
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2017.04.19.05.36.13;	author natano;	state Exp;
branches;
next	1.22;
commitid	0scK6D05EyEW7eqZ;

1.22
date	2016.05.28.07.00.18;	author natano;	state Exp;
branches;
next	1.21;
commitid	V3qpA476A18HvhDy;

1.21
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches;
next	1.20;
commitid	LQHdRRMF0nq0fugE;

1.20
date	2015.12.05.18.43.36;	author mmcc;	state Exp;
branches;
next	1.19;
commitid	z4uV9iYMuGOvIKaj;

1.19
date	2015.12.05.13.19.32;	author claudio;	state Exp;
branches;
next	1.18;
commitid	WQNWqOCspN7oDvQw;

1.18
date	2015.10.11.07.32.06;	author guenther;	state Exp;
branches;
next	1.17;
commitid	l7h58s8VRh2mApBT;

1.17
date	2015.07.20.18.55.35;	author yasuoka;	state Exp;
branches;
next	1.16;
commitid	Bn47ZfI45OrrVkN9;

1.16
date	2015.01.19.01.48.59;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	a1BWBASyBgKKetQd;

1.15
date	2014.08.23.15.29.55;	author doug;	state Exp;
branches;
next	1.14;
commitid	kuz623UzYVNbPDaT;

1.14
date	2014.07.18.13.16.22;	author yasuoka;	state Exp;
branches;
next	1.13;
commitid	sGzVTxw2qlgbC1KH;

1.13
date	2014.07.13.21.34.35;	author yasuoka;	state Exp;
branches;
next	1.12;
commitid	eoeiOpvf0myKWG0h;

1.12
date	2014.07.12.20.07.07;	author yasuoka;	state Exp;
branches;
next	1.11;
commitid	B7I0anPuaVP3kCM6;

1.11
date	2014.07.12.19.34.31;	author yasuoka;	state Exp;
branches;
next	1.10;
commitid	dP0mZl7pqPNqzLDC;

1.10
date	2014.07.12.14.04.18;	author yasuoka;	state Exp;
branches;
next	1.9;
commitid	t0CcAvTHqWCFoExz;

1.9
date	2013.02.08.12.35.52;	author yasuoka;	state Exp;
branches;
next	1.8;

1.8
date	2013.01.31.02.14.46;	author yasuoka;	state Exp;
branches;
next	1.7;

1.7
date	2012.09.28.23.46.00;	author yasuoka;	state Exp;
branches;
next	1.6;

1.6
date	2012.09.18.13.14.08;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2012.05.08.13.15.12;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2012.01.18.03.13.04;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.08.06.14.54;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2011.07.05.01.33.40;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.31.05.49.51;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Switch base tools from /dev/bpf0 to /dev/bpf. Now that /dev/bpf has been
around for two releases, it should be safe to do so.

ok bluhm deraadt sthen tb yasuoka
@
text
@/*	$OpenBSD: privsep.c,v 1.22 2016/05/28 07:00:18 natano Exp $ */

/*
 * Copyright (c) 2010 Yasuoka Masahiko <yasuoka@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/queue.h>
#include <sys/uio.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/pfkeyv2.h>
#include <netinet/in.h>

#include <errno.h>
#include <fcntl.h>
#include <imsg.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "pathnames.h"
#include "privsep.h"

#include "npppd.h"
#include "ppp.h"

#ifndef nitems
#define nitems(_a)	(sizeof((_a)) / sizeof((_a)[0]))
#endif

enum imsg_code {
	PRIVSEP_OK,
	PRIVSEP_OPEN,
	PRIVSEP_SOCKET,
	PRIVSEP_BIND,
	PRIVSEP_SENDTO,
	PRIVSEP_UNLINK,
	PRIVSEP_GET_USER_INFO,
	PRIVSEP_GET_IF_ADDR,
	PRIVSEP_SET_IF_ADDR,
	PRIVSEP_DEL_IF_ADDR,
	PRIVSEP_GET_IF_FLAGS,
	PRIVSEP_SET_IF_FLAGS
};

struct PRIVSEP_OPEN_ARG {
	char			 path[PATH_MAX];
	int			 flags;
};

struct PRIVSEP_SOCKET_ARG {
	int			 domain;
	int			 type;
	int			 protocol;
};

struct PRIVSEP_BIND_ARG {
	struct sockaddr_storage	 name;
	socklen_t		 namelen;
};

struct PRIVSEP_SENDTO_ARG {
	size_t			 len;
	int			 flags;
	struct sockaddr_storage	 to;
	socklen_t		 tolen;
	u_char			 msg[0];
};

struct PRIVSEP_UNLINK_ARG {
	char			 path[PATH_MAX];
};

struct PRIVSEP_GET_USER_INFO_ARG {
	char			 path[PATH_MAX];
	char			 username[MAX_USERNAME_LENGTH];
};

struct PRIVSEP_GET_IF_ADDR_ARG {
	char			 ifname[IFNAMSIZ];
};

struct PRIVSEP_GET_IF_ADDR_RESP {
	int			 retval;
	int			 rerrno;
	struct in_addr		 addr;
};

struct PRIVSEP_SET_IF_ADDR_ARG {
	char			 ifname[IFNAMSIZ];
	struct in_addr		 addr;
};

struct PRIVSEP_DEL_IF_ADDR_ARG {
	char			 ifname[IFNAMSIZ];
};

struct PRIVSEP_GET_IF_FLAGS_ARG {
	char			 ifname[IFNAMSIZ];
	int			 flags;
};

struct PRIVSEP_GET_IF_FLAGS_RESP {
	int			 retval;
	int			 rerrno;
	int			 flags;
};

struct PRIVSEP_SET_IF_FLAGS_ARG {
	char			 ifname[IFNAMSIZ];
	int			 flags;
};

struct PRIVSEP_COMMON_RESP {
	int			 retval;
	int			 rerrno;
};

struct PRIVSEP_GET_USER_INFO_RESP {
	int			 retval;
	int			 rerrno;
	char			 password[MAX_PASSWORD_LENGTH];
	struct in_addr		 framed_ip_address;
	struct in_addr		 framed_ip_netmask;
	char			 calling_number[NPPPD_PHONE_NUMBER_LEN + 1];
};

static void	 privsep_priv_main (int);
static void	 privsep_priv_dispatch_imsg (struct imsgbuf *);
int		 imsg_read_and_get(struct imsgbuf *, struct imsg *);
static int	 startswith(const char *, const char *);
static int	 privsep_recvfd (void);
static int	 privsep_common_resp (void);

static int	 privsep_npppd_check_open (struct PRIVSEP_OPEN_ARG *);
static int	 privsep_npppd_check_socket (struct PRIVSEP_SOCKET_ARG *);
static int	 privsep_npppd_check_bind (struct PRIVSEP_BIND_ARG *);
static int	 privsep_npppd_check_sendto (struct PRIVSEP_SENDTO_ARG *);
static int	 privsep_npppd_check_unlink (struct PRIVSEP_UNLINK_ARG *);
static int	 privsep_npppd_check_get_user_info (
		    struct PRIVSEP_GET_USER_INFO_ARG *);
static int	 privsep_npppd_check_get_if_addr (
		    struct PRIVSEP_GET_IF_ADDR_ARG *);
static int	 privsep_npppd_check_set_if_addr (
		    struct PRIVSEP_SET_IF_ADDR_ARG *);
static int	 privsep_npppd_check_del_if_addr (
		    struct PRIVSEP_DEL_IF_ADDR_ARG *);
static int	 privsep_npppd_check_get_if_flags (
		    struct PRIVSEP_GET_IF_FLAGS_ARG *);
static int	 privsep_npppd_check_set_if_flags (
		    struct PRIVSEP_SET_IF_FLAGS_ARG *);

static int		 privsep_sock = -1;
static struct imsgbuf	 privsep_ibuf;
static pid_t		 privsep_pid;

int
privsep_init(void)
{
	pid_t	 pid;
	int	 pairsock[2];

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pairsock) == -1)
		return (-1);

	if ((pid = fork()) < 0)
		goto fail;
	else if (pid == 0) {
		setsid();
		/* privileged process */
		setproctitle("[priv]");
		close(pairsock[1]);
		privsep_priv_main(pairsock[0]);
		_exit(0);
		/* NOTREACHED */
	}
	close(pairsock[0]);
	privsep_sock = pairsock[1];
	privsep_pid = pid;
	imsg_init(&privsep_ibuf, privsep_sock);

	return (0);
	/* NOTREACHED */
fail:
	if (pairsock[0] >= 0) {
		close(pairsock[0]);
		close(pairsock[1]);
	}

	return (-1);
}

void
privsep_fini(void)
{
	imsg_clear(&privsep_ibuf);
	if (privsep_sock >= 0) {
		close(privsep_sock);
		privsep_sock = -1;
	}
}

pid_t
privsep_priv_pid(void)
{
	return (privsep_pid);
}

/***********************************************************************
 * Functions for from jail
 ***********************************************************************/
int
priv_bind(int sock, const struct sockaddr *name, socklen_t namelen)
{
	struct PRIVSEP_BIND_ARG	 a;

	if (namelen > sizeof(a.name)) {
		errno = EINVAL;
		return (-1);
	}
	if ((sock = dup(sock)) == -1)
		return (-1);

	memcpy(&a.name, name, namelen);
	a.namelen = namelen;

	(void)imsg_compose(&privsep_ibuf, PRIVSEP_BIND, 0, 0, sock,
	    &a, sizeof(a));
	imsg_flush(&privsep_ibuf);

	return (privsep_common_resp());
}

int
priv_socket(int domain, int type, int protocol)
{
	struct PRIVSEP_SOCKET_ARG a;

	a.domain = domain;
	a.type = type;
	a.protocol = protocol;
	(void)imsg_compose(&privsep_ibuf, PRIVSEP_SOCKET, 0, 0, -1,
	    &a, sizeof(a));
	imsg_flush(&privsep_ibuf);

	return (privsep_recvfd());
}

int
priv_open(const char *path, int flags)
{
	struct PRIVSEP_OPEN_ARG a;

	strlcpy(a.path, path, sizeof(a.path));
	a.flags = flags;
	(void)imsg_compose(&privsep_ibuf, PRIVSEP_OPEN, 0, 0, -1,
	    &a, sizeof(a));
	imsg_flush(&privsep_ibuf);

	return (privsep_recvfd());
}

FILE *
priv_fopen(const char *path)
{
	int f;
	FILE *fp;

	if ((f = priv_open(path, O_RDONLY)) < 0)
		return (NULL);

	if ((fp = fdopen(f, "r")) == NULL) {
		close(f);
		return (NULL);
	} else
		return (fp);
}

int
priv_sendto(int s, const void *msg, int len, int flags,
    const struct sockaddr *to, socklen_t tolen)
{
	struct PRIVSEP_SENDTO_ARG	 a;
	struct iovec			 iov[2];

	if (tolen > sizeof(a.to)) {
		errno = EINVAL;
		return (-1);
	}
	if ((s = dup(s)) == -1)
		return (-1);

	a.len = len;
	a.flags = flags;
	a.tolen = tolen;
	if (tolen > 0)
		memcpy(&a.to, to, tolen);
	iov[0].iov_base = &a;
	iov[0].iov_len = offsetof(struct PRIVSEP_SENDTO_ARG, msg);
	iov[1].iov_base = (void *)msg;
	iov[1].iov_len = len;

	(void)imsg_composev(&privsep_ibuf, PRIVSEP_SENDTO, 0, 0, s,
	    iov, nitems(iov));
	imsg_flush(&privsep_ibuf);

	return (privsep_common_resp());
}

int
priv_send(int s, const void *msg, int len, int flags)
{
	return (priv_sendto(s, msg, len, flags, NULL, 0));
}

int
priv_unlink(const char *path)
{
	struct PRIVSEP_UNLINK_ARG a;

	strlcpy(a.path, path, sizeof(a.path));
	(void)imsg_compose(&privsep_ibuf, PRIVSEP_UNLINK, 0, 0, -1,
	    &a, sizeof(a));
	imsg_flush(&privsep_ibuf);

	return (privsep_common_resp());
}

int
priv_get_user_info(const char *path, const char *username,
    npppd_auth_user **puser)
{
	struct imsg				 imsg;
	ssize_t					 n;
	struct PRIVSEP_GET_USER_INFO_RESP	*r;
	struct PRIVSEP_GET_USER_INFO_ARG	 a;
	npppd_auth_user				*u;
	char					*cp;
	int					 sz;

	strlcpy(a.path, path, sizeof(a.path));
	strlcpy(a.username, username, sizeof(a.username));

	(void)imsg_compose(&privsep_ibuf, PRIVSEP_GET_USER_INFO, 0, 0, -1,
	    &a, sizeof(a));
	imsg_flush(&privsep_ibuf);

	if ((n = imsg_read_and_get(&privsep_ibuf, &imsg)) == -1)
		return (-1);
	if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*r)) {
		errno = EACCES;
		goto on_error;
	}
	r = imsg.data;
	if (r->retval != 0) {
		errno = r->rerrno;
		goto on_error;
	}

	sz = strlen(username) + strlen(r->password) +
	    strlen(r->calling_number) + 3;

	if ((u = malloc(offsetof(npppd_auth_user, space[sz]))) == NULL)
		goto on_error;

	cp = u->space;

	u->username = cp;
	n = strlcpy(cp, username, sz);
	cp += ++n; sz -= n;

	u->password = cp;
	n = strlcpy(cp, r->password, sz);
	cp += ++n; sz -= n;

	u->calling_number = cp;
	n = strlcpy(cp, r->calling_number, sz);
	cp += ++n; sz -= n;

	u->framed_ip_address = r->framed_ip_address;
	u->framed_ip_netmask = r->framed_ip_netmask;

	*puser = u;
	imsg_free(&imsg);

	return (0);

on_error:
	imsg_free(&imsg);
	return (-1);
}

int
priv_get_if_addr(const char *ifname, struct in_addr *addr)
{
	struct PRIVSEP_GET_IF_ADDR_ARG   a;
	struct PRIVSEP_GET_IF_ADDR_RESP *r;
	struct imsg			 imsg;
	int				 retval = -1;

	strlcpy(a.ifname, ifname, sizeof(a.ifname));

	(void)imsg_compose(&privsep_ibuf, PRIVSEP_GET_IF_ADDR, 0, 0, -1,
	    &a, sizeof(a));
	imsg_flush(&privsep_ibuf);

	if (imsg_read_and_get(&privsep_ibuf, &imsg) == -1)
		return (-1);

	if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*r))
		errno = EACCES;
	else {
		r = imsg.data;
		if (r->retval != -1)
			*addr = r->addr;
		else
			errno = r->rerrno;
		retval = r->retval;
	}
	imsg_free(&imsg);

	return (retval);
}

int
priv_delete_if_addr(const char *ifname)
{
	struct PRIVSEP_DEL_IF_ADDR_ARG   a;

	strlcpy(a.ifname, ifname, sizeof(a.ifname));
	(void)imsg_compose(&privsep_ibuf, PRIVSEP_DEL_IF_ADDR, 0, 0, -1,
	    &a, sizeof(a));
	imsg_flush(&privsep_ibuf);

	return (privsep_common_resp());
}

int
priv_set_if_addr(const char *ifname, struct in_addr *addr)
{
	struct PRIVSEP_SET_IF_ADDR_ARG   a;

	strlcpy(a.ifname, ifname, sizeof(a.ifname));
	a.addr = *addr;
	(void)imsg_compose(&privsep_ibuf, PRIVSEP_SET_IF_ADDR, 0, 0, -1,
	    &a, sizeof(a));
	imsg_flush(&privsep_ibuf);

	return (privsep_common_resp());
}

int
priv_get_if_flags(const char *ifname, int *pflags)
{
	struct PRIVSEP_GET_IF_FLAGS_ARG		 a;
	struct PRIVSEP_GET_IF_FLAGS_RESP	*r;
	struct imsg				 imsg;
	int					 retval = -1;

	strlcpy(a.ifname, ifname, sizeof(a.ifname));
	a.flags = 0;

	(void)imsg_compose(&privsep_ibuf, PRIVSEP_GET_IF_FLAGS, 0, 0, -1,
	    &a, sizeof(a));
	imsg_flush(&privsep_ibuf);

	if (imsg_read_and_get(&privsep_ibuf, &imsg) == -1)
		return (-1);
	if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*r))
		errno = EACCES;
	else {
		r = imsg.data;
		*pflags = r->flags;
		if (r->retval != 0)
			errno = r->rerrno;
		retval = r->retval;
	}
	imsg_free(&imsg);

	return (retval);
}

int
priv_set_if_flags(const char *ifname, int flags)
{
	struct PRIVSEP_SET_IF_FLAGS_ARG   a;

	strlcpy(a.ifname, ifname, sizeof(a.ifname));
	a.flags = flags;

	(void)imsg_compose(&privsep_ibuf, PRIVSEP_SET_IF_FLAGS, 0, 0, -1,
	    &a, sizeof(a));
	imsg_flush(&privsep_ibuf);

	return (privsep_common_resp());
}

static int
privsep_recvfd(void)
{
	struct PRIVSEP_COMMON_RESP	*r;
	struct imsg			 imsg;
	int				 retval = -1;

	if (imsg_read_and_get(&privsep_ibuf, &imsg) == -1)
		return (-1);
	if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*r))
		errno = EACCES;
	else {
		r = imsg.data;
		retval = r->retval;
		if (r->retval != 0)
			errno = r->rerrno;
		else
			retval = imsg.fd;
	}
	imsg_free(&imsg);

	return (retval);
}

static int
privsep_common_resp(void)
{
	struct PRIVSEP_COMMON_RESP	*r;
	struct imsg			 imsg;
	int				 retval = -1;

	if (imsg_read_and_get(&privsep_ibuf, &imsg) == -1) {
		errno = EACCES;
		return (-1);
	}
	if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*r))
		errno = EACCES;
	else {
		r = imsg.data;
		if (r->retval != 0)
			errno = r->rerrno;
		retval = r->retval;
	}
	imsg_free(&imsg);

	return (retval);
}

/***********************************************************************
 * privileged process
 ***********************************************************************/
static void
privsep_priv_main(int sock)
{
	struct imsgbuf	 ibuf;

	imsg_init(&ibuf, sock);
	privsep_priv_dispatch_imsg(&ibuf);
	imsg_clear(&ibuf);
	close(sock);

	exit(EXIT_SUCCESS);
}

static void
privsep_priv_dispatch_imsg(struct imsgbuf *ibuf)
{
	struct imsg	 imsg;

	for (;;) {
		if (imsg_read_and_get(ibuf, &imsg) == -1)
			return;

		switch (imsg.hdr.type) {
		case PRIVSEP_OPEN: {
			int				 f = -1;
			struct PRIVSEP_OPEN_ARG		*a = imsg.data;
			struct PRIVSEP_COMMON_RESP	 r = { -1, 0 };

			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*a))
				r.rerrno = EINVAL;
			else if (privsep_npppd_check_open(a))
				r.rerrno = EACCES;
			else {
				if ((f = open(a->path, a->flags & ~O_CREAT))
				    == -1)
					r.rerrno = errno;
				else
					r.retval = 0;
			}
			(void)imsg_compose(ibuf, PRIVSEP_OK, 0, 0, f,
			    &r, sizeof(r));
			imsg_flush(ibuf);
		    }
			break;
		case PRIVSEP_SOCKET: {
			int				 s = -1;
			struct PRIVSEP_SOCKET_ARG	*a = imsg.data;
			struct PRIVSEP_COMMON_RESP	 r = { -1, 0 };

			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*a))
				r.rerrno = EINVAL;
			else if (privsep_npppd_check_socket(a))
				r.rerrno = EACCES;
			else {
				if ((s = socket(a->domain, a->type,
				    a->protocol)) == -1)
					r.rerrno = errno;
				else
					r.retval = 0;
			}
			(void)imsg_compose(ibuf, PRIVSEP_OK, 0, 0, s,
			    &r, sizeof(r));
			imsg_flush(ibuf);
		    }
			break;
		case PRIVSEP_UNLINK: {
			struct PRIVSEP_UNLINK_ARG *a = imsg.data;
			struct PRIVSEP_COMMON_RESP r = { -1, 0 };

			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*a))
				r.rerrno = EINVAL;
			else if (privsep_npppd_check_unlink(a))
				r.rerrno = EACCES;
			else {
				if ((r.retval = unlink(a->path)) != 0)
					r.rerrno = errno;
			}

			(void)imsg_compose(ibuf, PRIVSEP_OK, 0, 0, -1,
			    &r, sizeof(r));
			imsg_flush(ibuf);
		    }
			break;
		case PRIVSEP_BIND: {
			struct PRIVSEP_BIND_ARG	*a = imsg.data;
			struct PRIVSEP_COMMON_RESP r = { -1, 0 };

			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*a) ||
			    imsg.fd < 0)
				r.rerrno = EINVAL;
			else if (privsep_npppd_check_bind(a))
				r.rerrno = EACCES;
			else {
				if ((r.retval = bind(imsg.fd,
				    (struct sockaddr *)&a->name, a->namelen))
				    != 0)
					r.rerrno = errno;
				close(imsg.fd);
			}
			(void)imsg_compose(ibuf, PRIVSEP_OK, 0, 0, -1,
			    &r, sizeof(r));
			imsg_flush(ibuf);
		    }
			break;
		case PRIVSEP_GET_USER_INFO: {
			struct PRIVSEP_GET_USER_INFO_ARG *a = imsg.data;
			struct PRIVSEP_GET_USER_INFO_RESP r;
			int   retval;
			char *str, *buf, *db[2] = { NULL, NULL };

			memset(&r, 0, sizeof(r));
			r.retval = -1;
			r.framed_ip_address.s_addr = INADDR_NAS_SELECT;
			r.framed_ip_netmask.s_addr = INADDR_NONE;
			str = buf = NULL;

			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*a)) {
				r.rerrno = EINVAL;
				(void)imsg_compose(ibuf, PRIVSEP_OK, 0, 0, -1,
				    &r, sizeof(r));
				return;
			}
			db[0] = a->path;
			if (privsep_npppd_check_get_user_info(a))
				r.rerrno = EACCES;
			else if ((retval = cgetent(&buf, db, a->username))
			    == 0) {
				if ((retval = cgetstr(buf, "password", &str))
				    >= 0) {
					if (strlcpy(r.password, str,
					    sizeof(r.password)) >=
					    sizeof(r.password))
						goto on_broken_entry;
					free(str);
					str = NULL;
				}
				if ((retval = cgetstr(buf, "calling-number",
				    &str)) >= 0) {
					if (strlcpy(r.calling_number, str,
					    sizeof(r.calling_number)) >=
					    sizeof(r.calling_number))
						goto on_broken_entry;
					free(str);
					str = NULL;
				}
				if ((retval = cgetstr(buf, "framed-ip-address",
				    &str)) >= 0) {
					if (inet_aton(str,
					    &r.framed_ip_address) != 1)
						goto on_broken_entry;
					free(str);
					str = NULL;
				}

				if ((retval = cgetstr(buf, "framed-ip-netmask",
				    &str)) >= 0) {
					if (inet_aton(str,
					    &r.framed_ip_netmask) != 1)
						goto on_broken_entry;
					free(str);
					str = NULL;
				}
				cgetclose();
				free(buf);
				r.retval = 0;
			} else if (retval == -1) {
				buf = NULL;
on_broken_entry:
				free(buf);
				free(str);
				r.retval = -1;
				r.rerrno = ENOENT;
			} else {
				r.retval = retval;
				r.rerrno = errno;
			}
			(void)imsg_compose(ibuf, PRIVSEP_OK, 0, 0, -1,
			    &r, sizeof(r));
			imsg_flush(ibuf);
		    }
			break;
		case PRIVSEP_SENDTO: {
			struct PRIVSEP_SENDTO_ARG *a = imsg.data;
			struct PRIVSEP_COMMON_RESP r = { -1, 0 };

			if (imsg.hdr.len < IMSG_HEADER_SIZE + sizeof(*a) ||
			    imsg.hdr.len < IMSG_HEADER_SIZE +
				offsetof(struct PRIVSEP_SENDTO_ARG,
					msg[a->len]))
				r.rerrno = EMSGSIZE;
			else if (imsg.fd < 0)
				r.rerrno = EINVAL;
			else if (privsep_npppd_check_sendto(a))
				r.rerrno = EACCES;
			else {
				if (a->tolen > 0)
					r.retval = sendto(imsg.fd, a->msg,
					    a->len, a->flags,
					    (struct sockaddr *)&a->to,
					    a->tolen);
				else
					r.retval = send(imsg.fd, a->msg, a->len,
					    a->flags);
				if (r.retval < 0)
					r.rerrno = errno;
				close(imsg.fd);
			}
			(void)imsg_compose(ibuf, PRIVSEP_OK, 0, 0, -1,
			    &r, sizeof(r));
			imsg_flush(ibuf);
		    }
			break;
		case PRIVSEP_GET_IF_ADDR: {
			int                              s;
			struct ifreq                     ifr;
			struct PRIVSEP_GET_IF_ADDR_ARG  *a = imsg.data;
			struct PRIVSEP_GET_IF_ADDR_RESP  r;

			memset(&r, 0, sizeof(r));
			r.retval = -1;
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*a))
				r.rerrno = EINVAL;
			else if (privsep_npppd_check_get_if_addr(a))
				r.rerrno = EACCES;
			else {
				memset(&ifr, 0, sizeof(ifr));
				strlcpy(ifr.ifr_name, a->ifname,
				    sizeof(ifr.ifr_name));
				if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ||
				    ioctl(s, SIOCGIFADDR, &ifr) != 0) {
					r.retval = -1;
					r.rerrno = errno;
				} else {
					r.retval = 0;
					r.addr = ((struct sockaddr_in *)
					    &ifr.ifr_addr)->sin_addr;
				}
				if (s >= 0)
					close(s);
			}
			(void)imsg_compose(ibuf, PRIVSEP_OK, 0, 0, -1,
			    &r, sizeof(r));
			imsg_flush(ibuf);
		    }
			break;
		case PRIVSEP_SET_IF_ADDR: {
			int                              s;
			struct ifaliasreq                ifra;
			struct PRIVSEP_SET_IF_ADDR_ARG  *a = imsg.data;
			struct PRIVSEP_COMMON_RESP       r = { -1, 0 };
			struct sockaddr_in              *sin4;

			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*a))
				r.rerrno = EINVAL;
			else if (privsep_npppd_check_set_if_addr(a))
				r.rerrno = EACCES;
			else {
				memset(&ifra, 0, sizeof(ifra));
				strlcpy(ifra.ifra_name, a->ifname,
				    sizeof(ifra.ifra_name));

				sin4 = (struct sockaddr_in *)&ifra.ifra_addr;
				sin4->sin_family = AF_INET;
				sin4->sin_len = sizeof(struct sockaddr_in);
				sin4->sin_addr = a->addr;

				sin4 = (struct sockaddr_in *)&ifra.ifra_mask;
				sin4->sin_family = AF_INET;
				sin4->sin_len = sizeof(struct sockaddr_in);
				sin4->sin_addr.s_addr = 0xffffffffUL;

				sin4 =
				    (struct sockaddr_in *)&ifra.ifra_broadaddr;
				sin4->sin_family = AF_INET;
				sin4->sin_len = sizeof(struct sockaddr_in);
				sin4->sin_addr.s_addr = 0;

				if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ||
				    ioctl(s, SIOCAIFADDR, &ifra) != 0) {
					r.retval = -1;
					r.rerrno = errno;
				} else
					r.retval = 0;
				if (s >= 0)
					close(s);
			}
			(void)imsg_compose(ibuf, PRIVSEP_OK, 0, 0, -1,
			    &r, sizeof(r));
			imsg_flush(ibuf);
		    }
			break;
		case PRIVSEP_DEL_IF_ADDR: {
			int                              s;
			struct ifreq                     ifr;
			struct PRIVSEP_DEL_IF_ADDR_ARG  *a = imsg.data;
			struct PRIVSEP_COMMON_RESP       r = { 0, -1 };

			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*a))
				r.rerrno = EINVAL;
			else if (privsep_npppd_check_del_if_addr(a))
				r.rerrno = EACCES;
			else {
				memset(&ifr, 0, sizeof(ifr));
				strlcpy(ifr.ifr_name, a->ifname,
				    sizeof(ifr.ifr_name));
				if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ||
				    ioctl(s, SIOCDIFADDR, &ifr) != 0) {
					r.retval = -1;
					r.rerrno = errno;
				} else
					r.retval = 0;
				if (s >= 0)
					close(s);
			}
			(void)imsg_compose(ibuf, PRIVSEP_OK, 0, 0, -1,
			    &r, sizeof(r));
			imsg_flush(ibuf);
		    }
			break;
		case PRIVSEP_GET_IF_FLAGS: {
			int                               s;
			struct ifreq                      ifr;
			struct PRIVSEP_GET_IF_FLAGS_ARG  *a = imsg.data;
			struct PRIVSEP_GET_IF_FLAGS_RESP  r;

			memset(&r, 0, sizeof(r));
			r.retval = -1;

			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*a))
				r.rerrno = EINVAL;
			else if (privsep_npppd_check_get_if_flags(a)) {
				r.rerrno = EACCES;
			} else {
				memset(&ifr, 0, sizeof(ifr));
				strlcpy(ifr.ifr_name, a->ifname,
				    sizeof(ifr.ifr_name));
				if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ||
				    ioctl(s, SIOCGIFFLAGS, &ifr) != 0) {
					r.retval = -1;
					r.rerrno = errno;
				} else {
					r.retval = 0;
					r.flags = ifr.ifr_flags;
				}
				if (s >= 0)
					close(s);
			}
			(void)imsg_compose(ibuf, PRIVSEP_OK, 0, 0, -1,
			    &r, sizeof(r));
			imsg_flush(ibuf);
		    }
			break;
		case PRIVSEP_SET_IF_FLAGS: {
			int                               s;
			struct ifreq                      ifr;
			struct PRIVSEP_SET_IF_FLAGS_ARG  *a = imsg.data;
			struct PRIVSEP_COMMON_RESP        r = { -1, 0 };

			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*a))
				r.rerrno = EINVAL;
			else if (privsep_npppd_check_set_if_flags(a))
				r.rerrno = EACCES;
			else {
				memset(&ifr, 0, sizeof(ifr));
				strlcpy(ifr.ifr_name, a->ifname,
				    sizeof(ifr.ifr_name));
				ifr.ifr_flags = a->flags;
				if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ||
				    ioctl(s, SIOCGIFFLAGS, &ifr) != 0) {
					r.retval = -1;
					r.rerrno = errno;
				} else
					r.retval = 0;
				if (s >= 0)
					close(s);
			}
			(void)imsg_compose(ibuf, PRIVSEP_OK, 0, 0, -1,
			    &r, sizeof(r));
			imsg_flush(ibuf);
		    }
			break;
		}
		imsg_free(&imsg);
	}
}

int
imsg_read_and_get(struct imsgbuf *ibuf, struct imsg *imsg)
{
	ssize_t	 n;

	for (;;) {
		if ((n = imsg_read(ibuf)) <= 0) {
			if (n == -1 && (errno == EAGAIN || errno == EINTR))
				continue;
			return (-1);
		}
		if ((n = imsg_get(ibuf, imsg)) < 0)
			return (-1);
		if (n == 0)
			continue;
		break;
	}

	return (0);
}

static int
startswith(const char *str, const char *prefix)
{
	return (strncmp(str, prefix, strlen(prefix)) == 0)? 1 : 0;
}

static int
privsep_npppd_check_open(struct PRIVSEP_OPEN_ARG *arg)
{
	int i;
	struct _allow_paths {
		const char *path;
		int path_is_prefix;
		int readonly;
	} const allow_paths[] = {
		{ NPPPD_DIR "/",	1,	1 },
		{ "/dev/bpf",		0,	0 },
		{ "/etc/resolv.conf",	0,	1 },
		{ "/dev/tun",		1,	0 },
		{ "/dev/pppx",		1,	0 }
	};

	/* O_NONBLOCK is the only 'extra' flag permitted */
	if (arg->flags & ~(O_ACCMODE | O_NONBLOCK))
		return (1);
	for (i = 0; i < (int)nitems(allow_paths); i++) {
		if (allow_paths[i].path_is_prefix) {
			if (!startswith(arg->path, allow_paths[i].path))
				continue;
		} else if (strcmp(arg->path, allow_paths[i].path) != 0)
			continue;
		if (allow_paths[i].readonly) {
			if ((arg->flags & O_ACCMODE) != O_RDONLY)
				continue;
		}
		return (0);
	}
	return (1);
}

static int
privsep_npppd_check_socket(struct PRIVSEP_SOCKET_ARG *arg)
{
	/* npppd uses routing socket */
	if (arg->domain == PF_ROUTE && arg->type == SOCK_RAW &&
	    arg->protocol  == AF_UNSPEC)
		return (0);

	/* npppd uses raw ip socket for GRE */
	if (arg->domain == AF_INET && arg->type == SOCK_RAW &&
	    arg->protocol == IPPROTO_GRE)
		return (0);

	/* L2TP uses PF_KEY socket to delete IPsec-SA */
	if (arg->domain == PF_KEY && arg->type == SOCK_RAW &&
	    arg->protocol == PF_KEY_V2)
		return (0);

	return (1);
}

static int
privsep_npppd_check_bind(struct PRIVSEP_BIND_ARG *arg)
{
	return (1);
}

static int
privsep_npppd_check_sendto(struct PRIVSEP_SENDTO_ARG *arg)
{
	/* for reply npppdctl's request */
	if (arg->flags == 0 && arg->tolen > 0 &&
	    arg->to.ss_family == AF_UNIX)
		return (0);

	/* for sending a routing socket message. */
	if (arg->flags == 0 && arg->tolen == 0)
		return (0);

	return (1);
}

static int
privsep_npppd_check_unlink(struct PRIVSEP_UNLINK_ARG *arg)
{

	return (1);
}

static int
privsep_npppd_check_get_user_info(struct PRIVSEP_GET_USER_INFO_ARG *arg)
{
	int l;

	l = strlen(NPPPD_DIR "/");
	if (strncmp(arg->path, NPPPD_DIR "/", l) == 0)
		return (0);

	return (1);
}

static int
privsep_npppd_check_get_if_addr(struct PRIVSEP_GET_IF_ADDR_ARG *arg)
{
	if (startswith(arg->ifname, "tun") || startswith(arg->ifname, "pppx"))
		return (0);

	return (1);
}

static int
privsep_npppd_check_set_if_addr(struct PRIVSEP_SET_IF_ADDR_ARG *arg)
{
	if (startswith(arg->ifname, "tun") || startswith(arg->ifname, "pppx"))
		return (0);

	return (1);
}

static int
privsep_npppd_check_del_if_addr(struct PRIVSEP_DEL_IF_ADDR_ARG *arg)
{
	if (startswith(arg->ifname, "tun") || startswith(arg->ifname, "pppx"))
		return (0);

	return (1);
}

static int
privsep_npppd_check_get_if_flags(struct PRIVSEP_GET_IF_FLAGS_ARG *arg)
{
	if (startswith(arg->ifname, "tun") || startswith(arg->ifname, "pppx"))
		return (0);

	return (1);
}

static int
privsep_npppd_check_set_if_flags(struct PRIVSEP_SET_IF_FLAGS_ARG *arg)
{
	if (startswith(arg->ifname, "tun") || startswith(arg->ifname, "pppx"))
		return (0);

	return (1);
}
@


1.22
log
@Replace the /dev/bpf* open loop with a plain open("/dev/bpf0", ...).
ok deraadt jca
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.21 2016/02/02 17:51:11 sthen Exp $ */
d986 1
a986 1
		{ "/dev/bpf0",		0,	0 },
@


1.21
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.20 2015/12/05 18:43:36 mmcc Exp $ */
d986 1
a986 1
		{ "/dev/bpf",		1,	0 },
@


1.20
log
@strings.h -> string.h to prevent an implicit declaration. Also remove a
bunch of NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.19 2015/12/05 13:19:32 claudio Exp $ */
a190 1
	setproctitle("main");
@


1.19
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.18 2015/10/11 07:32:06 guenther Exp $ */
d732 2
a733 4
				if (buf != NULL)
					free(buf);
				if (str != NULL)
					free(str);
@


1.18
log
@Simplify and lock down priv_open():
 * kill the 'mode' argument
 * fail if passed any flags other than O_ACCMODE OR O_NONBLOCK
 * paranoia: mask O_CREAT when calling open() with only two arguments
 * instead of using ioctl(FIONBIO) after the fact, pass O_NONBLOCK to
   priv_open()

"good start" deraadt@@
ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.17 2015/07/20 18:55:35 yasuoka Exp $ */
d959 1
a959 1
			if (n == 0 && (errno == EAGAIN || errno == EINTR))
@


1.17
log
@Add missing initializations in privsep.c

From Yuuichi Someya at IIJ.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.16 2015/01/19 01:48:59 deraadt Exp $ */
a62 1
	mode_t			 mode;
d265 1
a265 1
priv_open(const char *path, int flags, mode_t mode)
a270 1
	a.mode = mode;
d284 1
a284 1
	if ((f = priv_open(path, O_RDONLY, 0600)) < 0)
d597 1
a597 1
				if ((f = open(a->path, a->flags, a->mode))
d995 3
@


1.16
log
@move to <limits.h> universe
ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.15 2014/08/23 15:29:55 doug Exp $ */
d338 1
d478 1
d786 2
d800 2
a801 1
				} else
d804 1
@


1.15
log
@close fd when fdopen fails

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.14 2014/07/18 13:16:22 yasuoka Exp $ */
a17 1
#include <sys/param.h>
@


1.14
log
@Fix privsep.c.  Call missing imsg_free() after imsg_get().  Also add
missing #include <net/if.h> to use IFNAMESIZ and replace some strncmp()
by startswith().
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.13 2014/07/13 21:34:35 yasuoka Exp $ */
d285 1
d290 5
a294 1
	return fdopen(f, "r");
@


1.13
log
@Some functions need to dup() before sending a socket by imsg and don't
need to close() after sending socket since imsg_compose() closes the
passing socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.12 2014/07/12 20:07:07 yasuoka Exp $ */
d24 1
d360 1
a360 2
	if ((n = imsg_read_and_get(&privsep_ibuf, &imsg)) == -1) {
		errno = EACCES;
a361 1
	}
d364 1
a364 1
		return (-1);
d369 1
a369 1
		return (r->retval);
d376 1
a376 1
		return (-1);
d396 1
d399 4
d411 1
d419 1
a419 2
	if (imsg_read_and_get(&privsep_ibuf, &imsg) == -1) {
		errno = EACCES;
d421 2
a422 2
	}
	if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*r)) {
d424 7
a430 1
		return (-1);
d432 1
a432 5
	r = imsg.data;
	if (r->retval != -1)
		*addr = r->addr;
	else
		errno = r->rerrno;
d434 1
a434 1
	return (r->retval);
d470 1
d478 1
a478 2
	if (imsg_read_and_get(&privsep_ibuf, &imsg) == -1) {
		errno = EACCES;
d480 1
a480 2
	}
	if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*r)) {
d482 6
a487 1
		return (-1);
d489 1
a489 4
	r = imsg.data;
	*pflags = r->flags;
	if (r->retval != 0)
		errno = r->rerrno;
d491 1
a491 1
	return (r->retval);
d514 1
d516 1
a516 2
	if (imsg_read_and_get(&privsep_ibuf, &imsg) == -1) {
		errno = EACCES;
d518 1
a518 2
	}
	if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*r)) {
d520 7
a526 1
		return (-1);
d528 1
a528 3
	r = imsg.data;
	if (r->retval != 0)
		errno = r->rerrno;
d530 1
a530 1
	return (imsg.fd);
d538 1
d544 1
a544 1
	if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(*r)) {
d546 5
a550 1
		return (-1);
d552 1
a552 3
	r = imsg.data;
	if (r->retval != 0)
		errno = r->rerrno;
d554 1
a554 1
	return (r->retval);
d940 1
d1066 1
a1066 2
	if (strncmp(arg->ifname, "tun", 3) == 0 ||
	    strncmp(arg->ifname, "pppx", 4) == 0)
d1075 1
a1075 2
	if (strncmp(arg->ifname, "tun", 3) == 0 ||
	    strncmp(arg->ifname, "pppx", 4) == 0)
d1084 1
a1084 2
	if (strncmp(arg->ifname, "tun", 3) == 0 ||
	    strncmp(arg->ifname, "pppx", 4) == 0)
d1093 1
a1093 2
	if (strncmp(arg->ifname, "tun", 3) == 0 ||
	    strncmp(arg->ifname, "pppx", 4) == 0)
d1102 1
a1102 2
	if (strncmp(arg->ifname, "tun", 3) == 0 ||
	    strncmp(arg->ifname, "pppx", 4) == 0)
@


1.12
log
@Fix a potential bug.  privsep.c didn't check the interface name
correctly if it's pppx.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.11 2014/07/12 19:34:31 yasuoka Exp $ */
d237 3
d302 2
a588 1
			close(f);
a609 1
			close(s);
@


1.11
log
@Fix error in previous.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.10 2014/07/12 14:04:18 yasuoka Exp $ */
d1050 1
a1050 1
	    strncmp(arg->ifname, "pppx", 4))
d1060 1
a1060 1
	    strncmp(arg->ifname, "pppx", 4))
d1070 1
a1070 1
	    strncmp(arg->ifname, "pppx", 4))
d1080 1
a1080 1
	    strncmp(arg->ifname, "pppx", 4))
d1090 1
a1090 1
	    strncmp(arg->ifname, "pppx", 4))
@


1.10
log
@Use imsg(3) for the IPC between the privileged process and the
non-privileged process to be unify the way.  Also fix style.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.9 2013/02/08 12:35:52 yasuoka Exp $ */
d545 1
a545 1
	struct imsgbuf	 imsg;
d547 3
a549 3
	imsg_init(&imsg, sock);
	privsep_priv_dispatch_imsg(&imsg);
	imsg_clear(&imsg);
d933 1
a933 1
		if ((n = imsg_read(&privsep_ibuf)) <= 0) {
d938 1
a938 1
		if ((n = imsg_get(&privsep_ibuf, imsg)) < 0)
@


1.9
log
@Fix memory leak in privsep.c.  Free the memories which were allocated by
getcap(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.8 2013/01/31 02:14:46 yasuoka Exp $ */
d19 2
a21 3
#include <sys/uio.h>
#include <sys/time.h>
#include <sys/un.h>
d23 2
a24 1

a25 3
#include <net/pfkeyv2.h>
#include <net/if.h>
#include <arpa/inet.h>
d27 3
d31 1
a31 1
#include <stdio.h>
a32 2
#include <errno.h>
#include <fcntl.h>
a33 3
#include <stdlib.h>
#include <err.h>
#include <event.h>
d45 2
a46 1
enum PRIVSEP_CMD {
d61 3
a63 4
	enum PRIVSEP_CMD cmd;
	char path[PATH_MAX];
	int flags;
	mode_t mode;
d67 3
a69 4
	enum PRIVSEP_CMD cmd;
	int domain;
	int type;
	int protocol;
d73 2
a74 3
	enum PRIVSEP_CMD cmd;
	struct sockaddr_storage name;
	socklen_t namelen;
d78 5
a82 6
	enum PRIVSEP_CMD cmd;
	size_t len;
	int flags;
	struct sockaddr_storage to;
	socklen_t tolen;
	u_char msg[0];
d86 1
a86 2
	enum PRIVSEP_CMD cmd;
	char path[PATH_MAX];
d90 2
a91 3
	enum PRIVSEP_CMD cmd;
	char             path[PATH_MAX];
	char             username[MAX_USERNAME_LENGTH];
d95 1
a95 2
	enum PRIVSEP_CMD         cmd;
	char                     ifname[IFNAMSIZ];
d99 3
a101 3
	int                      retval;
	int                      rerrno;
	struct in_addr           addr;
d105 2
a106 3
	enum PRIVSEP_CMD         cmd;
	char                     ifname[IFNAMSIZ];
	struct in_addr           addr;
d110 1
a110 2
	enum PRIVSEP_CMD         cmd;
	char                     ifname[IFNAMSIZ];
d114 2
a115 3
	enum PRIVSEP_CMD         cmd;
	char                     ifname[IFNAMSIZ];
	int                      flags;
d119 3
a121 3
	int                      retval;
	int                      rerrno;
	int                      flags;
d125 2
a126 3
	enum PRIVSEP_CMD         cmd;
	char                     ifname[IFNAMSIZ];
	int                      flags;
d130 2
a131 2
	int retval;
	int rerrno;
d135 6
a140 6
	int              retval;
	int              rerrno;
	char             password[MAX_PASSWORD_LENGTH];
	struct in_addr   framed_ip_address;
	struct in_addr   framed_ip_netmask;
	char             calling_number[NPPPD_PHONE_NUMBER_LEN + 1];
d143 28
a170 20
static void  privsep_priv_main (int, int);
static void  privsep_priv_on_sockio (int, short, void *);
static void  privsep_priv_on_monpipeio (int, short, void *);
static int   privsep_recvfd (void);
static int   privsep_common_resp (void);
static void  privsep_sendfd(int, int, int);
static int   privsep_npppd_check_open (struct PRIVSEP_OPEN_ARG *);
static int   privsep_npppd_check_socket (struct PRIVSEP_SOCKET_ARG *);
static int   privsep_npppd_check_bind (struct PRIVSEP_BIND_ARG *);
static int   privsep_npppd_check_sendto (struct PRIVSEP_SENDTO_ARG *);
static int   privsep_npppd_check_unlink (struct PRIVSEP_UNLINK_ARG *);
static int   privsep_npppd_check_get_user_info (struct PRIVSEP_GET_USER_INFO_ARG *);
static int   privsep_npppd_check_get_if_addr (struct PRIVSEP_GET_IF_ADDR_ARG *);
static int   privsep_npppd_check_set_if_addr (struct PRIVSEP_SET_IF_ADDR_ARG *);
static int   privsep_npppd_check_del_if_addr (struct PRIVSEP_DEL_IF_ADDR_ARG *);
static int   privsep_npppd_check_get_if_flags (struct PRIVSEP_GET_IF_FLAGS_ARG *);
static int   privsep_npppd_check_set_if_flags (struct PRIVSEP_SET_IF_FLAGS_ARG *);

static int privsep_sock = -1, privsep_monpipe = -1;;
static pid_t privsep_pid;
d175 2
a176 2
	pid_t pid;
	int pairsock[] = { -1, -1 }, monpipe[] = { -1, -1 }, ival;
d178 2
a179 14
	if (socketpair(AF_UNIX, SOCK_DGRAM, PF_UNSPEC, pairsock) == -1)
		return -1;

	ival = PRIVSEP_BUFSIZE;
	if (setsockopt(pairsock[1], SOL_SOCKET, SO_SNDBUF, &ival, sizeof(ival))
	    != 0)
		goto fail;
	if (setsockopt(pairsock[0], SOL_SOCKET, SO_RCVBUF, &ival, sizeof(ival))
	    != 0)
		goto fail;

	/* pipe for monitoring */
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, monpipe) == -1)
		goto fail;
d188 1
a188 2
		close(monpipe[1]);
		privsep_priv_main(pairsock[0], monpipe[0]);
a193 1
	close(monpipe[0]);
a194 1
	privsep_monpipe = monpipe[1];
d196 1
d198 1
a198 1
	return 0;
a204 4
	if (monpipe[0] >= 0) {
		close(monpipe[0]);
		close(monpipe[1]);
	}
d206 1
a206 1
	return -1;
d212 1
a216 4
	if (privsep_monpipe >= 0) {
		close(privsep_monpipe);
		privsep_monpipe = -1;
	}
d220 1
a220 1
privsep_priv_pid (void)
d222 1
a222 1
	return privsep_pid;
d224 1
d231 1
a231 6
	int retval;
	struct PRIVSEP_BIND_ARG a;
	struct msghdr m;
	struct iovec iov[1];
	struct cmsghdr *cm;
	u_char cm_space[CMSG_LEN(sizeof(int))];
d235 1
a235 1
		return -1;
a236 5
	memset(&m, 0, sizeof(m));

	iov[0].iov_base = &a;
	iov[0].iov_len = sizeof(a);
	a.cmd = PRIVSEP_BIND;
d240 3
a242 10
	cm = (struct cmsghdr *)cm_space;
	cm->cmsg_len = sizeof(cm_space);
	cm->cmsg_level = SOL_SOCKET;
	cm->cmsg_type = SCM_RIGHTS;
	*(int *)CMSG_DATA(cm) = sock;

	m.msg_iov = iov;
	m.msg_iovlen = nitems(iov);
	m.msg_control = cm;
	m.msg_controllen = sizeof(cm_space);
d244 1
a244 4
	if ((retval = sendmsg(privsep_sock, &m, 0)) < 0)
		return retval;

	return privsep_common_resp();
a249 1
	int retval;
a251 1
	a.cmd = PRIVSEP_SOCKET;
d255 3
a257 2
	if ((retval = send(privsep_sock, &a, sizeof(a), 0)) < 0)
		return retval;
d259 1
a259 1
	return privsep_recvfd();
a264 1
	int retval;
a266 1
	a.cmd = PRIVSEP_OPEN;
d270 3
a272 2
	if ((retval = send(privsep_sock, &a, sizeof(a), 0)) < 0)
		return retval;
d274 1
a274 1
	return privsep_recvfd();
d283 1
a283 1
		return NULL;
d292 2
a293 6
	struct PRIVSEP_SENDTO_ARG a;
	struct msghdr m;
	struct iovec iov[2];
	struct cmsghdr *cm;
	u_char cm_space[CMSG_LEN(sizeof(int))];
	int retval;
d297 1
a297 1
		return -1;
a298 1
	memset(&m, 0, sizeof(m));
a299 10
	iov[0].iov_base = &a;
	/*
	 * Don't assume sizeof(struct PRIVSEP_SENDTO_ARG) equals
	 * offsetof(struct PRIVSEP_SENDTO_ARG, msg).
	 */
	iov[0].iov_len = offsetof(struct PRIVSEP_SENDTO_ARG, msg);
	iov[1].iov_base = (void *)msg;
	iov[1].iov_len = len;

	a.cmd = PRIVSEP_SENDTO;
d305 4
d310 3
a312 13
	cm = (struct cmsghdr *)cm_space;
	cm->cmsg_len = sizeof(cm_space);
	cm->cmsg_level = SOL_SOCKET;
	cm->cmsg_type = SCM_RIGHTS;
	*(int *)CMSG_DATA(cm) = s;

	m.msg_iov = iov;
	m.msg_iovlen = nitems(iov);
	m.msg_control = cm;
	m.msg_controllen = sizeof(cm_space);

	if ((retval = sendmsg(privsep_sock, &m, 0)) < 0)
		return retval;
d314 1
a314 1
	return privsep_common_resp();
d320 1
a320 1
	return priv_sendto(s, msg, len, flags, NULL, 0);
a325 1
	int retval;
d328 3
a330 4
	a.cmd = PRIVSEP_UNLINK;
	strlcpy(a.path, path, sizeof(a.path));
	if ((retval = send(privsep_sock, &a, sizeof(a), 0)) < 0)
		return retval;
d332 1
a332 1
	return privsep_common_resp();
d339 7
a345 5
	int                                n, sz, retval;
	char                              *cp;
	struct PRIVSEP_GET_USER_INFO_ARG   a;
	struct PRIVSEP_GET_USER_INFO_RESP  r;
	npppd_auth_user                   *u;
a346 1
	a.cmd = PRIVSEP_GET_USER_INFO;
a348 2
	if ((retval = send(privsep_sock, &a, sizeof(a), 0)) < 0)
		return retval;
d350 16
a365 5
	if (recv(privsep_sock, &r, sizeof(r), 0) != sizeof(r))
		return -1;
	if (r.retval != 0) {
		errno = r.rerrno;
		return r.retval;
d368 2
a369 2
	sz = strlen(username) + strlen(r.password) +
	    strlen(r.calling_number) + 3;
d372 1
a372 1
		return -1;
d381 1
a381 1
	n = strlcpy(cp, r.password, sz);
d385 1
a385 1
	n = strlcpy(cp, r.calling_number, sz);
d388 2
a389 2
	u->framed_ip_address = r.framed_ip_address;
	u->framed_ip_netmask = r.framed_ip_netmask;
d393 1
a393 1
	return 0;
a398 1
	int                              retval;
d400 2
a401 1
	struct PRIVSEP_GET_IF_ADDR_RESP  r;
a402 1
	a.cmd = PRIVSEP_GET_IF_ADDR;
d404 6
a409 5
	if ((retval = send(privsep_sock, &a, sizeof(a), 0)) < 0)
		return retval;
	if ((retval = recv(privsep_sock, &r, sizeof(r), 0)) < 0) {
		if (retval < 0)
			return retval;
d411 1
a411 1
		return -1;
d413 7
a419 3

	if (r.retval != -1)
		*addr = r.addr;
d421 1
a421 1
		errno = r.rerrno;
d423 1
a423 1
	return 0;
a428 1
	int                              retval;
a430 1
	a.cmd = PRIVSEP_DEL_IF_ADDR;
d432 3
a434 3
	if ((retval = send(privsep_sock, &a, sizeof(a), 0)) < 0)
		return retval;
	retval = privsep_common_resp();
d436 1
a436 1
	return retval;
a441 1
	int                              retval;
a443 1
	a.cmd = PRIVSEP_SET_IF_ADDR;
d446 3
a448 2
	if ((retval = send(privsep_sock, &a, sizeof(a), 0)) < 0)
		return retval;
d450 1
a450 1
	return privsep_common_resp();
d456 3
a458 3
	int                              retval;
	struct PRIVSEP_GET_IF_FLAGS_ARG   a;
	struct PRIVSEP_GET_IF_FLAGS_RESP  r;
a459 1
	a.cmd = PRIVSEP_GET_IF_FLAGS;
d461 10
a470 5
	if ((retval = send(privsep_sock, &a, sizeof(a), 0)) < 0)
		return retval;
	if ((retval = recv(privsep_sock, &r, sizeof(r), 0)) < 0) {
		if (retval < 0)
			return retval;
d472 1
a472 1
		return -1;
d474 4
a477 1
	*pflags = r.flags;
d479 1
a479 4
	if (r.retval != 0)
		errno = r.rerrno;

	return 0;
a484 1
	int                               retval;
a486 1
	a.cmd = PRIVSEP_SET_IF_FLAGS;
d489 6
a494 3
	if ((retval = send(privsep_sock, &a, sizeof(a), 0)) < 0)
		return retval;
	return privsep_common_resp();
d500 6
a505 20
	struct PRIVSEP_COMMON_RESP r;
	struct msghdr m;
	struct cmsghdr *cm;
	struct iovec iov[1];
	u_char cmsgbuf[256];

	memset(&m, 0, sizeof(m));

	iov[0].iov_base = &r;
	iov[0].iov_len = sizeof(r);
	memset(cmsgbuf, 0, sizeof(cmsgbuf));
	m.msg_iov = iov;
	m.msg_iovlen = nitems(iov);
	m.msg_control = cmsgbuf;
	m.msg_controllen = sizeof(cmsgbuf);
	if (recvmsg(privsep_sock, &m, 0) < sizeof(struct PRIVSEP_COMMON_RESP))
		goto on_error;
	if (r.retval < 0) {
		errno = r.rerrno;
		return r.retval;
d507 3
a509 8
	for (cm = CMSG_FIRSTHDR(&m); m.msg_controllen != 0 && cm;
	    cm = CMSG_NXTHDR(&m, cm)) {
		if (cm->cmsg_level == SOL_SOCKET &&
		    cm->cmsg_type == SCM_RIGHTS &&
		    cm->cmsg_len >= CMSG_LEN(sizeof(int))) {
			return *(int *)CMSG_DATA(cm);
		} else
			break;
d511 3
d515 1
a515 3
on_error:
	errno = EACCES;
	return -1;
d521 2
a522 1
	struct PRIVSEP_COMMON_RESP r;
d524 1
a524 2
	if (recv(privsep_sock, &r, sizeof(r), 0)
	    < sizeof(struct PRIVSEP_COMMON_RESP)) {
d526 1
a526 1
		return -1;
d528 7
a534 2
	if (r.retval != 0)
		errno = r.rerrno;
d536 1
a536 1
	return r.retval;
d543 1
a543 1
privsep_priv_main(int sock, int monpipe)
d545 1
a545 8
	struct event ev_sock, ev_monpipe;

	event_init();

	event_set(&ev_sock, sock, EV_READ | EV_PERSIST, privsep_priv_on_sockio,
	    NULL);
	event_set(&ev_monpipe, monpipe, EV_READ, privsep_priv_on_monpipeio,
	    NULL);
d547 3
a549 6
	if (event_add(&ev_sock, NULL) != 0)
		err(1, "event_add() failed on %s()", __func__);
	if (event_add(&ev_monpipe, NULL) != 0)
		err(1, "event_add() failed on %s()", __func__);

	event_loop(0);
a550 1
	close(monpipe);
d556 1
a556 1
privsep_priv_on_sockio(int sock, short evmask, void *ctx)
d558 1
a558 16
	int retval, fdesc;
	u_char rbuf[PRIVSEP_BUFSIZE], rcmsgbuf[128];
	struct iovec riov[1];
	struct msghdr rmsg;
	struct cmsghdr *cm;

	if (evmask & EV_READ) {
		fdesc = -1;

		memset(&rmsg, 0, sizeof(rmsg));
		riov[0].iov_base = rbuf;
		riov[0].iov_len = sizeof(rbuf);
		rmsg.msg_iov = riov;
		rmsg.msg_iovlen = nitems(riov);
		rmsg.msg_control = rcmsgbuf;
		rmsg.msg_controllen = sizeof(rcmsgbuf);
d560 2
a561 2
		if ((retval = recvmsg(sock, &rmsg, 0)) < 0) {
			event_loopexit(NULL);
a562 10
		}

		for (cm = CMSG_FIRSTHDR(&rmsg); rmsg.msg_controllen != 0 && cm;
		    cm = CMSG_NXTHDR(&rmsg, cm)) {
			if (cm->cmsg_level == SOL_SOCKET &&
			    cm->cmsg_type == SCM_RIGHTS &&
			    cm->cmsg_len >= CMSG_LEN(sizeof(int))) {
				fdesc = *(int *)CMSG_DATA(cm);
			}
		}
d564 1
a564 1
		switch (*(enum PRIVSEP_CMD *)rbuf) {
d566 3
a568 1
			struct PRIVSEP_OPEN_ARG	*a;
d570 15
a584 6
			a = (struct PRIVSEP_OPEN_ARG *)rbuf;
			if (privsep_npppd_check_open(a))
				privsep_sendfd(sock, -1, EACCES);
			else
				privsep_sendfd(sock,
				    open(a->path, a->flags, a->mode), 0);
d588 3
a590 1
			struct PRIVSEP_SOCKET_ARG *a;
d592 15
a606 6
			a = (struct PRIVSEP_SOCKET_ARG *)rbuf;
			if (privsep_npppd_check_socket(a))
				privsep_sendfd(sock, -1, EACCES);
			else
				privsep_sendfd(sock,
				    socket(a->domain, a->type, a->protocol), 0);
d610 2
a611 2
			struct PRIVSEP_UNLINK_ARG *a;
			struct PRIVSEP_COMMON_RESP r;
d613 3
a615 3
			a = (struct PRIVSEP_UNLINK_ARG *)rbuf;
			if (privsep_npppd_check_unlink(a)) {
				r.retval = -1;
d617 1
a617 1
			} else {
d621 4
a624 1
			(void)send(sock, &r, sizeof(r), 0);
d628 2
a629 2
			struct PRIVSEP_BIND_ARG	*a;
			struct PRIVSEP_COMMON_RESP r;
d631 2
a632 2
			a = (struct PRIVSEP_BIND_ARG *)rbuf;
			if (fdesc < 0) {
d634 1
a634 2
				r.retval = -1;
			} else if (privsep_npppd_check_bind(a)) {
d636 2
a637 3
				r.retval = -1;
			} else {
				if ((r.retval = bind(fdesc,
d641 1
a641 2
				close(fdesc);
				fdesc = -1;
d643 3
a645 1
			(void)send(sock, &r, sizeof(r), 0);
d649 1
a649 1
			struct PRIVSEP_GET_USER_INFO_ARG *a;
a653 1
			a = (struct PRIVSEP_GET_USER_INFO_ARG *)rbuf;
d655 1
d658 8
d667 1
a667 4

			str = buf = NULL;
			if (privsep_npppd_check_get_user_info(a)) {
				r.retval = -1;
d669 1
a669 1
			} else if ((retval = cgetent(&buf, db, a->username))
d722 3
a724 1
			(void)send(sock, &r, sizeof(r), 0);
d728 2
a729 2
			struct PRIVSEP_SENDTO_ARG *a;
			struct PRIVSEP_COMMON_RESP r;
d731 4
a734 4
			a = (struct PRIVSEP_SENDTO_ARG *)rbuf;
			if (retval < sizeof(struct PRIVSEP_SENDTO_ARG) ||
			    retval < offsetof(struct PRIVSEP_SENDTO_ARG,
				    msg[a->len])) {
d736 1
a736 2
				r.retval = -1;
			} else if (fdesc < 0) {
d738 1
a738 2
				r.retval = -1;
			} else if (privsep_npppd_check_sendto(a)) {
d740 1
a740 2
				r.retval = -1;
			} else {
d742 3
a744 2
					r.retval = sendto(fdesc, a->msg, a->len,
					    a->flags, (struct sockaddr *)&a->to,
d747 1
a747 1
					r.retval = send(fdesc, a->msg, a->len,
d751 1
a751 2
				close(fdesc);
				fdesc = -1;
d753 3
a755 1
			(void)send(sock, &r, sizeof(r), 0);
d761 1
a761 1
			struct PRIVSEP_GET_IF_ADDR_ARG  *a;
d764 3
a766 2
			a = (struct PRIVSEP_GET_IF_ADDR_ARG *)rbuf;
			if (privsep_npppd_check_get_if_addr(a)) {
d768 1
a768 2
				r.retval = -1;
			} else {
d782 3
a784 1
			(void)send(sock, &r, sizeof(r), 0);
d790 2
a791 2
			struct PRIVSEP_SET_IF_ADDR_ARG  *a;
			struct PRIVSEP_COMMON_RESP       r;
d794 3
a796 2
			a = (struct PRIVSEP_SET_IF_ADDR_ARG *)rbuf;
			if (privsep_npppd_check_set_if_addr(a)) {
d798 1
a798 2
				r.retval = -1;
			} else {
d828 3
a830 1
			(void)send(sock, &r, sizeof(r), 0);
d836 2
a837 2
			struct PRIVSEP_DEL_IF_ADDR_ARG  *a;
			struct PRIVSEP_COMMON_RESP       r;
d839 3
a841 2
			a = (struct PRIVSEP_DEL_IF_ADDR_ARG *)rbuf;
			if (privsep_npppd_check_del_if_addr(a)) {
d843 1
a843 2
				r.retval = -1;
			} else {
d856 3
a858 1
			(void)send(sock, &r, sizeof(r), 0);
d864 1
a864 1
			struct PRIVSEP_GET_IF_FLAGS_ARG  *a;
d867 6
a872 2
			a = (struct PRIVSEP_GET_IF_FLAGS_ARG *)rbuf;
			if (privsep_npppd_check_get_if_flags(a)) {
a873 1
				r.retval = -1;
d889 3
a891 1
			(void)send(sock, &r, sizeof(r), 0);
d897 2
a898 2
			struct PRIVSEP_SET_IF_FLAGS_ARG  *a;
			struct PRIVSEP_COMMON_RESP        r;
d900 3
a902 2
			a = (struct PRIVSEP_SET_IF_FLAGS_ARG *)rbuf;
			if (privsep_npppd_check_set_if_flags(a)) {
d904 1
a904 2
				r.retval = -1;
			} else {
d918 3
a920 1
			(void)send(sock, &r, sizeof(r), 0);
d927 2
a928 2
static void
privsep_priv_on_monpipeio(int sock, short evmask, void *ctx)
d930 1
a930 3
	/* called when the monitoring pipe is closed or broken */
	event_loopexit(NULL);
}
d932 11
a942 27
static void
privsep_sendfd(int sock, int fdesc, int rerrno)
{
	struct PRIVSEP_COMMON_RESP r;
	struct msghdr msg;
	struct cmsghdr *cm;
	struct iovec iov[1];
	u_char cm_space[CMSG_LEN(sizeof(int))];

	memset(&msg, 0, sizeof(msg));
	cm = (struct cmsghdr *)cm_space;
	iov[0].iov_base = &r;
	iov[0].iov_len = sizeof(r);
	r.rerrno = 0;
	r.retval = fdesc;

	if (fdesc < 0) {
		msg.msg_control = NULL;
		msg.msg_controllen = 0;
		r.rerrno = (rerrno == 0)? errno : rerrno;
	} else {
		cm->cmsg_len = sizeof(cm_space);
		cm->cmsg_level = SOL_SOCKET;
		cm->cmsg_type = SCM_RIGHTS;
		*(int *)CMSG_DATA(cm) = r.retval;
		msg.msg_control = cm;
		msg.msg_controllen = sizeof(cm_space);
d944 2
a945 5
	msg.msg_iov = iov;
	msg.msg_iovlen = nitems(iov);
	(void)sendmsg(sock, &msg, 0);
	if (fdesc >= 0)
		close(fdesc);
d970 1
a970 1
	for (i = 0; i < nitems(allow_paths); i++) {
d977 1
a977 1
		    	if ((arg->flags & O_ACCMODE) != O_RDONLY)
d980 1
a980 1
 		return 0;
d982 1
a982 1
	return 1;
d991 1
a991 1
		return 0;
d996 1
a996 1
		return 0;
d1001 1
a1001 1
		return 0;
d1003 1
a1003 1
	return 1;
d1009 1
a1009 2

	return 1;
d1018 1
a1018 1
		return 0;
d1022 1
a1022 1
		return 0;
d1024 1
a1024 1
	return 1;
d1031 1
a1031 1
	return 1;
d1041 1
a1041 1
		return 0;
d1043 1
a1043 1
	return 1;
d1051 1
a1051 1
		return 0;
d1053 1
a1053 1
	return 1;
d1061 1
a1061 1
		return 0;
d1063 1
a1063 1
	return 1;
d1071 1
a1071 1
		return 0;
d1073 1
a1073 1
	return 1;
d1081 1
a1081 1
		return 0;
d1083 1
a1083 1
	return 1;
d1091 1
a1091 1
		return 0;
d1093 1
a1093 1
	return 1;
@


1.8
log
@Deleting ip address of tun inteface was failed.  This was caused by
passing wrong inteface name to ioctl().

pointed out by csszep at gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.7 2012/09/28 23:46:00 yasuoka Exp $ */
d741 1
d753 2
d762 2
d770 2
d779 2
d783 1
d786 1
d788 4
@


1.7
log
@framed-ip-address and framed-ip-netmask were not working.

pointed out by Andrew Ngo.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.6 2012/09/18 13:14:08 yasuoka Exp $ */
d466 1
a466 1
	strlcpy(a.ifname, ifname, sizeof(ifname));
d491 1
a491 1
	strlcpy(a.ifname, ifname, sizeof(ifname));
d506 1
a506 1
	strlcpy(a.ifname, ifname, sizeof(ifname));
d522 1
a522 1
	strlcpy(a.ifname, ifname, sizeof(ifname));
d546 1
a546 1
	strlcpy(a.ifname, ifname, sizeof(ifname));
@


1.6
log
@New configuration syntax for npppd(8).  `npppd.conf' will be based on
parse.y and `npppd-users' will be based on getcap(3).  Add man pages.

feedback from giovanni
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.5 2012/05/08 13:15:12 yasuoka Exp $ */
d450 3
d737 2
@


1.5
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.4 2012/01/18 03:13:04 yasuoka Exp $ */
d23 1
d27 2
d43 3
d55 7
a61 1
	PRIVSEP_UNLINK
d98 46
d149 9
d169 6
d212 1
d407 143
d726 55
d813 152
d1028 3
a1030 1
		{ "/etc/resolv.conf",	0,	1 }
d1094 62
@


1.4
log
@Replace npppdctl(8) by new npppctl(8).  npppctl was written from
scratch, it uses parser.c derived from ikectl(8) to have OpenBSD's
fashion.  This includes related changes listed below:
- changed npppd control IPC heavyly.
- support IPv6 as tunnel source address.
- deleted support changing the configuration of npppd_ctl on running.
  Because it is not so needed but it requires privilege operations.
- refactors.

man page helps from jmc.  tested by sebastia.
ok deraadt sebastia sthen
@
text
@d1 1
a1 1
/* $OpenBSD: privsep.c,v 1.3 2011/07/08 06:14:54 yasuoka Exp $ */
@


1.3
log
@Improved npppd privileged separations:
- Changed finalizing way to the privileged process.  In old way, the
  privileged process could not aware abnormal exit of the process in
  jail.  Then the processes in jail remained as zombies.  Created a
  pipe to monitor the privileged process, the privileged process can
  exit in peace by using the pipe.
- npppd will exit abnormally when the privileged process exits
  abnormally.
- PF_KEY socket requires privileges.
- Return correct "errno" to the jail in priv_open().
- Cleanup.

ok hsuenaga@@
@
text
@d1 1
a1 1
/* $OpenBSD: privsep.c,v 1.2 2011/07/05 01:33:40 yasuoka Exp $ */
a645 5
	/* npppd uses /var/run/npppd_ctl as UNIX domain socket */
	if (arg->name.ss_family == AF_UNIX &&
	    startswith(((struct sockaddr_un *)&arg->name)->sun_path,
		    "/var/run/"))
		return 0;
a667 3
	/* npppd unlink the /var/run/npppd_ctl */
	if (startswith(arg->path, "/var/run/"))
		return 0;
@


1.2
log
@Fixed some bugs of priv_send().  The bugs caused sending routing messages
failures.  'errno' returned by the privileged process was not initialized.
'tolen' in priv_sendto() was garbage.

ok hsuenaga@@
@
text
@d1 1
a1 1
/* $OpenBSD: privsep.c,v 1.1 2010/01/31 05:49:51 yasuoka Exp $ */
d25 1
d34 2
d37 1
a39 1
#undef nitems
a44 1
	PRIVSEP_FINI,
d91 3
a93 1
static void  privsep_priv_main (int);
d103 2
a104 1
static int privsep_sock = -1;
d110 1
a110 1
	int pairsock[2];
d114 13
d128 1
a128 2
		return -1;

d134 2
a135 1
		privsep_priv_main(pairsock[0]);
d140 1
d142 2
d146 12
a162 2
	enum PRIVSEP_CMD cmd = PRIVSEP_FINI;

a163 1
		send(privsep_sock, &cmd, sizeof(cmd), 0);
d167 4
d173 5
d323 1
a323 1
	struct PRIVSEP_OPEN_ARG a;
d392 25
a416 1
privsep_priv_main(int sock)
d419 1
a419 1
	u_char rbuf[2048], rcmsgbuf[128];
d424 1
a424 1
	for (;;) {
d435 4
a438 3
		if ((retval = recvmsg(sock, &rmsg, 0)) <
		    sizeof(enum PRIVSEP_CMD))
			break;
a449 3
		case PRIVSEP_FINI:
			goto loop_exit;
			/* NOTREACHED */
d502 1
a502 1
				r.rerrno = errno;
d514 6
a519 1
			if (fdesc < 0) {
d543 1
a543 1
loop_exit:
d545 5
a549 1
	close(sock);
d571 1
a571 1
		r.rerrno = rerrno;
d596 23
a618 7
	/* BPF, configuration file or /etc/resolv.conf */
	if (startswith(arg->path, "/dev/bpf") ||
	    (startswith(arg->path, "/etc/npppd/") && arg->flags == O_RDONLY) ||
	    (strcmp(arg->path, "/etc/resolv.conf") == 0 &&
		    arg->flags == O_RDONLY))
		return 0;

d632 6
a637 1
	    arg->protocol  == IPPROTO_GRE)
@


1.1
log
@privilege separation of npppd.

- Drop privilege after daemon initializing.
- Some system calls that requires root privileges were replaced to
  wrapper functions that communicate with a separated privileged
  process via IPC.  And the privileged process checks whether the
  operations are acceptable.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d26 1
d242 5
a246 1
	iov[0].iov_len = sizeof(a);
d253 2
a254 1
	if (tolen > 0) {
a255 2
		a.tolen = tolen;
	}
d495 1
d568 1
a568 1
	if (arg->flags == 0 && arg->tolen >= 0 &&
@

