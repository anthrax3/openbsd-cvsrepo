head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.4
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.8
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2014.11.20.03.48.12;	author tedu;	state Exp;
branches;
next	1.6;
commitid	p39TubJravUKyG3v;

1.6
date	2014.04.16.05.57.05;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.12.05.23.20.26;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2010.09.22.11.48.38;	author yasuoka;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.13.07.49.44;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove nt and lanman functions which aren't used. ok reyk yasuoka
@
text
@/*	$OpenBSD: chap_ms.c,v 1.6 2014/04/16 05:57:05 jsg Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 1997-2001 Brian Somers <brian@@Awfulhak.org>
 * Copyright (c) 1997 Gabor Kincses <gabor@@acm.org>
 * Copyright (c) 1995 Eric Rosenquist
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
  */

#include <sys/types.h>

#include <ctype.h>
#include <string.h>
#include <stdio.h>

#include <openssl/evp.h>
#include <openssl/des.h>
#include <openssl/md4.h>
#include <openssl/md5.h>
#include <openssl/sha.h>

#include "chap_ms.h"

/*
 * Documentation & specifications:
 *
 * MS-CHAP (CHAP80)	RFC2433
 * MS-CHAP-V2 (CHAP81)	RFC2759
 * MPPE key management	RFC3079
 *
 * Security analysis:
 * Schneier/Mudge/Wagner, "MS-CHAP-v2", Oct 99
 * "It is unclear to us why this protocol is so complicated."
 */

static u_int8_t sha1_pad1[40] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static u_int8_t sha1_pad2[40] = {
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2
};

u_int8_t	 get7bits(u_int8_t *, int);
void		 mschap_des_addparity(u_int8_t *, u_int8_t *);
void		 mschap_des_encrypt(u_int8_t *, u_int8_t *, u_int8_t *);
void		 mschap_challenge_response(u_int8_t *, u_int8_t *, u_int8_t *);

u_int8_t
get7bits(u_int8_t *in, int start)
{
	u_int	 word;

	word = (u_int)in[start / 8] << 8;
	word |= (u_int)in[start / 8 + 1];
	word >>= 15 - (start % 8 + 7);

	return (word & 0xfe);
}

/* IN  56 bit DES key missing parity bits
   OUT 64 bit DES key with parity bits added */
void
mschap_des_addparity(u_int8_t *key, u_int8_t *des_key)
{
	des_key[0] = get7bits(key,  0);
	des_key[1] = get7bits(key,  7);
	des_key[2] = get7bits(key, 14);
	des_key[3] = get7bits(key, 21);
	des_key[4] = get7bits(key, 28);
	des_key[5] = get7bits(key, 35);
	des_key[6] = get7bits(key, 42);
	des_key[7] = get7bits(key, 49);

	DES_set_odd_parity((DES_cblock *)des_key);
}

void
mschap_des_encrypt(u_int8_t *clear, u_int8_t *key, u_int8_t *cipher)
{
	DES_cblock		des_key;
	DES_key_schedule	key_schedule;

	mschap_des_addparity(key, des_key);

	DES_set_key(&des_key, &key_schedule);
	DES_ecb_encrypt((DES_cblock *)clear, (DES_cblock *)cipher,
	    &key_schedule, 1);
}

void
mschap_challenge_response(u_int8_t *challenge, u_int8_t *pwhash,
    u_int8_t *response)
{
	u_int8_t	 padpwhash[21 + 1];

	bzero(&padpwhash, sizeof(padpwhash));
	memcpy(padpwhash, pwhash, MSCHAP_HASH_SZ);

	mschap_des_encrypt(challenge, padpwhash + 0, response + 0);
	mschap_des_encrypt(challenge, padpwhash + 7, response + 8);
	mschap_des_encrypt(challenge, padpwhash + 14, response + 16);
}

void
mschap_ntpassword_hash(u_int8_t *in, int inlen, u_int8_t *hash)
{
	EVP_MD_CTX	 ctx;
	u_int		 mdlen;

	EVP_DigestInit(&ctx, EVP_md4());
	EVP_DigestUpdate(&ctx, in, inlen);
	EVP_DigestFinal(&ctx, hash, &mdlen);
}

void
mschap_challenge_hash(u_int8_t *peer_challenge, u_int8_t *auth_challenge,
    u_int8_t *username, int usernamelen, u_int8_t *challenge)
{
	EVP_MD_CTX	 ctx;
	u_int8_t	 md[SHA_DIGEST_LENGTH];
	u_int		 mdlen;
	u_int8_t	*name;

	if ((name = strrchr(username, '\\')) == NULL)
		name = username;
	else
		name++;

	EVP_DigestInit(&ctx, EVP_sha1());
	EVP_DigestUpdate(&ctx, peer_challenge, MSCHAPV2_CHALLENGE_SZ);
	EVP_DigestUpdate(&ctx, auth_challenge, MSCHAPV2_CHALLENGE_SZ);
	EVP_DigestUpdate(&ctx, name, strlen(name));
	EVP_DigestFinal(&ctx, md, &mdlen);

	memcpy(challenge, md, MSCHAP_CHALLENGE_SZ);
}

void
mschap_nt_response(u_int8_t *auth_challenge, u_int8_t *peer_challenge,
    u_int8_t *username, int usernamelen, u_int8_t *password, int passwordlen,
    u_int8_t *response)
{
	u_int8_t challenge[MSCHAP_CHALLENGE_SZ];
	u_int8_t password_hash[MSCHAP_HASH_SZ];

	mschap_challenge_hash(peer_challenge, auth_challenge,
	    username, usernamelen, challenge);

	mschap_ntpassword_hash(password, passwordlen, password_hash);
	mschap_challenge_response(challenge, password_hash, response);
}

void
mschap_auth_response(u_int8_t *password, int passwordlen,
    u_int8_t *ntresponse, u_int8_t *auth_challenge, u_int8_t *peer_challenge,
    u_int8_t *username, int usernamelen, u_int8_t *auth_response)
{
	EVP_MD_CTX	 ctx;
	u_int8_t	 password_hash[MSCHAP_HASH_SZ];
	u_int8_t	 password_hash2[MSCHAP_HASH_SZ];
	u_int8_t	 challenge[MSCHAP_CHALLENGE_SZ];
	u_int8_t	 md[SHA_DIGEST_LENGTH], *ptr;
	u_int		 mdlen;
	int		 i;
	const u_int8_t	 hex[] = "0123456789ABCDEF";
	static u_int8_t	 magic1[39] = {
		0x4D, 0x61, 0x67, 0x69, 0x63, 0x20, 0x73, 0x65, 0x72, 0x76,
		0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6C, 0x69, 0x65,
		0x6E, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67,
		0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74
	};
	static u_int8_t	 magic2[41] = {
		0x50, 0x61, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x6B,
		0x65, 0x20, 0x69, 0x74, 0x20, 0x64, 0x6F, 0x20, 0x6D, 0x6F,
		0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x6F, 0x6E,
		0x65, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F,
		0x6E
	};

	mschap_ntpassword_hash(password, passwordlen, password_hash);
	mschap_ntpassword_hash(password_hash, MSCHAP_HASH_SZ, password_hash2);

	EVP_DigestInit(&ctx, EVP_sha1());
	EVP_DigestUpdate(&ctx, password_hash2, sizeof(password_hash2));
	EVP_DigestUpdate(&ctx, ntresponse, 24);
	EVP_DigestUpdate(&ctx, magic1, 39);
	EVP_DigestFinal(&ctx, md, &mdlen);

	mschap_challenge_hash(peer_challenge, auth_challenge,
	    username, usernamelen, challenge);

	EVP_DigestInit(&ctx, EVP_sha1());
	EVP_DigestUpdate(&ctx, md, sizeof(md));
	EVP_DigestUpdate(&ctx, challenge, sizeof(challenge));
	EVP_DigestUpdate(&ctx, magic2, 41);
	EVP_DigestFinal(&ctx, md, &mdlen);

	/*
	 * Encode the value of 'Digest' as "S=" followed by
	 * 40 ASCII hexadecimal digits and return it in
	 * AuthenticatorResponse.
	 * For example,
	 *   "S=0123456789ABCDEF0123456789ABCDEF01234567"
	 */
	ptr = auth_response;
	*ptr++ = 'S';
	*ptr++ = '=';
	for (i = 0; i < SHA_DIGEST_LENGTH; i++) {
		*ptr++ = hex[md[i] >> 4];
		*ptr++ = hex[md[i] & 0x0f];
	}
}

void
mschap_masterkey(u_int8_t *password_hash2, u_int8_t *ntresponse,
    u_int8_t *masterkey)
{
	u_int8_t	 md[SHA_DIGEST_LENGTH];
	u_int		 mdlen;
	EVP_MD_CTX	 ctx;
	static u_int8_t	 magic1[27] = {
		0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74,
		0x68, 0x65, 0x20, 0x4d, 0x50, 0x50, 0x45, 0x20, 0x4d,
		0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x4b, 0x65, 0x79
	};

	EVP_DigestInit(&ctx, EVP_sha1());
	EVP_DigestUpdate(&ctx, password_hash2, MSCHAP_HASH_SZ);
	EVP_DigestUpdate(&ctx, ntresponse, 24);
	EVP_DigestUpdate(&ctx, magic1, 27);
	EVP_DigestFinal(&ctx, md, &mdlen);

	memcpy(masterkey, md, 16);
}

void
mschap_asymetric_startkey(u_int8_t *masterkey, u_int8_t *sessionkey,
    int sessionkeylen, int issend, int isserver)
{
	EVP_MD_CTX	 ctx;
	u_int8_t	 md[SHA_DIGEST_LENGTH];
	u_int		 mdlen;
	u_int8_t	*s;
	static u_int8_t	 magic2[84] = {
		0x4f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69,
		0x65, 0x6e, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2c, 0x20,
		0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
		0x65, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x6b, 0x65, 0x79,
		0x3b, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
		0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73, 0x69, 0x64, 0x65,
		0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
		0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20,
		0x6b, 0x65, 0x79, 0x2e
	};
	static u_int8_t	 magic3[84] = {
		0x4f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69,
		0x65, 0x6e, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2c, 0x20,
		0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
		0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20,
		0x6b, 0x65, 0x79, 0x3b, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68,
		0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73,
		0x69, 0x64, 0x65, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73,
		0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20,
		0x6b, 0x65, 0x79, 0x2e
	};

	if (issend)
		s = isserver ? magic3 : magic2;
	else
		s = isserver ? magic2 : magic3;

	EVP_DigestInit(&ctx, EVP_sha1());
	EVP_DigestUpdate(&ctx, masterkey, 16);
	EVP_DigestUpdate(&ctx, sha1_pad1, 40);
	EVP_DigestUpdate(&ctx, s, 84);
	EVP_DigestUpdate(&ctx, sha1_pad2, 40);
	EVP_DigestFinal(&ctx, md, &mdlen);

	memcpy(sessionkey, md, sessionkeylen);
}

void
mschap_msk(u_int8_t *password, int passwordlen,
    u_int8_t *ntresponse, u_int8_t *msk)
{
	u_int8_t	 password_hash[MSCHAP_HASH_SZ];
	u_int8_t	 password_hash2[MSCHAP_HASH_SZ];
	u_int8_t	 masterkey[MSCHAP_MASTERKEY_SZ];
	u_int8_t	 sendkey[MSCHAP_MASTERKEY_SZ];
	u_int8_t	 recvkey[MSCHAP_MASTERKEY_SZ];

	mschap_ntpassword_hash(password, passwordlen, password_hash);
	mschap_ntpassword_hash(password_hash, MSCHAP_HASH_SZ, password_hash2);

	mschap_masterkey(password_hash2, ntresponse, masterkey);
	mschap_asymetric_startkey(masterkey, recvkey, sizeof(recvkey), 0, 1);
	mschap_asymetric_startkey(masterkey, sendkey, sizeof(sendkey), 1, 1);

	/* 16 bytes receive key + 16 bytes send key + 32 bytes 0 padding */
	bzero(msk, MSCHAP_MSK_SZ);
	memcpy(msk, &recvkey, sizeof(recvkey));
	memcpy(msk + sizeof(recvkey), &sendkey, sizeof(sendkey));
}

void
mschap_radiuskey(u_int8_t *plain, const u_int8_t *crypted,
    const u_int8_t *authenticator, const u_int8_t *secret)
{
	EVP_MD_CTX	 ctx;
	u_int8_t	 b[MD5_DIGEST_LENGTH], p[32];
	u_int		 i, mdlen;

	EVP_DigestInit(&ctx, EVP_md5());
	EVP_DigestUpdate(&ctx, secret, strlen(secret));
	EVP_DigestUpdate(&ctx, authenticator, 16);
	EVP_DigestUpdate(&ctx, crypted, 2);
	EVP_DigestFinal(&ctx, b, &mdlen);

	for (i = 0; i < mdlen; i++) {
		p[i] = b[i] ^ crypted[i+2];
	}

	EVP_DigestInit(&ctx, EVP_md5());
	EVP_DigestUpdate(&ctx, secret, strlen(secret));
	EVP_DigestUpdate(&ctx, crypted + 2, mdlen);
	EVP_DigestFinal(&ctx, b, &mdlen);

	for (i = 0; i < mdlen; i++) {
		p[i+16] = b[i] ^ crypted[i+18];
	}

	memcpy(plain, p+1, 16);
}
@


1.6
log
@sync with iked chap_ms.c
@
text
@d1 1
a1 1
/*	$OpenBSD: chap_ms.c,v 1.7 2014/04/16 04:59:56 miod Exp $	*/
a332 46
}

void
mschap_newkey(u_int8_t *startkey, u_int8_t *sessionkey,
    long sessionkeylen, u_int8_t *key)
{
	EVP_MD_CTX	 ctx;
	u_int8_t	 md[SHA_DIGEST_LENGTH];
	u_int		 mdlen;

	EVP_DigestInit(&ctx, EVP_sha1());
	EVP_DigestUpdate(&ctx, startkey, sessionkeylen);
	EVP_DigestUpdate(&ctx, sha1_pad1, sizeof(sha1_pad1));
	EVP_DigestUpdate(&ctx, sessionkey, sessionkeylen);
	EVP_DigestUpdate(&ctx, sha1_pad2, sizeof(sha1_pad2));
	EVP_DigestFinal(&ctx, md, &mdlen);

	memcpy(key, md, sessionkeylen);
}

void
mschap_nt(u_int8_t *password_hash, u_int8_t *challenge)
{
	u_int8_t	 response[24];

	mschap_challenge_response(challenge, password_hash, response);
	memcpy(password_hash, response, sizeof(response));
	password_hash[24] = 1;	/* NT-style response */
}

void
mschap_lanman(u_int8_t *digest, u_int8_t *challenge, u_int8_t *secret)
{
	static u_int8_t	 salt[] = "KGS!@@#$%"; /* RASAPI32.dll */
	u_int8_t	 SECRET[14 + 1], *ptr, *end;
	u_int8_t	 hash[MSCHAP_HASH_SZ];

	bzero(&SECRET, sizeof(SECRET));
	end = SECRET + (sizeof(SECRET) - 1);
	for (ptr = SECRET; *secret && ptr < end; ptr++, secret++)
		*ptr = toupper(*secret);

	mschap_des_encrypt(salt, SECRET, hash);
	mschap_des_encrypt(salt, SECRET + 7, hash + 8);

	mschap_challenge_response(challenge, hash, digest);
@


1.5
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 2
/*	$OpenBSD: chap_ms.c,v 1.4 2010/09/22 11:48:38 yasuoka Exp $	*/
/*	$vantronix: chap_ms.c,v 1.7 2010/06/02 12:22:58 reyk Exp $	*/
d4 2
a5 2
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
 * Copyright (c) 1997 - 2001 Brian Somers <brian@@Awfulhak.org>
d104 1
a104 1
	DES_set_odd_parity((des_cblock *)des_key);
d110 2
a111 2
	des_cblock		des_key;
	des_key_schedule	key_schedule;
d116 1
a116 1
	DES_ecb_encrypt((des_cblock *)clear, (des_cblock *)cipher,
d124 1
a124 1
	u_int8_t	 padpwhash[21];
d160 1
a160 1
	EVP_DigestUpdate(&ctx, peer_challenge, MSCHAPV2_CHALLENGE_SZ); 
d367 1
a367 1
	u_int8_t	 SECRET[14], *ptr, *end;
d370 2
a371 1
	end = SECRET + sizeof(SECRET);
a373 2
	if (ptr < end)
		memset(ptr, '\0', end - ptr);
d395 1
a395 1
	for(i = 0; i < mdlen; i++) {
d404 1
a404 1
	for(i = 0; i < mdlen; i++) {
@


1.4
log
@unify MS-CHAP implementation to sbin/iked/chap_ms.[ch].
copy sbin/iked/chap_ms.[ch] and fixed chap.c and eap.c to compile with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: chap_ms.c,v 1.1 2010/06/03 16:41:12 reyk Exp $	*/
a34 1
#include <sys/cdefs.h>
@


1.3
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d4 6
a9 5
/*-
 * Copyright (c) 1997        Gabor Kincses <gabor@@acm.org>
 *               1997 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Eric Rosenquist
 *                           Strata Software Limited.
d32 3
a34 3
 *
 * $FreeBSD: src/usr.sbin/ppp/chap_ms.c,v 1.9.2.5 2001/08/18 02:46:06 brian Exp $
 */
d36 1
a36 9
#ifndef LINT
__COPYRIGHT(
"@@(#) Copyright (c) 1997        Gabor Kincses <gabor@@acm.org>\n"
"@@(#)               1997 - 2001 Brian Somers <brian@@Awfulhak.org>\n"
"@@(#)          based on work by Eric Rosenquist\n"
"@@(#)                           Strata Software Limited.\n"
"@@(#) All rights reserved.\n"
);
#endif
d38 4
a41 1
#ifdef __FreeBSD__
d43 2
a44 9
#include <sha.h>
#else
#include <sys/types.h>
#include <stdlib.h>
#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <openssl/des.h>
#else
#include <des.h>
#endif
a45 5
#endif
#include <md4.h>
#include <md5.h>
#include <string.h>
#include <stdio.h>
a46 1
#include <openssl/opensslv.h>
d52 7
a58 3
 * MS-CHAP (CHAP80)	rfc2433
 * MS-CHAP-V2 (CHAP81)	rfc2759
 * MPPE key management	draft-ietf-pppext-mppe-keys-02.txt
d61 5
a65 18
static char SHA1_Pad1[40] =
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

static char SHA1_Pad2[40] =
  {0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
   0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
   0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2,
   0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2, 0xF2};

/* unused, for documentation only */
/* only NTResp is filled in for FreeBSD */
struct MS_ChapResponse {
    u_char LANManResp[24];
    u_char NTResp[24];
    u_char UseNT;	/* If 1, ignore the LANMan response field */
d68 14
a81 2
static u_char
Get7Bits(u_char *input, int startBit)
d83 1
a83 4
    register unsigned int	word;

    word  = (unsigned)input[startBit / 8] << 8;
    word |= (unsigned)input[startBit / 8 + 1];
d85 3
a87 1
    word >>= 15 - (startBit % 8 + 7);
d89 1
a89 1
    return word & 0xFE;
d94 2
a95 2
static void
MakeKey(u_char *key, u_char *des_key)
d97 8
a104 8
    des_key[0] = Get7Bits(key,  0);
    des_key[1] = Get7Bits(key,  7);
    des_key[2] = Get7Bits(key, 14);
    des_key[3] = Get7Bits(key, 21);
    des_key[4] = Get7Bits(key, 28);
    des_key[5] = Get7Bits(key, 35);
    des_key[6] = Get7Bits(key, 42);
    des_key[7] = Get7Bits(key, 49);
d106 1
a106 1
    DES_set_odd_parity((des_cblock *)des_key);
d109 2
a110 2
static void /* IN 8 octets IN 7 octest OUT 8 octets */
DesEncrypt(u_char *clear, u_char *key, u_char *cipher)
d112 2
a113 2
    des_cblock		des_key;
    des_key_schedule	key_schedule;
d115 1
a115 1
    MakeKey(key, des_key);
d117 3
a119 2
    DES_set_key(&des_key, &key_schedule);
    DES_ecb_encrypt((des_cblock *)clear, (des_cblock *)cipher, &key_schedule, 1);
d122 3
a124 2
static void      /* IN 8 octets      IN 16 octets     OUT 24 octets */
ChallengeResponse(u_char *challenge, u_char *pwHash, u_char *response)
d126 1
a126 1
    char    ZPasswordHash[21];
d128 2
a129 2
    memset(ZPasswordHash, '\0', sizeof ZPasswordHash);
    memcpy(ZPasswordHash, pwHash, 16);
d131 3
a133 3
    DesEncrypt(challenge, ZPasswordHash +  0, response + 0);
    DesEncrypt(challenge, ZPasswordHash +  7, response + 8);
    DesEncrypt(challenge, ZPasswordHash + 14, response + 16);
d137 1
a137 1
NtPasswordHash(char *key, int keylen, char *hash)
d139 2
a140 1
  MD4_CTX MD4context;
d142 3
a144 3
  MD4Init(&MD4context);
  MD4Update(&MD4context, key, keylen);
  MD4Final(hash, &MD4context);
d148 2
a149 1
HashNtPasswordHash(char *hash, char *hashhash)
d151 4
a154 20
  MD4_CTX MD4context;

  MD4Init(&MD4context);
  MD4Update(&MD4context, hash, 16);
  MD4Final(hashhash, &MD4context);
}

void
ChallengeHash(char *PeerChallenge, char *AuthenticatorChallenge,
              char *UserName, int UserNameLen, char *Challenge)
{
  SHA_CTX Context;
  char Digest[SHA_DIGEST_LENGTH];
  char *Name;

  Name = strrchr(UserName, '\\');
  if(NULL == Name)
    Name = UserName;
  else
    Name++;
d156 4
a159 1
  SHA1_Init(&Context);
d161 5
a165 3
  SHA1_Update(&Context, PeerChallenge, 16);
  SHA1_Update(&Context, AuthenticatorChallenge, 16);
  SHA1_Update(&Context, Name, strlen(Name));
d167 1
a167 2
  SHA1_Final(Digest, &Context);
  memcpy(Challenge, Digest, 8);
d171 3
a173 3
GenerateNTResponse(char *AuthenticatorChallenge, char *PeerChallenge,
                   char *UserName, int UserNameLen, char *Password,
                   int PasswordLen, char *Response)
d175 2
a176 2
  char Challenge[8];
  char PasswordHash[16];
d178 2
a179 15
  ChallengeHash(PeerChallenge, AuthenticatorChallenge, UserName, UserNameLen,
                Challenge);
  NtPasswordHash(Password, PasswordLen, PasswordHash);
  ChallengeResponse(Challenge, PasswordHash, Response);
}

#if !defined(__FreeBSD__)
static char *SHA1_End __P((SHA_CTX *, char *));
#define LENGTH 20
static char *
SHA1_End(SHA_CTX *ctx, char *buf)
{
    int i;
    unsigned char digest[LENGTH];
    static const char hex[]="0123456789abcdef";
d181 2
a182 11
    if (!buf)
        buf = malloc(2*LENGTH + 1);
    if (!buf)
        return 0;
    SHA1_Final(digest, ctx);
    for (i = 0; i < LENGTH; i++) {
        buf[i+i] = hex[digest[i] >> 4];
        buf[i+i+1] = hex[digest[i] & 0x0f];
    }
    buf[i+i] = '\0';
    return buf;
a183 1
#endif
d186 3
a188 4
GenerateAuthenticatorResponse(char *Password, int PasswordLen,
                              char *NTResponse, char *PeerChallenge,
                              char *AuthenticatorChallenge, char *UserName,
                              int UserNameLen, char *AuthenticatorResponse)
d190 21
a210 6
  SHA_CTX Context;
  char PasswordHash[16];
  char PasswordHashHash[16];
  char Challenge[8];
  u_char Digest[SHA_DIGEST_LENGTH];
  int i;
d212 2
a213 8
      /*
       * "Magic" constants used in response generation
       */
  char Magic1[39] =
         {0x4D, 0x61, 0x67, 0x69, 0x63, 0x20, 0x73, 0x65, 0x72, 0x76,
          0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6C, 0x69, 0x65,
          0x6E, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67,
          0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74};
d215 5
d221 2
a222 14
  char Magic2[41] =
         {0x50, 0x61, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x6B,
          0x65, 0x20, 0x69, 0x74, 0x20, 0x64, 0x6F, 0x20, 0x6D, 0x6F,
          0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x6F, 0x6E,
          0x65, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F,
          0x6E};
      /*
       * Hash the password with MD4
       */
  NtPasswordHash(Password, PasswordLen, PasswordHash);
      /*
       * Now hash the hash
       */
  HashNtPasswordHash(PasswordHash, PasswordHashHash);
d224 5
a228 24
  SHA1_Init(&Context);
  SHA1_Update(&Context, PasswordHashHash, 16);
  SHA1_Update(&Context, NTResponse, 24);
  SHA1_Update(&Context, Magic1, 39);
  SHA1_Final(Digest, &Context);
  ChallengeHash(PeerChallenge, AuthenticatorChallenge, UserName, UserNameLen,
                Challenge);
  SHA1_Init(&Context);
  SHA1_Update(&Context, Digest, 20);
  SHA1_Update(&Context, Challenge, 8);
  SHA1_Update(&Context, Magic2, 41);

      /*
       * Encode the value of 'Digest' as "S=" followed by
       * 40 ASCII hexadecimal digits and return it in
       * AuthenticatorResponse.
       * For example,
       *   "S=0123456789ABCDEF0123456789ABCDEF01234567"
       */
  AuthenticatorResponse[0] = 'S';
  AuthenticatorResponse[1] = '=';
  SHA1_End(&Context, AuthenticatorResponse + 2);
  for (i=2; i<42; i++)
    AuthenticatorResponse[i] = toupper((unsigned char)AuthenticatorResponse[i]);
d230 14
d247 2
a248 1
GetMasterKey(char *PasswordHashHash, char *NTResponse, char *MasterKey)
d250 14
a263 6
  char Digest[SHA_DIGEST_LENGTH];
  SHA_CTX Context;
  static char Magic1[27] =
      {0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74,
       0x68, 0x65, 0x20, 0x4d, 0x50, 0x50, 0x45, 0x20, 0x4d,
       0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x4b, 0x65, 0x79};
d265 1
a265 6
  SHA1_Init(&Context);
  SHA1_Update(&Context, PasswordHashHash, 16);
  SHA1_Update(&Context, NTResponse, 24);
  SHA1_Update(&Context, Magic1, 27);
  SHA1_Final(Digest, &Context);
  memcpy(MasterKey, Digest, 16);
d269 2
a270 2
GetAsymetricStartKey(char *MasterKey, char *SessionKey, int SessionKeyLength,
                     int IsSend, int IsServer)
d272 26
a297 3
  char Digest[SHA_DIGEST_LENGTH];
  SHA_CTX Context;
  char *s;
d299 4
a302 10
  static char Magic2[84] =
      {0x4f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69,
       0x65, 0x6e, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2c, 0x20,
       0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
       0x65, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x6b, 0x65, 0x79,
       0x3b, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
       0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73, 0x69, 0x64, 0x65,
       0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
       0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20,
       0x6b, 0x65, 0x79, 0x2e};
d304 6
a309 10
  static char Magic3[84] =
      {0x4f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69,
       0x65, 0x6e, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2c, 0x20,
       0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
       0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20,
       0x6b, 0x65, 0x79, 0x3b, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68,
       0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73,
       0x69, 0x64, 0x65, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73,
       0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20,
       0x6b, 0x65, 0x79, 0x2e};
d311 1
a311 22
  if (IsSend) {
     if (IsServer) {
        s = Magic3;
     } else {
        s = Magic2;
     }
  } else {
     if (IsServer) {
        s = Magic2;
     } else {
        s = Magic3;
     }
  }

  SHA1_Init(&Context);
  SHA1_Update(&Context, MasterKey, 16);
  SHA1_Update(&Context, SHA1_Pad1, 40);
  SHA1_Update(&Context, s, 84);
  SHA1_Update(&Context, SHA1_Pad2, 40);
  SHA1_Final(Digest, &Context);

  memcpy(SessionKey, Digest, SessionKeyLength);
d315 2
a316 2
GetNewKeyFromSHA(char *StartKey, char *SessionKey, long SessionKeyLength,
                 char *InterimKey)
d318 5
a322 2
  SHA_CTX Context;
  char Digest[SHA_DIGEST_LENGTH];
d324 2
a325 6
  SHA1_Init(&Context);
  SHA1_Update(&Context, StartKey, SessionKeyLength);
  SHA1_Update(&Context, SHA1_Pad1, 40);
  SHA1_Update(&Context, SessionKey, SessionKeyLength);
  SHA1_Update(&Context, SHA1_Pad2, 40);
  SHA1_Final(Digest, &Context);
d327 8
a334 1
  memcpy(InterimKey, Digest, SessionKeyLength);
d337 3
a339 4
#if 0
static void
Get_Key(char *InitialSessionKey, char *CurrentSessionKey,
        int LengthOfDesiredKey)
d341 3
a343 2
  SHA_CTX Context;
  char Digest[SHA_DIGEST_LENGTH];
d345 6
a350 6
  SHA1_Init(&Context);
  SHA1_Update(&Context, InitialSessionKey, LengthOfDesiredKey);
  SHA1_Update(&Context, SHA1_Pad1, 40);
  SHA1_Update(&Context, CurrentSessionKey, LengthOfDesiredKey);
  SHA1_Update(&Context, SHA1_Pad2, 40);
  SHA1_Final(Digest, &Context);
d352 1
a352 1
  memcpy(CurrentSessionKey, Digest, LengthOfDesiredKey);
a353 1
#endif
a354 3
/* passwordHash 16-bytes MD4 hashed password
   challenge    8-bytes peer CHAP challenge
   since passwordHash is in a 24-byte buffer, response is written in there */
d356 1
a356 1
mschap_NT(char *passwordHash, char *challenge)
d358 1
a358 1
    u_char response[24];
d360 3
a362 3
    ChallengeResponse(challenge, passwordHash, response);
    memcpy(passwordHash, response, 24);
    passwordHash[24] = 1;		/* NT-style response */
d366 1
a366 1
mschap_LANMan(char *digest, char *challenge, char *secret)
d368 3
a370 3
  static u_char salt[] = "KGS!@@#$%";	/* RASAPI32.dll */
  char SECRET[14], *ptr, *end;
  u_char hash[16];
d372 5
a376 5
  end = SECRET + sizeof SECRET;
  for (ptr = SECRET; *secret && ptr < end; ptr++, secret++)
    *ptr = toupper((unsigned char)*secret);
  if (ptr < end)
    memset(ptr, '\0', end - ptr);
d378 2
a379 2
  DesEncrypt(salt, SECRET, hash);
  DesEncrypt(salt, SECRET + 7, hash + 8);
d381 1
a381 1
  ChallengeResponse(challenge, hash, digest);
d385 2
a386 2
DecryptKeyFromRadius(char* plain, const char* crypted,
                     const char *authenticator, const char *secret)
d388 3
a390 4
  char b[16];
  char p[32];
  MD5_CTX ctx;
  int i;
d392 5
a396 5
  MD5Init(&ctx);
  MD5Update(&ctx, secret, strlen(secret));
  MD5Update(&ctx, authenticator, 16);
  MD5Update(&ctx, crypted, 2);
  MD5Final(b, &ctx);
d398 3
a400 3
  for(i=0;i<16;i++) {
    p[i] = b[i] ^ crypted[i+2];
  }
d402 4
a405 4
  MD5Init(&ctx);
  MD5Update(&ctx, secret, strlen(secret));
  MD5Update(&ctx, crypted+2, 16);
  MD5Final(b, &ctx);
d407 3
a409 3
  for(i=0;i<16;i++) {
    p[i+16] = b[i] ^ crypted[i+18];
  }
d411 1
a411 1
  memcpy(plain, p+1, 16);
@


1.2
log
@cleanup npppd code.  delete IIJ local ifdef switches and fix warnings.
ok @@dlg
@
text
@d1 2
d150 1
a150 1
{ 
d160 1
a160 1
{ 
d177 1
a177 1
  if(NULL == Name) 
d184 1
a184 1
  SHA1_Update(&Context, PeerChallenge, 16); 
d273 1
a273 1
  ChallengeHash(PeerChallenge, AuthenticatorChallenge, UserName, UserNameLen, 
d294 1
a294 1
 
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@a62 12
#if (OPENSSL_VERSION_NUMBER - 0 >= 0x00907000)
/*
 * 0.9.7
 */
#define	des_key_schedule 	DES_key_schedule
#define	des_set_odd_parity	DES_set_odd_parity
#define	des_set_key		DES_set_key
#define	des_ecb_encrypt		DES_ecb_encrypt
#define	des_cblock 		DES_cblock
#define	des_set_key 		DES_set_key
#define	des_ebc_encrypt 	DES_ebc_encrypt
#endif
d118 1
a118 1
    des_set_odd_parity((des_cblock *)des_key);
d129 2
a130 7
#if (OPENSSL_VERSION_NUMBER - 0 >= 0x00907000)
    des_set_key(&des_key, &key_schedule);
    des_ecb_encrypt((des_cblock *)clear, (des_cblock *)cipher, &key_schedule, 1);
#else
    des_set_key(&des_key, key_schedule);
    des_ecb_encrypt((des_cblock *)clear, (des_cblock *)cipher, key_schedule, 1);
#endif
@

