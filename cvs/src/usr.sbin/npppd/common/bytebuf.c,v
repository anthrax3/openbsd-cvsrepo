head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.10
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.05.18.43.36;	author mmcc;	state Exp;
branches;
next	1.7;
commitid	z4uV9iYMuGOvIKaj;

1.7
date	2015.01.19.01.48.59;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	a1BWBASyBgKKetQd;

1.6
date	2014.05.30.05.06.00;	author yasuoka;	state Exp;
branches;
next	1.5;

1.5
date	2012.05.08.13.15.11;	author yasuoka;	state Exp;
branches;
next	1.4;

1.4
date	2012.02.24.06.19.00;	author guenther;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.02.21.20.57;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.01.03.38.17;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.11.04.20.57;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.8
log
@strings.h -> string.h to prevent an implicit declaration. Also remove a
bunch of NULL-checks before free().
@
text
@/*	$OpenBSD: bytebuf.c,v 1.7 2015/01/19 01:48:59 deraadt Exp $ */
/*-
 * Copyright (c) 2009 Internet Initiative Japan Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/**@@file
 * bytebuffer provides 'byte buffer' helper methods.
 *
 * Example:<pre>
 *	bytebuffer *buf = bytebuffer_create(BUFSIZ);
 *	int sz = read(STDIN_FILENO, bytebuffer_pointer(buf),
 *	    bytebuffer_remaining(buf));
 *	if (sz > 0) {
 *	    bytebuffer_put(buf, BYTEBUFFER_PUT_DIRECT, sz);
 *	    bytebuffer_flip(buf);
 *
 *	    sz = write(STDOUT_FILENO, bytebuffer_pointer(buf),
 *		bytebuffer_remaining(buf));
 *	    bytebuffer_compact(buf);
 *	}</pre>
 *
 * @@author Yasuoka Masahiko
 * $Id: bytebuf.c,v 1.7 2015/01/19 01:48:59 deraadt Exp $
 */
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#ifdef	BYTEBUF_DEBUG
#include <stdio.h>
#endif

#ifndef	BYTEBUF_ASSERT
#ifdef	BYTEBUF_DEBUG
#define	BYTEBUF_ASSERT(cond)						\
	if (!(cond)) {						\
	    fprintf(stderr,					\
		"\nASSERT(" #cond ") failed on %s() at %s:%d.\n"\
		, __func__, __FILE__, __LINE__);		\
	    abort(); 						\
	}
#else
#define	BYTEBUF_ASSERT(cond)
#endif
#endif

#include "bytebuf.h"

struct _bytebuffer {
	/** current position */
	int 	position;
	/** current limit */
	int	limit;
	/** position mark*/
	int 	mark;
	/** capacity of buffer */
	size_t 	capacity;
	/** allocated memory area */
	void	*data;
};

/**
 * Create a bytebuffer and allocate memory area.
 *
 * @@param	capacity	Capacity of allocating memory.  If zero or
 *		    negative value is specified, this function don't allocate
 *		    memory.
 */
bytebuffer *
bytebuffer_create(size_t capacity)
{
	bytebuffer *_this = NULL;

	if ((_this = calloc(1, sizeof(bytebuffer))) == NULL)
		return NULL;

	if (capacity > 0) {
		if ((_this->data = calloc(1, capacity)) == NULL)
			goto fail;
		_this->capacity = capacity;
	} else
		_this->capacity = 0;

	_this->limit = _this->capacity;
	_this->mark = -1;
	return _this;
fail:
	free(_this);
	return NULL;
}

/**
 * Create a bytebuffer using existing memory area.  This memory area will
 * be freed by bytebuffer's destructor.
 *
 * @@data		the pointer to existing memory area
 * @@param capacity	capacity of 'data'.
 */
bytebuffer *
bytebuffer_wrap(void *data, size_t capacity)
{
	bytebuffer *_this;

	if ((_this = bytebuffer_create(0)) == NULL)
		return NULL;

	_this->data = data;
	_this->capacity = capacity;
	_this->mark = -1;

	return _this;
}

/**
 * Unwrap memory from bytebuffer.
 *
 * @@param _this		the bytebuffer object.
 */
void *
bytebuffer_unwrap(bytebuffer *_this)
{
	void *rval;

	rval = _this->data;
	_this->data = NULL;
	_this->capacity = 0;
	_this->position = 0;
	_this->limit = 0;
	_this->mark = -1;

	return rval;
}

/**
 * Change capacity of this buffer.
 *
 * @@param _this		the bytebuffer object.
 * @@param capacity	new capacity.
 */
int
bytebuffer_realloc(bytebuffer *_this, size_t capacity)
{
	void *new_data;

	BYTEBUF_ASSERT(_this->limit <= capacity);

	if (_this->limit > capacity) {
		errno = EINVAL;
		return -1;
	}

	if ((new_data = realloc(_this->data, capacity)) == NULL)
		return -1;

	_this->data = new_data;
	if (_this->limit == _this->capacity)
		_this->limit = capacity;
	_this->capacity = capacity;

	return 0;
}

/**
 * Compact this buffer.  the bytes between position and limit are copied
 * to the beginning of the buffer.
 *
 * @@param _this		the bytebuffer object.
 */
void
bytebuffer_compact(bytebuffer *_this)
{
	int len;

	len = bytebuffer_remaining(_this);

	if (len <= 0)
		len = 0;
	else if (_this->position != 0)
		memmove(_this->data,
		    (const char *)_this->data + _this->position, (size_t)len);

	_this->position = len;
	_this->limit = _this->capacity;
	_this->mark = -1;
}

static int bytebuffer_direct0;
/**
 * BYTEBUFFER_PUT_DIRECT specifies the data that has been written already by
 * direct access.
 */
const void * BYTEBUFFER_PUT_DIRECT = &bytebuffer_direct0;

/**
 * BYTEBUFFER_GET_DIRECT specifies the data that has been read already by
 * direct access.
 */
void * BYTEBUFFER_GET_DIRECT = &bytebuffer_direct0;

/**
 * Write the given data to the buffer.
 * If buffer is too small, this function returns <code>NULL</code> and
 * <code>errno</code> is <code>ENOBUFS</code>
 *
 * @@param _this		the bytebuffer object.
 * @@param src		source data.  To specify the data that has been
 *			written already by direct access, use
 *			{@@link ::BYTEBUFFER_PUT_DIRECT} for putting the data.
 *			NULL is the same {@@link ::BYTEBUFFER_PUT_DIRECT}
 *			at least on this version, but using NULL is deprecated.
 * @@param srclen	length of the source data.
 * @@see ::BYTEBUFFER_PUT_DIRECT
 */
void *
bytebuffer_put(bytebuffer *_this, const void *src, size_t srclen)
{
	void *rval;

	BYTEBUF_ASSERT(_this != NULL);
	BYTEBUF_ASSERT(srclen > 0);

	if (srclen > bytebuffer_remaining(_this)) {
		errno = ENOBUFS;
		return NULL;
	}
	rval = (char *)_this->data + _this->position;

	if (src != NULL && src != BYTEBUFFER_PUT_DIRECT)
		memcpy(rval, src, srclen);

	_this->position += srclen;

	return rval;
}

/*
 * Transfer data from this buffer to the given destination memory.
 * If the given buffer is too small, this function returns <code>NULL</code>
 * and <code>errno</code> is <code>ENOBUFS</code>
 *
 * @@param	dst	pointer of the destination memory.  Specify NULL
 *			to skip transferring the data.
 * @@param	dstlne	memory size of the destination.
 */
void *
bytebuffer_get(bytebuffer *_this, void *dst, size_t dstlen)
{
	BYTEBUF_ASSERT(_this != NULL);
	BYTEBUF_ASSERT(dstlen > 0);

	if (dstlen > bytebuffer_remaining(_this)) {
		errno = ENOBUFS;
		return NULL;
	}
	if (dst != NULL && dst != BYTEBUFFER_GET_DIRECT)
		memcpy(dst, (char *)_this->data + _this->position, dstlen);

	_this->position += dstlen;

	return dst;
}

/** Returns this buffer's position */
int
bytebuffer_position(bytebuffer *_this)
{
	BYTEBUF_ASSERT(_this != NULL);

	return _this->position;
}

/** Returns this buffer's limit */
int
bytebuffer_limit(bytebuffer *_this)
{
	BYTEBUF_ASSERT(_this != NULL);

	return _this->limit;
}

/** Returns this buffer's capacity */
int
bytebuffer_capacity(bytebuffer *_this)
{
	BYTEBUF_ASSERT(_this != NULL);

	return _this->capacity;
}

/** Returns a pointer to current position */
void *
bytebuffer_pointer(bytebuffer *_this)
{
	BYTEBUF_ASSERT(_this != NULL);

	return (char *)_this->data + _this->position;
}

/** Returns the number of byte between current position and the limit*/
size_t
bytebuffer_remaining(bytebuffer *_this)
{
	BYTEBUF_ASSERT(_this != NULL);
	BYTEBUF_ASSERT(_this->limit >= _this->position);

	return _this->limit - _this->position;
}

/** Returns whether there are data between current position and the limit */
int
bytebuffer_has_remaining(bytebuffer *_this)
{
	BYTEBUF_ASSERT(_this != NULL);

	return bytebuffer_remaining(_this) > 0;
}

/**
 * Flip this buffer.
 * The limit is set to the position and the position is set zero.
 */
void
bytebuffer_flip(bytebuffer *_this)
{
	BYTEBUF_ASSERT(_this != NULL);

	_this->limit = _this->position;
	_this->position = 0;
	_this->mark = -1;
}

/**
 * Rewind this buffer.
 * The position is set to zero.
 */
void
bytebuffer_rewind(bytebuffer *_this)
{
	BYTEBUF_ASSERT(_this != NULL);

	_this->position = 0;
	_this->mark = -1;
}

/**
 * Clear this buffer.
 * The position is set to zero.
 */
void
bytebuffer_clear(bytebuffer *_this)
{
	BYTEBUF_ASSERT(_this != NULL);

	_this->limit = _this->capacity;
	_this->position = 0;
	_this->mark = -1;
}

/** mark the current position.  */
void
bytebuffer_mark(bytebuffer *_this)
{
	BYTEBUF_ASSERT(_this != NULL);

	_this->mark = _this->position;
}

/** reset the position to the mark.  */
void
bytebuffer_reset(bytebuffer *_this)
{
	BYTEBUF_ASSERT(_this != NULL);
	BYTEBUF_ASSERT(_this->mark >= 0);

	if (_this->mark >= 0)
		_this->position = _this->mark;
}

/**
 * Destroy bytebuffer object.
 */
void
bytebuffer_destroy(bytebuffer *_this)
{
	BYTEBUF_ASSERT(_this != NULL);

	if (_this != NULL) {
		free(_this->data);
		free(_this);
	}
}
@


1.7
log
@move to <limits.h> universe
ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: bytebuf.c,v 1.6 2014/05/30 05:06:00 yasuoka Exp $ */
d44 1
a44 1
 * $Id: bytebuf.c,v 1.6 2014/05/30 05:06:00 yasuoka Exp $
d109 1
a109 2
	if (_this != NULL)
		free(_this);
d409 1
a409 2
		if (_this->data != NULL)
			free(_this->data);
@


1.6
log
@Use calloc instead of malloc and memset.

from Benjamin Baier
@
text
@d1 1
a1 1
/*	$OpenBSD: bytebuf.c,v 1.5 2012/05/08 13:15:11 yasuoka Exp $ */
d44 1
a44 1
 * $Id: bytebuf.c,v 1.5 2012/05/08 13:15:11 yasuoka Exp $
a81 4

#ifndef	MIN
#define	MIN(m,n)	((m) < (n)? (m) : (n))
#endif
@


1.5
log
@Fix comments and styles.  Delete unused variables and labels.
No binary changes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bytebuf.c,v 1.4 2012/02/24 06:19:00 guenther Exp $ */
d44 1
a44 1
 * $Id: bytebuf.c,v 1.4 2012/02/24 06:19:00 guenther Exp $
d99 1
a99 1
	if ((_this = malloc(sizeof(bytebuffer))) == NULL)
a101 2
	memset(_this, 0, sizeof(bytebuffer));

d103 1
a103 1
		if ((_this->data = malloc(capacity)) == NULL)
a104 1
		memset(_this->data, 0, capacity);
@


1.4
log
@Correct the spelling of "transferred" and "transferring"

from Tobias Ulmer (tobiasu at tmux.org); ok jmc@@, krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: bytebuf.c,v 1.3 2010/07/02 21:20:57 yasuoka Exp $ */
d44 1
a44 1
 * $Id: bytebuf.c,v 1.3 2010/07/02 21:20:57 yasuoka Exp $
@


1.3
log
@add $OpenBSD$ and remove trailing space.  no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: bytebuf.c,v 1.2 2010/07/01 03:38:17 yasuoka Exp $ */
d44 1
a44 1
 * $Id: bytebuf.c,v 1.2 2010/07/01 03:38:17 yasuoka Exp $
d271 1
a271 1
 *			to skip transfering the data.
@


1.2
log
@Translate Japanese comments or labels into English.  Translation was
done by IIJ people (MATSUI Yoshihiro, SAITOH Masanobu, Tomoyuki Sahara),
yuo@@ and myself.

This diff also includes
 - delete part of useless comments, correct spelling.
 - add man page of npppdctl.

There is no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d44 1
a44 1
 * $Id: bytebuf.c,v 1.1 2010/01/11 04:20:57 yasuoka Exp $
d64 1
a64 1
#define	BYTEBUF_ASSERT(cond)			
d85 1
a85 1
#endif	
d118 1
a118 1
	return NULL;	
d178 1
a178 1
		return -1;	
d180 1
a180 1
	
d259 1
a259 1
	
d267 1
a267 1
 * If the given buffer is too small, this function returns <code>NULL</code> 
d286 1
a286 1
	
d347 1
a347 1
/** 
d361 1
a361 1
/** 
d374 1
a374 1
/** 
@


1.1
log
@Initial import npppd(8).  npppd is a new PPP daemon that handles many
ppp sessions as a server.  It supports L2TP, PPTP and PPPoE as
tunneling.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d1 1
d44 1
a44 1
 * $Id: bytebuf.c 35638 2009-03-08 03:41:38Z yasuoka $
d106 1
a106 1
			goto reigai;
d115 1
a115 1
reigai:
@

