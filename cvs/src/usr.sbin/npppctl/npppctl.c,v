head	1.8;
access;
symbols
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.1.0.12
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.8
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.6
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.4
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.2;
locks; strict;
comment	@ * @;


1.8
date	2017.08.11.16.25.59;	author goda;	state Exp;
branches;
next	1.7;
commitid	NP2pVV4OeubFMchy;

1.7
date	2017.01.21.11.32.04;	author guenther;	state Exp;
branches;
next	1.6;
commitid	DpBZlpar7mq0CJFq;

1.6
date	2015.12.05.13.19.32;	author claudio;	state Exp;
branches;
next	1.5;
commitid	WQNWqOCspN7oDvQw;

1.5
date	2015.01.19.01.48.57;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	a1BWBASyBgKKetQd;

1.4
date	2014.07.22.02.02.59;	author yasuoka;	state Exp;
branches;
next	1.3;
commitid	XnHzXnzXEna3zggJ;

1.3
date	2014.04.03.07.10.18;	author yasuoka;	state Exp;
branches;
next	1.2;

1.2
date	2014.03.22.04.30.31;	author yasuoka;	state Exp;
branches;
next	1.1;

1.1
date	2012.01.18.03.13.04;	author yasuoka;	state Exp;
branches;
next	;


desc
@@


1.8
log
@display MRU each sessions in npppctl session command

ok yasuoka@@
@
text
@/*	$OpenBSD: npppctl.c,v 1.7 2017/01/21 11:32:04 guenther Exp $	*/

/*
 * Copyright (c) 2012 Internet Initiative Japan Inc.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/uio.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <errno.h>
#include <netdb.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <imsg.h>

#include <unistd.h>
#include <err.h>

#include "parser.h"
#include "npppd_ctl.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

#ifndef nitems
#define nitems(_x)	(sizeof(_x) / sizeof(_x[0]))
#endif

#define	NMAX_DISCONNECT		2048

static void         usage (void);
static void         show_clear_session (struct parse_result *, FILE *);
static void         monitor_session (struct parse_result *, FILE *);
static void         clear_session (u_int[], int, int, FILE *);
static void         fprint_who_brief (int, struct npppd_who *, FILE *);
static void         fprint_who_packets (int, struct npppd_who *, FILE *);
static void         fprint_who_all (int, struct npppd_who *, FILE *);
static const char  *peerstr (struct sockaddr *, char *, int);
static const char  *humanize_duration (uint32_t, char *, int);
static const char  *humanize_bytes (double, char *, int);
static bool         filter_match(struct parse_result *, struct npppd_who *);
static int          imsg_wait_command_completion (void);

static int             nflag = 0;
static struct imsgbuf  ctl_ibuf;
static struct imsg     ctl_imsg;

static void
usage(void)
{
	extern char		*__progname;

	fprintf(stderr,
	    "usage: %s [-n] [-s socket] command [arg ...]\n", __progname);
}

int
main(int argc, char *argv[])
{
	int			 ch, ctlsock = -1;
	struct parse_result	*result;
	struct sockaddr_un	 sun;
	const char		*npppd_ctlpath = NPPPD_SOCKET;
	extern int		 optind;
	extern char		*optarg;

	while ((ch = getopt(argc, argv, "ns:")) != -1)
		switch (ch) {
		case 'n':
			nflag = 1;
			break;
		case 's':
			npppd_ctlpath = optarg;
			break;
		default:
			usage();
			exit(EXIT_FAILURE);
		}

	argc -= optind;
	argv += optind;

	if ((result = parse(argc, argv)) == NULL)
		exit(EXIT_FAILURE);

	if ((ctlsock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
		err(EXIT_FAILURE, "socket");
	memset(&sun, 0, sizeof(sun));
	sun.sun_family = AF_UNIX;
	strlcpy(sun.sun_path, npppd_ctlpath, sizeof(sun.sun_path));
	if (connect(ctlsock, (struct sockaddr *)&sun, sizeof(sun)) < 0)
		err(EXIT_FAILURE, "connect");

	imsg_init(&ctl_ibuf, ctlsock);

	switch (result->action) {
	case SESSION_BRIEF:
	case SESSION_PKTS:
	case SESSION_ALL:
		show_clear_session(result, stdout);
		break;
	case CLEAR_SESSION:
		if (!result->has_ppp_id)
			show_clear_session(result, stdout);
		else {
			u_int ids[1];
			ids[0] = result->ppp_id;
			clear_session(ids, 1, 1, stdout);
		}
		break;
	case MONITOR_SESSION:
		monitor_session(result, stdout);
		break;
	case NONE:
		break;
	}

	exit(EXIT_SUCCESS);
}

static void
show_clear_session(struct parse_result *result, FILE *out)
{
	int                    i, n, ppp_id_idx;
	struct npppd_who_list *res;
	u_int                  ppp_id[NMAX_DISCONNECT];

	if (imsg_compose(&ctl_ibuf, IMSG_CTL_WHO, 0, 0, -1, NULL, 0) == -1)
		err(EXIT_FAILURE, "failed to componse a message\n");
	if (imsg_wait_command_completion() < 0)
		errx(EXIT_FAILURE, "failed to get response");
	if (ctl_imsg.hdr.type != IMSG_CTL_OK)
		errx(EXIT_FAILURE, "command was fail");
	n = ppp_id_idx = 0;
	while (imsg_wait_command_completion() == IMSG_PPP_START) {
		res = (struct npppd_who_list *)ctl_imsg.data;
		if (ctl_imsg.hdr.len - IMSG_HEADER_SIZE <
		    offsetof(struct npppd_who_list,
			    entry[res->entry_count])) {
			errx(1, "response size %d is too small for "
			    "the entry count %d",
			    (int)(ctl_imsg.hdr.len - IMSG_HEADER_SIZE),
			    res->entry_count);
		}
		for (i = 0; i < res->entry_count; i++, n++) {
			switch (result->action) {
			case SESSION_BRIEF:
				fprint_who_brief(n, &res->entry[i], out);
				break;
			case SESSION_PKTS:
				fprint_who_packets(n, &res->entry[i], out);
				break;
			case SESSION_ALL:
				if (filter_match(result, &res->entry[i]))
					fprint_who_all(n, &res->entry[i], out);
				break;
			case CLEAR_SESSION:
				if (filter_match(result, &res->entry[i])) {
					if (ppp_id_idx < nitems(ppp_id))
						ppp_id[ppp_id_idx] =
						    res->entry[i].ppp_id;
					ppp_id_idx++;
				}
				break;
			default:
				warnx("must not reached here");
				abort();
			}
		}
		if (!res->more_data)
			break;
	}
	if (result->action == CLEAR_SESSION) {
		if (ppp_id_idx > nitems(ppp_id))
			warnx(
			    "Disconnection for %d sessions has been requested, "
			    "but cannot disconnect only %d sessions because of "
			    "the implementation limit.",
			    ppp_id_idx, (int)nitems(ppp_id));
		clear_session(ppp_id, MINIMUM(ppp_id_idx, nitems(ppp_id)),
			ppp_id_idx, out);
	}
}

const char *bar =
"------------------------------------------------------------------------\n";
static void
monitor_session(struct parse_result *result, FILE *out)
{
	int                    i, n;
	struct npppd_who_list *res;

	if (imsg_compose(&ctl_ibuf, IMSG_CTL_MONITOR, 0, 0, -1, NULL, 0) == -1)
		err(EXIT_FAILURE, "failed to compose a message");
	if (imsg_wait_command_completion() < 0)
		errx(EXIT_FAILURE, "failed to get response");
	if (ctl_imsg.hdr.type != IMSG_CTL_OK)
		errx(EXIT_FAILURE, "command was fail");
	do {
		if (imsg_wait_command_completion() < 0)
			break;
		n = 0;
		if (ctl_imsg.hdr.type == IMSG_PPP_START ||
		    ctl_imsg.hdr.type == IMSG_PPP_STOP) {
			res = (struct npppd_who_list *)ctl_imsg.data;
			for (i = 0; i < res->entry_count; i++) {
				if (!filter_match(result, &res->entry[i]))
					continue;
				if (n == 0)
					fprintf(out, "PPP %s\n%s",
					    (ctl_imsg.hdr.type ==
						    IMSG_PPP_START)
						    ? "Started"
						    : "Stopped", bar);
				fprint_who_all(n++, &res->entry[i], out);
			}
			if (n > 0)
				fputs(bar, out);
		} else {
			warnx("received unknown message type = %d",
			    ctl_imsg.hdr.type);
			break;
		}
	} while (true);

	return;
}

static void
fprint_who_brief(int i, struct npppd_who *w, FILE *out)
{
	char buf[BUFSIZ];

	if (i == 0)
		fputs(
"Ppp Id     Assigned IPv4   Username             Proto Tunnel From\n"
"---------- --------------- -------------------- ----- ------------------------"
"-\n",
		    out);
	fprintf(out, "%10u %-15s %-20s %-5s %s\n", w->ppp_id,
	    inet_ntoa(w->framed_ip_address), w->username, w->tunnel_proto,
	    peerstr((struct sockaddr *)&w->tunnel_peer, buf, sizeof(buf)));
}

static void
fprint_who_packets(int i, struct npppd_who *w, FILE *out)
{
	if (i == 0)
		fputs(
"Ppd Id     Username             In(Kbytes/pkts/errs)    Out(Kbytes/pkts/errs)"
"\n"
"---------- -------------------- ----------------------- ----------------------"
"-\n",
		    out);
	fprintf(out, "%10u %-20s %9.1f %7u %5u %9.1f %7u %5u\n", w->ppp_id,
	    w->username,
	    (double)w->ibytes/1024, w->ipackets, w->ierrors,
	    (double)w->obytes/1024, w->opackets, w->oerrors);
}

static void
fprint_who_all(int i, struct npppd_who *w, FILE *out)
{
	struct tm  tm;
	char       ibytes_buf[48], obytes_buf[48], peer_buf[48], time_buf[48];
	char       dur_buf[48];

	localtime_r(&w->time, &tm);
	strftime(time_buf, sizeof(time_buf), "%Y/%m/%d %T", &tm);
	if (i != 0)
		fputs("\n", out);

	fprintf(out,
	    "Ppp Id = %u\n"
	    "          Ppp Id                  : %u\n"
	    "          Username                : %s\n"
	    "          Realm Name              : %s\n"
	    "          Concentrated Interface  : %s\n"
	    "          Assigned IPv4 Address   : %s\n"
	    "          MRU                     : %u\n"
	    "          Tunnel Protocol         : %s\n"
	    "          Tunnel From             : %s\n"
	    "          Start Time              : %s\n"
	    "          Elapsed Time            : %lu sec %s\n"
	    "          Input Bytes             : %llu%s\n"
	    "          Input Packets           : %lu\n"
	    "          Input Errors            : %lu (%.1f%%)\n"
	    "          Output Bytes            : %llu%s\n"
	    "          Output Packets          : %lu\n"
	    "          Output Errors           : %lu (%.1f%%)\n",
	    w->ppp_id, w->ppp_id, w->username, w->rlmname, w->ifname,
	    inet_ntoa(w->framed_ip_address), (u_int)w->mru, w->tunnel_proto,
	    peerstr((struct sockaddr *)&w->tunnel_peer, peer_buf,
		sizeof(peer_buf)), time_buf,
	    (unsigned long)w->duration_sec,
	    humanize_duration(w->duration_sec, dur_buf, sizeof(dur_buf)),
	    (unsigned long long)w->ibytes,
	    humanize_bytes((double)w->ibytes, ibytes_buf, sizeof(ibytes_buf)),
	    (unsigned long)w->ipackets,
	    (unsigned long)w->ierrors,
	    ((w->ipackets + w->ierrors) <= 0)
		? 0.0 : (100.0 * w->ierrors) / (w->ierrors + w->ipackets),
	    (unsigned long long)w->obytes,
	    humanize_bytes((double)w->obytes, obytes_buf, sizeof(obytes_buf)),
	    (unsigned long)w->opackets,
	    (unsigned long)w->oerrors,
	    ((w->opackets + w->oerrors) <= 0)
		? 0.0 : (100.0 * w->oerrors) / (w->oerrors + w->opackets));
}

/***********************************************************************
 * clear session
 ***********************************************************************/
static void
clear_session(u_int ppp_id[], int ppp_id_count, int total, FILE *out)
{
	int                               succ, fail, i, n, nmax;
	struct iovec                      iov[2];
	struct npppd_disconnect_request   req;
	struct npppd_disconnect_response *res;

	succ = fail = 0;
	if (ppp_id_count > 0) {
		nmax = (MAX_IMSGSIZE - IMSG_HEADER_SIZE -
		    offsetof(struct npppd_disconnect_request, ppp_id[0])) /
		    sizeof(u_int);
		for (i = 0; i < ppp_id_count; i += n) {
			n = MINIMUM(nmax, ppp_id_count - i);
			req.count = n;
			iov[0].iov_base = &req;
			iov[0].iov_len = offsetof(
			    struct npppd_disconnect_request, ppp_id[0]);
			iov[1].iov_base = &ppp_id[i];
			iov[1].iov_len = sizeof(u_int) * n;

			if (imsg_composev(&ctl_ibuf, IMSG_CTL_DISCONNECT, 0, 0,
			    -1, iov, 2) == -1)
				err(EXIT_FAILURE,
				    "Failed to compose a message");
			if (imsg_wait_command_completion() < 0)
				errx(EXIT_FAILURE, "failed to get response");
			if (ctl_imsg.hdr.type != IMSG_CTL_OK)
				errx(EXIT_FAILURE,
				    "Command was fail: msg type = %d",
				    ctl_imsg.hdr.type);
			if (ctl_imsg.hdr.len - IMSG_HEADER_SIZE <
			    sizeof(struct npppd_disconnect_response))
				err(EXIT_FAILURE, "response is corrupted");
			res = (struct npppd_disconnect_response *)ctl_imsg.data;
			succ += res->count;
		}
		fail = total - succ;
	}
	if (succ > 0)
		fprintf(out, "Successfully disconnected %d session%s.\n",
		    succ, (succ > 1)? "s" : "");
	if (fail > 0)
		fprintf(out, "Failed to disconnect %d session%s.\n",
		    fail, (fail > 1)? "s" : "");
	if (succ == 0 && fail == 0)
		fprintf(out, "No session to disconnect.\n");
}

/***********************************************************************
 * common functions
 ***********************************************************************/
static bool
filter_match(struct parse_result *result, struct npppd_who *who)
{
	if (result->has_ppp_id && result->ppp_id != who->ppp_id)
		return (false);

	switch (result->address.ss_family) {
	case AF_INET:
		if (((struct sockaddr_in *)&result->address)->sin_addr.
		    s_addr != who->framed_ip_address.s_addr)
			return (false);
		break;
	case AF_INET6:
		/* npppd doesn't support IPv6 yet */
		return (false);
	}

	if (result->interface != NULL &&
	    strcmp(result->interface, who->ifname) != 0)
		return (false);

	if (result->protocol != PROTO_UNSPEC &&
	    result->protocol != parse_protocol(who->tunnel_proto) )
		return (false);

	if (result->realm != NULL && strcmp(result->realm, who->rlmname) != 0)
		return (false);

	if (result->username != NULL &&
	    strcmp(result->username, who->username) != 0)
		return (false);

	return (true);
}

static const char *
peerstr(struct sockaddr *sa, char *buf, int lbuf)
{
	int   niflags, hasserv;
	char  hoststr[NI_MAXHOST], servstr[NI_MAXSERV];

	niflags = hasserv = 0;
	if (nflag)
		niflags |= NI_NUMERICHOST;
	if (sa->sa_family == AF_INET || sa->sa_family ==AF_INET6) {
		hasserv = 1;
		niflags |= NI_NUMERICSERV;
	}

	if (sa->sa_family == AF_LINK)
		snprintf(hoststr, sizeof(hoststr),
		    "%02x:%02x:%02x:%02x:%02x:%02x",
		    LLADDR((struct sockaddr_dl *)sa)[0] & 0xff,
		    LLADDR((struct sockaddr_dl *)sa)[1] & 0xff,
		    LLADDR((struct sockaddr_dl *)sa)[2] & 0xff,
		    LLADDR((struct sockaddr_dl *)sa)[3] & 0xff,
		    LLADDR((struct sockaddr_dl *)sa)[4] & 0xff,
		    LLADDR((struct sockaddr_dl *)sa)[5] & 0xff);
	else
		getnameinfo(sa, sa->sa_len, hoststr, sizeof(hoststr), servstr,
		    sizeof(servstr), niflags);

	strlcpy(buf, hoststr, lbuf);
	if (hasserv) {
		strlcat(buf, ":", lbuf);
		strlcat(buf, servstr, lbuf);
	}

	return (buf);
}

static const char *
humanize_duration(uint32_t sec, char *buf, int lbuf)
{
	char  fbuf[128];
	int   hour, min;

	hour = sec / (60 * 60);
	min = sec / 60;
	min %= 60;

	if (lbuf <= 0)
		return (buf);
	buf[0] = '\0';
	if (hour || min) {
		strlcat(buf, "(", lbuf);
		if (hour) {
			snprintf(fbuf, sizeof(fbuf),
			    "%d hour%s", hour, (hour > 1)? "s" : "");
			strlcat(buf, fbuf, lbuf);
		}
		if (hour && min)
			strlcat(buf, " and ", lbuf);
		if (min) {
			snprintf(fbuf, sizeof(fbuf),
			    "%d minute%s", min, (min > 1)? "s" : "");
			strlcat(buf, fbuf, lbuf);
		}
		strlcat(buf, ")", lbuf);
	}

	return (buf);
}

static const char *
humanize_bytes(double val, char *buf, int lbuf)
{
	if (lbuf <= 0)
		return (buf);

	if (val >= 1000 * 1024 * 1024)
		snprintf(buf, lbuf, " (%.1f GB)",
		    (double)val / (1024 * 1024 * 1024));
	else if (val >= 1000 * 1024)
		snprintf(buf, lbuf, " (%.1f MB)", (double)val / (1024 * 1024));
	else if (val >= 1000)
		snprintf(buf, lbuf, " (%.1f KB)", (double)val / 1024);
	else
		buf[0] = '\0';

	return (buf);
}

static int
imsg_wait_command_completion(void)
{
	int  n;

	while (ctl_ibuf.w.queued)
		if (msgbuf_write(&ctl_ibuf.w) <= 0 && errno != EAGAIN)
			return (-1);
	do {
		if ((n = imsg_get(&ctl_ibuf, &ctl_imsg)) == -1)
			return (-1);
		if (n != 0)
			break;
		if (((n = imsg_read(&ctl_ibuf)) == -1 && errno != EAGAIN) ||
		    n == 0)
			return (-1);
	} while (1);

	return (ctl_imsg.hdr.type);
}
@


1.7
log
@The POSIX APIs that that sockaddrs all ignore the s*_len field in the
incoming socket, so userspace doesn't need to set it unless it has its
own reasons for tracking the size along with the sockaddr.

ok phessler@@ deraadt@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npppctl.c,v 1.6 2015/12/05 13:19:32 claudio Exp $	*/
d299 1
d311 1
a311 1
	    inet_ntoa(w->framed_ip_address), w->tunnel_proto,
@


1.6
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npppctl.c,v 1.5 2015/01/19 01:48:57 deraadt Exp $	*/
a108 1
	sun.sun_len = sizeof(sun);
@


1.5
log
@move to <limits.h> universe
ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: npppctl.c,v 1.4 2014/07/22 02:02:59 yasuoka Exp $	*/
d522 2
a523 1
		if ((n = imsg_read(&ctl_ibuf)) == -1 || n == 0)
@


1.4
log
@Handle msgbuf_write() returning EAGAIN.

from krw
@
text
@d1 1
a1 1
/*	$OpenBSD: npppctl.c,v 1.3 2014/04/03 07:10:18 yasuoka Exp $	*/
a17 1
#include <sys/param.h>
d42 2
d200 1
a200 1
		clear_session(ppp_id, MIN(ppp_id_idx, nitems(ppp_id)),
d347 1
a347 1
			n = MIN(nmax, ppp_id_count - i);
@


1.3
log
@calucuation of response message size was wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppctl.c,v 1.2 2014/03/22 04:30:31 yasuoka Exp $	*/
d514 1
a514 1
		if (msgbuf_write(&ctl_ibuf.w) < -1)
@


1.2
log
@Reimplement control part of npppd(8) with imsg.  Also add "monitor"
command for npppctl(8) to monitor PPP session start/stop events.
@
text
@d1 1
a1 1
/*	$OpenBSD: npppctl.c,v 1.1 2012/01/18 03:13:04 yasuoka Exp $	*/
d158 2
a159 2
			    entry[res->entry_count + 1])) {
			err(1, "response size %d is too small for "
@


1.1
log
@Replace npppdctl(8) by new npppctl(8).  npppctl was written from
scratch, it uses parser.c derived from ikectl(8) to have OpenBSD's
fashion.  This includes related changes listed below:
- changed npppd control IPC heavyly.
- support IPv6 as tunnel source address.
- deleted support changing the configuration of npppd_ctl on running.
  Because it is not so needed but it requires privilege operations.
- refactors.

man page helps from jmc.  tested by sebastia.
ok deraadt sebastia sthen
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d19 1
a20 1
#include <sys/time.h>
d35 1
a49 1
static void         on_exit (void);
d51 1
d60 1
d62 3
a64 3
static int	ctlsock = -1;
static char	ctlsockpath[] = "/tmp/npppctl.XXXXXX";
static int	nflag = 0;
d72 1
a72 2
	    "usage: %s [-n] [-r rcvbuf_size] [-s socket] [-t timeout_sec] "
	    "command [arg ...]\n", __progname);
d78 1
a78 1
	int			 ch, timeout_sec, rcvbuf;
d81 1
a81 2
	const char		*npppd_ctlpath = NPPPD_CTL_SOCK_PATH;
	struct timeval		 tv;
d85 1
a85 3
	rcvbuf = NPPPD_CTL_MSGSZ * 64;
	timeout_sec = 2;
	while ((ch = getopt(argc, argv, "nr:s:t:")) != -1)
a89 8
		case 'r':
			if (sscanf(optarg, "%d", &rcvbuf) != 1 || rcvbuf <= 0)
				errx(EXIT_FAILURE, "invalid rcvbuf_size value");
			if (rcvbuf < NPPPD_CTL_MSGSZ)
				errx(EXIT_FAILURE, 
				    "rcvbuf_size can not be less than %d",
				    NPPPD_CTL_MSGSZ);
			break;
a92 5
		case 't':
			if (sscanf(optarg, "%d", &timeout_sec) != 1 ||
			    timeout_sec <= 0)
				errx(EXIT_FAILURE, "invalid timeout value");
			break;
d104 2
a105 3
	if ((ctlsock = mkstemp(ctlsockpath)) < 0)
		err(1, "mkstemp");

a108 13
	strlcpy(sun.sun_path, ctlsockpath, sizeof(sun.sun_path));

	close(ctlsock);
	unlink(ctlsockpath);

	if ((ctlsock = socket(AF_UNIX, SOCK_DGRAM, 0)) < 0)
		err(EXIT_FAILURE, "socket");
	if (bind(ctlsock, (struct sockaddr *)&sun, sizeof(sun)) != 0)
		err(EXIT_FAILURE, "bind");

	if (setsockopt(ctlsock, SOL_SOCKET, SO_RCVBUF, &rcvbuf, sizeof(rcvbuf))
	    != 0)
		err(EXIT_FAILURE, "setsockopt(,,SO_RCVBUF)");
d110 1
a110 1
	if (connect(ctlsock, (struct sockaddr *)&sun, sizeof(sun)) != 0)
a111 2
	/* setup cleaner */
	atexit(on_exit);
d113 1
a113 8
	tv.tv_sec = timeout_sec;
	tv.tv_usec = 0L;
	if (setsockopt(ctlsock, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)))
		warn("setsockopt(,,SO_SNDTIMEO)");
	tv.tv_sec = timeout_sec;
	tv.tv_usec = 0L;
	if (setsockopt(ctlsock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)))
		warn("setsockopt(,,SO_RCVTIMEO)");
d130 3
a140 8
on_exit(void)
{
	if (ctlsock >= 0)
		close(ctlsock);
	unlink(ctlsockpath);
}

static void
d143 20
a162 19
	int				 i, n, sz, ppp_id_idx;
	struct npppd_ctl_who_request	 req = { .cmd = NPPPD_CTL_CMD_WHO };
	struct npppd_ctl_who_response	*res;
	u_char				 buf[NPPPD_CTL_MSGSZ + BUFSIZ];
	u_int				 ppp_id[NMAX_DISCONNECT];

	res = (struct npppd_ctl_who_response *)buf;
	if (send(ctlsock, &req, sizeof(req), 0) < 0)
		err(1, "send");
	res->count = 0;
	n = 0;
	ppp_id_idx = 0;
	do {
		if ((sz = recv(ctlsock, &buf, sizeof(buf), MSG_WAITALL)) < 0) {
			if (errno == EAGAIN) {
				warn("recv");
				break;
			}
			err(EXIT_FAILURE, "recv");
d164 1
a164 3
		for (i = 0; n < res->count &&
		    offsetof(struct npppd_ctl_who_response, entry[i + 1]) <= sz;
		    i++, n++)
d188 58
a245 8
	} while (n < res->count);
	if (n > 0 && n < res->count)
		warnx("There are %d sessions in total, but we received only %d "
		    "sessions.  Receive buffer size may not be enough, use -r "
		    "option to increase the size.", res->count, n);
	if (result->action == CLEAR_SESSION)
		clear_session(ppp_id, MIN(ppp_id_idx,  nitems(ppp_id)),
		    ppp_id_idx, out);
d283 3
a285 3
	struct tm		tm;
	char			ibytes_buf[48], obytes_buf[48], peer_buf[48],
				time_buf[48], dur_buf[48];
d335 4
a338 5
	int					 succ, fail, i, n, nmax;
	struct npppd_ctl_disconnect_request	 req;
	struct npppd_ctl_disconnect_response	 res;
	struct iovec				 iov[2];
	struct msghdr				 msg;
d342 2
a343 2
		nmax = (NPPPD_CTL_MSGSZ -
		    offsetof(struct npppd_ctl_disconnect_request, ppp_id[0])) /
a346 1
			req.cmd = NPPPD_CTL_CMD_DISCONNECT;
a347 3
			memset(&msg, 0, sizeof(msg));
			msg.msg_iov = iov;
			msg.msg_iovlen = nitems(iov);
d350 1
a350 1
			    struct npppd_ctl_disconnect_request, ppp_id[0]);
d353 16
a368 5
			if (sendmsg(ctlsock, &msg, 0) < 0)
				err(EXIT_FAILURE, "sendmsg");
			if (recv(ctlsock, &res, sizeof(res), 0) < 0)
				err(EXIT_FAILURE, "recv");
			succ += res.count;
d373 1
a373 1
		fprintf(out, "Successfully disconnected %d session%s.\n", 
d376 1
a376 1
		fprintf(out, "Failed to disconnect %d session%s.\n", 
d389 1
a389 1
		return false;
d395 1
a395 1
			return false;
d399 1
a399 1
		return false;
d404 1
a404 1
		return false;
d408 1
a408 1
		return false;
d411 1
a411 1
		return false;
d415 1
a415 1
		return false;
d417 1
a417 1
	return true;
d423 2
a424 2
	int		 niflags, hasserv;
	char		 hoststr[NI_MAXHOST], servstr[NI_MAXSERV];
d446 1
a446 1
	
d453 1
a453 1
	return buf;
d459 2
a460 2
	char		fbuf[128];
	int		hour, min;
d467 1
a467 1
		return buf;
d486 1
a486 1
	return buf;
d493 1
a493 1
		return buf;
d504 22
a525 2
			
	return buf;
@

