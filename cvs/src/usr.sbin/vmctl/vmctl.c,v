head	1.27;
access;
symbols
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12;
locks; strict;
comment	@ * @;


1.27
date	2017.03.15.18.00.11;	author reyk;	state Exp;
branches;
next	1.26;
commitid	sOe1LdNCWSCEBzlV;

1.26
date	2017.03.03.09.12.40;	author reyk;	state Exp;
branches;
next	1.25;
commitid	icUMIbtHSLL1KfRH;

1.25
date	2017.03.01.21.22.57;	author reyk;	state Exp;
branches;
next	1.24;
commitid	X6VByFJujQU3GivX;

1.24
date	2017.03.01.21.15.26;	author mlarkin;	state Exp;
branches;
next	1.23;
commitid	OX3MysWIwhlli2T6;

1.23
date	2017.03.01.07.43.33;	author reyk;	state Exp;
branches;
next	1.22;
commitid	2hnfyuVZdSB2L5DB;

1.22
date	2017.02.28.08.35.08;	author reyk;	state Exp;
branches;
next	1.21;
commitid	MNezzjn2ho7jfLw0;

1.21
date	2016.12.14.21.17.25;	author reyk;	state Exp;
branches;
next	1.20;
commitid	yUESeopyz7N219vi;

1.20
date	2016.11.26.19.49.11;	author reyk;	state Exp;
branches;
next	1.19;
commitid	ad2wVCUrs7CBTqdu;

1.19
date	2016.11.26.18.37.32;	author reyk;	state Exp;
branches;
next	1.18;
commitid	4mwZd0uGv1GQ6kH5;

1.18
date	2016.11.24.07.58.55;	author reyk;	state Exp;
branches;
next	1.17;
commitid	vTTzvT7jwtD1X8ZA;

1.17
date	2016.11.22.11.31.38;	author edd;	state Exp;
branches;
next	1.16;
commitid	vSgc5Dc31FPMjVfo;

1.16
date	2016.10.06.16.53.39;	author reyk;	state Exp;
branches;
next	1.15;
commitid	rZXkGkdrUYpgwZlL;

1.15
date	2016.05.10.11.00.54;	author mlarkin;	state Exp;
branches;
next	1.14;
commitid	axt6qqEZCKSjp3PS;

1.14
date	2016.05.10.10.49.22;	author mlarkin;	state Exp;
branches;
next	1.13;
commitid	4o31h6Y3tvt7DKeG;

1.13
date	2016.03.13.13.11.47;	author stefan;	state Exp;
branches;
next	1.12;
commitid	tNFHzbetplEWT4Tg;

1.12
date	2016.01.26.07.58.35;	author reyk;	state Exp;
branches;
next	1.11;
commitid	IxKttLRTdSkwh6Il;

1.11
date	2016.01.13.13.08.20;	author reyk;	state Exp;
branches;
next	1.10;
commitid	wEitgKnGH4JxC29b;

1.10
date	2015.12.14.06.59.07;	author mlarkin;	state Exp;
branches;
next	1.9;
commitid	u2MfphuvnzQceP1z;

1.9
date	2015.12.11.10.16.53;	author reyk;	state Exp;
branches;
next	1.8;
commitid	czO28zk1ubQjkjYC;

1.8
date	2015.12.08.08.01.20;	author reyk;	state Exp;
branches;
next	1.7;
commitid	c3yBcgquzyIeX3Y7;

1.7
date	2015.12.07.18.23.24;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	ZQd65OsNaGKA7BXk;

1.6
date	2015.12.06.02.26.14;	author reyk;	state Exp;
branches;
next	1.5;
commitid	DA7pwA53qcaD5xYQ;

1.5
date	2015.12.06.01.58.21;	author reyk;	state Exp;
branches;
next	1.4;
commitid	mJFYjYlVhI5frPwA;

1.4
date	2015.12.05.20.26.38;	author reyk;	state Exp;
branches;
next	1.3;
commitid	rD8lfaZ6U5Ngf9LK;

1.3
date	2015.12.05.18.48.24;	author mlarkin;	state Exp;
branches;
next	1.2;
commitid	ZHuodOENrs4lOlY6;

1.2
date	2015.12.04.15.40.17;	author reyk;	state Exp;
branches;
next	1.1;
commitid	foauN6yiJ6HjqIH0;

1.1
date	2015.12.03.21.45.45;	author reyk;	state Exp;
branches;
next	;
commitid	MPLOtGQkSv2xIotz;


desc
@@


1.27
log
@Print "-" if the tty name is empty.
@
text
@/*	$OpenBSD: vmctl.c,v 1.26 2017/03/03 09:12:40 reyk Exp $	*/

/*
 * Copyright (c) 2014 Mike Larkin <mlarkin@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/uio.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <machine/vmmvar.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <imsg.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>
#include <pwd.h>
#include <grp.h>

#include "vmd.h"
#include "vmctl.h"

extern char *__progname;
uint32_t info_id;
char info_name[VMM_MAX_NAME_LEN];
int info_console;

/*
 * vm_start
 *
 * Request vmd to start the VM defined by the supplied parameters
 *
 * Parameters:
 *  name: optional name of the VM
 *  memsize: memory size (MB) of the VM to create
 *  nnics: number of vionet network interfaces to create
 *  nics: switch names of the network interfaces to create
 *  ndisks: number of disk images
 *  disks: disk image file names
 *  kernel: kernel image to load
 *
 * Return:
 *  0 if the request to start the VM was sent successfully.
 *  ENOMEM if a memory allocation failure occurred.
 */
int
vm_start(const char *name, int memsize, int nnics, char **nics,
    int ndisks, char **disks, char *kernel)
{
	struct vmop_create_params *vmc;
	struct vm_create_params *vcp;
	unsigned int flags = 0;
	int i;

	if (memsize)
		flags |= VMOP_CREATE_MEMORY;
	if (nnics)
		flags |= VMOP_CREATE_NETWORK;
	if (ndisks)
		flags |= VMOP_CREATE_DISK;
	if (kernel)
		flags |= VMOP_CREATE_KERNEL;
	if (flags != 0) {
		if (memsize < 1)
			memsize = VM_DEFAULT_MEMORY;
		if (ndisks > VMM_MAX_DISKS_PER_VM)
			errx(1, "too many disks");
		else if (ndisks == 0)
			warnx("starting without disks");
		if (kernel == NULL && ndisks == 0)
			errx(1, "no kernel or disk specified");
		if (nnics == -1)
			nnics = 0;
		if (nnics > VMM_MAX_NICS_PER_VM)
			errx(1, "too many network interfaces");
		if (nnics == 0)
			warnx("starting without network interfaces");
	}

	vmc = calloc(1, sizeof(struct vmop_create_params));
	if (vmc == NULL)
		return (ENOMEM);

	vmc->vmc_flags = flags;

	/* vcp includes configuration that is shared with the kernel */
	vcp = &vmc->vmc_params;

	/*
	 * XXX: vmd(8) fills in the actual memory ranges. vmctl(8)
	 * just passes in the actual memory size in MB here.
	 */
	vcp->vcp_nmemranges = 1;
	vcp->vcp_memranges[0].vmr_size = memsize;

	vcp->vcp_ncpus = 1;
	vcp->vcp_ndisks = ndisks;
	vcp->vcp_nnics = nnics;

	for (i = 0 ; i < ndisks; i++)
		strlcpy(vcp->vcp_disks[i], disks[i], VMM_MAX_PATH_DISK);
	for (i = 0 ; i < nnics; i++)
		strlcpy(vmc->vmc_ifswitch[i], nics[i], IF_NAMESIZE);
	if (name != NULL)
		strlcpy(vcp->vcp_name, name, VMM_MAX_NAME_LEN);
	if (kernel != NULL)
		strlcpy(vcp->vcp_kernel, kernel, VMM_MAX_KERNEL_PATH);

	imsg_compose(ibuf, IMSG_VMDOP_START_VM_REQUEST, 0, 0, -1,
	    vmc, sizeof(struct vmop_create_params));

	free(vcp);
	return (0);
}

/*
 * vm_start_complete
 *
 * Callback function invoked when we are expecting an
 * IMSG_VMDOP_START_VMM_RESPONSE message indicating the completion of
 * a start vm operation.
 *
 * Parameters:
 *  imsg : response imsg received from vmd
 *  ret  : return value
 *  autoconnect : open the console after startup
 *
 * Return:
 *  Always 1 to indicate we have processed the return message (even if it
 *  was an incorrect/failure message) 
 *
 *  The function also sets 'ret' to the error code as follows:
 *   0     : Message successfully processed
 *   EINVAL: Invalid or unexpected response from vmd
 *   EIO   : vm_start command failed
 */
int
vm_start_complete(struct imsg *imsg, int *ret, int autoconnect)
{
	struct vmop_result *vmr;
	int res;

	if (imsg->hdr.type == IMSG_VMDOP_START_VM_RESPONSE) {
		vmr = (struct vmop_result *)imsg->data;
		res = vmr->vmr_result;
		if (res) {
			errno = res;
			warn("start vm command failed");
			*ret = EIO;
		} else if (autoconnect) {
			/* does not return */
			ctl_openconsole(vmr->vmr_ttyname);
		} else {
			warnx("started vm %d successfully, tty %s",
			    vmr->vmr_id, vmr->vmr_ttyname);
			*ret = 0;
		}
	} else {
		warnx("unexpected response received from vmd");
		*ret = EINVAL;
	}

	return (1);
}

/*
 * terminate_vm
 *
 * Request vmd to stop the VM indicated
 *
 * Parameters:
 *  terminate_id: ID of the vm to be terminated
 *  name: optional name of the VM to be terminated
 */
void
terminate_vm(uint32_t terminate_id, const char *name)
{
	struct vmop_id vid;

	memset(&vid, 0, sizeof(vid));
	vid.vid_id = terminate_id;
	if (name != NULL)
		(void)strlcpy(vid.vid_name, name, sizeof(vid.vid_name));

	imsg_compose(ibuf, IMSG_VMDOP_TERMINATE_VM_REQUEST, 0, 0, -1,
	    &vid, sizeof(vid));
}

/*
 * terminate_vm_complete
 *
 * Callback function invoked when we are expecting an
 * IMSG_VMDOP_TERMINATE_VMM_RESPONSE message indicating the completion of
 * a terminate vm operation.
 *
 * Parameters:
 *  imsg : response imsg received from vmd
 *  ret  : return value
 *
 * Return:
 *  Always 1 to indicate we have processed the return message (even if it
 *  was an incorrect/failure message) 
 *
 *  The function also sets 'ret' to the error code as follows:
 *   0     : Message successfully processed
 *   EINVAL: Invalid or unexpected response from vmd
 *   EIO   : terminate_vm command failed
 */
int
terminate_vm_complete(struct imsg *imsg, int *ret)
{
	struct vmop_result *vmr;
	int res;

	if (imsg->hdr.type == IMSG_VMDOP_TERMINATE_VM_RESPONSE) {
		vmr = (struct vmop_result *)imsg->data;
		res = vmr->vmr_result;
		if (res) {
			errno = res;
			warn("terminate vm command failed");
			*ret = EIO;
		} else {
			warnx("terminated vm %d successfully", vmr->vmr_id);
			*ret = 0;
		}
	} else {
		warnx("unexpected response received from vmd");
		*ret = EINVAL;
	}

	return (1);
}

/*
 * get_info_vm
 *
 * Return the list of all running VMs or find a specific VM by ID or name.
 *
 * Parameters:
 *  id: optional ID of a VM to list
 *  name: optional name of a VM to list 
 *  console: if true, open the console of the selected VM (by name or ID)
 *
 * Request a list of running VMs from vmd
 */
void
get_info_vm(uint32_t id, const char *name, int console)
{
	info_id = id;
	if (name != NULL)
		(void)strlcpy(info_name, name, sizeof(info_name));
	info_console = console;
	imsg_compose(ibuf, IMSG_VMDOP_GET_INFO_VM_REQUEST, 0, 0, -1, NULL, 0);
}

/*
 * check_info_id
 *
 * Check if requested name or ID of a VM matches specified arguments
 *
 * Parameters:
 *  name: name of the VM
 *  id: ID of the VM
 */
int
check_info_id(const char *name, uint32_t id)
{
	if (info_id == 0 && *info_name == '\0')
		return (-1);
	if (info_id != 0 && info_id == id)
		return (1);
	if (*info_name != '\0' && name && strcmp(info_name, name) == 0)
		return (1);
	return (0);
}

/*
 * add_info
 *
 * Callback function invoked when we are expecting an
 * IMSG_VMDOP_GET_INFO_VM_DATA message indicating the receipt of additional
 * "list vm" data, or an IMSG_VMDOP_GET_INFO_VM_END_DATA message indicating
 * that no additional "list vm" data will be forthcoming.
 *
 * Parameters:
 *  imsg : response imsg received from vmd
 *  ret  : return value
 *
 * Return:
 *  0     : the returned data was successfully added to the "list vm" data.
 *          The caller can expect more data.
 *  1     : IMSG_VMDOP_GET_INFO_VM_END_DATA received (caller should not call
 *          add_info again), or an error occurred adding the returned data
 *          to the "list vm" data. The caller should check the value of
 *          'ret' to determine which case occurred.
 *
 * This function does not return if a VM is found and info_console is set.
 *
 *  The function also sets 'ret' to the error code as follows:
 *   0     : Message successfully processed
 *   EINVAL: Invalid or unexpected response from vmd
 *   ENOMEM: memory allocation failure
 */
int
add_info(struct imsg *imsg, int *ret)
{
	static size_t ct = 0;
	static struct vmop_info_result *vir = NULL;

	if (imsg->hdr.type == IMSG_VMDOP_GET_INFO_VM_DATA) {
		vir = reallocarray(vir, ct + 1,
		    sizeof(struct vmop_info_result));
		if (vir == NULL) {
			*ret = ENOMEM;
			return (1);
		}
		memcpy(&vir[ct], imsg->data, sizeof(struct vmop_info_result));
		ct++;
		*ret = 0;
		return (0);
	} else if (imsg->hdr.type == IMSG_VMDOP_GET_INFO_VM_END_DATA) {
		if (info_console)
			vm_console(vir, ct);
		else
			print_vm_info(vir, ct);
		free(vir);
		*ret = 0;
		return (1);
	} else {
		*ret = EINVAL;
		return (1);
	}
}

/*
 * print_vm_info
 *
 * Prints the vm information returned from vmd in 'list' to stdout.
 *
 * Parameters
 *  list: the vm information (consolidated) returned from vmd via imsg
 *  ct  : the size (number of elements in 'list') of the result
 */
void
print_vm_info(struct vmop_info_result *list, size_t ct)
{
	struct vm_info_result *vir;
	struct vmop_info_result *vmi;
	size_t i, j;
	char *vcpu_state, *tty;
	char curmem[FMT_SCALED_STRSIZE];
	char maxmem[FMT_SCALED_STRSIZE];
	char user[16], group[16];
	struct passwd *pw;
	struct group *gr;

	printf("%5s %5s %5s %7s %7s %7s %12s %s\n", "ID", "PID", "VCPUS",
	    "MAXMEM", "CURMEM", "TTY", "OWNER", "NAME");

	for (i = 0; i < ct; i++) {
		vmi = &list[i];
		vir = &vmi->vir_info;
		if (check_info_id(vir->vir_name, vir->vir_id)) {
			/* get user name */
			if ((pw = getpwuid(vmi->vir_uid)) == NULL)
				(void)snprintf(user, sizeof(user),
				    "%d", vmi->vir_uid);
			else
				(void)strlcpy(user, pw->pw_name,
				    sizeof(user));
			/* get group name */
			if (vmi->vir_gid != -1) {
				if (vmi->vir_uid == 0)
					*user = '\0';
				if ((gr = getgrgid(vmi->vir_gid)) == NULL)
					(void)snprintf(group, sizeof(group),
					    ":%lld", vmi->vir_gid);
				else
					(void)snprintf(group, sizeof(group),
					    ":%s", gr->gr_name);
				(void)strlcat(user, group, sizeof(user));
			}

			(void)strlcpy(curmem, "-", sizeof(curmem));
			(void)strlcpy(maxmem, "-", sizeof(maxmem));

			(void)fmt_scaled(vir->vir_memory_size * 1024 * 1024,
			    maxmem);

			if (vir->vir_id != 0) {
				if (*vmi->vir_ttyname == '\0')
					tty = "-";
				/* get tty - skip /dev/ path */
				else if ((tty = strrchr(vmi->vir_ttyname,
				    '/')) == NULL || ++tty == '\0')
					tty = list[i].vir_ttyname;

				(void)fmt_scaled(vir->vir_used_size, curmem);

				/* running vm */
				printf("%5u %5u %5zd %7s %7s %7s %12s %s\n",
				    vir->vir_id, vir->vir_creator_pid,
				    vir->vir_ncpus, maxmem, curmem,
				    tty, user, vir->vir_name);
			} else {
				/* disabled vm */
				printf("%5s %5s %5zd %7s %7s %7s %12s %s\n",
				    "-", "-",
				    vir->vir_ncpus, maxmem, curmem,
				    "-", user, vir->vir_name);
			}
		}
		if (check_info_id(vir->vir_name, vir->vir_id) > 0) {
			for (j = 0; j < vir->vir_ncpus; j++) {
				if (vir->vir_vcpu_state[j] ==
				    VCPU_STATE_STOPPED)
					vcpu_state = "STOPPED";
				else if (vir->vir_vcpu_state[j] ==
				    VCPU_STATE_RUNNING)
					vcpu_state = "RUNNING";
				else
					vcpu_state = "UNKNOWN";

				printf(" VCPU: %2zd STATE: %s\n",
				    j, vcpu_state);
			}
		}
	}
}

/*
 * vm_console
 *
 * Connects to the vm console returned from vmd in 'list'.
 *
 * Parameters
 *  list: the vm information (consolidated) returned from vmd via imsg
 *  ct  : the size (number of elements in 'list') of the result
 */
__dead void
vm_console(struct vmop_info_result *list, size_t ct)
{
	struct vmop_info_result *vir;
	size_t i;

	for (i = 0; i < ct; i++) {
		vir = &list[i];
		if (check_info_id(vir->vir_info.vir_name,
		    vir->vir_info.vir_id) > 0) {
			/* does not return */
			ctl_openconsole(vir->vir_ttyname);
		}
	}

	errx(1, "console %d not found", info_id);
}

/*
 * create_imagefile
 *
 * Create an empty imagefile with the specified path and size.
 *
 * Parameters:
 *  imgfile_path: path to the image file to create
 *  imgsize     : size of the image file to create (in MB)
 *
 * Return:
 *  EEXIST: The requested image file already exists
 *  0     : Image file successfully created
 *  Exxxx : Various other Exxxx errno codes due to other I/O errors
 */
int
create_imagefile(const char *imgfile_path, long imgsize)
{
	int fd, ret;

	/* Refuse to overwrite an existing image */
	fd = open(imgfile_path, O_RDWR | O_CREAT | O_TRUNC | O_EXCL,
	    S_IRUSR | S_IWUSR);
	if (fd == -1)
		return (errno);

	/* Extend to desired size */
	if (ftruncate(fd, (off_t)imgsize * 1024 * 1024) == -1) {
		ret = errno;
		close(fd);
		unlink(imgfile_path);
		return (ret);
	}

	ret = close(fd);
	return (ret);
}
@


1.26
log
@Undefined behavior: Variable 'user' was used as parameter and
destination in snprintf().  Use a temporary variable instead.

Found and OK by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.25 2017/03/01 21:22:57 reyk Exp $	*/
d412 2
d415 1
a415 1
				if ((tty = strrchr(vmi->vir_ttyname,
@


1.25
log
@Rename start_vm_complete to vm_start_complete for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.24 2017/03/01 21:15:26 mlarkin Exp $	*/
d374 1
a374 1
	char user[16];
d397 2
a398 2
					(void)snprintf(user, sizeof(user),
					    "%s:%lld", user, vmi->vir_gid);
d400 3
a402 2
					(void)snprintf(user, sizeof(user),
					    "%s:%s", user, gr->gr_name);
@


1.24
log
@unbreak vmctl build by renaming a function that now conflicts with
something from vmd.h . Temporary fix until the original committer can
fix it the way he desires.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.23 2017/03/01 07:43:33 reyk Exp $	*/
d138 1
a138 1
 * start_vm_complete
d156 1
a156 1
 *   EIO   : start_vm command failed
d159 1
a159 1
start_vm_complete(struct imsg *imsg, int *ret, int autoconnect)
@


1.23
log
@Add "owner" option to set a user/group ownership for pre-configured VMs

This allows matching users to start or stop VMs that they "own" and to
access the console accordingly.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.22 2017/02/28 08:35:08 reyk Exp $	*/
d50 1
a50 1
 * start_vm
d68 1
a68 1
start_vm(const char *name, int memsize, int nnics, char **nics,
@


1.22
log
@Use fmt_scaled(3) in vmctl status output to print curmem/maxmem

This matches the accepted input in vmctl start and vm.conf that
supports using M, G, T etc. instead of a hardcoded MB.  It also allows
to shrink the column size as the unit will be scaled automatically.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.21 2016/12/14 21:17:25 reyk Exp $	*/
d19 1
a19 1
#include <sys/types.h>
d38 2
d374 3
d378 2
a379 2
	printf("%5s %5s %5s %7s %7s %7s %s\n", "ID", "PID", "VCPUS",
	    "MAXMEM", "CURMEM", "TTY", "NAME");
d385 19
d419 1
a419 1
				printf("%5u %5u %5zd %7s %7s %7s %s\n",
d422 1
a422 1
				    tty, vir->vir_name);
d425 1
a425 1
				printf("%5s %5s %5zd %7s %7s %7s %s\n",
d428 1
a428 1
				    "-", vir->vir_name);
@


1.21
log
@Allow to start disabled and pre-configured VMs by name, "vmctl start foo".

With testing from Jon Bernard

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.20 2016/11/26 19:49:11 reyk Exp $	*/
d37 1
d367 1
d369 6
a374 1
	char *vcpu_state;
a375 2
	printf("%5s %5s %5s %9s %9s %*s %s\n", "ID", "PID", "VCPUS", "MAXMEM",
	    "CURMEM", VM_TTYNAME_MAX, "TTY", "NAME");
d377 2
a378 1
		vir = &list[i].vir_info;
d380 6
d387 7
d395 1
a395 1
				printf("%5u %5u %5zd %7zdMB %7zdMB %*s %s\n",
d397 2
a398 3
				    vir->vir_ncpus, vir->vir_memory_size,
				    vir->vir_used_size / 1024 / 1024 , VM_TTYNAME_MAX,
				    list[i].vir_ttyname, vir->vir_name);
d401 1
a401 1
				printf("%5s %5s %5zd %7zdMB %9s %*s %s\n",
d403 1
a403 2
				    vir->vir_ncpus, vir->vir_memory_size,
				    "-", VM_TTYNAME_MAX,
@


1.20
log
@If -m/memory is not specified, use 512M by default.

Default value picked with mlarkin - not too small and not too large.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.19 2016/11/26 18:37:32 reyk Exp $	*/
d70 1
d73 24
a96 14
	if (memsize < 1)
		memsize = VM_DEFAULT_MEMORY;
	if (ndisks > VMM_MAX_DISKS_PER_VM)
		errx(1, "too many disks");
	else if (ndisks == 0)
		warnx("starting without disks");
	if (kernel == NULL && ndisks == 0)
		errx(1, "no kernel or disk specified");
	if (nnics == -1)
		nnics = 0;
	if (nnics > VMM_MAX_NICS_PER_VM)
		errx(1, "too many network interfaces");
	if (nnics == 0)
		warnx("starting without network interfaces");
d101 2
@


1.19
log
@Add the vmctl start -n option to specify add a network interface to
the specified virtual switch from the command line.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.18 2016/11/24 07:58:55 reyk Exp $	*/
d73 1
a73 1
		errx(1, "specified memory size too small");
@


1.18
log
@Add support for booting the kernel from the disk image.

This make the kernel/-k argument optional and, if not specified, tries
to find the /bsd kernel in the primary hd0a partition of the first
disk image itself.  It doesn't support hd0a:/etc/boot.conf yet, and it
is no BIOS or full boot loader, but it makes booting and handling of
VMs a bit easier - booting an external kernel is still supported.

The UFS file system code ufs.c is directly from libsa which is also
used by the real boot loader.  The code compiles with a few signedness
warning which will be fixed separately.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.17 2016/11/22 11:31:38 edd Exp $	*/
d55 1
d65 2
a66 2
start_vm(const char *name, int memsize, int nnics, int ndisks, char **disks,
    char *kernel)
d82 2
d103 1
d107 2
a108 1

a112 1
	vcp->vcp_nnics = nnics;
@


1.17
log
@Insert disabled VMs into vmd(8)'s queues and allow vmctl(8) to display them.

Tested by Jon Bernard and reyk@@.

OK reyk@@, no objections mlarkin@@.

Thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.16 2016/10/06 16:53:39 reyk Exp $	*/
a72 2
	if (kernel == NULL)
		errx(1, "no kernel specified");
d77 2
d106 2
a107 1
	strlcpy(vcp->vcp_kernel, kernel, VMM_MAX_KERNEL_PATH);
@


1.16
log
@The start control imsg has been switched to a new "struct
vmop_create_params" that also includes configuration that is only for
userland.  I forgot to commit this chunk.

Found the hard way by mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.15 2016/05/10 11:00:54 mlarkin Exp $	*/
d356 15
a370 5
			printf("%5u %5u %5zd %7zdMB %7zdMB %*s %s\n",
			    vir->vir_id, vir->vir_creator_pid,
			    vir->vir_ncpus, vir->vir_memory_size,
			    vir->vir_used_size / 1024 / 1024 , VM_TTYNAME_MAX,
			    list[i].vir_ttyname, vir->vir_name);
@


1.15
log
@
move some argument checking from vmmaction() to start_vm()

from a diff posted to tech@@ by Fabien Siron, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.14 2016/05/10 10:49:22 mlarkin Exp $	*/
d67 1
d84 2
a85 2
	vcp = malloc(sizeof(struct vm_create_params));
	if (vcp == NULL)
d88 2
a89 1
	bzero(vcp, sizeof(struct vm_create_params));
d110 1
a110 1
	    vcp, sizeof(struct vm_create_params));
@


1.14
log
@
typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.13 2016/03/13 13:11:47 stefan Exp $	*/
d69 13
@


1.13
log
@Introduce memory ranges to support VMs with >= 4G RAM

Kernel bits:
- When creating a VM, a list of memory ranges has to be specified,
  similar to the BIOS memory map. This is necessary for VMs with
  RAM sizes approaching 4G because we'll need PCI MMIO space in
  the higher parts of the 32 bit address space.

vmctl and vmd bits:
- Construct appropriate memory ranges to create a VM with a given
  RAM size
- Construct a corresponding BIOS memory map from the memory ranges
  and update the boot params page accordingly.
- Make sure that all variables that represent guest physical addresses
  match the address width of the target CPU instead of using uint32_t.
- Fix some integer promotion glitches that actually restricted VM
  RAM size to 2G.

This changes the VM create ioctl interface, so update your kernel,
vmd, and vmctl.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.12 2016/01/26 07:58:35 reyk Exp $	*/
d242 1
a242 1
 * chec_info_id
@


1.12
log
@lseek() + write() can be replaced by a slightly shorter ftruncate()
call. Note that using ftruncate() to extend a file is not portable
(POSIX allows either zero-filling until the given size is reached, or
alternatively erroring out), but that shouldn't be a proble as vmm(4)
isn't cross-platform either.  unlink() the image file when extending
it fails for consistency with the other error case (the file can't be
created).

From Martin Natano
OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.11 2016/01/13 13:08:20 reyk Exp $	*/
d76 7
a82 1
	vcp->vcp_memory_size = memsize;
@


1.11
log
@Update the comments in vmctl.c that are describing function arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.10 2015/12/14 06:59:07 mlarkin Exp $	*/
d393 1
a393 1
 *  imgsize     : size of the image file to create
a403 2
	off_t ofs;
	char ch = '\0';
d411 2
a412 11
	ofs = (imgsize * 1024 * 1024) - 1;

	/* Set fd pos at desired size */
	if (lseek(fd, ofs, SEEK_SET) == -1) {
		ret = errno;
		close(fd);
		return (ret);
	}

	/* Write one byte to fill out the extent */
	if (write(fd, &ch, 1) == -1) {
d415 1
@


1.10
log
@
track used memory in each VM. This is passed back to vmctl status.

ok reyk@@, beck@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.9 2015/12/11 10:16:53 reyk Exp $	*/
d152 1
d216 7
d238 5
a242 1
 * Check if requested name or id matches specified arguments
d275 2
@


1.9
log
@The vmctl "id" argument can now be a number of or a vm name, eg.
vmctl stop 3
vmctl stop "openbsd.vm"
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.8 2015/12/08 08:01:20 reyk Exp $	*/
d316 2
a317 2
	printf("%5s %5s %5s %9s %*s %s\n", "ID", "PID", "VCPUS", "MAXMEM",
	    VM_TTYNAME_MAX, "TTY", "NAME");
d321 1
a321 1
			printf("%5u %5u %5zd %7zdMB %*s %s\n",
d324 2
a325 2
			    VM_TTYNAME_MAX, list[i].vir_ttyname,
			    vir->vir_name);
@


1.8
log
@Add "vmctl console" to connect to a specified VM console by id.

Requested by mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.7 2015/12/07 18:23:24 deraadt Exp $	*/
d43 1
d154 1
a154 1
terminate_vm(uint32_t terminate_id)
d156 1
a156 1
	struct vm_terminate_params vtp;
d158 4
a161 2
	bzero(&vtp, sizeof(struct vm_terminate_params));
	vtp.vtp_vm_id = terminate_id;
d164 1
a164 1
	    &vtp, sizeof(struct vm_terminate_params));
d218 1
a218 1
get_info_vm(uint32_t id, int console)
d221 2
d228 17
d320 1
a320 1
		if (info_id == 0 || info_id == vir->vir_id)
d326 2
a327 1
		if (info_id == vir->vir_id) {
d362 2
a363 1
		if (info_id == vir->vir_info.vir_id) {
@


1.7
log
@use O_EXCL rather than a race
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.6 2015/12/06 02:26:14 reyk Exp $	*/
d43 1
d129 2
a130 8
			closefrom(STDERR_FILENO + 1);

			/* Only returns on error */
			if (execl(VMCTL_CU, VMCTL_CU,
			    "-l", vmr->vmr_ttyname, "-s", "9600", NULL) == -1) {
				warn("failed to open the console");
				*ret = errno;
			}
d215 1
a215 1
get_info_vm(uint32_t id)
d218 1
d265 4
a268 1
		print_vm_info(vir, ct);
d320 26
@


1.6
log
@Print the TTY in the vmctl status output.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.5 2015/12/06 01:58:21 reyk Exp $	*/
a340 1
	struct stat sb;
d345 3
a347 8
	bzero(&sb, sizeof(sb));
	if (stat(imgfile_path, &sb) == 0) {
		return (EEXIST);
	}

	fd = open(imgfile_path, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);

	if (fd == -1) {
a348 1
	}
@


1.5
log
@When a new vm is created with VMM_IOC_CREATE, the kernel assigns a
unique id to it.  This happens in the vm child process and has to be
communicated to the parent processes to track the vm.  Knowing the vm
id in the parent and vmm processes also allows to remove vm from the
daemons list on terminate requests later.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmctl.c,v 1.4 2015/12/05 20:26:38 reyk Exp $	*/
d255 1
a255 1
	static struct vm_info_result *vir = NULL;
d259 1
a259 1
		    sizeof(struct vm_info_result));
d264 1
a264 1
		bcopy(imsg->data, &vir[ct], sizeof(struct vm_info_result));
d289 1
a289 1
print_vm_info(struct vm_info_result *list, size_t ct)
d291 1
d295 2
a296 2
	printf("%5s %5s %5s %9s   %s\n", "ID", "PID", "VCPUS", "MAXMEM",
	    "NAME");
d298 10
a307 8
		if (info_id == 0 || info_id == list[i].vir_id)
			printf("%5u %5u %5zd %7zdMB %s\n",
			    list[i].vir_id, list[i].vir_creator_pid,
			    list[i].vir_ncpus, list[i].vir_memory_size,
			    list[i].vir_name);
		if (info_id == list[i].vir_id) {
			for (j = 0; j < list[i].vir_ncpus; j++) {
				if (list[i].vir_vcpu_state[j] ==
d310 1
a310 1
				else if (list[i].vir_vcpu_state[j] ==
@


1.4
log
@Add OpenBSD Id
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d117 1
a117 1
	struct vmop_start_result *vmr;
d121 1
a121 1
		vmr = (struct vmop_start_result *)imsg->data;
d124 2
a125 2
			fprintf(stderr, "%s: start VM command failed (%d) - "
			    "%s\n", __progname, res, strerror(res));
d133 1
a133 2
				fprintf(stderr, "%s: failed to open "
				    "the console\n", __progname);
d137 2
a138 2
			fprintf(stdout, "%s: start VM command successful, "
			    "tty %s\n", __progname, vmr->vmr_ttyname);
d142 1
a142 2
		fprintf(stderr, "%s: unexpected response received from vmd\n",
		    __progname);
d192 1
d196 2
a197 1
		res = *(int *)imsg->data;
d199 2
a200 2
			fprintf(stderr, "%s: terminate VM command failed "
			    "(%d) - %s\n", __progname, res, strerror(res));
d203 1
a203 2
			fprintf(stderr, "%s: terminate VM command successful\n",
			    __progname);
d207 1
a207 2
		fprintf(stderr, "%s: unexpected response received from vmd\n",
		    __progname);
@


1.3
log
@
Align columns to printed output in "vmctl status"
@
text
@d1 2
@


1.2
log
@Add -c option to "vmctl start" to automatically connect to the VM
console after startup.  This calls 'cu -l $TTY -s 9600' internally -
a "safe mode" for cu is proposed by tedu@@.

Requested by mlarkin@@
OK tedu@@ on the execl/cu chunk
@
text
@d294 1
a294 1
	printf("%5s %5s %5s %7s   %s\n", "ID", "PID", "VCPUS", "MAXMEM",
@


1.1
log
@Replace vmmctl with vmctl.  Also remove parse.y from the "new" vmctl.

As discussed with mlarkin@@ and deraadt@@
@
text
@d101 1
d113 1
a113 1
start_vm_complete(struct imsg *imsg, int *ret)
d125 10
@

