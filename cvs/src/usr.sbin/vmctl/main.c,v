head	1.28;
access;
symbols
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14;
locks; strict;
comment	@ * @;


1.28
date	2017.05.04.19.41.58;	author reyk;	state Exp;
branches;
next	1.27;
commitid	ygf0Wmp9XnmAli8A;

1.27
date	2017.05.04.16.54.41;	author reyk;	state Exp;
branches;
next	1.26;
commitid	w2yDm1gwVPaym65O;

1.26
date	2017.04.19.15.38.32;	author reyk;	state Exp;
branches;
next	1.25;
commitid	Wp87uvjcKIIYK6nL;

1.25
date	2017.04.06.18.07.13;	author reyk;	state Exp;
branches;
next	1.24;
commitid	EDN0yyFCjEEFLBXp;

1.24
date	2017.03.25.16.28.25;	author reyk;	state Exp;
branches;
next	1.23;
commitid	s82EA2LBuZtftmLN;

1.23
date	2017.03.01.21.22.57;	author reyk;	state Exp;
branches;
next	1.22;
commitid	X6VByFJujQU3GivX;

1.22
date	2017.03.01.21.15.26;	author mlarkin;	state Exp;
branches;
next	1.21;
commitid	OX3MysWIwhlli2T6;

1.21
date	2017.03.01.07.43.33;	author reyk;	state Exp;
branches;
next	1.20;
commitid	2hnfyuVZdSB2L5DB;

1.20
date	2017.01.11.22.38.10;	author reyk;	state Exp;
branches;
next	1.19;
commitid	36vA2wHEJBH4Kmuc;

1.19
date	2016.11.26.18.37.32;	author reyk;	state Exp;
branches;
next	1.18;
commitid	4mwZd0uGv1GQ6kH5;

1.18
date	2016.10.12.19.10.03;	author reyk;	state Exp;
branches;
next	1.17;
commitid	ghkPP3DbrIiwazmp;

1.17
date	2016.05.10.11.00.54;	author mlarkin;	state Exp;
branches;
next	1.16;
commitid	axt6qqEZCKSjp3PS;

1.16
date	2016.04.25.15.14.34;	author mlarkin;	state Exp;
branches;
next	1.15;
commitid	JmSlJWAuQZnU6igB;

1.15
date	2016.03.17.19.40.43;	author krw;	state Exp;
branches;
next	1.14;
commitid	aCmYZrmRmWHLuztW;

1.14
date	2016.01.26.07.55.47;	author reyk;	state Exp;
branches;
next	1.13;
commitid	XUwGWQXG0XCXMzPL;

1.13
date	2016.01.05.16.25.34;	author semarie;	state Exp;
branches;
next	1.12;
commitid	FZjmy34ksZT3Cg6B;

1.12
date	2015.12.11.10.16.53;	author reyk;	state Exp;
branches;
next	1.11;
commitid	czO28zk1ubQjkjYC;

1.11
date	2015.12.11.09.24.10;	author reyk;	state Exp;
branches;
next	1.10;
commitid	BIUjAKLrcioUOQVp;

1.10
date	2015.12.11.09.08.05;	author reyk;	state Exp;
branches;
next	1.9;
commitid	xw9BeOVbB1cbCfoi;

1.9
date	2015.12.08.13.15.09;	author reyk;	state Exp;
branches;
next	1.8;
commitid	p7rt4ucJ2b8lFuTn;

1.8
date	2015.12.08.08.02.15;	author reyk;	state Exp;
branches;
next	1.7;
commitid	aiWmEPPVLHH01cZI;

1.7
date	2015.12.08.08.01.20;	author reyk;	state Exp;
branches;
next	1.6;
commitid	c3yBcgquzyIeX3Y7;

1.6
date	2015.12.05.22.34.31;	author sobrado;	state Exp;
branches;
next	1.5;
commitid	R6n9qvidcrQDHnbm;

1.5
date	2015.12.05.17.30.34;	author claudio;	state Exp;
branches;
next	1.4;
commitid	HZtr1GvWPr0Bg8in;

1.4
date	2015.12.05.04.40.05;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	l2hLGc6dvAwEASIY;

1.3
date	2015.12.04.15.40.17;	author reyk;	state Exp;
branches;
next	1.2;
commitid	foauN6yiJ6HjqIH0;

1.2
date	2015.12.03.23.32.32;	author reyk;	state Exp;
branches;
next	1.1;
commitid	ABlEnH3RsSBpSsyK;

1.1
date	2015.12.03.21.45.45;	author reyk;	state Exp;
branches;
next	;
commitid	MPLOtGQkSv2xIotz;


desc
@@


1.28
log
@Report command failure back to vmctl reload, reset, load, log verbose.

OK mlarkin@@
@
text
@/*	$OpenBSD: main.c,v 1.27 2017/05/04 16:54:41 reyk Exp $	*/

/*
 * Copyright (c) 2015 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/un.h>

#include <machine/vmmvar.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <limits.h>
#include <string.h>
#include <unistd.h>
#include <util.h>
#include <imsg.h>

#include "vmd.h"
#include "proc.h"
#include "vmctl.h"

static const char	*socket_name = SOCKET_NAME;
static int		 ctl_sock = -1;
static int		 tty_autoconnect = 0;

__dead void	 usage(void);
__dead void	 ctl_usage(struct ctl_command *);

int		 vmm_action(struct parse_result *);

int		 ctl_console(struct parse_result *, int, char *[]);
int		 ctl_create(struct parse_result *, int, char *[]);
int		 ctl_load(struct parse_result *, int, char *[]);
int		 ctl_log(struct parse_result *, int, char *[]);
int		 ctl_reload(struct parse_result *, int, char *[]);
int		 ctl_reset(struct parse_result *, int, char *[]);
int		 ctl_start(struct parse_result *, int, char *[]);
int		 ctl_status(struct parse_result *, int, char *[]);
int		 ctl_stop(struct parse_result *, int, char *[]);

struct ctl_command ctl_commands[] = {
	{ "console",	CMD_CONSOLE,	ctl_console,	"id" },
	{ "create",	CMD_CREATE,	ctl_create,	"\"path\" -s size", 1 },
	{ "load",	CMD_LOAD,	ctl_load,	"\"path\"" },
	{ "log",	CMD_LOG,	ctl_log,	"(verbose|brief)" },
	{ "reload",	CMD_RELOAD,	ctl_reload,	"" },
	{ "reset",	CMD_RESET,	ctl_reset,	"[all|vms|switches]" },
	{ "start",	CMD_START,	ctl_start,	"\"name\""
	    " [-Lc] [-b image] [-m size]\n"
	    "\t\t[-n switch] [-i count] [-d disk]*" },
	{ "status",	CMD_STATUS,	ctl_status,	"[id]" },
	{ "stop",	CMD_STOP,	ctl_stop,	"id" },
	{ NULL }
};

__dead void
usage(void)
{
	extern char	*__progname;
	int		 i;

	fprintf(stderr, "usage:\t%s command [arg ...]\n",
	    __progname);
	for (i = 0; ctl_commands[i].name != NULL; i++) {
		fprintf(stderr, "\t%s %s %s\n", __progname,
		    ctl_commands[i].name, ctl_commands[i].usage);
	}
	exit(1);
}

__dead void
ctl_usage(struct ctl_command *ctl)
{
	extern char	*__progname;

	fprintf(stderr, "usage:\t%s %s %s\n", __progname,
	    ctl->name, ctl->usage);
	exit(1);
}

int
main(int argc, char *argv[])
{
	int	 ch;

	while ((ch = getopt(argc, argv, "")) != -1) {
		switch (ch) {
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;
	optreset = 1;

	if (argc < 1)
		usage();

	return (parse(argc, argv));
}

int
parse(int argc, char *argv[])
{
	struct ctl_command	*ctl = NULL;
	struct parse_result	 res;
	int			 i;

	memset(&res, 0, sizeof(res));
	res.nifs = -1;

	for (i = 0; ctl_commands[i].name != NULL; i++) {
		if (strncmp(ctl_commands[i].name,
		    argv[0], strlen(argv[0])) == 0) {
			if (ctl != NULL) {
				fprintf(stderr,
				    "ambiguous argument: %s\n", argv[0]);
				usage();
			}
			ctl = &ctl_commands[i];
		}
	}

	if (ctl == NULL) {
		fprintf(stderr, "unknown argument: %s\n", argv[0]);
		usage();
	}

	res.action = ctl->action;
	res.ctl = ctl;

	if (!ctl->has_pledge) {
		/* pledge(2) default if command doesn't have its own pledge */
		if (pledge("stdio rpath exec unix getpw", NULL) == -1)
			err(1, "pledge");
	}
	if (ctl->main(&res, argc, argv) != 0)
		err(1, "failed");

	if (ctl_sock != -1) {
		close(ibuf->fd);
		free(ibuf);
	}

	return (0);
}

int
vmmaction(struct parse_result *res)
{
	struct sockaddr_un	 sun;
	struct imsg		 imsg;
	int			 done = 0;
	int			 n;
	int			 ret, action;

	if (ctl_sock == -1) {
		if ((ctl_sock = socket(AF_UNIX,
		    SOCK_STREAM|SOCK_CLOEXEC, 0)) == -1)
			err(1, "socket");

		bzero(&sun, sizeof(sun));
		sun.sun_family = AF_UNIX;
		strlcpy(sun.sun_path, socket_name, sizeof(sun.sun_path));

		if (connect(ctl_sock,
		    (struct sockaddr *)&sun, sizeof(sun)) == -1)
			err(1, "connect: %s", socket_name);

		if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
			err(1, "malloc");
		imsg_init(ibuf, ctl_sock);
	}

	switch (res->action) {
	case CMD_START:
		ret = vm_start(res->id, res->name, res->size, res->nifs,
		    res->nets, res->ndisks, res->disks, res->path);
		if (ret) {
			errno = ret;
			err(1, "start VM operation failed");
		}
		break;
	case CMD_STOP:
		terminate_vm(res->id, res->name);
		break;
	case CMD_STATUS:
		get_info_vm(res->id, res->name, 0);
		break;
	case CMD_CONSOLE:
		get_info_vm(res->id, res->name, 1);
		break;
	case CMD_LOAD:
		imsg_compose(ibuf, IMSG_VMDOP_LOAD, 0, 0, -1,
		    res->path, strlen(res->path) + 1);
		break;
	case CMD_LOG:
		imsg_compose(ibuf, IMSG_CTL_VERBOSE, 0, 0, -1,
		    &res->verbose, sizeof(res->verbose));
		break;
	case CMD_RELOAD:
		imsg_compose(ibuf, IMSG_VMDOP_RELOAD, 0, 0, -1, NULL, 0);
		break;
	case CMD_RESET:
		imsg_compose(ibuf, IMSG_CTL_RESET, 0, 0, -1,
		    &res->mode, sizeof(res->mode));
		break;
	case CMD_CREATE:
	case NONE:
		break;
	}

	action = res->action;
	parse_free(res);

	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
			err(1, "write error");

	while (!done) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");

		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				errx(1, "imsg_get error");
			if (n == 0)
				break;

			if (imsg.hdr.type == IMSG_CTL_FAIL) {
				if (IMSG_DATA_SIZE(&imsg) == sizeof(ret))
					memcpy(&ret, imsg.data, sizeof(ret));
				else
					ret = 0;
				if (ret != 0) {
					memcpy(&ret, imsg.data, sizeof(ret));
					errno = ret;
					err(1, "command failed");
				} else
					errx(1, "command failed");
			}

			ret = 0;
			switch (action) {
			case CMD_START:
				done = vm_start_complete(&imsg, &ret,
				    tty_autoconnect);
				break;
			case CMD_STOP:
				done = terminate_vm_complete(&imsg, &ret);
				break;
			case CMD_CONSOLE:
			case CMD_STATUS:
				done = add_info(&imsg, &ret);
				break;
			default:
				done = 1;
				break;
			}

			imsg_free(&imsg);
		}
	}

	return (0);
}

void
parse_free(struct parse_result *res)
{
	size_t	 i;

	free(res->name);
	free(res->path);
	for (i = 0; i < res->ndisks; i++)
		free(res->disks[i]);
	free(res->disks);
	memset(res, 0, sizeof(*res));
}

int
parse_ifs(struct parse_result *res, char *word, int val)
{
	const char	*error;

	if (word != NULL) {
		val = strtonum(word, 0, INT_MAX, &error);
		if (error != NULL)  {
			warnx("invalid count \"%s\": %s", word, error);
			return (-1);
		}
	}
	res->nifs = val;

	return (0);
}

int
parse_network(struct parse_result *res, char *word)
{
	char		**nets;
	char		*s;

	if ((nets = reallocarray(res->nets, res->nnets + 1,
	    sizeof(char *))) == NULL) {
		warn("reallocarray");
		return (-1);
	}
	if ((s = strdup(word)) == NULL) {
		warn("strdup");
		return (-1);
	}
	nets[res->nnets] = s;
	res->nets = nets;
	res->nnets++;

	return (0);
}

int
parse_size(struct parse_result *res, char *word, long long val)
{
	if (word != NULL) {
		if (scan_scaled(word, &val) != 0) {
			warn("invalid size: %s", word);
			return (-1);
		}
	}

	if (val < (1024 * 1024)) {
		warnx("size must be at least one megabyte");
		return (-1);
	} else
		res->size = val / 1024 / 1024;

	if ((res->size * 1024 * 1024) != val)
		warnx("size rounded to %lld megabytes", res->size);

	return (0);
}

int
parse_disk(struct parse_result *res, char *word)
{
	char		**disks;
	char		*s;

	if ((disks = reallocarray(res->disks, res->ndisks + 1,
	    sizeof(char *))) == NULL) {
		warn("reallocarray");
		return (-1);
	}
	if ((s = strdup(word)) == NULL) {
		warn("strdup");
		return (-1);
	}
	disks[res->ndisks] = s;
	res->disks = disks;
	res->ndisks++;

	return (0);
}

int
parse_vmid(struct parse_result *res, char *word)
{
	const char	*error;
	uint32_t	 id;

	if (word == NULL) {
		warnx("missing vmid argument");
		return (-1);
	}
	id = strtonum(word, 0, UINT32_MAX, &error);
	if (error == NULL) {
		res->id = id;
		res->name = NULL;
	} else {
		if (strlen(word) >= VMM_MAX_NAME_LEN) {
			warnx("name too long");
			return (-1);
		}
		res->id = 0;
		if ((res->name = strdup(word)) == NULL)
			errx(1, "strdup");
	}

	return (0);
}

int
ctl_create(struct parse_result *res, int argc, char *argv[])
{
	int		 ch, ret;
	const char	*paths[2];

	if (argc < 2)
		ctl_usage(res->ctl);

	paths[0] = argv[1];
	paths[1] = NULL;
	if (pledge("stdio rpath wpath cpath", NULL) == -1)
		err(1, "pledge");
	argc--;
	argv++;

	while ((ch = getopt(argc, argv, "s:")) != -1) {
		switch (ch) {
		case 's':
			if (parse_size(res, optarg, 0) != 0)
				errx(1, "invalid size: %s", optarg);
			break;
		default:
			ctl_usage(res->ctl);
			/* NOTREACHED */
		}
	}

	if (res->size == 0) {
		fprintf(stderr, "missing size argument\n");
		ctl_usage(res->ctl);
	}
	ret = create_imagefile(paths[0], res->size);
	if (ret != 0) {
		errno = ret;
		err(1, "create imagefile operation failed");
	} else
		warnx("imagefile created");
	return (0);
}

int
ctl_status(struct parse_result *res, int argc, char *argv[])
{
	if (argc == 2) {
		if (parse_vmid(res, argv[1]) == -1)
			errx(1, "invalid id: %s", argv[1]);
	} else if (argc > 2)
		ctl_usage(res->ctl);

	return (vmmaction(res));
}

int
ctl_load(struct parse_result *res, int argc, char *argv[])
{
	if (argc != 2)
		ctl_usage(res->ctl);

	if ((res->path = strdup(argv[1])) == NULL)
		err(1, "strdup");

	return (vmmaction(res));
}

int
ctl_log(struct parse_result *res, int argc, char *argv[])
{
	if (argc != 2)
		ctl_usage(res->ctl);

	if (strncasecmp("brief", argv[1], strlen(argv[1])) == 0)
		res->verbose = 0;
	else if (strncasecmp("verbose", argv[1], strlen(argv[1])) == 0)
		res->verbose = 2;
	else
		ctl_usage(res->ctl);

	return (vmmaction(res));
}

int
ctl_reload(struct parse_result *res, int argc, char *argv[])
{
	if (argc != 1)
		ctl_usage(res->ctl);

	return (vmmaction(res));
}

int
ctl_reset(struct parse_result *res, int argc, char *argv[])
{
	if (argc == 2) {
		if (strcasecmp("all", argv[1]) == 0)
			res->mode = CONFIG_ALL;
		else if (strcasecmp("vms", argv[1]) == 0)
			res->mode = CONFIG_VMS;
		else if (strcasecmp("switches", argv[1]) == 0)
			res->mode = CONFIG_SWITCHES;
		else
			ctl_usage(res->ctl);
	} else if (argc > 2)
		ctl_usage(res->ctl);

	if (res->mode == 0)
		res->mode = CONFIG_ALL;

	return (vmmaction(res));
}

int
ctl_start(struct parse_result *res, int argc, char *argv[])
{
	int		 ch, i;
	char		 path[PATH_MAX];

	if (argc < 2)
		ctl_usage(res->ctl);

	if (parse_vmid(res, argv[1]) == -1)
		errx(1, "invalid id: %s", argv[1]);

	argc--;
	argv++;

	while ((ch = getopt(argc, argv, "b:cLm:n:d:i:")) != -1) {
		switch (ch) {
		case 'b':
			if (res->path)
				errx(1, "boot image specified multiple times");
			if (realpath(optarg, path) == NULL)
				err(1, "invalid boot image path");
			if ((res->path = strdup(path)) == NULL)
				errx(1, "strdup");
			break;
		case 'c':
			tty_autoconnect = 1;
			break;
		case 'L':
			if (parse_network(res, ".") != 0)
				errx(1, "invalid network: %s", optarg);
			break;
		case 'm':
			if (res->size)
				errx(1, "memory specified multiple times");
			if (parse_size(res, optarg, 0) != 0)
				errx(1, "invalid memory size: %s", optarg);
			break;
		case 'n':
			if (parse_network(res, optarg) != 0)
				errx(1, "invalid network: %s", optarg);
			break;
		case 'd':
			if (realpath(optarg, path) == NULL)
				err(1, "invalid disk path");
			if (parse_disk(res, path) != 0)
				errx(1, "invalid disk: %s", optarg);
			break;
		case 'i':
			if (res->nifs != -1)
				errx(1, "interfaces specified multiple times");
			if (parse_ifs(res, optarg, 0) != 0)
				errx(1, "invalid interface count: %s", optarg);
			break;
		default:
			ctl_usage(res->ctl);
			/* NOTREACHED */
		}
	}

	for (i = res->nnets; i < res->nifs; i++) {
		/* Add interface that is not attached to a switch */
		if (parse_network(res, "") == -1)
			return (-1);
	}
	if (res->nnets > res->nifs)
		res->nifs = res->nnets;

	return (vmmaction(res));
}

int
ctl_stop(struct parse_result *res, int argc, char *argv[])
{
	if (argc == 2) {
		if (parse_vmid(res, argv[1]) == -1)
			errx(1, "invalid id: %s", argv[1]);
	} else if (argc != 2)
		ctl_usage(res->ctl);

	return (vmmaction(res));
}

int
ctl_console(struct parse_result *res, int argc, char *argv[])
{
	if (argc == 2) {
		if (parse_vmid(res, argv[1]) == -1)
			errx(1, "invalid id: %s", argv[1]);
	} else if (argc != 2)
		ctl_usage(res->ctl);

	return (vmmaction(res));
}

__dead void
ctl_openconsole(const char *name)
{
	closefrom(STDERR_FILENO + 1);
	execl(VMCTL_CU, VMCTL_CU, "-l", name, "-s", "9600", (char *)NULL);
	err(1, "failed to open the console");
}
@


1.27
log
@Report error for vmctl commands that need root privileges.

specifically: vmctl (load|reload|reset|log)

Reported by Christian Barthel
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2017/04/19 15:38:32 reyk Exp $	*/
d253 5
a257 1
				if (IMSG_DATA_SIZE(&imsg) == sizeof(ret)) {
@


1.26
log
@Add support for dynamic "NAT" interfaces (-L/local interface).

When a local interface is configured, vmd configures a /31 address on
the tap(4) interface of the host and provides another IP in the same
subnet via DHCP (BOOTP) to the VM.  vmd runs an internal BOOTP server
that replies with IP, gateway, and DNS addresses to the VM.  The
built-in server only ever responds to the VM on the inside and cannot
leak its DHCP responses to the outside.

Thanks to Uwe Werler, Josh Grosse, and some others for testing!

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2017/04/06 18:07:13 reyk Exp $	*/
a215 1
		done = 1;
a219 1
		done = 1;
a222 1
		done = 1;
a226 1
		done = 1;
d256 3
a258 6
					warn("command failed");
				} else {
					warnx("command failed");
				}
				done = 1;
				break;
@


1.25
log
@Do not expose vmm(4) VM IDs to the user, use vmd(8)'s IDs instead.

Each VM has two IDs: one from the kernel (vmm) and a different one
from userland (vmd).  The vmm ID is not consistent and incremented on
every boot during runtimg of the host system.  The vmd ID remains the
same during the lifetime of a configured VM, even after reboots.
Configured VMs will even get and keep their IDs when the configuration
is loaded.  This is more what users expect.

Pointed out and tested by otto@@

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2017/03/25 16:28:25 reyk Exp $	*/
d68 1
a68 1
	    " [-c] [-b image] [-m size]\n"
d542 1
a542 1
	while ((ch = getopt(argc, argv, "b:cm:n:d:i:")) != -1) {
d554 4
@


1.24
log
@Boot using BIOS from /etc/firmware/vmm-bios by default.

Instead of using the internal "vmboot", VMs will now be booted using
the external BIOS firmware in /etc/firmware/vmm-bios (which is subject
to a LGPLv3 license).  Direct booting of OpenBSD kernels or
non-default BIOS images is still supported for now using the -b/boot
option that is replacing the -k/kernel option.

As requested by Theo, vmd(8) fails if neither the default BIOS is
found nor a kernel has been specified in the VM configuration.  The
"vmm" BIOS has to be installed using fw_update(1), which will be done
automatically in most cases where the OpenBSD can fetch it after
install/upgrade.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2017/03/01 21:22:57 reyk Exp $	*/
d197 2
a198 2
		ret = vm_start(res->name, res->size, res->nifs, res->nets,
		    res->ndisks, res->disks, res->path);
d536 3
a538 2
	if ((res->name = strdup(argv[1])) == NULL)
		errx(1, "strdup");
@


1.23
log
@Rename start_vm_complete to vm_start_complete for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2017/03/01 21:15:26 mlarkin Exp $	*/
d68 1
a68 1
	    " [-c] [-k kernel] [-m size]\n"
d541 1
a541 1
	while ((ch = getopt(argc, argv, "ck:m:n:d:i:")) != -1) {
d543 1
a543 4
		case 'c':
			tty_autoconnect = 1;
			break;
		case 'k':
d545 1
a545 1
				errx(1, "kernel specified multiple times");
d547 1
a547 1
				err(1, "invalid kernel path");
d550 3
@


1.22
log
@unbreak vmctl build by renaming a function that now conflicts with
something from vmd.h . Temporary fix until the original committer can
fix it the way he desires.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2017/03/01 07:43:33 reyk Exp $	*/
d271 1
a271 1
				done = start_vm_complete(&imsg, &ret,
@


1.21
log
@Add "owner" option to set a user/group ownership for pre-configured VMs

This allows matching users to start or stop VMs that they "own" and to
access the console accordingly.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2017/01/11 22:38:10 reyk Exp $	*/
d197 1
a197 1
		ret = start_vm(res->name, res->size, res->nifs, res->nets,
@


1.20
log
@Add imsg communication channel between vmd and invividual VMs.
For now, this is only used to forward "log verbose|brief" requests,
but it will be used for better things later.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2016/11/26 18:37:32 reyk Exp $	*/
d154 1
a154 1
		if (pledge("stdio rpath exec unix", NULL) == -1)
@


1.19
log
@Add the vmctl start -n option to specify add a network interface to
the specified virtual switch from the command line.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2016/10/12 19:10:03 reyk Exp $	*/
d53 1
d64 1
d218 5
d477 16
@


1.18
log
@Fix functionality and semantics of vmctl load/reload/reset.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2016/05/10 11:00:54 mlarkin Exp $	*/
d66 2
a67 1
	    " [-c] -k kernel -m size [-i count] [-d disk]*" },
d195 1
a195 1
		ret = start_vm(res->name, res->size, res->nifs,
d312 23
d507 1
a507 1
	int		 ch;
d518 1
a518 1
	while ((ch = getopt(argc, argv, "ck:m:d:i:")) != -1) {
d537 4
d558 8
@


1.17
log
@
move some argument checking from vmmaction() to start_vm()

from a diff posted to tech@@ by Fabien Siron, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2016/04/25 15:14:34 mlarkin Exp $	*/
d53 2
d62 3
a64 2
	{ "load",	CMD_LOAD,	ctl_load,	"[path]" },
	{ "reload",	CMD_RELOAD,	ctl_load,	"[path]" },
d210 5
d216 1
a216 2
		imsg_compose(ibuf, IMSG_VMDOP_RELOAD, 0, 0, -1,
		    res->path, res->path == NULL ? 0 : strlen(res->path) + 1);
d219 3
a221 3
	case CMD_LOAD:
		imsg_compose(ibuf, IMSG_VMDOP_LOAD, 0, 0, -1,
		    res->path, res->path == NULL ? 0 : strlen(res->path) + 1);
d441 2
a442 1
	char	*config_file = NULL;
d444 28
a471 3
	if (argc == 2)
		config_file = argv[1];
	else if (argc > 2)
d474 2
a475 3
	if (config_file != NULL &&
	    (res->path = strdup(config_file)) == NULL)
		err(1, "strdup");
@


1.16
log
@
make vmctl 'create' usage description match the man page
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2016/03/17 19:40:43 krw Exp $	*/
a190 14
		/* XXX validation should be done in start_vm() */
		if (res->size < 1)
			errx(1, "specified memory size too small");
		if (res->path == NULL)
			errx(1, "no kernel specified");
		if (res->ndisks > VMM_MAX_DISKS_PER_VM)
			errx(1, "too many disks");
		else if (res->ndisks == 0)
			warnx("starting without disks");
		if (res->nifs == -1)
			res->nifs = 0;
		if (res->nifs == 0)
			warnx("starting without network interfaces");

@


1.15
log
@Last parameter to execl[e]() functions *must* be cast to a pointer.
Just NULL is not good practise as NULL is theoretically allowed to
be an integer rather than a pointer.

Use (char *)NULL consistently instead of scattering a few (char *)0
and (void *)NULL into the mix.

Prompted by and probably ok deraadt@@ millert@@ kettenis@@

Definitely ok mestre@@ ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2016/01/26 07:55:47 reyk Exp $	*/
d59 1
a59 1
	{ "create",	CMD_CREATE,	ctl_create,	"\"name\" -s size", 1 },
@


1.14
log
@The division "res->size /= 1024 / 1024" is a no-op: 1024 / 1024 is
evaluated first, resulting in res->size /= 1.  Remove the division and
the following check, as it can never fail; it is a left-over from
previous code that didn't check the size in the caller.

From Martin Natano
OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2016/01/05 16:25:34 semarie Exp $	*/
d544 1
a544 1
	execl(VMCTL_CU, VMCTL_CU, "-l", name, "-s", "9600", NULL);
@


1.13
log
@don't use the second argument of pledge(2) as the whitelist is not stabilized
for now.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2015/12/11 10:16:53 reyk Exp $	*/
a423 3
	res->size /= 1024 / 1024;
	if (res->size < 1)
		errx(1, "specified image size too small");
@


1.12
log
@The vmctl "id" argument can now be a number of or a vm name, eg.
vmctl stop 3
vmctl stop "openbsd.vm"
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 2015/12/11 09:24:10 reyk Exp $	*/
d403 1
a403 1
	if (pledge("stdio rpath wpath cpath", paths) == -1)
@


1.11
log
@Remove unused argument in parse_vmid()
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 2015/12/11 09:08:05 reyk Exp $	*/
d213 1
a213 1
		terminate_vm(res->id);
d216 1
a216 1
		get_info_vm(res->id, 0);
d219 1
a219 1
		get_info_vm(res->id, 1);
d376 11
a386 3
	if (error != NULL)  {
		warnx("invalid id: %s", error);
		return (-1);
a387 1
	res->id = id;
@


1.10
log
@Allow to specify relative pathnames on the command line (eg. -k ./bsd).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 2015/12/08 13:15:09 reyk Exp $	*/
d366 1
a366 1
parse_vmid(struct parse_result *res, char *word, uint32_t id)
d369 1
d371 8
a378 6
	if (word != NULL) {
		id = strtonum(word, 0, UINT32_MAX, &error);
		if (error != NULL)  {
			warnx("invalid id: %s", error);
			return (-1);
		}
d433 1
a433 1
		if (parse_vmid(res, argv[1], 0) == -1)
d516 1
a516 1
		if (parse_vmid(res, argv[1], 0) == -1)
d528 1
a528 1
		if (parse_vmid(res, argv[1], 0) == -1)
@


1.9
log
@style(9) says that is OK to not include sys/cdefs.h directly, as it
comes from sys/types.h (include-what-you-use doesn't know this policy).

Pointed out by Jan Schreiber
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 2015/12/08 08:02:15 reyk Exp $	*/
d458 2
a459 1
	int			 ch;
d477 3
a479 1
			if ((res->path = strdup(optarg)) == NULL)
d489 4
a492 2
			if (parse_disk(res, optarg) != 0)
				errx(1, "invalid memory size: %s", optarg);
@


1.8
log
@vmctl console - id is not optional
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 2015/12/08 08:01:20 reyk Exp $	*/
a22 1
#include <sys/cdefs.h>
d38 1
@


1.7
log
@Add "vmctl console" to connect to a specified VM console by id.

Requested by mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 2015/12/05 22:34:31 sobrado Exp $	*/
d58 1
a58 1
	{ "console",	CMD_CONSOLE,	ctl_console,	"[id]" },
@


1.6
log
@use argument names consistently.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 2015/12/05 17:30:34 claudio Exp $	*/
d50 1
d58 1
d216 4
a219 1
		get_info_vm(res->id);
d276 1
d514 20
@


1.5
log
@Another imsg_read user I did miss in my EAGAIN rampage.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 2015/12/05 04:40:05 deraadt Exp $	*/
d61 1
a61 1
	    " [-c] -k kernel -m memory [-i interfaces] [-d disk]*" },
@


1.4
log
@vmctl has no need to change the socket that talks to vmd.
discussed with reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 2015/12/04 15:40:17 reyk Exp $	*/
d239 1
a239 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.3
log
@Add -c option to "vmctl start" to automatically connect to the VM
console after startup.  This calls 'cu -l $TTY -s 9600' internally -
a "safe mode" for cu is proposed by tedu@@.

Requested by mlarkin@@
OK tedu@@ on the execl/cu chunk
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.2 2015/12/03 23:32:32 reyk Exp $	*/
d73 1
a73 1
	fprintf(stderr, "usage:\t%s [-s socket] command [arg ...]\n",
d97 1
a97 1
	while ((ch = getopt(argc, argv, "s:")) != -1) {
a98 3
		case 's':
			socket_name = optarg;
			break;
@


1.2
log
@Re-add the "load" and "reload" commands to vmctl: Instead of parsing
the configuration in vmctl directly, it now sends a (re)load request
to vmd.  The reload also resets the existing configuration status -
this doesn't do much difference yet but a future change will compare
if a specified VM is already running.  "load" will allow to add
configuration, while "reload" resets the state before loading.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.1 2015/12/03 21:45:45 reyk Exp $	*/
d43 1
d60 2
a61 2
	{ "start",	CMD_START,	ctl_start,
	    "\"name\" -k kernel -m memory [-i interfaces] [[-d disk] ...]" },
d149 1
a149 1
		if (pledge("stdio rpath unix", NULL) == -1)
d170 1
a170 1
	int			 ret;
d173 2
a174 1
		if ((ctl_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
d234 3
d266 1
a266 1
			switch (res->action) {
d268 2
a269 1
				done = start_vm_complete(&imsg, &ret);
a285 2
	parse_free(res);

d465 1
a465 1
	while ((ch = getopt(argc, argv, "k:m:d:i:")) != -1) {
d467 3
@


1.1
log
@Replace vmmctl with vmctl.  Also remove parse.y from the "new" vmctl.

As discussed with mlarkin@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 2015/12/03 13:08:44 reyk Exp $	*/
a41 1
static const char	*config_file = VMD_CONF;
d58 1
d217 10
a227 1
	case CMD_LOAD:
d434 2
d441 5
a445 3
	/* XXX send message to vmd(8) to load the configuration */
	errno = ENOSYS;
	return (-1);
@

