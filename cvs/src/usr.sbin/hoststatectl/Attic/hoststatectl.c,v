head	1.28;
access;
symbols
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16;
locks; strict;
comment	@ * @;


1.28
date	2007.12.07.17.27.05;	author deraadt;	state dead;
branches;
next	1.27;

1.27
date	2007.11.24.17.09.12;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.23.09.39.42;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.19.12.08.54;	author pyr;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.29.16.23.06;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.07.08.33.31;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.07.08.31.36;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.12.18.09.00;	author pyr;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.29.23.19.18;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.29.00.21.10;	author pyr;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.28.00.04.47;	author pyr;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.22.05.59.13;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.22.03.32.40;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.06.08.45.46;	author pyr;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.03.17.51.46;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.01.21.57.18;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.01.21.01.10;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.01.20.03.38;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.09.13.50.10;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.16.18.50.33;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.16.17.52.21;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.16.15.02.35;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.14.21.15;	author bernd;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.47.18;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.28
log
@hoststated/hoststatectl get repository copied (and de-tagged) into
relayd/relayctl.  This is a more suitable place for a daemon that has
grown out of it's initial roots of "monitoring and redirecting services
at various layers", into one that is "a full featured proxy, which
happens to know what is up/down"
@
text
@/*	$OpenBSD: hoststatectl.c,v 1.27 2007/11/24 17:09:12 reyk Exp $	*/

/*
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/un.h>

#include <net/if.h>
#include <net/if_media.h>
#include <net/if_types.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <event.h>

#include <openssl/ssl.h>

#include "hoststated.h"
#include "parser.h"

__dead void	 usage(void);
int		 show_summary_msg(struct imsg *, int);
int		 show_session_msg(struct imsg *);
int		 show_command_output(struct imsg *);
char		*print_service_status(int);
char		*print_host_status(int, int);
char		*print_table_status(int, int);
char		*print_relay_status(int);

struct imsgname {
	int type;
	char *name;
	void (*func)(struct imsg *);
};

struct imsgname *monitor_lookup(u_int8_t);
void		 monitor_host_status(struct imsg *);
void		 monitor_id(struct imsg *);
int		 monitor(struct imsg *);

struct imsgname imsgs[] = {
	{ IMSG_HOST_STATUS,		"host_status",	monitor_host_status },
	{ IMSG_CTL_SERVICE_DISABLE,	"ctl_disable_service",	monitor_id },
	{ IMSG_CTL_SERVICE_ENABLE,	"ctl_service_enable",	monitor_id },
	{ IMSG_CTL_TABLE_DISABLE,	"ctl_table_disable",	monitor_id },
	{ IMSG_CTL_TABLE_ENABLE,	"ctl_table_enable",	monitor_id },
	{ IMSG_CTL_HOST_DISABLE,	"ctl_host_disable",	monitor_id },
	{ IMSG_CTL_HOST_ENABLE,		"ctl_host_enable",	monitor_id },
	{ IMSG_CTL_TABLE_CHANGED,	"ctl_table_changed",	monitor_id },
	{ IMSG_CTL_PULL_RULESET,	"ctl_pull_ruleset",	monitor_id },
	{ IMSG_CTL_PUSH_RULESET,	"ctl_push_ruleset",	monitor_id },
	{ IMSG_SYNC,			"sync",			NULL },
	{ 0,				NULL,			NULL }
};
struct imsgname imsgunknown = {
	-1,				"<unknown>",		NULL
};

struct imsgbuf	*ibuf;

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s <command> [arg [...]]\n", __progname);
	exit(1);
}

/* dummy function so that hoststatectl does not need libevent */
void
imsg_event_add(struct imsgbuf *i)
{
	/* nothing */
}

int
main(int argc, char *argv[])
{
	struct sockaddr_un	 sun;
	struct parse_result	*res;
	struct imsg		 imsg;
	int			 ctl_sock;
	int			 done = 0;
	int			 n;

	/* parse options */
	if ((res = parse(argc - 1, argv + 1)) == NULL)
		exit(1);

	/* connect to hoststated control socket */
	if ((ctl_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "socket");

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	strlcpy(sun.sun_path, HOSTSTATED_SOCKET, sizeof(sun.sun_path));
 reconnect:
	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		/* Keep retrying if running in monitor mode */
		if (res->action == MONITOR &&
		    (errno == ENOENT || errno == ECONNREFUSED)) {
			usleep(100);
			goto reconnect;
		}
		err(1, "connect: %s", HOSTSTATED_SOCKET);
	}

	if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
		err(1, NULL);
	imsg_init(ibuf, ctl_sock, NULL);
	done = 0;

	/* process user request */
	switch (res->action) {
	case NONE:
		usage();
		/* not reached */
	case SHOW_SUM:
	case SHOW_HOSTS:
	case SHOW_RELAYS:
		imsg_compose(ibuf, IMSG_CTL_SHOW_SUM, 0, 0, -1, NULL, 0);
		printf("Type\t%4s\t%-24s\t%-7s\tStatus\n",
		    "Id", "Name", "Avlblty");
		break;
	case SHOW_SESSIONS:
		imsg_compose(ibuf, IMSG_CTL_SESSION, 0, 0, -1, NULL, 0);
		break;
	case SERV_ENABLE:
		imsg_compose(ibuf, IMSG_CTL_SERVICE_ENABLE, 0, 0, -1,
		    &res->id, sizeof(res->id));
		break;
	case SERV_DISABLE:
		imsg_compose(ibuf, IMSG_CTL_SERVICE_DISABLE, 0, 0, -1,
		    &res->id, sizeof(res->id));
		break;
	case TABLE_ENABLE:
		imsg_compose(ibuf, IMSG_CTL_TABLE_ENABLE, 0, 0, -1,
		    &res->id, sizeof(res->id));
		break;
	case TABLE_DISABLE:
		imsg_compose(ibuf, IMSG_CTL_TABLE_DISABLE, 0, 0, -1,
		    &res->id, sizeof(res->id));
		break;
	case HOST_ENABLE:
		imsg_compose(ibuf, IMSG_CTL_HOST_ENABLE, 0, 0, -1,
		    &res->id, sizeof(res->id));
		break;
	case HOST_DISABLE:
		imsg_compose(ibuf, IMSG_CTL_HOST_DISABLE, 0, 0, -1,
		    &res->id, sizeof(res->id));
		break;
	case SHUTDOWN:
		imsg_compose(ibuf, IMSG_CTL_SHUTDOWN, 0, 0, -1, NULL, 0);
		break;
	case POLL:
		imsg_compose(ibuf, IMSG_CTL_POLL, 0, 0, -1, NULL, 0);
		break;
	case RELOAD:
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, -1, NULL, 0);
		break;
	case MONITOR:
		imsg_compose(ibuf, IMSG_CTL_NOTIFY, 0, 0, -1, NULL, 0);
		break;
	}

	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) < 0)
			err(1, "write error");

	while (!done) {
		if ((n = imsg_read(ibuf)) == -1)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");

		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				errx(1, "imsg_get error");
			if (n == 0)
				break;
			switch (res->action) {
			case SHOW_SUM:
			case SHOW_HOSTS:
			case SHOW_RELAYS:
				done = show_summary_msg(&imsg, res->action);
				break;
			case SHOW_SESSIONS:
				done = show_session_msg(&imsg);
				break;
			case SERV_DISABLE:
			case SERV_ENABLE:
			case TABLE_DISABLE:
			case TABLE_ENABLE:
			case HOST_DISABLE:
			case HOST_ENABLE:
			case POLL:
			case RELOAD:
			case SHUTDOWN:
				done = show_command_output(&imsg);
				break;
			case NONE:
				break;
			case MONITOR:
				done = monitor(&imsg);
				break;
			}
			imsg_free(&imsg);
		}
	}
	close(ctl_sock);
	free(ibuf);

	return (0);
}

struct imsgname *
monitor_lookup(u_int8_t type)
{
	int i;

	for (i = 0; imsgs[i].name != NULL; i++)
		if (imsgs[i].type == type)
			return (&imsgs[i]);
	return (&imsgunknown);
}

void
monitor_host_status(struct imsg *imsg)
{
	struct ctl_status	 cs;

	memcpy(&cs, imsg->data, sizeof(cs));
	printf("\tid: %u\n", cs.id);
	printf("\tstate: ");
	switch (cs.up) {
	case HOST_UP:
		printf("up\n");
		break;
	case HOST_DOWN:
		printf("down\n");
		break;
	default:
		printf("unknown\n");
		break;
	}
}

void
monitor_id(struct imsg *imsg)
{
	struct ctl_id		 id;

	memcpy(&id, imsg->data, sizeof(id));
	printf("\tid: %u\n", id.id);
	if (strlen(id.name))
		printf("\tname: %s\n", id.name);
}

int
monitor(struct imsg *imsg)
{
	time_t			 now;
	int			 done = 0;
	struct imsgname		*imn;

	now = time(NULL);

	imn = monitor_lookup(imsg->hdr.type);
	printf("%s: imsg type %u len %u peerid %u pid %d\n", imn->name,
	    imsg->hdr.type, imsg->hdr.len, imsg->hdr.peerid, imsg->hdr.pid);
	printf("\ttimestamp: %u, %s", now, ctime(&now));
	if (imn->type == -1)
		done = 1;
	if (imn->func != NULL)
		(*imn->func)(imsg);

	return (done);
}

int
show_summary_msg(struct imsg *imsg, int type)
{
	struct service		*service;
	struct table		*table;
	struct host		*host;
	struct relay		*rlay;
	struct ctl_stats	 stats[RELAY_MAXPROC], crs;
	int			 i;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SERVICE:
		if (type == SHOW_RELAYS)
			break;
		service = imsg->data;
		printf("service\t%4u\t%-24s\t%-7s\t%s\n",
		    service->conf.id, service->conf.name, "",
		    print_service_status(service->conf.flags));
		break;
	case IMSG_CTL_TABLE:
		if (type == SHOW_RELAYS)
			break;
		table = imsg->data;
		printf("table\t%4u\t%-24s\t%-7s\t%s\n",
		    table->conf.id, table->conf.name, "",
		    print_table_status(table->up, table->conf.flags));
		break;
	case IMSG_CTL_HOST:
		if (type == SHOW_RELAYS)
			break;
		host = imsg->data;
		printf("host\t%4u\t%-24s\t%-7s\t%s\n",
		    host->conf.id, host->conf.name,
		    print_availability(host->check_cnt, host->up_cnt),
		    print_host_status(host->up, host->flags));
		if (type == SHOW_HOSTS && host->check_cnt) {
			printf("\t%4s\ttotal: %lu/%lu checks",
			    "", host->up_cnt, host->check_cnt);
			if (host->retry_cnt)
				printf(", %d retries", host->retry_cnt);
			printf("\n");
		}
		break;
	case IMSG_CTL_RELAY:
		if (type == SHOW_HOSTS)
			break;
		rlay = imsg->data;
		printf("relay\t%4u\t%-24s\t%-7s\t%s\n",
		    rlay->conf.id, rlay->conf.name, "",
		    print_relay_status(rlay->conf.flags));
		break;
	case IMSG_CTL_STATISTICS:
		if (type != SHOW_RELAYS)
			break;
		bcopy(imsg->data, &stats, sizeof(stats));
		bzero(&crs, sizeof(crs));
		crs.interval = stats[0].interval;
		for (i = 0; stats[i].id != EMPTY_ID; i++) {
			crs.cnt += stats[i].cnt;
			crs.last += stats[i].last;
			crs.avg += stats[i].avg;
			crs.last_hour += stats[i].last_hour;
			crs.avg_hour += stats[i].avg_hour;
			crs.last_day += stats[i].last_day;
			crs.avg_day += stats[i].avg_day;
		}
		if (crs.cnt == 0)
			break;
		printf("\t%4s\ttotal: %lu sessions\n"
		    "\t%4s\tlast: %lu/%us %lu/h %lu/d sessions\n"
		    "\t%4s\taverage: %lu/%us %lu/h %lu/d sessions\n",
		    "", crs.cnt,
		    "", crs.last, crs.interval,
		    crs.last_hour, crs.last_day,
		    "", crs.avg, crs.interval,
		    crs.avg_hour, crs.avg_day);
		break;
	case IMSG_CTL_END:
		return (1);
	default:
		errx(1, "wrong message in summary: %u", imsg->hdr.type);
		break;
	}
	return (0);
}

int
show_session_msg(struct imsg *imsg)
{
	struct session		*con;
	char			 a[128], b[128];
	struct timeval		 tv_now;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SESSION:
		con = imsg->data;

		(void)print_host(&con->in.ss, a, sizeof(a));
		(void)print_host(&con->out.ss, b, sizeof(b));
		printf("session %u:%u %s:%u -> %s:%u\t%s\n",
		    imsg->hdr.peerid, con->id,
		    a, ntohs(con->in.port), b, ntohs(con->out.port),
		    con->done ? "DONE" : "RUNNING");

		if (gettimeofday(&tv_now, NULL))
			fatal("show_session_msg: gettimeofday");
		print_time(&tv_now, &con->tv_start, a, sizeof(a));
		print_time(&tv_now, &con->tv_last, b, sizeof(b));
		printf("\tage %s, idle %s, relay %u", a, b, con->relayid);
		if (con->mark)
			printf(", mark %u", con->mark);
		printf("\n");
		break;
	case IMSG_CTL_END:
		return (1);
	default:
		errx(1, "wrong message in session: %u", imsg->hdr.type);
		break;
	}
	return (0);
}

int
show_command_output(struct imsg *imsg)
{
	switch (imsg->hdr.type) {
	case IMSG_CTL_OK:
		printf("command succeeded\n");
		break;
	case IMSG_CTL_FAIL:
		printf("command failed\n");
		break;
	default:
		errx(1, "wrong message in summary: %u", imsg->hdr.type);
	}
	return (1);
}

char *
print_service_status(int flags)
{
	if (flags & F_DISABLE) {
		return ("disabled");
	} else if (flags & F_DOWN) {
		return ("down");
	} else if (flags & F_BACKUP) {
		return ("active (using backup table)");
	} else
		return ("active");
}

char *
print_table_status(int up, int fl)
{
	static char buf[1024];

	bzero(buf, sizeof(buf));

	if (fl & F_DISABLE) {
		snprintf(buf, sizeof(buf) - 1, "disabled");
	} else if (!up) {
		snprintf(buf, sizeof(buf) - 1, "empty");
	} else
		snprintf(buf, sizeof(buf) - 1, "active (%d hosts up)", up);
	return (buf);
}

char *
print_host_status(int status, int fl)
{
	if (fl & F_DISABLE)
		return ("disabled");

	switch (status) {
	case HOST_DOWN:
		return ("down");
	case HOST_UNKNOWN:
		return ("unknown");
	case HOST_UP:
		return ("up");
	default:
		errx(1, "invalid status: %d", status);
	}
}

char *
print_relay_status(int flags)
{
	if (flags & F_DISABLE) {
		return ("disabled");
	} else
		return ("active");
}

@


1.27
log
@style(9) for includes
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.26 2007/11/23 09:39:42 reyk Exp $	*/
@


1.26
log
@re-implement the "mark" action and document it in the manpage:
it is possible to attach a mark to a session based on matching an
entity (header, url, cookie, ...) and add conditional action for this
mark. it works a bit like the tag/tagged keywords in pf, but i decided
to pick a different name to avoid confusion.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.25 2007/10/19 12:08:54 pyr Exp $	*/
d26 1
a26 2
#include <netinet/in.h>
#include <arpa/inet.h>
d30 2
@


1.25
log
@Add the ability to schedule an immediate check through hoststatectl.
Especially useful when interval is rather long.
I was supposed to commit this before 4.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.24 2007/09/29 16:23:06 pyr Exp $	*/
d413 4
a416 1
		printf("\tage %s, idle %s, relay %u\n", a, b, con->relayid);
@


1.24
log
@KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.23 2007/09/28 13:29:56 pyr Exp $	*/
d180 3
d221 1
@


1.23
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.22 2007/09/07 08:33:31 reyk Exp $	*/
d66 1
a66 1
	{ IMSG_HOST_STATUS,		"host_status",		monitor_host_status },
@


1.22
log
@add a "show sessions" command to dump the complete list of running relay
sessions.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.20 2007/06/12 18:09:00 pyr Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.21
log
@simple style change in the switch
@
text
@d47 1
d150 3
d209 3
d382 33
@


1.20
log
@reflect msf's changes to the imsg framework in hoststated.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.19 2007/05/29 23:19:18 pyr Exp $	*/
a200 2
				done = show_summary_msg(&imsg, SHOW_SUM);
				break;
a201 2
				done = show_summary_msg(&imsg, SHOW_HOSTS);
				break;
d203 1
a203 1
				done = show_summary_msg(&imsg, SHOW_RELAYS);
@


1.19
log
@allow the control handling code to send messages back to the parent.
forward IMSG_CTL_RELOAD which ends up not doing anything for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.18 2007/05/29 00:21:10 pyr Exp $	*/
d145 1
a145 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_SUM, 0, 0, NULL, 0);
d150 1
a150 1
		imsg_compose(ibuf, IMSG_CTL_SERVICE_ENABLE, 0, 0,
d154 1
a154 1
		imsg_compose(ibuf, IMSG_CTL_SERVICE_DISABLE, 0, 0,
d158 1
a158 1
		imsg_compose(ibuf, IMSG_CTL_TABLE_ENABLE, 0, 0,
d162 1
a162 1
		imsg_compose(ibuf, IMSG_CTL_TABLE_DISABLE, 0, 0,
d166 1
a166 1
		imsg_compose(ibuf, IMSG_CTL_HOST_ENABLE, 0, 0,
d170 1
a170 1
		imsg_compose(ibuf, IMSG_CTL_HOST_DISABLE, 0, 0,
d174 1
a174 1
		imsg_compose(ibuf, IMSG_CTL_SHUTDOWN, 0, 0, NULL, 0);
d177 1
a177 1
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, NULL, 0);
d180 1
a180 1
		imsg_compose(ibuf, IMSG_CTL_NOTIFY, 0, 0, NULL, 0);
@


1.18
log
@move struct relay to the runtime + config scheme.
this time around, include hoststatectl changes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.17 2007/05/28 00:04:47 pyr Exp $	*/
d215 2
a218 2
			case RELOAD:
			case SHUTDOWN:
@


1.17
log
@Reflect recent hoststated changes into hoststatectl
This unbreaks the tree.
Fixed from the depth of the OpenBSD lair.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.16 2007/02/22 05:59:13 reyk Exp $	*/
d346 2
a347 2
		    rlay->id, rlay->name, "",
		    print_relay_status(rlay->flags));
@


1.16
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.15 2007/02/22 03:32:40 reyk Exp $	*/
d314 2
a315 2
		    service->id, service->name, "",
		    print_service_status(service->flags));
d322 2
a323 2
		    table->id, table->name, "",
		    print_table_status(table->up, table->flags));
d330 1
a330 1
		    host->id, host->name,
@


1.15
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.14 2007/02/06 08:45:46 pyr Exp $	*/
d306 1
a306 1
	int		 	 i;
@


1.14
log
@inform hoststatectl monitor of ruleset changes and table syncs.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.13 2007/02/03 17:51:46 reyk Exp $	*/
d46 1
a46 1
int		 show_summary_msg(struct imsg *);
d51 1
d143 2
d146 2
a147 1
		printf("Type\t%4s\t%-24s\tStatus\n", "Id", "Name");
d201 7
a207 1
				done = show_summary_msg(&imsg);
d299 1
a299 1
show_summary_msg(struct imsg *imsg)
d301 6
a306 3
	struct service	*service;
	struct table	*table;
	struct host	*host;
d310 2
d313 2
a314 2
		printf("service\t%4u\t%-24s\t%s\n",
		    service->id, service->name,
d318 2
d321 2
a322 2
		printf("table\t%4u\t%-24s\t%s",
		    table->id, table->name,
a323 1
		printf("\n");
d326 2
d329 1
a329 1
		printf("host\t%4u\t%-24s\t%s\n",
d331 1
d333 41
d446 10
@


1.13
log
@wait for hoststated to become available in monitor mode.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.11 2007/02/01 21:01:10 reyk Exp $	*/
d71 3
@


1.12
log
@print id name in the monitor output if available
@
text
@d33 1
d117 8
a124 1
	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1)
d126 1
@


1.11
log
@modify the imsg monitor to look even nicer and to use a more flexible
API (inspired by the ipsec pfkey monitor).

ok pyr@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.9 2007/01/29 14:23:31 pyr Exp $	*/
d251 2
@


1.10
log
@add a monitor mode to hoststatectl to continuously report changes in
hoststated.
ok reyk@@, "looks nice and clean" niallo@@
@
text
@a46 1
int		 monitor(struct imsg *);
d51 26
d212 41
d257 2
a258 3
	int			 done;
	struct ctl_status	 cs; 
	struct ctl_id		 id; 
a259 1
	done = 0;
d261 6
a266 35
	printf("got message of size %u on  %s", imsg->hdr.len, ctime(&now));
	switch (imsg->hdr.type) {
	case IMSG_HOST_STATUS:
		memcpy(&cs, imsg->data, sizeof(cs));
		printf("HOST_STATUS: %u is in state %d\n", cs.id, cs.up);
		break;
	case IMSG_CTL_SERVICE_DISABLE:
		memcpy(&id, imsg->data, sizeof(id));
		printf("CTL_SERVICE_DISABLE: %u\n", id.id);
		break;
	case IMSG_CTL_SERVICE_ENABLE:
		memcpy(&id, imsg->data, sizeof(id));
		printf("CTL_SERVICE_ENABLE: %u\n", id.id);
		break;
	case IMSG_CTL_TABLE_DISABLE:
		memcpy(&id, imsg->data, sizeof(id));
		printf("CTL_TABLE_DISABLE: %u\n", id.id);
		break;
	case IMSG_CTL_TABLE_ENABLE:
		memcpy(&id, imsg->data, sizeof(id));
		printf("CTL_TABLE_ENABLE: %u\n", id.id);
		break;
	case IMSG_CTL_HOST_DISABLE:
		memcpy(&id, imsg->data, sizeof(id));
		printf("CTL_HOST_DISABLE: %u\n", id.id);
		break;
	case IMSG_CTL_HOST_ENABLE:
		memcpy(&id, imsg->data, sizeof(id));
		printf("CTL_HOST_ENABLE: %u\n", id.id);
		break;
	case IMSG_SYNC:
		printf("SYNC\n");
		break;
	default:
		printf("INVALID\n");
d268 3
a270 2
		break;
	}
@


1.9
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.8 2007/01/09 13:50:10 pyr Exp $	*/
d47 1
d138 3
d174 3
d185 51
@


1.8
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.7 2007/01/09 00:45:32 deraadt Exp $	*/
d38 2
@


1.7
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststatectl.c,v 1.6 2006/12/16 18:50:33 reyk Exp $	*/
d60 1
a60 1
/* dummy function so that hostatectl does not need libevent */
d81 1
a81 1
	/* connect to hostated control socket */
d87 1
a87 1
	strlcpy(sun.sun_path, HOSTATED_SOCKET, sizeof(sun.sun_path));
d89 1
a89 1
		err(1, "connect: %s", HOSTATED_SOCKET);
@


1.6
log
@- allow to use host/service/table names instead of Ids in hostatectl.
- minor change of the "hostatectl show" command output
- increase the max service and tag names (max pf tag name size is 64 now!)

thanks to pyr who found a bug in my initial diff
@
text
@d1 1
a1 1
/*	$OpenBSD: hostatectl.c,v 1.5 2006/12/16 17:52:21 deraadt Exp $	*/
d39 1
a39 1
#include "hostated.h"
@


1.5
log
@spacing, plus dubious \% in format string
@
text
@d1 1
a1 1
/*	$OpenBSD: hostatectl.c,v 1.4 2006/12/16 15:02:35 reyk Exp $	*/
d103 1
a103 1
		printf("type\t%4s\t%-16s\tstatus\n\n", "id", "name");
d188 1
a188 1
		printf("service\t%4u\t%-16s\t%s\n",
d194 1
a194 1
		printf("table\t%4u\t%-16s\t%s",
d201 1
a201 1
		printf("host\t%4u\t%-16s\t%s\n",
@


1.4
log
@more spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hostatectl.c,v 1.3 2006/12/16 14:21:15 bernd Exp $	*/
d103 1
a103 1
		printf("type\t\%4s\t%-16s\tstatus\n\n", "id", "name");
d107 1
a107 1
		     &res->id, sizeof(res->id));
d115 1
a115 1
		     &res->id, sizeof(res->id));
d119 1
a119 1
		     &res->id, sizeof(res->id));
d123 1
a123 1
		     &res->id, sizeof(res->id));
d127 1
a127 1
		     &res->id, sizeof(res->id));
@


1.3
log
@Fix two comments. ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hostatectl.c,v 1.2 2006/12/16 12:47:18 reyk Exp $	*/
d107 1
a107 1
			     &res->id, sizeof(res->id));
d111 1
a111 1
			     &res->id, sizeof(res->id));
d115 1
a115 1
			     &res->id, sizeof(res->id));
d119 1
a119 1
			     &res->id, sizeof(res->id));
d123 1
a123 1
			     &res->id, sizeof(res->id));
d127 1
a127 1
			     &res->id, sizeof(res->id));
d255 1
a255 2
		snprintf(buf, sizeof(buf) - 1, "active (%d hosts up)",
			 up);
@


1.2
log
@knf, spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hostatectl.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d60 1
a60 1
/* dummy function so that ospfctl does not need libevent */
d81 1
a81 1
	/* connect to ospfd control socket */
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d189 2
a190 2
		       service->id, service->name,
		       print_service_status(service->flags));
d195 2
a196 2
		       table->id, table->name,
		       print_table_status(table->up, table->flags));
d202 2
a203 2
		       host->id, host->name,
		       print_host_status(host->up, host->flags));
d234 1
a234 1
		return("disabled");
d236 1
a236 1
		return("down");
d238 1
a238 1
		return("active (using backup table)");
d240 1
a240 1
		return("active");
d264 1
a264 1
		return("disabled");
d268 1
a268 1
		return("down");
d270 1
a270 1
		return("unknown");
d272 1
a272 1
		return("up");
@

