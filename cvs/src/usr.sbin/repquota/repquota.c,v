head	1.35;
access;
symbols
	OPENBSD_6_2:1.35.0.8
	OPENBSD_6_2_BASE:1.35
	OPENBSD_6_1:1.35.0.6
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.35.0.2
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.31.0.6
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.30.0.16
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.14
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.12
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.10
	OPENBSD_5_0:1.30.0.8
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.6
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.4
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.10
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.6
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.4
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.28.0.4
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.27.0.6
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.4
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.25.0.8
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.6
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.14.0.4
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.12
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.10
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.8
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.6
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2016.03.16.15.41.11;	author krw;	state Exp;
branches;
next	1.34;
commitid	JEVxsRygqcjPtWTf;

1.34
date	2015.10.26.17.55.32;	author zhuk;	state Exp;
branches;
next	1.33;
commitid	z0N4R42NxAQI587l;

1.33
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	z3HrihslRYb4HqW9;

1.32
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	Uu5nFG3wCl0LACBb;

1.31
date	2013.11.12.22.27.13;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.27.23.59.54;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.07.14.23.55;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.18.23.17.59;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.03.19.02.30;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.01.04.31.11;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.26.19.47.10;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.25.15.54.17;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.23.36.54;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.30.15.30.05;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.30.20.52.42;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.30.20.47.42;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.06.21.49.21;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.06.18.29.37;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.29.09.45.08;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.28.08;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.15.05.19.10;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.14.23.03.05;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.21.09.50.00;	author pjanzen;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.11.18.47.29;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.01.03.24.08;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.01.17.07.14.24;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.12.12.20.32.17;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.04.12.30.21;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.25.11.04.14;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.23.41.45;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.01.07.05.28.06;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.06.21.41.00;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.24.14.32.22;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.35
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@/*
 * Copyright (c) 1980, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Elz at The University of Melbourne.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Quota report
 */
#include <sys/param.h>	/* dbtob */
#include <sys/stat.h>
#include <ufs/ufs/quota.h>
#include <fstab.h>
#include <pwd.h>
#include <grp.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

char *qfname = QUOTAFILENAME;
char *qfextension[] = INITQFNAMES;

struct fileusage {
	struct	fileusage *fu_next;
	struct	dqblk fu_dqblk;
	uid_t	fu_id;
	char	fu_name[1];
	/* actually bigger */
};
#define FUHASH 1024	/* must be power of two */
struct fileusage *fuhead[MAXQUOTAS][FUHASH];
struct fileusage *lookup(uid_t, int);
struct fileusage *addid(uid_t id, int type, char *name);
uid_t highid[MAXQUOTAS];	/* highest addid()'ed identifier per type */

int	vflag;			/* verbose */
int	aflag;			/* all file systems */

void	usage(void);
int	repquota(struct fstab *, int, char *);
int	hasquota(struct fstab *, int, char **);
int	oneof(char *, char *[], int);
char	*timeprt(time_t);
int
main(int argc, char *argv[])
{
	struct fstab *fs;
	struct passwd *pw;
	struct group *gr;
	int gflag = 0, uflag = 0, errs = 0;
	long i, argnum, done = 0;
	extern char *optarg;
	extern int optind;
	char *qfnp;
	int ch;

	while ((ch = getopt(argc, argv, "aguv")) != -1) {
		switch(ch) {
		case 'a':
			aflag++;
			break;
		case 'g':
			gflag++;
			break;
		case 'u':
			uflag++;
			break;
		case 'v':
			vflag++;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;
	if ((argc == 0) == (aflag == 0))
		usage();
	if (!gflag && !uflag) {
		if (aflag)
			gflag++;
		uflag++;
	}
	if (gflag) {
		setgrent();
		while ((gr = getgrent()) != 0)
			(void) addid((uid_t)gr->gr_gid, GRPQUOTA, gr->gr_name);
		endgrent();
	}
	if (uflag) {
		setpwent();
		while ((pw = getpwent()) != 0)
			(void) addid(pw->pw_uid, USRQUOTA, pw->pw_name);
		endpwent();
	}
	setfsent();
	while ((fs = getfsent()) != NULL) {
		if (strcmp(fs->fs_vfstype, "ffs") &&
		    strcmp(fs->fs_vfstype, "ufs") &&
		    strcmp(fs->fs_vfstype, "mfs"))
			continue;
		if (aflag) {
			if (gflag && hasquota(fs, GRPQUOTA, &qfnp))
				errs += repquota(fs, GRPQUOTA, qfnp);
			if (uflag && hasquota(fs, USRQUOTA, &qfnp))
				errs += repquota(fs, USRQUOTA, qfnp);
			continue;
		}
		if ((argnum = oneof(fs->fs_file, argv, argc)) >= 0 ||
		    (argnum = oneof(fs->fs_spec, argv, argc)) >= 0) {
			done |= 1 << argnum;
			if (gflag && hasquota(fs, GRPQUOTA, &qfnp))
				errs += repquota(fs, GRPQUOTA, qfnp);
			if (uflag && hasquota(fs, USRQUOTA, &qfnp))
				errs += repquota(fs, USRQUOTA, qfnp);
		}
	}
	endfsent();
	for (i = 0; i < argc; i++)
		if ((done & (1 << i)) == 0)
			fprintf(stderr, "%s not found in fstab\n", argv[i]);
	exit(errs);
}

void
usage(void)
{
	extern char *__progname;
	fprintf(stderr, "usage: %s [-aguv] filesystem ...\n", __progname);
	exit(1);
}

int
repquota(struct fstab *fs, int type, char *qfpathname)
{
	struct fileusage *fup;
	FILE *qf;
	uid_t id;
	struct dqblk dqbuf;
	char *timeprt(time_t);
	static struct dqblk zerodqblk;
	static int warned = 0;
	static int multiple = 0;

	if (quotactl(fs->fs_file, QCMD(Q_SYNC, type), 0, 0) < 0 &&
	    errno == EOPNOTSUPP && !warned && vflag) {
		warned++;
		fprintf(stdout,
		    "*** Warning: Quotas are not compiled into this kernel\n");
	}
	if (multiple++)
		printf("\n");
	if (vflag)
		fprintf(stdout, "*** Report for %s quotas on %s (%s)\n",
		    qfextension[type], fs->fs_file, fs->fs_spec);
	if ((qf = fopen(qfpathname, "r")) == NULL) {
		perror(qfpathname);
		return (1);
	}
	for (id = 0; ; id++) {
		fread(&dqbuf, sizeof(struct dqblk), 1, qf);
		if (feof(qf))
			break;
		if (dqbuf.dqb_curinodes == 0 && dqbuf.dqb_curblocks == 0)
			continue;
		if ((fup = lookup(id, type)) == 0)
			fup = addid(id, type, NULL);
		fup->fu_dqblk = dqbuf;
	}
	fclose(qf);
	printf("                        KByte limits               File limits\n");
	printf("User            used    soft    hard  grace    used  soft  hard  grace\n");
	for (id = 0; id <= highid[type]; id++) {
		fup = lookup(id, type);
		if (fup == 0)
			continue;
		if (fup->fu_dqblk.dqb_curinodes == 0 &&
		    fup->fu_dqblk.dqb_curblocks == 0)
			continue;
		printf("%-10s", fup->fu_name);
		printf("%c%c %7d %7d %7d %6s",
			fup->fu_dqblk.dqb_bsoftlimit && 
			    fup->fu_dqblk.dqb_curblocks >= 
			    fup->fu_dqblk.dqb_bsoftlimit ? '+' : '-',
			fup->fu_dqblk.dqb_isoftlimit &&
			    fup->fu_dqblk.dqb_curinodes >=
			    fup->fu_dqblk.dqb_isoftlimit ? '+' : '-',
			(int)(dbtob((u_quad_t)fup->fu_dqblk.dqb_curblocks)
			    / 1024),
			(int)(dbtob((u_quad_t)fup->fu_dqblk.dqb_bsoftlimit)
			    / 1024),
			(int)(dbtob((u_quad_t)fup->fu_dqblk.dqb_bhardlimit)
			    / 1024),
			fup->fu_dqblk.dqb_bsoftlimit && 
			    fup->fu_dqblk.dqb_curblocks >= 
			    fup->fu_dqblk.dqb_bsoftlimit ?
			    timeprt(fup->fu_dqblk.dqb_btime) : "");
		printf("  %6d %5d %5d %6s\n",
			fup->fu_dqblk.dqb_curinodes,
			fup->fu_dqblk.dqb_isoftlimit,
			fup->fu_dqblk.dqb_ihardlimit,
			fup->fu_dqblk.dqb_isoftlimit &&
			    fup->fu_dqblk.dqb_curinodes >=
			    fup->fu_dqblk.dqb_isoftlimit ?
			    timeprt(fup->fu_dqblk.dqb_itime) : "");
		fup->fu_dqblk = zerodqblk;
	}
	return (0);
}

/*
 * Check to see if target appears in list of size cnt.
 */
int
oneof(char *target, char *list[], int cnt)
{
	int i;

	for (i = 0; i < cnt; i++)
		if (strcmp(target, list[i]) == 0)
			return (i);
	return (-1);
}

/*
 * Check to see if a particular quota is to be enabled.
 */
int
hasquota(struct fstab *fs, int type, char **qfnamep)
{
	char *opt;
	char *cp;
	static char initname, usrname[100], grpname[100];
	static char buf[BUFSIZ];

	if (!initname) {
		(void)snprintf(usrname, sizeof usrname, "%s%s",
		    qfextension[USRQUOTA], qfname);
		(void)snprintf(grpname, sizeof grpname, "%s%s",
		    qfextension[GRPQUOTA], qfname);
		initname = 1;
	}
	strlcpy(buf, fs->fs_mntops, sizeof buf);
	for (opt = strtok(buf, ","); opt; opt = strtok(NULL, ",")) {
		if ((cp = strchr(opt, '=')))
			*cp++ = '\0';
		if (type == USRQUOTA && strcmp(opt, usrname) == 0)
			break;
		if (type == GRPQUOTA && strcmp(opt, grpname) == 0)
			break;
	}
	if (!opt)
		return (0);
	if (cp) {
		*qfnamep = cp;
		return (1);
	}
	(void)snprintf(buf, sizeof buf, "%s/%s.%s",
	    fs->fs_file, qfname, qfextension[type]);
	*qfnamep = buf;
	return (1);
}

/*
 * Routines to manage the file usage table.
 *
 * Lookup an id of a specific type.
 */
struct fileusage *
lookup(uid_t id, int type)
{
	struct fileusage *fup;

	for (fup = fuhead[type][id & (FUHASH-1)]; fup != 0; fup = fup->fu_next)
		if (fup->fu_id == id)
			return (fup);
	return (NULL);
}

/*
 * Add a new file usage id if it does not already exist.
 */
struct fileusage *
addid(uid_t id, int type, char *name)
{
	struct fileusage *fup, **fhp;
	size_t len;

	if ((fup = lookup(id, type)))
		return (fup);
	if (name)
		len = strlen(name);
	else
		len = 10;
	if ((fup = calloc(1, sizeof(*fup) + len)) == NULL) {
		fprintf(stderr, "out of memory for fileusage structures\n");
		exit(1);
	}
	fhp = &fuhead[type][id & (FUHASH - 1)];
	fup->fu_next = *fhp;
	*fhp = fup;
	fup->fu_id = id;
	if (id > highid[type])
		highid[type] = id;
	if (name) {
		bcopy(name, fup->fu_name, len + 1);
	} else {
		snprintf(fup->fu_name, len, "%u", id);
	}
	return (fup);
}

/*
 * Calculate the grace period and return a printable string for it.
 */
char *
timeprt(time_t seconds)
{
	int hours, minutes;
	static char buf[20];
	static time_t now;

	if (now == 0)
		time(&now);
	if (now > seconds)
		return ("none");
	seconds -= now;
	minutes = (seconds + 30) / 60;
	hours = (minutes + 30) / 60;
	if (hours >= 36) {
		snprintf(buf, sizeof buf, "%ddays", (hours + 12) / 24);
		return (buf);
	}
	if (minutes >= 60) {
		snprintf(buf, sizeof buf, "%2d:%d", minutes / 60,
		    minutes % 60);
		return (buf);
	}
	snprintf(buf, sizeof buf, "%2d", minutes);
	return (buf);
}
@


1.34
log
@Put repquota in line with other utilities: you either wants list everyting,
effectively using -a, or you specify filesystems one-by-one. Doing both
resulted in a funny error messages, so just don't allow that silly behaviour.

okay millert@@
@
text
@d195 1
a195 1
			fup = addid(id, type, (char *)0);
d305 1
a305 1
	return ((struct fileusage *)0);
@


1.33
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d105 1
a105 1
	if (argc == 0 && !aflag)
@


1.32
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d323 1
a323 1
	if ((fup = (struct fileusage *)calloc(1, sizeof(*fup) + len)) == NULL) {
@


1.31
log
@ensure there are prototypes
@
text
@d36 1
a36 1
#include <sys/param.h>
@


1.30
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d71 1
a71 1

@


1.29
log
@Fix use of arguments in usage().

ok winiger
@
text
@a32 11
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1990, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "from: @@(#)repquota.c	8.1 (Berkeley) 6/6/93";*/
static char *rcsid = "$Id: repquota.c,v 1.28 2007/02/18 23:17:59 jmc Exp $";
#endif /* not lint */

@


1.28
log
@tidy up synopsis and usage(); partly from Igor Sobrado
@
text
@d41 1
a41 1
static char *rcsid = "$Id: repquota.c,v 1.27 2005/04/03 19:02:30 otto Exp $";
d168 1
a168 2
	fprintf(stderr, "usage: repquota [-aguv] filesystem ...\n",
		__progname);
@


1.27
log
@Report quotas > 10GB in a readable way. Diff based on PR 2836.
ok deraadt@@
@
text
@d41 1
a41 1
static char *rcsid = "$Id: repquota.c,v 1.26 2005/04/01 04:31:11 deraadt Exp $";
d167 3
a169 3
	fprintf(stderr, "Usage:\n\t%s\n\t%s\n",
		"repquota [-v] [-g] [-u] -a",
		"repquota [-v] [-g] [-u] filesys ...");
@


1.26
log
@these commands said "blocks" when they meant "KBytes" (they even calculated
it so).  pointed out by janc@@cyberspace.org, pr 3956
@
text
@d41 1
a41 1
static char *rcsid = "$Id: repquota.c,v 1.25 2003/06/26 19:47:10 deraadt Exp $";
d221 1
a221 1
		printf("%c%c%8d%8d%8d%7s",
d238 1
a238 1
		printf("  %6d%6d%6d%7s\n",
@


1.25
log
@strict proto cleanups
@
text
@d41 1
a41 1
static char *rcsid = "$Id: repquota.c,v 1.24 2003/06/25 15:54:17 deraadt Exp $";
d211 1
a211 1
	printf("                        Block limits               File limits\n");
@


1.24
log
@ansi
@
text
@d41 1
a41 1
static char *rcsid = "$Id: repquota.c,v 1.23 2003/06/02 23:36:54 millert Exp $";
d180 1
a180 1
	char *timeprt();
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d41 1
a41 1
static char *rcsid = "$Id: repquota.c,v 1.22 2003/04/30 15:30:05 jason Exp $";
d71 2
a72 2
struct fileusage *lookup();
struct fileusage *addid();
d84 1
a84 3
main(argc, argv)
	int argc;
	char **argv;
d165 1
a165 1
usage()
d174 1
a174 4
repquota(fs, type, qfpathname)
	struct fstab *fs;
	int type;
	char *qfpathname;
d255 1
a255 3
oneof(target, list, cnt)
	char *target, *list[];
	int cnt;
d269 1
a269 4
hasquota(fs, type, qfnamep)
	struct fstab *fs;
	int type;
	char **qfnamep;
d310 1
a310 3
lookup(id, type)
	uid_t id;
	int type;
d324 1
a324 4
addid(id, type, name)
	uid_t id;
	int type;
	char *name;
d357 1
a357 2
timeprt(seconds)
	time_t seconds;
@


1.22
log
@pull in stdlib.h to avoid implicit decl of calloc(); ok henning
@
text
@d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static char *rcsid = "$Id: repquota.c,v 1.21 2003/03/30 20:52:42 deraadt Exp $";
@


1.21
log
@boring nothing commit from cloder
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.20 2003/03/30 20:47:42 deraadt Exp $";
d61 1
@


1.20
log
@snprintf; millert ok
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.19 2002/09/06 21:49:21 deraadt Exp $";
d345 1
a345 2
	int len;
	extern char *calloc();
@


1.19
log
@cope with INITQFNAMES without a ;
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.18 2002/09/06 18:29:37 deraadt Exp $";
d367 1
a367 1
		sprintf(fup->fu_name, "%u", id);
@


1.18
log
@no ; after INITQFNAMES
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.17 2002/05/29 09:45:08 deraadt Exp $";
d63 1
a63 1
char *qfextension[] = INITQFNAMES
@


1.17
log
@more sprintf
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.16 2002/03/14 16:44:25 mpech Exp $";
d63 1
a63 1
char *qfextension[] = INITQFNAMES;
@


1.16
log
@kill more registers.

millert@@ ok
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.15 2002/02/16 21:28:08 millert Exp $";
d391 1
a391 1
		sprintf(buf, "%ddays", (hours + 12) / 24);
d395 2
a396 1
		sprintf(buf, "%2d:%d", minutes / 60, minutes % 60);
d399 1
a399 1
	sprintf(buf, "%2d", minutes);
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.14 2001/01/15 05:19:10 angelos Exp $";
d91 3
a93 3
	register struct fstab *fs;
	register struct passwd *pw;
	register struct group *gr;
d180 1
a180 1
	register struct fstab *fs;
d184 1
a184 1
	register struct fileusage *fup;
d264 1
a264 1
	register char *target, *list[];
d267 1
a267 1
	register int i;
d280 1
a280 1
	register struct fstab *fs;
d284 1
a284 1
	register char *opt;
d327 1
a327 1
	register struct fileusage *fup;
@


1.14
log
@Revert previous patch.
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.12 2000/12/21 09:50:00 pjanzen Exp $";
d81 4
a84 4
void	usage __P((void));
int	repquota __P((struct fstab *, int, char *));
int	hasquota __P((struct fstab *, int, char **));
int	oneof __P((char *, char *[], int));
@


1.13
log
@Handle quotas over 4G, PR 1534 (bob@@prophecy.lu)
@
text
@a61 6
#if DEV_BSHIFT < 10
#define dbtokb(x) ((x) >> (10 - DEV_BSHIFT))
#else
#define dbtokb(x) ((x) << (DEV_BSHIFT - 10))
#endif

d229 1
a229 1
		printf("%c%c%8lu%8lu%8lu%7s",
d236 6
a241 3
			(int)(dbtokb((u_quad_t)fup->fu_dqblk.dqb_curblocks)),
			(int)(dbtokb((u_quad_t)fup->fu_dqblk.dqb_bsoftlimit)),
			(int)(dbtokb((u_quad_t)fup->fu_dqblk.dqb_bhardlimit)),
@


1.12
log
@Print quotas > 4G correctly; be a little more paranoid with a few buffers.
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.11 2000/09/11 18:47:29 millert Exp $";
d62 6
d235 1
a235 1
		printf("%c%c%8d%8d%8d%7s",
d242 3
a244 6
			(int)(dbtob((u_quad_t)fup->fu_dqblk.dqb_curblocks)
			    / 1024),
			(int)(dbtob((u_quad_t)fup->fu_dqblk.dqb_bsoftlimit)
			    / 1024),
			(int)(dbtob((u_quad_t)fup->fu_dqblk.dqb_bhardlimit)
			    / 1024),
@


1.11
log
@Fix pasto: repquota does not report user quotas when a volume argument is given
and there are no group quotas set.  canacar@@eee.metu.edu.tr
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.10 2000/02/01 03:24:08 deraadt Exp $";
d236 6
a241 3
			dbtob(fup->fu_dqblk.dqb_curblocks) / 1024,
			dbtob(fup->fu_dqblk.dqb_bsoftlimit) / 1024,
			dbtob(fup->fu_dqblk.dqb_bhardlimit) / 1024,
d290 4
a293 2
		sprintf(usrname, "%s%s", qfextension[USRQUOTA], qfname);
		sprintf(grpname, "%s%s", qfextension[GRPQUOTA], qfname);
d296 1
a296 1
	strcpy(buf, fs->fs_mntops);
d311 2
a312 1
	(void) sprintf(buf, "%s/%s.%s", fs->fs_file, qfname, qfextension[type]);
@


1.10
log
@no need to extern int errno if errno.h is included
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.9 1997/01/17 07:14:24 millert Exp $";
d158 1
a158 1
			if (uflag && hasquota(fs, GRPQUOTA, &qfnp))
@


1.9
log
@r?index -> strr?chr
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.8 1996/12/12 20:32:17 deraadt Exp $";
a191 1
	extern int errno;
@


1.8
log
@fix a typical use; -Wall
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.7 1996/05/04 12:30:21 deraadt Exp $";
d283 1
a283 1
	char *cp, *index(), *strtok();
d294 1
a294 1
		if ((cp = index(opt, '=')))
@


1.7
log
@allow operation even if fstab does not label filesystem as supporting
quotas; pointed out by jonny@@gaia.coppe.ufrj.br
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.6 1996/04/25 11:04:14 deraadt Exp $";
d58 1
d68 1
a68 1
	u_long	fu_id;
d76 1
a76 1
u_long highid[MAXQUOTAS];	/* highest addid()'ed identifier per type */
d81 6
d131 1
a131 1
			(void) addid((u_long)gr->gr_gid, GRPQUOTA, gr->gr_name);
d137 1
a137 1
			(void) addid((u_long)pw->pw_uid, USRQUOTA, pw->pw_name);
d156 1
a156 1
			if (gflag)
d158 1
a158 1
			if (uflag)
d169 1
d178 1
d186 1
a186 1
	u_long id;
d260 1
d276 1
d294 1
a294 1
		if (cp = index(opt, '='))
d319 1
a319 1
	u_long id;
d335 1
a335 1
	u_long id;
d343 1
a343 1
	if (fup = lookup(id, type))
d374 1
a374 1
	time_t hours, minutes;
@


1.6
log
@permit quotas to work on mfs; problem reported by rdante@@pnet.net
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.5 1996/04/21 23:41:45 deraadt Exp $";
d149 1
a149 1
			if (gflag && hasquota(fs, GRPQUOTA, &qfnp))
d151 1
a151 1
			if (uflag && hasquota(fs, USRQUOTA, &qfnp))
@


1.5
log
@sync to netbsd 960418
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.4 1996/01/07 05:28:06 deraadt Exp $";
d136 2
a137 1
		    strcmp(fs->fs_vfstype, "ufs"))
@


1.4
log
@accept either ffs or ufs for filesystem name
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.3 1995/11/06 21:41:00 deraadt Exp $";
d91 2
a92 1
	char ch, *qfnp;
d94 1
a94 1
	while ((ch = getopt(argc, argv, "aguv")) != EOF) {
@


1.3
log
@Complete change from ufs -> ffs; (From Tatoku Ogaito; PR #1679)
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.7.2.1 1995/11/01 00:32:19 jtc Exp $";
d134 2
a135 1
		if (strcmp(fs->fs_vfstype, "ffs"))
@


1.2
log
@ufs -> ffs
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.1.1.1 1995/10/18 08:48:05 deraadt Exp $";
@


1.1
log
@Initial revision
@
text
@d45 1
a45 1
static char *rcsid = "$Id: repquota.c,v 1.7 1995/01/03 02:06:31 cgd Exp $";
d134 1
a134 1
		if (strcmp(fs->fs_vfstype, "ufs"))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
