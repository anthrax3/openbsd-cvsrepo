head	1.50;
access;
symbols
	OPENBSD_6_2:1.50.0.6
	OPENBSD_6_2_BASE:1.50
	OPENBSD_6_1:1.50.0.4
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.49.0.4
	OPENBSD_6_0_BASE:1.49
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.47.0.6
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.41.0.4
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.2
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.40.0.2
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.10
	OPENBSD_5_0:1.39.0.8
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.39.0.6
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.4
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.37.0.10
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.6
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.37.0.4
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.37.0.2
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.35.0.14
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.12
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.35.0.10
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.35.0.8
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.35.0.6
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.35.0.4
	OPENBSD_3_6_BASE:1.35
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	OPENBSD_3_3:1.30.0.2
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.18.0.6
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.18.0.4
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.18.0.2
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.50
date	2016.09.10.05.48.18;	author jsg;	state Exp;
branches;
next	1.49;
commitid	VE4S1lCWf33AeYqe;

1.49
date	2015.12.10.18.40.46;	author mmcc;	state Exp;
branches;
next	1.48;
commitid	CZReKaQ9YkTORklR;

1.48
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	z3HrihslRYb4HqW9;

1.47
date	2015.01.18.04.48.24;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	eRoBhNqhtj9qy8AW;

1.46
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	Uu5nFG3wCl0LACBb;

1.45
date	2014.05.20.01.25.24;	author guenther;	state Exp;
branches;
next	1.44;

1.44
date	2013.11.12.13.11.10;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2013.10.15.05.15.12;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2013.08.22.04.43.41;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2013.01.29.22.39.06;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2012.04.06.18.06.40;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.11.16.44.59;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.27.23.59.51;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.02.15.19.38;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.18.16.28.10;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2003.09.25.16.52.11;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.26.21.36.39;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.02.23.36.53;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.06.23.21.41;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.04.22.40.52;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.30.15.35.13;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.25.21.55.01;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.06.19.04.49;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.30.19.09.05;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.25.16.41.43;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.20.23.07.49;	author pefo;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.16.21.28.03;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.11.13.08.09;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.03.03.03.07;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.25.05.40.28;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.30.16.00.25;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	99.03.24.05.25.57;	author millert;	state Exp;
branches
	1.18.6.1;
next	1.17;

1.17
date	98.12.19.18.48.05;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.11.29.09.34.09;	author downsj;	state Exp;
branches;
next	1.15;

1.15
date	98.10.28.23.20.01;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.09.26.07.16.23;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.08.23.00.57.15;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.08.21.19.31.29;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.08.21.19.24.39;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.08.20.00.14.03;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.08.19.07.43.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.08.19.06.47.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.12.15.10.15.39;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.22.08.16;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.07.31.17.21.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.31.16.51.51;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.24.09.22.59;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.17.20.04.55;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.39;	author deraadt;	state Exp;
branches;
next	;

1.18.6.1
date	2000.10.06.21.24.21;	author jason;	state Exp;
branches;
next	;


desc
@@


1.50
log
@missing fclose() in an error path
@
text
@/*	$OpenBSD: nlist.c,v 1.49 2015/12/10 18:40:46 mmcc Exp $	*/

/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>

#include <db.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <kvm.h>
#include <limits.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "extern.h"

#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <sys/sysctl.h>

#include <elf_abi.h>

typedef struct nlist NLIST;
#define	_strx	n_un.n_strx
#define	_name	n_un.n_name

static char *kfile;
static char *fmterr;

int	__elf_knlist(int fd, DB *db, int ksyms);

int
__elf_knlist(int fd, DB *db, int ksyms)
{
	caddr_t strtab = NULL;
	off_t symstroff, symoff;
	u_long symsize, symstrsize;
	u_long kernvma, kernoffs;
	int i, error = 0;
	Elf32_Word j;
	Elf_Sym sbuf;
	char buf[1024];
	Elf_Ehdr eh;
	Elf_Shdr *sh = NULL;
	DBT data, key;
	NLIST nbuf;
	FILE *fp;
	int usemalloc = 0;

	if ((fp = fdopen(fd, "r")) == NULL)
		err(1, "%s", kfile);

	if (fseek(fp, (off_t)0, SEEK_SET) == -1 ||
	    fread(&eh, sizeof(eh), 1, fp) != 1 ||
	    !IS_ELF(eh)) {
		fclose(fp);
		return (1);
	}

	sh = calloc(sizeof(Elf_Shdr), eh.e_shnum);
	if (sh == NULL)
		errx(1, "cannot allocate %zu bytes for symbol header",
		    sizeof(Elf_Shdr) * eh.e_shnum);

	if (fseek (fp, eh.e_shoff, SEEK_SET) < 0) {
		fmterr = "no exec header";
		error = -1;
		goto done;
	}

	if (fread(sh, sizeof(Elf_Shdr) * eh.e_shnum, 1, fp) != 1) {
		fmterr = "no exec header";
		error = -1;
		goto done;
	}

	symstrsize = symsize = 0;
	kernvma = (u_long)-1;	/* 0 is a valid value (at least on hp300) */
	for (i = 0; i < eh.e_shnum; i++) {
		if (sh[i].sh_type == SHT_STRTAB) {
			for (j = 0; j < eh.e_shnum; j++)
				if (sh[j].sh_type == SHT_SYMTAB &&
				    sh[j].sh_link == (unsigned)i) {
					symstroff = sh[i].sh_offset;
					symstrsize = sh[i].sh_size;
			}
		} else if (sh[i].sh_type == SHT_SYMTAB) {
			symoff = sh[i].sh_offset;
			symsize = sh[i].sh_size;
		} else if (sh[i].sh_type == SHT_PROGBITS &&
		    (sh[i].sh_flags & SHF_EXECINSTR)) {
			kernvma = sh[i].sh_addr;
			kernoffs = sh[i].sh_offset;
		}
	}

	if (symstrsize == 0 || symsize == 0 || kernvma == (u_long)-1) {
		fmterr = "corrupt file";
		error = -1;
		goto done;
	}

	/*
	 * Map string table into our address space.  This gives us
	 * an easy way to randomly access all the strings, without
	 * making the memory allocation permanent as with malloc/free
	 * (i.e., munmap will return it to the system).
	 *
	 * XXX - we really want to check if this is a regular file.
	 *	 then we probably want a MAP_PRIVATE here.
	 */
	strtab = mmap(NULL, (size_t)symstrsize, PROT_READ,
	    MAP_SHARED|MAP_FILE, fileno(fp), symstroff);
	if (strtab == MAP_FAILED) {
		usemalloc = 1;
		if ((strtab = malloc(symstrsize)) == NULL) {
			fmterr = "out of memory";
			error = -1;
			goto done;
		}
		if (fseek(fp, symstroff, SEEK_SET) == -1) {
			fmterr = "corrupt file";
			error = -1;
			goto done;
		}
		if (fread(strtab, symstrsize, 1, fp) != 1) {
			fmterr = "corrupt file";
			error = -1;
			goto done;
		}
	}

	if (fseek(fp, symoff, SEEK_SET) == -1) {
		fmterr = "corrupt file";
		error = -1;
		goto done;
	}

	data.data = (u_char *)&nbuf;
	data.size = sizeof(NLIST);

	/* Read each symbol and enter it into the database. */
	while (symsize > 0) {
		symsize -= sizeof(Elf_Sym);
		if (fread((char *)&sbuf, sizeof(sbuf), 1, fp) != 1) {
			if (feof(fp))
				fmterr = "corrupted symbol table";
			else
				warn("%s", kfile);
			error = -1;
			goto done;
		}
		if (!sbuf.st_name)
			continue;

		nbuf.n_value = sbuf.st_value;

		/* XXX type conversion is pretty rude... */
		switch(ELF_ST_TYPE(sbuf.st_info)) {
		case STT_NOTYPE:
			switch (sbuf.st_shndx) {
			case SHN_UNDEF:
				nbuf.n_type = N_UNDF;
				break;
			case SHN_ABS:
				nbuf.n_type = N_ABS;
				break;
			case SHN_COMMON:
				nbuf.n_type = N_COMM;
				break;
			default:
				nbuf.n_type = N_COMM | N_EXT;
				break;
			}
			break;
		case STT_FUNC:
			nbuf.n_type = N_TEXT;
			break;
		case STT_OBJECT:
			nbuf.n_type = N_DATA;
			break;
		case STT_FILE:
			nbuf.n_type = N_FN;
			break;
		}
		if (ELF_ST_BIND(sbuf.st_info) == STB_LOCAL)
			nbuf.n_type = N_EXT;

		*buf = '_';
		strlcpy(buf + 1, strtab + sbuf.st_name, sizeof buf - 1);
		key.data = (u_char *)buf;
		key.size = strlen((char *)key.data);
		if (db->put(db, &key, &data, 0))
			err(1, "record enter");

		if (strcmp((char *)key.data, VRS_SYM) == 0) {
			long cur_off;
			if (!ksyms) {
				/*
				 * Calculate offset to the version string in
				 * the file. kernvma is where the kernel is
				 * really loaded; kernoffs is where in the
				 * file it starts.
				 */
				long voff;
				voff = nbuf.n_value - kernvma + kernoffs;
				cur_off = ftell(fp);
				if (fseek(fp, voff, SEEK_SET) == -1) {
					fmterr = "corrupted string table";
					error = -1;
					goto done;
				}

				/*
				 * Read version string up to, and including
				 * newline. This code assumes that a newline
				 * terminates the version line.
				 */
				if (fgets(buf, sizeof(buf), fp) == NULL) {
					fmterr = "corrupted string table";
					error = -1;
					goto done;
				}
			} else {
				/*
				 * This is /dev/ksyms or a look alike.
				 * Use sysctl() to get version since we
				 * don't have real text or data.
				 */
				int mib[2];
				size_t len;
				char *p;

				mib[0] = CTL_KERN;
				mib[1] = KERN_VERSION;
				len = sizeof(buf);
				if (sysctl(mib, 2, buf, &len, NULL, 0) == -1) {
					err(1, "sysctl can't find kernel "
					    "version string");
				}
				if ((p = strchr(buf, '\n')) != NULL)
					*(p+1) = '\0';
			}

			key.data = (u_char *)VRS_KEY;
			key.size = sizeof(VRS_KEY) - 1;
			data.data = (u_char *)buf;
			data.size = strlen(buf);
			if (db->put(db, &key, &data, 0))
				err(1, "record enter");

			/* Restore to original values. */
			data.data = (u_char *)&nbuf;
			data.size = sizeof(NLIST);
			if (!ksyms && fseek(fp, cur_off, SEEK_SET) == -1) {
				fmterr = "corrupted string table";
				error = -1;
				goto done;
			}
		}
	}
done:
	if (strtab) {
		if (usemalloc)
			free(strtab);
		else
			munmap(strtab, symstrsize);
	}
	(void)fclose(fp);
	free(sh);
	return (error);
}

int
create_knlist(char *name, int fd, DB *db)
{
	int error, ksyms;

	if (strcmp(name, _PATH_KSYMS) == 0) {
		ksyms = 1;
	} else {
		ksyms = 0;
	}

	fmterr = NULL;
	kfile = name;
	/* rval of 1 means wrong executable type */
	error = __elf_knlist(fd, db, ksyms);

	if (fmterr != NULL)
		warnc(EFTYPE, "%s: %s", kfile, fmterr);

	return(error);
}
@


1.49
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.48 2015/08/20 22:39:29 deraadt Exp $	*/
d87 2
a88 1
	    !IS_ELF(eh))
d90 1
@


1.48
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.47 2015/01/18 04:48:24 deraadt Exp $	*/
d300 1
a300 2
	if (sh)
		free(sh);
@


1.47
log
@do not require <a.out.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.46 2015/01/16 06:40:17 deraadt Exp $	*/
d90 1
a90 1
	sh = (Elf_Shdr *)calloc(sizeof(Elf_Shdr), eh.e_shnum);
@


1.46
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.45 2014/05/20 01:25:24 guenther Exp $	*/
a33 1
#include <a.out.h>
@


1.45
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.44 2013/11/12 13:11:10 deraadt Exp $	*/
d32 1
a32 1
#include <sys/param.h>
@


1.44
log
@remove the code that iterates over binary types, since everything is now
ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.43 2013/10/15 05:15:12 deraadt Exp $	*/
d323 1
a323 1
		warnx("%s: %s: %s", kfile, fmterr, strerror(EFTYPE));
@


1.43
log
@tedu a.out support
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.42 2013/08/22 04:43:41 guenther Exp $	*/
a53 1
#ifdef _NLIST_DO_ELF
a54 1
#endif
d63 2
a64 1
#ifdef _NLIST_DO_ELF
a304 9
#endif /* _NLIST_DO_ELF */

static struct knlist_handlers {
	int	(*fn)(int fd, DB *db, int ksyms);
} nlist_fn[] = {
#ifdef _NLIST_DO_ELF
	{ __elf_knlist },
#endif
};
d309 1
a309 1
	int i, error, ksyms;
d317 5
a321 7
	for (i = 0; i < sizeof(nlist_fn)/sizeof(nlist_fn[0]); i++) {
		fmterr = NULL;
		kfile = name;
		/* rval of 1 means wrong executable type */
		if ((error = (nlist_fn[i].fn)(fd, db, ksyms)) != 1)
			break;
	}
@


1.42
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.41 2013/01/29 22:39:06 miod Exp $	*/
a57 4
#ifdef _NLIST_DO_ECOFF
#include <sys/exec_ecoff.h>
#endif

a64 223
#if defined(_NLIST_DO_AOUT)

static u_long get_kerntext(char *kfn, u_int magic);

int
__aout_knlist(int fd, DB *db, int ksyms)
{
	int nsyms;
	struct exec ebuf;
	FILE *fp;
	NLIST nbuf;
	DBT data, key;
	int nr, strsize;
	size_t len;
	u_long kerntextoff;
	size_t snamesize = 0;
	char *strtab, buf[1024], *sname, *p;

	/* Read in exec structure. */
	nr = read(fd, &ebuf, sizeof(struct exec));
	if (nr != sizeof(struct exec)) {
		fmterr = "no exec header";
		return (1);
	}

	/* Check magic number and symbol count. */
	if (N_BADMAG(ebuf)) {
		fmterr = "bad magic number";
		return (1);
	}

	/* Must have a symbol table. */
	if (!ebuf.a_syms) {
		fmterr = "stripped";
		return (-1);
	}

	/* Seek to string table. */
	if (lseek(fd, N_STROFF(ebuf), SEEK_SET) == -1) {
		fmterr = "corrupted string table";
		return (-1);
	}

	/* Read in the size of the string table. */
	nr = read(fd, (char *)&strsize, sizeof(strsize));
	if (nr != sizeof(strsize)) {
		fmterr = "no symbol table";
		return (-1);
	}

	/* Read in the string table. */
	strsize -= sizeof(strsize);
	if (!(strtab = malloc(strsize)))
		errx(1, "cannot allocate %d bytes for string table", strsize);
	if ((nr = read(fd, strtab, strsize)) != strsize) {
		fmterr = "corrupted symbol table";
		free(strtab);
		return (-1);
	}

	/* Seek to symbol table. */
	if (!(fp = fdopen(fd, "r")))
		err(1, "%s", kfile);
	if (fseek(fp, N_SYMOFF(ebuf), SEEK_SET) == -1) {
		free(strtab);
		warn("fseek %s", kfile);
		return (-1);
	}

	data.data = (u_char *)&nbuf;
	data.size = sizeof(NLIST);

	kerntextoff = get_kerntext(kfile, N_GETMAGIC(ebuf));

	/* Read each symbol and enter it into the database. */
	nsyms = ebuf.a_syms / sizeof(struct nlist);
	sname = NULL;
	while (nsyms--) {
		if (fread((char *)&nbuf, sizeof (NLIST), 1, fp) != 1) {
			if (feof(fp))
				fmterr = "corrupted symbol table";
			else
				warn("%s", kfile);
			free(strtab);
			return (-1);
		}
		if (!nbuf._strx || (nbuf.n_type & N_STAB))
			continue;

		/* If the symbol does not start with '_', add one */
		p = strtab + nbuf._strx - sizeof(int);
		if (*p != '_') {
			len = strlen(p) + 1;
			if (len >= snamesize) {
				char *newsname;
				int newsnamesize = len + 1024;

				newsname = realloc(sname, newsnamesize);
				if (newsname == NULL) {
					if (sname)
						free(sname);
					sname = NULL;
				} else {
					sname = newsname;
					snamesize = newsnamesize;
				}
			}
			if (sname == NULL)
				errx(1, "cannot allocate memory");
			*sname = '_';
			strlcpy(sname + 1, p, snamesize  - 1);
			key.data = (u_char *)sname;
			key.size = len;
		} else {
			key.data = (u_char *)p;
			key.size = strlen((char *)key.data);
		}
		if (db->put(db, &key, &data, 0))
			err(1, "record enter");

		if (strcmp((char *)key.data, VRS_SYM) == 0) {
			long cur_off;

			if (!ksyms) {
				/*
				 * Calculate offset relative to a normal
				 * (non-kernel) a.out.  Kerntextoff is where the
				 * kernel is really loaded; N_TXTADDR is where
				 * a normal file is loaded.  From there, locate
				 * file offset in text or data.
				 */
				long voff;

				voff = nbuf.n_value-kerntextoff+N_TXTADDR(ebuf);
				if ((nbuf.n_type & N_TYPE) == N_TEXT)
					voff += N_TXTOFF(ebuf)-N_TXTADDR(ebuf);
				else
					voff += N_DATOFF(ebuf)-N_DATADDR(ebuf);
				cur_off = ftell(fp);
				if (fseek(fp, voff, SEEK_SET) == -1) {
					fmterr = "corrupted string table";
					free(strtab);
					return (-1);
				}

				/*
				 * Read version string up to, and including
				 * newline.  This code assumes that a newline
				 * terminates the version line.
				 */
				if (fgets(buf, sizeof(buf), fp) == NULL) {
					fmterr = "corrupted string table";
					free(strtab);
					return (-1);
				}
			} else {
				/*
				 * This is /dev/ksyms or a look alike.
				 * Use sysctl() to get version since we
				 * don't have real text or data.
				 */
				int mib[2];

				mib[0] = CTL_KERN;
				mib[1] = KERN_VERSION;
				len = sizeof(buf);
				if (sysctl(mib, 2, buf, &len, NULL, 0) == -1) {
					err(1, "sysctl can't find kernel "
					    "version string");
				}
				if ((p = strchr(buf, '\n')) != NULL)
					*(p+1) = '\0';
			}
			key.data = (u_char *)VRS_KEY;
			key.size = sizeof(VRS_KEY) - 1;
			data.data = (u_char *)buf;
			data.size = strlen(buf);
			if (db->put(db, &key, &data, 0))
				err(1, "record enter");

			/* Restore to original values. */
			data.data = (u_char *)&nbuf;
			data.size = sizeof(NLIST);
			if (!ksyms && fseek(fp, cur_off, SEEK_SET) == -1) {
				fmterr = "corrupted string table";
				free(strtab);
				return (-1);
			}
		}
	}
	(void)fclose(fp);
	return (0);
}

/*
 * XXX: Using this value from machine/param.h introduces a
 * XXX: machine dependency on this program, so /usr can not
 * XXX: be shared between (i.e.) several m68k machines.
 * Instead of compiling in KERNTEXTOFF or KERNBASE, try to
 * determine the text start address from a standard symbol.
 * For backward compatibility, use the old compiled-in way
 * when the standard symbol name is not found.
 */
#ifndef KERNTEXTOFF
#define KERNTEXTOFF KERNBASE
#endif

static u_long
get_kerntext(char *name, u_int magic)
{
	NLIST nl[2];

	bzero((caddr_t)nl, sizeof(nl));
	nl[0]._name = "_kernel_text";

	if (nlist(name, nl) != 0)
		return (KERNTEXTOFF);

	return (nl[0].n_value);
}

#endif /* _NLIST_DO_AOUT */

a307 141
#ifdef _NLIST_DO_ECOFF

#define check(off, size)	((off < 0) || (off + size > mappedsize))
#define BAD			do { rv = -1; goto out; } while (0)
#define BADUNMAP		do { rv = -1; goto unmap; } while (0)
#define ECOFF_INTXT(p, e)	((p) > (e)->a.text_start && \
				 (p) < (e)->a.text_start + (e)->a.tsize)
#define ECOFF_INDAT(p, e)	((p) > (e)->a.data_start && \
				 (p) < (e)->a.data_start + (e)->a.dsize)

int
__ecoff_knlist(int fd, DB *db, int ksyms)
{
	struct ecoff_exechdr *exechdrp;
	struct ecoff_symhdr *symhdrp;
	struct ecoff_extsym *esyms;
	struct stat st;
	char *mappedfile, *cp;
	size_t mappedsize;
	u_long symhdroff, extstroff, off;
	u_int symhdrsize;
	int rv = 0;
	long i, nesyms;
	DBT data, key;
	NLIST nbuf;
	char *sname = NULL;
	size_t len, snamesize = 0;

	if (fstat(fd, &st) < 0)
		err(1, "can't stat %s", kfile);
	if (st.st_size > SIZE_T_MAX) {
		fmterr = "file too large";
		BAD;
	}

	mappedsize = st.st_size;
	mappedfile = mmap(NULL, mappedsize, PROT_READ, MAP_SHARED|MAP_FILE, fd, 0);
	if (mappedfile == MAP_FAILED) {
		fmterr = "unable to mmap";
		BAD;
	}

	if (check(0, sizeof *exechdrp))
		BADUNMAP;
	exechdrp = (struct ecoff_exechdr *)&mappedfile[0];

	if (ECOFF_BADMAG(exechdrp))
		BADUNMAP;

	symhdroff = exechdrp->f.f_symptr;
	symhdrsize = exechdrp->f.f_nsyms;
	if (symhdrsize == 0) {
		fmterr = "stripped";
		return (-1);
	}

	if (check(symhdroff, sizeof *symhdrp) ||
	    sizeof *symhdrp != symhdrsize)
		BADUNMAP;
	symhdrp = (struct ecoff_symhdr *)&mappedfile[symhdroff];

	nesyms = symhdrp->esymMax;
	if (check(symhdrp->cbExtOffset, nesyms * sizeof *esyms))
		BADUNMAP;
	esyms = (struct ecoff_extsym *)&mappedfile[symhdrp->cbExtOffset];
	extstroff = symhdrp->cbSsExtOffset;

	data.data = (u_char *)&nbuf;
	data.size = sizeof(NLIST);

	for (sname = NULL, i = 0; i < nesyms; i++) {
		/* Need to prepend a '_' */
		len = strlen(&mappedfile[extstroff + esyms[i].es_strindex]) + 1;
		if (len >= snamesize) {
			char *newsname;
			int newsnamesize = len + 1024;

			newsname = realloc(sname, newsnamesize);
			if (newsname == NULL) {
				if (sname)
					free(sname);
				sname = NULL;
			} else {
				sname = newsname;
				snamesize = newsnamesize;
			}
		}
		if (sname == NULL)
			errx(1, "cannot allocate memory");
		*sname = '_';
		strlcpy(sname+1, &mappedfile[extstroff + esyms[i].es_strindex],
		    snamesize - 1);

		/* Fill in NLIST */
		bzero(&nbuf, sizeof(nbuf));
		nbuf.n_value = esyms[i].es_value;
		nbuf.n_type = N_EXT;		/* XXX */

		/* Store entry in db */
		key.data = (u_char *)sname;
		key.size = strlen(sname);
		if (db->put(db, &key, &data, 0))
			err(1, "record enter");

		if (strcmp(sname, VRS_SYM) == 0) {
			key.data = (u_char *)VRS_KEY;
			key.size = sizeof(VRS_KEY) - 1;

			/* Version string may be in either text or data segs */
			if (ECOFF_INTXT(nbuf.n_value, exechdrp))
				off = nbuf.n_value - exechdrp->a.text_start +
				    ECOFF_TXTOFF(exechdrp);
			else if (ECOFF_INDAT(nbuf.n_value, exechdrp))
				off = nbuf.n_value - exechdrp->a.data_start +
				    ECOFF_DATOFF(exechdrp);
			else
				err(1, "unable to find version string");

			/* Version string should end in newline but... */
			data.data = &mappedfile[off];
			if ((cp = strchr(data.data, '\n')) != NULL)
				data.size = cp - (char *)data.data;
			else
				data.size = strlen((char *)data.data);

			if (db->put(db, &key, &data, 0))
				err(1, "record enter");

			/* Restore to original values */
			data.data = (u_char *)&nbuf;
			data.size = sizeof(nbuf);
		}
	}

unmap:
	munmap(mappedfile, mappedsize);
out:
	return (rv);
}
#endif /* _NLIST_DO_ECOFF */

a310 3
#ifdef _NLIST_DO_AOUT
	{ __aout_knlist },
#endif
a312 3
#endif
#ifdef _NLIST_DO_ECOFF
	{ __ecoff_knlist },
@


1.41
log
@Allow for a kernel linked at address zero; ok guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.40 2012/04/06 18:06:40 deraadt Exp $	*/
d321 1
a321 1
		errx(1, "cannot allocate %d bytes for symbol header",
@


1.40
log
@iterate over e_shnum using Elf32_Word instead of int
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.39 2009/11/11 16:44:59 deraadt Exp $	*/
d336 2
a337 1
	symstrsize = symsize = kernvma = 0;
d356 1
a356 1
	if (!symstrsize || !symsize || !kernvma) {
@


1.39
log
@patch a whole bunch of memory leaks, parfait only spotted one of them
ok miod jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.38 2009/10/27 23:59:51 deraadt Exp $	*/
d300 2
a301 1
	int i, j, error = 0;
@


1.38
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.37 2007/09/02 15:19:38 deraadt Exp $	*/
d125 1
d133 1
d152 1
d210 1
d221 1
d254 1
d296 1
a296 1
	caddr_t strtab;
d300 1
a300 1
	int i, j;
d325 2
a326 1
		return (-1);
d331 2
a332 1
		return (-1);
a334 1

d356 2
a357 1
		return (-1);
d375 2
a376 1
			return (-1);
a378 1
			free(strtab);
d380 2
a381 1
			return (-1);
a383 1
			free(strtab);
d385 2
a386 1
			return (-1);
d392 2
a393 1
		return (-1);
d407 2
a408 1
			return (-1);
d467 2
a468 1
					return (-1);
d478 2
a479 1
					return (-1);
d514 2
a515 1
				return (-1);
d519 7
a525 4
	if (usemalloc)
		free(strtab);
	else
		munmap(strtab, symstrsize);
d527 3
a529 1
	return (0);
@


1.37
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.36 2007/03/18 16:28:10 mickey Exp $	*/
a30 8

#ifndef lint
#if 0
static char sccsid[] = "from: @@(#)nlist.c	8.1 (Berkeley) 6/6/93";
#else
static const char rcsid[] = "$OpenBSD: nlist.c,v 1.36 2007/03/18 16:28:10 mickey Exp $";
#endif
#endif /* not lint */
@


1.36
log
@do not use section names for locating a string tab; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.35 2003/09/25 16:52:11 deraadt Exp $	*/
d36 1
a36 1
static const char rcsid[] = "$OpenBSD: nlist.c,v 1.35 2003/09/25 16:52:11 deraadt Exp $";
d320 1
a320 1
	sh = (Elf_Shdr *)malloc(sizeof(Elf_Shdr) * eh.e_shnum);
@


1.35
log
@realloc fixes; markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.34 2003/06/26 21:36:39 deraadt Exp $	*/
d36 1
a36 1
static const char rcsid[] = "$OpenBSD: nlist.c,v 1.34 2003/06/26 21:36:39 deraadt Exp $";
d300 1
a300 1
	u_long symsize;
d302 1
a302 1
	int i;
d304 1
a304 2
	size_t symstrsize;
	char *shstr, buf[1024];
a334 12
	shstr = (char *)malloc(sh[eh.e_shstrndx].sh_size);
	if (shstr == NULL)
		errx(1, "cannot allocate %d bytes for symbol string",
		    sh[eh.e_shstrndx].sh_size);
	if (fseek (fp, sh[eh.e_shstrndx].sh_offset, SEEK_SET) < 0) {
		fmterr = "corrupt file";
		return (-1);
	}
	if (fread(shstr, sh[eh.e_shstrndx].sh_size, 1, fp) != 1) {
		fmterr = "corrupt file";
		return (-1);
	}
d336 1
d338 8
a345 5
		if (strcmp (shstr + sh[i].sh_name, ".strtab") == 0) {
			symstroff = sh[i].sh_offset;
			symstrsize = sh[i].sh_size;
		}
		else if (strcmp (shstr + sh[i].sh_name, ".symtab") == 0) {
d348 2
a349 2
		}
		else if (strcmp (shstr + sh[i].sh_name, ".text") == 0) {
d355 1
a355 4

	/* Check for files too large to mmap. */
	/* XXX is this really possible? */
	if (symstrsize > SIZE_T_MAX) {
d359 1
@


1.34
log
@ansi and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.33 2003/06/02 23:36:53 millert Exp $	*/
d36 1
a36 1
static const char rcsid[] = "$OpenBSD: nlist.c,v 1.33 2003/06/02 23:36:53 millert Exp $";
d168 12
a179 2
				snamesize = len + 1024;
				sname = realloc(sname, snamesize);
d607 12
a618 2
			snamesize = len + 1024;
			sname = realloc(sname, snamesize);
@


1.33
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.32 2003/04/06 23:21:41 tedu Exp $	*/
d36 1
a36 1
static const char rcsid[] = "$OpenBSD: nlist.c,v 1.32 2003/04/06 23:21:41 tedu Exp $";
d82 1
a82 4
__aout_knlist(fd, db, ksyms)
	int fd;
	DB *db;
	int ksyms;
d269 1
a269 3
get_kerntext(name, magic)
	char *name;
	u_int magic;
d286 1
a286 4
__elf_knlist(fd, db, ksyms)
	int fd;
	DB *db;
	int ksyms;
d534 1
a534 4
__ecoff_knlist(fd, db, ksyms)
	int fd;
	DB *db;
	int ksyms;
d669 1
a669 4
create_knlist(name, fd, db)
	char *name;
	int fd;
	DB *db;
@


1.32
log
@use snamesize and realloc properly.  ok tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.31 2003/04/04 22:40:52 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d36 1
a36 1
static const char rcsid[] = "$OpenBSD: nlist.c,v 1.31 2003/04/04 22:40:52 deraadt Exp $";
@


1.31
log
@strlcpy; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.30 2002/11/30 15:35:13 mickey Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.30 2002/11/30 15:35:13 mickey Exp $";
d174 4
a177 2
			if (len >= snamesize)
				sname = realloc(sname, len + 1024);
d181 1
a181 1
			strlcpy(sname+1, p, len);
d453 1
a453 1
		if(ELF_ST_BIND(sbuf.st_info) == STB_LOCAL)
d611 4
a614 2
		if (len >= snamesize)
			sname = realloc(sname, len + 1024);
d619 1
a619 1
		    len - 1);
@


1.30
log
@be better about the STT_NOTYPE symbols, not all become N_UNDEF this way; pefo@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.29 2002/10/25 21:55:01 mickey Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.29 2002/10/25 21:55:01 mickey Exp $";
d179 1
a179 1
			strcpy(sname+1, p);
d455 1
a455 1
		strcpy(buf + 1, strtab + sbuf.st_name);
d614 2
a615 1
		strcpy(sname+1, &mappedfile[extstroff + esyms[i].es_strindex]);
@


1.29
log
@prepend the underscore always for elf, this makes kvm_bsd.db work on elf platforms; drahn@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.28 2002/09/06 19:04:49 deraadt Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.28 2002/09/06 19:04:49 deraadt Exp $";
d426 14
a439 1
			nbuf.n_type = N_UNDF;
d446 3
@


1.28
log
@fopen() does not return < 0
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.27 2002/05/30 19:09:05 deraadt Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.27 2002/05/30 19:09:05 deraadt Exp $";
d423 1
a423 1
		/*XXX type conversion is pretty rude... */
d438 3
a440 8
		if(eh.e_machine == EM_MIPS) {
			*buf = '_';
			strcpy(buf+1,strtab + sbuf.st_name);
			key.data = (u_char *)buf;
		}
		else {
			key.data = (u_char *)(strtab + sbuf.st_name);
		}
@


1.27
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.26 2002/03/25 16:41:43 deraadt Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.26 2002/03/25 16:41:43 deraadt Exp $";
d313 1
a313 1
	if ((fp = fdopen(fd, "r")) < 0)
@


1.26
log
@bring in prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.25 2002/03/14 16:44:25 mpech Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.25 2002/03/14 16:44:25 mpech Exp $";
d150 1
a150 1
	
d364 1
a364 1
	
a643 1
		
@


1.25
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.24 2002/02/20 23:07:49 pefo Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.24 2002/02/20 23:07:49 pefo Exp $";
d483 1
a483 1
				int len;
@


1.24
log
@Fix ELF so it works with /dev/ksyms. Also make 'detection' of ksyms
a little more robust by looking at the actual namelist filename.
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.23 2002/02/16 21:28:03 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.23 2002/02/16 21:28:03 millert Exp $";
d91 1
a91 1
	register int nsyms;
d298 5
a302 5
	register caddr_t strtab;
	register off_t symstroff, symoff;
	register u_long symsize;
	register u_long kernvma, kernoffs;
	register int i;
@


1.23
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.22 2001/05/11 13:08:09 art Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.22 2001/05/11 13:08:09 art Exp $";
d53 1
d86 1
a86 1
__aout_knlist(fd, db)
d89 1
d190 1
a190 1
			long cur_off = -1;
d192 1
a192 1
			if (ebuf.a_data && ebuf.a_text > __LDPGSZ) {
d224 1
a224 2
				 * No data segment and text is __LDPGSZ.
				 * This must be /dev/ksyms or a look alike.
d250 1
a250 1
			if (cur_off != -1 && fseek(fp, cur_off, SEEK_SET) == -1) {
d293 1
a293 1
__elf_knlist(fd, db)
d296 1
d451 34
a484 12
			long cur_off, voff;
			/*
			 * Calculate offset to the version string in the
			 * file.  kernvma is where the kernel is really
			 * loaded; kernoffs is where in the file it starts.
			 */
			voff = nbuf.n_value - kernvma + kernoffs;
			cur_off = ftell(fp);
			if (fseek(fp, voff, SEEK_SET) == -1) {
				fmterr = "corrupted string table";
				return (-1);
			}
d486 9
a494 8
			/*
			 * Read version string up to, and including newline.
			 * This code assumes that a newline terminates the
			 * version line.
			 */
			if (fgets(buf, sizeof(buf), fp) == NULL) {
				fmterr = "corrupted string table";
				return (-1);
d507 1
a507 1
			if (fseek(fp, cur_off, SEEK_SET) == -1) {
d533 1
a533 1
__ecoff_knlist(fd, db)
d536 1
d655 1
a655 1
	int	(*fn)(int fd, DB *db);
d674 7
a680 1
	int i, error;
d686 1
a686 1
		if ((error = (nlist_fn[i].fn)(fd, db)) != 1)
@


1.22
log
@MAP_COPY -> MAP_SHARED (it's ok in this case (/dev/ksyms))
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.21 2001/02/03 03:03:07 art Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.21 2001/02/03 03:03:07 art Exp $";
d82 1
a82 1
static u_long get_kerntext __P((char *kfn, u_int magic));
d629 1
a629 1
	int	(*fn) __P((int fd, DB *db));
@


1.21
log
@ELF: fallback to malloc when mmap fails. for /dev/ksyms.
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.20 2001/01/25 05:40:28 art Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.20 2001/01/25 05:40:28 art Exp $";
d535 1
a535 1
	mappedfile = mmap(NULL, mappedsize, PROT_READ, MAP_COPY|MAP_FILE, fd, 0);
@


1.20
log
@Make nlist elf-size independent.
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.19 2000/06/30 16:00:25 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.19 2000/06/30 16:00:25 millert Exp $";
d309 1
d374 3
d379 17
a395 4
	    MAP_PRIVATE|MAP_FILE, fileno(fp), symstroff);
	if (strtab == (char *)-1) {
		fmterr = "corrupt file";
		return (-1);
d488 4
a491 1
	munmap(strtab, symstrsize);
@


1.19
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.18 1999/03/24 05:25:57 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.18 1999/03/24 05:25:57 millert Exp $";
d301 1
a301 1
	Elf32_Sym sbuf;
d304 2
a305 2
	Elf32_Ehdr eh;
	Elf32_Shdr *sh = NULL;
d318 1
a318 1
	sh = (Elf32_Shdr *)malloc(sizeof(Elf32_Shdr) * eh.e_shnum);
d321 1
a321 1
		    sizeof(Elf32_Shdr) * eh.e_shnum);
d328 1
a328 1
	if (fread(sh, sizeof(Elf32_Shdr) * eh.e_shnum, 1, fp) != 1) {
d391 1
a391 1
		symsize -= sizeof(Elf32_Sym);
d405 1
a405 1
		switch(ELF32_ST_TYPE(sbuf.st_info)) {
d416 1
a416 1
		if(ELF32_ST_BIND(sbuf.st_info) == STB_LOCAL)
@


1.18
log
@Only exit in nlist.c due to a memory error, otherwise just return.  A return value of 1 indicates an incorrect executable type, a return value of -1 indicates some other problem.  This gives us better fallback from /dev/ksyms to /bsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.17 1998/12/19 18:48:05 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.17 1998/12/19 18:48:05 millert Exp $";
d396 1
a396 1
				warn(kfile);
@


1.18.6.1
log
@Pull in patch from current:
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.19 2000/06/30 16:00:25 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.19 2000/06/30 16:00:25 millert Exp $";
d396 1
a396 1
				warn("%s", kfile);
@


1.17
log
@back out recently added sanity check for data and bss as ksyms has neither
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.16 1998/11/29 09:34:09 downsj Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.16 1998/11/29 09:34:09 downsj Exp $";
a76 1
#define	badfmt(str)	errx(1, "%s: %s: %s", kfile, str, strerror(EFTYPE))
a81 1
static void badread __P((int, char *));
d104 1
a104 1
		return (-1);
d110 1
a110 1
		return (-1);
d114 4
a117 2
	if (!ebuf.a_syms)
		badfmt("stripped");
d120 4
a123 2
	if (lseek(fd, N_STROFF(ebuf), SEEK_SET) == -1)
		badfmt("corrupted string table");
d127 4
a130 2
	if (nr != sizeof(strsize))
		badread(nr, "no symbol table");
d136 4
a139 2
	if ((nr = read(fd, strtab, strsize)) != strsize)
		badread(nr, "corrupted symbol table");
d144 4
a147 2
	if (fseek(fp, N_SYMOFF(ebuf), SEEK_SET) == -1)
		err(1, "%s", kfile);
d160 4
a163 2
				badfmt("corrupted symbol table");
			err(1, "%s", kfile);
d165 1
a165 1
		if (!nbuf._strx || nbuf.n_type&N_STAB)
d206 4
a209 2
				if (fseek(fp, voff, SEEK_SET) == -1)
					badfmt("corrupted string table");
d216 4
a219 2
				if (fgets(buf, sizeof(buf), fp) == NULL)
					badfmt("corrupted string table");
d249 4
a252 2
			if (cur_off != -1 && fseek(fp, cur_off, SEEK_SET) == -1)
				badfmt("corrupted string table");
a287 10
static void
badread(nr, p)
	int nr;
	char *p;
{
	if (nr < 0)
		err(1, "%s", kfile);
	badfmt(p);
}

d316 1
a316 1
		return (-1);
d323 4
a326 2
	if (fseek (fp, eh.e_shoff, SEEK_SET) < 0)
		badfmt("no exec header");
d328 4
a331 2
	if (fread(sh, sizeof(Elf32_Shdr) * eh.e_shnum, 1, fp) != 1)
		badfmt("no exec header");
d337 8
a344 4
	if (fseek (fp, sh[eh.e_shstrndx].sh_offset, SEEK_SET) < 0)
		badfmt("corrupt file");
	if (fread(shstr, sh[eh.e_shstrndx].sh_size, 1, fp) != 1)
		badfmt("corrupt file");
d365 2
a366 1
		badfmt("corrupt file");
d376 4
a379 2
	if (strtab == (char *)-1)
		badfmt("corrupt file");
d381 4
a384 2
	if (fseek(fp, symoff, SEEK_SET) == -1)
		badfmt("corrupt file");
d394 4
a397 2
				badfmt("corrupted symbol table");
			err(1, "%s", kfile);
d440 4
a443 2
			if (fseek(fp, voff, SEEK_SET) == -1)
				badfmt("corrupted string table");
d450 4
a453 2
			if (fgets(buf, sizeof(buf), fp) == NULL)
				badfmt("corrupted string table");
d465 4
a468 2
			if (fseek(fp, cur_off, SEEK_SET) == -1)
				badfmt("corrupted string table");
d530 4
a533 2
	if (symhdrsize == 0)
		badfmt("stripped");
d633 2
a634 1
		if ((error = (nlist_fn[i].fn)(fd, db)) == 0)
d638 1
a638 1
		badfmt(fmterr);
@


1.16
log
@Blow up a little more verbosely if something's feeding us garbage.
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.15 1998/10/28 23:20:01 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.15 1998/10/28 23:20:01 millert Exp $";
a117 4

	/* Sanity check. */
	if (!ebuf.a_data || !ebuf.a_bss)
		badfmt("corrupt exec header");
@


1.15
log
@uninitialized variable; hgweigand@@wiesbaden.netsurf.de
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.14 1998/09/26 07:16:23 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.14 1998/09/26 07:16:23 millert Exp $";
d119 4
d135 1
a135 1
		errx(1, "cannot allocate %d bytes", strsize);
d318 1
a318 1
		errx(1, "cannot allocate %d bytes",
d329 2
a330 1
		errx(1, "cannot allocate %d bytes", sh[eh.e_shstrndx].sh_size);
@


1.14
log
@if malloc fails, say how much we tried to alloc
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.13 1998/08/23 00:57:15 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.13 1998/08/23 00:57:15 millert Exp $";
d99 1
a99 1
	size_t snamesize;
@


1.13
log
@o If the user doesn't specify a file, use /dev/ksyms in preference to
  /bsd if it exists and we can open it.
o Fix a bug where kvm_mkdb would leave a temp file in /var/db if the
  file argument didn't exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.12 1998/08/21 19:31:29 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.12 1998/08/21 19:31:29 millert Exp $";
d131 1
a131 1
		errx(1, "cannot allocate memory");
d314 2
a315 1
		errx(1, "cannot allocate memory");
d325 1
a325 1
		errx(1, "cannot allocate memory");
@


1.12
log
@oops, remove debugging info
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.11 1998/08/21 19:24:39 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.11 1998/08/21 19:24:39 millert Exp $";
d87 2
a88 2
__aout_knlist(name, db)
	char *name;
d96 1
a96 1
	int fd, nr, strsize;
a101 4
	kfile = name;
	if ((fd = open(name, O_RDONLY, 0)) < 0)
		err(1, "can't open %s", name);

d137 1
a137 1
		err(1, "%s", name);
d139 1
a139 1
		err(1, "%s", name);
d144 1
a144 1
	kerntextoff = get_kerntext(name, N_GETMAGIC(ebuf));
d153 1
a153 1
			err(1, "%s", name);
d286 2
a287 2
__elf_knlist(name, db)
	char *name;
a289 1
	register struct nlist *p;
d294 1
a294 1
	register int cc, i;
a295 1
	Elf32_Sym *s;
a299 1
	struct stat st;
d304 2
a305 3
	kfile = name;
	if ((fp = fopen(name, "r")) < 0)
		err(1, "%s", name);
d374 1
a374 1
			err(1, "%s", name);
d459 2
a460 2
__ecoff_knlist(name, db)
	char *name;
a474 1
	int fd;
a477 4
	kfile = name;
	if ((fd = open(name, O_RDONLY)) == -1)
		err(1, "%s", name);

d479 1
a479 1
		err(1, "can't stat %s", name);
d578 1
a578 1
	int	(*fn) __P((char *name, DB *db));
d592 1
a592 1
create_knlist(name, db)
d594 1
d601 2
a602 1
		if ((error = (nlist_fn[i].fn)(name, db)) == 0)
@


1.11
log
@Changes to work with /dev/ksyms:
    o If we are have no data segment and text seg is __LDPGSZ, we must be
      /dev/ksyms or an equivalent so use sysctl to get version string.
    o fix an int vs. long issue and prepend '_' to symbols that lack one
      (alpha for instance).
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.10 1998/08/20 00:14:03 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.10 1998/08/20 00:14:03 millert Exp $";
a171 1
			puts(sname);
@


1.10
log
@ecoff support, based on libc/gen/nlist.c
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.9 1998/08/19 07:43:40 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.9 1998/08/19 07:43:40 millert Exp $";
d63 1
d97 1
d99 2
a100 1
	char *strtab, buf[1024];
d152 1
d162 17
a178 2
		key.data = (u_char *)strtab + nbuf._strx - sizeof(long);
		key.size = strlen((char *)key.data);
d183 1
a183 23
			long cur_off, voff;
			/*
			 * Calculate offset relative to a normal (non-kernel)
			 * a.out.  Kerntextoff is where the kernel is really
			 * loaded; N_TXTADDR is where a normal file is loaded.
			 * From there, locate file offset in text or data.
			 */
			voff = nbuf.n_value - kerntextoff + N_TXTADDR(ebuf);
			if ((nbuf.n_type & N_TYPE) == N_TEXT)
				voff += N_TXTOFF(ebuf) - N_TXTADDR(ebuf);
			else
				voff += N_DATOFF(ebuf) - N_DATADDR(ebuf);
			cur_off = ftell(fp);
			if (fseek(fp, voff, SEEK_SET) == -1)
				badfmt("corrupted string table");

			/*
			 * Read version string up to, and including newline.
			 * This code assumes that a newline terminates the
			 * version line.
			 */
			if (fgets(buf, sizeof(buf), fp) == NULL)
				badfmt("corrupted string table");
d185 45
d240 1
a240 1
			if (fseek(fp, cur_off, SEEK_SET) == -1)
d532 1
a532 1
	for (i = 0; i < nesyms; i++) {
d534 1
a534 1
		len = strlen(&mappedfile[extstroff + esyms[i].es_strindex]);
d536 1
a536 1
			sname = malloc(len + 1024);
@


1.9
log
@clean up our temp files on failure
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.8 1998/08/19 06:47:54 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.8 1998/08/19 06:47:54 millert Exp $";
d68 4
d124 1
a124 1
	/* Read in the size of the symbol table. */
d416 9
d430 116
a545 1
	return (-1);
@


1.8
log
@Make kvm_mkdb work again
 o testdb() needs to take as an arg the name of the kernel so it can do
   the version test correctly.
 o add undocumented verbose flag to tell when we are rebuilding the .db file
 o DO_* -> _NLIST_DO_*, this prevented kvm_mkdb from doing anything at all.
 o preserve a few error messages so you get error output when none of
   the exec types match the target.
 o check malloc return values
 o get_kerntext should not subtract the sizeof(struct exec) from kernel_text
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.7 1997/12/15 10:15:39 deraadt Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.7 1997/12/15 10:15:39 deraadt Exp $";
d435 1
a435 1
void
d449 2
a450 2
	if (error)
		errx(1, "cannot determine executable type of %s", name);
@


1.7
log
@use MAP_PRIVATE|MAP_FILE; mrg
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.6 1997/01/15 22:08:16 millert Exp $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.6 1997/01/15 22:08:16 millert Exp $";
d64 1
a64 1
#ifdef DO_ELF
d74 1
d76 1
a76 1
#if defined(DO_AOUT)
d97 1
a97 1
		err(1, "%s", name);
d101 4
a104 2
	if (nr != sizeof(struct exec))
		return(-1);
d107 4
a110 2
	if (N_BADMAG(ebuf))
		return(-1);
d112 1
d128 1
a128 1
		err(1, NULL);
d199 1
a199 1
	return(0);
a227 2
	if (magic == ZMAGIC || magic == QMAGIC)
		return (nl[0].n_value - sizeof(struct exec));
d241 1
a241 1
#endif /* DO_AOUT */
d243 1
a243 1
#ifdef DO_ELF
d273 1
a273 1
		return(-1);
d276 2
d286 2
d407 1
a407 1
	return(0);
d409 1
a409 1
#endif /* DO_ELF */
d411 1
a411 1
#ifdef DO_ECOFF
d419 1
a419 1
#endif /* DO_ECOFF */
d424 1
a424 1
#ifdef DO_AOUT
d427 1
a427 1
#ifdef DO_ELF
d430 1
a430 1
#ifdef DO_ECOFF
d440 1
a440 1
	int n, i;
d443 2
a444 2
		n = (nlist_fn[i].fn)(name, db);
		if (n != -1)
d447 4
@


1.6
log
@From NetBSD: make testdb() fail if database version string has length zero.
Also, KNF, b* -> mem*, getopt tests against -1, not EOF, and index -> strchr.
Added OpenBSD tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
d40 1
a40 1
static char *rcsid = "$OpenBSD: nlist.c,v 1.5 1996/07/31 17:21:47 deraadt Exp $";
d312 2
a313 1
	strtab = mmap(NULL, (size_t)symstrsize, PROT_READ, 0, fileno(fp), symstroff);
@


1.5
log
@comment an #endif
@
text
@d1 2
d37 5
a41 2
/*static char sccsid[] = "from: @@(#)nlist.c	8.1 (Berkeley) 6/6/93";*/
static char *rcsid = "$Id: nlist.c,v 1.4 1996/07/31 16:51:51 deraadt Exp $";
@


1.4
log
@zmagic/qmagic has kernel offset problem; netbsd pr#2665, leo@@marco.de.
also rely on machine/exec.h DO_{AOUT,ELF,...} symbols, and declare a
stub ecoff handler for niklas to finish writing (stealable from libc)
@
text
@d36 1
a36 1
static char *rcsid = "$Id: nlist.c,v 1.3 1996/05/24 09:22:59 deraadt Exp $";
d232 1
a232 1
#endif
@


1.3
log
@get_kerntext
@
text
@d36 1
a36 1
static char *rcsid = "$Id: nlist.c,v 1.2 1996/05/17 20:04:55 pefo Exp $";
a38 3
#define DO_AOUT			/* always do a.out */
#define	DO_ELF			/* and elf too */

a67 4

static void badread __P((int, char *));
static u_long get_kerntext __P((char *kfn));

d72 3
d130 1
a130 1
	kerntextoff = get_kerntext(name);
d191 41
d397 3
a399 25
static void
badread(nr, p)
	int nr;
	char *p;
{
	if (nr < 0)
		err(1, "%s", kfile);
	badfmt(p);
}

/*
 * XXX: Using this value from machine/param.h introduces a
 * XXX: machine dependency on this program, so /usr can not
 * XXX: be shared between (i.e.) several m68k machines.
 * Instead of compiling in KERNTEXTOFF or KERNBASE, try to
 * determine the text start address from a standard symbol.
 * For backward compatibility, use the old compiled-in way
 * when the standard symbol name is not found.
 */
#ifndef KERNTEXTOFF
#define KERNTEXTOFF KERNBASE
#endif

static u_long
get_kerntext(name)
d401 1
d403 1
a403 9
	NLIST nl[2];

	bzero((caddr_t)nl, sizeof(nl));
	nl[0]._name = "_kernel_text";

	if (nlist(name, nl) != 0)
		return (KERNTEXTOFF);

	return (nl[0].n_value);
d405 1
d415 3
@


1.2
log
@Addition of elf support.
@
text
@d36 1
a36 1
static char *rcsid = "$Id: nlist.c,v 1.1.1.1 1995/10/18 08:47:39 deraadt Exp $";
d73 1
d90 1
d134 2
a153 3
#ifndef KERNTEXTOFF
#define KERNTEXTOFF KERNBASE
#endif
d156 1
a156 1
			 * a.out.  KERNTEXTOFF is where the kernel is really
d160 1
a160 1
			voff = nbuf.n_value - KERNTEXTOFF + N_TXTADDR(ebuf);
d368 28
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
static char *rcsid = "$Id: nlist.c,v 1.10 1994/06/11 07:57:41 mycroft Exp $";
d39 3
d58 8
d76 4
a79 2
void
create_knlist(name, db)
d98 1
a98 1
		badfmt("no exec header");
d102 2
a103 1
		badfmt("bad magic number");
d191 165
d357 1
d367 25
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
