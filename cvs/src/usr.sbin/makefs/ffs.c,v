head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.2
	OPENBSD_6_1_BASE:1.31;
locks; strict;
comment	@ * @;


1.31
date	2017.01.21.21.58.32;	author natano;	state Exp;
branches;
next	1.30;
commitid	TkU6uOzl5rgGqObF;

1.30
date	2016.12.17.16.14.18;	author krw;	state Exp;
branches;
next	1.29;
commitid	UocWJZF9S79UPA4S;

1.29
date	2016.12.17.15.20.10;	author krw;	state Exp;
branches;
next	1.28;
commitid	4NG3zmJk4vBnrsQQ;

1.28
date	2016.11.14.09.03.19;	author natano;	state Exp;
branches;
next	1.27;
commitid	qc0vKiNWhK0GWuq6;

1.27
date	2016.11.13.10.22.21;	author natano;	state Exp;
branches;
next	1.26;
commitid	OTTgByMsEs4uwRyO;

1.26
date	2016.11.11.09.54.07;	author natano;	state Exp;
branches;
next	1.25;
commitid	Z4QvXKrzswQtHtNF;

1.25
date	2016.11.11.09.27.31;	author natano;	state Exp;
branches;
next	1.24;
commitid	vDI6hpDOEUWrAWkY;

1.24
date	2016.11.10.08.33.11;	author natano;	state Exp;
branches;
next	1.23;
commitid	j6FwWptqDrMjaNi2;

1.23
date	2016.11.10.08.26.38;	author natano;	state Exp;
branches;
next	1.22;
commitid	pR23SKoOr8iJVLcB;

1.22
date	2016.11.08.19.38.57;	author natano;	state Exp;
branches;
next	1.21;
commitid	xMgQeixVRSGz3Ceq;

1.21
date	2016.11.08.19.22.29;	author natano;	state Exp;
branches;
next	1.20;
commitid	vdZl9Veq16pymCmL;

1.20
date	2016.11.06.12.33.30;	author natano;	state Exp;
branches;
next	1.19;
commitid	sPCDsy9xorF1YWTA;

1.19
date	2016.10.26.15.31.13;	author natano;	state Exp;
branches;
next	1.18;
commitid	zqExfQ3CxlIJwRFt;

1.18
date	2016.10.26.07.53.47;	author natano;	state Exp;
branches;
next	1.17;
commitid	u5FhgAQMMhudj2OK;

1.17
date	2016.10.23.10.22.21;	author natano;	state Exp;
branches;
next	1.16;
commitid	rHhaLNWxkoYu4Pqx;

1.16
date	2016.10.22.19.43.50;	author natano;	state Exp;
branches;
next	1.15;
commitid	E9ru6iMm8TbER1tL;

1.15
date	2016.10.22.19.17.47;	author natano;	state Exp;
branches;
next	1.14;
commitid	984F18i0puIYFRTL;

1.14
date	2016.10.22.18.17.14;	author natano;	state Exp;
branches;
next	1.13;
commitid	Dnp7IFCOk553ITkR;

1.13
date	2016.10.22.17.15.28;	author natano;	state Exp;
branches;
next	1.12;
commitid	9rfmVkxAuKkwrvnz;

1.12
date	2016.10.22.16.51.52;	author natano;	state Exp;
branches;
next	1.11;
commitid	c3bc3iog8Vd2Umt6;

1.11
date	2016.10.22.10.13.08;	author natano;	state Exp;
branches;
next	1.10;
commitid	QPfi2q5wbd9otGsc;

1.10
date	2016.10.18.17.23.21;	author natano;	state Exp;
branches;
next	1.9;
commitid	mFWxcHDQMKvsT7VE;

1.9
date	2016.10.17.07.54.17;	author natano;	state Exp;
branches;
next	1.8;
commitid	bwAFBWlUquDxvgor;

1.8
date	2016.10.17.01.16.22;	author tedu;	state Exp;
branches;
next	1.7;
commitid	XIRBCiI8rxgjkmJi;

1.7
date	2016.10.16.22.26.34;	author tedu;	state Exp;
branches;
next	1.6;
commitid	Vfxjcer663rJsYUw;

1.6
date	2016.10.16.21.59.28;	author tedu;	state Exp;
branches;
next	1.5;
commitid	SARjsefQgjiMBFje;

1.5
date	2016.10.16.21.44.43;	author tedu;	state Exp;
branches;
next	1.4;
commitid	BytESShtfhdUtae0;

1.4
date	2016.10.16.20.30.40;	author natano;	state Exp;
branches;
next	1.3;
commitid	MIQhJqZTHW9Z31K2;

1.3
date	2016.10.16.20.26.56;	author natano;	state Exp;
branches;
next	1.2;
commitid	CmcYdpJMky9LxxDQ;

1.2
date	2016.10.16.19.53.11;	author natano;	state Exp;
branches;
next	1.1;
commitid	1ZHAN76P5QzJWokO;

1.1
date	2016.10.16.17.08.53;	author natano;	state Exp;
branches;
next	;
commitid	O38itEriwOj0afR7;


desc
@@


1.31
log
@Use MD disklabel position.
@
text
@/*	$OpenBSD: ffs.c,v 1.30 2016/12/17 16:14:18 krw Exp $	*/
/*	$NetBSD: ffs.c,v 1.66 2015/12/21 00:58:08 christos Exp $	*/

/*
 * Copyright (c) 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Luke Mewburn for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ffs_alloc.c	8.19 (Berkeley) 7/13/95
 */

#include <sys/param.h>
#include <sys/disklabel.h>

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>

#include "ffs/ufs_inode.h"
#include "ffs/ffs_extern.h"

#include "makefs.h"
#include "ffs.h"
#include "ffs/newfs_extern.h"

#undef DIP
#define DIP(dp, field) \
	((ffs_opts->version == 1) ? \
	(dp)->ffs1_din.di_##field : (dp)->ffs2_din.di_##field)

/*
 * Various file system defaults (cribbed from newfs(8)).
 */
#define	DFL_FRAGSIZE		2048		/* fragment size */
#define	DFL_BLKSIZE		16384		/* block size */
#define	DFL_SECSIZE		512		/* sector size */


typedef struct {
	u_char		*buf;		/* buf for directory */
	doff_t		size;		/* full size of buf */
	doff_t		cur;		/* offset of current entry */
} dirbuf_t;


static	int	ffs_create_image(const char *, fsinfo_t *);
static	void	ffs_make_dirbuf(dirbuf_t *, const char *, fsnode *);
static	int	ffs_populate_dir(const char *, fsnode *, fsinfo_t *);
static	void	ffs_size_dir(fsnode *, fsinfo_t *);
static	void	ffs_validate(const char *, fsnode *, fsinfo_t *);
static	void	ffs_write_file(union dinode *, uint32_t, void *, fsinfo_t *);
static	void	ffs_write_inode(union dinode *, uint32_t, const fsinfo_t *);
static  void	*ffs_build_dinode1(struct ufs1_dinode *, dirbuf_t *, fsnode *,
				 fsnode *, fsinfo_t *);
static  void	*ffs_build_dinode2(struct ufs2_dinode *, dirbuf_t *, fsnode *,
				 fsnode *, fsinfo_t *);



	/* publically visible functions */
void
ffs_prep_opts(fsinfo_t *fsopts)
{
	ffs_opt_t *ffs_opts = ecalloc(1, sizeof(*ffs_opts));

	const option_t ffs_options[] = {
	    { "avgfilesize", &ffs_opts->avgfilesize, OPT_INT32, 1, INT_MAX },
	    { "avgfpdir", &ffs_opts->avgfpdir, OPT_INT32, 1, INT_MAX },
	    { "bsize", &ffs_opts->bsize, OPT_INT32, 1, INT_MAX },
	    { "density", &ffs_opts->density, OPT_INT32, 1, INT_MAX },
	    { "disklabel", NULL, OPT_STRBUF, 0, 0 },
	    { "extent", &ffs_opts->maxbsize, OPT_INT32, 1, INT_MAX },
	    { "fsize", &ffs_opts->fsize, OPT_INT32, 1, INT_MAX },
	    { "label", ffs_opts->label, OPT_STRARRAY, 1, MAXVOLLEN },
	    { "maxbpcg", &ffs_opts->maxblkspercg, OPT_INT32, 1, INT_MAX },
	    { "maxbpg", &ffs_opts->maxbpg, OPT_INT32, 1, INT_MAX },
	    { "minfree", &ffs_opts->minfree, OPT_INT32, 0, 99 },
	    { "optimization", NULL, OPT_STRBUF, 0, 0 },
	    { "version", &ffs_opts->version, OPT_INT32, 1, 2 },
	    { .name = NULL }
	};

	ffs_opts->bsize = -1;
	ffs_opts->fsize = -1;
	ffs_opts->density = -1;
	ffs_opts->minfree = MINFREE;
	ffs_opts->optimization = FS_OPTSPACE;
	ffs_opts->maxbpg = -1;
	ffs_opts->avgfilesize = AVFILESIZ;
	ffs_opts->avgfpdir = AFPDIR;
	ffs_opts->version = 1;
	ffs_opts->lp = NULL;
	ffs_opts->pp = NULL;

	fsopts->fs_specific = ffs_opts;
	fsopts->fs_options = copy_opts(ffs_options);
}

void
ffs_cleanup_opts(fsinfo_t *fsopts)
{
	free(fsopts->fs_specific);
	free(fsopts->fs_options);
}

int
ffs_parse_opts(const char *option, fsinfo_t *fsopts)
{
	ffs_opt_t	*ffs_opts = fsopts->fs_specific;
	option_t *ffs_options = fsopts->fs_options;
	char buf[1024];

	int	rv;

	assert(option != NULL);
	assert(fsopts != NULL);
	assert(ffs_opts != NULL);

	rv = set_option(ffs_options, option, buf, sizeof(buf));
	if (rv == -1)
		return 0;

	if (ffs_options[rv].name == NULL)
		abort();

	if (strcmp(ffs_options[rv].name, "disklabel") == 0) {
		struct disklabel *dp;

		dp = getdiskbyname(buf);
		if (dp == NULL)
			errx(1, "unknown disk type: %s", buf);

		ffs_opts->lp = emalloc(sizeof(struct disklabel));
		*ffs_opts->lp = *dp;
	} else if (strcmp(ffs_options[rv].name, "optimization") == 0) {
		if (strcmp(buf, "time") == 0) {
			ffs_opts->optimization = FS_OPTTIME;
		} else if (strcmp(buf, "space") == 0) {
			ffs_opts->optimization = FS_OPTSPACE;
		} else {
			warnx("Invalid optimization `%s'", buf);
			return 0;
		}
	}
	return 1;
}


void
ffs_makefs(const char *image, const char *dir, fsnode *root, fsinfo_t *fsopts)
{
	struct fs	*superblock;
	ffs_opt_t	*ffs_opts = fsopts->fs_specific;

	assert(image != NULL);
	assert(dir != NULL);
	assert(root != NULL);
	assert(fsopts != NULL);

		/* validate tree and options */
	ffs_validate(dir, root, fsopts);

	printf("Calculated size of `%s': %lld bytes, %lld inodes\n",
	    image, (long long)fsopts->size, (long long)fsopts->inodes);

		/* create image */
	if (ffs_create_image(image, fsopts) == -1)
		errx(1, "Image file `%s' not created.", image);

	fsopts->curinode = ROOTINO;

		/* populate image */
	printf("Populating `%s'\n", image);
	if (! ffs_populate_dir(dir, root, fsopts))
		errx(1, "Image file `%s' not populated.", image);

	bcleanup();

		/* update various superblock parameters */
	superblock = fsopts->superblock;
	superblock->fs_fmod = 0;
	superblock->fs_ffs1_cstotal.cs_ndir   = superblock->fs_cstotal.cs_ndir;
	superblock->fs_ffs1_cstotal.cs_nbfree = superblock->fs_cstotal.cs_nbfree;
	superblock->fs_ffs1_cstotal.cs_nifree = superblock->fs_cstotal.cs_nifree;
	superblock->fs_ffs1_cstotal.cs_nffree = superblock->fs_cstotal.cs_nffree;

		/* write out superblock; image is now complete */
	ffs_write_superblock(fsopts->superblock, fsopts);

	if (ffs_opts->lp != NULL) {
		struct disklabel *lp = ffs_opts->lp;
		uint16_t *p, *end, sum = 0;
		ssize_t n;
		uint32_t bpg;

		bpg = superblock->fs_fpg / superblock->fs_frag;
		while (bpg > UINT16_MAX)
			bpg >>= 1;
		ffs_opts->pp->p_cpg = bpg;

		lp->d_magic = DISKMAGIC;
		lp->d_magic2 = DISKMAGIC;
		arc4random_buf(lp->d_uid, sizeof(lp->d_uid));
		lp->d_checksum = 0;

		p = (uint16_t *)lp;
		end = (uint16_t *)&lp->d_partitions[lp->d_npartitions];
		while (p < end)
			sum ^= *p++;
		lp->d_checksum = sum;

		n = pwrite(fsopts->fd, lp, sizeof(struct disklabel),
		    fsopts->offset + LABELSECTOR * DEV_BSIZE + LABELOFFSET);
		if (n == -1)
			err(1, "failed to write disklabel");
		else if (n < sizeof(struct disklabel))
			errx(1, "failed to write disklabel: short write");
	}

	if (close(fsopts->fd) == -1)
		err(1, "Closing `%s'", image);
	fsopts->fd = -1;
	printf("Image `%s' complete\n", image);
}

	/* end of public functions */


static void
ffs_validate(const char *dir, fsnode *root, fsinfo_t *fsopts)
{
	ffs_opt_t *ffs_opts = fsopts->fs_specific;
	struct disklabel *lp = ffs_opts->lp;
	struct partition *pp = NULL;
	int32_t	ncg = 1;
	int i;

	assert(dir != NULL);
	assert(root != NULL);
	assert(fsopts != NULL);
	assert(ffs_opts != NULL);

	if (lp != NULL) {
		for (i = 0; i < lp->d_npartitions; i++) {
			pp = &lp->d_partitions[i];
			if (pp->p_fstype == FS_BSDFFS &&
			    pp->p_offset * lp->d_secsize == fsopts->offset) {
				break;
			}
		}
		if (i == lp->d_npartitions)
			errx(1, "no matching partition found in the disklabel");
		ffs_opts->pp = pp;

		if (pp->p_fragblock == 0)
			errx(1, "fragment size missing in disktab");
		if (fsopts->freeblocks != 0 || fsopts->freeblockpc != 0 ||
		    fsopts->freefiles != 0 || fsopts->freefilepc != 0 ||
		    fsopts->minsize != 0 || fsopts->maxsize != 0 ||
		    fsopts->sectorsize != -1 || fsopts->size != 0)
			errx(1, "-bfMmSs and disklabel are mutually exclusive");
		if (ffs_opts->fsize != -1 || ffs_opts->bsize != -1)
			errx(1, "b/fsize and disklabel are mutually exclusive");

		fsopts->sectorsize = lp->d_secsize;
		fsopts->minsize = fsopts->maxsize =
		    DL_GETPSIZE(pp) * lp->d_secsize;
		ffs_opts->fsize = DISKLABELV1_FFS_FSIZE(pp->p_fragblock);
		ffs_opts->bsize = DISKLABELV1_FFS_BSIZE(pp->p_fragblock);
	}

		/* set FFS defaults */
	if (fsopts->sectorsize == -1)
		fsopts->sectorsize = DFL_SECSIZE;
	if (ffs_opts->fsize == -1)
		ffs_opts->fsize = MAX(DFL_FRAGSIZE, fsopts->sectorsize);
	if (ffs_opts->bsize == -1)
		ffs_opts->bsize = MIN(DFL_BLKSIZE, 8 * ffs_opts->fsize);
				/* fsopts->density is set below */
	/* XXX ondisk32 */
	if (ffs_opts->maxbpg == -1)
		ffs_opts->maxbpg = ffs_opts->bsize / sizeof(int32_t);

		/* calculate size of tree */
	ffs_size_dir(root, fsopts);
	fsopts->inodes += ROOTINO;		/* include first two inodes */

		/* add requested slop */
	fsopts->size += fsopts->freeblocks;
	fsopts->inodes += fsopts->freefiles;
	if (fsopts->freefilepc > 0)
		fsopts->inodes =
		    fsopts->inodes * (100 + fsopts->freefilepc) / 100;
	if (fsopts->freeblockpc > 0)
		fsopts->size =
		    fsopts->size * (100 + fsopts->freeblockpc) / 100;

		/* add space needed for superblocks */
	/*
	 * The old SBOFF (SBLOCK_UFS1) is used here because makefs is
	 * typically used for small filesystems where space matters.
	 * XXX make this an option.
	 */
	fsopts->size += (SBLOCK_UFS1 + SBLOCKSIZE) * ncg;
		/* add space needed to store inodes, x3 for blockmaps, etc */
	if (ffs_opts->version == 1)
		fsopts->size += ncg * sizeof(struct ufs1_dinode) *
		    roundup(fsopts->inodes / ncg,
			ffs_opts->bsize / sizeof(struct ufs1_dinode));
	else
		fsopts->size += ncg * sizeof(struct ufs2_dinode) *
		    roundup(fsopts->inodes / ncg,
			ffs_opts->bsize / sizeof(struct ufs2_dinode));

		/* add minfree */
	if (ffs_opts->minfree > 0)
		fsopts->size =
		    fsopts->size * (100 + ffs_opts->minfree) / 100;
	/*
	 * XXX	any other fs slop to add, such as csum's, bitmaps, etc ??
	 */

	if (fsopts->size < fsopts->minsize)	/* ensure meets minimum size */
		fsopts->size = fsopts->minsize;

		/* round up to the next block */
	fsopts->size = roundup(fsopts->size, ffs_opts->bsize);

		/* calculate density if necessary */
	if (ffs_opts->density == -1)
		ffs_opts->density = fsopts->size / fsopts->inodes + 1;

		/* now check calculated sizes vs requested sizes */
	if (fsopts->maxsize > 0 && fsopts->size > fsopts->maxsize) {
		errx(1, "`%s' size of %lld is larger than the maxsize of %lld.",
		    dir, (long long)fsopts->size, (long long)fsopts->maxsize);
	}
}


static int
ffs_create_image(const char *image, fsinfo_t *fsopts)
{
	struct fs	*fs;
	char	*buf;
	int	i, bufsize;
	off_t	bufrem;
	time_t	tstamp;
	int	oflags = O_RDWR | O_CREAT;

	assert (image != NULL);
	assert (fsopts != NULL);

		/* create image */
	if (fsopts->offset == 0)
		oflags |= O_TRUNC;
	if ((fsopts->fd = open(image, oflags, 0666)) == -1) {
		warn("Can't open `%s' for writing", image);
		return (-1);
	}

		/* zero image */
	bufsize = 8192;
	bufrem = fsopts->size;

	if (fsopts->offset != 0)
		if (lseek(fsopts->fd, fsopts->offset, SEEK_SET) == -1) {
			warn("can't seek");
			return -1;
		}

	if (bufrem > 0)
		buf = ecalloc(1, bufsize);
	while (bufrem > 0) {
		i = write(fsopts->fd, buf, MIN(bufsize, bufrem));
		if (i == -1) {
			warn("zeroing image, %lld bytes to go",
			    (long long)bufrem);
			free(buf);
			return (-1);
		}
		bufrem -= i;
	}
	if (buf)
		free(buf);

		/* make the file system */
	if (Tflag) {
		tstamp = stampts;
		srandom_deterministic(stampts);
	} else
		tstamp = start_time.tv_sec;

	fs = ffs_mkfs(image, fsopts, tstamp);
	fsopts->superblock = (void *)fs;

	if ((off_t)(fs->fs_cstotal.cs_nifree + ROOTINO) < fsopts->inodes) {
		warnx(
		"Image file `%s' has %lld free inodes; %lld are required.",
		    image,
		    (long long)(fs->fs_cstotal.cs_nifree + ROOTINO),
		    (long long)fsopts->inodes);
		return (-1);
	}
	return (fsopts->fd);
}


static void
ffs_size_dir(fsnode *root, fsinfo_t *fsopts)
{
	struct direct	tmpdir;
	fsnode *	node;
	int		curdirsize, this;
	ffs_opt_t	*ffs_opts = fsopts->fs_specific;

	/* node may be NULL (empty directory) */
	assert(fsopts != NULL);
	assert(ffs_opts != NULL);

#define	ADDDIRENT(e) do {						\
	tmpdir.d_namlen = strlen((e));					\
	this = DIRSIZ(NEWDIRFMT, &tmpdir);				\
	if (this + curdirsize > roundup(curdirsize, DIRBLKSIZ))	\
		curdirsize = roundup(curdirsize, DIRBLKSIZ);	\
	curdirsize += this;						\
} while (0);

	/*
	 * XXX	this needs to take into account extra space consumed
	 *	by indirect blocks, etc.
	 */
#define	ADDSIZE(x) do {							\
	fsopts->size += roundup((x), ffs_opts->fsize);			\
} while (0);

	curdirsize = 0;
	for (node = root; node != NULL; node = node->next) {
		ADDDIRENT(node->name);
		if (node == root) {			/* we're at "." */
			assert(strcmp(node->name, ".") == 0);
			ADDDIRENT("..");
		} else if ((node->inode->flags & FI_SIZED) == 0) {
				/* don't count duplicate names */
			node->inode->flags |= FI_SIZED;
			fsopts->inodes++;
			if (node->type == S_IFREG)
				ADDSIZE(node->inode->st.st_size);
			if (node->type == S_IFLNK) {
				size_t	slen;

				slen = strlen(node->symlink) + 1;
				if (slen >= (ffs_opts->version == 1 ?
						MAXSYMLINKLEN_UFS1 :
						MAXSYMLINKLEN_UFS2))
					ADDSIZE(slen);
			}
		}
		if (node->type == S_IFDIR)
			ffs_size_dir(node->child, fsopts);
	}
	ADDSIZE(curdirsize);
}

static void *
ffs_build_dinode1(struct ufs1_dinode *dinp, dirbuf_t *dbufp, fsnode *cur,
		 fsnode *root, fsinfo_t *fsopts)
{
	size_t slen;
	void *membuf;

	memset(dinp, 0, sizeof(*dinp));
	dinp->di_mode = cur->inode->st.st_mode;
	dinp->di_nlink = cur->inode->nlink;
	dinp->di_size = cur->inode->st.st_size;
	dinp->di_flags = cur->inode->st.st_flags;
	dinp->di_gen = cur->inode->st.st_gen;
	dinp->di_uid = cur->inode->st.st_uid;
	dinp->di_gid = cur->inode->st.st_gid;

	dinp->di_atime = cur->inode->st.st_atime;
	dinp->di_mtime = cur->inode->st.st_mtime;
	dinp->di_ctime = cur->inode->st.st_ctime;
	dinp->di_atimensec = cur->inode->st.st_atimensec;
	dinp->di_mtimensec = cur->inode->st.st_mtimensec;
	dinp->di_ctimensec = cur->inode->st.st_ctimensec;
		/* not set: di_db, di_ib, di_blocks, di_spare */

	membuf = NULL;
	if (cur == root) {			/* "."; write dirbuf */
		membuf = dbufp->buf;
		dinp->di_size = dbufp->size;
	} else if (S_ISBLK(cur->type) || S_ISCHR(cur->type)) {
		dinp->di_size = 0;	/* a device */
		dinp->di_rdev = cur->inode->st.st_rdev;
	} else if (S_ISLNK(cur->type)) {	/* symlink */
		slen = strlen(cur->symlink);
		if (slen < MAXSYMLINKLEN_UFS1) {	/* short link */
			memcpy(dinp->di_db, cur->symlink, slen);
		} else
			membuf = cur->symlink;
		dinp->di_size = slen;
	}
	return membuf;
}

static void *
ffs_build_dinode2(struct ufs2_dinode *dinp, dirbuf_t *dbufp, fsnode *cur,
		 fsnode *root, fsinfo_t *fsopts)
{
	size_t slen;
	void *membuf;

	memset(dinp, 0, sizeof(*dinp));
	dinp->di_mode = cur->inode->st.st_mode;
	dinp->di_nlink = cur->inode->nlink;
	dinp->di_size = cur->inode->st.st_size;
	dinp->di_flags = cur->inode->st.st_flags;
	dinp->di_gen = cur->inode->st.st_gen;
	dinp->di_uid = cur->inode->st.st_uid;
	dinp->di_gid = cur->inode->st.st_gid;

	dinp->di_atime = cur->inode->st.st_atime;
	dinp->di_mtime = cur->inode->st.st_mtime;
	dinp->di_ctime = cur->inode->st.st_ctime;
	dinp->di_atimensec = cur->inode->st.st_atimensec;
	dinp->di_mtimensec = cur->inode->st.st_mtimensec;
	dinp->di_ctimensec = cur->inode->st.st_ctimensec;
		/* not set: di_db, di_ib, di_blocks, di_spare */

	membuf = NULL;
	if (cur == root) {			/* "."; write dirbuf */
		membuf = dbufp->buf;
		dinp->di_size = dbufp->size;
	} else if (S_ISBLK(cur->type) || S_ISCHR(cur->type)) {
		dinp->di_size = 0;	/* a device */
		dinp->di_rdev = cur->inode->st.st_rdev;
	} else if (S_ISLNK(cur->type)) {	/* symlink */
		slen = strlen(cur->symlink);
		if (slen < MAXSYMLINKLEN_UFS2) {	/* short link */
			memcpy(dinp->di_db, cur->symlink, slen);
		} else
			membuf = cur->symlink;
		dinp->di_size = slen;
	}
	return membuf;
}

static int
ffs_populate_dir(const char *dir, fsnode *root, fsinfo_t *fsopts)
{
	fsnode		*cur;
	dirbuf_t	dirbuf;
	union dinode	din;
	void		*membuf;
	char		path[MAXPATHLEN + 1];
	ffs_opt_t	*ffs_opts = fsopts->fs_specific;

	assert(dir != NULL);
	assert(root != NULL);
	assert(fsopts != NULL);
	assert(ffs_opts != NULL);

	(void)memset(&dirbuf, 0, sizeof(dirbuf));

		/*
		 * pass 1: allocate inode numbers, build directory `file'
		 */
	for (cur = root; cur != NULL; cur = cur->next) {
		if ((cur->inode->flags & FI_ALLOCATED) == 0) {
			cur->inode->flags |= FI_ALLOCATED;
			if (cur == root && cur->parent != NULL)
				cur->inode->ino = cur->parent->inode->ino;
			else {
				cur->inode->ino = fsopts->curinode;
				fsopts->curinode++;
			}
		}
		ffs_make_dirbuf(&dirbuf, cur->name, cur);
		if (cur == root) {		/* we're at "."; add ".." */
			ffs_make_dirbuf(&dirbuf, "..",
			    cur->parent == NULL ? cur : cur->parent->first);
			root->inode->nlink++;	/* count my parent's link */
		} else if (cur->child != NULL)
			root->inode->nlink++;	/* count my child's link */

		/*
		 * XXX	possibly write file and long symlinks here,
		 *	ensuring that blocks get written before inodes?
		 *	otoh, this isn't a real filesystem, so who
		 *	cares about ordering? :-)
		 */
	}

		/*
		 * pass 2: write out dirbuf, then non-directories at this level
		 */
	for (cur = root; cur != NULL; cur = cur->next) {
		if (cur->inode->flags & FI_WRITTEN)
			continue;		/* skip hard-linked entries */
		cur->inode->flags |= FI_WRITTEN;

		if ((size_t)snprintf(path, sizeof(path), "%s/%s/%s", cur->root,
		    cur->path, cur->name) >= sizeof(path))
			errx(1, "Pathname too long.");

		if (cur->child != NULL)
			continue;		/* child creates own inode */

				/* build on-disk inode */
		if (ffs_opts->version == 1)
			membuf = ffs_build_dinode1(&din.ffs1_din, &dirbuf, cur,
			    root, fsopts);
		else
			membuf = ffs_build_dinode2(&din.ffs2_din, &dirbuf, cur,
			    root, fsopts);

		if (membuf != NULL) {
			ffs_write_file(&din, cur->inode->ino, membuf, fsopts);
		} else if (S_ISREG(cur->type)) {
			ffs_write_file(&din, cur->inode->ino, path, fsopts);
		} else {
			assert (! S_ISDIR(cur->type));
			ffs_write_inode(&din, cur->inode->ino, fsopts);
		}
	}

		/*
		 * pass 3: write out sub-directories
		 */
	for (cur = root; cur != NULL; cur = cur->next) {
		if (cur->child == NULL)
			continue;
		if ((size_t)snprintf(path, sizeof(path), "%s/%s", dir,
		    cur->name) >= sizeof(path))
			errx(1, "Pathname too long.");
		if (! ffs_populate_dir(path, cur->child, fsopts))
			return (0);
	}

		/* cleanup */
	if (dirbuf.buf != NULL)
		free(dirbuf.buf);
	return (1);
}


static void
ffs_write_file(union dinode *din, uint32_t ino, void *buf, fsinfo_t *fsopts)
{
	int	isfile, ffd;
	char	*fbuf, *p;
	off_t	bufleft, chunk, offset;
	ssize_t nread;
	struct inode	in;
	struct mkfsbuf *	bp;
	ffs_opt_t	*ffs_opts = fsopts->fs_specific;
	struct mkfsvnode vp = { fsopts, NULL };

	assert (din != NULL);
	assert (buf != NULL);
	assert (fsopts != NULL);
	assert (ffs_opts != NULL);

	isfile = S_ISREG(DIP(din, mode));
	fbuf = NULL;
	ffd = -1;
	p = NULL;

	in.i_fs = (struct fs *)fsopts->superblock;
	in.i_devvp = &vp;

	in.i_number = ino;
	in.i_size = DIP(din, size);
	if (ffs_opts->version == 1)
		memcpy(&in.i_din.ffs1_din, &din->ffs1_din,
		    sizeof(in.i_din.ffs1_din));
	else
		memcpy(&in.i_din.ffs2_din, &din->ffs2_din,
		    sizeof(in.i_din.ffs2_din));

	if (DIP(din, size) == 0)
		goto write_inode_and_leave;		/* mmm, cheating */

	if (isfile) {
		fbuf = emalloc(ffs_opts->bsize);
		if ((ffd = open((char *)buf, O_RDONLY, 0444)) == -1) {
			warn("Can't open `%s' for reading", (char *)buf);
			goto leave_ffs_write_file;
		}
	} else {
		p = buf;
	}

	chunk = 0;
	for (bufleft = DIP(din, size); bufleft > 0; bufleft -= chunk) {
		chunk = MIN(bufleft, ffs_opts->bsize);
		if (!isfile)
			;
		else if ((nread = read(ffd, fbuf, chunk)) == -1)
			err(1, "Reading `%s', %lld bytes to go", (char *)buf,
			    (long long)bufleft);
		else if (nread != chunk)
			errx(1, "Reading `%s', %lld bytes to go, "
			    "read %zd bytes, expected %ju bytes, does "
			    "metalog size= attribute mismatch source size?",
			    (char *)buf, (long long)bufleft, nread,
			    (uintmax_t)chunk);
		else
			p = fbuf;
		offset = DIP(din, size) - bufleft;
	/*
	 * XXX	if holey support is desired, do the check here
	 *
	 * XXX	might need to write out last bit in fragroundup
	 *	sized chunk. however, ffs_balloc() handles this for us
	 */
		errno = ffs_balloc(&in, offset, chunk, &bp);
 bad_ffs_write_file:
		if (errno != 0)
			err(1,
			    "Writing inode %d (%s), bytes %lld + %lld",
			    ino,
			    isfile ? (char *)buf :
			      inode_type(DIP(din, mode) & S_IFMT),
			    (long long)offset, (long long)chunk);
		memcpy(bp->b_data, p, chunk);
		errno = bwrite(bp);
		if (errno != 0)
			goto bad_ffs_write_file;
		if (!isfile)
			p += chunk;
	}

 write_inode_and_leave:
	ffs_write_inode(&in.i_din, in.i_number, fsopts);

 leave_ffs_write_file:
	if (fbuf)
		free(fbuf);
	if (ffd != -1)
		close(ffd);
}


static void
ffs_make_dirbuf(dirbuf_t *dbuf, const char *name, fsnode *node)
{
	struct direct	de, *dp;
	uint16_t	llen;
	u_char		*newbuf;

	assert (dbuf != NULL);
	assert (name != NULL);
	assert (node != NULL);
					/* create direct entry */
	(void)memset(&de, 0, sizeof(de));
	de.d_ino = node->inode->ino;
	de.d_type = IFTODT(node->type);
	de.d_namlen = (uint8_t)strlen(name);
	strlcpy(de.d_name, name, sizeof de.d_name);
	de.d_reclen = DIRSIZ(NEWDIRFMT, &de);

	dp = (struct direct *)(dbuf->buf + dbuf->cur);
	llen = 0;
	if (dp != NULL)
		llen = DIRSIZ(NEWDIRFMT, dp);

	if (de.d_reclen + dbuf->cur + llen > roundup(dbuf->size, DIRBLKSIZ)) {
		newbuf = erealloc(dbuf->buf, dbuf->size + DIRBLKSIZ);
		dbuf->buf = newbuf;
		dbuf->size += DIRBLKSIZ;
		memset(dbuf->buf + dbuf->size - DIRBLKSIZ, 0, DIRBLKSIZ);
		dbuf->cur = dbuf->size - DIRBLKSIZ;
	} else if (dp) {			/* shrink end of previous */
		dp->d_reclen = llen;
		dbuf->cur += llen;
	}
	dp = (struct direct *)(dbuf->buf + dbuf->cur);
	memcpy(dp, &de, de.d_reclen);
	dp->d_reclen = dbuf->size - dbuf->cur;
}

/*
 * cribbed from sys/ufs/ffs/ffs_alloc.c
 */
static void
ffs_write_inode(union dinode *dp, uint32_t ino, const fsinfo_t *fsopts)
{
	char		*buf;
	struct ufs1_dinode *dp1;
	struct ufs2_dinode *dp2, *dip;
	struct cg	*cgp;
	struct fs	*fs;
	int		cg, cgino, i;
	daddr_t		d;
	char		sbbuf[FFS_MAXBSIZE];
	uint32_t	initediblk;
	ffs_opt_t	*ffs_opts = fsopts->fs_specific;

	assert (dp != NULL);
	assert (ino > 0);
	assert (fsopts != NULL);
	assert (ffs_opts != NULL);

	fs = (struct fs *)fsopts->superblock;
	cg = ino_to_cg(fs, ino);
	cgino = ino % fs->fs_ipg;

	ffs_rdfs(fsbtodb(fs, cgtod(fs, cg)), (int)fs->fs_cgsize, &sbbuf,
	    fsopts);
	cgp = (struct cg *)sbbuf;
	if (!cg_chkmagic(cgp))
		errx(1, "ffs_write_inode: cg %d: bad magic number", cg);

	assert (isclr(cg_inosused(cgp), cgino));

	buf = emalloc(fs->fs_bsize);
	dp1 = (struct ufs1_dinode *)buf;
	dp2 = (struct ufs2_dinode *)buf;

	if (fs->fs_cstotal.cs_nifree == 0)
		errx(1, "ffs_write_inode: fs out of inodes for ino %u",
		    ino);
	if (fs->fs_cs(fs, cg).cs_nifree == 0)
		errx(1,
		    "ffs_write_inode: cg %d out of inodes for ino %u",
		    cg, ino);
	setbit(cg_inosused(cgp), cgino);
	cgp->cg_cs.cs_nifree -= 1;
	fs->fs_cstotal.cs_nifree--;
	fs->fs_cs(fs, cg).cs_nifree--;
	if (S_ISDIR(DIP(dp, mode))) {
		cgp->cg_cs.cs_ndir += 1;
		fs->fs_cstotal.cs_ndir++;
		fs->fs_cs(fs, cg).cs_ndir++;
	}

	/*
	 * Initialize inode blocks on the fly for UFS2.
	 */
	initediblk = cgp->cg_initediblk;
	if (ffs_opts->version == 2 &&
	    (uint32_t)(cgino + INOPB(fs)) > initediblk &&
	    initediblk < cgp->cg_ffs2_niblk) {
		memset(buf, 0, fs->fs_bsize);
		dip = (struct ufs2_dinode *)buf;
		for (i = 0; i < INOPB(fs); i++) {
			dip->di_gen = random() / 2 + 1;
			dip++;
		}
		ffs_wtfs(fsbtodb(fs, ino_to_fsba(fs,
				  cg * fs->fs_ipg + initediblk)),
		    fs->fs_bsize, buf, fsopts);
		initediblk += INOPB(fs);
		cgp->cg_initediblk = initediblk;
	}


	ffs_wtfs(fsbtodb(fs, cgtod(fs, cg)), (int)fs->fs_cgsize, &sbbuf,
	    fsopts);

					/* now write inode */
	d = fsbtodb(fs, ino_to_fsba(fs, ino));
	ffs_rdfs(d, fs->fs_bsize, buf, fsopts);
	if (ffs_opts->version == 1)
		dp1[ino_to_fsbo(fs, ino)] = dp->ffs1_din;
	else
		dp2[ino_to_fsbo(fs, ino)] = dp->ffs2_din;
	ffs_wtfs(d, fs->fs_bsize, buf, fsopts);
	free(buf);
}
@


1.30
log
@While here nuke some more annoying whitespace nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.29 2016/12/17 15:20:10 krw Exp $	*/
d280 1
a280 1
		    fsopts->offset + DOS_LABELSECTOR * DEV_BSIZE);
@


1.29
log
@Nuke unused variable and some extra whitespace.

ok natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.28 2016/11/14 09:03:19 natano Exp $	*/
d458 1
a458 1
	} else 
@


1.28
log
@disklabel -w doesn't set bstart/bend, so makefs shouldn't do that either.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.27 2016/11/13 10:22:21 natano Exp $	*/
d194 1
a194 1
		struct disklabel *dp, *lp;
d199 1
a199 1
	
d375 1
a375 1
		    roundup(fsopts->inodes / ncg, 
d379 1
a379 1
		    roundup(fsopts->inodes / ncg, 
d718 1
a718 1
	int 	isfile, ffd;
d801 1
a801 1
  
d857 1
a857 1
	char 		*buf;
d903 1
a903 1
		fs->fs_cs(fs, cg).cs_ndir++; 
@


1.27
log
@Pick up the FS image size, the sector size and the bsize and fsize
parameters from the disklabel.

discussed with deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.22 2016/11/08 19:38:57 natano Exp $	*/
a261 5
		int i;

		arc4random_buf(lp->d_uid, sizeof(lp->d_uid));
		DL_SETBSTART(lp, 0);
		DL_SETBEND(lp, DL_GETDSIZE(lp));
d270 1
@


1.26
log
@Clean up FFS option handling somewhat; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.25 2016/11/11 09:27:31 natano Exp $	*/
d160 1
a201 4

#if 0
		fsopts->sectorsize = dp->d_secsize;
#endif
d261 1
d268 4
a271 11
		for (i = 0; i < lp->d_npartitions; i++) {
			struct partition *pp = &lp->d_partitions[i];
			if (pp->p_fstype == FS_BSDFFS &&
			    pp->p_offset == fsopts->offset) {
				pp->p_fragblock = DISKLABELV1_FFS_FRAGBLOCK(
				    superblock->fs_fsize, superblock->fs_frag);
				pp->p_cpg = superblock->fs_fpg /
				    superblock->fs_frag;
			}

		}
d303 3
d307 1
a307 1
	ffs_opt_t	*ffs_opts = fsopts->fs_specific;
d313 29
@


1.25
log
@Optimize for space by default.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.24 2016/11/10 08:33:11 natano Exp $	*/
d150 4
a153 4
	ffs_opts->bsize= -1;
	ffs_opts->fsize= -1;
	ffs_opts->density= -1;
	ffs_opts->minfree= -1;
d155 3
a157 4
	ffs_opts->maxcontig= -1;
	ffs_opts->maxbpg= -1;
	ffs_opts->avgfilesize= -1;
	ffs_opts->avgfpdir= -1;
a327 5
	if (ffs_opts->minfree == -1)
		ffs_opts->minfree = MINFREE;
	if (ffs_opts->maxcontig == -1)
		ffs_opts->maxcontig =
		    MAX(1, MIN(MAXBSIZE, FFS_MAXBSIZE) / ffs_opts->bsize);
a330 4
	if (ffs_opts->avgfilesize == -1)
		ffs_opts->avgfilesize = AVFILESIZ;
	if (ffs_opts->avgfpdir == -1)
		ffs_opts->avgfpdir = AFPDIR;
@


1.24
log
@Sync bsize and fsize defaults with newfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.23 2016/11/10 08:26:38 natano Exp $	*/
d154 1
a154 1
	ffs_opts->optimization= -1;
a330 2
	if (ffs_opts->optimization == -1)
		ffs_opts->optimization = DEFAULTOPT;
@


1.23
log
@Remove the unused cpg field from ffs_opt_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.22 2016/11/08 19:38:57 natano Exp $	*/
d101 2
a102 2
#define	DFL_FRAGSIZE		1024		/* fragment size */
#define	DFL_BLKSIZE		8192		/* block size */
@


1.22
log
@Respect -Ooffset for the disklabel location.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.21 2016/11/08 19:22:29 natano Exp $	*/
a103 1
#define	DFL_CYLSPERGROUP	65536		/* cylinders per group */
a151 1
	ffs_opts->cpg= -1;
a327 2
	if (ffs_opts->cpg == -1)
		ffs_opts->cpg = DFL_CYLSPERGROUP;
@


1.21
log
@Add a disklabel option that creates a disklabel with the info provided
by disktab. This is one piece of the puzzle that will allow use to build
install media without vnd.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.19 2016/10/26 15:31:13 natano Exp $	*/
d296 1
a296 1
		    DOS_LABELSECTOR * DEV_BSIZE);
@


1.20
log
@Remove unused fields from ffs_opt_t.
@
text
@d70 1
d139 1
d162 1
d195 14
a208 1
	if (strcmp(ffs_options[rv].name, "optimization") == 0) {
d226 1
d262 41
@


1.19
log
@s/EXIT_FAILURE/1/
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.18 2016/10/26 07:53:47 natano Exp $	*/
a103 6
#define	DFL_FRAGSPERINODE	4		/* fragments per inode */
#define	DFL_ROTDELAY		0		/* rotational delay */
#define	DFL_NRPOS		1		/* rotational positions */
#define	DFL_RPM			3600		/* rpm of disk */
#define	DFL_NSECTORS		64		/* # of sectors */
#define	DFL_NTRACKS		16		/* # of tracks */
a273 2
	else
		ffs_opts->cpgflg = 1;
a274 2
	if (ffs_opts->nsectors == -1)
		ffs_opts->nsectors = DFL_NSECTORS;
@


1.18
log
@Remove FS-specific option descriptions from the source code. We have a
manual for that. While there document the isolevel option and remove
some dysfunctional cd9660 options.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.17 2016/10/23 10:22:21 natano Exp $	*/
d717 2
a718 2
			err(EXIT_FAILURE, "Reading `%s', %lld bytes to go",
			    (char *)buf, (long long)bufleft);
d720 1
a720 1
			errx(EXIT_FAILURE, "Reading `%s', %lld bytes to go, "
@


1.17
log
@Remove short option names for -o.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.16 2016/10/22 19:43:50 natano Exp $	*/
d140 12
a151 21
	    { "avgfilesize", &ffs_opts->avgfilesize, OPT_INT32,
	      1, INT_MAX, "expected average file size" },
	    { "avgfpdir", &ffs_opts->avgfpdir, OPT_INT32,
	      1, INT_MAX, "expected # of files per directory" },
	    { "bsize", &ffs_opts->bsize, OPT_INT32, 1, INT_MAX, "block size" },
	    { "density", &ffs_opts->density, OPT_INT32,
	      1, INT_MAX, "bytes per inode" },
	    { "extent", &ffs_opts->maxbsize, OPT_INT32,
	      1, INT_MAX, "maximum # extent size" },
	    { "fsize", &ffs_opts->fsize, OPT_INT32,
	      1, INT_MAX, "fragment size" },
	    { "label", ffs_opts->label, OPT_STRARRAY,
	      1, sizeof(ffs_opts->label), "UFS label" },
	    { "maxbpcg", &ffs_opts->maxblkspercg, OPT_INT32,
	      1, INT_MAX, "max # of blocks per group" },
	    { "maxbpg", &ffs_opts->maxbpg, OPT_INT32,
	      1, INT_MAX, "max blocks per file in a cg" },
	    { "minfree", &ffs_opts->minfree, OPT_INT32, 0, 99, "minfree" },
	    { "optimization", NULL, OPT_STRBUF,
	      0, 0, "Optimization (time|space)" },
	    { "version", &ffs_opts->version, OPT_INT32, 1, 2, "UFS version" },
@


1.16
log
@Get rid of remaining FFS byteswap function stubs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.15 2016/10/22 19:17:47 natano Exp $	*/
d140 1
a140 11
	    { 'b', "bsize", &ffs_opts->bsize, OPT_INT32,
	      1, INT_MAX, "block size" },
	    { 'f', "fsize", &ffs_opts->fsize, OPT_INT32,
	      1, INT_MAX, "fragment size" },
	    { 'd', "density", &ffs_opts->density, OPT_INT32,
	      1, INT_MAX, "bytes per inode" },
	    { 'm', "minfree", &ffs_opts->minfree, OPT_INT32,
	      0, 99, "minfree" },
	    { 'M', "maxbpg", &ffs_opts->maxbpg, OPT_INT32,
	      1, INT_MAX, "max blocks per file in a cg" },
	    { 'a', "avgfilesize", &ffs_opts->avgfilesize, OPT_INT32,
d142 1
a142 1
	    { 'n', "avgfpdir", &ffs_opts->avgfpdir, OPT_INT32,
d144 4
a147 1
	    { 'x', "extent", &ffs_opts->maxbsize, OPT_INT32,
d149 5
a153 1
	    { 'g', "maxbpcg", &ffs_opts->maxblkspercg, OPT_INT32,
d155 4
a158 3
	    { 'v', "version", &ffs_opts->version, OPT_INT32,
	      1, 2, "UFS version" },
	    { 'o', "optimization", NULL, OPT_STRBUF,
d160 1
a160 2
	    { 'l', "label", ffs_opts->label, OPT_STRARRAY,
	      1, sizeof(ffs_opts->label), "UFS label" },
d207 1
a207 2
	switch (ffs_options[rv].letter) {
	case 'o':
a215 3
		break;
	default:
		break;
@


1.15
log
@Clean up timestamp handling code to be less confusing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.14 2016/10/22 18:17:14 natano Exp $	*/
a84 1
#include "ffs/ufs_bswap.h"
d527 1
a527 2
		dinp->di_rdev =
		    ufs_rw32(cur->inode->st.st_rdev, 0);
d569 1
a569 2
		dinp->di_rdev =
		    ufs_rw64(cur->inode->st.st_rdev, 0);
d782 1
a782 1
	uint16_t	llen, reclen;
d790 1
a790 1
	de.d_ino = ufs_rw32(node->inode->ino, 0);
d794 1
a794 2
	reclen = DIRSIZ(NEWDIRFMT, &de);
	de.d_reclen = ufs_rw16(reclen, 0);
d801 1
a801 1
	if (reclen + dbuf->cur + llen > roundup(dbuf->size, DIRBLKSIZ)) {
d808 1
a808 1
		dp->d_reclen = ufs_rw16(llen,0);
d812 2
a813 2
	memcpy(dp, &de, reclen);
	dp->d_reclen = ufs_rw16(dbuf->size - dbuf->cur, 0);
d874 1
a874 1
	initediblk = ufs_rw32(cgp->cg_initediblk, 0);
d877 1
a877 1
	    initediblk < ufs_rw32(cgp->cg_ffs2_niblk, 0)) {
d888 1
a888 1
		cgp->cg_initediblk = ufs_rw32(initediblk, 0);
@


1.14
log
@Remove huge amounts of debug code, that make the code nearly unreadable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.13 2016/10/22 17:15:28 natano Exp $	*/
d421 3
a423 3
	if (stampst.st_ino == 1) {
		tstamp = stampst.st_ctime;
		srandom_deterministic(tstamp);
a503 1
	struct stat *st = stampst.st_ino == 1 ? &stampst : &cur->inode->st;
d514 6
a519 6
	dinp->di_atime = st->st_atime;
	dinp->di_mtime = st->st_mtime;
	dinp->di_ctime = st->st_ctime;
	dinp->di_atimensec = st->st_atimensec;
	dinp->di_mtimensec = st->st_mtimensec;
	dinp->di_ctimensec = st->st_ctimensec;
a546 1
	struct stat *st = stampst.st_ino == 1 ? &stampst : &cur->inode->st;
d557 6
a562 6
	dinp->di_atime = st->st_atime;
	dinp->di_mtime = st->st_mtime;
	dinp->di_ctime = st->st_ctime;
	dinp->di_atimensec = st->st_atimensec;
	dinp->di_mtimensec = st->st_mtimensec;
	dinp->di_ctimensec = st->st_ctimensec;
@


1.13
log
@s/panic/errx/  This is userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.12 2016/10/22 16:51:52 natano Exp $	*/
a120 2
static	void	ffs_dump_fsinfo(fsinfo_t *);
static	void	ffs_dump_dirbuf(dirbuf_t *, const char *);
a203 3
	if (debug & DEBUG_FS_PARSE_OPTS)
		printf("ffs_parse_opts: got `%s'\n", option);

a232 1
	struct timeval	start;
a238 4
	if (debug & DEBUG_FS_MAKEFS)
		printf("ffs_makefs: image %s directory %s root %p\n",
		    image, dir, root);

a239 1
	TIMER_START(start);
a240 1
	TIMER_RESULTS(start, "ffs_validate");
a245 1
	TIMER_START(start);
a247 1
	TIMER_RESULTS(start, "ffs_create_image");
a250 3
	if (debug & DEBUG_FS_MAKEFS)
		putchar('\n');

a252 1
	TIMER_START(start);
a254 1
	TIMER_RESULTS(start, "ffs_populate_dir");
d256 1
a256 3
		/* ensure no outstanding buffers remain */
	if (debug & DEBUG_FS_MAKEFS)
		bcleanup();
a280 3
#if notyet
	int32_t	spc, nspf, ncyl, fssize;
#endif
a287 5
	if (debug & DEBUG_FS_VALIDATE) {
		printf("ffs_validate: before defaults set:\n");
		ffs_dump_fsinfo(fsopts);
	}

a320 4
	if (debug & DEBUG_FS_VALIDATE)
		printf("ffs_validate: size of tree: %lld bytes, %lld inodes\n",
		    (long long)fsopts->size, (long long)fsopts->inodes);

a365 6
	if (debug & DEBUG_FS_VALIDATE) {
		printf("ffs_validate: after defaults set:\n");
		ffs_dump_fsinfo(fsopts);
		printf("ffs_validate: dir %s; %lld bytes, %lld inodes\n",
		    dir, (long long)fsopts->size, (long long)fsopts->inodes);
	}
a373 30
static void
ffs_dump_fsinfo(fsinfo_t *f)
{

	ffs_opt_t	*fs = f->fs_specific;

	printf("fsopts at %p\n", f);

	printf("\tsize %lld, inodes %lld, curinode %u\n",
	    (long long)f->size, (long long)f->inodes, f->curinode);

	printf("\tminsize %lld, maxsize %lld\n",
	    (long long)f->minsize, (long long)f->maxsize);
	printf("\tfree files %lld, freefile %% %d\n",
	    (long long)f->freefiles, f->freefilepc);
	printf("\tfree blocks %lld, freeblock %% %d\n",
	    (long long)f->freeblocks, f->freeblockpc);
	printf("\tsectorsize %d\n", f->sectorsize);

	printf("\tbsize %d, fsize %d, cpg %d, density %d\n",
	    fs->bsize, fs->fsize, fs->cpg, fs->density);
	printf("\tnsectors %d, rpm %d, minfree %d\n",
	    fs->nsectors, fs->rpm, fs->minfree);
	printf("\tmaxcontig %d, maxbpg %d\n",
	    fs->maxcontig, fs->maxbpg);
	printf("\toptimization %s\n",
	    fs->optimization == FS_OPTSPACE ? "space" : "time");
}


a404 4
	if ((debug & DEBUG_FS_CREATE_IMAGE))
		printf(
		    "zero-ing image `%s', %lld sectors, using %d byte chunks\n",
		    image, (long long)bufrem, bufsize);
a420 3
	if (debug & DEBUG_FS_CREATE_IMAGE)
		printf("calling mkfs(\"%s\", ...)\n", image);

d424 1
a424 1
	} else {
a425 2
		srandom(tstamp);
	}
a428 12
	if (debug & DEBUG_FS_CREATE_IMAGE) {
		time_t t;

		t = (time_t)((struct fs *)fsopts->superblock)->fs_time;
		printf("mkfs returned %p; fs_time %s",
		    fsopts->superblock, ctime(&t));
		printf("fs totals: nbfree %lld, nffree %lld, nifree %lld, ndir %lld\n",
		    (long long)fs->fs_cstotal.cs_nbfree,
		    (long long)fs->fs_cstotal.cs_nffree,
		    (long long)fs->fs_cstotal.cs_nifree,
		    (long long)fs->fs_cstotal.cs_ndir);
	}
a453 4
	if (debug & DEBUG_FS_SIZE_DIR)
		printf("ffs_size_dir: entry: bytes %lld inodes %lld\n",
		    (long long)fsopts->size, (long long)fsopts->inodes);

a456 3
	if (debug & DEBUG_FS_SIZE_DIR_ADD_DIRENT)			\
		printf("ADDDIRENT: was: %s (%d) this %d cur %d\n",	\
		    e, tmpdir.d_namlen, this, curdirsize);		\
a459 3
	if (debug & DEBUG_FS_SIZE_DIR_ADD_DIRENT)			\
		printf("ADDDIRENT: now: %s (%d) this %d cur %d\n",	\
		    e, tmpdir.d_namlen, this, curdirsize);		\
a478 4
			if (debug & DEBUG_FS_SIZE_DIR_NODE)
				printf("ffs_size_dir: `%s' size %lld\n",
				    node->name,
				    (long long)node->inode->st.st_size);
a495 4

	if (debug & DEBUG_FS_SIZE_DIR)
		printf("ffs_size_dir: exit: size %lld inodes %lld\n",
		    (long long)fsopts->size, (long long)fsopts->inodes);
a602 3
	if (debug & DEBUG_FS_POPULATE)
		printf("ffs_populate_dir: PASS 1  dir %s node %p\n", dir, root);

a630 2
	if (debug & DEBUG_FS_POPULATE_DIRBUF)
		ffs_dump_dirbuf(&dirbuf, dir);
a634 2
	if (debug & DEBUG_FS_POPULATE)
		printf("ffs_populate_dir: PASS 2  dir %s\n", dir);
a654 8
		if (debug & DEBUG_FS_POPULATE_NODE) {
			printf("ffs_populate_dir: writing ino %d, %s",
			    cur->inode->ino, inode_type(cur->type));
			if (cur->inode->nlink > 1)
				printf(", nlink %d", cur->inode->nlink);
			putchar('\n');
		}

a667 2
	if (debug & DEBUG_FS_POPULATE)
		printf("ffs_populate_dir: PASS 3  dir %s\n", dir);
a677 3
	if (debug & DEBUG_FS_POPULATE)
		printf("ffs_populate_dir: DONE dir %s\n", dir);

a709 11
	if (debug & DEBUG_FS_WRITE_FILE) {
		printf(
		    "ffs_write_file: ino %u, din %p, isfile %d, %s, size %lld",
		    ino, din, isfile, inode_type(DIP(din, mode) & S_IFMT),
		    (long long)DIP(din, size));
		if (isfile)
			printf(", file '%s'\n", (char *)buf);
		else
			printf(", buffer %p\n", buf);
	}

a748 5
		if (debug & DEBUG_FS_WRITE_FILE_BLOCK)
			printf(
		"ffs_write_file: write %p offset %lld size %lld left %lld\n",
			    p, (long long)offset,
			    (long long)chunk, (long long)bufleft);
a783 25
ffs_dump_dirbuf(dirbuf_t *dbuf, const char *dir)
{
	doff_t		i;
	struct direct	*de;
	uint16_t	reclen;

	assert (dbuf != NULL);
	assert (dir != NULL);
	printf("ffs_dump_dirbuf: dir %s size %d cur %d\n",
	    dir, dbuf->size, dbuf->cur);

	for (i = 0; i < dbuf->size; ) {
		de = (struct direct *)(dbuf->buf + i);
		reclen = ufs_rw16(de->d_reclen, 0);
		printf(
	    " inode %4d %7s offset %4d reclen %3d namlen %3d name %s\n",
		    ufs_rw32(de->d_ino, 0),
		    inode_type(DTTOIF(de->d_type)), i, reclen,
		    de->d_namlen, de->d_name);
		i += reclen;
		assert(reclen > 0);
	}
}

static void
a806 8
	if (debug & DEBUG_FS_MAKE_DIRBUF)
		printf(
		    "ffs_make_dirbuf: dbuf siz %d cur %d lastlen %d\n"
		    "  ino %d type %d reclen %d namlen %d name %.30s\n",
		    dbuf->size, dbuf->cur, llen,
		    ufs_rw32(de.d_ino, 0), de.d_type, reclen,
		    de.d_namlen, de.d_name);

a807 3
		if (debug & DEBUG_FS_MAKE_DIRBUF)
			printf("ffs_make_dirbuf: growing buf to %d\n",
			    dbuf->size + DIRBLKSIZ);
a846 3
	if (debug & DEBUG_FS_WRITE_INODE)
		printf("ffs_write_inode: din %p ino %u cg %d cgino %d\n",
		    dp, ino, cg, cgino);
@


1.12
log
@Include our own <ufs/ufs/dinode.h>, <ufs/ufs/dir.h> and <ufs/ffs/fs.h>
header files instead of relying on copies of NetBSD's headers. This
required some changes in the .c files, due to renamed fields, functions
and preprocessor macros. Also pull in our own ffs_tables.c. As a bonus
this diff gets rid of layout compatibility issues in the superblock
(position of the fs_flags field).
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.11 2016/10/22 10:13:08 natano Exp $	*/
a1092 11
}

void
panic(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vwarnx(fmt, ap);
	va_end(ap);
	exit(1);
@


1.11
log
@Use deterministic pseudo-random numbers when the -T flag is used; for
repeatable builds.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.10 2016/10/18 17:23:21 natano Exp $	*/
d81 3
a83 2
#include "makefs.h"
#include "ffs.h"
a84 3
#include "ffs/dinode.h"
#include "ffs/dir.h"
#include "ffs/fs.h"
d86 2
d89 2
a90 1
#include "ffs/ufs_inode.h"
a91 1
#include "ffs/ffs_extern.h"
d263 1
a263 1
	fsopts->curinode = UFS_ROOTINO;
d282 4
a285 4
	superblock->fs_old_cstotal.cs_ndir   = superblock->fs_cstotal.cs_ndir;
	superblock->fs_old_cstotal.cs_nbfree = superblock->fs_cstotal.cs_nbfree;
	superblock->fs_old_cstotal.cs_nifree = superblock->fs_cstotal.cs_nifree;
	superblock->fs_old_cstotal.cs_nffree = superblock->fs_cstotal.cs_nffree;
d348 1
a348 1
	fsopts->inodes += UFS_ROOTINO;		/* include first two inodes */
d373 1
a373 1
		fsopts->size += ncg * DINODE1_SIZE *
d375 1
a375 1
			ffs_opts->bsize / DINODE1_SIZE);
d377 1
a377 1
		fsopts->size += ncg * DINODE2_SIZE *
d379 1
a379 1
			ffs_opts->bsize / DINODE2_SIZE);
d520 1
a520 1
	if ((off_t)(fs->fs_cstotal.cs_nifree + UFS_ROOTINO) < fsopts->inodes) {
d524 1
a524 1
		    (long long)(fs->fs_cstotal.cs_nifree + UFS_ROOTINO),
d550 1
a550 1
	this = UFS_DIRSIZ(&tmpdir);				\
d554 2
a555 2
	if (this + curdirsize > roundup(curdirsize, UFS_DIRBLKSIZ))	\
		curdirsize = roundup(curdirsize, UFS_DIRBLKSIZ);	\
d591 2
a592 2
						UFS1_MAXSYMLINKLEN :
						UFS2_MAXSYMLINKLEN))
d641 1
a641 1
		if (slen < UFS1_MAXSYMLINKLEN) {	/* short link */
d685 1
a685 1
		if (slen < UFS2_MAXSYMLINKLEN) {	/* short link */
d944 1
a944 1
		    ufs_rw32(de->d_fileno, 0),
d964 1
a964 1
	de.d_fileno = ufs_rw32(node->inode->ino, 0);
d968 1
a968 1
	reclen = UFS_DIRSIZ(&de);
d974 1
a974 1
		llen = UFS_DIRSIZ(dp);
d981 1
a981 1
		    ufs_rw32(de.d_fileno, 0), de.d_type, reclen,
d984 1
a984 1
	if (reclen + dbuf->cur + llen > roundup(dbuf->size, UFS_DIRBLKSIZ)) {
d987 2
a988 2
			    dbuf->size + UFS_DIRBLKSIZ);
		newbuf = erealloc(dbuf->buf, dbuf->size + UFS_DIRBLKSIZ);
d990 3
a992 3
		dbuf->size += UFS_DIRBLKSIZ;
		memset(dbuf->buf + dbuf->size - UFS_DIRBLKSIZ, 0, UFS_DIRBLKSIZ);
		dbuf->cur = dbuf->size - UFS_DIRBLKSIZ;
d1031 1
a1031 1
	ffs_rdfs(FFS_FSBTODB(fs, cgtod(fs, cg)), (int)fs->fs_cgsize, &sbbuf,
d1034 1
a1034 1
	if (!cg_chkmagic(cgp, 0))
d1037 1
a1037 1
	assert (isclr(cg_inosused(cgp, 0), cgino));
d1050 1
a1050 1
	setbit(cg_inosused(cgp, 0), cgino);
d1065 2
a1066 2
	    (uint32_t)(cgino + FFS_INOPB(fs)) > initediblk &&
	    initediblk < ufs_rw32(cgp->cg_niblk, 0)) {
d1069 1
a1069 1
		for (i = 0; i < FFS_INOPB(fs); i++) {
d1073 1
a1073 1
		ffs_wtfs(FFS_FSBTODB(fs, ino_to_fsba(fs,
d1076 1
a1076 1
		initediblk += FFS_INOPB(fs);
d1081 1
a1081 1
	ffs_wtfs(FFS_FSBTODB(fs, cgtod(fs, cg)), (int)fs->fs_cgsize, &sbbuf,
d1085 1
a1085 1
	d = FFS_FSBTODB(fs, ino_to_fsba(fs, ino));
@


1.10
log
@Merge ufs/{ufs,ffs}/ into ffs/.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.9 2016/10/17 07:54:17 natano Exp $	*/
d497 1
a497 1
	if (stampst.st_ino == 1)
d499 2
a500 1
	else
d502 2
a503 2

	srandom(tstamp);
@


1.9
log
@Remove "feature" defines. This code won't try to be portable when we are
done hacking it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.8 2016/10/17 01:16:22 tedu Exp $	*/
d84 4
a87 4
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>
#include <ufs/ufs/ufs_bswap.h>
@


1.8
log
@mechanical rename of vnode to mkfsvnode and buf to mkfsbuf to avoid
collisions with the kernel structures of the same name.
caught one bug where the wrong header was being included.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.7 2016/10/16 22:26:34 tedu Exp $	*/
a83 4
#if HAVE_STRUCT_STATVFS_F_IOSIZE && HAVE_FSTATVFS
#include <sys/statvfs.h>
#endif

a445 3
#if HAVE_STRUCT_STATVFS_F_IOSIZE && HAVE_FSTATVFS
	struct statvfs	sfs;
#endif
d465 1
a465 10
#if HAVE_STRUCT_STATVFS_F_IOSIZE && HAVE_FSTATVFS
	if (fstatvfs(fsopts->fd, &sfs) == -1) {
#endif
		bufsize = 8192;
#if HAVE_STRUCT_STATVFS_F_IOSIZE && HAVE_FSTATVFS
		warn("can't fstatvfs `%s', using default %d byte chunk",
		    image, bufsize);
	} else
		bufsize = sfs.f_iosize;
#endif
a616 1
#if HAVE_STRUCT_STAT_ST_FLAGS
a617 2
#endif
#if HAVE_STRUCT_STAT_ST_GEN
a618 1
#endif
a624 1
#if HAVE_STRUCT_STAT_ST_MTIMENSEC
a627 1
#endif
a660 1
#if HAVE_STRUCT_STAT_ST_FLAGS
a661 2
#endif
#if HAVE_STRUCT_STAT_ST_GEN
a662 1
#endif
a668 1
#if HAVE_STRUCT_STAT_ST_MTIMENSEC
a671 1
#endif
@


1.7
log
@remove swapping add macros
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.6 2016/10/16 21:59:28 tedu Exp $	*/
d848 1
a848 1
	struct buf *	bp;
d850 1
a850 1
	struct vnode vp = { fsopts, NULL };
@


1.6
log
@remove some byte swapping code from the top end
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.5 2016/10/16 21:44:43 tedu Exp $	*/
d1078 1
a1078 1
	ufs_add32(cgp->cg_cs.cs_nifree, -1, 0);
d1082 1
a1082 1
		ufs_add32(cgp->cg_cs.cs_ndir, 1, 0);
@


1.5
log
@/* XXX bounds checking! */
very crudely fix a few strcpy and sprintf warnings.
leave the quality warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.4 2016/10/16 20:30:40 natano Exp $	*/
d126 2
a127 2
static	void	ffs_dump_dirbuf(dirbuf_t *, const char *, int);
static	void	ffs_make_dirbuf(dirbuf_t *, const char *, fsnode *, int);
d434 1
a434 1
	printf("\tneedswap %d, sectorsize %d\n", f->needswap, f->sectorsize);
d565 1
a565 1
	this = UFS_DIRSIZ(0, &tmpdir, 0);				\
d659 1
a659 1
		    ufs_rw32(cur->inode->st.st_rdev, fsopts->needswap);
d709 1
a709 1
		    ufs_rw64(cur->inode->st.st_rdev, fsopts->needswap);
d754 1
a754 1
		ffs_make_dirbuf(&dirbuf, cur->name, cur, fsopts->needswap);
d757 1
a757 2
			    cur->parent == NULL ? cur : cur->parent->first,
			    fsopts->needswap);
d770 1
a770 1
		ffs_dump_dirbuf(&dirbuf, dir, fsopts->needswap);
d955 1
a955 1
ffs_dump_dirbuf(dirbuf_t *dbuf, const char *dir, int needswap)
d968 1
a968 1
		reclen = ufs_rw16(de->d_reclen, needswap);
d971 1
a971 1
		    ufs_rw32(de->d_fileno, needswap),
d980 1
a980 1
ffs_make_dirbuf(dirbuf_t *dbuf, const char *name, fsnode *node, int needswap)
d991 1
a991 1
	de.d_fileno = ufs_rw32(node->inode->ino, needswap);
d995 2
a996 2
	reclen = UFS_DIRSIZ(0, &de, needswap);
	de.d_reclen = ufs_rw16(reclen, needswap);
d1001 1
a1001 1
		llen = UFS_DIRSIZ(0, dp, needswap);
d1008 1
a1008 1
		    ufs_rw32(de.d_fileno, needswap), de.d_type, reclen,
d1021 1
a1021 1
		dp->d_reclen = ufs_rw16(llen,needswap);
d1026 1
a1026 1
	dp->d_reclen = ufs_rw16(dbuf->size - dbuf->cur, needswap);
d1061 1
a1061 1
	if (!cg_chkmagic(cgp, fsopts->needswap))
d1064 1
a1064 1
	assert (isclr(cg_inosused(cgp, fsopts->needswap), cgino));
d1077 2
a1078 2
	setbit(cg_inosused(cgp, fsopts->needswap), cgino);
	ufs_add32(cgp->cg_cs.cs_nifree, -1, fsopts->needswap);
d1082 1
a1082 1
		ufs_add32(cgp->cg_cs.cs_ndir, 1, fsopts->needswap);
d1090 1
a1090 1
	initediblk = ufs_rw32(cgp->cg_initediblk, fsopts->needswap);
d1093 1
a1093 1
	    initediblk < ufs_rw32(cgp->cg_niblk, fsopts->needswap)) {
d1104 1
a1104 1
		cgp->cg_initediblk = ufs_rw32(initediblk, fsopts->needswap);
d1114 4
a1117 13
	if (fsopts->needswap) {
		if (ffs_opts->version == 1)
			ffs_dinode1_swap(&dp->ffs1_din,
			    &dp1[ino_to_fsbo(fs, ino)]);
		else
			ffs_dinode2_swap(&dp->ffs2_din,
			    &dp2[ino_to_fsbo(fs, ino)]);
	} else {
		if (ffs_opts->version == 1)
			dp1[ino_to_fsbo(fs, ino)] = dp->ffs1_din;
		else
			dp2[ino_to_fsbo(fs, ino)] = dp->ffs2_din;
	}
@


1.4
log
@Remove the -Z (spare ffs image) option.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs.c,v 1.3 2016/10/16 20:26:56 natano Exp $	*/
d995 1
a995 1
	strcpy(de.d_name, name);
@


1.3
log
@Add OpenBSD RCS tags; reminded by tb
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a483 10
	if (fsopts->sparse) {
		if (ftruncate(fsopts->fd, bufrem) == -1) {
			printf ("ERROR in truncate. Sparse option disabled\n");
			fsopts->sparse = 0;
		} else {
			bufrem = 0; /* File truncated at bufrem. Remaining is 0 */
			buf = NULL;
		}
	}

d490 1
a490 1
	if ((debug & DEBUG_FS_CREATE_IMAGE) && fsopts->sparse == 0)
@


1.2
log
@Unused includes, as reported by include-what-you-use from ports.
@
text
@d1 1
@


1.1
log
@Import makefs - a tool to create filesystem images from a directory.

This is a rough port of the NetBSD tool with some features removed we
don't need. It compiles, but I don't promise anything more. Importing
now, so we can hack on it in tree.

The supported filesystem types are: cd9660, ffs and msdosfs.

ok deraadt
@
text
@a68 1
#include <sys/mount.h>
a78 1
#include <util.h>
@

