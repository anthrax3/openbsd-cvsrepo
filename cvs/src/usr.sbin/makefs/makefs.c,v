head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19;
locks; strict;
comment	@ * @;


1.19
date	2016.12.17.16.12.15;	author krw;	state Exp;
branches;
next	1.18;
commitid	A9ngZLAcWJ1yliUg;

1.18
date	2016.11.08.09.43.59;	author mestre;	state Exp;
branches;
next	1.17;
commitid	6soGjRz4quux9JSf;

1.17
date	2016.10.26.07.53.47;	author natano;	state Exp;
branches;
next	1.16;
commitid	u5FhgAQMMhudj2OK;

1.16
date	2016.10.25.07.59.45;	author jmc;	state Exp;
branches;
next	1.15;
commitid	U1pWh45nSQyNP1aw;

1.15
date	2016.10.23.10.22.21;	author natano;	state Exp;
branches;
next	1.14;
commitid	rHhaLNWxkoYu4Pqx;

1.14
date	2016.10.22.20.50.21;	author natano;	state Exp;
branches;
next	1.13;
commitid	b3iX6C5k7F7cn7lZ;

1.13
date	2016.10.22.19.17.47;	author natano;	state Exp;
branches;
next	1.12;
commitid	984F18i0puIYFRTL;

1.12
date	2016.10.22.18.17.14;	author natano;	state Exp;
branches;
next	1.11;
commitid	Dnp7IFCOk553ITkR;

1.11
date	2016.10.18.18.34.45;	author natano;	state Exp;
branches;
next	1.10;
commitid	QcshMd7t5eZFX0eI;

1.10
date	2016.10.18.18.15.23;	author natano;	state Exp;
branches;
next	1.9;
commitid	ITWqHtrnbt1LtcZk;

1.9
date	2016.10.18.17.38.20;	author natano;	state Exp;
branches;
next	1.8;
commitid	a4dEAqEste79ldPE;

1.8
date	2016.10.17.14.25.33;	author natano;	state Exp;
branches;
next	1.7;
commitid	NJxlngAGDNcgspmN;

1.7
date	2016.10.17.07.45.32;	author natano;	state Exp;
branches;
next	1.6;
commitid	JkjLS9gIGf7vqZdb;

1.6
date	2016.10.16.21.59.28;	author tedu;	state Exp;
branches;
next	1.5;
commitid	SARjsefQgjiMBFje;

1.5
date	2016.10.16.20.45.07;	author natano;	state Exp;
branches;
next	1.4;
commitid	8FkTvtx7GLzj3OKz;

1.4
date	2016.10.16.20.30.40;	author natano;	state Exp;
branches;
next	1.3;
commitid	MIQhJqZTHW9Z31K2;

1.3
date	2016.10.16.20.26.56;	author natano;	state Exp;
branches;
next	1.2;
commitid	CmcYdpJMky9LxxDQ;

1.2
date	2016.10.16.19.53.11;	author natano;	state Exp;
branches;
next	1.1;
commitid	1ZHAN76P5QzJWokO;

1.1
date	2016.10.16.17.08.53;	author natano;	state Exp;
branches;
next	;
commitid	O38itEriwOj0afR7;


desc
@@


1.19
log
@While here nuke some more annoying whitespace nits.
@
text
@/*	$OpenBSD: makefs.c,v 1.18 2016/11/08 09:43:59 mestre Exp $	*/
/*	$NetBSD: makefs.c,v 1.53 2015/11/27 15:10:32 joerg Exp $	*/

/*
 * Copyright (c) 2001-2003 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Luke Mewburn for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project by
 *      Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <assert.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include "makefs.h"

/*
 * list of supported file systems and dispatch functions
 */
typedef struct {
	const char	*type;
	void		(*prepare_options)(fsinfo_t *);
	int		(*parse_options)(const char *, fsinfo_t *);
	void		(*cleanup_options)(fsinfo_t *);
	void		(*make_fs)(const char *, const char *, fsnode *,
				fsinfo_t *);
} fstype_t;

static fstype_t fstypes[] = {
#define ENTRY(name) { \
	# name, name ## _prep_opts, name ## _parse_opts, \
	name ## _cleanup_opts, name ## _makefs  \
}
	ENTRY(ffs),
	ENTRY(cd9660),
	ENTRY(msdos),
	{ .type = NULL	},
};

int Tflag;
time_t stampts;
struct timespec	start_time;

static	fstype_t *get_fstype(const char *);
static time_t get_tstamp(const char *);
static long long strsuftoll(const char *, const char *, long long, long long);
static __dead void usage(void);

int
main(int argc, char *argv[])
{
	fstype_t	*fstype;
	fsinfo_t	 fsoptions;
	fsnode		*root;
	int		 ch, len;

	if ((fstype = get_fstype(DEFAULT_FSTYPE)) == NULL)
		errx(1, "Unknown default fs type `%s'.", DEFAULT_FSTYPE);

		/* set default fsoptions */
	(void)memset(&fsoptions, 0, sizeof(fsoptions));
	fsoptions.fd = -1;
	fsoptions.sectorsize = -1;

	if (fstype->prepare_options)
		fstype->prepare_options(&fsoptions);

	ch = clock_gettime(CLOCK_REALTIME, &start_time);
	if (ch == -1)
		err(1, "Unable to get system time");


	while ((ch = getopt(argc, argv, "b:f:M:m:O:o:s:S:t:T:")) != -1) {
		switch (ch) {
		case 'b':
			len = strlen(optarg) - 1;
			if (optarg[len] == '%') {
				optarg[len] = '\0';
				fsoptions.freeblockpc =
				    strsuftoll("free block percentage",
					optarg, 0, 99);
			} else {
				fsoptions.freeblocks =
				    strsuftoll("free blocks",
					optarg, 0, LLONG_MAX);
			}
			break;

		case 'f':
			len = strlen(optarg) - 1;
			if (optarg[len] == '%') {
				optarg[len] = '\0';
				fsoptions.freefilepc =
				    strsuftoll("free file percentage",
					optarg, 0, 99);
			} else {
				fsoptions.freefiles =
				    strsuftoll("free files",
					optarg, 0, LLONG_MAX);
			}
			break;

		case 'M':
			fsoptions.minsize =
			    strsuftoll("minimum size", optarg, 1LL, LLONG_MAX);
			break;

		case 'm':
			fsoptions.maxsize =
			    strsuftoll("maximum size", optarg, 1LL, LLONG_MAX);
			break;

		case 'O':
			fsoptions.offset =
			    strsuftoll("offset", optarg, 0LL, LLONG_MAX);
			break;

		case 'o':
		{
			char *p;

			while ((p = strsep(&optarg, ",")) != NULL) {
				if (*p == '\0')
					errx(1, "Empty option");
				if (! fstype->parse_options(p, &fsoptions))
					usage();
			}
			break;
		}

		case 's':
			fsoptions.minsize = fsoptions.maxsize =
			    strsuftoll("size", optarg, 1LL, LLONG_MAX);
			break;

		case 'S':
			fsoptions.sectorsize =
			    (int)strsuftoll("sector size", optarg,
				1LL, INT_MAX);
			break;

		case 't':
			/* Check current one and cleanup if necessary. */
			if (fstype->cleanup_options)
				fstype->cleanup_options(&fsoptions);
			fsoptions.fs_specific = NULL;
			if ((fstype = get_fstype(optarg)) == NULL)
				errx(1, "Unknown fs type `%s'.", optarg);
			fstype->prepare_options(&fsoptions);
			break;

		case 'T':
			Tflag = 1;
			stampts = get_tstamp(optarg);
			break;

		case '?':
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc != 2)
		usage();

	if (pledge("stdio rpath wpath cpath", NULL) == -1)
		err(1, "pledge");

				/* walk the tree */
	root = walk_dir(argv[1], ".", NULL, NULL);

				/* build the file system */
	fstype->make_fs(argv[0], argv[1], root, &fsoptions);

	free_fsnodes(root);

	exit(0);
}

int
set_option(const option_t *options, const char *option, char *buf, size_t len)
{
	char *var, *val;
	int retval;

	assert(option != NULL);

	var = estrdup(option);
	for (val = var; *val; val++)
		if (*val == '=') {
			*val++ = '\0';
			break;
		}
	retval = set_option_var(options, var, val, buf, len);
	free(var);
	return retval;
}

int
set_option_var(const option_t *options, const char *var, const char *val,
    char *buf, size_t len)
{
	char *s;
	size_t i;

#define NUM(type) \
	if (!*val) { \
		*(type *)options[i].value = 1; \
		break; \
	} \
	*(type *)options[i].value = (type)strsuftoll(options[i].name, val, \
	    options[i].minimum, options[i].maximum); break

	for (i = 0; options[i].name != NULL; i++) {
		if (strcmp(options[i].name, var) != 0)
			continue;
		switch (options[i].type) {
		case OPT_BOOL:
			*(int *)options[i].value = 1;
			break;
		case OPT_STRARRAY:
			strlcpy((void *)options[i].value, val, (size_t)
			    options[i].maximum);
			break;
		case OPT_STRPTR:
			s = estrdup(val);
			*(char **)options[i].value = s;
			break;
		case OPT_STRBUF:
			if (buf == NULL)
				abort();
			strlcpy(buf, val, len);
			break;
		case OPT_INT64:
			NUM(uint64_t);
		case OPT_INT32:
			NUM(uint32_t);
		case OPT_INT16:
			NUM(uint16_t);
		case OPT_INT8:
			NUM(uint8_t);
		default:
			warnx("Unknown type %d in option %s", options[i].type,
			    val);
			return 0;
		}
		return i;
	}
	warnx("Unknown option `%s'", var);
	return -1;
}


static fstype_t *
get_fstype(const char *type)
{
	int i;

	for (i = 0; fstypes[i].type != NULL; i++)
		if (strcmp(fstypes[i].type, type) == 0)
			return (&fstypes[i]);
	return (NULL);
}

option_t *
copy_opts(const option_t *o)
{
	size_t i;
	for (i = 0; o[i].name; i++)
		continue;
	i++;
	return memcpy(ecalloc(i, sizeof(*o)), o, i * sizeof(*o));
}

static time_t
get_tstamp(const char *b)
{
	time_t when;
	char *eb;

	errno = 0;
	when = strtoll(b, &eb, 0);
	if (b == eb || *eb || errno) {
		errx(1, "Cannot get timestamp from `%s'",
		    optarg);
	}
	return when;
}

/* XXX */
static long long
strsuftoll(const char *desc, const char *val, long long min, long long max)
{
	long long res;

	if (scan_scaled((char *)val, &res) == -1)
		err(1, "%s", desc);
	if (res < min || res > max)
		errc(1, ERANGE, "%s", desc);
	return res;
}

static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
"usage: %s [-b free-blocks] [-f free-files] [-M minimum-size]\n"
"\t[-m maximum-size] [-O offset] [-o fs-options] [-S sector-size]\n"
"\t[-s image-size] [-T timestamp] [-t fs-type] image-file directory\n",
	    __progname);

	exit(1);
}
@


1.18
log
@pledge for "stdio rpath wpath cpath" promises since it only needs to
read/write/create files

OK natano@@ and tb@@, thank you both for noticing the bad indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: makefs.c,v 1.17 2016/10/26 07:53:47 natano Exp $	*/
d88 1
a88 1
	int	 	 ch, len;
d147 1
a147 1
			fsoptions.offset = 
d150 1
a150 1
			
d293 1
a293 1
	
@


1.17
log
@Remove FS-specific option descriptions from the source code. We have a
manual for that. While there document the isolevel option and remove
some dysfunctional cd9660 options.
@
text
@d1 1
a1 1
/*	$OpenBSD: makefs.c,v 1.16 2016/10/25 07:59:45 jmc Exp $	*/
d200 3
@


1.16
log
@convert usage() to just spit out the normal options list,
instead of trying to list all the fs-specific stuff;

help/ok natano
@
text
@d1 1
a1 1
/*	$OpenBSD: makefs.c,v 1.15 2016/10/23 10:22:21 natano Exp $	*/
d243 1
a243 1
	*(type *)options[i].value = (type)strsuftoll(options[i].desc, val, \
@


1.15
log
@Remove short option names for -o.
@
text
@d1 1
a1 1
/*	$OpenBSD: makefs.c,v 1.13 2016/10/22 19:17:47 natano Exp $	*/
d80 1
a80 1
static	void	usage(fstype_t *, fsinfo_t *) __dead;
d159 1
a159 1
					usage(fstype, &fsoptions);
d192 1
a192 1
			usage(fstype, &fsoptions);
d199 1
a199 1
		usage(fstype, &fsoptions);
d336 1
a336 1
usage(fstype_t *fstype, fsinfo_t *fsoptions)
d341 1
a341 1
"Usage: %s [-b free-blocks] [-f free-files] [-M minimum-size]\n"
a345 9
	if (fstype) {
		size_t i;
		option_t *o = fsoptions->fs_options;

		fprintf(stderr, "\n%s specific options:\n", fstype->type);
		for (i = 0; o[i].name != NULL; i++)
			fprintf(stderr, "\t%-20.20s\t%s\n",
			    o[i].name, o[i].desc);
	}
@


1.14
log
@-#include <stdbool.h>
@
text
@d247 1
a247 4
		if (var[1] == '\0') {
			if (options[i].letter != var[0])
				continue;
		} else if (strcmp(options[i].name, var) != 0)
d352 1
a352 3
			fprintf(stderr, "\t%c%c%20.20s\t%s\n",
			    o[i].letter ? o[i].letter : ' ',
			    o[i].letter ? ',' : ' ',
@


1.13
log
@Clean up timestamp handling code to be less confusing.
@
text
@d1 1
a1 1
/*	$OpenBSD: makefs.c,v 1.12 2016/10/22 18:17:14 natano Exp $	*/
a45 1
#include <stdbool.h>
d254 1
a254 1
			*(bool *)options[i].value = 1;
@


1.12
log
@Remove huge amounts of debug code, that make the code nearly unreadable.
@
text
@d1 1
a1 1
/*	$OpenBSD: makefs.c,v 1.11 2016/10/18 18:34:45 natano Exp $	*/
d74 2
a76 1
struct stat stampst;
d79 1
a79 1
static int get_tstamp(const char *, struct stat *);
d187 2
a188 3
			if (get_tstamp(optarg, &stampst) == -1)
				errx(1, "Cannot get timestamp from `%s'",
				    optarg);
d311 2
a312 2
static int
get_tstamp(const char *b, struct stat *st)
d319 5
a323 6
	if (b == eb || *eb || errno)
		return -1;

	st->st_ino = 1;
	st->st_mtime = st->st_ctime = st->st_atime = when;
	return 0;
@


1.11
log
@Remove setprogname().
@
text
@d1 1
a1 1
/*	$OpenBSD: makefs.c,v 1.10 2016/10/18 18:15:23 natano Exp $	*/
a73 1
u_int		debug;
a84 1
	struct timeval	 start;
a89 1
	debug = 0;
a193 1
			/* NOTREACHED */
a202 1
	TIMER_START(start);
a203 7
	TIMER_RESULTS(start, "walk_dir");

	if (debug & DEBUG_DUMP_FSNODES) {
		printf("\nparent: %s\n", argv[1]);
		dump_fsnodes(root);
		putchar('\n');
	}
a205 1
	TIMER_START(start);
a206 1
	TIMER_RESULTS(start, "make_fs");
a210 1
	/* NOTREACHED */
@


1.10
log
@Only allow epoch timestamps for -T. A shared option for either using the
timestamps from a file or using an epoch timestamp is ridiculous.
@
text
@d1 1
a1 1
/*	$OpenBSD: makefs.c,v 1.9 2016/10/18 17:38:20 natano Exp $	*/
a91 2
	setprogname(argv[0]);

d358 1
a358 1
	const char *prog;
a359 1
	prog = getprogname();
d364 1
a364 1
	    prog);
@


1.9
log
@Remove the -B flag. Most of the byteswapping code was tedu'd already.
@
text
@d1 1
a1 1
/*	$OpenBSD: makefs.c,v 1.8 2016/10/17 14:25:33 natano Exp $	*/
a201 6
	if (debug) {
		printf("debug mask: 0x%08x\n", debug);
		printf("start time: %ld.%ld, %s",
		    (long)start_time.tv_sec, (long)start_time.tv_nsec,
		    ctime(&start_time.tv_sec));
	}
a333 3
	if (stat(b, st) != -1)
		return 0;

d366 1
a366 1
"\t[-s image-size] [-T <timestamp/file>] [-t fs-type] image-file directory\n",
@


1.8
log
@unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: makefs.c,v 1.7 2016/10/17 07:45:32 natano Exp $	*/
d111 1
a111 1
	while ((ch = getopt(argc, argv, "B:b:f:M:m:O:o:s:S:t:T:")) != -1) {
a112 5

		case 'B':
			warnx("Invalid endian `%s'.", optarg);
			usage(fstype, &fsoptions);
			break;
a199 1

d373 3
a375 4
"Usage: %s [-B endian] [-b free-blocks] [-f free-files]\n"
"\t[-M minimum-size] [-m maximum-size] [-O offset]\n"
"\t[-o fs-options] [-S sector-size] [-s image-size]\n"
"\t[-T <timestamp/file>] [-t fs-type] image-file directory\n",
@


1.7
log
@Remove the -d option.

    -d debug-mask
           Enable various levels of debugging, depending upon which bits are
           set in debug-mask.  XXX: document these

Useful, eh? Leaving the actual debug code in there for now, so debug
flags can be set at compile time. That might be removed in the future
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: makefs.c,v 1.6 2016/10/16 21:59:28 tedu Exp $	*/
d90 1
a90 1
	int	 	 ch, i, len;
@


1.6
log
@remove some byte swapping code from the top end
@
text
@d1 1
a1 1
/*	$OpenBSD: makefs.c,v 1.5 2016/10/16 20:45:07 natano Exp $	*/
d111 1
a111 1
	while ((ch = getopt(argc, argv, "B:b:d:f:M:m:O:o:s:S:t:T:")) != -1) {
a131 4
		case 'd':
			debug = strtoll(optarg, NULL, 0);
			break;

d379 4
a382 5
"Usage: %s [-B endian] [-b free-blocks] [-d debug-mask]\n"
"\t[-f free-files] [-M minimum-size] [-m maximum-size]\n"
"\t[-O offset] [-o fs-options] [-S sector-size]\n"
"\t[-s image-size] [-T <timestamp/file>] [-t fs-type]"
" image-file directory\n",
@


1.5
log
@Only allow one directory as argument and remove the -r option.
ok deraadt (on principle)
@
text
@d1 1
a1 1
/*	$OpenBSD: makefs.c,v 1.4 2016/10/16 20:30:40 natano Exp $	*/
d115 2
a116 16
			if (strcmp(optarg, "be") == 0 ||
			    strcmp(optarg, "4321") == 0 ||
			    strcmp(optarg, "big") == 0) {
#if BYTE_ORDER == LITTLE_ENDIAN
				fsoptions.needswap = 1;
#endif
			} else if (strcmp(optarg, "le") == 0 ||
			    strcmp(optarg, "1234") == 0 ||
			    strcmp(optarg, "little") == 0) {
#if BYTE_ORDER == BIG_ENDIAN
				fsoptions.needswap = 1;
#endif
			} else {
				warnx("Invalid endian `%s'.", optarg);
				usage(fstype, &fsoptions);
			}
a117 1

@


1.4
log
@Remove the -Z (spare ffs image) option.
@
text
@d1 1
a1 1
/*	$OpenBSD: makefs.c,v 1.3 2016/10/16 20:26:56 natano Exp $	*/
d111 1
a111 1
	while ((ch = getopt(argc, argv, "B:b:d:f:M:m:O:o:rs:S:t:T:")) != -1) {
a192 4
		case 'r':
			fsoptions.replace = 1;
			break;

d236 1
a236 1
	if (argc < 2)
d241 1
a241 1
	root = walk_dir(argv[1], ".", NULL, NULL, fsoptions.replace);
a243 12
	/* append extra directory */
	for (i = 2; i < argc; i++) {
		struct stat sb;
		if (stat(argv[i], &sb) == -1)
			err(1, "Can't stat `%s'", argv[i]);
		if (!S_ISDIR(sb.st_mode))
			errx(1, "%s: not a directory", argv[i]);
		TIMER_START(start);
		root = walk_dir(argv[i], ".", NULL, root, fsoptions.replace);
		TIMER_RESULTS(start, "walk_dir2");
	}

d398 1
a398 1
"Usage: %s [-r] [-B endian] [-b free-blocks] [-d debug-mask]\n"
d402 1
a402 1
" image-file directory [extra-directory ...]\n",
@


1.3
log
@Add OpenBSD RCS tags; reminded by tb
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d111 1
a111 1
	while ((ch = getopt(argc, argv, "B:b:d:f:M:m:O:o:rs:S:t:T:Z")) != -1) {
a223 4
		case 'Z':
			fsoptions.sparse = 1;
			break;

d414 1
a414 1
"Usage: %s [-rZ] [-B endian] [-b free-blocks] [-d debug-mask]\n"
@


1.2
log
@Unused includes, as reported by include-what-you-use from ports.
@
text
@d1 1
@


1.1
log
@Import makefs - a tool to create filesystem images from a directory.

This is a rough port of the NetBSD tool with some features removed we
don't need. It compiles, but I don't promise anything more. Importing
now, so we can hack on it in tree.

The supported filesystem types are: cd9660, ffs and msdosfs.

ok deraadt
@
text
@a38 1
#include <ctype.h>
a48 1
#include "cd9660.h"
@

