head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.4
	OPENBSD_6_1_BASE:1.6;
locks; strict;
comment	@ * @;


1.6
date	2016.12.17.16.26.46;	author krw;	state Exp;
branches;
next	1.5;
commitid	QI644l1OZS5OAKBL;

1.5
date	2016.10.22.19.43.50;	author natano;	state Exp;
branches;
next	1.4;
commitid	E9ru6iMm8TbER1tL;

1.4
date	2016.10.22.16.51.52;	author natano;	state Exp;
branches;
next	1.3;
commitid	c3bc3iog8Vd2Umt6;

1.3
date	2016.10.18.17.23.21;	author natano;	state Exp;
branches;
next	1.2;
commitid	mFWxcHDQMKvsT7VE;

1.2
date	2016.10.16.20.26.56;	author natano;	state Exp;
branches;
next	1.1;
commitid	CmcYdpJMky9LxxDQ;

1.1
date	2016.10.16.17.08.53;	author natano;	state Exp;
branches;
next	;
commitid	O38itEriwOj0afR7;


desc
@@


1.6
log
@While here nuke some more annoying whitespace nits.
@
text
@/*	$OpenBSD: ufs_bmap.c,v 1.5 2016/10/22 19:43:50 natano Exp $	*/
/*	$NetBSD: ufs_bmap.c,v 1.18 2013/06/19 17:51:27 dholland Exp $	*/
/* From: NetBSD: ufs_bmap.c,v 1.14 2001/11/08 05:00:51 chs Exp */

/*
 * Copyright (c) 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_bmap.c	8.8 (Berkeley) 8/11/95
 */

#include <sys/param.h>
#include <sys/time.h>

#include <assert.h>
#include <errno.h>
#include <strings.h>

#include "makefs.h"

#include <ufs/ufs/dinode.h>
#include <ufs/ffs/fs.h>

#include "ffs/ufs_inode.h"
#include "ffs/ffs_extern.h"

/*
 * Create an array of logical block number/offset pairs which represent the
 * path of indirect blocks required to access a data block.  The first "pair"
 * contains the logical block number of the appropriate single, double or
 * triple indirect block and the offset into the inode indirect block array.
 * Note, the logical block number of the inode single/double/triple indirect
 * block appears twice in the array, once with the offset into the i_ffs_ib and
 * once with the offset into the page itself.
 */
int
ufs_getlbns(struct inode *ip, daddr_t bn, struct indir *ap, int *nump)
{
	daddr_t metalbn, realbn;
	int64_t blockcnt;
	int lbc;
	int i, numlevels, off;
	u_long lognindir;

	lognindir = ffs(NINDIR(ip->i_fs)) - 1;
	if (nump)
		*nump = 0;
	numlevels = 0;
	realbn = bn;
	if ((long)bn < 0)
		bn = -(long)bn;

	assert (bn >= NDADDR);

	/*
	 * Determine the number of levels of indirection.  After this loop
	 * is done, blockcnt indicates the number of data blocks possible
	 * at the given level of indirection, and NIADDR - i is the number
	 * of levels of indirection needed to locate the requested block.
	 */

	bn -= NDADDR;
	for (lbc = 0, i = NIADDR;; i--, bn -= blockcnt) {
		if (i == 0)
			return (EFBIG);

		lbc += lognindir;
		blockcnt = (int64_t)1 << lbc;

		if (bn < blockcnt)
			break;
	}

	/* Calculate the address of the first meta-block. */
	metalbn = -((realbn >= 0 ? realbn : -realbn) - bn + NIADDR - i);

	/*
	 * At each iteration, off is the offset into the bap array which is
	 * an array of disk addresses at the current level of indirection.
	 * The logical block number and the offset in that block are stored
	 * into the argument array.
	 */
	ap->in_lbn = metalbn;
	ap->in_off = off = NIADDR - i;
	ap->in_exists = 0;
	ap++;
	for (++numlevels; i <= NIADDR; i++) {
		/* If searching for a meta-data block, quit when found. */
		if (metalbn == realbn)
			break;

		lbc -= lognindir;
		blockcnt = (int64_t)1 << lbc;
		off = (bn >> lbc) & (NINDIR(ip->i_fs) - 1);

		++numlevels;
		ap->in_lbn = metalbn;
		ap->in_off = off;
		ap->in_exists = 0;
		++ap;

		metalbn -= -1 + (off << lbc);
	}
	if (nump)
		*nump = numlevels;
	return (0);
}
@


1.5
log
@Get rid of remaining FFS byteswap function stubs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.4 2016/10/22 16:51:52 natano Exp $	*/
d84 1
a84 1
	/* 
d106 1
a106 1
	/* 
@


1.4
log
@Include our own <ufs/ufs/dinode.h>, <ufs/ufs/dir.h> and <ufs/ffs/fs.h>
header files instead of relying on copies of NetBSD's headers. This
required some changes in the .c files, due to renamed fields, functions
and preprocessor macros. Also pull in our own ffs_tables.c. As a bonus
this diff gets rid of layout compatibility issues in the superblock
(position of the fs_flags field).
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.3 2016/10/18 17:23:21 natano Exp $	*/
a52 1
#include "ffs/ufs_bswap.h"
@


1.3
log
@Merge ufs/{ufs,ffs}/ into ffs/.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.2 2016/10/16 20:26:56 natano Exp $	*/
d50 3
a52 1
#include "ffs/dinode.h"
a53 2
#include "ffs/fs.h"

d75 1
a75 1
	lognindir = ffs(FFS_NINDIR(ip->i_fs)) - 1;
d83 1
a83 1
	assert (bn >= UFS_NDADDR);
d88 1
a88 1
	 * at the given level of indirection, and UFS_NIADDR - i is the number
d92 2
a93 2
	bn -= UFS_NDADDR;
	for (lbc = 0, i = UFS_NIADDR;; i--, bn -= blockcnt) {
d105 1
a105 1
	metalbn = -((realbn >= 0 ? realbn : -realbn) - bn + UFS_NIADDR - i);
d114 1
a114 1
	ap->in_off = off = UFS_NIADDR - i;
d117 1
a117 1
	for (++numlevels; i <= UFS_NIADDR; i++) {
d124 1
a124 1
		off = (bn >> lbc) & (FFS_NINDIR(ip->i_fs) - 1);
@


1.2
log
@Add OpenBSD RCS tags; reminded by tb
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 3
a52 3
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/ufs_bswap.h>
#include <ufs/ffs/fs.h>
@


1.1
log
@Import makefs - a tool to create filesystem images from a directory.

This is a rough port of the NetBSD tool with some features removed we
don't need. It compiles, but I don't promise anything more. Importing
now, so we can hack on it in tree.

The supported filesystem types are: cd9660, ffs and msdosfs.

ok deraadt
@
text
@d1 1
@

