head	1.117;
access;
symbols
	OPENBSD_6_1:1.116.0.4
	OPENBSD_6_1_BASE:1.116
	OPENBSD_6_0:1.108.0.2
	OPENBSD_6_0_BASE:1.108
	OPENBSD_5_9:1.105.0.2
	OPENBSD_5_9_BASE:1.105
	OPENBSD_5_8:1.96.0.4
	OPENBSD_5_8_BASE:1.96
	OPENBSD_5_7:1.75.0.2
	OPENBSD_5_7_BASE:1.75
	OPENBSD_5_6:1.42.0.2
	OPENBSD_5_6_BASE:1.42;
locks; strict;
comment	@ * @;


1.117
date	2017.05.15.10.40.47;	author jsg;	state Exp;
branches;
next	1.116;
commitid	2LaYyuUSDmY7Si5l;

1.116
date	2017.03.16.10.18.11;	author florian;	state Exp;
branches;
next	1.115;
commitid	pOJdU03lhyFuOUS6;

1.115
date	2017.03.10.21.06.43;	author reyk;	state Exp;
branches;
next	1.114;
commitid	uZ3A794n79tKoVTv;

1.114
date	2017.02.07.12.22.41;	author reyk;	state Exp;
branches;
next	1.113;
commitid	macEB4cUIOcnjrn0;

1.113
date	2017.02.02.22.19.59;	author reyk;	state Exp;
branches;
next	1.112;
commitid	wAyoqiU7jG1NUkqx;

1.112
date	2017.01.31.14.39.47;	author reyk;	state Exp;
branches;
next	1.111;
commitid	IPZeYDCn5vLI9sJB;

1.111
date	2017.01.31.12.21.27;	author reyk;	state Exp;
branches;
next	1.110;
commitid	W6dCvmsAWEvXxw18;

1.110
date	2016.08.26.10.46.39;	author rzalamena;	state Exp;
branches;
next	1.109;
commitid	JNQbvPaxb6nMCsuY;

1.109
date	2016.07.27.11.02.41;	author reyk;	state Exp;
branches;
next	1.108;
commitid	8vF1DH1UIEVFX3e5;

1.108
date	2016.05.27.11.24.13;	author krw;	state Exp;
branches;
next	1.107;
commitid	iNDMT8xv6fBY8IDp;

1.107
date	2016.05.22.19.20.03;	author jung;	state Exp;
branches;
next	1.106;
commitid	JycEi9sqbVJpJ2Tj;

1.106
date	2016.03.08.09.33.15;	author florian;	state Exp;
branches;
next	1.105;
commitid	TVL220R4XsSPamVq;

1.105
date	2016.02.11.19.30.04;	author tim;	state Exp;
branches;
next	1.104;
commitid	HFI5EB7tPmYQqMYe;

1.104
date	2016.02.11.16.14.11;	author tim;	state Exp;
branches;
next	1.103;
commitid	quYOIEbp5hlzh0eW;

1.103
date	2015.12.07.20.30.17;	author mmcc;	state Exp;
branches;
next	1.102;
commitid	4HTjyFggaYLwMHWc;

1.102
date	2015.12.03.11.46.25;	author reyk;	state Exp;
branches;
next	1.101;
commitid	MjVkI8WBXvjkg1UG;

1.101
date	2015.10.13.08.33.06;	author sunil;	state Exp;
branches;
next	1.100;
commitid	9Y5DVzTYC8m8u6tY;

1.100
date	2015.10.13.07.57.13;	author reyk;	state Exp;
branches;
next	1.99;
commitid	eRpR6Xfo42iR98SK;

1.99
date	2015.09.07.14.46.24;	author reyk;	state Exp;
branches;
next	1.98;
commitid	3N8ZbJM1mbV6AuOV;

1.98
date	2015.08.21.07.30.50;	author reyk;	state Exp;
branches;
next	1.97;
commitid	1QqLCAwOjd8tDz2y;

1.97
date	2015.08.20.13.00.23;	author reyk;	state Exp;
branches;
next	1.96;
commitid	WDQybNKi4LiEFw8K;

1.96
date	2015.07.31.00.10.51;	author benno;	state Exp;
branches;
next	1.95;
commitid	fAnDDuLHMOr8xOWK;

1.95
date	2015.07.29.22.03.41;	author reyk;	state Exp;
branches;
next	1.94;
commitid	rol6YjSk5cC38ac4;

1.94
date	2015.07.29.20.03.14;	author florian;	state Exp;
branches;
next	1.93;
commitid	UvkQRTHkUu4OhiEw;

1.93
date	2015.07.23.09.36.32;	author semarie;	state Exp;
branches;
next	1.92;
commitid	5CXr77ACMFnz3GFc;

1.92
date	2015.07.19.05.17.27;	author reyk;	state Exp;
branches;
next	1.91;
commitid	jdqdR7UPKnGDga2T;

1.91
date	2015.07.18.06.00.43;	author reyk;	state Exp;
branches;
next	1.90;
commitid	GYrjpgr4p814WbAx;

1.90
date	2015.07.18.05.41.19;	author florian;	state Exp;
branches;
next	1.89;
commitid	2Fg8acs1mTRftiTA;

1.89
date	2015.07.16.19.05.28;	author reyk;	state Exp;
branches;
next	1.88;
commitid	uD9Qfc9LJPALunq8;

1.88
date	2015.07.15.23.16.38;	author reyk;	state Exp;
branches;
next	1.87;
commitid	RzY5FSK1wD1o0SL4;

1.87
date	2015.07.15.22.23.00;	author reyk;	state Exp;
branches;
next	1.86;
commitid	uaqF6ieLzlsU5D5u;

1.86
date	2015.07.15.17.52.23;	author reyk;	state Exp;
branches;
next	1.85;
commitid	eijcjWsY2t2XJ8iz;

1.85
date	2015.07.15.16.02.38;	author semarie;	state Exp;
branches;
next	1.84;
commitid	8MZqJrDe1jrb3uzq;

1.84
date	2015.06.23.17.25.01;	author semarie;	state Exp;
branches;
next	1.83;
commitid	YL52OeP3rw53ofpS;

1.83
date	2015.06.23.15.23.14;	author reyk;	state Exp;
branches;
next	1.82;
commitid	KmQD0QhuAUl1XRCr;

1.82
date	2015.06.22.11.46.06;	author reyk;	state Exp;
branches;
next	1.81;
commitid	6kf8bowuKT2yOL4a;

1.81
date	2015.06.21.13.08.36;	author reyk;	state Exp;
branches;
next	1.80;
commitid	QEFwr1zJJBzqiuyh;

1.80
date	2015.05.20.09.28.47;	author kettenis;	state Exp;
branches;
next	1.79;
commitid	YKbXEhIZlwjrozF0;

1.79
date	2015.05.03.18.39.58;	author florian;	state Exp;
branches;
next	1.78;
commitid	tKSpRdIDfb89N9Nf;

1.78
date	2015.04.18.09.27.54;	author jsg;	state Exp;
branches;
next	1.77;
commitid	CvkNdFuQE1NcguA2;

1.77
date	2015.04.09.16.48.29;	author florian;	state Exp;
branches;
next	1.76;
commitid	rcMqXongSnebNFy5;

1.76
date	2015.04.08.19.39.29;	author florian;	state Exp;
branches;
next	1.75;
commitid	ZYLpw4TLuW3YAWA4;

1.75
date	2015.02.23.18.43.18;	author reyk;	state Exp;
branches;
next	1.74;
commitid	xe3hvTl4EsdtcfCj;

1.74
date	2015.02.08.00.00.59;	author reyk;	state Exp;
branches;
next	1.73;
commitid	T0lfZLuka5kZO7cg;

1.73
date	2015.02.07.23.59.28;	author reyk;	state Exp;
branches;
next	1.72;
commitid	BdZCMcq9YE6R9CIr;

1.72
date	2015.02.07.01.23.12;	author reyk;	state Exp;
branches;
next	1.71;
commitid	tJajgOHQ1aZRGbKl;

1.71
date	2015.02.06.13.05.20;	author reyk;	state Exp;
branches;
next	1.70;
commitid	WzsLdaJsWwlcIzRK;

1.70
date	2015.02.05.10.47.53;	author reyk;	state Exp;
branches;
next	1.69;
commitid	fARu7KJkAh355XJa;

1.69
date	2015.01.21.22.21.05;	author reyk;	state Exp;
branches;
next	1.68;
commitid	64Zc6bef54Vu2Noy;

1.68
date	2015.01.19.20.01.02;	author florian;	state Exp;
branches;
next	1.67;
commitid	ucQ2vb7S8tn6m4cA;

1.67
date	2015.01.19.20.00.07;	author florian;	state Exp;
branches;
next	1.66;
commitid	uDWn7Rj546an5NG2;

1.66
date	2015.01.19.19.37.50;	author reyk;	state Exp;
branches;
next	1.65;
commitid	95e2Z6BqzOOfEsll;

1.65
date	2015.01.18.14.01.17;	author florian;	state Exp;
branches;
next	1.64;
commitid	7n1dHfzjQzsDnx3e;

1.64
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.63;
commitid	Uu5nFG3wCl0LACBb;

1.63
date	2015.01.13.09.21.15;	author reyk;	state Exp;
branches;
next	1.62;
commitid	vlRoyiZgaC5QvCo7;

1.62
date	2015.01.06.17.48.04;	author reyk;	state Exp;
branches;
next	1.61;
commitid	AZgcXJSyZiubAQer;

1.61
date	2015.01.06.13.48.15;	author reyk;	state Exp;
branches;
next	1.60;
commitid	1pdciXvRU250oszJ;

1.60
date	2015.01.06.13.38.59;	author reyk;	state Exp;
branches;
next	1.59;
commitid	7uF7PKoXV2HRnj4h;

1.59
date	2015.01.04.22.23.58;	author chrisz;	state Exp;
branches;
next	1.58;
commitid	PxQkOIiHP7NqIPYy;

1.58
date	2015.01.01.14.15.02;	author reyk;	state Exp;
branches;
next	1.57;
commitid	bb5s5QBx3K8HXzjN;

1.57
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.56;
commitid	XnjIOhurXdX5o1V9;

1.56
date	2014.12.08.19.31.27;	author florian;	state Exp;
branches;
next	1.55;
commitid	fi3e2kvMtXbWn0wm;

1.55
date	2014.12.04.02.44.42;	author tedu;	state Exp;
branches;
next	1.54;
commitid	A2H8wpKaas7ra1zW;

1.54
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.53;
commitid	2uw1UTO4k6erpWzK;

1.53
date	2014.10.22.09.48.03;	author reyk;	state Exp;
branches;
next	1.52;
commitid	6UIQ1JUjIEqOoSI1;

1.52
date	2014.10.21.13.00.33;	author reyk;	state Exp;
branches;
next	1.51;
commitid	Z1GQGdwoHr7tFH16;

1.51
date	2014.09.29.19.30.47;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	MS0GNEU2JBJZ5mx1;

1.50
date	2014.09.15.08.00.27;	author reyk;	state Exp;
branches;
next	1.49;
commitid	UOU7wW3d3NNcF4WU;

1.49
date	2014.09.10.15.39.57;	author reyk;	state Exp;
branches;
next	1.48;
commitid	BrSDFsqPx9KchyVo;

1.48
date	2014.09.05.15.06.05;	author reyk;	state Exp;
branches;
next	1.47;
commitid	zZuRVa6ojZgzv2Uk;

1.47
date	2014.09.05.10.04.20;	author reyk;	state Exp;
branches;
next	1.46;
commitid	L018oMJIofTIKQBT;

1.46
date	2014.08.29.13.01.46;	author reyk;	state Exp;
branches;
next	1.45;
commitid	s1q2vKQd3ZNYgiRk;

1.45
date	2014.08.21.19.23.10;	author chrisz;	state Exp;
branches;
next	1.44;
commitid	JCs4fDUGf9JXsJFG;

1.44
date	2014.08.08.18.29.42;	author reyk;	state Exp;
branches;
next	1.43;
commitid	J4bMyiFa6dPdfodH;

1.43
date	2014.08.08.15.46.01;	author reyk;	state Exp;
branches;
next	1.42;
commitid	MOcna59bzLxiD32l;

1.42
date	2014.08.06.18.21.14;	author reyk;	state Exp;
branches
	1.42.2.1;
next	1.41;
commitid	jZUEHtimlVJa4lx5;

1.41
date	2014.08.06.15.08.04;	author florian;	state Exp;
branches;
next	1.40;
commitid	JiDxX0IDmc7NLOCZ;

1.40
date	2014.08.06.09.34.21;	author reyk;	state Exp;
branches;
next	1.39;
commitid	X2IL5L6Av5Pu0ino;

1.39
date	2014.08.05.18.01.10;	author reyk;	state Exp;
branches;
next	1.38;
commitid	bNgJHQQ6lNzksAJO;

1.38
date	2014.08.05.16.30.36;	author reyk;	state Exp;
branches;
next	1.37;
commitid	JpK6oqkkh2jiIWCI;

1.37
date	2014.08.05.14.36.10;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	ihzE2dtXwl1ZnYhi;

1.36
date	2014.08.04.11.09.25;	author reyk;	state Exp;
branches;
next	1.35;
commitid	Dj6ALT3dpIHqBQcw;

1.35
date	2014.08.04.06.35.10;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	jTuUMNRcoR31PL9B;

1.34
date	2014.08.03.22.38.12;	author reyk;	state Exp;
branches;
next	1.33;
commitid	NQSzoccH9KIwwSqc;

1.33
date	2014.08.03.21.33.27;	author reyk;	state Exp;
branches;
next	1.32;
commitid	mQEA6EyKk53ViyFd;

1.32
date	2014.08.03.20.39.40;	author reyk;	state Exp;
branches;
next	1.31;
commitid	SI4ST45AyhzT510m;

1.31
date	2014.08.03.12.26.19;	author reyk;	state Exp;
branches;
next	1.30;
commitid	nLaH9MjCgoWopkfz;

1.30
date	2014.08.03.10.26.44;	author reyk;	state Exp;
branches;
next	1.29;
commitid	J4iRjIQasNlCySVe;

1.29
date	2014.08.03.10.22.30;	author reyk;	state Exp;
branches;
next	1.28;
commitid	WoVa57YdbLMbGLzU;

1.28
date	2014.08.02.21.21.47;	author doug;	state Exp;
branches;
next	1.27;
commitid	eYHmkmq5eeXpnLSo;

1.27
date	2014.08.01.22.24.05;	author reyk;	state Exp;
branches;
next	1.26;
commitid	GXr73HMBmpwnofsc;

1.26
date	2014.08.01.21.51.02;	author doug;	state Exp;
branches;
next	1.25;
commitid	EQrn6y0IO5CKfaGo;

1.25
date	2014.07.31.18.07.11;	author reyk;	state Exp;
branches;
next	1.24;
commitid	vNGac2qPq7P5adZU;

1.24
date	2014.07.31.17.55.09;	author reyk;	state Exp;
branches;
next	1.23;
commitid	2oJScuzXVXi93eTv;

1.23
date	2014.07.31.09.34.57;	author reyk;	state Exp;
branches;
next	1.22;
commitid	KZnViLTHk4UhEJQd;

1.22
date	2014.07.31.09.23.53;	author florian;	state Exp;
branches;
next	1.21;
commitid	4jka4N6hQtuBEhDN;

1.21
date	2014.07.30.13.49.48;	author reyk;	state Exp;
branches;
next	1.20;
commitid	xXDeSGReD1XsNQaP;

1.20
date	2014.07.30.10.05.14;	author reyk;	state Exp;
branches;
next	1.19;
commitid	crg28r1097elBMcd;

1.19
date	2014.07.25.23.25.38;	author reyk;	state Exp;
branches;
next	1.18;
commitid	ySxKAMtbgDwL8jGt;

1.18
date	2014.07.25.23.23.39;	author reyk;	state Exp;
branches;
next	1.17;
commitid	ovF3df8kR0MciR0p;

1.17
date	2014.07.25.21.48.05;	author reyk;	state Exp;
branches;
next	1.16;
commitid	9XpegUgEoI731K60;

1.16
date	2014.07.25.21.36.37;	author reyk;	state Exp;
branches;
next	1.15;
commitid	ExWZFwhdWCbeflzy;

1.15
date	2014.07.25.21.29.58;	author reyk;	state Exp;
branches;
next	1.14;
commitid	smhDJiNevxTCWh6A;

1.14
date	2014.07.25.16.23.19;	author reyk;	state Exp;
branches;
next	1.13;
commitid	xxvqODaQzmLv14My;

1.13
date	2014.07.25.13.10.18;	author reyk;	state Exp;
branches;
next	1.12;
commitid	e2fiCfjHRfxIZTmx;

1.12
date	2014.07.25.12.46.23;	author reyk;	state Exp;
branches;
next	1.11;
commitid	nFELL2a0ZqVmRooJ;

1.11
date	2014.07.24.08.32.36;	author reyk;	state Exp;
branches;
next	1.10;
commitid	quJMC73DegnsF51x;

1.10
date	2014.07.23.21.43.12;	author reyk;	state Exp;
branches;
next	1.9;
commitid	VwbmwwMNcn9gFVvS;

1.9
date	2014.07.17.11.35.26;	author stsp;	state Exp;
branches;
next	1.8;
commitid	TTduxpjvPpaxCdUl;

1.8
date	2014.07.16.10.25.28;	author reyk;	state Exp;
branches;
next	1.7;
commitid	ogHdcewg1QccxeTT;

1.7
date	2014.07.14.09.03.08;	author reyk;	state Exp;
branches;
next	1.6;
commitid	VrqdtDY9d8gwXs9T;

1.6
date	2014.07.14.00.19.48;	author reyk;	state Exp;
branches;
next	1.5;
commitid	PY8fkGzrfhDzml1J;

1.5
date	2014.07.13.15.39.01;	author reyk;	state Exp;
branches;
next	1.4;
commitid	1lsVtvYmGmYZFvMJ;

1.4
date	2014.07.13.14.17.37;	author reyk;	state Exp;
branches;
next	1.3;
commitid	4gg9IcDTWDACYa56;

1.3
date	2014.07.13.09.46.19;	author beck;	state Exp;
branches;
next	1.2;
commitid	O4WjnLQQFbT5J3lM;

1.2
date	2014.07.12.23.55.35;	author reyk;	state Exp;
branches;
next	1.1;
commitid	xNwEtJ1XRlomIA59;

1.1
date	2014.07.12.23.34.54;	author reyk;	state Exp;
branches;
next	;
commitid	U5OqzWAgis3Sb3uE;

1.42.2.1
date	2014.11.20.07.48.45;	author jasper;	state Exp;
branches;
next	;
commitid	aoUNgrdXQt2mQs98;


desc
@@


1.117
log
@Avoid a crash servicing requests when a server is configured with
"block return 401".  Problem reported by Jurjen Oskam.
ok florian@@
@
text
@/*	$OpenBSD: server_http.c,v 1.116 2017/03/16 10:18:11 florian Exp $	*/

/*
 * Copyright (c) 2006 - 2017 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/tree.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <fnmatch.h>
#include <stdio.h>
#include <time.h>
#include <resolv.h>
#include <event.h>
#include <ctype.h>
#include <vis.h>

#include "httpd.h"
#include "http.h"
#include "patterns.h"

static int	 server_httpmethod_cmp(const void *, const void *);
static int	 server_httperror_cmp(const void *, const void *);
void		 server_httpdesc_free(struct http_descriptor *);
int		 server_http_authenticate(struct server_config *,
		    struct client *);
char		*server_expand_http(struct client *, const char *,
		    char *, size_t);

static struct http_method	 http_methods[] = HTTP_METHODS;
static struct http_error	 http_errors[] = HTTP_ERRORS;

void
server_http(void)
{
	DPRINTF("%s: sorting lookup tables, pid %d", __func__, getpid());

	/* Sort the HTTP lookup arrays */
	qsort(http_methods, sizeof(http_methods) /
	    sizeof(http_methods[0]) - 1,
	    sizeof(http_methods[0]), server_httpmethod_cmp);
	qsort(http_errors, sizeof(http_errors) /
	    sizeof(http_errors[0]) - 1,
	    sizeof(http_errors[0]), server_httperror_cmp);
}

void
server_http_init(struct server *srv)
{
	/* nothing */
}

int
server_httpdesc_init(struct client *clt)
{
	struct http_descriptor	*desc;

	if ((desc = calloc(1, sizeof(*desc))) == NULL)
		return (-1);
	RB_INIT(&desc->http_headers);
	clt->clt_descreq = desc;

	if ((desc = calloc(1, sizeof(*desc))) == NULL) {
		/* req will be cleaned up later */
		return (-1);
	}
	RB_INIT(&desc->http_headers);
	clt->clt_descresp = desc;

	return (0);
}

void
server_httpdesc_free(struct http_descriptor *desc)
{
	if (desc == NULL)
		return;

	free(desc->http_path);
	desc->http_path = NULL;
	free(desc->http_path_alias);
	desc->http_path_alias = NULL;
	free(desc->http_query);
	desc->http_query = NULL;
	free(desc->http_version);
	desc->http_version = NULL;
	free(desc->http_host);
	desc->http_host = NULL;

	kv_purge(&desc->http_headers);
	desc->http_lastheader = NULL;
	desc->http_method = 0;
	desc->http_chunked = 0;
}

int
server_http_authenticate(struct server_config *srv_conf, struct client *clt)
{
	char			 decoded[1024];
	FILE			*fp = NULL;
	struct http_descriptor	*desc = clt->clt_descreq;
	const struct auth	*auth = srv_conf->auth;
	struct kv		*ba, key;
	size_t			 linesize = 0;
	ssize_t			 linelen;
	int			 ret = -1;
	char			*line = NULL, *user = NULL, *pass = NULL;
	char			*clt_user = NULL, *clt_pass = NULL;

	memset(decoded, 0, sizeof(decoded));
	key.kv_key = "Authorization";

	if ((ba = kv_find(&desc->http_headers, &key)) == NULL ||
	    ba->kv_value == NULL)
		goto done;

	if (strncmp(ba->kv_value, "Basic ", strlen("Basic ")) != 0)
		goto done;

	if (b64_pton(strchr(ba->kv_value, ' ') + 1, (uint8_t *)decoded,
	    sizeof(decoded)) <= 0)
		goto done;

	if ((clt_pass = strchr(decoded, ':')) == NULL)
		goto done;

	clt_user = decoded;
	*clt_pass++ = '\0';
	if ((clt->clt_remote_user = strdup(clt_user)) == NULL)
		goto done;

	if (clt_pass == NULL)
		goto done;

	if ((fp = fopen(auth->auth_htpasswd, "r")) == NULL)
		goto done;

	while ((linelen = getline(&line, &linesize, fp)) != -1) {
		if (line[linelen - 1] == '\n')
			line[linelen - 1] = '\0';
		user = line;
		pass = strchr(line, ':');

		if (pass == NULL) {
			explicit_bzero(line, linelen);
			continue;
		}

		*pass++ = '\0';

		if (strcmp(clt_user, user) != 0) {
			explicit_bzero(line, linelen);
			continue;
		}

		if (crypt_checkpass(clt_pass, pass) == 0) {
			explicit_bzero(line, linelen);
			ret = 0;
			break;
		}
	}
done:
	free(line);
	if (fp != NULL)
		fclose(fp);

	if (ba != NULL && ba->kv_value != NULL) {
		explicit_bzero(ba->kv_value, strlen(ba->kv_value));
		explicit_bzero(decoded, sizeof(decoded));
	}

	return (ret);
}

void
server_read_http(struct bufferevent *bev, void *arg)
{
	struct client		*clt = arg;
	struct server_config	*srv_conf = clt->clt_srv_conf;
	struct http_descriptor	*desc = clt->clt_descreq;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);
	char			*line = NULL, *key, *value;
	const char		*errstr;
	size_t			 size, linelen;
	struct kv		*hdr = NULL;

	getmonotime(&clt->clt_tv_last);

	size = EVBUFFER_LENGTH(src);
	DPRINTF("%s: session %d: size %lu, to read %lld",
	    __func__, clt->clt_id, size, clt->clt_toread);
	if (!size) {
		clt->clt_toread = TOREAD_HTTP_HEADER;
		goto done;
	}

	while (!clt->clt_headersdone) {
		if (!clt->clt_line) {
			/* Peek into the buffer to see if it looks like HTTP */
			key = EVBUFFER_DATA(src);
			if (!isalpha(*key)) {
				server_abort_http(clt, 400,
				    "invalid request line");
				goto abort;
			}
		}

		if ((line = evbuffer_readln(src,
		    &linelen, EVBUFFER_EOL_CRLF_STRICT)) == NULL) {
			/* No newline found after too many bytes */
			if (size > SERVER_MAXHEADERLENGTH) {
				server_abort_http(clt, 413,
				    "request line too long");
				goto abort;
			}
			break;
		}

		/*
		 * An empty line indicates the end of the request.
		 * libevent already stripped the \r\n for us.
		 */
		if (!linelen) {
			clt->clt_headersdone = 1;
			free(line);
			break;
		}
		key = line;

		/* Limit the total header length minus \r\n */
		clt->clt_headerlen += linelen;
		if (clt->clt_headerlen > SERVER_MAXHEADERLENGTH) {
			server_abort_http(clt, 413, "request too large");
			goto abort;
		}

		/*
		 * The first line is the GET/POST/PUT/... request,
		 * subsequent lines are HTTP headers.
		 */
		if (++clt->clt_line == 1)
			value = strchr(key, ' ');
		else if (*key == ' ' || *key == '\t')
			/* Multiline headers wrap with a space or tab */
			value = NULL;
		else
			value = strchr(key, ':');
		if (value == NULL) {
			if (clt->clt_line == 1) {
				server_abort_http(clt, 400, "malformed");
				goto abort;
			}

			/* Append line to the last header, if present */
			if (kv_extend(&desc->http_headers,
			    desc->http_lastheader, line) == NULL)
				goto fail;

			free(line);
			continue;
		}
		if (*value == ':') {
			*value++ = '\0';
			value += strspn(value, " \t\r\n");
		} else {
			*value++ = '\0';
		}

		DPRINTF("%s: session %d: header '%s: %s'", __func__,
		    clt->clt_id, key, value);

		/*
		 * Identify and handle specific HTTP request methods
		 */
		if (clt->clt_line == 1) {
			if ((desc->http_method = server_httpmethod_byname(key))
			    == HTTP_METHOD_NONE) {
				server_abort_http(clt, 400, "malformed");
				goto abort;
			}

			/*
			 * Decode request path and query
			 */
			desc->http_path = strdup(value);
			if (desc->http_path == NULL)
				goto fail;

			desc->http_version = strchr(desc->http_path, ' ');
			if (desc->http_version == NULL) {
				server_abort_http(clt, 400, "malformed");
				goto abort;
			}

			*desc->http_version++ = '\0';
			desc->http_query = strchr(desc->http_path, '?');
			if (desc->http_query != NULL)
				*desc->http_query++ = '\0';

			/*
			 * Have to allocate the strings because they could
			 * be changed independently by the filters later.
			 */
			if ((desc->http_version =
			    strdup(desc->http_version)) == NULL)
				goto fail;

			if (desc->http_query != NULL &&
			    (desc->http_query =
			    strdup(desc->http_query)) == NULL)
				goto fail;

		} else if (desc->http_method != HTTP_METHOD_NONE &&
		    strcasecmp("Content-Length", key) == 0) {
			if (desc->http_method == HTTP_METHOD_TRACE ||
			    desc->http_method == HTTP_METHOD_CONNECT) {
				/*
				 * These method should not have a body
				 * and thus no Content-Length header.
				 */
				server_abort_http(clt, 400, "malformed");
				goto abort;
			}

			/*
			 * Need to read data from the client after the
			 * HTTP header.
			 * XXX What about non-standard clients not using
			 * the carriage return? And some browsers seem to
			 * include the line length in the content-length.
			 */
			clt->clt_toread = strtonum(value, 0, LLONG_MAX,
			    &errstr);
			if (errstr) {
				server_abort_http(clt, 500, errstr);
				goto abort;
			}
			if ((size_t)clt->clt_toread >
			    srv_conf->maxrequestbody) {
				server_abort_http(clt, 413, NULL);
				goto abort;
			}
		}

		if (strcasecmp("Transfer-Encoding", key) == 0 &&
		    strcasecmp("chunked", value) == 0)
			desc->http_chunked = 1;

		if (clt->clt_line != 1) {
			if ((hdr = kv_add(&desc->http_headers, key,
			    value)) == NULL)
				goto fail;

			desc->http_lastheader = hdr;
		}

		free(line);
	}
	if (clt->clt_headersdone) {
		if (desc->http_method == HTTP_METHOD_NONE) {
			server_abort_http(clt, 406, "no method");
			return;
		}

		switch (desc->http_method) {
		case HTTP_METHOD_CONNECT:
			/* Data stream */
			clt->clt_toread = TOREAD_UNLIMITED;
			bev->readcb = server_read;
			break;
		case HTTP_METHOD_GET:
		case HTTP_METHOD_HEAD:
		/* WebDAV methods */
		case HTTP_METHOD_COPY:
		case HTTP_METHOD_MOVE:
			clt->clt_toread = 0;
			break;
		case HTTP_METHOD_DELETE:
		case HTTP_METHOD_OPTIONS:
		case HTTP_METHOD_POST:
		case HTTP_METHOD_PUT:
		case HTTP_METHOD_RESPONSE:
		/* WebDAV methods */
		case HTTP_METHOD_PROPFIND:
		case HTTP_METHOD_PROPPATCH:
		case HTTP_METHOD_MKCOL:
		case HTTP_METHOD_LOCK:
		case HTTP_METHOD_UNLOCK:
		case HTTP_METHOD_VERSION_CONTROL:
		case HTTP_METHOD_REPORT:
		case HTTP_METHOD_CHECKOUT:
		case HTTP_METHOD_CHECKIN:
		case HTTP_METHOD_UNCHECKOUT:
		case HTTP_METHOD_MKWORKSPACE:
		case HTTP_METHOD_UPDATE:
		case HTTP_METHOD_LABEL:
		case HTTP_METHOD_MERGE:
		case HTTP_METHOD_BASELINE_CONTROL:
		case HTTP_METHOD_MKACTIVITY:
		case HTTP_METHOD_ORDERPATCH:
		case HTTP_METHOD_ACL:
		case HTTP_METHOD_MKREDIRECTREF:
		case HTTP_METHOD_UPDATEREDIRECTREF:
		case HTTP_METHOD_SEARCH:
		case HTTP_METHOD_PATCH:
			/* HTTP request payload */
			if (clt->clt_toread > 0)
				bev->readcb = server_read_httpcontent;

			/* Single-pass HTTP body */
			if (clt->clt_toread < 0) {
				clt->clt_toread = TOREAD_UNLIMITED;
				bev->readcb = server_read;
			}
			break;
		default:
			server_abort_http(clt, 405, "method not allowed");
			return;
		}
		if (desc->http_chunked) {
			/* Chunked transfer encoding */
			clt->clt_toread = TOREAD_HTTP_CHUNK_LENGTH;
			bev->readcb = server_read_httpchunks;
		}

 done:
		if (clt->clt_toread != 0)
			bufferevent_disable(bev, EV_READ);
		server_response(httpd_env, clt);
		return;
	}
	if (clt->clt_done) {
		server_close(clt, "done");
		return;
	}
	if (EVBUFFER_LENGTH(src) && bev->readcb != server_read_http)
		bev->readcb(bev, arg);
	bufferevent_enable(bev, EV_READ);
	return;
 fail:
	server_abort_http(clt, 500, strerror(errno));
 abort:
	free(line);
}

void
server_read_httpcontent(struct bufferevent *bev, void *arg)
{
	struct client		*clt = arg;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);
	size_t			 size;

	getmonotime(&clt->clt_tv_last);

	size = EVBUFFER_LENGTH(src);
	DPRINTF("%s: session %d: size %lu, to read %lld", __func__,
	    clt->clt_id, size, clt->clt_toread);
	if (!size)
		return;

	if (clt->clt_toread > 0) {
		/* Read content data */
		if ((off_t)size > clt->clt_toread) {
			size = clt->clt_toread;
			if (fcgi_add_stdin(clt, src) == -1)
				goto fail;
			clt->clt_toread = 0;
		} else {
			if (fcgi_add_stdin(clt, src) == -1)
				goto fail;
			clt->clt_toread -= size;
		}
		DPRINTF("%s: done, size %lu, to read %lld", __func__,
		    size, clt->clt_toread);
	}
	if (clt->clt_toread == 0) {
		fcgi_add_stdin(clt, NULL);
		clt->clt_toread = TOREAD_HTTP_HEADER;
		bufferevent_disable(bev, EV_READ);
		bev->readcb = server_read_http;
		return;
	}
	if (clt->clt_done)
		goto done;
	if (bev->readcb != server_read_httpcontent)
		bev->readcb(bev, arg);

	return;
 done:
	return;
 fail:
	server_close(clt, strerror(errno));
}

void
server_read_httpchunks(struct bufferevent *bev, void *arg)
{
	struct client		*clt = arg;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);
	char			*line;
	long long		 llval;
	size_t			 size;

	getmonotime(&clt->clt_tv_last);

	size = EVBUFFER_LENGTH(src);
	DPRINTF("%s: session %d: size %lu, to read %lld", __func__,
	    clt->clt_id, size, clt->clt_toread);
	if (!size)
		return;

	if (clt->clt_toread > 0) {
		/* Read chunk data */
		if ((off_t)size > clt->clt_toread) {
			size = clt->clt_toread;
			if (server_bufferevent_write_chunk(clt, src, size)
			    == -1)
				goto fail;
			clt->clt_toread = 0;
		} else {
			if (server_bufferevent_write_buffer(clt, src) == -1)
				goto fail;
			clt->clt_toread -= size;
		}
		DPRINTF("%s: done, size %lu, to read %lld", __func__,
		    size, clt->clt_toread);
	}
	switch (clt->clt_toread) {
	case TOREAD_HTTP_CHUNK_LENGTH:
		line = evbuffer_readln(src, NULL, EVBUFFER_EOL_CRLF_STRICT);
		if (line == NULL) {
			/* Ignore empty line, continue */
			bufferevent_enable(bev, EV_READ);
			return;
		}
		if (strlen(line) == 0) {
			free(line);
			goto next;
		}

		/*
		 * Read prepended chunk size in hex, ignore the trailer.
		 * The returned signed value must not be negative.
		 */
		if (sscanf(line, "%llx", &llval) != 1 || llval < 0) {
			free(line);
			server_close(clt, "invalid chunk size");
			return;
		}

		if (server_bufferevent_print(clt, line) == -1 ||
		    server_bufferevent_print(clt, "\r\n") == -1) {
			free(line);
			goto fail;
		}
		free(line);

		if ((clt->clt_toread = llval) == 0) {
			DPRINTF("%s: last chunk", __func__);
			clt->clt_toread = TOREAD_HTTP_CHUNK_TRAILER;
		}
		break;
	case TOREAD_HTTP_CHUNK_TRAILER:
		/* Last chunk is 0 bytes followed by trailer and empty line */
		line = evbuffer_readln(src, NULL, EVBUFFER_EOL_CRLF_STRICT);
		if (line == NULL) {
			/* Ignore empty line, continue */
			bufferevent_enable(bev, EV_READ);
			return;
		}
		if (server_bufferevent_print(clt, line) == -1 ||
		    server_bufferevent_print(clt, "\r\n") == -1) {
			free(line);
			goto fail;
		}
		if (strlen(line) == 0) {
			/* Switch to HTTP header mode */
			clt->clt_toread = TOREAD_HTTP_HEADER;
			bev->readcb = server_read_http;
		}
		free(line);
		break;
	case 0:
		/* Chunk is terminated by an empty newline */
		line = evbuffer_readln(src, NULL, EVBUFFER_EOL_CRLF_STRICT);
		free(line);
		if (server_bufferevent_print(clt, "\r\n") == -1)
			goto fail;
		clt->clt_toread = TOREAD_HTTP_CHUNK_LENGTH;
		break;
	}

 next:
	if (clt->clt_done)
		goto done;
	if (EVBUFFER_LENGTH(src))
		bev->readcb(bev, arg);
	bufferevent_enable(bev, EV_READ);
	return;

 done:
	server_close(clt, "last http chunk read (done)");
	return;
 fail:
	server_close(clt, strerror(errno));
}

void
server_read_httprange(struct bufferevent *bev, void *arg)
{
	struct client		*clt = arg;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);
	size_t			 size;
	struct media_type	*media;
	struct range_data	*r = &clt->clt_ranges;
	struct range		*range;

	getmonotime(&clt->clt_tv_last);

	if (r->range_toread > 0) {
		size = EVBUFFER_LENGTH(src);
		if (!size)
			return;

		/* Read chunk data */
		if ((off_t)size > r->range_toread) {
			size = r->range_toread;
			if (server_bufferevent_write_chunk(clt, src, size)
			    == -1)
				goto fail;
			r->range_toread = 0;
		} else {
			if (server_bufferevent_write_buffer(clt, src) == -1)
				goto fail;
			r->range_toread -= size;
		}
		if (r->range_toread < 1)
			r->range_toread = TOREAD_HTTP_RANGE;
		DPRINTF("%s: done, size %lu, to read %lld", __func__,
		    size, r->range_toread);
	}

	switch (r->range_toread) {
	case TOREAD_HTTP_RANGE:
		if (r->range_index >= r->range_count) {
			if (r->range_count > 1) {
				/* Add end marker */
				if (server_bufferevent_printf(clt,
				    "\r\n--%llu--\r\n",
				    clt->clt_boundary) == -1)
					goto fail;
			}
			r->range_toread = TOREAD_HTTP_NONE;
			break;
		}

		range = &r->range[r->range_index];

		if (r->range_count > 1) {
			media = r->range_media;
			if (server_bufferevent_printf(clt,
			    "\r\n--%llu\r\n"
			    "Content-Type: %s/%s\r\n"
			    "Content-Range: bytes %lld-%lld/%zu\r\n\r\n",
			    clt->clt_boundary,
			    media->media_type, media->media_subtype,
			    range->start, range->end, r->range_total) == -1)
				goto fail;
		}
		r->range_toread = range->end - range->start + 1;

		if (lseek(clt->clt_fd, range->start, SEEK_SET) == -1)
			goto fail;

		/* Throw away bytes that are already in the input buffer */
		evbuffer_drain(src, EVBUFFER_LENGTH(src));

		/* Increment for the next part */
		r->range_index++;
		break;
	case TOREAD_HTTP_NONE:
	case 0:
		break;
	}

	if (clt->clt_done)
		goto done;

	if (EVBUFFER_LENGTH(EVBUFFER_OUTPUT(clt->clt_bev)) > (size_t)
	    SERVER_MAX_PREFETCH * clt->clt_sndbufsiz) {
		bufferevent_disable(clt->clt_srvbev, EV_READ);
		clt->clt_srvbev_throttled = 1;
	}

	return;
 done:
	(*bev->errorcb)(bev, EVBUFFER_READ, bev->cbarg);
	return;
 fail:
	server_close(clt, strerror(errno));
}

void
server_reset_http(struct client *clt)
{
	struct server		*srv = clt->clt_srv;

	server_log(clt, NULL);

	server_httpdesc_free(clt->clt_descreq);
	server_httpdesc_free(clt->clt_descresp);
	clt->clt_headerlen = 0;
	clt->clt_headersdone = 0;
	clt->clt_done = 0;
	clt->clt_line = 0;
	clt->clt_chunk = 0;
	free(clt->clt_remote_user);
	clt->clt_remote_user = NULL;
	clt->clt_bev->readcb = server_read_http;
	clt->clt_srv_conf = &srv->srv_conf;
	str_match_free(&clt->clt_srv_match);
}

ssize_t
server_http_time(time_t t, char *tmbuf, size_t len)
{
	struct tm		 tm;

	/* New HTTP/1.1 RFC 7231 prefers IMF-fixdate from RFC 5322 */
	if (t == -1 || gmtime_r(&t, &tm) == NULL)
		return (-1);
	else
		return (strftime(tmbuf, len, "%a, %d %h %Y %T %Z", &tm));
}

const char *
server_http_host(struct sockaddr_storage *ss, char *buf, size_t len)
{
	char		hbuf[HOST_NAME_MAX+1];
	in_port_t	port;

	if (print_host(ss, buf, len) == NULL)
		return (NULL);

	port = ntohs(server_socket_getport(ss));
	if (port == HTTP_PORT)
		return (buf);

	switch (ss->ss_family) {
	case AF_INET:
		if ((size_t)snprintf(hbuf, sizeof(hbuf),
		    "%s:%u", buf, port) >= sizeof(hbuf))
			return (NULL);
		break;
	case AF_INET6:
		if ((size_t)snprintf(hbuf, sizeof(hbuf),
		    "[%s]:%u", buf, port) >= sizeof(hbuf))
			return (NULL);
		break;
	}

	if (strlcpy(buf, hbuf, len) >= len)
		return (NULL);

	return (buf);
}

char *
server_http_parsehost(char *host, char *buf, size_t len, int *portval)
{
	char		*start, *end, *port;
	const char	*errstr = NULL;

	if (strlcpy(buf, host, len) >= len) {
		log_debug("%s: host name too long", __func__);
		return (NULL);
	}

	start = buf;
	end = port = NULL;

	if (*start == '[' && (end = strchr(start, ']')) != NULL) {
		/* Address enclosed in [] with port, eg. [2001:db8::1]:80 */
		start++;
		*end++ = '\0';
		if ((port = strchr(end, ':')) == NULL || *port == '\0')
			port = NULL;
		else
			port++;
		memmove(buf, start, strlen(start) + 1);
	} else if ((end = strchr(start, ':')) != NULL) {
		/* Name or address with port, eg. www.example.com:80 */
		*end++ = '\0';
		port = end;
	} else {
		/* Name or address with default port, eg. www.example.com */
		port = NULL;
	}

	if (port != NULL) {
		/* Save the requested port */
		*portval = strtonum(port, 0, 0xffff, &errstr);
		if (errstr != NULL) {
			log_debug("%s: invalid port: %s", __func__,
			    strerror(errno));
			return (NULL);
		}
		*portval = htons(*portval);
	} else {
		/* Port not given, indicate the default port */
		*portval = -1;
	}

	return (start);
}

void
server_abort_http(struct client *clt, unsigned int code, const char *msg)
{
	struct server_config	*srv_conf = clt->clt_srv_conf;
	struct bufferevent	*bev = clt->clt_bev;
	struct http_descriptor	*desc = clt->clt_descreq;
	const char		*httperr = NULL, *style;
	char			*httpmsg, *body = NULL, *extraheader = NULL;
	char			 tmbuf[32], hbuf[128], *hstsheader = NULL;
	char			 buf[IBUF_READ_SIZE];
	char			*escapedmsg = NULL;
	int			 bodylen;

	if (code == 0) {
		server_close(clt, "dropped");
		return;
	}

	if ((httperr = server_httperror_byid(code)) == NULL)
		httperr = "Unknown Error";

	if (bev == NULL)
		goto done;

	if (server_log_http(clt, code, 0) == -1)
		goto done;

	/* Some system information */
	if (print_host(&srv_conf->ss, hbuf, sizeof(hbuf)) == NULL)
		goto done;

	if (server_http_time(time(NULL), tmbuf, sizeof(tmbuf)) <= 0)
		goto done;

	/* Do not send details of the Internal Server Error */
	switch (code) {
	case 301:
	case 302:
	case 303:
		if (msg == NULL)
			break;
		memset(buf, 0, sizeof(buf));
		if (server_expand_http(clt, msg, buf, sizeof(buf)) == NULL)
			goto done;
		if (asprintf(&extraheader, "Location: %s\r\n", buf) == -1) {
			code = 500;
			extraheader = NULL;
		}
		msg = buf;
		break;
	case 401:
		if (msg == NULL)
			break;
		if (stravis(&escapedmsg, msg, VIS_DQ) == -1) {
			code = 500;
			extraheader = NULL;
		} else if (asprintf(&extraheader,
		    "WWW-Authenticate: Basic realm=\"%s\"\r\n", escapedmsg)
		    == -1) {
			code = 500;
			extraheader = NULL;
		}
		break;
	case 416:
		if (msg == NULL)
			break;
		if (asprintf(&extraheader,
		    "Content-Range: %s\r\n", msg) == -1) {
			code = 500;
			extraheader = NULL;
		}
		break;
	default:
		/*
		 * Do not send details of the error.  Traditionally,
		 * web servers responsed with the request path on 40x
		 * errors which could be abused to inject JavaScript etc.
		 * Instead of sanitizing the path here, we just don't
		 * reprint it.
		 */
		break;
	}

	free(escapedmsg);

	/* A CSS stylesheet allows minimal customization by the user */
	style = "body { background-color: white; color: black; font-family: "
	    "'Comic Sans MS', 'Chalkboard SE', 'Comic Neue', sans-serif; }\n"
	    "hr { border: 0; border-bottom: 1px dashed; }\n";

	/* Generate simple HTML error document */
	if ((bodylen = asprintf(&body,
	    "<!DOCTYPE html>\n"
	    "<html>\n"
	    "<head>\n"
	    "<meta http-equiv=\"Content-Type\" content=\"text/html; "
	    "charset=utf-8\"/>\n"
	    "<title>%03d %s</title>\n"
	    "<style type=\"text/css\"><!--\n%s\n--></style>\n"
	    "</head>\n"
	    "<body>\n"
	    "<h1>%03d %s</h1>\n"
	    "<hr>\n<address>%s</address>\n"
	    "</body>\n"
	    "</html>\n",
	    code, httperr, style, code, httperr, HTTPD_SERVERNAME)) == -1) {
		body = NULL;
		goto done;
	}

	if (srv_conf->flags & SRVFLAG_SERVER_HSTS) {
		if (asprintf(&hstsheader, "Strict-Transport-Security: "
		    "max-age=%d%s%s\r\n", srv_conf->hsts_max_age,
		    srv_conf->hsts_flags & HSTSFLAG_SUBDOMAINS ?
		    "; includeSubDomains" : "",
		    srv_conf->hsts_flags & HSTSFLAG_PRELOAD ?
		    "; preload" : "") == -1) {
			hstsheader = NULL;
			goto done;
		}
	}

	/* Add basic HTTP headers */
	if (asprintf(&httpmsg,
	    "HTTP/1.0 %03d %s\r\n"
	    "Date: %s\r\n"
	    "Server: %s\r\n"
	    "Connection: close\r\n"
	    "Content-Type: text/html\r\n"
	    "Content-Length: %d\r\n"
	    "%s"
	    "%s"
	    "\r\n"
	    "%s",
	    code, httperr, tmbuf, HTTPD_SERVERNAME, bodylen,
	    extraheader == NULL ? "" : extraheader,
	    hstsheader == NULL ? "" : hstsheader,
	    desc->http_method == HTTP_METHOD_HEAD ? "" : body) == -1)
		goto done;

	/* Dump the message without checking for success */
	server_dump(clt, httpmsg, strlen(httpmsg));
	free(httpmsg);

 done:
	free(body);
	free(extraheader);
	free(hstsheader);
	if (msg == NULL)
		msg = "\"\"";
	if (asprintf(&httpmsg, "%s (%03d %s)", msg, code, httperr) == -1) {
		server_close(clt, msg);
	} else {
		server_close(clt, httpmsg);
		free(httpmsg);
	}
}

void
server_close_http(struct client *clt)
{
	struct http_descriptor *desc;

	desc = clt->clt_descreq;
	server_httpdesc_free(desc);
	free(desc);
	clt->clt_descreq = NULL;

	desc = clt->clt_descresp;
	server_httpdesc_free(desc);
	free(desc);
	clt->clt_descresp = NULL;
	free(clt->clt_remote_user);
	clt->clt_remote_user = NULL;

	str_match_free(&clt->clt_srv_match);
}

char *
server_expand_http(struct client *clt, const char *val, char *buf,
    size_t len)
{
	struct http_descriptor	*desc = clt->clt_descreq;
	struct server_config	*srv_conf = clt->clt_srv_conf;
	char			 ibuf[128], *str, *path, *query;
	const char		*errstr = NULL, *p;
	size_t			 size;
	int			 n, ret;

	if (strlcpy(buf, val, len) >= len)
		return (NULL);

	/* Find previously matched substrings by index */
	for (p = val; clt->clt_srv_match.sm_nmatch &&
	    (p = strstr(p, "%")) != NULL; p++) {
		if (!isdigit((unsigned char)*(p + 1)))
			continue;

		/* Copy number, leading '%' char and add trailing \0 */
		size = strspn(p + 1, "0123456789") + 2;
		if (size  >= sizeof(ibuf))
			return (NULL);
		(void)strlcpy(ibuf, p, size);
		n = strtonum(ibuf + 1, 0,
		    clt->clt_srv_match.sm_nmatch - 1, &errstr);
		if (errstr != NULL)
			return (NULL);

		/* Expand variable with matched value */
		if ((str = url_encode(clt->clt_srv_match.sm_match[n])) == NULL)
			return (NULL);
		ret = expand_string(buf, len, ibuf, str);
		free(str);
		if (ret != 0)
			return (NULL);
	}
	if (strstr(val, "$DOCUMENT_URI") != NULL) {
		if ((path = url_encode(desc->http_path)) == NULL)
			return (NULL);
		ret = expand_string(buf, len, "$DOCUMENT_URI", path);
		free(path);
		if (ret != 0)
			return (NULL);
	}
	if (strstr(val, "$QUERY_STRING") != NULL) {
		if (desc->http_query == NULL) {
			ret = expand_string(buf, len, "$QUERY_STRING", "");
		} else {
			if ((query = url_encode(desc->http_query)) == NULL)
				return (NULL);
			ret = expand_string(buf, len, "$QUERY_STRING", query);
			free(query);
		}
		if (ret != 0)
			return (NULL);
	}
	if (strstr(val, "$HTTP_HOST") != NULL) {
		if (desc->http_host == NULL)
			return (NULL);
		if ((str = url_encode(desc->http_host)) == NULL)
			return (NULL);
		expand_string(buf, len, "$HTTP_HOST", str);
		free(str);
	}
	if (strstr(val, "$REMOTE_") != NULL) {
		if (strstr(val, "$REMOTE_ADDR") != NULL) {
			if (print_host(&clt->clt_ss,
			    ibuf, sizeof(ibuf)) == NULL)
				return (NULL);
			if (expand_string(buf, len,
			    "$REMOTE_ADDR", ibuf) != 0)
				return (NULL);
		}
		if (strstr(val, "$REMOTE_PORT") != NULL) {
			snprintf(ibuf, sizeof(ibuf),
			    "%u", ntohs(clt->clt_port));
			if (expand_string(buf, len,
			    "$REMOTE_PORT", ibuf) != 0)
				return (NULL);
		}
		if (strstr(val, "$REMOTE_USER") != NULL) {
			if ((srv_conf->flags & SRVFLAG_AUTH) &&
			    clt->clt_remote_user != NULL) {
				if ((str = url_encode(clt->clt_remote_user))
				    == NULL)
					return (NULL);
			} else
				str = strdup("");
			ret = expand_string(buf, len, "$REMOTE_USER", str);
			free(str);
			if (ret != 0)
				return (NULL);
		}
	}
	if (strstr(val, "$REQUEST_URI") != NULL) {
		if ((path = url_encode(desc->http_path)) == NULL)
			return (NULL);
		if (desc->http_query == NULL) {
			str = path;
		} else {
			if ((query = url_encode(desc->http_query)) == NULL) {
				free(path);
				return (NULL);
			}
			ret = asprintf(&str, "%s?%s", path, query);
			free(path);
			free(query);
			if (ret == -1)
				return (NULL);
		}

		ret = expand_string(buf, len, "$REQUEST_URI", str);
		free(str);
		if (ret != 0)
			return (NULL);
	}
	if (strstr(val, "$SERVER_") != NULL) {
		if (strstr(val, "$SERVER_ADDR") != NULL) {
			if (print_host(&srv_conf->ss,
			    ibuf, sizeof(ibuf)) == NULL)
				return (NULL);
			if (expand_string(buf, len,
			    "$SERVER_ADDR", ibuf) != 0)
				return (NULL);
		}
		if (strstr(val, "$SERVER_PORT") != NULL) {
			snprintf(ibuf, sizeof(ibuf), "%u",
			    ntohs(srv_conf->port));
			if (expand_string(buf, len,
			    "$SERVER_PORT", ibuf) != 0)
				return (NULL);
		}
		if (strstr(val, "$SERVER_NAME") != NULL) {
			if ((str = url_encode(srv_conf->name))
			     == NULL)
				return (NULL);
			ret = expand_string(buf, len, "$SERVER_NAME", str);
			free(str);
			if (ret != 0)
				return (NULL);
		}
	}

	return (buf);
}

int
server_response(struct httpd *httpd, struct client *clt)
{
	char			 path[PATH_MAX];
	char			 hostname[HOST_NAME_MAX+1];
	struct http_descriptor	*desc = clt->clt_descreq;
	struct http_descriptor	*resp = clt->clt_descresp;
	struct server		*srv = clt->clt_srv;
	struct server_config	*srv_conf = &srv->srv_conf;
	struct kv		*kv, key, *host;
	struct str_find		 sm;
	int			 portval = -1, ret;
	char			*hostval;
	const char		*errstr = NULL;

	/* Canonicalize the request path */
	if (desc->http_path == NULL ||
	    url_decode(desc->http_path) == NULL ||
	    canonicalize_path(desc->http_path, path, sizeof(path)) == NULL)
		goto fail;
	free(desc->http_path);
	if ((desc->http_path = strdup(path)) == NULL)
		goto fail;

	key.kv_key = "Host";
	if ((host = kv_find(&desc->http_headers, &key)) != NULL &&
	    host->kv_value == NULL)
		host = NULL;

	if (strcmp(desc->http_version, "HTTP/1.1") == 0) {
		/* Host header is mandatory */
		if (host == NULL)
			goto fail;

		/* Is the connection persistent? */
		key.kv_key = "Connection";
		if ((kv = kv_find(&desc->http_headers, &key)) != NULL &&
		    strcasecmp("close", kv->kv_value) == 0)
			clt->clt_persist = 0;
		else
			clt->clt_persist++;
	} else {
		/* Is the connection persistent? */
		key.kv_key = "Connection";
		if ((kv = kv_find(&desc->http_headers, &key)) != NULL &&
		    strcasecmp("keep-alive", kv->kv_value) == 0)
			clt->clt_persist++;
		else
			clt->clt_persist = 0;
	}

	if (clt->clt_persist >= srv_conf->maxrequests)
		clt->clt_persist = 0;

	/* pipelining should end after the first "idempotent" method */
	if (clt->clt_pipelining && clt->clt_toread > 0)
		clt->clt_persist = 0;

	/*
	 * Do we have a Host header and matching configuration?
	 * XXX the Host can also appear in the URL path.
	 */
	if (host != NULL) {
		if ((hostval = server_http_parsehost(host->kv_value,
		    hostname, sizeof(hostname), &portval)) == NULL)
			goto fail;

		TAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {
#ifdef DEBUG
			if ((srv_conf->flags & SRVFLAG_LOCATION) == 0) {
				DPRINTF("%s: virtual host \"%s:%u\""
				    " host \"%s\" (\"%s\")",
				    __func__, srv_conf->name,
				    ntohs(srv_conf->port), host->kv_value,
				    hostname);
			}
#endif
			if (srv_conf->flags & SRVFLAG_LOCATION)
				continue;
			else if (srv_conf->flags & SRVFLAG_SERVER_MATCH) {
				str_find(hostname, srv_conf->name,
				    &sm, 1, &errstr);
				ret = errstr == NULL ? 0 : -1;
			} else {
				ret = fnmatch(srv_conf->name,
				    hostname, FNM_CASEFOLD);
			}
			if (ret == 0 &&
			    (portval == -1 ||
			    (portval != -1 && portval == srv_conf->port))) {
				/* Replace host configuration */
				clt->clt_srv_conf = srv_conf;
				srv_conf = NULL;
				break;
			}
		}
	}

	if (srv_conf != NULL) {
		/* Use the actual server IP address */
		if (server_http_host(&clt->clt_srv_ss, hostname,
		    sizeof(hostname)) == NULL)
			goto fail;
	} else {
		/* Host header was valid and found */
		if (strlcpy(hostname, host->kv_value, sizeof(hostname)) >=
		    sizeof(hostname))
			goto fail;
		srv_conf = clt->clt_srv_conf;
	}

	if ((desc->http_host = strdup(hostname)) == NULL)
		goto fail;

	/* Now fill in the mandatory parts of the response descriptor */
	resp->http_method = desc->http_method;
	if ((resp->http_version = strdup(desc->http_version)) == NULL)
		goto fail;

	/* Now search for the location */
	srv_conf = server_getlocation(clt, desc->http_path);

	if (srv_conf->flags & SRVFLAG_BLOCK) {
		server_abort_http(clt, srv_conf->return_code,
		    srv_conf->return_uri);
		return (-1);
	} else if (srv_conf->flags & SRVFLAG_AUTH &&
	    server_http_authenticate(srv_conf, clt) == -1) {
		server_abort_http(clt, 401, srv_conf->auth_realm);
		return (-1);
	} else
		return (server_file(httpd, clt));
 fail:
	server_abort_http(clt, 400, "bad request");
	return (-1);
}

const char *
server_root_strip(const char *path, int n)
{
	const char *p;

	/* Strip strip leading directories. Leading '/' is ignored. */
	for (; n > 0 && *path != '\0'; n--)
		if ((p = strchr(++path, '/')) == NULL)
			path = strchr(path, '\0');
		else
			path = p;

	return (path);
}

struct server_config *
server_getlocation(struct client *clt, const char *path)
{
	struct server		*srv = clt->clt_srv;
	struct server_config	*srv_conf = clt->clt_srv_conf, *location;
	const char		*errstr = NULL;
	int			 ret;

	/* Now search for the location */
	TAILQ_FOREACH(location, &srv->srv_hosts, entry) {
#ifdef DEBUG
		if (location->flags & SRVFLAG_LOCATION) {
			DPRINTF("%s: location \"%s\" path \"%s\"",
			    __func__, location->location, path);
		}
#endif
		if ((location->flags & SRVFLAG_LOCATION) &&
		    location->parent_id == srv_conf->parent_id) {
			errstr = NULL;
			if (location->flags & SRVFLAG_LOCATION_MATCH) {
				ret = str_match(path, location->location,
				    &clt->clt_srv_match, &errstr);
			} else {
				ret = fnmatch(location->location,
				    path, FNM_CASEFOLD);
			}
			if (ret == 0 && errstr == NULL) {
				/* Replace host configuration */
				clt->clt_srv_conf = srv_conf = location;
				break;
			}
		}
	}

	return (srv_conf);
}

int
server_response_http(struct client *clt, unsigned int code,
    struct media_type *media, off_t size, time_t mtime)
{
	struct server_config	*srv_conf = clt->clt_srv_conf;
	struct http_descriptor	*desc = clt->clt_descreq;
	struct http_descriptor	*resp = clt->clt_descresp;
	const char		*error;
	struct kv		*ct, *cl;
	char			 tmbuf[32];

	if (desc == NULL || media == NULL ||
	    (error = server_httperror_byid(code)) == NULL)
		return (-1);

	if (server_log_http(clt, code, size) == -1)
		return (-1);

	/* Add error codes */
	if (kv_setkey(&resp->http_pathquery, "%u", code) == -1 ||
	    kv_set(&resp->http_pathquery, "%s", error) == -1)
		return (-1);

	/* Add headers */
	if (kv_add(&resp->http_headers, "Server", HTTPD_SERVERNAME) == NULL)
		return (-1);

	/* Is it a persistent connection? */
	if (clt->clt_persist) {
		if (kv_add(&resp->http_headers,
		    "Connection", "keep-alive") == NULL)
			return (-1);
	} else if (kv_add(&resp->http_headers, "Connection", "close") == NULL)
		return (-1);

	/* Set media type */
	if ((ct = kv_add(&resp->http_headers, "Content-Type", NULL)) == NULL ||
	    kv_set(ct, "%s/%s", media->media_type, media->media_subtype) == -1)
		return (-1);

	/* Set content length, if specified */
	if ((cl =
	    kv_add(&resp->http_headers, "Content-Length", NULL)) == NULL ||
	    kv_set(cl, "%lld", (long long)size) == -1)
		return (-1);

	/* Set last modification time */
	if (server_http_time(mtime, tmbuf, sizeof(tmbuf)) <= 0 ||
	    kv_add(&resp->http_headers, "Last-Modified", tmbuf) == NULL)
		return (-1);

	/* HSTS header */
	if (srv_conf->flags & SRVFLAG_SERVER_HSTS) {
		if ((cl =
		    kv_add(&resp->http_headers, "Strict-Transport-Security",
		    NULL)) == NULL ||
		    kv_set(cl, "max-age=%d%s%s", srv_conf->hsts_max_age,
		    srv_conf->hsts_flags & HSTSFLAG_SUBDOMAINS ?
		    "; includeSubDomains" : "",
		    srv_conf->hsts_flags & HSTSFLAG_PRELOAD ?
		    "; preload" : "") == -1)
			return (-1);
	}

	/* Date header is mandatory and should be added as late as possible */
	if (server_http_time(time(NULL), tmbuf, sizeof(tmbuf)) <= 0 ||
	    kv_add(&resp->http_headers, "Date", tmbuf) == NULL)
		return (-1);

	/* Write completed header */
	if (server_writeresponse_http(clt) == -1 ||
	    server_bufferevent_print(clt, "\r\n") == -1 ||
	    server_headers(clt, resp, server_writeheader_http, NULL) == -1 ||
	    server_bufferevent_print(clt, "\r\n") == -1)
		return (-1);

	if (size == 0 || resp->http_method == HTTP_METHOD_HEAD) {
		bufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);
		if (clt->clt_persist)
			clt->clt_toread = TOREAD_HTTP_HEADER;
		else
			clt->clt_toread = TOREAD_HTTP_NONE;
		clt->clt_done = 0;
		return (0);
	}

	return (1);
}

int
server_writeresponse_http(struct client *clt)
{
	struct http_descriptor	*desc = clt->clt_descresp;

	DPRINTF("version: %s rescode: %s resmsg: %s", desc->http_version,
	    desc->http_rescode, desc->http_resmesg);

	if (server_bufferevent_print(clt, desc->http_version) == -1 ||
	    server_bufferevent_print(clt, " ") == -1 ||
	    server_bufferevent_print(clt, desc->http_rescode) == -1 ||
	    server_bufferevent_print(clt, " ") == -1 ||
	    server_bufferevent_print(clt, desc->http_resmesg) == -1)
		return (-1);

	return (0);
}

int
server_writeheader_http(struct client *clt, struct kv *hdr, void *arg)
{
	char			*ptr;
	const char		*key;

	if (hdr->kv_flags & KV_FLAG_INVALID)
		return (0);

	/* The key might have been updated in the parent */
	if (hdr->kv_parent != NULL && hdr->kv_parent->kv_key != NULL)
		key = hdr->kv_parent->kv_key;
	else
		key = hdr->kv_key;

	ptr = hdr->kv_value;
	if (server_bufferevent_print(clt, key) == -1 ||
	    (ptr != NULL &&
	    (server_bufferevent_print(clt, ": ") == -1 ||
	    server_bufferevent_print(clt, ptr) == -1 ||
	    server_bufferevent_print(clt, "\r\n") == -1)))
		return (-1);
	DPRINTF("%s: %s: %s", __func__, key,
	    hdr->kv_value == NULL ? "" : hdr->kv_value);

	return (0);
}

int
server_headers(struct client *clt, void *descp,
    int (*hdr_cb)(struct client *, struct kv *, void *), void *arg)
{
	struct kv		*hdr, *kv;
	struct http_descriptor	*desc = descp;

	RB_FOREACH(hdr, kvtree, &desc->http_headers) {
		if ((hdr_cb)(clt, hdr, arg) == -1)
			return (-1);
		TAILQ_FOREACH(kv, &hdr->kv_children, kv_entry) {
			if ((hdr_cb)(clt, kv, arg) == -1)
				return (-1);
		}
	}

	return (0);
}

enum httpmethod
server_httpmethod_byname(const char *name)
{
	enum httpmethod		 id = HTTP_METHOD_NONE;
	struct http_method	 method, *res = NULL;

	/* Set up key */
	method.method_name = name;

	if ((res = bsearch(&method, http_methods,
	    sizeof(http_methods) / sizeof(http_methods[0]) - 1,
	    sizeof(http_methods[0]), server_httpmethod_cmp)) != NULL)
		id = res->method_id;

	return (id);
}

const char *
server_httpmethod_byid(unsigned int id)
{
	const char	*name = "<UNKNOWN>";
	int		 i;

	for (i = 0; http_methods[i].method_name != NULL; i++) {
		if (http_methods[i].method_id == id) {
			name = http_methods[i].method_name;
			break;
		}
	}

	return (name);
}

static int
server_httpmethod_cmp(const void *a, const void *b)
{
	const struct http_method *ma = a;
	const struct http_method *mb = b;

	/*
	 * RFC 2616 section 5.1.1 says that the method is case
	 * sensitive so we don't do a strcasecmp here.
	 */
	return (strcmp(ma->method_name, mb->method_name));
}

const char *
server_httperror_byid(unsigned int id)
{
	struct http_error	 error, *res;

	/* Set up key */
	error.error_code = (int)id;

	if ((res = bsearch(&error, http_errors,
	    sizeof(http_errors) / sizeof(http_errors[0]) - 1,
	    sizeof(http_errors[0]), server_httperror_cmp)) != NULL)
		return (res->error_name);

	return (NULL);
}

static int
server_httperror_cmp(const void *a, const void *b)
{
	const struct http_error *ea = a;
	const struct http_error *eb = b;
	return (ea->error_code - eb->error_code);
}

int
server_log_http(struct client *clt, unsigned int code, size_t len)
{
	static char		 tstamp[64];
	static char		 ip[INET6_ADDRSTRLEN];
	time_t			 t;
	struct kv		 key, *agent, *referrer;
	struct tm		*tm;
	struct server_config	*srv_conf;
	struct http_descriptor	*desc;
	int			 ret = -1;
	char			*user = NULL;
	char			*path = NULL;
	char			*query = NULL;
	char			*version = NULL;
	char			*referrer_v = NULL;
	char			*agent_v = NULL;

	if ((srv_conf = clt->clt_srv_conf) == NULL)
		return (-1);
	if ((srv_conf->flags & SRVFLAG_LOG) == 0)
		return (0);
	if ((desc = clt->clt_descreq) == NULL)
		return (-1);

	if ((t = time(NULL)) == -1)
		return (-1);
	if ((tm = localtime(&t)) == NULL)
		return (-1);
	if (strftime(tstamp, sizeof(tstamp), "%d/%b/%Y:%H:%M:%S %z", tm) == 0)
		return (-1);

	if (print_host(&clt->clt_ss, ip, sizeof(ip)) == NULL)
		return (-1);

	/*
	 * For details on common log format, see:
	 * https://httpd.apache.org/docs/current/mod/mod_log_config.html
	 *
	 * httpd's format is similar to these Apache LogFormats:
	 * "%v %h %l %u %t \"%r\" %>s %B"
	 * "%v %h %l %u %t \"%r\" %>s %B \"%{Referer}i\" \"%{User-agent}i\""
	 */
	switch (srv_conf->logformat) {
	case LOG_FORMAT_COMMON:
		/* Use vis to encode input values from the header */
		if (clt->clt_remote_user &&
		    stravis(&user, clt->clt_remote_user, HTTPD_LOGVIS) == -1)
			goto done;
		if (desc->http_version &&
		    stravis(&version, desc->http_version, HTTPD_LOGVIS) == -1)
			goto done;

		/* The following should be URL-encoded */
		if (desc->http_path &&
		    (path = url_encode(desc->http_path)) == NULL)
			goto done;
		if (desc->http_query &&
		    (query = url_encode(desc->http_query)) == NULL)
			goto done;

		ret = evbuffer_add_printf(clt->clt_log,
		    "%s %s - %s [%s] \"%s %s%s%s%s%s\" %03d %zu\n",
		    srv_conf->name, ip, clt->clt_remote_user == NULL ? "-" :
		    user, tstamp,
		    server_httpmethod_byid(desc->http_method),
		    desc->http_path == NULL ? "" : path,
		    desc->http_query == NULL ? "" : "?",
		    desc->http_query == NULL ? "" : query,
		    desc->http_version == NULL ? "" : " ",
		    desc->http_version == NULL ? "" : version,
		    code, len);

		break;

	case LOG_FORMAT_COMBINED:
		key.kv_key = "Referer"; /* sic */
		if ((referrer = kv_find(&desc->http_headers, &key)) != NULL &&
		    referrer->kv_value == NULL)
			referrer = NULL;

		key.kv_key = "User-Agent";
		if ((agent = kv_find(&desc->http_headers, &key)) != NULL &&
		    agent->kv_value == NULL)
			agent = NULL;

		/* Use vis to encode input values from the header */
		if (clt->clt_remote_user &&
		    stravis(&user, clt->clt_remote_user, HTTPD_LOGVIS) == -1)
			goto done;
		if (desc->http_version &&
		    stravis(&version, desc->http_version, HTTPD_LOGVIS) == -1)
			goto done;
		if (agent &&
		    stravis(&agent_v, agent->kv_value, HTTPD_LOGVIS) == -1)
			goto done;

		/* The following should be URL-encoded */
		if (desc->http_path &&
		    (path = url_encode(desc->http_path)) == NULL)
			goto done;
		if (desc->http_query &&
		    (query = url_encode(desc->http_query)) == NULL)
			goto done;
		if (referrer &&
		    (referrer_v = url_encode(referrer->kv_value)) == NULL)
			goto done;

		ret = evbuffer_add_printf(clt->clt_log,
		    "%s %s - %s [%s] \"%s %s%s%s%s%s\""
		    " %03d %zu \"%s\" \"%s\"\n",
		    srv_conf->name, ip, clt->clt_remote_user == NULL ? "-" :
		    user, tstamp,
		    server_httpmethod_byid(desc->http_method),
		    desc->http_path == NULL ? "" : path,
		    desc->http_query == NULL ? "" : "?",
		    desc->http_query == NULL ? "" : query,
		    desc->http_version == NULL ? "" : " ",
		    desc->http_version == NULL ? "" : version,
		    code, len,
		    referrer == NULL ? "" : referrer_v,
		    agent == NULL ? "" : agent_v);

		break;

	case LOG_FORMAT_CONNECTION:
		/* URL-encode the path */
		if (desc->http_path &&
		    (path = url_encode(desc->http_path)) == NULL)
			goto done;

		ret = evbuffer_add_printf(clt->clt_log, " [%s]",
		    desc->http_path == NULL ? "" : path);

		break;
	}

done:
	free(user);
	free(path);
	free(query);
	free(version);
	free(referrer_v);
	free(agent_v);

	return (ret);
}
@


1.116
log
@Expand $HTTP_HOST in redirects.
From Rivo Nurges Rivo.Nurges AT smit.ee, thanks!
OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.115 2017/03/10 21:06:43 reyk Exp $	*/
d890 2
d903 2
@


1.115
log
@Sync from relayd: DELETE can have a body.

Fix by Rivo Nurges, fixes a problem with Atlassian JIRA

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.114 2017/02/07 12:22:41 reyk Exp $	*/
d1070 8
@


1.114
log
@Improve parsing of the HTTP request line

Make sure that the beginning of a new request starts with an
alphabetic character.  This is a quick way to detect non-ASCII
requests (eg. TLS on port 80).  The full validation of the request
method is done once the input line is read.

Make sure that non-terminated lines do not exceed the
SERVER_MAXHEADERLENGTH which is 8k.  As the current read watermark is
set to 64k, this means that the limit check is triggered after max.
64k of input, depending on the TCP read buffer.

OK benno@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.113 2017/02/02 22:19:59 reyk Exp $	*/
a392 1
		case HTTP_METHOD_DELETE:
d400 1
@


1.113
log
@Fix support for HTTP pipelining by handling all requests in the buffer.

Tested & OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.112 2017/01/31 14:39:47 reyk Exp $	*/
d219 21
a239 3
	while (!clt->clt_headersdone && (line =
	    evbuffer_readln(src, NULL, EVBUFFER_EOL_CRLF_STRICT)) != NULL) {
		linelen = strlen(line);
@


1.112
log
@Reimplement httpd's support for byte ranges.

The previous implementation loaded all the output into a single output
buffer and used its size to determine the Content-Length of the body.

The new implementation calculates the body length first and writes the
individual ranges in an async way using the bufferevent mechanism.

This prevents httpd from using too much memory and applies the
watermark and throttling mechanisms to range requests.

Problem reported by Pierre Kim (pierre.kim.sec at gmail.com)

OK benno@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.111 2017/01/31 12:21:27 reyk Exp $	*/
d1187 4
@


1.111
log
@The variable clt_done is used in too many places.

Introduce a new variable clt_headersdone in the async HTTP parser.

OK sunil@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.110 2016/08/26 10:46:39 rzalamena Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@@openbsd.org>
d607 95
@


1.110
log
@Replace the static env variables with a single global variable.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.109 2016/07/27 11:02:41 reyk Exp $	*/
d219 1
a219 1
	while (!clt->clt_done && (line =
d228 1
a228 1
			clt->clt_done = 1;
d363 1
a363 1
	if (clt->clt_done) {
d622 2
a624 1
	clt->clt_done = 0;
@


1.109
log
@According to RFC 7231 4.3.7, OPTIONS may have body. "Although this
specification does not define any use for such a payload, future
extensions to HTTP might use the OPTIONS body to make more detailed
queries about the target resource." The future has arrived.

Found and tested by Michael Lechtermann
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.108 2016/05/27 11:24:13 krw Exp $	*/
a51 2
static struct httpd	*env = NULL;

d56 1
a56 1
server_http(struct httpd *x_env)
a57 3
	if (x_env != NULL)
		env = x_env;

d433 1
a433 1
		server_response(env, clt);
@


1.108
log
@Return "400 Bad Request" instead of "500 Server Internal Error" for
requests lacking "HTTP/<version>".

This makes it more obvious that httpd(8) does not attempt to support
HTTP v0.9 (circa 1991), when "GET <url>\r\n" was valid.

ok millert@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.107 2016/05/22 19:20:03 jung Exp $	*/
a382 1
		case HTTP_METHOD_OPTIONS:
d388 1
@


1.107
log
@makes sure the value of the asprintf buffer is zeroed on error

from Hiltjo Posthuma

"do." deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.106 2016/03/08 09:33:15 florian Exp $	*/
d299 4
a302 2
			if (desc->http_version == NULL)
				goto fail;
@


1.106
log
@Set content charset for auto index generated page.
Pointed out and diff by dhill, thanks!
Tweaks and same change for error documents by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.105 2016/02/11 19:30:04 tim Exp $	*/
d829 2
a830 1
	    code, httperr, style, code, httperr, HTTPD_SERVERNAME)) == -1)
d832 1
d840 2
a841 1
		    "; preload" : "") == -1)
d843 1
@


1.105
log
@Back out previous; requested by jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.103 2015/12/07 20:30:17 mmcc Exp $	*/
d819 2
@


1.104
log
@Include the server port number in the common and combined logs. This is useful
to distinguish between http and https requests.

OK florian@@ reyk@@ a while ago
@
text
@d1507 3
a1509 3
		    "%s:%u %s - %s [%s] \"%s %s%s%s%s%s\" %03d %zu\n",
		    srv_conf->name, htons(srv_conf->port), ip,
		    clt->clt_remote_user == NULL ? "-" : user, tstamp,
d1554 1
a1554 1
		    "%s:%u %s - %s [%s] \"%s %s%s%s%s%s\""
d1556 2
a1557 2
		    srv_conf->name, htons(srv_conf->port), ip,
		    clt->clt_remote_user == NULL ? "-" : user, tstamp,
@


1.103
log
@No need to check for NULL before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.102 2015/12/03 11:46:25 reyk Exp $	*/
d1507 3
a1509 3
		    "%s %s - %s [%s] \"%s %s%s%s%s%s\" %03d %zu\n",
		    srv_conf->name, ip, clt->clt_remote_user == NULL ? "-" :
		    user, tstamp,
d1554 1
a1554 1
		    "%s %s - %s [%s] \"%s %s%s%s%s%s\""
d1556 2
a1557 2
		    srv_conf->name, ip, clt->clt_remote_user == NULL ? "-" :
		    user, tstamp,
@


1.102
log
@Remove unnecessary NULL checks before free().

From Jan Schreiber
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.101 2015/10/13 08:33:06 sunil Exp $	*/
d593 1
a593 2
		if (line != NULL)
			free(line);
@


1.101
log
@Plug a leak.

Ok gilles@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.100 2015/10/13 07:57:13 reyk Exp $	*/
d105 12
a116 20
	if (desc->http_path != NULL) {
		free(desc->http_path);
		desc->http_path = NULL;
	}
	if (desc->http_path_alias != NULL) {
		free(desc->http_path_alias);
		desc->http_path_alias = NULL;
	}
	if (desc->http_query != NULL) {
		free(desc->http_query);
		desc->http_query = NULL;
	}
	if (desc->http_version != NULL) {
		free(desc->http_version);
		desc->http_version = NULL;
	}
	if (desc->http_host != NULL) {
		free(desc->http_host);
		desc->http_host = NULL;
	}
@


1.100
log
@Pass unsigned chars to ctype functions.

From Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.99 2015/09/07 14:46:24 reyk Exp $	*/
d198 1
@


1.99
log
@Fix a regression that was introduced with server.c r1.64: Do NOT free
srv_conf->auth in serverconfig_free() because it was not allocated in
config_getserver() but assigned as a reference by id from a global
list that is maintained independently.  This fixes a potential
double-free.  This fix also makes srv_conf->auth "const" to emphasize
that the read-only auth pointer was not allocated here.

OK jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.98 2015/08/21 07:30:50 reyk Exp $	*/
d921 1
a921 1
		if (!isdigit(*(p + 1)))
@


1.98
log
@The WebDAV MOVE method was not included in the switch statement
handling the HTTP methods in server_http.c which resulted in a 405
method not allowed error when trying to use it.

Fix by jaminh on github
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.97 2015/08/20 13:00:23 reyk Exp $	*/
d137 1
a137 1
	struct auth		*auth = srv_conf->auth;
@


1.97
log
@Change httpd(8) to use C99-style fixed-width integers (uintN_t instead
of u_intN_t) and replace u_int with unsigned int.  Mixing both
variants is a bad style and most contributors seem to prefer this
style; it also helps us to get used to it, portability, and
standardization.

Theoretically no binary change, except one in practice: httpd.o has a
different checksum because gcc with -O2 pads/optimizes "struct
privsep" differently when using "unsigned int" instead "u_int" for the
affected members.  "u_int" is just a typedef of "unsigned int", -O0
doesn't build the difference and clang with -O2 doesn't do it either -
it is just another curiosity from gcc-land.

OK semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.96 2015/07/31 00:10:51 benno Exp $	*/
d391 1
@


1.96
log
@repair hsts header output, wrong format strings caused broken
Strict-Transport-Security headers. Add __format__ attribute to
kv_set() and kv_setkey() to make it easier to spot such problems.

Found by and fix from Donovan Watteau <tsoomi -AT- gmail -DOT- com>,
thanks for your help.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.95 2015/07/29 22:03:41 reyk Exp $	*/
d155 1
a155 1
	if (b64_pton(strchr(ba->kv_value, ' ') + 1, (u_int8_t *)decoded,
d736 1
a736 1
server_abort_http(struct client *clt, u_int code, const char *msg)
d1229 1
a1229 1
server_response_http(struct client *clt, u_int code,
d1400 1
a1400 1
server_httpmethod_byid(u_int id)
d1429 1
a1429 1
server_httperror_byid(u_int id)
d1453 1
a1453 1
server_log_http(struct client *clt, u_int code, size_t len)
@


1.95
log
@backout the previous:  it broke wordpress somehow.
we need more care to find a proper fix for the fastcgi headers.

acknowledged by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.94 2015/07/29 20:03:14 florian Exp $	*/
d1247 1
a1247 1
	if (kv_setkey(&resp->http_pathquery, "%lu", code) == -1 ||
d1284 1
a1284 1
		    kv_set(cl, "max-age=%d%s%s%s", srv_conf->hsts_max_age,
@


1.94
log
@Read fcgi response records until we have the whole http header and can
parse it. Otherwise http headers can leak into the body.
Pointed out by Jean-Philippe Ouellet on bugs@@ Thanks!
OK reyk, commit ASAP deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.93 2015/07/23 09:36:32 semarie Exp $	*/
a634 1
	clt->clt_fcgi_http_header_state = FCGI_HTTP_HEADER_UNREAD;
@


1.93
log
@The realm in authenticate directive of config file isn't escaped for '"' char.
The diff corrects this problem by using VIS_DQ.

ok reyk@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.92 2015/07/19 05:17:27 reyk Exp $	*/
d635 1
@


1.92
log
@For the completeness of HSTS, add the non-standard preload option.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.91 2015/07/18 06:00:43 reyk Exp $	*/
d745 1
d786 6
a791 2
		if (asprintf(&extraheader,
		    "WWW-Authenticate: Basic realm=\"%s\"\r\n", msg) == -1) {
d813 2
@


1.91
log
@Allow to change the default media type globally or per-location,
eg. default type text/html.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.90 2015/07/18 05:41:19 florian Exp $	*/
d832 5
a836 3
		    "max-age=%d%s\r\n", srv_conf->hsts_max_age,
		    srv_conf->hsts_subdomains == 0 ? "" : 
		    " ; includeSubDomains") == -1)
d1277 5
a1281 3
		    kv_set(cl, "max-age=%d%s", srv_conf->hsts_max_age,
		    srv_conf->hsts_subdomains == 0 ? "" :
		    " ; includeSubDomains") == -1)
@


1.90
log
@Implement HTTP Strict Transport Security (HSTS).
Input & OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.89 2015/07/16 19:05:28 reyk Exp $	*/
d1230 2
a1231 1
	if (desc == NULL || (error = server_httperror_byid(code)) == NULL)
d1256 1
a1256 3
	    kv_set(ct, "%s/%s",
	    media == NULL ? "application" : media->media_type,
	    media == NULL ? "octet-stream" : media->media_subtype) == -1)
@


1.89
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.88 2015/07/15 23:16:38 reyk Exp $	*/
d738 1
a738 2
	struct server		*srv = clt->clt_srv;
	struct server_config	*srv_conf = &srv->srv_conf;
d743 1
a743 1
	char			 tmbuf[32], hbuf[128];
d830 8
d847 1
d852 1
d863 1
d1223 1
d1270 11
@


1.88
log
@Escape the message in server_log() as well.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.87 2015/07/15 22:23:00 reyk Exp $	*/
d1011 1
a1011 1
			if ((str = url_encode(srv_conf->name)) 
d1542 1
a1542 1
	       
d1552 2
a1553 2
		    	desc->http_path == NULL ? "" : path);
	       
@


1.87
log
@For some values like the User-Agent, use vis(3) instead of url_encode().
This makes the output more readable and matches Apache's log encoding.

OK sthen@@ brynet@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.86 2015/07/15 17:52:23 reyk Exp $	*/
a1424 1
	static const int	 vis_http = VIS_NL|VIS_TAB|VIS_CSTYLE;
d1467 1
a1467 1
		    stravis(&user, clt->clt_remote_user, vis_http) == -1)
d1470 1
a1470 1
		    stravis(&version, desc->http_version, vis_http) == -1)
d1508 1
a1508 1
		    stravis(&user, clt->clt_remote_user, vis_http) == -1)
d1511 1
a1511 1
		    stravis(&version, desc->http_version, vis_http) == -1)
d1514 1
a1514 1
		    stravis(&agent_v, agent->kv_value, vis_http) == -1)
@


1.86
log
@Simplify the error path of the previous commit: by using ret = -1 by
default and only setting it to 0 on success, we don't have to set it
in each error case.  While here, also remove two superfluous NULL
checks (as pointed out by semarie).

OK semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.85 2015/07/15 16:02:38 semarie Exp $	*/
d38 1
d1425 1
d1466 1
d1468 4
a1471 1
		    (user = url_encode(clt->clt_remote_user)) == NULL)
d1474 1
a1477 1

a1481 4
		if (desc->http_version &&
		    (version = url_encode(desc->http_version)) == NULL)
			goto done;

d1507 1
d1509 7
a1515 1
		    (user = url_encode(clt->clt_remote_user)) == NULL)
d1518 1
a1521 1

a1524 5

		if (desc->http_version &&
		    (version = url_encode(desc->http_version)) == NULL)
			goto done;

a1528 4
		if (agent &&
		    (agent_v = url_encode(agent->kv_value)) == NULL)
			goto done;

d1547 1
@


1.85
log
@httpd don't sanitize variables before putting them in logs. It is possible for
an attacker to push arbitaries characters in logs (newline for forging entries,
or some control escaping interpreted by terminal emulator).

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.84 2015/06/23 17:25:01 semarie Exp $	*/
d1429 1
a1429 1
	int			 ret = 0;
d1465 1
a1465 2
		    (user = url_encode(clt->clt_remote_user)) == NULL) {
			ret = -1;
a1466 1
		}
d1469 1
a1469 2
		    (path = url_encode(desc->http_path)) == NULL) {
			ret = -1;
a1470 1
		}
d1473 1
a1473 2
		    (query = url_encode(desc->http_query)) == NULL) {
			ret = -1;
a1474 1
		}
d1477 1
a1477 2
		    (version = url_encode(desc->http_version)) == NULL) {
			ret = -1;
a1478 1
		}
d1506 1
a1506 2
		    (user = url_encode(clt->clt_remote_user)) == NULL) {
			ret = -1;
a1507 1
		}
d1510 1
a1510 2
		    (path = url_encode(desc->http_path)) == NULL) {
			ret = -1;
a1511 1
		}
d1514 1
a1514 2
		    (query = url_encode(desc->http_query)) == NULL) {
			ret = -1;
a1515 1
		}
d1518 1
a1518 2
		    (version = url_encode(desc->http_version)) == NULL) {
			ret = -1;
a1519 1
		}
d1521 2
a1522 3
		if (referrer && referrer->kv_value &&
		    (referrer_v = url_encode(referrer->kv_value)) == NULL) {
			ret = -1;
a1523 1
		}
d1525 2
a1526 3
		if (agent && agent->kv_value &&
		    (agent_v = url_encode(agent->kv_value)) == NULL) {
			ret = -1;
a1527 1
		}
d1548 1
a1548 2
		    (path = url_encode(desc->http_path)) == NULL) {
			ret = -1;
a1549 1
		}
@


1.84
log
@escape the matched substrings before using it in expansion.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.83 2015/06/23 15:23:14 reyk Exp $	*/
d1429 7
d1464 25
a1488 1
		if (evbuffer_add_printf(clt->clt_log,
d1491 1
a1491 1
		    clt->clt_remote_user, tstamp,
d1493 1
a1493 1
		    desc->http_path == NULL ? "" : desc->http_path,
d1495 1
a1495 1
		    desc->http_query == NULL ? "" : desc->http_query,
d1497 3
a1499 3
		    desc->http_version == NULL ? "" : desc->http_version,
		    code, len) == -1)
			return (-1);
d1513 37
a1549 1
		if (evbuffer_add_printf(clt->clt_log,
d1553 1
a1553 1
		    clt->clt_remote_user, tstamp,
d1555 1
a1555 1
		    desc->http_path == NULL ? "" : desc->http_path,
d1557 1
a1557 1
		    desc->http_query == NULL ? "" : desc->http_query,
d1559 1
a1559 1
		    desc->http_version == NULL ? "" : desc->http_version,
d1561 3
a1563 3
		    referrer == NULL ? "" : referrer->kv_value,
		    agent == NULL ? "" : agent->kv_value) == -1)
			return (-1);
d1567 9
a1575 3
		if (evbuffer_add_printf(clt->clt_log, " [%s]",
		    desc->http_path == NULL ? "" : desc->http_path) == -1)
			return (-1);
d1579 9
a1587 1
	return (0);
@


1.83
log
@Add initial support for pattern matching using Lua's pattern matching code.

With important help on the pattern matcher from semarie@@

OK semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.82 2015/06/22 11:46:06 reyk Exp $	*/
d914 5
a918 2
		if (expand_string(buf, len, ibuf,
		    clt->clt_srv_match.sm_match[n]) != 0)
@


1.82
log
@After the last change, we also have to url_encode $SERVER_NAME and
$REMOTE_USER before using them in the Location.

From Sebastien Marie (semarie)
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.81 2015/06/21 13:08:36 reyk Exp $	*/
d32 1
d37 1
a37 1
#include <fnmatch.h>
d41 1
d638 1
d879 2
d890 3
a892 1
	int			 ret;
d897 21
d1030 2
a1031 1
	int			 portval = -1;
d1033 1
d1093 11
a1103 3
			if ((srv_conf->flags & SRVFLAG_LOCATION) == 0 &&
			    fnmatch(srv_conf->name, hostname,
			    FNM_CASEFOLD) == 0 &&
d1173 2
d1185 14
a1198 5
		    location->parent_id == srv_conf->parent_id &&
		    fnmatch(location->location, path, FNM_CASEFOLD) == 0) {
			/* Replace host configuration */
			clt->clt_srv_conf = srv_conf = location;
			break;
@


1.81
log
@When encoding the Location url, only encode the query and path
elements from the user input and not the constants from the
configuration.  This makes it possible to specify chars like '?' in
the uri.

OK Sebastien Marie
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.80 2015/05/20 09:28:47 kettenis Exp $	*/
d928 9
a936 6
			    clt->clt_remote_user != NULL)
				str = clt->clt_remote_user;
			else
				str = "";
			if (expand_string(buf, len,
			    "$REMOTE_USER", str) != 0)
d979 6
a984 2
			if (expand_string(buf, len,
			    "$SERVER_NAME", srv_conf->name) != 0)
@


1.80
log
@Use off_t instead of size_t to pass file size and print it using %lld when
constructing the Content-Length header field.  Should fix some, but probably
not all, problems with serving files bigger than 2G on 32-bit architectures.

ok reyk@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.79 2015/05/03 18:39:58 florian Exp $	*/
d741 1
a741 1
	char			 buf[IBUF_READ_SIZE], *ptr = NULL;
d773 1
a773 2
		if ((ptr = server_expand_http(clt, msg,
		    buf, sizeof(buf))) == NULL)
d775 1
a775 3
		if ((ptr = url_encode(ptr)) == NULL)
			goto done;
		if (asprintf(&extraheader, "Location: %s\r\n", ptr) == -1) {
d779 1
a779 1
		msg = ptr;
a857 1
	free(ptr);
d884 2
a885 1
	char			 ibuf[128], *str;
d891 5
a895 2
		if (expand_string(buf, len, "$DOCUMENT_URI",
		    desc->http_path) != 0)
d899 9
a907 3
		if (expand_string(buf, len, "$QUERY_STRING",
		    desc->http_query == NULL ? "" :
		    desc->http_query) != 0)
d938 2
d941 10
a950 1
			if ((str = strdup(desc->http_path)) == NULL)
a951 6
		} else if (asprintf(&str, "%s?%s",
		    desc->http_path, desc->http_query) == -1)
			return (NULL);
		if (expand_string(buf, len, "$REQUEST_URI", str) != 0) {
			free(str);
			return (NULL);
d953 2
d956 2
@


1.79
log
@Implement byte ranges.
From Sunil Nimmagadda <sunil At nimmagadda DOT net>
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.78 2015/04/18 09:27:54 jsg Exp $	*/
d1136 1
a1136 1
    struct media_type *media, size_t size, time_t mtime)
d1177 1
a1177 1
	    kv_set(cl, "%ld", size) == -1)
@


1.78
log
@Regis Leroy reported that httpd does not strictly accept CRLF for
newlines which could lead to http response splitting/smuggling
if a badly behaved proxy is in front of httpd.

Switch from evbuffer_readline() to evbuffer_readln() with
EVBUFFER_EOL_CRLF_STRICT to avoid this.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.77 2015/04/09 16:48:29 florian Exp $	*/
d787 7
@


1.77
log
@Revert previous as this breaks stuff.
I fscked up the testing, sorry!
Found the hard way by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.76 2015/04/08 19:39:29 florian Exp $	*/
d228 2
a229 1
	while (!clt->clt_done && (line = evbuffer_readline(src)) != NULL) {
d540 1
a540 1
		line = evbuffer_readline(src);
d575 1
a575 1
		line = evbuffer_readline(src);
d595 1
a595 1
		line = evbuffer_readline(src);
@


1.76
log
@Do not silently accept multiple Content-Length headers.
Pointed out by Regis Leroy (regis.leroy AT makina-corpus DOT com),
thanks!
Tweak and OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.75 2015/02/23 18:43:18 reyk Exp $	*/
a341 5
			if (clt->clt_toread != 0) {
				/* We already read Content-Length */
				server_abort_http(clt, 400, errstr);
				goto abort;
			}
@


1.75
log
@Allow to specify CGI variables as macros in redirection strings, eg.
block return 301 "http://www.example.com/$REQUEST_URI"

OK tedu@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.74 2015/02/08 00:00:59 reyk Exp $	*/
d342 5
@


1.74
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.73 2015/02/07 23:59:28 reyk Exp $	*/
d45 3
a47 1
    struct client *);
d740 1
d768 10
a777 1
		if (asprintf(&extraheader, "Location: %s\r\n", msg) == -1) {
d781 1
d845 2
d853 1
d872 88
@


1.73
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.72 2015/02/07 01:23:12 reyk Exp $	*/
d1297 2
a1298 1
		    "%s %s - %s [%s] \"%s %s%s%s%s%s\" %03d %zu \"%s\" \"%s\"\n",
@


1.72
log
@Add support for blocking, dropping, and redirecting requests.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.71 2015/02/06 13:05:20 reyk Exp $	*/
d129 10
a138 9
	FILE *fp = NULL;
	struct http_descriptor *desc = clt->clt_descreq;
	struct auth *auth = srv_conf->auth;
	struct kv *ba, key;
	size_t linesize = 0;
	ssize_t linelen;
	int ret = -1;
	char *line = NULL, decoded[1024];
	char *clt_user = NULL, *clt_pass = NULL, *user = NULL, *pass = NULL;
d150 1
a150 1
	if (b64_pton(strchr(ba->kv_value, ' ') + 1, decoded,
@


1.71
log
@Fix log options in locations.

Reported and tested by Markus Bergkvist
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.70 2015/02/05 10:47:53 reyk Exp $	*/
d739 5
d965 5
a969 1
	if (srv_conf->flags & SRVFLAG_AUTH &&
@


1.70
log
@Fix potential NULL pointer dereference.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.69 2015/01/21 22:21:05 reyk Exp $	*/
d620 2
a631 2

	server_log(clt, NULL);
d1001 1
a1001 1
		    location->id == srv_conf->id &&
@


1.69
log
@httpd is based on relayd and had included many headers that are only
needed by its ancestor.  jsg@@, include-what-you-use, and some manual
review helped to cleanup the headers (take iwyu with a grain of salt).
Based on common practice, httpd.h now also includes the necessary
headers for itself.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.68 2015/01/19 20:01:02 florian Exp $	*/
d1202 1
a1202 1
	struct http_error	 error, *res = NULL;
d1207 1
a1207 1
	res = bsearch(&error, http_errors,
d1209 2
a1210 1
	    sizeof(http_errors[0]), server_httperror_cmp);
d1212 1
a1212 1
	return (res->error_name);
@


1.68
log
@Log the remote user in the access.log.
Pointed out by, tweak & OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.67 2015/01/19 20:00:07 florian Exp $	*/
a20 2
#include <sys/time.h>
#include <sys/stat.h>
a21 1
#include <sys/un.h>
a23 1
#include <net/if.h>
d25 1
a25 2
#include <netinet/ip.h>
#include <netinet/tcp.h>
a27 1
#include <fcntl.h>
d33 1
a33 2
#include <err.h>
#include <pwd.h>
a34 1
#include <syslog.h>
@


1.67
log
@s/clt_fcgi_remote_user/clt_remote_user/
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.66 2015/01/19 19:37:50 reyk Exp $	*/
d166 2
d195 1
a195 3
			clt->clt_remote_user = strdup(clt_user);
			if (clt->clt_remote_user != NULL)
				ret = 0;
d1269 3
a1271 2
		    "%s %s - - [%s] \"%s %s%s%s%s%s\" %03d %zu\n",
		    srv_conf->name, ip, tstamp,
d1294 3
a1296 2
		    "%s %s - - [%s] \"%s %s%s%s%s%s\" %03d %zu \"%s\" \"%s\"\n",
		    srv_conf->name, ip, tstamp,
@


1.66
log
@Decouple auth parameters from struct server_config into struct auth.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.65 2015/01/18 14:01:17 florian Exp $	*/
d193 2
a194 2
			clt->clt_fcgi_remote_user = strdup(clt_user);
			if (clt->clt_fcgi_remote_user != NULL)
d634 2
a635 2
	free(clt->clt_fcgi_remote_user);
	clt->clt_fcgi_remote_user = NULL;
d856 2
a857 2
	free(clt->clt_fcgi_remote_user);
	clt->clt_fcgi_remote_user = NULL;
@


1.65
log
@First stab at implementing basic auth.
Currently the htpasswd file needs to be in the chroot; will hopefully
improved soonish.
Based on a diff from Oscar Linderholm many months ago but turned into
a complete rewrite.
input/OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.64 2015/01/16 06:40:17 deraadt Exp $	*/
d139 1
d170 1
a170 1
	if ((fp = fopen(srv_conf->auth_htpasswd, "r")) == NULL)
d968 1
a968 1
	if (srv_conf->flags & SRVFLAG_AUTH_BASIC &&
@


1.64
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.63 2015/01/13 09:21:15 reyk Exp $	*/
d41 1
d52 2
d134 76
d633 2
d771 7
d855 2
d967 6
a972 1
	return (server_file(httpd, clt));
@


1.63
log
@bump copyright year
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.62 2015/01/06 17:48:04 reyk Exp $	*/
d37 1
d575 1
a575 1
	char		hbuf[MAXHOSTNAMELEN];
d772 2
a773 2
	char			 path[MAXPATHLEN];
	char			 hostname[MAXHOSTNAMELEN];
@


1.62
log
@I missed one goto abort instead of free(line).

Found by Fabian Raetz at gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.61 2015/01/06 13:48:15 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 - 2014 Reyk Floeter <reyk@@openbsd.org>
@


1.61
log
@Instead of calling free(line) in each error case, call it once in fail:.

From Fabian Raetz at gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.60 2015/01/06 13:38:59 reyk Exp $	*/
a168 1
			free(line);
d170 1
a170 1
			return;
@


1.60
log
@Return "400 Bad Request" instead of "500 Internal Server Error" for
unknown/invalid HTTP requests.

From Fabian Raetz at gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.59 2015/01/04 22:23:58 chrisz Exp $	*/
a186 1
				free(line);
d188 1
a188 1
				return;
d193 1
a193 2
			    desc->http_lastheader, line) == NULL) {
				free(line);
a194 1
			}
d223 1
a223 2
			if (desc->http_path == NULL) {
				free(line);
d225 1
a225 1
			}
d227 1
a227 2
			if (desc->http_version == NULL) {
				free(line);
d229 1
a229 1
			}
d240 1
a240 2
			    strdup(desc->http_version)) == NULL) {
				free(line);
d242 1
a242 1
			}
d245 1
a245 2
			    strdup(desc->http_query)) == NULL) {
				free(line);
d247 1
a247 1
			}
d286 1
a286 2
			    value)) == NULL) {
				free(line);
d288 1
a288 1
			}
a375 1
	return;
@


1.59
log
@add new url stripping option:

strip number
	Strip number path components from the beginning of the
	request URI before looking up the stripped-down URI at
	the document root.


reviewed with much patience and OK by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.58 2015/01/01 14:15:02 reyk Exp $	*/
d217 4
a220 2
			    == HTTP_METHOD_NONE)
				goto fail;
@


1.58
log
@Use the HTML5 doctype for error and auto index pages because it is
shorter, newer, and the recommendation.  From James Jerkins.

Exclude the charset for now because it is not explicitly handled by httpd.

OK validator.w3.org (This document was successfully checked as HTML5!)
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.57 2014/12/21 00:54:49 guenther Exp $	*/
d888 15
@


1.57
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.56 2014/12/08 19:31:27 florian Exp $	*/
d715 1
a715 2
	    "<!DOCTYPE HTML PUBLIC "
	    "\"-//W3C//DTD HTML 4.01 Transitional//EN\">\n"
@


1.56
log
@Do not send an error body in a HEAD request answer.
From Bertrand Janin (b at janin dot com), thanks!
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.55 2014/12/04 02:44:42 tedu Exp $	*/
a30 1
#include <arpa/inet.h>
@


1.55
log
@stop viral header propagation. none of this code uses sys/hash.h
from Max Fillinger
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.54 2014/10/25 03:23:49 lteo Exp $	*/
d667 3
a669 2
	const char		*httperr = NULL, *text = "";
	char			*httpmsg, *extraheader = NULL;
d671 1
a671 1
	const char		*style;
d713 3
a715 9
	/* Generate simple HTTP+HTML error document */
	if (asprintf(&httpmsg,
	    "HTTP/1.0 %03d %s\r\n"
	    "Date: %s\r\n"
	    "Server: %s\r\n"
	    "Connection: close\r\n"
	    "Content-Type: text/html\r\n"
	    "%s"
	    "\r\n"
a724 1
	    "<div id='m'>%s</div>\n"
d728 15
a742 1
	    code, httperr, tmbuf, HTTPD_SERVERNAME,
d744 1
a744 2
	    code, httperr, style, code, httperr, text,
	    HTTPD_SERVERNAME) == -1)
d752 1
@


1.54
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.53 2014/10/22 09:48:03 reyk Exp $	*/
a25 1
#include <sys/hash.h>
@


1.53
log
@URL-decode the request path.

Tested by ajacoutot@@ and others
OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.52 2014/10/21 13:00:33 reyk Exp $	*/
a28 1
#include <netinet/in_systm.h>
@


1.52
log
@Rework the error message a little bit: Do not send details of the
error.  Traditionally, web servers responsed with the request path on
40x errors which could be abused to inject JavaScript etc.  Instead of
sanitizing the path, we just don't reprint it.  Also modify the style
a little bit but keep Comic Sans.

With input from Jonas Lindemann and doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.51 2014/09/29 19:30:47 deraadt Exp $	*/
d787 1
@


1.51
log
@whitespace spotted while studying the code
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.50 2014/09/15 08:00:27 reyk Exp $	*/
a691 3
	case 500:
		/* Do not send details of the Internal Server Error */
		break;
d700 7
a706 1
		text = msg;
d712 2
a713 1
	    "'Comic Sans MS', 'Chalkboard SE', 'Comic Neue', sans-serif; }";
d731 1
a731 1
	    "<h1>%s</h1>\n"
d733 1
a733 1
	    "<hr><address>%s at %s port %d</address>\n"
d738 2
a739 2
	    code, httperr, style, httperr, text,
	    HTTPD_SERVERNAME, hbuf, ntohs(srv_conf->port)) == -1)
@


1.50
log
@Make the HTTP version mandatory and abort if it is missing in the request.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.49 2014/09/10 15:39:57 reyk Exp $	*/
d343 1
a343 1
 		case HTTP_METHOD_ORDERPATCH:
d557 1
a557 1
	
@


1.49
log
@Handle different possible variations of the Host header (eg.
www.example.com, www.example.com:80, [2001:db8::1], [2001:db8::1]:80).
The port is optional and is typically used on non-default ports.  If
the server name is a plain IPv6 address, it is commonly specified in
square brackets.

Makes ajacoutot@@ happy
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.48 2014/09/05 15:06:05 reyk Exp $	*/
d232 5
a236 2
			if (desc->http_version != NULL)
				*desc->http_version++ = '\0';
d243 1
a243 1
			 * be changed independetly by the filters later.
d245 1
a245 2
			if (desc->http_version != NULL &&
			    (desc->http_version =
@


1.48
log
@Add various RFC-based WebDAV methods to the list of accepted HTTP methods.
This fixes (Fast)CGI-based WebDAV and CalDAV (calendar) servers with httpd.

ok benno@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.47 2014/09/05 10:04:20 reyk Exp $	*/
d612 49
d776 2
d822 4
a825 1
		/* XXX maybe better to turn srv_hosts into a tree */
d829 5
a833 2
				DPRINTF("%s: virtual host \"%s\" host \"%s\"",
				    __func__, srv_conf->name, host->kv_value);
d837 4
a840 2
			    fnmatch(srv_conf->name, host->kv_value,
			    FNM_CASEFOLD) == 0) {
@


1.47
log
@Remove a limitation that only allowed to specify a server name once.
The key has been changed to server name + address + port and now it is
possible to use the same server name for multiple servers with
different addresses, eg. http://www.example.com and
https://www.example.com/.

OK doug@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.46 2014/08/29 13:01:46 reyk Exp $	*/
d317 2
d324 23
d358 2
a359 4
			/* HTTP handler */
			clt->clt_toread = TOREAD_HTTP_HEADER;
			bev->readcb = server_read_http;
			break;
d1007 1
a1007 1
	const char	*name = NULL;
@


1.46
log
@Use two instead of one http descriptor for request and response.

OK chrisz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.45 2014/08/21 19:23:10 chrisz Exp $	*/
d750 6
d805 6
@


1.45
log
@Add Last-Modified: HTTP header.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.44 2014/08/08 18:29:42 reyk Exp $	*/
d89 2
d92 4
d97 1
a97 1
	clt->clt_desc = desc;
d105 2
d129 2
d138 1
a138 1
	struct http_descriptor	*desc = clt->clt_desc;
a530 1
	struct http_descriptor	*desc = clt->clt_desc;
d532 3
a534 4

	server_httpdesc_free(desc);
	desc->http_method = 0;
	desc->http_chunked = 0;
d681 1
a681 1
	struct http_descriptor *desc	= clt->clt_desc;
d683 6
a688 2
	if (desc == NULL)
		return;
d691 1
d699 2
a700 1
	struct http_descriptor	*desc	= clt->clt_desc;
d777 5
d815 2
a816 1
	struct http_descriptor	*desc = clt->clt_desc;
a826 2
	kv_purge(&desc->http_headers);

d828 2
a829 2
	if (kv_setkey(&desc->http_pathquery, "%lu", code) == -1 ||
	    kv_set(&desc->http_pathquery, "%s", error) == -1)
d833 1
a833 1
	if (kv_add(&desc->http_headers, "Server", HTTPD_SERVERNAME) == NULL)
d838 1
a838 1
		if (kv_add(&desc->http_headers,
d841 1
a841 1
	} else if (kv_add(&desc->http_headers, "Connection", "close") == NULL)
d845 1
a845 1
	if ((ct = kv_add(&desc->http_headers, "Content-Type", NULL)) == NULL ||
d853 1
a853 1
	    kv_add(&desc->http_headers, "Content-Length", NULL)) == NULL ||
d859 1
a859 1
	    kv_add(&desc->http_headers, "Last-Modified", tmbuf) == NULL)
d864 1
a864 1
	    kv_add(&desc->http_headers, "Date", tmbuf) == NULL)
d870 1
a870 1
	    server_headers(clt, server_writeheader_http, NULL) == -1 ||
d874 1
a874 1
	if (size == 0 || desc->http_method == HTTP_METHOD_HEAD) {
d890 1
a890 1
	struct http_descriptor	*desc = (struct http_descriptor *)clt->clt_desc;
d934 1
a934 1
server_headers(struct client *clt,
d938 1
a938 1
	struct http_descriptor	*desc = (struct http_descriptor *)clt->clt_desc;
d1036 1
a1036 1
	if ((desc = clt->clt_desc) == NULL)
@


1.44
log
@When opening directories, re-match the location after the index file
has been appended.  This allows to use a fastcgi target as the default
index, for example index.php.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.43 2014/08/08 15:46:01 reyk Exp $	*/
d537 2
a538 2
void
server_http_date(char *tmbuf, size_t len)
a539 1
	time_t			 t;
d543 4
a546 3
	time(&t);
	gmtime_r(&t, &tm);
	strftime(tmbuf, len, "%a, %d %h %Y %T %Z", &tm);
d605 2
a606 1
	server_http_date(tmbuf, sizeof(tmbuf));
d794 1
a794 1
    struct media_type *media, size_t size)
d839 8
a846 3
	/* Date header is mandatory and should be added last */
	server_http_date(tmbuf, sizeof(tmbuf));
	if (kv_add(&desc->http_headers, "Date", tmbuf) == NULL)
@


1.43
log
@Allow to serve emtpy (0 bytes) files.

Found by jasper@@
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.42 2014/08/06 18:21:14 reyk Exp $	*/
d103 4
d687 1
a687 1
	struct server_config	*srv_conf = &srv->srv_conf, *location;
d763 15
d781 1
a781 2
		    fnmatch(location->location, desc->http_path,
		    FNM_CASEFOLD) == 0) {
d788 1
a788 6
	if (srv_conf->flags & SRVFLAG_FCGI)
		return (server_fcgi(httpd, clt));
	return (server_file(httpd, clt));
 fail:
	server_abort_http(clt, 400, "bad request");
	return (-1);
@


1.42
log
@Limit the body size in client requests (eg. POST data) to 1M by default;
add a configuration option to change the limit.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.41 2014/08/06 15:08:04 florian Exp $	*/
d820 1
a820 1
	if (size && ((cl =
d822 1
a822 1
	    kv_set(cl, "%ld", size) == -1))
d837 1
a837 1
	if (desc->http_method == HTTP_METHOD_HEAD) {
@


1.42.2.1
log
@httpd was developed very rapidly in the weeks before 5.6 release,
and it has a few flaws.  It would be nice to get these flaws fully
remediated before the next release, and that requires the community
to want to use it.
Therefore here is a "jumbo" patch that brings in the most important fixes.

committing on behalf of reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.42 2014/08/06 18:21:14 reyk Exp $	*/
a88 2
	RB_INIT(&desc->http_headers);
	clt->clt_descreq = desc;
a89 4
	if ((desc = calloc(1, sizeof(*desc))) == NULL) {
		/* req will be cleaned up later */
		return (-1);
	}
d91 1
a91 1
	clt->clt_descresp = desc;
a98 2
	if (desc == NULL)
		return;
a102 4
	if (desc->http_path_alias != NULL) {
		free(desc->http_path_alias);
		desc->http_path_alias = NULL;
	}
a116 2
	desc->http_method = 0;
	desc->http_chunked = 0;
d124 1
a124 1
	struct http_descriptor	*desc = clt->clt_descreq;
d218 2
a219 5
			if (desc->http_version == NULL) {
				free(line);
				goto fail;
			}
			*desc->http_version++ = '\0';
d226 1
a226 1
			 * be changed independently by the filters later.
d228 2
a229 1
			if ((desc->http_version =
a302 2
		/* WebDAV methods */
		case HTTP_METHOD_COPY:
a307 23
		/* WebDAV methods */
		case HTTP_METHOD_PROPFIND:
		case HTTP_METHOD_PROPPATCH:
		case HTTP_METHOD_MKCOL:
		case HTTP_METHOD_LOCK:
		case HTTP_METHOD_UNLOCK:
		case HTTP_METHOD_VERSION_CONTROL:
		case HTTP_METHOD_REPORT:
		case HTTP_METHOD_CHECKOUT:
		case HTTP_METHOD_CHECKIN:
		case HTTP_METHOD_UNCHECKOUT:
		case HTTP_METHOD_MKWORKSPACE:
		case HTTP_METHOD_UPDATE:
		case HTTP_METHOD_LABEL:
		case HTTP_METHOD_MERGE:
		case HTTP_METHOD_BASELINE_CONTROL:
		case HTTP_METHOD_MKACTIVITY:
		case HTTP_METHOD_ORDERPATCH:
		case HTTP_METHOD_ACL:
		case HTTP_METHOD_MKREDIRECTREF:
		case HTTP_METHOD_UPDATEREDIRECTREF:
		case HTTP_METHOD_SEARCH:
		case HTTP_METHOD_PATCH:
d319 4
a322 2
			server_abort_http(clt, 405, "method not allowed");
			return;
d517 1
d520 3
a522 2
	server_httpdesc_free(clt->clt_descreq);
	server_httpdesc_free(clt->clt_descresp);
d533 2
a534 2
ssize_t
server_http_time(time_t t, char *tmbuf, size_t len)
d536 1
d540 3
a542 4
	if (t == -1 || gmtime_r(&t, &tm) == NULL)
		return (-1);
	else
		return (strftime(tmbuf, len, "%a, %d %h %Y %T %Z", &tm));
a576 49
char *
server_http_parsehost(char *host, char *buf, size_t len, int *portval)
{
	char		*start, *end, *port;
	const char	*errstr = NULL;

	if (strlcpy(buf, host, len) >= len) {
		log_debug("%s: host name too long", __func__);
		return (NULL);
	}

	start = buf;
	end = port = NULL;

	if (*start == '[' && (end = strchr(start, ']')) != NULL) {
		/* Address enclosed in [] with port, eg. [2001:db8::1]:80 */
		start++;
		*end++ = '\0';
		if ((port = strchr(end, ':')) == NULL || *port == '\0')
			port = NULL;
		else
			port++;
		memmove(buf, start, strlen(start) + 1);
	} else if ((end = strchr(start, ':')) != NULL) {
		/* Name or address with port, eg. www.example.com:80 */
		*end++ = '\0';
		port = end;
	} else {
		/* Name or address with default port, eg. www.example.com */
		port = NULL;
	}

	if (port != NULL) {
		/* Save the requested port */
		*portval = strtonum(port, 0, 0xffff, &errstr);
		if (errstr != NULL) {
			log_debug("%s: invalid port: %s", __func__,
			    strerror(errno));
			return (NULL);
		}
		*portval = htons(*portval);
	} else {
		/* Port not given, indicate the default port */
		*portval = -1;
	}

	return (start);
}

d601 1
a601 2
	if (server_http_time(time(NULL), tmbuf, sizeof(tmbuf)) <= 0)
		goto done;
d605 3
d616 1
d668 1
a668 1
	struct http_descriptor *desc;
d670 2
a671 6
	desc = clt->clt_descreq;
	server_httpdesc_free(desc);
	free(desc);
	clt->clt_descreq = NULL;

	desc = clt->clt_descresp;
a673 1
	clt->clt_descresp = NULL;
d681 1
a681 2
	struct http_descriptor	*desc = clt->clt_descreq;
	struct http_descriptor	*resp = clt->clt_descresp;
d683 1
a683 1
	struct server_config	*srv_conf = &srv->srv_conf;
a684 2
	int			 portval = -1;
	char			*hostval;
a687 1
	    url_decode(desc->http_path) == NULL ||
d729 1
a729 4
		if ((hostval = server_http_parsehost(host->kv_value,
		    hostname, sizeof(hostname), &portval)) == NULL)
			goto fail;

d732 2
a733 4
			    fnmatch(srv_conf->name, hostname,
			    FNM_CASEFOLD) == 0 &&
			    (portval == -1 ||
			    (portval != -1 && portval == srv_conf->port))) {
a757 20
	/* Now fill in the mandatory parts of the response descriptor */
	resp->http_method = desc->http_method;
	if ((resp->http_version = strdup(desc->http_version)) == NULL)
		goto fail;

	/* Now search for the location */
	srv_conf = server_getlocation(clt, desc->http_path);

	return (server_file(httpd, clt));
 fail:
	server_abort_http(clt, 400, "bad request");
	return (-1);
}

struct server_config *
server_getlocation(struct client *clt, const char *path)
{
	struct server		*srv = clt->clt_srv;
	struct server_config	*srv_conf = clt->clt_srv_conf, *location;

d762 2
a763 1
		    fnmatch(location->location, path, FNM_CASEFOLD) == 0) {
d770 6
a775 1
	return (srv_conf);
d780 1
a780 1
    struct media_type *media, size_t size, time_t mtime)
d782 1
a782 2
	struct http_descriptor	*desc = clt->clt_descreq;
	struct http_descriptor	*resp = clt->clt_descresp;
d793 2
d796 2
a797 2
	if (kv_setkey(&resp->http_pathquery, "%lu", code) == -1 ||
	    kv_set(&resp->http_pathquery, "%s", error) == -1)
d801 1
a801 1
	if (kv_add(&resp->http_headers, "Server", HTTPD_SERVERNAME) == NULL)
d806 1
a806 1
		if (kv_add(&resp->http_headers,
d809 1
a809 1
	} else if (kv_add(&resp->http_headers, "Connection", "close") == NULL)
d813 1
a813 1
	if ((ct = kv_add(&resp->http_headers, "Content-Type", NULL)) == NULL ||
d820 3
a822 8
	if ((cl =
	    kv_add(&resp->http_headers, "Content-Length", NULL)) == NULL ||
	    kv_set(cl, "%ld", size) == -1)
		return (-1);

	/* Set last modification time */
	if (server_http_time(mtime, tmbuf, sizeof(tmbuf)) <= 0 ||
	    kv_add(&resp->http_headers, "Last-Modified", tmbuf) == NULL)
d825 3
a827 3
	/* Date header is mandatory and should be added as late as possible */
	if (server_http_time(time(NULL), tmbuf, sizeof(tmbuf)) <= 0 ||
	    kv_add(&resp->http_headers, "Date", tmbuf) == NULL)
d833 1
a833 1
	    server_headers(clt, resp, server_writeheader_http, NULL) == -1 ||
d837 1
a837 1
	if (size == 0 || resp->http_method == HTTP_METHOD_HEAD) {
d853 1
a853 1
	struct http_descriptor	*desc = clt->clt_descresp;
d897 1
a897 1
server_headers(struct client *clt, void *descp,
d901 1
a901 1
	struct http_descriptor	*desc = descp;
d935 1
a935 1
	const char	*name = "<UNKNOWN>";
d999 1
a999 1
	if ((desc = clt->clt_descreq) == NULL)
@


1.41
log
@http POST support
with & OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.40 2014/08/06 09:34:21 reyk Exp $	*/
d123 1
d263 5
@


1.40
log
@Add braces.  Style-only change.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.39 2014/08/05 18:01:10 reyk Exp $	*/
d325 4
a328 4
		if (clt->clt_toread <= 0) {
			server_response(env, clt);
			return;
		}
d364 1
a364 2
			if (server_bufferevent_write_chunk(clt,
			    src, size) == -1)
d368 1
a368 1
			if (server_bufferevent_write_buffer(clt, src) == -1)
d376 1
d378 1
d380 1
d386 1
a386 1
	bufferevent_enable(bev, EV_READ);
a388 1
	server_close(clt, "last http content read");
@


1.39
log
@Add configuration options for the most-important connection limits:
max requests (per connection) and timeout.  We don't want to add too
many button, and there are good defaults, but these ones are kind of
mandatory.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.38 2014/08/05 16:30:36 reyk Exp $	*/
d650 1
a650 1
	if (asprintf(&httpmsg, "%s (%03d %s)", msg, code, httperr) == -1)
d652 1
a652 1
	else {
@


1.38
log
@Limit the number of (Keep-Alive) requests per connection to 100.
(Same default as in nginx and Apache).
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.37 2014/08/05 14:36:10 deraadt Exp $	*/
d714 1
a714 1
	if (clt->clt_persist >= SERVER_MAXREQUESTS)
@


1.37
log
@retire blink because this is serious software now; ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.36 2014/08/04 11:09:25 reyk Exp $	*/
d713 3
@


1.36
log
@httpd doesn't support SSL/TLS yet, remove the remaining bits.
The secrect plan is to add it later using the ressl wrapper library.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.35 2014/08/04 06:35:10 deraadt Exp $	*/
d615 1
a615 8
	    "'Comic Sans MS', 'Chalkboard SE', 'Comic Neue', sans-serif; }"
	    "blink { animation:blink 1s; animation-iteration-count: infinite;"
	    "-webkit-animation:blink 1s;"
	    "-webkit-animation-iteration-count: infinite;}"
	    "@@keyframes blink { 0%{opacity:0.0;} 50%{opacity:0.0;}"
	    "50.01%{opacity:1.0;} 100%{opacity:1.0;} }"
	    "@@-webkit-keyframes blink { 0%{opacity:0.0;} 50%{opacity:0.0;}"
	    "50.01%{opacity:1.0;} 100%{opacity:1.0;} }";
d633 1
a633 1
	    "<h1><blink>%s</blink></h1>\n"
@


1.35
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.34 2014/08/03 22:38:12 reyk Exp $	*/
a45 2

#include <openssl/ssl.h>
@


1.34
log
@Also write log messages, like 404 Not Found, on error.  This is a bit
tricky because we couldn't guarantee a sane state after
server_response_http() so fail hard afterwards and close the connection.

ok doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.33 2014/08/03 21:33:27 reyk Exp $	*/
d81 1
a81 1
	/* nothing */	
@


1.33
log
@Allocate http_host instead of carrying a buffer in the descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.32 2014/08/03 20:39:40 reyk Exp $	*/
d587 3
@


1.32
log
@Dynamically pass HTTP request headers as protocol-specific HTTP_* CGI
meta-variables.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.31 2014/08/03 12:26:19 reyk Exp $	*/
d113 4
d679 1
d740 2
a741 2
		if (server_http_host(&clt->clt_srv_ss, desc->http_host,
		    sizeof(desc->http_host)) == NULL)
d745 2
a746 2
		if (strlcpy(desc->http_host, host->kv_value,
		    sizeof(desc->http_host)) >= sizeof(desc->http_host))
d750 3
@


1.31
log
@Add function to iterate all headers.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.30 2014/08/03 10:26:44 reyk Exp $	*/
d821 1
a821 1
	    server_headers(clt, server_writeheader_http) == -1 ||
d857 1
a857 1
server_writeheader_http(struct client *clt, struct kv *hdr)
d885 2
a886 1
server_headers(struct client *clt, int (*hdr_cb)(struct client *, struct kv *))
d892 1
a892 1
		if ((hdr_cb)(clt, hdr) == -1)
d895 1
a895 1
			if ((hdr_cb)(clt, kv) == -1)
@


1.30
log
@Add another log mode "connection" for a relayd(8)-style log entry after
each connection, not every request.  The code was already there and enabled
on debug, I just turned it into an alternative log format.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.29 2014/08/03 10:22:30 reyk Exp $	*/
d821 1
a821 1
	    server_writeheader_http(clt) == -1 ||
d857 1
a857 1
server_writeheader_kv(struct client *clt, struct kv *hdr)
d885 1
a885 1
server_writeheader_http(struct client *clt)
d891 1
a891 1
		if (server_writeheader_kv(clt, hdr) == -1)
d894 1
a894 1
			if (server_writeheader_kv(clt, kv) == -1)
@


1.29
log
@Prefer getnameinfo() with NI_NUMERICHOST over inet_ntop because it is also
aware of the IPv6 scope Id.  We already have a function print_host() that
uses getnameinfo, so no need for the inet_ntop cases. Confirmed by florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.28 2014/08/02 21:21:47 doug Exp $	*/
d521 1
a521 1
	server_log(clt);
d996 2
a997 1
	print_host(&clt->clt_ss, ip, sizeof(ip));
d1045 6
@


1.28
log
@Locations now inherit access log settings from the server.

Add log to the server flags.

input/"Looks ok" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.27 2014/08/01 22:24:05 reyk Exp $	*/
d996 1
a996 10
	if (clt->clt_ss.ss_family == AF_INET) {
		struct sockaddr_in	*in = (struct sockaddr_in *)&clt->clt_ss;
		if (inet_ntop(AF_INET, &in->sin_addr, ip, sizeof(ip)) == NULL)
			return (-1);
	} else if (clt->clt_ss.ss_family == AF_INET6) {
		struct sockaddr_in6	*in = (struct sockaddr_in6 *)&clt->clt_ss;
		if (inet_ntop(AF_INET6, &in->sin6_addr, ip, sizeof(ip)) == NULL)
			return (-1);
	} else
		return (-1);
@


1.27
log
@Use the log buffer to defer the logging until the connection is closed
or the request completed.  Turn the old log message into a debug message.

ok doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.26 2014/08/01 21:51:02 doug Exp $	*/
d974 5
a978 4
	static char tstamp[64];
	static char ip[INET6_ADDRSTRLEN];
	time_t t;
	struct tm *tm;
a980 1
	struct kv		key, *agent, *referrer;
d984 2
a987 2
	if (srv_conf->logformat == LOG_FORMAT_NONE)
		return (0);
d997 1
a997 1
		struct sockaddr_in *in = (struct sockaddr_in *)&clt->clt_ss;
d1001 1
a1001 1
		struct sockaddr_in6 *in = (struct sockaddr_in6 *)&clt->clt_ss;
d1010 4
a1054 3

	case LOG_FORMAT_NONE:
		return (-1);
@


1.26
log
@Add common and combined access logging to httpd.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.25 2014/07/31 18:07:11 reyk Exp $	*/
d520 2
d1013 2
a1014 1
		log_info("%s %s - - [%s] \"%s %s%s%s%s%s\" %03d %zu",
d1022 2
a1023 1
		    code, len);
d1037 2
a1038 2
		log_info("%s %s - - [%s] \"%s %s%s%s%s%s\" %03d %zu"
		    " \"%s\" \"%s\"",
d1048 2
a1049 1
		    agent == NULL ? "" : agent->kv_value);
d1052 1
a1052 1
	default:
@


1.25
log
@Only write the HTTP header for the first fastcgi chunk.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.24 2014/07/31 17:55:09 reyk Exp $	*/
d43 1
d776 3
d967 85
@


1.24
log
@some fastcgi improvements:
- DPRINTF instead of log_info for internal debugging.
- submit QUERY_STRING, if it exists
- use a proper function to create an HTTP header.
- use server_file_error() to detect EOF and fastcgi stream errors.
- disable keep-alive/persist for now until we have a reliable way to
get the content length from the cgi response or support chunked
encoding.

"Cool, jep" florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.23 2014/07/31 09:34:57 reyk Exp $	*/
d516 1
@


1.23
log
@Add a configuration variable "fastcgi" to enable it per server or location.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.22 2014/07/31 09:23:53 florian Exp $	*/
a50 1
static void	 server_http_date(char *, size_t);
d520 1
a520 1
static void
a674 1
	int			 ret;
d755 2
a756 9
		ret = server_fcgi(httpd, clt);
	else
		ret = server_file(httpd, clt);
	if (ret == -1)
		return (ret);

	server_reset_http(clt);

	return (0);
@


1.22
log
@Put in first stab at fastcgi. Very early work in progress. Putting it
in now so that we can quickly work on it in tree. Requested by reyk@@.
deraadt@@ is OK with this according to reyk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.21 2014/07/30 13:49:48 reyk Exp $	*/
d751 1
a751 2
			clt->clt_srv_conf = location;
			srv_conf = NULL;
d756 6
a761 6
	if (strlen(desc->http_path) > strlen("/cgi-bin/") &&
	    strncmp("/cgi-bin/", desc->http_path, strlen("/cgi-bin/")) == 0) {
		if ((ret = server_fcgi(httpd, clt)) == -1)
			return (-1);
	} else if ((ret = server_file(httpd, clt)) == -1)
		return (-1);
@


1.21
log
@Make "location" work with name-based virtual servers.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.20 2014/07/30 10:05:14 reyk Exp $	*/
d757 5
a761 1
	if ((ret = server_file(httpd, clt)) == -1)
@


1.20
log
@Add "location" keyword to specify path-specific configuration in
servers, for example auto index for a sub-directory only.  Internally,
a "location" is just a special type of a "virtual" server.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.19 2014/07/25 23:25:38 reyk Exp $	*/
d674 1
a674 1
	struct server_config	*srv_conf = &srv->srv_conf;
d720 3
a722 5
			if (((srv_conf->flags & SRVFLAG_LOCATION) &&
			    fnmatch(srv_conf->location,
			    desc->http_path, FNM_CASEFOLD) == 0) ||
			    (fnmatch(srv_conf->name, host->kv_value,
			    FNM_CASEFOLD) == 0)) {
d741 14
@


1.19
log
@Reset the default Host for each request
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.18 2014/07/25 23:23:39 reyk Exp $	*/
d568 2
a569 1
	struct server_config	*srv_conf = clt->clt_srv_conf;
d720 5
a724 2
			if (fnmatch(srv_conf->name, host->kv_value,
			    FNM_CASEFOLD) == 0) {
@


1.18
log
@It is recommended to use a URL in the Location header of 3xx
responses.  To accomplish this, add some semantics to retrieve the
server host name of a connection: either IP, IP:PORT (if not 80) or
[IP6]:PORT, or Host value (if valid).
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.17 2014/07/25 21:48:05 reyk Exp $	*/
d509 1
d518 1
@


1.17
log
@Append mandatory Date header to each response.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.16 2014/07/25 21:36:37 reyk Exp $	*/
d531 32
d671 2
a672 2
	struct server_config	*srv_conf;
	struct kv		*kv, key;
d683 5
d690 1
a690 2
		key.kv_key = "Host";
		if ((kv = kv_find(&desc->http_headers, &key)) == NULL)
d714 1
a714 2
	key.kv_key = "Host";
	if ((kv = kv_find(&desc->http_headers, &key)) != NULL) {
d717 1
a717 1
			if (fnmatch(srv_conf->name, kv->kv_value,
d721 1
d725 12
@


1.16
log
@New HTTP/1.1 RFC 7231 prefers IMF-fixdate from RFC 5322.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.15 2014/07/25 21:29:58 reyk Exp $	*/
d51 1
d519 12
a537 2
	time_t			 t;
	struct tm		 tm;
d551 1
a551 4
	/* New HTTP/1.1 RFC 7231 prefers IMF-fixdate from RFC 5322 */
	time(&t);
	gmtime_r(&t, &tm);
	strftime(tmbuf, sizeof(tmbuf), "%a, %d %h %Y %T %Z", &tm);
d709 1
d744 5
@


1.15
log
@Canonicalize the request path once without the docroot and prepend the
docroot only only when it's needed.  Suggested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.14 2014/07/25 16:23:19 reyk Exp $	*/
d526 1
a526 1
	struct tm		*lt;
d540 1
a540 1
	/* RFC 2616 "tolerates" asctime() */
d542 2
a543 4
	lt = localtime(&t);
	tmbuf[0] = '\0';
	if (asctime_r(lt, tmbuf) != NULL)
		tmbuf[strlen(tmbuf) - 1] = '\0';	/* skip final '\n' */
@


1.14
log
@Add support for "virtual hosts" aka. server blocks aka. multiple
servers with the same or "overlapping" IP address but a different name.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.13 2014/07/25 13:10:18 reyk Exp $	*/
d630 1
d637 6
a642 1
	if (desc->http_path == NULL)
@


1.13
log
@Split server and server_config.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.12 2014/07/25 12:46:23 reyk Exp $	*/
d631 2
d660 17
@


1.12
log
@Rename a field, needed later, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.11 2014/07/24 08:32:36 reyk Exp $	*/
d521 1
a521 1
	struct server		*srv = clt->clt_srv;
d537 1
a537 1
	if (print_host(&srv->srv_conf.ss, hbuf, sizeof(hbuf)) == NULL)
d599 1
a599 1
	    HTTPD_SERVERNAME, hbuf, ntohs(srv->srv_conf.port)) == -1)
@


1.11
log
@Plug a memleak by correctly free'ing the HTTP descriptor that contains
all the headers etc. of a connection.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.10 2014/07/23 21:43:12 reyk Exp $	*/
d521 1
a521 1
	struct server		*srv = clt->clt_server;
@


1.10
log
@First attempt at verifying the request path and the access
permissions.  We also have to redirect with 301 if a directory name
was requested without the trailing slash.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.9 2014/07/17 11:35:26 stsp Exp $	*/
d113 1
@


1.9
log
@Move comment about strcasecmp() to a more suitable spot.
ok reyk benno
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.8 2014/07/16 10:25:28 reyk Exp $	*/
d523 1
a523 1
	char			*httpmsg;
d547 12
a558 1
	if (code != 500)
d560 2
d580 1
d596 1
d606 1
@


1.8
log
@Implement file descriptor accounting.  The concept was taken from
relayd but had to be adjusted for httpd.  It now handles single-pass
HTTP connections, persistent connections with multiple requests, and
body-less HEAD requests.  With input from benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.7 2014/07/14 09:03:08 reyk Exp $	*/
a789 4
	/*
	 * RFC 2616 section 5.1.1 says that the method is case
	 * sensitive so we don't do a strcasecmp here.
	 */
d819 5
@


1.7
log
@Track Connection: Keep-Alive
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.6 2014/07/14 00:19:48 reyk Exp $	*/
d322 2
a323 2
			if (server_response(env, clt) == -1)
				return;
a513 1
	clt->clt_toread = TOREAD_HTTP_HEADER;
d646 1
a646 3
	/* XXX */
	if (!(desc->http_method == HTTP_METHOD_HEAD && clt->clt_persist == 0))
		server_reset_http(clt);
d648 1
a648 1
	return (ret);
@


1.6
log
@first step towards keep-alive/persistent connections support
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.5 2014/07/13 15:39:01 reyk Exp $	*/
d627 2
a628 1
		/* Is the connection persistent? */		
d633 1
a633 1
			clt->clt_persist = 1;
d635 7
a641 2
		/* Keep-Alive with HTTP/1.0 not supported */
		clt->clt_persist = 0;
@


1.5
log
@Remove a debug message
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.4 2014/07/13 14:17:37 reyk Exp $	*/
a324 2

		server_reset_http(clt);
d514 2
d609 103
@


1.4
log
@Add support for media types (aka. MIME types): the types section is
compatible to nginx' mime.types file which can be included directly.
If not present, use a few built-in defaults for html, css, txt, jpeg,
gif, png, and js.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.3 2014/07/13 09:46:19 beck Exp $	*/
a644 1
	DPRINTF("%s: ptr %s", __func__, ptr);
@


1.3
log
@Make error messages more obvious to the user.
ok reyk@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.2 2014/07/12 23:55:35 reyk Exp $	*/
d322 1
a322 1
			if (server_response(clt) == -1)
@


1.2
log
@Use Comic Sans (or Chalkboard) as the default font for HTTP error
messages because we love web hipsters.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_http.c,v 1.1 2014/07/12 23:34:54 reyk Exp $	*/
d553 8
a560 2
	    "'Comic Sans MS', 'Chalkboard SE', 'Comic Neue', sans-serif; }";

d577 1
a577 1
	    "<h1>%s</h1>\n"
@


1.1
log
@Add httpd(8), an attempt to turn the relayd(8) codebase into a simple
web server.  It is not finished yet and I just started it today, but
the goal is to provide an HTTP server that a) provides minimal
features, b) serves static files, c) provides FastCGI support, and d)
follows common coding practices of OpenBSD.

It will neither support plugins, nor custom memory allocators, EBCDIC
support, PCRE or any other things that can be found elsewhere.
httpd(8) is not intended to provide a fully-featured replacement for
nginx(8) or the Apache, but it will provide enough functionality that
is needed in the OpenBSD base system.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.25 2014/07/11 23:11:54 benno Exp $	*/
d552 2
a553 1
	style = "body { background-color: white; color: black; }";
@

