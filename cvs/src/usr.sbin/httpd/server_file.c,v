head	1.65;
access;
symbols
	OPENBSD_6_1:1.65.0.2
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.62.0.2
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.60.0.2
	OPENBSD_5_9_BASE:1.60
	OPENBSD_5_8:1.60.0.4
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.51.0.2
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31;
locks; strict;
comment	@ * @;


1.65
date	2017.02.02.22.19.59;	author reyk;	state Exp;
branches;
next	1.64;
commitid	wAyoqiU7jG1NUkqx;

1.64
date	2017.01.31.14.39.47;	author reyk;	state Exp;
branches;
next	1.63;
commitid	IPZeYDCn5vLI9sJB;

1.63
date	2017.01.30.09.54.41;	author reyk;	state Exp;
branches;
next	1.62;
commitid	AA08ObpVQZArFZ1S;

1.62
date	2016.05.17.03.12.39;	author deraadt;	state Exp;
branches
	1.62.2.1;
next	1.61;
commitid	Imx654prZP1deS2o;

1.61
date	2016.03.08.09.33.15;	author florian;	state Exp;
branches;
next	1.60;
commitid	TVL220R4XsSPamVq;

1.60
date	2015.08.03.11.45.17;	author florian;	state Exp;
branches
	1.60.2.1;
next	1.59;
commitid	R0hlkHQJt4QQvq7o;

1.59
date	2015.07.20.11.38.19;	author semarie;	state Exp;
branches;
next	1.58;
commitid	C6kfKMEHKRc9fFWv;

1.58
date	2015.07.18.14.36.24;	author kili;	state Exp;
branches;
next	1.57;
commitid	xJeS3KhWiKovkGIr;

1.57
date	2015.07.18.06.00.43;	author reyk;	state Exp;
branches;
next	1.56;
commitid	GYrjpgr4p814WbAx;

1.56
date	2015.07.17.21.53.57;	author reyk;	state Exp;
branches;
next	1.55;
commitid	1WmorDDx9EZBFAFy;

1.55
date	2015.07.16.19.05.28;	author reyk;	state Exp;
branches;
next	1.54;
commitid	uD9Qfc9LJPALunq8;

1.54
date	2015.05.05.11.10.13;	author florian;	state Exp;
branches;
next	1.53;
commitid	oZ3Ognf95F5TdxOi;

1.53
date	2015.05.03.18.39.58;	author florian;	state Exp;
branches;
next	1.52;
commitid	tKSpRdIDfb89N9Nf;

1.52
date	2015.04.25.14.40.35;	author florian;	state Exp;
branches;
next	1.51;
commitid	CeoWS8psgugFUxeS;

1.51
date	2015.02.12.10.05.29;	author reyk;	state Exp;
branches;
next	1.50;
commitid	eiL3BkcA1VXRVRJ2;

1.50
date	2015.02.10.08.12.29;	author florian;	state Exp;
branches;
next	1.49;
commitid	mWYYH04t95KXgJsq;

1.49
date	2015.02.08.00.00.59;	author reyk;	state Exp;
branches;
next	1.48;
commitid	T0lfZLuka5kZO7cg;

1.48
date	2015.01.21.22.21.05;	author reyk;	state Exp;
branches;
next	1.47;
commitid	64Zc6bef54Vu2Noy;

1.47
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	Uu5nFG3wCl0LACBb;

1.46
date	2015.01.13.09.21.15;	author reyk;	state Exp;
branches;
next	1.45;
commitid	vlRoyiZgaC5QvCo7;

1.45
date	2015.01.06.17.55.28;	author stsp;	state Exp;
branches;
next	1.44;
commitid	JGYDDHJHjy8OxZnk;

1.44
date	2015.01.04.22.23.58;	author chrisz;	state Exp;
branches;
next	1.43;
commitid	PxQkOIiHP7NqIPYy;

1.43
date	2015.01.01.14.15.02;	author reyk;	state Exp;
branches;
next	1.42;
commitid	bb5s5QBx3K8HXzjN;

1.42
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.41;
commitid	XnjIOhurXdX5o1V9;

1.41
date	2014.12.12.14.45.59;	author reyk;	state Exp;
branches;
next	1.40;
commitid	j2F3LZ1OyONol7u9;

1.40
date	2014.12.04.02.44.42;	author tedu;	state Exp;
branches;
next	1.39;
commitid	A2H8wpKaas7ra1zW;

1.39
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.38;
commitid	2uw1UTO4k6erpWzK;

1.38
date	2014.10.21.13.00.33;	author reyk;	state Exp;
branches;
next	1.37;
commitid	Z1GQGdwoHr7tFH16;

1.37
date	2014.10.02.19.22.43;	author reyk;	state Exp;
branches;
next	1.36;
commitid	fE54qSJpQK0UmfPw;

1.36
date	2014.09.27.12.49.45;	author reyk;	state Exp;
branches;
next	1.35;
commitid	mCKudHpVLssh9h1M;

1.35
date	2014.08.29.13.01.46;	author reyk;	state Exp;
branches;
next	1.34;
commitid	s1q2vKQd3ZNYgiRk;

1.34
date	2014.08.21.19.23.10;	author chrisz;	state Exp;
branches;
next	1.33;
commitid	JCs4fDUGf9JXsJFG;

1.33
date	2014.08.14.07.50.35;	author chrisz;	state Exp;
branches;
next	1.32;
commitid	NRdxwF98IujBTikg;

1.32
date	2014.08.08.18.29.42;	author reyk;	state Exp;
branches;
next	1.31;
commitid	J4bMyiFa6dPdfodH;

1.31
date	2014.08.06.11.24.12;	author reyk;	state Exp;
branches
	1.31.4.1;
next	1.30;
commitid	uOQWAqZrGtAeribj;

1.30
date	2014.08.06.09.36.31;	author reyk;	state Exp;
branches;
next	1.29;
commitid	3LE5yBvWStUuSW90;

1.29
date	2014.08.04.17.43.20;	author reyk;	state Exp;
branches;
next	1.28;
commitid	H3HuXU947CCdmbjy;

1.28
date	2014.08.04.11.09.25;	author reyk;	state Exp;
branches;
next	1.27;
commitid	Dj6ALT3dpIHqBQcw;

1.27
date	2014.08.03.22.47.25;	author reyk;	state Exp;
branches;
next	1.26;
commitid	xmfioaDS7ZyzQkTc;

1.26
date	2014.08.03.22.38.12;	author reyk;	state Exp;
branches;
next	1.25;
commitid	NQSzoccH9KIwwSqc;

1.25
date	2014.08.03.11.16.10;	author reyk;	state Exp;
branches;
next	1.24;
commitid	fIgJJaAKavK3V1Ms;

1.24
date	2014.08.02.09.54.13;	author reyk;	state Exp;
branches;
next	1.23;
commitid	5XKYTFjUCKotRnfJ;

1.23
date	2014.08.02.09.46.51;	author reyk;	state Exp;
branches;
next	1.22;
commitid	XZAJJANjgjQV7mO3;

1.22
date	2014.07.31.17.55.09;	author reyk;	state Exp;
branches;
next	1.21;
commitid	2oJScuzXVXi93eTv;

1.21
date	2014.07.31.14.25.14;	author reyk;	state Exp;
branches;
next	1.20;
commitid	QkmIVLoOhhCQIxFE;

1.20
date	2014.07.31.13.28.15;	author reyk;	state Exp;
branches;
next	1.19;
commitid	HDnnTvoJZbrXmrWp;

1.19
date	2014.07.30.07.09.38;	author reyk;	state Exp;
branches;
next	1.18;
commitid	kXw8khCYxhk80jZ1;

1.18
date	2014.07.29.16.17.28;	author reyk;	state Exp;
branches;
next	1.17;
commitid	lVEJBNunwU7ia3Go;

1.17
date	2014.07.26.22.38.38;	author reyk;	state Exp;
branches;
next	1.16;
commitid	e0A7iwrkK2cDozBN;

1.16
date	2014.07.25.23.23.39;	author reyk;	state Exp;
branches;
next	1.15;
commitid	ovF3df8kR0MciR0p;

1.15
date	2014.07.25.21.29.58;	author reyk;	state Exp;
branches;
next	1.14;
commitid	smhDJiNevxTCWh6A;

1.14
date	2014.07.25.20.13.06;	author reyk;	state Exp;
branches;
next	1.13;
commitid	tMgLyg9w52NgWcf2;

1.13
date	2014.07.25.13.10.18;	author reyk;	state Exp;
branches;
next	1.12;
commitid	e2fiCfjHRfxIZTmx;

1.12
date	2014.07.25.12.46.23;	author reyk;	state Exp;
branches;
next	1.11;
commitid	nFELL2a0ZqVmRooJ;

1.11
date	2014.07.25.12.42.05;	author reyk;	state Exp;
branches;
next	1.10;
commitid	YXf583TKv41UVnB7;

1.10
date	2014.07.23.22.20.37;	author reyk;	state Exp;
branches;
next	1.9;
commitid	M1CwvbpClTvztNTB;

1.9
date	2014.07.23.22.18.57;	author reyk;	state Exp;
branches;
next	1.8;
commitid	P3icQi9Crq0BBV1N;

1.8
date	2014.07.23.21.43.12;	author reyk;	state Exp;
branches;
next	1.7;
commitid	VwbmwwMNcn9gFVvS;

1.7
date	2014.07.23.19.03.56;	author reyk;	state Exp;
branches;
next	1.6;
commitid	ZUW6ktdLBGFDHF5g;

1.6
date	2014.07.16.10.25.28;	author reyk;	state Exp;
branches;
next	1.5;
commitid	ogHdcewg1QccxeTT;

1.5
date	2014.07.15.09.51.06;	author reyk;	state Exp;
branches;
next	1.4;
commitid	pBpUmXmDPModxe18;

1.4
date	2014.07.14.00.19.48;	author reyk;	state Exp;
branches;
next	1.3;
commitid	PY8fkGzrfhDzml1J;

1.3
date	2014.07.13.15.07.50;	author reyk;	state Exp;
branches;
next	1.2;
commitid	g1b0NbSrZCfJqpHu;

1.2
date	2014.07.13.14.17.37;	author reyk;	state Exp;
branches;
next	1.1;
commitid	4gg9IcDTWDACYa56;

1.1
date	2014.07.12.23.34.54;	author reyk;	state Exp;
branches;
next	;
commitid	U5OqzWAgis3Sb3uE;

1.31.4.1
date	2014.11.20.07.48.45;	author jasper;	state Exp;
branches;
next	;
commitid	aoUNgrdXQt2mQs98;

1.60.2.1
date	2017.01.31.21.07.28;	author benno;	state Exp;
branches;
next	;
commitid	mWlmi6TB2DQPFSlf;

1.62.2.1
date	2017.01.31.21.07.05;	author benno;	state Exp;
branches;
next	;
commitid	ksUXciNKE4ZID4Xr;


desc
@@


1.65
log
@Fix support for HTTP pipelining by handling all requests in the buffer.

Tested & OK jung@@
@
text
@/*	$OpenBSD: server_file.c,v 1.64 2017/01/31 14:39:47 reyk Exp $	*/

/*
 * Copyright (c) 2006 - 2017 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/stat.h>

#include <limits.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <dirent.h>
#include <time.h>
#include <event.h>

#include "httpd.h"
#include "http.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

int		 server_file_access(struct httpd *, struct client *,
		    char *, size_t);
int		 server_file_request(struct httpd *, struct client *,
		    char *, struct stat *);
int		 server_partial_file_request(struct httpd *, struct client *,
		    char *, struct stat *, char *);
int		 server_file_index(struct httpd *, struct client *,
		    struct stat *);
int		 server_file_modified_since(struct http_descriptor *,
		    struct stat *);
int		 server_file_method(struct client *);
int		 parse_range_spec(char *, size_t, struct range *);
int		 parse_ranges(struct client *, char *, size_t);

int
server_file_access(struct httpd *env, struct client *clt,
    char *path, size_t len)
{
	struct http_descriptor	*desc = clt->clt_descreq;
	struct server_config	*srv_conf = clt->clt_srv_conf;
	struct stat		 st;
	struct kv		*r, key;
	char			*newpath, *encodedpath;
	int			 ret;

	errno = 0;

	if (access(path, R_OK) == -1) {
		goto fail;
	} else if (stat(path, &st) == -1) {
		goto fail;
	} else if (S_ISDIR(st.st_mode)) {
		/* Deny access if directory indexing is disabled */
		if (srv_conf->flags & SRVFLAG_NO_INDEX) {
			errno = EACCES;
			goto fail;
		}

		if (desc->http_path_alias != NULL) {
			/* Recursion - the index "file" is a directory? */
			errno = EINVAL;
			goto fail;
		}

		/* Redirect to path with trailing "/" */
		if (path[strlen(path) - 1] != '/') {
			if ((encodedpath = url_encode(desc->http_path)) == NULL)
				return (500);
			if (asprintf(&newpath, "http%s://%s%s/",
			    srv_conf->flags & SRVFLAG_TLS ? "s" : "",
			    desc->http_host, encodedpath) == -1) {
				free(encodedpath);
				return (500);
			}
			free(encodedpath);

			/* Path alias will be used for the redirection */
			desc->http_path_alias = newpath;

			/* Indicate that the file has been moved */
			return (301);
		}

		/* Append the default index file to the location */
		if (asprintf(&newpath, "%s%s", desc->http_path,
		    srv_conf->index) == -1)
			return (500);
		desc->http_path_alias = newpath;
		if (server_getlocation(clt, newpath) != srv_conf) {
			/* The location has changed */
			return (server_file(env, clt));
		}

		/* Otherwise append the default index file to the path */
		if (strlcat(path, srv_conf->index, len) >= len) {
			errno = EACCES;
			goto fail;
		}

		ret = server_file_access(env, clt, path, len);
		if (ret == 404) {
			/*
			 * Index file not found; fail if auto-indexing is
			 * not enabled, otherwise return success but
			 * indicate directory with S_ISDIR of the previous
			 * stat.
			 */
			if ((srv_conf->flags & SRVFLAG_AUTO_INDEX) == 0) {
				errno = EACCES;
				goto fail;
			}

			return (server_file_index(env, clt, &st));
		}
		return (ret);
	} else if (!S_ISREG(st.st_mode)) {
		/* Don't follow symlinks and ignore special files */
		errno = EACCES;
		goto fail;
	}

	key.kv_key = "Range";
	r = kv_find(&desc->http_headers, &key);
	if (r != NULL)
		return (server_partial_file_request(env, clt, path, &st,
		    r->kv_value));
	else
		return (server_file_request(env, clt, path, &st));

 fail:
	switch (errno) {
	case ENOENT:
	case ENOTDIR:
		return (404);
	case EACCES:
		return (403);
	default:
		return (500);
	}

	/* NOTREACHED */
}

int
server_file(struct httpd *env, struct client *clt)
{
	struct http_descriptor	*desc = clt->clt_descreq;
	struct server_config	*srv_conf = clt->clt_srv_conf;
	char			 path[PATH_MAX];
	const char		*stripped, *errstr = NULL;
	int			 ret = 500;

	if (srv_conf->flags & SRVFLAG_FCGI)
		return (server_fcgi(env, clt));

	/* Request path is already canonicalized */
	stripped = server_root_strip(
	    desc->http_path_alias != NULL ?
	    desc->http_path_alias : desc->http_path,
	    srv_conf->strip);
	if ((size_t)snprintf(path, sizeof(path), "%s%s",
	    srv_conf->root, stripped) >= sizeof(path)) {
		errstr = desc->http_path;
		goto abort;
	}

	/* Returns HTTP status code on error */
	if ((ret = server_file_access(env, clt, path, sizeof(path))) > 0) {
		errstr = desc->http_path_alias != NULL ?
		    desc->http_path_alias : desc->http_path;
		goto abort;
	}

	return (ret);

 abort:
	if (errstr == NULL)
		errstr = strerror(errno);
	server_abort_http(clt, ret, errstr);
	return (-1);
}

int
server_file_method(struct client *clt)
{
	struct http_descriptor	*desc = clt->clt_descreq;

	switch (desc->http_method) {
	case HTTP_METHOD_GET:
	case HTTP_METHOD_HEAD:
		return (0);
	default:
		/* Other methods are not allowed */
		errno = EACCES;
		return (405);
	}
	/* NOTREACHED */
}

int
server_file_request(struct httpd *env, struct client *clt, char *path,
    struct stat *st)
{
	struct server_config	*srv_conf = clt->clt_srv_conf;
	struct media_type	*media;
	const char		*errstr = NULL;
	int			 fd = -1, ret, code = 500;

	if ((ret = server_file_method(clt)) != 0) {
		code = ret;
		goto abort;
	}

	if ((ret = server_file_modified_since(clt->clt_descreq, st)) != -1)
		return (ret);

	/* Now open the file, should be readable or we have another problem */
	if ((fd = open(path, O_RDONLY)) == -1)
		goto abort;

	media = media_find_config(env, srv_conf, path);
	ret = server_response_http(clt, 200, media, st->st_size,
	    MINIMUM(time(NULL), st->st_mtim.tv_sec));
	switch (ret) {
	case -1:
		goto fail;
	case 0:
		/* Connection is already finished */
		close(fd);
		goto done;
	default:
		break;
	}

	clt->clt_fd = fd;
	if (clt->clt_srvbev != NULL)
		bufferevent_free(clt->clt_srvbev);

	clt->clt_srvbev_throttled = 0;
	clt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read,
	    server_write, server_file_error, clt);
	if (clt->clt_srvbev == NULL) {
		errstr = "failed to allocate file buffer event";
		goto fail;
	}

	/* Adjust read watermark to the socket output buffer size */
	bufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,
	    clt->clt_sndbufsiz);

	bufferevent_settimeout(clt->clt_srvbev,
	    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);
	bufferevent_enable(clt->clt_srvbev, EV_READ);
	bufferevent_disable(clt->clt_bev, EV_READ);

 done:
	server_reset_http(clt);
	return (0);
 fail:
	bufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);
	bufferevent_free(clt->clt_bev);
	clt->clt_bev = NULL;
 abort:
	if (fd != -1)
		close(fd);
	if (errstr == NULL)
		errstr = strerror(errno);
	server_abort_http(clt, code, errstr);
	return (-1);
}

int
server_partial_file_request(struct httpd *env, struct client *clt, char *path,
    struct stat *st, char *range_str)
{
	struct server_config	*srv_conf = clt->clt_srv_conf;
	struct http_descriptor	*resp = clt->clt_descresp;
	struct http_descriptor	*desc = clt->clt_descreq;
	struct media_type	*media, multipart_media;
	struct range_data	*r = &clt->clt_ranges;
	struct range		*range;
	size_t			 content_length = 0;
	int			 code = 500, fd = -1, i, nranges, ret;
	char			 content_range[64];
	const char		*errstr = NULL;

	/* Ignore range request for methods other than GET */
	if (desc->http_method != HTTP_METHOD_GET)
		return server_file_request(env, clt, path, st);

	if ((nranges = parse_ranges(clt, range_str, st->st_size)) < 1) {
		code = 416;
		(void)snprintf(content_range, sizeof(content_range),
		    "bytes */%lld", st->st_size);
		errstr = content_range;
		goto abort;
	}

	/* Now open the file, should be readable or we have another problem */
	if ((fd = open(path, O_RDONLY)) == -1)
		goto abort;

	media = media_find_config(env, srv_conf, path);
	r->range_media = media;

	if (nranges == 1) {
		range = &r->range[0];
		(void)snprintf(content_range, sizeof(content_range),
		    "bytes %lld-%lld/%lld", range->start, range->end,
		    st->st_size);
		if (kv_add(&resp->http_headers, "Content-Range",
		    content_range) == NULL)
			goto abort;

		range = &r->range[0];
		content_length += range->end - range->start + 1;
	} else {
		/* Add boundary, all parts will be handled by the callback */
		arc4random_buf(&clt->clt_boundary, sizeof(clt->clt_boundary));

		/* Calculate Content-Length of the complete multipart body */
		for (i = 0; i < nranges; i++) {
			range = &r->range[i];

			/* calculate Content-Length of the complete body */
			if ((ret = snprintf(NULL, 0,
			    "\r\n--%llu\r\n"
			    "Content-Type: %s/%s\r\n"
			    "Content-Range: bytes %lld-%lld/%lld\r\n\r\n",
			    clt->clt_boundary,
			    media->media_type, media->media_subtype,
			    range->start, range->end, st->st_size)) < 0)
				goto abort;

			/* Add data length */
			content_length += ret + range->end - range->start + 1;

		}
		if ((ret = snprintf(NULL, 0, "\r\n--%llu--\r\n",
		    clt->clt_boundary)) < 0)
			goto abort;
		content_length += ret;

		/* prepare multipart/byteranges media type */
		(void)strlcpy(multipart_media.media_type, "multipart",
		    sizeof(multipart_media.media_type));
		(void)snprintf(multipart_media.media_subtype,
		    sizeof(multipart_media.media_subtype),
		    "byteranges; boundary=%llu", clt->clt_boundary);
		media = &multipart_media;
	}

	/* Start with first range */
	r->range_toread = TOREAD_HTTP_RANGE;

	ret = server_response_http(clt, 206, media, content_length,
	    MINIMUM(time(NULL), st->st_mtim.tv_sec));
	switch (ret) {
	case -1:
		goto fail;
	case 0:
		/* Connection is already finished */
		close(fd);
		goto done;
	default:
		break;
	}

	clt->clt_fd = fd;
	if (clt->clt_srvbev != NULL)
		bufferevent_free(clt->clt_srvbev);

	clt->clt_srvbev_throttled = 0;
	clt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read_httprange,
	    server_write, server_file_error, clt);
	if (clt->clt_srvbev == NULL) {
		errstr = "failed to allocate file buffer event";
		goto fail;
	}

	/* Adjust read watermark to the socket output buffer size */
	bufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,
	    clt->clt_sndbufsiz);

	bufferevent_settimeout(clt->clt_srvbev,
	    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);
	bufferevent_enable(clt->clt_srvbev, EV_READ);
	bufferevent_disable(clt->clt_bev, EV_READ);

 done:
	server_reset_http(clt);
	return (0);
 fail:
	bufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);
	bufferevent_free(clt->clt_bev);
	clt->clt_bev = NULL;
 abort:
	if (fd != -1)
		close(fd);
	if (errstr == NULL)
		errstr = strerror(errno);
	server_abort_http(clt, code, errstr);
	return (-1);
}

int
server_file_index(struct httpd *env, struct client *clt, struct stat *st)
{
	char			  path[PATH_MAX];
	char			  tmstr[21];
	struct http_descriptor	 *desc = clt->clt_descreq;
	struct server_config	 *srv_conf = clt->clt_srv_conf;
	struct dirent		**namelist, *dp;
	int			  namesize, i, ret, fd = -1, namewidth, skip;
	int			  code = 500;
	struct evbuffer		 *evb = NULL;
	struct media_type	 *media;
	const char		 *stripped, *style;
	char			 *escapeduri, *escapedhtml, *escapedpath;
	struct tm		  tm;
	time_t			  t, dir_mtime;

	if ((ret = server_file_method(clt)) != 0) {
		code = ret;
		goto abort;
	}

	/* Request path is already canonicalized */
	stripped = server_root_strip(desc->http_path, srv_conf->strip);
	if ((size_t)snprintf(path, sizeof(path), "%s%s",
	    srv_conf->root, stripped) >= sizeof(path))
		goto abort;

	/* Now open the file, should be readable or we have another problem */
	if ((fd = open(path, O_RDONLY)) == -1)
		goto abort;

	/* Save last modification time */
	dir_mtime = MINIMUM(time(NULL), st->st_mtim.tv_sec);

	if ((evb = evbuffer_new()) == NULL)
		goto abort;

	if ((namesize = scandir(path, &namelist, NULL, alphasort)) == -1)
		goto abort;

	/* Indicate failure but continue going through the list */
	skip = 0;

	if ((escapedpath = escape_html(desc->http_path)) == NULL)
		goto fail;

	/* A CSS stylesheet allows minimal customization by the user */
	style = "body { background-color: white; color: black; font-family: "
	    "sans-serif; }\nhr { border: 0; border-bottom: 1px dashed; }\n";
	/* Generate simple HTML index document */
	if (evbuffer_add_printf(evb,
	    "<!DOCTYPE html>\n"
	    "<html>\n"
	    "<head>\n"
	    "<meta http-equiv=\"Content-Type\" content=\"text/html; "
	    "charset=utf-8\"/>\n"
	    "<title>Index of %s</title>\n"
	    "<style type=\"text/css\"><!--\n%s\n--></style>\n"
	    "</head>\n"
	    "<body>\n"
	    "<h1>Index of %s</h1>\n"
	    "<hr>\n<pre>\n",
	    escapedpath, style, escapedpath) == -1)
		skip = 1;

	free(escapedpath);

	for (i = 0; i < namesize; i++) {
		dp = namelist[i];

		if (skip ||
		    fstatat(fd, dp->d_name, st, 0) == -1) {
			free(dp);
			continue;
		}

		t = st->st_mtime;
		localtime_r(&t, &tm);
		strftime(tmstr, sizeof(tmstr), "%d-%h-%Y %R", &tm);
		namewidth = 51 - strlen(dp->d_name);

		if ((escapeduri = url_encode(dp->d_name)) == NULL)
			goto fail;
		if ((escapedhtml = escape_html(dp->d_name)) == NULL)
			goto fail;

		if (dp->d_name[0] == '.' &&
		    !(dp->d_name[1] == '.' && dp->d_name[2] == '\0')) {
			/* ignore hidden files starting with a dot */
		} else if (S_ISDIR(st->st_mode)) {
			namewidth -= 1; /* trailing slash */
			if (evbuffer_add_printf(evb,
			    "<a href=\"%s%s/\">%s/</a>%*s%s%20s\n",
			    strchr(escapeduri, ':') != NULL ? "./" : "",
			    escapeduri, escapedhtml,
			    MAXIMUM(namewidth, 0), " ", tmstr, "-") == -1)
				skip = 1;
		} else if (S_ISREG(st->st_mode)) {
			if (evbuffer_add_printf(evb,
			    "<a href=\"%s%s\">%s</a>%*s%s%20llu\n",
			    strchr(escapeduri, ':') != NULL ? "./" : "",
			    escapeduri, escapedhtml,
			    MAXIMUM(namewidth, 0), " ",
			    tmstr, st->st_size) == -1)
				skip = 1;
		}
		free(escapeduri);
		free(escapedhtml);
		free(dp);
	}
	free(namelist);

	if (skip ||
	    evbuffer_add_printf(evb,
	    "</pre>\n<hr>\n</body>\n</html>\n") == -1)
		goto abort;

	close(fd);
	fd = -1;

	media = media_find_config(env, srv_conf, "index.html");
	ret = server_response_http(clt, 200, media, EVBUFFER_LENGTH(evb),
	    dir_mtime);
	switch (ret) {
	case -1:
		goto fail;
	case 0:
		/* Connection is already finished */
		evbuffer_free(evb);
		goto done;
	default:
		break;
	}

	if (server_bufferevent_write_buffer(clt, evb) == -1)
		goto fail;
	evbuffer_free(evb);
	evb = NULL;

	bufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);
	if (clt->clt_persist)
		clt->clt_toread = TOREAD_HTTP_HEADER;
	else
		clt->clt_toread = TOREAD_HTTP_NONE;
	clt->clt_done = 0;

 done:
	server_reset_http(clt);
	return (0);
 fail:
	bufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);
	bufferevent_free(clt->clt_bev);
	clt->clt_bev = NULL;
 abort:
	if (fd != -1)
		close(fd);
	if (evb != NULL)
		evbuffer_free(evb);
	server_abort_http(clt, code, desc->http_path);
	return (-1);
}

void
server_file_error(struct bufferevent *bev, short error, void *arg)
{
	struct client		*clt = arg;
	struct evbuffer		*src, *dst;

	if (error & EVBUFFER_TIMEOUT) {
		server_close(clt, "buffer event timeout");
		return;
	}
	if (error & EVBUFFER_ERROR) {
		if (errno == EFBIG) {
			bufferevent_enable(bev, EV_READ);
			return;
		}
		server_close(clt, "buffer event error");
		return;
	}
	if (error & (EVBUFFER_READ|EVBUFFER_WRITE|EVBUFFER_EOF)) {
		bufferevent_disable(bev, EV_READ|EV_WRITE);

		clt->clt_done = 1;

		src = EVBUFFER_INPUT(clt->clt_bev);

		/* Close the connection if a previous pipeline is empty */
		if (clt->clt_pipelining && EVBUFFER_LENGTH(src) == 0)
			clt->clt_persist = 0;

		if (clt->clt_persist) {
			/* Close input file and wait for next HTTP request */
			if (clt->clt_fd != -1)
				close(clt->clt_fd);
			clt->clt_fd = -1;
			clt->clt_toread = TOREAD_HTTP_HEADER;
			server_reset_http(clt);
			bufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);

			/* Start pipelining if the buffer is not empty */
			if (EVBUFFER_LENGTH(src)) {
				clt->clt_pipelining++;
				server_read_http(clt->clt_bev, arg);
			}
			return;
		}

		dst = EVBUFFER_OUTPUT(clt->clt_bev);
		if (EVBUFFER_LENGTH(dst)) {
			/* Finish writing all data first */
			bufferevent_enable(clt->clt_bev, EV_WRITE);
			return;
		}

		server_close(clt, "done");
		return;
	}
	server_close(clt, "unknown event error");
	return;
}

int
server_file_modified_since(struct http_descriptor *desc, struct stat *st)
{
	struct kv	 key, *since;
	struct tm	 tm;

	key.kv_key = "If-Modified-Since";
	if ((since = kv_find(&desc->http_headers, &key)) != NULL &&
	    since->kv_value != NULL) {
		memset(&tm, 0, sizeof(struct tm));

		/*
		 * Return "Not modified" if the file hasn't changed since
		 * the requested time.
		 */
		if (strptime(since->kv_value,
		    "%a, %d %h %Y %T %Z", &tm) != NULL &&
		    timegm(&tm) >= st->st_mtim.tv_sec)
			return (304);
	}

	return (-1);
}

int
parse_ranges(struct client *clt, char *str, size_t file_sz)
{
	int			 i = 0;
	char			*p, *q;
	struct range_data	*r = &clt->clt_ranges;

	memset(r, 0, sizeof(*r));

	/* Extract range unit */
	if ((p = strchr(str, '=')) == NULL)
		return (-1);

	*p++ = '\0';
	/* Check if it's a bytes range spec */
	if (strcmp(str, "bytes") != 0)
		return (-1);

	while ((q = strchr(p, ',')) != NULL) {
		*q++ = '\0';

		/* Extract start and end positions */
		if (parse_range_spec(p, file_sz, &r->range[i]) == 0)
			continue;

		i++;
		if (i == SERVER_MAX_RANGES)
			return (-1);

		p = q;
	}

	if (parse_range_spec(p, file_sz, &r->range[i]) != 0)
		i++;

	r->range_total = file_sz;
	r->range_count = i;
	return (i);
}

int
parse_range_spec(char *str, size_t size, struct range *r)
{
	size_t		 start_str_len, end_str_len;
	char		*p, *start_str, *end_str;
	const char	*errstr;

	if ((p = strchr(str, '-')) == NULL)
		return (0);

	*p++ = '\0';
	start_str = str;
	end_str = p;
	start_str_len = strlen(start_str);
	end_str_len = strlen(end_str);

	/* Either 'start' or 'end' is optional but not both */
	if ((start_str_len == 0) && (end_str_len == 0))
		return (0);

	if (end_str_len) {
		r->end = strtonum(end_str, 0, LLONG_MAX, &errstr);
		if (errstr)
			return (0);

		if ((size_t)r->end >= size)
			r->end = size - 1;
	} else
		r->end = size - 1;

	if (start_str_len) {
		r->start = strtonum(start_str, 0, LLONG_MAX, &errstr);
		if (errstr)
			return (0);

		if ((size_t)r->start >= size)
			return (0);
	} else {
		r->start = size - r->end;
		r->end = size - 1;
	}

	if (r->end < r->start)
		return (0);

	return (1);
}
@


1.64
log
@Reimplement httpd's support for byte ranges.

The previous implementation loaded all the output into a single output
buffer and used its size to determine the Content-Length of the body.

The new implementation calculates the body length first and writes the
individual ranges in an async way using the bufferevent mechanism.

This prevents httpd from using too much memory and applies the
watermark and throttling mechanisms to range requests.

Problem reported by Pierre Kim (pierre.kim.sec at gmail.com)

OK benno@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.63 2017/01/30 09:54:41 reyk Exp $	*/
d592 1
a592 1
	struct evbuffer		*dst;
d611 6
d625 6
@


1.63
log
@Fix error path of range requests, found while reviewing byte range support.

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.62 2016/05/17 03:12:39 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@@openbsd.org>
a38 6
#define MAX_RANGES	4

struct range {
	off_t	start;
	off_t	end;
};
d52 1
a52 2
struct range	*parse_range(char *, size_t, int *);
int		 buffer_add_range(int, struct evbuffer *, struct range *);
d299 1
d301 1
a301 2
	struct evbuffer		*evb = NULL;
	size_t			 content_length;
a302 1
	uint32_t		 boundary;
d310 1
a310 1
	if ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {
d323 1
a323 4
	if ((evb = evbuffer_new()) == NULL) {
		errstr = "failed to allocate file buffer";
		goto abort;
	}
d326 1
d334 2
a335 4
		content_length = range->end - range->start + 1;
		if (buffer_add_range(fd, evb, range) == 0)
			goto abort;

d337 2
a338 13
		content_length = 0;
		boundary = arc4random();
		/* Generate a multipart payload of byteranges */
		while (nranges--) {
			if ((i = evbuffer_add_printf(evb, "\r\n--%ud\r\n",
			    boundary)) == -1)
				goto abort;

			content_length += i;
			if ((i = evbuffer_add_printf(evb,
			    "Content-Type: %s/%s\r\n",
			    media->media_type, media->media_subtype)) == -1)
				goto abort;
d340 8
a347 2
			content_length += i;
			if ((i = evbuffer_add_printf(evb,
d349 3
a351 1
			    range->start, range->end, st->st_size)) == -1)
d354 2
a355 3
			content_length += i;
			if (buffer_add_range(fd, evb, range) == 0)
				goto abort;
a356 2
			content_length += range->end - range->start + 1;
			range++;
d358 2
a359 3

		if ((i = evbuffer_add_printf(evb, "\r\n--%ud--\r\n",
		    boundary)) == -1)
d361 1
a361 2

		content_length += i;
d368 1
a368 1
		    "byteranges; boundary=%ud", boundary);
d372 2
a373 2
	close(fd);
	fd = -1;
d382 1
d388 9
a396 1
	if (server_bufferevent_write_buffer(clt, evb) == -1)
d398 5
d404 4
a407 6
	bufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);
	if (clt->clt_persist)
		clt->clt_toread = TOREAD_HTTP_HEADER;
	else
		clt->clt_toread = TOREAD_HTTP_NONE;
	clt->clt_done = 0;
a409 1
	evbuffer_free(evb);
a416 2
	if (evb != NULL)
		evbuffer_free(evb);
d660 2
a661 2
struct range *
parse_range(char *str, size_t file_sz, int *nranges)
a662 1
	static struct range	 ranges[MAX_RANGES];
d665 3
d671 1
a671 1
		return (NULL);
d676 1
a676 1
		return (NULL);
d682 1
a682 1
		if (parse_range_spec(p, file_sz, &ranges[i]) == 0)
d686 2
a687 2
		if (i == MAX_RANGES)
			return (NULL);
d692 1
a692 1
	if (parse_range_spec(p, file_sz, &ranges[i]) != 0)
d695 3
a697 2
	*nranges = i;
	return (i ? ranges : NULL);
a743 23

	return (1);
}

int
buffer_add_range(int fd, struct evbuffer *evb, struct range *range)
{
	char	buf[BUFSIZ];
	size_t	n, range_sz;
	ssize_t	nread;

	if (lseek(fd, range->start, SEEK_SET) == -1)
		return (0);

	range_sz = range->end - range->start + 1;
	while (range_sz) {
		n = MINIMUM(range_sz, sizeof(buf));
		if ((nread = read(fd, buf, n)) == -1)
			return (0);

		evbuffer_add(evb, buf, nread);
		range_sz -= nread;
	}
@


1.62
log
@Repair some file descriptor leaks.
ok beck krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.61 2016/03/08 09:33:15 florian Exp $	*/
a401 2
		evbuffer_free(evb);
		evb = NULL;
a409 3
	evbuffer_free(evb);
	evb = NULL;

d418 1
d426 2
@


1.62.2.1
log
@A bug in the processing of range headers in httpd can lead to memory
exhaustion and possibly crash httpd.

This patch disables range header processing.

The problem is fixed in future versions of httpd (OpenBSD 6.1)
by changing the way the file size is determined.

found by Pierre Kim (pierre.kim.sec at gmail.com), thanks.
fix by sunil@@

ok reyk@@ sunil@@ and beck@@ danj@@ tb@@ and tj@@ on the errata.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.62 2016/05/17 03:12:39 deraadt Exp $	*/
d68 1
d148 7
a154 1
	return (server_file_request(env, clt, path, &st));
@


1.61
log
@Set content charset for auto index generated page.
Pointed out and diff by dhill, thanks!
Tweaks and same change for error documents by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.60 2015/08/03 11:45:17 florian Exp $	*/
d290 2
d392 3
a401 1
		close(fd);
d430 2
@


1.60
log
@Fix rev 1.70 of server.c by only re-enabling the bufferevent if we
previously disabled it because we were reading to fast (from disk).
Problem noted and tracked down to that commit by weerd@@ and
independently by stsp@@.
Tested by weerd@@, stsp@@, reyk@@
OK bluhm@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.59 2015/07/20 11:38:19 semarie Exp $	*/
d487 2
@


1.60.2.1
log
@A bug in the processing of range headers in httpd can lead to memory
exhaustion and possibly crash httpd.

This patch disables range header processing.

The problem is fixed in future versions of httpd (OpenBSD 6.1)
by changing the way the file size is determined.

found by Pierre Kim (pierre.kim.sec at gmail.com), thanks.
fix by sunil@@

ok reyk@@ sunil@@ and beck@@ danj@@ tb@@ and tj@@ on the errata.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.60 2015/08/03 11:45:17 florian Exp $	*/
d68 1
d148 7
a154 1
	return (server_file_request(env, clt, path, &st));
@


1.59
log
@ensure http_path is escaped before using it in Location redirection.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.58 2015/07/18 14:36:24 kili Exp $	*/
d265 1
@


1.58
log
@Fix check against NULL which was reverted by accident in r1.56.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.57 2015/07/18 06:00:43 reyk Exp $	*/
d69 1
a69 1
	char			*newpath;
d93 2
d97 2
a98 1
			    desc->http_host, desc->http_path) == -1)
d100 3
@


1.57
log
@Allow to change the default media type globally or per-location,
eg. default type text/html.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.56 2015/07/17 21:53:57 reyk Exp $	*/
d642 1
a642 1
	    since->kv_value == NULL) {
@


1.56
log
@Adjust server_file_modified_since() to our style.  Please keep httpd clean.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.55 2015/07/16 19:05:28 reyk Exp $	*/
d241 1
a241 1
	media = media_find(env->sc_mediatypes, path);
d293 1
d321 1
a321 1
	media = media_find(env->sc_mediatypes, path);
d351 1
a351 3
			    media == NULL ? "application" : media->media_type,
			    media == NULL ?
			    "octet-stream" : media->media_subtype)) == -1)
d544 1
a544 1
	media = media_find(env->sc_mediatypes, "index.html");
@


1.55
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.54 2015/05/05 11:10:13 florian Exp $	*/
d235 1
a235 1
		return ret;
d636 1
a636 1
server_file_modified_since(struct http_descriptor * desc, struct stat * st)
d638 2
a639 4
	struct kv		 key, *since;
	struct tm		 tm;

	memset(&tm, 0, sizeof(struct tm));
d643 10
a652 3
	    since->kv_value != NULL) {
		if (strptime(since->kv_value, "%a, %d %h %Y %T %Z", &tm) !=
		    NULL && timegm(&tm) >= st->st_mtim.tv_sec) {
a653 1
		}
@


1.54
log
@Implement If-Modified-Since.
From Kyle Thompson <jmp AT giga DOT moe>.
Tweaks by me.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.53 2015/05/03 18:39:58 florian Exp $	*/
d46 1
a46 1
int	 	 server_file_access(struct httpd *, struct client *,
d48 1
a48 1
int	 	 server_file_request(struct httpd *, struct client *,
d50 1
a50 1
int	 	 server_partial_file_request(struct httpd *, struct client *,
d52 1
a52 1
int	 	 server_file_index(struct httpd *, struct client *,
d56 4
a59 4
int	 	 server_file_method(struct client *);
int	 	 parse_range_spec(char *, size_t, struct range *);
struct range 	*parse_range(char *, size_t, int *);
int	 	 buffer_add_range(int, struct evbuffer *, struct range *);
d299 1
a299 1
	int		 	 code = 500, fd = -1, i, nranges, ret;
d301 1
a301 1
	char		 	 content_range[64];
d328 1
a328 1
	    	    "bytes %lld-%lld/%lld", range->start, range->end,
d350 2
a351 2
	    		    media == NULL ? "application" : media->media_type,
	    		    media == NULL ?
d377 1
a377 1
	    	    sizeof(multipart_media.media_type));
d379 2
a380 2
	    	    sizeof(multipart_media.media_subtype),
	    	    "byteranges; boundary=%ud", boundary);
d659 1
a659 1
	int	 	 	 i = 0;
d695 1
a695 1
	size_t	 	 start_str_len, end_str_len;
@


1.53
log
@Implement byte ranges.
From Sunil Nimmagadda <sunil At nimmagadda DOT net>
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.52 2015/04/25 14:40:35 florian Exp $	*/
d54 2
d234 3
d635 20
a761 1

@


1.52
log
@Prepend files or directories containing ":" with "./" in directory
indexes as per RFC 3986:
A path segment that contains a colon character (e.g., "this:that")
cannot be used as the first segment of a relative-path reference, as
it would be mistaken for a scheme name.  Such a segment must be
preceded by a dot-segment (e.g., "./this:that") to make a relative-
path reference.

While here add a "/" to the end of directory names, this saves us one
redirect round trip.

Found the hard way & "functionality wise, OK" ajacoutot@@
RFC pointer & OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.51 2015/02/12 10:05:29 reyk Exp $	*/
d39 1
d41 17
a57 5
int	 server_file_access(struct httpd *, struct client *, char *, size_t);
int	 server_file_request(struct httpd *, struct client *, char *,
	    struct stat *);
int	 server_file_index(struct httpd *, struct client *, struct stat *);
int	 server_file_method(struct client *);
d66 1
d140 7
a146 1
	return (server_file_request(env, clt, path, &st));
d285 137
d629 109
@


1.51
log
@Rename escape_uri() to url_encode() because it is the opposite of
url_decode().  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.50 2015/02/10 08:12:29 florian Exp $	*/
d355 2
a356 1
			    "<a href=\"%s\">%s/</a>%*s%s%20s\n",
d362 2
a363 1
			    "<a href=\"%s\">%s</a>%*s%s%20llu\n",
@


1.50
log
@Encode directory listings.
Problem pointed out by remco AT d-compu.dyndns.org some time ago.
Input / OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.49 2015/02/08 00:00:59 reyk Exp $	*/
d344 1
a344 1
		if ((escapeduri = escape_uri(dp->d_name)) == NULL)
@


1.49
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.48 2015/01/21 22:21:05 reyk Exp $	*/
d277 1
d308 3
d325 1
a325 1
	    desc->http_path, style, desc->http_path) == -1)
d328 2
d344 5
d356 1
a356 1
			    dp->d_name, dp->d_name,
d362 1
a362 1
			    dp->d_name, dp->d_name,
d367 2
@


1.48
log
@httpd is based on relayd and had included many headers that are only
needed by its ancestor.  jsg@@, include-what-you-use, and some manual
review helped to cleanup the headers (take iwyu with a grain of salt).
Based on common practice, httpd.h now also includes the necessary
headers for itself.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.47 2015/01/16 06:40:17 deraadt Exp $	*/
d352 2
a353 1
			    MAXIMUM(namewidth, 0), " ", tmstr, st->st_size) == -1)
@


1.47
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.46 2015/01/13 09:21:15 reyk Exp $	*/
a19 1
#include <sys/queue.h>
a21 8
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/tree.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
d23 1
a31 1
#include <err.h>
@


1.46
log
@bump copyright year
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.45 2015/01/06 17:55:28 stsp Exp $	*/
d46 3
d156 1
a156 1
	char			 path[MAXPATHLEN];
d227 1
a227 1
	    MIN(time(NULL), st->st_mtim.tv_sec));
d276 1
a276 1
	char			  path[MAXPATHLEN];
d305 1
a305 1
	dir_mtime = MIN(time(NULL), st->st_mtim.tv_sec);
d355 1
a355 1
			    MAX(namewidth, 0), " ", tmstr, "-") == -1)
d361 1
a361 1
			    MAX(namewidth, 0), " ", tmstr, st->st_size) == -1)
@


1.45
log
@Make httpd return "404 not found" if an intermediate component of a requested
file path does not exist rather than returning "500 internal server error".
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.44 2015/01/04 22:23:58 chrisz Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 - 2014 Reyk Floeter <reyk@@openbsd.org>
@


1.44
log
@add new url stripping option:

strip number
	Strip number path components from the beginning of the
	request URI before looking up the stripped-down URI at
	the document root.


reviewed with much patience and OK by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.43 2015/01/01 14:15:02 reyk Exp $	*/
d137 1
@


1.43
log
@Use the HTML5 doctype for error and auto index pages because it is
shorter, newer, and the recommendation.  From James Jerkins.

Exclude the charset for now because it is not explicitly handled by httpd.

OK validator.w3.org (This document was successfully checked as HTML5!)
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.42 2014/12/21 00:54:49 guenther Exp $	*/
d153 1
a153 1
	const char		*errstr = NULL;
d160 4
d165 1
a165 3
	    srv_conf->root,
	    desc->http_path_alias != NULL ?
	    desc->http_path_alias : desc->http_path) >= sizeof(path)) {
d281 1
a281 1
	const char		 *style;
d291 1
d293 1
a293 1
	    srv_conf->root, desc->http_path) >= sizeof(path))
@


1.42
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.41 2014/12/12 14:45:59 reyk Exp $	*/
d314 1
a314 2
	    "<!DOCTYPE HTML PUBLIC "
	    "\"-//W3C//DTD HTML 4.01 Transitional//EN\">\n"
@


1.41
log
@Like previously done in relayd, change the keyword "ssl" to "tls" to
reflect reality.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.40 2014/12/04 02:44:42 tedu Exp $	*/
a30 1
#include <arpa/inet.h>
@


1.40
log
@stop viral header propagation. none of this code uses sys/hash.h
from Max Fillinger
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.39 2014/10/25 03:23:49 lteo Exp $	*/
d85 1
a85 1
			    srv_conf->flags & SRVFLAG_SSL ? "s" : "",
@


1.39
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.38 2014/10/21 13:00:33 reyk Exp $	*/
a25 1
#include <sys/hash.h>
@


1.38
log
@Rework the error message a little bit: Do not send details of the
error.  Traditionally, web servers responsed with the request path on
40x errors which could be abused to inject JavaScript etc.  Instead of
sanitizing the path, we just don't reprint it.  Also modify the style
a little bit but keep Comic Sans.

With input from Jonas Lindemann and doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.37 2014/10/02 19:22:43 reyk Exp $	*/
a28 1
#include <netinet/in_systm.h>
@


1.37
log
@Fix an error case that was never handled ending up in an endless event
loop that could eat all CPU.  I thought that the previous (correct)
commit fixed it which wasn't the case.  But this one is obvious.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.36 2014/09/27 12:49:45 reyk Exp $	*/
d314 1
a314 1
	    "sans-serif; }";
@


1.36
log
@In addition to READ, disable WRITE events when closing the file
descriptor of the file I/O bufferevent. This fixes a potential event flood.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.35 2014/08/29 13:01:46 reyk Exp $	*/
d425 8
d459 1
a459 5
	if (error & EVBUFFER_ERROR && errno == EFBIG) {
		bufferevent_enable(bev, EV_READ);
		return;
	}
	server_close(clt, "buffer event error");
@


1.35
log
@Use two instead of one http descriptor for request and response.

OK chrisz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.34 2014/08/21 19:23:10 chrisz Exp $	*/
d426 1
a426 1
		bufferevent_disable(bev, EV_READ);
@


1.34
log
@Add Last-Modified: HTTP header.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.33 2014/08/14 07:50:35 chrisz Exp $	*/
d59 1
a59 1
	struct http_descriptor	*desc = clt->clt_desc;
d153 1
a153 1
	struct http_descriptor	*desc = clt->clt_desc;
d190 1
a190 1
	struct http_descriptor	*desc = clt->clt_desc;
d275 1
a275 1
	struct http_descriptor	 *desc = clt->clt_desc;
@


1.33
log
@Remove obsolete struct stat parameters.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.32 2014/08/08 18:29:42 reyk Exp $	*/
d52 1
a52 1
int	 server_file_index(struct httpd *, struct client *);
d126 1
a126 1
			return (server_file_index(env, clt));
d223 2
a224 1
	ret = server_response_http(clt, 200, media, st->st_size);
d271 1
a271 1
server_file_index(struct httpd *env, struct client *clt)
a282 1
	struct stat		  st;
d284 1
a284 1
	time_t			  t;
d300 3
d334 1
a334 1
		    fstatat(fd, dp->d_name, &st, 0) == -1) {
d339 1
a339 1
		t = st.st_mtime;
d347 1
a347 1
		} else if (S_ISDIR(st.st_mode)) {
d354 1
a354 1
		} else if (S_ISREG(st.st_mode)) {
d358 1
a358 1
			    MAX(namewidth, 0), " ", tmstr, st.st_size) == -1)
d374 2
a375 1
	ret = server_response_http(clt, 200, media, EVBUFFER_LENGTH(evb));
@


1.32
log
@When opening directories, re-match the location after the index file
has been appended.  This allows to use a fastcgi target as the default
index, for example index.php.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.31 2014/08/06 11:24:12 reyk Exp $	*/
d49 1
a49 2
int	 server_file_access(struct httpd *, struct client *, char *,
	    size_t, struct stat *);
d57 1
a57 1
    char *path, size_t len, struct stat *st)
d61 1
a61 1
	struct stat		 stb;
d69 1
a69 1
	} else if (stat(path, st) == -1) {
d71 1
a71 1
	} else if (S_ISDIR(st->st_mode)) {
d113 1
a113 1
		ret = server_file_access(env, clt, path, len, &stb);
d129 1
a129 1
	} else if (!S_ISREG(st->st_mode)) {
d135 1
a135 1
	return (server_file_request(env, clt, path, st));
a157 1
	struct stat		 st;
d172 1
a172 2
	if ((ret = server_file_access(env, clt, path, sizeof(path),
	    &st)) > 0) {
@


1.31
log
@The watermark exposed a bug in server_write that broke keep-alive
support.  Instead of calling server_close from server_write, we have
to proceed to the next connection by calling the error handler.

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.30 2014/08/06 09:36:31 reyk Exp $	*/
d49 3
a51 1
int	 server_file_access(struct client *, char *, size_t,
d54 1
d57 2
a58 2
server_file_access(struct client *clt, char *path, size_t len,
    struct stat *st)
d64 1
a67 9
	switch (desc->http_method) {
	case HTTP_METHOD_GET:
	case HTTP_METHOD_HEAD:
		break;
	default:
		/* Other methods are not allowed */
		return (405);
	}

d79 1
a79 1
		if (!len) {
d91 2
a92 2
			free(desc->http_path);
			desc->http_path = newpath;
d98 11
a108 1
		/* Otherwise append the default index file */
d114 2
a115 2
		/* Check again but set len to 0 to avoid recursion */
		if (server_file_access(clt, path, 0, &stb) == 404) {
d126 2
a127 3
		} else {
			/* return updated stat from index file */
			memcpy(st, &stb, sizeof(*st));
d129 1
d136 1
a136 1
	return (0);
d156 1
a156 1
	struct media_type	*media;
d158 1
a158 2
	int			 fd = -1, ret, code = 500;
	char			 path[MAXPATHLEN];
d161 3
d166 3
a168 1
	    srv_conf->root, desc->http_path) >= sizeof(path)) {
d174 4
a177 3
	if ((ret = server_file_access(clt, path, sizeof(path), &st)) != 0) {
		code = ret;
		errstr = desc->http_path;
d181 38
a218 3
	if (S_ISDIR(st.st_mode)) {
		/* List directory index */
		return (server_file_index(env, clt));
d226 1
a226 1
	ret = server_response_http(clt, 200, media, st.st_size);
d281 1
d289 5
d410 1
a410 1
	server_abort_http(clt, 500, desc->http_path);
@


1.31.4.1
log
@httpd was developed very rapidly in the weeks before 5.6 release,
and it has a few flaws.  It would be nice to get these flaws fully
remediated before the next release, and that requires the community
to want to use it.
Therefore here is a "jumbo" patch that brings in the most important fixes.

committing on behalf of reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.31 2014/08/06 11:24:12 reyk Exp $	*/
d49 1
a49 2
int	 server_file_access(struct httpd *, struct client *, char *, size_t);
int	 server_file_request(struct httpd *, struct client *, char *,
d51 1
a51 2
int	 server_file_index(struct httpd *, struct client *, struct stat *);
int	 server_file_method(struct client *);
d54 2
a55 2
server_file_access(struct httpd *env, struct client *clt,
    char *path, size_t len)
d57 1
a57 1
	struct http_descriptor	*desc = clt->clt_descreq;
d59 1
a59 1
	struct stat		 st;
a60 1
	int			 ret;
d64 9
d75 1
a75 1
	} else if (stat(path, &st) == -1) {
d77 1
a77 1
	} else if (S_ISDIR(st.st_mode)) {
d84 1
a84 1
		if (desc->http_path_alias != NULL) {
d96 2
a97 2
			/* Path alias will be used for the redirection */
			desc->http_path_alias = newpath;
d103 1
a103 11
		/* Append the default index file to the location */
		if (asprintf(&newpath, "%s%s", desc->http_path,
		    srv_conf->index) == -1)
			return (500);
		desc->http_path_alias = newpath;
		if (server_getlocation(clt, newpath) != srv_conf) {
			/* The location has changed */
			return (server_file(env, clt));
		}

		/* Otherwise append the default index file to the path */
d109 2
a110 2
		ret = server_file_access(env, clt, path, len);
		if (ret == 404) {
d121 3
a123 2

			return (server_file_index(env, clt, &st));
d125 1
a125 2
		return (ret);
	} else if (!S_ISREG(st.st_mode)) {
d131 1
a131 1
	return (server_file_request(env, clt, path, &st));
d149 1
a149 1
	struct http_descriptor	*desc = clt->clt_descreq;
d151 3
d155 1
a155 5
	const char		*errstr = NULL;
	int			 ret = 500;

	if (srv_conf->flags & SRVFLAG_FCGI)
		return (server_fcgi(env, clt));
d159 1
a159 3
	    srv_conf->root,
	    desc->http_path_alias != NULL ?
	    desc->http_path_alias : desc->http_path) >= sizeof(path)) {
d165 3
a167 3
	if ((ret = server_file_access(env, clt, path, sizeof(path))) > 0) {
		errstr = desc->http_path_alias != NULL ?
		    desc->http_path_alias : desc->http_path;
d171 3
a173 38
	return (ret);

 abort:
	if (errstr == NULL)
		errstr = strerror(errno);
	server_abort_http(clt, ret, errstr);
	return (-1);
}

int
server_file_method(struct client *clt)
{
	struct http_descriptor	*desc = clt->clt_descreq;

	switch (desc->http_method) {
	case HTTP_METHOD_GET:
	case HTTP_METHOD_HEAD:
		return (0);
	default:
		/* Other methods are not allowed */
		errno = EACCES;
		return (405);
	}
	/* NOTREACHED */
}

int
server_file_request(struct httpd *env, struct client *clt, char *path,
    struct stat *st)
{
	struct server_config	*srv_conf = clt->clt_srv_conf;
	struct media_type	*media;
	const char		*errstr = NULL;
	int			 fd = -1, ret, code = 500;

	if ((ret = server_file_method(clt)) != 0) {
		code = ret;
		goto abort;
d181 1
a181 2
	ret = server_response_http(clt, 200, media, st->st_size,
	    MIN(time(NULL), st->st_mtim.tv_sec));
d228 1
a228 1
server_file_index(struct httpd *env, struct client *clt, struct stat *st)
d232 1
a232 1
	struct http_descriptor	 *desc = clt->clt_descreq;
a235 1
	int			  code = 500;
d239 1
d241 1
a241 6
	time_t			  t, dir_mtime;

	if ((ret = server_file_method(clt)) != 0) {
		code = ret;
		goto abort;
	}
a251 3
	/* Save last modification time */
	dir_mtime = MIN(time(NULL), st->st_mtim.tv_sec);

d263 1
a263 1
	    "sans-serif; }\nhr { border: 0; border-bottom: 1px dashed; }\n";
d283 1
a283 1
		    fstatat(fd, dp->d_name, st, 0) == -1) {
d288 1
a288 1
		t = st->st_mtime;
d296 1
a296 1
		} else if (S_ISDIR(st->st_mode)) {
d303 1
a303 1
		} else if (S_ISREG(st->st_mode)) {
d307 1
a307 1
			    MAX(namewidth, 0), " ", tmstr, st->st_size) == -1)
d323 1
a323 2
	ret = server_response_http(clt, 200, media, EVBUFFER_LENGTH(evb),
	    dir_mtime);
d359 1
a359 1
	server_abort_http(clt, code, desc->http_path);
a372 8
	if (error & EVBUFFER_ERROR) {
		if (errno == EFBIG) {
			bufferevent_enable(bev, EV_READ);
			return;
		}
		server_close(clt, "buffer event error");
		return;
	}
d374 1
a374 1
		bufferevent_disable(bev, EV_READ|EV_WRITE);
d399 5
a403 1
	server_close(clt, "unknown event error");
@


1.30
log
@Adjust the read/write watermarks according to the TCP send buffer.
This fixes sending of large files.  Previously, httpd was reading the
input file too quickly and could run out of memory when filling the
input buffer.

Found by jsg@@
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.29 2014/08/04 17:43:20 reyk Exp $	*/
a377 7
		dst = EVBUFFER_OUTPUT(clt->clt_bev);
		if (EVBUFFER_LENGTH(dst)) {
			/* Finish writing all data first */
			bufferevent_enable(clt->clt_bev, EV_WRITE);
			return;
		}

d388 8
@


1.29
log
@Redirect to https:// if SSL/TLS is enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.28 2014/08/04 11:09:25 reyk Exp $	*/
d203 4
@


1.28
log
@httpd doesn't support SSL/TLS yet, remove the remaining bits.
The secrect plan is to add it later using the ressl wrapper library.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.27 2014/08/03 22:47:25 reyk Exp $	*/
d92 2
a93 1
			if (asprintf(&newpath, "http://%s%s/",
@


1.27
log
@Only allow GET and HEAD for static files or return 405.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.26 2014/08/03 22:38:12 reyk Exp $	*/
a44 2

#include <openssl/ssl.h>
@


1.26
log
@Also write log messages, like 404 Not Found, on error.  This is a bit
tricky because we couldn't guarantee a sane state after
server_response_http() so fail hard afterwards and close the connection.

ok doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.25 2014/08/03 11:16:10 reyk Exp $	*/
d65 9
@


1.25
log
@Split fastcgi socket path and document root option and add the
SCRIPT_FILENAME CGI param with a prepended root.  This fixes php-fpm
that expects SCRIPT_FILENAME and also works with slowcgi if you
configure the root correctly.  For example, if SCRIPT_NAME and
REQUEST_URI are /php/index.php, root is /htdocs, SCRIPT_FILENAME will
be /htdocs/php/index.php.  As tested and discussed with florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.24 2014/08/02 09:54:13 reyk Exp $	*/
d145 1
a145 1
	int			 fd = -1, ret;
d152 2
a153 3
		/* Do not echo the uncanonicalized path */
		server_abort_http(clt, 500, desc->http_path);
		return (-1);
d158 3
a160 2
		server_abort_http(clt, ret, desc->http_path);
		return (-1);
d170 1
a170 1
		goto fail;
d205 4
d211 1
a211 1
	server_abort_http(clt, 500, errstr);
d234 1
a234 1
		goto fail;
d238 1
a238 1
		goto fail;
d241 1
a241 1
		goto fail;
d244 1
a244 1
		goto fail;
d305 1
a305 1
		goto fail;
d308 1
d326 1
a337 1

d339 4
@


1.24
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.23 2014/08/02 09:46:51 reyk Exp $	*/
d151 1
a151 1
	    srv_conf->path, desc->http_path) >= sizeof(path)) {
d229 1
a229 1
	    srv_conf->path, desc->http_path) >= sizeof(path))
@


1.23
log
@scandir(3)-based directory auto index didn't work on NFS because the
file system is not filling in d_type properly.  Using st_mode from the
stat call fixes the problem, eg. S_ISDIR(st.st_mode) instead of
dp->d_type == DT_DIR.  Pointed out by pelikan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.22 2014/07/31 17:55:09 reyk Exp $	*/
d273 1
a273 1
		localtime_r(&t, &tm);			
@


1.22
log
@some fastcgi improvements:
- DPRINTF instead of log_info for internal debugging.
- submit QUERY_STRING, if it exists
- use a proper function to create an HTTP header.
- use server_file_error() to detect EOF and fastcgi stream errors.
- disable keep-alive/persist for now until we have a reliable way to
get the content length from the cgi response or support chunked
encoding.

"Cool, jep" florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.21 2014/07/31 14:25:14 reyk Exp $	*/
d280 1
a280 1
		} else if (dp->d_type == DT_DIR) {
d287 1
a287 1
		} else if (dp->d_type == DT_REG) {
@


1.21
log
@One bufferevent can be shared by file and fcgi.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.20 2014/07/31 13:28:15 reyk Exp $	*/
a53 1
void	 server_file_error(struct bufferevent *, short, void *);
d180 1
a180 1
		return (0);
d201 2
d313 1
a313 1
		return (0);
d329 2
@


1.20
log
@Rename the "docroot" variable to "path" because it will be used for
either files or the fastcgi socket (and there's no need to use a union yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.19 2014/07/30 07:09:38 reyk Exp $	*/
d187 2
a188 2
	if (clt->clt_file != NULL)
		bufferevent_free(clt->clt_file);
d190 1
a190 1
	clt->clt_file = bufferevent_new(clt->clt_fd, server_read,
d192 1
a192 1
	if (clt->clt_file == NULL) {
d197 1
a197 1
	bufferevent_settimeout(clt->clt_file,
d199 1
a199 1
	bufferevent_enable(clt->clt_file, EV_READ);
@


1.19
log
@Reserve an extra file descriptor per connection instead of per
request.  This fixes fd accounting with persistent connections and
reduces the complexity of the implementation.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.18 2014/07/29 16:17:28 reyk Exp $	*/
d152 1
a152 1
	    srv_conf->docroot, desc->http_path) >= sizeof(path)) {
d228 1
a228 1
	    srv_conf->docroot, desc->http_path) >= sizeof(path))
@


1.18
log
@Add extended directory index options: "[no] index" and "[no] auto index".
The option "directory auto index" implements basic directory listing
and is turned off by default.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.17 2014/07/26 22:38:38 reyk Exp $	*/
a172 3
	/* File descriptor is opened, decrement inflight counter */
	server_inflight_dec(clt, __func__);

a233 3

	/* File descriptor is opened, decrement inflight counter */
	server_inflight_dec(clt, __func__);
@


1.17
log
@Remove redundant slash
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.16 2014/07/25 23:23:39 reyk Exp $	*/
d41 2
d51 1
a51 1
int	 server_file_access(struct http_descriptor *, char *, size_t,
d53 1
d57 1
a57 1
server_file_access(struct http_descriptor *desc, char *path, size_t len,
d60 5
a64 1
	char	*newpath;
d72 5
a76 1
		/* XXX Should we support directory listing? */
d97 1
a97 1
		if (strlcat(path, HTTPD_INDEX, len) >= len) {
d103 15
a117 1
		return (server_file_access(desc, path, 0, st));
d159 1
a159 1
	if ((ret = server_file_access(desc, path, sizeof(path), &st)) != 0) {
d164 5
d210 132
@


1.16
log
@It is recommended to use a URL in the Location header of 3xx
responses.  To accomplish this, add some semantics to retrieve the
server host name of a connection: either IP, IP:PORT (if not 80) or
[IP6]:PORT, or Host value (if valid).
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.15 2014/07/25 21:29:58 reyk Exp $	*/
d126 1
a126 1
	if ((size_t)snprintf(path, sizeof(path), "%s/%s",
@


1.15
log
@Canonicalize the request path once without the docroot and prepend the
docroot only only when it's needed.  Suggested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.14 2014/07/25 20:13:06 reyk Exp $	*/
d75 2
a76 1
			if (asprintf(&newpath, "%s/", desc->http_path) == -1)
@


1.14
log
@Don't leak docroot in the error message if the default index file is missing.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.13 2014/07/25 13:10:18 reyk Exp $	*/
d57 1
d59 1
d75 4
a78 7
			/* Remove the document root to get the relative URL */
			if (canonicalize_path(NULL,
			    desc->http_path, path, len) == NULL ||
			    strlcat(path, "/", len) >= len) {
				errno = EINVAL;
				goto fail;
			}
d91 1
a91 2
		if (server_file_access(desc, path, 0, st) != 0)
			goto fail;
a100 4
	/* Remove the document root */
	if (len && canonicalize_path(NULL, desc->http_path, path, len) == NULL)
		return (500);

d124 3
a126 2
	if (canonicalize_path(srv_conf->docroot,
	    desc->http_path, path, sizeof(path)) == NULL) {
d128 1
a128 1
		server_abort_http(clt, 500, "invalid request path");
d134 1
a134 1
		server_abort_http(clt, ret, path);
@


1.13
log
@Split server and server_config.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.12 2014/07/25 12:46:23 reyk Exp $	*/
d92 2
a93 1
		return (server_file_access(desc, path, 0, st));
@


1.12
log
@Rename a field, needed later, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.11 2014/07/25 12:42:05 reyk Exp $	*/
d122 1
a122 1
	struct server		*srv = clt->clt_srv;
d129 1
a129 1
	if (canonicalize_path(srv->srv_conf.docroot,
d174 1
a174 1
	    srv->srv_conf.timeout.tv_sec, srv->srv_conf.timeout.tv_sec);
@


1.11
log
@Move the docroot into the server block.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.10 2014/07/23 22:20:37 reyk Exp $	*/
d122 1
a122 1
	struct server		*srv = clt->clt_server;
@


1.10
log
@The default index page shouldn't be a directory.  It's a 500.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.9 2014/07/23 22:18:57 reyk Exp $	*/
d129 1
a129 1
	if (canonicalize_path(HTTPD_DOCROOT,
@


1.9
log
@Don't expose the docroot on error.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.8 2014/07/23 21:43:12 reyk Exp $	*/
d67 1
a67 1
			errno = EACCES;
@


1.8
log
@First attempt at verifying the request path and the access
permissions.  We also have to redirect with 301 if a directory name
was requested without the trailing slash.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.7 2014/07/23 19:03:56 reyk Exp $	*/
d102 4
@


1.7
log
@Add canonicalize_path() to canonicalize the requested URL path.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.6 2014/07/16 10:25:28 reyk Exp $	*/
d49 2
d54 61
a124 5
	/* 
	 * XXX This is not ready XXX
	 * XXX Don't expect anything from this code yet,
	 */

d127 2
a128 1
		server_abort_http(clt, 404, path);
d132 3
a134 20
	/* Prepend default index file */
	if (path[strlen(path) - 1] == '/' &&
	    strlcat(path, HTTPD_INDEX, sizeof(path)) >= sizeof(path)) {
		server_abort_http(clt, 404, path);
		return (-1);
	}

	if (access(path, R_OK) == -1) {
		strlcpy(path, desc->http_path, sizeof(path));
		switch (errno) {
		case EACCES:
			server_abort_http(clt, 403, path);
			break;
		case ENOENT:
			server_abort_http(clt, 404, path);
			break;
		default:
			server_abort_http(clt, 500, path);
			break;
		}
d138 2
a139 1
	if ((fd = open(path, O_RDONLY)) == -1 || fstat(fd, &st) == -1)
@


1.6
log
@Implement file descriptor accounting.  The concept was taken from
relayd but had to be adjusted for httpd.  It now handles single-pass
HTTP connections, persistent connections with multiple requests, and
body-less HEAD requests.  With input from benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.5 2014/07/15 09:51:06 reyk Exp $	*/
d67 12
a78 6
	strlcpy(path, "/htdocs", sizeof(path));
	if (desc->http_path[0] != '/')
		strlcat(path, "/", sizeof(path));
	strlcat(path, desc->http_path, sizeof(path));
	if (desc->http_path[strlen(desc->http_path) - 1] == '/')
		strlcat(path, "index.html", sizeof(path));
@


1.5
log
@don't diplay the full path in error messages
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.4 2014/07/14 00:19:48 reyk Exp $	*/
d49 2
d93 3
d112 1
d114 1
a114 1
	    server_write, server_error, clt);
d123 1
d131 43
@


1.4
log
@first step towards keep-alive/persistent connections support
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.3 2014/07/13 15:07:50 reyk Exp $	*/
d73 1
@


1.3
log
@Finish writing the output before closing the connection
(adopted from relayd).
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.2 2014/07/13 14:17:37 reyk Exp $	*/
d50 1
a50 1
server_response(struct httpd *env, struct client *clt)
a53 1
	struct kv		*ct, *cl;
d56 1
a56 1
	int			 fd = -1;
a59 3
	if (desc->http_path == NULL)
		goto fail;

a89 16
	kv_purge(&desc->http_headers);

	/* Add error codes */
	if (kv_setkey(&desc->http_pathquery, "200") == -1 ||
	    kv_set(&desc->http_pathquery, "%s",
	    server_httperror_byid(200)) == -1)
		goto fail;		

	/* Add headers */
	if (kv_add(&desc->http_headers, "Server", HTTPD_SERVERNAME) == NULL ||
	    kv_add(&desc->http_headers, "Connection", "close") == NULL ||
	    (ct = kv_add(&desc->http_headers, "Content-Type", NULL)) == NULL ||
	    (cl = kv_add(&desc->http_headers, "Content-Length", NULL)) == NULL)
		goto fail;

	/* Set content type */
d91 11
a101 14
	if (kv_set(ct, "%s/%s",
	    media == NULL ? "application" : media->media_type,
	    media == NULL ? "octet-stream" : media->media_subtype) == -1)
		goto fail;

	/* Set content length */
	if (kv_set(cl, "%ld", st.st_size) == -1)
		goto fail;

	if (server_writeresponse_http(clt) == -1 ||
	    server_bufferevent_print(clt, "\r\n") == -1 ||
	    server_writeheader_http(clt) == -1 ||
	    server_bufferevent_print(clt, "\r\n") == -1)
		goto fail;
d104 2
@


1.2
log
@Add support for media types (aka. MIME types): the types section is
compatible to nginx' mime.types file which can be included directly.
If not present, use a few built-in defaults for html, css, txt, jpeg,
gif, png, and js.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_file.c,v 1.1 2014/07/12 23:34:54 reyk Exp $	*/
d136 1
a136 1
	bufferevent_enable(clt->clt_file, EV_READ|EV_WRITE);
@


1.1
log
@Add httpd(8), an attempt to turn the relayd(8) codebase into a simple
web server.  It is not finished yet and I just started it today, but
the goal is to provide an HTTP server that a) provides minimal
features, b) serves static files, c) provides FastCGI support, and d)
follows common coding practices of OpenBSD.

It will neither support plugins, nor custom memory allocators, EBCDIC
support, PCRE or any other things that can be found elsewhere.
httpd(8) is not intended to provide a fully-featured replacement for
nginx(8) or the Apache, but it will provide enough functionality that
is needed in the OpenBSD base system.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
a50 1
server_response(struct client *clt)
d54 2
a55 1
	struct kv		*kv;
a93 1
	/* XXX verify results XXX */
d95 24
a118 6
	kv_add(&desc->http_headers, "Server", HTTPD_SERVERNAME);
	kv_add(&desc->http_headers, "Connection", "close");
	if ((kv = kv_add(&desc->http_headers, "Content-Length", NULL)) != NULL)
		kv_set(kv, "%ld", st.st_size);
	kv_setkey(&desc->http_pathquery, "200");
	kv_set(&desc->http_pathquery, "%s", server_httperror_byid(200));
@

