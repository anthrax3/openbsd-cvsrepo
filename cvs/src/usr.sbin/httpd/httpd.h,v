head	1.132;
access;
symbols
	OPENBSD_6_1:1.131.0.4
	OPENBSD_6_1_BASE:1.131
	OPENBSD_6_0:1.104.0.2
	OPENBSD_6_0_BASE:1.104
	OPENBSD_5_9:1.102.0.2
	OPENBSD_5_9_BASE:1.102
	OPENBSD_5_8:1.96.0.4
	OPENBSD_5_8_BASE:1.96
	OPENBSD_5_7:1.81.0.2
	OPENBSD_5_7_BASE:1.81
	OPENBSD_5_6:1.51.0.2
	OPENBSD_5_6_BASE:1.51;
locks; strict;
comment	@ * @;


1.132
date	2017.05.28.10.37.26;	author benno;	state Exp;
branches;
next	1.131;
commitid	uoabWwRtZPFIlwfI;

1.131
date	2017.03.25.17.25.34;	author claudio;	state Exp;
branches;
next	1.130;
commitid	43NsM2S8LTb1McoD;

1.130
date	2017.02.07.12.27.42;	author reyk;	state Exp;
branches;
next	1.129;
commitid	39LWvR7k2X9Ou0Vd;

1.129
date	2017.02.03.08.23.46;	author guenther;	state Exp;
branches;
next	1.128;
commitid	RkgZAc0srXet0WqL;

1.128
date	2017.02.02.22.19.59;	author reyk;	state Exp;
branches;
next	1.127;
commitid	wAyoqiU7jG1NUkqx;

1.127
date	2017.01.31.14.39.47;	author reyk;	state Exp;
branches;
next	1.126;
commitid	IPZeYDCn5vLI9sJB;

1.126
date	2017.01.31.12.21.27;	author reyk;	state Exp;
branches;
next	1.125;
commitid	W6dCvmsAWEvXxw18;

1.125
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.124;
commitid	eA8b246voAapPTkX;

1.124
date	2016.11.17.14.52.48;	author jsing;	state Exp;
branches;
next	1.123;
commitid	9adJPMuYYFWkfsUD;

1.123
date	2016.11.06.10.49.38;	author beck;	state Exp;
branches;
next	1.122;
commitid	49Xfy4fsPamn6Ga1;

1.122
date	2016.10.12.10.57.30;	author reyk;	state Exp;
branches;
next	1.121;
commitid	bwf7lQ6uLNV5tXt6;

1.121
date	2016.10.05.16.58.19;	author reyk;	state Exp;
branches;
next	1.120;
commitid	UGOrmt0fCkvkKrPU;

1.120
date	2016.09.28.12.01.04;	author reyk;	state Exp;
branches;
next	1.119;
commitid	iF3bh0NN3JRVXz7J;

1.119
date	2016.09.03.14.44.21;	author reyk;	state Exp;
branches;
next	1.118;
commitid	n0F9VKkYrh9A46uy;

1.118
date	2016.09.02.11.25.14;	author reyk;	state Exp;
branches;
next	1.117;
commitid	GjKzhVfFFKgNZ4YN;

1.117
date	2016.09.01.11.13.18;	author florian;	state Exp;
branches;
next	1.116;
commitid	RC3HXj7tjvlwnsNW;

1.116
date	2016.09.01.10.59.38;	author reyk;	state Exp;
branches;
next	1.115;
commitid	a0vgTMcaG5L6YvdV;

1.115
date	2016.09.01.09.47.03;	author rzalamena;	state Exp;
branches;
next	1.114;
commitid	kOwNifk43Y8HrMUc;

1.114
date	2016.08.30.14.31.53;	author rzalamena;	state Exp;
branches;
next	1.113;
commitid	aFS6ntUbudjiLont;

1.113
date	2016.08.30.13.37.10;	author rzalamena;	state Exp;
branches;
next	1.112;
commitid	gQIP66uAaKMRFcyR;

1.112
date	2016.08.30.10.54.42;	author florian;	state Exp;
branches;
next	1.111;
commitid	DrhLELl2yXwxn1oo;

1.111
date	2016.08.27.11.13.16;	author rzalamena;	state Exp;
branches;
next	1.110;
commitid	9y7IlhMzSGJO9BSx;

1.110
date	2016.08.26.12.24.21;	author rzalamena;	state Exp;
branches;
next	1.109;
commitid	DjkH3CPbmaCOtzZ5;

1.109
date	2016.08.26.10.46.39;	author rzalamena;	state Exp;
branches;
next	1.108;
commitid	JNQbvPaxb6nMCsuY;

1.108
date	2016.08.22.15.02.18;	author jsing;	state Exp;
branches;
next	1.107;
commitid	kgucYc6Cn9YK2ZhC;

1.107
date	2016.08.16.18.41.57;	author tedu;	state Exp;
branches;
next	1.106;
commitid	eyeRGwF24702KeRh;

1.106
date	2016.08.15.16.12.34;	author jsing;	state Exp;
branches;
next	1.105;
commitid	ywDK1QHdQbsHLFgT;

1.105
date	2016.08.15.13.48.24;	author jsing;	state Exp;
branches;
next	1.104;
commitid	el084N3wYoLArEkM;

1.104
date	2016.07.13.16.35.47;	author jsing;	state Exp;
branches;
next	1.103;
commitid	02rKn2WBJ6A1ygkh;

1.103
date	2016.04.28.14.20.11;	author jsing;	state Exp;
branches;
next	1.102;
commitid	QyxLnTjK6WHT3hH3;

1.102
date	2015.12.02.15.13.00;	author reyk;	state Exp;
branches;
next	1.101;
commitid	VcVtArSBXuXwQYz0;

1.101
date	2015.11.23.20.56.14;	author reyk;	state Exp;
branches;
next	1.100;
commitid	V1t7bAFyH2Xn6Kqj;

1.100
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.99;
commitid	T3JBYxNT0thPuavp;

1.99
date	2015.11.21.12.40.59;	author reyk;	state Exp;
branches;
next	1.98;
commitid	NAdDmgxUAp5Vg17B;

1.98
date	2015.09.07.14.46.24;	author reyk;	state Exp;
branches;
next	1.97;
commitid	3N8ZbJM1mbV6AuOV;

1.97
date	2015.08.20.13.00.23;	author reyk;	state Exp;
branches;
next	1.96;
commitid	WDQybNKi4LiEFw8K;

1.96
date	2015.08.03.11.45.17;	author florian;	state Exp;
branches;
next	1.95;
commitid	R0hlkHQJt4QQvq7o;

1.95
date	2015.07.31.00.10.51;	author benno;	state Exp;
branches;
next	1.94;
commitid	fAnDDuLHMOr8xOWK;

1.94
date	2015.07.29.22.03.41;	author reyk;	state Exp;
branches;
next	1.93;
commitid	rol6YjSk5cC38ac4;

1.93
date	2015.07.29.20.03.14;	author florian;	state Exp;
branches;
next	1.92;
commitid	UvkQRTHkUu4OhiEw;

1.92
date	2015.07.19.05.17.27;	author reyk;	state Exp;
branches;
next	1.91;
commitid	jdqdR7UPKnGDga2T;

1.91
date	2015.07.18.22.19.50;	author reyk;	state Exp;
branches;
next	1.90;
commitid	g5sVLwTWWtLsXmAh;

1.90
date	2015.07.18.06.00.43;	author reyk;	state Exp;
branches;
next	1.89;
commitid	GYrjpgr4p814WbAx;

1.89
date	2015.07.18.05.41.18;	author florian;	state Exp;
branches;
next	1.88;
commitid	2Fg8acs1mTRftiTA;

1.88
date	2015.07.16.16.29.25;	author florian;	state Exp;
branches;
next	1.87;
commitid	lZ8k3sH29eTMhooJ;

1.87
date	2015.07.16.04.46.07;	author reyk;	state Exp;
branches;
next	1.86;
commitid	de3K0YI9aZhD0FkR;

1.86
date	2015.07.15.23.16.38;	author reyk;	state Exp;
branches;
next	1.85;
commitid	RzY5FSK1wD1o0SL4;

1.85
date	2015.07.15.16.00.39;	author jsing;	state Exp;
branches;
next	1.84;
commitid	fH3yCV9YOBuXQu46;

1.84
date	2015.06.23.15.23.14;	author reyk;	state Exp;
branches;
next	1.83;
commitid	KmQD0QhuAUl1XRCr;

1.83
date	2015.05.20.09.28.47;	author kettenis;	state Exp;
branches;
next	1.82;
commitid	YKbXEhIZlwjrozF0;

1.82
date	2015.03.15.22.08.45;	author florian;	state Exp;
branches;
next	1.81;
commitid	CdJAqROMMjgUOnXV;

1.81
date	2015.02.23.18.43.18;	author reyk;	state Exp;
branches;
next	1.80;
commitid	xe3hvTl4EsdtcfCj;

1.80
date	2015.02.12.10.05.29;	author reyk;	state Exp;
branches;
next	1.79;
commitid	eiL3BkcA1VXRVRJ2;

1.79
date	2015.02.12.04.40.23;	author jsing;	state Exp;
branches;
next	1.78;
commitid	4hspTe8KgQAkgFb0;

1.78
date	2015.02.10.08.12.29;	author florian;	state Exp;
branches;
next	1.77;
commitid	mWYYH04t95KXgJsq;

1.77
date	2015.02.07.23.56.02;	author reyk;	state Exp;
branches;
next	1.76;
commitid	XXpdSU1rkGa1nBd8;

1.76
date	2015.02.07.06.26.28;	author jsing;	state Exp;
branches;
next	1.75;
commitid	Jsq1AV9W6epuXQBP;

1.75
date	2015.02.07.01.23.12;	author reyk;	state Exp;
branches;
next	1.74;
commitid	tJajgOHQ1aZRGbKl;

1.74
date	2015.02.06.13.05.20;	author reyk;	state Exp;
branches;
next	1.73;
commitid	WzsLdaJsWwlcIzRK;

1.73
date	2015.01.21.22.23.24;	author reyk;	state Exp;
branches;
next	1.72;
commitid	TdBP3Ps5E1MgPmyk;

1.72
date	2015.01.21.22.21.05;	author reyk;	state Exp;
branches;
next	1.71;
commitid	64Zc6bef54Vu2Noy;

1.71
date	2015.01.19.20.00.07;	author florian;	state Exp;
branches;
next	1.70;
commitid	uDWn7Rj546an5NG2;

1.70
date	2015.01.19.19.37.50;	author reyk;	state Exp;
branches;
next	1.69;
commitid	95e2Z6BqzOOfEsll;

1.69
date	2015.01.18.14.01.17;	author florian;	state Exp;
branches;
next	1.68;
commitid	7n1dHfzjQzsDnx3e;

1.68
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	Uu5nFG3wCl0LACBb;

1.67
date	2015.01.13.09.21.15;	author reyk;	state Exp;
branches;
next	1.66;
commitid	vlRoyiZgaC5QvCo7;

1.66
date	2015.01.04.22.23.58;	author chrisz;	state Exp;
branches;
next	1.65;
commitid	PxQkOIiHP7NqIPYy;

1.65
date	2015.01.02.19.09.52;	author reyk;	state Exp;
branches;
next	1.64;
commitid	bgwsdJzq8GBjl4es;

1.64
date	2014.12.12.14.45.59;	author reyk;	state Exp;
branches;
next	1.63;
commitid	j2F3LZ1OyONol7u9;

1.63
date	2014.11.11.15.54.45;	author beck;	state Exp;
branches;
next	1.62;
commitid	ki9qbAAMZ7dFJTRL;

1.62
date	2014.11.03.18.43.24;	author bluhm;	state Exp;
branches;
next	1.61;
commitid	awoa44OYi1wnC5N7;

1.61
date	2014.10.31.13.49.52;	author jsing;	state Exp;
branches;
next	1.60;
commitid	ezNS1yQDKKs563EI;

1.60
date	2014.10.22.09.48.03;	author reyk;	state Exp;
branches;
next	1.59;
commitid	6UIQ1JUjIEqOoSI1;

1.59
date	2014.09.10.15.39.57;	author reyk;	state Exp;
branches;
next	1.58;
commitid	BrSDFsqPx9KchyVo;

1.58
date	2014.09.05.10.04.20;	author reyk;	state Exp;
branches;
next	1.57;
commitid	L018oMJIofTIKQBT;

1.57
date	2014.09.02.16.20.41;	author reyk;	state Exp;
branches;
next	1.56;
commitid	Z5PKhfXhMri1amPw;

1.56
date	2014.09.01.09.32.43;	author reyk;	state Exp;
branches;
next	1.55;
commitid	jMu1buTp6ZpC9q0x;

1.55
date	2014.08.29.13.01.46;	author reyk;	state Exp;
branches;
next	1.54;
commitid	s1q2vKQd3ZNYgiRk;

1.54
date	2014.08.21.19.23.10;	author chrisz;	state Exp;
branches;
next	1.53;
commitid	JCs4fDUGf9JXsJFG;

1.53
date	2014.08.13.16.04.28;	author reyk;	state Exp;
branches;
next	1.52;
commitid	rO4nAEntB2c9vXlM;

1.52
date	2014.08.08.18.29.42;	author reyk;	state Exp;
branches;
next	1.51;
commitid	J4bMyiFa6dPdfodH;

1.51
date	2014.08.06.18.21.14;	author reyk;	state Exp;
branches
	1.51.2.1;
next	1.50;
commitid	jZUEHtimlVJa4lx5;

1.50
date	2014.08.06.16.09.02;	author jsing;	state Exp;
branches;
next	1.49;
commitid	CZdtcBfBkirUWTpH;

1.49
date	2014.08.06.15.08.04;	author florian;	state Exp;
branches;
next	1.48;
commitid	JiDxX0IDmc7NLOCZ;

1.48
date	2014.08.06.09.36.31;	author reyk;	state Exp;
branches;
next	1.47;
commitid	3LE5yBvWStUuSW90;

1.47
date	2014.08.06.02.04.42;	author jsing;	state Exp;
branches;
next	1.46;
commitid	Wq3y58SpTrH6PeRm;

1.46
date	2014.08.05.18.01.10;	author reyk;	state Exp;
branches;
next	1.45;
commitid	bNgJHQQ6lNzksAJO;

1.45
date	2014.08.05.16.30.35;	author reyk;	state Exp;
branches;
next	1.44;
commitid	JpK6oqkkh2jiIWCI;

1.44
date	2014.08.05.15.36.59;	author reyk;	state Exp;
branches;
next	1.43;
commitid	0eZ0KmX2vQuZV9Ts;

1.43
date	2014.08.05.09.24.21;	author jsg;	state Exp;
branches;
next	1.42;
commitid	NFtWiwbcZQWHRBUA;

1.42
date	2014.08.04.18.12.15;	author reyk;	state Exp;
branches;
next	1.41;
commitid	x0mQG5OVVgk9h47j;

1.41
date	2014.08.04.17.38.12;	author reyk;	state Exp;
branches;
next	1.40;
commitid	QN0gng3yApfUkUG0;

1.40
date	2014.08.04.15.49.28;	author reyk;	state Exp;
branches;
next	1.39;
commitid	LDlAyIlUWDBjADa5;

1.39
date	2014.08.04.14.49.24;	author reyk;	state Exp;
branches;
next	1.38;
commitid	vp0mWPeKkmrTbblJ;

1.38
date	2014.08.04.06.35.10;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	jTuUMNRcoR31PL9B;

1.37
date	2014.08.03.20.39.40;	author reyk;	state Exp;
branches;
next	1.36;
commitid	SI4ST45AyhzT510m;

1.36
date	2014.08.03.12.26.19;	author reyk;	state Exp;
branches;
next	1.35;
commitid	nLaH9MjCgoWopkfz;

1.35
date	2014.08.03.11.16.10;	author reyk;	state Exp;
branches;
next	1.34;
commitid	fIgJJaAKavK3V1Ms;

1.34
date	2014.08.03.10.26.43;	author reyk;	state Exp;
branches;
next	1.33;
commitid	J4iRjIQasNlCySVe;

1.33
date	2014.08.02.21.21.47;	author doug;	state Exp;
branches;
next	1.32;
commitid	eYHmkmq5eeXpnLSo;

1.32
date	2014.08.02.17.05.18;	author florian;	state Exp;
branches;
next	1.31;
commitid	Jee6bm4wBB35H4JN;

1.31
date	2014.08.02.11.52.00;	author reyk;	state Exp;
branches;
next	1.30;
commitid	bdxHYKjcY9PJGrJu;

1.30
date	2014.08.01.22.24.05;	author reyk;	state Exp;
branches;
next	1.29;
commitid	GXr73HMBmpwnofsc;

1.29
date	2014.08.01.21.59.56;	author reyk;	state Exp;
branches;
next	1.28;
commitid	x6XXpbpENAdHhEQS;

1.28
date	2014.08.01.21.51.02;	author doug;	state Exp;
branches;
next	1.27;
commitid	EQrn6y0IO5CKfaGo;

1.27
date	2014.08.01.08.34.46;	author florian;	state Exp;
branches;
next	1.26;
commitid	SQpmoq716KYwsw94;

1.26
date	2014.07.31.18.07.11;	author reyk;	state Exp;
branches;
next	1.25;
commitid	vNGac2qPq7P5adZU;

1.25
date	2014.07.31.17.55.09;	author reyk;	state Exp;
branches;
next	1.24;
commitid	2oJScuzXVXi93eTv;

1.24
date	2014.07.31.14.25.14;	author reyk;	state Exp;
branches;
next	1.23;
commitid	QkmIVLoOhhCQIxFE;

1.23
date	2014.07.31.14.18.38;	author reyk;	state Exp;
branches;
next	1.22;
commitid	YuIDlOouHxlacCk2;

1.22
date	2014.07.31.13.28.15;	author reyk;	state Exp;
branches;
next	1.21;
commitid	HDnnTvoJZbrXmrWp;

1.21
date	2014.07.31.09.34.57;	author reyk;	state Exp;
branches;
next	1.20;
commitid	KZnViLTHk4UhEJQd;

1.20
date	2014.07.31.09.23.53;	author florian;	state Exp;
branches;
next	1.19;
commitid	4jka4N6hQtuBEhDN;

1.19
date	2014.07.30.13.49.48;	author reyk;	state Exp;
branches;
next	1.18;
commitid	xXDeSGReD1XsNQaP;

1.18
date	2014.07.30.10.05.14;	author reyk;	state Exp;
branches;
next	1.17;
commitid	crg28r1097elBMcd;

1.17
date	2014.07.29.16.17.28;	author reyk;	state Exp;
branches;
next	1.16;
commitid	lVEJBNunwU7ia3Go;

1.16
date	2014.07.29.12.16.36;	author reyk;	state Exp;
branches;
next	1.15;
commitid	9PurumxX3SjNH6Pz;

1.15
date	2014.07.25.23.30.58;	author reyk;	state Exp;
branches;
next	1.14;
commitid	3E0HntdxEq94QrDK;

1.14
date	2014.07.25.23.23.39;	author reyk;	state Exp;
branches;
next	1.13;
commitid	ovF3df8kR0MciR0p;

1.13
date	2014.07.25.21.29.58;	author reyk;	state Exp;
branches;
next	1.12;
commitid	smhDJiNevxTCWh6A;

1.12
date	2014.07.25.16.23.19;	author reyk;	state Exp;
branches;
next	1.11;
commitid	xxvqODaQzmLv14My;

1.11
date	2014.07.25.13.10.18;	author reyk;	state Exp;
branches;
next	1.10;
commitid	e2fiCfjHRfxIZTmx;

1.10
date	2014.07.25.12.46.23;	author reyk;	state Exp;
branches;
next	1.9;
commitid	nFELL2a0ZqVmRooJ;

1.9
date	2014.07.25.12.42.05;	author reyk;	state Exp;
branches;
next	1.8;
commitid	YXf583TKv41UVnB7;

1.8
date	2014.07.24.08.11.27;	author reyk;	state Exp;
branches;
next	1.7;
commitid	876FAoxapK12ZFCf;

1.7
date	2014.07.23.19.03.56;	author reyk;	state Exp;
branches;
next	1.6;
commitid	ZUW6ktdLBGFDHF5g;

1.6
date	2014.07.23.13.26.39;	author reyk;	state Exp;
branches;
next	1.5;
commitid	zAAnmSLr14THdHMx;

1.5
date	2014.07.23.12.01.27;	author reyk;	state Exp;
branches;
next	1.4;
commitid	0q1uEuiVCKCuc6Hh;

1.4
date	2014.07.16.10.25.28;	author reyk;	state Exp;
branches;
next	1.3;
commitid	ogHdcewg1QccxeTT;

1.3
date	2014.07.14.00.19.48;	author reyk;	state Exp;
branches;
next	1.2;
commitid	PY8fkGzrfhDzml1J;

1.2
date	2014.07.13.14.17.37;	author reyk;	state Exp;
branches;
next	1.1;
commitid	4gg9IcDTWDACYa56;

1.1
date	2014.07.12.23.34.54;	author reyk;	state Exp;
branches;
next	;
commitid	U5OqzWAgis3Sb3uE;

1.51.2.1
date	2014.11.20.07.48.45;	author jasper;	state Exp;
branches;
next	;
commitid	aoUNgrdXQt2mQs98;


desc
@@


1.132
log
@use __func__ in log messages.
From Hiltjo Posthuma hiltjo -AT codemadness -DOT- org, thanks!
ok florian, claudio
@
text
@/*	$OpenBSD: httpd.h,v 1.131 2017/03/25 17:25:34 claudio Exp $	*/

/*
 * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2006, 2007 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _HTTPD_H
#define _HTTPD_H

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/time.h>

#include <net/if.h>
#include <netinet/in.h>

#include <stdarg.h>
#include <limits.h>
#include <event.h>
#include <imsg.h>
#include <tls.h>
#include <vis.h>

#include "patterns.h"

#ifndef nitems
#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))
#endif

#define CONF_FILE		"/etc/httpd.conf"
#define HTTPD_SOCKET		"/var/run/httpd.sock"
#define HTTPD_USER		"www"
#define HTTPD_SERVERNAME	"OpenBSD httpd"
#define HTTPD_DOCROOT		"/htdocs"
#define HTTPD_INDEX		"index.html"
#define HTTPD_FCGI_SOCKET	"/run/slowcgi.sock"
#define HTTPD_LOGROOT		"/logs"
#define HTTPD_ACCESS_LOG	"access.log"
#define HTTPD_ERROR_LOG		"error.log"
#define HTTPD_DEFAULT_TYPE	{ "bin", "application", "octet-stream", NULL }
#define HTTPD_LOGVIS		VIS_NL|VIS_TAB|VIS_CSTYLE
#define HTTPD_TLS_CERT		"/etc/ssl/server.crt"
#define HTTPD_TLS_KEY		"/etc/ssl/private/server.key"
#define HTTPD_TLS_CIPHERS	"compat"
#define HTTPD_TLS_DHE_PARAMS	"none"
#define HTTPD_TLS_ECDHE_CURVE	"auto"
#define FD_RESERVE		5

#define SERVER_MAX_CLIENTS	1024
#define SERVER_TIMEOUT		600
#define SERVER_REQUESTTIMEOUT	60
#define SERVER_CACHESIZE	-1	/* use default size */
#define SERVER_NUMPROC		3
#define SERVER_MAXHEADERLENGTH	8192
#define SERVER_MAXREQUESTS	100	/* max requests per connection */
#define SERVER_MAXREQUESTBODY	1048576	/* 1M */
#define SERVER_BACKLOG		10
#define SERVER_OUTOF_FD_RETRIES	5
#define SERVER_MAX_PREFETCH	256
#define SERVER_MIN_PREFETCHED	32
#define SERVER_HSTS_DEFAULT_AGE	31536000
#define SERVER_MAX_RANGES	4
#define SERVER_DEF_TLS_LIFETIME	(2 * 3600)
#define SERVER_MIN_TLS_LIFETIME	(60)
#define SERVER_MAX_TLS_LIFETIME	(24 * 3600)

#define MEDIATYPE_NAMEMAX	128	/* file name extension */
#define MEDIATYPE_TYPEMAX	64	/* length of type/subtype */

#define CONFIG_RELOAD		0x00
#define CONFIG_MEDIA		0x01
#define CONFIG_SERVERS		0x02
#define CONFIG_AUTH		0x04
#define CONFIG_ALL		0xff

#define FCGI_CONTENT_SIZE	65535

#define PROC_PARENT_SOCK_FILENO	3
#define PROC_MAX_INSTANCES	32

enum httpchunk {
	TOREAD_UNLIMITED		= -1,
	TOREAD_HTTP_HEADER		= -2,
	TOREAD_HTTP_CHUNK_LENGTH	= -3,
	TOREAD_HTTP_CHUNK_TRAILER	= -4,
	TOREAD_HTTP_NONE		= -5,
	TOREAD_HTTP_RANGE		= TOREAD_HTTP_CHUNK_LENGTH
};

#if DEBUG
#define DPRINTF		log_debug
#else
#define DPRINTF(x...)	do {} while(0)
#endif

struct ctl_flags {
	uint8_t		 cf_opts;
	uint32_t	 cf_flags;
	uint8_t		 cf_tls_sid[TLS_MAX_SESSION_ID_LENGTH];
};

enum key_type {
	KEY_TYPE_NONE		= 0,
	KEY_TYPE_COOKIE,
	KEY_TYPE_HEADER,
	KEY_TYPE_PATH,
	KEY_TYPE_QUERY,
	KEY_TYPE_URL,
	KEY_TYPE_MAX
};

TAILQ_HEAD(kvlist, kv);
RB_HEAD(kvtree, kv);

struct kv {
	char			*kv_key;
	char			*kv_value;

	enum key_type		 kv_type;

#define KV_FLAG_INVALID		 0x01
#define KV_FLAG_GLOBBING	 0x02
	uint8_t			 kv_flags;

	struct kvlist		 kv_children;
	struct kv		*kv_parent;
	TAILQ_ENTRY(kv)		 kv_entry;

	RB_ENTRY(kv)		 kv_node;
};

struct portrange {
	in_port_t		 val[2];
	uint8_t			 op;
};

struct address {
	struct sockaddr_storage	 ss;
	int			 ipproto;
	int			 prefixlen;
	struct portrange	 port;
	char			 ifname[IFNAMSIZ];
	TAILQ_ENTRY(address)	 entry;
};
TAILQ_HEAD(addresslist, address);

/* initially control.h */
struct control_sock {
	const char	*cs_name;
	struct event	 cs_ev;
	struct event	 cs_evt;
	int		 cs_fd;
	int		 cs_restricted;
	void		*cs_env;

	TAILQ_ENTRY(control_sock) cs_entry;
};
TAILQ_HEAD(control_socks, control_sock);

struct {
	struct event	 ev;
	int		 fd;
} control_state;

struct imsgev {
	struct imsgbuf		 ibuf;
	void			(*handler)(int, short, void *);
	struct event		 ev;
	struct privsep_proc	*proc;
	void			*data;
	short			 events;
};

#define IMSG_SIZE_CHECK(imsg, p) do {				\
	if (IMSG_DATA_SIZE(imsg) < sizeof(*p))			\
		fatalx("bad length imsg received");		\
} while (0)
#define IMSG_DATA_SIZE(imsg)	((imsg)->hdr.len - IMSG_HEADER_SIZE)

struct ctl_conn {
	TAILQ_ENTRY(ctl_conn)	 entry;
	uint8_t			 flags;
	unsigned int		 waiting;
#define CTL_CONN_NOTIFY		 0x01
	struct imsgev		 iev;

};
TAILQ_HEAD(ctl_connlist, ctl_conn);

enum imsg_type {
	IMSG_NONE,
	IMSG_CTL_OK,
	IMSG_CTL_FAIL,
	IMSG_CTL_VERBOSE,
	IMSG_CTL_PROCFD,
	IMSG_CTL_RESET,
	IMSG_CTL_SHUTDOWN,
	IMSG_CTL_RELOAD,
	IMSG_CTL_NOTIFY,
	IMSG_CTL_END,
	IMSG_CTL_START,
	IMSG_CTL_REOPEN,
	IMSG_CFG_SERVER,
	IMSG_CFG_TLS,
	IMSG_CFG_MEDIA,
	IMSG_CFG_AUTH,
	IMSG_CFG_DONE,
	IMSG_LOG_ACCESS,
	IMSG_LOG_ERROR,
	IMSG_LOG_OPEN,
	IMSG_TLSTICKET_REKEY
};

enum privsep_procid {
	PROC_ALL	= -1,
	PROC_PARENT	= 0,
	PROC_SERVER,
	PROC_LOGGER,
	PROC_MAX
} privsep_process;

/* Attach the control socket to the following process */
#define PROC_CONTROL	PROC_LOGGER

struct privsep_pipes {
	int				*pp_pipes[PROC_MAX];
};

struct privsep {
	struct privsep_pipes		*ps_pipes[PROC_MAX];
	struct privsep_pipes		*ps_pp;

	struct imsgev			*ps_ievs[PROC_MAX];
	const char			*ps_title[PROC_MAX];
	uint8_t				 ps_what[PROC_MAX];

	unsigned int			 ps_instances[PROC_MAX];
	unsigned int			 ps_instance;

	struct control_sock		 ps_csock;
	struct control_socks		 ps_rcsocks;

	/* Event and signal handlers */
	struct event			 ps_evsigint;
	struct event			 ps_evsigterm;
	struct event			 ps_evsigchld;
	struct event			 ps_evsighup;
	struct event			 ps_evsigpipe;
	struct event			 ps_evsigusr1;

	int				 ps_noaction;
	struct passwd			*ps_pw;
	struct httpd			*ps_env;
};

struct privsep_proc {
	const char		*p_title;
	enum privsep_procid	 p_id;
	int			(*p_cb)(int, struct privsep_proc *,
				    struct imsg *);
	void			(*p_init)(struct privsep *,
				    struct privsep_proc *);
	const char		*p_chroot;
	struct privsep		*p_ps;
	void			(*p_shutdown)(void);
	struct passwd		*p_pw;
};

struct privsep_fd {
	enum privsep_procid		 pf_procid;
	unsigned int			 pf_instance;
};

enum fcgistate {
	FCGI_READ_HEADER,
	FCGI_READ_CONTENT,
	FCGI_READ_PADDING
};

struct fcgi_data {
	enum fcgistate		 state;
	int			 toread;
	int			 padding_len;
	int			 type;
	int			 chunked;
	int			 end;
	int			 status;
	int			 headersdone;
};

struct range {
	off_t	start;
	off_t	end;
};

struct range_data {
	struct range		 range[SERVER_MAX_RANGES];
	int			 range_count;
	int			 range_index;
	off_t			 range_toread;

	/* For the Content headers in each part */
	struct media_type	*range_media;
	size_t			 range_total;
};

struct client {
	uint32_t		 clt_id;
	pid_t			 clt_pid;
	void			*clt_srv;
	void			*clt_srv_conf;
	uint32_t		 clt_srv_id;
	struct sockaddr_storage	 clt_srv_ss;
	struct str_match	 clt_srv_match;

	int			 clt_s;
	in_port_t		 clt_port;
	struct sockaddr_storage	 clt_ss;
	struct bufferevent	*clt_bev;
	struct evbuffer		*clt_output;
	struct event		 clt_ev;
	void			*clt_descreq;
	void			*clt_descresp;
	int			 clt_sndbufsiz;
	uint64_t		 clt_boundary;

	int			 clt_fd;
	struct tls		*clt_tls_ctx;
	struct bufferevent	*clt_srvbev;
	int			 clt_srvbev_throttled;

	off_t			 clt_toread;
	size_t			 clt_headerlen;
	int			 clt_headersdone;
	unsigned int		 clt_persist;
	unsigned int		 clt_pipelining;
	int			 clt_line;
	int			 clt_done;
	int			 clt_chunk;
	int			 clt_inflight;
	struct range_data	 clt_ranges;
	struct fcgi_data	 clt_fcgi;
	char			*clt_remote_user;
	struct evbuffer		*clt_srvevb;

	struct evbuffer		*clt_log;
	struct timeval		 clt_timeout;
	struct timeval		 clt_tv_start;
	struct timeval		 clt_tv_last;
	struct event		 clt_inflightevt;

	SPLAY_ENTRY(client)	 clt_nodes;
};
SPLAY_HEAD(client_tree, client);

#define SRVFLAG_INDEX		0x00000001
#define SRVFLAG_NO_INDEX	0x00000002
#define SRVFLAG_AUTO_INDEX	0x00000004
#define SRVFLAG_NO_AUTO_INDEX	0x00000008
#define SRVFLAG_ROOT		0x00000010
#define SRVFLAG_LOCATION	0x00000020
#define SRVFLAG_FCGI		0x00000040
#define SRVFLAG_NO_FCGI		0x00000080
#define SRVFLAG_LOG		0x00000100
#define SRVFLAG_NO_LOG		0x00000200
#define SRVFLAG_SOCKET		0x00000400
#define SRVFLAG_SYSLOG		0x00000800
#define SRVFLAG_NO_SYSLOG	0x00001000
#define SRVFLAG_TLS		0x00002000
#define SRVFLAG_ACCESS_LOG	0x00004000
#define SRVFLAG_ERROR_LOG	0x00008000
#define SRVFLAG_AUTH		0x00010000
#define SRVFLAG_NO_AUTH		0x00020000
#define SRVFLAG_BLOCK		0x00040000
#define SRVFLAG_NO_BLOCK	0x00080000
#define SRVFLAG_LOCATION_MATCH	0x00100000
#define SRVFLAG_SERVER_MATCH	0x00200000
#define SRVFLAG_SERVER_HSTS	0x00400000
#define SRVFLAG_DEFAULT_TYPE	0x00800000

#define SRVFLAG_BITS							\
	"\10\01INDEX\02NO_INDEX\03AUTO_INDEX\04NO_AUTO_INDEX"		\
	"\05ROOT\06LOCATION\07FCGI\10NO_FCGI\11LOG\12NO_LOG\13SOCKET"	\
	"\14SYSLOG\15NO_SYSLOG\16TLS\17ACCESS_LOG\20ERROR_LOG"		\
	"\21AUTH\22NO_AUTH\23BLOCK\24NO_BLOCK\25LOCATION_MATCH"		\
	"\26SERVER_MATCH\27SERVER_HSTS\30DEFAULT_TYPE"

#define TCPFLAG_NODELAY		0x01
#define TCPFLAG_NNODELAY	0x02
#define TCPFLAG_SACK		0x04
#define TCPFLAG_NSACK		0x08
#define TCPFLAG_BUFSIZ		0x10
#define TCPFLAG_IPTTL		0x20
#define TCPFLAG_IPMINTTL	0x40
#define TCPFLAG_NSPLICE		0x80
#define TCPFLAG_DEFAULT		0x00

#define TCPFLAG_BITS						\
	"\10\01NODELAY\02NO_NODELAY\03SACK\04NO_SACK"		\
	"\05SOCKET_BUFFER_SIZE\06IP_TTL\07IP_MINTTL\10NO_SPLICE"

#define HSTSFLAG_SUBDOMAINS	0x01
#define HSTSFLAG_PRELOAD	0x02
#define HSTSFLAG_BITS		"\10\01SUBDOMAINS\02PRELOAD"

enum log_format {
	LOG_FORMAT_COMMON,
	LOG_FORMAT_COMBINED,
	LOG_FORMAT_CONNECTION
};

struct log_file {
	char			log_name[NAME_MAX];
	int			log_fd;
	uint32_t		log_id;
	TAILQ_ENTRY(log_file)	log_entry;
};
TAILQ_HEAD(log_files, log_file) log_files;

struct media_type {
	char			 media_name[MEDIATYPE_NAMEMAX];
	char			 media_type[MEDIATYPE_TYPEMAX];
	char			 media_subtype[MEDIATYPE_TYPEMAX];
	char			*media_encoding;
	RB_ENTRY(media_type)	 media_entry;
};
RB_HEAD(mediatypes, media_type);

struct auth {
	char			 auth_htpasswd[PATH_MAX];
	uint32_t		 auth_id;
	TAILQ_ENTRY(auth)	 auth_entry;
};
TAILQ_HEAD(serverauth, auth);

struct server_tls_ticket {
	uint32_t	tt_id;
	uint32_t	tt_keyrev;
	unsigned char	tt_key[TLS_TICKET_KEY_SIZE];
};

struct server_config {
	uint32_t		 id;
	uint32_t		 parent_id;
	char			 name[HOST_NAME_MAX+1];
	char			 location[NAME_MAX];
	char			 index[NAME_MAX];
	char			 root[PATH_MAX];
	char			 socket[PATH_MAX];
	char			 accesslog[NAME_MAX];
	char			 errorlog[NAME_MAX];
	struct media_type	 default_type;

	in_port_t		 port;
	struct sockaddr_storage	 ss;
	int			 prefixlen;
	struct timeval		 timeout;
	struct timeval		 requesttimeout;
	uint32_t		 maxrequests;
	size_t			 maxrequestbody;

	uint8_t			*tls_cert;
	size_t			 tls_cert_len;
	char			*tls_cert_file;
	char			 tls_ciphers[NAME_MAX];
	char			 tls_dhe_params[NAME_MAX];
	char			 tls_ecdhe_curve[NAME_MAX];
	uint8_t			*tls_key;
	size_t			 tls_key_len;
	char			*tls_key_file;
	uint32_t		 tls_protocols;
	uint8_t			*tls_ocsp_staple;
	size_t			 tls_ocsp_staple_len;
	char			*tls_ocsp_staple_file;
	struct server_tls_ticket tls_ticket_key;
	int			 tls_ticket_lifetime;

	uint32_t		 flags;
	int			 strip;
	uint8_t			 tcpflags;
	int			 tcpbufsiz;
	int			 tcpbacklog;
	uint8_t			 tcpipttl;
	uint8_t			 tcpipminttl;

	enum log_format		 logformat;
	struct log_file		*logaccess;
	struct log_file		*logerror;

	char			 auth_realm[NAME_MAX];
	uint32_t		 auth_id;
	const struct auth	*auth;

	int			 return_code;
	char			*return_uri;
	off_t			 return_uri_len;

	int			 hsts_max_age;
	uint8_t			 hsts_flags;

	TAILQ_ENTRY(server_config) entry;
};
TAILQ_HEAD(serverhosts, server_config);

struct tls_config {
	uint32_t		 id;

	size_t			 tls_cert_len;
	size_t			 tls_key_len;
	size_t			 tls_ocsp_staple_len;
};

struct server {
	TAILQ_ENTRY(server)	 srv_entry;
	struct server_config	 srv_conf;
	struct serverhosts	 srv_hosts;

	int			 srv_s;
	struct event		 srv_ev;
	struct event		 srv_evt;

	struct tls		 *srv_tls_ctx;
	struct tls_config	 *srv_tls_config;

	struct client_tree	 srv_clients;
};
TAILQ_HEAD(serverlist, server);

struct httpd {
	uint8_t			 sc_opts;
	uint32_t		 sc_flags;
	const char		*sc_conffile;
	struct event		 sc_ev;
	uint16_t		 sc_prefork_server;
	uint16_t		 sc_id;
	int			 sc_paused;
	char			*sc_chroot;
	char			*sc_logdir;

	uint8_t			 sc_tls_sid[TLS_MAX_SESSION_ID_LENGTH];

	struct serverlist	*sc_servers;
	struct mediatypes	*sc_mediatypes;
	struct media_type	 sc_default_type;
	struct serverauth	*sc_auth;

	struct privsep		*sc_ps;
	int			 sc_reload;
};

#define HTTPD_OPT_VERBOSE		0x01
#define HTTPD_OPT_NOACTION		0x04

/* control.c */
int	 control_init(struct privsep *, struct control_sock *);
int	 control_listen(struct control_sock *);
void	 control_cleanup(struct control_sock *);
void	 control_dispatch_imsg(int, short, void *);
void	 control_imsg_forward(struct privsep *, struct imsg *);
struct ctl_conn	*
	 control_connbyfd(int);

extern  struct ctl_connlist ctl_conns;

/* parse.y */
int	 parse_config(const char *, struct httpd *);
int	 load_config(const char *, struct httpd *);
int	 cmdline_symset(char *);

/* server.c */
void	 server(struct privsep *, struct privsep_proc *);
int	 server_tls_cmp(struct server *, struct server *, int);
int	 server_tls_load_keypair(struct server *);
int	 server_tls_load_ocsp(struct server *);
void	 server_generate_ticket_key(struct server_config *);
int	 server_privinit(struct server *);
void	 server_purge(struct server *);
void	 serverconfig_free(struct server_config *);
void	 serverconfig_reset(struct server_config *);
int	 server_socket_af(struct sockaddr_storage *, in_port_t);
in_port_t
	 server_socket_getport(struct sockaddr_storage *);
int	 server_socket_connect(struct sockaddr_storage *, in_port_t,
	    struct server_config *);
void	 server_write(struct bufferevent *, void *);
void	 server_read(struct bufferevent *, void *);
void	 server_error(struct bufferevent *, short, void *);
void	 server_log(struct client *, const char *);
void	 server_sendlog(struct server_config *, int, const char *, ...)
	    __attribute__((__format__ (printf, 3, 4)));
void	 server_close(struct client *, const char *);
void	 server_dump(struct client *, const void *, size_t);
int	 server_client_cmp(struct client *, struct client *);
int	 server_bufferevent_printf(struct client *, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
int	 server_bufferevent_print(struct client *, const char *);
int	 server_bufferevent_write_buffer(struct client *,
	    struct evbuffer *);
int	 server_bufferevent_write_chunk(struct client *,
	    struct evbuffer *, size_t);
int	 server_bufferevent_add(struct event *, int);
int	 server_bufferevent_write(struct client *, void *, size_t);
struct server *
	 server_byaddr(struct sockaddr *, in_port_t);
struct server_config *
	 serverconfig_byid(uint32_t);
int	 server_foreach(int (*)(struct server *,
	    struct server_config *, void *), void *);
struct server *
	 server_match(struct server *, int);

SPLAY_PROTOTYPE(client_tree, client, clt_nodes, server_client_cmp);

/* server_http.c */
void	 server_http_init(struct server *);
void	 server_http(void);
int	 server_httpdesc_init(struct client *);
void	 server_read_http(struct bufferevent *, void *);
void	 server_abort_http(struct client *, unsigned int, const char *);
unsigned int
	 server_httpmethod_byname(const char *);
const char
	*server_httpmethod_byid(unsigned int);
const char
	*server_httperror_byid(unsigned int);
void	 server_read_httpcontent(struct bufferevent *, void *);
void	 server_read_httpchunks(struct bufferevent *, void *);
void	 server_read_httprange(struct bufferevent *, void *);
int	 server_writeheader_http(struct client *clt, struct kv *, void *);
int	 server_headers(struct client *, void *,
	    int (*)(struct client *, struct kv *, void *), void *);
int	 server_writeresponse_http(struct client *);
int	 server_response_http(struct client *, unsigned int,
	    struct media_type *, off_t, time_t);
void	 server_reset_http(struct client *);
void	 server_close_http(struct client *);
int	 server_response(struct httpd *, struct client *);
const char *
	 server_root_strip(const char *, int);
struct server_config *
	 server_getlocation(struct client *, const char *);
const char *
	 server_http_host(struct sockaddr_storage *, char *, size_t);
char	*server_http_parsehost(char *, char *, size_t, int *);
ssize_t	 server_http_time(time_t, char *, size_t);
int	 server_log_http(struct client *, unsigned int, size_t);

/* server_file.c */
int	 server_file(struct httpd *, struct client *);
void	 server_file_error(struct bufferevent *, short, void *);

/* server_fcgi.c */
int	 server_fcgi(struct httpd *, struct client *);
int	 fcgi_add_stdin(struct client *, struct evbuffer *);

/* httpd.c */
void		 event_again(struct event *, int, short,
		    void (*)(int, short, void *),
		    struct timeval *, struct timeval *, void *);
int		 expand_string(char *, size_t, const char *, const char *);
const char	*url_decode(char *);
char		*url_encode(const char *);
const char	*canonicalize_host(const char *, char *, size_t);
const char	*canonicalize_path(const char *, char *, size_t);
size_t		 path_info(char *);
char		*escape_html(const char *);
void		 socket_rlimit(int);
char		*evbuffer_getline(struct evbuffer *);
char		*get_string(uint8_t *, size_t);
void		*get_data(uint8_t *, size_t);
int		 sockaddr_cmp(struct sockaddr *, struct sockaddr *, int);
struct in6_addr *prefixlen2mask6(uint8_t, uint32_t *);
uint32_t	 prefixlen2mask(uint8_t);
int		 accept_reserve(int, struct sockaddr *, socklen_t *, int,
		    volatile int *);
struct kv	*kv_add(struct kvtree *, char *, char *);
int		 kv_set(struct kv *, char *, ...)
		    __attribute__((__format__ (printf, 2, 3)));
int		 kv_setkey(struct kv *, char *, ...)
		    __attribute__((__format__ (printf, 2, 3)));
void		 kv_delete(struct kvtree *, struct kv *);
struct kv	*kv_extend(struct kvtree *, struct kv *, char *);
void		 kv_purge(struct kvtree *);
void		 kv_free(struct kv *);
struct kv	*kv_inherit(struct kv *, struct kv *);
int		 kv_log(struct evbuffer *, struct kv *);
struct kv	*kv_find(struct kvtree *, struct kv *);
int		 kv_cmp(struct kv *, struct kv *);
struct media_type
		*media_add(struct mediatypes *, struct media_type *);
void		 media_delete(struct mediatypes *, struct media_type *);
void		 media_purge(struct mediatypes *);
struct media_type *
		 media_find(struct mediatypes *, const char *);
struct media_type *
		 media_find_config(struct httpd *, struct server_config *,
		    const char *);
int		 media_cmp(struct media_type *, struct media_type *);
RB_PROTOTYPE(kvtree, kv, kv_node, kv_cmp);
RB_PROTOTYPE(mediatypes, media_type, media_entry, media_cmp);
struct auth	*auth_add(struct serverauth *, struct auth *);
struct auth	*auth_byid(struct serverauth *, uint32_t);
void		 auth_free(struct serverauth *, struct auth *);
const char	*print_host(struct sockaddr_storage *, char *, size_t);
const char	*print_time(struct timeval *, struct timeval *, char *, size_t);
const char	*printb_flags(const uint32_t, const char *);
void		 getmonotime(struct timeval *);

extern struct httpd *httpd_env;

/* log.c */
void	log_init(int, int);
void	log_procinit(const char *);
void	log_setverbose(int);
int	log_getverbose(void);
void	log_warn(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_warnx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_info(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_debug(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	logit(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	vlog(int, const char *, va_list)
	    __attribute__((__format__ (printf, 2, 0)));
__dead void fatal(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
__dead void fatalx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));

/* proc.c */
enum privsep_procid
	    proc_getid(struct privsep_proc *, unsigned int, const char *);
void	 proc_init(struct privsep *, struct privsep_proc *, unsigned int,
	    int, char **, enum privsep_procid);
void	 proc_kill(struct privsep *);
void	 proc_connect(struct privsep *);
void	 proc_dispatch(int, short event, void *);
void	 proc_run(struct privsep *, struct privsep_proc *,
	    struct privsep_proc *, unsigned int,
	    void (*)(struct privsep *, struct privsep_proc *, void *), void *);
void	 proc_range(struct privsep *, enum privsep_procid, int *, int *);
int	 proc_compose_imsg(struct privsep *, enum privsep_procid, int,
	    u_int16_t, u_int32_t, int, void *, u_int16_t);
int	 proc_compose(struct privsep *, enum privsep_procid,
	    uint16_t, void *, uint16_t);
int	 proc_composev_imsg(struct privsep *, enum privsep_procid, int,
	    u_int16_t, u_int32_t, int, const struct iovec *, int);
int	 proc_composev(struct privsep *, enum privsep_procid,
	    uint16_t, const struct iovec *, int);
int	 proc_forward_imsg(struct privsep *, struct imsg *,
	    enum privsep_procid, int);
struct imsgbuf *
	 proc_ibuf(struct privsep *, enum privsep_procid, int);
struct imsgev *
	 proc_iev(struct privsep *, enum privsep_procid, int);
int	 proc_flush_imsg(struct privsep *, enum privsep_procid, int);
void	 imsg_event_add(struct imsgev *);
int	 imsg_compose_event(struct imsgev *, uint16_t, uint32_t,
	    pid_t, int, void *, uint16_t);
int	 imsg_composev_event(struct imsgev *, uint16_t, uint32_t,
	    pid_t, int, const struct iovec *, int);

/* config.c */
int	 config_init(struct httpd *);
void	 config_purge(struct httpd *, unsigned int);
int	 config_setreset(struct httpd *, unsigned int);
int	 config_getreset(struct httpd *, struct imsg *);
int	 config_getcfg(struct httpd *, struct imsg *);
int	 config_setserver(struct httpd *, struct server *);
int	 config_settls(struct httpd *, struct server *);
int	 config_getserver(struct httpd *, struct imsg *);
int	 config_gettls(struct httpd *, struct imsg *);
int	 config_setmedia(struct httpd *, struct media_type *);
int	 config_getmedia(struct httpd *, struct imsg *);
int	 config_setauth(struct httpd *, struct auth *);
int	 config_getauth(struct httpd *, struct imsg *);

/* logger.c */
void	 logger(struct privsep *, struct privsep_proc *);
int	 logger_open_priv(struct imsg *);

#endif /* _HTTPD_H */
@


1.131
log
@Implement TLS ticket support in httpd. Off by default. Use
	tls ticket lifetime default
to turn it on with a 2h ticket lifetime.
Rekeying happens after a quarter of that time.
OK reky@@ and bob@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.130 2017/02/07 12:27:42 reyk Exp $	*/
d454 1
a454 1
	uint32_t 	tt_keyrev;
d649 2
a650 2
int	 server_response_http(struct client *, unsigned int, struct media_type *,
	    off_t, time_t);
@


1.130
log
@/tmp/cvsspEkok
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.129 2017/02/03 08:23:46 guenther Exp $	*/
d79 3
d115 1
d226 2
a227 1
	IMSG_LOG_OPEN
d452 6
d491 2
d556 2
d591 1
@


1.129
log
@Stop assuming that in_{addr,port}_t are typedefed in <sys/types.h> and
instead pull in <netinet/in.h> or <arpa/inet.h> when those are needed.

ok florian@@ beck@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.128 2017/02/02 22:19:59 reyk Exp $	*/
d67 1
d463 1
@


1.128
log
@Fix support for HTTP pipelining by handling all requests in the buffer.

Tested & OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.127 2017/01/31 14:39:47 reyk Exp $	*/
d31 1
@


1.127
log
@Reimplement httpd's support for byte ranges.

The previous implementation loaded all the output into a single output
buffer and used its size to determine the Content-Length of the body.

The new implementation calculates the body length first and writes the
individual ranges in an async way using the bufferevent mechanism.

This prevents httpd from using too much memory and applies the
watermark and throttling mechanisms to range requests.

Problem reported by Pierre Kim (pierre.kim.sec at gmail.com)

OK benno@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.126 2017/01/31 12:21:27 reyk Exp $	*/
d345 1
@


1.126
log
@The variable clt_done is used in too many places.

Introduce a new variable clt_headersdone in the async HTTP parser.

OK sunil@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.125 2017/01/09 14:49:22 reyk Exp $	*/
d76 1
d97 2
a98 1
	TOREAD_HTTP_NONE		= -5
d300 16
d334 1
d349 1
d624 1
@


1.125
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.124 2016/11/17 14:52:48 jsing Exp $	*/
d324 1
@


1.124
log
@Move OCSP loading into a separate function - it is not part of the keypair
and this way we can give a separate specific error message.

ok beck@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.123 2016/11/06 10:49:38 beck Exp $	*/
d688 2
a689 1
void	log_verbose(int);
@


1.123
log
@Add OCSP stapling support to httpd
ok jsing@@ bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.122 2016/10/12 10:57:30 reyk Exp $	*/
d550 1
@


1.122
log
@Prevent fd exhaustion in the parent when loading the listening server
sockets by sending the fd one-by-one.  This allows to start httpd with
max 32 server instances and many server sockets without changing the
default rlimits in any way.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.121 2016/10/05 16:58:19 reyk Exp $	*/
d452 3
d488 1
@


1.121
log
@sync proc.c with vmd: add p_pw to specify a non-standard user for a process.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.120 2016/09/28 12:01:04 reyk Exp $	*/
d727 1
@


1.120
log
@sync proc.c from switchd, includes minor cast qual fix and removal of p_env.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.119 2016/09/03 14:44:21 reyk Exp $	*/
d273 1
@


1.119
log
@Replace [RELAY|SERVER]_MAXPROC with the new PROC_MAX_INSTANCES
variable and limit it from 128 to 32 instances (the old value).
While here, move a few PROC_ defines around.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.118 2016/09/02 11:25:14 reyk Exp $	*/
a269 1
	void			(*p_shutdown)(void);
d272 1
a272 1
	struct httpd		*p_env;
@


1.118
log
@proc.c tweaks: Rename proc_listento() to proc_accept() as it is the
receiving side of proc_connect().  Move some code from main into
proc_init(), the function is now called by parent and children, not
just the parent and it is less copy + paste for other daemons.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.117 2016/09/01 11:13:18 florian Exp $	*/
a67 1
#define SERVER_MAXPROC		32
d88 3
a230 5

/* Define default parent socket number */
#define PARENT_SOCK_FILENO	3

#define PROC_MAX_INSTANCES	128
@


1.117
log
@struct client starts to become the kitchen sink. Move fastcgi data to
its own struct. Requested by and OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.116 2016/09/01 10:59:38 reyk Exp $	*/
d708 1
a708 1
	    int, char **);
@


1.116
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.115 2016/09/01 09:47:03 rzalamena Exp $	*/
d290 11
d332 1
a332 8
	enum fcgistate		 clt_fcgi_state;
	int			 clt_fcgi_toread;
	int			 clt_fcgi_padding_len;
	int			 clt_fcgi_type;
	int			 clt_fcgi_chunked;
	int			 clt_fcgi_end;
	int			 clt_fcgi_status;
	int			 clt_fcgi_headersdone;
@


1.115
log
@Teach httpd/proc.c how to fork+exec.

This commit implemented the basic functions to proc.c to make it not rely
on global variables, malloc()ed memory and CLOEXEC pipes.

Fix child proc titles from reyk@@
ok reyk@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.114 2016/08/30 14:31:53 rzalamena Exp $	*/
d703 2
a704 1
void	 proc_init(struct privsep *, struct privsep_proc *, unsigned int, int, char **);
@


1.114
log
@Kill (remove) the ps_pid from privsep struct since it is not being used
anymore. Also fix the process initialization prototypes.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.113 2016/08/30 13:37:10 rzalamena Exp $	*/
d201 1
d230 5
d279 5
d701 3
a703 1
void	 proc_init(struct privsep *, struct privsep_proc *, unsigned int);
d705 1
a705 1
void	 proc_listen(struct privsep *, struct privsep_proc *, size_t);
d707 1
a707 1
pid_t	 proc_run(struct privsep *, struct privsep_proc *,
@


1.113
log
@Remove duplicated prototypes from header.

"Looks good to me" natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.112 2016/08/30 10:54:42 florian Exp $	*/
a238 1
	pid_t				 ps_pid[PROC_MAX];
d265 1
a265 1
	pid_t			(*p_init)(struct privsep *,
d531 1
a531 1
pid_t	 server(struct privsep *, struct privsep_proc *);
d734 1
a734 1
pid_t	 logger(struct privsep *, struct privsep_proc *);
@


1.112
log
@Do not assume that the full http response header is in the first
fastcgi stdout record. Keep processing stdout records until we found
the header / body separator and only then generate the header
response.
Problem reported by many.

OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.111 2016/08/27 11:13:16 rzalamena Exp $	*/
a624 3
void		 imsg_event_add(struct imsgev *);
int		 imsg_compose_event(struct imsgev *, uint16_t, uint32_t,
		    pid_t, int, void *, uint16_t);
@


1.111
log
@Kill p_instance from proc.c and remove static proc_id unused variables.

To keep the debug functionality intact and correct we'll use the pid
field in the imsg header to pass the instance number. Remember to always
pass 'ps_instance + 1' otherwise libutil will fill imsg header pid field
with the imsgbuf pid (which is the current process pid).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.110 2016/08/26 12:24:21 rzalamena Exp $	*/
d317 2
@


1.110
log
@Kill the ps_ninstances from proc.c.

We got the same information in ps_instances[proc] (more accurate) and
we avoid allocating unnecessary memory for pipe storage.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.109 2016/08/26 10:46:39 rzalamena Exp $	*/
a268 1
	unsigned int		 p_instance;
d518 1
a518 1
void	 control_imsg_forward(struct imsg *);
@


1.109
log
@Replace the static env variables with a single global variable.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.108 2016/08/22 15:02:18 jsing Exp $	*/
a242 1
	unsigned int			 ps_ninstances;
@


1.108
log
@Enable SNI support in httpd(8).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.107 2016/08/16 18:41:57 tedu Exp $	*/
d575 1
a575 1
void	 server_http(struct httpd *);
d669 2
@


1.107
log
@stop including sys/param.h for nitems. define locally as needed.
ok natano reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.106 2016/08/15 16:12:34 jsing Exp $	*/
d533 1
a533 1
int	 server_tls_cmp(struct server *, struct server *);
@


1.106
log
@Move server_match() from parse.y to server.c; use env instead of conf,
which is actually the same thing (cluebat from reyk@@).
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.105 2016/08/15 13:48:24 jsing Exp $	*/
d40 4
@


1.105
log
@Make httpd stricter with respect to TLS configuration - in particular, do
not allow TLS and non-TLS to be configured on the same port, do not allow
TLS options to be specified without a TLS listener and ensure that the TLS
options are the same when a server is specified on the same address/port.
Currently, these configurations are permitted but do not work as intended.

Also factor out and reuse the server matching code, which was previously
duplicated.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.104 2016/07/13 16:35:47 jsing Exp $	*/
d564 2
@


1.104
log
@Adjust existing tls_config_set_cipher() callers for TLS cipher group
changes - map the previous configuration to the equivalent in the new
groups. This will be revisited post release.

Discussed with beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.103 2016/04/28 14:20:11 jsing Exp $	*/
d529 1
@


1.103
log
@Simplify TLS configuration handling. Instead of matching by address/port,
match by configuration ID. This also prevents a memory leak when there are
multiple certificates specified for the same server.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.102 2015/12/02 15:13:00 reyk Exp $	*/
d55 1
a55 1
#define HTTPD_TLS_CIPHERS	"HIGH:!aNULL"
@


1.102
log
@sync with relayd, use proc_compose()
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.101 2015/11/23 20:56:14 reyk Exp $	*/
a466 3

	in_port_t		 port;
	struct sockaddr_storage	 ss;
@


1.101
log
@Retire socket_set_blockmode() in favor of the SOCK_NONBLOCK type flag.
As done in iked and snmpd.

OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.100 2015/11/22 13:27:13 reyk Exp $	*/
d697 3
a699 1
	    uint16_t, int, void *, uint16_t);
d701 3
a703 1
	    uint16_t, int, const struct iovec *, int);
@


1.100
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.99 2015/11/21 12:40:59 reyk Exp $	*/
a166 5
enum blockmodes {
	BM_NORMAL,
	BM_NONBLOCK
};

a521 1
void	 socket_set_blockmode(int, enum blockmodes);
@


1.99
log
@Move local logging functions into httpd.c, and sync log.c with relayd -
both daemons are now sharing the same file.  No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.98 2015/09/07 14:46:24 reyk Exp $	*/
d673 2
a674 1
void	log_init(int);
d688 4
a691 2
__dead void fatal(const char *);
__dead void fatalx(const char *);
@


1.98
log
@Fix a regression that was introduced with server.c r1.64: Do NOT free
srv_conf->auth in serverconfig_free() because it was not allocated in
config_getserver() but assigned as a reference by id from a global
list that is maintained independently.  This fixes a potential
double-free.  This fix also makes srv_conf->auth "const" to emphasize
that the read-only auth pointer was not allocated here.

OK jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.97 2015/08/20 13:00:23 reyk Exp $	*/
d667 4
d675 12
a686 6
void	log_warn(const char *, ...) __attribute__((__format__ (printf, 1, 2)));
void	log_warnx(const char *, ...) __attribute__((__format__ (printf, 1, 2)));
void	log_info(const char *, ...) __attribute__((__format__ (printf, 1, 2)));
void	log_debug(const char *, ...) __attribute__((__format__ (printf, 1, 2)));
void	logit(int, const char *, ...) __attribute__((__format__ (printf, 2, 3)));
void	vlog(int, const char *, va_list) __attribute__((__format__ (printf, 2, 0)));
a688 4
const char *print_host(struct sockaddr_storage *, char *, size_t);
const char *print_time(struct timeval *, struct timeval *, char *, size_t);
const char *printb_flags(const uint32_t, const char *);
void	 getmonotime(struct timeval *);
@


1.97
log
@Change httpd(8) to use C99-style fixed-width integers (uintN_t instead
of u_intN_t) and replace u_int with unsigned int.  Mixing both
variants is a bad style and most contributors seem to prefer this
style; it also helps us to get used to it, portability, and
standardization.

Theoretically no binary change, except one in practice: httpd.o has a
different checksum because gcc with -O2 pads/optimizes "struct
privsep" differently when using "unsigned int" instead "u_int" for the
affected members.  "u_int" is just a typedef of "unsigned int", -O0
doesn't build the difference and clang with -O2 doesn't do it either -
it is just another curiosity from gcc-land.

OK semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.96 2015/08/03 11:45:17 florian Exp $	*/
d457 1
a457 1
	struct auth		*auth;
@


1.96
log
@Fix rev 1.70 of server.c by only re-enabling the bufferevent if we
previously disabled it because we were reading to fast (from disk).
Problem noted and tracked down to that commit by weerd@@ and
independently by stsp@@.
Tested by weerd@@, stsp@@, reyk@@
OK bluhm@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.95 2015/07/31 00:10:51 benno Exp $	*/
d100 2
a101 2
	u_int8_t	 cf_opts;
	u_int32_t	 cf_flags;
d125 1
a125 1
	u_int8_t		 kv_flags;
d136 1
a136 1
	u_int8_t		 op;
d189 2
a190 2
	u_int8_t		 flags;
	u_int			 waiting;
d241 1
a241 1
	u_int8_t			 ps_what[PROC_MAX];
d243 3
a245 3
	u_int				 ps_instances[PROC_MAX];
	u_int				 ps_ninstances;
	u_int				 ps_instance;
d271 1
a271 1
	u_int			 p_instance;
d284 1
a284 1
	u_int32_t		 clt_id;
d288 1
a288 1
	u_int32_t		 clt_srv_id;
d309 1
a309 1
	u_int			 clt_persist;
d392 1
a392 1
	u_int32_t		log_id;
d408 1
a408 1
	u_int32_t		 auth_id;
d414 2
a415 2
	u_int32_t		 id;
	u_int32_t		 parent_id;
d429 1
a429 1
	u_int32_t		 maxrequests;
d432 1
a432 1
	u_int8_t		*tls_cert;
d438 1
a438 1
	u_int8_t		*tls_key;
d441 1
a441 1
	u_int32_t		 tls_protocols;
d443 1
a443 1
	u_int32_t		 flags;
d445 1
a445 1
	u_int8_t		 tcpflags;
d448 2
a449 2
	u_int8_t		 tcpipttl;
	u_int8_t		 tcpipminttl;
d456 1
a456 1
	u_int32_t		 auth_id;
d464 1
a464 1
	u_int8_t		 hsts_flags;
d471 1
a471 1
	u_int32_t		 id;
d497 2
a498 2
	u_int8_t		 sc_opts;
	u_int32_t		 sc_flags;
d501 2
a502 2
	u_int16_t		 sc_prefork_server;
	u_int16_t		 sc_id;
d569 1
a569 1
	 serverconfig_byid(u_int32_t);
d580 3
a582 2
void	 server_abort_http(struct client *, u_int, const char *);
u_int	 server_httpmethod_byname(const char *);
d584 1
a584 1
	*server_httpmethod_byid(u_int);
d586 1
a586 1
	*server_httperror_byid(u_int);
d593 1
a593 1
int	 server_response_http(struct client *, u_int, struct media_type *,
d606 1
a606 1
int	 server_log_http(struct client *, u_int, size_t);
d628 2
a629 2
int		 imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t,
		    pid_t, int, void *, u_int16_t);
d632 2
a633 2
char		*get_string(u_int8_t *, size_t);
void		*get_data(u_int8_t *, size_t);
d635 2
a636 2
struct in6_addr *prefixlen2mask6(u_int8_t, u_int32_t *);
u_int32_t	 prefixlen2mask(u_int8_t);
d640 4
a643 2
int		 kv_set(struct kv *, char *, ...) __attribute__((__format__ (printf, 2, 3)));
int		 kv_setkey(struct kv *, char *, ...) __attribute__((__format__ (printf, 2, 3)));
d665 1
a665 1
struct auth	*auth_byid(struct serverauth *, u_int32_t);
d681 1
a681 1
const char *printb_flags(const u_int32_t, const char *);
d685 1
a685 1
void	 proc_init(struct privsep *, struct privsep_proc *, u_int);
d690 1
a690 1
	    struct privsep_proc *, u_int,
d694 1
a694 1
	    u_int16_t, int, void *, u_int16_t);
d696 1
a696 1
	    u_int16_t, int, const struct iovec *, int);
d704 3
a706 3
int	 imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t,
	    pid_t, int, void *, u_int16_t);
int	 imsg_composev_event(struct imsgev *, u_int16_t, u_int32_t,
d711 2
a712 2
void	 config_purge(struct httpd *, u_int);
int	 config_setreset(struct httpd *, u_int);
@


1.95
log
@repair hsts header output, wrong format strings caused broken
Strict-Transport-Security headers. Add __format__ attribute to
kv_set() and kv_setkey() to make it easier to spot such problems.

Found by and fix from Donovan Watteau <tsoomi -AT- gmail -DOT- com>,
thanks for your help.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.94 2015/07/29 22:03:41 reyk Exp $	*/
d305 1
@


1.94
log
@backout the previous:  it broke wordpress somehow.
we need more care to find a proper fix for the fastcgi headers.

acknowledged by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.93 2015/07/29 20:03:14 florian Exp $	*/
d638 2
a639 2
int		 kv_set(struct kv *, char *, ...);
int		 kv_setkey(struct kv *, char *, ...);
@


1.93
log
@Read fcgi response records until we have the whole http header and can
parse it. Otherwise http headers can leak into the body.
Pointed out by Jean-Philippe Ouellet on bugs@@ Thanks!
OK reyk, commit ASAP deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.92 2015/07/19 05:17:27 reyk Exp $	*/
a282 7
enum fcgihttpheaderstate {
	FCGI_HTTP_HEADER_ERROR,
	FCGI_HTTP_HEADER_UNREAD,
	FCGI_HTTP_HEADER_READ,
	FCGI_HTTP_HEADER_DONE
};

a318 3
	struct evbuffer		*clt_fcgi_http_header_evb;
	enum fcgihttpheaderstate clt_fcgi_http_header_state;

@


1.92
log
@For the completeness of HSTS, add the non-standard preload option.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.91 2015/07/18 22:19:50 reyk Exp $	*/
d283 7
d326 3
@


1.91
log
@libtls has been changed to set SSL_MODE_ENABLE_PARTIAL_WRITE and
SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER by default.  This gives
tls_write() a similar short write semantics as write(2) and a
workaround in httpd to cope with the previous differences can be
removed.  Specifically, httpd can stop copying data into a local
buffer that was used to keep it around for repeated writes.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.90 2015/07/18 06:00:43 reyk Exp $	*/
d378 4
d463 1
a463 1
	int			 hsts_subdomains;
@


1.90
log
@Allow to change the default media type globally or per-location,
eg. default type text/html.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.89 2015/07/18 05:41:18 florian Exp $	*/
a295 2
	char			*clt_buf;
	size_t			 clt_buflen;
@


1.89
log
@Implement HTTP Strict Transport Security (HSTS).
Input & OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.88 2015/07/16 16:29:25 florian Exp $	*/
d51 1
d357 1
d364 1
a364 1
	"\26SERVER_MATCH\27SERVER_HSTS"
d394 9
d420 1
a492 9
struct media_type {
	char			 media_name[MEDIATYPE_NAMEMAX];
	char			 media_type[MEDIATYPE_TYPEMAX];
	char			 media_subtype[MEDIATYPE_TYPEMAX];
	char			*media_encoding;
	RB_ENTRY(media_type)	 media_entry;
};
RB_HEAD(mediatypes, media_type);

d506 1
d651 4
a654 1
		 media_find(struct mediatypes *, char *);
@


1.88
log
@If we can read faster from disk than send data to the client stop
reading from disk when we hold a certain amount of data in
RAM. Re-enable reading once we send enough data to the
client. Otherwise we might end up with the whole file (which can be
huge) in RAM.
Reported by Matthew Martin ( matt.a.martin AT gmail ) on bugs@@,
thanks!
OK reyk@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.87 2015/07/16 04:46:07 reyk Exp $	*/
d71 1
d355 1
d362 1
a362 1
	"\26SERVER_MATCH"
d447 3
@


1.87
log
@VIS_QUOTE is not there yet, unbreak the tree. Noticed by semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.86 2015/07/15 23:16:38 reyk Exp $	*/
d69 2
@


1.86
log
@Escape the message in server_log() as well.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.85 2015/07/15 16:00:39 jsing Exp $	*/
d51 1
a51 1
#define HTTPD_LOGVIS		VIS_NL|VIS_TAB|VIS_QUOTE|VIS_CSTYLE
@


1.85
log
@Send the TLS certificate and key via separate imsgs, rather than
including them in the IMSG_CFG_SERVER imsg. This allows the certificate
and key to each be almost 16KB (the maximum size for an imsg), rather than
having a combined total of less than 16KB (which can be reached with large
keys, certificate bundles or by including text versions of certificates).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.84 2015/06/23 15:23:14 reyk Exp $	*/
d37 1
d51 1
@


1.84
log
@Add initial support for pattern matching using Lua's pattern matching code.

With important help on the pattern matcher from semarie@@

OK semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.83 2015/05/20 09:28:47 kettenis Exp $	*/
d204 1
d446 10
d694 1
d696 1
@


1.83
log
@Use off_t instead of size_t to pass file size and print it using %lld when
constructing the Content-Length header field.  Should fix some, but probably
not all, problems with serving files bigger than 2G on 32-bit architectures.

ok reyk@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.82 2015/03/15 22:08:45 florian Exp $	*/
d38 2
d283 1
d347 2
d354 2
a355 1
	"\21AUTH\22NO_AUTH\23BLOCK\24NO_BLOCK"
@


1.82
log
@Prevent use after free.
While here unconditionally free clt and move declaration of
server_inflight_dec() into server.c
Found while investigating if (foo != NULL) free(foo) patterns pointed
out by Markus Elfring.
OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.81 2015/02/23 18:43:18 reyk Exp $	*/
d560 1
a560 1
	    size_t, time_t);
@


1.81
log
@Allow to specify CGI variables as macros in redirection strings, eg.
block return 301 "http://www.example.com/$REQUEST_URI"

OK tedu@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.80 2015/02/12 10:05:29 reyk Exp $	*/
a532 1
void	 server_inflight_dec(struct client *, const char *);
@


1.80
log
@Rename escape_uri() to url_encode() because it is the opposite of
url_decode().  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.79 2015/02/12 04:40:23 jsing Exp $	*/
d587 1
@


1.79
log
@Allow TLS protocols to be specified via a "tls protocols" configuration
option.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.78 2015/02/10 08:12:29 florian Exp $	*/
d588 1
a591 1
char		*escape_uri(const char *);
@


1.78
log
@Encode directory listings.
Problem pointed out by remco AT d-compu.dyndns.org some time ago.
Input / OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.77 2015/02/07 23:56:02 reyk Exp $	*/
d413 1
@


1.77
log
@Remove server_load_file() in favor of tls_load_file(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.76 2015/02/07 06:26:28 jsing Exp $	*/
d590 2
@


1.76
log
@Add httpd configuration options to allow the specification of DHE
parameters and the ECDHE curve. This primarily allows for DHE cipher suites
to be enabled.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.75 2015/02/07 01:23:12 reyk Exp $	*/
d404 2
a405 2
	char			*tls_cert;
	off_t			 tls_cert_len;
d410 2
a411 2
	char			*tls_key;
	off_t			 tls_key_len;
@


1.75
log
@Add support for blocking, dropping, and redirecting requests.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.74 2015/02/06 13:05:20 reyk Exp $	*/
d51 2
d408 2
@


1.74
log
@Fix log options in locations.

Reported and tested by Markus Bergkvist
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.73 2015/01/21 22:23:24 reyk Exp $	*/
d340 2
d347 1
a347 1
	"\21AUTH\22NO_AUTH"
d425 4
@


1.73
log
@Ooops, no need to include sys/cdefs.h.

Pointed out by florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.72 2015/01/21 22:21:05 reyk Exp $	*/
d384 1
@


1.72
log
@httpd is based on relayd and had included many headers that are only
needed by its ancestor.  jsg@@, include-what-you-use, and some manual
review helped to cleanup the headers (take iwyu with a grain of salt).
Based on common practice, httpd.h now also includes the necessary
headers for itself.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.71 2015/01/19 20:00:07 florian Exp $	*/
a28 1
#include <sys/cdefs.h>
@


1.71
log
@s/clt_fcgi_remote_user/clt_remote_user/
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.70 2015/01/19 19:37:50 reyk Exp $	*/
d24 3
d28 2
d31 3
d35 1
@


1.70
log
@Decouple auth parameters from struct server_config into struct auth.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.69 2015/01/18 14:01:17 florian Exp $	*/
d301 1
a301 1
	char			*clt_fcgi_remote_user;
@


1.69
log
@First stab at implementing basic auth.
Currently the htpasswd file needs to be in the chroot; will hopefully
improved soonish.
Based on a diff from Oscar Linderholm many months ago but turned into
a complete rewrite.
input/OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.68 2015/01/16 06:40:17 deraadt Exp $	*/
d62 1
d193 1
d330 2
a331 1
#define SRVFLAG_AUTH_BASIC	0x00010000
d337 1
a337 1
	"\21AUTH_BASIC"
d367 7
a382 2
	char			 auth_realm[NAME_MAX];
	char			 auth_htpasswd[PATH_MAX];
d411 4
d457 1
d603 3
d658 2
@


1.68
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.67 2015/01/13 09:21:15 reyk Exp $	*/
d299 1
d328 1
d333 2
a334 1
	"\14SYSLOG\15NO_SYSLOG\16TLS\17ACCESS_LOG\20ERROR_LOG"
d373 2
@


1.67
log
@bump copyright year
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.66 2015/01/04 22:23:58 chrisz Exp $	*/
a25 1
#include <sys/param.h>		/* MAXHOSTNAMELEN */
d363 1
a363 1
	char			 name[MAXHOSTNAMELEN];
d366 2
a367 2
	char			 root[MAXPATHLEN];
	char			 socket[MAXPATHLEN];
@


1.66
log
@add new url stripping option:

strip number
	Strip number path components from the beginning of the
	request URI before looking up the stripped-down URI at
	the document root.


reviewed with much patience and OK by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.65 2015/01/02 19:09:52 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 - 2014 Reyk Floeter <reyk@@openbsd.org>
@


1.65
log
@Bump config flags field to 32bits.  Makes room for future changes -
but no functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.64 2014/12/12 14:45:59 reyk Exp $	*/
d388 1
d528 2
@


1.64
log
@Like previously done in relayd, change the keyword "ssl" to "tls" to
reflect reality.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.63 2014/11/11 15:54:45 beck Exp $	*/
d312 16
a327 16
#define SRVFLAG_INDEX		0x0001
#define SRVFLAG_NO_INDEX	0x0002
#define SRVFLAG_AUTO_INDEX	0x0004
#define SRVFLAG_NO_AUTO_INDEX	0x0008
#define SRVFLAG_ROOT		0x0010
#define SRVFLAG_LOCATION	0x0020
#define SRVFLAG_FCGI		0x0040
#define SRVFLAG_NO_FCGI		0x0080
#define SRVFLAG_LOG		0x0100
#define SRVFLAG_NO_LOG		0x0200
#define SRVFLAG_SOCKET		0x0400
#define SRVFLAG_SYSLOG		0x0800
#define SRVFLAG_NO_SYSLOG	0x1000
#define SRVFLAG_TLS		0x2000
#define SRVFLAG_ACCESS_LOG	0x4000
#define SRVFLAG_ERROR_LOG	0x8000
d387 1
a387 1
	u_int16_t		 flags;
@


1.63
log
@Allow the log directory to be configurable in the config file, rather than
fixed as /logs within the chroot.  As this httpd is properly privesp'ed this
has the nice property of allowing us to put the logs outside the chroot if
we want to.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.62 2014/11/03 18:43:24 bluhm Exp $	*/
d41 3
a43 3
#define HTTPD_SSL_CERT		"/etc/ssl/server.crt"
#define HTTPD_SSL_KEY		"/etc/ssl/private/server.key"
#define HTTPD_SSL_CIPHERS	"HIGH:!aNULL"
d325 1
a325 1
#define SRVFLAG_SSL		0x2000
d332 1
a332 1
	"\14SYSLOG\15NO_SYSLOG\16SSL\17ACCESS_LOG\20ERROR_LOG"
d379 7
a385 7
	char			*ssl_cert;
	off_t			 ssl_cert_len;
	char			*ssl_cert_file;
	char			 ssl_ciphers[NAME_MAX];
	char			*ssl_key;
	off_t			 ssl_key_len;
	char			*ssl_key_file;
d467 1
a467 1
int	 server_ssl_load_keypair(struct server *);
@


1.62
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.61 2014/10/31 13:49:52 jsing Exp $	*/
d436 1
@


1.61
log
@Update httpd(8) to use libtls instead of libressl.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.60 2014/10/22 09:48:03 reyk Exp $	*/
d590 1
@


1.60
log
@URL-decode the request path.

Tested by ajacoutot@@ and others
OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.59 2014/09/10 15:39:57 reyk Exp $	*/
d29 1
a29 1
#include <ressl.h>
d284 1
a284 1
	struct ressl		*clt_ressl_ctx;
d411 2
a412 2
	struct ressl		 *srv_ressl_ctx;
	struct ressl_config	 *srv_ressl_config;
@


1.59
log
@Handle different possible variations of the Host header (eg.
www.example.com, www.example.com:80, [2001:db8::1], [2001:db8::1]:80).
The port is optional and is typically used on non-default ports.  If
the server name is a plain IPv6 address, it is commonly specified in
square brackets.

Makes ajacoutot@@ happy
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.58 2014/09/05 10:04:20 reyk Exp $	*/
d546 1
@


1.58
log
@Remove a limitation that only allowed to specify a server name once.
The key has been changed to server name + address + port and now it is
possible to use the same server name for multiple servers with
different addresses, eg. http://www.example.com and
https://www.example.com/.

OK doug@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.57 2014/09/02 16:20:41 reyk Exp $	*/
d530 1
@


1.57
log
@FastCGI did not support persistent connections.  Add initial support
for persistent connections with FastCGI by implementing chunked
Transfer-Encoding.  This only works with HTTP/1.1.

With input and help from florian@@ who found some FastCGI edge cases.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.56 2014/09/01 09:32:43 reyk Exp $	*/
d469 2
@


1.56
log
@Replace the code to get the FastCGI Status header with a proper way to
parse and write the headers using the http response descriptor.  This
allows to add other tweaks, like support for chunked encoding, later.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.55 2014/08/29 13:01:46 reyk Exp $	*/
d298 2
d483 2
@


1.55
log
@Use two instead of one http descriptor for request and response.

OK chrisz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.54 2014/08/21 19:23:10 chrisz Exp $	*/
d546 1
@


1.54
log
@Add Last-Modified: HTTP header.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.53 2014/08/13 16:04:28 reyk Exp $	*/
d279 2
a280 1
	void			*clt_desc;
d512 1
a512 1
int	 server_headers(struct client *,
@


1.53
log
@Provide a failsafe version of the path_info() function that doesn't
need a temporary path variable.  Based on an initial diff from
chrisz@@.

"Commit any failsafe version and I'm ok with it" chrisz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.52 2014/08/08 18:29:42 reyk Exp $	*/
d515 1
a515 1
	    size_t);
d523 1
a523 1
void	 server_http_date(char *, size_t);
@


1.52
log
@When opening directories, re-match the location after the index file
has been appended.  This allows to use a fastcgi target as the default
index, for example index.php.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.51 2014/08/06 18:21:14 reyk Exp $	*/
d540 1
a540 1
ssize_t		 path_info(char *);
@


1.51
log
@Limit the body size in client requests (eg. POST data) to 1M by default;
add a configuration option to change the limit.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.50 2014/08/06 16:09:02 jsing Exp $	*/
d519 2
@


1.51.2.1
log
@httpd was developed very rapidly in the weeks before 5.6 release,
and it has a few flaws.  It would be nice to get these flaws fully
remediated before the next release, and that requires the community
to want to use it.
Therefore here is a "jumbo" patch that brings in the most important fixes.

committing on behalf of reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.51 2014/08/06 18:21:14 reyk Exp $	*/
d279 1
a279 2
	void			*clt_descreq;
	void			*clt_descresp;
a296 2
	int			 clt_fcgi_chunked;
	int			 clt_fcgi_end;
a465 2
void	 serverconfig_free(struct server_config *);
void	 serverconfig_reset(struct server_config *);
a479 2
int	 server_bufferevent_printf(struct client *, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
d511 1
a511 1
int	 server_headers(struct client *, void *,
d515 1
a515 1
	    size_t, time_t);
a518 2
struct server_config *
	 server_getlocation(struct client *, const char *);
d521 1
a521 2
char	*server_http_parsehost(char *, char *, size_t, int *);
ssize_t	 server_http_time(time_t, char *, size_t);
a535 1
const char	*url_decode(char *);
d538 1
a538 1
size_t		 path_info(char *);
a542 1
char		*evbuffer_getline(struct evbuffer *);
a577 1
void	logit(int, const char *, ...) __attribute__((__format__ (printf, 2, 3)));
@


1.50
log
@Configure the default SSL ciphers as HIGH:!aNULL.

ok deraadt@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.49 2014/08/06 15:08:04 florian Exp $	*/
d53 1
d374 1
@


1.49
log
@http POST support
with & OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.48 2014/08/06 09:36:31 reyk Exp $	*/
d41 1
d43 1
a43 1
#define HTTPD_SSL_CERT		"/etc/ssl/server.crt"
d377 1
@


1.48
log
@Adjust the read/write watermarks according to the TCP send buffer.
This fixes sending of large files.  Previously, httpd was reading the
input file too quickly and could run out of memory when filling the
input buffer.

Found by jsg@@
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.47 2014/08/06 02:04:42 jsing Exp $	*/
d63 2
d526 1
@


1.47
log
@Load the SSL public/private keys in the parent process, then provide them
to the privsep process via imsg. This allows the keys to be moved out of
the chroot (now /etc/ssl/server.crt, /etc/ssl/private/server.key).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.46 2014/08/05 18:01:10 reyk Exp $	*/
d276 1
@


1.46
log
@Add configuration options for the most-important connection limits:
max requests (per connection) and timeout.  We don't want to add too
many button, and there are good defaults, but these ones are kind of
mandatory.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.45 2014/08/05 16:30:35 reyk Exp $	*/
d41 2
a42 2
#define HTTPD_SSL_KEY		"/conf/server.key"
#define HTTPD_SSL_CERT		"/conf/server.crt"
d370 7
d456 1
@


1.45
log
@Limit the number of (Keep-Alive) requests per connection to 100.
(Same default as in nginx and Apache).
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.44 2014/08/05 15:36:59 reyk Exp $	*/
d283 1
a283 1
	int			 clt_persist;
d366 1
d368 1
a368 1
	int			 prefixlen;
@


1.44
log
@Improve logging to allow per- server/location log files.  The log
files can also be owned by root now: they're opened by the parent and
send to the logger process with fd passing.  This also works with reload.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.43 2014/08/05 09:24:21 jsg Exp $	*/
d51 1
@


1.43
log
@add a config option to specify the chroot directory
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.42 2014/08/04 18:12:15 reyk Exp $	*/
d38 3
a40 2
#define HTTPD_ACCESS_LOG	"/logs/access.log"
#define HTTPD_ERROR_LOG		"/logs/error.log"
d190 2
a191 1
	IMSG_LOG_ERROR
d317 2
d323 1
a323 1
	"\14SYSLOG\15NO_SYSLOG"
d345 8
d360 2
d365 1
a366 1
	struct timeval		 timeout;
d376 2
d458 2
a459 4
void	 server_log_access(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	 server_log_error(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
d473 4
d606 1
@


1.42
log
@Temporarily move the default location of the SSL/TLS server key and
certificate from /var/www/ to /var/www/conf/.  Don't get scared - this
will be changed soon!  They're currently located in the chroot
directory but will be moved outside as soon as we adopted some of the
key privsep from relayd in ressl/httpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.41 2014/08/04 17:38:12 reyk Exp $	*/
d400 1
@


1.41
log
@Proxy commit for jsing@@:
"Add TLS/SSL support to httpd, based on the recent ressl commits."

From jsing@@
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.40 2014/08/04 15:49:28 reyk Exp $	*/
d40 2
@


1.40
log
@Add initial support for log files in /var/www/logs/.  Logging with
syslog is still supported but disabled by default.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.39 2014/08/04 14:49:24 reyk Exp $	*/
d29 1
d266 2
d273 1
d312 1
d373 3
@


1.39
log
@Implement PATH_INFO and add DOCUMENT_ROOT.
PATH_INFO was requested by naddy@@ who successfully tested it with "cvsweb".

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.38 2014/08/04 06:35:10 deraadt Exp $	*/
d37 2
d181 1
d184 3
a186 1
	IMSG_CFG_DONE
d193 1
d198 1
a198 1
#define PROC_CONTROL	PROC_PARENT
d226 1
d306 2
d309 4
a312 3
#define SRVFLAG_BITS						\
	"\10\01INDEX\02NO_INDEX\03AUTO_INDEX\04NO_AUTO_INDEX"	\
	"\05ROOT\06LOCATION\07FCGI\10NO_FCGI\11LOG\12NO_LOG\13SOCKET"
d389 1
d431 4
d574 3
@


1.38
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.37 2014/08/03 20:39:40 reyk Exp $	*/
d476 1
@


1.37
log
@Dynamically pass HTTP request headers as protocol-specific HTTP_* CGI
meta-variables.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.36 2014/08/03 12:26:19 reyk Exp $	*/
d486 1
a486 1
		     volatile int *);
@


1.36
log
@Add function to iterate all headers.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.35 2014/08/03 11:16:10 reyk Exp $	*/
d449 3
a451 2
int	 server_writeheader_http(struct client *clt, struct kv *);
int	 server_headers(struct client *, int (*)(struct client *, struct kv *));
@


1.35
log
@Split fastcgi socket path and document root option and add the
SCRIPT_FILENAME CGI param with a prepended root.  This fixes php-fpm
that expects SCRIPT_FILENAME and also works with slowcgi if you
configure the root correctly.  For example, if SCRIPT_NAME and
REQUEST_URI are /php/index.php, root is /htdocs, SCRIPT_FILENAME will
be /htdocs/php/index.php.  As tested and discussed with florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.34 2014/08/03 10:26:43 reyk Exp $	*/
d449 2
a450 2
int	 server_writeheader_kv(struct client *, struct kv *);
int	 server_writeheader_http(struct client *);
@


1.34
log
@Add another log mode "connection" for a relayd(8)-style log entry after
each connection, not every request.  The code was already there and enabled
on debug, I just turned it into an alternative log format.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.33 2014/08/02 21:21:47 doug Exp $	*/
d288 11
a298 10
#define SRVFLAG_INDEX		0x001
#define SRVFLAG_NO_INDEX	0x002
#define SRVFLAG_AUTO_INDEX	0x004
#define SRVFLAG_NO_AUTO_INDEX	0x008
#define SRVFLAG_PATH		0x010
#define SRVFLAG_LOCATION	0x020
#define SRVFLAG_FCGI		0x040
#define SRVFLAG_NO_FCGI		0x080
#define SRVFLAG_LOG		0x100
#define SRVFLAG_NO_LOG		0x200
d302 1
a302 1
	"\05PATH\06LOCATION\07FCGI\10NO_FCGI\11LOG\12NO_LOG"
d329 2
a330 1
	char			 path[MAXPATHLEN];
@


1.33
log
@Locations now inherit access log settings from the server.

Add log to the server flags.

input/"Looks ok" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.32 2014/08/02 17:05:18 florian Exp $	*/
d319 2
a320 1
	LOG_FORMAT_COMBINED
d417 1
a417 1
void	 server_log(struct client *);
@


1.32
log
@Padding of fcgi records is optional, but if we receive padding data we
should read it.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.31 2014/08/02 11:52:00 reyk Exp $	*/
d288 10
a297 8
#define SRVFLAG_INDEX		0x01
#define SRVFLAG_NO_INDEX	0x02
#define SRVFLAG_AUTO_INDEX	0x04
#define SRVFLAG_NO_AUTO_INDEX	0x08
#define SRVFLAG_PATH		0x10
#define SRVFLAG_LOCATION	0x20
#define SRVFLAG_FCGI		0x40
#define SRVFLAG_NO_FCGI		0x80
d301 1
a301 1
	"\05PATH\06LOCATION\07FCGI\10NO_FCGI"
d318 2
a319 3
	LOG_FORMAT_NONE = -1,
	LOG_FORMAT_COMMON = 0,
	LOG_FORMAT_COMBINED,
d334 1
a334 1
	u_int8_t		 flags;
@


1.31
log
@Allow to specify a FastCGI TCP socket on localhost (eg. :9000).  Used
for debugging, you should prefer local UNIX sockets, but it helped to
find an issue that will be fixed with the next commit.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.30 2014/08/01 22:24:05 reyk Exp $	*/
d242 2
a243 1
	FCGI_READ_CONTENT
d274 1
@


1.30
log
@Use the log buffer to defer the logging until the connection is closed
or the request completed.  Turn the old log message into a debug message.

ok doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.29 2014/08/01 21:59:56 reyk Exp $	*/
d408 2
@


1.29
log
@remove the global "log updates/all" option that came from relayd.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.28 2014/08/01 21:51:02 doug Exp $	*/
d411 1
@


1.28
log
@Add common and combined access logging to httpd.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.27 2014/08/01 08:34:46 florian Exp $	*/
a382 3
#define HTTPD_OPT_LOGUPDATE		0x08
#define HTTPD_OPT_LOGNOTIFY		0x10
#define HTTPD_OPT_LOGALL		0x18
@


1.27
log
@Correctly parse fcgi records if we don't get the whole record in one
bufferevent_read().
Input/OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.26 2014/07/31 18:07:11 reyk Exp $	*/
d313 6
d338 2
d454 1
@


1.26
log
@Only write the HTTP header for the first fastcgi chunk.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.25 2014/07/31 17:55:09 reyk Exp $	*/
d240 5
d271 4
@


1.25
log
@some fastcgi improvements:
- DPRINTF instead of log_info for internal debugging.
- submit QUERY_STRING, if it exists
- use a proper function to create an HTTP header.
- use server_file_error() to detect EOF and fastcgi stream errors.
- disable keep-alive/persist for now until we have a reliable way to
get the content length from the cgi response or support chunked
encoding.

"Cool, jep" florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.24 2014/07/31 14:25:14 reyk Exp $	*/
d264 1
@


1.24
log
@One bufferevent can be shared by file and fcgi.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.23 2014/07/31 14:18:38 reyk Exp $	*/
d435 1
d439 1
@


1.23
log
@Allow to specify a non-default fastcgi socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.22 2014/07/31 13:28:15 reyk Exp $	*/
d257 1
a257 2
	struct bufferevent	*clt_file;
	struct bufferevent	*clt_fcgi;
@


1.22
log
@Rename the "docroot" variable to "path" because it will be used for
either files or the fastcgi socket (and there's no need to use a union yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.21 2014/07/31 09:34:57 reyk Exp $	*/
d36 1
@


1.21
log
@Add a configuration variable "fastcgi" to enable it per server or location.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.20 2014/07/31 09:23:53 florian Exp $	*/
d280 1
a280 1
#define SRVFLAG_DOCROOT		0x10
d287 1
a287 1
	"\05LOCATION\06FCGI\07NO_FCGI"
d306 1
a306 1
	char			 docroot[MAXPATHLEN];
d308 1
a308 1
	char			 location[NAME_MAX];
@


1.20
log
@Put in first stab at fastcgi. Very early work in progress. Putting it
in now so that we can quickly work on it in tree. Requested by reyk@@.
deraadt@@ is OK with this according to reyk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.19 2014/07/30 13:49:48 reyk Exp $	*/
d282 2
d286 2
a287 1
	"\10\01INDEX\02NO_INDEX\03AUTO_INDEX\04NO_AUTO_INDEX\05LOCATION"
@


1.19
log
@Make "location" work with name-based virtual servers.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.18 2014/07/30 10:05:14 reyk Exp $	*/
d257 1
d435 3
@


1.18
log
@Add "location" keyword to specify path-specific configuration in
servers, for example auto index for a sub-directory only.  Internally,
a "location" is just a special type of a "virtual" server.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.17 2014/07/29 16:17:28 reyk Exp $	*/
a404 2
struct server *
	 server_byname(const char *);
@


1.17
log
@Add extended directory index options: "[no] index" and "[no] auto index".
The option "directory auto index" implements basic directory listing
and is turned off by default.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.16 2014/07/29 12:16:36 reyk Exp $	*/
d279 2
d283 1
a283 1
	"\10\01INDEX\02NO_INDEX\03AUTO_INDEX\04NO_AUTO_INDEX"
d304 1
d405 2
@


1.16
log
@Move configurable TCP options into struct server_config.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.15 2014/07/25 23:30:58 reyk Exp $	*/
d275 8
a298 1
	u_int32_t		 flags;
d301 2
d308 1
@


1.15
log
@Differentiate servers by address and port, not just by address.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.14 2014/07/25 23:23:39 reyk Exp $	*/
a54 14
#define TCPFLAG_NODELAY		0x01
#define TCPFLAG_NNODELAY	0x02
#define TCPFLAG_SACK		0x04
#define TCPFLAG_NSACK		0x08
#define TCPFLAG_BUFSIZ		0x10
#define TCPFLAG_IPTTL		0x20
#define TCPFLAG_IPMINTTL	0x40
#define TCPFLAG_NSPLICE		0x80
#define TCPFLAG_DEFAULT		0x00

#define TCPFLAG_BITS						\
	"\10\01NODELAY\02NO_NODELAY\03SACK\04NO_SACK"		\
	"\05SOCKET_BUFFER_SIZE\06IP_TTL\07IP_MINTTL\10NO_SPLICE"

d275 14
d299 6
a312 6

	u_int8_t		 srv_tcpflags;
	int			 srv_tcpbufsiz;
	int			 srv_tcpbacklog;
	u_int8_t		 srv_tcpipttl;
	u_int8_t		 srv_tcpipminttl;
@


1.14
log
@It is recommended to use a URL in the Location header of 3xx
responses.  To accomplish this, add some semantics to retrieve the
server host name of a connection: either IP, IP:PORT (if not 80) or
[IP6]:PORT, or Host value (if valid).
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.13 2014/07/25 21:29:58 reyk Exp $	*/
d391 1
a391 1
	 server_byaddr(struct sockaddr *);
@


1.13
log
@Canonicalize the request path once without the docroot and prepend the
docroot only only when it's needed.  Suggested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.12 2014/07/25 16:23:19 reyk Exp $	*/
d259 1
d416 2
@


1.12
log
@Add support for "virtual hosts" aka. server blocks aka. multiple
servers with the same or "overlapping" IP address but a different name.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.11 2014/07/25 13:10:18 reyk Exp $	*/
d424 1
a424 1
const char	*canonicalize_path(const char *, const char *, char *, size_t);
@


1.11
log
@Split server and server_config.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.10 2014/07/25 12:46:23 reyk Exp $	*/
d126 1
d295 1
d297 2
d300 1
d305 1
d389 2
d431 3
@


1.10
log
@Rename a field, needed later, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.9 2014/07/25 12:42:05 reyk Exp $	*/
d256 1
@


1.9
log
@Move the docroot into the server block.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.8 2014/07/24 08:11:27 reyk Exp $	*/
d255 2
a256 2
	void			*clt_server;
	u_int32_t		 clt_serverid;
@


1.8
log
@Remove unused fields from structure
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.7 2014/07/23 19:03:56 reyk Exp $	*/
d290 1
@


1.7
log
@Add canonicalize_path() to canonicalize the requested URL path.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.6 2014/07/23 13:26:39 reyk Exp $	*/
a305 4
	struct bufferevent	*srv_bev;
	int			 srv_dsts;
	struct bufferevent	*srv_dstbev;

@


1.6
log
@Correctly shutdown the servers when the process is terminating;
prevents a crash on exit.  With debugging help from blambert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.5 2014/07/23 12:01:27 reyk Exp $	*/
d34 2
d418 1
@


1.5
log
@always enable DPRINTF with compiled with DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.4 2014/07/16 10:25:28 reyk Exp $	*/
d365 1
@


1.4
log
@Implement file descriptor accounting.  The concept was taken from
relayd but had to be adjusted for httpd.  It now handles single-pass
HTTP connections, persistent connections with multiple requests, and
body-less HEAD requests.  With input from benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.3 2014/07/14 00:19:48 reyk Exp $	*/
d75 1
a75 1
#if DEBUG > 1
@


1.3
log
@first step towards keep-alive/persistent connections support
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.2 2014/07/13 14:17:37 reyk Exp $	*/
d268 1
a270 1
	size_t			 clt_headerlen;
d272 1
d381 1
@


1.2
log
@Add support for media types (aka. MIME types): the types section is
compatible to nginx' mime.types file which can be included directly.
If not present, use a few built-in defaults for html, css, txt, jpeg,
gif, png, and js.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.h,v 1.1 2014/07/12 23:34:54 reyk Exp $	*/
d71 2
a72 1
	TOREAD_HTTP_CHUNK_TRAILER	= -4
d268 1
d399 2
d403 1
d406 1
a406 1
int	 server_response(struct httpd *, struct client *);
@


1.1
log
@Add httpd(8), an attempt to turn the relayd(8) codebase into a simple
web server.  It is not finished yet and I just started it today, but
the goal is to provide an HTTP server that a) provides minimal
features, b) serves static files, c) provides FastCGI support, and d)
follows common coding practices of OpenBSD.

It will neither support plugins, nor custom memory allocators, EBCDIC
support, PCRE or any other things that can be found elsewhere.
httpd(8) is not intended to provide a fully-featured replacement for
nginx(8) or the Apache, but it will provide enough functionality that
is needed in the OpenBSD base system.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 3
d49 2
a50 1
#define CONFIG_SERVERS		0x01
d189 1
d312 9
d330 1
d401 1
a401 1
int	 server_response(struct client *);
d427 7
d435 1
d485 2
@

