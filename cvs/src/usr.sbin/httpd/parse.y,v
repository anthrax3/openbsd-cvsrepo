head	1.92;
access;
symbols
	OPENBSD_6_2_BASE:1.92
	OPENBSD_6_1:1.90.0.4
	OPENBSD_6_1_BASE:1.90
	OPENBSD_6_0:1.78.0.2
	OPENBSD_6_0_BASE:1.78
	OPENBSD_5_9:1.77.0.2
	OPENBSD_5_9_BASE:1.77
	OPENBSD_5_8:1.73.0.4
	OPENBSD_5_8_BASE:1.73
	OPENBSD_5_7:1.65.0.2
	OPENBSD_5_7_BASE:1.65
	OPENBSD_5_6:1.34.0.2
	OPENBSD_5_6_BASE:1.34;
locks; strict;
comment	@ * @;


1.92
date	2017.08.28.06.00.05;	author florian;	state Exp;
branches;
next	1.91;
commitid	faUqpJctBIBuXYb0;

1.91
date	2017.08.11.18.48.56;	author jsing;	state Exp;
branches;
next	1.90;
commitid	RqXM9HKDTTdTxuJj;

1.90
date	2017.03.25.17.25.34;	author claudio;	state Exp;
branches;
next	1.89;
commitid	43NsM2S8LTb1McoD;

1.89
date	2017.02.07.12.27.42;	author reyk;	state Exp;
branches;
next	1.88;
commitid	39LWvR7k2X9Ou0Vd;

1.88
date	2017.01.27.07.03.27;	author tom;	state Exp;
branches;
next	1.87;
commitid	slOBNDigsyjRr000;

1.87
date	2017.01.05.13.53.09;	author krw;	state Exp;
branches;
next	1.86;
commitid	3AKCl24jEn0sIt6p;

1.86
date	2017.01.05.12.42.18;	author krw;	state Exp;
branches;
next	1.85;
commitid	uzjOUwLRoN7KbcZI;

1.85
date	2016.11.17.14.52.48;	author jsing;	state Exp;
branches;
next	1.84;
commitid	9adJPMuYYFWkfsUD;

1.84
date	2016.11.06.15.50.47;	author beck;	state Exp;
branches;
next	1.83;
commitid	bTKbqUiGVOmqMiOm;

1.83
date	2016.11.06.10.49.38;	author beck;	state Exp;
branches;
next	1.82;
commitid	49Xfy4fsPamn6Ga1;

1.82
date	2016.09.03.14.44.21;	author reyk;	state Exp;
branches;
next	1.81;
commitid	n0F9VKkYrh9A46uy;

1.81
date	2016.08.22.15.02.18;	author jsing;	state Exp;
branches;
next	1.80;
commitid	kgucYc6Cn9YK2ZhC;

1.80
date	2016.08.15.16.12.34;	author jsing;	state Exp;
branches;
next	1.79;
commitid	ywDK1QHdQbsHLFgT;

1.79
date	2016.08.15.13.48.24;	author jsing;	state Exp;
branches;
next	1.78;
commitid	el084N3wYoLArEkM;

1.78
date	2016.06.21.21.35.24;	author benno;	state Exp;
branches;
next	1.77;
commitid	AL6SnrmnHkmPOpjv;

1.77
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.76;
commitid	T3JBYxNT0thPuavp;

1.76
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.75;
commitid	z3HrihslRYb4HqW9;

1.75
date	2015.08.20.13.00.23;	author reyk;	state Exp;
branches;
next	1.74;
commitid	WDQybNKi4LiEFw8K;

1.74
date	2015.08.19.21.26.21;	author reyk;	state Exp;
branches;
next	1.73;
commitid	CBj3QjLYa3H2cfyp;

1.73
date	2015.07.19.05.17.27;	author reyk;	state Exp;
branches;
next	1.72;
commitid	jdqdR7UPKnGDga2T;

1.72
date	2015.07.18.06.00.43;	author reyk;	state Exp;
branches;
next	1.71;
commitid	GYrjpgr4p814WbAx;

1.71
date	2015.07.18.05.41.18;	author florian;	state Exp;
branches;
next	1.70;
commitid	2Fg8acs1mTRftiTA;

1.70
date	2015.07.16.19.05.28;	author reyk;	state Exp;
branches;
next	1.69;
commitid	uD9Qfc9LJPALunq8;

1.69
date	2015.07.15.17.14.50;	author jsing;	state Exp;
branches;
next	1.68;
commitid	2nStwAyixed69aI2;

1.68
date	2015.06.23.15.23.14;	author reyk;	state Exp;
branches;
next	1.67;
commitid	KmQD0QhuAUl1XRCr;

1.67
date	2015.04.01.04.51.15;	author jsg;	state Exp;
branches;
next	1.66;
commitid	nKLyahYVDFxzjkHd;

1.66
date	2015.03.09.15.46.45;	author reyk;	state Exp;
branches;
next	1.65;
commitid	cHAHyuhC4AkZXh8Z;

1.65
date	2015.02.12.04.40.23;	author jsing;	state Exp;
branches;
next	1.64;
commitid	4hspTe8KgQAkgFb0;

1.64
date	2015.02.08.04.50.32;	author reyk;	state Exp;
branches;
next	1.63;
commitid	jVCsun3nRn9HXgv1;

1.63
date	2015.02.08.00.00.59;	author reyk;	state Exp;
branches;
next	1.62;
commitid	T0lfZLuka5kZO7cg;

1.62
date	2015.02.07.06.26.28;	author jsing;	state Exp;
branches;
next	1.61;
commitid	Jsq1AV9W6epuXQBP;

1.61
date	2015.02.07.01.23.12;	author reyk;	state Exp;
branches;
next	1.60;
commitid	tJajgOHQ1aZRGbKl;

1.60
date	2015.02.06.13.05.20;	author reyk;	state Exp;
branches;
next	1.59;
commitid	WzsLdaJsWwlcIzRK;

1.59
date	2015.01.29.08.52.52;	author reyk;	state Exp;
branches;
next	1.58;
commitid	JohsalaNJ8LItqdP;

1.58
date	2015.01.21.22.21.05;	author reyk;	state Exp;
branches;
next	1.57;
commitid	64Zc6bef54Vu2Noy;

1.57
date	2015.01.19.21.07.33;	author reyk;	state Exp;
branches;
next	1.56;
commitid	Cr1mCt0wWEAa8BcS;

1.56
date	2015.01.19.19.37.50;	author reyk;	state Exp;
branches;
next	1.55;
commitid	95e2Z6BqzOOfEsll;

1.55
date	2015.01.18.14.01.17;	author florian;	state Exp;
branches;
next	1.54;
commitid	7n1dHfzjQzsDnx3e;

1.54
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	Uu5nFG3wCl0LACBb;

1.53
date	2015.01.13.09.21.15;	author reyk;	state Exp;
branches;
next	1.52;
commitid	vlRoyiZgaC5QvCo7;

1.52
date	2015.01.07.11.04.29;	author reyk;	state Exp;
branches;
next	1.51;
commitid	WQM3zQopkMqrWIXz;

1.51
date	2015.01.06.14.07.48;	author reyk;	state Exp;
branches;
next	1.50;
commitid	hbuEM4rAFoNpF9Xp;

1.50
date	2015.01.04.22.23.58;	author chrisz;	state Exp;
branches;
next	1.49;
commitid	PxQkOIiHP7NqIPYy;

1.49
date	2015.01.03.23.54.25;	author reyk;	state Exp;
branches;
next	1.48;
commitid	IH4cHK0wOi5IuXuc;

1.48
date	2015.01.03.16.20.31;	author reyk;	state Exp;
branches;
next	1.47;
commitid	TtgvMPUAoU53eXip;

1.47
date	2015.01.03.15.49.18;	author reyk;	state Exp;
branches;
next	1.46;
commitid	9CmQ2ohpRPUtdzFN;

1.46
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.45;
commitid	XnjIOhurXdX5o1V9;

1.45
date	2014.12.18.10.10.11;	author reyk;	state Exp;
branches;
next	1.44;
commitid	MzVOWmcjMTtZ5ELT;

1.44
date	2014.12.12.14.45.59;	author reyk;	state Exp;
branches;
next	1.43;
commitid	j2F3LZ1OyONol7u9;

1.43
date	2014.12.04.02.44.42;	author tedu;	state Exp;
branches;
next	1.42;
commitid	A2H8wpKaas7ra1zW;

1.42
date	2014.11.20.05.51.20;	author jsg;	state Exp;
branches;
next	1.41;
commitid	3Z7yItGpFsmshk0c;

1.41
date	2014.11.11.15.54.45;	author beck;	state Exp;
branches;
next	1.40;
commitid	ki9qbAAMZ7dFJTRL;

1.40
date	2014.11.03.18.43.24;	author bluhm;	state Exp;
branches;
next	1.39;
commitid	awoa44OYi1wnC5N7;

1.39
date	2014.11.03.03.46.44;	author doug;	state Exp;
branches;
next	1.38;
commitid	ySikNROqsbfuJcrP;

1.38
date	2014.09.05.10.04.20;	author reyk;	state Exp;
branches;
next	1.37;
commitid	L018oMJIofTIKQBT;

1.37
date	2014.09.04.13.45.17;	author reyk;	state Exp;
branches;
next	1.36;
commitid	QmsPNsK45rPNnF2l;

1.36
date	2014.08.25.14.27.54;	author reyk;	state Exp;
branches;
next	1.35;
commitid	9BrKucaQiTo8j21n;

1.35
date	2014.08.09.07.35.45;	author reyk;	state Exp;
branches;
next	1.34;
commitid	XVUYZ60vxeT5Y1rP;

1.34
date	2014.08.06.20.29.54;	author reyk;	state Exp;
branches
	1.34.2.1;
next	1.33;
commitid	JDxuBybaCzkECcWt;

1.33
date	2014.08.06.18.21.14;	author reyk;	state Exp;
branches;
next	1.32;
commitid	jZUEHtimlVJa4lx5;

1.32
date	2014.08.06.16.11.34;	author jsing;	state Exp;
branches;
next	1.31;
commitid	ebob1eJXfL1TNUpx;

1.31
date	2014.08.06.16.09.02;	author jsing;	state Exp;
branches;
next	1.30;
commitid	CZdtcBfBkirUWTpH;

1.30
date	2014.08.06.12.56.58;	author reyk;	state Exp;
branches;
next	1.29;
commitid	riXTx0iMqjDxBeF1;

1.29
date	2014.08.06.02.04.42;	author jsing;	state Exp;
branches;
next	1.28;
commitid	Wq3y58SpTrH6PeRm;

1.28
date	2014.08.05.18.01.10;	author reyk;	state Exp;
branches;
next	1.27;
commitid	bNgJHQQ6lNzksAJO;

1.27
date	2014.08.05.17.03.21;	author reyk;	state Exp;
branches;
next	1.26;
commitid	ulX0VuMNq02xaDM4;

1.26
date	2014.08.05.16.46.35;	author reyk;	state Exp;
branches;
next	1.25;
commitid	Y1Qcoeg2kKNpOxtd;

1.25
date	2014.08.05.15.36.59;	author reyk;	state Exp;
branches;
next	1.24;
commitid	0eZ0KmX2vQuZV9Ts;

1.24
date	2014.08.05.09.24.21;	author jsg;	state Exp;
branches;
next	1.23;
commitid	NFtWiwbcZQWHRBUA;

1.23
date	2014.08.04.17.38.12;	author reyk;	state Exp;
branches;
next	1.22;
commitid	QN0gng3yApfUkUG0;

1.22
date	2014.08.04.16.07.59;	author reyk;	state Exp;
branches;
next	1.21;
commitid	DOpcuTQXLhUVV2le;

1.21
date	2014.08.04.15.49.28;	author reyk;	state Exp;
branches;
next	1.20;
commitid	LDlAyIlUWDBjADa5;

1.20
date	2014.08.04.11.09.25;	author reyk;	state Exp;
branches;
next	1.19;
commitid	Dj6ALT3dpIHqBQcw;

1.19
date	2014.08.03.20.43.03;	author reyk;	state Exp;
branches;
next	1.18;
commitid	TtWvHWpY8PUl6hQO;

1.18
date	2014.08.03.11.16.10;	author reyk;	state Exp;
branches;
next	1.17;
commitid	fIgJJaAKavK3V1Ms;

1.17
date	2014.08.03.10.26.43;	author reyk;	state Exp;
branches;
next	1.16;
commitid	J4iRjIQasNlCySVe;

1.16
date	2014.08.02.21.21.47;	author doug;	state Exp;
branches;
next	1.15;
commitid	eYHmkmq5eeXpnLSo;

1.15
date	2014.08.01.21.59.56;	author reyk;	state Exp;
branches;
next	1.14;
commitid	x6XXpbpENAdHhEQS;

1.14
date	2014.08.01.21.51.02;	author doug;	state Exp;
branches;
next	1.13;
commitid	EQrn6y0IO5CKfaGo;

1.13
date	2014.07.31.14.18.38;	author reyk;	state Exp;
branches;
next	1.12;
commitid	YuIDlOouHxlacCk2;

1.12
date	2014.07.31.13.28.15;	author reyk;	state Exp;
branches;
next	1.11;
commitid	HDnnTvoJZbrXmrWp;

1.11
date	2014.07.31.09.34.57;	author reyk;	state Exp;
branches;
next	1.10;
commitid	KZnViLTHk4UhEJQd;

1.10
date	2014.07.30.13.49.48;	author reyk;	state Exp;
branches;
next	1.9;
commitid	xXDeSGReD1XsNQaP;

1.9
date	2014.07.30.10.05.14;	author reyk;	state Exp;
branches;
next	1.8;
commitid	crg28r1097elBMcd;

1.8
date	2014.07.29.16.17.28;	author reyk;	state Exp;
branches;
next	1.7;
commitid	lVEJBNunwU7ia3Go;

1.7
date	2014.07.25.17.04.47;	author reyk;	state Exp;
branches;
next	1.6;
commitid	tC3lUKjkKCnWZ8nY;

1.6
date	2014.07.25.16.23.19;	author reyk;	state Exp;
branches;
next	1.5;
commitid	xxvqODaQzmLv14My;

1.5
date	2014.07.25.15.47.11;	author reyk;	state Exp;
branches;
next	1.4;
commitid	xtB2Bs9CALPvM8y3;

1.4
date	2014.07.25.12.42.05;	author reyk;	state Exp;
branches;
next	1.3;
commitid	YXf583TKv41UVnB7;

1.3
date	2014.07.23.22.02.02;	author reyk;	state Exp;
branches;
next	1.2;
commitid	2WxTyiNOZ9AJbuTa;

1.2
date	2014.07.13.14.17.37;	author reyk;	state Exp;
branches;
next	1.1;
commitid	4gg9IcDTWDACYa56;

1.1
date	2014.07.12.23.34.54;	author reyk;	state Exp;
branches;
next	;
commitid	U5OqzWAgis3Sb3uE;

1.34.2.1
date	2014.11.20.07.48.45;	author jasper;	state Exp;
branches;
next	;
commitid	aoUNgrdXQt2mQs98;


desc
@@


1.92
log
@65535 is a valid port to listen on.
Off-by-one pointed out by and diff from Kris Katterjohn katterjohn AT
gmail, thanks!
chris@@ pointed out that more than httpd(8) is effected.
OK gilles@@
@
text
@/*	$OpenBSD: parse.y,v 1.91 2017/08/11 18:48:56 jsing Exp $	*/

/*
 * Copyright (c) 2007 - 2015 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2004 Ryan McBride <mcbride@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/ioctl.h>
#include <sys/sockio.h>
#include <sys/time.h>

#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <unistd.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdio.h>
#include <netdb.h>
#include <string.h>
#include <ifaddrs.h>
#include <syslog.h>

#include "httpd.h"
#include "http.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file, *topfile;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

struct httpd		*conf = NULL;
static int		 errors = 0;
static int		 loadcfg = 0;
uint32_t		 last_server_id = 0;
uint32_t		 last_auth_id = 0;

static struct server	*srv = NULL, *parentsrv = NULL;
static struct server_config *srv_conf = NULL;
struct serverlist	 servers;
struct media_type	 media;

struct address	*host_v4(const char *);
struct address	*host_v6(const char *);
int		 host_dns(const char *, struct addresslist *,
		    int, struct portrange *, const char *, int);
int		 host_if(const char *, struct addresslist *,
		    int, struct portrange *, const char *, int);
int		 host(const char *, struct addresslist *,
		    int, struct portrange *, const char *, int);
void		 host_free(struct addresslist *);
struct server	*server_inherit(struct server *, struct server_config *,
		    struct server_config *);
int		 getservice(char *);
int		 is_if_in_group(const char *, const char *);

typedef struct {
	union {
		int64_t			 number;
		char			*string;
		struct timeval		 tv;
		struct portrange	 port;
		struct auth		 auth;
		struct {
			struct sockaddr_storage	 ss;
			char			 name[HOST_NAME_MAX+1];
		}			 addr;
	} v;
	int lineno;
} YYSTYPE;

%}

%token	ACCESS ALIAS AUTO BACKLOG BODY BUFFER CERTIFICATE CHROOT CIPHERS COMMON
%token	COMBINED CONNECTION DHE DIRECTORY ECDHE ERR FCGI INDEX IP KEY LIFETIME
%token	LISTEN LOCATION LOG LOGDIR MATCH MAXIMUM NO NODELAY OCSP ON PORT PREFORK
%token	PROTOCOLS REQUESTS ROOT SACK SERVER SOCKET STRIP STYLE SYSLOG TCP TICKET
%token	TIMEOUT TLS TYPE TYPES HSTS MAXAGE SUBDOMAINS DEFAULT PRELOAD REQUEST
%token	ERROR INCLUDE AUTHENTICATE WITH BLOCK DROP RETURN PASS
%token	<v.string>	STRING
%token  <v.number>	NUMBER
%type	<v.port>	port
%type	<v.number>	opttls optmatch
%type	<v.tv>		timeout
%type	<v.string>	numberstring optstring
%type	<v.auth>	authopts

%%

grammar		: /* empty */
		| grammar include '\n'
		| grammar '\n'
		| grammar varset '\n'
		| grammar main '\n'
		| grammar server '\n'
		| grammar types '\n'
		| grammar error '\n'		{ file->errors++; }
		;

include		: INCLUDE STRING		{
			struct file	*nfile;

			if ((nfile = pushfile($2, 0)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}
		;

varset		: STRING '=' STRING	{
			char *s = $1;
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				fatal("cannot store variable");
			free($1);
			free($3);
		}
		;

opttls		: /*empty*/	{ $$ = 0; }
		| TLS		{ $$ = 1; }
		;

main		: PREFORK NUMBER	{
			if (loadcfg)
				break;
			if ($2 <= 0 || $2 > PROC_MAX_INSTANCES) {
				yyerror("invalid number of preforked "
				    "servers: %lld", $2);
				YYERROR;
			}
			conf->sc_prefork_server = $2;
		}
		| CHROOT STRING		{
			conf->sc_chroot = $2;
		}
		| LOGDIR STRING		{
			conf->sc_logdir = $2;
		}
		| DEFAULT TYPE mediastring	{
			memcpy(&conf->sc_default_type, &media,
			    sizeof(struct media_type));
		}
		;

server		: SERVER optmatch STRING	{
			struct server	*s;

			if (!loadcfg) {
				free($3);
				YYACCEPT;
			}

			if ((s = calloc(1, sizeof (*s))) == NULL)
				fatal("out of memory");

			if (strlcpy(s->srv_conf.name, $3,
			    sizeof(s->srv_conf.name)) >=
			    sizeof(s->srv_conf.name)) {
				yyerror("server name truncated");
				free($3);
				free(s);
				YYERROR;
			}
			free($3);

			strlcpy(s->srv_conf.root, HTTPD_DOCROOT,
			    sizeof(s->srv_conf.root));
			strlcpy(s->srv_conf.index, HTTPD_INDEX,
			    sizeof(s->srv_conf.index));
			strlcpy(s->srv_conf.accesslog, HTTPD_ACCESS_LOG,
			    sizeof(s->srv_conf.accesslog));
			strlcpy(s->srv_conf.errorlog, HTTPD_ERROR_LOG,
			    sizeof(s->srv_conf.errorlog));
			s->srv_conf.id = ++last_server_id;
			s->srv_conf.parent_id = s->srv_conf.id;
			s->srv_s = -1;
			s->srv_conf.timeout.tv_sec = SERVER_TIMEOUT;
			s->srv_conf.requesttimeout.tv_sec =
			    SERVER_REQUESTTIMEOUT;
			s->srv_conf.maxrequests = SERVER_MAXREQUESTS;
			s->srv_conf.maxrequestbody = SERVER_MAXREQUESTBODY;
			s->srv_conf.flags = SRVFLAG_LOG;
			if ($2)
				s->srv_conf.flags |= SRVFLAG_SERVER_MATCH;
			s->srv_conf.logformat = LOG_FORMAT_COMMON;
			s->srv_conf.tls_protocols = TLS_PROTOCOLS_DEFAULT;
			if ((s->srv_conf.tls_cert_file =
			    strdup(HTTPD_TLS_CERT)) == NULL)
				fatal("out of memory");
			if ((s->srv_conf.tls_key_file =
			    strdup(HTTPD_TLS_KEY)) == NULL)
				fatal("out of memory");
			strlcpy(s->srv_conf.tls_ciphers,
			    HTTPD_TLS_CIPHERS,
			    sizeof(s->srv_conf.tls_ciphers));
			strlcpy(s->srv_conf.tls_dhe_params,
			    HTTPD_TLS_DHE_PARAMS,
			    sizeof(s->srv_conf.tls_dhe_params));
			strlcpy(s->srv_conf.tls_ecdhe_curves,
			    HTTPD_TLS_ECDHE_CURVES,
			    sizeof(s->srv_conf.tls_ecdhe_curves));

			s->srv_conf.hsts_max_age = SERVER_HSTS_DEFAULT_AGE;

			if (last_server_id == INT_MAX) {
				yyerror("too many servers defined");
				free(s);
				YYERROR;
			}
			srv = s;
			srv_conf = &srv->srv_conf;

			SPLAY_INIT(&srv->srv_clients);
			TAILQ_INIT(&srv->srv_hosts);

			TAILQ_INSERT_TAIL(&srv->srv_hosts, srv_conf, entry);
		} '{' optnl serveropts_l '}'	{
			struct server		*s, *sn;
			struct server_config	*a, *b;

			srv_conf = &srv->srv_conf;

			/* Check if the new server already exists. */
			if (server_match(srv, 1) != NULL) {
				yyerror("server \"%s\" defined twice",
				    srv->srv_conf.name);
				serverconfig_free(srv_conf);
				free(srv);
				YYABORT;
			}

			if (srv->srv_conf.ss.ss_family == AF_UNSPEC) {
				yyerror("listen address not specified");
				serverconfig_free(srv_conf);
				free(srv);
				YYERROR;
			}

			if ((s = server_match(srv, 0)) != NULL) {
				if ((s->srv_conf.flags & SRVFLAG_TLS) != 
				    (srv->srv_conf.flags & SRVFLAG_TLS)) {
					yyerror("server \"%s\": tls and "
					    "non-tls on same address/port",
					    srv->srv_conf.name);
					serverconfig_free(srv_conf);
					free(srv);
					YYERROR;
				}
				if (server_tls_cmp(s, srv, 0) != 0) {
					yyerror("server \"%s\": tls "
					    "configuration mismatch on same "
					    "address/port",
					    srv->srv_conf.name);
					serverconfig_free(srv_conf);
					free(srv);
					YYERROR;
				}
			}

			if ((srv->srv_conf.flags & SRVFLAG_TLS) &&
			    srv->srv_conf.tls_protocols == 0) {
				yyerror("server \"%s\": no tls protocols",
				    srv->srv_conf.name);
				serverconfig_free(srv_conf);
				free(srv);
				YYERROR;
			}

			if (server_tls_load_keypair(srv) == -1) {
				yyerror("server \"%s\": failed to load "
				    "public/private keys", srv->srv_conf.name);
				serverconfig_free(srv_conf);
				free(srv);
				YYERROR;
			}

			if (server_tls_load_ocsp(srv) == -1) {
				yyerror("server \"%s\": failed to load "
				    "ocsp staple", srv->srv_conf.name);
				serverconfig_free(srv_conf);
				free(srv);
				YYERROR;
			}

			DPRINTF("adding server \"%s[%u]\"",
			    srv->srv_conf.name, srv->srv_conf.id);

			TAILQ_INSERT_TAIL(conf->sc_servers, srv, srv_entry);

			/*
			 * Add aliases and additional listen addresses as
			 * individual servers.
			 */
			TAILQ_FOREACH(a, &srv->srv_hosts, entry) {
				/* listen address */
				if (a->ss.ss_family == AF_UNSPEC)
					continue;
				TAILQ_FOREACH(b, &srv->srv_hosts, entry) {
					/* alias name */
					if (*b->name == '\0' ||
					    (b == &srv->srv_conf && b == a))
						continue;

					if ((sn = server_inherit(srv,
					    b, a)) == NULL) {
						serverconfig_free(srv_conf);
						free(srv);
						YYABORT;
					}

					DPRINTF("adding server \"%s[%u]\"",
					    sn->srv_conf.name, sn->srv_conf.id);

					TAILQ_INSERT_TAIL(conf->sc_servers,
					    sn, srv_entry);
				}
			}

			/* Remove temporary aliases */
			TAILQ_FOREACH_SAFE(a, &srv->srv_hosts, entry, b) {
				TAILQ_REMOVE(&srv->srv_hosts, a, entry);
				if (a == &srv->srv_conf)
					continue;
				serverconfig_free(a);
				free(a);
			}

			srv = NULL;
			srv_conf = NULL;
		}
		;

serveropts_l	: serveropts_l serveroptsl nl
		| serveroptsl optnl
		;

serveroptsl	: LISTEN ON STRING opttls port {
			struct addresslist	 al;
			struct address		*h;
			struct server_config	*s_conf, *alias = NULL;

			if (parentsrv != NULL) {
				yyerror("listen %s inside location", $3);
				free($3);
				YYERROR;
			}

			if (srv->srv_conf.ss.ss_family != AF_UNSPEC) {
				if ((alias = calloc(1,
				    sizeof(*alias))) == NULL)
					fatal("out of memory");

				/* Add as an IP-based alias. */
				s_conf = alias;
			} else
				s_conf = &srv->srv_conf;

			TAILQ_INIT(&al);
			if (host($3, &al, 1, &$5, NULL, -1) <= 0) {
				yyerror("invalid listen ip: %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
			h = TAILQ_FIRST(&al);
			memcpy(&s_conf->ss, &h->ss, sizeof(s_conf->ss));
			s_conf->port = h->port.val[0];
			s_conf->prefixlen = h->prefixlen;
			host_free(&al);

			if ($4)
				s_conf->flags |= SRVFLAG_TLS;

			if (alias != NULL) {
				/* IP-based; use name match flags from parent */
				alias->flags &= ~SRVFLAG_SERVER_MATCH;
				alias->flags |= srv->srv_conf.flags &
				    SRVFLAG_SERVER_MATCH;
				TAILQ_INSERT_TAIL(&srv->srv_hosts,
				    alias, entry);
			}
		}
		| ALIAS optmatch STRING		{
			struct server_config	*alias;

			if (parentsrv != NULL) {
				yyerror("alias inside location");
				free($3);
				YYERROR;
			}

			if ((alias = calloc(1, sizeof(*alias))) == NULL)
				fatal("out of memory");

			if (strlcpy(alias->name, $3, sizeof(alias->name)) >=
			    sizeof(alias->name)) {
				yyerror("server alias truncated");
				free($3);
				free(alias);
				YYERROR;
			}
			free($3);

			if ($2)
				alias->flags |= SRVFLAG_SERVER_MATCH;

			TAILQ_INSERT_TAIL(&srv->srv_hosts, alias, entry);
		}
		| tcpip			{
			if (parentsrv != NULL) {
				yyerror("tcp flags inside location");
				YYERROR;
			}
		}
		| connection		{
			if (parentsrv != NULL) {
				yyerror("connection options inside location");
				YYERROR;
			}
		}
		| tls			{
			struct server_config	*sc;
			int			 tls_flag = 0;

			if (parentsrv != NULL) {
				yyerror("tls configuration inside location");
				YYERROR;
			}

			/* Ensure that at least one server has TLS enabled. */
			TAILQ_FOREACH(sc, &srv->srv_hosts, entry) {
				tls_flag |= (sc->flags & SRVFLAG_TLS);
			}
			if (tls_flag == 0) {
				yyerror("tls options without tls listener");
				YYERROR;
			}
		}
		| root
		| directory
		| logformat
		| fastcgi
		| authenticate
		| filter
		| LOCATION optmatch STRING	{
			struct server	*s;

			if (srv->srv_conf.ss.ss_family == AF_UNSPEC) {
				yyerror("listen address not specified");
				free($3);
				YYERROR;
			}

			if (parentsrv != NULL) {
				yyerror("location %s inside location", $3);
				free($3);
				YYERROR;
			}

			if (!loadcfg) {
				free($3);
				YYACCEPT;
			}

			if ((s = calloc(1, sizeof (*s))) == NULL)
				fatal("out of memory");

			if (strlcpy(s->srv_conf.location, $3,
			    sizeof(s->srv_conf.location)) >=
			    sizeof(s->srv_conf.location)) {
				yyerror("server location truncated");
				free($3);
				free(s);
				YYERROR;
			}
			free($3);

			if (strlcpy(s->srv_conf.name, srv->srv_conf.name,
			    sizeof(s->srv_conf.name)) >=
			    sizeof(s->srv_conf.name)) {
				yyerror("server name truncated");
				free(s);
				YYERROR;
			}

			s->srv_conf.id = ++last_server_id;
			/* A location entry uses the parent id */
			s->srv_conf.parent_id = srv->srv_conf.id;
			s->srv_conf.flags = SRVFLAG_LOCATION;
			if ($2)
				s->srv_conf.flags |= SRVFLAG_LOCATION_MATCH;
			s->srv_s = -1;
			memcpy(&s->srv_conf.ss, &srv->srv_conf.ss,
			    sizeof(s->srv_conf.ss));
			s->srv_conf.port = srv->srv_conf.port;
			s->srv_conf.prefixlen = srv->srv_conf.prefixlen;

			if (last_server_id == INT_MAX) {
				yyerror("too many servers/locations defined");
				free(s);
				YYERROR;
			}
			parentsrv = srv;
			srv = s;
			srv_conf = &srv->srv_conf;
			SPLAY_INIT(&srv->srv_clients);
		} '{' optnl serveropts_l '}'	{
			struct server	*s = NULL;

			TAILQ_FOREACH(s, conf->sc_servers, srv_entry) {
				if ((s->srv_conf.flags & SRVFLAG_LOCATION) &&
				    s->srv_conf.id == srv_conf->id &&
				    strcmp(s->srv_conf.location,
				    srv_conf->location) == 0)
					break;
			}
			if (s != NULL) {
				yyerror("location \"%s\" defined twice",
				    srv->srv_conf.location);
				serverconfig_free(srv_conf);
				free(srv);
				YYABORT;
			}

			DPRINTF("adding location \"%s\" for \"%s[%u]\"",
			    srv->srv_conf.location,
			    srv->srv_conf.name, srv->srv_conf.id);

			TAILQ_INSERT_TAIL(conf->sc_servers, srv, srv_entry);

			srv = parentsrv;
			srv_conf = &parentsrv->srv_conf;
			parentsrv = NULL;
		}
		| DEFAULT TYPE mediastring	{
			srv_conf->flags |= SRVFLAG_DEFAULT_TYPE;
			memcpy(&srv_conf->default_type, &media,
			    sizeof(struct media_type));
		}
		| include
		| hsts				{
			if (parentsrv != NULL) {
				yyerror("hsts inside location");
				YYERROR;
			}
			srv->srv_conf.flags |= SRVFLAG_SERVER_HSTS;
		}
		;

hsts		: HSTS '{' optnl hstsflags_l '}'
		| HSTS hstsflags
		| HSTS
		;

hstsflags_l	: hstsflags optcommanl hstsflags_l
		| hstsflags optnl
		;

hstsflags	: MAXAGE NUMBER		{
			if ($2 < 0 || $2 > INT_MAX) {
				yyerror("invalid number of seconds: %lld", $2);
				YYERROR;
			}
			srv_conf->hsts_max_age = $2;
		}
		| SUBDOMAINS		{
			srv->srv_conf.hsts_flags |= HSTSFLAG_SUBDOMAINS;
		}
		| PRELOAD		{
			srv->srv_conf.hsts_flags |= HSTSFLAG_PRELOAD;
		}
		;

fastcgi		: NO FCGI		{
			srv_conf->flags &= ~SRVFLAG_FCGI;
			srv_conf->flags |= SRVFLAG_NO_FCGI;
		}
		| FCGI			{
			srv_conf->flags &= ~SRVFLAG_NO_FCGI;
			srv_conf->flags |= SRVFLAG_FCGI;
		}
		| FCGI			{
			srv_conf->flags &= ~SRVFLAG_NO_FCGI;
			srv_conf->flags |= SRVFLAG_FCGI;
		} '{' optnl fcgiflags_l '}'
		| FCGI			{
			srv_conf->flags &= ~SRVFLAG_NO_FCGI;
			srv_conf->flags |= SRVFLAG_FCGI;
		} fcgiflags
		;

fcgiflags_l	: fcgiflags optcommanl fcgiflags_l
		| fcgiflags optnl
		;

fcgiflags	: SOCKET STRING		{
			if (strlcpy(srv_conf->socket, $2,
			    sizeof(srv_conf->socket)) >=
			    sizeof(srv_conf->socket)) {
				yyerror("fastcgi socket too long");
				free($2);
				YYERROR;
			}
			free($2);
			srv_conf->flags |= SRVFLAG_SOCKET;
		}
		;

connection	: CONNECTION '{' optnl conflags_l '}'
		| CONNECTION conflags
		;

conflags_l	: conflags optcommanl conflags_l
		| conflags optnl
		;

conflags	: TIMEOUT timeout		{
			memcpy(&srv_conf->timeout, &$2,
			    sizeof(struct timeval));
		}
		| REQUEST TIMEOUT timeout	{
			memcpy(&srv_conf->requesttimeout, &$3,
			    sizeof(struct timeval));
		}
		| MAXIMUM REQUESTS NUMBER	{
			srv_conf->maxrequests = $3;
		}
		| MAXIMUM REQUEST BODY NUMBER	{
			srv_conf->maxrequestbody = $4;
		}
		;

tls		: TLS '{' optnl tlsopts_l '}'
		| TLS tlsopts
		;

tlsopts_l	: tlsopts optcommanl tlsopts_l
		| tlsopts optnl
		;

tlsopts		: CERTIFICATE STRING		{
			free(srv_conf->tls_cert_file);
			if ((srv_conf->tls_cert_file = strdup($2)) == NULL)
				fatal("out of memory");
			free($2);
		}
		| KEY STRING			{
			free(srv_conf->tls_key_file);
			if ((srv_conf->tls_key_file = strdup($2)) == NULL)
				fatal("out of memory");
			free($2);
		}
		| OCSP STRING			{
			free(srv_conf->tls_ocsp_staple_file);
			if ((srv_conf->tls_ocsp_staple_file = strdup($2))
			    == NULL)
				fatal("out of memory");
			free($2);
		}
		| CIPHERS STRING		{
			if (strlcpy(srv_conf->tls_ciphers, $2,
			    sizeof(srv_conf->tls_ciphers)) >=
			    sizeof(srv_conf->tls_ciphers)) {
				yyerror("ciphers too long");
				free($2);
				YYERROR;
			}
			free($2);
		}
		| DHE STRING			{
			if (strlcpy(srv_conf->tls_dhe_params, $2,
			    sizeof(srv_conf->tls_dhe_params)) >=
			    sizeof(srv_conf->tls_dhe_params)) {
				yyerror("dhe too long");
				free($2);
				YYERROR;
			}
			free($2);
		}
		| ECDHE STRING			{
			if (strlcpy(srv_conf->tls_ecdhe_curves, $2,
			    sizeof(srv_conf->tls_ecdhe_curves)) >=
			    sizeof(srv_conf->tls_ecdhe_curves)) {
				yyerror("ecdhe too long");
				free($2);
				YYERROR;
			}
			free($2);
		}
		| PROTOCOLS STRING		{
			if (tls_config_parse_protocols(
			    &srv_conf->tls_protocols, $2) != 0) {
				yyerror("invalid tls protocols");
				free($2);
				YYERROR;
			}
			free($2);
		}
		| TICKET LIFETIME DEFAULT	{
			srv_conf->tls_ticket_lifetime = SERVER_DEF_TLS_LIFETIME;
		}
		| TICKET LIFETIME NUMBER	{
			if ($3 != 0 && $3 < SERVER_MIN_TLS_LIFETIME) {
				yyerror("ticket lifetime too small");
				YYERROR;
			}
			if ($3 > SERVER_MAX_TLS_LIFETIME) {
				yyerror("ticket lifetime too large");
				YYERROR;
			}
			srv_conf->tls_ticket_lifetime = $3;
		}
		| NO TICKET			{
			srv_conf->tls_ticket_lifetime = 0;
		}
		;

root		: ROOT rootflags
		| ROOT '{' optnl rootflags_l '}'
		;

rootflags_l	: rootflags optcommanl rootflags_l
		| rootflags optnl
		;

rootflags	: STRING		{
			if (strlcpy(srv->srv_conf.root, $1,
			    sizeof(srv->srv_conf.root)) >=
			    sizeof(srv->srv_conf.root)) {
				yyerror("document root too long");
				free($1);
				YYERROR;
			}
			free($1);
			srv->srv_conf.flags |= SRVFLAG_ROOT;
		}
		| STRIP NUMBER		{
			if ($2 < 0 || $2 > INT_MAX) {
				yyerror("invalid strip number");
				YYERROR;
			}
			srv->srv_conf.strip = $2;
		}
		;

authenticate	: NO AUTHENTICATE		{
			srv->srv_conf.flags |= SRVFLAG_NO_AUTH;
		}
		| AUTHENTICATE authopts		{
			struct auth	*auth;

			if ((auth = auth_add(conf->sc_auth, &$2)) == NULL) {
				yyerror("failed to add auth");
				YYERROR;
			}

			if (auth->auth_id == 0) {
				/* New htpasswd, get new Id */
				auth->auth_id = ++last_auth_id;
				if (last_auth_id == INT_MAX) {
					yyerror("too many auth ids defined");
					auth_free(conf->sc_auth, auth);
					YYERROR;
				}
			}

			srv->srv_conf.auth_id = auth->auth_id;
			srv->srv_conf.flags |= SRVFLAG_AUTH;
		}
		;

authopts	: STRING WITH STRING	{
			if (strlcpy(srv->srv_conf.auth_realm, $1,
			    sizeof(srv->srv_conf.auth_realm)) >=
			    sizeof(srv->srv_conf.auth_realm)) {
				yyerror("basic auth realm name too long");
				free($1);
				YYERROR;
			}
			free($1);
			if (strlcpy($$.auth_htpasswd, $3,
			    sizeof($$.auth_htpasswd)) >=
			    sizeof($$.auth_htpasswd)) {
				yyerror("password file name too long");
				free($3);
				YYERROR;
			}
			free($3);

		}
		| WITH STRING		{
			if (strlcpy($$.auth_htpasswd, $2,
			    sizeof($$.auth_htpasswd)) >=
			    sizeof($$.auth_htpasswd)) {
				yyerror("password file name too long");
				free($2);
				YYERROR;
			}
			free($2);
		};

directory	: DIRECTORY dirflags
		| DIRECTORY '{' optnl dirflags_l '}'
		;

dirflags_l	: dirflags optcommanl dirflags_l
		| dirflags optnl
		;

dirflags	: INDEX STRING		{
			if (strlcpy(srv_conf->index, $2,
			    sizeof(srv_conf->index)) >=
			    sizeof(srv_conf->index)) {
				yyerror("index file too long");
				free($2);
				YYERROR;
			}
			srv_conf->flags &= ~SRVFLAG_NO_INDEX;
			srv_conf->flags |= SRVFLAG_INDEX;
			free($2);
		}
		| NO INDEX		{
			srv_conf->flags &= ~SRVFLAG_INDEX;
			srv_conf->flags |= SRVFLAG_NO_INDEX;
		}
		| AUTO INDEX		{
			srv_conf->flags &= ~SRVFLAG_NO_AUTO_INDEX;
			srv_conf->flags |= SRVFLAG_AUTO_INDEX;
		}
		| NO AUTO INDEX		{
			srv_conf->flags &= ~SRVFLAG_AUTO_INDEX;
			srv_conf->flags |= SRVFLAG_NO_AUTO_INDEX;
		}
		;


logformat	: LOG logflags
		| LOG '{' optnl logflags_l '}'
		| NO LOG		{
			srv_conf->flags &= ~SRVFLAG_LOG;
			srv_conf->flags |= SRVFLAG_NO_LOG;
		}
		;

logflags_l	: logflags optcommanl logflags_l
		| logflags optnl
		;

logflags	: STYLE logstyle
		| SYSLOG		{
			srv_conf->flags &= ~SRVFLAG_NO_SYSLOG;
			srv_conf->flags |= SRVFLAG_SYSLOG;
		}
		| NO SYSLOG		{
			srv_conf->flags &= ~SRVFLAG_SYSLOG;
			srv_conf->flags |= SRVFLAG_NO_SYSLOG;
		}
		| ACCESS STRING		{
			if (strlcpy(srv_conf->accesslog, $2,
			    sizeof(srv_conf->accesslog)) >=
			    sizeof(srv_conf->accesslog)) {
				yyerror("access log name too long");
				free($2);
				YYERROR;
			}
			free($2);
			srv_conf->flags |= SRVFLAG_ACCESS_LOG;
		}
		| ERR STRING		{
			if (strlcpy(srv_conf->errorlog, $2,
			    sizeof(srv_conf->errorlog)) >=
			    sizeof(srv_conf->errorlog)) {
				yyerror("error log name too long");
				free($2);
				YYERROR;
			}
			free($2);
			srv_conf->flags |= SRVFLAG_ERROR_LOG;
		}
		;

logstyle	: COMMON		{
			srv_conf->flags &= ~SRVFLAG_NO_LOG;
			srv_conf->flags |= SRVFLAG_LOG;
			srv_conf->logformat = LOG_FORMAT_COMMON;
		}
		| COMBINED		{
			srv_conf->flags &= ~SRVFLAG_NO_LOG;
			srv_conf->flags |= SRVFLAG_LOG;
			srv_conf->logformat = LOG_FORMAT_COMBINED;
		}
		| CONNECTION		{
			srv_conf->flags &= ~SRVFLAG_NO_LOG;
			srv_conf->flags |= SRVFLAG_LOG;
			srv_conf->logformat = LOG_FORMAT_CONNECTION;
		}
		;

filter		: block RETURN NUMBER optstring	{
			if ($3 <= 0 || server_httperror_byid($3) == NULL) {
				yyerror("invalid return code: %lld", $3);
				free($4);
				YYERROR;
			}
			srv_conf->return_code = $3;

			if ($4 != NULL) {
				/* Only for 3xx redirection headers */
				if ($3 < 300 || $3 > 399) {
					yyerror("invalid return code for "
					    "location URI");
					free($4);
					YYERROR;
				}
				srv_conf->return_uri = $4;
				srv_conf->return_uri_len = strlen($4) + 1;
			}
		}
		| block DROP			{
			/* No return code, silently drop the connection */
			srv_conf->return_code = 0;
		}
		| block				{
			/* Forbidden */
			srv_conf->return_code = 403;
		}
		| PASS				{
			srv_conf->flags &= ~SRVFLAG_BLOCK;
			srv_conf->flags |= SRVFLAG_NO_BLOCK;
		}
		;

block		: BLOCK				{
			srv_conf->flags &= ~SRVFLAG_NO_BLOCK;
			srv_conf->flags |= SRVFLAG_BLOCK;
		}
		;

optmatch	: /* empty */		{ $$ = 0; }
		| MATCH			{ $$ = 1; }
		;

optstring	: /* empty */		{ $$ = NULL; }
		| STRING		{ $$ = $1; }
		;

tcpip		: TCP '{' optnl tcpflags_l '}'
		| TCP tcpflags
		;

tcpflags_l	: tcpflags optcommanl tcpflags_l
		| tcpflags optnl
		;

tcpflags	: SACK			{ srv_conf->tcpflags |= TCPFLAG_SACK; }
		| NO SACK		{ srv_conf->tcpflags |= TCPFLAG_NSACK; }
		| NODELAY		{
			srv_conf->tcpflags |= TCPFLAG_NODELAY;
		}
		| NO NODELAY		{
			srv_conf->tcpflags |= TCPFLAG_NNODELAY;
		}
		| BACKLOG NUMBER	{
			if ($2 < 0 || $2 > SERVER_MAX_CLIENTS) {
				yyerror("invalid backlog: %lld", $2);
				YYERROR;
			}
			srv_conf->tcpbacklog = $2;
		}
		| SOCKET BUFFER NUMBER	{
			srv_conf->tcpflags |= TCPFLAG_BUFSIZ;
			if ((srv_conf->tcpbufsiz = $3) < 0) {
				yyerror("invalid socket buffer size: %lld", $3);
				YYERROR;
			}
		}
		| IP STRING NUMBER	{
			if ($3 < 0) {
				yyerror("invalid ttl: %lld", $3);
				free($2);
				YYERROR;
			}
			if (strcasecmp("ttl", $2) == 0) {
				srv_conf->tcpflags |= TCPFLAG_IPTTL;
				srv_conf->tcpipttl = $3;
			} else if (strcasecmp("minttl", $2) == 0) {
				srv_conf->tcpflags |= TCPFLAG_IPMINTTL;
				srv_conf->tcpipminttl = $3;
			} else {
				yyerror("invalid TCP/IP flag: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		;

types		: TYPES	'{' optnl mediaopts_l '}'
		;

mediaopts_l	: mediaopts_l mediaoptsl nl
		| mediaoptsl nl
		;

mediaoptsl	: mediastring medianames_l optsemicolon
		| include
		;

mediastring	: STRING '/' STRING	{
			if (strlcpy(media.media_type, $1,
			    sizeof(media.media_type)) >=
			    sizeof(media.media_type) ||
			    strlcpy(media.media_subtype, $3,
			    sizeof(media.media_subtype)) >=
			    sizeof(media.media_subtype)) {
				yyerror("media type too long");
				free($1);
				free($3);
				YYERROR;
			}
			free($1);
			free($3);
		}
		;

medianames_l	: medianames_l medianamesl
		| medianamesl
		;

medianamesl	: numberstring				{
			if (strlcpy(media.media_name, $1,
			    sizeof(media.media_name)) >=
			    sizeof(media.media_name)) {
				yyerror("media name too long");
				free($1);
				YYERROR;
			}
			free($1);

			if (!loadcfg)
				break;

			if (media_add(conf->sc_mediatypes, &media) == NULL) {
				yyerror("failed to add media type");
				YYERROR;
			}
		}
		;

port		: PORT NUMBER {
			if ($2 <= 0 || $2 > (int)USHRT_MAX) {
				yyerror("invalid port: %lld", $2);
				YYERROR;
			}
			$$.val[0] = htons($2);
		}
		| PORT STRING {
			int	 val;

			if ((val = getservice($2)) == -1) {
				yyerror("invalid port: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			$$.val[0] = val;
		}
		;

timeout		: NUMBER
		{
			if ($1 < 0) {
				yyerror("invalid timeout: %lld", $1);
				YYERROR;
			}
			$$.tv_sec = $1;
			$$.tv_usec = 0;
		}
		;

numberstring	: NUMBER		{
			char *s;
			if (asprintf(&s, "%lld", $1) == -1) {
				yyerror("asprintf: number");
				YYERROR;
			}
			$$ = s;
		}
		| STRING
		;

optsemicolon	: ';'
		|
		;

optnl		: '\n' optnl
		|
		;

optcommanl	: ',' optnl
		| nl
		;

nl		: '\n' optnl
		;

%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;
	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		fatalx("yyerror vasprintf");
	va_end(ap);
	logit(LOG_CRIT, "%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "access",		ACCESS },
		{ "alias",		ALIAS },
		{ "authenticate",	AUTHENTICATE},
		{ "auto",		AUTO },
		{ "backlog",		BACKLOG },
		{ "block",		BLOCK },
		{ "body",		BODY },
		{ "buffer",		BUFFER },
		{ "certificate",	CERTIFICATE },
		{ "chroot",		CHROOT },
		{ "ciphers",		CIPHERS },
		{ "combined",		COMBINED },
		{ "common",		COMMON },
		{ "connection",		CONNECTION },
		{ "default",		DEFAULT },
		{ "dhe",		DHE },
		{ "directory",		DIRECTORY },
		{ "drop",		DROP },
		{ "ecdhe",		ECDHE },
		{ "error",		ERR },
		{ "fastcgi",		FCGI },
		{ "hsts",		HSTS },
		{ "include",		INCLUDE },
		{ "index",		INDEX },
		{ "ip",			IP },
		{ "key",		KEY },
		{ "lifetime",		LIFETIME },
		{ "listen",		LISTEN },
		{ "location",		LOCATION },
		{ "log",		LOG },
		{ "logdir",		LOGDIR },
		{ "match",		MATCH },
		{ "max",		MAXIMUM },
		{ "max-age",		MAXAGE },
		{ "no",			NO },
		{ "nodelay",		NODELAY },
		{ "ocsp",		OCSP },
		{ "on",			ON },
		{ "pass",		PASS },
		{ "port",		PORT },
		{ "prefork",		PREFORK },
		{ "preload",		PRELOAD },
		{ "protocols",		PROTOCOLS },
		{ "request",		REQUEST },
		{ "requests",		REQUESTS },
		{ "return",		RETURN },
		{ "root",		ROOT },
		{ "sack",		SACK },
		{ "server",		SERVER },
		{ "socket",		SOCKET },
		{ "strip",		STRIP },
		{ "style",		STYLE },
		{ "subdomains",		SUBDOMAINS },
		{ "syslog",		SYSLOG },
		{ "tcp",		TCP },
		{ "ticket",		TICKET },
		{ "timeout",		TIMEOUT },
		{ "tls",		TLS },
		{ "type",		TYPE },
		{ "types",		TYPES },
		{ "with",		WITH }
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

unsigned char	*parsebuf;
int		 parseindex;
unsigned char	 pushback_buffer[MAXPUSHBACK];
int		 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	unsigned char	 buf[8096];
	unsigned char	*p, *val;
	int		 quotec, next, c;
	int		 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && x != '<' && x != '>' && \
	x != '!' && x != '=' && x != '#' && \
	x != ',' && x != ';' && x != '/'))

	if (isalnum(c) || c == ':' || c == '_' || c == '*') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		log_warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		log_warnx("%s: group writable or world read/writable", fname);
		return (-1);
	}
	return (0);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		log_warn("%s: malloc", __func__);
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		log_warn("%s: malloc", __func__);
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		log_warn("%s: %s", __func__, nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

int
parse_config(const char *filename, struct httpd *x_conf)
{
	struct sym		*sym, *next;
	struct media_type	 dflt = HTTPD_DEFAULT_TYPE;

	conf = x_conf;
	if (config_init(conf) == -1) {
		log_warn("%s: cannot initialize configuration", __func__);
		return (-1);
	}

	/* Set default media type */
	memcpy(&conf->sc_default_type, &dflt, sizeof(struct media_type));

	errors = 0;

	if ((file = pushfile(filename, 0)) == NULL)
		return (-1);

	topfile = file;
	setservent(1);

	yyparse();
	errors = file->errors;
	popfile();

	endservent();
	endprotoent();

	/* Free macros */
	TAILQ_FOREACH_SAFE(sym, &symhead, entry, next) {
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	return (errors ? -1 : 0);
}

int
load_config(const char *filename, struct httpd *x_conf)
{
	struct sym		*sym, *next;
	struct http_mediatype	 mediatypes[] = MEDIA_TYPES;
	struct media_type	 m;
	int			 i;

	conf = x_conf;
	conf->sc_flags = 0;

	loadcfg = 1;
	errors = 0;
	last_server_id = 0;
	last_auth_id = 0;

	srv = NULL;

	if ((file = pushfile(filename, 0)) == NULL)
		return (-1);

	topfile = file;
	setservent(1);

	yyparse();
	errors = file->errors;
	popfile();

	endservent();
	endprotoent();

	/* Free macros and check which have not been used. */
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
		if ((conf->sc_opts & HTTPD_OPT_VERBOSE) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	if (TAILQ_EMPTY(conf->sc_servers)) {
		log_warnx("no actions, nothing to do");
		errors++;
	}

	if (RB_EMPTY(conf->sc_mediatypes)) {
		/* Add default media types */
		for (i = 0; mediatypes[i].media_name != NULL; i++) {
			(void)strlcpy(m.media_name, mediatypes[i].media_name,
			    sizeof(m.media_name));
			(void)strlcpy(m.media_type, mediatypes[i].media_type,
			    sizeof(m.media_type));
			(void)strlcpy(m.media_subtype,
			    mediatypes[i].media_subtype,
			    sizeof(m.media_subtype));
			m.media_encoding = NULL;

			if (media_add(conf->sc_mediatypes, &m) == NULL) {
				log_warnx("failed to add default media \"%s\"",
				    m.media_name);
				errors++;
			}
		}
	}

	return (errors ? -1 : 0);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		errx(1, "cmdline_symset: malloc");

	(void)strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

struct address *
host_v4(const char *s)
{
	struct in_addr		 ina;
	struct sockaddr_in	*sain;
	struct address		*h;

	memset(&ina, 0, sizeof(ina));
	if (inet_pton(AF_INET, s, &ina) != 1)
		return (NULL);

	if ((h = calloc(1, sizeof(*h))) == NULL)
		fatal(__func__);
	sain = (struct sockaddr_in *)&h->ss;
	sain->sin_len = sizeof(struct sockaddr_in);
	sain->sin_family = AF_INET;
	sain->sin_addr.s_addr = ina.s_addr;
	if (sain->sin_addr.s_addr == INADDR_ANY)
		h->prefixlen = 0; /* 0.0.0.0 address */
	else
		h->prefixlen = -1; /* host address */
	return (h);
}

struct address *
host_v6(const char *s)
{
	struct addrinfo		 hints, *res;
	struct sockaddr_in6	*sa_in6;
	struct address		*h = NULL;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_DGRAM; /* dummy */
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(s, "0", &hints, &res) == 0) {
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal(__func__);
		sa_in6 = (struct sockaddr_in6 *)&h->ss;
		sa_in6->sin6_len = sizeof(struct sockaddr_in6);
		sa_in6->sin6_family = AF_INET6;
		memcpy(&sa_in6->sin6_addr,
		    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr,
		    sizeof(sa_in6->sin6_addr));
		sa_in6->sin6_scope_id =
		    ((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id;
		if (memcmp(&sa_in6->sin6_addr, &in6addr_any,
		    sizeof(sa_in6->sin6_addr)) == 0)
			h->prefixlen = 0; /* any address */
		else
			h->prefixlen = -1; /* host address */
		freeaddrinfo(res);
	}

	return (h);
}

int
host_dns(const char *s, struct addresslist *al, int max,
    struct portrange *port, const char *ifname, int ipproto)
{
	struct addrinfo		 hints, *res0, *res;
	int			 error, cnt = 0;
	struct sockaddr_in	*sain;
	struct sockaddr_in6	*sin6;
	struct address		*h;

	if ((cnt = host_if(s, al, max, port, ifname, ipproto)) != 0)
		return (cnt);

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM; /* DUMMY */
	hints.ai_flags = AI_ADDRCONFIG;
	error = getaddrinfo(s, NULL, &hints, &res0);
	if (error == EAI_AGAIN || error == EAI_NODATA || error == EAI_NONAME)
		return (0);
	if (error) {
		log_warnx("%s: could not parse \"%s\": %s", __func__, s,
		    gai_strerror(error));
		return (-1);
	}

	for (res = res0; res && cnt < max; res = res->ai_next) {
		if (res->ai_family != AF_INET &&
		    res->ai_family != AF_INET6)
			continue;
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal(__func__);

		if (port != NULL)
			memcpy(&h->port, port, sizeof(h->port));
		if (ifname != NULL) {
			if (strlcpy(h->ifname, ifname, sizeof(h->ifname)) >=
			    sizeof(h->ifname))
				log_warnx("%s: interface name truncated",
				    __func__);
			freeaddrinfo(res0);
			free(h);
			return (-1);
		}
		if (ipproto != -1)
			h->ipproto = ipproto;
		h->ss.ss_family = res->ai_family;
		h->prefixlen = -1; /* host address */

		if (res->ai_family == AF_INET) {
			sain = (struct sockaddr_in *)&h->ss;
			sain->sin_len = sizeof(struct sockaddr_in);
			sain->sin_addr.s_addr = ((struct sockaddr_in *)
			    res->ai_addr)->sin_addr.s_addr;
		} else {
			sin6 = (struct sockaddr_in6 *)&h->ss;
			sin6->sin6_len = sizeof(struct sockaddr_in6);
			memcpy(&sin6->sin6_addr, &((struct sockaddr_in6 *)
			    res->ai_addr)->sin6_addr, sizeof(struct in6_addr));
		}

		TAILQ_INSERT_HEAD(al, h, entry);
		cnt++;
	}
	if (cnt == max && res) {
		log_warnx("%s: %s resolves to more than %d hosts", __func__,
		    s, max);
	}
	freeaddrinfo(res0);
	return (cnt);
}

int
host_if(const char *s, struct addresslist *al, int max,
    struct portrange *port, const char *ifname, int ipproto)
{
	struct ifaddrs		*ifap, *p;
	struct sockaddr_in	*sain;
	struct sockaddr_in6	*sin6;
	struct address		*h;
	int			 cnt = 0, af;

	if (getifaddrs(&ifap) == -1)
		fatal("getifaddrs");

	/* First search for IPv4 addresses */
	af = AF_INET;

 nextaf:
	for (p = ifap; p != NULL && cnt < max; p = p->ifa_next) {
		if (p->ifa_addr->sa_family != af ||
		    (strcmp(s, p->ifa_name) != 0 &&
		    !is_if_in_group(p->ifa_name, s)))
			continue;
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal("calloc");

		if (port != NULL)
			memcpy(&h->port, port, sizeof(h->port));
		if (ifname != NULL) {
			if (strlcpy(h->ifname, ifname, sizeof(h->ifname)) >=
			    sizeof(h->ifname))
				log_warnx("%s: interface name truncated",
				    __func__);
			freeifaddrs(ifap);
			return (-1);
		}
		if (ipproto != -1)
			h->ipproto = ipproto;
		h->ss.ss_family = af;
		h->prefixlen = -1; /* host address */

		if (af == AF_INET) {
			sain = (struct sockaddr_in *)&h->ss;
			sain->sin_len = sizeof(struct sockaddr_in);
			sain->sin_addr.s_addr = ((struct sockaddr_in *)
			    p->ifa_addr)->sin_addr.s_addr;
		} else {
			sin6 = (struct sockaddr_in6 *)&h->ss;
			sin6->sin6_len = sizeof(struct sockaddr_in6);
			memcpy(&sin6->sin6_addr, &((struct sockaddr_in6 *)
			    p->ifa_addr)->sin6_addr, sizeof(struct in6_addr));
			sin6->sin6_scope_id = ((struct sockaddr_in6 *)
			    p->ifa_addr)->sin6_scope_id;
		}

		TAILQ_INSERT_HEAD(al, h, entry);
		cnt++;
	}
	if (af == AF_INET) {
		/* Next search for IPv6 addresses */
		af = AF_INET6;
		goto nextaf;
	}

	if (cnt > max) {
		log_warnx("%s: %s resolves to more than %d hosts", __func__,
		    s, max);
	}
	freeifaddrs(ifap);
	return (cnt);
}

int
host(const char *s, struct addresslist *al, int max,
    struct portrange *port, const char *ifname, int ipproto)
{
	struct address *h;

	if (strcmp("*", s) == 0)
		s = "0.0.0.0";

	h = host_v4(s);

	/* IPv6 address? */
	if (h == NULL)
		h = host_v6(s);

	if (h != NULL) {
		if (port != NULL)
			memcpy(&h->port, port, sizeof(h->port));
		if (ifname != NULL) {
			if (strlcpy(h->ifname, ifname, sizeof(h->ifname)) >=
			    sizeof(h->ifname)) {
				log_warnx("%s: interface name truncated",
				    __func__);
				free(h);
				return (-1);
			}
		}
		if (ipproto != -1)
			h->ipproto = ipproto;

		TAILQ_INSERT_HEAD(al, h, entry);
		return (1);
	}

	return (host_dns(s, al, max, port, ifname, ipproto));
}

void
host_free(struct addresslist *al)
{
	struct address	 *h;

	while ((h = TAILQ_FIRST(al)) != NULL) {
		TAILQ_REMOVE(al, h, entry);
		free(h);
	}
}

struct server *
server_inherit(struct server *src, struct server_config *alias,
    struct server_config *addr)
{
	struct server	*dst, *s, *dstl;

	if ((dst = calloc(1, sizeof(*dst))) == NULL)
		fatal("out of memory");

	/* Copy the source server and assign a new Id */
	memcpy(&dst->srv_conf, &src->srv_conf, sizeof(dst->srv_conf));
	if ((dst->srv_conf.tls_cert_file =
	    strdup(src->srv_conf.tls_cert_file)) == NULL)
		fatal("out of memory");
	if ((dst->srv_conf.tls_key_file =
	    strdup(src->srv_conf.tls_key_file)) == NULL)
		fatal("out of memory");
	if (src->srv_conf.tls_ocsp_staple_file != NULL) {
		if ((dst->srv_conf.tls_ocsp_staple_file =
		    strdup(src->srv_conf.tls_ocsp_staple_file)) == NULL)
			fatal("out of memory");
	}

	if (src->srv_conf.return_uri != NULL &&
	    (dst->srv_conf.return_uri =
	    strdup(src->srv_conf.return_uri)) == NULL)
		fatal("out of memory");

	dst->srv_conf.id = ++last_server_id;
	dst->srv_conf.parent_id = dst->srv_conf.id;
	dst->srv_s = -1;

	if (last_server_id == INT_MAX) {
		yyerror("too many servers defined");
		serverconfig_free(&dst->srv_conf);
		free(dst);
		return (NULL);
	}

	/* Now set alias and listen address */
	strlcpy(dst->srv_conf.name, alias->name, sizeof(dst->srv_conf.name));
	memcpy(&dst->srv_conf.ss, &addr->ss, sizeof(dst->srv_conf.ss));
	dst->srv_conf.port = addr->port;
	dst->srv_conf.prefixlen = addr->prefixlen;
	if (addr->flags & SRVFLAG_TLS)
		dst->srv_conf.flags |= SRVFLAG_TLS;
	else
		dst->srv_conf.flags &= ~SRVFLAG_TLS;

	/* Don't inherit the "match" option, use it from the alias */
	dst->srv_conf.flags &= ~SRVFLAG_SERVER_MATCH;
	dst->srv_conf.flags |= (alias->flags & SRVFLAG_SERVER_MATCH);

	if (server_tls_load_keypair(dst) == -1) {
		yyerror("failed to load public/private keys "
		    "for server %s", dst->srv_conf.name);
		serverconfig_free(&dst->srv_conf);
		free(dst);
		return (NULL);
	}

	if (server_tls_load_ocsp(dst) == -1) {
		yyerror("failed to load ocsp staple "
		    "for server %s", dst->srv_conf.name);
		serverconfig_free(&dst->srv_conf);
		free(dst);
		return (NULL);
	}

	/* Check if the new server already exists */
	if (server_match(dst, 1) != NULL) {
		yyerror("server \"%s\" defined twice",
		    dst->srv_conf.name);
		serverconfig_free(&dst->srv_conf);
		free(dst);
		return (NULL);
	}

	/* Copy all the locations of the source server */
	TAILQ_FOREACH(s, conf->sc_servers, srv_entry) {
		if (!(s->srv_conf.flags & SRVFLAG_LOCATION &&
		    s->srv_conf.parent_id == src->srv_conf.parent_id))
			continue;

		if ((dstl = calloc(1, sizeof(*dstl))) == NULL)
			fatal("out of memory");

		memcpy(&dstl->srv_conf, &s->srv_conf, sizeof(dstl->srv_conf));
		strlcpy(dstl->srv_conf.name, alias->name,
		    sizeof(dstl->srv_conf.name));

		/* Copy the new Id and listen address */
		dstl->srv_conf.id = ++last_server_id;
		dstl->srv_conf.parent_id = dst->srv_conf.id;
		memcpy(&dstl->srv_conf.ss, &addr->ss,
		    sizeof(dstl->srv_conf.ss));
		dstl->srv_conf.port = addr->port;
		dstl->srv_conf.prefixlen = addr->prefixlen;
		dstl->srv_s = -1;

		DPRINTF("adding location \"%s\" for \"%s[%u]\"",
		    dstl->srv_conf.location,
		    dstl->srv_conf.name, dstl->srv_conf.id);

		TAILQ_INSERT_TAIL(conf->sc_servers, dstl, srv_entry);
	}

	return (dst);
}

int
getservice(char *n)
{
	struct servent	*s;
	const char	*errstr;
	long long	 llval;

	llval = strtonum(n, 0, UINT16_MAX, &errstr);
	if (errstr) {
		s = getservbyname(n, "tcp");
		if (s == NULL)
			s = getservbyname(n, "udp");
		if (s == NULL) {
			yyerror("unknown port %s", n);
			return (-1);
		}
		return (s->s_port);
	}

	return (htons((unsigned short)llval));
}

int
is_if_in_group(const char *ifname, const char *groupname)
{
	unsigned int		 len;
	struct ifgroupreq	 ifgr;
	struct ifg_req		*ifg;
	int			 s;
	int			 ret = 0;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		err(1, "socket");

	memset(&ifgr, 0, sizeof(ifgr));
	if (strlcpy(ifgr.ifgr_name, ifname, IFNAMSIZ) >= IFNAMSIZ)
		err(1, "IFNAMSIZ");
	if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1) {
		if (errno == EINVAL || errno == ENOTTY)
			goto end;
		err(1, "SIOCGIFGROUP");
	}

	len = ifgr.ifgr_len;
	ifgr.ifgr_groups = calloc(len / sizeof(struct ifg_req),
	    sizeof(struct ifg_req));
	if (ifgr.ifgr_groups == NULL)
		err(1, "getifgroups");
	if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1)
		err(1, "SIOCGIFGROUP");

	ifg = ifgr.ifgr_groups;
	for (; ifg && len >= sizeof(struct ifg_req); ifg++) {
		len -= sizeof(struct ifg_req);
		if (strcmp(ifg->ifgrq_group, groupname) == 0) {
			ret = 1;
			break;
		}
	}
	free(ifgr.ifgr_groups);

end:
	close(s);
	return (ret);
}
@


1.91
log
@Convert httpd to tls_config_set_ecdhecurves(), allowing a list of curves
to be specified, rather than a single curve.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.90 2017/03/25 17:25:34 claudio Exp $	*/
d1121 1
a1121 1
			if ($2 <= 0 || $2 >= (int)USHRT_MAX) {
@


1.90
log
@Implement TLS ticket support in httpd. Off by default. Use
	tls ticket lifetime default
to turn it on with a 2h ticket lifetime.
Rekeying happens after a quarter of that time.
OK reky@@ and bob@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.89 2017/02/07 12:27:42 reyk Exp $	*/
d269 3
a271 3
			strlcpy(s->srv_conf.tls_ecdhe_curve,
			    HTTPD_TLS_ECDHE_CURVE,
			    sizeof(s->srv_conf.tls_ecdhe_curve));
d751 3
a753 3
			if (strlcpy(srv_conf->tls_ecdhe_curve, $2,
			    sizeof(srv_conf->tls_ecdhe_curve)) >=
			    sizeof(srv_conf->tls_ecdhe_curve)) {
@


1.89
log
@/tmp/cvsspEkok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.88 2017/01/27 07:03:27 tom Exp $	*/
d133 4
a136 4
%token	COMBINED CONNECTION DHE DIRECTORY ECDHE ERR FCGI INDEX IP KEY LISTEN
%token	LOCATION LOG LOGDIR MATCH MAXIMUM NO NODELAY OCSP ON PORT PREFORK
%token	PROTOCOLS REQUESTS ROOT SACK SERVER SOCKET STRIP STYLE SYSLOG TCP TIMEOUT
%token	TLS TYPE TYPES HSTS MAXAGE SUBDOMAINS DEFAULT PRELOAD REQUEST
d769 17
d1238 1
d1267 1
@


1.88
log
@More s/OSCP/OCSP/ typos

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.87 2017/01/05 13:53:09 krw Exp $	*/
d248 2
d689 4
@


1.87
log
@Replace hand-rolled for(;;) emptying of 'symhead' TAILQ with more
modern TAILQ_FOREACH_SAFE().

No intentional functional change.

ok millert@@ bluhm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.86 2017/01/05 12:42:18 krw Exp $	*/
d347 1
a347 1
				    "oscp staple", srv->srv_conf.name);
d2072 1
a2072 1
		yyerror("failed to load oscp staple "
@


1.86
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.85 2016/11/17 14:52:48 jsing Exp $	*/
d1601 1
a1601 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
@


1.85
log
@Move OCSP loading into a separate function - it is not part of the keypair
and this way we can give a separate specific error message.

ok beck@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.84 2016/11/06 15:50:47 beck Exp $	*/
d1692 4
a1695 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d1754 1
a1754 1
	TAILQ_FOREACH(sym, &symhead, entry)
d1759 1
@


1.84
log
@since ocsp stapling is optional, make sure we guard if we do not have it.
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.83 2016/11/06 10:49:38 beck Exp $	*/
d345 8
a2030 4
	dst->srv_conf.tls_cert = NULL;
	dst->srv_conf.tls_key = NULL;
	dst->srv_conf.tls_cert_len = 0;
	dst->srv_conf.tls_key_len = 0;
d2064 8
@


1.83
log
@Add OCSP stapling support to httpd
ok jsing@@ bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.82 2016/09/03 14:44:21 reyk Exp $	*/
d2018 5
a2022 3
	if ((dst->srv_conf.tls_ocsp_staple_file =
	    strdup(src->srv_conf.tls_ocsp_staple_file)) == NULL)
		fatal("out of memory");
@


1.82
log
@Replace [RELAY|SERVER]_MAXPROC with the new PROC_MAX_INSTANCES
variable and limit it from 128 to 32 instances (the old value).
While here, move a few PROC_ defines around.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.81 2016/08/22 15:02:18 jsing Exp $	*/
d134 3
a136 3
%token	LOCATION LOG LOGDIR MATCH MAXIMUM NO NODELAY ON PORT PREFORK PROTOCOLS
%token	REQUEST REQUESTS ROOT SACK SERVER SOCKET STRIP STYLE SYSLOG TCP TIMEOUT
%token	TLS TYPE TYPES HSTS MAXAGE SUBDOMAINS DEFAULT PRELOAD
d709 7
d1216 1
d2017 3
@


1.81
log
@Enable SNI support in httpd(8).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.80 2016/08/15 16:12:34 jsing Exp $	*/
d196 1
a196 1
			if ($2 <= 0 || $2 > SERVER_MAXPROC) {
@


1.80
log
@Move server_match() from parse.y to server.c; use env instead of conf,
which is actually the same thing (cluebat from reyk@@).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.79 2016/08/15 13:48:24 jsing Exp $	*/
d317 1
a317 1
				if (server_tls_cmp(s, srv) != 0) {
@


1.79
log
@Make httpd stricter with respect to TLS configuration - in particular, do
not allow TLS and non-TLS to be configured on the same port, do not allow
TLS options to be specified without a TLS listener and ensure that the TLS
options are the same when a server is specified on the same address/port.
Currently, these configurations are permitted but do not work as intended.

Also factor out and reuse the server matching code, which was previously
duplicated.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.78 2016/06/21 21:35:24 benno Exp $	*/
a109 1
struct server	*server_match(struct server *, int);
a1990 27
}

struct server *
server_match(struct server *s2, int match_name)
{
	struct server	*s1;

	/* Attempt to find matching server. */
	TAILQ_FOREACH(s1, conf->sc_servers, srv_entry) {
		if ((s1->srv_conf.flags & SRVFLAG_LOCATION) != 0)
			continue;
		if (match_name) {
			if (strcmp(s1->srv_conf.name, s2->srv_conf.name) != 0)
				continue;
		}
		if (s1->srv_conf.port != s2->srv_conf.port)
			continue;
		if (sockaddr_cmp(
		    (struct sockaddr *)&s1->srv_conf.ss,
		    (struct sockaddr *)&s2->srv_conf.ss,
		    s1->srv_conf.prefixlen) != 0)
			continue;

		return (s1);
	}

	return (NULL);
@


1.78
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.77 2015/11/22 13:27:13 reyk Exp $	*/
d110 1
d287 1
a287 1
			struct server		*s = NULL, *sn;
d292 2
a293 13
			TAILQ_FOREACH(s, conf->sc_servers, srv_entry) {
				if ((s->srv_conf.flags &
				    SRVFLAG_LOCATION) == 0 &&
				    strcmp(s->srv_conf.name,
				    srv->srv_conf.name) == 0 &&
				    s->srv_conf.port == srv->srv_conf.port &&
				    sockaddr_cmp(
				    (struct sockaddr *)&s->srv_conf.ss,
				    (struct sockaddr *)&srv->srv_conf.ss,
				    s->srv_conf.prefixlen) == 0)
					break;
			}
			if (s != NULL) {
d308 21
d331 3
a333 1
				yyerror("no TLS protocols");
d339 2
a340 2
				yyerror("failed to load public/private keys "
				    "for server %s", srv->srv_conf.name);
d414 1
a414 1
				/* Add as an alias */
d432 1
a432 1
			if ($4) {
a433 1
			}
d483 3
d490 9
d743 1
a743 1
				yyerror("invalid TLS protocols");
d1995 27
d2082 1
a2082 13
	TAILQ_FOREACH(s, conf->sc_servers, srv_entry) {
		if ((s->srv_conf.flags &
		    SRVFLAG_LOCATION) == 0 &&
		    strcmp(s->srv_conf.name,
		    dst->srv_conf.name) == 0 &&
		    s->srv_conf.port == dst->srv_conf.port &&
		    sockaddr_cmp(
		    (struct sockaddr *)&s->srv_conf.ss,
		    (struct sockaddr *)&dst->srv_conf.ss,
		    s->srv_conf.prefixlen) == 0)
			break;
	}
	if (s != NULL) {
@


1.77
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.76 2015/08/20 22:39:29 deraadt Exp $	*/
d174 8
@


1.76
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.75 2015/08/20 13:00:23 reyk Exp $	*/
d1726 1
a1726 1
		fatal(NULL);
d1751 1
a1751 1
			fatal(NULL);
d1802 1
a1802 1
			fatal(NULL);
@


1.75
log
@Change httpd(8) to use C99-style fixed-width integers (uintN_t instead
of u_intN_t) and replace u_int with unsigned int.  Mixing both
variants is a bad style and most contributors seem to prefer this
style; it also helps us to get used to it, portability, and
standardization.

Theoretically no binary change, except one in practice: httpd.o has a
different checksum because gcc with -O2 pads/optimizes "struct
privsep" differently when using "unsigned int" instead "u_int" for the
affected members.  "u_int" is just a typedef of "unsigned int", -O0
doesn't build the difference and clang with -O2 doesn't do it either -
it is just another curiosity from gcc-land.

OK semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.74 2015/08/19 21:26:21 reyk Exp $	*/
d2119 2
a2120 3
	ifgr.ifgr_groups =
	    (struct ifg_req *)calloc(len / sizeof(struct ifg_req),
		sizeof(struct ifg_req));
@


1.74
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.73 2015/07/19 05:17:27 reyk Exp $	*/
d1215 4
a1218 4
u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;
d1310 4
a1313 4
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;
d2094 1
a2094 1
	return (htons((u_short)llval));
@


1.73
log
@For the completeness of HSTS, add the non-standard preload option.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.72 2015/07/18 06:00:43 reyk Exp $	*/
d1010 1
a1010 1
mediastring	: STRING '/' STRING 	{
@


1.72
log
@Allow to change the default media type globally or per-location,
eg. default type text/html.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.71 2015/07/18 05:41:18 florian Exp $	*/
d136 1
a136 1
%token	TLS TYPE TYPES HSTS MAXAGE SUBDOMAINS DEFAULT
d596 4
a599 1
			srv->srv_conf.hsts_subdomains = 1;
d1182 1
@


1.71
log
@Implement HTTP Strict Transport Security (HSTS).
Input & OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.70 2015/07/16 19:05:28 reyk Exp $	*/
d136 1
a136 1
%token	TLS TYPES HSTS MAXAGE SUBDOMAINS
d201 4
d564 5
d1003 5
a1007 1
mediaoptsl	: STRING '/' STRING	{
d1021 1
a1021 2
		} medianames_l optsemicolon
		| include
d1154 1
d1194 1
d1522 2
a1523 1
	struct sym	*sym, *next;
d1530 3
@


1.70
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.69 2015/07/15 17:14:50 jsing Exp $	*/
d136 1
a136 1
%token	TLS TYPES
d259 2
d561 28
d1148 1
d1159 1
d1176 1
@


1.69
log
@Unbreak configurations that have a non-TLS listen statement followed by a
TLS listen statement. A bug was introduced in r1.68 of parse.y, which
results in flags being directly copied from the parent, meaning that the
TLS flag for the second server gets lost.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.68 2015/06/23 15:23:14 reyk Exp $	*/
d412 2
a413 1
				alias->flags |= srv->srv_conf.flags & SRVFLAG_SERVER_MATCH;
@


1.68
log
@Add initial support for pattern matching using Lua's pattern matching code.

With important help on the pattern matcher from semarie@@

OK semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.67 2015/04/01 04:51:15 jsg Exp $	*/
d411 2
a412 1
				alias->flags = srv->srv_conf.flags;
@


1.67
log
@Zero the tls cert/key length variables when inheriting a server
configuration for multiple listen statements in a server block.
Otherwise httpd will crash when a listen statement with tls is followed
by a listen statement without tls.

Problem reported by Kent Fritz on misc.

ok jsing@@ looks good deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.66 2015/03/09 15:46:45 reyk Exp $	*/
d110 1
a110 1
struct server	*server_inherit(struct server *, const char *,
d134 1
a134 1
%token	LOCATION LOG LOGDIR MAXIMUM NO NODELAY ON PORT PREFORK PROTOCOLS
d141 1
a141 1
%type	<v.number>	opttls
d203 1
a203 1
server		: SERVER STRING		{
d207 1
a207 1
				free($2);
d214 1
a214 1
			if (strlcpy(s->srv_conf.name, $2,
d218 1
a218 1
				free($2);
d222 1
a222 1
			free($2);
d238 3
a240 1
			s->srv_conf.flags |= SRVFLAG_LOG;
d339 1
a339 1
					    b->name, a)) == NULL) {
d410 2
d416 1
a416 1
		| ALIAS STRING		{
d421 1
a421 1
				free($2);
d428 1
a428 1
			if (strlcpy(alias->name, $2, sizeof(alias->name)) >=
d431 1
a431 1
				free($2);
d435 4
a438 1
			free($2);
d466 1
a466 1
		| LOCATION STRING		{
d471 1
a471 1
				free($2);
d476 2
a477 2
				yyerror("location %s inside location", $2);
				free($2);
d482 1
a482 1
				free($2);
d489 1
a489 1
			if (strlcpy(s->srv_conf.location, $2,
d493 1
a493 1
				free($2);
d497 1
a497 1
			free($2);
d511 2
d896 4
d1124 1
d1906 1
a1906 1
server_inherit(struct server *src, const char *name,
d1944 1
a1944 1
	strlcpy(dst->srv_conf.name, name, sizeof(dst->srv_conf.name));
d1953 4
d1996 2
a1997 1
		strlcpy(dstl->srv_conf.name, name, sizeof(dstl->srv_conf.name));
@


1.66
log
@Make httpd TLSv1.2-only by default.  Some older browsers, like IE 10,
will be incompatible with this change.  We do this early in the
release cycle, so there is a good chance to get more experience with
the impact of it and the upcoming restricted cipher modes.

OK jsing@@ deraadt@@ benno@@ bmercer@@ krw@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.65 2015/02/12 04:40:23 jsing Exp $	*/
d1910 2
@


1.65
log
@Allow TLS protocols to be specified via a "tls protocols" configuration
option.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.64 2015/02/08 04:50:32 reyk Exp $	*/
d240 1
a240 1
			s->srv_conf.tls_protocols = TLS_PROTOCOLS_ALL;
@


1.64
log
@Use AI_ADDRCONFIG when resolv hosts on startup.

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.63 2015/02/08 00:00:59 reyk Exp $	*/
d134 3
a136 2
%token	LOCATION LOG LOGDIR MAXIMUM NO NODELAY ON PORT PREFORK REQUEST REQUESTS
%token	ROOT SACK SERVER SOCKET STRIP STYLE SYSLOG TCP TIMEOUT TLS TYPES
d240 1
d302 7
d655 9
d1118 1
@


1.63
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.62 2015/02/07 06:26:28 jsing Exp $	*/
d1697 1
@


1.62
log
@Add httpd configuration options to allow the specification of DHE
parameters and the ECDHE curve. This primarily allows for DHE cipher suites
to be enabled.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.61 2015/02/07 01:23:12 reyk Exp $	*/
d135 1
a135 1
%token	ROOT SACK SERVER SOCKET STRIP STYLE SYSLOG TCP TIMEOUT TLS TYPES 
@


1.61
log
@Add support for blocking, dropping, and redirecting requests.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.60 2015/02/06 13:05:20 reyk Exp $	*/
d133 3
a135 3
%token	COMBINED CONNECTION DIRECTORY ERR FCGI INDEX IP KEY LISTEN LOCATION
%token	LOG LOGDIR MAXIMUM NO NODELAY ON PORT PREFORK REQUEST REQUESTS ROOT
%token	SACK SERVER SOCKET STRIP STYLE SYSLOG TCP TIMEOUT TLS TYPES 
d245 2
a246 1
			strlcpy(s->srv_conf.tls_ciphers, HTTPD_TLS_CIPHERS,
d248 6
d626 20
d1079 1
d1082 1
@


1.60
log
@Fix log options in locations.

Reported and tested by Markus Bergkvist
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.59 2015/01/29 08:52:52 reyk Exp $	*/
d136 1
a136 1
%token	ERROR INCLUDE AUTHENTICATE WITH
d142 1
a142 1
%type	<v.string>	numberstring
d442 1
d802 44
d1043 1
d1053 1
d1068 1
d1073 1
d1861 5
@


1.59
log
@Fix a regression that removed support for using service names instead
of ports.  It is now possible to use "listen on * port www" again.

Found by ajacoutot@@
OK ajacoutot@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.58 2015/01/21 22:21:05 reyk Exp $	*/
d232 1
d483 1
d485 1
a485 1
			s->srv_conf.id = srv->srv_conf.id;
d1814 1
d1866 1
a1866 1
		    s->srv_conf.id == src->srv_conf.id))
d1876 2
a1877 1
		dstl->srv_conf.id = dst->srv_conf.id;
@


1.58
log
@httpd is based on relayd and had included many headers that are only
needed by its ancestor.  jsg@@, include-what-you-use, and some manual
review helped to cleanup the headers (take iwyu with a grain of salt).
Based on common practice, httpd.h now also includes the necessary
headers for itself.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.57 2015/01/19 21:07:33 reyk Exp $	*/
d905 12
@


1.57
log
@No need to include pfvar.h, another leftover from relayd.  It was also
used for portrange operators which weren't used in httpd.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.56 2015/01/19 19:37:50 reyk Exp $	*/
d32 1
d34 2
a39 1
#include <net/route.h>
a44 1
#include <event.h>
@


1.56
log
@Decouple auth parameters from struct server_config into struct auth.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.55 2015/01/18 14:01:17 florian Exp $	*/
a34 1
#include <net/pfvar.h>
a370 5
			if ($5.op != PF_OP_EQ) {
				yyerror("invalid port");
				free($3);
				YYERROR;
			}
d898 1
a898 27
port		: PORT STRING {
			char		*a, *b;
			int		 p[2];

			p[0] = p[1] = 0;

			a = $2;
			b = strchr($2, ':');
			if (b == NULL)
				$$.op = PF_OP_EQ;
			else {
				*b++ = '\0';
				if ((p[1] = getservice(b)) == -1) {
					free($2);
					YYERROR;
				}
				$$.op = PF_OP_RRG;
			}
			if ((p[0] = getservice(a)) == -1) {
				free($2);
				YYERROR;
			}
			$$.val[0] = p[0];
			$$.val[1] = p[1];
			free($2);
		}
		| PORT NUMBER {
a903 1
			$$.op = PF_OP_EQ;
@


1.55
log
@First stab at implementing basic auth.
Currently the htpasswd file needs to be in the chroot; will hopefully
improved soonish.
Based on a diff from Oscar Linderholm many months ago but turned into
a complete rewrite.
input/OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.54 2015/01/16 06:40:17 deraadt Exp $	*/
d94 1
d121 1
d143 1
d651 28
a678 2
authenticate	: AUTHENTICATE STRING WITH STRING		{
			if (strlcpy(srv->srv_conf.auth_realm, $2,
d682 1
a682 1
				free($2);
d685 4
a688 4
			free($2);
			if (strlcpy(srv->srv_conf.auth_htpasswd, $4,
			    sizeof(srv->srv_conf.auth_htpasswd)) >=
			    sizeof(srv->srv_conf.auth_htpasswd)) {
d690 1
a690 1
				free($4);
d693 2
a694 2
			free($4);
			srv->srv_conf.flags |= SRVFLAG_AUTH_BASIC;
d696 4
a699 4
		| AUTHENTICATE WITH STRING		{
			if (strlcpy(srv->srv_conf.auth_htpasswd, $3,
			    sizeof(srv->srv_conf.auth_htpasswd)) >=
			    sizeof(srv->srv_conf.auth_htpasswd)) {
d701 1
a701 1
				free($3);
d704 1
a704 2
			free($3);
			srv->srv_conf.flags |= SRVFLAG_AUTH_BASIC;
d1431 1
@


1.54
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.53 2015/01/13 09:21:15 reyk Exp $	*/
d134 1
a134 1
%token	ERROR INCLUDE
d442 1
d648 31
d985 1
d1025 2
a1026 1
		{ "types",		TYPES }
@


1.53
log
@bump copyright year
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.52 2015/01/07 11:04:29 reyk Exp $	*/
d122 1
a122 1
			char			 name[MAXHOSTNAMELEN];
@


1.52
log
@Relax configuration list parsing to allow multi-line blocks for tls,
root, tcp etc.

Based on a diff from Nathanael Rensen.
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.51 2015/01/06 14:07:48 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007 - 2014 Reyk Floeter <reyk@@openbsd.org>
@


1.51
log
@Only open a socket once for each unique "listen on" statement.  This
prevents running out of file descriptors when loading a configuration
with many aliases.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.48 2015/01/03 16:20:31 reyk Exp $	*/
d420 1
a420 1
		| TCP			{
d425 2
a426 2
		} tcpip
		| CONNECTION		{
d431 2
a432 2
		} connection
		| TLS			{
d437 3
a439 5
		} tls
		| ROOT rootflags
		| ROOT '{' rootflags_l '}'
		| DIRECTORY dirflags
		| DIRECTORY '{' dirflags_l '}'
d543 1
a543 1
		} '{' fcgiflags_l '}'
d550 2
a551 2
fcgiflags_l	: fcgiflags comma fcgiflags_l
		| fcgiflags
d567 2
a568 2
connection	: '{' conflags_l '}'
		| conflags
d571 2
a572 2
conflags_l	: conflags comma conflags_l
		| conflags
d587 2
a588 2
tls		: '{' tlsopts_l '}'
		| tlsopts
d591 2
a592 2
tlsopts_l	: tlsopts comma tlsopts_l
		| tlsopts
d619 6
a624 2
rootflags_l	: rootflags comma rootflags_l
		| rootflags
d647 6
a652 2
dirflags_l	: dirflags comma dirflags_l
		| dirflags
d683 1
a683 1
		| LOG '{' logflags_l '}'
d690 2
a691 2
logflags_l	: logflags comma logflags_l
		| logflags
a693 1

d744 2
a745 2
tcpip		: '{' tcpflags_l '}'
		| tcpflags
d748 2
a749 2
tcpflags_l	: tcpflags comma tcpflags_l
		| tcpflags
a901 5
comma		: ','
		| nl
		| /* empty */
		;

d908 4
@


1.50
log
@add new url stripping option:

strip number
	Strip number path components from the beginning of the
	request URI before looking up the stripped-down URI at
	the document root.


reviewed with much patience and OK by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.49 2015/01/03 23:54:25 reyk Exp $	*/
d229 1
d488 1
d1765 2
d1831 1
@


1.49
log
@Reset tls key and cert to NULL when duplicating a server - avoids a
possible double free in the error path of the parser.

Found by + OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.47 2015/01/03 15:49:18 reyk Exp $	*/
d133 1
a133 1
%token	SACK SERVER SOCKET STYLE SYSLOG TCP TIMEOUT TLS TYPES
d437 2
a438 11
		| ROOT STRING		{
			if (strlcpy(srv->srv_conf.root, $2,
			    sizeof(srv->srv_conf.root)) >=
			    sizeof(srv->srv_conf.root)) {
				yyerror("document root too long");
				free($2);
				YYERROR;
			}
			free($2);
			srv->srv_conf.flags |= SRVFLAG_ROOT;
		}
d619 24
d980 1
@


1.48
log
@Tweak previous - add a missing free in the error path.
@
text
@d1743 2
@


1.47
log
@Support alias names and multiple listen statements per server block.
The implementation is done in the parser by expanding each
alias/listen into an independent server configuration; this makes it
easier to handle internally without adding additional loops or
conditions.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.46 2014/12/21 00:54:49 guenther Exp $	*/
d1747 1
@


1.46
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.45 2014/12/18 10:10:11 reyk Exp $	*/
d109 2
d130 1
a130 1
%token	ACCESS AUTO BACKLOG BODY BUFFER CERTIFICATE CHROOT CIPHERS COMMON
d133 1
a133 1
%token	SACK SERVER SOCKET STYLE SYSLOG TCP TIMEOUT TLS TYPES 
d252 3
d256 4
a259 1
			struct server	*s = NULL;
d301 38
d351 1
a351 1
			struct server		*s;
d360 6
a365 3
				yyerror("listen address already specified");
				free($3);
				YYERROR;
d367 1
a367 1
				s = srv;
d382 3
a384 4
			memcpy(&srv->srv_conf.ss, &h->ss,
			    sizeof(s->srv_conf.ss));
			s->srv_conf.port = h->port.val[0];
			s->srv_conf.prefixlen = h->prefixlen;
d388 26
a413 1
				s->srv_conf.flags |= SRVFLAG_TLS;
d415 3
d931 1
d1724 93
@


1.45
log
@Accept * as an alias for the default ipv4 listen address.

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.44 2014/12/12 14:45:59 reyk Exp $	*/
a37 1
#include <arpa/nameser.h>
@


1.44
log
@Like previously done in relayd, change the keyword "ssl" to "tls" to
reflect reality.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.43 2014/12/04 02:44:42 tedu Exp $	*/
d1126 1
a1126 1
	if (isalnum(c) || c == ':' || c == '_') {
d1607 3
@


1.43
log
@stop viral header propagation. none of this code uses sys/hash.h
from Max Fillinger
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.42 2014/11/20 05:51:20 jsg Exp $	*/
d132 1
a132 1
%token	SACK SERVER SOCKET SSL STYLE SYSLOG TCP TIMEOUT TYPES
d137 1
a137 1
%type	<v.number>	optssl
d176 2
a177 2
optssl		: /*empty*/	{ $$ = 0; }
		| SSL		{ $$ = 1; }
d233 2
a234 2
			if ((s->srv_conf.ssl_cert_file =
			    strdup(HTTPD_SSL_CERT)) == NULL)
d236 2
a237 2
			if ((s->srv_conf.ssl_key_file =
			    strdup(HTTPD_SSL_KEY)) == NULL)
d239 2
a240 2
			strlcpy(s->srv_conf.ssl_ciphers, HTTPD_SSL_CIPHERS,
			    sizeof(s->srv_conf.ssl_ciphers));
d281 1
a281 1
			if (server_ssl_load_keypair(srv) == -1) {
d303 1
a303 1
serveroptsl	: LISTEN ON STRING optssl port {
d341 1
a341 1
				s->srv_conf.flags |= SRVFLAG_SSL;
d356 1
a356 1
		| SSL			{
d358 1
a358 1
				yyerror("ssl configuration inside location");
d361 1
a361 1
		} ssl
d521 2
a522 2
ssl		: '{' sslopts_l '}'
		| sslopts
d525 2
a526 2
sslopts_l	: sslopts comma sslopts_l
		| sslopts
d529 3
a531 3
sslopts		: CERTIFICATE STRING		{
			free(srv_conf->ssl_cert_file);
			if ((srv_conf->ssl_cert_file = strdup($2)) == NULL)
d536 2
a537 2
			free(srv_conf->ssl_key_file);
			if ((srv_conf->ssl_key_file = strdup($2)) == NULL)
d542 3
a544 3
			if (strlcpy(srv_conf->ssl_ciphers, $2,
			    sizeof(srv_conf->ssl_ciphers)) >=
			    sizeof(srv_conf->ssl_ciphers)) {
a888 1
		{ "ssl",		SSL },
d893 1
@


1.42
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2014/11/11 15:54:45 beck Exp $	*/
a32 1
#include <sys/hash.h>
@


1.41
log
@Allow the log directory to be configurable in the config file, rather than
fixed as /logs within the chroot.  As this httpd is properly privesp'ed this
has the nice property of allowing us to put the logs outside the chroot if
we want to.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2014/11/03 18:43:24 bluhm Exp $	*/
d1069 3
@


1.40
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.39 2014/11/03 03:46:44 doug Exp $	*/
d132 2
a133 2
%token	LOG MAXIMUM NO NODELAY ON PORT PREFORK REQUEST REQUESTS ROOT SACK
%token	SERVER SOCKET SSL STYLE SYSLOG TCP TIMEOUT TYPES
d194 3
d877 1
@


1.39
log
@Add gcc format attributes to yyerror() in httpd.

Fix a few format characters as well.
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2014/09/05 10:04:20 reyk Exp $	*/
d830 1
a830 1
	char		*nfmt;
d834 2
a835 3
	if (asprintf(&nfmt, "%s:%d: %s", file->name, yylval.lineno, fmt) == -1)
		fatalx("yyerror asprintf");
	vlog(LOG_CRIT, nfmt, ap);
d837 2
a838 1
	free(nfmt);
@


1.38
log
@Remove a limitation that only allowed to specify a server name once.
The key has been changed to server name + address + port and now it is
possible to use the same server name for multiple servers with
different addresses, eg. http://www.example.com and
https://www.example.com/.

OK doug@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2014/09/04 13:45:17 reyk Exp $	*/
d72 3
a74 1
int		 yyerror(const char *, ...);
d186 1
a186 1
				    "servers: %d", $2);
d663 1
a663 1
				yyerror("invalid backlog: %d", $2);
d671 1
a671 1
				yyerror("invalid socket buffer size: %d", $3);
d677 1
a677 1
				yyerror("invalid ttl: %d", $3);
d773 1
a773 1
				yyerror("invalid port: %d", $2);
d784 1
a784 1
				yyerror("invalid timeout: %d\n", $1);
@


1.37
log
@One line change adding the 'include' directive to the valid server
options.  This allows to include external configuration files from
within server and location sections, not just from global context, for
example to share common configuration within multiple servers (or
virtual hosts).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.36 2014/08/25 14:27:54 reyk Exp $	*/
a201 9
			TAILQ_FOREACH(s, conf->sc_servers, srv_entry)
				if (!strcmp(s->srv_conf.name, $2))
					break;
			if (s != NULL) {
				yyerror("server %s defined twice", $2);
				free($2);
				YYERROR;
			}

a246 1
			TAILQ_INSERT_TAIL(conf->sc_servers, srv, srv_entry);
d248 22
d272 2
a273 1
				free($2);
d276 1
d280 2
d284 6
a392 11
			TAILQ_FOREACH(s, conf->sc_servers, srv_entry)
				if (strcmp(s->srv_conf.name,
				    srv->srv_conf.name) == 0 &&
				    strcmp(s->srv_conf.location, $2) == 0)
					break;
			if (s != NULL) {
				yyerror("location %s defined twice", $2);
				free($2);
				YYERROR;
			}

d431 22
d454 1
a454 1
		} '{' optnl serveropts_l '}'	{
@


1.36
log
@Add a generic system-wide /usr/share/misc/mime.types file that can be
included in httpd.conf.  httpd(8) now supports both mime.types
flavours with or without semicolon at the end of the line (nginx- or
apache-style).

Discussed with many, with input from halex@@
OK halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2014/08/09 07:35:45 reyk Exp $	*/
d426 1
@


1.35
log
@Allow to inclue the types section anywhere in the configuration file.

Found by chris@@
OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2014/08/06 20:29:54 reyk Exp $	*/
d138 1
d664 1
a664 1
		| mediaoptsl optnl
d681 2
a682 1
		} medianames_l ';'
d689 1
a689 1
medianamesl	: STRING				{
d756 11
d770 4
@


1.34
log
@Change grammar to remove a shift/reduce conflict that was introduced
with the ssl options.
"listen on $ip port 443 ssl" turns into "listen on $ip ssl port 443".

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2014/08/06 18:21:14 reyk Exp $	*/
d696 3
@


1.34.2.1
log
@httpd was developed very rapidly in the weeks before 5.6 release,
and it has a few flaws.  It would be nice to get these flaws fully
remediated before the next release, and that requires the community
to want to use it.
Therefore here is a "jumbo" patch that brings in the most important fixes.

committing on behalf of reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2014/08/06 20:29:54 reyk Exp $	*/
d183 1
a183 1
				    "servers: %lld", $2);
d201 9
d255 1
a256 22
			struct server	*s = NULL;

			TAILQ_FOREACH(s, conf->sc_servers, srv_entry) {
				if ((s->srv_conf.flags &
				    SRVFLAG_LOCATION) == 0 &&
				    strcmp(s->srv_conf.name,
				    srv->srv_conf.name) == 0 &&
				    s->srv_conf.port == srv->srv_conf.port &&
				    sockaddr_cmp(
				    (struct sockaddr *)&s->srv_conf.ss,
				    (struct sockaddr *)&srv->srv_conf.ss,
				    s->srv_conf.prefixlen) == 0)
					break;
			}
			if (s != NULL) {
				yyerror("server \"%s\" defined twice",
				    srv->srv_conf.name);
				serverconfig_free(srv_conf);
				free(srv);
				YYABORT;
			}

d259 1
a259 2
				serverconfig_free(srv_conf);
				free(srv);
a261 1

a264 2
				serverconfig_free(srv_conf);
				free(srv);
a266 3

			TAILQ_INSERT_TAIL(conf->sc_servers, srv, srv_entry);

d370 11
d419 1
a420 19
			struct server	*s = NULL;

			TAILQ_FOREACH(s, conf->sc_servers, srv_entry) {
				if ((s->srv_conf.flags & SRVFLAG_LOCATION) &&
				    s->srv_conf.id == srv_conf->id &&
				    strcmp(s->srv_conf.location,
				    srv_conf->location) == 0)
					break;
			}
			if (s != NULL) {
				yyerror("location \"%s\" defined twice",
				    srv->srv_conf.location);
				serverconfig_free(srv_conf);
				free(srv);
				YYABORT;
			}

			TAILQ_INSERT_TAIL(conf->sc_servers, srv, srv_entry);

a424 1
		| include
d626 1
a626 1
				yyerror("invalid backlog: %lld", $2);
d634 1
a634 1
				yyerror("invalid socket buffer size: %lld", $3);
d640 1
a640 1
				yyerror("invalid ttl: %lld", $3);
a696 3
			if (!loadcfg)
				break;

d732 1
a732 1
				yyerror("invalid port: %lld", $2);
d743 1
a743 1
				yyerror("invalid timeout: %lld", $1);
d774 1
a774 1
	char		*msg;
d778 3
a780 2
	if (vasprintf(&msg, fmt, ap) == -1)
		fatalx("yyerror vasprintf");
d782 1
a782 2
	logit(LOG_CRIT, "%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
@


1.33
log
@Limit the body size in client requests (eg. POST data) to 1M by default;
add a configuration option to change the limit.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2014/08/06 16:11:34 jsing Exp $	*/
d276 1
a276 1
serveroptsl	: LISTEN ON STRING port optssl {
d293 1
a293 1
			if ($4.op != PF_OP_EQ) {
d300 1
a300 1
			if (host($3, &al, 1, &$4, NULL, -1) <= 0) {
d313 1
a313 1
			if ($5) {
@


1.32
log
@Provide configuration options that allow the SSL certificate, key and
ciphers to be specified for each server.

ok deraadt@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2014/08/06 12:56:58 reyk Exp $	*/
d128 4
a131 4
%token	ACCESS AUTO BACKLOG BUFFER CERTIFICATE CHROOT CIPHERS COMMON COMBINED
%token	CONNECTION DIRECTORY ERR FCGI INDEX IP KEY LISTEN LOCATION LOG MAXIMUM
%token	NO NODELAY ON PORT PREFORK REQUESTS ROOT SACK SERVER SOCKET SSL STYLE
%token	SYSLOG TCP TIMEOUT TYPES
d234 1
d477 3
d800 1
d824 1
@


1.31
log
@Configure the default SSL ciphers as HIGH:!aNULL.

ok deraadt@@ reyk@@
@
text
@d128 4
a131 4
%token	ACCESS AUTO BACKLOG BUFFER CHROOT COMMON COMBINED CONNECTION
%token	DIRECTORY ERR FCGI INDEX IP LISTEN LOCATION LOG MAXIMUM NO NODELAY
%token	ON PORT	PREFORK REQUESTS ROOT SACK SERVER SOCKET SSL STYLE SYSLOG
%token	TCP TIMEOUT TYPES
d236 6
a241 2
			s->srv_conf.ssl_cert_file = HTTPD_SSL_CERT;
			s->srv_conf.ssl_key_file = HTTPD_SSL_KEY;
d328 6
d478 32
d797 1
d799 1
d809 1
@


1.30
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2014/08/06 02:04:42 jsing Exp $	*/
d238 2
@


1.29
log
@Load the SSL public/private keys in the parent process, then provide them
to the privsep process via imsg. This allows the keys to be moved out of
the chroot (now /etc/ssl/server.crt, /etc/ssl/private/server.key).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2014/08/05 18:01:10 reyk Exp $	*/
d310 1
a310 1
		| TCP 			{
d316 1
a316 1
		| CONNECTION 		{
@


1.28
log
@Add configuration options for the most-important connection limits:
max requests (per connection) and timeout.  We don't want to add too
many button, and there are good defaults, but these ones are kind of
mandatory.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2014/08/05 17:03:21 reyk Exp $	*/
d236 2
d253 5
@


1.27
log
@Bring back the tcp/ip configuration options.  This code was already
there and is from relayd.  We can decide later which options should
be added or removed, but it shouldn't do any harm.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2014/08/05 16:46:35 reyk Exp $	*/
d129 3
a131 2
%token	DIRECTORY ERR FCGI INDEX IP LISTEN LOCATION LOG NO NODELAY ON PORT
%token	PREFORK ROOT SACK SERVER SOCKET SSL STYLE SYSLOG TCP TYPES
d137 1
d233 1
d308 2
a309 2
		} tcpflags
		| TCP 			{
d311 1
a311 1
				yyerror("tcp flags inside location");
d314 1
a314 1
		} '{' tcpflags_l '}'
d442 17
d553 4
d685 11
d759 1
d765 1
d774 1
@


1.26
log
@Add srv_conf helper variable to make the code more readable.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2014/08/05 15:36:59 reyk Exp $	*/
d128 3
a130 3
%token	ACCESS AUTO CHROOT COMMON COMBINED CONNECTION DIRECTORY ERR FCGI
%token	INDEX LISTEN LOCATION LOG NO ON PORT PREFORK ROOT SERVER SOCKET SSL
%token	STYLE SYSLOG TYPES
d300 12
d533 47
d709 2
d720 1
d725 1
d730 1
d736 1
@


1.25
log
@Improve logging to allow per- server/location log files.  The log
files can also be owned by root now: they're opened by the parent and
send to the logger process with fd passing.  This also works with reload.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2014/08/05 09:24:21 jsg Exp $	*/
d96 1
d240 1
d251 1
d382 1
d387 1
d393 2
a394 2
			srv->srv_conf.flags &= ~SRVFLAG_FCGI;
			srv->srv_conf.flags |= SRVFLAG_NO_FCGI;
d397 2
a398 2
			srv->srv_conf.flags &= ~SRVFLAG_NO_FCGI;
			srv->srv_conf.flags |= SRVFLAG_FCGI;
d401 2
a402 2
			srv->srv_conf.flags &= ~SRVFLAG_NO_FCGI;
			srv->srv_conf.flags |= SRVFLAG_FCGI;
d405 2
a406 2
			srv->srv_conf.flags &= ~SRVFLAG_NO_FCGI;
			srv->srv_conf.flags |= SRVFLAG_FCGI;
d415 3
a417 3
			if (strlcpy(srv->srv_conf.socket, $2,
			    sizeof(srv->srv_conf.socket)) >=
			    sizeof(srv->srv_conf.socket)) {
d423 1
a423 1
			srv->srv_conf.flags |= SRVFLAG_SOCKET;
d432 3
a434 3
			if (strlcpy(srv->srv_conf.index, $2,
			    sizeof(srv->srv_conf.index)) >=
			    sizeof(srv->srv_conf.index)) {
d439 2
a440 2
			srv->srv_conf.flags &= ~SRVFLAG_NO_INDEX;
			srv->srv_conf.flags |= SRVFLAG_INDEX;
d444 2
a445 2
			srv->srv_conf.flags &= ~SRVFLAG_INDEX;
			srv->srv_conf.flags |= SRVFLAG_NO_INDEX;
d448 2
a449 2
			srv->srv_conf.flags &= ~SRVFLAG_NO_AUTO_INDEX;
			srv->srv_conf.flags |= SRVFLAG_AUTO_INDEX;
d452 2
a453 2
			srv->srv_conf.flags &= ~SRVFLAG_AUTO_INDEX;
			srv->srv_conf.flags |= SRVFLAG_NO_AUTO_INDEX;
d461 2
a462 2
			srv->srv_conf.flags &= ~SRVFLAG_LOG;
			srv->srv_conf.flags |= SRVFLAG_NO_LOG;
d473 2
a474 2
			srv->srv_conf.flags &= ~SRVFLAG_NO_SYSLOG;
			srv->srv_conf.flags |= SRVFLAG_SYSLOG;
d477 2
a478 2
			srv->srv_conf.flags &= ~SRVFLAG_SYSLOG;
			srv->srv_conf.flags |= SRVFLAG_NO_SYSLOG;
d481 3
a483 3
			if (strlcpy(srv->srv_conf.accesslog, $2,
			    sizeof(srv->srv_conf.accesslog)) >=
			    sizeof(srv->srv_conf.accesslog)) {
d489 1
a489 1
			srv->srv_conf.flags |= SRVFLAG_ACCESS_LOG;
d492 3
a494 3
			if (strlcpy(srv->srv_conf.errorlog, $2,
			    sizeof(srv->srv_conf.errorlog)) >=
			    sizeof(srv->srv_conf.errorlog)) {
d500 1
a500 1
			srv->srv_conf.flags |= SRVFLAG_ERROR_LOG;
d505 3
a507 3
			srv->srv_conf.flags &= ~SRVFLAG_NO_LOG;
			srv->srv_conf.flags |= SRVFLAG_LOG;
			srv->srv_conf.logformat = LOG_FORMAT_COMMON;
d510 3
a512 3
			srv->srv_conf.flags &= ~SRVFLAG_NO_LOG;
			srv->srv_conf.flags |= SRVFLAG_LOG;
			srv->srv_conf.logformat = LOG_FORMAT_COMBINED;
d515 3
a517 3
			srv->srv_conf.flags &= ~SRVFLAG_NO_LOG;
			srv->srv_conf.flags |= SRVFLAG_LOG;
			srv->srv_conf.logformat = LOG_FORMAT_CONNECTION;
@


1.24
log
@add a config option to specify the chroot directory
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2014/08/04 17:38:12 reyk Exp $	*/
d127 3
a129 3
%token	AUTO CHROOT COMMON COMBINED CONNECTION DIRECTORY FCGI FILE INDEX LISTEN
%token	LOCATION LOG NO ON PORT PREFORK ROOT SERVER SOCKET SSL STYLE SYSLOG
%token	TYPES
d224 4
d475 22
d643 1
d650 1
a651 1
		{ "file",		FILE },
@


1.23
log
@Proxy commit for jsing@@:
"Add TLS/SSL support to httpd, based on the recent ressl commits."

From jsing@@
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2014/08/04 16:07:59 reyk Exp $	*/
d127 1
a127 1
%token	AUTO COMMON COMBINED CONNECTION DIRECTORY FCGI FILE INDEX LISTEN
d185 3
d618 1
@


1.22
log
@Change grammar from "log [style]" to "log style [style]".
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2014/08/04 15:49:28 reyk Exp $	*/
d128 2
a129 1
%token	LOCATION LOG NO ON PORT PREFORK ROOT SERVER SOCKET STYLE SYSLOG TYPES
d134 1
d171 4
d249 1
a249 1
serveroptsl	: LISTEN ON STRING port {
d285 4
d633 1
@


1.21
log
@Add initial support for log files in /var/www/logs/.  Logging with
syslog is still supported but disabled by default.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2014/08/04 11:09:25 reyk Exp $	*/
d128 1
a128 1
%token	LOCATION LOG NO ON PORT PREFORK ROOT SERVER SOCKET SYSLOG TYPES
d448 13
a460 1
logflags	: COMMON		{
a474 8
		| SYSLOG		{
			srv->srv_conf.flags &= ~SRVFLAG_NO_SYSLOG;
			srv->srv_conf.flags |= SRVFLAG_SYSLOG;
		}
		| NO SYSLOG		{
			srv->srv_conf.flags &= ~SRVFLAG_SYSLOG;
			srv->srv_conf.flags |= SRVFLAG_NO_SYSLOG;
		}
d623 1
@


1.20
log
@httpd doesn't support SSL/TLS yet, remove the remaining bits.
The secrect plan is to add it later using the ressl wrapper library.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2014/08/03 20:43:03 reyk Exp $	*/
d127 2
a128 2
%token	AUTO COMMON COMBINED CONNECTION DIRECTORY FCGI INDEX LISTEN LOCATION
%token	LOG NO ON PORT PREFORK ROOT SERVER SOCKET TYPES
d435 14
a448 1
logformat	: LOG COMMON		{
d453 1
a453 1
		| LOG COMBINED		{
d458 1
a458 1
		| LOG CONNECTION	{
d463 7
a469 3
		| NO LOG		{
			srv->srv_conf.flags &= ~SRVFLAG_LOG;
			srv->srv_conf.flags |= SRVFLAG_NO_LOG;
d606 1
d619 1
@


1.19
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2014/08/03 11:16:10 reyk Exp $	*/
a54 2

#include <openssl/ssl.h>
@


1.18
log
@Split fastcgi socket path and document root option and add the
SCRIPT_FILENAME CGI param with a prepended root.  This fixes php-fpm
that expects SCRIPT_FILENAME and also works with slowcgi if you
configure the root correctly.  For example, if SCRIPT_NAME and
REQUEST_URI are /php/index.php, root is /htdocs, SCRIPT_FILENAME will
be /htdocs/php/index.php.  As tested and discussed with florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2014/08/03 10:26:43 reyk Exp $	*/
d131 1
a131 1
%token	ERROR INCLUDE 
d376 1
a376 1
		| FCGI				{
d380 1
a380 1
		| FCGI 				{
d384 1
a384 1
		| FCGI				{
d430 1
a430 1
		}	
d437 1
a437 1
logformat	: LOG COMMON {
d442 1
a442 1
		| LOG COMBINED {
d447 1
a447 1
		| LOG CONNECTION {
d452 1
a452 1
		| NO LOG {
d465 1
a465 1
mediaoptsl	: STRING '/' STRING 			{
d1029 1
a1029 1
		}		
@


1.17
log
@Add another log mode "connection" for a relayd(8)-style log entry after
each connection, not every request.  The code was already there and enabled
on debug, I just turned it into an alternative log format.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2014/08/02 21:21:47 doug Exp $	*/
d213 2
a214 2
			strlcpy(s->srv_conf.path, HTTPD_DOCROOT,
			    sizeof(s->srv_conf.path));
d283 3
a285 8
			if (srv->srv_conf.flags & SRVFLAG_FCGI) {
				yyerror("root conflicts with fastcgi");
				free($2);
				YYERROR;
			}
			if (strlcpy(srv->srv_conf.path, $2,
			    sizeof(srv->srv_conf.path)) >=
			    sizeof(srv->srv_conf.path)) {
d291 1
a291 1
			srv->srv_conf.flags |= SRVFLAG_PATH;
d395 3
a397 3
			if (strlcpy(srv->srv_conf.path, $2,
			    sizeof(srv->srv_conf.path)) >=
			    sizeof(srv->srv_conf.path)) {
d403 1
a403 1
			srv->srv_conf.flags |= SRVFLAG_PATH;
@


1.16
log
@Locations now inherit access log settings from the server.

Add log to the server flags.

input/"Looks ok" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2014/08/01 21:59:56 reyk Exp $	*/
d129 3
a131 3
%token	AUTO DIRECTORY FCGI INDEX LISTEN LOCATION LOG NO ON PORT
%token	PREFORK ROOT SERVER SOCKET TYPES
%token	ERROR INCLUDE COMMON COMBINED
d452 5
d593 1
@


1.15
log
@remove the global "log updates/all" option that came from relayd.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2014/08/01 21:51:02 doug Exp $	*/
d219 2
d443 2
d448 2
d453 2
a454 1
			srv->srv_conf.logformat = LOG_FORMAT_NONE;
@


1.14
log
@Add common and combined access logging to httpd.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2014/07/31 14:18:38 reyk Exp $	*/
d129 2
a130 2
%token	ALL AUTO DIRECTORY FCGI INDEX LISTEN LOCATION LOG NO ON PORT
%token	PREFORK ROOT SERVER SOCKET TYPES UPDATES VERBOSE
a133 1
%type	<v.number>	loglevel
d171 1
a171 6
main		: LOG loglevel		{
			if (loadcfg)
				break;
			conf->sc_opts |= $2;
		}
		| PREFORK NUMBER	{
a531 4
loglevel	: UPDATES		{ $$ = HTTPD_OPT_LOGUPDATE; }
		| ALL			{ $$ = HTTPD_OPT_LOGALL; }
		;

a577 1
		{ "all",		ALL },
d595 1
a595 2
		{ "types",		TYPES },
		{ "updates",		UPDATES }
@


1.13
log
@Allow to specify a non-default fastcgi socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2014/07/31 13:28:15 reyk Exp $	*/
d131 1
a131 1
%token	ERROR INCLUDE
d304 1
d446 11
d590 2
@


1.12
log
@Rename the "docroot" variable to "path" because it will be used for
either files or the fastcgi socket (and there's no need to use a union yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2014/07/31 09:34:57 reyk Exp $	*/
d130 1
a130 1
%token	PREFORK ROOT SERVER TYPES UPDATES VERBOSE
d287 5
d304 1
a304 8
		| NO FCGI		{
			srv->srv_conf.flags &= ~SRVFLAG_FCGI;
			srv->srv_conf.flags |= SRVFLAG_NO_FCGI;
		}
		| FCGI			{
			srv->srv_conf.flags &= ~SRVFLAG_NO_FCGI;
			srv->srv_conf.flags |= SRVFLAG_FCGI;
		}
d380 35
d591 1
@


1.11
log
@Add a configuration variable "fastcgi" to enable it per server or location.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2014/07/30 13:49:48 reyk Exp $	*/
d219 2
a220 2
			strlcpy(s->srv_conf.docroot, HTTPD_DOCROOT,
			    sizeof(s->srv_conf.docroot));
d287 3
a289 3
			if (strlcpy(srv->srv_conf.docroot, $2,
			    sizeof(srv->srv_conf.docroot)) >=
			    sizeof(srv->srv_conf.docroot)) {
d295 1
a295 1
			srv->srv_conf.flags |= SRVFLAG_DOCROOT;
@


1.10
log
@Make "location" work with name-based virtual servers.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2014/07/30 10:05:14 reyk Exp $	*/
d129 2
a130 2
%token	ALL AUTO DIRECTORY INDEX LISTEN LOCATION LOG NO ON PORT PREFORK ROOT
%token	SERVER TYPES UPDATES VERBOSE
d299 8
d546 1
@


1.9
log
@Add "location" keyword to specify path-specific configuration in
servers, for example auto index for a sub-directory only.  Internally,
a "location" is just a special type of a "virtual" server.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2014/07/29 16:17:28 reyk Exp $	*/
d236 5
d302 6
d351 2
a352 1
			s->srv_conf.id = ++last_server_id;
d354 4
@


1.8
log
@Add extended directory index options: "[no] index" and "[no] auto index".
The option "directory auto index" implements basic directory listing
and is turned off by default.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2014/07/25 17:04:47 reyk Exp $	*/
d97 1
a97 1
static struct server	*srv = NULL;
d129 2
a130 2
%token	ALL AUTO DIRECTORY INDEX LISTEN LOG NO ON PORT PREFORK ROOT SERVER
%token	TYPES UPDATES VERBOSE
d232 1
a232 1
		} '{' optnl serveropts_l '}'	{
d235 2
d249 6
d290 1
d294 62
d525 1
@


1.7
log
@Add a single line to fix the address matching of multiple server blocks with
non-virtual hosts.  I had this line in a previous diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2014/07/25 16:23:19 reyk Exp $	*/
d129 3
a131 2
%token	ALL PORT LISTEN PREFORK ROOT SERVER ERROR LOG VERBOSE ON TYPES
%token	UPDATES INCLUDE
d221 2
d283 32
d402 5
d449 2
d452 1
d455 1
@


1.6
log
@Add support for "virtual hosts" aka. server blocks aka. multiple
servers with the same or "overlapping" IP address but a different name.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2014/07/25 15:47:11 reyk Exp $	*/
d267 1
@


1.5
log
@Add and document 'root' configuration option for the docroot.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2014/07/25 12:42:05 reyk Exp $	*/
d940 4
a943 1

d969 5
a973 1

d1026 1
d1089 1
@


1.4
log
@Move the docroot into the server block.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2014/07/23 22:02:02 reyk Exp $	*/
d129 1
a129 1
%token	ALL PORT LISTEN PREFORK SERVER ERROR INCLUDE LOG VERBOSE ON TYPES
d269 10
d414 1
@


1.3
log
@The media_encoding is not used in parse.y but stack garbage could lead
to a double free; set it to NULL.

This should fix a problem that was found by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2014/07/13 14:17:37 reyk Exp $	*/
d218 2
@


1.2
log
@Add support for media types (aka. MIME types): the types section is
compatible to nginx' mime.types file which can be included directly.
If not present, use a few built-in defaults for html, css, txt, jpeg,
gif, png, and js.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2014/07/12 23:34:54 reyk Exp $	*/
d823 1
@


1.1
log
@Add httpd(8), an attempt to turn the relayd(8) codebase into a simple
web server.  It is not finished yet and I just started it today, but
the goal is to provide an HTTP server that a) provides minimal
features, b) serves static files, c) provides FastCGI support, and d)
follows common coding practices of OpenBSD.

It will neither support plugins, nor custom memory allocators, EBCDIC
support, PCRE or any other things that can be found elsewhere.
httpd(8) is not intended to provide a fully-featured replacement for
nginx(8) or the Apache, but it will provide enough functionality that
is needed in the OpenBSD base system.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.187 2014/07/11 17:35:16 reyk Exp $	*/
d99 1
d129 1
a129 1
%token	ALL PORT LISTEN PREFORK SERVER ERROR INCLUDE LOG VERBOSE ON
d144 1
d269 45
a353 5
comma		: ','
		| nl
		| /* empty */
		;

d403 1
d631 1
a631 1
	x != ',' && x != '/'))
d768 3
d811 19
@

