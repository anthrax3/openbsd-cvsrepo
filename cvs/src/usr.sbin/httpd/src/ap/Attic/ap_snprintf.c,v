head	1.18;
access;
symbols
	OPENBSD_5_5:1.17.0.26
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.22
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.20
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.18
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.16
	OPENBSD_5_0:1.17.0.14
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.12
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.10
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.6
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.4
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.4
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.3
	apache_1_3_27:1.1.1.3
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2014.04.22.14.47.26;	author henning;	state dead;
branches;
next	1.17;

1.17
date	2008.05.25.11.46.27;	author mbalmer;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.03.18.01.52;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.28.21.11.22;	author niallo;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.28.21.03.33;	author niallo;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.06.13.14.09;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.02.19.42.46;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.21.13.11.35;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.09.11.23.58;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.11.17.22.56;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2002.10.07.20.23.06;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.29.02.08.05;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.12.07.56.49;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.29.10.21.39;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.25.18.29.39;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.06.29.24;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.03.01.01.05.42;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.37;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.37;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.28.31;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.07.19.48.11;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.21.12.53.37;	author henning;	state Exp;
branches;
next	;


desc
@@


1.18
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/* $OpenBSD: ap_snprintf.c,v 1.17 2008/05/25 11:46:27 mbalmer Exp $ */

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/*
 * This code is based on, and used with the permission of, the
 * SIO stdio-replacement strx_* functions by Panos Tsirigotis
 * <panos@@alumni.cs.colorado.edu> for xinetd.
 */

#include "httpd.h"

#include <stdio.h>
#include <ctype.h>
#include <sys/types.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>

typedef enum {
        NO = 0, YES = 1
} boolean_e;

#ifndef FALSE
#define FALSE			0
#endif
#ifndef TRUE
#define TRUE			1
#endif
#define NUL			'\0'
#define WIDE_INT		long

typedef WIDE_INT wide_int;
typedef unsigned WIDE_INT u_wide_int;
typedef intmax_t widest_int;
typedef uintmax_t u_widest_int;
typedef int bool_int;

#define S_NULL			"(null)"
#define S_NULL_LEN		6

#define FLOAT_DIGITS		6
#define EXPONENT_LENGTH		10

/*
 * NUM_BUF_SIZE is the size of the buffer used for arithmetic conversions
 *
 * XXX: this is a magic number; do not decrease it
 */
#define NUM_BUF_SIZE		512

/*
 * cvt.c - IEEE floating point formatting routines for FreeBSD
 * from GNU libc-4.6.27.  Modified to be thread safe.
 */

/*
 *    ap_ecvt converts to decimal
 *      the number of digits is specified by ndigit
 *      decpt is set to the position of the decimal point
 *      sign is set to 0 for positive, 1 for negative
 */

#define	NDIG	80

/* buf must have at least NDIG bytes */
static char *
ap_cvt(double arg, int ndigits, int *decpt, int *sign, int eflag, char *buf)
{
	int r2;
	double fi, fj;
	char *p, *p1;

	if (ndigits >= NDIG - 1)
		ndigits = NDIG - 2;
	r2 = 0;
	*sign = 0;
	p = &buf[0];
	if (arg < 0) {
		*sign = 1;
		arg = -arg;
	}
	arg = modf(arg, &fi);
	p1 = &buf[NDIG];
	/*
	* Do integer part
	*/
	if (fi != 0) {
		p1 = &buf[NDIG];
		while (p1 > &buf[0] && fi != 0) {
			fj = modf(fi / 10, &fi);
			*--p1 = (int) ((fj + .03) * 10) + '0';
			r2++;
		}
		while (p1 < &buf[NDIG])
			*p++ = *p1++;
	}
	else if (arg > 0) {
		while ((fj = arg * 10) < 1) {
			arg = fj;
			r2--;
		}
	}
	p1 = &buf[ndigits];
	if (eflag == 0)
		p1 += r2;
	*decpt = r2;
	if (p1 < &buf[0]) {
		buf[0] = '\0';
		return (buf);
	}
	while (p <= p1 && p < &buf[NDIG]) {
		arg *= 10;
		arg = modf(arg, &fj);
		*p++ = (int) fj + '0';
	}
	if (p1 >= &buf[NDIG]) {
		buf[NDIG - 1] = '\0';
		return (buf);
	}
	p = p1;
	*p1 += 5;
	while (*p1 > '9') {
		*p1 = '0';
		if (p1 > buf)
			++ * --p1;
		else {
			*p1 = '1';
			(*decpt)++;
			if (eflag == 0) {
				if (p > buf)
					*p = '0';
				p++;
			}
		}
	}
	*p = '\0';
	return (buf);
	}

	static char
	*ap_ecvt(double arg, int ndigits, int *decpt, int *sign, char *buf)
	{
	return (ap_cvt(arg, ndigits, decpt, sign, 1, buf));
	}

	static char *
	ap_fcvt(double arg, int ndigits, int *decpt, int *sign, char *buf)
	{
	return (ap_cvt(arg, ndigits, decpt, sign, 0, buf));
}

/*
 * ap_gcvt  - Floating output conversion to
 * minimal length string
 */

static char
*ap_gcvt(double number, int ndigit, char *buf, boolean_e altform)
{
	int sign, decpt;
	char *p1, *p2;
	int i;
	char buf1[NDIG];

	p1 = ap_ecvt(number, ndigit, &decpt, &sign, buf1);
	p2 = buf;
	if (sign)
		*p2++ = '-';
	for (i = ndigit - 1; i > 0 && p1[i] == '0'; i--)
		ndigit--;
	if ((decpt >= 0 && decpt - ndigit > 4)
	    || (decpt < 0 && decpt < -3)) {             /* use E-style */
		decpt--;
		*p2++ = *p1++;
		*p2++ = '.';
		for (i = 1; i < ndigit; i++)
		    *p2++ = *p1++;
		*p2++ = 'e';
		if (decpt < 0) {
		    decpt = -decpt;
		    *p2++ = '-';
		}
		else
		    *p2++ = '+';
		if (decpt / 100 > 0)
		    *p2++ = decpt / 100 + '0';
		if (decpt / 10 > 0)
		    *p2++ = (decpt % 100) / 10 + '0';
		*p2++ = decpt % 10 + '0';
	}
	else {
		if (decpt <= 0) {
			if (*p1 != '0')
				*p2++ = '.';
			while (decpt < 0) {
				decpt++;
				*p2++ = '0';
			}
		}
		for (i = 1; i <= ndigit; i++) {
			*p2++ = *p1++;
			if (i == decpt)
				*p2++ = '.';
		}
		if (ndigit < decpt) {
			while (ndigit++ < decpt)
				*p2++ = '0';
			*p2++ = '.';
		}
	}
	if (p2[-1] == '.' && !altform)
		p2--;
	*p2 = '\0';
	return (buf);
}

/*
 * The INS_CHAR macro inserts a character in the buffer and writes
 * the buffer back to disk if necessary
 * It uses the char pointers sp and bep:
 *      sp points to the next available character in the buffer
 *      bep points to the end-of-buffer+1
 * While using this macro, note that the nextb pointer is NOT updated.
 *
 * NOTE: Evaluation of the c argument should not have any side-effects
 */
#define INS_CHAR(c, sp, bep, cc)                                \
                {                                               \
                if (sp >= bep) {                                \
                        vbuff->curpos = sp;                     \
                        if (flush_func(vbuff))                  \
                                return -1;                      \
                        sp = vbuff->curpos;                     \
                        bep = vbuff->endpos;                    \
                }                                               \
                *sp++ = (c);                                    \
                cc++;                                           \
        }

#define NUM( c )                        ( c - '0' )

#define STR_TO_DEC( str, num )          \
    num = NUM( *str++ ) ;               \
    while ( ap_isdigit( *str ) )        \
    {                                   \
        num *= 10 ;                     \
        num += NUM( *str++ ) ;          \
    }

/*
 * This macro does zero padding so that the precision
 * requirement is satisfied. The padding is done by
 * adding '0's to the left of the string that is going
 * to be printed. We don't allow precision to be large
 * enough that we continue past the start of s.
 *
 * NOTE: this makes use of the magic info that s is
 * always based on num_buf with a size of NUM_BUF_SIZE.
 */
#define FIX_PRECISION( adjust, precision, s, s_len )    \
    if ( adjust ) {                                     \
        int p = precision < NUM_BUF_SIZE - 1 ? precision : NUM_BUF_SIZE - 1; \
        while ( s_len < p )                             \
        {                                               \
            *--s = '0' ;                                \
            s_len++ ;                                   \
        }                                               \
    }

/*
 * Macro that does padding. The padding is done by printing
 * the character ch.
 */
#define PAD( width, len, ch )   do              \
        {                                       \
            INS_CHAR( ch, sp, bep, cc ) ;       \
            width-- ;                           \
        }                                       \
        while ( width > len )

/*
 * Prefix the character ch to the string str
 * Increase length
 * Set the has_prefix flag
 */
#define PREFIX( str, length, ch )	 *--str = ch ; length++ ; has_prefix = YES


/*
 * Convert num to its decimal format.
 * Return value:
 *   - a pointer to a string containing the number (no sign)
 *   - len contains the length of the string
 *   - is_negative is set to TRUE or FALSE depending on the sign
 *     of the number (always set to FALSE if is_unsigned is TRUE)
 *
 * The caller provides a buffer for the string: that is the buf_end argument
 * which is a pointer to the END of the buffer + 1 (i.e. if the buffer
 * is declared as buf[ 100 ], buf_end should be &buf[ 100 ])
 *
 * Note: we have 2 versions. One is used when we need to use quads
 * (conv_10_quad), the other when we don't (conv_10). We're assuming the
 * latter is faster.
 */
static char *
conv_10(wide_int num, bool_int is_unsigned,
    bool_int *is_negative, char *buf_end, int *len)
{
	char *p = buf_end;
	u_wide_int magnitude;

	if (is_unsigned) {
		magnitude = (u_wide_int) num;
		*is_negative = FALSE;
	}
	else {
		*is_negative = (num < 0);

		/*
		 * On a 2's complement machine, negating the most negative
		 * integer results in a number that cannot be represented as
		 * a signed integer.
		 * Here is what we do to obtain the number's magnitude:
		 *      a. add 1 to the number
		 *      b. negate it (becomes positive)
		 *      c. convert it to unsigned
		 *      d. add 1
		 */
		if (*is_negative) {
			wide_int t = num + 1;

			magnitude = ((u_wide_int) -t) + 1;
		}
		else
			magnitude = (u_wide_int) num;
	}

	/*
	* We use a do-while loop so that we write at least 1 digit 
	*/
	do {
		u_wide_int new_magnitude = magnitude / 10;

		*--p = (char) (magnitude - new_magnitude * 10 + '0');
		magnitude = new_magnitude;
	}
	while (magnitude);

	*len = buf_end - p;
	return (p);
}

static char *
conv_10_quad(widest_int num, bool_int is_unsigned,
    bool_int *is_negative, char *buf_end, int *len)
{
	char *p = buf_end;
	u_widest_int magnitude;

	/*
	* We see if we can use the faster non-quad version by checking the
	* number against the largest long value it can be. If <=, we
	* punt to the quicker version.
	*/
	if ((num <= ULONG_MAX && is_unsigned) ||
	    (num <= LONG_MAX && !is_unsigned))
		return(conv_10( (wide_int)num, is_unsigned, is_negative,
		    buf_end, len));

	if (is_unsigned) {
		magnitude = (u_widest_int) num;
		*is_negative = FALSE;
	}
	else {
		*is_negative = (num < 0);

		/*
		 * On a 2's complement machine, negating the most negative
		 * integer * results in a number that cannot be represented as
		 * a signed integer.
		 * Here is what we do to obtain the number's magnitude:
		 *      a. add 1 to the number
		 *      b. negate it (becomes positive)
		 *      c. convert it to unsigned
		 *      d. add 1
		 */
		if (*is_negative) {
			widest_int t = num + 1;

			magnitude = ((u_widest_int) -t) + 1;
		}
		else
			magnitude = (u_widest_int) num;
	}

	/*
	* We use a do-while loop so that we write at least 1 digit 
	*/
	do {
		u_widest_int new_magnitude = magnitude / 10;

		*--p = (char) (magnitude - new_magnitude * 10 + '0');
		magnitude = new_magnitude;
	}
	while (magnitude);

	*len = buf_end - p;
	return (p);
}



static char*
conv_in_addr(struct in_addr *ia, char *buf_end, int *len)
{
	unsigned addr = ntohl(ia->s_addr);
	char *p = buf_end;
	bool_int is_negative;
	int sub_len;

	p = conv_10((addr & 0x000000FF)      , TRUE, &is_negative, p, &sub_len);
	*--p = '.';
	p = conv_10((addr & 0x0000FF00) >>  8, TRUE, &is_negative, p, &sub_len);
	*--p = '.';
	p = conv_10((addr & 0x00FF0000) >> 16, TRUE, &is_negative, p, &sub_len);
	*--p = '.';
	p = conv_10((addr & 0xFF000000) >> 24, TRUE, &is_negative, p, &sub_len);

	*len = buf_end - p;
	return (p);
}



static char *
conv_sockaddr_in(struct sockaddr_in *si, char *buf_end, int *len)
{
	char *p = buf_end;
	bool_int is_negative;
	int sub_len;

	p = conv_10(ntohs(si->sin_port), TRUE, &is_negative, p, &sub_len);
	*--p = ':';
	p = conv_in_addr(&si->sin_addr, p, &sub_len);

	*len = buf_end - p;
	return (p);
}



/*
 * Convert a floating point number to a string formats 'f', 'e' or 'E'.
 * The result is placed in buf, and len denotes the length of the string
 * The sign is returned in the is_negative argument (and is not placed
 * in buf).
 */
static char *
conv_fp(char format, double num, boolean_e add_dp,
    int precision, bool_int *is_negative, char *buf, int *len, int buflen)
{
	char *s = buf;
	char *p;
	int decimal_point;
	char buf1[NDIG];

	if (format == 'f')
		p = ap_fcvt(num, precision, &decimal_point, is_negative, buf1);
	else                    /* either e or E format */
		p = ap_ecvt(num, precision + 1, &decimal_point, is_negative,
		    buf1);
	/*
	* Check for Infinity and NaN
	*/
	if (ap_isalpha(*p)) {
		*len = strlcpy(buf, p, buflen);
		/* we really need the wanted len here */
		*is_negative = FALSE;
		return (buf);
	}

	if (format == 'f') {
		if (decimal_point <= 0) {
			*s++ = '0';
			if (precision > 0) {
				*s++ = '.';
				while (decimal_point++ < 0)
					*s++ = '0';
			}
			else if (add_dp)
				*s++ = '.';
		}
		else {
			while (decimal_point-- > 0)
				*s++ = *p++;
			if (precision > 0 || add_dp)
				*s++ = '.';
		}
	}
	else {
		*s++ = *p++;
		if (precision > 0 || add_dp)
			*s++ = '.';
	}

	/*
	* copy the rest of p, the NUL is NOT copied
	*/
	while (*p)
		*s++ = *p++;

	if (format != 'f') {
		char temp[EXPONENT_LENGTH];     /* for exponent conversion */
		int t_len;
		bool_int exponent_is_negative;

		*s++ = format;          /* either e or E */
		decimal_point--;
		if (decimal_point != 0) {
			p = conv_10((wide_int) decimal_point, FALSE,
			    &exponent_is_negative, &temp[EXPONENT_LENGTH],
			    &t_len);
			*s++ = exponent_is_negative ? '-' : '+';

			/*
			* Make sure the exponent has at least 2 digits
			*/
			if (t_len == 1)
				*s++ = '0';
			while (t_len--)
				*s++ = *p++;
		}
		else {
			*s++ = '+';
			*s++ = '0';
			*s++ = '0';
		}
	}
	*len = s - buf;
	return (buf);
}


/*
 * Convert num to a base X number where X is a power of 2. nbits determines X.
 * For example, if nbits is 3, we do base 8 conversion
 * Return value:
 *      a pointer to a string containing the number
 *
 * The caller provides a buffer for the string: that is the buf_end argument
 * which is a pointer to the END of the buffer + 1 (i.e. if the buffer
 * is declared as buf[ 100 ], buf_end should be &buf[ 100 ])
 *
 * As with conv_10, we have a faster version which is used when
 * the number isn't quad size.
 */
static char *
conv_p2(u_wide_int num, int nbits, char format, char *buf_end,
    int *len)
{
	int mask = (1 << nbits) - 1;
	char *p = buf_end;
	static const char low_digits[] = "0123456789abcdef";
	static const char upper_digits[] = "0123456789ABCDEF";
	const char *digits = (format == 'X') ? upper_digits :
	    low_digits;

	do {
		*--p = digits[num & mask];
		num >>= nbits;
	}
	while (num);

	*len = buf_end - p;
	return (p);
}

static char *
conv_p2_quad(u_widest_int num, int nbits, char format,
    char *buf_end, int *len)
{
	int mask = (1 << nbits) - 1;
	char *p = buf_end;
	static const char low_digits[] = "0123456789abcdef";
	static const char upper_digits[] = "0123456789ABCDEF";
	const char *digits = (format == 'X') ? upper_digits :
	    low_digits;

	if (num <= ULONG_MAX)
		return(conv_p2( (u_wide_int)num, nbits, format, buf_end, len));

	do {
		*--p = digits[num & mask];
		num >>= nbits;
	}
	while (num);

	*len = buf_end - p;
	return (p);
}


/*
 * Do format conversion placing the output in buffer
 */
API_EXPORT(int)
ap_vformatter(int (*flush_func)(ap_vformatter_buff *),
    ap_vformatter_buff *vbuff, const char *fmt, va_list ap)
{
	char *sp;
	char *bep;
	int cc = 0;
	int i;

	char *s = NULL;
	char *q;
	int s_len;

	int min_width = 0;
	int precision = 0;
	enum {
	LEFT, RIGHT
	} adjust;
	char pad_char;
	char prefix_char;

	double fp_num;
	widest_int i_quad = (widest_int) 0;
	u_widest_int ui_quad;
	wide_int i_num = (wide_int) 0;
	u_wide_int ui_num;

	char num_buf[NUM_BUF_SIZE];
	char char_buf[2];		/* for printing %% and %<unknown> */

	enum var_type_enum {
		IS_QUAD, IS_LONG, IS_SHORT, IS_INT
	};
	enum var_type_enum var_type = IS_INT;

	/*
	* Flag variables
	*/
	boolean_e alternate_form;
	boolean_e print_sign;
	boolean_e print_blank;
	boolean_e adjust_precision;
	boolean_e adjust_width;
	bool_int is_negative;

	sp = vbuff->curpos;
	bep = vbuff->endpos;

	while (*fmt) {
		if (*fmt != '%') {
			INS_CHAR(*fmt, sp, bep, cc);
			}
		else {
			/*
			* Default variable settings
			*/
			adjust = RIGHT;
			alternate_form = print_sign = print_blank = NO;
			pad_char = ' ';
			prefix_char = NUL;

			fmt++;

			/*
			* Try to avoid checking for flags, width or precision
			*/
			if (!ap_islower(*fmt)) {
				/*
				 * Recognize flags: -, #, BLANK, +
				 */
				for (;; fmt++) {
					if (*fmt == '-')
						adjust = LEFT;
					else if (*fmt == '+')
						print_sign = YES;
					else if (*fmt == '#')
						alternate_form = YES;
					else if (*fmt == ' ')
						print_blank = YES;
					else if (*fmt == '0')
						pad_char = '0';
					else
						break;
				}

				/*
				 * Check if a width was specified
				 */
				if (ap_isdigit(*fmt)) {
					STR_TO_DEC(fmt, min_width);
					adjust_width = YES;
				}
				else if (*fmt == '*') {
					min_width = va_arg(ap, int);
					fmt++;
					adjust_width = YES;
					if (min_width < 0) {
						adjust = LEFT;
						min_width = -min_width;
					}
				}
				else
					adjust_width = NO;

				/*
				 * Check if a precision was specified
				 */
				if (*fmt == '.') {
					adjust_precision = YES;
					fmt++;
					if (ap_isdigit(*fmt)) {
						STR_TO_DEC(fmt, precision);
					}
					else if (*fmt == '*') {
						precision = va_arg(ap, int);
						fmt++;
						if (precision < 0)
							precision = 0;
					}
					else
						precision = 0;
				}
				else
					adjust_precision = NO;
			}
			else
				adjust_precision = adjust_width = NO;

			/*
			* Modifier check
			*/
			if (*fmt == 'q') {
				var_type = IS_QUAD;
				fmt++;
			}
			else if (*fmt == 'l') {
				var_type = IS_LONG;
				fmt++;
			}
			else if (*fmt == 'h') {
				var_type = IS_SHORT;
				fmt++;
			}
			else {
				var_type = IS_INT;
			}

			/*
			* Argument extraction and printing.
			* First we determine the argument type.
			* Then, we convert the argument to a string.
			* On exit from the switch, s points to the string that
			* must be printed, s_len has the length of the string
			* The precision requirements, if any, are reflected in
			* s_len.
			*
			* NOTE: pad_char may be set to '0' because of the 0
			* flag.
			* It is reset to ' ' by non-numeric formats
			*/
			switch (*fmt) {
			case 'u':
				if (var_type == IS_QUAD) {
					i_quad = va_arg(ap, u_widest_int);
					s = conv_10_quad(i_quad, 1,
					    &is_negative,
					    &num_buf[NUM_BUF_SIZE], &s_len);
				}
				else {
					if (var_type == IS_LONG)
						i_num = (wide_int) va_arg(ap,
						    u_wide_int);
					else if (var_type == IS_SHORT)
						i_num = (wide_int)
						    (unsigned short) va_arg(ap,
						    unsigned int);
					else
						i_num = (wide_int) va_arg(ap,
						    unsigned int);
					s = conv_10(i_num, 1, &is_negative,
					    &num_buf[NUM_BUF_SIZE], &s_len);
				}
				FIX_PRECISION(adjust_precision, precision, s,
				    s_len);
				break;

			case 'd':
			case 'i':
				if (var_type == IS_QUAD) {
					i_quad = va_arg(ap, widest_int);
					s = conv_10_quad(i_quad, 0,
					    &is_negative,
					    &num_buf[NUM_BUF_SIZE], &s_len);
				}
				else {
					if (var_type == IS_LONG)
						i_num = (wide_int) va_arg(ap,
						wide_int);
					else if (var_type == IS_SHORT)
						i_num = (wide_int) (short)
						    va_arg(ap, int);
					else
						i_num = (wide_int) va_arg(ap,
						    int);
					s = conv_10(i_num, 0, &is_negative,
					    &num_buf[NUM_BUF_SIZE], &s_len);
				}
				FIX_PRECISION(adjust_precision, precision, s,
				    s_len);

				if (is_negative)
					prefix_char = '-';
				else if (print_sign)
					prefix_char = '+';
				else if (print_blank)
					prefix_char = ' ';
				break;


			case 'o':
				if (var_type == IS_QUAD) {
					ui_quad = va_arg(ap, u_widest_int);
					s = conv_p2_quad(ui_quad, 3, *fmt,
					    &num_buf[NUM_BUF_SIZE], &s_len);
				}
				else {
					if (var_type == IS_LONG)
						ui_num = (u_wide_int) va_arg(ap,
						    u_wide_int);
					else if (var_type == IS_SHORT)
						ui_num = (u_wide_int)
						    (unsigned short)
						    va_arg(ap, unsigned int);
					else
						ui_num = (u_wide_int) va_arg(ap,
						    unsigned int);
					s = conv_p2(ui_num, 3, *fmt,
					    &num_buf[NUM_BUF_SIZE], &s_len);
				}
				FIX_PRECISION(adjust_precision, precision, s,
				    s_len);
				if (alternate_form && *s != '0') {
					*--s = '0';
					s_len++;
				}
				break;


			case 'x':
			case 'X':
				if (var_type == IS_QUAD) {
					ui_quad = va_arg(ap, u_widest_int);
					s = conv_p2_quad(ui_quad, 4, *fmt,
					    &num_buf[NUM_BUF_SIZE], &s_len);
				}
				else {
					if (var_type == IS_LONG)
						ui_num = (u_wide_int) va_arg(ap,
						    u_wide_int);
					else if (var_type == IS_SHORT)
						ui_num = (u_wide_int)
						    (unsigned short) va_arg(ap,
						    unsigned int);
					else
						ui_num = (u_wide_int) va_arg(ap,
						    unsigned int);
					s = conv_p2(ui_num, 4, *fmt,
					    &num_buf[NUM_BUF_SIZE], &s_len);
				}
				FIX_PRECISION(adjust_precision, precision, s,
				    s_len);
				if (alternate_form && i_num != 0) {
					*--s = *fmt;	/* 'x' or 'X' */
					*--s = '0';
					s_len += 2;
				}
				break;


			case 's':
				s = va_arg(ap, char *);
				if (s != NULL) {
					s_len = strlen(s);
					if (adjust_precision && precision
					    < s_len)
						s_len = precision;
				}
				else {
					s = S_NULL;
					s_len = S_NULL_LEN;
				}
				pad_char = ' ';
				break;


			case 'f':
			case 'e':
			case 'E':
				fp_num = va_arg(ap, double);
				/*
				 * * We use &num_buf[ 1 ], so that we have room
				 *   for the sign
				 */
				if (isnan(fp_num)) {
					s = "nan";
					s_len = 3;
				}
				else if (isinf(fp_num)) {
					s = "inf";
					s_len = 3;
				} else {
					s = conv_fp(*fmt, fp_num,
					    alternate_form,
					    (adjust_precision == NO) ?
					    FLOAT_DIGITS : precision,
					    &is_negative, &num_buf[1],
					    &s_len, sizeof(num_buf) - 1);
					if (is_negative)
						prefix_char = '-';
					else if (print_sign)
						prefix_char = '+';
					else if (print_blank)
						prefix_char = ' ';
				}
				break;


			case 'g':
			case 'G':
				if (adjust_precision == NO)
					precision = FLOAT_DIGITS;
				else if (precision == 0)
					precision = 1;
				/*
				 * * We use &num_buf[ 1 ], so that we have room
				 *   for the sign
				 */
				s = ap_gcvt(va_arg(ap, double), precision,
				    &num_buf[1], alternate_form);
				if (*s == '-')
					prefix_char = *s++;
				else if (print_sign)
					prefix_char = '+';
				else if (print_blank)
					prefix_char = ' ';

				s_len = strlen(s);

				if (alternate_form && (q = strchr(s, '.'))
				    == NULL) {
					s[s_len++] = '.';
					s[s_len] = '\0';
					/* delimit for following strchr() */
				}
				if (*fmt == 'G' && (q = strchr(s, 'e')) != NULL)
					*q = 'E';
				break;


			case 'c':
				char_buf[0] = (char) (va_arg(ap, int));
				s = &char_buf[0];
				s_len = 1;
				pad_char = ' ';
				break;


			case '%':
				char_buf[0] = '%';
				s = &char_buf[0];
				s_len = 1;
				pad_char = ' ';
				break;


			case 'n':
				if (var_type == IS_QUAD)
					*(va_arg(ap, widest_int *)) = cc;
				else if (var_type == IS_LONG)
					*(va_arg(ap, long *)) = cc;
				else if (var_type == IS_SHORT)
					*(va_arg(ap, short *)) = cc;
				else
					*(va_arg(ap, int *)) = cc;
				break;

			/*
			 * This is where we extend the printf format, with a
			 * second type specifier
			 */
			case 'p':
				switch(*++fmt) {
				case 'p':
					ui_quad = (u_widest_int)(uintptr_t)
					    va_arg(ap, void *);
					s = conv_p2_quad(ui_quad, 4,
					    'x', &num_buf[NUM_BUF_SIZE],
					    &s_len);
					pad_char = ' ';
					break;

				/* print a struct sockaddr_in as a.b.c.d:port */
				case 'I':
				{
					struct sockaddr_in *si;

					si = va_arg(ap, struct sockaddr_in *);
					if (si != NULL) {
						s = conv_sockaddr_in(si,
						    &num_buf[NUM_BUF_SIZE],
						    &s_len);
						if (adjust_precision &&
						    precision < s_len)
							s_len = precision;
					}
					else {
					    s = S_NULL;
					    s_len = S_NULL_LEN;
					}
					pad_char = ' ';
					break;
				}

				    /* print a struct in_addr as a.b.c.d */
				case 'A':
				{
					struct in_addr *ia;

					ia = va_arg(ap, struct in_addr *);
					if (ia != NULL) {
						s = conv_in_addr(ia,
						    &num_buf[NUM_BUF_SIZE],
						    &s_len);
						if (adjust_precision &&
						    precision < s_len)
							s_len = precision;
					}
					else {
						s = S_NULL;
						s_len = S_NULL_LEN;
					}
					pad_char = ' ';
					break;
				}

				case NUL:
				/* if %p ends the string, oh well ignore it */
					continue;

				default:
					s = "bogus %p";
					s_len = 8;
					prefix_char = NUL;
					break;
				}
				break;

			case NUL:
				/*
				 * The last character of the format string was
				 * %. We ignore it.
				 */
				continue;


			/*
			 * The default case is for unrecognized %'s.
			 * We print %<char> to help the user identify what
			 * option is not understood.
			 * This is also useful in case the user wants to pass
			 * the output of format_converter to another function
			 * that understands some other %<char> (like syslog).
			 * Note that we can't point s inside fmt because the
			 * unknown <char> could be preceded by width etc.
			 */
			default:
				char_buf[0] = '%';
				char_buf[1] = *fmt;
				s = char_buf;
				s_len = 2;
				pad_char = ' ';
				break;
			}

			if (prefix_char != NUL && s != S_NULL &&
			    s != char_buf) {
				*--s = prefix_char;
				s_len++;
			}

			if (adjust_width && adjust == RIGHT &&
			    min_width > s_len) {
				if (pad_char == '0' && prefix_char != NUL) {
					INS_CHAR(*s, sp, bep, cc);
					s++;
					s_len--;
					min_width--;
				}
				PAD(min_width, s_len, pad_char);
			}

			/*
			* Print the string s. 
			*/
			for (i = s_len; i != 0; i--) {
				INS_CHAR(*s, sp, bep, cc);
				s++;
			}

			if (adjust_width && adjust == LEFT && min_width > s_len)
				PAD(min_width, s_len, pad_char);
		}
		fmt++;
	}
	vbuff->curpos = sp;

	return cc;
}


static int
snprintf_flush(ap_vformatter_buff *vbuff)
{
	/* if the buffer fills we have to abort immediately, there is no way
	* to "flush" an ap_snprintf... there's nowhere to flush it to.
	*/
	return -1;
}


API_EXPORT_NONSTD(int)
ap_snprintf(char *buf, size_t len, const char *format,...)
{
	int cc;
	va_list ap;
	ap_vformatter_buff vbuff;

	if (len == 0)
		return 0;

	/* save one byte for nul terminator */
	vbuff.curpos = buf;
	vbuff.endpos = buf + len - 1;
	va_start(ap, format);
	cc = ap_vformatter(snprintf_flush, &vbuff, format, ap);
	va_end(ap);
	*vbuff.curpos = '\0';
	return (cc == -1) ? len : cc;
}


API_EXPORT(int)
ap_vsnprintf(char *buf, size_t len, const char *format, va_list ap)
{
	int cc;
	ap_vformatter_buff vbuff;

	if (len == 0)
		return 0;

	/* save one byte for nul terminator */
	vbuff.curpos = buf;
	vbuff.endpos = buf + len - 1;
	cc = ap_vformatter(snprintf_flush, &vbuff, format, ap);
	*vbuff.curpos = '\0';
	return (cc == -1) ? len : cc;
}
@


1.17
log
@de-register, remove #ifdefs and #ifndefs using SIN6_LEN, add OpenBSD cvs
markers.

no binary changes
@
text
@d1 1
a1 1
/* $OpenBSD: ap_snprintf.c,v 1.16 2007/02/03 18:01:52 espie Exp $ */
@


1.16
log
@remove varying parts from generated configure info:
- ap_snprintf can grab needed types from stdint.h
- expat-lite can grab byte-order from system includes.

no breakage in modules in the ports tree.

work by me and millert@@, ok miod@@.
@
text
@d1 1
a1 1
/* $OpenBSD: ap_snprintf.c,v 1.15 2005/03/28 21:11:22 niallo Exp $ */
d128 1
a128 1
	register int r2;
d130 1
a130 1
	register char *p, *p1;
d220 2
a221 2
	register char *p1, *p2;
	register int i;
d365 2
a366 2
conv_10(register wide_int num, register bool_int is_unsigned,
    register bool_int *is_negative, char *buf_end, register int *len)
d368 2
a369 2
	register char *p = buf_end;
	register u_wide_int magnitude;
d401 1
a401 1
		register u_wide_int new_magnitude = magnitude / 10;
d413 2
a414 2
conv_10_quad(widest_int num, register bool_int is_unsigned,
    register bool_int *is_negative, char *buf_end, register int *len)
d416 1
a416 1
	register char *p = buf_end;
d518 1
a518 1
conv_fp(register char format, register double num, boolean_e add_dp,
d521 2
a522 2
	register char *s = buf;
	register char *p;
d617 2
a618 2
conv_p2(register u_wide_int num, register int nbits, char format, char *buf_end,
    register int *len)
d620 2
a621 2
	register int mask = (1 << nbits) - 1;
	register char *p = buf_end;
d624 1
a624 1
	register const char *digits = (format == 'X') ? upper_digits :
d638 2
a639 2
conv_p2_quad(u_widest_int num, register int nbits, char format,
    char *buf_end, register int *len)
d641 2
a642 2
	register int mask = (1 << nbits) - 1;
	register char *p = buf_end;
d645 1
a645 1
	register const char *digits = (format == 'X') ? upper_digits :
d669 4
a672 4
	register char *sp;
	register char *bep;
	register int cc = 0;
	register int i;
d674 1
a674 1
	register char *s = NULL;
d678 1
a678 1
	register int min_width = 0;
@


1.15
log
@one line was 81 chars long. break it up.
@
text
@d1 1
a1 1
/* $OpenBSD: ap_snprintf.c,v 1.14 2005/03/28 21:03:33 niallo Exp $ */
d75 1
a87 3
#ifndef AP_LONGEST_LONG
#define AP_LONGEST_LONG		long
#endif
a89 1
#define WIDEST_INT		AP_LONGEST_LONG
d93 2
a94 2
typedef WIDEST_INT widest_int;
typedef unsigned WIDEST_INT u_widest_int;
a1056 8
					/*
					* If the pointer size is equal to or
					* smaller than the size of the largest
					* unsigned int, we convert the pointer
					* to a hex number,
					* otherwise we print "%p" to indicate
					* that we don't handle "%p".
					*/
d1058 5
a1062 24
			#ifdef AP_VOID_P_IS_QUAD
					if (sizeof(void *)
					    <= sizeof(u_widest_int)) {
						ui_quad = (u_widest_int)
						    va_arg(ap, void *);
						s = conv_p2_quad(ui_quad, 4,
						    'x', &num_buf[NUM_BUF_SIZE],
						    &s_len);
					}
			#else
					if (sizeof(void *)
					    <= sizeof(u_wide_int)) {
						ui_num = (u_wide_int) va_arg(ap,
						    void *);
						s = conv_p2(ui_num, 4, 'x',
						    &num_buf[NUM_BUF_SIZE],
						    &s_len);
					}
			#endif
					else {
						s = "%p";
						s_len = 2;
						prefix_char = NUL;
					}
@


1.14
log
@clean up this code. make it conform as closely to KNF as possible without
introducing any binary changes.

two files here have different binary output when the number of lines changes,
we will finish cleaning those in another pass.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d832 2
a833 1
					s = conv_10_quad(i_quad, 1, &is_negative,
@


1.13
log
@kill more dead code, mostly inside #ifdef SOMENONSENSEONSTUPIDOSES
joint work by Michael Knudsen <e@@molioner.dk> and Daniel Ouellet
<daniel@@presscom.net> with my input
no change in binaries
@
text
@d1 2
d78 1
a78 1
    NO = 0, YES = 1
d128 2
a129 1
static char *ap_cvt(double arg, int ndigits, int *decpt, int *sign, int eflag, char *buf)
d131 14
a144 19
    register int r2;
    double fi, fj;
    register char *p, *p1;
    
    if (ndigits >= NDIG - 1)
	ndigits = NDIG - 2;
    r2 = 0;
    *sign = 0;
    p = &buf[0];
    if (arg < 0) {
	*sign = 1;
	arg = -arg;
    }
    arg = modf(arg, &fi);
    p1 = &buf[NDIG];
    /*
     * Do integer part
     */
    if (fi != 0) {
d146 12
a157 4
	while (p1 > &buf[0] && fi != 0) {
	    fj = modf(fi / 10, &fi);
	    *--p1 = (int) ((fj + .03) * 10) + '0';
	    r2++;
d159 38
a196 7
	while (p1 < &buf[NDIG])
	    *p++ = *p1++;
    }
    else if (arg > 0) {
	while ((fj = arg * 10) < 1) {
	    arg = fj;
	    r2--;
d198 1
a198 16
    }
    p1 = &buf[ndigits];
    if (eflag == 0)
	p1 += r2;
    *decpt = r2;
    if (p1 < &buf[0]) {
	buf[0] = '\0';
	return (buf);
    }
    while (p <= p1 && p < &buf[NDIG]) {
	arg *= 10;
	arg = modf(arg, &fj);
	*p++ = (int) fj + '0';
    }
    if (p1 >= &buf[NDIG]) {
	buf[NDIG - 1] = '\0';
a199 15
    }
    p = p1;
    *p1 += 5;
    while (*p1 > '9') {
	*p1 = '0';
	if (p1 > buf)
	    ++ * --p1;
	else {
	    *p1 = '1';
	    (*decpt)++;
	    if (eflag == 0) {
		if (p > buf)
		    *p = '0';
		p++;
	    }
a200 4
    }
    *p = '\0';
    return (buf);
}
d202 5
a206 4
static char *ap_ecvt(double arg, int ndigits, int *decpt, int *sign, char *buf)
{
    return (ap_cvt(arg, ndigits, decpt, sign, 1, buf));
}
d208 4
a211 3
static char *ap_fcvt(double arg, int ndigits, int *decpt, int *sign, char *buf)
{
    return (ap_cvt(arg, ndigits, decpt, sign, 0, buf));
d219 2
a220 1
static char *ap_gcvt(double number, int ndigit, char *buf, boolean_e altform)
d222 15
a236 43
    int sign, decpt;
    register char *p1, *p2;
    register int i;
    char buf1[NDIG];

    p1 = ap_ecvt(number, ndigit, &decpt, &sign, buf1);
    p2 = buf;
    if (sign)
	*p2++ = '-';
    for (i = ndigit - 1; i > 0 && p1[i] == '0'; i--)
	ndigit--;
    if ((decpt >= 0 && decpt - ndigit > 4)
	|| (decpt < 0 && decpt < -3)) {		/* use E-style */
	decpt--;
	*p2++ = *p1++;
	*p2++ = '.';
	for (i = 1; i < ndigit; i++)
	    *p2++ = *p1++;
	*p2++ = 'e';
	if (decpt < 0) {
	    decpt = -decpt;
	    *p2++ = '-';
	}
	else
	    *p2++ = '+';
	if (decpt / 100 > 0)
	    *p2++ = decpt / 100 + '0';
	if (decpt / 10 > 0)
	    *p2++ = (decpt % 100) / 10 + '0';
	*p2++ = decpt % 10 + '0';
    }
    else {
	if (decpt <= 0) {
	    if (*p1 != '0')
		*p2++ = '.';
	    while (decpt < 0) {
		decpt++;
		*p2++ = '0';
	    }
	}
	for (i = 1; i <= ndigit; i++) {
	    *p2++ = *p1++;
	    if (i == decpt)
d238 14
d253 19
a271 4
	if (ndigit < decpt) {
	    while (ndigit++ < decpt)
		*p2++ = '0';
	    *p2++ = '.';
d273 4
a276 5
    }
    if (p2[-1] == '.' && !altform)
	p2--;
    *p2 = '\0';
    return (buf);
d289 21
a309 21
#define INS_CHAR(c, sp, bep, cc)				\
	    {							\
		if (sp >= bep) {				\
		    vbuff->curpos = sp;                         \
		    if (flush_func(vbuff))			\
			return -1;				\
		    sp = vbuff->curpos;				\
		    bep = vbuff->endpos;			\
		} 						\
		*sp++ = (c);					\
		cc++; 						\
	    }

#define NUM( c )			( c - '0' )

#define STR_TO_DEC( str, num )		\
    num = NUM( *str++ ) ;		\
    while ( ap_isdigit( *str ) )		\
    {					\
	num *= 10 ;			\
	num += NUM( *str++ ) ;		\
d322 2
a323 2
#define FIX_PRECISION( adjust, precision, s, s_len )	\
    if ( adjust ) {					\
d325 5
a329 5
	while ( s_len < p )				\
	{						\
	    *--s = '0' ;				\
	    s_len++ ;					\
	}						\
d336 6
a341 6
#define PAD( width, len, ch )	do		\
	{					\
	    INS_CHAR( ch, sp, bep, cc ) ;	\
	    width-- ;				\
	}					\
	while ( width > len )
d367 3
a369 3
static char *conv_10(register wide_int num, register bool_int is_unsigned,
		     register bool_int *is_negative, char *buf_end,
		     register int *len)
d371 2
a372 2
    register char *p = buf_end;
    register u_wide_int magnitude;
d374 6
a379 6
    if (is_unsigned) {
	magnitude = (u_wide_int) num;
	*is_negative = FALSE;
    }
    else {
	*is_negative = (num < 0);
d381 12
a392 11
	/*
	 * On a 2's complement machine, negating the most negative integer 
	 * results in a number that cannot be represented as a signed integer.
	 * Here is what we do to obtain the number's magnitude:
	 *      a. add 1 to the number
	 *      b. negate it (becomes positive)
	 *      c. convert it to unsigned
	 *      d. add 1
	 */
	if (*is_negative) {
	    wide_int t = num + 1;
d394 4
a397 1
	    magnitude = ((u_wide_int) -t) + 1;
a398 3
	else
	    magnitude = (u_wide_int) num;
    }
d400 5
a404 5
    /*
     * We use a do-while loop so that we write at least 1 digit 
     */
    do {
	register u_wide_int new_magnitude = magnitude / 10;
d406 4
a409 4
	*--p = (char) (magnitude - new_magnitude * 10 + '0');
	magnitude = new_magnitude;
    }
    while (magnitude);
d411 2
a412 2
    *len = buf_end - p;
    return (p);
d415 3
a417 3
static char *conv_10_quad(widest_int num, register bool_int is_unsigned,
		     register bool_int *is_negative, char *buf_end,
		     register int *len)
d419 2
a420 2
    register char *p = buf_end;
    u_widest_int magnitude;
d422 16
a437 15
    /*
     * We see if we can use the faster non-quad version by checking the
     * number against the largest long value it can be. If <=, we
     * punt to the quicker version.
     */
    if ((num <= ULONG_MAX && is_unsigned) || (num <= LONG_MAX && !is_unsigned))
    	return(conv_10( (wide_int)num, is_unsigned, is_negative,
	       buf_end, len));

    if (is_unsigned) {
	magnitude = (u_widest_int) num;
	*is_negative = FALSE;
    }
    else {
	*is_negative = (num < 0);
d439 12
a450 11
	/*
	 * On a 2's complement machine, negating the most negative integer 
	 * results in a number that cannot be represented as a signed integer.
	 * Here is what we do to obtain the number's magnitude:
	 *      a. add 1 to the number
	 *      b. negate it (becomes positive)
	 *      c. convert it to unsigned
	 *      d. add 1
	 */
	if (*is_negative) {
	    widest_int t = num + 1;
d452 4
a455 1
	    magnitude = ((u_widest_int) -t) + 1;
a456 3
	else
	    magnitude = (u_widest_int) num;
    }
d458 5
a462 5
    /*
     * We use a do-while loop so that we write at least 1 digit 
     */
    do {
	u_widest_int new_magnitude = magnitude / 10;
d464 4
a467 4
	*--p = (char) (magnitude - new_magnitude * 10 + '0');
	magnitude = new_magnitude;
    }
    while (magnitude);
d469 2
a470 2
    *len = buf_end - p;
    return (p);
d475 2
a476 1
static char *conv_in_addr(struct in_addr *ia, char *buf_end, int *len)
d478 12
a489 12
    unsigned addr = ntohl(ia->s_addr);
    char *p = buf_end;
    bool_int is_negative;
    int sub_len;

    p = conv_10((addr & 0x000000FF)      , TRUE, &is_negative, p, &sub_len);
    *--p = '.';
    p = conv_10((addr & 0x0000FF00) >>  8, TRUE, &is_negative, p, &sub_len);
    *--p = '.';
    p = conv_10((addr & 0x00FF0000) >> 16, TRUE, &is_negative, p, &sub_len);
    *--p = '.';
    p = conv_10((addr & 0xFF000000) >> 24, TRUE, &is_negative, p, &sub_len);
d491 2
a492 2
    *len = buf_end - p;
    return (p);
d497 2
a498 1
static char *conv_sockaddr_in(struct sockaddr_in *si, char *buf_end, int *len)
d500 7
a506 7
    char *p = buf_end;
    bool_int is_negative;
    int sub_len;

    p = conv_10(ntohs(si->sin_port), TRUE, &is_negative, p, &sub_len);
    *--p = ':';
    p = conv_in_addr(&si->sin_addr, p, &sub_len);
d508 2
a509 2
    *len = buf_end - p;
    return (p);
d520 3
a522 3
static char *conv_fp(register char format, register double num,
    boolean_e add_dp, int precision, bool_int *is_negative,
    char *buf, int *len, int buflen)
d524 19
a542 18
    register char *s = buf;
    register char *p;
    int decimal_point;
    char buf1[NDIG];

    if (format == 'f')
	p = ap_fcvt(num, precision, &decimal_point, is_negative, buf1);
    else			/* either e or E format */
	p = ap_ecvt(num, precision + 1, &decimal_point, is_negative, buf1);

    /*
     * Check for Infinity and NaN
     */
    if (ap_isalpha(*p)) {
	*len = strlcpy(buf, p, buflen); /* we really need the wanted len here */
	*is_negative = FALSE;
	return (buf);
    }
d544 17
a560 10
    if (format == 'f') {
	if (decimal_point <= 0) {
	    *s++ = '0';
	    if (precision > 0) {
		*s++ = '.';
		while (decimal_point++ < 0)
		    *s++ = '0';
	    }
	    else if (add_dp)
		*s++ = '.';
a562 1
	    while (decimal_point-- > 0)
d564 2
a565 2
	    if (precision > 0 || add_dp)
		*s++ = '.';
a566 6
    }
    else {
	*s++ = *p++;
	if (precision > 0 || add_dp)
	    *s++ = '.';
    }
d568 4
a571 24
    /*
     * copy the rest of p, the NUL is NOT copied
     */
    while (*p)
	*s++ = *p++;

    if (format != 'f') {
	char temp[EXPONENT_LENGTH];	/* for exponent conversion */
	int t_len;
	bool_int exponent_is_negative;

	*s++ = format;		/* either e or E */
	decimal_point--;
	if (decimal_point != 0) {
	    p = conv_10((wide_int) decimal_point, FALSE, &exponent_is_negative,
			&temp[EXPONENT_LENGTH], &t_len);
	    *s++ = exponent_is_negative ? '-' : '+';

	    /*
	     * Make sure the exponent has at least 2 digits
	     */
	    if (t_len == 1)
		*s++ = '0';
	    while (t_len--)
d573 27
d601 2
a602 9
	else {
	    *s++ = '+';
	    *s++ = '0';
	    *s++ = '0';
	}
    }

    *len = s - buf;
    return (buf);
d619 3
a621 2
static char *conv_p2(register u_wide_int num, register int nbits,
		     char format, char *buf_end, register int *len)
d623 12
a634 11
    register int mask = (1 << nbits) - 1;
    register char *p = buf_end;
    static const char low_digits[] = "0123456789abcdef";
    static const char upper_digits[] = "0123456789ABCDEF";
    register const char *digits = (format == 'X') ? upper_digits : low_digits;

    do {
	*--p = digits[num & mask];
	num >>= nbits;
    }
    while (num);
d636 2
a637 2
    *len = buf_end - p;
    return (p);
d640 3
a642 2
static char *conv_p2_quad(u_widest_int num, register int nbits,
		     char format, char *buf_end, register int *len)
d644 15
a658 14
    register int mask = (1 << nbits) - 1;
    register char *p = buf_end;
    static const char low_digits[] = "0123456789abcdef";
    static const char upper_digits[] = "0123456789ABCDEF";
    register const char *digits = (format == 'X') ? upper_digits : low_digits;

    if (num <= ULONG_MAX)
    	return(conv_p2( (u_wide_int)num, nbits, format, buf_end, len));

    do {
	*--p = digits[num & mask];
	num >>= nbits;
    }
    while (num);
d660 2
a661 2
    *len = buf_end - p;
    return (p);
d668 2
a669 1
API_EXPORT(int) ap_vformatter(int (*flush_func)(ap_vformatter_buff *),
d672 12
a683 12
    register char *sp;
    register char *bep;
    register int cc = 0;
    register int i;

    register char *s = NULL;
    char *q;
    int s_len;

    register int min_width = 0;
    int precision = 0;
    enum {
d685 17
a701 67
    } adjust;
    char pad_char;
    char prefix_char;

    double fp_num;
    widest_int i_quad = (widest_int) 0;
    u_widest_int ui_quad;
    wide_int i_num = (wide_int) 0;
    u_wide_int ui_num;

    char num_buf[NUM_BUF_SIZE];
    char char_buf[2];		/* for printing %% and %<unknown> */

    enum var_type_enum {
    	IS_QUAD, IS_LONG, IS_SHORT, IS_INT
    };
    enum var_type_enum var_type = IS_INT;

    /*
     * Flag variables
     */
    boolean_e alternate_form;
    boolean_e print_sign;
    boolean_e print_blank;
    boolean_e adjust_precision;
    boolean_e adjust_width;
    bool_int is_negative;

    sp = vbuff->curpos;
    bep = vbuff->endpos;

    while (*fmt) {
	if (*fmt != '%') {
	    INS_CHAR(*fmt, sp, bep, cc);
	}
	else {
	    /*
	     * Default variable settings
	     */
	    adjust = RIGHT;
	    alternate_form = print_sign = print_blank = NO;
	    pad_char = ' ';
	    prefix_char = NUL;

	    fmt++;

	    /*
	     * Try to avoid checking for flags, width or precision
	     */
	    if (!ap_islower(*fmt)) {
		/*
		 * Recognize flags: -, #, BLANK, +
		 */
		for (;; fmt++) {
		    if (*fmt == '-')
			adjust = LEFT;
		    else if (*fmt == '+')
			print_sign = YES;
		    else if (*fmt == '#')
			alternate_form = YES;
		    else if (*fmt == ' ')
			print_blank = YES;
		    else if (*fmt == '0')
			pad_char = '0';
		    else
			break;
		}
d703 25
a727 18
		/*
		 * Check if a width was specified
		 */
		if (ap_isdigit(*fmt)) {
		    STR_TO_DEC(fmt, min_width);
		    adjust_width = YES;
		}
		else if (*fmt == '*') {
		    min_width = va_arg(ap, int);
		    fmt++;
		    adjust_width = YES;
		    if (min_width < 0) {
			adjust = LEFT;
			min_width = -min_width;
		    }
		}
		else
		    adjust_width = NO;
a728 11
		/*
		 * Check if a precision was specified
		 */
		if (*fmt == '.') {
		    adjust_precision = YES;
		    fmt++;
		    if (ap_isdigit(*fmt)) {
			STR_TO_DEC(fmt, precision);
		    }
		    else if (*fmt == '*') {
			precision = va_arg(ap, int);
a729 61
			if (precision < 0)
			    precision = 0;
		    }
		    else
			precision = 0;
		}
		else
		    adjust_precision = NO;
	    }
	    else
		adjust_precision = adjust_width = NO;

	    /*
	     * Modifier check
	     */
	    if (*fmt == 'q') {
		var_type = IS_QUAD;
		fmt++;
	    }
	    else if (*fmt == 'l') {
		var_type = IS_LONG;
		fmt++;
	    }
	    else if (*fmt == 'h') {
		var_type = IS_SHORT;
		fmt++;
	    }
	    else {
		var_type = IS_INT;
	    }

	    /*
	     * Argument extraction and printing.
	     * First we determine the argument type.
	     * Then, we convert the argument to a string.
	     * On exit from the switch, s points to the string that
	     * must be printed, s_len has the length of the string
	     * The precision requirements, if any, are reflected in s_len.
	     *
	     * NOTE: pad_char may be set to '0' because of the 0 flag.
	     *   It is reset to ' ' by non-numeric formats
	     */
	    switch (*fmt) {
	    case 'u':
	    	if (var_type == IS_QUAD) {
		    i_quad = va_arg(ap, u_widest_int);
		    s = conv_10_quad(i_quad, 1, &is_negative,
			    &num_buf[NUM_BUF_SIZE], &s_len);
		}
		else {
		    if (var_type == IS_LONG)
			i_num = (wide_int) va_arg(ap, u_wide_int);
		    else if (var_type == IS_SHORT)
			i_num = (wide_int) (unsigned short) va_arg(ap, unsigned int);
		    else
			i_num = (wide_int) va_arg(ap, unsigned int);
		    s = conv_10(i_num, 1, &is_negative,
			    &num_buf[NUM_BUF_SIZE], &s_len);
		}
		FIX_PRECISION(adjust_precision, precision, s, s_len);
		break;
d731 64
a794 18
	    case 'd':
	    case 'i':
	    	if (var_type == IS_QUAD) {
		    i_quad = va_arg(ap, widest_int);
		    s = conv_10_quad(i_quad, 0, &is_negative,
			    &num_buf[NUM_BUF_SIZE], &s_len);
		}
		else {
		    if (var_type == IS_LONG)
			i_num = (wide_int) va_arg(ap, wide_int);
		    else if (var_type == IS_SHORT)
			i_num = (wide_int) (short) va_arg(ap, int);
		    else
			i_num = (wide_int) va_arg(ap, int);
		    s = conv_10(i_num, 0, &is_negative,
			    &num_buf[NUM_BUF_SIZE], &s_len);
		}
		FIX_PRECISION(adjust_precision, precision, s, s_len);
d796 14
a809 206
		if (is_negative)
		    prefix_char = '-';
		else if (print_sign)
		    prefix_char = '+';
		else if (print_blank)
		    prefix_char = ' ';
		break;


	    case 'o':
		if (var_type == IS_QUAD) {
		    ui_quad = va_arg(ap, u_widest_int);
		    s = conv_p2_quad(ui_quad, 3, *fmt,
			    &num_buf[NUM_BUF_SIZE], &s_len);
		}
		else {
		    if (var_type == IS_LONG)
			ui_num = (u_wide_int) va_arg(ap, u_wide_int);
		    else if (var_type == IS_SHORT)
			ui_num = (u_wide_int) (unsigned short) va_arg(ap, unsigned int);
		    else
			ui_num = (u_wide_int) va_arg(ap, unsigned int);
		    s = conv_p2(ui_num, 3, *fmt,
			    &num_buf[NUM_BUF_SIZE], &s_len);
		}
		FIX_PRECISION(adjust_precision, precision, s, s_len);
		if (alternate_form && *s != '0') {
		    *--s = '0';
		    s_len++;
		}
		break;


	    case 'x':
	    case 'X':
		if (var_type == IS_QUAD) {
		    ui_quad = va_arg(ap, u_widest_int);
		    s = conv_p2_quad(ui_quad, 4, *fmt,
			    &num_buf[NUM_BUF_SIZE], &s_len);
		}
		else {
		    if (var_type == IS_LONG)
			ui_num = (u_wide_int) va_arg(ap, u_wide_int);
		    else if (var_type == IS_SHORT)
			ui_num = (u_wide_int) (unsigned short) va_arg(ap, unsigned int);
		    else
			ui_num = (u_wide_int) va_arg(ap, unsigned int);
		    s = conv_p2(ui_num, 4, *fmt,
			    &num_buf[NUM_BUF_SIZE], &s_len);
		}
		FIX_PRECISION(adjust_precision, precision, s, s_len);
		if (alternate_form && i_num != 0) {
		    *--s = *fmt;	/* 'x' or 'X' */
		    *--s = '0';
		    s_len += 2;
		}
		break;


	    case 's':
		s = va_arg(ap, char *);
		if (s != NULL) {
		    s_len = strlen(s);
		    if (adjust_precision && precision < s_len)
			s_len = precision;
		}
		else {
		    s = S_NULL;
		    s_len = S_NULL_LEN;
		}
		pad_char = ' ';
		break;


	    case 'f':
	    case 'e':
	    case 'E':
		fp_num = va_arg(ap, double);
		/*
		 * * We use &num_buf[ 1 ], so that we have room for the sign
		 */
		if (isnan(fp_num)) {
		    s = "nan";
		    s_len = 3;
		}
		else
		if (isinf(fp_num)) {
		    s = "inf";
		    s_len = 3;
		}
		else
		{
		    s = conv_fp(*fmt, fp_num, alternate_form,
			    (adjust_precision == NO) ? FLOAT_DIGITS : precision,
				&is_negative, &num_buf[1], &s_len,
				sizeof(num_buf) - 1);
		    if (is_negative)
			prefix_char = '-';
		    else if (print_sign)
			prefix_char = '+';
		    else if (print_blank)
			prefix_char = ' ';
		}
	        break;


	    case 'g':
	    case 'G':
		if (adjust_precision == NO)
		    precision = FLOAT_DIGITS;
		else if (precision == 0)
		    precision = 1;
		/*
		 * * We use &num_buf[ 1 ], so that we have room for the sign
		 */
		s = ap_gcvt(va_arg(ap, double), precision, &num_buf[1],
		            alternate_form);
		if (*s == '-')
		    prefix_char = *s++;
		else if (print_sign)
		    prefix_char = '+';
		else if (print_blank)
		    prefix_char = ' ';

		s_len = strlen(s);

		if (alternate_form && (q = strchr(s, '.')) == NULL) {
		    s[s_len++] = '.';
		    s[s_len] = '\0'; /* delimit for following strchr() */
		}
		if (*fmt == 'G' && (q = strchr(s, 'e')) != NULL)
		    *q = 'E';
		break;


	    case 'c':
		char_buf[0] = (char) (va_arg(ap, int));
		s = &char_buf[0];
		s_len = 1;
		pad_char = ' ';
		break;


	    case '%':
		char_buf[0] = '%';
		s = &char_buf[0];
		s_len = 1;
		pad_char = ' ';
		break;


	    case 'n':
	    	if (var_type == IS_QUAD)
		    *(va_arg(ap, widest_int *)) = cc;
		else if (var_type == IS_LONG)
		    *(va_arg(ap, long *)) = cc;
		else if (var_type == IS_SHORT)
		    *(va_arg(ap, short *)) = cc;
		else
		    *(va_arg(ap, int *)) = cc;
		break;

		/*
		 * This is where we extend the printf format, with a second
		 * type specifier
		 */
	    case 'p':
		switch(*++fmt) {
		    /*
		     * If the pointer size is equal to or smaller than the size
		     * of the largest unsigned int, we convert the pointer to a
		     * hex number, otherwise we print "%p" to indicate that we
		     * don't handle "%p".
		     */
		case 'p':
#ifdef AP_VOID_P_IS_QUAD
		    if (sizeof(void *) <= sizeof(u_widest_int)) {
		    	ui_quad = (u_widest_int) va_arg(ap, void *);
			s = conv_p2_quad(ui_quad, 4, 'x',
				&num_buf[NUM_BUF_SIZE], &s_len);
		    }
#else
		    if (sizeof(void *) <= sizeof(u_wide_int)) {
		    	ui_num = (u_wide_int) va_arg(ap, void *);
			s = conv_p2(ui_num, 4, 'x',
				&num_buf[NUM_BUF_SIZE], &s_len);
		    }
#endif
		    else {
			s = "%p";
			s_len = 2;
			prefix_char = NUL;
		    }
		    pad_char = ' ';
		    break;

		    /* print a struct sockaddr_in as a.b.c.d:port */
		case 'I':
		    {
			struct sockaddr_in *si;

			si = va_arg(ap, struct sockaddr_in *);
			if (si != NULL) {
			    s = conv_sockaddr_in(si, &num_buf[NUM_BUF_SIZE], &s_len);
			    if (adjust_precision && precision < s_len)
				s_len = precision;
d812 1
a812 2
			    s = S_NULL;
			    s_len = S_NULL_LEN;
a813 3
			pad_char = ' ';
		    }
		    break;
d815 361
a1175 10
		    /* print a struct in_addr as a.b.c.d */
		case 'A':
		    {
			struct in_addr *ia;

			ia = va_arg(ap, struct in_addr *);
			if (ia != NULL) {
			    s = conv_in_addr(ia, &num_buf[NUM_BUF_SIZE], &s_len);
			    if (adjust_precision && precision < s_len)
				s_len = precision;
d1177 5
a1181 3
			else {
			    s = S_NULL;
			    s_len = S_NULL_LEN;
a1182 3
			pad_char = ' ';
		    }
		    break;
d1184 10
a1193 11
		case NUL:
		    /* if %p ends the string, oh well ignore it */
		    continue;

		default:
		    s = "bogus %p";
		    s_len = 8;
		    prefix_char = NUL;
		    break;
		}
		break;
d1195 7
a1201 6
	    case NUL:
		/*
		 * The last character of the format string was %.
		 * We ignore it.
		 */
		continue;
d1203 2
a1204 31

		/*
		 * The default case is for unrecognized %'s.
		 * We print %<char> to help the user identify what
		 * option is not understood.
		 * This is also useful in case the user wants to pass
		 * the output of format_converter to another function
		 * that understands some other %<char> (like syslog).
		 * Note that we can't point s inside fmt because the
		 * unknown <char> could be preceded by width etc.
		 */
	    default:
		char_buf[0] = '%';
		char_buf[1] = *fmt;
		s = char_buf;
		s_len = 2;
		pad_char = ' ';
		break;
	    }

	    if (prefix_char != NUL && s != S_NULL && s != char_buf) {
		*--s = prefix_char;
		s_len++;
	    }

	    if (adjust_width && adjust == RIGHT && min_width > s_len) {
		if (pad_char == '0' && prefix_char != NUL) {
		    INS_CHAR(*s, sp, bep, cc);
		    s++;
		    s_len--;
		    min_width--;
d1206 1
a1206 13
		PAD(min_width, s_len, pad_char);
	    }

	    /*
	     * Print the string s. 
	     */
	    for (i = s_len; i != 0; i--) {
		INS_CHAR(*s, sp, bep, cc);
		s++;
	    }

	    if (adjust_width && adjust == LEFT && min_width > s_len)
		PAD(min_width, s_len, pad_char);
d1208 1
a1208 3
	fmt++;
    }
    vbuff->curpos = sp;
d1210 1
a1210 1
    return cc;
d1214 2
a1215 1
static int snprintf_flush(ap_vformatter_buff *vbuff)
d1217 4
a1220 4
    /* if the buffer fills we have to abort immediately, there is no way
     * to "flush" an ap_snprintf... there's nowhere to flush it to.
     */
    return -1;
d1224 2
a1225 1
API_EXPORT_NONSTD(int) ap_snprintf(char *buf, size_t len, const char *format,...)
d1227 15
a1241 15
    int cc;
    va_list ap;
    ap_vformatter_buff vbuff;

    if (len == 0)
	return 0;

    /* save one byte for nul terminator */
    vbuff.curpos = buf;
    vbuff.endpos = buf + len - 1;
    va_start(ap, format);
    cc = ap_vformatter(snprintf_flush, &vbuff, format, ap);
    va_end(ap);
    *vbuff.curpos = '\0';
    return (cc == -1) ? len : cc;
d1245 2
a1246 2
API_EXPORT(int) ap_vsnprintf(char *buf, size_t len, const char *format,
			     va_list ap)
d1248 2
a1249 2
    int cc;
    ap_vformatter_buff vbuff;
d1251 2
a1252 2
    if (len == 0)
	return 0;
d1254 6
a1259 6
    /* save one byte for nul terminator */
    vbuff.curpos = buf;
    vbuff.endpos = buf + len - 1;
    cc = ap_vformatter(snprintf_flush, &vbuff, format, ap);
    *vbuff.curpos = '\0';
    return (cc == -1) ? len : cc;
@


1.12
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@a928 1
#ifdef HAVE_ISNAN
a933 2
#endif
#ifdef HAVE_ISINF
a938 1
#endif
@


1.11
log
@merge
@
text
@a68 1
#ifndef NETWARE
a69 1
#endif
a73 3
#ifdef WIN32
#include <float.h>
#endif
a94 4
#ifdef __TANDEM
/* Although Tandem supports "long long" there is no unsigned variant. */
typedef unsigned long       u_widest_int;
#else
a95 1
#endif
@


1.10
log
@more string shit, ok bob and vincent
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
d320 5
a324 1
 * to be printed.
d327 3
a329 3
    if ( adjust )					\
	while ( s_len < precision &&			\
		s_len < NUM_BUF_SIZE - 1)		\
d333 2
a334 1
	}
a766 4
		 *
		 * XXX: an unreasonable amount of precision may be specified
		 * resulting in overflow of num_buf. Currently we
		 * ignore this possibility.
@


1.9
log
@fix buffer overflow in the FIX_PRECISION macro
not exploiteable; would need more programming errors to cause harm
from jim@@apache
@
text
@d516 1
a516 1
    char *buf, int *len)
d532 1
a532 1
	*len = strlen(strcpy(buf, p));
d955 2
a956 1
				&is_negative, &num_buf[1], &s_len);
@


1.8
log
@merge apache 1.3.27 and mod_ssl 2.8.11
@
text
@d324 2
a325 1
	while ( s_len < precision )			\
@


1.7
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d1161 1
a1161 4
    if (sp >= bep) {
	if (flush_func(vbuff))
	    return -1;
    }
@


1.6
log
@Apache 1.3.23+mod_ssl-2.8.6-1.3.23 merge
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d1161 4
@


1.5
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d76 3
d158 1
a158 1
	while (fi != 0) {
d937 26
a962 10
		s = conv_fp(*fmt, fp_num, alternate_form,
			(adjust_precision == NO) ? FLOAT_DIGITS : precision,
			    &is_negative, &num_buf[1], &s_len);
		if (is_negative)
		    prefix_char = '-';
		else if (print_sign)
		    prefix_char = '+';
		else if (print_blank)
		    prefix_char = ' ';
		break;
d1174 1
a1174 1
API_EXPORT(int) ap_snprintf(char *buf, size_t len, const char *format,...)
@


1.4
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1995-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 20
a38 23
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 10
a59 6
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
@


1.3
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d65 1
d67 1
a86 1
#define INT_NULL		((int *)0)
d134 1
a134 1

d405 1
a405 1
static char *conv_10_quad(register widest_int num, register bool_int is_unsigned,
d410 1
a410 1
    register u_widest_int magnitude;
d413 3
a415 2
     * If the value is less than the maximum unsigned long value,
     * then we know we aren't using quads, so use the faster function
d417 1
a417 1
    if (num <= ULONG_MAX)
d450 1
a450 1
	register u_widest_int new_magnitude = magnitude / 10;
d623 1
a623 1
static char *conv_p2_quad(register u_widest_int num, register int nbits,
@


1.2
log
@Apache 1.3.4 merge
@
text
@d81 3
d87 1
d91 7
d352 4
d404 55
d598 3
d621 22
d668 2
d676 5
a683 1
    boolean_e is_long;
d781 10
a790 2
	    if (*fmt == 'l') {
		is_long = YES;
d794 1
a794 3
		if (*fmt == 'h')  /* "short" backward compatibility */
		    ++fmt;
		is_long = NO;
d810 13
a822 5
		if (is_long)
		    i_num = va_arg(ap, u_wide_int);
		else
		    i_num = (wide_int) va_arg(ap, unsigned int);
		s = conv_10(i_num, 1, &is_negative,
d824 1
d830 13
a842 5
		if (is_long)
		    i_num = va_arg(ap, wide_int);
		else
		    i_num = (wide_int) va_arg(ap, int);
		s = conv_10(i_num, 0, &is_negative,
d844 1
d857 13
a869 5
		if (is_long)
		    ui_num = va_arg(ap, u_wide_int);
		else
		    ui_num = (u_wide_int) va_arg(ap, unsigned int);
		s = conv_p2(ui_num, 3, *fmt,
d871 1
d882 13
a894 5
		if (is_long)
		    ui_num = (u_wide_int) va_arg(ap, u_wide_int);
		else
		    ui_num = (u_wide_int) va_arg(ap, unsigned int);
		s = conv_p2(ui_num, 4, *fmt,
d896 1
d986 8
a993 1
		*(va_arg(ap, int *)) = cc;
d1003 4
a1006 3
		     * If the pointer size is equal to the size of an unsigned
		     * integer we convert the pointer to a hex number, otherwise 
		     * we print "%p" to indicate that we don't handle "%p".
d1009 13
a1021 5
		    ui_num = (u_wide_int) va_arg(ap, void *);

		    if (sizeof(char *) <= sizeof(u_wide_int))
				s = conv_p2(ui_num, 4, 'x',
					    &num_buf[NUM_BUF_SIZE], &s_len);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1995-1998 The Apache Group.  All rights reserved.
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 23
a38 20
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 5
a54 3
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
a55 6
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/*
a64 1
#ifndef NETWARE
a65 1
#endif
a69 3
#ifdef WIN32
#include <float.h>
#endif
a80 3
#ifndef AP_LONGEST_LONG
#define AP_LONGEST_LONG		long
#endif
d82 1
a83 1
#define WIDEST_INT		AP_LONGEST_LONG
a86 7
typedef WIDEST_INT widest_int;
#ifdef __TANDEM
/* Although Tandem supports "long long" there is no unsigned variant. */
typedef unsigned long       u_widest_int;
#else
typedef unsigned WIDEST_INT u_widest_int;
#endif
d122 1
a122 1
    
d139 1
a139 1
	while (p1 > &buf[0] && fi != 0) {
a340 4
 *
 * Note: we have 2 versions. One is used when we need to use quads
 * (conv_10_quad), the other when we don't (conv_10). We're assuming the
 * latter is faster.
a388 56
static char *conv_10_quad(widest_int num, register bool_int is_unsigned,
		     register bool_int *is_negative, char *buf_end,
		     register int *len)
{
    register char *p = buf_end;
    u_widest_int magnitude;

    /*
     * We see if we can use the faster non-quad version by checking the
     * number against the largest long value it can be. If <=, we
     * punt to the quicker version.
     */
    if ((num <= ULONG_MAX && is_unsigned) || (num <= LONG_MAX && !is_unsigned))
    	return(conv_10( (wide_int)num, is_unsigned, is_negative,
	       buf_end, len));

    if (is_unsigned) {
	magnitude = (u_widest_int) num;
	*is_negative = FALSE;
    }
    else {
	*is_negative = (num < 0);

	/*
	 * On a 2's complement machine, negating the most negative integer 
	 * results in a number that cannot be represented as a signed integer.
	 * Here is what we do to obtain the number's magnitude:
	 *      a. add 1 to the number
	 *      b. negate it (becomes positive)
	 *      c. convert it to unsigned
	 *      d. add 1
	 */
	if (*is_negative) {
	    widest_int t = num + 1;

	    magnitude = ((u_widest_int) -t) + 1;
	}
	else
	    magnitude = (u_widest_int) num;
    }

    /*
     * We use a do-while loop so that we write at least 1 digit 
     */
    do {
	u_widest_int new_magnitude = magnitude / 10;

	*--p = (char) (magnitude - new_magnitude * 10 + '0');
	magnitude = new_magnitude;
    }
    while (magnitude);

    *len = buf_end - p;
    return (p);
}

a527 3
 *
 * As with conv_10, we have a faster version which is used when
 * the number isn't quad size.
a547 22
static char *conv_p2_quad(u_widest_int num, register int nbits,
		     char format, char *buf_end, register int *len)
{
    register int mask = (1 << nbits) - 1;
    register char *p = buf_end;
    static const char low_digits[] = "0123456789abcdef";
    static const char upper_digits[] = "0123456789ABCDEF";
    register const char *digits = (format == 'X') ? upper_digits : low_digits;

    if (num <= ULONG_MAX)
    	return(conv_p2( (u_wide_int)num, nbits, format, buf_end, len));

    do {
	*--p = digits[num & mask];
	num >>= nbits;
    }
    while (num);

    *len = buf_end - p;
    return (p);
}

a572 2
    widest_int i_quad = (widest_int) 0;
    u_widest_int ui_quad;
a578 5
    enum var_type_enum {
    	IS_QUAD, IS_LONG, IS_SHORT, IS_INT
    };
    enum var_type_enum var_type = IS_INT;

d582 1
d680 2
a681 10
	    if (*fmt == 'q') {
		var_type = IS_QUAD;
		fmt++;
	    }
	    else if (*fmt == 'l') {
		var_type = IS_LONG;
		fmt++;
	    }
	    else if (*fmt == 'h') {
		var_type = IS_SHORT;
d685 3
a687 1
		var_type = IS_INT;
d703 5
a707 13
	    	if (var_type == IS_QUAD) {
		    i_quad = va_arg(ap, u_widest_int);
		    s = conv_10_quad(i_quad, 1, &is_negative,
			    &num_buf[NUM_BUF_SIZE], &s_len);
		}
		else {
		    if (var_type == IS_LONG)
			i_num = (wide_int) va_arg(ap, u_wide_int);
		    else if (var_type == IS_SHORT)
			i_num = (wide_int) (unsigned short) va_arg(ap, unsigned int);
		    else
			i_num = (wide_int) va_arg(ap, unsigned int);
		    s = conv_10(i_num, 1, &is_negative,
a708 1
		}
d714 5
a718 3
	    	if (var_type == IS_QUAD) {
		    i_quad = va_arg(ap, widest_int);
		    s = conv_10_quad(i_quad, 0, &is_negative,
a719 11
		}
		else {
		    if (var_type == IS_LONG)
			i_num = (wide_int) va_arg(ap, wide_int);
		    else if (var_type == IS_SHORT)
			i_num = (wide_int) (short) va_arg(ap, int);
		    else
			i_num = (wide_int) va_arg(ap, int);
		    s = conv_10(i_num, 0, &is_negative,
			    &num_buf[NUM_BUF_SIZE], &s_len);
		}
d732 5
a736 3
		if (var_type == IS_QUAD) {
		    ui_quad = va_arg(ap, u_widest_int);
		    s = conv_p2_quad(ui_quad, 3, *fmt,
a737 11
		}
		else {
		    if (var_type == IS_LONG)
			ui_num = (u_wide_int) va_arg(ap, u_wide_int);
		    else if (var_type == IS_SHORT)
			ui_num = (u_wide_int) (unsigned short) va_arg(ap, unsigned int);
		    else
			ui_num = (u_wide_int) va_arg(ap, unsigned int);
		    s = conv_p2(ui_num, 3, *fmt,
			    &num_buf[NUM_BUF_SIZE], &s_len);
		}
d748 5
a752 13
		if (var_type == IS_QUAD) {
		    ui_quad = va_arg(ap, u_widest_int);
		    s = conv_p2_quad(ui_quad, 4, *fmt,
			    &num_buf[NUM_BUF_SIZE], &s_len);
		}
		else {
		    if (var_type == IS_LONG)
			ui_num = (u_wide_int) va_arg(ap, u_wide_int);
		    else if (var_type == IS_SHORT)
			ui_num = (u_wide_int) (unsigned short) va_arg(ap, unsigned int);
		    else
			ui_num = (u_wide_int) va_arg(ap, unsigned int);
		    s = conv_p2(ui_num, 4, *fmt,
a753 1
		}
d785 10
a794 26
#ifdef HAVE_ISNAN
		if (isnan(fp_num)) {
		    s = "nan";
		    s_len = 3;
		}
		else
#endif
#ifdef HAVE_ISINF
		if (isinf(fp_num)) {
		    s = "inf";
		    s_len = 3;
		}
		else
#endif
		{
		    s = conv_fp(*fmt, fp_num, alternate_form,
			    (adjust_precision == NO) ? FLOAT_DIGITS : precision,
				&is_negative, &num_buf[1], &s_len);
		    if (is_negative)
			prefix_char = '-';
		    else if (print_sign)
			prefix_char = '+';
		    else if (print_blank)
			prefix_char = ' ';
		}
	        break;
d843 1
a843 8
	    	if (var_type == IS_QUAD)
		    *(va_arg(ap, widest_int *)) = cc;
		else if (var_type == IS_LONG)
		    *(va_arg(ap, long *)) = cc;
		else if (var_type == IS_SHORT)
		    *(va_arg(ap, short *)) = cc;
		else
		    *(va_arg(ap, int *)) = cc;
d853 3
a855 4
		     * If the pointer size is equal to or smaller than the size
		     * of the largest unsigned int, we convert the pointer to a
		     * hex number, otherwise we print "%p" to indicate that we
		     * don't handle "%p".
d858 5
a862 13
#ifdef AP_VOID_P_IS_QUAD
		    if (sizeof(void *) <= sizeof(u_widest_int)) {
		    	ui_quad = (u_widest_int) va_arg(ap, void *);
			s = conv_p2_quad(ui_quad, 4, 'x',
				&num_buf[NUM_BUF_SIZE], &s_len);
		    }
#else
		    if (sizeof(void *) <= sizeof(u_wide_int)) {
		    	ui_num = (u_wide_int) va_arg(ap, void *);
			s = conv_p2(ui_num, 4, 'x',
				&num_buf[NUM_BUF_SIZE], &s_len);
		    }
#endif
a976 4
    if (sp >= bep) {
	if (flush_func(vbuff))
	    return -1;
    }
d990 1
a990 1
API_EXPORT_NONSTD(int) ap_snprintf(char *buf, size_t len, const char *format,...)
@


1.1.1.3
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@d1161 4
a1164 1

@


1.1.1.4
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
d320 1
a320 5
 * to be printed. We don't allow precision to be large
 * enough that we continue past the start of s.
 *
 * NOTE: this makes use of the magic info that s is
 * always based on num_buf with a size of NUM_BUF_SIZE.
d323 2
a324 3
    if ( adjust ) {					\
        int p = precision < NUM_BUF_SIZE - 1 ? precision : NUM_BUF_SIZE - 1; \
	while ( s_len < p )				\
d328 1
a328 2
	}						\
    }
d761 4
@


