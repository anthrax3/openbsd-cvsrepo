head	1.17;
access;
symbols
	OPENBSD_5_5:1.16.0.26
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.22
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.20
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.18
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.16
	OPENBSD_5_0:1.16.0.14
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.12
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.10
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.6
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.8
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.15.0.14
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.12
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.10
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.8
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.5
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.4
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.3
	apache_1_3_27:1.1.1.3
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2014.04.22.14.47.26;	author henning;	state dead;
branches;
next	1.16;

1.16
date	2008.05.14.09.25.38;	author mbalmer;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.09.12.13.10;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.17.18.57.05;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.21.13.11.35;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.19.21.31.16;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.29.02.08.06;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.20.18.06.14;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.29.10.21.43;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.22.18.08;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.25.18.29.48;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.06.29.37;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.03.01.04.28.40;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.01.06.13;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	98.10.11.19.45.14;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.40;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.40;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.28.49;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.07.19.48.13;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.21.12.53.39;	author henning;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.17.17.03.22;	author henning;	state Exp;
branches;
next	;


desc
@@


1.17
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*	$OpenBSD: http_request.c,v 1.16 2008/05/14 09:25:38 mbalmer Exp $ */

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/*
 * http_request.c: functions to get and process requests
 *
 * Rob McCool 3/21/93
 *
 * Thoroughly revamped by rst for Apache.  NB this file reads
 * best from the bottom up.
 *
 */

#define CORE_PRIVATE
#include "httpd.h"
#include "http_config.h"
#include "http_request.h"
#include "http_core.h"
#include "http_protocol.h"
#include "http_conf_globals.h"		/* for ap_extended_status */
#include "http_log.h"
#include "http_main.h"
#include "scoreboard.h"
#include "fnmatch.h"

/*****************************************************************
 *
 * Getting and checking directory configuration.  Also checks the
 * FollowSymlinks and FollowSymOwner stuff, since this is really the
 * only place that can happen (barring a new mid_dir_walk callout).
 *
 * We can't do it as an access_checker module function which gets
 * called with the final per_dir_config, since we could have a directory
 * with FollowSymLinks disabled, which contains a symlink to another
 * with a .htaccess file which turns FollowSymLinks back on --- and
 * access in such a case must be denied.  So, whatever it is that
 * checks FollowSymLinks needs to know the state of the options as
 * they change, all the way down.
 */

/*
 * We don't want people able to serve up pipes, or unix sockets, or other
 * scary things.  Note that symlink tests are performed later.
 */
static int
check_safe_file(request_rec *r)
{
	if (r->finfo.st_mode == 0		 /* doesn't exist */
	    || S_ISDIR(r->finfo.st_mode)
	    || S_ISREG(r->finfo.st_mode)
	    || S_ISLNK(r->finfo.st_mode))
		return OK;

	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
	    "object is not a file, directory or symlink: %s", r->filename);
	return HTTP_FORBIDDEN;
}


static int
check_symlinks(char *d, int opts)
{
	struct stat lfi, fi;
	char *lastp;
	int res;

	if (opts & OPT_SYM_LINKS)
		return OK;

	/*
	 * Strip trailing '/', if any, off what we're checking; trailing
	 * slashes make some systems follow symlinks to directories even in
	 * lstat(). After we've done the lstat, put it back.  Also, don't
	 * bother checking '/' at all...
	 * 
	 * Note that we don't have to worry about multiple slashes here
	 * because of no2slash() below...
	 */

	lastp = d + strlen(d) - 1;
	if (lastp == d)
		return OK;	/* Root directory, '/' */

	if (*lastp == '/')
		*lastp = '\0';
	else
		lastp = NULL;

	res = lstat(d, &lfi);

	if (lastp)
		*lastp = '/';

	/*
	 * Note that we don't reject accesses to nonexistent files (multiviews
	 * or the like may cons up a way to run the transaction anyway)...
	 */

	if (!(res >= 0) || !S_ISLNK(lfi.st_mode))
		return OK;

	/* OK, it's a symlink.  May still be OK with OPT_SYM_OWNER */
	if (!(opts & OPT_SYM_OWNER))
		return HTTP_FORBIDDEN;

	if (stat(d, &fi) < 0)
		return HTTP_FORBIDDEN;

	return (fi.st_uid == lfi.st_uid) ? OK : HTTP_FORBIDDEN;

}

/* Dealing with the file system to get PATH_INFO */
static int
get_path_info(request_rec *r)
{
	char *cp;
	char *path = r->filename;
	char *end = &path[strlen(path)];
	char *last_cp = NULL;
	int rv;

	if (r->finfo.st_mode)
		/* assume path_info already set */
		return OK;

	/* Advance over trailing slashes ... NOT part of filename 
	 * if file is not a UNC name (Win32 only).
	 */
	for (cp = end; cp > path && cp[-1] == '/'; --cp)
		continue;

	while (cp > path) {

		/* See if the pathname ending here exists... */

		*cp = '\0';

		/* We must not stat() filenames that may cause os-specific
		 * system problems, such as "/file/aux" on DOS-abused
		 * filesystems. So pretend that they do not exist by returning
		 * an ENOENT error. This will force us to drop that part of
		 * the path and keep looking back for a "real" file that
		 * exists, while still allowing the "invalid" path parts within
		 * the PATH_INFO.
		 */
		if (!ap_os_is_filename_valid(path)) {
			errno = ENOENT;
			rv = -1;
		} else {
			errno = 0;
			rv = stat(path, &r->finfo);
		}

		if (cp != end)
			*cp = '/';

		if (!rv) {

			/*
			 * Aha!  Found something.  If it was a
			 * directory, we will search contents of
			 * that directory for a multi_match, so the
			 * PATH_INFO argument starts with the
			 * component after that.
			 */
			if (S_ISDIR(r->finfo.st_mode) && last_cp) {
				r->finfo.st_mode = 0;   /* No such file... */
				cp = last_cp;
			}

			r->path_info = ap_pstrdup(r->pool, cp);
			*cp = '\0';
			return OK;
		}
		/* must set this to zero, some stat()s may have corrupted it
		 * even if they returned an error.
		 */
		r->finfo.st_mode = 0;
		if (errno == ENOENT || errno == ENOTDIR) {
			last_cp = cp;

			while (--cp > path && *cp != '/')
				continue;

			while (cp > path && cp[-1] == '/')
				--cp;
		} else {
			if (errno == EACCES)
				ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
				    "access to %s failed because search "
				    "permissions are missing on a component "
				    "of the path", r->uri);
			else
				ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
				    "access to %s failed", r->uri);
			return HTTP_FORBIDDEN;
		}
	}
	return OK;
}

static int
directory_walk(request_rec *r)
{
	core_server_config *sconf =
	    ap_get_module_config(r->server->module_config, &core_module);
	void *per_dir_defaults = r->server->lookup_defaults;
	void **sec = (void **)sconf->sec->elts;
	int num_sec = sconf->sec->nelts;
	char *test_filename;
	char *test_dirname;
	int res;
	unsigned i, num_dirs;
	int j, test_filename_len;

	/*
	 * Are we dealing with a file? If not, we can (hopefuly)
	 * safely assume we have a handler that doesn't require one,
	 * but for safety's sake, and so we have something find_types()
	 * can get something out of, fake one. But don't run through
	 * the directory entries.
	 */

	if (r->filename == NULL) {
		r->filename = ap_pstrdup(r->pool, r->uri);
		r->finfo.st_mode = 0;   /* Not really a file... */
		r->per_dir_config = per_dir_defaults;

		return OK;
	}

	/*
	 * Go down the directory hierarchy.  Where we have to check
	 * for symlinks, do so.  Where a .htaccess file has permission
	 * to override anything, try to find one.  If either of these
	 * things fails, we could poke around, see why, and adjust
	 * the lookup_rec accordingly --- this might save us a call
	 * to get_path_info (with the attendant stat()s); however,
	 * for the moment, that's not worth the trouble.
	 *
	 * Fake filenames (i.e. proxy:) only match Directory sections.
	 */
	if (!ap_os_is_path_absolute(r->filename)) {
		void *this_conf, *entry_config;
		core_dir_config *entry_core;
		char *entry_dir;

		for (j = 0; j < num_sec; ++j) {

			entry_config = sec[j];

			entry_core = (core_dir_config *)
			    ap_get_module_config(entry_config, &core_module);
			entry_dir = entry_core->d;

			this_conf = NULL;
			if (entry_core->r) {
				if (!ap_regexec(entry_core->r, r->filename, 0,
				    NULL, 0))
					this_conf = entry_config;

			} else if (entry_core->d_is_fnmatch) {
				if (!ap_fnmatch(entry_dir, r->filename, 0))
					this_conf = entry_config;
			} else if (!strncmp(r->filename, entry_dir,
			    strlen(entry_dir)))
				this_conf = entry_config;

			if (this_conf)
				per_dir_defaults =
				    ap_merge_per_dir_configs(r->pool,
				    per_dir_defaults, this_conf);
		}

		r->per_dir_config = per_dir_defaults;

		return OK;
	}

	r->filename   = ap_os_case_canonical_filename(r->pool, r->filename);

	res = get_path_info(r);
	if (res != OK)
		return res;

	r->case_preserved_filename = r->filename;

	r->filename   = ap_os_canonical_filename(r->pool, r->filename);

	test_filename = ap_pstrdup(r->pool, r->filename);

	ap_no2slash(test_filename);
	num_dirs = ap_count_dirs(test_filename);

	if (!ap_os_is_filename_valid(r->filename) &&
	    !(r->method_number == M_OPTIONS && !strcmp(r->uri, "*"))) {
		ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
		    "Filename is not valid: %s", r->filename);
		return HTTP_FORBIDDEN;
	}

	if ((res = check_safe_file(r)))
		return res;

	test_filename_len = strlen(test_filename);
	if (test_filename[test_filename_len - 1] == '/')
		--num_dirs;

	if (S_ISDIR(r->finfo.st_mode))
		++num_dirs;

	/*
	 * We will use test_dirname as scratch space while we build directory
	 * names during the walk.  Profiling shows directory_walk to be a busy
	 * function so we try to avoid allocating lots of extra memory here.
	 * We need 2 extra bytes, one for trailing \0 and one because
	 * make_dirstr_prefix will add potentially one extra /.
	 */
	test_dirname = ap_palloc(r->pool, test_filename_len + 2);


	/* Normal File Systems are rooted at / */
	i = 1;

	/* j keeps track of which section we're on, see
	 * core_reorder_directories */
	j = 0;
	for (; i <= num_dirs; ++i) {
		int overrides_here;
		core_dir_config *core_dir = (core_dir_config *)
		    ap_get_module_config(per_dir_defaults, &core_module);

		/*
		 * XXX: this could be made faster by only copying the next
		 * component rather than copying the entire thing all over.
		 */
		ap_make_dirstr_prefix(test_dirname, test_filename, i);

		/*
		 * Do symlink checks first, because they are done with the
		 * permissions appropriate to the *parent* directory...
		 */

		if ((res = check_symlinks(test_dirname, core_dir->opts))) {
			ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
			    "Symbolic link not allowed: %s", test_dirname);
			return res;
		}

		/*
		 * Begin *this* level by looking for matching <Directory> sections
		 * from access.conf.
		 */

		for (; j < num_sec; ++j) {
			void *entry_config = sec[j];
			core_dir_config *entry_core;
			char *entry_dir;
			void *this_conf;

			entry_core = (core_dir_config *)
			    ap_get_module_config(entry_config, &core_module);
			entry_dir = entry_core->d;

			if (entry_core->r
			    || !ap_os_is_path_absolute(entry_dir)
			    || entry_core->d_components > i)
				break;

			this_conf = NULL;
			if (entry_core->d_is_fnmatch) {
				if (!ap_fnmatch(entry_dir, test_dirname,
				    FNM_PATHNAME))
					this_conf = entry_config;
			} else if (!strcmp(test_dirname, entry_dir))
				this_conf = entry_config;

			if (this_conf) {
				per_dir_defaults =
				    ap_merge_per_dir_configs(r->pool,
														 per_dir_defaults,
														 this_conf);
				core_dir = (core_dir_config *)
				    ap_get_module_config(per_dir_defaults,
				    &core_module);
			}
		}
		overrides_here = core_dir->override;

		/* If .htaccess files are enabled, check for one. */

		if (overrides_here) {
			void *htaccess_conf = NULL;

			res = ap_parse_htaccess(&htaccess_conf, r,
			    overrides_here, ap_pstrdup(r->pool, test_dirname),
			    sconf->access_name);
			if (res)
				return res;

			if (htaccess_conf) {
				per_dir_defaults =
				    ap_merge_per_dir_configs(r->pool,
				    per_dir_defaults,
															htaccess_conf);
				r->per_dir_config = per_dir_defaults;
			}
		}
	}

	/*
	 * There's two types of IS_SPECIAL sections (see http_core.c), and
	 * we've already handled the proxy:-style stuff.  Now we'll deal with
	 * the regexes.
	 */
	for (; j < num_sec; ++j) {
		void *entry_config = sec[j];
		core_dir_config *entry_core;

		entry_core = (core_dir_config *)
		    ap_get_module_config(entry_config, &core_module);

		if (entry_core->r) {
			if (!ap_regexec(entry_core->r, test_dirname, 0, NULL,
			    REG_NOTEOL))
				per_dir_defaults =
				    ap_merge_per_dir_configs(r->pool,
				    per_dir_defaults, entry_config);
		}
	}
	r->per_dir_config = per_dir_defaults;

	/*
	 * Symlink permissions are determined by the parent.  If the request is
	 * for a directory then applying the symlink test here would use the
	 * permissions of the directory as opposed to its parent.  Consider a
	 * symlink pointing to a dir with a .htaccess disallowing symlinks.  If
	 * you access /symlink (or /symlink/) you would get a 403 without this
	 * S_ISDIR test.  But if you accessed /symlink/index.html, for example,
	 * you would *not* get the 403.
	 */
	if (!S_ISDIR(r->finfo.st_mode)
	    && (res = check_symlinks(r->filename, ap_allow_options(r)))) {
		ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
		     "Symbolic link not allowed: %s", r->filename);
		return res;
	}
	return OK;  /* Can only "fail" if access denied by the
		     * symlink goop. */
}

static int
location_walk(request_rec *r)
{
	core_server_config *sconf =
	     ap_get_module_config(r->server->module_config, &core_module);
	void *per_dir_defaults = r->per_dir_config;
	void **url = (void **) sconf->sec_url->elts;
	int len, num_url = sconf->sec_url->nelts;
	char *test_location;
	void *this_conf, *entry_config;
	core_dir_config *entry_core;
	char *entry_url;
	int j;

	if (!num_url)
		return OK;

	/* Location and LocationMatch differ on their behaviour w.r.t. multiple
	 * slashes.  Location matches multiple slashes with a single slash,
	 * LocationMatch doesn't.  An exception, for backwards brokenness is
	 * absoluteURIs... in which case neither match multiple slashes.
	 */
	if (r->uri[0] != '/')
		test_location = r->uri;
	else {
		test_location = ap_pstrdup(r->pool, r->uri);
		ap_no2slash(test_location);
	}

	/* Go through the location entries, and check for matches. */

	/* we apply the directive sections in some order;
	 * should really try them with the most general first.
	 */
	for (j = 0; j < num_url; ++j) {

		entry_config = url[j];

		entry_core = (core_dir_config *)
		    ap_get_module_config(entry_config, &core_module);
		entry_url = entry_core->d;

		len = strlen(entry_url);

		this_conf = NULL;

		if (entry_core->r) {
			if (!ap_regexec(entry_core->r, r->uri, 0, NULL, 0))
				this_conf = entry_config;
		} else if (entry_core->d_is_fnmatch) {
			if (!ap_fnmatch(entry_url, test_location, FNM_PATHNAME))
				this_conf = entry_config;
		} else if (!strncmp(test_location, entry_url, len) &&
		    (entry_url[len - 1] == '/' ||
		    test_location[len] == '/' || test_location[len] == '\0'))
			this_conf = entry_config;

		if (this_conf)
			per_dir_defaults = ap_merge_per_dir_configs(r->pool,
			    per_dir_defaults, this_conf);
	}
	r->per_dir_config = per_dir_defaults;

	return OK;
}

static int
file_walk(request_rec *r)
{
	core_dir_config *conf =
	    ap_get_module_config(r->per_dir_config, &core_module);
	void *per_dir_defaults = r->per_dir_config;
	void **file = (void **) conf->sec->elts;
	int num_files = conf->sec->nelts;
	char *test_file;

	/* get the basename */
	test_file = strrchr(r->filename, '/');
	if (test_file == NULL)
		test_file = r->filename;
	else
		++test_file;

	/* Go through the file entries, and check for matches. */

	if (num_files) {
		void *this_conf, *entry_config;
		core_dir_config *entry_core;
		char *entry_file;
		int j;

		/* we apply the directive sections in some order;
		 * should really try them with the most general first.
		 */
		for (j = 0; j < num_files; ++j) {

			entry_config = file[j];

			entry_core = (core_dir_config *)
			     ap_get_module_config(entry_config, &core_module);
			entry_file = entry_core->d;

			this_conf = NULL;

			if (entry_core->r) {
				if (!ap_regexec(entry_core->r, test_file, 0,
				    NULL, 0))
					this_conf = entry_config;
			} else if (entry_core->d_is_fnmatch) {
				if (!ap_fnmatch(entry_file, test_file,
				    FNM_PATHNAME))
					this_conf = entry_config;
			} else if (!strcmp(test_file, entry_file))
				this_conf = entry_config;

			if (this_conf)
				per_dir_defaults =
				    ap_merge_per_dir_configs(r->pool,
				    per_dir_defaults, this_conf);
		}
		r->per_dir_config = per_dir_defaults;
	}
	return OK;
}

/*****************************************************************
 *
 * The sub_request mechanism.
 *
 * Fns to look up a relative URI from, e.g., a map file or SSI document.
 * These do all access checks, etc., but don't actually run the transaction
 * ... use run_sub_req below for that.  Also, be sure to use destroy_sub_req
 * as appropriate if you're likely to be creating more than a few of these.
 * (An early Apache version didn't destroy the sub_reqs used in directory
 * indexing.  The result, when indexing a directory with 800-odd files in
 * it, was massively excessive storage allocation).
 *
 * Note more manipulation of protocol-specific vars in the request
 * structure...
 */

static request_rec *
make_sub_request(const request_rec *r)
{
	pool *rrp = ap_make_sub_pool(r->pool);
	request_rec *rr = ap_pcalloc(rrp, sizeof(request_rec));

	rr->pool = rrp;
	return rr;
}

API_EXPORT(request_rec *)
ap_sub_req_method_uri(const char *method, const char *new_file,
    const request_rec *r)
{
	request_rec *rnew;
	int res;
	char *udir;

	rnew = make_sub_request(r);
	rnew->hostname = r->hostname;
	rnew->request_time = r->request_time;
	rnew->connection = r->connection;
	rnew->server = r->server;
	rnew->request_config = ap_create_request_config(rnew->pool);
	rnew->htaccess = r->htaccess;
	rnew->per_dir_config = r->server->lookup_defaults;

	ap_set_sub_req_protocol(rnew, r);

	/* would be nicer to pass "method" to ap_set_sub_req_protocol */
	rnew->method = method;
	rnew->method_number = ap_method_number_of(method);

	if (new_file[0] == '/')
		ap_parse_uri(rnew, new_file);
	else {
		udir = ap_make_dirstr_parent(rnew->pool, r->uri);
		udir = ap_escape_uri(rnew->pool, udir);	/* re-escape it */
		ap_parse_uri(rnew,
		    ap_make_full_path(rnew->pool, udir, new_file));
	}

	/* We cannot return NULL without violating the API. So just turn this
	 * subrequest into a 500 to indicate the failure. */
	if (ap_is_recursion_limit_exceeded(r)) {
		rnew->status = HTTP_INTERNAL_SERVER_ERROR;
		return rnew;
	}

	res = ap_unescape_url(rnew->uri);
	if (res) {
		rnew->status = res;
		return rnew;
	}

	ap_getparents(rnew->uri);

	if ((res = location_walk(rnew))) {
		rnew->status = res;
		return rnew;
	}

	res = ap_translate_name(rnew);
	if (res) {
		rnew->status = res;
		return rnew;
	}

	/*
	 * We could be clever at this point, and avoid calling directory_walk,
	 * etc. However, we'd need to test that the old and new filenames
	 * contain the same directory components, so it would require
	 * duplicating the start of translate_name. Instead we rely on the
	 * cache of .htaccess results.
	 *
	 * NB: directory_walk() clears the per_dir_config, so we don't inherit
	 * from location_walk() above
	 */
	/* XXX: This should be display a we bit better... */
	if ((res = directory_walk(rnew))
	    || (res = file_walk(rnew))
	    || (res = location_walk(rnew))
	    || ((ap_satisfies(rnew) == SATISFY_ALL
	    || ap_satisfies(rnew) == SATISFY_NOSPEC)
		? ((res = ap_check_access(rnew))
			   || (ap_some_auth_required(rnew)
				   && ((res = ap_check_user_id(rnew))
					   || (res = ap_check_auth(rnew)))))
			: ((res = ap_check_access(rnew))
			   && (!ap_some_auth_required(rnew)
				   || ((res = ap_check_user_id(rnew))
					   || (res = ap_check_auth(rnew)))))
		   )
		|| (res = ap_find_types(rnew))
		|| (res = ap_run_fixups(rnew))
	    ) {
		rnew->status = res;
	}
	return rnew;
}

API_EXPORT(request_rec *)
ap_sub_req_lookup_uri(const char *new_file, const request_rec *r)
{
	return ap_sub_req_method_uri("GET", new_file, r);
}

API_EXPORT(request_rec *)
ap_sub_req_lookup_file(const char *new_file, const request_rec *r)
{
	request_rec *rnew;
	int res;
	char *fdir;

	rnew = make_sub_request(r);
	rnew->hostname = r->hostname;
	rnew->request_time = r->request_time;
	rnew->connection = r->connection;
	rnew->server = r->server;
	rnew->request_config = ap_create_request_config(rnew->pool);
	rnew->htaccess = r->htaccess;

	ap_set_sub_req_protocol(rnew, r);
	fdir = ap_make_dirstr_parent(rnew->pool, r->filename);

	/* We cannot return NULL without violating the API. So just turn this
	 * subrequest into a 500. */
	if (ap_is_recursion_limit_exceeded(r)) {
		rnew->status = HTTP_INTERNAL_SERVER_ERROR;
		return rnew;
	}

	/*
	 * Check for a special case... if there are no '/' characters in
	 * new_file at all, then we are looking at a relative lookup in the
	 * same directory. That means we won't have to redo directory_walk,
	 * and we may not even have to redo access checks.
	 */

	if (strchr(new_file, '/') == NULL) {
		char *udir = ap_make_dirstr_parent(rnew->pool, r->uri);

		rnew->uri = ap_make_full_path(rnew->pool, udir, new_file);
		rnew->filename = ap_make_full_path(rnew->pool, fdir, new_file);
		ap_parse_uri(rnew, rnew->uri);	/* fill in parsed_uri values */
		if (stat(rnew->filename, &rnew->finfo) < 0) {
			rnew->finfo.st_mode = 0;
			/* Special case for filenames which exceed the maximum
			 * limit imposed by the operating system (~1024). These
			 * should NOT be treated like "file not found", because
			 * there is a difference between "the file is not there"
			 * and "the file exists, but you tried to access it
			 * using a path which exceeds the path length limit".
			 * The idea here is to handle DoS attacks with long
			 * runs of //////'s in a graceful and secure manner.
			 */
			if (errno == ENAMETOOLONG) {
				ap_log_rerror(APLOG_MARK, APLOG_CRIT, r,
				    "Possible DoS attempt? Path=%s",
				    r->filename);
				rnew->status = HTTP_FORBIDDEN;
				return rnew;
			}
		}

		if ((res = check_safe_file(rnew))) {
			rnew->status = res;
			return rnew;
		}

		rnew->per_dir_config = r->per_dir_config;

		/*
		 * no matter what, if it's a subdirectory, we need to re-run
		 * directory_walk
		 */
		if (S_ISDIR(rnew->finfo.st_mode)) {
			res = directory_walk(rnew);
			if (!res)
				res = file_walk(rnew);
		} else {
			if ((res = check_symlinks(rnew->filename,
			    ap_allow_options(rnew)))) {
				ap_log_rerror(APLOG_MARK,
				    APLOG_NOERRNO|APLOG_ERR, rnew,
				    "Symbolic link not allowed: %s",
				    rnew->filename);
				rnew->status = res;
				return rnew;
			}
			/*
			 * do a file_walk, if it doesn't change the
			 * per_dir_config then we know that we don't have to
			 * redo all the access checks
			 */
			if ((res = file_walk(rnew))) {
				rnew->status = res;
				return rnew;
			}
			if (rnew->per_dir_config == r->per_dir_config) {
				if ((res = ap_find_types(rnew))
				    || (res = ap_run_fixups(rnew)))
					rnew->status = res;
				return rnew;
			}
		}
	} else {
		/* XXX: @@@@@@: What should be done with the parsed_uri values? */
		ap_parse_uri(rnew, new_file);	/* fill in parsed_uri values */
		/*
		 * XXX: this should be set properly like it is in the same-dir
		 * case but it's actually sometimes to impossible to do it...
		 * because the file may not have a uri associated with it -djg
		 */
		rnew->uri = "INTERNALLY GENERATED file-relative req";
		rnew->filename = ((ap_os_is_path_absolute(new_file)) ?
		    ap_pstrdup(rnew->pool, new_file) :
		    ap_make_full_path(rnew->pool, fdir, new_file));
		rnew->per_dir_config = r->server->lookup_defaults;
		res = directory_walk(rnew);
		if (!res)
			res = file_walk(rnew);
	}

	/* XXX: horrid...*/
	if (res
		|| ((ap_satisfies(rnew) == SATISFY_ALL
			 || ap_satisfies(rnew) == SATISFY_NOSPEC)
			? ((res = ap_check_access(rnew))
			   || (ap_some_auth_required(rnew)
				   && ((res = ap_check_user_id(rnew))
					   || (res = ap_check_auth(rnew)))))
			: ((res = ap_check_access(rnew))
			   && (!ap_some_auth_required(rnew)
				   || ((res = ap_check_user_id(rnew))
					   || (res = ap_check_auth(rnew)))))
		   )
		|| (res = ap_find_types(rnew))
		|| (res = ap_run_fixups(rnew))
	   ) {
		rnew->status = res;
	}
	return rnew;
}

API_EXPORT(int)
ap_run_sub_req(request_rec *r)
{
	int retval = ap_invoke_handler(r);
	ap_finalize_sub_req_protocol(r);
	return retval;
}

API_EXPORT(void)
ap_destroy_sub_req(request_rec *r)
{
	/* Reclaim the space */
	ap_destroy_pool(r->pool);
}

/*****************************************************************
 *
 * Mainline request processing...
 */

API_EXPORT(void)
ap_die(int type, request_rec *r)
{
	int error_index = ap_index_of_response(type);
	char *custom_response = ap_response_code_string(r, error_index);
	int recursive_error = 0;

	if (type == DONE) {
		ap_finalize_request_protocol(r);
		return;
	}

	/*
	 * The following takes care of Apache redirects to custom response URLs
	 * Note that if we are already dealing with the response to some other
	 * error condition, we just report on the original error, and give up on
	 * any attempt to handle the other thing "intelligently"...
	 */

	if (r->status != HTTP_OK) {
		recursive_error = type;

		while (r->prev && (r->prev->status != HTTP_OK))
			r = r->prev;	/* Get back to original error */

		type = r->status;
		custom_response = NULL; /* Do NOT retry the custom thing! */
	}

	r->status = type;

	/*
	 * This test is done here so that none of the auth modules needs to know
	 * about proxy authentication.  They treat it like normal auth, and then
	 * we tweak the status.
	 */
	if (r->status == AUTH_REQUIRED && r->proxyreq == STD_PROXY)
		r->status = HTTP_PROXY_AUTHENTICATION_REQUIRED;

	/*
	 * If we want to keep the connection, be sure that the request body
	 * (if any) has been read.
	 */
	if ((r->status != HTTP_NOT_MODIFIED) && (r->status != HTTP_NO_CONTENT)
	    && !ap_status_drops_connection(r->status)
	    && r->connection && (r->connection->keepalive != -1))
		(void)ap_discard_request_body(r);

	/*
	 * Two types of custom redirects --- plain text, and URLs. Plain text
	 * has a leading '"', so the URL code, here, is triggered on its absence
	 */

	if (custom_response && custom_response[0] != '"') {

		if (ap_is_url(custom_response)) {
			/*
			 * The URL isn't local, so lets drop through the rest
			 * of this apache code, and continue with the usual
			 * REDIRECT handler. But note that the client will
			 * ultimately see the wrong status...
			 *
			 * Also, before updating r->status, we may need to
			 * ensure that the connection is dropped.  For example,
			 * there may be unread request body that would confuse
			 * us if we try to read another request.
			 */
			if (ap_status_drops_connection(r->status))
				r->connection->keepalive = -1;
			r->status = REDIRECT;
			ap_table_setn(r->headers_out, "Location",
			    custom_response);
		} else if (custom_response[0] == '/') {
			const char *error_notes;
			r->no_local_copy = 1;	/* Do NOT send USE_LOCAL_COPY
						 * for error documents! */
			/*
			 * This redirect needs to be a GET no matter what the
			 * original method was.
			 */
			ap_table_setn(r->subprocess_env, "REQUEST_METHOD",
			    r->method);

			/*
			 * Provide a special method for modules to communicate
			 * more informative (than the plain canned) messages to
			 * us. Propagate them to ErrorDocuments via the
			 * ERROR_NOTES variable:
			 */
			if ((error_notes = 
			    ap_table_get(r->notes, "error-notes")) != NULL)
				ap_table_setn(r->subprocess_env, "ERROR_NOTES",
				    error_notes);

			/* 
			 * If it is already a GET or a HEAD, don't change it 
			 * (method_number for GET and HEAD is the same) 
			 */
			if(r->method_number!=M_GET) { 
				r->method = ap_pstrdup(r->pool, "GET");
				r->method_number = M_GET;
			}
			ap_internal_redirect(custom_response, r);
			return;
		} else {
			/*
			 * Dumb user has given us a bad url to redirect to --- 
			 * fake up dying with a recursive server error...
			 */
			recursive_error = SERVER_ERROR;
			ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
			    "Invalid error redirection directive: %s",
			    custom_response);
		}
	}
	ap_send_error_response(r, recursive_error);
}

static void
decl_die(int status, char *phase, request_rec *r)
{
	if (status == DECLINED) {
		ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_CRIT, r,
		    "configuration error:  couldn't %s: %s", phase, r->uri);
		ap_die(SERVER_ERROR, r);
	} else
		ap_die(status, r);
}

API_EXPORT(int)
ap_some_auth_required(request_rec *r)
{
	/* Is there a require line configured for the type of *this* req? */

	const array_header *reqs_arr = ap_requires(r);
	require_line *reqs;
	int i;

	if (!reqs_arr)
		return 0;

	reqs = (require_line *)reqs_arr->elts;

	for (i = 0; i < reqs_arr->nelts; ++i)
		if (reqs[i].method_mask & (1 << r->method_number))
			return 1;

	return 0;
}

static void
process_request_internal(request_rec *r)
{
	int access_status;

	/* Ignore embedded %2F's in path for proxy requests */
	if (r->proxyreq == NOT_PROXY && r->parsed_uri.path) {
		access_status = ap_unescape_url(r->parsed_uri.path);
		if (access_status) {
			ap_die(access_status, r);
			return;
		}
	}

	ap_getparents(r->uri);	 /* OK --- shrinking transformations... */

	if ((access_status = location_walk(r))) {
		ap_die(access_status, r);
		return;
	}

	if ((access_status = ap_translate_name(r))) {
		decl_die(access_status, "translate", r);
		return;
	}

	if (r->proxyreq == NOT_PROXY) {
		/*
		 * We don't want TRACE to run through the normal handler set, we
		 * handle it specially.
		 */
		if (r->method_number == M_TRACE) {
			if ((access_status = ap_send_http_trace(r)))
				ap_die(access_status, r);
			else
				ap_finalize_request_protocol(r);
			return;
		}
	}

	if (r->proto_num > HTTP_VERSION(1,0) && ap_table_get(r->subprocess_env,
	    "downgrade-1.0"))
		r->proto_num = HTTP_VERSION(1,0);

	/*
	 * NB: directory_walk() clears the per_dir_config, so we don't inherit
	 * from location_walk() above
	 */

	if ((access_status = directory_walk(r))) {
		ap_die(access_status, r);
		return;
	}

	if ((access_status = file_walk(r))) {
		ap_die(access_status, r);
		return;
	}

	if ((access_status = location_walk(r))) {
		ap_die(access_status, r);
		return;
	}

	if ((access_status = ap_header_parse(r))) {
		ap_die(access_status, r);
		return;
	}

	switch (ap_satisfies(r)) {
	case SATISFY_ALL:
	case SATISFY_NOSPEC:
		if ((access_status = ap_check_access(r)) != 0) {
			decl_die(access_status, "check access", r);
			return;
		}
		if (ap_some_auth_required(r)) {
			if (((access_status = ap_check_user_id(r)) != 0)
			    || !ap_auth_type(r)) {
				decl_die(access_status, ap_auth_type(r)
				    ? "check user.  No user file?"
				    : "perform authentication. AuthType not "
				    "set!", r);
				return;
			}
			if (((access_status = ap_check_auth(r)) != 0)
			    || !ap_auth_type(r)) {
				decl_die(access_status, ap_auth_type(r)
				    ? "check access.  No groups file?"
				    : "perform authentication. AuthType not "
				    "set!", r);
				return;
			}
		}
		break;
	case SATISFY_ANY:
		if (((access_status = ap_check_access(r)) != 0)) {
			if (!ap_some_auth_required(r)) {
				decl_die(access_status, "check access", r);
				return;
			}
			if (((access_status = ap_check_user_id(r)) != 0)
			    || !ap_auth_type(r)) {
				decl_die(access_status, ap_auth_type(r)
				    ? "check user.  No user file?"
				    : "perform authentication. AuthType not "
				    "set!", r);
				return;
			}
			if (((access_status = ap_check_auth(r)) != 0)
			    || !ap_auth_type(r)) {
				decl_die(access_status, ap_auth_type(r)
				    ? "check access.  No groups file?"
				    : "perform authentication. AuthType not "
				    "set!", r);
				return;
			}
		}
		break;
	}

	if (! (r->proxyreq != NOT_PROXY
	    && r->parsed_uri.scheme != NULL
	    && strcmp(r->parsed_uri.scheme, "http") == 0) ) {
		if ((access_status = ap_find_types(r)) != 0) {
			decl_die(access_status, "find types", r);
			return;
		}
	}

	if ((access_status = ap_run_fixups(r)) != 0) {
		ap_die(access_status, r);
		return;
	}

	if ((access_status = ap_invoke_handler(r)) != 0) {
		ap_die(access_status, r);
		return;
	}

	/* Take care of little things that need to happen when we're done */
	ap_finalize_request_protocol(r);
}

API_EXPORT(void)
ap_process_request(request_rec *r)
{
	int old_stat;

	if (ap_extended_status)
		ap_time_process_request(r->connection->child_num,
		    START_PREQUEST);

	process_request_internal(r);

	old_stat = ap_update_child_status(r->connection->child_num,
	    SERVER_BUSY_LOG, r);

	/*
	 * We want to flush the last packet if this isn't a pipelining
	 * connection *before* we start into logging.  Suppose that the
	 * logging causes a DNS lookup to occur, which may have a high
	 * latency.  If we hold off on this packet, then it'll appear
	 * like the link is stalled when really it's the application
	 * that's stalled.
	 */
	ap_bhalfduplex(r->connection->client);
	ap_log_transaction(r);

	(void)ap_update_child_status(r->connection->child_num, old_stat, r);
	if (ap_extended_status)
		ap_time_process_request(r->connection->child_num,
		    STOP_PREQUEST);
}

static table *
rename_original_env(pool *p, table *t)
{
	array_header *env_arr = ap_table_elts(t);
	table_entry *elts = (table_entry *)env_arr->elts;
	table *new = ap_make_table(p, env_arr->nalloc);
	int i;

	for (i = 0; i < env_arr->nelts; ++i) {
		if (!elts[i].key)
			continue;
		ap_table_setn(new, ap_pstrcat(p, "REDIRECT_", elts[i].key,
		    NULL),  elts[i].val);
	}

	return new;
}

static request_rec *
internal_internal_redirect(const char *new_uri, request_rec *r)
{
	int access_status;
	request_rec *new;

	if (ap_is_recursion_limit_exceeded(r)) {
		ap_die(HTTP_INTERNAL_SERVER_ERROR, r);
		return NULL;
	}

	new = (request_rec *)ap_pcalloc(r->pool, sizeof(request_rec));

	new->connection = r->connection;
	new->server = r->server;
	new->pool = r->pool;

	/*
	 * A whole lot of this really ought to be shared with http_protocol.c...
	 * another missing cleanup.  It's particularly inappropriate to be
	 * setting header_only, etc., here.
	 */

	new->method = r->method;
	new->method_number = r->method_number;
	/* initialize context _BEFORE_ ap_parse_uri() call */
	new->ctx = r->ctx;
	ap_parse_uri(new, new_uri);
	new->request_config = ap_create_request_config(r->pool);
	new->per_dir_config = r->server->lookup_defaults;

	new->prev = r;
	r->next = new;

	/* Inherit the rest of the protocol info... */

	new->the_request = r->the_request;

	new->allowed = r->allowed;

	new->status = r->status;
	new->assbackwards = r->assbackwards;
	new->header_only = r->header_only;
	new->protocol = r->protocol;
	new->proto_num = r->proto_num;
	new->hostname = r->hostname;
	new->request_time = r->request_time;
	new->main = r->main;

	new->headers_in = r->headers_in;
	new->headers_out = ap_make_table(r->pool, 12);
	new->err_headers_out = r->err_headers_out;
	new->subprocess_env = rename_original_env(r->pool, r->subprocess_env);
	new->notes = ap_make_table(r->pool, 5);

	new->htaccess = r->htaccess;
	new->no_cache = r->no_cache;
	new->expecting_100 = r->expecting_100;
	new->no_local_copy = r->no_local_copy;
	new->read_length = r->read_length;	 /* We can only read it once */
	new->vlist_validator = r->vlist_validator;

	ap_table_setn(new->subprocess_env, "REDIRECT_STATUS",
		ap_psprintf(r->pool, "%d", r->status));

	/*
	 * XXX: hmm.  This is because mod_setenvif and mod_unique_id really need
	 * to do their thing on internal redirects as well.  Perhaps this is a
	 * misnamed function.
	 */
	if ((access_status = ap_run_post_read_request(new))) {
		ap_die(access_status, new);
		return NULL;
	}

	return new;
}

API_EXPORT(void)
ap_internal_redirect(const char *new_uri, request_rec *r)
{
	request_rec *new = internal_internal_redirect(new_uri, r);

	if (new)
		process_request_internal(new);
}

/* This function is designed for things like actions or CGI scripts, when
 * using AddHandler, and you want to preserve the content type across
 * an internal redirect.
 */
API_EXPORT(void)
ap_internal_redirect_handler(const char *new_uri, request_rec *r)
{
	request_rec *new = internal_internal_redirect(new_uri, r);

	if (new) {
		if (r->handler)
			new->content_type = r->content_type;
		process_request_internal(new);
	}
}

/*
 * Is it the initial main request, which we only get *once* per HTTP request?
 */
API_EXPORT(int)
ap_is_initial_req(request_rec *r)
{
	return
	    (r->main == NULL)   /* otherwise, this is a sub-request */
	    &&
	    (r->prev == NULL);  /* otherwise, this is an internal redirect */
}

/*
 * Function to set the r->mtime field to the specified value if it's later
 * than what's already there.
 */
API_EXPORT(time_t)
ap_update_mtime(request_rec *r, time_t dependency_mtime)
{
	if (r->mtime < dependency_mtime)
		r->mtime = dependency_mtime;
	return r->mtime;
}
@


1.16
log
@More KNF/readability changes.

no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.15
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d1 2
d77 1
a77 1
#include "http_conf_globals.h"	/* for ap_extended_status */
d102 2
a103 1
static int check_safe_file(request_rec *r)
d105 9
a113 10
    if (r->finfo.st_mode == 0         /* doesn't exist */
        || S_ISDIR(r->finfo.st_mode)
        || S_ISREG(r->finfo.st_mode)
        || S_ISLNK(r->finfo.st_mode)) {
        return OK;
    }
    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                "object is not a file, directory or symlink: %s",
                r->filename);
    return HTTP_FORBIDDEN;
d117 2
a118 1
static int check_symlinks(char *d, int opts)
d120 25
a144 3
    struct stat lfi, fi;
    char *lastp;
    int res;
d146 1
a146 2
    if (opts & OPT_SYM_LINKS)
        return OK;
d148 2
a149 9
    /*
     * Strip trailing '/', if any, off what we're checking; trailing slashes
     * make some systems follow symlinks to directories even in lstat().
     * After we've done the lstat, put it back.  Also, don't bother checking
     * '/' at all...
     * 
     * Note that we don't have to worry about multiple slashes here because of
     * no2slash() below...
     */
d151 4
a154 3
    lastp = d + strlen(d) - 1;
    if (lastp == d)
        return OK;              /* Root directory, '/' */
d156 2
a157 4
    if (*lastp == '/')
        *lastp = '\0';
    else
        lastp = NULL;
d159 3
a161 1
    res = lstat(d, &lfi);
d163 2
a164 2
    if (lastp)
        *lastp = '/';
d166 1
a166 4
    /*
     * Note that we don't reject accesses to nonexistent files (multiviews or
     * the like may cons up a way to run the transaction anyway)...
     */
d168 1
a168 2
    if (!(res >= 0) || !S_ISLNK(lfi.st_mode))
        return OK;
d170 19
a188 1
    /* OK, it's a symlink.  May still be OK with OPT_SYM_OWNER */
d190 1
a190 2
    if (!(opts & OPT_SYM_OWNER))
        return HTTP_FORBIDDEN;
d192 1
a192 2
    if (stat(d, &fi) < 0)
        return HTTP_FORBIDDEN;
d194 1
a194 1
    return (fi.st_uid == lfi.st_uid) ? OK : HTTP_FORBIDDEN;
d196 62
d260 2
a261 3
/* Dealing with the file system to get PATH_INFO
 */
static int get_path_info(request_rec *r)
d263 10
a272 5
    char *cp;
    char *path = r->filename;
    char *end = &path[strlen(path)];
    char *last_cp = NULL;
    int rv;
d274 12
a285 4
    if (r->finfo.st_mode) {
	/* assume path_info already set */
	return OK;
    }
d287 2
d290 10
a299 50
        /* Advance over trailing slashes ... NOT part of filename 
         * if file is not a UNC name (Win32 only).
         */
        for (cp = end; cp > path && cp[-1] == '/'; --cp)
            continue;

    while (cp > path) {

        /* See if the pathname ending here exists... */

        *cp = '\0';

        /* We must not stat() filenames that may cause os-specific system
         * problems, such as "/file/aux" on DOS-abused filesystems.
         * So pretend that they do not exist by returning an ENOENT error.
         * This will force us to drop that part of the path and keep
         * looking back for a "real" file that exists, while still allowing
         * the "invalid" path parts within the PATH_INFO.
         */
        if (!ap_os_is_filename_valid(path)) {
            errno = ENOENT;
            rv = -1;
        }
        else {
            errno = 0;
            rv = stat(path, &r->finfo);
        }

        if (cp != end)
            *cp = '/';

        if (!rv) {

            /*
             * Aha!  Found something.  If it was a directory, we will search
             * contents of that directory for a multi_match, so the PATH_INFO
             * argument starts with the component after that.
             */

            if (S_ISDIR(r->finfo.st_mode) && last_cp) {
                r->finfo.st_mode = 0;   /* No such file... */
                cp = last_cp;
            }

            r->path_info = ap_pstrdup(r->pool, cp);
            *cp = '\0';
            return OK;
        }
	/* must set this to zero, some stat()s may have corrupted it
	 * even if they returned an error.
d301 32
a332 226
	r->finfo.st_mode = 0;
        if (errno == ENOENT || errno == ENOTDIR) {
            last_cp = cp;

            while (--cp > path && *cp != '/')
                continue;

            while (cp > path && cp[-1] == '/')
                --cp;
        }
        else {
            if (errno == EACCES)
                ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                            "access to %s failed because search "
                            "permissions are missing on a component "
                            "of the path", r->uri);
            else
                ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                            "access to %s failed", r->uri);
            return HTTP_FORBIDDEN;
        }
    }
    return OK;
}

static int directory_walk(request_rec *r)
{
    core_server_config *sconf = ap_get_module_config(r->server->module_config,
                                                  &core_module);
    void *per_dir_defaults = r->server->lookup_defaults;
    void **sec = (void **) sconf->sec->elts;
    int num_sec = sconf->sec->nelts;
    char *test_filename;
    char *test_dirname;
    int res;
    unsigned i, num_dirs;
    int j, test_filename_len;

    /*
     * Are we dealing with a file? If not, we can (hopefuly) safely assume we
     * have a handler that doesn't require one, but for safety's sake, and so
     * we have something find_types() can get something out of, fake one. But
     * don't run through the directory entries.
     */

    if (r->filename == NULL) {
        r->filename = ap_pstrdup(r->pool, r->uri);
        r->finfo.st_mode = 0;   /* Not really a file... */
        r->per_dir_config = per_dir_defaults;

        return OK;
    }

    /*
     * Go down the directory hierarchy.  Where we have to check for symlinks,
     * do so.  Where a .htaccess file has permission to override anything,
     * try to find one.  If either of these things fails, we could poke
     * around, see why, and adjust the lookup_rec accordingly --- this might
     * save us a call to get_path_info (with the attendant stat()s); however,
     * for the moment, that's not worth the trouble.
     *
     * Fake filenames (i.e. proxy:) only match Directory sections.
     */

    if (!ap_os_is_path_absolute(r->filename))
    {
        void *this_conf, *entry_config;
        core_dir_config *entry_core;
        char *entry_dir;

        for (j = 0; j < num_sec; ++j) {

            entry_config = sec[j];

            entry_core = (core_dir_config *)
                ap_get_module_config(entry_config, &core_module);
            entry_dir = entry_core->d;

            this_conf = NULL;
            if (entry_core->r) {
                if (!ap_regexec(entry_core->r, r->filename, 0, NULL, 0))
                    this_conf = entry_config;
            }
            else if (entry_core->d_is_fnmatch) {
                if (!ap_fnmatch(entry_dir, r->filename, 0))
                    this_conf = entry_config;
            }
            else if (!strncmp(r->filename, entry_dir, strlen(entry_dir)))
                this_conf = entry_config;

            if (this_conf)
                per_dir_defaults = ap_merge_per_dir_configs(r->pool,
                                                         per_dir_defaults,
                                                         this_conf);
        }

        r->per_dir_config = per_dir_defaults;

        return OK;
    }

    r->filename   = ap_os_case_canonical_filename(r->pool, r->filename);

    res = get_path_info(r);
    if (res != OK) {
        return res;
    }

    r->case_preserved_filename = r->filename;

    r->filename   = ap_os_canonical_filename(r->pool, r->filename);

    test_filename = ap_pstrdup(r->pool, r->filename);

    ap_no2slash(test_filename);
    num_dirs = ap_count_dirs(test_filename);

    if (!ap_os_is_filename_valid(r->filename) &&
        !(r->method_number == M_OPTIONS && !strcmp(r->uri, "*"))) {
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                      "Filename is not valid: %s", r->filename);
        return HTTP_FORBIDDEN;
    }

    if ((res = check_safe_file(r))) {
        return res;
    }

    test_filename_len = strlen(test_filename);
    if (test_filename[test_filename_len - 1] == '/')
        --num_dirs;

    if (S_ISDIR(r->finfo.st_mode))
        ++num_dirs;

    /*
     * We will use test_dirname as scratch space while we build directory
     * names during the walk.  Profiling shows directory_walk to be a busy
     * function so we try to avoid allocating lots of extra memory here.
     * We need 2 extra bytes, one for trailing \0 and one because
     * make_dirstr_prefix will add potentially one extra /.
     */
    test_dirname = ap_palloc(r->pool, test_filename_len + 2);


    /* Normal File Systems are rooted at / */
    i = 1;

    /* j keeps track of which section we're on, see core_reorder_directories */
    j = 0;
    for (; i <= num_dirs; ++i) {
        int overrides_here;
        core_dir_config *core_dir = (core_dir_config *)
            ap_get_module_config(per_dir_defaults, &core_module);

        /*
         * XXX: this could be made faster by only copying the next component
         * rather than copying the entire thing all over.
         */
        ap_make_dirstr_prefix(test_dirname, test_filename, i);

        /*
         * Do symlink checks first, because they are done with the
         * permissions appropriate to the *parent* directory...
         */

        if ((res = check_symlinks(test_dirname, core_dir->opts))) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                        "Symbolic link not allowed: %s", test_dirname);
            return res;
        }

        /*
         * Begin *this* level by looking for matching <Directory> sections
         * from access.conf.
         */

        for (; j < num_sec; ++j) {
            void *entry_config = sec[j];
            core_dir_config *entry_core;
            char *entry_dir;
            void *this_conf;

            entry_core = (core_dir_config *)
                         ap_get_module_config(entry_config, &core_module);
            entry_dir = entry_core->d;

            if (entry_core->r
		|| !ap_os_is_path_absolute(entry_dir)
                || entry_core->d_components > i)
                break;

            this_conf = NULL;
            if (entry_core->d_is_fnmatch) {
                if (!ap_fnmatch(entry_dir, test_dirname, FNM_PATHNAME)) {
                    this_conf = entry_config;
                }
            }
            else if (!strcmp(test_dirname, entry_dir))
                this_conf = entry_config;

            if (this_conf) {
                per_dir_defaults = ap_merge_per_dir_configs(r->pool,
                                                         per_dir_defaults,
                                                         this_conf);
                core_dir = (core_dir_config *)
                           ap_get_module_config(per_dir_defaults, &core_module);
            }
        }
        overrides_here = core_dir->override;

        /* If .htaccess files are enabled, check for one. */

        if (overrides_here) {
            void *htaccess_conf = NULL;

            res = ap_parse_htaccess(&htaccess_conf, r, overrides_here,
                                 ap_pstrdup(r->pool, test_dirname),
                                 sconf->access_name);
            if (res)
                return res;

            if (htaccess_conf) {
                per_dir_defaults = ap_merge_per_dir_configs(r->pool,
							    per_dir_defaults,
							    htaccess_conf);
a333 57
	    }
        }
    }

    /*
     * There's two types of IS_SPECIAL sections (see http_core.c), and we've
     * already handled the proxy:-style stuff.  Now we'll deal with the
     * regexes.
     */
    for (; j < num_sec; ++j) {
        void *entry_config = sec[j];
        core_dir_config *entry_core;

        entry_core = (core_dir_config *)
                     ap_get_module_config(entry_config, &core_module);

        if (entry_core->r) {
            if (!ap_regexec(entry_core->r, test_dirname, 0, NULL, REG_NOTEOL)) {
                per_dir_defaults =
                    ap_merge_per_dir_configs(r->pool, per_dir_defaults,
                                          entry_config);
            }
        }
    }
    r->per_dir_config = per_dir_defaults;

    /*
     * Symlink permissions are determined by the parent.  If the request is
     * for a directory then applying the symlink test here would use the
     * permissions of the directory as opposed to its parent.  Consider a
     * symlink pointing to a dir with a .htaccess disallowing symlinks.  If
     * you access /symlink (or /symlink/) you would get a 403 without this
     * S_ISDIR test.  But if you accessed /symlink/index.html, for example,
     * you would *not* get the 403.
     */
    if (!S_ISDIR(r->finfo.st_mode)
        && (res = check_symlinks(r->filename, ap_allow_options(r)))) {
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                    "Symbolic link not allowed: %s", r->filename);
        return res;
    }
    return OK;                  /* Can only "fail" if access denied by the
                                 * symlink goop. */
}

static int location_walk(request_rec *r)
{
    core_server_config *sconf = ap_get_module_config(r->server->module_config,
                                                  &core_module);
    void *per_dir_defaults = r->per_dir_config;
    void **url = (void **) sconf->sec_url->elts;
    int len, num_url = sconf->sec_url->nelts;
    char *test_location;
    void *this_conf, *entry_config;
    core_dir_config *entry_core;
    char *entry_url;
    int j;
d335 174
a508 3
    if (!num_url) {
	return OK;
    }
d510 27
a536 38
    /* Location and LocationMatch differ on their behaviour w.r.t. multiple
     * slashes.  Location matches multiple slashes with a single slash,
     * LocationMatch doesn't.  An exception, for backwards brokenness is
     * absoluteURIs... in which case neither match multiple slashes.
     */
    if (r->uri[0] != '/') {
	test_location = r->uri;
    }
    else {
	test_location = ap_pstrdup(r->pool, r->uri);
	ap_no2slash(test_location);
    }

    /* Go through the location entries, and check for matches. */

    /* we apply the directive sections in some order;
     * should really try them with the most general first.
     */
    for (j = 0; j < num_url; ++j) {

	entry_config = url[j];

	entry_core = (core_dir_config *)
	    ap_get_module_config(entry_config, &core_module);
	entry_url = entry_core->d;

	len = strlen(entry_url);

	this_conf = NULL;

	if (entry_core->r) {
	    if (!ap_regexec(entry_core->r, r->uri, 0, NULL, 0))
		this_conf = entry_config;
	}
	else if (entry_core->d_is_fnmatch) {
	    if (!ap_fnmatch(entry_url, test_location, FNM_PATHNAME)) {
		this_conf = entry_config;
	    }
d538 25
a562 1
	else if (!strncmp(test_location, entry_url, len) &&
d564 2
a565 2
		test_location[len] == '/' || test_location[len] == '\0'))
	    this_conf = entry_config;
d567 66
a632 68
	if (this_conf)
	    per_dir_defaults = ap_merge_per_dir_configs(r->pool,
					    per_dir_defaults, this_conf);
    }
    r->per_dir_config = per_dir_defaults;

    return OK;
}

static int file_walk(request_rec *r)
{
    core_dir_config *conf = ap_get_module_config(r->per_dir_config, &core_module);
    void *per_dir_defaults = r->per_dir_config;
    void **file = (void **) conf->sec->elts;
    int num_files = conf->sec->nelts;
    char *test_file;

    /* get the basename */
    test_file = strrchr(r->filename, '/');
    if (test_file == NULL) {
	test_file = r->filename;
    }
    else {
	++test_file;
    }

    /* Go through the file entries, and check for matches. */

    if (num_files) {
        void *this_conf, *entry_config;
        core_dir_config *entry_core;
        char *entry_file;
        int j;

        /* we apply the directive sections in some order;
         * should really try them with the most general first.
         */
        for (j = 0; j < num_files; ++j) {

            entry_config = file[j];

            entry_core = (core_dir_config *)
                         ap_get_module_config(entry_config, &core_module);
            entry_file = entry_core->d;

            this_conf = NULL;

            if (entry_core->r) {
                if (!ap_regexec(entry_core->r, test_file, 0, NULL, 0))
                    this_conf = entry_config;
            }
            else if (entry_core->d_is_fnmatch) {
                if (!ap_fnmatch(entry_file, test_file, FNM_PATHNAME)) {
                    this_conf = entry_config;
                }
            }
            else if (!strcmp(test_file, entry_file)) {
                this_conf = entry_config;
	    }

            if (this_conf)
                per_dir_defaults = ap_merge_per_dir_configs(r->pool,
                                                         per_dir_defaults,
                                                         this_conf);
        }
        r->per_dir_config = per_dir_defaults;
    }
    return OK;
d651 2
a652 1
static request_rec *make_sub_request(const request_rec *r)
d654 2
a655 2
    pool *rrp = ap_make_sub_pool(r->pool);
    request_rec *rr = ap_pcalloc(rrp, sizeof(request_rec));
d657 2
a658 2
    rr->pool = rrp;
    return rr;
d661 233
a893 237
API_EXPORT(request_rec *) ap_sub_req_method_uri(const char *method,
                                                const char *new_file,
                                                const request_rec *r)
{
    request_rec *rnew;
    int res;
    char *udir;

    rnew = make_sub_request(r);
    rnew->hostname       = r->hostname;
    rnew->request_time   = r->request_time;
    rnew->connection     = r->connection;
    rnew->server         = r->server;
    rnew->request_config = ap_create_request_config(rnew->pool);
    rnew->htaccess       = r->htaccess;
    rnew->per_dir_config = r->server->lookup_defaults;

    ap_set_sub_req_protocol(rnew, r);

    /* would be nicer to pass "method" to ap_set_sub_req_protocol */
    rnew->method = method;
    rnew->method_number = ap_method_number_of(method);

    if (new_file[0] == '/')
        ap_parse_uri(rnew, new_file);
    else {
        udir = ap_make_dirstr_parent(rnew->pool, r->uri);
        udir = ap_escape_uri(rnew->pool, udir);    /* re-escape it */
        ap_parse_uri(rnew, ap_make_full_path(rnew->pool, udir, new_file));
    }

    /* We cannot return NULL without violating the API. So just turn this
     * subrequest into a 500 to indicate the failure. */
    if (ap_is_recursion_limit_exceeded(r)) {
        rnew->status = HTTP_INTERNAL_SERVER_ERROR;
        return rnew;
    }

    res = ap_unescape_url(rnew->uri);
    if (res) {
        rnew->status = res;
        return rnew;
    }

    ap_getparents(rnew->uri);

    if ((res = location_walk(rnew))) {
        rnew->status = res;
        return rnew;
    }

    res = ap_translate_name(rnew);
    if (res) {
        rnew->status = res;
        return rnew;
    }

    /*
     * We could be clever at this point, and avoid calling directory_walk,
     * etc. However, we'd need to test that the old and new filenames contain
     * the same directory components, so it would require duplicating the
     * start of translate_name. Instead we rely on the cache of .htaccess
     * results.
     *
     * NB: directory_walk() clears the per_dir_config, so we don't inherit
     * from location_walk() above
     */

    if ((res = directory_walk(rnew))
        || (res = file_walk(rnew))
        || (res = location_walk(rnew))
        || ((ap_satisfies(rnew) == SATISFY_ALL
             || ap_satisfies(rnew) == SATISFY_NOSPEC)
            ? ((res = ap_check_access(rnew))
               || (ap_some_auth_required(rnew)
                   && ((res = ap_check_user_id(rnew))
                       || (res = ap_check_auth(rnew)))))
            : ((res = ap_check_access(rnew))
               && (!ap_some_auth_required(rnew)
                   || ((res = ap_check_user_id(rnew))
                       || (res = ap_check_auth(rnew)))))
           )
        || (res = ap_find_types(rnew))
        || (res = ap_run_fixups(rnew))
       ) {
        rnew->status = res;
    }
    return rnew;
}

API_EXPORT(request_rec *) ap_sub_req_lookup_uri(const char *new_file,
                                                const request_rec *r)
{
    return ap_sub_req_method_uri("GET", new_file, r);
}

API_EXPORT(request_rec *) ap_sub_req_lookup_file(const char *new_file,
                                              const request_rec *r)
{
    request_rec *rnew;
    int res;
    char *fdir;

    rnew = make_sub_request(r);
    rnew->hostname       = r->hostname;
    rnew->request_time   = r->request_time;
    rnew->connection     = r->connection;
    rnew->server         = r->server;
    rnew->request_config = ap_create_request_config(rnew->pool);
    rnew->htaccess       = r->htaccess;

    ap_set_sub_req_protocol(rnew, r);
    fdir = ap_make_dirstr_parent(rnew->pool, r->filename);

    /* We cannot return NULL without violating the API. So just turn this
     * subrequest into a 500. */
    if (ap_is_recursion_limit_exceeded(r)) {
        rnew->status = HTTP_INTERNAL_SERVER_ERROR;
        return rnew;
    }

    /*
     * Check for a special case... if there are no '/' characters in new_file
     * at all, then we are looking at a relative lookup in the same
     * directory. That means we won't have to redo directory_walk, and we may
     * not even have to redo access checks.
     */

    if (strchr(new_file, '/') == NULL) {
        char *udir = ap_make_dirstr_parent(rnew->pool, r->uri);

        rnew->uri = ap_make_full_path(rnew->pool, udir, new_file);
        rnew->filename = ap_make_full_path(rnew->pool, fdir, new_file);
        ap_parse_uri(rnew, rnew->uri);    /* fill in parsed_uri values */
        if (stat(rnew->filename, &rnew->finfo) < 0) {
            rnew->finfo.st_mode = 0;
            /* Special case for filenames which exceed the maximum limit
	     * imposed by the operating system (~1024). These should
	     * NOT be treated like "file not found", because there is
	     * a difference between "the file is not there" and
	     * "the file exists, but you tried to access it using a
	     * path which exceeds the path length limit".
	     * The idea here is to handle DoS attacks with long
	     * runs of //////'s in a graceful and secure manner.
	     */
            if (errno == ENAMETOOLONG) {
                ap_log_rerror(APLOG_MARK, APLOG_CRIT, r,
                              "Possible DoS attempt? Path=%s", r->filename);
                rnew->status = HTTP_FORBIDDEN;
                return rnew;
            }
        }

        if ((res = check_safe_file(rnew))) {
            rnew->status = res;
            return rnew;
        }

        rnew->per_dir_config = r->per_dir_config;

        /*
         * no matter what, if it's a subdirectory, we need to re-run
         * directory_walk
         */
        if (S_ISDIR(rnew->finfo.st_mode)) {
            res = directory_walk(rnew);
            if (!res) {
                res = file_walk(rnew);
            }
        }
        else {
            if ((res = check_symlinks(rnew->filename, ap_allow_options(rnew)))) {
                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, rnew,
                            "Symbolic link not allowed: %s", rnew->filename);
                rnew->status = res;
                return rnew;
            }
            /*
             * do a file_walk, if it doesn't change the per_dir_config then
             * we know that we don't have to redo all the access checks
             */
            if ((res = file_walk(rnew))) {
                rnew->status = res;
                return rnew;
            }
            if (rnew->per_dir_config == r->per_dir_config) {
                if ((res = ap_find_types(rnew)) || (res = ap_run_fixups(rnew))) {
                    rnew->status = res;
                }
                return rnew;
            }
        }
    }
    else {
	/* XXX: @@@@@@: What should be done with the parsed_uri values? */
	ap_parse_uri(rnew, new_file);	/* fill in parsed_uri values */
        /*
         * XXX: this should be set properly like it is in the same-dir case
         * but it's actually sometimes to impossible to do it... because the
         * file may not have a uri associated with it -djg
         */
        rnew->uri = "INTERNALLY GENERATED file-relative req";
        rnew->filename = ((ap_os_is_path_absolute(new_file)) ?
                          ap_pstrdup(rnew->pool, new_file) :
                          ap_make_full_path(rnew->pool, fdir, new_file));
        rnew->per_dir_config = r->server->lookup_defaults;
        res = directory_walk(rnew);
        if (!res) {
            res = file_walk(rnew);
        }
    }

    if (res
        || ((ap_satisfies(rnew) == SATISFY_ALL
             || ap_satisfies(rnew) == SATISFY_NOSPEC)
            ? ((res = ap_check_access(rnew))
               || (ap_some_auth_required(rnew)
                   && ((res = ap_check_user_id(rnew))
                       || (res = ap_check_auth(rnew)))))
            : ((res = ap_check_access(rnew))
               && (!ap_some_auth_required(rnew)
                   || ((res = ap_check_user_id(rnew))
                       || (res = ap_check_auth(rnew)))))
           )
        || (res = ap_find_types(rnew))
        || (res = ap_run_fixups(rnew))
       ) {
        rnew->status = res;
    }
    return rnew;
}

API_EXPORT(int) ap_run_sub_req(request_rec *r)
{
    int retval = ap_invoke_handler(r);
    ap_finalize_sub_req_protocol(r);
    return retval;
d896 2
a897 1
API_EXPORT(void) ap_destroy_sub_req(request_rec *r)
d899 10
a908 2
    /* Reclaim the space */
    ap_destroy_pool(r->pool);
d916 2
a917 1
API_EXPORT(void) ap_die(int type, request_rec *r)
d919 27
a945 171
    int error_index = ap_index_of_response(type);
    char *custom_response = ap_response_code_string(r, error_index);
    int recursive_error = 0;

    if (type == DONE) {
        ap_finalize_request_protocol(r);
        return;
    }

    /*
     * The following takes care of Apache redirects to custom response URLs
     * Note that if we are already dealing with the response to some other
     * error condition, we just report on the original error, and give up on
     * any attempt to handle the other thing "intelligently"...
     */

    if (r->status != HTTP_OK) {
        recursive_error = type;

        while (r->prev && (r->prev->status != HTTP_OK))
            r = r->prev;        /* Get back to original error */

        type = r->status;
        custom_response = NULL; /* Do NOT retry the custom thing! */
    }

    r->status = type;

    /*
     * This test is done here so that none of the auth modules needs to know
     * about proxy authentication.  They treat it like normal auth, and then
     * we tweak the status.
     */
    if (r->status == AUTH_REQUIRED && r->proxyreq == STD_PROXY) {
        r->status = HTTP_PROXY_AUTHENTICATION_REQUIRED;
    }

    /*
     * If we want to keep the connection, be sure that the request body
     * (if any) has been read.
     */
    if ((r->status != HTTP_NOT_MODIFIED) && (r->status != HTTP_NO_CONTENT)
        && !ap_status_drops_connection(r->status)
        && r->connection && (r->connection->keepalive != -1)) {

        (void) ap_discard_request_body(r);
    }

    /*
     * Two types of custom redirects --- plain text, and URLs. Plain text has
     * a leading '"', so the URL code, here, is triggered on its absence
     */

    if (custom_response && custom_response[0] != '"') {

        if (ap_is_url(custom_response)) {
            /*
             * The URL isn't local, so lets drop through the rest of this
             * apache code, and continue with the usual REDIRECT handler.
             * But note that the client will ultimately see the wrong
             * status...
             *
             * Also, before updating r->status, we may need to ensure that
             * the connection is dropped.  For example, there may be
             * unread request body that would confuse us if we try
             * to read another request.
             */
            if (ap_status_drops_connection(r->status)) {
                r->connection->keepalive = -1;
            }
            r->status = REDIRECT;
            ap_table_setn(r->headers_out, "Location", custom_response);
        }
        else if (custom_response[0] == '/') {
            const char *error_notes;
            r->no_local_copy = 1;       /* Do NOT send USE_LOCAL_COPY for
                                         * error documents! */
            /*
             * This redirect needs to be a GET no matter what the original
             * method was.
             */
            ap_table_setn(r->subprocess_env, "REQUEST_METHOD", r->method);

	    /*
	     * Provide a special method for modules to communicate
	     * more informative (than the plain canned) messages to us.
	     * Propagate them to ErrorDocuments via the ERROR_NOTES variable:
	     */
            if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
		ap_table_setn(r->subprocess_env, "ERROR_NOTES", error_notes);
	    }
	    /* 
	     * If it is already a GET or a HEAD, don't change it 
	     * (method_number for GET and HEAD is the same) 
	     */
	    if(r->method_number!=M_GET) { 
            	r->method = ap_pstrdup(r->pool, "GET");
            	r->method_number = M_GET;
	    }
            ap_internal_redirect(custom_response, r);
            return;
        }
        else {
            /*
             * Dumb user has given us a bad url to redirect to --- fake up
             * dying with a recursive server error...
             */
            recursive_error = SERVER_ERROR;
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                        "Invalid error redirection directive: %s",
                        custom_response);
        }
    }
    ap_send_error_response(r, recursive_error);
}

static void decl_die(int status, char *phase, request_rec *r)
{
    if (status == DECLINED) {
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_CRIT, r,
                    "configuration error:  couldn't %s: %s", phase, r->uri);
        ap_die(SERVER_ERROR, r);
    }
    else
        ap_die(status, r);
}

API_EXPORT(int) ap_some_auth_required(request_rec *r)
{
    /* Is there a require line configured for the type of *this* req? */

    const array_header *reqs_arr = ap_requires(r);
    require_line *reqs;
    int i;

    if (!reqs_arr)
        return 0;

    reqs = (require_line *) reqs_arr->elts;

    for (i = 0; i < reqs_arr->nelts; ++i)
        if (reqs[i].method_mask & (1 << r->method_number))
            return 1;

    return 0;
}

static void process_request_internal(request_rec *r)
{
    int access_status;

    /* Ignore embedded %2F's in path for proxy requests */
    if (r->proxyreq == NOT_PROXY && r->parsed_uri.path) {
	access_status = ap_unescape_url(r->parsed_uri.path);
	if (access_status) {
	    ap_die(access_status, r);
	    return;
	}
    }

    ap_getparents(r->uri);     /* OK --- shrinking transformations... */

    if ((access_status = location_walk(r))) {
        ap_die(access_status, r);
        return;
    }

    if ((access_status = ap_translate_name(r))) {
        decl_die(access_status, "translate", r);
        return;
    }
a946 1
    if (r->proxyreq == NOT_PROXY) {
d948 3
a950 2
	 * We don't want TRACE to run through the normal handler set, we
	 * handle it specially.
d952 131
a1082 2
	if (r->method_number == M_TRACE) {
	    if ((access_status = ap_send_http_trace(r)))
d1084 248
a1331 3
	    else
		ap_finalize_request_protocol(r);
	    return;
a1332 1
    }
d1334 10
a1343 224
    if (r->proto_num > HTTP_VERSION(1,0) && ap_table_get(r->subprocess_env, "downgrade-1.0")) {
        r->proto_num = HTTP_VERSION(1,0);
    }

    /*
     * NB: directory_walk() clears the per_dir_config, so we don't inherit
     * from location_walk() above
     */

    if ((access_status = directory_walk(r))) {
        ap_die(access_status, r);
        return;
    }

    if ((access_status = file_walk(r))) {
        ap_die(access_status, r);
        return;
    }

    if ((access_status = location_walk(r))) {
        ap_die(access_status, r);
        return;
    }

    if ((access_status = ap_header_parse(r))) {
        ap_die(access_status, r);
        return;
    }

    switch (ap_satisfies(r)) {
    case SATISFY_ALL:
    case SATISFY_NOSPEC:
        if ((access_status = ap_check_access(r)) != 0) {
            decl_die(access_status, "check access", r);
            return;
        }
        if (ap_some_auth_required(r)) {
            if (((access_status = ap_check_user_id(r)) != 0) || !ap_auth_type(r)) {
                decl_die(access_status, ap_auth_type(r)
		    ? "check user.  No user file?"
		    : "perform authentication. AuthType not set!", r);
                return;
            }
            if (((access_status = ap_check_auth(r)) != 0) || !ap_auth_type(r)) {
                decl_die(access_status, ap_auth_type(r)
		    ? "check access.  No groups file?"
		    : "perform authentication. AuthType not set!", r);
                return;
            }
        }
        break;
    case SATISFY_ANY:
        if (((access_status = ap_check_access(r)) != 0)) {
            if (!ap_some_auth_required(r)) {
                decl_die(access_status, "check access", r);
                return;
            }
            if (((access_status = ap_check_user_id(r)) != 0) || !ap_auth_type(r)) {
                decl_die(access_status, ap_auth_type(r)
		    ? "check user.  No user file?"
		    : "perform authentication. AuthType not set!", r);
                return;
            }
            if (((access_status = ap_check_auth(r)) != 0) || !ap_auth_type(r)) {
                decl_die(access_status, ap_auth_type(r)
		    ? "check access.  No groups file?"
		    : "perform authentication. AuthType not set!", r);
                return;
            }
        }
        break;
    }

    if (! (r->proxyreq != NOT_PROXY
	   && r->parsed_uri.scheme != NULL
	   && strcmp(r->parsed_uri.scheme, "http") == 0) ) {
	if ((access_status = ap_find_types(r)) != 0) {
	    decl_die(access_status, "find types", r);
	    return;
	}
    }

    if ((access_status = ap_run_fixups(r)) != 0) {
        ap_die(access_status, r);
        return;
    }

    if ((access_status = ap_invoke_handler(r)) != 0) {
        ap_die(access_status, r);
        return;
    }

    /* Take care of little things that need to happen when we're done */
    ap_finalize_request_protocol(r);
}

API_EXPORT(void) ap_process_request(request_rec *r)
{
    int old_stat;

    if (ap_extended_status)
	ap_time_process_request(r->connection->child_num, START_PREQUEST);

    process_request_internal(r);

    old_stat = ap_update_child_status(r->connection->child_num,
                                   SERVER_BUSY_LOG, r);

    /*
     * We want to flush the last packet if this isn't a pipelining connection
     * *before* we start into logging.  Suppose that the logging causes a DNS
     * lookup to occur, which may have a high latency.  If we hold off on
     * this packet, then it'll appear like the link is stalled when really
     * it's the application that's stalled.
     */
    ap_bhalfduplex(r->connection->client);
    ap_log_transaction(r);

    (void) ap_update_child_status(r->connection->child_num, old_stat, r);
    if (ap_extended_status)
	ap_time_process_request(r->connection->child_num, STOP_PREQUEST);
}

static table *rename_original_env(pool *p, table *t)
{
    array_header *env_arr = ap_table_elts(t);
    table_entry *elts = (table_entry *) env_arr->elts;
    table *new = ap_make_table(p, env_arr->nalloc);
    int i;

    for (i = 0; i < env_arr->nelts; ++i) {
        if (!elts[i].key)
            continue;
        ap_table_setn(new, ap_pstrcat(p, "REDIRECT_", elts[i].key, NULL),
                  elts[i].val);
    }

    return new;
}

static request_rec *internal_internal_redirect(const char *new_uri, request_rec *r)
{
    int access_status;
    request_rec *new;

    if (ap_is_recursion_limit_exceeded(r)) {
        ap_die(HTTP_INTERNAL_SERVER_ERROR, r);
        return NULL;
    }

    new = (request_rec *) ap_pcalloc(r->pool, sizeof(request_rec));

    new->connection = r->connection;
    new->server     = r->server;
    new->pool       = r->pool;

    /*
     * A whole lot of this really ought to be shared with http_protocol.c...
     * another missing cleanup.  It's particularly inappropriate to be
     * setting header_only, etc., here.
     */

    new->method          = r->method;
    new->method_number   = r->method_number;
    /* initialize context _BEFORE_ ap_parse_uri() call */
    new->ctx             = r->ctx;
    ap_parse_uri(new, new_uri);
    new->request_config = ap_create_request_config(r->pool);
    new->per_dir_config = r->server->lookup_defaults;

    new->prev = r;
    r->next   = new;

    /* Inherit the rest of the protocol info... */

    new->the_request = r->the_request;

    new->allowed         = r->allowed;

    new->status          = r->status;
    new->assbackwards    = r->assbackwards;
    new->header_only     = r->header_only;
    new->protocol        = r->protocol;
    new->proto_num       = r->proto_num;
    new->hostname        = r->hostname;
    new->request_time    = r->request_time;
    new->main            = r->main;

    new->headers_in      = r->headers_in;
    new->headers_out     = ap_make_table(r->pool, 12);
    new->err_headers_out = r->err_headers_out;
    new->subprocess_env  = rename_original_env(r->pool, r->subprocess_env);
    new->notes           = ap_make_table(r->pool, 5);

    new->htaccess        = r->htaccess;
    new->no_cache        = r->no_cache;
    new->expecting_100	 = r->expecting_100;
    new->no_local_copy   = r->no_local_copy;
    new->read_length     = r->read_length;     /* We can only read it once */
    new->vlist_validator = r->vlist_validator;

    ap_table_setn(new->subprocess_env, "REDIRECT_STATUS",
	ap_psprintf(r->pool, "%d", r->status));

    /*
     * XXX: hmm.  This is because mod_setenvif and mod_unique_id really need
     * to do their thing on internal redirects as well.  Perhaps this is a
     * misnamed function.
     */
    if ((access_status = ap_run_post_read_request(new))) {
        ap_die(access_status, new);
        return NULL;
    }

    return new;
}

API_EXPORT(void) ap_internal_redirect(const char *new_uri, request_rec *r)
{
    request_rec *new = internal_internal_redirect(new_uri, r);

    if (new) {
        process_request_internal(new);
    }
d1350 2
a1351 1
API_EXPORT(void) ap_internal_redirect_handler(const char *new_uri, request_rec *r)
d1353 1
a1353 1
    request_rec *new = internal_internal_redirect(new_uri, r);
d1355 5
a1359 5
    if (new) {
        if (r->handler)
            new->content_type = r->content_type;
        process_request_internal(new);
    }
d1365 2
a1366 1
API_EXPORT(int) ap_is_initial_req(request_rec *r)
d1368 4
a1371 4
    return
        (r->main == NULL)       /* otherwise, this is a sub-request */
        &&
        (r->prev == NULL);      /* otherwise, this is an internal redirect */
d1378 2
a1379 1
API_EXPORT(time_t) ap_update_mtime(request_rec *r, time_t dependency_mtime)
d1381 3
a1383 4
    if (r->mtime < dependency_mtime) {
        r->mtime = dependency_mtime;
    }
    return r->mtime;
@


1.14
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@a176 3
#if defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS)
    char bStripSlash=1;
#endif
a182 8
#ifdef HAVE_DRIVE_LETTERS
    /* If the directory is x:\, then we don't want to strip
     * the trailing slash since x: is not a valid directory.
     */
    if (strlen(path) == 3 && path[1] == ':' && path[2] == '/')
        bStripSlash = 0;
#endif

a183 24
#ifdef HAVE_UNC_PATHS
    /* If UNC name == //machine/share/, do not 
     * advance over the trailing slash.  Any other
     * UNC name is OK to strip the slash.
     */
    cp = end;
    if (strlen(path) > 2 && path[0] == '/' && path[1] == '/' && 
        path[2] != '/' && cp[-1] == '/') {
        char *p;
        int iCount=0;
        p = path;
        while (p = strchr(p,'/')) {
            p++;
            iCount++;
        }
    
        if (iCount == 4)
            bStripSlash = 0;
    }
#endif

#if defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS)
    if (bStripSlash)
#endif
a235 1
#if defined(ENOENT) && defined(ENOTDIR)
a245 1
#if defined(EACCES)
a251 1
#endif 
a255 24
#else
#error ENOENT || ENOTDIR not defined; please see the
#error comments at this line in the source for a workaround.
        /*
         * If ENOENT || ENOTDIR is not defined in one of the your OS's
         * include files, Apache does not know how to check to see why the
         * stat() of the index file failed; there are cases where it can fail
         * even though the file exists.  This means that it is possible for
         * someone to get a directory listing of a directory even though
         * there is an index (eg. index.html) file in it.  If you do not have
         * a problem with this, delete the above #error lines and start the
         * compile again.  If you need to do this, please submit a bug report
         * from http://www.apache.org/bug_report.html letting us know that
         * you needed to do this.  Please be sure to include the operating
         * system you are using.
         */
	last_cp = cp;

	while (--cp > path && *cp != '/')
	    continue;

	while (cp > path && cp[-1] == '/')
	    --cp;
#endif  /* ENOENT && ENOTDIR */
a271 3
#if defined(HAVE_UNC_PATHS) || defined(NETWARE)
    unsigned iStart = 1;
#endif
a378 8
#if defined(HAVE_UNC_PATHS)
    /* If the name is a UNC name, then do not perform any true file test
     * against the machine name (start at //machine/share/)
     * This is optimized to use the normal walk (skips the redundant '/' root)
     */
    if (num_dirs > 3 && test_filename[0] == '/' && test_filename[1] == '/')
        iStart = 4;
#endif
a379 15

#if defined(HAVE_DRIVE_LETTERS) || defined(NETWARE)
    /* Should match <Directory> sections starting from '/', not 'e:/' 
     * (for example).  WIN32/OS2/NETWARE do not have a single root directory,
     * they have one for each filesystem.  Traditionally, Apache has treated 
     * <Directory /> permissions as the base for the whole server, and this 
     * tradition should probably be preserved. 
     *
     * NOTE: MUST SYNC WITH ap_make_dirstr_prefix() CHANGE IN src/main/util.c
     */
    if (test_filename[0] == '/')
        i = 1;
    else
        i = 0;
#else
a381 1
#endif /* def HAVE_DRIVE_LETTERS || NETWARE */
a400 4
#if defined(HAVE_UNC_PATHS) || defined(NETWARE)
        /* Test only legal names against the real filesystem */
        if (i >= iStart)
#endif
a423 7
#if defined(HAVE_DRIVE_LETTERS) || defined(NETWARE)
    /* To account for the top-level "/" directory when i == 0 
     * XXX: I think the net test is wrong... may fail ap_os_is_path_absolute
     */
                || (entry_core->d_components > 1
                    && entry_core->d_components > i))
#else
a424 1
#endif /* def HAVE_DRIVE_LETTERS || NETWARE */                  
a442 9
#if defined(HAVE_DRIVE_LETTERS) || defined(NETWARE)
            /* So that other top-level directory sections (e.g. "e:/") aren't
             * skipped when i == 0
             * XXX: I don't get you here, Tim... That's a level 1 section, but
             *      we are at level 0. Did you mean fast-forward to the next?
             */
            else if (!i)
                break;
#endif /* def HAVE_DRIVE_LETTERS || NETWARE */
a447 4
#if defined(HAVE_UNC_PATHS) || defined(NETWARE)
        /* Test only legal names against the real filesystem */
        if (i >= iStart)
#endif
a798 1
#ifdef ENAMETOOLONG
a813 1
#endif
a1264 1
#ifdef EAPI
a1266 1
#endif /* EAPI */
@


1.13
log
@merge apache 1.3.29 and mod_ssl 2.8.16
ok brad@@
@
text
@a116 4
#if defined(OS2) || defined(WIN32) || defined(NETWARE)
    /* OS/2 doesn't have symlinks */
    return OK;
#else
a165 1
#endif
a244 3
#ifdef OS2
            r->finfo.st_ino = 0;
#endif
a452 9
#if defined(NETWARE)
    /* If the name is a fully qualified volume name, then do not perform any
     * true file test on the machine name (start at machine/share:/)
     * XXX: The implementation eludes me at this moment... 
     *      Does this make sense?  Please test!
     */
    if (num_dirs > 1 && strchr(test_filename, '/') < strchr(test_filename, ':'))
        iStart = 2;
#endif
a773 5
#ifdef CHARSET_EBCDIC
    /* Assume virgin state (like after reading the request_line): */
    ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, rr->ebcdic.conv_in  = 1);
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, rr->ebcdic.conv_out = 1);
#endif   
a1019 6
#ifdef CHARSET_EBCDIC
    if (r->main) {
        ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, r->main->ebcdic.conv_in);
        ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->main->ebcdic.conv_out);
    }
#endif   
a1418 4
#ifdef CHARSET_EBCDIC /* @@@@@@ Is this correct? When is it used? */
    new->ebcdic.conv_out= r->ebcdic.conv_out;
    new->ebcdic.conv_in = r->ebcdic.conv_in;
#endif
@


1.12
log
@merge
@
text
@d1120 5
d1126 3
@


1.11
log
@merge
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
d291 7
a297 2
            if (errno != EACCES)
#endif
d830 7
d913 7
d1289 1
a1289 1
        if (((access_status = ap_check_access(r)) != 0) || !ap_auth_type(r)) {
d1291 1
a1291 4
                decl_die(access_status ? access_status :
			 HTTP_INTERNAL_SERVER_ERROR,
			 ap_auth_type(r) ? "check access"
		    : "perform authentication. AuthType not set!", r);
d1380 8
a1387 1
    request_rec *new = (request_rec *) ap_pcalloc(r->pool, sizeof(request_rec));
d1463 4
a1466 1
    process_request_internal(new);
d1476 6
a1481 3
    if (r->handler)
        new->content_type = r->content_type;
    process_request_internal(new);
@


1.10
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d928 1
a928 1
                              "Possible DoS attempt? URL=%s", r->filename);
@


1.9
log
@merge mod_ssl 2.8.4
--
Ok'd by: beck@@
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d420 2
a421 1
    if (!ap_os_is_filename_valid(r->filename)) {
d786 5
a1015 1
#ifndef CHARSET_EBCDIC
a1016 6
#else /*CHARSET_EBCDIC*/
    /* Save the EBCDIC conversion setting of the caller across subrequests */
    int convert = ap_bgetflag(r->connection->client, B_EBCDIC2ASCII);
    int retval  = ap_invoke_handler(r);
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, convert);
#endif /*CHARSET_EBCDIC*/
d1023 6
d1317 1
a1317 1
void ap_process_request(request_rec *r)
d1416 4
@


1.8
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d1373 4
a1410 3
#ifdef EAPI
    new->ctx             = r->ctx;
#endif /* EAPI */
@


1.7
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1995-1999 The Apache Group.  All rights reserved.
d19 20
a38 23
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 7
a56 6
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
d250 3
d910 17
@


1.6
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d181 1
a181 1
#ifdef HAVE_DRIVE_LETTERS
d196 1
d199 1
d218 1
d220 1
a228 1

d331 1
a331 1
    unsigned i, num_dirs, iStart;
d333 3
d407 2
d442 4
a445 4
    iStart = 1;
#ifdef WIN32
    /* If the name is a UNC name, then do not walk through the
     * machine and share name (e.g. \\machine\share\)
d451 28
d481 1
a481 1
    for (i = iStart; i <= num_dirs; ++i) {
d497 4
d524 7
d532 1
d551 9
d565 4
d1097 8
a1104 2
            r->method = ap_pstrdup(r->pool, "GET");
            r->method_number = M_GET;
@


1.5
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d116 1
a116 1
#if defined(OS2) || defined(WIN32)
d986 1
a986 1
    if (r->status == AUTH_REQUIRED && r->proxyreq) {
d1091 1
a1091 1
    if (!r->proxyreq && r->parsed_uri.path) {
d1111 1
a1111 1
    if (!r->proxyreq) {
d1179 3
a1181 2
                decl_die(access_status, ap_auth_type(r)
		    ? "check access"
d1201 1
a1201 1
    if (! (r->proxyreq 
@


1.4
log
@mod_ssl-2.2.3-1.3.4 (will require libssl-1.1 for https to work, but
mostly harmless otherwise).
@
text
@d181 2
a182 2
#ifdef WIN32
    BOOL bStripSlash=TRUE;
d190 1
a190 1
#ifdef WIN32
d195 1
a195 1
        bStripSlash = FALSE;
d214 1
a214 1
            bStripSlash = FALSE;
d268 4
d273 1
a273 1
        else if (errno == ENOENT || errno == ENOTDIR) {
d306 1
a306 2
        else {
            last_cp = cp;
d308 2
a309 2
            while (--cp > path && *cp != '/')
                continue;
d311 2
a312 3
            while (cp > path && cp[-1] == '/')
                --cp;
        }
d373 1
a373 1
                if (!regexec(entry_core->r, r->filename, 0, NULL, 0))
d539 1
a539 1
            if (!regexec(entry_core->r, test_dirname, 0, NULL, REG_NOTEOL)) {
d615 1
a615 1
	    if (!regexec(entry_core->r, r->uri, 0, NULL, 0))
d676 1
a676 1
                if (!regexec(entry_core->r, test_file, 0, NULL, 0))
d723 3
a725 2
API_EXPORT(request_rec *) ap_sub_req_lookup_uri(const char *new_file,
                                             const request_rec *r)
d742 4
d806 6
d1314 1
@


1.3
log
@Apache 1.3.4 merge
@
text
@d1304 3
@


1.2
log
@Apache 1.3.3 merge + proxy_segv fix
@
text
@d2 1
a2 1
 * Copyright (c) 1995-1998 The Apache Group.  All rights reserved.
d182 1
a182 1
    char buf[5];
d191 2
a192 2
    /* If the path is x:/, then convert it to x:/., coz that's what stat
     * needs to work properly
d194 21
a214 6
    if (strlen(path) == 3 && path[1] == ':') {
	strcpy(buf,path);
	buf[3]='.';
	buf[4]='\0';
	path=buf;
	end=buf+4;
d216 2
d219 5
a223 5

    /* Advance over trailing slashes ... NOT part of filename */

    for (cp = end; cp > path && cp[-1] == '/'; --cp)
        continue;
d232 15
a246 2
        errno = 0;
        rv = stat(path, &r->finfo);
d326 1
a326 1
    unsigned i, num_dirs;
d392 7
d400 1
d406 4
a409 3
    res = get_path_info(r);
    if (res != OK) {
        return res;
d432 9
d443 1
a443 1
    for (i = 1; i <= num_dirs; ++i) {
d515 6
a520 4
            if (htaccess_conf)
                per_dir_defaults =
                    ap_merge_per_dir_configs(r->pool, per_dir_defaults,
                                          htaccess_conf);
d743 1
a743 1
        udir = escape_uri(rnew->pool, udir);    /* re-escape it */
d829 1
a829 1
	ap_parse_uri(rnew, rnew->uri);    /* fill in parsed_uri values */
d883 1
a883 8
#ifdef WIN32
        rnew->filename = ((new_file[0] == '/'
                           || (ap_isalpha(new_file[0])
                               && new_file[1] == ':'
                               && new_file[2] == '/')) ?
#else
        rnew->filename = ((new_file[0] == '/') ?
#endif
d915 1
d917 6
d982 1
a982 1
        && !status_drops_connection(r->status)
d1303 1
@


1.1
log
@Initial revision
@
text
@d191 4
a194 2
    /* If the path is x:/, then convert it to x:/., coz that's what stat needs to work properly */
    if(strlen(path) == 3 && path[1] == ':') {
d679 1
d757 1
d833 6
d840 1
a1025 33

    /*
     * Kluge to be reading the assbackwards field outside of protocol.c, but
     * we've got to check for this sort of nonsense somewhere...
     */

    if (r->assbackwards && r->header_only) {
        /*
         * Client asked for headers only with HTTP/0.9, which doesn't send
         * headers!  Have to dink things even to make sure the error message
         * comes through...
         */
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                    "client sent illegal HTTP/0.9 request: %s", r->uri);
        r->header_only = 0;
        ap_die(BAD_REQUEST, r);
        return;
    }

    if ((!r->hostname && (r->proto_num >= HTTP_VERSION(1,1))) ||
        ((r->proto_num == HTTP_VERSION(1,1)) && !ap_table_get(r->headers_in, "Host"))) {
        /*
         * Client sent us a HTTP/1.1 or later request without telling us the
         * hostname, either with a full URL or a Host: header. We therefore
         * need to (as per the 1.1 spec) send an error.  As a special case,
	 * HTTP/1.1 mentions twice (S9, S14.23) that a request MUST contain
	 * a Host: header, and the server MUST respond with 400 if it doesn't.
         */
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
               "client sent HTTP/1.1 request without hostname (see RFC2068 section 9, and 14.23): %s", r->uri);
        ap_die(BAD_REQUEST, r);
        return;
    }
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d16 9
a24 6
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
d26 3
a28 4
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
d30 4
a33 3
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
d35 4
a38 4
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 5
a54 3
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
a55 3
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
d116 1
a116 1
#if defined(OS2) || defined(WIN32) || defined(NETWARE)
d181 2
a182 2
#if defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS)
    char bStripSlash=1;
d190 9
a198 6
#ifdef HAVE_DRIVE_LETTERS
    /* If the directory is x:\, then we don't want to strip
     * the trailing slash since x: is not a valid directory.
     */
    if (strlen(path) == 3 && path[1] == ':' && path[2] == '/')
        bStripSlash = 0;
d201 1
d203 2
a204 20
#ifdef HAVE_UNC_PATHS
    /* If UNC name == //machine/share/, do not 
     * advance over the trailing slash.  Any other
     * UNC name is OK to strip the slash.
     */
    cp = end;
    if (strlen(path) > 2 && path[0] == '/' && path[1] == '/' && 
        path[2] != '/' && cp[-1] == '/') {
        char *p;
        int iCount=0;
        p = path;
        while (p = strchr(p,'/')) {
            p++;
            iCount++;
        }
    
        if (iCount == 4)
            bStripSlash = 0;
    }
#endif
a205 8
#if defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS)
    if (bStripSlash)
#endif
        /* Advance over trailing slashes ... NOT part of filename 
         * if file is not a UNC name (Win32 only).
         */
        for (cp = end; cp > path && cp[-1] == '/'; --cp)
            continue;
d213 2
a214 18
        /* We must not stat() filenames that may cause os-specific system
         * problems, such as "/file/aux" on DOS-abused filesystems.
         * So pretend that they do not exist by returning an ENOENT error.
         * This will force us to drop that part of the path and keep
         * looking back for a "real" file that exists, while still allowing
         * the "invalid" path parts within the PATH_INFO.
         */
        if (!ap_os_is_filename_valid(path)) {
            errno = ENOENT;
            rv = -1;
        }
        else {
            errno = 0;
            rv = stat(path, &r->finfo);
#ifdef OS2
            r->finfo.st_ino = 0;
#endif
        }
a235 4
	/* must set this to zero, some stat()s may have corrupted it
	 * even if they returned an error.
	 */
	r->finfo.st_mode = 0;
d237 1
a237 1
        if (errno == ENOENT || errno == ENOTDIR) {
d270 2
a271 1
	last_cp = cp;
d273 2
a274 2
	while (--cp > path && *cp != '/')
	    continue;
d276 3
a278 2
	while (cp > path && cp[-1] == '/')
	    --cp;
a295 3
#if defined(HAVE_UNC_PATHS) || defined(NETWARE)
    unsigned iStart = 1;
#endif
d339 1
a339 1
                if (!ap_regexec(entry_core->r, r->filename, 0, NULL, 0))
a359 9
    r->filename   = ap_os_case_canonical_filename(r->pool, r->filename);

    res = get_path_info(r);
    if (res != OK) {
        return res;
    }

    r->case_preserved_filename = r->filename;

a360 1

d366 3
a368 5
    if (!ap_os_is_filename_valid(r->filename) &&
        !(r->method_number == M_OPTIONS && !strcmp(r->uri, "*"))) {
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                      "Filename is not valid: %s", r->filename);
        return HTTP_FORBIDDEN;
a390 37
#if defined(HAVE_UNC_PATHS)
    /* If the name is a UNC name, then do not perform any true file test
     * against the machine name (start at //machine/share/)
     * This is optimized to use the normal walk (skips the redundant '/' root)
     */
    if (num_dirs > 3 && test_filename[0] == '/' && test_filename[1] == '/')
        iStart = 4;
#endif

#if defined(NETWARE)
    /* If the name is a fully qualified volume name, then do not perform any
     * true file test on the machine name (start at machine/share:/)
     * XXX: The implementation eludes me at this moment... 
     *      Does this make sense?  Please test!
     */
    if (num_dirs > 1 && strchr(test_filename, '/') < strchr(test_filename, ':'))
        iStart = 2;
#endif

#if defined(HAVE_DRIVE_LETTERS) || defined(NETWARE)
    /* Should match <Directory> sections starting from '/', not 'e:/' 
     * (for example).  WIN32/OS2/NETWARE do not have a single root directory,
     * they have one for each filesystem.  Traditionally, Apache has treated 
     * <Directory /> permissions as the base for the whole server, and this 
     * tradition should probably be preserved. 
     *
     * NOTE: MUST SYNC WITH ap_make_dirstr_prefix() CHANGE IN src/main/util.c
     */
    if (test_filename[0] == '/')
        i = 1;
    else
        i = 0;
#else
    /* Normal File Systems are rooted at / */
    i = 1;
#endif /* def HAVE_DRIVE_LETTERS || NETWARE */

d393 1
a393 1
    for (; i <= num_dirs; ++i) {
a408 4
#if defined(HAVE_UNC_PATHS) || defined(NETWARE)
        /* Test only legal names against the real filesystem */
        if (i >= iStart)
#endif
a431 7
#if defined(HAVE_DRIVE_LETTERS) || defined(NETWARE)
    /* To account for the top-level "/" directory when i == 0 
     * XXX: I think the net test is wrong... may fail ap_os_is_path_absolute
     */
                || (entry_core->d_components > 1
                    && entry_core->d_components > i))
#else
a432 1
#endif /* def HAVE_DRIVE_LETTERS || NETWARE */                  
a450 9
#if defined(HAVE_DRIVE_LETTERS) || defined(NETWARE)
            /* So that other top-level directory sections (e.g. "e:/") aren't
             * skipped when i == 0
             * XXX: I don't get you here, Tim... That's a level 1 section, but
             *      we are at level 0. Did you mean fast-forward to the next?
             */
            else if (!i)
                break;
#endif /* def HAVE_DRIVE_LETTERS || NETWARE */
a455 4
#if defined(HAVE_UNC_PATHS) || defined(NETWARE)
        /* Test only legal names against the real filesystem */
        if (i >= iStart)
#endif
d465 4
a468 6
            if (htaccess_conf) {
                per_dir_defaults = ap_merge_per_dir_configs(r->pool,
							    per_dir_defaults,
							    htaccess_conf);
		r->per_dir_config = per_dir_defaults;
	    }
d485 1
a485 1
            if (!ap_regexec(entry_core->r, test_dirname, 0, NULL, REG_NOTEOL)) {
d561 1
a561 1
	    if (!ap_regexec(entry_core->r, r->uri, 0, NULL, 0))
d622 1
a622 1
                if (!ap_regexec(entry_core->r, test_file, 0, NULL, 0))
a665 5
#ifdef CHARSET_EBCDIC
    /* Assume virgin state (like after reading the request_line): */
    ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, rr->ebcdic.conv_in  = 1);
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, rr->ebcdic.conv_out = 1);
#endif   
d669 2
a670 3
API_EXPORT(request_rec *) ap_sub_req_method_uri(const char *method,
                                                const char *new_file,
                                                const request_rec *r)
a676 1
    rnew->hostname       = r->hostname;
a685 4
    /* would be nicer to pass "method" to ap_set_sub_req_protocol */
    rnew->method = method;
    rnew->method_number = ap_method_number_of(method);

d690 1
a690 1
        udir = ap_escape_uri(rnew->pool, udir);    /* re-escape it */
a745 6
API_EXPORT(request_rec *) ap_sub_req_lookup_uri(const char *new_file,
                                                const request_rec *r)
{
    return ap_sub_req_method_uri("GET", new_file, r);
}

a753 1
    rnew->hostname       = r->hostname;
d775 1
a775 1
        ap_parse_uri(rnew, rnew->uri);    /* fill in parsed_uri values */
a777 17
#ifdef ENAMETOOLONG
            /* Special case for filenames which exceed the maximum limit
	     * imposed by the operating system (~1024). These should
	     * NOT be treated like "file not found", because there is
	     * a difference between "the file is not there" and
	     * "the file exists, but you tried to access it using a
	     * path which exceeds the path length limit".
	     * The idea here is to handle DoS attacks with long
	     * runs of //////'s in a graceful and secure manner.
	     */
            if (errno == ENAMETOOLONG) {
                ap_log_rerror(APLOG_MARK, APLOG_CRIT, r,
                              "Possible DoS attempt? Path=%s", r->filename);
                rnew->status = HTTP_FORBIDDEN;
                return rnew;
            }
#endif
d829 1
a829 1
        rnew->filename = ((ap_os_is_path_absolute(new_file)) ?
a867 6
#ifdef CHARSET_EBCDIC
    if (r->main) {
        ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, r->main->ebcdic.conv_in);
        ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->main->ebcdic.conv_out);
    }
#endif   
d912 1
a912 1
    if (r->status == AUTH_REQUIRED && r->proxyreq == STD_PROXY) {
d921 1
a921 1
        && !ap_status_drops_connection(r->status)
d962 2
a963 8
	    /* 
	     * If it is already a GET or a HEAD, don't change it 
	     * (method_number for GET and HEAD is the same) 
	     */
	    if(r->method_number!=M_GET) { 
            	r->method = ap_pstrdup(r->pool, "GET");
            	r->method_number = M_GET;
	    }
d1016 33
d1050 1
a1050 1
    if (r->proxyreq == NOT_PROXY && r->parsed_uri.path) {
d1070 1
a1070 1
    if (r->proxyreq == NOT_PROXY) {
d1138 2
a1139 3
                decl_die(access_status ? access_status :
			 HTTP_INTERNAL_SERVER_ERROR,
			 ap_auth_type(r) ? "check access"
d1159 1
a1159 1
    if (! (r->proxyreq != NOT_PROXY
d1182 1
a1182 1
API_EXPORT(void) ap_process_request(request_rec *r)
a1272 1
    new->expecting_100	 = r->expecting_100;
a1274 5
    new->vlist_validator = r->vlist_validator;
#ifdef CHARSET_EBCDIC /* @@@@@@ Is this correct? When is it used? */
    new->ebcdic.conv_out= r->ebcdic.conv_out;
    new->ebcdic.conv_in = r->ebcdic.conv_in;
#endif
@


1.1.1.3
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@a1377 4
#ifdef EAPI
    /* initialize context _BEFORE_ ap_parse_uri() call */
    new->ctx             = r->ctx;
#endif /* EAPI */
@


1.1.1.4
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
d291 2
a292 7
            if (errno == EACCES)
                ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                            "access to %s failed because search "
                            "permissions are missing on a component "
                            "of the path", r->uri);
            else
#endif 
a824 7
    /* We cannot return NULL without violating the API. So just turn this
     * subrequest into a 500 to indicate the failure. */
    if (ap_is_recursion_limit_exceeded(r)) {
        rnew->status = HTTP_INTERNAL_SERVER_ERROR;
        return rnew;
    }

a900 7
    /* We cannot return NULL without violating the API. So just turn this
     * subrequest into a 500. */
    if (ap_is_recursion_limit_exceeded(r)) {
        rnew->status = HTTP_INTERNAL_SERVER_ERROR;
        return rnew;
    }

d1270 1
a1270 1
        if (((access_status = ap_check_access(r)) != 0)) {
d1272 4
a1275 1
                decl_die(access_status, "check access", r);
d1364 1
a1364 8
    request_rec *new;

    if (ap_is_recursion_limit_exceeded(r)) {
        ap_die(HTTP_INTERNAL_SERVER_ERROR, r);
        return NULL;
    }

    new = (request_rec *) ap_pcalloc(r->pool, sizeof(request_rec));
d1440 1
a1440 4

    if (new) {
        process_request_internal(new);
    }
d1450 3
a1452 6

    if (new) {
        if (r->handler)
            new->content_type = r->content_type;
        process_request_internal(new);
    }
@


1.1.1.5
log
@import Apache 1.3.29 and mod_ssl 2.8.16
@
text
@a1119 5
             *
             * Also, before updating r->status, we may need to ensure that
             * the connection is dropped.  For example, there may be
             * unread request body that would confuse us if we try
             * to read another request.
a1120 3
            if (ap_status_drops_connection(r->status)) {
                r->connection->keepalive = -1;
            }
@


