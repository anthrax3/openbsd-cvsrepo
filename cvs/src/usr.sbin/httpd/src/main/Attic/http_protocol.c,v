head	1.40;
access;
symbols
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.37.0.16
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.14
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.12
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.10
	OPENBSD_5_0:1.37.0.8
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.6
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.4
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.35.0.4
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.34.0.4
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.31.0.4
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.30.0.4
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.28.0.4
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.4
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.4
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.3
	apache_1_3_27:1.1.1.3
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2014.04.22.14.47.26;	author henning;	state dead;
branches;
next	1.39;

1.39
date	2013.08.22.04.43.41;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2013.08.08.03.16.13;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2010.02.25.07.49.53;	author pyr;	state Exp;
branches;
next	1.36;

1.36
date	2010.02.23.08.15.27;	author pyr;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.02.23.36.40;	author pyr;	state Exp;
branches;
next	1.34;

1.34
date	2008.05.23.08.41.48;	author mbalmer;	state Exp;
branches;
next	1.33;

1.33
date	2008.05.15.06.05.43;	author mbalmer;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.24.11.56.29;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2006.09.26.03.26.36;	author djm;	state Exp;
branches;
next	1.30;

1.30
date	2006.02.11.19.15.57;	author otto;	state Exp;
branches
	1.30.2.1
	1.30.4.1;
next	1.29;

1.29
date	2005.11.11.15.09.54;	author cloder;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.09.12.13.09;	author henning;	state Exp;
branches
	1.28.4.1;
next	1.27;

1.27
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.07.04.24.00;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.15.12.17.18;	author otto;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2004.01.13.16.32.53;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.21.13.11.35;	author henning;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2003.07.08.09.51.23;	author david;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.21.18.41.09;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.21.16.39.56;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.21.16.34.44;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.17.03.14.33;	author cloder;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.16.17.16.12;	author cloder;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.16.15.54.59;	author cloder;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.15.18.04.38;	author cloder;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.07.20.23.06;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.19.21.31.16;	author henning;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2002.06.17.19.15.49;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.17.17.25.49;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.29.02.08.06;	author beck;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.03.29.10.21.43;	author beck;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2000.12.15.22.18.08;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.19.11.17.09;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.25.18.29.48;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.06.29.37;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.03.01.04.28.37;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.01.06.12;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	98.10.11.19.45.13;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.40;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.40;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.28.49;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.07.19.48.13;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.21.12.53.39;	author henning;	state Exp;
branches;
next	;

1.9.4.1
date	2002.06.19.07.37.11;	author miod;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.17.20.34.46;	author jason;	state Exp;
branches;
next	;

1.13.2.1
date	2003.02.24.02.09.39;	author margarida;	state Exp;
branches;
next	;

1.23.2.1
date	2004.06.10.03.55.55;	author brad;	state Exp;
branches;
next	;

1.25.2.1
date	2004.06.10.02.12.51;	author brad;	state Exp;
branches;
next	;

1.28.4.1
date	2006.09.26.21.07.43;	author brad;	state Exp;
branches;
next	;

1.30.2.1
date	2006.09.26.20.55.06;	author brad;	state Exp;
branches;
next	;

1.30.4.1
date	2006.11.01.21.18.38;	author brad;	state Exp;
branches;
next	;


desc
@@


1.40
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*	$OpenBSD: http_protocol.c,v 1.39 2013/08/22 04:43:41 guenther Exp $ */

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/*
 * http_protocol.c --- routines which directly communicate with the client.
 *
 * Code originally by Rob McCool; much redone by Robert S. Thau
 * and the Apache Group.
 */

#define CORE_PRIVATE
#include "httpd.h"
#include "http_config.h"
#include "http_core.h"
#include "http_protocol.h"
#include "http_main.h"
#include "http_request.h"
#include "http_vhost.h"
#include "http_log.h"           /* For errors detected in basic auth common
                                 * support code... */
#include "util_date.h"          /* For parseHTTPdate and BAD_DATE */
#include <stdarg.h>
#include "http_conf_globals.h"
#include "util_md5.h"           /* For digestAuth */
#include "ap_sha1.h"

#define SET_BYTES_SENT(r) \
  do { if (r->sent_bodyct) \
          ap_bgetopt (r->connection->client, BO_BYTECT, &r->bytes_sent); \
  } while (0)

/*
 * Builds the content-type that should be sent to the client from the
 * content-type specified.  The following rules are followed:
 *    - if type is NULL, type is set to ap_default_type(r)
 *    - if charset adding is disabled, stop processing and return type.
 *    - then, if there are no parameters on type, add the default charset
 *    - return type
 */
static const char *make_content_type(request_rec *r, const char *type) {
    char *needcset[] = {
	"text/plain",
	"text/html",
	NULL };
    char **pcset;
    core_dir_config *conf;

    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
                                                   &core_module);
    if (!type) {
        type = ap_default_type(r);
    }
    if (conf->add_default_charset != ADD_DEFAULT_CHARSET_ON) {
        return type;
    }

    if (ap_strcasestr(type, "charset=") != NULL) {
	/* already has parameter, do nothing */
	/* XXX we don't check the validity */
	;
    }
    else {
    	/* see if it makes sense to add the charset. At present,
	 * we only add it if the Content-type is one of needcset[]
	 */
	for (pcset = needcset; *pcset ; pcset++) {
	    if (ap_strcasestr(type, *pcset) != NULL) {
		type = ap_pstrcat(r->pool, type, "; charset=", 
                                  conf->add_default_charset_name, NULL);
		break;
	    }
        }
    }
    return type;
}

enum byterange_token {
    BYTERANGE_OK,
    BYTERANGE_EMPTY,
    BYTERANGE_BADSYNTAX,
    BYTERANGE_UNSATISFIABLE
};

static enum byterange_token
    parse_byterange(request_rec *r, off_t *start, off_t *end)
{
    const char *estr;
    /* parsing first, semantics later */

    while (ap_isspace(*r->range))
        ++r->range;

    /* check for an empty range, which is OK */
    if (*r->range == '\0') {
	return BYTERANGE_EMPTY;
    }
    else if (*r->range == ',') {
	++r->range;
	return BYTERANGE_EMPTY;
    }

    if (ap_isdigit(*r->range))
        *start = strtoll(r->range, (char **)&r->range, 10);
    else
        *start = -1;

    while (ap_isspace(*r->range))
        ++r->range;

    if (*r->range != '-')
	return BYTERANGE_BADSYNTAX;
    ++r->range;

    while (ap_isspace(*r->range))
        ++r->range;

    if (ap_isdigit(*r->range))
        *end = strtoll(r->range, (char **)&r->range, 10);
    else
        *end = -1;

    while (ap_isspace(*r->range))
        ++r->range;

    /* check the end of the range */
    if (*r->range == ',') {
	++r->range;
    }
    else if (*r->range != '\0') {
	return BYTERANGE_BADSYNTAX;
    }

    /* parsing done; now check the numbers */

    if (*start < 0) { /* suffix-byte-range-spec */
	if (*end < 0) /* no numbers */
	    return BYTERANGE_BADSYNTAX;
	*start = r->clength - *end;
	if (*start < 0)
	    *start = 0;
	*end = r->clength - 1;
    }
    else {
	if (*end >= 0 && *start > *end) /* out-of-order range */
	    return BYTERANGE_BADSYNTAX;
	if (*end < 0 || *end >= r->clength)
	    *end = r->clength - 1;
    }
    /* RFC 2616 is somewhat unclear about what we should do if the end
     * is missing and the start is after the clength. The robustness
     * principle says we should accept it as an unsatisfiable range.
     * We accept suffix-byte-range-specs like -0 for the same reason.
     */
    if (*start >= r->clength)
	return BYTERANGE_UNSATISFIABLE;

    return BYTERANGE_OK;
}

/* If this function is called with output=1, it will spit out the
 * correct headers for a byterange chunk. If output=0 it will not
 * output anything but just return the number of bytes it would have
 * output. If start or end are less than 0 then it will do a byterange
 * chunk trailer instead of a header.
 */
static int byterange_boundary(request_rec *r, off_t start , off_t end, int output)
{
    int length = 0;

    if (start < 0 || end < 0) {
	if (output)
	    ap_rvputs(r, CRLF "--", r->boundary, "--" CRLF, NULL);
	else
	    length = 4 + strlen(r->boundary) + 4;
    }
    else {
	const char *ct = make_content_type(r, r->content_type);
	char ts[MAX_STRING_LEN];

	ap_snprintf(ts, sizeof(ts), "%qd-%qd/%qd", start, end, r->clength);
	if (output)
	    ap_rvputs(r, CRLF "--", r->boundary, CRLF "Content-type: ",
		      ct, CRLF "Content-range: bytes ", ts, CRLF CRLF,
		      NULL);
	else
	    length = 4 + strlen(r->boundary) + 16
		+ strlen(ct) + 23 + strlen(ts) + 4;
    }

    return length;
}

API_EXPORT(int) ap_set_byterange(request_rec *r)
{
    const char *range, *if_range, *match;
    char *bbuf, *b;
    u_int32_t rbuf[12]; /* 48 bytes yields 64 base64 chars */
    off_t length, start, end, one_start = 0, one_end = 0;
    size_t u;
    int ranges, empty;
    
    if (!r->clength || r->assbackwards)
        return 0;

    /* Check for Range request-header (HTTP/1.1) or Request-Range for
     * backwards-compatibility with second-draft Luotonen/Franks
     * byte-ranges (e.g. Netscape Navigator 2-3).
     *
     * We support this form, with Request-Range, and (farther down) we
     * send multipart/x-byteranges instead of multipart/byteranges for
     * Request-Range based requests to work around a bug in Netscape
     * Navigator 2-3 and MSIE 3.
     */

    if (!(range = ap_table_get(r->headers_in, "Range")))
        range = ap_table_get(r->headers_in, "Request-Range");

    if (!range || strncasecmp(range, "bytes=", 6)) {
        return 0;
    }
    range += 6;

    /* Check the If-Range header for Etag or Date.
     * Note that this check will return false (as required) if either
     * of the two etags are weak.
     */
    if ((if_range = ap_table_get(r->headers_in, "If-Range"))) {
        if (if_range[0] == '"') {
            if (!(match = ap_table_get(r->headers_out, "Etag")) ||
                (strcmp(if_range, match) != 0))
                return 0;
        }
        else if (!(match = ap_table_get(r->headers_out, "Last-Modified")) ||
                 (strcmp(if_range, match) != 0))
            return 0;
    }

    /*
     * Parse the byteranges, counting how many of them there are and
     * the total number of bytes we will send to the client. This is a
     * dummy run for the while(ap_each_byterange()) loop that the
     * caller will perform if we return 1.
     */
    r->range = range;
    for (u = 0; u < sizeof(rbuf)/sizeof(rbuf[0]); u++)
        rbuf[u] = htonl(arc4random());

    bbuf = ap_palloc(r->pool, ap_base64encode_len(sizeof(rbuf)));
    ap_base64encode(bbuf, (const unsigned char *)rbuf, sizeof(rbuf));
    for (b = bbuf; *b != '\0'; b++) {
        if (((b - bbuf) + 1) % 7 == 0)
            *b = '-';
        else if (!isalnum(*b))
            *b = 'a';
    }

    r->boundary = bbuf;

    length = 0;
    ranges = 0;
    empty = 1;
    do {
	switch (parse_byterange(r, &start, &end)) {
	case BYTERANGE_UNSATISFIABLE:
	    empty = 0;
	    break;
	default:
	    /* be more defensive here? */
	case BYTERANGE_BADSYNTAX:
	    r->boundary = NULL;
	    r->range = NULL;
	    return 0;
	case BYTERANGE_EMPTY:
	    break;
	case BYTERANGE_OK:
	    ++ranges;
	    length += byterange_boundary(r, start, end, 0)
		+ end - start + 1;
	    /* save in case of unsatisfiable ranges */
	    one_start = start;
	    one_end = end;
	    break;
	}
    } while (*r->range != '\0');

    if (ranges == 0) {
	/* no ranges or only unsatisfiable ranges */
	if (empty || if_range) {
	    r->boundary = NULL;
	    r->range = NULL;
	    return 0;
	}
	else {
	    ap_table_setn(r->headers_out, "Content-Range",
		ap_psprintf(r->pool, "bytes */%qd", r->clength));
	    ap_set_content_length(r, 0);			  
	    r->boundary = NULL;
	    r->range = range;
	    r->header_only = 1;
	    r->status = HTTP_RANGE_NOT_SATISFIABLE;
	    return 1;
	}
    }
    else if (ranges == 1) {
	/* simple handling of a single range -- no boundaries */
        ap_table_setn(r->headers_out, "Content-Range",
	    ap_psprintf(r->pool, "bytes %qd-%qd/%qd",
		one_start, one_end, r->clength));
	ap_table_setn(r->headers_out, "Content-Length",
	    ap_psprintf(r->pool, "%qd", one_end - one_start + 1LL));
	r->boundary = NULL;
	r->byterange = 1;
	r->range = range;
	r->status = PARTIAL_CONTENT;
	return 1;
    }
    else {
	/* multiple ranges */
	length += byterange_boundary(r, -1, -1, 0);
	ap_table_setn(r->headers_out, "Content-Length",
	    ap_psprintf(r->pool, "%qd", length));
	r->byterange = 2;
	r->range = range;
	r->status = PARTIAL_CONTENT;
	return 1;
    }
}

API_EXPORT(int) ap_each_byterange(request_rec *r, off_t *offset, off_t *length)
{
    off_t start, end;

    do {
	if (parse_byterange(r, &start, &end) == BYTERANGE_OK) {
	    if (r->byterange > 1)
		byterange_boundary(r, start, end, 1);
	    *offset = start;
	    *length = end - start + 1;
	    return 1;
	}
    } while (*r->range != '\0');
    if (r->byterange > 1)
	byterange_boundary(r, -1, -1, 1);
    return 0;
}

API_EXPORT(int) ap_set_content_length(request_rec *r, off_t clength)
{
    r->clength = clength;
    ap_table_setn(r->headers_out, "Content-Length", ap_psprintf(r->pool, "%qd", clength));
    return 0;
}

API_EXPORT(int) ap_set_keepalive(request_rec *r)
{
    int ka_sent = 0;
    int wimpy = ap_find_token(r->pool,
                           ap_table_get(r->headers_out, "Connection"), "close");
    const char *conn = ap_table_get(r->headers_in, "Connection");

    /* The following convoluted conditional determines whether or not
     * the current connection should remain persistent after this response
     * (a.k.a. HTTP Keep-Alive) and whether or not the output message
     * body should use the HTTP/1.1 chunked transfer-coding.  In English,
     *
     *   IF  we have not marked this connection as errored;
     *   and the response body has a defined length due to the status code
     *       being 304 or 204, the request method being HEAD, already
     *       having defined Content-Length or Transfer-Encoding: chunked, or
     *       the request version being HTTP/1.1 and thus capable of being set
     *       as chunked [we know the (r->chunked = 1) side-effect is ugly];
     *   and the server configuration enables keep-alive;
     *   and the server configuration has a reasonable inter-request timeout;
     *   and there is no maximum # requests or the max hasn't been reached;
     *   and the response status does not require a close;
     *   and the response generator has not already indicated close;
     *   and the client did not request non-persistence (Connection: close);
     *   and    we haven't been configured to ignore the buggy twit
     *       or they're a buggy twit coming through a HTTP/1.1 proxy
     *   and    the client is requesting an HTTP/1.0-style keep-alive
     *       or the client claims to be HTTP/1.1 compliant (perhaps a proxy);
     *   THEN we can be persistent, which requires more headers be output.
     *
     * Note that the condition evaluation order is extremely important.
     */
    if ((r->connection->keepalive != -1) &&
        ((r->status == HTTP_NOT_MODIFIED) ||
         (r->status == HTTP_NO_CONTENT) ||
         r->header_only ||
         ap_table_get(r->headers_out, "Content-Length") ||
         ap_find_last_token(r->pool,
                         ap_table_get(r->headers_out, "Transfer-Encoding"),
                         "chunked") ||
         ((r->proto_num >= HTTP_VERSION(1,1)) &&
	  (r->chunked = 1))) && /* THIS CODE IS CORRECT, see comment above. */
        r->server->keep_alive &&
        (r->server->keep_alive_timeout > 0) &&
        ((r->server->keep_alive_max == 0) ||
         (r->server->keep_alive_max > r->connection->keepalives)) &&
        !ap_status_drops_connection(r->status) &&
        !wimpy &&
        !ap_find_token(r->pool, conn, "close") &&
        (!ap_table_get(r->subprocess_env, "nokeepalive") ||
         ap_table_get(r->headers_in, "Via")) &&
        ((ka_sent = ap_find_token(r->pool, conn, "keep-alive")) ||
         (r->proto_num >= HTTP_VERSION(1,1)))
       ) {
        int left = r->server->keep_alive_max - r->connection->keepalives;

        r->connection->keepalive = 1;
        r->connection->keepalives++;

        /* If they sent a Keep-Alive token, send one back */
        if (ka_sent) {
            if (r->server->keep_alive_max)
		ap_table_setn(r->headers_out, "Keep-Alive",
		    ap_psprintf(r->pool, "timeout=%d, max=%d",
                            r->server->keep_alive_timeout, left));
            else
		ap_table_setn(r->headers_out, "Keep-Alive",
		    ap_psprintf(r->pool, "timeout=%d",
                            r->server->keep_alive_timeout));
            ap_table_mergen(r->headers_out, "Connection", "Keep-Alive");
        }

        return 1;
    }

    /* Otherwise, we need to indicate that we will be closing this
     * connection immediately after the current response.
     *
     * We only really need to send "close" to HTTP/1.1 clients, but we
     * always send it anyway, because a broken proxy may identify itself
     * as HTTP/1.0, but pass our request along with our HTTP/1.1 tag
     * to a HTTP/1.1 client. Better safe than sorry.
     */
    if (!wimpy)
	ap_table_mergen(r->headers_out, "Connection", "close");

    r->connection->keepalive = 0;

    return 0;
}

/*
 * Return the latest rational time from a request/mtime (modification time)
 * pair.  We return the mtime unless it's in the future, in which case we
 * return the current time.  We use the request time as a reference in order
 * to limit the number of calls to time().  We don't check for futurosity
 * unless the mtime is at least as new as the reference.
 */
API_EXPORT(time_t) ap_rationalize_mtime(request_rec *r, time_t mtime)
{
    time_t now;

    /* For all static responses, it's almost certain that the file was
     * last modified before the beginning of the request.  So there's
     * no reason to call time(NULL) again.  But if the response has been
     * created on demand, then it might be newer than the time the request
     * started.  In this event we really have to call time(NULL) again
     * so that we can give the clients the most accurate Last-Modified.  If we
     * were given a time in the future, we return the current time - the
     * Last-Modified can't be in the future.
     */
    now = (mtime < r->request_time) ? r->request_time : time(NULL);
    return (mtime > now) ? now : mtime;
}

API_EXPORT(int) ap_meets_conditions(request_rec *r)
{
    const char *etag = ap_table_get(r->headers_out, "ETag");
    const char *if_match, *if_modified_since, *if_unmodified, *if_nonematch;
    time_t mtime;

    /* Check for conditional requests --- note that we only want to do
     * this if we are successful so far and we are not processing a
     * subrequest or an ErrorDocument.
     *
     * The order of the checks is important, since ETag checks are supposed
     * to be more accurate than checks relative to the modification time.
     * However, not all documents are guaranteed to *have* ETags, and some
     * might have Last-Modified values w/o ETags, so this gets a little
     * complicated.
     */

    if (!ap_is_HTTP_SUCCESS(r->status) || r->no_local_copy) {
        return OK;
    }

    mtime = (r->mtime != 0) ? r->mtime : time(NULL);

    /* If an If-Match request-header field was given
     * AND the field value is not "*" (meaning match anything)
     * AND if our strong ETag does not match any entity tag in that field,
     *     respond with a status of 412 (Precondition Failed).
     */
    if ((if_match = ap_table_get(r->headers_in, "If-Match")) != NULL) {
        if (if_match[0] != '*' &&
            (etag == NULL || etag[0] == 'W' ||
             !ap_find_list_item(r->pool, if_match, etag))) {
            return HTTP_PRECONDITION_FAILED;
        }
    }
    else {
        /* Else if a valid If-Unmodified-Since request-header field was given
         * AND the requested resource has been modified since the time
         * specified in this field, then the server MUST
         *     respond with a status of 412 (Precondition Failed).
         */
        if_unmodified = ap_table_get(r->headers_in, "If-Unmodified-Since");
        if (if_unmodified != NULL) {
            time_t ius = ap_parseHTTPdate(if_unmodified);

            if ((ius != BAD_DATE) && (mtime > ius)) {
                return HTTP_PRECONDITION_FAILED;
            }
        }
    }

    /* If an If-None-Match request-header field was given
     * AND the field value is "*" (meaning match anything)
     *     OR our ETag matches any of the entity tags in that field, fail.
     *
     * If the request method was GET or HEAD, failure means the server
     *    SHOULD respond with a 304 (Not Modified) response.
     * For all other request methods, failure means the server MUST
     *    respond with a status of 412 (Precondition Failed).
     *
     * GET or HEAD allow weak etag comparison, all other methods require
     * strong comparison.  We can only use weak if it's not a range request.
     */
    if_nonematch = ap_table_get(r->headers_in, "If-None-Match");
    if (if_nonematch != NULL) {
        if (r->method_number == M_GET) {
            if (if_nonematch[0] == '*')
                return HTTP_NOT_MODIFIED;
            if (etag != NULL) {
                if (ap_table_get(r->headers_in, "Range")) {
                    if (etag[0] != 'W' &&
                        ap_find_list_item(r->pool, if_nonematch, etag)) {
                        return HTTP_NOT_MODIFIED;
                    }
                }
                else if (strstr(if_nonematch, etag)) {
                    return HTTP_NOT_MODIFIED;
                }
            }
        }
        else if (if_nonematch[0] == '*' ||
                 (etag != NULL &&
                  ap_find_list_item(r->pool, if_nonematch, etag))) {
            return HTTP_PRECONDITION_FAILED;
        }
    }
    /* Else if a valid If-Modified-Since request-header field was given
     * AND it is a GET or HEAD request
     * AND the requested resource has not been modified since the time
     * specified in this field, then the server MUST
     *    respond with a status of 304 (Not Modified).
     * A date later than the server's current request time is invalid.
     */
    else if ((r->method_number == M_GET)
             && ((if_modified_since =
                  ap_table_get(r->headers_in, "If-Modified-Since")) != NULL)) {
        time_t ims = ap_parseHTTPdate(if_modified_since);

        if ((ims >= mtime) && (ims <= r->request_time)) {
            return HTTP_NOT_MODIFIED;
        }
    }
    return OK;
}

/*
 * Construct an entity tag (ETag) from resource information.  If it's a real
 * file, build in some of the file characteristics.  If the modification time
 * is newer than (request-time minus 1 second), mark the ETag as weak - it
 * could be modified again in as short an interval.  We rationalize the
 * modification time we're given to keep it from being in the future.
 */
API_EXPORT(char *) ap_make_etag_orig(request_rec *r, int force_weak)
{
    char *etag;
    char *weak;
    core_dir_config *cfg;
    etag_components_t etag_bits;

    cfg = (core_dir_config *)ap_get_module_config(r->per_dir_config,
                                                  &core_module);
    etag_bits = (cfg->etag_bits & (~ cfg->etag_remove)) | cfg->etag_add;
    if (etag_bits == ETAG_UNSET) {
        etag_bits = ETAG_BACKWARD;
    }
    /*
     * Make an ETag header out of various pieces of information. We use
     * the last-modified date and, if we have a real file, the
     * length and inode number - note that this doesn't have to match
     * the content-length (i.e. includes), it just has to be unique
     * for the file.
     *
     * If the request was made within a second of the last-modified date,
     * we send a weak tag instead of a strong one, since it could
     * be modified again later in the second, and the validation
     * would be incorrect.
     */
    
    weak = ((r->request_time - r->mtime > 1) && !force_weak) ? "" : "W/";

    if (r->finfo.st_mode != 0) {
        char **ent;
        array_header *components;
        int i;

        /*
         * If it's a file (or we wouldn't be here) and no ETags
         * should be set for files, return an empty string and
         * note it for ap_send_header_field() to ignore.
         */
        if (etag_bits & ETAG_NONE) {
            ap_table_setn(r->notes, "no-etag", "omit");
            return "";
        }

        components = ap_make_array(r->pool, 4, sizeof(char *));
        if (etag_bits & ETAG_INODE) {
            ent = (char **) ap_push_array(components);
            *ent = ap_psprintf(r->pool, "%qx",
                               (unsigned long long) r->finfo.st_ino);
        }
        if (etag_bits & ETAG_SIZE) {
            ent = (char **) ap_push_array(components);
            *ent = ap_psprintf(r->pool, "%lx",
                               (unsigned long) r->finfo.st_size);
        }
        if (etag_bits & ETAG_MTIME) {
            ent = (char **) ap_push_array(components);
            *ent = ap_psprintf(r->pool, "%lx", (unsigned long) r->mtime);
        }
        ent = (char **) components->elts;
        etag = ap_pstrcat(r->pool, weak, "\"", NULL);
        for (i = 0; i < components->nelts; ++i) {
            etag = ap_psprintf(r->pool, "%s%s%s", etag,
                               (i == 0 ? "" : "-"),
                               ent[i]);
        }
        etag = ap_pstrcat(r->pool, etag, "\"", NULL);
    }
    else {
        etag = ap_psprintf(r->pool, "%s\"%lx\"", weak,
                    (unsigned long) r->mtime);
    }

    return etag;
}

API_EXPORT(void) ap_set_etag(request_rec *r)
{
    char *etag;
    char *variant_etag, *vlv;
    int vlv_weak;

    if (!r->vlist_validator) {
        etag = ap_make_etag(r, 0);

        /* If we get a blank etag back, don't set the header. */
        if (!etag[0]) {
            return;
        }
    }
    else {
        /* If we have a variant list validator (vlv) due to the
         * response being negotiated, then we create a structured
         * entity tag which merges the variant etag with the variant
         * list validator (vlv).  This merging makes revalidation
         * somewhat safer, ensures that caches which can deal with
         * Vary will (eventually) be updated if the set of variants is
         * changed, and is also a protocol requirement for transparent
         * content negotiation.
         */

        /* if the variant list validator is weak, we make the whole
         * structured etag weak.  If we would not, then clients could
         * have problems merging range responses if we have different
         * variants with the same non-globally-unique strong etag.
         */

        vlv = r->vlist_validator;
        vlv_weak = (vlv[0] == 'W');
               
        variant_etag = ap_make_etag(r, vlv_weak);

        /* If we get a blank etag back, don't append vlv and stop now. */
        if (!variant_etag[0]) {
            return;
        }

        /* merge variant_etag and vlv into a structured etag */
        variant_etag[strlen(variant_etag) - 1] = '\0';
        if (vlv_weak)
            vlv += 3;
        else
            vlv++;
        etag = ap_pstrcat(r->pool, variant_etag, ";", vlv, NULL);
    }

    ap_table_setn(r->headers_out, "ETag", etag);
}

/*
 * This function sets the Last-Modified output header field to the value
 * of the mtime field in the request structure - rationalized to keep it from
 * being in the future.
 */
API_EXPORT(void) ap_set_last_modified(request_rec *r)
{
    time_t mod_time = ap_rationalize_mtime(r, r->mtime);

    ap_table_setn(r->headers_out, "Last-Modified",
              ap_gm_timestr_822(r->pool, mod_time));
}

/* Get the method number associated with the given string, assumed to
 * contain an HTTP method.  Returns M_INVALID if not recognized.
 *
 * This is the first step toward placing method names in a configurable
 * list.  Hopefully it (and other routines) can eventually be moved to
 * something like a mod_http_methods.c, complete with config stuff.
 */
API_EXPORT(int) ap_method_number_of(const char *method)
{
    switch (*method) {
        case 'H':
           if (strcmp(method, "HEAD") == 0)
               return M_GET;   /* see header_only in request_rec */
           break;
        case 'G':
           if (strcmp(method, "GET") == 0)
               return M_GET;
           break;
        case 'P':
           if (strcmp(method, "POST") == 0)
               return M_POST;
           if (strcmp(method, "PUT") == 0)
               return M_PUT;
           if (strcmp(method, "PATCH") == 0)
               return M_PATCH;
           if (strcmp(method, "PROPFIND") == 0)
               return M_PROPFIND;
           if (strcmp(method, "PROPPATCH") == 0)
               return M_PROPPATCH;
           break;
        case 'D':
           if (strcmp(method, "DELETE") == 0)
               return M_DELETE;
           break;
        case 'C':
           if (strcmp(method, "CONNECT") == 0)
               return M_CONNECT;
           if (strcmp(method, "COPY") == 0)
               return M_COPY;
           break;
        case 'M':
           if (strcmp(method, "MKCOL") == 0)
               return M_MKCOL;
           if (strcmp(method, "MOVE") == 0)
               return M_MOVE;
           break;
        case 'O':
           if (strcmp(method, "OPTIONS") == 0)
               return M_OPTIONS;
           break;
        case 'L':
           if (strcmp(method, "LOCK") == 0)
               return M_LOCK;
           break;
        case 'U':
           if (strcmp(method, "UNLOCK") == 0)
               return M_UNLOCK;
           break;
    }
    return M_INVALID;
}

/* Get a line of protocol input, including any continuation lines
 * caused by MIME folding (or broken clients) if fold != 0, and place it
 * in the buffer s, of size n bytes, without the ending newline.
 *
 * Returns -1 on error, or the length of s.
 *
 * Note: Because bgets uses 1 char for newline and 1 char for NUL,
 *       the most we can get is (n - 2) actual characters if it
 *       was ended by a newline, or (n - 1) characters if the line
 *       length exceeded (n - 1).  So, if the result == (n - 1),
 *       then the actual input line exceeded the buffer length,
 *       and it would be a good idea for the caller to puke 400 or 414.
 */
API_EXPORT(int) ap_getline(char *s, int n, BUFF *in, int fold)
{
    char *pos, next;
    int retval;
    int total = 0;

    pos = s;

    do {
        retval = ap_bgets(pos, n, in);     /* retval == -1 if error, 0 if EOF */

        if (retval <= 0) {
            total = ((retval < 0) && (total == 0)) ? -1 : total;
            break;
        }

        /* retval is the number of characters read, not including NUL      */

        n -= retval;            /* Keep track of how much of s is full     */
        pos += (retval - 1);    /* and where s ends                        */
        total += retval;        /* and how long s has become               */

        if (*pos == '\n') {     /* Did we get a full line of input?        */
            /*
             * Trim any extra trailing spaces or tabs except for the first
             * space or tab at the beginning of a blank string.  This makes
             * it much easier to check field values for exact matches, and
             * saves memory as well.  Terminate string at end of line.
             */
            while (pos > (s + 1) && (*(pos - 1) == ' ' || *(pos - 1) == '\t')) {
                --pos;          /* trim extra trailing spaces or tabs      */
                --total;        /* but not one at the beginning of line    */
                ++n;
            }
            *pos = '\0';
            --total;
            ++n;
        }
        else
            break;       /* if not, input line exceeded buffer size */

        /* Continue appending if line folding is desired and
         * the last line was not empty and we have room in the buffer and
         * the next line begins with a continuation character.
         */
    } while (fold && (retval != 1) && (n > 1)
                  && (ap_blookc(&next, in) == 1)
                  && ((next == ' ') || (next == '\t')));

    return total;
}

/* parse_uri: break apart the uri
 * Side Effects:
 * - sets r->args to rest after '?' (or NULL if no '?')
 * - sets r->uri to request uri (without r->args part)
 * - sets r->hostname (if not set already) from request (scheme://host:port)
 */
CORE_EXPORT(void) ap_parse_uri(request_rec *r, const char *uri)
{
    int status = HTTP_OK;

    r->unparsed_uri = ap_pstrdup(r->pool, uri);

    if (r->method_number == M_CONNECT) {
	status = ap_parse_hostinfo_components(r->pool, uri, &r->parsed_uri);
    } else {
	/* Simple syntax Errors in URLs are trapped by parse_uri_components(). */
	status = ap_parse_uri_components(r->pool, uri, &r->parsed_uri);
    }

    if (ap_is_HTTP_SUCCESS(status)) {
	/* if it has a scheme we may need to do absoluteURI vhost stuff */
	if (r->parsed_uri.scheme
	    && !strcasecmp(r->parsed_uri.scheme, ap_http_method(r))) {
	    r->hostname = r->parsed_uri.hostname;
	} else if (r->method_number == M_CONNECT) {
	    r->hostname = r->parsed_uri.hostname;
	}
	r->args = r->parsed_uri.query;
	r->uri = r->parsed_uri.path ? r->parsed_uri.path
				    : ap_pstrdup(r->pool, "/");
    }
    else {
	r->args = NULL;
	r->hostname = NULL;
	r->status = status;             /* set error status */
	r->uri = ap_pstrdup(r->pool, uri);
    }
}

static int read_request_line(request_rec *r)
{
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* ap_getline's two extra for \n\0 */
    const char *ll = l;
    const char *uri;
    conn_rec *conn = r->connection;
    unsigned int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len = 0;
    int valid_protocol = 1;

    /* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */
    ap_bsetflag(conn->client, B_SAFEREAD, 1);
    while ((len = ap_getline(l, sizeof(l), conn->client, 0)) <= 0) {
        if ((len < 0) || ap_bgetflag(conn->client, B_EOF)) {
            ap_bsetflag(conn->client, B_SAFEREAD, 0);
	    /* this is a hack to make sure that request time is set,
	     * it's not perfect, but it's better than nothing 
	     */
	    r->request_time = time(0);
            return 0;
        }
    }
    /* we've probably got something to do, ignore graceful restart requests */
    signal(SIGUSR1, SIG_IGN);

    ap_bsetflag(conn->client, B_SAFEREAD, 0);

    r->request_time = time(NULL);
    r->the_request = ap_pstrdup(r->pool, l);
    r->method = ap_getword_white(r->pool, &ll);
    uri = ap_getword_white(r->pool, &ll);

    /* Provide quick information about the request method as soon as known */

    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
        r->header_only = 1;
    }

    ap_parse_uri(r, uri);

    /* ap_getline returns (size of max buffer - 1) if it fills up the
     * buffer before finding the end-of-line.  This is only going to
     * happen if it exceeds the configured limit for a request-line.
     */
    if (len > r->server->limit_req_line) {
        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = ap_pstrdup(r->pool, "HTTP/1.0");
        return 0;
    }

    r->assbackwards = (ll[0] == '\0');
    r->protocol = ap_pstrdup(r->pool, ll[0] ? ll : "HTTP/0.9");

    /* Avoid sscanf in the common case */
    if (strlen(r->protocol) == 8
        && r->protocol[0] == 'H' && r->protocol[1] == 'T'
	&& r->protocol[2] == 'T' && r->protocol[3] == 'P'
        && r->protocol[4] == '/' && ap_isdigit(r->protocol[5])
	&& r->protocol[6] == '.' && ap_isdigit(r->protocol[7])) {
        r->proto_num = HTTP_VERSION(r->protocol[5] - '0', r->protocol[7] - '0');
    }
    else {
        char lint[2];
        char http[5];
	if (3 == sscanf(r->protocol, "%4s/%u.%u%1s", http, &major, &minor, lint)
            && (strcasecmp("http", http) == 0)
	    && (minor < HTTP_VERSION(1,0)) ) /* don't allow HTTP/0.1000 */
	    r->proto_num = HTTP_VERSION(major, minor);
	else {
	    r->proto_num = HTTP_VERSION(1,0);
	    valid_protocol = 0;
	}
    }

    /* Check for a valid protocol, and disallow everything but whitespace
     * after the protocol string. A protocol string of nothing but
     * whitespace is considered valid */
    if (ap_protocol_req_check && !valid_protocol) {
        int n = 0;
	while (ap_isspace(r->protocol[n]))
	    ++n;
	if (r->protocol[n] != '\0') {
	    r->status    = HTTP_BAD_REQUEST;
	    r->proto_num = HTTP_VERSION(1,0);
	    r->protocol  = ap_pstrdup(r->pool, "HTTP/1.0");
	    ap_table_setn(r->notes, "error-notes",
                     "The request line contained invalid characters "
                     "following the protocol string.<P>\n");
	    return 0;
	}
    }

    return 1;
}

static void get_mime_headers(request_rec *r)
{
    char field[DEFAULT_LIMIT_REQUEST_FIELDSIZE + 2]; /* ap_getline's two extra */
    conn_rec *c = r->connection;
    char *value;
    char *copy;
    int len;
    int fields_read = 0;
    table *tmp_headers;

    /* We'll use ap_overlap_tables later to merge these into r->headers_in. */
    tmp_headers = ap_make_table(r->pool, 50);

    /*
     * Read header lines until we get the empty separator line, a read error,
     * the connection closes (EOF), reach the server limit, or we timeout.
     */
    while ((len = ap_getline(field, sizeof(field), c->client, 1)) > 0) {

        if (r->server->limit_req_fields &&
            (++fields_read > r->server->limit_req_fields)) {
            r->status = HTTP_BAD_REQUEST;
            ap_table_setn(r->notes, "error-notes",
                          "The number of request header fields exceeds "
                          "this server's limit.<P>\n");
            return;
        }
        /* ap_getline returns (size of max buffer - 1) if it fills up the
         * buffer before finding the end-of-line.  This is only going to
         * happen if it exceeds the configured limit for a field size.
         */
        if (len > r->server->limit_req_fieldsize) {
            r->status = HTTP_BAD_REQUEST;
            ap_table_setn(r->notes, "error-notes", ap_pstrcat(r->pool,
                "Size of a request header field exceeds server limit.<P>\n"
                "<PRE>\n", ap_escape_html(r->pool, field), "</PRE>\n", NULL));
            return;
        }
        copy = ap_palloc(r->pool, len + 1);
        memcpy(copy, field, len + 1);

        if (!(value = strchr(copy, ':'))) {     /* Find the colon separator */
            r->status = HTTP_BAD_REQUEST;       /* or abort the bad request */
            ap_table_setn(r->notes, "error-notes", ap_pstrcat(r->pool,
                "Request header field is missing colon separator.<P>\n"
                "<PRE>\n", ap_escape_html(r->pool, copy), "</PRE>\n", NULL));
            return;
        }

        *value = '\0';
        ++value;
        while (*value == ' ' || *value == '\t')
            ++value;            /* Skip to start of value   */

	ap_table_addn(tmp_headers, copy, value);
    }

    ap_overlap_tables(r->headers_in, tmp_headers, AP_OVERLAP_TABLES_MERGE);
}

API_EXPORT(request_rec *) ap_read_request(conn_rec *conn)
{
    request_rec *r;
    pool *p;
    const char *expect;
    int access_status;

    p = ap_make_sub_pool(conn->pool);
    r = ap_pcalloc(p, sizeof(request_rec));
    r->pool            = p;
    r->connection      = conn;
    conn->server       = conn->base_server;
    r->server          = conn->server;

    conn->keptalive    = conn->keepalive == 1;
    conn->keepalive    = 0;

    conn->user         = NULL;
    conn->ap_auth_type    = NULL;

    r->headers_in      = ap_make_table(r->pool, 50);
    r->subprocess_env  = ap_make_table(r->pool, 50);
    r->headers_out     = ap_make_table(r->pool, 12);
    r->err_headers_out = ap_make_table(r->pool, 5);
    r->notes           = ap_make_table(r->pool, 5);

    r->request_config  = ap_create_request_config(r->pool);
    r->per_dir_config  = r->server->lookup_defaults;

    r->sent_bodyct     = 0;                      /* bytect isn't for body */

    r->read_length     = 0;
    r->read_body       = REQUEST_NO_BODY;

    r->status          = HTTP_REQUEST_TIME_OUT;  /* Until we get a request */
    r->the_request     = NULL;

    r->ctx = ap_ctx_new(r->pool);

    /* Get the request... */

    ap_keepalive_timeout("read request line", r);
    if (!read_request_line(r)) {
        ap_kill_timeout(r);
        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {

            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                         "request failed: URI too long");
            ap_send_error_response(r, 0);
            ap_log_transaction(r);
            return r;
        }
        else if (r->status == HTTP_BAD_REQUEST) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                         "request failed: erroneous characters after protocol string: %s",
			 ap_escape_logitem(r->pool, r->the_request));
            ap_send_error_response(r, 0);
            ap_log_transaction(r);
            return r;
        }
        return NULL;
    }
    if (!r->assbackwards) {
        ap_hard_timeout("read request headers", r);
        get_mime_headers(r);
        ap_kill_timeout(r);
        if (r->status != HTTP_REQUEST_TIME_OUT) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                         "request failed: error reading the headers");
            ap_send_error_response(r, 0);
            ap_log_transaction(r);
            return r;
        }
    }
    else {
        ap_kill_timeout(r);

        if (r->header_only) {
            /*
             * Client asked for headers only with HTTP/0.9, which doesn't send
             * headers! Have to dink things just to make sure the error message
             * comes through...
             */
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                          "client sent invalid HTTP/0.9 request: HEAD %s",
                          r->uri);
            r->header_only = 0;
            r->status = HTTP_BAD_REQUEST;
            ap_send_error_response(r, 0);
            ap_log_transaction(r);
            return r;
        }
    }

    r->status = HTTP_OK;                         /* Until further notice. */

    /* update what we think the virtual host is based on the headers we've
     * now read. may update status.
     */
    ap_update_vhost_from_headers(r);

    /* we may have switched to another server */
    r->per_dir_config = r->server->lookup_defaults;

    conn->keptalive = 0;        /* We now have a request to play with */

    if ((!r->hostname && (r->proto_num >= HTTP_VERSION(1,1))) ||
        ((r->proto_num == HTTP_VERSION(1,1)) &&
         !ap_table_get(r->headers_in, "Host"))) {
        /*
         * Client sent us an HTTP/1.1 or later request without telling us the
         * hostname, either with a full URL or a Host: header. We therefore
         * need to (as per the 1.1 spec) send an error.  As a special case,
         * HTTP/1.1 mentions twice (S9, S14.23) that a request MUST contain
         * a Host: header, and the server MUST respond with 400 if it doesn't.
         */
        r->status = HTTP_BAD_REQUEST;
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                      "client sent HTTP/1.1 request without hostname "
                      "(see RFC2616 section 14.23): %s", r->uri);
    }
    if (r->status != HTTP_OK) {
        ap_send_error_response(r, 0);
        ap_log_transaction(r);
        return r;
    }

    if ((access_status = ap_run_post_read_request(r))) {
        ap_die(access_status, r);
        ap_log_transaction(r);
        return NULL;
    }

    if (((expect = ap_table_get(r->headers_in, "Expect")) != NULL) &&
        (expect[0] != '\0')) {
        /*
         * The Expect header field was added to HTTP/1.1 after RFC 2068
         * as a means to signal when a 100 response is desired and,
         * unfortunately, to signal a poor man's mandatory extension that
         * the server must understand or return 417 Expectation Failed.
         */
        if (strcasecmp(expect, "100-continue") == 0) {
            r->expecting_100 = 1;
        }
        else {
            r->status = HTTP_EXPECTATION_FAILED;
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, r,
                          "client sent an unrecognized expectation value of "
                          "Expect: %s", expect);
            ap_send_error_response(r, 0);
            (void) ap_discard_request_body(r);
            ap_log_transaction(r);
            return r;
        }
    }

    return r;
}

/*
 * A couple of other functions which initialize some of the fields of
 * a request structure, as appropriate for adjuncts of one kind or another
 * to a request in progress.  Best here, rather than elsewhere, since
 * *someone* has to set the protocol-specific fields...
 */

API_EXPORT(void) ap_set_sub_req_protocol(request_rec *rnew, const request_rec *r)
{
    rnew->the_request     = r->the_request;  /* Keep original request-line */

    rnew->assbackwards    = 1;   /* Don't send headers from this. */
    rnew->no_local_copy   = 1;   /* Don't try to send USE_LOCAL_COPY for a
                                  * fragment. */
    rnew->method          = "GET";
    rnew->method_number   = M_GET;
    rnew->protocol        = "INCLUDED";

    rnew->status          = HTTP_OK;

    rnew->headers_in      = r->headers_in;
    rnew->subprocess_env  = ap_copy_table(rnew->pool, r->subprocess_env);
    rnew->headers_out     = ap_make_table(rnew->pool, 5);
    rnew->err_headers_out = ap_make_table(rnew->pool, 5);
    rnew->notes           = ap_make_table(rnew->pool, 5);

    rnew->expecting_100   = r->expecting_100;
    rnew->read_length     = r->read_length;
    rnew->read_body       = REQUEST_NO_BODY;

    rnew->main = (request_rec *) r;

    rnew->ctx = r->ctx;

}

API_EXPORT(void) ap_finalize_sub_req_protocol(request_rec *sub)
{
    SET_BYTES_SENT(sub->main);
}

/*
 * Support for the Basic authentication protocol, and a bit for Digest.
 */

API_EXPORT(void) ap_note_auth_failure(request_rec *r)
{
    if (!strcasecmp(ap_auth_type(r), "Basic"))
        ap_note_basic_auth_failure(r);
    else if (!strcasecmp(ap_auth_type(r), "Digest"))
        ap_note_digest_auth_failure(r);
}

API_EXPORT(void) ap_note_basic_auth_failure(request_rec *r)
{
    if (strcasecmp(ap_auth_type(r), "Basic"))
        ap_note_auth_failure(r);
    else
        ap_table_setn(r->err_headers_out,
                  r->proxyreq == STD_PROXY ? "Proxy-Authenticate"
		      : "WWW-Authenticate",
                  ap_pstrcat(r->pool, "Basic realm=\"", ap_auth_name(r), "\"",
                          NULL));
}

API_EXPORT(void) ap_note_digest_auth_failure(request_rec *r)
{
    /* We need to create a nonce which:
     * a) changes all the time (see r->request_time)
     *    below and
     * b) of which we can verify that it is our own
     *    fairly easily when it comes to veryfing
     *    the digest coming back in the response.
     * c) and which as a whole should not
     *    be unlikely to be in use anywhere else.
     */
    char * nonce_prefix = ap_md5(r->pool,
           (unsigned char *)
           ap_psprintf(r->pool, "%s%lld",
                       ap_auth_nonce(r), (long long)r->request_time));

    ap_table_setn(r->err_headers_out,
	    r->proxyreq == STD_PROXY ? "Proxy-Authenticate"
		  : "WWW-Authenticate",
           ap_psprintf(r->pool, "Digest realm=\"%s\", nonce=\"%s%lld\"",
               ap_auth_name(r), nonce_prefix, (long long)r->request_time));
}

API_EXPORT(int) ap_get_basic_auth_pw(request_rec *r, const char **pw)
{
    const char *auth_line = ap_table_get(r->headers_in,
					 r->proxyreq == STD_PROXY
					 ? "Proxy-Authorization"
					 : "Authorization");
    const char *t;

    if (!(t = ap_auth_type(r)) || strcasecmp(t, "Basic"))
        return DECLINED;

    if (!ap_auth_name(r)) {
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR,
		    r, "need AuthName: %s", r->uri);
        return SERVER_ERROR;
    }

    if (!auth_line) {
        ap_note_basic_auth_failure(r);
        return AUTH_REQUIRED;
    }

    if (strcasecmp(ap_getword(r->pool, &auth_line, ' '), "Basic")) {
        /* Client tried to authenticate using wrong auth scheme */
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                    "client used wrong authentication scheme: %s", r->uri);
        ap_note_basic_auth_failure(r);
        return AUTH_REQUIRED;
    }

    while (*auth_line== ' ' || *auth_line== '\t')
        auth_line++;

    t = ap_pbase64decode(r->pool, auth_line);
    /* Note that this allocation has to be made from r->connection->pool
     * because it has the lifetime of the connection.  The other allocations
     * are temporary and can be tossed away any time.
     */
    r->connection->user = ap_getword_nulls (r->connection->pool, &t, ':');
    r->connection->ap_auth_type = "Basic";

    *pw = t;

    return OK;
}

/* New Apache routine to map status codes into array indicies
 *  e.g.  100 -> 0,  101 -> 1,  200 -> 2 ...
 * The number of status lines must equal the value of RESPONSE_CODES (httpd.h)
 * and must be listed in order.
 */

static const char * const status_lines[RESPONSE_CODES] =
{
    "100 Continue",
    "101 Switching Protocols",
    "102 Processing",
#define LEVEL_200  3
    "200 OK",
    "201 Created",
    "202 Accepted",
    "203 Non-Authoritative Information",
    "204 No Content",
    "205 Reset Content",
    "206 Partial Content",
    "207 Multi-Status",
#define LEVEL_300 11
    "300 Multiple Choices",
    "301 Moved Permanently",
    "302 Found",
    "303 See Other",
    "304 Not Modified",
    "305 Use Proxy",
    "306 unused",
    "307 Temporary Redirect",
#define LEVEL_400 19
    "400 Bad Request",
    "401 Authorization Required",
    "402 Payment Required",
    "403 Forbidden",
    "404 Not Found",
    "405 Method Not Allowed",
    "406 Not Acceptable",
    "407 Proxy Authentication Required",
    "408 Request Time-out",
    "409 Conflict",
    "410 Gone",
    "411 Length Required",
    "412 Precondition Failed",
    "413 Request Entity Too Large",
    "414 Request-URI Too Large",
    "415 Unsupported Media Type",
    "416 Requested Range Not Satisfiable",
    "417 Expectation Failed",
    "418 unused",
    "419 unused",
    "420 unused",
    "421 unused",
    "422 Unprocessable Entity",
    "423 Locked",
    "424 Failed Dependency",
#define LEVEL_500 44
    "500 Internal Server Error",
    "501 Method Not Implemented",
    "502 Bad Gateway",
    "503 Service Temporarily Unavailable",
    "504 Gateway Time-out",
    "505 HTTP Version Not Supported",
    "506 Variant Also Negotiates",
    "507 Insufficient Storage",
    "508 unused",
    "509 unused",
    "510 Not Extended"
};

/* The index is found by its offset from the x00 code of each level.
 * Although this is fast, it will need to be replaced if some nutcase
 * decides to define a high-numbered code before the lower numbers.
 * If that sad event occurs, replace the code below with a linear search
 * from status_lines[shortcut[i]] to status_lines[shortcut[i+1]-1];
 */
API_EXPORT(int) ap_index_of_response(int status)
{
    static int shortcut[6] = {0, LEVEL_200, LEVEL_300, LEVEL_400,
    LEVEL_500, RESPONSE_CODES};
    int i, pos;

    if (status < 100)           /* Below 100 is illegal for HTTP status */
        return LEVEL_500;

    for (i = 0; i < 5; i++) {
        status -= 100;
        if (status < 100) {
            pos = (status + shortcut[i]);
            if (pos < shortcut[i + 1])
                return pos;
            else
                return LEVEL_500;       /* status unknown (falls in gap) */
        }
    }
    return LEVEL_500;           /* 600 or above is also illegal */
}

/* Send a single HTTP header field to the client.  Note that this function
 * is used in calls to table_do(), so their interfaces are co-dependent.
 * In other words, don't change this one without checking table_do in alloc.c.
 * It returns true unless there was a write error of some kind.
 */
API_EXPORT_NONSTD(int) ap_send_header_field(request_rec *r,
                                            const char *fieldname,
                                            const char *fieldval)
{
    if (strcasecmp(fieldname, "ETag") == 0) {
        if (ap_table_get(r->notes, "no-etag") != NULL) {
            return 1;
        }
    }
    return (0 < ap_rvputs(r, fieldname, ": ", fieldval, CRLF, NULL));
}

API_EXPORT(void) ap_basic_http_header(request_rec *r)
{
    char *protocol;

    if (r->assbackwards)
        return;

    if (!r->status_line)
        r->status_line = status_lines[ap_index_of_response(r->status)];

    /* kluge around broken browsers when indicated by force-response-1.0
     */
    if (r->proto_num == HTTP_VERSION(1,0)
       && ap_table_get(r->subprocess_env, "force-response-1.0")) {

        protocol = "HTTP/1.0";
        r->connection->keepalive = -1;
    }
    else
        protocol = SERVER_PROTOCOL;

    /* output the HTTP/1.x Status-Line */
    ap_rvputs(r, protocol, " ", r->status_line, CRLF, NULL);

    /* output the date header */
    ap_send_header_field(r, "Date", ap_gm_timestr_822(r->pool, r->request_time));

    /* keep the set-by-proxy server header, otherwise
     * generate a new server header */
    if (r->proxyreq) {
        const char *server = ap_table_get(r->headers_out, "Server");
        if (server) {
            ap_send_header_field(r, "Server", server);
        }
    }
    else {
        ap_send_header_field(r, "Server", ap_get_server_version());
    }

    /* unset so we don't send them again */
    ap_table_unset(r->headers_out, "Date");        /* Avoid bogosity */
    ap_table_unset(r->headers_out, "Server");
}

/* Navigator versions 2.x, 3.x and 4.0 betas up to and including 4.0b2
 * have a header parsing bug.  If the terminating \r\n occur starting
 * at offset 256, 257 or 258 of output then it will not properly parse
 * the headers.  Curiously it doesn't exhibit this problem at 512, 513.
 * We are guessing that this is because their initial read of a new request
 * uses a 256 byte buffer, and subsequent reads use a larger buffer.
 * So the problem might exist at different offsets as well.
 *
 * This should also work on keepalive connections assuming they use the
 * same small buffer for the first read of each new request.
 *
 * At any rate, we check the bytes written so far and, if we are about to
 * tickle the bug, we instead insert a bogus padding header.  Since the bug
 * manifests as a broken image in Navigator, users blame the server.  :(
 * It is more expensive to check the User-Agent than it is to just add the
 * bytes, so we haven't used the BrowserMatch feature here.
 */
static void terminate_header(BUFF *client)
{
    off_t bs;

    ap_bgetopt(client, BO_BYTECT, &bs);
    if (bs >= 255 && bs <= 257)
        ap_bputs("X-Pad: avoid browser bug" CRLF, client);

    ap_bputs(CRLF, client);  /* Send the terminating empty line */
}

/* Build the Allow field-value from the request handler method mask.
 * Note that we always allow TRACE, since it is handled below.
 */
static char *make_allow(request_rec *r)
{
    return 2 + ap_pstrcat(r->pool,
                   (r->allowed & (1 << M_GET))       ? ", GET, HEAD" : "",
                   (r->allowed & (1 << M_POST))      ? ", POST"      : "",
                   (r->allowed & (1 << M_PUT))       ? ", PUT"       : "",
                   (r->allowed & (1 << M_DELETE))    ? ", DELETE"    : "",
                   (r->allowed & (1 << M_CONNECT))   ? ", CONNECT"   : "",
                   (r->allowed & (1 << M_OPTIONS))   ? ", OPTIONS"   : "",
                   (r->allowed & (1 << M_PATCH))     ? ", PATCH"     : "",
                   (r->allowed & (1 << M_PROPFIND))  ? ", PROPFIND"  : "",
                   (r->allowed & (1 << M_PROPPATCH)) ? ", PROPPATCH" : "",
                   (r->allowed & (1 << M_MKCOL))     ? ", MKCOL"     : "",
                   (r->allowed & (1 << M_COPY))      ? ", COPY"      : "",
                   (r->allowed & (1 << M_MOVE))      ? ", MOVE"      : "",
                   (r->allowed & (1 << M_LOCK))      ? ", LOCK"      : "",
                   (r->allowed & (1 << M_UNLOCK))    ? ", UNLOCK"    : "",
                   ", TRACE",
                   NULL);
}

API_EXPORT(int) ap_send_http_trace(request_rec *r)
{
    int rv;

    /* Get the original request */
    while (r->prev)
        r = r->prev;

    if ((rv = ap_setup_client_block(r, REQUEST_NO_BODY)))
        return rv;

    ap_hard_timeout("send TRACE", r);

    r->content_type = "message/http";
    ap_send_http_header(r);

    /* Now we recreate the request, and echo it back */

    ap_rvputs(r, r->the_request, CRLF, NULL);

    ap_table_do((int (*) (void *, const char *, const char *))
                ap_send_header_field, (void *) r, r->headers_in, NULL);
    ap_rputs(CRLF, r);

    ap_kill_timeout(r);
    return OK;
}

API_EXPORT(int) ap_send_http_options(request_rec *r)
{
    const off_t zero = 0LL;

    if (r->assbackwards)
        return DECLINED;

    ap_hard_timeout("send OPTIONS", r);

    ap_basic_http_header(r);

    ap_table_setn(r->headers_out, "Content-Length", "0");
    ap_table_setn(r->headers_out, "Allow", make_allow(r));
    ap_set_keepalive(r);

    ap_table_do((int (*) (void *, const char *, const char *)) ap_send_header_field,
             (void *) r, r->headers_out, NULL);

    terminate_header(r->connection->client);

    ap_kill_timeout(r);
    ap_bsetopt(r->connection->client, BO_BYTECT, &zero);

    return OK;
}

/*
 * Here we try to be compatible with clients that want multipart/x-byteranges
 * instead of multipart/byteranges (also see above), as per HTTP/1.1. We
 * look for the Request-Range header (e.g. Netscape 2 and 3) as an indication
 * that the browser supports an older protocol. We also check User-Agent
 * for Microsoft Internet Explorer 3, which needs this as well.
 */
static int use_range_x(request_rec *r)
{
    const char *ua;
    return (ap_table_get(r->headers_in, "Request-Range") ||
            ((ua = ap_table_get(r->headers_in, "User-Agent"))
             && strstr(ua, "MSIE 3")));
}

/* This routine is called by ap_table_do and merges all instances of
 * the passed field values into a single array that will be further
 * processed by some later routine.  Originally intended to help split
 * and recombine multiple Vary fields, though it is generic to any field
 * consisting of comma/space-separated tokens.
 */
static int uniq_field_values(void *d, const char *key, const char *val)
{
    array_header *values;
    char *start;
    char *e;
    char **strpp;
    int  i;

    values = (array_header *)d;

    e = ap_pstrdup(values->pool, val);

    do {
        /* Find a non-empty fieldname */

        while (*e == ',' || ap_isspace(*e)) {
            ++e;
        }
        if (*e == '\0') {
            break;
        }
        start = e;
        while (*e != '\0' && *e != ',' && !ap_isspace(*e)) {
            ++e;
        }
        if (*e != '\0') {
            *e++ = '\0';
        }

        /* Now add it to values if it isn't already represented.
         * Could be replaced by a ap_array_strcasecmp() if we had one.
         */
        for (i = 0, strpp = (char **) values->elts; i < values->nelts;
             ++i, ++strpp) {
            if (*strpp && strcasecmp(*strpp, start) == 0) {
                break;
            }
        }
        if (i == values->nelts) {  /* if not found */
           *(char **)ap_push_array(values) = start;
        }
    } while (*e != '\0');

    return 1;
}

/*
 * Since some clients choke violently on multiple Vary fields, or
 * Vary fields with duplicate tokens, combine any multiples and remove
 * any duplicates.
 */
static void fixup_vary(request_rec *r)
{
    array_header *varies;

    varies = ap_make_array(r->pool, 5, sizeof(char *));

    /* Extract all Vary fields from the headers_out, separate each into
     * its comma-separated fieldname values, and then add them to varies
     * if not already present in the array.
     */
    ap_table_do((int (*)(void *, const char *, const char *))uniq_field_values,
		(void *) varies, r->headers_out, "Vary", NULL);

    /* If we found any, replace old Vary fields with unique-ified value */

    if (varies->nelts > 0) {
	ap_table_setn(r->headers_out, "Vary",
		      ap_array_pstrcat(r->pool, varies, ','));
    }
}

API_EXPORT(void) ap_send_http_header(request_rec *r)
{
    int i;
    const off_t zero = 0LL;

    if (r->assbackwards) {
        if (!r->main)
            ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
        r->sent_bodyct = 1;
        return;
    }

    /*
     * Now that we are ready to send a response, we need to combine the two
     * header field tables into a single table.  If we don't do this, our
     * later attempts to set or unset a given fieldname might be bypassed.
     */
    if (!ap_is_empty_table(r->err_headers_out))
        r->headers_out = ap_overlay_tables(r->pool, r->err_headers_out,
                                        r->headers_out);

    /*
     * Remove the 'Vary' header field if the client can't handle it.
     * Since this will have nasty effects on HTTP/1.1 caches, force
     * the response into HTTP/1.0 mode.
     */
    if (ap_table_get(r->subprocess_env, "force-no-vary") != NULL) {
	ap_table_unset(r->headers_out, "Vary");
	r->proto_num = HTTP_VERSION(1,0);
	ap_table_set(r->subprocess_env, "force-response-1.0", "1");
    }
    else {
	fixup_vary(r);
    }

    ap_hard_timeout("send headers", r);

    ap_basic_http_header(r);

    ap_set_keepalive(r);

    if (r->chunked) {
        ap_table_mergen(r->headers_out, "Transfer-Encoding", "chunked");
        ap_table_unset(r->headers_out, "Content-Length");
    }

    if (r->byterange > 1)
        ap_table_setn(r->headers_out, "Content-Type",
                  ap_pstrcat(r->pool, "multipart", use_range_x(r) ? "/x-" : "/",
                          "byteranges; boundary=", r->boundary, NULL));
    else ap_table_setn(r->headers_out, "Content-Type", make_content_type(r, 
	r->content_type));

    if (r->content_encoding)
        ap_table_setn(r->headers_out, "Content-Encoding", r->content_encoding);

    if (r->content_languages && r->content_languages->nelts) {
        for (i = 0; i < r->content_languages->nelts; ++i) {
            ap_table_mergen(r->headers_out, "Content-Language",
                        ((char **) (r->content_languages->elts))[i]);
        }
    }
    else if (r->content_language)
        ap_table_setn(r->headers_out, "Content-Language", r->content_language);

    /*
     * Control cachability for non-cachable responses if not already set by
     * some other part of the server configuration.
     */
    if (r->no_cache && !ap_table_get(r->headers_out, "Expires"))
        ap_table_addn(r->headers_out, "Expires",
                  ap_gm_timestr_822(r->pool, r->request_time));

    /* Send the entire table of header fields, terminated by an empty line. */

    ap_table_do((int (*) (void *, const char *, const char *)) ap_send_header_field,
             (void *) r, r->headers_out, NULL);

    terminate_header(r->connection->client);

    ap_kill_timeout(r);

    ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
    r->sent_bodyct = 1;         /* Whatever follows is real body stuff... */

    /* Set buffer flags for the body */
    if (r->chunked)
        ap_bsetflag(r->connection->client, B_CHUNK, 1);
}

/* finalize_request_protocol is called at completion of sending the
 * response.  It's sole purpose is to send the terminating protocol
 * information for any wrappers around the response message body
 * (i.e., transfer encodings).  It should have been named finalize_response.
 */
API_EXPORT(void) ap_finalize_request_protocol(request_rec *r)
{
    if (r->chunked && !r->connection->aborted) {
        /*
         * Turn off chunked encoding --- we can only do this once.
         */
        r->chunked = 0;
        ap_bsetflag(r->connection->client, B_CHUNK, 0);

        ap_soft_timeout("send ending chunk", r);
        ap_rputs("0" CRLF, r);
        /* If we had footer "headers", we'd send them now */
        ap_rputs(CRLF, r);
        ap_kill_timeout(r);

    }
}

/* Here we deal with getting the request message body from the client.
 * Whether or not the request contains a body is signaled by the presence
 * of a non-zero Content-Length or by a Transfer-Encoding: chunked.
 *
 * Note that this is more complicated than it was in Apache 1.1 and prior
 * versions, because chunked support means that the module does less.
 *
 * The proper procedure is this:
 *
 * 1. Call setup_client_block() near the beginning of the request
 *    handler. This will set up all the necessary properties, and will
 *    return either OK, or an error code. If the latter, the module should
 *    return that error code. The second parameter selects the policy to
 *    apply if the request message indicates a body, and how a chunked
 *    transfer-coding should be interpreted. Choose one of
 *
 *    REQUEST_NO_BODY          Send 413 error if message has any body
 *    REQUEST_CHUNKED_ERROR    Send 411 error if body without Content-Length
 *    REQUEST_CHUNKED_DECHUNK  If chunked, remove the chunks for me.
 *    REQUEST_CHUNKED_PASS     Pass the chunks to me without removal.
 *
 *    In order to use the last two options, the caller MUST provide a buffer
 *    large enough to hold a chunk-size line, including any extensions.
 *
 * 2. When you are ready to read a body (if any), call should_client_block().
 *    This will tell the module whether or not to read input. If it is 0,
 *    the module should assume that there is no message body to read.
 *    This step also sends a 100 Continue response to HTTP/1.1 clients,
 *    so should not be called until the module is *definitely* ready to
 *    read content. (otherwise, the point of the 100 response is defeated).
 *    Never call this function more than once.
 *
 * 3. Finally, call get_client_block in a loop. Pass it a buffer and its size.
 *    It will put data into the buffer (not necessarily a full buffer), and
 *    return the length of the input block. When it is done reading, it will
 *    return 0 if EOF, or -1 if there was an error.
 *    If an error occurs on input, we force an end to keepalive.
 */

API_EXPORT(int) ap_setup_client_block(request_rec *r, int read_policy)
{
    const char *tenc = ap_table_get(r->headers_in, "Transfer-Encoding");
    const char *lenp = ap_table_get(r->headers_in, "Content-Length");
    unsigned long max_body;

    r->read_body = read_policy;
    r->read_chunked = 0;
    r->remaining = 0;

    if (tenc) {
        if (strcasecmp(tenc, "chunked")) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                        "Unknown Transfer-Encoding %s", tenc);
            return HTTP_NOT_IMPLEMENTED;
        }
        if (r->read_body == REQUEST_CHUNKED_ERROR) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                        "chunked Transfer-Encoding forbidden: %s", r->uri);
            return (lenp) ? HTTP_BAD_REQUEST : HTTP_LENGTH_REQUIRED;
        }

        r->read_chunked = 1;
    }
    else if (lenp) {
        const char *pos = lenp;
        int conversion_error = 0;

        while (ap_isspace(*pos))
            ++pos;

        if (*pos == '\0') {
            /* special case test - a C-L field NULL or all blanks is
             * assumed OK and defaults to 0. Otherwise, we do a
             * strict check of the field */
            r->remaining = 0;
        }
        else {
            char *endstr;
            errno = 0;
            r->remaining = ap_strtol(lenp, &endstr, 10);
            if (errno || (endstr && *endstr) || (r->remaining < 0)) {
                conversion_error = 1;
            }
        }

        if (conversion_error) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                        "Invalid Content-Length");
            return HTTP_BAD_REQUEST;
        }
    }

    if ((r->read_body == REQUEST_NO_BODY) &&
        (r->read_chunked || (r->remaining > 0))) {
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                    "%s with body is not allowed for %s", r->method, r->uri);
        return HTTP_REQUEST_ENTITY_TOO_LARGE;
    }

    max_body = ap_get_limit_req_body(r);
    if (max_body && ((unsigned long)r->remaining > max_body)
                 && (r->remaining >= 0)) {
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
          "Request content-length of %s is larger than the configured "
          "limit of %lu", lenp, max_body);
        return HTTP_REQUEST_ENTITY_TOO_LARGE;
    }

    return OK;
}

API_EXPORT(int) ap_should_client_block(request_rec *r)
{
    /* First check if we have already read the request body */

    if (r->read_length || (!r->read_chunked && (r->remaining <= 0)))
        return 0;

    if (r->expecting_100 && r->proto_num >= HTTP_VERSION(1,1)) {
        /* sending 100 Continue interim response */
        ap_rvputs(r, SERVER_PROTOCOL, " ", status_lines[0], CRLF CRLF,
                  NULL);
        ap_rflush(r);
    }

    return 1;
}

/**
 * Parse a chunk extension, detect overflow.
 * There are two error cases:
 *  1) If the conversion would require too many bits, a -1 is returned.
 *  2) If the conversion used the correct number of bits, but an overflow
 *     caused only the sign bit to flip, then that negative number is
 *     returned.
 * In general, any negative number can be considered an overflow error.
 */
API_EXPORT(long) ap_get_chunk_size(char *b)
{
    long chunksize = 0;
    long chunkbits = sizeof(long) * 8;

    /* Skip leading zeros */
    while (*b == '0') {
        ++b;
    }

    while (ap_isxdigit(*b) && (chunkbits > 0)) {
        int xvalue = 0;

        if (*b >= '0' && *b <= '9') {
            xvalue = *b - '0';
        }
        else if (*b >= 'A' && *b <= 'F') {
            xvalue = *b - 'A' + 0xa;
        }
        else if (*b >= 'a' && *b <= 'f') {
            xvalue = *b - 'a' + 0xa;
        }

        chunksize = (chunksize << 4) | xvalue;
        chunkbits -= 4;
        ++b;
    }
    if (ap_isxdigit(*b) && (chunkbits <= 0)) {
        /* overflow */
        return -1;
    }

    return chunksize;
}

/* get_client_block is called in a loop to get the request message body.
 * This is quite simple if the client includes a content-length
 * (the normal case), but gets messy if the body is chunked. Note that
 * r->remaining is used to maintain state across calls and that
 * r->read_length is the total number of bytes given to the caller
 * across all invocations.  It is messy because we have to be careful not
 * to read past the data provided by the client, since these reads block.
 * Returns 0 on End-of-body, -1 on error or premature chunk end.
 *
 * Reading the chunked encoding requires a buffer size large enough to
 * hold a chunk-size line, including any extensions. For now, we'll leave
 * that to the caller, at least until we can come up with a better solution.
 */
API_EXPORT(long) ap_get_client_block(request_rec *r, char *buffer, int bufsiz)
{
    int c;
    long len_read, len_to_read;
    long chunk_start = 0;
    unsigned long max_body;

    if (!r->read_chunked) {     /* Content-length read */
        len_to_read = (r->remaining > bufsiz) ? bufsiz : r->remaining;
        len_read = ap_bread(r->connection->client, buffer, len_to_read);
        if (len_read <= 0) {
            if (len_read < 0)
                r->connection->keepalive = -1;
            return len_read;
        }
        r->read_length += len_read;
        r->remaining -= len_read;
        return len_read;
    }

    /*
     * Handle chunked reading Note: we are careful to shorten the input
     * bufsiz so that there will always be enough space for us to add a CRLF
     * (if necessary).
     */
    if (r->read_body == REQUEST_CHUNKED_PASS)
        bufsiz -= 2;
    if (bufsiz <= 0)
        return -1;              /* Cannot read chunked with a small buffer */

    /* Check to see if we have already read too much request data.
     * For efficiency reasons, we only check this at the top of each
     * caller read pass, since the limit exists just to stop infinite
     * length requests and nobody cares if it goes over by one buffer.
     */
    max_body = ap_get_limit_req_body(r);
    if (max_body && ((unsigned long) r->read_length > max_body)
                 && (r->read_length >= 0)) {
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
            "Chunked request body is larger than the configured limit of %lu",
            max_body);
        r->connection->keepalive = -1;
        return -1;
    }

    if (r->remaining == 0) {    /* Start of new chunk */

        chunk_start = ap_getline(buffer, bufsiz, r->connection->client, 0);
        if ((chunk_start <= 0) || (chunk_start >= (bufsiz - 1))
            || !ap_isxdigit(*buffer)) {
            r->connection->keepalive = -1;
            return -1;
        }

        len_to_read = ap_get_chunk_size(buffer);

        if (len_to_read == 0) { /* Last chunk indicated, get footers */
            if (r->read_body == REQUEST_CHUNKED_DECHUNK) {
                get_mime_headers(r);
                ap_snprintf(buffer, bufsiz, "%ld", r->read_length);
                ap_table_unset(r->headers_in, "Transfer-Encoding");
                ap_table_setn(r->headers_in, "Content-Length",
                    ap_pstrdup(r->pool, buffer));
                return 0;
            }
            r->remaining = -1;  /* Indicate footers in-progress */
        }
        else if (len_to_read < 0) {
            r->connection->keepalive = -1;
            return -1;
        }
        else {
            r->remaining = len_to_read;
        }
        if (r->read_body == REQUEST_CHUNKED_PASS) {
            buffer[chunk_start++] = CR; /* Restore chunk-size line end  */
            buffer[chunk_start++] = LF;
            buffer += chunk_start;      /* and pass line on to caller   */
            bufsiz -= chunk_start;
        }
        else {
            /* REQUEST_CHUNKED_DECHUNK -- do not include the length of the
             * header in the return value
             */
            chunk_start = 0;
        }
    }
                                /* When REQUEST_CHUNKED_PASS, we are */
    if (r->remaining == -1) {   /* reading footers until empty line  */
        len_read = chunk_start;

        while ((bufsiz > 1) && ((len_read =
                  ap_getline(buffer, bufsiz, r->connection->client, 1)) > 0)) {

            if (len_read != (bufsiz - 1)) {
                buffer[len_read++] = CR;        /* Restore footer line end  */
                buffer[len_read++] = LF;
            }
            chunk_start += len_read;
            buffer += len_read;
            bufsiz -= len_read;
        }
        if (len_read < 0) {
            r->connection->keepalive = -1;
            return -1;
        }

        if (len_read == 0) {    /* Indicates an empty line */
            buffer[0] = CR;
            buffer[1] = LF;
            chunk_start += 2;
            r->remaining = -2;
        }
        r->read_length += chunk_start;
        return chunk_start;
    }
                                /* When REQUEST_CHUNKED_PASS, we     */
    if (r->remaining == -2) {   /* finished footers when last called */
        r->remaining = 0;       /* so now we must signal EOF         */
        return 0;
    }

    /* Otherwise, we are in the midst of reading a chunk of data */

    len_to_read = (r->remaining > bufsiz) ? bufsiz : r->remaining;

    len_read = ap_bread(r->connection->client, buffer, len_to_read);
    if (len_read <= 0) {
        r->connection->keepalive = -1;
        return -1;
    }

    r->remaining -= len_read;

    if (r->remaining == 0) {    /* End of chunk, get trailing CRLF */

        if ((c = ap_bgetc(r->connection->client)) == CR) {
            c = ap_bgetc(r->connection->client);
        }

        if (c != LF) {
            r->connection->keepalive = -1;
            return -1;
        }
        if (r->read_body == REQUEST_CHUNKED_PASS) {
            buffer[len_read++] = CR;
            buffer[len_read++] = LF;
        }
    }
    r->read_length += (chunk_start + len_read);

    return (chunk_start + len_read);
}

/* In HTTP/1.1, any method can have a body.  However, most GET handlers
 * wouldn't know what to do with a request body if they received one.
 * This helper routine tests for and reads any message body in the request,
 * simply discarding whatever it receives.  We need to do this because
 * failing to read the request body would cause it to be interpreted
 * as the next request on a persistent connection.
 *
 * Since we return an error status if the request is malformed, this
 * routine should be called at the beginning of a no-body handler, e.g.,
 *
 *    if ((retval = ap_discard_request_body(r)) != OK)
 *        return retval;
 */
API_EXPORT(int) ap_discard_request_body(request_rec *r)
{
    int rv;

    if ((rv = ap_setup_client_block(r, REQUEST_CHUNKED_PASS)))
        return rv;

    /* In order to avoid sending 100 Continue when we already know the
     * final response status, and yet not kill the connection if there is
     * no request body to be read, we need to duplicate the test from
     * ap_should_client_block() here negated rather than call it directly.
     */
    if ((r->read_length == 0) && (r->read_chunked || (r->remaining > 0))) {
        char dumpbuf[HUGE_STRING_LEN];

        if (r->expecting_100) {
            r->connection->keepalive = -1;
            return OK;
        }
        ap_hard_timeout("reading request body", r);
        while ((rv = ap_get_client_block(r, dumpbuf, HUGE_STRING_LEN)) > 0)
            continue;
        ap_kill_timeout(r);

        if (rv < 0)
            return HTTP_BAD_REQUEST;
    }
    return OK;
}

/*
 * Send the body of a response to the client.
 */
API_EXPORT(long) ap_send_fd(FILE *f, request_rec *r)
{
    return ap_send_fd_length(f, r, -1);
}

API_EXPORT(long) ap_send_fd_length(FILE *f, request_rec *r, long length)
{
    char buf[IOBUFSIZE];
    long total_bytes_sent = 0;
    int n, w, o, len;

    if (length == 0)
        return 0;

    ap_soft_timeout("send body", r);

    while (!r->connection->aborted) {
        if ((length > 0) && (total_bytes_sent + IOBUFSIZE) > length)
            len = length - total_bytes_sent;
        else
            len = IOBUFSIZE;

        while ((n = fread(buf, sizeof(char), len, f)) < 1
               && ferror(f) && errno == EINTR && !r->connection->aborted)
            continue;

        if (n < 1) {
            break;
        }
        o = 0;

        while (n && !r->connection->aborted) {
            w = ap_bwrite(r->connection->client, &buf[o], n);
            if (w > 0) {
                ap_reset_timeout(r); /* reset timeout after successful write */
                total_bytes_sent += w;
                n -= w;
                o += w;
            }
            else if (w < 0) {
                if (!r->connection->aborted) {
                    ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                     "client stopped connection before send body completed");
                    ap_bsetflag(r->connection->client, B_EOUT, 1);
                    r->connection->aborted = 1;
                }
                break;
            }
        }
    }

    ap_kill_timeout(r);
    SET_BYTES_SENT(r);
    return total_bytes_sent;
}

/*
 * Send the body of a response to the client.
 */
API_EXPORT(long) ap_send_fb(BUFF *fb, request_rec *r)
{
    return ap_send_fb_length(fb, r, -1);
}

API_EXPORT(long) ap_send_fb_length(BUFF *fb, request_rec *r, long length)
{
    char buf[IOBUFSIZE];
    long total_bytes_sent = 0;
    int n, w, o, len, fd;
    fd_set fds;

    if (length == 0)
        return 0;

    /* Make fb unbuffered and non-blocking */
    ap_bsetflag(fb, B_RD, 0);
    ap_bnonblock(fb, B_RD);
    fd = ap_bfileno(fb, B_RD);
    if (fd >= FD_SETSIZE) {
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
	    "send body: filedescriptor (%u) larger than FD_SETSIZE (%u) "
	    "found, you probably need to rebuild Apache with a "
	    "larger FD_SETSIZE", fd, FD_SETSIZE);
	return 0;
    }

    ap_soft_timeout("send body", r);

    FD_ZERO(&fds);
    while (!r->connection->aborted) {
        if ((length > 0) && (total_bytes_sent + IOBUFSIZE) > length)
            len = length - total_bytes_sent;
        else
            len = IOBUFSIZE;

        do {
            n = ap_bread(fb, buf, len);
            if (n >= 0)
                break;
            if (r->connection->aborted)
                break;
            if (n < 0 && errno != EAGAIN)
                break;

            /* we need to block, so flush the output first */
            if (ap_bflush(r->connection->client) < 0) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                    "client stopped connection before send body completed");
                ap_bsetflag(r->connection->client, B_EOUT, 1);
                r->connection->aborted = 1;
                break;
            }
            FD_SET(fd, &fds);
            /*
             * we don't care what select says, we might as well loop back
             * around and try another read
             */
            ap_select(fd + 1, &fds, NULL, NULL, NULL);
        } while (!r->connection->aborted);

        if (n < 1 || r->connection->aborted) {
            break;
        }
        o = 0;

        while (n && !r->connection->aborted) {
            w = ap_bwrite(r->connection->client, &buf[o], n);
            if (w > 0) {
                ap_reset_timeout(r); /* reset timeout after successful write */
                total_bytes_sent += w;
                n -= w;
                o += w;
            }
            else if (w < 0) {
                if (!r->connection->aborted) {
                    ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                       "client stopped connection before send body completed");
                    ap_bsetflag(r->connection->client, B_EOUT, 1);
                    r->connection->aborted = 1;
                }
                break;
            }
        }
    }

    ap_kill_timeout(r);
    SET_BYTES_SENT(r);
    return total_bytes_sent;
}



/* The code writes MMAP_SEGMENT_SIZE bytes at a time.  This is due to Apache's
 * timeout model, which is a timeout per-write rather than a time for the
 * entire transaction to complete.  Essentially this should be small enough
 * so that in one Timeout period, your slowest clients should be reasonably
 * able to receive this many bytes.
 *
 * To take advantage of zero-copy TCP under Solaris 2.6 this should be a
 * multiple of 16k.  (And you need a SunATM2.0 network card.)
 */
#ifndef MMAP_SEGMENT_SIZE
#define MMAP_SEGMENT_SIZE       32768
#endif

/* send data from an in-memory buffer */
API_EXPORT(off_t) ap_send_mmap(void *mm, request_rec *r, off_t offset,
                             off_t length)
{
    off_t total_bytes_sent = 0;
    off_t n, w;

    if (length == 0)
        return 0;

    ap_soft_timeout("send mmap", r);

    length += offset;
    while (!r->connection->aborted && offset < length) {
        if (length - offset > MMAP_SEGMENT_SIZE) {
            n = MMAP_SEGMENT_SIZE;
        }
        else {
            n = length - offset;
        }

        while (n && !r->connection->aborted) {
            w = ap_bwrite(r->connection->client, (char *) mm + offset, n);
            if (w > 0) {
                ap_reset_timeout(r); /* reset timeout after successful write */
                total_bytes_sent += w;
                n -= w;
                offset += w;
            }
            else if (w < 0) {
                if (!r->connection->aborted) {
                    ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                       "client stopped connection before send mmap completed");
                    ap_bsetflag(r->connection->client, B_EOUT, 1);
                    r->connection->aborted = 1;
                }
                break;
            }
        }
    }

    ap_kill_timeout(r);
    SET_BYTES_SENT(r);
    return total_bytes_sent;
}

API_EXPORT(int) ap_rputc(int c, request_rec *r)
{
    if (r->connection->aborted)
        return EOF;

    if (ap_bputc(c, r->connection->client) < 0) {
        if (!r->connection->aborted) {
            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                "client stopped connection before rputc completed");
            ap_bsetflag(r->connection->client, B_EOUT, 1);
            r->connection->aborted = 1;
        }
        return EOF;
    }
    SET_BYTES_SENT(r);
    return c;
}

API_EXPORT(int) ap_rputs(const char *str, request_rec *r)
{
    int rcode;

    if (r->connection->aborted)
        return EOF;
    
    rcode = ap_bputs(str, r->connection->client);
    if (rcode < 0) {
        if (!r->connection->aborted) {
            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                "client stopped connection before rputs completed");
            ap_bsetflag(r->connection->client, B_EOUT, 1);
            r->connection->aborted = 1;
        }
        return EOF;
    }
    SET_BYTES_SENT(r);
    return rcode;
}

API_EXPORT(int) ap_rwrite(const void *buf, int nbyte, request_rec *r)
{
    int n;

    if (r->connection->aborted)
        return -1;

    n = ap_bwrite(r->connection->client, buf, nbyte);
    if (n < 0) {
        if (!r->connection->aborted) {
            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                "client stopped connection before rwrite completed");
            ap_bsetflag(r->connection->client, B_EOUT, 1);
            r->connection->aborted = 1;
        }
        return -1;
    }
    SET_BYTES_SENT(r);
    return n;
}

API_EXPORT(int) ap_vrprintf(request_rec *r, const char *fmt, va_list ap)
{
    int n;

    if (r->connection->aborted)
        return -1;

    n = ap_vbprintf(r->connection->client, fmt, ap);

    if (n < 0) {
        if (!r->connection->aborted) {
            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                "client stopped connection before vrprintf completed");
            ap_bsetflag(r->connection->client, B_EOUT, 1);
            r->connection->aborted = 1;
        }
        return -1;
    }
    SET_BYTES_SENT(r);
    return n;
}

API_EXPORT_NONSTD(int) ap_rprintf(request_rec *r, const char *fmt,...)
{
    va_list vlist;
    int n;

    if (r->connection->aborted)
        return -1;

    va_start(vlist, fmt);
    n = ap_vbprintf(r->connection->client, fmt, vlist);
    va_end(vlist);

    if (n < 0) {
        if (!r->connection->aborted) {
            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                "client stopped connection before rprintf completed");
            ap_bsetflag(r->connection->client, B_EOUT, 1);
            r->connection->aborted = 1;
        }
        return -1;
    }
    SET_BYTES_SENT(r);
    return n;
}

API_EXPORT_NONSTD(int) ap_rvputs(request_rec *r,...)
{
    va_list args;
    int i, j, k;
    const char *x;
    BUFF *fb = r->connection->client;

    if (r->connection->aborted)
        return EOF;

    va_start(args, r);
    for (k = 0;;) {
        x = va_arg(args, const char *);
        if (x == NULL)
            break;
        j = strlen(x);
        i = ap_bwrite(fb, x, j);
        if (i != j) {
            va_end(args);
            if (!r->connection->aborted) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                    "client stopped connection before rvputs completed");
                ap_bsetflag(r->connection->client, B_EOUT, 1);
                r->connection->aborted = 1;
            }
            return EOF;
        }
        k += i;
    }
    va_end(args);

    SET_BYTES_SENT(r);
    return k;
}

API_EXPORT(int) ap_rflush(request_rec *r)
{
    if (ap_bflush(r->connection->client) < 0) {
        if (!r->connection->aborted) {
            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                "client stopped connection before rflush completed");
            ap_bsetflag(r->connection->client, B_EOUT, 1);
            r->connection->aborted = 1;
        }
        return EOF;
    }
    return 0;
}

/* We should have named this send_canned_response, since it is used for any
 * response that can be generated by the server from the request record.
 * This includes all 204 (no content), 3xx (redirect), 4xx (client error),
 * and 5xx (server error) messages that have not been redirected to another
 * handler via the ErrorDocument feature.
 */
API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
{
    int status = r->status;
    int idx = ap_index_of_response(status);
    char *custom_response;
    const char *location = ap_table_get(r->headers_out, "Location");

    /*
     * It's possible that the Location field might be in r->err_headers_out
     * instead of r->headers_out; use the latter if possible, else the
     * former.
     */
    if (location == NULL) {
	location = ap_table_get(r->err_headers_out, "Location");
    }
    /* We need to special-case the handling of 204 and 304 responses,
     * since they have specific HTTP requirements and do not include a
     * message body.  Note that being assbackwards here is not an option.
     */
    if (status == HTTP_NOT_MODIFIED) {
        if (!ap_is_empty_table(r->err_headers_out))
            r->headers_out = ap_overlay_tables(r->pool, r->err_headers_out,
                                               r->headers_out);
        ap_hard_timeout("send 304", r);

        ap_basic_http_header(r);
        ap_set_keepalive(r);

        ap_table_do((int (*)(void *, const char *, const char *)) ap_send_header_field,
                    (void *) r, r->headers_out,
                    "Connection",
                    "Keep-Alive",
                    "ETag",
                    "Content-Location",
                    "Expires",
                    "Cache-Control",
                    "Vary",
                    "Warning",
                    "WWW-Authenticate",
                    "Proxy-Authenticate",
                    NULL);

        terminate_header(r->connection->client);

        ap_kill_timeout(r);
        return;
    }

    if (status == HTTP_NO_CONTENT) {
        ap_send_http_header(r);
        ap_finalize_request_protocol(r);
        return;
    }

    if (!r->assbackwards) {
        table *tmp = r->headers_out;

        /* For all HTTP/1.x responses for which we generate the message,
         * we need to avoid inheriting the "normal status" header fields
         * that may have been set by the request handler before the
         * error or redirect, except for Location on external redirects.
         */
        r->headers_out = r->err_headers_out;
        r->err_headers_out = tmp;
        ap_clear_table(r->err_headers_out);

        if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {
            if ((location != NULL) && *location) {
	        ap_table_setn(r->headers_out, "Location", location);
            }
            else {
                location = "";   /* avoids coredump when printing, below */
            }
        }

        r->content_language = NULL;
        r->content_languages = NULL;
        r->content_encoding = NULL;
        r->clength = 0;
        if (ap_table_get(r->subprocess_env,
                         "suppress-error-charset") != NULL) {
            r->content_type = "text/html";
        }
        else {
            r->content_type = "text/html; charset=iso-8859-1";
        }

        if ((status == METHOD_NOT_ALLOWED) || (status == NOT_IMPLEMENTED))
            ap_table_setn(r->headers_out, "Allow", make_allow(r));

        ap_send_http_header(r);

        if (r->header_only) {
            ap_finalize_request_protocol(r);
            ap_rflush(r);
            return;
        }
    }

    ap_hard_timeout("send error body", r);

    if ((custom_response = ap_response_code_string(r, idx))) {
        /*
         * We have a custom response output. This should only be
         * a text-string to write back. But if the ErrorDocument
         * was a local redirect and the requested resource failed
         * for any reason, the custom_response will still hold the
         * redirect URL. We don't really want to output this URL
         * as a text message, so first check the custom response
         * string to ensure that it is a text-string (using the
         * same test used in ap_die(), i.e. does it start with a ").
         * If it doesn't, we've got a recursive error, so find
         * the original error and output that as well.
         */
        if (custom_response[0] == '\"') {
            ap_rputs(custom_response + 1, r);
            ap_kill_timeout(r);
            ap_finalize_request_protocol(r);
            ap_rflush(r);
            return;
        }
        /*
         * Redirect failed, so get back the original error
         */
        while (r->prev && (r->prev->status != HTTP_OK))
            r = r->prev;
    }
    {
        const char *title = status_lines[idx];
        const char *h1;
        const char *error_notes;

        /* Accept a status_line set by a module, but only if it begins
         * with the 3 digit status code
         */
        if (r->status_line != NULL
            && strlen(r->status_line) > 4       /* long enough */
            && ap_isdigit(r->status_line[0])
            && ap_isdigit(r->status_line[1])
            && ap_isdigit(r->status_line[2])
            && ap_isspace(r->status_line[3])
            && ap_isalnum(r->status_line[4])) {
            title = r->status_line;
        }

        /* folks decided they didn't want the error code in the H1 text */
        h1 = &title[4];

        ap_rvputs(r,
                  DOCTYPE_HTML_2_0
                  "<HTML><HEAD>\n<TITLE>", title,
                  "</TITLE>\n</HEAD><BODY>\n<H1>", h1, "</H1>\n",
                  NULL);

	switch (status) {
	case HTTP_MOVED_PERMANENTLY:
	case HTTP_MOVED_TEMPORARILY:
	case HTTP_TEMPORARY_REDIRECT:
	    ap_rvputs(r, "The document has moved <A HREF=\"",
		      ap_escape_html(r->pool, location), "\">here</A>.<P>\n",
		      NULL);
	    break;
	case HTTP_SEE_OTHER:
	    ap_rvputs(r, "The answer to your request is located <A HREF=\"",
		      ap_escape_html(r->pool, location), "\">here</A>.<P>\n",
		      NULL);
	    break;
	case HTTP_USE_PROXY:
	    ap_rvputs(r, "This resource is only accessible "
		      "through the proxy\n",
		      ap_escape_html(r->pool, location),
		      "<BR>\nYou will need to ",
		      "configure your client to use that proxy.<P>\n", NULL);
	    break;
	case HTTP_PROXY_AUTHENTICATION_REQUIRED:
	case AUTH_REQUIRED:
	    ap_rputs("This server could not verify that you\n"
	             "are authorized to access the document\n"
	             "requested.  Either you supplied the wrong\n"
	             "credentials (e.g., bad password), or your\n"
	             "browser doesn't understand how to supply\n"
	             "the credentials required.<P>\n", r);
	    break;
	case BAD_REQUEST:
	    ap_rputs("Your browser sent a request that "
	             "this server could not understand.<P>\n", r);
	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
		ap_rvputs(r, error_notes, "<P>\n", NULL);
	    }
	    break;
	case HTTP_FORBIDDEN:
	    ap_rvputs(r, "You don't have permission to access ",
		      ap_escape_html(r->pool, r->uri),
		      "\non this server.<P>\n", NULL);
	    break;
	case NOT_FOUND:
	    ap_rvputs(r, "The requested URL ",
		      ap_escape_html(r->pool, r->uri),
		      " was not found on this server.<P>\n", NULL);
	    break;
	case METHOD_NOT_ALLOWED:
	    ap_rvputs(r, "The requested method ", r->method,
		      " is not allowed "
		      "for the URL ", ap_escape_html(r->pool, r->uri),
		      ".<P>\n", NULL);
	    break;
	case NOT_ACCEPTABLE:
	    ap_rvputs(r,
		      "An appropriate representation of the "
		      "requested resource ",
		      ap_escape_html(r->pool, r->uri),
		      " could not be found on this server.<P>\n", NULL);
	    /* fall through */
	case MULTIPLE_CHOICES:
	    {
		const char *list;
		if ((list = ap_table_get(r->notes, "variant-list")))
		    ap_rputs(list, r);
	    }
	    break;
	case LENGTH_REQUIRED:
	    ap_rvputs(r, "A request of the requested method ", r->method,
		      " requires a valid Content-length.<P>\n", NULL);
	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
		ap_rvputs(r, error_notes, "<P>\n", NULL);
	    }
	    break;
	case PRECONDITION_FAILED:
	    ap_rvputs(r, "The precondition on the request for the URL ",
		      ap_escape_html(r->pool, r->uri),
		      " evaluated to false.<P>\n", NULL);
	    break;
	case HTTP_NOT_IMPLEMENTED:
	    ap_rvputs(r, ap_escape_html(r->pool, r->method), " to ",
		      ap_escape_html(r->pool, r->uri),
		      " not supported.<P>\n", NULL);
	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
		ap_rvputs(r, error_notes, "<P>\n", NULL);
	    }
	    break;
	case BAD_GATEWAY:
	    ap_rputs("The proxy server received an invalid" CRLF
	             "response from an upstream server.<P>" CRLF, r);
	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
		ap_rvputs(r, error_notes, "<P>\n", NULL);
	    }
	    break;
	case VARIANT_ALSO_VARIES:
	    ap_rvputs(r, "A variant for the requested resource\n<PRE>\n",
		      ap_escape_html(r->pool, r->uri),
		      "\n</PRE>\nis itself a negotiable resource. "
		      "This indicates a configuration error.<P>\n", NULL);
	    break;
	case HTTP_REQUEST_TIME_OUT:
	    ap_rputs("Server timeout waiting for the HTTP request from the client.\n", r);
	    break;
	case HTTP_GONE:
	    ap_rvputs(r, "The requested resource<BR>",
		      ap_escape_html(r->pool, r->uri),
		      "<BR>\nis no longer available on this server ",
		      "and there is no forwarding address.\n",
		      "Please remove all references to this resource.\n",
		      NULL);
	    break;
	case HTTP_REQUEST_ENTITY_TOO_LARGE:
	    ap_rvputs(r, "The requested resource<BR>",
		      ap_escape_html(r->pool, r->uri), "<BR>\n",
		      "does not allow request data with ", r->method,
		      " requests, or the amount of data provided in\n",
		      "the request exceeds the capacity limit.\n", NULL);
	    break;
	case HTTP_REQUEST_URI_TOO_LARGE:
	    ap_rputs("The requested URL's length exceeds the capacity\n"
	             "limit for this server.<P>\n", r);
	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
		ap_rvputs(r, error_notes, "<P>\n", NULL);
	    }
	    break;
	case HTTP_UNSUPPORTED_MEDIA_TYPE:
	    ap_rputs("The supplied request data is not in a format\n"
	             "acceptable for processing by this resource.\n", r);
	    break;
	case HTTP_RANGE_NOT_SATISFIABLE:
	    ap_rputs("None of the range-specifier values in the Range\n"
	             "request-header field overlap the current extent\n"
	             "of the selected resource.\n", r);
	    break;
	case HTTP_EXPECTATION_FAILED:
	    ap_rvputs(r, "The expectation given in the Expect request-header"
	              "\nfield could not be met by this server.<P>\n"
	              "The client sent<PRE>\n    Expect: ",
	              ap_escape_html(r->pool, ap_table_get(r->headers_in,
		      "Expect")), "\n</PRE>\n"
	              "but we only allow the 100-continue expectation.\n",
	              NULL);
	    break;
	case HTTP_UNPROCESSABLE_ENTITY:
	    ap_rputs("The server understands the media type of the\n"
	             "request entity, but was unable to process the\n"
	             "contained instructions.\n", r);
	    break;
	case HTTP_LOCKED:
	    ap_rputs("The requested resource is currently locked.\n"
	             "The lock must be released or proper identification\n"
	             "given before the method can be applied.\n", r);
	    break;
	case HTTP_FAILED_DEPENDENCY:
	    ap_rputs("The method could not be performed on the resource\n"
	             "because the requested action depended on another\n"
	             "action and that other action failed.\n", r);
	    break;
	case HTTP_INSUFFICIENT_STORAGE:
	    ap_rputs("The method could not be performed on the resource\n"
	             "because the server is unable to store the\n"
	             "representation needed to successfully complete the\n"
	             "request.  There is insufficient free space left in\n"
	             "your storage allocation.\n", r);
	    break;
	case HTTP_SERVICE_UNAVAILABLE:
	    ap_rputs("The server is temporarily unable to service your\n"
	             "request due to maintenance downtime or capacity\n"
	             "problems. Please try again later.\n", r);
	    break;
	case HTTP_GATEWAY_TIME_OUT:
	    ap_rputs("The proxy server did not receive a timely response\n"
	             "from the upstream server.\n", r);
	    break;
	case HTTP_NOT_EXTENDED:
	    ap_rputs("A mandatory extension policy in the request is not\n"
	             "accepted by the server for this resource.\n", r);
	    break;
	default:            /* HTTP_INTERNAL_SERVER_ERROR */
	    /*
	     * This comparison to expose error-notes could be modified to
	     * use a configuration directive and export based on that 
	     * directive.  For now "*" is used to designate an error-notes
	     * that is totally safe for any user to see (ie lacks paths,
	     * database passwords, etc.)
	     */
	    if (((error_notes = ap_table_get(r->notes, "error-notes")) != NULL)
		&& (h1 = ap_table_get(r->notes, "verbose-error-to")) != NULL
		&& (strcmp(h1, "*") == 0)) {
	        ap_rvputs(r, error_notes, "<P>\n", NULL);
	    }
	    else {
	        ap_rvputs(r, "The server encountered an internal error or\n"
	             "misconfiguration and was unable to complete\n"
	             "your request.<P>\n"
	             "Please contact the server administrator,\n ",
	             ap_escape_html(r->pool, r->server->server_admin),
	             " and inform them of the time the error occurred,\n"
	             "and anything you might have done that may have\n"
	             "caused the error.<P>\n"
		     "More information about this error may be available\n"
		     "in the server error log.<P>\n", NULL);
	    }
	 /*
	  * It would be nice to give the user the information they need to
	  * fix the problem directly since many users don't have access to
	  * the error_log (think University sites) even though they can easily
	  * get this error by misconfiguring an htaccess file.  However, the
	  * error notes tend to include the real file pathname in this case,
	  * which some people consider to be a breach of privacy.  Until we
	  * can figure out a way to remove the pathname, leave this commented.
	  *
	  * if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
	  *     ap_rvputs(r, error_notes, "<P>\n", NULL);
	  * }
	  */
	    break;
	}

        if (recursive_error) {
            ap_rvputs(r, "<P>Additionally, a ",
                      status_lines[ap_index_of_response(recursive_error)],
                      "\nerror was encountered while trying to use an "
                      "ErrorDocument to handle the request.\n", NULL);
        }
        ap_rputs(ap_psignature("<HR>\n", r), r);
        ap_rputs("</BODY></HTML>\n", r);
    }
    ap_kill_timeout(r);
    ap_finalize_request_protocol(r);
    ap_rflush(r);
}

/*
 * The shared hash context, copies of which are used by all children for
 * etag generation.  ap_init_etag() must be called once before all the
 * children are created.  We use a secret hash initialization value
 * so that people can't brute-force inode numbers.
 */
static AP_SHA1_CTX baseCtx;

int ap_create_etag_state(pool *pconf)
{
    u_int32_t rnd;
    unsigned int u;
    int fd;
    char* filename;

    filename = ap_server_root_relative(pconf, "logs/etag-state");
    ap_server_strip_chroot(filename, 0);

    if ((fd = open(filename, O_CREAT|O_WRONLY|O_TRUNC|O_NOFOLLOW, 0640)) ==
      -1) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
          "could not create %s", filename);
        exit(-1);
    }

    if (fchown(fd, -1, ap_group_id) == -1) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
          "could not chown %s", filename);
        exit(-1);
    }

    /* generate random bytes and write them */
    for (u = 0; u < 4; u++) {
        rnd = arc4random();
        if (write(fd, &rnd, sizeof(rnd)) == -1) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
              "could not write to %s", filename);
            exit(-1);
        }
    }

    close (fd);
    return (0);
}

int ap_read_etag_state(pool *pconf)
{
    struct stat st;
    u_int32_t rnd;
    unsigned int u;
    int fd;
    char* filename;

    ap_SHA1Init(&baseCtx);

    filename = ap_server_root_relative(pconf, "logs/etag-state");
    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, NULL,
      "Initializing etag from %s", filename);

    ap_server_strip_chroot(filename, 0);

    if ((fd = open(filename, O_RDONLY|O_NOFOLLOW, 0640)) == -1)
	return (-1);

    fchmod(fd, S_IRUSR|S_IWUSR|S_IRGRP);
    fchown(fd, -1, ap_group_id);

    if (fstat(fd, &st) == -1) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
          "could not fstat %s", filename);
        exit(-1);
    }

    if (st.st_size != sizeof(rnd)*4) {
	return (-1);
    }

    /* read 4 random 32-bit uints from file and update the hash context */
    for (u = 0; u < 4; u++) {
        if (read(fd, &rnd, sizeof(rnd)) != sizeof(rnd))
            return (-1);

        ap_SHA1Update_binary(&baseCtx, (const unsigned char *)&rnd,
          sizeof(rnd));
    }

    if (close(fd) == -1) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
          "could not properly close %s", filename);
        exit(-1);
    }
    return (0);
}

API_EXPORT(void) ap_init_etag(pool *pconf)
{
    if (ap_read_etag_state(pconf) == -1) {
        ap_create_etag_state(pconf);
        if (ap_read_etag_state(pconf) == -1) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
              "could not initialize etag state");
            exit(-1);
        }
    }			
}

API_EXPORT(char *) ap_make_etag(request_rec *r, int force_weak)
{
    AP_SHA1_CTX hashCtx;
    core_dir_config *cfg;
    etag_components_t etag_bits;
    int weak;
    unsigned char md[SHA_DIGESTSIZE];
    unsigned int i;
    
    memcpy(&hashCtx, &baseCtx, sizeof(hashCtx));
    
    cfg = (core_dir_config *)ap_get_module_config(r->per_dir_config,
      &core_module);
    etag_bits = (cfg->etag_bits & (~ cfg->etag_remove)) | cfg->etag_add;
    if (etag_bits == ETAG_UNSET)
        etag_bits = ETAG_BACKWARD;
    
    weak = ((r->request_time - r->mtime <= 1) || force_weak);
    
    if (r->finfo.st_mode != 0) {
        if (etag_bits & ETAG_NONE) {
            ap_table_setn(r->notes, "no-etag", "omit");
            return "";
        }
        if (etag_bits & ETAG_INODE) {
            ap_SHA1Update_binary(&hashCtx,
              (const unsigned char *)&r->finfo.st_dev,
              sizeof(r->finfo.st_dev));
            ap_SHA1Update_binary(&hashCtx,
              (const unsigned char *)&r->finfo.st_ino,
              sizeof(r->finfo.st_ino));
        }
        if (etag_bits & ETAG_SIZE)
            ap_SHA1Update_binary(&hashCtx,
              (const unsigned char *)&r->finfo.st_size,
              sizeof(r->finfo.st_size));
        if (etag_bits & ETAG_MTIME)
            ap_SHA1Update_binary(&hashCtx,
              (const unsigned char *)&r->mtime,
              sizeof(r->mtime));
    }
    else {
        weak = 1;
        ap_SHA1Update_binary(&hashCtx, (const unsigned char *)&r->mtime,
          sizeof(r->mtime));
    }
    ap_SHA1Final(md, &hashCtx);
    return ap_psprintf(r->pool, "%s\""
      "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
        "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
        "\"", weak ? "W/" : "",
      md[0], md[1], md[2], md[3], md[4], md[5], md[6], md[7],
      md[8], md[9], md[10], md[11], md[12], md[13], md[14], md[15],
      md[16], md[17], md[18], md[19]);
}
@


1.39
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.38 2013/08/08 03:16:13 guenther Exp $ */
@


1.38
log
@Prep for big ino_t: cast to unsigned long long and format with %ll or %q

httpd correction and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.37 2010/02/25 07:49:53 pyr Exp $ */
d1352 2
a1353 2
           ap_psprintf(r->pool, "%s%lu",
                       ap_auth_nonce(r), r->request_time));
d1358 2
a1359 2
           ap_psprintf(r->pool, "Digest realm=\"%s\", nonce=\"%s%lu\"",
               ap_auth_name(r), nonce_prefix, r->request_time));
@


1.37
log
@fix some fallout from the >2G commit. namely allow for all byte counters to
report the correct size when it exceeds a long's capacity.

From Dan Harnett <daniel @@ harnett . name>
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.36 2010/02/23 08:15:27 pyr Exp $ */
d684 2
a685 2
            *ent = ap_psprintf(r->pool, "%lx",
                               (unsigned long) r->finfo.st_ino);
@


1.36
log
@Fix byte range parsing, broken in last revision of http_protocol.c,
unfortunately this backs out the use of strtonum and goes back to strtoll
will need more love in a future diff.

This fix from Dan Harnett <daniel @@ harnett . name>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.35 2009/06/02 23:36:40 pyr Exp $ */
d1585 1
a1585 1
    long int bs;
d1648 1
a1648 1
    const long int zero = 0L;
d1768 1
a1768 1
    const long int zero = 0L;
@


1.35
log
@Fix the way apache reports Content-Length by promoting the clength field
of request_rec from long to off_t, which makes it 64bit on i386.
This allows files bigger than 2gig to be correctly served on arches
where long is only 32bits.

Warning: this introduces an ABI break, and hence some third party
apache modules will need to be rebuilt to correctly link to this new
apache.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.34 2008/05/23 08:41:48 mbalmer Exp $ */
d159 3
a161 5
    if (ap_isdigit(*r->range)) {
        *start = strtonum(r->range, QUAD_MIN, QUAD_MAX, &estr);
        if (estr)
            return BYTERANGE_BADSYNTAX;
    } else
d174 3
a176 5
    if (ap_isdigit(*r->range)) {
        *end = strtonum(r->range, QUAD_MIN, QUAD_MAX, &estr);
        if (estr)
            return BYTERANGE_BADSYNTAX;
    } else
d2429 2
a2430 2
API_EXPORT(size_t) ap_send_mmap(void *mm, request_rec *r, size_t offset,
                             size_t length)
d2432 2
a2433 2
    size_t total_bytes_sent = 0;
    int n, w;
@


1.34
log
@de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.33 2008/05/15 06:05:43 mbalmer Exp $ */
d142 1
a142 1
    parse_byterange(request_rec *r, long *start, long *end)
d144 1
d159 6
a164 4
    if (ap_isdigit(*r->range))
	*start = ap_strtol(r->range, (char **)&r->range, 10);
    else
	*start = -1;
d176 6
a181 4
    if (ap_isdigit(*r->range))
	*end = ap_strtol(r->range, (char **)&r->range, 10);
    else
	*end = -1;
d227 1
a227 1
static int byterange_boundary(request_rec *r, long start, long end, int output)
d241 1
a241 1
	ap_snprintf(ts, sizeof(ts), "%ld-%ld/%ld", start, end, r->clength);
d259 1
a259 1
    long length, start, end, one_start = 0, one_end = 0;
d356 1
a356 1
		ap_psprintf(r->pool, "bytes */%ld", r->clength));
d368 1
a368 1
	    ap_psprintf(r->pool, "bytes %ld-%ld/%ld",
d371 1
a371 1
	    ap_psprintf(r->pool, "%ld", one_end - one_start + 1));
d382 1
a382 1
	    ap_psprintf(r->pool, "%ld", length));
d390 1
a390 1
API_EXPORT(int) ap_each_byterange(request_rec *r, long *offset, long *length)
d392 1
a392 1
    long start, end;
d408 1
a408 1
API_EXPORT(int) ap_set_content_length(request_rec *r, long clength)
d411 1
a411 1
    ap_table_setn(r->headers_out, "Content-Length", ap_psprintf(r->pool, "%ld", clength));
@


1.33
log
@Add OpenBSD markers.

no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.32 2008/01/24 11:56:29 krw Exp $ */
d2271 1
a2271 1
    register int n, w, o, len;
d2330 1
a2330 1
    register int n, w, o, len, fd;
@


1.32
log
@"read(..., ..., sizeof Y) < sizeof Y" is a dangerous idiom because it
does an unsigned comparison and read() can return -1. Use '!=' instead
of '<' since read() can't return more than 'sizeof Y'. Not perfect
(that would require a separate test for -1) but a very common usage.

ok henning@@
@
text
@d1 2
a2 1
/*	$OpenBSD: http_protocol.c,v 1.31 2006/09/26 03:26:36 djm Exp $ */
@


1.31
log
@escape error response to unsupported Expect: header, fixes
CVE-2006-3918; ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.30 2006/02/11 19:15:57 otto Exp $ */
d3099 1
a3099 1
        if (read(fd, &rnd, sizeof(rnd)) < sizeof(rnd))
@


1.30
log
@Fix a few "discards qualifier" warnings. From A. Farber in PR 5114.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.29 2005/11/11 15:09:54 cloder Exp $ */
d2925 2
a2926 1
	              ap_table_get(r->headers_in, "Expect"), "\n</PRE>\n"
@


1.30.4.1
log
@MFC:
Fix by djm@@

escape error response to unsupported Expect: header, fixes
CVE-2006-3918
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.30 2006/02/11 19:15:57 otto Exp $ */
d2925 1
a2925 2
	              ap_escape_html(r->pool, ap_table_get(r->headers_in,
		      "Expect")), "\n</PRE>\n"
@


1.30.2.1
log
@MFC:
Fix by djm@@

escape error response to unsupported Expect: header, fixes
CVE-2006-3918
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.30 2006/02/11 19:15:57 otto Exp $ */
d2925 1
a2925 2
	              ap_escape_html(r->pool, ap_table_get(r->headers_in,
		      "Expect")), "\n</PRE>\n"
@


1.29
log
@Disable the TRACE method completely.  It is a security risk and is not
that useful for debugging.
OK henning, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.28 2005/02/09 12:13:09 henning Exp $ */
d3032 1
a3032 1
    const char* filename;
d3070 1
a3070 1
    const char* filename;
@


1.28
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.27 2004/12/02 19:42:47 henning Exp $ */
a825 4
           break;
        case 'T':
           if (strcmp(method, "TRACE") == 0)
               return M_TRACE;
@


1.28.4.1
log
@MFC:
Fix by djm@@

escape error response to unsupported Expect: header, fixes
CVE-2006-3918
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.28 2005/02/09 12:13:09 henning Exp $ */
d2929 1
a2929 2
	              ap_escape_html(r->pool, ap_table_get(r->headers_in,
		      "Expect")), "\n</PRE>\n"
@


1.27
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.26 2004/06/07 04:24:00 brad Exp $ */
a982 1
#ifdef SIGUSR1
a983 1
#endif
a1153 1
#ifdef EAPI
a1154 1
#endif /* EAPI */
a1307 1
#ifdef EAPI
a1308 1
#endif /* EAPI */
a2340 1
#ifndef TPF_NO_NONSOCKET_SELECT
a2341 1
#endif
a2342 1
#ifdef CHECK_FD_SETSIZE
a2349 1
#endif
a2354 9
#ifdef NDELAY_PIPE_RETURNS_ZERO
	/* Contributed by dwd@@bell-labs.com for UTS 2.1.2, where the fcntl */
	/*   O_NDELAY flag causes read to return 0 when there's nothing */
	/*   available when reading from a pipe.  That makes it tricky */
	/*   to detect end-of-file :-(.  This stupid bug is even documented */
	/*   in the read(2) man page where it says that everything but */
	/*   pipes return -1 and EAGAIN.  That makes it a feature, right? */
	int afterselect = 0;
#endif
a2361 4
#ifdef NDELAY_PIPE_RETURNS_ZERO
	    if ((n > 0) || (n == 0 && afterselect))
		break;
#else
a2363 1
#endif
a2381 5
#ifdef TPF_HAVE_NONSOCKET_SELECT
            tv.tv_sec =  1;
            tv.tv_usec = 0;
            ap_select(fd + 1, &fds, NULL, NULL, &tv);
#else
a2382 4
#endif  
#ifdef NDELAY_PIPE_RETURNS_ZERO
	    afterselect = 1;
#endif
@


1.26
log
@mod_digest for Apache does not properly verify the nonce of a client response
by using a AuthNonce secret.

CAN-2003-0987

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.25 2004/01/15 12:17:18 otto Exp $ */
a87 27
#ifdef CHARSET_EBCDIC
/* Save & Restore the current conversion settings
 * "input"  means: ASCII -> EBCDIC (when reading MIME Headers and PUT/POST data)
 * "output" means: EBCDIC -> ASCII (when sending MIME Headers and Chunks)
 */

#define PUSH_EBCDIC_INPUTCONVERSION_STATE(_buff, _onoff) \
        int _convert_in = ap_bgetflag(_buff, B_ASCII2EBCDIC); \
        ap_bsetflag(_buff, B_ASCII2EBCDIC, _onoff);

#define POP_EBCDIC_INPUTCONVERSION_STATE(_buff) \
        ap_bsetflag(_buff, B_ASCII2EBCDIC, _convert_in);

#define PUSH_EBCDIC_INPUTCONVERSION_STATE_r(_req, _onoff) \
        ap_bsetflag(_req->connection->client, B_ASCII2EBCDIC, _onoff);

#define POP_EBCDIC_INPUTCONVERSION_STATE_r(_req) \
        ap_bsetflag(_req->connection->client, B_ASCII2EBCDIC, _req->ebcdic.conv_in);

#define PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(_req, _onoff) \
        ap_bsetflag(_req->connection->client, B_EBCDIC2ASCII, _onoff);

#define POP_EBCDIC_OUTPUTCONVERSION_STATE_r(_req) \
        ap_bsetflag(_req->connection->client, B_EBCDIC2ASCII, _req->ebcdic.conv_out);

#endif /*CHARSET_EBCDIC*/

a224 8
#ifdef CHARSET_EBCDIC
    /* determine current setting of conversion flag,
     * set to ON (protocol strings MUST be converted)
     * and reset to original setting before returning
     */
    PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(r, 1);
#endif /*CHARSET_EBCDIC*/

a244 4
#ifdef CHARSET_EBCDIC
    POP_EBCDIC_OUTPUTCONVERSION_STATE_r(r);
#endif /*CHARSET_EBCDIC*/

a860 11
#ifdef CHARSET_EBCDIC
    /* When ap_getline() is called, the HTTP protocol is in a state
     * where we MUST be reading "plain text" protocol stuff,
     * (Request line, MIME headers, Chunk sizes) regardless of
     * the MIME type and conversion setting of the document itself.
     * Save the current setting of the ASCII-EBCDIC conversion flag
     * for uploads, then temporarily set it to ON
     * (and restore it before returning).
     */
    PUSH_EBCDIC_INPUTCONVERSION_STATE(in, 1);
#endif /*CHARSET_EBCDIC*/
a904 5
#ifdef CHARSET_EBCDIC
    /* restore ASCII->EBCDIC conversion state */
    POP_EBCDIC_INPUTCONVERSION_STATE(in);
#endif /*CHARSET_EBCDIC*/

a937 12
#if defined(OS2) || defined(WIN32)
	/* Handle path translations for OS/2 and plug security hole.
	 * This will prevent "http://www.wherever.com/..\..\/" from
	 * returning a directory for the root drive.
	 */
	{
	    char *x;

	    for (x = r->uri; (x = strchr(x, '\\')) != NULL; )
		*x = '/';
	}
#endif  /* OS2 || WIN32 */
a1159 5
#ifdef CHARSET_EBCDIC
    ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, r->ebcdic.conv_in  = 1);
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
#endif

a1399 3
    /* No CHARSET_EBCDIC Issue here because the line has already
     * been converted to native text.
     */
a1421 7
#ifdef UTS21
/* The second const triggers an assembler bug on UTS 2.1.
 * Another workaround is to move some code out of this file into another,
 *   but this is easier.  Dave Dykstra, 3/31/99 
 */
static const char * status_lines[RESPONSE_CODES] =
#else
a1422 1
#endif
a1550 4
#ifdef CHARSET_EBCDIC
    PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(r, 1);
#endif /*CHARSET_EBCDIC*/

a1571 3
#ifdef CHARSET_EBCDIC
    POP_EBCDIC_OUTPUTCONVERSION_STATE_r(r);
#endif /*CHARSET_EBCDIC*/
a1640 4
#ifdef CHARSET_EBCDIC
    /* Server-generated response, converted */
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
#endif
a1777 5
#ifdef CHARSET_EBCDIC
    /* Use previously determined conversion (output): */
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, ap_checkconv(r));
#endif /*CHARSET_EBCDIC*/

a1811 4
#ifdef CHARSET_EBCDIC
    PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(r, 1);
#endif /*CHARSET_EBCDIC*/

a1860 3
#ifdef CHARSET_EBCDIC
    POP_EBCDIC_OUTPUTCONVERSION_STATE_r(r);
#endif /*CHARSET_EBCDIC*/
a1870 3
#ifdef CHARSET_EBCDIC
        PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(r, 1);
#endif
a1882 3
#ifdef CHARSET_EBCDIC
        POP_EBCDIC_OUTPUTCONVERSION_STATE_r(r);
#endif /*CHARSET_EBCDIC*/
a1993 10
#ifdef CHARSET_EBCDIC
    {
        /* Determine the EBCDIC conversion for the uploaded content
         * by looking at the Content-Type MIME header. 
         * If no Content-Type header is found, text conversion is assumed.
         */
        ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, ap_checkconv_in(r));
    }
#endif

a2205 4
#ifdef CHARSET_EBCDIC
        /* Chunk end is Protocol stuff! Set conversion = 1 to read CR LF: */
        PUSH_EBCDIC_INPUTCONVERSION_STATE_r(r, 1);
#endif /*CHARSET_EBCDIC*/
a2210 5
#ifdef CHARSET_EBCDIC
        /* restore ASCII->EBCDIC conversion state */
        POP_EBCDIC_INPUTCONVERSION_STATE_r(r);
#endif /*CHARSET_EBCDIC*/

a2340 3
#ifdef TPF
    struct timeval tv;
#endif 
a2676 4
#ifdef CHARSET_EBCDIC
    /* Error Responses (builtin / string literal / redirection) are TEXT! */
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
#endif
a2768 5

#ifdef CHARSET_EBCDIC
    /* Server-generated response, converted */
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
#endif
@


1.25
log
@Fix printf format string. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.24 2004/01/13 16:32:53 otto Exp $ */
d80 1
d1421 14
d1438 2
a1439 2
	    ap_psprintf(r->pool, "Digest realm=\"%s\", nonce=\"%lu\"",
		ap_auth_name(r), (unsigned long)r->request_time));
@


1.25.2.1
log
@MFC:
Fix by brad@@

mod_digest for Apache does not properly verify the nonce of a client response
by using a AuthNonce secret.

CAN-2003-0987
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.25 2004/01/15 12:17:18 otto Exp $ */
a79 1
#include "util_md5.h"           /* For digestAuth */
a1419 14
    /* We need to create a nonce which:
     * a) changes all the time (see r->request_time)
     *    below and
     * b) of which we can verify that it is our own
     *    fairly easily when it comes to veryfing
     *    the digest coming back in the response.
     * c) and which as a whole should not
     *    be unlikely to be in use anywhere else.
     */
    char * nonce_prefix = ap_md5(r->pool,
           (unsigned char *)
           ap_psprintf(r->pool, "%s%lu",
                       ap_auth_nonce(r), r->request_time));

d1423 2
a1424 2
           ap_psprintf(r->pool, "Digest realm=\"%s\", nonce=\"%s%lu\"",
               ap_auth_name(r), nonce_prefix, r->request_time));
@


1.24
log
@return value at end of non-void function
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.23 2003/08/21 13:11:35 henning Exp $ */
d1424 1
a1424 1
		ap_auth_name(r), r->request_time));
@


1.23
log
@merge
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.22 2003/07/08 09:51:23 david Exp $ */
d3226 1
d3275 1
@


1.23.2.1
log
@MFC:
Fix by brad@@

mod_digest for Apache does not properly verify the nonce of a client response
by using a AuthNonce secret.

CAN-2003-0987
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.23 2003/08/21 13:11:35 henning Exp $ */
a79 1
#include "util_md5.h"           /* For digestAuth */
a1419 14
    /* We need to create a nonce which:
     * a) changes all the time (see r->request_time)
     *    below and
     * b) of which we can verify that it is our own
     *    fairly easily when it comes to veryfing
     *    the digest coming back in the response.
     * c) and which as a whole should not
     *    be unlikely to be in use anywhere else.
     */
    char * nonce_prefix = ap_md5(r->pool,
           (unsigned char *)
           ap_psprintf(r->pool, "%s%lu",
                       ap_auth_nonce(r), r->request_time));

d1423 2
a1424 2
           ap_psprintf(r->pool, "Digest realm=\"%s\", nonce=\"%s%lu\"",
               ap_auth_name(r), nonce_prefix, r->request_time));
@


1.22
log
@declare chroot and etag functions in the .h files
and get rid of some implicit declaration warnings
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.21 2003/02/21 18:41:09 henning Exp $ */
d5 1
a5 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
d1092 1
a1092 1
        char *lint;
d1094 1
a1094 2
	lint = ap_palloc(r->pool, strlen(r->protocol)+1);
	if (3 == sscanf(r->protocol, "%4s/%u.%u%s", http, &major, &minor, lint)
@


1.21
log
@open the etag-state file writeonly. open it O_TRUNC in case it was too big.
chmod/chown to root.www 0640, just in case a etag file from the initial
version is around.

ok cloder theo
@
text
@d1 1
a1 1
/*	$OpenBSD: http_protocol.c,v 1.20 2003/02/21 16:39:56 henning Exp $ */
a3228 12
API_EXPORT(void) ap_init_etag(pool *pconf)
{
    if (ap_read_etag_state(pconf) == -1) {
        ap_create_etag_state(pconf);
        if (ap_read_etag_state(pconf) == -1) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
              "could not initialize etag state");
            exit(-1);
        }
    }			
}

d3275 12
@


1.20
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d3203 2
a3204 1
    if ((fd = open(filename, O_CREAT|O_RDWR|O_NOFOLLOW, 0640)) == -1) {
d3259 3
@


1.19
log
@fix restarts.
the etag-state file wasn't readable after chroot and privilege drop.
therefore, make it root.www 640.
split the read and write portions to their own functions, and in init_etag,
try to write the etag-state; in case of any problem with that, create a new
one and read that.
@
text
@d1 1
@


1.18
log
@Add hyphens to boundary ID to make it not pure base64.  This means that
the boundary could never ever be accidentally matched inside base64
data.  Based on conversation with markus@@, deraadt@@, henning@@. OK
deraadt@@, henning@@
@
text
@d3192 1
a3192 1
API_EXPORT(void) ap_init_etag(pool *pconf)
a3193 1
    struct stat st;
a3198 2
    ap_SHA1Init(&baseCtx);

d3200 1
a3200 2
    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, NULL,
      "Initializing etag from %s", filename);
d3202 1
a3202 1
    if ((fd = open(filename, O_CREAT|O_RDWR|O_NOFOLLOW, 0600)) == -1) {
d3204 1
a3204 1
          "could not open %s", filename);
d3208 1
a3208 1
    if (fstat(fd, &st) == -1) {
d3210 1
a3210 1
          "could not fstat %s", filename);
d3214 4
a3217 7
    if (st.st_size != sizeof(rnd)*4) {
        if (st.st_size > 0) {
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
              "truncating %s from %qd bytes to 0", filename, st.st_size);
        }

        if (ftruncate(fd, 0) == -1) {
d3219 1
a3219 1
              "could not truncate %s", filename);
d3222 1
d3224 2
a3225 9
        /* generate random bytes and write them */
        for (u = 0; u < 4; u++) {
            rnd = arc4random();
            if (write(fd, &rnd, sizeof(rnd)) == -1) {
                ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
                  "could not write to %s", filename);
                exit(-1);
            }
        }
d3227 5
a3231 2
        /* rewind */
        if (lseek(fd, 0, SEEK_SET) == -1) {
d3233 1
a3233 1
              "could not seek on %s", filename);
d3236 30
d3270 2
a3271 5
        if (read(fd, &rnd, sizeof(rnd)) < sizeof(rnd)) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
              "could not read from %s", filename);
            exit(-1);
        }
@


1.17
log
@Don't leak the inode numbers of served files via the
ETag (entity tag) header value.  Instead of including
the file modification date, inode, file size, etc.
directly in the ETag header, return a SHA1 hash of
these values instead.

This SHA1 hash is initialized with a pseudorandom
secret, so that it's harder to brute force inode
numbers.  This initialization secret is saved in a
file called "etag-state" in the httpd chroot logs/
directory, so that the ETag header values are consistent
across httpd restarts (if the secret were different
each time httpd started, ETags would change unnecessarily
and thereby cause caches to refresh unnecessarily).

An additional change is introduced: we add the dev
number to the hash when (and only when) we add the
inode number to the hash.

Before:
HTTP/1.1 200 OK
Server: Apache/1.3.27 (Unix) mod_ssl/2.8.12 OpenSSL/0.9.7-beta3
ETag: "b10d3-1e59-3e49cbe4"

In this case, we can tell the inode number of index.html
is is b10d3 hex.

After:
HTTP/1.1 200 OK
Server: Apache/1.3.27 (Unix) mod_ssl/2.8.12 OpenSSL/0.9.7-beta3
ETag: "3f3b3cb2ce2e278087960b3be6a6e9844166e371"

Idea and solution by deraadt@@.  OK deraadt@@, henning@@.  Any
bugs are my fault :)
@
text
@d343 3
a345 1
        if (!isalnum(*b))
@


1.16
log
@My last commit uses base64 for the multipart MIME boundary id.  Since
the base64 alphabet includes the characters '/', '+', and '=', it may
violate section 4 of RFC 1341, which says that these kinds of characters
must be quoted in order to be used as a header parameter.  Pointed out
by Wouter Clarie (rimshot AT pandora DOT be).

My solution is not to quote the parameter (I'm afraid that will break
simple browsers) but to replace special characters with alphabetic
characters so that the resulting string is entirely alphanumeric.  We
don't want to use hex here, the alphabet is too small.

"not too ugly for me" deraadt@@, "a bit ugly but good enough" henning@@,
"that might be better than quoting" wouter
@
text
@d79 1
d671 1
a671 1
API_EXPORT(char *) ap_make_etag(request_rec *r, int force_weak)
d3180 139
@


1.15
log
@Don't leak httpd child PIDs via multipart MIME boundary separators.
Instead, generate a random MIME boundary separator that is also
much longer, which makes it less likely to occur in the data.

Before:
HTTP/1.1 206 Partial Content
Server: Apache/1.3.27 (Unix) mod_ssl/2.8.12 OpenSSL/0.9.7-beta3
Content-Type: multipart/byteranges; boundary=3e4e7d648e6

where the first 6 hex digits of the boundary is the request
time and the last 4 hex digits of the boundary (48e6) is the PID
of the httpd process that served the request.

After:
HTTP/1.1 206 Partial Content
Server: Apache/1.3.27 (Unix) mod_ssl/2.8.12 OpenSSL/0.9.7-beta3
Content-Type: multipart/byteranges; boundary=lqmQDSxeaFSosnx+R46M94slY7G5BKGVPIhCc4ffoW852Vz0RbOaLJfMCAHHTfvR

The boundary now consists of 48 pseudorandom bytes encoded into 64
base64 characters.  This is in accordance with RFC 1341 section 7.2.1.

Based on conversations with deraadt@@. OK deraadt@@
@
text
@d287 1
a287 1
    char *bbuf;
d341 5
@


1.14
log
@merge apache 1.3.27 and mod_ssl 2.8.11
@
text
@d287 2
d290 1
d336 7
a342 2
    r->boundary = ap_psprintf(r->pool, "%lx%lx",
			      r->request_time, (long) getpid());
@


1.13
log
@merge
@
text
@d126 10
a135 4
    core_dir_config *conf = (core_dir_config *)ap_get_module_config(
	r->per_dir_config, &core_module);
    if (!type) type = ap_default_type(r);
    if (conf->add_default_charset != ADD_DEFAULT_CHARSET_ON) return type;
d141 2
a142 1
    } else {
d146 1
a146 1
	for (pcset = needcset; *pcset ; pcset++)
d149 1
a149 1
		    conf->add_default_charset_name, NULL);
d152 1
d740 5
d768 5
a773 1

d1003 2
a1004 1
    int len, n;
d1066 8
a1073 3
    if (2 == sscanf(r->protocol, "HTTP/%u.%u%n", &major, &minor, &n)
      && minor < HTTP_VERSION(1,0))	/* don't allow HTTP/0.1000 */
	r->proto_num = HTTP_VERSION(major, minor);
d1075 11
a1085 2
	r->proto_num = HTTP_VERSION(1,0);
	n = 0;
d1089 15
a1103 11
     * after the protocol string */
    while (ap_isspace(r->protocol[n]))
        ++n;
    if (r->protocol[n] != '\0') {
        r->status    = HTTP_BAD_REQUEST;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = ap_pstrdup(r->pool, "HTTP/1.0");
        ap_table_setn(r->notes, "error-notes",
                      "The request line contained invalid characters "
                      "following the protocol string.<P>\n");
        return 0;
d2034 1
a2034 1
        while (ap_isdigit(*pos) || ap_isspace(*pos))
d2038 6
d2047 1
a2047 1
            if (errno || (endstr && *endstr)) {
d2052 1
a2052 1
        if (*pos != '\0' || conversion_error) {
d2105 9
d2857 7
a2863 1
        r->content_type = "text/html; charset=iso-8859-1";
@


1.13.2.1
log
@Pull patch from current:
Fix by cloder@@ and henning@@

Don't leak httpd child PIDs via multipart MIME boundary separators.
Instead, generate a random MIME boundary separator that is also
much longer, which makes it less likely to occur in the data.

Since the base64 alphabet includes the characters  '/', '+',
and '=', it may violate section 4 of RFC 1341, which says that these
kinds of characters must be quoted in order to be used as a header
parameter. Pointed out by Wouter Clarie (rimshot AT pandora DOT be).

Don't leak the inode numbers of served files via the ETag (entity tag)
header value.  Instead of including the file modification date, inode,
file size, etc. directly in ETag header, return a SHA1 hash of these
values instead.
@
text
@a0 1
/*	$OpenBSD: http_protocol.c,v 1.20 2003/02/21 16:39:56 henning Exp $ */
a78 1
#include "ap_sha1.h"
a278 2
    char *bbuf, *b;
    u_int32_t rbuf[12]; /* 48 bytes yields 64 base64 chars */
a279 1
    size_t u;
d325 2
a326 14
    for (u = 0; u < sizeof(rbuf)/sizeof(rbuf[0]); u++)
        rbuf[u] = htonl(arc4random());

    bbuf = ap_palloc(r->pool, ap_base64encode_len(sizeof(rbuf)));
    ap_base64encode(bbuf, (const unsigned char *)rbuf, sizeof(rbuf));
    for (b = bbuf; *b != '\0'; b++) {
        if (((b - bbuf) + 1) % 7 == 0)
            *b = '-';
        else if (!isalnum(*b))
            *b = 'a';
    }

    r->boundary = bbuf;

d649 1
a649 1
API_EXPORT(char *) ap_make_etag_orig(request_rec *r, int force_weak)
a3108 160
}

/*
 * The shared hash context, copies of which are used by all children for
 * etag generation.  ap_init_etag() must be called once before all the
 * children are created.  We use a secret hash initialization value
 * so that people can't brute-force inode numbers.
 */
static AP_SHA1_CTX baseCtx;

int ap_create_etag_state(pool *pconf)
{
    u_int32_t rnd;
    unsigned int u;
    int fd;
    const char* filename;

    filename = ap_server_root_relative(pconf, "logs/etag-state");
    ap_server_strip_chroot(filename, 0);

    if ((fd = open(filename, O_CREAT|O_WRONLY|O_TRUNC|O_NOFOLLOW, 0640)) ==
      -1) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
          "could not create %s", filename);
        exit(-1);
    }

    if (fchown(fd, -1, ap_group_id) == -1) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
          "could not chown %s", filename);
        exit(-1);
    }

    /* generate random bytes and write them */
    for (u = 0; u < 4; u++) {
        rnd = arc4random();
        if (write(fd, &rnd, sizeof(rnd)) == -1) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
              "could not write to %s", filename);
            exit(-1);
        }
    }

    close (fd);
}

API_EXPORT(void) ap_init_etag(pool *pconf)
{
    if (ap_read_etag_state(pconf) == -1) {
        ap_create_etag_state(pconf);
        if (ap_read_etag_state(pconf) == -1) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
              "could not initialize etag state");
            exit(-1);
        }
    }			
}

int ap_read_etag_state(pool *pconf)
{
    struct stat st;
    u_int32_t rnd;
    unsigned int u;
    int fd;
    const char* filename;

    ap_SHA1Init(&baseCtx);

    filename = ap_server_root_relative(pconf, "logs/etag-state");
    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, NULL,
      "Initializing etag from %s", filename);

    ap_server_strip_chroot(filename, 0);

    if ((fd = open(filename, O_RDONLY|O_NOFOLLOW, 0640)) == -1)
	return (-1);

    fchmod(fd, S_IRUSR|S_IWUSR|S_IRGRP);
    fchown(fd, -1, ap_group_id);

    if (fstat(fd, &st) == -1) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
          "could not fstat %s", filename);
        exit(-1);
    }

    if (st.st_size != sizeof(rnd)*4) {
	return (-1);
    }

    /* read 4 random 32-bit uints from file and update the hash context */
    for (u = 0; u < 4; u++) {
        if (read(fd, &rnd, sizeof(rnd)) < sizeof(rnd))
            return (-1);

        ap_SHA1Update_binary(&baseCtx, (const unsigned char *)&rnd,
          sizeof(rnd));
    }

    if (close(fd) == -1) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
          "could not properly close %s", filename);
        exit(-1);
    }
}

API_EXPORT(char *) ap_make_etag(request_rec *r, int force_weak)
{
    AP_SHA1_CTX hashCtx;
    core_dir_config *cfg;
    etag_components_t etag_bits;
    int weak;
    unsigned char md[SHA_DIGESTSIZE];
    unsigned int i;
    
    memcpy(&hashCtx, &baseCtx, sizeof(hashCtx));
    
    cfg = (core_dir_config *)ap_get_module_config(r->per_dir_config,
      &core_module);
    etag_bits = (cfg->etag_bits & (~ cfg->etag_remove)) | cfg->etag_add;
    if (etag_bits == ETAG_UNSET)
        etag_bits = ETAG_BACKWARD;
    
    weak = ((r->request_time - r->mtime <= 1) || force_weak);
    
    if (r->finfo.st_mode != 0) {
        if (etag_bits & ETAG_NONE) {
            ap_table_setn(r->notes, "no-etag", "omit");
            return "";
        }
        if (etag_bits & ETAG_INODE) {
            ap_SHA1Update_binary(&hashCtx,
              (const unsigned char *)&r->finfo.st_dev,
              sizeof(r->finfo.st_dev));
            ap_SHA1Update_binary(&hashCtx,
              (const unsigned char *)&r->finfo.st_ino,
              sizeof(r->finfo.st_ino));
        }
        if (etag_bits & ETAG_SIZE)
            ap_SHA1Update_binary(&hashCtx,
              (const unsigned char *)&r->finfo.st_size,
              sizeof(r->finfo.st_size));
        if (etag_bits & ETAG_MTIME)
            ap_SHA1Update_binary(&hashCtx,
              (const unsigned char *)&r->mtime,
              sizeof(r->mtime));
    }
    else {
        weak = 1;
        ap_SHA1Update_binary(&hashCtx, (const unsigned char *)&r->mtime,
          sizeof(r->mtime));
    }
    ap_SHA1Final(md, &hashCtx);
    return ap_psprintf(r->pool, "%s\""
      "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
        "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
        "\"", weak ? "W/" : "",
      md[0], md[1], md[2], md[3], md[4], md[5], md[6], md[7],
      md[8], md[9], md[10], md[11], md[12], md[13], md[14], md[15],
      md[16], md[17], md[18], md[19]);
@


1.12
log
@The Real Fix for the buffer overflow; from apache.org
ok beck@@
@
text
@d174 1
a174 1
	*start = strtol(r->range, (char **)&r->range, 10);
d189 1
a189 1
	*end = strtol(r->range, (char **)&r->range, 10);
d860 1
a860 1
static int getline(char *s, int n, BUFF *in, int fold)
d866 1
a866 1
    /* When getline() is called, the HTTP protocol is in a state
d981 1
a981 1
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* getline's two extra for \n\0 */
d986 1
a986 1
    int len;
d1003 1
a1003 1
    while ((len = getline(l, sizeof(l), conn->client, 0)) <= 0) {
d1034 1
a1034 1
    /* getline returns (size of max buffer - 1) if it fills up the
d1048 1
a1048 1
    if (2 == sscanf(r->protocol, "HTTP/%u.%u", &major, &minor)
d1051 1
a1051 1
    else
d1053 16
d1075 1
a1075 1
    char field[DEFAULT_LIMIT_REQUEST_FIELDSIZE + 2]; /* getline's two extra */
d1090 1
a1090 1
    while ((len = getline(field, sizeof(field), c->client, 1)) > 0) {
d1100 1
a1100 1
        /* getline returns (size of max buffer - 1) if it fills up the
d1192 8
a1548 1
    const char *server;
d1577 1
a1577 1
    /* keep a previously set server header (possible from proxy), otherwise
d1579 5
a1583 2
    if (server = ap_table_get(r->headers_out, "Server")) {
        ap_send_header_field(r, "Server", server);
d1996 1
d2000 11
a2010 1
        if (*pos != '\0') {
d2012 1
a2012 1
                        "Invalid Content-Length %s", lenp);
a2014 2

        r->remaining = atol(lenp);
d2063 1
a2063 1
static long get_chunk_size(char *b)
d2158 1
a2158 1
        chunk_start = getline(buffer, bufsiz, r->connection->client, 0);
d2165 1
a2165 1
        len_to_read = get_chunk_size(buffer);
d2203 1
a2203 1
                  getline(buffer, bufsiz, r->connection->client, 1)) > 0)) {
@


1.11
log
@work around a possible buffer overflow in chunk handling.
ok beck@@
@
text
@d2031 1
d2033 6
a2038 1
    while (ap_isxdigit(*b)) {
d2041 1
a2041 2
	/* This works even on EBCDIC. */
        if (*b >= '0' && *b <= '9')
d2043 2
a2044 1
        else if (*b >= 'A' && *b <= 'F')
d2046 2
a2047 1
        else if (*b >= 'a' && *b <= 'f')
d2049 1
d2052 1
d2055 4
d2084 1
a2084 1
        len_to_read = (r->remaining > (unsigned int)bufsiz) ? bufsiz : r->remaining;
d2143 4
d2200 1
a2200 1
    len_to_read = (r->remaining > (unsigned int)bufsiz) ? bufsiz : r->remaining;
@


1.10
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d2071 1
a2071 1
        len_to_read = (r->remaining > bufsiz) ? bufsiz : r->remaining;
d2183 1
a2183 1
    len_to_read = (r->remaining > bufsiz) ? bufsiz : r->remaining;
@


1.10.2.1
log
@Pull in patch from current:
Fix (henning):
- work around a possible buffer overflow in chunk handling.
ok beck@@
- The Real Fix for the buffer overflow; from apache.org
ok beck@@
@
text
@a2030 1
    long chunkbits = sizeof(long) * 8;
d2032 1
a2032 6
    /* Skip leading zeros */
    while (*b == '0') {
        ++b;
    }

    while (ap_isxdigit(*b) && (chunkbits > 0)) {
d2035 2
a2036 1
        if (*b >= '0' && *b <= '9') {
d2038 1
a2038 2
        }
        else if (*b >= 'A' && *b <= 'F') {
d2040 1
a2040 2
        }
        else if (*b >= 'a' && *b <= 'f') {
a2041 1
        }
a2043 1
        chunkbits -= 4;
a2045 4
    if (ap_isxdigit(*b) && (chunkbits <= 0)) {
        /* overflow */
        return -1;
    }
a2128 4
        }
        else if (len_to_read < 0) {
            r->connection->keepalive = -1;
            return -1;
@


1.9
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d98 2
a99 3
#define PUSH_EBCDIC_OUTPUTCONVERSION_STATE(_buff, _onoff) \
        int _convert_out = ap_bgetflag(_buff, B_EBCDIC2ASCII); \
        ap_bsetflag(_buff, B_EBCDIC2ASCII, _onoff);
d101 8
a108 2
#define POP_EBCDIC_OUTPUTCONVERSION_STATE(_buff) \
        ap_bsetflag(_buff, B_EBCDIC2ASCII, _convert_out);
d246 1
a246 1
    PUSH_EBCDIC_OUTPUTCONVERSION_STATE(r->connection->client, 1);
d270 1
a270 1
    POP_EBCDIC_OUTPUTCONVERSION_STATE(r->connection->client);
d364 1
d653 2
d656 6
d678 37
a714 5
        etag = ap_psprintf(r->pool,
                    "%s\"%lx-%lx-%lx\"", weak,
                    (unsigned long) r->finfo.st_ino,
                    (unsigned long) r->finfo.st_size,
                    (unsigned long) r->mtime);
d1064 1
a1064 1
    unsigned int fields_read = 0;
d1117 1
a1117 1
request_rec *ap_read_request(conn_rec *conn)
d1159 2
a1160 1
    ap_bsetflag(r->connection->client, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 1);
d1282 1
a1282 1
void ap_set_sub_req_protocol(request_rec *rnew, const request_rec *r)
d1313 1
a1313 1
void ap_finalize_sub_req_protocol(request_rec *sub)
d1381 2
a1382 2
    /* CHARSET_EBCDIC Issue's here ?!? Compare with 32/9 instead
     * as we are operating on an octed stream ?
d1511 2
a1512 1
    const char *fieldname, const char *fieldval)
d1514 5
d1525 1
d1533 1
a1533 2
    /* mod_proxy is only HTTP/1.0, so avoid sending HTTP/1.1 error response;
     * kluge around broken browsers when indicated by force-response-1.0
d1535 2
a1536 3
    if (r->proxyreq != NOT_PROXY
        || (r->proto_num == HTTP_VERSION(1,0)
            && ap_table_get(r->subprocess_env, "force-response-1.0"))) {
d1545 1
a1545 1
    { PUSH_EBCDIC_OUTPUTCONVERSION_STATE(r->connection->client, 1);
d1548 1
a1548 2
    /* Output the HTTP/1.x Status-Line and the Date and Server fields */

d1551 1
a1552 1
    ap_send_header_field(r, "Server", ap_get_server_version());
d1554 10
d1567 1
a1567 1
    POP_EBCDIC_OUTPUTCONVERSION_STATE(r->connection->client); }
d1638 4
d1655 1
a1655 1
int ap_send_http_options(request_rec *r)
d1779 5
d1819 1
a1819 1
    { PUSH_EBCDIC_OUTPUTCONVERSION_STATE(r->connection->client, 1);
d1872 1
a1872 1
    POP_EBCDIC_OUTPUTCONVERSION_STATE(r->connection->client); }
d1885 1
a1885 1
	PUSH_EBCDIC_OUTPUTCONVERSION_STATE(r->connection->client, 1);
d1900 1
a1900 1
	POP_EBCDIC_OUTPUTCONVERSION_STATE(r->connection->client);
d1990 2
a1991 1
    if (max_body && (r->remaining > max_body)) {
d2000 2
a2001 2
        /* @@@@@@ Temporary kludge for guessing the conversion @@@@@@
         * from looking at the MIME header. 
d2004 1
a2004 8
        const char *typep = ap_table_get(r->headers_in, "Content-Type");
        int convert_in = (typep == NULL ||
                          strncasecmp(typep, "text/", 5) == 0 ||
                          strncasecmp(typep, "message/", 8) == 0 ||
                          strncasecmp(typep, "multipart/", 10) == 0 ||
                          strcasecmp (typep, "application/x-www-form-urlencoded") == 0
                         );
        ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, convert_in);
d2035 1
d2099 2
a2100 1
    if (max_body && (r->read_length > max_body)) {
d2196 1
a2196 1
        PUSH_EBCDIC_INPUTCONVERSION_STATE(r->connection->client, 1);
d2205 1
a2205 1
        POP_EBCDIC_INPUTCONVERSION_STATE(r->connection->client);
d2338 3
d2347 1
a2347 1
#ifndef TPF    
d2406 5
d2412 1
d2591 1
a2591 1
API_EXPORT(int) ap_rprintf(request_rec *r, const char *fmt,...)
d2677 4
d2768 5
d2928 1
a2928 1
	    ap_rputs("I'm tired of waiting for your request.\n", r);
@


1.9.4.1
log
@Pull in patch from current:
Fix (henning):
- work around a possible buffer overflow in chunk handling.
ok beck@@
- The Real Fix for the buffer overflow; from apache.org
ok beck@@
@
text
@a1966 1
    long chunkbits = sizeof(long) * 8;
d1968 1
a1968 6
    /* Skip leading zeros */
    while (*b == '0') {
        ++b;
    }

    while (ap_isxdigit(*b) && (chunkbits > 0)) {
d1971 1
a1971 1
        if (*b >= '0' && *b <= '9') {
d1973 1
a1973 2
        }
        else if (*b >= 'A' && *b <= 'F') {
d1975 1
a1975 2
        }
        else if (*b >= 'a' && *b <= 'f') {
a1976 1
        }
a1978 1
        chunkbits -= 4;
a1980 4
    if (ap_isxdigit(*b) && (chunkbits <= 0)) {
        /* overflow */
        return -1;
    }
a2062 4
        }
        else if (len_to_read < 0) {
            r->connection->keepalive = -1;
            return -1;
@


1.8
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1995-1999 The Apache Group.  All rights reserved.
d19 6
a24 9
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
d26 4
a29 3
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
d31 3
a33 4
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
d35 4
a38 4
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 3
a52 5
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
d54 3
d144 9
a152 1
static int parse_byterange(char *range, long clength, long *start, long *end)
d154 1
a154 1
    char *dash = strchr(range, '-');
d156 2
a157 2
    if (!dash)
        return 0;
d159 3
a161 4
    if ((dash == range)) {
        /* In the form "-5" */
        *start = clength - atol(dash + 1);
        *end = clength - 1;
d163 3
a165 8
    else {
        *dash = '\0';
        dash++;
        *start = atol(range);
        if (*dash)
            *end = atol(dash);
        else                    /* "5-" */
            *end = clength - 1;
d168 30
a197 2
    if (*start < 0)
	*start = 0;
d199 1
a199 2
    if (*end >= clength)
        *end = clength - 1;
d201 21
a221 2
    if (*start > *end)
	return 0;
d223 1
a223 1
    return (*start > 0 || *end < clength - 1);
d226 44
a269 2
static int internal_byterange(int, long *, request_rec *, const char **, long *,
                              long *);
d274 3
a276 2
    long range_start, range_end;

d296 1
d313 35
a347 7
    if (!strchr(range, ',')) {
        /* A single range */
        if (!parse_byterange(ap_pstrdup(r->pool, range + 6), r->clength,
                             &range_start, &range_end))
            return 0;

        r->byterange = 1;
d349 19
d370 8
a377 3
		range_start, range_end, r->clength));
        ap_table_setn(r->headers_out, "Content-Length",
	    ap_psprintf(r->pool, "%ld", range_end - range_start + 1));
d380 8
a387 18
        /* a multiple range */
        const char *r_range = ap_pstrdup(r->pool, range + 6);
        long tlength = 0;
	int ret;
	
        r->boundary = ap_psprintf(r->pool, "%lx%lx",
				r->request_time, (long) getpid());
        do {
	    /* Loop while we have another range spec to process */
	    ret = internal_byterange(0, &tlength, r, &r_range, NULL, NULL);
	} while (ret == 1);
	/* If an error occured processing one of the range specs, we
	 * must fail */
	if (ret < 0)
	    return 0;
        ap_table_setn(r->headers_out, "Content-Length",
	    ap_psprintf(r->pool, "%ld", tlength));
        r->byterange = 2;
a388 5

    r->status = PARTIAL_CONTENT;
    r->range = range + 6;

    return 1;
d393 1
a393 2
    return internal_byterange(1, NULL, r, &r->range, offset, length);
}
d395 12
a406 75
/* If this function is called with realreq=1, it will spit out
 * the correct headers for a byterange chunk, and set offset and
 * length to the positions they should be.
 *
 * If it is called with realreq=0, it will add to tlength the length
 * it *would* have used with realreq=1.
 *
 * Either case will return 1 if it should be called again, 0 when done,
 * or -1 if an error occurs AND realreq=0.
 */
static int internal_byterange(int realreq, long *tlength, request_rec *r,
                              const char **r_range, long *offset, long *length)
{
    long range_start, range_end;
    char *range;
#ifdef CHARSET_EBCDIC
    /* determine current setting of conversion flag,
     * set to ON (protocol strings MUST be converted)
     * and reset to original setting before returning
     */
    PUSH_EBCDIC_OUTPUTCONVERSION_STATE(r->connection->client, 1);
#endif /*CHARSET_EBCDIC*/

    if (!**r_range) {
        if (r->byterange > 1) {
            if (realreq)
                ap_rvputs(r, CRLF "--", r->boundary, "--" CRLF, NULL);
            else
                *tlength += 4 + strlen(r->boundary) + 4;
        }
#ifdef CHARSET_EBCDIC
        POP_EBCDIC_OUTPUTCONVERSION_STATE(r->connection->client);
#endif /*CHARSET_EBCDIC*/
        return 0;
    }

    range = ap_getword(r->pool, r_range, ',');
    if (!parse_byterange(range, r->clength, &range_start, &range_end)) {
#ifdef CHARSET_EBCDIC
        POP_EBCDIC_OUTPUTCONVERSION_STATE(r->connection->client);
#endif /*CHARSET_EBCDIC*/
	if (!realreq)
	    /* Return error on invalid syntax */
	    return -1;
	else
	    /* Should never get here */
	    return 0;
    }

    if (r->byterange > 1) {
        const char *ct = make_content_type(r, r->content_type);
        char ts[MAX_STRING_LEN];

        ap_snprintf(ts, sizeof(ts), "%ld-%ld/%ld", range_start, range_end,
                    r->clength);
        if (realreq)
            ap_rvputs(r, CRLF "--", r->boundary, CRLF "Content-type: ",
                   ct, CRLF "Content-range: bytes ", ts, CRLF CRLF,
                   NULL);
        else
            *tlength += 4 + strlen(r->boundary) + 16 + strlen(ct) + 23 +
                        strlen(ts) + 4;
    }

    if (realreq) {
        *offset = range_start;
        *length = range_end - range_start + 1;
    }
    else {
        *tlength += range_end - range_start + 1;
    }
#ifdef CHARSET_EBCDIC
    POP_EBCDIC_OUTPUTCONVERSION_STATE(r->connection->client);
#endif /*CHARSET_EBCDIC*/
    return 1;
d1188 1
a1188 1
                      "(see RFC2068 section 9, and 14.23): %s", r->uri);
d1195 7
a1222 6
    }

    if ((access_status = ap_run_post_read_request(r))) {
        ap_die(access_status, r);
        ap_log_transaction(r);
        return NULL;
@


1.7
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d238 2
a239 2

        r->byterange = 2;
d242 8
a249 1
        while (internal_byterange(0, &tlength, r, &r_range, NULL, NULL));
d252 1
d273 2
a274 2
 * Either case will return 1 if it should be called again, and 0
 * when done.
d307 6
a312 3
        /* Skip this one */
        return internal_byterange(realreq, tlength, r, r_range, offset,
                                  length);
d873 1
a873 1
    int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
@


1.6
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d106 37
d305 1
a305 1
        const char *ct = r->content_type ? r->content_type : ap_default_type(r);
d969 1
a969 1
                "<PRE>\n", field, "</PRE>\n", NULL));
d979 1
a979 1
                "<PRE>\n", copy, "</PRE>\n", NULL));
d1685 2
a1686 4
    else if (r->content_type)
        ap_table_setn(r->headers_out, "Content-Type", r->content_type);
    else
        ap_table_setn(r->headers_out, "Content-Type", ap_default_type(r));
d2597 1
a2597 1
        r->content_type = "text/html";
@


1.5
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d84 21
d236 7
d247 1
a247 1
                ap_rvputs(r, "\015\012--", r->boundary, "--\015\012", NULL);
d251 3
d258 4
a261 1
    if (!parse_byterange(range, r->clength, &range_start, &range_end))
d265 1
d274 2
a275 2
            ap_rvputs(r, "\015\012--", r->boundary, "\015\012Content-type: ",
                   ct, "\015\012Content-range: bytes ", ts, "\015\012\015\012",
d289 3
d705 11
d722 4
a725 2
        if (retval <= 0)
            return ((retval < 0) && (total == 0)) ? -1 : total;
d750 1
a750 1
            return total;       /* if not, input line exceeded buffer size */
d760 5
d1052 1
a1052 1
     * now read
d1075 2
d1174 2
a1175 1
                  r->proxyreq ? "Proxy-Authenticate" : "WWW-Authenticate",
d1183 2
a1184 1
	    r->proxyreq ? "Proxy-Authenticate" : "WWW-Authenticate",
d1192 3
a1194 2
                                      r->proxyreq ? "Proxy-Authorization"
                                                  : "Authorization");
d1351 1
a1351 1
    return (0 < ap_rvputs(r, fieldname, ": ", fieldval, "\015\012", NULL));
a1356 3
#ifdef CHARSET_EBCDIC
    int convert = ap_bgetflag(r->connection->client, B_EBCDIC2ASCII);
#endif /*CHARSET_EBCDIC*/
d1367 1
a1367 1
    if (r->proxyreq
d1378 1
a1378 1
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, 1);
d1383 1
a1383 1
    ap_rvputs(r, protocol, " ", r->status_line, "\015\012", NULL);
d1391 1
a1391 2
    if (!convert)
        ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, convert);
d1418 1
a1418 1
        ap_bputs("X-Pad: avoid browser bug\015\012", client);
d1420 1
a1420 1
    ap_bputs("\015\012", client);  /* Send the terminating empty line */
d1465 1
a1465 1
    ap_rvputs(r, r->the_request, "\015\012", NULL);
d1469 1
a1469 1
    ap_rputs("\015\012", r);
a1597 3
#ifdef CHARSET_EBCDIC
    int convert = ap_bgetflag(r->connection->client, B_EBCDIC2ASCII);
#endif /*CHARSET_EBCDIC*/
d1634 1
a1634 1
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, 1);
d1689 1
a1689 2
    if (!convert)
        ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, convert);
d1701 3
d1711 1
a1711 1
        ap_rputs("0\015\012", r);
d1713 1
a1713 1
        ap_rputs("\015\012", r);
d1715 4
d1814 17
d1843 1
a1843 1
        ap_rvputs(r, SERVER_PROTOCOL, " ", status_lines[0], "\015\012\015\012",
d2015 5
d2023 6
d2483 1
a2483 1
void ap_send_error_response(request_rec *r, int recursive_error)
d2718 2
a2719 2
	    ap_rputs("The proxy server received an invalid\015\012"
	             "response from an upstream server.<P>\015\012", r);
@


1.4
log
@mod_ssl-2.2.3-1.3.4 (will require libssl-1.1 for https to work, but
mostly harmless otherwise).
@
text
@d147 4
a150 2
    /* Check the If-Range header for Etag or Date */

d154 1
a154 1
                (strcasecmp(if_range, match) != 0))
d158 1
a158 1
                 (strcasecmp(if_range, match) != 0))
d403 2
a404 2
     * AND if our ETag does not match any of the entity tags in that field
     * AND the field value is not "*" (meaning match anything), then
d408 3
a410 2
        if ((etag == NULL) ||
            ((if_match[0] != '*') && !ap_find_token(r->pool, if_match, etag))) {
d431 10
a440 6
     * AND if our ETag matches any of the entity tags in that field
     * OR if the field value is "*" (meaning match anything), then
     *    if the request method was GET or HEAD, the server SHOULD
     *       respond with a 304 (Not Modified) response.
     *    For all other request methods, the server MUST
     *       respond with a status of 412 (Precondition Failed).
d444 19
a462 7
        int rstatus;

        if ((if_nonematch[0] == '*')
            || ((etag != NULL) && ap_find_token(r->pool, if_nonematch, etag))) {
            rstatus = (r->method_number == M_GET) ? HTTP_NOT_MODIFIED
                                                  : HTTP_PRECONDITION_FAILED;
            return rstatus;
a751 4
#ifndef WIN32   /* for OS/2 only: */
	    /* Fix OS/2 HPFS filename case problem. */
	    ap_str_tolower(r->uri);
#endif
d790 4
a955 1
            ap_bflush(r->connection->client);
a968 1
            ap_bflush(r->connection->client);
a987 1
            ap_bflush(r->connection->client);
a1019 1
        ap_bflush(r->connection->client);
a1039 1
            ap_bflush(r->connection->client);
d1158 7
a1164 1
    t = ap_uudecode(r->pool, auth_line);
d1183 10
a1192 1
static char *status_lines[RESPONSE_CODES] = {
d1290 1
a1290 2
    return (0 < ap_bvputs(r->connection->client,
                       fieldname, ": ", fieldval, "\015\012", NULL));
d1325 1
a1325 2
    ap_bvputs(r->connection->client,
           protocol, " ", r->status_line, "\015\012", NULL);
d1410 3
a1412 3
    ap_table_do((int (*) (void *, const char *, const char *)) ap_send_header_field,
             (void *) r, r->headers_in, NULL);
    ap_bputs("\015\012", r->connection->client);
d1459 78
d1561 14
d1655 1
a1655 1
        ap_bputs("0\015\012", r->connection->client);
d1657 1
a1657 1
        ap_bputs("\015\012", r->connection->client);
d1766 3
a1768 4
        ap_bvputs(r->connection->client,
               SERVER_PROTOCOL, " ", status_lines[0], "\015\012\015\012",
               NULL);
        ap_bflush(r->connection->client);
d1778 1
a1778 1
    while (isxdigit(*b)) {
d1856 1
a1856 1
            || !isxdigit(*buffer)) {
d1975 4
a1978 2
    /* If we are discarding the request body, then we must already know
     * the final status code, therefore disable the sending of 100 continue.
d1980 1
a1980 3
    r->expecting_100 = 0;

    if (ap_should_client_block(r)) {
d1983 4
d2035 2
a2036 2
                ap_reset_timeout(r);   /* reset timeout after successful write */
		total_bytes_sent += w;
d2041 1
a2041 5
                if (r->connection->aborted)
                    break;
                else if (errno == EAGAIN)
                    continue;
                else {
a2045 1
                    break;
d2047 1
d2077 1
d2079 1
d2081 1
a2081 1
#ifndef WIN32
d2122 1
d2124 5
a2128 2
            ap_bflush(r->connection->client);
            if (r->connection->aborted)
d2130 1
a2144 1

a2145 1
        total_bytes_sent += n;
d2150 2
a2151 2
                ap_reset_timeout(r);       /* reset timeout after successful
                                         * write */
d2156 1
a2156 5
                if (r->connection->aborted)
                    break;
                else if (errno == EAGAIN)
                    continue;
                else {
d2158 1
a2158 1
                     "client stopped connection before send body completed");
a2160 1
                    break;
d2162 1
d2211 1
a2211 1
                ap_reset_timeout(r);   /* reset timeout after successful write */
d2217 1
a2217 5
                if (r->connection->aborted)
                    break;
                else if (errno == EAGAIN)
                    continue;
                else {
d2219 1
a2219 1
                     "client stopped connection before send mmap completed");
a2221 1
                    break;
d2223 1
d2237 10
a2246 1
    ap_bputc(c, r->connection->client);
d2257 1
d2259 9
d2275 1
d2277 2
a2278 1
        return EOF;
d2280 31
d2321 2
a2322 1
        return EOF;
d2326 10
d2359 7
a2365 1
            return -1;
d2377 10
a2386 1
    return ap_bflush(r->connection->client);
a2396 1
    BUFF *fd = r->connection->client;
d2402 8
d2461 8
a2468 3
        if (location && *location
            && (ap_is_HTTP_REDIRECT(status) || status == HTTP_CREATED))
            ap_table_setn(r->headers_out, "Location", location);
d2483 1
d2504 1
a2504 1
            ap_bputs(custom_response + 1, fd);
d2507 1
d2517 2
a2518 2
        char *title = status_lines[idx];
        char *h1;
d2537 2
a2538 2
        ap_bvputs(fd,
                  "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n"
d2547 1
a2547 1
	    ap_bvputs(fd, "The document has moved <A HREF=\"",
d2552 1
a2552 1
	    ap_bvputs(fd, "The answer to your request is located <A HREF=\"",
d2557 1
a2557 1
	    ap_bvputs(fd, "This resource is only accessible "
d2565 6
a2570 6
	    ap_bputs("This server could not verify that you\n", fd);
	    ap_bputs("are authorized to access the document you\n", fd);
	    ap_bputs("requested.  Either you supplied the wrong\n", fd);
	    ap_bputs("credentials (e.g., bad password), or your\n", fd);
	    ap_bputs("browser doesn't understand how to supply\n", fd);
	    ap_bputs("the credentials required.<P>\n", fd);
d2573 2
a2574 2
	    ap_bputs("Your browser sent a request that\n", fd);
	    ap_bputs("this server could not understand.<P>\n", fd);
d2576 1
a2576 1
		ap_bvputs(fd, error_notes, "<P>\n", NULL);
d2580 1
a2580 1
	    ap_bvputs(fd, "You don't have permission to access ",
d2585 1
a2585 1
	    ap_bvputs(fd, "The requested URL ",
d2590 1
a2590 1
	    ap_bvputs(fd, "The requested method ", r->method,
d2596 1
a2596 1
	    ap_bvputs(fd,
d2606 1
a2606 1
		    ap_bputs(list, fd);
d2610 1
a2610 1
	    ap_bvputs(fd, "A request of the requested method ", r->method,
d2613 1
a2613 1
		ap_bvputs(fd, error_notes, "<P>\n", NULL);
d2617 1
a2617 1
	    ap_bvputs(fd, "The precondition on the request for the URL ",
d2622 1
a2622 1
	    ap_bvputs(fd, ap_escape_html(r->pool, r->method), " to ",
d2626 1
a2626 1
		ap_bvputs(fd, error_notes, "<P>\n", NULL);
d2630 5
a2634 2
	    ap_bputs("The proxy server received an invalid\015\012", fd);
	    ap_bputs("response from an upstream server.<P>\015\012", fd);
d2637 1
a2637 1
	    ap_bvputs(fd, "A variant for the requested resource\n<PRE>\n",
d2643 1
a2643 1
	    ap_bputs("I'm tired of waiting for your request.\n", fd);
d2646 1
a2646 1
	    ap_bvputs(fd, "The requested resource<BR>",
d2654 1
a2654 1
	    ap_bvputs(fd, "The requested resource<BR>",
d2661 2
a2662 2
	    ap_bputs("The requested URL's length exceeds the capacity\n"
	             "limit for this server.<P>\n", fd);
d2664 1
a2664 1
		ap_bvputs(fd, error_notes, "<P>\n", NULL);
d2668 2
a2669 2
	    ap_bputs("The supplied request data is not in a format\n"
	             "acceptable for processing by this resource.\n", fd);
d2672 1
a2672 1
	    ap_bputs("None of the range-specifier values in the Range\n"
d2674 1
a2674 1
	             "of the selected resource.\n", fd);
d2677 1
a2677 1
	    ap_bvputs(fd, "The expectation given in the Expect request-header"
d2685 1
a2685 1
	    ap_bputs("The server understands the media type of the\n"
d2687 1
a2687 1
	             "contained instructions.\n", fd);
d2690 1
a2690 1
	    ap_bputs("The requested resource is currently locked.\n"
d2692 1
a2692 1
	             "given before the method can be applied.\n", fd);
d2695 1
a2695 1
	    ap_bputs("The method could not be performed on the resource\n"
d2697 1
a2697 1
	             "action and that other action failed.\n", fd);
d2700 1
a2700 1
	    ap_bputs("The method could not be performed on the resource\n"
d2704 1
a2704 1
	             "your storage allocation.\n", fd);
d2707 1
a2707 1
	    ap_bputs("The server is temporarily unable to service your\n"
d2709 1
a2709 1
	             "problems. Please try again later.\n", fd);
d2712 2
a2713 2
	    ap_bputs("The proxy server did not receive a timely response\n"
	             "from the upstream server.\n", fd);
d2716 2
a2717 2
	    ap_bputs("A mandatory extension policy in the request is not\n"
                     "accepted by the server for this resource.\n", fd);
d2720 14
a2733 1
	    ap_bvputs(fd, "The server encountered an internal error or\n"
d2743 1
d2754 1
a2754 1
	  *     ap_bvputs(fd, error_notes, "<P>\n", NULL);
d2761 1
a2761 1
            ap_bvputs(fd, "<P>Additionally, a ",
d2766 2
a2767 2
        ap_bputs(ap_psignature("<HR>\n", r), fd);
        ap_bputs("</BODY></HTML>\n", fd);
d2771 1
@


1.3
log
@Apache 1.3.4 merge
@
text
@d919 4
d1072 5
@


1.2
log
@Apache 1.3.3 merge + proxy_segv fix
@
text
@d2 1
a2 1
 * Copyright (c) 1995-1998 The Apache Group.  All rights reserved.
d308 1
a308 1
        !status_drops_connection(r->status) &&
d472 1
a472 1
API_EXPORT(void) ap_set_etag(request_rec *r)
d490 1
a490 1
    weak = (r->request_time - r->mtime > 1) ? "" : "W/";
d493 2
a494 2
	etag = ap_psprintf(r->pool,
		    "%s\"%lx-%lx-%lx\"", weak,
d504 44
d564 66
d791 3
a793 1
    if (!strcmp(r->method, "HEAD")) {
a794 1
        r->method_number = M_GET;
a795 16
    else if (!strcmp(r->method, "GET"))
        r->method_number = M_GET;
    else if (!strcmp(r->method, "POST"))
        r->method_number = M_POST;
    else if (!strcmp(r->method, "PUT"))
        r->method_number = M_PUT;
    else if (!strcmp(r->method, "DELETE"))
        r->method_number = M_DELETE;
    else if (!strcmp(r->method, "CONNECT"))
        r->method_number = M_CONNECT;
    else if (!strcmp(r->method, "OPTIONS"))
        r->method_number = M_OPTIONS;
    else if (!strcmp(r->method, "TRACE"))
        r->method_number = M_TRACE;
    else
        r->method_number = M_INVALID;   /* Will eventually croak. */
d1154 1
a1154 1
static char *status_lines[] = {
d1201 2
a1202 1
#define LEVEL_500 43
d1209 2
a1210 2
    "506 Variant Also Negotiates"
    "507 unused",
d1213 1
a1213 1
    "510 Not Extended",
d1336 16
a1351 7
                       (r->allowed & (1 << M_GET)) ? ", GET, HEAD" : "",
                       (r->allowed & (1 << M_POST)) ? ", POST" : "",
                       (r->allowed & (1 << M_PUT)) ? ", PUT" : "",
                       (r->allowed & (1 << M_DELETE)) ? ", DELETE" : "",
                       (r->allowed & (1 << M_OPTIONS)) ? ", OPTIONS" : "",
                       ", TRACE",
                       NULL);
d2405 1
a2405 1
	case NOT_IMPLEMENTED:
d2409 3
d2418 4
a2421 3
	    ap_bvputs(fd, "A variant for the requested entity  ",
		      ap_escape_html(r->pool, r->uri), " is itself a ",
		      "transparently negotiable resource.<P>\n", NULL);
d2475 12
d2508 16
a2523 4
	             "caused the error.<P>\n", NULL);
	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
		ap_bvputs(fd, error_notes, "<P>\n", NULL);
	    }
@


1.1
log
@Initial revision
@
text
@d554 11
a780 2
        /* XXX: should strip trailing whitespace as well */

d790 2
a792 1
    pool *p;
d859 17
d890 43
d968 1
d1062 2
a1063 1
#define LEVEL_200  2
d1071 2
a1072 1
#define LEVEL_300  9
d1075 1
a1075 1
    "302 Moved Temporarily",
d1079 3
a1081 1
#define LEVEL_400 15
d1098 9
a1106 1
#define LEVEL_500 31
d1113 5
a1117 1
    "506 Variant Also Varies"
d1531 1
a1531 1
    if (r->proto_num >= HTTP_VERSION(1,1)) {
d1743 5
d2222 171
a2392 126
        if ((error_notes = ap_table_get(r->notes, "error-notes"))) {
            ap_bputs(error_notes, fd);
        }
        else
            switch (status) {
            case REDIRECT:
            case MOVED:
                ap_bvputs(fd, "The document has moved <A HREF=\"",
                          ap_escape_html(r->pool, location), "\">here</A>.<P>\n", NULL);
                break;
            case HTTP_SEE_OTHER:
                ap_bvputs(fd, "The answer to your request is located <A HREF=\"",
                          ap_escape_html(r->pool, location), "\">here</A>.<P>\n", NULL);
                break;
            case HTTP_USE_PROXY:
                ap_bvputs(fd, "This resource is only accessible through the proxy\n",
                ap_escape_html(r->pool, location), "<BR>\nYou will need to ",
                     "configure your client to use that proxy.<P>\n", NULL);
                break;
            case HTTP_PROXY_AUTHENTICATION_REQUIRED:
            case AUTH_REQUIRED:
                ap_bputs("This server could not verify that you\n", fd);
                ap_bputs("are authorized to access the document you\n", fd);
                ap_bputs("requested.  Either you supplied the wrong\n", fd);
                ap_bputs("credentials (e.g., bad password), or your\n", fd);
                ap_bputs("browser doesn't understand how to supply\n", fd);
                ap_bputs("the credentials required.<P>\n", fd);
                break;
            case BAD_REQUEST:
                ap_bputs("Your browser sent a request that\n", fd);
                ap_bputs("this server could not understand.<P>\n", fd);
                break;
            case HTTP_FORBIDDEN:
                ap_bvputs(fd, "You don't have permission to access ",
                  ap_escape_html(r->pool, r->uri), "\non this server.<P>\n",
                          NULL);
                break;
            case NOT_FOUND:
                ap_bvputs(fd, "The requested URL ", ap_escape_html(r->pool, r->uri),
                          " was not found on this server.<P>\n", NULL);
                break;
            case METHOD_NOT_ALLOWED:
                ap_bvputs(fd, "The requested method ", r->method, " is not allowed "
                          "for the URL ", ap_escape_html(r->pool, r->uri),
                          ".<P>\n", NULL);
                break;
            case NOT_ACCEPTABLE:
                ap_bvputs(fd,
                 "An appropriate representation of the requested resource ",
                          ap_escape_html(r->pool, r->uri),
                          " could not be found on this server.<P>\n", NULL);
                /* fall through */
            case MULTIPLE_CHOICES:
                {
                    const char *list;
                    if ((list = ap_table_get(r->notes, "variant-list")))
                        ap_bputs(list, fd);
                }
                break;
            case LENGTH_REQUIRED:
                ap_bvputs(fd, "A request of the requested method ", r->method,
                          " requires a valid Content-length.<P>\n", NULL);
                break;
            case PRECONDITION_FAILED:
                ap_bvputs(fd, "The precondition on the request for the URL ",
                ap_escape_html(r->pool, r->uri), " evaluated to false.<P>\n",
                          NULL);
                break;
            case NOT_IMPLEMENTED:
                ap_bvputs(fd, ap_escape_html(r->pool, r->method), " to ",
                          ap_escape_html(r->pool, r->uri), " not supported.<P>\n", NULL);
                break;
            case BAD_GATEWAY:
                ap_bputs("The proxy server received an invalid\015\012", fd);
                ap_bputs("response from an upstream server.<P>\015\012", fd);
                break;
            case VARIANT_ALSO_VARIES:
                ap_bvputs(fd, "A variant for the requested entity  ",
                          ap_escape_html(r->pool, r->uri), " is itself a ",
                          "transparently negotiable resource.<P>\n", NULL);
                break;
            case HTTP_REQUEST_TIME_OUT:
                ap_bputs("I'm tired of waiting for your request.\n", fd);
                break;
            case HTTP_GONE:
                ap_bvputs(fd, "The requested resource<BR>",
                          ap_escape_html(r->pool, r->uri),
                          "<BR>\nis no longer available on this server ",
                          "and there is no forwarding address.\n",
                  "Please remove all references to this resource.\n", NULL);
                break;
            case HTTP_REQUEST_ENTITY_TOO_LARGE:
                ap_bvputs(fd, "The requested resource<BR>",
                          ap_escape_html(r->pool, r->uri), "<BR>\n",
                          "does not allow request data with ", r->method,
                          " requests, or the amount of data provided in\n",
                          "the request exceeds the capacity limit.\n", NULL);
                break;
            case HTTP_REQUEST_URI_TOO_LARGE:
                ap_bputs("The requested URL's length exceeds the capacity\n", fd);
                ap_bputs("limit for this server.\n", fd);
                break;
            case HTTP_UNSUPPORTED_MEDIA_TYPE:
                ap_bputs("The supplied request data is not in a format\n", fd);
                ap_bputs("acceptable for processing by this resource.\n", fd);
                break;
            case HTTP_SERVICE_UNAVAILABLE:
                ap_bputs("The server is temporarily unable to service your\n", fd);
                ap_bputs("request due to maintenance downtime or capacity\n", fd);
                ap_bputs("problems. Please try again later.\n", fd);
                break;
            case HTTP_GATEWAY_TIME_OUT:
                ap_bputs("The proxy server did not receive a timely response\n", fd);
                ap_bputs("from the upstream server.<P>\n", fd);
                break;
            default:            /* HTTP_INTERNAL_SERVER_ERROR */
                ap_bputs("The server encountered an internal error or\n", fd);
                ap_bputs("misconfiguration and was unable to complete\n", fd);
                ap_bputs("your request.<P>\n", fd);
                ap_bputs("Please contact the server administrator,\n ", fd);
                ap_bputs(ap_escape_html(r->pool, r->server->server_admin), fd);
                ap_bputs(" and inform them of the time the error occurred,\n", fd);
                ap_bputs("and anything you might have done that may have\n", fd);
                ap_bputs("caused the error.<P>\n", fd);
                break;
            }
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d16 23
a38 20
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 6
a55 7
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
a83 70
#ifdef CHARSET_EBCDIC
/* Save & Restore the current conversion settings
 * "input"  means: ASCII -> EBCDIC (when reading MIME Headers and PUT/POST data)
 * "output" means: EBCDIC -> ASCII (when sending MIME Headers and Chunks)
 */

#define PUSH_EBCDIC_INPUTCONVERSION_STATE(_buff, _onoff) \
        int _convert_in = ap_bgetflag(_buff, B_ASCII2EBCDIC); \
        ap_bsetflag(_buff, B_ASCII2EBCDIC, _onoff);

#define POP_EBCDIC_INPUTCONVERSION_STATE(_buff) \
        ap_bsetflag(_buff, B_ASCII2EBCDIC, _convert_in);

#define PUSH_EBCDIC_INPUTCONVERSION_STATE_r(_req, _onoff) \
        ap_bsetflag(_req->connection->client, B_ASCII2EBCDIC, _onoff);

#define POP_EBCDIC_INPUTCONVERSION_STATE_r(_req) \
        ap_bsetflag(_req->connection->client, B_ASCII2EBCDIC, _req->ebcdic.conv_in);

#define PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(_req, _onoff) \
        ap_bsetflag(_req->connection->client, B_EBCDIC2ASCII, _onoff);

#define POP_EBCDIC_OUTPUTCONVERSION_STATE_r(_req) \
        ap_bsetflag(_req->connection->client, B_EBCDIC2ASCII, _req->ebcdic.conv_out);

#endif /*CHARSET_EBCDIC*/

/*
 * Builds the content-type that should be sent to the client from the
 * content-type specified.  The following rules are followed:
 *    - if type is NULL, type is set to ap_default_type(r)
 *    - if charset adding is disabled, stop processing and return type.
 *    - then, if there are no parameters on type, add the default charset
 *    - return type
 */
static const char *make_content_type(request_rec *r, const char *type) {
    char *needcset[] = {
	"text/plain",
	"text/html",
	NULL };
    char **pcset;
    core_dir_config *conf = (core_dir_config *)ap_get_module_config(
	r->per_dir_config, &core_module);
    if (!type) type = ap_default_type(r);
    if (conf->add_default_charset != ADD_DEFAULT_CHARSET_ON) return type;

    if (ap_strcasestr(type, "charset=") != NULL) {
	/* already has parameter, do nothing */
	/* XXX we don't check the validity */
	;
    } else {
    	/* see if it makes sense to add the charset. At present,
	 * we only add it if the Content-type is one of needcset[]
	 */
	for (pcset = needcset; *pcset ; pcset++)
	    if (ap_strcasestr(type, *pcset) != NULL) {
		type = ap_pstrcat(r->pool, type, "; charset=", 
		    conf->add_default_charset_name, NULL);
		break;
	    }
    }
    return type;
}

enum byterange_token {
    BYTERANGE_OK,
    BYTERANGE_EMPTY,
    BYTERANGE_BADSYNTAX,
    BYTERANGE_UNSATISFIABLE
};
d85 1
a85 2
static enum byterange_token
    parse_byterange(request_rec *r, long *start, long *end)
d87 1
a87 1
    /* parsing first, semantics later */
d89 2
a90 2
    while (ap_isspace(*r->range))
        ++r->range;
d92 4
a95 3
    /* check for an empty range, which is OK */
    if (*r->range == '\0') {
	return BYTERANGE_EMPTY;
d97 8
a104 3
    else if (*r->range == ',') {
	++r->range;
	return BYTERANGE_EMPTY;
d107 2
a108 4
    if (ap_isdigit(*r->range))
	*start = ap_strtol(r->range, (char **)&r->range, 10);
    else
	*start = -1;
d110 2
a111 2
    while (ap_isspace(*r->range))
        ++r->range;
d113 2
a114 24
    if (*r->range != '-')
	return BYTERANGE_BADSYNTAX;
    ++r->range;

    while (ap_isspace(*r->range))
        ++r->range;

    if (ap_isdigit(*r->range))
	*end = ap_strtol(r->range, (char **)&r->range, 10);
    else
	*end = -1;

    while (ap_isspace(*r->range))
        ++r->range;

    /* check the end of the range */
    if (*r->range == ',') {
	++r->range;
    }
    else if (*r->range != '\0') {
	return BYTERANGE_BADSYNTAX;
    }

    /* parsing done; now check the numbers */
d116 1
a116 23
    if (*start < 0) { /* suffix-byte-range-spec */
	if (*end < 0) /* no numbers */
	    return BYTERANGE_BADSYNTAX;
	*start = r->clength - *end;
	if (*start < 0)
	    *start = 0;
	*end = r->clength - 1;
    }
    else {
	if (*end >= 0 && *start > *end) /* out-of-order range */
	    return BYTERANGE_BADSYNTAX;
	if (*end < 0 || *end >= r->clength)
	    *end = r->clength - 1;
    }
    /* RFC 2616 is somewhat unclear about what we should do if the end
     * is missing and the start is after the clength. The robustness
     * principle says we should accept it as an unsatisfiable range.
     * We accept suffix-byte-range-specs like -0 for the same reason.
     */
    if (*start >= r->clength)
	return BYTERANGE_UNSATISFIABLE;

    return BYTERANGE_OK;
d119 2
a120 44
/* If this function is called with output=1, it will spit out the
 * correct headers for a byterange chunk. If output=0 it will not
 * output anything but just return the number of bytes it would have
 * output. If start or end are less than 0 then it will do a byterange
 * chunk trailer instead of a header.
 */
static int byterange_boundary(request_rec *r, long start, long end, int output)
{
    int length = 0;

#ifdef CHARSET_EBCDIC
    /* determine current setting of conversion flag,
     * set to ON (protocol strings MUST be converted)
     * and reset to original setting before returning
     */
    PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(r, 1);
#endif /*CHARSET_EBCDIC*/

    if (start < 0 || end < 0) {
	if (output)
	    ap_rvputs(r, CRLF "--", r->boundary, "--" CRLF, NULL);
	else
	    length = 4 + strlen(r->boundary) + 4;
    }
    else {
	const char *ct = make_content_type(r, r->content_type);
	char ts[MAX_STRING_LEN];

	ap_snprintf(ts, sizeof(ts), "%ld-%ld/%ld", start, end, r->clength);
	if (output)
	    ap_rvputs(r, CRLF "--", r->boundary, CRLF "Content-type: ",
		      ct, CRLF "Content-range: bytes ", ts, CRLF CRLF,
		      NULL);
	else
	    length = 4 + strlen(r->boundary) + 16
		+ strlen(ct) + 23 + strlen(ts) + 4;
    }

#ifdef CHARSET_EBCDIC
    POP_EBCDIC_OUTPUTCONVERSION_STATE_r(r);
#endif /*CHARSET_EBCDIC*/

    return length;
}
d125 2
a126 3
    long length, start, end, one_start = 0, one_end = 0;
    int ranges, empty;
    
a145 1
    range += 6;
d147 2
a148 4
    /* Check the If-Range header for Etag or Date.
     * Note that this check will return false (as required) if either
     * of the two etags are weak.
     */
d152 1
a152 1
                (strcmp(if_range, match) != 0))
d156 1
a156 1
                 (strcmp(if_range, match) != 0))
d160 7
a166 35
    /*
     * Parse the byteranges, counting how many of them there are and
     * the total number of bytes we will send to the client. This is a
     * dummy run for the while(ap_each_byterange()) loop that the
     * caller will perform if we return 1.
     */
    r->range = range;
    r->boundary = ap_psprintf(r->pool, "%lx%lx",
			      r->request_time, (long) getpid());
    length = 0;
    ranges = 0;
    empty = 1;
    do {
	switch (parse_byterange(r, &start, &end)) {
	case BYTERANGE_UNSATISFIABLE:
	    empty = 0;
	    break;
	default:
	    /* be more defensive here? */
	case BYTERANGE_BADSYNTAX:
	    r->boundary = NULL;
	    r->range = NULL;
	    return 0;
	case BYTERANGE_EMPTY:
	    break;
	case BYTERANGE_OK:
	    ++ranges;
	    length += byterange_boundary(r, start, end, 0)
		+ end - start + 1;
	    /* save in case of unsatisfiable ranges */
	    one_start = start;
	    one_end = end;
	    break;
	}
    } while (*r->range != '\0');
a167 20
    if (ranges == 0) {
	/* no ranges or only unsatisfiable ranges */
	if (empty || if_range) {
	    r->boundary = NULL;
	    r->range = NULL;
	    return 0;
	}
	else {
	    ap_table_setn(r->headers_out, "Content-Range",
		ap_psprintf(r->pool, "bytes */%ld", r->clength));
	    ap_set_content_length(r, 0);			  
	    r->boundary = NULL;
	    r->range = range;
	    r->header_only = 1;
	    r->status = HTTP_RANGE_NOT_SATISFIABLE;
	    return 1;
	}
    }
    else if (ranges == 1) {
	/* simple handling of a single range -- no boundaries */
d170 3
a172 8
		one_start, one_end, r->clength));
	ap_table_setn(r->headers_out, "Content-Length",
	    ap_psprintf(r->pool, "%ld", one_end - one_start + 1));
	r->boundary = NULL;
	r->byterange = 1;
	r->range = range;
	r->status = PARTIAL_CONTENT;
	return 1;
d175 10
a184 8
	/* multiple ranges */
	length += byterange_boundary(r, -1, -1, 0);
	ap_table_setn(r->headers_out, "Content-Length",
	    ap_psprintf(r->pool, "%ld", length));
	r->byterange = 2;
	r->range = range;
	r->status = PARTIAL_CONTENT;
	return 1;
d186 5
d195 2
a196 1
    long start, end;
d198 55
a252 12
    do {
	if (parse_byterange(r, &start, &end) == BYTERANGE_OK) {
	    if (r->byterange > 1)
		byterange_boundary(r, start, end, 1);
	    *offset = start;
	    *length = end - start + 1;
	    return 1;
	}
    } while (*r->range != '\0');
    if (r->byterange > 1)
	byterange_boundary(r, -1, -1, 1);
    return 0;
d308 1
a308 1
        !ap_status_drops_connection(r->status) &&
d401 2
a402 2
     * AND the field value is not "*" (meaning match anything)
     * AND if our strong ETag does not match any entity tag in that field,
d406 2
a407 3
        if (if_match[0] != '*' &&
            (etag == NULL || etag[0] == 'W' ||
             !ap_find_list_item(r->pool, if_match, etag))) {
d428 6
a433 10
     * AND the field value is "*" (meaning match anything)
     *     OR our ETag matches any of the entity tags in that field, fail.
     *
     * If the request method was GET or HEAD, failure means the server
     *    SHOULD respond with a 304 (Not Modified) response.
     * For all other request methods, failure means the server MUST
     *    respond with a status of 412 (Precondition Failed).
     *
     * GET or HEAD allow weak etag comparison, all other methods require
     * strong comparison.  We can only use weak if it's not a range request.
d437 7
a443 19
        if (r->method_number == M_GET) {
            if (if_nonematch[0] == '*')
                return HTTP_NOT_MODIFIED;
            if (etag != NULL) {
                if (ap_table_get(r->headers_in, "Range")) {
                    if (etag[0] != 'W' &&
                        ap_find_list_item(r->pool, if_nonematch, etag)) {
                        return HTTP_NOT_MODIFIED;
                    }
                }
                else if (strstr(if_nonematch, etag)) {
                    return HTTP_NOT_MODIFIED;
                }
            }
        }
        else if (if_nonematch[0] == '*' ||
                 (etag != NULL &&
                  ap_find_list_item(r->pool, if_nonematch, etag))) {
            return HTTP_PRECONDITION_FAILED;
d472 1
a472 1
API_EXPORT(char *) ap_make_etag(request_rec *r, int force_weak)
a475 2
    core_dir_config *cfg;
    etag_components_t etag_bits;
a476 6
    cfg = (core_dir_config *)ap_get_module_config(r->per_dir_config,
                                                  &core_module);
    etag_bits = (cfg->etag_bits & (~ cfg->etag_remove)) | cfg->etag_add;
    if (etag_bits == ETAG_UNSET) {
        etag_bits = ETAG_BACKWARD;
    }
d490 1
a490 1
    weak = ((r->request_time - r->mtime > 1) && !force_weak) ? "" : "W/";
d493 5
a497 37
        char **ent;
        array_header *components;
        int i;

        /*
         * If it's a file (or we wouldn't be here) and no ETags
         * should be set for files, return an empty string and
         * note it for ap_send_header_field() to ignore.
         */
        if (etag_bits & ETAG_NONE) {
            ap_table_setn(r->notes, "no-etag", "omit");
            return "";
        }

        components = ap_make_array(r->pool, 4, sizeof(char *));
        if (etag_bits & ETAG_INODE) {
            ent = (char **) ap_push_array(components);
            *ent = ap_psprintf(r->pool, "%lx",
                               (unsigned long) r->finfo.st_ino);
        }
        if (etag_bits & ETAG_SIZE) {
            ent = (char **) ap_push_array(components);
            *ent = ap_psprintf(r->pool, "%lx",
                               (unsigned long) r->finfo.st_size);
        }
        if (etag_bits & ETAG_MTIME) {
            ent = (char **) ap_push_array(components);
            *ent = ap_psprintf(r->pool, "%lx", (unsigned long) r->mtime);
        }
        ent = (char **) components->elts;
        etag = ap_pstrcat(r->pool, weak, "\"", NULL);
        for (i = 0; i < components->nelts; ++i) {
            etag = ap_psprintf(r->pool, "%s%s%s", etag,
                               (i == 0 ? "" : "-"),
                               ent[i]);
        }
        etag = ap_pstrcat(r->pool, etag, "\"", NULL);
a503 44
    return etag;
}

API_EXPORT(void) ap_set_etag(request_rec *r)
{
    char *etag;
    char *variant_etag, *vlv;
    int vlv_weak;

    if (!r->vlist_validator) {
        etag = ap_make_etag(r, 0);
    }
    else {
        /* If we have a variant list validator (vlv) due to the
         * response being negotiated, then we create a structured
         * entity tag which merges the variant etag with the variant
         * list validator (vlv).  This merging makes revalidation
         * somewhat safer, ensures that caches which can deal with
         * Vary will (eventually) be updated if the set of variants is
         * changed, and is also a protocol requirement for transparent
         * content negotiation.
         */

        /* if the variant list validator is weak, we make the whole
         * structured etag weak.  If we would not, then clients could
         * have problems merging range responses if we have different
         * variants with the same non-globally-unique strong etag.
         */

        vlv = r->vlist_validator;
        vlv_weak = (vlv[0] == 'W');
               
        variant_etag = ap_make_etag(r, vlv_weak);

        /* merge variant_etag and vlv into a structured etag */

        variant_etag[strlen(variant_etag) - 1] = '\0';
        if (vlv_weak)
            vlv += 3;
        else
            vlv++;
        etag = ap_pstrcat(r->pool, variant_etag, ";", vlv, NULL);
    }

a519 66
/* Get the method number associated with the given string, assumed to
 * contain an HTTP method.  Returns M_INVALID if not recognized.
 *
 * This is the first step toward placing method names in a configurable
 * list.  Hopefully it (and other routines) can eventually be moved to
 * something like a mod_http_methods.c, complete with config stuff.
 */
API_EXPORT(int) ap_method_number_of(const char *method)
{
    switch (*method) {
        case 'H':
           if (strcmp(method, "HEAD") == 0)
               return M_GET;   /* see header_only in request_rec */
           break;
        case 'G':
           if (strcmp(method, "GET") == 0)
               return M_GET;
           break;
        case 'P':
           if (strcmp(method, "POST") == 0)
               return M_POST;
           if (strcmp(method, "PUT") == 0)
               return M_PUT;
           if (strcmp(method, "PATCH") == 0)
               return M_PATCH;
           if (strcmp(method, "PROPFIND") == 0)
               return M_PROPFIND;
           if (strcmp(method, "PROPPATCH") == 0)
               return M_PROPPATCH;
           break;
        case 'D':
           if (strcmp(method, "DELETE") == 0)
               return M_DELETE;
           break;
        case 'C':
           if (strcmp(method, "CONNECT") == 0)
               return M_CONNECT;
           if (strcmp(method, "COPY") == 0)
               return M_COPY;
           break;
        case 'M':
           if (strcmp(method, "MKCOL") == 0)
               return M_MKCOL;
           if (strcmp(method, "MOVE") == 0)
               return M_MOVE;
           break;
        case 'O':
           if (strcmp(method, "OPTIONS") == 0)
               return M_OPTIONS;
           break;
        case 'T':
           if (strcmp(method, "TRACE") == 0)
               return M_TRACE;
           break;
        case 'L':
           if (strcmp(method, "LOCK") == 0)
               return M_LOCK;
           break;
        case 'U':
           if (strcmp(method, "UNLOCK") == 0)
               return M_UNLOCK;
           break;
    }
    return M_INVALID;
}

d533 1
a533 1
API_EXPORT(int) ap_getline(char *s, int n, BUFF *in, int fold)
a537 11
#ifdef CHARSET_EBCDIC
    /* When ap_getline() is called, the HTTP protocol is in a state
     * where we MUST be reading "plain text" protocol stuff,
     * (Request line, MIME headers, Chunk sizes) regardless of
     * the MIME type and conversion setting of the document itself.
     * Save the current setting of the ASCII-EBCDIC conversion flag
     * for uploads, then temporarily set it to ON
     * (and restore it before returning).
     */
    PUSH_EBCDIC_INPUTCONVERSION_STATE(in, 1);
#endif /*CHARSET_EBCDIC*/
d544 2
a545 4
        if (retval <= 0) {
            total = ((retval < 0) && (total == 0)) ? -1 : total;
            break;
        }
a553 11
            /*
             * Trim any extra trailing spaces or tabs except for the first
             * space or tab at the beginning of a blank string.  This makes
             * it much easier to check field values for exact matches, and
             * saves memory as well.  Terminate string at end of line.
             */
            while (pos > (s + 1) && (*(pos - 1) == ' ' || *(pos - 1) == '\t')) {
                --pos;          /* trim extra trailing spaces or tabs      */
                --total;        /* but not one at the beginning of line    */
                ++n;
            }
d559 1
a559 1
            break;       /* if not, input line exceeded buffer size */
a568 5
#ifdef CHARSET_EBCDIC
    /* restore ASCII->EBCDIC conversion state */
    POP_EBCDIC_INPUTCONVERSION_STATE(in);
#endif /*CHARSET_EBCDIC*/

d612 4
d629 1
a629 1
    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* ap_getline's two extra for \n\0 */
d633 2
a634 2
    unsigned int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
    int len, n;
d651 1
a651 1
    while ((len = ap_getline(l, sizeof(l), conn->client, 0)) <= 0) {
a653 4
	    /* this is a hack to make sure that request time is set,
	     * it's not perfect, but it's better than nothing 
	     */
	    r->request_time = time(0);
d670 1
a670 3

    r->method_number = ap_method_number_of(r->method);
    if (r->method_number == M_GET && r->method[0] == 'H') {
d672 1
d674 16
d693 1
a693 1
    /* ap_getline returns (size of max buffer - 1) if it fills up the
d707 1
a707 1
    if (2 == sscanf(r->protocol, "HTTP/%u.%u%n", &major, &minor, &n)
d710 1
a710 1
    else {
a711 16
	n = 0;
    }

    /* Check for a valid protocol, and disallow everything but whitespace
     * after the protocol string */
    while (ap_isspace(r->protocol[n]))
        ++n;
    if (r->protocol[n] != '\0') {
        r->status    = HTTP_BAD_REQUEST;
        r->proto_num = HTTP_VERSION(1,0);
        r->protocol  = ap_pstrdup(r->pool, "HTTP/1.0");
        ap_table_setn(r->notes, "error-notes",
                      "The request line contained invalid characters "
                      "following the protocol string.<P>\n");
        return 0;
    }
d718 1
a718 1
    char field[DEFAULT_LIMIT_REQUEST_FIELDSIZE + 2]; /* ap_getline's two extra */
d723 1
a723 1
    int fields_read = 0;
d733 1
a733 1
    while ((len = ap_getline(field, sizeof(field), c->client, 1)) > 0) {
d743 1
a743 1
        /* ap_getline returns (size of max buffer - 1) if it fills up the
d751 1
a751 1
                "<PRE>\n", ap_escape_html(r->pool, field), "</PRE>\n", NULL));
d761 1
a761 1
                "<PRE>\n", ap_escape_html(r->pool, copy), "</PRE>\n", NULL));
d770 2
d778 1
a778 1
API_EXPORT(request_rec *) ap_read_request(conn_rec *conn)
d781 1
a782 2
    const char *expect;
    int access_status;
d815 1
a815 2
    ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, r->ebcdic.conv_in  = 1);
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
d828 1
a828 8
            ap_log_transaction(r);
            return r;
        }
        else if (r->status == HTTP_BAD_REQUEST) {
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                         "request failed: erroneous characters after protocol string: %s",
			 ap_escape_logitem(r->pool, r->the_request));
            ap_send_error_response(r, 0);
d842 1
a848 16

        if (r->header_only) {
            /*
             * Client asked for headers only with HTTP/0.9, which doesn't send
             * headers! Have to dink things just to make sure the error message
             * comes through...
             */
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                          "client sent invalid HTTP/0.9 request: HEAD %s",
                          r->uri);
            r->header_only = 0;
            r->status = HTTP_BAD_REQUEST;
            ap_send_error_response(r, 0);
            ap_log_transaction(r);
            return r;
        }
d854 1
a854 1
     * now read. may update status.
a862 21
    if ((!r->hostname && (r->proto_num >= HTTP_VERSION(1,1))) ||
        ((r->proto_num == HTTP_VERSION(1,1)) &&
         !ap_table_get(r->headers_in, "Host"))) {
        /*
         * Client sent us an HTTP/1.1 or later request without telling us the
         * hostname, either with a full URL or a Host: header. We therefore
         * need to (as per the 1.1 spec) send an error.  As a special case,
         * HTTP/1.1 mentions twice (S9, S14.23) that a request MUST contain
         * a Host: header, and the server MUST respond with 400 if it doesn't.
         */
        r->status = HTTP_BAD_REQUEST;
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
                      "client sent HTTP/1.1 request without hostname "
                      "(see RFC2616 section 14.23): %s", r->uri);
    }
    if (r->status != HTTP_OK) {
        ap_send_error_response(r, 0);
        ap_log_transaction(r);
        return r;
    }

a868 23
    if (((expect = ap_table_get(r->headers_in, "Expect")) != NULL) &&
        (expect[0] != '\0')) {
        /*
         * The Expect header field was added to HTTP/1.1 after RFC 2068
         * as a means to signal when a 100 response is desired and,
         * unfortunately, to signal a poor man's mandatory extension that
         * the server must understand or return 417 Expectation Failed.
         */
        if (strcasecmp(expect, "100-continue") == 0) {
            r->expecting_100 = 1;
        }
        else {
            r->status = HTTP_EXPECTATION_FAILED;
            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, r,
                          "client sent an unrecognized expectation value of "
                          "Expect: %s", expect);
            ap_send_error_response(r, 0);
            (void) ap_discard_request_body(r);
            ap_log_transaction(r);
            return r;
        }
    }

d879 1
a879 1
API_EXPORT(void) ap_set_sub_req_protocol(request_rec *rnew, const request_rec *r)
a897 1
    rnew->expecting_100   = r->expecting_100;
d904 1
a904 1
API_EXPORT(void) ap_finalize_sub_req_protocol(request_rec *sub)
d927 1
a927 2
                  r->proxyreq == STD_PROXY ? "Proxy-Authenticate"
		      : "WWW-Authenticate",
d935 1
a935 2
	    r->proxyreq == STD_PROXY ? "Proxy-Authenticate"
		  : "WWW-Authenticate",
d943 2
a944 3
					 r->proxyreq == STD_PROXY
					 ? "Proxy-Authorization"
					 : "Authorization");
d969 1
a969 7
    /* No CHARSET_EBCDIC Issue here because the line has already
     * been converted to native text.
     */
    while (*auth_line== ' ' || *auth_line== '\t')
        auth_line++;

    t = ap_pbase64decode(r->pool, auth_line);
d988 1
a988 10
#ifdef UTS21
/* The second const triggers an assembler bug on UTS 2.1.
 * Another workaround is to move some code out of this file into another,
 *   but this is easier.  Dave Dykstra, 3/31/99 
 */
static const char * status_lines[RESPONSE_CODES] =
#else
static const char * const status_lines[RESPONSE_CODES] =
#endif
{
d991 1
a991 2
    "102 Processing",
#define LEVEL_200  3
d999 1
a999 2
    "207 Multi-Status",
#define LEVEL_300 11
d1002 1
a1002 1
    "302 Found",
d1006 1
a1006 3
    "306 unused",
    "307 Temporary Redirect",
#define LEVEL_400 19
d1023 1
a1023 10
    "416 Requested Range Not Satisfiable",
    "417 Expectation Failed",
    "418 unused",
    "419 unused",
    "420 unused",
    "421 unused",
    "422 Unprocessable Entity",
    "423 Locked",
    "424 Failed Dependency",
#define LEVEL_500 44
d1030 1
a1030 5
    "506 Variant Also Negotiates",
    "507 Insufficient Storage",
    "508 unused",
    "509 unused",
    "510 Not Extended"
d1067 1
a1067 2
                                            const char *fieldname,
                                            const char *fieldval)
d1069 2
a1070 6
    if (strcasecmp(fieldname, "ETag") == 0) {
        if (ap_table_get(r->notes, "no-etag") != NULL) {
            return 1;
        }
    }
    return (0 < ap_rvputs(r, fieldname, ": ", fieldval, CRLF, NULL));
d1076 3
d1086 2
a1087 1
    /* kluge around broken browsers when indicated by force-response-1.0
d1089 3
a1091 2
    if (r->proto_num == HTTP_VERSION(1,0)
       && ap_table_get(r->subprocess_env, "force-response-1.0")) {
d1100 1
a1100 1
    PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(r, 1);
d1103 4
a1106 2
    /* output the HTTP/1.x Status-Line */
    ap_rvputs(r, protocol, " ", r->status_line, CRLF, NULL);
a1107 1
    /* output the date header */
d1109 1
a1110 13
    /* keep the set-by-proxy server header, otherwise
     * generate a new server header */
    if (r->proxyreq) {
        const char *server = ap_table_get(r->headers_out, "Server");
        if (server) {
            ap_send_header_field(r, "Server", server);
        }
    }
    else {
        ap_send_header_field(r, "Server", ap_get_server_version());
    }

    /* unset so we don't send them again */
d1114 2
a1115 1
    POP_EBCDIC_OUTPUTCONVERSION_STATE_r(r);
d1142 1
a1142 1
        ap_bputs("X-Pad: avoid browser bug" CRLF, client);
d1144 1
a1144 1
    ap_bputs(CRLF, client);  /* Send the terminating empty line */
d1153 7
a1159 16
                   (r->allowed & (1 << M_GET))       ? ", GET, HEAD" : "",
                   (r->allowed & (1 << M_POST))      ? ", POST"      : "",
                   (r->allowed & (1 << M_PUT))       ? ", PUT"       : "",
                   (r->allowed & (1 << M_DELETE))    ? ", DELETE"    : "",
                   (r->allowed & (1 << M_CONNECT))   ? ", CONNECT"   : "",
                   (r->allowed & (1 << M_OPTIONS))   ? ", OPTIONS"   : "",
                   (r->allowed & (1 << M_PATCH))     ? ", PATCH"     : "",
                   (r->allowed & (1 << M_PROPFIND))  ? ", PROPFIND"  : "",
                   (r->allowed & (1 << M_PROPPATCH)) ? ", PROPPATCH" : "",
                   (r->allowed & (1 << M_MKCOL))     ? ", MKCOL"     : "",
                   (r->allowed & (1 << M_COPY))      ? ", COPY"      : "",
                   (r->allowed & (1 << M_MOVE))      ? ", MOVE"      : "",
                   (r->allowed & (1 << M_LOCK))      ? ", LOCK"      : "",
                   (r->allowed & (1 << M_UNLOCK))    ? ", UNLOCK"    : "",
                   ", TRACE",
                   NULL);
a1176 4
#ifdef CHARSET_EBCDIC
    /* Server-generated response, converted */
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
#endif
d1180 1
a1180 1
    ap_rvputs(r, r->the_request, CRLF, NULL);
d1182 3
a1184 3
    ap_table_do((int (*) (void *, const char *, const char *))
                ap_send_header_field, (void *) r, r->headers_in, NULL);
    ap_rputs(CRLF, r);
d1190 1
a1190 1
API_EXPORT(int) ap_send_http_options(request_rec *r)
a1230 78
/* This routine is called by ap_table_do and merges all instances of
 * the passed field values into a single array that will be further
 * processed by some later routine.  Originally intended to help split
 * and recombine multiple Vary fields, though it is generic to any field
 * consisting of comma/space-separated tokens.
 */
static int uniq_field_values(void *d, const char *key, const char *val)
{
    array_header *values;
    char *start;
    char *e;
    char **strpp;
    int  i;

    values = (array_header *)d;

    e = ap_pstrdup(values->pool, val);

    do {
        /* Find a non-empty fieldname */

        while (*e == ',' || ap_isspace(*e)) {
            ++e;
        }
        if (*e == '\0') {
            break;
        }
        start = e;
        while (*e != '\0' && *e != ',' && !ap_isspace(*e)) {
            ++e;
        }
        if (*e != '\0') {
            *e++ = '\0';
        }

        /* Now add it to values if it isn't already represented.
         * Could be replaced by a ap_array_strcasecmp() if we had one.
         */
        for (i = 0, strpp = (char **) values->elts; i < values->nelts;
             ++i, ++strpp) {
            if (*strpp && strcasecmp(*strpp, start) == 0) {
                break;
            }
        }
        if (i == values->nelts) {  /* if not found */
           *(char **)ap_push_array(values) = start;
        }
    } while (*e != '\0');

    return 1;
}

/*
 * Since some clients choke violently on multiple Vary fields, or
 * Vary fields with duplicate tokens, combine any multiples and remove
 * any duplicates.
 */
static void fixup_vary(request_rec *r)
{
    array_header *varies;

    varies = ap_make_array(r->pool, 5, sizeof(char *));

    /* Extract all Vary fields from the headers_out, separate each into
     * its comma-separated fieldname values, and then add them to varies
     * if not already present in the array.
     */
    ap_table_do((int (*)(void *, const char *, const char *))uniq_field_values,
		(void *) varies, r->headers_out, "Vary", NULL);

    /* If we found any, replace old Vary fields with unique-ified value */

    if (varies->nelts > 0) {
	ap_table_setn(r->headers_out, "Vary",
		      ap_array_pstrcat(r->pool, varies, ','));
    }
}

a1234 1

d1236 1
a1236 2
    /* Use previously determined conversion (output): */
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, ap_checkconv(r));
a1254 14
    /*
     * Remove the 'Vary' header field if the client can't handle it.
     * Since this will have nasty effects on HTTP/1.1 caches, force
     * the response into HTTP/1.0 mode.
     */
    if (ap_table_get(r->subprocess_env, "force-no-vary") != NULL) {
	ap_table_unset(r->headers_out, "Vary");
	r->proto_num = HTTP_VERSION(1,0);
	ap_table_set(r->subprocess_env, "force-response-1.0", "1");
    }
    else {
	fixup_vary(r);
    }

d1260 1
a1260 1
    PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(r, 1);
d1274 4
a1277 2
    else ap_table_setn(r->headers_out, "Content-Type", make_content_type(r, 
	r->content_type));
d1315 2
a1316 1
    POP_EBCDIC_OUTPUTCONVERSION_STATE_r(r);
a1327 3
#ifdef CHARSET_EBCDIC
        PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(r, 1);
#endif
d1335 1
a1335 1
        ap_rputs("0" CRLF, r);
d1337 1
a1337 1
        ap_rputs(CRLF, r);
a1338 4

#ifdef CHARSET_EBCDIC
        POP_EBCDIC_OUTPUTCONVERSION_STATE_r(r);
#endif /*CHARSET_EBCDIC*/
a1406 1
        int conversion_error = 0;
d1410 1
a1410 11

        if (*pos == '\0') {
            char *endstr;
            errno = 0;
            r->remaining = ap_strtol(lenp, &endstr, 10);
            if (errno || (endstr && *endstr)) {
                conversion_error = 1;
            }
        }

        if (*pos != '\0' || conversion_error) {
d1412 1
a1412 1
                        "Invalid Content-Length");
d1415 2
d1427 1
a1427 2
    if (max_body && ((unsigned long)r->remaining > max_body)
                 && (r->remaining >= 0)) {
a1433 10
#ifdef CHARSET_EBCDIC
    {
        /* Determine the EBCDIC conversion for the uploaded content
         * by looking at the Content-Type MIME header. 
         * If no Content-Type header is found, text conversion is assumed.
         */
        ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, ap_checkconv_in(r));
    }
#endif

d1444 1
a1444 1
    if (r->expecting_100 && r->proto_num >= HTTP_VERSION(1,1)) {
d1446 4
a1449 3
        ap_rvputs(r, SERVER_PROTOCOL, " ", status_lines[0], CRLF CRLF,
                  NULL);
        ap_rflush(r);
d1455 1
a1455 1
API_EXPORT(long) ap_get_chunk_size(char *b)
a1457 6
    long chunkbits = sizeof(long) * 8;

    /* Skip leading zeros */
    while (*b == '0') {
        ++b;
    }
d1459 1
a1459 1
    while (ap_isxdigit(*b) && (chunkbits > 0)) {
d1462 1
a1462 1
        if (*b >= '0' && *b <= '9') {
d1464 1
a1464 2
        }
        else if (*b >= 'A' && *b <= 'F') {
d1466 1
a1466 2
        }
        else if (*b >= 'a' && *b <= 'f') {
a1467 1
        }
a1469 1
        chunkbits -= 4;
a1471 4
    if (ap_isxdigit(*b) && (chunkbits <= 0)) {
        /* overflow */
        return -1;
    }
d1525 1
a1525 2
    if (max_body && ((unsigned long) r->read_length > max_body)
                 && (r->read_length >= 0)) {
d1535 1
a1535 1
        chunk_start = ap_getline(buffer, bufsiz, r->connection->client, 0);
d1537 1
a1537 1
            || !ap_isxdigit(*buffer)) {
d1542 1
a1542 1
        len_to_read = ap_get_chunk_size(buffer);
a1554 4
        else if (len_to_read < 0) {
            r->connection->keepalive = -1;
            return -1;
        }
d1576 1
a1576 1
                  ap_getline(buffer, bufsiz, r->connection->client, 1)) > 0)) {
a1618 5
#ifdef CHARSET_EBCDIC
        /* Chunk end is Protocol stuff! Set conversion = 1 to read CR LF: */
        PUSH_EBCDIC_INPUTCONVERSION_STATE_r(r, 1);
#endif /*CHARSET_EBCDIC*/

a1621 6

#ifdef CHARSET_EBCDIC
        /* restore ASCII->EBCDIC conversion state */
        POP_EBCDIC_INPUTCONVERSION_STATE_r(r);
#endif /*CHARSET_EBCDIC*/

d1656 1
a1656 6
    /* In order to avoid sending 100 Continue when we already know the
     * final response status, and yet not kill the connection if there is
     * no request body to be read, we need to duplicate the test from
     * ap_should_client_block() here negated rather than call it directly.
     */
    if ((r->read_length == 0) && (r->read_chunked || (r->remaining > 0))) {
a1658 4
        if (r->expecting_100) {
            r->connection->keepalive = -1;
            return OK;
        }
d1707 2
a1708 2
                ap_reset_timeout(r); /* reset timeout after successful write */
                total_bytes_sent += w;
d1713 5
a1717 1
                if (!r->connection->aborted) {
d1722 1
a1723 1
                break;
a1746 3
#ifdef TPF
    struct timeval tv;
#endif 
a1752 1
#ifndef TPF_NO_NONSOCKET_SELECT
a1753 1
#endif
d1755 1
a1755 1
#ifdef CHECK_FD_SETSIZE
a1795 1

d1797 2
a1798 5
            if (ap_bflush(r->connection->client) < 0) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                    "client stopped connection before send body completed");
                ap_bsetflag(r->connection->client, B_EOUT, 1);
                r->connection->aborted = 1;
a1799 1
            }
a1804 5
#ifdef TPF_HAVE_NONSOCKET_SELECT
            tv.tv_sec =  1;
            tv.tv_usec = 0;
            ap_select(fd + 1, &fds, NULL, NULL, &tv);
#else
a1805 1
#endif  
d1814 1
d1816 1
d1821 2
a1822 2
                ap_reset_timeout(r); /* reset timeout after successful write */
                total_bytes_sent += w;
d1827 5
a1831 1
                if (!r->connection->aborted) {
d1833 1
a1833 1
                       "client stopped connection before send body completed");
d1836 1
a1837 1
                break;
d1886 1
a1886 1
                ap_reset_timeout(r); /* reset timeout after successful write */
d1892 5
a1896 1
                if (!r->connection->aborted) {
d1898 1
a1898 1
                       "client stopped connection before send mmap completed");
d1901 1
a1902 1
                break;
d1916 1
a1916 10

    if (ap_bputc(c, r->connection->client) < 0) {
        if (!r->connection->aborted) {
            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                "client stopped connection before rputc completed");
            ap_bsetflag(r->connection->client, B_EOUT, 1);
            r->connection->aborted = 1;
        }
        return EOF;
    }
a1926 1
    
a1927 9
    if (rcode < 0) {
        if (!r->connection->aborted) {
            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                "client stopped connection before rputs completed");
            ap_bsetflag(r->connection->client, B_EOUT, 1);
            r->connection->aborted = 1;
        }
        return EOF;
    }
a1934 1

d1936 1
a1936 2
        return -1;

a1937 9
    if (n < 0) {
        if (!r->connection->aborted) {
            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                "client stopped connection before rwrite completed");
            ap_bsetflag(r->connection->client, B_EOUT, 1);
            r->connection->aborted = 1;
        }
        return -1;
    }
d1942 1
a1942 23
API_EXPORT(int) ap_vrprintf(request_rec *r, const char *fmt, va_list ap)
{
    int n;

    if (r->connection->aborted)
        return -1;

    n = ap_vbprintf(r->connection->client, fmt, ap);

    if (n < 0) {
        if (!r->connection->aborted) {
            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                "client stopped connection before vrprintf completed");
            ap_bsetflag(r->connection->client, B_EOUT, 1);
            r->connection->aborted = 1;
        }
        return -1;
    }
    SET_BYTES_SENT(r);
    return n;
}

API_EXPORT_NONSTD(int) ap_rprintf(request_rec *r, const char *fmt,...)
d1948 1
a1948 2
        return -1;

a1951 10

    if (n < 0) {
        if (!r->connection->aborted) {
            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                "client stopped connection before rprintf completed");
            ap_bsetflag(r->connection->client, B_EOUT, 1);
            r->connection->aborted = 1;
        }
        return -1;
    }
d1975 1
a1975 7
            if (!r->connection->aborted) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                    "client stopped connection before rvputs completed");
                ap_bsetflag(r->connection->client, B_EOUT, 1);
                r->connection->aborted = 1;
            }
            return EOF;
d1987 1
a1987 10
    if (ap_bflush(r->connection->client) < 0) {
        if (!r->connection->aborted) {
            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
                "client stopped connection before rflush completed");
            ap_bsetflag(r->connection->client, B_EOUT, 1);
            r->connection->aborted = 1;
        }
        return EOF;
    }
    return 0;
d1996 1
a1996 1
API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
d1998 1
a2002 4
#ifdef CHARSET_EBCDIC
    /* Error Responses (builtin / string literal / redirection) are TEXT! */
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
#endif
a2003 8
    /*
     * It's possible that the Location field might be in r->err_headers_out
     * instead of r->headers_out; use the latter if possible, else the
     * former.
     */
    if (location == NULL) {
	location = ap_table_get(r->err_headers_out, "Location");
    }
d2055 3
a2057 8
        if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {
            if ((location != NULL) && *location) {
	        ap_table_setn(r->headers_out, "Location", location);
            }
            else {
                location = "";   /* avoids coredump when printing, below */
            }
        }
d2063 1
a2063 1
        r->content_type = "text/html; charset=iso-8859-1";
a2071 1
            ap_rflush(r);
a2075 5
#ifdef CHARSET_EBCDIC
    /* Server-generated response, converted */
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
#endif

d2092 1
a2092 1
            ap_rputs(custom_response + 1, r);
a2094 1
            ap_rflush(r);
d2104 2
a2105 2
        const char *title = status_lines[idx];
        const char *h1;
d2124 2
a2125 2
        ap_rvputs(r,
                  DOCTYPE_HTML_2_0
d2130 126
a2255 216
	switch (status) {
	case HTTP_MOVED_PERMANENTLY:
	case HTTP_MOVED_TEMPORARILY:
	case HTTP_TEMPORARY_REDIRECT:
	    ap_rvputs(r, "The document has moved <A HREF=\"",
		      ap_escape_html(r->pool, location), "\">here</A>.<P>\n",
		      NULL);
	    break;
	case HTTP_SEE_OTHER:
	    ap_rvputs(r, "The answer to your request is located <A HREF=\"",
		      ap_escape_html(r->pool, location), "\">here</A>.<P>\n",
		      NULL);
	    break;
	case HTTP_USE_PROXY:
	    ap_rvputs(r, "This resource is only accessible "
		      "through the proxy\n",
		      ap_escape_html(r->pool, location),
		      "<BR>\nYou will need to ",
		      "configure your client to use that proxy.<P>\n", NULL);
	    break;
	case HTTP_PROXY_AUTHENTICATION_REQUIRED:
	case AUTH_REQUIRED:
	    ap_rputs("This server could not verify that you\n"
	             "are authorized to access the document\n"
	             "requested.  Either you supplied the wrong\n"
	             "credentials (e.g., bad password), or your\n"
	             "browser doesn't understand how to supply\n"
	             "the credentials required.<P>\n", r);
	    break;
	case BAD_REQUEST:
	    ap_rputs("Your browser sent a request that "
	             "this server could not understand.<P>\n", r);
	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
		ap_rvputs(r, error_notes, "<P>\n", NULL);
	    }
	    break;
	case HTTP_FORBIDDEN:
	    ap_rvputs(r, "You don't have permission to access ",
		      ap_escape_html(r->pool, r->uri),
		      "\non this server.<P>\n", NULL);
	    break;
	case NOT_FOUND:
	    ap_rvputs(r, "The requested URL ",
		      ap_escape_html(r->pool, r->uri),
		      " was not found on this server.<P>\n", NULL);
	    break;
	case METHOD_NOT_ALLOWED:
	    ap_rvputs(r, "The requested method ", r->method,
		      " is not allowed "
		      "for the URL ", ap_escape_html(r->pool, r->uri),
		      ".<P>\n", NULL);
	    break;
	case NOT_ACCEPTABLE:
	    ap_rvputs(r,
		      "An appropriate representation of the "
		      "requested resource ",
		      ap_escape_html(r->pool, r->uri),
		      " could not be found on this server.<P>\n", NULL);
	    /* fall through */
	case MULTIPLE_CHOICES:
	    {
		const char *list;
		if ((list = ap_table_get(r->notes, "variant-list")))
		    ap_rputs(list, r);
	    }
	    break;
	case LENGTH_REQUIRED:
	    ap_rvputs(r, "A request of the requested method ", r->method,
		      " requires a valid Content-length.<P>\n", NULL);
	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
		ap_rvputs(r, error_notes, "<P>\n", NULL);
	    }
	    break;
	case PRECONDITION_FAILED:
	    ap_rvputs(r, "The precondition on the request for the URL ",
		      ap_escape_html(r->pool, r->uri),
		      " evaluated to false.<P>\n", NULL);
	    break;
	case HTTP_NOT_IMPLEMENTED:
	    ap_rvputs(r, ap_escape_html(r->pool, r->method), " to ",
		      ap_escape_html(r->pool, r->uri),
		      " not supported.<P>\n", NULL);
	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
		ap_rvputs(r, error_notes, "<P>\n", NULL);
	    }
	    break;
	case BAD_GATEWAY:
	    ap_rputs("The proxy server received an invalid" CRLF
	             "response from an upstream server.<P>" CRLF, r);
	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
		ap_rvputs(r, error_notes, "<P>\n", NULL);
	    }
	    break;
	case VARIANT_ALSO_VARIES:
	    ap_rvputs(r, "A variant for the requested resource\n<PRE>\n",
		      ap_escape_html(r->pool, r->uri),
		      "\n</PRE>\nis itself a negotiable resource. "
		      "This indicates a configuration error.<P>\n", NULL);
	    break;
	case HTTP_REQUEST_TIME_OUT:
	    ap_rputs("Server timeout waiting for the HTTP request from the client.\n", r);
	    break;
	case HTTP_GONE:
	    ap_rvputs(r, "The requested resource<BR>",
		      ap_escape_html(r->pool, r->uri),
		      "<BR>\nis no longer available on this server ",
		      "and there is no forwarding address.\n",
		      "Please remove all references to this resource.\n",
		      NULL);
	    break;
	case HTTP_REQUEST_ENTITY_TOO_LARGE:
	    ap_rvputs(r, "The requested resource<BR>",
		      ap_escape_html(r->pool, r->uri), "<BR>\n",
		      "does not allow request data with ", r->method,
		      " requests, or the amount of data provided in\n",
		      "the request exceeds the capacity limit.\n", NULL);
	    break;
	case HTTP_REQUEST_URI_TOO_LARGE:
	    ap_rputs("The requested URL's length exceeds the capacity\n"
	             "limit for this server.<P>\n", r);
	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
		ap_rvputs(r, error_notes, "<P>\n", NULL);
	    }
	    break;
	case HTTP_UNSUPPORTED_MEDIA_TYPE:
	    ap_rputs("The supplied request data is not in a format\n"
	             "acceptable for processing by this resource.\n", r);
	    break;
	case HTTP_RANGE_NOT_SATISFIABLE:
	    ap_rputs("None of the range-specifier values in the Range\n"
	             "request-header field overlap the current extent\n"
	             "of the selected resource.\n", r);
	    break;
	case HTTP_EXPECTATION_FAILED:
	    ap_rvputs(r, "The expectation given in the Expect request-header"
	              "\nfield could not be met by this server.<P>\n"
	              "The client sent<PRE>\n    Expect: ",
	              ap_table_get(r->headers_in, "Expect"), "\n</PRE>\n"
	              "but we only allow the 100-continue expectation.\n",
	              NULL);
	    break;
	case HTTP_UNPROCESSABLE_ENTITY:
	    ap_rputs("The server understands the media type of the\n"
	             "request entity, but was unable to process the\n"
	             "contained instructions.\n", r);
	    break;
	case HTTP_LOCKED:
	    ap_rputs("The requested resource is currently locked.\n"
	             "The lock must be released or proper identification\n"
	             "given before the method can be applied.\n", r);
	    break;
	case HTTP_FAILED_DEPENDENCY:
	    ap_rputs("The method could not be performed on the resource\n"
	             "because the requested action depended on another\n"
	             "action and that other action failed.\n", r);
	    break;
	case HTTP_INSUFFICIENT_STORAGE:
	    ap_rputs("The method could not be performed on the resource\n"
	             "because the server is unable to store the\n"
	             "representation needed to successfully complete the\n"
	             "request.  There is insufficient free space left in\n"
	             "your storage allocation.\n", r);
	    break;
	case HTTP_SERVICE_UNAVAILABLE:
	    ap_rputs("The server is temporarily unable to service your\n"
	             "request due to maintenance downtime or capacity\n"
	             "problems. Please try again later.\n", r);
	    break;
	case HTTP_GATEWAY_TIME_OUT:
	    ap_rputs("The proxy server did not receive a timely response\n"
	             "from the upstream server.\n", r);
	    break;
	case HTTP_NOT_EXTENDED:
	    ap_rputs("A mandatory extension policy in the request is not\n"
	             "accepted by the server for this resource.\n", r);
	    break;
	default:            /* HTTP_INTERNAL_SERVER_ERROR */
	    /*
	     * This comparison to expose error-notes could be modified to
	     * use a configuration directive and export based on that 
	     * directive.  For now "*" is used to designate an error-notes
	     * that is totally safe for any user to see (ie lacks paths,
	     * database passwords, etc.)
	     */
	    if (((error_notes = ap_table_get(r->notes, "error-notes")) != NULL)
		&& (h1 = ap_table_get(r->notes, "verbose-error-to")) != NULL
		&& (strcmp(h1, "*") == 0)) {
	        ap_rvputs(r, error_notes, "<P>\n", NULL);
	    }
	    else {
	        ap_rvputs(r, "The server encountered an internal error or\n"
	             "misconfiguration and was unable to complete\n"
	             "your request.<P>\n"
	             "Please contact the server administrator,\n ",
	             ap_escape_html(r->pool, r->server->server_admin),
	             " and inform them of the time the error occurred,\n"
	             "and anything you might have done that may have\n"
	             "caused the error.<P>\n"
		     "More information about this error may be available\n"
		     "in the server error log.<P>\n", NULL);
	    }
	 /*
	  * It would be nice to give the user the information they need to
	  * fix the problem directly since many users don't have access to
	  * the error_log (think University sites) even though they can easily
	  * get this error by misconfiguring an htaccess file.  However, the
	  * error notes tend to include the real file pathname in this case,
	  * which some people consider to be a breach of privacy.  Until we
	  * can figure out a way to remove the pathname, leave this commented.
	  *
	  * if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
	  *     ap_rvputs(r, error_notes, "<P>\n", NULL);
	  * }
	  */
	    break;
	}
d2258 1
a2258 1
            ap_rvputs(r, "<P>Additionally, a ",
d2263 2
a2264 2
        ap_rputs(ap_psignature("<HR>\n", r), r);
        ap_rputs("</BODY></HTML>\n", r);
a2267 1
    ap_rflush(r);
@


1.1.1.3
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@d126 4
a129 10
    core_dir_config *conf;

    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
                                                   &core_module);
    if (!type) {
        type = ap_default_type(r);
    }
    if (conf->add_default_charset != ADD_DEFAULT_CHARSET_ON) {
        return type;
    }
d135 1
a135 2
    }
    else {
d139 1
a139 1
	for (pcset = needcset; *pcset ; pcset++) {
d142 1
a142 1
                                  conf->add_default_charset_name, NULL);
a144 1
        }
a731 5

        /* If we get a blank etag back, don't set the header. */
        if (!etag[0]) {
            return;
        }
d755 1
a755 4
        /* If we get a blank etag back, don't append vlv and stop now. */
        if (!variant_etag[0]) {
            return;
        }
a756 1
        /* merge variant_etag and vlv into a structured etag */
d986 1
a986 2
    int len = 0;
    int valid_protocol = 1;
d1048 3
a1050 8
    /* Avoid sscanf in the common case */
    if (strlen(r->protocol) == 8
        && r->protocol[0] == 'H' && r->protocol[1] == 'T'
	&& r->protocol[2] == 'T' && r->protocol[3] == 'P'
        && r->protocol[4] == '/' && ap_isdigit(r->protocol[5])
	&& r->protocol[6] == '.' && ap_isdigit(r->protocol[7])) {
        r->proto_num = HTTP_VERSION(r->protocol[5] - '0', r->protocol[7] - '0');
    }
d1052 2
a1053 11
        char *lint;
        char http[5];
	lint = ap_palloc(r->pool, strlen(r->protocol)+1);
	if (3 == sscanf(r->protocol, "%4s/%u.%u%s", http, &major, &minor, lint)
            && (strcasecmp("http", http) == 0)
	    && (minor < HTTP_VERSION(1,0)) ) /* don't allow HTTP/0.1000 */
	    r->proto_num = HTTP_VERSION(major, minor);
	else {
	    r->proto_num = HTTP_VERSION(1,0);
	    valid_protocol = 0;
	}
d1057 11
a1067 15
     * after the protocol string. A protocol string of nothing but
     * whitespace is considered valid */
    if (ap_protocol_req_check && !valid_protocol) {
        int n = 0;
	while (ap_isspace(r->protocol[n]))
	    ++n;
	if (r->protocol[n] != '\0') {
	    r->status    = HTTP_BAD_REQUEST;
	    r->proto_num = HTTP_VERSION(1,0);
	    r->protocol  = ap_pstrdup(r->pool, "HTTP/1.0");
	    ap_table_setn(r->notes, "error-notes",
                     "The request line contained invalid characters "
                     "following the protocol string.<P>\n");
	    return 0;
	}
a1169 4
#ifdef EAPI
    r->ctx = ap_ctx_new(r->pool);
#endif /* EAPI */

a1325 5

#ifdef EAPI
    rnew->ctx = r->ctx;
#endif /* EAPI */

d1989 1
a1989 1
        while (ap_isspace(*pos))
a1992 6
            /* special case test - a C-L field NULL or all blanks is
             * assumed OK and defaults to 0. Otherwise, we do a
             * strict check of the field */
            r->remaining = 0;
        }
        else {
d1996 1
a1996 1
            if (errno || (endstr && *endstr) || (r->remaining < 0)) {
d2001 1
a2001 1
        if (conversion_error) {
a2053 9
/**
 * Parse a chunk extension, detect overflow.
 * There are two error cases:
 *  1) If the conversion would require too many bits, a -1 is returned.
 *  2) If the conversion used the correct number of bits, but an overflow
 *     caused only the sign bit to flip, then that negative number is
 *     returned.
 * In general, any negative number can be considered an overflow error.
 */
d2797 1
a2797 7
        if (ap_table_get(r->subprocess_env,
                         "suppress-error-charset") != NULL) {
            r->content_type = "text/html";
        }
        else {
            r->content_type = "text/html; charset=iso-8859-1";
        }
@


1.1.1.4
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
d1075 1
a1075 1
        char lint[2];
d1077 2
a1078 1
	if (3 == sscanf(r->protocol, "%4s/%u.%u%1s", http, &major, &minor, lint)
@


