head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.26
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.22
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.20
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.18
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.16
	OPENBSD_5_0:1.6.0.14
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.12
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.10
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.6
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.8
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.4.0.14
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.3.0.10
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.8
	OPENBSD_3_5_BASE:1.3
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.2
	OPENBSD_3_4:1.3.0.6
	OPENBSD_3_4_BASE:1.3
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.2
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.2
	apache_1_3_27:1.1.1.2
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.1.1.1.0.14
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.12
	OPENBSD_2_8:1.1.1.1.0.10
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.8
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.6
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.04.22.14.47.26;	author henning;	state dead;
branches;
next	1.6;

1.6
date	2008.05.15.06.05.43;	author mbalmer;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.13.17.44.46;	author mbalmer;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.19.21.31.15;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.29.02.08.05;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.39;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.39;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.28.41;	author henning;	state Exp;
branches;
next	;


desc
@@


1.7
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*	$OpenBSD: gen_test_char.c,v 1.6 2008/05/15 06:05:43 mbalmer Exp $ */

/* we need some of the portability definitions... for strchr */
#include "httpd.h"

/* A bunch of functions in util.c scan strings looking for certain characters.
 * To make that more efficient we encode a lookup table.
 */
#define T_ESCAPE_SHELL_CMD	(0x01)
#define T_ESCAPE_PATH_SEGMENT	(0x02)
#define T_OS_ESCAPE_PATH	(0x04)
#define T_HTTP_TOKEN_STOP	(0x08)
#define T_ESCAPE_LOGITEM	(0x10)

int
main(int argc, char *argv[])
{
	unsigned c;
	unsigned char flags;

	printf(
	    "/* this file is automatically generated by gen_test_char, "
	    "do not edit */\n"
	    "#define T_ESCAPE_SHELL_CMD	0x%02x "
	    "/* chars with special meaning in the shell */\n"
	    "#define T_ESCAPE_PATH_SEGMENT	0x%02x "
	    "/* find path segment, as defined in RFC1808 */\n"
	    "#define T_OS_ESCAPE_PATH	0x%02x "
	    "/* escape characters in a path or uri */\n"
	    "#define T_HTTP_TOKEN_STOP	0x%02x "
	    "/* find http tokens, as defined in RFC2616 */\n"
	    "#define T_ESCAPE_LOGITEM	0x%02x "
	    "/* filter what should go in the log file */\n"
	    "\n",
	    T_ESCAPE_SHELL_CMD,
	    T_ESCAPE_PATH_SEGMENT,
	    T_OS_ESCAPE_PATH,
	    T_HTTP_TOKEN_STOP,
	    T_ESCAPE_LOGITEM);

	/* we explicitly dealt with NUL above
	 * in case some strchr() do bogosity with it
	  */

	printf("static const unsigned char test_char_table[256] = {\n"
	    "    0x00, ");    /* print initial item */

	for (c = 1; c < 256; ++c) {
		flags = 0;

		/* escape_shell_cmd */
		if (strchr("&;`'\"|*?~<>^()[]{}$\\\n", c))
			flags |= T_ESCAPE_SHELL_CMD;

		if (!ap_isalnum(c) && !strchr("$-_.+!*'(),:@@&=~", c))
			flags |= T_ESCAPE_PATH_SEGMENT;

		if (!ap_isalnum(c) && !strchr("$-_.+!*'(),:@@&=/~", c))
			flags |= T_OS_ESCAPE_PATH;

		/* these are the "tspecials" from RFC2068 */
		if (ap_iscntrl(c) || strchr(" \t()<>@@,;:\\/[]?={}", c))
			flags |= T_HTTP_TOKEN_STOP;

		/* For logging, escape all control characters, double quotes
	         * (because they delimit the request in the log file)
		 * backslashes (because we use backslash for escaping)
		 * and 8-bit chars with the high bit set
		 */
		if (!ap_isprint(c) || c == '"' || c == '\\' || ap_iscntrl(c))
			flags |= T_ESCAPE_LOGITEM;
		printf("0x%02x%s", flags, (c < 255) ? ", " : "  ");

		if ((c % 8) == 7)
			printf(" /*0x%02x...0x%02x*/\n    ", c-7, c);
	}
	printf("\n};\n");

	return 0;
}
@


1.6
log
@Add OpenBSD markers.

no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.5
log
@A first chunk of readability/knf changes.  Since there is nothing more
to merge from upstream, we can safely sanitize the code and hopefully
the build system.

Discussed with and feedback from sthen, todd, dlg and henning.

no binary changes.
@
text
@d1 2
@


1.4
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@d13 2
a14 1
int main(int argc, char *argv[])
d16 2
a17 2
    unsigned c;
    unsigned char flags;
d19 52
a70 41
    printf(
"/* this file is automatically generated by gen_test_char, do not edit */\n"
"#define T_ESCAPE_SHELL_CMD	0x%02x /* chars with special meaning in the shell */\n"
"#define T_ESCAPE_PATH_SEGMENT	0x%02x /* find path segment, as defined in RFC1808 */\n"
"#define T_OS_ESCAPE_PATH	0x%02x /* escape characters in a path or uri */\n"
"#define T_HTTP_TOKEN_STOP	0x%02x /* find http tokens, as defined in RFC2616 */\n"
"#define T_ESCAPE_LOGITEM	0x%02x /* filter what should go in the log file */\n"
"\n",
	T_ESCAPE_SHELL_CMD,
	T_ESCAPE_PATH_SEGMENT,
	T_OS_ESCAPE_PATH,
	T_HTTP_TOKEN_STOP,
	T_ESCAPE_LOGITEM
	);

    /* we explicitly dealt with NUL above
     * in case some strchr() do bogosity with it */

    printf("static const unsigned char test_char_table[256] = {\n"
	   "    0x00, ");    /* print initial item */

    for (c = 1; c < 256; ++c) {
	flags = 0;

	/* escape_shell_cmd */
        if (strchr("&;`'\"|*?~<>^()[]{}$\\\n", c)) {
	    flags |= T_ESCAPE_SHELL_CMD;
	}

	if (!ap_isalnum(c) && !strchr("$-_.+!*'(),:@@&=~", c)) {
	    flags |= T_ESCAPE_PATH_SEGMENT;
	}

	if (!ap_isalnum(c) && !strchr("$-_.+!*'(),:@@&=/~", c)) {
	    flags |= T_OS_ESCAPE_PATH;
	}

	/* these are the "tspecials" from RFC2068 */
	if (ap_iscntrl(c) || strchr(" \t()<>@@,;:\\/[]?={}", c)) {
	    flags |= T_HTTP_TOKEN_STOP;
	}
d72 2
a73 7
	/* For logging, escape all control characters,
	 * double quotes (because they delimit the request in the log file)
	 * backslashes (because we use backslash for escaping)
	 * and 8-bit chars with the high bit set
	 */
	if (!ap_isprint(c) || c == '"' || c == '\\' || ap_iscntrl(c)) {
	    flags |= T_ESCAPE_LOGITEM;
d75 1
a75 6
	printf("0x%02x%s", flags, (c < 255) ? ", " : "  ");

	if ((c % 8) == 7)
	    printf(" /*0x%02x...0x%02x*/\n    ", c-7, c);
    }
    printf("\n};\n");
d77 1
a77 1
    return 0;
@


1.3
log
@merge
@
text
@a42 13
#if defined(WIN32) || defined(OS2)
        /* Win32/OS2 have many of the same vulnerable characters
         * as Unix sh, plus the carriage return and percent char.
         * The proper escaping of these characters varies from unix
         * since Win32/OS2 use carets or doubled-double quotes, 
         * and neither lf nor cr can be escaped.  We escape unix 
         * specific as well, to assure that cross-compiled unix 
         * applications behave similiarly when invoked on win32/os2.
         */
        if (strchr("&;`'\"|*?~<>^()[]{}$\\\n\r%", c)) {
	    flags |= T_ESCAPE_SHELL_CMD;
	}
#else
a45 1
#endif
@


1.2
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d11 1
d20 6
a25 7
"#define T_ESCAPE_SHELL_CMD	(%u)\n"
"#define T_ESCAPE_PATH_SEGMENT	(%u)\n"
"#define T_OS_ESCAPE_PATH	(%u)\n"
"#define T_HTTP_TOKEN_STOP	(%u)\n"
"\n"
"static const unsigned char test_char_table[256] = {\n"
"    0,",
d29 3
a31 1
	T_HTTP_TOKEN_STOP);
d36 3
a40 2
	if (c % 20 == 0)
	    printf("\n    ");
a72 1
	printf("%u%c", flags, (c < 255) ? ',' : ' ');
d74 12
@


1.1
log
@Initial revision
@
text
@d40 10
a49 1
	if (strchr("&;`'\"|*?~<>^()[]{}$\\\n", c)) {
d52 5
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@a10 1
#define T_ESCAPE_LOGITEM	(0x10)
d19 7
a25 6
"#define T_ESCAPE_SHELL_CMD	0x%02x /* chars with special meaning in the shell */\n"
"#define T_ESCAPE_PATH_SEGMENT	0x%02x /* find path segment, as defined in RFC1808 */\n"
"#define T_OS_ESCAPE_PATH	0x%02x /* escape characters in a path or uri */\n"
"#define T_HTTP_TOKEN_STOP	0x%02x /* find http tokens, as defined in RFC2616 */\n"
"#define T_ESCAPE_LOGITEM	0x%02x /* filter what should go in the log file */\n"
"\n",
d29 1
a29 3
	T_HTTP_TOKEN_STOP,
	T_ESCAPE_LOGITEM
	);
a33 3
    printf("static const unsigned char test_char_table[256] = {\n"
	   "    0x00, ");    /* print initial item */

d36 2
d40 1
a40 14
#if defined(WIN32) || defined(OS2)
        /* Win32/OS2 have many of the same vulnerable characters
         * as Unix sh, plus the carriage return and percent char.
         * The proper escaping of these characters varies from unix
         * since Win32/OS2 use carets or doubled-double quotes, 
         * and neither lf nor cr can be escaped.  We escape unix 
         * specific as well, to assure that cross-compiled unix 
         * applications behave similiarly when invoked on win32/os2.
         */
        if (strchr("&;`'\"|*?~<>^()[]{}$\\\n\r%", c)) {
	    flags |= T_ESCAPE_SHELL_CMD;
	}
#else
        if (strchr("&;`'\"|*?~<>^()[]{}$\\\n", c)) {
a42 1
#endif
d56 1
a57 12
	/* For logging, escape all control characters,
	 * double quotes (because they delimit the request in the log file)
	 * backslashes (because we use backslash for escaping)
	 * and 8-bit chars with the high bit set
	 */
	if (!ap_isprint(c) || c == '"' || c == '\\' || ap_iscntrl(c)) {
	    flags |= T_ESCAPE_LOGITEM;
	}
	printf("0x%02x%s", flags, (c < 255) ? ", " : "  ");

	if ((c % 8) == 7)
	    printf(" /*0x%02x...0x%02x*/\n    ", c-7, c);
@

