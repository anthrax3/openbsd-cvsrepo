head	1.56;
access;
symbols
	OPENBSD_5_5:1.55.0.14
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.55.0.10
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.55.0.8
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.55.0.6
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.4
	OPENBSD_5_0:1.55.0.2
	OPENBSD_5_0_BASE:1.55
	OPENBSD_4_9:1.54.0.6
	OPENBSD_4_9_BASE:1.54
	OPENBSD_4_8:1.54.0.4
	OPENBSD_4_8_BASE:1.54
	OPENBSD_4_7:1.54.0.2
	OPENBSD_4_7_BASE:1.54
	OPENBSD_4_6:1.53.0.6
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.53.0.2
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.52.0.2
	OPENBSD_4_4_BASE:1.52
	OPENBSD_4_3:1.49.0.4
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.49.0.2
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.45.0.4
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.45.0.2
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.39.0.2
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.38.0.2
	OPENBSD_3_7_BASE:1.38
	OPENBSD_3_6:1.35.0.4
	OPENBSD_3_6_BASE:1.35
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.5
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.4
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.3
	apache_1_3_27:1.1.1.3
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.56
date	2014.04.22.14.47.26;	author henning;	state dead;
branches;
next	1.55;

1.55
date	2011.07.17.17.32.35;	author jcs;	state Exp;
branches;
next	1.54;

1.54
date	2010.02.25.07.49.53;	author pyr;	state Exp;
branches;
next	1.53;

1.53
date	2008.12.02.17.55.35;	author sthen;	state Exp;
branches;
next	1.52;

1.52
date	2008.05.21.11.28.48;	author mbalmer;	state Exp;
branches;
next	1.51;

1.51
date	2008.05.21.08.57.38;	author mbalmer;	state Exp;
branches;
next	1.50;

1.50
date	2008.05.09.08.06.28;	author mbalmer;	state Exp;
branches;
next	1.49;

1.49
date	2007.08.09.10.44.54;	author martynas;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.25.21.27.16;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2007.03.30.09.54.19;	author pyr;	state Exp;
branches;
next	1.46;

1.46
date	2007.03.22.20.08.18;	author pyr;	state Exp;
branches;
next	1.45;

1.45
date	2006.07.28.14.07.22;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.15.16.49.14;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.22.13.19.19;	author ray;	state Exp;
branches;
next	1.42;

1.42
date	2006.02.22.15.07.12;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2006.02.13.23.15.19;	author stevesk;	state Exp;
branches;
next	1.40;

1.40
date	2006.02.11.19.15.57;	author otto;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.03.05.44.35;	author djm;	state Exp;
branches;
next	1.38;

1.38
date	2005.02.09.12.13.09;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2004.12.04.12.43.35;	author jmc;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2004.02.10.12.59.29;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2003.11.17.18.57.05;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.24.10.38.30;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.19.17.23.27;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2003.08.21.13.11.35;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2003.07.08.09.51.23;	author david;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.08.20.13.08;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.16.17.16.12;	author cloder;	state Exp;
branches;
next	1.27;

1.27
date	2002.12.05.23.45.01;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.07.20.23.06;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.09.14.21.18;	author henning;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2002.09.08.17.14.57;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.04.12.28.42;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.31.09.02.28;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.29.16.47.22;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.22.18.25.31;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.20.10.38.25;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.19.21.31.15;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.17.11.19.10;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.16.14.08.34;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.15.09.40.49;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.11.08.26.27;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.09.17.34.07;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.09.17.28.47;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.06.19.35.51;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.29.02.08.05;	author beck;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.03.29.10.21.43;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.15.22.18.07;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.19.11.17.08;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.25.18.29.47;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.06.29.36;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.03.01.04.28.36;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.01.06.10;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	98.10.11.19.45.13;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.39;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.39;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.28.47;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.07.19.48.12;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.21.12.53.39;	author henning;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.17.17.03.22;	author henning;	state Exp;
branches;
next	;

1.10.2.1
date	2003.01.22.23.52.20;	author miod;	state Exp;
branches;
next	;

1.25.2.1
date	2002.11.08.00.04.04;	author jason;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2003.02.24.02.09.38;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.56
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/* $OpenBSD: http_main.c,v 1.55 2011/07/17 17:32:35 jcs Exp $ */

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/*
 * httpd.c: simple http daemon for answering WWW file requests
 *
 * 
 * 03-21-93  Rob McCool wrote original code (up to NCSA HTTPd 1.3)
 * 
 * 03-06-95  blong
 *  changed server number for child-alone processes to 0 and changed name
 *   of processes
 *
 * 03-10-95  blong
 *      Added numerous speed hacks proposed by Robert S. Thau (rst@@ai.mit.edu) 
 *      including set group before fork, and call gettime before to fork
 *      to set up libraries.
 *
 * 04-14-95  rst / rh
 *      Brandon's code snarfed from NCSA 1.4, but tinkered to work with the
 *      Apache server, and also to have child processes do accept() directly.
 *
 * April-July '95 rst
 *      Extensive rework for Apache.
 */

#define REALMAIN main

#define CORE_PRIVATE

#include "httpd.h"
#include "http_main.h"
#include "http_log.h"
#include "http_config.h"	/* for read_config */
#include "http_protocol.h"	/* for read_request */
#include "http_request.h"	/* for process_request */
#include "http_conf_globals.h"
#include "http_core.h"		/* for get_remote_host */
#include "http_vhost.h"
#include "util_script.h"	/* to force util_script.c linking */
#include "util_uri.h"
#include "fdcache.h"
#include "scoreboard.h"
#include "multithread.h"
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <netinet/tcp.h>
#ifdef MOD_SSL
#include <openssl/evp.h>
#endif

/* This next function is never used. It is here to ensure that if we
 * make all the modules into shared libraries that core httpd still
 * includes the full Apache API. Without this function the objects in
 * main/util_script.c would not be linked into a minimal httpd.
 * And the extra prototype is to make gcc -Wmissing-prototypes quiet.
 */
API_EXPORT(void) ap_force_library_loading(void);
API_EXPORT(void) ap_force_library_loading(void) {
    ap_add_cgi_vars(NULL);
}

#include "explain.h"

#if !defined(max)
#define max(a,b)        (a > b ? a : b)
#endif

#define PATHSEPARATOR '/'

DEF_Explain

/* Defining GPROF when compiling uses the moncontrol() function to
 * disable gprof profiling in the parent, and enable it only for
 * request processing in children (or in one_process mode).  It's
 * absolutely required to get useful gprof results under linux
 * because the profile itimers and such are disabled across a
 * fork().  It's probably useful elsewhere as well.
 */
#ifdef GPROF
extern void moncontrol(int);
#define MONCONTROL(x) moncontrol(x)
#else
#define MONCONTROL(x)
#endif

/* this just need to be anything non-NULL */
void *ap_dummy_mutex = &ap_dummy_mutex;

/*
 * Actual definitions of config globals... here because this is
 * for the most part the only code that acts on 'em.  (Hmmm... mod_main.c?)
 */
int ap_thread_count = 0;
API_VAR_EXPORT int ap_standalone=0;
API_VAR_EXPORT int ap_configtestonly=0;
int ap_docrootcheck=1;
API_VAR_EXPORT uid_t ap_user_id=0;
API_VAR_EXPORT char *ap_user_name=NULL;
API_VAR_EXPORT gid_t ap_group_id=0;
API_VAR_EXPORT int ap_max_requests_per_child=0;
API_VAR_EXPORT int ap_max_cpu_per_child=0;
API_VAR_EXPORT int ap_max_data_per_child=0;
API_VAR_EXPORT int ap_max_nofile_per_child=0;
API_VAR_EXPORT int ap_max_rss_per_child=0;
API_VAR_EXPORT int ap_max_stack_per_child=0;
API_VAR_EXPORT int ap_threads_per_child=0;
API_VAR_EXPORT int ap_excess_requests_per_child=0;
API_VAR_EXPORT char *ap_pid_fname=NULL;
API_VAR_EXPORT char *ap_scoreboard_fname=NULL;
API_VAR_EXPORT char *ap_lock_fname=NULL;
API_VAR_EXPORT char *ap_server_argv0=NULL;
API_VAR_EXPORT int ap_default_family = PF_INET;
API_VAR_EXPORT struct sockaddr_storage ap_bind_address;
API_VAR_EXPORT int ap_daemons_to_start=0;
API_VAR_EXPORT int ap_daemons_min_free=0;
API_VAR_EXPORT int ap_daemons_max_free=0;
API_VAR_EXPORT int ap_daemons_limit=0;
API_VAR_EXPORT time_t ap_restart_time=0;
API_VAR_EXPORT int ap_suexec_enabled = 0;
API_VAR_EXPORT int ap_listenbacklog=0;

struct accept_mutex_methods_s {
    void (*child_init)(pool *p);
    void (*init)(pool *p);
    void (*on)(void);
    void (*off)(void);
    char *name;
};
typedef struct accept_mutex_methods_s accept_mutex_methods_s;
accept_mutex_methods_s *amutex;

int ap_dump_settings = 0;
API_VAR_EXPORT int ap_extended_status = 0;
API_VAR_EXPORT ap_ctx *ap_global_ctx;

/*
 * The max child slot ever assigned, preserved across restarts.  Necessary
 * to deal with MaxClients changes across SIGUSR1 restarts.  We use this
 * value to optimize routines that have to scan the entire scoreboard.
 */
static int max_daemons_limit = -1;

/*
 * During config time, listeners is treated as a NULL-terminated list.
 * child_main previously would start at the beginning of the list each time
 * through the loop, so a socket early on in the list could easily starve out
 * sockets later on in the list.  The solution is to start at the listener
 * after the last one processed.  But to do that fast/easily in child_main it's
 * way more convenient for listeners to be a ring that loops back on itself.
 * The routine setup_listeners() is called after config time to both open up
 * the sockets and to turn the NULL-terminated list into a ring that loops back
 * on itself.
 *
 * head_listener is used by each child to keep track of what they consider
 * to be the "start" of the ring.  It is also set by make_child to ensure
 * that new children also don't starve any sockets.
 *
 * Note that listeners != NULL is ensured by read_config().
 */
listen_rec *ap_listeners=NULL;
static listen_rec *head_listener;

API_VAR_EXPORT char ap_server_root[MAX_STRING_LEN]="";
API_VAR_EXPORT char ap_server_confname[MAX_STRING_LEN]="";
API_VAR_EXPORT char ap_coredump_dir[MAX_STRING_LEN]="";

API_VAR_EXPORT array_header *ap_server_pre_read_config=NULL;
API_VAR_EXPORT array_header *ap_server_post_read_config=NULL;
API_VAR_EXPORT array_header *ap_server_config_defines=NULL;

API_VAR_EXPORT int ap_server_chroot=1;
API_VAR_EXPORT int is_chrooted=0;

/* *Non*-shared http_main globals... */

static server_rec *server_conf;
static JMP_BUF APACHE_TLS jmpbuffer;
static int sd;
static fd_set listenfds;
static int listenmaxfd;
static pid_t pgrp;

/* one_process --- debugging mode variable; can be set from the command line
 * with the -X flag.  If set, this gets you the child_main loop running
 * in the process which originally started up (no detach, no make_child),
 * which is a pretty nice debugging environment.  (You'll get a SIGHUP
 * early in standalone_main; just continue through.  This is the server
 * trying to kill off any child processes which it might have lying
 * around --- Apache doesn't keep track of their pids, it just sends
 * SIGHUP to the process group, ignoring it in the root process.
 * Continue through and you'll be fine.).
 */

static int one_process = 0;

static int do_detach = 1;

/* set if timeouts are to be handled by the children and not by the parent.
 * i.e. child_timeouts = !standalone || one_process.
 */
static int child_timeouts;

#ifdef DEBUG_SIGSTOP
int raise_sigstop_flags;
#endif

/* used to maintain list of children which aren't part of the scoreboard */
typedef struct other_child_rec other_child_rec;
struct other_child_rec {
    other_child_rec *next;
    int pid;
    void (*maintenance) (int, void *, ap_wait_t);
    void *data;
    int write_fd;
};
static other_child_rec *other_children;

static pool *pglobal;		/* Global pool */
static pool *pconf;		/* Pool for config stuff */
static pool *plog;		/* Pool for error-logging files */
static pool *ptrans;		/* Pool for per-transaction stuff */
static pool *pchild;		/* Pool for httpd child stuff */
static pool *pmutex;            /* Pool for accept mutex in child */
static pool *pcommands;	/* Pool for -C and -c switches */

static int APACHE_TLS my_pid;	/* it seems silly to call getpid all the time */
static int my_child_num;


scoreboard *ap_scoreboard_image = NULL;

/*
 * Pieces for managing the contents of the Server response header
 * field.
 */
static char *server_version = NULL;
static int version_locked = 0;

/* Global, alas, so http_core can talk to us */
enum server_token_type ap_server_tokens = SrvTk_PRODUCT_ONLY;

/* Also global, for http_core and http_protocol */
API_VAR_EXPORT int ap_protocol_req_check = 1;

API_VAR_EXPORT int ap_change_shmem_uid = 0;

/*
 * This routine is called when the pconf pool is vacuumed.  It resets the
 * server version string to a known value and [re]enables modifications
 * (which are disabled by configuration completion). 
 */
static void reset_version(void *dummy)
{
    version_locked = 0;
    ap_server_tokens = SrvTk_PRODUCT_ONLY;
    server_version = NULL;
}

API_EXPORT(const char *) ap_get_server_version(void)
{
    return (server_version ? server_version : SERVER_BASEVERSION);
}

API_EXPORT(void) ap_add_version_component(const char *component)
{
    if (! version_locked) {
        /*
         * If the version string is null, register our cleanup to reset the
         * pointer on pool destruction. We also know that, if NULL,
	 * we are adding the original SERVER_BASEVERSION string.
         */
        if (server_version == NULL) {
	    ap_register_cleanup(pconf, NULL, (void (*)(void *))reset_version, 
				ap_null_cleanup);
	    server_version = ap_pstrdup(pconf, component);
	}
	else {
	    /*
	     * Tack the given component identifier to the end of
	     * the existing string.
	     */
	    server_version = ap_pstrcat(pconf, server_version, " ",
					component, NULL);
	}
    }
}

/*
 * This routine adds the real server base identity to the version string,
 * and then locks out changes until the next reconfig.
 */
static void ap_set_version(void)
{
    if (ap_server_tokens == SrvTk_PRODUCT_ONLY) {
	ap_add_version_component(SERVER_PRODUCT);
    }
    else if (ap_server_tokens == SrvTk_MIN) {
	ap_add_version_component(SERVER_BASEVERSION);
    }
    else {
	ap_add_version_component(SERVER_BASEVERSION " (" PLATFORM ")");
    }
    /*
     * Lock the server_version string if we're not displaying
     * the full set of tokens
     */
    if (ap_server_tokens != SrvTk_FULL) {
	version_locked++;
    }
}

API_EXPORT(void) ap_add_config_define(const char *define)
{
    char **var;
    var = (char **)ap_push_array(ap_server_config_defines);
    *var = ap_pstrdup(pcommands, define);
    return;
}

/*
 * Invoke the `close_connection' hook of modules to let them do
 * some connection dependent actions before we close it.
 */
static void ap_call_close_connection_hook(conn_rec *c)
{
    module *m;
    for (m = top_module; m != NULL; m = m->next)
        if (m->magic == MODULE_MAGIC_COOKIE_EAPI)
            if (m->close_connection != NULL)
                (*m->close_connection)(c);
    return;
}

static APACHE_TLS int volatile exit_after_unblock = 0;

#ifdef GPROF
/* 
 * change directory for gprof to plop the gmon.out file
 * configure in httpd.conf:
 * GprofDir logs/   -> $ServerRoot/logs/gmon.out
 * GprofDir logs/%  -> $ServerRoot/logs/gprof.$pid/gmon.out
 */
static void chdir_for_gprof(void)
{
    core_server_config *sconf = 
	ap_get_module_config(server_conf->module_config, &core_module);    
    char *dir = sconf->gprof_dir;

    if(dir) {
	char buf[512];
	int len = strlen(sconf->gprof_dir) - 1;
	if(*(dir + len) == '%') {
	    dir[len] = '\0';
	    ap_snprintf(buf, sizeof(buf), "%sgprof.%d", dir, (int)getpid());
	} 
	dir = ap_server_root_relative(pconf, buf[0] ? buf : dir);
	if(mkdir(dir, 0755) < 0 && errno != EEXIST) {
	    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
			 "gprof: error creating directory %s", dir);
	}
    }
    else {
	dir = ap_server_root_relative(pconf, "logs");
    }

    chdir(dir);
}
#else
#define chdir_for_gprof()
#endif

/* a clean exit from a child with proper cleanup */
static void clean_child_exit(int code) __attribute__ ((noreturn));
static void clean_child_exit(int code)
{
    if (pchild) {
        /* make sure the accept mutex is released before calling child
         * exit hooks and cleanups...  otherwise, modules can segfault
         * in such code and, depending on the mutex mechanism, leave
         * the server deadlocked...  even if the module doesn't segfault,
         * if it performs extensive processing it can temporarily prevent
         * the server from accepting new connections
         */
        ap_clear_pool(pmutex);
	ap_child_exit_modules(pchild, server_conf);
	ap_destroy_pool(pchild);
    }
    chdir_for_gprof();
    exit(code);
}

/*
 * Start of accept() mutex fluff:
 *  Concept: Each method has it's own distinct set of mutex functions,
 *   which it shoves in a nice struct for us. We then pick
 *   which struct to use. We tell Apache which methods we
 *   support via HAVE_FOO_SERIALIZED_ACCEPT. We can
 *   specify the default via USE_FOO_SERIALIZED_ACCEPT
 *   (this pre-1.3.21 builds which use that at the command-
 *   line during builds work as expected). Without a set
 *   method, we pick the 1st from the following order:
 *   uslock, pthread, sysvsem, fcntl, flock, os2sem, tpfcore and none.
 */

static void expand_lock_fname(pool *p)
{
    /* XXXX possibly bogus cast */
    ap_lock_fname = ap_psprintf(p, "%s.%lu",
	ap_server_root_relative(p, ap_lock_fname), (unsigned long)getpid());
}

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

static int sem_id = -1;
static struct sembuf op_on;
static struct sembuf op_off;

/* We get a random semaphore ... the lame sysv semaphore interface
 * means we have to be sure to clean this up or else we'll leak
 * semaphores.
 */
static void accept_mutex_cleanup_sysvsem(void *foo)
{
    union semun ick;

    if (sem_id < 0)
	return;
    /* this is ignored anyhow */
    ick.val = 0;
    semctl(sem_id, 0, IPC_RMID, ick);
}

#define accept_mutex_child_init_sysvsem(x)

static void accept_mutex_init_sysvsem(pool *p)
{
    union semun ick;
    struct semid_ds buf;

    /* acquire the semaphore */
    sem_id = semget(IPC_PRIVATE, 1, IPC_CREAT | 0600);
    if (sem_id < 0) {
	perror("semget");
	exit(APEXIT_INIT);
    }
    ick.val = 1;
    if (semctl(sem_id, 0, SETVAL, ick) < 0) {
	perror("semctl(SETVAL)");
	exit(APEXIT_INIT);
    }
    if (!getuid()) {
	/* restrict it to use only by the appropriate user_id ... not that this
	 * stops CGIs from acquiring it and dinking around with it.
	 */
	buf.sem_perm.uid = ap_user_id;
	buf.sem_perm.gid = ap_group_id;
	buf.sem_perm.mode = 0600;
	ick.buf = &buf;
	if (semctl(sem_id, 0, IPC_SET, ick) < 0) {
	    perror("semctl(IPC_SET)");
	    exit(APEXIT_INIT);
	}
    }
    ap_register_cleanup(p, NULL, accept_mutex_cleanup_sysvsem, ap_null_cleanup);

    /* pre-initialize these */
    op_on.sem_num = 0;
    op_on.sem_op = -1;
    op_on.sem_flg = SEM_UNDO;
    op_off.sem_num = 0;
    op_off.sem_op = 1;
    op_off.sem_flg = SEM_UNDO;
}

static void accept_mutex_on_sysvsem(void)
{
    while (semop(sem_id, &op_on, 1) < 0) {
	if (errno != EINTR) {
	    perror("accept_mutex_on");
	    clean_child_exit(APEXIT_CHILDFATAL);
	}
    }
}

static void accept_mutex_off_sysvsem(void)
{
    while (semop(sem_id, &op_off, 1) < 0) {
	if (errno != EINTR) {
	    perror("accept_mutex_off");
	    clean_child_exit(APEXIT_CHILDFATAL);
	}
    }
}

accept_mutex_methods_s accept_mutex_sysvsem_s = {
    NULL,
    accept_mutex_init_sysvsem,
    accept_mutex_on_sysvsem,
    accept_mutex_off_sysvsem,
    "sysvsem"
};

static int flock_fd = -1;

static void accept_mutex_cleanup_flock(void *foo)
{
    unlink(ap_lock_fname);
}

/*
 * Initialize mutex lock.
 * Done by each child at it's birth
 */
static void accept_mutex_child_init_flock(pool *p)
{

    flock_fd = ap_popenf_ex(p, ap_lock_fname, O_WRONLY, 0600, 1);
    if (flock_fd == -1) {
	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
		    "Child cannot open lock file: %s", ap_lock_fname);
	clean_child_exit(APEXIT_CHILDINIT);
    }
}

/*
 * Initialize mutex lock.
 * Must be safe to call this on a restart.
 */
static void accept_mutex_init_flock(pool *p)
{
    expand_lock_fname(p);
    ap_server_strip_chroot(ap_lock_fname, 0);
    unlink(ap_lock_fname);
    flock_fd = ap_popenf_ex(p, ap_lock_fname, O_CREAT | O_WRONLY | O_EXCL, 0600, 1);
    if (flock_fd == -1) {
	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
		    "Parent cannot open lock file: %s", ap_lock_fname);
	exit(APEXIT_INIT);
    }
    ap_register_cleanup(p, NULL, accept_mutex_cleanup_flock, ap_null_cleanup);
}

static void accept_mutex_on_flock(void)
{
    int ret;

    while ((ret = flock(flock_fd, LOCK_EX)) < 0 && errno == EINTR)
	continue;

    if (ret < 0) {
	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
		    "flock: LOCK_EX: Error getting accept lock. Exiting!");
	clean_child_exit(APEXIT_CHILDFATAL);
    }
}

static void accept_mutex_off_flock(void)
{
    if (flock(flock_fd, LOCK_UN) < 0) {
	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
		    "flock: LOCK_UN: Error freeing accept lock. Exiting!");
	clean_child_exit(APEXIT_CHILDFATAL);
    }
}

accept_mutex_methods_s accept_mutex_flock_s = {
    accept_mutex_child_init_flock,
    accept_mutex_init_flock,
    accept_mutex_on_flock,
    accept_mutex_off_flock,
    "flock"
};

#define AP_FPTR1(x,y)	{ if (x) ((* x)(y)); }
#define AP_FPTR0(x)	{ if (x) ((* x)()); }

#define accept_mutex_child_init(x) 	AP_FPTR1(amutex->child_init,x)
#define accept_mutex_init(x) 		AP_FPTR1(amutex->init,x)
#define accept_mutex_off() 		AP_FPTR0(amutex->off)
#define accept_mutex_on() 		AP_FPTR0(amutex->on)

char *ap_default_mutex_method(void)
{
    char *t;
    t = "sysvsem";
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"sysvsem"))))
    	return "sysvsem";
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"flock"))))
    	return "flock";
    fprintf(stderr, "No default accept serialization known!!\n");
    exit(APEXIT_INIT);
    /*NOTREACHED */
    return "unknown";
}

char *ap_init_mutex_method(char *t)
{
    if (!(strcasecmp(t,"default")))
	t = ap_default_mutex_method();

    if (!(strcasecmp(t,"sysvsem"))) {
    	amutex = &accept_mutex_sysvsem_s;
    } else 
    if (!(strcasecmp(t,"flock"))) {
    	amutex = &accept_mutex_flock_s;
    } else 
    {
/* Ignore this directive on Windows */
    if (server_conf) {
        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
                    "Requested serialization method '%s' not available",t);
        exit(APEXIT_INIT);
    } else {
        fprintf(stderr, "Requested serialization method '%s' not available\n", t);
        exit(APEXIT_INIT);
    }
    }
    return NULL;
}

/* On some architectures it's safe to do unserialized accept()s in the single
 * Listen case.  But it's never safe to do it in the case where there's
 * multiple Listen statements.  Define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
 * when it's safe in the single Listen case.
 */
#define SAFE_ACCEPT(stmt) do {if(ap_listeners->next != ap_listeners) {stmt;}} while(0)

static void usage(char *bin)
{
    char pad[MAX_STRING_LEN];
    unsigned i;

    for (i = 0; i < strlen(bin); i++)
	pad[i] = ' ';
    pad[i] = '\0';
    fprintf(stderr, "Usage: %s [-46FhLlSTtUuVvX] [-C directive] [-c directive] [-D parameter]\n", bin);
    fprintf(stderr, "       %s [-d serverroot] [-f config]\n", pad);
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "  -C directive     : process directive before reading config files\n");
    fprintf(stderr, "  -c directive     : process directive after  reading config files\n");
    fprintf(stderr, "  -D parameter     : define a parameter for use in <IfDefine name> directives\n");
    fprintf(stderr, "  -d serverroot    : specify an alternate initial ServerRoot\n");
    fprintf(stderr, "  -4               : assume IPv4 for ambiguous directives (default)\n");
    fprintf(stderr, "  -6               : assume IPv6 for ambiguous directives\n");
    fprintf(stderr, "  -F               : run main process in foreground, for process supervisors\n");
    fprintf(stderr, "  -f config        : specify an alternate ServerConfigFile\n");
    fprintf(stderr, "  -h               : list available command line options (this page)\n");
    fprintf(stderr, "  -L               : list available configuration directives\n");
    fprintf(stderr, "  -l               : list compiled-in modules\n");
    fprintf(stderr, "  -S               : show parsed settings (currently only vhost settings)\n");
    fprintf(stderr, "  -T               : run syntax check for config files (without docroot check)\n");
    fprintf(stderr, "  -t               : run syntax check for config files (with docroot check)\n");
    fprintf(stderr, "  -U               : unspecified address family for ambiguous directives\n"); 
    fprintf(stderr, "  -u               : unsecure mode: do not chroot into ServerRoot\n");
    fprintf(stderr, "  -V               : show compile settings\n");
    fprintf(stderr, "  -v               : show version number\n");
    fprintf(stderr, "  -X               : run in single-process mode\n");

    exit(1);
}


/*****************************************************************
 *
 * Timeout handling.  DISTINCTLY not thread-safe, but all this stuff
 * has to change for threads anyway.  Note that this code allows only
 * one timeout in progress at a time...
 */

static APACHE_TLS conn_rec *volatile current_conn;
static APACHE_TLS request_rec *volatile timeout_req;
static APACHE_TLS const char *volatile timeout_name = NULL;
static APACHE_TLS int volatile alarms_blocked = 0;
static APACHE_TLS int volatile alarm_pending = 0;


static void timeout(int sig)
{
    void *dirconf;
    if (alarms_blocked) {
	alarm_pending = 1;
	return;
    }
    if (exit_after_unblock) {
	clean_child_exit(0);
    }

    if (!current_conn) {
	ap_longjmp(jmpbuffer, 1);
    }

    if (timeout_req != NULL)
	dirconf = timeout_req->per_dir_config;
    else
	dirconf = current_conn->server->lookup_defaults;
    if (!current_conn->keptalive) {
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO,
		     current_conn->server, "[client %s] %s timed out",
		     current_conn->remote_ip,
		     timeout_name ? timeout_name : "request");
    }

    if (timeout_req) {
	/* Someone has asked for this transaction to just be aborted
	 * if it times out...
	 */
	request_rec *log_req = timeout_req;
	request_rec *save_req = timeout_req;

	/* avoid looping... if ap_log_transaction started another
	 * timer (say via rfc1413.c) we could loop...
	 */
	timeout_req = NULL;

	while (log_req->main || log_req->prev) {
	    /* Get back to original request... */
	    if (log_req->main)
		log_req = log_req->main;
	    else
		log_req = log_req->prev;
	}

	if (!current_conn->keptalive) {
	    /* in some cases we come here before setting the time */
	    if (log_req->request_time == 0) {
                log_req->request_time = time(NULL);
	    }
	    ap_log_transaction(log_req);
	}

	ap_call_close_connection_hook(save_req->connection);

	ap_bsetflag(save_req->connection->client, B_EOUT, 1);
	ap_bclose(save_req->connection->client);
	
	if (!ap_standalone)
	    exit(0);
        ap_longjmp(jmpbuffer, 1);
    }
    else {			/* abort the connection */
	ap_call_close_connection_hook(current_conn);
	ap_bsetflag(current_conn->client, B_EOUT, 1);
	ap_bclose(current_conn->client);
	current_conn->aborted = 1;
    }
}


/*
 * These two called from alloc.c to protect its critical sections...
 * Note that they can nest (as when destroying the sub_pools of a pool
 * which is itself being cleared); we have to support that here.
 */

API_EXPORT(void) ap_block_alarms(void)
{
    ++alarms_blocked;
}

API_EXPORT(void) ap_unblock_alarms(void)
{
    --alarms_blocked;
    if (alarms_blocked == 0) {
	if (exit_after_unblock) {
	    /* We have a couple race conditions to deal with here, we can't
	     * allow a timeout that comes in this small interval to allow
	     * the child to jump back to the main loop.  Instead we block
	     * alarms again, and then note that exit_after_unblock is
	     * being dealt with.  We choose this way to solve this so that
	     * the common path through unblock_alarms() is really short.
	     */
	    ++alarms_blocked;
	    exit_after_unblock = 0;
	    clean_child_exit(0);
	}
	if (alarm_pending) {
	    alarm_pending = 0;
	    timeout(0);
	}
    }
}

static APACHE_TLS void (*volatile alarm_fn) (int) = NULL;

static void alrm_handler(int sig)
{
    if (alarm_fn) {
	(*alarm_fn) (sig);
    }
}

API_EXPORT(unsigned int) ap_set_callback_and_alarm(void (*fn) (int), int x)
{
    unsigned int old;

    if (alarm_fn && x && fn != alarm_fn) {
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_DEBUG, NULL,
	    "ap_set_callback_and_alarm: possible nested timer!");
    }
    alarm_fn = fn;
    if (child_timeouts) {
	old = alarm(x);
    }
    else {
	/* Just note the timeout in our scoreboard, no need to call the system.
	 * We also note that the virtual time has gone forward.
	 */
	ap_check_signals();
	old = ap_scoreboard_image->servers[my_child_num].timeout_len;
	ap_scoreboard_image->servers[my_child_num].timeout_len = x;
	++ap_scoreboard_image->servers[my_child_num].cur_vtime;
    }
    return (old);
}


/* reset_timeout (request_rec *) resets the timeout in effect,
 * as long as it hasn't expired already.
 */

API_EXPORT(void) ap_reset_timeout(request_rec *r)
{
    int i;
    if (timeout_name) {		/* timeout has been set */
	i = ap_set_callback_and_alarm(alarm_fn, r->server->timeout);
	if (i == 0)		/* timeout already expired, so set it back to 0 */
	    ap_set_callback_and_alarm(alarm_fn, 0);
    }
}




API_EXPORT(void) ap_keepalive_timeout(char *name, request_rec *r)
{
    unsigned int to;
    timeout_req = r;
    timeout_name = name;
    if (r->connection->keptalive)
	to = r->server->keep_alive_timeout;
    else
	to = r->server->timeout;
    ap_set_callback_and_alarm(timeout, to);
}

API_EXPORT(void) ap_hard_timeout(char *name, request_rec *r)
{
    timeout_req = r;
    timeout_name = name;
    ap_set_callback_and_alarm(timeout, r->server->timeout);
}

API_EXPORT(void) ap_soft_timeout(char *name, request_rec *r)
{
    timeout_name = name;
    ap_set_callback_and_alarm(timeout, r->server->timeout);
}

API_EXPORT(void) ap_kill_timeout(request_rec *dummy)
{
    ap_check_signals();
    ap_set_callback_and_alarm(NULL, 0);
    timeout_req = NULL;
    timeout_name = NULL;
}


/*
 * More machine-dependent networking gooo... on some systems,
 * you've got to be *really* sure that all the packets are acknowledged
 * before closing the connection, since the client will not be able
 * to see the last response if their TCP buffer is flushed by a RST
 * packet from us, which is what the server's TCP stack will send
 * if it receives any request data after closing the connection.
 *
 * In an ideal world, this function would be accomplished by simply
 * setting the socket option SO_LINGER and handling it within the
 * server's TCP stack while the process continues on to the next request.
 * Unfortunately, it seems that most (if not all) operating systems
 * block the server process on close() when SO_LINGER is used.
 * For those that don't, see USE_SO_LINGER below.  For the rest,
 * we have created a home-brew lingering_close.
 *
 * Many operating systems tend to block, puke, or otherwise mishandle
 * calls to shutdown only half of the connection.
 */
#ifndef MAX_SECS_TO_LINGER
#define MAX_SECS_TO_LINGER 30
#endif

#define sock_enable_linger(s)	/* NOOP */

/* Special version of timeout for lingering_close */

static void lingerout(int sig)
{
    if (alarms_blocked) {
	alarm_pending = 1;
	return;
    }

    if (!current_conn) {
	ap_longjmp(jmpbuffer, 1);
    }
    ap_bsetflag(current_conn->client, B_EOUT, 1);
    current_conn->aborted = 1;
}

static void linger_timeout(void)
{
    timeout_name = "lingering close";
    ap_set_callback_and_alarm(lingerout, MAX_SECS_TO_LINGER);
}

/* Since many clients will abort a connection instead of closing it,
 * attempting to log an error message from this routine will only
 * confuse the webmaster.  There doesn't seem to be any portable way to
 * distinguish between a dropped connection and something that might be
 * worth logging.
 */
static void lingering_close(request_rec *r)
{
    char dummybuf[512];
    struct timeval tv;
    fd_set lfds;
    int select_rv;
    int lsd;

    /* Prevent a slow-drip client from holding us here indefinitely */

    linger_timeout();

    /* Send any leftover data to the client, but never try to again */

    if (ap_bflush(r->connection->client) == -1) {
	ap_call_close_connection_hook(r->connection);
	ap_kill_timeout(r);
	ap_bclose(r->connection->client);
	return;
    }
    ap_call_close_connection_hook(r->connection);
    ap_bsetflag(r->connection->client, B_EOUT, 1);

    /* Close our half of the connection --- send the client a FIN */

    lsd = r->connection->client->fd;

    if ((shutdown(lsd, 1) != 0) || r->connection->aborted) {
	ap_kill_timeout(r);
	ap_bclose(r->connection->client);
	return;
    }

    /* Set up to wait for readable data on socket... */

    FD_ZERO(&lfds);

    /* Wait for readable data or error condition on socket;
     * slurp up any data that arrives...  We exit when we go for an
     * interval of tv length without getting any more data, get an error
     * from select(), get an error or EOF on a read, or the timer expires.
     */

    do {
	/* We use a 2 second timeout because current (Feb 97) browsers
	 * fail to close a connection after the server closes it.  Thus,
	 * to avoid keeping the child busy, we are only lingering long enough
	 * for a client that is actively sending data on a connection.
	 * This should be sufficient unless the connection is massively
	 * losing packets, in which case we might have missed the RST anyway.
	 * These parameters are reset on each pass, since they might be
	 * changed by select.
	 */

	FD_SET(lsd, &lfds);
	tv.tv_sec = 2;
	tv.tv_usec = 0;

	select_rv = ap_select(lsd + 1, &lfds, NULL, NULL, &tv);

    } while ((select_rv > 0) &&
             (read(lsd, dummybuf, sizeof(dummybuf)) > 0));

    /* Should now have seen final ack.  Safe to finally kill socket */

    ap_bclose(r->connection->client);

    ap_kill_timeout(r);
}

/*****************************************************************
 * dealing with other children
 */

API_EXPORT(void) ap_register_other_child(int pid,
		       void (*maintenance) (int reason, void *, ap_wait_t status),
			  void *data, int write_fd)
{
    other_child_rec *ocr;

    ocr = ap_palloc(pconf, sizeof(*ocr));
    ocr->pid = pid;
    ocr->maintenance = maintenance;
    ocr->data = data;
    ocr->write_fd = write_fd;
    ocr->next = other_children;
    other_children = ocr;
}

/* note that since this can be called by a maintenance function while we're
 * scanning the other_children list, all scanners should protect themself
 * by loading ocr->next before calling any maintenance function.
 */
API_EXPORT(void) ap_unregister_other_child(void *data)
{
    other_child_rec **pocr, *nocr;

    for (pocr = &other_children; *pocr; pocr = &(*pocr)->next) {
	if ((*pocr)->data == data) {
	    nocr = (*pocr)->next;
	    (*(*pocr)->maintenance) (OC_REASON_UNREGISTER, (*pocr)->data, (ap_wait_t)-1);
	    *pocr = nocr;
	    /* XXX: um, well we've just wasted some space in pconf ? */
	    return;
	}
    }
}

/* test to ensure that the write_fds are all still writable, otherwise
 * invoke the maintenance functions as appropriate */
static void probe_writable_fds(void)
{
    fd_set writable_fds;
    int fd_max;
    other_child_rec *ocr, *nocr;
    struct timeval tv;
    int rc;

    if (other_children == NULL)
	return;

    fd_max = 0;
    FD_ZERO(&writable_fds);
    do {
	for (ocr = other_children; ocr; ocr = ocr->next) {
	    if (ocr->write_fd == -1)
		continue;
	    FD_SET(ocr->write_fd, &writable_fds);
	    if (ocr->write_fd > fd_max) {
		fd_max = ocr->write_fd;
	    }
	}
	if (fd_max == 0)
	    return;

	tv.tv_sec = 0;
	tv.tv_usec = 0;
	rc = ap_select(fd_max + 1, NULL, &writable_fds, NULL, &tv);
    } while (rc == -1 && errno == EINTR);

    if (rc == -1) {
	/* XXX: uhh this could be really bad, we could have a bad file
	 * descriptor due to a bug in one of the maintenance routines */
	ap_log_unixerr("probe_writable_fds", "select",
		    "could not probe writable fds", server_conf);
	return;
    }
    if (rc == 0)
	return;

    for (ocr = other_children; ocr; ocr = nocr) {
	nocr = ocr->next;
	if (ocr->write_fd == -1)
	    continue;
	if (FD_ISSET(ocr->write_fd, &writable_fds))
	    continue;
	(*ocr->maintenance) (OC_REASON_UNWRITABLE, ocr->data, (ap_wait_t)-1);
    }
}

/* possibly reap an other_child, return 0 if yes, -1 if not */
static int reap_other_child(int pid, ap_wait_t status)
{
    other_child_rec *ocr, *nocr;

    for (ocr = other_children; ocr; ocr = nocr) {
	nocr = ocr->next;
	if (ocr->pid != pid)
	    continue;
	ocr->pid = -1;
	(*ocr->maintenance) (OC_REASON_DEATH, ocr->data, status);
	return 0;
    }
    return -1;
}

/*****************************************************************
 *
 * Dealing with the scoreboard... a lot of these variables are global
 * only to avoid getting clobbered by the longjmp() that happens when
 * a hard timeout expires...
 *
 * We begin with routines which deal with the file itself... 
 */

static void setup_shared_mem(pool *p)
{
    caddr_t m;

/* BSD style */
    m = mmap((caddr_t) 0, SCOREBOARD_SIZE,
	     PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0);
    if (m == (caddr_t) - 1) {
	perror("mmap");
	fprintf(stderr, "%s: Could not mmap memory\n", ap_server_argv0);
	exit(APEXIT_INIT);
    }
    ap_scoreboard_image = (scoreboard *) m;
    ap_scoreboard_image->global.running_generation = 0;
}

/* Called by parent process */
static void reinit_scoreboard(pool *p)
{
    int running_gen = 0;
    if (ap_scoreboard_image)
	running_gen = ap_scoreboard_image->global.running_generation;

    if (ap_scoreboard_image == NULL) {
	setup_shared_mem(p);
    }
    memset(ap_scoreboard_image, 0, SCOREBOARD_SIZE);
    ap_scoreboard_image->global.running_generation = running_gen;
}

/* Routines called to deal with the scoreboard image
 * --- note that we do *not* need write locks, since update_child_status
 * only updates a *single* record in place, and only one process writes to
 * a given scoreboard slot at a time (either the child process owning that
 * slot, or the parent, noting that the child has died).
 *
 * As a final note --- setting the score entry to getpid() is always safe,
 * since when the parent is writing an entry, it's only noting SERVER_DEAD
 * anyway.
 */

API_EXPORT(int) ap_exists_scoreboard_image(void)
{
    return (ap_scoreboard_image ? 1 : 0);
}

/* a clean exit from the parent with proper cleanup */
static void clean_parent_exit(int code) __attribute__((noreturn));
static void clean_parent_exit(int code)
{
    /* Clear the pool - including any registered cleanups */
    ap_destroy_pool(pglobal);
    ap_kill_alloc_shared();
    fdcache_closeall();
    exit(code);
}

API_EXPORT(int) ap_update_child_status(int child_num, int status, request_rec *r)
{
    int old_status;
    short_score *ss;

    if (child_num < 0)
	return -1;

    ap_check_signals();

    ss = &ap_scoreboard_image->servers[child_num];
    old_status = ss->status;
    ss->status = status;

    ++ss->cur_vtime;

    if (ap_extended_status) {
	if (status == SERVER_READY || status == SERVER_DEAD) {
	    /*
	     * Reset individual counters
	     */
	    if (status == SERVER_DEAD) {
		ss->my_access_count = 0L;
		ss->my_bytes_served = 0ULL;
	    }
	    ss->conn_count = (unsigned short) 0;
	    ss->conn_bytes = 0ULL;
	}
        else if (status == SERVER_STARTING) {
            /* clean out the start_time so that mod_status will print Req=0 */
            /* Use memset to be independent from the type (struct timeval vs. clock_t) */
            memset (&ss->start_time, '\0', sizeof ss->start_time);
        }
	if (r) {
	    conn_rec *c = r->connection;
	    ap_cpystrn(ss->client, ap_get_remote_host(c, r->per_dir_config,
				  REMOTE_NOLOOKUP), sizeof(ss->client));
	    if (r->the_request == NULL) {
		    ap_cpystrn(ss->request, "NULL", sizeof(ss->request));
	    } else if (r->parsed_uri.password == NULL) {
		    ap_cpystrn(ss->request, r->the_request, sizeof(ss->request));
	    } else {
		/* Don't reveal the password in the server-status view */
		    ap_cpystrn(ss->request, ap_pstrcat(r->pool, r->method, " ",
					       ap_unparse_uri_components(r->pool, &r->parsed_uri, UNP_OMITPASSWORD),
					       r->assbackwards ? NULL : " ", r->protocol, NULL),
				       sizeof(ss->request));
	    }
	    ss->vhostrec =  r->server;
	}
    }
    if (status == SERVER_STARTING && r == NULL) {
	/* clean up the slot's vhostrec pointer (maybe re-used)
	 * and mark the slot as belonging to a new generation.
	 */
	ss->vhostrec = NULL;
	ap_scoreboard_image->parent[child_num].generation = ap_my_generation;
    }

    return old_status;
}

void ap_time_process_request(int child_num, int status)
{
    short_score *ss;

    if (child_num < 0)
	return;

    ss = &ap_scoreboard_image->servers[child_num];

    if (status == START_PREQUEST) {
	if (gettimeofday(&ss->start_time, (struct timezone *) 0) < 0)
	    ss->start_time.tv_sec =
		ss->start_time.tv_usec = 0L;
    }
    else if (status == STOP_PREQUEST) {
	if (gettimeofday(&ss->stop_time, (struct timezone *) 0) < 0)
	    ss->stop_time.tv_sec =
		ss->stop_time.tv_usec =
		ss->start_time.tv_sec =
		ss->start_time.tv_usec = 0L;

    }
}

static void increment_counts(int child_num, request_rec *r)
{
    off_t bs = 0;
    short_score *ss;

    ss = &ap_scoreboard_image->servers[child_num];

    if (r->sent_bodyct)
	ap_bgetopt(r->connection->client, BO_BYTECT, &bs);

    times(&ss->times);
    ss->access_count++;
    ss->my_access_count++;
    ss->conn_count++;
    ss->bytes_served += bs;
    ss->my_bytes_served += bs;
    ss->conn_bytes += bs;
}

static int find_child_by_pid(int pid)
{
    int i;

    for (i = 0; i < max_daemons_limit; ++i)
	if (ap_scoreboard_image->parent[i].pid == pid)
	    return i;

    return -1;
}

static int safe_child_kill(pid_t pid, int sig)
{
    if (getpgid(pid) == getpgrp()) {
        return kill(pid, sig);
    }
    else {
        errno = EINVAL;
        return -1;
    }
}

static void reclaim_child_processes(int terminate)
{
    int i, status;
    long int waittime = 1024 * 16;	/* in usecs */
    struct timeval tv;
    int waitret, tries;
    int not_dead_yet;
    int ret;
    other_child_rec *ocr, *nocr;

    for (tries = terminate ? 4 : 1; tries <= 12; ++tries) {
	/* don't want to hold up progress any more than 
	 * necessary, but we need to allow children a few moments to exit.
	 * Set delay with an exponential backoff. NOTE: if we get
 	 * interrupted, we'll wait longer than expected...
	 */
	tv.tv_sec = waittime / 1000000;
	tv.tv_usec = waittime % 1000000;
	waittime = waittime * 4;
	do {
	    ret = ap_select(0, NULL, NULL, NULL, &tv);
	} while (ret == -1 && errno == EINTR);

	/* now see who is done */
	not_dead_yet = 0;
	for (i = 0; i < max_daemons_limit; ++i) {
	    int pid = ap_scoreboard_image->parent[i].pid;

	    if (pid == my_pid || pid == 0)
		continue;

	    waitret = waitpid(pid, &status, WNOHANG);
	    if (waitret == pid || waitret == -1) {
		ap_scoreboard_image->parent[i].pid = 0;
		continue;
	    }
	    ++not_dead_yet;
	    switch (tries) {
	    case 1:     /*  16ms */
	    case 2:     /*  82ms */
		break;
	    case 3:     /* 344ms */
		/* perhaps it missed the SIGHUP, lets try again */
		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING,
			    server_conf,
		    "child process %d did not exit, sending another SIGHUP",
			    pid);
		safe_child_kill(pid, SIGHUP);
		waittime = 1024 * 16;
		break;
	    case 4:     /*  16ms */
	    case 5:     /*  82ms */
	    case 6:     /* 344ms */
		break;
	    case 7:     /* 1.4sec */
		/* ok, now it's being annoying */
		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING,
			    server_conf,
		   "child process %d still did not exit, sending a SIGTERM",
			    pid);
		safe_child_kill(pid, SIGTERM);
		break;
	    case 8:     /*  6 sec */
		/* die child scum */
		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
		   "child process %d still did not exit, sending a SIGKILL",
			    pid);
		safe_child_kill(pid, SIGKILL);
		waittime = 1024 * 16; /* give them some time to die */
		break;
	    case 9:     /*   6 sec */
	    case 10:    /* 6.1 sec */
	    case 11:    /* 6.4 sec */
		break;
	    case 12:    /* 7.4 sec */
		/* gave it our best shot, but alas...  If this really 
		 * is a child we are trying to kill and it really hasn't
		 * exited, we will likely fail to bind to the port
		 * after the restart.
		 */
		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
			    "could not make child process %d exit, "
			    "attempting to continue anyway", pid);
		break;
	    }
	}
	for (ocr = other_children; ocr; ocr = nocr) {
	    nocr = ocr->next;
	    if (ocr->pid == -1)
		continue;

	    waitret = waitpid(ocr->pid, &status, WNOHANG);
	    if (waitret == ocr->pid) {
		ocr->pid = -1;
		(*ocr->maintenance) (OC_REASON_RESTART, ocr->data, (ap_wait_t)status);
	    }
	    else if (waitret == 0) {
		(*ocr->maintenance) (OC_REASON_RESTART, ocr->data, (ap_wait_t)-1);
		++not_dead_yet;
	    }
	    else if (waitret == -1) {
		/* uh what the heck? they didn't call unregister? */
		ocr->pid = -1;
		(*ocr->maintenance) (OC_REASON_LOST, ocr->data, (ap_wait_t)-1);
	    }
	}
	if (!not_dead_yet) {
	    /* nothing left to wait for */
	    break;
	}
    }
}


/* Finally, this routine is used by the caretaker process to wait for
 * a while...
 */

/* number of calls to wait_or_timeout between writable probes */
#ifndef INTERVAL_OF_WRITABLE_PROBES
#define INTERVAL_OF_WRITABLE_PROBES 10
#endif
static int wait_or_timeout_counter;

static int wait_or_timeout(ap_wait_t *status)
{
    struct timeval tv;
    int ret;

    ++wait_or_timeout_counter;
    if (wait_or_timeout_counter == INTERVAL_OF_WRITABLE_PROBES) {
	wait_or_timeout_counter = 0;
	probe_writable_fds();
    }
    ret = waitpid(-1, status, WNOHANG);
    if (ret == -1 && errno == EINTR) {
	return -1;
    }
    if (ret > 0) {
	return ret;
    }
    tv.tv_sec = SCOREBOARD_MAINTENANCE_INTERVAL / 1000000;
    tv.tv_usec = SCOREBOARD_MAINTENANCE_INTERVAL % 1000000;
    ap_select(0, NULL, NULL, NULL, &tv);
    return -1;
}

#if defined(NSIG)
#define NumSIG NSIG
#elif defined(_NSIG)
#define NumSIG _NSIG
#elif defined(__NSIG)
#define NumSIG __NSIG
#else
#define NumSIG 32   /* for 1998's unixes, this is still a good assumption */
#endif

#define SYS_SIGLIST ap_sys_siglist
#define INIT_SIGLIST() siglist_init();

const char *ap_sys_siglist[NumSIG];

static void siglist_init(void)
{
    int sig;

    ap_sys_siglist[0] = "Signal 0";
    ap_sys_siglist[SIGHUP] = "Hangup";
    ap_sys_siglist[SIGINT] = "Interrupt";
    ap_sys_siglist[SIGQUIT] = "Quit";
    ap_sys_siglist[SIGILL] = "Illegal instruction";
    ap_sys_siglist[SIGTRAP] = "Trace/BPT trap";
    ap_sys_siglist[SIGIOT] = "IOT instruction";
    ap_sys_siglist[SIGABRT] = "Abort";
    ap_sys_siglist[SIGEMT] = "Emulator trap";
    ap_sys_siglist[SIGFPE] = "Arithmetic exception";
    ap_sys_siglist[SIGKILL] = "Killed";
    ap_sys_siglist[SIGBUS] = "Bus error";
    ap_sys_siglist[SIGSEGV] = "Segmentation fault";
    ap_sys_siglist[SIGSYS] = "Bad system call";
    ap_sys_siglist[SIGPIPE] = "Broken pipe";
    ap_sys_siglist[SIGALRM] = "Alarm clock";
    ap_sys_siglist[SIGTERM] = "Terminated";
    ap_sys_siglist[SIGUSR1] = "User defined signal 1";
    ap_sys_siglist[SIGUSR2] = "User defined signal 2";
    ap_sys_siglist[SIGCHLD] = "Child status change";
    ap_sys_siglist[SIGWINCH] = "Window changed";
    ap_sys_siglist[SIGURG] = "urgent socket condition";
    ap_sys_siglist[SIGIO] = "socket I/O possible";
    ap_sys_siglist[SIGSTOP] = "Stopped (signal)";
    ap_sys_siglist[SIGTSTP] = "Stopped";
    ap_sys_siglist[SIGCONT] = "Continued";
    ap_sys_siglist[SIGTTIN] = "Stopped (tty input)";
    ap_sys_siglist[SIGTTOU] = "Stopped (tty output)";
    ap_sys_siglist[SIGVTALRM] = "virtual timer expired";
    ap_sys_siglist[SIGPROF] = "profiling timer expired";
    ap_sys_siglist[SIGXCPU] = "exceeded cpu limit";
    ap_sys_siglist[SIGXFSZ] = "exceeded file size limit";
    for (sig=0; sig < sizeof(ap_sys_siglist)/sizeof(ap_sys_siglist[0]); ++sig)
        if (ap_sys_siglist[sig] == NULL)
            ap_sys_siglist[sig] = "";
}

/* handle all varieties of core dumping signals */
static void sig_coredump(int sig)
{
    chdir(ap_coredump_dir);
    signal(sig, SIG_DFL);
    kill(getpid(), sig);
    /* At this point we've got sig blocked, because we're still inside
     * the signal handler.  When we leave the signal handler it will
     * be unblocked, and we'll take the signal... and coredump or whatever
     * is appropriate for this particular Unix.  In addition the parent
     * will see the real signal we received -- whereas if we called
     * abort() here, the parent would only see SIGABRT.
     */
}

/*****************************************************************
 * Connection structures and accounting...
 */

static void just_die(int sig)
{				/* SIGHUP to child process??? */
    /* if alarms are blocked we have to wait to die otherwise we might
     * end up with corruption in alloc.c's internal structures */
    if (alarms_blocked) {
	exit_after_unblock = 1;
    }
    else {
	clean_child_exit(0);
    }
}

static int volatile usr1_just_die = 1;
static int volatile deferred_die;

static void usr1_handler(int sig)
{
    if (usr1_just_die) {
	just_die(sig);
    }
    deferred_die = 1;
}

/* volatile just in case */
static int volatile shutdown_pending;
static int volatile restart_pending;
static int volatile is_graceful;
API_VAR_EXPORT ap_generation_t volatile ap_my_generation=0;


/*
 * ap_start_shutdown() and ap_start_restart(), below, are a first stab at
 * functions to initiate shutdown or restart without relying on signals. 
 * Previously this was initiated in sig_term() and restart() signal handlers, 
 * but we want to be able to start a shutdown/restart from other sources --
 * e.g. on Win32, from the service manager. Now the service manager can
 * call ap_start_shutdown() or ap_start_restart() as appropiate.  Note that
 * these functions can also be called by the child processes, since global
 * variables are no longer used to pass on the required action to the parent.
 */

API_EXPORT(void) ap_start_shutdown(void)
{
    if (shutdown_pending == 1) {
	/* Um, is this _probably_ not an error, if the user has
	 * tried to do a shutdown twice quickly, so we won't
	 * worry about reporting it.
	 */
	return;
    }
    shutdown_pending = 1;
}

/* do a graceful restart if graceful == 1 */
API_EXPORT(void) ap_start_restart(int graceful)
{
    if (restart_pending == 1) {
	/* Probably not an error - don't bother reporting it */
	return;
    }
    restart_pending = 1;
    is_graceful = graceful;
}

static void sig_term(int sig)
{
    ap_start_shutdown();
}

static void restart(int sig)
{
    ap_start_restart(sig == SIGUSR1);
}

static void set_signals(void)
{
    struct sigaction sa;

    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (!one_process) {
	sa.sa_handler = sig_coredump;
	sa.sa_flags = SA_RESETHAND;
	if (sigaction(SIGBUS, &sa, NULL) < 0)
	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGBUS)");
	if (sigaction(SIGABRT, &sa, NULL) < 0)
	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGABRT)");
	if (sigaction(SIGILL, &sa, NULL) < 0)
	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGILL)");
	sa.sa_flags = 0;
    }
    sa.sa_handler = sig_term;
    if (sigaction(SIGTERM, &sa, NULL) < 0)
	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGTERM)");
    if (sigaction(SIGINT, &sa, NULL) < 0)
        ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGINT)");
    sa.sa_handler = SIG_DFL;
    if (sigaction(SIGXCPU, &sa, NULL) < 0)
	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGXCPU)");
    sa.sa_handler = SIG_DFL;
    if (sigaction(SIGXFSZ, &sa, NULL) < 0)
	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGXFSZ)");
    sa.sa_handler = SIG_IGN;
    if (sigaction(SIGPIPE, &sa, NULL) < 0)
	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGPIPE)");

    /* we want to ignore HUPs and USR1 while we're busy processing one */
    sigaddset(&sa.sa_mask, SIGHUP);
    sigaddset(&sa.sa_mask, SIGUSR1);
    sa.sa_handler = restart;
    if (sigaction(SIGHUP, &sa, NULL) < 0)
	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGHUP)");
    if (sigaction(SIGUSR1, &sa, NULL) < 0)
	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGUSR1)");
}


/*****************************************************************
 * Here follows a long bunch of generic server bookkeeping stuff...
 */

static void detach(void)
{
    int x;

    chdir("/");
    if (do_detach) {
        if ((x = fork()) > 0)
            exit(0);
        else if (x == -1) {
            perror("fork");
	    fprintf(stderr, "%s: unable to fork new process\n", ap_server_argv0);
	    exit(1);
        }
        RAISE_SIGSTOP(DETACH);
    }
    if ((pgrp = setsid()) == -1) {
	perror("setsid");
	fprintf(stderr, "%s: setsid failed\n", ap_server_argv0);
	if (!do_detach) 
	    fprintf(stderr, "setsid() failed probably because you aren't "
		"running under a process management tool like daemontools\n");
	exit(1);
    }

    /* close out the standard file descriptors */
    if (freopen("/dev/null", "r", stdin) == NULL) {
	fprintf(stderr, "%s: unable to replace stdin with /dev/null: %s\n",
		ap_server_argv0, strerror(errno));
	/* continue anyhow -- note we can't close out descriptor 0 because we
	 * have nothing to replace it with, and if we didn't have a descriptor
	 * 0 the next file would be created with that value ... leading to
	 * havoc.
	 */
    }
    if (freopen("/dev/null", "w", stdout) == NULL) {
	fprintf(stderr, "%s: unable to replace stdout with /dev/null: %s\n",
		ap_server_argv0, strerror(errno));
    }
    /* stderr is a tricky one, we really want it to be the error_log,
     * but we haven't opened that yet.  So leave it alone for now and it'll
     * be reopened moments later.
     */
}

/* Set group privileges.
 *
 * Note that we use the username as set in the config files, rather than
 * the lookup of to uid --- the same uid may have multiple passwd entries,
 * with different sets of groups for each.
 */

static void set_group_privs(void)
{
    if (!geteuid()) {
	char *name;

	/* Get username if passed as a uid */

	if (ap_user_name[0] == '#') {
	    struct passwd *ent;
	    uid_t uid = atoi(&ap_user_name[1]);

	    if ((ent = getpwuid(uid)) == NULL) {
		ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
			 "getpwuid: couldn't determine user name from uid %u, "
			 "you probably need to modify the User directive",
			 (unsigned)uid);
		clean_child_exit(APEXIT_CHILDFATAL);
	    }

	    name = ent->pw_name;
	}
	else
	    name = ap_user_name;

	/*
	 * Set the GID before initgroups(), since on some platforms
	 * setgid() is known to zap the group list.
	 */
	if (setgid(ap_group_id) == -1) {
	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
			"setgid: unable to set group id to Group %u",
			(unsigned)ap_group_id);
	    clean_child_exit(APEXIT_CHILDFATAL);
	}

	/* Reset `groups' attributes. */

	if (initgroups(name, ap_group_id) == -1) {
	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
			"initgroups: unable to set groups for User %s "
			"and Group %u", name, (unsigned)ap_group_id);
	    clean_child_exit(APEXIT_CHILDFATAL);
	}
    }
}

/* check to see if we have the 'suexec' setuid wrapper installed */
static int init_suexec(void)
{
    int result = 0;

    struct stat wrapper;

    if ((stat(SUEXEC_BIN, &wrapper)) != 0) {
	result = 0;
    }
    else if ((wrapper.st_mode & S_ISUID) && (wrapper.st_uid == 0)) {
	result = 1;
    }
    return result;
}

/*****************************************************************
 * Connection structures and accounting...
 */


static conn_rec *new_connection(pool *p, server_rec *server, BUFF *inout,
			     const struct sockaddr *remaddr,
			     const struct sockaddr *saddr,
			     int child_num)
{
    conn_rec *conn = (conn_rec *) ap_pcalloc(p, sizeof(conn_rec));
    char hostnamebuf[MAXHOSTNAMELEN];
    size_t addr_len;

    /* Got a connection structure, so initialize what fields we can
     * (the rest are zeroed out by pcalloc).
     */

    conn->child_num = child_num;

    conn->pool = p;
    addr_len = saddr->sa_len;
    memcpy(&conn->local_addr, saddr, addr_len);
    getnameinfo((struct sockaddr *)&conn->local_addr, addr_len,
	hostnamebuf, sizeof(hostnamebuf), NULL, 0, NI_NUMERICHOST);
    conn->local_ip = ap_pstrdup(conn->pool, hostnamebuf);
    conn->server = server; /* just a guess for now */
    ap_update_vhost_given_ip(conn);
    conn->base_server = conn->server;
    conn->client = inout;

    addr_len = remaddr->sa_len;
    memcpy(&conn->remote_addr, remaddr, addr_len);
    getnameinfo((struct sockaddr *)&conn->remote_addr, addr_len,
      hostnamebuf, sizeof(hostnamebuf), NULL, 0, NI_NUMERICHOST);
    conn->remote_ip = ap_pstrdup(conn->pool, hostnamebuf);
    conn->ctx = ap_ctx_new(conn->pool);

    /*
     * Invoke the `new_connection' hook of modules to let them do
     * some connection dependent actions before we go on with
     * processing the request on this connection.
     */
    {
        module *m;
        for (m = top_module; m != NULL; m = m->next)
            if (m->magic == MODULE_MAGIC_COOKIE_EAPI)
                if (m->new_connection != NULL)
                    (*m->new_connection)(conn);
    }

    return conn;
}

static void sock_disable_nagle(int s, struct sockaddr_in *sin_client)
{
    /* The Nagle algorithm says that we should delay sending partial
     * packets in hopes of getting more data.  We don't want to do
     * this; we are not telnet.  There are bad interactions between
     * persistent connections and Nagle's algorithm that have very severe
     * performance penalties.  (Failing to disable Nagle is not much of a
     * problem with simple HTTP.)
     *
     * In spite of these problems, failure here is not a shooting offense.
     */
    int just_say_no = 1;

    if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (char *) &just_say_no,
		   sizeof(int)) < 0) {
        if (sin_client) {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, server_conf,
                         "setsockopt: (TCP_NODELAY), client %pA probably "
                         "dropped the connection", &sin_client->sin_addr);
        }
        else {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, server_conf,
                         "setsockopt: (TCP_NODELAY)");
        }
    }
}

static int make_sock(pool *p, const struct sockaddr *server)
{
    int s;
    int one = 1;
    char addr[INET6_ADDRSTRLEN + 128];
    char a0[INET6_ADDRSTRLEN];
    char p0[NI_MAXSERV];

    switch(server->sa_family){
    case AF_INET:
    case AF_INET6:
      break;
    default:
      ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
                   "make_sock: unsupported address family %u", 
		   server->sa_family);
      ap_unblock_alarms();
      exit(1);
    }
    
    getnameinfo(server, server->sa_len, a0, sizeof(a0), p0, sizeof(p0),
   	NI_NUMERICHOST | NI_NUMERICSERV);
    ap_snprintf(addr, sizeof(addr), "address %s port %s", a0, p0);
#ifdef MPE
    if (atoi(p0) < 1024)
      privport++;
#endif

    /* note that because we're about to slack we don't use psocket */
    ap_block_alarms();
    if ((s = socket(server->sa_family, SOCK_STREAM, IPPROTO_TCP)) == -1) {
	    ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
		    "make_sock: failed to get a socket for %s", addr);

	    ap_unblock_alarms();
	    exit(1);
    }

    s = ap_slack(s, AP_SLACK_HIGH);

    ap_note_cleanups_for_socket_ex(p, s, 1);	/* arrange to close on exec or restart */

    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *) &one, sizeof(int)) < 0) {
	ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
		    "make_sock: for %s, setsockopt: (SO_REUSEADDR)", addr);
	closesocket(s);
	ap_unblock_alarms();
	exit(1);
    }
    one = 1;
    if (setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, (char *) &one, sizeof(int)) < 0) {
	ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
		    "make_sock: for %s, setsockopt: (SO_KEEPALIVE)", addr);
	closesocket(s);

	ap_unblock_alarms();
	exit(1);
    }

    sock_disable_nagle(s, NULL);
    sock_enable_linger(s);

    /*
     * To send data over high bandwidth-delay connections at full
     * speed we must force the TCP window to open wide enough to keep the
     * pipe full.  The default window size on many systems
     * is only 4kB.  Cross-country WAN connections of 100ms
     * at 1Mb/s are not impossible for well connected sites.
     * If we assume 100ms cross-country latency,
     * a 4kB buffer limits throughput to 40kB/s.
     *
     * To avoid this problem I've added the SendBufferSize directive
     * to allow the web master to configure send buffer size.
     *
     * The trade-off of larger buffers is that more kernel memory
     * is consumed.  YMMV, know your customers and your network!
     *
     * -John Heidemann <johnh@@isi.edu> 25-Oct-96
     *
     * If no size is specified, use the kernel default.
     */
    if (server_conf->send_buffer_size) {
	if (setsockopt(s, SOL_SOCKET, SO_SNDBUF,
		(char *) &server_conf->send_buffer_size, sizeof(int)) < 0) {
	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf,
			"make_sock: failed to set SendBufferSize for %s, "
			"using default", addr);
	    /* not a fatal error */
	}
    }

    if (bind(s, server, server->sa_len) == -1) {
	ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
	    "make_sock: could not bind to %s", addr);

	closesocket(s);
	ap_unblock_alarms();
	exit(1);
    }

    if (listen(s, ap_listenbacklog) == -1) {
	ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
	    "make_sock: unable to listen for connections on %s", addr);
	closesocket(s);
	ap_unblock_alarms();
	exit(1);
    }

    ap_unblock_alarms();

    /* protect various fd_sets */
    if (s >= FD_SETSIZE) {
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
	    "make_sock: problem listening on %s, filedescriptor (%u) "
	    "larger than FD_SETSIZE (%u) "
	    "found, you probably need to rebuild Apache with a "
	    "larger FD_SETSIZE", addr, s, FD_SETSIZE);
	closesocket(s);
	exit(1);
    }

    return s;
}


/*
 * During a restart we keep track of the old listeners here, so that we
 * can re-use the sockets.  We have to do this because we won't be able
 * to re-open the sockets ("Address already in use").
 *
 * Unlike the listeners ring, old_listeners is a NULL terminated list.
 *
 * copy_listeners() makes the copy, find_listener() finds an old listener
 * and close_unused_listener() cleans up whatever wasn't used.
 */
static listen_rec *old_listeners;

/* unfortunately copy_listeners may be called before listeners is a ring */
static void copy_listeners(pool *p)
{
    listen_rec *lr;

    ap_assert(old_listeners == NULL);
    if (ap_listeners == NULL) {
	return;
    }
    lr = ap_listeners;
    do {
	listen_rec *nr = malloc(sizeof *nr);

        if (nr == NULL) {
            fprintf(stderr, "Ouch!  malloc failed in copy_listeners()\n");
            exit(1);
        }
	*nr = *lr;
	ap_kill_cleanups_for_socket(p, nr->fd);
	nr->next = old_listeners;
	ap_assert(!nr->used);
	old_listeners = nr;
	lr = lr->next;
    } while (lr && lr != ap_listeners);
}


static int find_listener(listen_rec *lr)
{
    listen_rec *or;

    for (or = old_listeners; or; or = or->next) {
	if (!memcmp(&or->local_addr, &lr->local_addr, sizeof(or->local_addr))) {
	    or->used = 1;
	    return or->fd;
	}
    }
    return -1;
}


static void close_unused_listeners(void)
{
    listen_rec *or, *next;

    for (or = old_listeners; or; or = next) {
	next = or->next;
	if (!or->used)
	    closesocket(or->fd);
	free(or);
    }
    old_listeners = NULL;
}


/* open sockets, and turn the listeners list into a singly linked ring */
static void setup_listeners(pool *p)
{
    listen_rec *lr;
    int fd;

    listenmaxfd = -1;
    FD_ZERO(&listenfds);
    lr = ap_listeners;
    for (;;) {
	fd = find_listener(lr);
	if (fd < 0) {
		fd = make_sock(p, (struct sockaddr *)&lr->local_addr);
	}
	else {
	    ap_note_cleanups_for_socket_ex(p, fd, 1);
	}
	/* if we get here, (fd >= 0) && (fd < FD_SETSIZE) */
	if (fd >= 0) {
	    FD_SET(fd, &listenfds);
	    if (fd > listenmaxfd)
		listenmaxfd = fd;
	}
	lr->fd = fd;
	if (lr->next == NULL)
	    break;
	lr = lr->next;
    }
    /* turn the list into a ring */
    lr->next = ap_listeners;
    head_listener = ap_listeners;
    close_unused_listeners();

}


/*
 * Find a listener which is ready for accept().  This advances the
 * head_listener global.
 */
static ap_inline listen_rec *find_ready_listener(fd_set * main_fds)
{
    listen_rec *lr;

    lr = head_listener;
    do {
	if (FD_ISSET(lr->fd, main_fds)) {
	    head_listener = lr->next;
	    return (lr);
	}
	lr = lr->next;
    } while (lr != head_listener);
    return NULL;
}


static void show_compile_settings(void)
{
    printf("Server version: %s\n", ap_get_server_version());
    printf("Server's Module Magic Number: %u:%u\n",
	   MODULE_MAGIC_NUMBER_MAJOR, MODULE_MAGIC_NUMBER_MINOR);
    printf("Server compiled with....\n");
    printf(" -D EAPI\n");
#ifdef EAPI_MM
    printf(" -D EAPI_MM\n");
#ifdef EAPI_MM_CORE_PATH
    printf(" -D EAPI_MM_CORE_PATH=\"" EAPI_MM_CORE_PATH "\"\n");
#endif
#endif
    printf(" -D HAVE_MMAP\n");
    printf(" -D HAVE_SHMGET\n");
    printf(" -D USE_MMAP_SCOREBOARD\n");
    printf(" -D USE_MMAP_FILES\n");
#ifdef MMAP_SEGMENT_SIZE
	printf(" -D MMAP_SEGMENT_SIZE=%ld\n",(long)MMAP_SEGMENT_SIZE);
#endif
    printf(" -D HAVE_FLOCK_SERIALIZED_ACCEPT\n");
    printf(" -D HAVE_SYSVSEM_SERIALIZED_ACCEPT\n");
    printf(" -D SINGLE_LISTEN_UNSERIALIZED_ACCEPT\n");
#ifdef BUFFERED_LOGS
    printf(" -D BUFFERED_LOGS\n");
#ifdef PIPE_BUF
	printf(" -D PIPE_BUF=%ld\n",(long)PIPE_BUF);
#endif
#endif
    printf(" -D DYNAMIC_MODULE_LIMIT=%ld\n",(long)DYNAMIC_MODULE_LIMIT);
    printf(" -D HARD_SERVER_LIMIT=%ld\n",(long)HARD_SERVER_LIMIT);

/* This list displays the compiled-in default paths: */
#ifdef HTTPD_ROOT
    printf(" -D HTTPD_ROOT=\"" HTTPD_ROOT "\"\n");
#endif
#if defined(SUEXEC_BIN)
    printf(" -D SUEXEC_BIN=\"" SUEXEC_BIN "\"\n");
#endif
#ifdef DEFAULT_PIDLOG
    printf(" -D DEFAULT_PIDLOG=\"" DEFAULT_PIDLOG "\"\n");
#endif
#ifdef DEFAULT_SCOREBOARD
    printf(" -D DEFAULT_SCOREBOARD=\"" DEFAULT_SCOREBOARD "\"\n");
#endif
#ifdef DEFAULT_LOCKFILE
    printf(" -D DEFAULT_LOCKFILE=\"" DEFAULT_LOCKFILE "\"\n");
#endif
#ifdef DEFAULT_ERRORLOG
    printf(" -D DEFAULT_ERRORLOG=\"" DEFAULT_ERRORLOG "\"\n");
#endif
#ifdef TYPES_CONFIG_FILE
    printf(" -D TYPES_CONFIG_FILE=\"" TYPES_CONFIG_FILE "\"\n");
#endif
#ifdef SERVER_CONFIG_FILE
    printf(" -D SERVER_CONFIG_FILE=\"" SERVER_CONFIG_FILE "\"\n");
#endif
#ifdef ACCESS_CONFIG_FILE
    printf(" -D ACCESS_CONFIG_FILE=\"" ACCESS_CONFIG_FILE "\"\n");
#endif
#ifdef RESOURCE_CONFIG_FILE
    printf(" -D RESOURCE_CONFIG_FILE=\"" RESOURCE_CONFIG_FILE "\"\n");
#endif
}


/* Some init code that's common between win32 and unix... well actually
 * some of it is #ifdef'd but was duplicated before anyhow.  This stuff
 * is still a mess.
 */
static void common_init(void)
{
    INIT_SIGLIST()


    pglobal = ap_init_alloc();
    pconf = ap_make_sub_pool(pglobal);
    plog = ap_make_sub_pool(pglobal);
    ptrans = ap_make_sub_pool(pconf);

    ap_util_init();
    ap_util_uri_init();

    pcommands = ap_make_sub_pool(NULL);
    ap_server_pre_read_config  = ap_make_array(pcommands, 1, sizeof(char *));
    ap_server_post_read_config = ap_make_array(pcommands, 1, sizeof(char *));
    ap_server_config_defines   = ap_make_array(pcommands, 1, sizeof(char *));

    ap_hook_init();
    ap_hook_configure("ap::buff::read", 
                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);
    ap_hook_configure("ap::buff::write",  
                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);
    ap_hook_configure("ap::buff::writev",  
                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);
    ap_hook_configure("ap::buff::sendwithtimeout", 
                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);
    ap_hook_configure("ap::buff::recvwithtimeout", 
                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);

    ap_global_ctx = ap_ctx_new(NULL);
}

/*****************************************************************
 * Child process main loop.
 * The following vars are static to avoid getting clobbered by longjmp();
 * they are really private to child_main.
 */

static int srv;
static int csd;
static int dupped_csd;
static int requests_this_child;
static fd_set main_fds;

API_EXPORT(void) ap_child_terminate(request_rec *r)
{
    r->connection->keepalive = 0;
    requests_this_child = ap_max_requests_per_child = 1;
}

static void child_main(int child_num_arg)
{
    NET_SIZE_T clen;
    struct sockaddr_storage sa_server;
    struct sockaddr_storage sa_client;
    listen_rec *lr;
    struct rlimit rlp;

    /* All of initialization is a critical section, we don't care if we're
     * told to HUP or USR1 before we're done initializing.  For example,
     * we could be half way through child_init_modules() when a restart
     * signal arrives, and we'd have no real way to recover gracefully
     * and exit properly.
     *
     * I suppose a module could take forever to initialize, but that would
     * be either a broken module, or a broken configuration (i.e. network
     * problems, file locking problems, whatever). -djg
     */
    ap_block_alarms();

    my_pid = getpid();
    csd = -1;
    dupped_csd = -1;
    my_child_num = child_num_arg;
    requests_this_child = 0;

    setproctitle("child");

    /*
     * set up rlimits to keep apache+scripting from leaking horribly
     */
    if (ap_max_cpu_per_child != 0){
	rlp.rlim_cur = rlp.rlim_max = ap_max_cpu_per_child;
	if (setrlimit(RLIMIT_CPU, &rlp) == -1){
	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
		"setrlimit: unable to set CPU limit to %d",
		ap_max_cpu_per_child);
	    clean_child_exit(APEXIT_CHILDFATAL);
	}
    }
    if (ap_max_data_per_child != 0){
	rlp.rlim_cur = rlp.rlim_max = ap_max_data_per_child;
	if (setrlimit(RLIMIT_DATA, &rlp) == -1){
	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
		"setrlimit: unable to set data limit to %d",
		ap_max_data_per_child);
	    clean_child_exit(APEXIT_CHILDFATAL);
	}
    }
    if (ap_max_nofile_per_child != 0){
	rlp.rlim_cur = rlp.rlim_max = ap_max_nofile_per_child;
	if (setrlimit(RLIMIT_NOFILE, &rlp) == -1){
	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
		"setrlimit: unable to set open file limit to %d",
		ap_max_nofile_per_child);
	    clean_child_exit(APEXIT_CHILDFATAL);
	}
    }
    if (ap_max_rss_per_child != 0){
	rlp.rlim_cur = rlp.rlim_max = ap_max_rss_per_child;
	if (setrlimit(RLIMIT_RSS, &rlp) == -1){
	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
		"setrlimit: unable to set RSS limit to %d",
		ap_max_rss_per_child);
	    clean_child_exit(APEXIT_CHILDFATAL);
	}
    }
    if (ap_max_stack_per_child != 0){
	rlp.rlim_cur = rlp.rlim_max = ap_max_stack_per_child;
	if (setrlimit(RLIMIT_STACK, &rlp) == -1){
	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
		"setrlimit: unable to set stack size limit to %d",
		ap_max_stack_per_child);
	    clean_child_exit(APEXIT_CHILDFATAL);
	}
    }

    /* Get a sub pool for global allocations in this child, so that
     * we can have cleanups occur when the child exits.
     */
    pchild = ap_make_sub_pool(pconf);
    /* associate accept mutex cleanup with a subpool of pchild so we can
     * make sure the mutex is released before calling module code at
     * termination
     */
    pmutex = ap_make_sub_pool(pchild);

    /* needs to be done before we switch UIDs so we have permissions */
    SAFE_ACCEPT(accept_mutex_child_init(pmutex));

    set_group_privs();
    /* 
     * Only try to switch if we're running as root
     * In case of Cygwin we have the special super-user named SYSTEM
     */
    if (!geteuid() && (
	setuid(ap_user_id) == -1)) {
	ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
		    "setuid: unable to change to uid: %u", ap_user_id);
	clean_child_exit(APEXIT_CHILDFATAL);
    }

    ap_child_init_modules(pchild, server_conf);

    /* done with the initialization critical section */
    ap_unblock_alarms();

    (void) ap_update_child_status(my_child_num, SERVER_READY, (request_rec *) NULL);

    /*
     * Setup the jump buffers so that we can return here after a timeout 
     */
    ap_setjmp(jmpbuffer);
    signal(SIGURG, timeout);
    if (signal(SIGALRM, alrm_handler) == SIG_ERR) {
	   fprintf(stderr, "installing signal handler for SIGALRM failed, errno %u\n", errno);
	}


    while (1) {
	BUFF *conn_io;
	request_rec *r;

	/* Prepare to receive a SIGUSR1 due to graceful restart so that
	 * we can exit cleanly.  Since we're between connections right
	 * now it's the right time to exit, but we might be blocked in a
	 * system call when the graceful restart request is made. */
	usr1_just_die = 1;
	signal(SIGUSR1, usr1_handler);

	/*
	 * (Re)initialize this child to a pre-connection state.
	 */

	ap_kill_timeout(0);	/* Cancel any outstanding alarms. */
	current_conn = NULL;

	ap_clear_pool(ptrans);

	if (ap_scoreboard_image->global.running_generation != ap_my_generation) {
	    clean_child_exit(0);
	}

	if ((ap_max_requests_per_child > 0
	     && requests_this_child++ >= ap_max_requests_per_child)) {
	    clean_child_exit(0);
	}

	(void) ap_update_child_status(my_child_num, SERVER_READY, (request_rec *) NULL);

	/*
	 * Wait for an acceptable connection to arrive.
	 */

	/* Lock around "accept", if necessary */
	SAFE_ACCEPT(accept_mutex_on());

	for (;;) {
	    if (ap_listeners->next != ap_listeners) {
		/* more than one socket */
		memcpy(&main_fds, &listenfds, sizeof(fd_set));
		srv = ap_select(listenmaxfd + 1, &main_fds, NULL, NULL, NULL);

		if (srv < 0 && errno != EINTR) {
		    /* Single Unix documents select as returning errnos
		     * EBADF, EINTR, and EINVAL... and in none of those
		     * cases does it make sense to continue.  In fact
		     * on Linux 2.0.x we seem to end up with EFAULT
		     * occasionally, and we'd loop forever due to it.
		     */
		    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf, "select: (listen)");
		    clean_child_exit(1);
		}

		if (srv <= 0)
		    continue;

		lr = find_ready_listener(&main_fds);
		if (lr == NULL)
		    continue;
		sd = lr->fd;
	    }
	    else {
		/* only one socket, just pretend we did the other stuff */
		sd = ap_listeners->fd;
	    }

	    /* if we accept() something we don't want to die, so we have to
	     * defer the exit
	     */
	    deferred_die = 0;
	    usr1_just_die = 0;
	    for (;;) {
		clen = sizeof(sa_client);
		csd = ap_accept(sd, (struct sockaddr *)&sa_client, &clen);
		if (csd >= 0 || errno != EINTR)
		    break;
		if (deferred_die) {
		    /* we didn't get a socket, and we were told to die */
		    clean_child_exit(0);
		}
	    }

	    if (csd >= 0)
		break;		/* We have a socket ready for reading */
	    else {

		/* Our old behaviour here was to continue after accept()
		 * errors.  But this leads us into lots of troubles
		 * because most of the errors are quite fatal.  For
		 * example, EMFILE can be caused by slow descriptor
		 * leaks (say in a 3rd party module, or libc).  It's
		 * foolish for us to continue after an EMFILE.  We also
		 * seem to tickle kernel bugs on some platforms which
		 * lead to never-ending loops here.  So it seems best
		 * to just exit in most cases.
		 */
                switch (errno) {

                case ECONNABORTED:
		    /* Linux generates the rest of these, other tcp
		     * stacks (i.e. bsd) tend to hide them behind
		     * getsockopt() interfaces.  They occur when
		     * the net goes sour or the client disconnects
		     * after the three-way handshake has been done
		     * in the kernel but before userland has picked
		     * up the socket.
		     */
                case ECONNRESET:
                case ETIMEDOUT:
		case EHOSTUNREACH:
		case ENETUNREACH:
                    break;
		case ENETDOWN:
		     /*
		      * When the network layer has been shut down, there
		      * is not much use in simply exiting: the parent
		      * would simply re-create us (and we'd fail again).
		      * Use the CHILDFATAL code to tear the server down.
		      * @@@@@@ Martin's idea for possible improvement:
		      * A different approach would be to define
		      * a new APEXIT_NETDOWN exit code, the reception
		      * of which would make the parent shutdown all
		      * children, then idle-loop until it detected that
		      * the network is up again, and restart the children.
		      * Ben Hyde noted that temporary ENETDOWN situations
		      * occur in mobile IP.
		      */
		    ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
			"accept: giving up.");
		    clean_child_exit(APEXIT_CHILDFATAL);

		default:
		    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
				"accept: (client socket)");
		    clean_child_exit(1);
		}
	    }

	    /* go around again, safe to die */
	    usr1_just_die = 1;
	    if (deferred_die) {
		/* ok maybe not, see ya later */
		clean_child_exit(0);
	    }
	    /* or maybe we missed a signal, you never know on systems
	     * without reliable signals
	     */
	    if (ap_scoreboard_image->global.running_generation != ap_my_generation) {
		clean_child_exit(0);
	    }
	}

	SAFE_ACCEPT(accept_mutex_off());	/* unlock after "accept" */


	/* We've got a socket, let's at least process one request off the
	 * socket before we accept a graceful restart request.
	 */
	signal(SIGUSR1, SIG_IGN);

	ap_note_cleanups_for_socket_ex(ptrans, csd, 1);

	/* protect various fd_sets */
	if (csd >= FD_SETSIZE) {
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
		"[csd] filedescriptor (%u) larger than FD_SETSIZE (%u) "
		"found, you probably need to rebuild Apache with a "
		"larger FD_SETSIZE", csd, FD_SETSIZE);
	    continue;
	}

	/*
	 * We now have a connection, so set it up with the appropriate
	 * socket options, file descriptors, and read/write buffers.
	 */

	clen = sizeof(sa_server);
	if (getsockname(csd, (struct sockaddr *)&sa_server, &clen) < 0) {
	    ap_log_error(APLOG_MARK, APLOG_DEBUG, server_conf, 
                         "getsockname, client %pA probably dropped the "
                         "connection", 
                         &((struct sockaddr_in *)&sa_client)->sin_addr);
	    continue;
	}

	sock_disable_nagle(csd, (struct sockaddr_in *)&sa_client);

	(void) ap_update_child_status(my_child_num, SERVER_BUSY_READ,
				   (request_rec *) NULL);

	conn_io = ap_bcreate(ptrans, B_RDWR | B_SOCKET);

	dupped_csd = csd;
	ap_bpushfd(conn_io, csd, dupped_csd);

	current_conn = new_connection(ptrans, server_conf, conn_io,
				          (struct sockaddr *)&sa_client,
				          (struct sockaddr *)&sa_server,
				          my_child_num);

	/*
	 * Read and process each request found on our connection
	 * until no requests are left or we decide to close.
	 */

	while ((r = ap_read_request(current_conn)) != NULL) {

	    /* read_request_line has already done a
	     * signal (SIGUSR1, SIG_IGN);
	     */

	    (void) ap_update_child_status(my_child_num, SERVER_BUSY_WRITE, r);

	    /* process the request if it was read without error */

	    if (r->status == HTTP_OK)
		ap_process_request(r);

	    if(ap_extended_status)
		increment_counts(my_child_num, r);

	    if (!current_conn->keepalive || current_conn->aborted)
		break;

	    ap_destroy_pool(r->pool);
	    (void) ap_update_child_status(my_child_num, SERVER_BUSY_KEEPALIVE,
				       (request_rec *) NULL);

	    if (ap_scoreboard_image->global.running_generation != ap_my_generation) {
		ap_call_close_connection_hook(current_conn);
		ap_bclose(conn_io);
		clean_child_exit(0);
	    }

	    /* In case we get a graceful restart while we're blocked
	     * waiting for the request.
	     *
	     * XXX: This isn't perfect, we might actually read the
	     * request and then just die without saying anything to
	     * the client.  This can be fixed by using deferred_die
	     * but you have to teach buff.c about it so that it can handle
	     * the EINTR properly.
	     *
	     * In practice though browsers (have to) expect keepalive
	     * connections to close before receiving a response because
	     * of network latencies and server timeouts.
	     */
	    usr1_just_die = 1;
	    signal(SIGUSR1, usr1_handler);
	}

	/*
	 * Close the connection, being careful to send out whatever is still
	 * in our buffers.  If possible, try to avoid a hard close until the
	 * client has ACKed our FIN and/or has stopped sending us data.
	 */

	if (r && r->connection
	    && !r->connection->aborted
	    && r->connection->client
	    && (r->connection->client->fd >= 0)) {

	    lingering_close(r);
	}
	else {
	    ap_call_close_connection_hook(current_conn);
	    ap_bsetflag(conn_io, B_EOUT, 1);
	    ap_bclose(conn_io);
	}
    }
}


static int make_child(server_rec *s, int slot, time_t now)
{
    int pid;

    if (slot + 1 > max_daemons_limit) {
	max_daemons_limit = slot + 1;
    }

    if (one_process) {
	signal(SIGHUP, just_die);
	signal(SIGINT, just_die);
	signal(SIGQUIT, SIG_DFL);
	signal(SIGTERM, just_die);
	child_main(slot);
    }

    /* avoid starvation */
    head_listener = head_listener->next;

    Explain1("Starting new child in slot %d", slot);
    (void) ap_update_child_status(slot, SERVER_STARTING, (request_rec *) NULL);


    if ((pid = fork()) == -1) {
	ap_log_error(APLOG_MARK, APLOG_ERR, s, "fork: Unable to fork new process");

	/* fork didn't succeed. Fix the scoreboard or else
	 * it will say SERVER_STARTING forever and ever
	 */
	(void) ap_update_child_status(slot, SERVER_DEAD, (request_rec *) NULL);

	/* In case system resources are maxxed out, we don't want
	   Apache running away with the CPU trying to fork over and
	   over and over again. */
	sleep(10);

	return -1;
    }

    if (!pid) {
	RAISE_SIGSTOP(MAKE_CHILD);
	MONCONTROL(1);
	/* Disable the restart signal handlers and enable the just_die stuff.
	 * Note that since restart() just notes that a restart has been
	 * requested there's no race condition here.
	 */
	signal(SIGHUP, just_die);
	signal(SIGUSR1, just_die);
	signal(SIGTERM, just_die);
	child_main(slot);
    }

    ap_scoreboard_image->parent[slot].last_rtime = now;
    ap_scoreboard_image->parent[slot].pid = pid;
    return 0;
}


/* start up a bunch of children */
static void startup_children(int number_to_start)
{
    int i;
    time_t now = time(NULL);

    for (i = 0; number_to_start && i < ap_daemons_limit; ++i) {
	if (ap_scoreboard_image->servers[i].status != SERVER_DEAD) {
	    continue;
	}
	if (make_child(server_conf, i, now) < 0) {
	    break;
	}
	--number_to_start;
    }
}


/*
 * idle_spawn_rate is the number of children that will be spawned on the
 * next maintenance cycle if there aren't enough idle servers.  It is
 * doubled up to MAX_SPAWN_RATE, and reset only when a cycle goes by
 * without the need to spawn.
 */
static int idle_spawn_rate = 1;
#ifndef MAX_SPAWN_RATE
#define MAX_SPAWN_RATE	(32)
#endif
static int hold_off_on_exponential_spawning;

/*
 * Define the signal that is used to kill off children if idle_count
 * is greater then ap_daemons_max_free. Usually we will use SIGUSR1
 * to gracefully shutdown, but unfortunatly some OS will need other 
 * signals to ensure that the child process is terminated and the 
 * scoreboard pool is not growing to infinity. Also set the signal we
 * use to kill of childs that exceed timeout. This effect has been
* seen at least on Cygwin 1.x. -- Stipe Tolj <tolj@@wapme-systems.de>
 */
#define SIG_IDLE_KILL SIGUSR1
#define SIG_TIMEOUT_KILL SIGALRM

static void perform_idle_server_maintenance(void)
{
    int i;
    int to_kill;
    int idle_count;
    short_score *ss;
    time_t now = time(NULL);
    int free_length;
    int free_slots[MAX_SPAWN_RATE];
    int last_non_dead;
    int total_non_dead;

    /* initialize the free_list */
    free_length = 0;

    to_kill = -1;
    idle_count = 0;
    last_non_dead = -1;
    total_non_dead = 0;

    for (i = 0; i < ap_daemons_limit; ++i) {
	int status;

	if (i >= max_daemons_limit && free_length == idle_spawn_rate)
	    break;
	ss = &ap_scoreboard_image->servers[i];
	status = ss->status;
	if (status == SERVER_DEAD) {
	    /* try to keep children numbers as low as possible */
	    if (free_length < idle_spawn_rate) {
		free_slots[free_length] = i;
		++free_length;
	    }
	}
	else {
	    /* We consider a starting server as idle because we started it
	     * at least a cycle ago, and if it still hasn't finished starting
	     * then we're just going to swamp things worse by forking more.
	     * So we hopefully won't need to fork more if we count it.
	     * This depends on the ordering of SERVER_READY and SERVER_STARTING.
	     */
	    if (status <= SERVER_READY) {
		++ idle_count;
		/* always kill the highest numbered child if we have to...
		 * no really well thought out reason ... other than observing
		 * the server behaviour under linux where lower numbered children
		 * tend to service more hits (and hence are more likely to have
		 * their data in cpu caches).
		 */
		to_kill = i;
	    }

	    ++total_non_dead;
	    last_non_dead = i;
	    if (ss->timeout_len) {
		/* if it's a live server, with a live timeout then
		 * start checking its timeout */
		parent_score *ps = &ap_scoreboard_image->parent[i];
		if (ss->cur_vtime != ps->last_vtime) {
		    /* it has made progress, so update its last_rtime,
		     * last_vtime */
		    ps->last_rtime = now;
		    ps->last_vtime = ss->cur_vtime;
		}
		else if (ps->last_rtime + ss->timeout_len < now) {
		    /* no progress, and the timeout length has been exceeded */
		    ss->timeout_len = 0;
		    safe_child_kill(ps->pid, SIG_TIMEOUT_KILL);
		}
	    }
	}
    }
    max_daemons_limit = last_non_dead + 1;
    if (idle_count > ap_daemons_max_free) {
	/* kill off one child... we use SIGUSR1 because that'll cause it to
	 * shut down gracefully, in case it happened to pick up a request
	 * while we were counting. Use the define SIG_IDLE_KILL to reflect
	 * which signal should be used on the specific OS.
	 */
	safe_child_kill(ap_scoreboard_image->parent[to_kill].pid, SIG_IDLE_KILL);
	idle_spawn_rate = 1;
    }
    else if (idle_count < ap_daemons_min_free) {
	/* terminate the free list */
	if (free_length == 0) {
	    /* only report this condition once */
	    static int reported = 0;

	    if (!reported) {
		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
			    "server reached MaxClients setting, consider"
			    " raising the MaxClients setting");
		reported = 1;
	    }
	    idle_spawn_rate = 1;
	}
	else {
	    if (idle_spawn_rate >= 8) {
		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
		    "server seems busy, (you may need "
		    "to increase StartServers, or Min/MaxSpareServers), "
		    "spawning %d children, there are %d idle, and "
		    "%d total children", idle_spawn_rate,
		    idle_count, total_non_dead);
	    }
	    for (i = 0; i < free_length; ++i) {
		make_child(server_conf, free_slots[i], now);
	    }
	    /* the next time around we want to spawn twice as many if this
	     * wasn't good enough, but not if we've just done a graceful
	     */
	    if (hold_off_on_exponential_spawning) {
		--hold_off_on_exponential_spawning;
	    }
	    else if (idle_spawn_rate < MAX_SPAWN_RATE) {
		idle_spawn_rate *= 2;
	    }
	}
    }
    else {
	idle_spawn_rate = 1;
    }
}


static void process_child_status(int pid, ap_wait_t status)
{
    /* Child died... if it died due to a fatal error,
	* we should simply bail out.
	*/
    if ((WIFEXITED(status)) &&
	WEXITSTATUS(status) == APEXIT_CHILDFATAL) {
        /* cleanup pid file -- it is useless after our exiting */
        const char *pidfile = NULL;
        pidfile = ap_server_root_relative (pconf, ap_pid_fname);
        if ( pidfile != NULL && unlink(pidfile) == 0)
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO,
                         server_conf,
                         "removed PID file %s (pid=%ld)",
                         pidfile, (long)getpid());
	ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, server_conf,
			"Child %d returned a Fatal error... \n"
			"Apache is exiting!",
			pid);
	exit(APEXIT_CHILDFATAL);
    }
    if (WIFSIGNALED(status)) {
	switch (WTERMSIG(status)) {
	case SIGTERM:
	case SIGHUP:
	case SIGUSR1:
	case SIGKILL:
	    break;
	default:
	    if (WCOREDUMP(status)) {
		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE,
			     server_conf,
			     "child pid %d exit signal %s (%d), "
			     "possible coredump in %s",
			     pid, (WTERMSIG(status) >= NumSIG) ? "" : 
			     SYS_SIGLIST[WTERMSIG(status)], WTERMSIG(status),
			     ap_coredump_dir);
	    }
	    else {
		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE,
			     server_conf,
			     "child pid %d exit signal %s (%d)", pid,
			     SYS_SIGLIST[WTERMSIG(status)], WTERMSIG(status));
	    }
	}
    }
}


/*****************************************************************
 * Executive routines.
 */

#ifndef STANDALONE_MAIN
#define STANDALONE_MAIN standalone_main

static void standalone_main(int argc, char **argv)
{
    int remaining_children_to_start;


    ap_standalone = 1;

    is_graceful = 0;

    if (!one_process) {
	detach();
    }
    else {
	MONCONTROL(1);
    }

    my_pid = getpid();

    do {
	copy_listeners(pconf);
	if (!is_graceful) {
	    ap_restart_time = time(NULL);
	}
	ap_clear_pool(pconf);
	ptrans = ap_make_sub_pool(pconf);

	ap_init_mutex_method(ap_default_mutex_method());

	server_conf = ap_read_config(pconf, ptrans, ap_server_confname);
	setup_listeners(pconf);
	ap_clear_pool(plog);

	/* 
	 * we cannot reopen the logfiles once we dropped permissions, 
	 * we cannot write the pidfile (pointless anyway), and we can't
	 * reload & reinit the modules.
	 */

	if (!is_chrooted) {
	    ap_open_logs(server_conf, plog);
	    ap_log_pid(pconf, ap_pid_fname);
	}
	ap_set_version();	/* create our server_version string */
	ap_init_modules(pconf, server_conf);
	ap_init_etag(pconf);
	version_locked++;	/* no more changes to server_version */

	if(!is_graceful && !is_chrooted)
	    if (ap_server_chroot) {
		if (geteuid()) {
		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, 
			server_conf, "can't run in secure mode if not "
			"started with root privs.");
		    exit(1);
		}

		/* initialize /dev/crypto, XXX check for -DSSL option */
#ifdef MOD_SSL
		OpenSSL_add_all_algorithms();
#endif

		if (initgroups(ap_user_name, ap_group_id)) {
		    ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
			"initgroups: unable to set groups for User %s "
			"and Group %u", ap_user_name, (unsigned)ap_group_id);
		    exit(1);
		}

		if (chroot(ap_server_root) < 0) {
		    ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
			"unable to chroot into %s!", ap_server_root);
		    exit(1);
		}
		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 
		    server_conf, "chrooted in %s", ap_server_root);
		chdir("/");
		is_chrooted = 1;
		setproctitle("parent [chroot %s]", ap_server_root);

		if (setresgid(ap_group_id, ap_group_id, ap_group_id) != 0 ||
		    setresuid(ap_user_id, ap_user_id, ap_user_id) != 0) {
			ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
			    "can't drop privileges!");
			exit(1);
		} else
		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE,
			server_conf, "changed to uid %u, gid %u",
			ap_user_id, ap_group_id);
		} else
		    setproctitle("parent");


	SAFE_ACCEPT(accept_mutex_init(pconf));
	if (!is_graceful) {
	    reinit_scoreboard(pconf);
	}
	set_signals();

	if (ap_daemons_max_free < ap_daemons_min_free + 1)	/* Don't thrash... */
	    ap_daemons_max_free = ap_daemons_min_free + 1;

	/* If we're doing a graceful_restart then we're going to see a lot
	 * of children exiting immediately when we get into the main loop
	 * below (because we just sent them SIGUSR1).  This happens pretty
	 * rapidly... and for each one that exits we'll start a new one until
	 * we reach at least daemons_min_free.  But we may be permitted to
	 * start more than that, so we'll just keep track of how many we're
	 * supposed to start up without the 1 second penalty between each fork.
	 */
	remaining_children_to_start = ap_daemons_to_start;
	if (remaining_children_to_start > ap_daemons_limit) {
	    remaining_children_to_start = ap_daemons_limit;
	}
	if (!is_graceful) {
	    startup_children(remaining_children_to_start);
	    remaining_children_to_start = 0;
	}
	else {
	    /* give the system some time to recover before kicking into
	     * exponential mode */
	    hold_off_on_exponential_spawning = 10;
	}

	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
		    "%s configured -- resuming normal operations",
		    ap_get_server_version());
	if (ap_suexec_enabled) {
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
		         "suEXEC mechanism enabled (wrapper: %s)", SUEXEC_BIN);
	}
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
		    "Accept mutex: %s (Default: %s)",
		     amutex->name, ap_default_mutex_method());
	restart_pending = shutdown_pending = 0;

	while (!restart_pending && !shutdown_pending) {
	    int child_slot;
	    ap_wait_t status;
	    int pid = wait_or_timeout(&status);

	    /* XXX: if it takes longer than 1 second for all our children
	     * to start up and get into IDLE state then we may spawn an
	     * extra child
	     */
	    if (pid >= 0) {
		process_child_status(pid, status);
		/* non-fatal death... note that it's gone in the scoreboard. */
		child_slot = find_child_by_pid(pid);
		Explain2("Reaping child %d slot %d", pid, child_slot);
		if (child_slot >= 0) {
		    (void) ap_update_child_status(child_slot, SERVER_DEAD,
					       (request_rec *) NULL);
		    if (remaining_children_to_start
			&& child_slot < ap_daemons_limit) {
			/* we're still doing a 1-for-1 replacement of dead
			 * children with new children
			 */
			make_child(server_conf, child_slot, time(NULL));
			--remaining_children_to_start;
		    }
		}
		else if (reap_other_child(pid, status) == 0) {
		    /* handled */
		}
		else if (is_graceful) {
		    /* Great, we've probably just lost a slot in the
		     * scoreboard.  Somehow we don't know about this
		     * child.
		     */
		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, server_conf,
				"long lost child came home! (pid %d)", pid);
		}
		/* Don't perform idle maintenance when a child dies,
		 * only do it when there's a timeout.  Remember only a
		 * finite number of children can die, and it's pretty
		 * pathological for a lot to die suddenly.
		 */
		continue;
	    }
	    else if (remaining_children_to_start) {
		/* we hit a 1 second timeout in which none of the previous
		 * generation of children needed to be reaped... so assume
		 * they're all done, and pick up the slack if any is left.
		 */
		startup_children(remaining_children_to_start);
		remaining_children_to_start = 0;
		/* In any event we really shouldn't do the code below because
		 * few of the servers we just started are in the IDLE state
		 * yet, so we'd mistakenly create an extra server.
		 */
		continue;
	    }

	    perform_idle_server_maintenance();
	}

	if (shutdown_pending) {
	    /* Time to gracefully shut down:
	     * Kill child processes, tell them to call child_exit, etc...
	     */
	    if (ap_killpg(pgrp, SIGTERM) < 0) {
		ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "killpg SIGTERM");
	    }
	    reclaim_child_processes(1);		/* Start with SIGTERM */

	    /* cleanup pid file on normal shutdown */
	    {
		char *pidfile = NULL;
		pidfile = ap_server_root_relative (pconf, ap_pid_fname);
		ap_server_strip_chroot(pidfile, 0);
		if ( pidfile != NULL && unlink(pidfile) == 0)
		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO,
				 server_conf,
				 "removed PID file %s (pid=%u)",
				 pidfile, getpid());
	    }

	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
			"caught SIGTERM, shutting down");
	    clean_parent_exit(0);
	}

	/* we've been told to restart */
	signal(SIGHUP, SIG_IGN);
	signal(SIGUSR1, SIG_IGN);

	if (one_process) {
	    /* not worth thinking about */
	    clean_parent_exit(0);
	}

	/* advance to the next generation */
	/* XXX: we really need to make sure this new generation number isn't in
	 * use by any of the children.
	 */
	++ap_my_generation;
	ap_scoreboard_image->global.running_generation = ap_my_generation;

	if (is_graceful) {
	    int i;
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
			"SIGUSR1 received.  Doing graceful restart");

	    /* kill off the idle ones */
	    if (ap_killpg(pgrp, SIGUSR1) < 0) {
		ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "killpg SIGUSR1");
	    }
	    /* This is mostly for debugging... so that we know what is still
	     * gracefully dealing with existing request.  But we can't really
	     * do it if we're in a SCOREBOARD_FILE because it'll cause
	     * corruption too easily.
	     */
	    for (i = 0; i < ap_daemons_limit; ++i) {
		if (ap_scoreboard_image->servers[i].status != SERVER_DEAD) {
		    ap_scoreboard_image->servers[i].status = SERVER_GRACEFUL;
		}
	    }
	}
	else {
	    /* Kill 'em off */
	    if (ap_killpg(pgrp, SIGHUP) < 0) {
		ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "killpg SIGHUP");
	    }
	    reclaim_child_processes(0);		/* Not when just starting up */
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
			"SIGHUP received.  Attempting to restart");
	}
    } while (restart_pending);

    /*add_common_vars(NULL);*/
}				/* standalone_main */
#else
/* prototype */
void STANDALONE_MAIN(int argc, char **argv);
#endif /* STANDALONE_MAIN */

extern char *optarg;
extern int optind;

int REALMAIN(int argc, char *argv[])
{
    int c;
    int sock_in;
    int sock_out;
    char *s;
    
    MONCONTROL(0);

    common_init();
    
    if ((s = strrchr(argv[0], PATHSEPARATOR)) != NULL) {
	ap_server_argv0 = ++s;
    }
    else {
	ap_server_argv0 = argv[0];
    }
    
    ap_cpystrn(ap_server_root, HTTPD_ROOT, sizeof(ap_server_root));
    ap_cpystrn(ap_server_confname, SERVER_CONFIG_FILE, sizeof(ap_server_confname));

    ap_setup_prelinked_modules();

    while ((c = getopt(argc, argv,
				    "D:C:c:xXd:Ff:vVlLR:StThUu46"
#ifdef DEBUG_SIGSTOP
				    "Z:"
#endif
			)) != -1) {
	char **new;
	switch (c) {
	case 'c':
	    new = (char **)ap_push_array(ap_server_post_read_config);
	    *new = ap_pstrdup(pcommands, optarg);
	    break;
	case 'C':
	    new = (char **)ap_push_array(ap_server_pre_read_config);
	    *new = ap_pstrdup(pcommands, optarg);
	    break;
	case 'D':
	    new = (char **)ap_push_array(ap_server_config_defines);
	    *new = ap_pstrdup(pcommands, optarg);
	    break;
	case 'd':
	    ap_cpystrn(ap_server_root, optarg, sizeof(ap_server_root));
	    break;
	case 'F':
	    do_detach = 0;
	    break;
	case 'f':
	    ap_cpystrn(ap_server_confname, optarg, sizeof(ap_server_confname));
	    break;
	case 'v':
	    ap_server_tokens = SrvTk_FULL;
	    ap_set_version();
	    printf("Server version: %s\n", ap_get_server_version());
	    exit(0);
	case 'V':
	    ap_server_tokens = SrvTk_FULL;
	    ap_set_version();
	    show_compile_settings();
	    exit(0);
	case 'l':
	    ap_suexec_enabled = init_suexec();
	    ap_show_modules();
	    exit(0);
	case 'L':
	    ap_show_directives();
	    exit(0);
	case 'X':
	    ++one_process;	/* Weird debugging mode. */
	    break;
#ifdef DEBUG_SIGSTOP
	case 'Z':
	    raise_sigstop_flags = atoi(optarg);
	    break;
#endif
	case 'S':
	    ap_dump_settings = 1;
	    break;
	case 't':
	    ap_configtestonly = 1;
	    ap_docrootcheck = 1;
	    break;
	case 'T':
	    ap_configtestonly = 1;
	    ap_docrootcheck = 0;
	    break;
	case 'h':
	    usage(argv[0]);
	    break;
	case '4':
	    ap_default_family = PF_INET;
	    break;
	case '6':
	    ap_default_family = PF_INET6;
	    break;
	case 'u':
	    ap_server_chroot = 0;
	    break;
	case 'U':
	    ap_default_family = PF_UNSPEC;
	    break;
	case '?':
	    usage(argv[0]);
	}
    }
    ap_init_alloc_shared(TRUE);

    ap_suexec_enabled = init_suexec();
    server_conf = ap_read_config(pconf, ptrans, ap_server_confname);

    ap_init_alloc_shared(FALSE);

    if (ap_configtestonly) {
        fprintf(stderr, "Syntax OK\n");
        clean_parent_exit(0);
    }
    if (ap_dump_settings) {
        clean_parent_exit(0);
    }

    child_timeouts = !ap_standalone || one_process;


    if (ap_standalone) {
	ap_open_logs(server_conf, plog);
	ap_set_version();
	ap_init_modules(pconf, server_conf);
	version_locked++;
	STANDALONE_MAIN(argc, argv);
    }
    else {
	conn_rec *conn;
	request_rec *r;
	BUFF *cio;
	struct sockaddr_storage sa_server, sa_client;
	NET_SIZE_T l;
	char servbuf[NI_MAXSERV];

	ap_set_version();
	/* Yes this is called twice. */
	ap_init_modules(pconf, server_conf);
	version_locked++;
	ap_open_logs(server_conf, plog);
	ap_init_modules(pconf, server_conf);
	set_group_privs();

    /* 
     * Only try to switch if we're running as root
     * In case of Cygwin we have the special super-user named SYSTEM
     * with a pre-defined uid.
     */
	if (!geteuid() && setuid(ap_user_id) == -1) {
	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
			"setuid: unable to change to uid: %u",
			ap_user_id);
	    exit(1);
	}
	if (ap_setjmp(jmpbuffer)) {
	    exit(0);
	}

    sock_in = fileno(stdin);
    sock_out = fileno(stdout);

	l = sizeof(sa_client);
	if ((getpeername(sock_in, (struct sockaddr *)&sa_client, &l)) < 0) {
/* get peername will fail if the input isn't a socket */
	    perror("getpeername");
	    memset(&sa_client, '\0', sizeof(sa_client));
	}

	l = sizeof(sa_server);
	if (getsockname(sock_in, (struct sockaddr *)&sa_server, &l) < 0) {
	    perror("getsockname");
	    fprintf(stderr, "Error getting local address\n");
	    exit(1);
	}
	if (getnameinfo(((struct sockaddr *)&sa_server), l,
			NULL, 0, servbuf, sizeof(servbuf), 
			NI_NUMERICSERV)){
	    fprintf(stderr, "getnameinfo(): family=%d\n", sa_server.ss_family);
	    exit(1);
	}
	servbuf[sizeof(servbuf)-1] = '\0';
	server_conf->port = atoi(servbuf);
	cio = ap_bcreate(ptrans, B_RDWR | B_SOCKET);
        cio->fd = sock_out;
        cio->fd_in = sock_in;
	conn = new_connection(ptrans, server_conf, cio,
			          (struct sockaddr *)&sa_client,
			          (struct sockaddr *)&sa_server, -1);

	while ((r = ap_read_request(conn)) != NULL) {

	    if (r->status == HTTP_OK)
		ap_process_request(r);

	    if (!conn->keepalive || conn->aborted)
		break;

	    ap_destroy_pool(r->pool);
	}

	ap_call_close_connection_hook(conn);

	ap_bclose(cio);
    }
    exit(0);
}

#include "httpd.h"
/*
 * Force ap_validate_password() into the image so that modules like
 * mod_auth can use it even if they're dynamically loaded.
 */
void suck_in_ap_validate_password(void);
void suck_in_ap_validate_password(void)
{
    ap_validate_password("a", "b");
}

/* force Expat to be linked into the server executable */
#if defined(USE_EXPAT)
#include "xmlparse.h"
const XML_LChar *suck_in_expat(void);
const XML_LChar *suck_in_expat(void)
{
    return XML_ErrorString(XML_ERROR_NONE);
}
#endif /* USE_EXPAT */

API_EXPORT(void) ap_server_strip_chroot(char *src, int force)
{
    char buf[MAX_STRING_LEN];

    if(src != NULL && ap_server_chroot && (is_chrooted || force)) {
	if (strncmp(ap_server_root, src, strlen(ap_server_root)) == 0) {
	    strlcpy(buf, src+strlen(ap_server_root), MAX_STRING_LEN);
	    strlcpy(src, buf, strlen(src));
	} 
    }
}

API_EXPORT(int) ap_server_is_chrooted()
{
    return(is_chrooted);
}

API_EXPORT(int) ap_server_chroot_desired()
{
    return(ap_server_chroot);
}
@


1.55
log
@typo in usage summary
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.54 2010/02/25 07:49:53 pyr Exp $ */
@


1.54
log
@fix some fallout from the >2G commit. namely allow for all byte counters to
report the correct size when it exceeds a long's capacity.

From Dan Harnett <daniel @@ harnett . name>
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.53 2008/12/02 17:55:35 sthen Exp $ */
d704 1
a704 1
    fprintf(stderr, "  -4               : assume IPv4 for ambiguous directirves (default)\n");
@


1.53
log
@correct spelling (ambigous -> ambiguous)
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.52 2008/05/21 11:28:48 mbalmer Exp $ */
d1247 1
a1247 1
		ss->my_bytes_served = 0L;
d1250 1
a1250 1
	    ss->conn_bytes = (unsigned long) 0;
d1312 1
a1312 1
    long int bs = 0;
d1324 3
a1326 3
    ss->bytes_served += (unsigned long) bs;
    ss->my_bytes_served += (unsigned long) bs;
    ss->conn_bytes += (unsigned long) bs;
@


1.52
log
@Remove #ifndef SIN6_LEN/#else/#endif constructs.

Suggested by djm a while ago.  No binary changes.
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.51 2008/05/21 08:57:38 mbalmer Exp $ */
d704 2
a705 2
    fprintf(stderr, "  -4               : assume IPv4 for ambigous directirves (default)\n");
    fprintf(stderr, "  -6               : assume IPv6 for ambigous directives\n");
d714 1
a714 1
    fprintf(stderr, "  -U               : unspecified address family for ambigous directives\n"); 
@


1.51
log
@Document and implement -U option, fix usage information for '-?'.

Documentation corrections and spelling by jmc.
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.50 2008/05/09 08:06:28 mbalmer Exp $ */
a1828 3
#ifndef SIN6_LEN
    addr_len = SA_LEN(saddr);
#else
a1829 1
#endif
a1838 3
#ifndef SIN6_LEN
    addr_len = SA_LEN(remaddr);
#else
a1839 1
#endif
d1909 2
a1910 7
    getnameinfo(server,
#ifndef SIN6_LEN
		SA_LEN(server),
#else
		server->sa_len,
#endif
		a0, sizeof(a0), p0, sizeof(p0), NI_NUMERICHOST | NI_NUMERICSERV);
d1980 1
a1980 6
#ifndef SIN6_LEN
    if (bind(s, server, SA_LEN(server)) == -1)
#else
    if (bind(s, server, server->sa_len) == -1)
#endif
    {
@


1.50
log
@Add support for IPv6 while keeping the default at IPv4 to not break
existing installations.  See the documentation for the IPv6 related
configuration.

This changes the module ABI since addresses are now struct addrinfo.

This has been tested by many people and run on production machines
for several months.

feedback many, ok todd
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.49 2007/08/09 10:44:54 martynas Exp $ */
d697 1
a697 1
    fprintf(stderr, "Usage: %s [-FhLlSTtuVvX] [-C directive] [-c directive] [-D parameter]\n", bin);
d704 2
d714 1
d3254 1
a3254 1
				    "D:C:c:xXd:Ff:vVlLR:StThu46"
d3329 3
@


1.49
log
@fix CVE-2007-3304

The Apache HTTP server did not verify that a process was an Apache child
process before sending it signals. A local attacker with the ability to
run scripts on the HTTP server could manipulate the scoreboard and cause
arbitrary processes to be terminated which could lead to a denial of
service.

ok miod@@ (who also noticed to protect reclaim_child_processes); henning@@;
djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.48 2007/05/25 21:27:16 krw Exp $ */
d171 2
a172 1
API_VAR_EXPORT struct in_addr ap_bind_address={0};
d1811 2
a1812 2
			     const struct sockaddr_in *remaddr,
			     const struct sockaddr_in *saddr,
d1816 2
d1826 9
a1834 3
    conn->local_addr = *saddr;
    conn->local_ip = ap_pstrdup(conn->pool,
				inet_ntoa(conn->local_addr.sin_addr));
d1840 9
a1848 3
    conn->remote_addr = *remaddr;
    conn->remote_ip = ap_pstrdup(conn->pool,
			      inet_ntoa(conn->remote_addr.sin_addr));
d1894 1
a1894 1
static int make_sock(pool *p, const struct sockaddr_in *server)
d1898 28
a1925 7
    char addr[512];

    if (server->sin_addr.s_addr != htonl(INADDR_ANY))
	ap_snprintf(addr, sizeof(addr), "address %s port %d",
		inet_ntoa(server->sin_addr), ntohs(server->sin_port));
    else
	ap_snprintf(addr, sizeof(addr), "port %d", ntohs(server->sin_port));
d1929 1
a1929 1
    if ((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
d1990 6
a1995 2

    if (bind(s, (struct sockaddr *) server, sizeof(struct sockaddr_in)) == -1) {
d2108 1
a2108 1
	    fd = make_sock(p, &lr->local_addr);
d2114 5
a2118 3
	FD_SET(fd, &listenfds);
	if (fd > listenmaxfd)
	    listenmaxfd = fd;
d2276 2
a2277 2
    struct sockaddr sa_server;
    struct sockaddr sa_client;
d2467 1
a2467 1
		csd = ap_accept(sd, &sa_client, &clen);
d2571 1
a2571 1
	if (getsockname(csd, &sa_server, &clen) < 0) {
d2590 2
a2591 2
				          (struct sockaddr_in *) &sa_client,
				          (struct sockaddr_in *) &sa_server,
d3251 1
a3251 1
				    "D:C:c:xXd:Ff:vVlLR:StThu"
d3317 7
a3358 1
	struct sockaddr sa_server, sa_client;
d3360 1
d3362 1
d3391 1
a3391 1
	if ((getpeername(sock_in, &sa_client, &l)) < 0) {
d3398 1
a3398 1
	if (getsockname(sock_in, &sa_server, &l) < 0) {
d3403 8
a3410 1
	server_conf->port = ntohs(((struct sockaddr_in *) &sa_server)->sin_port);
d3415 2
a3416 2
			          (struct sockaddr_in *) &sa_client,
			          (struct sockaddr_in *) &sa_server, -1);
@


1.48
log
@"interupt" -> "interrupt" in various comments. Mostly from Diego Casati.
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.47 2007/03/30 09:54:19 pyr Exp $ */
d1336 11
d1394 1
a1394 1
		kill(pid, SIGHUP);
d1407 1
a1407 1
		kill(pid, SIGTERM);
d1414 1
a1414 1
		kill(pid, SIGKILL);
d2792 1
a2792 1
		    kill(ps->pid, SIG_TIMEOUT_KILL);
d2804 1
a2804 1
	kill(ap_scoreboard_image->parent[to_kill].pid, SIG_IDLE_KILL);
@


1.47
log
@Restore full version reporting when using the -v and -V switch.
This unbreaks some configuration scripts.
ok henning@@, xsa@@, espie@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.46 2007/03/22 20:08:18 pyr Exp $ */
d1350 1
a1350 1
 	 * interupted, we'll wait longer than expected...
@


1.46
log
@remove default output of version numbers to silence confused auditing
programs.
prompted by deraadt@@ and cloder@@, ok cloder@@, henning@@, xsa@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.45 2006/07/28 14:07:22 henning Exp $ */
d3227 1
d3232 1
@


1.45
log
@avoid printing server built date, we set that to "unknown" anyway
leave the function there of course, it's part of the API
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.44 2006/05/15 16:49:14 henning Exp $ */
d298 1
a298 1
enum server_token_type ap_server_tokens = SrvTk_FULL;
d313 1
a313 1
    ap_server_tokens = SrvTk_FULL;
@


1.44
log
@set cur & max limits with MaxFOOPerChild instead of cur twice
From: John Wong <johnw@@wonghome.net>, ok ckuethe
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.43 2006/03/22 13:19:19 ray Exp $ */
a2101 1
    printf("Server built:   %s\n", ap_get_server_built());
a3024 2
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
		    "Server built: %s", ap_get_server_built());
a3228 1
	    printf("Server built:   %s\n", ap_get_server_built());
@


1.43
log
@Remove four unused functions: ap_sync_scoreboard_image, reopen_scoreboard,
put_scoreboard_info, and update_scoreboard_global.

From Daniel Ouellet, plus one line he missed.

OK henning@@ and otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.42 2006/02/22 15:07:12 henning Exp $ */
d2253 1
a2253 1
	rlp.rlim_cur = rlp.rlim_cur = ap_max_cpu_per_child ;
d2262 1
a2262 1
	rlp.rlim_cur = rlp.rlim_cur = ap_max_data_per_child ;
d2271 1
a2271 1
	rlp.rlim_cur = rlp.rlim_cur = ap_max_nofile_per_child ;
d2280 1
a2280 1
	rlp.rlim_cur = rlp.rlim_cur = ap_max_rss_per_child ;
d2289 1
a2289 1
	rlp.rlim_cur = rlp.rlim_cur = ap_max_stack_per_child ;
@


1.42
log
@allow ressource limits for child processes to be set.
from Chris Kuethe <chris.kuethe@@gmail.com>
running at UofA for months now, ok beck niallo, also tested mbalmer
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.41 2006/02/13 23:15:19 stevesk Exp $ */
a1178 4
static void reopen_scoreboard(pool *p)
{
}

a1203 4
ap_inline void ap_sync_scoreboard_image(void)
{
}

a1208 5
static ap_inline void put_scoreboard_info(int child_num,
				       short_score *new_score_rec)
{
}

a1229 1
    ap_sync_scoreboard_image();
a1277 1
    put_scoreboard_info(child_num, ss);
a1281 4
static void update_scoreboard_global(void)
{
}

a1288 1
    ap_sync_scoreboard_image();
a1303 2

    put_scoreboard_info(child_num, ss);
a1310 1
    ap_sync_scoreboard_image();
a1322 2

    put_scoreboard_info(child_num, ss);
a1345 2
    ap_sync_scoreboard_image();

a2308 1
    reopen_scoreboard(pchild);
a2359 1
	ap_sync_scoreboard_image();
a2488 1
	    ap_sync_scoreboard_image();
a2569 1
	    ap_sync_scoreboard_image();
a2734 1
    ap_sync_scoreboard_image();
a3044 1
		ap_sync_scoreboard_image();
a3134 1
	update_scoreboard_global();
a3149 1
	    ap_sync_scoreboard_image();
@


1.41
log
@spelling in error message; ok otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.40 2006/02/11 19:15:57 otto Exp $ */
d103 2
d160 5
d2254 1
d2275 49
@


1.40
log
@Fix a few "discards qualifier" warnings. From A. Farber in PR 5114.
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.39 2005/05/03 05:44:35 djm Exp $ */
d2953 1
a2953 1
			    "can't drop priviliges!");
@


1.39
log
@setres[ug]id; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.38 2005/02/09 12:13:09 henning Exp $ */
d3081 1
a3081 1
		const char *pidfile = NULL;
@


1.38
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.37 2004/12/04 12:43:35 jmc Exp $ */
d2950 2
a2951 2
		if (setegid(ap_group_id) || setgid(ap_group_id) ||
		    seteuid(ap_user_id) || setuid(ap_user_id)) {
@


1.37
log
@sync usage() w/ man page;
ok henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.36 2004/12/02 19:42:47 henning Exp $ */
a83 7
#ifndef SHARED_CORE_BOOTSTRAP
#ifndef SHARED_CORE_TIESTATIC

#ifdef SHARED_CORE
#define REALMAIN ap_main
int ap_main(int argc, char *argv[]);
#else
a84 1
#endif
a102 10
#ifdef USE_SHMGET_SCOREBOARD
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#endif
#ifdef SecureWare
#include <sys/security.h>
#include <sys/audit.h>
#include <prot.h>
#endif
a103 3
#ifdef HAVE_BSTRING_H
#include <bstring.h>		/* for IRIX, FD_SET calls bzero() */
#endif
a107 36
#ifdef MULTITHREAD
/* special debug stuff -- PCS */

/* Set this non-zero if you are prepared to put up with more than one log entry per second */
#define SEVERELY_VERBOSE	    0

  /* APD1() to APD5() are macros to help us debug. They can either
   * log to the screen or the error_log file. In release builds, these
   * macros do nothing. In debug builds, they send messages at priority
   * "debug" to the error log file, or if DEBUG_TO_CONSOLE is defined,
   * to the console.
   */

# ifdef _DEBUG
#  ifndef DEBUG_TO_CONSOLE
#   define APD1(a) ap_log_error(APLOG_MARK,APLOG_DEBUG|APLOG_NOERRNO,server_conf,a)
#   define APD2(a,b) ap_log_error(APLOG_MARK,APLOG_DEBUG|APLOG_NOERRNO,server_conf,a,b)
#   define APD3(a,b,c) ap_log_error(APLOG_MARK,APLOG_DEBUG|APLOG_NOERRNO,server_conf,a,b,c)
#   define APD4(a,b,c,d) ap_log_error(APLOG_MARK,APLOG_DEBUG|APLOG_NOERRNO,server_conf,a,b,c,d)
#   define APD5(a,b,c,d,e) ap_log_error(APLOG_MARK,APLOG_DEBUG|APLOG_NOERRNO,server_conf,a,b,c,d,e)
#  else
#   define APD1(a) printf("%s\n",a)
#   define APD2(a,b) do { printf(a,b);putchar('\n'); } while(0);
#   define APD3(a,b,c) do { printf(a,b,c);putchar('\n'); } while(0);
#   define APD4(a,b,c,d) do { printf(a,b,c,d);putchar('\n'); } while(0);
#   define APD5(a,b,c,d,e) do { printf(a,b,c,d,e);putchar('\n'); } while(0);
#  endif
# else /* !_DEBUG */
#  define APD1(a) 
#  define APD2(a,b) 
#  define APD3(a,b,c) 
#  define APD4(a,b,c,d) 
#  define APD5(a,b,c,d,e) 
# endif /* _DEBUG */
#endif /* MULTITHREAD */

a126 5

#ifdef MINT
long _stksize = 32768;
#endif

a142 1
#ifndef MULTITHREAD
a144 1
#endif
a156 3
#ifdef MULTIPLE_GROUPS
gid_t group_id_list[NGROUPS_MAX];
#endif
a182 9
#ifdef SO_ACCEPTFILTER
int ap_acceptfilter =
#ifdef AP_ACCEPTFILTER_OFF
	0;
#else
	1;
#endif
#endif

a184 1
#ifdef EAPI
a185 1
#endif /* EAPI */
a257 1
#ifndef NO_OTHER_CHILD
a267 1
#endif
a277 1
#ifndef MULTITHREAD
a278 1
#endif
a362 1
#ifdef EAPI
a383 1
#endif /* EAPI */
a455 1
#if defined(HAVE_FCNTL_SERIALIZED_ACCEPT) || defined(HAVE_FLOCK_SERIALIZED_ACCEPT)
a461 243
#endif

#if defined (HAVE_USLOCK_SERIALIZED_ACCEPT)
#include <ulocks.h>
static ulock_t uslock = NULL;

#define accept_mutex_child_init_uslock(x)

static void accept_mutex_init_uslock(pool *p)
{
    ptrdiff_t old;
    usptr_t *us;


    /* default is 8, allocate enough for all the children plus the parent */
    if ((old = usconfig(CONF_INITUSERS, HARD_SERVER_LIMIT + 1)) == -1) {
	perror("usconfig(CONF_INITUSERS)");
	exit(-1);
    }

    if ((old = usconfig(CONF_LOCKTYPE, US_NODEBUG)) == -1) {
	perror("usconfig(CONF_LOCKTYPE)");
	exit(-1);
    }
    if ((old = usconfig(CONF_ARENATYPE, US_SHAREDONLY)) == -1) {
	perror("usconfig(CONF_ARENATYPE)");
	exit(-1);
    }
    if ((us = usinit("/dev/zero")) == NULL) {
	perror("usinit");
	exit(-1);
    }

    if ((uslock = usnewlock(us)) == NULL) {
	perror("usnewlock");
	exit(-1);
    }
}

static void accept_mutex_on_uslock(void)
{
    switch (ussetlock(uslock)) {
    case 1:
	/* got lock */
	break;
    case 0:
	fprintf(stderr, "didn't get lock\n");
	clean_child_exit(APEXIT_CHILDFATAL);
    case -1:
	perror("ussetlock");
	clean_child_exit(APEXIT_CHILDFATAL);
    }
}

static void accept_mutex_off_uslock(void)
{
    if (usunsetlock(uslock) == -1) {
	perror("usunsetlock");
	clean_child_exit(APEXIT_CHILDFATAL);
    }
}

accept_mutex_methods_s accept_mutex_uslock_s = {
    NULL,
    accept_mutex_init_uslock,
    accept_mutex_on_uslock,
    accept_mutex_off_uslock,
    "uslock"
};
#endif

#if defined (HAVE_PTHREAD_SERIALIZED_ACCEPT)

/* This code probably only works on Solaris ... but it works really fast
 * on Solaris.  Note that pthread mutexes are *NOT* released when a task
 * dies ... the task has to free it itself.  So we block signals and
 * try to be nice about releasing the mutex.
 */

#include <pthread.h>

static pthread_mutex_t *accept_mutex = (void *)(caddr_t) -1;
static int have_accept_mutex;
static sigset_t accept_block_mask;
static sigset_t accept_previous_mask;

static void accept_mutex_child_cleanup_pthread(void *foo)
{
    if (accept_mutex != (void *)(caddr_t)-1
	&& have_accept_mutex) {
	pthread_mutex_unlock(accept_mutex);
    }
}

static void accept_mutex_child_init_pthread(pool *p)
{
    ap_register_cleanup(p, NULL, accept_mutex_child_cleanup_pthread, ap_null_cleanup);
}

static void accept_mutex_cleanup_pthread(void *foo)
{
    if (accept_mutex != (void *)(caddr_t)-1
	&& munmap((caddr_t) accept_mutex, sizeof(*accept_mutex))) {
	perror("munmap");
    }
    accept_mutex = (void *)(caddr_t)-1;
}

/* remove_sync_sigs() is from APR 0.9.4
 *
 * It is invalid to block synchronous signals, as such signals must
 * be delivered on the thread that generated the original error
 * (e.g., invalid storage reference).  Blocking them interferes
 * with proper recovery.
 */
static void remove_sync_sigs(sigset_t *sig_mask)
{
#ifdef SIGABRT
    sigdelset(sig_mask, SIGABRT);
#endif
#ifdef SIGBUS
    sigdelset(sig_mask, SIGBUS);
#endif
#ifdef SIGEMT
    sigdelset(sig_mask, SIGEMT);
#endif
#ifdef SIGFPE
    sigdelset(sig_mask, SIGFPE);
#endif
#ifdef SIGILL
    sigdelset(sig_mask, SIGILL);
#endif
#ifdef SIGIOT
    sigdelset(sig_mask, SIGIOT);
#endif
#ifdef SIGPIPE
    sigdelset(sig_mask, SIGPIPE);
#endif
#ifdef SIGSEGV
    sigdelset(sig_mask, SIGSEGV);
#endif
#ifdef SIGSYS
    sigdelset(sig_mask, SIGSYS);
#endif
#ifdef SIGTRAP
    sigdelset(sig_mask, SIGTRAP);
#endif

/* APR logic to remove SIGUSR2 not copied */
}

static void accept_mutex_init_pthread(pool *p)
{
    pthread_mutexattr_t mattr;
    int fd;

    fd = open("/dev/zero", O_RDWR);
    if (fd == -1) {
	perror("open(/dev/zero)");
	exit(APEXIT_INIT);
    }
    accept_mutex = (pthread_mutex_t *) mmap((caddr_t) 0, sizeof(*accept_mutex),
				 PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (accept_mutex == (void *) (caddr_t) - 1) {
	perror("mmap /dev/zero");
	exit(APEXIT_INIT);
    }
    close(fd);
    if ((errno = pthread_mutexattr_init(&mattr))) {
	perror("pthread_mutexattr_init");
	exit(APEXIT_INIT);
    }
    if ((errno = pthread_mutexattr_setpshared(&mattr,
						PTHREAD_PROCESS_SHARED))) {
	perror("pthread_mutexattr_setpshared");
	exit(APEXIT_INIT);
    }
    if ((errno = pthread_mutex_init(accept_mutex, &mattr))) {
	perror("pthread_mutex_init");
	exit(APEXIT_INIT);
    }
    sigfillset(&accept_block_mask);
    sigdelset(&accept_block_mask, SIGHUP);
    sigdelset(&accept_block_mask, SIGTERM);
    sigdelset(&accept_block_mask, SIGUSR1);
    remove_sync_sigs(&accept_block_mask);
    ap_register_cleanup(p, NULL, accept_mutex_cleanup_pthread, ap_null_cleanup);
}

static void accept_mutex_on_pthread(void)
{
    int err;

    if (sigprocmask(SIG_BLOCK, &accept_block_mask, &accept_previous_mask)) {
	perror("sigprocmask(SIG_BLOCK)");
	clean_child_exit(APEXIT_CHILDFATAL);
    }
    /* We need to block alarms here, since if we get killed *right* after 
     * locking the mutex, have_accept_mutex will not be set, and our
     * child cleanup will not work.
     */
    ap_block_alarms();
    if ((err = pthread_mutex_lock(accept_mutex))) {
	errno = err;
	perror("pthread_mutex_lock");
	clean_child_exit(APEXIT_CHILDFATAL);
    }
    have_accept_mutex = 1;
    ap_unblock_alarms();
}

static void accept_mutex_off_pthread(void)
{
    int err;

    /* Have to block alarms here, or else we might have a double-unlock, which
     * is possible with pthread mutexes, since they are designed to be fast,
     * and hence not necessarily make checks for ownership or multiple unlocks.
     */
    ap_block_alarms(); 
    if ((err = pthread_mutex_unlock(accept_mutex))) {
	errno = err;
	perror("pthread_mutex_unlock");
	clean_child_exit(APEXIT_CHILDFATAL);
    }
    have_accept_mutex = 0;
    ap_unblock_alarms();
    if (sigprocmask(SIG_SETMASK, &accept_previous_mask, NULL)) {
	perror("sigprocmask(SIG_SETMASK)");
	clean_child_exit(1);
    }
}

accept_mutex_methods_s accept_mutex_pthread_s = {
    accept_mutex_child_init_pthread,
    accept_mutex_init_pthread,
    accept_mutex_on_pthread,
    accept_mutex_off_pthread,
    "pthread"
};
#endif

#if defined (HAVE_SYSVSEM_SERIALIZED_ACCEPT)
a466 9
#ifdef NEED_UNION_SEMUN
union semun {
    int val;
    struct semid_ds *buf;
    ushort *array;
};

#endif

a554 81
#endif

#if defined(HAVE_FCNTL_SERIALIZED_ACCEPT)
static struct flock lock_it;
static struct flock unlock_it;

static int lock_fd = -1;

#define accept_mutex_child_init_fcntl(x)

/*
 * Initialize mutex lock.
 * Must be safe to call this on a restart.
 */
static void accept_mutex_init_fcntl(pool *p)
{

    lock_it.l_whence = SEEK_SET;	/* from current point */
    lock_it.l_start = 0;		/* -"- */
    lock_it.l_len = 0;			/* until end of file */
    lock_it.l_type = F_WRLCK;		/* set exclusive/write lock */
    lock_it.l_pid = 0;			/* pid not actually interesting */
    unlock_it.l_whence = SEEK_SET;	/* from current point */
    unlock_it.l_start = 0;		/* -"- */
    unlock_it.l_len = 0;		/* until end of file */
    unlock_it.l_type = F_UNLCK;		/* set exclusive/write lock */
    unlock_it.l_pid = 0;		/* pid not actually interesting */

    expand_lock_fname(p);
    lock_fd = ap_popenf_ex(p, ap_lock_fname, O_CREAT | O_WRONLY | O_EXCL, 0644, 1);
    if (lock_fd == -1) {
	perror("open");
	fprintf(stderr, "Cannot open lock file: %s\n", ap_lock_fname);
	exit(APEXIT_INIT);
    }
    unlink(ap_lock_fname);
}

static void accept_mutex_on_fcntl(void)
{
    int ret;

    while ((ret = fcntl(lock_fd, F_SETLKW, &lock_it)) < 0 && errno == EINTR) {
	/* nop */
    }

    if (ret < 0) {
	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
		    "fcntl: F_SETLKW: Error getting accept lock, exiting!  "
		    "Perhaps you need to use the LockFile directive to place "
		    "your lock file on a local disk!");
	clean_child_exit(APEXIT_CHILDFATAL);
    }
}

static void accept_mutex_off_fcntl(void)
{
    int ret;

    while ((ret = fcntl(lock_fd, F_SETLKW, &unlock_it)) < 0 && errno == EINTR) {
	/* nop */
    }
    if (ret < 0) {
	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
		    "fcntl: F_SETLKW: Error freeing accept lock, exiting!  "
		    "Perhaps you need to use the LockFile directive to place "
		    "your lock file on a local disk!");
	clean_child_exit(APEXIT_CHILDFATAL);
    }
}

accept_mutex_methods_s accept_mutex_fcntl_s = {
    NULL,
    accept_mutex_init_fcntl,
    accept_mutex_on_fcntl,
    accept_mutex_off_fcntl,
    "fcntl"
};
#endif

#if defined(HAVE_FLOCK_SERIALIZED_ACCEPT)
a625 19
#endif

/* Generally, HAVE_NONE_SERIALIZED_ACCEPT simply won't work but
 * for testing purposes, here it is... */
#if defined HAVE_NONE_SERIALIZED_ACCEPT
#if !defined(MULTITHREAD)
/* Multithreaded systems don't complete between processes for
 * the sockets. */
#define NO_SERIALIZED_ACCEPT
#endif 

accept_mutex_methods_s accept_mutex_none_s = {
    NULL,
    NULL,
    NULL,
    NULL,
    "none"
};
#endif
a637 5
#if defined USE_USLOCK_SERIALIZED_ACCEPT
    t = "uslock";
#elif defined USE_PTHREAD_SERIALIZED_ACCEPT
    t = "pthread";
#elif defined USE_SYSVSEM_SERIALIZED_ACCEPT
a638 24
#elif defined USE_FCNTL_SERIALIZED_ACCEPT
    t = "fcntl";
#elif defined USE_FLOCK_SERIALIZED_ACCEPT
    t = "flock";
#elif defined USE_OS2SEM_SERIALIZED_ACCEPT
    t = "os2sem";
#elif defined USE_TPF_CORE_SERIALIZED_ACCEPT
    t = "tpfcore";
#elif defined USE_BEOS_SERIALIZED_ACCEPT
    t = "beos_sem";
#elif defined USE_NONE_SERIALIZED_ACCEPT
    t = "none";
#else
    t = "default";
#endif
#if defined HAVE_USLOCK_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"uslock"))))
    	return "uslock";
#endif
#if defined HAVE_PTHREAD_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"pthread"))))
    	return "pthread";
#endif
#if defined HAVE_SYSVSEM_SERIALIZED_ACCEPT
a640 6
#endif
#if defined HAVE_FCNTL_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"fcntl"))))
    	return "fcntl";
#endif
#if defined HAVE_FLOCK_SERIALIZED_ACCEPT
a642 6
#endif
#if defined HAVE_NONE_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"none"))))
    	return "none";
#endif

a653 11
#if defined HAVE_USLOCK_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"uslock"))) {
    	amutex = &accept_mutex_uslock_s;
    } else 
#endif
#if defined HAVE_PTHREAD_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"pthread"))) {
    	amutex = &accept_mutex_pthread_s;
    } else 
#endif
#if defined HAVE_SYSVSEM_SERIALIZED_ACCEPT
a656 7
#endif
#if defined HAVE_FCNTL_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"fcntl"))) {
    	amutex = &accept_mutex_fcntl_s;
    } else
#endif
#if defined HAVE_FLOCK_SERIALIZED_ACCEPT
a659 6
#endif
#if defined HAVE_NONE_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"none"))) {
    	amutex = &accept_mutex_none_s;
    } else
#endif
a678 1
#ifdef SINGLE_LISTEN_UNSERIALIZED_ACCEPT
a679 3
#else
#define SAFE_ACCEPT(stmt) do {stmt;} while(0)
#endif
a689 3
#ifdef SHARED_CORE
    fprintf(stderr, "       %s [-d serverroot] [-f config] [-R libexecdir]\n", pad);
#else
a690 1
#endif
a700 3
#ifdef SHARED_CORE
    fprintf(stderr, "  -R libexecdir    : specify an alternate location for shared object files\n");
#endif
a780 1
#ifdef EAPI
a781 1
#endif /* EAPI */
a790 1
#ifdef EAPI
a791 1
#endif /* EAPI */
a850 3
#ifndef OPTIMIZE_TIMEOUTS
    old = alarm(x);
#else
a862 1
#endif
d935 1
a935 2
 * calls to shutdown only half of the connection.  You should define
 * NO_LINGCLOSE in ap_config.h if such is the case for your system.
a940 19
#ifdef USE_SO_LINGER
#define NO_LINGCLOSE		/* The two lingering options are exclusive */

static void sock_enable_linger(int s)
{
    struct linger li;

    li.l_onoff = 1;
    li.l_linger = MAX_SECS_TO_LINGER;

    if (setsockopt(s, SOL_SOCKET, SO_LINGER,
		   (char *) &li, sizeof(struct linger)) < 0) {
	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf,
	            "setsockopt: (SO_LINGER)");
	/* not a fatal error */
    }
}

#else
a941 3
#endif /* USE_SO_LINGER */

#ifndef NO_LINGCLOSE
a985 1
#ifdef EAPI
a986 1
#endif /* EAPI */
a990 1
#ifdef EAPI
a991 1
#endif /* EAPI */
a1039 1
#endif /* ndef NO_LINGCLOSE */
a1044 1
#ifndef NO_OTHER_CHILD
a1145 1
#endif
d1156 19
a1174 7
#ifdef MULTITHREAD
/*
 * In the multithreaded mode, have multiple threads - not multiple
 * processes that need to talk to each other. Just use a simple
 * malloc. But let the routines that follow, think that you have
 * shared memory (so they use memcpy etc.)
 */
d1176 1
d1179 4
a1182 2
    ap_assert(!ap_scoreboard_image);
    ap_scoreboard_image = (scoreboard *) malloc(SCOREBOARD_SIZE);
d1184 1
a1184 1
	fprintf(stderr, "Ouch!  Out of memory reiniting scoreboard!\n");
d1187 1
d1190 12
a1201 1
void cleanup_scoreboard(void)
a1202 3
    ap_assert(ap_scoreboard_image);
    free(ap_scoreboard_image);
    ap_scoreboard_image = NULL;
d1205 1
a1205 1
API_EXPORT(void) ap_sync_scoreboard_image(void)
d1207 1
d1210 1
a1210 341

#else /* MULTITHREAD */
#if defined(USE_POSIX_SCOREBOARD)
#include <sys/mman.h>
/* 
 * POSIX 1003.4 style
 *
 * Note 1: 
 * As of version 4.23A, shared memory in QNX must reside under /dev/shmem,
 * where no subdirectories allowed.
 *
 * POSIX shm_open() and shm_unlink() will take care about this issue,
 * but to avoid confusion, I suggest to redefine scoreboard file name
 * in httpd.conf to cut "logs/" from it. With default setup actual name
 * will be "/dev/shmem/logs.apache_status". 
 * 
 * If something went wrong and Apache did not unlinked this object upon
 * exit, you can remove it manually, using "rm -f" command.
 * 
 * Note 2:
 * <sys/mman.h> in QNX defines MAP_ANON, but current implementation 
 * does NOT support BSD style anonymous mapping. So, the order of 
 * conditional compilation is important: 
 * this #ifdef section must be ABOVE the next one (BSD style).
 *
 * I tested this stuff and it works fine for me, but if it provides 
 * trouble for you, just comment out USE_MMAP_SCOREBOARD in QNX section
 * of ap_config.h
 *
 * June 5, 1997, 
 * Igor N. Kovalenko -- infoh@@mail.wplus.net
 */

static void cleanup_shared_mem(void *d)
{
    shm_unlink(ap_scoreboard_fname);
}

static void setup_shared_mem(pool *p)
{
    char buf[512];
    caddr_t m;
    int fd;

    fd = shm_open(ap_scoreboard_fname, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
    if (fd == -1) {
	ap_snprintf(buf, sizeof(buf), "%s: could not open(create) scoreboard",
		    ap_server_argv0);
	perror(buf);
	exit(APEXIT_INIT);
    }
    if (ltrunc(fd, (off_t) SCOREBOARD_SIZE, SEEK_SET) == -1) {
	ap_snprintf(buf, sizeof(buf), "%s: could not ltrunc scoreboard",
		    ap_server_argv0);
	perror(buf);
	shm_unlink(ap_scoreboard_fname);
	exit(APEXIT_INIT);
    }
    if ((m = (caddr_t) mmap((caddr_t) 0,
			    (size_t) SCOREBOARD_SIZE, PROT_READ | PROT_WRITE,
			    MAP_SHARED, fd, (off_t) 0)) == (caddr_t) - 1) {
	ap_snprintf(buf, sizeof(buf), "%s: cannot mmap scoreboard",
		    ap_server_argv0);
	perror(buf);
	shm_unlink(ap_scoreboard_fname);
	exit(APEXIT_INIT);
    }
    close(fd);
    ap_register_cleanup(p, NULL, cleanup_shared_mem, ap_null_cleanup);
    ap_scoreboard_image = (scoreboard *) m;
    ap_scoreboard_image->global.running_generation = 0;
}

static void reopen_scoreboard(pool *p)
{
}

#elif defined(USE_MMAP_SCOREBOARD)

static void setup_shared_mem(pool *p)
{
    caddr_t m;

#if defined(MAP_ANON)
/* BSD style */
#if defined(MAP_TMPFILE)
    {
	char mfile[] = "/tmp/apache_shmem_XXXX";
	int fd = mkstemp(mfile);
	if (fd == -1) {
	    perror("open");
	    fprintf(stderr, "%s: Could not open %s\n", ap_server_argv0, mfile);
	    exit(APEXIT_INIT);
	}
	m = mmap((caddr_t) 0, SCOREBOARD_SIZE,
		PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (m == (caddr_t) - 1) {
	    perror("mmap");
	    fprintf(stderr, "%s: Could not mmap %s\n", ap_server_argv0, mfile);
	    exit(APEXIT_INIT);
	}
	close(fd);
	unlink(mfile);
    }
#else
    m = mmap((caddr_t) 0, SCOREBOARD_SIZE,
	     PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0);
#endif
    if (m == (caddr_t) - 1) {
	perror("mmap");
	fprintf(stderr, "%s: Could not mmap memory\n", ap_server_argv0);
	exit(APEXIT_INIT);
    }
#else
/* Sun style */
    int fd;

    fd = open("/dev/zero", O_RDWR);
    if (fd == -1) {
	perror("open");
	fprintf(stderr, "%s: Could not open /dev/zero\n", ap_server_argv0);
	exit(APEXIT_INIT);
    }
    m = mmap((caddr_t) 0, SCOREBOARD_SIZE,
	     PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (m == (caddr_t) - 1) {
	perror("mmap");
	fprintf(stderr, "%s: Could not mmap /dev/zero\n", ap_server_argv0);
	exit(APEXIT_INIT);
    }
    close(fd);
#endif
    ap_scoreboard_image = (scoreboard *) m;
    ap_scoreboard_image->global.running_generation = 0;
}

static void reopen_scoreboard(pool *p)
{
}

#elif defined(USE_SHMGET_SCOREBOARD)
static key_t shmkey = IPC_PRIVATE;
static int shmid = -1;

static void setup_shared_mem(pool *p)
{
    struct shmid_ds shmbuf;
#ifdef MOVEBREAK
    char *obrk;
#endif

    if ((shmid = shmget(shmkey, SCOREBOARD_SIZE, IPC_CREAT | SHM_R | SHM_W)) == -1) {
	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
                     "could not call shmget");
	exit(APEXIT_INIT);
    }

    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
		"created shared memory segment #%d", shmid);

#ifdef MOVEBREAK
    /*
     * Some SysV systems place the shared segment WAY too close
     * to the dynamic memory break point (sbrk(0)). This severely
     * limits the use of malloc/sbrk in the program since sbrk will
     * refuse to move past that point.
     *
     * To get around this, we move the break point "way up there",
     * attach the segment and then move break back down. Ugly
     */
    if ((obrk = sbrk(MOVEBREAK)) == (char *) -1) {
	ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
	    "sbrk() could not move break");
    }
#endif

#define BADSHMAT	((scoreboard *)(-1))
    if ((ap_scoreboard_image = (scoreboard *) shmat(shmid, 0, 0)) == BADSHMAT) {
	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf, "shmat error");
	/*
	 * We exit below, after we try to remove the segment
	 */
    }
    /* only worry about permissions if we attached the segment
       and we want/need to change the uid/gid */
    else if (ap_change_shmem_uid) {
	if (shmctl(shmid, IPC_STAT, &shmbuf) != 0) {
	    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
		"shmctl() could not stat segment #%d", shmid);
	}
	else {
	    shmbuf.shm_perm.uid = ap_user_id;
	    shmbuf.shm_perm.gid = ap_group_id;
	    if (shmctl(shmid, IPC_SET, &shmbuf) != 0) {
		ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
		    "shmctl() could not set segment #%d", shmid);
	    }
	}
    }
    /*
     * We must avoid leaving segments in the kernel's
     * (small) tables.
     */
    if (shmctl(shmid, IPC_RMID, NULL) != 0) {
	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf,
		"shmctl: IPC_RMID: could not remove shared memory segment #%d",
		shmid);
    }
    if (ap_scoreboard_image == BADSHMAT)	/* now bailout */
	exit(APEXIT_INIT);

#ifdef MOVEBREAK
    if (obrk == (char *) -1)
	return;			/* nothing else to do */
    if (sbrk(-(MOVEBREAK)) == (char *) -1) {
	ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
	    "sbrk() could not move break back");
    }
#endif
    ap_scoreboard_image->global.running_generation = 0;
}

static void reopen_scoreboard(pool *p)
{
}

#else
#define SCOREBOARD_FILE
static scoreboard _scoreboard_image;
static int scoreboard_fd = -1;

/* XXX: things are seriously screwed if we ever have to do a partial
 * read or write ... we could get a corrupted scoreboard
 */
static int force_write(int fd, void *buffer, int bufsz)
{
    int rv, orig_sz = bufsz;

    do {
	rv = write(fd, buffer, bufsz);
	if (rv > 0) {
	    buffer = (char *) buffer + rv;
	    bufsz -= rv;
	}
    } while ((rv > 0 && bufsz > 0) || (rv == -1 && errno == EINTR));

    return rv < 0 ? rv : orig_sz - bufsz;
}

static int force_read(int fd, void *buffer, int bufsz)
{
    int rv, orig_sz = bufsz;

    do {
	rv = read(fd, buffer, bufsz);
	if (rv > 0) {
	    buffer = (char *) buffer + rv;
	    bufsz -= rv;
	}
    } while ((rv > 0 && bufsz > 0) || (rv == -1 && errno == EINTR));

    return rv < 0 ? rv : orig_sz - bufsz;
}

static void cleanup_scoreboard_file(void *foo)
{
    unlink(ap_scoreboard_fname);
}

void reopen_scoreboard(pool *p)
{
    if (scoreboard_fd != -1)
	ap_pclosef(p, scoreboard_fd);

    scoreboard_fd = ap_popenf_ex(p, ap_scoreboard_fname, O_CREAT | O_BINARY | O_RDWR, 0666, 1);
    if (scoreboard_fd == -1) {
	perror(ap_scoreboard_fname);
	fprintf(stderr, "Cannot open scoreboard file:\n");
	clean_child_exit(1);
    }
}
#endif

/* Called by parent process */
static void reinit_scoreboard(pool *p)
{
    int running_gen = 0;
    if (ap_scoreboard_image)
	running_gen = ap_scoreboard_image->global.running_generation;

#ifndef SCOREBOARD_FILE
    if (ap_scoreboard_image == NULL) {
	setup_shared_mem(p);
    }
    memset(ap_scoreboard_image, 0, SCOREBOARD_SIZE);
    ap_scoreboard_image->global.running_generation = running_gen;
#else
    ap_scoreboard_image = &_scoreboard_image;
    ap_scoreboard_fname = ap_server_root_relative(p, ap_scoreboard_fname);

    scoreboard_fd = ap_popenf_ex(p, ap_scoreboard_fname, O_CREAT | O_BINARY | O_RDWR, 0644, 1);
    if (scoreboard_fd == -1) {
	perror(ap_scoreboard_fname);
	fprintf(stderr, "Cannot open scoreboard file:\n");
	exit(APEXIT_INIT);
    }
    ap_register_cleanup(p, NULL, cleanup_scoreboard_file, ap_null_cleanup);

    memset((char *) ap_scoreboard_image, 0, sizeof(*ap_scoreboard_image));
    ap_scoreboard_image->global.running_generation = running_gen;
    force_write(scoreboard_fd, ap_scoreboard_image, sizeof(*ap_scoreboard_image));
#endif
}

/* Routines called to deal with the scoreboard image
 * --- note that we do *not* need write locks, since update_child_status
 * only updates a *single* record in place, and only one process writes to
 * a given scoreboard slot at a time (either the child process owning that
 * slot, or the parent, noting that the child has died).
 *
 * As a final note --- setting the score entry to getpid() is always safe,
 * since when the parent is writing an entry, it's only noting SERVER_DEAD
 * anyway.
 */

ap_inline void ap_sync_scoreboard_image(void)
{
#ifdef SCOREBOARD_FILE
    lseek(scoreboard_fd, 0L, 0);
    force_read(scoreboard_fd, ap_scoreboard_image, sizeof(*ap_scoreboard_image));
#endif
}

#endif /* MULTITHREAD */

API_EXPORT(int) ap_exists_scoreboard_image(void)
{
    return (ap_scoreboard_image ? 1 : 0);
}

static ap_inline void put_scoreboard_info(int child_num,
a1212 4
#ifdef SCOREBOARD_FILE
    lseek(scoreboard_fd, (long) child_num * sizeof(short_score), 0);
    force_write(scoreboard_fd, new_score_rec, sizeof(short_score));
#endif
a1220 1
#ifdef EAPI
a1221 1
#endif
a1240 1
#ifdef OPTIMIZE_TIMEOUTS
a1241 1
#endif
a1243 3
#ifndef OPTIMIZE_TIMEOUTS
	ss->last_used = time(NULL);
#endif
a1283 5
#ifdef SCOREBOARD_FILE
	lseek(scoreboard_fd, XtOffsetOf(scoreboard, parent[child_num]), 0);
	force_write(scoreboard_fd, &ap_scoreboard_image->parent[child_num],
	    sizeof(parent_score));
#endif
a1291 6
#ifdef SCOREBOARD_FILE
    lseek(scoreboard_fd,
	  (char *) &ap_scoreboard_image->global -(char *) ap_scoreboard_image, 0);
    force_write(scoreboard_fd, &ap_scoreboard_image->global,
		sizeof ap_scoreboard_image->global);
#endif
a1296 3
#if defined(NO_GETTIMEOFDAY) && !defined(NO_TIMES)
    struct tms tms_blk;
#endif
a1304 6
#if defined(NO_GETTIMEOFDAY)
#ifndef NO_TIMES
	if ((ss->start_time = times(&tms_blk)) == -1)
#endif /* NO_TIMES */
	    ss->start_time = (clock_t) 0;
#else
a1307 1
#endif
a1309 6
#if defined(NO_GETTIMEOFDAY)
#ifndef NO_TIMES
	if ((ss->stop_time = times(&tms_blk)) == -1)
#endif
	    ss->stop_time = ss->start_time = (clock_t) 0;
#else
a1314 1
#endif
a1331 1
#ifndef NO_TIMES
a1332 1
#endif
a1355 1
#ifndef MULTITHREAD
a1361 1
#ifndef NO_OTHER_CHILD
a1362 1
#endif
a1441 1
#ifndef NO_OTHER_CHILD
a1461 1
#endif
a1466 1
#endif /* ndef MULTITHREAD */
a1469 23
#if defined(NEED_WAITPID)
/*
   Systems without a real waitpid sometimes lose a child's exit while waiting
   for another.  Search through the scoreboard for missing children.
 */
int reap_children(ap_wait_t *status)
{
    int n, pid;

    for (n = 0; n < max_daemons_limit; ++n) {
        ap_sync_scoreboard_image();
	if (ap_scoreboard_image->servers[n].status != SERVER_DEAD &&
		kill((pid = ap_scoreboard_image->parent[n].pid), 0) == -1) {
	    ap_update_child_status(n, SERVER_DEAD, NULL);
	    /* just mark it as having a successful exit status */
	    bzero((char *) status, sizeof(ap_wait_t));
	    return(pid);
	}
    }
    return 0;
}
#endif

a1487 1
#ifndef NO_OTHER_CHILD
a1488 1
#endif
a1496 5
#ifdef NEED_WAITPID
    if ((ret = reap_children(status)) > 0) {
	return ret;
    }
#endif
a1512 3
#ifdef SYS_SIGLIST /* platform has sys_siglist[] */
#define INIT_SIGLIST()  /*nothing*/
#else /* platform has no sys_siglist[], define our own */
a1522 1
#ifdef SIGHUP
a1523 2
#endif
#ifdef SIGINT
a1524 2
#endif
#ifdef SIGQUIT
a1525 2
#endif
#ifdef SIGILL
a1526 2
#endif
#ifdef SIGTRAP
a1527 2
#endif
#ifdef SIGIOT
a1528 2
#endif
#ifdef SIGABRT
a1529 2
#endif
#ifdef SIGEMT
a1530 2
#endif
#ifdef SIGFPE
a1531 2
#endif
#ifdef SIGKILL
a1532 2
#endif
#ifdef SIGBUS
a1533 2
#endif
#ifdef SIGSEGV
a1534 2
#endif
#ifdef SIGSYS
a1535 2
#endif
#ifdef SIGPIPE
a1536 2
#endif
#ifdef SIGALRM
a1537 2
#endif
#ifdef SIGTERM
a1538 2
#endif
#ifdef SIGUSR1
a1539 2
#endif
#ifdef SIGUSR2
a1540 5
#endif
#ifdef SIGCLD
    ap_sys_siglist[SIGCLD] = "Child status change";
#endif
#ifdef SIGCHLD
a1541 5
#endif
#ifdef SIGPWR
    ap_sys_siglist[SIGPWR] = "Power-fail restart";
#endif
#ifdef SIGWINCH
a1542 2
#endif
#ifdef SIGURG
a1543 5
#endif
#ifdef SIGPOLL
    ap_sys_siglist[SIGPOLL] = "Pollable event occurred";
#endif
#ifdef SIGIO
a1544 2
#endif
#ifdef SIGSTOP
a1545 2
#endif
#ifdef SIGTSTP
a1546 2
#endif
#ifdef SIGCONT
a1547 2
#endif
#ifdef SIGTTIN
a1548 2
#endif
#ifdef SIGTTOU
a1549 2
#endif
#ifdef SIGVTALRM
a1550 2
#endif
#ifdef SIGPROF
a1551 2
#endif
#ifdef SIGXCPU
a1552 2
#endif
#ifdef SIGXFSZ
a1553 1
#endif
a1557 2
#endif /* platform has sys_siglist[] */

a1653 1
#ifndef NO_USE_SIGACTION
a1660 3
#if defined(SA_ONESHOT)
	sa.sa_flags = SA_ONESHOT;
#elif defined(SA_RESETHAND)
a1661 6
#endif
#ifdef SIGSEGV_CHECK
	if (sigaction(SIGSEGV, &sa, NULL) < 0)
	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGSEGV)");
#endif /* SIGSEGV_CHECK */
#ifdef SIGBUS
a1663 6
#endif
#ifdef SIGABORT
	if (sigaction(SIGABORT, &sa, NULL) < 0)
	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGABORT)");
#endif
#ifdef SIGABRT
a1665 2
#endif
#ifdef SIGILL
a1667 1
#endif
a1672 1
#ifdef SIGINT
a1674 2
#endif
#ifdef SIGXCPU
a1677 2
#endif
#ifdef SIGXFSZ
a1680 2
#endif
#ifdef SIGPIPE
a1683 1
#endif
a1692 36
#else
    if (!one_process) {
#ifdef SIGSEGV_CHECK
	signal(SIGSEGV, sig_coredump);
#endif /* SIGSEGV_CHECK */
#ifdef SIGBUS
	signal(SIGBUS, sig_coredump);
#endif /* SIGBUS */
#ifdef SIGABORT
	signal(SIGABORT, sig_coredump);
#endif /* SIGABORT */
#ifdef SIGABRT
	signal(SIGABRT, sig_coredump);
#endif /* SIGABRT */
#ifdef SIGILL
	signal(SIGILL, sig_coredump);
#endif /* SIGILL */
#ifdef SIGXCPU
	signal(SIGXCPU, SIG_DFL);
#endif /* SIGXCPU */
#ifdef SIGXFSZ
	signal(SIGXFSZ, SIG_DFL);
#endif /* SIGXFSZ */
    }
    signal(SIGTERM, sig_term);
#ifdef SIGHUP
    signal(SIGHUP, restart);
#endif /* SIGHUP */
#ifdef SIGUSR1
    signal(SIGUSR1, restart);
#endif /* SIGUSR1 */
#ifdef SIGPIPE
    signal(SIGPIPE, SIG_IGN);
#endif /* SIGPIPE */

#endif
a1714 1
#ifndef NO_SETSID
a1722 7
#else
    if ((pgrp = setpgrp(getpid(), 0)) == -1) {
	perror("setpgrp");
	fprintf(stderr, "%s: setpgrp failed\n", ap_server_argv0);
	exit(1);
    }
#endif
a1774 2
	/* OS/2 and TPF don't support groups. */

a1793 7
#ifdef MULTIPLE_GROUPS
	if (getgroups(NGROUPS_MAX, group_id_list) == -1) {
	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
			"getgroups: unable to get group list");
	    clean_child_exit(APEXIT_CHILDFATAL);
	}
#endif /* MULTIPLE_GROUPS */
a1842 1
#ifdef EAPI
a1843 1
#endif /* EAPI */
a1844 1
#ifdef EAPI
a1856 1
#endif /* EAPI */
a1860 1
#if defined(TCP_NODELAY) && !defined(MPE) && !defined(TPF)
a1887 4
#else
#define sock_disable_nagle(s, c)	/* NOOP */
#endif

a1909 17
    /* Solaris (probably versions 2.4, 2.5, and 2.5.1 with various levels
     * of tcp patches) has some really weird bugs where if you dup the
     * socket now it breaks things across SIGHUP restarts.  It'll either
     * be unable to bind, or it won't respond.
     */

    /* PR#1282 Unixware 1.x appears to have the same problem as solaris */
#if defined (UW) && UW < 200
#define WORKAROUND_SOLARIS_BUG
#endif

    /* PR#1973 NCR SVR4 systems appear to have the same problem */
#if defined (MPRAS)
#define WORKAROUND_SOLARIS_BUG
#endif

#ifndef WORKAROUND_SOLARIS_BUG
a1912 1
#endif
a1921 1
#if defined(SO_KEEPALIVE) && !defined(MPE)
a1929 1
#endif
a1980 35
#ifdef SO_ACCEPTFILTER
    if (ap_acceptfilter) {
#ifndef ACCEPT_FILTER_NAME
#define ACCEPT_FILTER_NAME "httpready"
#ifdef __FreeBSD_version
#if __FreeBSD_version < 411000 /* httpready broken before 4.1.1 */
#undef ACCEPT_FILTER_NAME
#define ACCEPT_FILTER_NAME "dataready"
#endif
#endif
#endif /* ! ACCEPT_FILTER_NAME */
	/*
	 * See htdocs/manual/misc/perf-bsd44.html for a discussion of
	 * how to enable this feature and various issues with it.
	 */
	struct accept_filter_arg af = {
	    ACCEPT_FILTER_NAME, ""
	};
	if (setsockopt(s, SOL_SOCKET, SO_ACCEPTFILTER, &af, sizeof(af)) < 0) {
            if (errno == ENOPROTOOPT) {
	    	ap_log_error(APLOG_MARK, APLOG_INFO | APLOG_NOERRNO, server_conf,
			 "socket option SO_ACCEPTFILTER unknown on this machine. Continuing.");
	     } else {
	    	ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_INFO, server_conf,
			 "make_sock: for %s, setsockopt: (SO_ACCEPTFILTER)", addr);
	     }
	}
    }
#endif

#ifdef WORKAROUND_SOLARIS_BUG
    s = ap_slack(s, AP_SLACK_HIGH);

    ap_note_cleanups_for_socket_ex(p, s, 1);	/* arrange to close on exec or restart */
#endif
a1982 1
#ifdef CHECK_FD_SETSIZE
a1992 1
#endif
a2095 11
#ifdef NO_SERIALIZED_ACCEPT
    /* warn them about the starvation problem if they're using multiple
     * sockets
     */
    if (ap_listeners->next != ap_listeners) {
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_CRIT, NULL,
		    "You cannot use multiple Listens safely on your system, "
		    "proceeding anyway.  See src/PORTING, search for "
		    "SERIALIZED_ACCEPT.");
    }
#endif
a2125 1
#ifdef EAPI
a2126 1
#endif
a2132 7
#ifdef BIG_SECURITY_HOLE
    printf(" -D BIG_SECURITY_HOLE\n");
#endif
#ifdef SECURITY_HOLE_PASS_AUTHORIZATION
    printf(" -D SECURITY_HOLE_PASS_AUTHORIZATION\n");
#endif
#ifdef HAVE_MMAP
a2133 2
#endif
#ifdef HAVE_SHMGET
a2134 2
#endif
#ifdef USE_MMAP_SCOREBOARD
a2135 8
#endif
#ifdef USE_SHMGET_SCOREBOARD
    printf(" -D USE_SHMGET_SCOREBOARD\n");
#endif
#ifdef USE_POSIX_SCOREBOARD
    printf(" -D USE_POSIX_SCOREBOARD\n");
#endif
#ifdef USE_MMAP_FILES
a2139 11
#endif /*USE_MMAP_FILES*/
#ifdef NO_WRITEV
    printf(" -D NO_WRITEV\n");
#endif
#ifdef NO_LINGCLOSE
    printf(" -D NO_LINGCLOSE\n");
#endif
#ifdef HAVE_FCNTL_SERIALIZED_ACCEPT
    printf(" -D HAVE_FCNTL_SERIALIZED_ACCEPT\n");
#endif
#ifdef HAVE_FLOCK_SERIALIZED_ACCEPT
a2140 5
#endif
#ifdef HAVE_USLOCK_SERIALIZED_ACCEPT
    printf(" -D HAVE_USLOCK_SERIALIZED_ACCEPT\n");
#endif
#ifdef HAVE_SYSVSEM_SERIALIZED_ACCEPT
a2141 8
#endif
#ifdef HAVE_PTHREAD_SERIALIZED_ACCEPT
    printf(" -D HAVE_PTHREAD_SERIALIZED_ACCEPT\n");
#endif
#ifdef HAVE_NONE_SERIALIZED_ACCEPT
    printf(" -D HAVE_NONE_SERIALIZED_ACCEPT\n");
#endif
#ifdef SINGLE_LISTEN_UNSERIALIZED_ACCEPT
a2142 7
#endif
#ifdef NO_OTHER_CHILD
    printf(" -D NO_OTHER_CHILD\n");
#endif
#ifdef NO_RELIABLE_PIPED_LOGS
    printf(" -D NO_RELIABLE_PIPED_LOGS\n");
#endif
a2150 16
#ifdef MULTITHREAD
    printf(" -D MULTITHREAD\n");
#endif
#ifdef NEED_HASHBANG_EMUL
    printf(" -D NEED_HASHBANG_EMUL\n");
#endif
#ifdef SHARED_CORE
    printf(" -D SHARED_CORE\n");
#endif
#ifdef SO_ACCEPTFILTER
    printf(" -D SO_ACCEPTFILTER\n");
    printf(" -D ACCEPT_FILTER_NAME=\"" ACCEPT_FILTER_NAME "\"\n");
#endif
#ifdef AP_ACCEPTFILTER_OFF
    printf(" -D AP_ACCEPTFILTER_OFF\n");
#endif
d2156 1
a2156 1
#if defined(SUEXEC_BIN) && !defined(TPF)
a2158 3
#if defined(SHARED_CORE) && defined(SHARED_CORE_DIR)
    printf(" -D SHARED_CORE_DIR=\"" SHARED_CORE_DIR "\"\n");
#endif
a2207 1
#ifdef EAPI
a2220 1
#endif /* EAPI */
a2222 1
#ifndef MULTITHREAD
a2304 1
#ifdef SIGURG
a2305 1
#endif
a2411 18

#ifdef EPROTO
		    /* EPROTO on certain older kernels really means
		     * ECONNABORTED, so we need to ignore it for them.
		     * See discussion in new-httpd archives nh.9701
		     * search for EPROTO.
		     *
		     * Also see nh.9603, search for EPROTO:
		     * There is potentially a bug in Solaris 2.x x<6,
		     * and other boxes that implement tcp sockets in
		     * userland (i.e. on top of STREAMS).  On these
		     * systems, EPROTO can actually result in a fatal
		     * loop.  See PR#981 for example.  It's hard to
		     * handle both uses of EPROTO.
		     */
                case EPROTO:
#endif
#ifdef ECONNABORTED
a2412 1
#endif
a2420 1
#ifdef ECONNRESET
a2421 2
#endif
#ifdef ETIMEDOUT
a2422 2
#endif
#ifdef EHOSTUNREACH
a2423 2
#endif
#ifdef ENETUNREACH
a2424 1
#endif
a2425 1
#ifdef ENETDOWN
a2443 1
#endif /*ENETDOWN*/
a2477 1
#ifdef CHECK_FD_SETSIZE
a2484 1
#endif
a2506 10
#ifdef B_SFIO
	(void) sfdisc(conn_io->sf_in, SF_POPDISC);
	sfdisc(conn_io->sf_in, bsfio_new(conn_io->pool, conn_io));
	sfsetbuf(conn_io->sf_in, NULL, 0);

	(void) sfdisc(conn_io->sf_out, SF_POPDISC);
	sfdisc(conn_io->sf_out, bsfio_new(conn_io->pool, conn_io));
	sfsetbuf(conn_io->sf_out, NULL, 0);
#endif

a2507 19
#if defined(NEED_DUPPED_CSD)
	if ((dupped_csd = dup(csd)) < 0) {
	    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
			"dup: couldn't duplicate csd");
	    dupped_csd = csd;	/* Oh well... */
	}
	ap_note_cleanups_for_socket_ex(ptrans, dupped_csd, 1);

	/* protect various fd_sets */
#ifdef CHECK_FD_SETSIZE
	if (dupped_csd >= FD_SETSIZE) {
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
		"[dupped_csd] filedescriptor (%u) larger than FD_SETSIZE (%u) "
		"found, you probably need to rebuild Apache with a "
		"larger FD_SETSIZE", dupped_csd, FD_SETSIZE);
	    continue;
	}
#endif
#endif
a2544 1
#ifdef EAPI
a2545 1
#endif /* EAPI */
a2572 6
#ifdef NO_LINGCLOSE
#ifdef EAPI
	ap_call_close_connection_hook(current_conn);
#endif /* EAPI */
	ap_bclose(conn_io);	/* just close it */
#else
a2580 1
#ifdef EAPI
a2581 1
#endif /* EAPI */
a2584 1
#endif
a2599 1
#ifdef SIGQUIT
a2600 1
#endif
a2628 12
#ifdef AIX_BIND_PROCESSOR
/* by default AIX binds to a single processor
 * this bit unbinds children which will then bind to another cpu
 */
#include <sys/processor.h>
	int status = bindprocessor(BINDPROCESS, (int)getpid(), 
				   PROCESSOR_CLASS_ANY);
	if (status != OK) {
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, server_conf,
			"processor unbind failed %d", status);
	}
#endif
a2640 1
#ifdef OPTIMIZE_TIMEOUTS
a2641 1
#endif
a2642 6
#ifdef SCOREBOARD_FILE
    lseek(scoreboard_fd, XtOffsetOf(scoreboard, parent[slot]), 0);
    force_write(scoreboard_fd, &ap_scoreboard_image->parent[slot],
		sizeof(parent_score));
#endif

a2743 1
#ifdef OPTIMIZE_TIMEOUTS
a2759 1
#endif
a2843 2
#ifdef SYS_SIGLIST
#ifdef WCOREDUMP
a2853 1
#endif
a2857 1
#ifdef WCOREDUMP
a2858 7
#endif
#else
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE,
			 server_conf,
			 "child pid %d exit signal %d",
			 pid, WTERMSIG(status));
#endif
a2893 6
#ifdef SCOREBOARD_FILE
	else if (scoreboard_fd != -1) {
	    ap_kill_cleanup(pconf, NULL, cleanup_scoreboard_file);
	    ap_kill_cleanups_for_fd(pconf, scoreboard_fd);
	}
#endif
a2966 7
#ifdef SCOREBOARD_FILE
	else {
	    ap_scoreboard_fname = ap_server_root_relative(pconf, ap_scoreboard_fname);
	    ap_note_cleanups_for_fd_ex(pconf, scoreboard_fd, 1); /* close on exec */
	}
#endif

a3033 1
#ifndef NO_OTHER_CHILD
a3036 1
#endif
a3113 1
#ifndef SCOREBOARD_FILE
a3114 1
#endif
a3121 1
#ifndef SCOREBOARD_FILE
a3132 1
#endif
a3154 6
/* Cygwin 1.x SHARED_CORE support needs REALMAIN to be declared as dllexport,
 * so we can later while SHARED_CORE_BOOTSTRAP is compiled and linked see the 
 * dllimport for it. -- Stipe Tolj <tolj@@wapme-systems.de>
 */


a3161 15
#ifdef SecureWare
    if (set_auth_parameters(argc, argv) < 0)
	perror("set_auth_parameters");
    if (getluid() < 0)
	if (setluid(getuid()) < 0)
	    perror("setluid");
    if (setreuid(0, 0) < 0)
	perror("setreuid");
#endif

#ifdef SOCKS
    SOCKSinit(argv[0]);
#endif


a3230 9
#ifdef SHARED_CORE
	case 'R':
	    /* just ignore this option here, because it has only
	     * effect when SHARED_CORE is used and then it was
	     * already handled in the Shared Core Bootstrap
	     * program.
	     */
	    break;
#endif
a3250 1
#ifdef EAPI
a3251 1
#endif
a3255 1
#ifdef EAPI
a3256 1
#endif
a3259 1
#ifdef EAPI
a3260 3
#else
        exit(0);
#endif
a3262 1
#ifdef EAPI
a3263 3
#else
        exit(0);
#endif
a3340 1
#ifdef EAPI
a3341 1
#endif /* EAPI */
d3348 1
a3348 75
#else /* ndef MULTITHREAD */


/**********************************************************************
 * Multithreaded implementation
 *
 * This code is fairly specific to Win32.
 *
 * The model used to handle requests is a set of threads. One "main"
 * thread listens for new requests. When something becomes
 * available, it does a select and places the newly available socket
 * onto a list of "jobs" (add_job()). Then any one of a fixed number
 * of "worker" threads takes the top job off the job list with
 * remove_job() and handles that connection to completion. After
 * the connection has finished the thread is free to take another
 * job from the job list.
 *
 * In the code, the "main" thread is running within the worker_main()
 * function. The first thing this function does is create the
 * worker threads, which operate in the child_sub_main() function. The
 * main thread then goes into a loop within worker_main() where they
 * do a select() on the listening sockets. The select times out once
 * per second so that the thread can check for an "exit" signal
 * from the parent process (see below). If this signal is set, the 
 * thread can exit, but only after it has accepted all incoming
 * connections already in the listen queue (since Win32 appears
 * to through away listened but unaccepted connections when a 
 * process dies).
 *
 * Because the main and worker threads exist within a single process
 * they are vulnerable to crashes or memory leaks (crashes can also
 * be caused within modules, of course). There also needs to be a 
 * mechanism to perform restarts and shutdowns. This is done by
 * creating the main & worker threads within a subprocess. A
 * main process (the "parent process") creates one (or more) 
 * processes to do the work, then the parent sits around waiting
 * for the working process to die, in which case it starts a new
 * one. The parent process also handles restarts (by creating
 * a new working process then signalling the previous working process 
 * exit ) and shutdowns (by signalling the working process to exit).
 * The parent process operates within the master_main() function. This
 * process also handles requests from the service manager (NT only).
 *
 * Signalling between the parent and working process uses a Win32
 * event. Each child has a unique name for the event, which is
 * passed to it with the -Z argument when the child is spawned. The
 * parent sets (signals) this event to tell the child to die.
 * At present all children do a graceful die - they finish all
 * current jobs _and_ empty the listen queue before they exit.
 * A non-graceful die would need a second event. The -Z argument in
 * the child is also used to create the shutdown and restart events,
 * since the prefix (apPID) contains the parent process PID.
 *
 * The code below starts with functions at the lowest level -
 * worker threads, and works up to the top level - the main()
 * function of the parent process.
 *
 * The scoreboard (in process memory) contains details of the worker
 * threads (within the active working process). There is no shared
 * "scoreboard" between processes, since only one is ever active
 * at once (or at most, two, when one has been told to shutdown but
 * is processes outstanding requests, and a new one has been started).
 * This is controlled by a "start_mutex" which ensures only one working
 * process is active at once.
 **********************************************************************/

/* The code protected by #ifdef UNGRACEFUL_RESTARTS/#endif sections
 * could implement a sort-of ungraceful restart for Win32. instead of
 * graceful restarts. 
 *
 * However it does not work too well because it does not intercept a
 * connection already in progress (in child_sub_main()). We'd have to
 * get that to poll on the exit event. 
 */

d3350 2
a3351 1
 * Definition of jobs, shared by main and worker threads.
d3353 2
a3354 34

typedef struct joblist_s {
    struct joblist_s *next;
    int sock;
} joblist;

/*
 * Globals common to main and worker threads. This structure is not
 * used by the parent process.
 */

typedef struct globals_s {
#ifdef UNGRACEFUL_RESTART
    HANDLE thread_exit_event;
#else
    int exit_now;
#endif
    semaphore *jobsemaphore;
    joblist *jobhead;
    joblist *jobtail;
    mutex *jobmutex;
    int jobcount;
} globals;

globals allowed_globals =
{0, NULL, NULL, NULL, NULL, 0};

/*
 * add_job()/remove_job() - add or remove an accepted socket from the
 * list of sockets connected to clients. allowed_globals.jobmutex protects
 * against multiple concurrent access to the linked list of jobs.
 */

void add_job(int sock)
d3356 1
a3356 90
    joblist *new_job;
    
    ap_assert(allowed_globals.jobmutex);

    /* TODO: If too many jobs in queue, sleep, check for problems */
    ap_acquire_mutex(allowed_globals.jobmutex);
    new_job = (joblist *) malloc(sizeof(joblist));
    if (new_job == NULL) {
	fprintf(stderr, "Ouch!  Out of memory in add_job()!\n");
    }
    new_job->next = NULL;
    new_job->sock = sock;
    if (allowed_globals.jobtail != NULL)
	allowed_globals.jobtail->next = new_job;
    allowed_globals.jobtail = new_job;
    if (!allowed_globals.jobhead)
	allowed_globals.jobhead = new_job;
    allowed_globals.jobcount++;
    release_semaphore(allowed_globals.jobsemaphore);
    ap_release_mutex(allowed_globals.jobmutex);
}

int remove_job(int csd)
{
    static reported = 0;
    static active_threads = 0;
    joblist *job;
    int sock;

    /* Decline decrementing active_threads count on the first call
     * to remove_job.  csd == -1 implies that this is the thread's
     * first call to remove_job.
     */
    if (csd != -1) {
        active_threads--;
    }

#ifdef UNGRACEFUL_RESTART
    HANDLE hObjects[2];
    int rv;

    hObjects[0] = allowed_globals.jobsemaphore;
    hObjects[1] = allowed_globals.thread_exit_event;

    rv = WaitForMultipleObjects(2, hObjects, FALSE, INFINITE);
    ap_assert(rv != WAIT_FAILED);
    if (rv == WAIT_OBJECT_0 + 1) {
	/* thread_exit_now */
	APD1("thread got exit now event");
	return -1;
    }
    /* must be semaphore */
#else
    acquire_semaphore(allowed_globals.jobsemaphore);
#endif
    ap_assert(allowed_globals.jobmutex);

#ifdef UNGRACEFUL_RESTART
    if (!allowed_globals.jobhead) {
#else
    ap_acquire_mutex(allowed_globals.jobmutex);
    if (allowed_globals.exit_now && !allowed_globals.jobhead) {
#endif
	ap_release_mutex(allowed_globals.jobmutex);
	return (-1);
    }

    job = allowed_globals.jobhead;
    ap_assert(job);
    allowed_globals.jobhead = job->next;
    if (allowed_globals.jobhead == NULL)
	allowed_globals.jobtail = NULL;

    ap_release_mutex(allowed_globals.jobmutex);
    sock = job->sock;
    free(job);

    /* If sock == -1 then the thread is about to exit so 
     * don't count it as active.
     */
    if (sock != -1)
        active_threads++;

    if (!reported && (active_threads == ap_threads_per_child)) {
        reported = 1;
        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
                     "Server ran out of threads to serve requests. Consider "
                     "raising the ThreadsPerChild setting");
    }
    return (sock);
a3358 1428
/*
 * child_sub_main() - this is the main loop for the worker threads
 *
 * Each thread runs within this function. They wait within remove_job()
 * for a job to become available, then handle all the requests on that
 * connection until it is closed, then return to remove_job().
 *
 * The worker thread will exit when it removes a job which contains
 * socket number -1. This provides a graceful thread exit, since
 * it will never exit during a connection.
 *
 * This code in this function is basically equivalent to the child_main()
 * from the multi-process (Unix) environment, except that we
 *
 *  - do not call child_init_modules (child init API phase)
 *  - block in remove_job, and when unblocked we have an already
 *    accepted socket, instead of blocking on a mutex or select().
 */

static void child_sub_main(int child_num)
{
    NET_SIZE_T clen;
    struct sockaddr sa_server;
    struct sockaddr sa_client;
    pool *ptrans;
    int requests_this_child = 0;
    int csd = -1;
    int dupped_csd = -1;
    int srv = 0;

    ap_thread_count++;
    ptrans = ap_make_sub_pool(pconf);

    (void) ap_update_child_status(child_num, SERVER_READY, (request_rec *) NULL);

    /*
     * Setup the jump buffers so that we can return here after a timeout.
     */
#if defined(USE_LONGJMP)
    setjmp(jmpbuffer);
#else
    sigsetjmp(jmpbuffer, 1);
#endif
#if defined(SIGURG)
    signal(SIGURG, timeout);
#endif


    while (1) {
	BUFF *conn_io;
	request_rec *r;
	
	/*
	 * (Re)initialize this child to a pre-connection state.
	 */
	 
	ap_set_callback_and_alarm(NULL, 0); /* Cancel any outstanding alarms */
	timeout_req = NULL;                 /* No request in progress */
	current_conn = NULL;
	ap_clear_pool(ptrans);

	(void) ap_update_child_status(child_num, SERVER_READY,
	                              (request_rec *) NULL);

	/* Get job from the job list. This will block until a job is ready.
	 * If -1 is returned then the main thread wants us to exit.
	 */
	csd = remove_job(csd);
	if (csd == -1)
	    break;		/* time to exit */

	requests_this_child++;

	ap_note_cleanups_for_socket_ex(ptrans, csd, 1);

	/*
	 * We now have a connection, so set it up with the appropriate
	 * socket options, file descriptors, and read/write buffers.
	 */

	clen = sizeof(sa_server);	
	if (getsockname(csd, &sa_server, &clen) < 0) {
	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "getsockname");
	    continue;
	}
	clen = sizeof(sa_client);
	if ((getpeername(csd, &sa_client, &clen)) < 0) {
	    /* get peername will fail if the input isn't a socket */
	    perror("getpeername");
	    memset(&sa_client, '\0', sizeof(sa_client));
	}

	sock_disable_nagle(csd, (struct sockaddr_in *)&sa_client);

	(void) ap_update_child_status(child_num, SERVER_BUSY_READ,
				   (request_rec *) NULL);

	conn_io = ap_bcreate(ptrans, B_RDWR | B_SOCKET);
	dupped_csd = csd;
#if defined(NEED_DUPPED_CSD)
	if ((dupped_csd = dup(csd)) < 0) {
	    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
			"dup: couldn't duplicate csd");
	    dupped_csd = csd;	/* Oh well... */
	}
	ap_note_cleanups_for_socket_ex(ptrans, dupped_csd, 1);
#endif
	ap_bpushfd(conn_io, csd, dupped_csd);

	current_conn = new_connection(ptrans, server_conf, conn_io,
				          (struct sockaddr_in *) &sa_client,
				          (struct sockaddr_in *) &sa_server,
				          child_num);
				          
	/*
	 * Read and process each request found on our connection
	 * until no requests are left or we decide to close.
	 */
	while ((r = ap_read_request(current_conn)) != NULL) {
            (void) ap_update_child_status(child_num, SERVER_BUSY_WRITE, r);

	    if (r->status == HTTP_OK)
		ap_process_request(r);

	    if (ap_extended_status)
		increment_counts(child_num, r);
	    if (!current_conn->keepalive || current_conn->aborted)
		break;
            /* If the server is shutting down, do not allow anymore requests 
             * to be handled on the keepalive connection. Leave the thread 
             * alive to drain the job queue. This check is particularly 
             * important on the threaded server to allow the process to be 
             * quickly taken down cleanly.
             */
            if (allowed_globals.exit_now)
                break;
	    ap_destroy_pool(r->pool);
	    (void) ap_update_child_status(child_num, SERVER_BUSY_KEEPALIVE,
				       (request_rec *) NULL);

	    ap_sync_scoreboard_image();
	}

	/*
	 * Close the connection, being careful to send out whatever is still
	 * in our buffers.  If possible, try to avoid a hard close until the
	 * client has ACKed our FIN and/or has stopped sending us data.
	 */
	ap_kill_cleanups_for_socket(ptrans, csd);

#ifdef NO_LINGCLOSE
#ifdef EAPI
	ap_call_close_connection_hook(current_conn);
#endif /* EAPI */
	ap_bclose(conn_io);	/* just close it */
#else
	if (r && r->connection
	    && !r->connection->aborted
	    && r->connection->client
	    && (r->connection->client->fd >= 0)) {

	    lingering_close(r);
	}
	else {
#ifdef EAPI
	    ap_call_close_connection_hook(current_conn);
#endif /* EAPI */
	    ap_bsetflag(conn_io, B_EOUT, 1);
	    ap_bclose(conn_io);
	}
#endif
    }
    ap_destroy_pool(ptrans);
    (void) ap_update_child_status(child_num, SERVER_DEAD, NULL);
    
    ap_thread_count--;
}


void child_main(int child_num_arg)
{
    /*
     * Only reason for this function, is to pass in
     * arguments to child_sub_main() on its stack so
     * that longjump doesn't try to corrupt its local
     * variables and I don't need to make those
     * damn variables static/global
     */
    child_sub_main(child_num_arg);
}



void cleanup_thread(thread **handles, int *thread_cnt, int thread_to_clean)
{
    int i;

    free_thread(handles[thread_to_clean]);
    for (i = thread_to_clean; i < ((*thread_cnt) - 1); i++)
	handles[i] = handles[i + 1];
    (*thread_cnt)--;
}
/*****************************************************************
 * Executive routines.
 */

extern void main_control_server(void *); /* in hellop.c */

event *exit_event;
mutex *start_mutex;

#define MAX_SIGNAL_NAME 30  /* Long enough for apPID_shutdown, where PID is an int */
char signal_name_prefix[MAX_SIGNAL_NAME];
char signal_restart_name[MAX_SIGNAL_NAME]; 
char signal_shutdown_name[MAX_SIGNAL_NAME];

#define MAX_SELECT_ERRORS 100

/*
 * Initialise the signal names, in the global variables signal_name_prefix, 
 * signal_restart_name and signal_shutdown_name.
 */

void setup_signal_names(char *prefix)
{
    ap_snprintf(signal_name_prefix, sizeof(signal_name_prefix), prefix);    
    ap_snprintf(signal_shutdown_name, sizeof(signal_shutdown_name), 
	"%s_shutdown", signal_name_prefix);    
    ap_snprintf(signal_restart_name, sizeof(signal_restart_name), 
	"%s_restart", signal_name_prefix);    

    APD2("signal prefix %s", signal_name_prefix);
}

static void setup_inherited_listeners(pool *p)
{
    HANDLE pipe;
    listen_rec *lr;
    int fd;
    WSAPROTOCOL_INFO WSAProtocolInfo;
    DWORD BytesRead;

    /* Setup the listeners */
    listenmaxfd = -1;
    FD_ZERO(&listenfds);

    /* Open the pipe to the parent process to receive the inherited socket
     * data. The sockets have been set to listening in the parent process.
     */
    pipe = GetStdHandle(STD_INPUT_HANDLE);
    for (lr = ap_listeners; lr; lr = lr->next) {
        if (!ReadFile(pipe, &WSAProtocolInfo, sizeof(WSAPROTOCOL_INFO), 
                      &BytesRead, (LPOVERLAPPED) NULL)) {
            ap_log_error(APLOG_MARK, APLOG_WIN32ERROR|APLOG_CRIT, server_conf,
                         "setup_inherited_listeners: Unable to read socket data from parent");
            signal_parent(0);	/* tell parent to die */
            exit(1);
        }
        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
                         "BytesRead = %d WSAProtocolInfo = %x20", BytesRead, WSAProtocolInfo);
        fd = WSASocket(FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO,
                       &WSAProtocolInfo, 0, 0);
        if (fd == INVALID_SOCKET) {
            ap_log_error(APLOG_MARK, APLOG_WIN32ERROR|APLOG_CRIT, server_conf,
                         "setup_inherited_listeners: WSASocket failed to open the inherited socket.");
            signal_parent(0);	/* tell parent to die */
            exit(1);
        }
        if (fd >= 0) {
            FD_SET(fd, &listenfds);
            if (fd > listenmaxfd)
                listenmaxfd = fd;
        }
        ap_note_cleanups_for_socket_ex(p, fd, 1);
        lr->fd = fd;
        if (lr->next == NULL) {
            /* turn the list into a ring */
            lr->next = ap_listeners;
            break;
        }
    }
    head_listener = ap_listeners;
    close_unused_listeners();
    CloseHandle(pipe);
    return;
}

/*
 * worker_main() is main loop for the child process. The loop in
 * this function becomes the controlling thread for the actually working
 * threads (which run in a loop in child_sub_main()).
 */
 
void worker_main(void)
{
    int nthreads;
    fd_set main_fds;
    int srv;
    int clen;
    int csd;
    struct sockaddr_in sa_client;
    int total_jobs = 0;
    thread **child_handles;
    int rv;
    time_t end_time;
    int i;
    struct timeval tv;
    int wait_time = 1;
    int max_jobs_per_exe;
    int max_jobs_after_exit_request;
    HANDLE hObjects[2];

    int count_select_errors = 0;
    pool *pchild;

    pchild = ap_make_sub_pool(pconf);

    ap_standalone = 1;
    sd = -1;
    nthreads = ap_threads_per_child;
    max_jobs_after_exit_request = ap_excess_requests_per_child;
    max_jobs_per_exe = ap_max_requests_per_child;
    if (nthreads <= 0)
	nthreads = 40;
    if (max_jobs_per_exe <= 0)
	max_jobs_per_exe = 0;
    if (max_jobs_after_exit_request <= 0)
	max_jobs_after_exit_request = max_jobs_per_exe / 10;

    if (!one_process)
	detach();

    my_pid = getpid();

    ++ap_my_generation;

    copy_listeners(pconf);
    ap_restart_time = time(NULL);

    reinit_scoreboard(pconf);
    
    /*
     * Wait until we have permission to start accepting connections.
     * start_mutex is used to ensure that only one child ever
     * goes into the listen/accept loop at once. Also wait on exit_event,
     * in case we (this child) is told to die before we get a chance to
     * serve any requests.
     */
    hObjects[0] = (HANDLE)start_mutex;
    hObjects[1] = (HANDLE)exit_event;
    rv = WaitForMultipleObjects(2, hObjects, FALSE, INFINITE);
    if (rv == WAIT_FAILED) {
	ap_log_error(APLOG_MARK,APLOG_ERR|APLOG_WIN32ERROR, server_conf,
                     "Waiting for start_mutex or exit_event -- process will exit");

	ap_destroy_pool(pchild);
	cleanup_scoreboard();
	exit(1);
    }
    if (rv == WAIT_OBJECT_0 + 1) {
	/* exit event signalled - exit now */
	ap_destroy_pool(pchild);
	cleanup_scoreboard();
	exit(0);
    }
    /* start_mutex obtained, continue into the select() loop */
    if (one_process) {
        setup_listeners(pconf);
    } else {
        /* Get listeners from the parent process */
        setup_inherited_listeners(pconf);
    }

    if (listenmaxfd == -1) {
	/* Help, no sockets were made, better log something and exit */
	ap_log_error(APLOG_MARK, APLOG_CRIT|APLOG_NOERRNO, NULL,
		    "No sockets were created for listening");

	signal_parent(0);	/* tell parent to die */

	ap_destroy_pool(pchild);
	cleanup_scoreboard();
	exit(1);
    }
    set_signals();

    /*
     * - Initialize allowed_globals
     * - Create the thread table
     * - Spawn off threads
     * - Create listen socket set (done above)
     * - loop {
     *       wait for request
     *       create new job
     *   } while (!time to exit)
     * - Close all listeners
     * - Wait for all threads to complete
     * - Exit
     */

    ap_child_init_modules(pconf, server_conf);

    allowed_globals.jobsemaphore = create_semaphore(0);
    allowed_globals.jobmutex = ap_create_mutex(NULL);

    /* spawn off the threads */
    child_handles = (thread *) alloca(nthreads * sizeof(int));
    for (i = 0; i < nthreads; i++) {
	child_handles[i] = create_thread((void (*)(void *)) child_main, (void *) i);
        if (child_handles[i] == 0) {
            ap_log_error(APLOG_MARK, APLOG_ERR, server_conf, 
                         "create_thread rc = %d", errno);
        }
    }
    if (nthreads > max_daemons_limit) {
	max_daemons_limit = nthreads;
    }

    while (1) {
        if (max_jobs_per_exe && (total_jobs > max_jobs_per_exe)) {
            /* Reached MaxRequestsPerChild. Stop accepting new connections
             * and signal the parent to start a new child process.
             */
            ap_start_restart(1);
            break;
	}
        /* Always check for the exit event being signaled.
         */
        rv = WaitForSingleObject(exit_event, 0);
        ap_assert((rv == WAIT_TIMEOUT) || (rv == WAIT_OBJECT_0));
        if (rv == WAIT_OBJECT_0) {
            APD1("child: exit event signalled, exiting");
            break;
        }

	tv.tv_sec = wait_time;
	tv.tv_usec = 0;
	memcpy(&main_fds, &listenfds, sizeof(fd_set));

	srv = ap_select(listenmaxfd + 1, &main_fds, NULL, NULL, &tv);

        if (srv == 0) {
            count_select_errors = 0;    /* reset count of errors */            
            continue;
        }
	else if (srv == SOCKET_ERROR) {
            if (h_errno != WSAEINTR) {
                /* A "real" error occurred, log it and increment the count of
                 * select errors. This count is used to ensure we don't go into
                 * a busy loop of continuous errors.
                 */
                ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, 
                             "select failed with errno %d", h_errno);
                count_select_errors++;
                if (count_select_errors > MAX_SELECT_ERRORS) {
                    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, server_conf,
                                 "Too many errors in select loop. Child process exiting.");
                    break;
                }
            }
            continue;
	} else {
	    listen_rec *lr;

	    lr = find_ready_listener(&main_fds);
	    if (lr != NULL) {
		sd = lr->fd;
	    }
	}
	do {
	    clen = sizeof(sa_client);
	    csd = accept(sd, (struct sockaddr *) &sa_client, &clen);
	    if (csd == INVALID_SOCKET) {
		csd = -1;
	    }
	} while (csd < 0 && h_errno == WSAEINTR);

	if (csd < 0) {
	    if (h_errno != WSAECONNABORTED) {
		ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
                             "accept: (client socket) failed with errno = %d",h_errno);
            }
	}
	else {
	    add_job(csd);
	    total_jobs++;
	}
    }

    APD2("process PID %d exiting", my_pid);

    /* Get ready to shutdown and exit */
    allowed_globals.exit_now = 1;
    ap_release_mutex(start_mutex);

#ifdef UNGRACEFUL_RESTART
    SetEvent(allowed_globals.thread_exit_event);
#else
    for (i = 0; i < nthreads; i++) {
	add_job(-1);
    }
#endif

    APD2("process PID %d waiting for worker threads to exit", my_pid);
    /* Wait for all your children */
    end_time = time(NULL) + 180;
    while (nthreads) {
        rv = wait_for_many_objects(nthreads, child_handles, 
                                   end_time - time(NULL));
	if (rv != WAIT_TIMEOUT) {
	    rv = rv - WAIT_OBJECT_0;
	    ap_assert((rv >= 0) && (rv < nthreads));
	    cleanup_thread(child_handles, &nthreads, rv);
	    continue;
	}
	break;
    }

    APD2("process PID %d killing remaining worker threads", my_pid);
    for (i = 0; i < nthreads; i++) {
	kill_thread(child_handles[i]);
	free_thread(child_handles[i]);
    }
#ifdef UNGRACEFUL_RESTART
    ap_assert(CloseHandle(allowed_globals.thread_exit_event));
#endif
    destroy_semaphore(allowed_globals.jobsemaphore);
    ap_destroy_mutex(allowed_globals.jobmutex);

    ap_child_exit_modules(pconf, server_conf);
    ap_destroy_pool(pchild);

    cleanup_scoreboard();

    APD2("process PID %d exited", my_pid);
    clean_parent_exit(0);
}				/* standalone_main */

/*
 * Spawn a child Apache process. The child process has the command line arguments from
 * argc and argv[], plus a -Z argument giving the name of an event. The child should
 * open and poll or wait on this event. When it is signalled, the child should die.
 * prefix is a prefix string for the event name.
 * 
 * The child_num argument on entry contains a serial number for this child (used to create
 * a unique event name). On exit, this number will have been incremented by one, ready
 * for the next call. 
 *
 * On exit, the value pointed to be *ev will contain the event created
 * to signal the new child process.
 *
 * The return value is the handle to the child process if successful, else -1. If -1 is
 * returned the error will already have been logged by ap_log_error().
 */

/**********************************************************************
 * master_main - this is the parent (main) process. We create a
 * child process to do the work, then sit around waiting for either
 * the child to exit, or a restart or exit signal. If the child dies,
 * we just respawn a new one. If we have a shutdown or graceful restart,
 * tell the child to die when it is ready. If it is a non-graceful
 * restart, force the child to die immediately.
 **********************************************************************/

#define MAX_PROCESSES 50 /* must be < MAX_WAIT_OBJECTS-1 */

static void cleanup_process(HANDLE *handles, HANDLE *events, int position, int *processes)
{
    int i;
    int handle = 0;

    CloseHandle(handles[position]);
    CloseHandle(events[position]);

    handle = (int)handles[position];

    for (i = position; i < (*processes)-1; i++) {
	handles[i] = handles[i + 1];
	events[i] = events[i + 1];
    }
    (*processes)--;

    APD4("cleanup_processes: removed child in slot %d handle %d, max=%d", position, handle, *processes);
}

static int create_process(pool *p, HANDLE *handles, HANDLE *events, 
                          int *processes, int *child_num, char *kill_event_name, int argc, char **argv)
{

    int rv, i;
    HANDLE kill_event;
    char buf[1024];
    char exit_event_name[40]; /* apPID_C# */
    char *pCommand;

    STARTUPINFO si;           /* Filled in prior to call to CreateProcess */
    PROCESS_INFORMATION pi;   /* filled in on call to CreateProces */
    LPWSAPROTOCOL_INFO  lpWSAProtocolInfo;
    listen_rec *lr;
    DWORD BytesWritten;
    HANDLE hPipeRead = NULL;
    HANDLE hPipeWrite = NULL;
    HANDLE hPipeWriteDup;
    HANDLE hNullOutput = NULL;
    HANDLE hShareError = NULL;
    HANDLE hCurrentProcess;
    SECURITY_ATTRIBUTES sa = {0};  

    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

    /* Build the command line. Should look something like this:
     * C:/apache/bin/apache.exe -Z exit_event -f ap_server_confname 
     * First, get the path to the executable...
     */
    rv = GetModuleFileName(NULL, buf, sizeof(buf));
    if (rv == sizeof(buf)) {
        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                     "Parent: Path to Apache process too long");
        return -1;
    } else if (rv == 0) {
        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                     "Parent: GetModuleFileName() returned NULL for current process.");
        return -1;
    }
    
    /* Create the exit event (apPID_C#). Parent signals this event to tell the
     * child to exit 
     */
    ap_snprintf(exit_event_name, sizeof(exit_event_name), "%s_C%d", kill_event_name, ++(*child_num));
    kill_event = CreateEvent(NULL, TRUE, FALSE, exit_event_name);
    if (!kill_event) {
        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                     "Parent: Could not create exit event for child process");
        return -1;
    }
    
	/* service children must be created with the -z option,
	 * while console mode (interactive apache) children are created
	 * with the -Z option
	 */
    pCommand = ap_psprintf(p, "\"%s\" -%c %s -f \"%s\"", buf, 
		                   isProcessService() ? 'z' : 'Z',
		                   exit_event_name, ap_server_confname);  

    for (i = 1; i < argc; i++) {
        if ((argv[i][0] == '-') && ((argv[i][1] == 'k') || (argv[i][1] == 'n')))
            ++i;
        else
            pCommand = ap_pstrcat(p, pCommand, " \"", argv[i], "\"", NULL);
    }

    /* Create a pipe to send socket info to the child */
    if (!CreatePipe(&hPipeRead, &hPipeWrite, &sa, 0)) {
        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                     "Parent: Unable to create pipe to child process.\n");
        return -1;
    }

    /* Open a null handle to soak info from the child */
    hNullOutput = CreateFile("nul", GENERIC_READ | GENERIC_WRITE, 
                             FILE_SHARE_READ | FILE_SHARE_WRITE, 
                             &sa, OPEN_EXISTING, 0, NULL);
    if (hNullOutput == INVALID_HANDLE_VALUE) {
        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                     "Parent: Unable to create null output pipe for child process.\n");
        return -1;
    }

    /* Child's initial stderr -> our main server error log (or, failing that, stderr) */
    if (server_conf->error_log) {
        hShareError = (HANDLE)_get_osfhandle(fileno(server_conf->error_log));
        if (hShareError == INVALID_HANDLE_VALUE) {
            hShareError = GetStdHandle(STD_ERROR_HANDLE);
        }
    }

    hCurrentProcess = GetCurrentProcess();
    if (DuplicateHandle(hCurrentProcess, hPipeWrite, hCurrentProcess,
                        &hPipeWriteDup, 0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        CloseHandle(hPipeWrite);
        hPipeWrite = hPipeWriteDup;
    }

    /* Give the read in of the pipe (hPipeRead) to the child as stdin. The 
     * parent will write the socket data to the child on this pipe.
     */
    memset(&si, 0, sizeof(si));
    memset(&pi, 0, sizeof(pi));
    si.cb = sizeof(si);
    si.dwFlags     = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;
    si.hStdInput   = hPipeRead;
    si.hStdOutput  = hNullOutput;
    si.hStdError   = hShareError;

    if (!CreateProcess(NULL, pCommand, NULL, NULL, 
                       TRUE,      /* Inherit handles */
                       0,         /* Creation flags */
                       NULL, NULL,
                       &si, &pi)) {
        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                     "Parent: Not able to create the child process.");
        /*
         * We must close the handles to the new process and its main thread
         * to prevent handle and memory leaks.
         */ 
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        CloseHandle(hPipeRead);
        CloseHandle(hPipeWrite);        
        CloseHandle(hNullOutput);

        return -1;
    }
    else {
        ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_INFO, server_conf,
                     "Parent: Created child process %d", pi.dwProcessId);

        /* Assume the child process lives. Update the process and event tables */
        handles[*processes] = pi.hProcess;
        events[*processes] = kill_event;
        (*processes)++;

        /* We never store the thread's handle, so close it now. */
        CloseHandle(pi.hThread);

        /* Run the chain of open sockets. For each socket, duplicate it 
         * for the target process then send the WSAPROTOCOL_INFO 
         * (returned by dup socket) to the child */
        lr = ap_listeners;
        while (lr != NULL) {
            lpWSAProtocolInfo = ap_pcalloc(p, sizeof(WSAPROTOCOL_INFO));
            ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_INFO, server_conf,
                         "Parent: Duplicating socket %d and sending it to child process %d", lr->fd, pi.dwProcessId);
            if (WSADuplicateSocket(lr->fd, 
                                   pi.dwProcessId,
                                   lpWSAProtocolInfo) == SOCKET_ERROR) {
                ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                             "Parent: WSADuplicateSocket failed for socket %d.", lr->fd );
                return -1;
            }

            if (!WriteFile(hPipeWrite, lpWSAProtocolInfo, (DWORD) sizeof(WSAPROTOCOL_INFO),
                           &BytesWritten,
                           (LPOVERLAPPED) NULL)) {
                ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                             "Parent: Unable to write duplicated socket %d to the child.", lr->fd );
                return -1;
            }

            lr = lr->next;
            if (lr == ap_listeners)
                break;
        }
    }
    CloseHandle(hPipeRead);
    CloseHandle(hPipeWrite);        
    CloseHandle(hNullOutput);

    return 0;
}

/* To share the semaphores with other processes, we need a NULL ACL
 * Code from MS KB Q106387
 */

static PSECURITY_ATTRIBUTES GetNullACL()
{
    PSECURITY_DESCRIPTOR pSD;
    PSECURITY_ATTRIBUTES sa;

    sa  = (PSECURITY_ATTRIBUTES) LocalAlloc(LPTR, sizeof(SECURITY_ATTRIBUTES));
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR,
					    SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (pSD == NULL || sa == NULL) {
        return NULL;
    }
    /*
     * Win98 returns nonzero on failure; check LastError to make sure.
     */
    SetLastError(0);
    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)
	|| GetLastError()) {
        LocalFree( pSD );
        LocalFree( sa );
        return NULL;
    }
    if (!SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE)
	|| GetLastError()) {
        LocalFree( pSD );
        LocalFree( sa );
        return NULL;
    }
    sa->nLength = sizeof(sa);
    sa->lpSecurityDescriptor = pSD;
    sa->bInheritHandle = TRUE;
    return sa;
}


static void CleanNullACL( void *sa ) {
    if( sa ) {
        LocalFree( ((PSECURITY_ATTRIBUTES)sa)->lpSecurityDescriptor);
        LocalFree( sa );
    }
}

int master_main(int argc, char **argv)
{
    /* returns NULL if invalid (Win95?) */
    PSECURITY_ATTRIBUTES sa = GetNullACL();
    int nchild = ap_daemons_to_start;
    int child_num = 0;
    int rv, cld;
    char signal_prefix_string[100];
    int i;
    time_t tmstart;
    HANDLE signal_shutdown_event;	/* used to signal shutdown to parent */
    HANDLE signal_restart_event;	/* used to signal a restart to parent */
    HANDLE process_handles[MAX_PROCESSES];
    HANDLE process_kill_events[MAX_PROCESSES];
    int current_live_processes = 0; /* number of child process we know about */
    int processes_to_create = 0;    /* number of child processes to create */
    pool *pparent = NULL;  /* pool for the parent process. Cleaned on each restart */

    nchild = 1;	    /* only allowed one child process for current generation */
    processes_to_create = nchild;

    is_graceful = 0;

    ap_snprintf(signal_prefix_string, sizeof(signal_prefix_string),
	        "ap%d", getpid());
    setup_signal_names(signal_prefix_string);

    /* Create shutdown event, apPID_shutdown, where PID is the parent 
     * Apache process ID. Shutdown is signaled by 'apache -k shutdown'.
     */
    signal_shutdown_event = CreateEvent(sa, TRUE, FALSE, signal_shutdown_name);
    if (!signal_shutdown_event) {
	ap_log_error(APLOG_MARK, APLOG_EMERG|APLOG_WIN32ERROR, server_conf,
		    "master_main: Cannot create shutdown event %s", signal_shutdown_name);
        CleanNullACL((void *)sa);
	exit(1);
    }

    /* Create restart event, apPID_restart, where PID is the parent 
     * Apache process ID. Restart is signaled by 'apache -k restart'.
     */
    signal_restart_event = CreateEvent(sa, TRUE, FALSE, signal_restart_name);
    if (!signal_restart_event) {
	CloseHandle(signal_shutdown_event);
	ap_log_error(APLOG_MARK, APLOG_EMERG|APLOG_WIN32ERROR, server_conf,
		    "master_main: Cannot create restart event %s", signal_restart_name);
        CleanNullACL((void *)sa);
	exit(1);
    }
    CleanNullACL((void *)sa);

    /* Create the start mutex, apPID, where PID is the parent Apache process ID.
     * Ths start mutex is used during a restart to prevent more than one 
     * child process from entering the accept loop at once.
     */
    start_mutex = ap_create_mutex(signal_prefix_string);
    restart_pending = shutdown_pending = 0;

    do { /* restart-pending */
	if (!is_graceful) {
	    ap_restart_time = time(NULL);
	}
        copy_listeners(pconf);
	ap_clear_pool(pconf);
	pparent = ap_make_sub_pool(pconf);

	server_conf = ap_read_config(pconf, pparent, ap_server_confname);
        setup_listeners(pconf);
	ap_clear_pool(plog);
	ap_open_logs(server_conf, plog);
	ap_set_version();
	ap_init_modules(pconf, server_conf);
	version_locked++;
        service_set_status(SERVICE_START_PENDING);
        /* Create child processes */
        while (processes_to_create--) {
            if (create_process(pconf, process_handles, process_kill_events, 
                               &current_live_processes, &child_num, signal_prefix_string, argc, argv) < 0) {
                ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
                             "master_main: create child process failed. Exiting.");
                goto die_now;
            }
        }
        service_set_status(SERVICE_RUNNING);
	restart_pending = shutdown_pending = 0;

        /* Wait for either the shutdown or restart events to be signaled */
        process_handles[current_live_processes] = signal_shutdown_event;
        process_handles[current_live_processes+1] = signal_restart_event;
        rv = WaitForMultipleObjects(current_live_processes+2, (HANDLE *)process_handles, 
                                    FALSE, INFINITE);
        if (rv == WAIT_FAILED) {
            /* Something serious is wrong */
            ap_log_error(APLOG_MARK,APLOG_CRIT|APLOG_WIN32ERROR, server_conf,
                         "master_main: : WaitForMultipeObjects on process handles and apache-signal -- doing shutdown");
            shutdown_pending = 1;
            break;
        }
        if (rv == WAIT_TIMEOUT) {
            /* Hey, this cannot happen */
            ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
                         "master_main: WaitForMultipeObjects with INFINITE wait exited with WAIT_TIMEOUT");
            shutdown_pending = 1;
        }

        cld = rv - WAIT_OBJECT_0;
        APD4("main process: wait finished, cld=%d handle %d (max=%d)", cld, process_handles[cld], current_live_processes);
        if (cld == current_live_processes) {
            /* apPID_shutdown event signalled, we should exit now */
            shutdown_pending = 1;
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf, 
                         "master_main: Shutdown event signaled. Shutting the server down.");
            if (ResetEvent(signal_shutdown_event) == 0) {
                ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_WIN32ERROR, server_conf,
                             "ResetEvent(signal_shutdown_event)");
            }
	    /* Signal each child processes to die */
	    for (i = 0; i < current_live_processes; i++) {
		APD3("master_main: signalling child %d, handle %d to die", i, process_handles[i]);
		if (SetEvent(process_kill_events[i]) == 0)
		    ap_log_error(APLOG_MARK,APLOG_ERR|APLOG_WIN32ERROR, server_conf,
                                 "master_main: SetEvent for child process in slot #%d failed", i);
	    }
            break;
        } else if (cld == current_live_processes+1) {
            /* apPID_restart event signalled. 
             * Signal the child to shutdown and start a new child process.
             * The restart event can be signaled by a command line restart or
             * by the child process when it handles MaxRequestPerChild connections.
             */
            int children_to_kill = current_live_processes;
            restart_pending = 1;
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf, 
                         "master_main: Restart event signaled. Doing a graceful restart.");
            if (ResetEvent(signal_restart_event) == 0) {
                ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_WIN32ERROR, server_conf,
                             "master_main: ResetEvent(signal_restart_event) failed.");
            }
            /* Signal each child process to die */
	    for (i = 0; i < children_to_kill; i++) {
		APD3("master_main: signalling child #%d handle %d to die", i, process_handles[i]);
		if (SetEvent(process_kill_events[i]) == 0)
		    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_WIN32ERROR, server_conf,
                                 "master_main: SetEvent for child process in slot #%d failed", i);
                /* Remove the process (and event) from the process table */
                cleanup_process(process_handles, process_kill_events, i, &current_live_processes);
	    }
	    processes_to_create = 1;
            ++ap_my_generation;
            continue;
        } else {
            /* The child process exited premeturely because of a fatal error condition
             * (eg, seg fault). Cleanup and restart the child process.
             */
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf, 
                         "master_main: Child processed exited prematurely. Restarting the child process.");
	    ap_assert(cld < current_live_processes);
	    cleanup_process(process_handles, process_kill_events, cld, &current_live_processes);
	    APD2("main_process: child in slot %d died", rv);
            processes_to_create = 1;
            continue;
	}

    } while (1);

    /* If we dropped out of the loop we definitly want to die completely. We need to
     * make sure we wait for all the child process to exit first.
     */

    APD2("*** main process shutdown, processes=%d ***", current_live_processes);

die_now:

    tmstart = time(NULL);
    while (current_live_processes && ((tmstart+60) > time(NULL))) {
	service_set_status(SERVICE_STOP_PENDING);
	rv = WaitForMultipleObjects(current_live_processes, (HANDLE *)process_handles, FALSE, 2000);
	if (rv == WAIT_TIMEOUT)
	    continue;
	ap_assert(rv != WAIT_FAILED);
	cld = rv - WAIT_OBJECT_0;
	ap_assert(rv < current_live_processes);
	APD4("main_process: child in #%d handle %d died, left=%d", 
	    rv, process_handles[rv], current_live_processes);
	cleanup_process(process_handles, process_kill_events, cld, &current_live_processes);
    }
    for (i = 0; i < current_live_processes; i++) {
	ap_log_error(APLOG_MARK,APLOG_ERR|APLOG_NOERRNO, server_conf,
 	    "forcing termination of child #%d (handle %d)", i, process_handles[i]);
	TerminateProcess((HANDLE) process_handles[i], 1);
    }

    CloseHandle(signal_restart_event);
    CloseHandle(signal_shutdown_event);

    /* cleanup pid file on normal shutdown */
    {
	const char *pidfile = NULL;
	pidfile = ap_server_root_relative (pparent, ap_pid_fname);
	if ( pidfile != NULL && unlink(pidfile) == 0)
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO,
			 server_conf,
			 "removed PID file %s (pid=%u)",
			 pidfile, getpid());
    }

    if (pparent) {
	ap_destroy_pool(pparent);
    }

    ap_destroy_mutex(start_mutex);
    return (0);
}

/*
 * Send signal to a running Apache. On entry signal should contain
 * either "shutdown" or "restart"
 */

int send_signal(pool *p, char *signal)
{
    char prefix[20];
    FILE *fp;
    int nread;
    char *fname;
    int end;

    fname = ap_server_root_relative (p, ap_pid_fname);

    fp = fopen(fname, "r");
    if (!fp) {
	printf("Cannot read apache PID file %s\n", fname);
        return FALSE;
    }
    prefix[0] = 'a';
    prefix[1] = 'p';

    nread = fread(prefix+2, 1, sizeof(prefix)-3, fp);
    if (nread == 0) {
	fclose(fp);
	printf("PID file %s was empty\n", fname);
        return FALSE;
    }
    fclose(fp);

    /* Terminate the prefix string */
    end = 2 + nread - 1;
    while (end > 0 && (prefix[end] == '\r' || prefix[end] == '\n'))
	end--;
    prefix[end + 1] = '\0';

    setup_signal_names(prefix);

    if (!strcasecmp(signal, "shutdown"))
	ap_start_shutdown();
    else if (!strcasecmp(signal, "restart"))
	ap_start_restart(1);
    else {
	printf("Unknown signal name \"%s\". Use either shutdown or restart.\n",
	    signal);
        return FALSE;
    }
    return TRUE;
}

void post_parse_init()
{
    ap_set_version();
    ap_init_modules(pconf, server_conf);
    ap_suexec_enabled = init_suexec();
    version_locked++;
    ap_open_logs(server_conf, plog);
    set_group_privs();
}


int REALMAIN(int argc, char *argv[]) 
{
    int c;
    int child = 0;
    char *cp;
    char *s;
    int conf_specified = 0;
    

    /* Console application or a child process. */

    if ((s = strrchr(argv[0], PATHSEPARATOR)) != NULL) {
        ap_server_argv0 = ++s;
    }
    else {
        ap_server_argv0 = argv[0];
    }

    common_init();
    ap_setup_prelinked_modules();

    /* initialize ap_server_root to the directory of the executable, in case
     * the user chooses a relative path for the -d serverroot arg a bit later
     */


    /* Fallback position if argv[0] wasn't deciphered
     */
    if (!*ap_server_root)
        ap_cpystrn(ap_server_root, HTTPD_ROOT, sizeof(ap_server_root));

    chdir (ap_server_root);

    while ((c = getopt(argc, argv, "D:C:c:Xd:Ff:vVlLesStTh")) != -1) {
        char **new;
	switch (c) {
	case 'c':
	    new = (char **)ap_push_array(ap_server_post_read_config);
	    *new = ap_pstrdup(pcommands, optarg);
	    break;
	case 'C':
	    new = (char **)ap_push_array(ap_server_pre_read_config);
	    *new = ap_pstrdup(pcommands, optarg);
	    break;
	case 'D':
	    new = (char **)ap_push_array(ap_server_config_defines);
	    *new = ap_pstrdup(pcommands, optarg);
	    break;
	case 'S':
	    ap_dump_settings = 1;
	    break;
	case 'd':
            optarg = ap_os_canonical_filename(pcommands, optarg);
            if (!ap_os_is_path_absolute(optarg)) {
	        optarg = ap_pstrcat(pcommands, ap_server_root, "/", 
                                    optarg, NULL);
            }
            ap_cpystrn(ap_server_root, optarg, sizeof(ap_server_root));
            ap_getparents(ap_server_root);
            ap_no2slash(ap_server_root);
            if (ap_server_root[0] 
                    && ap_server_root[strlen(ap_server_root) - 1] == '/')
                ap_server_root[strlen(ap_server_root) - 1] = '\0';
	    break;
	case 'F':
	    do_detach = 0;
	    break;
	case 'f':
            ap_cpystrn(ap_server_confname,
                       ap_os_canonical_filename(pcommands, optarg),
                       sizeof(ap_server_confname));
            conf_specified = 1;
	    break;
	case 'v':
	    ap_set_version();
	    printf("Server version: %s\n", ap_get_server_version());
	    printf("Server built:   %s\n", ap_get_server_built());
            clean_parent_exit(0);

        case 'V':
	    ap_set_version();
	    show_compile_settings();
            clean_parent_exit(0);

	case 'l':
	    ap_show_modules();
            clean_parent_exit(0);

	case 'L':
	    ap_show_directives();
            clean_parent_exit(0);

	case 'X':
	    ++one_process;	/* Weird debugging mode. */
	    break;
	case 't':
	    ap_configtestonly = 1;
	    ap_docrootcheck = 1;
	    break;
	case 'T':
	    ap_configtestonly = 1;
	    ap_docrootcheck = 0;
	    break;
	case 'h':
	    usage(ap_server_argv0);
	case '?':
	    usage(ap_server_argv0);
        }   /* switch */
    }       /* while  */

    /* ServerRoot/ServerConfFile are found in this order:
     * (1) serverroot set to Apache.exe's path, or HTTPD_ROOT if unparsable
     * (2) arguments are grabbed for the -n named service, if given
     * (3) the -d argument is taken from the given command line
     * (4) the -d argument is taken from the service's default args
     * (5) the -f argument is taken from the given command line
     * (6) the -f argument is taken from the service's default args
     * (7) if -f is omitted, then initialized to SERVER_CONFIG_FILE
     * (8) if ap_server_confname is not absolute, then merge it to serverroot
     */
    
    if (!conf_specified)
        ap_cpystrn(ap_server_confname, SERVER_CONFIG_FILE, sizeof(ap_server_confname));

#ifdef EAPI
    ap_init_alloc_shared(TRUE);
#endif

    if (!ap_os_is_path_absolute(ap_server_confname))
        ap_cpystrn(ap_server_confname,
                   ap_server_root_relative(pcommands, ap_server_confname),
                   sizeof(ap_server_confname));
    ap_getparents(ap_server_confname);
    ap_no2slash(ap_server_confname);
    
    server_conf = ap_read_config(pconf, ptrans, ap_server_confname);
#ifdef EAPI
    ap_init_alloc_shared(FALSE);
#endif

    if (ap_configtestonly) {
        fprintf(stderr, "%s: Syntax OK\n", ap_server_root_relative(pcommands, ap_server_confname));
        clean_parent_exit(0);
    }

    if (ap_dump_settings) {
        clean_parent_exit(0);
    }

    if (!child && !ap_dump_settings) { 
        ap_log_pid(pconf, ap_pid_fname);
    }

    post_parse_init();


    if (one_process && !exit_event)
	exit_event = create_event(0, 0, NULL);
    if (one_process && !start_mutex)
	start_mutex = ap_create_mutex(NULL);

    /*
     * In the future, the main will spawn off a couple
     * of children and monitor them. As soon as a child
     * exits, it spawns off a new one
     */
    if (child || one_process) {
	if (!exit_event || !start_mutex)
	    exit(-1);
	worker_main();
	ap_destroy_mutex(start_mutex);
	destroy_event(exit_event);
    } 
    else 
    {
        master_main(argc, argv);
    }

    clean_parent_exit(0);
    return 0;	/* purely to avoid a warning */
}

#endif /* ndef MULTITHREAD */

#else  /* ndef SHARED_CORE_TIESTATIC */

/*
**  Standalone Tie Program for Shared Core support
**
**  It's purpose is to tie the static libraries and 
**  the shared core library under link-time and  
**  passing execution control to the real main function
**  in the shared core library under run-time.
*/

extern int ap_main(int argc, char *argv[]);

int main(int argc, char *argv[]) 
{
    return ap_main(argc, argv);
}

#endif /* ndef SHARED_CORE_TIESTATIC */
#else  /* ndef SHARED_CORE_BOOTSTRAP */


/*
**  Standalone Bootstrap Program for Shared Core support
**
**  It's purpose is to initialise the LD_LIBRARY_PATH
**  environment variable therewith the Unix loader is able
**  to start the Standalone Tie Program (see above)
**  and then replacing itself with this program by
**  immediately passing execution to it.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ap_config.h"
#include "httpd.h"

#define VARNAME "LD_LIBRARY_PATH"

#ifndef SHARED_CORE_DIR 
#define SHARED_CORE_DIR HTTPD_ROOT "/libexec"
#endif

#ifndef SHARED_CORE_EXECUTABLE_PROGRAM
#define SHARED_CORE_EXECUTABLE_PROGRAM "lib" TARGET ".ep"
#endif

extern char *optarg;
extern int   optind;

int main(int argc, char *argv[], char *envp[]) 
{
    char prog[MAX_STRING_LEN];
    char llp_buf[MAX_STRING_LEN];
    char **llp_slot;
    char *llp_existing;
    char *llp_dir;
    char **envpnew;
    int c, i, l;

	
    /* 
     * parse argument line, 
     * but only handle the -L option 
     */
    llp_dir = SHARED_CORE_DIR;
    while ((c = getopt(argc, argv, "D:C:c:Xd:Ff:vVlLR:SZ:tTh")) != -1) {
	switch (c) {
	case 'D':
	case 'C':
	case 'c':
	case 'X':
	case 'd':
	case 'F':
	case 'f':
	case 'v':
	case 'V':
	case 'l':
	case 'L':
	case 'S':
	case 'Z':
	case 't':
	case 'T':
	case 'h':
	case '?':
	    break;
	case 'R':
	    llp_dir = strdup(optarg);
	    break;
	}
    }

	
    /* 
     * create path to SHARED_CORE_EXECUTABLE_PROGRAM
     */
    ap_snprintf(prog, sizeof(prog), "%s/%s", llp_dir, SHARED_CORE_EXECUTABLE_PROGRAM);

    /* 
     * adjust process environment therewith the Unix loader 
     * is able to start the SHARED_CORE_EXECUTABLE_PROGRAM.
     */
    llp_slot = NULL;
    llp_existing = NULL;
    l = strlen(VARNAME);
    for (i = 0; envp[i] != NULL; i++) {
	if (strncmp(envp[i], VARNAME "=", l+1) == 0) {
	    llp_slot = &envp[i];
	    llp_existing = strchr(envp[i], '=') + 1;
	}
    }
    if (llp_slot == NULL) {
	envpnew = (char **)malloc(sizeof(char *)*(i + 2));
	if (envpnew == NULL) {
	    fprintf(stderr, "Ouch!  Out of memory generating envpnew!\n");
	}
	memcpy(envpnew, envp, sizeof(char *)*i);
	envp = envpnew;
	llp_slot = &envp[i++];
	envp[i] = NULL;
    }
    if (llp_existing != NULL)
	 ap_snprintf(llp_buf, sizeof(llp_buf), "%s=%s:%s", VARNAME, llp_dir, llp_existing);
    else
	 ap_snprintf(llp_buf, sizeof(llp_buf), "%s=%s", VARNAME, llp_dir);
    *llp_slot = strdup(llp_buf);

    /* 
     * finally replace our process with 
     * the SHARED_CORE_EXECUTABLE_PROGRAM
     */
    if (execve(prog, argv, envp) == -1) {
	fprintf(stderr, 
		"%s: Unable to exec Shared Core Executable Program `%s'\n",
		argv[0], prog);
	return 1;
    }
    else
	return 0;
}

#endif /* ndef SHARED_CORE_BOOTSTRAP */

#ifndef SHARED_CORE_BOOTSTRAP
#include "httpd.h"
/*
 * Force ap_validate_password() into the image so that modules like
 * mod_auth can use it even if they're dynamically loaded.
 */
void suck_in_ap_validate_password(void);
void suck_in_ap_validate_password(void)
{
    ap_validate_password("a", "b");
}
#endif

d3360 1
a3360 1
#if defined(USE_EXPAT) && !defined(SHARED_CORE_BOOTSTRAP)
@


1.36
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.35 2004/02/10 12:59:29 henning Exp $ */
d1195 1
d1197 1
a1197 1
    fprintf(stderr, "Usage: %s [-R directory] [-D name] [-d directory] [-f file]\n", bin);
d1199 1
a1199 1
    fprintf(stderr, "Usage: %s [-D name] [-d directory] [-f file]\n", bin);
a1200 2
    fprintf(stderr, "       %s [-C \"directive\"] [-c \"directive\"]\n", pad);
    fprintf(stderr, "       %s [-v] [-V] [-h] [-l] [-L] [-S] [-t] [-T] [-F] [-u]\n", pad);
d1202 9
d1212 1
a1212 1
    fprintf(stderr, "  -R directory     : specify an alternate location for shared object files\n");
a1213 10
    fprintf(stderr, "  -D name          : define a name for use in <IfDefine name> directives\n");
    fprintf(stderr, "  -d directory     : specify an alternate initial ServerRoot\n");
    fprintf(stderr, "  -f file          : specify an alternate ServerConfigFile\n");
    fprintf(stderr, "  -C \"directive\"   : process directive before reading config files\n");
    fprintf(stderr, "  -c \"directive\"   : process directive after  reading config files\n");
    fprintf(stderr, "  -v               : show version number\n");
    fprintf(stderr, "  -V               : show compile settings\n");
    fprintf(stderr, "  -h               : list available command line options (this page)\n");
    fprintf(stderr, "  -l               : list compiled-in modules\n");
    fprintf(stderr, "  -L               : list available configuration directives\n");
d1215 1
d1217 4
a1220 3
    fprintf(stderr, "  -T               : run syntax check for config files (without docroot check)\n");
    fprintf(stderr, "  -F               : run main process in foreground, for process supervisors\n");
    fprintf(stderr, "  -u               : Unsecure mode. Do not chroot into ServerRoot.\n");
@


1.35
log
@ap_server_strip_chroot() is void not int, found by otto while playing with
a etoh diff
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.34 2003/11/17 18:57:05 henning Exp $ */
a120 3
#ifdef WIN32
#include "../os/win32/getopt.h"
#elif !defined(BEOS) && !defined(TPF) && !defined(NETWARE) && !defined(OS390) && !defined(CYGWIN)
a121 1
#endif
a181 6
#ifdef WIN32
#include "../os/win32/service.h"
#include "../os/win32/registry.h"
#define DEFAULTSERVICENAME "Apache"
#define PATHSEPARATOR '\\'
#else
a182 1
#endif
a188 12
#ifdef USE_OS2_SCOREBOARD
    /* Add MMAP style functionality to OS/2 */
#define INCL_DOSMEMMGR
#define INCL_DOSEXCEPTIONS
#define INCL_DOSSEMAPHORES
#include <os2.h>
#include <umalloc.h>
#include <stdio.h>
caddr_t create_shared_heap(const char *, size_t);
caddr_t get_shared_heap(const char *);
#endif

a213 4
#ifdef NETWARE
BOOL ap_main_finished = FALSE;
unsigned int ap_thread_stack_size = 65536;
#endif
a305 1
#ifndef NETWARE
a306 1
#endif
a309 1
#ifndef NETWARE
a310 1
#endif
a329 1
#ifndef NETWARE
a330 1
#endif
a356 1
#ifndef NETWARE
a357 1
#endif
a361 6
#ifdef TPF
pid_t tpf_parent_pid;
int tpf_child = 0;
char tpf_server_name[INETD_SERVNAME_LENGTH+1];
char tpf_mutex_key[TPF_MUTEX_KEY_SIZE];
#endif /* TPF */
a468 1
#ifndef NETWARE
a469 1
#endif
a718 4
#if !defined(CYGWIN)
    /* Cygwin has problems with this pthread call claiming that these 
     * are "Invalid arguements", Stipe Tolj <tolj@@wapme-systems.de>
     */
a723 1
#endif
a1045 175
#if defined(HAVE_OS2SEM_SERIALIZED_ACCEPT)

static HMTX lock_sem = -1;

static void accept_mutex_cleanup_os2sem(void *foo)
{
    DosReleaseMutexSem(lock_sem);
    DosCloseMutexSem(lock_sem);
}

/*
 * Initialize mutex lock.
 * Done by each child at it's birth
 */
static void accept_mutex_child_init_os2sem(pool *p)
{
    int rc = DosOpenMutexSem(NULL, &lock_sem);

    if (rc != 0) {
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
		    "Child cannot open lock semaphore, rc=%d", rc);
	clean_child_exit(APEXIT_CHILDINIT);
    } else {
        ap_register_cleanup(p, NULL, accept_mutex_cleanup_os2sem, ap_null_cleanup);
    }
}

/*
 * Initialize mutex lock.
 * Must be safe to call this on a restart.
 */
static void accept_mutex_init_os2sem(pool *p)
{
    int rc = DosCreateMutexSem(NULL, &lock_sem, DC_SEM_SHARED, FALSE);

    if (rc != 0) {
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
		    "Parent cannot create lock semaphore, rc=%d", rc);
	exit(APEXIT_INIT);
    }

    ap_register_cleanup(p, NULL, accept_mutex_cleanup_os2sem, ap_null_cleanup);
}

static void accept_mutex_on_os2sem(void)
{
    int rc = DosRequestMutexSem(lock_sem, SEM_INDEFINITE_WAIT);

    if (rc != 0) {
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
		    "OS2SEM: Error %d getting accept lock. Exiting!", rc);
	clean_child_exit(APEXIT_CHILDFATAL);
    }
}

static void accept_mutex_off_os2sem(void)
{
    int rc = DosReleaseMutexSem(lock_sem);
    
    if (rc != 0) {
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
		    "OS2SEM: Error %d freeing accept lock. Exiting!", rc);
	clean_child_exit(APEXIT_CHILDFATAL);
    }
}

accept_mutex_methods_s accept_mutex_os2sem_s = {
    accept_mutex_child_init_os2sem,
    accept_mutex_init_os2sem,
    accept_mutex_on_os2sem,
    accept_mutex_off_os2sem,
    "os2sem"
};
#endif

#if defined(HAVE_TPF_CORE_SERIALIZED_ACCEPT)

static int tpf_core_held;

static void accept_mutex_cleanup_tpfcore(void *foo)
{
    if(tpf_core_held)
        deqc(tpf_mutex_key, QUAL_S);
}

#define accept_mutex_init_tpfcore(x)

static void accept_mutex_child_init_tpfcore(pool *p)
{
    ap_register_cleanup(p, NULL, accept_mutex_cleanup_tpfcore, ap_null_cleanup);
    tpf_core_held = 0;
}

static void accept_mutex_on_tpfcore(void)
{
    enqc(tpf_mutex_key, ENQ_WAIT, 0, QUAL_S);
    tpf_core_held = 1;
    ap_check_signals();
}

static void accept_mutex_off_tpfcore(void)
{
    deqc(tpf_mutex_key, QUAL_S);
    tpf_core_held = 0;
    ap_check_signals();
}

accept_mutex_methods_s accept_mutex_tpfcore_s = {
    accept_mutex_child_init_tpfcore,
    NULL,
    accept_mutex_on_tpfcore,
    accept_mutex_off_tpfcore,
    "tpfcore"
};
#endif

#ifdef HAVE_BEOS_SERIALIZED_ACCEPT
static sem_id _sem = -1;
static int  locked = 0;

static void accept_mutex_child_cleanup_beos(void *foo)
{
    if (_sem > 0 && locked)
        release_sem(_sem);
}

static void accept_mutex_child_init_beos(pool *p)
{
    ap_register_cleanup(p, NULL, accept_mutex_child_cleanup_beos, ap_null_cleanup);
    locked = 0;
}

static void accept_mutex_cleanup_beos(void *foo)
{
    if (_sem > 0)
        delete_sem(_sem);
}

static void accept_mutex_init_beos(pool *p)
{
    _sem = create_sem(1, "httpd_accept");
    if (_sem < 0) {
        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
                    "Parent cannot create lock semaphore, sem=%ld", _sem);
        exit(APEXIT_INIT);
    }

    ap_register_cleanup(p, NULL, accept_mutex_cleanup_beos, ap_null_cleanup);
}                                                                                                        
void accept_mutex_on_beos(void)
{
    if (locked == 0) {
        if (acquire_sem(_sem) == B_OK)
            locked = 1;
    }
}

static void accept_mutex_off_beos(void)
{
    if (locked == 1) {
        if (release_sem(_sem) == B_OK)
            locked = 0; 
    }
}

accept_mutex_methods_s accept_mutex_beos_s = {
    accept_mutex_child_init_beos,
    accept_mutex_init_beos,
    accept_mutex_on_beos,
    accept_mutex_off_beos,
    "beos_sem"
};
#endif /* HAVE_BEOS_SERIALIZED_ACCEPT */


a1115 12
#if defined HAVE_OS2SEM_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"os2sem"))))
    	return "os2sem";
#endif
#if defined HAVE_TPF_CORE_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"tpfcore"))))
    	return "tpfcore";
#endif
#if defined HAVE_BEOS_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"beos_sem"))))
        return "beos_sem";
#endif
a1156 15
#if defined HAVE_OS2SEM_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"os2sem"))) {
    	amutex = &accept_mutex_os2sem_s;
    } else 
#endif
#if defined HAVE_TPF_CORE_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"tpfcore"))) {
    	amutex = &accept_mutex_tpfcore_s;
    } else 
#endif
#if defined HAVE_BEOS_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"beos_sem"))) {
        amutex = &accept_mutex_beos_s;
    } else
#endif
a1163 1
#ifndef WIN32
a1171 1
#endif
a1194 5
#ifdef WIN32
    fprintf(stderr, "Usage: %s [-D name] [-d directory] [-f file] [-n service]\n", bin);
    fprintf(stderr, "       %s [-C \"directive\"] [-c \"directive\"] [-k signal]\n", pad);
    fprintf(stderr, "       %s [-v] [-V] [-h] [-l] [-L] [-S] [-t] [-T]\n", pad);
#else /* !WIN32 */
a1205 1
#endif /* !WIN32 */
a1216 4
#ifdef NETWARE
    fprintf(stderr, "  -e               : force the display of configuration file errors to the logger screen\n");
    fprintf(stderr, "  -s               : load Apache without a screen\n");
#endif
a1218 1
#ifndef WIN32
a1220 12
#endif
#ifdef WIN32
    fprintf(stderr, "  -n name          : name the Apache service for -k options below;\n");
    fprintf(stderr, "  -k stop|shutdown : tell running Apache to shutdown\n");
    fprintf(stderr, "  -k restart       : tell running Apache to do a graceful restart\n");
    fprintf(stderr, "  -k start         : tell Apache to start\n");
    fprintf(stderr, "  -k install   | -i: install an Apache service\n");
    fprintf(stderr, "  -k config        : reconfigure an installed Apache service\n");
    fprintf(stderr, "  -k uninstall | -u: uninstall an Apache service\n");
    fprintf(stderr, "  -W service       : after -k config|install; Apache starts after 'service'\n");
    fprintf(stderr, "  -w               : holds the window open for 30 seconds for fatal errors.\n");
#endif
a1221 3
#if defined(NETWARE)
    clean_parent_exit(0);
#else
a1222 1
#endif
a1225 38

#ifdef NETWARE
/* Thread Storage Data */
typedef struct _TSD {
    conn_rec*		current_conn;
    int 			alarms_blocked;
    int				alarm_pending;
    request_rec*	timeout_req;
    char*			timeout_name;
    JMP_BUF			jmpbuffer;
    int				exit_after_unblock;
    void 			(*alarm_fn) (int);
    unsigned int 	alarm_expiry_time;
} TSD;

static TSD Tsd;

void init_tsd()
{    
    int *thread_ptr;

    memset(&Tsd, 0, sizeof(TSD));
    thread_ptr = __get_thread_data_area_ptr();
    *thread_ptr = (int) &Tsd;
}

#define get_tsd            TSD* tsd = (TSD*) Thread_Data_Area;
#define current_conn       tsd->current_conn
#define alarms_blocked     tsd->alarms_blocked
#define alarm_pending      tsd->alarm_pending
#define timeout_req        tsd->timeout_req
#define timeout_name       tsd->timeout_name
#define jmpbuffer          tsd->jmpbuffer
#define exit_after_unblock tsd->exit_after_unblock
#define alarm_fn           tsd->alarm_fn
#define alarm_expiry_time  tsd->alarm_expiry_time

#else
a1237 1
#endif
a1242 3
#ifdef NETWARE
    get_tsd
#endif    
a1278 3
#ifdef NETWARE
            ThreadSwitch();
#endif
a1315 1
#ifndef TPF
a1323 3
#ifdef NETWARE
    get_tsd
#endif
a1328 3
#ifdef NETWARE
    get_tsd
#endif
a1348 1
#endif /* TPF */
a1349 1
#ifndef NETWARE
a1350 4
#endif
#if defined(WIN32) || defined(CYGWIN_WINSOCK) 
static APACHE_TLS unsigned int alarm_expiry_time = 0;
#endif /* WIN32 */
a1351 1
#if !defined(WIN32)  && !defined(NETWARE)
a1357 1
#endif
a1362 18
#if defined(WIN32) || defined(NETWARE)
    time_t now = time(NULL);
#ifdef NETWARE
    get_tsd
#endif
    old = alarm_expiry_time;

    if (old)
	old -= now;
    if (x == 0) {
	alarm_fn = NULL;
	alarm_expiry_time = 0;
    }
    else {
	alarm_fn = fn;
	alarm_expiry_time = now + x;
    }
#else
a1383 1
#endif
a1387 26
#if defined(WIN32) || defined(NETWARE) || defined(CYGWIN_WINSOCK) 
API_EXPORT(int) ap_check_alarm(void)
{
#ifdef NETWARE
    get_tsd
#endif
    if (alarm_expiry_time) {
	unsigned int t;

	t = time(NULL);
	if (t >= alarm_expiry_time) {
	    alarm_expiry_time = 0;
	    (*alarm_fn) (0);
	    return (-1);
	}
	else {
	    return (alarm_expiry_time - t);
	}
    }
    else
	return (0);
}
#endif /* WIN32 */



a1394 3
#ifdef NETWARE
    get_tsd
#endif
a1407 3
#ifdef NETWARE
    get_tsd
#endif
a1418 3
#ifdef NETWARE
    get_tsd
#endif
a1425 3
#ifdef NETWARE
    get_tsd
#endif
a1431 3
#ifdef NETWARE
    get_tsd
#endif
a1490 3
#ifdef NETWARE
    get_tsd
#endif
a1504 3
#ifdef NETWARE
    get_tsd
#endif
a1571 3
#ifdef NETWARE
        ThreadSwitch();
#endif
a1579 3
#if defined(WIN32) || defined(NETWARE)
             (recv(lsd, dummybuf, sizeof(dummybuf), 0) > 0));
#else
a1580 1
#endif
d1738 1
a1738 85
#if defined(USE_OS2_SCOREBOARD)

/* The next two routines are used to access shared memory under OS/2.  */
/* This requires EMX v09c to be installed.                           */

caddr_t create_shared_heap(const char *name, size_t size)
{
    ULONG rc;
    void *mem;
    Heap_t h;

    rc = DosAllocSharedMem(&mem, name, size,
			   PAG_COMMIT | PAG_READ | PAG_WRITE);
    if (rc != 0)
	return NULL;
    h = _ucreate(mem, size, !_BLOCK_CLEAN, _HEAP_REGULAR | _HEAP_SHARED,
		 NULL, NULL);
    if (h == NULL)
	DosFreeMem(mem);
    return (caddr_t) h;
}

caddr_t get_shared_heap(const char *Name)
{

    PVOID BaseAddress;		/* Pointer to the base address of
				   the shared memory object */
    ULONG AttributeFlags;	/* Flags describing characteristics
				   of the shared memory object */
    APIRET rc;			/* Return code */

    /* Request read and write access to */
    /*   the shared memory object       */
    AttributeFlags = PAG_WRITE | PAG_READ;

    rc = DosGetNamedSharedMem(&BaseAddress, Name, AttributeFlags);

    if (rc != 0) {
	printf("DosGetNamedSharedMem error: return code = %ld", rc);
	return 0;
    }

    return BaseAddress;
}

static void setup_shared_mem(pool *p)
{
    caddr_t m;

    int rc;

    m = (caddr_t) create_shared_heap("\\SHAREMEM\\SCOREBOARD", SCOREBOARD_SIZE);
    if (m == 0) {
	fprintf(stderr, "%s: Could not create OS/2 Shared memory pool.\n",
		ap_server_argv0);
	exit(APEXIT_INIT);
    }

    rc = _uopen((Heap_t) m);
    if (rc != 0) {
	fprintf(stderr,
		"%s: Could not uopen() newly created OS/2 Shared memory pool.\n",
		ap_server_argv0);
    }
    ap_scoreboard_image = (scoreboard *) m;
    ap_scoreboard_image->global.running_generation = 0;
}

static void reopen_scoreboard(pool *p)
{
    caddr_t m;
    int rc;

    m = (caddr_t) get_shared_heap("\\SHAREMEM\\SCOREBOARD");
    if (m == 0) {
	fprintf(stderr, "%s: Could not find existing OS/2 Shared memory pool.\n",
		ap_server_argv0);
	exit(APEXIT_INIT);
    }

    rc = _uopen((Heap_t) m);
    ap_scoreboard_image = (scoreboard *) m;
}

#elif defined(USE_POSIX_SCOREBOARD)
d1821 1
a1821 18
#ifdef CONVEXOS11
    /*
     * 9-Aug-97 - Jeff Venters (venters@@convex.hp.com)
     * ConvexOS maps address space as follows:
     *   0x00000000 - 0x7fffffff : Kernel
     *   0x80000000 - 0xffffffff : User
     * Start mmapped area 1GB above start of text.
     *
     * Also, the length requires a pointer as the actual length is
     * returned (rounded up to a page boundary).
     */
    {
	unsigned len = SCOREBOARD_SIZE;

	m = mmap((caddr_t) 0xC0000000, &len,
		 PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, NOFD, 0);
    }
#elif defined(MAP_TMPFILE)
a1887 8
#ifdef LINUX
	if (errno == ENOSYS) {
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
			 "Your kernel was built without CONFIG_SYSVIPC\n"
			 "%s: Please consult the Apache FAQ for details",
			 ap_server_argv0);
	}
#endif
a2009 3
#ifdef TPF
    ap_scoreboard_fname = ap_server_root_relative(p, ap_scoreboard_fname);
#endif /* TPF */
a2085 17
#ifdef NETWARE
void clean_shutdown_on_exit(void)
{
    if (!ap_main_finished) {
        AMCSocketCleanup();
        ap_destroy_pool(pcommands);    
        free(ap_loaded_modules);    
        ap_cleanup_method_ptrs();    
        ap_destroy_pool(pglobal);
        ap_cleanup_alloc();
        ap_main_finished = TRUE;
    }
}

void clean_parent_exit(int code) __attribute__((noreturn));
void clean_parent_exit(int code)
#else
a2087 1
#endif
a2088 9
#ifdef NETWARE
    AMCSocketCleanup();
    ap_destroy_pool(pcommands);    
    free(ap_loaded_modules);    
    ap_cleanup_method_ptrs();    
    ap_destroy_pool(pglobal);
    ap_cleanup_alloc();
    ap_main_finished = TRUE;
#else
a2090 1
#endif
a2111 3
#ifdef NETWARE
    ap_scoreboard_image->parent[child_num].pid = GetThreadID();
#endif
a2409 1
#ifndef NETWARE
a2417 29
#ifdef WIN32
#define MAXWAITOBJ MAXIMUM_WAIT_OBJECTS
    HANDLE h[MAXWAITOBJ];
    int e[MAXWAITOBJ];
    int round, pi, hi, rv, err;
    for (round = 0; round <= (HARD_SERVER_LIMIT - 1) / MAXWAITOBJ + 1; round++) {
	hi = 0;
	for (pi = round * MAXWAITOBJ;
	     (pi < (round + 1) * MAXWAITOBJ) && (pi < HARD_SERVER_LIMIT);
	     pi++) {
	    if (ap_scoreboard_image->servers[pi].status != SERVER_DEAD) {
		e[hi] = pi;
		h[hi++] = (HANDLE) ap_scoreboard_image->parent[pi].pid;
	    }

	}
	if (hi > 0) {
	    rv = WaitForMultipleObjects(hi, h, FALSE, 10000);
	    if (rv == -1)
		err = GetLastError();
	    if ((WAIT_OBJECT_0 <= (unsigned int) rv) && ((unsigned int) rv < (WAIT_OBJECT_0 + hi)))
		return (ap_scoreboard_image->parent[e[rv - WAIT_OBJECT_0]].pid);
	    else if ((WAIT_ABANDONED_0 <= (unsigned int) rv) && ((unsigned int) rv < (WAIT_ABANDONED_0 + hi)))
		return (ap_scoreboard_image->parent[e[rv - WAIT_ABANDONED_0]].pid);

	}
    }
    return (-1);
#else /* WIN32 */
a2443 1
#endif /* WIN32 */
a2444 1
#endif
a2582 1
#if !defined(WIN32) && !defined(NETWARE)
a2583 3
#else
    raise(sig);
#endif
a2600 3
#ifdef NETWARE
    get_tsd
#endif
a2625 76
#ifdef WIN32
/*
 * Signalling Apache on NT.
 *
 * Under Unix, Apache can be told to shutdown or restart by sending various
 * signals (HUP, USR, TERM). On NT we don't have easy access to signals, so
 * we use "events" instead. The parent apache process goes into a loop
 * where it waits forever for a set of events. Two of those events are
 * called
 *
 *    apPID_shutdown
 *    apPID_restart
 *
 * (where PID is the PID of the apache parent process). When one of these
 * is signalled, the Apache parent performs the appropriate action. The events
 * can become signalled through internal Apache methods (e.g. if the child
 * finds a fatal error and needs to kill its parent), via the service
 * control manager (the control thread will signal the shutdown event when
 * requested to stop the Apache service), from the -k Apache command line,
 * or from any external program which finds the Apache PID from the
 * httpd.pid file.
 *
 * The signal_parent() function, below, is used to signal one of these events.
 * It can be called by any child or parent process, since it does not
 * rely on global variables.
 *
 * On entry, type gives the event to signal. 0 means shutdown, 1 means 
 * graceful restart.
 */

static void signal_parent(int type)
{
    HANDLE e;
    char *signal_name;
    extern char signal_shutdown_name[];
    extern char signal_restart_name[];

    /* after updating the shutdown_pending or restart flags, we need
     * to wake up the parent process so it can see the changes. The
     * parent will normally be waiting for either a child process
     * to die, or for a signal on the "spache-signal" event. So set the
     * "apache-signal" event here.
     */

    /* XXX: This is no good, can't we please die in -X mode :-? */
    if (one_process) {
	return;
    }

    switch(type) {
    case 0: signal_name = signal_shutdown_name; break;
    case 1: signal_name = signal_restart_name; break;
    default: return;
    }

    APD2("signal_parent signalling event \"%s\"", signal_name);

    e = OpenEvent(EVENT_ALL_ACCESS, FALSE, signal_name);
    if (!e) {
	/* Um, problem, can't signal the parent, which means we can't
	 * signal ourselves to die. Ignore for now...
	 */
	ap_log_error(APLOG_MARK, APLOG_EMERG|APLOG_WIN32ERROR, server_conf,
	    "OpenEvent on %s event", signal_name);
	return;
    }
    if (SetEvent(e) == 0) {
	/* Same problem as above */
	ap_log_error(APLOG_MARK, APLOG_EMERG|APLOG_WIN32ERROR, server_conf,
	    "SetEvent on %s event", signal_name);
	CloseHandle(e);
	return;
    }
    CloseHandle(e);
}
#endif
a2639 1
#ifndef WIN32
a2647 3
#else
    signal_parent(0);	    /* get the parent process to wake up */
#endif
a2652 1
#ifndef WIN32
a2658 3
#else
    signal_parent(1);	    /* get the parent process to wake up */
#endif /* WIN32 */
a2667 4
#ifdef TPF
    signal(sig, restart);
#endif
#if !defined (WIN32) && !defined(NETWARE)
a2668 3
#else
    ap_start_restart(1);
#endif
a2762 1
#ifndef NETWARE
a2763 1
#endif
a2783 1
#if !defined(WIN32) && !defined(NETWARE)
a2786 4
#if !defined(MPE) && !defined(OS2) && !defined(TPF) && !defined(BEOS) && \
    !defined(BONE)
/* Don't detach for MPE because child processes can't survive the death of
   the parent. */
a2796 1
#endif
a2805 19
#elif defined(NEXT) || defined(NEWSOS)
    if (setpgrp(0, getpid()) == -1 || (pgrp = getpgrp(0)) == -1) {
	perror("setpgrp");
	fprintf(stderr, "%s: setpgrp or getpgrp failed\n", ap_server_argv0);
	exit(1);
    }
#elif defined(OS2) || defined(TPF)
    /* OS/2 and TPF don't support process group IDs */
    pgrp = getpid();
#elif defined(MPE)
    /* MPE uses negative pid for process group */
    pgrp = -getpid();
#elif defined(CYGWIN)
    /* Cygwin does not take any argument for setpgrp() */
    if ((pgrp = setpgrp()) == -1) {
        perror("setpgrp");
        fprintf(stderr, "%s: setpgrp failed\n", ap_server_argv0);
        exit(1);
    }
a2831 1
#endif /* ndef WIN32 */
a2842 1
#if !defined(WIN32) && !defined(NETWARE) && !defined(BEOS) && !defined(BONE)
a2864 1
#if !defined(OS2) && !defined(TPF)
a2870 3
#ifdef MPE
	GETPRIVMODE();
#endif
a2871 3
#ifdef MPE
	    GETUSERMODE();
#endif
a2876 3
#ifdef MPE
	GETUSERMODE();
#endif
a2892 1
#endif /* !defined(OS2) && !defined(TPF) */
a2893 1
#endif /* !defined(WIN32) && !defined(NETWARE) && !defined(BEOS) */
a2900 1
#if !defined(WIN32) && !defined(NETWARE) && !defined(TPF)
a2908 1
#endif /* ndef WIN32 */
a2979 3
#ifdef NETWARE
        errno = WSAGetLastError();
#endif
a3022 3
#if defined (SOLARIS2) && SOLARIS2 < 260
#define WORKAROUND_SOLARIS_BUG
#endif
a3034 1
#ifndef BEOS /* this won't work for BeOS sockets!! */
a3035 1
#endif
a3037 3
#ifdef TPF
    os_note_additional_cleanups(p, s);
#endif /* TPF */
a3040 1
#ifndef _OSD_POSIX
a3045 1
#endif /*_OSD_POSIX*/
a3080 1
#ifndef BEOS			/* BeOS does not support SO_SNDBUF */
a3089 1
#endif
a3090 5
#ifdef MPE
/* MPE requires CAP=PM and GETPRIVMODE to bind to ports less than 1024 */
    if (ntohs(server->sin_port) < 1024)
	GETPRIVMODE();
#endif
a3094 4
#ifdef MPE
	if (ntohs(server->sin_port) < 1024)
	    GETUSERMODE();
#endif
a3099 4
#ifdef MPE
    if (ntohs(server->sin_port) < 1024)
	GETUSERMODE();
#endif
a3294 45
#if defined(WIN32) || defined(NETWARE)
static int s_iInitCount = 0;

static int AMCSocketInitialize(void)
{
    int iVersionRequested;
    WSADATA wsaData;
    int err;

    if (s_iInitCount > 0) {
	s_iInitCount++;
	return (0);
    }
    else if (s_iInitCount < 0)
	return (s_iInitCount);

    /* s_iInitCount == 0. Do the initailization */
    iVersionRequested = MAKEWORD(2, 0);
    err = WSAStartup((WORD) iVersionRequested, &wsaData);
    if (err) {
        printf("WSAStartup failed with error %d\n", err);
	s_iInitCount = -1;
	return (s_iInitCount);
    }

    if (LOBYTE(wsaData.wVersion) != 2 ||
	HIBYTE(wsaData.wVersion) != 0) {
        printf("Apache requires Winsock 2. Please see the Apache FAQ for more information.\n");
	s_iInitCount = -2;
	WSACleanup();
	return (s_iInitCount);
    }
    s_iInitCount++;
    return (s_iInitCount);
}


static void AMCSocketCleanup(void)
{
    if (--s_iInitCount == 0)
	WSACleanup();
    return;
}
#endif

a3310 3
#ifdef TPF
    show_os_specific_compile_settings();
#endif
a3328 3
#ifdef USE_OS2_SCOREBOARD
    printf(" -D USE_OS2_SCOREBOARD\n");
#endif
a3358 9
#ifdef HAVE_OS2SEM_SERIALIZED_ACCEPT
    printf(" -D HAVE_OS2SEM_SERIALIZED_ACCEPT\n");
#endif
#ifdef HAVE_TPF_CORE_SERIALIZED_ACCEPT
    printf(" -D HAVE_TPF_CORE_SERIALIZED_ACCEPT\n");
#endif
#ifdef HAVE_BEOS_SERIALIZED_ACCEPT
    printf(" -D HAVE_BEOS_SERIALIZED_ACCEPT\n");
#endif  
a3381 3
#ifdef CHARSET_EBCDIC
    printf(" -D CHARSET_EBCDIC\n");
#endif
a3394 3
#ifdef CYGWIN_WINSOCK 
    printf(" -D CYGWIN_WINSOCK\n"); 
#endif 
a3439 3
#ifdef AUX3
    (void) set42sig();
#endif
a3440 4
#if defined(WIN32) || defined(NETWARE)
    /* Initialize the stupid sockets */
    AMCSocketInitialize();
#endif /* WIN32 */
a3532 11
#ifdef MPE
    /* No such thing as root on MPE, so try to switch unconditionally */
    GETPRIVMODE();
    if (setuid(ap_user_id) == -1) {
	GETUSERMODE();
	ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
		    "setuid: unable to change to uid: %d", ap_user_id);
	exit(1);
    }
    GETUSERMODE();
#else
a3536 3
#ifdef CYGWIN
    if (getuid() == SYSTEM_UID && (
#else
a3537 4
#endif
#ifdef _OSD_POSIX
	os_init_job_environment(server_conf, ap_user_name, one_process) != 0 || 
#endif
a3542 1
#endif
a3554 1
#ifndef OS2
a3557 1
#endif
a3560 5
#ifdef TPF
    signal(SIGHUP, just_die);
    signal(SIGTERM, just_die);
    signal(SIGUSR1, just_die);
#endif /* TPF */
a3561 7
#ifdef OS2
/* Stop Ctrl-C/Ctrl-Break signals going to child processes */
    {
        unsigned long ulTimes;
        DosSetSignalExceptionFocus(0, &ulTimes);
    }
#endif
a3587 1
#ifndef WIN32
a3591 3
#else
	++requests_this_child;
#endif
a3663 11
#if defined(HPUX11) && defined(ENOBUFS)
                    /* On HPUX 11.x, the 'ENOBUFS, No buffer space available'
                     * error occures because the accept() cannot complete.
                     * You will not see ENOBUFS at 10.20 because the kernel
                     * hides any occurrence from being returned from user space.
                     * ENOBUFS at 11.0 TCP/IP is quite possible, and could
                     * occur intermittently. As a work-around, we are going to
                     * ingnore ENOBUFS.
                     */
                case ENOBUFS:
#endif
a3725 14
#ifdef TPF
		case EINACT:
                    ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO,
                                 server_conf, "offload device inactive");
                    clean_child_exit(APEXIT_CHILDFATAL); 
		    break;
		default:
                    if (getppid() != 1) {
                        ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO,
                                     server_conf, "select/accept error (%u)",
                                     errno);
                    }
		    clean_child_exit(APEXIT_CHILDFATAL);
#else
a3729 1
#endif
a3749 4
#ifdef TPF
	if (csd == 0)                       /* 0 is invalid socket for TPF */
	    continue;
#endif
a3847 11
#ifdef TPF_HAVE_NSD
            /* Update the TPF Network Services Database message counters */
            tpf_tcpip_message_cnt(NSDB_INPUT_CNT,
                ((struct sockaddr_in *)&sa_server)->sin_port,
                NSDB_TCP_S, 1);

            tpf_tcpip_message_cnt(NSDB_OUTPUT_CNT,
                ((struct sockaddr_in *)&sa_server)->sin_port,
                NSDB_TCP_S, 1);
#endif /* TPF_HAVE_NSD */

a3910 29
#ifdef TPF
static void reset_tpf_listeners(APACHE_TPF_INPUT *input_parms)
{
    int count;
    listen_rec *lr;

    count = 0;
    listenmaxfd = -1;
    FD_ZERO(&listenfds);
    lr = ap_listeners;

    for(;;) {
        lr->fd = input_parms->listeners[count];
        if(lr->fd >= 0) {
            FD_SET(lr->fd, &listenfds);
            if(lr->fd > listenmaxfd)
                listenmaxfd = lr->fd;
        }
        if(lr->next == NULL)
            break;
        lr = lr->next;
        count++;
    }
    lr->next = ap_listeners;
    head_listener = ap_listeners;
    close_unused_listeners();
}

#endif /* TPF */
a3936 6
#ifdef _OSD_POSIX
    /* BS2000 requires a "special" version of fork() before a setuid() call */
    if ((pid = os_fork(ap_user_name)) == -1) {
#elif defined(TPF)
    if ((pid = os_fork(s, slot)) == -1) {
#else
a3937 1
#endif
a4030 4
#if defined(CYGWIN)
#define SIG_IDLE_KILL SIGKILL
#define SIG_TIMEOUT_KILL SIGUSR2
#else
a4032 1
#endif
a4117 3
#ifdef TPF
        ap_update_child_status(to_kill, SERVER_DEAD, (request_rec *)NULL);
#endif
a4142 9
#ifdef TPF
        if(make_child(server_conf, free_slots[i], now) == -1) {
            if(free_length == 1) {
                shutdown_pending = 1;
                ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
                "No active child processes: shutting down");
            }
        }
#else
a4143 1
#endif /* TPF */
a4232 3
#ifdef OS2
    printf("%s \n", ap_get_server_version());
#endif
a4387 5
#ifdef TPF
            if (shutdown_pending += os_check_server(tpf_server_name)) {
                break;
            }
#endif
a4536 3
#if defined(CYGWIN)
__declspec(dllexport)  
#endif
a4558 5
#ifdef TPF
    EBW_AREA input_parms;
    ecbptr()->ebrout = PRIMECRAS;
    input_parms = * (EBW_AREA *)(&(ecbptr()->ebw000));
#endif
a4623 6
#ifdef TPF
	case 'x':
	    os_tpf_child(&input_parms.child);
	    set_signals();
	    break;
#endif
a4686 4
#ifdef BEOS
    /* make sure we're running in single_process mode - Yuck! */
    one_process = 1;
#endif
a4687 1
#ifndef TPF
a4694 39
#else
    if (!tpf_child) {
        memcpy(tpf_server_name, input_parms.parent.servname,
               INETD_SERVNAME_LENGTH);
        tpf_server_name[INETD_SERVNAME_LENGTH + 1] = '\0';
        snprintf(tpf_mutex_key, sizeof(tpf_mutex_key), "%.*x", TPF_MUTEX_KEY_SIZE - 1, getpid());
        tpf_parent_pid = getppid();
        ap_open_logs(server_conf, plog);
        ap_tpf_zinet_checks(ap_standalone, tpf_server_name, server_conf);
        ap_tpf_save_argv(argc, argv);    /* save argv parms for children */
    }
    if (ap_standalone) {
        ap_set_version();
        ap_init_modules(pconf, server_conf);
        version_locked++;
        if(tpf_child) {
           server_conf->error_log = stderr;
#ifdef HAVE_SYSLOG
            /* if ErrorLog is syslog call ap_open_logs from the child since
               syslog isn't redirected to stderr by the Apache parent */
            if (strncasecmp(server_conf->error_fname, "syslog", 6) == 0) {
               ap_open_logs(server_conf, plog);
            }
#endif /* HAVE_SYSLOG */
            copy_listeners(pconf);
            reset_tpf_listeners(&input_parms.child);
#ifdef SCOREBOARD_FILE
            ap_scoreboard_image = &_scoreboard_image;
#else /* must be USE_SHMGET_SCOREBOARD */
            ap_scoreboard_image =
                (scoreboard *)input_parms.child.scoreboard_heap;
#endif
            ap_init_mutex_method(ap_default_mutex_method());
            child_main(input_parms.child.slot);
        }
        else
            STANDALONE_MAIN(argc, argv);
    }
#endif
a4709 11
#ifdef MPE
	/* No such thing as root on MPE, so try to switch unconditionally */
	GETPRIVMODE();
	if (setuid(ap_user_id) == -1) {
	    GETUSERMODE();
	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
			"setuid: unable to change to uid: %d", ap_user_id);
	    exit(1);
	}
	GETUSERMODE();
#else
a4714 3
#ifdef CYGWIN
    if ((getuid() == SYSTEM_UID) && setuid(ap_user_id) == -1) {
#else
a4715 1
#endif
a4720 1
#endif
a4724 9
#ifdef MPE
/* HP MPE 5.5 inetd only passes the incoming socket as stdin (fd 0), whereas
   HPUX inetd passes the incoming socket as stdin (fd 0) and stdout (fd 1).
   Go figure.  SR 5003355016 has been submitted to request that the existing
   functionality be documented, and then to enhance the functionality to be
   like HPUX. */
    sock_in = fileno(stdin);
    sock_out = fileno(stdin);
#else
a4726 1
#endif
a5003 9
#ifdef NETWARE
    TSD* tsd = NULL;

    while(tsd == NULL) {
        tsd = (TSD*) Thread_Data_Area;
        ThreadSwitchWithDelay();
    }
    init_name_space();
#endif
a5020 3
#ifdef NETWARE
    tsd = (TSD*) Thread_Data_Area;
#endif
a5025 3
#ifdef NETWARE
        ThreadSwitch();
#endif
a5152 3
#ifdef NETWARE
void child_main(void* child_num_arg)
#else
a5153 1
#endif
a5161 8
#ifdef NETWARE
    TSD Tsd;
    int *thread_ptr;
    memset(&Tsd, 0, sizeof(TSD));
    thread_ptr = __get_thread_data_area_ptr();
    *thread_ptr = (int) &Tsd;
	child_sub_main((int)child_num_arg);
#else
a5162 1
#endif
a5175 40
#ifdef WIN32
/*
 * The Win32 call WaitForMultipleObjects will only allow you to wait for 
 * a maximum of MAXIMUM_WAIT_OBJECTS (current 64).  Since the threading 
 * model in the multithreaded version of apache wants to use this call, 
 * we are restricted to a maximum of 64 threads.  This is a simplistic 
 * routine that will increase this size.
 */
static DWORD wait_for_many_objects(DWORD nCount, CONST HANDLE *lpHandles, 
                            DWORD dwSeconds)
{
    time_t tStopTime;
    DWORD dwRet = WAIT_TIMEOUT;
    DWORD dwIndex=0;
    BOOL bFirst = TRUE;
  
    tStopTime = time(NULL) + dwSeconds;
  
    do {
        if (!bFirst)
            Sleep(1000);
        else
            bFirst = FALSE;
          
        for (dwIndex = 0; dwIndex * MAXIMUM_WAIT_OBJECTS < nCount; dwIndex++) {
            dwRet = WaitForMultipleObjects(
                        min(MAXIMUM_WAIT_OBJECTS, 
                            nCount - (dwIndex * MAXIMUM_WAIT_OBJECTS)),
                        lpHandles + (dwIndex * MAXIMUM_WAIT_OBJECTS), 
                        0, 0);
                                           
            if (dwRet != WAIT_TIMEOUT) {                                          
              break;
            }
        }
    } while((time(NULL) < tStopTime) && (dwRet == WAIT_TIMEOUT));
    
    return dwRet;
}
#endif
a5207 1
#ifndef NETWARE
a5259 1
#endif
a5266 184
#ifdef NETWARE
void worker_main(void)
{
    int nthreads;
    fd_set main_fds;
    int srv;
    int clen;
    int csd;
    struct sockaddr_in sa_client;
    thread **child_handles;
    int rv;
    int i;
    struct timeval tv;
    int my_pid;
    int count_select_errors = 0;
    pool *pchild;
    module **m;    
    listen_rec* lr;
    

    pchild = ap_make_sub_pool(pconf);

    ap_standalone = 1;
    sd = -1;
    nthreads = ap_threads_per_child;
    
    if (nthreads <= 0)
        nthreads = 40;
	    
    my_pid = getpid();

    ++ap_my_generation;

    copy_listeners(pconf);
    ap_restart_time = time(NULL);

    reinit_scoreboard(pconf);
    setup_listeners(pconf);

    if (listenmaxfd == -1) {
        /* Help, no sockets were made, better log something and exit */
        ap_log_error(APLOG_MARK, APLOG_CRIT|APLOG_NOERRNO, NULL,
                     "No sockets were created for listening");
        
        ap_destroy_pool(pchild);
        cleanup_scoreboard();
        exit(1);
    }
    
    set_signals();

    /* Display listening ports */
    printf("   Listening on port(s):");
    lr = ap_listeners;
    do {
       printf(" %d", ntohs(lr->local_addr.sin_port));
       lr = lr->next;
    } while(lr && lr != ap_listeners);
    
    /* Display dynamic modules loaded */
    printf("\n");    
    for (m = ap_loaded_modules; *m != NULL; m++) {
        if (((module*)*m)->dynamic_load_handle) {
            printf("   Loaded dynamic module %s\n", ap_find_module_name(*m));
        }
    }

    /*
     * - Initialize allowed_globals
     * - Create the thread table
     * - Spawn off threads
     * - Create listen socket set (done above)
     * - loop {
     *       wait for request
     *       create new job
     *   } while (!time to exit)
     * - Close all listeners
     * - Wait for all threads to complete
     * - Exit
     */

    ap_child_init_modules(pconf, server_conf);
    allowed_globals.jobmutex = ap_create_mutex(NULL);
    allowed_globals.jobsemaphore = create_semaphore(0);

    /* spawn off the threads */
    child_handles = (thread *) malloc(nthreads * sizeof(int));
    
    for (i = 0; i < nthreads; i++) {
        child_handles[i] = create_thread((void (*)(void *)) child_main, (void *) i);
    }
    
    if (nthreads > max_daemons_limit) {
        max_daemons_limit = nthreads;
    }

    while (1) {    
        tv.tv_sec = 1;
        tv.tv_usec = 0;
        
        ThreadSwitch();
        
        if (shutdown_pending)
            break;
            
        memcpy(&main_fds, &listenfds, sizeof(fd_set));
        srv = ap_select(listenmaxfd + 1, &main_fds, NULL, NULL, &tv);

        if (srv == 0) {
            count_select_errors = 0;    /* reset count of errors */
            continue;
        }
        else if (srv == SOCKET_ERROR) {
            if (h_errno != WSAEINTR) {
                /* A "real" error occurred, log it and increment the count of
                 * select errors. This count is used to ensure we don't go into
                 * a busy loop of continuous errors.
                 */
                ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, 
                             "select failed with errno %d", h_errno);
                count_select_errors++;
                if (count_select_errors > MAX_SELECT_ERRORS) {
                    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, server_conf,
                                 "Too many errors in select loop. Child process exiting.");
                    break;
                }
            }
            continue;
        } else {
            listen_rec *lr;
            
            lr = find_ready_listener(&main_fds);
	    
            if (lr != NULL) {
                sd = lr->fd;
            }
        }

        do {
            clen = sizeof(sa_client);
            csd = accept(sd, (struct sockaddr *) &sa_client, &clen);
            
            if (csd == INVALID_SOCKET) {
                csd = -1;
            }
        } while (csd < 0 && h_errno == EINTR);
	
        if (csd == INVALID_SOCKET) {
            if (h_errno != WSAECONNABORTED) {
                ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
                             "accept: (client socket) failed with errno = %d",h_errno);
            }
        }
        else {
            add_job(csd);
        }
    }

    APD2("process PID %d exiting", my_pid);

    /* Get ready to shutdown and exit */
    allowed_globals.exit_now = 1;
    
    for (i = 0; i < nthreads; i++) {
        add_job(-1);
    }

    APD2("process PID %d waiting for worker threads to exit", my_pid);
    while(ap_thread_count)
        ThreadSwitch();
    
    destroy_semaphore(allowed_globals.jobsemaphore);
    ap_destroy_mutex(allowed_globals.jobmutex);
    
    ap_child_exit_modules(pconf, server_conf);
    ap_destroy_pool(pchild);
    free(child_handles);
    cleanup_scoreboard();

    APD2("process PID %d exited", my_pid);
    clean_parent_exit(0);

}
#else
a5996 1
#endif
a6059 24
#ifdef NETWARE
extern char *optarg;

void signal_handler(int sig)
{
    switch (sig) {
    case SIGTERM:
        shutdown_pending = 1;

        while(!ap_main_finished)
            ThreadSwitchWithDelay();

        break;
    }
    return;
}
#endif

#if defined(NETWARE)
int apache_main(int argc, char *argv[])
#elif defined(WIN32)
 __declspec(dllexport)
int apache_main(int argc, char *argv[])
#else
a6060 1
#endif
a6067 40
#ifdef WIN32
    jmp_buf reparse_args;
    char *service_name = NULL;
    int install = 0;
    int reparsed = 0;
    int is_child_of_service = 0;
    char *signal_to_send = NULL;

    /* Service application under WinNT the first time through only...
     * service_main immediately resets real_exit_code to zero
     */
    if (real_exit_code && isWindowsNT()) 
    {
        if (((argc == 1) && isProcessService()) 
            || ((argc == 2) && !strcmp(argv[1], "--ntservice")))
        {
            service_main(apache_main, argc, argv);
            /* this was the end of the service control thread... 
             * cleanups already ran when second thread of apache_main
             * terminated, so simply...
             */
            exit(0);
        }
    }

    /* This behavior is voided by setting real_exit_code to 0 */
    atexit(hold_console_open_on_error);
#endif

#ifdef NETWARE
    int currentScreen = GetCurrentScreen();
    /* If top_module is not NULL then APACHEC was not exited cleanly
     * and is in a bad state.  Simply clean up and exit.
     */
    check_clean_load (top_module);
    init_name_space();
    signal(SIGTERM, signal_handler);
    atexit(clean_shutdown_on_exit);
    init_tsd();
#endif
a6084 21
#ifdef NETWARE
    if(!*ap_server_root) {
        ap_cpystrn(ap_server_root, bslash2slash(remove_filename(argv[0])),
                   sizeof(ap_server_root));
    }
#endif

#ifdef WIN32
    if(!*ap_server_root) {
        if (GetModuleFileName(NULL, ap_server_root, sizeof(ap_server_root))) {
            ap_cpystrn(ap_server_root,
                       ap_os_canonical_filename(pcommands, ap_server_root), 
                       sizeof(ap_server_root));
            if (ap_os_is_path_absolute(ap_server_root) 
                    && strchr(ap_server_root, '/'))
                *strrchr(ap_server_root, '/') = '\0';
            else 
                *ap_server_root = '\0';
        }
    }
#endif
a6092 20
#ifdef WIN32
    /* If this is a service, we will need to fall back here and 
     * reparse the entire options list.
     */
    if (setjmp(reparse_args)) {
        /* Reset and reparse the command line */
        ap_server_pre_read_config  = ap_make_array(pcommands, 1, sizeof(char *));
        ap_server_post_read_config = ap_make_array(pcommands, 1, sizeof(char *));
        ap_server_config_defines   = ap_make_array(pcommands, 1, sizeof(char *));

        /* Reset optreset and optind to allow getopt to work correctly
         * the second time around, and assure we never come back here.
         */
        optreset = 1;
        optind = 1;
        reparsed = 1;
    }

    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVlLz:Z:wiuStThk:n:W:")) != -1) {
#else /* !WIN32 */
a6093 1
#endif
a6107 90
#ifdef WIN32
        /* Shortcuts; include the -w option to hold the window open on error.
         * This must not be toggled once we reset real_exit_code to 0!
         */
        case 'w':
            if (real_exit_code)
                real_exit_code = 2;
            break;
	/* service children must be created with the -z option,
	 * while console mode (interactive apache) children are created
	 * with the -Z option
	 */
        case 'z':
            is_child_of_service = 1;
        case 'Z':
            /* Prevent holding open the (nonexistant) console */
            real_exit_code = 0;
	    exit_event = open_event(optarg);
	    APD2("child: opened process event %s", optarg);
	    cp = strchr(optarg, '_');
	    ap_assert(cp);
	    *cp = 0;
	    setup_signal_names(optarg);
	    start_mutex = ap_open_mutex(signal_name_prefix);
	    ap_assert(start_mutex);
	    child = 1;
	    break;
        case 'n':
            service_name = ap_pstrdup(pcommands, optarg);
            break;
	case 'i':
            install = 2;
	    break;
	case 'u':
            install = -1;
	    break;
	case 'k':
            if (!strcasecmp(optarg, "stop"))
                signal_to_send = "shutdown";
            else if (!strcasecmp(optarg, "install"))
                install = 2;
            else if (!strcasecmp(optarg, "config"))
                install = 1;
            else if (!strcasecmp(optarg, "uninstall"))
                install = -1;
            else
                signal_to_send = optarg;
	    break;
        case 'W':
            /* -With a dependent service */
            if (install < 1) {
	        fprintf(stderr, "%s: invalid option: -W %s ignored\n"
                        "\t-W only modifies -k install or -k config\n",
                        argv[0], optarg);
            }
            else if (!isWindowsNT()) {
                fprintf(stderr, "%s: invalid option: -W %s ignored\n"
                        "\t-W is only supported for Windows NT/2000\n",
                        argv[0], optarg);
            }
            break;
#endif /* WIN32 */
#ifdef NETWARE
        case 'e':
            {
                int screenHandle;  

                /* Get a screen handle for the console screen. */
                if ((screenHandle = CreateScreen("System Console", 0)) != NULL)
                {
                    SetAutoScreenDestructionMode(1); 
                    SetCurrentScreen(screenHandle);  /* switch to console screen I/O */
                }
            }
            break;
        case 's':
            if (DestroyScreen(GetCurrentScreen()) == 0)
            {
                int screenHandle;  

                /* Create a screen handle for the console screen, 
                even though the console screen exists. */
                if ((screenHandle = CreateScreen("System Console", 0)) != NULL)
                {
                    SetCurrentScreen(screenHandle);  /* switch to console screen I/O */
                    currentScreen = GetCurrentScreen();
                }
            }
            break;
#endif
a6123 1
#ifndef WIN32
a6126 1
#endif
a6136 3
#ifdef WIN32
            clean_parent_exit(1);
#else
a6137 1
#endif
a6141 3
#ifdef WIN32
            clean_parent_exit(1);
#else
a6142 1
#endif
a6145 3
#ifdef WIN32
            clean_parent_exit(1);
#else
a6146 1
#endif
a6149 3
#ifdef WIN32
            clean_parent_exit(1);
#else
a6150 1
#endif
a6167 3
#ifdef NETWARE
        ThreadSwitch();
#endif
a6169 67
#ifdef WIN32

    if (!service_name && install) {
        service_name = DEFAULTSERVICENAME;
    }

    if (service_name) {
        service_name = get_display_name(service_name);
    }

    if (service_name && isValidService(service_name)) 
    {
        if (install == 2) {
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, NULL,
                         "Service \"%s\" is already installed!", service_name);
            clean_parent_exit(1);
        }
        /* Don't proceed if we are configuring, uninstalling 
         * or already merged and reparsed the service args
         */
        if (!install && !reparsed)
        {
            int svcargc;
            char **newargv, **svcargv;
            if (ap_configtestonly)
                fprintf(stderr, "Default command options for service %s:\n", 
                        service_name);
                    
            /* Merge the service's default args */
            if (ap_registry_get_service_args(pcommands, &svcargc, &svcargv, 
                                             service_name) > 0) {
                newargv = (char**)malloc((svcargc + argc + 1) * sizeof(char*));
                newargv[0] = argv[0];  /* The true executable name */
                memcpy(newargv + 1, svcargv, svcargc * sizeof(char*)); 
                memcpy(newargv + 1 + svcargc, argv + 1, 
                       (argc - 1) * sizeof(char*));
                argc += svcargc; /* Add the startup options args */
                argv = newargv;
                argv[argc] = NULL;

                if (ap_configtestonly) {
                    while (svcargc-- > 0) {
                        if ((**svcargv == '-') && strchr("dfDCc", svcargv[0][1])
                            && svcargc) {
                            fprintf(stderr, "    %s %s\n", 
                                    *svcargv, *(svcargv + 1));
                            svcargv += 2; --svcargc;
                        }
                        else
                            fprintf(stderr, "    %s\n", *(svcargv++));
                    }
                }
                /* Run through the command line args all over again */
                longjmp(reparse_args, 1);
            }
            else if (ap_configtestonly)
                fprintf (stderr, "    (none)\n");
        }
    }
    else if (service_name && (install <= 1))
    {
        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, NULL,
                     "Service \"%s\" is not installed!", service_name);
        clean_parent_exit(1);
    }
#endif

a6194 31
#ifdef WIN32
    /* Read the conf now unless we are uninstalling the service,
     * or shutting down a running service 
     * (but do read the conf for the pidfile if we shutdown the console)
     */
    if ((install >= 0) && (!service_name || !signal_to_send 
                            || strcasecmp(signal_to_send,"shutdown"))) {
        server_conf = ap_read_config(pconf, ptrans, ap_server_confname);
    }

    if (install) {
        if (install > 0) 
            InstallService(pconf, service_name, argc, argv, install == 1);
        else
            RemoveService(service_name);
        clean_parent_exit(0);
    }

    /* All NT signals, and all but the 9x start signal are handled entirely.
     * Die if we failed, are on NT, or are not "start"ing the service
     */
    if (service_name && signal_to_send) {
        if (send_signal_to_service(service_name, signal_to_send, argc, argv))
            clean_parent_exit(0);
        if (isWindowsNT() || strcasecmp(signal_to_send, "start"))
            clean_parent_exit(1);
        /* Still here?  Then we are hanging around to detach the console 
         * and use this process as the Windows 9x service.
         */
    }
#else /* ndef WIN32 */
a6195 1
#endif
a6201 3
#ifdef WIN32
        clean_parent_exit(1);
#else
a6202 1
#endif
a6205 11
#ifdef WIN32
        clean_parent_exit(1);
#else
        clean_parent_exit(0);
#endif
    }

#ifdef WIN32
    /* Non-service Signals.  (Ignore -k start for now [with or without -n arg]) */
    if (signal_to_send && strcasecmp(signal_to_send, "start")) {
        send_signal(pconf, signal_to_send);
a6207 1
#endif
a6208 1
#ifndef NETWARE
a6211 1
#endif
a6214 14
#if defined(OS2)
    printf("%s running...\n", ap_get_server_version());
#elif defined(WIN32)
    if (!child) {
        printf("%s running...\n", ap_get_server_version());
    }
#elif defined(NETWARE)
    if (currentScreen != GetCurrentScreen()) {
        SetCurrentScreen(currentScreen);  /* switch to console screen I/O */
        SetAutoScreenDestructionMode(0); 
    }

    printf("%s running...\n", ap_get_server_version());
#endif
a6215 1
#ifndef NETWARE
a6219 5
#endif

#ifdef NETWARE
    worker_main();
    destroy_semaphore(allowed_globals.jobsemaphore);
a6220 3
    while((ap_thread_count) || (!shutdown_pending))
        ThreadSwitchWithDelay();
#else 
a6228 6
#ifdef WIN32
        if (child)
            ap_start_child_console(is_child_of_service);
        else
            ap_start_console_monitor();
#endif
a6232 22
#ifdef WIN32
    /* Windows NT service second time around ... we have all the overrides 
     * from the NT SCM, so go to town and return to the SCM when we quit.
     */
    if (isWindowsNT() && isProcessService())
    {
        master_main(argc, argv);
    }
    else if (service_name && signal_to_send && !isWindowsNT()
             && !strcasecmp(signal_to_send, "start")) {
        /* service95_main will call master_main() */
        service95_main(master_main, argc, argv, service_name);
    }
    else 
    {
	/* Let's go fishing for some signals including ctrl+c, ctrl+break,
         * logoff, close and shutdown, while the server is running
	 */
	ap_start_console_monitor();
        master_main(argc, argv);
    }
#else /* ndef WIN32 */
a6236 2
#endif /* ndef WIN32 */
#endif /* ndef NETWARE */
a6264 16
#if defined(OS2) || defined(CYGWIN)
/* Shared core loader for OS/2 and Cygwin */

#if defined(CYGWIN)
__declspec(dllimport) 
#endif


int ap_main(int argc, char *argv[]); /* Load time linked from cyghttpd.dll */

int main(int argc, char *argv[])
{
    return ap_main(argc, argv);
}

#else
a6282 3
#if defined(HPUX) || defined(HPUX10) || defined(HPUX11)
#define VARNAME "SHLIB_PATH"
#else
a6283 1
#endif
a6305 7
#ifdef MPE
    /*
     * MPE doesn't currently initialize the envp parameter.  Instead, we must
     * use the global variable environ. 
     */
    envp = environ;
#endif
a6337 7
#ifdef MPE
    /*
     * MPE doesn't currently initialize the envp parameter.  Instead, we must
     * use the global variable environ. 
     */
    envp = environ;
#endif
a6386 1
#endif /* def OS2 */
@


1.34
log
@merge apache 1.3.29 and mod_ssl 2.8.16
ok brad@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.33 2003/10/24 10:38:30 henning Exp $ */
d8143 1
a8143 1
API_EXPORT(int) ap_server_strip_chroot(char *src, int force)
@


1.33
log
@initgroups() before chroot(), found by Daniel Lucq
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.32 2003/09/19 17:23:27 henning Exp $ */
a3782 1
#ifdef BEOS
a3783 3
#else
	close(s);
#endif
a3792 1
#ifdef BEOS
a3793 3
#else
	close(s);
#endif
a3847 1
#ifdef BEOS
a3848 3
#else
	close(s);
#endif
a3859 1
#ifdef BEOS
a3860 3
#else
	close(s);
#endif
a3909 1
#ifdef BEOS
a3910 3
#else
	close(s);
#endif
@


1.32
log
@when dropping privileges use initgroups(3) instead of setgroups(2) so the
secondary groups get initialized as well.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.31 2003/08/21 13:11:35 henning Exp $ */
d5280 7
d5298 1
a5298 2
		if (initgroups(ap_user_name, ap_group_id) ||
		    setegid(ap_group_id) || setgid(ap_group_id) ||
@


1.31
log
@merge
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.30 2003/07/08 09:51:23 david Exp $ */
d5291 3
a5293 3
		if (setgroups(1, &ap_group_id) || setegid(ap_group_id) ||
		    setgid(ap_group_id) || seteuid(ap_user_id) || 
		    setuid(ap_user_id)) {
@


1.30
log
@declare chroot and etag functions in the .h files
and get rid of some implicit declaration warnings
ok henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.29 2003/04/08 20:13:08 henning Exp $ */
d6 1
a6 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
d387 1
d398 1
d555 8
d698 43
d780 1
d969 1
a969 1
    lock_fd = ap_popenf(p, ap_lock_fname, O_CREAT | O_WRONLY | O_EXCL, 0644);
d1036 1
a1036 1
    flock_fd = ap_popenf(p, ap_lock_fname, O_WRONLY, 0600);
d1053 1
a1053 1
    flock_fd = ap_popenf(p, ap_lock_fname, O_CREAT | O_WRONLY | O_EXCL, 0600);
a2482 31
#elif defined(USE_TPF_SCOREBOARD)

static void cleanup_scoreboard_heap()
{
    int rv;
    rv = rsysc(ap_scoreboard_image, SCOREBOARD_FRAMES, SCOREBOARD_NAME);
    if(rv == RSYSC_ERROR) {
        ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
            "rsysc() could not release scoreboard system heap");
    }
}

static void setup_shared_mem(pool *p)
{
    cinfc(CINFC_WRITE, CINFC_CMMCTK2);
    ap_scoreboard_image = (scoreboard *) gsysc(SCOREBOARD_FRAMES, SCOREBOARD_NAME);

    if (!ap_scoreboard_image) {
        fprintf(stderr, "httpd: Could not create scoreboard system heap storage.\n");
        exit(APEXIT_INIT);
    }

    ap_register_cleanup(p, NULL, cleanup_scoreboard_heap, ap_null_cleanup);
    ap_scoreboard_image->global.running_generation = 0;
}

static void reopen_scoreboard(pool *p)
{
    cinfc(CINFC_WRITE, CINFC_CMMCTK2);
}

d2534 1
a2534 1
    scoreboard_fd = ap_popenf(p, ap_scoreboard_fname, O_CREAT | O_BINARY | O_RDWR, 0666);
d2560 1
a2560 1
    scoreboard_fd = ap_popenf(p, ap_scoreboard_fname, O_CREAT | O_BINARY | O_RDWR, 0644);
d2687 5
d3346 3
d3693 1
a3693 1
static void sock_disable_nagle(int s)
d3711 9
a3719 2
	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf,
		    "setsockopt: (TCP_NODELAY)");
d3724 1
a3724 1
#define sock_disable_nagle(s)	/* NOOP */
d3773 1
a3773 1
    ap_note_cleanups_for_socket(p, s);	/* arrange to close on exec or restart */
d3779 1
a3780 1
    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *) &one, sizeof(int)) < 0) {
d3790 1
a3791 1
#endif /*_OSD_POSIX*/
d3808 1
a3808 1
    sock_disable_nagle(s);
d3914 1
a3914 1
    ap_note_cleanups_for_socket(p, s);	/* arrange to close on exec or restart */
d4021 1
a4021 1
	    ap_note_cleanups_for_socket(p, fd);
d4213 1
d4371 5
d4379 1
a4379 1
    SAFE_ACCEPT(accept_mutex_child_init(pchild));
d4625 3
a4627 3
		    ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
			"offload device inactive");
		    clean_child_exit(APEXIT_CHILDFATAL);
d4630 5
a4634 2
		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
			"select/accept error (%u)", errno);
d4672 1
a4672 1
	ap_note_cleanups_for_fd(ptrans, csd);
d4692 4
a4695 1
	    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf, "getsockname");
d4699 1
a4699 1
	sock_disable_nagle(csd);
d4723 1
a4723 1
	ap_note_cleanups_for_fd(ptrans, dupped_csd);
d5086 3
d5150 8
d5312 1
a5312 1
	    ap_note_cleanups_for_fd(pconf, scoreboard_fd);
d5366 5
a5423 11
#ifdef TPF
            ap_check_signals();
            if (!shutdown_pending) {
                if (os_check_server(tpf_server_name)) {
                    shutdown_pending++;
                } else {
                    sleep(1);
                    ap_check_signals();
                }
            }
#endif /*TPF */
d5703 1
a5723 1
            scoreboard_fd = input_parms.child.scoreboard_fd;
d5725 1
a5725 1
#else /* must be USE_TPF_SCOREBOARD or USE_SHMGET_SCOREBOARD */
d6129 1
a6129 1
	ap_note_cleanups_for_socket(ptrans, csd);
d6148 1
a6148 1
	sock_disable_nagle(csd);
d6161 1
a6161 1
	ap_note_cleanups_for_socket(ptrans, dupped_csd);
d6383 1
a6383 1
        ap_note_cleanups_for_socket(p, fd);
@


1.29
log
@easy sprintf in code we don't use
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.28 2003/02/16 17:16:12 cloder Exp $ */
d107 1
@


1.28
log
@Don't leak the inode numbers of served files via the
ETag (entity tag) header value.  Instead of including
the file modification date, inode, file size, etc.
directly in the ETag header, return a SHA1 hash of
these values instead.

This SHA1 hash is initialized with a pseudorandom
secret, so that it's harder to brute force inode
numbers.  This initialization secret is saved in a
file called "etag-state" in the httpd chroot logs/
directory, so that the ETag header values are consistent
across httpd restarts (if the secret were different
each time httpd started, ETags would change unnecessarily
and thereby cause caches to refresh unnecessarily).

An additional change is introduced: we add the dev
number to the hash when (and only when) we add the
inode number to the hash.

Before:
HTTP/1.1 200 OK
Server: Apache/1.3.27 (Unix) mod_ssl/2.8.12 OpenSSL/0.9.7-beta3
ETag: "b10d3-1e59-3e49cbe4"

In this case, we can tell the inode number of index.html
is is b10d3 hex.

After:
HTTP/1.1 200 OK
Server: Apache/1.3.27 (Unix) mod_ssl/2.8.12 OpenSSL/0.9.7-beta3
ETag: "3f3b3cb2ce2e278087960b3be6a6e9844166e371"

Idea and solution by deraadt@@.  OK deraadt@@, henning@@.  Any
bugs are my fault :)
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.27 2002/12/05 23:45:01 henning Exp $ */
d5646 1
a5646 1
        sprintf(tpf_mutex_key, "%.*x", TPF_MUTEX_KEY_SIZE - 1, getpid());
@


1.27
log
@typo in error message; Tor Houghton
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.26 2002/10/07 20:23:06 henning Exp $ */
d5201 1
@


1.26
log
@merge apache 1.3.27 and mod_ssl 2.8.11
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.25 2002/09/09 14:21:18 henning Exp $ */
d3863 1
a3863 1
			 "socket option SO_ACCEPTFILTER unkown on this machine. Continuing.");
@


1.25
log
@move OpenSSL include up
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.24 2002/09/08 17:14:57 markus Exp $ */
d398 1
d413 5
a788 1
/* it makes no sense, but this isn't defined on solaris */
d790 1
a790 1
    long val;
d1121 1
a1121 1
        coruc(RESOURCE_KEY);
d1134 1
a1134 1
    corhc(RESOURCE_KEY);
d1141 1
a1141 1
    coruc(RESOURCE_KEY);
d2385 3
a2387 1
    else {			/* only worry about permissions if we attached the segment */
d4174 1
d5645 1
d7464 1
a7464 1
    while ((c = getopt(argc, argv, "D:C:c:Xd:fF:vVlLesStTh")) != -1) {
@


1.25.2.1
log
@Pull in patch from current:
Fix (miod?, henning?):
 *) SECURITY CAN-2002-0839 (cve.mitre.org)
    Add the new directive 'ShmemUIDisUser'. By default, Apache
    will no longer set the uid/gid of SysV shared memory scoreboard
    to User/Group, and it will therefore stay the uid/gid of
    the parent Apache process. This is actually the way it should
    be, however, some implementations may still require this, which
    can be enabled by 'ShmemUIDisUser On'.  Reported by iDefense.
    [Jim Jagielski]
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.25 2002/09/09 14:21:18 henning Exp $ */
d2379 14
@


1.25.2.2
log
@Pull patch from current:
Fix by cloder@@ and henning@@

Don't leak httpd child PIDs via multipart MIME boundary separators.
Instead, generate a random MIME boundary separator that is also
much longer, which makes it less likely to occur in the data.

Since the base64 alphabet includes the characters  '/', '+',
and '=', it may violate section 4 of RFC 1341, which says that these
kinds of characters must be quoted in order to be used as a header
parameter. Pointed out by Wouter Clarie (rimshot AT pandora DOT be).

Don't leak the inode numbers of served files via the ETag (entity tag)
header value.  Instead of including the file modification date, inode,
file size, etc. directly in ETag header, return a SHA1 hash of these
values instead.
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.28 2003/02/16 17:16:12 cloder Exp $ */
a5178 1
	ap_init_etag(pconf);
@


1.24
log
@missing include for evp.h; ok henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.23 2002/09/04 12:28:42 henning Exp $ */
d128 3
a208 4
#endif

#ifdef MOD_SSL
#include <openssl/evp.h>
@


1.23
log
@remove some unnecessary casts and adjust format strings
looked over by dhartmei@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.22 2002/07/31 09:02:28 henning Exp $ */
d206 4
@


1.22
log
@#ifdef MOD_SSL for OpenSSL initialization
pointed out buy Stephane Engel
Thankski!
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.21 2002/07/29 16:47:22 henning Exp $ */
d4351 1
a4351 1
		    "setuid: unable to change to uid: %ld", (long) ap_user_id);
d5225 2
a5226 2
			server_conf, "changed to uid %ld, gid %ld",
			(long)ap_user_id, (long)ap_group_id);
d5375 2
a5376 2
				 "removed PID file %s (pid=%ld)",
				 pidfile, (long)getpid());
d5704 2
a5705 2
			"setuid: unable to change to uid: %ld",
			(long) ap_user_id);
d7238 2
a7239 2
			 "removed PID file %s (pid=%ld)",
			 pidfile, (long)getpid());
@


1.21
log
@fix -u description in httpd -h: we don't chroot into DocumentRoot but
ServerRoot.
noticed by "Aaron Yourk" <ayourk@@srt.com>
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.20 2002/07/22 18:25:31 henning Exp $ */
d5202 1
d5204 1
@


1.20
log
@don't attempt to chroot if we are already chrooted ;-)
(happens on SIGHUP aka apachectl restart)
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.19 2002/07/20 10:38:25 henning Exp $ */
d1420 1
a1420 1
    fprintf(stderr, "  -u               : Unsecure mode. Do not chroot into DocumentRoot.\n");
@


1.19
log
@short -u description in httpd -h
pointed out by Sam Smith
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.18 2002/07/19 21:31:15 henning Exp $ */
d5192 1
a5192 1
	if(!is_graceful)
@


1.18
log
@merge
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.16 2002/07/16 14:08:34 henning Exp $ */
d1420 1
@


1.17
log
@o add ap_server_chroot_desired in http_main which just returns ap_server_chroot
o fdcache clean up on exit
o use fdcache for mod_log_config. survives graceful restarts now as long as
  no new logfile has to be opened. the latter is impossible because we lack
  the permission to do so once started.
@
text
@d352 2
d1395 1
a1395 1
    fprintf(stderr, "       %s [-v] [-V] [-h] [-l] [-L] [-S] [-t] [-T] [-u]\n", pad);
d1418 3
d2784 1
d2794 2
a2795 1
	 * Set delay with an exponential backoff.
d2800 3
a2802 1
	ap_select(0, NULL, NULL, NULL, &tv);
d3436 9
a3444 6
    if ((x = fork()) > 0)
	exit(0);
    else if (x == -1) {
	perror("fork");
	fprintf(stderr, "%s: unable to fork new process\n", ap_server_argv0);
	exit(1);
a3445 1
    RAISE_SIGSTOP(DETACH);
d3451 3
d3468 7
a4204 3
#ifdef DEFAULT_XFERLOG
    printf(" -D DEFAULT_XFERLOG=\"" DEFAULT_XFERLOG "\"\n");
#endif
d4336 7
a4342 1
    /* Only try to switch if we're running as root */
d4344 1
d4927 3
a4929 2
 * scoreboard pool is not growing to infinity. This effect has been
 * seen at least on Cygwin 1.x. -- Stipe Tolj <tolj@@wapme-systems.de>
d4933 1
d4936 1
d5008 1
a5008 1
		    kill(ps->pid, SIGALRM);
d5497 1
a5497 1
				    "D:C:c:xXd:f:vVlLR:StThu"
d5519 3
d5633 1
d5640 8
a5649 1
            server_conf->error_log = NULL;
d5690 8
a5697 1
	/* Only try to switch if we're running as root */
d5699 1
d7449 1
a7449 1
    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVlLesStTh")) != -1) {
d7571 5
d7911 1
a7911 1
int ap_main(int argc, char *argv[]); /* Load time linked from libhttpd.dll */
d7977 1
a7977 1
    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVlLR:SZ:tTh")) != -1) {
d7984 1
@


1.16
log
@correct error message
@
text
@d1 1
a1 1
/* $OpenBSD: http_main.c,v 1.15 2002/07/15 09:40:49 henning Exp $ */
d2606 1
d8049 4
@


1.15
log
@don't try things we are not able to do if chrooted on graceful restarts.
this does not mean a chrooted httpd survives a graceful restart (yet).
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d5165 3
a5167 3
		    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
			"can't run in secure mode if not started with "
			"root privs.");
d5175 1
a5175 1
		    ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
@


1.14
log
@open /dev/crypto with OpenSSL_add_all_algorithms() before calling chroot;
@
text
@d1 2
d4345 3
a4347 1
    signal(SIGALRM, alrm_handler);
d5147 11
a5157 2
	ap_open_logs(server_conf, plog);
	ap_log_pid(pconf, ap_pid_fname);
d5162 8
a5169 4
	if(!is_graceful && ap_server_chroot) {

	    /* initialize /dev/crypto, XXX check for -DSSL option */
	    OpenSSL_add_all_algorithms();
d5171 2
a5172 5
	    if (geteuid()) {
		ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
		   "can't run in secure mode if not started with root privs.");
		exit(1);
	    }
d5174 1
a5174 14
	    if (chroot(ap_server_root) < 0) {
		ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
		    "unable to chroot into %s!", ap_server_root);
		exit(1);
	    }
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
		"chrooted in %s", ap_server_root);
	    chdir("/");
	    is_chrooted = 1;
	    setproctitle("parent [chroot %s]", ap_server_root);

	    if (setgroups(1, &ap_group_id) || setegid(ap_group_id) ||
		setgid(ap_group_id) || seteuid(ap_user_id) || 
		setuid(ap_user_id)) {
d5176 1
a5176 1
			"can't drop priviliges!");
d5178 20
a5197 6
	    } else
		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE,
		    server_conf, "changed to uid %ld, gid %ld",
		    (long)ap_user_id, (long)ap_group_id);
	} else
	    setproctitle("parent");
d8041 5
@


1.13
log
@I am getting sick of telling people to use the style of the code they change
@
text
@d5150 4
@


1.12
log
@apache chroot and privilege drop.
httpd will chroot itself into ServerRoot (/var/www) and drop root privileges
now. This is enabled by default. Make sure to read httpd(8).

help deraadt@@
ssl mutex fixes beck@@

"commit" deraadt@@
@
text
@d5156 1
a5156 1
	    if(chroot(ap_server_root) < 0) {
d5167 1
a5167 1
	    if ( setgroups(1, &ap_group_id) || setegid(ap_group_id) ||
d5169 1
a5169 1
		setuid(ap_user_id) ) {
@


1.11
log
@do not install a SIGSEGV handler
@
text
@d321 3
d984 1
d1391 1
a1391 1
    fprintf(stderr, "       %s [-v] [-V] [-h] [-l] [-L] [-S] [-t] [-T]\n", pad);
d4292 2
d5148 32
d5320 1
d5449 1
a5449 1
				    "D:C:c:xXd:f:vVlLR:StTh"
d5526 3
d8011 12
@


1.10
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d3312 1
d3315 1
d3367 1
d3369 1
@


1.10.2.1
log
@Pull in patch from current:
Fix (henning):
By default, Apache will no longer set the uid/gid of SysV shared memory
scoreboard to User/Group, and it will therefore stay the uid/gid of
the parent Apache process. This is actually the way it should be.
Reported by iDefense.
[Jim Jagielski]
@
text
@d2365 14
@


1.9
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d120 1
a120 1
#elif !defined(BEOS) && !defined(TPF) && !defined(NETWARE) && !defined(OS390)
d169 2
a170 2
extern void ap_force_library_loading(void);
void ap_force_library_loading(void) {
a230 1
 
a231 1
int ap_thread_count = 0;
d235 1
d237 1
a237 1
int ap_configtestonly=0;
d250 1
a250 1
char *ap_lock_fname;
d252 1
a252 1
struct in_addr ap_bind_address;
d257 1
a257 1
time_t ap_restart_time=0;
d259 21
a279 1
int ap_listenbacklog;
d310 1
a310 1
listen_rec *ap_listeners;
d315 1
a315 1
char ap_coredump_dir[MAX_STRING_LEN];
d317 3
a319 3
array_header *ap_server_pre_read_config;
array_header *ap_server_post_read_config;
array_header *ap_server_config_defines;
d543 14
a556 1
#if defined(USE_FCNTL_SERIALIZED_ACCEPT) || defined(USE_FLOCK_SERIALIZED_ACCEPT)
d565 1
a565 2
#if defined (USE_USLOCK_SERIALIZED_ACCEPT)

a566 1

d569 1
a569 1
#define accept_mutex_child_init(x)
d571 1
a571 1
static void accept_mutex_init(pool *p)
d602 1
a602 1
static void accept_mutex_on(void)
d617 1
a617 1
static void accept_mutex_off(void)
d625 10
a634 1
#elif defined (USE_PTHREAD_SERIALIZED_ACCEPT)
d649 1
a649 1
static void accept_mutex_child_cleanup(void *foo)
d657 1
a657 1
static void accept_mutex_child_init(pool *p)
d659 1
a659 1
    ap_register_cleanup(p, NULL, accept_mutex_child_cleanup, ap_null_cleanup);
d662 1
a662 1
static void accept_mutex_cleanup(void *foo)
d671 1
a671 1
static void accept_mutex_init(pool *p)
d684 1
a684 1
	perror("mmap");
d692 4
d701 1
d710 1
a710 1
    ap_register_cleanup(p, NULL, accept_mutex_cleanup, ap_null_cleanup);
d713 1
a713 1
static void accept_mutex_on(void)
d735 1
a735 1
static void accept_mutex_off(void)
d757 10
a766 1
#elif defined (USE_SYSVSEM_SERIALIZED_ACCEPT)
d790 1
a790 1
static void accept_mutex_cleanup(void *foo)
d801 1
a801 1
#define accept_mutex_child_init(x)
d803 1
a803 1
static void accept_mutex_init(pool *p)
d832 1
a832 1
    ap_register_cleanup(p, NULL, accept_mutex_cleanup, ap_null_cleanup);
d843 1
a843 1
static void accept_mutex_on(void)
d853 1
a853 1
static void accept_mutex_off(void)
d863 10
a872 1
#elif defined(USE_FCNTL_SERIALIZED_ACCEPT)
d878 1
a878 1
#define accept_mutex_child_init(x)
d884 1
a884 1
static void accept_mutex_init(pool *p)
d908 1
a908 1
static void accept_mutex_on(void)
d925 1
a925 1
static void accept_mutex_off(void)
d941 10
a950 1
#elif defined(USE_FLOCK_SERIALIZED_ACCEPT)
d952 1
a952 1
static int lock_fd = -1;
d954 1
a954 1
static void accept_mutex_cleanup(void *foo)
d963 1
a963 1
static void accept_mutex_child_init(pool *p)
d966 2
a967 2
    lock_fd = ap_popenf(p, ap_lock_fname, O_WRONLY, 0600);
    if (lock_fd == -1) {
d978 1
a978 1
static void accept_mutex_init(pool *p)
d982 2
a983 2
    lock_fd = ap_popenf(p, ap_lock_fname, O_CREAT | O_WRONLY | O_EXCL, 0600);
    if (lock_fd == -1) {
d988 1
a988 1
    ap_register_cleanup(p, NULL, accept_mutex_cleanup, ap_null_cleanup);
d991 1
a991 1
static void accept_mutex_on(void)
d995 1
a995 1
    while ((ret = flock(lock_fd, LOCK_EX)) < 0 && errno == EINTR)
d1005 1
a1005 1
static void accept_mutex_off(void)
d1007 1
a1007 1
    if (flock(lock_fd, LOCK_UN) < 0) {
d1014 10
a1023 1
#elif defined(USE_OS2SEM_SERIALIZED_ACCEPT)
d1027 1
a1027 1
static void accept_mutex_cleanup(void *foo)
d1037 1
a1037 1
static void accept_mutex_child_init(pool *p)
d1046 1
a1046 1
        ap_register_cleanup(p, NULL, accept_mutex_cleanup, ap_null_cleanup);
d1054 1
a1054 1
static void accept_mutex_init(pool *p)
d1064 1
a1064 1
    ap_register_cleanup(p, NULL, accept_mutex_cleanup, ap_null_cleanup);
d1067 1
a1067 1
static void accept_mutex_on(void)
d1078 1
a1078 1
static void accept_mutex_off(void)
d1089 10
a1098 1
#elif defined(USE_TPF_CORE_SERIALIZED_ACCEPT)
d1102 1
a1102 1
static void accept_mutex_cleanup(void *foo)
d1108 1
a1108 1
#define accept_mutex_init(x)
d1110 1
a1110 1
static void accept_mutex_child_init(pool *p)
d1112 1
a1112 1
    ap_register_cleanup(p, NULL, accept_mutex_cleanup, ap_null_cleanup);
d1116 1
a1116 1
static void accept_mutex_on(void)
d1123 1
a1123 1
static void accept_mutex_off(void)
d1130 71
a1200 4
#else
/* Default --- no serialization.  Other methods *could* go here,
 * as #elifs...
 */
d1205 9
a1213 4
#define accept_mutex_child_init(x)
#define accept_mutex_init(x)
#define accept_mutex_on()
#define accept_mutex_off()
d1215 137
d1353 3
d1405 1
d1418 2
d1422 1
a1422 1
#ifdef NETWARE
d1538 1
a1538 1
                log_req->request_time = time(0);
d1610 1
a1610 1
#ifdef WIN32
a1622 1
#ifdef EAPI
a1623 3
#else
unsigned int ap_set_callback_and_alarm(void (*fn) (int), int x)
#endif
d1628 1
d1635 1
a1635 1
	old -= time(0);
d1642 1
a1642 1
	alarm_expiry_time = time(NULL) + x;
d1671 1
a1671 1
#if defined(WIN32) || defined(NETWARE)
d1717 1
a1717 1
void ap_keepalive_timeout(char *name, request_rec *r)
d1913 5
a1917 1
             (read(lsd, dummybuf, sizeof dummybuf) > 0));
d2565 13
d2603 1
a2603 1
int ap_update_child_status(int child_num, int status, request_rec *r)
d2860 1
a2860 1
		(*ocr->maintenance) (OC_REASON_DEATH, ocr->data, (ap_wait_t)status);
d3162 1
a3162 1
ap_generation_t volatile ap_my_generation=0;
d3412 2
a3413 1
#if !defined(MPE) && !defined(OS2) && !defined(TPF)
d3552 1
a3552 1
#if !defined(WIN32) && !defined(NETWARE)
d3800 1
a3800 1
    {
d3802 4
d3808 2
d3817 8
a3824 8
	if (setsockopt(s, SOL_SOCKET, SO_ACCEPTFILTER, &af, sizeof(af)) < 0
	    && errno != ENOENT) {
	    ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
			 "make_sock: for %s, setsockopt: (SO_ACCEPTFILTER)",
			 addr);
	    close(s);
	    ap_unblock_alarms();
	    exit(1);
d3941 1
d4050 3
a4070 6
#ifdef USE_TPF_SCOREBOARD
    printf(" -D USE_TPF_SCOREBOARD\n");
#endif
#ifdef NO_SAWNC
    printf(" -D NO_SAWNC\n");
#endif
d4089 8
a4096 2
#ifdef USE_FCNTL_SERIALIZED_ACCEPT
    printf(" -D USE_FCNTL_SERIALIZED_ACCEPT\n");
d4098 2
a4099 2
#ifdef USE_FLOCK_SERIALIZED_ACCEPT
    printf(" -D USE_FLOCK_SERIALIZED_ACCEPT\n");
d4101 2
a4102 2
#ifdef USE_USLOCK_SERIALIZED_ACCEPT
    printf(" -D USE_USLOCK_SERIALIZED_ACCEPT\n");
d4104 2
a4105 2
#ifdef USE_SYSVSEM_SERIALIZED_ACCEPT
    printf(" -D USE_SYSVSEM_SERIALIZED_ACCEPT\n");
d4107 8
a4114 2
#ifdef USE_PTHREAD_SERIALIZED_ACCEPT
    printf(" -D USE_PTHREAD_SERIALIZED_ACCEPT\n");
d4143 10
d4158 1
a4158 1
#ifdef SUEXEC_BIN
d4452 13
d4661 11
d4856 1
a4856 1
    time_t now = time(0);
d4882 14
d4902 1
a4902 1
    time_t now = time(0);
d4975 2
a4976 1
	 * while we were counting
d4978 1
a4978 1
	kill(ap_scoreboard_image->parent[to_kill].pid, SIGUSR1);
d5128 2
d5185 3
d5213 1
a5213 1
			make_child(server_conf, child_slot, time(0));
d5253 9
a5261 3
        shutdown_pending = os_check_server(tpf_server_name);
        ap_check_signals();
        sleep(1);
d5353 9
d5534 1
a5534 1
        ap_open_logs(server_conf, pconf);
d5552 1
d5786 1
a5786 1
int remove_job(void)
d5788 2
d5793 8
d5830 1
d5836 1
d5840 13
a5892 1

d5894 1
a5895 2
#endif

d5938 1
a5938 1
	csd = remove_job();
d5941 1
a5941 1
		    
d5999 8
a6006 1

a6045 1
#ifdef NETWARE
a6046 1
#endif
d6376 1
a6376 1
      
d6519 4
d6530 2
a6531 1
            /* MaxRequestsPerChild hit...
d6533 1
d6598 1
a6598 1
      
d6714 1
a6714 1
    HANDLE hNullError = NULL;
d6780 6
a6785 8
    /* Open a null handle to soak info from the child */
    hNullError = CreateFile("nul", GENERIC_READ | GENERIC_WRITE, 
                            FILE_SHARE_READ | FILE_SHARE_WRITE, 
                            &sa, OPEN_EXISTING, 0, NULL);
    if (hNullError == INVALID_HANDLE_VALUE) {
        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                     "Parent: Unable to create null error pipe for child process.\n");
        return -1;
d6806 1
a6806 1
    si.hStdError   = hNullError;
a6823 1
        CloseHandle(hNullError);        
a6870 1
    CloseHandle(hNullError);        
d7045 5
a7049 1
            /* apPID_restart event signalled, restart the child process */
d7067 1
a7067 1
	    processes_to_create = nchild;
d7071 2
a7072 4
            /* A child process must have exited because of MaxRequestPerChild being hit
             * or a fatal error condition (seg fault, etc.). Remove the dead process 
             * from the process_handles and process_kill_events table and create a new
             * child process.
d7075 1
a7075 1
                         "master_main: Child processed exited (due to MaxRequestsPerChild?). Restarting the child process.");
a7130 2

    service_set_status(SERVICE_STOPPED);
d7247 5
a7251 1
            clean_parent_exit(0);
d7260 5
d7267 1
d7334 1
a7334 1
    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVlLz:Z:wiuStThk:n:")) != -1) {
d7336 1
a7336 1
    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVlLsStTh")) != -1) {
d7400 13
d7415 12
d7428 12
a7439 1
            DestroyScreen(GetCurrentScreen());
d7526 4
a7622 2
        if (!service_name)
            service_name = ap_pstrdup(pconf, DEFAULTSERVICENAME);
d7689 5
a7693 1
    clrscr();
d7785 7
a7791 2
#ifdef OS2
/* Shared core loader for OS/2 */
@


1.8
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1995-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 20
a38 23
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 7
a56 6
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
d677 5
d688 1
d695 5
a704 13
    /* There is a slight race condition right here... if we were to die right
     * now, we'd do another pthread_mutex_unlock.  Now, doing that would let
     * another process into the mutex.  pthread mutexes are designed to be
     * fast, as such they don't have protection for things like testing if the
     * thread owning a mutex is actually unlocking it (or even any way of
     * testing who owns the mutex).
     *
     * If we were to unset have_accept_mutex prior to releasing the mutex
     * then the race could result in the server unable to serve hits.  Doing
     * it this way means that the server can continue, but an additional
     * child might be in the critical section ... at least it's still serving
     * hits.
     */
d706 1
d1075 5
a1086 3
#ifdef WIN32
    fprintf(stderr, "       %s [-n service] [-k signal] [-i] [-u]\n", pad);
#endif
d1091 1
d1109 2
a1110 2
    fprintf(stderr, "  -n name          : set service name and use its ServerConfigFile\n");
    fprintf(stderr, "  -k shutdown      : tell running Apache to shutdown\n");
d1113 3
a1115 2
    fprintf(stderr, "  -i               : install an Apache service\n");
    fprintf(stderr, "  -u               : uninstall an Apache service\n");
d2890 1
d3162 1
a3162 1
#if !defined(WIN32) && !defined(NETWARE) && !defined(BEOS)
a3615 5
	if (fd >= 0) {
	    FD_SET(fd, &listenfds);
	    if (fd > listenmaxfd)
		listenmaxfd = fd;
	}
d3745 2
a3746 2
#ifdef USE_TPF_DAEMON
    printf(" -D USE_TPF_DAEMON\n");
d5126 7
a5133 6
        if(!tpf_child) {
            memcpy(tpf_server_name, input_parms.parent.servname,
                   INETD_SERVNAME_LENGTH);
            tpf_server_name[INETD_SERVNAME_LENGTH+1] = '\0';
            ap_open_logs(server_conf, pconf);
        }
d5192 1
a5192 6
#ifdef TPF
/* TPF's Internet Daemon passes the incoming socket nbr (inetd mode only) */
    sock_in = sock_out = input_parms.parent.socket;
/* TPF also needs a signal set for alarm in inetd mode */
    signal(SIGALRM, alrm_handler);
#elif defined(MPE)
d6274 2
d6309 7
a6315 1
    pCommand = ap_psprintf(p, "\"%s\" -Z %s -f \"%s\"", buf, exit_event_name, ap_server_confname);  
d6331 20
d6365 1
a6365 1
    si.dwFlags     = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
d6368 2
d6384 4
d6434 2
a6760 16
int service_init()
{
    common_init();
 
    ap_cpystrn(ap_server_root, HTTPD_ROOT, sizeof(ap_server_root));
    if (ap_registry_get_service_conf(pconf, ap_server_confname, sizeof(ap_server_confname),
                                     ap_server_argv0))
        return FALSE;

    ap_setup_prelinked_modules();
    server_conf = ap_read_config(pconf, ptrans, ap_server_confname);
    ap_log_pid(pconf, ap_pid_fname);
    post_parse_init();
    return TRUE;
}

d6794 1
a6794 2
    char cwd[MAX_STRING_LEN];

d6796 1
d6799 2
d6803 4
a6806 2
    /* Service application under WinNT */
    if (isWindowsNT()) 
d6811 1
a6811 1
            service_main(master_main, argc, argv);
d6837 5
a6841 1
    
d6847 40
a6886 5
#else
    if(!GetCurrentDirectory(sizeof(cwd),cwd)) {
       ap_log_error(APLOG_MARK,APLOG_EMERG|APLOG_WIN32ERROR, NULL,
       "GetCurrentDirectory() failure");
       return -1;
d6889 3
a6891 2
    ap_cpystrn(cwd, ap_os_canonical_filename(pcommands, cwd), sizeof(cwd));
    ap_cpystrn(ap_server_root, cwd, sizeof(ap_server_root));
a6892 2

    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVlLZ:iusStThk:n:")) != -1) {
d6908 14
a6921 1
	case 'Z':
d6938 1
a6938 1
	    install = 1;
d6941 1
a6941 4
	    install = -1;
	    break;
	case 'S':
	    ap_dump_settings = 1;
d6946 6
d6961 3
d6967 2
a6968 2
	        optarg = ap_pstrcat(pcommands, cwd, optarg, NULL);
                ap_getparents(optarg);
d6970 6
a6975 5
            if (optarg[strlen(optarg)-1] != '/')
                optarg = ap_pstrcat(pcommands, optarg, "/", NULL);
            ap_cpystrn(ap_server_root,
                       optarg,
                       sizeof(ap_server_root));
d6987 3
a6989 1
#ifdef NETWARE
a6990 2
#else
            clean_parent_exit(1);
d6996 3
a6998 1
#ifdef NETWARE
a6999 2
#else
            clean_parent_exit(1);
d7004 3
a7006 1
#ifdef NETWARE
a7007 2
#else
            clean_parent_exit(1);
d7012 3
a7014 1
#ifdef NETWARE
a7015 2
#else
            clean_parent_exit(1);
d7040 1
d7047 1
a7047 5
        ap_registry_get_service_conf(pconf, ap_server_confname, 
                                     sizeof(ap_server_confname),
                                     service_name);
        conf_specified = 1;
        if (install > 0) {
d7052 41
d7094 1
a7094 1
    else if (service_name && (install <= 0))
d7102 9
a7110 6
    /* ServerConfFile is found in this order:
     * (1) -f or -n
     * (2) [-d]/SERVER_CONFIG_FILE
     * (3) ./SERVER_CONFIG_FILE
     * (4) [Registry: HKLM\Software\[product]\ServerRoot]/SERVER_CONFIG_FILE
     * (5) /HTTPD_ROOT/SERVER_CONFIG_FILE
d7112 2
a7113 2
     
    if (!conf_specified) {
a7114 10
        if (access(ap_server_root_relative(pcommands, ap_server_confname), 0)) {
#ifndef NETWARE
            ap_registry_get_server_root(pconf, ap_server_root, sizeof(ap_server_root));
#endif
            if (!*ap_server_root)
                ap_cpystrn(ap_server_root, HTTPD_ROOT, sizeof(ap_server_root));
            ap_cpystrn(ap_server_root, ap_os_canonical_filename(pcommands, ap_server_root),
                       sizeof(ap_server_root));
        }
    }
d7120 4
a7123 7
    if (!ap_os_is_path_absolute(ap_server_confname)) {
        char *full_conf_path;

        full_conf_path = ap_pstrcat(pcommands, ap_server_root, "/", ap_server_confname, NULL);
        full_conf_path = ap_os_canonical_filename(pcommands, full_conf_path);
        ap_cpystrn(ap_server_confname, full_conf_path, sizeof(ap_server_confname));
    }
d7126 1
a7126 1

d7141 1
a7141 2
            InstallService(service_name, ap_server_root_relative(pcommands, 
                                                         ap_server_confname));
a7146 5
    if (service_name && !conf_specified) {
        printf("Unknown service: %s\n", service_name);
        clean_parent_exit(1);
    }

d7151 1
a7151 1
        if (send_signal_to_service(service_name, signal_to_send))
d7168 3
d7172 1
d7176 3
d7180 1
d7233 4
a7236 2
	if (child)
	    FreeConsole();
d7243 7
@


1.7
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d236 1
a236 1
int ap_standalone=0;
d239 3
a241 3
uid_t ap_user_id=0;
char *ap_user_name=NULL;
gid_t ap_group_id=0;
d245 5
a249 5
int ap_max_requests_per_child=0;
int ap_threads_per_child=0;
int ap_excess_requests_per_child=0;
char *ap_pid_fname=NULL;
char *ap_scoreboard_fname=NULL;
d251 1
a251 1
char *ap_server_argv0=NULL;
d253 4
a256 4
int ap_daemons_to_start=0;
int ap_daemons_min_free=0;
int ap_daemons_max_free=0;
int ap_daemons_limit=0;
d258 1
a258 1
int ap_suexec_enabled = 0;
d294 1
a294 1
char ap_server_confname[MAX_STRING_LEN]="";
d429 4
a432 1
    if (ap_server_tokens == SrvTk_MIN) {
d1100 3
d1137 12
a1148 1
#define get_tsd            TSD* tsd = (TSD*) GetThreadDataAreaPtr();
d2255 4
d2261 1
d2265 5
d2271 1
a2271 1
#endif
d2274 1
d2587 1
a2623 25
#elif defined(NETWARE)
    struct timeval tv;
    int ret = 0;

    ++wait_or_timeout_counter;
    if (wait_or_timeout_counter == INTERVAL_OF_WRITABLE_PROBES) {
	    wait_or_timeout_counter = 0;
#ifndef NO_OTHER_CHILD
	    probe_writable_fds();
#endif
    }

    if (ret == -1 && errno == EINTR) {
	    return -1;
    }

    if (ret > 0) {
	    return ret;
    }
    
    tv.tv_sec = SCOREBOARD_MAINTENANCE_INTERVAL / 1000000;
    tv.tv_usec = SCOREBOARD_MAINTENANCE_INTERVAL % 1000000;
    ap_select(0, NULL, NULL, NULL, &tv);
    return -1;

d2653 1
a2653 1

d2929 1
a2929 1
void ap_start_shutdown(void)
d2946 1
a2946 1
void ap_start_restart(int graceful)
d3157 1
a3157 1
#if !defined(WIN32) && !defined(NETWARE)
d3187 3
d3191 3
d3199 3
d3220 1
a3220 1
#endif /* ndef WIN32 */
d3228 1
a3228 1
#ifndef WIN32
d3378 1
a3378 1
    closesocket(s);
d3383 1
a3383 1
	return -1;
d3392 1
a3392 1
    closesocket(s);
d3398 1
a3398 1
	return -1;
d3451 1
a3451 1
    closesocket(s);
d3467 1
a3467 1
    closesocket(s);
d3475 24
d3515 1
a3515 1
    closesocket(s);
d3519 1
a3519 1
	return -1;
a3551 4
#ifdef NETWARE
        ThreadSwitch();
#endif
	
d3606 1
a3606 1
        fd = make_sock(p, &lr->local_addr);
d3616 3
a3652 3
#ifdef NETWARE
	ThreadSwitch();
#endif
d3950 3
a3952 9
    /* Only try to switch if we're running as MANAGER.SYS */
    if (geteuid() == 1 && ap_user_id > 1) {
	GETPRIVMODE();
	if (setuid(ap_user_id) == -1) {
	    GETUSERMODE();
	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
			"setuid: unable to change to uid: %d", ap_user_id);
	    exit(1);
	}
d3954 3
d3958 1
d5169 3
a5171 9
	/* Only try to switch if we're running as MANAGER.SYS */
	if (geteuid() == 1 && ap_user_id > 1) {
	    GETPRIVMODE();
	    if (setuid(ap_user_id) == -1) {
		GETUSERMODE();
		ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
			    "setuid: unable to change to uid: %d", ap_user_id);
		exit(1);
	    }
d5173 3
d5177 1
d5464 1
a5464 1
        tsd = (TSD*) GetThreadDataAreaPtr();
d5468 1
a5468 3
    SetCurrentNameSpace(4);
    SetTargetNameSpace(4);

d5489 1
a5489 1
    tsd = (TSD*) GetThreadDataAreaPtr();
a5565 3
#ifdef NETWARE
            ThreadSwitch();
#endif
d5636 1
a5636 1

d5638 2
a5639 1
	SaveThreadDataAreaPtr(&Tsd);
a5798 1
    int total_jobs = 0;
a5803 1
    
d5806 3
d5836 1
a5836 1
        exit(0);
d5841 16
a5944 1
            total_jobs++;
d5952 1
a5952 2
    ap_release_mutex(start_mutex);

d6038 1
a6038 1
	exit(0);
d6063 1
a6063 1
	exit(0);
d6277 2
d6314 4
a6317 1
        pCommand = ap_pstrcat(p, pCommand, " \"", argv[i], "\"", NULL);
d6327 9
a6335 1
    /* Give the read in of teh pipe (hPipeRead) to the child as stdin. The 
a6761 5

int main(int argc, char *argv[]) 
{
    ExitThread(TSR_THREAD, 0);
}
d6777 4
a6782 1
    int conf_specified = 0;
d6784 15
a6798 1
    char cwd[MAX_STRING_LEN];
d6801 1
a6801 4
    TSD Tsd;

    SetCurrentNameSpace(4);
    SetTargetNameSpace(4);
d6803 1
a6803 11
    memset(&Tsd, 0, sizeof(Tsd));
    SaveThreadDataAreaPtr(&Tsd);
#else
    /* Service application
     * Configuration file in registry at:
     * HKLM\System\CurrentControlSet\Services\[Svc name]\Parameters\ConfPath
     */
    if (isProcessService()) {
        service_main(master_main, argc, argv);
        clean_parent_exit(0);
    }
d6825 1
a6825 1
       ap_log_error(APLOG_MARK,APLOG_WIN32ERROR, NULL,
d6851 2
a6864 5
            if (isValidService(optarg)) {
                ap_registry_get_service_conf(pconf, ap_server_confname, sizeof(ap_server_confname),
                                             optarg);
                conf_specified = 1;
            }
d6876 4
a6879 1
	    signal_to_send = optarg;
d6882 5
d6909 1
d6911 3
d6915 1
a6915 1
	case 'V':
d6918 1
d6920 3
d6926 1
d6928 3
d6934 1
d6936 3
d6961 25
d7022 9
d7035 2
a7036 1
            InstallService(service_name, ap_server_root_relative(pcommands, ap_server_confname));
a7040 5
    
    if (service_name && signal_to_send) {
        send_signal_to_service(service_name, signal_to_send);
        clean_parent_exit(0);
    }
d7044 14
a7057 1
        clean_parent_exit(0);
d7059 2
a7061 2
    server_conf = ap_read_config(pconf, ptrans, ap_server_confname);

d7075 2
a7076 1
    /* Treat -k start confpath as just -f confpath */
d7081 2
a7082 1
    
d7091 1
a7091 1
#ifdef OS2
d7093 1
a7093 2
#endif
#if defined(WIN32) || defined(NETWARE)
d7095 1
a7095 1
	printf("%s running...\n", ap_get_server_version());
d7097 3
d7115 1
a7115 1
#else
d7124 4
d7131 14
d7146 1
d7148 1
d7150 3
a7152 1
#endif
d7275 8
@


1.6
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d1632 1
a1632 1
	    (*(*pocr)->maintenance) (OC_REASON_UNREGISTER, (*pocr)->data, -1);
d1688 1
a1688 1
	(*ocr->maintenance) (OC_REASON_UNWRITABLE, ocr->data, -1);
d2510 1
a2510 1
		(*ocr->maintenance) (OC_REASON_DEATH, ocr->data, status);
d2513 1
a2513 1
		(*ocr->maintenance) (OC_REASON_RESTART, ocr->data, -1);
d2519 1
a2519 1
		(*ocr->maintenance) (OC_REASON_LOST, ocr->data, -1);
d5080 5
@


1.5
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d119 1
a119 1
#elif !defined(BEOS) && !defined(TPF)
a121 1

d230 6
a235 1

d304 1
d306 1
d310 1
d312 1
d330 1
d332 1
d358 1
d360 1
d468 1
d470 1
d1107 4
d1112 1
d1115 28
d1155 2
d1161 3
a1163 1

a1190 1

d1200 3
d1213 1
a1213 1
	      log_req->request_time = time(0);
d1224 1
a1224 1

d1227 1
a1227 2

	ap_longjmp(jmpbuffer, 1);
d1239 1
d1249 3
d1257 3
d1282 1
d1284 1
d1289 1
a1289 1
#ifndef WIN32
d1306 4
a1309 1
#ifdef WIN32
d1311 1
d1349 1
a1349 1
#ifdef WIN32
d1352 3
d1382 3
a1384 1

d1398 3
a1400 1

a1402 1

a1407 1

d1412 3
a1416 1

a1417 1

d1422 3
a1425 1

a1426 1

d1431 3
d1493 3
d1510 3
a1513 1

d1580 4
d2009 1
a2009 1
		    "could not call shmget");
d2241 4
d2267 4
d2428 1
a2428 1
    for (tries = terminate ? 4 : 1; tries <= 9; ++tries) {
d2483 5
d2489 1
a2489 1
	    case 9:     /* 14 sec */
d2595 24
d2788 1
a2788 1
#ifndef WIN32
d2810 3
d2963 1
a2963 1
#ifndef WIN32
d3058 1
a3058 1

d3060 1
d3081 1
a3081 1
#if !defined(WIN32)
d3153 1
a3153 1
#ifndef WIN32
d3213 2
d3218 5
a3222 5
    if ((stat(SUEXEC_BIN, &wrapper)) != 0)
	return (ap_suexec_enabled);

    if ((wrapper.st_mode & S_ISUID) && wrapper.st_uid == 0) {
	ap_suexec_enabled = 1;
d3225 1
a3225 1
    return (ap_suexec_enabled);
d3296 3
a3307 1

d3323 1
a3323 1
	ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
d3325 3
a3327 2
	ap_unblock_alarms();
	exit(1);
a3359 2
#ifndef MPE
/* MPE does not support SO_REUSEADDR and SO_KEEPALIVE */
d3374 1
a3374 1
#ifdef SO_KEEPALIVE
a3387 1
#endif
d3514 9
a3522 4
	if (nr == NULL) {
	    fprintf(stderr, "Ouch!  malloc failed in copy_listeners()\n");
	    exit(1);
	}
d3573 1
a3573 1
	    fd = make_sock(p, &lr->local_addr);
d3617 3
d3630 1
a3630 1
#ifdef WIN32
d3647 1
a3647 1
    iVersionRequested = MAKEWORD(1, 1);
d3650 1
d3654 4
a3657 2
    if (LOBYTE(wsaData.wVersion) != 1 ||
	HIBYTE(wsaData.wVersion) != 1) {
a3661 1

a3663 1

d3687 3
d3709 6
d3827 1
a3827 1
#ifdef WIN32
d4949 1
a4949 1
    APACHE_TPF_INPUT input_parms;
d4951 1
a4951 1
    input_parms = * (APACHE_TPF_INPUT *)(&(ecbptr()->ebw000));
d5006 1
d5017 1
a5017 1
	    os_tpf_child(&input_parms);
d5065 3
d5069 1
d5072 3
d5076 1
d5092 2
a5093 1
            memcpy(tpf_server_name, input_parms.inetd_server.servname, INETD_SERVNAME_LENGTH);
d5102 1
a5102 1
            reset_tpf_listeners(&input_parms);
d5105 1
a5105 1
            scoreboard_fd = input_parms.scoreboard_fd;
d5108 2
a5109 1
            ap_scoreboard_image = (scoreboard *)input_parms.scoreboard_heap;
d5111 1
a5111 1
            child_main(input_parms.slot);
d5158 2
a5159 4
/* TPF only passes the incoming socket number from the internet daemon
   in ebw000 */
    sock_in = * (int*)(&(ecbptr()->ebw000));
    sock_out = * (int*)(&(ecbptr()->ebw000));
d5330 2
a5332 1
    ap_assert(allowed_globals.jobmutex);
d5426 14
d5452 1
a5452 1
#ifdef SIGURG
d5456 4
d5463 4
a5466 1

d5470 1
a5470 1

a5473 1

d5485 1
d5495 1
a5495 1
	clen = sizeof(sa_server);
d5528 1
a5528 1

a5532 1

d5534 4
a5537 1
	    (void) ap_update_child_status(child_num, SERVER_BUSY_WRITE, r);
a5543 1

d5585 4
d5592 3
d5596 1
d5605 7
d5613 1
d5699 1
d5708 4
d5716 30
a5745 44

    /* Setup the listeners */
    listenmaxfd = -1;
    FD_ZERO(&listenfds);
    lr = ap_listeners;

    FD_ZERO(&listenfds);

    for (;;) {
	fd = find_listener(lr);
	if (fd < 0) {
            if (!ReadFile(pipe, 
                          &WSAProtocolInfo, sizeof(WSAPROTOCOL_INFO),
                          &BytesRead,
                          (LPOVERLAPPED) NULL)){
                ap_log_error(APLOG_MARK, APLOG_WIN32ERROR|APLOG_CRIT, server_conf,
                             "setup_inherited_listeners: Unable to read socket data from parent");
                exit(1);
            }
            fd = WSASocket(FROM_PROTOCOL_INFO,
                           FROM_PROTOCOL_INFO,
                           FROM_PROTOCOL_INFO,
                           &WSAProtocolInfo,
                           0,
                           0);
            if (fd == INVALID_SOCKET) {
                ap_log_error(APLOG_MARK, APLOG_WIN32ERROR|APLOG_CRIT, server_conf,
                             "setup_inherited_listeners: WSASocket failed to get inherit the socket.");
                exit(1);
            }
            APD2("setup_inherited_listeners: WSASocket() returned socket %d", fd);
	}
	else {
	    ap_note_cleanups_for_socket(p, fd);
	}
	if (fd >= 0) {
	    FD_SET(fd, &listenfds);
	    if (fd > listenmaxfd)
		listenmaxfd = fd;
	}
	lr->fd = fd;
	if (lr->next == NULL)
	    break;
	lr = lr->next;
a5746 2
    /* turn the list into a ring */
    lr->next = ap_listeners;
d5752 1
d5759 152
d5912 17
d5947 1
d5976 1
a5976 1

d6067 1
a6068 1
	memcpy(&main_fds, &listenfds, sizeof(fd_set));
a6069 7
#ifdef WIN32
	if (srv == SOCKET_ERROR) {
	    /* Map the Win32 error into a standard Unix error condition */
	    errno = WSAGetLastError();
	    srv = -1;
	}
#endif /* WIN32 */
d6071 19
a6089 19
	if (srv < 0) {
	    /* Error occurred - if EINTR, loop around with problem */
	    if (errno != EINTR) {
		/* A "real" error occurred, log it and increment the count of
		 * select errors. This count is used to ensure we don't go into
		 * a busy loop of continuous errors.
		 */
		ap_log_error(APLOG_MARK, APLOG_ERR, server_conf, "select: (listen)");
		count_select_errors++;
		if (count_select_errors > MAX_SELECT_ERRORS) {
		    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, server_conf,
			"Too many errors in select loop. Child process exiting.");
		    break;
		}
	    }
	    continue;
	}
	count_select_errors = 0;    /* reset count of errors */
	if (srv == 0) {
d6091 1
a6091 3
	}

	{
a6101 1
#ifdef WIN32
a6103 1
		errno = WSAGetLastError();
d6105 1
a6105 2
#endif /* WIN32 */
	} while (csd < 0 && errno == EINTR);
d6108 1
a6108 7
#if defined(EPROTO) && defined(ECONNABORTED)
	    if ((errno != EPROTO) && (errno != ECONNABORTED))
#elif defined(EPROTO)
	    if (errno != EPROTO)
#elif defined(ECONNABORTED)
	    if (errno != ECONNABORTED)
#endif
d6110 2
a6111 1
			    "accept: (client socket)");
d6267 1
a6267 1
        pCommand = ap_pstrcat(p, pCommand, " ", argv[i], NULL);
d6366 1
a6366 3
     * We can safely use GetLastError() here without presetting it;
     * {Initialize,Set}SecurityDescriptor() have been verified as clearing it
     * on successful completion.
d6368 1
d6608 1
d6687 29
a6715 3
#ifdef WIN32
__declspec(dllexport)
     int apache_main(int argc, char *argv[])
d6730 9
d6747 1
d6760 7
a6766 1

d6775 1
d6847 2
a6848 1
	    exit(0);
d6852 2
a6853 1
	    exit(0);
d6856 2
a6857 1
	    exit(0);
d6860 2
a6861 1
	    exit(0);
d6878 3
d6890 1
a6890 1

d6894 1
d6896 1
d6959 2
a6960 1

d6964 1
d6971 1
a6971 1
#ifdef WIN32
d6976 2
d6982 9
d7005 1
d7090 8
d7180 1
@


1.4
log
@mod_ssl-2.2.3-1.3.4 (will require libssl-1.1 for https to work, but
mostly harmless otherwise).
@
text
@d183 4
d232 6
a237 4
int ap_standalone;
uid_t ap_user_id;
char *ap_user_name;
gid_t ap_group_id;
d241 5
a245 5
int ap_max_requests_per_child;
int ap_threads_per_child;
int ap_excess_requests_per_child;
char *ap_pid_fname;
char *ap_scoreboard_fname;
d247 1
a247 1
char *ap_server_argv0;
d249 5
a253 5
int ap_daemons_to_start;
int ap_daemons_min_free;
int ap_daemons_max_free;
int ap_daemons_limit;
time_t ap_restart_time;
d289 2
a290 2
API_VAR_EXPORT char ap_server_root[MAX_STRING_LEN];
char ap_server_confname[MAX_STRING_LEN];
d341 1
d343 1
d353 5
d440 14
d775 5
a779 3
    if (semop(sem_id, &op_on, 1) < 0) {
	perror("accept_mutex_on");
	clean_child_exit(APEXIT_CHILDFATAL);
d785 5
a789 3
    if (semop(sem_id, &op_off, 1) < 0) {
	perror("accept_mutex_off");
	clean_child_exit(APEXIT_CHILDFATAL);
d945 2
a946 2
	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
		    "Child cannot open lock semaphore");
d948 2
d962 2
a963 2
	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
		    "Parent cannot create lock semaphore");
d975 1
a975 1
	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
d986 1
a986 1
	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
d992 32
d1059 1
a1059 1
    fprintf(stderr, "Usage: %s [-R directory] [-d directory] [-f file]\n", bin);
d1061 1
a1061 1
    fprintf(stderr, "Usage: %s [-d directory] [-f file]\n", bin);
d1064 4
a1067 1
    fprintf(stderr, "       %s [-v] [-V] [-h] [-l] [-L] [-S] [-t]\n", pad);
d1083 2
a1084 1
    fprintf(stderr, "  -t               : run syntax test for configuration files only\n");
d1086 1
d1089 3
d1110 1
a1110 1
{				/* Also called on SIGPIPE */
a1112 1
    signal(SIGPIPE, SIG_IGN);	/* Block SIGPIPE */
d1130 4
a1133 14
	if (sig == SIGPIPE) {
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO,
			current_conn->server,
			"[client %s] stopped connection before %s completed",
			current_conn->remote_ip,
			timeout_name ? timeout_name : "request");
	}
	else {
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO,
			current_conn->server,
			"[client %s] %s timed out",
			current_conn->remote_ip,
			timeout_name ? timeout_name : "request");
	}
d1157 5
a1161 1
	if (!current_conn->keptalive)
d1163 5
d1178 3
d1273 1
d1359 1
d1458 3
d1465 3
d1646 3
d1996 31
d2075 3
d2158 4
a2161 1
    ap_destroy_pool(pconf);
d2173 2
d2712 1
a2712 1
ap_generation_t volatile ap_my_generation;
d2898 5
d2942 4
d2985 1
a2985 1
    /* OS/2 don't support process group IDs */
d3051 13
a3063 2
#ifndef OS2
	/* OS/2 dosen't support groups. */
d3079 2
a3080 8
#endif
	if (setgid(ap_group_id) == -1) {
	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
			"setgid: unable to set group id to Group %u",
			(unsigned)ap_group_id);
	    clean_child_exit(APEXIT_CHILDFATAL);
	}
#endif
d3121 2
d3153 1
a3153 1
#if defined(TCP_NODELAY) && !defined(MPE)
d3220 1
d3222 1
d3225 3
d3236 3
d3240 1
d3246 1
a3246 2
#ifndef BEOS
/* BeOS does not support SO_KEEPALIVE */
d3250 3
d3254 2
d3301 1
d3309 4
d3314 1
d3326 3
d3330 1
d3342 1
a3342 1
#ifndef WIN32
d3350 3
d3354 1
d3549 3
d3638 1
a3638 1
#ifdef SHARED_CORE_DIR
d3687 3
a3689 1
    pconf = ap_init_alloc();
d3778 1
a3778 1
			"setuid: unable to change uid");
d3791 1
a3791 1
		    "setuid: unable to change uid");
d3804 1
a3804 2
     * Setup the jump buffers so that we can return here after
     * a signal or a timeout (yeah, I know, same thing).
a3811 1
    signal(SIGPIPE, timeout);
d3813 5
d3854 1
a3854 1
	     && ++requests_this_child >= ap_max_requests_per_child)) {
d3907 1
a3907 1
		csd = accept(sd, &sa_client, &clen);
d3971 20
d3992 11
d4007 1
d4028 5
d4041 1
d4049 1
d4089 1
d4098 1
d4136 3
d4167 3
d4180 3
d4190 30
d4231 1
d4233 1
d4245 6
a4250 1
#ifndef _OSD_POSIX
d4252 1
a4252 4
#else /*_OSD_POSIX*/
    /* BS2000 requires a "special" version of fork() before a setuid() call */
    if ((pid = os_fork()) == -1) {
#endif /*_OSD_POSIX*/
d4570 2
a4571 1
	ap_open_logs(server_conf, pconf);
d4687 5
a4784 1
    int configtestonly = 0;
d4803 6
d4813 1
a4813 1
    if ((s = strrchr(argv[0], '/')) != NULL) {
a4824 1
#ifndef TPF
d4826 1
a4826 1
				    "D:C:c:Xd:f:vVlLR:Sth"
d4869 6
d4893 6
a4898 1
	    configtestonly = 1;
d4906 3
a4908 1
#endif /* TPF */
d4913 5
a4917 1
    if (configtestonly) {
d4927 1
d4929 1
a4929 1
	ap_open_logs(server_conf, pconf);
d4935 26
d4972 1
a4972 1
	ap_open_logs(server_conf, pconf);
d4983 1
a4983 1
			    "setuid: unable to change uid");
d4992 2
a4993 1
			"setuid: unable to change uid");
a5001 5
    signal(SIGALRM, alrm_handler);
    ecbptr()->ebrout = PRIMECRAS;
#endif /* TPF */

#ifdef TPF
d5006 2
d5053 4
d5181 3
d5276 1
a5276 2
     * Setup the jump buffers so that we can return here after
     * a signal or a timeout (yeah, I know, same thing).
d5295 2
a5296 2
	ap_set_callback_and_alarm(NULL, 0);	/* Cancel any outstanding alarms. */
	timeout_req = NULL;	/* No request in progress */
a5297 3
#ifdef SIGPIPE
	signal(SIGPIPE, timeout);
#endif
d5301 2
a5302 1
	(void) ap_update_child_status(child_num, SERVER_READY, (request_rec *) NULL);
d5385 3
d5398 3
d5442 1
a5442 1
DWORD wait_for_many_objects(DWORD nCount, CONST HANDLE *lpHandles, 
d5506 65
a5591 2
    int start_exit = 0;
    int start_mutex_released = 0;
d5636 1
a5636 1
	    "Waiting for start_mutex or exit_event -- process will exit");
d5649 6
a5655 1
    setup_listeners(pconf);
d5698 4
a5701 28
#if SEVERELY_VERBOSE
	APD4("child PID %d: thread_main total_jobs=%d start_exit=%d",
		my_pid, total_jobs, start_exit);
#endif
	if ((max_jobs_per_exe && (total_jobs > max_jobs_per_exe) && !start_exit)) {
	    start_exit = 1;
	    wait_time = 1;
	    ap_release_mutex(start_mutex);
	    start_mutex_released = 1;
	    APD2("process PID %d: start mutex released\n", my_pid);
	}
	if (!start_exit) {
	    rv = WaitForSingleObject(exit_event, 0);
	    ap_assert((rv == WAIT_TIMEOUT) || (rv == WAIT_OBJECT_0));
	    if (rv == WAIT_OBJECT_0) {
		APD1("child: exit event signalled, exiting");
		start_exit = 1;
		/* Lets not break yet - we may have threads to clean up */
		/* break;*/
	    }
	    rv = wait_for_many_objects(nthreads, child_handles, 0);
	    ap_assert(rv != WAIT_FAILED);
	    if (rv != WAIT_TIMEOUT) {
		rv = rv - WAIT_OBJECT_0;
		ap_assert((rv >= 0) && (rv < nthreads));
		cleanup_thread(child_handles, &nthreads, rv);
		break;
	    }
d5703 8
a5711 7
#if 0
	/* Um, this made us exit before all the connections in our
	 * listen queue were dealt with. 
	 */
	if (start_exit && max_jobs_after_exit_request && (count_down-- < 0))
	    break;
#endif
d5730 1
a5730 1
		 * a busy loop of continuour errors.
d5744 1
a5744 4
	    if (start_exit)
		break;
	    else
		continue;
d5787 1
a5787 3
    if (!start_mutex_released) {
	ap_release_mutex(start_mutex);
    }
a5848 53
int create_event_and_spawn(int argc, char **argv, event **ev, int *child_num, char *prefix)
{
    char buf[40], mod[200];
    int i, rv;
    char **pass_argv = (char **) alloca(sizeof(char *) * (argc + 3));
    
    /* We need an event to tell the child process to kill itself when
     * the parent is doing a shutdown/restart. This will be named
     * apPID_CN where PID is the parent Apache process PID and 
     * N is a unique child serial number. prefix contains
     * the "apPID" part. The child will get the name of this
     * event as its -Z command line argument.
     */
    ap_snprintf(buf, sizeof(buf), "%s_C%d", prefix, ++(*child_num));
    _flushall();
    *ev = CreateEvent(NULL, TRUE, FALSE, buf);
    if (!*ev) {
	ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_WIN32ERROR, NULL,
	    "could not create event for child process");
	return -1;
    }
    APD2("create_event_and_spawn(): created process kill event %s", buf);

    pass_argv[0] = argv[0];
    pass_argv[1] = "-Z";
    pass_argv[2] = buf;
    for (i = 1; i < argc; i++) {
	pass_argv[i + 2] = argv[i];
    }
    pass_argv[argc + 2] = NULL;

    rv = GetModuleFileName(NULL, mod, sizeof(mod));
    if (rv == sizeof(mod)) {
	/* mod[] was not big enough for our pathname */
	ap_log_error(APLOG_MARK, APLOG_ERR, NULL,
	    "Internal error: path to Apache process too long");
	return -1;
    }
    if (rv == 0) {
	ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_WIN32ERROR, NULL,
	    "GetModuleFileName() for current process");
	return -1;
    }
    rv = spawnv(_P_NOWAIT, mod, pass_argv);
    if (rv == -1) {
	ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_WIN32ERROR, NULL,
	    "spawn of child process %s failed", mod);
	return -1;
    }

    return rv;
}

d5860 1
a5860 1
void cleanup_process(HANDLE *handles, HANDLE *events, int position, int *processes)
d5879 2
a5880 1
int create_process(HANDLE *handles, HANDLE *events, int *processes, int *child_num, char *kill_event_name, int argc, char **argv)
d5882 2
a5883 1
    int i = *processes;
d5885 79
a5963 1
    int child_handle;
d5965 1
a5965 3
    child_handle = create_event_and_spawn(argc, argv, &kill_event, child_num, kill_event_name);
    if (child_handle <= 0) {
	return -1;
d5967 3
a5969 3
    handles[i] = (HANDLE)child_handle;
    events[i] = kill_event;
    (*processes)++;
d5971 39
a6009 2
    APD4("create_processes: created child in slot %d handle %d, max=%d", 
	(*processes)-1, handles[(*processes)-1], *processes);
d6014 46
d6062 2
a6064 2
    event **ev;
    int *child;
d6087 4
a6090 1
    signal_shutdown_event = CreateEvent(NULL, TRUE, FALSE, signal_shutdown_name);
d6093 2
a6094 1
		    "Cannot create shutdown event %s", signal_shutdown_name);
d6097 5
a6101 2
    APD2("master_main: created event %s", signal_shutdown_name);
    signal_restart_event = CreateEvent(NULL, TRUE, FALSE, signal_restart_name);
d6105 2
a6106 1
		    "Cannot create restart event %s", signal_restart_name);
d6109 1
a6109 1
    APD2("master_main: created event %s", signal_restart_name);
d6111 4
a6115 13
    ev = (event **) alloca(sizeof(event *) * nchild);
    child = (int *) alloca(sizeof(int) * (nchild+1));

    while (processes_to_create--) {
	service_set_status(SERVICE_START_PENDING);
	if (create_process(process_handles, process_kill_events, 
	    &current_live_processes, &child_num, signal_prefix_string, argc, argv) < 0) {
	    goto die_now;
	}
    }

    service_set_status(SERVICE_RUNNING);

d6122 1
d6127 3
a6129 1
	ap_open_logs(server_conf, pconf);
d6133 11
a6143 1

d6146 18
a6163 37
	/* Wait for either a child process to die, or for the stop_event
	 * to be signalled by the service manager or rpc server */
	while (1) {
	    /* Next line will block forever until either a child dies, or we
	     * get signalled on the "apache-signal" event (e.g. if the user is
	     * requesting a shutdown/restart)
	     */
	    if (current_live_processes == 0) {
		/* Shouldn't happen, but better safe than sorry */
		ap_log_error(APLOG_MARK,APLOG_ERR|APLOG_NOERRNO, server_conf,
 			"master_main: no child processes alive! creating one");
		if (create_process(process_handles, process_kill_events, 
		    &current_live_processes, &child_num, signal_prefix_string, 
		    argc, argv) < 0) {
		    goto die_now;
		}
		if (processes_to_create) {
		    processes_to_create--;
		}
	    }
	    process_handles[current_live_processes] = signal_shutdown_event;
	    process_handles[current_live_processes+1] = signal_restart_event;
	    rv = WaitForMultipleObjects(current_live_processes+2, (HANDLE *)process_handles, 
			FALSE, INFINITE);
	    if (rv == WAIT_FAILED) {
		/* Something serious is wrong */
		ap_log_error(APLOG_MARK,APLOG_CRIT|APLOG_WIN32ERROR, server_conf,
		    "WaitForMultipeObjects on process handles and apache-signal -- doing shutdown");
		shutdown_pending = 1;
		break;
	    }
	    if (rv == WAIT_TIMEOUT) {
		/* Hey, this cannot happen */
		ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
		    "WaitForMultipeObjects with INFINITE wait exited with WAIT_TIMEOUT");
		shutdown_pending = 1;
	    }
d6165 17
a6181 13
	    cld = rv - WAIT_OBJECT_0;
	    APD4("main process: wait finished, cld=%d handle %d (max=%d)", cld, process_handles[cld], current_live_processes);
	    if (cld == current_live_processes) {
		/* shutdown event signalled, we should exit now */
		if (ResetEvent(signal_shutdown_event) == 0) {
		    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_WIN32ERROR, server_conf,
			"ResetEvent(signal_shutdown_event)");
		    /* Continue -- since we are doing a shutdown anyway */
		}
		shutdown_pending = 1;
		APD3("main process: stop_event signalled: shutdown_pending=%d, restart_pending=%d",
		    shutdown_pending, restart_pending);
		break;
d6183 15
a6197 3
	    if (cld == current_live_processes+1) {
		/* restart event signalled, we should exit now */
		if (ResetEvent(signal_restart_event) == 0) {
d6199 3
a6201 7
			"ResetEvent(signal_restart_event)");
		    /* Continue -- hopefully the restart will fix the problem */
		}
		restart_pending = 1;
		APD3("main process: stop_event signalled: shutdown_pending=%d, restart_pending=%d",
		    shutdown_pending, restart_pending);
		break;
d6203 11
d6217 2
a6218 20
	    if (processes_to_create) {
		create_process(process_handles, process_kill_events, &current_live_processes, 
			&child_num, signal_prefix_string, argc, argv);
		processes_to_create--;
	    }
	}
	if (!shutdown_pending && !restart_pending) {
	    ap_log_error(APLOG_MARK,APLOG_CRIT|APLOG_NOERRNO, server_conf,
		"master_main: no shutdown or restart variables set -- doing shutdown");
	    shutdown_pending = 1;
	}
	if (shutdown_pending) {
	    /* tell all child processes to die */
	    for (i = 0; i < current_live_processes; i++) {
		APD3("main process: signalling child #%d handle %d to die", i, process_handles[i]);
		if (SetEvent(process_kill_events[i]) == 0)
		    ap_log_error(APLOG_MARK,APLOG_WIN32ERROR, server_conf,
			"SetEvent for child process in slot #%d", i);
	    }
	    break;
a6219 2
	if (restart_pending) {
	    int children_to_kill = current_live_processes;
d6221 1
a6221 19
	    APD1("--- Doing graceful restart ---");

	    processes_to_create = nchild;
	    for (i = 0; i < nchild; ++i) {
		if (current_live_processes >= MAX_PROCESSES)
		    break;
		create_process(process_handles, process_kill_events, &current_live_processes, 
		    &child_num, signal_prefix_string, argc, argv);
		processes_to_create--;
	    }
	    for (i = 0; i < children_to_kill; i++) {
		APD3("main process: signalling child #%d handle %d to die", i, process_handles[i]);
		if (SetEvent(process_kill_events[i]) == 0)
		    ap_log_error(APLOG_MARK,APLOG_WIN32ERROR, server_conf,
 			"SetEvent for child process in slot #%d", i);
	    }
	}
	++ap_my_generation;
    } while (restart_pending);
d6279 1
a6279 1
void send_signal(pool *p, char *signal)
d6292 1
a6292 1
	return;
d6301 1
a6301 1
	return;
d6317 1
a6317 1
    else
d6320 4
d6325 24
a6348 1
    return;
d6361 2
a6362 1
    int run_as_service = 1;
d6364 1
a6364 1
    int configtestonly = 0;
d6366 12
a6377 3
    char *s;
    
    common_init();
d6379 2
a6380 2
    if ((s = strrchr(argv[0], '/')) != NULL) {
	ap_server_argv0 = ++s;
d6383 1
a6383 1
	ap_server_argv0 = argv[0];
d6386 2
a6387 11
    /* Get the serverroot from the registry, if it exists. This can be
     * overridden by a command line -d argument.
     */
    if (ap_registry_get_server_root(pconf, ap_server_root, sizeof(ap_server_root)) < 0) {
	/* The error has already been logged. Actually it won't have been,
	 * because we haven't read the config files to find out where our 
	 * error log is. But we can't just ignore the error since we might
	 * end up using totally the wrong server root.
	 */
	exit(1);
    }
d6389 4
a6392 2
    if (!*ap_server_root) {
	ap_cpystrn(ap_server_root, HTTPD_ROOT, sizeof(ap_server_root));
a6393 1
    ap_cpystrn(ap_server_confname, SERVER_CONFIG_FILE, sizeof(ap_server_confname));
d6395 2
a6396 1
    ap_setup_prelinked_modules();
d6398 1
a6398 1
    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVlLZ:iusSthk:")) != -1) {
d6425 8
a6438 3
	case 's':
	    run_as_service = 0;
	    break;
d6447 10
a6456 1
	    ap_cpystrn(ap_server_root, ap_os_canonical_filename(pconf, optarg), sizeof(ap_server_root));
d6459 4
a6462 1
	    ap_cpystrn(ap_server_confname, ap_os_canonical_filename(pconf, optarg), sizeof(ap_server_confname));
d6483 6
a6488 1
	    configtestonly = 1;
d6491 1
a6491 1
	    usage(argv[0]);
d6493 21
a6513 2
	    usage(argv[0]);
	}
d6516 10
a6525 2
    if (!child && run_as_service) {
	service_cd();
d6527 2
d6530 21
d6553 11
a6563 3
    if (configtestonly) {
        fprintf(stderr, "Syntax OK\n");
        exit(0);
d6566 4
a6569 3
    if (signal_to_send) {
	send_signal(pconf, signal_to_send);
	exit(0);
d6572 2
a6573 2
    if (!child && !ap_dump_settings && !install) {
	ap_log_pid(pconf, ap_pid_fname);
d6575 2
a6576 6
    ap_set_version();
    ap_init_modules(pconf, server_conf);
    ap_suexec_enabled = init_suexec();
    version_locked++;
    ap_open_logs(server_conf, pconf);
    set_group_privs();
a6585 1

d6602 2
a6603 4
    else {
	service_main(master_main, argc, argv,
			"Apache", install, run_as_service);
    }
d6632 12
d6693 1
a6693 1
    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVlLR:SZ:th")) != -1) {
d6708 1
d6721 1
a6721 1
    sprintf(prog, "%s/%s", llp_dir, SHARED_CORE_EXECUTABLE_PROGRAM);
d6738 3
d6747 1
a6747 1
	 sprintf(llp_buf, "%s=%s:%s", VARNAME, llp_dir, llp_existing);
d6749 1
a6749 1
	 sprintf(llp_buf, "%s=%s", VARNAME, llp_dir);
d6766 1
d6768 22
@


1.3
log
@Apache 1.3.4 merge
@
text
@d252 3
d419 10
d1163 3
d1167 1
d2991 18
d3379 3
d3527 16
@


1.2
log
@Apache 1.3.3 merge + proxy_segv fix
@
text
@d2 1
a2 1
 * Copyright (c) 1995-1998 The Apache Group.  All rights reserved.
d119 1
a119 1
#elif !defined(BEOS)
d250 1
a250 1
int ap_dump_settings;
d981 1
a981 1
    fprintf(stderr, "Usage: %s [-L directory] [-d directory] [-f file]\n", bin);
d986 1
a986 1
    fprintf(stderr, "       %s [-v] [-V] [-h] [-l] [-S] [-t]\n", pad);
d989 1
a989 1
    fprintf(stderr, "  -L directory     : specify an alternate location for shared object files\n");
d998 1
a998 1
    fprintf(stderr, "  -h               : list available configuration directives\n");
d1000 1
d1048 1
a1048 1
			"(client %s) stopped connection before %s completed",
d1055 1
a1055 1
			"(client %s) %s timed out",
d1100 1
d1134 1
a1134 1

d1616 2
a1617 1
	fprintf(stderr, "httpd: Could not create OS/2 Shared memory pool.\n");
d1623 3
a1625 1
	fprintf(stderr, "httpd: Could not uopen() newly created OS/2 Shared memory pool.\n");
d1628 1
a1628 1
    ap_scoreboard_image->global.exit_generation = 0;
d1638 2
a1639 1
	fprintf(stderr, "httpd: Could not find existing OS/2 Shared memory pool.\n");
d1685 1
d1691 3
a1693 1
	perror("httpd: could not open(create) scoreboard");
d1697 3
a1699 1
	perror("httpd: could not ltrunc scoreboard");
d1706 3
a1708 1
	perror("httpd: cannot mmap scoreboard");
d1715 1
a1715 1
    ap_scoreboard_image->global.exit_generation = 0;
d1753 1
a1753 1
	    fprintf(stderr, "httpd: Could not open %s\n", mfile);
d1760 1
a1760 1
	    fprintf(stderr, "httpd: Could not mmap %s\n", mfile);
d1772 1
a1772 1
	fprintf(stderr, "httpd: Could not mmap memory\n");
d1782 1
a1782 1
	fprintf(stderr, "httpd: Could not open /dev/zero\n");
d1789 1
a1789 1
	fprintf(stderr, "httpd: Could not mmap /dev/zero\n");
d1795 1
a1795 1
    ap_scoreboard_image->global.exit_generation = 0;
d1817 3
a1819 2
		    "httpd: Your kernel was built without CONFIG_SYSVIPC\n"
		    "httpd: please consult the Apache FAQ for details");
d1887 1
a1887 1
    ap_scoreboard_image->global.exit_generation = 0;
d1954 1
a1954 1
    int exit_gen = 0;
d1956 1
a1956 1
	exit_gen = ap_scoreboard_image->global.exit_generation;
d1963 1
a1963 1
    ap_scoreboard_image->global.exit_generation = exit_gen;
d1977 1
a1977 1
    ap_scoreboard_image->global.exit_generation = exit_gen;
d2072 1
a2072 1
	    ap_cpystrn(ss->vhost, r->server->server_hostname, sizeof(ss->vhost));
d2075 12
d2571 1
a2571 1
static int volatile generation;
d2810 1
a2810 1
#if !defined(MPE) && !defined(OS2)
d2817 1
a2817 1
	fprintf(stderr, "httpd: unable to fork new process\n");
d2825 1
a2825 1
	fprintf(stderr, "httpd: setsid failed\n");
d2831 1
a2831 1
	fprintf(stderr, "httpd: setpgrp or getpgrp failed\n");
d2834 1
a2834 1
#elif defined(OS2)
d2843 1
a2843 1
	fprintf(stderr, "httpd: setpgrp failed\n");
d2850 2
a2851 2
	fprintf(stderr, "httpd: unable to replace stdin with /dev/null: %s\n",
		strerror(errno));
d2859 2
a2860 2
	fprintf(stderr, "httpd: unable to replace stdout with /dev/null: %s\n",
		strerror(errno));
d3561 1
a3561 1
	os_init_job_environment(server_conf, ap_user_name) != 0 || 
d3619 1
a3619 1
	if (ap_scoreboard_image->global.exit_generation >= generation) {
d3760 1
a3760 1
	    if (ap_scoreboard_image->global.exit_generation >= generation) {
d3865 1
a3865 1
	    if (ap_scoreboard_image->global.exit_generation >= generation) {
d3933 2
d3936 4
d4132 9
d4142 1
d4186 6
a4191 6
		    server_conf,
		    "httpd: child pid %d exit signal %s (%d), "
		    "possible coredump in %s",
		    pid, (WTERMSIG(status) >= NumSIG) ? "" : 
		    SYS_SIGLIST[WTERMSIG(status)], WTERMSIG(status),
		    ap_coredump_dir);
d4196 3
a4198 3
		    server_conf,
		    "httpd: child pid %d exit signal %s (%d)",
		    pid, SYS_SIGLIST[WTERMSIG(status)], WTERMSIG(status));
d4204 3
a4206 3
		server_conf,
		"httpd: child pid %d exit signal %d",
		pid, WTERMSIG(status));
a4230 1
    ++generation;
d4391 1
a4391 1
				 "httpd: removed PID file %s (pid=%ld)",
d4396 1
a4396 1
			"httpd: caught SIGTERM, shutting down");
d4409 8
a4420 6

	    /* USE WITH CAUTION:  Graceful restarts are not known to work
	     * in various configurations on the architectures we support. */
	    ap_scoreboard_image->global.exit_generation = generation;
	    update_scoreboard_global();

a4450 1
	++generation;
d4467 4
a4470 1

d4489 7
a4495 1
    ap_server_argv0 = argv[0];
d4501 1
d4503 1
a4503 1
				    "D:C:c:Xd:f:vVhlL:St"
a4536 3
	case 'h':
	    ap_show_directives();
	    exit(0);
d4540 3
d4552 1
a4552 1
	case 'L':
d4566 2
d4572 1
d4581 3
d4601 1
d4604 1
d4633 23
d4657 1
a4657 1
	if ((getpeername(fileno(stdin), &sa_client, &l)) < 0) {
d4664 1
a4664 1
	if (getsockname(fileno(stdin), &sa_server, &l) < 0) {
d4671 2
a4672 12
#ifdef MPE
/* HP MPE 5.5 inetd only passes the incoming socket as stdin (fd 0), whereas
   HPUX inetd passes the incoming socket as stdin (fd 0) and stdout (fd 1).
   Go figure.  SR 5003355016 has been submitted to request that the existing
   functionality be documented, and then to enhance the functionality to be
   like HPUX. */

	cio->fd = fileno(stdin);
#else
	cio->fd = fileno(stdout);
#endif
	cio->fd_in = fileno(stdin);
d5179 1
a5179 1
    ++generation;
a5558 1
    ++generation;
d5719 1
a5719 1
	++generation;
a5728 2
    CloseHandle(signal_restart_event);
    CloseHandle(signal_shutdown_event);
d5749 3
d5759 1
a5759 1
			 "httpd: removed PID file %s (pid=%ld)",
d5837 1
d5841 6
a5846 1
    ap_server_argv0 = argv[0];
d5867 1
a5867 1
    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVhlZ:iusStk:")) != -1) {
a5924 3
	case 'h':
	    ap_show_directives();
	    exit(0);
d5928 3
d5937 2
d5971 1
a5971 1
    printf("%s \n", ap_get_server_version());
d5975 1
a5975 1
	printf("%s \n", ap_get_server_version());
d6055 1
a6055 1
#define SHARED_CORE_EXECUTABLE_PROGRAM "libhttpd.ep"
d6076 1
a6076 1
    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVhlL:SZ:t")) != -1) {
a6085 1
	case 'h':
d6087 1
d6091 1
d6094 1
a6094 1
	case 'L':
d6137 2
a6138 2
		"httpd: Unable to exec Shared Core Executable Program `%s'\n",
		prog);
@


1.1
log
@Initial revision
@
text
@d1002 4
d2549 26
a2574 6
 * signal_parent() tells the parent process to wake up and do something.
 * Once woken it will look at shutdown_pending and restart_pending to decide
 * what to do. If neither variable is set, it will do a shutdown. This function
 * if called by start_shutdown() or start_restart() in the parent's process
 * space, so that the variables get set. However it can also be called 
 * by child processes to force the parent to exit in an emergency.
d2577 1
a2577 1
static void signal_parent(void)
d2580 4
d2595 5
a2599 1
    APD1("*** SIGNAL_PARENT SET ***");
d2601 3
a2603 1
    e = OpenEvent(EVENT_ALL_ACCESS, FALSE, "apache-signal");
d2605 1
a2605 1
	/* Um, problem, can't signal the main loop, which means we can't
d2609 1
a2609 1
	    "OpenEvent on apache-signal event");
d2615 2
a2616 1
	    "SetEvent on apache-signal event");
d2624 1
a2624 1
 * start_shutdown() and start_restart(), below, are a first stab at
d2629 3
a2631 9
 * call start_shutdown() or start_restart() as appropiate. 
 *
 * These should only be called from the parent process itself, since the
 * parent process will use the shutdown_pending and restart_pending variables
 * to determine whether to shutdown or restart. The child process should
 * call signal_parent() directly to tell the parent to die -- this will
 * cause neither of those variable to be set, which the parent will
 * assume means something serious is wrong (which it will be, for the
 * child to force an exit) and so do an exit anyway.
d2636 1
d2645 2
a2646 3

#ifdef WIN32
    signal_parent();	    /* get the parent process to wake up */
d2653 1
d2660 2
a2661 3

#ifdef WIN32
    signal_parent();	    /* get the parent process to wake up */
d4665 1
a4665 1
 * passed to it with the -c argument when the child is spawned. The
d4669 3
a4671 1
 * A non-graceful die would need a second event.
d5035 5
d5042 22
a5065 7
    /*
     * I am writing this stuff specifically for NT.
     * have pulled out a lot of the restart and
     * graceful restart stuff, because that is only
     * useful on Unix (not sure it even makes sense
     * in a multi-threaded env.
     */
d5113 7
a5119 1
    //ap_acquire_mutex(start_mutex);
d5145 1
a5145 1
	signal_parent();	/* tell parent to die */
d5174 5
a5178 9
    {
	int i;

	for (i = 0; i < nthreads; i++) {
	    child_handles[i] = create_thread((void (*)(void *)) child_main, (void *) i);
	}
	if (nthreads > max_daemons_limit) {
	    max_daemons_limit = nthreads;
	}
d5344 5
a5348 5
/* Spawn a child Apache process. The child process has the command
 * line arguments from argc and argv[], plus a -Z argument giving the
 * name of an event. The child should open and poll or wait on this
 * event. When it is signalled, the child should die.  prefix is a
 * prefix string for the event name.
d5350 3
a5352 3
 * The child_num argument on entry contains a serial number for this
 * child (used to create a unique event name). On exit, this number
 * will have been incremented by one, ready for the next call.
d5357 2
a5358 3
 * The return value is the handle to the child process if successful,
 * else -1. If -1 is returned the error will already have been logged
 * by ap_log_error(). 
d5366 9
a5374 2

    ap_snprintf(buf, sizeof(buf), "%s_%d", prefix, ++(*child_num));
d5471 1
a5471 1
    char buf[100];
d5474 2
a5475 1
    HANDLE signal_event;	/* used to signal shutdown/restart to parent */
d5488 14
a5501 2
    signal_event = OpenEvent(EVENT_ALL_ACCESS, FALSE, "apache-signal");
    if (!signal_event) {
d5503 1
a5503 1
		    "Cannot open apache-signal event");
d5506 1
d5508 1
a5508 2
    sprintf(buf, "Apache%d", getpid());
    start_mutex = ap_create_mutex(buf);
d5515 1
a5515 1
	    &current_live_processes, &child_num, buf, argc, argv) < 0) {
a5535 2
	if (!is_graceful)
	    reinit_scoreboard(pconf);
d5551 2
a5552 1
		    &current_live_processes, &child_num, buf, argc, argv) < 0) {
d5559 3
a5561 2
	    process_handles[current_live_processes] = signal_event;
	    rv = WaitForMultipleObjects(current_live_processes+1, (HANDLE *)process_handles, 
d5570 7
a5576 1
	    ap_assert(rv != WAIT_TIMEOUT);
d5580 19
a5598 3
		/* stop_event is signalled, we should exit now */
		if (ResetEvent(signal_event) == 0)
		    APD1("main process: *** ERROR: ResetEvent(stop_event) failed ***");
d5607 2
a5608 1
		create_process(process_handles, process_kill_events, &current_live_processes, &child_num, buf, argc, argv);
a5624 1

d5636 2
a5637 1
		create_process(process_handles, process_kill_events, &current_live_processes, &child_num, buf, argc, argv);
d5657 2
a5658 1
    CloseHandle(signal_event);
a5677 1
    service_set_status(SERVICE_STOPPED);
d5695 2
d5700 50
d5763 1
d5788 1
a5788 1
    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVhlZ:iusSt")) != -1) {
d5810 3
a5812 1
	    start_mutex = ap_open_mutex(optarg);
d5827 3
d5874 6
a5879 1
    if (!child) {
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 23
a38 20
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 6
a55 7
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
d119 1
a119 1
#elif !defined(BEOS) && !defined(TPF) && !defined(NETWARE) && !defined(OS390) && !defined(CYGWIN)
d122 1
d169 2
a170 2
API_EXPORT(void) ap_force_library_loading(void);
API_EXPORT(void) ap_force_library_loading(void) {
a182 4
#define DEFAULTSERVICENAME "Apache"
#define PATHSEPARATOR '\\'
#else
#define PATHSEPARATOR '/'
d227 5
a231 11
#ifdef NETWARE
BOOL ap_main_finished = FALSE;
unsigned int ap_thread_stack_size = 65536;
#endif
int ap_thread_count = 0;
API_VAR_EXPORT int ap_standalone=0;
API_VAR_EXPORT int ap_configtestonly=0;
int ap_docrootcheck=1;
API_VAR_EXPORT uid_t ap_user_id=0;
API_VAR_EXPORT char *ap_user_name=NULL;
API_VAR_EXPORT gid_t ap_group_id=0;
d235 16
a250 36
API_VAR_EXPORT int ap_max_requests_per_child=0;
API_VAR_EXPORT int ap_threads_per_child=0;
API_VAR_EXPORT int ap_excess_requests_per_child=0;
API_VAR_EXPORT char *ap_pid_fname=NULL;
API_VAR_EXPORT char *ap_scoreboard_fname=NULL;
API_VAR_EXPORT char *ap_lock_fname=NULL;
API_VAR_EXPORT char *ap_server_argv0=NULL;
API_VAR_EXPORT struct in_addr ap_bind_address={0};
API_VAR_EXPORT int ap_daemons_to_start=0;
API_VAR_EXPORT int ap_daemons_min_free=0;
API_VAR_EXPORT int ap_daemons_max_free=0;
API_VAR_EXPORT int ap_daemons_limit=0;
API_VAR_EXPORT time_t ap_restart_time=0;
API_VAR_EXPORT int ap_suexec_enabled = 0;
API_VAR_EXPORT int ap_listenbacklog=0;

struct accept_mutex_methods_s {
    void (*child_init)(pool *p);
    void (*init)(pool *p);
    void (*on)(void);
    void (*off)(void);
    char *name;
};
typedef struct accept_mutex_methods_s accept_mutex_methods_s;
accept_mutex_methods_s *amutex;

#ifdef SO_ACCEPTFILTER
int ap_acceptfilter =
#ifdef AP_ACCEPTFILTER_OFF
	0;
#else
	1;
#endif
#endif

int ap_dump_settings = 0;
d277 1
a277 1
listen_rec *ap_listeners=NULL;
d280 7
a286 7
API_VAR_EXPORT char ap_server_root[MAX_STRING_LEN]="";
API_VAR_EXPORT char ap_server_confname[MAX_STRING_LEN]="";
API_VAR_EXPORT char ap_coredump_dir[MAX_STRING_LEN]="";

API_VAR_EXPORT array_header *ap_server_pre_read_config=NULL;
API_VAR_EXPORT array_header *ap_server_post_read_config=NULL;
API_VAR_EXPORT array_header *ap_server_config_defines=NULL;
a290 1
#ifndef NETWARE
a291 1
#endif
a294 1
#ifndef NETWARE
a295 1
#endif
a309 2
static int do_detach = 1;

a312 1
#ifndef NETWARE
a313 1
#endif
a331 1
static pool *pglobal;		/* Global pool */
a332 1
static pool *plog;		/* Pool for error-logging files */
a336 1
#ifndef NETWARE
a337 1
#endif
a341 5
#ifdef TPF
int tpf_child = 0;
char tpf_server_name[INETD_SERVNAME_LENGTH+1];
#endif /* TPF */

d401 1
a401 4
    if (ap_server_tokens == SrvTk_PRODUCT_ONLY) {
	ap_add_version_component(SERVER_PRODUCT);
    }
    else if (ap_server_tokens == SrvTk_MIN) {
a415 1
#ifndef NETWARE
a416 1
#endif
d466 1
a466 14
/*
 * Start of accept() mutex fluff:
 *  Concept: Each method has it's own distinct set of mutex functions,
 *   which it shoves in a nice struct for us. We then pick
 *   which struct to use. We tell Apache which methods we
 *   support via HAVE_FOO_SERIALIZED_ACCEPT. We can
 *   specify the default via USE_FOO_SERIALIZED_ACCEPT
 *   (this pre-1.3.21 builds which use that at the command-
 *   line during builds work as expected). Without a set
 *   method, we pick the 1st from the following order:
 *   uslock, pthread, sysvsem, fcntl, flock, os2sem, tpfcore and none.
 */

#if defined(HAVE_FCNTL_SERIALIZED_ACCEPT) || defined(HAVE_FLOCK_SERIALIZED_ACCEPT)
d475 2
a476 1
#if defined (HAVE_USLOCK_SERIALIZED_ACCEPT)
d478 1
d481 1
a481 1
#define accept_mutex_child_init_uslock(x)
d483 1
a483 1
static void accept_mutex_init_uslock(pool *p)
d514 1
a514 1
static void accept_mutex_on_uslock(void)
d529 1
a529 1
static void accept_mutex_off_uslock(void)
d537 1
a537 10
accept_mutex_methods_s accept_mutex_uslock_s = {
    NULL,
    accept_mutex_init_uslock,
    accept_mutex_on_uslock,
    accept_mutex_off_uslock,
    "uslock"
};
#endif

#if defined (HAVE_PTHREAD_SERIALIZED_ACCEPT)
d552 1
a552 1
static void accept_mutex_child_cleanup_pthread(void *foo)
d560 1
a560 1
static void accept_mutex_child_init_pthread(pool *p)
d562 1
a562 1
    ap_register_cleanup(p, NULL, accept_mutex_child_cleanup_pthread, ap_null_cleanup);
d565 1
a565 1
static void accept_mutex_cleanup_pthread(void *foo)
d574 1
a574 1
static void accept_mutex_init_pthread(pool *p)
d587 1
a587 1
	perror("mmap /dev/zero");
a594 4
#if !defined(CYGWIN)
    /* Cygwin has problems with this pthread call claiming that these 
     * are "Invalid arguements", Stipe Tolj <tolj@@wapme-systems.de>
     */
a599 1
#endif
d608 1
a608 1
    ap_register_cleanup(p, NULL, accept_mutex_cleanup_pthread, ap_null_cleanup);
d611 1
a611 1
static void accept_mutex_on_pthread(void)
a618 5
    /* We need to block alarms here, since if we get killed *right* after 
     * locking the mutex, have_accept_mutex will not be set, and our
     * child cleanup will not work.
     */
    ap_block_alarms();
a624 1
    ap_unblock_alarms();
d627 1
a627 1
static void accept_mutex_off_pthread(void)
a630 5
    /* Have to block alarms here, or else we might have a double-unlock, which
     * is possible with pthread mutexes, since they are designed to be fast,
     * and hence not necessarily make checks for ownership or multiple unlocks.
     */
    ap_block_alarms(); 
d636 13
a649 1
    ap_unblock_alarms();
d656 1
a656 10
accept_mutex_methods_s accept_mutex_pthread_s = {
    accept_mutex_child_init_pthread,
    accept_mutex_init_pthread,
    accept_mutex_on_pthread,
    accept_mutex_off_pthread,
    "pthread"
};
#endif

#if defined (HAVE_SYSVSEM_SERIALIZED_ACCEPT)
d680 1
a680 1
static void accept_mutex_cleanup_sysvsem(void *foo)
d691 1
a691 1
#define accept_mutex_child_init_sysvsem(x)
d693 1
a693 1
static void accept_mutex_init_sysvsem(pool *p)
d722 1
a722 1
    ap_register_cleanup(p, NULL, accept_mutex_cleanup_sysvsem, ap_null_cleanup);
d733 1
a733 1
static void accept_mutex_on_sysvsem(void)
d735 3
a737 5
    while (semop(sem_id, &op_on, 1) < 0) {
	if (errno != EINTR) {
	    perror("accept_mutex_on");
	    clean_child_exit(APEXIT_CHILDFATAL);
	}
d741 1
a741 1
static void accept_mutex_off_sysvsem(void)
d743 3
a745 5
    while (semop(sem_id, &op_off, 1) < 0) {
	if (errno != EINTR) {
	    perror("accept_mutex_off");
	    clean_child_exit(APEXIT_CHILDFATAL);
	}
d749 1
a749 10
accept_mutex_methods_s accept_mutex_sysvsem_s = {
    NULL,
    accept_mutex_init_sysvsem,
    accept_mutex_on_sysvsem,
    accept_mutex_off_sysvsem,
    "sysvsem"
};
#endif

#if defined(HAVE_FCNTL_SERIALIZED_ACCEPT)
d755 1
a755 1
#define accept_mutex_child_init_fcntl(x)
d761 1
a761 1
static void accept_mutex_init_fcntl(pool *p)
d785 1
a785 1
static void accept_mutex_on_fcntl(void)
d802 1
a802 1
static void accept_mutex_off_fcntl(void)
d818 1
a818 8
accept_mutex_methods_s accept_mutex_fcntl_s = {
    NULL,
    accept_mutex_init_fcntl,
    accept_mutex_on_fcntl,
    accept_mutex_off_fcntl,
    "fcntl"
};
#endif
d820 1
a820 1
#if defined(HAVE_FLOCK_SERIALIZED_ACCEPT)
d822 1
a822 3
static int flock_fd = -1;

static void accept_mutex_cleanup_flock(void *foo)
d831 1
a831 1
static void accept_mutex_child_init_flock(pool *p)
d834 2
a835 2
    flock_fd = ap_popenf(p, ap_lock_fname, O_WRONLY, 0600);
    if (flock_fd == -1) {
d846 1
a846 1
static void accept_mutex_init_flock(pool *p)
d850 2
a851 2
    flock_fd = ap_popenf(p, ap_lock_fname, O_CREAT | O_WRONLY | O_EXCL, 0600);
    if (flock_fd == -1) {
d856 1
a856 1
    ap_register_cleanup(p, NULL, accept_mutex_cleanup_flock, ap_null_cleanup);
d859 1
a859 1
static void accept_mutex_on_flock(void)
d863 1
a863 1
    while ((ret = flock(flock_fd, LOCK_EX)) < 0 && errno == EINTR)
d873 1
a873 1
static void accept_mutex_off_flock(void)
d875 1
a875 1
    if (flock(flock_fd, LOCK_UN) < 0) {
d882 1
a882 10
accept_mutex_methods_s accept_mutex_flock_s = {
    accept_mutex_child_init_flock,
    accept_mutex_init_flock,
    accept_mutex_on_flock,
    accept_mutex_off_flock,
    "flock"
};
#endif

#if defined(HAVE_OS2SEM_SERIALIZED_ACCEPT)
d886 1
a886 1
static void accept_mutex_cleanup_os2sem(void *foo)
d896 1
a896 1
static void accept_mutex_child_init_os2sem(pool *p)
d901 2
a902 2
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
		    "Child cannot open lock semaphore, rc=%d", rc);
a903 2
    } else {
        ap_register_cleanup(p, NULL, accept_mutex_cleanup_os2sem, ap_null_cleanup);
d911 1
a911 1
static void accept_mutex_init_os2sem(pool *p)
d916 2
a917 2
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
		    "Parent cannot create lock semaphore, rc=%d", rc);
d921 1
a921 1
    ap_register_cleanup(p, NULL, accept_mutex_cleanup_os2sem, ap_null_cleanup);
d924 1
a924 1
static void accept_mutex_on_os2sem(void)
d929 1
a929 1
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
d935 1
a935 1
static void accept_mutex_off_os2sem(void)
d940 1
a940 1
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
d946 4
a949 112
accept_mutex_methods_s accept_mutex_os2sem_s = {
    accept_mutex_child_init_os2sem,
    accept_mutex_init_os2sem,
    accept_mutex_on_os2sem,
    accept_mutex_off_os2sem,
    "os2sem"
};
#endif

#if defined(HAVE_TPF_CORE_SERIALIZED_ACCEPT)

static int tpf_core_held;

static void accept_mutex_cleanup_tpfcore(void *foo)
{
    if(tpf_core_held)
        coruc(RESOURCE_KEY);
}

#define accept_mutex_init_tpfcore(x)

static void accept_mutex_child_init_tpfcore(pool *p)
{
    ap_register_cleanup(p, NULL, accept_mutex_cleanup_tpfcore, ap_null_cleanup);
    tpf_core_held = 0;
}

static void accept_mutex_on_tpfcore(void)
{
    corhc(RESOURCE_KEY);
    tpf_core_held = 1;
    ap_check_signals();
}

static void accept_mutex_off_tpfcore(void)
{
    coruc(RESOURCE_KEY);
    tpf_core_held = 0;
    ap_check_signals();
}

accept_mutex_methods_s accept_mutex_tpfcore_s = {
    accept_mutex_child_init_tpfcore,
    NULL,
    accept_mutex_on_tpfcore,
    accept_mutex_off_tpfcore,
    "tpfcore"
};
#endif

#ifdef HAVE_BEOS_SERIALIZED_ACCEPT
static sem_id _sem = -1;
static int  locked = 0;

static void accept_mutex_child_cleanup_beos(void *foo)
{
    if (_sem > 0 && locked)
        release_sem(_sem);
}

static void accept_mutex_child_init_beos(pool *p)
{
    ap_register_cleanup(p, NULL, accept_mutex_child_cleanup_beos, ap_null_cleanup);
    locked = 0;
}

static void accept_mutex_cleanup_beos(void *foo)
{
    if (_sem > 0)
        delete_sem(_sem);
}

static void accept_mutex_init_beos(pool *p)
{
    _sem = create_sem(1, "httpd_accept");
    if (_sem < 0) {
        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
                    "Parent cannot create lock semaphore, sem=%ld", _sem);
        exit(APEXIT_INIT);
    }

    ap_register_cleanup(p, NULL, accept_mutex_cleanup_beos, ap_null_cleanup);
}                                                                                                        
void accept_mutex_on_beos(void)
{
    if (locked == 0) {
        if (acquire_sem(_sem) == B_OK)
            locked = 1;
    }
}

static void accept_mutex_off_beos(void)
{
    if (locked == 1) {
        if (release_sem(_sem) == B_OK)
            locked = 0; 
    }
}

accept_mutex_methods_s accept_mutex_beos_s = {
    accept_mutex_child_init_beos,
    accept_mutex_init_beos,
    accept_mutex_on_beos,
    accept_mutex_off_beos,
    "beos_sem"
};
#endif /* HAVE_BEOS_SERIALIZED_ACCEPT */


/* Generally, HAVE_NONE_SERIALIZED_ACCEPT simply won't work but
 * for testing purposes, here it is... */
#if defined HAVE_NONE_SERIALIZED_ACCEPT
d954 4
a957 135
#endif 

accept_mutex_methods_s accept_mutex_none_s = {
    NULL,
    NULL,
    NULL,
    NULL,
    "none"
};
#endif

#define AP_FPTR1(x,y)	{ if (x) ((* x)(y)); }
#define AP_FPTR0(x)	{ if (x) ((* x)()); }

#define accept_mutex_child_init(x) 	AP_FPTR1(amutex->child_init,x)
#define accept_mutex_init(x) 		AP_FPTR1(amutex->init,x)
#define accept_mutex_off() 		AP_FPTR0(amutex->off)
#define accept_mutex_on() 		AP_FPTR0(amutex->on)

char *ap_default_mutex_method(void)
{
    char *t;
#if defined USE_USLOCK_SERIALIZED_ACCEPT
    t = "uslock";
#elif defined USE_PTHREAD_SERIALIZED_ACCEPT
    t = "pthread";
#elif defined USE_SYSVSEM_SERIALIZED_ACCEPT
    t = "sysvsem";
#elif defined USE_FCNTL_SERIALIZED_ACCEPT
    t = "fcntl";
#elif defined USE_FLOCK_SERIALIZED_ACCEPT
    t = "flock";
#elif defined USE_OS2SEM_SERIALIZED_ACCEPT
    t = "os2sem";
#elif defined USE_TPF_CORE_SERIALIZED_ACCEPT
    t = "tpfcore";
#elif defined USE_BEOS_SERIALIZED_ACCEPT
    t = "beos_sem";
#elif defined USE_NONE_SERIALIZED_ACCEPT
    t = "none";
#else
    t = "default";
#endif
#if defined HAVE_USLOCK_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"uslock"))))
    	return "uslock";
#endif
#if defined HAVE_PTHREAD_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"pthread"))))
    	return "pthread";
#endif
#if defined HAVE_SYSVSEM_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"sysvsem"))))
    	return "sysvsem";
#endif
#if defined HAVE_FCNTL_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"fcntl"))))
    	return "fcntl";
#endif
#if defined HAVE_FLOCK_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"flock"))))
    	return "flock";
#endif
#if defined HAVE_OS2SEM_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"os2sem"))))
    	return "os2sem";
#endif
#if defined HAVE_TPF_CORE_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"tpfcore"))))
    	return "tpfcore";
#endif
#if defined HAVE_BEOS_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"beos_sem"))))
        return "beos_sem";
#endif
#if defined HAVE_NONE_SERIALIZED_ACCEPT
    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"none"))))
    	return "none";
#endif

    fprintf(stderr, "No default accept serialization known!!\n");
    exit(APEXIT_INIT);
    /*NOTREACHED */
    return "unknown";
}

char *ap_init_mutex_method(char *t)
{
    if (!(strcasecmp(t,"default")))
	t = ap_default_mutex_method();

#if defined HAVE_USLOCK_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"uslock"))) {
    	amutex = &accept_mutex_uslock_s;
    } else 
#endif
#if defined HAVE_PTHREAD_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"pthread"))) {
    	amutex = &accept_mutex_pthread_s;
    } else 
#endif
#if defined HAVE_SYSVSEM_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"sysvsem"))) {
    	amutex = &accept_mutex_sysvsem_s;
    } else 
#endif
#if defined HAVE_FCNTL_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"fcntl"))) {
    	amutex = &accept_mutex_fcntl_s;
    } else
#endif
#if defined HAVE_FLOCK_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"flock"))) {
    	amutex = &accept_mutex_flock_s;
    } else 
#endif
#if defined HAVE_OS2SEM_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"os2sem"))) {
    	amutex = &accept_mutex_os2sem_s;
    } else 
#endif
#if defined HAVE_TPF_CORE_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"tpfcore"))) {
    	amutex = &accept_mutex_tpfcore_s;
    } else 
#endif
#if defined HAVE_BEOS_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"beos_sem"))) {
        amutex = &accept_mutex_beos_s;
    } else
#endif
#if defined HAVE_NONE_SERIALIZED_ACCEPT
    if (!(strcasecmp(t,"none"))) {
    	amutex = &accept_mutex_none_s;
    } else
a958 11
    {
/* Ignore this directive on Windows */
#ifndef WIN32
    if (server_conf) {
        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
                    "Requested serialization method '%s' not available",t);
        exit(APEXIT_INIT);
    } else {
        fprintf(stderr, "Requested serialization method '%s' not available\n", t);
        exit(APEXIT_INIT);
    }
a959 3
    }
    return NULL;
}
a979 5
#ifdef WIN32
    fprintf(stderr, "Usage: %s [-D name] [-d directory] [-f file] [-n service]\n", bin);
    fprintf(stderr, "       %s [-C \"directive\"] [-c \"directive\"] [-k signal]\n", pad);
    fprintf(stderr, "       %s [-v] [-V] [-h] [-l] [-L] [-S] [-t] [-T]\n", pad);
#else /* !WIN32 */
d981 1
a981 1
    fprintf(stderr, "Usage: %s [-R directory] [-D name] [-d directory] [-f file]\n", bin);
d983 1
a983 1
    fprintf(stderr, "Usage: %s [-D name] [-d directory] [-f file]\n", bin);
d986 1
a986 1
    fprintf(stderr, "       %s [-v] [-V] [-h] [-l] [-L] [-S] [-t] [-T] [-F]\n", pad);
d989 1
a989 1
    fprintf(stderr, "  -R directory     : specify an alternate location for shared object files\n");
a990 1
#endif /* !WIN32 */
d998 1
a998 1
    fprintf(stderr, "  -h               : list available command line options (this page)\n");
a999 1
    fprintf(stderr, "  -L               : list available configuration directives\n");
d1001 1
a1001 24
#ifdef NETWARE
    fprintf(stderr, "  -e               : force the display of configuration file errors to the logger screen\n");
    fprintf(stderr, "  -s               : load Apache without a screen\n");
#endif
    fprintf(stderr, "  -t               : run syntax check for config files (with docroot check)\n");
    fprintf(stderr, "  -T               : run syntax check for config files (without docroot check)\n");
#ifndef WIN32
    fprintf(stderr, "  -F               : run main process in foreground, for process supervisors\n");
#endif
#ifdef WIN32
    fprintf(stderr, "  -n name          : name the Apache service for -k options below;\n");
    fprintf(stderr, "  -k stop|shutdown : tell running Apache to shutdown\n");
    fprintf(stderr, "  -k restart       : tell running Apache to do a graceful restart\n");
    fprintf(stderr, "  -k start         : tell Apache to start\n");
    fprintf(stderr, "  -k install   | -i: install an Apache service\n");
    fprintf(stderr, "  -k config        : reconfigure an installed Apache service\n");
    fprintf(stderr, "  -k uninstall | -u: uninstall an Apache service\n");
    fprintf(stderr, "  -W service       : after -k config|install; Apache starts after 'service'\n");
    fprintf(stderr, "  -w               : holds the window open for 30 seconds for fatal errors.\n");
#endif

#if defined(NETWARE)
    clean_parent_exit(0);
#else
a1002 1
#endif
a1004 39


#ifdef NETWARE
/* Thread Storage Data */
typedef struct _TSD {
    conn_rec*		current_conn;
    int 			alarms_blocked;
    int				alarm_pending;
    request_rec*	timeout_req;
    char*			timeout_name;
    JMP_BUF			jmpbuffer;
    int				exit_after_unblock;
    void 			(*alarm_fn) (int);
    unsigned int 	alarm_expiry_time;
} TSD;

static TSD Tsd;

void init_tsd()
{    
    int *thread_ptr;

    memset(&Tsd, 0, sizeof(TSD));
    thread_ptr = __get_thread_data_area_ptr();
    *thread_ptr = (int) &Tsd;
}

#define get_tsd            TSD* tsd = (TSD*) Thread_Data_Area;
#define current_conn       tsd->current_conn
#define alarms_blocked     tsd->alarms_blocked
#define alarm_pending      tsd->alarm_pending
#define timeout_req        tsd->timeout_req
#define timeout_name       tsd->timeout_name
#define jmpbuffer          tsd->jmpbuffer
#define exit_after_unblock tsd->exit_after_unblock
#define alarm_fn           tsd->alarm_fn
#define alarm_expiry_time  tsd->alarm_expiry_time

#else
a1016 2
#endif

d1019 1
a1019 1
{
d1021 2
a1022 3
#ifdef NETWARE
    get_tsd
#endif    
d1040 14
a1053 4
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO,
		     current_conn->server, "[client %s] %s timed out",
		     current_conn->remote_ip,
		     timeout_name ? timeout_name : "request");
d1060 1
a1069 3
#ifdef NETWARE
            ThreadSwitch();
#endif
d1077 1
a1077 5
	if (!current_conn->keptalive) {
	    /* in some cases we come here before setting the time */
	    if (log_req->request_time == 0) {
                log_req->request_time = time(NULL);
	    }
a1078 1
	}
d1082 1
a1082 1
	
d1085 2
a1086 1
        ap_longjmp(jmpbuffer, 1);
a1094 2

#ifndef TPF
a1102 3
#ifdef NETWARE
    get_tsd
#endif
a1107 3
#ifdef NETWARE
    get_tsd
#endif
a1127 1
#endif /* TPF */
d1129 1
a1129 1
#ifndef NETWARE
d1131 1
a1131 2
#endif
#if defined(WIN32) || defined(CYGWIN_WINSOCK) 
d1135 1
a1135 1
#if !defined(WIN32)  && !defined(NETWARE)
d1144 1
a1144 1
API_EXPORT(unsigned int) ap_set_callback_and_alarm(void (*fn) (int), int x)
d1148 1
a1148 5
#if defined(WIN32) || defined(NETWARE)
    time_t now = time(NULL);
#ifdef NETWARE
    get_tsd
#endif
a1149 1

d1151 1
a1151 1
	old -= now;
d1158 1
a1158 1
	alarm_expiry_time = now + x;
a1175 1
	ap_check_signals();
d1186 1
a1186 1
#if defined(WIN32) || defined(NETWARE) || defined(CYGWIN_WINSOCK) 
a1188 3
#ifdef NETWARE
    get_tsd
#endif
d1216 1
a1216 3
#ifdef NETWARE
    get_tsd
#endif
d1227 1
a1227 1
API_EXPORT(void) ap_keepalive_timeout(char *name, request_rec *r)
d1230 1
a1230 3
#ifdef NETWARE
    get_tsd
#endif
d1233 1
d1239 1
a1243 3
#ifdef NETWARE
    get_tsd
#endif
d1246 1
d1248 1
a1252 3
#ifdef NETWARE
    get_tsd
#endif
d1254 1
d1256 1
a1260 4
#ifdef NETWARE
    get_tsd
#endif
    ap_check_signals();
a1318 3
#ifdef NETWARE
    get_tsd
#endif
a1332 3
#ifdef NETWARE
    get_tsd
#endif
d1334 1
a1394 4
#ifdef NETWARE
        ThreadSwitch();
#endif

d1402 1
a1402 5
#if defined(WIN32) || defined(NETWARE)
             (recv(lsd, dummybuf, sizeof(dummybuf), 0) > 0));
#else
             (read(lsd, dummybuf, sizeof(dummybuf)) > 0));
#endif
d1443 1
a1443 1
	    (*(*pocr)->maintenance) (OC_REASON_UNREGISTER, (*pocr)->data, (ap_wait_t)-1);
d1499 1
a1499 1
	(*ocr->maintenance) (OC_REASON_UNWRITABLE, ocr->data, (ap_wait_t)-1);
a1540 3
    if (ap_scoreboard_image == NULL) {
	fprintf(stderr, "Ouch!  Out of memory reiniting scoreboard!\n");
    }
d1610 1
a1610 2
	fprintf(stderr, "%s: Could not create OS/2 Shared memory pool.\n",
		ap_server_argv0);
d1616 1
a1616 3
	fprintf(stderr,
		"%s: Could not uopen() newly created OS/2 Shared memory pool.\n",
		ap_server_argv0);
d1619 1
a1619 1
    ap_scoreboard_image->global.running_generation = 0;
d1629 1
a1629 2
	fprintf(stderr, "%s: Could not find existing OS/2 Shared memory pool.\n",
		ap_server_argv0);
a1674 1
    char buf[512];
d1680 1
a1680 3
	ap_snprintf(buf, sizeof(buf), "%s: could not open(create) scoreboard",
		    ap_server_argv0);
	perror(buf);
d1684 1
a1684 3
	ap_snprintf(buf, sizeof(buf), "%s: could not ltrunc scoreboard",
		    ap_server_argv0);
	perror(buf);
d1691 1
a1691 3
	ap_snprintf(buf, sizeof(buf), "%s: cannot mmap scoreboard",
		    ap_server_argv0);
	perror(buf);
d1698 1
a1698 1
    ap_scoreboard_image->global.running_generation = 0;
d1736 1
a1736 1
	    fprintf(stderr, "%s: Could not open %s\n", ap_server_argv0, mfile);
d1743 1
a1743 1
	    fprintf(stderr, "%s: Could not mmap %s\n", ap_server_argv0, mfile);
d1755 1
a1755 1
	fprintf(stderr, "%s: Could not mmap memory\n", ap_server_argv0);
d1765 1
a1765 1
	fprintf(stderr, "%s: Could not open /dev/zero\n", ap_server_argv0);
d1772 1
a1772 1
	fprintf(stderr, "%s: Could not mmap /dev/zero\n", ap_server_argv0);
d1778 1
a1778 1
    ap_scoreboard_image->global.running_generation = 0;
d1800 2
a1801 3
			 "Your kernel was built without CONFIG_SYSVIPC\n"
			 "%s: Please consult the Apache FAQ for details",
			 ap_server_argv0);
d1805 1
a1805 1
                     "could not call shmget");
d1869 1
a1869 31
    ap_scoreboard_image->global.running_generation = 0;
}

static void reopen_scoreboard(pool *p)
{
}

#elif defined(USE_TPF_SCOREBOARD)

static void cleanup_scoreboard_heap()
{
    int rv;
    rv = rsysc(ap_scoreboard_image, SCOREBOARD_FRAMES, SCOREBOARD_NAME);
    if(rv == RSYSC_ERROR) {
        ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
            "rsysc() could not release scoreboard system heap");
    }
}

static void setup_shared_mem(pool *p)
{
    cinfc(CINFC_WRITE, CINFC_CMMCTK2);
    ap_scoreboard_image = (scoreboard *) gsysc(SCOREBOARD_FRAMES, SCOREBOARD_NAME);

    if (!ap_scoreboard_image) {
        fprintf(stderr, "httpd: Could not create scoreboard system heap storage.\n");
        exit(APEXIT_INIT);
    }

    ap_register_cleanup(p, NULL, cleanup_scoreboard_heap, ap_null_cleanup);
    ap_scoreboard_image->global.running_generation = 0;
a1873 1
    cinfc(CINFC_WRITE, CINFC_CMMCTK2);
a1923 3
#ifdef TPF
    ap_scoreboard_fname = ap_server_root_relative(p, ap_scoreboard_fname);
#endif /* TPF */
d1936 1
a1936 1
    int running_gen = 0;
d1938 1
a1938 1
	running_gen = ap_scoreboard_image->global.running_generation;
d1945 1
a1945 1
    ap_scoreboard_image->global.running_generation = running_gen;
d1959 1
a1959 1
    ap_scoreboard_image->global.running_generation = running_gen;
a1999 17
#ifdef NETWARE
void clean_shutdown_on_exit(void)
{
    if (!ap_main_finished) {
        AMCSocketCleanup();
        ap_destroy_pool(pcommands);    
        free(ap_loaded_modules);    
        ap_cleanup_method_ptrs();    
        ap_destroy_pool(pglobal);
        ap_cleanup_alloc();
        ap_main_finished = TRUE;
    }
}

void clean_parent_exit(int code) __attribute__((noreturn));
void clean_parent_exit(int code)
#else
a2001 1
#endif
a2002 9
#ifdef NETWARE
    AMCSocketCleanup();
    ap_destroy_pool(pcommands);    
    free(ap_loaded_modules);    
    ap_cleanup_method_ptrs();    
    ap_destroy_pool(pglobal);
    ap_cleanup_alloc();
    ap_main_finished = TRUE;
#else
d2004 1
a2004 2
    ap_destroy_pool(pglobal);
#endif
d2008 1
a2008 1
API_EXPORT(int) ap_update_child_status(int child_num, int status, request_rec *r)
a2015 2
    ap_check_signals();

a2019 4
#ifdef NETWARE
    ap_scoreboard_image->parent[child_num].pid = GetThreadID();
#endif

d2054 1
a2054 1
	    ss->vhostrec =  r->server;
a2056 12
    if (status == SERVER_STARTING && r == NULL) {
	/* clean up the slot's vhostrec pointer (maybe re-used)
	 * and mark the slot as belonging to a new generation.
	 */
	ss->vhostrec = NULL;
	ap_scoreboard_image->parent[child_num].generation = ap_my_generation;
#ifdef SCOREBOARD_FILE
	lseek(scoreboard_fd, XtOffsetOf(scoreboard, parent[child_num]), 0);
	force_write(scoreboard_fd, &ap_scoreboard_image->parent[child_num],
	    sizeof(parent_score));
#endif
    }
a2158 1
    int ret;
d2165 1
a2165 1
    for (tries = terminate ? 4 : 1; tries <= 12; ++tries) {
d2168 1
a2168 2
	 * Set delay with an exponential backoff. NOTE: if we get
 	 * interupted, we'll wait longer than expected...
d2173 1
a2173 3
	do {
	    ret = ap_select(0, NULL, NULL, NULL, &tv);
	} while (ret == -1 && errno == EINTR);
a2219 5
		waittime = 1024 * 16; /* give them some time to die */
		break;
	    case 9:     /*   6 sec */
	    case 10:    /* 6.1 sec */
	    case 11:    /* 6.4 sec */
d2221 1
a2221 1
	    case 12:    /* 7.4 sec */
d2242 1
a2242 1
		(*ocr->maintenance) (OC_REASON_RESTART, ocr->data, (ap_wait_t)status);
d2245 1
a2245 1
		(*ocr->maintenance) (OC_REASON_RESTART, ocr->data, (ap_wait_t)-1);
d2251 1
a2251 1
		(*ocr->maintenance) (OC_REASON_LOST, ocr->data, (ap_wait_t)-1);
a2290 1
#ifndef NETWARE
d2327 1
d2357 1
a2357 1
#endif
d2496 1
a2496 1
#if !defined(WIN32) && !defined(NETWARE)
a2517 3
#ifdef NETWARE
    get_tsd
#endif
d2541 1
a2541 1
API_VAR_EXPORT ap_generation_t volatile ap_my_generation=0;
d2545 6
a2550 26
 * Signalling Apache on NT.
 *
 * Under Unix, Apache can be told to shutdown or restart by sending various
 * signals (HUP, USR, TERM). On NT we don't have easy access to signals, so
 * we use "events" instead. The parent apache process goes into a loop
 * where it waits forever for a set of events. Two of those events are
 * called
 *
 *    apPID_shutdown
 *    apPID_restart
 *
 * (where PID is the PID of the apache parent process). When one of these
 * is signalled, the Apache parent performs the appropriate action. The events
 * can become signalled through internal Apache methods (e.g. if the child
 * finds a fatal error and needs to kill its parent), via the service
 * control manager (the control thread will signal the shutdown event when
 * requested to stop the Apache service), from the -k Apache command line,
 * or from any external program which finds the Apache PID from the
 * httpd.pid file.
 *
 * The signal_parent() function, below, is used to signal one of these events.
 * It can be called by any child or parent process, since it does not
 * rely on global variables.
 *
 * On entry, type gives the event to signal. 0 means shutdown, 1 means 
 * graceful restart.
d2553 1
a2553 1
static void signal_parent(int type)
a2555 4
    char *signal_name;
    extern char signal_shutdown_name[];
    extern char signal_restart_name[];

a2562 1
    /* XXX: This is no good, can't we please die in -X mode :-? */
d2567 1
a2567 7
    switch(type) {
    case 0: signal_name = signal_shutdown_name; break;
    case 1: signal_name = signal_restart_name; break;
    default: return;
    }

    APD2("signal_parent signalling event \"%s\"", signal_name);
d2569 1
a2569 1
    e = OpenEvent(EVENT_ALL_ACCESS, FALSE, signal_name);
d2571 1
a2571 1
	/* Um, problem, can't signal the parent, which means we can't
d2575 1
a2575 1
	    "OpenEvent on %s event", signal_name);
d2581 1
a2581 2
	    "SetEvent on %s event", signal_name);
	CloseHandle(e);
d2589 1
a2589 1
 * ap_start_shutdown() and ap_start_restart(), below, are a first stab at
d2594 9
a2602 3
 * call ap_start_shutdown() or ap_start_restart() as appropiate.  Note that
 * these functions can also be called by the child processes, since global
 * variables are no longer used to pass on the required action to the parent.
d2605 1
a2605 1
API_EXPORT(void) ap_start_shutdown(void)
a2606 1
#ifndef WIN32
d2615 3
a2617 2
#else
    signal_parent(0);	    /* get the parent process to wake up */
d2622 1
a2622 1
API_EXPORT(void) ap_start_restart(int graceful)
a2623 1
#ifndef WIN32
d2630 3
a2632 2
#else
    signal_parent(1);	    /* get the parent process to wake up */
d2643 1
a2643 1
#if !defined (WIN32) && !defined(NETWARE)
a2701 5
#ifdef SIGPIPE
    sa.sa_handler = SIG_IGN;
    if (sigaction(SIGPIPE, &sa, NULL) < 0)
	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGPIPE)");
#endif
d2733 1
a2733 1
#ifndef NETWARE
a2734 1
#endif
a2740 4
#ifdef SIGPIPE
    signal(SIGPIPE, SIG_IGN);
#endif /* SIGPIPE */

d2751 1
a2751 1
#if !defined(WIN32) && !defined(NETWARE)
d2755 1
a2755 2
#if !defined(MPE) && !defined(OS2) && !defined(TPF) && !defined(BEOS) && \
    !defined(BONE)
d2758 6
a2763 9
    if (do_detach) {
        if ((x = fork()) > 0)
            exit(0);
        else if (x == -1) {
            perror("fork");
	    fprintf(stderr, "%s: unable to fork new process\n", ap_server_argv0);
	    exit(1);
        }
        RAISE_SIGSTOP(DETACH);
d2765 1
d2770 1
a2770 4
	fprintf(stderr, "%s: setsid failed\n", ap_server_argv0);
	if (!do_detach) 
	    fprintf(stderr, "setsid() failed probably because you aren't "
		"running under a process management tool like daemontools\n");
d2776 1
a2776 1
	fprintf(stderr, "%s: setpgrp or getpgrp failed\n", ap_server_argv0);
d2779 2
a2780 2
#elif defined(OS2) || defined(TPF)
    /* OS/2 and TPF don't support process group IDs */
a2784 7
#elif defined(CYGWIN)
    /* Cygwin does not take any argument for setpgrp() */
    if ((pgrp = setpgrp()) == -1) {
        perror("setpgrp");
        fprintf(stderr, "%s: setpgrp failed\n", ap_server_argv0);
        exit(1);
    }
d2788 1
a2788 1
	fprintf(stderr, "%s: setpgrp failed\n", ap_server_argv0);
d2795 2
a2796 2
	fprintf(stderr, "%s: unable to replace stdin with /dev/null: %s\n",
		ap_server_argv0, strerror(errno));
d2804 2
a2805 2
	fprintf(stderr, "%s: unable to replace stdout with /dev/null: %s\n",
		ap_server_argv0, strerror(errno));
d2823 1
a2823 1
#if !defined(WIN32) && !defined(NETWARE) && !defined(BEOS) && !defined(BONE)
d2846 2
a2847 2
#if !defined(OS2) && !defined(TPF)
	/* OS/2 and TPF don't support groups. */
d2849 1
a2849 21
	/*
	 * Set the GID before initgroups(), since on some platforms
	 * setgid() is known to zap the group list.
	 */
#ifdef MPE
	GETPRIVMODE();
#endif
	if (setgid(ap_group_id) == -1) {
#ifdef MPE
	    GETUSERMODE();
#endif
	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
			"setgid: unable to set group id to Group %u",
			(unsigned)ap_group_id);
	    clean_child_exit(APEXIT_CHILDFATAL);
	}
#ifdef MPE
	GETUSERMODE();
#endif

	/* Reset `groups' attributes. */
d2863 8
a2870 2
#endif /* MULTIPLE_GROUPS */
#endif /* !defined(OS2) && !defined(TPF) */
d2872 1
a2872 1
#endif /* !defined(WIN32) && !defined(NETWARE) && !defined(BEOS) */
d2878 2
a2879 1
    int result = 0;
d2881 2
a2882 2
#if !defined(WIN32) && !defined(NETWARE) && !defined(TPF)
    struct stat wrapper;
d2884 2
a2885 5
    if ((stat(SUEXEC_BIN, &wrapper)) != 0) {
	result = 0;
    }
    else if ((wrapper.st_mode & S_ISUID) && (wrapper.st_uid == 0)) {
	result = 1;
d2888 1
a2888 1
    return result;
a2910 2
    conn->local_ip = ap_pstrdup(conn->pool,
				inet_ntoa(conn->local_addr.sin_addr));
d2923 1
a2923 1
#if defined(TCP_NODELAY) && !defined(MPE) && !defined(TPF)
a2938 3
#ifdef NETWARE
        errno = WSAGetLastError();
#endif
d2948 1
d2964 1
a2964 1
	    ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
d2966 2
a2967 3

	    ap_unblock_alarms();
	    exit(1);
a2989 1
#ifndef BEOS /* this won't work for BeOS sockets!! */
a2990 1
#endif
a2992 3
#ifdef TPF
    os_note_additional_cleanups(p, s);
#endif /* TPF */
d2995 2
a3000 3
#ifdef BEOS
	closesocket(s);
#else
a3001 1
#endif
d3003 1
a3003 1
	exit(1);
d3007 2
a3008 1
#if defined(SO_KEEPALIVE) && !defined(MPE)
a3011 3
#ifdef BEOS
	closesocket(s);
#else
a3012 2
#endif

d3014 1
a3014 1
	exit(1);
d3017 1
a3057 1

a3064 4

#ifdef BEOS
	closesocket(s);
#else
a3065 1
#endif
a3076 3
#ifdef BEOS
	closesocket(s);
#else
a3077 1
#endif
a3081 30
#ifdef SO_ACCEPTFILTER
    if (ap_acceptfilter) {
#ifndef ACCEPT_FILTER_NAME
#define ACCEPT_FILTER_NAME "httpready"
#ifdef __FreeBSD_version
#if __FreeBSD_version < 411000 /* httpready broken before 4.1.1 */
#undef ACCEPT_FILTER_NAME
#define ACCEPT_FILTER_NAME "dataready"
#endif
#endif
#endif /* ! ACCEPT_FILTER_NAME */
	/*
	 * See htdocs/manual/misc/perf-bsd44.html for a discussion of
	 * how to enable this feature and various issues with it.
	 */
	struct accept_filter_arg af = {
	    ACCEPT_FILTER_NAME, ""
	};
	if (setsockopt(s, SOL_SOCKET, SO_ACCEPTFILTER, &af, sizeof(af)) < 0) {
            if (errno == ENOPROTOOPT) {
	    	ap_log_error(APLOG_MARK, APLOG_INFO | APLOG_NOERRNO, server_conf,
			 "socket option SO_ACCEPTFILTER unkown on this machine. Continuing.");
	     } else {
	    	ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_INFO, server_conf,
			 "make_sock: for %s, setsockopt: (SO_ACCEPTFILTER)", addr);
	     }
	}
    }
#endif

d3089 1
a3089 1
#ifdef CHECK_FD_SETSIZE
a3096 3
#ifdef BEOS
	closesocket(s);
#else
d3098 1
a3098 2
#endif
	exit(1);
d3130 4
a3133 5

        if (nr == NULL) {
            fprintf(stderr, "Ouch!  malloc failed in copy_listeners()\n");
            exit(1);
        }
d3189 5
a3193 4
	/* if we get here, (fd >= 0) && (fd < FD_SETSIZE) */
	FD_SET(fd, &listenfds);
	if (fd > listenmaxfd)
	    listenmaxfd = fd;
d3238 1
a3238 1
#if defined(WIN32) || defined(NETWARE)
d3255 1
a3255 1
    iVersionRequested = MAKEWORD(2, 0);
a3257 1
        printf("WSAStartup failed with error %d\n", err);
d3261 2
a3262 4

    if (LOBYTE(wsaData.wVersion) != 2 ||
	HIBYTE(wsaData.wVersion) != 0) {
        printf("Apache requires Winsock 2. Please see the Apache FAQ for more information.\n");
d3267 1
d3270 1
a3288 3
#ifdef TPF
    show_os_specific_compile_settings();
#endif
d3325 2
a3326 5
#ifdef HAVE_FCNTL_SERIALIZED_ACCEPT
    printf(" -D HAVE_FCNTL_SERIALIZED_ACCEPT\n");
#endif
#ifdef HAVE_FLOCK_SERIALIZED_ACCEPT
    printf(" -D HAVE_FLOCK_SERIALIZED_ACCEPT\n");
d3328 2
a3329 2
#ifdef HAVE_USLOCK_SERIALIZED_ACCEPT
    printf(" -D HAVE_USLOCK_SERIALIZED_ACCEPT\n");
d3331 2
a3332 2
#ifdef HAVE_SYSVSEM_SERIALIZED_ACCEPT
    printf(" -D HAVE_SYSVSEM_SERIALIZED_ACCEPT\n");
d3334 2
a3335 2
#ifdef HAVE_PTHREAD_SERIALIZED_ACCEPT
    printf(" -D HAVE_PTHREAD_SERIALIZED_ACCEPT\n");
d3337 2
a3338 11
#ifdef HAVE_OS2SEM_SERIALIZED_ACCEPT
    printf(" -D HAVE_OS2SEM_SERIALIZED_ACCEPT\n");
#endif
#ifdef HAVE_TPF_CORE_SERIALIZED_ACCEPT
    printf(" -D HAVE_TPF_CORE_SERIALIZED_ACCEPT\n");
#endif
#ifdef HAVE_BEOS_SERIALIZED_ACCEPT
    printf(" -D HAVE_BEOS_SERIALIZED_ACCEPT\n");
#endif  
#ifdef HAVE_NONE_SERIALIZED_ACCEPT
    printf(" -D HAVE_NONE_SERIALIZED_ACCEPT\n");
a3366 10
#ifdef SO_ACCEPTFILTER
    printf(" -D SO_ACCEPTFILTER\n");
    printf(" -D ACCEPT_FILTER_NAME=\"" ACCEPT_FILTER_NAME "\"\n");
#endif
#ifdef AP_ACCEPTFILTER_OFF
    printf(" -D AP_ACCEPTFILTER_OFF\n");
#endif
#ifdef CYGWIN_WINSOCK 
    printf(" -D CYGWIN_WINSOCK\n"); 
#endif 
d3372 1
a3372 1
#if defined(SUEXEC_BIN) && !defined(TPF)
d3375 1
a3375 1
#if defined(SHARED_CORE) && defined(SHARED_CORE_DIR)
d3387 3
d3419 1
a3419 1
#if defined(WIN32) || defined(NETWARE)
d3424 1
a3424 3
    pglobal = ap_init_alloc();
    pconf = ap_make_sub_pool(pglobal);
    plog = ap_make_sub_pool(pglobal);
d3491 9
a3499 3
    /* No such thing as root on MPE, so try to switch unconditionally */
    GETPRIVMODE();
    if (setuid(ap_user_id) == -1) {
a3500 3
	ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
		    "setuid: unable to change to uid: %d", ap_user_id);
	exit(1);
a3501 8
    GETUSERMODE();
#else
    /* 
     * Only try to switch if we're running as root
     * In case of Cygwin we have the special super-user named SYSTEM
     */
#ifdef CYGWIN
    if (getuid() == SYSTEM_UID && (
d3503 1
a3504 1
#endif
d3506 1
a3506 1
	os_init_job_environment(server_conf, ap_user_name, one_process) != 0 || 
d3510 1
a3510 1
		    "setuid: unable to change to uid: %ld", (long) ap_user_id);
d3523 2
a3524 1
     * Setup the jump buffers so that we can return here after a timeout 
d3532 1
a3533 5
#ifdef TPF
    signal(SIGHUP, just_die);
    signal(SIGTERM, just_die);
    signal(SIGUSR1, just_die);
#endif /* TPF */
d3564 1
a3564 1
	if (ap_scoreboard_image->global.running_generation != ap_my_generation) {
d3570 1
a3570 1
	     && requests_this_child++ >= ap_max_requests_per_child)) {
d3623 1
a3623 1
		csd = ap_accept(sd, &sa_client, &clen);
a3646 13

#if defined(HPUX11) && defined(ENOBUFS)
                    /* On HPUX 11.x, the 'ENOBUFS, No buffer space available'
                     * error occures because the accept() cannot complete.
                     * You will not see ENOBUFS at 10.20 because the kernel
                     * hides any occurrence from being returned from user space.
                     * ENOBUFS at 11.0 TCP/IP is quite possible, and could
                     * occur intermittently. As a work-around, we are going to
                     * ingnore ENOBUFS.
                     */
                case ENOBUFS:
#endif

d3687 1
a3687 32
#ifdef ENETDOWN
		case ENETDOWN:
		     /*
		      * When the network layer has been shut down, there
		      * is not much use in simply exiting: the parent
		      * would simply re-create us (and we'd fail again).
		      * Use the CHILDFATAL code to tear the server down.
		      * @@@@@@ Martin's idea for possible improvement:
		      * A different approach would be to define
		      * a new APEXIT_NETDOWN exit code, the reception
		      * of which would make the parent shutdown all
		      * children, then idle-loop until it detected that
		      * the network is up again, and restart the children.
		      * Ben Hyde noted that temporary ENETDOWN situations
		      * occur in mobile IP.
		      */
		    ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
			"accept: giving up.");
		    clean_child_exit(APEXIT_CHILDFATAL);
#endif /*ENETDOWN*/

#ifdef TPF
		case EINACT:
		    ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
			"offload device inactive");
		    clean_child_exit(APEXIT_CHILDFATAL);
		    break;
		default:
		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
			"select/accept error (%u)", errno);
		    clean_child_exit(APEXIT_CHILDFATAL);
#else
a3691 1
#endif
d3705 1
a3705 1
	    if (ap_scoreboard_image->global.running_generation != ap_my_generation) {
a3711 5
#ifdef TPF
	if (csd == 0)                       /* 0 is invalid socket for TPF */
	    continue;
#endif

a3719 1
#ifdef CHECK_FD_SETSIZE
a3726 1
#endif
a3765 1
#ifdef CHECK_FD_SETSIZE
a3773 1
#endif
a3801 11
#ifdef TPF_HAVE_NSD
            /* Update the TPF Network Services Database message counters */
            tpf_tcpip_message_cnt(NSDB_INPUT_CNT,
                ((struct sockaddr_in *)&sa_server)->sin_port,
                NSDB_TCP_S, 1);

            tpf_tcpip_message_cnt(NSDB_OUTPUT_CNT,
                ((struct sockaddr_in *)&sa_server)->sin_port,
                NSDB_TCP_S, 1);
#endif /* TPF_HAVE_NSD */

d3810 1
a3810 1
	    if (ap_scoreboard_image->global.running_generation != ap_my_generation) {
a3855 30
#ifdef TPF
static void reset_tpf_listeners(APACHE_TPF_INPUT *input_parms)
{
    int count;
    listen_rec *lr;

    count = 0;
    listenmaxfd = -1;
    FD_ZERO(&listenfds);
    lr = ap_listeners;

    for(;;) {
        lr->fd = input_parms->listeners[count];
        if(lr->fd >= 0) {
            FD_SET(lr->fd, &listenfds);
            if(lr->fd > listenmaxfd)
                listenmaxfd = lr->fd;
        }
        if(lr->next == NULL)
            break;
        lr = lr->next;
        count++;
    }
    lr->next = ap_listeners;
    head_listener = ap_listeners;
    close_unused_listeners();
}

#endif /* TPF */

a3866 1
#ifdef SIGQUIT
a3867 1
#endif
a3877 7

#ifdef _OSD_POSIX
    /* BS2000 requires a "special" version of fork() before a setuid() call */
    if ((pid = os_fork(ap_user_name)) == -1) {
#elif defined(TPF)
    if ((pid = os_fork(s, slot)) == -1) {
#else
a3878 1
#endif
d3937 1
a3937 1
    time_t now = time(NULL);
a3962 17
/*
 * Define the signal that is used to kill off children if idle_count
 * is greater then ap_daemons_max_free. Usually we will use SIGUSR1
 * to gracefully shutdown, but unfortunatly some OS will need other 
 * signals to ensure that the child process is terminated and the 
 * scoreboard pool is not growing to infinity. Also set the signal we
 * use to kill of childs that exceed timeout. This effect has been
* seen at least on Cygwin 1.x. -- Stipe Tolj <tolj@@wapme-systems.de>
 */
#if defined(CYGWIN)
#define SIG_IDLE_KILL SIGKILL
#define SIG_TIMEOUT_KILL SIGUSR2
#else
#define SIG_IDLE_KILL SIGUSR1
#define SIG_TIMEOUT_KILL SIGALRM
#endif

d3969 1
a3969 1
    time_t now = time(NULL);
d4032 1
a4032 1
		    kill(ps->pid, SIG_TIMEOUT_KILL);
d4042 1
a4042 2
	 * while we were counting. Use the define SIG_IDLE_KILL to reflect
	 * which signal should be used on the specific OS.
d4044 1
a4044 1
	kill(ap_scoreboard_image->parent[to_kill].pid, SIG_IDLE_KILL);
a4070 9
#ifdef TPF
        if(make_child(server_conf, free_slots[i], now) == -1) {
            if(free_length == 1) {
                shutdown_pending = 1;
                ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
                "No active child processes: shutting down");
            }
        }
#else
a4071 1
#endif /* TPF */
d4115 6
a4120 6
			     server_conf,
			     "child pid %d exit signal %s (%d), "
			     "possible coredump in %s",
			     pid, (WTERMSIG(status) >= NumSIG) ? "" : 
			     SYS_SIGLIST[WTERMSIG(status)], WTERMSIG(status),
			     ap_coredump_dir);
d4125 3
a4127 3
			     server_conf,
			     "child pid %d exit signal %s (%d)", pid,
			     SYS_SIGLIST[WTERMSIG(status)], WTERMSIG(status));
d4133 3
a4135 3
			 server_conf,
			 "child pid %d exit signal %d",
			 pid, WTERMSIG(status));
d4160 1
a4184 2
	ap_init_mutex_method(ap_default_mutex_method());

d4187 1
a4187 2
	ap_clear_pool(plog);
	ap_open_logs(server_conf, plog);
a4238 3
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
		    "Accept mutex: %s (Default: %s)",
		     amutex->name, ap_default_mutex_method());
d4264 1
a4264 1
			make_child(server_conf, child_slot, time(NULL));
a4302 11
#ifdef TPF
            ap_check_signals();
            if (!shutdown_pending) {
                if (os_check_server(tpf_server_name)) {
                    shutdown_pending++;
                } else {
                    sleep(1);
                    ap_check_signals();
                }
            }
#endif /*TPF */
d4321 1
a4321 1
				 "removed PID file %s (pid=%ld)",
d4326 1
a4326 1
			"caught SIGTERM, shutting down");
a4338 8
	/* advance to the next generation */
	/* XXX: we really need to make sure this new generation number isn't in
	 * use by any of the children.
	 */
	++ap_my_generation;
	ap_scoreboard_image->global.running_generation = ap_my_generation;
	update_scoreboard_global();

d4343 6
d4379 1
a4391 9
/* Cygwin 1.x SHARED_CORE support needs REALMAIN to be declared as dllexport,
 * so we can later while SHARED_CORE_BOOTSTRAP is compiled and linked see the 
 * dllimport for it. -- Stipe Tolj <tolj@@wapme-systems.de>
 */

#if defined(CYGWIN)
__declspec(dllexport)  
#endif

d4395 2
a4396 4
    int sock_in;
    int sock_out;
    char *s;
    
a4410 6
#ifdef TPF
    EBW_AREA input_parms;
    ecbptr()->ebrout = PRIMECRAS;
    input_parms = * (EBW_AREA *)(&(ecbptr()->ebw000));
#endif

d4415 1
a4415 7
    if ((s = strrchr(argv[0], PATHSEPARATOR)) != NULL) {
	ap_server_argv0 = ++s;
    }
    else {
	ap_server_argv0 = argv[0];
    }
    
d4422 1
a4422 1
				    "D:C:c:xXd:Ff:vVlLR:StTh"
a4443 3
	case 'F':
	    do_detach = 0;
	    break;
d4456 3
a4459 1
	    ap_suexec_enabled = init_suexec();
a4461 3
	case 'L':
	    ap_show_directives();
	    exit(0);
a4464 6
#ifdef TPF
	case 'x':
	    os_tpf_child(&input_parms.child);
	    set_signals();
	    break;
#endif
d4471 1
a4471 1
	case 'R':
d4483 1
a4483 2
	    ap_configtestonly = 1;
	    ap_docrootcheck = 1;
a4484 6
	case 'T':
	    ap_configtestonly = 1;
	    ap_docrootcheck = 0;
	    break;
	case 'h':
	    usage(argv[0]);
d4493 1
a4493 1
    if (ap_configtestonly) {
a4496 3
    if (ap_dump_settings) {
        exit(0);
    }
a4499 6
#ifdef BEOS
    /* make sure we're running in single_process mode - Yuck! */
    one_process = 1;
#endif

#ifndef TPF
d4501 1
a4501 1
	ap_open_logs(server_conf, plog);
a4506 38
#else
    if (!tpf_child) {
        memcpy(tpf_server_name, input_parms.parent.servname,
               INETD_SERVNAME_LENGTH);
        tpf_server_name[INETD_SERVNAME_LENGTH + 1] = '\0';
        ap_open_logs(server_conf, plog);
        ap_tpf_zinet_checks(ap_standalone, tpf_server_name, server_conf);
        ap_tpf_save_argv(argc, argv);    /* save argv parms for children */
    }
    if (ap_standalone) {
        ap_set_version();
        ap_init_modules(pconf, server_conf);
        version_locked++;
        if(tpf_child) {
           server_conf->error_log = stderr;
#ifdef HAVE_SYSLOG
            /* if ErrorLog is syslog call ap_open_logs from the child since
               syslog isn't redirected to stderr by the Apache parent */
            if (strncasecmp(server_conf->error_fname, "syslog", 6) == 0) {
               ap_open_logs(server_conf, plog);
            }
#endif /* HAVE_SYSLOG */
            copy_listeners(pconf);
            reset_tpf_listeners(&input_parms.child);
#ifdef SCOREBOARD_FILE
            scoreboard_fd = input_parms.child.scoreboard_fd;
            ap_scoreboard_image = &_scoreboard_image;
#else /* must be USE_TPF_SCOREBOARD or USE_SHMGET_SCOREBOARD */
            ap_scoreboard_image =
                (scoreboard *)input_parms.child.scoreboard_heap;
#endif
            ap_init_mutex_method(ap_default_mutex_method());
            child_main(input_parms.child.slot);
        }
        else
            STANDALONE_MAIN(argc, argv);
    }
#endif
a4513 1
	ap_set_version();
d4516 1
a4516 2
	version_locked++;
	ap_open_logs(server_conf, plog);
d4521 9
a4529 3
	/* No such thing as root on MPE, so try to switch unconditionally */
	GETPRIVMODE();
	if (setuid(ap_user_id) == -1) {
a4530 3
	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
			"setuid: unable to change to uid: %d", ap_user_id);
	    exit(1);
a4531 9
	GETUSERMODE();
#else
    /* 
     * Only try to switch if we're running as root
     * In case of Cygwin we have the special super-user named SYSTEM
     * with a pre-defined uid.
     */
#ifdef CYGWIN
    if ((getuid() == SYSTEM_UID) && setuid(ap_user_id) == -1) {
d4533 1
a4534 1
#endif
d4536 1
a4536 2
			"setuid: unable to change to uid: %ld",
			(long) ap_user_id);
a4543 13
#ifdef MPE
/* HP MPE 5.5 inetd only passes the incoming socket as stdin (fd 0), whereas
   HPUX inetd passes the incoming socket as stdin (fd 0) and stdout (fd 1).
   Go figure.  SR 5003355016 has been submitted to request that the existing
   functionality be documented, and then to enhance the functionality to be
   like HPUX. */
    sock_in = fileno(stdin);
    sock_out = fileno(stdin);
#else
    sock_in = fileno(stdin);
    sock_out = fileno(stdout);
#endif

d4545 1
a4545 1
	if ((getpeername(sock_in, &sa_client, &l)) < 0) {
d4552 1
a4552 1
	if (getsockname(sock_in, &sa_server, &l) < 0) {
d4559 12
a4570 2
        cio->fd = sock_out;
        cio->fd_in = sock_in;
d4636 1
a4636 1
 * passed to it with the -Z argument when the child is spawned. The
d4640 1
a4640 3
 * A non-graceful die would need a second event. The -Z argument in
 * the child is also used to create the shutdown and restart events,
 * since the prefix (apPID) contains the parent process PID.
d4703 1
a4703 1
    
a4704 1

a4707 3
    if (new_job == NULL) {
	fprintf(stderr, "Ouch!  Out of memory in add_job()!\n");
    }
d4720 1
a4720 1
int remove_job(int csd)
a4721 2
    static reported = 0;
    static active_threads = 0;
a4724 8
    /* Decline decrementing active_threads count on the first call
     * to remove_job.  csd == -1 implies that this is the thread's
     * first call to remove_job.
     */
    if (csd != -1) {
        active_threads--;
    }

a4753 1

a4758 1

a4761 13

    /* If sock == -1 then the thread is about to exit so 
     * don't count it as active.
     */
    if (sock != -1)
        active_threads++;

    if (!reported && (active_threads == ap_threads_per_child)) {
        reported = 1;
        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
                     "Server ran out of threads to serve requests. Consider "
                     "raising the ThreadsPerChild setting");
    }
a4794 10
#ifdef NETWARE
    TSD* tsd = NULL;

    while(tsd == NULL) {
        tsd = (TSD*) Thread_Data_Area;
        ThreadSwitchWithDelay();
    }
    init_name_space();
#endif
    ap_thread_count++;
d4800 2
a4801 1
     * Setup the jump buffers so that we can return here after a timeout.
d4808 1
a4808 1
#if defined(SIGURG)
a4811 4
#ifdef NETWARE
    tsd = (TSD*) Thread_Data_Area;
#endif

d4815 1
a4815 4
	
#ifdef NETWARE
        ThreadSwitch();
#endif
d4819 3
a4821 3
	 
	ap_set_callback_and_alarm(NULL, 0); /* Cancel any outstanding alarms */
	timeout_req = NULL;                 /* No request in progress */
d4823 4
d4829 1
a4829 2
	(void) ap_update_child_status(child_num, SERVER_READY,
	                              (request_rec *) NULL);
d4834 1
a4834 1
	csd = remove_job(csd);
a4836 1

d4846 1
a4846 1
	clen = sizeof(sa_server);	
d4879 1
a4879 1
				          
d4884 1
d4886 1
a4886 1
            (void) ap_update_child_status(child_num, SERVER_BUSY_WRITE, r);
d4893 1
d4896 1
a4896 8
            /* If the server is shutting down, do not allow anymore requests 
             * to be handled on the keepalive connection. Leave the thread 
             * alive to drain the job queue. This check is particularly 
             * important on the threaded server to allow the process to be 
             * quickly taken down cleanly.
             */
            if (allowed_globals.exit_now)
                break;
a4928 2
    
    ap_thread_count--;
a4931 3
#ifdef NETWARE
void child_main(void* child_num_arg)
#else
a4932 1
#endif
a4940 8
#ifdef NETWARE
    TSD Tsd;
    int *thread_ptr;
    memset(&Tsd, 0, sizeof(TSD));
    thread_ptr = __get_thread_data_area_ptr();
    *thread_ptr = (int) &Tsd;
	child_sub_main((int)child_num_arg);
#else
a4941 1
#endif
d4963 1
a4963 1
static DWORD wait_for_many_objects(DWORD nCount, CONST HANDLE *lpHandles, 
a5003 5
#define MAX_SIGNAL_NAME 30  /* Long enough for apPID_shutdown, where PID is an int */
char signal_name_prefix[MAX_SIGNAL_NAME];
char signal_restart_name[MAX_SIGNAL_NAME]; 
char signal_shutdown_name[MAX_SIGNAL_NAME];

d5006 8
a5013 31
/*
 * Initialise the signal names, in the global variables signal_name_prefix, 
 * signal_restart_name and signal_shutdown_name.
 */

void setup_signal_names(char *prefix)
{
    ap_snprintf(signal_name_prefix, sizeof(signal_name_prefix), prefix);    
    ap_snprintf(signal_shutdown_name, sizeof(signal_shutdown_name), 
	"%s_shutdown", signal_name_prefix);    
    ap_snprintf(signal_restart_name, sizeof(signal_restart_name), 
	"%s_restart", signal_name_prefix);    

    APD2("signal prefix %s", signal_name_prefix);
}

#ifndef NETWARE
static void setup_inherited_listeners(pool *p)
{
    HANDLE pipe;
    listen_rec *lr;
    int fd;
    WSAPROTOCOL_INFO WSAProtocolInfo;
    DWORD BytesRead;

    /* Setup the listeners */
    listenmaxfd = -1;
    FD_ZERO(&listenfds);

    /* Open the pipe to the parent process to receive the inherited socket
     * data. The sockets have been set to listening in the parent process.
a5014 231
    pipe = GetStdHandle(STD_INPUT_HANDLE);
    for (lr = ap_listeners; lr; lr = lr->next) {
        if (!ReadFile(pipe, &WSAProtocolInfo, sizeof(WSAPROTOCOL_INFO), 
                      &BytesRead, (LPOVERLAPPED) NULL)) {
            ap_log_error(APLOG_MARK, APLOG_WIN32ERROR|APLOG_CRIT, server_conf,
                         "setup_inherited_listeners: Unable to read socket data from parent");
            signal_parent(0);	/* tell parent to die */
            exit(1);
        }
        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
                         "BytesRead = %d WSAProtocolInfo = %x20", BytesRead, WSAProtocolInfo);
        fd = WSASocket(FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO,
                       &WSAProtocolInfo, 0, 0);
        if (fd == INVALID_SOCKET) {
            ap_log_error(APLOG_MARK, APLOG_WIN32ERROR|APLOG_CRIT, server_conf,
                         "setup_inherited_listeners: WSASocket failed to open the inherited socket.");
            signal_parent(0);	/* tell parent to die */
            exit(1);
        }
        if (fd >= 0) {
            FD_SET(fd, &listenfds);
            if (fd > listenmaxfd)
                listenmaxfd = fd;
        }
        ap_note_cleanups_for_socket(p, fd);
        lr->fd = fd;
        if (lr->next == NULL) {
            /* turn the list into a ring */
            lr->next = ap_listeners;
            break;
        }
    }
    head_listener = ap_listeners;
    close_unused_listeners();
    CloseHandle(pipe);
    return;
}
#endif

/*
 * worker_main() is main loop for the child process. The loop in
 * this function becomes the controlling thread for the actually working
 * threads (which run in a loop in child_sub_main()).
 */
 
#ifdef NETWARE
void worker_main(void)
{
    int nthreads;
    fd_set main_fds;
    int srv;
    int clen;
    int csd;
    struct sockaddr_in sa_client;
    thread **child_handles;
    int rv;
    int i;
    struct timeval tv;
    int my_pid;
    int count_select_errors = 0;
    pool *pchild;
    module **m;    
    listen_rec* lr;
    

    pchild = ap_make_sub_pool(pconf);

    ap_standalone = 1;
    sd = -1;
    nthreads = ap_threads_per_child;
    
    if (nthreads <= 0)
        nthreads = 40;
	    
    my_pid = getpid();

    ++ap_my_generation;

    copy_listeners(pconf);
    ap_restart_time = time(NULL);

    reinit_scoreboard(pconf);
    setup_listeners(pconf);

    if (listenmaxfd == -1) {
        /* Help, no sockets were made, better log something and exit */
        ap_log_error(APLOG_MARK, APLOG_CRIT|APLOG_NOERRNO, NULL,
                     "No sockets were created for listening");
        
        ap_destroy_pool(pchild);
        cleanup_scoreboard();
        exit(1);
    }
    
    set_signals();

    /* Display listening ports */
    printf("   Listening on port(s):");
    lr = ap_listeners;
    do {
       printf(" %d", ntohs(lr->local_addr.sin_port));
       lr = lr->next;
    } while(lr && lr != ap_listeners);
    
    /* Display dynamic modules loaded */
    printf("\n");    
    for (m = ap_loaded_modules; *m != NULL; m++) {
        if (((module*)*m)->dynamic_load_handle) {
            printf("   Loaded dynamic module %s\n", ap_find_module_name(*m));
        }
    }

    /*
     * - Initialize allowed_globals
     * - Create the thread table
     * - Spawn off threads
     * - Create listen socket set (done above)
     * - loop {
     *       wait for request
     *       create new job
     *   } while (!time to exit)
     * - Close all listeners
     * - Wait for all threads to complete
     * - Exit
     */

    ap_child_init_modules(pconf, server_conf);
    allowed_globals.jobmutex = ap_create_mutex(NULL);
    allowed_globals.jobsemaphore = create_semaphore(0);

    /* spawn off the threads */
    child_handles = (thread *) malloc(nthreads * sizeof(int));
    
    for (i = 0; i < nthreads; i++) {
        child_handles[i] = create_thread((void (*)(void *)) child_main, (void *) i);
    }
    
    if (nthreads > max_daemons_limit) {
        max_daemons_limit = nthreads;
    }

    while (1) {    
        tv.tv_sec = 1;
        tv.tv_usec = 0;
        
        ThreadSwitch();
        
        if (shutdown_pending)
            break;
            
        memcpy(&main_fds, &listenfds, sizeof(fd_set));
        srv = ap_select(listenmaxfd + 1, &main_fds, NULL, NULL, &tv);

        if (srv == 0) {
            count_select_errors = 0;    /* reset count of errors */
            continue;
        }
        else if (srv == SOCKET_ERROR) {
            if (h_errno != WSAEINTR) {
                /* A "real" error occurred, log it and increment the count of
                 * select errors. This count is used to ensure we don't go into
                 * a busy loop of continuous errors.
                 */
                ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, 
                             "select failed with errno %d", h_errno);
                count_select_errors++;
                if (count_select_errors > MAX_SELECT_ERRORS) {
                    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, server_conf,
                                 "Too many errors in select loop. Child process exiting.");
                    break;
                }
            }
            continue;
        } else {
            listen_rec *lr;
            
            lr = find_ready_listener(&main_fds);
	    
            if (lr != NULL) {
                sd = lr->fd;
            }
        }

        do {
            clen = sizeof(sa_client);
            csd = accept(sd, (struct sockaddr *) &sa_client, &clen);
            
            if (csd == INVALID_SOCKET) {
                csd = -1;
            }
        } while (csd < 0 && h_errno == EINTR);
	
        if (csd == INVALID_SOCKET) {
            if (h_errno != WSAECONNABORTED) {
                ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
                             "accept: (client socket) failed with errno = %d",h_errno);
            }
        }
        else {
            add_job(csd);
        }
    }

    APD2("process PID %d exiting", my_pid);

    /* Get ready to shutdown and exit */
    allowed_globals.exit_now = 1;
    
    for (i = 0; i < nthreads; i++) {
        add_job(-1);
    }

    APD2("process PID %d waiting for worker threads to exit", my_pid);
    while(ap_thread_count)
        ThreadSwitch();
    
    destroy_semaphore(allowed_globals.jobsemaphore);
    ap_destroy_mutex(allowed_globals.jobmutex);
    
    ap_child_exit_modules(pconf, server_conf);
    ap_destroy_pool(pchild);
    free(child_handles);
    cleanup_scoreboard();

    APD2("process PID %d exited", my_pid);
    clean_parent_exit(0);

}
#else
void worker_main(void)
{
d5028 2
a5032 1

d5055 1
a5055 1
    ++ap_my_generation;
d5061 2
a5062 8
    
    /*
     * Wait until we have permission to start accepting connections.
     * start_mutex is used to ensure that only one child ever
     * goes into the listen/accept loop at once. Also wait on exit_event,
     * in case we (this child) is told to die before we get a chance to
     * serve any requests.
     */
d5068 1
a5068 1
                     "Waiting for start_mutex or exit_event -- process will exit");
d5072 1
a5072 1
	exit(1);
a5080 6
    if (one_process) {
        setup_listeners(pconf);
    } else {
        /* Get listeners from the parent process */
        setup_inherited_listeners(pconf);
    }
d5082 1
d5088 1
a5088 1
	signal_parent(0);	/* tell parent to die */
d5092 1
a5092 1
	exit(1);
d5117 9
a5125 9
    for (i = 0; i < nthreads; i++) {
	child_handles[i] = create_thread((void (*)(void *)) child_main, (void *) i);
        if (child_handles[i] == 0) {
            ap_log_error(APLOG_MARK, APLOG_ERR, server_conf, 
                         "create_thread rc = %d", errno);
        }
    }
    if (nthreads > max_daemons_limit) {
	max_daemons_limit = nthreads;
d5129 28
a5156 6
        if (max_jobs_per_exe && (total_jobs > max_jobs_per_exe)) {
            /* Reached MaxRequestsPerChild. Stop accepting new connections
             * and signal the parent to start a new child process.
             */
            ap_start_restart(1);
            break;
a5157 8
        /* Always check for the exit event being signaled.
         */
        rv = WaitForSingleObject(exit_event, 0);
        ap_assert((rv == WAIT_TIMEOUT) || (rv == WAIT_OBJECT_0));
        if (rv == WAIT_OBJECT_0) {
            APD1("child: exit event signalled, exiting");
            break;
        }
d5159 7
d5168 1
d5170 8
d5179 24
a5202 1
	srv = ap_select(listenmaxfd + 1, &main_fds, NULL, NULL, &tv);
d5204 1
a5204 21
        if (srv == 0) {
            count_select_errors = 0;    /* reset count of errors */            
            continue;
        }
	else if (srv == SOCKET_ERROR) {
            if (h_errno != WSAEINTR) {
                /* A "real" error occurred, log it and increment the count of
                 * select errors. This count is used to ensure we don't go into
                 * a busy loop of continuous errors.
                 */
                ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, 
                             "select failed with errno %d", h_errno);
                count_select_errors++;
                if (count_select_errors > MAX_SELECT_ERRORS) {
                    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, server_conf,
                                 "Too many errors in select loop. Child process exiting.");
                    break;
                }
            }
            continue;
	} else {
d5215 1
d5218 1
d5220 2
a5221 1
	} while (csd < 0 && h_errno == WSAEINTR);
d5224 7
a5230 1
	    if (h_errno != WSAECONNABORTED) {
d5232 1
a5232 2
                             "accept: (client socket) failed with errno = %d",h_errno);
            }
d5239 1
a5239 1

d5244 3
a5246 1
    ap_release_mutex(start_mutex);
d5291 5
a5295 5
/*
 * Spawn a child Apache process. The child process has the command line arguments from
 * argc and argv[], plus a -Z argument giving the name of an event. The child should
 * open and poll or wait on this event. When it is signalled, the child should die.
 * prefix is a prefix string for the event name.
d5297 3
a5299 3
 * The child_num argument on entry contains a serial number for this child (used to create
 * a unique event name). On exit, this number will have been incremented by one, ready
 * for the next call. 
d5304 50
a5353 3
 * The return value is the handle to the child process if successful, else -1. If -1 is
 * returned the error will already have been logged by ap_log_error().
 */
d5366 1
a5366 1
static void cleanup_process(HANDLE *handles, HANDLE *events, int position, int *processes)
d5385 1
a5385 2
static int create_process(pool *p, HANDLE *handles, HANDLE *events, 
                          int *processes, int *child_num, char *kill_event_name, int argc, char **argv)
d5387 1
a5387 2

    int rv, i;
d5389 1
a5389 54
    char buf[1024];
    char exit_event_name[40]; /* apPID_C# */
    char *pCommand;

    STARTUPINFO si;           /* Filled in prior to call to CreateProcess */
    PROCESS_INFORMATION pi;   /* filled in on call to CreateProces */
    LPWSAPROTOCOL_INFO  lpWSAProtocolInfo;
    listen_rec *lr;
    DWORD BytesWritten;
    HANDLE hPipeRead = NULL;
    HANDLE hPipeWrite = NULL;
    HANDLE hPipeWriteDup;
    HANDLE hNullOutput = NULL;
    HANDLE hShareError = NULL;
    HANDLE hCurrentProcess;
    SECURITY_ATTRIBUTES sa = {0};  

    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;

    /* Build the command line. Should look something like this:
     * C:/apache/bin/apache.exe -Z exit_event -f ap_server_confname 
     * First, get the path to the executable...
     */
    rv = GetModuleFileName(NULL, buf, sizeof(buf));
    if (rv == sizeof(buf)) {
        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                     "Parent: Path to Apache process too long");
        return -1;
    } else if (rv == 0) {
        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                     "Parent: GetModuleFileName() returned NULL for current process.");
        return -1;
    }
    
    /* Create the exit event (apPID_C#). Parent signals this event to tell the
     * child to exit 
     */
    ap_snprintf(exit_event_name, sizeof(exit_event_name), "%s_C%d", kill_event_name, ++(*child_num));
    kill_event = CreateEvent(NULL, TRUE, FALSE, exit_event_name);
    if (!kill_event) {
        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                     "Parent: Could not create exit event for child process");
        return -1;
    }
    
	/* service children must be created with the -z option,
	 * while console mode (interactive apache) children are created
	 * with the -Z option
	 */
    pCommand = ap_psprintf(p, "\"%s\" -%c %s -f \"%s\"", buf, 
		                   isProcessService() ? 'z' : 'Z',
		                   exit_event_name, ap_server_confname);  
d5391 3
a5393 5
    for (i = 1; i < argc; i++) {
        if ((argv[i][0] == '-') && ((argv[i][1] == 'k') || (argv[i][1] == 'n')))
            ++i;
        else
            pCommand = ap_pstrcat(p, pCommand, " \"", argv[i], "\"", NULL);
d5395 3
d5399 2
a5400 108
    /* Create a pipe to send socket info to the child */
    if (!CreatePipe(&hPipeRead, &hPipeWrite, &sa, 0)) {
        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                     "Parent: Unable to create pipe to child process.\n");
        return -1;
    }

    /* Open a null handle to soak info from the child */
    hNullOutput = CreateFile("nul", GENERIC_READ | GENERIC_WRITE, 
                             FILE_SHARE_READ | FILE_SHARE_WRITE, 
                             &sa, OPEN_EXISTING, 0, NULL);
    if (hNullOutput == INVALID_HANDLE_VALUE) {
        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                     "Parent: Unable to create null output pipe for child process.\n");
        return -1;
    }

    /* Child's initial stderr -> our main server error log (or, failing that, stderr) */
    if (server_conf->error_log) {
        hShareError = (HANDLE)_get_osfhandle(fileno(server_conf->error_log));
        if (hShareError == INVALID_HANDLE_VALUE) {
            hShareError = GetStdHandle(STD_ERROR_HANDLE);
        }
    }

    hCurrentProcess = GetCurrentProcess();
    if (DuplicateHandle(hCurrentProcess, hPipeWrite, hCurrentProcess,
                        &hPipeWriteDup, 0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        CloseHandle(hPipeWrite);
        hPipeWrite = hPipeWriteDup;
    }

    /* Give the read in of the pipe (hPipeRead) to the child as stdin. The 
     * parent will write the socket data to the child on this pipe.
     */
    memset(&si, 0, sizeof(si));
    memset(&pi, 0, sizeof(pi));
    si.cb = sizeof(si);
    si.dwFlags     = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;
    si.hStdInput   = hPipeRead;
    si.hStdOutput  = hNullOutput;
    si.hStdError   = hShareError;

    if (!CreateProcess(NULL, pCommand, NULL, NULL, 
                       TRUE,      /* Inherit handles */
                       0,         /* Creation flags */
                       NULL, NULL,
                       &si, &pi)) {
        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                     "Parent: Not able to create the child process.");
        /*
         * We must close the handles to the new process and its main thread
         * to prevent handle and memory leaks.
         */ 
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        CloseHandle(hPipeRead);
        CloseHandle(hPipeWrite);        
        CloseHandle(hNullOutput);

        return -1;
    }
    else {
        ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_INFO, server_conf,
                     "Parent: Created child process %d", pi.dwProcessId);

        /* Assume the child process lives. Update the process and event tables */
        handles[*processes] = pi.hProcess;
        events[*processes] = kill_event;
        (*processes)++;

        /* We never store the thread's handle, so close it now. */
        CloseHandle(pi.hThread);

        /* Run the chain of open sockets. For each socket, duplicate it 
         * for the target process then send the WSAPROTOCOL_INFO 
         * (returned by dup socket) to the child */
        lr = ap_listeners;
        while (lr != NULL) {
            lpWSAProtocolInfo = ap_pcalloc(p, sizeof(WSAPROTOCOL_INFO));
            ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_INFO, server_conf,
                         "Parent: Duplicating socket %d and sending it to child process %d", lr->fd, pi.dwProcessId);
            if (WSADuplicateSocket(lr->fd, 
                                   pi.dwProcessId,
                                   lpWSAProtocolInfo) == SOCKET_ERROR) {
                ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                             "Parent: WSADuplicateSocket failed for socket %d.", lr->fd );
                return -1;
            }

            if (!WriteFile(hPipeWrite, lpWSAProtocolInfo, (DWORD) sizeof(WSAPROTOCOL_INFO),
                           &BytesWritten,
                           (LPOVERLAPPED) NULL)) {
                ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
                             "Parent: Unable to write duplicated socket %d to the child.", lr->fd );
                return -1;
            }

            lr = lr->next;
            if (lr == ap_listeners)
                break;
        }
    }
    CloseHandle(hPipeRead);
    CloseHandle(hPipeWrite);        
    CloseHandle(hNullOutput);
a5404 45
/* To share the semaphores with other processes, we need a NULL ACL
 * Code from MS KB Q106387
 */

static PSECURITY_ATTRIBUTES GetNullACL()
{
    PSECURITY_DESCRIPTOR pSD;
    PSECURITY_ATTRIBUTES sa;

    sa  = (PSECURITY_ATTRIBUTES) LocalAlloc(LPTR, sizeof(SECURITY_ATTRIBUTES));
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR,
					    SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (pSD == NULL || sa == NULL) {
        return NULL;
    }
    /*
     * Win98 returns nonzero on failure; check LastError to make sure.
     */
    SetLastError(0);
    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)
	|| GetLastError()) {
        LocalFree( pSD );
        LocalFree( sa );
        return NULL;
    }
    if (!SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE)
	|| GetLastError()) {
        LocalFree( pSD );
        LocalFree( sa );
        return NULL;
    }
    sa->nLength = sizeof(sa);
    sa->lpSecurityDescriptor = pSD;
    sa->bInheritHandle = TRUE;
    return sa;
}


static void CleanNullACL( void *sa ) {
    if( sa ) {
        LocalFree( ((PSECURITY_ATTRIBUTES)sa)->lpSecurityDescriptor);
        LocalFree( sa );
    }
}

a5406 2
    /* returns NULL if invalid (Win95?) */
    PSECURITY_ATTRIBUTES sa = GetNullACL();
d5408 2
d5412 1
a5412 1
    char signal_prefix_string[100];
d5415 1
a5415 2
    HANDLE signal_shutdown_event;	/* used to signal shutdown to parent */
    HANDLE signal_restart_event;	/* used to signal a restart to parent */
d5426 1
d5428 2
a5429 9
    ap_snprintf(signal_prefix_string, sizeof(signal_prefix_string),
	        "ap%d", getpid());
    setup_signal_names(signal_prefix_string);

    /* Create shutdown event, apPID_shutdown, where PID is the parent 
     * Apache process ID. Shutdown is signaled by 'apache -k shutdown'.
     */
    signal_shutdown_event = CreateEvent(sa, TRUE, FALSE, signal_shutdown_name);
    if (!signal_shutdown_event) {
d5431 1
a5431 2
		    "master_main: Cannot create shutdown event %s", signal_shutdown_name);
        CleanNullACL((void *)sa);
d5435 11
a5445 10
    /* Create restart event, apPID_restart, where PID is the parent 
     * Apache process ID. Restart is signaled by 'apache -k restart'.
     */
    signal_restart_event = CreateEvent(sa, TRUE, FALSE, signal_restart_name);
    if (!signal_restart_event) {
	CloseHandle(signal_shutdown_event);
	ap_log_error(APLOG_MARK, APLOG_EMERG|APLOG_WIN32ERROR, server_conf,
		    "master_main: Cannot create restart event %s", signal_restart_name);
        CleanNullACL((void *)sa);
	exit(1);
a5446 1
    CleanNullACL((void *)sa);
d5448 82
a5529 6
    /* Create the start mutex, apPID, where PID is the parent Apache process ID.
     * Ths start mutex is used during a restart to prevent more than one 
     * child process from entering the accept loop at once.
     */
    start_mutex = ap_create_mutex(signal_prefix_string);
    restart_pending = shutdown_pending = 0;
d5531 1
a5531 3
    do { /* restart-pending */
	if (!is_graceful) {
	    ap_restart_time = time(NULL);
d5533 2
a5534 3
        copy_listeners(pconf);
	ap_clear_pool(pconf);
	pparent = ap_make_sub_pool(pconf);
d5536 1
a5536 19
	server_conf = ap_read_config(pconf, pparent, ap_server_confname);
        setup_listeners(pconf);
	ap_clear_pool(plog);
	ap_open_logs(server_conf, plog);
	ap_set_version();
	ap_init_modules(pconf, server_conf);
	version_locked++;
        service_set_status(SERVICE_START_PENDING);
        /* Create child processes */
        while (processes_to_create--) {
            if (create_process(pconf, process_handles, process_kill_events, 
                               &current_live_processes, &child_num, signal_prefix_string, argc, argv) < 0) {
                ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
                             "master_main: create child process failed. Exiting.");
                goto die_now;
            }
        }
        service_set_status(SERVICE_RUNNING);
	restart_pending = shutdown_pending = 0;
d5538 6
a5543 36
        /* Wait for either the shutdown or restart events to be signaled */
        process_handles[current_live_processes] = signal_shutdown_event;
        process_handles[current_live_processes+1] = signal_restart_event;
        rv = WaitForMultipleObjects(current_live_processes+2, (HANDLE *)process_handles, 
                                    FALSE, INFINITE);
        if (rv == WAIT_FAILED) {
            /* Something serious is wrong */
            ap_log_error(APLOG_MARK,APLOG_CRIT|APLOG_WIN32ERROR, server_conf,
                         "master_main: : WaitForMultipeObjects on process handles and apache-signal -- doing shutdown");
            shutdown_pending = 1;
            break;
        }
        if (rv == WAIT_TIMEOUT) {
            /* Hey, this cannot happen */
            ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
                         "master_main: WaitForMultipeObjects with INFINITE wait exited with WAIT_TIMEOUT");
            shutdown_pending = 1;
        }

        cld = rv - WAIT_OBJECT_0;
        APD4("main process: wait finished, cld=%d handle %d (max=%d)", cld, process_handles[cld], current_live_processes);
        if (cld == current_live_processes) {
            /* apPID_shutdown event signalled, we should exit now */
            shutdown_pending = 1;
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf, 
                         "master_main: Shutdown event signaled. Shutting the server down.");
            if (ResetEvent(signal_shutdown_event) == 0) {
                ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_WIN32ERROR, server_conf,
                             "ResetEvent(signal_shutdown_event)");
            }
	    /* Signal each child processes to die */
	    for (i = 0; i < current_live_processes; i++) {
		APD3("master_main: signalling child %d, handle %d to die", i, process_handles[i]);
		if (SetEvent(process_kill_events[i]) == 0)
		    ap_log_error(APLOG_MARK,APLOG_ERR|APLOG_WIN32ERROR, server_conf,
                                 "master_main: SetEvent for child process in slot #%d failed", i);
a5544 16
            break;
        } else if (cld == current_live_processes+1) {
            /* apPID_restart event signalled. 
             * Signal the child to shutdown and start a new child process.
             * The restart event can be signaled by a command line restart or
             * by the child process when it handles MaxRequestPerChild connections.
             */
            int children_to_kill = current_live_processes;
            restart_pending = 1;
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf, 
                         "master_main: Restart event signaled. Doing a graceful restart.");
            if (ResetEvent(signal_restart_event) == 0) {
                ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_WIN32ERROR, server_conf,
                             "master_main: ResetEvent(signal_restart_event) failed.");
            }
            /* Signal each child process to die */
d5546 1
a5546 1
		APD3("master_main: signalling child #%d handle %d to die", i, process_handles[i]);
d5548 3
a5550 19
		    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_WIN32ERROR, server_conf,
                                 "master_main: SetEvent for child process in slot #%d failed", i);
                /* Remove the process (and event) from the process table */
                cleanup_process(process_handles, process_kill_events, i, &current_live_processes);
	    }
	    processes_to_create = 1;
            ++ap_my_generation;
            continue;
        } else {
            /* The child process exited premeturely because of a fatal error condition
             * (eg, seg fault). Cleanup and restart the child process.
             */
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf, 
                         "master_main: Child processed exited prematurely. Restarting the child process.");
	    ap_assert(cld < current_live_processes);
	    cleanup_process(process_handles, process_kill_events, cld, &current_live_processes);
	    APD2("main_process: child in slot %d died", rv);
            processes_to_create = 1;
            continue;
d5552 2
a5553 2

    } while (1);
d5562 1
d5582 1
a5582 3

    CloseHandle(signal_restart_event);
    CloseHandle(signal_shutdown_event);
d5591 1
a5591 1
			 "removed PID file %s (pid=%ld)",
a5601 1
#endif
d5603 3
a5605 85
/*
 * Send signal to a running Apache. On entry signal should contain
 * either "shutdown" or "restart"
 */

int send_signal(pool *p, char *signal)
{
    char prefix[20];
    FILE *fp;
    int nread;
    char *fname;
    int end;

    fname = ap_server_root_relative (p, ap_pid_fname);

    fp = fopen(fname, "r");
    if (!fp) {
	printf("Cannot read apache PID file %s\n", fname);
        return FALSE;
    }
    prefix[0] = 'a';
    prefix[1] = 'p';

    nread = fread(prefix+2, 1, sizeof(prefix)-3, fp);
    if (nread == 0) {
	fclose(fp);
	printf("PID file %s was empty\n", fname);
        return FALSE;
    }
    fclose(fp);

    /* Terminate the prefix string */
    end = 2 + nread - 1;
    while (end > 0 && (prefix[end] == '\r' || prefix[end] == '\n'))
	end--;
    prefix[end + 1] = '\0';

    setup_signal_names(prefix);

    if (!strcasecmp(signal, "shutdown"))
	ap_start_shutdown();
    else if (!strcasecmp(signal, "restart"))
	ap_start_restart(1);
    else {
	printf("Unknown signal name \"%s\". Use either shutdown or restart.\n",
	    signal);
        return FALSE;
    }
    return TRUE;
}

void post_parse_init()
{
    ap_set_version();
    ap_init_modules(pconf, server_conf);
    ap_suexec_enabled = init_suexec();
    version_locked++;
    ap_open_logs(server_conf, plog);
    set_group_privs();
}


#ifdef NETWARE
extern char *optarg;

void signal_handler(int sig)
{
    switch (sig) {
    case SIGTERM:
        shutdown_pending = 1;

        while(!ap_main_finished)
            ThreadSwitchWithDelay();

        break;
    }
    return;
}
#endif

#if defined(NETWARE)
int apache_main(int argc, char *argv[])
#elif defined(WIN32)
 __declspec(dllexport)
int apache_main(int argc, char *argv[])
d5613 3
a5615 2
    char *s;
    int conf_specified = 0;
d5617 3
a5619 7
#ifdef WIN32
    jmp_buf reparse_args;
    char *service_name = NULL;
    int install = 0;
    int reparsed = 0;
    int is_child_of_service = 0;
    char *signal_to_send = NULL;
d5621 2
a5622 2
    /* Service application under WinNT the first time through only...
     * service_main immediately resets real_exit_code to zero
d5624 7
a5630 12
    if (real_exit_code && isWindowsNT()) 
    {
        if (((argc == 1) && isProcessService()) 
            || ((argc == 2) && !strcmp(argv[1], "--ntservice")))
        {
            service_main(apache_main, argc, argv);
            /* this was the end of the service control thread... 
             * cleanups already ran when second thread of apache_main
             * terminated, so simply...
             */
            exit(0);
        }
d5633 2
a5634 23
    /* This behavior is voided by setting real_exit_code to 0 */
    atexit(hold_console_open_on_error);
#endif

#ifdef NETWARE
    int currentScreen = GetCurrentScreen();
    /* If top_module is not NULL then APACHEC was not exited cleanly
     * and is in a bad state.  Simply clean up and exit.
     */
    check_clean_load (top_module);
    init_name_space();
    signal(SIGTERM, signal_handler);
    atexit(clean_shutdown_on_exit);
    init_tsd();
#endif

    /* Console application or a child process. */

    if ((s = strrchr(argv[0], PATHSEPARATOR)) != NULL) {
        ap_server_argv0 = ++s;
    }
    else {
        ap_server_argv0 = argv[0];
d5636 1
a5637 1
    common_init();
d5640 1
a5640 55
    /* initialize ap_server_root to the directory of the executable, in case
     * the user chooses a relative path for the -d serverroot arg a bit later
     */

#ifdef NETWARE
    if(!*ap_server_root) {
        ap_cpystrn(ap_server_root, bslash2slash(remove_filename(argv[0])),
                   sizeof(ap_server_root));
    }
#endif

#ifdef WIN32
    if(!*ap_server_root) {
        if (GetModuleFileName(NULL, ap_server_root, sizeof(ap_server_root))) {
            ap_cpystrn(ap_server_root,
                       ap_os_canonical_filename(pcommands, ap_server_root), 
                       sizeof(ap_server_root));
            if (ap_os_is_path_absolute(ap_server_root) 
                    && strchr(ap_server_root, '/'))
                *strrchr(ap_server_root, '/') = '\0';
            else 
                *ap_server_root = '\0';
        }
    }
#endif

    /* Fallback position if argv[0] wasn't deciphered
     */
    if (!*ap_server_root)
        ap_cpystrn(ap_server_root, HTTPD_ROOT, sizeof(ap_server_root));

    chdir (ap_server_root);

#ifdef WIN32
    /* If this is a service, we will need to fall back here and 
     * reparse the entire options list.
     */
    if (setjmp(reparse_args)) {
        /* Reset and reparse the command line */
        ap_server_pre_read_config  = ap_make_array(pcommands, 1, sizeof(char *));
        ap_server_post_read_config = ap_make_array(pcommands, 1, sizeof(char *));
        ap_server_config_defines   = ap_make_array(pcommands, 1, sizeof(char *));

        /* Reset optreset and optind to allow getopt to work correctly
         * the second time around, and assure we never come back here.
         */
        optreset = 1;
        optind = 1;
        reparsed = 1;
    }

    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVlLz:Z:wiuStThk:n:W:")) != -1) {
#else /* !WIN32 */
    while ((c = getopt(argc, argv, "D:C:c:Xd:fF:vVlLesStTh")) != -1) {
#endif
d5656 1
a5656 16
        /* Shortcuts; include the -w option to hold the window open on error.
         * This must not be toggled once we reset real_exit_code to 0!
         */
        case 'w':
            if (real_exit_code)
                real_exit_code = 2;
            break;
	/* service children must be created with the -z option,
	 * while console mode (interactive apache) children are created
	 * with the -Z option
	 */
        case 'z':
            is_child_of_service = 1;
        case 'Z':
            /* Prevent holding open the (nonexistant) console */
            real_exit_code = 0;
d5662 1
a5662 3
	    setup_signal_names(optarg);
	    start_mutex = ap_open_mutex(signal_name_prefix);
	    ap_assert(start_mutex);
a5664 3
        case 'n':
            service_name = ap_pstrdup(pcommands, optarg);
            break;
d5666 1
a5666 1
            install = 2;
d5669 1
a5669 1
            install = -1;
d5671 2
a5672 11
	case 'k':
            if (!strcasecmp(optarg, "stop"))
                signal_to_send = "shutdown";
            else if (!strcasecmp(optarg, "install"))
                install = 2;
            else if (!strcasecmp(optarg, "config"))
                install = 1;
            else if (!strcasecmp(optarg, "uninstall"))
                install = -1;
            else
                signal_to_send = optarg;
a5673 42
        case 'W':
            /* -With a dependent service */
            if (install < 1) {
	        fprintf(stderr, "%s: invalid option: -W %s ignored\n"
                        "\t-W only modifies -k install or -k config\n",
                        argv[0], optarg);
            }
            else if (!isWindowsNT()) {
                fprintf(stderr, "%s: invalid option: -W %s ignored\n"
                        "\t-W is only supported for Windows NT/2000\n",
                        argv[0], optarg);
            }
            break;
#endif /* WIN32 */
#ifdef NETWARE
        case 'e':
            {
                int screenHandle;  

                /* Get a screen handle for the console screen. */
                if ((screenHandle = CreateScreen("System Console", 0)) != NULL)
                {
                    SetAutoScreenDestructionMode(1); 
                    SetCurrentScreen(screenHandle);  /* switch to console screen I/O */
                }
            }
            break;
        case 's':
            if (DestroyScreen(GetCurrentScreen()) == 0)
            {
                int screenHandle;  

                /* Create a screen handle for the console screen, 
                even though the console screen exists. */
                if ((screenHandle = CreateScreen("System Console", 0)) != NULL)
                {
                    SetCurrentScreen(screenHandle);  /* switch to console screen I/O */
                    currentScreen = GetCurrentScreen();
                }
            }
            break;
#endif
d5677 1
d5679 1
a5679 11
            optarg = ap_os_canonical_filename(pcommands, optarg);
            if (!ap_os_is_path_absolute(optarg)) {
	        optarg = ap_pstrcat(pcommands, ap_server_root, "/", 
                                    optarg, NULL);
            }
            ap_cpystrn(ap_server_root, optarg, sizeof(ap_server_root));
            ap_getparents(ap_server_root);
            ap_no2slash(ap_server_root);
            if (ap_server_root[0] 
                    && ap_server_root[strlen(ap_server_root) - 1] == '/')
                ap_server_root[strlen(ap_server_root) - 1] = '\0';
a5680 5
#ifndef WIN32
	case 'F':
	    do_detach = 0;
	    break;
#endif
d5682 1
a5682 4
            ap_cpystrn(ap_server_confname,
                       ap_os_canonical_filename(pcommands, optarg),
                       sizeof(ap_server_confname));
            conf_specified = 1;
d5688 2
a5689 7
#ifdef WIN32
            clean_parent_exit(1);
#else
            clean_parent_exit(0);
#endif

        case 'V':
d5692 4
a5695 6
#ifdef WIN32
            clean_parent_exit(1);
#else
            clean_parent_exit(0);
#endif

d5698 1
a5698 14
#ifdef WIN32
            clean_parent_exit(1);
#else
            clean_parent_exit(0);
#endif

	case 'L':
	    ap_show_directives();
#ifdef WIN32
            clean_parent_exit(1);
#else
            clean_parent_exit(0);
#endif

d5703 1
a5703 2
	    ap_configtestonly = 1;
	    ap_docrootcheck = 1;
a5704 6
	case 'T':
	    ap_configtestonly = 1;
	    ap_docrootcheck = 0;
	    break;
	case 'h':
	    usage(ap_server_argv0);
d5706 2
a5707 11
	    usage(ap_server_argv0);
        }   /* switch */
#ifdef NETWARE
        ThreadSwitch();
#endif
    }       /* while  */

#ifdef WIN32

    if (!service_name && install) {
        service_name = DEFAULTSERVICENAME;
d5710 2
a5711 2
    if (service_name) {
        service_name = get_display_name(service_name);
d5714 1
a5714 56
    if (service_name && isValidService(service_name)) 
    {
        if (install == 2) {
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, NULL,
                         "Service \"%s\" is already installed!", service_name);
            clean_parent_exit(1);
        }
        /* Don't proceed if we are configuring, uninstalling 
         * or already merged and reparsed the service args
         */
        if (!install && !reparsed)
        {
            int svcargc;
            char **newargv, **svcargv;
            if (ap_configtestonly)
                fprintf(stderr, "Default command options for service %s:\n", 
                        service_name);
                    
            /* Merge the service's default args */
            if (ap_registry_get_service_args(pcommands, &svcargc, &svcargv, 
                                             service_name) > 0) {
                newargv = (char**)malloc((svcargc + argc + 1) * sizeof(char*));
                newargv[0] = argv[0];  /* The true executable name */
                memcpy(newargv + 1, svcargv, svcargc * sizeof(char*)); 
                memcpy(newargv + 1 + svcargc, argv + 1, 
                       (argc - 1) * sizeof(char*));
                argc += svcargc; /* Add the startup options args */
                argv = newargv;
                argv[argc] = NULL;

                if (ap_configtestonly) {
                    while (svcargc-- > 0) {
                        if ((**svcargv == '-') && strchr("dfDCc", svcargv[0][1])
                            && svcargc) {
                            fprintf(stderr, "    %s %s\n", 
                                    *svcargv, *(svcargv + 1));
                            svcargv += 2; --svcargc;
                        }
                        else
                            fprintf(stderr, "    %s\n", *(svcargv++));
                    }
                }
                /* Run through the command line args all over again */
                longjmp(reparse_args, 1);
            }
            else if (ap_configtestonly)
                fprintf (stderr, "    (none)\n");
        }
    }
    else if (service_name && (install <= 1))
    {
        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, NULL,
                     "Service \"%s\" is not installed!", service_name);
        clean_parent_exit(1);
    }
#endif
d5716 3
a5718 29
    /* ServerRoot/ServerConfFile are found in this order:
     * (1) serverroot set to Apache.exe's path, or HTTPD_ROOT if unparsable
     * (2) arguments are grabbed for the -n named service, if given
     * (3) the -d argument is taken from the given command line
     * (4) the -d argument is taken from the service's default args
     * (5) the -f argument is taken from the given command line
     * (6) the -f argument is taken from the service's default args
     * (7) if -f is omitted, then initialized to SERVER_CONFIG_FILE
     * (8) if ap_server_confname is not absolute, then merge it to serverroot
     */
    
    if (!conf_specified)
        ap_cpystrn(ap_server_confname, SERVER_CONFIG_FILE, sizeof(ap_server_confname));

    if (!ap_os_is_path_absolute(ap_server_confname))
        ap_cpystrn(ap_server_confname,
                   ap_server_root_relative(pcommands, ap_server_confname),
                   sizeof(ap_server_confname));
    ap_getparents(ap_server_confname);
    ap_no2slash(ap_server_confname);
    
#ifdef WIN32
    /* Read the conf now unless we are uninstalling the service,
     * or shutting down a running service 
     * (but do read the conf for the pidfile if we shutdown the console)
     */
    if ((install >= 0) && (!service_name || !signal_to_send 
                            || strcasecmp(signal_to_send,"shutdown"))) {
        server_conf = ap_read_config(pconf, ptrans, ap_server_confname);
d5721 2
a5722 6
    if (install) {
        if (install > 0) 
            InstallService(pconf, service_name, argc, argv, install == 1);
        else
            RemoveService(service_name);
        clean_parent_exit(0);
d5724 6
d5731 2
a5732 30
    /* All NT signals, and all but the 9x start signal are handled entirely.
     * Die if we failed, are on NT, or are not "start"ing the service
     */
    if (service_name && signal_to_send) {
        if (send_signal_to_service(service_name, signal_to_send, argc, argv))
            clean_parent_exit(0);
        if (isWindowsNT() || strcasecmp(signal_to_send, "start"))
            clean_parent_exit(1);
        /* Still here?  Then we are hanging around to detach the console 
         * and use this process as the Windows 9x service.
         */
    }
#else /* ndef WIN32 */
    server_conf = ap_read_config(pconf, ptrans, ap_server_confname);
#endif

    if (ap_configtestonly) {
        fprintf(stderr, "%s: Syntax OK\n", ap_server_root_relative(pcommands, ap_server_confname));
#ifdef WIN32
        clean_parent_exit(1);
#else
        clean_parent_exit(0);
#endif
    }

    if (ap_dump_settings) {
#ifdef WIN32
        clean_parent_exit(1);
#else
        clean_parent_exit(0);
a5733 2
    }

a5734 18
    /* Non-service Signals.  (Ignore -k start for now [with or without -n arg]) */
    if (signal_to_send && strcasecmp(signal_to_send, "start")) {
        send_signal(pconf, signal_to_send);
        clean_parent_exit(0);
    }
#endif

#ifndef NETWARE
    if (!child && !ap_dump_settings) { 
        ap_log_pid(pconf, ap_pid_fname);
    }
#endif

    post_parse_init();

#if defined(OS2)
    printf("%s running...\n", ap_get_server_version());
#elif defined(WIN32)
d5736 1
a5736 1
        printf("%s running...\n", ap_get_server_version());
a5737 7
#elif defined(NETWARE)
    if (currentScreen != GetCurrentScreen()) {
        SetCurrentScreen(currentScreen);  /* switch to console screen I/O */
        SetAutoScreenDestructionMode(0); 
    }

    printf("%s running...\n", ap_get_server_version());
a5739 1
#ifndef NETWARE
a5743 9
#endif

#ifdef NETWARE
    worker_main();
    destroy_semaphore(allowed_globals.jobsemaphore);

    while((ap_thread_count) || (!shutdown_pending))
        ThreadSwitchWithDelay();
#else 
a5751 6
#ifdef WIN32
        if (child)
            ap_start_child_console(is_child_of_service);
        else
            ap_start_console_monitor();
#endif
a5754 8
    } 
#ifdef WIN32
    /* Windows NT service second time around ... we have all the overrides 
     * from the NT SCM, so go to town and return to the SCM when we quit.
     */
    if (isWindowsNT() && isProcessService())
    {
        master_main(argc, argv);
d5756 3
a5758 17
    else if (service_name && signal_to_send && !isWindowsNT()
             && !strcasecmp(signal_to_send, "start")) {
        /* service95_main will call master_main() */
        service95_main(master_main, argc, argv, service_name);
    }
    else 
    {
	/* Let's go fishing for some signals including ctrl+c, ctrl+break,
         * logoff, close and shutdown, while the server is running
	 */
	ap_start_console_monitor();
        master_main(argc, argv);
    }
#else /* ndef WIN32 */
    else 
    {
        master_main(argc, argv);
a5759 2
#endif /* ndef WIN32 */
#endif /* ndef NETWARE */
a5787 17
#if defined(OS2) || defined(CYGWIN)
/* Shared core loader for OS/2 and Cygwin */

#if defined(CYGWIN)
__declspec(dllimport) 
#endif


int ap_main(int argc, char *argv[]); /* Load time linked from cyghttpd.dll */

int main(int argc, char *argv[])
{
    return ap_main(argc, argv);
}

#else

d5816 1
a5816 1
#define SHARED_CORE_EXECUTABLE_PROGRAM "lib" TARGET ".ep"
a5831 8
#ifdef MPE
    /*
     * MPE doesn't currently initialize the envp parameter.  Instead, we must
     * use the global variable environ. 
     */
    envp = environ;
#endif
	
d5837 1
a5837 1
    while ((c = getopt(argc, argv, "D:C:c:Xd:Ff:vVlLR:SZ:tTh")) != -1) {
a5843 1
	case 'F':
d5847 1
a5848 1
	case 'L':
a5851 2
	case 'T':
	case 'h':
d5854 1
a5854 1
	case 'R':
a5859 8
#ifdef MPE
    /*
     * MPE doesn't currently initialize the envp parameter.  Instead, we must
     * use the global variable environ. 
     */
    envp = environ;
#endif
	
d5863 1
a5863 1
    ap_snprintf(prog, sizeof(prog), "%s/%s", llp_dir, SHARED_CORE_EXECUTABLE_PROGRAM);
a5879 3
	if (envpnew == NULL) {
	    fprintf(stderr, "Ouch!  Out of memory generating envpnew!\n");
	}
d5886 1
a5886 1
	 ap_snprintf(llp_buf, sizeof(llp_buf), "%s=%s:%s", VARNAME, llp_dir, llp_existing);
d5888 1
a5888 1
	 ap_snprintf(llp_buf, sizeof(llp_buf), "%s=%s", VARNAME, llp_dir);
d5897 2
a5898 2
		"%s: Unable to exec Shared Core Executable Program `%s'\n",
		argv[0], prog);
a5904 1
#endif /* def OS2 */
a5905 23

#ifndef SHARED_CORE_BOOTSTRAP
#include "httpd.h"
/*
 * Force ap_validate_password() into the image so that modules like
 * mod_auth can use it even if they're dynamically loaded.
 */
void suck_in_ap_validate_password(void);
void suck_in_ap_validate_password(void)
{
    ap_validate_password("a", "b");
}
#endif

/* force Expat to be linked into the server executable */
#if defined(USE_EXPAT) && !defined(SHARED_CORE_BOOTSTRAP)
#include "xmlparse.h"
const XML_LChar *suck_in_expat(void);
const XML_LChar *suck_in_expat(void)
{
    return XML_ErrorString(XML_ERROR_NONE);
}
#endif /* USE_EXPAT */
@


1.1.1.3
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@a281 3
#ifdef EAPI
API_VAR_EXPORT ap_ctx *ap_global_ctx;
#endif /* EAPI */
a386 1
char tpf_mutex_key[TPF_MUTEX_KEY_SIZE];
a400 5
/* Also global, for http_core and http_protocol */
API_VAR_EXPORT int ap_protocol_req_check = 1;

API_VAR_EXPORT int ap_change_shmem_uid = 0;

a465 24
#ifdef EAPI
API_EXPORT(void) ap_add_config_define(const char *define)
{
    char **var;
    var = (char **)ap_push_array(ap_server_config_defines);
    *var = ap_pstrdup(pcommands, define);
    return;
}

/*
 * Invoke the `close_connection' hook of modules to let them do
 * some connection dependent actions before we close it.
 */
static void ap_call_close_connection_hook(conn_rec *c)
{
    module *m;
    for (m = top_module; m != NULL; m = m->next)
        if (m->magic == MODULE_MAGIC_COOKIE_EAPI)
            if (m->close_connection != NULL)
                (*m->close_connection)(c);
    return;
}
#endif /* EAPI */

d748 1
d750 1
a750 1
    int val;
d1080 1
a1080 1
        deqc(tpf_mutex_key, QUAL_S);
d1093 1
a1093 1
    enqc(tpf_mutex_key, ENQ_WAIT, 0, QUAL_S);
d1100 1
a1100 1
    deqc(tpf_mutex_key, QUAL_S);
a1520 4
#ifdef EAPI
	ap_call_close_connection_hook(save_req->connection);
#endif /* EAPI */

a1528 3
#ifdef EAPI
	ap_call_close_connection_hook(current_conn);
#endif /* EAPI */
a1830 3
#ifdef EAPI
	ap_call_close_connection_hook(r->connection);
#endif /* EAPI */
a1834 3
#ifdef EAPI
    ap_call_close_connection_hook(r->connection);
#endif /* EAPI */
d2330 1
a2330 3
    /* only worry about permissions if we attached the segment
       and we want/need to change the uid/gid */
    else if (ap_change_shmem_uid) {
a2561 3
#ifdef EAPI
    ap_kill_alloc_shared();
#endif
a3572 18
#ifdef EAPI
    conn->ctx = ap_ctx_new(conn->pool);
#endif /* EAPI */

#ifdef EAPI
    /*
     * Invoke the `new_connection' hook of modules to let them do
     * some connection dependent actions before we go on with
     * processing the request on this connection.
     */
    {
        module *m;
        for (m = top_module; m != NULL; m = m->next)
            if (m->magic == MODULE_MAGIC_COOKIE_EAPI)
                if (m->new_connection != NULL)
                    (*m->new_connection)(conn);
    }
#endif /* EAPI */
a4000 9
#ifdef EAPI
    printf(" -D EAPI\n");
#endif
#ifdef EAPI_MM
    printf(" -D EAPI_MM\n");
#ifdef EAPI_MM_CORE_PATH
    printf(" -D EAPI_MM_CORE_PATH=\"" EAPI_MM_CORE_PATH "\"\n");
#endif
#endif
a4081 1
    printf(" -D HARD_SERVER_LIMIT=%ld\n",(long)HARD_SERVER_LIMIT);
a4169 16

#ifdef EAPI
    ap_hook_init();
    ap_hook_configure("ap::buff::read", 
                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);
    ap_hook_configure("ap::buff::write",  
                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);
    ap_hook_configure("ap::buff::writev",  
                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);
    ap_hook_configure("ap::buff::sendwithtimeout", 
                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);
    ap_hook_configure("ap::buff::recvwithtimeout", 
                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);

    ap_global_ctx = ap_ctx_new(NULL);
#endif /* EAPI */
a4619 3
#ifdef EAPI
		ap_call_close_connection_hook(current_conn);
#endif /* EAPI */
a4647 3
#ifdef EAPI
	ap_call_close_connection_hook(current_conn);
#endif /* EAPI */
a4657 3
#ifdef EAPI
	    ap_call_close_connection_hook(current_conn);
#endif /* EAPI */
a5422 3
#ifdef EAPI
    ap_init_alloc_shared(TRUE);
#endif
a5426 4
#ifdef EAPI
    ap_init_alloc_shared(FALSE);
#endif

a5428 3
#ifdef EAPI
        clean_parent_exit(0);
#else
a5429 1
#endif
a5431 3
#ifdef EAPI
        clean_parent_exit(0);
#else
a5432 1
#endif
a5454 1
        sprintf(tpf_mutex_key, "%.*x", TPF_MUTEX_KEY_SIZE - 1, getpid());
a5578 4
#ifdef EAPI
	ap_call_close_connection_hook(conn);
#endif /* EAPI */

a5954 3
#ifdef EAPI
	ap_call_close_connection_hook(current_conn);
#endif /* EAPI */
a5964 3
#ifdef EAPI
	    ap_call_close_connection_hook(current_conn);
#endif /* EAPI */
d7263 1
a7263 1
    while ((c = getopt(argc, argv, "D:C:c:Xd:Ff:vVlLesStTh")) != -1) {
a7532 4
#ifdef EAPI
    ap_init_alloc_shared(TRUE);
#endif

a7571 3
#endif
#ifdef EAPI
    ap_init_alloc_shared(FALSE);
@


1.1.1.4
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
a377 1
static pool *pmutex;            /* Pool for accept mutex in child */
a387 1
pid_t tpf_parent_pid;
a543 8
        /* make sure the accept mutex is released before calling child
         * exit hooks and cleanups...  otherwise, modules can segfault
         * in such code and, depending on the mutex mechanism, leave
         * the server deadlocked...  even if the module doesn't segfault,
         * if it performs extensive processing it can temporarily prevent
         * the server from accepting new connections
         */
        ap_clear_pool(pmutex);
a678 43
/* remove_sync_sigs() is from APR 0.9.4
 *
 * It is invalid to block synchronous signals, as such signals must
 * be delivered on the thread that generated the original error
 * (e.g., invalid storage reference).  Blocking them interferes
 * with proper recovery.
 */
static void remove_sync_sigs(sigset_t *sig_mask)
{
#ifdef SIGABRT
    sigdelset(sig_mask, SIGABRT);
#endif
#ifdef SIGBUS
    sigdelset(sig_mask, SIGBUS);
#endif
#ifdef SIGEMT
    sigdelset(sig_mask, SIGEMT);
#endif
#ifdef SIGFPE
    sigdelset(sig_mask, SIGFPE);
#endif
#ifdef SIGILL
    sigdelset(sig_mask, SIGILL);
#endif
#ifdef SIGIOT
    sigdelset(sig_mask, SIGIOT);
#endif
#ifdef SIGPIPE
    sigdelset(sig_mask, SIGPIPE);
#endif
#ifdef SIGSEGV
    sigdelset(sig_mask, SIGSEGV);
#endif
#ifdef SIGSYS
    sigdelset(sig_mask, SIGSYS);
#endif
#ifdef SIGTRAP
    sigdelset(sig_mask, SIGTRAP);
#endif

/* APR logic to remove SIGUSR2 not copied */
}

a717 1
    remove_sync_sigs(&accept_block_mask);
d906 1
a906 1
    lock_fd = ap_popenf_ex(p, ap_lock_fname, O_CREAT | O_WRONLY | O_EXCL, 0644, 1);
d973 1
a973 1
    flock_fd = ap_popenf_ex(p, ap_lock_fname, O_WRONLY, 0600, 1);
d989 1
a989 1
    flock_fd = ap_popenf_ex(p, ap_lock_fname, O_CREAT | O_WRONLY | O_EXCL, 0600, 1);
d2418 31
d2500 1
a2500 1
    scoreboard_fd = ap_popenf_ex(p, ap_scoreboard_fname, O_CREAT | O_BINARY | O_RDWR, 0666, 1);
d2526 1
a2526 1
    scoreboard_fd = ap_popenf_ex(p, ap_scoreboard_fname, O_CREAT | O_BINARY | O_RDWR, 0644, 1);
a2651 5
        else if (status == SERVER_STARTING) {
            /* clean out the start_time so that mod_status will print Req=0 */
            /* Use memset to be independent from the type (struct timeval vs. clock_t) */
            memset (&ss->start_time, '\0', sizeof ss->start_time);
        }
a3305 3
#ifdef TPF
    signal(sig, restart);
#endif
d3646 1
a3646 1
static void sock_disable_nagle(int s, struct sockaddr_in *sin_client)
d3664 2
a3665 9
        if (sin_client) {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, server_conf,
                         "setsockopt: (TCP_NODELAY), client %pA probably "
                         "dropped the connection", &sin_client->sin_addr);
        }
        else {
            ap_log_error(APLOG_MARK, APLOG_DEBUG, server_conf,
                         "setsockopt: (TCP_NODELAY)");
        }
d3670 1
a3670 1
#define sock_disable_nagle(s, c)	/* NOOP */
d3719 1
a3719 1
    ap_note_cleanups_for_socket_ex(p, s, 1);	/* arrange to close on exec or restart */
d3725 1
a3726 1
#ifndef _OSD_POSIX
d3736 1
a3737 1
    }
d3754 1
a3754 1
    sock_disable_nagle(s, NULL);
d3860 1
a3860 1
    ap_note_cleanups_for_socket_ex(p, s, 1);	/* arrange to close on exec or restart */
d3967 1
a3967 1
	    ap_note_cleanups_for_socket_ex(p, fd, 1);
a4158 1
    printf(" -D DYNAMIC_MODULE_LIMIT=%ld\n",(long)DYNAMIC_MODULE_LIMIT);
a4313 5
    /* associate accept mutex cleanup with a subpool of pchild so we can
     * make sure the mutex is released before calling module code at
     * termination
     */
    pmutex = ap_make_sub_pool(pchild);
d4317 1
a4317 1
    SAFE_ACCEPT(accept_mutex_child_init(pmutex));
d4561 3
a4563 3
                    ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO,
                                 server_conf, "offload device inactive");
                    clean_child_exit(APEXIT_CHILDFATAL); 
d4566 2
a4567 5
                    if (getppid() != 1) {
                        ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO,
                                     server_conf, "select/accept error (%u)",
                                     errno);
                    }
d4605 1
a4605 1
	ap_note_cleanups_for_socket_ex(ptrans, csd, 1);
d4625 1
a4625 4
	    ap_log_error(APLOG_MARK, APLOG_DEBUG, server_conf, 
                         "getsockname, client %pA probably dropped the "
                         "connection", 
                         &((struct sockaddr_in *)&sa_client)->sin_addr);
d4629 1
a4629 1
	sock_disable_nagle(csd, (struct sockaddr_in *)&sa_client);
d4653 1
a4653 1
	ap_note_cleanups_for_socket_ex(ptrans, dupped_csd, 1);
a5015 3
#ifdef TPF
        ap_update_child_status(to_kill, SERVER_DEAD, (request_rec *)NULL);
#endif
a5076 8
        /* cleanup pid file -- it is useless after our exiting */
        const char *pidfile = NULL;
        pidfile = ap_server_root_relative (pconf, ap_pid_fname);
        if ( pidfile != NULL && unlink(pidfile) == 0)
            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO,
                         server_conf,
                         "removed PID file %s (pid=%ld)",
                         pidfile, (long)getpid());
d5181 1
a5181 1
	    ap_note_cleanups_for_fd_ex(pconf, scoreboard_fd, 1); /* close on exec */
a5234 5
#ifdef TPF
            if (shutdown_pending += os_check_server(tpf_server_name)) {
                break;
            }
#endif
d5288 11
a5573 1
        tpf_parent_pid = getppid();
d5594 1
d5596 1
a5596 1
#else /* must be USE_SHMGET_SCOREBOARD */
d6000 1
a6000 1
	ap_note_cleanups_for_socket_ex(ptrans, csd, 1);
d6019 1
a6019 1
	sock_disable_nagle(csd, (struct sockaddr_in *)&sa_client);
d6032 1
a6032 1
	ap_note_cleanups_for_socket_ex(ptrans, dupped_csd, 1);
d6254 1
a6254 1
        ap_note_cleanups_for_socket_ex(p, fd, 1);
@


1.1.1.5
log
@import Apache 1.3.29 and mod_ssl 2.8.16
@
text
@d3767 1
d3769 3
d3781 1
d3783 3
d3840 1
d3842 3
d3856 1
d3858 3
d3910 1
d3912 3
@


