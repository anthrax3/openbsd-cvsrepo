head	1.22;
access;
symbols
	OPENBSD_5_5:1.21.0.20
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.16
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.14
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.12
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.10
	OPENBSD_5_0:1.21.0.8
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.8
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.6
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.5
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.4
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.3
	apache_1_3_27:1.1.1.3
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.04.22.14.47.26;	author henning;	state dead;
branches;
next	1.21;

1.21
date	2010.02.25.07.49.53;	author pyr;	state Exp;
branches;
next	1.20;

1.20
date	2008.05.15.06.05.43;	author mbalmer;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.13.17.44.46;	author mbalmer;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.15.14.28.17;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.23.21.08.01;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.09.12.13.09;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.06.13.14.10;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.17.18.57.05;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.21.13.11.35;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.06.21.08.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.29.02.08.05;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.05.02.26.58;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.29.10.21.42;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.22.18.05;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.25.18.29.46;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.06.29.35;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.03.01.04.28.35;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.01.06.06;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	98.10.11.19.45.11;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.39;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.39;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.28.41;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.07.19.48.12;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.21.12.53.39;	author henning;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.17.17.03.21;	author henning;	state Exp;
branches;
next	;


desc
@@


1.22
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*	$OpenBSD: buff.c,v 1.21 2010/02/25 07:49:53 pyr Exp $ */

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

#include "httpd.h"
#include "http_main.h"
#include "http_log.h"
#include "buff.h"

#include <errno.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <sys/types.h>
#include <sys/uio.h>

#ifndef DEFAULT_BUFSIZE
#define DEFAULT_BUFSIZE (4096)
#endif
/* This must be enough to represent (DEFAULT_BUFSIZE - 3) in hex,
 * plus two extra characters.
 */
#ifndef CHUNK_HEADER_SIZE
#define CHUNK_HEADER_SIZE (5)
#endif

#define ascii_CRLF "\015\012"	/* A CRLF which won't pass the conversion
				 * machinery */

/* bwrite()s of greater than this size can result in a large_write() call,
 * which can result in a writev().  It's a little more work to set up the
 * writev() rather than copy bytes into the buffer, so we don't do it for small
 * writes.  This is especially important when chunking (which is a very likely
 * source of small writes if it's a module using ap_bputc/ap_bputs)...because we
 * have the expense of actually building two chunks for each writev().
 */
#ifndef LARGE_WRITE_THRESHOLD
#define LARGE_WRITE_THRESHOLD 31
#endif


/*
 * Buffered I/O routines.
 * These are a replacement for the stdio routines.
 * Advantages:
 *  Known semantics for handling of file-descriptors (on close etc.)
 *  No problems reading and writing simultanously to the same descriptor
 *  No limits on the number of open file handles.
 *  Only uses memory resources; no need to ensure the close routine
 *  is called.
 *  Extra code could be inserted between the buffered and un-buffered routines.
 *  Timeouts could be handled by using select or poll before read or write.
 *  Extra error handling could be introduced; e.g.
 *   keep an address to which we should longjump(), or
 *   keep a stack of routines to call on error.
 */

/* Notes:
 *  On reading EOF, EOF will set in the flags and no further Input will
 * be done.
 *
 * On an error except for EAGAIN, ERROR will be set in the flags and no
 * further I/O will be done
 */


/* the lowest level reading primitive */
static int
ap_read(BUFF *fb, void *buf, int nbyte)
{
	int rv;

	if (!ap_hook_call("ap::buff::read", &rv, fb, buf, nbyte))
		rv = read(fb->fd_in, buf, nbyte);

	return rv;
}

static ap_inline int
buff_read(BUFF *fb, void *buf, int nbyte)
{
	int rv;

	rv = ap_read(fb, buf, nbyte);
	return rv;
}

/* the lowest level writing primitive */
static int
ap_write(BUFF *fb, const void *buf, int nbyte)
{
	int rv;

	if (!ap_hook_call("ap::buff::write", &rv, fb, buf, nbyte))
		rv = write(fb->fd, buf, nbyte);
	return rv;
}

static ap_inline int
buff_write(BUFF *fb, const void *buf, int nbyte)
{
	int rv;

	if (fb->filter_callback != NULL)
		fb->filter_callback(fb, buf, nbyte);

	rv = ap_write(fb, buf, nbyte);
	return rv;
}

static void
doerror(BUFF *fb, int direction)
{
	int errsave = errno;	/* Save errno to prevent overwriting it below */

	fb->flags |= (direction == B_RD ? B_RDERR : B_WRERR);
	if (fb->error != NULL)
		(*fb->error)(fb, direction, fb->error_data);

	errno = errsave;
}

/* Buffering routines */
/*
 * Create a new buffered stream
 */
API_EXPORT(BUFF *)
ap_bcreate(pool *p, int flags)
{
	BUFF *fb;

	fb = ap_palloc(p, sizeof(BUFF));
	fb->pool = p;
	fb->bufsiz = DEFAULT_BUFSIZE;
	fb->flags = flags & (B_RDWR | B_SOCKET);

	if (flags & B_RD)
		fb->inbase = ap_palloc(p, fb->bufsiz);
	else
		fb->inbase = NULL;

	/* overallocate so that we can put a chunk trailer of CRLF into this
	 * buffer
	 */
	if (flags & B_WR)
		fb->outbase = ap_palloc(p, fb->bufsiz + 2);
	else
		fb->outbase = NULL;

	fb->inptr = fb->inbase;

	fb->incnt = 0;
	fb->outcnt = 0;
	fb->outchunk = -1;
	fb->error = NULL;
	fb->bytes_sent = 0LL;

	fb->fd = -1;
	fb->fd_in = -1;

	fb->callback_data = NULL;
	fb->filter_callback = NULL;

	fb->ctx = ap_ctx_new(p);

	return fb;
}

/*
 * Push some I/O file descriptors onto the stream
 */
API_EXPORT(void)
ap_bpushfd(BUFF *fb, int fd_in, int fd_out)
{
	fb->fd = fd_out;
	fb->fd_in = fd_in;
}

API_EXPORT(int)
ap_bsetopt(BUFF *fb, int optname, const void *optval)
{
	if (optname == BO_BYTECT) {
		fb->bytes_sent = *(off_t *)optval -
		    (off_t)fb->outcnt;
		return 0;
	}
	else {
		errno = EINVAL;
		return -1;
	}
}

API_EXPORT(int)
ap_bgetopt(BUFF *fb, int optname, void *optval)
{
	if (optname == BO_BYTECT) {
		off_t bs = fb->bytes_sent + fb->outcnt;
		if (bs < 0LL)
			bs = 0LL;
		*(off_t *)optval = bs;
		return 0;
	}
	else {
		errno = EINVAL;
		return -1;
	}
}

static int bflush_core(BUFF *fb);

/*
 * Start chunked encoding.
 *
 * Note that in order for ap_bputc() to be an efficient macro we have to guarantee
 * that start_chunk() has always been called on the buffer before we leave any
 * routine in this file.  Said another way, if a routine here uses end_chunk()
 * and writes something on the wire, then it has to call start_chunk() or set
 * an error condition before returning.
 */
static void
start_chunk(BUFF *fb)
{
	if (fb->outchunk != -1) {
		/* already chunking */
		return;
	}
	if ((fb->flags & (B_WRERR | B_EOUT | B_WR)) != B_WR) {
		/* unbuffered writes */
		return;
	}

	/* we need at least the header_len + at least 1 data byte
	 * remember that we've overallocated fb->outbase so that we can always
	 * fit the two byte CRLF trailer
	 */
	if (fb->bufsiz - fb->outcnt < CHUNK_HEADER_SIZE + 1)
		bflush_core(fb);

	fb->outchunk = fb->outcnt;
	fb->outcnt += CHUNK_HEADER_SIZE;
}


/*
 * end a chunk -- tweak the chunk_header from start_chunk, and add a trailer
 */
static void
end_chunk(BUFF *fb)
{
	int i;
	unsigned char *strp;

	if (fb->outchunk == -1) {
		/* not chunking */
		return;
	}

	if (fb->outchunk + CHUNK_HEADER_SIZE == fb->outcnt) {
		/* nothing was written into this chunk, and we can't write a
		 * 0 size chunk because that signifies EOF, so just erase it
		 */
		fb->outcnt = fb->outchunk;
		fb->outchunk = -1;
		return;
	}

	/* we know this will fit because of how we wrote it in start_chunk() */
	i = ap_snprintf((char *)&fb->outbase[fb->outchunk], CHUNK_HEADER_SIZE,
	    "%x", fb->outcnt - fb->outchunk - CHUNK_HEADER_SIZE);

	/* we may have to tack some trailing spaces onto the number we just
	 * wrote in case it was smaller than our estimated size.  We've also
	 * written a \0 into the buffer with ap_snprintf so we might have to
	 * put a \r back in.
	 */
	strp = &fb->outbase[fb->outchunk + i];
	while (i < CHUNK_HEADER_SIZE - 2) {
		*strp++ = ' ';
		++i;
	}
	*strp++ = CR;
	*strp = LF;

	/* tack on the trailing CRLF, we've reserved room for this */
	fb->outbase[fb->outcnt++] = CR;
	fb->outbase[fb->outcnt++] = LF;

	fb->outchunk = -1;
}


/*
 * Set a flag on (1) or off (0).
 */
API_EXPORT(int)
ap_bsetflag(BUFF *fb, int flag, int value)
{
	if (value) {
		fb->flags |= flag;
		if (flag & B_CHUNK)
			start_chunk(fb);
	} else {
		fb->flags &= ~flag;
		if (flag & B_CHUNK)
			end_chunk(fb);
	}
	return value;
}


API_EXPORT(int)
ap_bnonblock(BUFF *fb, int direction)
{
	int fd;

	fd = (direction == B_RD) ? fb->fd_in : fb->fd;
	return fcntl(fd, F_SETFL, O_NONBLOCK);
}

API_EXPORT(int)
ap_bfileno(BUFF *fb, int direction)
{
	return (direction == B_RD) ? fb->fd_in : fb->fd;
}

/*
 * This is called instead of read() everywhere in here.  It implements
 * the B_SAFEREAD functionality -- which is to force a flush() if a read()
 * would block.  It also deals with the EINTR errno result from read().
 * return code is like read() except EINTR is eliminated.
 */

#define saferead saferead_guts

/* Test the descriptor and flush the output buffer if it looks like
 * we will block on the next read.
 *
 * Note we assume the caller has ensured that fb->fd_in <= FD_SETSIZE
 */
API_EXPORT(void)
ap_bhalfduplex(BUFF *fb)
{
	int rv;
	fd_set fds;
	struct timeval tv;

	/* We don't need to do anything if the connection has been closed
	* or there is something readable in the incoming buffer
	* or there is nothing flushable in the output buffer.
	*/
	if (fb == NULL || fb->fd_in < 0 || fb->incnt > 0 || fb->outcnt == 0)
		return;

	/* test for a block */
	do {
		FD_ZERO(&fds);
		FD_SET(fb->fd_in, &fds);
		tv.tv_sec = 0;
		tv.tv_usec = 0;
		rv = ap_select(fb->fd_in + 1, &fds, NULL, NULL, &tv);
	} while (rv < 0 && errno == EINTR && !(fb->flags & B_EOUT));

	/* treat any error as if it would block as well */
	if (rv != 1)
		ap_bflush(fb);
}

static ap_inline int
saferead_guts(BUFF *fb, void *buf, int nbyte)
{
	int rv;

	if (fb->flags & B_SAFEREAD)
		ap_bhalfduplex(fb);

	do {
		rv = buff_read(fb, buf, nbyte);
	} while (rv == -1 && errno == EINTR && !(fb->flags & B_EOUT));
	return (rv);
}


/* A wrapper around saferead which does error checking and EOF checking
 * yeah, it's confusing, this calls saferead, which calls buff_read...
 * and then there's the SFIO case.  Note that saferead takes care
 * of EINTR.
 */
static int
read_with_errors(BUFF *fb, void *buf, int nbyte)
{
	int rv;

	rv = saferead(fb, buf, nbyte);
	if (rv == 0)
		fb->flags |= B_EOF;
	else if (rv == -1 && errno != EAGAIN)
		doerror(fb, B_RD);
	return rv;
}


/*
 * Read up to nbyte bytes into buf.
 * If fewer than byte bytes are currently available, then return those.
 * Returns 0 for EOF, -1 for error.
 * NOTE EBCDIC: The readahead buffer _always_ contains *unconverted* data.
 * Only when the caller retrieves data from the buffer (calls bread)
 * is a conversion done, if the conversion flag is set at that time.
 */
API_EXPORT(int)
ap_bread(BUFF *fb, void *buf, int nbyte)
{
	int i, nrd;

	if (fb->flags & B_RDERR)
		return -1;
	if (nbyte == 0)
		return 0;

	if (!(fb->flags & B_RD)) {
		/* Unbuffered reading.  First check if there was something in
		 * the buffer from before we went unbuffered. */
		if (fb->incnt) {
			i = (fb->incnt > nbyte) ? nbyte : fb->incnt;
			memcpy(buf, fb->inptr, i);
			fb->incnt -= i;
			fb->inptr += i;
			return i;
		}
		i = read_with_errors(fb, buf, nbyte);
		return i;
	}

	nrd = fb->incnt;
	/* can we fill the buffer */
	if (nrd >= nbyte) {
		memcpy(buf, fb->inptr, nbyte);
		fb->incnt = nrd - nbyte;
		fb->inptr += nbyte;
		return nbyte;
	}

	if (nrd > 0) {
		memcpy(buf, fb->inptr, nrd);
		nbyte -= nrd;
		buf = nrd + (char *)buf;
		fb->incnt = 0;
	}
	if (fb->flags & B_EOF)
		return nrd;

	/* do a single read */
	if (nbyte >= fb->bufsiz) {
		/* read directly into caller's buffer */
		i = read_with_errors(fb, buf, nbyte);
		if (i == -1)
			return nrd ? nrd : -1;
	}
	else {
		/* read into hold buffer, then memcpy */
		fb->inptr = fb->inbase;
		i = read_with_errors(fb, fb->inptr, fb->bufsiz);
		if (i == -1)
			return nrd ? nrd : -1;
		fb->incnt = i;
		if (i > nbyte)
			i = nbyte;
		memcpy(buf, fb->inptr, i);
		fb->incnt -= i;
		fb->inptr += i;
	}
	return nrd + i;
}


/*
 * Reads from the stream into the array pointed to by buff, until
 * a (CR)LF sequence is read, or end-of-file condition is encountered
 * or until n-1 bytes have been stored in buff. If a CRLF sequence is
 * read, it is replaced by a newline character.  The string is then
 * terminated with a null character.
 *
 * Returns the number of bytes stored in buff, or zero on end of
 * transmission, or -1 on an error.
 *
 * Notes:
 *  If null characters are expected in the data stream, then
 * buff should not be treated as a null terminated C string; instead
 * the returned count should be used to determine the length of the
 * string.
 *  CR characters in the byte stream not immediately followed by a LF
 * will be preserved.
 */
API_EXPORT(int)
ap_bgets(char *buff, int n, BUFF *fb)
{
	int i, ch, ct;

	/* Can't do bgets on an unbuffered stream */
	if (!(fb->flags & B_RD)) {
		errno = EINVAL;
		return -1;
	}
	if (fb->flags & B_RDERR)
		return -1;

	ct = 0;
	i = 0;
	for (;;) {
		if (i == fb->incnt) {
			/* no characters left */
			fb->inptr = fb->inbase;
			fb->incnt = 0;
			if (fb->flags & B_EOF)
				break;
			i = read_with_errors(fb, fb->inptr, fb->bufsiz);
			if (i == -1) {
				buff[ct] = '\0';
				return ct ? ct : -1;
			}
			fb->incnt = i;
			if (i == 0)
				break;		/* EOF */
			i = 0;
			continue;		/* restart with the new data */
		}

		ch = fb->inptr[i++];
		if (ch == LF) {  /* got LF */
			if (ct == 0)
				buff[ct++] = '\n';
			/* if just preceded by CR, replace CR with LF */
			else if (buff[ct - 1] == CR)
				buff[ct - 1] = '\n';
			else if (ct < n - 1)
				buff[ct++] = '\n';
			else
				i--;		/* no room for LF */
			break;
		}
		if (ct == n - 1) {
			i--;		/* push back ch */
			break;
		}

		buff[ct++] = ch;
	}
	fb->incnt -= i;
	fb->inptr += i;

	buff[ct] = '\0';
	return ct;
}

/*
 * Looks at the stream fb and places the first character into buff
 * without removing it from the stream buffer.
 *
 * Returns 1 on success, zero on end of transmission, or -1 on an error.
 *
 */
API_EXPORT(int)
ap_blookc(char *buff, BUFF *fb)
{
	int i;

	*buff = '\0';

	if (!(fb->flags & B_RD)) {	/* Can't do blookc on an unbuffered
					 * stream */
		errno = EINVAL;
		return -1;
	}
	if (fb->flags & B_RDERR)
		return -1;

	if (fb->incnt == 0) {	/* no characters left in stream buffer */
		fb->inptr = fb->inbase;
		if (fb->flags & B_EOF)
			return 0;

		i = read_with_errors(fb, fb->inptr, fb->bufsiz);
		if (i <= 0)
			return i;
		fb->incnt = i;
	}

	*buff = fb->inptr[0];
	return 1;
}

/*
 * Skip data until a linefeed character is read
 * Returns 1 on success, 0 if no LF found, or -1 on error
 */
API_EXPORT(int)
ap_bskiplf(BUFF *fb)
{
	unsigned char *x;
	int i;

	/* Can't do bskiplf on an unbuffered stream */
	if (!(fb->flags & B_RD)) {
		errno = EINVAL;
		return -1;
	}
	if (fb->flags & B_RDERR)
		return -1;

	for (;;) {
		x = (unsigned char *)memchr(fb->inptr, '\012', fb->incnt);
		if (x != NULL) {
			x++;
			fb->incnt -= x - fb->inptr;
			fb->inptr = x;
			return 1;
		}

		fb->inptr = fb->inbase;
		fb->incnt = 0;
		if (fb->flags & B_EOF)
			return 0;
		i = read_with_errors(fb, fb->inptr, fb->bufsiz);
		if (i <= 0)
			return i;
		fb->incnt = i;
	}
}

/*
 * output a single character.  Used by ap_bputs when the buffer
 * is full... and so it'll cause the buffer to be flushed first.
 */
API_EXPORT(int)
ap_bflsbuf(int c, BUFF *fb)
{
	char ss[1];

	ss[0] = c;
	return ap_bwrite(fb, ss, 1);
}

/*
 * Fill the buffer and read a character from it
 */
API_EXPORT(int)
ap_bfilbuf(BUFF *fb)
{
	int i;
	char buf[1];

	i = ap_bread(fb, buf, 1);
	if (i == 0)
		errno = 0;		/* no error; EOF */
	if (i != 1)
		return EOF;
	else
		return buf[0];
}


/*
 * When doing chunked encodings we really have to write everything in the
 * chunk before proceeding onto anything else.  This routine either writes
 * nbytes and returns 0 or returns -1 indicating a failure.
 *
 * This is *seriously broken* if used on a non-blocking fd.  It will poll.
 *
 * Deals with calling doerror and setting bytes_sent.
 */
static int
write_it_all(BUFF *fb, const void *buf, int nbyte)
{
	int i;

	if (fb->flags & (B_WRERR | B_EOUT))
		return -1;

	while (nbyte > 0) {
		i = buff_write(fb, buf, nbyte);
		if (i < 0) {
			if (errno != EAGAIN && errno != EINTR) {
				doerror(fb, B_WR);
				return -1;
			}
		}
		else {
			nbyte -= i;
			buf = i + (const char *) buf;
			fb->bytes_sent += i;
		}
		if (fb->flags & B_EOUT)
			return -1;
	}
	return 0;
}


/* Similar to previous, but uses writev.  Note that it modifies vec.
 * return 0 if successful, -1 otherwise.
 *
 * Deals with doerror() and bytes_sent.
 */
static int
writev_it_all(BUFF *fb, struct iovec *vec, int nvec)
{
	int i, rv;

	if (fb->filter_callback != NULL) {
		for (i = 0; i < nvec; i++)
			fb->filter_callback(fb, vec[i].iov_base,
			    vec[i].iov_len);
	}

	/* while it's nice an easy to build the vector and crud, it's painful
	 * to deal with a partial writev()
	 */
	i = 0;
	while (i < nvec) {
		do
			if (!ap_hook_call("ap::buff::writev", &rv, fb, &vec[i],
			    nvec -i))
				rv = writev(fb->fd, &vec[i], nvec - i);
		while (rv == -1 && (errno == EINTR || errno == EAGAIN)
		    && !(fb->flags & B_EOUT));
		if (rv == -1) {
			if (errno != EINTR && errno != EAGAIN)
				doerror(fb, B_WR);

			return -1;
		}
		fb->bytes_sent += rv;
		/* recalculate vec to deal with partial writes */
		while (rv > 0) {
			if (rv < vec[i].iov_len) {
				vec[i].iov_base = (char *)vec[i].iov_base + rv;
				vec[i].iov_len -= rv;
				rv = 0;
			} else {
				rv -= vec[i].iov_len;
				++i;
			}
		}
		if (fb->flags & B_EOUT)
			return -1;
	}
	/* if we got here, we wrote it all */
	return 0;
}

/* A wrapper for buff_write which deals with error conditions and
 * bytes_sent.  Also handles non-blocking writes.
 */
static int
write_with_errors(BUFF *fb, const void *buf, int nbyte)
{
	int rv;

	do
		rv = buff_write(fb, buf, nbyte);
	while (rv == -1 && errno == EINTR && !(fb->flags & B_EOUT));
	if (rv == -1) {
		if (errno != EAGAIN)
			doerror(fb, B_WR);
		return -1;
	} else if (rv == 0) {
		errno = EAGAIN;
		return -1;
	}
	fb->bytes_sent += rv;
	return rv;
}


/*
 * A hook to write() that deals with chunking. This is really a protocol-
 * level issue, but we deal with it here because it's simpler; this is
 * an interim solution pending a complete rewrite of all this stuff in
 * 2.0, using something like sfio stacked disciplines or BSD's funopen().
 *
 * Can be used on non-blocking descriptors, but only if they're not chunked.
 * Deals with doerror() and bytes_sent.
 */
static int
bcwrite(BUFF *fb, const void *buf, int nbyte)
{
	char chunksize[16];		/* Big enough for practically anything */
	struct iovec vec[3];

	if (fb->flags & (B_WRERR | B_EOUT))
		return -1;

	if (!(fb->flags & B_CHUNK))
		return write_with_errors(fb, buf, nbyte);

	vec[0].iov_base = chunksize;
	vec[0].iov_len = ap_snprintf(chunksize, sizeof(chunksize), "%x" CRLF,
	    nbyte);
	vec[1].iov_base = (void *)buf;	/* cast is to avoid const warning */
	vec[1].iov_len = nbyte;
	vec[2].iov_base = ascii_CRLF;
	vec[2].iov_len = 2;

	return writev_it_all(fb, vec,
	    (sizeof(vec) / sizeof(vec[0]))) ? -1 : nbyte;
}


/*
 * Used to combine the contents of the fb buffer, and a large buffer
 * passed in.
 */
static int
large_write(BUFF *fb, const void *buf, int nbyte)
{
	struct iovec vec[4];
	int nvec;
	char chunksize[16];

	/* it's easiest to end the current chunk */
	if (fb->flags & B_CHUNK)
		end_chunk(fb);

	nvec = 0;
	if (fb->outcnt > 0) {
		vec[nvec].iov_base = (void *)fb->outbase;
		vec[nvec].iov_len = fb->outcnt;
		++nvec;
	}
	if (fb->flags & B_CHUNK) {
		vec[nvec].iov_base = chunksize;
		vec[nvec].iov_len = ap_snprintf(chunksize, sizeof(chunksize),
		"%x" CRLF, nbyte);
		++nvec;
		vec[nvec].iov_base = (void *)buf;
		vec[nvec].iov_len = nbyte;
		++nvec;
		vec[nvec].iov_base = ascii_CRLF;
		vec[nvec].iov_len = 2;
		++nvec;
	} else {
		vec[nvec].iov_base = (void *)buf;
		vec[nvec].iov_len = nbyte;
		++nvec;
	}

	fb->outcnt = 0;
	if (writev_it_all(fb, vec, nvec))
		return -1;
	else if (fb->flags & B_CHUNK)
		start_chunk(fb);

	return nbyte;
}


/*
 * Write nbyte bytes.
 * Only returns fewer than nbyte if an error ocurred.
 * Returns -1 if no bytes were written before the error ocurred.
 * It is worth noting that if an error occurs, the buffer is in an unknown
 * state.
 */
API_EXPORT(int)
ap_bwrite(BUFF *fb, const void *buf, int nbyte)
{
	int i, nwr, useable_bufsiz;

	if (fb->flags & (B_WRERR | B_EOUT))
		return -1;
	if (nbyte == 0)
		return 0;

	if (!(fb->flags & B_WR)) {
		/* unbuffered write -- have to use bcwrite since we aren't
		 * taking care of chunking any other way
		 */
		return bcwrite(fb, buf, nbyte);
	}

	/*
	 * Detect case where we're asked to write a large buffer, and combine our
	 * current buffer with it in a single writev().  Note we don't consider
	 * the case nbyte == 1 because modules which use rputc() loops will cause
	 * us to use writev() too frequently.  In those cases we really should just
	 * start a new buffer.
	 */
	if (fb->outcnt > 0 && nbyte > LARGE_WRITE_THRESHOLD
	     && nbyte + fb->outcnt >= fb->bufsiz)
		return large_write(fb, buf, nbyte);


	/*
	 * Whilst there is data in the buffer, keep on adding to it and
	 * writing it out
	 */
	nwr = 0;
	while (fb->outcnt > 0) {
		/* can we accept some data? */
		i = fb->bufsiz - fb->outcnt;
		if (i > 0) {
			if (i > nbyte)
				i = nbyte;
			memcpy(fb->outbase + fb->outcnt, buf, i);
			fb->outcnt += i;
			nbyte -= i;
			buf = i + (const char *)buf;
			nwr += i;
			if (nbyte == 0)
				return nwr;	/* return if none left */
		}

		/* the buffer must be full */
		if (fb->flags & B_CHUNK) {
			end_chunk(fb);
			/* it is just too painful to try to re-cram the buffer while
			* chunking
			*/
			if (write_it_all(fb, fb->outbase, fb->outcnt) == -1) {
				/* we cannot continue after a chunked error */
				return -1;
			}
			fb->outcnt = 0;
			break;
		}
		i = write_with_errors(fb, fb->outbase, fb->outcnt);
		if (i <= 0)
			return nwr ? nwr : -1;

		/* deal with a partial write */
		if (i < fb->outcnt) {
			int j, n = fb->outcnt;
			unsigned char *x = fb->outbase;
			for (j = i; j < n; j++)
			x[j - i] = x[j];
			fb->outcnt -= i;
		} else
			fb->outcnt = 0;

		if (fb->flags & B_EOUT)
		return -1;
	}
	/* we have emptied the file buffer. Now try to write the data from the
	 * original buffer until there is less than bufsiz left.  Note that we
	 * use bcwrite() to do this for us, it will do the chunking so that
	 * we don't have to dink around building a chunk in our own buffer.
	 *
	 * Note also that bcwrite never does a partial write if we're chunking,
	 * so we're guaranteed to either end in an error state, or make it
	 * out of this loop and call start_chunk() below.
	 *
	 * Remember we may not be able to use the entire buffer if we're
	 * chunking.
	 */
	useable_bufsiz = fb->bufsiz;
	if (fb->flags & B_CHUNK)
		useable_bufsiz -= CHUNK_HEADER_SIZE;
	while (nbyte >= useable_bufsiz) {
		i = bcwrite(fb, buf, nbyte);
		if (i <= 0)
			return nwr ? nwr : -1;

		buf = i + (const char *)buf;
		nwr += i;
		nbyte -= i;

		if (fb->flags & B_EOUT)
			return -1;
	}
	/* copy what's left to the file buffer */
	fb->outcnt = 0;
	if (fb->flags & B_CHUNK)
		start_chunk(fb);
	if (nbyte > 0)
		memcpy(fb->outbase + fb->outcnt, buf, nbyte);
	fb->outcnt += nbyte;
	nwr += nbyte;
	return nwr;
}


static int
bflush_core(BUFF *fb)
{
	int i;

	while (fb->outcnt > 0) {
		i = write_with_errors(fb, fb->outbase, fb->outcnt);
		if (i <= 0)
			return -1;

		/*
		 * We should have written all the data, but if the fd was in a
		 * strange (non-blocking) mode, then we might not have done so.
		 */
		if (i < fb->outcnt) {
			int j, n = fb->outcnt;
			unsigned char *x = fb->outbase;
			for (j = i; j < n; j++)
			x[j - i] = x[j];
		}
		fb->outcnt -= i;

		/* If a soft timeout occurs while flushing, the handler should
		 * have set the buffer flag B_EOUT.
		 */
		if (fb->flags & B_EOUT)
			return -1;
	}
	return 0;
}

/*
 * Flushes the buffered stream.
 * Returns 0 on success or -1 on error
 */
API_EXPORT(int)
ap_bflush(BUFF *fb)
{
	int ret;

	if ((fb->flags & (B_WRERR | B_EOUT | B_WR)) != B_WR)
		return -1;

	if (fb->flags & B_CHUNK)
		end_chunk(fb);

	ret = bflush_core(fb);

	if (ret == 0 && (fb->flags & B_CHUNK))
		start_chunk(fb);

	return ret;
}

/*
 * Flushes and closes the file, even if an error occurred.
 * Discards an data that was not read, or not written by bflush()
 * Sets the EOF flag to indicate no further data can be read,
 * and the EOUT flag to indicate no further data can be written.
 */
API_EXPORT(int)
ap_bclose(BUFF *fb)
{
	int rc1, rc2, rc3;

	if (fb->flags & B_WR)
		rc1 = ap_bflush(fb);
	else
		rc1 = 0;
	if (fb->flags & B_SOCKET) {
		rc2 = ap_pclosesocket(fb->pool, fb->fd);
		if (fb->fd_in != fb->fd)
			rc3 = ap_pclosesocket(fb->pool, fb->fd_in);
		else
			rc3 = 0;
	} else {
		rc2 = ap_pclosef(fb->pool, fb->fd);
		if (fb->fd_in != fb->fd)
			rc3 = ap_pclosef(fb->pool, fb->fd_in);
		else
			rc3 = 0;
	}

	fb->inptr = fb->inbase;
	fb->incnt = 0;
	fb->outcnt = 0;

	fb->flags |= B_EOF | B_EOUT;
	fb->fd = -1;
	fb->fd_in = -1;

	if (rc1 != 0)
		return rc1;
	else if (rc2 != 0)
		return rc2;
	else
		return rc3;
}

/*
 * returns the number of bytes written or -1 on error
 */
API_EXPORT(int)
ap_bputs(const char *x, BUFF *fb)
{
	int i, j = strlen(x);
	i = ap_bwrite(fb, x, j);
	if (i != j)
		return -1;
	else
		return j;
}

/*
 * returns the number of bytes written or -1 on error
 */
API_EXPORT_NONSTD(int)
ap_bvputs(BUFF *fb,...)
{
	int i, j, k;
	va_list v;
	const char *x;

	va_start(v, fb);
	for (k = 0;;) {
		x = va_arg(v, const char *);
		if (x == NULL)
			break;
		j = strlen(x);
		i = ap_bwrite(fb, x, j);
		if (i != j) {
			va_end(v);
			return -1;
		}
		k += i;
	}

	va_end(v);

	return k;
}

API_EXPORT(void)
ap_bonerror(BUFF *fb, void (*error) (BUFF *, int, void *), void *data)
{
	fb->error = error;
	fb->error_data = data;
}

struct bprintf_data {
    ap_vformatter_buff	 vbuff;
    BUFF		*fb;
};

static int
bprintf_flush(ap_vformatter_buff *vbuff)
{
	struct bprintf_data *b = (struct bprintf_data *)vbuff;
	BUFF *fb = b->fb;

	fb->outcnt += b->vbuff.curpos - (char *)&fb->outbase[fb->outcnt];
	if (fb->outcnt == fb->bufsiz)
		if (ap_bflush(fb))
			return -1;

	vbuff->curpos = (char *)&fb->outbase[fb->outcnt];
	vbuff->endpos = (char *)&fb->outbase[fb->bufsiz];
	return 0;
}

API_EXPORT_NONSTD(int)
ap_bprintf(BUFF *fb, const char *fmt, ...)
{
	va_list ap;
	int res;
	struct bprintf_data b;

	/* XXX: only works with buffered writes */
	if ((fb->flags & (B_WRERR | B_EOUT | B_WR)) != B_WR)
		return -1;
	b.vbuff.curpos = (char *)&fb->outbase[fb->outcnt];
	b.vbuff.endpos = (char *)&fb->outbase[fb->bufsiz];
	b.fb = fb;
	va_start(ap, fmt);
	res = ap_vformatter(bprintf_flush, &b.vbuff, fmt, ap);
	va_end(ap);
	if (res != -1)
		fb->outcnt += b.vbuff.curpos - (char *)&fb->outbase[fb->outcnt];
	return res;
}

API_EXPORT(int) 
ap_vbprintf(BUFF *fb, const char *fmt, va_list ap)
{
	struct bprintf_data b;
	int res;

	/* XXX: only works with buffered writes */
	if ((fb->flags & (B_WRERR | B_EOUT | B_WR)) != B_WR)
		return -1;
	b.vbuff.curpos = (char *)&fb->outbase[fb->outcnt];
	b.vbuff.endpos = (char *)&fb->outbase[fb->bufsiz];
	b.fb = fb;
	res = ap_vformatter(bprintf_flush, &b.vbuff, fmt, ap);
	if (res != -1)
		fb->outcnt += b.vbuff.curpos - (char *)&fb->outbase[fb->outcnt];
	return res;
}
 
@


1.21
log
@fix some fallout from the >2G commit. namely allow for all byte counters to
report the correct size when it exceeds a long's capacity.

From Dan Harnett <daniel @@ harnett . name>
@
text
@d1 1
a1 1
/*	$OpenBSD: buff.c,v 1.20 2008/05/15 06:05:43 mbalmer Exp $ */
@


1.20
log
@Add OpenBSD markers.

no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d212 1
a212 1
	fb->bytes_sent = 0L;
d239 2
a240 2
		fb->bytes_sent = *(const long int *)optval -
		    (long int)fb->outcnt;
d253 4
a256 4
		long int bs = fb->bytes_sent + fb->outcnt;
		if (bs < 0L)
			bs = 0L;
		*(long int *)optval = bs;
@


1.19
log
@A first chunk of readability/knf changes.  Since there is nothing more
to merge from upstream, we can safely sanitize the code and hopefully
the build system.

Discussed with and feedback from sthen, todd, dlg and henning.

no binary changes.
@
text
@d1 2
@


1.18
log
@[fF]uther -> [fF]urther in comments and man page. First one spotted on
tech@@ by Jung.
@
text
@d81 2
a82 1
#define ascii_CRLF "\015\012" /* A CRLF which won't pass the conversion machinery */
d122 2
a123 1
static int ap_read(BUFF *fb, void *buf, int nbyte)
d125 2
a126 2
    int rv;
    
d128 3
a130 3
	rv = read(fb->fd_in, buf, nbyte);
    
    return rv;
d133 2
a134 1
static ap_inline int buff_read(BUFF *fb, void *buf, int nbyte)
d136 1
a136 1
    int rv;
d138 2
a139 2
    rv = ap_read(fb, buf, nbyte);
    return rv;
d143 2
a144 1
static int ap_write(BUFF *fb, const void *buf, int nbyte)
d146 2
a147 2
    int rv;
    
d149 2
a150 2
	rv = write(fb->fd, buf, nbyte);
    return rv;
d153 2
a154 1
static ap_inline int buff_write(BUFF *fb, const void *buf, int nbyte)
d156 1
a156 1
    int rv;
d158 5
a162 6
    if (fb->filter_callback != NULL) {
        fb->filter_callback(fb, buf, nbyte);
    }
   
    rv = ap_write(fb, buf, nbyte);
    return rv;
d165 2
a166 1
static void doerror(BUFF *fb, int direction)
d168 1
a168 1
    int errsave = errno;	/* Save errno to prevent overwriting it below */
d170 3
a172 3
    fb->flags |= (direction == B_RD ? B_RDERR : B_WRERR);
    if (fb->error != NULL)
	(*fb->error) (fb, direction, fb->error_data);
d174 1
a174 1
    errno = errsave;
d181 2
a182 1
API_EXPORT(BUFF *) ap_bcreate(pool *p, int flags)
d184 1
a184 1
    BUFF *fb;
d186 4
a189 4
    fb = ap_palloc(p, sizeof(BUFF));
    fb->pool = p;
    fb->bufsiz = DEFAULT_BUFSIZE;
    fb->flags = flags & (B_RDWR | B_SOCKET);
d191 4
a194 4
    if (flags & B_RD)
	fb->inbase = ap_palloc(p, fb->bufsiz);
    else
	fb->inbase = NULL;
d196 7
a202 6
    /* overallocate so that we can put a chunk trailer of CRLF into this
     * buffer */
    if (flags & B_WR)
	fb->outbase = ap_palloc(p, fb->bufsiz + 2);
    else
	fb->outbase = NULL;
d204 1
a204 1
    fb->inptr = fb->inbase;
d206 5
a210 5
    fb->incnt = 0;
    fb->outcnt = 0;
    fb->outchunk = -1;
    fb->error = NULL;
    fb->bytes_sent = 0L;
d212 2
a213 2
    fb->fd = -1;
    fb->fd_in = -1;
d215 2
a216 2
    fb->callback_data = NULL;
    fb->filter_callback = NULL;
d218 1
a218 1
    fb->ctx = ap_ctx_new(p);
d220 1
a220 1
    return fb;
d226 2
a227 1
API_EXPORT(void) ap_bpushfd(BUFF *fb, int fd_in, int fd_out)
d229 2
a230 2
    fb->fd = fd_out;
    fb->fd_in = fd_in;
d233 2
a234 1
API_EXPORT(int) ap_bsetopt(BUFF *fb, int optname, const void *optval)
d236 9
a244 8
    if (optname == BO_BYTECT) {
	fb->bytes_sent = *(const long int *) optval - (long int) fb->outcnt;
	return 0;
    }
    else {
	errno = EINVAL;
	return -1;
    }
d247 14
a260 13
API_EXPORT(int) ap_bgetopt(BUFF *fb, int optname, void *optval)
{
    if (optname == BO_BYTECT) {
	long int bs = fb->bytes_sent + fb->outcnt;
	if (bs < 0L)
	    bs = 0L;
	*(long int *) optval = bs;
	return 0;
    }
    else {
	errno = EINVAL;
	return -1;
    }
d274 2
a275 1
static void start_chunk(BUFF *fb)
d277 18
a294 18
    if (fb->outchunk != -1) {
	/* already chunking */
	return;
    }
    if ((fb->flags & (B_WRERR | B_EOUT | B_WR)) != B_WR) {
	/* unbuffered writes */
	return;
    }

    /* we need at least the header_len + at least 1 data byte
     * remember that we've overallocated fb->outbase so that we can always
     * fit the two byte CRLF trailer
     */
    if (fb->bufsiz - fb->outcnt < CHUNK_HEADER_SIZE + 1) {
	bflush_core(fb);
    }
    fb->outchunk = fb->outcnt;
    fb->outcnt += CHUNK_HEADER_SIZE;
d301 2
a302 1
static void end_chunk(BUFF *fb)
d304 2
a305 2
    int i;
    unsigned char *strp;
d307 22
a328 8
    if (fb->outchunk == -1) {
	/* not chunking */
	return;
    }

    if (fb->outchunk + CHUNK_HEADER_SIZE == fb->outcnt) {
	/* nothing was written into this chunk, and we can't write a 0 size
	 * chunk because that signifies EOF, so just erase it
d330 7
a336 4
	fb->outcnt = fb->outchunk;
	fb->outchunk = -1;
	return;
    }
d338 3
a340 20
    /* we know this will fit because of how we wrote it in start_chunk() */
    i = ap_snprintf((char *) &fb->outbase[fb->outchunk], CHUNK_HEADER_SIZE,
		"%x", fb->outcnt - fb->outchunk - CHUNK_HEADER_SIZE);

    /* we may have to tack some trailing spaces onto the number we just wrote
     * in case it was smaller than our estimated size.  We've also written
     * a \0 into the buffer with ap_snprintf so we might have to put a
     * \r back in.
     */
    strp = &fb->outbase[fb->outchunk + i];
    while (i < CHUNK_HEADER_SIZE - 2) {
	*strp++ = ' ';
	++i;
    }
    *strp++ = CR;
    *strp = LF;

    /* tack on the trailing CRLF, we've reserved room for this */
    fb->outbase[fb->outcnt++] = CR;
    fb->outbase[fb->outcnt++] = LF;
d342 1
a342 1
    fb->outchunk = -1;
d349 2
a350 1
API_EXPORT(int) ap_bsetflag(BUFF *fb, int flag, int value)
d352 8
a359 10
    if (value) {
	fb->flags |= flag;
	if (flag & B_CHUNK) {
	    start_chunk(fb);
	}
    }
    else {
	fb->flags &= ~flag;
	if (flag & B_CHUNK) {
	    end_chunk(fb);
d361 1
a361 2
    }
    return value;
d365 2
a366 1
API_EXPORT(int) ap_bnonblock(BUFF *fb, int direction)
d368 1
a368 1
    int fd;
d370 2
a371 2
    fd = (direction == B_RD) ? fb->fd_in : fb->fd;
    return fcntl(fd, F_SETFL, O_NONBLOCK);
d374 2
a375 1
API_EXPORT(int) ap_bfileno(BUFF *fb, int direction)
d377 1
a377 1
    return (direction == B_RD) ? fb->fd_in : fb->fd;
d394 2
a395 1
API_EXPORT(void) ap_bhalfduplex(BUFF *fb)
d397 37
a433 37
    int rv;
    fd_set fds;
    struct timeval tv;

    /* We don't need to do anything if the connection has been closed
     * or there is something readable in the incoming buffer
     * or there is nothing flushable in the output buffer.
     */
    if (fb == NULL || fb->fd_in < 0 || fb->incnt > 0 || fb->outcnt == 0) {
	return;
    }
    /* test for a block */
    do {
	FD_ZERO(&fds);
	FD_SET(fb->fd_in, &fds);
	tv.tv_sec = 0;
	tv.tv_usec = 0;
	rv = ap_select(fb->fd_in + 1, &fds, NULL, NULL, &tv);
    } while (rv < 0 && errno == EINTR && !(fb->flags & B_EOUT));

    /* treat any error as if it would block as well */
    if (rv != 1) {
	ap_bflush(fb);
    }
}

static ap_inline int saferead_guts(BUFF *fb, void *buf, int nbyte)
{
    int rv;

    if (fb->flags & B_SAFEREAD) {
	ap_bhalfduplex(fb);
    }
    do {
	rv = buff_read(fb, buf, nbyte);
    } while (rv == -1 && errno == EINTR && !(fb->flags & B_EOUT));
    return (rv);
d442 2
a443 1
static int read_with_errors(BUFF *fb, void *buf, int nbyte)
d445 1
a445 1
    int rv;
d447 6
a452 8
    rv = saferead(fb, buf, nbyte);
    if (rv == 0) {
	fb->flags |= B_EOF;
    }
    else if (rv == -1 && errno != EAGAIN) {
	doerror(fb, B_RD);
    }
    return rv;
d464 2
a465 1
API_EXPORT(int) ap_bread(BUFF *fb, void *buf, int nbyte)
d467 1
a467 1
    int i, nrd;
d469 4
a472 4
    if (fb->flags & B_RDERR)
	return -1;
    if (nbyte == 0)
	return 0;
d474 31
a504 22
    if (!(fb->flags & B_RD)) {
	/* Unbuffered reading.  First check if there was something in the
	 * buffer from before we went unbuffered. */
	if (fb->incnt) {
	    i = (fb->incnt > nbyte) ? nbyte : fb->incnt;
	    memcpy(buf, fb->inptr, i);
	    fb->incnt -= i;
	    fb->inptr += i;
	    return i;
	}
	i = read_with_errors(fb, buf, nbyte);
	return i;
    }

    nrd = fb->incnt;
/* can we fill the buffer */
    if (nrd >= nbyte) {
	memcpy(buf, fb->inptr, nbyte);
	fb->incnt = nrd - nbyte;
	fb->inptr += nbyte;
	return nbyte;
    }
d506 21
a526 32
    if (nrd > 0) {
	memcpy(buf, fb->inptr, nrd);
	nbyte -= nrd;
	buf = nrd + (char *) buf;
	fb->incnt = 0;
    }
    if (fb->flags & B_EOF)
	return nrd;

/* do a single read */
    if (nbyte >= fb->bufsiz) {
/* read directly into caller's buffer */
	i = read_with_errors(fb, buf, nbyte);
	if (i == -1) {
	    return nrd ? nrd : -1;
	}
    }
    else {
/* read into hold buffer, then memcpy */
	fb->inptr = fb->inbase;
	i = read_with_errors(fb, fb->inptr, fb->bufsiz);
	if (i == -1) {
	    return nrd ? nrd : -1;
	}
	fb->incnt = i;
	if (i > nbyte)
	    i = nbyte;
	memcpy(buf, fb->inptr, i);
	fb->incnt -= i;
	fb->inptr += i;
    }
    return nrd + i;
d548 2
a549 1
API_EXPORT(int) ap_bgets(char *buff, int n, BUFF *fb)
d551 9
a559 1
    int i, ch, ct;
d561 38
a598 51
/* Can't do bgets on an unbuffered stream */
    if (!(fb->flags & B_RD)) {
	errno = EINVAL;
	return -1;
    }
    if (fb->flags & B_RDERR)
	return -1;

    ct = 0;
    i = 0;
    for (;;) {
	if (i == fb->incnt) {
/* no characters left */
	    fb->inptr = fb->inbase;
	    fb->incnt = 0;
	    if (fb->flags & B_EOF)
		break;
	    i = read_with_errors(fb, fb->inptr, fb->bufsiz);
	    if (i == -1) {
		buff[ct] = '\0';
		return ct ? ct : -1;
	    }
	    fb->incnt = i;
	    if (i == 0)
		break;		/* EOF */
	    i = 0;
	    continue;		/* restart with the new data */
	}

	ch = fb->inptr[i++];
	if (ch == LF) {  /* got LF */
	    if (ct == 0)
		buff[ct++] = '\n';
/* if just preceded by CR, replace CR with LF */
	    else if (buff[ct - 1] == CR)
		buff[ct - 1] = '\n';
	    else if (ct < n - 1)
		buff[ct++] = '\n';
	    else
		i--;		/* no room for LF */
	    break;
	}
	if (ct == n - 1) {
	    i--;		/* push back ch */
	    break;
	}

	buff[ct++] = ch;
    }
    fb->incnt -= i;
    fb->inptr += i;
d600 7
a606 2
    buff[ct] = '\0';
    return ct;
d616 2
a617 1
API_EXPORT(int) ap_blookc(char *buff, BUFF *fb)
d619 1
a619 1
    int i;
d621 1
a621 1
    *buff = '\0';
d623 7
a629 6
    if (!(fb->flags & B_RD)) {	/* Can't do blookc on an unbuffered stream */
	errno = EINVAL;
	return -1;
    }
    if (fb->flags & B_RDERR)
	return -1;
d631 9
a639 8
    if (fb->incnt == 0) {	/* no characters left in stream buffer */
	fb->inptr = fb->inbase;
	if (fb->flags & B_EOF)
	    return 0;

	i = read_with_errors(fb, fb->inptr, fb->bufsiz);
	if (i <= 0) {
	    return i;
a640 2
	fb->incnt = i;
    }
d642 2
a643 2
    *buff = fb->inptr[0];
    return 1;
d650 2
a651 1
API_EXPORT(int) ap_bskiplf(BUFF *fb)
d653 2
a654 2
    unsigned char *x;
    int i;
d656 4
a659 15
/* Can't do bskiplf on an unbuffered stream */
    if (!(fb->flags & B_RD)) {
	errno = EINVAL;
	return -1;
    }
    if (fb->flags & B_RDERR)
	return -1;

    for (;;) {
	x = (unsigned char *) memchr(fb->inptr, '\012', fb->incnt);
	if (x != NULL) {
	    x++;
	    fb->incnt -= x - fb->inptr;
	    fb->inptr = x;
	    return 1;
d661 2
d664 18
a681 9
	fb->inptr = fb->inbase;
	fb->incnt = 0;
	if (fb->flags & B_EOF)
	    return 0;
	i = read_with_errors(fb, fb->inptr, fb->bufsiz);
	if (i <= 0)
	    return i;
	fb->incnt = i;
    }
d688 2
a689 1
API_EXPORT(int) ap_bflsbuf(int c, BUFF *fb)
d691 1
a691 1
    char ss[1];
d693 2
a694 2
    ss[0] = c;
    return ap_bwrite(fb, ss, 1);
d700 2
a701 1
API_EXPORT(int) ap_bfilbuf(BUFF *fb)
d703 2
a704 2
    int i;
    char buf[1];
d706 7
a712 7
    i = ap_bread(fb, buf, 1);
    if (i == 0)
	errno = 0;		/* no error; EOF */
    if (i != 1)
	return EOF;
    else
	return buf[0];
d725 2
a726 1
static int write_it_all(BUFF *fb, const void *buf, int nbyte)
d728 1
a728 1
    int i;
d730 2
a731 2
    if (fb->flags & (B_WRERR | B_EOUT))
	return -1;
d733 15
a747 7
    while (nbyte > 0) {
	i = buff_write(fb, buf, nbyte);
	if (i < 0) {
	    if (errno != EAGAIN && errno != EINTR) {
		doerror(fb, B_WR);
		return -1;
	    }
d749 1
a749 9
	else {
	    nbyte -= i;
	    buf = i + (const char *) buf;
	    fb->bytes_sent += i;
	}
	if (fb->flags & B_EOUT)
	    return -1;
    }
    return 0;
d758 2
a759 1
static int writev_it_all(BUFF *fb, struct iovec *vec, int nvec)
d761 6
a766 23
    int i, rv;
    
    if (fb->filter_callback != NULL) {
        for (i = 0; i < nvec; i++) {
            fb->filter_callback(fb, vec[i].iov_base, vec[i].iov_len);
        }
    }

    /* while it's nice an easy to build the vector and crud, it's painful
     * to deal with a partial writev()
     */
    i = 0;
    while (i < nvec) {
	do
	    if (!ap_hook_call("ap::buff::writev", &rv, fb, &vec[i], nvec -i))
	    rv = writev(fb->fd, &vec[i], nvec - i);
	while (rv == -1 && (errno == EINTR || errno == EAGAIN)
	       && !(fb->flags & B_EOUT));
	if (rv == -1) {
	    if (errno != EINTR && errno != EAGAIN) {
		doerror(fb, B_WR);
	    }
	    return -1;
d768 32
a799 12
	fb->bytes_sent += rv;
	/* recalculate vec to deal with partial writes */
	while (rv > 0) {
	    if (rv < vec[i].iov_len) {
		vec[i].iov_base = (char *) vec[i].iov_base + rv;
		vec[i].iov_len -= rv;
		rv = 0;
	    }
	    else {
		rv -= vec[i].iov_len;
		++i;
	    }
d801 2
a802 5
	if (fb->flags & B_EOUT)
	    return -1;
    }
    /* if we got here, we wrote it all */
    return 0;
d808 2
a809 1
static int write_with_errors(BUFF *fb, const void *buf, int nbyte)
d811 1
a811 1
    int rv;
d813 13
a825 15
    do
	rv = buff_write(fb, buf, nbyte);
    while (rv == -1 && errno == EINTR && !(fb->flags & B_EOUT));
    if (rv == -1) {
	if (errno != EAGAIN) {
	    doerror(fb, B_WR);
	}
	return -1;
    }
    else if (rv == 0) {
	errno = EAGAIN;
	return -1;
    }
    fb->bytes_sent += rv;
    return rv;
d838 2
a839 1
static int bcwrite(BUFF *fb, const void *buf, int nbyte)
d841 5
a845 2
    char chunksize[16];		/* Big enough for practically anything */
    struct iovec vec[3];
d847 2
a848 2
    if (fb->flags & (B_WRERR | B_EOUT))
	return -1;
d850 7
a856 11
    if (!(fb->flags & B_CHUNK)) {
	return write_with_errors(fb, buf, nbyte);
    }

    vec[0].iov_base = chunksize;
    vec[0].iov_len = ap_snprintf(chunksize, sizeof(chunksize), "%x" CRLF,
				 nbyte);
    vec[1].iov_base = (void *) buf;	/* cast is to avoid const warning */
    vec[1].iov_len = nbyte;
    vec[2].iov_base = ascii_CRLF;
    vec[2].iov_len = 2;
d858 2
a859 1
    return writev_it_all(fb, vec, (sizeof(vec) / sizeof(vec[0]))) ? -1 : nbyte;
d867 2
a868 1
static int large_write(BUFF *fb, const void *buf, int nbyte)
d870 38
a907 40
    struct iovec vec[4];
    int nvec;
    char chunksize[16];

    /* it's easiest to end the current chunk */
    if (fb->flags & B_CHUNK) {
	end_chunk(fb);
    }
    nvec = 0;
    if (fb->outcnt > 0) {
	vec[nvec].iov_base = (void *) fb->outbase;
	vec[nvec].iov_len = fb->outcnt;
	++nvec;
    }
    if (fb->flags & B_CHUNK) {
	vec[nvec].iov_base = chunksize;
	vec[nvec].iov_len = ap_snprintf(chunksize, sizeof(chunksize),
					"%x" CRLF, nbyte);
	++nvec;
	vec[nvec].iov_base = (void *) buf;
	vec[nvec].iov_len = nbyte;
	++nvec;
	vec[nvec].iov_base = ascii_CRLF;
	vec[nvec].iov_len = 2;
	++nvec;
    }
    else {
	vec[nvec].iov_base = (void *) buf;
	vec[nvec].iov_len = nbyte;
	++nvec;
    }

    fb->outcnt = 0;
    if (writev_it_all(fb, vec, nvec)) {
	return -1;
    }
    else if (fb->flags & B_CHUNK) {
	start_chunk(fb);
    }
    return nbyte;
d918 2
a919 1
API_EXPORT(int) ap_bwrite(BUFF *fb, const void *buf, int nbyte)
d921 1
a921 1
    int i, nwr, useable_bufsiz;
d923 4
a926 4
    if (fb->flags & (B_WRERR | B_EOUT))
	return -1;
    if (nbyte == 0)
	return 0;
d928 5
a932 36
    if (!(fb->flags & B_WR)) {
/* unbuffered write -- have to use bcwrite since we aren't taking care
 * of chunking any other way */
	return bcwrite(fb, buf, nbyte);
    }

/*
 * Detect case where we're asked to write a large buffer, and combine our
 * current buffer with it in a single writev().  Note we don't consider
 * the case nbyte == 1 because modules which use rputc() loops will cause
 * us to use writev() too frequently.  In those cases we really should just
 * start a new buffer.
 */
    if (fb->outcnt > 0 && nbyte > LARGE_WRITE_THRESHOLD
	&& nbyte + fb->outcnt >= fb->bufsiz) {
	return large_write(fb, buf, nbyte);
    }

/*
 * Whilst there is data in the buffer, keep on adding to it and writing it
 * out
 */
    nwr = 0;
    while (fb->outcnt > 0) {
/* can we accept some data? */
	i = fb->bufsiz - fb->outcnt;
	if (i > 0) {
	    if (i > nbyte)
		i = nbyte;
	    memcpy(fb->outbase + fb->outcnt, buf, i);
	    fb->outcnt += i;
	    nbyte -= i;
	    buf = i + (const char *) buf;
	    nwr += i;
	    if (nbyte == 0)
		return nwr;	/* return if none left */
d935 10
a944 70
/* the buffer must be full */
	if (fb->flags & B_CHUNK) {
	    end_chunk(fb);
	    /* it is just too painful to try to re-cram the buffer while
	     * chunking
	     */
	    if (write_it_all(fb, fb->outbase, fb->outcnt) == -1) {
		/* we cannot continue after a chunked error */
		return -1;
	    }
	    fb->outcnt = 0;
	    break;
	}
	i = write_with_errors(fb, fb->outbase, fb->outcnt);
	if (i <= 0) {
	    return nwr ? nwr : -1;
	}

	/* deal with a partial write */
	if (i < fb->outcnt) {
	    int j, n = fb->outcnt;
	    unsigned char *x = fb->outbase;
	    for (j = i; j < n; j++)
		x[j - i] = x[j];
	    fb->outcnt -= i;
	}
	else
	    fb->outcnt = 0;

	if (fb->flags & B_EOUT)
	    return -1;
    }
/* we have emptied the file buffer. Now try to write the data from the
 * original buffer until there is less than bufsiz left.  Note that we
 * use bcwrite() to do this for us, it will do the chunking so that
 * we don't have to dink around building a chunk in our own buffer.
 *
 * Note also that bcwrite never does a partial write if we're chunking,
 * so we're guaranteed to either end in an error state, or make it
 * out of this loop and call start_chunk() below.
 *
 * Remember we may not be able to use the entire buffer if we're
 * chunking.
 */
    useable_bufsiz = fb->bufsiz;
    if (fb->flags & B_CHUNK) useable_bufsiz -= CHUNK_HEADER_SIZE;
    while (nbyte >= useable_bufsiz) {
	i = bcwrite(fb, buf, nbyte);
	if (i <= 0) {
	    return nwr ? nwr : -1;
	}

	buf = i + (const char *) buf;
	nwr += i;
	nbyte -= i;

	if (fb->flags & B_EOUT)
	    return -1;
    }
/* copy what's left to the file buffer */
    fb->outcnt = 0;
    if (fb->flags & B_CHUNK)
	start_chunk(fb);
    if (nbyte > 0)
	memcpy(fb->outbase + fb->outcnt, buf, nbyte);
    fb->outcnt += nbyte;
    nwr += nbyte;
    return nwr;
}

a945 8
static int bflush_core(BUFF *fb)
{
    int i;

    while (fb->outcnt > 0) {
	i = write_with_errors(fb, fb->outbase, fb->outcnt);
	if (i <= 0)
	    return -1;
d948 2
a949 2
	 * We should have written all the data, but if the fd was in a
	 * strange (non-blocking) mode, then we might not have done so.
d951 45
a995 5
	if (i < fb->outcnt) {
	    int j, n = fb->outcnt;
	    unsigned char *x = fb->outbase;
	    for (j = i; j < n; j++)
		x[j - i] = x[j];
d997 37
a1033 1
	fb->outcnt -= i;
a1034 6
	/* If a soft timeout occurs while flushing, the handler should
	 * have set the buffer flag B_EOUT.
	 */
	if (fb->flags & B_EOUT)
	    return -1;
    }
d1036 29
a1064 1
    return 0;
d1071 2
a1072 1
API_EXPORT(int) ap_bflush(BUFF *fb)
d1074 1
a1074 1
    int ret;
d1076 2
a1077 2
    if ((fb->flags & (B_WRERR | B_EOUT | B_WR)) != B_WR)
	return -1;
d1079 2
a1080 2
    if (fb->flags & B_CHUNK)
	end_chunk(fb);
d1082 1
a1082 1
    ret = bflush_core(fb);
d1084 2
a1085 3
    if (ret == 0 && (fb->flags & B_CHUNK)) {
	start_chunk(fb);
    }
d1087 1
a1087 1
    return ret;
d1096 2
a1097 1
API_EXPORT(int) ap_bclose(BUFF *fb)
d1099 1
a1099 1
    int rc1, rc2, rc3;
d1101 16
a1116 8
    if (fb->flags & B_WR)
	rc1 = ap_bflush(fb);
    else
	rc1 = 0;
    if (fb->flags & B_SOCKET) {
	rc2 = ap_pclosesocket(fb->pool, fb->fd);
	if (fb->fd_in != fb->fd) {
	    rc3 = ap_pclosesocket(fb->pool, fb->fd_in);
a1117 12
	else {
	    rc3 = 0;
	}
    } else {
	rc2 = ap_pclosef(fb->pool, fb->fd);
	if (fb->fd_in != fb->fd) {
	    rc3 = ap_pclosef(fb->pool, fb->fd_in);
	}
	else {
	    rc3 = 0;
	}
    }
d1119 14
a1132 14
    fb->inptr = fb->inbase;
    fb->incnt = 0;
    fb->outcnt = 0;

    fb->flags |= B_EOF | B_EOUT;
    fb->fd = -1;
    fb->fd_in = -1;

    if (rc1 != 0)
	return rc1;
    else if (rc2 != 0)
	return rc2;
    else
	return rc3;
d1138 2
a1139 1
API_EXPORT(int) ap_bputs(const char *x, BUFF *fb)
d1141 6
a1146 6
    int i, j = strlen(x);
    i = ap_bwrite(fb, x, j);
    if (i != j)
	return -1;
    else
	return j;
d1152 2
a1153 1
API_EXPORT_NONSTD(int) ap_bvputs(BUFF *fb,...)
d1155 16
a1170 14
    int i, j, k;
    va_list v;
    const char *x;

    va_start(v, fb);
    for (k = 0;;) {
	x = va_arg(v, const char *);
	if (x == NULL)
	    break;
	j = strlen(x);
	i = ap_bwrite(fb, x, j);
	if (i != j) {
	    va_end(v);
	    return -1;
a1171 2
	k += i;
    }
d1173 1
a1173 1
    va_end(v);
d1175 1
a1175 1
    return k;
d1178 2
a1179 2
API_EXPORT(void) ap_bonerror(BUFF *fb, void (*error) (BUFF *, int, void *),
			  void *data)
d1181 2
a1182 2
    fb->error = error;
    fb->error_data = data;
d1186 2
a1187 2
    ap_vformatter_buff vbuff;
    BUFF *fb;
d1190 2
a1191 1
static int bprintf_flush(ap_vformatter_buff *vbuff)
d1193 12
a1204 2
    struct bprintf_data *b = (struct bprintf_data *)vbuff;
    BUFF *fb = b->fb;
d1206 37
a1242 48
    fb->outcnt += b->vbuff.curpos - (char *)&fb->outbase[fb->outcnt];
    if (fb->outcnt == fb->bufsiz) {
	if (ap_bflush(fb)) {
	    return -1;
	}
    }
    vbuff->curpos = (char *)&fb->outbase[fb->outcnt];
    vbuff->endpos = (char *)&fb->outbase[fb->bufsiz];
    return 0;
}

API_EXPORT_NONSTD(int) ap_bprintf(BUFF *fb, const char *fmt, ...)
{
    va_list ap;
    int res;
    struct bprintf_data b;

    /* XXX: only works with buffered writes */
    if ((fb->flags & (B_WRERR | B_EOUT | B_WR)) != B_WR)
	return -1;
    b.vbuff.curpos = (char *)&fb->outbase[fb->outcnt];
    b.vbuff.endpos = (char *)&fb->outbase[fb->bufsiz];
    b.fb = fb;
    va_start(ap, fmt);
    res = ap_vformatter(bprintf_flush, &b.vbuff, fmt, ap);
    va_end(ap);
    if (res != -1) {
	fb->outcnt += b.vbuff.curpos - (char *)&fb->outbase[fb->outcnt];
    }
    return res;
}

API_EXPORT(int) ap_vbprintf(BUFF *fb, const char *fmt, va_list ap)
{
    struct bprintf_data b;
    int res;

    /* XXX: only works with buffered writes */
    if ((fb->flags & (B_WRERR | B_EOUT | B_WR)) != B_WR)
	return -1;
    b.vbuff.curpos = (char *)&fb->outbase[fb->outcnt];
    b.vbuff.endpos = (char *)&fb->outbase[fb->bufsiz];
    b.fb = fb;
    res = ap_vformatter(bprintf_flush, &b.vbuff, fmt, ap);
    if (res != -1) {
	fb->outcnt += b.vbuff.curpos - (char *)&fb->outbase[fb->outcnt];
    }
    return res;
@


1.17
log
@Spelling.

'preceeding' -> 'preceding'
'preceeds' -> 'precedes'
'preceeded' -> 'preceded'
@
text
@d116 1
a116 1
 * futher I/O will be done
d1075 1
a1075 1
 * Sets the EOF flag to indicate no futher data can be read,
@


1.16
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d573 1
a573 1
/* if just preceeded by CR, replace CR with LF */
@


1.15
log
@kill more dead code, mostly inside #ifdef SOMENONSENSEONSTUPIDOSES
joint work by Michael Knudsen <e@@molioner.dk> and Daniel Ouellet
<daniel@@presscom.net> with my input
no change in binaries
@
text
@a144 3
#if defined (B_SFIO)
	rv = sfwrite(fb->sf_out, buf, nbyte);
#else
a145 2
#endif
    
a207 9
#ifdef B_SFIO
    fb->sf_in = NULL;
    fb->sf_out = NULL;
    fb->sf_in = sfnew(fb->sf_in, NIL(Void_t *),
		      (size_t) SF_UNBOUND, 0, SF_READ);
    fb->sf_out = sfnew(fb->sf_out, NIL(Void_t *),
		       (size_t) SF_UNBOUND, 1, SF_WRITE);
#endif

a358 1
#if defined(O_NONBLOCK)
a359 8
#elif defined(O_NDELAY)
    return fcntl(fd, F_SETFL, O_NDELAY);
#elif defined(FNDELAY)
    return fcntl(fd, F_SETFL, FNDELAY);
#else
    /* XXXX: this breaks things, but an alternative isn't obvious...*/
    return 0;
#endif
a373 2

#if !defined (B_SFIO) || defined (WIN32)
a374 7
#else
static int saferead(BUFF *fb, char *buf, int nbyte)
{
    return sfread(fb->sf_in, buf, nbyte);
}
#endif

a421 36
#ifdef B_SFIO
int bsfio_read(Sfio_t * f, char *buf, int nbyte, apache_sfio *disc)
{
    int rv;
    BUFF *fb = disc->buff;

    rv = saferead_guts(fb, buf, nbyte);

    buf[rv] = '\0';
    f->next = 0;

    return (rv);
}

int bsfio_write(Sfio_t * f, char *buf, int nbyte, apache_sfio *disc)
{
    return ap_write(disc->buff, buf, nbyte);
}

Sfdisc_t *bsfio_new(pool *p, BUFF *b)
{
    apache_sfio *disc;

    if (!(disc = (apache_sfio *) ap_palloc(p, sizeof(apache_sfio))))
	            return (Sfdisc_t *) disc;

    disc->disc.readf = (Sfread_f) bsfio_read;
    disc->disc.writef = (Sfwrite_f) bsfio_write;
    disc->disc.seekf = (Sfseek_f) NULL;
    disc->disc.exceptf = (Sfexcept_f) NULL;
    disc->buff = b;

    return (Sfdisc_t *) disc;
}
#endif

a1110 5

#ifdef B_SFIO
    sfclose(fb->sf_in);
    sfclose(fb->sf_out);
#endif
@


1.14
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@a67 1
#ifndef NO_WRITEV
a69 5
#endif

#ifdef HAVE_BSTRING_H
#include <bstring.h>		/* for IRIX, FD_SET calls bzero() */
#endif
a124 1
#ifdef EAPI
a125 1
#endif /* EAPI */
a143 1
#ifdef EAPI
a144 1
#endif /* EAPI */
a224 1
#ifdef EAPI
a225 1
#endif /* EAPI */
a802 1
#ifndef NO_WRITEV
a823 1
#ifdef EAPI
a824 1
#endif /* EAPI */
a852 1
#endif
a890 1
#ifndef NO_WRITEV
a891 1
#endif
a899 12
#ifdef NO_WRITEV
    /* without writev() this has poor performance, too bad */

    ap_snprintf(chunksize, sizeof(chunksize), "%x" CRLF, nbyte);
    if (write_it_all(fb, chunksize, strlen(chunksize)) == -1)
	return -1;
    if (write_it_all(fb, buf, nbyte) == -1)
	return -1;
    if (write_it_all(fb, ascii_CRLF, 2) == -1)
	return -1;
    return nbyte;
#else
a908 1
#endif
a911 1
#ifndef NO_WRITEV
a958 1
#endif
a982 1
#ifndef NO_WRITEV
a993 1
#endif
@


1.13
log
@merge apache 1.3.29 and mod_ssl 2.8.16
ok brad@@
@
text
@a124 156
#if defined(WIN32) || defined(NETWARE) || defined(CYGWIN_WINSOCK) 

/*
  select() sometimes returns 1 even though the write will block. We must work around this.
*/

API_EXPORT(int) ap_sendwithtimeout(int sock, const char *buf, int len, int flags)
{
    int iostate = 1;
    fd_set fdset;
    struct timeval tv;
    int err = WSAEWOULDBLOCK;
    int rv;
    int retry;

    tv.tv_sec = ap_check_alarm();

    /* If ap_sendwithtimeout is called with an invalid timeout
     * set a default timeout of 300 seconds. This hack is needed
     * to emulate the non-blocking send() that was removed in 
     * the previous patch to this function. Network servers
     * should never make network i/o calls w/o setting a timeout.
     * (doing otherwise opens a DoS attack exposure)
     */
    if (tv.tv_sec <= 0) {
        tv.tv_sec = 300;
    }

    rv = ioctlsocket(sock, FIONBIO, (u_long*)&iostate);
    iostate = 0;
    if (rv) {
	err = WSAGetLastError();
	ap_assert(0);
    }

    rv = send(sock, buf, len, flags);
    if (rv == SOCKET_ERROR) {
	err = WSAGetLastError();
	if (err == WSAEWOULDBLOCK)
	    do {
		retry=0;

		FD_ZERO(&fdset);
		FD_SET(sock, &fdset);
		tv.tv_usec = 0;
		rv = select(sock + 1, NULL, &fdset, NULL, &tv);
		if (rv == SOCKET_ERROR)
		    err = WSAGetLastError();
		else if (rv == 0) {
 		    ioctlsocket(sock, FIONBIO, (u_long*)&iostate);
		    if(ap_check_alarm() < 0) {
			WSASetLastError(EINTR);	/* Simulate an alarm() */
			return (SOCKET_ERROR);
		    }
 		}
		else {
		    rv = send(sock, buf, len, flags);
		    if (rv == SOCKET_ERROR) {
		        err = WSAGetLastError();
			if(err == WSAEWOULDBLOCK) {
			    
			    retry=1;
                            ap_log_error(APLOG_MARK,APLOG_DEBUG,NULL,
                                         "select claimed we could write, but in fact we couldn't.");
#ifdef NETWARE
                            ThreadSwitchWithDelay();
#else
			    Sleep(100);
#endif
			}
		    }
		}
	    } while(retry);
    }

    ioctlsocket(sock, FIONBIO, (u_long*)&iostate);

    if (rv == SOCKET_ERROR)
	WSASetLastError(err);
    return (rv);
}


API_EXPORT(int) ap_recvwithtimeout(int sock, char *buf, int len, int flags)
{
    int iostate = 1;
    fd_set fdset;
    struct timeval tv;
    int err = WSAEWOULDBLOCK;
    int rv;
    int retry;

    tv.tv_sec = ap_check_alarm();

    /* If ap_recvwithtimeout is called with an invalid timeout
     * set a default timeout of 300 seconds. This hack is needed
     * to emulate the non-blocking recv() that was removed in 
     * the previous patch to this function. Network servers
     * should never make network i/o calls w/o setting a timeout.
     * (doing otherwise opens a DoS attack exposure)
     */
    if (tv.tv_sec <= 0) {
        tv.tv_sec = 300;
    }

    rv = ioctlsocket(sock, FIONBIO, (u_long*)&iostate);
    iostate = 0;
    ap_assert(!rv);

    rv = recv(sock, buf, len, flags);
    if (rv == SOCKET_ERROR) {
	err = WSAGetLastError();
	if (err == WSAEWOULDBLOCK) {
            do {
                retry = 0;
                FD_ZERO(&fdset);
                FD_SET(sock, &fdset);
                tv.tv_usec = 0;
                rv = select(sock + 1, &fdset, NULL, NULL, &tv);
                if (rv == SOCKET_ERROR)
                    err = WSAGetLastError();
                else if (rv == 0) {
                    ioctlsocket(sock, FIONBIO, (u_long*)&iostate);
                    ap_check_alarm();
                    WSASetLastError(WSAEWOULDBLOCK);
                    return (SOCKET_ERROR);
                }
                else {
                    rv = recv(sock, buf, len, flags);
                    if (rv == SOCKET_ERROR) {
                        err = WSAGetLastError();
                        if (err == WSAEWOULDBLOCK) {
                            ap_log_error(APLOG_MARK, APLOG_DEBUG, NULL,
                                         "select claimed we could read, but in fact we couldn't.");
                            retry = 1;
#ifdef NETWARE
                            ThreadSwitchWithDelay();
#else
                            Sleep(100);
#endif
                        }
                    }
                }
            } while (retry);
        }
    }

    ioctlsocket(sock, FIONBIO, (u_long*)&iostate);

    if (rv == SOCKET_ERROR)
	WSASetLastError(err);
    return (rv);
}

#endif /* WIN32 */

a130 9
#ifdef WIN32
    if (fb->hFH != INVALID_HANDLE_VALUE) {
        if (!ReadFile(fb->hFH,buf,nbyte,&rv,NULL)) {
            errno = GetLastError();
            rv = -1;
        }
    }
    else
#endif
a142 33
#if defined (WIN32) || defined(NETWARE) || defined(CYGWIN_WINSOCK) 
    if (fb->flags & B_SOCKET) {
#ifdef EAPI
	if (!ap_hook_call("ap::buff::recvwithtimeout", &rv, fb, buf, nbyte))
#endif /* EAPI */
	rv = ap_recvwithtimeout(fb->fd_in, buf, nbyte, 0);
	if (rv == SOCKET_ERROR)
	    errno = WSAGetLastError();
    }
    else
	rv = ap_read(fb, buf, nbyte);
#elif defined (BEOS)
    if (fb->flags & B_SOCKET) {
        rv = recv(fb->fd_in, buf, nbyte, 0);
    } else
        rv = ap_read(fb,buf,nbyte);
#elif defined(TPF)
    fd_set fds;
    struct timeval tv;

    ap_check_signals();
    if (fb->flags & B_SOCKET) {
        FD_ZERO(&fds);
        FD_SET(fb->fd_in, &fds);
        tv.tv_sec = 1;
        tv.tv_usec = 0;
        rv = ap_select(fb->fd_in + 1, &fds, NULL, NULL, &tv);
        if (rv > 0)
            rv = ap_read(fb, buf, nbyte);
    }
    else
        rv = ap_read(fb, buf, nbyte);
#else
a143 1
#endif /* WIN32 */
a151 9
#ifdef WIN32
    if (fb->hFH != INVALID_HANDLE_VALUE) {
        if (!WriteFile(fb->hFH,buf,nbyte,&rv,NULL)) {
            errno = GetLastError();
            rv = -1;
        }
    }
    else
#endif
a157 11
#ifdef _OSD_POSIX
        /* Sorry, but this is a hack: On BS2000, currently the send() call
         * has slightly better performance, and it doesn't have a maximum
	 * transfer size of 16kB per write. Both write() and writev()
	 * currently have such a limit and therefore don't work
	 * too well with MMAP files.
	 */
	if (fb->flags & B_SOCKET)
	    rv = send(fb->fd, buf, nbyte, 0);
	else
#endif
a171 17
#if defined(WIN32) || defined(NETWARE)
    if (fb->flags & B_SOCKET) {
#ifdef EAPI
	if (!ap_hook_call("ap::buff::sendwithtimeout", &rv, fb, buf, nbyte))
#endif /* EAPI */
	rv = ap_sendwithtimeout(fb->fd, buf, nbyte, 0);
	if (rv == SOCKET_ERROR)
	    errno = WSAGetLastError();
    }
    else
	rv = ap_write(fb, buf, nbyte);
#elif defined(BEOS)
    if(fb->flags & B_SOCKET) {
        rv = send(fb->fd, buf, nbyte, 0);
    } else 
        rv = ap_write(fb, buf,nbyte);
#else
a172 1
#endif /* WIN32 */
a211 4
#ifdef CHARSET_EBCDIC
    fb->flags |= (flags & B_SOCKET) ? (B_EBCDIC2ASCII | B_ASCII2EBCDIC) : 0;
#endif /*CHARSET_EBCDIC*/

a221 3
#ifdef WIN32
    fb->hFH = INVALID_HANDLE_VALUE;
#endif
a250 10
#ifdef WIN32
/*
 * Push some Win32 handles onto the stream.
 */
API_EXPORT(void) ap_bpushh(BUFF *fb, HANDLE hFH)
{
    fb->hFH = hFH;
}
#endif

a354 6
#ifdef CHARSET_EBCDIC
    /* Chunks are an HTTP/1.1 Protocol feature. They must ALWAYS be in ASCII */
    ebcdic2ascii(&fb->outbase[fb->outchunk], &fb->outbase[fb->outchunk], CHUNK_HEADER_SIZE);
    ebcdic2ascii(&fb->outbase[fb->outcnt-2], &fb->outbase[fb->outcnt-2], 2);
#endif /*CHARSET_EBCDIC*/

a544 5
#ifdef CHARSET_EBCDIC
	    if (fb->flags & B_ASCII2EBCDIC)
		ascii2ebcdic(buf, fb->inptr, i);
	    else
#endif /*CHARSET_EBCDIC*/
a550 4
#ifdef CHARSET_EBCDIC
	if (i > 0 && ap_bgetflag(fb, B_ASCII2EBCDIC))
	    ascii2ebcdic(buf, buf, i);
#endif /*CHARSET_EBCDIC*/
a556 5
#ifdef CHARSET_EBCDIC
	if (fb->flags & B_ASCII2EBCDIC)
	    ascii2ebcdic(buf, fb->inptr, nbyte);
	else
#endif /*CHARSET_EBCDIC*/
a563 5
#ifdef CHARSET_EBCDIC
	if (fb->flags & B_ASCII2EBCDIC)
	    ascii2ebcdic(buf, fb->inptr, nrd);
	else
#endif /*CHARSET_EBCDIC*/
a575 4
#ifdef CHARSET_EBCDIC
	if (i > 0 && ap_bgetflag(fb, B_ASCII2EBCDIC))
	    ascii2ebcdic(buf, buf, i);
#endif /*CHARSET_EBCDIC*/
a589 5
#ifdef CHARSET_EBCDIC
	if (fb->flags & B_ASCII2EBCDIC)
	    ascii2ebcdic(buf, fb->inptr, i);
	else
#endif /*CHARSET_EBCDIC*/
a649 4
#ifdef CHARSET_EBCDIC
	if (fb->flags & B_ASCII2EBCDIC)
	    ch = os_toebcdic[(unsigned char)ch];
#endif
a707 1
#ifndef CHARSET_EBCDIC
a708 5
#else /*CHARSET_EBCDIC*/
    *buff = (fb->flags & B_ASCII2EBCDIC)
	     ? os_toebcdic[(unsigned char)fb->inptr[0]]
	     : fb->inptr[0];
#endif /*CHARSET_EBCDIC*/
a921 4
#ifdef CHARSET_EBCDIC
    /* Chunks are an HTTP/1.1 Protocol feature. They must ALWAYS be in ASCII */
    ebcdic2ascii(chunksize, chunksize, strlen(chunksize));
#endif /*CHARSET_EBCDIC*/
a932 4
#ifdef CHARSET_EBCDIC
    /* Chunks are an HTTP/1.1 Protocol feature. They must ALWAYS be in ASCII */
    ebcdic2ascii(chunksize, chunksize, strlen(chunksize));
#endif /*CHARSET_EBCDIC*/
a967 4
#ifdef CHARSET_EBCDIC
    /* Chunks are an HTTP/1.1 Protocol feature. They must ALWAYS be in ASCII */
	ebcdic2ascii(chunksize, chunksize, strlen(chunksize));
#endif /*CHARSET_EBCDIC*/
a1003 4
#ifdef CHARSET_EBCDIC
    static char *cbuf = NULL;
    static int csize = 0;
#endif /*CHARSET_EBCDIC*/
a1009 16
#ifdef CHARSET_EBCDIC
    if (ap_bgetflag(fb, B_EBCDIC2ASCII)) {
        if (nbyte > csize) {
            if (cbuf != NULL)
                free(cbuf);
            cbuf = malloc(csize = nbyte+HUGE_STRING_LEN);
            if (cbuf == NULL) {
                fprintf(stderr, "Ouch!  Out of memory in ap_bwrite()!\n");
                csize = 0;
            }
        }
        ebcdic2ascii((cbuf) ? cbuf : (void*)buf, buf, nbyte);
        buf = (cbuf) ? cbuf : buf;
    }
#endif /*CHARSET_EBCDIC*/

a1197 7
#if defined(WIN32)
    if (fb->hFH != INVALID_HANDLE_VALUE) {
        rc2 = ap_pcloseh(fb->pool, fb->hFH);
        rc3 = 0;
    }
    else {
#endif
a1205 3
#if defined(WIN32)
    }
#endif
a1285 7
#ifdef CHARSET_EBCDIC
    /* Characters were pushed into the buffer without conversion. Do it now */
    if (fb->flags & B_EBCDIC2ASCII)
        ebcdic2ascii(&fb->outbase[fb->outcnt],
		     &fb->outbase[fb->outcnt],
		     b->vbuff.curpos - (char *)&fb->outbase[fb->outcnt]);
#endif /*CHARSET_EBCDIC*/
a1312 7
#ifdef CHARSET_EBCDIC
	/* Characters were pushed into the buffer without conversion. Do it now */
	if (fb->flags & B_EBCDIC2ASCII)
	    ebcdic2ascii(&fb->outbase[fb->outcnt],
			 &fb->outbase[fb->outcnt],
			 b.vbuff.curpos - (char *)&fb->outbase[fb->outcnt]);
#endif /*CHARSET_EBCDIC*/
a1330 7
#ifdef CHARSET_EBCDIC
	/* Characters were pushed into the buffer without conversion. Do it now */
	if (fb->flags & B_EBCDIC2ASCII)
	    ebcdic2ascii(&fb->outbase[fb->outcnt],
			 &fb->outbase[fb->outcnt],
			 b.vbuff.curpos - (char *)&fb->outbase[fb->outcnt]);
#endif /*CHARSET_EBCDIC*/
@


1.12
log
@merge
@
text
@a1518 1
#if defined(WIN32) || defined(NETWARE) || defined(CYGWIN_WINSOCK) 
d1527 3
a1529 3
    }
#if !defined(NETWARE) && !defined(CYGWIN_WINSOCK) 
    else if (fb->hFH != INVALID_HANDLE_VALUE) {
a1532 1
#endif
a1533 10
#elif defined(BEOS)
    if (fb->flags & B_SOCKET) {
	rc2 = ap_pclosesocket(fb->pool, fb->fd);
	if (fb->fd_in != fb->fd) {
	    rc3 = ap_pclosesocket(fb->pool, fb->fd_in);
	}
	else {
	    rc3 = 0;
	}
    } else {
d1542 2
a1543 1
#if defined(WIN32) || defined (BEOS) || defined(NETWARE) || defined(CYGWIN_WINSOCK) 
@


1.11
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
@


1.10
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d508 1
a508 1
	fb->bytes_sent = *(const long int *) optval - (long int) fb->outcnt;;
@


1.9
log
@correct select(FD_SETSIZE,...) misuse
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d62 1
d125 1
a125 1
#if defined(WIN32) || defined(NETWARE)
d131 1
a131 5
#ifdef EAPI
API_EXPORT(int) sendwithtimeout(int sock, const char *buf, int len, int flags)
#else /* EAPI */
int sendwithtimeout(int sock, const char *buf, int len, int flags)
#endif /* EAPI */
d140 12
a151 2
    if (!(tv.tv_sec = ap_check_alarm()))
	return (send(sock, buf, len, flags));
a186 1
#ifdef NETWARE
d189 1
a191 2
                            ap_log_error(APLOG_MARK,APLOG_DEBUG,NULL,
                                         "select claimed we could write, but in fact we couldn't. This is a bug in Windows.");
d207 2
a208 5
#ifdef EAPI
API_EXPORT(int) recvwithtimeout(int sock, char *buf, int len, int flags)
#else /* EAPI */
int recvwithtimeout(int sock, char *buf, int len, int flags)
#endif /* EAPI */
d217 12
a228 2
    if (!(tv.tv_sec = ap_check_alarm()))
	return (recv(sock, buf, len, flags));
d308 1
a308 1
#if defined (WIN32) || defined(NETWARE)
d313 1
a313 1
	rv = recvwithtimeout(fb->fd_in, buf, nbyte, 0);
d387 4
d396 1
a396 1
	rv = sendwithtimeout(fb->fd, buf, nbyte, 0);
d476 3
d1122 6
d1519 1
a1519 1
#if defined(WIN32) || defined(NETWARE)
d1529 1
a1529 1
#ifndef NETWARE
d1554 1
a1554 1
#if defined(WIN32) || defined (BEOS) || defined(NETWARE)
@


1.8
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d163 1
a163 1
		rv = select(FD_SETSIZE, NULL, &fdset, NULL, &tv);
d231 1
a231 1
                rv = select(FD_SETSIZE, &fdset, NULL, NULL, &tv);
@


1.7
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1996-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 20
a38 23
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 7
a56 6
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
@


1.6
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d85 1
d212 1
d225 32
a256 18
	    FD_ZERO(&fdset);
	    FD_SET(sock, &fdset);
	    tv.tv_usec = 0;
	    rv = select(FD_SETSIZE, &fdset, NULL, NULL, &tv);
	    if (rv == SOCKET_ERROR)
		err = WSAGetLastError();
	    else if (rv == 0) {
		ioctlsocket(sock, FIONBIO, (u_long*)&iostate);
		ap_check_alarm();
		WSASetLastError(WSAEWOULDBLOCK);
		return (SOCKET_ERROR);
	    }
	    else {
		rv = recv(sock, buf, len, flags);
		if (rv == SOCKET_ERROR)
		    err = WSAGetLastError();
	    }
	}
d1202 1
a1202 1
    if (write_it_all(fb, CRLF, 2) == -1)
d1215 1
a1215 1
    vec[2].iov_base = CRLF;
d1256 1
a1256 1
	vec[nvec].iov_base = CRLF;
@


1.5
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d122 1
a122 1
#ifdef WIN32
d144 1
a144 1
    rv = ioctlsocket(sock, FIONBIO, &iostate);
d150 1
d165 1
a165 1
 		    ioctlsocket(sock, FIONBIO, &iostate);
d170 1
a170 1
		}
d176 1
a176 2
			    ap_log_error(APLOG_MARK,APLOG_DEBUG,NULL,
				"select claimed we could write, but in fact we couldn't. This is a bug in Windows.");
d178 7
d186 1
d192 3
a194 1
    ioctlsocket(sock, FIONBIO, &iostate);
d215 1
a215 1
    rv = ioctlsocket(sock, FIONBIO, &iostate);
d218 1
d230 1
a230 1
		ioctlsocket(sock, FIONBIO, &iostate);
d242 3
a244 1
    ioctlsocket(sock, FIONBIO, &iostate);
d260 2
a261 1
        if (!ReadFile(fb->hFH,buf,nbyte,&rv,NULL))
d263 1
d279 1
a279 1
#if defined (WIN32)
d292 1
a292 1
    rv = recv(fb->fd_in, buf, nbyte, 0);
d294 1
a294 1
    rv = ap_read(fb,buf,nbyte);
a300 1
        alarm(rv = alarm(0));
d303 1
a303 1
        tv.tv_sec = rv+1;
d310 1
a310 1
    rv = ap_read(fb, buf, nbyte);
d324 4
a327 2
        if (!WriteFile(fb->hFH,buf,nbyte,&rv,NULL))
          rv = -1;
d337 11
d358 1
a358 1
#if defined(WIN32)
d371 1
a371 1
    rv = send(fb->fd, buf, nbyte, 0);
d373 1
a373 1
    rv = ap_write(fb, buf,nbyte);
d566 7
a572 2
    *strp++ = '\015';
    *strp = '\012';
d576 1
a578 4
    /* tack on the trailing CRLF, we've reserved room for this */
    fb->outbase[fb->outcnt++] = '\015';
    fb->outbase[fb->outcnt++] = '\012';

d902 1
a902 14
#ifndef CHARSET_EBCDIC
	if (ch == '\012') {	/* got LF */
	    if (ct == 0)
		buff[ct++] = '\n';
/* if just preceeded by CR, replace CR with LF */
	    else if (buff[ct - 1] == '\015')
		buff[ct - 1] = '\n';
	    else if (ct < n - 1)
		buff[ct++] = '\n';
	    else
		i--;		/* no room for LF */
	    break;
	}
#else /* an EBCDIC machine: do the same, but convert to EBCDIC on the fly: */
d905 2
a906 1
	if (ch == os_toebcdic['\012']) {  /* got LF */
d910 1
a910 1
	    else if (buff[ct - 1] == os_toebcdic['\015'])
a917 1
#endif
d1177 1
a1177 1
    ap_snprintf(chunksize, sizeof(chunksize), "%x\015\012", nbyte);
d1186 1
a1186 1
    if (write_it_all(fb, "\015\012", 2) == -1)
d1191 1
a1191 1
    vec[0].iov_len = ap_snprintf(chunksize, sizeof(chunksize), "%x\015\012",
d1199 1
a1199 1
    vec[2].iov_base = "\015\012";
d1231 1
a1231 1
					"%x\015\012", nbyte);
d1240 1
a1240 1
	vec[nvec].iov_base = "\015\012";
d1477 1
a1477 1
#ifdef WIN32
d1487 1
d1489 2
a1490 2
	    rc2 = ap_pcloseh(fb->pool, fb->hFH);
	    rc3 = 0;
d1492 1
d1512 1
a1512 1
#if defined(WIN32) || defined (BEOS)
@


1.4
log
@mod_ssl-2.2.3-1.3.4 (will require libssl-1.1 for https to work, but
mostly harmless otherwise).
@
text
@d275 5
d284 1
a284 1
    tpf_process_signals();
d292 2
a293 4
        if (rv < 1) {
            tpf_process_signals();
            return(rv);
        }
d295 1
d342 5
d717 1
d1272 2
a1273 1
            if (cbuf == NULL)
d1275 1
d1476 10
d1494 1
a1494 1
#ifdef WIN32
@


1.3
log
@Apache 1.3.4 merge
@
text
@d128 3
d132 1
d190 3
a192 1

d194 1
d252 3
d266 3
d311 3
d329 3
d407 4
d1067 3
@


1.2
log
@Apache 1.3.3 merge + proxy_segv fix
@
text
@d2 1
a2 1
 * Copyright (c) 1996-1998 The Apache Group.  All rights reserved.
d262 18
d1599 1
@


1.1
log
@Initial revision
@
text
@d565 5
a569 1
/* note we assume the caller has ensured that fb->fd_in <= FD_SETSIZE */
d576 5
a580 1
    if (fb->incnt > 0 || fb->outcnt == 0) {
d590 2
a591 1
    } while (rv < 0 && errno == EINTR);
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 23
a38 20
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 6
a55 7
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
a60 1
#include "buff.h"
a84 1
#define ascii_CRLF "\015\012" /* A CRLF which won't pass the conversion machinery */
d122 1
a122 1
#if defined(WIN32) || defined(NETWARE) || defined(CYGWIN_WINSOCK) 
d128 1
a128 1
API_EXPORT(int) ap_sendwithtimeout(int sock, const char *buf, int len, int flags)
d137 2
a138 12
    tv.tv_sec = ap_check_alarm();

    /* If ap_sendwithtimeout is called with an invalid timeout
     * set a default timeout of 300 seconds. This hack is needed
     * to emulate the non-blocking send() that was removed in 
     * the previous patch to this function. Network servers
     * should never make network i/o calls w/o setting a timeout.
     * (doing otherwise opens a DoS attack exposure)
     */
    if (tv.tv_sec <= 0) {
        tv.tv_sec = 300;
    }
d140 1
a140 1
    rv = ioctlsocket(sock, FIONBIO, (u_long*)&iostate);
a145 1

d160 1
a160 1
 		    ioctlsocket(sock, FIONBIO, (u_long*)&iostate);
d165 1
a165 1
 		}
d171 2
a172 1
			    
a173 5
                            ap_log_error(APLOG_MARK,APLOG_DEBUG,NULL,
                                         "select claimed we could write, but in fact we couldn't.");
#ifdef NETWARE
                            ThreadSwitchWithDelay();
#else
a174 1
#endif
d180 1
a180 3

    ioctlsocket(sock, FIONBIO, (u_long*)&iostate);

d187 1
a187 1
API_EXPORT(int) ap_recvwithtimeout(int sock, char *buf, int len, int flags)
a193 3
    int retry;

    tv.tv_sec = ap_check_alarm();
d195 2
a196 10
    /* If ap_recvwithtimeout is called with an invalid timeout
     * set a default timeout of 300 seconds. This hack is needed
     * to emulate the non-blocking recv() that was removed in 
     * the previous patch to this function. Network servers
     * should never make network i/o calls w/o setting a timeout.
     * (doing otherwise opens a DoS attack exposure)
     */
    if (tv.tv_sec <= 0) {
        tv.tv_sec = 300;
    }
d198 1
a198 1
    rv = ioctlsocket(sock, FIONBIO, (u_long*)&iostate);
a200 1

d205 18
a222 32
            do {
                retry = 0;
                FD_ZERO(&fdset);
                FD_SET(sock, &fdset);
                tv.tv_usec = 0;
                rv = select(FD_SETSIZE, &fdset, NULL, NULL, &tv);
                if (rv == SOCKET_ERROR)
                    err = WSAGetLastError();
                else if (rv == 0) {
                    ioctlsocket(sock, FIONBIO, (u_long*)&iostate);
                    ap_check_alarm();
                    WSASetLastError(WSAEWOULDBLOCK);
                    return (SOCKET_ERROR);
                }
                else {
                    rv = recv(sock, buf, len, flags);
                    if (rv == SOCKET_ERROR) {
                        err = WSAGetLastError();
                        if (err == WSAEWOULDBLOCK) {
                            ap_log_error(APLOG_MARK, APLOG_DEBUG, NULL,
                                         "select claimed we could read, but in fact we couldn't.");
                            retry = 1;
#ifdef NETWARE
                            ThreadSwitchWithDelay();
#else
                            Sleep(100);
#endif
                        }
                    }
                }
            } while (retry);
        }
d224 1
a224 3

    ioctlsocket(sock, FIONBIO, (u_long*)&iostate);

d240 1
a240 2
        if (!ReadFile(fb->hFH,buf,nbyte,&rv,NULL)) {
            errno = GetLastError();
a241 1
        }
d254 1
a254 1
#if defined (WIN32) || defined(NETWARE) || defined(CYGWIN_WINSOCK) 
d256 1
a256 1
	rv = ap_recvwithtimeout(fb->fd_in, buf, nbyte, 0);
a261 21
#elif defined (BEOS)
    if (fb->flags & B_SOCKET) {
        rv = recv(fb->fd_in, buf, nbyte, 0);
    } else
        rv = ap_read(fb,buf,nbyte);
#elif defined(TPF)
    fd_set fds;
    struct timeval tv;

    ap_check_signals();
    if (fb->flags & B_SOCKET) {
        FD_ZERO(&fds);
        FD_SET(fb->fd_in, &fds);
        tv.tv_sec = 1;
        tv.tv_usec = 0;
        rv = ap_select(fb->fd_in + 1, &fds, NULL, NULL, &tv);
        if (rv > 0)
            rv = ap_read(fb, buf, nbyte);
    }
    else
        rv = ap_read(fb, buf, nbyte);
d275 2
a276 4
        if (!WriteFile(fb->hFH,buf,nbyte,&rv,NULL)) {
            errno = GetLastError();
            rv = -1;
        }
a282 11
#ifdef _OSD_POSIX
        /* Sorry, but this is a hack: On BS2000, currently the send() call
         * has slightly better performance, and it doesn't have a maximum
	 * transfer size of 16kB per write. Both write() and writev()
	 * currently have such a limit and therefore don't work
	 * too well with MMAP files.
	 */
	if (fb->flags & B_SOCKET)
	    rv = send(fb->fd, buf, nbyte, 0);
	else
#endif
d293 1
a293 5
    if (fb->filter_callback != NULL) {
        fb->filter_callback(fb, buf, nbyte);
    }
   
#if defined(WIN32) || defined(NETWARE)
d295 1
a295 1
	rv = ap_sendwithtimeout(fb->fd, buf, nbyte, 0);
a300 5
#elif defined(BEOS)
    if(fb->flags & B_SOCKET) {
        rv = send(fb->fd, buf, nbyte, 0);
    } else 
        rv = ap_write(fb, buf,nbyte);
a369 3
    fb->callback_data = NULL;
    fb->filter_callback = NULL;

d489 2
a490 7
    *strp++ = CR;
    *strp = LF;

    /* tack on the trailing CRLF, we've reserved room for this */
    fb->outbase[fb->outcnt++] = CR;
    fb->outbase[fb->outcnt++] = LF;

a493 1
    ebcdic2ascii(&fb->outbase[fb->outcnt-2], &fb->outbase[fb->outcnt-2], 2);
d496 4
d565 1
a565 5
/* Test the descriptor and flush the output buffer if it looks like
 * we will block on the next read.
 *
 * Note we assume the caller has ensured that fb->fd_in <= FD_SETSIZE
 */
d572 1
a572 5
    /* We don't need to do anything if the connection has been closed
     * or there is something readable in the incoming buffer
     * or there is nothing flushable in the output buffer.
     */
    if (fb == NULL || fb->fd_in < 0 || fb->incnt > 0 || fb->outcnt == 0) {
d582 1
a582 2
    } while (rv < 0 && errno == EINTR && !(fb->flags & B_EOUT));

a657 1

d813 14
a826 1
#ifdef CHARSET_EBCDIC
d829 1
a829 2
#endif
	if (ch == LF) {  /* got LF */
d833 1
a833 1
	    else if (buff[ct - 1] == CR)
d841 1
a1009 6
    
    if (fb->filter_callback != NULL) {
        for (i = 0; i < nvec; i++) {
            fb->filter_callback(fb, vec[i].iov_base, vec[i].iov_len);
        }
    }
d1098 1
a1098 1
    ap_snprintf(chunksize, sizeof(chunksize), "%x" CRLF, nbyte);
d1107 1
a1107 1
    if (write_it_all(fb, ascii_CRLF, 2) == -1)
d1112 1
a1112 1
    vec[0].iov_len = ap_snprintf(chunksize, sizeof(chunksize), "%x" CRLF,
d1120 1
a1120 1
    vec[2].iov_base = ascii_CRLF;
d1152 1
a1152 1
					"%x" CRLF, nbyte);
d1161 1
a1161 1
	vec[nvec].iov_base = ascii_CRLF;
d1209 1
a1209 2
            if (cbuf == NULL) {
                fprintf(stderr, "Ouch!  Out of memory in ap_bwrite()!\n");
a1210 1
            }
d1396 1
a1396 1
#if defined(WIN32) || defined(NETWARE) || defined(CYGWIN_WINSOCK) 
a1405 1
#if !defined(NETWARE) && !defined(CYGWIN_WINSOCK) 
d1407 2
a1408 2
        rc2 = ap_pcloseh(fb->pool, fb->hFH);
        rc3 = 0;
a1409 1
#endif
a1410 10
#elif defined(BEOS)
    if (fb->flags & B_SOCKET) {
	rc2 = ap_pclosesocket(fb->pool, fb->fd);
	if (fb->fd_in != fb->fd) {
	    rc3 = ap_pclosesocket(fb->pool, fb->fd_in);
	}
	else {
	    rc3 = 0;
	}
    } else {
d1419 1
a1419 1
#if defined(WIN32) || defined (BEOS) || defined(NETWARE) || defined(CYGWIN_WINSOCK) 
a1571 1
 
@


1.1.1.3
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@a295 3
#ifdef EAPI
	if (!ap_hook_call("ap::buff::read", &rv, fb, buf, nbyte))
#endif /* EAPI */
a306 3
#ifdef EAPI
	if (!ap_hook_call("ap::buff::recvwithtimeout", &rv, fb, buf, nbyte))
#endif /* EAPI */
a353 3
#ifdef EAPI
	if (!ap_hook_call("ap::buff::write", &rv, fb, buf, nbyte))
#endif /* EAPI */
a383 3
#ifdef EAPI
	if (!ap_hook_call("ap::buff::sendwithtimeout", &rv, fb, buf, nbyte))
#endif /* EAPI */
a466 4
#ifdef EAPI
    fb->ctx = ap_ctx_new(p);
#endif /* EAPI */

a1118 3
#ifdef EAPI
	    if (!ap_hook_call("ap::buff::writev", &rv, fb, &vec[i], nvec -i))
#endif /* EAPI */
@


1.1.1.4
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
@


1.1.1.5
log
@import Apache 1.3.29 and mod_ssl 2.8.16
@
text
@d1519 1
d1528 3
a1530 3
    } else {
#if defined(WIN32)
    if (fb->hFH != INVALID_HANDLE_VALUE) {
d1534 1
d1536 10
d1554 1
a1554 2
    }
#if defined(WIN32)
@


