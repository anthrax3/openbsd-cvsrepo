head	1.12;
access;
symbols
	OPENBSD_5_5:1.11.0.26
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.22
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.20
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.18
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.16
	OPENBSD_5_0:1.11.0.14
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.12
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.10
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.6
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.8
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.4
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.8.0.14
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.12
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.10
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.8
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.3
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.3
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.2
	apache_1_3_27:1.1.1.2
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.04.22.14.47.26;	author henning;	state dead;
branches;
next	1.11;

1.11
date	2008.05.15.06.05.44;	author mbalmer;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.13.20.06.45;	author mbalmer;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.09.08.06.28;	author mbalmer;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.21.13.11.36;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.19.21.31.16;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.29.02.08.06;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.29.10.21.44;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.06.29.39;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.03.01.01.06.20;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.40;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.40;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.28.52;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.21.12.53.40;	author henning;	state Exp;
branches;
next	;


desc
@@


1.12
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*	$OpenBSD: util_uri.c,v 1.11 2008/05/15 06:05:44 mbalmer Exp $ */

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/*
 * util_uri.c: URI related utility things
 * 
 */

#include "httpd.h"
#include "http_log.h"
#include "http_conf_globals.h"  /* for user_id & group_id */
#include "util_uri.h"

/* 
 * Some WWW schemes and their default ports; this is basically /etc/services
 * This will become global when the protocol abstraction comes
 * As the schemes are searched by a linear search,
 * they are sorted by their expected frequency
 */
static schemes_t schemes[] = {
	{"http", DEFAULT_HTTP_PORT},
	{"ftp", DEFAULT_FTP_PORT},
	{"https", DEFAULT_HTTPS_PORT},
	{"gopher", DEFAULT_GOPHER_PORT},
	{"wais", DEFAULT_WAIS_PORT},
	{"nntp", DEFAULT_NNTP_PORT},
	{"snews", DEFAULT_SNEWS_PORT},
	{"prospero", DEFAULT_PROSPERO_PORT},
	{NULL, 0xFFFF}              /* unknown port */
};


API_EXPORT(unsigned short)
ap_default_port_for_scheme(const char *scheme_str)
{
	schemes_t *scheme;

	if (scheme_str == NULL)
		return 0;

	for (scheme = schemes; scheme->name != NULL; ++scheme)
		if (strcasecmp(scheme_str, scheme->name) == 0)
			return scheme->default_port;

	return 0;
}

API_EXPORT(unsigned short)
ap_default_port_for_request(const request_rec *r)
{
	return (r->parsed_uri.scheme)
	    ? ap_default_port_for_scheme(r->parsed_uri.scheme) : 0;
}

/* 
 * Create a copy of a "struct hostent" record; it was presumably returned
 * from a call to gethostbyname() and lives in static storage.
 * By creating a copy we can tuck it away for later use.
 */
API_EXPORT(struct hostent *)
ap_pduphostent(pool *p, const struct hostent *hp)
{
	struct hostent *newent;
	char **ptrs;
	char **aliases;
	struct in_addr *addrs;
	int i = 0, j = 0;

	if (hp == NULL)
		return NULL;

	/* Count number of alias entries */
	if (hp->h_aliases != NULL)
		for (; hp->h_aliases[j] != NULL; ++j)
			continue;

	/* Count number of in_addr entries */
	if (hp->h_addr_list != NULL)
		for (; hp->h_addr_list[i] != NULL; ++i)
			continue;

	/* Allocate hostent structure, alias ptrs, addr ptrs, addrs */
	newent = (struct hostent *)ap_palloc(p, sizeof(*hp));
	aliases = (char **)ap_palloc(p, (j + 1) * sizeof(char *));
	ptrs = (char **)ap_palloc(p, (i + 1) * sizeof(char *));
	addrs = (struct in_addr *)ap_palloc(p, (i + 1) * sizeof(struct in_addr));

	*newent = *hp;
	newent->h_name = ap_pstrdup(p, hp->h_name);
	newent->h_aliases = aliases;
	newent->h_addr_list = (char **)ptrs;

	/* Copy Alias Names: */
	for (j = 0; hp->h_aliases[j] != NULL; ++j)
		aliases[j] = ap_pstrdup(p, hp->h_aliases[j]);
	aliases[j] = NULL;

	/* Copy address entries */
	for (i = 0; hp->h_addr_list[i] != NULL; ++i) {
		ptrs[i] = (char *)&addrs[i];
		addrs[i] = *(struct in_addr *)hp->h_addr_list[i];
	}
	ptrs[i] = NULL;

	return newent;
}


/*
 * pgethostbyname(): resolve hostname, if successful return an ALLOCATED
 * COPY OF the hostent structure, intended to be stored and used later.
 * (gethostbyname() uses static storage that would be overwritten on each call)
 */
API_EXPORT(struct hostent *)
ap_pgethostbyname(pool *p, const char *hostname)
{
	struct hostent *hp = gethostbyname(hostname);
	return (hp == NULL) ? NULL : ap_pduphostent(p, hp);
}


/* Unparse a uri_components structure to an URI string.
 * Optionally suppress the password for security reasons.
 * See also RFC 2396.
 */
API_EXPORT(char *)
ap_unparse_uri_components(pool *p, const uri_components * uptr, unsigned flags)
{
	char *parts[16];     /* 16 distinct parts of a URI */
	char *scheme = NULL; /* to hold the scheme without modifying const
			     /* args */
	int j = 0;           /* an index into parts */

	memset(parts, 0, sizeof(parts));

	/*
	 * If suppressing the site part, omit all of
	 * scheme://user:pass@@host:port
	 */
	if (!(flags & UNP_OMITSITEPART)) {

		/* 
		 * if the user passes in a scheme, we'll assume an
		 * absoluteURI
		 */
		if (uptr->scheme) {
			scheme = uptr->scheme;

			parts[j++] = uptr->scheme;
			parts[j++] = ":";
		}

		/* handle the hier_part */
		if (uptr->user || uptr->password || uptr->hostname) {
			/* this stuff requires absoluteURI, so we have to
			 * add the scheme
			 */
			if (!uptr->scheme) {
				scheme = DEFAULT_URI_SCHEME;

				parts[j++] = DEFAULT_URI_SCHEME;
				parts[j++] = ":";
			}

			parts[j++] = "//";

			/* userinfo requires hostport */
			if (uptr->hostname && (uptr->user || uptr->password)) {
				if (uptr->user && !(flags & UNP_OMITUSER))
					parts[j++] = uptr->user;

				if (uptr->password &&
				    !(flags & UNP_OMITPASSWORD)) {
					parts[j++] = ":";

					if (flags & UNP_REVEALPASSWORD)
						parts[j++] = uptr->password;
					else
						parts[j++] = "XXXXXXXX";
				}    

				parts[j++] = "@@";
			}                

			/* If we get here, there must be a hostname. */
			parts[j++] = uptr->hostname;

			/*
			 * Emit the port.  A small beautification
			 * prevents http://host:80/ and similar visual blight.
			 */
			if (uptr->port_str && !(uptr->port && scheme &&
			    uptr->port == ap_default_port_for_scheme(scheme))) {
				parts[j++] = ":";
				parts[j++] = uptr->port_str;
			}
		}
	}

	if (!(flags & UNP_OMITPATHINFO)) {


		/* We must ensure we don't put out a hier_part and a rel_path */
		if (j && uptr->path && *uptr->path != '/')
			parts[j++] = "/";

		if (uptr->path != NULL)
			parts[j++] = uptr->path;

		if (!(flags & UNP_OMITQUERY)) {
			if (uptr->query) {
				parts[j++] = "?";
				parts[j++] = uptr->query;
			}

			if (uptr->fragment) {
				parts[j++] = "#";
				parts[j++] = uptr->fragment;
			}
		}
	}

	/* Ugly, but correct and probably faster than ap_vsnprintf. */
	return ap_pstrcat(p, parts[0], parts[1], parts[2], parts[3], parts[4],
	    parts[5], parts[6], parts[7], parts[8], parts[9], parts[10],
	    parts[11], parts[12], parts[13], parts[14], parts[15], NULL);
}

/*
 * Here is the hand-optimized parse_uri_components().  There are some wild
 * tricks we could pull in assembly language that we don't pull here... like we
 * can do word-at-time scans for delimiter characters using the same technique
 * that fast memchr()s use.  But that would be way non-portable. -djg
 */

/* 
 * We have a table that we can index by character and it tells us if the
 * character is one of the interesting delimiters.  Note that we even get
 * compares for NUL for free -- it's just another delimiter.
 */

#define T_COLON         0x01    /* ':' */
#define T_SLASH         0x02    /* '/' */
#define T_QUESTION      0x04    /* '?' */
#define T_HASH          0x08    /* '#' */
#define T_NUL           0x80    /* '\0' */

/* the uri_delims.h file is autogenerated by gen_uri_delims.c */
#include "uri_delims.h"

/* it works like this:
    if (uri_delims[ch] & NOTEND_foobar) {
        then we're not at a delimiter for foobar
    }
*/

/* Note that we optimize the scheme scanning here, we cheat and let the
 * compiler know that it doesn't have to do the & masking.
 */
#define NOTEND_SCHEME   (0xff)
#define NOTEND_HOSTINFO (T_SLASH | T_QUESTION | T_HASH | T_NUL)
#define NOTEND_PATH     (T_QUESTION | T_HASH | T_NUL)

void
ap_util_uri_init(void)
{
	/*
	 * Nothing to do - except....
	 * UTIL_URI_REGEX was removed, but third parties may depend on this
	 * symbol being present. So, we'll leave it in.... - vjo
	 */
}

/* parse_uri_components():
 * Parse a given URI, fill in all supplied fields of a uri_components
 * structure. This eliminates the necessity of extracting host, port,
 * path, query info repeatedly in the modules.
 * Side effects:
 *  - fills in fields of uri_components *uptr
 *  - none on any of the r->* fields
 */
API_EXPORT(int)
ap_parse_uri_components(pool *p, const char *uri, uri_components * uptr)
{
	const char *s;
	const char *s1;
	const char *hostinfo;
	char *endstr;
	int port;

	/* Initialize the structure. parse_uri() and parse_uri_components()
	 * can be called more than once per request.
	 */
	memset(uptr, '\0', sizeof(*uptr));
	uptr->is_initialized = 1;

	/* We assume the processor has a branch predictor like most --
	 * it assumes forward branches are untaken and backwards are taken.
	 * That's the reason for the gotos.  -djg
	 */
	if (uri[0] == '/') {
		deal_with_path:
		/* we expect uri to point to first character of path ...
		 * remember that the path could be empty -- 
		 * http://foobar?query for example
		 */
		s = uri;
		while ((uri_delims[*(unsigned char *)s] & NOTEND_PATH) == 0)
			++s;

		if (s != uri)
			uptr->path = ap_pstrndup(p, uri, s - uri);

		if (*s == 0)
			return HTTP_OK;

		if (*s == '?') {
			++s;
			s1 = strchr(s, '#');
			if (s1) {
				uptr->fragment = ap_pstrdup(p, s1 + 1);
				uptr->query = ap_pstrndup(p, s, s1 - s);
			} else
				uptr->query = ap_pstrdup(p, s);

			return HTTP_OK;
		}
		/* otherwise it's a fragment */
		uptr->fragment = ap_pstrdup(p, s + 1);
		return HTTP_OK;
	}

	/* find the scheme: */
	s = uri;
	while ((uri_delims[*(unsigned char *) s] & NOTEND_SCHEME) == 0)
		++s;

	/* scheme must be non-empty and followed by :// */
	if (s == uri || s[0] != ':' || s[1] != '/' || s[2] != '/')
		goto deal_with_path;    /* backwards predicted taken! */


	uptr->scheme = ap_pstrndup(p, uri, s - uri);
	s += 3;
	hostinfo = s;
	while ((uri_delims[*(unsigned char *) s] & NOTEND_HOSTINFO) == 0)
		++s;

	uri = s;	/* whatever follows hostinfo is start of uri */
	uptr->hostinfo = ap_pstrndup(p, hostinfo, uri - hostinfo);

	/* If there's a username:password@@host:port, the @@ we want is
	 * the last @@...too bad there's no memrchr()... For the C purists,
	 * note that hostinfo is definately not the first character of the
	 * original uri so therefore &hostinfo[-1] < &hostinfo[0] ...
	 *  and this loop is valid C.
	 */
	do {
		--s;
	} while (s >= hostinfo && *s != '@@');
	if (s < hostinfo) {
		/* again we want the common case to be fall through */
		deal_with_host:
		/* We expect hostinfo to point to the first character of
		 * the hostname.  If there's a port it is the first colon.
		 */
		if (*hostinfo == '[') {
			s = memchr(hostinfo+1, ']', uri - hostinfo - 1);
			if (s)
				s = strchr(s, ':');
		} else
			s = memchr(hostinfo, ':', uri - hostinfo);
		if (s == NULL) {
			/* we expect the common case to have no port */
			uptr->hostname = ap_pstrndup(p, hostinfo,
			    uri - hostinfo);
			goto deal_with_path;
		}
		uptr->hostname = ap_pstrndup(p, hostinfo, s - hostinfo);
		++s;
		uptr->port_str = ap_pstrndup(p, s, uri - s);
		if (uri != s) {
			port = ap_strtol(uptr->port_str, &endstr, 10);
			uptr->port = port;
			if (*endstr == '\0')
				goto deal_with_path;

			/* Invalid characters after ':' found */
			return HTTP_BAD_REQUEST;
		}
		uptr->port = ap_default_port_for_scheme(uptr->scheme);
		goto deal_with_path;
	}

	/* first colon delimits username:password */
	s1 = memchr(hostinfo, ':', s - hostinfo);
	if (s1) {
		uptr->user = ap_pstrndup(p, hostinfo, s1 - hostinfo);
		++s1;
		uptr->password = ap_pstrndup(p, s1, s - s1);
	} else
		uptr->user = ap_pstrndup(p, hostinfo, s - hostinfo);
	hostinfo = s + 1;
	goto deal_with_host;
}

/* Special case for CONNECT parsing: it comes with the hostinfo part only */
/* See the INTERNET-DRAFT document "Tunneling SSL Through a WWW Proxy"
 * currently at http://www.mcom.com/newsref/std/tunneling_ssl.html
 * for the format of the "CONNECT host:port HTTP/1.0" request
 */
API_EXPORT(int)
ap_parse_hostinfo_components(pool *p, const char *hostinfo,
    uri_components *uptr)
{
	const char *s;
	char *endstr;

	/* Initialize the structure. parse_uri() and parse_uri_components()
	 * can be called more than once per request.
	 */
	memset(uptr, '\0', sizeof(*uptr));
	uptr->is_initialized = 1;
	uptr->hostinfo = ap_pstrdup(p, hostinfo);

	/* We expect hostinfo to point to the first character of
	 * the hostname.  There must be a port, separated by a colon
	 */
	if (*hostinfo == '[') {
		s = strchr(hostinfo+1, ']');
		if (s)
			s = strchr(s, ':');
	} else
		s = strchr(hostinfo, ':');
	if (s == NULL)
		return HTTP_BAD_REQUEST;

	uptr->hostname = ap_pstrndup(p, hostinfo, s - hostinfo);
	++s;
	uptr->port_str = ap_pstrdup(p, s);
	if (*s != '\0') {
		uptr->port = (unsigned short)ap_strtol(uptr->port_str,
		    &endstr, 10);
		if (*endstr == '\0')
			return HTTP_OK;

	/* Invalid characters after ':' found */
	}
	return HTTP_BAD_REQUEST;
}
@


1.11
log
@Add OpenBSD markers.

no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.10
log
@knf.  no binary changes.
@
text
@d1 2
@


1.9
log
@Add support for IPv6 while keeping the default at IPv4 to not break
existing installations.  See the documentation for the IPv6 related
configuration.

This changes the module ABI since addresses are now struct addrinfo.

This has been tested by many people and run on production machines
for several months.

feedback many, ok todd
@
text
@d69 6
a74 4
/* Some WWW schemes and their default ports; this is basically /etc/services */
/* This will become global when the protocol abstraction comes */
/* As the schemes are searched by a linear search, */
/* they are sorted by their expected frequency */
d76 9
a84 9
    {"http", DEFAULT_HTTP_PORT},
    {"ftp", DEFAULT_FTP_PORT},
    {"https", DEFAULT_HTTPS_PORT},
    {"gopher", DEFAULT_GOPHER_PORT},
    {"wais", DEFAULT_WAIS_PORT},
    {"nntp", DEFAULT_NNTP_PORT},
    {"snews", DEFAULT_SNEWS_PORT},
    {"prospero", DEFAULT_PROSPERO_PORT},
    {NULL, 0xFFFF}              /* unknown port */
d88 2
a89 1
API_EXPORT(unsigned short) ap_default_port_for_scheme(const char *scheme_str)
d91 1
a91 1
    schemes_t *scheme;
d93 2
a94 2
    if (scheme_str == NULL)
        return 0;
d96 3
a98 3
    for (scheme = schemes; scheme->name != NULL; ++scheme)
        if (strcasecmp(scheme_str, scheme->name) == 0)
            return scheme->default_port;
d100 1
a100 1
    return 0;
d103 2
a104 1
API_EXPORT(unsigned short) ap_default_port_for_request(const request_rec *r)
d106 2
a107 3
    return (r->parsed_uri.scheme)
        ? ap_default_port_for_scheme(r->parsed_uri.scheme)
        : 0;
d110 2
a111 1
/* Create a copy of a "struct hostent" record; it was presumably returned
d115 2
a116 1
API_EXPORT(struct hostent *) ap_pduphostent(pool *p, const struct hostent *hp)
d118 41
a158 35
    struct hostent *newent;
    char **ptrs;
    char **aliases;
    struct in_addr *addrs;
    int i = 0, j = 0;

    if (hp == NULL)
        return NULL;

    /* Count number of alias entries */
    if (hp->h_aliases != NULL)
        for (; hp->h_aliases[j] != NULL; ++j)
            continue;

    /* Count number of in_addr entries */
    if (hp->h_addr_list != NULL)
        for (; hp->h_addr_list[i] != NULL; ++i)
            continue;

    /* Allocate hostent structure, alias ptrs, addr ptrs, addrs */
    newent = (struct hostent *) ap_palloc(p, sizeof(*hp));
    aliases = (char **) ap_palloc(p, (j + 1) * sizeof(char *));
    ptrs = (char **) ap_palloc(p, (i + 1) * sizeof(char *));
    addrs = (struct in_addr *) ap_palloc(p, (i + 1) * sizeof(struct in_addr));

    *newent = *hp;
    newent->h_name = ap_pstrdup(p, hp->h_name);
    newent->h_aliases = aliases;
    newent->h_addr_list = (char **) ptrs;

    /* Copy Alias Names: */
    for (j = 0; hp->h_aliases[j] != NULL; ++j) {
        aliases[j] = ap_pstrdup(p, hp->h_aliases[j]);
    }
    aliases[j] = NULL;
d160 1
a160 8
    /* Copy address entries */
    for (i = 0; hp->h_addr_list[i] != NULL; ++i) {
        ptrs[i] = (char *) &addrs[i];
        addrs[i] = *(struct in_addr *) hp->h_addr_list[i];
    }
    ptrs[i] = NULL;

    return newent;
d164 2
a165 1
/* pgethostbyname(): resolve hostname, if successful return an ALLOCATED
d169 2
a170 1
API_EXPORT(struct hostent *) ap_pgethostbyname(pool *p, const char *hostname)
d172 2
a173 2
    struct hostent *hp = gethostbyname(hostname);
    return (hp == NULL) ? NULL : ap_pduphostent(p, hp);
d181 2
a182 3
API_EXPORT(char *) ap_unparse_uri_components(pool *p,
                                             const uri_components * uptr,
                                             unsigned flags)
d184 93
a276 86
    char *parts[16];     /* 16 distinct parts of a URI */
    char *scheme = NULL; /* to hold the scheme without modifying const args */
    int j = 0;           /* an index into parts */
    
    memset(parts, 0, sizeof(parts));
        
    /* If suppressing the site part, omit all of scheme://user:pass@@host:port */
    if (!(flags & UNP_OMITSITEPART)) {

        /* if the user passes in a scheme, we'll assume an absoluteURI */
        if (uptr->scheme) {
            scheme = uptr->scheme;
            
            parts[j++] = uptr->scheme;
            parts[j++] = ":";
        }
        
        /* handle the hier_part */
        if (uptr->user || uptr->password || uptr->hostname) {
            
            /* this stuff requires absoluteURI, so we have to add the scheme */
            if (!uptr->scheme) {
                scheme = DEFAULT_URI_SCHEME;
                
                parts[j++] = DEFAULT_URI_SCHEME;
                parts[j++] = ":";
            }
            
            parts[j++] = "//";
            
            /* userinfo requires hostport */
            if (uptr->hostname && (uptr->user || uptr->password)) {
                if (uptr->user && !(flags & UNP_OMITUSER))
                    parts[j++] = uptr->user;
                
                if (uptr->password && !(flags & UNP_OMITPASSWORD)) {
                    parts[j++] = ":";

                    if (flags & UNP_REVEALPASSWORD)
                        parts[j++] = uptr->password;
                    else
                        parts[j++] = "XXXXXXXX";
                }    

                parts[j++] = "@@";
            }                
            
            /* If we get here, there must be a hostname. */
            parts[j++] = uptr->hostname;
            
            /* Emit the port.  A small beautification
             * prevents http://host:80/ and similar visual blight.
             */
            if (uptr->port_str &&
                !(uptr->port   &&
                  scheme       &&
                  uptr->port == ap_default_port_for_scheme(scheme))) {

                parts[j++] = ":";
                parts[j++] = uptr->port_str;
            }
        }
    }
        
    if (!(flags & UNP_OMITPATHINFO)) {
        
        
        /* We must ensure we don't put out a hier_part and a rel_path */
        if (j && uptr->path && *uptr->path != '/')
            parts[j++] = "/";
        
        if (uptr->path != NULL)
            parts[j++] = uptr->path;

        if (!(flags & UNP_OMITQUERY)) {
            if (uptr->query) {
                parts[j++] = "?";
                parts[j++] = uptr->query;
            }
            
            if (uptr->fragment) {
                parts[j++] = "#";
                parts[j++] = uptr->fragment;
            }
        }
    }
d278 4
a281 20
    /* Ugly, but correct and probably faster than ap_vsnprintf. */
    return ap_pstrcat(p,
        parts[0],
        parts[1],
        parts[2],
        parts[3],
        parts[4],
        parts[5],
        parts[6],
        parts[7],
        parts[8],
        parts[9],
        parts[10],
        parts[11],
        parts[12],
        parts[13],
        parts[14],
        parts[15],
        NULL
    );
d284 2
a285 1
/* Here is the hand-optimized parse_uri_components().  There are some wild
d291 2
a292 1
/* We have a table that we can index by character and it tells us if the
d319 2
a320 1
void ap_util_uri_init(void)
d322 5
a326 4
    /* Nothing to do - except....
       UTIL_URI_REGEX was removed, but third parties may depend on this symbol
       being present. So, we'll leave it in.... - vjo
     */
d337 2
a338 2
API_EXPORT(int) ap_parse_uri_components(pool *p, const char *uri,
                                        uri_components * uptr)
d340 5
a344 47
    const char *s;
    const char *s1;
    const char *hostinfo;
    char *endstr;
    int port;

    /* Initialize the structure. parse_uri() and parse_uri_components()
     * can be called more than once per request.
     */
    memset(uptr, '\0', sizeof(*uptr));
    uptr->is_initialized = 1;

    /* We assume the processor has a branch predictor like most --
     * it assumes forward branches are untaken and backwards are taken.  That's
     * the reason for the gotos.  -djg
     */
    if (uri[0] == '/') {
      deal_with_path:
        /* we expect uri to point to first character of path ... remember
         * that the path could be empty -- http://foobar?query for example
         */
        s = uri;
        while ((uri_delims[*(unsigned char *) s] & NOTEND_PATH) == 0) {
            ++s;
        }
        if (s != uri) {
            uptr->path = ap_pstrndup(p, uri, s - uri);
        }
        if (*s == 0) {
            return HTTP_OK;
        }
        if (*s == '?') {
            ++s;
            s1 = strchr(s, '#');
            if (s1) {
                uptr->fragment = ap_pstrdup(p, s1 + 1);
                uptr->query = ap_pstrndup(p, s, s1 - s);
            }
            else {
                uptr->query = ap_pstrdup(p, s);
            }
            return HTTP_OK;
        }
        /* otherwise it's a fragment */
        uptr->fragment = ap_pstrdup(p, s + 1);
        return HTTP_OK;
    }
d346 5
a350 9
    /* find the scheme: */
    s = uri;
    while ((uri_delims[*(unsigned char *) s] & NOTEND_SCHEME) == 0) {
        ++s;
    }
    /* scheme must be non-empty and followed by :// */
    if (s == uri || s[0] != ':' || s[1] != '/' || s[2] != '/') {
        goto deal_with_path;    /* backwards predicted taken! */
    }
d352 35
a386 8
    uptr->scheme = ap_pstrndup(p, uri, s - uri);
    s += 3;
    hostinfo = s;
    while ((uri_delims[*(unsigned char *) s] & NOTEND_HOSTINFO) == 0) {
        ++s;
    }
    uri = s;                    /* whatever follows hostinfo is start of uri */
    uptr->hostinfo = ap_pstrndup(p, hostinfo, uri - hostinfo);
d388 24
a411 13
    /* If there's a username:password@@host:port, the @@ we want is the last @@...
     * too bad there's no memrchr()... For the C purists, note that hostinfo
     * is definately not the first character of the original uri so therefore
     * &hostinfo[-1] < &hostinfo[0] ... and this loop is valid C.
     */
    do {
	--s;
    } while (s >= hostinfo && *s != '@@');
    if (s < hostinfo) {
	/* again we want the common case to be fall through */
deal_with_host:
	/* We expect hostinfo to point to the first character of
	 * the hostname.  If there's a port it is the first colon.
d413 34
a446 18
	if (*hostinfo == '[') {
	    s = memchr(hostinfo+1, ']', uri - hostinfo - 1);
	    if (s)
		s = strchr(s, ':');
	} else
	    s = memchr(hostinfo, ':', uri - hostinfo);
	if (s == NULL) {
	    /* we expect the common case to have no port */
	    uptr->hostname = ap_pstrndup(p, hostinfo, uri - hostinfo);
	    goto deal_with_path;
	}
	uptr->hostname = ap_pstrndup(p, hostinfo, s - hostinfo);
	++s;
	uptr->port_str = ap_pstrndup(p, s, uri - s);
	if (uri != s) {
	    port = ap_strtol(uptr->port_str, &endstr, 10);
	    uptr->port = port;
	    if (*endstr == '\0') {
a447 3
	    }
	    /* Invalid characters after ':' found */
	    return HTTP_BAD_REQUEST;
a448 3
	uptr->port = ap_default_port_for_scheme(uptr->scheme);
	goto deal_with_path;
    }
d450 10
a459 12
    /* first colon delimits username:password */
    s1 = memchr(hostinfo, ':', s - hostinfo);
    if (s1) {
	uptr->user = ap_pstrndup(p, hostinfo, s1 - hostinfo);
	++s1;
	uptr->password = ap_pstrndup(p, s1, s - s1);
    }
    else {
	uptr->user = ap_pstrndup(p, hostinfo, s - hostinfo);
    }
    hostinfo = s + 1;
    goto deal_with_host;
d467 3
a469 2
API_EXPORT(int) ap_parse_hostinfo_components(pool *p, const char *hostinfo,
                                             uri_components * uptr)
d471 9
a479 2
    const char *s;
    char *endstr;
d481 24
a504 30
    /* Initialize the structure. parse_uri() and parse_uri_components()
     * can be called more than once per request.
     */
    memset(uptr, '\0', sizeof(*uptr));
    uptr->is_initialized = 1;
    uptr->hostinfo = ap_pstrdup(p, hostinfo);

    /* We expect hostinfo to point to the first character of
     * the hostname.  There must be a port, separated by a colon
     */
    if (*hostinfo == '[') {
        s = strchr(hostinfo+1, ']');
        if (s)
            s = strchr(s, ':');
    } else
        s = strchr(hostinfo, ':');
    if (s == NULL) {
        return HTTP_BAD_REQUEST;
    }
    uptr->hostname = ap_pstrndup(p, hostinfo, s - hostinfo);
    ++s;
    uptr->port_str = ap_pstrdup(p, s);
    if (*s != '\0') {
        uptr->port = (unsigned short)ap_strtol(uptr->port_str, &endstr, 10);
        if (*endstr == '\0') {
            return HTTP_OK;
        }
        /* Invalid characters after ':' found */
    }
    return HTTP_BAD_REQUEST;
@


1.8
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@d413 1
a413 1
        --s;
d416 30
a445 25
        /* again we want the common case to be fall through */
      deal_with_host:
        /* We expect hostinfo to point to the first character of
         * the hostname.  If there's a port it is the first colon.
         */
        s = memchr(hostinfo, ':', uri - hostinfo);
        if (s == NULL) {
            /* we expect the common case to have no port */
            uptr->hostname = ap_pstrndup(p, hostinfo, uri - hostinfo);
            goto deal_with_path;
        }
        uptr->hostname = ap_pstrndup(p, hostinfo, s - hostinfo);
        ++s;
        uptr->port_str = ap_pstrndup(p, s, uri - s);
        if (uri != s) {
            port = ap_strtol(uptr->port_str, &endstr, 10);
            uptr->port = port;
            if (*endstr == '\0') {
                goto deal_with_path;
            }
            /* Invalid characters after ':' found */
            return HTTP_BAD_REQUEST;
        }
        uptr->port = ap_default_port_for_scheme(uptr->scheme);
        goto deal_with_path;
d451 3
a453 3
        uptr->user = ap_pstrndup(p, hostinfo, s1 - hostinfo);
        ++s1;
        uptr->password = ap_pstrndup(p, s1, s - s1);
d456 1
a456 1
        uptr->user = ap_pstrndup(p, hostinfo, s - hostinfo);
d483 6
a488 1
    s = strchr(hostinfo, ':');
@


1.7
log
@merge
@
text
@a165 4
#ifdef TPF
    /* get rid of compilation warning on TPF */
    struct hostent *hp = gethostbyname((char *)hostname);
#else
a166 1
#endif
@


1.6
log
@merge
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
d166 4
d171 1
@


1.5
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d431 1
a431 1
            port = strtol(uptr->port_str, &endstr, 10);
d486 1
a486 1
        uptr->port = (unsigned short)strtol(uptr->port_str, &endstr, 10);
@


1.4
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d250 2
a251 1
        parts[j++] = uptr->path;
a287 199
/* The regex version of parse_uri_components has the advantage that it is
 * relatively easy to understand and extend.  But it has the disadvantage
 * that the regexes are complex enough that regex libraries really
 * don't do a great job with them performancewise.
 *
 * The default is a hand coded scanner that is two orders of magnitude
 * faster.
 */
#ifdef UTIL_URI_REGEX

static regex_t re_uri;
static regex_t re_hostpart;

void ap_util_uri_init(void)
{
    int ret;
    const char *re_str;

    /* This is a modified version of the regex that appeared in
     * draft-fielding-uri-syntax-01.  It doesnt allow the uri to contain a
     * scheme but no hostinfo or vice versa. 
     *
     * draft-fielding-uri-syntax-01.txt, section 4.4 tells us:
     *
     *      Although the BNF defines what is allowed in each component, it is
     *      ambiguous in terms of differentiating between a site component and
     *      a path component that begins with two slash characters.
     *  
     * RFC2068 disambiguates this for the Request-URI, which may only ever be
     * the "abs_path" portion of the URI.  So a request "GET //foo/bar
     * HTTP/1.1" is really referring to the path //foo/bar, not the host foo,
     * path /bar.  Nowhere in RFC2068 is it possible to have a scheme but no
     * hostinfo or a hostinfo but no scheme.  (Unless you're proxying a
     * protocol other than HTTP, but this parsing engine probably won't work
     * for other protocols.)
     *
     *         12            3          4       5   6        7 8 */
    re_str = "^(([^:/?#]+)://([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$";
    /*          ^scheme--^   ^site---^  ^path--^   ^query^    ^frag */
    if ((ret = regcomp(&re_uri, re_str, REG_EXTENDED)) != 0) {
        char line[1024];

        /* Make a readable error message */
        ret = regerror(ret, &re_uri, line, sizeof line);
        ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, NULL,
                     "Internal error: regcomp(\"%s\") returned non-zero (%s) - "
                     "possibly due to broken regex lib! "
                     "Did you define WANTHSREGEX=yes?", re_str, line);

        exit(1);
    }

    /* This is a sub-RE which will break down the hostinfo part,
     * i.e., user, password, hostname and port.
     * $          12      3 4        5       6 7    */
    re_str = "^(([^:]*)(:(.*))?@@)?([^@@:]*)(:([0-9]*))?$";
    /*             ^^user^ :pw        ^host^ ^:[port]^ */
    if ((ret = regcomp(&re_hostpart, re_str, REG_EXTENDED)) != 0) {
        char line[1024];

        /* Make a readable error message */
        ret = regerror(ret, &re_hostpart, line, sizeof line);
        ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, NULL,
                     "Internal error: regcomp(\"%s\") returned non-zero (%s) - "
                     "possibly due to broken regex lib! "
                     "Did you define WANTHSREGEX=yes?", re_str, line);

        exit(1);
    }
}


/* parse_uri_components():
 * Parse a given URI, fill in all supplied fields of a uri_components
 * structure. This eliminates the necessity of extracting host, port,
 * path, query info repeatedly in the modules.
 * Side effects:
 *  - fills in fields of uri_components *uptr
 *  - none on any of the r->* fields
 */
API_EXPORT(int) ap_parse_uri_components(pool *p, const char *uri,
                                        uri_components * uptr)
{
    int ret;
    regmatch_t match[10];       /* This must have at least as much elements
                                   * as there are braces in the re_strings */

    ap_assert(uptr != NULL);

    /* Initialize the structure. parse_uri() and parse_uri_components()
     * can be called more than once per request.
     */
    memset(uptr, '\0', sizeof(*uptr));
    uptr->is_initialized = 1;

    ret = ap_regexec(&re_uri, uri, re_uri.re_nsub + 1, match, 0);

    if (ret != 0) {
        ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, NULL,
                     "ap_regexec() could not parse uri (\"%s\")", uri);

        return HTTP_BAD_REQUEST;
    }

    if (match[2].rm_so != match[2].rm_eo)
        uptr->scheme =
            ap_pstrndup(p, uri + match[2].rm_so,
                        match[2].rm_eo - match[2].rm_so);

    /* empty hostinfo is valid, that's why we test $1 but use $3 */
    if (match[1].rm_so != match[1].rm_eo)
        uptr->hostinfo =
            ap_pstrndup(p, uri + match[3].rm_so,
                        match[3].rm_eo - match[3].rm_so);

    if (match[4].rm_so != match[4].rm_eo)
        uptr->path =
            ap_pstrndup(p, uri + match[4].rm_so,
                        match[4].rm_eo - match[4].rm_so);

    /* empty query string is valid, that's why we test $5 but use $6 */
    if (match[5].rm_so != match[5].rm_eo)
        uptr->query =
            ap_pstrndup(p, uri + match[6].rm_so,
                        match[6].rm_eo - match[6].rm_so);

    /* empty fragment is valid, test $7 use $8 */
    if (match[7].rm_so != match[7].rm_eo)
        uptr->fragment =
            ap_pstrndup(p, uri + match[8].rm_so,
                        match[8].rm_eo - match[8].rm_so);

    if (uptr->hostinfo) {
        /* Parse the hostinfo part to extract user, password, host, and port */
        ret =
            ap_regexec(&re_hostpart, uptr->hostinfo, re_hostpart.re_nsub + 1,
                       match, 0);
        if (ret != 0) {
            ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, NULL,
                         "ap_regexec() could not parse (\"%s\") as host part",
                         uptr->hostinfo);

            return HTTP_BAD_REQUEST;
        }

        /* $      12      3 4        5       6 7            */
        /*      "^(([^:]*)(:(.*))?@@)?([^@@:]*)(:([0-9]*))?$" */
        /*         ^^user^ :pw        ^host^ ^:[port]^      */

        /* empty user is valid, that's why we test $1 but use $2 */
        if (match[1].rm_so != match[1].rm_eo)
            uptr->user =
                ap_pstrndup(p, uptr->hostinfo + match[2].rm_so,
                            match[2].rm_eo - match[2].rm_so);

        /* empty password is valid, test $3 but use $4 */
        if (match[3].rm_so != match[3].rm_eo)
            uptr->password =
                ap_pstrndup(p, uptr->hostinfo + match[4].rm_so,
                            match[4].rm_eo - match[4].rm_so);

        /* empty hostname is valid, and implied by the existence of hostinfo */
        uptr->hostname =
            ap_pstrndup(p, uptr->hostinfo + match[5].rm_so,
                        match[5].rm_eo - match[5].rm_so);

        if (match[6].rm_so != match[6].rm_eo) {
            /* Note that the port string can be empty.
             * If it is, we use the default port associated with the scheme
             */
            uptr->port_str =
                ap_pstrndup(p, uptr->hostinfo + match[7].rm_so,
                            match[7].rm_eo - match[7].rm_so);
            if (uptr->port_str[0] != '\0') {
                char *endstr;
                int port;

                port = strtol(uptr->port_str, &endstr, 10);
                uptr->port = port;
                if (*endstr != '\0') {
                    /* Invalid characters after ':' found */
                    return HTTP_BAD_REQUEST;
                }
            }
            else {
                uptr->port =
                    uptr->scheme ? ap_default_port_for_scheme(uptr->
                                                              scheme) :
                    DEFAULT_HTTP_PORT;
            }
        }
    }

    if (ret == 0)
        ret = HTTP_OK;
    return ret;
}
#else

d323 4
a326 1
    /* nothing to do */
d486 1
a486 1
        uptr->port = strtol(uptr->port_str, &endstr, 10);
a493 1
#endif
@


1.3
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d2 4
a5 1
 * Copyright (c) 1998-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 20
a38 22
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 7
a56 6
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
d66 1
a66 1
#include "http_conf_globals.h"	/* for user_id & group_id */
d73 4
a76 5
static schemes_t schemes[] =
{
    {"http",   DEFAULT_HTTP_PORT},
    {"ftp",    DEFAULT_FTP_PORT},
    {"https",  DEFAULT_HTTPS_PORT},
d78 3
a80 3
    {"wais",   DEFAULT_WAIS_PORT},
    {"nntp",   DEFAULT_NNTP_PORT},
    {"snews",  DEFAULT_SNEWS_PORT},
d82 1
a82 1
    { NULL, 0xFFFF }			/* unknown port */
d90 3
d94 2
a95 2
	if (strcasecmp(scheme_str, scheme->name) == 0)
	    return scheme->default_port;
d103 2
a104 2
	? ap_default_port_for_scheme(r->parsed_uri.scheme)
	: 0;
d114 2
a115 2
    char	  **ptrs;
    char	  **aliases;
d117 1
a117 1
    int		   i = 0, j = 0;
d120 1
a120 1
	return NULL;
d124 2
a125 2
	for (; hp->h_aliases[j] != NULL; ++j)
	    continue;
d129 2
a130 2
	for (; hp->h_addr_list[i] != NULL; ++i)
	    continue;
d134 3
a136 3
    aliases = (char **) ap_palloc(p, (j+1) * sizeof(char*));
    ptrs = (char **) ap_palloc(p, (i+1) * sizeof(char*));
    addrs  = (struct in_addr *) ap_palloc(p, (i+1) * sizeof(struct in_addr));
d141 1
a141 1
    newent->h_addr_list = (char**) ptrs;
d145 1
a145 1
       aliases[j] = ap_pstrdup(p, hp->h_aliases[j]);
d151 2
a152 2
	ptrs[i] = (char*) &addrs[i];
	addrs[i] = *(struct in_addr *) hp->h_addr_list[i];
d173 1
d175 11
a185 5
API_EXPORT(char *) ap_unparse_uri_components(pool *p, const uri_components *uptr, unsigned flags)
{
    char *ret = "";

    /* If suppressing the site part, omit both user name & scheme://hostname */
d188 53
a240 26
	/* Construct a "user:password@@" string, honoring the passed UNP_ flags: */
	if (uptr->user||uptr->password)
	    ret = ap_pstrcat (p,
			(uptr->user     && !(flags & UNP_OMITUSER)) ? uptr->user : "",
			(uptr->password && !(flags & UNP_OMITPASSWORD)) ? ":" : "",
			(uptr->password && !(flags & UNP_OMITPASSWORD))
			   ? ((flags & UNP_REVEALPASSWORD) ? uptr->password : "XXXXXXXX")
			   : "",
			"@@", NULL);

	/* Construct scheme://site string */
	if (uptr->hostname) {
	    int is_default_port;

	    is_default_port =
		(uptr->port_str == NULL ||
		 uptr->port == 0 ||
		 uptr->port == ap_default_port_for_scheme(uptr->scheme));

	    ret = ap_pstrcat (p,
			uptr->scheme, "://", ret, 
			uptr->hostname ? uptr->hostname : "",
			is_default_port ? "" : ":",
			is_default_port ? "" : uptr->port_str,
			NULL);
	}
d242 1
a242 2

    /* Should we suppress all path info? */
d244 41
a284 11
	/* Append path, query and fragment strings: */
	ret = ap_pstrcat (p,
		ret,
		uptr->path ? uptr->path : "",
		(uptr->query    && !(flags & UNP_OMITQUERY)) ? "?" : "",
		(uptr->query    && !(flags & UNP_OMITQUERY)) ? uptr->query : "",
		(uptr->fragment && !(flags & UNP_OMITQUERY)) ? "#" : NULL,
		(uptr->fragment && !(flags & UNP_OMITQUERY)) ? uptr->fragment : NULL,
		NULL);
    }
    return ret;
d311 3
a313 3
     *	    Although the BNF defines what is allowed in each component, it is
     *	    ambiguous in terms of differentiating between a site component and
     *	    a path component that begins with two slash characters.
d327 1
a327 1
	char line[1024];
d329 6
a334 7
	/* Make a readable error message */
	ret = regerror(ret, &re_uri, line, sizeof line);
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, NULL,
		"Internal error: regcomp(\"%s\") returned non-zero (%s) - "
		"possibly due to broken regex lib! "
		"Did you define WANTHSREGEX=yes?",
		re_str, line);
d336 1
a336 1
	exit(1);
d342 1
a342 1
    re_str    = "^(([^:]*)(:(.*))?@@)?([^@@:]*)(:([0-9]*))?$";
d345 1
a345 1
	char line[1024];
d347 6
a352 7
	/* Make a readable error message */
	ret = regerror(ret, &re_hostpart, line, sizeof line);
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, NULL,
		"Internal error: regcomp(\"%s\") returned non-zero (%s) - "
		"possibly due to broken regex lib! "
		"Did you define WANTHSREGEX=yes?",
		re_str, line);
d354 1
a354 1
	exit(1);
d367 2
a368 1
API_EXPORT(int) ap_parse_uri_components(pool *p, const char *uri, uri_components *uptr)
d371 2
a372 2
    regmatch_t match[10];	/* This must have at least as much elements
				* as there are braces in the re_strings */
d374 1
a374 1
    ap_assert (uptr != NULL);
d379 1
a379 1
    memset (uptr, '\0', sizeof(*uptr));
d385 2
a386 3
	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, NULL,
                    "ap_regexec() could not parse uri (\"%s\")",
		    uri);
d388 1
a388 1
	return HTTP_BAD_REQUEST;
d392 3
a394 1
	uptr->scheme = ap_pstrndup (p, uri+match[2].rm_so, match[2].rm_eo - match[2].rm_so);
d398 3
a400 1
	uptr->hostinfo = ap_pstrndup (p, uri+match[3].rm_so, match[3].rm_eo - match[3].rm_so);
d403 3
a405 1
	uptr->path = ap_pstrndup (p, uri+match[4].rm_so, match[4].rm_eo - match[4].rm_so);
d409 3
a411 1
	uptr->query = ap_pstrndup (p, uri+match[6].rm_so, match[6].rm_eo - match[6].rm_so);
d415 3
a417 1
	uptr->fragment = ap_pstrndup (p, uri+match[8].rm_so, match[8].rm_eo - match[8].rm_so);
d420 58
a477 45
	/* Parse the hostinfo part to extract user, password, host, and port */
	ret = ap_regexec(&re_hostpart, uptr->hostinfo, re_hostpart.re_nsub + 1, match, 0);
	if (ret != 0) {
	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, NULL,
                    "ap_regexec() could not parse (\"%s\") as host part",
		    uptr->hostinfo);

	    return HTTP_BAD_REQUEST;
	}

	/* $      12      3 4        5       6 7            */
	/*      "^(([^:]*)(:(.*))?@@)?([^@@:]*)(:([0-9]*))?$" */
	/*         ^^user^ :pw        ^host^ ^:[port]^      */

	/* empty user is valid, that's why we test $1 but use $2 */
	if (match[1].rm_so != match[1].rm_eo)
	    uptr->user = ap_pstrndup (p, uptr->hostinfo+match[2].rm_so, match[2].rm_eo - match[2].rm_so);

	/* empty password is valid, test $3 but use $4 */
	if (match[3].rm_so != match[3].rm_eo)
	    uptr->password = ap_pstrndup (p, uptr->hostinfo+match[4].rm_so, match[4].rm_eo - match[4].rm_so);

	/* empty hostname is valid, and implied by the existence of hostinfo */
	uptr->hostname = ap_pstrndup (p, uptr->hostinfo+match[5].rm_so, match[5].rm_eo - match[5].rm_so);

	if (match[6].rm_so != match[6].rm_eo) {
	    /* Note that the port string can be empty.
	     * If it is, we use the default port associated with the scheme
	     */
	    uptr->port_str = ap_pstrndup (p, uptr->hostinfo+match[7].rm_so, match[7].rm_eo - match[7].rm_so);
	    if (uptr->port_str[0] != '\0') {
		char *endstr;
		int port;

		port = strtol(uptr->port_str, &endstr, 10);
		uptr->port = port;
		if (*endstr != '\0') {
		    /* Invalid characters after ':' found */
		    return HTTP_BAD_REQUEST;
		}
	    }
	    else {
		uptr->port = uptr->scheme ? ap_default_port_for_scheme(uptr->scheme) : DEFAULT_HTTP_PORT;
	    }
	}
d481 1
a481 1
	ret = HTTP_OK;
d497 5
a501 5
#define T_COLON		0x01	/* ':' */
#define T_SLASH		0x02	/* '/' */
#define T_QUESTION	0x04	/* '?' */
#define T_HASH		0x08	/* '#' */
#define T_NUL		0x80	/* '\0' */
d508 1
a508 1
	then we're not at a delimiter for foobar
d515 3
a517 3
#define NOTEND_SCHEME	(0xff)
#define NOTEND_HOSTINFO	(T_SLASH | T_QUESTION | T_HASH | T_NUL)
#define NOTEND_PATH	(T_QUESTION | T_HASH | T_NUL)
d532 2
a533 1
API_EXPORT(int) ap_parse_uri_components(pool *p, const char *uri, uri_components *uptr)
d544 1
a544 1
    memset (uptr, '\0', sizeof(*uptr));
d552 29
a580 29
deal_with_path:
	/* we expect uri to point to first character of path ... remember
	 * that the path could be empty -- http://foobar?query for example
	 */
	s = uri;
	while ((uri_delims[*(unsigned char *)s] & NOTEND_PATH) == 0) {
	    ++s;
	}
	if (s != uri) {
	    uptr->path = ap_pstrndup(p, uri, s - uri);
	}
	if (*s == 0) {
	    return HTTP_OK;
	}
	if (*s == '?') {
	    ++s;
	    s1 = strchr(s, '#');
	    if (s1) {
		uptr->fragment = ap_pstrdup(p, s1 + 1);
		uptr->query = ap_pstrndup(p, s, s1 - s);
	    }
	    else {
		uptr->query = ap_pstrdup(p, s);
	    }
	    return HTTP_OK;
	}
	/* otherwise it's a fragment */
	uptr->fragment = ap_pstrdup(p, s + 1);
	return HTTP_OK;
d585 2
a586 2
    while ((uri_delims[*(unsigned char *)s] & NOTEND_SCHEME) == 0) {
	++s;
d590 1
a590 1
	goto deal_with_path;	/* backwards predicted taken! */
d596 2
a597 2
    while ((uri_delims[*(unsigned char *)s] & NOTEND_HOSTINFO) == 0) {
	++s;
d599 1
a599 1
    uri = s;	/* whatever follows hostinfo is start of uri */
d608 1
a608 1
	--s;
d611 25
a635 25
	/* again we want the common case to be fall through */
deal_with_host:
	/* We expect hostinfo to point to the first character of
	 * the hostname.  If there's a port it is the first colon.
	 */
	s = memchr(hostinfo, ':', uri - hostinfo);
	if (s == NULL) {
	    /* we expect the common case to have no port */
	    uptr->hostname = ap_pstrndup(p, hostinfo, uri - hostinfo);
	    goto deal_with_path;
	}
	uptr->hostname = ap_pstrndup(p, hostinfo, s - hostinfo);
	++s;
	uptr->port_str = ap_pstrndup(p, s, uri - s);
	if (uri != s) {
	    port = strtol(uptr->port_str, &endstr, 10);
	    uptr->port = port;
	    if (*endstr == '\0') {
		goto deal_with_path;
	    }
	    /* Invalid characters after ':' found */
	    return HTTP_BAD_REQUEST;
	}
	uptr->port = ap_default_port_for_scheme(uptr->scheme);
	goto deal_with_path;
d641 3
a643 3
	uptr->user = ap_pstrndup(p, hostinfo, s1 - hostinfo);
	++s1;
	uptr->password = ap_pstrndup(p, s1, s - s1);
d646 1
a646 1
	uptr->user = ap_pstrndup(p, hostinfo, s - hostinfo);
d657 2
a658 1
API_EXPORT(int) ap_parse_hostinfo_components(pool *p, const char *hostinfo, uri_components *uptr)
d666 1
a666 1
    memset (uptr, '\0', sizeof(*uptr));
d675 1
a675 1
	return HTTP_BAD_REQUEST;
d681 5
a685 5
	uptr->port = strtol(uptr->port_str, &endstr, 10);
	if (*endstr == '\0') {
	    return HTTP_OK;
	}
	/* Invalid characters after ':' found */
@


1.2
log
@Apache 1.3.4 merge
@
text
@d189 7
d199 2
a200 2
			uptr->port_str ? ":" : "",
			uptr->port_str ? uptr->port_str : "",
d276 2
a277 2
    re_str    = "^(([^:]*)(:(.*))?@@)?([^@@:]*)(:(.*))?$";
    /*             ^^user^ :pw      ^host^   port */
d316 1
a316 1
    ret = regexec(&re_uri, uri, re_uri.re_nsub + 1, match, 0);
d320 1
a320 1
                    "regexec() could not parse uri (\"%s\")",
d346 1
a346 1
	ret = regexec(&re_hostpart, uptr->hostinfo, re_hostpart.re_nsub + 1, match, 0);
d349 1
a349 1
                    "regexec() could not parse (\"%s\") as host part",
d355 3
a357 3
	/* $          12      3 4        5       6 7    */
	/*        = "^(([^:]*)(:(.*))?@@)?([^@@:]*)(:(.*))?$" */
	/*             ^^user^ :pw      ^host^   port */
d381 1
a381 1
		if (*endstr != '\0' || uptr->port != port) {
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1998 The Apache Group.  All rights reserved.
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 22
a37 20
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d39 7
a45 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d49 6
a54 7
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
d64 1
a64 1
#include "http_conf_globals.h"  /* for user_id & group_id */
d71 5
a75 4
static schemes_t schemes[] = {
    {"http", DEFAULT_HTTP_PORT},
    {"ftp", DEFAULT_FTP_PORT},
    {"https", DEFAULT_HTTPS_PORT},
d77 3
a79 3
    {"wais", DEFAULT_WAIS_PORT},
    {"nntp", DEFAULT_NNTP_PORT},
    {"snews", DEFAULT_SNEWS_PORT},
d81 1
a81 1
    {NULL, 0xFFFF}              /* unknown port */
a88 3
    if (scheme_str == NULL)
        return 0;

d90 2
a91 2
        if (strcasecmp(scheme_str, scheme->name) == 0)
            return scheme->default_port;
d99 2
a100 2
        ? ap_default_port_for_scheme(r->parsed_uri.scheme)
        : 0;
d110 2
a111 2
    char **ptrs;
    char **aliases;
d113 1
a113 1
    int i = 0, j = 0;
d116 1
a116 1
        return NULL;
d120 2
a121 2
        for (; hp->h_aliases[j] != NULL; ++j)
            continue;
d125 2
a126 2
        for (; hp->h_addr_list[i] != NULL; ++i)
            continue;
d130 3
a132 3
    aliases = (char **) ap_palloc(p, (j + 1) * sizeof(char *));
    ptrs = (char **) ap_palloc(p, (i + 1) * sizeof(char *));
    addrs = (struct in_addr *) ap_palloc(p, (i + 1) * sizeof(struct in_addr));
d137 1
a137 1
    newent->h_addr_list = (char **) ptrs;
d141 1
a141 1
        aliases[j] = ap_pstrdup(p, hp->h_aliases[j]);
d147 2
a148 2
        ptrs[i] = (char *) &addrs[i];
        addrs[i] = *(struct in_addr *) hp->h_addr_list[i];
a168 1
 * See also RFC 2396.
d170 5
a174 11
API_EXPORT(char *) ap_unparse_uri_components(pool *p,
                                             const uri_components * uptr,
                                             unsigned flags)
{
    char *parts[16];     /* 16 distinct parts of a URI */
    char *scheme = NULL; /* to hold the scheme without modifying const args */
    int j = 0;           /* an index into parts */
    
    memset(parts, 0, sizeof(parts));
        
    /* If suppressing the site part, omit all of scheme://user:pass@@host:port */
d177 19
a195 53
        /* if the user passes in a scheme, we'll assume an absoluteURI */
        if (uptr->scheme) {
            scheme = uptr->scheme;
            
            parts[j++] = uptr->scheme;
            parts[j++] = ":";
        }
        
        /* handle the hier_part */
        if (uptr->user || uptr->password || uptr->hostname) {
            
            /* this stuff requires absoluteURI, so we have to add the scheme */
            if (!uptr->scheme) {
                scheme = DEFAULT_URI_SCHEME;
                
                parts[j++] = DEFAULT_URI_SCHEME;
                parts[j++] = ":";
            }
            
            parts[j++] = "//";
            
            /* userinfo requires hostport */
            if (uptr->hostname && (uptr->user || uptr->password)) {
                if (uptr->user && !(flags & UNP_OMITUSER))
                    parts[j++] = uptr->user;
                
                if (uptr->password && !(flags & UNP_OMITPASSWORD)) {
                    parts[j++] = ":";

                    if (flags & UNP_REVEALPASSWORD)
                        parts[j++] = uptr->password;
                    else
                        parts[j++] = "XXXXXXXX";
                }    

                parts[j++] = "@@";
            }                
            
            /* If we get here, there must be a hostname. */
            parts[j++] = uptr->hostname;
            
            /* Emit the port.  A small beautification
             * prevents http://host:80/ and similar visual blight.
             */
            if (uptr->port_str &&
                !(uptr->port   &&
                  scheme       &&
                  uptr->port == ap_default_port_for_scheme(scheme))) {

                parts[j++] = ":";
                parts[j++] = uptr->port_str;
            }
        }
d197 2
a198 1
        
d200 188
a387 42
        
        
        /* We must ensure we don't put out a hier_part and a rel_path */
        if (j && uptr->path && *uptr->path != '/')
            parts[j++] = "/";
        
        if (uptr->path != NULL)
            parts[j++] = uptr->path;

        if (!(flags & UNP_OMITQUERY)) {
            if (uptr->query) {
                parts[j++] = "?";
                parts[j++] = uptr->query;
            }
            
            if (uptr->fragment) {
                parts[j++] = "#";
                parts[j++] = uptr->fragment;
            }
        }
    }

    /* Ugly, but correct and probably faster than ap_vsnprintf. */
    return ap_pstrcat(p,
        parts[0],
        parts[1],
        parts[2],
        parts[3],
        parts[4],
        parts[5],
        parts[6],
        parts[7],
        parts[8],
        parts[9],
        parts[10],
        parts[11],
        parts[12],
        parts[13],
        parts[14],
        parts[15],
        NULL
    );
d389 1
d402 5
a406 5
#define T_COLON         0x01    /* ':' */
#define T_SLASH         0x02    /* '/' */
#define T_QUESTION      0x04    /* '?' */
#define T_HASH          0x08    /* '#' */
#define T_NUL           0x80    /* '\0' */
d413 1
a413 1
        then we're not at a delimiter for foobar
d420 3
a422 3
#define NOTEND_SCHEME   (0xff)
#define NOTEND_HOSTINFO (T_SLASH | T_QUESTION | T_HASH | T_NUL)
#define NOTEND_PATH     (T_QUESTION | T_HASH | T_NUL)
d426 1
a426 4
    /* Nothing to do - except....
       UTIL_URI_REGEX was removed, but third parties may depend on this symbol
       being present. So, we'll leave it in.... - vjo
     */
d437 1
a437 2
API_EXPORT(int) ap_parse_uri_components(pool *p, const char *uri,
                                        uri_components * uptr)
d448 1
a448 1
    memset(uptr, '\0', sizeof(*uptr));
d456 29
a484 29
      deal_with_path:
        /* we expect uri to point to first character of path ... remember
         * that the path could be empty -- http://foobar?query for example
         */
        s = uri;
        while ((uri_delims[*(unsigned char *) s] & NOTEND_PATH) == 0) {
            ++s;
        }
        if (s != uri) {
            uptr->path = ap_pstrndup(p, uri, s - uri);
        }
        if (*s == 0) {
            return HTTP_OK;
        }
        if (*s == '?') {
            ++s;
            s1 = strchr(s, '#');
            if (s1) {
                uptr->fragment = ap_pstrdup(p, s1 + 1);
                uptr->query = ap_pstrndup(p, s, s1 - s);
            }
            else {
                uptr->query = ap_pstrdup(p, s);
            }
            return HTTP_OK;
        }
        /* otherwise it's a fragment */
        uptr->fragment = ap_pstrdup(p, s + 1);
        return HTTP_OK;
d489 2
a490 2
    while ((uri_delims[*(unsigned char *) s] & NOTEND_SCHEME) == 0) {
        ++s;
d494 1
a494 1
        goto deal_with_path;    /* backwards predicted taken! */
d500 2
a501 2
    while ((uri_delims[*(unsigned char *) s] & NOTEND_HOSTINFO) == 0) {
        ++s;
d503 1
a503 1
    uri = s;                    /* whatever follows hostinfo is start of uri */
d512 1
a512 1
        --s;
d515 25
a539 25
        /* again we want the common case to be fall through */
      deal_with_host:
        /* We expect hostinfo to point to the first character of
         * the hostname.  If there's a port it is the first colon.
         */
        s = memchr(hostinfo, ':', uri - hostinfo);
        if (s == NULL) {
            /* we expect the common case to have no port */
            uptr->hostname = ap_pstrndup(p, hostinfo, uri - hostinfo);
            goto deal_with_path;
        }
        uptr->hostname = ap_pstrndup(p, hostinfo, s - hostinfo);
        ++s;
        uptr->port_str = ap_pstrndup(p, s, uri - s);
        if (uri != s) {
            port = ap_strtol(uptr->port_str, &endstr, 10);
            uptr->port = port;
            if (*endstr == '\0') {
                goto deal_with_path;
            }
            /* Invalid characters after ':' found */
            return HTTP_BAD_REQUEST;
        }
        uptr->port = ap_default_port_for_scheme(uptr->scheme);
        goto deal_with_path;
d545 3
a547 3
        uptr->user = ap_pstrndup(p, hostinfo, s1 - hostinfo);
        ++s1;
        uptr->password = ap_pstrndup(p, s1, s - s1);
d550 1
a550 1
        uptr->user = ap_pstrndup(p, hostinfo, s - hostinfo);
d561 1
a561 2
API_EXPORT(int) ap_parse_hostinfo_components(pool *p, const char *hostinfo,
                                             uri_components * uptr)
d569 1
a569 1
    memset(uptr, '\0', sizeof(*uptr));
d578 1
a578 1
        return HTTP_BAD_REQUEST;
d584 5
a588 5
        uptr->port = (unsigned short)ap_strtol(uptr->port_str, &endstr, 10);
        if (*endstr == '\0') {
            return HTTP_OK;
        }
        /* Invalid characters after ':' found */
d592 1
@


1.1.1.3
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
a165 4
#ifdef TPF
    /* get rid of compilation warning on TPF */
    struct hostent *hp = gethostbyname((char *)hostname);
#else
a166 1
#endif
@


