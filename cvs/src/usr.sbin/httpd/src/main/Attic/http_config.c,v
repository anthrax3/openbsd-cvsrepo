head	1.22;
access;
symbols
	OPENBSD_5_5:1.21.0.26
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.22
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.20
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.18
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.16
	OPENBSD_5_0:1.21.0.14
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.12
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.10
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.6
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.8
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.4
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.4
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.3
	apache_1_3_27:1.1.1.3
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.04.22.14.47.26;	author henning;	state dead;
branches;
next	1.21;

1.21
date	2008.05.14.16.11.22;	author mbalmer;	state Exp;
branches;
next	1.20;

1.20
date	2008.05.14.13.47.05;	author mbalmer;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.09.08.06.28;	author mbalmer;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.19.14.59.10;	author robert;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.22.15.07.12;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.09.12.13.09;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.21.13.11.35;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.08.09.51.23;	author david;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.07.20.23.06;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.07.07.43.13;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.15.09.40.49;	author henning;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2002.03.29.02.08.05;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.29.10.21.42;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.22.18.06;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.25.18.29.46;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.06.29.36;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.03.01.04.28.35;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.01.06.07;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	98.10.11.19.45.12;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.39;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.39;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.28.42;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.07.19.48.12;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.21.12.53.39;	author henning;	state Exp;
branches;
next	;

1.10.2.1
date	2002.11.04.14.43.30;	author jason;	state Exp;
branches;
next	;


desc
@@


1.22
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/* $OpenBSD: http_config.c,v 1.21 2008/05/14 16:11:22 mbalmer Exp $ */

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/*
 * http_config.c: once was auxillary functions for reading httpd's config
 * file and converting filenames into a namespace
 *
 * Rob McCool 
 * 
 * Wall-to-wall rewrite for Apache... commands which are part of the
 * server core can now be found next door in "http_core.c".  Now contains
 * general command loop, and functions which do bookkeeping for the new
 * Apache config stuff (modules and configuration vectors).
 *
 * rst
 *
 */

#define CORE_PRIVATE

#include "httpd.h"
#include "http_config.h"
#include "http_core.h"
#include "http_log.h"		/* for errors in parse_htaccess */
#include "http_main.h"
#include "http_request.h"	/* for default_handler (see invoke_handler) */
#include "http_conf_globals.h"	/* Sigh... */
#include "http_vhost.h"
#include "explain.h"
#include "fnmatch.h"

DEF_Explain

/****************************************************************
 *
 * We begin with the functions which deal with the linked list
 * of modules which control just about all of the server operation.
 */

/* total_modules is the number of modules that have been linked
 * into the server.
 */
static int total_modules = 0;
/* dynamic_modules is the number of modules that have been added
 * after the pre-loaded ones have been set up. It shouldn't be larger
 * than DYNAMIC_MODULE_LIMIT.
 */
static int dynamic_modules = 0;
API_VAR_EXPORT module *top_module = NULL;
API_VAR_EXPORT module **ap_loaded_modules=NULL;

typedef int (*handler_func) (request_rec *);
typedef void *(*dir_maker_func) (pool *, char *);
typedef void *(*merger_func) (pool *, void *, void *);

/* Dealing with config vectors.  These are associated with per-directory,
 * per-server, and per-request configuration, and have a void* pointer for
 * each modules.  The nature of the structure pointed to is private to the
 * module in question... the core doesn't (and can't) know.  However, there
 * are defined interfaces which allow it to create instances of its private
 * per-directory and per-server structures, and to merge the per-directory
 * structures of a directory and its subdirectory (producing a new one in
 * which the defaults applying to the base directory have been properly
 * overridden).
 */

#ifndef ap_get_module_config
API_EXPORT(void *)
ap_get_module_config(void *conf_vector, module *m)
{
	void **confv = (void **)conf_vector;
	return confv[m->module_index];
}
#endif

#ifndef ap_set_module_config
API_EXPORT(void)
ap_set_module_config(void *conf_vector, module *m, void *val)
{
	void **confv = (void **) conf_vector;
	confv[m->module_index] = val;
}
#endif

static void *
create_empty_config(pool *p)
{
	void **conf_vector = (void **)ap_pcalloc(p, sizeof(void *) *
	    (total_modules + DYNAMIC_MODULE_LIMIT));
	return (void *)conf_vector;
}

static void *
create_default_per_dir_config(pool *p)
{
	void **conf_vector = (void **)ap_pcalloc(p, sizeof(void *) * 
	    (total_modules + DYNAMIC_MODULE_LIMIT));
	module *modp;

	for (modp = top_module; modp; modp = modp->next) {
		dir_maker_func df = modp->create_dir_config;

		if (df)
			conf_vector[modp->module_index] = (*df) (p, NULL);
	}

	return (void *) conf_vector;
}

CORE_EXPORT(void *)
ap_merge_per_dir_configs(pool *p, void *base, void *new)
{
	void **conf_vector = (void **)ap_palloc(p, sizeof(void *) * total_modules);
	void **base_vector = (void **)base;
	void **new_vector = (void **)new;
	module *modp;

	for (modp = top_module; modp; modp = modp->next) {
		merger_func df = modp->merge_dir_config;
		int i = modp->module_index;

		if (df && new_vector[i])
			conf_vector[i] = (*df) (p, base_vector[i],
			    new_vector[i]);
		else
			conf_vector[i] = new_vector[i] ?
			    new_vector[i] : base_vector[i];
	}

	return (void *) conf_vector;
}

static void *
create_server_config(pool *p, server_rec *s)
{
	void **conf_vector = (void **)ap_pcalloc(p, sizeof(void *) *
	    (total_modules + DYNAMIC_MODULE_LIMIT));
	module *modp;

	for (modp = top_module; modp; modp = modp->next) {
		if (modp->create_server_config)
			conf_vector[modp->module_index] =
			    (*modp->create_server_config) (p, s);
	}

	return (void *)conf_vector;
}

static void
merge_server_configs(pool *p, void *base, void *virt)
{
	/* Can reuse the 'virt' vector for the spine of it, since we don't
	* have to deal with the moral equivalent of .htaccess files here...
	*/

	void **base_vector = (void **)base;
	void **virt_vector = (void **)virt;
	module *modp;

	for (modp = top_module; modp; modp = modp->next) {
		merger_func df = modp->merge_server_config;
		int i = modp->module_index;

		if (!virt_vector[i])
			virt_vector[i] = base_vector[i];
		else if (df)
			virt_vector[i] = (*df)(p, base_vector[i],
			    virt_vector[i]);
	}
}

CORE_EXPORT(void *)
ap_create_request_config(pool *p)
{
	return create_empty_config(p);
}

CORE_EXPORT(void *)
ap_create_per_dir_config(pool *p)
{
	return create_empty_config(p);
}

#ifdef EXPLAIN

struct {
	int	 offset;
	char	*method;
} aMethods[] = {
#define m(meth)	{ XtOffsetOf(module,meth),#meth }
	m(translate_handler),
	m(ap_check_user_id),
	m(auth_checker),
	m(type_checker),
	m(fixer_upper),
	m(logger),
	{ -1, "?" },
#undef m
};

char *
ShowMethod(module *modp, int offset)
{
	int n;
	static char buf[200];

	for (n = 0; aMethods[n].offset >= 0; ++n)
		if (aMethods[n].offset == offset)
			break;
	ap_snprintf(buf, sizeof(buf), "%s:%s", modp->name, aMethods[n].method);
	return buf;
}
#else
#define ShowMethod(modp,offset)
#endif

/****************************************************************
 *
 * Dispatch through the modules to find handlers for various phases
 * of request handling.  These are invoked by http_request.c to actually
 * do the dirty work of slogging through the module structures.
 */

/*
 * Optimized run_method routines.  The observation here is that many modules
 * have NULL for most of the methods.  So we build optimized lists of
 * everything.  If you think about it, this is really just like a sparse array
 * implementation to avoid scanning the zero entries.
 */
static const int method_offsets[] =
{
	XtOffsetOf(module, translate_handler),
	XtOffsetOf(module, ap_check_user_id),
	XtOffsetOf(module, auth_checker),
	XtOffsetOf(module, access_checker),
	XtOffsetOf(module, type_checker),
	XtOffsetOf(module, fixer_upper),
	XtOffsetOf(module, logger),
	XtOffsetOf(module, header_parser),
	XtOffsetOf(module, post_read_request)
};
#define NMETHODS	(sizeof (method_offsets)/sizeof (method_offsets[0]))

static struct {
	int translate_handler;
	int ap_check_user_id;
	int auth_checker;
	int access_checker;
	int type_checker;
	int fixer_upper;
	int logger;
	int header_parser;
	int post_read_request;
} offsets_into_method_ptrs;

/*
 * This is just one big array of method_ptrs.  It's constructed such that,
 * for example, method_ptrs[ offsets_into_method_ptrs.logger ] is the first
 * logger function.  You go one-by-one from there until you hit a NULL.
 * This structure was designed to hopefully maximize cache-coolness.
 */
static handler_func *method_ptrs;

void
ap_cleanup_method_ptrs()
{
	if (method_ptrs)
		free(method_ptrs);
}

/* routine to reconstruct all these shortcuts... called after every
 * add_module.
 * XXX: this breaks if modules dink with their methods pointers
 */
static void
build_method_shortcuts(void)
{
	module *modp;
	int how_many_ptrs;
	int i;
	int next_ptr;
	handler_func fp;

	if (method_ptrs)
		/* free up any previous set of method_ptrs */
		free(method_ptrs);

	/* first we count how many functions we have */
	how_many_ptrs = 0;
	for (modp = top_module; modp; modp = modp->next) {
		for (i = 0; i < NMETHODS; ++i) {
			if (*(handler_func *)(method_offsets[i] + (char *)modp))
				++how_many_ptrs;
		}
	}
	method_ptrs = malloc((how_many_ptrs + NMETHODS) * sizeof(handler_func));
	if (method_ptrs == NULL)
		fprintf(stderr, "Ouch!  Out of memory in "
		    "build_method_shortcuts()!\n");

	next_ptr = 0;
	for (i = 0; i < NMETHODS; ++i) {
		/* XXX: This is an itsy bit presumptuous about the alignment
		* constraints on offsets_into_method_ptrs.  I can't remember if
		* ANSI says this has to be true... -djg */
		((int *)&offsets_into_method_ptrs)[i] = next_ptr;
		for (modp = top_module; modp; modp = modp->next) {
			fp = *(handler_func *)(method_offsets[i] +
			    (char *)modp);
			if (fp)
				method_ptrs[next_ptr++] = fp;
		}
		method_ptrs[next_ptr++] = NULL;
	}
}


static int
run_method(request_rec *r, int offset, int run_all)
{
	int i;

	for (i = offset; method_ptrs[i]; ++i) {
		handler_func mod_handler = method_ptrs[i];

		if (mod_handler) {
			int result;

			result = (*mod_handler) (r);

			if (result != DECLINED && (!run_all || result != OK))
				return result;
		}
	}

	return run_all ? OK : DECLINED;
}

API_EXPORT(int)
ap_translate_name(request_rec *r)
{
	return run_method(r, offsets_into_method_ptrs.translate_handler, 0);
}

API_EXPORT(int)
ap_check_access(request_rec *r)
{
	return run_method(r, offsets_into_method_ptrs.access_checker, 1);
}

API_EXPORT(int)
ap_find_types(request_rec *r)
{
	return run_method(r, offsets_into_method_ptrs.type_checker, 0);
}

API_EXPORT(int)
ap_run_fixups(request_rec *r)
{
	return run_method(r, offsets_into_method_ptrs.fixer_upper, 1);
}

API_EXPORT(int)
ap_log_transaction(request_rec *r)
{
	return run_method(r, offsets_into_method_ptrs.logger, 1);
}

API_EXPORT(int)
ap_header_parse(request_rec *r)
{
	return run_method(r, offsets_into_method_ptrs.header_parser, 1);
}

API_EXPORT(int)
ap_run_post_read_request(request_rec *r)
{
	return run_method(r, offsets_into_method_ptrs.post_read_request, 1);
}

/* Auth stuff --- anything that defines one of these will presumably
 * want to define something for the other.  Note that check_auth is
 * separate from check_access to make catching some config errors easier.
 */

API_EXPORT(int)
ap_check_user_id(request_rec *r)
{
	return run_method(r, offsets_into_method_ptrs.ap_check_user_id, 0);
}

API_EXPORT(int)
ap_check_auth(request_rec *r)
{
	return run_method(r, offsets_into_method_ptrs.auth_checker, 0);
}

/*
 * For speed/efficiency we generate a compact list of all the handlers
 * and wildcard handlers.  This means we won't have to scan the entire
 * module list looking for handlers... where we'll find a whole whack
 * of NULLs.
 */
typedef struct {
	handler_rec	hr;
	size_t		len;
} fast_handler_rec;

static fast_handler_rec *handlers;
static fast_handler_rec *wildhandlers;

static void
init_handlers(pool *p)
{
	module *modp;
	int nhandlers = 0;
	int nwildhandlers = 0;
	const handler_rec *handp;
	fast_handler_rec *ph, *pw;
	char *starp;

	for (modp = top_module; modp; modp = modp->next) {
		if (!modp->handlers)
			continue;
		for (handp = modp->handlers; handp->content_type; ++handp) {
			if (strchr(handp->content_type, '*'))
				nwildhandlers ++;
			else
				nhandlers ++;
		}
	}
	ph = handlers = ap_palloc(p, sizeof(*ph) * (nhandlers + 1));
	pw = wildhandlers = ap_palloc(p, sizeof(*pw) * (nwildhandlers + 1));
	for (modp = top_module; modp; modp = modp->next) {
		if (!modp->handlers)
			continue;
		for (handp = modp->handlers; handp->content_type; ++handp) {
			if ((starp = strchr(handp->content_type, '*'))) {
				pw->hr.content_type = handp->content_type;
				pw->hr.handler = handp->handler;
				pw->len = starp - handp->content_type;
				pw ++;
			} else {
				ph->hr.content_type = handp->content_type;
				ph->hr.handler = handp->handler;
				ph->len = strlen(handp->content_type);
				ph ++;
			}
		}
	}
	pw->hr.content_type = NULL;
	pw->hr.handler = NULL;
	ph->hr.content_type = NULL;
	ph->hr.handler = NULL;
}

API_EXPORT(int)
ap_invoke_handler(request_rec *r)
{
	fast_handler_rec *handp;
	const char *handler;
	char *p;
	size_t handler_len;
	int result = HTTP_INTERNAL_SERVER_ERROR;

	if (r->handler) {
		handler = r->handler;
		handler_len = strlen(handler);
	} else {
		handler = r->content_type ?
		    r->content_type : ap_default_type(r);
		if ((p = strchr(handler, ';')) != NULL) {
			/* MIME type arguments */
			while (p > handler && p[-1] == ' ')
				--p;		/* strip trailing spaces */
			handler_len = p - handler;
		} else
			handler_len = strlen(handler);
	}

	/* Pass one --- direct matches */
	for (handp = handlers; handp->hr.content_type; ++handp) {
		if (handler_len == handp->len
		    && !strncmp(handler, handp->hr.content_type, handler_len)) {
			result = (*handp->hr.handler) (r);

			if (result != DECLINED)
				return result;
		}
	}

	/* Pass two --- wildcard matches */
	for (handp = wildhandlers; handp->hr.content_type; ++handp) {
		if (handler_len >= handp->len
		    && !strncmp(handler, handp->hr.content_type, handp->len)) {
			result = (*handp->hr.handler) (r);

			if (result != DECLINED)
				return result;
		}
	}

	if (result == HTTP_INTERNAL_SERVER_ERROR && r->handler && r->filename) {
		ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, r,
		    "handler \"%s\" not found for: %s", r->handler,
		    r->filename);
	}
	return HTTP_INTERNAL_SERVER_ERROR;
}

/* One-time setup for precompiled modules --- NOT to be done on restart */

API_EXPORT(void)
ap_add_module(module *m)
{
	/* This could be called from an AddModule httpd.conf command,
	* after the file has been linked and the module structure within it
	* teased out...
	*/

	if (m->version != MODULE_MAGIC_NUMBER_MAJOR) {
		fprintf(stderr, "%s: module \"%s\" is not compatible with this "
		    "version of Apache.\n", ap_server_argv0, m->name);
		fprintf(stderr, "Please contact the vendor for the correct "
		    "version.\n");
		exit(1);
	}

	if (m->next == NULL) {
		m->next = top_module;
		top_module = m;
	}
	if (m->module_index == -1) {
		m->module_index = total_modules++;
		dynamic_modules++;

		if (dynamic_modules > DYNAMIC_MODULE_LIMIT) {
			fprintf(stderr, "%s: module \"%s\" could not be "
			    "loaded, because the dynamic\n", ap_server_argv0,
			    m->name);
			fprintf(stderr, "module limit was reached. Please "
			    "increase DYNAMIC_MODULE_LIMIT and recompile.\n");
			exit(1);
		}
	}

	/* Some C compilers put a complete path into __FILE__, but we want
	* only the filename (e.g. mod_includes.c). So check for path
	* components (Unix and DOS), and remove them.
	*/

	if (strrchr(m->name, '/'))
		m->name = 1 + strrchr(m->name, '/');
	if (strrchr(m->name, '\\'))
		m->name = 1 + strrchr(m->name, '\\');

	/*
	* Invoke the `add_module' hook inside the now existing set
	* of modules to let them all now that this module was added.
	*/
	{
		module *m2;
		for (m2 = top_module; m2 != NULL; m2 = m2->next)
			if (m2->magic == MODULE_MAGIC_COOKIE_EAPI)
				if (m2->add_module != NULL)
					(*m2->add_module)(m);
	}
}

/* 
 * remove_module undoes what add_module did. There are some caveats:
 * when the module is removed, its slot is lost so all the current
 * per-dir and per-server configurations are invalid. So we should
 * only ever call this function when you are invalidating almost
 * all our current data. I.e. when doing a restart.
 */

API_EXPORT(void)
ap_remove_module(module *m)
{
	module *modp;

	/*
	* Invoke the `remove_module' hook inside the now existing
	* set of modules to let them all now that this module is
	* beeing removed.
	*/
	{
		module *m2;
		for (m2 = top_module; m2 != NULL; m2 = m2->next)
			if (m2->magic == MODULE_MAGIC_COOKIE_EAPI)
				if (m2->remove_module != NULL)
					(*m2->remove_module)(m);
	}

	modp = top_module;
	if (modp == m) {
		/* We are the top module, special case */
		top_module = modp->next;
		m->next = NULL;
	} else {
		/* Not the top module, find use. When found modp will
		* point to the module _before_ us in the list
		*/

		while (modp && modp->next != m)
			modp = modp->next;

		if (!modp) {
			/* Uh-oh, this module doesn't exist */
			ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, NULL,
			    "Cannot remove module %s: not found in module list",
			    m->name);
			return;
		}
		/* Eliminate us from the module list */
		modp->next = modp->next->next;
	}

	m->module_index = -1;	/* simulate being unloaded, should
	 * be unnecessary */
	dynamic_modules--;
	total_modules--;
}

API_EXPORT(void)
ap_add_loaded_module(module *mod)
{
	module **m;

	/* 
	*  Add module pointer to top of chained module list 
	*/
	ap_add_module(mod);

	/* 
	*  And module pointer to list of loaded modules 
	*
	*  Notes: 1. ap_add_module() would already complain if no more space
	*            exists for adding a dynamically loaded module
	*         2. ap_add_module() accepts double-inclusion, so we have
	*            to accept this, too.
	*/
	for (m = ap_loaded_modules; *m != NULL; m++)
		;
	*m++ = mod;
	*m = NULL;
}

API_EXPORT(void)
ap_remove_loaded_module(module *mod)
{
	module **m;
	module **m2;
	int done;

	/* 
	*  Remove module pointer from chained module list 
	*/
	ap_remove_module(mod);

	/* 
	*  Remove module pointer from list of loaded modules
	*
	*  Note: 1. We cannot determine if the module was successfully
	*           removed by ap_remove_module().
	*        2. We have not to complain explicity when the module
	*           is not found because ap_remove_module() did it
	*           for us already.
	*/
	for (m = m2 = ap_loaded_modules, done = 0; *m2 != NULL; m2++) {
		if (*m2 == mod && done == 0)
			done = 1;
		else
			*m++ = *m2;
	}
	*m = NULL;
}

API_EXPORT(void)
ap_setup_prelinked_modules(void)
{
	module **m;
	module **m2;

	/*
	*  Initialise total_modules variable and module indices
	*/
	total_modules = 0;
	for (m = ap_preloaded_modules; *m != NULL; m++)
		(*m)->module_index = total_modules++;

	/* 
	*  Initialise list of loaded modules
	*/
	ap_loaded_modules = (module **)malloc(
	sizeof(module *)*(total_modules+DYNAMIC_MODULE_LIMIT+1));
	if (ap_loaded_modules == NULL) {
		fprintf(stderr, "Ouch!  Out of memory in "
		    "ap_setup_prelinked_modules()!\n");
		exit(1);
	}
	for (m = ap_preloaded_modules, m2 = ap_loaded_modules; *m != NULL; )
		*m2++ = *m++;
	*m2 = NULL;

	/*
	*   Initialize chain of linked (=activate) modules
	*/
	for (m = ap_prelinked_modules; *m != NULL; m++)
		ap_add_module(*m);
}

API_EXPORT(const char *)
ap_find_module_name(module *m)
{
	return m->name;
}

API_EXPORT(module *)
ap_find_linked_module(const char *name)
{
	module *modp;

	for (modp = top_module; modp; modp = modp->next) {
		if (strcmp(modp->name, name) == 0)
			return modp;
	}
	return NULL;
}

/* Add a named module.  Returns 1 if module found, 0 otherwise.  */
API_EXPORT(int)
ap_add_named_module(const char *name)
{
	module *modp;
	int i = 0;

	for (modp = ap_loaded_modules[i]; modp; modp = ap_loaded_modules[++i]) {
		if (strcmp(modp->name, name) == 0) {
			/* Only add modules that are not already enabled.  */
			if (modp->next == NULL)
				ap_add_module(modp);
			return 1;
		}
	}
	return 0;
}

/* Clear the internal list of modules, in preparation for starting over. */
API_EXPORT(void)
ap_clear_module_list()
{
	module **m = &top_module;
	module **next_m;

	while (*m) {
		next_m = &((*m)->next);
		*m = NULL;
		m = next_m;
	}

	/* This is required; so we add it always.  */
	ap_add_named_module("http_core.c");
}

/*****************************************************************
 *
 * Resource, access, and .htaccess config files now parsed by a common
 * command loop.
 *
 * Let's begin with the basics; parsing the line and
 * invoking the function...
 */

static const char *
invoke_cmd(const command_rec *cmd, cmd_parms *parms, void *mconfig,
    const char *args)
{
	char *w, *w2, *w3;
	const char *errmsg;

	if ((parms->override & cmd->req_override) == 0)
		return ap_pstrcat(parms->pool, cmd->name, " not allowed here",
		    NULL);

	parms->info = cmd->cmd_data;
	parms->cmd = cmd;

	switch (cmd->args_how) {
	case RAW_ARGS:
		return ((const char *(*)(cmd_parms *, void *, const char *))
		    (cmd->func))(parms, mconfig, args);

	case NO_ARGS:
		if (*args != 0)
			return ap_pstrcat(parms->pool, cmd->name,
			    " takes no arguments", NULL);

		return ((const char *(*)(cmd_parms *, void *))
		    (cmd->func))(parms, mconfig);

	case TAKE1:
		w = ap_getword_conf(parms->pool, &args);

		if (*w == '\0' || *args != 0)
			return ap_pstrcat(parms->pool, cmd->name,
			    " takes one argument", cmd->errmsg ? ", " : NULL,
			    cmd->errmsg, NULL);

		return ((const char *(*)(cmd_parms *, void *, const char *))
		    (cmd->func))(parms, mconfig, w);

	case TAKE2:
		w = ap_getword_conf(parms->pool, &args);
		w2 = ap_getword_conf(parms->pool, &args);

		if (*w == '\0' || *w2 == '\0' || *args != 0)
			return ap_pstrcat(parms->pool, cmd->name,
			    " takes two arguments", cmd->errmsg ? ", " : NULL,
			    cmd->errmsg, NULL);

		return ((const char *(*)(cmd_parms *, void *, const char *,
		    const char *))(cmd->func))(parms, mconfig, w, w2);

	case TAKE12:
		w = ap_getword_conf(parms->pool, &args);
		w2 = ap_getword_conf(parms->pool, &args);

		if (*w == '\0' || *args != 0)
			return ap_pstrcat(parms->pool, cmd->name,
			    " takes 1-2 arguments", cmd->errmsg ? ", " : NULL,
			    cmd->errmsg, NULL);

		return ((const char *(*)(cmd_parms *, void *, const char *,
		    const char *))(cmd->func))(parms, mconfig, w,
		    *w2 ? w2 : NULL);

	case TAKE3:
		w = ap_getword_conf(parms->pool, &args);
		w2 = ap_getword_conf(parms->pool, &args);
		w3 = ap_getword_conf(parms->pool, &args);

		if (*w == '\0' || *w2 == '\0' || *w3 == '\0' || *args != 0)
			return ap_pstrcat(parms->pool, cmd->name,
			    " takes three arguments",
			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);

		return ((const char *(*)(cmd_parms *, void *, const char *,
		    const char *, const char *))(cmd->func))(parms, mconfig,
		    w, w2, w3);

	case TAKE23:
		w = ap_getword_conf(parms->pool, &args);
		w2 = ap_getword_conf(parms->pool, &args);
		w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;

		if (*w == '\0' || *w2 == '\0' || *args != 0)
			return ap_pstrcat(parms->pool, cmd->name,
			    " takes two or three arguments",
			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);

		return ((const char *(*)(cmd_parms *, void *, const char *,
		    const char *, const char *)) (cmd->func)) (parms,
		    mconfig, w, w2, w3);

	case TAKE123:
		w = ap_getword_conf(parms->pool, &args);
		w2 = *args ? ap_getword_conf(parms->pool, &args) : NULL;
		w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;

		if (*w == '\0' || *args != 0)
			return ap_pstrcat(parms->pool, cmd->name,
			    " takes one, two or three arguments",
			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);

		return ((const char *(*)(cmd_parms *, void *, const char *,
		    const char *, const char *))(cmd->func))(parms, mconfig,
		    w, w2, w3);

	case TAKE13:
		w = ap_getword_conf(parms->pool, &args);
		w2 = *args ? ap_getword_conf(parms->pool, &args) : NULL;
		w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;

		if (*w == '\0' || (w2 && *w2 && !w3) || *args != 0)
			return ap_pstrcat(parms->pool, cmd->name,
			    " takes one or three arguments",
			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);

		return ((const char *(*)(cmd_parms *, void *, const char *,
		    const char *, const char *))(cmd->func))(parms,
		    mconfig, w, w2, w3);

	case ITERATE:
		while (*(w = ap_getword_conf(parms->pool, &args)) != '\0')
			if ((errmsg = ((const char *(*)(cmd_parms *, void *,
			    const char *))(cmd->func))(parms, mconfig, w)))
				return errmsg;

		return NULL;

	case ITERATE2:
		w = ap_getword_conf(parms->pool, &args);

		if (*w == '\0' || *args == 0)
			return ap_pstrcat(parms->pool, cmd->name,
			    " requires at least two arguments",
			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);


		while (*(w2 = ap_getword_conf(parms->pool, &args)) != '\0')
			if   ((errmsg = ((const char *(*)(cmd_parms *, void *,
			    const char *, const char *)) (cmd->func)) (parms,
			    mconfig, w, w2)))
				return errmsg;

		return NULL;

	case FLAG:
		w = ap_getword_conf(parms->pool, &args);

		if (*w == '\0' || (strcasecmp(w, "on") && strcasecmp(w, "off")))
			return ap_pstrcat(parms->pool, cmd->name,
			    " must be On or Off", NULL);

		return ((const char *(*)(cmd_parms *, void *, int))
		    (cmd->func))(parms, mconfig, strcasecmp(w, "off") != 0);

	default:
		return ap_pstrcat(parms->pool, cmd->name,
		    " is improperly configured internally (server bug)", NULL);
	}
}

CORE_EXPORT(const command_rec *)
ap_find_command(const char *name, const command_rec *cmds)
{
	while (cmds->name)
		if (!strcasecmp(name, cmds->name))
			return cmds;
		else
			++cmds;

	return NULL;
}

CORE_EXPORT(const command_rec *)
ap_find_command_in_modules(const char *cmd_name, module **mod)
{
	const command_rec *cmdp;
	module *modp;

	for (modp = *mod; modp; modp = modp->next)
		if (modp->cmds &&
		    (cmdp = ap_find_command(cmd_name, modp->cmds))) {
			*mod = modp;
			return cmdp;
		}

	return NULL;
}

CORE_EXPORT(void *)
ap_set_config_vectors(cmd_parms *parms, void *config, module *mod)
{
	void *mconfig = ap_get_module_config(config, mod);
	void *sconfig = ap_get_module_config(parms->server->module_config, mod);

	if (!mconfig && mod->create_dir_config) {
		mconfig = (*mod->create_dir_config)(parms->pool, parms->path);
		ap_set_module_config(config, mod, mconfig);
	}

	if (!sconfig && mod->create_server_config) {
		sconfig = (*mod->create_server_config)(parms->pool,
		    parms->server);
		ap_set_module_config(parms->server->module_config, mod,
		    sconfig);
	}
	return mconfig;
}

CORE_EXPORT(const char *)
ap_handle_command(cmd_parms *parms, void *config, const char *l)
{
	void *oldconfig;
	const char *args, *cmd_name, *retval;
	const command_rec *cmd;
	module *mod = top_module;

	/*
	* Invoke the `rewrite_command' of modules to allow
	* they to rewrite the directive line before we
	* process it.
	*/
	{
		module *m;
		char *cp;
		for (m = top_module; m != NULL; m = m->next) {
			if (m->magic == MODULE_MAGIC_COOKIE_EAPI) {
				if (m->rewrite_command != NULL) {
					cp = (m->rewrite_command)(parms,
					    config, l);
					if (cp != NULL)
						l = cp;
				}
			}
		}
	}

	if ((l[0] == '#') || (!l[0]))
		return NULL;

	args = l;
	cmd_name = ap_getword_conf(parms->temp_pool, &args);
	if (*cmd_name == '\0')
		return NULL;

	oldconfig = parms->context;
	parms->context = config;
	do {
		if (!(cmd = ap_find_command_in_modules(cmd_name, &mod))) {
			errno = EINVAL;
			return ap_pstrcat(parms->pool, "Invalid command '",
			    cmd_name, "', perhaps mis-spelled or defined by "
			    "a module not included in the server configuration",
			    NULL);
		} else {
			void *mconfig = ap_set_config_vectors(parms,config,
			    mod);

			retval = invoke_cmd(cmd, parms, mconfig, args);
			mod = mod->next;	/* Next time around, 
						 * skip this one
						 */
		}
	} while (retval && !strcmp(retval, DECLINE_CMD));
	parms->context = oldconfig;

	return retval;
}

API_EXPORT(const char *)
ap_srm_command_loop(cmd_parms *parms, void *config)
{
	char l[MAX_STRING_LEN];

	while (!(ap_cfg_getline(l, MAX_STRING_LEN, parms->config_file))) {
		const char *errmsg = ap_handle_command(parms, config, l);
		if (errmsg)
			return errmsg;
	}

	return NULL;
}

/*
 * Generic command functions...
 */

API_EXPORT_NONSTD(const char *)
ap_set_string_slot(cmd_parms *cmd, char *struct_ptr, char *arg)
{
	/* This one's pretty generic... */

	int offset = (int)(long)cmd->info;
	*(char **)(struct_ptr + offset) = arg;
	return NULL;
}

API_EXPORT_NONSTD(const char *)
ap_set_string_slot_lower(cmd_parms *cmd, char *struct_ptr, char *arg)
{
	/* This one's pretty generic... */

	int offset = (int)(long)cmd->info;
	ap_str_tolower(arg);
	*(char **)(struct_ptr + offset) = arg;
	return NULL;
}

API_EXPORT_NONSTD(const char *)
ap_set_flag_slot(cmd_parms *cmd, char *struct_ptr, int arg)
{
	/* This one's pretty generic too... */

	int offset = (int)(long)cmd->info;
	*(int *)(struct_ptr + offset) = arg ? 1 : 0;
	return NULL;
}

API_EXPORT_NONSTD(const char *)
ap_set_file_slot(cmd_parms *cmd, char *struct_ptr, char *arg)
{
	/* Prepend server_root to relative arg.
	This allows .htaccess to be independent of server_root,
	so the server can be moved or mirrored with less pain.  */
	char *p;
	int offset = (int)(long)cmd->info;
	arg = ap_os_canonical_filename(cmd->pool, arg);
	if (ap_os_is_path_absolute(arg))
		p = arg;
	else
		p = ap_make_full_path(cmd->pool, ap_server_root, arg);
	*(char **)(struct_ptr + offset) = p;
	return NULL;
}

/*****************************************************************
 *
 * Reading whole config files...
 */

static cmd_parms default_parms =
    {NULL, 0, -1, NULL, NULL, NULL, NULL, NULL, NULL, NULL};

API_EXPORT(char *)
ap_server_root_relative(pool *p, char *file)
{
	file = ap_os_canonical_filename(p, file);
	if(ap_os_is_path_absolute(file))
		return file;
	return ap_make_full_path(p, ap_server_root, file);
}


/* This structure and the following functions are needed for the
 * table-based config file reading. They are passed to the
 * cfg_open_custom() routine.
 */

/* Structure to be passed to cfg_open_custom(): it contains an
 * index which is incremented from 0 to nelts on each call to
 * cfg_getline() (which in turn calls arr_elts_getstr())
 * and an array_header pointer for the string array.
 */
typedef struct {
	array_header	*array;
	int		 curr_idx;
} arr_elts_param_t;


/* arr_elts_getstr() returns the next line from the string array. */
static void *
arr_elts_getstr(void *buf, size_t bufsiz, void *param)
{
	arr_elts_param_t *arr_param = (arr_elts_param_t *) param;

	/* End of array reached? */
	if (++arr_param->curr_idx > arr_param->array->nelts)
		return NULL;

	/* return the line */
	ap_cpystrn(buf,
	    ((char **)arr_param->array->elts)[arr_param->curr_idx - 1], bufsiz);

	return buf;
}


/* arr_elts_close(): dummy close routine (makes sure no more lines can be read) */
static int
arr_elts_close(void *param)
{
	arr_elts_param_t *arr_param = (arr_elts_param_t *)param;
	arr_param->curr_idx = arr_param->array->nelts;
	return 0;
}

static void
process_command_config(server_rec *s, array_header *arr, pool *p, pool *ptemp)
{
	const char *errmsg;
	cmd_parms parms;
	arr_elts_param_t arr_parms;

	arr_parms.curr_idx = 0;
	arr_parms.array = arr;

	parms = default_parms;
	parms.pool = p;
	parms.temp_pool = ptemp;
	parms.server = s;
	parms.override = (RSRC_CONF | OR_ALL) & ~(OR_AUTHCFG | OR_LIMIT);
	parms.config_file = ap_pcfg_open_custom(p, "-c/-C directives",
	    &arr_parms, NULL, arr_elts_getstr, arr_elts_close);

	errmsg = ap_srm_command_loop(&parms, s->lookup_defaults);

	if (errmsg) {
		fprintf(stderr, "Syntax error in -C/-c directive:\n%s\n",
		    errmsg);
		exit(1);
	}

	ap_cfg_closefile(parms.config_file);
}

typedef struct {
	char *fname;
} fnames;

static int
fname_alphasort(const void *fn1, const void *fn2)
{
	const fnames *f1 = fn1;
	const fnames *f2 = fn2;

	return strcmp(f1->fname,f2->fname);
}

CORE_EXPORT(void)
ap_process_resource_config(server_rec *s, char *fname, pool *p, pool *ptemp)
{
	const char *errmsg;
	cmd_parms parms;
	struct stat finfo;
	int ispatt;
	fname = ap_server_root_relative(p, fname);

	if (!(strcmp(fname, ap_server_root_relative(p, RESOURCE_CONFIG_FILE)))
	    || !(strcmp(fname, ap_server_root_relative(p, ACCESS_CONFIG_FILE))))
		if (stat(fname, &finfo) == -1)
			return;

	/* if we are already chrooted here, it's a restart. strip chroot
	 * then. */
	ap_server_strip_chroot(fname, 0);

	/* don't require conf/httpd.conf if we have a -C or -c switch */
	if((ap_server_pre_read_config->nelts
	    || ap_server_post_read_config->nelts)
	    && !(strcmp(fname, ap_server_root_relative(p, SERVER_CONFIG_FILE))))
		if (stat(fname, &finfo) == -1)
			return;

	/* 
	* here we want to check if the candidate file is really a
	* directory, and most definitely NOT a symlink (to prevent
	* horrible loops).  If so, let's recurse and toss it back into
	* the function.
	*/
	ispatt = ap_is_fnmatch(fname);
	if (ispatt || ap_is_rdirectory(fname)) {
		DIR *dirp;
		struct DIR_TYPE *dir_entry;
		int current;
		array_header *candidates = NULL;
		fnames *fnew;
		char *path = ap_pstrdup(p,fname);
		char *pattern = NULL;

		if(ispatt && (pattern = strrchr(path, '/')) != NULL) {
			*pattern++ = '\0';
			if (ap_is_fnmatch(path)) {
				fprintf(stderr, "%s: wildcard patterns not "
				    "allowed in Include %s\n", ap_server_argv0,
				    fname);
				exit(1);
			}

			if (!ap_is_rdirectory(path)){ 
				fprintf(stderr, "%s: Include directory '%s' "
				    "not found", ap_server_argv0, path);
				exit(1);
			}
			if (!ap_is_fnmatch(pattern)) {
				fprintf(stderr, "%s: must include a wildcard "
				    "pattern for Include %s\n", ap_server_argv0,
				    fname);
				exit(1);
			}
		}


		/*
		* first course of business is to grok all the directory
		* entries here and store 'em away. Recall we need full
		* pathnames for this.
		*/
		if (ap_configtestonly)
			fprintf(stdout, "Processing config directory: %s\n",
			    fname);
		dirp = ap_popendir(p, path);
		if (dirp == NULL) {
			perror("fopen");
			fprintf(stderr, "%s: could not open config directory "
			    "%s\n", ap_server_argv0, path);
			exit(1);
		}
		candidates = ap_make_array(p, 1, sizeof(fnames));
		while ((dir_entry = readdir(dirp)) != NULL) {
			/* strip out '.' and '..' */
			if (strcmp(dir_entry->d_name, ".") &&
			strcmp(dir_entry->d_name, "..") &&
			(!ispatt ||
			!ap_fnmatch(pattern,dir_entry->d_name, FNM_PERIOD))) {
				fnew = (fnames *) ap_push_array(candidates);
				fnew->fname = ap_make_full_path(p, path,
				    dir_entry->d_name);
			}
		}
		ap_pclosedir(p, dirp);
		if (candidates->nelts != 0) {
			qsort((void *)candidates->elts, candidates->nelts,
			    sizeof(fnames), fname_alphasort);
			/*
			* Now recurse these... we handle errors and
			* subdirectories via the recursion, which is nice
			*/
			for (current = 0; current < candidates->nelts;
			    ++current) {
				fnew = &((fnames *) candidates->elts)[current];
				if (ap_configtestonly)
					fprintf(stdout, " Processing config "
					    "file: %s\n", fnew->fname);
				ap_process_resource_config(s, fnew->fname, p,
				    ptemp);
			}
		}
		return;
	}
    
	/* GCC's initialization extensions are soooo nice here... */

	parms = default_parms;
	parms.pool = p;
	parms.temp_pool = ptemp;
	parms.server = s;
	parms.override = (RSRC_CONF | OR_ALL) & ~(OR_AUTHCFG | OR_LIMIT);

	if (!(parms.config_file = ap_pcfg_openfile(p,fname))) {
		perror("fopen");
		fprintf(stderr, "%s: could not open document config file %s\n",
		    ap_server_argv0, fname);
		exit(1);
	}

	errmsg = ap_srm_command_loop(&parms, s->lookup_defaults);

	if (errmsg) {
		fprintf(stderr, "Syntax error on line %d of %s:\n",
		    parms.config_file->line_number, parms.config_file->name);
		fprintf(stderr, "%s\n", errmsg);
		exit(1);
	}

	ap_cfg_closefile(parms.config_file);
}

CORE_EXPORT(int)
ap_parse_htaccess(void **result, request_rec *r, int override, const char *d,
const char *access_name)
	{
	configfile_t *f = NULL;
	cmd_parms parms;
	const char *errmsg;
	char *filename = NULL;
	const struct htaccess_result *cache;
	struct htaccess_result *new;
	void *dc = NULL;

	/* firstly, search cache */
	for (cache = r->htaccess; cache != NULL; cache = cache->next)
		if (cache->override == override && strcmp(cache->dir, d) == 0) {
			if (cache->htaccess != NULL)
				*result = cache->htaccess;
			return OK;
		}

	parms = default_parms;
	parms.override = override;
	parms.pool = r->pool;
	parms.temp_pool = r->pool;
	parms.server = r->server;
	parms.path = ap_pstrdup(r->pool, d);

	/* loop through the access names and find the first one */

	while (access_name[0]) {
		filename = ap_make_full_path(r->pool, d,
		    ap_getword_conf(r->pool, &access_name));

		if ((f = ap_pcfg_openfile(r->pool, filename)) != NULL) {

			dc = ap_create_per_dir_config(r->pool);

			parms.config_file = f;

			errmsg = ap_srm_command_loop(&parms, dc);

			ap_cfg_closefile(f);

			if (errmsg) {
				ap_log_rerror(APLOG_MARK,
				    APLOG_ALERT|APLOG_NOERRNO, r,
				    "%s: %s", filename, errmsg);
				return HTTP_INTERNAL_SERVER_ERROR;
			}
			*result = dc;
			break;
		} else if (errno != ENOENT && errno != ENOTDIR) {
			ap_log_rerror(APLOG_MARK, APLOG_CRIT, r,
			    "%s pcfg_openfile: unable to check htaccess file, "
			    "ensure it is readable",
			    filename);
			ap_table_setn(r->notes, "error-notes",
			    "Server unable to read htaccess file, denying "
			    "access to be safe");
			return HTTP_FORBIDDEN;
		}
	}

	/* cache it */
	new = ap_palloc(r->pool, sizeof(struct htaccess_result));
	new->dir = parms.path;
	new->override = override;
	new->htaccess = dc;
	/* add to head of list */
	new->next = r->htaccess;
	r->htaccess = new;

	return OK;
}


CORE_EXPORT(const char *)
ap_init_virtual_host(pool *p, const char *hostname, server_rec *main_server,
    server_rec **ps)
{
	server_rec *s = (server_rec *) ap_pcalloc(p, sizeof(server_rec));

	struct rlimit limits;

	getrlimit(RLIMIT_NOFILE, &limits);
	if (limits.rlim_cur < limits.rlim_max) {
		limits.rlim_cur += 2;
		if (setrlimit(RLIMIT_NOFILE, &limits) < 0) {
			perror("setrlimit(RLIMIT_NOFILE)");
			fprintf(stderr, "Cannot exceed hard limit for open "
			    "files");
		}
	}

	s->server_admin = NULL;
	s->server_hostname = NULL;
	s->error_fname = NULL;
	s->srm_confname = NULL;
	s->access_confname = NULL;
	s->timeout = 0;
	s->keep_alive_timeout = 0;
	s->keep_alive = -1;
	s->keep_alive_max = -1;
	s->error_log = main_server->error_log;
	s->loglevel = main_server->loglevel;
	/* useful default, otherwise we get a port of 0 on redirects */
	s->port = main_server->port;
	s->next = NULL;

	s->is_virtual = 1;
	s->names = ap_make_array(p, 4, sizeof(char **));
	s->wild_names = ap_make_array(p, 4, sizeof(char **));

	s->module_config = create_empty_config(p);
	s->lookup_defaults = ap_create_per_dir_config(p);

	s->server_uid = ap_user_id;
	s->server_gid = ap_group_id;

	s->limit_req_line = main_server->limit_req_line;
	s->limit_req_fieldsize = main_server->limit_req_fieldsize;
	s->limit_req_fields = main_server->limit_req_fields;

	s->ctx = ap_ctx_new(p);

	*ps = s;

	return ap_parse_vhost_addrs(p, hostname, s);
}


static void
fixup_virtual_hosts(pool *p, server_rec *main_server)
{
	server_rec *virt;

	for (virt = main_server->next; virt; virt = virt->next) {
		merge_server_configs(p, main_server->module_config,
		    virt->module_config);

		virt->lookup_defaults =
		    ap_merge_per_dir_configs(p, main_server->lookup_defaults,
		    virt->lookup_defaults);

		if (virt->server_admin == NULL)
			virt->server_admin = main_server->server_admin;

		if (virt->srm_confname == NULL)
			virt->srm_confname = main_server->srm_confname;

		if (virt->access_confname == NULL)
			virt->access_confname = main_server->access_confname;

		if (virt->timeout == 0)
			virt->timeout = main_server->timeout;

		if (virt->keep_alive_timeout == 0)
			virt->keep_alive_timeout =
			    main_server->keep_alive_timeout;

		if (virt->keep_alive == -1)
			virt->keep_alive = main_server->keep_alive;

		if (virt->keep_alive_max == -1)
			virt->keep_alive_max = main_server->keep_alive_max;

		if (virt->send_buffer_size == 0)
			virt->send_buffer_size = main_server->send_buffer_size;

		/* XXX: this is really something that should be dealt with
		 * by a post-config api phase */
		ap_core_reorder_directories(p, virt);
	}
	ap_core_reorder_directories(p, main_server);
}

/*****************************************************************
 *
 * Getting *everything* configured... 
 */

static void
init_config_globals(pool *p)
{
	/* ServerRoot, server_confname set in httpd.c */

	ap_standalone = 1;
	ap_user_name = DEFAULT_USER;
	if (!ap_server_is_chrooted()) { 
		/* can't work, just keep old setting */
		ap_user_id = ap_uname2id(DEFAULT_USER);
		ap_group_id = ap_gname2id(DEFAULT_GROUP);
	}
	ap_daemons_to_start = DEFAULT_START_DAEMON;
	ap_daemons_min_free = DEFAULT_MIN_FREE_DAEMON;
	ap_daemons_max_free = DEFAULT_MAX_FREE_DAEMON;
	ap_daemons_limit = HARD_SERVER_LIMIT;
	ap_pid_fname = DEFAULT_PIDLOG;
	ap_scoreboard_fname = DEFAULT_SCOREBOARD;
	ap_lock_fname = DEFAULT_LOCKFILE;
	ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
	ap_max_cpu_per_child = DEFAULT_MAX_CPU_PER_CHILD;
	ap_max_data_per_child = DEFAULT_MAX_DATA_PER_CHILD;
	ap_max_nofile_per_child = DEFAULT_MAX_NOFILE_PER_CHILD;
	ap_max_rss_per_child = DEFAULT_MAX_RSS_PER_CHILD;
	ap_max_stack_per_child = DEFAULT_MAX_STACK_PER_CHILD;
	ap_listeners = NULL;
	ap_listenbacklog = DEFAULT_LISTENBACKLOG;
	ap_extended_status = 0;

	/* Global virtual host hash bucket pointers.  Init to null. */
	ap_init_vhost_config(p);

	ap_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
}

static server_rec *init_server_config(pool *p)
{
	server_rec *s = (server_rec *)ap_pcalloc(p, sizeof(server_rec));

	s->port = 0;
	s->server_admin = DEFAULT_ADMIN;
	s->server_hostname = NULL;
	s->error_fname = DEFAULT_ERRORLOG;
	s->error_log = stderr;
	s->loglevel = DEFAULT_LOGLEVEL;
	s->srm_confname = RESOURCE_CONFIG_FILE;
	s->access_confname = ACCESS_CONFIG_FILE;
	s->limit_req_line = DEFAULT_LIMIT_REQUEST_LINE;
	s->limit_req_fieldsize = DEFAULT_LIMIT_REQUEST_FIELDSIZE;
	s->limit_req_fields = DEFAULT_LIMIT_REQUEST_FIELDS;
	s->timeout = DEFAULT_TIMEOUT;
	s->keep_alive_timeout = DEFAULT_KEEPALIVE_TIMEOUT;
	s->keep_alive_max = DEFAULT_KEEPALIVE;
	s->keep_alive = 1;
	s->next = NULL;
	s->addrs = ap_pcalloc(p, sizeof(server_addr_rec));
	/* NOT virtual host; don't match any real network interface */
	memset(&s->addrs->host_addr, 0, sizeof(s->addrs->host_addr));
#if 0
	s->addrs->host_addr.ss_family = ap_default_family;
	/* XXX: needed?, XXX: PF_xxx can be different from AF_xxx */
#endif
#ifdef HAVE_SOCKADDR_LEN
	s->addrs->host_addr.ss_len = sizeof(s->addrs->host_addr); 
	/* XXX: needed ? */
#endif
	s->addrs->host_port = 0;	/* matches any port */
	s->addrs->virthost = "";	/* must be non-NULL */
	s->names = s->wild_names = NULL;

	s->module_config = create_server_config(p, s);
	s->lookup_defaults = create_default_per_dir_config(p);

	s->ctx = ap_ctx_new(p);

	return s;
}


static void
default_listeners(pool *p, server_rec *s)
{
	listen_rec *new;
	struct addrinfo hints, *res0, *res;
	int gai;
	char servbuf[NI_MAXSERV];

	if (ap_listeners != NULL)
		return;

	ap_snprintf(servbuf, sizeof(servbuf), "%d", s->port ?
	    s->port : DEFAULT_HTTP_PORT);
	memset (&hints, 0, sizeof(hints));
	hints.ai_family = ap_default_family;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_PASSIVE;
	gai = getaddrinfo(NULL, servbuf, &hints, &res0);
	if (gai){
		fprintf(stderr, "default_listeners(): getaddrinfo(PASSIVE) "
		    "for family %u: %s\n", ap_default_family,
		    gai_strerror(gai));
		exit (1);
	}
	/* allocate a default listener */
	new = ap_pcalloc(p, sizeof(listen_rec));
	memcpy(&new->local_addr, res0->ai_addr, res0->ai_addrlen);
	new->fd = -1;
	new->used = 0;
	new->next = NULL;
	ap_listeners = new;

	freeaddrinfo(res0);
}


API_EXPORT(server_rec *)
ap_read_config(pool *p, pool *ptemp, char *confname)
{
	server_rec *s = init_server_config(p);

	init_config_globals(p);

	/* All server-wide config files now have the SAME syntax... */

	process_command_config(s, ap_server_pre_read_config, p, ptemp);

	ap_process_resource_config(s, confname, p, ptemp);
	ap_process_resource_config(s, s->srm_confname, p, ptemp);
	ap_process_resource_config(s, s->access_confname, p, ptemp);

	process_command_config(s, ap_server_post_read_config, p, ptemp);

	fixup_virtual_hosts(p, s);
	default_listeners(p, s);
	ap_fini_vhost_config(p, s);

	return s;
}

API_EXPORT(void)
ap_single_module_configure(pool *p, server_rec *s, module *m)
{
	if (m->create_server_config)
		ap_set_module_config(s->module_config, m,
		    (*m->create_server_config)(p, s));
	if (m->create_dir_config)
		ap_set_module_config(s->lookup_defaults, m,
		    (*m->create_dir_config)(p, NULL));
}

API_EXPORT(void)
ap_init_modules(pool *p, server_rec *s)
{
	module *m;

	for (m = top_module; m; m = m->next)
		if (m->init)
			(*m->init) (s, p);
	build_method_shortcuts();
	init_handlers(p);
}

API_EXPORT(void)
ap_child_init_modules(pool *p, server_rec *s)
{
	module *m;

	for (m = top_module; m; m = m->next)
		if (m->child_init)
			(*m->child_init) (s, p);
}

API_EXPORT(void)
ap_child_exit_modules(pool *p, server_rec *s)
{
	module *m;

	signal(SIGHUP, SIG_IGN);
	signal(SIGUSR1, SIG_IGN);

	for (m = top_module; m; m = m->next)
		if (m->child_exit)
			(*m->child_exit) (s, p);

}

/********************************************************************
 * Configuration directives are restricted in terms of where they may
 * appear in the main configuration files and/or .htaccess files according
 * to the bitmask req_override in the command_rec structure.
 * If any of the overrides set in req_override are also allowed in the
 * context in which the command is read, then the command is allowed.
 * The context is determined as follows:
 *
 *    inside *.conf --> override = (RSRC_CONF|OR_ALL)&~(OR_AUTHCFG|OR_LIMIT);
 *    within <Directory> or <Location> --> override = OR_ALL|ACCESS_CONF;
 *    within .htaccess --> override = AllowOverride for current directory;
 *
 * the result is, well, a rather confusing set of possibilities for when
 * a particular directive is allowed to be used.  This procedure prints
 * in English where the given (pc) directive can be used.
 */
static void
show_overrides(const command_rec *pc, module *pm)
{
	int n = 0;

	printf("\tAllowed in *.conf ");
	if ((pc->req_override & (OR_OPTIONS | OR_FILEINFO | OR_INDEXES)) ||
	    ((pc->req_override & RSRC_CONF) &&
	    ((pc->req_override & (ACCESS_CONF | OR_AUTHCFG | OR_LIMIT)))))
		printf("anywhere");
	else if (pc->req_override & RSRC_CONF)
		printf("only outside <Directory>, <Files> or <Location>");
	else
		printf("only inside <Directory>, <Files> or <Location>");

	/* Warn if the directive is allowed inside <Directory> or .htaccess
	 * but module doesn't support per-dir configuration */

	if ((pc->req_override & (OR_ALL | ACCESS_CONF))
	    && !pm->create_dir_config)
		printf(" [no per-dir config]");

	if (pc->req_override & OR_ALL) {
		printf(" and in .htaccess\n\twhen AllowOverride");

		if ((pc->req_override & OR_ALL) == OR_ALL)
			printf(" isn't None");
		else {
			printf(" includes ");

			if (pc->req_override & OR_AUTHCFG) {
				if (n++)
					printf(" or ");
				printf("AuthConfig");
			}
			if (pc->req_override & OR_LIMIT) {
				if (n++)
					printf(" or ");
				printf("Limit");
			}
			if (pc->req_override & OR_OPTIONS) {
				if (n++)
					printf(" or ");
				printf("Options");
			}
			if (pc->req_override & OR_FILEINFO) {
				if (n++)
					printf(" or ");
				printf("FileInfo");
			}
			if (pc->req_override & OR_INDEXES) {
				if (n++)
					printf(" or ");
				printf("Indexes");
			}
		}
	}
	printf("\n");
}

/* Show the preloaded configuration directives, the help string explaining
 * the directive arguments, in what module they are handled, and in
 * what parts of the configuration they are allowed.  Used for httpd -L.
 */
API_EXPORT(void)
ap_show_directives(void)
{
	const command_rec *pc;
	int n;

	for (n = 0; ap_loaded_modules[n]; ++n)
		for (pc = ap_loaded_modules[n]->cmds; pc && pc->name; ++pc) {
			printf("%s (%s)\n", pc->name,
			    ap_loaded_modules[n]->name);
			if (pc->errmsg)
				printf("\t%s\n", pc->errmsg);
			show_overrides(pc, ap_loaded_modules[n]);
		}
}

/* Show the preloaded module names.  Used for httpd -l. */
API_EXPORT(void)
ap_show_modules(void)
{
	int n;

	printf("Compiled-in modules:\n");
	for (n = 0; ap_loaded_modules[n]; ++n)
		printf("  %s\n", ap_loaded_modules[n]->name);

	printf("suexec: %s\n", ap_suexec_enabled
	    ? "enabled; valid wrapper " SUEXEC_BIN
	    : "disabled; invalid wrapper " SUEXEC_BIN);
}
@


1.21
log
@fix comment.
@
text
@d1 1
a1 1
/* $OpenBSD: http_config.c,v 1.20 2008/05/14 13:47:05 mbalmer Exp $ */
@


1.20
log
@Next chunk of KNF/readability.

no binary changes.
@
text
@d1 1
a1 1
/* $OpenBSD: http_config.c,v 1.19 2008/05/09 08:06:28 mbalmer Exp $ */
d1654 1
a1654 1
	* XXX: needed ? */
@


1.19
log
@Add support for IPv6 while keeping the default at IPv4 to not break
existing installations.  See the documentation for the IPv6 related
configuration.

This changes the module ABI since addresses are now struct addrinfo.

This has been tested by many people and run on production machines
for several months.

feedback many, ok todd
@
text
@d1 1
a1 1
/* $OpenBSD: http_config.c,v 1.18 2007/11/19 14:59:10 robert Exp $ */
d125 2
a126 1
API_EXPORT(void *) ap_get_module_config(void *conf_vector, module *m)
d128 2
a129 2
    void **confv = (void **) conf_vector;
    return confv[m->module_index];
d134 2
a135 1
API_EXPORT(void) ap_set_module_config(void *conf_vector, module *m, void *val)
d137 2
a138 2
    void **confv = (void **) conf_vector;
    confv[m->module_index] = val;
d142 2
a143 1
static void *create_empty_config(pool *p)
d145 3
a147 3
    void **conf_vector = (void **) ap_pcalloc(p, sizeof(void *) *
				    (total_modules + DYNAMIC_MODULE_LIMIT));
    return (void *) conf_vector;
d150 2
a151 1
static void *create_default_per_dir_config(pool *p)
d153 3
a155 2
    void **conf_vector = (void **) ap_pcalloc(p, sizeof(void *) * (total_modules + DYNAMIC_MODULE_LIMIT));
    module *modp;
d157 2
a158 2
    for (modp = top_module; modp; modp = modp->next) {
	dir_maker_func df = modp->create_dir_config;
d160 3
a162 3
	if (df)
	    conf_vector[modp->module_index] = (*df) (p, NULL);
    }
d164 1
a164 1
    return (void *) conf_vector;
d168 1
a168 1
     ap_merge_per_dir_configs(pool *p, void *base, void *new)
d170 8
a177 8
    void **conf_vector = (void **) ap_palloc(p, sizeof(void *) * total_modules);
    void **base_vector = (void **) base;
    void **new_vector = (void **) new;
    module *modp;

    for (modp = top_module; modp; modp = modp->next) {
	merger_func df = modp->merge_dir_config;
	int i = modp->module_index;
d179 7
a185 5
	if (df && new_vector[i])
	    conf_vector[i] = (*df) (p, base_vector[i], new_vector[i]);
	else
	    conf_vector[i] = new_vector[i] ? new_vector[i] : base_vector[i];
    }
d187 1
a187 1
    return (void *) conf_vector;
d190 2
a191 1
static void *create_server_config(pool *p, server_rec *s)
d193 3
a195 2
    void **conf_vector = (void **) ap_pcalloc(p, sizeof(void *) * (total_modules + DYNAMIC_MODULE_LIMIT));
    module *modp;
d197 5
a201 4
    for (modp = top_module; modp; modp = modp->next) {
	if (modp->create_server_config)
	    conf_vector[modp->module_index] = (*modp->create_server_config) (p, s);
    }
d203 1
a203 1
    return (void *) conf_vector;
d206 2
a207 1
static void merge_server_configs(pool *p, void *base, void *virt)
d209 3
a211 3
    /* Can reuse the 'virt' vector for the spine of it, since we don't
     * have to deal with the moral equivalent of .htaccess files here...
     */
d213 3
a215 3
    void **base_vector = (void **) base;
    void **virt_vector = (void **) virt;
    module *modp;
d217 3
a219 3
    for (modp = top_module; modp; modp = modp->next) {
	merger_func df = modp->merge_server_config;
	int i = modp->module_index;
d221 6
a226 5
	if (!virt_vector[i])
	    virt_vector[i] = base_vector[i];
	else if (df)
	    virt_vector[i] = (*df) (p, base_vector[i], virt_vector[i]);
    }
d229 2
a230 1
CORE_EXPORT(void *) ap_create_request_config(pool *p)
d232 1
a232 1
    return create_empty_config(p);
d235 2
a236 1
CORE_EXPORT(void *) ap_create_per_dir_config(pool *p)
d238 1
a238 1
    return create_empty_config(p);
d244 3
a246 5
    int offset;
    char *method;
} aMethods[] =

{
d248 7
a254 7
    m(translate_handler),
    m(ap_check_user_id),
    m(auth_checker),
    m(type_checker),
    m(fixer_upper),
    m(logger),
    { -1, "?" },
d258 2
a259 1
char *ShowMethod(module *modp, int offset)
d261 2
a262 2
    int n;
    static char buf[200];
d264 5
a268 5
    for (n = 0; aMethods[n].offset >= 0; ++n)
	if (aMethods[n].offset == offset)
	    break;
    ap_snprintf(buf, sizeof(buf), "%s:%s", modp->name, aMethods[n].method);
    return buf;
d289 9
a297 9
    XtOffsetOf(module, translate_handler),
    XtOffsetOf(module, ap_check_user_id),
    XtOffsetOf(module, auth_checker),
    XtOffsetOf(module, access_checker),
    XtOffsetOf(module, type_checker),
    XtOffsetOf(module, fixer_upper),
    XtOffsetOf(module, logger),
    XtOffsetOf(module, header_parser),
    XtOffsetOf(module, post_read_request)
d302 9
a310 9
    int translate_handler;
    int ap_check_user_id;
    int auth_checker;
    int access_checker;
    int type_checker;
    int fixer_upper;
    int logger;
    int header_parser;
    int post_read_request;
d321 2
a322 2

void ap_cleanup_method_ptrs()
d324 2
a325 3
    if (method_ptrs) {
        free(method_ptrs);
    }
d332 2
a333 1
static void build_method_shortcuts(void)
d335 24
a358 14
    module *modp;
    int how_many_ptrs;
    int i;
    int next_ptr;
    handler_func fp;

    if (method_ptrs) {
	/* free up any previous set of method_ptrs */
	free(method_ptrs);
    }

    /* first we count how many functions we have */
    how_many_ptrs = 0;
    for (modp = top_module; modp; modp = modp->next) {
d360 11
a370 20
	    if (*(handler_func *) (method_offsets[i] + (char *) modp)) {
		++how_many_ptrs;
	    }
	}
    }
    method_ptrs = malloc((how_many_ptrs + NMETHODS) * sizeof(handler_func));
    if (method_ptrs == NULL) {
	fprintf(stderr, "Ouch!  Out of memory in build_method_shortcuts()!\n");
    }
    next_ptr = 0;
    for (i = 0; i < NMETHODS; ++i) {
	/* XXX: This is an itsy bit presumptuous about the alignment
	 * constraints on offsets_into_method_ptrs.  I can't remember if
	 * ANSI says this has to be true... -djg */
	((int *) &offsets_into_method_ptrs)[i] = next_ptr;
	for (modp = top_module; modp; modp = modp->next) {
	    fp = *(handler_func *) (method_offsets[i] + (char *) modp);
	    if (fp) {
		method_ptrs[next_ptr++] = fp;
	    }
a371 2
	method_ptrs[next_ptr++] = NULL;
    }
d375 2
a376 1
static int run_method(request_rec *r, int offset, int run_all)
d378 1
a378 1
    int i;
d380 2
a381 2
    for (i = offset; method_ptrs[i]; ++i) {
	handler_func mod_handler = method_ptrs[i];
d383 2
a384 2
	if (mod_handler) {
	    int result;
d386 1
a386 1
	    result = (*mod_handler) (r);
d388 3
a390 2
	    if (result != DECLINED && (!run_all || result != OK))
		return result;
a391 1
    }
d393 1
a393 1
    return run_all ? OK : DECLINED;
d396 2
a397 1
API_EXPORT(int) ap_translate_name(request_rec *r)
d399 1
a399 1
    return run_method(r, offsets_into_method_ptrs.translate_handler, 0);
d402 2
a403 1
API_EXPORT(int) ap_check_access(request_rec *r)
d405 1
a405 1
    return run_method(r, offsets_into_method_ptrs.access_checker, 1);
d408 2
a409 1
API_EXPORT(int) ap_find_types(request_rec *r)
d411 1
a411 1
    return run_method(r, offsets_into_method_ptrs.type_checker, 0);
d414 2
a415 1
API_EXPORT(int) ap_run_fixups(request_rec *r)
d417 1
a417 1
    return run_method(r, offsets_into_method_ptrs.fixer_upper, 1);
d420 2
a421 1
API_EXPORT(int) ap_log_transaction(request_rec *r)
d423 1
a423 1
    return run_method(r, offsets_into_method_ptrs.logger, 1);
d426 2
a427 1
API_EXPORT(int) ap_header_parse(request_rec *r)
d429 1
a429 1
    return run_method(r, offsets_into_method_ptrs.header_parser, 1);
d432 2
a433 1
API_EXPORT(int) ap_run_post_read_request(request_rec *r)
d435 1
a435 1
    return run_method(r, offsets_into_method_ptrs.post_read_request, 1);
d443 2
a444 1
API_EXPORT(int) ap_check_user_id(request_rec *r)
d446 1
a446 1
    return run_method(r, offsets_into_method_ptrs.ap_check_user_id, 0);
d449 2
a450 1
API_EXPORT(int) ap_check_auth(request_rec *r)
d452 1
a452 1
    return run_method(r, offsets_into_method_ptrs.auth_checker, 0);
d462 2
a463 2
    handler_rec hr;
    size_t len;
d469 2
a470 1
static void init_handlers(pool *p)
d472 94
a565 96
    module *modp;
    int nhandlers = 0;
    int nwildhandlers = 0;
    const handler_rec *handp;
    fast_handler_rec *ph, *pw;
    char *starp;

    for (modp = top_module; modp; modp = modp->next) {
	if (!modp->handlers)
	    continue;
	for (handp = modp->handlers; handp->content_type; ++handp) {
	    if (strchr(handp->content_type, '*')) {
                nwildhandlers ++;
            } else {
                nhandlers ++;
            }
        }
    }
    ph = handlers = ap_palloc(p, sizeof(*ph)*(nhandlers + 1));
    pw = wildhandlers = ap_palloc(p, sizeof(*pw)*(nwildhandlers + 1));
    for (modp = top_module; modp; modp = modp->next) {
	if (!modp->handlers)
	    continue;
	for (handp = modp->handlers; handp->content_type; ++handp) {
	    if ((starp = strchr(handp->content_type, '*'))) {
                pw->hr.content_type = handp->content_type;
                pw->hr.handler = handp->handler;
		pw->len = starp - handp->content_type;
                pw ++;
            } else {
                ph->hr.content_type = handp->content_type;
                ph->hr.handler = handp->handler;
		ph->len = strlen(handp->content_type);
                ph ++;
            }
        }
    }
    pw->hr.content_type = NULL;
    pw->hr.handler = NULL;
    ph->hr.content_type = NULL;
    ph->hr.handler = NULL;
}

API_EXPORT(int) ap_invoke_handler(request_rec *r)
{
    fast_handler_rec *handp;
    const char *handler;
    char *p;
    size_t handler_len;
    int result = HTTP_INTERNAL_SERVER_ERROR;

    if (r->handler) {
	handler = r->handler;
	handler_len = strlen(handler);
    }
    else {
	handler = r->content_type ? r->content_type : ap_default_type(r);
	if ((p = strchr(handler, ';')) != NULL) { /* MIME type arguments */
	    while (p > handler && p[-1] == ' ')
		--p;		/* strip trailing spaces */
	    handler_len = p - handler;
	}
	else {
	    handler_len = strlen(handler);
	}
    }

    /* Pass one --- direct matches */

    for (handp = handlers; handp->hr.content_type; ++handp) {
	if (handler_len == handp->len
	    && !strncmp(handler, handp->hr.content_type, handler_len)) {
            result = (*handp->hr.handler) (r);

            if (result != DECLINED)
                return result;
        }
    }

    /* Pass two --- wildcard matches */

    for (handp = wildhandlers; handp->hr.content_type; ++handp) {
	if (handler_len >= handp->len
	    && !strncmp(handler, handp->hr.content_type, handp->len)) {
             result = (*handp->hr.handler) (r);

             if (result != DECLINED)
                 return result;
         }
    }

    if (result == HTTP_INTERNAL_SERVER_ERROR && r->handler && r->filename) {
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, r,
            "handler \"%s\" not found for: %s", r->handler, r->filename);
    }
    return HTTP_INTERNAL_SERVER_ERROR;
d570 2
a571 1
API_EXPORT(void) ap_add_module(module *m)
d573 52
a624 50
    /* This could be called from an AddModule httpd.conf command,
     * after the file has been linked and the module structure within it
     * teased out...
     */

    if (m->version != MODULE_MAGIC_NUMBER_MAJOR) {
	fprintf(stderr, "%s: module \"%s\" is not compatible with this "
		"version of Apache.\n", ap_server_argv0, m->name);
	fprintf(stderr, "Please contact the vendor for the correct version.\n");
	exit(1);
    }

    if (m->next == NULL) {
	m->next = top_module;
	top_module = m;
    }
    if (m->module_index == -1) {
	m->module_index = total_modules++;
	dynamic_modules++;

	if (dynamic_modules > DYNAMIC_MODULE_LIMIT) {
	    fprintf(stderr, "%s: module \"%s\" could not be loaded, because"
		    " the dynamic\n", ap_server_argv0, m->name);
	    fprintf(stderr, "module limit was reached. Please increase "
		    "DYNAMIC_MODULE_LIMIT and recompile.\n");
	    exit(1);
	}
    }

    /* Some C compilers put a complete path into __FILE__, but we want
     * only the filename (e.g. mod_includes.c). So check for path
     * components (Unix and DOS), and remove them.
     */

    if (strrchr(m->name, '/'))
	m->name = 1 + strrchr(m->name, '/');
    if (strrchr(m->name, '\\'))
	m->name = 1 + strrchr(m->name, '\\');

    /*
     * Invoke the `add_module' hook inside the now existing set
     * of modules to let them all now that this module was added.
     */
    {
        module *m2;
        for (m2 = top_module; m2 != NULL; m2 = m2->next)
            if (m2->magic == MODULE_MAGIC_COOKIE_EAPI)
                if (m2->add_module != NULL)
                    (*m2->add_module)(m);
    }
d635 144
a778 1
API_EXPORT(void) ap_remove_module(module *m)
d780 1
a780 1
    module *modp;
d782 5
a786 142
    /*
     * Invoke the `remove_module' hook inside the now existing
     * set of modules to let them all now that this module is
     * beeing removed.
     */
    {
        module *m2;
        for (m2 = top_module; m2 != NULL; m2 = m2->next)
            if (m2->magic == MODULE_MAGIC_COOKIE_EAPI)
                if (m2->remove_module != NULL)
                    (*m2->remove_module)(m);
    }

    modp = top_module;
    if (modp == m) {
	/* We are the top module, special case */
	top_module = modp->next;
	m->next = NULL;
    }
    else {
	/* Not the top module, find use. When found modp will
	 * point to the module _before_ us in the list
	 */

	while (modp && modp->next != m) {
	    modp = modp->next;
	}
	if (!modp) {
	    /* Uh-oh, this module doesn't exist */
	    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, NULL,
		"Cannot remove module %s: not found in module list",
		m->name);
	    return;
	}
	/* Eliminate us from the module list */
	modp->next = modp->next->next;
    }

    m->module_index = -1;	/* simulate being unloaded, should
				 * be unnecessary */
    dynamic_modules--;
    total_modules--;
}

API_EXPORT(void) ap_add_loaded_module(module *mod)
{
    module **m;

    /* 
     *  Add module pointer to top of chained module list 
     */
    ap_add_module(mod);

    /* 
     *  And module pointer to list of loaded modules 
     *
     *  Notes: 1. ap_add_module() would already complain if no more space
     *            exists for adding a dynamically loaded module
     *         2. ap_add_module() accepts double-inclusion, so we have
     *            to accept this, too.
     */
    for (m = ap_loaded_modules; *m != NULL; m++)
        ;
    *m++ = mod;
    *m = NULL;
}

API_EXPORT(void) ap_remove_loaded_module(module *mod)
{
    module **m;
    module **m2;
    int done;

    /* 
     *  Remove module pointer from chained module list 
     */
    ap_remove_module(mod);

    /* 
     *  Remove module pointer from list of loaded modules
     *
     *  Note: 1. We cannot determine if the module was successfully
     *           removed by ap_remove_module().
     *        2. We have not to complain explicity when the module
     *           is not found because ap_remove_module() did it
     *           for us already.
     */
    for (m = m2 = ap_loaded_modules, done = 0; *m2 != NULL; m2++) {
        if (*m2 == mod && done == 0)
            done = 1;
        else
            *m++ = *m2;
    }
    *m = NULL;
}

API_EXPORT(void) ap_setup_prelinked_modules(void)
{
    module **m;
    module **m2;

    /*
     *  Initialise total_modules variable and module indices
     */
    total_modules = 0;
    for (m = ap_preloaded_modules; *m != NULL; m++)
        (*m)->module_index = total_modules++;

    /* 
     *  Initialise list of loaded modules
     */
    ap_loaded_modules = (module **)malloc(
        sizeof(module *)*(total_modules+DYNAMIC_MODULE_LIMIT+1));
    if (ap_loaded_modules == NULL) {
	fprintf(stderr, "Ouch!  Out of memory in ap_setup_prelinked_modules()!\n");
	exit(1);
    }
    for (m = ap_preloaded_modules, m2 = ap_loaded_modules; *m != NULL; )
        *m2++ = *m++;
    *m2 = NULL;

    /*
     *   Initialize chain of linked (=activate) modules
     */
    for (m = ap_prelinked_modules; *m != NULL; m++)
        ap_add_module(*m);
}

API_EXPORT(const char *) ap_find_module_name(module *m)
{
    return m->name;
}

API_EXPORT(module *) ap_find_linked_module(const char *name)
{
    module *modp;

    for (modp = top_module; modp; modp = modp->next) {
	if (strcmp(modp->name, name) == 0)
	    return modp;
    }
    return NULL;
d790 2
a791 1
API_EXPORT(int) ap_add_named_module(const char *name)
d793 2
a794 2
    module *modp;
    int i = 0;
d796 7
a802 7
    for (modp = ap_loaded_modules[i]; modp; modp = ap_loaded_modules[++i]) {
	if (strcmp(modp->name, name) == 0) {
	    /* Only add modules that are not already enabled.  */
	    if (modp->next == NULL) {
		ap_add_module(modp);
	    }
	    return 1;
d804 1
a804 3
    }

    return 0;
d808 2
a809 1
API_EXPORT(void) ap_clear_module_list()
d811 2
a812 2
    module **m = &top_module;
    module **next_m;
d814 5
a818 5
    while (*m) {
	next_m = &((*m)->next);
	*m = NULL;
	m = next_m;
    }
d820 2
a821 2
    /* This is required; so we add it always.  */
    ap_add_named_module("http_core.c");
d833 71
a903 68
static const char *invoke_cmd(const command_rec *cmd, cmd_parms *parms,
			    void *mconfig, const char *args)
{
    char *w, *w2, *w3;
    const char *errmsg;

    if ((parms->override & cmd->req_override) == 0)
	return ap_pstrcat(parms->pool, cmd->name, " not allowed here", NULL);

    parms->info = cmd->cmd_data;
    parms->cmd = cmd;

    switch (cmd->args_how) {
    case RAW_ARGS:
	return ((const char *(*)(cmd_parms *, void *, const char *))
		(cmd->func)) (parms, mconfig, args);

    case NO_ARGS:
	if (*args != 0)
	    return ap_pstrcat(parms->pool, cmd->name, " takes no arguments",
			   NULL);

	return ((const char *(*)(cmd_parms *, void *))
		(cmd->func)) (parms, mconfig);

    case TAKE1:
	w = ap_getword_conf(parms->pool, &args);

	if (*w == '\0' || *args != 0)
	    return ap_pstrcat(parms->pool, cmd->name, " takes one argument",
			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);

	return ((const char *(*)(cmd_parms *, void *, const char *))
		(cmd->func)) (parms, mconfig, w);

    case TAKE2:

	w = ap_getword_conf(parms->pool, &args);
	w2 = ap_getword_conf(parms->pool, &args);

	if (*w == '\0' || *w2 == '\0' || *args != 0)
	    return ap_pstrcat(parms->pool, cmd->name, " takes two arguments",
			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);

	return ((const char *(*)(cmd_parms *, void *, const char *,
			const char *)) (cmd->func)) (parms, mconfig, w, w2);

    case TAKE12:

	w = ap_getword_conf(parms->pool, &args);
	w2 = ap_getword_conf(parms->pool, &args);

	if (*w == '\0' || *args != 0)
	    return ap_pstrcat(parms->pool, cmd->name, " takes 1-2 arguments",
			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);

	return ((const char *(*)(cmd_parms *, void *, const char *,
			    const char *)) (cmd->func)) (parms, mconfig, w,
							    *w2 ? w2 : NULL);

    case TAKE3:

	w = ap_getword_conf(parms->pool, &args);
	w2 = ap_getword_conf(parms->pool, &args);
	w3 = ap_getword_conf(parms->pool, &args);

	if (*w == '\0' || *w2 == '\0' || *w3 == '\0' || *args != 0)
	    return ap_pstrcat(parms->pool, cmd->name, " takes three arguments",
d906 8
a913 3
	return ((const char *(*)(cmd_parms *, void *, const char *,
			    const char *, const char *)) (cmd->func)) (parms,
							mconfig, w, w2, w3);
d915 2
a916 8
    case TAKE23:

	w = ap_getword_conf(parms->pool, &args);
	w2 = ap_getword_conf(parms->pool, &args);
	w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;

	if (*w == '\0' || *w2 == '\0' || *args != 0)
	    return ap_pstrcat(parms->pool, cmd->name,
d920 8
a927 9
	return ((const char *(*)(cmd_parms *, void *, const char *,
			    const char *, const char *)) (cmd->func)) (parms,
							mconfig, w, w2, w3);

    case TAKE123:

	w = ap_getword_conf(parms->pool, &args);
	w2 = *args ? ap_getword_conf(parms->pool, &args) : NULL;
	w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;
d929 2
a930 2
	if (*w == '\0' || *args != 0)
	    return ap_pstrcat(parms->pool, cmd->name,
d934 8
a941 9
	return ((const char *(*)(cmd_parms *, void *, const char *,
			    const char *, const char *)) (cmd->func)) (parms,
							mconfig, w, w2, w3);

    case TAKE13:

	w = ap_getword_conf(parms->pool, &args);
	w2 = *args ? ap_getword_conf(parms->pool, &args) : NULL;
	w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;
d943 2
a944 2
	if (*w == '\0' || (w2 && *w2 && !w3) || *args != 0)
	    return ap_pstrcat(parms->pool, cmd->name,
d948 9
a956 5
	return ((const char *(*)(cmd_parms *, void *, const char *,
			    const char *, const char *)) (cmd->func)) (parms,
							mconfig, w, w2, w3);

    case ITERATE:
d958 1
a958 4
	while (*(w = ap_getword_conf(parms->pool, &args)) != '\0')
	if   ((errmsg = ((const char *(*)(cmd_parms *, void *,
			const char *)) (cmd->func)) (parms, mconfig, w)))
		    return errmsg;
d960 2
a961 1
	return NULL;
d963 2
a964 6
    case ITERATE2:

	w = ap_getword_conf(parms->pool, &args);

	if (*w == '\0' || *args == 0)
	    return ap_pstrcat(parms->pool, cmd->name,
d969 2
a970 2
	while (*(w2 = ap_getword_conf(parms->pool, &args)) != '\0')
	    if   ((errmsg = ((const char *(*)(cmd_parms *, void *,
d972 2
a973 4
							    mconfig, w, w2)))
			return errmsg;

	return NULL;
d975 1
a975 1
    case FLAG:
d977 2
a978 1
	w = ap_getword_conf(parms->pool, &args);
d980 3
a982 3
	if (*w == '\0' || (strcasecmp(w, "on") && strcasecmp(w, "off")))
	    return ap_pstrcat(parms->pool, cmd->name, " must be On or Off",
			    NULL);
d984 2
a985 2
	return ((const char *(*)(cmd_parms *, void *, int))
		(cmd->func)) (parms, mconfig, strcasecmp(w, "off") != 0);
d987 4
a990 6
    default:

	return ap_pstrcat(parms->pool, cmd->name,
		    " is improperly configured internally (server bug)",
			NULL);
    }
d993 2
a994 1
CORE_EXPORT(const command_rec *) ap_find_command(const char *name, const command_rec *cmds)
d996 5
a1000 5
    while (cmds->name)
	if (!strcasecmp(name, cmds->name))
	    return cmds;
	else
	    ++cmds;
d1002 1
a1002 1
    return NULL;
d1005 2
a1006 1
CORE_EXPORT(const command_rec *) ap_find_command_in_modules(const char *cmd_name, module **mod)
d1008 2
a1009 2
    const command_rec *cmdp;
    module *modp;
d1011 6
a1016 5
    for (modp = *mod; modp; modp = modp->next)
	if (modp->cmds && (cmdp = ap_find_command(cmd_name, modp->cmds))) {
	    *mod = modp;
	    return cmdp;
	}
d1018 1
a1018 1
    return NULL;
d1021 2
a1022 1
CORE_EXPORT(void *) ap_set_config_vectors(cmd_parms *parms, void *config, module *mod)
d1024 2
a1025 2
    void *mconfig = ap_get_module_config(config, mod);
    void *sconfig = ap_get_module_config(parms->server->module_config, mod);
d1027 4
a1030 4
    if (!mconfig && mod->create_dir_config) {
	mconfig = (*mod->create_dir_config) (parms->pool, parms->path);
	ap_set_module_config(config, mod, mconfig);
    }
d1032 7
a1038 5
    if (!sconfig && mod->create_server_config) {
	sconfig = (*mod->create_server_config) (parms->pool, parms->server);
	ap_set_module_config(parms->server->module_config, mod, sconfig);
    }
    return mconfig;
d1041 2
a1042 1
CORE_EXPORT(const char *) ap_handle_command(cmd_parms *parms, void *config, const char *l)
d1044 4
a1047 4
    void *oldconfig;
    const char *args, *cmd_name, *retval;
    const command_rec *cmd;
    module *mod = top_module;
d1049 19
a1067 18
    /*
     * Invoke the `rewrite_command' of modules to allow
     * they to rewrite the directive line before we
     * process it.
     */
    {
        module *m;
        char *cp;
        for (m = top_module; m != NULL; m = m->next) {
            if (m->magic == MODULE_MAGIC_COOKIE_EAPI) {
                if (m->rewrite_command != NULL) {
                    cp = (m->rewrite_command)(parms, config, l);
                    if (cp != NULL)
                        l = cp;
                }
            }
        }
    }
d1069 2
a1070 2
    if ((l[0] == '#') || (!l[0]))
	return NULL;
d1072 17
a1088 4
    args = l;
    cmd_name = ap_getword_conf(parms->temp_pool, &args);
    if (*cmd_name == '\0')
	return NULL;
d1090 7
a1096 11
    oldconfig = parms->context;
    parms->context = config;
    do {
	if (!(cmd = ap_find_command_in_modules(cmd_name, &mod))) {
            errno = EINVAL;
            return ap_pstrcat(parms->pool, "Invalid command '", cmd_name,
                           "', perhaps mis-spelled or defined by a module "
                           "not included in the server configuration", NULL);
	}
	else {
	    void *mconfig = ap_set_config_vectors(parms,config, mod);
d1098 1
a1098 7
	    retval = invoke_cmd(cmd, parms, mconfig, args);
	    mod = mod->next;	/* Next time around, skip this one */
	}
    } while (retval && !strcmp(retval, DECLINE_CMD));
    parms->context = oldconfig;

    return retval;
d1101 2
a1102 1
API_EXPORT(const char *) ap_srm_command_loop(cmd_parms *parms, void *config)
d1104 1
a1104 1
    char l[MAX_STRING_LEN];
d1106 4
a1109 4
    while (!(ap_cfg_getline(l, MAX_STRING_LEN, parms->config_file))) {
	const char *errmsg = ap_handle_command(parms, config, l);
        if (errmsg) {
	    return errmsg;
a1110 1
    }
d1112 1
a1112 1
    return NULL;
d1119 2
a1120 2
API_EXPORT_NONSTD(const char *) ap_set_string_slot(cmd_parms *cmd,
						char *struct_ptr, char *arg)
d1122 1
a1122 1
    /* This one's pretty generic... */
d1124 3
a1126 3
    int offset = (int) (long) cmd->info;
    *(char **) (struct_ptr + offset) = arg;
    return NULL;
d1129 2
a1130 2
API_EXPORT_NONSTD(const char *) ap_set_string_slot_lower(cmd_parms *cmd,
						char *struct_ptr, char *arg)
d1132 1
a1132 1
    /* This one's pretty generic... */
d1134 4
a1137 4
    int offset = (int) (long) cmd->info;
    ap_str_tolower(arg);
    *(char **) (struct_ptr + offset) = arg;
    return NULL;
d1140 2
a1141 2
API_EXPORT_NONSTD(const char *) ap_set_flag_slot(cmd_parms *cmd,
					      char *struct_ptr, int arg)
d1143 1
a1143 1
    /* This one's pretty generic too... */
d1145 3
a1147 3
    int offset = (int) (long) cmd->info;
    *(int *) (struct_ptr + offset) = arg ? 1 : 0;
    return NULL;
d1150 2
a1151 1
API_EXPORT_NONSTD(const char *) ap_set_file_slot(cmd_parms *cmd, char *struct_ptr, char *arg)
d1153 12
a1164 12
    /* Prepend server_root to relative arg.
       This allows .htaccess to be independent of server_root,
       so the server can be moved or mirrored with less pain.  */
    char *p;
    int offset = (int) (long) cmd->info;
    arg = ap_os_canonical_filename(cmd->pool, arg);
    if (ap_os_is_path_absolute(arg))
	p = arg;
    else
	p = ap_make_full_path(cmd->pool, ap_server_root, arg);
    *(char **) (struct_ptr + offset) = p;
    return NULL;
d1173 1
a1173 1
{NULL, 0, -1, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
d1175 2
a1176 1
API_EXPORT(char *) ap_server_root_relative(pool *p, char *file)
d1178 4
a1181 4
    file = ap_os_canonical_filename(p, file);
    if(ap_os_is_path_absolute(file))
	return file;
    return ap_make_full_path(p, ap_server_root, file);
d1196 2
a1197 2
    array_header *array;
    int curr_idx;
d1202 2
a1203 1
static void *arr_elts_getstr(void *buf, size_t bufsiz, void *param)
d1205 1
a1205 1
    arr_elts_param_t *arr_param = (arr_elts_param_t *) param;
d1207 3
a1209 3
    /* End of array reached? */
    if (++arr_param->curr_idx > arr_param->array->nelts)
        return NULL;
d1211 3
a1213 2
    /* return the line */
    ap_cpystrn(buf, ((char **) arr_param->array->elts)[arr_param->curr_idx - 1], bufsiz);
d1215 1
a1215 1
    return buf;
d1220 2
a1221 1
static int arr_elts_close(void *param)
d1223 30
a1252 30
    arr_elts_param_t *arr_param = (arr_elts_param_t *) param;
    arr_param->curr_idx = arr_param->array->nelts;
    return 0;
}

static void process_command_config(server_rec *s, array_header *arr, pool *p,
				    pool *ptemp)
{
    const char *errmsg;
    cmd_parms parms;
    arr_elts_param_t arr_parms;

    arr_parms.curr_idx = 0;
    arr_parms.array = arr;

    parms = default_parms;
    parms.pool = p;
    parms.temp_pool = ptemp;
    parms.server = s;
    parms.override = (RSRC_CONF | OR_ALL) & ~(OR_AUTHCFG | OR_LIMIT);
    parms.config_file = ap_pcfg_open_custom(p, "-c/-C directives",
                                         &arr_parms, NULL,
                                         arr_elts_getstr, arr_elts_close);

    errmsg = ap_srm_command_loop(&parms, s->lookup_defaults);

    if (errmsg) {
        fprintf(stderr, "Syntax error in -C/-c directive:\n%s\n", errmsg);
        exit(1);
    }
d1254 1
a1254 1
    ap_cfg_closefile(parms.config_file);
d1258 1
a1258 1
    char *fname;
d1261 2
a1262 1
static int fname_alphasort(const void *fn1, const void *fn2)
d1264 2
a1265 2
    const fnames *f1 = fn1;
    const fnames *f2 = fn2;
d1267 1
a1267 1
    return strcmp(f1->fname,f2->fname);
d1270 69
a1338 96
CORE_EXPORT(void) ap_process_resource_config(server_rec *s, char *fname, pool *p, pool *ptemp)
{
    const char *errmsg;
    cmd_parms parms;
    struct stat finfo;
    int ispatt;
    fname = ap_server_root_relative(p, fname);

    if (!(strcmp(fname, ap_server_root_relative(p, RESOURCE_CONFIG_FILE))) ||
	!(strcmp(fname, ap_server_root_relative(p, ACCESS_CONFIG_FILE)))) {
	if (stat(fname, &finfo) == -1)
	    return;
    }

    /* if we are already chrooted here, it's a restart. strip chroot then. */
    ap_server_strip_chroot(fname, 0);

    /* don't require conf/httpd.conf if we have a -C or -c switch */
    if((ap_server_pre_read_config->nelts || ap_server_post_read_config->nelts) &&
       !(strcmp(fname, ap_server_root_relative(p, SERVER_CONFIG_FILE)))) {
	if (stat(fname, &finfo) == -1)
	    return;
    }

    /* 
     * here we want to check if the candidate file is really a
     * directory, and most definitely NOT a symlink (to prevent
     * horrible loops).  If so, let's recurse and toss it back into
     * the function.
     */
    ispatt = ap_is_fnmatch(fname);
    if (ispatt || ap_is_rdirectory(fname)) {
	DIR *dirp;
	struct DIR_TYPE *dir_entry;
	int current;
	array_header *candidates = NULL;
	fnames *fnew;
	char *path = ap_pstrdup(p,fname);
	char *pattern = NULL;

        if(ispatt && (pattern = strrchr(path, '/')) != NULL) {
            *pattern++ = '\0';
            if (ap_is_fnmatch(path)) {
                fprintf(stderr, "%s: wildcard patterns not allowed in Include "
                        "%s\n", ap_server_argv0, fname);
                exit(1);
            }

            if (!ap_is_rdirectory(path)){ 
                fprintf(stderr, "%s: Include directory '%s' not found",
                        ap_server_argv0, path);
                exit(1);
            }
            if (!ap_is_fnmatch(pattern)) {
                fprintf(stderr, "%s: must include a wildcard pattern "
                        "for Include %s\n", ap_server_argv0, fname);
                exit(1);
            }
        }


	/*
	 * first course of business is to grok all the directory
	 * entries here and store 'em away. Recall we need full pathnames
	 * for this.
	 */
	if (ap_configtestonly)
		fprintf(stdout, "Processing config directory: %s\n", fname);
	dirp = ap_popendir(p, path);
	if (dirp == NULL) {
	    perror("fopen");
	    fprintf(stderr, "%s: could not open config directory %s\n",
		ap_server_argv0, path);
	    exit(1);
	}
	candidates = ap_make_array(p, 1, sizeof(fnames));
	while ((dir_entry = readdir(dirp)) != NULL) {
	    /* strip out '.' and '..' */
	    if (strcmp(dir_entry->d_name, ".") &&
		strcmp(dir_entry->d_name, "..") &&
                (!ispatt ||
                 !ap_fnmatch(pattern,dir_entry->d_name, FNM_PERIOD)) ) {
		fnew = (fnames *) ap_push_array(candidates);
		fnew->fname = ap_make_full_path(p, path, dir_entry->d_name);
	    }
	}
	ap_pclosedir(p, dirp);
	if (candidates->nelts != 0) {
            qsort((void *) candidates->elts, candidates->nelts,
              sizeof(fnames), fname_alphasort);
	    /*
	     * Now recurse these... we handle errors and subdirectories
	     * via the recursion, which is nice
	     */
	    for (current = 0; current < candidates->nelts; ++current) {
	        fnew = &((fnames *) candidates->elts)[current];
d1340 40
a1379 3
			fprintf(stdout, " Processing config file: %s\n", fnew->fname);
		ap_process_resource_config(s, fnew->fname, p, ptemp);
	    }
a1380 2
	return;
    }
d1382 1
a1382 1
    /* GCC's initialization extensions are soooo nice here... */
d1384 12
a1395 5
    parms = default_parms;
    parms.pool = p;
    parms.temp_pool = ptemp;
    parms.server = s;
    parms.override = (RSRC_CONF | OR_ALL) & ~(OR_AUTHCFG | OR_LIMIT);
d1397 1
a1397 6
    if (!(parms.config_file = ap_pcfg_openfile(p,fname))) {
	perror("fopen");
	fprintf(stderr, "%s: could not open document config file %s\n",
		ap_server_argv0, fname);
	exit(1);
    }
d1399 6
a1404 8
    errmsg = ap_srm_command_loop(&parms, s->lookup_defaults);

    if (errmsg) {
	fprintf(stderr, "Syntax error on line %d of %s:\n",
		parms.config_file->line_number, parms.config_file->name);
	fprintf(stderr, "%s\n", errmsg);
	exit(1);
    }
d1406 1
a1406 1
    ap_cfg_closefile(parms.config_file);
d1409 61
a1469 17
CORE_EXPORT(int) ap_parse_htaccess(void **result, request_rec *r, int override,
		   const char *d, const char *access_name)
{
    configfile_t *f = NULL;
    cmd_parms parms;
    const char *errmsg;
    char *filename = NULL;
    const struct htaccess_result *cache;
    struct htaccess_result *new;
    void *dc = NULL;

/* firstly, search cache */
    for (cache = r->htaccess; cache != NULL; cache = cache->next)
	if (cache->override == override && strcmp(cache->dir, d) == 0) {
	    if (cache->htaccess != NULL)
		*result = cache->htaccess;
	    return OK;
d1472 10
a1481 53
    parms = default_parms;
    parms.override = override;
    parms.pool = r->pool;
    parms.temp_pool = r->pool;
    parms.server = r->server;
    parms.path = ap_pstrdup(r->pool, d);

    /* loop through the access names and find the first one */

    while (access_name[0]) {
        filename = ap_make_full_path(r->pool, d,
                                     ap_getword_conf(r->pool, &access_name));

        if ((f = ap_pcfg_openfile(r->pool, filename)) != NULL) {

            dc = ap_create_per_dir_config(r->pool);

            parms.config_file = f;

            errmsg = ap_srm_command_loop(&parms, dc);

            ap_cfg_closefile(f);

            if (errmsg) {
                ap_log_rerror(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, r,
                              "%s: %s", filename, errmsg);
                return HTTP_INTERNAL_SERVER_ERROR;
            }
            *result = dc;
            break;
        }
        else if (errno != ENOENT && errno != ENOTDIR) {
            ap_log_rerror(APLOG_MARK, APLOG_CRIT, r,
                          "%s pcfg_openfile: unable to check htaccess file, "
                          "ensure it is readable",
                          filename);
            ap_table_setn(r->notes, "error-notes",
                          "Server unable to read htaccess file, denying "
                          "access to be safe");
            return HTTP_FORBIDDEN;
        }
    }

/* cache it */
    new = ap_palloc(r->pool, sizeof(struct htaccess_result));
    new->dir = parms.path;
    new->override = override;
    new->htaccess = dc;
/* add to head of list */
    new->next = r->htaccess;
    r->htaccess = new;

    return OK;
d1485 16
a1500 13
CORE_EXPORT(const char *) ap_init_virtual_host(pool *p, const char *hostname,
			      server_rec *main_server, server_rec **ps)
{
    server_rec *s = (server_rec *) ap_pcalloc(p, sizeof(server_rec));

    struct rlimit limits;

    getrlimit(RLIMIT_NOFILE, &limits);
    if (limits.rlim_cur < limits.rlim_max) {
	limits.rlim_cur += 2;
	if (setrlimit(RLIMIT_NOFILE, &limits) < 0) {
	    perror("setrlimit(RLIMIT_NOFILE)");
	    fprintf(stderr, "Cannot exceed hard limit for open files");
a1501 1
    }
d1503 14
a1516 14
    s->server_admin = NULL;
    s->server_hostname = NULL;
    s->error_fname = NULL;
    s->srm_confname = NULL;
    s->access_confname = NULL;
    s->timeout = 0;
    s->keep_alive_timeout = 0;
    s->keep_alive = -1;
    s->keep_alive_max = -1;
    s->error_log = main_server->error_log;
    s->loglevel = main_server->loglevel;
    /* useful default, otherwise we get a port of 0 on redirects */
    s->port = main_server->port;
    s->next = NULL;
d1518 3
a1520 3
    s->is_virtual = 1;
    s->names = ap_make_array(p, 4, sizeof(char **));
    s->wild_names = ap_make_array(p, 4, sizeof(char **));
d1522 2
a1523 2
    s->module_config = create_empty_config(p);
    s->lookup_defaults = ap_create_per_dir_config(p);
d1525 2
a1526 2
    s->server_uid = ap_user_id;
    s->server_gid = ap_group_id;
d1528 3
a1530 3
    s->limit_req_line = main_server->limit_req_line;
    s->limit_req_fieldsize = main_server->limit_req_fieldsize;
    s->limit_req_fields = main_server->limit_req_fields;
d1532 1
a1532 1
    s->ctx = ap_ctx_new(p);
d1534 1
a1534 1
    *ps = s;
d1536 1
a1536 1
    return ap_parse_vhost_addrs(p, hostname, s);
d1540 2
a1541 1
static void fixup_virtual_hosts(pool *p, server_rec *main_server)
d1543 1
a1543 1
    server_rec *virt;
d1545 3
a1547 3
    for (virt = main_server->next; virt; virt = virt->next) {
	merge_server_configs(p, main_server->module_config,
			     virt->module_config);
d1549 3
a1551 3
	virt->lookup_defaults =
	    ap_merge_per_dir_configs(p, main_server->lookup_defaults,
				  virt->lookup_defaults);
d1553 2
a1554 2
	if (virt->server_admin == NULL)
	    virt->server_admin = main_server->server_admin;
d1556 2
a1557 2
	if (virt->srm_confname == NULL)
	    virt->srm_confname = main_server->srm_confname;
d1559 2
a1560 2
	if (virt->access_confname == NULL)
	    virt->access_confname = main_server->access_confname;
d1562 2
a1563 2
	if (virt->timeout == 0)
	    virt->timeout = main_server->timeout;
d1565 3
a1567 2
	if (virt->keep_alive_timeout == 0)
	    virt->keep_alive_timeout = main_server->keep_alive_timeout;
d1569 2
a1570 2
	if (virt->keep_alive == -1)
	    virt->keep_alive = main_server->keep_alive;
d1572 2
a1573 2
	if (virt->keep_alive_max == -1)
	    virt->keep_alive_max = main_server->keep_alive_max;
d1575 2
a1576 2
	if (virt->send_buffer_size == 0)
	    virt->send_buffer_size = main_server->send_buffer_size;
d1578 5
a1582 5
	/* XXX: this is really something that should be dealt with by a
	 * post-config api phase */
	ap_core_reorder_directories(p, virt);
    }
    ap_core_reorder_directories(p, main_server);
d1590 2
a1591 1
static void init_config_globals(pool *p)
d1593 1
a1593 1
    /* ServerRoot, server_confname set in httpd.c */
d1595 23
a1617 23
    ap_standalone = 1;
    ap_user_name = DEFAULT_USER;
    if (!ap_server_is_chrooted()) { 
	/* can't work, just keep old setting */
	ap_user_id = ap_uname2id(DEFAULT_USER);
	ap_group_id = ap_gname2id(DEFAULT_GROUP);
    }
    ap_daemons_to_start = DEFAULT_START_DAEMON;
    ap_daemons_min_free = DEFAULT_MIN_FREE_DAEMON;
    ap_daemons_max_free = DEFAULT_MAX_FREE_DAEMON;
    ap_daemons_limit = HARD_SERVER_LIMIT;
    ap_pid_fname = DEFAULT_PIDLOG;
    ap_scoreboard_fname = DEFAULT_SCOREBOARD;
    ap_lock_fname = DEFAULT_LOCKFILE;
    ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
    ap_max_cpu_per_child = DEFAULT_MAX_CPU_PER_CHILD;
    ap_max_data_per_child = DEFAULT_MAX_DATA_PER_CHILD;
    ap_max_nofile_per_child = DEFAULT_MAX_NOFILE_PER_CHILD;
    ap_max_rss_per_child = DEFAULT_MAX_RSS_PER_CHILD;
    ap_max_stack_per_child = DEFAULT_MAX_STACK_PER_CHILD;
    ap_listeners = NULL;
    ap_listenbacklog = DEFAULT_LISTENBACKLOG;
    ap_extended_status = 0;
d1619 2
a1620 2
    /* Global virtual host hash bucket pointers.  Init to null. */
    ap_init_vhost_config(p);
d1622 1
a1622 1
    ap_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
d1627 1
a1627 1
    server_rec *s = (server_rec *) ap_pcalloc(p, sizeof(server_rec));
d1629 19
a1647 19
    s->port = 0;
    s->server_admin = DEFAULT_ADMIN;
    s->server_hostname = NULL;
    s->error_fname = DEFAULT_ERRORLOG;
    s->error_log = stderr;
    s->loglevel = DEFAULT_LOGLEVEL;
    s->srm_confname = RESOURCE_CONFIG_FILE;
    s->access_confname = ACCESS_CONFIG_FILE;
    s->limit_req_line = DEFAULT_LIMIT_REQUEST_LINE;
    s->limit_req_fieldsize = DEFAULT_LIMIT_REQUEST_FIELDSIZE;
    s->limit_req_fields = DEFAULT_LIMIT_REQUEST_FIELDS;
    s->timeout = DEFAULT_TIMEOUT;
    s->keep_alive_timeout = DEFAULT_KEEPALIVE_TIMEOUT;
    s->keep_alive_max = DEFAULT_KEEPALIVE;
    s->keep_alive = 1;
    s->next = NULL;
    s->addrs = ap_pcalloc(p, sizeof(server_addr_rec));
    /* NOT virtual host; don't match any real network interface */
    memset(&s->addrs->host_addr, 0, sizeof(s->addrs->host_addr));
d1649 2
a1650 1
    s->addrs->host_addr.ss_family = ap_default_family; /* XXX: needed?, XXX: PF_xxx can be different from AF_xxx */
d1653 2
a1654 1
    s->addrs->host_addr.ss_len = sizeof(s->addrs->host_addr); /* XXX: needed ? */
d1656 10
a1665 10
    s->addrs->host_port = 0;	/* matches any port */
    s->addrs->virthost = "";	/* must be non-NULL */
    s->names = s->wild_names = NULL;

    s->module_config = create_server_config(p, s);
    s->lookup_defaults = create_default_per_dir_config(p);

    s->ctx = ap_ctx_new(p);

    return s;
d1669 31
a1699 6
static void default_listeners(pool *p, server_rec *s)
{
    listen_rec *new;
    struct addrinfo hints, *res0, *res;
    int gai;
    char servbuf[NI_MAXSERV];
d1701 1
a1701 23
    if (ap_listeners != NULL) {
	return;
    }
    ap_snprintf(servbuf, sizeof(servbuf), "%d", s->port ? s->port : DEFAULT_HTTP_PORT);
    memset (&hints, 0, sizeof(hints));
    hints.ai_family = ap_default_family;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    gai = getaddrinfo(NULL, servbuf, &hints, &res0);
    if (gai){
	fprintf(stderr, "default_listeners(): getaddrinfo(PASSIVE) for family %u: %s\n",
		ap_default_family, gai_strerror(gai));
	exit (1);
    }
    /* allocate a default listener */
    new = ap_pcalloc(p, sizeof(listen_rec));
    memcpy(&new->local_addr, res0->ai_addr, res0->ai_addrlen);
    new->fd = -1;
    new->used = 0;
    new->next = NULL;
    ap_listeners = new;

    freeaddrinfo(res0);
d1705 2
a1706 1
API_EXPORT(server_rec *) ap_read_config(pool *p, pool *ptemp, char *confname)
d1708 1
a1708 1
    server_rec *s = init_server_config(p);
d1710 1
a1710 1
    init_config_globals(p);
d1712 1
a1712 1
    /* All server-wide config files now have the SAME syntax... */
d1714 1
a1714 1
    process_command_config(s, ap_server_pre_read_config, p, ptemp);
d1716 3
a1718 3
    ap_process_resource_config(s, confname, p, ptemp);
    ap_process_resource_config(s, s->srm_confname, p, ptemp);
    ap_process_resource_config(s, s->access_confname, p, ptemp);
d1720 1
a1720 1
    process_command_config(s, ap_server_post_read_config, p, ptemp);
d1722 3
a1724 3
    fixup_virtual_hosts(p, s);
    default_listeners(p, s);
    ap_fini_vhost_config(p, s);
d1726 1
a1726 1
    return s;
d1729 2
a1730 1
API_EXPORT(void) ap_single_module_configure(pool *p, server_rec *s, module *m)
d1732 6
a1737 6
    if (m->create_server_config)
        ap_set_module_config(s->module_config, m,
                             (*m->create_server_config)(p, s));
    if (m->create_dir_config)
        ap_set_module_config(s->lookup_defaults, m,
                             (*m->create_dir_config)(p, NULL));
d1740 2
a1741 1
API_EXPORT(void) ap_init_modules(pool *p, server_rec *s)
d1743 1
a1743 1
    module *m;
d1745 5
a1749 5
    for (m = top_module; m; m = m->next)
	if (m->init)
	    (*m->init) (s, p);
    build_method_shortcuts();
    init_handlers(p);
d1752 2
a1753 1
API_EXPORT(void) ap_child_init_modules(pool *p, server_rec *s)
d1755 1
a1755 1
    module *m;
d1757 3
a1759 3
    for (m = top_module; m; m = m->next)
	if (m->child_init)
	    (*m->child_init) (s, p);
d1762 2
a1763 1
API_EXPORT(void) ap_child_exit_modules(pool *p, server_rec *s)
d1765 1
a1765 1
    module *m;
d1767 2
a1768 2
    signal(SIGHUP, SIG_IGN);
    signal(SIGUSR1, SIG_IGN);
d1770 3
a1772 3
    for (m = top_module; m; m = m->next)
	if (m->child_exit)
	    (*m->child_exit) (s, p);
d1792 2
a1793 1
static void show_overrides(const command_rec *pc, module *pm)
d1795 11
a1805 1
    int n = 0;
d1807 41
a1847 49
    printf("\tAllowed in *.conf ");
    if ((pc->req_override & (OR_OPTIONS | OR_FILEINFO | OR_INDEXES)) ||
	((pc->req_override & RSRC_CONF) &&
	 ((pc->req_override & (ACCESS_CONF | OR_AUTHCFG | OR_LIMIT)))))
	printf("anywhere");
    else if (pc->req_override & RSRC_CONF)
	printf("only outside <Directory>, <Files> or <Location>");
    else
	printf("only inside <Directory>, <Files> or <Location>");

    /* Warn if the directive is allowed inside <Directory> or .htaccess
     * but module doesn't support per-dir configuration */

    if ((pc->req_override & (OR_ALL | ACCESS_CONF)) && !pm->create_dir_config)
	printf(" [no per-dir config]");

    if (pc->req_override & OR_ALL) {
	printf(" and in .htaccess\n\twhen AllowOverride");

	if ((pc->req_override & OR_ALL) == OR_ALL)
	    printf(" isn't None");
	else {
	    printf(" includes ");

	    if (pc->req_override & OR_AUTHCFG) {
		if (n++)
		    printf(" or ");
		printf("AuthConfig");
	    }
	    if (pc->req_override & OR_LIMIT) {
		if (n++)
		    printf(" or ");
		printf("Limit");
	    }
	    if (pc->req_override & OR_OPTIONS) {
		if (n++)
		    printf(" or ");
		printf("Options");
	    }
	    if (pc->req_override & OR_FILEINFO) {
		if (n++)
		    printf(" or ");
		printf("FileInfo");
	    }
	    if (pc->req_override & OR_INDEXES) {
		if (n++)
		    printf(" or ");
		printf("Indexes");
	    }
d1849 1
a1849 2
    }
    printf("\n");
d1856 2
a1857 1
API_EXPORT(void) ap_show_directives(void)
d1859 2
a1860 2
    const command_rec *pc;
    int n;
d1862 8
a1869 7
    for (n = 0; ap_loaded_modules[n]; ++n)
	for (pc = ap_loaded_modules[n]->cmds; pc && pc->name; ++pc) {
	    printf("%s (%s)\n", pc->name, ap_loaded_modules[n]->name);
	    if (pc->errmsg)
		printf("\t%s\n", pc->errmsg);
	    show_overrides(pc, ap_loaded_modules[n]);
	}
d1873 2
a1874 1
API_EXPORT(void) ap_show_modules(void)
d1876 1
a1876 1
    int n;
d1878 7
a1884 8
    printf("Compiled-in modules:\n");
    for (n = 0; ap_loaded_modules[n]; ++n) {
	printf("  %s\n", ap_loaded_modules[n]->name);
    }
    printf("suexec: %s\n",
	   ap_suexec_enabled
	       ? "enabled; valid wrapper " SUEXEC_BIN
	       : "disabled; invalid wrapper " SUEXEC_BIN);
@


1.18
log
@do not print "Processing config {dir,file} ...." messages unless the -t
or -T option is specified, which is only going to do a syntax check on
the config file(s)

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_config.c,v 1.17 2006/02/22 15:07:12 henning Exp $ */
a1558 1
    ap_bind_address.s_addr = htonl(INADDR_ANY);
d1591 7
a1597 1
    s->addrs->host_addr.s_addr = htonl(INADDR_ANY);
d1614 3
d1621 11
d1634 1
a1634 5
    new->local_addr.sin_family = AF_INET;
    new->local_addr.sin_addr = ap_bind_address;
    /* Buck ugly cast to get around terniary op bug in some (MS) compilers */
    new->local_addr.sin_port = htons((unsigned short)(s->port ? s->port 
                                                        : DEFAULT_HTTP_PORT));
d1639 2
@


1.17
log
@allow ressource limits for child processes to be set.
from Chris Kuethe <chris.kuethe@@gmail.com>
running at UofA for months now, ok beck niallo, also tested mbalmer
@
text
@d1 1
a1 1
/* $OpenBSD: http_config.c,v 1.16 2005/02/09 12:13:09 henning Exp $ */
d1294 2
a1295 1
	fprintf(stderr, "Processing config directory: %s\n", fname);
d1324 2
a1325 1
		fprintf(stderr, " Processing config file: %s\n", fnew->fname);
@


1.16
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d1 1
a1 1
/* $OpenBSD: http_config.c,v 1.15 2004/12/02 19:42:47 henning Exp $ */
d1552 5
@


1.15
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_config.c,v 1.14 2003/08/21 13:11:35 henning Exp $ */
a589 1
#ifdef EAPI
a600 1
#endif /* EAPI */
a614 1
#ifdef EAPI
a626 1
#endif /* EAPI */
a1016 1
#ifdef EAPI
a1034 1
#endif /* EAPI */
a1436 1
#ifdef RLIMIT_NOFILE
a1446 1
#endif
a1476 1
#ifdef EAPI
a1477 1
#endif /* EAPI */
a1592 1
#ifdef EAPI
a1593 1
#endif /* EAPI */
a1676 1
#ifdef SIGHUP
a1677 2
#endif
#ifdef SIGUSR1
a1678 1
#endif
@


1.14
log
@merge
@
text
@d1 1
a1 1
/* $OpenBSD: http_config.c,v 1.13 2003/07/08 09:51:23 david Exp $ */
a559 3
#ifdef NETWARE
        clean_parent_exit(1);
#else    
a560 1
#endif
a575 3
#ifdef NETWARE
            clean_parent_exit(1);
#else
a576 1
#endif
a589 9
#ifdef _OSD_POSIX /* __FILE__="*POSIX(/home/martin/apache/src/modules/standard/mod_info.c)" */
    /* We cannot fix the string in-place, because it's const */
    if (m->name[strlen(m->name)-1]==')') {
	char *tmp = strdup(m->name);	/* FIXME:memory leak, albeit a small one */
	tmp[strlen(tmp)-1] = '\0';
	m->name = tmp;
    }
#endif /*_OSD_POSIX*/

a733 3
#ifdef NETWARE
        clean_parent_exit(1);
#else
a734 1
#endif
a1126 1
#ifndef OS2
a1127 1
#endif
a1145 1
#ifndef OS2
a1146 1
#endif
a1215 3
#ifdef NETWARE
        clean_parent_exit(1);
#else
a1216 1
#endif
a1305 3
#ifdef NETWARE
	    clean_parent_exit(1);
#else
a1306 1
#endif
a1347 3
#ifdef NETWARE
        clean_parent_exit(1);
#else
a1348 1
#endif
a1356 3
#ifdef NETWARE
        clean_parent_exit(1);
#else
a1357 1
#endif
a1802 1
#if !defined(WIN32) && !defined(NETWARE) && !defined(TPF)
a1806 1
#endif
@


1.13
log
@declare chroot and etag functions in the .h files
and get rid of some implicit declaration warnings
ok henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: http_config.c,v 1.12 2002/10/07 20:23:06 henning Exp $ */
d6 1
a6 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
@


1.12
log
@merge apache 1.3.27 and mod_ssl 2.8.11
@
text
@d1 1
a1 1
/* $OpenBSD: http_config.c,v 1.11 2002/10/07 07:43:13 henning Exp $ */
d82 1
@


1.11
log
@make restarts work again with missing srm.conf (sigh)
pointed out by nicolas at untz dot net, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: http_config.c,v 1.10 2002/07/15 09:40:49 henning Exp $ */
d86 1
d1267 1
a1267 1

d1292 2
a1293 1
    if (ap_is_rdirectory(fname)) {
d1299 23
d1329 1
a1329 1
	dirp = ap_popendir(p, fname);
d1333 1
a1333 1
		ap_server_argv0, fname);
d1344 3
a1346 1
		strcmp(dir_entry->d_name, "..")) {
d1348 1
a1348 1
		fnew->fname = ap_make_full_path(p, fname, dir_entry->d_name);
@


1.10
log
@don't try things we are not able to do if chrooted on graceful restarts.
this does not mean a chrooted httpd survives a graceful restart (yet).
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a1268 3
    /* if we are already chrooted here, it's a restart. strip chroot then. */
    ap_server_strip_chroot(fname, 0);

d1274 3
@


1.10.2.1
log
@pull in patch from current:
Fix (henning):
make restarts work again with missing srm.conf (sigh)
pointed out by nicolas at untz dot net, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: http_config.c,v 1.11 2002/10/07 07:43:13 henning Exp $ */
d1269 3
a1276 3

    /* if we are already chrooted here, it's a restart. strip chroot then. */
    ap_server_strip_chroot(fname, 0);
@


1.9
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d1 2
d1269 3
d1562 5
a1566 2
    ap_user_id = ap_uname2id(DEFAULT_USER);
    ap_group_id = ap_gname2id(DEFAULT_GROUP);
@


1.8
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d158 1
a158 1
void *
d213 1
a213 1
void *ap_create_request_config(pool *p)
d379 1
a379 1
int ap_translate_name(request_rec *r)
d384 1
a384 1
int ap_check_access(request_rec *r)
d389 1
a389 1
int ap_find_types(request_rec *r)
d394 1
a394 1
int ap_run_fixups(request_rec *r)
d399 1
a399 1
int ap_log_transaction(request_rec *r)
d404 1
a404 1
int ap_header_parse(request_rec *r)
d409 1
a409 1
int ap_run_post_read_request(request_rec *r)
d419 1
a419 1
int ap_check_user_id(request_rec *r)
d424 1
a424 1
int ap_check_auth(request_rec *r)
d488 1
a488 1
int ap_invoke_handler(request_rec *r)
d728 1
a728 1
void ap_setup_prelinked_modules(void)
d1259 1
a1259 1
void ap_process_resource_config(server_rec *s, char *fname, pool *p, pool *ptemp)
d1371 1
a1371 1
int ap_parse_htaccess(void **result, request_rec *r, int override,
d1627 3
a1629 1
    new->local_addr.sin_port = htons(s->port ? s->port : DEFAULT_HTTP_PORT);
d1637 1
a1637 1
server_rec *ap_read_config(pool *p, pool *ptemp, char *confname)
d1660 1
a1660 1
void ap_single_module_configure(pool *p, server_rec *s, module *m)
d1670 1
a1670 1
void ap_init_modules(pool *p, server_rec *s)
d1681 1
a1681 1
void ap_child_init_modules(pool *p, server_rec *s)
d1690 1
a1690 1
void ap_child_exit_modules(pool *p, server_rec *s)
d1785 1
a1785 1
void ap_show_directives(void)
d1800 1
a1800 1
void ap_show_modules(void)
d1808 1
a1808 1
#if !defined(WIN32) && !defined(NETWARE)
@


1.7
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1995-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 20
a38 23
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 7
a56 6
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
d1144 3
d1165 3
d1781 1
a1781 1
 * what parts of the configuration they are allowed.  Used for httpd -h.
@


1.6
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d303 8
d555 3
d559 1
d575 3
d579 1
d727 1
a727 1
void ap_setup_prelinked_modules()
d746 3
d750 1
d1230 3
d1234 1
d1240 12
d1273 56
d1341 3
d1345 1
d1354 3
d1358 1
a1363 1

d1776 1
a1776 1
void ap_show_directives()
d1791 1
a1791 1
void ap_show_modules()
d1799 1
d1804 1
@


1.5
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@a514 5
    if (result == HTTP_INTERNAL_SERVER_ERROR && r->handler) {
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, r,
            "handler \"%s\" not found for: %s", r->handler, r->filename);
    }

d527 4
d730 1
d913 1
a913 1
	if (*w == '\0' || (*w2 && !w3) || *args != 0)
d1697 1
a1697 1
    for (n = 0; ap_loaded_modules[n]; ++n)
d1699 5
@


1.4
log
@mod_ssl-2.2.3-1.3.4 (will require libssl-1.1 for https to work, but
mostly harmless otherwise).
@
text
@d102 1
a102 1
API_VAR_EXPORT module **ap_loaded_modules;
d330 3
d657 1
d729 3
d993 17
d1012 1
d1046 2
d1056 1
a1056 14
	    void *mconfig = ap_get_module_config(config, mod);
	    void *sconfig =
		ap_get_module_config(parms->server->module_config, mod);

	    if (!mconfig && mod->create_dir_config) {
		mconfig = (*mod->create_dir_config) (parms->pool, parms->path);
		ap_set_module_config(config, mod, mconfig);
	    }

	    if (!sconfig && mod->create_server_config) {
		sconfig =
		    (*mod->create_server_config) (parms->pool, parms->server);
		ap_set_module_config(parms->server->module_config, mod, sconfig);
	    }
d1062 1
d1137 1
a1137 1
{NULL, 0, -1, NULL, NULL, NULL, NULL, NULL, NULL};
a1559 8
}

void ap_single_module_init(pool *p, server_rec *s, module *m)
{
    if (m->init)
        (*m->init)(s, p);
    build_method_shortcuts();
    init_handlers(p);
@


1.3
log
@Apache 1.3.4 merge
@
text
@d583 14
d611 15
d992 21
d1372 4
d1486 4
@


1.2
log
@Apache 1.3.3 merge + proxy_segv fix
@
text
@d2 1
a2 1
 * Copyright (c) 1995-1998 The Apache Group.  All rights reserved.
d482 1
a482 1
    int result = NOT_IMPLEMENTED;
d512 1
a512 1
    if (result == NOT_IMPLEMENTED && r->handler) {
d529 1
a529 1
    return NOT_IMPLEMENTED;
d542 2
a543 2
	fprintf(stderr, "httpd: module \"%s\" is not compatible with this "
		"version of Apache.\n", m->name);
d557 2
a558 2
	    fprintf(stderr, "httpd: module \"%s\" could not be loaded, because"
		    " the dynamic\n", m->name);
d1182 2
a1183 2
	fprintf(stderr, "httpd: could not open document config file %s\n",
		fname);
d1191 1
a1191 1
		parms.config_file->line_number, fname);
d1479 17
d1560 1
a1560 1
	printf("only outside <Directory> or <Location>");
d1562 1
a1562 1
	printf("only inside <Directory> or <Location>");
@


1.1
log
@Initial revision
@
text
@d1209 1
a1209 1
    void *dc;
a1226 20
    while (!f && access_name[0]) {
	char *w = ap_getword_conf(r->pool, &access_name);
	filename = ap_make_full_path(r->pool, d, w);
	f = ap_pcfg_openfile(r->pool, filename);
    }
    if (f) {
	dc = ap_create_per_dir_config(r->pool);

	parms.config_file = f;

	errmsg = ap_srm_command_loop(&parms, dc);

	ap_cfg_closefile(f);

	if (errmsg) {
	    ap_log_rerror(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, r, "%s: %s",
                        filename, errmsg);
	    ap_table_setn(r->notes, "error-notes", errmsg);
            return HTTP_INTERNAL_SERVER_ERROR;
	}
d1228 32
a1259 14
	*result = dc;
    }
    else {
	if (errno == ENOENT || errno == ENOTDIR)
	    dc = NULL;
	else {
	    ap_log_rerror(APLOG_MARK, APLOG_CRIT, r,
			"%s pcfg_openfile: unable to check htaccess file, ensure it is readable",
			filename);
	    ap_table_setn(r->notes, "error-notes",
			  "Server unable to read htaccess file, denying "
			  "access to be safe");
	    return HTTP_FORBIDDEN;
	}
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 23
a38 20
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 6
a55 7
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
d102 1
a102 1
API_VAR_EXPORT module **ap_loaded_modules=NULL;
d157 1
a157 1
CORE_EXPORT(void *)
d212 1
a212 1
CORE_EXPORT(void *) ap_create_request_config(pool *p)
a302 8

void ap_cleanup_method_ptrs()
{
    if (method_ptrs) {
        free(method_ptrs);
    }
}

a329 3
    if (method_ptrs == NULL) {
	fprintf(stderr, "Ouch!  Out of memory in build_method_shortcuts()!\n");
    }
d367 1
a367 1
API_EXPORT(int) ap_translate_name(request_rec *r)
d372 1
a372 1
API_EXPORT(int) ap_check_access(request_rec *r)
d377 1
a377 1
API_EXPORT(int) ap_find_types(request_rec *r)
d382 1
a382 1
API_EXPORT(int) ap_run_fixups(request_rec *r)
d387 1
a387 1
API_EXPORT(int) ap_log_transaction(request_rec *r)
d392 1
a392 1
API_EXPORT(int) ap_header_parse(request_rec *r)
d397 1
a397 1
API_EXPORT(int) ap_run_post_read_request(request_rec *r)
d407 1
a407 1
API_EXPORT(int) ap_check_user_id(request_rec *r)
d412 1
a412 1
API_EXPORT(int) ap_check_auth(request_rec *r)
d476 1
a476 1
API_EXPORT(int) ap_invoke_handler(request_rec *r)
d482 1
a482 1
    int result = HTTP_INTERNAL_SERVER_ERROR;
d512 5
d529 1
a529 5
    if (result == HTTP_INTERNAL_SERVER_ERROR && r->handler && r->filename) {
        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, r,
            "handler \"%s\" not found for: %s", r->handler, r->filename);
    }
    return HTTP_INTERNAL_SERVER_ERROR;
d542 2
a543 2
	fprintf(stderr, "%s: module \"%s\" is not compatible with this "
		"version of Apache.\n", ap_server_argv0, m->name);
a544 3
#ifdef NETWARE
        clean_parent_exit(1);
#else    
a545 1
#endif
d557 2
a558 2
	    fprintf(stderr, "%s: module \"%s\" could not be loaded, because"
		    " the dynamic\n", ap_server_argv0, m->name);
a560 3
#ifdef NETWARE
            clean_parent_exit(1);
#else
a561 1
#endif
a624 1
    total_modules--;
d679 1
a679 1
API_EXPORT(void) ap_setup_prelinked_modules(void)
a695 8
    if (ap_loaded_modules == NULL) {
	fprintf(stderr, "Ouch!  Out of memory in ap_setup_prelinked_modules()!\n");
#ifdef NETWARE
        clean_parent_exit(1);
#else
	exit(1);
#endif
    }
d877 1
a877 1
	if (*w == '\0' || (w2 && *w2 && !w3) || *args != 0)
a956 17
CORE_EXPORT(void *) ap_set_config_vectors(cmd_parms *parms, void *config, module *mod)
{
    void *mconfig = ap_get_module_config(config, mod);
    void *sconfig = ap_get_module_config(parms->server->module_config, mod);

    if (!mconfig && mod->create_dir_config) {
	mconfig = (*mod->create_dir_config) (parms->pool, parms->path);
	ap_set_module_config(config, mod, mconfig);
    }

    if (!sconfig && mod->create_server_config) {
	sconfig = (*mod->create_server_config) (parms->pool, parms->server);
	ap_set_module_config(parms->server->module_config, mod, sconfig);
    }
    return mconfig;
}

a958 1
    void *oldconfig;
a970 2
    oldconfig = parms->context;
    parms->context = config;
d979 14
a992 1
	    void *mconfig = ap_set_config_vectors(parms,config, mod);
a997 1
    parms->context = oldconfig;
a1057 3
#ifndef OS2
    arg = ap_os_canonical_filename(cmd->pool, arg);
#endif
d1072 1
a1072 1
{NULL, 0, -1, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
a1075 3
#ifndef OS2
    file = ap_os_canonical_filename(p, file);
#endif
a1144 3
#ifdef NETWARE
        clean_parent_exit(1);
#else
a1145 1
#endif
d1151 1
a1151 13
typedef struct {
    char *fname;
} fnames;

static int fname_alphasort(const void *fn1, const void *fn2)
{
    const fnames *f1 = fn1;
    const fnames *f2 = fn2;

    return strcmp(f1->fname,f2->fname);
}

CORE_EXPORT(void) ap_process_resource_config(server_rec *s, char *fname, pool *p, pool *ptemp)
a1171 56
    /* 
     * here we want to check if the candidate file is really a
     * directory, and most definitely NOT a symlink (to prevent
     * horrible loops).  If so, let's recurse and toss it back into
     * the function.
     */
    if (ap_is_rdirectory(fname)) {
	DIR *dirp;
	struct DIR_TYPE *dir_entry;
	int current;
	array_header *candidates = NULL;
	fnames *fnew;

	/*
	 * first course of business is to grok all the directory
	 * entries here and store 'em away. Recall we need full pathnames
	 * for this.
	 */
	fprintf(stderr, "Processing config directory: %s\n", fname);
	dirp = ap_popendir(p, fname);
	if (dirp == NULL) {
	    perror("fopen");
	    fprintf(stderr, "%s: could not open config directory %s\n",
		ap_server_argv0, fname);
#ifdef NETWARE
	    clean_parent_exit(1);
#else
	    exit(1);
#endif
	}
	candidates = ap_make_array(p, 1, sizeof(fnames));
	while ((dir_entry = readdir(dirp)) != NULL) {
	    /* strip out '.' and '..' */
	    if (strcmp(dir_entry->d_name, ".") &&
		strcmp(dir_entry->d_name, "..")) {
		fnew = (fnames *) ap_push_array(candidates);
		fnew->fname = ap_make_full_path(p, fname, dir_entry->d_name);
	    }
	}
	ap_pclosedir(p, dirp);
	if (candidates->nelts != 0) {
            qsort((void *) candidates->elts, candidates->nelts,
              sizeof(fnames), fname_alphasort);
	    /*
	     * Now recurse these... we handle errors and subdirectories
	     * via the recursion, which is nice
	     */
	    for (current = 0; current < candidates->nelts; ++current) {
	        fnew = &((fnames *) candidates->elts)[current];
		fprintf(stderr, " Processing config file: %s\n", fnew->fname);
		ap_process_resource_config(s, fnew->fname, p, ptemp);
	    }
	}
	return;
    }
    
d1182 2
a1183 5
	fprintf(stderr, "%s: could not open document config file %s\n",
		ap_server_argv0, fname);
#ifdef NETWARE
        clean_parent_exit(1);
#else
a1184 1
#endif
d1191 1
a1191 1
		parms.config_file->line_number, parms.config_file->name);
a1192 3
#ifdef NETWARE
        clean_parent_exit(1);
#else
a1193 1
#endif
d1199 2
a1200 1
CORE_EXPORT(int) ap_parse_htaccess(void **result, request_rec *r, int override,
d1209 1
a1209 1
    void *dc = NULL;
d1227 7
d1235 1
a1235 3
    while (access_name[0]) {
        filename = ap_make_full_path(r->pool, d,
                                     ap_getword_conf(r->pool, &access_name));
d1237 1
a1237 1
        if ((f = ap_pcfg_openfile(r->pool, filename)) != NULL) {
d1239 1
a1239 1
            dc = ap_create_per_dir_config(r->pool);
d1241 6
a1246 1
            parms.config_file = f;
d1248 14
a1261 22
            errmsg = ap_srm_command_loop(&parms, dc);

            ap_cfg_closefile(f);

            if (errmsg) {
                ap_log_rerror(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, r,
                              "%s: %s", filename, errmsg);
                return HTTP_INTERNAL_SERVER_ERROR;
            }
            *result = dc;
            break;
        }
        else if (errno != ENOENT && errno != ENOTDIR) {
            ap_log_rerror(APLOG_MARK, APLOG_CRIT, r,
                          "%s pcfg_openfile: unable to check htaccess file, "
                          "ensure it is readable",
                          filename);
            ap_table_setn(r->notes, "error-notes",
                          "Server unable to read htaccess file, denying "
                          "access to be safe");
            return HTTP_FORBIDDEN;
        }
d1450 1
a1450 3
    /* Buck ugly cast to get around terniary op bug in some (MS) compilers */
    new->local_addr.sin_port = htons((unsigned short)(s->port ? s->port 
                                                        : DEFAULT_HTTP_PORT));
d1458 1
a1458 1
API_EXPORT(server_rec *) ap_read_config(pool *p, pool *ptemp, char *confname)
a1480 9
API_EXPORT(void) ap_single_module_configure(pool *p, server_rec *s, module *m)
{
    if (m->create_server_config)
        ap_set_module_config(s->module_config, m,
                             (*m->create_server_config)(p, s));
    if (m->create_dir_config)
        ap_set_module_config(s->lookup_defaults, m,
                             (*m->create_dir_config)(p, NULL));
}
d1482 1
a1482 1
API_EXPORT(void) ap_init_modules(pool *p, server_rec *s)
d1493 1
a1493 1
API_EXPORT(void) ap_child_init_modules(pool *p, server_rec *s)
d1502 1
a1502 1
API_EXPORT(void) ap_child_exit_modules(pool *p, server_rec *s)
d1545 1
a1545 1
	printf("only outside <Directory>, <Files> or <Location>");
d1547 1
a1547 1
	printf("only inside <Directory>, <Files> or <Location>");
d1595 1
a1595 1
 * what parts of the configuration they are allowed.  Used for httpd -L.
d1597 1
a1597 1
API_EXPORT(void) ap_show_directives(void)
d1612 1
a1612 1
API_EXPORT(void) ap_show_modules(void)
d1617 1
a1617 1
    for (n = 0; ap_loaded_modules[n]; ++n) {
a1618 7
    }
#if !defined(WIN32) && !defined(NETWARE) && !defined(TPF)
    printf("suexec: %s\n",
	   ap_suexec_enabled
	       ? "enabled; valid wrapper " SUEXEC_BIN
	       : "disabled; invalid wrapper " SUEXEC_BIN);
#endif
@


1.1.1.3
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@a83 1
#include "fnmatch.h"
a601 14

#ifdef EAPI
    /*
     * Invoke the `add_module' hook inside the now existing set
     * of modules to let them all now that this module was added.
     */
    {
        module *m2;
        for (m2 = top_module; m2 != NULL; m2 = m2->next)
            if (m2->magic == MODULE_MAGIC_COOKIE_EAPI)
                if (m2->add_module != NULL)
                    (*m2->add_module)(m);
    }
#endif /* EAPI */
a615 15
#ifdef EAPI
    /*
     * Invoke the `remove_module' hook inside the now existing
     * set of modules to let them all now that this module is
     * beeing removed.
     */
    {
        module *m2;
        for (m2 = top_module; m2 != NULL; m2 = m2->next)
            if (m2->magic == MODULE_MAGIC_COOKIE_EAPI)
                if (m2->remove_module != NULL)
                    (*m2->remove_module)(m);
    }
#endif /* EAPI */

a1008 21
#ifdef EAPI
    /*
     * Invoke the `rewrite_command' of modules to allow
     * they to rewrite the directive line before we
     * process it.
     */
    {
        module *m;
        char *cp;
        for (m = top_module; m != NULL; m = m->next) {
            if (m->magic == MODULE_MAGIC_COOKIE_EAPI) {
                if (m->rewrite_command != NULL) {
                    cp = (m->rewrite_command)(parms, config, l);
                    if (cp != NULL)
                        l = cp;
                }
            }
        }
    }
#endif /* EAPI */

d1214 1
a1214 1
    int ispatt;
d1236 1
a1236 2
    ispatt = ap_is_fnmatch(fname);
    if (ispatt || ap_is_rdirectory(fname)) {
a1241 23
	char *path = ap_pstrdup(p,fname);
	char *pattern = NULL;

        if(ispatt && (pattern = strrchr(path, '/')) != NULL) {
            *pattern++ = '\0';
            if (ap_is_fnmatch(path)) {
                fprintf(stderr, "%s: wildcard patterns not allowed in Include "
                        "%s\n", ap_server_argv0, fname);
                exit(1);
            }

            if (!ap_is_rdirectory(path)){ 
                fprintf(stderr, "%s: Include directory '%s' not found",
                        ap_server_argv0, path);
                exit(1);
            }
            if (!ap_is_fnmatch(pattern)) {
                fprintf(stderr, "%s: must include a wildcard pattern "
                        "for Include %s\n", ap_server_argv0, fname);
                exit(1);
            }
        }

d1249 1
a1249 1
	dirp = ap_popendir(p, path);
d1253 1
a1253 1
		ap_server_argv0, path);
d1264 1
a1264 3
		strcmp(dir_entry->d_name, "..") &&
                (!ispatt ||
                 !ap_fnmatch(pattern,dir_entry->d_name, FNM_PERIOD)) ) {
d1266 1
a1266 1
		fnew->fname = ap_make_full_path(p, path, dir_entry->d_name);
a1442 4
#ifdef EAPI
    s->ctx = ap_ctx_new(p);
#endif /* EAPI */

a1552 4

#ifdef EAPI
    s->ctx = ap_ctx_new(p);
#endif /* EAPI */
@


1.1.1.4
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
@


