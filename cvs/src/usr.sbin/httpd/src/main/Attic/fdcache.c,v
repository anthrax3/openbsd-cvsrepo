head	1.12;
access;
symbols
	OPENBSD_5_5:1.11.0.26
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.22
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.20
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.18
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.16
	OPENBSD_5_0:1.11.0.14
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.12
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.10
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.6
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.8
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.4
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.10.0.20
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.18
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.16
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.14
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5;
locks; strict;
comment	@ * @;


1.12
date	2014.04.22.14.47.26;	author henning;	state dead;
branches;
next	1.11;

1.11
date	2008.05.14.13.47.05;	author mbalmer;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.18.21.16.37;	author david;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.17.35.44;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.12.17.23.45;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.17.23.21;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.12.17.20.47;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.02.11.52.01;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.17.17.00.25;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.17.13.51.42;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.17.13.15.57;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.17.11.17.00;	author henning;	state Exp;
branches;
next	;


desc
@@


1.12
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*	$OpenBSD: fdcache.c,v 1.11 2008/05/14 13:47:05 mbalmer Exp $ */

/*
 * Copyright (c) 2002, 2003 Henning Brauer
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

struct fdcache {
	char		*fname;
	int		 fd;
	struct fdcache	*next;
};

struct fdcache	*fdc;

int
fdcache_open(char *fn, int flags, mode_t mode)
{
	struct fdcache *fdcp = NULL, *tmp = NULL;

	for (fdcp = fdc; fdcp && strcmp(fn, fdcp->fname); fdcp = fdcp->next);
		/* nothing */

	if (fdcp == NULL) {
		/* need to open */
		if ((tmp = calloc(1, sizeof(struct fdcache))) == NULL)
			err(1, "calloc");
		if ((tmp->fname = strdup(fn)) == NULL)
			err(1, "strdup");
		if ((tmp->fd = open(fn, flags, mode)) < 0)
			err(1, "Cannot open %s", tmp->fname);
		tmp->next = fdc;
		fdc = tmp;
		return(fdc->fd);
	} else
		return(fdcp->fd);	/* fd cached */
}

void
fdcache_closeall(void)
{
	struct fdcache *fdcp = NULL, *tmp = NULL;

	for (fdcp = fdc; fdcp != NULL; ) {
		tmp = fdcp;
		fdcp = tmp->next;
		if (tmp->fd > 0)
			close(tmp->fd);
		free(tmp->fname);
		free(tmp);
	}
}

@


1.11
log
@Next chunk of KNF/readability.

no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdcache.c,v 1.10 2003/07/18 21:16:37 david Exp $ */
@


1.10
log
@#include "http_main.h" for the chroot functions
fixes some implicit declaration warnings
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdcache.c,v 1.9 2003/05/12 17:35:44 henning Exp $ */
d42 3
a44 3
    char *fname;
    int  fd;
    struct fdcache *next;
d52 1
a52 1
    struct fdcache *fdcp = NULL, *tmp = NULL;
d54 2
a55 2
    for (fdcp = fdc; fdcp && strcmp(fn, fdcp->fname); fdcp = fdcp->next);
	/* nothing */
d57 13
a69 13
    if (fdcp == NULL) {
	/* need to open */
	if ((tmp = calloc(1, sizeof(struct fdcache))) == NULL)
	    err(1, "calloc");
	if ((tmp->fname = strdup(fn)) == NULL)
	    err(1, "strdup");
	if ((tmp->fd = open(fn, flags, mode)) < 0)
	    err(1, "Cannot open %s", tmp->fname);
	tmp->next = fdc;
	fdc = tmp;
	return(fdc->fd);
    } else
	return(fdcp->fd);	/* fd cached */
d75 1
a75 1
    struct fdcache *fdcp = NULL, *tmp = NULL;
d77 8
a84 8
    for (fdcp = fdc; fdcp != NULL; ) {
	tmp = fdcp;
	fdcp = tmp->next;
	if (tmp->fd > 0)
	    close(tmp->fd);
	free(tmp->fname);
	free(tmp);
    }
@


1.9
log
@cut crap, use strdup instead of malloc + strlcpy, use err()
@
text
@d1 1
a1 1
/*	$OpenBSD: fdcache.c,v 1.8 2003/05/12 17:23:45 henning Exp $ */
d36 1
@


1.8
log
@extend copyright to 2003
@
text
@d1 1
a1 1
/*	$OpenBSD: fdcache.c,v 1.7 2003/05/12 17:23:21 henning Exp $ */
d58 6
a63 16
	tmp = calloc(1, sizeof(struct fdcache));
	if (tmp == NULL) {
	    fprintf(stderr, "calloc failed\n");
	    exit(1);
	}
	tmp->fname = malloc(strlen(fn) + 1);
	if (tmp->fname == NULL) {
	    fprintf(stderr, "malloc failed\n");
	    exit(1);
	}
	strlcpy(tmp->fname, fn, strlen(fn) + 1);
	if ((tmp->fd = open(fn, flags, mode)) < 0) {
	    fprintf(stderr, "Cannot open %s: %s\n",
	      tmp->fname, strerror(errno));
	    exit(1);
	}
@


1.7
log
@no point in strncmp here; seen after question from
Pedro Bastos <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: fdcache.c,v 1.6 2003/05/12 17:20:47 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2002 Henning Brauer
@


1.6
log
@explicit != NULL for pointer
@
text
@d1 1
a1 1
/*	$OpenBSD: fdcache.c,v 1.5 2002/08/02 11:52:01 henning Exp $ */
d53 1
a53 1
    for (fdcp = fdc; fdcp && strncmp(fn, fdcp->fname, 1024); fdcp = fdcp->next);
@


1.5
log
@2 missing #includes
@
text
@d1 1
a1 1
/*	$OpenBSD: fdcache.c,v 1.4 2002/07/17 17:00:25 henning Exp $ */
d86 1
a86 1
    for (fdcp = fdc; fdcp; ) {
@


1.4
log
@un-KNF to match apache source code style. requested by theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdcache.c,v 1.3 2002/07/17 13:51:42 henning Exp $ */
d37 2
d82 1
a82 1
fdcache_closeall()
@


1.3
log
@correctly free() all list members in _closeall.
10x markus
@
text
@d1 1
a1 1
/*	$OpenBSD: fdcache.c,v 1.2 2002/07/17 13:15:57 henning Exp $ */
d39 3
a41 3
	char	*fname;
	int	 fd;
	struct fdcache	*next;
d49 1
a49 1
	struct fdcache *fdcp = NULL, *tmp = NULL;
d51 26
a76 27
	for (fdcp = fdc; fdcp && strncmp(fn, fdcp->fname, 1024);
	    fdcp = fdcp->next);
		/* nothing */

	if (fdcp == NULL) {
		/* need to open */
		tmp = calloc(1, sizeof(struct fdcache));
		if (tmp == NULL) {
			fprintf(stderr, "calloc failed\n");
			exit(1);
		}
		tmp->fname = malloc(strlen(fn) + 1);
		if (tmp->fname == NULL) {
			fprintf(stderr, "malloc failed\n");
			exit(1);
		}
		strlcpy(tmp->fname, fn, strlen(fn) + 1);
		if ((tmp->fd = open(fn, flags, mode)) < 0) {
			fprintf(stderr, "Cannot open %s: %s\n",
			    tmp->fname, strerror(errno));
			exit(1);
		}
		tmp->next = fdc;
		fdc = tmp;
		return(fdc->fd);
	} else
		return(fdcp->fd);	/* fd cached */
d82 1
a82 1
	struct fdcache *fdcp = NULL, *tmp = NULL;
d84 8
a91 8
	for (fdcp = fdc; fdcp; ) {
		tmp = fdcp;
		fdcp = tmp->next;
		if (tmp->fd > 0)
			close(tmp->fd);
		free(tmp->fname);
		free(tmp);
	}
@


1.2
log
@KNF
I slacked again.
10x markus.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdcache.c,v 1.1 2002/07/17 11:17:00 henning Exp $ */
d83 1
a83 1
	struct fdcache *fdcp = NULL;
d85 7
a91 4
	for (fdcp = fdc; fdcp; fdcp = fdcp->next) {
		if (fdcp->fd > 0)
			close(fdcp->fd);
		free(fdcp->fname);
a92 2
	if (fdc != NULL)
		free(fdc);
@


1.1
log
@introduce fdcache, a simple wrapper to keep a copy of fds outside
server_conf. needed to make the mod_log_* modules survive graceful restarts.
has to be used with great care, as of now only appropriate for logfiles.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d51 1
a51 1
	for(fdcp = fdc; fdcp && strncmp(fn, fdcp->fname, 1024);
d55 1
a55 2
	if (fdcp == NULL)
	{
d85 1
a85 2
	for(fdcp = fdc; fdcp; fdcp = fdcp->next)
	{
@

