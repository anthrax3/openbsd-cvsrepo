head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.22
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.20
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.18
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.16
	OPENBSD_5_0:1.19.0.14
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.12
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.10
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.6
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.17.0.14
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.12
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.10
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.8
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.6
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.3
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.3
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.2
	apache_1_3_27:1.1.1.2
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.04.22.14.47.26;	author henning;	state dead;
branches;
next	1.20;

1.20
date	2013.08.18.16.32.24;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.14.09.25.38;	author mbalmer;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.14.08.42.20;	author mbalmer;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.09.12.13.09;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.07.04.21.30;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.21.13.11.35;	author henning;	state Exp;
branches
	1.14.2.1
	1.14.4.1;
next	1.13;

1.13
date	2002.08.15.15.49.33;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.19.21.31.15;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.17.11.24.42;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.29.02.08.05;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.09.07.05.01;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.29.10.21.43;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.22.18.07;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.19.11.17.08;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.25.18.29.47;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.06.29.36;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.01.06.09;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	98.10.11.19.45.12;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.39;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.39;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.28.44;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.21.12.53.39;	author henning;	state Exp;
branches;
next	;

1.14.2.1
date	2004.06.10.03.55.18;	author brad;	state Exp;
branches;
next	;

1.14.4.1
date	2004.06.10.02.09.05;	author brad;	state Exp;
branches;
next	;


desc
@@


1.21
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*	$OpenBSD: http_log.c,v 1.20 2013/08/18 16:32:24 guenther Exp $ */

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/*
 * http_log.c: Dealing with the logs and errors
 * 
 * Rob McCool
 * 
 */


#define CORE_PRIVATE
#include "httpd.h"
#include "http_conf_globals.h"
#include "http_config.h"
#include "http_core.h"
#include "http_log.h"
#include "http_main.h"

#include <stdarg.h>

typedef struct {
	char	*t_name;
	int	 t_val;
} TRANS;

static const TRANS facilities[] = {
	{"auth",	LOG_AUTH},
	{"authpriv",	LOG_AUTHPRIV},
	{"cron", 	LOG_CRON},
	{"daemon",	LOG_DAEMON},
	{"ftp",		LOG_FTP},
	{"kern",	LOG_KERN},
	{"lpr",		LOG_LPR},
	{"mail",	LOG_MAIL},
	{"news",	LOG_NEWS},
	{"syslog",	LOG_SYSLOG},
	{"user",	LOG_USER},
	{"uucp",	LOG_UUCP},
	{"local0",	LOG_LOCAL0},
	{"local1",	LOG_LOCAL1},
	{"local2",	LOG_LOCAL2},
	{"local3",	LOG_LOCAL3},
	{"local4",	LOG_LOCAL4},
	{"local5",	LOG_LOCAL5},
	{"local6",	LOG_LOCAL6},
	{"local7",	LOG_LOCAL7},
	{NULL,				-1},
};

static const TRANS priorities[] = {
	{"emerg",	APLOG_EMERG},
	{"alert",	APLOG_ALERT},
	{"crit",	APLOG_CRIT},
	{"error",	APLOG_ERR},
	{"warn",	APLOG_WARNING},
	{"notice",	APLOG_NOTICE},
	{"info",	APLOG_INFO},
	{"debug",	APLOG_DEBUG},
	{NULL,		-1},
};

static int
error_log_child(void *cmd, child_info *pinfo)
{
	/* Child process code for 'ErrorLog "|..."';
	 * may want a common framework for this, since I expect it will
	 * be common for other foo-loggers to want this sort of thing...
	 */
	int child_pid = 0;

	ap_cleanup_for_exec();
	/* No concept of a child process on Win32 */
	signal(SIGHUP, SIG_IGN);
	execl(SHELL_PATH, SHELL_PATH, "-c", (char *)cmd, (char *)NULL);
	exit(1);
	/* NOT REACHED */
	return(child_pid);
}

static void
open_error_log(server_rec *s, pool *p)
{
	char *fname;

	if (*s->error_fname == '|') {
		FILE *dummy;
		if (!ap_spawn_child(p, error_log_child,
		    (void *)(s->error_fname+1), kill_after_timeout, &dummy,
		    NULL, NULL)) {
			perror("ap_spawn_child");
			fprintf(stderr, "Couldn't fork child for ErrorLog "
			    "process\n");
			exit(1);
		}

		s->error_log = dummy;
	} else if (!strncasecmp(s->error_fname, "syslog", 6)) {
		if ((fname = strchr(s->error_fname, ':'))) {
			const TRANS *fac;

			fname++;
			for (fac = facilities; fac->t_name; fac++) {
				if (!strcasecmp(fname, fac->t_name)) {
					openlog(ap_server_argv0,
					    LOG_NDELAY|LOG_CONS|LOG_PID,
					    fac->t_val);
					s->error_log = NULL;
					return;
				}
			}
		} else
			openlog(ap_server_argv0, LOG_NDELAY|LOG_CONS|LOG_PID,
			    LOG_LOCAL7);

		s->error_log = NULL;
	} else {
		fname = ap_server_root_relative(p, s->error_fname);
		if (!(s->error_log = ap_pfopen(p, fname, "a"))) {
			perror("fopen");
			fprintf(stderr, "%s: could not open error log file "
			    "%s.\n", ap_server_argv0, fname);
			exit(1);
		}
	}
}

API_EXPORT(void)
ap_open_logs(server_rec *s_main, pool *p)
{
	server_rec *virt, *q;
	int replace_stderr;


	open_error_log(s_main, p);

	replace_stderr = 1;
	if (s_main->error_log) {
		/* replace stderr with this new log */
		fflush(stderr);
		if (dup2(fileno(s_main->error_log), STDERR_FILENO) == -1)
			ap_log_error(APLOG_MARK, APLOG_CRIT, s_main,
			    "unable to replace stderr with error_log");
		else
			replace_stderr = 0;
	}
	/* note that stderr may still need to be replaced with something
	 * because it points to the old error log, or back to the tty
	 * of the submitter.
	 */
	if (replace_stderr && freopen("/dev/null", "w", stderr) == NULL)
		ap_log_error(APLOG_MARK, APLOG_CRIT, s_main,
		    "unable to replace stderr with /dev/null");

	for (virt = s_main->next; virt; virt = virt->next) {
		if (virt->error_fname) {
			for (q=s_main; q != virt; q = q->next)
				if (q->error_fname != NULL &&
				    strcmp(q->error_fname, virt->error_fname)
				    == 0)
					break;
			if (q == virt)
				open_error_log(virt, p);
			else 
				virt->error_log = q->error_log;
		} else
			virt->error_log = s_main->error_log;
	}
}

API_EXPORT(void)
ap_error_log2stderr(server_rec *s)
{
	if (s->error_log != NULL && fileno(s->error_log) != STDERR_FILENO)
		dup2(fileno(s->error_log), STDERR_FILENO);
}

static void
log_error_core(const char *file, int line, int level, const server_rec *s,
    const request_rec *r, const char *fmt, va_list args)
{
	char errstr[MAX_STRING_LEN];
	char scratch[MAX_STRING_LEN];
	size_t len;
	int save_errno = errno;
	FILE *logf;

	if (s == NULL) {
		/*
		 * If we are doing stderr logging (startup), don't log messages
		 * that are above the default server log level unless it is a
		 * startup/shutdown notice
		 */
		if (((level & APLOG_LEVELMASK) != APLOG_NOTICE) &&
		    ((level & APLOG_LEVELMASK) > DEFAULT_LOGLEVEL))
			return;
		logf = stderr;
	} else if (s->error_log) {
		/*
		 * If we are doing normal logging, don't log messages that are
		 * above the server log level unless it is a startup/shutdown
		 * notice
		 */
		if (((level & APLOG_LEVELMASK) != APLOG_NOTICE) &&
		    ((level & APLOG_LEVELMASK) > s->loglevel))
			return;
		logf = s->error_log;
	} else {
		/*
		 * If we are doing syslog logging, don't log messages that are
		 * above the server log level (including a startup/shutdown
		 * notice)
		 */
		if ((level & APLOG_LEVELMASK) > s->loglevel)
			return;
		logf = NULL;
	}

	if (logf)
		len = ap_snprintf(errstr, sizeof(errstr), "[%s] ",
		    ap_get_time());
	else
		len = 0;

	len += ap_snprintf(errstr + len, sizeof(errstr) - len,
			"[%s] ", priorities[level & APLOG_LEVELMASK].t_name);

	if (file && (level & APLOG_LEVELMASK) == APLOG_DEBUG)
		len += ap_snprintf(errstr + len, sizeof(errstr) - len,
		    "%s(%d): ", file, line);
	if (r)
		/* XXX: TODO: add a method of selecting whether logged client
		 * addresses are in dotted quad or resolved form... dotted
		 * quad is the most secure, which is why I'm implementing it
		 * first. -djg
		 */
		len += ap_snprintf(errstr + len, sizeof(errstr) - len,
		    "[client %s] ", r->connection->remote_ip);

	if (!(level & APLOG_NOERRNO) && (save_errno != 0))
		len += ap_snprintf(errstr + len, sizeof(errstr) - len,
		    "(%d)%s: ", save_errno, strerror(save_errno));

	if (ap_vsnprintf(scratch, sizeof(scratch) - len, fmt, args))
		len += ap_escape_errorlog_item(errstr + len, scratch,
		    sizeof(errstr) - len);

	/* NULL if we are logging to syslog */
	if (logf) {
		fputs(errstr, logf);
		fputc('\n', logf);
		fflush(logf);
	} else
		syslog(level & APLOG_LEVELMASK, "%s", errstr);
}
	
API_EXPORT_NONSTD(void)
ap_log_error(const char *file, int line, int level, const server_rec *s,
    const char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	log_error_core(file, line, level, s, NULL, fmt, args);
	va_end(args);
}

API_EXPORT_NONSTD(void)
ap_log_rerror(const char *file, int line, int level, const request_rec *r,
    const char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	log_error_core(file, line, level, r->server, r, fmt, args);
	/*
	 * IF the error level is 'warning' or more severe,
	 * AND there isn't already error text associated with this request,
	 * THEN make the message text available to ErrorDocument and
	 * other error processors.  This can be disabled by stuffing
	 * something, even an empty string, into the "error-notes" cell
	 * before calling this routine.
	 */
	va_end(args);
	va_start(args,fmt); 
	if (((level & APLOG_LEVELMASK) <= APLOG_WARNING)
		&& (ap_table_get(r->notes, "error-notes") == NULL)) {
		ap_table_setn(r->notes, "error-notes",
		    ap_escape_html(r->pool, ap_pvsprintf(r->pool, fmt, args)));
	}
	va_end(args);
}

API_EXPORT(void)
ap_log_pid(pool *p, char *fname)
{
	FILE *pid_file;
	struct stat finfo;
	static pid_t saved_pid = -1;
	pid_t mypid;
	mode_t u;

	if (!fname) 
		return;

	fname = ap_server_root_relative(p, fname);
	mypid = getpid();
	if (!ap_server_chroot_desired() && mypid != saved_pid 
	    && stat(fname, &finfo) == 0)
	  /* USR1 and HUP call this on each restart.
	   * Only warn on first time through for this pid.
	   *
	   * XXX: Could just write first time through too, although
	   *	  that may screw up scripts written to do something
	   *	  based on the last modification time of the pid file.
	   */
		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL, "%s",
		    ap_psprintf(p, "pid file %s overwritten -- Unclean shutdown"
		    " of previous Apache run?", fname));

	u = umask(022);
	(void)umask(u | 022);
	if(!(pid_file = fopen(fname, "w"))) {
		perror("fopen");
		fprintf(stderr, "%s: could not log pid to file %s\n",
		    ap_server_argv0, fname);
		exit(1);
	}
	(void)umask(u);
	fprintf(pid_file, "%ld\n", (long)mypid);
	fclose(pid_file);
	saved_pid = mypid;
}

API_EXPORT(void)
ap_log_error_old(const char *err, server_rec *s)
{
	ap_log_error(APLOG_MARK, APLOG_ERR, s, "%s", err);
}

API_EXPORT(void)
ap_log_unixerr(const char *routine, const char *file, const char *msg,
    server_rec *s)
{
	ap_log_error(file, 0, APLOG_ERR, s, "%s", msg);
}

API_EXPORT_NONSTD(void)
ap_log_printf(const server_rec *s, const char *fmt, ...)
{
	va_list args;
	
	va_start(args, fmt);
	log_error_core(APLOG_MARK, APLOG_ERR, s, NULL, fmt, args);
	va_end(args);
}

API_EXPORT(void)
ap_log_reason(const char *reason, const char *file, request_rec *r) 
{
	ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
	    "access to %s failed for %s, reason: %s", file,
	    ap_get_remote_host(r->connection, r->per_dir_config, REMOTE_NAME),
	    reason);
}

API_EXPORT(void)
ap_log_assert(const char *szExp, const char *szFile, int nLine)
{
	fprintf(stderr, "[%s] file %s, line %d, assertion \"%s\" failed\n",
	    ap_get_time(), szFile, nLine, szExp);
	/* unix assert does an abort leading to a core dump */
	abort();
}

/* piped log support */

/* forward declaration */
static void piped_log_maintenance(int reason, void *data, ap_wait_t status);

static int
piped_log_spawn(piped_log *pl)
{
	int pid;

	ap_block_alarms();
	pid = fork();
	if (pid == 0) {
		/* XXX: need to check what open fds the logger is actually
		 *      passed,
		 * XXX: and CGIs for that matter ... cleanup_for_exec *should*
		 * XXX: close all the relevant stuff, but hey, it could be
		 *      broken. */
		RAISE_SIGSTOP(PIPED_LOG_SPAWN);
		/* we're now in the child */
		close(STDIN_FILENO);
		dup2(pl->fds[0], STDIN_FILENO);

		ap_cleanup_for_exec();
		signal(SIGCHLD, SIG_DFL);	/* for HPUX */
		signal(SIGHUP, SIG_IGN);
		execl(SHELL_PATH, SHELL_PATH, "-c", pl->program, (char *)NULL);
		fprintf(stderr,
		    "piped_log_spawn: unable to exec %s -c '%s': %s\n",
		    SHELL_PATH, pl->program, strerror (errno));
		exit(1);
	}
	if (pid == -1) {
		fprintf(stderr,
		    "piped_log_spawn: unable to fork(): %s\n", strerror(errno));
		ap_unblock_alarms();
		return -1;
	}
	ap_unblock_alarms();
	pl->pid = pid;
	ap_register_other_child(pid, piped_log_maintenance, pl, pl->fds[1]);
	return 0;
}


static void
piped_log_maintenance(int reason, void *data, ap_wait_t status)
{
	piped_log *pl = data;

	switch (reason) {
	case OC_REASON_DEATH:
	case OC_REASON_LOST:
		pl->pid = -1;
		ap_unregister_other_child(pl);
		if (pl->program == NULL)
			/* during a restart */
			break;
		if (piped_log_spawn(pl) == -1)
			/* what can we do?  This could be the error log we're having
			 * problems opening up... */
			fprintf(stderr,
			    "piped_log_maintenance: unable to respawn '%s': %s\n",
			    pl->program, strerror(errno));
		break;
	case OC_REASON_UNWRITABLE:
		/* We should not kill off the pipe here, since it may only be
		 * full. If it really is locked, we should kill it off manually.
		 */
		break;
	case OC_REASON_RESTART:
		pl->program = NULL;
		if (pl->pid != -1)
			kill(pl->pid, SIGTERM);
		break;
	case OC_REASON_UNREGISTER:
		break;
	}
}


static void
piped_log_cleanup(void *data)
{
	piped_log *pl = data;

	if (pl->pid != -1)
		kill(pl->pid, SIGTERM);
	
	ap_unregister_other_child(pl);
	close(pl->fds[0]);
	close(pl->fds[1]);
}


static void
piped_log_cleanup_for_exec(void *data)
{
	piped_log *pl = data;

	close(pl->fds[0]);
	close(pl->fds[1]);
}

static int
piped_log_magic_cleanup(void *data)
{
	piped_log *pl = data;

	/* Yes, I _do_ mean a binary and */
	return ap_close_fd_on_exec(pl->fds[0]) &
	    ap_close_fd_on_exec(pl->fds[1]);
}

API_EXPORT(piped_log *)
ap_open_piped_log(pool *p, const char *program)
{
	piped_log *pl;

	pl = ap_palloc(p, sizeof (*pl));
	pl->p = p;
	pl->program = ap_pstrdup(p, program);
	pl->pid = -1;
	ap_block_alarms ();
	if (pipe(pl->fds) == -1) {
		int save_errno = errno;
		ap_unblock_alarms();
		errno = save_errno;
		return NULL;
	}
	ap_register_cleanup_ex(p, pl, piped_log_cleanup,
	    piped_log_cleanup_for_exec, piped_log_magic_cleanup);
	if (piped_log_spawn(pl) == -1) {
		int save_errno = errno;
		ap_kill_cleanup(p, pl, piped_log_cleanup);
		close(pl->fds[0]);
		close(pl->fds[1]);
		ap_unblock_alarms();
		errno = save_errno;
		return NULL;
	}
	ap_unblock_alarms();
	return pl;
}

API_EXPORT(void)
ap_close_piped_log(piped_log *pl)
{
	ap_block_alarms();
	piped_log_cleanup(pl);
	ap_kill_cleanup(pl->p, pl, piped_log_cleanup);
	ap_unblock_alarms();
}
@


1.20
log
@Fix calls to printf-like functions which passed a non-fixed string
as the format and no variable args.
Replace "%#0.*X" with "%#.*X": the zero-fill flag is ignored/implied
on numeric conversions when a precision is specified.

ok jung@@ millert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: http_log.c,v 1.19 2008/05/14 09:25:38 mbalmer Exp $ */
@


1.19
log
@More KNF/readability changes.

no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: http_log.c,v 1.18 2008/05/14 08:42:20 mbalmer Exp $ */
d374 1
a374 1
		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
@


1.18
log
@Next chunk of KNF/readability changes.

no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: http_log.c,v 1.17 2005/02/09 12:13:09 henning Exp $ */
d23 2
a24 2
 *        "This product includes software developed by the
 *         Apache Software Foundation (http://www.apache.org/)."
@


1.17
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: http_log.c,v 1.16 2004/12/02 19:42:47 henning Exp $ */
d23 2
a24 2
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
d81 1
a81 1
	int	t_val;
d85 21
a105 21
    {"auth",	LOG_AUTH},
    {"authpriv",LOG_AUTHPRIV},
    {"cron", 	LOG_CRON},
    {"daemon",	LOG_DAEMON},
    {"ftp",	LOG_FTP},
    {"kern",	LOG_KERN},
    {"lpr",	LOG_LPR},
    {"mail",	LOG_MAIL},
    {"news",	LOG_NEWS},
    {"syslog",	LOG_SYSLOG},
    {"user",	LOG_USER},
    {"uucp",	LOG_UUCP},
    {"local0",	LOG_LOCAL0},
    {"local1",	LOG_LOCAL1},
    {"local2",	LOG_LOCAL2},
    {"local3",	LOG_LOCAL3},
    {"local4",	LOG_LOCAL4},
    {"local5",	LOG_LOCAL5},
    {"local6",	LOG_LOCAL6},
    {"local7",	LOG_LOCAL7},
    {NULL,		-1},
d109 9
a117 9
    {"emerg",	APLOG_EMERG},
    {"alert",	APLOG_ALERT},
    {"crit",	APLOG_CRIT},
    {"error",	APLOG_ERR},
    {"warn",	APLOG_WARNING},
    {"notice",	APLOG_NOTICE},
    {"info",	APLOG_INFO},
    {"debug",	APLOG_DEBUG},
    {NULL,	-1},
d120 2
a121 1
static int error_log_child(void *cmd, child_info *pinfo)
d123 29
a151 42
    /* Child process code for 'ErrorLog "|..."';
     * may want a common framework for this, since I expect it will
     * be common for other foo-loggers to want this sort of thing...
     */
    int child_pid = 0;

    ap_cleanup_for_exec();
    /* No concept of a child process on Win32 */
    signal(SIGHUP, SIG_IGN);
    execl(SHELL_PATH, SHELL_PATH, "-c", (char *)cmd, (char *)NULL);
    exit(1);
    /* NOT REACHED */
    return(child_pid);
}

static void open_error_log(server_rec *s, pool *p)
{
    char *fname;

    if (*s->error_fname == '|') {
	FILE *dummy;
	if (!ap_spawn_child(p, error_log_child, (void *)(s->error_fname+1),
			    kill_after_timeout, &dummy, NULL, NULL)) {
	    perror("ap_spawn_child");
	    fprintf(stderr, "Couldn't fork child for ErrorLog process\n");
	    exit(1);
	}

	s->error_log = dummy;
    }

    else if (!strncasecmp(s->error_fname, "syslog", 6)) {
	if ((fname = strchr(s->error_fname, ':'))) {
	    const TRANS *fac;

	    fname++;
	    for (fac = facilities; fac->t_name; fac++) {
		if (!strcasecmp(fname, fac->t_name)) {
		    openlog(ap_server_argv0, LOG_NDELAY|LOG_CONS|LOG_PID,
			    fac->t_val);
		    s->error_log = NULL;
		    return;
a152 4
	    }
	}
	else
	    openlog(ap_server_argv0, LOG_NDELAY|LOG_CONS|LOG_PID, LOG_LOCAL7);
d154 28
a181 9
	s->error_log = NULL;
    }
    else {
	fname = ap_server_root_relative(p, s->error_fname);
        if (!(s->error_log = ap_pfopen(p, fname, "a"))) {
            perror("fopen");
            fprintf(stderr, "%s: could not open error log file %s.\n",
		    ap_server_argv0, fname);
            exit(1);
a182 1
    }
d185 2
a186 1
API_EXPORT(void) ap_open_logs(server_rec *s_main, pool *p)
d188 2
a189 2
    server_rec *virt, *q;
    int replace_stderr;
d192 1
a192 1
    open_error_log(s_main, p);
d194 9
a202 9
    replace_stderr = 1;
    if (s_main->error_log) {
	/* replace stderr with this new log */
	fflush(stderr);
	if (dup2(fileno(s_main->error_log), STDERR_FILENO) == -1) {
	    ap_log_error(APLOG_MARK, APLOG_CRIT, s_main,
		"unable to replace stderr with error_log");
	} else {
	    replace_stderr = 0;
d204 21
a224 21
    }
    /* note that stderr may still need to be replaced with something
     * because it points to the old error log, or back to the tty
     * of the submitter.
     */
    if (replace_stderr && freopen("/dev/null", "w", stderr) == NULL) {
	ap_log_error(APLOG_MARK, APLOG_CRIT, s_main,
	    "unable to replace stderr with /dev/null");
    }

    for (virt = s_main->next; virt; virt = virt->next) {
	if (virt->error_fname)
	{
	    for (q=s_main; q != virt; q = q->next)
		if (q->error_fname != NULL &&
		    strcmp(q->error_fname, virt->error_fname) == 0)
		    break;
	    if (q == virt)
		open_error_log(virt, p);
	    else 
		virt->error_log = q->error_log;
a225 3
	else
	    virt->error_log = s_main->error_log;
    }
d228 5
a232 4
API_EXPORT(void) ap_error_log2stderr(server_rec *s) {
    if (   s->error_log != NULL
        && fileno(s->error_log) != STDERR_FILENO)
        dup2(fileno(s->error_log), STDERR_FILENO);
d235 3
a237 3
static void log_error_core(const char *file, int line, int level,
			   const server_rec *s, const request_rec *r,
			   const char *fmt, va_list args)
d239 5
a243 5
    char errstr[MAX_STRING_LEN];
    char scratch[MAX_STRING_LEN];
    size_t len;
    int save_errno = errno;
    FILE *logf;
d245 88
a332 1
    if (s == NULL) {
d334 6
a339 3
	 * If we are doing stderr logging (startup), don't log messages that are
	 * above the default server log level unless it is a startup/shutdown
	 * notice
d341 56
a396 30
	if (((level & APLOG_LEVELMASK) != APLOG_NOTICE) &&
	    ((level & APLOG_LEVELMASK) > DEFAULT_LOGLEVEL))
	    return;
	logf = stderr;
    }
    else if (s->error_log) {
	/*
	 * If we are doing normal logging, don't log messages that are
	 * above the server log level unless it is a startup/shutdown notice
	 */
	if (((level & APLOG_LEVELMASK) != APLOG_NOTICE) &&
	    ((level & APLOG_LEVELMASK) > s->loglevel))
	    return;
	logf = s->error_log;
    }
    else {
	/*
	 * If we are doing syslog logging, don't log messages that are
	 * above the server log level (including a startup/shutdown notice)
	 */
	if ((level & APLOG_LEVELMASK) > s->loglevel)
	    return;
	logf = NULL;
    }

    if (logf) {
	len = ap_snprintf(errstr, sizeof(errstr), "[%s] ", ap_get_time());
    } else {
	len = 0;
    }
d398 6
a403 2
    len += ap_snprintf(errstr + len, sizeof(errstr) - len,
	    "[%s] ", priorities[level & APLOG_LEVELMASK].t_name);
d405 9
a413 19
    if (file && (level & APLOG_LEVELMASK) == APLOG_DEBUG) {
	len += ap_snprintf(errstr + len, sizeof(errstr) - len,
		"%s(%d): ", file, line);
    }
    if (r) {
	/* XXX: TODO: add a method of selecting whether logged client
	 * addresses are in dotted quad or resolved form... dotted
	 * quad is the most secure, which is why I'm implementing it
	 * first. -djg
	 */
	len += ap_snprintf(errstr + len, sizeof(errstr) - len,
		"[client %s] ", r->connection->remote_ip);
    }
    if (!(level & APLOG_NOERRNO)
	&& (save_errno != 0)
	) {
	len += ap_snprintf(errstr + len, sizeof(errstr) - len,
		"(%d)%s: ", save_errno, strerror(save_errno));
    }
d415 7
a421 122
    if (ap_vsnprintf(scratch, sizeof(scratch) - len, fmt, args)) {
        len += ap_escape_errorlog_item(errstr + len, scratch,
                                       sizeof(errstr) - len);
    }

    /* NULL if we are logging to syslog */
    if (logf) {
	fputs(errstr, logf);
	fputc('\n', logf);
	fflush(logf);
    }
    else {
	syslog(level & APLOG_LEVELMASK, "%s", errstr);
    }
}
    
API_EXPORT_NONSTD(void) ap_log_error(const char *file, int line, int level,
			      const server_rec *s, const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    log_error_core(file, line, level, s, NULL, fmt, args);
    va_end(args);
}

API_EXPORT_NONSTD(void) ap_log_rerror(const char *file, int line, int level,
			       const request_rec *r, const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    log_error_core(file, line, level, r->server, r, fmt, args);
    /*
     * IF the error level is 'warning' or more severe,
     * AND there isn't already error text associated with this request,
     * THEN make the message text available to ErrorDocument and
     * other error processors.  This can be disabled by stuffing
     * something, even an empty string, into the "error-notes" cell
     * before calling this routine.
     */
    va_end(args);
    va_start(args,fmt); 
    if (((level & APLOG_LEVELMASK) <= APLOG_WARNING)
	&& (ap_table_get(r->notes, "error-notes") == NULL)) {
	ap_table_setn(r->notes, "error-notes",
		      ap_escape_html(r->pool, ap_pvsprintf(r->pool, fmt, 
		      args)));
    }
    va_end(args);
}

API_EXPORT(void) ap_log_pid(pool *p, char *fname)
{
    FILE *pid_file;
    struct stat finfo;
    static pid_t saved_pid = -1;
    pid_t mypid;
    mode_t u;

    if (!fname) 
	return;

    fname = ap_server_root_relative(p, fname);
    mypid = getpid();
    if (!ap_server_chroot_desired() && mypid != saved_pid 
      && stat(fname, &finfo) == 0) {
      /* USR1 and HUP call this on each restart.
       * Only warn on first time through for this pid.
       *
       * XXX: Could just write first time through too, although
       *      that may screw up scripts written to do something
       *      based on the last modification time of the pid file.
       */
      ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
		   ap_psprintf(p,
			       "pid file %s overwritten -- Unclean shutdown of previous Apache run?",
			       fname)
		   );
    }

    u = umask(022);
    (void) umask(u | 022);
    if(!(pid_file = fopen(fname, "w"))) {
	perror("fopen");
        fprintf(stderr, "%s: could not log pid to file %s\n",
		ap_server_argv0, fname);
        exit(1);
    }
    (void) umask(u);
    fprintf(pid_file, "%ld\n", (long)mypid);
    fclose(pid_file);
    saved_pid = mypid;
}

API_EXPORT(void) ap_log_error_old(const char *err, server_rec *s)
{
    ap_log_error(APLOG_MARK, APLOG_ERR, s, "%s", err);
}

API_EXPORT(void) ap_log_unixerr(const char *routine, const char *file,
			      const char *msg, server_rec *s)
{
    ap_log_error(file, 0, APLOG_ERR, s, "%s", msg);
}

API_EXPORT_NONSTD(void) ap_log_printf(const server_rec *s, const char *fmt, ...)
{
    va_list args;
    
    va_start(args, fmt);
    log_error_core(APLOG_MARK, APLOG_ERR, s, NULL, fmt, args);
    va_end(args);
}

API_EXPORT(void) ap_log_reason(const char *reason, const char *file, request_rec *r) 
{
    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
		"access to %s failed for %s, reason: %s",
		file,
		ap_get_remote_host(r->connection, r->per_dir_config, REMOTE_NAME),
		reason);
d424 2
a425 1
API_EXPORT(void) ap_log_assert(const char *szExp, const char *szFile, int nLine)
d427 1
a427 1
    fprintf(stderr, "[%s] file %s, line %d, assertion \"%s\" failed\n",
d429 2
a430 2
    /* unix assert does an abort leading to a core dump */
    abort();
d438 2
a439 1
static int piped_log_spawn(piped_log *pl)
d441 1
a441 1
    int pid;
d443 28
a470 23
    ap_block_alarms();
    pid = fork();
    if (pid == 0) {
	/* XXX: need to check what open fds the logger is actually passed,
	 * XXX: and CGIs for that matter ... cleanup_for_exec *should*
	 * XXX: close all the relevant stuff, but hey, it could be broken. */
	RAISE_SIGSTOP(PIPED_LOG_SPAWN);
	/* we're now in the child */
	close(STDIN_FILENO);
	dup2(pl->fds[0], STDIN_FILENO);

	ap_cleanup_for_exec();
	signal(SIGCHLD, SIG_DFL);	/* for HPUX */
	signal(SIGHUP, SIG_IGN);
	execl(SHELL_PATH, SHELL_PATH, "-c", pl->program, (char *)NULL);
	fprintf(stderr,
	    "piped_log_spawn: unable to exec %s -c '%s': %s\n",
	    SHELL_PATH, pl->program, strerror (errno));
	exit(1);
    }
    if (pid == -1) {
	fprintf(stderr,
	    "piped_log_spawn: unable to fork(): %s\n", strerror (errno));
d472 3
a474 6
	return -1;
    }
    ap_unblock_alarms();
    pl->pid = pid;
    ap_register_other_child(pid, piped_log_maintenance, pl, pl->fds[1]);
    return 0;
d478 32
a509 12
static void piped_log_maintenance(int reason, void *data, ap_wait_t status)
{
    piped_log *pl = data;

    switch (reason) {
    case OC_REASON_DEATH:
    case OC_REASON_LOST:
	pl->pid = -1;
	ap_unregister_other_child(pl);
	if (pl->program == NULL) {
	    /* during a restart */
	    break;
a510 24
	if (piped_log_spawn(pl) == -1) {
	    /* what can we do?  This could be the error log we're having
	     * problems opening up... */
	    fprintf(stderr,
		"piped_log_maintenance: unable to respawn '%s': %s\n",
		pl->program, strerror(errno));
	}
	break;
    
    case OC_REASON_UNWRITABLE:
        /* We should not kill off the pipe here, since it may only be full.
         * If it really is locked, we should kill it off manually. */
	break;
    
    case OC_REASON_RESTART:
	pl->program = NULL;
	if (pl->pid != -1) {
	    kill(pl->pid, SIGTERM);
	}
	break;

    case OC_REASON_UNREGISTER:
	break;
    }
d514 2
a515 1
static void piped_log_cleanup(void *data)
d517 1
a517 1
    piped_log *pl = data;
d519 6
a524 6
    if (pl->pid != -1) {
	kill(pl->pid, SIGTERM);
    }
    ap_unregister_other_child(pl);
    close(pl->fds[0]);
    close(pl->fds[1]);
d528 2
a529 1
static void piped_log_cleanup_for_exec(void *data)
d531 1
a531 1
    piped_log *pl = data;
d533 2
a534 2
    close(pl->fds[0]);
    close(pl->fds[1]);
d537 2
a538 1
static int piped_log_magic_cleanup(void *data)
d540 1
a540 1
    piped_log *pl = data;
d542 3
a544 2
    /* Yes, I _do_ mean a binary and */
    return ap_close_fd_on_exec(pl->fds[0]) & ap_close_fd_on_exec(pl->fds[1]);
d547 2
a548 1
API_EXPORT(piped_log *) ap_open_piped_log(pool *p, const char *program)
d550 1
a550 1
    piped_log *pl;
d552 22
a573 18
    pl = ap_palloc(p, sizeof (*pl));
    pl->p = p;
    pl->program = ap_pstrdup(p, program);
    pl->pid = -1;
    ap_block_alarms ();
    if (pipe(pl->fds) == -1) {
	int save_errno = errno;
	ap_unblock_alarms();
	errno = save_errno;
	return NULL;
    }
    ap_register_cleanup_ex(p, pl, piped_log_cleanup, piped_log_cleanup_for_exec,
			 piped_log_magic_cleanup);
    if (piped_log_spawn(pl) == -1) {
	int save_errno = errno;
	ap_kill_cleanup(p, pl, piped_log_cleanup);
	close(pl->fds[0]);
	close(pl->fds[1]);
d575 1
a575 5
	errno = save_errno;
	return NULL;
    }
    ap_unblock_alarms();
    return pl;
d578 7
a584 6
API_EXPORT(void) ap_close_piped_log(piped_log *pl)
{
    ap_block_alarms();
    piped_log_cleanup(pl);
    ap_kill_cleanup(pl->p, pl, piped_log_cleanup);
    ap_unblock_alarms();
@


1.16
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: http_log.c,v 1.15 2004/06/07 04:21:30 brad Exp $ */
a83 2
#ifdef HAVE_SYSLOG

a85 1
#ifdef LOG_AUTHPRIV
a86 2
#endif
#ifdef LOG_CRON
a87 2
#endif
#ifdef LOG_DAEMON
a88 2
#endif
#ifdef LOG_FTP
a89 2
#endif
#ifdef LOG_KERN
a90 2
#endif
#ifdef LOG_LPR
a91 2
#endif
#ifdef LOG_MAIL
a92 2
#endif
#ifdef LOG_NEWS
a93 2
#endif
#ifdef LOG_SYSLOG
a94 2
#endif
#ifdef LOG_USER
a95 2
#endif
#ifdef LOG_UUCP
a96 2
#endif
#ifdef LOG_LOCAL0
a97 2
#endif
#ifdef LOG_LOCAL1
a98 2
#endif
#ifdef LOG_LOCAL2
a99 2
#endif
#ifdef LOG_LOCAL3
a100 2
#endif
#ifdef LOG_LOCAL4
a101 2
#endif
#ifdef LOG_LOCAL5
a102 2
#endif
#ifdef LOG_LOCAL6
a103 2
#endif
#ifdef LOG_LOCAL7
a104 1
#endif
a106 1
#endif
a128 1
#ifdef SIGHUP
a130 1
#endif /* ndef SIGHUP */
a152 1
#ifdef HAVE_SYSLOG
a171 1
#endif
a238 1
#ifndef AP_UNSAFE_ERROR_LOG_UNESCAPED
a239 1
#endif
a303 1
#ifndef AP_UNSAFE_ERROR_LOG_UNESCAPED
a307 3
#else
    len += ap_vsnprintf(errstr + len, sizeof(errstr) - len, fmt, args);
#endif
a314 1
#ifdef HAVE_SYSLOG
a317 1
#endif
a437 2
#ifndef NO_PIPED_LOGS
#ifndef NO_RELIABLE_PIPED_LOGS
a447 1
	/* XXX: this needs porting to OS2 and WIN32 */
a583 45

#else
static int piped_log_child(void *cmd, child_info *pinfo)
{
    /* Child process code for 'TransferLog "|..."';
     * may want a common framework for this, since I expect it will
     * be common for other foo-loggers to want this sort of thing...
     */
    int child_pid = 1;

    ap_cleanup_for_exec();
#ifdef SIGHUP
    signal(SIGHUP, SIG_IGN);
#endif
    execl (SHELL_PATH, SHELL_PATH, "-c", (char *)cmd, (char *)NULL);
    perror("exec");
    fprintf(stderr, "Exec of shell for logging failed!!!\n");
    return(child_pid);
}


API_EXPORT(piped_log *) ap_open_piped_log(pool *p, const char *program)
{
    piped_log *pl;
    FILE *dummy;
    if (!ap_spawn_child(p, piped_log_child, (void *)program,
			kill_after_timeout, &dummy, NULL, NULL)) {
	perror("ap_spawn_child");
	fprintf(stderr, "Couldn't fork child for piped log process\n");
	exit (1);
    }
    pl = ap_palloc(p, sizeof (*pl));
    pl->p = p;
    pl->write_f = dummy;

    return pl;
}


API_EXPORT(void) ap_close_piped_log(piped_log *pl)
{
    ap_pfclose(pl->p, pl->write_f);
}
#endif
#endif
@


1.15
log
@Apache does not filter terminal escape sequences from its error logs, which
could make it easier for attackers to insert those sequences into terminal
emulators containing vulnerabilities related to escape sequences.

CAN-2003-0020

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: http_log.c,v 1.14 2003/08/21 13:11:35 henning Exp $ */
a167 3
#if defined(WIN32)
    char *shellcmd;
#endif
a173 15
#if defined(NETWARE)
    child_pid = spawnlp(P_NOWAIT, SHELL_PATH, (char *)cmd);
    return(child_pid);
#elif defined(WIN32)
    shellcmd = getenv("COMSPEC");
    if (!shellcmd)
        shellcmd = SHELL_PATH;
    child_pid = spawnl(_P_NOWAIT, shellcmd, shellcmd, "/c", (char *)cmd, NULL);
    return(child_pid);
#elif defined(OS2)
    /* For OS/2 we need to use a '/' and spawn the child rather than exec as
     * we haven't forked */
    child_pid = spawnl(P_NOWAIT, SHELL_PATH, SHELL_PATH, "/c", (char *)cmd, NULL);
    return(child_pid);
#else    
a174 1
#endif    
a185 8
#ifdef TPF
        TPF_FORK_CHILD cld;
        cld.filename = s->error_fname+1;
        cld.subprocess_env = NULL;
        cld.prog_type = FORK_NAME;
        if (!ap_spawn_child(p, NULL, &cld,
                            kill_after_timeout, &dummy, NULL, NULL)) {
#else
a187 1
#endif /* TPF */
a232 7
#ifdef OS390
    /*
     * Cause errno2 (reason code) information to be generated whenever
     * strerror(errno) is invoked.
     */
    setenv("_EDC_ADD_ERRNO2", "1", 1);
#endif
a330 1
#ifndef TPF
a331 18
#ifdef _OSD_POSIX
	char tmp[256];
	char *e = strrchr(file, '/');

	/* In OSD/POSIX, the compiler returns for __FILE__
	 * a string like: __FILE__="*POSIX(/usr/include/stdio.h)"
	 * (it even returns an absolute path for sources in
	 * the current directory). Here we try to strip this
	 * down to the basename.
	 */
	if (e != NULL && e[1] != '\0') {
	    ap_snprintf(tmp, sizeof(tmp), "%s", &e[1]);
	    e = &tmp[strlen(tmp)-1];
	    if (*e == ')')
		*e = '\0';
	    file = tmp;
	}
#endif /*_OSD_POSIX*/
a334 1
#endif /* TPF */
a345 3
#ifdef WIN32
	&& !(level & APLOG_WIN32ERROR)
#endif
a349 44
#ifdef WIN32
    if (level & APLOG_WIN32ERROR) {
	int nChars;
	int nErrorCode;

	nErrorCode = GetLastError();
	len += ap_snprintf(errstr + len, sizeof(errstr) - len,
	    "(%d)", nErrorCode);

	nChars = FormatMessage( 
	    FORMAT_MESSAGE_FROM_SYSTEM,
	    NULL,
	    nErrorCode,
	    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), /* Default language */
	    (LPTSTR) errstr + len,
	    sizeof(errstr) - len,
	    NULL 
	);
	len += nChars;
	if (nChars == 0) {
	    /* Um, error occurred, but we can't recurse to log it again
	     * (and it would probably only fail anyway), so lets just
	     * log the numeric value.
	     */
	    nErrorCode = GetLastError();
	    len += ap_snprintf(errstr + len, sizeof(errstr) - len,
			       "(FormatMessage failed with code %d): ",
			       nErrorCode);
	}
	else {
	    /* FormatMessage put the message in the buffer, but it may
	     * have appended a newline (\r\n). So remove it and use
	     * ": " instead like the Unix errors. The error may also
	     * end with a . before the return - if so, trash it.
	     */
	    if (len > 1 && errstr[len-2] == '\r' && errstr[len-1] == '\n') {
		if (len > 2 && errstr[len-3] == '.')
		    len--;
		errstr[len-2] = ':';
		errstr[len-1] = ' ';
	    }
	}
    }
#endif
a414 1
#ifndef WIN32
a415 1
#endif
a437 1
#ifndef WIN32
a439 1
#endif
a445 1
#ifndef WIN32
a446 1
#endif
a484 1
#ifndef WIN32
a486 3
#else
    exit(1);
#endif
a648 3
#if defined(WIN32)
    char *shellcmd;
#endif
a653 15
#if defined(NETWARE)
    child_pid = spawnlp(P_NOWAIT, SHELL_PATH, (char *)cmd);
    return(child_pid);
#elif defined(WIN32)
    shellcmd = getenv("COMSPEC");
    if (!shellcmd)
        shellcmd = SHELL_PATH;
    child_pid = spawnl(_P_NOWAIT, shellcmd, shellcmd, "/c", (char *)cmd, NULL);
    return(child_pid);
#elif defined(OS2)
    /* For OS/2 we need to use a '/' and spawn the child rather than exec as
     * we haven't forked */
    child_pid = spawnl(P_NOWAIT, SHELL_PATH, SHELL_PATH, "/c", (char *)cmd, NULL);
    return(child_pid);
#else
a654 1
#endif
@


1.14
log
@merge
@
text
@d1 1
a1 1
/*	$OpenBSD: http_log.c,v 1.13 2002/08/15 15:49:33 henning Exp $ */
d319 3
d453 6
d460 1
@


1.14.2.1
log
@MFC:
Fix by brad@@

Apache does not filter terminal escape sequences from its error logs, which
could make it easier for attackers to insert those sequences into terminal
emulators containing vulnerabilities related to escape sequences.

CAN-2003-0020
@
text
@d1 1
a1 1
/*	$OpenBSD: http_log.c,v 1.14 2003/08/21 13:11:35 henning Exp $ */
a318 3
#ifndef AP_UNSAFE_ERROR_LOG_UNESCAPED
    char scratch[MAX_STRING_LEN];
#endif
a449 6
#ifndef AP_UNSAFE_ERROR_LOG_UNESCAPED
    if (ap_vsnprintf(scratch, sizeof(scratch) - len, fmt, args)) {
        len += ap_escape_errorlog_item(errstr + len, scratch,
                                       sizeof(errstr) - len);
    }
#else
a450 1
#endif
@


1.14.4.1
log
@MFC:
Fix by brad@@

Apache does not filter terminal escape sequences from its error logs, which
could make it easier for attackers to insert those sequences into terminal
emulators containing vulnerabilities related to escape sequences.

CAN-2003-0020
@
text
@d1 1
a1 1
/*	$OpenBSD: http_log.c,v 1.14 2003/08/21 13:11:35 henning Exp $ */
a318 3
#ifndef AP_UNSAFE_ERROR_LOG_UNESCAPED
    char scratch[MAX_STRING_LEN];
#endif
a449 6
#ifndef AP_UNSAFE_ERROR_LOG_UNESCAPED
    if (ap_vsnprintf(scratch, sizeof(scratch) - len, fmt, args)) {
        len += ap_escape_errorlog_item(errstr + len, scratch,
                                       sizeof(errstr) - len);
    }
#else
a450 1
#endif
@


1.13
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d6 1
a6 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
d697 7
d720 2
a721 1
    ap_register_cleanup(p, pl, piped_log_cleanup, piped_log_cleanup_for_exec);
@


1.12
log
@merge
@
text
@d1 2
@


1.11
log
@get rid of the "Unclean shutdown" warning if started in secure mode.
this warning is issued if an old pid file exists. As we cannot remove our
pidfile on shutdown (lack of priviledges) this warning always occured.
@
text
@a341 12
#ifdef TPF
    else if (tpf_child) {
    /*
     * If we are doing normal logging, don't log messages that are
     * above the server log level unless it is a startup/shutdown notice
     */
    if (((level & APLOG_LEVELMASK) != APLOG_NOTICE) &&
        ((level & APLOG_LEVELMASK) > s->loglevel))
        return;
    logf = stderr;
    }
#endif /* TPF */
@


1.10
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d526 2
a527 1
    if (mypid != saved_pid && stat(fname, &finfo) == 0) {
@


1.9
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d254 1
a254 1
void ap_open_logs(server_rec *s_main, pool *p)
d475 1
a475 1
API_EXPORT(void) ap_log_error(const char *file, int line, int level,
d485 1
a485 1
API_EXPORT(void) ap_log_rerror(const char *file, int line, int level,
d511 1
a511 1
void ap_log_pid(pool *p, char *fname)
d570 1
a570 1
API_EXPORT(void) ap_log_printf(const server_rec *s, const char *fmt, ...)
@


1.8
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d190 1
a190 1
    execl(SHELL_PATH, SHELL_PATH, "-c", (char *)cmd, NULL);
d626 1
a626 1
	execl(SHELL_PATH, SHELL_PATH, "-c", pl->program, NULL);
d775 1
a775 1
    execl (SHELL_PATH, SHELL_PATH, "-c", (char *)cmd, NULL);
@


1.7
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1995-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 6
a24 9
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
d26 4
a29 3
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
d31 3
a33 4
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
d35 4
a38 4
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 3
a52 5
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
d54 3
d668 2
a669 3
	if (pl->pid != -1) {
	    kill(pl->pid, SIGTERM);
	}
@


1.6
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d165 3
d178 4
a181 1
    child_pid = spawnl(_P_NOWAIT, SHELL_PATH, SHELL_PATH, "/c", (char *)cmd, NULL);
d258 8
d752 3
d764 4
a767 1
    child_pid = spawnl(_P_NOWAIT, SHELL_PATH, SHELL_PATH, "/c", (char *)cmd, NULL);
@


1.5
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d490 2
a491 1
		      ap_pvsprintf(r->pool, fmt, args));
d502 3
d526 4
d536 3
@


1.4
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d171 4
a174 1
#if defined(WIN32)
d413 1
a413 1
	    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
d576 1
d732 4
a735 1
#if defined(WIN32)
a755 9
#ifdef TPF
    TPF_FORK_CHILD cld;
    cld.filename = (char *)program;
    cld.subprocess_env = NULL;
    cld.prog_type = FORK_NAME;

    if (!ap_spawn_child (p, NULL, &cld,
      kill_after_timeout, &dummy, NULL, NULL)){
#else
a757 1
#endif /* TPF */
d774 1
@


1.3
log
@Apache 1.3.4 merge
@
text
@d175 4
a178 2
    /* For OS/2 we need to use a '/' */
    execl(SHELL_PATH, SHELL_PATH, "/c", (char *)cmd, NULL);
d193 8
a200 1

d203 1
d324 12
d347 1
a347 2
	len = ap_snprintf(errstr, sizeof(errstr), "%s: [%s] ",
			  ap_server_argv0, ap_get_time());
d355 1
d378 1
d482 2
d732 4
a735 2
    /* For OS/2 we need to use a '/' */
    execl (SHELL_PATH, SHELL_PATH, "/c", (char *)cmd, NULL);
d749 5
d755 3
d760 1
@


1.2
log
@Apache 1.3.3 merge + proxy_segv fix
@
text
@d2 1
a2 1
 * Copyright (c) 1995-1998 The Apache Group.  All rights reserved.
d68 1
d210 2
a211 1
		    openlog("httpd", LOG_NDELAY|LOG_CONS|LOG_PID, fac->t_val);
d218 1
a218 1
	    openlog("httpd", LOG_NDELAY|LOG_CONS|LOG_PID, LOG_LOCAL7);
d227 2
a228 1
            fprintf(stderr,"httpd: could not open error log file %s.\n", fname);
d325 2
a326 1
	len = ap_snprintf(errstr, sizeof(errstr), "[%s] ", ap_get_time());
d400 2
a401 1
		"(FormatMessage failed with code %d): ", nErrorCode);
d489 1
a489 1
			       "pid file %s overwritten -- Unclean shutdown of previous apache run?",
d496 2
a497 1
        fprintf(stderr, "httpd: could not log pid to file %s\n", fname);
@


1.1
log
@Initial revision
@
text
@d157 1
a157 1
static int error_log_child (void *cmd, child_info *pinfo)
d168 1
a168 1
    signal (SIGHUP, SIG_IGN);
d171 1
a171 1
    child_pid = spawnl (_P_NOWAIT, SHELL_PATH, SHELL_PATH, "/c", (char *)cmd, NULL);
d175 1
a175 1
    execl (SHELL_PATH, SHELL_PATH, "/c", (char *)cmd, NULL);
d177 1
a177 1
    execl (SHELL_PATH, SHELL_PATH, "-c", (char *)cmd, NULL);
d179 1
a179 1
    exit (1);
d184 1
a184 1
static void open_error_log (server_rec *s, pool *p)
d193 3
a195 3
	    perror ("ap_spawn_child");
	    fprintf (stderr, "Couldn't fork child for ErrorLog process\n");
	    exit (1);
d222 2
a223 2
	fname = ap_server_root_relative (p, s->error_fname);
        if(!(s->error_log = ap_pfopen(p, fname, "a"))) {
d231 1
a231 1
void ap_open_logs (server_rec *s_main, pool *p)
d236 1
a236 1
    open_error_log (s_main, p);
d242 1
a242 1
	if (dup2(fileno(s_main->error_log), 2) == -1) {
d265 4
a268 2
	    if (q == virt) open_error_log (virt, p);
	    else virt->error_log = q->error_log;
d275 4
a278 3
API_EXPORT(void) ap_error_log2stderr (server_rec *s) {
    if(fileno(s->error_log) != STDERR_FILENO)
        dup2(fileno(s->error_log),STDERR_FILENO);
d281 1
a281 1
static void log_error_core (const char *file, int line, int level,
d429 1
a429 1
API_EXPORT(void) ap_log_error (const char *file, int line, int level,
d446 12
a457 5
    if (ap_table_get(r->notes, "error-notes") == NULL) {
	char errstr[MAX_STRING_LEN];

	ap_vsnprintf(errstr, sizeof(errstr), fmt, args);
	ap_table_set(r->notes, "error-notes", errstr);
d462 1
a462 1
void ap_log_pid (pool *p, char *fname)
d469 2
a470 1
    if (!fname) return;
d472 1
a472 1
    fname = ap_server_root_relative (p, fname);
d474 1
a474 1
    if (mypid != saved_pid && stat(fname,&finfo) == 0) {
d489 1
a489 1
    if(!(pid_file = fopen(fname,"w"))) {
d491 1
a491 1
        fprintf(stderr,"httpd: could not log pid to file %s\n", fname);
d494 1
a494 1
    fprintf(pid_file,"%ld\n",(long)mypid);
d499 1
a499 1
API_EXPORT(void) ap_log_error_old (const char *err, server_rec *s)
d504 1
a504 1
API_EXPORT(void) ap_log_unixerr (const char *routine, const char *file,
d510 1
a510 1
API_EXPORT(void) ap_log_printf (const server_rec *s, const char *fmt, ...)
d519 1
a519 1
API_EXPORT(void) ap_log_reason (const char *reason, const char *file, request_rec *r) 
d528 1
a528 1
API_EXPORT(void) ap_log_assert (const char *szExp, const char *szFile, int nLine)
d544 1
a544 1
static void piped_log_maintenance (int reason, void *data, ap_wait_t status);
d546 1
a546 1
static int piped_log_spawn (piped_log *pl)
d559 2
a560 2
	close (STDIN_FILENO);
	dup2 (pl->fds[0], STDIN_FILENO);
d562 5
a566 5
	ap_cleanup_for_exec ();
	signal (SIGCHLD, SIG_DFL);	/* for HPUX */
	signal (SIGHUP, SIG_IGN);
	execl (SHELL_PATH, SHELL_PATH, "-c", pl->program, NULL);
	fprintf (stderr,
d569 1
a569 1
	exit (1);
d572 1
a572 1
	fprintf (stderr,
d574 1
a574 1
	ap_unblock_alarms ();
d579 1
a579 1
    ap_register_other_child (pid, piped_log_maintenance, pl, pl->fds[1]);
d584 1
a584 1
static void piped_log_maintenance (int reason, void *data, ap_wait_t status)
d592 1
a592 1
	ap_unregister_other_child (pl);
d597 1
a597 1
	if (piped_log_spawn (pl) == -1) {
d600 1
a600 1
	    fprintf (stderr,
d602 1
a602 1
		pl->program, strerror (errno));
d608 1
a608 1
	    kill (pl->pid, SIGTERM);
d615 1
a615 1
	    kill (pl->pid, SIGTERM);
d625 1
a625 1
static void piped_log_cleanup (void *data)
d630 1
a630 1
	kill (pl->pid, SIGTERM);
d632 3
a634 3
    ap_unregister_other_child (pl);
    close (pl->fds[0]);
    close (pl->fds[1]);
d638 1
a638 1
static void piped_log_cleanup_for_exec (void *data)
d642 2
a643 2
    close (pl->fds[0]);
    close (pl->fds[1]);
d647 1
a647 1
API_EXPORT(piped_log *) ap_open_piped_log (pool *p, const char *program)
d651 1
a651 1
    pl = ap_palloc (p, sizeof (*pl));
d653 1
a653 1
    pl->program = ap_pstrdup (p, program);
d656 1
a656 1
    if (pipe (pl->fds) == -1) {
d662 2
a663 2
    ap_register_cleanup (p, pl, piped_log_cleanup, piped_log_cleanup_for_exec);
    if (piped_log_spawn (pl) == -1) {
d665 4
a668 4
	ap_kill_cleanup (p, pl, piped_log_cleanup);
	close (pl->fds[0]);
	close (pl->fds[1]);
	ap_unblock_alarms ();
d672 1
a672 1
    ap_unblock_alarms ();
d676 1
a676 1
API_EXPORT(void) ap_close_piped_log (piped_log *pl)
d678 4
a681 4
    ap_block_alarms ();
    piped_log_cleanup (pl);
    ap_kill_cleanup (pl->p, pl, piped_log_cleanup);
    ap_unblock_alarms ();
d685 1
a685 1
static int piped_log_child (void *cmd, child_info *pinfo)
d695 1
a695 1
    signal (SIGHUP, SIG_IGN);
d698 1
a698 1
    child_pid = spawnl (_P_NOWAIT, SHELL_PATH, SHELL_PATH, "/c", (char *)cmd, NULL);
d706 2
a707 2
    perror ("exec");
    fprintf (stderr, "Exec of shell for logging failed!!!\n");
d712 1
a712 1
API_EXPORT(piped_log *) ap_open_piped_log (pool *p, const char *program)
d719 2
a720 2
	perror ("ap_spawn_child");
	fprintf (stderr, "Couldn't fork child for piped log process\n");
d723 1
a723 1
    pl = ap_palloc (p, sizeof (*pl));
d731 1
a731 1
API_EXPORT(void) ap_close_piped_log (piped_log *pl)
d733 1
a733 1
    ap_pfclose (pl->p, pl->write_f);
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 9
a24 6
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
d26 3
a28 4
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
d30 4
a33 3
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
d35 4
a38 4
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 5
a54 3
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
a55 3
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
a67 1
#include "http_conf_globals.h"
d157 1
a157 1
static int error_log_child(void *cmd, child_info *pinfo)
a163 3
#if defined(WIN32)
    char *shellcmd;
#endif
d168 1
a168 1
    signal(SIGHUP, SIG_IGN);
d170 2
a171 8
#if defined(NETWARE)
    child_pid = spawnlp(P_NOWAIT, SHELL_PATH, (char *)cmd);
    return(child_pid);
#elif defined(WIN32)
    shellcmd = getenv("COMSPEC");
    if (!shellcmd)
        shellcmd = SHELL_PATH;
    child_pid = spawnl(_P_NOWAIT, shellcmd, shellcmd, "/c", (char *)cmd, NULL);
d174 2
a175 4
    /* For OS/2 we need to use a '/' and spawn the child rather than exec as
     * we haven't forked */
    child_pid = spawnl(P_NOWAIT, SHELL_PATH, SHELL_PATH, "/c", (char *)cmd, NULL);
    return(child_pid);
d177 1
a177 1
    execl(SHELL_PATH, SHELL_PATH, "-c", (char *)cmd, NULL);
d179 1
a179 1
    exit(1);
d184 1
a184 1
static void open_error_log(server_rec *s, pool *p)
d190 1
a190 8
#ifdef TPF
        TPF_FORK_CHILD cld;
        cld.filename = s->error_fname+1;
        cld.subprocess_env = NULL;
        cld.prog_type = FORK_NAME;
        if (!ap_spawn_child(p, NULL, &cld,
                            kill_after_timeout, &dummy, NULL, NULL)) {
#else
d193 3
a195 4
#endif /* TPF */
	    perror("ap_spawn_child");
	    fprintf(stderr, "Couldn't fork child for ErrorLog process\n");
	    exit(1);
d209 1
a209 2
		    openlog(ap_server_argv0, LOG_NDELAY|LOG_CONS|LOG_PID,
			    fac->t_val);
d216 1
a216 1
	    openlog(ap_server_argv0, LOG_NDELAY|LOG_CONS|LOG_PID, LOG_LOCAL7);
d222 2
a223 2
	fname = ap_server_root_relative(p, s->error_fname);
        if (!(s->error_log = ap_pfopen(p, fname, "a"))) {
d225 1
a225 2
            fprintf(stderr, "%s: could not open error log file %s.\n",
		    ap_server_argv0, fname);
d231 1
a231 1
API_EXPORT(void) ap_open_logs(server_rec *s_main, pool *p)
d236 1
a236 9
#ifdef OS390
    /*
     * Cause errno2 (reason code) information to be generated whenever
     * strerror(errno) is invoked.
     */
    setenv("_EDC_ADD_ERRNO2", "1", 1);
#endif

    open_error_log(s_main, p);
d242 1
a242 1
	if (dup2(fileno(s_main->error_log), STDERR_FILENO) == -1) {
d265 2
a266 4
	    if (q == virt)
		open_error_log(virt, p);
	    else 
		virt->error_log = q->error_log;
d273 3
a275 4
API_EXPORT(void) ap_error_log2stderr(server_rec *s) {
    if (   s->error_log != NULL
        && fileno(s->error_log) != STDERR_FILENO)
        dup2(fileno(s->error_log), STDERR_FILENO);
d278 1
a278 1
static void log_error_core(const char *file, int line, int level,
a326 1
#ifndef TPF
a348 1
#endif /* TPF */
d380 1
a380 1
	    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), /* Default language */
d393 1
a393 2
			       "(FormatMessage failed with code %d): ",
			       nErrorCode);
d426 1
a426 1
API_EXPORT_NONSTD(void) ap_log_error(const char *file, int line, int level,
d436 1
a436 1
API_EXPORT_NONSTD(void) ap_log_rerror(const char *file, int line, int level,
d443 5
a447 15
    /*
     * IF the error level is 'warning' or more severe,
     * AND there isn't already error text associated with this request,
     * THEN make the message text available to ErrorDocument and
     * other error processors.  This can be disabled by stuffing
     * something, even an empty string, into the "error-notes" cell
     * before calling this routine.
     */
    va_end(args);
    va_start(args,fmt); 
    if (((level & APLOG_LEVELMASK) <= APLOG_WARNING)
	&& (ap_table_get(r->notes, "error-notes") == NULL)) {
	ap_table_setn(r->notes, "error-notes",
		      ap_escape_html(r->pool, ap_pvsprintf(r->pool, fmt, 
		      args)));
d452 1
a452 1
API_EXPORT(void) ap_log_pid(pool *p, char *fname)
a457 3
#ifndef WIN32
    mode_t u;
#endif
d459 1
a459 2
    if (!fname) 
	return;
d461 1
a461 1
    fname = ap_server_root_relative(p, fname);
d463 1
a463 1
    if (mypid != saved_pid && stat(fname, &finfo) == 0) {
d473 1
a473 1
			       "pid file %s overwritten -- Unclean shutdown of previous Apache run?",
d478 1
a478 5
#ifndef WIN32
    u = umask(022);
    (void) umask(u | 022);
#endif
    if(!(pid_file = fopen(fname, "w"))) {
d480 1
a480 2
        fprintf(stderr, "%s: could not log pid to file %s\n",
		ap_server_argv0, fname);
d483 1
a483 4
#ifndef WIN32
    (void) umask(u);
#endif
    fprintf(pid_file, "%ld\n", (long)mypid);
d488 1
a488 1
API_EXPORT(void) ap_log_error_old(const char *err, server_rec *s)
d493 1
a493 1
API_EXPORT(void) ap_log_unixerr(const char *routine, const char *file,
d499 1
a499 1
API_EXPORT_NONSTD(void) ap_log_printf(const server_rec *s, const char *fmt, ...)
d508 1
a508 1
API_EXPORT(void) ap_log_reason(const char *reason, const char *file, request_rec *r) 
d517 1
a517 1
API_EXPORT(void) ap_log_assert(const char *szExp, const char *szFile, int nLine)
a530 1
#ifndef NO_PIPED_LOGS
d533 1
a533 1
static void piped_log_maintenance(int reason, void *data, ap_wait_t status);
d535 1
a535 1
static int piped_log_spawn(piped_log *pl)
d548 2
a549 2
	close(STDIN_FILENO);
	dup2(pl->fds[0], STDIN_FILENO);
d551 5
a555 5
	ap_cleanup_for_exec();
	signal(SIGCHLD, SIG_DFL);	/* for HPUX */
	signal(SIGHUP, SIG_IGN);
	execl(SHELL_PATH, SHELL_PATH, "-c", pl->program, NULL);
	fprintf(stderr,
d558 1
a558 1
	exit(1);
d561 1
a561 1
	fprintf(stderr,
d563 1
a563 1
	ap_unblock_alarms();
d568 1
a568 1
    ap_register_other_child(pid, piped_log_maintenance, pl, pl->fds[1]);
d573 1
a573 1
static void piped_log_maintenance(int reason, void *data, ap_wait_t status)
d581 1
a581 1
	ap_unregister_other_child(pl);
d586 1
a586 1
	if (piped_log_spawn(pl) == -1) {
d589 1
a589 1
	    fprintf(stderr,
d591 1
a591 1
		pl->program, strerror(errno));
d596 3
a598 2
        /* We should not kill off the pipe here, since it may only be full.
         * If it really is locked, we should kill it off manually. */
d604 1
a604 1
	    kill(pl->pid, SIGTERM);
d614 1
a614 1
static void piped_log_cleanup(void *data)
d619 1
a619 1
	kill(pl->pid, SIGTERM);
d621 3
a623 3
    ap_unregister_other_child(pl);
    close(pl->fds[0]);
    close(pl->fds[1]);
d627 1
a627 1
static void piped_log_cleanup_for_exec(void *data)
d631 2
a632 2
    close(pl->fds[0]);
    close(pl->fds[1]);
d636 1
a636 1
API_EXPORT(piped_log *) ap_open_piped_log(pool *p, const char *program)
d640 1
a640 1
    pl = ap_palloc(p, sizeof (*pl));
d642 1
a642 1
    pl->program = ap_pstrdup(p, program);
d645 1
a645 1
    if (pipe(pl->fds) == -1) {
d651 2
a652 2
    ap_register_cleanup(p, pl, piped_log_cleanup, piped_log_cleanup_for_exec);
    if (piped_log_spawn(pl) == -1) {
d654 4
a657 4
	ap_kill_cleanup(p, pl, piped_log_cleanup);
	close(pl->fds[0]);
	close(pl->fds[1]);
	ap_unblock_alarms();
d661 1
a661 1
    ap_unblock_alarms();
d665 1
a665 1
API_EXPORT(void) ap_close_piped_log(piped_log *pl)
d667 4
a670 4
    ap_block_alarms();
    piped_log_cleanup(pl);
    ap_kill_cleanup(pl->p, pl, piped_log_cleanup);
    ap_unblock_alarms();
d674 1
a674 1
static int piped_log_child(void *cmd, child_info *pinfo)
a680 3
#if defined(WIN32)
    char *shellcmd;
#endif
d684 1
a684 1
    signal(SIGHUP, SIG_IGN);
d686 2
a687 8
#if defined(NETWARE)
    child_pid = spawnlp(P_NOWAIT, SHELL_PATH, (char *)cmd);
    return(child_pid);
#elif defined(WIN32)
    shellcmd = getenv("COMSPEC");
    if (!shellcmd)
        shellcmd = SHELL_PATH;
    child_pid = spawnl(_P_NOWAIT, shellcmd, shellcmd, "/c", (char *)cmd, NULL);
d690 2
a691 4
    /* For OS/2 we need to use a '/' and spawn the child rather than exec as
     * we haven't forked */
    child_pid = spawnl(P_NOWAIT, SHELL_PATH, SHELL_PATH, "/c", (char *)cmd, NULL);
    return(child_pid);
d695 2
a696 2
    perror("exec");
    fprintf(stderr, "Exec of shell for logging failed!!!\n");
d701 1
a701 1
API_EXPORT(piped_log *) ap_open_piped_log(pool *p, const char *program)
d705 1
d708 2
a709 2
	perror("ap_spawn_child");
	fprintf(stderr, "Couldn't fork child for piped log process\n");
d712 1
a712 1
    pl = ap_palloc(p, sizeof (*pl));
d720 1
a720 1
API_EXPORT(void) ap_close_piped_log(piped_log *pl)
d722 1
a722 1
    ap_pfclose(pl->p, pl->write_f);
a723 1
#endif
@


1.1.1.3
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
a693 7
static int piped_log_magic_cleanup(void *data)
{
    piped_log *pl = data;

    /* Yes, I _do_ mean a binary and */
    return ap_close_fd_on_exec(pl->fds[0]) & ap_close_fd_on_exec(pl->fds[1]);
}
d710 1
a710 2
    ap_register_cleanup_ex(p, pl, piped_log_cleanup, piped_log_cleanup_for_exec,
			 piped_log_magic_cleanup);
@


