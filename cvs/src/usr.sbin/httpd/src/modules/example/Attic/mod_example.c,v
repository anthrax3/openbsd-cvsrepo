head	1.11;
access;
symbols
	OPENBSD_5_5:1.10.0.34
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.30
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.28
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.26
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.24
	OPENBSD_5_0:1.10.0.22
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.20
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.18
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.14
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.16
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.12
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.4
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.4
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.3
	apache_1_3_27:1.1.1.3
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	apache_1_3_26:1.1.1.3
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.2.0.2
	OPENBSD_2_4_BASE:1.1.1.2
	apache_1_3_2:1.1.1.2
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	apache:1.1.1
	apache_1_2_6:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.04.22.14.47.26;	author henning;	state dead;
branches;
next	1.10;

1.10
date	2006.07.28.14.07.41;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.21.13.11.36;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.06.21.08.08;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.29.02.08.06;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.29.10.21.44;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.22.18.11;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.06.29.39;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.03.01.01.06.22;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.03.25.07.08.50;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.25.07.08.50;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.10.01.17.19.40;	author beck;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.07.19.21.28.52;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.21.12.53.40;	author henning;	state Exp;
branches;
next	;


desc
@@


1.11
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/* 
 * Apache example module.  Provide demonstrations of how modules do things.
 *
 */

#include "httpd.h"
#include "http_config.h"
#include "http_core.h"
#include "http_log.h"
#include "http_main.h"
#include "http_protocol.h"
#include "util_script.h"

#include <stdio.h>

/*--------------------------------------------------------------------------*/
/*                                                                          */
/* Data declarations.                                                       */
/*                                                                          */
/* Here are the static cells and structure declarations private to our      */
/* module.                                                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*
 * Sample configuration record.  Used for both per-directory and per-server
 * configuration data.
 *
 * It's perfectly reasonable to have two different structures for the two
 * different environments.  The same command handlers will be called for
 * both, though, so the handlers need to be able to tell them apart.  One
 * possibility is for both structures to start with an int which is zero for
 * one and 1 for the other.
 *
 * Note that while the per-directory and per-server configuration records are
 * available to most of the module handlers, they should be treated as
 * READ-ONLY by all except the command and merge handlers.  Sometimes handlers
 * are handed a record that applies to the current location by implication or
 * inheritance, and modifying it will change the rules for other locations.
 */
typedef struct excfg {
    int cmode;                  /* Environment to which record applies (directory,
                                 * server, or combination).
                                 */
#define CONFIG_MODE_SERVER 1
#define CONFIG_MODE_DIRECTORY 2
#define CONFIG_MODE_COMBO 3     /* Shouldn't ever happen. */
    int local;                  /* Boolean: "Example" directive declared here? */
    int congenital;             /* Boolean: did we inherit an "Example"? */
    char *trace;                /* Pointer to trace string. */
    char *loc;                  /* Location to which this record applies. */
} excfg;

/*
 * Let's set up a module-local static cell to point to the accreting callback
 * trace.  As each API callback is made to us, we'll tack on the particulars
 * to whatever we've already recorded.  To avoid massive memory bloat as
 * directories are walked again and again, we record the routine/environment
 * the first time (non-request context only), and ignore subsequent calls for
 * the same routine/environment.
 */
static const char *trace = NULL;
static table *static_calls_made = NULL;

/*
 * To avoid leaking memory from pools other than the per-request one, we
 * allocate a module-private pool, and then use a sub-pool of that which gets
 * freed each time we modify the trace.  That way previous layers of trace
 * data don't get lost.
 */
static pool *example_pool = NULL;
static pool *example_subpool = NULL;

/*
 * Declare ourselves so the configuration routines can find and know us.
 * We'll fill it in at the end of the module.
 */
module MODULE_VAR_EXPORT example_module;

/*--------------------------------------------------------------------------*/
/*                                                                          */
/* The following pseudo-prototype declarations illustrate the parameters    */
/* passed to command handlers for the different types of directive          */
/* syntax.  If an argument was specified in the directive definition        */
/* (look for "command_rec" below), it's available to the command handler    */
/* via the (void *) info field in the cmd_parms argument passed to the      */
/* handler (cmd->info for the examples below).                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*
 * Command handler for a NO_ARGS directive.
 *
 * static const char *handle_NO_ARGS(cmd_parms *cmd, void *mconfig);
 */

/*
 * Command handler for a RAW_ARGS directive.  The "args" argument is the text
 * of the commandline following the directive itself.
 *
 * static const char *handle_RAW_ARGS(cmd_parms *cmd, void *mconfig,
 *                                    const char *args);
 */

/*
 * Command handler for a FLAG directive.  The single parameter is passed in
 * "bool", which is either zero or not for Off or On respectively.
 *
 * static const char *handle_FLAG(cmd_parms *cmd, void *mconfig, int bool);
 */

/*
 * Command handler for a TAKE1 directive.  The single parameter is passed in
 * "word1".
 *
 * static const char *handle_TAKE1(cmd_parms *cmd, void *mconfig,
 *                                 char *word1);
 */

/*
 * Command handler for a TAKE2 directive.  TAKE2 commands must always have
 * exactly two arguments.
 *
 * static const char *handle_TAKE2(cmd_parms *cmd, void *mconfig,
 *                                 char *word1, char *word2);
 */

/*
 * Command handler for a TAKE3 directive.  Like TAKE2, these must have exactly
 * three arguments, or the parser complains and doesn't bother calling us.
 *
 * static const char *handle_TAKE3(cmd_parms *cmd, void *mconfig,
 *                                 char *word1, char *word2, char *word3);
 */

/*
 * Command handler for a TAKE12 directive.  These can take either one or two
 * arguments.
 * - word2 is a NULL pointer if no second argument was specified.
 *
 * static const char *handle_TAKE12(cmd_parms *cmd, void *mconfig,
 *                                  char *word1, char *word2);
 */

/*
 * Command handler for a TAKE123 directive.  A TAKE123 directive can be given,
 * as might be expected, one, two, or three arguments.
 * - word2 is a NULL pointer if no second argument was specified.
 * - word3 is a NULL pointer if no third argument was specified.
 *
 * static const char *handle_TAKE123(cmd_parms *cmd, void *mconfig,
 *                                   char *word1, char *word2, char *word3);
 */

/*
 * Command handler for a TAKE13 directive.  Either one or three arguments are
 * permitted - no two-parameters-only syntax is allowed.
 * - word2 and word3 are NULL pointers if only one argument was specified.
 *
 * static const char *handle_TAKE13(cmd_parms *cmd, void *mconfig,
 *                                  char *word1, char *word2, char *word3);
 */

/*
 * Command handler for a TAKE23 directive.  At least two and as many as three
 * arguments must be specified.
 * - word3 is a NULL pointer if no third argument was specified.
 *
 * static const char *handle_TAKE23(cmd_parms *cmd, void *mconfig,
 *                                  char *word1, char *word2, char *word3);
 */

/*
 * Command handler for a ITERATE directive.
 * - Handler is called once for each of n arguments given to the directive.
 * - word1 points to each argument in turn.
 *
 * static const char *handle_ITERATE(cmd_parms *cmd, void *mconfig,
 *                                   char *word1);
 */

/*
 * Command handler for a ITERATE2 directive.
 * - Handler is called once for each of the second and subsequent arguments
 *   given to the directive.
 * - word1 is the same for each call for a particular directive instance (the
 *   first argument).
 * - word2 points to each of the second and subsequent arguments in turn.
 *
 * static const char *handle_ITERATE2(cmd_parms *cmd, void *mconfig,
 *                                    char *word1, char *word2);
 */

/*--------------------------------------------------------------------------*/
/*                                                                          */
/* These routines are strictly internal to this module, and support its     */
/* operation.  They are not referenced by any external portion of the       */
/* server.                                                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*
 * Locate our directory configuration record for the current request.
 */
static excfg *our_dconfig(request_rec *r)
{

    return (excfg *) ap_get_module_config(r->per_dir_config, &example_module);
}

#if 0
/*
 * Locate our server configuration record for the specified server.
 */
static excfg *our_sconfig(server_rec *s)
{

    return (excfg *) ap_get_module_config(s->module_config, &example_module);
}

/*
 * Likewise for our configuration record for the specified request.
 */
static excfg *our_rconfig(request_rec *r)
{

    return (excfg *) ap_get_module_config(r->request_config, &example_module);
}
#endif

/*
 * This routine sets up some module-wide cells if they haven't been already.
 */
static void setup_module_cells()
{
    /*
     * If we haven't already allocated our module-private pool, do so now.
     */
    if (example_pool == NULL) {
        example_pool = ap_make_sub_pool(NULL);
    };
    /*
     * Likewise for the table of routine/environment pairs we visit outside of
     * request context.
     */
    if (static_calls_made == NULL) {
        static_calls_made = ap_make_table(example_pool, 16);
    };
}

/*
 * This routine is used to add a trace of a callback to the list.  We're
 * passed the server record (if available), the request record (if available),
 * a pointer to our private configuration record (if available) for the
 * environment to which the callback is supposed to apply, and some text.  We
 * turn this into a textual representation and add it to the tail of the list.
 * The list can be displayed by the example_handler() routine.
 *
 * If the call occurs within a request context (i.e., we're passed a request
 * record), we put the trace into the request pool and attach it to the
 * request via the notes mechanism.  Otherwise, the trace gets added
 * to the static (non-request-specific) list.
 *
 * Note that the r->notes table is only for storing strings; if you need to
 * maintain per-request data of any other type, you need to use another
 * mechanism.
 */

#define TRACE_NOTE "example-trace"

static void trace_add(server_rec *s, request_rec *r, excfg *mconfig,
                      const char *note)
{

    const char *sofar;
    char *addon;
    char *where;
    pool *p;
    const char *trace_copy;

    /*
     * Make sure our pools and tables are set up - we need 'em.
     */
    setup_module_cells();
    /*
     * Now, if we're in request-context, we use the request pool.
     */
    if (r != NULL) {
        p = r->pool;
        if ((trace_copy = ap_table_get(r->notes, TRACE_NOTE)) == NULL) {
            trace_copy = "";
        }
    }
    else {
        /*
         * We're not in request context, so the trace gets attached to our
         * module-wide pool.  We do the create/destroy every time we're called
         * in non-request context; this avoids leaking memory in some of
         * the subsequent calls that allocate memory only once (such as the
         * key formation below).
         *
         * Make a new sub-pool and copy any existing trace to it.  Point the
         * trace cell at the copied value.
         */
        p = ap_make_sub_pool(example_pool);
        if (trace != NULL) {
            trace = ap_pstrdup(p, trace);
        }
        /*
         * Now, if we have a sub-pool from before, nuke it and replace with
         * the one we just allocated.
         */
        if (example_subpool != NULL) {
            ap_destroy_pool(example_subpool);
        }
        example_subpool = p;
        trace_copy = trace;
    }
    /*
     * If we weren't passed a configuration record, we can't figure out to
     * what location this call applies.  This only happens for co-routines
     * that don't operate in a particular directory or server context.  If we
     * got a valid record, extract the location (directory or server) to which
     * it applies.
     */
    where = (mconfig != NULL) ? mconfig->loc : "nowhere";
    where = (where != NULL) ? where : "";
    /*
     * Now, if we're not in request context, see if we've been called with
     * this particular combination before.  The table is allocated in the
     * module's private pool, which doesn't get destroyed.
     */
    if (r == NULL) {
        char *key;

        key = ap_pstrcat(p, note, ":", where, NULL);
        if (ap_table_get(static_calls_made, key) != NULL) {
            /*
             * Been here, done this.
             */
            return;
        }
        else {
            /*
             * First time for this combination of routine and environment -
             * log it so we don't do it again.
             */
            ap_table_set(static_calls_made, key, "been here");
        }
    }
    addon = ap_pstrcat(p, "   <LI>\n", "    <DL>\n", "     <DT><SAMP>",
                    note, "</SAMP>\n", "     </DT>\n", "     <DD><SAMP>[",
                    where, "]</SAMP>\n", "     </DD>\n", "    </DL>\n",
                    "   </LI>\n", NULL);
    sofar = (trace_copy == NULL) ? "" : trace_copy;
    trace_copy = ap_pstrcat(p, sofar, addon, NULL);
    if (r != NULL) {
        ap_table_set(r->notes, TRACE_NOTE, trace_copy);
    }
    else {
        trace = trace_copy;
    }
    /*
     * You *could* change the following if you wanted to see the calling
     * sequence reported in the server's error_log, but beware - almost all of
     * these co-routines are called for every single request, and the impact
     * on the size (and readability) of the error_log is considerable.
     */
#define EXAMPLE_LOG_EACH 0
#if EXAMPLE_LOG_EACH
    if (s != NULL) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, s, "mod_example: %s", note);
    }
#endif
}

/*--------------------------------------------------------------------------*/
/* We prototyped the various syntax for command handlers (routines that     */
/* are called when the configuration parser detects a directive declared    */
/* by our module) earlier.  Now we actually declare a "real" routine that   */
/* will be invoked by the parser when our "real" directive is               */
/* encountered.                                                             */
/*                                                                          */
/* If a command handler encounters a problem processing the directive, it   */
/* signals this fact by returning a non-NULL pointer to a string            */
/* describing the problem.                                                  */
/*                                                                          */
/* The magic return value DECLINE_CMD is used to deal with directives       */
/* that might be declared by multiple modules.  If the command handler      */
/* returns NULL, the directive was processed; if it returns DECLINE_CMD,    */
/* the next module (if any) that declares the directive is given a chance   */
/* at it.  If it returns any other value, it's treated as the text of an    */
/* error message.                                                           */
/*--------------------------------------------------------------------------*/
/* 
 * Command handler for the NO_ARGS "Example" directive.  All we do is mark the
 * call in the trace log, and flag the applicability of the directive to the
 * current location in that location's configuration record.
 */
static const char *cmd_example(cmd_parms *cmd, void *mconfig)
{

    excfg *cfg = (excfg *) mconfig;

    /*
     * "Example Wuz Here"
     */
    cfg->local = 1;
    trace_add(cmd->server, NULL, cfg, "cmd_example()");
    return NULL;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/* Now we declare our content handlers, which are invoked when the server   */
/* encounters a document which our module is supposed to have a chance to   */
/* see.  (See mod_mime's SetHandler and AddHandler directives, and the      */
/* mod_info and mod_status examples, for more details.)                     */
/*                                                                          */
/* Since content handlers are dumping data directly into the connexion      */
/* (using the r*() routines, such as rputs() and rprintf()) without         */
/* intervention by other parts of the server, they need to make             */
/* sure any accumulated HTTP headers are sent first.  This is done by       */
/* calling send_http_header().  Otherwise, no header will be sent at all,   */
/* and the output sent to the client will actually be HTTP-uncompliant.     */
/*--------------------------------------------------------------------------*/
/* 
 * Sample content handler.  All this does is display the call list that has
 * been built up so far.
 *
 * The return value instructs the caller concerning what happened and what to
 * do next:
 *  OK ("we did our thing")
 *  DECLINED ("this isn't something with which we want to get involved")
 *  HTTP_mumble ("an error status should be reported")
 */
static int example_handler(request_rec *r)
{

    excfg *dcfg;

    dcfg = our_dconfig(r);
    trace_add(r->server, r, dcfg, "example_handler()");
    /*
     * We're about to start sending content, so we need to force the HTTP
     * headers to be sent at this point.  Otherwise, no headers will be sent
     * at all.  We can set any we like first, of course.  **NOTE** Here's
     * where you set the "Content-type" header, and you do so by putting it in
     * r->content_type, *not* r->headers_out("Content-type").  If you don't
     * set it, it will be filled in with the server's default type (typically
     * "text/plain").  You *must* also ensure that r->content_type is lower
     * case.
     *
     * We also need to start a timer so the server can know if the connexion
     * is broken.
     */
    r->content_type = "text/html";

    ap_soft_timeout("send example call trace", r);
    ap_send_http_header(r);

    /*
     * If we're only supposed to send header information (HEAD request), we're
     * already there.
     */
    if (r->header_only) {
        ap_kill_timeout(r);
        return OK;
    }

    /*
     * Now send our actual output.  Since we tagged this as being
     * "text/html", we need to embed any HTML.
     */
    ap_rputs(DOCTYPE_HTML_3_2, r);
    ap_rputs("<HTML>\n", r);
    ap_rputs(" <HEAD>\n", r);
    ap_rputs("  <TITLE>mod_example Module Content-Handler Output\n", r);
    ap_rputs("  </TITLE>\n", r);
    ap_rputs(" </HEAD>\n", r);
    ap_rputs(" <BODY>\n", r);
    ap_rputs("  <H1><SAMP>mod_example</SAMP> Module Content-Handler Output\n", r);
    ap_rputs("  </H1>\n", r);
    ap_rputs("  <P>\n", r);
    ap_rprintf(r, "  Apache HTTP Server version: \"%s\"\n",
	    ap_get_server_version());
    ap_rputs("  </P>\n", r);
    ap_rputs("  <P>\n", r);
    ap_rputs("  The format for the callback trace is:\n", r);
    ap_rputs("  </P>\n", r);
    ap_rputs("  <DL>\n", r);
    ap_rputs("   <DT><EM>n</EM>.<SAMP>&lt;routine-name&gt;", r);
    ap_rputs("(&lt;routine-data&gt;)</SAMP>\n", r);
    ap_rputs("   </DT>\n", r);
    ap_rputs("   <DD><SAMP>[&lt;applies-to&gt;]</SAMP>\n", r);
    ap_rputs("   </DD>\n", r);
    ap_rputs("  </DL>\n", r);
    ap_rputs("  <P>\n", r);
    ap_rputs("  The <SAMP>&lt;routine-data&gt;</SAMP> is supplied by\n", r);
    ap_rputs("  the routine when it requests the trace,\n", r);
    ap_rputs("  and the <SAMP>&lt;applies-to&gt;</SAMP> is extracted\n", r);
    ap_rputs("  from the configuration record at the time of the trace.\n", r);
    ap_rputs("  <STRONG>SVR()</STRONG> indicates a server environment\n", r);
    ap_rputs("  (blank means the main or default server, otherwise it's\n", r);
    ap_rputs("  the name of the VirtualHost); <STRONG>DIR()</STRONG>\n", r);
    ap_rputs("  indicates a location in the URL or filesystem\n", r);
    ap_rputs("  namespace.\n", r);
    ap_rputs("  </P>\n", r);
    ap_rprintf(r, "  <H2>Static callbacks so far:</H2>\n  <OL>\n%s  </OL>\n",
            trace);
    ap_rputs("  <H2>Request-specific callbacks so far:</H2>\n", r);
    ap_rprintf(r, "  <OL>\n%s  </OL>\n", ap_table_get(r->notes, TRACE_NOTE));
    ap_rputs("  <H2>Environment for <EM>this</EM> call:</H2>\n", r);
    ap_rputs("  <UL>\n", r);
    ap_rprintf(r, "   <LI>Applies-to: <SAMP>%s</SAMP>\n   </LI>\n", dcfg->loc);
    ap_rprintf(r, "   <LI>\"Example\" directive declared here: %s\n   </LI>\n",
            (dcfg->local ? "YES" : "NO"));
    ap_rprintf(r, "   <LI>\"Example\" inherited: %s\n   </LI>\n",
            (dcfg->congenital ? "YES" : "NO"));
    ap_rputs("  </UL>\n", r);
    ap_rputs(" </BODY>\n", r);
    ap_rputs("</HTML>\n", r);
    /*
     * We're all done, so cancel the timeout we set.  Since this is probably
     * the end of the request we *could* assume this would be done during
     * post-processing - but it's possible that another handler might be
     * called and inherit our outstanding timer.  Not good; to each its own.
     */
    ap_kill_timeout(r);
    /*
     * We did what we wanted to do, so tell the rest of the server we
     * succeeded.
     */
    return OK;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/* Now let's declare routines for each of the callback phase in order.      */
/* (That's the order in which they're listed in the callback list, *not     */
/* the order in which the server calls them!  See the command_rec           */
/* declaration near the bottom of this file.)  Note that these may be       */
/* called for situations that don't relate primarily to our function - in   */
/* other words, the fixup handler shouldn't assume that the request has     */
/* to do with "example" stuff.                                              */
/*                                                                          */
/* With the exception of the content handler, all of our routines will be   */
/* called for each request, unless an earlier handler from another module   */
/* aborted the sequence.                                                    */
/*                                                                          */
/* Handlers that are declared as "int" can return the following:            */
/*                                                                          */
/*  OK          Handler accepted the request and did its thing with it.     */
/*  DECLINED    Handler took no action.                                     */
/*  HTTP_mumble Handler looked at request and found it wanting.             */
/*                                                                          */
/* What the server does after calling a module handler depends upon the     */
/* handler's return value.  In all cases, if the handler returns            */
/* DECLINED, the server will continue to the next module with an handler    */
/* for the current phase.  However, if the handler return a non-OK,         */
/* non-DECLINED status, the server aborts the request right there.  If      */
/* the handler returns OK, the server's next action is phase-specific;      */
/* see the individual handler comments below for details.                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/* 
 * This function is called during server initialisation.  Any information
 * that needs to be recorded must be in static cells, since there's no
 * configuration record.
 *
 * There is no return value.
 */

/*
 * All our module-initialiser does is add its trace to the log.
 */
static void example_init(server_rec *s, pool *p)
{

    char *note;
    char *sname = s->server_hostname;

    /*
     * Set up any module cells that ought to be initialised.
     */
    setup_module_cells();
    /*
     * The arbitrary text we add to our trace entry indicates for which server
     * we're being called.
     */
    sname = (sname != NULL) ? sname : "";
    note = ap_pstrcat(p, "example_init(", sname, ")", NULL);
    trace_add(s, NULL, NULL, note);
}

/* 
 * This function is called during server initialisation when an heavy-weight
 * process (such as a child) is being initialised.  As with the
 * module-initialisation function, any information that needs to be recorded
 * must be in static cells, since there's no configuration record.
 *
 * There is no return value.
 */

/*
 * All our process-initialiser does is add its trace to the log.
 */
static void example_child_init(server_rec *s, pool *p)
{

    char *note;
    char *sname = s->server_hostname;

    /*
     * Set up any module cells that ought to be initialised.
     */
    setup_module_cells();
    /*
     * The arbitrary text we add to our trace entry indicates for which server
     * we're being called.
     */
    sname = (sname != NULL) ? sname : "";
    note = ap_pstrcat(p, "example_child_init(", sname, ")", NULL);
    trace_add(s, NULL, NULL, note);
}

/* 
 * This function is called when an heavy-weight process (such as a child) is
 * being run down or destroyed.  As with the child-initialisation function,
 * any information that needs to be recorded must be in static cells, since
 * there's no configuration record.
 *
 * There is no return value.
 */

/*
 * All our process-death routine does is add its trace to the log.
 */
static void example_child_exit(server_rec *s, pool *p)
{

    char *note;
    char *sname = s->server_hostname;

    /*
     * The arbitrary text we add to our trace entry indicates for which server
     * we're being called.
     */
    sname = (sname != NULL) ? sname : "";
    note = ap_pstrcat(p, "example_child_exit(", sname, ")", NULL);
    trace_add(s, NULL, NULL, note);
}

/*
 * This function gets called to create a per-directory configuration
 * record.  This will be called for the "default" server environment, and for
 * each directory for which the parser finds any of our directives applicable.
 * If a directory doesn't have any of our directives involved (i.e., they
 * aren't in the .htaccess file, or a <Location>, <Directory>, or related
 * block), this routine will *not* be called - the configuration for the
 * closest ancestor is used.
 *
 * The return value is a pointer to the created module-specific
 * structure.
 */
static void *example_create_dir_config(pool *p, char *dirspec)
{

    excfg *cfg;
    char *dname = dirspec;

    /*
     * Allocate the space for our record from the pool supplied.
     */
    cfg = (excfg *) ap_pcalloc(p, sizeof(excfg));
    /*
     * Now fill in the defaults.  If there are any `parent' configuration
     * records, they'll get merged as part of a separate callback.
     */
    cfg->local = 0;
    cfg->congenital = 0;
    cfg->cmode = CONFIG_MODE_DIRECTORY;
    /*
     * Finally, add our trace to the callback list.
     */
    dname = (dname != NULL) ? dname : "";
    cfg->loc = ap_pstrcat(p, "DIR(", dname, ")", NULL);
    trace_add(NULL, NULL, cfg, "example_create_dir_config()");
    return (void *) cfg;
}

/*
 * This function gets called to merge two per-directory configuration
 * records.  This is typically done to cope with things like .htaccess files
 * or <Location> directives for directories that are beneath one for which a
 * configuration record was already created.  The routine has the
 * responsibility of creating a new record and merging the contents of the
 * other two into it appropriately.  If the module doesn't declare a merge
 * routine, the record for the closest ancestor location (that has one) is
 * used exclusively.
 *
 * The routine MUST NOT modify any of its arguments!
 *
 * The return value is a pointer to the created module-specific structure
 * containing the merged values.
 */
static void *example_merge_dir_config(pool *p, void *parent_conf,
                                      void *newloc_conf)
{

    excfg *merged_config = (excfg *) ap_pcalloc(p, sizeof(excfg));
    excfg *pconf = (excfg *) parent_conf;
    excfg *nconf = (excfg *) newloc_conf;
    char *note;

    /*
     * Some things get copied directly from the more-specific record, rather
     * than getting merged.
     */
    merged_config->local = nconf->local;
    merged_config->loc = ap_pstrdup(p, nconf->loc);
    /*
     * Others, like the setting of the `congenital' flag, get ORed in.  The
     * setting of that particular flag, for instance, is TRUE if it was ever
     * true anywhere in the upstream configuration.
     */
    merged_config->congenital = (pconf->congenital | pconf->local);
    /*
     * If we're merging records for two different types of environment (server
     * and directory), mark the new record appropriately.  Otherwise, inherit
     * the current value.
     */
    merged_config->cmode =
        (pconf->cmode == nconf->cmode) ? pconf->cmode : CONFIG_MODE_COMBO;
    /*
     * Now just record our being called in the trace list.  Include the
     * locations we were asked to merge.
     */
    note = ap_pstrcat(p, "example_merge_dir_config(\"", pconf->loc, "\",\"",
                   nconf->loc, "\")", NULL);
    trace_add(NULL, NULL, merged_config, note);
    return (void *) merged_config;
}

/*
 * This function gets called to create a per-server configuration
 * record.  It will always be called for the "default" server.
 *
 * The return value is a pointer to the created module-specific
 * structure.
 */
static void *example_create_server_config(pool *p, server_rec *s)
{

    excfg *cfg;
    char *sname = s->server_hostname;

    /*
     * As with the example_create_dir_config() reoutine, we allocate and fill
     * in an empty record.
     */
    cfg = (excfg *) ap_pcalloc(p, sizeof(excfg));
    cfg->local = 0;
    cfg->congenital = 0;
    cfg->cmode = CONFIG_MODE_SERVER;
    /*
     * Note that we were called in the trace list.
     */
    sname = (sname != NULL) ? sname : "";
    cfg->loc = ap_pstrcat(p, "SVR(", sname, ")", NULL);
    trace_add(s, NULL, cfg, "example_create_server_config()");
    return (void *) cfg;
}

/*
 * This function gets called to merge two per-server configuration
 * records.  This is typically done to cope with things like virtual hosts and
 * the default server configuration  The routine has the responsibility of
 * creating a new record and merging the contents of the other two into it
 * appropriately.  If the module doesn't declare a merge routine, the more
 * specific existing record is used exclusively.
 *
 * The routine MUST NOT modify any of its arguments!
 *
 * The return value is a pointer to the created module-specific structure
 * containing the merged values.
 */
static void *example_merge_server_config(pool *p, void *server1_conf,
                                         void *server2_conf)
{

    excfg *merged_config = (excfg *) ap_pcalloc(p, sizeof(excfg));
    excfg *s1conf = (excfg *) server1_conf;
    excfg *s2conf = (excfg *) server2_conf;
    char *note;

    /*
     * Our inheritance rules are our own, and part of our module's semantics.
     * Basically, just note whence we came.
     */
    merged_config->cmode =
        (s1conf->cmode == s2conf->cmode) ? s1conf->cmode : CONFIG_MODE_COMBO;
    merged_config->local = s2conf->local;
    merged_config->congenital = (s1conf->congenital | s1conf->local);
    merged_config->loc = ap_pstrdup(p, s2conf->loc);
    /*
     * Trace our call, including what we were asked to merge.
     */
    note = ap_pstrcat(p, "example_merge_server_config(\"", s1conf->loc, "\",\"",
                   s2conf->loc, "\")", NULL);
    trace_add(NULL, NULL, merged_config, note);
    return (void *) merged_config;
}

/*
 * This routine is called after the request has been read but before any other
 * phases have been processed.  This allows us to make decisions based upon
 * the input header fields.
 *
 * The return value is OK, DECLINED, or HTTP_mumble.  If we return OK, no
 * further modules are called for this phase.
 */
static int example_post_read_request(request_rec *r)
{

    excfg *cfg;

    cfg = our_dconfig(r);
    /*
     * We don't actually *do* anything here, except note the fact that we were
     * called.
     */
    trace_add(r->server, r, cfg, "example_post_read_request()");
    return DECLINED;
}

/*
 * This routine gives our module an opportunity to translate the URI into an
 * actual filename.  If we don't do anything special, the server's default
 * rules (Alias directives and the like) will continue to be followed.
 *
 * The return value is OK, DECLINED, or HTTP_mumble.  If we return OK, no
 * further modules are called for this phase.
 */
static int example_translate_handler(request_rec *r)
{

    excfg *cfg;

    cfg = our_dconfig(r);
    /*
     * We don't actually *do* anything here, except note the fact that we were
     * called.
     */
    trace_add(r->server, r, cfg, "example_translate_handler()");
    return DECLINED;
}

/*
 * This routine is called to check the authentication information sent with
 * the request (such as looking up the user in a database and verifying that
 * the [encrypted] password sent matches the one in the database).
 *
 * The return value is OK, DECLINED, or some HTTP_mumble error (typically
 * HTTP_UNAUTHORIZED).  If we return OK, no other modules are given a chance
 * at the request during this phase.
 */
static int example_check_user_id(request_rec *r)
{

    excfg *cfg;

    cfg = our_dconfig(r);
    /*
     * Don't do anything except log the call.
     */
    trace_add(r->server, r, cfg, "example_check_user_id()");
    return DECLINED;
}

/*
 * This routine is called to check to see if the resource being requested
 * requires authorisation.
 *
 * The return value is OK, DECLINED, or HTTP_mumble.  If we return OK, no
 * other modules are called during this phase.
 *
 * If *all* modules return DECLINED, the request is aborted with a server
 * error.
 */
static int example_auth_checker(request_rec *r)
{

    excfg *cfg;

    cfg = our_dconfig(r);
    /*
     * Log the call and return OK, or access will be denied (even though we
     * didn't actually do anything).
     */
    trace_add(r->server, r, cfg, "example_auth_checker()");
    return DECLINED;
}

/*
 * This routine is called to check for any module-specific restrictions placed
 * upon the requested resource.  (See the mod_access module for an example.)
 *
 * The return value is OK, DECLINED, or HTTP_mumble.  All modules with an
 * handler for this phase are called regardless of whether their predecessors
 * return OK or DECLINED.  The first one to return any other status, however,
 * will abort the sequence (and the request) as usual.
 */
static int example_access_checker(request_rec *r)
{

    excfg *cfg;

    cfg = our_dconfig(r);
    trace_add(r->server, r, cfg, "example_access_checker()");
    return DECLINED;
}

/*
 * This routine is called to determine and/or set the various document type
 * information bits, like Content-type (via r->content_type), language, et
 * cetera.
 *
 * The return value is OK, DECLINED, or HTTP_mumble.  If we return OK, no
 * further modules are given a chance at the request for this phase.
 */
static int example_type_checker(request_rec *r)
{

    excfg *cfg;

    cfg = our_dconfig(r);
    /*
     * Log the call, but don't do anything else - and report truthfully that
     * we didn't do anything.
     */
    trace_add(r->server, r, cfg, "example_type_checker()");
    return DECLINED;
}

/*
 * This routine is called to perform any module-specific fixing of header
 * fields, et cetera.  It is invoked just before any content-handler.
 *
 * The return value is OK, DECLINED, or HTTP_mumble.  If we return OK, the
 * server will still call any remaining modules with an handler for this
 * phase.
 */
static int example_fixer_upper(request_rec *r)
{

    excfg *cfg;

    cfg = our_dconfig(r);
    /*
     * Log the call and exit.
     */
    trace_add(r->server, r, cfg, "example_fixer_upper()");
    return OK;
}

/*
 * This routine is called to perform any module-specific logging activities
 * over and above the normal server things.
 *
 * The return value is OK, DECLINED, or HTTP_mumble.  If we return OK, any
 * remaining modules with an handler for this phase will still be called.
 */
static int example_logger(request_rec *r)
{

    excfg *cfg;

    cfg = our_dconfig(r);
    trace_add(r->server, r, cfg, "example_logger()");
    return DECLINED;
}

/*
 * This routine is called to give the module a chance to look at the request
 * headers and take any appropriate specific actions early in the processing
 * sequence.
 *
 * The return value is OK, DECLINED, or HTTP_mumble.  If we return OK, any
 * remaining modules with handlers for this phase will still be called.
 */
static int example_header_parser(request_rec *r)
{

    excfg *cfg;

    cfg = our_dconfig(r);
    trace_add(r->server, r, cfg, "example_header_parser()");
    return DECLINED;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/* All of the routines have been declared now.  Here's the list of          */
/* directives specific to our module, and information about where they      */
/* may appear and how the command parser should pass them to us for         */
/* processing.  Note that care must be taken to ensure that there are NO    */
/* collisions of directive names between modules.                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/* 
 * List of directives specific to our module.
 */
static const command_rec example_cmds[] =
{
    {
        "Example",              /* directive name */
        cmd_example,            /* config action routine */
        NULL,                   /* argument to include in call */
        OR_OPTIONS,             /* where available */
        NO_ARGS,                /* arguments */
        "Example directive - no arguments"
                                /* directive description */
    },
    {NULL}
};

/*--------------------------------------------------------------------------*/
/*                                                                          */
/* Now the list of content handlers available from this module.             */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/* 
 * List of content handlers our module supplies.  Each handler is defined by
 * two parts: a name by which it can be referenced (such as by
 * {Add,Set}Handler), and the actual routine name.  The list is terminated by
 * a NULL block, since it can be of variable length.
 *
 * Note that content-handlers are invoked on a most-specific to least-specific
 * basis; that is, a handler that is declared for "text/plain" will be
 * invoked before one that was declared for "text / *".  Note also that
 * if a content-handler returns anything except DECLINED, no other
 * content-handlers will be called.
 */
static const handler_rec example_handlers[] =
{
    {"example-handler", example_handler},
    {NULL}
};

/*--------------------------------------------------------------------------*/
/*                                                                          */
/* Finally, the list of callback routines and data structures that          */
/* provide the hooks into our module from the other parts of the server.    */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/* 
 * Module definition for configuration.  If a particular callback is not
 * needed, replace its routine name below with the word NULL.
 *
 * The number in brackets indicates the order in which the routine is called
 * during request processing.  Note that not all routines are necessarily
 * called (such as if a resource doesn't have access restrictions).
 */
module MODULE_VAR_EXPORT example_module =
{
    STANDARD_MODULE_STUFF,
    example_init,               /* module initializer */
    example_create_dir_config,  /* per-directory config creator */
    example_merge_dir_config,   /* dir config merger */
    example_create_server_config,       /* server config creator */
    example_merge_server_config,        /* server config merger */
    example_cmds,               /* command table */
    example_handlers,           /* [9] list of handlers */
    example_translate_handler,  /* [2] filename-to-URI translation */
    example_check_user_id,      /* [5] check/validate user_id */
    example_auth_checker,       /* [6] check user_id is valid *here* */
    example_access_checker,     /* [4] check access by host address */
    example_type_checker,       /* [7] MIME type checker/setter */
    example_fixer_upper,        /* [8] fixups */
    example_logger,             /* [10] logger */
#if MODULE_MAGIC_NUMBER >= 19970103
    example_header_parser,      /* [3] header parser */
#endif
#if MODULE_MAGIC_NUMBER >= 19970719
    example_child_init,         /* process initializer */
#endif
#if MODULE_MAGIC_NUMBER >= 19970728
    example_child_exit,         /* process exit/cleanup */
#endif
#if MODULE_MAGIC_NUMBER >= 19970902
    example_post_read_request   /* [1] post read_request handling */
#endif
};
@


1.10
log
@avoid printing the server built date
@
text
@@


1.9
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@a544 2
    ap_rputs("  <BR>\n", r);
    ap_rprintf(r, "  Server built: \"%s\"\n", ap_get_server_built());
@


1.8
log
@merge
@
text
@a518 4
#ifdef CHARSET_EBCDIC
    /* Server-generated response, converted */
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
#endif
@


1.7
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
@


1.6
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d551 1
a551 1
    ap_rputs("  </P>\n", r);;
@


1.5
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d516 1
d519 5
@


1.4
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1995-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 20
a38 23
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 7
a56 6
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
d136 1
a136 1
module example_module;
d1123 1
a1123 1
module example_module =
@


1.3
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d427 2
a428 1
    if (EXAMPLE_LOG_EACH && (s != NULL)) {
d431 1
d712 1
a712 1
 * This function gets called to create up a per-directory configuration
d1131 1
a1131 1
    example_handlers,           /* [7] list of handlers */
@


1.2
log
@Apache 1.3.4 merge
@
text
@d528 1
a528 1
    ap_rputs("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n", r);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1995-1997 The Apache Group.  All rights reserved.
d23 2
a24 1
 *    prior written permission.
d26 5
a30 1
 * 5. Redistributions of any form whatsoever must retain the following
d74 6
a79 6
/*									    */
/* Data declarations.							    */
/*									    */
/* Here are the static cells and structure declarations private to our	    */
/* module.								    */
/*									    */
d98 4
a101 3
typedef struct example_config {
    int	    cmode;	/* Environment to which record applies (directory,  */
			/* server, or combination).			    */
d104 6
a109 6
#define CONFIG_MODE_COMBO 3  /* Shouldn't ever happen.			    */
    int	    local;	/* Boolean: was "Example" directive declared here?  */
    int	    congenital;	/* Boolean: did we inherit an "Example"?	    */
    char    *trace;	/* Pointer to trace string.			    */
    char    *loc;	/* Location to which this record applies.	    */
} example_config;
d119 1
a119 1
static char *trace = NULL;
d138 1
a138 1
/*									    */
d140 2
a141 2
/* passed to command handlers for the different types of directive	    */
/* syntax.  If an argument was specified in the directive definition	    */
d143 3
a145 3
/* via the (void *) info field in the cmd_parms argument passed to the	    */
/* handler (cmd->info for the examples below).				    */
/*									    */
d151 1
a151 2
 * static const char *handle_NO_ARGS
 *	(cmd_parms *cmd, void *mconfig);
d153 1
a153 1
 
d158 9
a166 2
 * static const char *handle_RAW_ARGS
 *	(cmd_parms *cmd, void *mconfig, const char *args);
d173 2
a174 2
 * static const char *handle_TAKE1
 *	(cmd_parms *cmd, void *mconfig, char *word1);
d181 2
a182 2
 * static const char *handle_TAKE2
 *	(cmd_parms *cmd, void *mconfig, char *word1, char *word2);
d189 2
a190 2
 * static const char *handle_TAKE3
 *	(cmd_parms *cmd, void *mconfig, char *word1, char *word2, char *word3);
d198 2
a199 2
 * static const char *handle_TAKE12
 *	(cmd_parms *cmd, void *mconfig, char *word1, char *word2);
d208 2
a209 2
 * static const char *handle_TAKE123
 *	(cmd_parms *cmd, void *mconfig, char *word1, char *word2, char *word3);
d217 2
a218 2
 * static const char *handle_TAKE13
 *	(cmd_parms *cmd, void *mconfig, char *word1, char *word2, char *word3);
d226 2
a227 2
 * static const char *handle_TAKE23
 *	(cmd_parms *cmd, void *mconfig, char *word1, char *word2, char *word3);
d235 2
a236 2
 * static const char *handle_ITERATE
 *	(cmd_parms *cmd, void *mconfig, char *word1);
d247 2
a248 2
 * static const char *handle_ITERATE2
 *	(cmd_parms *cmd, void *mconfig, char *word1, char *word2);
d252 5
a256 5
/*									    */
/* These routines are strictly internal to this module, and support its	    */
/* operation.  They are not referenced by any external portion of the	    */
/* server.								    */
/*									    */
d262 2
a263 2
static example_config *our_dconfig
	(request_rec *r) {
d265 1
a265 5
    return (example_config *) get_module_config
				(
				    r->per_dir_config,
				    &example_module
				);
d268 1
d272 2
a273 2
static example_config *our_sconfig
	(server_rec *s) {
d275 1
a275 5
    return (example_config *) get_module_config
				(
				    s->module_config,
				    &example_module
				);
d281 2
a282 2
static example_config *our_rconfig
	(request_rec *r) {
d284 1
a284 5
    return (example_config *) get_module_config
				(
				    r->request_config,
				    &example_module
				);
d286 1
d291 2
a292 1
static void setup_module_cells () {
d297 1
a297 1
	example_pool = make_sub_pool (NULL);
d304 1
a304 1
	static_calls_made = make_table (example_pool, 16);
d328 9
a336 11
static void trace_add
	(server_rec *s, request_rec *r, example_config *mconfig,
	 const char *note) {

    char    *sofar;
    char    *addon;
    char    *where;
    pool    *p;
    char    *trace_copy;
    example_config
	    *rconfig;
d341 1
a341 1
    setup_module_cells ();
d346 29
a374 28
	p = r->pool;
	if ((trace_copy = table_get (r->notes, TRACE_NOTE)) == NULL) {
	    trace_copy = "";
	}
    } else {
	/*
	 * We're not in request context, so the trace gets attached to our
	 * module-wide pool.  We do the create/destroy every time we're called
	 * in non-request context; this avoids leaking memory in some of
	 * the subsequent calls that allocate memory only once (such as the
	 * key formation below).
	 *
	 * Make a new sub-pool and copy any existing trace to it.  Point the
	 * trace cell at the copied value.
	 */
	p = make_sub_pool (example_pool);
	if (trace != NULL) {
	    trace = pstrdup (p, trace);
	}
	/*
	 * Now, if we have a sub-pool from before, nuke it and replace with
	 * the one we just allocated.
	 */
	if (example_subpool != NULL) {
	    destroy_pool (example_subpool);
	}
	example_subpool = p;
	trace_copy = trace;
d391 1
a391 1
	char	*key;
d393 14
a406 13
	key = pstrcat (p, note, ":", where, NULL);
	if (table_get (static_calls_made, key) != NULL) {
	    /*
	     * Been here, done this.
	     */
	    return;
	} else {
	    /*
	     * First time for this combination of routine and environment -
	     * log it so we don't do it again.
	     */
	    table_set (static_calls_made, key, "been here");
	}
d408 4
a411 17
    addon = pstrcat 
		(
		    p,
		    "   <LI>\n",
		    "    <DL>\n",
		    "     <DT><SAMP>",
		    note,
		    "</SAMP>\n",
		    "     </DT>\n",
		    "     <DD><SAMP>[",
		    where,
		    "]</SAMP>\n",
		    "     </DD>\n",
		    "    </DL>\n",
		    "   </LI>\n",
		    NULL
		);
d413 1
a413 1
    trace_copy = pstrcat (p, sofar, addon, NULL);
d415 4
a418 3
	table_set (r->notes, TRACE_NOTE, trace_copy);
    } else {
	trace = trace_copy;
d421 1
a421 1
     * You *could* uncomment the following if you wanted to see the calling
d426 3
a428 3
/*
    if (s != NULL) {
        log_printf (s, "mod_example: %s", note);
a429 1
 */
d436 3
a438 3
/* will be invoked by the parser when our "real" directive is		    */
/* encountered.								    */
/*									    */
d440 5
a444 5
/* signals this fact by returning a non-NULL pointer to a string	    */
/* describing the problem.						    */
/*									    */
/* The magic return value DECLINE_CMD is used to deal with directives	    */
/* that might be declared by multiple modules.  If the command handler	    */
d448 1
a448 1
/* error message.							    */
d455 2
a456 2
static const char *cmd_example
	(cmd_parms *cmd, void *mconfig) {
d458 1
a458 2
    example_config
	    *cfg = (example_config *) mconfig;
d464 1
a464 1
    trace_add (cmd->server, NULL, cfg, "cmd_example()");
d469 1
a469 1
/*									    */
d472 7
a478 7
/* see.  (See mod_mime's SetHandler and AddHandler directives, and the	    */
/* mod_info and mod_status examples, for more details.)			    */
/*									    */
/* Since content handlers are dumping data directly into the connexion	    */
/* (using the r*() routines, such as rputs() and rprintf()) without	    */
/* intervention by other parts of the server, they need to make		    */
/* sure any accumulated HTTP headers are sent first.  This is done by	    */
d480 1
a480 1
/* and the output sent to the client will actually be HTTP-uncompliant.	    */
d492 2
a493 2
static int example_handler
	(request_rec *r) {
d495 1
a495 4
    example_config
	    *dcfg;
    example_config
	    *rcfg;
d497 2
a498 2
    dcfg = our_dconfig (r);
    trace_add (r->server, r, dcfg, "example_handler()");
d506 2
a507 1
     * "text/plain").
d513 2
a514 2
    soft_timeout ("send example call trace", r);
    send_http_header (r);
d520 2
a521 2
	kill_timeout (r);
	return OK;
d528 50
a577 60
    rputs ("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n", r);
    rputs ("<HTML>\n", r);
    rputs (" <HEAD>\n", r);
    rputs ("  <TITLE>mod_example Module Content-Handler Output\n", r);
    rputs ("  </TITLE>\n", r);
    rputs (" </HEAD>\n", r);
    rputs (" <BODY>\n", r);
    rputs ("  <H1><SAMP>mod_example</SAMP> Module Content-Handler Output\n", r);
    rputs ("  </H1>\n", r);
    rputs ("  <P>\n", r);
    rputs ("  The format for the callback trace is:\n", r);
    rputs ("  </P>\n", r);
    rputs ("  <DL>\n", r);
    rputs ("   <DT><EM>n</EM>.<SAMP>&lt;routine-name&gt;", r);
    rputs ("(&lt;routine-data&gt;)</SAMP>\n", r);
    rputs ("   </DT>\n", r);
    rputs ("   <DD><SAMP>[&lt;applies-to&gt;]</SAMP>\n", r);
    rputs ("   </DD>\n", r);
    rputs ("  </DL>\n", r);
    rputs ("  <P>\n", r);
    rputs ("  The <SAMP>&lt;routine-data&gt;</SAMP> is supplied by\n", r);
    rputs ("  the routine when it requests the trace,\n", r);
    rputs ("  and the <SAMP>&lt;applies-to&gt;</SAMP> is extracted\n", r);
    rputs ("  from the configuration record at the time of the trace.\n", r); 
    rputs ("  <STRONG>SVR()</STRONG> indicates a server environment\n", r);
    rputs ("  (blank means the main or default server, otherwise it's\n", r);
    rputs ("  the name of the VirtualHost); <STRONG>DIR()</STRONG>\n", r);
    rputs ("  indicates a location in the URL or filesystem\n", r);
    rputs ("  namespace.\n", r);
    rputs ("  </P>\n", r);
    rprintf
	(
	    r,
	    "  <H2>Static callbacks so far:</H2>\n  <OL>\n%s  </OL>\n",
	    trace
	);
    rprintf
	(
	    r,
	    "  <H2>Request-specific callbacks so far:</H2>\n  <OL>\n%s  </OL>\n",
	    table_get (r->notes, TRACE_NOTE)
	);
    rputs ("  <H2>Environment for <EM>this</EM> call:</H2>\n", r);
    rputs ("  <UL>\n", r);
    rprintf (r, "   <LI>Applies-to: <SAMP>%s</SAMP>\n   </LI>\n", dcfg->loc);
    rprintf
	(
	    r,
	    "   <LI>\"Example\" directive declared here: %s\n   </LI>\n",
	    (dcfg->local ? "YES" : "NO")
	);
    rprintf
	(
	    r,
	    "   <LI>\"Example\" inherited: %s\n   </LI>\n",
	    (dcfg->congenital ? "YES" : "NO")
	);
    rputs ("  </UL>\n", r);
    rputs (" </BODY>\n", r);
    rputs ("</HTML>\n", r);
d584 1
a584 1
    kill_timeout (r);
d593 5
a597 5
/*									    */
/* Now let's declare routines for each of the callback phase in order.	    */
/* (That's the order in which they're listed in the callback list, *not	    */
/* the order in which the server calls them!  See the command_rec	    */
/* declaration near the bottom of this file.)  Note that these may be	    */
d599 3
a601 3
/* other words, the fixup handler shouldn't assume that the request has	    */
/* to do with "example" stuff.	    					    */
/*									    */
d604 10
a613 10
/* aborted the sequence.						    */
/*									    */
/* Handlers that are declared as "int" can return the following:	    */
/*									    */
/*  OK		Handler accepted the request and did its thing with it.	    */
/*  DECLINED	Handler took no action.					    */
/*  HTTP_mumble	Handler looked at request and found it wanting.		    */
/*									    */
/* What the server does after calling a module handler depends upon the	    */
/* handler's return value.  In all cases, if the handler returns	    */
d615 5
a619 5
/* for the current phase.  However, if the handler return a non-OK,	    */
/* non-DECLINED status, the server aborts the request right there.  If	    */
/* the handler returns OK, the server's next action is phase-specific;	    */
/* see the individual handler comments below for details.		    */
/*									    */
d632 2
a633 2
static void example_init
	(server_rec *s, pool *p) {
d635 2
a636 2
    char    *note;
    char    *sname = s->server_hostname;
d641 1
a641 1
    setup_module_cells ();
d647 60
a706 2
    note = pstrcat (p, "example_init(", sname, ")", NULL);
    trace_add (s, NULL, NULL, note);
d721 2
a722 2
static void *example_dir_create
	(pool *p, char *dirspec) {
d724 2
a725 3
    example_config
	    *cfg;
    char    *dname = dirspec;
d730 1
a730 1
    cfg = (example_config *) pcalloc (p, sizeof(example_config));
d742 2
a743 2
    cfg->loc = pstrcat (p, "DIR(", dname, ")", NULL);
    trace_add (NULL, NULL, cfg, "example_dir_create()");
d762 8
a769 11
static void *example_dir_merge
	(pool *p, void *parent_conf, void *newloc_conf) {

    example_config
	    *merged_config =
		(example_config *) pcalloc (p, sizeof(example_config));
    example_config
	    *pconf = (example_config *) parent_conf;
    example_config
	    *nconf = (example_config *) newloc_conf;
    char    *note;
d776 1
a776 1
    merged_config->loc = pstrdup (p, nconf->loc);
d789 1
a789 1
	(pconf->cmode == nconf->cmode) ? pconf->cmode : CONFIG_MODE_COMBO;
d794 3
a796 11
    note = pstrcat
	    (
		p,
		"example_dir_merge(\"",
		pconf->loc,
		"\",\"",
		nconf->loc,
		"\")",
		NULL
	    );
    trace_add (NULL, NULL, merged_config, note);
d807 2
a808 2
static void *example_server_create
	(pool *p, server_rec *s) {
d810 2
a811 3
    example_config
	    *cfg;
    char    *sname = s->server_hostname;
d814 2
a815 2
     * As with the example_dir_create() reoutine, we allocate and fill in an
     * empty record.
d817 1
a817 1
    cfg = (example_config *) pcalloc (p, sizeof(example_config));
d825 2
a826 2
    cfg->loc = pstrcat (p, "SVR(", sname, ")", NULL);
    trace_add (s, NULL, cfg, "example_server_create()");
d843 8
a850 11
static void *example_server_merge
	(pool *p, void *server1_conf, void *server2_conf) {

    example_config
	    *merged_config =
		(example_config *) pcalloc (p, sizeof(example_config));
    example_config
	    *s1conf = (example_config *) server1_conf;
    example_config
	    *s2conf = (example_config *) server2_conf;
    char    *note;
d857 1
a857 1
	(s1conf->cmode == s2conf->cmode) ? s1conf->cmode : CONFIG_MODE_COMBO;
d860 1
a860 1
    merged_config->loc = pstrdup (p, s2conf->loc);
d864 3
a866 11
    note = pstrcat
	    (
		p,
		"example_server_merge(\"",
		s1conf->loc,
		"\",\"",
		s2conf->loc,
		"\")",
		NULL
	    );
    trace_add (NULL, NULL, merged_config, note);
d871 22
d900 2
a901 2
static int example_xlate
	(request_rec *r) {
d903 1
a903 2
    example_config
	    *cfg;
d905 1
a905 1
    cfg = our_dconfig (r);
d910 1
a910 1
    trace_add (r->server, r, cfg, "example_xlate()");
d923 2
a924 2
static int example_ckuser
	(request_rec *r) {
d926 1
a926 2
    example_config
	    *cfg;
d928 1
a928 1
    cfg = our_dconfig (r);
d932 1
a932 1
    trace_add (r->server, r, cfg, "example_ckuser()");
d946 2
a947 2
static int example_ckauth
	(request_rec *r) {
d949 1
a949 2
    example_config
	    *cfg;
d951 1
a951 1
    cfg = our_dconfig (r);
d956 2
a957 2
    trace_add (r->server, r, cfg, "example_ckauth()");
    return OK;
d969 2
a970 2
static int example_ckaccess
	(request_rec *r) {
d972 1
a972 2
    example_config
	    *cfg;
d974 3
a976 3
    cfg = our_dconfig (r);
    trace_add (r->server, r, cfg, "example_ckaccess()");
    return OK;
d987 2
a988 2
static int example_typer
	(request_rec *r) {
d990 1
a990 2
    example_config
	    *cfg;
d992 1
a992 1
    cfg = our_dconfig (r);
d997 1
a997 1
    trace_add (r->server, r, cfg, "example_typer()");
d1009 2
a1010 2
static int example_fixer
	(request_rec *r) {
d1012 1
a1012 2
    example_config
	    *cfg;
d1014 1
a1014 1
    cfg = our_dconfig (r);
d1018 1
a1018 1
    trace_add (r->server, r, cfg, "example_fixer()");
d1029 2
a1030 2
static int example_logger
	(request_rec *r) {
d1032 1
a1032 2
    example_config
	    *cfg;
d1034 2
a1035 2
    cfg = our_dconfig (r);
    trace_add (r->server, r, cfg, "example_logger()");
d1047 2
a1048 2
static int example_hparser
	(request_rec *r) {
d1050 1
a1050 2
    example_config
	    *cfg;
d1052 2
a1053 2
    cfg = our_dconfig (r);
    trace_add (r->server, r, cfg, "example_hparser()");
d1058 4
a1061 4
/*									    */
/* All of the routines have been declared now.  Here's the list of	    */
/* directives specific to our module, and information about where they	    */
/* may appear and how the command parser should pass them to us for	    */
d1063 2
a1064 2
/* collisions of directive names between modules.			    */
/*									    */
d1069 2
a1070 1
command_rec example_commands[] = {
d1072 7
a1078 7
	"Example",			/* directive name */
	cmd_example,			/* action routine for directive */
	NULL,				/* argument to include in call */
	OR_OPTIONS,			/* where available */
	NO_ARGS,			/* arguments */
	"Example directive - no arguments"
					/* directive description */
d1080 1
a1080 1
    { NULL }
d1084 3
a1086 3
/*									    */
/* Now the list of content handlers available from this module.		    */
/*									    */
d1100 4
a1103 3
handler_rec example_handlers[] = {
    { "example-handler", example_handler },
    { NULL }
d1107 2
a1108 2
/*									    */
/* Finally, the list of callback routines and data structures that	    */
d1110 1
a1110 1
/*									    */
d1120 2
a1121 1
module example_module = {
d1123 26
a1148 15
    example_init,		/* initializer */
    example_dir_create,		/* per-directory config creater */
    example_dir_merge,		/* dir config merger - default is to override */
    example_server_create,	/* server config creator */
    example_server_merge,	/* server config merger */
    example_commands,		/* command table */
    example_handlers,		/* [6] list of handlers */
    example_xlate,		/* [1] filename-to-URI translation */
    example_ckuser,		/* [4] check/validate HTTP user_id */
    example_ckauth,		/* [5] check HTTP user_id is valid *here* */
    example_ckaccess,		/* [3] check access by host address, etc. */
    example_typer,		/* [6] MIME type checker/setter */
    example_fixer,		/* [7] fixups */
    example_logger,		/* [9] logger */
    example_hparser		/* [2] header parser */
@


1.1.1.1
log
@Initial import from apache 1.2.6
@
text
@@


1.1.1.2
log
@Apache 1.3.2
@
text
@d2 1
a2 1
 * Copyright (c) 1995-1998 The Apache Group.  All rights reserved.
d23 1
a23 2
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
d25 1
a25 5
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
d69 6
a74 6
/*                                                                          */
/* Data declarations.                                                       */
/*                                                                          */
/* Here are the static cells and structure declarations private to our      */
/* module.                                                                  */
/*                                                                          */
d93 3
a95 4
typedef struct excfg {
    int cmode;                  /* Environment to which record applies (directory,
                                 * server, or combination).
                                 */
d98 6
a103 6
#define CONFIG_MODE_COMBO 3     /* Shouldn't ever happen. */
    int local;                  /* Boolean: "Example" directive declared here? */
    int congenital;             /* Boolean: did we inherit an "Example"? */
    char *trace;                /* Pointer to trace string. */
    char *loc;                  /* Location to which this record applies. */
} excfg;
d113 1
a113 1
static const char *trace = NULL;
d132 1
a132 1
/*                                                                          */
d134 2
a135 2
/* passed to command handlers for the different types of directive          */
/* syntax.  If an argument was specified in the directive definition        */
d137 3
a139 3
/* via the (void *) info field in the cmd_parms argument passed to the      */
/* handler (cmd->info for the examples below).                              */
/*                                                                          */
d145 2
a146 1
 * static const char *handle_NO_ARGS(cmd_parms *cmd, void *mconfig);
d148 1
a148 1

d153 2
a154 9
 * static const char *handle_RAW_ARGS(cmd_parms *cmd, void *mconfig,
 *                                    const char *args);
 */

/*
 * Command handler for a FLAG directive.  The single parameter is passed in
 * "bool", which is either zero or not for Off or On respectively.
 *
 * static const char *handle_FLAG(cmd_parms *cmd, void *mconfig, int bool);
d161 2
a162 2
 * static const char *handle_TAKE1(cmd_parms *cmd, void *mconfig,
 *                                 char *word1);
d169 2
a170 2
 * static const char *handle_TAKE2(cmd_parms *cmd, void *mconfig,
 *                                 char *word1, char *word2);
d177 2
a178 2
 * static const char *handle_TAKE3(cmd_parms *cmd, void *mconfig,
 *                                 char *word1, char *word2, char *word3);
d186 2
a187 2
 * static const char *handle_TAKE12(cmd_parms *cmd, void *mconfig,
 *                                  char *word1, char *word2);
d196 2
a197 2
 * static const char *handle_TAKE123(cmd_parms *cmd, void *mconfig,
 *                                   char *word1, char *word2, char *word3);
d205 2
a206 2
 * static const char *handle_TAKE13(cmd_parms *cmd, void *mconfig,
 *                                  char *word1, char *word2, char *word3);
d214 2
a215 2
 * static const char *handle_TAKE23(cmd_parms *cmd, void *mconfig,
 *                                  char *word1, char *word2, char *word3);
d223 2
a224 2
 * static const char *handle_ITERATE(cmd_parms *cmd, void *mconfig,
 *                                   char *word1);
d235 2
a236 2
 * static const char *handle_ITERATE2(cmd_parms *cmd, void *mconfig,
 *                                    char *word1, char *word2);
d240 5
a244 5
/*                                                                          */
/* These routines are strictly internal to this module, and support its     */
/* operation.  They are not referenced by any external portion of the       */
/* server.                                                                  */
/*                                                                          */
d250 2
a251 2
static excfg *our_dconfig(request_rec *r)
{
d253 5
a257 1
    return (excfg *) ap_get_module_config(r->per_dir_config, &example_module);
a259 1
#if 0
d263 2
a264 2
static excfg *our_sconfig(server_rec *s)
{
d266 5
a270 1
    return (excfg *) ap_get_module_config(s->module_config, &example_module);
d276 2
a277 2
static excfg *our_rconfig(request_rec *r)
{
d279 5
a283 1
    return (excfg *) ap_get_module_config(r->request_config, &example_module);
a284 1
#endif
d289 1
a289 2
static void setup_module_cells()
{
d294 1
a294 1
        example_pool = ap_make_sub_pool(NULL);
d301 1
a301 1
        static_calls_made = ap_make_table(example_pool, 16);
d325 11
a335 9
static void trace_add(server_rec *s, request_rec *r, excfg *mconfig,
                      const char *note)
{

    const char *sofar;
    char *addon;
    char *where;
    pool *p;
    const char *trace_copy;
d340 1
a340 1
    setup_module_cells();
d345 28
a372 29
        p = r->pool;
        if ((trace_copy = ap_table_get(r->notes, TRACE_NOTE)) == NULL) {
            trace_copy = "";
        }
    }
    else {
        /*
         * We're not in request context, so the trace gets attached to our
         * module-wide pool.  We do the create/destroy every time we're called
         * in non-request context; this avoids leaking memory in some of
         * the subsequent calls that allocate memory only once (such as the
         * key formation below).
         *
         * Make a new sub-pool and copy any existing trace to it.  Point the
         * trace cell at the copied value.
         */
        p = ap_make_sub_pool(example_pool);
        if (trace != NULL) {
            trace = ap_pstrdup(p, trace);
        }
        /*
         * Now, if we have a sub-pool from before, nuke it and replace with
         * the one we just allocated.
         */
        if (example_subpool != NULL) {
            ap_destroy_pool(example_subpool);
        }
        example_subpool = p;
        trace_copy = trace;
d389 1
a389 1
        char *key;
d391 13
a403 14
        key = ap_pstrcat(p, note, ":", where, NULL);
        if (ap_table_get(static_calls_made, key) != NULL) {
            /*
             * Been here, done this.
             */
            return;
        }
        else {
            /*
             * First time for this combination of routine and environment -
             * log it so we don't do it again.
             */
            ap_table_set(static_calls_made, key, "been here");
        }
d405 17
a421 4
    addon = ap_pstrcat(p, "   <LI>\n", "    <DL>\n", "     <DT><SAMP>",
                    note, "</SAMP>\n", "     </DT>\n", "     <DD><SAMP>[",
                    where, "]</SAMP>\n", "     </DD>\n", "    </DL>\n",
                    "   </LI>\n", NULL);
d423 1
a423 1
    trace_copy = ap_pstrcat(p, sofar, addon, NULL);
d425 3
a427 4
        ap_table_set(r->notes, TRACE_NOTE, trace_copy);
    }
    else {
        trace = trace_copy;
d430 1
a430 1
     * You *could* change the following if you wanted to see the calling
d435 3
a437 3
#define EXAMPLE_LOG_EACH 0
    if (EXAMPLE_LOG_EACH && (s != NULL)) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG, s, "mod_example: %s", note);
d439 1
d446 3
a448 3
/* will be invoked by the parser when our "real" directive is               */
/* encountered.                                                             */
/*                                                                          */
d450 5
a454 5
/* signals this fact by returning a non-NULL pointer to a string            */
/* describing the problem.                                                  */
/*                                                                          */
/* The magic return value DECLINE_CMD is used to deal with directives       */
/* that might be declared by multiple modules.  If the command handler      */
d458 1
a458 1
/* error message.                                                           */
d465 2
a466 2
static const char *cmd_example(cmd_parms *cmd, void *mconfig)
{
d468 2
a469 1
    excfg *cfg = (excfg *) mconfig;
d475 1
a475 1
    trace_add(cmd->server, NULL, cfg, "cmd_example()");
d480 1
a480 1
/*                                                                          */
d483 7
a489 7
/* see.  (See mod_mime's SetHandler and AddHandler directives, and the      */
/* mod_info and mod_status examples, for more details.)                     */
/*                                                                          */
/* Since content handlers are dumping data directly into the connexion      */
/* (using the r*() routines, such as rputs() and rprintf()) without         */
/* intervention by other parts of the server, they need to make             */
/* sure any accumulated HTTP headers are sent first.  This is done by       */
d491 1
a491 1
/* and the output sent to the client will actually be HTTP-uncompliant.     */
d503 2
a504 2
static int example_handler(request_rec *r)
{
d506 4
a509 1
    excfg *dcfg;
d511 2
a512 2
    dcfg = our_dconfig(r);
    trace_add(r->server, r, dcfg, "example_handler()");
d520 1
a520 2
     * "text/plain").  You *must* also ensure that r->content_type is lower
     * case.
d526 2
a527 2
    ap_soft_timeout("send example call trace", r);
    ap_send_http_header(r);
d533 2
a534 2
        ap_kill_timeout(r);
        return OK;
d541 60
a600 50
    ap_rputs("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2//EN\">\n", r);
    ap_rputs("<HTML>\n", r);
    ap_rputs(" <HEAD>\n", r);
    ap_rputs("  <TITLE>mod_example Module Content-Handler Output\n", r);
    ap_rputs("  </TITLE>\n", r);
    ap_rputs(" </HEAD>\n", r);
    ap_rputs(" <BODY>\n", r);
    ap_rputs("  <H1><SAMP>mod_example</SAMP> Module Content-Handler Output\n", r);
    ap_rputs("  </H1>\n", r);
    ap_rputs("  <P>\n", r);
    ap_rprintf(r, "  Apache HTTP Server version: \"%s\"\n",
	    ap_get_server_version());
    ap_rputs("  <BR>\n", r);
    ap_rprintf(r, "  Server built: \"%s\"\n", ap_get_server_built());
    ap_rputs("  </P>\n", r);;
    ap_rputs("  <P>\n", r);
    ap_rputs("  The format for the callback trace is:\n", r);
    ap_rputs("  </P>\n", r);
    ap_rputs("  <DL>\n", r);
    ap_rputs("   <DT><EM>n</EM>.<SAMP>&lt;routine-name&gt;", r);
    ap_rputs("(&lt;routine-data&gt;)</SAMP>\n", r);
    ap_rputs("   </DT>\n", r);
    ap_rputs("   <DD><SAMP>[&lt;applies-to&gt;]</SAMP>\n", r);
    ap_rputs("   </DD>\n", r);
    ap_rputs("  </DL>\n", r);
    ap_rputs("  <P>\n", r);
    ap_rputs("  The <SAMP>&lt;routine-data&gt;</SAMP> is supplied by\n", r);
    ap_rputs("  the routine when it requests the trace,\n", r);
    ap_rputs("  and the <SAMP>&lt;applies-to&gt;</SAMP> is extracted\n", r);
    ap_rputs("  from the configuration record at the time of the trace.\n", r);
    ap_rputs("  <STRONG>SVR()</STRONG> indicates a server environment\n", r);
    ap_rputs("  (blank means the main or default server, otherwise it's\n", r);
    ap_rputs("  the name of the VirtualHost); <STRONG>DIR()</STRONG>\n", r);
    ap_rputs("  indicates a location in the URL or filesystem\n", r);
    ap_rputs("  namespace.\n", r);
    ap_rputs("  </P>\n", r);
    ap_rprintf(r, "  <H2>Static callbacks so far:</H2>\n  <OL>\n%s  </OL>\n",
            trace);
    ap_rputs("  <H2>Request-specific callbacks so far:</H2>\n", r);
    ap_rprintf(r, "  <OL>\n%s  </OL>\n", ap_table_get(r->notes, TRACE_NOTE));
    ap_rputs("  <H2>Environment for <EM>this</EM> call:</H2>\n", r);
    ap_rputs("  <UL>\n", r);
    ap_rprintf(r, "   <LI>Applies-to: <SAMP>%s</SAMP>\n   </LI>\n", dcfg->loc);
    ap_rprintf(r, "   <LI>\"Example\" directive declared here: %s\n   </LI>\n",
            (dcfg->local ? "YES" : "NO"));
    ap_rprintf(r, "   <LI>\"Example\" inherited: %s\n   </LI>\n",
            (dcfg->congenital ? "YES" : "NO"));
    ap_rputs("  </UL>\n", r);
    ap_rputs(" </BODY>\n", r);
    ap_rputs("</HTML>\n", r);
d607 1
a607 1
    ap_kill_timeout(r);
d616 5
a620 5
/*                                                                          */
/* Now let's declare routines for each of the callback phase in order.      */
/* (That's the order in which they're listed in the callback list, *not     */
/* the order in which the server calls them!  See the command_rec           */
/* declaration near the bottom of this file.)  Note that these may be       */
d622 3
a624 3
/* other words, the fixup handler shouldn't assume that the request has     */
/* to do with "example" stuff.                                              */
/*                                                                          */
d627 10
a636 10
/* aborted the sequence.                                                    */
/*                                                                          */
/* Handlers that are declared as "int" can return the following:            */
/*                                                                          */
/*  OK          Handler accepted the request and did its thing with it.     */
/*  DECLINED    Handler took no action.                                     */
/*  HTTP_mumble Handler looked at request and found it wanting.             */
/*                                                                          */
/* What the server does after calling a module handler depends upon the     */
/* handler's return value.  In all cases, if the handler returns            */
d638 5
a642 5
/* for the current phase.  However, if the handler return a non-OK,         */
/* non-DECLINED status, the server aborts the request right there.  If      */
/* the handler returns OK, the server's next action is phase-specific;      */
/* see the individual handler comments below for details.                   */
/*                                                                          */
d655 2
a656 2
static void example_init(server_rec *s, pool *p)
{
d658 2
a659 2
    char *note;
    char *sname = s->server_hostname;
d664 1
a664 1
    setup_module_cells();
d670 2
a671 60
    note = ap_pstrcat(p, "example_init(", sname, ")", NULL);
    trace_add(s, NULL, NULL, note);
}

/* 
 * This function is called during server initialisation when an heavy-weight
 * process (such as a child) is being initialised.  As with the
 * module-initialisation function, any information that needs to be recorded
 * must be in static cells, since there's no configuration record.
 *
 * There is no return value.
 */

/*
 * All our process-initialiser does is add its trace to the log.
 */
static void example_child_init(server_rec *s, pool *p)
{

    char *note;
    char *sname = s->server_hostname;

    /*
     * Set up any module cells that ought to be initialised.
     */
    setup_module_cells();
    /*
     * The arbitrary text we add to our trace entry indicates for which server
     * we're being called.
     */
    sname = (sname != NULL) ? sname : "";
    note = ap_pstrcat(p, "example_child_init(", sname, ")", NULL);
    trace_add(s, NULL, NULL, note);
}

/* 
 * This function is called when an heavy-weight process (such as a child) is
 * being run down or destroyed.  As with the child-initialisation function,
 * any information that needs to be recorded must be in static cells, since
 * there's no configuration record.
 *
 * There is no return value.
 */

/*
 * All our process-death routine does is add its trace to the log.
 */
static void example_child_exit(server_rec *s, pool *p)
{

    char *note;
    char *sname = s->server_hostname;

    /*
     * The arbitrary text we add to our trace entry indicates for which server
     * we're being called.
     */
    sname = (sname != NULL) ? sname : "";
    note = ap_pstrcat(p, "example_child_exit(", sname, ")", NULL);
    trace_add(s, NULL, NULL, note);
d686 2
a687 2
static void *example_create_dir_config(pool *p, char *dirspec)
{
d689 3
a691 2
    excfg *cfg;
    char *dname = dirspec;
d696 1
a696 1
    cfg = (excfg *) ap_pcalloc(p, sizeof(excfg));
d708 2
a709 2
    cfg->loc = ap_pstrcat(p, "DIR(", dname, ")", NULL);
    trace_add(NULL, NULL, cfg, "example_create_dir_config()");
d728 11
a738 8
static void *example_merge_dir_config(pool *p, void *parent_conf,
                                      void *newloc_conf)
{

    excfg *merged_config = (excfg *) ap_pcalloc(p, sizeof(excfg));
    excfg *pconf = (excfg *) parent_conf;
    excfg *nconf = (excfg *) newloc_conf;
    char *note;
d745 1
a745 1
    merged_config->loc = ap_pstrdup(p, nconf->loc);
d758 1
a758 1
        (pconf->cmode == nconf->cmode) ? pconf->cmode : CONFIG_MODE_COMBO;
d763 11
a773 3
    note = ap_pstrcat(p, "example_merge_dir_config(\"", pconf->loc, "\",\"",
                   nconf->loc, "\")", NULL);
    trace_add(NULL, NULL, merged_config, note);
d784 2
a785 2
static void *example_create_server_config(pool *p, server_rec *s)
{
d787 3
a789 2
    excfg *cfg;
    char *sname = s->server_hostname;
d792 2
a793 2
     * As with the example_create_dir_config() reoutine, we allocate and fill
     * in an empty record.
d795 1
a795 1
    cfg = (excfg *) ap_pcalloc(p, sizeof(excfg));
d803 2
a804 2
    cfg->loc = ap_pstrcat(p, "SVR(", sname, ")", NULL);
    trace_add(s, NULL, cfg, "example_create_server_config()");
d821 11
a831 8
static void *example_merge_server_config(pool *p, void *server1_conf,
                                         void *server2_conf)
{

    excfg *merged_config = (excfg *) ap_pcalloc(p, sizeof(excfg));
    excfg *s1conf = (excfg *) server1_conf;
    excfg *s2conf = (excfg *) server2_conf;
    char *note;
d838 1
a838 1
        (s1conf->cmode == s2conf->cmode) ? s1conf->cmode : CONFIG_MODE_COMBO;
d841 1
a841 1
    merged_config->loc = ap_pstrdup(p, s2conf->loc);
d845 11
a855 3
    note = ap_pstrcat(p, "example_merge_server_config(\"", s1conf->loc, "\",\"",
                   s2conf->loc, "\")", NULL);
    trace_add(NULL, NULL, merged_config, note);
a859 22
 * This routine is called after the request has been read but before any other
 * phases have been processed.  This allows us to make decisions based upon
 * the input header fields.
 *
 * The return value is OK, DECLINED, or HTTP_mumble.  If we return OK, no
 * further modules are called for this phase.
 */
static int example_post_read_request(request_rec *r)
{

    excfg *cfg;

    cfg = our_dconfig(r);
    /*
     * We don't actually *do* anything here, except note the fact that we were
     * called.
     */
    trace_add(r->server, r, cfg, "example_post_read_request()");
    return DECLINED;
}

/*
d867 2
a868 2
static int example_translate_handler(request_rec *r)
{
d870 2
a871 1
    excfg *cfg;
d873 1
a873 1
    cfg = our_dconfig(r);
d878 1
a878 1
    trace_add(r->server, r, cfg, "example_translate_handler()");
d891 2
a892 2
static int example_check_user_id(request_rec *r)
{
d894 2
a895 1
    excfg *cfg;
d897 1
a897 1
    cfg = our_dconfig(r);
d901 1
a901 1
    trace_add(r->server, r, cfg, "example_check_user_id()");
d915 2
a916 2
static int example_auth_checker(request_rec *r)
{
d918 2
a919 1
    excfg *cfg;
d921 1
a921 1
    cfg = our_dconfig(r);
d926 2
a927 2
    trace_add(r->server, r, cfg, "example_auth_checker()");
    return DECLINED;
d939 2
a940 2
static int example_access_checker(request_rec *r)
{
d942 2
a943 1
    excfg *cfg;
d945 3
a947 3
    cfg = our_dconfig(r);
    trace_add(r->server, r, cfg, "example_access_checker()");
    return DECLINED;
d958 2
a959 2
static int example_type_checker(request_rec *r)
{
d961 2
a962 1
    excfg *cfg;
d964 1
a964 1
    cfg = our_dconfig(r);
d969 1
a969 1
    trace_add(r->server, r, cfg, "example_type_checker()");
d981 2
a982 2
static int example_fixer_upper(request_rec *r)
{
d984 2
a985 1
    excfg *cfg;
d987 1
a987 1
    cfg = our_dconfig(r);
d991 1
a991 1
    trace_add(r->server, r, cfg, "example_fixer_upper()");
d1002 2
a1003 2
static int example_logger(request_rec *r)
{
d1005 2
a1006 1
    excfg *cfg;
d1008 2
a1009 2
    cfg = our_dconfig(r);
    trace_add(r->server, r, cfg, "example_logger()");
d1021 2
a1022 2
static int example_header_parser(request_rec *r)
{
d1024 2
a1025 1
    excfg *cfg;
d1027 2
a1028 2
    cfg = our_dconfig(r);
    trace_add(r->server, r, cfg, "example_header_parser()");
d1033 4
a1036 4
/*                                                                          */
/* All of the routines have been declared now.  Here's the list of          */
/* directives specific to our module, and information about where they      */
/* may appear and how the command parser should pass them to us for         */
d1038 2
a1039 2
/* collisions of directive names between modules.                           */
/*                                                                          */
d1044 1
a1044 2
static const command_rec example_cmds[] =
{
d1046 7
a1052 7
        "Example",              /* directive name */
        cmd_example,            /* config action routine */
        NULL,                   /* argument to include in call */
        OR_OPTIONS,             /* where available */
        NO_ARGS,                /* arguments */
        "Example directive - no arguments"
                                /* directive description */
d1054 1
a1054 1
    {NULL}
d1058 3
a1060 3
/*                                                                          */
/* Now the list of content handlers available from this module.             */
/*                                                                          */
d1074 3
a1076 4
static const handler_rec example_handlers[] =
{
    {"example-handler", example_handler},
    {NULL}
d1080 2
a1081 2
/*                                                                          */
/* Finally, the list of callback routines and data structures that          */
d1083 1
a1083 1
/*                                                                          */
d1093 1
a1093 2
module example_module =
{
d1095 15
a1109 26
    example_init,               /* module initializer */
    example_create_dir_config,  /* per-directory config creator */
    example_merge_dir_config,   /* dir config merger */
    example_create_server_config,       /* server config creator */
    example_merge_server_config,        /* server config merger */
    example_cmds,               /* command table */
    example_handlers,           /* [7] list of handlers */
    example_translate_handler,  /* [2] filename-to-URI translation */
    example_check_user_id,      /* [5] check/validate user_id */
    example_auth_checker,       /* [6] check user_id is valid *here* */
    example_access_checker,     /* [4] check access by host address */
    example_type_checker,       /* [7] MIME type checker/setter */
    example_fixer_upper,        /* [8] fixups */
    example_logger,             /* [10] logger */
#if MODULE_MAGIC_NUMBER >= 19970103
    example_header_parser,      /* [3] header parser */
#endif
#if MODULE_MAGIC_NUMBER >= 19970719
    example_child_init,         /* process initializer */
#endif
#if MODULE_MAGIC_NUMBER >= 19970728
    example_child_exit,         /* process exit/cleanup */
#endif
#if MODULE_MAGIC_NUMBER >= 19970902
    example_post_read_request   /* [1] post read_request handling */
#endif
@


1.1.1.3
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 23
a38 20
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 6
a55 7
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
d135 1
a135 1
module MODULE_VAR_EXPORT example_module;
d427 1
a427 2
#if EXAMPLE_LOG_EACH
    if (s != NULL) {
a429 1
#endif
a512 1

a514 5
#ifdef CHARSET_EBCDIC
    /* Server-generated response, converted */
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
#endif

d528 1
a528 1
    ap_rputs(DOCTYPE_HTML_3_2, r);
d710 1
a710 1
 * This function gets called to create a per-directory configuration
d1120 1
a1120 1
module MODULE_VAR_EXPORT example_module =
d1129 1
a1129 1
    example_handlers,           /* [9] list of handlers */
@


1.1.1.4
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
@


