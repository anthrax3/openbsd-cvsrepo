head	1.14;
access;
symbols
	OPENBSD_5_5:1.13.0.26
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.22
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.20
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.18
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.16
	OPENBSD_5_0:1.13.0.14
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.12
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.10
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.6
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.6
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.4
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.4
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.3
	apache_1_3_27:1.1.1.3
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	apache_1_3_26:1.1.1.3
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.2.0.2
	OPENBSD_2_4_BASE:1.1.1.2
	apache_1_3_2:1.1.1.2
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	apache:1.1.1
	apache_1_2_6:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.13;

1.13
date	2008.05.09.08.06.28;	author mbalmer;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.06.03.14.37;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.01.12.53.59;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.21.13.11.36;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.09.12.35.41;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.19.21.31.16;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.29.02.08.06;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.29.10.21.45;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.22.18.14;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.25.18.29.50;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.06.29.42;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.03.01.01.06.26;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.03.25.07.08.50;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.25.07.08.50;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.10.01.17.19.41;	author beck;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.07.19.21.28.54;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.21.12.53.40;	author henning;	state Exp;
branches;
next	;


desc
@@


1.14
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

#ifndef MOD_PROXY_H
#define MOD_PROXY_H 

/*
 * Main include file for the Apache proxy
 */

/*

   Note numerous FIXMEs and CHECKMEs which should be eliminated.

   If TESTING is set, then garbage collection doesn't delete ... probably a good
   idea when hacking.

 */

#define TESTING 0

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"

#include "explain.h"

extern module MODULE_VAR_EXPORT proxy_module;


/* for proxy_canonenc() */
enum enctype {
    enc_path, enc_search, enc_user, enc_fpath, enc_parm
};

#define HDR_APP (0)             /* append header, for proxy_add_header() */
#define HDR_REP (1)             /* replace header, for proxy_add_header() */

/* number of characters in the hash */
#define HASH_LEN (22*2)

/* maximum  'CacheDirLevels*CacheDirLength' value */
#define CACHEFILE_LEN 20        /* must be less than HASH_LEN/2 */

#define SEC_ONE_DAY             86400   /* one day, in seconds */
#define SEC_ONE_HR              3600    /* one hour, in seconds */

#define DEFAULT_FTP_DATA_PORT   20
#define DEFAULT_FTP_PORT        21
#define DEFAULT_GOPHER_PORT     70
#define DEFAULT_NNTP_PORT       119
#define DEFAULT_WAIS_PORT       210
#define DEFAULT_HTTPS_PORT      443
#define DEFAULT_SNEWS_PORT      563
#define DEFAULT_PROSPERO_PORT   1525    /* WARNING: conflict w/Oracle */

/* Some WWW schemes and their default ports; this is basically /etc/services */
struct proxy_services {
    const char *scheme;
    int port;
};

/* static information about a remote proxy */
struct proxy_remote {
    const char *scheme;         /* the schemes handled by this proxy, or '*' */
    const char *protocol;       /* the scheme used to talk to this proxy */
    const char *hostname;       /* the hostname of this proxy */
    int port;                   /* the port for this proxy */
};

struct proxy_alias {
    char *real;
    char *fake;
};

struct dirconn_entry {
    char *name;
    struct in_addr addr, mask;
    struct hostent *hostentry;
    int (*matcher) (struct dirconn_entry * This, request_rec *r);
};

struct noproxy_entry {
    char *name;
    struct in_addr addr;
};

struct nocache_entry {
    char *name;
    struct in_addr addr;
};

#define DEFAULT_CACHE_SPACE 5
#define DEFAULT_CACHE_MAXEXPIRE SEC_ONE_DAY
#define DEFAULT_CACHE_EXPIRE    SEC_ONE_HR
#define DEFAULT_CACHE_LMFACTOR (0.1)
#define DEFAULT_CACHE_COMPLETION (0.9)
#define DEFAULT_CACHE_GCINTERVAL SEC_ONE_HR

#ifndef MAX
#define MAX(a,b)                ((a) > (b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b)                ((a) < (b) ? (a) : (b))
#endif

/* static information about the local cache */
struct cache_conf {
    const char *root;           /* the location of the cache directory */
    off_t space;                /* Maximum cache size (in 1024 bytes) */
    char space_set;
    time_t maxexpire;           /* Maximum time to keep cached files in secs */
    char maxexpire_set;
    time_t defaultexpire;       /* default time to keep cached file in secs */
    char defaultexpire_set;
    double lmfactor;            /* factor for estimating expires date */
    char lmfactor_set;
    time_t gcinterval;          /* garbage collection interval, in seconds */
    char gcinterval_set;
    int dirlevels;              /* Number of levels of subdirectories */
    char dirlevels_set;
    int dirlength;              /* Length of subdirectory names */
    char dirlength_set;
    float cache_completion;     /* Force cache completion after this point */
    char cache_completion_set;
};

typedef struct {
    struct cache_conf cache;    /* cache configuration */
    array_header *proxies;
    array_header *aliases;
    array_header *raliases;
    array_header *noproxies;
    array_header *dirconn;
    array_header *nocaches;
    array_header *allowed_connect_ports;
    char *domain;               /* domain name to use in absence of a domain name in the request */
    int req;                    /* true if proxy requests are enabled */
    char req_set;
    enum {
      via_off,
      via_on,
      via_block,
      via_full
    } viaopt;                   /* how to deal with proxy Via: headers */
    char viaopt_set;
    size_t recv_buffer_size;
    char recv_buffer_size_set;
    size_t io_buffer_size;
    char io_buffer_size_set;
    int preserve_host;
    int preserve_host_set;
} proxy_server_conf;

struct hdr_entry {
    const char *field;
    const char *value;
};

/* caching information about a request */
typedef struct {
    request_rec *req;           /* the request */
    char *url;                  /* the URL requested */
    char *filename;             /* name of the cache file,
                                   or NULL if no cache */
    char *tempfile;             /* name of the temporary file,
                                   or NULL if not caching */
    time_t ims;                 /* if-Modified-Since date of request,
                                   -1 if no header */
    time_t ius;                 /* if-Unmodified-Since date of request,
                                   -1 if no header */
    const char *im;             /* if-Match etag of request,
                                   NULL if no header */
    const char *inm;            /* if-None-Match etag of request,
                                   NULL if no header */
    BUFF *fp;                   /* the cache file descriptor if the file
                                   is cached and may be returned,
                                   or NULL if the file is not cached
                                   (or must be reloaded) */
    BUFF *origfp;               /* the old cache file descriptor if the file has
                                   been revalidated and is being rewritten to
                                   disk */
    time_t expire;              /* calculated expire date of cached entity */
    time_t lmod;                /* last-modified date of cached entity */
    time_t date;                /* the date the cached file was last touched */
    time_t req_time;            /* the time the request started */
    time_t resp_time;           /* the time the response was received */
    int version;                /* update count of the file */
    off_t len;                  /* content length */
    char *protocol;             /* Protocol, and major/minor number,
                                   e.g. HTTP/1.1 */
    int status;                 /* the status of the cached file */
    unsigned int written;       /* total *content* bytes written to cache */
    float cache_completion;     /* specific to this request */
    char *resp_line;            /* the whole status line
                                   (protocol, code + message) */
    table *req_hdrs;            /* the original request headers */
    table *hdrs;                /* the original HTTP response headers
                                   of the file */
    char *xcache;               /* the X-Cache header value
                                   to be sent to client */
} cache_req;

struct per_thread_data {
    struct hostent hpbuf;
    in_addr_t ipaddr;
    char *charpbuf[2];
};
/* Function prototypes */

/* proxy_cache.c */

void ap_proxy_cache_tidy(cache_req *c);
int ap_proxy_cache_check(request_rec *r, char *url, struct cache_conf *conf,
                      cache_req **cr);
int ap_proxy_cache_update(cache_req *c, table *resp_hdrs,
                       const int is_HTTP1, int nocache);
void ap_proxy_garbage_coll(request_rec *r);

/* proxy_connect.c */

int ap_proxy_connect_handler(request_rec *r, cache_req *c, char *url,
                          const char *proxyhost, int proxyport);

/* proxy_ftp.c */

int ap_proxy_ftp_canon(request_rec *r, char *url);
int ap_proxy_ftp_handler(request_rec *r, cache_req *c, char *url);

/* proxy_http.c */

int ap_proxy_http_canon(request_rec *r, char *url, const char *scheme,
                     int def_port);
int ap_proxy_http_handler(request_rec *r, cache_req *c, char *url,
                       const char *proxyhost, int proxyport);

/* proxy_util.c */

int ap_proxy_hex2c(const char *x);
void ap_proxy_c2hex(int ch, char *x);
char *ap_proxy_canonenc(pool *p, const char *x, int len, enum enctype t,
                        enum proxyreqtype isenc);
char *ap_proxy_canon_netloc(pool *p, char **const urlp, char **userp,
                         char **passwordp, char **hostp, int *port);
const char *ap_proxy_date_canon(pool *p, const char *x);
table *ap_proxy_read_headers(request_rec *r, char *buffer, int size, BUFF *f);
long int ap_proxy_send_fb(BUFF *f, request_rec *r, cache_req *c, off_t len, int nowrite, int chunked, size_t recv_buffer_size);
void ap_proxy_write_headers(cache_req *c, const char *respline, table *t);
int ap_proxy_liststr(const char *list, const char *key, char **val);
void ap_proxy_hash(const char *it, char *val, int ndepth, int nlength);
int ap_proxy_hex2sec(const char *x);
int ap_proxy_sec2hex(int t, char *y, int len);
cache_req *ap_proxy_cache_error(cache_req *r);
int ap_proxyerror(request_rec *r, int statuscode, const char *message);
const char *ap_proxy_host2addr(const char *host, struct hostent *reqhp);
int ap_proxy_is_ipaddr(struct dirconn_entry *This, pool *p);
int ap_proxy_is_domainname(struct dirconn_entry *This, pool *p);
int ap_proxy_is_hostname(struct dirconn_entry *This, pool *p);
int ap_proxy_is_word(struct dirconn_entry *This, pool *p);
int ap_proxy_doconnect(int sock, struct sockaddr *addr, request_rec *r);
int ap_proxy_garbage_init(server_rec *, pool *);
/* This function is called by ap_table_do() for all header lines */
int ap_proxy_send_hdr_line(void *p, const char *key, const char *value);
unsigned ap_proxy_bputs2(const char *data, BUFF *client, cache_req *cache);
time_t ap_proxy_current_age(cache_req *c, const time_t age_value);
BUFF *ap_proxy_open_cachefile(request_rec *r, char *filename);
BUFF *ap_proxy_create_cachefile(request_rec *r, char *filename);
void ap_proxy_clear_connection(pool *p, table *headers);
int ap_proxy_table_replace(table *base, table *overlay);
void ap_proxy_table_unmerge(pool *p, table *t, char *key);
int ap_proxy_read_response_line(BUFF *f, request_rec *r, char *buffer, int size, int *backasswards, int *major, int *minor);

/* WARNING - PRIVATE DEFINITION BELOW */

/* XXX: if you tweak this you should look at is_empty_table() and table_elts()
 * in ap_alloc.h
 *
 * NOTE: this private definition is a duplicate of the one in alloc.c
 * It's here for ap_proxy_table_replace() to avoid breaking binary compat
 */
struct table {
    /* This has to be first to promote backwards compatibility with
     * older modules which cast a table * to an array_header *...
     * they should use the table_elts() function for most of the
     * cases they do this for.
     */
    array_header a;
#ifdef MAKE_TABLE_PROFILE
    void *creator;
#endif
};

#endif /*MOD_PROXY_H*/
@


1.13
log
@Add support for IPv6 while keeping the default at IPv4 to not break
existing installations.  See the documentation for the IPv6 related
configuration.

This changes the module ABI since addresses are now struct addrinfo.

This has been tested by many people and run on production machines
for several months.

feedback many, ok todd
@
text
@@


1.12
log
@fix proxying on big-endian 64-bit machines, u_long is not the size of
an ip address, that's for sure; pr 5232 arjones@@simultan.dyndns.org
@
text
@d315 1
a315 1
int ap_proxy_doconnect(int sock, struct sockaddr_in *addr, request_rec *r);
@


1.11
log
@add ProxyPreserveHost support to mod_proxy. it allows to pass the original
Host header to the backend. default off. henning@@ ok.
@
text
@d261 1
a261 1
    u_long ipaddr;
@


1.10
log
@merge
@
text
@d206 2
@


1.9
log
@string shit; ok dhartmei@@
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
@


1.8
log
@merge
@
text
@d305 1
a305 1
void ap_proxy_sec2hex(int t, char *y);
@


1.7
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d300 1
a300 1
long int ap_proxy_send_fb(BUFF *f, request_rec *r, cache_req *c, off_t len, int nowrite, size_t recv_buffer_size);
d324 1
@


1.6
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d68 1
a68 2
   Note that the Explain() stuff is not yet complete.
   Also note numerous FIXMEs and CHECKMEs which should be eliminated.
a72 30
   This code is still experimental!

   Things to do:

   1. Make it garbage collect in the background, not while someone is waiting for
   a response!

   2. Check the logic thoroughly.

   3. Empty directories are only removed the next time round (but this does avoid
   two passes). Consider doing them the first time round.

   Ben Laurie <ben@@algroup.co.uk> 30 Mar 96

   More things to do:

   0. Code cleanup (ongoing)

   1. add 230 response output for ftp now that it works

   2. Make the ftp proxy transparent, also same with (future) gopher & wais

   3. Use protocol handler struct a la Apache module handlers (Dirk van Gulik)

   4. Use a cache expiry database for more efficient GC (Jeremy Wohl)

   5. Bulletproof GC against SIGALRM

   Chuck Murcko <chuck@@topsail.org> 15 April 1997

d75 1
a75 2
#define TESTING	0
#undef EXPLAIN
d91 2
a92 2
#define HDR_APP (0)		/* append header, for proxy_add_header() */
#define HDR_REP (1)		/* replace header, for proxy_add_header() */
d98 1
a98 1
#define CACHEFILE_LEN 20	/* must be less than HASH_LEN/2 */
d100 2
a101 2
#define	SEC_ONE_DAY		86400	/* one day, in seconds */
#define	SEC_ONE_HR		3600	/* one hour, in seconds */
d103 8
a110 8
#define	DEFAULT_FTP_DATA_PORT	20
#define	DEFAULT_FTP_PORT	21
#define	DEFAULT_GOPHER_PORT	70
#define	DEFAULT_NNTP_PORT	119
#define	DEFAULT_WAIS_PORT	210
#define	DEFAULT_HTTPS_PORT	443
#define	DEFAULT_SNEWS_PORT	563
#define	DEFAULT_PROSPERO_PORT	1525	/* WARNING: conflict w/Oracle */
d120 4
a123 4
    const char *scheme;		/* the schemes handled by this proxy, or '*' */
    const char *protocol;	/* the scheme used to talk to this proxy */
    const char *hostname;	/* the hostname of this proxy */
    int port;			/* the port for this proxy */
d155 7
d164 2
a165 2
    const char *root;		/* the location of the cache directory */
    off_t space;			/* Maximum cache size (in 1024 bytes) */
d167 1
a167 1
    time_t maxexpire;		/* Maximum time to keep cached files in secs */
d169 1
a169 1
    time_t defaultexpire;	/* default time to keep cached file in secs */
d171 1
a171 1
    double lmfactor;		/* factor for estimating expires date */
d173 1
a173 1
    time_t gcinterval;		/* garbage collection interval, in seconds */
d175 1
a175 1
    int dirlevels;		/* Number of levels of subdirectories */
d177 1
a177 1
    int dirlength;		/* Length of subdirectory names */
d179 1
a179 1
    float cache_completion;	/* Force cache completion after this point */
d184 1
a184 1
    struct cache_conf cache;	/* cache configuration */
d192 2
a193 2
    char *domain;		/* domain name to use in absence of a domain name in the request */
    int req;			/* true if proxy requests are enabled */
d204 2
d215 40
a254 19
    request_rec *req;		/* the request */
    char *url;			/* the URL requested */
    char *filename;		/* name of the cache file, or NULL if no cache */
    char *tempfile;		/* name of the temporary file, of NULL if not caching */
    time_t ims;			/* if-modified-since date of request; -1 if no header */
    BUFF *fp;			/* the cache file descriptor if the file is cached
				   and may be returned, or NULL if the file is
				   not cached (or must be reloaded) */
    time_t expire;		/* calculated expire date of cached entity */
    time_t lmod;		/* last-modified date of cached entity */
    time_t date;		/* the date the cached file was last touched */
    int version;		/* update count of the file */
    off_t len;			/* content length */
    char *protocol;		/* Protocol, and major/minor number, e.g. HTTP/1.1 */
    int status;			/* the status of the cached file */
    unsigned int written;	/* total *content* bytes written to cache */
    float cache_completion;	/* specific to this request */
    char *resp_line;		/* the whole status like (protocol, code + message) */
    table *hdrs;		/* the HTTP headers of the file */
a256 6
/* Additional information passed to the function called by ap_table_do() */
struct tbl_do_args {
    request_rec *req;
    cache_req *cache;
};

d268 1
a268 1
		      cache_req **cr);
d270 1
a270 1
		       const int is_HTTP1, int nocache);
d276 1
a276 1
			  const char *proxyhost, int proxyport);
d286 1
a286 1
		     int def_port);
d288 1
a288 1
		       const char *proxyhost, int proxyport);
d295 1
a295 1
			enum proxyreqtype isenc);
d297 1
a297 1
			 char **passwordp, char **hostp, int *port);
d300 3
a302 3
long int ap_proxy_send_fb(BUFF *f, request_rec *r, cache_req *c);
void ap_proxy_send_headers(request_rec *r, const char *respline, table *hdrs);
int ap_proxy_liststr(const char *list, const char *val);
d318 26
@


1.5
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1996-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 20
a38 23
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 7
a56 6
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
d185 1
@


1.4
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d263 5
@


1.3
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@a130 7
#ifdef CHARSET_EBCDIC
#define CRLF   "\r\n"
#else /*CHARSET_EBCDIC*/
#define CRLF   "\015\012"
#endif /*CHARSET_EBCDIC*/


d189 1
d191 1
d193 1
d195 1
d197 1
d199 1
d201 1
d203 1
d217 1
d224 1
d226 1
d296 1
a296 1
		     int isenc);
@


1.2
log
@Apache 1.3.4 merge
@
text
@d304 1
a304 1
int ap_proxyerror(request_rec *r, const char *message);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1996,1997 The Apache Group.  All rights reserved.
d23 2
a24 1
 *    prior written permission.
d26 5
a30 1
 * 5. Redistributions of any form whatsoever must retain the following
d58 3
d67 2
a68 2
Note that the Explain() stuff is not yet complete.
Also note numerous FIXMEs and CHECKMEs which should be eliminated.
d70 2
a71 2
If TESTING is set, then garbage collection doesn't delete ... probably a good
idea when hacking.
d73 1
a73 1
This code is still experimental!
d75 1
a75 1
Things to do:
d77 2
a78 2
1. Make it garbage collect in the background, not while someone is waiting for
a response!
d80 1
a80 1
2. Check the logic thoroughly.
d82 2
a83 2
3. Empty directories are only removed the next time round (but this does avoid
two passes). Consider doing them the first time round.
d85 1
a85 1
Ben Laurie <ben@@algroup.co.uk> 30 Mar 96
d87 1
a87 1
More things to do:
d89 1
a89 1
0. Code cleanup (ongoing)
d91 1
a91 1
1. add 230 response output for ftp now that it works
d93 1
a93 1
2. Make the ftp proxy transparent, also same with (future) gopher & wais
d95 1
a95 3
3. Use protocol handler struct a la Apache module handlers (Dirk van Gulik)
 
4. Use a cache expiry database for more efficient GC (Jeremy Wohl)
d97 1
a97 1
5. Bulletproof GC against SIGALRM
d99 1
a99 1
Chuck Murcko <chuck@@topsail.org> 15 April 1997
d101 3
a103 1
*/
d111 1
a111 1
  
d114 1
a114 1
DEF_Explain
d117 4
a120 2
extern module proxy_module;

d122 2
a123 5
/* for proxy_canonenc() */
enum enctype { enc_path, enc_search, enc_user, enc_fpath, enc_parm }; 
 
#define HDR_APP (0)	/* append header, for proxy_add_header() */
#define HDR_REP (1)	/* replace header, for proxy_add_header() */
d128 10
d151 1
a151 2
struct proxy_services
{
d157 5
a161 6
struct proxy_remote
{
    const char *scheme;    /* the schemes handled by this proxy, or '*' */
    const char *protocol;  /* the scheme used to talk to this proxy */
    const char *hostname;  /* the hostname of this proxy */
    int port;              /* the port for this proxy */
d169 7
d190 1
d193 10
a202 10
struct cache_conf
{
    const char *root;   /* the location of the cache directory */
    int space;          /* Maximum cache size (in 1024 bytes) */
    int maxexpire;      /* Maximum time to keep cached files in secs */
    int defaultexpire;  /* default time to keep cached file in secs */
    double lmfactor;    /* factor for estimating expires date */
    int gcinterval;     /* garbage collection interval, in seconds */
    int dirlevels;	/* Number of levels of subdirectories */
    int dirlength;	/* Length of subdirectory names */
d205 2
a206 3
typedef struct
{
    struct cache_conf cache;  /* cache configuration */
d209 1
d211 1
d213 10
a222 1
    int req;                 /* true if proxy requests are enabled */
d225 3
a227 4
struct hdr_entry
{
    char *field;
    char *value;
d231 26
a256 19
struct cache_req
{
    request_rec *req;  /* the request */
    char *url;         /* the URL requested */
    char *filename;    /* name of the cache file, or NULL if no cache */
    char *tempfile;    /* name of the temporary file, of NULL if not caching */
    time_t ims;        /* if-modified-since date of request; -1 if no header */
    BUFF *fp;          /* the cache file descriptor if the file is cached
                          and may be returned, or NULL if the file is
                          not cached (or must be reloaded) */
    time_t expire;      /* calculated expire date of cached entity */
    time_t lmod;        /* last-modified date of cached entity */
    time_t date;        /* the date the cached file was last touched */
    int version;        /* update count of the file */
    unsigned int len;   /* content length */
    char *protocol;     /* Protocol, and major/minor number, e.g. HTTP/1.1 */
    int status;         /* the status of the cached file */
    char *resp_line;    /* the whole status like (protocol, code + message) */
    array_header *hdrs; /* the HTTP headers of the file */
d258 1
a258 1
      
d263 6
a268 6
void proxy_cache_tidy(struct cache_req *c);
int proxy_cache_check(request_rec *r, char *url, struct cache_conf *conf,
    struct cache_req **cr);
int proxy_cache_update(struct cache_req *c, array_header *resp_hdrs,
    const int is_HTTP1, int nocache);
void proxy_garbage_coll(request_rec *r);
d272 2
a273 1
int proxy_connect_handler(request_rec *r, struct cache_req *c, char *url);
d277 2
a278 2
int proxy_ftp_canon(request_rec *r, char *url);
int proxy_ftp_handler(request_rec *r, struct cache_req *c, char *url);
d282 4
a285 4
int proxy_http_canon(request_rec *r, char *url, const char *scheme,
    int def_port);
int proxy_http_handler(request_rec *r, struct cache_req *c, char *url,
    const char *proxyhost, int proxyport);
d289 26
a314 24
int proxy_hex2c(const char *x);
void proxy_c2hex(int ch, char *x);
char *proxy_canonenc(pool *p, const char *x, int len, enum enctype t,
    int isenc);
char *proxy_canon_netloc(pool *pool, char **const urlp, char **userp,
    char **passwordp, char **hostp, int *port);
char *proxy_date_canon(pool *p, char *x);
array_header *proxy_read_headers(pool *pool, char *buffer, int size, BUFF *f);
long int proxy_send_fb(BUFF *f, request_rec *r, BUFF *f2, struct cache_req *c);
struct hdr_entry *proxy_get_header(array_header *hdrs_arr, const char *name);
struct hdr_entry *proxy_add_header(array_header *hdrs_arr, char *field,
    char *value, int rep);
void proxy_del_header(array_header *hdrs_arr, const char *field);
void proxy_send_headers(BUFF *fp, const char *respline, array_header *hdrs_arr);
int proxy_liststr(const char *list, const char *val);
void proxy_hash(const char *it, char *val,int ndepth,int nlength);
int proxy_hex2sec(const char *x);
void proxy_sec2hex(int t, char *y);
void proxy_log_uerror(const char *routine, const char *file, const char *err,
    server_rec *s);
BUFF *proxy_cache_error(struct cache_req *r);
int proxyerror(request_rec *r, const char *message);
const char *proxy_host2addr(const char *host, struct hostent *reqhp);
int proxy_doconnect(int sock, struct sockaddr_in *addr, request_rec *r);
d316 1
@


1.1.1.1
log
@Initial import from apache 1.2.6
@
text
@@


1.1.1.2
log
@Apache 1.3.2
@
text
@d2 1
a2 1
 * Copyright (c) 1996-1998 The Apache Group.  All rights reserved.
d23 1
a23 2
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
d25 1
a25 5
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
a52 3
#ifndef MOD_PROXY_H
#define MOD_PROXY_H 

d59 2
a60 2
   Note that the Explain() stuff is not yet complete.
   Also note numerous FIXMEs and CHECKMEs which should be eliminated.
d62 2
a63 2
   If TESTING is set, then garbage collection doesn't delete ... probably a good
   idea when hacking.
d65 1
a65 1
   This code is still experimental!
d67 1
a67 1
   Things to do:
d69 2
a70 2
   1. Make it garbage collect in the background, not while someone is waiting for
   a response!
d72 1
a72 1
   2. Check the logic thoroughly.
d74 2
a75 2
   3. Empty directories are only removed the next time round (but this does avoid
   two passes). Consider doing them the first time round.
d77 1
a77 1
   Ben Laurie <ben@@algroup.co.uk> 30 Mar 96
d79 1
a79 1
   More things to do:
d81 1
a81 1
   0. Code cleanup (ongoing)
d83 1
a83 1
   1. add 230 response output for ftp now that it works
d85 1
a85 1
   2. Make the ftp proxy transparent, also same with (future) gopher & wais
d87 3
a89 1
   3. Use protocol handler struct a la Apache module handlers (Dirk van Gulik)
d91 1
a91 1
   4. Use a cache expiry database for more efficient GC (Jeremy Wohl)
d93 1
a93 1
   5. Bulletproof GC against SIGALRM
d95 1
a95 3
   Chuck Murcko <chuck@@topsail.org> 15 April 1997

 */
d103 4
a107 1
#include "explain.h"
d109 1
a109 1
extern module MODULE_VAR_EXPORT proxy_module;
d113 4
a116 6
enum enctype {
    enc_path, enc_search, enc_user, enc_fpath, enc_parm
};

#define HDR_APP (0)		/* append header, for proxy_add_header() */
#define HDR_REP (1)		/* replace header, for proxy_add_header() */
a120 10
/* maximum  'CacheDirLevels*CacheDirLength' value */
#define CACHEFILE_LEN 20	/* must be less than HASH_LEN/2 */

#ifdef CHARSET_EBCDIC
#define CRLF   "\r\n"
#else /*CHARSET_EBCDIC*/
#define CRLF   "\015\012"
#endif /*CHARSET_EBCDIC*/


d134 2
a135 1
struct proxy_services {
d141 6
a146 5
struct proxy_remote {
    const char *scheme;		/* the schemes handled by this proxy, or '*' */
    const char *protocol;	/* the scheme used to talk to this proxy */
    const char *hostname;	/* the hostname of this proxy */
    int port;			/* the port for this proxy */
a153 7
struct dirconn_entry {
    char *name;
    struct in_addr addr, mask;
    struct hostent *hostentry;
    int (*matcher) (struct dirconn_entry * This, request_rec *r);
};

a167 1
#define DEFAULT_CACHE_COMPLETION (0.9)
d170 10
a179 10
struct cache_conf {
    const char *root;		/* the location of the cache directory */
    off_t space;			/* Maximum cache size (in 1024 bytes) */
    time_t maxexpire;		/* Maximum time to keep cached files in secs */
    time_t defaultexpire;	/* default time to keep cached file in secs */
    double lmfactor;		/* factor for estimating expires date */
    time_t gcinterval;		/* garbage collection interval, in seconds */
    int dirlevels;		/* Number of levels of subdirectories */
    int dirlength;		/* Length of subdirectory names */
    float cache_completion;	/* Force cache completion after this point */
d182 3
a184 2
typedef struct {
    struct cache_conf cache;	/* cache configuration */
a186 1
    array_header *raliases;
a187 1
    array_header *dirconn;
d189 1
a189 10
    array_header *allowed_connect_ports;
    char *domain;		/* domain name to use in absence of a domain name in the request */
    int req;			/* true if proxy requests are enabled */
    enum {
      via_off,
      via_on,
      via_block,
      via_full
    } viaopt;                   /* how to deal with proxy Via: headers */
    size_t recv_buffer_size;
d192 4
a195 3
struct hdr_entry {
    const char *field;
    const char *value;
d199 19
a217 26
typedef struct {
    request_rec *req;		/* the request */
    char *url;			/* the URL requested */
    char *filename;		/* name of the cache file, or NULL if no cache */
    char *tempfile;		/* name of the temporary file, of NULL if not caching */
    time_t ims;			/* if-modified-since date of request; -1 if no header */
    BUFF *fp;			/* the cache file descriptor if the file is cached
				   and may be returned, or NULL if the file is
				   not cached (or must be reloaded) */
    time_t expire;		/* calculated expire date of cached entity */
    time_t lmod;		/* last-modified date of cached entity */
    time_t date;		/* the date the cached file was last touched */
    int version;		/* update count of the file */
    off_t len;			/* content length */
    char *protocol;		/* Protocol, and major/minor number, e.g. HTTP/1.1 */
    int status;			/* the status of the cached file */
    unsigned int written;	/* total *content* bytes written to cache */
    float cache_completion;	/* specific to this request */
    char *resp_line;		/* the whole status like (protocol, code + message) */
    table *hdrs;		/* the HTTP headers of the file */
} cache_req;

/* Additional information passed to the function called by ap_table_do() */
struct tbl_do_args {
    request_rec *req;
    cache_req *cache;
d219 1
a219 1

d224 6
a229 6
void ap_proxy_cache_tidy(cache_req *c);
int ap_proxy_cache_check(request_rec *r, char *url, struct cache_conf *conf,
		      cache_req **cr);
int ap_proxy_cache_update(cache_req *c, table *resp_hdrs,
		       const int is_HTTP1, int nocache);
void ap_proxy_garbage_coll(request_rec *r);
d233 1
a233 2
int ap_proxy_connect_handler(request_rec *r, cache_req *c, char *url,
			  const char *proxyhost, int proxyport);
d237 2
a238 2
int ap_proxy_ftp_canon(request_rec *r, char *url);
int ap_proxy_ftp_handler(request_rec *r, cache_req *c, char *url);
d242 4
a245 4
int ap_proxy_http_canon(request_rec *r, char *url, const char *scheme,
		     int def_port);
int ap_proxy_http_handler(request_rec *r, cache_req *c, char *url,
		       const char *proxyhost, int proxyport);
d249 24
a272 26
int ap_proxy_hex2c(const char *x);
void ap_proxy_c2hex(int ch, char *x);
char *ap_proxy_canonenc(pool *p, const char *x, int len, enum enctype t,
		     int isenc);
char *ap_proxy_canon_netloc(pool *p, char **const urlp, char **userp,
			 char **passwordp, char **hostp, int *port);
const char *ap_proxy_date_canon(pool *p, const char *x);
table *ap_proxy_read_headers(request_rec *r, char *buffer, int size, BUFF *f);
long int ap_proxy_send_fb(BUFF *f, request_rec *r, cache_req *c);
void ap_proxy_send_headers(request_rec *r, const char *respline, table *hdrs);
int ap_proxy_liststr(const char *list, const char *val);
void ap_proxy_hash(const char *it, char *val, int ndepth, int nlength);
int ap_proxy_hex2sec(const char *x);
void ap_proxy_sec2hex(int t, char *y);
cache_req *ap_proxy_cache_error(cache_req *r);
int ap_proxyerror(request_rec *r, const char *message);
const char *ap_proxy_host2addr(const char *host, struct hostent *reqhp);
int ap_proxy_is_ipaddr(struct dirconn_entry *This, pool *p);
int ap_proxy_is_domainname(struct dirconn_entry *This, pool *p);
int ap_proxy_is_hostname(struct dirconn_entry *This, pool *p);
int ap_proxy_is_word(struct dirconn_entry *This, pool *p);
int ap_proxy_doconnect(int sock, struct sockaddr_in *addr, request_rec *r);
int ap_proxy_garbage_init(server_rec *, pool *);
/* This function is called by ap_table_do() for all header lines */
int ap_proxy_send_hdr_line(void *p, const char *key, const char *value);
unsigned ap_proxy_bputs2(const char *data, BUFF *client, cache_req *cache);
a273 1
#endif /*MOD_PROXY_H*/
@


1.1.1.3
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 23
a38 20
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 5
a54 3
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
a55 3
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
d67 2
a68 1
   Note numerous FIXMEs and CHECKMEs which should be eliminated.
d73 30
d105 2
a106 1
#define TESTING 0
d122 2
a123 2
#define HDR_APP (0)             /* append header, for proxy_add_header() */
#define HDR_REP (1)             /* replace header, for proxy_add_header() */
d129 1
a129 4
#define CACHEFILE_LEN 20        /* must be less than HASH_LEN/2 */

#define SEC_ONE_DAY             86400   /* one day, in seconds */
#define SEC_ONE_HR              3600    /* one hour, in seconds */
d131 18
a148 8
#define DEFAULT_FTP_DATA_PORT   20
#define DEFAULT_FTP_PORT        21
#define DEFAULT_GOPHER_PORT     70
#define DEFAULT_NNTP_PORT       119
#define DEFAULT_WAIS_PORT       210
#define DEFAULT_HTTPS_PORT      443
#define DEFAULT_SNEWS_PORT      563
#define DEFAULT_PROSPERO_PORT   1525    /* WARNING: conflict w/Oracle */
d158 4
a161 4
    const char *scheme;         /* the schemes handled by this proxy, or '*' */
    const char *protocol;       /* the scheme used to talk to this proxy */
    const char *hostname;       /* the hostname of this proxy */
    int port;                   /* the port for this proxy */
a190 8
#define DEFAULT_CACHE_GCINTERVAL SEC_ONE_HR

#ifndef MAX
#define MAX(a,b)                ((a) > (b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b)                ((a) < (b) ? (a) : (b))
#endif
d194 9
a202 17
    const char *root;           /* the location of the cache directory */
    off_t space;                /* Maximum cache size (in 1024 bytes) */
    char space_set;
    time_t maxexpire;           /* Maximum time to keep cached files in secs */
    char maxexpire_set;
    time_t defaultexpire;       /* default time to keep cached file in secs */
    char defaultexpire_set;
    double lmfactor;            /* factor for estimating expires date */
    char lmfactor_set;
    time_t gcinterval;          /* garbage collection interval, in seconds */
    char gcinterval_set;
    int dirlevels;              /* Number of levels of subdirectories */
    char dirlevels_set;
    int dirlength;              /* Length of subdirectory names */
    char dirlength_set;
    float cache_completion;     /* Force cache completion after this point */
    char cache_completion_set;
d206 1
a206 1
    struct cache_conf cache;    /* cache configuration */
d214 2
a215 3
    char *domain;               /* domain name to use in absence of a domain name in the request */
    int req;                    /* true if proxy requests are enabled */
    char req_set;
a221 1
    char viaopt_set;
a222 3
    char recv_buffer_size_set;
    size_t io_buffer_size;
    char io_buffer_size_set;
d232 19
a250 40
    request_rec *req;           /* the request */
    char *url;                  /* the URL requested */
    char *filename;             /* name of the cache file,
                                   or NULL if no cache */
    char *tempfile;             /* name of the temporary file,
                                   or NULL if not caching */
    time_t ims;                 /* if-Modified-Since date of request,
                                   -1 if no header */
    time_t ius;                 /* if-Unmodified-Since date of request,
                                   -1 if no header */
    const char *im;             /* if-Match etag of request,
                                   NULL if no header */
    const char *inm;            /* if-None-Match etag of request,
                                   NULL if no header */
    BUFF *fp;                   /* the cache file descriptor if the file
                                   is cached and may be returned,
                                   or NULL if the file is not cached
                                   (or must be reloaded) */
    BUFF *origfp;               /* the old cache file descriptor if the file has
                                   been revalidated and is being rewritten to
                                   disk */
    time_t expire;              /* calculated expire date of cached entity */
    time_t lmod;                /* last-modified date of cached entity */
    time_t date;                /* the date the cached file was last touched */
    time_t req_time;            /* the time the request started */
    time_t resp_time;           /* the time the response was received */
    int version;                /* update count of the file */
    off_t len;                  /* content length */
    char *protocol;             /* Protocol, and major/minor number,
                                   e.g. HTTP/1.1 */
    int status;                 /* the status of the cached file */
    unsigned int written;       /* total *content* bytes written to cache */
    float cache_completion;     /* specific to this request */
    char *resp_line;            /* the whole status line
                                   (protocol, code + message) */
    table *req_hdrs;            /* the original request headers */
    table *hdrs;                /* the original HTTP response headers
                                   of the file */
    char *xcache;               /* the X-Cache header value
                                   to be sent to client */
d253 4
a256 4
struct per_thread_data {
    struct hostent hpbuf;
    u_long ipaddr;
    char *charpbuf[2];
d258 1
d265 1
a265 1
                      cache_req **cr);
d267 1
a267 1
                       const int is_HTTP1, int nocache);
d273 1
a273 1
                          const char *proxyhost, int proxyport);
d283 1
a283 1
                     int def_port);
d285 1
a285 1
                       const char *proxyhost, int proxyport);
d292 1
a292 1
                        enum proxyreqtype isenc);
d294 1
a294 1
                         char **passwordp, char **hostp, int *port);
d297 3
a299 3
long int ap_proxy_send_fb(BUFF *f, request_rec *r, cache_req *c, off_t len, int nowrite, int chunked, size_t recv_buffer_size);
void ap_proxy_write_headers(cache_req *c, const char *respline, table *t);
int ap_proxy_liststr(const char *list, const char *key, char **val);
d304 1
a304 1
int ap_proxyerror(request_rec *r, int statuscode, const char *message);
a314 27
time_t ap_proxy_current_age(cache_req *c, const time_t age_value);
BUFF *ap_proxy_open_cachefile(request_rec *r, char *filename);
BUFF *ap_proxy_create_cachefile(request_rec *r, char *filename);
void ap_proxy_clear_connection(pool *p, table *headers);
int ap_proxy_table_replace(table *base, table *overlay);
void ap_proxy_table_unmerge(pool *p, table *t, char *key);
int ap_proxy_read_response_line(BUFF *f, request_rec *r, char *buffer, int size, int *backasswards, int *major, int *minor);

/* WARNING - PRIVATE DEFINITION BELOW */

/* XXX: if you tweak this you should look at is_empty_table() and table_elts()
 * in ap_alloc.h
 *
 * NOTE: this private definition is a duplicate of the one in alloc.c
 * It's here for ap_proxy_table_replace() to avoid breaking binary compat
 */
struct table {
    /* This has to be first to promote backwards compatibility with
     * older modules which cast a table * to an array_header *...
     * they should use the table_elts() function for most of the
     * cases they do this for.
     */
    array_header a;
#ifdef MAKE_TABLE_PROFILE
    void *creator;
#endif
};
@


1.1.1.4
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
@


