head	1.19;
access;
symbols
	OPENBSD_5_5:1.18.0.20
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.16
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.14
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.12
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.10
	OPENBSD_5_0:1.18.0.8
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.10
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.8
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.5
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.5
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.4
	apache_1_3_27:1.1.1.4
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	apache_1_3_26:1.1.1.3
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	apache_1_3_2:1.1.1.2
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	apache:1.1.1
	apache_1_2_6:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.18;

1.18
date	2010.02.03.17.42.30;	author jasper;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.09.08.06.28;	author mbalmer;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.20.03.33.09;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.09.12.13.10;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.21.13.11.36;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.09.12.35.41;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.07.20.23.06;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.19.21.31.16;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.29.02.08.06;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.29.10.21.45;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.22.18.16;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.19.11.17.16;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.25.18.29.52;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.06.29.43;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.01.06.31;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	98.10.11.19.45.14;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.03.25.07.08.50;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.25.07.08.50;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.10.01.17.19.42;	author beck;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.07.19.21.28.57;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.07.19.48.13;	author henning;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.08.21.12.53.40;	author henning;	state Exp;
branches;
next	;


desc
@@


1.19
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/* Utility routines for Apache proxy */
#include "mod_proxy.h"
#include "http_main.h"
#include "ap_md5.h"
#include "multithread.h"
#include "http_log.h"
#include "util_uri.h"
#include "util_date.h"          /* get ap_checkmask() decl. */

static int proxy_match_ipaddr(struct dirconn_entry *This, request_rec *r);
static int proxy_match_domainname(struct dirconn_entry *This, request_rec *r);
static int proxy_match_hostname(struct dirconn_entry *This, request_rec *r);
static int proxy_match_word(struct dirconn_entry *This, request_rec *r);
static struct per_thread_data *get_per_thread_data(void);
/* already called in the knowledge that the characters are hex digits */
int ap_proxy_hex2c(const char *x)
{
    int i;
    int ch;

    ch = x[0];
    if (ap_isdigit(ch))
        i = ch - '0';
    else if (ap_isupper(ch))
        i = ch - ('A' - 10);
    else
        i = ch - ('a' - 10);
    i <<= 4;

    ch = x[1];
    if (ap_isdigit(ch))
        i += ch - '0';
    else if (ap_isupper(ch))
        i += ch - ('A' - 10);
    else
        i += ch - ('a' - 10);
    return i;
}

void ap_proxy_c2hex(int ch, char *x)
{
    int i;

    x[0] = '%';
    i = (ch & 0xF0) >> 4;
    if (i >= 10)
        x[1] = ('A' - 10) + i;
    else
        x[1] = '0' + i;

    i = ch & 0x0F;
    if (i >= 10)
        x[2] = ('A' - 10) + i;
    else
        x[2] = '0' + i;
}

/*
 * canonicalise a URL-encoded string
 */

/*
 * Convert a URL-encoded string to canonical form.
 * It decodes characters which need not be encoded,
 * and encodes those which must be encoded, and does not touch
 * those which must not be touched.
 */
char *ap_proxy_canonenc(pool *p, const char *x, int len, enum enctype t,
                             enum proxyreqtype isenc)
{
    int i, j, ch;
    char *y;
    const char *allowed;        /* characters which should not be encoded */
    const char *reserved;       /* characters which much not be en/de-coded */

/* N.B. in addition to :@@&=, this allows ';' in an http path
 * and '?' in an ftp path -- this may be revised
 *
 * Also, it makes a '+' character in a search string reserved, as
 * it may be form-encoded. (Although RFC 1738 doesn't allow this -
 * it only permits ; / ? : @@ = & as reserved chars.)
 */
    if (t == enc_path)
        allowed = "$-_.+!*'(),;:@@&=";
    else if (t == enc_search)
        allowed = "$-_.!*'(),;:@@&=";
    else if (t == enc_user)
        allowed = "$-_.+!*'(),;@@&=";
    else if (t == enc_fpath)
        allowed = "$-_.+!*'(),?:@@&=";
    else                        /* if (t == enc_parm) */
        allowed = "$-_.+!*'(),?/:@@&=";

    if (t == enc_path)
        reserved = "/";
    else if (t == enc_search)
        reserved = "+";
    else
        reserved = "";

    y = ap_palloc(p, 3 * len + 1);

    for (i = 0, j = 0; i < len; i++, j++) {
/* always handle '/' first */
        ch = x[i];
        if (strchr(reserved, ch)) {
            y[j] = ch;
            continue;
        }
/* decode it if not already done */
        if (isenc != NOT_PROXY && ch == '%') {
            if (!ap_isxdigit(x[i + 1]) || !ap_isxdigit(x[i + 2]))
                return NULL;
            ch = ap_proxy_hex2c(&x[i + 1]);
            i += 2;
            if (ch != 0 && strchr(reserved, ch)) {      /* keep it encoded */
                ap_proxy_c2hex(ch, &y[j]);
                j += 2;
                continue;
            }
        }
/* recode it, if necessary */
        if (!ap_isalnum(ch) && !strchr(allowed, ch)) {
            ap_proxy_c2hex(ch, &y[j]);
            j += 2;
        }
        else
            y[j] = ch;
    }
    y[j] = '\0';
    return y;
}

/*
 * Parses network-location.
 *    urlp           on input the URL; on output the path, after the leading /
 *    user           NULL if no user/password permitted
 *    password       holder for password
 *    host           holder for host
 *    port           port number; only set if one is supplied.
 *
 * Returns an error string.
 */
char *
     ap_proxy_canon_netloc(pool *p, char **const urlp, char **userp,
                                char **passwordp, char **hostp, int *port)
{
    int i;
    char *strp, *host, *url = *urlp;
    char *user = NULL, *password = NULL;
    char *t = NULL, *u = NULL, *v = NULL;

    if (url[0] != '/' || url[1] != '/')
        return "Malformed URL";
    host = url + 2;
    url = strchr(host, '/');
    if (url == NULL)
        url = "";
    else
        *(url++) = '\0';        /* skip seperating '/' */

    /* find _last_ '@@' since it might occur in user/password part */
    strp = strrchr(host, '@@');

    if (strp != NULL) {
        *strp = '\0';
        user = host;
        host = strp + 1;

/* find password */
        strp = strchr(user, ':');
        if (strp != NULL) {
            *strp = '\0';
            password = ap_proxy_canonenc(p, strp + 1, strlen(strp + 1), enc_user, STD_PROXY);
            if (password == NULL)
                return "Bad %-escape in URL (password)";
        }

        user = ap_proxy_canonenc(p, user, strlen(user), enc_user, STD_PROXY);
        if (user == NULL)
            return "Bad %-escape in URL (username)";
    }
    if (userp != NULL) {
        *userp = user;
    }
    if (passwordp != NULL) {
        *passwordp = password;
    }

    v = host;
    if (*host == '['){
	u = strrchr(host, ']');
	if (u){
	    host++;
	    *u = '\0';
	    v = u + 1;
	}
    }
    t = strrchr(v, ':');
    if (t){
	*t = '\0';
	strp = t + 1;
    }
    if (strp){
	for (i=0; strp[i] != '\0'; i++)
	    if (!ap_isdigit(strp[i]))
		break;

	/* if (i == 0) the no port was given; keep default */
	if (strp[i] != '\0') {
	    return "Bad port number in URL";
	}
        else if (i > 0) {
	    *port = atoi(strp);
	    if (*port > 65535)
		return "Port number in URL > 65535";
	}
    }
    ap_str_tolower(host);       /* DNS names are case-insensitive */
    if (*host == '\0')
        return "Missing host in URL";
/* check hostname syntax */
    for (i = 0; host[i] != '\0'; i++)
	if (!ap_isxdigit(host[i]) && host[i] != '.' && host[i] != ':')
	    break;
    /* must be an IP address */
    if (host[i] == '\0') {
	struct addrinfo hints, *res0;
	int gai;
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_flags = AI_NUMERICHOST;
	if (gai = getaddrinfo(host, NULL, &hints, &res0)) {
#if 0
	    return gai_strerror(gai);
#else
	    return "Bad IP address in URL";
#endif
	}
	freeaddrinfo(res0);
    }

/*    if (strchr(host,'.') == NULL && domain != NULL)
   host = pstrcat(p, host, domain, NULL);
 */
    *urlp = url;
    *hostp = host;

    return NULL;
}

static const char *const lwday[7] =
{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

/*
 * If the date is a valid RFC 850 date or asctime() date, then it
 * is converted to the RFC 1123 format, otherwise it is not modified.
 * This routine is not very fast at doing conversions, as it uses
 * sscanf and sprintf. However, if the date is already correctly
 * formatted, then it exits very quickly.
 */
const char *
     ap_proxy_date_canon(pool *p, const char *x)
{
    int wk, mday, year, hour, min, sec, mon;
    char *q, month[4], zone[4], week[4];

    q = strchr(x, ',');
    /* check for RFC 850 date */
    if (q != NULL && q - x > 3 && q[1] == ' ') {
        *q = '\0';
        for (wk = 0; wk < 7; wk++)
            if (strcmp(x, lwday[wk]) == 0)
                break;
        *q = ',';
        if (wk == 7)
            return x;           /* not a valid date */
        if (q[4] != '-' || q[8] != '-' || q[11] != ' ' || q[14] != ':' ||
            q[17] != ':' || strcmp(&q[20], " GMT") != 0)
            return x;
        if (sscanf(q + 2, "%u-%3s-%u %u:%u:%u %3s", &mday, month, &year,
                   &hour, &min, &sec, zone) != 7)
            return x;
        if (year < 70)
            year += 2000;
        else
            year += 1900;
    }
    else {
/* check for acstime() date */
        if (x[3] != ' ' || x[7] != ' ' || x[10] != ' ' || x[13] != ':' ||
            x[16] != ':' || x[19] != ' ' || x[24] != '\0')
            return x;
        if (sscanf(x, "%3s %3s %u %u:%u:%u %u", week, month, &mday, &hour,
                   &min, &sec, &year) != 7)
            return x;
        for (wk = 0; wk < 7; wk++)
            if (strcmp(week, ap_day_snames[wk]) == 0)
                break;
        if (wk == 7)
            return x;
    }

/* check date */
    for (mon = 0; mon < 12; mon++)
        if (strcmp(month, ap_month_snames[mon]) == 0)
            break;
    if (mon == 12)
        return x;

    q = ap_palloc(p, 30);
    ap_snprintf(q, 30, "%s, %.2d %s %d %.2d:%.2d:%.2d GMT", ap_day_snames[wk], mday,
                ap_month_snames[mon], year, hour, min, sec);
    return q;
}


/*
 * Reads headers from a buffer and returns an array of headers.
 * Returns NULL on file error
 * This routine tries to deal with too long lines and continuation lines.
 *
 * Note: Currently the headers are passed through unmerged. This has to be
 * done so that headers which react badly to merging (such as Set-Cookie
 * headers, which contain commas within the date field) do not get stuffed
 * up.
 */
table *ap_proxy_read_headers(request_rec *r, char *buffer, int size, BUFF *f)
{
    table *resp_hdrs;
    int len;
    char *value, *end;
    char field[MAX_STRING_LEN];

    resp_hdrs = ap_make_table(r->pool, 20);

    /*
     * Read header lines until we get the empty separator line, a read error,
     * the connection closes (EOF), or we timeout.
     */
    while ((len = ap_getline(buffer, size, f, 1)) > 0) {

        if (!(value = strchr(buffer, ':'))) {   /* Find the colon separator */

            /*
             * Buggy MS IIS servers sometimes return invalid headers (an
             * extra "HTTP/1.0 200, OK" line sprinkled in between the usual
             * MIME headers). Try to deal with it in a sensible way, but log
             * the fact. XXX: The mask check is buggy if we ever see an
             * HTTP/1.10
             */

            if (!ap_checkmask(buffer, "HTTP/#.# ###*")) {
                /* Nope, it wasn't even an extra HTTP header. Give up. */
                return NULL;
            }

            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_NOERRNO, r->server,
                         "proxy: Ignoring duplicate HTTP status line "
                         "returned by buggy server %s (%s)", r->uri, r->method);
            continue;
        }

        *value = '\0';
        ++value;
        /*
         * XXX: RFC2068 defines only SP and HT as whitespace, this test is
         * wrong... and so are many others probably.
         */
        while (ap_isspace(*value))
            ++value;            /* Skip to start of value   */

        /* should strip trailing whitespace as well */
        for (end = &value[strlen(value) - 1]; end > value && ap_isspace(*end); --end)
            *end = '\0';

        /* make sure we add so as not to destroy duplicated headers */
        ap_table_add(resp_hdrs, buffer, value);

        /* the header was too long; at the least we should skip extra data */
        if (len >= size - 1) {
            while ((len = ap_getline(field, MAX_STRING_LEN, f, 1))
                   >= MAX_STRING_LEN - 1) {
                /* soak up the extra data */
            }
            if (len == 0)       /* time to exit the larger loop as well */
                break;
        }
    }
    return resp_hdrs;
}

/* read data from (socket BUFF*) f, write it to:
 * - c->fp, if it is open
 * - r->connection->client, if nowrite == 0
 */

long int ap_proxy_send_fb(BUFF *f, request_rec *r, cache_req *c, off_t len, int nowrite, int chunked, size_t recv_buffer_size)
{
    int ok, end_of_chunk;
    char *buf;
    size_t buf_size;
    long remaining = 0;
    long total_bytes_rcvd;
    register int n = 0, o, w;
    conn_rec *con = r->connection;
    int alternate_timeouts = 1; /* 1 if we alternate between soft & hard
                                 * timeouts */

    /* allocate a buffer to store the bytes in */
    /*
     * make sure it is at least IOBUFSIZE, as recv_buffer_size may be zero
     * for system default
     */
    buf_size = MAX(recv_buffer_size, IOBUFSIZE);
    buf = ap_palloc(r->pool, buf_size);

    total_bytes_rcvd = 0;
    if (c != NULL)
        c->written = 0;

    /*
     * Since we are reading from one buffer and writing to another, it is
     * unsafe to do a soft_timeout here, at least until the proxy has its own
     * timeout handler which can set both buffers to EOUT.
     */

    ap_kill_timeout(r);

    /*
     * CHECKME! Since hard_timeout won't work in unix on sends with partial
     * cache completion, we have to alternate between hard_timeout for reads,
     * and soft_timeout for send.  This is because we need to get a return
     * from ap_bwrite to be able to continue caching. BUT, if we *can't*
     * continue anyway, just use hard_timeout. (Also, if no cache file is
     * written, use hard timeouts)
     */

    if (c == NULL || c->len <= 0 || c->cache_completion == 1.0) {
        ap_hard_timeout("proxy send body", r);
        alternate_timeouts = 0;
    }

    /*
     * Loop and ap_bread() while we can successfully read and write, or
     * (after the client aborted) while we can successfully read and finish
     * the configured cache_completion.
     */
    for (end_of_chunk = ok = 1; ok;) {
        if (alternate_timeouts)
            ap_hard_timeout("proxy recv body from upstream server", r);


        /* read a chunked block */
        if (chunked) {
            long chunk_start = 0;
            n = 0;

            /* start of a new chunk */
            if (end_of_chunk) {
                end_of_chunk = 0;
                /* get the chunk size from the stream */
                chunk_start = ap_getline(buf, buf_size, f, 0);
                if ((chunk_start <= 0) || ((size_t)chunk_start + 1 >= buf_size) || !ap_isxdigit(*buf)) {
                    n = -1;
                }
                /* parse the chunk size */
                else {
                    remaining = ap_get_chunk_size(buf);
                    if (remaining == 0) { /* Last chunk indicated, get footers */
                        /* as we are a proxy, we discard the footers, as the headers
                         * have already been sent at this point.
                         */
                        if (NULL == ap_proxy_read_headers(r, buf, buf_size, f)) {
                            n = -1;
                        }
                    }
                    else if (remaining < 0) {
                        n = -1;
                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                                      "proxy: remote protocol error, invalid chunk size");

                    }
                }
            }

            /* read the chunk */
            if (remaining > 0) {
	    	n = ap_bread(f, buf, (int) MIN(buf_size, remaining));
                if (n > -1) {
                    remaining -= n;
                    end_of_chunk = (remaining == 0);
                }
            }

            /* soak up trailing CRLF */
            if (end_of_chunk) {
                int ch; /* int because it may hold an EOF */
                /*
                 * For EBCDIC, the proxy has configured the BUFF layer to
                 * transparently pass the ascii characters thru (also writing
                 * an ASCII copy to the cache, where appropriate).
                 * Therefore, we see here an ASCII-CRLF (\015\012),
                 * not an EBCDIC-CRLF (\r\n).
                 */
                if ((ch = ap_bgetc(f)) == EOF) {
                    /* Protocol error: EOF detected within chunk */
                    n = -1;
                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                                  "proxy: remote protocol error, eof while reading chunked from proxy");
                }
                else
                {
                    if (ch == '\015') { /* _ASCII_ CR */
                        ch = ap_bgetc(f);
                    }
                    if (ch != '\012') {
                        n = -1;
                    }
                }
            }
        }

        /* otherwise read block normally */
        else {
            if (-1 == len) {
                n = ap_bread(f, buf, buf_size);
            }
            else {
                n = ap_bread(f, buf, (int) MIN(buf_size,
                                               (len - total_bytes_rcvd)));
            }
        }


        if (alternate_timeouts)
            ap_kill_timeout(r);
        else
            ap_reset_timeout(r);

        if (n == -1) {          /* input error */
            if (c != NULL) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                              "proxy: error reading from %s", c->url);
                c = ap_proxy_cache_error(c);
            }
            break;
        }
        if (n == 0)
            break;              /* EOF */
        o = 0;
        total_bytes_rcvd += n;

        /* if we've received everything... */
        /*
         * in the case of slow frontends and expensive backends, we want to
         * avoid leaving a backend connection hanging while the frontend
         * takes it's time to absorb the bytes. so: if we just read the last
         * block, we close the backend connection now instead of later - it's
         * no longer needed.
         */
        if (total_bytes_rcvd == len) {
            ap_bclose(f);
            f = NULL;
        }

        /* Write to cache first. */
        /*
         * @@@@@@ XXX FIXME: Assuming that writing the cache file won't time
         * out?!!?
         */
        if (c != NULL && c->fp != NULL) {
            if (ap_bwrite(c->fp, &buf[0], n) != n) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                              "proxy: error writing to %s", c->tempfile);
                c = ap_proxy_cache_error(c);
            }
            else {
                c->written += n;
            }
        }

        /* Write the block to the client, detect aborted transfers */
        while (!nowrite && !con->aborted && n > 0) {
            if (alternate_timeouts)
                ap_soft_timeout("proxy send body", r);

            w = ap_bwrite(con->client, &buf[o], n);

            if (alternate_timeouts)
                ap_kill_timeout(r);
            else
                ap_reset_timeout(r);

            if (w <= 0) {
                if (c != NULL) {
                    /*
                     * when a send failure occurs, we need to decide whether
                     * to continue loading and caching the document, or to
                     * abort the whole thing
                     */
                    ok = (c->len > 0) &&
                        (c->cache_completion > 0) &&
                        (c->len * c->cache_completion < total_bytes_rcvd);

                    if (!ok) {
                        if (c->fp != NULL) {
                            ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR));
                            c->fp = NULL;
                        }
                        unlink(c->tempfile);
                        c = NULL;
                    }
                }
                con->aborted = 1;
                break;
            }
            n -= w;
            o += w;
        }                       /* while client alive and more data to send */

        /* if we've received everything, leave now */
        if (total_bytes_rcvd == len)
            break;

    }                           /* loop and ap_bread while "ok" */

    /* if the backend connection is still open, close it */
    if (f) {
        ap_bclose(f);
    }

    if (!con->aborted) {
        ap_bflush(con->client);
    }

    ap_kill_timeout(r);

    r->bytes_sent += total_bytes_rcvd;

    return total_bytes_rcvd;
}

/*
 * Writes response line and headers to the cache file.
 *
 * If respline is NULL, no response line will be written.
 */
void ap_proxy_write_headers(cache_req *c, const char *respline, table *t)
{
    /* write status line */
    if (respline && c->fp != NULL &&
        ap_bvputs(c->fp, respline, CRLF, NULL) == -1) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                      "proxy: error writing status line to %s", c->tempfile);
        c = ap_proxy_cache_error(c);
        return;
    }

    /* write response headers to the cache file */
    ap_table_do(ap_proxy_send_hdr_line, c, t, NULL);

    /* write terminating CRLF */
    if (c->fp != NULL && ap_bputs(CRLF, c->fp) == -1) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                      "proxy: error writing CRLF to %s", c->tempfile);
        c = ap_proxy_cache_error(c);
    }
}


/*
 * list is a comma-separated list of case-insensitive tokens, with
 * optional whitespace around the tokens.
 * The return returns 1 if the token val is found in the list, or 0
 * otherwise.
 */
int ap_proxy_liststr(const char *list, const char *key, char **val)
{
    int len, i;
    const char *p;
    char valbuf[HUGE_STRING_LEN];
    valbuf[sizeof(valbuf) - 1] = 0;     /* safety terminating zero */

    len = strlen(key);

    while (list != NULL) {
        p = strchr(list, ',');
        if (p != NULL) {
            i = p - list;
            do
                p++;
            while (ap_isspace(*p));
        }
        else
            i = strlen(list);

        while (i > 0 && ap_isspace(list[i - 1]))
            i--;
        if (i == len && strncasecmp(list, key, len) == 0) {
            if (val) {
                p = strchr(list, ',');
                while (ap_isspace(*list)) {
                    list++;
                }
                if ('=' == list[0])
                    list++;
                while (ap_isspace(*list)) {
                    list++;
                }
                strncpy(valbuf, list, MIN(p - list, sizeof(valbuf) - 1));
                *val = valbuf;
            }
            return 1;
        }
        list = p;
    }
    return 0;
}

void ap_proxy_hash(const char *it, char *val, int ndepth, int nlength)
{
    AP_MD5_CTX context;
    unsigned char digest[16];
    char tmp[22];
    int i, k, d;
    unsigned int x;
    static const char enc_table[64] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_@@";

    ap_MD5Init(&context);
    ap_MD5Update(&context, (const unsigned char *)it, strlen(it));
    ap_MD5Final(digest, &context);

/* encode 128 bits as 22 characters, using a modified uuencoding */
/* the encoding is 3 bytes -> 4 characters
 * i.e. 128 bits is 5 x 3 bytes + 1 byte -> 5 * 4 characters + 2 characters
 */
    for (i = 0, k = 0; i < 15; i += 3) {
        x = (digest[i] << 16) | (digest[i + 1] << 8) | digest[i + 2];
        tmp[k++] = enc_table[x >> 18];
        tmp[k++] = enc_table[(x >> 12) & 0x3f];
        tmp[k++] = enc_table[(x >> 6) & 0x3f];
        tmp[k++] = enc_table[x & 0x3f];
    }
/* one byte left */
    x = digest[15];
    tmp[k++] = enc_table[x >> 2];       /* use up 6 bits */
    tmp[k++] = enc_table[(x << 4) & 0x3f];
    /* now split into directory levels */

    for (i = k = d = 0; d < ndepth; ++d) {
        memcpy(&val[i], &tmp[k], nlength);
        k += nlength;
        val[i + nlength] = '/';
        i += nlength + 1;
    }
    memcpy(&val[i], &tmp[k], 22 - k);
    val[i + 22 - k] = '\0';
}

/*
 * Converts 16 hex digits to a time integer
 */
int ap_proxy_hex2sec(const char *x)
{
    int i, ch;
    unsigned int j;

    for (i = 0, j = 0; i < 16; i++) {
        ch = x[i];
        j <<= 4;
        if (ap_isdigit(ch))
            j |= ch - '0';
        else if (ap_isupper(ch))
            j |= ch - ('A' - 10);
        else
            j |= ch - ('a' - 10);
    }
/* no longer necessary, as the source hex is 8-byte int */
/*    if (j == 0xffffffff)*/
    /*      return -1;*//* so that it works with 8-byte ints */
/*    else */
    return j;
}

/*
 * Converts a time integer to 16 hex digits
 */
int ap_proxy_sec2hex(int t, char *y, int len)
{
    int i, ch;
    unsigned int j = t;

    if (-1 == t) {
        if (strlcpy(y, "FFFFFFFFFFFFFFFF", len) > len)
		return (-1);
        return (0);
    }

    if (len < 17)
	return (-1);

    for (i = 15; i >= 0; i--) {
        ch = j & 0xF;
        j >>= 4;
        if (ch >= 10)
            y[i] = ch + ('A' - 10);
        else
            y[i] = ch + '0';
    }
    y[16] = '\0';
    return (0);
}


cache_req *ap_proxy_cache_error(cache_req *c)
{
    if (c != NULL) {
        if (c->fp != NULL) {
            ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR));
            c->fp = NULL;
        }
        if (c->origfp != NULL) {
            ap_pclosef(c->req->pool, ap_bfileno(c->origfp, B_WR));
            c->origfp = NULL;
        }
        if (c->tempfile)
            unlink(c->tempfile);
    }
    return NULL;
}

int ap_proxyerror(request_rec *r, int statuscode, const char *message)
{
    ap_table_setn(r->notes, "error-notes",
                  ap_pstrcat(r->pool,
                             "The proxy server could not handle the request "
                           "<EM><A HREF=\"", ap_escape_uri(r->pool, r->uri),
                             "\">", ap_escape_html(r->pool, r->method),
                             "&nbsp;",
                          ap_escape_html(r->pool, r->uri), "</A></EM>.<P>\n"
                             "Reason: <STRONG>",
                             ap_escape_html(r->pool, message),
                             "</STRONG>", NULL));

    /* Allow "error-notes" string to be printed by ap_send_error_response() */
    ap_table_setn(r->notes, "verbose-error-to", ap_pstrdup(r->pool, "*"));

    r->status_line = ap_psprintf(r->pool, "%3.3u Proxy Error", statuscode);
    return statuscode;
}

/*
 * This routine returns its own error message
 */
const char *
     ap_proxy_host2addr(const char *host, struct hostent * reqhp)
{
    int i;
    struct hostent *hp;
    struct per_thread_data *ptd = get_per_thread_data();

    for (i = 0; host[i] != '\0'; i++)
        if (!ap_isdigit(host[i]) && host[i] != '.')
            break;

    if (host[i] != '\0') {
        hp = gethostbyname(host);
        if (hp == NULL)
            return "Host not found";
    }
    else {
        ptd->ipaddr = ap_inet_addr(host);
        hp = gethostbyaddr((char *)&ptd->ipaddr, sizeof(ptd->ipaddr), AF_INET);
        if (hp == NULL) {
            memset(&ptd->hpbuf, 0, sizeof(ptd->hpbuf));
            ptd->hpbuf.h_name = 0;
            ptd->hpbuf.h_addrtype = AF_INET;
            ptd->hpbuf.h_length = sizeof(ptd->ipaddr);
            ptd->hpbuf.h_addr_list = ptd->charpbuf;
            ptd->hpbuf.h_addr_list[0] = (char *)&ptd->ipaddr;
            ptd->hpbuf.h_addr_list[1] = 0;
            hp = &ptd->hpbuf;
        }
    }
    *reqhp = *hp;
    return NULL;
}

static const char *
     proxy_get_host_of_request(request_rec *r)
{
    char *url, *user = NULL, *password = NULL, *err, *host;
    int port = -1;

    if (r->hostname != NULL)
        return r->hostname;

    /* Set url to the first char after "scheme://" */
    if ((url = strchr(r->uri, ':')) == NULL
        || url[1] != '/' || url[2] != '/')
        return NULL;

    url = ap_pstrdup(r->pool, &url[1]); /* make it point to "//", which is
                                         * what proxy_canon_netloc expects */

    err = ap_proxy_canon_netloc(r->pool, &url, &user, &password, &host, &port);

    if (err != NULL)
        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, r,
                      "%s", err);

    r->hostname = host;

    return host;                /* ought to return the port, too */
}

/* Return TRUE if addr represents an IP address (or an IP network address) */
int ap_proxy_is_ipaddr(struct dirconn_entry *This, pool *p)
{
    const char *addr = This->name;
    long ip_addr[4];
    int i, quads;
    long bits;

    /* if the address is given with an explicit netmask, use that */
    /* Due to a deficiency in ap_inet_addr(), it is impossible to parse */
    /* "partial" addresses (with less than 4 quads) correctly, i.e.  */
    /* 192.168.123 is parsed as 192.168.0.123, which is not what I want. */
    /* I therefore have to parse the IP address manually: */
    /*
     * if (proxy_readmask(This->name, &This->addr.s_addr, &This->mask.s_addr)
     * == 0)
     */
    /* addr and mask were set by proxy_readmask() */
    /* return 1; */

    /* Parse IP addr manually, optionally allowing */
    /* abbreviated net addresses like 192.168. */

    /* Iterate over up to 4 (dotted) quads. */
    for (quads = 0; quads < 4 && *addr != '\0'; ++quads) {
        char *tmp;

        if (*addr == '/' && quads > 0)  /* netmask starts here. */
            break;

        if (!ap_isdigit(*addr))
            return 0;           /* no digit at start of quad */

        ip_addr[quads] = ap_strtol(addr, &tmp, 0);

        if (tmp == addr)        /* expected a digit, found something else */
            return 0;

        if (ip_addr[quads] < 0 || ip_addr[quads] > 255) {
            /* invalid octet */
            return 0;
        }

        addr = tmp;

        if (*addr == '.' && quads != 3)
            ++addr;             /* after the 4th quad, a dot would be illegal */
    }

    for (This->addr.s_addr = 0, i = 0; i < quads; ++i)
        This->addr.s_addr |= htonl(ip_addr[i] << (24 - 8 * i));

    if (addr[0] == '/' && ap_isdigit(addr[1])) {        /* net mask follows: */
        char *tmp;

        ++addr;

        bits = ap_strtol(addr, &tmp, 0);

        if (tmp == addr)        /* expected a digit, found something else */
            return 0;

        addr = tmp;

        if (bits < 0 || bits > 32)      /* netmask must be between 0 and 32 */
            return 0;

    }
    else {
        /* Determine (i.e., "guess") netmask by counting the */
        /* number of trailing .0's; reduce #quads appropriately */
        /* (so that 192.168.0.0 is equivalent to 192.168.)        */
        while (quads > 0 && ip_addr[quads - 1] == 0)
            --quads;

        /*
         * "IP Address should be given in dotted-quad form, optionally
         * followed by a netmask (e.g., 192.168.111.0/24)";
         */
        if (quads < 1)
            return 0;

        /* every zero-byte counts as 8 zero-bits */
        bits = 8 * quads;

        if (bits != 32)         /* no warning for fully qualified IP address */
            fprintf(stderr, "Warning: NetMask not supplied with IP-Addr; guessing: %s/%ld\n",
                    inet_ntoa(This->addr), bits);
    }

    This->mask.s_addr = htonl(INADDR_NONE << (32 - bits));

    if (*addr == '\0' && (This->addr.s_addr & ~This->mask.s_addr) != 0) {
        fprintf(stderr, "Warning: NetMask and IP-Addr disagree in %s/%ld\n",
                inet_ntoa(This->addr), bits);
        This->addr.s_addr &= This->mask.s_addr;
        fprintf(stderr, "         Set to %s/%ld\n",
                inet_ntoa(This->addr), bits);
    }

    if (*addr == '\0') {
        This->matcher = proxy_match_ipaddr;
        return 1;
    }
    else
        return (*addr == '\0'); /* okay iff we've parsed the whole string */
}

/* Return TRUE if addr represents an IP address (or an IP network address) */
static int proxy_match_ipaddr(struct dirconn_entry *This, request_rec *r)
{
    int i;
    int ip_addr[4];
    struct in_addr addr;
    struct in_addr *ip_list;
    char **ip_listptr;
    const char *found;
    const char *host = proxy_get_host_of_request(r);

    if (host == NULL)           /* oops! */
        return 0;

    memset(&addr, '\0', sizeof addr);
    memset(ip_addr, '\0', sizeof ip_addr);

    if (4 == sscanf(host, "%d.%d.%d.%d", &ip_addr[0], &ip_addr[1], &ip_addr[2], &ip_addr[3])) {
        for (addr.s_addr = 0, i = 0; i < 4; ++i)
            addr.s_addr |= htonl(ip_addr[i] << (24 - 8 * i));

        if (This->addr.s_addr == (addr.s_addr & This->mask.s_addr)) {
#if DEBUGGING
            fprintf(stderr, "1)IP-Match: %s[%s] <-> ", host, inet_ntoa(addr));
            fprintf(stderr, "%s/", inet_ntoa(This->addr));
            fprintf(stderr, "%s\n", inet_ntoa(This->mask));
#endif
            return 1;
        }
#if DEBUGGING
        else {
            fprintf(stderr, "1)IP-NoMatch: %s[%s] <-> ", host, inet_ntoa(addr));
            fprintf(stderr, "%s/", inet_ntoa(This->addr));
            fprintf(stderr, "%s\n", inet_ntoa(This->mask));
        }
#endif
    }
    else {
        struct hostent the_host;

        memset(&the_host, '\0', sizeof the_host);
        found = ap_proxy_host2addr(host, &the_host);

        if (found != NULL) {
#if DEBUGGING
            fprintf(stderr, "2)IP-NoMatch: hostname=%s msg=%s\n", host, found);
#endif
            return 0;
        }

        if (the_host.h_name != NULL)
            found = the_host.h_name;
        else
            found = host;

        /* Try to deal with multiple IP addr's for a host */
        for (ip_listptr = the_host.h_addr_list; *ip_listptr; ++ip_listptr) {
            ip_list = (struct in_addr *)*ip_listptr;
            if (This->addr.s_addr == (ip_list->s_addr & This->mask.s_addr)) {
#if DEBUGGING
                fprintf(stderr, "3)IP-Match: %s[%s] <-> ", found, inet_ntoa(*ip_list));
                fprintf(stderr, "%s/", inet_ntoa(This->addr));
                fprintf(stderr, "%s\n", inet_ntoa(This->mask));
#endif
                return 1;
            }
#if DEBUGGING
            else {
                fprintf(stderr, "3)IP-NoMatch: %s[%s] <-> ", found, inet_ntoa(*ip_list));
                fprintf(stderr, "%s/", inet_ntoa(This->addr));
                fprintf(stderr, "%s\n", inet_ntoa(This->mask));
            }
#endif
        }
    }

    return 0;
}

/* Return TRUE if addr represents a domain name */
int ap_proxy_is_domainname(struct dirconn_entry *This, pool *p)
{
    char *addr = This->name;
    int i;

    /* Domain name must start with a '.' */
    if (addr[0] != '.')
        return 0;

    /* rfc1035 says DNS names must consist of "[-a-zA-Z0-9]" and '.' */
    for (i = 0; ap_isalnum(addr[i]) || addr[i] == '-' || addr[i] == '.'; ++i)
        continue;

    if (addr[i] != '\0')
        return 0;

    /* Strip trailing dots */
    for (i = strlen(addr) - 1; i > 0 && addr[i] == '.'; --i)
        addr[i] = '\0';

    This->matcher = proxy_match_domainname;
    return 1;
}

/* Return TRUE if host "host" is in domain "domain" */
static int proxy_match_domainname(struct dirconn_entry *This, request_rec *r)
{
    const char *host = proxy_get_host_of_request(r);
    int d_len = strlen(This->name), h_len;

    if (host == NULL)           /* some error was logged already */
        return 0;

    h_len = strlen(host);

    /* @@@@@@ do this within the setup? */
    /* Ignore trailing dots in domain comparison: */
    while (d_len > 0 && This->name[d_len - 1] == '.')
        --d_len;
    while (h_len > 0 && host[h_len - 1] == '.')
        --h_len;
    return h_len > d_len
        && strncasecmp(&host[h_len - d_len], This->name, d_len) == 0;
}

/* Return TRUE if addr represents a host name */
int ap_proxy_is_hostname(struct dirconn_entry *This, pool *p)
{
    struct hostent host;
    char *addr = This->name;
    int i;

    /* Host names must not start with a '.' */
    if (addr[0] == '.')
        return 0;

    /* rfc1035 says DNS names must consist of "[-a-zA-Z0-9]" and '.' */
    for (i = 0; ap_isalnum(addr[i]) || addr[i] == '-' || addr[i] == '.'; ++i);

    if (addr[i] != '\0' || ap_proxy_host2addr(addr, &host) != NULL)
        return 0;

    This->hostentry = ap_pduphostent(p, &host);

    /* Strip trailing dots */
    for (i = strlen(addr) - 1; i > 0 && addr[i] == '.'; --i)
        addr[i] = '\0';

    This->matcher = proxy_match_hostname;
    return 1;
}

/* Return TRUE if host "host" is equal to host2 "host2" */
static int proxy_match_hostname(struct dirconn_entry *This, request_rec *r)
{
    char *host = This->name;
    const char *host2 = proxy_get_host_of_request(r);
    int h2_len;
    int h1_len;

    if (host == NULL || host2 == NULL)
        return 0;               /* oops! */

    h2_len = strlen(host2);
    h1_len = strlen(host);

    /* Ignore trailing dots in host2 comparison: */
    while (h2_len > 0 && host2[h2_len - 1] == '.')
        --h2_len;
    while (h1_len > 0 && host[h1_len - 1] == '.')
        --h1_len;
    return h1_len == h2_len
        && strncasecmp(host, host2, h1_len) == 0;
}

/* Return TRUE if addr is to be matched as a word */
int ap_proxy_is_word(struct dirconn_entry *This, pool *p)
{
    This->matcher = proxy_match_word;
    return 1;
}

/* Return TRUE if string "str2" occurs literally in "str1" */
static int proxy_match_word(struct dirconn_entry *This, request_rec *r)
{
    const char *host = proxy_get_host_of_request(r);
    return host != NULL && strstr(host, This->name) != NULL;
}

int ap_proxy_doconnect(int sock, struct sockaddr *addr, request_rec *r)
{
    int i;
    int salen;
    char hbuf[NI_MAXHOST], pbuf[NI_MAXSERV];
#ifdef NI_WITHSCOPEID
    const int niflags = NI_NUMERICHOST | NI_NUMERICSERV | NI_WITHSCOPEID;
#else
    const int niflags = NI_NUMERICHOST | NI_NUMERICSERV;
#endif

    ap_hard_timeout("proxy connect", r);
#ifdef HAVE_SOCKADDR_LEN
    salen = addr->sa_len;
#else
    switch (addr->sa_family) {
    case AF_INET6:
	salen = sizeof(struct sockaddr_in6);
	break;
    default:
	salen = sizeof(struct sockaddr_in);
	break;
    }
#endif
    do {
	i = connect(sock,  addr, salen);
    } while (i == -1 && errno == EINTR);
    if (i == -1) {
	if (getnameinfo(addr, salen, hbuf, sizeof(hbuf), pbuf, sizeof(pbuf),
		niflags) != 0) {
	    strcpy(hbuf, "?");
	    strcpy(pbuf, "?");
	}
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                      "proxy connect to %s port %s failed", hbuf, pbuf);
    }
    ap_kill_timeout(r);

    return i;
}

/* This function is called by ap_table_do() for all header lines
 * (from proxy_http.c and proxy_ftp.c)
 * It is passed a cache_req struct pointer and a MIME field and value pair
 */
int ap_proxy_send_hdr_line(void *p, const char *key, const char *value)
{
    cache_req *c = (cache_req *)p;

    if (key == NULL || value == NULL || value[0] == '\0')
        return 1;
    if (c->fp != NULL &&
        ap_bvputs(c->fp, key, ": ", value, CRLF, NULL) == -1) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                      "proxy: error writing header to %s", c->tempfile);
        c = ap_proxy_cache_error(c);
        return 0;               /* no need to continue, it failed already */
    }
    return 1;                   /* tell ap_table_do() to continue calling us
                                 * for more headers */
}

/* send a text line to one or two BUFF's; return line length */
unsigned ap_proxy_bputs2(const char *data, BUFF *client, cache_req *cache)
{
    unsigned len = ap_bputs(data, client);
    if (cache != NULL && cache->fp != NULL)
        ap_bputs(data, cache->fp);
    return len;
}

/* do a HTTP/1.1 age calculation */
time_t ap_proxy_current_age(cache_req *c, const time_t age_value)
{
    time_t apparent_age, corrected_received_age, response_delay, corrected_initial_age,
           resident_time, current_age;

    /* Perform an HTTP/1.1 age calculation. (RFC2616 13.2.3) */

    apparent_age = MAX(0, c->resp_time - c->date);
    corrected_received_age = MAX(apparent_age, age_value);
    response_delay = c->resp_time - c->req_time;
    corrected_initial_age = corrected_received_age + response_delay;
    resident_time = time(NULL) - c->resp_time;
    current_age = corrected_initial_age + resident_time;

    return (current_age);
}

/* open a cache file and return a pointer to a BUFF */
BUFF *ap_proxy_open_cachefile(request_rec *r, char *filename)
{
    BUFF *cachefp = NULL;
    int cfd;

    if (filename != NULL) {
        cfd = open(filename, O_RDWR | O_BINARY);
        if (cfd != -1) {
            ap_note_cleanups_for_fd(r->pool, cfd);
            cachefp = ap_bcreate(r->pool, B_RD | B_WR);
            ap_bpushfd(cachefp, cfd, cfd);
        }
        else if (errno != ENOENT)
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                          "proxy: error opening cache file %s",
                          filename);
        else
            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "File %s not found", filename);

    }
    return cachefp;
}

/* create a cache file and return a pointer to a BUFF */
BUFF *ap_proxy_create_cachefile(request_rec *r, char *filename)
{
    BUFF *cachefp = NULL;
    int cfd;

    if (filename != NULL) {
        cfd = open(filename, O_WRONLY | O_CREAT | O_EXCL | O_BINARY, 0622);
        if (cfd != -1) {
            ap_note_cleanups_for_fd(r->pool, cfd);
            cachefp = ap_bcreate(r->pool, B_WR);
            ap_bpushfd(cachefp, -1, cfd);
        }
        else if (errno != ENOENT)
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                          "proxy: error creating cache file %s",
                          filename);
    }
    return cachefp;
}

/* Clear all connection-based headers from headers table */
void ap_proxy_clear_connection(pool *p, table *headers)
{
    const char *name;
    char *next = ap_pstrdup(p, ap_table_get(headers, "Connection"));

    /* Some proxies (Squid, ICS) use the non-standard "Proxy-Connection" header. */
    ap_table_unset(headers, "Proxy-Connection");

    if (next != NULL) {
        while (*next) {
            name = next;
            while (*next && !ap_isspace(*next) && (*next != ','))
                ++next;
            while (ap_isspace(*next) || (*next == ',')) {
                *next = '\0';
                ++next;
            }
            ap_table_unset(headers, name);
        }
        ap_table_unset(headers, "Connection");
    }

    /* unset hop-by-hop headers defined in RFC2616 13.5.1 */
    ap_table_unset(headers,"Keep-Alive");
    /*
     * XXX: @@@@@@ FIXME: "Proxy-Authenticate" should IMO *not* be stripped
     * because in a chain of proxies some "front" proxy might need
     * proxy authentication, while a "back-end" proxy which needs none can
     * simply pass the "Proxy-Authenticate" back to the client, and pass
     * the client's "Proxy-Authorization" to the front-end proxy.
     * (See the note in proxy_http.c for the "Proxy-Authorization" case.)
     *
     *   MnKr 04/2002
     */
    ap_table_unset(headers,"Proxy-Authenticate");
    ap_table_unset(headers,"TE");
    ap_table_unset(headers,"Trailer");
    /* it is safe to just chop the transfer-encoding header
     * here, because proxy doesn't support any other encodings
     * to the backend other than chunked.
     */
    ap_table_unset(headers,"Transfer-Encoding");
    ap_table_unset(headers,"Upgrade");

}

/* overlay one table on another
 * keys in base will be replaced by keys in overlay
 *
 * Note: this has to be done in a special way, due
 * to some nastiness when it comes to having multiple
 * headers in the overlay table. First, we remove all
 * the headers in the base table that are found in the
 * overlay table, then we simply concatenate the
 * tables together.
 *
 * The base and overlay tables need not be in the same
 * pool (and probably won't be).
 *
 * If the base table is changed in any way through
 * being overlayed with the overlay table, this
 * function returns a 1.
 */
int ap_proxy_table_replace(table *base, table *overlay)
{
    table_entry *elts = (table_entry *)overlay->a.elts;
    int i, q = 0;
    const char *val;

    /* remove overlay's keys from base */
    for (i = 0; i < overlay->a.nelts; ++i) {
        val = ap_table_get(base, elts[i].key);
        if (!val || strcmp(val, elts[i].val)) {
            q = 1;
        }
        if (val) {
            ap_table_unset(base, elts[i].key);
        }
    }

    /* add overlay to base */
    for (i = 0; i < overlay->a.nelts; ++i) {
        ap_table_add(base, elts[i].key, elts[i].val);
    }

    return q;
}

/* read the response line
 * This function reads a single line of response from the server,
 * and returns a status code.
 * It also populates the request_rec with the resultant status, and
 * returns backasswards status (HTTP/0.9).
 */
int ap_proxy_read_response_line(BUFF *f, request_rec *r, char *buffer, int size, int *backasswards, int *major, int *minor) {

    long len;

    len = ap_getline(buffer, size-1, f, 0);
    if (len == -1) {
        ap_bclose(f);
        ap_kill_timeout(r);
        return ap_proxyerror(r, HTTP_BAD_GATEWAY,
                             "Error reading from remote server");
    }
    else if (len == 0) {
        ap_bclose(f);
        ap_kill_timeout(r);
        return ap_proxyerror(r, HTTP_BAD_GATEWAY,
                             "Document contains no data");
    }

    /*
     * Is it an HTTP/1 response? Do some sanity checks on the response. (This
     * is buggy if we ever see an HTTP/1.10)
     */
    if (ap_checkmask(buffer, "HTTP/#.# ###*")) {

        if (2 != sscanf(buffer, "HTTP/%u.%u", major, minor)) {
            /* if no response, default to HTTP/1.1 - is this correct? */
            *major = 1;
            *minor = 1;
        }

        /* If not an HTTP/1 message */
        if (*major < 1) {
            ap_bclose(f);
            ap_kill_timeout(r);
            return HTTP_BAD_GATEWAY;
        }
        *backasswards = 0;

        /* there need not be a reason phrase in the response,
	 * and ap_getline() already deleted trailing whitespace.
	 * But RFC2616 requires a SP after the Status-Code. Add one:
	 */
	if (strlen(buffer) < sizeof("HTTP/1.x 200 ")-1)
	  buffer = ap_pstrcat(r->pool, buffer, " ", NULL);
        buffer[12] = '\0';
        r->status = atoi(&buffer[9]);
        buffer[12] = ' ';
        r->status_line = ap_pstrdup(r->pool, &buffer[9]);

        /* if the response was 100 continue, soak up any headers */
        if (r->status == 100) {
            ap_proxy_read_headers(r, buffer, size, f);
        }

    }
    else {

        /* an http/0.9 response */
        *backasswards = 1;
        r->status = 200;
        r->status_line = "200 OK";
        *major = 0;
        *minor = 9;

    }

    return OK;

}

static struct per_thread_data *get_per_thread_data(void)
{
    static APACHE_TLS struct per_thread_data sptd;
    return &sptd;
}
@


1.18
log
@Add a SECURITY FIX for CVE-2010-0010
"on 64-bit platforms this allows remote origin servers to cause a
denial of service (daemon crash) or possibly execute arbitrary code
via a large chunk size that triggers a heap-based buffer overflow."

"looks good" to henning@@
ok otto@@
@
text
@@


1.17
log
@Add support for IPv6 while keeping the default at IPv4 to not break
existing installations.  See the documentation for the IPv6 related
configuration.

This changes the module ABI since addresses are now struct addrinfo.

This has been tested by many people and run on production machines
for several months.

feedback many, ok todd
@
text
@d547 1
a547 1
                n = ap_bread(f, buf, MIN((int)buf_size, (int)remaining));
d588 2
a589 2
                n = ap_bread(f, buf, MIN((int)buf_size,
                                         (int)(len - total_bytes_rcvd)));
@


1.16
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d209 1
d248 23
a270 12
    strp = strrchr(host, ':');
    if (strp != NULL) {
        *(strp++) = '\0';

        for (i = 0; strp[i] != '\0'; i++)
            if (!ap_isdigit(strp[i]))
                break;

        /* if (i == 0) the no port was given; keep default */
        if (strp[i] != '\0') {
            return "Bad port number in URL";
        }
d272 4
a275 4
            *port = atoi(strp);
            if (*port > 65535)
                return "Port number in URL > 65535";
        }
d282 2
a283 2
        if (!ap_isdigit(host[i]) && host[i] != '.')
            break;
d285 14
a298 3
    if (host[i] == '\0' && (ap_inet_addr(host) == -1 || inet_network(host) == -1))
    {
        return "Bad IP address in URL";
d1274 1
a1274 1
int ap_proxy_doconnect(int sock, struct sockaddr_in *addr, request_rec *r)
d1277 7
d1286 12
d1299 1
a1299 1
        i = connect(sock, (struct sockaddr *)addr, sizeof(struct sockaddr_in));
d1302 5
d1308 1
a1308 2
                      "proxy connect to %s port %d failed",
                      inet_ntoa(addr->sin_addr), ntohs(addr->sin_port));
@


1.15
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d1376 1
a1376 1
            while (*next && (ap_isspace(*next) || (*next == ','))) {
@


1.14
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@a755 53
#ifdef CASE_BLIND_FILESYSTEM

/*
 * On some platforms, the file system is NOT case sensitive. So, a == A
 * need to map to smaller set of characters
 */
void ap_proxy_hash(const char *it, char *val, int ndepth, int nlength)
{
    AP_MD5_CTX context;
    unsigned char digest[16];
    char tmp[26];
    int i, k, d;
    unsigned int x;
    static const char enc_table[32] = "abcdefghijklmnopqrstuvwxyz012345";

    ap_MD5Init(&context);
    ap_MD5Update(&context, (const unsigned char *)it, strlen(it));
    ap_MD5Final(digest, &context);

/* encode 128 bits as 26 characters, using a modified uuencoding */
/* the encoding is 5 bytes -> 8 characters
 * i.e. 128 bits is 3 x 5 bytes + 1 byte -> 3 * 8 characters + 2 characters
 */
    for (i = 0, k = 0; i < 15; i += 5) {
        x = (digest[i] << 24) | (digest[i + 1] << 16) | (digest[i + 2] << 8) | digest[i + 3];
        tmp[k++] = enc_table[x >> 27];
        tmp[k++] = enc_table[(x >> 22) & 0x1f];
        tmp[k++] = enc_table[(x >> 17) & 0x1f];
        tmp[k++] = enc_table[(x >> 12) & 0x1f];
        tmp[k++] = enc_table[(x >> 7) & 0x1f];
        tmp[k++] = enc_table[(x >> 2) & 0x1f];
        x = ((x & 0x3) << 8) | digest[i + 4];
        tmp[k++] = enc_table[x >> 5];
        tmp[k++] = enc_table[x & 0x1f];
    }
/* one byte left */
    x = digest[15];
    tmp[k++] = enc_table[x >> 3];       /* use up 5 bits */
    tmp[k++] = enc_table[x & 0x7];
    /* now split into directory levels */

    for (i = k = d = 0; d < ndepth; ++d) {
        memcpy(&val[i], &tmp[k], nlength);
        k += nlength;
        val[i + nlength] = '/';
        i += nlength + 1;
    }
    memcpy(&val[i], &tmp[k], 26 - k);
    val[i + 26 - k] = '\0';
}

#else

a796 2
#endif                          /* CASE_BLIND_FILESYSTEM */

a1154 7
#if 0
    if (addr[i] == ':') {
        fprintf(stderr, "@@@@@@@@ handle optional port in proxy_is_domainname()\n");
        /* @@@@@@@@ handle optional port */
    }
#endif

a1200 7
#if 0
    if (addr[i] == ':') {
        fprintf(stderr, "@@@@@@@@ handle optional port in proxy_is_hostname()\n");
        /* @@@@@@@@ handle optional port */
    }
#endif

a1226 9

#if 0
    unsigned long *ip_list;

    /* Try to deal with multiple IP addr's for a host */
    for (ip_list = *This->hostentry->h_addr_list; *ip_list != 0UL; ++ip_list)
        if (*ip_list == ? ? ? ? ? ? ? ? ? ? ? ? ?)
            return 1;
#endif
@


1.13
log
@merge
@
text
@a76 1
#ifndef CHARSET_EBCDIC
a95 3
#else                           /* CHARSET_EBCDIC */
    return (1 == sscanf(x, "%2x", &i)) ? os_toebcdic[i & 0xFF] : 0;
#endif                          /* CHARSET_EBCDIC */
a99 1
#ifndef CHARSET_EBCDIC
a113 8
#else                           /* CHARSET_EBCDIC */
    static const char ntoa[] = {"0123456789ABCDEF"};
    ch = os_toascii[ch & 0xFF];
    x[0] = '%';
    x[1] = ntoa[(ch >> 4) & 0x0F];
    x[2] = ntoa[ch & 0x0F];
    x[3] = '\0';
#endif                          /* CHARSET_EBCDIC */
a272 3
#if defined(WIN32) || defined(NETWARE) || defined(TPF) || defined(BEOS)
    if (host[i] == '\0' && (inet_addr(host) == -1))
#else
a273 1
#endif
a456 6
#ifdef CHARSET_EBCDIC
    /* The cache copy is ASCII, not EBCDIC, even for text/html) */
    ap_bsetflag(f, B_ASCII2EBCDIC | B_EBCDIC2ASCII, 0);
    ap_bsetflag(con->client, B_ASCII2EBCDIC | B_EBCDIC2ASCII, 0);
#endif

a464 5
#if defined(WIN32) || defined(TPF) || defined(NETWARE)
    /* works fine under win32, so leave it */
    ap_hard_timeout("proxy send body", r);
    alternate_timeouts = 0;
#else
a477 1
#endif
a815 8
#if defined(MPE) || (defined(AIX) && defined(__ps2__))
    /*
     * Believe it or not, AIX 1.x does not allow you to name a file '@@', so
     * hack around it in the encoding.
     */
    static const char enc_table[64] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_%";
#else
a817 1
#endif
a1335 4
#if defined(WIN32) || defined(NETWARE)
        if (i == SOCKET_ERROR)
            errno = WSAGetLastError();
#endif                          /* WIN32 */
a1604 29

#if defined WIN32

static DWORD tls_index;

BOOL WINAPI DllMain(HINSTANCE dllhandle, DWORD reason, LPVOID reserved)
{
    LPVOID memptr;

    switch (reason) {
    case DLL_PROCESS_ATTACH:
        tls_index = TlsAlloc();
    case DLL_THREAD_ATTACH:     /* intentional no break */
        TlsSetValue(tls_index, malloc(sizeof(struct per_thread_data)));
        break;
    case DLL_THREAD_DETACH:
        memptr = TlsGetValue(tls_index);
        if (memptr) {
            free(memptr);
            TlsSetValue(tls_index, 0);
        }
        break;
    }

    return TRUE;
}

#endif

a1606 6
#if defined(WIN32)

    return (struct per_thread_data *)TlsGetValue(tls_index);

#else

a1608 2

#endif
@


1.12
log
@string shit; ok dhartmei@@
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
@


1.11
log
@merge apache 1.3.27 and mod_ssl 2.8.11
@
text
@d918 1
a918 1
void ap_proxy_sec2hex(int t, char *y)
d924 3
a926 2
        strcpy(y, "FFFFFFFFFFFFFFFF");
        return;
d929 3
d941 1
@


1.10
log
@merge
@
text
@d1610 6
@


1.9
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d66 1
a66 1
#include "util_date.h"  /* get ap_checkmask() decl. */
d76 3
a78 1
    int i, ch;
a79 1
#ifndef CHARSET_EBCDIC
d97 3
a99 3
#else /*CHARSET_EBCDIC*/
    return (1 == sscanf(x, "%2x", &i)) ? os_toebcdic[i&0xFF] : 0;
#endif /*CHARSET_EBCDIC*/
d119 2
a120 2
#else /*CHARSET_EBCDIC*/
    static const char ntoa[] = { "0123456789ABCDEF" };
d123 2
a124 2
    x[1] = ntoa[(ch>>4)&0x0F];
    x[2] = ntoa[ch&0x0F];
d126 1
a126 1
#endif /*CHARSET_EBCDIC*/
d140 1
a140 1
                        enum proxyreqtype isenc)
d149 1
a149 1
 * 
d217 1
a217 1
                        char **passwordp, char **hostp, int *port)
d271 2
a272 1
        } else if (i > 0) {
d278 1
a278 1
    ap_str_tolower(host);                /* DNS names are case-insensitive */
d304 1
a304 1
static const char * const lwday[7] =
a369 57
/* NOTE: This routine is taken from http_protocol::getline()
 * because the old code found in the proxy module was too
 * difficult to understand and maintain.
 */
/* Get a line of protocol input, including any continuation lines
 * caused by MIME folding (or broken clients) if fold != 0, and place it
 * in the buffer s, of size n bytes, without the ending newline.
 *
 * Returns -1 on error, or the length of s.
 *
 * Note: Because bgets uses 1 char for newline and 1 char for NUL,
 *       the most we can get is (n - 2) actual characters if it
 *       was ended by a newline, or (n - 1) characters if the line
 *       length exceeded (n - 1).  So, if the result == (n - 1),
 *       then the actual input line exceeded the buffer length,
 *       and it would be a good idea for the caller to puke 400 or 414.
 */
static int proxy_getline(char *s, int n, BUFF *in, int fold)
{
    char *pos, next;
    int retval;
    int total = 0;

    pos = s;

    do {
        retval = ap_bgets(pos, n, in);     /* retval == -1 if error, 0 if EOF */

        if (retval <= 0)
            return ((retval < 0) && (total == 0)) ? -1 : total;

        /* retval is the number of characters read, not including NUL      */

        n -= retval;            /* Keep track of how much of s is full     */
        pos += (retval - 1);    /* and where s ends                        */
        total += retval;        /* and how long s has become               */

        if (*pos == '\n') {     /* Did we get a full line of input?        */
            *pos = '\0';
            --total;
            ++n;
        }
        else
            return total;       /* if not, input line exceeded buffer size */

        /* Continue appending if line folding is desired and
         * the last line was not empty and we have room in the buffer and
         * the next line begins with a continuation character.
         */
    } while (fold && (retval != 1) && (n > 1)
                  && (ap_blookc(&next, in) == 1)
                  && ((next == ' ') || (next == '\t')));

    return total;
}


d393 11
a403 9
    while ((len = proxy_getline(buffer, size, f, 1)) > 0) {
        
        if (!(value = strchr(buffer, ':'))) {     /* Find the colon separator */

            /* Buggy MS IIS servers sometimes return invalid headers
             * (an extra "HTTP/1.0 200, OK" line sprinkled in between
             * the usual MIME headers). Try to deal with it in a sensible
             * way, but log the fact.
             * XXX: The mask check is buggy if we ever see an HTTP/1.10 */
d410 3
a412 3
            ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, r->server,
                         "proxy: Ignoring duplicate HTTP header "
                         "returned by %s (%s)", r->uri, r->method);
d418 2
a419 1
        /* XXX: RFC2068 defines only SP and HT as whitespace, this test is
d426 1
a426 1
        for (end = &value[strlen(value)-1]; end > value && ap_isspace(*end); --end)
d433 3
a435 3
        if (len >= size - 1) { 
            while ((len = proxy_getline(field, MAX_STRING_LEN, f, 1))
                    >= MAX_STRING_LEN - 1) {
d438 1
a438 1
            if (len == 0) /* time to exit the larger loop as well */
d445 1
a445 1
/* read data from f, write it to:
d450 1
a450 1
long int ap_proxy_send_fb(BUFF *f, request_rec *r, cache_req *c, off_t len, int nowrite, size_t recv_buffer_size)
d452 1
a452 1
    int  ok;
d455 1
d457 1
a457 1
    register int n, o, w;
d459 2
a460 1
    int alternate_timeouts = 1; /* 1 if we alternate between soft & hard timeouts */
d463 4
a466 1
    /* make sure it is at least IOBUFSIZE, as recv_buffer_size may be zero for system default */
d476 2
a477 4
    ap_bsetflag(f, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);
    if (c != NULL && c->fp != NULL)
        ap_bsetflag(c->fp, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);
    ap_bsetflag(con->client, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);
d480 4
a483 3
    /* Since we are reading from one buffer and writing to another,
     * it is unsafe to do a soft_timeout here, at least until the proxy
     * has its own timeout handler which can set both buffers to EOUT.
d493 7
a499 6
    /* CHECKME! Since hard_timeout won't work in unix on sends with partial
     * cache completion, we have to alternate between hard_timeout
     * for reads, and soft_timeout for send.  This is because we need
     * to get a return from ap_bwrite to be able to continue caching.
     * BUT, if we *can't* continue anyway, just use hard_timeout.
     * (Also, if no cache file is written, use hard timeouts)
d508 4
a511 3
    /* Loop and ap_bread() while we can successfully read and write,
     * or (after the client aborted) while we can successfully
     * read and finish the configured cache_completion.
d513 1
a513 1
    for (ok = 1; ok; ) {
d517 69
a585 3
        /* Read block from server */
        if (-1 == len) {
            n = ap_bread(f, buf, buf_size);
d587 2
d590 7
a596 1
            n = ap_bread(f, buf, MIN((off_t)buf_size, len - total_bytes_rcvd));
d599 1
d608 1
a608 1
                    "proxy: error reading from %s", c->url);
d614 1
a614 1
            break;                /* EOF */
d619 6
a624 5
        /* in the case of slow frontends and expensive backends,
         * we want to avoid leaving a backend connection hanging
         * while the frontend takes it's time to absorb the bytes.
         * so: if we just read the last block, we close the backend
         * connection now instead of later - it's no longer needed.
d632 4
a635 1
        /*@@@@@@ XXX FIXME: Assuming that writing the cache file won't time out?!!? */
d639 1
a639 1
                    "proxy: error writing to %s", c->tempfile);
d641 2
a642 1
            } else {
d661 4
a664 3
                    /* when a send failure occurs, we need to decide
                     * whether to continue loading and caching the
                     * document, or to abort the whole thing
d667 2
a668 2
                         (c->cache_completion > 0) &&
                         (c->len * c->cache_completion < total_bytes_rcvd);
d670 4
a673 4
                    if (! ok) {
                        if (c->fp!=NULL) {
                        ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR));
                        c->fp = NULL;
d684 1
a684 1
        } /* while client alive and more data to send */
d690 1
a690 1
    } /* loop and ap_bread while "ok" */
d702 3
d718 3
a720 3
            ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                          "proxy: error writing status line to %s", c->tempfile);
            c = ap_proxy_cache_error(c);
d722 1
a722 1
        }
d747 1
a747 1
    valbuf[sizeof(valbuf)-1] = 0; /* safety terminating zero */
d775 1
a775 1
                strncpy(valbuf, list, MIN(p-list, sizeof(valbuf)-1));
d801 1
a801 1
    ap_MD5Update(&context, (const unsigned char *) it, strlen(it));
d846 4
a849 2
    /* Believe it or not, AIX 1.x does not allow you to name a file '@@',
     * so hack around it in the encoding. */
d851 1
a851 1
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_%";
d854 1
a854 1
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_@@";
d858 1
a858 1
    ap_MD5Update(&context, (const unsigned char *) it, strlen(it));
d874 1
a874 1
    tmp[k++] = enc_table[x >> 2];        /* use up 6 bits */
d888 1
a888 1
#endif /* CASE_BLIND_FILESYSTEM */
d910 1
a910 1
/*      return -1;*/            /* so that it works with 8-byte ints */
d912 1
a912 1
        return j;
d960 1
a960 1
                  ap_pstrcat(r->pool, 
d962 1
a962 1
                             "<EM><A HREF=\"", ap_escape_uri(r->pool, r->uri),
d964 2
a965 2
                             "&nbsp;", 
                             ap_escape_html(r->pool, r->uri), "</A></EM>.<P>\n"
d967 1
a967 1
                             ap_escape_html(r->pool, message), 
d981 1
a981 1
     ap_proxy_host2addr(const char *host, struct hostent *reqhp)
d998 1
a998 1
        hp = gethostbyaddr((char *) &ptd->ipaddr, sizeof(ptd->ipaddr), AF_INET);
d1005 1
a1005 1
            ptd->hpbuf.h_addr_list[0] = (char *) &ptd->ipaddr;
d1028 2
a1029 1
    url = ap_pstrdup(r->pool, &url[1]); /* make it point to "//", which is what proxy_canon_netloc expects */
d1034 2
a1035 2
        ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
                     "%s", err);
d1055 4
a1058 1
    /*if (proxy_readmask(This->name, &This->addr.s_addr, &This->mask.s_addr) == 0) */
d1060 1
a1060 1
    /*return 1; */
d1075 1
a1075 1
        ip_addr[quads] = strtol(addr, &tmp, 0);
d1099 1
a1099 1
        bits = strtol(addr, &tmp, 0);
d1117 4
a1120 1
        /* "IP Address should be given in dotted-quad form, optionally followed by a netmask (e.g., 192.168.111.0/24)"; */
d1161 2
a1162 2
    if (host == NULL)   /* oops! */
       return 0;
d1207 1
a1207 1
            ip_list = (struct in_addr *) *ip_listptr;
d1306 1
a1306 1
    This->hostentry = ap_pduphostent (p, &host);
d1325 1
a1325 1
       return 0; /* oops! */
d1368 1
a1368 1
        i = connect(sock, (struct sockaddr *) addr, sizeof(struct sockaddr_in));
d1372 1
a1372 1
#endif /* WIN32 */
d1376 2
a1377 2
                     "proxy connect to %s port %d failed",
                     inet_ntoa(addr->sin_addr), ntohs(addr->sin_port));
d1392 1
a1392 1
      if (key == NULL || value == NULL || value[0] == '\0')
d1394 1
a1394 1
      if (c->fp != NULL &&
d1396 4
a1399 4
            ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                    "proxy: error writing header to %s", c->tempfile);
          c = ap_proxy_cache_error(c);
            return 0; /* no need to continue, it failed already */
d1401 2
a1402 1
    return 1; /* tell ap_table_do() to continue calling us for more headers */
d1417 2
a1418 1
    time_t apparent_age, corrected_received_age, response_delay, corrected_initial_age, resident_time, current_age;
d1450 1
a1450 1
            ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "File %s not found", filename);
d1483 1
a1484 2
        if (!next) 
        return;
d1486 10
a1495 7
    while (*next) { 
        name = next;
        while (*next && !ap_isspace(*next) && (*next != ','))
            ++next;
        while (*next && (ap_isspace(*next) || (*next == ','))) {
            *next = '\0';
            ++next;
d1497 1
a1497 1
        ap_table_unset(headers, name);
d1499 23
a1521 1
    ap_table_unset(headers, "Connection");
d1543 1
a1543 1
    table_entry *elts = (table_entry *) overlay->a.elts;
d1566 22
a1587 11
/* unmerge an element in the table */
void ap_proxy_table_unmerge(pool *p, table *t, char *key)
{
    long int offset = 0;
    long int count = 0;
    char *value = NULL;

    /* get the value to unmerge */
    const char *initial = ap_table_get(t, key);
    if (!initial) {
        return;
a1588 1
    value = ap_pstrdup(p, initial);
d1590 5
a1594 2
    /* remove the value from the headers */
    ap_table_unset(t, key);
d1596 4
a1599 6
    /* find each comma */
    while (value[count]) {
        if (value[count] == ',') {
            value[count] = 0;
            ap_table_add(t, key, value + offset);
            offset = count + 1;
d1601 29
a1629 1
        count++;
d1631 3
a1633 1
    ap_table_add(t, key, value + offset);
d1636 1
d1641 1
a1641 1
BOOL WINAPI DllMain (HINSTANCE dllhandle, DWORD reason, LPVOID reserved)
d1648 2
a1649 2
    case DLL_THREAD_ATTACH: /* intentional no break */
        TlsSetValue (tls_index, malloc (sizeof (struct per_thread_data)));
d1652 1
a1652 1
        memptr = TlsGetValue (tls_index);
d1654 2
a1655 2
            free (memptr);
            TlsSetValue (tls_index, 0);
d1669 1
a1669 1
    return (struct per_thread_data *) TlsGetValue (tls_index);
@


1.8
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d66 1
a66 1
#include "util_date.h"	/* get ap_checkmask() decl. */
d81 1
a81 1
	i = ch - '0';
d83 1
a83 1
	i = ch - ('A' - 10);
d85 1
a85 1
	i = ch - ('a' - 10);
d90 1
a90 1
	i += ch - '0';
d92 1
a92 1
	i += ch - ('A' - 10);
d94 1
a94 1
	i += ch - ('a' - 10);
d109 1
a109 1
	x[1] = ('A' - 10) + i;
d111 1
a111 1
	x[1] = '0' + i;
d115 1
a115 1
	x[2] = ('A' - 10) + i;
d117 1
a117 1
	x[2] = '0' + i;
d139 1
a139 1
			enum proxyreqtype isenc)
d143 2
a144 2
    const char *allowed;	/* characters which should not be encoded */
    const char *reserved;	/* characters which much not be en/de-coded */
d154 1
a154 1
	allowed = "$-_.+!*'(),;:@@&=";
d156 1
a156 1
	allowed = "$-_.!*'(),;:@@&=";
d158 1
a158 1
	allowed = "$-_.+!*'(),;@@&=";
d160 3
a162 3
	allowed = "$-_.+!*'(),?:@@&=";
    else			/* if (t == enc_parm) */
	allowed = "$-_.+!*'(),?/:@@&=";
d165 1
a165 1
	reserved = "/";
d167 1
a167 1
	reserved = "+";
d169 1
a169 1
	reserved = "";
d175 5
a179 5
	ch = x[i];
	if (strchr(reserved, ch)) {
	    y[j] = ch;
	    continue;
	}
d181 11
a191 11
	if (isenc != NOT_PROXY && ch == '%') {
	    if (!ap_isxdigit(x[i + 1]) || !ap_isxdigit(x[i + 2]))
		return NULL;
	    ch = ap_proxy_hex2c(&x[i + 1]);
	    i += 2;
	    if (ch != 0 && strchr(reserved, ch)) {	/* keep it encoded */
		ap_proxy_c2hex(ch, &y[j]);
		j += 2;
		continue;
	    }
	}
d193 6
a198 6
	if (!ap_isalnum(ch) && !strchr(allowed, ch)) {
	    ap_proxy_c2hex(ch, &y[j]);
	    j += 2;
	}
	else
	    y[j] = ch;
d216 1
a216 1
			char **passwordp, char **hostp, int *port)
d223 1
a223 1
	return "Malformed URL";
d227 1
a227 1
	url = "";
d229 1
a229 1
	*(url++) = '\0';	/* skip seperating '/' */
d235 3
a237 3
	*strp = '\0';
	user = host;
	host = strp + 1;
d240 11
a250 11
	strp = strchr(user, ':');
	if (strp != NULL) {
	    *strp = '\0';
	    password = ap_proxy_canonenc(p, strp + 1, strlen(strp + 1), enc_user, STD_PROXY);
	    if (password == NULL)
		return "Bad %-escape in URL (password)";
	}

	user = ap_proxy_canonenc(p, user, strlen(user), enc_user, STD_PROXY);
	if (user == NULL)
	    return "Bad %-escape in URL (username)";
d253 1
a253 1
	*userp = user;
d256 1
a256 1
	*passwordp = password;
d261 1
a261 1
	*(strp++) = '\0';
d263 12
a274 12
	for (i = 0; strp[i] != '\0'; i++)
	    if (!ap_isdigit(strp[i]))
		break;

	/* if (i == 0) the no port was given; keep default */
	if (strp[i] != '\0') {
	    return "Bad port number in URL";
	} else if (i > 0) {
	    *port = atoi(strp);
	    if (*port > 65535)
		return "Port number in URL > 65535";
	}
d276 1
a276 1
    ap_str_tolower(host);		/* DNS names are case-insensitive */
d278 1
a278 1
	return "Missing host in URL";
d281 2
a282 2
	if (!ap_isdigit(host[i]) && host[i] != '.')
	    break;
d290 1
a290 1
	return "Bad IP address in URL";
d321 17
a337 17
	*q = '\0';
	for (wk = 0; wk < 7; wk++)
	    if (strcmp(x, lwday[wk]) == 0)
		break;
	*q = ',';
	if (wk == 7)
	    return x;		/* not a valid date */
	if (q[4] != '-' || q[8] != '-' || q[11] != ' ' || q[14] != ':' ||
	    q[17] != ':' || strcmp(&q[20], " GMT") != 0)
	    return x;
	if (sscanf(q + 2, "%u-%3s-%u %u:%u:%u %3s", &mday, month, &year,
		   &hour, &min, &sec, zone) != 7)
	    return x;
	if (year < 70)
	    year += 2000;
	else
	    year += 1900;
d341 11
a351 11
	if (x[3] != ' ' || x[7] != ' ' || x[10] != ' ' || x[13] != ':' ||
	    x[16] != ':' || x[19] != ' ' || x[24] != '\0')
	    return x;
	if (sscanf(x, "%3s %3s %u %u:%u:%u %u", week, month, &mday, &hour,
		   &min, &sec, &year) != 7)
	    return x;
	for (wk = 0; wk < 7; wk++)
	    if (strcmp(week, ap_day_snames[wk]) == 0)
		break;
	if (wk == 7)
	    return x;
d356 2
a357 2
	if (strcmp(month, ap_month_snames[mon]) == 0)
	    break;
d359 1
a359 1
	return x;
d363 1
a363 1
		ap_month_snames[mon], year, hour, min, sec);
d429 5
a433 2
 * @@@@@@: XXX: FIXME: currently the headers are passed thru un-merged. 
 * Is that okay, or should they be collapsed where possible?
d449 2
a450 2
	
	if (!(value = strchr(buffer, ':'))) {     /* Find the colon separator */
d452 16
a467 16
	    /* Buggy MS IIS servers sometimes return invalid headers
	     * (an extra "HTTP/1.0 200, OK" line sprinkled in between
	     * the usual MIME headers). Try to deal with it in a sensible
	     * way, but log the fact.
	     * XXX: The mask check is buggy if we ever see an HTTP/1.10 */

	    if (!ap_checkmask(buffer, "HTTP/#.# ###*")) {
		/* Nope, it wasn't even an extra HTTP header. Give up. */
		return NULL;
	    }

	    ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, r->server,
			 "proxy: Ignoring duplicate HTTP header "
			 "returned by %s (%s)", r->uri, r->method);
	    continue;
	}
d471 3
a473 3
	/* XXX: RFC2068 defines only SP and HT as whitespace, this test is
	 * wrong... and so are many others probably.
	 */
d477 3
a479 3
	/* should strip trailing whitespace as well */
	for (end = &value[strlen(value)-1]; end > value && ap_isspace(*end); --end)
	    *end = '\0';
d481 1
d484 9
a492 9
	/* the header was too long; at the least we should skip extra data */
	if (len >= size - 1) { 
	    while ((len = proxy_getline(field, MAX_STRING_LEN, f, 1))
		    >= MAX_STRING_LEN - 1) {
		/* soak up the extra data */
	    }
	    if (len == 0) /* time to exit the larger loop as well */
		break;
	}
d497 6
a502 1
long int ap_proxy_send_fb(BUFF *f, request_rec *r, cache_req *c)
d505 2
a506 1
    char buf[IOBUFSIZE];
d510 6
a515 1
    int alternate_timeouts = 1;	/* 1 if we alternate between soft & hard timeouts */
d525 1
a525 1
	ap_bsetflag(c->fp, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);
d563 7
a569 2
	/* Read block from server */
	n = ap_bread(f, buf, IOBUFSIZE);
d576 24
a599 12
	if (n == -1) {		/* input error */
	    if (c != NULL) {
		ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
		    "proxy: error reading from %s", c->url);
		c = ap_proxy_cache_error(c);
	    }
	    break;
	}
	if (n == 0)
	    break;		/* EOF */
	o = 0;
	total_bytes_rcvd += n;
d601 2
a602 2
	/* Write to cache first. */
	/*@@@@@@ XXX FIXME: Assuming that writing the cache file won't time out?!!? */
d606 2
a607 2
		    "proxy: error writing to %s", c->tempfile);
		c = ap_proxy_cache_error(c);
d613 2
a614 2
	/* Write the block to the client, detect aborted transfers */
        while (!con->aborted && n > 0) {
d626 1
a626 1
                if (c != NULL && c->fp != NULL) {
d636 1
d639 1
d641 1
a641 1
			c = NULL;
d650 5
d657 8
a664 2
    if (!con->aborted)
	ap_bflush(con->client);
d671 3
a673 5
 * Sends response line and headers.  Uses the client fd and the 
 * headers_out array from the passed request_rec to talk to the client
 * and to properly set the headers it sends for things such as logging.
 * 
 * A timeout should be set before calling this routine.
d675 1
a675 1
void ap_proxy_send_headers(request_rec *r, const char *respline, table *t)
d677 8
a684 3
    int i;
    BUFF *fp = r->connection->client;
    table_entry *elts = (table_entry *) ap_table_elts(t)->elts;
d686 2
a687 1
    ap_bvputs(fp, respline, CRLF, NULL);
d689 5
a693 5
    for (i = 0; i < ap_table_elts(t)->nelts; ++i) {
	if (elts[i].key != NULL) {
	    ap_bvputs(fp, elts[i].key, ": ", elts[i].val, CRLF, NULL);
	    ap_table_addn(r->headers_out, elts[i].key, elts[i].val);
	}
a694 2

    ap_bputs(CRLF, fp);
d704 1
a704 1
int ap_proxy_liststr(const char *list, const char *val)
d708 2
d711 1
a711 1
    len = strlen(val);
d714 29
a742 15
	p = strchr(list, ',');
	if (p != NULL) {
	    i = p - list;
	    do
		p++;
	    while (ap_isspace(*p));
	}
	else
	    i = strlen(list);

	while (i > 0 && ap_isspace(list[i - 1]))
	    i--;
	if (i == len && strncasecmp(list, val, len) == 0)
	    return 1;
	list = p;
d771 10
a780 10
	x = (digest[i] << 24) | (digest[i + 1] << 16) | (digest[i + 2] << 8) | digest[i + 3];
	tmp[k++] = enc_table[x >> 27];
	tmp[k++] = enc_table[(x >> 22) & 0x1f];
	tmp[k++] = enc_table[(x >> 17) & 0x1f];
	tmp[k++] = enc_table[(x >> 12) & 0x1f];
	tmp[k++] = enc_table[(x >> 7) & 0x1f];
	tmp[k++] = enc_table[(x >> 2) & 0x1f];
	x = ((x & 0x3) << 8) | digest[i + 4];
	tmp[k++] = enc_table[x >> 5];
	tmp[k++] = enc_table[x & 0x1f];
d784 1
a784 1
    tmp[k++] = enc_table[x >> 3];	/* use up 5 bits */
d789 4
a792 4
	memcpy(&val[i], &tmp[k], nlength);
	k += nlength;
	val[i + nlength] = '/';
	i += nlength + 1;
d811 1
a811 1
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_%";
d814 1
a814 1
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_@@";
d826 5
a830 5
	x = (digest[i] << 16) | (digest[i + 1] << 8) | digest[i + 2];
	tmp[k++] = enc_table[x >> 18];
	tmp[k++] = enc_table[(x >> 12) & 0x3f];
	tmp[k++] = enc_table[(x >> 6) & 0x3f];
	tmp[k++] = enc_table[x & 0x3f];
d834 1
a834 1
    tmp[k++] = enc_table[x >> 2];	/* use up 6 bits */
d839 4
a842 4
	memcpy(&val[i], &tmp[k], nlength);
	k += nlength;
	val[i + nlength] = '/';
	i += nlength + 1;
d851 1
a851 1
 * Converts 8 hex digits to a time integer
d858 9
a866 9
    for (i = 0, j = 0; i < 8; i++) {
	ch = x[i];
	j <<= 4;
	if (ap_isdigit(ch))
	    j |= ch - '0';
	else if (ap_isupper(ch))
	    j |= ch - ('A' - 10);
	else
	    j |= ch - ('a' - 10);
d868 5
a872 4
    if (j == 0xffffffff)
	return -1;		/* so that it works with 8-byte ints */
    else
	return j;
d876 1
a876 1
 * Converts a time integer to 8 hex digits
d883 12
a894 7
    for (i = 7; i >= 0; i--) {
	ch = j & 0xF;
	j >>= 4;
	if (ch >= 10)
	    y[i] = ch + ('A' - 10);
	else
	    y[i] = ch + '0';
d896 1
a896 1
    y[8] = '\0';
d903 10
a912 5
	if (c->fp != NULL) {
	    ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR));
	    c->fp = NULL;
	}
	if (c->tempfile) unlink(c->tempfile);
d920 9
a928 9
		  ap_pstrcat(r->pool, 
			     "The proxy server could not handle the request "
			     "<EM><A HREF=\"", ap_escape_uri(r->pool, r->uri),
			     "\">", ap_escape_html(r->pool, r->method),
			     "&nbsp;", 
			     ap_escape_html(r->pool, r->uri), "</A></EM>.<P>\n"
			     "Reason: <STRONG>",
			     ap_escape_html(r->pool, message), 
			     "</STRONG>", NULL));
d948 2
a949 2
	if (!ap_isdigit(host[i]) && host[i] != '.')
	    break;
d952 3
a954 3
	hp = gethostbyname(host);
	if (hp == NULL)
	    return "Host not found";
d957 12
a968 12
	ptd->ipaddr = ap_inet_addr(host);
	hp = gethostbyaddr((char *) &ptd->ipaddr, sizeof(ptd->ipaddr), AF_INET);
	if (hp == NULL) {
	    memset(&ptd->hpbuf, 0, sizeof(ptd->hpbuf));
	    ptd->hpbuf.h_name = 0;
	    ptd->hpbuf.h_addrtype = AF_INET;
	    ptd->hpbuf.h_length = sizeof(ptd->ipaddr);
	    ptd->hpbuf.h_addr_list = ptd->charpbuf;
	    ptd->hpbuf.h_addr_list[0] = (char *) &ptd->ipaddr;
	    ptd->hpbuf.h_addr_list[1] = 0;
	    hp = &ptd->hpbuf;
	}
d981 1
a981 1
	return r->hostname;
d985 2
a986 2
	|| url[1] != '/' || url[2] != '/')
	return NULL;
d988 1
a988 1
    url = ap_pstrdup(r->pool, &url[1]);	/* make it point to "//", which is what proxy_canon_netloc expects */
d993 2
a994 2
	ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
		     "%s", err);
d998 1
a998 1
    return host;		/* ought to return the port, too */
d1023 1
a1023 1
	char *tmp;
d1025 2
a1026 2
	if (*addr == '/' && quads > 0)	/* netmask starts here. */
	    break;
d1028 2
a1029 2
	if (!ap_isdigit(*addr))
	    return 0;		/* no digit at start of quad */
d1031 1
a1031 1
	ip_addr[quads] = strtol(addr, &tmp, 0);
d1033 2
a1034 2
	if (tmp == addr)	/* expected a digit, found something else */
	    return 0;
d1036 4
a1039 4
	if (ip_addr[quads] < 0 || ip_addr[quads] > 255) {
	    /* invalid octet */
	    return 0;
	}
d1041 1
a1041 1
	addr = tmp;
d1043 2
a1044 2
	if (*addr == '.' && quads != 3)
	    ++addr;		/* after the 4th quad, a dot would be illegal */
d1048 1
a1048 1
	This->addr.s_addr |= htonl(ip_addr[i] << (24 - 8 * i));
d1050 2
a1051 2
    if (addr[0] == '/' && ap_isdigit(addr[1])) {	/* net mask follows: */
	char *tmp;
d1053 1
a1053 1
	++addr;
d1055 1
a1055 1
	bits = strtol(addr, &tmp, 0);
d1057 2
a1058 2
	if (tmp == addr)	/* expected a digit, found something else */
	    return 0;
d1060 1
a1060 1
	addr = tmp;
d1062 2
a1063 2
	if (bits < 0 || bits > 32)	/* netmask must be between 0 and 32 */
	    return 0;
d1067 16
a1082 16
	/* Determine (i.e., "guess") netmask by counting the */
	/* number of trailing .0's; reduce #quads appropriately */
	/* (so that 192.168.0.0 is equivalent to 192.168.)        */
	while (quads > 0 && ip_addr[quads - 1] == 0)
	    --quads;

	/* "IP Address should be given in dotted-quad form, optionally followed by a netmask (e.g., 192.168.111.0/24)"; */
	if (quads < 1)
	    return 0;

	/* every zero-byte counts as 8 zero-bits */
	bits = 8 * quads;

	if (bits != 32)		/* no warning for fully qualified IP address */
	    fprintf(stderr, "Warning: NetMask not supplied with IP-Addr; guessing: %s/%ld\n",
		    inet_ntoa(This->addr), bits);
d1088 5
a1092 5
	fprintf(stderr, "Warning: NetMask and IP-Addr disagree in %s/%ld\n",
		inet_ntoa(This->addr), bits);
	This->addr.s_addr &= This->mask.s_addr;
	fprintf(stderr, "         Set to %s/%ld\n",
		inet_ntoa(This->addr), bits);
d1096 2
a1097 2
	This->matcher = proxy_match_ipaddr;
	return 1;
d1100 1
a1100 1
	return (*addr == '\0');	/* okay iff we've parsed the whole string */
d1121 2
a1122 2
	for (addr.s_addr = 0, i = 0; i < 4; ++i)
	    addr.s_addr |= htonl(ip_addr[i] << (24 - 8 * i));
d1124 1
a1124 1
	if (This->addr.s_addr == (addr.s_addr & This->mask.s_addr)) {
d1126 3
a1128 3
	    fprintf(stderr, "1)IP-Match: %s[%s] <-> ", host, inet_ntoa(addr));
	    fprintf(stderr, "%s/", inet_ntoa(This->addr));
	    fprintf(stderr, "%s\n", inet_ntoa(This->mask));
d1130 2
a1131 2
	    return 1;
	}
d1133 5
a1137 5
	else {
	    fprintf(stderr, "1)IP-NoMatch: %s[%s] <-> ", host, inet_ntoa(addr));
	    fprintf(stderr, "%s/", inet_ntoa(This->addr));
	    fprintf(stderr, "%s\n", inet_ntoa(This->mask));
	}
d1141 1
a1141 1
	struct hostent the_host;
d1143 2
a1144 2
	memset(&the_host, '\0', sizeof the_host);
	found = ap_proxy_host2addr(host, &the_host);
d1146 1
a1146 1
	if (found != NULL) {
d1148 1
a1148 1
	    fprintf(stderr, "2)IP-NoMatch: hostname=%s msg=%s\n", host, found);
d1150 7
a1156 2
	    return 0;
	}
d1158 4
a1161 9
	if (the_host.h_name != NULL)
	    found = the_host.h_name;
	else
	    found = host;

	/* Try to deal with multiple IP addr's for a host */
	for (ip_listptr = the_host.h_addr_list; *ip_listptr; ++ip_listptr) {
	    ip_list = (struct in_addr *) *ip_listptr;
	    if (This->addr.s_addr == (ip_list->s_addr & This->mask.s_addr)) {
d1163 3
a1165 3
		fprintf(stderr, "3)IP-Match: %s[%s] <-> ", found, inet_ntoa(*ip_list));
		fprintf(stderr, "%s/", inet_ntoa(This->addr));
		fprintf(stderr, "%s\n", inet_ntoa(This->mask));
d1167 2
a1168 2
		return 1;
	    }
d1170 5
a1174 5
	    else {
		fprintf(stderr, "3)IP-NoMatch: %s[%s] <-> ", found, inet_ntoa(*ip_list));
		fprintf(stderr, "%s/", inet_ntoa(This->addr));
		fprintf(stderr, "%s\n", inet_ntoa(This->mask));
	    }
d1176 1
a1176 1
	}
d1190 1
a1190 1
	return 0;
d1194 1
a1194 1
	continue;
d1198 2
a1199 2
	fprintf(stderr, "@@@@@@@@ handle optional port in proxy_is_domainname()\n");
	/* @@@@@@@@ handle optional port */
d1204 1
a1204 1
	return 0;
d1208 1
a1208 1
	addr[i] = '\0';
d1220 2
a1221 2
    if (host == NULL)		/* some error was logged already */
	return 0;
d1228 1
a1228 1
	--d_len;
d1230 1
a1230 1
	--h_len;
d1232 1
a1232 1
	&& strncasecmp(&host[h_len - d_len], This->name, d_len) == 0;
d1244 1
a1244 1
	return 0;
d1251 2
a1252 2
	fprintf(stderr, "@@@@@@@@ handle optional port in proxy_is_hostname()\n");
	/* @@@@@@@@ handle optional port */
d1257 1
a1257 1
	return 0;
d1263 1
a1263 1
	addr[i] = '\0';
d1288 2
a1289 2
	if (*ip_list == ? ? ? ? ? ? ? ? ? ? ? ? ?)
	    return 1;
d1294 1
a1294 1
	--h2_len;
d1296 1
a1296 1
	--h1_len;
d1298 1
a1298 1
	&& strncasecmp(host, host2, h1_len) == 0;
d1321 1
a1321 1
	i = connect(sock, (struct sockaddr *) addr, sizeof(struct sockaddr_in));
d1323 2
a1324 2
	if (i == SOCKET_ERROR)
	    errno = WSAGetLastError();
d1328 3
a1330 3
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "proxy connect to %s port %d failed",
		     inet_ntoa(addr->sin_addr), ntohs(addr->sin_port));
d1337 4
a1340 3
/* This function is called by ap_table_do() for all header lines */
/* (from proxy_http.c and proxy_ftp.c) */
/* It is passed a table_do_args struct pointer and a MIME field and value pair */
d1343 1
a1343 1
    struct tbl_do_args *parm = (struct tbl_do_args *)p;
d1345 8
a1352 9
    if (key == NULL || value == NULL || value[0] == '\0')
	return 1;
    if (!parm->req->assbackwards)
	ap_rvputs(parm->req, key, ": ", value, CRLF, NULL);
    if (parm->cache != NULL && parm->cache->fp != NULL &&
	ap_bvputs(parm->cache->fp, key, ": ", value, CRLF, NULL) == -1) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, parm->cache->req,
		    "proxy: error writing header to %s", parm->cache->tempfile);
	    parm->cache = ap_proxy_cache_error(parm->cache);
d1362 1
a1362 1
	ap_bputs(data, cache->fp);
d1366 156
d1532 1
a1532 1
	tls_index = TlsAlloc();
d1534 2
a1535 2
	TlsSetValue (tls_index, malloc (sizeof (struct per_thread_data)));
	break;
d1537 6
a1542 6
	memptr = TlsGetValue (tls_index);
	if (memptr) {
	    free (memptr);
	    TlsSetValue (tls_index, 0);
	}
	break;
@


1.7
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1996-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 20
a38 23
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 7
a56 6
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
d120 1
a120 1
    ch &= 0xFF;
d122 2
a123 2
    x[1] = ntoa[(os_toascii[ch]>>4)&0x0F];
    x[2] = ntoa[os_toascii[ch]&0x0F];
@


1.6
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d71 1
a71 1

d242 1
a242 1
	    password = ap_proxy_canonenc(p, strp + 1, strlen(strp + 1), enc_user, 1);
d247 1
a247 1
	user = ap_proxy_canonenc(p, user, strlen(user), enc_user, 1);
d283 1
a283 1
#if defined(WIN32) || defined(NETWARE) || defined(TPF)
d520 1
a520 1
#if defined(WIN32) || defined(TPF)
d743 1
a743 1
#if defined(AIX) && defined(__ps2__)
d870 1
a870 3
    static APACHE_TLS struct hostent hpbuf;
    static APACHE_TLS u_long ipaddr;
    static APACHE_TLS char *charpbuf[2];
d882 2
a883 2
	ipaddr = ap_inet_addr(host);
	hp = gethostbyaddr((char *) &ipaddr, sizeof(u_long), AF_INET);
d885 8
a892 8
	    memset(&hpbuf, 0, sizeof(hpbuf));
	    hpbuf.h_name = 0;
	    hpbuf.h_addrtype = AF_INET;
	    hpbuf.h_length = sizeof(u_long);
	    hpbuf.h_addr_list = charpbuf;
	    hpbuf.h_addr_list[0] = (char *) &ipaddr;
	    hpbuf.h_addr_list[1] = 0;
	    hp = &hpbuf;
d1291 41
@


1.5
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d847 7
a853 3
			     "<EM><A HREF=\"", r->uri, "\">",
			     r->method, "&nbsp;", r->uri, "</A></EM>.<P>\n"
			     "Reason: <STRONG>", message, "</STRONG>", NULL));
d855 1
a855 1
    /* Allow the "error-notes" string to be printed by ap_send_error_response() */
@


1.4
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d137 2
a138 2
char *
     ap_proxy_canonenc(pool *p, const char *x, int len, enum enctype t, int isenc)
d180 1
a180 1
	if (isenc && ch == '%') {
d283 1
a283 1
#ifdef WIN32
d520 1
a520 1
#ifdef WIN32
d603 1
a603 1
                        ap_pclosef(c->req->pool, c->fp->fd);
d834 1
a834 1
	    ap_pclosef(c->req->pool, c->fp->fd);
d1245 1
a1245 1
#ifdef WIN32
@


1.3
log
@Apache 1.3.4 merge
@
text
@d181 1
a181 1
	    if (!isxdigit(x[i + 1]) || !isxdigit(x[i + 2]))
d494 1
a494 1
    int  ok = 1;
d496 1
a496 1
    long total_bytes_rcv;
d499 1
a499 1
    int alt_to = 1;
d501 2
a502 2
    total_bytes_rcv = 0;
    if (c)
d523 1
a523 1
    alt_to = 0;
d530 1
d533 1
a533 6
    if (c) {
        if (c->len <= 0 || c->cache_completion == 1) {
            ap_hard_timeout("proxy send body", r);
            alt_to = 0;
        }
    } else {
d535 1
a535 1
        alt_to = 0;
d539 7
a545 3
    while (ok) {
        if (alt_to)
            ap_hard_timeout("proxy send body", r);
d550 1
a550 1
        if (alt_to)
d556 3
a558 1
	    if (c != NULL)
d560 1
d566 1
a566 1
	total_bytes_rcv += n;
d569 1
d572 3
a574 1
                c = ap_proxy_cache_error(c);
d581 2
a582 2
        while (n && !con->aborted) {
            if (alt_to)
d587 1
a587 1
            if (alt_to)
d600 1
a600 1
                         (c->len * c->cache_completion < total_bytes_rcv);
d614 2
a615 2
        }
    }
d621 1
a621 1
    return total_bytes_rcv;
d637 1
a637 2
    ap_bputs(respline, fp);
    ap_bputs(CRLF, fp);
a641 2
	    /* FIXME: @@@@@@ This used to be ap_table_set(), but I think
	     * ap_table_addn() is correct. MnKr */
d832 7
a838 5
    ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
		 "proxy: error writing to cache file %s", c->tempfile);
    ap_pclosef(c->req->pool, c->fp->fd);
    c->fp = NULL;
    unlink(c->tempfile);
d842 1
a842 1
int ap_proxyerror(request_rec *r, const char *message)
d850 6
a855 2
    r->status_line = "500 Proxy Error";
    return HTTP_INTERNAL_SERVER_ERROR;
d1272 3
a1274 1
	ap_bvputs(parm->cache->fp, key, ": ", value, CRLF, NULL) == -1)
d1276 1
@


1.2
log
@Apache 1.3.3 merge + proxy_segv fix
@
text
@d2 1
a2 1
 * Copyright (c) 1996-1998 The Apache Group.  All rights reserved.
d266 2
a267 1
	if (i == 0 || strp[i] != '\0')
d269 5
a273 3
	*port = atoi(strp);
	if (*port > 65535)
	    return "Port number in URL > 65535";
d680 1
a680 1
#ifdef WIN32
d683 1
a683 1
 * On NT, the file system is NOT case sensitive. So, a == A
d781 1
a781 1
#endif /* WIN32 */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1996,1997 The Apache Group.  All rights reserved.
d23 2
a24 1
 *    prior written permission.
d26 5
a30 1
 * 5. Redistributions of any form whatsoever must retain the following
a58 1

d61 10
a70 1
#include "md5.h"
d73 1
a73 2
int
proxy_hex2c(const char *x)
d77 1
d79 6
a84 3
    if (isdigit(ch)) i = ch - '0';
    else if (isupper(ch)) i = ch - ('A' - 10);
    else i = ch - ('a' - 10);
d88 6
a93 3
    if (isdigit(ch)) i += ch - '0';
    else if (isupper(ch)) i += ch - ('A' - 10);
    else i += ch - ('a' - 10);
d95 3
d100 1
a100 2
void
proxy_c2hex(int ch, char *x)
d102 1
d107 4
a110 2
    if (i >= 10) x[1] = ('A' - 10) + i;
    else x[1] = '0' + i;
d113 12
a124 2
    if (i >= 10) x[2] = ('A' - 10) + i;
    else x[2] = '0' + i;
d138 1
a138 1
proxy_canonenc(pool *p, const char *x, int len, enum enctype t, int isenc)
d140 1
a140 1
    int i, j, ispath, ch;
d142 2
a143 2
    const char *allowed;  /* characters which should not be encoded */
    const char *reserved;  /* characters which much not be en/de-coded */
d152 17
a168 9
    if (t == enc_path) allowed = "$-_.+!*'(),;:@@&=";
    else if (t == enc_search) allowed = "$-_.!*'(),;:@@&=";
    else if (t == enc_user) allowed = "$-_.+!*'(),;@@&=";
    else if (t == enc_fpath) allowed = "$-_.+!*'(),?:@@&=";
    else /* if (t == enc_parm) */ allowed = "$-_.+!*'(),?/:@@&=";

    if (t == enc_path) reserved = "/";
    else if (t == enc_search) reserved = "+";
    else reserved = "";
d170 1
a170 2
    y = palloc(p, 3*len+1);
    ispath = (t == enc_path);
d172 1
a172 2
    for (i=0, j=0; i < len; i++, j++)
    {
d175 1
a175 2
	if (ind(reserved, ch) != -1)
	{
d180 2
a181 3
	if (isenc && ch == '%')
	{
	    if (!isxdigit(x[i+1]) || !isxdigit(x[i+2]))
d183 1
a183 1
	    ch = proxy_hex2c(&x[i+1]);
d185 2
a186 3
	    if (ch != 0 && ind(reserved, ch) != -1)
	    {  /* keep it encoded */
		proxy_c2hex(ch, &y[j]);
d192 2
a193 3
	if (!isalnum(ch) && ind(allowed, ch) == -1)
	{
	    proxy_c2hex(ch, &y[j]);
d195 3
a197 1
	} else y[j] = ch;
d214 2
a215 2
proxy_canon_netloc(pool *pool, char **const urlp, char **userp,
    char **passwordp, char **hostp, int *port)
d218 2
a219 1
    char *p, *host, *url=*urlp;
d221 2
a222 1
    if (url[0] != '/' || url[1] != '/') return "Malformed URL";
d228 1
a228 1
	*(url++) = '\0';  /* skip seperating '/' */
d230 2
a231 4
    if (userp != NULL)
    {
	char *user=NULL, *password = NULL;
	p = strchr(host, '@@');
d233 4
a236 5
	if (p != NULL)
	{
	    *p = '\0';
	    user = host;
	    host = p + 1;
d239 7
a245 8
	    p = strchr(user, ':');
	    if (p != NULL)
	    {
		*p = '\0';
		password = proxy_canonenc(pool, p+1, strlen(p+1), enc_user, 1);
		if (password == NULL)
		    return "Bad %-escape in URL (password)";
	    }
d247 5
a251 3
	    user = proxy_canonenc(pool, user, strlen(user), enc_user, 1);
	    if (user == NULL) return "Bad %-escape in URL (username)";
	}
d253 2
d258 7
a264 7
    p = strchr(host, ':');
    if (p != NULL)
    {
	*(p++) = '\0';
	
	for (i=0; p[i] != '\0'; i++)
	    if (!isdigit(p[i])) break;
d266 1
a266 1
	if (i == 0 || p[i] != '\0')
d268 3
a270 2
	*port = atoi(p);
	if (*port > 65535) return "Port number in URL > 65535";
d272 3
a274 2
    str_tolower(host); /* DNS names are case-insensitive */
    if (*host == '\0') return "Missing host in URL";
d276 2
a277 2
    for (i=0; host[i] != '\0'; i++)
	if (!isdigit(host[i]) && host[i] != '.')
d279 9
a287 3
 /* must be an IP address */
    if (host[i] == '\0' && (inet_addr(host) == -1 || inet_network(host) == -1))
	    return "Bad IP address in URL";
d289 3
d298 1
a298 1
static const char *lwday[7]=
a299 5
static const char *wday[7]=
{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
static const char *months[12]=
{"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov",
 "Dec"};
d308 2
a309 2
char *
proxy_date_canon(pool *p, char *x)
d313 1
a313 1
    
d316 1
a316 2
    if (q != NULL && q - x > 3 && q[1] == ' ')
    {
d318 3
a320 2
	for (wk=0; wk < 7; wk++)
	    if (strcmp(x, lwday[wk]) == 0) break;
d322 2
a323 1
	if (wk == 7) return x;  /* not a valid date */
d325 11
a335 7
	    q[17] != ':' || strcmp(&q[20], " GMT") != 0) return x;
	if (sscanf(q+2, "%u-%3s-%u %u:%u:%u %3s", &mday, month, &year,
		   &hour, &min, &sec, zone) != 7) return x;
	if (year < 70) year += 2000;
	else year += 1900;
    } else
    {
d338 2
a339 1
	    x[16] != ':' || x[19] != ' ' || x[24] != '\0') return x;
d341 7
a347 4
		   &min, &sec, &year) != 7) return x;
	for (wk=0; wk < 7; wk++)
	    if (strcmp(week, wday[wk]) == 0) break;
	if (wk == 7) return x;
d351 5
a355 2
    for (mon=0; mon < 12; mon++) if (strcmp(month, months[mon]) == 0) break;
    if (mon == 12) return x;
d357 61
a417 7
    if (strlen(x)+1 < 30) {
        x = palloc(p, 30);
    }
    /* format: "Wed, 17 Dec 1997 00:53:40 GMT" (29 chars data) */
    ap_snprintf(x, 30, "%s, %.2d %s %d %.2d:%.2d:%.2d GMT", wday[wk], mday,
	    months[mon], year, hour, min, sec);
    return x;
d420 1
d424 3
d428 1
a428 2
array_header *
proxy_read_headers(pool *pool, char *buffer, int size, BUFF *f)
d430 14
a443 4
    int gotcr, len, i, j;
    array_header *resp_hdrs;
    struct hdr_entry *hdr;
    char *p;
d445 5
a449 2
    resp_hdrs = make_array(pool, 10, sizeof(struct hdr_entry));
    hdr = NULL;
d451 3
a453 26
    gotcr = 1;
    for (;;)
    {
	len = bgets(buffer, size, f);
	if (len == -1) return NULL;
	if (len == 0) break;
	if (buffer[len-1] == '\n')
	{
	    buffer[--len] = '\0';
	    i = 1;
	} else
	    i = 0;

	if (!gotcr || buffer[0] == ' ' || buffer[0] == '\t')
	{
	    /* a continuation header */
	    if (hdr == NULL)
	    {
		/* error!! */
		if (!i)
		{
		    i = bskiplf(f);
		    if (i == -1) return NULL;
		}
		gotcr = 1;
		continue;
d455 5
a459 1
	    hdr->value = pstrcat(pool, hdr->value, buffer, NULL);
d461 20
a480 15
	else if (gotcr && len == 0) break;
	else
	{
	    p = strchr(buffer, ':');
	    if (p == NULL)
	    {
		/* error!! */
		if (!gotcr)
		{
		    i = bskiplf(f);
		    if (i == -1) return NULL;
		}
		gotcr = 1;
		hdr = NULL;
		continue;
d482 2
a483 6
	    hdr = push_array(resp_hdrs);
	    *(p++) = '\0';
	    hdr->field = pstrdup(pool, buffer);
	    while (*p == ' ' || *p == '\t') p++;
	    hdr->value = pstrdup(pool, p);
	    gotcr = i;
a485 10

    hdr = (struct hdr_entry *)resp_hdrs->elts;
    for (i=0; i < resp_hdrs->nelts; i++)
    {
	p = hdr[i].value;
	j = strlen(p);
	while (j > 0 && (p[j-1] == ' ' || p[j-1] == '\t')) j--;
	p[j] = '\0';
    }

d489 1
a489 2
long int
proxy_send_fb(BUFF *f, request_rec *r, BUFF *f2, struct cache_req *c)
d491 1
d493 2
a494 2
    long total_bytes_sent;
    register int n,o,w;
d496 13
a508 2
    
    total_bytes_sent = 0;
a513 1
    hard_timeout("proxy send body", r);
d515 40
a554 5
    while (!con->aborted && f != NULL) {
	n = bread(f, buf, IOBUFSIZE);
	if (n == -1) /* input error */
	{
	    if (f2 != NULL) f2 = proxy_cache_error(c);
d557 25
a581 3
	if (n == 0) break; /* EOF */
        o=0;
	total_bytes_sent += n;
a582 5
	if (f2 != NULL)
	    if (bwrite(f2, buf, n) != n) f2 = proxy_cache_error(c);
	
        while(n && !con->aborted) {
            w = bwrite(con->client, &buf[o], n);
d584 15
a598 4
                if (f2 != NULL) {
                    pclosef(c->req->pool, c->fp->fd);
                    c->fp = NULL; 
                    unlink(c->tempfile);
d600 1
d603 2
a604 3
	    reset_timeout(r); /* reset timeout after successful write */
            n-=w;
            o+=w;
d607 1
d609 1
a609 5
        bflush(con->client);
    
    kill_timeout(r);
    return total_bytes_sent;
}
d611 2
a612 15
/*
 * Read a header from the array, returning the first entry
 */
struct hdr_entry *
proxy_get_header(array_header *hdrs_arr, const char *name)
{
    struct hdr_entry *hdrs;
    int i;

    hdrs = (struct hdr_entry *)hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; i++)
        if (hdrs[i].field != NULL && strcasecmp(name, hdrs[i].field) == 0)
	    return &hdrs[i];

    return NULL;
d616 4
a619 42
 * Add to the header reply, either concatenating, or replacing existin
 * headers. It stores the pointers provided, so make sure the data
 * is not subsequently overwritten
 */
struct hdr_entry *
proxy_add_header(array_header *hdrs_arr, char *field, char *value,
	   int rep)
{
    int i;
    struct hdr_entry *hdrs;

    hdrs = (struct hdr_entry *)hdrs_arr->elts;
    if (rep)
	for (i = 0; i < hdrs_arr->nelts; i++)
	    if (hdrs[i].field != NULL && strcasecmp(field, hdrs[i].field) == 0)
	    {
		hdrs[i].value = value;
		return hdrs;
	    }
	
    hdrs = push_array(hdrs_arr);
    hdrs->field = field;
    hdrs->value = value;

    return hdrs;
}

void
proxy_del_header(array_header *hdrs_arr, const char *field)
{
    int i;
    struct hdr_entry *hdrs;

    hdrs = (struct hdr_entry *)hdrs_arr->elts;

    for (i = 0; i < hdrs_arr->nelts; i++)
	if (hdrs[i].field != NULL && strcasecmp(field, hdrs[i].field) == 0)
	    hdrs[i].value = NULL;
}

/*
 * Sends response line and headers
d622 1
a622 2
void
proxy_send_headers(BUFF *fp, const char *respline, array_header *hdrs_arr)
a623 1
    struct hdr_entry *hdrs;
d625 2
d628 2
a629 1
    hdrs = (struct hdr_entry *)hdrs_arr->elts;
d631 7
a637 6
    bputs(respline, fp);
    bputs("\015\012", fp);
    for (i = 0; i < hdrs_arr->nelts; i++)
    {
        if (hdrs[i].field == NULL) continue;
	bvputs(fp, hdrs[i].field, ": ", hdrs[i].value, "\015\012", NULL);
d640 1
a640 1
    bputs("\015\012", fp);
d650 1
a650 2
int
proxy_liststr(const char *list, const char *val)
d657 1
a657 2
    while (list != NULL)
    {
d659 1
a659 2
	if (p != NULL)
	{
d661 4
a664 2
	    do p++; while (isspace(*p));
	} 
d668 4
a671 2
	while (i > 0 && isspace(list[i-1])) i--;
	if (i == len && strncasecmp(list, val, len) == 0) return 1;
d677 7
a683 2
void
proxy_hash(const char *it, char *val,int ndepth,int nlength)
d685 48
a732 1
    MD5_CTX context;
d737 13
a749 6
    static const char table[64]=
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_@@";

    MD5Init(&context);
    MD5Update(&context, (const unsigned char *)it, strlen(it));
    MD5Final(digest, &context);
d755 6
a760 7
    for (i=0, k=0; i < 15; i += 3)
    {
	x = (digest[i] << 16) | (digest[i+1] << 8) | digest[i+2];
	tmp[k++] = table[x >> 18];
	tmp[k++] = table[(x >> 12) & 0x3f];
	tmp[k++] = table[(x >> 6) & 0x3f];
	tmp[k++] = table[x & 0x3f];
d764 2
a765 2
    tmp[k++] = table[x >> 2];  /* use up 6 bits */
    tmp[k++] = table[(x << 4) & 0x3f];
d768 8
a775 9
    for(i=k=d=0 ; d < ndepth ; ++d)
	{
	strncpy(&val[i],&tmp[k],nlength);
	k+=nlength;
	val[i+nlength]='/';
	i+=nlength+1;
	}
    memcpy(&val[i],&tmp[k],22-k);
    val[i+22-k]='\0';
d778 2
d783 1
a783 2
int
proxy_hex2sec(const char *x)
d788 1
a788 2
    for (i=0, j=0; i < 8; i++)
    {
d791 6
a796 3
	if (isdigit(ch)) j |= ch - '0';
	else if (isupper(ch)) j |= ch - ('A' - 10);
	else j |= ch - ('a' - 10);
d798 4
a801 2
    if (j == 0xffffffff) return -1;  /* so that it works with 8-byte ints */
    else return j;
d807 1
a807 2
void
proxy_sec2hex(int t, char *y)
d810 1
a810 1
    unsigned int j=t;
d812 1
a812 2
    for (i=7; i >= 0; i--)
    {
d815 4
a818 2
	if (ch >= 10) y[i] = ch + ('A' - 10);
	else y[i] = ch + '0';
a822 26
void
proxy_log_uerror(const char *routine, const char *file, const char *err,
	   server_rec *s)
{
    char *p, *q;

    q = get_time();
    p = strerror(errno);

    if (err != NULL)
    {
	fprintf(s->error_log, "[%s] %s\n", q, err);
	if (file != NULL)
	    fprintf(s->error_log, "- %s: %s: %s\n", routine, file, p);
	else
	    fprintf(s->error_log, "- %s: %s\n", routine, p);
    } else
    {
	if (file != NULL)
	    fprintf(s->error_log, "[%s] %s: %s: %s\n", q, routine, file, p);
	else
	    fprintf(s->error_log, "[%s] %s: %s\n", q, routine, p);
    }

    fflush(s->error_log);
}
d824 1
a824 2
BUFF *
proxy_cache_error(struct cache_req *c)
d826 4
a829 4
    proxy_log_uerror("write", c->tempfile, "proxy: error writing to cache file",
        c->req->server);
    pclosef(c->req->pool, c->fp->fd);
    c->fp = NULL; 
d834 1
a834 2
int
proxyerror(request_rec *r, const char *message)
d836 6
a841 1
    r->status = SERVER_ERROR;
d843 1
a843 13
    r->content_type = "text/html";

    send_http_header(r);
    soft_timeout("proxy error", r);

    rvputs(r, "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\015\012\
<html><head><title>Proxy Error</title><head>\015\012<body><h1>Proxy Error\
</h1>\015\012The proxy server could not handle this request.\
\015\012<p>\015\012Reason: <b>", message, "</b>\015\012</body><html>\015\012",
	   NULL);

    kill_timeout(r);
    return OK;
d850 1
a850 1
proxy_host2addr(const char *host, struct hostent *reqhp)
d854 3
a856 3
    static struct hostent hpbuf;
    static u_long ipaddr;
    static char* charpbuf[2];
d858 2
a859 2
    for (i=0; host[i] != '\0'; i++)
	if (!isdigit(host[i]) && host[i] != '.')
d862 1
a862 2
    if (host[i] != '\0')
    {
d866 4
a869 4
    } else
    {
	ipaddr = inet_addr(host);
	hp = gethostbyaddr((char *)&ipaddr, sizeof(u_long), AF_INET);
d876 1
a876 1
	    hpbuf.h_addr_list[0] = (char*)&ipaddr;
d881 1
a881 1
    memcpy(reqhp, hp, sizeof(struct hostent));
d885 2
a886 2
int
proxy_doconnect(int sock, struct sockaddr_in *addr, request_rec *r)
d888 263
d1153 91
a1243 5
    hard_timeout("proxy connect", r);
    do	i = connect(sock, (struct sockaddr *)addr, sizeof(struct sockaddr_in));
    while (i == -1 && errno == EINTR);
    if (i == -1) proxy_log_uerror("connect", NULL, NULL, r->server);
    kill_timeout(r);
d1246 26
@


1.1.1.1
log
@Initial import from apache 1.2.6
@
text
@@


1.1.1.2
log
@Apache 1.3.2
@
text
@d2 1
a2 1
 * Copyright (c) 1996-1998 The Apache Group.  All rights reserved.
d23 1
a23 2
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
d25 1
a25 5
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
d54 1
d57 1
a57 10
#include "ap_md5.h"
#include "multithread.h"
#include "http_log.h"
#include "util_uri.h"
#include "util_date.h"	/* get ap_checkmask() decl. */

static int proxy_match_ipaddr(struct dirconn_entry *This, request_rec *r);
static int proxy_match_domainname(struct dirconn_entry *This, request_rec *r);
static int proxy_match_hostname(struct dirconn_entry *This, request_rec *r);
static int proxy_match_word(struct dirconn_entry *This, request_rec *r);
d60 2
a61 1
int ap_proxy_hex2c(const char *x)
a64 1
#ifndef CHARSET_EBCDIC
d66 3
a68 6
    if (ap_isdigit(ch))
	i = ch - '0';
    else if (ap_isupper(ch))
	i = ch - ('A' - 10);
    else
	i = ch - ('a' - 10);
d72 3
a74 6
    if (ap_isdigit(ch))
	i += ch - '0';
    else if (ap_isupper(ch))
	i += ch - ('A' - 10);
    else
	i += ch - ('a' - 10);
a75 3
#else /*CHARSET_EBCDIC*/
    return (1 == sscanf(x, "%2x", &i)) ? os_toebcdic[i&0xFF] : 0;
#endif /*CHARSET_EBCDIC*/
d78 2
a79 1
void ap_proxy_c2hex(int ch, char *x)
a80 1
#ifndef CHARSET_EBCDIC
d85 2
a86 4
    if (i >= 10)
	x[1] = ('A' - 10) + i;
    else
	x[1] = '0' + i;
d89 2
a90 12
    if (i >= 10)
	x[2] = ('A' - 10) + i;
    else
	x[2] = '0' + i;
#else /*CHARSET_EBCDIC*/
    static const char ntoa[] = { "0123456789ABCDEF" };
    ch &= 0xFF;
    x[0] = '%';
    x[1] = ntoa[(os_toascii[ch]>>4)&0x0F];
    x[2] = ntoa[os_toascii[ch]&0x0F];
    x[3] = '\0';
#endif /*CHARSET_EBCDIC*/
d104 1
a104 1
     ap_proxy_canonenc(pool *p, const char *x, int len, enum enctype t, int isenc)
d106 1
a106 1
    int i, j, ch;
d108 2
a109 2
    const char *allowed;	/* characters which should not be encoded */
    const char *reserved;	/* characters which much not be en/de-coded */
d118 9
a126 17
    if (t == enc_path)
	allowed = "$-_.+!*'(),;:@@&=";
    else if (t == enc_search)
	allowed = "$-_.!*'(),;:@@&=";
    else if (t == enc_user)
	allowed = "$-_.+!*'(),;@@&=";
    else if (t == enc_fpath)
	allowed = "$-_.+!*'(),?:@@&=";
    else			/* if (t == enc_parm) */
	allowed = "$-_.+!*'(),?/:@@&=";

    if (t == enc_path)
	reserved = "/";
    else if (t == enc_search)
	reserved = "+";
    else
	reserved = "";
d128 2
a129 1
    y = ap_palloc(p, 3 * len + 1);
d131 2
a132 1
    for (i = 0, j = 0; i < len; i++, j++) {
d135 2
a136 1
	if (strchr(reserved, ch)) {
d141 3
a143 2
	if (isenc && ch == '%') {
	    if (!isxdigit(x[i + 1]) || !isxdigit(x[i + 2]))
d145 1
a145 1
	    ch = ap_proxy_hex2c(&x[i + 1]);
d147 3
a149 2
	    if (ch != 0 && strchr(reserved, ch)) {	/* keep it encoded */
		ap_proxy_c2hex(ch, &y[j]);
d155 3
a157 2
	if (!ap_isalnum(ch) && !strchr(allowed, ch)) {
	    ap_proxy_c2hex(ch, &y[j]);
d159 1
a159 3
	}
	else
	    y[j] = ch;
d176 2
a177 2
     ap_proxy_canon_netloc(pool *p, char **const urlp, char **userp,
			char **passwordp, char **hostp, int *port)
d180 1
a180 2
    char *strp, *host, *url = *urlp;
    char *user = NULL, *password = NULL;
d182 1
a182 2
    if (url[0] != '/' || url[1] != '/')
	return "Malformed URL";
d188 1
a188 1
	*(url++) = '\0';	/* skip seperating '/' */
d190 4
a193 2
    /* find _last_ '@@' since it might occur in user/password part */
    strp = strrchr(host, '@@');
d195 5
a199 4
    if (strp != NULL) {
	*strp = '\0';
	user = host;
	host = strp + 1;
d202 11
a212 6
	strp = strchr(user, ':');
	if (strp != NULL) {
	    *strp = '\0';
	    password = ap_proxy_canonenc(p, strp + 1, strlen(strp + 1), enc_user, 1);
	    if (password == NULL)
		return "Bad %-escape in URL (password)";
a213 6

	user = ap_proxy_canonenc(p, user, strlen(user), enc_user, 1);
	if (user == NULL)
	    return "Bad %-escape in URL (username)";
    }
    if (userp != NULL) {
a214 2
    }
    if (passwordp != NULL) {
d218 7
a224 7
    strp = strrchr(host, ':');
    if (strp != NULL) {
	*(strp++) = '\0';

	for (i = 0; strp[i] != '\0'; i++)
	    if (!ap_isdigit(strp[i]))
		break;
d226 1
a226 1
	if (i == 0 || strp[i] != '\0')
d228 2
a229 3
	*port = atoi(strp);
	if (*port > 65535)
	    return "Port number in URL > 65535";
d231 2
a232 3
    ap_str_tolower(host);		/* DNS names are case-insensitive */
    if (*host == '\0')
	return "Missing host in URL";
d234 2
a235 2
    for (i = 0; host[i] != '\0'; i++)
	if (!ap_isdigit(host[i]) && host[i] != '.')
d237 3
a239 9
    /* must be an IP address */
#ifdef WIN32
    if (host[i] == '\0' && (inet_addr(host) == -1))
#else
    if (host[i] == '\0' && (ap_inet_addr(host) == -1 || inet_network(host) == -1))
#endif
    {
	return "Bad IP address in URL";
    }
a240 3
/*    if (strchr(host,'.') == NULL && domain != NULL)
   host = pstrcat(p, host, domain, NULL);
 */
d247 1
a247 1
static const char * const lwday[7] =
d249 5
d262 2
a263 2
const char *
     ap_proxy_date_canon(pool *p, const char *x)
d267 1
a267 1

d270 2
a271 1
    if (q != NULL && q - x > 3 && q[1] == ' ') {
d273 2
a274 3
	for (wk = 0; wk < 7; wk++)
	    if (strcmp(x, lwday[wk]) == 0)
		break;
d276 1
a276 2
	if (wk == 7)
	    return x;		/* not a valid date */
d278 7
a284 11
	    q[17] != ':' || strcmp(&q[20], " GMT") != 0)
	    return x;
	if (sscanf(q + 2, "%u-%3s-%u %u:%u:%u %3s", &mday, month, &year,
		   &hour, &min, &sec, zone) != 7)
	    return x;
	if (year < 70)
	    year += 2000;
	else
	    year += 1900;
    }
    else {
d287 1
a287 2
	    x[16] != ':' || x[19] != ' ' || x[24] != '\0')
	    return x;
d289 4
a292 7
		   &min, &sec, &year) != 7)
	    return x;
	for (wk = 0; wk < 7; wk++)
	    if (strcmp(week, ap_day_snames[wk]) == 0)
		break;
	if (wk == 7)
	    return x;
d296 2
a297 5
    for (mon = 0; mon < 12; mon++)
	if (strcmp(month, ap_month_snames[mon]) == 0)
	    break;
    if (mon == 12)
	return x;
d299 7
a305 4
    q = ap_palloc(p, 30);
    ap_snprintf(q, 30, "%s, %.2d %s %d %.2d:%.2d:%.2d GMT", ap_day_snames[wk], mday,
		ap_month_snames[mon], year, hour, min, sec);
    return q;
a307 58

/* NOTE: This routine is taken from http_protocol::getline()
 * because the old code found in the proxy module was too
 * difficult to understand and maintain.
 */
/* Get a line of protocol input, including any continuation lines
 * caused by MIME folding (or broken clients) if fold != 0, and place it
 * in the buffer s, of size n bytes, without the ending newline.
 *
 * Returns -1 on error, or the length of s.
 *
 * Note: Because bgets uses 1 char for newline and 1 char for NUL,
 *       the most we can get is (n - 2) actual characters if it
 *       was ended by a newline, or (n - 1) characters if the line
 *       length exceeded (n - 1).  So, if the result == (n - 1),
 *       then the actual input line exceeded the buffer length,
 *       and it would be a good idea for the caller to puke 400 or 414.
 */
static int proxy_getline(char *s, int n, BUFF *in, int fold)
{
    char *pos, next;
    int retval;
    int total = 0;

    pos = s;

    do {
        retval = ap_bgets(pos, n, in);     /* retval == -1 if error, 0 if EOF */

        if (retval <= 0)
            return ((retval < 0) && (total == 0)) ? -1 : total;

        /* retval is the number of characters read, not including NUL      */

        n -= retval;            /* Keep track of how much of s is full     */
        pos += (retval - 1);    /* and where s ends                        */
        total += retval;        /* and how long s has become               */

        if (*pos == '\n') {     /* Did we get a full line of input?        */
            *pos = '\0';
            --total;
            ++n;
        }
        else
            return total;       /* if not, input line exceeded buffer size */

        /* Continue appending if line folding is desired and
         * the last line was not empty and we have room in the buffer and
         * the next line begins with a continuation character.
         */
    } while (fold && (retval != 1) && (n > 1)
                  && (ap_blookc(&next, in) == 1)
                  && ((next == ' ') || (next == '\t')));

    return total;
}


a310 3
 * This routine tries to deal with too long lines and continuation lines.
 * @@@@@@: XXX: FIXME: currently the headers are passed thru un-merged. 
 * Is that okay, or should they be collapsed where possible?
d312 2
a313 1
table *ap_proxy_read_headers(request_rec *r, char *buffer, int size, BUFF *f)
d315 4
a318 14
    table *resp_hdrs;
    int len;
    char *value, *end;
    char field[MAX_STRING_LEN];

    resp_hdrs = ap_make_table(r->pool, 20);

    /*
     * Read header lines until we get the empty separator line, a read error,
     * the connection closes (EOF), or we timeout.
     */
    while ((len = proxy_getline(buffer, size, f, 1)) > 0) {
	
	if (!(value = strchr(buffer, ':'))) {     /* Find the colon separator */
d320 2
a321 5
	    /* Buggy MS IIS servers sometimes return invalid headers
	     * (an extra "HTTP/1.0 200, OK" line sprinkled in between
	     * the usual MIME headers). Try to deal with it in a sensible
	     * way, but log the fact.
	     * XXX: The mask check is buggy if we ever see an HTTP/1.10 */
d323 26
a348 3
	    if (!ap_checkmask(buffer, "HTTP/#.# ###*")) {
		/* Nope, it wasn't even an extra HTTP header. Give up. */
		return NULL;
d350 1
a350 5

	    ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, r->server,
			 "proxy: Ignoring duplicate HTTP header "
			 "returned by %s (%s)", r->uri, r->method);
	    continue;
d352 15
a366 20

        *value = '\0';
        ++value;
	/* XXX: RFC2068 defines only SP and HT as whitespace, this test is
	 * wrong... and so are many others probably.
	 */
        while (ap_isspace(*value))
            ++value;            /* Skip to start of value   */

	/* should strip trailing whitespace as well */
	for (end = &value[strlen(value)-1]; end > value && ap_isspace(*end); --end)
	    *end = '\0';

        ap_table_add(resp_hdrs, buffer, value);

	/* the header was too long; at the least we should skip extra data */
	if (len >= size - 1) { 
	    while ((len = proxy_getline(field, MAX_STRING_LEN, f, 1))
		    >= MAX_STRING_LEN - 1) {
		/* soak up the extra data */
d368 6
a373 2
	    if (len == 0) /* time to exit the larger loop as well */
		break;
d376 10
d389 2
a390 1
long int ap_proxy_send_fb(BUFF *f, request_rec *r, cache_req *c)
a391 1
    int  ok = 1;
d393 2
a394 2
    long total_bytes_rcv;
    register int n, o, w;
d396 2
a397 13
    int alt_to = 1;

    total_bytes_rcv = 0;
    if (c)
        c->written = 0;

#ifdef CHARSET_EBCDIC
    /* The cache copy is ASCII, not EBCDIC, even for text/html) */
    ap_bsetflag(f, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);
    if (c != NULL && c->fp != NULL)
	ap_bsetflag(c->fp, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);
    ap_bsetflag(con->client, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);
#endif
d403 1
d405 5
a409 40
    ap_kill_timeout(r);

#ifdef WIN32
    /* works fine under win32, so leave it */
    ap_hard_timeout("proxy send body", r);
    alt_to = 0;
#else
    /* CHECKME! Since hard_timeout won't work in unix on sends with partial
     * cache completion, we have to alternate between hard_timeout
     * for reads, and soft_timeout for send.  This is because we need
     * to get a return from ap_bwrite to be able to continue caching.
     * BUT, if we *can't* continue anyway, just use hard_timeout.
     */

    if (c) {
        if (c->len <= 0 || c->cache_completion == 1) {
            ap_hard_timeout("proxy send body", r);
            alt_to = 0;
        }
    } else {
        ap_hard_timeout("proxy send body", r);
        alt_to = 0;
    }
#endif

    while (ok) {
        if (alt_to)
            ap_hard_timeout("proxy send body", r);

	/* Read block from server */
	n = ap_bread(f, buf, IOBUFSIZE);

        if (alt_to)
            ap_kill_timeout(r);
        else
            ap_reset_timeout(r);

	if (n == -1) {		/* input error */
	    if (c != NULL)
		c = ap_proxy_cache_error(c);
d412 3
a414 25
	if (n == 0)
	    break;		/* EOF */
	o = 0;
	total_bytes_rcv += n;

	/* Write to cache first. */
        if (c != NULL && c->fp != NULL) {
            if (ap_bwrite(c->fp, &buf[0], n) != n) {
                c = ap_proxy_cache_error(c);
            } else {
                c->written += n;
            }
        }

	/* Write the block to the client, detect aborted transfers */
        while (n && !con->aborted) {
            if (alt_to)
                ap_soft_timeout("proxy send body", r);

            w = ap_bwrite(con->client, &buf[o], n);

            if (alt_to)
                ap_kill_timeout(r);
            else
                ap_reset_timeout(r);
d416 5
d422 4
a425 15
                if (c != NULL) {
                    /* when a send failure occurs, we need to decide
                     * whether to continue loading and caching the
                     * document, or to abort the whole thing
                     */
                    ok = (c->len > 0) &&
                         (c->cache_completion > 0) &&
                         (c->len * c->cache_completion < total_bytes_rcv);

                    if (! ok) {
                        ap_pclosef(c->req->pool, c->fp->fd);
                        c->fp = NULL;
                        unlink(c->tempfile);
			c = NULL;
                    }
a426 1
                con->aborted = 1;
d429 3
a431 2
            n -= w;
            o += w;
d434 57
d492 1
a492 2
    if (!con->aborted)
	ap_bflush(con->client);
d494 3
a496 2
    ap_kill_timeout(r);
    return total_bytes_rcv;
d500 1
a500 4
 * Sends response line and headers.  Uses the client fd and the 
 * headers_out array from the passed request_rec to talk to the client
 * and to properly set the headers it sends for things such as logging.
 * 
d503 2
a504 1
void ap_proxy_send_headers(request_rec *r, const char *respline, table *t)
d506 1
a507 2
    BUFF *fp = r->connection->client;
    table_entry *elts = (table_entry *) ap_table_elts(t)->elts;
d509 1
a509 2
    ap_bputs(respline, fp);
    ap_bputs(CRLF, fp);
d511 6
a516 7
    for (i = 0; i < ap_table_elts(t)->nelts; ++i) {
	if (elts[i].key != NULL) {
	    ap_bvputs(fp, elts[i].key, ": ", elts[i].val, CRLF, NULL);
	    /* FIXME: @@@@@@ This used to be ap_table_set(), but I think
	     * ap_table_addn() is correct. MnKr */
	    ap_table_addn(r->headers_out, elts[i].key, elts[i].val);
	}
d519 1
a519 1
    ap_bputs(CRLF, fp);
d529 2
a530 1
int ap_proxy_liststr(const char *list, const char *val)
d537 2
a538 1
    while (list != NULL) {
d540 2
a541 1
	if (p != NULL) {
d543 2
a544 4
	    do
		p++;
	    while (ap_isspace(*p));
	}
d548 2
a549 4
	while (i > 0 && ap_isspace(list[i - 1]))
	    i--;
	if (i == len && strncasecmp(list, val, len) == 0)
	    return 1;
d555 2
a556 7
#ifdef WIN32

/*
 * On NT, the file system is NOT case sensitive. So, a == A
 * need to map to smaller set of characters
 */
void ap_proxy_hash(const char *it, char *val, int ndepth, int nlength)
d558 1
a558 1
    AP_MD5_CTX context;
d560 1
a560 1
    char tmp[26];
d563 2
a564 1
    static const char enc_table[32] = "abcdefghijklmnopqrstuvwxyz012345";
d566 3
a568 58
    ap_MD5Init(&context);
    ap_MD5Update(&context, (const unsigned char *) it, strlen(it));
    ap_MD5Final(digest, &context);

/* encode 128 bits as 26 characters, using a modified uuencoding */
/* the encoding is 5 bytes -> 8 characters
 * i.e. 128 bits is 3 x 5 bytes + 1 byte -> 3 * 8 characters + 2 characters
 */
    for (i = 0, k = 0; i < 15; i += 5) {
	x = (digest[i] << 24) | (digest[i + 1] << 16) | (digest[i + 2] << 8) | digest[i + 3];
	tmp[k++] = enc_table[x >> 27];
	tmp[k++] = enc_table[(x >> 22) & 0x1f];
	tmp[k++] = enc_table[(x >> 17) & 0x1f];
	tmp[k++] = enc_table[(x >> 12) & 0x1f];
	tmp[k++] = enc_table[(x >> 7) & 0x1f];
	tmp[k++] = enc_table[(x >> 2) & 0x1f];
	x = ((x & 0x3) << 8) | digest[i + 4];
	tmp[k++] = enc_table[x >> 5];
	tmp[k++] = enc_table[x & 0x1f];
    }
/* one byte left */
    x = digest[15];
    tmp[k++] = enc_table[x >> 3];	/* use up 5 bits */
    tmp[k++] = enc_table[x & 0x7];
    /* now split into directory levels */

    for (i = k = d = 0; d < ndepth; ++d) {
	memcpy(&val[i], &tmp[k], nlength);
	k += nlength;
	val[i + nlength] = '/';
	i += nlength + 1;
    }
    memcpy(&val[i], &tmp[k], 26 - k);
    val[i + 26 - k] = '\0';
}

#else

void ap_proxy_hash(const char *it, char *val, int ndepth, int nlength)
{
    AP_MD5_CTX context;
    unsigned char digest[16];
    char tmp[22];
    int i, k, d;
    unsigned int x;
#if defined(AIX) && defined(__ps2__)
    /* Believe it or not, AIX 1.x does not allow you to name a file '@@',
     * so hack around it in the encoding. */
    static const char enc_table[64] =
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_%";
#else
    static const char enc_table[64] =
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_@@";
#endif

    ap_MD5Init(&context);
    ap_MD5Update(&context, (const unsigned char *) it, strlen(it));
    ap_MD5Final(digest, &context);
d574 7
a580 6
    for (i = 0, k = 0; i < 15; i += 3) {
	x = (digest[i] << 16) | (digest[i + 1] << 8) | digest[i + 2];
	tmp[k++] = enc_table[x >> 18];
	tmp[k++] = enc_table[(x >> 12) & 0x3f];
	tmp[k++] = enc_table[(x >> 6) & 0x3f];
	tmp[k++] = enc_table[x & 0x3f];
d584 2
a585 2
    tmp[k++] = enc_table[x >> 2];	/* use up 6 bits */
    tmp[k++] = enc_table[(x << 4) & 0x3f];
d588 9
a596 8
    for (i = k = d = 0; d < ndepth; ++d) {
	memcpy(&val[i], &tmp[k], nlength);
	k += nlength;
	val[i + nlength] = '/';
	i += nlength + 1;
    }
    memcpy(&val[i], &tmp[k], 22 - k);
    val[i + 22 - k] = '\0';
a598 2
#endif /* WIN32 */

d602 2
a603 1
int ap_proxy_hex2sec(const char *x)
d608 2
a609 1
    for (i = 0, j = 0; i < 8; i++) {
d612 3
a614 6
	if (ap_isdigit(ch))
	    j |= ch - '0';
	else if (ap_isupper(ch))
	    j |= ch - ('A' - 10);
	else
	    j |= ch - ('a' - 10);
d616 2
a617 4
    if (j == 0xffffffff)
	return -1;		/* so that it works with 8-byte ints */
    else
	return j;
d623 2
a624 1
void ap_proxy_sec2hex(int t, char *y)
d627 1
a627 1
    unsigned int j = t;
d629 2
a630 1
    for (i = 7; i >= 0; i--) {
d633 2
a634 4
	if (ch >= 10)
	    y[i] = ch + ('A' - 10);
	else
	    y[i] = ch + '0';
d639 26
d666 2
a667 1
cache_req *ap_proxy_cache_error(cache_req *c)
d669 4
a672 4
    ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
		 "proxy: error writing to cache file %s", c->tempfile);
    ap_pclosef(c->req->pool, c->fp->fd);
    c->fp = NULL;
d677 2
a678 1
int ap_proxyerror(request_rec *r, const char *message)
d680 1
a680 6
    ap_table_setn(r->notes, "error-notes",
		  ap_pstrcat(r->pool, 
			     "The proxy server could not handle the request "
			     "<EM><A HREF=\"", r->uri, "\">",
			     r->method, "&nbsp;", r->uri, "</A></EM>.<P>\n"
			     "Reason: <STRONG>", message, "</STRONG>", NULL));
d682 13
a694 1
    return HTTP_INTERNAL_SERVER_ERROR;
d701 1
a701 1
     ap_proxy_host2addr(const char *host, struct hostent *reqhp)
d705 3
a707 3
    static APACHE_TLS struct hostent hpbuf;
    static APACHE_TLS u_long ipaddr;
    static APACHE_TLS char *charpbuf[2];
d709 2
a710 2
    for (i = 0; host[i] != '\0'; i++)
	if (!ap_isdigit(host[i]) && host[i] != '.')
d713 2
a714 1
    if (host[i] != '\0') {
d718 4
a721 4
    }
    else {
	ipaddr = ap_inet_addr(host);
	hp = gethostbyaddr((char *) &ipaddr, sizeof(u_long), AF_INET);
d728 1
a728 1
	    hpbuf.h_addr_list[0] = (char *) &ipaddr;
d733 1
a733 1
    *reqhp = *hp;
d737 2
a738 2
static const char *
     proxy_get_host_of_request(request_rec *r)
a739 263
    char *url, *user = NULL, *password = NULL, *err, *host;
    int port = -1;

    if (r->hostname != NULL)
	return r->hostname;

    /* Set url to the first char after "scheme://" */
    if ((url = strchr(r->uri, ':')) == NULL
	|| url[1] != '/' || url[2] != '/')
	return NULL;

    url = ap_pstrdup(r->pool, &url[1]);	/* make it point to "//", which is what proxy_canon_netloc expects */

    err = ap_proxy_canon_netloc(r->pool, &url, &user, &password, &host, &port);

    if (err != NULL)
	ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
		     "%s", err);

    r->hostname = host;

    return host;		/* ought to return the port, too */
}

/* Return TRUE if addr represents an IP address (or an IP network address) */
int ap_proxy_is_ipaddr(struct dirconn_entry *This, pool *p)
{
    const char *addr = This->name;
    long ip_addr[4];
    int i, quads;
    long bits;

    /* if the address is given with an explicit netmask, use that */
    /* Due to a deficiency in ap_inet_addr(), it is impossible to parse */
    /* "partial" addresses (with less than 4 quads) correctly, i.e.  */
    /* 192.168.123 is parsed as 192.168.0.123, which is not what I want. */
    /* I therefore have to parse the IP address manually: */
    /*if (proxy_readmask(This->name, &This->addr.s_addr, &This->mask.s_addr) == 0) */
    /* addr and mask were set by proxy_readmask() */
    /*return 1; */

    /* Parse IP addr manually, optionally allowing */
    /* abbreviated net addresses like 192.168. */

    /* Iterate over up to 4 (dotted) quads. */
    for (quads = 0; quads < 4 && *addr != '\0'; ++quads) {
	char *tmp;

	if (*addr == '/' && quads > 0)	/* netmask starts here. */
	    break;

	if (!ap_isdigit(*addr))
	    return 0;		/* no digit at start of quad */

	ip_addr[quads] = strtol(addr, &tmp, 0);

	if (tmp == addr)	/* expected a digit, found something else */
	    return 0;

	if (ip_addr[quads] < 0 || ip_addr[quads] > 255) {
	    /* invalid octet */
	    return 0;
	}

	addr = tmp;

	if (*addr == '.' && quads != 3)
	    ++addr;		/* after the 4th quad, a dot would be illegal */
    }

    for (This->addr.s_addr = 0, i = 0; i < quads; ++i)
	This->addr.s_addr |= htonl(ip_addr[i] << (24 - 8 * i));

    if (addr[0] == '/' && ap_isdigit(addr[1])) {	/* net mask follows: */
	char *tmp;

	++addr;

	bits = strtol(addr, &tmp, 0);

	if (tmp == addr)	/* expected a digit, found something else */
	    return 0;

	addr = tmp;

	if (bits < 0 || bits > 32)	/* netmask must be between 0 and 32 */
	    return 0;

    }
    else {
	/* Determine (i.e., "guess") netmask by counting the */
	/* number of trailing .0's; reduce #quads appropriately */
	/* (so that 192.168.0.0 is equivalent to 192.168.)        */
	while (quads > 0 && ip_addr[quads - 1] == 0)
	    --quads;

	/* "IP Address should be given in dotted-quad form, optionally followed by a netmask (e.g., 192.168.111.0/24)"; */
	if (quads < 1)
	    return 0;

	/* every zero-byte counts as 8 zero-bits */
	bits = 8 * quads;

	if (bits != 32)		/* no warning for fully qualified IP address */
	    fprintf(stderr, "Warning: NetMask not supplied with IP-Addr; guessing: %s/%ld\n",
		    inet_ntoa(This->addr), bits);
    }

    This->mask.s_addr = htonl(INADDR_NONE << (32 - bits));

    if (*addr == '\0' && (This->addr.s_addr & ~This->mask.s_addr) != 0) {
	fprintf(stderr, "Warning: NetMask and IP-Addr disagree in %s/%ld\n",
		inet_ntoa(This->addr), bits);
	This->addr.s_addr &= This->mask.s_addr;
	fprintf(stderr, "         Set to %s/%ld\n",
		inet_ntoa(This->addr), bits);
    }

    if (*addr == '\0') {
	This->matcher = proxy_match_ipaddr;
	return 1;
    }
    else
	return (*addr == '\0');	/* okay iff we've parsed the whole string */
}

/* Return TRUE if addr represents an IP address (or an IP network address) */
static int proxy_match_ipaddr(struct dirconn_entry *This, request_rec *r)
{
    int i;
    int ip_addr[4];
    struct in_addr addr;
    struct in_addr *ip_list;
    char **ip_listptr;
    const char *found;
    const char *host = proxy_get_host_of_request(r);

    if (host == NULL)   /* oops! */
       return 0;

    memset(&addr, '\0', sizeof addr);
    memset(ip_addr, '\0', sizeof ip_addr);

    if (4 == sscanf(host, "%d.%d.%d.%d", &ip_addr[0], &ip_addr[1], &ip_addr[2], &ip_addr[3])) {
	for (addr.s_addr = 0, i = 0; i < 4; ++i)
	    addr.s_addr |= htonl(ip_addr[i] << (24 - 8 * i));

	if (This->addr.s_addr == (addr.s_addr & This->mask.s_addr)) {
#if DEBUGGING
	    fprintf(stderr, "1)IP-Match: %s[%s] <-> ", host, inet_ntoa(addr));
	    fprintf(stderr, "%s/", inet_ntoa(This->addr));
	    fprintf(stderr, "%s\n", inet_ntoa(This->mask));
#endif
	    return 1;
	}
#if DEBUGGING
	else {
	    fprintf(stderr, "1)IP-NoMatch: %s[%s] <-> ", host, inet_ntoa(addr));
	    fprintf(stderr, "%s/", inet_ntoa(This->addr));
	    fprintf(stderr, "%s\n", inet_ntoa(This->mask));
	}
#endif
    }
    else {
	struct hostent the_host;

	memset(&the_host, '\0', sizeof the_host);
	found = ap_proxy_host2addr(host, &the_host);

	if (found != NULL) {
#if DEBUGGING
	    fprintf(stderr, "2)IP-NoMatch: hostname=%s msg=%s\n", host, found);
#endif
	    return 0;
	}

	if (the_host.h_name != NULL)
	    found = the_host.h_name;
	else
	    found = host;

	/* Try to deal with multiple IP addr's for a host */
	for (ip_listptr = the_host.h_addr_list; *ip_listptr; ++ip_listptr) {
	    ip_list = (struct in_addr *) *ip_listptr;
	    if (This->addr.s_addr == (ip_list->s_addr & This->mask.s_addr)) {
#if DEBUGGING
		fprintf(stderr, "3)IP-Match: %s[%s] <-> ", found, inet_ntoa(*ip_list));
		fprintf(stderr, "%s/", inet_ntoa(This->addr));
		fprintf(stderr, "%s\n", inet_ntoa(This->mask));
#endif
		return 1;
	    }
#if DEBUGGING
	    else {
		fprintf(stderr, "3)IP-NoMatch: %s[%s] <-> ", found, inet_ntoa(*ip_list));
		fprintf(stderr, "%s/", inet_ntoa(This->addr));
		fprintf(stderr, "%s\n", inet_ntoa(This->mask));
	    }
#endif
	}
    }

    return 0;
}

/* Return TRUE if addr represents a domain name */
int ap_proxy_is_domainname(struct dirconn_entry *This, pool *p)
{
    char *addr = This->name;
    int i;

    /* Domain name must start with a '.' */
    if (addr[0] != '.')
	return 0;

    /* rfc1035 says DNS names must consist of "[-a-zA-Z0-9]" and '.' */
    for (i = 0; ap_isalnum(addr[i]) || addr[i] == '-' || addr[i] == '.'; ++i)
	continue;

#if 0
    if (addr[i] == ':') {
	fprintf(stderr, "@@@@@@@@ handle optional port in proxy_is_domainname()\n");
	/* @@@@@@@@ handle optional port */
    }
#endif

    if (addr[i] != '\0')
	return 0;

    /* Strip trailing dots */
    for (i = strlen(addr) - 1; i > 0 && addr[i] == '.'; --i)
	addr[i] = '\0';

    This->matcher = proxy_match_domainname;
    return 1;
}

/* Return TRUE if host "host" is in domain "domain" */
static int proxy_match_domainname(struct dirconn_entry *This, request_rec *r)
{
    const char *host = proxy_get_host_of_request(r);
    int d_len = strlen(This->name), h_len;

    if (host == NULL)		/* some error was logged already */
	return 0;

    h_len = strlen(host);

    /* @@@@@@ do this within the setup? */
    /* Ignore trailing dots in domain comparison: */
    while (d_len > 0 && This->name[d_len - 1] == '.')
	--d_len;
    while (h_len > 0 && host[h_len - 1] == '.')
	--h_len;
    return h_len > d_len
	&& strncasecmp(&host[h_len - d_len], This->name, d_len) == 0;
}

/* Return TRUE if addr represents a host name */
int ap_proxy_is_hostname(struct dirconn_entry *This, pool *p)
{
    struct hostent host;
    char *addr = This->name;
d742 5
a746 91
    /* Host names must not start with a '.' */
    if (addr[0] == '.')
	return 0;

    /* rfc1035 says DNS names must consist of "[-a-zA-Z0-9]" and '.' */
    for (i = 0; ap_isalnum(addr[i]) || addr[i] == '-' || addr[i] == '.'; ++i);

#if 0
    if (addr[i] == ':') {
	fprintf(stderr, "@@@@@@@@ handle optional port in proxy_is_hostname()\n");
	/* @@@@@@@@ handle optional port */
    }
#endif

    if (addr[i] != '\0' || ap_proxy_host2addr(addr, &host) != NULL)
	return 0;

    This->hostentry = ap_pduphostent (p, &host);

    /* Strip trailing dots */
    for (i = strlen(addr) - 1; i > 0 && addr[i] == '.'; --i)
	addr[i] = '\0';

    This->matcher = proxy_match_hostname;
    return 1;
}

/* Return TRUE if host "host" is equal to host2 "host2" */
static int proxy_match_hostname(struct dirconn_entry *This, request_rec *r)
{
    char *host = This->name;
    const char *host2 = proxy_get_host_of_request(r);
    int h2_len;
    int h1_len;

    if (host == NULL || host2 == NULL)
       return 0; /* oops! */

    h2_len = strlen(host2);
    h1_len = strlen(host);

#if 0
    unsigned long *ip_list;

    /* Try to deal with multiple IP addr's for a host */
    for (ip_list = *This->hostentry->h_addr_list; *ip_list != 0UL; ++ip_list)
	if (*ip_list == ? ? ? ? ? ? ? ? ? ? ? ? ?)
	    return 1;
#endif

    /* Ignore trailing dots in host2 comparison: */
    while (h2_len > 0 && host2[h2_len - 1] == '.')
	--h2_len;
    while (h1_len > 0 && host[h1_len - 1] == '.')
	--h1_len;
    return h1_len == h2_len
	&& strncasecmp(host, host2, h1_len) == 0;
}

/* Return TRUE if addr is to be matched as a word */
int ap_proxy_is_word(struct dirconn_entry *This, pool *p)
{
    This->matcher = proxy_match_word;
    return 1;
}

/* Return TRUE if string "str2" occurs literally in "str1" */
static int proxy_match_word(struct dirconn_entry *This, request_rec *r)
{
    const char *host = proxy_get_host_of_request(r);
    return host != NULL && strstr(host, This->name) != NULL;
}

int ap_proxy_doconnect(int sock, struct sockaddr_in *addr, request_rec *r)
{
    int i;

    ap_hard_timeout("proxy connect", r);
    do {
	i = connect(sock, (struct sockaddr *) addr, sizeof(struct sockaddr_in));
#ifdef WIN32
	if (i == SOCKET_ERROR)
	    errno = WSAGetLastError();
#endif /* WIN32 */
    } while (i == -1 && errno == EINTR);
    if (i == -1) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "proxy connect to %s port %d failed",
		     inet_ntoa(addr->sin_addr), ntohs(addr->sin_port));
    }
    ap_kill_timeout(r);
a748 26
}

/* This function is called by ap_table_do() for all header lines */
/* (from proxy_http.c and proxy_ftp.c) */
/* It is passed a table_do_args struct pointer and a MIME field and value pair */
int ap_proxy_send_hdr_line(void *p, const char *key, const char *value)
{
    struct tbl_do_args *parm = (struct tbl_do_args *)p;

    if (key == NULL || value == NULL || value[0] == '\0')
	return 1;
    if (!parm->req->assbackwards)
	ap_rvputs(parm->req, key, ": ", value, CRLF, NULL);
    if (parm->cache != NULL && parm->cache->fp != NULL &&
	ap_bvputs(parm->cache->fp, key, ": ", value, CRLF, NULL) == -1)
	    parm->cache = ap_proxy_cache_error(parm->cache);
    return 1; /* tell ap_table_do() to continue calling us for more headers */
}

/* send a text line to one or two BUFF's; return line length */
unsigned ap_proxy_bputs2(const char *data, BUFF *client, cache_req *cache)
{
    unsigned len = ap_bputs(data, client);
    if (cache != NULL && cache->fp != NULL)
	ap_bputs(data, cache->fp);
    return len;
@


1.1.1.3
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 9
a24 6
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
d26 3
a28 4
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
d30 4
a33 3
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
d35 4
a38 4
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 5
a54 3
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
a55 3
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
d65 1
a65 1
#include "util_date.h"          /* get ap_checkmask() decl. */
d71 1
a71 1
static struct per_thread_data *get_per_thread_data(void);
d75 2
a76 1
    int i;
a77 2
    int ch;

d80 1
a80 1
        i = ch - '0';
d82 1
a82 1
        i = ch - ('A' - 10);
d84 1
a84 1
        i = ch - ('a' - 10);
d89 1
a89 1
        i += ch - '0';
d91 1
a91 1
        i += ch - ('A' - 10);
d93 1
a93 1
        i += ch - ('a' - 10);
d95 3
a97 3
#else                           /* CHARSET_EBCDIC */
    return (1 == sscanf(x, "%2x", &i)) ? os_toebcdic[i & 0xFF] : 0;
#endif                          /* CHARSET_EBCDIC */
d108 1
a108 1
        x[1] = ('A' - 10) + i;
d110 1
a110 1
        x[1] = '0' + i;
d114 1
a114 1
        x[2] = ('A' - 10) + i;
d116 4
a119 4
        x[2] = '0' + i;
#else                           /* CHARSET_EBCDIC */
    static const char ntoa[] = {"0123456789ABCDEF"};
    ch = os_toascii[ch & 0xFF];
d121 2
a122 2
    x[1] = ntoa[(ch >> 4) & 0x0F];
    x[2] = ntoa[ch & 0x0F];
d124 1
a124 1
#endif                          /* CHARSET_EBCDIC */
d137 2
a138 2
char *ap_proxy_canonenc(pool *p, const char *x, int len, enum enctype t,
                             enum proxyreqtype isenc)
d142 2
a143 2
    const char *allowed;        /* characters which should not be encoded */
    const char *reserved;       /* characters which much not be en/de-coded */
d147 1
a147 1
 *
d153 1
a153 1
        allowed = "$-_.+!*'(),;:@@&=";
d155 1
a155 1
        allowed = "$-_.!*'(),;:@@&=";
d157 1
a157 1
        allowed = "$-_.+!*'(),;@@&=";
d159 3
a161 3
        allowed = "$-_.+!*'(),?:@@&=";
    else                        /* if (t == enc_parm) */
        allowed = "$-_.+!*'(),?/:@@&=";
d164 1
a164 1
        reserved = "/";
d166 1
a166 1
        reserved = "+";
d168 1
a168 1
        reserved = "";
d174 5
a178 5
        ch = x[i];
        if (strchr(reserved, ch)) {
            y[j] = ch;
            continue;
        }
d180 11
a190 11
        if (isenc != NOT_PROXY && ch == '%') {
            if (!ap_isxdigit(x[i + 1]) || !ap_isxdigit(x[i + 2]))
                return NULL;
            ch = ap_proxy_hex2c(&x[i + 1]);
            i += 2;
            if (ch != 0 && strchr(reserved, ch)) {      /* keep it encoded */
                ap_proxy_c2hex(ch, &y[j]);
                j += 2;
                continue;
            }
        }
d192 6
a197 6
        if (!ap_isalnum(ch) && !strchr(allowed, ch)) {
            ap_proxy_c2hex(ch, &y[j]);
            j += 2;
        }
        else
            y[j] = ch;
d215 1
a215 1
                                char **passwordp, char **hostp, int *port)
d222 1
a222 1
        return "Malformed URL";
d226 1
a226 1
        url = "";
d228 1
a228 1
        *(url++) = '\0';        /* skip seperating '/' */
d234 3
a236 3
        *strp = '\0';
        user = host;
        host = strp + 1;
d239 11
a249 11
        strp = strchr(user, ':');
        if (strp != NULL) {
            *strp = '\0';
            password = ap_proxy_canonenc(p, strp + 1, strlen(strp + 1), enc_user, STD_PROXY);
            if (password == NULL)
                return "Bad %-escape in URL (password)";
        }

        user = ap_proxy_canonenc(p, user, strlen(user), enc_user, STD_PROXY);
        if (user == NULL)
            return "Bad %-escape in URL (username)";
d252 1
a252 1
        *userp = user;
d255 1
a255 1
        *passwordp = password;
d260 1
a260 5
        *(strp++) = '\0';

        for (i = 0; strp[i] != '\0'; i++)
            if (!ap_isdigit(strp[i]))
                break;
d262 9
a270 9
        /* if (i == 0) the no port was given; keep default */
        if (strp[i] != '\0') {
            return "Bad port number in URL";
        }
        else if (i > 0) {
            *port = atoi(strp);
            if (*port > 65535)
                return "Port number in URL > 65535";
        }
d272 1
a272 1
    ap_str_tolower(host);       /* DNS names are case-insensitive */
d274 1
a274 1
        return "Missing host in URL";
d277 2
a278 2
        if (!ap_isdigit(host[i]) && host[i] != '.')
            break;
d280 1
a280 1
#if defined(WIN32) || defined(NETWARE) || defined(TPF) || defined(BEOS)
d286 1
a286 1
        return "Bad IP address in URL";
d298 1
a298 1
static const char *const lwday[7] =
d317 17
a333 17
        *q = '\0';
        for (wk = 0; wk < 7; wk++)
            if (strcmp(x, lwday[wk]) == 0)
                break;
        *q = ',';
        if (wk == 7)
            return x;           /* not a valid date */
        if (q[4] != '-' || q[8] != '-' || q[11] != ' ' || q[14] != ':' ||
            q[17] != ':' || strcmp(&q[20], " GMT") != 0)
            return x;
        if (sscanf(q + 2, "%u-%3s-%u %u:%u:%u %3s", &mday, month, &year,
                   &hour, &min, &sec, zone) != 7)
            return x;
        if (year < 70)
            year += 2000;
        else
            year += 1900;
d337 11
a347 11
        if (x[3] != ' ' || x[7] != ' ' || x[10] != ' ' || x[13] != ':' ||
            x[16] != ':' || x[19] != ' ' || x[24] != '\0')
            return x;
        if (sscanf(x, "%3s %3s %u %u:%u:%u %u", week, month, &mday, &hour,
                   &min, &sec, &year) != 7)
            return x;
        for (wk = 0; wk < 7; wk++)
            if (strcmp(week, ap_day_snames[wk]) == 0)
                break;
        if (wk == 7)
            return x;
d352 2
a353 2
        if (strcmp(month, ap_month_snames[mon]) == 0)
            break;
d355 1
a355 1
        return x;
d359 1
a359 1
                ap_month_snames[mon], year, hour, min, sec);
d364 57
d425 2
a426 5
 *
 * Note: Currently the headers are passed through unmerged. This has to be
 * done so that headers which react badly to merging (such as Set-Cookie
 * headers, which contain commas within the date field) do not get stuffed
 * up.
d441 20
a460 22
    while ((len = ap_getline(buffer, size, f, 1)) > 0) {

        if (!(value = strchr(buffer, ':'))) {   /* Find the colon separator */

            /*
             * Buggy MS IIS servers sometimes return invalid headers (an
             * extra "HTTP/1.0 200, OK" line sprinkled in between the usual
             * MIME headers). Try to deal with it in a sensible way, but log
             * the fact. XXX: The mask check is buggy if we ever see an
             * HTTP/1.10
             */

            if (!ap_checkmask(buffer, "HTTP/#.# ###*")) {
                /* Nope, it wasn't even an extra HTTP header. Give up. */
                return NULL;
            }

            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_NOERRNO, r->server,
                         "proxy: Ignoring duplicate HTTP status line "
                         "returned by buggy server %s (%s)", r->uri, r->method);
            continue;
        }
d464 3
a466 4
        /*
         * XXX: RFC2068 defines only SP and HT as whitespace, this test is
         * wrong... and so are many others probably.
         */
d470 3
a472 3
        /* should strip trailing whitespace as well */
        for (end = &value[strlen(value) - 1]; end > value && ap_isspace(*end); --end)
            *end = '\0';
a473 1
        /* make sure we add so as not to destroy duplicated headers */
d476 9
a484 9
        /* the header was too long; at the least we should skip extra data */
        if (len >= size - 1) {
            while ((len = ap_getline(field, MAX_STRING_LEN, f, 1))
                   >= MAX_STRING_LEN - 1) {
                /* soak up the extra data */
            }
            if (len == 0)       /* time to exit the larger loop as well */
                break;
        }
d489 1
a489 6
/* read data from (socket BUFF*) f, write it to:
 * - c->fp, if it is open
 * - r->connection->client, if nowrite == 0
 */

long int ap_proxy_send_fb(BUFF *f, request_rec *r, cache_req *c, off_t len, int nowrite, int chunked, size_t recv_buffer_size)
d491 4
a494 6
    int ok, end_of_chunk;
    char *buf;
    size_t buf_size;
    long remaining = 0;
    long total_bytes_rcvd;
    register int n = 0, o, w;
d496 1
a496 10
    int alternate_timeouts = 1; /* 1 if we alternate between soft & hard
                                 * timeouts */

    /* allocate a buffer to store the bytes in */
    /*
     * make sure it is at least IOBUFSIZE, as recv_buffer_size may be zero
     * for system default
     */
    buf_size = MAX(recv_buffer_size, IOBUFSIZE);
    buf = ap_palloc(r->pool, buf_size);
d498 2
a499 2
    total_bytes_rcvd = 0;
    if (c != NULL)
d504 4
a507 2
    ap_bsetflag(f, B_ASCII2EBCDIC | B_EBCDIC2ASCII, 0);
    ap_bsetflag(con->client, B_ASCII2EBCDIC | B_EBCDIC2ASCII, 0);
d510 3
a512 4
    /*
     * Since we are reading from one buffer and writing to another, it is
     * unsafe to do a soft_timeout here, at least until the proxy has its own
     * timeout handler which can set both buffers to EOUT.
d517 1
a517 1
#if defined(WIN32) || defined(TPF) || defined(NETWARE)
d520 1
a520 1
    alternate_timeouts = 0;
d522 5
a526 7
    /*
     * CHECKME! Since hard_timeout won't work in unix on sends with partial
     * cache completion, we have to alternate between hard_timeout for reads,
     * and soft_timeout for send.  This is because we need to get a return
     * from ap_bwrite to be able to continue caching. BUT, if we *can't*
     * continue anyway, just use hard_timeout. (Also, if no cache file is
     * written, use hard timeouts)
d529 6
a534 1
    if (c == NULL || c->len <= 0 || c->cache_completion == 1.0) {
d536 1
a536 1
        alternate_timeouts = 0;
d540 3
a542 90
    /*
     * Loop and ap_bread() while we can successfully read and write, or
     * (after the client aborted) while we can successfully read and finish
     * the configured cache_completion.
     */
    for (end_of_chunk = ok = 1; ok;) {
        if (alternate_timeouts)
            ap_hard_timeout("proxy recv body from upstream server", r);


        /* read a chunked block */
        if (chunked) {
            long chunk_start = 0;
            n = 0;

            /* start of a new chunk */
            if (end_of_chunk) {
                end_of_chunk = 0;
                /* get the chunk size from the stream */
                chunk_start = ap_getline(buf, buf_size, f, 0);
                if ((chunk_start <= 0) || ((size_t)chunk_start + 1 >= buf_size) || !ap_isxdigit(*buf)) {
                    n = -1;
                }
                /* parse the chunk size */
                else {
                    remaining = ap_get_chunk_size(buf);
                    if (remaining == 0) { /* Last chunk indicated, get footers */
                        /* as we are a proxy, we discard the footers, as the headers
                         * have already been sent at this point.
                         */
                        if (NULL == ap_proxy_read_headers(r, buf, buf_size, f)) {
                            n = -1;
                        }
                    }
                    else if (remaining < 0) {
                        n = -1;
                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                                      "proxy: remote protocol error, invalid chunk size");

                    }
                }
            }

            /* read the chunk */
            if (remaining > 0) {
                n = ap_bread(f, buf, MIN((int)buf_size, (int)remaining));
                if (n > -1) {
                    remaining -= n;
                    end_of_chunk = (remaining == 0);
                }
            }

            /* soak up trailing CRLF */
            if (end_of_chunk) {
                int ch; /* int because it may hold an EOF */
                /*
                 * For EBCDIC, the proxy has configured the BUFF layer to
                 * transparently pass the ascii characters thru (also writing
                 * an ASCII copy to the cache, where appropriate).
                 * Therefore, we see here an ASCII-CRLF (\015\012),
                 * not an EBCDIC-CRLF (\r\n).
                 */
                if ((ch = ap_bgetc(f)) == EOF) {
                    /* Protocol error: EOF detected within chunk */
                    n = -1;
                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                                  "proxy: remote protocol error, eof while reading chunked from proxy");
                }
                else
                {
                    if (ch == '\015') { /* _ASCII_ CR */
                        ch = ap_bgetc(f);
                    }
                    if (ch != '\012') {
                        n = -1;
                    }
                }
            }
        }

        /* otherwise read block normally */
        else {
            if (-1 == len) {
                n = ap_bread(f, buf, buf_size);
            }
            else {
                n = ap_bread(f, buf, MIN((int)buf_size,
                                         (int)(len - total_bytes_rcvd)));
            }
        }
d544 2
d547 1
a547 1
        if (alternate_timeouts)
d552 9
a560 25
        if (n == -1) {          /* input error */
            if (c != NULL) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                              "proxy: error reading from %s", c->url);
                c = ap_proxy_cache_error(c);
            }
            break;
        }
        if (n == 0)
            break;              /* EOF */
        o = 0;
        total_bytes_rcvd += n;

        /* if we've received everything... */
        /*
         * in the case of slow frontends and expensive backends, we want to
         * avoid leaving a backend connection hanging while the frontend
         * takes it's time to absorb the bytes. so: if we just read the last
         * block, we close the backend connection now instead of later - it's
         * no longer needed.
         */
        if (total_bytes_rcvd == len) {
            ap_bclose(f);
            f = NULL;
        }
d562 1
a562 5
        /* Write to cache first. */
        /*
         * @@@@@@ XXX FIXME: Assuming that writing the cache file won't time
         * out?!!?
         */
a564 2
                ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                              "proxy: error writing to %s", c->tempfile);
d566 1
a566 2
            }
            else {
d571 3
a573 3
        /* Write the block to the client, detect aborted transfers */
        while (!nowrite && !con->aborted && n > 0) {
            if (alternate_timeouts)
d578 1
a578 1
            if (alternate_timeouts)
d585 3
a587 4
                    /*
                     * when a send failure occurs, we need to decide whether
                     * to continue loading and caching the document, or to
                     * abort the whole thing
d590 2
a591 2
                        (c->cache_completion > 0) &&
                        (c->len * c->cache_completion < total_bytes_rcvd);
d593 3
a595 5
                    if (!ok) {
                        if (c->fp != NULL) {
                            ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR));
                            c->fp = NULL;
                        }
d597 1
a597 1
                        c = NULL;
d605 1
a605 11
        }                       /* while client alive and more data to send */

        /* if we've received everything, leave now */
        if (total_bytes_rcvd == len)
            break;

    }                           /* loop and ap_bread while "ok" */

    /* if the backend connection is still open, close it */
    if (f) {
        ap_bclose(f);
d608 2
a609 3
    if (!con->aborted) {
        ap_bflush(con->client);
    }
d612 1
a612 4

    r->bytes_sent += total_bytes_rcvd;

    return total_bytes_rcvd;
d616 5
a620 3
 * Writes response line and headers to the cache file.
 *
 * If respline is NULL, no response line will be written.
d622 1
a622 1
void ap_proxy_write_headers(cache_req *c, const char *respline, table *t)
d624 14
a637 17
    /* write status line */
    if (respline && c->fp != NULL &&
        ap_bvputs(c->fp, respline, CRLF, NULL) == -1) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                      "proxy: error writing status line to %s", c->tempfile);
        c = ap_proxy_cache_error(c);
        return;
    }

    /* write response headers to the cache file */
    ap_table_do(ap_proxy_send_hdr_line, c, t, NULL);

    /* write terminating CRLF */
    if (c->fp != NULL && ap_bputs(CRLF, c->fp) == -1) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                      "proxy: error writing CRLF to %s", c->tempfile);
        c = ap_proxy_cache_error(c);
d639 2
d650 1
a650 1
int ap_proxy_liststr(const char *list, const char *key, char **val)
a653 2
    char valbuf[HUGE_STRING_LEN];
    valbuf[sizeof(valbuf) - 1] = 0;     /* safety terminating zero */
d655 1
a655 1
    len = strlen(key);
d658 15
a672 29
        p = strchr(list, ',');
        if (p != NULL) {
            i = p - list;
            do
                p++;
            while (ap_isspace(*p));
        }
        else
            i = strlen(list);

        while (i > 0 && ap_isspace(list[i - 1]))
            i--;
        if (i == len && strncasecmp(list, key, len) == 0) {
            if (val) {
                p = strchr(list, ',');
                while (ap_isspace(*list)) {
                    list++;
                }
                if ('=' == list[0])
                    list++;
                while (ap_isspace(*list)) {
                    list++;
                }
                strncpy(valbuf, list, MIN(p - list, sizeof(valbuf) - 1));
                *val = valbuf;
            }
            return 1;
        }
        list = p;
d677 1
a677 1
#ifdef CASE_BLIND_FILESYSTEM
d680 1
a680 1
 * On some platforms, the file system is NOT case sensitive. So, a == A
d693 1
a693 1
    ap_MD5Update(&context, (const unsigned char *)it, strlen(it));
d701 10
a710 10
        x = (digest[i] << 24) | (digest[i + 1] << 16) | (digest[i + 2] << 8) | digest[i + 3];
        tmp[k++] = enc_table[x >> 27];
        tmp[k++] = enc_table[(x >> 22) & 0x1f];
        tmp[k++] = enc_table[(x >> 17) & 0x1f];
        tmp[k++] = enc_table[(x >> 12) & 0x1f];
        tmp[k++] = enc_table[(x >> 7) & 0x1f];
        tmp[k++] = enc_table[(x >> 2) & 0x1f];
        x = ((x & 0x3) << 8) | digest[i + 4];
        tmp[k++] = enc_table[x >> 5];
        tmp[k++] = enc_table[x & 0x1f];
d714 1
a714 1
    tmp[k++] = enc_table[x >> 3];       /* use up 5 bits */
d719 4
a722 4
        memcpy(&val[i], &tmp[k], nlength);
        k += nlength;
        val[i + nlength] = '/';
        i += nlength + 1;
d737 3
a739 5
#if defined(MPE) || (defined(AIX) && defined(__ps2__))
    /*
     * Believe it or not, AIX 1.x does not allow you to name a file '@@', so
     * hack around it in the encoding.
     */
d741 1
a741 1
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_%";
d744 1
a744 1
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_@@";
d748 1
a748 1
    ap_MD5Update(&context, (const unsigned char *)it, strlen(it));
d756 5
a760 5
        x = (digest[i] << 16) | (digest[i + 1] << 8) | digest[i + 2];
        tmp[k++] = enc_table[x >> 18];
        tmp[k++] = enc_table[(x >> 12) & 0x3f];
        tmp[k++] = enc_table[(x >> 6) & 0x3f];
        tmp[k++] = enc_table[x & 0x3f];
d764 1
a764 1
    tmp[k++] = enc_table[x >> 2];       /* use up 6 bits */
d769 4
a772 4
        memcpy(&val[i], &tmp[k], nlength);
        k += nlength;
        val[i + nlength] = '/';
        i += nlength + 1;
d778 1
a778 1
#endif                          /* CASE_BLIND_FILESYSTEM */
d781 1
a781 1
 * Converts 16 hex digits to a time integer
d788 9
a796 9
    for (i = 0, j = 0; i < 16; i++) {
        ch = x[i];
        j <<= 4;
        if (ap_isdigit(ch))
            j |= ch - '0';
        else if (ap_isupper(ch))
            j |= ch - ('A' - 10);
        else
            j |= ch - ('a' - 10);
d798 4
a801 5
/* no longer necessary, as the source hex is 8-byte int */
/*    if (j == 0xffffffff)*/
    /*      return -1;*//* so that it works with 8-byte ints */
/*    else */
    return j;
d805 1
a805 1
 * Converts a time integer to 16 hex digits
d812 7
a818 12
    if (-1 == t) {
        strcpy(y, "FFFFFFFFFFFFFFFF");
        return;
    }

    for (i = 15; i >= 0; i--) {
        ch = j & 0xF;
        j >>= 4;
        if (ch >= 10)
            y[i] = ch + ('A' - 10);
        else
            y[i] = ch + '0';
d820 1
a820 1
    y[16] = '\0';
d826 5
a830 12
    if (c != NULL) {
        if (c->fp != NULL) {
            ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR));
            c->fp = NULL;
        }
        if (c->origfp != NULL) {
            ap_pclosef(c->req->pool, ap_bfileno(c->origfp, B_WR));
            c->origfp = NULL;
        }
        if (c->tempfile)
            unlink(c->tempfile);
    }
d834 1
a834 1
int ap_proxyerror(request_rec *r, int statuscode, const char *message)
d837 7
a843 15
                  ap_pstrcat(r->pool,
                             "The proxy server could not handle the request "
                           "<EM><A HREF=\"", ap_escape_uri(r->pool, r->uri),
                             "\">", ap_escape_html(r->pool, r->method),
                             "&nbsp;",
                          ap_escape_html(r->pool, r->uri), "</A></EM>.<P>\n"
                             "Reason: <STRONG>",
                             ap_escape_html(r->pool, message),
                             "</STRONG>", NULL));

    /* Allow "error-notes" string to be printed by ap_send_error_response() */
    ap_table_setn(r->notes, "verbose-error-to", ap_pstrdup(r->pool, "*"));

    r->status_line = ap_psprintf(r->pool, "%3.3u Proxy Error", statuscode);
    return statuscode;
d850 1
a850 1
     ap_proxy_host2addr(const char *host, struct hostent * reqhp)
d854 3
a856 1
    struct per_thread_data *ptd = get_per_thread_data();
d859 2
a860 2
        if (!ap_isdigit(host[i]) && host[i] != '.')
            break;
d863 3
a865 3
        hp = gethostbyname(host);
        if (hp == NULL)
            return "Host not found";
d868 12
a879 12
        ptd->ipaddr = ap_inet_addr(host);
        hp = gethostbyaddr((char *)&ptd->ipaddr, sizeof(ptd->ipaddr), AF_INET);
        if (hp == NULL) {
            memset(&ptd->hpbuf, 0, sizeof(ptd->hpbuf));
            ptd->hpbuf.h_name = 0;
            ptd->hpbuf.h_addrtype = AF_INET;
            ptd->hpbuf.h_length = sizeof(ptd->ipaddr);
            ptd->hpbuf.h_addr_list = ptd->charpbuf;
            ptd->hpbuf.h_addr_list[0] = (char *)&ptd->ipaddr;
            ptd->hpbuf.h_addr_list[1] = 0;
            hp = &ptd->hpbuf;
        }
d892 1
a892 1
        return r->hostname;
d896 2
a897 2
        || url[1] != '/' || url[2] != '/')
        return NULL;
d899 1
a899 2
    url = ap_pstrdup(r->pool, &url[1]); /* make it point to "//", which is
                                         * what proxy_canon_netloc expects */
d904 2
a905 2
        ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, r,
                      "%s", err);
d909 1
a909 1
    return host;                /* ought to return the port, too */
d925 1
a925 4
    /*
     * if (proxy_readmask(This->name, &This->addr.s_addr, &This->mask.s_addr)
     * == 0)
     */
d927 1
a927 1
    /* return 1; */
d934 1
a934 1
        char *tmp;
d936 2
a937 2
        if (*addr == '/' && quads > 0)  /* netmask starts here. */
            break;
d939 2
a940 2
        if (!ap_isdigit(*addr))
            return 0;           /* no digit at start of quad */
d942 1
a942 1
        ip_addr[quads] = ap_strtol(addr, &tmp, 0);
d944 2
a945 2
        if (tmp == addr)        /* expected a digit, found something else */
            return 0;
d947 4
a950 4
        if (ip_addr[quads] < 0 || ip_addr[quads] > 255) {
            /* invalid octet */
            return 0;
        }
d952 1
a952 1
        addr = tmp;
d954 2
a955 2
        if (*addr == '.' && quads != 3)
            ++addr;             /* after the 4th quad, a dot would be illegal */
d959 1
a959 1
        This->addr.s_addr |= htonl(ip_addr[i] << (24 - 8 * i));
d961 2
a962 2
    if (addr[0] == '/' && ap_isdigit(addr[1])) {        /* net mask follows: */
        char *tmp;
d964 1
a964 1
        ++addr;
d966 1
a966 1
        bits = ap_strtol(addr, &tmp, 0);
d968 2
a969 2
        if (tmp == addr)        /* expected a digit, found something else */
            return 0;
d971 1
a971 1
        addr = tmp;
d973 2
a974 2
        if (bits < 0 || bits > 32)      /* netmask must be between 0 and 32 */
            return 0;
d978 16
a993 19
        /* Determine (i.e., "guess") netmask by counting the */
        /* number of trailing .0's; reduce #quads appropriately */
        /* (so that 192.168.0.0 is equivalent to 192.168.)        */
        while (quads > 0 && ip_addr[quads - 1] == 0)
            --quads;

        /*
         * "IP Address should be given in dotted-quad form, optionally
         * followed by a netmask (e.g., 192.168.111.0/24)";
         */
        if (quads < 1)
            return 0;

        /* every zero-byte counts as 8 zero-bits */
        bits = 8 * quads;

        if (bits != 32)         /* no warning for fully qualified IP address */
            fprintf(stderr, "Warning: NetMask not supplied with IP-Addr; guessing: %s/%ld\n",
                    inet_ntoa(This->addr), bits);
d999 5
a1003 5
        fprintf(stderr, "Warning: NetMask and IP-Addr disagree in %s/%ld\n",
                inet_ntoa(This->addr), bits);
        This->addr.s_addr &= This->mask.s_addr;
        fprintf(stderr, "         Set to %s/%ld\n",
                inet_ntoa(This->addr), bits);
d1007 2
a1008 2
        This->matcher = proxy_match_ipaddr;
        return 1;
d1011 1
a1011 1
        return (*addr == '\0'); /* okay iff we've parsed the whole string */
d1025 2
a1026 2
    if (host == NULL)           /* oops! */
        return 0;
d1032 2
a1033 2
        for (addr.s_addr = 0, i = 0; i < 4; ++i)
            addr.s_addr |= htonl(ip_addr[i] << (24 - 8 * i));
d1035 1
a1035 1
        if (This->addr.s_addr == (addr.s_addr & This->mask.s_addr)) {
d1037 3
a1039 3
            fprintf(stderr, "1)IP-Match: %s[%s] <-> ", host, inet_ntoa(addr));
            fprintf(stderr, "%s/", inet_ntoa(This->addr));
            fprintf(stderr, "%s\n", inet_ntoa(This->mask));
d1041 2
a1042 2
            return 1;
        }
d1044 5
a1048 5
        else {
            fprintf(stderr, "1)IP-NoMatch: %s[%s] <-> ", host, inet_ntoa(addr));
            fprintf(stderr, "%s/", inet_ntoa(This->addr));
            fprintf(stderr, "%s\n", inet_ntoa(This->mask));
        }
d1052 1
a1052 1
        struct hostent the_host;
d1054 2
a1055 2
        memset(&the_host, '\0', sizeof the_host);
        found = ap_proxy_host2addr(host, &the_host);
d1057 1
a1057 1
        if (found != NULL) {
d1059 1
a1059 1
            fprintf(stderr, "2)IP-NoMatch: hostname=%s msg=%s\n", host, found);
d1061 2
a1062 7
            return 0;
        }

        if (the_host.h_name != NULL)
            found = the_host.h_name;
        else
            found = host;
d1064 9
a1072 4
        /* Try to deal with multiple IP addr's for a host */
        for (ip_listptr = the_host.h_addr_list; *ip_listptr; ++ip_listptr) {
            ip_list = (struct in_addr *)*ip_listptr;
            if (This->addr.s_addr == (ip_list->s_addr & This->mask.s_addr)) {
d1074 3
a1076 3
                fprintf(stderr, "3)IP-Match: %s[%s] <-> ", found, inet_ntoa(*ip_list));
                fprintf(stderr, "%s/", inet_ntoa(This->addr));
                fprintf(stderr, "%s\n", inet_ntoa(This->mask));
d1078 2
a1079 2
                return 1;
            }
d1081 5
a1085 5
            else {
                fprintf(stderr, "3)IP-NoMatch: %s[%s] <-> ", found, inet_ntoa(*ip_list));
                fprintf(stderr, "%s/", inet_ntoa(This->addr));
                fprintf(stderr, "%s\n", inet_ntoa(This->mask));
            }
d1087 1
a1087 1
        }
d1101 1
a1101 1
        return 0;
d1105 1
a1105 1
        continue;
d1109 2
a1110 2
        fprintf(stderr, "@@@@@@@@ handle optional port in proxy_is_domainname()\n");
        /* @@@@@@@@ handle optional port */
d1115 1
a1115 1
        return 0;
d1119 1
a1119 1
        addr[i] = '\0';
d1131 2
a1132 2
    if (host == NULL)           /* some error was logged already */
        return 0;
d1139 1
a1139 1
        --d_len;
d1141 1
a1141 1
        --h_len;
d1143 1
a1143 1
        && strncasecmp(&host[h_len - d_len], This->name, d_len) == 0;
d1155 1
a1155 1
        return 0;
d1162 2
a1163 2
        fprintf(stderr, "@@@@@@@@ handle optional port in proxy_is_hostname()\n");
        /* @@@@@@@@ handle optional port */
d1168 1
a1168 1
        return 0;
d1170 1
a1170 1
    This->hostentry = ap_pduphostent(p, &host);
d1174 1
a1174 1
        addr[i] = '\0';
d1189 1
a1189 1
        return 0;               /* oops! */
d1199 2
a1200 2
        if (*ip_list == ? ? ? ? ? ? ? ? ? ? ? ? ?)
            return 1;
d1205 1
a1205 1
        --h2_len;
d1207 1
a1207 1
        --h1_len;
d1209 1
a1209 1
        && strncasecmp(host, host2, h1_len) == 0;
d1232 5
a1236 5
        i = connect(sock, (struct sockaddr *)addr, sizeof(struct sockaddr_in));
#if defined(WIN32) || defined(NETWARE)
        if (i == SOCKET_ERROR)
            errno = WSAGetLastError();
#endif                          /* WIN32 */
d1239 3
a1241 3
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                      "proxy connect to %s port %d failed",
                      inet_ntoa(addr->sin_addr), ntohs(addr->sin_port));
d1248 3
a1250 4
/* This function is called by ap_table_do() for all header lines
 * (from proxy_http.c and proxy_ftp.c)
 * It is passed a cache_req struct pointer and a MIME field and value pair
 */
d1253 1
a1253 1
    cache_req *c = (cache_req *)p;
d1256 7
a1262 10
        return 1;
    if (c->fp != NULL &&
        ap_bvputs(c->fp, key, ": ", value, CRLF, NULL) == -1) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                      "proxy: error writing header to %s", c->tempfile);
        c = ap_proxy_cache_error(c);
        return 0;               /* no need to continue, it failed already */
    }
    return 1;                   /* tell ap_table_do() to continue calling us
                                 * for more headers */
d1270 1
a1270 1
        ap_bputs(data, cache->fp);
a1273 264
/* do a HTTP/1.1 age calculation */
time_t ap_proxy_current_age(cache_req *c, const time_t age_value)
{
    time_t apparent_age, corrected_received_age, response_delay, corrected_initial_age,
           resident_time, current_age;

    /* Perform an HTTP/1.1 age calculation. (RFC2616 13.2.3) */

    apparent_age = MAX(0, c->resp_time - c->date);
    corrected_received_age = MAX(apparent_age, age_value);
    response_delay = c->resp_time - c->req_time;
    corrected_initial_age = corrected_received_age + response_delay;
    resident_time = time(NULL) - c->resp_time;
    current_age = corrected_initial_age + resident_time;

    return (current_age);
}

/* open a cache file and return a pointer to a BUFF */
BUFF *ap_proxy_open_cachefile(request_rec *r, char *filename)
{
    BUFF *cachefp = NULL;
    int cfd;

    if (filename != NULL) {
        cfd = open(filename, O_RDWR | O_BINARY);
        if (cfd != -1) {
            ap_note_cleanups_for_fd(r->pool, cfd);
            cachefp = ap_bcreate(r->pool, B_RD | B_WR);
            ap_bpushfd(cachefp, cfd, cfd);
        }
        else if (errno != ENOENT)
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                          "proxy: error opening cache file %s",
                          filename);
        else
            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "File %s not found", filename);

    }
    return cachefp;
}

/* create a cache file and return a pointer to a BUFF */
BUFF *ap_proxy_create_cachefile(request_rec *r, char *filename)
{
    BUFF *cachefp = NULL;
    int cfd;

    if (filename != NULL) {
        cfd = open(filename, O_WRONLY | O_CREAT | O_EXCL | O_BINARY, 0622);
        if (cfd != -1) {
            ap_note_cleanups_for_fd(r->pool, cfd);
            cachefp = ap_bcreate(r->pool, B_WR);
            ap_bpushfd(cachefp, -1, cfd);
        }
        else if (errno != ENOENT)
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                          "proxy: error creating cache file %s",
                          filename);
    }
    return cachefp;
}

/* Clear all connection-based headers from headers table */
void ap_proxy_clear_connection(pool *p, table *headers)
{
    const char *name;
    char *next = ap_pstrdup(p, ap_table_get(headers, "Connection"));

    /* Some proxies (Squid, ICS) use the non-standard "Proxy-Connection" header. */
    ap_table_unset(headers, "Proxy-Connection");

    if (next != NULL) {
        while (*next) {
            name = next;
            while (*next && !ap_isspace(*next) && (*next != ','))
                ++next;
            while (*next && (ap_isspace(*next) || (*next == ','))) {
                *next = '\0';
                ++next;
            }
            ap_table_unset(headers, name);
        }
        ap_table_unset(headers, "Connection");
    }

    /* unset hop-by-hop headers defined in RFC2616 13.5.1 */
    ap_table_unset(headers,"Keep-Alive");
    /*
     * XXX: @@@@@@ FIXME: "Proxy-Authenticate" should IMO *not* be stripped
     * because in a chain of proxies some "front" proxy might need
     * proxy authentication, while a "back-end" proxy which needs none can
     * simply pass the "Proxy-Authenticate" back to the client, and pass
     * the client's "Proxy-Authorization" to the front-end proxy.
     * (See the note in proxy_http.c for the "Proxy-Authorization" case.)
     *
     *   MnKr 04/2002
     */
    ap_table_unset(headers,"Proxy-Authenticate");
    ap_table_unset(headers,"TE");
    ap_table_unset(headers,"Trailer");
    /* it is safe to just chop the transfer-encoding header
     * here, because proxy doesn't support any other encodings
     * to the backend other than chunked.
     */
    ap_table_unset(headers,"Transfer-Encoding");
    ap_table_unset(headers,"Upgrade");

}

/* overlay one table on another
 * keys in base will be replaced by keys in overlay
 *
 * Note: this has to be done in a special way, due
 * to some nastiness when it comes to having multiple
 * headers in the overlay table. First, we remove all
 * the headers in the base table that are found in the
 * overlay table, then we simply concatenate the
 * tables together.
 *
 * The base and overlay tables need not be in the same
 * pool (and probably won't be).
 *
 * If the base table is changed in any way through
 * being overlayed with the overlay table, this
 * function returns a 1.
 */
int ap_proxy_table_replace(table *base, table *overlay)
{
    table_entry *elts = (table_entry *)overlay->a.elts;
    int i, q = 0;
    const char *val;

    /* remove overlay's keys from base */
    for (i = 0; i < overlay->a.nelts; ++i) {
        val = ap_table_get(base, elts[i].key);
        if (!val || strcmp(val, elts[i].val)) {
            q = 1;
        }
        if (val) {
            ap_table_unset(base, elts[i].key);
        }
    }

    /* add overlay to base */
    for (i = 0; i < overlay->a.nelts; ++i) {
        ap_table_add(base, elts[i].key, elts[i].val);
    }

    return q;
}

/* read the response line
 * This function reads a single line of response from the server,
 * and returns a status code.
 * It also populates the request_rec with the resultant status, and
 * returns backasswards status (HTTP/0.9).
 */
int ap_proxy_read_response_line(BUFF *f, request_rec *r, char *buffer, int size, int *backasswards, int *major, int *minor) {

    long len;

    len = ap_getline(buffer, size-1, f, 0);
    if (len == -1) {
        ap_bclose(f);
        ap_kill_timeout(r);
        return ap_proxyerror(r, HTTP_BAD_GATEWAY,
                             "Error reading from remote server");
    }
    else if (len == 0) {
        ap_bclose(f);
        ap_kill_timeout(r);
        return ap_proxyerror(r, HTTP_BAD_GATEWAY,
                             "Document contains no data");
    }

    /*
     * Is it an HTTP/1 response? Do some sanity checks on the response. (This
     * is buggy if we ever see an HTTP/1.10)
     */
    if (ap_checkmask(buffer, "HTTP/#.# ###*")) {

        if (2 != sscanf(buffer, "HTTP/%u.%u", major, minor)) {
            /* if no response, default to HTTP/1.1 - is this correct? */
            *major = 1;
            *minor = 1;
        }

        /* If not an HTTP/1 message */
        if (*major < 1) {
            ap_bclose(f);
            ap_kill_timeout(r);
            return HTTP_BAD_GATEWAY;
        }
        *backasswards = 0;

        buffer[12] = '\0';
        r->status = atoi(&buffer[9]);
        buffer[12] = ' ';
        r->status_line = ap_pstrdup(r->pool, &buffer[9]);

        /* if the response was 100 continue, soak up any headers */
        if (r->status == 100) {
            ap_proxy_read_headers(r, buffer, size, f);
        }

    }
    else {

        /* an http/0.9 response */
        *backasswards = 1;
        r->status = 200;
        r->status_line = "200 OK";
        *major = 0;
        *minor = 9;

    }

    return OK;

}


#if defined WIN32

static DWORD tls_index;

BOOL WINAPI DllMain(HINSTANCE dllhandle, DWORD reason, LPVOID reserved)
{
    LPVOID memptr;

    switch (reason) {
    case DLL_PROCESS_ATTACH:
        tls_index = TlsAlloc();
    case DLL_THREAD_ATTACH:     /* intentional no break */
        TlsSetValue(tls_index, malloc(sizeof(struct per_thread_data)));
        break;
    case DLL_THREAD_DETACH:
        memptr = TlsGetValue(tls_index);
        if (memptr) {
            free(memptr);
            TlsSetValue(tls_index, 0);
        }
        break;
    }

    return TRUE;
}

#endif

static struct per_thread_data *get_per_thread_data(void)
{
#if defined(WIN32)

    return (struct per_thread_data *)TlsGetValue(tls_index);

#else

    static APACHE_TLS struct per_thread_data sptd;
    return &sptd;

#endif
}
@


1.1.1.4
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@a1609 6
        /* there need not be a reason phrase in the response,
	 * and ap_getline() already deleted trailing whitespace.
	 * But RFC2616 requires a SP after the Status-Code. Add one:
	 */
	if (strlen(buffer) < sizeof("HTTP/1.x 200 ")-1)
	  buffer = ap_pstrcat(r->pool, buffer, " ", NULL);
@


1.1.1.5
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
@


