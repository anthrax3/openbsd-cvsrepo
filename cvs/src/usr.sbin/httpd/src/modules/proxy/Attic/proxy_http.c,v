head	1.23;
access;
symbols
	OPENBSD_5_5:1.22.0.16
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.12
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.6
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.5
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.5
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.4
	apache_1_3_27:1.1.1.4
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	apache_1_3_26:1.1.1.3
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.1.2.0.2
	OPENBSD_2_4_BASE:1.1.1.2
	apache_1_3_2:1.1.1.2
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	apache:1.1.1
	apache_1_2_6:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.22;

1.22
date	2011.01.05.12.47.13;	author jasper;	state Exp;
branches;
next	1.21;

1.21
date	2010.02.25.07.53.07;	author jasper;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.03.09.10.45;	author mbalmer;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.04.14.39.37;	author mbalmer;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2008.05.09.08.06.28;	author mbalmer;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.01.12.53.59;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.09.12.13.10;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.10.16.55.02;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.21.13.11.36;	author henning;	state Exp;
branches
	1.13.2.1
	1.13.4.1;
next	1.12;

1.12
date	2003.04.08.20.46.28;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.07.20.23.06;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.19.21.31.16;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.29.02.08.06;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.29.10.21.45;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.22.18.15;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.19.11.17.16;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.25.18.29.52;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.06.29.43;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.04.28.43;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.03.01.01.06.30;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.03.25.07.08.50;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.25.07.08.50;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.10.01.17.19.42;	author beck;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.07.19.21.28.56;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.07.19.48.13;	author henning;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.08.21.12.53.40;	author henning;	state Exp;
branches;
next	;

1.13.2.1
date	2004.06.11.04.40.34;	author brad;	state Exp;
branches;
next	;

1.13.4.1
date	2004.06.11.04.19.04;	author brad;	state Exp;
branches;
next	;

1.19.2.1
date	2008.11.06.10.06.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.23
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/* HTTP routines for Apache proxy */

#include "mod_proxy.h"
#include "http_log.h"
#include "http_main.h"
#include "http_core.h"
#include "util_date.h"

/*
 * Canonicalise http-like URLs.
 *  scheme is the scheme for the URL
 *  url    is the URL starting with the first '/'
 *  def_port is the default port for this scheme.
 */
int ap_proxy_http_canon(request_rec *r, char *url, const char *scheme, int def_port)
{
    char *host, *path, *search, sport[7];
    const char *err;
    int port;

    /*
     * do syntatic check. We break the URL into host, port, path, search
     */
    port = def_port;
    err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);
    if (err)
        return HTTP_BAD_REQUEST;

    /* now parse path/search args, according to rfc1738 */
    /*
     * N.B. if this isn't a true proxy request, then the URL _path_ has
     * already been decoded.  True proxy requests have r->uri ==
     * r->unparsed_uri, and no others have that property.
     */
    if (r->uri == r->unparsed_uri) {
        search = strchr(url, '?');
        if (search != NULL)
            *(search++) = '\0';
    }
    else
        search = r->args;

    /* process path */
    path = ap_proxy_canonenc(r->pool, url, strlen(url), enc_path,
                             r->proxyreq);
    if (path == NULL)
        return HTTP_BAD_REQUEST;

    if (port != def_port)
        ap_snprintf(sport, sizeof(sport), ":%d", port);
    else
        sport[0] = '\0';

    r->filename = ap_pstrcat(r->pool, "proxy:", scheme, "://", host, sport, "/",
                   path, (search) ? "?" : "", (search) ? search : "", NULL);
    return OK;
}

/* handle the conversion of URLs in the ProxyPassReverse function */
static const char *proxy_location_reverse_map(request_rec *r, const char *url)
{
    void *sconf;
    proxy_server_conf *conf;
    struct proxy_alias *ent;
    int i, l1, l2;
    char *u;

    sconf = r->server->module_config;
    conf = (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
    l1 = strlen(url);
    ent = (struct proxy_alias *)conf->raliases->elts;
    for (i = 0; i < conf->raliases->nelts; i++) {
        l2 = strlen(ent[i].real);
        if (l1 >= l2 && strncmp(ent[i].real, url, l2) == 0) {
            u = ap_pstrcat(r->pool, ent[i].fake, &url[l2], NULL);
            return ap_construct_url(r->pool, u, r);
        }
    }
    return url;
}

/*
 * This handles http:// URLs, and other URLs using a remote proxy over http
 * If proxyhost is NULL, then contact the server directly, otherwise
 * go via the proxy.
 * Note that if a proxy is used, then URLs other than http: can be accessed,
 * also, if we have trouble which is clearly specific to the proxy, then
 * we return DECLINED so that we can try another proxy. (Or the direct
 * route.)
 */
int ap_proxy_http_handler(request_rec *r, cache_req *c, char *url,
                              const char *proxyhost, int proxyport)
{
    const char *strp;
    char *strp2;
    const char *err, *desthost;
    int i, j, sock,/* len,*/ backasswards;
    table *req_hdrs, *resp_hdrs;
    array_header *reqhdrs_arr;
    table_entry *reqhdrs_elts;
    BUFF *f;
    char buffer[HUGE_STRING_LEN];
    char portstr[32];
    pool *p = r->pool;
    int chunked = 0, destport = 0;
    char *destportstr = NULL;
    const char *urlptr = NULL;
    const char *datestr, *urlstr;
    struct addrinfo hints, *res, *res0;
    int error;
    int result, major, minor;
    const char *content_length;
    const char *peer;
    int destportstrtonum;
    const char *errstr;

    void *sconf = r->server->module_config;
    proxy_server_conf *conf =
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
    struct noproxy_entry *npent = (struct noproxy_entry *) conf->noproxies->elts;
    struct nocache_entry *ncent = (struct nocache_entry *) conf->nocaches->elts;
    int nocache = 0;

    if (conf->cache.root == NULL)
        nocache = 1;

    /* We break the URL into host, port, path-search */

    urlptr = strstr(url, "://");
    if (urlptr == NULL)
        return HTTP_BAD_REQUEST;
    destport = DEFAULT_HTTP_PORT;
    urlptr += 3;
    ap_hook_use("ap::mod_proxy::http::handler::set_destport", 
                AP_HOOK_SIG2(int,ptr), 
                AP_HOOK_TOPMOST,
                &destport, r);
    ap_snprintf(portstr, sizeof(portstr), "%d", destport);
    destportstr = portstr;
    strp = strchr(urlptr, '/');
    if (strp == NULL) {
        desthost = ap_pstrdup(p, urlptr);
        urlptr = "/";
    }
    else {
        char *q = ap_palloc(p, strp - urlptr + 1);
        memcpy(q, urlptr, strp - urlptr);
        q[strp - urlptr] = '\0';
        urlptr = strp;
        desthost = q;
    }
    if (*desthost == '['){
      char *u = strrchr(desthost+1, ']');
      if (u){
          desthost++;
          *u = '\0';
          if (*(u+1) == ':'){ /* [host]:xx */
              strp2 = u+1;
          }
          else if (*(u+1) == '\0'){   /* [host] */
              strp2 = NULL;
          }
          else
              return HTTP_BAD_REQUEST;
      }
      else
          return HTTP_BAD_REQUEST;
    }
    else
       strp2 = strrchr(desthost, ':');

    if (strp2 != NULL) {
        *(strp2++) = '\0';
        if (ap_isdigit(*strp2))
            destportstr = strp2;
    }

    /* Make sure peer is always set to prevent a segfault in the SSL handler */
    peer = desthost;

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;
    error = getaddrinfo(desthost, destportstr, &hints, &res0);
    if (error && proxyhost == NULL) {
      return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
                  gai_strerror(error));       /* give up */
     }
 
      /* check if ProxyBlock directive on this host */
      for (i = 0; i < conf->noproxies->nelts; i++) {
      int fail;
      struct sockaddr_in *sin;

      fail = 0;
      if (npent[i].name != NULL && strstr(desthost, npent[i].name))
          fail++;
      if (npent[i].name != NULL && strcmp(npent[i].name, "*") == 0)
          fail++;
      for (res = res0; res; res = res->ai_next) {
          switch (res->ai_family) {
          case AF_INET:
              sin = (struct sockaddr_in *)res->ai_addr;
              if (sin->sin_addr.s_addr == npent[i].addr.s_addr)
                  fail++;
              break;
		
          }
      }
      if (fail) {
          if (res0 != NULL)
              freeaddrinfo(res0);
          return ap_proxyerror(r, HTTP_FORBIDDEN,
                               "Connect to remote machine blocked");
      }
    }
    if (proxyhost != NULL) {
      char pbuf[10];

      if (res0 != NULL)
          freeaddrinfo(res0);

      ap_snprintf(pbuf, sizeof(pbuf), "%d", proxyport);
      memset(&hints, 0, sizeof(hints));
      hints.ai_family = PF_UNSPEC;
      hints.ai_socktype = SOCK_STREAM;
      hints.ai_protocol = IPPROTO_TCP;
      error = getaddrinfo(proxyhost, pbuf, &hints, &res0);
      if (error)
          return DECLINED;    /* try another */
    }

    /* check if ProxyBlock directive on this host */
    for (i = 0; i < conf->noproxies->nelts; i++) {
	peer =  ap_psprintf(p, "%s:%s", desthost, destportstr);  
    }


    /*
     * we have worked out who exactly we are going to connect to, now make
     * that connection...
     */
     sock = i = -1;
     for (res = res0; res; res = res->ai_next) {
       sock = ap_psocket(p, res->ai_family, res->ai_socktype,
           res->ai_protocol);
       if (sock < 0)
           continue;

      if (conf->recv_buffer_size) {
          if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
                         (const char *)&conf->recv_buffer_size, sizeof(int))
              == -1) {
              ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                            "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
          }
      }

      i = ap_proxy_doconnect(sock, res->ai_addr, r);
      if (i == 0)
          break;
      ap_pclosesocket(p, sock);
    }
    freeaddrinfo(res0);

    if (i == -1) {
        if (proxyhost != NULL)
            return DECLINED;    /* try again another way */
        else
            return ap_proxyerror(r, HTTP_BAD_GATEWAY, ap_pstrcat(r->pool,
                                    "Could not connect to remote machine: ",
                                                    strerror(errno), NULL));
    }

    /* record request_time for HTTP/1.1 age calculation */
    c->req_time = time(NULL);

    /*
     * build upstream-request headers by stripping r->headers_in from
     * connection specific headers. We must not remove the Connection: header
     * from r->headers_in, we still have to react to Connection: close
     */
    req_hdrs = ap_copy_table(r->pool, r->headers_in);
    ap_proxy_clear_connection(r->pool, req_hdrs);

    /*
     * At this point, we start sending the HTTP/1.1 request to the remote
     * server (proxy or otherwise).
     */
    f = ap_bcreate(p, B_RDWR | B_SOCKET);
    ap_bpushfd(f, sock, sock);

    {
        char *errmsg = NULL;
        ap_hook_use("ap::mod_proxy::http::handler::new_connection", 
                    AP_HOOK_SIG4(ptr,ptr,ptr,ptr), 
                    AP_HOOK_DECLINE(NULL),
                    &errmsg, r, f, peer);
        if (errmsg != NULL)
            return ap_proxyerror(r, HTTP_BAD_GATEWAY, errmsg);
    }

    ap_hard_timeout("proxy send", r);
    ap_bvputs(f, r->method, " ", proxyhost ? url : urlptr, " HTTP/1.1" CRLF,
              NULL);
    {
	int rc = DECLINED;
	ap_hook_use("ap::mod_proxy::http::handler::write_host_header", 
		    AP_HOOK_SIG6(int,ptr,ptr,ptr,ptr,ptr), 
		    AP_HOOK_DECLINE(DECLINED),
		    &rc, r, f, desthost, destportstr, destportstr);
        if (rc == DECLINED) {
	    destportstrtonum = strtonum(destportstr, 0, 65535, &errstr);
	    if (errstr)
		errx(1, "The destination port is %s: %s", errstr, destportstr);

	    if (destportstr != NULL && destportstrtonum != destport)
		ap_bvputs(f, "Host: ", desthost, ":", destportstr, CRLF, NULL);
	    else
		ap_bvputs(f, "Host: ", desthost, CRLF, NULL);
        }
    }

    if (conf->viaopt == via_block) {
        /* Block all outgoing Via: headers */
        ap_table_unset(req_hdrs, "Via");
    }
    else if (conf->viaopt != via_off) {
        /* Create a "Via:" request header entry and merge it */
        i = ap_get_server_port(r);
        if (ap_is_default_port(i, r)) {
            strlcpy(portstr, "", sizeof(portstr));
        }
        else {
            ap_snprintf(portstr, sizeof portstr, ":%d", i);
        }
        /* Generate outgoing Via: header with/without server comment: */
        ap_table_mergen(req_hdrs, "Via",
                        (conf->viaopt == via_full)
                        ? ap_psprintf(p, "%d.%d %s%s (%s)",
                                      HTTP_VERSION_MAJOR(r->proto_num),
                                      HTTP_VERSION_MINOR(r->proto_num),
                                      ap_get_server_name(r), portstr,
                                      SERVER_BASEVERSION)
                        : ap_psprintf(p, "%d.%d %s%s",
                                      HTTP_VERSION_MAJOR(r->proto_num),
                                      HTTP_VERSION_MINOR(r->proto_num),
                                      ap_get_server_name(r), portstr)
            );
    }

    /* the X-* headers are only added if we are a reverse
     * proxy, otherwise we would be giving away private information.
     */
    if (r->proxyreq == PROXY_PASS) {
        const char *buf;

        /*
         * Add X-Forwarded-For: so that the upstream has a chance to determine,
         * where the original request came from.
         */
        ap_table_mergen(req_hdrs, "X-Forwarded-For", r->connection->remote_ip);

        /* Add X-Forwarded-Host: so that upstream knows what the
         * original request hostname was.
         */
        if ((buf = ap_table_get(r->headers_in, "Host"))) {
            ap_table_mergen(req_hdrs, "X-Forwarded-Host", buf);
        }

        /* Add X-Forwarded-Server: so that upstream knows what the
         * name of this proxy server is (if there are more than one)
         * XXX: This duplicates Via: - do we strictly need it?
         */
        ap_table_mergen(req_hdrs, "X-Forwarded-Server", r->server->server_hostname);
    } 

    /* we don't yet support keepalives - but we will soon, I promise! */
    ap_table_set(req_hdrs, "Connection", "close");

    reqhdrs_arr = ap_table_elts(req_hdrs);
    reqhdrs_elts = (table_entry *)reqhdrs_arr->elts;
    for (i = 0; i < reqhdrs_arr->nelts; i++) {
        if (reqhdrs_elts[i].key == NULL || reqhdrs_elts[i].val == NULL

        /*
         * Clear out hop-by-hop request headers not to send: RFC2616 13.5.1
         * says we should strip these headers:
         */
            || !strcasecmp(reqhdrs_elts[i].key, "Host") /* Already sent */
            || !strcasecmp(reqhdrs_elts[i].key, "Keep-Alive")
            || !strcasecmp(reqhdrs_elts[i].key, "TE")
            || !strcasecmp(reqhdrs_elts[i].key, "Trailer")
            || !strcasecmp(reqhdrs_elts[i].key, "Transfer-Encoding")
            || !strcasecmp(reqhdrs_elts[i].key, "Upgrade")
        /*
         * XXX: @@@@@@ FIXME: "Proxy-Authorization" should *only* be suppressed
         * if THIS server requested the authentication, not when a frontend
         * proxy requested it!
         * 
         * The solution to this problem is probably to strip out the
         * Proxy-Authorisation header in the authorisation code itself, not
         * here. This saves us having to signal somehow whether this request
         * was authenticated or not.
         */
            || !strcasecmp(reqhdrs_elts[i].key, "Proxy-Authorization"))
            continue;
        ap_bvputs(f, reqhdrs_elts[i].key, ": ", reqhdrs_elts[i].val, CRLF, NULL);
    }

    /* the obligatory empty line to mark the end of the headers */
    ap_bputs(CRLF, f);

    /* and flush the above away */
    ap_bflush(f);

    /* and kill the send timeout */
    ap_kill_timeout(r);


    /* read the request data, and pass it to the backend.
     * we might encounter a stray 100-continue reponse from a PUT or POST,
     * if this happens we ignore the 100 continue status line and read the
     * response again.
     */
    {
        /* send the request data, if any. */
        ap_hard_timeout("proxy receive request data", r);
        if (ap_should_client_block(r)) {
            while ((i = ap_get_client_block(r, buffer, sizeof buffer)) > 0) {
                ap_reset_timeout(r);
                ap_bwrite(f, buffer, i);
            }
        }
        ap_bflush(f);
        ap_kill_timeout(r);


        /* then, read a response line */
        ap_hard_timeout("proxy receive response status line", r);
        result = ap_proxy_read_response_line(f, r, buffer, sizeof(buffer)-1, &backasswards, &major, &minor);
        ap_kill_timeout(r);

        /* trap any errors */
        if (result != OK) {
            ap_bclose(f);
            return result;
        }

        /* if this response was 100-continue, a stray response has been caught.
         * read the line again for the real response
         */
        if (r->status == 100) {
            ap_hard_timeout("proxy receive response status line", r);
            result = ap_proxy_read_response_line(f, r, buffer, sizeof(buffer)-1, &backasswards, &major, &minor);
            ap_kill_timeout(r);

            /* trap any errors */
            if (result != OK) {
                ap_bclose(f);
                return result;
            }
        }
    }


    /*
     * We have our response status line from the convoluted code above,
     * now we read the headers to continue.
     */
    ap_hard_timeout("proxy receive response headers", r);

    /*
     * Is it an HTTP/1 response? Do some sanity checks on the response. (This
     * is buggy if we ever see an HTTP/1.10)
     */
    if (backasswards == 0) {

        /* read the response headers. */
        /* N.B. for HTTP/1.0 clients, we have to fold line-wrapped headers */
        /* Also, take care with headers with multiple occurences. */

        resp_hdrs = ap_proxy_read_headers(r, buffer, sizeof(buffer), f);
        if (resp_hdrs == NULL) {
            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_NOERRNO, r->server,
                         "proxy: Bad HTTP/%d.%d header returned by %s (%s)",
                         major, minor, r->uri, r->method);
            resp_hdrs = ap_make_table(p, 20);
            nocache = 1;        /* do not cache this broken file */
        }

        /* handle Via header in the response */
        if (conf->viaopt != via_off && conf->viaopt != via_block) {
            /* Create a "Via:" response header entry and merge it */
            i = ap_get_server_port(r);
            if (ap_is_default_port(i, r)) {
                strlcpy(portstr, "", sizeof(portstr));
            }
            else {
                ap_snprintf(portstr, sizeof portstr, ":%d", i);
            }
            ap_table_mergen((table *)resp_hdrs, "Via",
                            (conf->viaopt == via_full)
                            ? ap_psprintf(p, "%d.%d %s%s (%s)",
                                          major, minor,
                                          ap_get_server_name(r), portstr,
                                          SERVER_BASEVERSION)
                            : ap_psprintf(p, "%d.%d %s%s",
                                          major, minor,
                                          ap_get_server_name(r), portstr)
                );
        }

        /* is this content chunked? */
        chunked = ap_find_last_token(r->pool,
                                     ap_table_get(resp_hdrs, "Transfer-Encoding"),
                                     "chunked");

        /* strip hop-by-hop headers defined by Connection and RFC2616 */
        ap_proxy_clear_connection(p, resp_hdrs);

        content_length = ap_table_get(resp_hdrs, "Content-Length");
        if (content_length != NULL) {
            c->len = ap_strtol(content_length, NULL, 10);

	    if (c->len < 0) {
		ap_kill_timeout(r);
		return ap_proxyerror(r, HTTP_BAD_GATEWAY, ap_pstrcat(r->pool,
				     "Invalid Content-Length from remote server",
                                      NULL));
	    }
        }

    }
    else {
        /* an http/0.9 response */

        /* no headers */
        resp_hdrs = ap_make_table(p, 20);
    }

    ap_kill_timeout(r);

    /*
     * HTTP/1.1 requires us to accept 3 types of dates, but only generate one
     * type
     */
    /*
     * we SET the dates here, obliterating possible multiple dates, as only
     * one of each date makes sense in each response.
     */
    if ((datestr = ap_table_get(resp_hdrs, "Date")) != NULL)
        ap_table_set(resp_hdrs, "Date", ap_proxy_date_canon(p, datestr));
    if ((datestr = ap_table_get(resp_hdrs, "Last-Modified")) != NULL)
        ap_table_set(resp_hdrs, "Last-Modified", ap_proxy_date_canon(p, datestr));
    if ((datestr = ap_table_get(resp_hdrs, "Expires")) != NULL)
        ap_table_set(resp_hdrs, "Expires", ap_proxy_date_canon(p, datestr));

    /* handle the ProxyPassReverse mappings */
    if ((urlstr = ap_table_get(resp_hdrs, "Location")) != NULL)
        ap_table_set(resp_hdrs, "Location", proxy_location_reverse_map(r, urlstr));
    if ((urlstr = ap_table_get(resp_hdrs, "URI")) != NULL)
        ap_table_set(resp_hdrs, "URI", proxy_location_reverse_map(r, urlstr));
    if ((urlstr = ap_table_get(resp_hdrs, "Content-Location")) != NULL)
        ap_table_set(resp_hdrs, "Content-Location", proxy_location_reverse_map(r, urlstr));

/* check if NoCache directive on this host */
  {
    struct sockaddr_in *sin;
    struct sockaddr_in6 *sin6;

    if (nocache == 0) {
	for (i = 0; i < conf->nocaches->nelts; i++) {
	    if (ncent[i].name != NULL && 
		(ncent[i].name[0] == '*' ||
		 strstr(desthost, ncent[i].name) != NULL)) {
		nocache = 1;
		break;
	    }
	    switch (res->ai_addr->sa_family) {
	    case AF_INET:
		sin = (struct sockaddr_in *)res->ai_addr;
		if (sin->sin_addr.s_addr == ncent[i].addr.s_addr) {
		    nocache = 1;
		    break;
		}
	    }
	}

        /* update the cache file, possibly even fulfilling the request if
         * it turns out a conditional allowed us to serve the object from the
         * cache...
         */
        i = ap_proxy_cache_update(c, resp_hdrs, !backasswards, nocache);
        if (i != DECLINED) {
            ap_bclose(f);
            return i;
        }

        /* write status line and headers to the cache file */
        ap_proxy_write_headers(c, ap_pstrcat(p, "HTTP/1.1 ", r->status_line, NULL), resp_hdrs);
    }
  }

    /* Setup the headers for our client from upstreams response-headers */
    ap_proxy_table_replace(r->headers_out, resp_hdrs);
    /* Add X-Cache header - be careful not to obliterate any upstream headers */
    ap_table_mergen(r->headers_out, "X-Cache",
                    ap_pstrcat(r->pool, "MISS from ",
                               ap_get_server_name(r), NULL));
    /* The Content-Type of this response is the upstream one. */
    r->content_type = ap_table_get(r->headers_out, "Content-Type");
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Content-Type: %s", r->content_type);

    /* finally output the headers to the client */
    ap_send_http_header(r);

    /*
     * Is it an HTTP/0.9 respose? If so, send the extra data we read from
     * upstream as the start of the reponse to client
     */
/* FIXME: This code is broken: we try and write a buffer and length that
 * were never intelligently initialised. Rather have a bit of broken protocol
 * handling for now than broken code.
 */
/*
    if (backasswards) {
        ap_hard_timeout("proxy send assbackward", r);

        ap_bwrite(r->connection->client, buffer, len);
        if (c != NULL && c->fp != NULL && ap_bwrite(c->fp, buffer, len) != len) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                      "proxy: error writing extra data to %s", c->tempfile);
            c = ap_proxy_cache_error(c);
        }
        ap_kill_timeout(r);
    }
*/

/* send body */
/* if header only, then cache will be NULL */
/* HTTP/1.0 tells us to read to EOF, rather than content-length bytes */
/* XXX CHANGEME: We want to eventually support keepalives, which means
 * we must read content-length bytes... */
    if (!r->header_only) {
/* we need to set this for ap_proxy_send_fb()... */
        c->cache_completion = conf->cache.cache_completion;

/* XXX CHECKME: c->len should be the expected content length, or -1 if the
 * content length is not known. We need to make 100% sure c->len is always
 * set correctly before we get here to correctly do keepalive.
 */
        ap_proxy_send_fb(f, r, c, c->len, 0, chunked, conf->io_buffer_size);
    }

    /* ap_proxy_send_fb() closes the socket f for us */

    ap_proxy_cache_tidy(c);

    ap_proxy_garbage_coll(r);
    return OK;
}
@


1.22
log
@- properly fix pr6009. a different fix was commited as the original patch
used atoi(). this fix uses strtonum() instead.

from bjorn ketelaars, pr6515.
ok henning@@
@
text
@@


1.21
log
@- apache would send the wrong Host-Header back when setup as a reverse proxy
with ProxyPreserveHost.

fixes pr6009, though i applied a different fix as what was suggested in that pr.

ok sthen@@
@
text
@d172 2
d372 5
a376 1
	    if (destportstr != NULL && destport != DEFAULT_HTTP_PORT)
@


1.20
log
@Use correct function signature when calling the write_host_header hook.

from Josh Elsasser <josh@@elsasser.org>, thanks.
@
text
@d370 1
a370 1
	    if (destportstr != NULL)
@


1.19
log
@Make the proxy module work with https again by allowing the destination
port to be set in the config file instead of using HTTP_DEFAULT_PORT
in all cases.  Prevent a segfault that would happen when the SSL
connection from the proxy fails.

Problem found and analyzed by Mischa Diehm; fix by me.
@
text
@d366 1
a366 1
		    AP_HOOK_SIG6(ptr,ptr,ptr,ptr,ptr,ptr), 
@


1.19.2.1
log
@Use correct function signature when calling the write_host_header hook.
@
text
@d366 1
a366 1
		    AP_HOOK_SIG6(int,ptr,ptr,ptr,ptr,ptr), 
@


1.18
log
@Add support for IPv6 while keeping the default at IPv4 to not break
existing installations.  See the documentation for the IPv6 related
configuration.

This changes the module ABI since addresses are now struct addrinfo.

This has been tested by many people and run on production machines
for several months.

feedback many, ok todd
@
text
@d171 1
a171 1
    char *peer;
d194 1
a194 1
    ap_snprintf(portstr, sizeof(portstr), "%d", DEFAULT_HTTP_PORT);
d233 4
a288 1

@


1.17
log
@add ProxyPreserveHost support to mod_proxy. it allows to pass the original
Host header to the backend. default off. henning@@ ok.
@
text
@d154 1
a154 1
    const char *err, *desthost, *hostname;
a158 3
    struct sockaddr_in server;
    struct in_addr destaddr;
    struct hostent server_hp;
d163 1
a163 2
    int destport = 0;
    int chunked = 0;
d167 2
a182 3
    memset(&server, '\0', sizeof(server));
    server.sin_family = AF_INET;

d188 1
a189 1
    destport = DEFAULT_HTTP_PORT;
d194 2
d208 19
a227 1
    strp2 = strchr(desthost, ':');
d230 1
a230 2
        if (ap_isdigit(*strp2)) {
            destport = atoi(strp2);
a231 1
        }
d233 53
a287 1
    destaddr.s_addr = ap_inet_addr(desthost);
d289 1
a289 20
        if (destaddr.s_addr == npent[i].addr.s_addr ||
            (npent[i].name != NULL &&
             (npent[i].name[0] == '*' || strstr(desthost, npent[i].name) != NULL)))
            return ap_proxyerror(r, HTTP_FORBIDDEN,
                                 "Connect to remote machine blocked");
    }

    if (proxyhost != NULL) {
        server.sin_port = htons((unsigned short)proxyport);
        err = ap_proxy_host2addr(proxyhost, &server_hp);
        if (err != NULL)
            return DECLINED;    /* try another */
	peer = ap_psprintf(p, "%s:%u", proxyhost, proxyport);  
    }
    else {
        server.sin_port = htons((unsigned short)destport);
        err = ap_proxy_host2addr(desthost, &server_hp);
        if (err != NULL)
            return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, err);
	peer =  ap_psprintf(p, "%s:%u", desthost, destport);  
d297 20
a316 14
    sock = ap_psocket_ex(p, PF_INET, SOCK_STREAM, IPPROTO_TCP, 1);
    if (sock == -1) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                      "proxy: error creating socket");
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (conf->recv_buffer_size) {
        if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
                       (const char *)&conf->recv_buffer_size, sizeof(int))
            == -1) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                          "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
        }
d318 1
a319 9
    j = 0;
    while (server_hp.h_addr_list[j] != NULL) {
        memcpy(&server.sin_addr, server_hp.h_addr_list[j],
               sizeof(struct in_addr));
        i = ap_proxy_doconnect(sock, &server, r);
        if (i == 0)
            break;
        j++;
    }
a359 22

    if (conf->preserve_host) {
        hostname = ap_table_get(r->headers_in, "Host");
        if (!hostname) {
            hostname = r->server->server_hostname;
            ap_log_rerror(APLOG_MARK, APLOG_WARNING, r,
                          "proxy: No host line on incoming request "
                          "and preserve host set forcing hostname to "
                          "be %s for uri %s", hostname, r->uri);
        }
        strp2 = strchr(hostname, ':');
        if (strp2 != NULL) {
            *(strp2++) = '\0';
            if (ap_isdigit(*strp2)) {
                destport = atoi(strp2);
                destportstr = strp2;
            }
        }
    }
    else
        hostname = desthost;

d363 1
a363 1
		    AP_HOOK_SIG6(int,ptr,ptr,ptr,int,ptr), 
d365 1
a365 1
		    &rc, r, f, hostname, destport, destportstr);
d367 2
a368 2
	    if (destportstr != NULL && destport != DEFAULT_HTTP_PORT)
		ap_bvputs(f, "Host: ", hostname, ":", destportstr, CRLF, NULL);
d370 1
a370 1
		ap_bvputs(f, "Host: ", hostname, CRLF, NULL);
d617 5
a621 1
    /* check if NoCache directive on this host */
d623 16
a638 9
        for (i = 0; i < conf->nocaches->nelts; i++) {
            if (destaddr.s_addr == ncent[i].addr.s_addr ||
                (ncent[i].name != NULL &&
                 (ncent[i].name[0] == '*' ||
                  strstr(desthost, ncent[i].name) != NULL))) {
                nocache = 1;
                break;
            }
        }
d640 2
a641 3
        /*
         * update the cache file, possibly even fulfilling the request if it
         * turns out a conditional allowed us to serve the object from the
d653 1
@


1.16
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d154 1
a154 1
    const char *err, *desthost;
d316 22
d343 1
a343 1
		    &rc, r, f, desthost, destport, destportstr);
d346 1
a346 1
		ap_bvputs(f, "Host: ", desthost, ":", destportstr, CRLF, NULL);
d348 1
a348 1
		ap_bvputs(f, "Host: ", desthost, CRLF, NULL);
d595 1
a595 1
/* check if NoCache directive on this host */
@


1.15
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@a172 1
#ifdef EAPI
a173 1
#endif
a194 1
#ifdef EAPI
a198 1
#endif /* EAPI */
a235 1
#ifdef EAPI
a236 1
#endif
a242 1
#ifdef EAPI
a243 1
#endif
a266 12
#ifdef SINIX_D_RESOLVER_BUG
    {
        struct in_addr *ip_addr = (struct in_addr *)*server_hp.h_addr_list;

        for (; ip_addr->s_addr != 0; ++ip_addr) {
            memcpy(&server.sin_addr, ip_addr, sizeof(struct in_addr));
            i = ap_proxy_doconnect(sock, &server, r);
            if (i == 0)
                break;
        }
    }
#else
a275 1
#endif
a302 1
#ifdef EAPI
a311 1
#endif /* EAPI */
a315 1
#ifdef EAPI
a328 7
#else /* EAPI */
    /* Send Host: now, adding it to req_hdrs wouldn't be much better */
    if (destportstr != NULL && destport != DEFAULT_HTTP_PORT)
        ap_bvputs(f, "Host: ", desthost, ":", destportstr, CRLF, NULL);
    else
        ap_bvputs(f, "Host: ", desthost, CRLF, NULL);
#endif /* EAPI */
@


1.14
log
@SECURITY: CAN-2004-0492 (cve.mitre.org)
Reject responses from a remote server if sent an invalid (negative)
Content-Length.  [Mark Cox]
@
text
@a265 1
#if !defined(TPF) && !defined(BEOS)
a273 1
#endif
a664 10

#ifdef CHARSET_EBCDIC
    /*
     * What we read/write after the header should not be modified (i.e., the
     * cache copy is ASCII, not EBCDIC, even for text/html)
     */
    r->ebcdic.conv_in = r->ebcdic.conv_out = 0;
    ap_bsetflag(f, B_ASCII2EBCDIC | B_EBCDIC2ASCII, 0);
    ap_bsetflag(r->connection->client, B_ASCII2EBCDIC | B_EBCDIC2ASCII, 0);
#endif
@


1.13
log
@merge
@
text
@d564 7
@


1.13.2.1
log
@MFC:
Fix by henning@@

SECURITY: CAN-2004-0492 (cve.mitre.org)
Reject responses from a remote server if sent an invalid (negative)
Content-Length.  [Mark Cox]
@
text
@a563 7

	    if (c->len < 0) {
		ap_kill_timeout(r);
		return ap_proxyerror(r, HTTP_BAD_GATEWAY, ap_pstrcat(r->pool,
				     "Invalid Content-Length from remote server",
                                      NULL));
	    }
@


1.13.4.1
log
@MFC:
Fix by henning@@

SECURITY: CAN-2004-0492 (cve.mitre.org)
Reject responses from a remote server if sent an invalid (negative)
Content-Length.  [Mark Cox]
@
text
@a563 7

	    if (c->len < 0) {
		ap_kill_timeout(r);
		return ap_proxyerror(r, HTTP_BAD_GATEWAY, ap_pstrcat(r->pool,
				     "Invalid Content-Length from remote server",
                                      NULL));
	    }
@


1.12
log
@2x trivial strcpy
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
d259 1
a259 1
    sock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);
@


1.11
log
@merge apache 1.3.27 and mod_ssl 2.8.11
@
text
@d371 1
a371 1
            strcpy(portstr, "");
d536 1
a536 1
                strcpy(portstr, "");
@


1.10
log
@merge
@
text
@a565 2
        /* Now add out bound headers set by other modules */
        resp_hdrs = ap_overlay_tables(r->pool, r->err_headers_out, resp_hdrs);
@


1.9
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d79 2
a80 2
    /* do syntatic check.
     * We break the URL into host, port, path, search
d88 4
a91 3
    /* N.B. if this isn't a true proxy request, then the URL _path_
     * has already been decoded.  True proxy requests have r->uri
     * == r->unparsed_uri, and no others have that property.
d150 1
a150 1
                       const char *proxyhost, int proxyport)
d155 1
a155 1
    int i, j, sock, len, backasswards;
d167 1
d171 2
d179 1
a179 1
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
d184 2
a185 1
    if (conf->cache.root == NULL) nocache = 1;
d230 1
a230 1
              (npent[i].name[0] == '*' || strstr(desthost, npent[i].name) != NULL)))
d255 3
a257 2
    /* we have worked out who exactly we are going to connect to, now
     * make that connection...
d262 1
a262 1
                    "proxy: error creating socket");
d269 1
a269 1
                       (const char *) &conf->recv_buffer_size, sizeof(int))
d272 1
a272 1
                         "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
d279 1
a279 1
        struct in_addr *ip_addr = (struct in_addr *) *server_hp.h_addr_list;
d304 2
a305 2
                                "Could not connect to remote machine: ",
                                strerror(errno), NULL));
d311 4
a314 4
    /* build upstream-request headers by stripping r->headers_in from
     * connection specific headers.
     * We must not remove the Connection: header from r->headers_in,
     * we still have to react to Connection: close
d319 3
a321 2
    /* At this point, we start sending the HTTP/1.1 request to the
     * remote server (proxy or otherwise).
d340 1
a340 1
           NULL);
d366 2
a367 1
    } else if (conf->viaopt != via_off) {
d370 4
a373 3
        if (ap_is_default_port(i,r)) {
            strcpy(portstr,"");
        } else {
d378 1
a378 1
                    (conf->viaopt == via_full)
d380 4
a383 4
                                HTTP_VERSION_MAJOR(r->proto_num),
                                HTTP_VERSION_MINOR(r->proto_num),
                                ap_get_server_name(r), portstr,
                                SERVER_BASEVERSION)
d385 4
a388 4
                                HTTP_VERSION_MAJOR(r->proto_num),
                                HTTP_VERSION_MINOR(r->proto_num),
                                ap_get_server_name(r), portstr)
                        );
d391 26
a416 4
    /* Add X-Forwarded-For: so that the upstream has a chance to
       determine, where the original request came from. */
    ap_table_mergen(req_hdrs, "X-Forwarded-For", r->connection->remote_ip);
    
d421 1
a421 1
    reqhdrs_elts = (table_entry *) reqhdrs_arr->elts;
d425 3
a427 2
        /* Clear out hop-by-hop request headers not to send:
         * RFC2616 13.5.1 says we should strip these headers:
d435 10
a444 10

            /* XXX: @@@@@@ FIXME: "Proxy-Authorization" should *only* be 
             * suppressed if THIS server requested the authentication,
             * not when a frontend proxy requested it!
             *
             * The solution to this problem is probably to strip out
             * the Proxy-Authorisation header in the authorisation
             * code itself, not here. This saves us having to signal
             * somehow whether this request was authenticated or not.
             */
d453 1
a453 5
    /* send the request data, if any. */
    if (ap_should_client_block(r)) {
        while ((i = ap_get_client_block(r, buffer, sizeof buffer)) > 0)
            ap_bwrite(f, buffer, i);
    }
d455 2
d460 4
a463 1
    /* Right - now it's time to listen for a response.
d465 12
a476 1
    ap_hard_timeout("proxy receive", r);
d478 3
a480 11
    len = ap_bgets(buffer, sizeof buffer - 1, f);
    if (len == -1) {
        ap_bclose(f);
        ap_kill_timeout(r);
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                     "ap_bgets() - proxy receive - Error reading from remote server %s (length %d)",
                     proxyhost ? proxyhost : desthost, len);
        return ap_proxyerror(r, HTTP_BAD_GATEWAY,
                             "Error reading from remote server");
    } else if (len == 0) {
        ap_bclose(f);
a481 3
        return ap_proxyerror(r, HTTP_BAD_GATEWAY,
                             "Document contains no data");
    }
d483 4
a486 10
    /* Is it an HTTP/1 response?
     * Do some sanity checks on the response.
     * (This is buggy if we ever see an HTTP/1.10)
     */
    if (ap_checkmask(buffer, "HTTP/#.# ###*")) {
        int major, minor;
        if (2 != sscanf(buffer, "HTTP/%u.%u", &major, &minor)) {
            /* if no response, default to HTTP/1.1 - is this correct? */
            major = 1;
            minor = 1;
d489 6
a494 3
        /* If not an HTTP/1 message or if the status line was > 8192 bytes */
        if (buffer[5] != '1' || buffer[len - 1] != '\n') {
            ap_bclose(f);
d496 6
a501 1
            return HTTP_BAD_GATEWAY;
d503 2
a504 2
        backasswards = 0;
        buffer[--len] = '\0';
d506 11
a516 4
        buffer[12] = '\0';
        r->status = atoi(&buffer[9]);
        buffer[12] = ' ';
        r->status_line = ap_pstrdup(p, &buffer[9]);
d522 1
a522 1
        resp_hdrs = ap_proxy_read_headers(r, buffer, HUGE_STRING_LEN, f);
d524 3
a526 3
            ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, r->server,
                 "proxy: Bad HTTP/%d.%d header returned by %s (%s)",
                 major, minor, r->uri, r->method);
d528 1
a528 1
            nocache = 1;    /* do not cache this broken file */
d535 4
a538 3
            if (ap_is_default_port(i,r)) {
                strcpy(portstr,"");
            } else {
d544 3
a546 3
                                major, minor,
                                ap_get_server_name(r), portstr,
                                SERVER_BASEVERSION)
d548 3
a550 3
                                major, minor,
                                ap_get_server_name(r), portstr)
                            );
d553 6
a558 1
        /* strip hop-by-hop headers defined by Connection */
d560 6
d568 1
a568 1
}
a570 3
        backasswards = 1;
        r->status = 200;
        r->status_line = "200 OK";
d579 2
a580 2
     * HTTP/1.1 requires us to accept 3 types of dates, but only generate
     * one type
d582 2
a583 1
    /* we SET the dates here, obliterating possible multiple dates, as only
d595 1
a595 1
      ap_table_set(resp_hdrs, "Location", proxy_location_reverse_map(r, urlstr));
d597 1
a597 1
      ap_table_set(resp_hdrs, "URI", proxy_location_reverse_map(r, urlstr));
d599 1
a599 1
      ap_table_set(resp_hdrs, "Content-Location", proxy_location_reverse_map(r , urlstr));
d606 4
a609 4
                  (ncent[i].name[0] == '*' ||
                   strstr(desthost, ncent[i].name) != NULL))) {
               nocache = 1;
               break;
d613 10
a622 9
    /* update the cache file, possibly even fulfilling the request if
     * it turns out a conditional allowed us to serve the object from the
     * cache...
     */
    i = ap_proxy_cache_update(c, resp_hdrs, !backasswards, nocache);
    if (i != DECLINED) {
        ap_bclose(f);
        return i;
    }
d629 1
a629 1
    ap_overlap_tables(r->headers_out, resp_hdrs, AP_OVERLAP_TABLES_SET);
d632 2
a633 2
                  ap_pstrcat(r->pool, "MISS from ",
                             ap_get_server_name(r), NULL));
d635 2
a636 2
    r->content_type = ap_table_get (r->headers_out, "Content-Type");
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Content-Type: %s", r->content_type);
d641 9
a649 2
    /* Is it an HTTP/0.9 respose? If so, send the extra data we read
       from upstream as the start of the reponse to client */
d656 1
a656 1
                "proxy: error writing extra data to %s", c->tempfile);
d661 1
a661 1

d664 3
a666 2
    /* What we read/write after the header should not be modified
     * (i.e., the cache copy is ASCII, not EBCDIC, even for text/html)
d668 3
a670 2
    ap_bsetflag(f, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);
    ap_bsetflag(r->connection->client, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);
d686 1
a686 1
        ap_proxy_send_fb(f, r, c, c->len, 0, conf->io_buffer_size);
@


1.8
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d79 3
a81 3
/* do syntatic check.
 * We break the URL into host, port, path, search
 */
d85 1
a85 1
	return HTTP_BAD_REQUEST;
d87 5
a91 5
/* now parse path/search args, according to rfc1738 */
/* N.B. if this isn't a true proxy request, then the URL _path_
 * has already been decoded.  True proxy requests have r->uri
 * == r->unparsed_uri, and no others have that property.
 */
d93 3
a95 3
	search = strchr(url, '?');
	if (search != NULL)
	    *(search++) = '\0';
d98 1
a98 1
	search = r->args;
d100 1
a100 1
/* process path */
d102 1
a102 1
			     r->proxyreq);
d104 1
a104 1
	return HTTP_BAD_REQUEST;
d107 1
a107 1
	ap_snprintf(sport, sizeof(sport), ":%d", port);
d109 1
a109 1
	sport[0] = '\0';
d112 1
a112 1
		   path, (search) ? "?" : "", (search) ? search : "", NULL);
d115 2
a116 1
 
a138 23
/* Clear all connection-based headers from the incoming headers table */
static void clear_connection(pool *p, table *headers)
{
    const char *name;
    char *next = ap_pstrdup(p, ap_table_get(headers, "Connection"));

    ap_table_unset(headers, "Proxy-Connection");
    if (!next)
	return;

    while (*next) {
	name = next;
	while (*next && !ap_isspace(*next) && (*next != ','))
	    ++next;
	while (*next && (ap_isspace(*next) || (*next == ','))) {
	    *next = '\0';
	    ++next;
	}
	ap_table_unset(headers, name);
    }
    ap_table_unset(headers, "Connection");
}

d149 1
a149 1
		       const char *proxyhost, int proxyport)
d155 1
d157 1
a157 2
    table *resp_hdrs;
    table_entry *reqhdrs;
a164 1
    const long int zero = 0L;
d168 1
a168 2
    const char *datestr;
    struct tbl_do_args tdo;
d180 2
d185 1
a185 1
/* We break the URL into host, port, path-search */
d189 1
a189 1
	return HTTP_BAD_REQUEST;
d200 2
a201 2
	desthost = ap_pstrdup(p, urlptr);
	urlptr = "/";
d204 5
a208 5
	char *q = ap_palloc(p, strp - urlptr + 1);
	memcpy(q, urlptr, strp - urlptr);
	q[strp - urlptr] = '\0';
	urlptr = strp;
	desthost = q;
d213 5
a217 5
	*(strp2++) = '\0';
	if (ap_isdigit(*strp2)) {
	    destport = atoi(strp2);
	    destportstr = strp2;
	}
d220 1
a220 1
/* check if ProxyBlock directive on this host */
d231 4
a234 4
	server.sin_port = htons(proxyport);
	err = ap_proxy_host2addr(proxyhost, &server_hp);
	if (err != NULL)
	    return DECLINED;	/* try another */
d240 4
a243 4
	server.sin_port = htons(destport);
	err = ap_proxy_host2addr(desthost, &server_hp);
	if (err != NULL)
	    return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, err);
d249 4
d255 3
a257 3
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		    "proxy: error creating socket");
	return HTTP_INTERNAL_SERVER_ERROR;
d262 6
a267 6
	if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
		       (const char *) &conf->recv_buffer_size, sizeof(int))
	    == -1) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
	}
d273 1
a273 1
	struct in_addr *ip_addr = (struct in_addr *) *server_hp.h_addr_list;
d275 6
a280 6
	for (; ip_addr->s_addr != 0; ++ip_addr) {
	    memcpy(&server.sin_addr, ip_addr, sizeof(struct in_addr));
	    i = ap_proxy_doconnect(sock, &server, r);
	    if (i == 0)
		break;
	}
d285 6
a290 6
	memcpy(&server.sin_addr, server_hp.h_addr_list[j],
	       sizeof(struct in_addr));
	i = ap_proxy_doconnect(sock, &server, r);
	if (i == 0)
	    break;
	j++;
d294 6
a299 6
	if (proxyhost != NULL)
	    return DECLINED;	/* try again another way */
	else
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY, ap_pstrcat(r->pool,
				"Could not connect to remote machine: ",
				strerror(errno), NULL));
d302 10
a311 1
    clear_connection(r->pool, r->headers_in);	/* Strip connection-based headers */
d313 3
d332 2
a333 2
    ap_bvputs(f, r->method, " ", proxyhost ? url : urlptr, " HTTP/1.0" CRLF,
	   NULL);
d349 1
d351 1
a351 1
	ap_bvputs(f, "Host: ", desthost, ":", destportstr, CRLF, NULL);
d353 1
a353 1
	ap_bvputs(f, "Host: ", desthost, CRLF, NULL);
d357 2
a358 2
	/* Block all outgoing Via: headers */
	ap_table_unset(r->headers_in, "Via");
d360 28
a387 21
	/* Create a "Via:" request header entry and merge it */
	i = ap_get_server_port(r);
	if (ap_is_default_port(i,r)) {
	    strcpy(portstr,"");
	} else {
	    ap_snprintf(portstr, sizeof portstr, ":%d", i);
	}
	/* Generate outgoing Via: header with/without server comment: */
	ap_table_mergen(r->headers_in, "Via",
		    (conf->viaopt == via_full)
			? ap_psprintf(p, "%d.%d %s%s (%s)",
				HTTP_VERSION_MAJOR(r->proto_num),
				HTTP_VERSION_MINOR(r->proto_num),
				ap_get_server_name(r), portstr,
				SERVER_BASEVERSION)
			: ap_psprintf(p, "%d.%d %s%s",
				HTTP_VERSION_MAJOR(r->proto_num),
				HTTP_VERSION_MINOR(r->proto_num),
				ap_get_server_name(r), portstr)
			);
    }
d389 2
a390 2
    reqhdrs_arr = ap_table_elts(r->headers_in);
    reqhdrs = (table_entry *) reqhdrs_arr->elts;
d392 24
a415 10
	if (reqhdrs[i].key == NULL || reqhdrs[i].val == NULL
	/* Clear out headers not to send */
	    || !strcasecmp(reqhdrs[i].key, "Host")	/* Already sent */
	    /* XXX: @@@@@@ FIXME: "Proxy-Authorization" should *only* be 
	     * suppressed if THIS server requested the authentication,
	     * not when a frontend proxy requested it!
	     */
	    || !strcasecmp(reqhdrs[i].key, "Proxy-Authorization"))
	    continue;
	ap_bvputs(f, reqhdrs[i].key, ": ", reqhdrs[i].val, CRLF, NULL);
d418 1
a419 1
/* send the request data, if any. */
d421 1
d423 2
a424 2
	while ((i = ap_get_client_block(r, buffer, sizeof buffer)) > 0)
	    ap_bwrite(f, buffer, i);
d429 3
d436 7
a442 7
	ap_bclose(f);
	ap_kill_timeout(r);
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "ap_bgets() - proxy receive - Error reading from remote server %s (length %d)",
		     proxyhost ? proxyhost : desthost, len);
	return ap_proxyerror(r, HTTP_BAD_GATEWAY,
			     "Error reading from remote server");
d444 4
a447 4
	ap_bclose(f);
	ap_kill_timeout(r);
	return ap_proxyerror(r, HTTP_BAD_GATEWAY,
			     "Document contains no data");
d450 4
a453 1
/* Is it an HTTP/1 response?  This is buggy if we ever see an HTTP/1.10 */
d455 15
a469 52
	int major, minor;
	if (2 != sscanf(buffer, "HTTP/%u.%u", &major, &minor)) {
	    major = 1;
	    minor = 0;
	}

/* If not an HTTP/1 message or if the status line was > 8192 bytes */
	if (buffer[5] != '1' || buffer[len - 1] != '\n') {
	    ap_bclose(f);
	    ap_kill_timeout(r);
	    return HTTP_BAD_GATEWAY;
	}
	backasswards = 0;
	buffer[--len] = '\0';

	buffer[12] = '\0';
	r->status = atoi(&buffer[9]);
	buffer[12] = ' ';
	r->status_line = ap_pstrdup(p, &buffer[9]);

/* read the headers. */
/* N.B. for HTTP/1.0 clients, we have to fold line-wrapped headers */
/* Also, take care with headers with multiple occurences. */

	resp_hdrs = ap_proxy_read_headers(r, buffer, HUGE_STRING_LEN, f);
	if (resp_hdrs == NULL) {
	    ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, r->server,
		 "proxy: Bad HTTP/%d.%d header returned by %s (%s)",
		 major, minor, r->uri, r->method);
	    resp_hdrs = ap_make_table(p, 20);
	    nocache = 1;    /* do not cache this broken file */
	}

	if (conf->viaopt != via_off && conf->viaopt != via_block) {
	    /* Create a "Via:" response header entry and merge it */
	    i = ap_get_server_port(r);
	    if (ap_is_default_port(i,r)) {
		strcpy(portstr,"");
	    } else {
		ap_snprintf(portstr, sizeof portstr, ":%d", i);
	    }
	    ap_table_mergen((table *)resp_hdrs, "Via",
			    (conf->viaopt == via_full)
			    ? ap_psprintf(p, "%d.%d %s%s (%s)",
				major, minor,
				ap_get_server_name(r), portstr,
				SERVER_BASEVERSION)
			    : ap_psprintf(p, "%d.%d %s%s",
				major, minor,
				ap_get_server_name(r), portstr)
			    );
	}
d471 44
a514 2
	clear_connection(p, resp_hdrs);	/* Strip Connection hdrs */
    }
d516 4
a519 4
/* an http/0.9 response */
	backasswards = 1;
	r->status = 200;
	r->status_line = "200 OK";
d521 2
a522 2
/* no headers */
	resp_hdrs = ap_make_table(p, 20);
a524 2
    c->hdrs = resp_hdrs;

d527 7
a533 4
/*
 * HTTP/1.0 requires us to accept 3 types of dates, but only generate
 * one type
 */
d535 1
a535 1
	ap_table_set(resp_hdrs, "Date", ap_proxy_date_canon(p, datestr));
d537 1
a537 1
	ap_table_set(resp_hdrs, "Last-Modified", ap_proxy_date_canon(p, datestr));
d539 1
a539 1
	ap_table_set(resp_hdrs, "Expires", ap_proxy_date_canon(p, datestr));
d541 7
a547 4
    if ((datestr = ap_table_get(resp_hdrs, "Location")) != NULL)
	ap_table_set(resp_hdrs, "Location", proxy_location_reverse_map(r, datestr));
    if ((datestr = ap_table_get(resp_hdrs, "URI")) != NULL)
	ap_table_set(resp_hdrs, "URI", proxy_location_reverse_map(r, datestr));
d551 9
a559 10
	for (i = 0; i < conf->nocaches->nelts; i++) {
	    if (destaddr.s_addr == ncent[i].addr.s_addr ||
	        (ncent[i].name != NULL &&
		  (ncent[i].name[0] == '*' ||
		   strstr(desthost, ncent[i].name) != NULL))) {
	       nocache = 1;
	       break;
	    }
	}
    }
d561 4
d567 6
a572 2
	ap_bclose(f);
	return i;
d575 12
a586 1
    ap_hard_timeout("proxy receive", r);
d588 2
a589 26
/* write status line */
    if (!r->assbackwards)
	ap_rvputs(r, "HTTP/1.0 ", r->status_line, CRLF, NULL);
    if (c != NULL && c->fp != NULL &&
	ap_bvputs(c->fp, "HTTP/1.0 ", r->status_line, CRLF, NULL) == -1) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
		"proxy: error writing status line to %s", c->tempfile);
	    c = ap_proxy_cache_error(c);
    }

/* send headers */
    tdo.req = r;
    tdo.cache = c;
    ap_table_do(ap_proxy_send_hdr_line, &tdo, resp_hdrs, NULL);

    if (!r->assbackwards)
	ap_rputs(CRLF, r);
    if (c != NULL && c->fp != NULL && ap_bputs(CRLF, c->fp) == -1) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
	    "proxy: error writing CRLF to %s", c->tempfile);
	c = ap_proxy_cache_error(c);
    }

    ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
    r->sent_bodyct = 1;
/* Is it an HTTP/0.9 respose? If so, send the extra data */
d591 9
a599 6
	ap_bwrite(r->connection->client, buffer, len);
	if (c != NULL && c->fp != NULL && ap_bwrite(c->fp, buffer, len) != len) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
		"proxy: error writing extra data to %s", c->tempfile);
	    c = ap_proxy_cache_error(c);
	}
d601 1
a601 1
    ap_kill_timeout(r);
d614 2
d618 7
a624 2
	c->cache_completion = conf->cache.cache_completion;
	ap_proxy_send_fb(f, r, c);
d627 2
a629 2

    ap_bclose(f);
@


1.7
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1996-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 6
a24 9
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
d26 4
a29 3
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
d31 3
a33 4
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
d35 4
a38 4
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 3
a52 5
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
d54 3
d245 5
a249 4
	if ((npent[i].name != NULL && strstr(desthost, npent[i].name) != NULL)
	    || destaddr.s_addr == npent[i].addr.s_addr || npent[i].name[0] == '*')
	    return ap_proxyerror(r, HTTP_FORBIDDEN,
				 "Connect to remote machine blocked");
d518 10
a527 4
    for (i = 0; i < conf->nocaches->nelts; i++) {
	if ((ncent[i].name != NULL && strstr(desthost, ncent[i].name) != NULL)
	    || destaddr.s_addr == ncent[i].addr.s_addr || ncent[i].name[0] == '*')
	    nocache = 1;
@


1.6
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d276 1
a276 1
#ifndef TPF
@


1.5
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d192 3
d255 3
d264 3
d327 1
a327 1
                    AP_HOOK_SIG3(ptr,ptr,ptr), 
d329 1
a329 1
                    &errmsg, r, f);
@


1.4
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d100 2
a101 1
    path = ap_proxy_canonenc(r->pool, url, strlen(url), enc_path, r->proxyreq);
d267 1
d276 1
@


1.3
log
@mod_ssl-2.2.3-1.3.4 (will require libssl-1.1 for https to work, but
mostly harmless otherwise).
@
text
@d242 2
a243 1
	    return ap_proxyerror(r, "Connect to remote machine blocked");
d256 1
a256 1
	    return ap_proxyerror(r, err);	/* give up */
d301 1
a301 1
	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ ap_pstrcat(r->pool,
d319 1
a319 1
            return ap_proxyerror(r, errmsg);
d389 1
a389 1
/* send the request data, if any. N.B. should we trap SIGPIPE ? */
d401 1
a401 1
    if (len == -1 || len == 0) {
d405 9
a413 3
		     "ap_bgets() - proxy receive - Error reading from remote server %s",
		     proxyhost ? proxyhost : desthost);
	return ap_proxyerror(r, "Error reading from remote server");
d522 5
a526 2
	ap_bvputs(c->fp, "HTTP/1.0 ", r->status_line, CRLF, NULL) == -1)
	c = ap_proxy_cache_error(c);
d535 3
a537 1
    if (c != NULL && c->fp != NULL && ap_bputs(CRLF, c->fp) == -1)
d539 1
d546 3
a548 1
	if (c != NULL && c->fp != NULL && ap_bwrite(c->fp, buffer, len) != len)
d550 1
@


1.2
log
@Apache 1.3.4 merge
@
text
@d209 6
d310 12
d325 15
d344 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1996,1997 The Apache Group.  All rights reserved.
d23 2
a24 1
 *    prior written permission.
d26 5
a30 1
 * 5. Redistributions of any form whatsoever must retain the following
d63 1
d72 1
a72 2
int
proxy_http_canon(request_rec *r, char *url, const char *scheme, int def_port)
d74 1
a74 1
    char *host, *path, *search, *p, sport[7];
d82 3
a84 2
    err = proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);
    if (err) return BAD_REQUEST;
d88 2
a89 1
 * has already been decoded
d91 7
a97 6
    if (r->proxyreq)
    {
	p = strchr(url, '?');
	if (p != NULL) *(p++) = '\0';
    } else
	p = r->args;
d100 3
a102 2
    path = proxy_canonenc(r->pool, url, strlen(url), enc_path, r->proxyreq);
    if (path == NULL) return BAD_REQUEST;
d104 4
a107 7
/* process search */
    if (p != NULL)
    {
	search = p;
	if (search == NULL) return BAD_REQUEST;
    } else
	search = NULL;
d109 2
a110 5
    if (port != def_port) ap_snprintf(sport, sizeof(sport), ":%d", port);
    else sport[0] = '\0';

    r->filename = pstrcat(r->pool, "proxy:", scheme, "://", host, sport, "/",
	path, (search) ? "?" : "", (search) ? search : "", NULL);
d113 22
d137 1
a137 1
static void clear_connection (table *headers)
d139 2
a140 2
    char *name;
    char *next = table_get(headers, "Connection");
d142 3
a144 1
    if (!next) return;
d147 8
a154 7
        name = next;
        while (*next && !isspace(*next) && (*next != ',')) ++next;
        while (*next && (isspace(*next) || (*next == ','))) {
            *next = '\0';
            ++next;
        }
        table_unset(headers, name);
d156 1
a156 1
    table_unset(headers, "Connection");
d168 2
a169 3
int
proxy_http_handler(request_rec *r, struct cache_req *c, char *url,
	     const char *proxyhost, int proxyport)
d171 2
a172 1
    char *p;
d175 2
a176 1
    array_header *reqhdrs_arr, *resp_hdrs;
d181 1
a181 2
    BUFF *f, *cache;
    struct hdr_entry *hdr;
d183 3
a185 2
    pool *pool=r->pool;
    const long int zero=0L;
d188 3
a190 1
    char *urlptr = NULL;
d194 3
a196 3
        (proxy_server_conf *)get_module_config(sconf, &proxy_module);
    struct noproxy_entry *npent=(struct noproxy_entry *)conf->noproxies->elts;
    struct nocache_entry *ncent=(struct nocache_entry *)conf->nocaches->elts;
d204 3
a206 2
    urlptr = strstr(url,"://");
    if (urlptr == NULL) return BAD_REQUEST;
d208 20
a227 23
    destport = DEFAULT_PORT;
    p = strchr(urlptr, '/');
    if (p == NULL)
    {
        desthost = pstrdup(pool, urlptr);
        urlptr = "/";
    } else
    {
        char *q = palloc(pool, p-urlptr+1);
        memcpy(q, urlptr, p-urlptr);
        q[p-urlptr] = '\0';
        urlptr = p;
        desthost = q;
    }

    p = strchr(desthost, ':');
    if (p != NULL)
    {
        *(p++) = '\0';
	if (isdigit(*p))
	{
            destport = atoi(p);
            destportstr = p;
d232 5
a236 6
    destaddr.s_addr = inet_addr(desthost);
    for (i=0; i < conf->noproxies->nelts; i++)
    {
        if ((npent[i].name != NULL && strstr(desthost, npent[i].name) != NULL)
	  || destaddr.s_addr == npent[i].addr.s_addr || npent[i].name[0] == '*')
	    return proxyerror(r, "Connect to remote machine blocked");
d239 1
a239 2
    if (proxyhost != NULL)
    {
d241 5
a245 4
	err = proxy_host2addr(proxyhost, &server_hp);
	if (err != NULL) return DECLINED;  /* try another */
    } else
    {
d247 19
a265 2
	err = proxy_host2addr(desthost, &server_hp);
	if (err != NULL) return proxyerror(r, err); /* give up */
d268 1
a268 2
    sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sock == -1)
d270 8
a277 2
	log_error("proxy: error creating socket", r->server);
	return SERVER_ERROR;
d279 1
a279 3
    note_cleanups_for_fd(pool, sock);

    
d283 2
a284 2
	    sizeof(struct in_addr));
        i = proxy_doconnect(sock, &server, r);
d289 20
a308 17
    if (i == -1)
    {
	if (proxyhost != NULL) return DECLINED; /* try again another way */
	else return proxyerror(r, "Could not connect to remote machine");
    }

    clear_connection(r->headers_in);	/* Strip connection-based headers */

    f = bcreate(pool, B_RDWR);
    bpushfd(f, sock, sock);

    hard_timeout ("proxy send", r);
    bvputs(f, r->method, " ", proxyhost ? url : urlptr, " HTTP/1.0\015\012",
           NULL);
    bvputs(f, "Host: ", desthost, NULL);
    if (destportstr != NULL && destport != DEFAULT_PORT)
	bvputs(f, ":", destportstr, "\015\012", NULL);
d310 1
a310 1
	bputs("\015\012", f);
d312 29
a340 4
    reqhdrs_arr = table_elts (r->headers_in);
    reqhdrs = (table_entry *)reqhdrs_arr->elts;
    for (i=0; i < reqhdrs_arr->nelts; i++)
    {
d342 7
a348 1
	  || !strcasecmp(reqhdrs[i].key, "Host"))  /* already sent if there */
d350 1
a350 1
	bvputs(f, reqhdrs[i].key, ": ", reqhdrs[i].val, "\015\012", NULL);
d353 1
a353 1
    bputs("\015\012", f);
d356 17
a372 4
    if (should_client_block(r))
    {
	while ((i = get_client_block(r, buffer, HUGE_STRING_LEN)) > 0)
            bwrite(f, buffer, i);
a373 2
    bflush(f);
    kill_timeout(r);
d375 7
a381 9
    hard_timeout ("proxy receive", r);
    
    len = bgets(buffer, HUGE_STRING_LEN-1, f);
    if (len == -1 || len == 0)
    {
	pclosef(pool, sock);
	kill_timeout(r);
	return proxyerror(r, "Error reading from remote server");
    }
d383 5
a387 9
/* Is it an HTTP/1 response?  This is buggy if we ever see an HTTP/1.10 */
    if (checkmask(buffer,  "HTTP/#.# ###*"))
    {
/* If not an HTTP/1 messsage or if the status line was > 8192 bytes */
	if (buffer[5] != '1' || buffer[len-1] != '\n')
	{
	    pclosef(pool, sock);
	    kill_timeout(r);
	    return BAD_GATEWAY;
d395 1
a395 1
	r->status_line = pstrdup(pool, &buffer[9]);
d401 8
a408 1
	resp_hdrs = proxy_read_headers(pool, buffer, HUGE_STRING_LEN, f);
d410 21
a430 1
	clear_connection((table *)resp_hdrs);  /* Strip Connection hdrs */
d432 1
a432 2
    else
    {
d439 1
a439 1
	resp_hdrs = make_array(pool, 2, sizeof(struct hdr_entry));
d442 3
a444 1
    kill_timeout(r);
d450 11
a460 11
    
    hdr = (struct hdr_entry *)resp_hdrs->elts;
    for (i=0; i < resp_hdrs->nelts; i++)
    {
	if (hdr[i].value[0] == '\0') continue;
	p = hdr[i].field;
	if (strcasecmp(p, "Date") == 0 ||
	    strcasecmp(p, "Last-Modified") == 0 ||
	    strcasecmp(p, "Expires") == 0)
	    hdr[i].value = proxy_date_canon(pool, hdr[i].value);
    }
d463 4
a466 5
    for (i=0; i < conf->nocaches->nelts; i++)
    {
        if ((ncent[i].name != NULL && strstr(desthost, ncent[i].name) != NULL)
	  || destaddr.s_addr == ncent[i].addr.s_addr || ncent[i].name[0] == '*')
	    nocache = 1; 
d469 3
a471 4
    i = proxy_cache_update(c, resp_hdrs, !backasswards, nocache);
    if (i != DECLINED)
    {
	pclosef(pool, sock);
d475 1
a475 3
    cache = c->fp;

    hard_timeout ("proxy receive", r);
d479 4
a482 4
        rvputs(r, "HTTP/1.0 ", r->status_line, "\015\012", NULL);
    if (cache != NULL)
	if (bvputs(cache, "HTTP/1.0 ", r->status_line, "\015\012", NULL) == -1)
	    cache = proxy_cache_error(c);
d485 3
a487 11
    for (i=0; i < resp_hdrs->nelts; i++)
    {
	if (hdr[i].field == NULL || hdr[i].value == NULL ||
	    hdr[i].value[0] == '\0') continue;
	if (!r->assbackwards)
	    rvputs(r, hdr[i].field, ": ", hdr[i].value, "\015\012", NULL);
	if (cache != NULL)
	    if (bvputs(cache, hdr[i].field, ": ", hdr[i].value, "\015\012",
		       NULL) == -1)
		cache = proxy_cache_error(c);
    }
d489 4
a492 3
    if (!r->assbackwards) rputs("\015\012", r);
    if (cache != NULL)
	if (bputs("\015\012", cache) == -1) cache = proxy_cache_error(c);
d494 1
a494 1
    bsetopt(r->connection->client, BO_BYTECT, &zero);
d497 14
a510 7
    if (backasswards)
    {
	bwrite(r->connection->client, buffer, len);
	if (cache != NULL)
	    if (bwrite(f, buffer, len) != len) cache = proxy_cache_error(c);
    }
    kill_timeout(r);
d515 5
a519 1
    if (!r->header_only) proxy_send_fb(f, r, cache, c);
d521 1
a521 1
    proxy_cache_tidy(c);
d523 1
a523 1
    pclosef(pool, sock);
d525 1
a525 1
    proxy_garbage_coll(r);
a527 1

@


1.1.1.1
log
@Initial import from apache 1.2.6
@
text
@@


1.1.1.2
log
@Apache 1.3.2
@
text
@d2 1
a2 1
 * Copyright (c) 1996-1998 The Apache Group.  All rights reserved.
d23 1
a23 2
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
d25 1
a25 5
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
a57 1
#include "http_core.h"
d66 2
a67 1
int ap_proxy_http_canon(request_rec *r, char *url, const char *scheme, int def_port)
d69 1
a69 1
    char *host, *path, *search, sport[7];
d77 2
a78 3
    err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);
    if (err)
	return HTTP_BAD_REQUEST;
d82 1
a82 2
 * has already been decoded.  True proxy requests have r->uri
 * == r->unparsed_uri, and no others have that property.
d84 6
a89 7
    if (r->uri == r->unparsed_uri) {
	search = strchr(url, '?');
	if (search != NULL)
	    *(search++) = '\0';
    }
    else
	search = r->args;
d92 2
a93 3
    path = ap_proxy_canonenc(r->pool, url, strlen(url), enc_path, r->proxyreq);
    if (path == NULL)
	return HTTP_BAD_REQUEST;
d95 10
a104 4
    if (port != def_port)
	ap_snprintf(sport, sizeof(sport), ":%d", port);
    else
	sport[0] = '\0';
d106 2
a107 2
    r->filename = ap_pstrcat(r->pool, "proxy:", scheme, "://", host, sport, "/",
		   path, (search) ? "?" : "", (search) ? search : "", NULL);
a109 22
 
static const char *proxy_location_reverse_map(request_rec *r, const char *url)
{
    void *sconf;
    proxy_server_conf *conf;
    struct proxy_alias *ent;
    int i, l1, l2;
    char *u;

    sconf = r->server->module_config;
    conf = (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
    l1 = strlen(url);
    ent = (struct proxy_alias *)conf->raliases->elts;
    for (i = 0; i < conf->raliases->nelts; i++) {
        l2 = strlen(ent[i].real);
        if (l1 >= l2 && strncmp(ent[i].real, url, l2) == 0) {
            u = ap_pstrcat(r->pool, ent[i].fake, &url[l2], NULL);
            return ap_construct_url(r->pool, u, r);
        }
    }
    return url;
}
d112 1
a112 1
static void clear_connection(pool *p, table *headers)
d114 2
a115 2
    const char *name;
    char *next = ap_pstrdup(p, ap_table_get(headers, "Connection"));
d117 1
a117 3
    ap_table_unset(headers, "Proxy-Connection");
    if (!next)
	return;
d120 7
a126 8
	name = next;
	while (*next && !ap_isspace(*next) && (*next != ','))
	    ++next;
	while (*next && (ap_isspace(*next) || (*next == ','))) {
	    *next = '\0';
	    ++next;
	}
	ap_table_unset(headers, name);
d128 1
a128 1
    ap_table_unset(headers, "Connection");
d140 3
a142 2
int ap_proxy_http_handler(request_rec *r, cache_req *c, char *url,
		       const char *proxyhost, int proxyport)
d144 1
a144 2
    const char *strp;
    char *strp2;
d147 1
a147 2
    array_header *reqhdrs_arr;
    table *resp_hdrs;
d152 2
a153 1
    BUFF *f;
d155 2
a156 3
    char portstr[32];
    pool *p = r->pool;
    const long int zero = 0L;
d159 1
a159 3
    const char *urlptr = NULL;
    const char *datestr;
    struct tbl_do_args tdo;
d163 3
a165 3
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
    struct noproxy_entry *npent = (struct noproxy_entry *) conf->noproxies->elts;
    struct nocache_entry *ncent = (struct nocache_entry *) conf->nocaches->elts;
d173 2
a174 3
    urlptr = strstr(url, "://");
    if (urlptr == NULL)
	return HTTP_BAD_REQUEST;
d176 23
a198 20
    destport = DEFAULT_HTTP_PORT;
    strp = strchr(urlptr, '/');
    if (strp == NULL) {
	desthost = ap_pstrdup(p, urlptr);
	urlptr = "/";
    }
    else {
	char *q = ap_palloc(p, strp - urlptr + 1);
	memcpy(q, urlptr, strp - urlptr);
	q[strp - urlptr] = '\0';
	urlptr = strp;
	desthost = q;
    }

    strp2 = strchr(desthost, ':');
    if (strp2 != NULL) {
	*(strp2++) = '\0';
	if (ap_isdigit(*strp2)) {
	    destport = atoi(strp2);
	    destportstr = strp2;
d203 6
a208 5
    destaddr.s_addr = ap_inet_addr(desthost);
    for (i = 0; i < conf->noproxies->nelts; i++) {
	if ((npent[i].name != NULL && strstr(desthost, npent[i].name) != NULL)
	    || destaddr.s_addr == npent[i].addr.s_addr || npent[i].name[0] == '*')
	    return ap_proxyerror(r, "Connect to remote machine blocked");
d211 2
a212 1
    if (proxyhost != NULL) {
d214 4
a217 5
	err = ap_proxy_host2addr(proxyhost, &server_hp);
	if (err != NULL)
	    return DECLINED;	/* try another */
    }
    else {
d219 2
a220 19
	err = ap_proxy_host2addr(desthost, &server_hp);
	if (err != NULL)
	    return ap_proxyerror(r, err);	/* give up */
    }

    sock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sock == -1) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		    "proxy: error creating socket");
	return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (conf->recv_buffer_size) {
	if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
		       (const char *) &conf->recv_buffer_size, sizeof(int))
	    == -1) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
	}
d223 2
a224 1
#ifdef SINIX_D_RESOLVER_BUG
d226 4
a229 1
	struct in_addr *ip_addr = (struct in_addr *) *server_hp.h_addr_list;
d231 1
a231 8
	for (; ip_addr->s_addr != 0; ++ip_addr) {
	    memcpy(&server.sin_addr, ip_addr, sizeof(struct in_addr));
	    i = ap_proxy_doconnect(sock, &server, r);
	    if (i == 0)
		break;
	}
    }
#else
d235 2
a236 2
	       sizeof(struct in_addr));
	i = ap_proxy_doconnect(sock, &server, r);
d241 17
a257 20
#endif
    if (i == -1) {
	if (proxyhost != NULL)
	    return DECLINED;	/* try again another way */
	else
	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ ap_pstrcat(r->pool,
				"Could not connect to remote machine: ",
				strerror(errno), NULL));
    }

    clear_connection(r->pool, r->headers_in);	/* Strip connection-based headers */

    f = ap_bcreate(p, B_RDWR | B_SOCKET);
    ap_bpushfd(f, sock, sock);

    ap_hard_timeout("proxy send", r);
    ap_bvputs(f, r->method, " ", proxyhost ? url : urlptr, " HTTP/1.0" CRLF,
	   NULL);
    if (destportstr != NULL && destport != DEFAULT_HTTP_PORT)
	ap_bvputs(f, "Host: ", desthost, ":", destportstr, CRLF, NULL);
d259 1
a259 1
	ap_bvputs(f, "Host: ", desthost, CRLF, NULL);
d261 4
a264 29
    if (conf->viaopt == via_block) {
	/* Block all outgoing Via: headers */
	ap_table_unset(r->headers_in, "Via");
    } else if (conf->viaopt != via_off) {
	/* Create a "Via:" request header entry and merge it */
	i = ap_get_server_port(r);
	if (ap_is_default_port(i,r)) {
	    strcpy(portstr,"");
	} else {
	    ap_snprintf(portstr, sizeof portstr, ":%d", i);
	}
	/* Generate outgoing Via: header with/without server comment: */
	ap_table_mergen(r->headers_in, "Via",
		    (conf->viaopt == via_full)
			? ap_psprintf(p, "%d.%d %s%s (%s)",
				HTTP_VERSION_MAJOR(r->proto_num),
				HTTP_VERSION_MINOR(r->proto_num),
				ap_get_server_name(r), portstr,
				SERVER_BASEVERSION)
			: ap_psprintf(p, "%d.%d %s%s",
				HTTP_VERSION_MAJOR(r->proto_num),
				HTTP_VERSION_MINOR(r->proto_num),
				ap_get_server_name(r), portstr)
			);
    }

    reqhdrs_arr = ap_table_elts(r->headers_in);
    reqhdrs = (table_entry *) reqhdrs_arr->elts;
    for (i = 0; i < reqhdrs_arr->nelts; i++) {
d266 1
a266 7
	/* Clear out headers not to send */
	    || !strcasecmp(reqhdrs[i].key, "Host")	/* Already sent */
	    /* XXX: @@@@@@ FIXME: "Proxy-Authorization" should *only* be 
	     * suppressed if THIS server requested the authentication,
	     * not when a frontend proxy requested it!
	     */
	    || !strcasecmp(reqhdrs[i].key, "Proxy-Authorization"))
d268 1
a268 1
	ap_bvputs(f, reqhdrs[i].key, ": ", reqhdrs[i].val, CRLF, NULL);
d271 1
a271 1
    ap_bputs(CRLF, f);
d274 16
a289 17
    if (ap_should_client_block(r)) {
	while ((i = ap_get_client_block(r, buffer, sizeof buffer)) > 0)
	    ap_bwrite(f, buffer, i);
    }
    ap_bflush(f);
    ap_kill_timeout(r);

    ap_hard_timeout("proxy receive", r);

    len = ap_bgets(buffer, sizeof buffer - 1, f);
    if (len == -1 || len == 0) {
	ap_bclose(f);
	ap_kill_timeout(r);
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "ap_bgets() - proxy receive - Error reading from remote server %s",
		     proxyhost ? proxyhost : desthost);
	return ap_proxyerror(r, "Error reading from remote server");
d293 8
a300 12
    if (ap_checkmask(buffer, "HTTP/#.# ###*")) {
	int major, minor;
	if (2 != sscanf(buffer, "HTTP/%u.%u", &major, &minor)) {
	    major = 1;
	    minor = 0;
	}

/* If not an HTTP/1 message or if the status line was > 8192 bytes */
	if (buffer[5] != '1' || buffer[len - 1] != '\n') {
	    ap_bclose(f);
	    ap_kill_timeout(r);
	    return HTTP_BAD_GATEWAY;
d308 1
a308 1
	r->status_line = ap_pstrdup(p, &buffer[9]);
d314 1
a314 8
	resp_hdrs = ap_proxy_read_headers(r, buffer, HUGE_STRING_LEN, f);
	if (resp_hdrs == NULL) {
	    ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, r->server,
		 "proxy: Bad HTTP/%d.%d header returned by %s (%s)",
		 major, minor, r->uri, r->method);
	    resp_hdrs = ap_make_table(p, 20);
	    nocache = 1;    /* do not cache this broken file */
	}
d316 1
a316 21
	if (conf->viaopt != via_off && conf->viaopt != via_block) {
	    /* Create a "Via:" response header entry and merge it */
	    i = ap_get_server_port(r);
	    if (ap_is_default_port(i,r)) {
		strcpy(portstr,"");
	    } else {
		ap_snprintf(portstr, sizeof portstr, ":%d", i);
	    }
	    ap_table_mergen((table *)resp_hdrs, "Via",
			    (conf->viaopt == via_full)
			    ? ap_psprintf(p, "%d.%d %s%s (%s)",
				major, minor,
				ap_get_server_name(r), portstr,
				SERVER_BASEVERSION)
			    : ap_psprintf(p, "%d.%d %s%s",
				major, minor,
				ap_get_server_name(r), portstr)
			    );
	}

	clear_connection(p, resp_hdrs);	/* Strip Connection hdrs */
d318 2
a319 1
    else {
d326 1
a326 1
	resp_hdrs = ap_make_table(p, 20);
d329 1
a329 3
    c->hdrs = resp_hdrs;

    ap_kill_timeout(r);
d335 11
a345 11
    if ((datestr = ap_table_get(resp_hdrs, "Date")) != NULL)
	ap_table_set(resp_hdrs, "Date", ap_proxy_date_canon(p, datestr));
    if ((datestr = ap_table_get(resp_hdrs, "Last-Modified")) != NULL)
	ap_table_set(resp_hdrs, "Last-Modified", ap_proxy_date_canon(p, datestr));
    if ((datestr = ap_table_get(resp_hdrs, "Expires")) != NULL)
	ap_table_set(resp_hdrs, "Expires", ap_proxy_date_canon(p, datestr));

    if ((datestr = ap_table_get(resp_hdrs, "Location")) != NULL)
	ap_table_set(resp_hdrs, "Location", proxy_location_reverse_map(r, datestr));
    if ((datestr = ap_table_get(resp_hdrs, "URI")) != NULL)
	ap_table_set(resp_hdrs, "URI", proxy_location_reverse_map(r, datestr));
d348 5
a352 4
    for (i = 0; i < conf->nocaches->nelts; i++) {
	if ((ncent[i].name != NULL && strstr(desthost, ncent[i].name) != NULL)
	    || destaddr.s_addr == ncent[i].addr.s_addr || ncent[i].name[0] == '*')
	    nocache = 1;
d355 4
a358 3
    i = ap_proxy_cache_update(c, resp_hdrs, !backasswards, nocache);
    if (i != DECLINED) {
	ap_bclose(f);
d362 3
a364 1
    ap_hard_timeout("proxy receive", r);
d368 4
a371 4
	ap_rvputs(r, "HTTP/1.0 ", r->status_line, CRLF, NULL);
    if (c != NULL && c->fp != NULL &&
	ap_bvputs(c->fp, "HTTP/1.0 ", r->status_line, CRLF, NULL) == -1)
	c = ap_proxy_cache_error(c);
d374 11
a384 3
    tdo.req = r;
    tdo.cache = c;
    ap_table_do(ap_proxy_send_hdr_line, &tdo, resp_hdrs, NULL);
d386 3
a388 4
    if (!r->assbackwards)
	ap_rputs(CRLF, r);
    if (c != NULL && c->fp != NULL && ap_bputs(CRLF, c->fp) == -1)
	c = ap_proxy_cache_error(c);
d390 1
a390 1
    ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
d393 7
a399 14
    if (backasswards) {
	ap_bwrite(r->connection->client, buffer, len);
	if (c != NULL && c->fp != NULL && ap_bwrite(c->fp, buffer, len) != len)
	    c = ap_proxy_cache_error(c);
    }
    ap_kill_timeout(r);

#ifdef CHARSET_EBCDIC
    /* What we read/write after the header should not be modified
     * (i.e., the cache copy is ASCII, not EBCDIC, even for text/html)
     */
    ap_bsetflag(f, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);
    ap_bsetflag(r->connection->client, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);
#endif
d404 1
a404 5
    if (!r->header_only) {
/* we need to set this for ap_proxy_send_fb()... */
	c->cache_completion = conf->cache.cache_completion;
	ap_proxy_send_fb(f, r, c);
    }
d406 1
a406 1
    ap_proxy_cache_tidy(c);
d408 1
a408 1
    ap_bclose(f);
d410 1
a410 1
    ap_proxy_garbage_coll(r);
d413 1
@


1.1.1.3
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 9
a24 6
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
d26 3
a28 4
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
d30 4
a33 3
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
d35 4
a38 4
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 5
a54 3
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
a55 3
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
d78 3
a80 3
    /*
     * do syntatic check. We break the URL into host, port, path, search
     */
d84 1
a84 1
        return HTTP_BAD_REQUEST;
d86 5
a90 6
    /* now parse path/search args, according to rfc1738 */
    /*
     * N.B. if this isn't a true proxy request, then the URL _path_ has
     * already been decoded.  True proxy requests have r->uri ==
     * r->unparsed_uri, and no others have that property.
     */
d92 3
a94 3
        search = strchr(url, '?');
        if (search != NULL)
            *(search++) = '\0';
d97 1
a97 1
        search = r->args;
d99 2
a100 3
    /* process path */
    path = ap_proxy_canonenc(r->pool, url, strlen(url), enc_path,
                             r->proxyreq);
d102 1
a102 1
        return HTTP_BAD_REQUEST;
d105 1
a105 1
        ap_snprintf(sport, sizeof(sport), ":%d", port);
d107 1
a107 1
        sport[0] = '\0';
d110 1
a110 1
                   path, (search) ? "?" : "", (search) ? search : "", NULL);
d113 1
a113 2

/* handle the conversion of URLs in the ProxyPassReverse function */
d136 23
d169 1
a169 1
                              const char *proxyhost, int proxyport)
d174 1
a174 2
    int i, j, sock,/* len,*/ backasswards;
    table *req_hdrs, *resp_hdrs;
d176 2
a177 1
    table_entry *reqhdrs_elts;
d185 1
a186 1
    int chunked = 0;
d189 2
a190 3
    const char *datestr, *urlstr;
    int result, major, minor;
    const char *content_length;
d194 1
a194 1
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
a198 3
    if (conf->cache.root == NULL)
        nocache = 1;

d202 1
a202 1
    /* We break the URL into host, port, path-search */
d206 1
a206 1
        return HTTP_BAD_REQUEST;
d211 2
a212 2
        desthost = ap_pstrdup(p, urlptr);
        urlptr = "/";
d215 5
a219 5
        char *q = ap_palloc(p, strp - urlptr + 1);
        memcpy(q, urlptr, strp - urlptr);
        q[strp - urlptr] = '\0';
        urlptr = strp;
        desthost = q;
d224 5
a228 5
        *(strp2++) = '\0';
        if (ap_isdigit(*strp2)) {
            destport = atoi(strp2);
            destportstr = strp2;
        }
d231 1
a231 1
    /* check if ProxyBlock directive on this host */
d234 3
a236 5
        if (destaddr.s_addr == npent[i].addr.s_addr ||
            (npent[i].name != NULL &&
             (npent[i].name[0] == '*' || strstr(desthost, npent[i].name) != NULL)))
            return ap_proxyerror(r, HTTP_FORBIDDEN,
                                 "Connect to remote machine blocked");
d240 4
a243 4
        server.sin_port = htons((unsigned short)proxyport);
        err = ap_proxy_host2addr(proxyhost, &server_hp);
        if (err != NULL)
            return DECLINED;    /* try another */
d246 4
a249 4
        server.sin_port = htons((unsigned short)destport);
        err = ap_proxy_host2addr(desthost, &server_hp);
        if (err != NULL)
            return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, err);
a251 5

    /*
     * we have worked out who exactly we are going to connect to, now make
     * that connection...
     */
d254 3
a256 3
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                      "proxy: error creating socket");
        return HTTP_INTERNAL_SERVER_ERROR;
a258 1
#if !defined(TPF) && !defined(BEOS)
d260 6
a265 6
        if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
                       (const char *)&conf->recv_buffer_size, sizeof(int))
            == -1) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                          "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
        }
a266 1
#endif
d270 1
a270 1
        struct in_addr *ip_addr = (struct in_addr *)*server_hp.h_addr_list;
d272 6
a277 6
        for (; ip_addr->s_addr != 0; ++ip_addr) {
            memcpy(&server.sin_addr, ip_addr, sizeof(struct in_addr));
            i = ap_proxy_doconnect(sock, &server, r);
            if (i == 0)
                break;
        }
d282 6
a287 6
        memcpy(&server.sin_addr, server_hp.h_addr_list[j],
               sizeof(struct in_addr));
        i = ap_proxy_doconnect(sock, &server, r);
        if (i == 0)
            break;
        j++;
d291 6
a296 6
        if (proxyhost != NULL)
            return DECLINED;    /* try again another way */
        else
            return ap_proxyerror(r, HTTP_BAD_GATEWAY, ap_pstrcat(r->pool,
                                    "Could not connect to remote machine: ",
                                                    strerror(errno), NULL));
d299 1
a299 10
    /* record request_time for HTTP/1.1 age calculation */
    c->req_time = time(NULL);

    /*
     * build upstream-request headers by stripping r->headers_in from
     * connection specific headers. We must not remove the Connection: header
     * from r->headers_in, we still have to react to Connection: close
     */
    req_hdrs = ap_copy_table(r->pool, r->headers_in);
    ap_proxy_clear_connection(r->pool, req_hdrs);
a300 4
    /*
     * At this point, we start sending the HTTP/1.1 request to the remote
     * server (proxy or otherwise).
     */
d305 2
a306 3
    ap_bvputs(f, r->method, " ", proxyhost ? url : urlptr, " HTTP/1.1" CRLF,
              NULL);
    /* Send Host: now, adding it to req_hdrs wouldn't be much better */
d308 1
a308 1
        ap_bvputs(f, "Host: ", desthost, ":", destportstr, CRLF, NULL);
d310 1
a310 1
        ap_bvputs(f, "Host: ", desthost, CRLF, NULL);
d313 23
a335 25
        /* Block all outgoing Via: headers */
        ap_table_unset(req_hdrs, "Via");
    }
    else if (conf->viaopt != via_off) {
        /* Create a "Via:" request header entry and merge it */
        i = ap_get_server_port(r);
        if (ap_is_default_port(i, r)) {
            strcpy(portstr, "");
        }
        else {
            ap_snprintf(portstr, sizeof portstr, ":%d", i);
        }
        /* Generate outgoing Via: header with/without server comment: */
        ap_table_mergen(req_hdrs, "Via",
                        (conf->viaopt == via_full)
                        ? ap_psprintf(p, "%d.%d %s%s (%s)",
                                      HTTP_VERSION_MAJOR(r->proto_num),
                                      HTTP_VERSION_MINOR(r->proto_num),
                                      ap_get_server_name(r), portstr,
                                      SERVER_BASEVERSION)
                        : ap_psprintf(p, "%d.%d %s%s",
                                      HTTP_VERSION_MAJOR(r->proto_num),
                                      HTTP_VERSION_MINOR(r->proto_num),
                                      ap_get_server_name(r), portstr)
            );
d338 2
a339 31
    /* the X-* headers are only added if we are a reverse
     * proxy, otherwise we would be giving away private information.
     */
    if (r->proxyreq == PROXY_PASS) {
        const char *buf;

        /*
         * Add X-Forwarded-For: so that the upstream has a chance to determine,
         * where the original request came from.
         */
        ap_table_mergen(req_hdrs, "X-Forwarded-For", r->connection->remote_ip);

        /* Add X-Forwarded-Host: so that upstream knows what the
         * original request hostname was.
         */
        if ((buf = ap_table_get(r->headers_in, "Host"))) {
            ap_table_mergen(req_hdrs, "X-Forwarded-Host", buf);
        }

        /* Add X-Forwarded-Server: so that upstream knows what the
         * name of this proxy server is (if there are more than one)
         * XXX: This duplicates Via: - do we strictly need it?
         */
        ap_table_mergen(req_hdrs, "X-Forwarded-Server", r->server->server_hostname);
    } 

    /* we don't yet support keepalives - but we will soon, I promise! */
    ap_table_set(req_hdrs, "Connection", "close");

    reqhdrs_arr = ap_table_elts(req_hdrs);
    reqhdrs_elts = (table_entry *)reqhdrs_arr->elts;
d341 10
a350 25
        if (reqhdrs_elts[i].key == NULL || reqhdrs_elts[i].val == NULL

        /*
         * Clear out hop-by-hop request headers not to send: RFC2616 13.5.1
         * says we should strip these headers:
         */
            || !strcasecmp(reqhdrs_elts[i].key, "Host") /* Already sent */
            || !strcasecmp(reqhdrs_elts[i].key, "Keep-Alive")
            || !strcasecmp(reqhdrs_elts[i].key, "TE")
            || !strcasecmp(reqhdrs_elts[i].key, "Trailer")
            || !strcasecmp(reqhdrs_elts[i].key, "Transfer-Encoding")
            || !strcasecmp(reqhdrs_elts[i].key, "Upgrade")
        /*
         * XXX: @@@@@@ FIXME: "Proxy-Authorization" should *only* be suppressed
         * if THIS server requested the authentication, not when a frontend
         * proxy requested it!
         * 
         * The solution to this problem is probably to strip out the
         * Proxy-Authorisation header in the authorisation code itself, not
         * here. This saves us having to signal somehow whether this request
         * was authenticated or not.
         */
            || !strcasecmp(reqhdrs_elts[i].key, "Proxy-Authorization"))
            continue;
        ap_bvputs(f, reqhdrs_elts[i].key, ": ", reqhdrs_elts[i].val, CRLF, NULL);
a352 1
    /* the obligatory empty line to mark the end of the headers */
d354 1
d356 4
a359 1
    /* and flush the above away */
a360 2

    /* and kill the send timeout */
d363 1
d365 64
a428 28
    /* read the request data, and pass it to the backend.
     * we might encounter a stray 100-continue reponse from a PUT or POST,
     * if this happens we ignore the 100 continue status line and read the
     * response again.
     */
    {
        /* send the request data, if any. */
        ap_hard_timeout("proxy receive request data", r);
        if (ap_should_client_block(r)) {
            while ((i = ap_get_client_block(r, buffer, sizeof buffer)) > 0) {
                ap_reset_timeout(r);
                ap_bwrite(f, buffer, i);
            }
        }
        ap_bflush(f);
        ap_kill_timeout(r);


        /* then, read a response line */
        ap_hard_timeout("proxy receive response status line", r);
        result = ap_proxy_read_response_line(f, r, buffer, sizeof(buffer)-1, &backasswards, &major, &minor);
        ap_kill_timeout(r);

        /* trap any errors */
        if (result != OK) {
            ap_bclose(f);
            return result;
        }
d430 1
a430 14
        /* if this response was 100-continue, a stray response has been caught.
         * read the line again for the real response
         */
        if (r->status == 100) {
            ap_hard_timeout("proxy receive response status line", r);
            result = ap_proxy_read_response_line(f, r, buffer, sizeof(buffer)-1, &backasswards, &major, &minor);
            ap_kill_timeout(r);

            /* trap any errors */
            if (result != OK) {
                ap_bclose(f);
                return result;
            }
        }
d432 5
d438 2
a439 63

    /*
     * We have our response status line from the convoluted code above,
     * now we read the headers to continue.
     */
    ap_hard_timeout("proxy receive response headers", r);

    /*
     * Is it an HTTP/1 response? Do some sanity checks on the response. (This
     * is buggy if we ever see an HTTP/1.10)
     */
    if (backasswards == 0) {

        /* read the response headers. */
        /* N.B. for HTTP/1.0 clients, we have to fold line-wrapped headers */
        /* Also, take care with headers with multiple occurences. */

        resp_hdrs = ap_proxy_read_headers(r, buffer, sizeof(buffer), f);
        if (resp_hdrs == NULL) {
            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_NOERRNO, r->server,
                         "proxy: Bad HTTP/%d.%d header returned by %s (%s)",
                         major, minor, r->uri, r->method);
            resp_hdrs = ap_make_table(p, 20);
            nocache = 1;        /* do not cache this broken file */
        }

        /* handle Via header in the response */
        if (conf->viaopt != via_off && conf->viaopt != via_block) {
            /* Create a "Via:" response header entry and merge it */
            i = ap_get_server_port(r);
            if (ap_is_default_port(i, r)) {
                strcpy(portstr, "");
            }
            else {
                ap_snprintf(portstr, sizeof portstr, ":%d", i);
            }
            ap_table_mergen((table *)resp_hdrs, "Via",
                            (conf->viaopt == via_full)
                            ? ap_psprintf(p, "%d.%d %s%s (%s)",
                                          major, minor,
                                          ap_get_server_name(r), portstr,
                                          SERVER_BASEVERSION)
                            : ap_psprintf(p, "%d.%d %s%s",
                                          major, minor,
                                          ap_get_server_name(r), portstr)
                );
        }

        /* is this content chunked? */
        chunked = ap_find_last_token(r->pool,
                                     ap_table_get(resp_hdrs, "Transfer-Encoding"),
                                     "chunked");

        /* strip hop-by-hop headers defined by Connection and RFC2616 */
        ap_proxy_clear_connection(p, resp_hdrs);

        content_length = ap_table_get(resp_hdrs, "Content-Length");
        if (content_length != NULL) {
            c->len = ap_strtol(content_length, NULL, 10);
        }

        /* Now add out bound headers set by other modules */
        resp_hdrs = ap_overlay_tables(r->pool, r->err_headers_out, resp_hdrs);
a440 2
    else {
        /* an http/0.9 response */
d442 1
a442 3
        /* no headers */
        resp_hdrs = ap_make_table(p, 20);
    }
d446 4
a449 8
    /*
     * HTTP/1.1 requires us to accept 3 types of dates, but only generate one
     * type
     */
    /*
     * we SET the dates here, obliterating possible multiple dates, as only
     * one of each date makes sense in each response.
     */
d451 1
a451 1
        ap_table_set(resp_hdrs, "Date", ap_proxy_date_canon(p, datestr));
d453 1
a453 1
        ap_table_set(resp_hdrs, "Last-Modified", ap_proxy_date_canon(p, datestr));
d455 1
a455 1
        ap_table_set(resp_hdrs, "Expires", ap_proxy_date_canon(p, datestr));
d457 4
a460 7
    /* handle the ProxyPassReverse mappings */
    if ((urlstr = ap_table_get(resp_hdrs, "Location")) != NULL)
        ap_table_set(resp_hdrs, "Location", proxy_location_reverse_map(r, urlstr));
    if ((urlstr = ap_table_get(resp_hdrs, "URI")) != NULL)
        ap_table_set(resp_hdrs, "URI", proxy_location_reverse_map(r, urlstr));
    if ((urlstr = ap_table_get(resp_hdrs, "Content-Location")) != NULL)
        ap_table_set(resp_hdrs, "Content-Location", proxy_location_reverse_map(r, urlstr));
d463 34
a496 48
    if (nocache == 0) {
        for (i = 0; i < conf->nocaches->nelts; i++) {
            if (destaddr.s_addr == ncent[i].addr.s_addr ||
                (ncent[i].name != NULL &&
                 (ncent[i].name[0] == '*' ||
                  strstr(desthost, ncent[i].name) != NULL))) {
                nocache = 1;
                break;
            }
        }

        /*
         * update the cache file, possibly even fulfilling the request if it
         * turns out a conditional allowed us to serve the object from the
         * cache...
         */
        i = ap_proxy_cache_update(c, resp_hdrs, !backasswards, nocache);
        if (i != DECLINED) {
            ap_bclose(f);
            return i;
        }

        /* write status line and headers to the cache file */
        ap_proxy_write_headers(c, ap_pstrcat(p, "HTTP/1.1 ", r->status_line, NULL), resp_hdrs);
    }

    /* Setup the headers for our client from upstreams response-headers */
    ap_proxy_table_replace(r->headers_out, resp_hdrs);
    /* Add X-Cache header - be careful not to obliterate any upstream headers */
    ap_table_mergen(r->headers_out, "X-Cache",
                    ap_pstrcat(r->pool, "MISS from ",
                               ap_get_server_name(r), NULL));
    /* The Content-Type of this response is the upstream one. */
    r->content_type = ap_table_get(r->headers_out, "Content-Type");
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Content-Type: %s", r->content_type);

    /* finally output the headers to the client */
    ap_send_http_header(r);

    /*
     * Is it an HTTP/0.9 respose? If so, send the extra data we read from
     * upstream as the start of the reponse to client
     */
/* FIXME: This code is broken: we try and write a buffer and length that
 * were never intelligently initialised. Rather have a bit of broken protocol
 * handling for now than broken code.
 */
/*
d498 3
a500 9
        ap_hard_timeout("proxy send assbackward", r);

        ap_bwrite(r->connection->client, buffer, len);
        if (c != NULL && c->fp != NULL && ap_bwrite(c->fp, buffer, len) != len) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                      "proxy: error writing extra data to %s", c->tempfile);
            c = ap_proxy_cache_error(c);
        }
        ap_kill_timeout(r);
d502 1
a502 1
*/
d505 2
a506 3
    /*
     * What we read/write after the header should not be modified (i.e., the
     * cache copy is ASCII, not EBCDIC, even for text/html)
d508 2
a509 3
    r->ebcdic.conv_in = r->ebcdic.conv_out = 0;
    ap_bsetflag(f, B_ASCII2EBCDIC | B_EBCDIC2ASCII, 0);
    ap_bsetflag(r->connection->client, B_ASCII2EBCDIC | B_EBCDIC2ASCII, 0);
a514 2
/* XXX CHANGEME: We want to eventually support keepalives, which means
 * we must read content-length bytes... */
d517 2
a518 7
        c->cache_completion = conf->cache.cache_completion;

/* XXX CHECKME: c->len should be the expected content length, or -1 if the
 * content length is not known. We need to make 100% sure c->len is always
 * set correctly before we get here to correctly do keepalive.
 */
        ap_proxy_send_fb(f, r, c, c->len, 0, chunked, conf->io_buffer_size);
d521 1
a521 1
    /* ap_proxy_send_fb() closes the socket f for us */
d523 1
a523 1
    ap_proxy_cache_tidy(c);
@


1.1.1.4
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@a172 3
#ifdef EAPI
    char *peer;
#endif
a193 6
#ifdef EAPI
    ap_hook_use("ap::mod_proxy::http::handler::set_destport", 
                AP_HOOK_SIG2(int,ptr), 
                AP_HOOK_TOPMOST,
                &destport, r);
#endif /* EAPI */
a230 3
#ifdef EAPI
	peer = ap_psprintf(p, "%s:%u", proxyhost, proxyport);  
#endif
a236 3
#ifdef EAPI
	peer =  ap_psprintf(p, "%s:%u", desthost, destport);  
#endif
a310 12
#ifdef EAPI
    {
        char *errmsg = NULL;
        ap_hook_use("ap::mod_proxy::http::handler::new_connection", 
                    AP_HOOK_SIG4(ptr,ptr,ptr,ptr), 
                    AP_HOOK_DECLINE(NULL),
                    &errmsg, r, f, peer);
        if (errmsg != NULL)
            return ap_proxyerror(r, HTTP_BAD_GATEWAY, errmsg);
    }
#endif /* EAPI */

a313 15
#ifdef EAPI
    {
	int rc = DECLINED;
	ap_hook_use("ap::mod_proxy::http::handler::write_host_header", 
		    AP_HOOK_SIG6(int,ptr,ptr,ptr,int,ptr), 
		    AP_HOOK_DECLINE(DECLINED),
		    &rc, r, f, desthost, destport, destportstr);
        if (rc == DECLINED) {
	    if (destportstr != NULL && destport != DEFAULT_HTTP_PORT)
		ap_bvputs(f, "Host: ", desthost, ":", destportstr, CRLF, NULL);
	    else
		ap_bvputs(f, "Host: ", desthost, CRLF, NULL);
        }
    }
#else /* EAPI */
a318 1
#endif /* EAPI */
d523 2
@


1.1.1.5
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
d259 1
a259 1
    sock = ap_psocket_ex(p, PF_INET, SOCK_STREAM, IPPROTO_TCP, 1);
@


