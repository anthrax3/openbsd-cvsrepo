head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.20
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.16
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.14
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.12
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.12
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.8
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.6
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.10
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.8
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.6
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.5
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.5
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.4
	apache_1_3_27:1.1.1.4
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	apache_1_3_26:1.1.1.3
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.2.0.2
	OPENBSD_2_4_BASE:1.1.1.2
	apache_1_3_2:1.1.1.2
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	apache:1.1.1
	apache_1_2_6:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.20;

1.20
date	2010.02.25.07.49.53;	author pyr;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.20.03.33.09;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.09.12.13.10;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.15.12.17.18;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.21.13.11.36;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.02.14.18.12;	author avsm;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.09.12.35.41;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.08.18.21.17;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.07.20.23.06;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.19.21.31.16;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.29.02.08.06;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.29.10.21.45;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.22.18.15;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.25.18.29.51;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.06.29.42;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.06.05.22.55.21;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.06.04.22.15.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.03.01.01.06.27;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.03.25.07.08.50;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.25.07.08.50;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.10.01.17.19.42;	author beck;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.07.19.21.28.55;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.07.19.48.13;	author henning;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.08.21.12.53.40;	author henning;	state Exp;
branches;
next	;


desc
@@


1.21
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/* Cache and garbage collection routines for Apache proxy */

#include "mod_proxy.h"
#include "http_conf_globals.h"
#include "http_log.h"
#include "http_main.h"
#include "http_core.h"
#include "util_date.h"
#include <utime.h>
#include "multithread.h"
#include "ap_md5.h"

struct gc_ent {
    unsigned long int len;
    time_t expire;
    char file[HASH_LEN + 1];
};

/* Poor man's 61 bit arithmetic */
typedef struct {
    long lower;                 /* lower 30 bits of result */
    long upper;                 /* upper 31 bits of result */
} long61_t;

/* FIXME: The block size can be different on a `per file system' base.
 * This would make automatic detection highly OS specific.
 * In the GNU fileutils code for du(1), you can see how complicated it can
 * become to detect the block size. And, with BSD-4.x fragments, it
 * it even more difficult to get precise results.
 * As a compromise (and to improve on the incorrect counting of cache
 * size on byte level, omitting directory sizes entirely, which was
 * used up to apache-1.3b7) we're rounding to multiples of 512 here.
 * Your file system may be using larger blocks (I certainly hope so!)
 * but it will hardly use smaller blocks.
 * (So this approximation is still closer to reality than the old behavior).
 * The best solution would be automatic detection, the next best solution
 * IMHO is a sensible default and the possibility to override it.
 */

#define ROUNDUP2BLOCKS(_bytes) (((_bytes)+block_size-1) & ~(block_size-1))
static long block_size = 512;   /* this must be a power of 2 */
static long61_t curbytes, cachesize;
static time_t garbage_now, garbage_expire;
static mutex *garbage_mutex = NULL;


int ap_proxy_garbage_init(server_rec *r, pool *p)
{
    if (!garbage_mutex)
        garbage_mutex = ap_create_mutex(NULL);

    return (0);
}


static int sub_garbage_coll(request_rec *r, array_header *files,
                             const char *cachedir, const char *cachesubdir);
static void help_proxy_garbage_coll(request_rec *r);
static int should_proxy_garbage_coll(request_rec *r);
static void detached_proxy_garbage_coll(request_rec *r);


void ap_proxy_garbage_coll(request_rec *r)
{
    static int inside = 0;

    (void)ap_acquire_mutex(garbage_mutex);
    if (inside == 1) {
        (void)ap_release_mutex(garbage_mutex);
        return;
    }
    else
        inside = 1;
    (void)ap_release_mutex(garbage_mutex);

    ap_block_alarms();          /* avoid SIGALRM on big cache cleanup */
    if (should_proxy_garbage_coll(r))
        detached_proxy_garbage_coll(r);
    ap_unblock_alarms();

    (void)ap_acquire_mutex(garbage_mutex);
    inside = 0;
    (void)ap_release_mutex(garbage_mutex);
}


static void add_long61(long61_t *accu, long val)
{
    /* Add in lower 30 bits */
    accu->lower += (val & 0x3FFFFFFFL);
    /* add in upper bits, and carry */
    accu->upper += (val >> 30) + ((accu->lower & ~0x3FFFFFFFL) != 0L);
    /* Clear carry */
    accu->lower &= 0x3FFFFFFFL;
}

static void sub_long61(long61_t *accu, long val)
{
    int carry = (val & 0x3FFFFFFFL) > accu->lower;
    /* Subtract lower 30 bits */
    accu->lower = accu->lower - (val & 0x3FFFFFFFL) + ((carry) ? 0x40000000 : 0);
    /* add in upper bits, and carry */
    accu->upper -= (val >> 30) + carry;
}

/* Compare two long61's:
 * return <0 when left < right
 * return  0 when left == right
 * return >0 when left > right
 */
static long cmp_long61(long61_t *left, long61_t *right)
{
    return (left->upper == right->upper) ? (left->lower - right->lower)
    : (left->upper - right->upper);
}

/* Compare two gc_ent's, sort them by expiration date */
static int gcdiff(const void *ap, const void *bp)
{
    const struct gc_ent *a = (const struct gc_ent *) ap;
    const struct gc_ent *b = (const struct gc_ent *) bp;

    if (a->expire > b->expire)
        return 1;
    else if (a->expire < b->expire)
        return -1;
    else
        return 0;
}

static void detached_proxy_garbage_coll(request_rec *r)
{
    pid_t pid;
    int status;
    pid_t pgrp;

    switch (pid = fork()) {
    case -1:
        ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                     "proxy: fork() for cache cleanup failed");
        return;

    case 0:                     /* Child */

        /* close all sorts of things, including the socket fd */
        ap_cleanup_for_exec();

        /* Fork twice to disassociate from the child */
        switch (pid = fork()) {
        case -1:
            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                         "proxy: fork(2nd) for cache cleanup failed");
            exit(1);

        case 0:         /* Child */
            /* The setpgrp() stuff was snarfed from http_main.c */
            if ((pgrp = setsid()) == -1) {
                perror("setsid");
                fprintf(stderr, "%s: setsid failed\n",
                        ap_server_argv0);
                exit(1);
            }
            help_proxy_garbage_coll(r);
            exit(0);

        default:                /* Father */
            /* After grandson has been forked off, */
            /* there's nothing else to do. */
            exit(0);
        }
    default:
        /* Wait until grandson has been forked off */
        /* (without wait we'd leave a zombie) */
        waitpid(pid, &status, 0);
        return;
    }
}

#define DOT_TIME "/.time"       /* marker */

static int should_proxy_garbage_coll(request_rec *r)
{
    void *sconf = r->server->module_config;
    proxy_server_conf *pconf =
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
    const struct cache_conf *conf = &pconf->cache;

    const char *cachedir = conf->root;
    char *filename;
    size_t fnlen;
    struct stat buf;
    int timefd;
    time_t every = conf->gcinterval;
    static time_t lastcheck = BAD_DATE; /* static (per-process) data!!! */

    if (cachedir == NULL || every == -1)
        return 0;

    fnlen = strlen(cachedir) + strlen(DOT_TIME) + 1;
    filename = ap_palloc(r->pool, fnlen);

    garbage_now = time(NULL);
    /*
     * Usually, the modification time of <cachedir>/.time can only increase.
     * Thus, even with several child processes having their own copy of
     * lastcheck, if time(NULL) still < lastcheck then it's not time for GC
     * yet.
     */
    if (garbage_now != -1 && lastcheck != BAD_DATE && garbage_now < lastcheck + every)
        return 0;

    strlcpy(filename, cachedir, fnlen);
    strlcat(filename, DOT_TIME, fnlen);

    /*
     * At this point we have a bit of an engineering compromise. We could
     * either create and/or mark the .time file  (prior to the fork which
     * might fail on a resource issue) or wait until we are safely forked.
     * The advantage of doing it now in this process is that we get some
     * usefull live out of the global last check variable. (XXX which should
     * go scoreboard IMHO.) Note that the actual counting is at a later
     * moment.
     */
    if (stat(filename, &buf) == -1) {   /* does not exist */
        if (errno != ENOENT) {
            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                         "proxy: stat(%s)", filename);
            return 0;
        }
        if ((timefd = creat(filename, 0666)) == -1) {
            if (errno != EEXIST)
                ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                             "proxy: creat(%s)", filename);
            else
                lastcheck = garbage_now;        /* someone else got in there */
            return 0;
        }
        close(timefd);
    }
    else {
        lastcheck = buf.st_mtime;       /* save the time */
        if (garbage_now < lastcheck + every) {
            return 0;
        }
        if (utime(filename, NULL) == -1)
            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                         "proxy: utimes(%s)", filename);
    }

    return 1;
}

static void help_proxy_garbage_coll(request_rec *r)
{
    const char *cachedir;
    void *sconf = r->server->module_config;
    proxy_server_conf *pconf =
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
    const struct cache_conf *conf = &pconf->cache;
    array_header *files;
    struct gc_ent *fent;
    char *filename;
    int i;

    cachedir = conf->root;
    filename = ap_palloc(r->pool, strlen(cachedir) + HASH_LEN + 2);
    /* configured size is given in kB. Make it bytes, convert to long61_t: */
    cachesize.lower = cachesize.upper = 0;
    add_long61(&cachesize, conf->space << 10);

    ap_block_alarms();          /* avoid SIGALRM on big cache cleanup */

    files = ap_make_array(r->pool, 100, sizeof(struct gc_ent));
    curbytes.upper = curbytes.lower = 0L;

    sub_garbage_coll(r, files, cachedir, "/");

    if (cmp_long61(&curbytes, &cachesize) < 0L) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server,
                     "proxy GC: Cache is %ld%% full (nothing deleted)",
                     (long)(((curbytes.upper << 20) | (curbytes.lower >> 10)) * 100 / conf->space));
        ap_unblock_alarms();
        return;
    }

    /* sort the files we found by expiration date */
    qsort(files->elts, files->nelts, sizeof(struct gc_ent), gcdiff);

    for (i = 0; i < files->nelts; i++) {
        fent = &((struct gc_ent *) files->elts)[i];
        snprintf(filename, sizeof(fent->file), "%s%s", cachedir, fent->file);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "GC Unlinking %s (expiry %ld, garbage_now %ld)", filename, (long)fent->expire, (long)garbage_now);
#if TESTING
        fprintf(stderr, "Would unlink %s\n", filename);
#else
        if (unlink(filename) == -1) {
            if (errno != ENOENT)
                ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                             "proxy gc: unlink(%s)", filename);
        }
        else
#endif
        {
            sub_long61(&curbytes, ROUNDUP2BLOCKS(fent->len));
            if (cmp_long61(&curbytes, &cachesize) < 0)
                break;
        }
    }

    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server,
                 "proxy GC: Cache is %ld%% full (%d deleted)",
                 (long)(((curbytes.upper << 20) | (curbytes.lower >> 10)) * 100 / conf->space), i);
    ap_unblock_alarms();
}

static int sub_garbage_coll(request_rec *r, array_header *files,
                          const char *cachebasedir, const char *cachesubdir)
{
    char line[17 * (3)];
    char cachedir[HUGE_STRING_LEN];
    struct stat buf;
    int fd, i;
    DIR *dir;
    struct dirent *ent;
    struct gc_ent *fent;
    int nfiles = 0;
    char *filename;
    size_t fnlen;

    ap_snprintf(cachedir, sizeof(cachedir), "%s%s", cachebasedir, cachesubdir);
    fnlen = strlen(cachedir) + HASH_LEN + 2;
    filename = ap_palloc(r->pool, fnlen);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "GC Examining directory %s", cachedir);
    dir = opendir(cachedir);
    if (dir == NULL) {
        ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                     "proxy gc: opendir(%s)", cachedir);
        return 0;
    }

    while ((ent = readdir(dir)) != NULL) {
        if (ent->d_name[0] == '.')
            continue;
        snprintf(filename, fnlen, "%s%s", cachedir, ent->d_name);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "GC Examining file %s", filename);
/* is it a temporary file? */
        if (strncmp(ent->d_name, "tmp", 3) == 0) {
/* then stat it to see how old it is; delete temporary files > 1 day old */
            if (stat(filename, &buf) == -1) {
                if (errno != ENOENT)
                    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                                 "proxy gc: stat(%s)", filename);
            }
            else if (garbage_now != -1 && buf.st_atime < garbage_now - SEC_ONE_DAY &&
                     buf.st_mtime < garbage_now - SEC_ONE_DAY) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "GC unlink %s", filename);
                ap_log_error(APLOG_MARK, APLOG_INFO | APLOG_NOERRNO, r->server,
                     "proxy gc: deleting orphaned cache file %s", filename);
#if TESTING
                fprintf(stderr, "Would unlink %s\n", filename);
#else
                unlink(filename);
#endif
            }
            continue;
        }
        ++nfiles;
	/* is it another file? */
        /* FIXME: Shouldn't any unexpected files be deleted? */
        /* if (strlen(ent->d_name) != HASH_LEN) continue; */

	/* read the file */
        fd = open(filename, O_RDONLY | O_BINARY);
        if (fd == -1) {
            if (errno != ENOENT)
                ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                             "proxy gc: open(%s)", filename);
            continue;
        }
        if (fstat(fd, &buf) == -1) {
            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                         "proxy gc: fstat(%s)", filename);
            close(fd);
            continue;
        }

        if (S_ISDIR(buf.st_mode)) {
            char newcachedir[HUGE_STRING_LEN];
            close(fd);
            ap_snprintf(newcachedir, sizeof(newcachedir),
                        "%s%s/", cachesubdir, ent->d_name);
            if (!sub_garbage_coll(r, files, cachebasedir, newcachedir)) {
                ap_snprintf(newcachedir, sizeof(newcachedir),
                            "%s%s", cachedir, ent->d_name);
#if TESTING
                fprintf(stderr, "Would remove directory %s\n", newcachedir);
#else
                rmdir(newcachedir);
#endif
                --nfiles;
            }
            else {
                /* Directory is not empty. Account for its size: */
                add_long61(&curbytes, ROUNDUP2BLOCKS(buf.st_size));
            }
            continue;
        }


        i = read(fd, line, 17 * (3) - 1);
        close(fd);
        if (i == -1) {
            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                         "proxy gc: read(%s)", filename);
            continue;
        }
        line[i] = '\0';
        garbage_expire = ap_proxy_hex2sec(line + 17 * (2));
        if (!ap_checkmask(line, "&&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&&") ||
            garbage_expire == BAD_DATE) {
            /* bad file */
            if (garbage_now != -1 && buf.st_atime > garbage_now + SEC_ONE_DAY &&
                buf.st_mtime > garbage_now + SEC_ONE_DAY) {
                ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_NOERRNO, r->server,
                             "proxy: deleting bad cache file with future date: %s", filename);
#if TESTING
                fprintf(stderr, "Would unlink bad file %s\n", filename);
#else
                unlink(filename);
#endif
            }
            continue;
        }

/*
 * we need to calculate an 'old' factor, and remove the 'oldest' files
 * so that the space requirement is met; sort by the expires date of the
 * file.
 *
 */
        fent = (struct gc_ent *) ap_push_array(files);
        fent->len = buf.st_size;
        fent->expire = garbage_expire;
        strlcpy(fent->file, cachesubdir, sizeof(fent->file));
        strlcat(fent->file, ent->d_name, sizeof(fent->file));

/* accumulate in blocks, to cope with directories > 4Gb */
        add_long61(&curbytes, ROUNDUP2BLOCKS(buf.st_size));
    }

    closedir(dir);

    return nfiles;

}


/*
 * Read a cache file;
 * returns 1 on success,
 *         0 on failure (bad file or wrong URL)
 *        -1 on UNIX error
 *
 * We read the cache hex header, then the message response line and
 * response headers, and finally we return with the filepointer
 * pointing at the start of the message body itself, ready to be
 * shipped to the client later on, if appropriate.
 */
static int rdcache(request_rec *r, BUFF *cachefp, cache_req *c)
{
    char urlbuff[HUGE_STRING_LEN], *strp;
    int len;

    /* read the data from the cache file */

    /*
     * Format:
     * 
     * The cache needs to keep track of the following information: - Date,
     * LastMod, Version, ReqTime, RespTime, ContentLength - The original
     * request headers (for Vary) - The original response headers (for
     * returning with a cached response) - The body of the message
     * 
     * date SP lastmod SP expire SP count SP request-time SP response-time SP
     * content-lengthCRLF (dates are stored as hex seconds since 1970)
     * Original URLCRLF Original Request Headers CRLF Original Response
     * Headers CRLF Body
     * 
     */

    /* retrieve cachefile information values */
    len = ap_bgets(urlbuff, sizeof urlbuff, cachefp);
    if (len == -1) {
        /* Delete broken cache file */
        unlink(c->filename);
        return -1;
    }
    if (len == 0 || urlbuff[len - 1] != '\n')
        return 0;
    urlbuff[len - 1] = '\0';

    if (!ap_checkmask(urlbuff,
                      "&&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&&"))
        return 0;

    c->date = ap_proxy_hex2sec(urlbuff + 17 * (0));
    c->lmod = ap_proxy_hex2sec(urlbuff + 17 * (1));
    c->expire = ap_proxy_hex2sec(urlbuff + 17 * (2));
    c->version = ap_proxy_hex2sec(urlbuff + 17 * (3));
    c->req_time = ap_proxy_hex2sec(urlbuff + 17 * (4));
    c->resp_time = ap_proxy_hex2sec(urlbuff + 17 * (5));
    c->len = ap_proxy_hex2sec(urlbuff + 17 * (6));

    /* check that we have the same URL */
    len = ap_bgets(urlbuff, sizeof urlbuff, cachefp);
    if (len == -1) {
        /* Delete broken cache file */
        unlink(c->filename);
        return -1;
    }
    if (len == 0 || strncmp(urlbuff, "X-URL: ", 7) != 0 ||
        urlbuff[len - 1] != '\n')
        return 0;
    urlbuff[len - 1] = '\0';
    if (strcmp(urlbuff + 7, c->url) != 0)
        return 0;

    /* then the original request headers */
    c->req_hdrs = ap_proxy_read_headers(r, urlbuff, sizeof urlbuff, cachefp);
    if (c->req_hdrs == NULL) {
        /* Delete broken cache file */
        unlink(c->filename);
        return -1;
    }

    /* then the original response headers */
    len = ap_bgets(urlbuff, sizeof urlbuff, cachefp);
    if (len == -1) {
        /* Delete broken cache file */
        unlink(c->filename);
        return -1;
    }
    if (len == 0 || urlbuff[len - 1] != '\n')
        return 0;
    urlbuff[--len] = '\0';

    c->resp_line = ap_pstrdup(r->pool, urlbuff);
    strp = strchr(urlbuff, ' ');
    if (strp == NULL)
        return 0;

    c->status = atoi(strp);
    c->hdrs = ap_proxy_read_headers(r, urlbuff, sizeof urlbuff, cachefp);
    if (c->hdrs == NULL) {
        /* Delete broken cache file */
        unlink(c->filename);
        return -1;
    }
    if (c->len != -1)           /* add a content-length header */
        if (ap_table_get(c->hdrs, "Content-Length") == NULL) {
            ap_table_set(c->hdrs, "Content-Length",
                         ap_psprintf(r->pool, "%lu", (unsigned long)c->len));
        }


    return 1;
}

/*
 * Call this to check the possible conditional status of
 * the client request, and return the response from the cache
 *
 * Conditionals include If-Modified-Since, If-Match, If-Unmodified-Since
 * and If-None-Match.
 *
 * We don't yet understand If-Range, but we will...
 */
int ap_proxy_cache_conditional(request_rec *r, cache_req *c, BUFF *cachefp)
{
    const char *etag, *wetag = NULL;

    /* get etag */
    if ((etag = ap_table_get(c->hdrs, "Etag"))) {
        wetag = ap_pstrcat(r->pool, "W/", etag, NULL);
    }

    /* check for If-Match, If-Unmodified-Since */
    while (1) {

        /*
         * check If-Match and If-Unmodified-Since exist
         * 
         * If neither of these exist, the request is not conditional, and we
         * serve it normally
         */
        if (!c->im && BAD_DATE == c->ius) {
            break;
        }

        /*
         * check If-Match
         * 
         * we check if the Etag on the cached file is in the list of Etags in
         * the If-Match field. The comparison must be a strong comparison, so
         * the Etag cannot be marked as weak. If the comparision fails we
         * return 412 Precondition Failed.
         * 
         * if If-Match is specified AND If-Match is not a "*" AND Etag is
         * missing or weak or not in the list THEN return 412 Precondition
         * Failed
         */

        if (c->im) {
            if (strcmp(c->im, "*") &&
                (!etag || (strlen(etag) > 1 && 'W' == etag[0] && '/' == etag[1]) || !ap_proxy_liststr(c->im, etag, NULL))) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Match specified, and it didn't - return 412");
            }
            else {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Match specified, and it matched");
                break;
            }
        }

        /*
         * check If-Unmodified-Since
         * 
         * if If-Unmodified-Since is specified AND Last-Modified is specified
         * somewhere AND If-Unmodified-Since is in the past compared to
         * Last-Modified THEN return 412 Precondition Failed
         */
        if (BAD_DATE != c->ius && BAD_DATE != c->lmod) {
            if (c->ius < c->lmod) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Unmodified-Since specified, but it wasn't - return 412");
            }
            else {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Unmodified-Since specified, and it was unmodified");
                break;
            }
        }

        /* if cache file is being updated */
        if (c->origfp) {
            ap_proxy_write_headers(c, c->resp_line, c->hdrs);
            ap_proxy_send_fb(c->origfp, r, c, c->len, 1, 0, IOBUFSIZE);
            ap_proxy_cache_tidy(c);
        }
        else
            ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));

        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Use your cached copy, conditional precondition failed.");
        return HTTP_PRECONDITION_FAILED;
    }


    /* check for If-None-Match, If-Modified-Since */
    while (1) {

        /*
         * check for existance of If-None-Match and If-Modified-Since
         * 
         * if neither of these headers have been set, then the request is not
         * conditional, and we just send the cached response and be done with
         * it.
         */
        if (!c->inm && BAD_DATE == c->ims) {
            break;
        }

        /*
         * check If-None-Match
         * 
         * we check if the Etag on the cached file is in the list of Etags in
         * the If-None-Match field. The comparison must be a strong
         * comparison, so the Etag cannot be marked as weak. If the
         * comparision fails we return 412 Precondition Failed.
         * 
         * if If-None-Match is specified: if If-None-Match is a "*" THEN 304
         * else if Etag is specified AND we get a match THEN 304 else if Weak
         * Etag is specified AND we get a match THEN 304 else sent the
         * original object
         */
        if (c->inm) {
            if (!strcmp(c->inm, "*")) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-None-Match: * specified, return 304");
            }
            else if (etag && ap_proxy_liststr(c->inm, etag, NULL)) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-None-Match: specified and we got a strong match - return 304");
            }
            else if (wetag && ap_proxy_liststr(c->inm, wetag, NULL)) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-None-Match specified, and we got a weak match - return 304");
            }
            else
                break;
        }

        /*
         * check If-Modified-Since
         * 
         * if If-Modified-Since is specified AND Last-Modified is specified
         * somewhere: if last modification date is earlier than
         * If-Modified-Since THEN 304 else send the original object
         */
        if (BAD_DATE != c->ims && BAD_DATE != c->lmod) {
            if (c->ims >= c->lmod) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Modified-Since specified and not modified, try return 304");
            }
            else
                break;
        }


        /* are we updating the cache file? */
        if (c->origfp) {
            ap_proxy_write_headers(c, c->resp_line, c->hdrs);
            ap_proxy_send_fb(c->origfp, r, c, c->len, 1, 0, IOBUFSIZE);
            ap_proxy_cache_tidy(c);
        }
        else
            ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));

        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Use local copy, cached file hasn't changed");
        return HTTP_NOT_MODIFIED;
    }


    /* No conditional - just send it cousin! */
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Local copy modified, send it");
    r->status_line = strchr(c->resp_line, ' ') + 1;
    r->status = c->status;

    /* Prepare and send headers to client */
    ap_proxy_table_replace(r->headers_out, c->hdrs);
    /* make sure our X-Cache header does not stomp on a previous header */
    ap_table_mergen(r->headers_out, "X-Cache", c->xcache);

    /* content type is already set in the headers */
    r->content_type = ap_table_get(r->headers_out, "Content-Type");

    ap_send_http_header(r);

    /* are we rewriting the cache file? */
    if (c->origfp) {
        ap_proxy_write_headers(c, c->resp_line, c->hdrs);
        ap_proxy_send_fb(c->origfp, r, c, c->len, r->header_only, 0, IOBUFSIZE);
        ap_proxy_cache_tidy(c);
        return OK;
    }

    /* no, we not */
    if (!r->header_only) {
        ap_proxy_send_fb(cachefp, r, NULL, c->len, 0, 0, IOBUFSIZE);
    }
    else {
        ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));
    }

    return OK;
}


/*
 * Call this to test for a resource in the cache
 * Returns DECLINED if we need to check the remote host
 * or an HTTP status code if successful
 *
 * Functions:
 *   if URL is cached then
 *      if cached file is not expired then
 *         if last modified after if-modified-since then send body
 *         else send 304 Not modified
 *      else if cached file is expired then
 *         if last modified after if-modified-since then add
 *            last modified date to request
 */
int ap_proxy_cache_check(request_rec *r, char *url, struct cache_conf * conf,
                             cache_req **cr)
{
    const char *datestr, *pragma_req = NULL, *pragma_cresp = NULL, *cc_req = NULL,
        *cc_cresp = NULL;
    cache_req *c;
    BUFF *cachefp;
    int i;
    void *sconf = r->server->module_config;
    proxy_server_conf *pconf =
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
    const char *agestr = NULL;
    char *val;
    time_t age_c = 0;
    time_t age, maxage_req, maxage_cresp, maxage, smaxage, maxstale, minfresh;

    c = ap_pcalloc(r->pool, sizeof(cache_req));
    *cr = c;
    c->req = r;
    c->url = ap_pstrdup(r->pool, url);
    c->filename = NULL;
    c->tempfile = NULL;
    c->fp = NULL;
    c->origfp = NULL;
    c->version = 0;
    c->len = -1;
    c->req_hdrs = NULL;
    c->hdrs = NULL;
    c->xcache = NULL;

    /* get the If-Modified-Since date of the request, if it exists */
    c->ims = BAD_DATE;
    datestr = ap_table_get(r->headers_in, "If-Modified-Since");
    if (datestr != NULL) {
        /* this may modify the value in the original table */
        datestr = ap_proxy_date_canon(r->pool, datestr);
        c->ims = ap_parseHTTPdate(datestr);
        if (c->ims == BAD_DATE) /* bad or out of range date; remove it */
            ap_table_unset(r->headers_in, "If-Modified-Since");
    }

/* get the If-Unmodified-Since date of the request, if it exists */
    c->ius = BAD_DATE;
    datestr = ap_table_get(r->headers_in, "If-Unmodified-Since");
    if (datestr != NULL) {
        /* this may modify the value in the original table */
        datestr = ap_proxy_date_canon(r->pool, datestr);
        c->ius = ap_parseHTTPdate(datestr);
        if (c->ius == BAD_DATE) /* bad or out of range date; remove it */
            ap_table_unset(r->headers_in, "If-Unmodified-Since");
    }

/* get the If-Match of the request, if it exists */
    c->im = ap_table_get(r->headers_in, "If-Match");

/* get the If-None-Match of the request, if it exists */
    c->inm = ap_table_get(r->headers_in, "If-None-Match");

/* find the filename for this cache entry */
    if (conf->root != NULL) {
        char hashfile[66];
        ap_proxy_hash(url, hashfile, pconf->cache.dirlevels, pconf->cache.dirlength);
        c->filename = ap_pstrcat(r->pool, conf->root, "/", hashfile, NULL);
    }
    else {
        c->filename = NULL;
        c->fp = NULL;
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "No CacheRoot, so no caching. Declining.");
        return DECLINED;
    }

/* find certain cache controlling headers */
    pragma_req = ap_table_get(r->headers_in, "Pragma");
    cc_req = ap_table_get(r->headers_in, "Cache-Control");

/* first things first - does the request allow us to return
 * cached information at all? If not, just decline the request.
 *
 * Note that there is a big difference between not being allowed
 * to cache a request (no-store) and not being allowed to return
 * a cached request without revalidation (max-age=0).
 *
 * Caching is forbidden under the following circumstances:
 *
 * - RFC2616 14.9.2 Cache-Control: no-store
 * we are not supposed to store this request at all. Behave as a tunnel.
 *
 */
    if (ap_proxy_liststr(cc_req, "no-store", NULL)) {

/* delete the previously cached file */
        if (c->filename)
            unlink(c->filename);
        c->fp = NULL;
        c->filename = NULL;
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "no-store forbids caching. Declining.");
        return DECLINED;
    }

/* if the cache file exists, open it */
    cachefp = NULL;
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Request for %s, pragma_req=%s, ims=%ld", url,
                 (pragma_req == NULL) ? "(unset)" : pragma_req, (long)c->ims);
/* find out about whether the request can access the cache */
    if (c->filename != NULL && r->method_number == M_GET &&
        strlen(url) < 1024) {
        cachefp = ap_proxy_open_cachefile(r, c->filename);
    }


    /*
     * if a cache file exists, try reading body and headers from cache file
     */
    if (cachefp != NULL) {
        i = rdcache(r, cachefp, c);
        if (i == -1)
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                          "proxy: error reading cache file %s",
                          c->filename);
        else if (i == 0)
            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, r,
                          "proxy: bad (short?) cache file: %s", c->filename);
        if (i != 1) {
            ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));
            cachefp = NULL;
        }
        if (c->hdrs) {
            cc_cresp = ap_table_get(c->hdrs, "Cache-Control");
            pragma_cresp = ap_table_get(c->hdrs, "Pragma");
            if ((agestr = ap_table_get(c->hdrs, "Age"))) {
                age_c = atoi(agestr);
            }
        }
    }

    /* if a cache file does not exist, create empty header array */
/* fixed?  in this case, we want to get the headers from the remote server
   it will be handled later if we don't do this (I hope ;-)

    if (cachefp == NULL)
        c->hdrs = ap_make_table(r->pool, 20);
*/
    /* FIXME: Shouldn't we check the URL somewhere? */

    /*
     * Check Content-Negotiation - Vary
     * 
     * At this point we need to make sure that the object we found in the cache
     * is the same object that would be delivered to the client, when the
     * effects of content negotiation are taken into effect.
     * 
     * In plain english, we want to make sure that a language-negotiated
     * document in one language is not given to a client asking for a
     * language negotiated document in a different language by mistake.
     * 
     * RFC2616 13.6 and 14.44 describe the Vary mechanism.
     */
    if (c->hdrs && c->req_hdrs) {
        char *vary = ap_pstrdup(r->pool, ap_table_get(c->hdrs, "Vary"));

        while (vary && *vary) {
            char *name = vary;
            const char *h1, *h2;

            /* isolate header name */
            while (*vary && !ap_isspace(*vary) && (*vary != ','))
                ++vary;
            while (ap_isspace(*vary) || (*vary == ',')) {
                *vary = '\0';
                ++vary;
            }

            /*
             * is this header in the request and the header in the cached
             * request identical? If not, we give up and do a straight get
             */
            h1 = ap_table_get(r->headers_in, name);
            h2 = ap_table_get(c->req_hdrs, name);
            if (h1 == h2) {
                /* both headers NULL, so a match - do nothing */
            }
            else if (h1 && h2 && !strcmp(h1, h2)) {
                /* both headers exist and are equal - do nothing */
            }
            else {

                /* headers do not match, so Vary failed */
                c->fp = cachefp;
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Vary header mismatch - object must be fetched from scratch. Declining.");
                return DECLINED;
            }
        }
    }


    /*
     * We now want to check if our cached data is still fresh. This depends
     * on a few things, in this order:
     * 
     * - RFC2616 14.9.4 End to end reload, Cache-Control: no-cache no-cache in
     * either the request or the cached response means that we must
     * revalidate the request unconditionally, overriding any expiration
     * mechanism. It's equivalent to max-age=0,must-revalidate.
     * 
     * - RFC2616 14.32 Pragma: no-cache This is treated the same as
     * Cache-Control: no-cache.
     * 
     * - RFC2616 14.9.3 Cache-Control: max-stale, must-revalidate,
     * proxy-revalidate if the max-stale request header exists, modify the
     * stale calculations below so that an object can be at most <max-stale>
     * seconds stale before we request a revalidation, _UNLESS_ a
     * must-revalidate or proxy-revalidate cached response header exists to
     * stop us doing this.
     * 
     * - RFC2616 14.9.3 Cache-Control: s-maxage the origin server specifies the
     * maximum age an object can be before it is considered stale. This
     * directive has the effect of proxy|must revalidate, which in turn means
     * simple ignore any max-stale setting.
     * 
     * - RFC2616 14.9.4 Cache-Control: max-age this header can appear in both
     * requests and responses. If both are specified, the smaller of the two
     * takes priority.
     * 
     * - RFC2616 14.21 Expires: if this request header exists in the cached
     * entity, and it's value is in the past, it has expired.
     * 
     */

    /* calculate age of object */
    age = ap_proxy_current_age(c, age_c);

    /* extract s-maxage */
    if (cc_cresp && ap_proxy_liststr(cc_cresp, "s-maxage", &val))
        smaxage = atoi(val);
    else
        smaxage = -1;

    /* extract max-age from request */
    if (cc_req && ap_proxy_liststr(cc_req, "max-age", &val))
        maxage_req = atoi(val);
    else
        maxage_req = -1;

    /* extract max-age from response */
    if (cc_cresp && ap_proxy_liststr(cc_cresp, "max-age", &val))
        maxage_cresp = atoi(val);
    else
        maxage_cresp = -1;

    /*
     * if both maxage request and response, the smaller one takes priority
     */
    if (-1 == maxage_req)
        maxage = maxage_cresp;
    else if (-1 == maxage_cresp)
        maxage = maxage_req;
    else
        maxage = MIN(maxage_req, maxage_cresp);

    /* extract max-stale */
    if (cc_req && ap_proxy_liststr(cc_req, "max-stale", &val))
        maxstale = atoi(val);
    else
        maxstale = 0;

    /* extract min-fresh */
    if (cc_req && ap_proxy_liststr(cc_req, "min-fresh", &val))
        minfresh = atoi(val);
    else
        minfresh = 0;

    /* override maxstale if must-revalidate or proxy-revalidate */
    if (maxstale && ((cc_cresp && ap_proxy_liststr(cc_cresp, "must-revalidate", NULL)) || (cc_cresp && ap_proxy_liststr(cc_cresp, "proxy-revalidate", NULL))))
        maxstale = 0;

    if (cachefp != NULL &&

    /* handle no-cache */
        !((cc_req && ap_proxy_liststr(cc_req, "no-cache", NULL)) ||
          (pragma_req && ap_proxy_liststr(pragma_req, "no-cache", NULL)) ||
          (cc_cresp && ap_proxy_liststr(cc_cresp, "no-cache", NULL)) ||
      (pragma_cresp && ap_proxy_liststr(pragma_cresp, "no-cache", NULL))) &&

    /* handle expiration */
        ((-1 < smaxage && age < (smaxage - minfresh)) ||
         (-1 < maxage && age < (maxage + maxstale - minfresh)) ||
         (c->expire != BAD_DATE && age < (c->expire - c->date + maxstale - minfresh)))
        ) {

        /* it's fresh darlings... */

        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Unexpired data available");

        /* set age header on response */
        ap_table_set(c->hdrs, "Age",
                     ap_psprintf(r->pool, "%lu", (unsigned long)age));

        /* add warning if maxstale overrode freshness calculation */
        if (!((-1 < smaxage && age < smaxage) ||
              (-1 < maxage && age < maxage) ||
              (c->expire != BAD_DATE && (c->expire - c->date) > age))) {
            /* make sure we don't stomp on a previous warning */
            ap_table_merge(c->hdrs, "Warning", "110 Response is stale");
        }

        /* check conditionals (If-Modified-Since, etc) */
        c->xcache = ap_pstrcat(r->pool, "HIT from ", ap_get_server_name(r), NULL);
        return ap_proxy_cache_conditional(r, c, cachefp);


    }

    /*
     * at this point we have determined our cached data needs revalidation
     * but first - we check 1 thing:
     * 
     * RFC2616 14.9.4 - if "only-if-cached" specified, send a 504 Gateway
     * Timeout - we're not allowed to revalidate the object
     */
    if (ap_proxy_liststr(cc_req, "only-if-cached", NULL)) {
        if (cachefp)
            ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));
        return HTTP_GATEWAY_TIME_OUT;
    }


    /*
     * If we already have cached data and a last-modified date, and it is not
     * a head request, then add an If-Modified-Since.
     * 
     * If we also have an Etag, then the object must have come from an HTTP/1.1
     * server. Add an If-None-Match as well.
     * 
     * See RFC2616 13.3.4
     */

    if (cachefp != NULL && !r->header_only) {

        const char *etag = ap_table_get(c->hdrs, "Etag");

        /* If-Modified-Since */
        if (c->lmod != BAD_DATE) {
            /*
             * use the later of the one from the request and the
             * last-modified date from the cache
             */
            if (c->ims == BAD_DATE || c->ims < c->lmod) {
                const char *q;

                if ((q = ap_table_get(c->hdrs, "Last-Modified")) != NULL)
                    ap_table_set(r->headers_in, "If-Modified-Since", (char *)q);
            }
        }

        /* If-None-Match */
        if (etag) {
            ap_table_set(r->headers_in, "If-None-Match", etag);
        }

    }


    c->fp = cachefp;

    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Local copy not present or expired. Declining.");

    return DECLINED;
}

/*
 * Having read the response from the client, decide what to do
 * If the response is not cachable, then delete any previously cached
 * response, and copy data from remote server to client.
 * Functions:
 *  parse dates
 *  check for an uncachable response
 *  calculate an expiry date, if one is not provided
 *  if the remote file has not been modified, then return the document
 *  from the cache, maybe updating the header line
 *  otherwise, delete the old cached file and open a new temporary file
 */
int ap_proxy_cache_update(cache_req *c, table *resp_hdrs,
                              const int is_HTTP1, int nocache)
{
    request_rec *r = c->req;
    char *p;
    const char *expire, *lmods, *dates, *clen;
    time_t expc, date, lmod, now;
    char buff[17 * 7 + 1];
    void *sconf = r->server->module_config;
    proxy_server_conf *conf =
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
    const char *cc_resp;
    table *req_hdrs;
    size_t tflen;

    cc_resp = ap_table_get(resp_hdrs, "Cache-Control");

    c->tempfile = NULL;

    /* we've received the response from the origin server */

    /*
     * read expiry date; if a bad date, then leave it so the client can read
     * it
     */
    expire = ap_table_get(resp_hdrs, "Expires");
    if (expire != NULL)
        expc = ap_parseHTTPdate(expire);
    else
        expc = BAD_DATE;

    /* read the last-modified date; if the date is bad, then delete it */
    lmods = ap_table_get(resp_hdrs, "Last-Modified");
    if (lmods != NULL) {
        lmod = ap_parseHTTPdate(lmods);
        if (lmod == BAD_DATE) {
            /* kill last modified date */
            lmods = NULL;
        }
    }
    else
        lmod = BAD_DATE;


    /*
     * what responses should we not cache?
     * 
     * At this point we decide based on the response headers whether it is
     * appropriate _NOT_ to cache the data from the server. There are a whole
     * lot of conditions that prevent us from caching this data. They are
     * tested here one by one to be clear and unambiguous.
     */

    /*
     * RFC2616 13.4 we are allowed to cache 200, 203, 206, 300, 301 or 410 We
     * don't cache 206, because we don't (yet) cache partial responses. We
     * include 304 Not Modified here too as this is the origin server telling
     * us to serve the cached copy.
     */
    if ((r->status != HTTP_OK && r->status != HTTP_NON_AUTHORITATIVE && r->status != HTTP_MULTIPLE_CHOICES && r->status != HTTP_MOVED_PERMANENTLY && r->status != HTTP_NOT_MODIFIED) ||

    /* if a broken Expires header is present, don't cache it */
        (expire != NULL && expc == BAD_DATE) ||

    /*
     * if the server said 304 Not Modified but we have no cache file - pass
     * this untouched to the user agent, it's not for us.
     */
        (r->status == HTTP_NOT_MODIFIED && (c == NULL || c->fp == NULL)) ||

    /*
     * 200 OK response from HTTP/1.0 and up without a Last-Modified header
     */
        (r->status == HTTP_OK && lmods == NULL && is_HTTP1) ||

    /* HEAD requests */
        r->header_only ||

    /*
     * RFC2616 14.9.2 Cache-Control: no-store response indicating do not
     * cache, or stop now if you are trying to cache it
     */
        ap_proxy_liststr(cc_resp, "no-store", NULL) ||

    /*
     * RFC2616 14.9.1 Cache-Control: private this object is marked for this
     * user's eyes only. Behave as a tunnel.
     */
        ap_proxy_liststr(cc_resp, "private", NULL) ||

    /*
     * RFC2616 14.8 Authorisation: if authorisation is included in the
     * request, we don't cache, but we can cache if the following exceptions
     * are true: 1) If Cache-Control: s-maxage is included 2) If
     * Cache-Control: must-revalidate is included 3) If Cache-Control: public
     * is included
     */
        (ap_table_get(r->headers_in, "Authorization") != NULL

         && !(ap_proxy_liststr(cc_resp, "s-maxage", NULL) || ap_proxy_liststr(cc_resp, "must-revalidate", NULL) || ap_proxy_liststr(cc_resp, "public", NULL))
         ) ||

    /* or we've been asked not to cache it above */
        nocache) {

        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Response is not cacheable, unlinking %s", c->filename);

        /* close the file */
        if (c->fp != NULL) {
            ap_pclosef(r->pool, ap_bfileno(c->fp, B_WR));
            c->fp = NULL;
        }

        /* delete the previously cached file */
        if (c->filename)
            unlink(c->filename);
        return DECLINED;        /* send data to client but not cache */
    }


    /*
     * It's safe to cache the response.
     * 
     * We now want to update the cache file header information with the new
     * date, last modified, expire and content length and write it away to
     * our cache file. First, we determine these values from the response,
     * using heuristics if appropriate.
     * 
     * In addition, we make HTTP/1.1 age calculations and write them away too.
     */

    /* Read the date. Generate one if one is not supplied */
    dates = ap_table_get(resp_hdrs, "Date");
    if (dates != NULL)
        date = ap_parseHTTPdate(dates);
    else
        date = BAD_DATE;

    now = time(NULL);

    if (date == BAD_DATE) {     /* No, or bad date */
/* no date header! */
/* add one; N.B. use the time _now_ rather than when we were checking the cache
 */
        date = now;
        dates = ap_gm_timestr_822(r->pool, now);
        ap_table_set(resp_hdrs, "Date", dates);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Added date header");
    }

/* set response_time for HTTP/1.1 age calculations */
    c->resp_time = now;

/* check last-modified date */
    if (lmod != BAD_DATE && lmod > date)
/* if its in the future, then replace by date */
    {
        lmod = date;
        lmods = dates;
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Last modified is in the future, replacing with now");
    }
/* if the response did not contain the header, then use the cached version */
    if (lmod == BAD_DATE && c->fp != NULL) {
        lmod = c->lmod;
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Reusing cached last modified");
    }

/* we now need to calculate the expire data for the object. */
    if (expire == NULL && c->fp != NULL) {      /* no expiry data sent in
                                                 * response */
        expire = ap_table_get(c->hdrs, "Expires");
        if (expire != NULL)
            expc = ap_parseHTTPdate(expire);
    }
/* so we now have the expiry date */
/* if no expiry date then
 *   if lastmod
 *      expiry date = now + min((date - lastmod) * factor, maxexpire)
 *   else
 *      expire date = now + defaultexpire
 */
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Expiry date is %ld", (long)expc);
    if (expc == BAD_DATE) {
        if (lmod != BAD_DATE) {
            double x = (double)(date - lmod) * conf->cache.lmfactor;
            double maxex = conf->cache.maxexpire;
            if (x > maxex)
                x = maxex;
            expc = now + (int)x;
        }
        else
            expc = now + conf->cache.defaultexpire;
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Expiry date calculated %ld", (long)expc);
    }

/* get the content-length header */
    clen = ap_table_get(resp_hdrs, "Content-Length");
    if (clen == NULL)
        c->len = -1;
    else
        c->len = ap_strtol(clen, NULL, 10);

/* we have all the header information we need - write it to the cache file */
    c->version++;
    ap_proxy_sec2hex(date, buff + 17 * (0), sizeof(buff) - 17 * 0);
    buff[17 * (1) - 1] = ' ';
    ap_proxy_sec2hex(lmod, buff + 17 * (1), sizeof(buff) - 17 * 1);
    buff[17 * (2) - 1] = ' ';
    ap_proxy_sec2hex(expc, buff + 17 * (2), sizeof(buff) - 17 * 2);
    buff[17 * (3) - 1] = ' ';
    ap_proxy_sec2hex(c->version, buff + 17 * (3), sizeof(buff) - 17 * 3);
    buff[17 * (4) - 1] = ' ';
    ap_proxy_sec2hex(c->req_time, buff + 17 * (4), sizeof(buff) - 17 * 4);
    buff[17 * (5) - 1] = ' ';
    ap_proxy_sec2hex(c->resp_time, buff + 17 * (5), sizeof(buff) - 17 * 5);
    buff[17 * (6) - 1] = ' ';
    ap_proxy_sec2hex(c->len, buff + 17 * (6), sizeof(buff) - 17 * 6);
    buff[17 * (7) - 1] = '\n';
    buff[17 * (7)] = '\0';

/* Was the server response a 304 Not Modified?
 *
 * If it was, it means that we requested a revalidation, and that
 * the result of that revalidation was that the object was fresh.
 *
 */

/* if response from server 304 not modified */
    if (r->status == HTTP_NOT_MODIFIED) {

/* Have the headers changed?
 *
 * if not - we fulfil the request and return now.
 */

        if (c->hdrs) {
            /* recall at this point that c->len is already set from resp_hdrs.
               If Content-Length was NULL, then c->len is -1, otherwise it's
               set to whatever the value was. */
            if (c->len == 0 || c->len == -1) {
                const char *c_clen_str;
                off_t c_clen;
                if ( (c_clen_str = ap_table_get(c->hdrs, "Content-Length")) &&
                   ( (c_clen = ap_strtol(c_clen_str, NULL, 10)) > 0) ) {
                        ap_table_set(resp_hdrs, "Content-Length", c_clen_str);
                        c->len = c_clen;
                        ap_proxy_sec2hex(c->len, buff + 17 * (6),
			    sizeof(buff) - 17 * 6);
                        buff[17 * (7) - 1] = '\n';
                        buff[17 * (7)] = '\0';
                }
            }
            if (!ap_proxy_table_replace(c->hdrs, resp_hdrs)) {
                c->xcache = ap_pstrcat(r->pool, "HIT from ", ap_get_server_name(r), " (with revalidation)", NULL);
                return ap_proxy_cache_conditional(r, c, c->fp);
            }
        }
        else
            c->hdrs = resp_hdrs;
/* if we get here - the headers have changed. Go through the motions
 * of creating a new temporary cache file below, we'll then serve
 * the request like we would have in ap_proxy_cache_conditional()
 * above, and at the same time we will also rewrite the contents
 * to the new temporary file.
 */
    }

/*
 * Ok - lets prepare and open the cached file
 *
 * If a cached file (in c->fp) is already open, then we want to
 * update that cached file. Copy the c->fp to c->origfp and open
 * up a new one.
 *
 * If the cached file (in c->fp) is NULL, we must open a new cached
 * file from scratch.
 *
 * The new cache file will be moved to it's final location in the
 * directory tree later, overwriting the old cache file should it exist.
 */

/* if a cache file was already open */
    if (c->fp != NULL) {
        c->origfp = c->fp;
    }

    while (1) {
/* create temporary filename */
#define TMPFILESTR    "/tmpXXXXXXXXXX"
        if (conf->cache.root == NULL) {
            c = ap_proxy_cache_error(c);
            break;
        }
        tflen = strlen(conf->cache.root) + sizeof(TMPFILESTR);
        c->tempfile = ap_palloc(r->pool, tflen);
        strlcpy(c->tempfile, conf->cache.root, tflen);
        strlcat(c->tempfile, TMPFILESTR, tflen);
#undef TMPFILESTR
        p = mktemp(c->tempfile);
        if (p == NULL) {
            c = ap_proxy_cache_error(c);
            break;
        }

        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Create temporary file %s", c->tempfile);

/* create the new file */
        c->fp = ap_proxy_create_cachefile(r, c->tempfile);
        if (NULL == c->fp) {
            c = ap_proxy_cache_error(c);
            break;
        }

/* write away the cache header and the URL */
        if (ap_bvputs(c->fp, buff, "X-URL: ", c->url, "\n", NULL) == -1) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                        "proxy: error writing cache file(%s)", c->tempfile);
            c = ap_proxy_cache_error(c);
            break;
        }

/* get original request headers */
        if (c->req_hdrs)
            req_hdrs = ap_copy_table(r->pool, c->req_hdrs);
        else
            req_hdrs = ap_copy_table(r->pool, r->headers_in);

/* remove hop-by-hop headers */
        ap_proxy_clear_connection(r->pool, req_hdrs);

/* save original request headers */
        if (c->req_hdrs)
            ap_table_do(ap_proxy_send_hdr_line, c, c->req_hdrs, NULL);
        else
            ap_table_do(ap_proxy_send_hdr_line, c, r->headers_in, NULL);
        if (ap_bputs(CRLF, c->fp) == -1) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                          "proxy: error writing request headers terminating CRLF to %s", c->tempfile);
            c = ap_proxy_cache_error(c);
            break;
        }
        break;
    }

/* Was the server response a 304 Not Modified?
 *
 * If so, we have some work to do that we didn't do when we first
 * checked above. We need to fulfil the request, and we need to
 * copy the body from the old object to the new one.
 */

/* if response from server 304 not modified */
    if (r->status == HTTP_NOT_MODIFIED) {

/* fulfil the request */
        c->xcache = ap_pstrcat(r->pool, "HIT from ", ap_get_server_name(r), " (with revalidation)", NULL);
        return ap_proxy_cache_conditional(r, c, c->fp);

    }
    return DECLINED;
}

void ap_proxy_cache_tidy(cache_req *c)
{
    server_rec *s;
    off_t bc;

    if (!c || !c->fp)
        return;

    s = c->req->server;

/* don't care how much was sent, but rather how much was written to cache
    ap_bgetopt(c->req->connection->client, BO_BYTECT, &bc);
 */
    bc = c->written;

    if (c->len != -1) {
/* file lengths don't match; don't cache it */
        if (bc != c->len) {
            ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR));  /* no need to flush */
            unlink(c->tempfile);
            return;
        }
    }
/* don't care if aborted, cache it if fully retrieved from host!
    else if (c->req->connection->aborted) {
        ap_pclosef(c->req->pool, c->fp->fd);    / no need to flush /
        unlink(c->tempfile);
        return;
    }
*/
    else {
/* update content-length of file */
        char buff[17];
        off_t curpos;

        c->len = bc;
        ap_bflush(c->fp);
        ap_proxy_sec2hex(c->len, buff, sizeof(buff));
        curpos = lseek(ap_bfileno(c->fp, B_WR), 17 * 6, SEEK_SET);
        if (curpos == -1)
            ap_log_error(APLOG_MARK, APLOG_ERR, s,
                      "proxy: error seeking on cache file %s", c->tempfile);
        else if (write(ap_bfileno(c->fp, B_WR), buff, sizeof(buff) - 1) == -1)
            ap_log_error(APLOG_MARK, APLOG_ERR, s,
                         "proxy: error updating cache file %s", c->tempfile);
    }

    if (ap_bflush(c->fp) == -1) {
        ap_log_error(APLOG_MARK, APLOG_ERR, s,
                     "proxy: error writing to cache file %s",
                     c->tempfile);
        ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR));
        unlink(c->tempfile);
        return;
    }

    if (ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR))== -1) {
        ap_log_error(APLOG_MARK, APLOG_ERR, s,
                     "proxy: error closing cache file %s", c->tempfile);
        unlink(c->tempfile);
        return;
    }

    if (unlink(c->filename) == -1 && errno != ENOENT) {
        ap_log_error(APLOG_MARK, APLOG_ERR, s,
                     "proxy: error deleting old cache file %s",
                     c->filename);
        (void)unlink(c->tempfile);
    }
    else {
        char *p;
        proxy_server_conf *conf =
        (proxy_server_conf *)ap_get_module_config(s->module_config, &proxy_module);

        for (p = c->filename + strlen(conf->cache.root) + 1;;) {
            p = strchr(p, '/');
            if (!p)
                break;
            *p = '\0';
            if (mkdir(c->filename, S_IREAD | S_IWRITE | S_IEXEC) < 0 && errno != EEXIST)
                ap_log_error(APLOG_MARK, APLOG_ERR, s,
                             "proxy: error creating cache directory %s",
                             c->filename);
            *p = '/';
            ++p;
        }
        if (link(c->tempfile, c->filename) == -1)
            ap_log_error(APLOG_MARK, APLOG_INFO, s,
                         "proxy: error linking cache file %s to %s",
                         c->tempfile, c->filename);
        if (unlink(c->tempfile) == -1)
            ap_log_error(APLOG_MARK, APLOG_ERR, s,
                         "proxy: error deleting temp file %s", c->tempfile);
    }
}
@


1.20
log
@fix some fallout from the >2G commit. namely allow for all byte counters to
report the correct size when it exceeds a long's capacity.

From Dan Harnett <daniel @@ harnett . name>
@
text
@@


1.19
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1579 1
a1579 1
    long int bc;
@


1.18
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d1000 1
a1000 1
            while (*vary && (ap_isspace(*vary) || (*vary == ','))) {
@


1.17
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@a194 4
#if 0
    ap_log_error(APLOG_MARK, APLOG_DEBUG, r->server,
                 "proxy: Guess what; we fork() again...");
#endif
a214 1
#ifndef NO_SETSID
a220 8
#else
            if ((pgrp = setpgrp(getpid(), 0)) == -1) {
                perror("setpgrp");
                fprintf(stderr, "%s: setpgrp failed\n",
                        ap_server_argv0);
                exit(1);
            }
#endif
d426 1
a426 1
/* is it another file? */
d430 1
a430 4
/* under OS/2 use dirent's d_attr to identify a diretory */
/* under TPF use stat to identify a directory */

/* read the file */
a1216 3
#if defined(ULTRIX_BRAIN_DEATH) || defined(SINIX_D_RESOLVER_BUG)
    extern char *mktemp(char *template);
#endif
@


1.16
log
@Fix printf format string. ok henning@@
@
text
@a66 3
#ifdef WIN32
#include <sys/utime.h>
#else
a67 1
#endif                          /* WIN32 */
a69 7
#ifdef __TANDEM
#include <sys/types.h>
#include <sys/stat.h>
#endif
#ifdef TPF
#include "os.h"
#endif
a117 1
#if !defined(WIN32) && !defined(MPE) && !defined(OS2) && !defined(NETWARE) && !defined(TPF)
a118 1
#endif
a135 1
#if !defined(WIN32) && !defined(MPE) && !defined(OS2) && !defined(NETWARE) && !defined(TPF)
a136 3
#else
        help_proxy_garbage_coll(r);
#endif
a188 1
#if !defined(WIN32) && !defined(MPE) && !defined(OS2) && !defined(NETWARE) && !defined(TPF)
a225 15
#elif defined(NEXT) || defined(NEWSOS)
            if (setpgrp(0, getpid()) == -1 || (pgrp = getpgrp(0)) == -1) {
                perror("setpgrp");
                fprintf(stderr, "%S: setpgrp or getpgrp failed\n",
                        ap_server_argv0);
                exit(1);
            }
#elif defined(CYGWIN)
            /* Cygwin does not take any argument for setpgrp() */
            if ((pgrp = setpgrp()) == -1) {
                perror("setpgrp");
                fprintf(stderr, "%S: setpgrp failed\n",
                        ap_server_argv0);
                exit(1);
            }
a248 1
#endif                          /* ndef WIN32 */
a394 3
#if defined(NEXT) || defined(WIN32)
    struct DIR_TYPE *ent;
#else
a395 1
#endif
a444 29
#if defined(OS2) || defined(TPF)
/* is it a directory? */
#ifdef OS2
        if (ent->d_attr & A_DIR)
#elif defined(TPF)
            if (stat(filename, &buf) == -1) {
                if (errno != ENOENT)
                    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                                 "proxy gc: stat(%s)", filename);
            }
        if (S_ISDIR(buf.st_mode))
#endif
        {
            char newcachedir[HUGE_STRING_LEN];
            ap_snprintf(newcachedir, sizeof(newcachedir),
                        "%s%s/", cachesubdir, ent->d_name);
            if (!sub_garbage_coll(r, files, cachebasedir, newcachedir)) {
                ap_snprintf(newcachedir, sizeof(newcachedir),
                            "%s%s", cachedir, ent->d_name);
#if TESTING
                fprintf(stderr, "Would remove directory %s\n", newcachedir);
#else
                rmdir(newcachedir);
#endif
                --nfiles;
            }
            continue;
        }
#endif
a446 12
#if defined(WIN32)
        /*
         * On WIN32 open does not work for directories, so we us stat instead
         * of fstat to determine if the file is a directory
         */
        if (stat(filename, &buf) == -1) {
            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                         "proxy gc: stat(%s)", filename);
            continue;
        }
        fd = -1;
#else
a459 1
#endif
a460 2
/* In OS/2 and TPF this has already been done above */
#if !defined(OS2) && !defined(TPF)
a462 2
#if !defined(WIN32)
            /* Win32 used stat, no file to close */
a463 1
#endif
a481 1
#endif
a482 13
#if defined(WIN32)
        /*
         * Since we have determined above that the file is not a directory,
         * it should be safe to open it now
         */
        fd = open(filename, O_RDONLY | O_BINARY);
        if (fd == -1) {
            if (errno != ENOENT)
                ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                             "proxy gc: open(%s) = %d", filename, errno);
            continue;
        }
#endif
a1520 1
#ifndef TPF
a1531 12
#else
        if (conf->cache.root == NULL) {
            c = ap_proxy_cache_error(c);
            break;
        }
        tflen = strlen(conf->cache.root) + 1 + L_tmpnam;
        c->tempfile = ap_palloc(r->pool, tflen);
        strlcpy(c->tempfile, conf->cache.root, tflen);
        strlcat(c->tempfile, "/", tflen);
        p = tmpnam(NULL);
        strlcat(c->tempfile, p, tflen);
#endif
a1673 5
#if defined(WIN32) || defined(NETWARE)
            if (mkdir(c->filename) < 0 && errno != EEXIST)
#elif defined(__TANDEM)
                if (mkdir(c->filename, S_IRWXU | S_IRWXG | S_IRWXO) < 0 && errno != EEXIST)
#else
a1674 1
#endif                          /* WIN32 */
a1680 10
#if defined(OS2) || defined(WIN32) || defined(NETWARE) || defined(MPE)
        /* Under OS/2 use rename. */
        if (rename(c->tempfile, c->filename) == -1) {
            ap_log_error(APLOG_MARK, APLOG_ERR, s,
                         "proxy: error renaming cache file %s to %s",
                         c->tempfile, c->filename);
            (void)unlink(c->tempfile);
        }
#else

a1687 1
#endif
@


1.15
log
@merge
@
text
@d1050 1
a1050 1
                 (pragma_req == NULL) ? "(unset)" : pragma_req, c->ims);
@


1.14
log
@bump mktemp/mkstemp randomness from 6 -> 10 X's
henning@@ ok
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
d1810 1
a1810 1
            ap_log_error(APLOG_MARK, APLOG_ERR, s,
@


1.13
log
@string shit; ok dhartmei@@
@
text
@d1621 1
a1621 1
#define TMPFILESTR    "/tmpXXXXXX"
@


1.12
log
@string fixes; pval agrees
@
text
@d1536 1
a1536 1
    ap_proxy_sec2hex(date, buff + 17 * (0));
d1538 1
a1538 1
    ap_proxy_sec2hex(lmod, buff + 17 * (1));
d1540 1
a1540 1
    ap_proxy_sec2hex(expc, buff + 17 * (2));
d1542 1
a1542 1
    ap_proxy_sec2hex(c->version, buff + 17 * (3));
d1544 1
a1544 1
    ap_proxy_sec2hex(c->req_time, buff + 17 * (4));
d1546 1
a1546 1
    ap_proxy_sec2hex(c->resp_time, buff + 17 * (5));
d1548 1
a1548 1
    ap_proxy_sec2hex(c->len, buff + 17 * (6));
d1578 2
a1579 1
                        ap_proxy_sec2hex(c->len, buff + 17 * (6));
d1744 1
a1744 1
        ap_proxy_sec2hex(c->len, buff);
@


1.11
log
@merge apache 1.3.27 and mod_ssl 2.8.11
@
text
@d295 1
d304 2
a305 1
    filename = ap_palloc(r->pool, strlen(cachedir) + strlen(DOT_TIME) + 1);
d317 2
a318 2
    strcpy(filename, cachedir);
    strcat(filename, DOT_TIME);
d396 1
a396 1
        sprintf(filename, "%s%s", cachedir, fent->file);
d437 1
d440 2
a441 1
    filename = ap_palloc(r->pool, strlen(cachedir) + HASH_LEN + 2);
d453 1
a453 1
        sprintf(filename, "%s%s", cachedir, ent->d_name);
d617 2
a618 2
        strcpy(fent->file, cachesubdir);
        strcat(fent->file, ent->d_name);
d1345 1
d1625 4
a1628 3
        c->tempfile = ap_palloc(r->pool, strlen(conf->cache.root) + sizeof(TMPFILESTR));
        strcpy(c->tempfile, conf->cache.root);
        strcat(c->tempfile, TMPFILESTR);
d1636 4
a1639 3
        c->tempfile = ap_palloc(r->pool, strlen(conf->cache.root) + 1 + L_tmpnam);
        strcpy(c->tempfile, conf->cache.root);
        strcat(c->tempfile, "/");
d1641 1
a1641 1
        strcat(c->tempfile, p);
@


1.10
log
@merge
@
text
@d1527 1
a1527 1
        c->len = atoi(clen);
d1563 15
@


1.9
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d71 1
a71 1
#endif /* WIN32 */
d90 2
a91 2
    long lower; /* lower 30 bits of result */
    long upper; /* upper 31 bits of result */
d126 1
a126 1
                            const char *cachedir, const char *cachesubdir);
d138 1
a138 1
    (void) ap_acquire_mutex(garbage_mutex);
d140 1
a140 1
        (void) ap_release_mutex(garbage_mutex);
d145 1
a145 1
    (void) ap_release_mutex(garbage_mutex);
d156 1
a156 1
    (void) ap_acquire_mutex(garbage_mutex);
d158 1
a158 1
    (void) ap_release_mutex(garbage_mutex);
d162 1
a162 2
static void
add_long61 (long61_t *accu, long val)
d172 1
a172 2
static void
sub_long61 (long61_t *accu, long val)
d186 1
a186 2
static long
cmp_long61 (long61_t *left, long61_t *right)
d189 1
a189 1
                                         : (left->upper - right->upper);
d215 1
a215 1
                         "proxy: Guess what; we fork() again...");
d218 4
a221 4
        case -1:
            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                         "proxy: fork() for cache cleanup failed");
            return;
d223 1
a223 1
        case 0: /* Child */
d225 2
a226 2
            /* close all sorts of things, including the socket fd */
            ap_cleanup_for_exec();
d228 4
a231 4
            /* Fork twice to disassociate from the child */
            switch (pid = fork()) {
                case -1:
                    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
d233 1
a233 1
                    exit(1);
d235 2
a236 2
                case 0: /* Child */
                    /* The setpgrp() stuff was snarfed from http_main.c */
d238 6
a243 6
                    if ((pgrp = setsid()) == -1) {
                        perror("setsid");
                        fprintf(stderr, "%s: setsid failed\n",
                                ap_server_argv0);
                        exit(1);
                    }
d245 14
a258 6
                    if (setpgrp(0, getpid()) == -1 || (pgrp = getpgrp(0)) == -1) {
                        perror("setpgrp");
                        fprintf(stderr, "%S: setpgrp or getpgrp failed\n",
                                ap_server_argv0);
                        exit(1);
                    }
d260 20
a279 20
                    if ((pgrp = setpgrp(getpid(), 0)) == -1) {
                        perror("setpgrp");
                        fprintf(stderr, "%s: setpgrp failed\n",
                                ap_server_argv0);
                        exit(1);
                    }
#endif
                    help_proxy_garbage_coll(r);
                    exit(0);

                default:    /* Father */
                    /* After grandson has been forked off, */
                    /* there's nothing else to do. */
                    exit(0);
            }
        default:
            /* Wait until grandson has been forked off */
            /* (without wait we'd leave a zombie) */
            waitpid(pid, &status, 0);
            return;
d282 1
a282 1
#endif /* ndef WIN32 */
d290 1
a290 1
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
d298 1
a298 1
    static time_t lastcheck = BAD_DATE;         /* static (per-process) data!!! */
d303 1
a303 1
    filename = ap_palloc(r->pool, strlen(cachedir) + strlen( DOT_TIME ) +1);
d306 2
a307 1
    /* Usually, the modification time of <cachedir>/.time can only increase.
d309 2
a310 2
     * lastcheck, if time(NULL) still < lastcheck then it's not time
     * for GC yet.
d315 2
a316 2
    strcpy(filename,cachedir);
    strcat(filename,DOT_TIME);
d318 8
a325 7
    /* At this point we have a bit of an engineering compromise. We could either
     * create and/or mark the .time file  (prior to the fork which might
     * fail on a resource issue) or wait until we are safely forked. The
     * advantage of doing it now in this process is that we get some
     * usefull live out of the global last check variable. (XXX which
     * should go scoreboard IMHO.) Note that the actual counting is 
     * at a later moment.
d327 1
a327 1
   if (stat(filename, &buf) == -1) {   /* does not exist */
d361 1
a361 1
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
d382 3
a384 3
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server,
                         "proxy GC: Cache is %ld%% full (nothing deleted)",
                         (long)(((curbytes.upper<<20)|(curbytes.lower>>10))*100/conf->space));
d395 1
a395 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "GC Unlinking %s (expiry %ld, garbage_now %ld)", filename, (long)fent->expire, (long)garbage_now);
d413 3
a415 3
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server,
                         "proxy GC: Cache is %ld%% full (%d deleted)",
                         (long)(((curbytes.upper<<20)|(curbytes.lower>>10))*100/conf->space), i);
d422 1
a422 1
    char line[17*(3)];
d438 1
a438 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "GC Examining directory %s", cachedir);
d450 1
a450 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "GC Examining file %s", filename);
d461 3
a463 3
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "GC unlink %s", filename);
                ap_log_error(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, r->server,
                             "proxy gc: deleting orphaned cache file %s", filename);
d475 1
a475 1
        /*      if (strlen(ent->d_name) != HASH_LEN) continue; */
d482 1
a482 1
        if (ent->d_attr & A_DIR) {
d484 6
a489 6
    if (stat(filename, &buf) == -1) {
        if (errno != ENOENT)
            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                 "proxy gc: stat(%s)", filename);
    }
    if (S_ISDIR(buf.st_mode)) {
d491 1
d511 3
a513 3
        /* On WIN32 open does not work for directories, 
         * so we us stat instead of fstat to determine 
         * if the file is a directory 
d556 2
a557 1
            } else {
d566 3
a568 2
        /* Since we have determined above that the file is not a directory,
         * it should be safe to open it now 
d578 2
a579 2
 
        i = read(fd, line, 17*(3)-1);
d587 1
a587 1
        garbage_expire = ap_proxy_hex2sec(line + 17*(2));
d593 1
a593 1
                ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, r->server,
d645 12
a656 16
    /* Format:
     *
     * The cache needs to keep track of the following information:
     * - Date, LastMod, Version, ReqTime, RespTime, ContentLength
     * - The original request headers (for Vary)
     * - The original response headers (for returning with a cached response)
     * - The body of the message
     *
     * date SP lastmod SP expire SP count SP request-time SP response-time SP content-lengthCRLF
     * (dates are stored as hex seconds since 1970)
     * Original URLCRLF
     * Original Request Headers
     * CRLF
     * Original Response Headers
     * CRLF
     * Body
d662 3
a664 1
    if (len == -1)
d666 1
d672 1
a672 1
                   "&&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&&"))
d675 7
a681 7
    c->date = ap_proxy_hex2sec(urlbuff + 17*(0));
    c->lmod = ap_proxy_hex2sec(urlbuff + 17*(1));
    c->expire = ap_proxy_hex2sec(urlbuff + 17*(2));
    c->version = ap_proxy_hex2sec(urlbuff + 17*(3));
    c->req_time = ap_proxy_hex2sec(urlbuff + 17*(4));
    c->resp_time = ap_proxy_hex2sec(urlbuff + 17*(5));
    c->len = ap_proxy_hex2sec(urlbuff + 17*(6));
d685 3
a687 1
    if (len == -1)
d689 1
d699 3
a701 1
    if (c->req_hdrs == NULL)
d703 1
d707 3
a709 1
    if (len == -1)
d711 1
d723 3
a725 1
    if (c->hdrs == NULL)
d727 2
a728 1
    if (c->len != -1)    /* add a content-length header */
d734 1
a734 1
    
d759 5
a763 4
        /* check If-Match and If-Unmodified-Since exist
         *
         * If neither of these exist, the request is not conditional, and
         * we serve it normally
d769 11
a779 11
        /* check If-Match
         *
         * we check if the Etag on the cached file is in the list of Etags
         * in the If-Match field. The comparison must be a strong comparison,
         * so the Etag cannot be marked as weak. If the comparision fails
         * we return 412 Precondition Failed.
         *
         * if If-Match is specified AND
         * If-Match is not a "*" AND
         * Etag is missing or weak or not in the list THEN
         * return 412 Precondition Failed
d784 2
a785 2
            (!etag || (strlen(etag) > 1 && 'W' == etag[0] && '/' == etag[1]) || !ap_proxy_liststr(c->im, etag, NULL))) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "If-Match specified, and it didn't - return 412");
d788 1
a788 1
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "If-Match specified, and it matched");
d793 6
a798 6
        /* check If-Unmodified-Since
         *
         * if If-Unmodified-Since is specified AND
         * Last-Modified is specified somewhere AND
         * If-Unmodified-Since is in the past compared to Last-Modified THEN
         * return 412 Precondition Failed
d802 1
a802 1
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "If-Unmodified-Since specified, but it wasn't - return 412");
d805 1
a805 1
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "If-Unmodified-Since specified, and it was unmodified");
d813 1
a813 1
            ap_proxy_send_fb(c->origfp, r, c, c->len, 1, IOBUFSIZE);
d819 1
a819 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Use your cached copy, conditional precondition failed.");
d827 6
a832 5
        /* check for existance of If-None-Match and If-Modified-Since
         *
         * if neither of these headers have been set, then the request
         * is not conditional, and we just send the cached response and
         * be done with it.
d838 12
a849 12
        /* check If-None-Match
         *
         * we check if the Etag on the cached file is in the list of Etags
         * in the If-None-Match field. The comparison must be a strong comparison,
         * so the Etag cannot be marked as weak. If the comparision fails
         * we return 412 Precondition Failed.
         *
         * if If-None-Match is specified:
         * if If-None-Match is a "*" THEN 304
         * else if Etag is specified AND we get a match THEN 304
         * else if Weak Etag is specified AND we get a match THEN 304
         * else sent the original object
d853 1
a853 1
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "If-None-Match: * specified, return 304");
d856 1
a856 1
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "If-None-Match: specified and we got a strong match - return 304");
d859 1
a859 1
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "If-None-Match specified, and we got a weak match - return 304");
d865 6
a870 6
        /* check If-Modified-Since
         *
         * if If-Modified-Since is specified AND
         * Last-Modified is specified somewhere:
         * if last modification date is earlier than If-Modified-Since THEN 304
         * else send the original object
d874 1
a874 1
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "If-Modified-Since specified and not modified, try return 304");
d884 1
a884 1
            ap_proxy_send_fb(c->origfp, r, c, c->len, 1, IOBUFSIZE);
d890 1
a890 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Use local copy, cached file hasn't changed");
d896 1
a896 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Local copy modified, send it");
d901 1
a901 1
    ap_overlap_tables(r->headers_out, c->hdrs, AP_OVERLAP_TABLES_SET);
a907 4
    /* cookies are special: they must not be merged (stupid browsers) */
    ap_proxy_table_unmerge(r->pool, r->headers_out, "Set-Cookie");
    ap_proxy_table_unmerge(r->pool, r->headers_out, "Set-Cookie2");

d913 1
a913 1
        ap_proxy_send_fb(c->origfp, r, c, c->len, r->header_only, IOBUFSIZE);
d920 1
a920 1
        ap_proxy_send_fb(cachefp, r, NULL, c->len, 0, IOBUFSIZE);
d944 2
a945 2
int ap_proxy_cache_check(request_rec *r, char *url, struct cache_conf *conf,
                      cache_req **cr)
d947 2
a948 1
    const char *datestr, *pragma_req = NULL, *pragma_cresp = NULL, *cc_req = NULL, *cc_cresp = NULL, *vary = NULL;
a949 1
    time_t now;
d954 1
a954 1
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
d970 1
a970 1
    c->req_hdrs = NULL;   
d979 4
a982 4
      datestr = ap_proxy_date_canon(r->pool, datestr);
      c->ims = ap_parseHTTPdate(datestr);
      if (c->ims == BAD_DATE)        /* bad or out of range date; remove it */
         ap_table_unset(r->headers_in, "If-Modified-Since");
d990 4
a993 4
      datestr = ap_proxy_date_canon(r->pool, datestr); 
      c->ius = ap_parseHTTPdate(datestr);
      if (c->ius == BAD_DATE) /* bad or out of range date; remove it */
          ap_table_unset(r->headers_in, "If-Unmodified-Since");
d995 1
a995 1
     
d998 1
a998 1
     
d1006 1
a1006 1
      c->filename = ap_pstrcat(r->pool, conf->root, "/", hashfile, NULL);
d1009 4
a1012 4
      c->filename = NULL;
      c->fp = NULL;
      ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "No CacheRoot, so no caching. Declining.");
      return DECLINED;
d1035 6
a1040 6
      if (c->filename)
          unlink(c->filename);
      c->fp = NULL;
      c->filename = NULL;
      ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "no-store forbids caching. Declining.");
      return DECLINED;
d1045 2
a1046 2
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Request for %s, pragma_req=%s, ims=%ld", url,
             pragma_req, c->ims);
d1049 2
a1050 2
        strlen(url) < 1024 ) {
      cachefp = ap_proxy_open_cachefile(r, c->filename); 
d1054 3
a1056 1
    /* if a cache file exists, try reading body and headers from cache file */
d1061 2
a1062 2
                         "proxy: error reading cache file %s", 
                         c->filename);
d1064 2
a1065 2
            ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
                         "proxy: bad (short?) cache file: %s", c->filename);
a1072 1
            vary = ap_table_get(c->hdrs, "Vary");
d1088 3
a1090 2
    /* Check Content-Negotiation - Vary
     *
d1094 1
a1094 1
     *
d1098 1
a1098 1
     *
d1116 4
a1119 2
            /* is this header in the request and the header in the cached
             * request identical? If not, we give up and do a straight get */
d1132 1
a1132 1
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Vary header mismatch - object must be fetched from scratch. Declining.");
d1139 2
a1140 1
    /* We now want to check if our cached data is still fresh. This depends
d1142 27
a1168 27
     *
     * - RFC2616 14.9.4 End to end reload, Cache-Control: no-cache
     * no-cache in either the request or the cached response means that
     * we must revalidate the request unconditionally, overriding any
     * expiration mechanism. It's equivalent to max-age=0,must-revalidate.
     *
     * - RFC2616 14.32 Pragma: no-cache
     * This is treated the same as Cache-Control: no-cache.
     *
     * - RFC2616 14.9.3 Cache-Control: max-stale, must-revalidate, proxy-revalidate
     * if the max-stale request header exists, modify the stale calculations
     * below so that an object can be at most <max-stale> seconds stale before
     * we request a revalidation, _UNLESS_ a must-revalidate or
     * proxy-revalidate cached response header exists to stop us doing this.
     *
     * - RFC2616 14.9.3 Cache-Control: s-maxage
     * the origin server specifies the maximum age an object can be before
     * it is considered stale. This directive has the effect of proxy|must
     * revalidate, which in turn means simple ignore any max-stale setting.
     *
     * - RFC2616 14.9.4 Cache-Control: max-age
     * this header can appear in both requests and responses. If both are
     * specified, the smaller of the two takes priority.
     *
     * - RFC2616 14.21 Expires:
     * if this request header exists in the cached entity, and it's value is
     * in the past, it has expired.
d1183 1
a1183 1
        maxage_req =  atoi(val);
d1189 1
a1189 1
        maxage_cresp =  atoi(val);
d1193 3
a1195 1
    /* if both maxage request and response, the smaller one takes priority */
d1205 1
a1205 1
        maxstale =  atoi(val);
d1211 1
a1211 1
        minfresh =  atoi(val);
d1216 1
a1216 1
    if (maxstale && ( (cc_cresp && ap_proxy_liststr(cc_cresp, "must-revalidate", NULL)) || (cc_cresp && ap_proxy_liststr(cc_cresp, "proxy-revalidate", NULL)) ))
a1218 1
    now = time(NULL);
d1221 2
a1222 2
        /* handle no-cache */
        !( (cc_req && ap_proxy_liststr(cc_req, "no-cache", NULL)) ||
d1225 1
a1225 6
          (pragma_cresp && ap_proxy_liststr(pragma_cresp, "no-cache", NULL)) ) &&

        /* handle expiration */
        ( (-1 < smaxage && age < (smaxage - minfresh)) ||
          (-1 < maxage && age < (maxage + maxstale - minfresh)) ||
          (c->expire != BAD_DATE && age < (c->expire - c->date + maxstale - minfresh)) )
d1227 4
d1235 1
a1235 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Unexpired data available");
d1239 1
a1239 1
                        ap_psprintf(r->pool, "%lu", (unsigned long)age));
d1242 3
a1244 3
        if (!( (-1 < smaxage && age < smaxage) ||
             (-1 < maxage && age < maxage) ||
             (c->expire != BAD_DATE && (c->expire - c->date) > age) )) {
d1256 2
a1257 1
    /* at this point we have determined our cached data needs revalidation
d1259 3
a1261 3
     *
     * RFC2616 14.9.4 - if "only-if-cached" specified, send a
     * 504 Gateway Timeout - we're not allowed to revalidate the object
d1270 7
a1276 6
    /* If we already have cached data and a last-modified date, and it is
     * not a head request, then add an If-Modified-Since.
     *
     * If we also have an Etag, then the object must have come from
     * an HTTP/1.1 server. Add an If-None-Match as well.
     *
d1286 4
a1289 2
            /* use the later of the one from the request and the last-modified date
             * from the cache */
d1294 1
a1294 1
                    ap_table_set(r->headers_in, "If-Modified-Since", (char *) q);
d1308 1
a1308 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Local copy not present or expired. Declining.");
d1326 1
a1326 1
                       const int is_HTTP1, int nocache)
d1329 2
a1330 2
  extern char *mktemp(char *template);
#endif 
d1335 1
a1335 1
    char buff[17*7+1];
d1338 1
a1338 1
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
d1347 5
a1351 3
    
    /* read expiry date; if a bad date, then leave it so the client can
     * read it */
d1373 13
a1385 10
     *
     * At this point we decide based on the response headers whether it
     * is appropriate _NOT_ to cache the data from the server. There are
     * a whole lot of conditions that prevent us from caching this data.
     * They are tested here one by one to be clear and unambiguous. */

    /* RFC2616 13.4 we are allowed to cache 200, 203, 206, 300, 301 or 410
     * We don't cache 206, because we don't (yet) cache partial responses.
     * We include 304 Not Modified here too as this is the origin server
     * telling us to serve the cached copy. */
d1391 4
a1394 2
    /* if the server said 304 Not Modified but we have no cache file - pass
     * this untouched to the user agent, it's not for us. */
d1397 3
a1399 1
    /* 200 OK response from HTTP/1.0 and up without a Last-Modified header */
d1405 4
a1408 2
    /* RFC2616 14.9.2 Cache-Control: no-store response indicating do not
     * cache, or stop now if you are trying to cache it */
d1411 4
a1414 2
    /* RFC2616 14.9.1 Cache-Control: private
     * this object is marked for this user's eyes only. Behave as a tunnel. */
d1417 6
a1422 6
    /* RFC2616 14.8 Authorisation:
     * if authorisation is included in the request, we don't cache, but we
     * can cache if the following exceptions are true:
     * 1) If Cache-Control: s-maxage is included
     * 2) If Cache-Control: must-revalidate is included
     * 3) If Cache-Control: public is included
d1426 2
a1427 2
        && !(ap_proxy_liststr(cc_resp, "s-maxage", NULL) || ap_proxy_liststr(cc_resp, "must-revalidate", NULL) || ap_proxy_liststr(cc_resp, "public", NULL))
        ) ||
d1432 1
a1432 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Response is not cacheable, unlinking %s", c->filename);
d1447 9
a1455 9
    /* It's safe to cache the response.
     *
     * We now want to update the cache file header information with
     * the new date, last modified, expire and content length and write
     * it away to our cache file. First, we determine these values from
     * the response, using heuristics if appropriate.
     *
     * In addition, we make HTTP/1.1 age calculations and write them away
     * too.
d1474 1
a1474 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Added date header");
d1486 1
a1486 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Last modified is in the future, replacing with now");
d1491 1
a1491 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Reusing cached last modified");
d1495 2
a1496 1
    if (expire == NULL && c->fp != NULL) {     /* no expiry data sent in response */
d1508 1
a1508 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Expiry date is %ld", (long)expc);
d1511 1
a1511 1
            double x = (double) (date - lmod) * conf->cache.lmfactor;
d1515 1
a1515 1
            expc = now + (int) x;
d1519 1
a1519 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Expiry date calculated %ld", (long)expc);
d1531 15
a1545 15
    ap_proxy_sec2hex(date, buff + 17*(0));
    buff[17*(1)-1] = ' ';
    ap_proxy_sec2hex(lmod, buff + 17*(1));
    buff[17*(2)-1] = ' '; 
    ap_proxy_sec2hex(expc, buff + 17*(2));
    buff[17*(3)-1] = ' ';
    ap_proxy_sec2hex(c->version, buff + 17*(3));
    buff[17*(4)-1] = ' ';
    ap_proxy_sec2hex(c->req_time, buff + 17*(4));
    buff[17*(5)-1] = ' ';
    ap_proxy_sec2hex(c->resp_time, buff + 17*(5));
    buff[17*(6)-1] = ' '; 
    ap_proxy_sec2hex(c->len, buff + 17*(6));
    buff[17*(7)-1] = '\n';
    buff[17*(7)] = '\0';
d1555 1
a1555 1
      if (r->status == HTTP_NOT_MODIFIED) {
d1563 3
a1565 3
          if (!ap_proxy_table_replace(c->hdrs, resp_hdrs)) {
              c->xcache = ap_pstrcat(r->pool, "HIT from ", ap_get_server_name(r), " (with revalidation)", NULL);
              return ap_proxy_cache_conditional(r, c, c->fp);
d1569 1
a1569 1
          c->hdrs = resp_hdrs;
d1576 1
a1576 1
      }
d1578 1
a1578 1
/* 
d1580 1
a1580 1
 * 
d1584 1
a1584 1
 *  
d1590 1
a1590 1
 */       
d1594 1
a1594 1
      c->origfp = c->fp;
d1601 7
a1607 7
      if (conf->cache.root == NULL) {
          c = ap_proxy_cache_error(c);
          break;
      }
      c->tempfile = ap_palloc(r->pool, strlen(conf->cache.root) + sizeof(TMPFILESTR));
      strcpy(c->tempfile, conf->cache.root);
      strcat(c->tempfile, TMPFILESTR);
d1609 1
a1609 1
      p = mktemp(c->tempfile);
d1611 14
a1624 14
      if (conf->cache.root == NULL) {
          c = ap_proxy_cache_error(c);
          break;
      }
      c->tempfile = ap_palloc(r->pool, strlen(conf->cache.root) +1+ L_tmpnam);
      strcpy(c->tempfile, conf->cache.root);
      strcat(c->tempfile, "/");
      p = tmpnam(NULL);
      strcat(c->tempfile, p);
#endif
      if (p == NULL) {
          c = ap_proxy_cache_error(c);
          break;
      }
d1626 1
a1626 1
      ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "Create temporary file %s", c->tempfile);
d1629 5
a1633 5
      c->fp = ap_proxy_create_cachefile(r, c->tempfile);
      if (NULL == c->fp) {
          c = ap_proxy_cache_error(c);
          break;
      }
d1636 6
a1641 6
      if (ap_bvputs(c->fp, buff, "X-URL: ", c->url, "\n", NULL) == -1) {
          ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                       "proxy: error writing cache file(%s)", c->tempfile);
          c = ap_proxy_cache_error(c);
          break;
      }
d1644 4
a1647 4
      if (c->req_hdrs)
          req_hdrs = ap_copy_table(r->pool, c->req_hdrs);
      else
          req_hdrs = ap_copy_table(r->pool, r->headers_in);
d1650 1
a1650 1
      ap_proxy_clear_connection(r->pool, req_hdrs);
d1653 1
a1653 1
      if (c->req_hdrs)
d1655 1
a1655 1
      else
d1657 7
a1663 7
      if (ap_bputs(CRLF, c->fp) == -1) {
          ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                      "proxy: error writing request headers terminating CRLF to %s", c->tempfile);
          c = ap_proxy_cache_error(c);
          break;
      }
      break;
d1677 2
a1678 2
      c->xcache = ap_pstrcat(r->pool, "HIT from ", ap_get_server_name(r), " (with revalidation)", NULL);
      return ap_proxy_cache_conditional(r, c, c->fp);
d1722 1
a1722 1
        curpos = lseek(ap_bfileno(c->fp, B_WR), 17*6, SEEK_SET);
d1725 1
a1725 1
                         "proxy: error seeking on cache file %s", c->tempfile);
d1740 1
a1740 1
    if (ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR)) == -1) {
d1750 2
a1751 1
                     c->tempfile);
d1756 1
a1756 1
        (proxy_server_conf *) ap_get_module_config(s->module_config, &proxy_module);
d1766 1
a1766 1
            if (mkdir(c->filename, S_IRWXU | S_IRWXG | S_IRWXO) < 0 && errno != EEXIST)
d1769 1
a1769 1
#endif /* WIN32 */
d1778 1
a1778 1
        if (rename(c->tempfile, c->filename) == -1)
d1782 2
a1783 1
    }
d1790 4
a1794 6

    if (unlink(c->tempfile) == -1)
        ap_log_error(APLOG_MARK, APLOG_ERR, s,
                     "proxy: error deleting temp file %s", c->tempfile);
#endif

@


1.8
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d65 1
a81 2
DEF_Explain

d90 1
a90 1
    long lower;	/* lower 30 bits of result */
d110 1
a110 1
static long block_size = 512;	/* this must be a power of 2 */
d119 1
a119 1
	garbage_mutex = ap_create_mutex(NULL);
d126 1
a126 1
			    const char *cachedir, const char *cachesubdir);
d140 2
a141 2
	(void) ap_release_mutex(garbage_mutex);
	return;
d144 1
a144 1
	inside = 1;
d147 1
a147 1
    ap_block_alarms();		/* avoid SIGALRM on big cache cleanup */
d192 1
a192 1
					 : (left->upper - right->upper);
d202 1
a202 1
	return 1;
d204 1
a204 1
	return -1;
d206 1
a206 1
	return 0;
d218 1
a218 1
			 "proxy: Guess what; we fork() again...");
d221 6
a226 16
	case -1:
	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			 "proxy: fork() for cache cleanup failed");
	    return;

	case 0:	/* Child */

	    /* close all sorts of things, including the socket fd */
	    ap_cleanup_for_exec();

	    /* Fork twice to disassociate from the child */
	    switch (pid = fork()) {
		case -1:
		    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			 "proxy: fork(2nd) for cache cleanup failed");
		    exit(1);
d228 12
a239 2
		case 0:	/* Child */
		    /* The setpgrp() stuff was snarfed from http_main.c */
d241 6
a246 6
		    if ((pgrp = setsid()) == -1) {
			perror("setsid");
			fprintf(stderr, "%s: setsid failed\n",
				ap_server_argv0);
			exit(1);
		    }
d248 6
a253 6
		    if (setpgrp(0, getpid()) == -1 || (pgrp = getpgrp(0)) == -1) {
			perror("setpgrp");
			fprintf(stderr, "%S: setpgrp or getpgrp failed\n",
				ap_server_argv0);
			exit(1);
		    }
d255 6
a260 6
		    if ((pgrp = setpgrp(getpid(), 0)) == -1) {
			perror("setpgrp");
			fprintf(stderr, "%s: setpgrp failed\n",
				ap_server_argv0);
			exit(1);
		    }
d262 2
a263 2
		    help_proxy_garbage_coll(r);
		    exit(0);
d265 10
a274 10
		default:    /* Father */
		    /* After grandson has been forked off, */
		    /* there's nothing else to do. */
		    exit(0);		    
	    }
	default:
	    /* Wait until grandson has been forked off */
	    /* (without wait we'd leave a zombie) */
	    waitpid(pid, &status, 0);
	    return;
d279 1
a279 1
#define DOT_TIME "/.time"	/* marker */
d337 1
a337 1
	lastcheck = buf.st_mtime;       /* save the time */
d367 1
a367 1
    ap_block_alarms();		/* avoid SIGALRM on big cache cleanup */
d375 5
a379 5
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server,
			 "proxy GC: Cache is %ld%% full (nothing deleted)",
			 (long)(((curbytes.upper<<20)|(curbytes.lower>>10))*100/conf->space));
	ap_unblock_alarms();
	return;
d386 3
a388 3
	fent = &((struct gc_ent *) files->elts)[i];
	sprintf(filename, "%s%s", cachedir, fent->file);
	Explain3("GC Unlinking %s (expiry %ld, garbage_now %ld)", filename, (long)fent->expire, (long)garbage_now);
d390 1
a390 1
	fprintf(stderr, "Would unlink %s\n", filename);
d392 6
a397 6
	if (unlink(filename) == -1) {
	    if (errno != ENOENT)
		ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			     "proxy gc: unlink(%s)", filename);
	}
	else
d399 5
a403 5
	{
	    sub_long61(&curbytes, ROUNDUP2BLOCKS(fent->len));
	    if (cmp_long61(&curbytes, &cachesize) < 0)
		break;
	}
d407 2
a408 2
			 "proxy GC: Cache is %ld%% full (%d deleted)",
			 (long)(((curbytes.upper<<20)|(curbytes.lower>>10))*100/conf->space), i);
d413 1
a413 1
			  const char *cachebasedir, const char *cachesubdir)
d415 1
a415 1
    char line[27];
d431 1
a431 1
    Explain1("GC Examining directory %s", cachedir);
d434 3
a436 3
	ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
		     "proxy gc: opendir(%s)", cachedir);
	return 0;
d440 4
a443 4
	if (ent->d_name[0] == '.')
	    continue;
	sprintf(filename, "%s%s", cachedir, ent->d_name);
	Explain1("GC Examining file %s", filename);
d445 1
a445 1
	if (strncmp(ent->d_name, "tmp", 3) == 0) {
d447 10
a456 10
	    if (stat(filename, &buf) == -1) {
		if (errno != ENOENT)
		    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
				 "proxy gc: stat(%s)", filename);
	    }
	    else if (garbage_now != -1 && buf.st_atime < garbage_now - SEC_ONE_DAY &&
		     buf.st_mtime < garbage_now - SEC_ONE_DAY) {
		Explain1("GC unlink %s", filename);
		ap_log_error(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, r->server,
			     "proxy gc: deleting orphaned cache file %s", filename);
d458 1
a458 1
		fprintf(stderr, "Would unlink %s\n", filename);
d460 1
a460 1
		unlink(filename);
d462 4
a465 4
	    }
	    continue;
	}
	++nfiles;
d467 2
a468 2
	/* FIXME: Shouldn't any unexpected files be deleted? */
	/*      if (strlen(ent->d_name) != HASH_LEN) continue; */
d475 1
a475 1
	if (ent->d_attr & A_DIR) {
d484 6
a489 6
	    char newcachedir[HUGE_STRING_LEN];
	    ap_snprintf(newcachedir, sizeof(newcachedir),
			"%s%s/", cachesubdir, ent->d_name);
	    if (!sub_garbage_coll(r, files, cachebasedir, newcachedir)) {
		ap_snprintf(newcachedir, sizeof(newcachedir),
			    "%s%s", cachedir, ent->d_name);
d491 1
a491 1
		fprintf(stderr, "Would remove directory %s\n", newcachedir);
d493 1
a493 1
		rmdir(newcachedir);
d495 4
a498 4
		--nfiles;
	    }
	    continue;
	}
d509 1
a509 1
        		 "proxy gc: stat(%s)", filename);
d514 13
a526 13
 	fd = open(filename, O_RDONLY | O_BINARY);
	if (fd == -1) {
	    if (errno != ENOENT)
		ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			     "proxy gc: open(%s)", filename);
	    continue;
	}
	if (fstat(fd, &buf) == -1) {
	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			 "proxy gc: fstat(%s)", filename);
	    close(fd);
	    continue;
	}
d531 2
a532 2
	if (S_ISDIR(buf.st_mode)) {
	    char newcachedir[HUGE_STRING_LEN];
d537 5
a541 5
	    ap_snprintf(newcachedir, sizeof(newcachedir),
			"%s%s/", cachesubdir, ent->d_name);
	    if (!sub_garbage_coll(r, files, cachebasedir, newcachedir)) {
		ap_snprintf(newcachedir, sizeof(newcachedir),
			    "%s%s", cachedir, ent->d_name);
d543 1
a543 1
		fprintf(stderr, "Would remove directory %s\n", newcachedir);
d545 1
a545 1
		rmdir(newcachedir);
d547 7
a553 7
		--nfiles;
	    } else {
		/* Directory is not empty. Account for its size: */
		add_long61(&curbytes, ROUNDUP2BLOCKS(buf.st_size));
	    }
	    continue;
	}
d563 2
a564 2
	        ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
		             "proxy gc: open(%s) = %d", filename, errno);
d569 16
a584 16
	i = read(fd, line, 26);
	close(fd);
	if (i == -1) {
	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			 "proxy gc: read(%s)", filename);
	    continue;
	}
	line[i] = '\0';
	garbage_expire = ap_proxy_hex2sec(line + 18);
	if (!ap_checkmask(line, "&&&&&&&& &&&&&&&& &&&&&&&&") ||
	    garbage_expire == BAD_DATE) {
	    /* bad file */
	    if (garbage_now != -1 && buf.st_atime > garbage_now + SEC_ONE_DAY &&
		buf.st_mtime > garbage_now + SEC_ONE_DAY) {
		ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, r->server,
			     "proxy: deleting bad cache file with future date: %s", filename);
d586 1
a586 1
		fprintf(stderr, "Would unlink bad file %s\n", filename);
d588 1
a588 1
		unlink(filename);
d590 3
a592 3
	    }
	    continue;
	}
d600 5
a604 5
	fent = (struct gc_ent *) ap_push_array(files);
	fent->len = buf.st_size;
	fent->expire = garbage_expire;
	strcpy(fent->file, cachesubdir);
	strcat(fent->file, ent->d_name);
d607 1
a607 1
	add_long61(&curbytes, ROUNDUP2BLOCKS(buf.st_size));
d616 1
d618 1
a618 1
 * read a cache file;
d622 5
d630 1
a630 1
    char urlbuff[1034], *strp;
d632 23
a654 5
/* read the data from the cache file */
/* format
 * date SP lastmod SP expire SP count SP content-length CRLF
 * dates are stored as hex seconds since 1970
 */
d657 1
a657 1
	return -1;
d659 1
a659 1
	return 0;
d663 2
a664 2
		   "&&&&&&&& &&&&&&&& &&&&&&&& &&&&&&&& &&&&&&&&"))
	return 0;
d666 7
a672 5
    c->date = ap_proxy_hex2sec(urlbuff);
    c->lmod = ap_proxy_hex2sec(urlbuff + 9);
    c->expire = ap_proxy_hex2sec(urlbuff + 18);
    c->version = ap_proxy_hex2sec(urlbuff + 27);
    c->len = ap_proxy_hex2sec(urlbuff + 36);
d674 1
a674 1
/* check that we have the same URL */
d677 1
a677 1
	return -1;
d679 2
a680 2
	urlbuff[len - 1] != '\n')
	return 0;
d683 6
a688 1
	return 0;
d690 1
a690 1
/* What follows is the message */
d693 1
a693 1
	return -1;
d695 1
a695 1
	return 0;
d701 1
a701 1
	return 0;
d706 93
a798 6
	return -1;
    if (c->len != -1) {		/* add a content-length header */
	if (ap_table_get(c->hdrs, "Content-Length") == NULL) {
	    ap_table_set(c->hdrs, "Content-Length",
			 ap_psprintf(r->pool, "%lu", (unsigned long)c->len));
	}
d800 108
a907 1
    return 1;
d921 1
a921 1
 *      else
d926 1
a926 1
		      cache_req **cr)
d928 1
a928 2
    char hashfile[66];
    const char *imstr, *pragma, *auth;
d932 1
a932 2
    int cfd, i;
    const long int zero = 0L;
d936 4
d945 9
d955 1
a955 1
/* get the If-Modified-Since date of the request */
d957 31
a987 7
    imstr = ap_table_get(r->headers_in, "If-Modified-Since");
    if (imstr != NULL) {
/* this may modify the value in the original table */
	imstr = ap_proxy_date_canon(r->pool, imstr);
	c->ims = ap_parseHTTPdate(imstr);
	if (c->ims == BAD_DATE)	/* bad or out of range date; remove it */
	    ap_table_unset(r->headers_in, "If-Modified-Since");
d989 25
d1015 8
a1022 6
/* find the filename for this cache entry */
    ap_proxy_hash(url, hashfile, pconf->cache.dirlevels, pconf->cache.dirlength);
    if (conf->root != NULL)
	c->filename = ap_pstrcat(r->pool, conf->root, "/", hashfile, NULL);
    else
	c->filename = NULL;
d1024 1
d1026 2
a1028 4
    pragma = ap_table_get(r->headers_in, "Pragma");
    auth = ap_table_get(r->headers_in, "Authorization");
    Explain5("Request for %s, pragma=%s, auth=%s, ims=%ld, imstr=%s", url,
	     pragma, auth, (long)c->ims, imstr);
d1030 2
a1031 17
	strlen(url) < 1024 && !ap_proxy_liststr(pragma, "no-cache") &&
	auth == NULL) {
	Explain1("Check file %s", c->filename);
	cfd = open(c->filename, O_RDWR | O_BINARY);
	if (cfd != -1) {
	    ap_note_cleanups_for_fd(r->pool, cfd);
	    cachefp = ap_bcreate(r->pool, B_RD | B_WR);
	    ap_bpushfd(cachefp, cfd, cfd);
	}
	else if (errno != ENOENT)
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "proxy: error opening cache file %s",
			 c->filename);
#ifdef EXPLAIN
	else
	    Explain1("File %s not found", c->filename);
#endif
d1034 2
d1037 20
a1056 12
	i = rdcache(r, cachefp, c);
	if (i == -1)
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "proxy: error reading cache file %s", 
			 c->filename);
	else if (i == 0)
	    ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
			 "proxy: bad (short?) cache file: %s", c->filename);
	if (i != 1) {
	    ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));
	    cachefp = NULL;
	}
d1058 2
d1062 1
d1064 1
a1064 1
	c->hdrs = ap_make_table(r->pool, 20);
d1067 126
d1194 37
a1230 11
/* Ok, have we got some un-expired data? */
    if (cachefp != NULL && c->expire != BAD_DATE && now < c->expire) {
	Explain0("Unexpired data available");
/* check IMS */
	if (c->lmod != BAD_DATE && c->ims != BAD_DATE && c->ims >= c->lmod) {
/* has the cached file changed since this request? */
	    if (c->date == BAD_DATE || c->date > c->ims) {
/* No, but these header values may have changed, so we send them with the
 * 304 HTTP_NOT_MODIFIED response
 */
		const char *q;
d1232 10
a1241 23
		if ((q = ap_table_get(c->hdrs, "Expires")) != NULL)
		    ap_table_set(r->headers_out, "Expires", q);
	    }
	    ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));
	    Explain0("Use local copy, cached file hasn't changed");
	    return HTTP_NOT_MODIFIED;
	}

/* Ok, has been modified */
	Explain0("Local copy modified, send it");
	r->status_line = strchr(c->resp_line, ' ') + 1;
	r->status = c->status;
	if (!r->assbackwards) {
	    ap_soft_timeout("proxy send headers", r);
	    ap_proxy_send_headers(r, c->resp_line, c->hdrs);
	    ap_kill_timeout(r);
	}
	ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
	r->sent_bodyct = 1;
	if (!r->header_only)
	    ap_proxy_send_fb(cachefp, r, NULL);
	ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));
	return OK;
a1243 3
/* if we already have data and a last-modified date, and it is not a head
 * request, then add an If-Modified-Since
 */
d1245 29
a1273 7
    if (cachefp != NULL && c->lmod != BAD_DATE && !r->header_only) {
/*
 * use the later of the one from the request and the last-modified date
 * from the cache
 */
	if (c->ims == BAD_DATE || c->ims < c->lmod) {
	    const char *q;
a1274 4
	    if ((q = ap_table_get(c->hdrs, "Last-Modified")) != NULL)
		ap_table_set(r->headers_in, "If-Modified-Since",
			  (char *) q);
	}
d1276 2
d1280 1
a1280 1
    Explain0("Local copy not present or expired. Declining.");
d1298 1
a1298 1
		       const int is_HTTP1, int nocache)
a1304 1
    int i;
d1307 1
a1307 1
    char buff[46];
d1311 4
a1314 1
    const long int zero = 0L;
d1318 4
a1321 4
/* we've received the response */
/* read expiry date; if a bad date, then leave it so the client can
 * read it
 */
d1324 1
a1324 1
	expc = ap_parseHTTPdate(expire);
d1326 1
a1326 1
	expc = BAD_DATE;
d1328 1
a1328 3
/*
 * read the last-modified date; if the date is bad, then delete it
 */
d1331 5
a1335 5
	lmod = ap_parseHTTPdate(lmods);
	if (lmod == BAD_DATE) {
/* kill last modified date */
	    lmods = NULL;
	}
d1338 54
a1391 1
	lmod = BAD_DATE;
d1393 7
a1399 25
/*
 * what responses should we not cache?
 * Unknown status responses and those known to be uncacheable
 * 304 HTTP_NOT_MODIFIED response when we have no valid cache file, or
 * 200 HTTP_OK response from HTTP/1.0 and up without a Last-Modified header, or
 * HEAD requests, or
 * requests with an Authorization header, or
 * protocol requests nocache (e.g. ftp with user/password)
 */
/* @@@@@@ XXX FIXME: is the test "r->status != HTTP_MOVED_PERMANENTLY" correct?
 * or shouldn't it be "ap_is_HTTP_REDIRECT(r->status)" ? -MnKr */
    if ((r->status != HTTP_OK && r->status != HTTP_MOVED_PERMANENTLY && r->status != HTTP_NOT_MODIFIED) ||
	(expire != NULL && expc == BAD_DATE) ||
	(r->status == HTTP_NOT_MODIFIED && (c == NULL || c->fp == NULL)) ||
	(r->status == HTTP_OK && lmods == NULL && is_HTTP1) ||
	r->header_only ||
	ap_table_get(r->headers_in, "Authorization") != NULL ||
	nocache) {
	Explain1("Response is not cacheable, unlinking %s", c->filename);
/* close the file */
	if (c->fp != NULL) {
	    ap_pclosef(r->pool, ap_bfileno(c->fp, B_WR));
	    c->fp = NULL;
	}
/* delete the previously cached file */
d1402 1
a1402 1
	return DECLINED;	/* send data to client but not cache */
d1405 13
a1417 4
/* otherwise, we are going to cache the response */
/*
 * Read the date. Generate one if one is not supplied
 */
d1420 1
a1420 1
	date = ap_parseHTTPdate(dates);
d1422 1
a1422 1
	date = BAD_DATE;
d1426 1
a1426 1
    if (date == BAD_DATE) {	/* No, or bad date */
d1430 4
a1433 4
	date = now;
	dates = ap_gm_timestr_822(r->pool, now);
	ap_table_set(resp_hdrs, "Date", dates);
	Explain0("Added date header");
d1436 3
d1443 3
a1445 3
	lmod = date;
	lmods = dates;
	Explain0("Last modified is in the future, replacing with now");
d1449 2
a1450 2
	lmod = c->lmod;
	Explain0("Reusing cached last modified");
d1454 4
a1457 4
    if (expire == NULL && c->fp != NULL) {	/* no expiry data sent in response */
	expire = ap_table_get(c->hdrs, "Expires");
	if (expire != NULL)
	    expc = ap_parseHTTPdate(expire);
d1466 1
a1466 1
    Explain1("Expiry date is %ld", (long)expc);
d1468 10
a1477 10
	if (lmod != BAD_DATE) {
	    double x = (double) (date - lmod) * conf->cache.lmfactor;
	    double maxex = conf->cache.maxexpire;
	    if (x > maxex)
		x = maxex;
	    expc = now + (int) x;
	}
	else
	    expc = now + conf->cache.defaultexpire;
	Explain1("Expiry date calculated %ld", (long)expc);
d1483 1
a1483 1
	c->len = -1;
d1485 26
a1510 1
	c->len = atoi(clen);
d1512 2
a1513 11
    ap_proxy_sec2hex(date, buff);
    buff[8] = ' ';
    ap_proxy_sec2hex(lmod, buff + 9);
    buff[17] = ' ';
    ap_proxy_sec2hex(expc, buff + 18);
    buff[26] = ' ';
    ap_proxy_sec2hex(c->version++, buff + 27);
    buff[35] = ' ';
    ap_proxy_sec2hex(c->len, buff + 36);
    buff[44] = '\n';
    buff[45] = '\0';
d1515 36
a1550 54
/* if file not modified */
    if (r->status == HTTP_NOT_MODIFIED) {
	if (c->ims != BAD_DATE && lmod != BAD_DATE && lmod <= c->ims) {
/* set any changed headers somehow */
/* update dates and version, but not content-length */
	    if (lmod != c->lmod || expc != c->expire || date != c->date) {
		off_t curpos = lseek(ap_bfileno(c->fp, B_WR), 0, SEEK_SET);
		if (curpos == -1)
		    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
				 "proxy: error seeking on cache file %s",
				 c->filename);
		else if (write(ap_bfileno(c->fp, B_WR), buff, 35) == -1)
		    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
				 "proxy: error updating cache file %s",
				 c->filename);
	    }
	    ap_pclosef(r->pool, ap_bfileno(c->fp, B_WR));
	    Explain0("Remote document not modified, use local copy");
	    /* CHECKME: Is this right? Shouldn't we check IMS again here? */
	    return HTTP_NOT_MODIFIED;
	}
	else {
/* return the whole document */
	    Explain0("Remote document updated, sending");
	    r->status_line = strchr(c->resp_line, ' ') + 1;
	    r->status = c->status;
	    if (!r->assbackwards) {
		ap_soft_timeout("proxy send headers", r);
		ap_proxy_send_headers(r, c->resp_line, c->hdrs);
		ap_kill_timeout(r);
	    }
	    ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
	    r->sent_bodyct = 1;
	    if (!r->header_only)
		ap_proxy_send_fb(c->fp, r, NULL);
/* set any changed headers somehow */
/* update dates and version, but not content-length */
	    if (lmod != c->lmod || expc != c->expire || date != c->date) {
		off_t curpos = lseek(ap_bfileno(c->fp, B_WR), 0, SEEK_SET);

		if (curpos == -1)
		    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
				 "proxy: error seeking on cache file %s",
				 c->filename);
		else if (write(ap_bfileno(c->fp, B_WR), buff, 35) == -1)
		    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
				 "proxy: error updating cache file %s",
				 c->filename);
	    }
	    ap_pclosef(r->pool, ap_bfileno(c->fp, B_WR));
	    return OK;
	}
    }
/* new or modified file */
d1552 1
a1552 1
	ap_pclosef(r->pool, ap_bfileno(c->fp, B_WR));
a1553 3
    c->version = 0;
    ap_proxy_sec2hex(0, buff + 27);
    buff[35] = ' ';
d1555 11
a1565 8
/* open temporary file */
#if !defined(TPF) && !defined(NETWARE)
#define TMPFILESTR	"/tmpXXXXXX"
    if (conf->cache.root == NULL)
	return DECLINED;
    c->tempfile = ap_palloc(r->pool, strlen(conf->cache.root) + sizeof(TMPFILESTR));
    strcpy(c->tempfile, conf->cache.root);
    strcat(c->tempfile, TMPFILESTR);
d1567 1
a1567 1
    p = mktemp(c->tempfile);
d1569 9
a1577 7
    if (conf->cache.root == NULL)
    return DECLINED;
    c->tempfile = ap_palloc(r->pool, strlen(conf->cache.root) +1+ L_tmpnam);
    strcpy(c->tempfile, conf->cache.root);
    strcat(c->tempfile, "/");
    p = tmpnam(NULL);
    strcat(c->tempfile, p);
d1579 44
a1622 2
    if (p == NULL)
	return DECLINED;
d1624 13
a1636 1
    Explain1("Create temporary file %s", c->tempfile);
a1637 17
    i = open(c->tempfile, O_WRONLY | O_CREAT | O_EXCL | O_BINARY, 0622);
    if (i == -1) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "proxy: error creating cache file %s",
		     c->tempfile);
	return DECLINED;
    }
    ap_note_cleanups_for_fd(r->pool, i);
    c->fp = ap_bcreate(r->pool, B_WR);
    ap_bpushfd(c->fp, -1, i);

    if (ap_bvputs(c->fp, buff, "X-URL: ", c->url, "\n", NULL) == -1) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "proxy: error writing cache file(%s)", c->tempfile);
	ap_pclosef(r->pool, ap_bfileno(c->fp, B_WR));
	unlink(c->tempfile);
	c->fp = NULL;
d1647 2
a1648 2
    if (c == NULL || c->fp == NULL)
	return;
d1659 5
a1663 5
	if (bc != c->len) {
	    ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR));	/* no need to flush */
	    unlink(c->tempfile);
	    return;
	}
d1667 3
a1669 3
	ap_pclosef(c->req->pool, c->fp->fd);	/ no need to flush /
	unlink(c->tempfile);
	return;
d1674 2
a1675 2
	char buff[9];
	off_t curpos;
d1677 10
a1686 10
	c->len = bc;
	ap_bflush(c->fp);
	ap_proxy_sec2hex(c->len, buff);
	curpos = lseek(ap_bfileno(c->fp, B_WR), 36, SEEK_SET);
	if (curpos == -1)
	    ap_log_error(APLOG_MARK, APLOG_ERR, s,
			 "proxy: error seeking on cache file %s", c->tempfile);
	else if (write(ap_bfileno(c->fp, B_WR), buff, 8) == -1)
	    ap_log_error(APLOG_MARK, APLOG_ERR, s,
			 "proxy: error updating cache file %s", c->tempfile);
d1690 6
a1695 6
	ap_log_error(APLOG_MARK, APLOG_ERR, s,
		     "proxy: error writing to cache file %s",
		     c->tempfile);
	ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR));
	unlink(c->tempfile);
	return;
d1699 4
a1702 4
	ap_log_error(APLOG_MARK, APLOG_ERR, s,
		     "proxy: error closing cache file %s", c->tempfile);
	unlink(c->tempfile);
	return;
d1706 3
a1708 3
	ap_log_error(APLOG_MARK, APLOG_ERR, s,
		     "proxy: error deleting old cache file %s",
		     c->tempfile);
d1711 9
a1719 9
	char *p;
	proxy_server_conf *conf =
	(proxy_server_conf *) ap_get_module_config(s->module_config, &proxy_module);

	for (p = c->filename + strlen(conf->cache.root) + 1;;) {
	    p = strchr(p, '/');
	    if (!p)
		break;
	    *p = '\0';
d1721 1
a1721 1
	    if (mkdir(c->filename) < 0 && errno != EEXIST)
d1723 1
a1723 1
	    if (mkdir(c->filename, S_IRWXU | S_IRWXG | S_IRWXO) < 0 && errno != EEXIST)
d1725 1
a1725 1
	    if (mkdir(c->filename, S_IREAD | S_IWRITE | S_IEXEC) < 0 && errno != EEXIST)
d1727 6
a1732 6
		ap_log_error(APLOG_MARK, APLOG_ERR, s,
			     "proxy: error creating cache directory %s",
			     c->filename);
	    *p = '/';
	    ++p;
	}
d1734 5
a1738 5
	/* Under OS/2 use rename. */
	if (rename(c->tempfile, c->filename) == -1)
	    ap_log_error(APLOG_MARK, APLOG_ERR, s,
			 "proxy: error renaming cache file %s to %s",
			 c->tempfile, c->filename);
d1742 4
a1745 4
	if (link(c->tempfile, c->filename) == -1)
	    ap_log_error(APLOG_MARK, APLOG_ERR, s,
			 "proxy: error linking cache file %s to %s",
			 c->tempfile, c->filename);
d1749 2
a1750 2
	ap_log_error(APLOG_MARK, APLOG_ERR, s,
		     "proxy: error deleting temp file %s", c->tempfile);
@


1.7
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1996-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 20
a38 23
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 7
a56 6
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
@


1.6
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d198 2
a199 2
    const struct gc_ent *a = (const struct gc_ent * const) ap;
    const struct gc_ent *b = (const struct gc_ent * const) bp;
d388 1
a388 1
	Explain3("GC Unlinking %s (expiry %ld, garbage_now %ld)", filename, fent->expire, garbage_now);
d502 13
a514 1
	fd = open(filename, O_RDONLY | O_BINARY);
d527 1
d533 4
a536 1
	    close(fd);
d556 13
d742 1
a742 1
	     pragma, auth, c->ims, imstr);
d979 1
a979 1
    Explain1("Expiry date is %ld", expc);
d990 1
a990 1
	Explain1("Expiry date calculated %ld", expc);
d1074 1
a1074 1
#ifndef TPF
d1209 1
a1209 1
#if defined(OS2) || defined(WIN32) || defined(NETWARE)
@


1.5
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d76 3
d129 1
a129 1
#if !defined(WIN32) && !defined(MPE) && !defined(OS2)
d149 1
a149 1
#if !defined(WIN32) && !defined(MPE) && !defined(OS2)
d209 1
a209 1
#if !defined(WIN32) && !defined(MPE) && !defined(OS2)
d471 3
a474 1
/* is it a directory? */
d476 8
d516 2
a517 2
/* In OS/2 this has already been done above */
#ifndef OS2
d744 1
a744 1
	    ap_pclosef(r->pool, cachefp->fd);
d770 1
a770 1
	    ap_pclosef(r->pool, cachefp->fd);
d788 1
a788 1
	ap_pclosef(r->pool, cachefp->fd);
d892 1
a892 1
	    ap_pclosef(r->pool, c->fp->fd);
d989 1
a989 1
		off_t curpos = lseek(c->fp->fd, 0, SEEK_SET);
d994 1
a994 1
		else if (write(c->fp->fd, buff, 35) == -1)
d999 1
a999 1
	    ap_pclosef(r->pool, c->fp->fd);
d1021 1
a1021 1
		off_t curpos = lseek(c->fp->fd, 0, SEEK_SET);
d1027 1
a1027 1
		else if (write(c->fp->fd, buff, 35) == -1)
d1032 1
a1032 1
	    ap_pclosef(r->pool, c->fp->fd);
d1038 1
a1038 2
	ap_pclosef(r->pool, c->fp->fd);
	c->fp->fd = -1;
d1045 1
d1054 9
d1082 1
a1082 1
	ap_pclosef(r->pool, c->fp->fd);
d1107 1
a1107 1
	    ap_pclosef(c->req->pool, c->fp->fd);	/* no need to flush */
d1127 1
a1127 1
	curpos = lseek(c->fp->fd, 36, SEEK_SET);
d1131 1
a1131 1
	else if (write(c->fp->fd, buff, 8) == -1)
d1140 1
a1140 1
	ap_pclosef(c->req->pool, c->fp->fd);
d1145 1
a1145 1
    if (ap_pclosef(c->req->pool, c->fp->fd) == -1) {
d1167 1
a1167 1
#ifdef WIN32
d1180 1
a1180 1
#if defined(OS2) || defined(WIN32)
@


1.4
log
@Pretty sure that the more restrictive umask used by mkstemp() makes the fchmod not neccessary
@
text
@d72 4
d109 1
a109 2
static time_t every, garbage_now, garbage_expire;
static char *filename;
d125 1
d145 1
d147 1
a147 1
    detached_proxy_garbage_coll(r);
d149 1
a149 1
    help_proxy_garbage_coll(r);
d213 4
d276 3
a278 1
static void help_proxy_garbage_coll(request_rec *r)
a279 1
    const char *cachedir;
d284 3
a286 1
    array_header *files;
d288 6
a293 3
    struct gc_ent *fent;
    int i, timefd;
    static time_t lastcheck = BAD_DATE;		/* static (per-process) data!!! */
d295 1
a295 5
    cachedir = conf->root;
    /* configured size is given in kB. Make it bytes, convert to long61_t: */
    cachesize.lower = cachesize.upper = 0;
    add_long61(&cachesize, conf->space << 10);
    every = conf->gcinterval;
a296 2
    if (cachedir == NULL || every == -1)
	return;
d304 1
a304 1
	return;
d306 2
a307 1
    ap_block_alarms();		/* avoid SIGALRM on big cache cleanup */
d309 23
a331 20
    filename = ap_palloc(r->pool, strlen(cachedir) + HASH_LEN + 2);
    strcpy(filename, cachedir);
    strcat(filename, "/.time");
    if (stat(filename, &buf) == -1) {	/* does not exist */
	if (errno != ENOENT) {
	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			 "proxy: stat(%s)", filename);
	    ap_unblock_alarms();
	    return;
	}
	if ((timefd = creat(filename, 0666)) == -1) {
	    if (errno != EEXIST)
		ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			     "proxy: creat(%s)", filename);
	    else
		lastcheck = garbage_now;	/* someone else got in there */
	    ap_unblock_alarms();
	    return;
	}
	close(timefd);
d334 7
a340 8
	lastcheck = buf.st_mtime;	/* save the time */
	if (garbage_now < lastcheck + every) {
	    ap_unblock_alarms();
	    return;
	}
	if (utime(filename, NULL) == -1)
	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			 "proxy: utimes(%s)", filename);
d342 24
d424 1
d427 1
d818 1
a818 1
#ifdef ULTRIX_BRAIN_DEATH
d867 1
a867 1
/* @@@@@@ XXX FIXME: is the test "r->status != HTTP_MOVED_PERMANENTLY" corerct?
d1040 7
a1046 1
    i = mkstemp(c->tempfile);
a1052 1

d1147 2
@


1.3
log
@use mkstemp; Peter.Galbavy@@knowledge.com
@
text
@a1008 1
    (void) fchmod(i, 0622);
@


1.2
log
@Apache 1.3.4 merge
@
text
@d1002 1
a1002 7
    p = mktemp(c->tempfile);
    if (p == NULL)
	return DECLINED;

    Explain1("Create temporary file %s", c->tempfile);

    i = open(c->tempfile, O_WRONLY | O_CREAT | O_EXCL | O_BINARY, 0622);
d1009 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1996,1997 The Apache Group.  All rights reserved.
d23 2
a24 1
 *    prior written permission.
d26 5
a30 1
 * 5. Redistributions of any form whatsoever must retain the following
a59 2
#include "md5.h"

d61 1
d65 3
d69 3
d73 1
a73 1
#define	abs(c)	((c) >= 0 ? (c) : -(c))
d75 1
a75 2
struct gc_ent
{
d78 74
a151 1
    char file[HASH_LEN+1];
a152 1
};
d154 35
a188 2
static int
gcdiff(const void *ap, const void *bp)
d190 2
a191 1
    const struct gc_ent *a=*(struct gc_ent **)ap, *b=*(struct gc_ent **)bp;
d193 6
a198 3
    if (a->expire > b->expire) return 1;
    else if (a->expire < b->expire) return -1;
    else return 0;
d201 51
a251 5
static int curbytes, cachesize, every;
static unsigned long int curblocks;
static time_t now, expire;
static char *filename;
static int filenamelen;
d253 13
a265 2
static int sub_garbage_coll(request_rec *r,array_header *files,
			    const char *cachedir,const char *cachesubdir);
d267 2
a268 2
void proxy_garbage_coll(request_rec *r)
    {
d272 2
a273 2
        (proxy_server_conf *)get_module_config(sconf, &proxy_module);
    const struct cache_conf *conf=&pconf->cache;
d276 1
a276 1
    struct gc_ent *fent,**elts;    
d278 1
a278 1
    static time_t lastcheck=BAD_DATE;  /* static data!!! */
d281 3
a283 1
    cachesize = conf->space;
d286 10
a295 5
    if (cachedir == NULL || every == -1) return;
    now = time(NULL);
    if (now != -1 && lastcheck != BAD_DATE && now < lastcheck + every) return;

    block_alarms();	/* avoid SIGALRM on big cache cleanup */
d297 1
a297 3
    filenamelen = strlen(cachedir) + HASH_LEN + 2;
    filename = palloc(r->pool, filenamelen);
    ap_snprintf(filename, filenamelen, "%s/.time", cachedir);
d299 8
a306 6
    if (stat(filename, &buf) == -1) /* does not exist */
    {
	if (errno != ENOENT)
	{
	    proxy_log_uerror("stat", filename, NULL, r->server);
	    unblock_alarms();
d309 1
a309 2
	if ((timefd = creat(filename, 0666)) == -1)
	{
d311 2
a312 1
		proxy_log_uerror("creat", filename, NULL, r->server);
d314 2
a315 2
		lastcheck = abs(now);  /* someone else got in there */
	    unblock_alarms();
d319 5
a323 6
    } else
    {
	lastcheck = buf.st_mtime;  /* save the time */
	if (now < lastcheck + every)
	{
	    unblock_alarms();
d327 2
a328 1
	    proxy_log_uerror("utimes", filename, NULL, r->server);
d330 2
a331 3
    files = make_array(r->pool, 100, sizeof(struct gc_ent *));
    curblocks = 0;
    curbytes = 0;
d333 1
a333 1
    sub_garbage_coll(r,files,cachedir,"/");
d335 5
a339 3
    if (curblocks < cachesize || curblocks + curbytes <= cachesize)
    {
	unblock_alarms();
d343 2
a344 1
    qsort(files->elts, files->nelts, sizeof(struct gc_ent *), gcdiff);
d346 4
a349 6
    elts = (struct gc_ent **)files->elts;
    for (i=0; i < files->nelts; i++)
    {
	fent = elts[i];
	ap_snprintf(filename, filenamelen, "%s%s", cachedir, fent->file);
	Explain3("GC Unlinking %s (expiry %ld, now %ld)",filename,fent->expire,now);
d351 1
a351 1
	fprintf(stderr,"Would unlink %s\n",filename);
d353 1
a353 2
	if (unlink(filename) == -1)
	{
d355 2
a356 1
		proxy_log_uerror("unlink", filename, NULL, r->server);
d361 2
a362 8
	    curblocks -= fent->len >> 10;
	    curbytes -= fent->len & 0x3FF;
	    if (curbytes < 0)
	    {
		curbytes += 1024;
		curblocks--;
	    }
	    if (curblocks < cachesize || curblocks + curbytes <= cachesize)
d366 5
a370 1
    unblock_alarms();
d373 2
a374 2
static int sub_garbage_coll(request_rec *r,array_header *files,
			     const char *cachebasedir,const char *cachesubdir)
d379 1
a379 1
    int fd,i;
d381 1
a381 1
#if defined(NEXT)
d387 1
a387 1
    int nfiles=0;
d389 2
a390 2
    ap_snprintf(cachedir, sizeof(cachedir), "%s%s",cachebasedir,cachesubdir);
    Explain1("GC Examining directory %s",cachedir);
d392 3
a394 3
    if (dir == NULL)
    {
	proxy_log_uerror("opendir", cachedir, NULL, r->server);
d398 5
a402 5
    while ((ent = readdir(dir)) != NULL)
    {
	if (ent->d_name[0] == '.') continue;
	ap_snprintf(filename, filenamelen, "%s%s", cachedir, ent->d_name);
	Explain1("GC Examining file %s",filename);
d404 1
a404 2
	if (strncmp(ent->d_name, "tmp", 3) == 0)
	{
d406 1
a406 2
	    if (stat(filename, &buf) == -1)
	    {
d408 8
a415 5
		    proxy_log_uerror("stat", filename, NULL, r->server);
	    } else if (now != -1 && buf.st_atime < now - SEC_ONE_DAY &&
		       buf.st_mtime < now - SEC_ONE_DAY)
		{
		Explain1("GC unlink %s",filename);
d417 1
a417 1
		fprintf(stderr,"Would unlink %s\n",filename);
d421 1
a421 1
		}
d427 22
a448 1
	/*	if (strlen(ent->d_name) != HASH_LEN) continue; */
d451 5
a455 5
	fd = open(filename, O_RDONLY);
	if (fd == -1)
	{
	    if (errno  != ENOENT) proxy_log_uerror("open", filename,NULL,
		r->server);
d458 3
a460 3
	if (fstat(fd, &buf) == -1)
	{
	    proxy_log_uerror("fstat", filename, NULL, r->server);
d464 4
a467 2
	if(S_ISDIR(buf.st_mode))
	    {
d471 4
a474 5
		"%s%s/",cachesubdir,ent->d_name);
	    if(!sub_garbage_coll(r,files,cachebasedir,newcachedir))
		{
		ap_snprintf(newcachedir, sizeof(newcachedir), 
			"%s%s",cachedir,ent->d_name);
d476 1
a476 1
		fprintf(stderr,"Would remove directory %s\n",newcachedir);
d481 4
a484 1
		}
d486 3
a488 2
	    }
	    
d490 4
a493 4
	if (i == -1)
	{
	    proxy_log_uerror("read", filename, NULL, r->server);
	    close(fd);
a495 1
	close(fd);
d497 3
a499 4
	expire = proxy_hex2sec(line+18);
	if (!checkmask(line, "&&&&&&&& &&&&&&&& &&&&&&&&") ||
	  expire == BAD_DATE)
	{
d501 4
a504 4
	    if (now != -1 && buf.st_atime > now + SEC_ONE_DAY &&
		buf.st_mtime > now + SEC_ONE_DAY)
	    {
		log_error("proxy: deleting bad cache file", r->server);
d506 1
a506 1
		fprintf(stderr,"Would unlink bad file %s\n",filename);
d520 1
a520 3
	/* FIXME: We should make the array an array of gc_ents, not gc_ent *s
	 */
	fent = palloc(r->pool, sizeof(struct gc_ent));
d522 3
a524 4
	fent->expire = expire;
	ap_snprintf(fent->file, sizeof(fent->file), "%s%s", cachesubdir,
	    ent->d_name);
	*(struct gc_ent **)push_array(files) = fent;
d527 1
a527 7
	curblocks += buf.st_size >> 10; /* Kbytes */
	curbytes += buf.st_size & 0x3FF;
	if (curbytes >= 1024)
	{
	    curbytes -= 1024;
	    curblocks++;
	}
d542 1
a542 2
static int
rdcache(pool *pool, BUFF *cachefp, struct cache_req *c)
d544 1
a544 1
    char urlbuff[1034], *p;
d551 6
a556 4
    len = bgets(urlbuff, 1034, cachefp);
    if (len == -1) return -1;
    if (len == 0 || urlbuff[len-1] != '\n') return 0;
    urlbuff[len-1] = '\0';
d558 2
a559 2
    if (!checkmask(urlbuff,
      "&&&&&&&& &&&&&&&& &&&&&&&& &&&&&&&& &&&&&&&&"))
d562 5
a566 5
    c->date = proxy_hex2sec(urlbuff);
    c->lmod = proxy_hex2sec(urlbuff+9);
    c->expire = proxy_hex2sec(urlbuff+18);
    c->version = proxy_hex2sec(urlbuff+27);
    c->len = proxy_hex2sec(urlbuff+36);
d569 3
a571 2
    len = bgets(urlbuff, 1034, cachefp);
    if (len == -1) return -1;
d573 4
a576 1
	urlbuff[len-1] != '\n')
a577 2
    urlbuff[len-1] = '\0';
    if (strcmp(urlbuff+7, c->url) != 0) return 0;
d580 5
a584 3
    len = bgets(urlbuff, 1034, cachefp);
    if (len == -1) return -1;
    if (len == 0 || urlbuff[len-1] != '\n') return 0;
d587 13
a599 16
    c->resp_line = pstrdup(pool, urlbuff);
    p = strchr(urlbuff, ' ');
    if (p == NULL) return 0;

    c->status = atoi(p);
    c->hdrs = proxy_read_headers(pool, urlbuff, 1034, cachefp);
    if (c->hdrs == NULL) return -1;
    if (c->len != -1) /* add a content-length header */
    {
	struct hdr_entry *q;
	q = proxy_get_header(c->hdrs, "Content-Length");
	if (q == NULL)
	{
	    p = palloc(pool, 15);
	    ap_snprintf(p, 15, "%u", c->len);
	    proxy_add_header(c->hdrs, "Content-Length", p, HDR_REP);
d620 2
a621 3
int
proxy_cache_check(request_rec *r, char *url, struct cache_conf *conf,
	     struct cache_req **cr)
d623 3
a625 2
    char hashfile[33], *imstr, *pragma, *p, *auth;
    struct cache_req *c;
d629 1
a629 1
    const long int zero=0L;
d632 1
a632 1
        (proxy_server_conf *)get_module_config(sconf, &proxy_module);
d634 1
a634 1
    c = pcalloc(r->pool, sizeof(struct cache_req));
d637 1
a637 1
    c->url = pstrdup(r->pool, url);
d641 2
a642 3
    imstr = table_get(r->headers_in, "If-Modified-Since");
    if (imstr != NULL)
    {
d644 4
a647 4
	imstr = proxy_date_canon(r->pool, imstr);
	c->ims = parseHTTPdate(imstr);
	if (c->ims == BAD_DATE)  /* bad or out of range date; remove it */
	    table_set(r->headers_in, "If-Modified-Since", NULL);
d651 1
a651 1
    proxy_hash(url, hashfile,pconf->cache.dirlevels,pconf->cache.dirlength);
d653 1
a653 1
	c->filename = pstrcat(r->pool, conf->root, "/", hashfile, NULL);
d659 4
a662 4
    pragma = table_get(r->headers_in, "Pragma");
    auth = table_get(r->headers_in, "Authorization");
    Explain5("Request for %s, pragma=%s, auth=%s, ims=%ld, imstr=%s",url,
      pragma,auth,c->ims,imstr);
d664 13
a676 13
	strlen(url) < 1024 && !proxy_liststr(pragma, "no-cache") &&
	    auth == NULL)
    {
        Explain1("Check file %s",c->filename);
	cfd = open(c->filename, O_RDWR);
	if (cfd != -1)
	{
	    note_cleanups_for_fd(r->pool, cfd);
	    cachefp = bcreate(r->pool, B_RD | B_WR);
	    bpushfd(cachefp, cfd, cfd);
	} else if (errno != ENOENT)
	    proxy_log_uerror("open", c->filename,
		"proxy: error opening cache file", r->server);
d679 1
a679 1
	    Explain1("File %s not found",c->filename);
d682 3
a684 4
    
    if (cachefp != NULL)
    {
	i = rdcache(r->pool, cachefp, c);
d686 3
a688 2
	    proxy_log_uerror("read", c->filename,
		"proxy: error reading cache file", r->server);
d690 4
a693 4
	    log_error("proxy: bad cache file", r->server);
	if (i != 1)
	{
	    pclosef(r->pool, cachefp->fd);
d697 2
d700 2
a701 1
	c->hdrs = make_array(r->pool, 2, sizeof(struct hdr_entry));
d705 2
a706 3
    if (cachefp != NULL && c->expire != BAD_DATE && now < c->expire)
    {
        Explain0("Unexpired data available");
d708 1
a708 2
	if (c->lmod != BAD_DATE && c->ims != BAD_DATE && c->ims >= c->lmod)
	{
d710 1
a710 2
	    if (c->date == BAD_DATE || c->date > c->ims)
	    {
d712 1
a712 1
 * 304 response
d714 4
a717 5
	    /* CHECKME: surely this was wrong? (Ben)
		p = table_get(r->headers_in, "Expires");
		*/
		p = table_get(c->hdrs, "Expires");
		if (p != NULL) 	table_set(r->headers_out, "Expires", p);
d719 1
a719 1
	    pclosef(r->pool, cachefp->fd);
d721 1
a721 1
	    return USE_LOCAL_COPY;
d729 3
a731 3
	    soft_timeout("proxy send headers", r);
	    proxy_send_headers(r->connection->client, c->resp_line,  c->hdrs);
	    kill_timeout(r);
d733 1
a733 1
	bsetopt(r->connection->client, BO_BYTECT, &zero);
d735 3
a737 2
	if (!r->header_only) proxy_send_fb (cachefp, r, NULL, NULL);
	pclosef(r->pool, cachefp->fd);
d745 1
a745 2
    if (cachefp != NULL && c->lmod != BAD_DATE && !r->header_only)
    {
d750 2
a751 3
	if (c->ims == BAD_DATE || c->ims < c->lmod)
	{
	    struct hdr_entry *q;
d753 3
a755 5
	    q = proxy_get_header(c->hdrs, "Last-Modified");

	    if (q != NULL && q->value != NULL)
		table_set(r->headers_in, "If-Modified-Since",
			  (char *)q->value);
d777 2
a778 3
int
proxy_cache_update(struct cache_req *c, array_header *resp_hdrs,
                   const int is_HTTP1, int nocache)
d780 4
a783 1
    request_rec *r=c->req;
d786 1
a786 1
    struct hdr_entry *expire, *dates, *lmods, *clen;
d791 2
a792 2
        (proxy_server_conf *)get_module_config(sconf, &proxy_module);
    const long int zero=0L;
d800 5
a804 3
    expire = proxy_get_header(resp_hdrs, "Expires");
    if (expire != NULL) expc = parseHTTPdate(expire->value);
    else expc = BAD_DATE;
d809 4
a812 6
    lmods = proxy_get_header(resp_hdrs, "Last-Modified");
    if (lmods != NULL)
    {
	lmod = parseHTTPdate(lmods->value);
	if (lmod == BAD_DATE)
	{
a813 1
	    lmods->value = NULL;
d816 2
a817 1
    } else
d823 2
a824 2
 * 304 response when we have no valid cache file, or
 * 200 response from HTTP/1.0 and up without a Last-Modified header, or
d829 3
a831 1
    if ((r->status != 200 && r->status != 301 && r->status != 304) ||
d833 2
a834 2
	(r->status == 304 && c->fp == NULL) ||
	(r->status == 200 && lmods == NULL && is_HTTP1) ||
d836 3
a838 4
	table_get(r->headers_in, "Authorization") != NULL ||
	nocache)
    {
	Explain1("Response is not cacheable, unlinking %s",c->filename);
d840 2
a841 3
	if (c->fp != NULL)
	{
	    pclosef(r->pool, c->fp->fd);
d845 3
a847 2
	unlink(c->filename);
	return DECLINED; /* send data to client but not cache */
d854 6
a859 4
    dates = proxy_get_header(resp_hdrs, "Date");
    if (dates != NULL) date = parseHTTPdate(dates->value);
    else date = BAD_DATE;
	
d862 1
a862 2
    if (date == BAD_DATE) /* No, or bad date */
    {
d866 3
a868 3
	date = abs(now);
	p = gm_timestr_822(r->pool, now);
	dates = proxy_add_header(resp_hdrs, "Date", p, HDR_REP);
d877 1
a877 1
	lmods->value = dates->value;
d881 1
a881 2
    if (lmod == BAD_DATE && c->fp != NULL)
	{
d884 1
a884 1
	}
d887 4
a890 4
    if (expire == NULL && c->fp != NULL)  /* no expiry data sent in response */
    {
	expire = proxy_get_header(c->hdrs, "Expires");
	if (expire != NULL) expc = parseHTTPdate(expire->value);
d899 12
a910 12
    Explain1("Expiry date is %ld",expc);
    if (expc == BAD_DATE)
    {
	if (lmod != BAD_DATE)
	{
	    double x = (double)(date - lmod)*conf->cache.lmfactor;
	    double maxex=conf->cache.maxexpire;
	    if (x > maxex) x = maxex;
	    expc = abs(now) + (int)x;
	} else
	    expc = abs(now) + conf->cache.defaultexpire;
	Explain1("Expiry date calculated %ld",expc);
d914 5
a918 3
    clen = proxy_get_header(c->hdrs, "Content-Length");
    if (clen == NULL) c->len = -1;
    else c->len = atoi(clen->value);
d920 1
a920 1
    proxy_sec2hex(date, buff);
d922 1
a922 1
    proxy_sec2hex(lmod, buff+9);
d924 1
a924 1
    proxy_sec2hex(expc, buff+18);
d926 1
a926 1
    proxy_sec2hex(c->version++, buff+27);
d928 1
a928 1
    proxy_sec2hex(c->len, buff+36);
d933 2
a934 4
    if (r->status == 304)
    {
	if (c->ims != BAD_DATE && lmod != BAD_DATE && lmod <= c->ims)
	{
d937 2
a938 3
	    if (lmod != c->lmod || expc != c->expire || date != c->date)
	    {
		off_t curpos=lseek(c->fp->fd, 0, SEEK_SET);
d940 3
a942 2
		    proxy_log_uerror("lseek", c->filename,
			       "proxy: error seeking on cache file",r->server);
d944 3
a946 2
		    proxy_log_uerror("write", c->filename,
			       "proxy: error updating cache file", r->server);
d948 1
a948 1
	    pclosef(r->pool, c->fp->fd);
d951 3
a953 3
	    return USE_LOCAL_COPY;
	} else
	{
d959 3
a961 4
		soft_timeout("proxy send headers", r);
		proxy_send_headers(r->connection->client, c->resp_line,
		    c->hdrs);
		kill_timeout(r);
d963 1
a963 1
	    bsetopt(r->connection->client, BO_BYTECT, &zero);
d965 2
a966 1
	    if (!r->header_only) proxy_send_fb (c->fp, r, NULL, NULL);
d969 2
a970 3
	    if (lmod != c->lmod || expc != c->expire || date != c->date)
	    {
		off_t curpos=lseek(c->fp->fd, 0, SEEK_SET);
d973 3
a975 2
		    proxy_log_uerror("lseek", c->filename,
			       "proxy: error seeking on cache file",r->server);
d977 3
a979 2
		    proxy_log_uerror("write", c->filename,
			       "proxy: error updating cache file", r->server);
d981 1
a981 1
	    pclosef(r->pool, c->fp->fd);
d985 3
a987 4
/* new or modified file */	    
    if (c->fp != NULL)
    {
	pclosef(r->pool, c->fp->fd);
d991 1
a991 1
    proxy_sec2hex(0, buff+27);
d997 4
a1000 4
        return DECLINED;
    c->tempfile=palloc(r->pool,strlen(conf->cache.root)+sizeof(TMPFILESTR));
    strcpy(c->tempfile,conf->cache.root);
    strcat(c->tempfile,TMPFILESTR);
d1004 1
a1004 1
        return DECLINED;
d1006 1
a1006 1
    Explain1("Create temporary file %s",c->tempfile);
d1008 5
a1012 5
    i = open(c->tempfile, O_WRONLY | O_CREAT | O_EXCL, 0622);
    if (i == -1)
    {
	proxy_log_uerror("open", c->tempfile,
	    "proxy: error creating cache file", r->server);
d1015 8
a1022 9
    note_cleanups_for_fd(r->pool, i);
    c->fp = bcreate(r->pool, B_WR);
    bpushfd(c->fp, -1, i);

    if (bvputs(c->fp, buff, "X-URL: ", c->url, "\n", NULL) == -1)
    {
	proxy_log_uerror("write", c->tempfile,
	    "proxy: error writing cache file", r->server);
	pclosef(r->pool, c->fp->fd);
d1029 1
a1029 2
void
proxy_cache_tidy(struct cache_req *c)
d1031 1
a1031 1
    server_rec *s=c->req->server;
d1034 2
a1035 1
    if (c->fp == NULL) return;
d1037 1
a1037 1
    bgetopt(c->req->connection->client, BO_BYTECT, &bc);
d1039 6
a1044 2
    if (c->len != -1)
    {
d1046 2
a1047 3
	if (bc != c->len)
	{
	    pclosef(c->req->pool, c->fp->fd);  /* no need to flush */
d1051 9
a1059 7
    } else
    if (c->req->connection->aborted) {
	    pclosef(c->req->pool, c->fp->fd);  /* no need to flush */
	    unlink(c->tempfile);
	    return;
    } else 
    {
d1065 2
a1066 2
	bflush(c->fp);
	proxy_sec2hex(c->len, buff);
d1069 2
a1070 2
	    proxy_log_uerror("lseek", c->tempfile,
		"proxy: error seeking on cache file", s);
d1072 2
a1073 2
	    proxy_log_uerror("write", c->tempfile,
		"proxy: error updating cache file", s);
d1076 5
a1080 5
    if (bflush(c->fp) == -1)
    {
	proxy_log_uerror("write", c->tempfile,
	    "proxy: error writing to cache file", s);
	pclosef(c->req->pool, c->fp->fd);
d1085 3
a1087 4
    if (pclosef(c->req->pool, c->fp->fd) == -1)
    {
	proxy_log_uerror("close", c->tempfile,
	    "proxy: error closing cache file", s);
d1092 6
a1097 6
    if (unlink(c->filename) == -1 && errno != ENOENT)
    {
	proxy_log_uerror("unlink", c->filename,
		   "proxy: error deleting old cache file", s);
    } else
	{
d1099 2
a1100 2
	proxy_server_conf *conf=
	  (proxy_server_conf *)get_module_config(s->module_config,&proxy_module);
d1102 3
a1104 4
	for(p=c->filename+strlen(conf->cache.root)+1 ; ; )
	    {
	    p=strchr(p,'/');
	    if(!p)
d1106 10
a1115 5
	    *p='\0';
	    if(mkdir(c->filename,S_IREAD|S_IWRITE|S_IEXEC) < 0 && errno != EEXIST)
		proxy_log_uerror("mkdir",c->filename,
		    "proxy: error creating cache directory",s);
	    *p='/';
d1117 9
a1125 8
	    }
#ifdef __EMX__
        /* Under OS/2 use rename. */            
        if (rename(c->tempfile, c->filename) == -1)
            proxy_log_uerror("rename", c->filename,
		"proxy: error renaming cache file", s);
}
#else            
d1128 4
a1131 3
	    proxy_log_uerror("link", c->filename,
		"proxy: error linking cache file", s);
	}
d1134 2
a1135 2
	proxy_log_uerror("unlink", c->tempfile,
	    "proxy: error deleting temp file",s);
a1138 1

@


1.1.1.1
log
@Initial import from apache 1.2.6
@
text
@@


1.1.1.2
log
@Apache 1.3.2
@
text
@d2 1
a2 1
 * Copyright (c) 1996-1998 The Apache Group.  All rights reserved.
d23 1
a23 2
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
d25 1
a25 5
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
d55 2
a60 3
#ifdef WIN32
#include <sys/utime.h>
#else
a61 3
#endif /* WIN32 */
#include "multithread.h"
#include "ap_md5.h"
d63 1
a63 1
DEF_Explain
d65 2
a66 1
struct gc_ent {
d69 2
a70 1
    char file[HASH_LEN + 1];
d73 2
a74 30
/* Poor man's 61 bit arithmetic */
typedef struct {
    long lower;	/* lower 30 bits of result */
    long upper; /* upper 31 bits of result */
} long61_t;

/* FIXME: The block size can be different on a `per file system' base.
 * This would make automatic detection highly OS specific.
 * In the GNU fileutils code for du(1), you can see how complicated it can
 * become to detect the block size. And, with BSD-4.x fragments, it
 * it even more difficult to get precise results.
 * As a compromise (and to improve on the incorrect counting of cache
 * size on byte level, omitting directory sizes entirely, which was
 * used up to apache-1.3b7) we're rounding to multiples of 512 here.
 * Your file system may be using larger blocks (I certainly hope so!)
 * but it will hardly use smaller blocks.
 * (So this approximation is still closer to reality than the old behavior).
 * The best solution would be automatic detection, the next best solution
 * IMHO is a sensible default and the possibility to override it.
 */

#define ROUNDUP2BLOCKS(_bytes) (((_bytes)+block_size-1) & ~(block_size-1))
static long block_size = 512;	/* this must be a power of 2 */
static long61_t curbytes, cachesize;
static time_t every, garbage_now, garbage_expire;
static char *filename;
static mutex *garbage_mutex = NULL;


int ap_proxy_garbage_init(server_rec *r, pool *p)
d76 1
a76 2
    if (!garbage_mutex)
	garbage_mutex = ap_create_mutex(NULL);
d78 3
a80 1
    return (0);
d83 5
d89 2
a90 6
static int sub_garbage_coll(request_rec *r, array_header *files,
			    const char *cachedir, const char *cachesubdir);
static void help_proxy_garbage_coll(request_rec *r);
#if !defined(WIN32) && !defined(MPE) && !defined(OS2)
static void detached_proxy_garbage_coll(request_rec *r);
#endif
d92 2
a93 140

void ap_proxy_garbage_coll(request_rec *r)
{
    static int inside = 0;

    (void) ap_acquire_mutex(garbage_mutex);
    if (inside == 1) {
	(void) ap_release_mutex(garbage_mutex);
	return;
    }
    else
	inside = 1;
    (void) ap_release_mutex(garbage_mutex);

    ap_block_alarms();		/* avoid SIGALRM on big cache cleanup */
#if !defined(WIN32) && !defined(MPE) && !defined(OS2)
    detached_proxy_garbage_coll(r);
#else
    help_proxy_garbage_coll(r);
#endif
    ap_unblock_alarms();

    (void) ap_acquire_mutex(garbage_mutex);
    inside = 0;
    (void) ap_release_mutex(garbage_mutex);
}


static void
add_long61 (long61_t *accu, long val)
{
    /* Add in lower 30 bits */
    accu->lower += (val & 0x3FFFFFFFL);
    /* add in upper bits, and carry */
    accu->upper += (val >> 30) + ((accu->lower & ~0x3FFFFFFFL) != 0L);
    /* Clear carry */
    accu->lower &= 0x3FFFFFFFL;
}

static void
sub_long61 (long61_t *accu, long val)
{
    int carry = (val & 0x3FFFFFFFL) > accu->lower;
    /* Subtract lower 30 bits */
    accu->lower = accu->lower - (val & 0x3FFFFFFFL) + ((carry) ? 0x40000000 : 0);
    /* add in upper bits, and carry */
    accu->upper -= (val >> 30) + carry;
}

/* Compare two long61's:
 * return <0 when left < right
 * return  0 when left == right
 * return >0 when left > right
 */
static long
cmp_long61 (long61_t *left, long61_t *right)
{
    return (left->upper == right->upper) ? (left->lower - right->lower)
					 : (left->upper - right->upper);
}

/* Compare two gc_ent's, sort them by expiration date */
static int gcdiff(const void *ap, const void *bp)
{
    const struct gc_ent *a = (const struct gc_ent * const) ap;
    const struct gc_ent *b = (const struct gc_ent * const) bp;

    if (a->expire > b->expire)
	return 1;
    else if (a->expire < b->expire)
	return -1;
    else
	return 0;
}

#if !defined(WIN32) && !defined(MPE) && !defined(OS2)
static void detached_proxy_garbage_coll(request_rec *r)
{
    pid_t pid;
    int status;
    pid_t pgrp;

    switch (pid = fork()) {
	case -1:
	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			 "proxy: fork() for cache cleanup failed");
	    return;

	case 0:	/* Child */

	    /* close all sorts of things, including the socket fd */
	    ap_cleanup_for_exec();

	    /* Fork twice to disassociate from the child */
	    switch (pid = fork()) {
		case -1:
		    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			 "proxy: fork(2nd) for cache cleanup failed");
		    exit(1);

		case 0:	/* Child */
		    /* The setpgrp() stuff was snarfed from http_main.c */
#ifndef NO_SETSID
		    if ((pgrp = setsid()) == -1) {
			perror("setsid");
			fprintf(stderr, "httpd: setsid failed\n");
			exit(1);
		    }
#elif defined(NEXT) || defined(NEWSOS)
		    if (setpgrp(0, getpid()) == -1 || (pgrp = getpgrp(0)) == -1) {
			perror("setpgrp");
			fprintf(stderr, "httpd: setpgrp or getpgrp failed\n");
			exit(1);
		    }
#else
		    if ((pgrp = setpgrp(getpid(), 0)) == -1) {
			perror("setpgrp");
			fprintf(stderr, "httpd: setpgrp failed\n");
			exit(1);
		    }
#endif
		    help_proxy_garbage_coll(r);
		    exit(0);

		default:    /* Father */
		    /* After grandson has been forked off, */
		    /* there's nothing else to do. */
		    exit(0);		    
	    }
	default:
	    /* Wait until grandson has been forked off */
	    /* (without wait we'd leave a zombie) */
	    waitpid(pid, &status, 0);
	    return;
    }
}
#endif /* ndef WIN32 */

static void help_proxy_garbage_coll(request_rec *r)
{
d97 2
a98 2
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
    const struct cache_conf *conf = &pconf->cache;
d101 1
a101 1
    struct gc_ent *fent;
d103 1
a103 1
    static time_t lastcheck = BAD_DATE;		/* static (per-process) data!!! */
d106 1
a106 3
    /* configured size is given in kB. Make it bytes, convert to long61_t: */
    cachesize.lower = cachesize.upper = 0;
    add_long61(&cachesize, conf->space << 10);
d109 5
a113 10
    if (cachedir == NULL || every == -1)
	return;
    garbage_now = time(NULL);
    /* Usually, the modification time of <cachedir>/.time can only increase.
     * Thus, even with several child processes having their own copy of
     * lastcheck, if time(NULL) still < lastcheck then it's not time
     * for GC yet.
     */
    if (garbage_now != -1 && lastcheck != BAD_DATE && garbage_now < lastcheck + every)
	return;
d115 3
a117 1
    ap_block_alarms();		/* avoid SIGALRM on big cache cleanup */
d119 6
a124 8
    filename = ap_palloc(r->pool, strlen(cachedir) + HASH_LEN + 2);
    strcpy(filename, cachedir);
    strcat(filename, "/.time");
    if (stat(filename, &buf) == -1) {	/* does not exist */
	if (errno != ENOENT) {
	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			 "proxy: stat(%s)", filename);
	    ap_unblock_alarms();
d127 2
a128 1
	if ((timefd = creat(filename, 0666)) == -1) {
d130 1
a130 2
		ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			     "proxy: creat(%s)", filename);
d132 2
a133 2
		lastcheck = garbage_now;	/* someone else got in there */
	    ap_unblock_alarms();
d137 6
a142 5
    }
    else {
	lastcheck = buf.st_mtime;	/* save the time */
	if (garbage_now < lastcheck + every) {
	    ap_unblock_alarms();
d146 1
a146 2
	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			 "proxy: utimes(%s)", filename);
d148 3
a150 2
    files = ap_make_array(r->pool, 100, sizeof(struct gc_ent));
    curbytes.upper = curbytes.lower = 0L;
d152 1
a152 1
    sub_garbage_coll(r, files, cachedir, "/");
d154 3
a156 5
    if (cmp_long61(&curbytes, &cachesize) < 0L) {
	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server,
			 "proxy GC: Cache is %ld%% full (nothing deleted)",
			 (long)(((curbytes.upper<<20)|(curbytes.lower>>10))*100/conf->space));
	ap_unblock_alarms();
d160 1
a160 2
    /* sort the files we found by expiration date */
    qsort(files->elts, files->nelts, sizeof(struct gc_ent), gcdiff);
d162 6
a167 4
    for (i = 0; i < files->nelts; i++) {
	fent = &((struct gc_ent *) files->elts)[i];
	sprintf(filename, "%s%s", cachedir, fent->file);
	Explain3("GC Unlinking %s (expiry %ld, garbage_now %ld)", filename, fent->expire, garbage_now);
d169 1
a169 1
	fprintf(stderr, "Would unlink %s\n", filename);
d171 2
a172 1
	if (unlink(filename) == -1) {
d174 1
a174 2
		ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			     "proxy gc: unlink(%s)", filename);
d179 8
a186 2
	    sub_long61(&curbytes, ROUNDUP2BLOCKS(fent->len));
	    if (cmp_long61(&curbytes, &cachesize) < 0)
d190 1
a190 5

    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server,
			 "proxy GC: Cache is %ld%% full (%d deleted)",
			 (long)(((curbytes.upper<<20)|(curbytes.lower>>10))*100/conf->space), i);
    ap_unblock_alarms();
d193 2
a194 2
static int sub_garbage_coll(request_rec *r, array_header *files,
			  const char *cachebasedir, const char *cachesubdir)
d199 1
a199 1
    int fd, i;
d201 1
a201 1
#if defined(NEXT) || defined(WIN32)
d207 1
a207 1
    int nfiles = 0;
d209 2
a210 2
    ap_snprintf(cachedir, sizeof(cachedir), "%s%s", cachebasedir, cachesubdir);
    Explain1("GC Examining directory %s", cachedir);
d212 3
a214 3
    if (dir == NULL) {
	ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
		     "proxy gc: opendir(%s)", cachedir);
d218 5
a222 5
    while ((ent = readdir(dir)) != NULL) {
	if (ent->d_name[0] == '.')
	    continue;
	sprintf(filename, "%s%s", cachedir, ent->d_name);
	Explain1("GC Examining file %s", filename);
d224 2
a225 1
	if (strncmp(ent->d_name, "tmp", 3) == 0) {
d227 2
a228 1
	    if (stat(filename, &buf) == -1) {
d230 5
a234 8
		    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
				 "proxy gc: stat(%s)", filename);
	    }
	    else if (garbage_now != -1 && buf.st_atime < garbage_now - SEC_ONE_DAY &&
		     buf.st_mtime < garbage_now - SEC_ONE_DAY) {
		Explain1("GC unlink %s", filename);
		ap_log_error(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, r->server,
			     "proxy gc: deleting orphaned cache file %s", filename);
d236 1
a236 1
		fprintf(stderr, "Would unlink %s\n", filename);
d240 1
a240 1
	    }
d246 1
a246 22
	/*      if (strlen(ent->d_name) != HASH_LEN) continue; */

/* under OS/2 use dirent's d_attr to identify a diretory */
#ifdef OS2
/* is it a directory? */
	if (ent->d_attr & A_DIR) {
	    char newcachedir[HUGE_STRING_LEN];
	    ap_snprintf(newcachedir, sizeof(newcachedir),
			"%s%s/", cachesubdir, ent->d_name);
	    if (!sub_garbage_coll(r, files, cachebasedir, newcachedir)) {
		ap_snprintf(newcachedir, sizeof(newcachedir),
			    "%s%s", cachedir, ent->d_name);
#if TESTING
		fprintf(stderr, "Would remove directory %s\n", newcachedir);
#else
		rmdir(newcachedir);
#endif
		--nfiles;
	    }
	    continue;
	}
#endif
d249 5
a253 5
	fd = open(filename, O_RDONLY | O_BINARY);
	if (fd == -1) {
	    if (errno != ENOENT)
		ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			     "proxy gc: open(%s)", filename);
d256 3
a258 3
	if (fstat(fd, &buf) == -1) {
	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			 "proxy gc: fstat(%s)", filename);
d262 2
a263 4

/* In OS/2 this has already been done above */
#ifndef OS2
	if (S_ISDIR(buf.st_mode)) {
d267 5
a271 4
			"%s%s/", cachesubdir, ent->d_name);
	    if (!sub_garbage_coll(r, files, cachebasedir, newcachedir)) {
		ap_snprintf(newcachedir, sizeof(newcachedir),
			    "%s%s", cachedir, ent->d_name);
d273 1
a273 1
		fprintf(stderr, "Would remove directory %s\n", newcachedir);
d278 2
a279 3
	    } else {
		/* Directory is not empty. Account for its size: */
		add_long61(&curbytes, ROUNDUP2BLOCKS(buf.st_size));
d281 6
a288 3
#endif

	i = read(fd, line, 26);
a289 5
	if (i == -1) {
	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
			 "proxy gc: read(%s)", filename);
	    continue;
	}
d291 4
a294 3
	garbage_expire = ap_proxy_hex2sec(line + 18);
	if (!ap_checkmask(line, "&&&&&&&& &&&&&&&& &&&&&&&&") ||
	    garbage_expire == BAD_DATE) {
d296 4
a299 4
	    if (garbage_now != -1 && buf.st_atime > garbage_now + SEC_ONE_DAY &&
		buf.st_mtime > garbage_now + SEC_ONE_DAY) {
		ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, r->server,
			     "proxy: deleting bad cache file with future date: %s", filename);
d301 1
a301 1
		fprintf(stderr, "Would unlink bad file %s\n", filename);
d315 3
a317 1
	fent = (struct gc_ent *) ap_push_array(files);
d319 4
a322 3
	fent->expire = garbage_expire;
	strcpy(fent->file, cachesubdir);
	strcat(fent->file, ent->d_name);
d325 7
a331 1
	add_long61(&curbytes, ROUNDUP2BLOCKS(buf.st_size));
d346 2
a347 1
static int rdcache(request_rec *r, BUFF *cachefp, cache_req *c)
d349 1
a349 1
    char urlbuff[1034], *strp;
d356 4
a359 6
    len = ap_bgets(urlbuff, sizeof urlbuff, cachefp);
    if (len == -1)
	return -1;
    if (len == 0 || urlbuff[len - 1] != '\n')
	return 0;
    urlbuff[len - 1] = '\0';
d361 2
a362 2
    if (!ap_checkmask(urlbuff,
		   "&&&&&&&& &&&&&&&& &&&&&&&& &&&&&&&& &&&&&&&&"))
d365 5
a369 5
    c->date = ap_proxy_hex2sec(urlbuff);
    c->lmod = ap_proxy_hex2sec(urlbuff + 9);
    c->expire = ap_proxy_hex2sec(urlbuff + 18);
    c->version = ap_proxy_hex2sec(urlbuff + 27);
    c->len = ap_proxy_hex2sec(urlbuff + 36);
d372 2
a373 3
    len = ap_bgets(urlbuff, sizeof urlbuff, cachefp);
    if (len == -1)
	return -1;
d375 1
a375 4
	urlbuff[len - 1] != '\n')
	return 0;
    urlbuff[len - 1] = '\0';
    if (strcmp(urlbuff + 7, c->url) != 0)
d377 2
d381 3
a383 5
    len = ap_bgets(urlbuff, sizeof urlbuff, cachefp);
    if (len == -1)
	return -1;
    if (len == 0 || urlbuff[len - 1] != '\n')
	return 0;
d386 16
a401 13
    c->resp_line = ap_pstrdup(r->pool, urlbuff);
    strp = strchr(urlbuff, ' ');
    if (strp == NULL)
	return 0;

    c->status = atoi(strp);
    c->hdrs = ap_proxy_read_headers(r, urlbuff, sizeof urlbuff, cachefp);
    if (c->hdrs == NULL)
	return -1;
    if (c->len != -1) {		/* add a content-length header */
	if (ap_table_get(c->hdrs, "Content-Length") == NULL) {
	    ap_table_set(c->hdrs, "Content-Length",
			 ap_psprintf(r->pool, "%lu", (unsigned long)c->len));
d422 3
a424 2
int ap_proxy_cache_check(request_rec *r, char *url, struct cache_conf *conf,
		      cache_req **cr)
d426 2
a427 3
    char hashfile[66];
    const char *imstr, *pragma, *auth;
    cache_req *c;
d431 1
a431 1
    const long int zero = 0L;
d434 1
a434 1
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
d436 1
a436 1
    c = ap_pcalloc(r->pool, sizeof(cache_req));
d439 1
a439 1
    c->url = ap_pstrdup(r->pool, url);
d443 3
a445 2
    imstr = ap_table_get(r->headers_in, "If-Modified-Since");
    if (imstr != NULL) {
d447 4
a450 4
	imstr = ap_proxy_date_canon(r->pool, imstr);
	c->ims = ap_parseHTTPdate(imstr);
	if (c->ims == BAD_DATE)	/* bad or out of range date; remove it */
	    ap_table_unset(r->headers_in, "If-Modified-Since");
d454 1
a454 1
    ap_proxy_hash(url, hashfile, pconf->cache.dirlevels, pconf->cache.dirlength);
d456 1
a456 1
	c->filename = ap_pstrcat(r->pool, conf->root, "/", hashfile, NULL);
d462 4
a465 4
    pragma = ap_table_get(r->headers_in, "Pragma");
    auth = ap_table_get(r->headers_in, "Authorization");
    Explain5("Request for %s, pragma=%s, auth=%s, ims=%ld, imstr=%s", url,
	     pragma, auth, c->ims, imstr);
d467 13
a479 13
	strlen(url) < 1024 && !ap_proxy_liststr(pragma, "no-cache") &&
	auth == NULL) {
	Explain1("Check file %s", c->filename);
	cfd = open(c->filename, O_RDWR | O_BINARY);
	if (cfd != -1) {
	    ap_note_cleanups_for_fd(r->pool, cfd);
	    cachefp = ap_bcreate(r->pool, B_RD | B_WR);
	    ap_bpushfd(cachefp, cfd, cfd);
	}
	else if (errno != ENOENT)
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "proxy: error opening cache file %s",
			 c->filename);
d482 1
a482 1
	    Explain1("File %s not found", c->filename);
d485 4
a488 3

    if (cachefp != NULL) {
	i = rdcache(r, cachefp, c);
d490 2
a491 3
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "proxy: error reading cache file %s", 
			 c->filename);
d493 4
a496 4
	    ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
			 "proxy: bad (short?) cache file: %s", c->filename);
	if (i != 1) {
	    ap_pclosef(r->pool, cachefp->fd);
a499 2
/* fixed?  in this case, we want to get the headers from the remote server
   it will be handled later if we don't do this (I hope ;-)
d501 1
a501 2
	c->hdrs = ap_make_table(r->pool, 20);
*/
d505 3
a507 2
    if (cachefp != NULL && c->expire != BAD_DATE && now < c->expire) {
	Explain0("Unexpired data available");
d509 2
a510 1
	if (c->lmod != BAD_DATE && c->ims != BAD_DATE && c->ims >= c->lmod) {
d512 2
a513 1
	    if (c->date == BAD_DATE || c->date > c->ims) {
d515 1
a515 1
 * 304 HTTP_NOT_MODIFIED response
d517 5
a521 4
		const char *q;

		if ((q = ap_table_get(c->hdrs, "Expires")) != NULL)
		    ap_table_set(r->headers_out, "Expires", q);
d523 1
a523 1
	    ap_pclosef(r->pool, cachefp->fd);
d525 1
a525 1
	    return HTTP_NOT_MODIFIED;
d533 3
a535 3
	    ap_soft_timeout("proxy send headers", r);
	    ap_proxy_send_headers(r, c->resp_line, c->hdrs);
	    ap_kill_timeout(r);
d537 1
a537 1
	ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
d539 2
a540 3
	if (!r->header_only)
	    ap_proxy_send_fb(cachefp, r, NULL);
	ap_pclosef(r->pool, cachefp->fd);
d548 2
a549 1
    if (cachefp != NULL && c->lmod != BAD_DATE && !r->header_only) {
d554 3
a556 2
	if (c->ims == BAD_DATE || c->ims < c->lmod) {
	    const char *q;
d558 5
a562 3
	    if ((q = ap_table_get(c->hdrs, "Last-Modified")) != NULL)
		ap_table_set(r->headers_in, "If-Modified-Since",
			  (char *) q);
d584 3
a586 2
int ap_proxy_cache_update(cache_req *c, table *resp_hdrs,
		       const int is_HTTP1, int nocache)
d588 1
a588 4
#ifdef ULTRIX_BRAIN_DEATH
  extern char *mktemp(char *template);
#endif 
    request_rec *r = c->req;
d591 1
a591 1
    const char *expire, *lmods, *dates, *clen;
d596 2
a597 2
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
    const long int zero = 0L;
d605 3
a607 5
    expire = ap_table_get(resp_hdrs, "Expires");
    if (expire != NULL)
	expc = ap_parseHTTPdate(expire);
    else
	expc = BAD_DATE;
d612 6
a617 4
    lmods = ap_table_get(resp_hdrs, "Last-Modified");
    if (lmods != NULL) {
	lmod = ap_parseHTTPdate(lmods);
	if (lmod == BAD_DATE) {
d619 1
d622 1
a622 2
    }
    else
d628 2
a629 2
 * 304 HTTP_NOT_MODIFIED response when we have no valid cache file, or
 * 200 HTTP_OK response from HTTP/1.0 and up without a Last-Modified header, or
d634 1
a634 3
/* @@@@@@ XXX FIXME: is the test "r->status != HTTP_MOVED_PERMANENTLY" corerct?
 * or shouldn't it be "ap_is_HTTP_REDIRECT(r->status)" ? -MnKr */
    if ((r->status != HTTP_OK && r->status != HTTP_MOVED_PERMANENTLY && r->status != HTTP_NOT_MODIFIED) ||
d636 2
a637 2
	(r->status == HTTP_NOT_MODIFIED && (c == NULL || c->fp == NULL)) ||
	(r->status == HTTP_OK && lmods == NULL && is_HTTP1) ||
d639 4
a642 3
	ap_table_get(r->headers_in, "Authorization") != NULL ||
	nocache) {
	Explain1("Response is not cacheable, unlinking %s", c->filename);
d644 3
a646 2
	if (c->fp != NULL) {
	    ap_pclosef(r->pool, c->fp->fd);
d650 2
a651 3
        if (c->filename)
            unlink(c->filename);
	return DECLINED;	/* send data to client but not cache */
d658 4
a661 6
    dates = ap_table_get(resp_hdrs, "Date");
    if (dates != NULL)
	date = ap_parseHTTPdate(dates);
    else
	date = BAD_DATE;

d664 2
a665 1
    if (date == BAD_DATE) {	/* No, or bad date */
d669 3
a671 3
	date = now;
	dates = ap_gm_timestr_822(r->pool, now);
	ap_table_set(resp_hdrs, "Date", dates);
d680 1
a680 1
	lmods = dates;
d684 2
a685 1
    if (lmod == BAD_DATE && c->fp != NULL) {
d688 1
a688 1
    }
d691 4
a694 4
    if (expire == NULL && c->fp != NULL) {	/* no expiry data sent in response */
	expire = ap_table_get(c->hdrs, "Expires");
	if (expire != NULL)
	    expc = ap_parseHTTPdate(expire);
d703 12
a714 12
    Explain1("Expiry date is %ld", expc);
    if (expc == BAD_DATE) {
	if (lmod != BAD_DATE) {
	    double x = (double) (date - lmod) * conf->cache.lmfactor;
	    double maxex = conf->cache.maxexpire;
	    if (x > maxex)
		x = maxex;
	    expc = now + (int) x;
	}
	else
	    expc = now + conf->cache.defaultexpire;
	Explain1("Expiry date calculated %ld", expc);
d718 3
a720 5
    clen = ap_table_get(resp_hdrs, "Content-Length");
    if (clen == NULL)
	c->len = -1;
    else
	c->len = atoi(clen);
d722 1
a722 1
    ap_proxy_sec2hex(date, buff);
d724 1
a724 1
    ap_proxy_sec2hex(lmod, buff + 9);
d726 1
a726 1
    ap_proxy_sec2hex(expc, buff + 18);
d728 1
a728 1
    ap_proxy_sec2hex(c->version++, buff + 27);
d730 1
a730 1
    ap_proxy_sec2hex(c->len, buff + 36);
d735 4
a738 2
    if (r->status == HTTP_NOT_MODIFIED) {
	if (c->ims != BAD_DATE && lmod != BAD_DATE && lmod <= c->ims) {
d741 3
a743 2
	    if (lmod != c->lmod || expc != c->expire || date != c->date) {
		off_t curpos = lseek(c->fp->fd, 0, SEEK_SET);
d745 2
a746 3
		    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
				 "proxy: error seeking on cache file %s",
				 c->filename);
d748 2
a749 3
		    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
				 "proxy: error updating cache file %s",
				 c->filename);
d751 1
a751 1
	    ap_pclosef(r->pool, c->fp->fd);
d754 3
a756 3
	    return HTTP_NOT_MODIFIED;
	}
	else {
d762 4
a765 3
		ap_soft_timeout("proxy send headers", r);
		ap_proxy_send_headers(r, c->resp_line, c->hdrs);
		ap_kill_timeout(r);
d767 1
a767 1
	    ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
d769 1
a769 2
	    if (!r->header_only)
		ap_proxy_send_fb(c->fp, r, NULL);
d772 3
a774 2
	    if (lmod != c->lmod || expc != c->expire || date != c->date) {
		off_t curpos = lseek(c->fp->fd, 0, SEEK_SET);
d777 2
a778 3
		    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
				 "proxy: error seeking on cache file %s",
				 c->filename);
d780 2
a781 3
		    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
				 "proxy: error updating cache file %s",
				 c->filename);
d783 1
a783 1
	    ap_pclosef(r->pool, c->fp->fd);
d787 4
a790 3
/* new or modified file */
    if (c->fp != NULL) {
	ap_pclosef(r->pool, c->fp->fd);
d794 1
a794 1
    ap_proxy_sec2hex(0, buff + 27);
d800 4
a803 4
	return DECLINED;
    c->tempfile = ap_palloc(r->pool, strlen(conf->cache.root) + sizeof(TMPFILESTR));
    strcpy(c->tempfile, conf->cache.root);
    strcat(c->tempfile, TMPFILESTR);
d807 1
a807 1
	return DECLINED;
d809 1
a809 1
    Explain1("Create temporary file %s", c->tempfile);
d811 5
a815 5
    i = open(c->tempfile, O_WRONLY | O_CREAT | O_EXCL | O_BINARY, 0622);
    if (i == -1) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "proxy: error creating cache file %s",
		     c->tempfile);
d818 9
a826 8
    ap_note_cleanups_for_fd(r->pool, i);
    c->fp = ap_bcreate(r->pool, B_WR);
    ap_bpushfd(c->fp, -1, i);

    if (ap_bvputs(c->fp, buff, "X-URL: ", c->url, "\n", NULL) == -1) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "proxy: error writing cache file(%s)", c->tempfile);
	ap_pclosef(r->pool, c->fp->fd);
d833 2
a834 1
void ap_proxy_cache_tidy(cache_req *c)
d836 1
a836 1
    server_rec *s;
d839 1
a839 2
    if (c == NULL || c->fp == NULL)
	return;
d841 1
a841 1
    s = c->req->server;
d843 2
a844 6
/* don't care how much was sent, but rather how much was written to cache
    ap_bgetopt(c->req->connection->client, BO_BYTECT, &bc);
 */
    bc = c->written;

    if (c->len != -1) {
d846 3
a848 2
	if (bc != c->len) {
	    ap_pclosef(c->req->pool, c->fp->fd);	/* no need to flush */
d852 7
a858 9
    }
/* don't care if aborted, cache it if fully retrieved from host!
    else if (c->req->connection->aborted) {
	ap_pclosef(c->req->pool, c->fp->fd);	/ no need to flush /
	unlink(c->tempfile);
	return;
    }
*/
    else {
d864 2
a865 2
	ap_bflush(c->fp);
	ap_proxy_sec2hex(c->len, buff);
d868 2
a869 2
	    ap_log_error(APLOG_MARK, APLOG_ERR, s,
			 "proxy: error seeking on cache file %s", c->tempfile);
d871 2
a872 2
	    ap_log_error(APLOG_MARK, APLOG_ERR, s,
			 "proxy: error updating cache file %s", c->tempfile);
d875 5
a879 5
    if (ap_bflush(c->fp) == -1) {
	ap_log_error(APLOG_MARK, APLOG_ERR, s,
		     "proxy: error writing to cache file %s",
		     c->tempfile);
	ap_pclosef(c->req->pool, c->fp->fd);
d884 4
a887 3
    if (ap_pclosef(c->req->pool, c->fp->fd) == -1) {
	ap_log_error(APLOG_MARK, APLOG_ERR, s,
		     "proxy: error closing cache file %s", c->tempfile);
d892 6
a897 6
    if (unlink(c->filename) == -1 && errno != ENOENT) {
	ap_log_error(APLOG_MARK, APLOG_ERR, s,
		     "proxy: error deleting old cache file %s",
		     c->tempfile);
    }
    else {
d899 2
a900 2
	proxy_server_conf *conf =
	(proxy_server_conf *) ap_get_module_config(s->module_config, &proxy_module);
d902 4
a905 3
	for (p = c->filename + strlen(conf->cache.root) + 1;;) {
	    p = strchr(p, '/');
	    if (!p)
d907 5
a911 10
	    *p = '\0';
#ifdef WIN32
	    if (mkdir(c->filename) < 0 && errno != EEXIST)
#else
	    if (mkdir(c->filename, S_IREAD | S_IWRITE | S_IEXEC) < 0 && errno != EEXIST)
#endif /* WIN32 */
		ap_log_error(APLOG_MARK, APLOG_ERR, s,
			     "proxy: error creating cache directory %s",
			     c->filename);
	    *p = '/';
d913 8
a920 9
	}
#if defined(OS2) || defined(WIN32)
	/* Under OS/2 use rename. */
	if (rename(c->tempfile, c->filename) == -1)
	    ap_log_error(APLOG_MARK, APLOG_ERR, s,
			 "proxy: error renaming cache file %s to %s",
			 c->tempfile, c->filename);
    }
#else
d923 3
a925 4
	    ap_log_error(APLOG_MARK, APLOG_ERR, s,
			 "proxy: error linking cache file %s to %s",
			 c->tempfile, c->filename);
    }
d928 2
a929 2
	ap_log_error(APLOG_MARK, APLOG_ERR, s,
		     "proxy: error deleting temp file %s", c->tempfile);
d933 1
@


1.1.1.3
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 23
a38 20
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 5
a54 3
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
a55 3
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
a60 1
#include "http_conf_globals.h"
a62 1
#include "http_core.h"
d68 1
a68 1
#endif                          /* WIN32 */
d71 2
a72 7
#ifdef __TANDEM
#include <sys/types.h>
#include <sys/stat.h>
#endif
#ifdef TPF
#include "os.h"
#endif
d82 2
a83 2
    long lower;                 /* lower 30 bits of result */
    long upper;                 /* upper 31 bits of result */
d102 1
a102 1
static long block_size = 512;   /* this must be a power of 2 */
d104 2
a105 1
static time_t garbage_now, garbage_expire;
d112 1
a112 1
        garbage_mutex = ap_create_mutex(NULL);
d119 1
a119 1
                             const char *cachedir, const char *cachesubdir);
d121 1
a121 2
static int should_proxy_garbage_coll(request_rec *r);
#if !defined(WIN32) && !defined(MPE) && !defined(OS2) && !defined(NETWARE) && !defined(TPF)
d130 1
a130 1
    (void)ap_acquire_mutex(garbage_mutex);
d132 2
a133 2
        (void)ap_release_mutex(garbage_mutex);
        return;
d136 2
a137 2
        inside = 1;
    (void)ap_release_mutex(garbage_mutex);
d139 3
a141 4
    ap_block_alarms();          /* avoid SIGALRM on big cache cleanup */
    if (should_proxy_garbage_coll(r))
#if !defined(WIN32) && !defined(MPE) && !defined(OS2) && !defined(NETWARE) && !defined(TPF)
        detached_proxy_garbage_coll(r);
d143 1
a143 1
        help_proxy_garbage_coll(r);
d147 1
a147 1
    (void)ap_acquire_mutex(garbage_mutex);
d149 1
a149 1
    (void)ap_release_mutex(garbage_mutex);
d153 2
a154 1
static void add_long61(long61_t *accu, long val)
d164 2
a165 1
static void sub_long61(long61_t *accu, long val)
d179 2
a180 1
static long cmp_long61(long61_t *left, long61_t *right)
d183 1
a183 1
    : (left->upper - right->upper);
d189 2
a190 2
    const struct gc_ent *a = (const struct gc_ent *) ap;
    const struct gc_ent *b = (const struct gc_ent *) bp;
d193 1
a193 1
        return 1;
d195 1
a195 1
        return -1;
d197 1
a197 1
        return 0;
d200 1
a200 1
#if !defined(WIN32) && !defined(MPE) && !defined(OS2) && !defined(NETWARE) && !defined(TPF)
a206 4
#if 0
    ap_log_error(APLOG_MARK, APLOG_DEBUG, r->server,
                 "proxy: Guess what; we fork() again...");
#endif
d208 16
a223 16
    case -1:
        ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                     "proxy: fork() for cache cleanup failed");
        return;

    case 0:                     /* Child */

        /* close all sorts of things, including the socket fd */
        ap_cleanup_for_exec();

        /* Fork twice to disassociate from the child */
        switch (pid = fork()) {
        case -1:
            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                         "proxy: fork(2nd) for cache cleanup failed");
            exit(1);
d225 2
a226 2
        case 0:         /* Child */
            /* The setpgrp() stuff was snarfed from http_main.c */
d228 5
a232 6
            if ((pgrp = setsid()) == -1) {
                perror("setsid");
                fprintf(stderr, "%s: setsid failed\n",
                        ap_server_argv0);
                exit(1);
            }
d234 5
a238 14
            if (setpgrp(0, getpid()) == -1 || (pgrp = getpgrp(0)) == -1) {
                perror("setpgrp");
                fprintf(stderr, "%S: setpgrp or getpgrp failed\n",
                        ap_server_argv0);
                exit(1);
            }
#elif defined(CYGWIN)
            /* Cygwin does not take any argument for setpgrp() */
            if ((pgrp = setpgrp()) == -1) {
                perror("setpgrp");
                fprintf(stderr, "%S: setpgrp failed\n",
                        ap_server_argv0);
                exit(1);
            }
d240 19
a258 20
            if ((pgrp = setpgrp(getpid(), 0)) == -1) {
                perror("setpgrp");
                fprintf(stderr, "%s: setpgrp failed\n",
                        ap_server_argv0);
                exit(1);
            }
#endif
            help_proxy_garbage_coll(r);
            exit(0);

        default:                /* Father */
            /* After grandson has been forked off, */
            /* there's nothing else to do. */
            exit(0);
        }
    default:
        /* Wait until grandson has been forked off */
        /* (without wait we'd leave a zombie) */
        waitpid(pid, &status, 0);
        return;
d261 1
a261 1
#endif                          /* ndef WIN32 */
d263 1
a263 3
#define DOT_TIME "/.time"       /* marker */

static int should_proxy_garbage_coll(request_rec *r)
d265 1
d268 1
a268 1
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
d270 5
d276 5
a280 6
    const char *cachedir = conf->root;
    char *filename;
    struct stat buf;
    int timefd;
    time_t every = conf->gcinterval;
    static time_t lastcheck = BAD_DATE; /* static (per-process) data!!! */
d283 1
a283 4
        return 0;

    filename = ap_palloc(r->pool, strlen(cachedir) + strlen(DOT_TIME) + 1);

d285 1
a285 2
    /*
     * Usually, the modification time of <cachedir>/.time can only increase.
d287 2
a288 2
     * lastcheck, if time(NULL) still < lastcheck then it's not time for GC
     * yet.
d291 3
a293 1
        return 0;
d295 1
d297 18
a314 26
    strcat(filename, DOT_TIME);

    /*
     * At this point we have a bit of an engineering compromise. We could
     * either create and/or mark the .time file  (prior to the fork which
     * might fail on a resource issue) or wait until we are safely forked.
     * The advantage of doing it now in this process is that we get some
     * usefull live out of the global last check variable. (XXX which should
     * go scoreboard IMHO.) Note that the actual counting is at a later
     * moment.
     */
    if (stat(filename, &buf) == -1) {   /* does not exist */
        if (errno != ENOENT) {
            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                         "proxy: stat(%s)", filename);
            return 0;
        }
        if ((timefd = creat(filename, 0666)) == -1) {
            if (errno != EEXIST)
                ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                             "proxy: creat(%s)", filename);
            else
                lastcheck = garbage_now;        /* someone else got in there */
            return 0;
        }
        close(timefd);
d317 8
a324 7
        lastcheck = buf.st_mtime;       /* save the time */
        if (garbage_now < lastcheck + every) {
            return 0;
        }
        if (utime(filename, NULL) == -1)
            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                         "proxy: utimes(%s)", filename);
a325 24

    return 1;
}

static void help_proxy_garbage_coll(request_rec *r)
{
    const char *cachedir;
    void *sconf = r->server->module_config;
    proxy_server_conf *pconf =
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
    const struct cache_conf *conf = &pconf->cache;
    array_header *files;
    struct gc_ent *fent;
    char *filename;
    int i;

    cachedir = conf->root;
    filename = ap_palloc(r->pool, strlen(cachedir) + HASH_LEN + 2);
    /* configured size is given in kB. Make it bytes, convert to long61_t: */
    cachesize.lower = cachesize.upper = 0;
    add_long61(&cachesize, conf->space << 10);

    ap_block_alarms();          /* avoid SIGALRM on big cache cleanup */

d332 5
a336 5
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server,
                     "proxy GC: Cache is %ld%% full (nothing deleted)",
                     (long)(((curbytes.upper << 20) | (curbytes.lower >> 10)) * 100 / conf->space));
        ap_unblock_alarms();
        return;
d343 3
a345 3
        fent = &((struct gc_ent *) files->elts)[i];
        sprintf(filename, "%s%s", cachedir, fent->file);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "GC Unlinking %s (expiry %ld, garbage_now %ld)", filename, (long)fent->expire, (long)garbage_now);
d347 1
a347 1
        fprintf(stderr, "Would unlink %s\n", filename);
d349 17
a365 17
        if (unlink(filename) == -1) {
            if (errno != ENOENT)
                ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                             "proxy gc: unlink(%s)", filename);
        }
        else
#endif
        {
            sub_long61(&curbytes, ROUNDUP2BLOCKS(fent->len));
            if (cmp_long61(&curbytes, &cachesize) < 0)
                break;
        }
    }

    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server,
                 "proxy GC: Cache is %ld%% full (%d deleted)",
                 (long)(((curbytes.upper << 20) | (curbytes.lower >> 10)) * 100 / conf->space), i);
d370 1
a370 1
                          const char *cachebasedir, const char *cachesubdir)
d372 1
a372 1
    char line[17 * (3)];
a383 1
    char *filename;
d386 1
a386 2
    filename = ap_palloc(r->pool, strlen(cachedir) + HASH_LEN + 2);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "GC Examining directory %s", cachedir);
d389 3
a391 3
        ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                     "proxy gc: opendir(%s)", cachedir);
        return 0;
d395 4
a398 4
        if (ent->d_name[0] == '.')
            continue;
        sprintf(filename, "%s%s", cachedir, ent->d_name);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "GC Examining file %s", filename);
d400 1
a400 1
        if (strncmp(ent->d_name, "tmp", 3) == 0) {
d402 10
a411 10
            if (stat(filename, &buf) == -1) {
                if (errno != ENOENT)
                    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                                 "proxy gc: stat(%s)", filename);
            }
            else if (garbage_now != -1 && buf.st_atime < garbage_now - SEC_ONE_DAY &&
                     buf.st_mtime < garbage_now - SEC_ONE_DAY) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "GC unlink %s", filename);
                ap_log_error(APLOG_MARK, APLOG_INFO | APLOG_NOERRNO, r->server,
                     "proxy gc: deleting orphaned cache file %s", filename);
d413 1
a413 1
                fprintf(stderr, "Would unlink %s\n", filename);
d415 1
a415 1
                unlink(filename);
d417 4
a420 4
            }
            continue;
        }
        ++nfiles;
d422 2
a423 2
        /* FIXME: Shouldn't any unexpected files be deleted? */
        /* if (strlen(ent->d_name) != HASH_LEN) continue; */
d426 1
a426 2
/* under TPF use stat to identify a directory */
#if defined(OS2) || defined(TPF)
d428 7
a434 17
#ifdef OS2
        if (ent->d_attr & A_DIR)
#elif defined(TPF)
            if (stat(filename, &buf) == -1) {
                if (errno != ENOENT)
                    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                                 "proxy gc: stat(%s)", filename);
            }
        if (S_ISDIR(buf.st_mode))
#endif
        {
            char newcachedir[HUGE_STRING_LEN];
            ap_snprintf(newcachedir, sizeof(newcachedir),
                        "%s%s/", cachesubdir, ent->d_name);
            if (!sub_garbage_coll(r, files, cachebasedir, newcachedir)) {
                ap_snprintf(newcachedir, sizeof(newcachedir),
                            "%s%s", cachedir, ent->d_name);
d436 1
a436 1
                fprintf(stderr, "Would remove directory %s\n", newcachedir);
d438 1
a438 1
                rmdir(newcachedir);
d440 4
a443 4
                --nfiles;
            }
            continue;
        }
d447 24
a470 40
#if defined(WIN32)
        /*
         * On WIN32 open does not work for directories, so we us stat instead
         * of fstat to determine if the file is a directory
         */
        if (stat(filename, &buf) == -1) {
            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                         "proxy gc: stat(%s)", filename);
            continue;
        }
        fd = -1;
#else
        fd = open(filename, O_RDONLY | O_BINARY);
        if (fd == -1) {
            if (errno != ENOENT)
                ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                             "proxy gc: open(%s)", filename);
            continue;
        }
        if (fstat(fd, &buf) == -1) {
            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                         "proxy gc: fstat(%s)", filename);
            close(fd);
            continue;
        }
#endif

/* In OS/2 and TPF this has already been done above */
#if !defined(OS2) && !defined(TPF)
        if (S_ISDIR(buf.st_mode)) {
            char newcachedir[HUGE_STRING_LEN];
#if !defined(WIN32)
            /* Win32 used stat, no file to close */
            close(fd);
#endif
            ap_snprintf(newcachedir, sizeof(newcachedir),
                        "%s%s/", cachesubdir, ent->d_name);
            if (!sub_garbage_coll(r, files, cachebasedir, newcachedir)) {
                ap_snprintf(newcachedir, sizeof(newcachedir),
                            "%s%s", cachedir, ent->d_name);
d472 1
a472 1
                fprintf(stderr, "Would remove directory %s\n", newcachedir);
d474 1
a474 24
                rmdir(newcachedir);
#endif
                --nfiles;
            }
            else {
                /* Directory is not empty. Account for its size: */
                add_long61(&curbytes, ROUNDUP2BLOCKS(buf.st_size));
            }
            continue;
        }
#endif

#if defined(WIN32)
        /*
         * Since we have determined above that the file is not a directory,
         * it should be safe to open it now
         */
        fd = open(filename, O_RDONLY | O_BINARY);
        if (fd == -1) {
            if (errno != ENOENT)
                ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                             "proxy gc: open(%s) = %d", filename, errno);
            continue;
        }
d476 25
a500 17

        i = read(fd, line, 17 * (3) - 1);
        close(fd);
        if (i == -1) {
            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
                         "proxy gc: read(%s)", filename);
            continue;
        }
        line[i] = '\0';
        garbage_expire = ap_proxy_hex2sec(line + 17 * (2));
        if (!ap_checkmask(line, "&&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&&") ||
            garbage_expire == BAD_DATE) {
            /* bad file */
            if (garbage_now != -1 && buf.st_atime > garbage_now + SEC_ONE_DAY &&
                buf.st_mtime > garbage_now + SEC_ONE_DAY) {
                ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_NOERRNO, r->server,
                             "proxy: deleting bad cache file with future date: %s", filename);
d502 1
a502 1
                fprintf(stderr, "Would unlink bad file %s\n", filename);
d504 1
a504 1
                unlink(filename);
d506 3
a508 3
            }
            continue;
        }
d516 5
a520 5
        fent = (struct gc_ent *) ap_push_array(files);
        fent->len = buf.st_size;
        fent->expire = garbage_expire;
        strcpy(fent->file, cachesubdir);
        strcat(fent->file, ent->d_name);
d523 1
a523 1
        add_long61(&curbytes, ROUNDUP2BLOCKS(buf.st_size));
a531 1

d533 1
a533 1
 * Read a cache file;
a536 5
 *
 * We read the cache hex header, then the message response line and
 * response headers, and finally we return with the filepointer
 * pointing at the start of the message body itself, ready to be
 * shipped to the client later on, if appropriate.
d540 1
a540 1
    char urlbuff[HUGE_STRING_LEN], *strp;
d542 5
a546 19

    /* read the data from the cache file */

    /*
     * Format:
     * 
     * The cache needs to keep track of the following information: - Date,
     * LastMod, Version, ReqTime, RespTime, ContentLength - The original
     * request headers (for Vary) - The original response headers (for
     * returning with a cached response) - The body of the message
     * 
     * date SP lastmod SP expire SP count SP request-time SP response-time SP
     * content-lengthCRLF (dates are stored as hex seconds since 1970)
     * Original URLCRLF Original Request Headers CRLF Original Response
     * Headers CRLF Body
     * 
     */

    /* retrieve cachefile information values */
d548 2
a549 5
    if (len == -1) {
        /* Delete broken cache file */
        unlink(c->filename);
        return -1;
    }
d551 1
a551 1
        return 0;
d555 2
a556 2
                      "&&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&&"))
        return 0;
d558 5
a562 7
    c->date = ap_proxy_hex2sec(urlbuff + 17 * (0));
    c->lmod = ap_proxy_hex2sec(urlbuff + 17 * (1));
    c->expire = ap_proxy_hex2sec(urlbuff + 17 * (2));
    c->version = ap_proxy_hex2sec(urlbuff + 17 * (3));
    c->req_time = ap_proxy_hex2sec(urlbuff + 17 * (4));
    c->resp_time = ap_proxy_hex2sec(urlbuff + 17 * (5));
    c->len = ap_proxy_hex2sec(urlbuff + 17 * (6));
d564 1
a564 1
    /* check that we have the same URL */
d566 2
a567 5
    if (len == -1) {
        /* Delete broken cache file */
        unlink(c->filename);
        return -1;
    }
d569 2
a570 2
        urlbuff[len - 1] != '\n')
        return 0;
d573 1
a573 1
        return 0;
d575 1
a575 9
    /* then the original request headers */
    c->req_hdrs = ap_proxy_read_headers(r, urlbuff, sizeof urlbuff, cachefp);
    if (c->req_hdrs == NULL) {
        /* Delete broken cache file */
        unlink(c->filename);
        return -1;
    }

    /* then the original response headers */
d577 2
a578 5
    if (len == -1) {
        /* Delete broken cache file */
        unlink(c->filename);
        return -1;
    }
d580 1
a580 1
        return 0;
d586 1
a586 1
        return 0;
d590 8
a597 12
    if (c->hdrs == NULL) {
        /* Delete broken cache file */
        unlink(c->filename);
        return -1;
    }
    if (c->len != -1)           /* add a content-length header */
        if (ap_table_get(c->hdrs, "Content-Length") == NULL) {
            ap_table_set(c->hdrs, "Content-Length",
                         ap_psprintf(r->pool, "%lu", (unsigned long)c->len));
        }


a600 191
/*
 * Call this to check the possible conditional status of
 * the client request, and return the response from the cache
 *
 * Conditionals include If-Modified-Since, If-Match, If-Unmodified-Since
 * and If-None-Match.
 *
 * We don't yet understand If-Range, but we will...
 */
int ap_proxy_cache_conditional(request_rec *r, cache_req *c, BUFF *cachefp)
{
    const char *etag, *wetag = NULL;

    /* get etag */
    if ((etag = ap_table_get(c->hdrs, "Etag"))) {
        wetag = ap_pstrcat(r->pool, "W/", etag, NULL);
    }

    /* check for If-Match, If-Unmodified-Since */
    while (1) {

        /*
         * check If-Match and If-Unmodified-Since exist
         * 
         * If neither of these exist, the request is not conditional, and we
         * serve it normally
         */
        if (!c->im && BAD_DATE == c->ius) {
            break;
        }

        /*
         * check If-Match
         * 
         * we check if the Etag on the cached file is in the list of Etags in
         * the If-Match field. The comparison must be a strong comparison, so
         * the Etag cannot be marked as weak. If the comparision fails we
         * return 412 Precondition Failed.
         * 
         * if If-Match is specified AND If-Match is not a "*" AND Etag is
         * missing or weak or not in the list THEN return 412 Precondition
         * Failed
         */

        if (c->im) {
            if (strcmp(c->im, "*") &&
                (!etag || (strlen(etag) > 1 && 'W' == etag[0] && '/' == etag[1]) || !ap_proxy_liststr(c->im, etag, NULL))) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Match specified, and it didn't - return 412");
            }
            else {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Match specified, and it matched");
                break;
            }
        }

        /*
         * check If-Unmodified-Since
         * 
         * if If-Unmodified-Since is specified AND Last-Modified is specified
         * somewhere AND If-Unmodified-Since is in the past compared to
         * Last-Modified THEN return 412 Precondition Failed
         */
        if (BAD_DATE != c->ius && BAD_DATE != c->lmod) {
            if (c->ius < c->lmod) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Unmodified-Since specified, but it wasn't - return 412");
            }
            else {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Unmodified-Since specified, and it was unmodified");
                break;
            }
        }

        /* if cache file is being updated */
        if (c->origfp) {
            ap_proxy_write_headers(c, c->resp_line, c->hdrs);
            ap_proxy_send_fb(c->origfp, r, c, c->len, 1, 0, IOBUFSIZE);
            ap_proxy_cache_tidy(c);
        }
        else
            ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));

        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Use your cached copy, conditional precondition failed.");
        return HTTP_PRECONDITION_FAILED;
    }


    /* check for If-None-Match, If-Modified-Since */
    while (1) {

        /*
         * check for existance of If-None-Match and If-Modified-Since
         * 
         * if neither of these headers have been set, then the request is not
         * conditional, and we just send the cached response and be done with
         * it.
         */
        if (!c->inm && BAD_DATE == c->ims) {
            break;
        }

        /*
         * check If-None-Match
         * 
         * we check if the Etag on the cached file is in the list of Etags in
         * the If-None-Match field. The comparison must be a strong
         * comparison, so the Etag cannot be marked as weak. If the
         * comparision fails we return 412 Precondition Failed.
         * 
         * if If-None-Match is specified: if If-None-Match is a "*" THEN 304
         * else if Etag is specified AND we get a match THEN 304 else if Weak
         * Etag is specified AND we get a match THEN 304 else sent the
         * original object
         */
        if (c->inm) {
            if (!strcmp(c->inm, "*")) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-None-Match: * specified, return 304");
            }
            else if (etag && ap_proxy_liststr(c->inm, etag, NULL)) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-None-Match: specified and we got a strong match - return 304");
            }
            else if (wetag && ap_proxy_liststr(c->inm, wetag, NULL)) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-None-Match specified, and we got a weak match - return 304");
            }
            else
                break;
        }

        /*
         * check If-Modified-Since
         * 
         * if If-Modified-Since is specified AND Last-Modified is specified
         * somewhere: if last modification date is earlier than
         * If-Modified-Since THEN 304 else send the original object
         */
        if (BAD_DATE != c->ims && BAD_DATE != c->lmod) {
            if (c->ims >= c->lmod) {
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Modified-Since specified and not modified, try return 304");
            }
            else
                break;
        }


        /* are we updating the cache file? */
        if (c->origfp) {
            ap_proxy_write_headers(c, c->resp_line, c->hdrs);
            ap_proxy_send_fb(c->origfp, r, c, c->len, 1, 0, IOBUFSIZE);
            ap_proxy_cache_tidy(c);
        }
        else
            ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));

        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Use local copy, cached file hasn't changed");
        return HTTP_NOT_MODIFIED;
    }


    /* No conditional - just send it cousin! */
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Local copy modified, send it");
    r->status_line = strchr(c->resp_line, ' ') + 1;
    r->status = c->status;

    /* Prepare and send headers to client */
    ap_proxy_table_replace(r->headers_out, c->hdrs);
    /* make sure our X-Cache header does not stomp on a previous header */
    ap_table_mergen(r->headers_out, "X-Cache", c->xcache);

    /* content type is already set in the headers */
    r->content_type = ap_table_get(r->headers_out, "Content-Type");

    ap_send_http_header(r);

    /* are we rewriting the cache file? */
    if (c->origfp) {
        ap_proxy_write_headers(c, c->resp_line, c->hdrs);
        ap_proxy_send_fb(c->origfp, r, c, c->len, r->header_only, 0, IOBUFSIZE);
        ap_proxy_cache_tidy(c);
        return OK;
    }

    /* no, we not */
    if (!r->header_only) {
        ap_proxy_send_fb(cachefp, r, NULL, c->len, 0, 0, IOBUFSIZE);
    }
    else {
        ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));
    }

    return OK;
}

d612 1
a612 1
 *      else if cached file is expired then
d616 2
a617 2
int ap_proxy_cache_check(request_rec *r, char *url, struct cache_conf * conf,
                             cache_req **cr)
d619 2
a620 2
    const char *datestr, *pragma_req = NULL, *pragma_cresp = NULL, *cc_req = NULL,
        *cc_cresp = NULL;
d622 1
d624 2
a625 1
    int i;
d628 1
a628 5
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
    const char *agestr = NULL;
    char *val;
    time_t age_c = 0;
    time_t age, maxage_req, maxage_cresp, maxage, smaxage, maxstale, minfresh;
a633 9
    c->filename = NULL;
    c->tempfile = NULL;
    c->fp = NULL;
    c->origfp = NULL;
    c->version = 0;
    c->len = -1;
    c->req_hdrs = NULL;
    c->hdrs = NULL;
    c->xcache = NULL;
d635 1
a635 1
    /* get the If-Modified-Since date of the request, if it exists */
d637 7
a643 18
    datestr = ap_table_get(r->headers_in, "If-Modified-Since");
    if (datestr != NULL) {
        /* this may modify the value in the original table */
        datestr = ap_proxy_date_canon(r->pool, datestr);
        c->ims = ap_parseHTTPdate(datestr);
        if (c->ims == BAD_DATE) /* bad or out of range date; remove it */
            ap_table_unset(r->headers_in, "If-Modified-Since");
    }

/* get the If-Unmodified-Since date of the request, if it exists */
    c->ius = BAD_DATE;
    datestr = ap_table_get(r->headers_in, "If-Unmodified-Since");
    if (datestr != NULL) {
        /* this may modify the value in the original table */
        datestr = ap_proxy_date_canon(r->pool, datestr);
        c->ius = ap_parseHTTPdate(datestr);
        if (c->ius == BAD_DATE) /* bad or out of range date; remove it */
            ap_table_unset(r->headers_in, "If-Unmodified-Since");
a645 6
/* get the If-Match of the request, if it exists */
    c->im = ap_table_get(r->headers_in, "If-Match");

/* get the If-None-Match of the request, if it exists */
    c->inm = ap_table_get(r->headers_in, "If-None-Match");

d647 5
a651 39
    if (conf->root != NULL) {
        char hashfile[66];
        ap_proxy_hash(url, hashfile, pconf->cache.dirlevels, pconf->cache.dirlength);
        c->filename = ap_pstrcat(r->pool, conf->root, "/", hashfile, NULL);
    }
    else {
        c->filename = NULL;
        c->fp = NULL;
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "No CacheRoot, so no caching. Declining.");
        return DECLINED;
    }

/* find certain cache controlling headers */
    pragma_req = ap_table_get(r->headers_in, "Pragma");
    cc_req = ap_table_get(r->headers_in, "Cache-Control");

/* first things first - does the request allow us to return
 * cached information at all? If not, just decline the request.
 *
 * Note that there is a big difference between not being allowed
 * to cache a request (no-store) and not being allowed to return
 * a cached request without revalidation (max-age=0).
 *
 * Caching is forbidden under the following circumstances:
 *
 * - RFC2616 14.9.2 Cache-Control: no-store
 * we are not supposed to store this request at all. Behave as a tunnel.
 *
 */
    if (ap_proxy_liststr(cc_req, "no-store", NULL)) {

/* delete the previously cached file */
        if (c->filename)
            unlink(c->filename);
        c->fp = NULL;
        c->filename = NULL;
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "no-store forbids caching. Declining.");
        return DECLINED;
    }
a652 1
/* if the cache file exists, open it */
a653 2
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Request for %s, pragma_req=%s, ims=%ld", url,
                 (pragma_req == NULL) ? "(unset)" : pragma_req, c->ims);
d655 4
d660 17
a676 2
        strlen(url) < 1024) {
        cachefp = ap_proxy_open_cachefile(r, c->filename);
a678 4

    /*
     * if a cache file exists, try reading body and headers from cache file
     */
d680 12
a691 19
        i = rdcache(r, cachefp, c);
        if (i == -1)
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                          "proxy: error reading cache file %s",
                          c->filename);
        else if (i == 0)
            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, r,
                          "proxy: bad (short?) cache file: %s", c->filename);
        if (i != 1) {
            ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));
            cachefp = NULL;
        }
        if (c->hdrs) {
            cc_cresp = ap_table_get(c->hdrs, "Cache-Control");
            pragma_cresp = ap_table_get(c->hdrs, "Pragma");
            if ((agestr = ap_table_get(c->hdrs, "Age"))) {
                age_c = atoi(agestr);
            }
        }
a692 2

    /* if a cache file does not exist, create empty header array */
a694 1

d696 1
a696 1
        c->hdrs = ap_make_table(r->pool, 20);
d699 12
d712 23
a734 166
    /*
     * Check Content-Negotiation - Vary
     * 
     * At this point we need to make sure that the object we found in the cache
     * is the same object that would be delivered to the client, when the
     * effects of content negotiation are taken into effect.
     * 
     * In plain english, we want to make sure that a language-negotiated
     * document in one language is not given to a client asking for a
     * language negotiated document in a different language by mistake.
     * 
     * RFC2616 13.6 and 14.44 describe the Vary mechanism.
     */
    if (c->hdrs && c->req_hdrs) {
        char *vary = ap_pstrdup(r->pool, ap_table_get(c->hdrs, "Vary"));

        while (vary && *vary) {
            char *name = vary;
            const char *h1, *h2;

            /* isolate header name */
            while (*vary && !ap_isspace(*vary) && (*vary != ','))
                ++vary;
            while (*vary && (ap_isspace(*vary) || (*vary == ','))) {
                *vary = '\0';
                ++vary;
            }

            /*
             * is this header in the request and the header in the cached
             * request identical? If not, we give up and do a straight get
             */
            h1 = ap_table_get(r->headers_in, name);
            h2 = ap_table_get(c->req_hdrs, name);
            if (h1 == h2) {
                /* both headers NULL, so a match - do nothing */
            }
            else if (h1 && h2 && !strcmp(h1, h2)) {
                /* both headers exist and are equal - do nothing */
            }
            else {

                /* headers do not match, so Vary failed */
                c->fp = cachefp;
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Vary header mismatch - object must be fetched from scratch. Declining.");
                return DECLINED;
            }
        }
    }


    /*
     * We now want to check if our cached data is still fresh. This depends
     * on a few things, in this order:
     * 
     * - RFC2616 14.9.4 End to end reload, Cache-Control: no-cache no-cache in
     * either the request or the cached response means that we must
     * revalidate the request unconditionally, overriding any expiration
     * mechanism. It's equivalent to max-age=0,must-revalidate.
     * 
     * - RFC2616 14.32 Pragma: no-cache This is treated the same as
     * Cache-Control: no-cache.
     * 
     * - RFC2616 14.9.3 Cache-Control: max-stale, must-revalidate,
     * proxy-revalidate if the max-stale request header exists, modify the
     * stale calculations below so that an object can be at most <max-stale>
     * seconds stale before we request a revalidation, _UNLESS_ a
     * must-revalidate or proxy-revalidate cached response header exists to
     * stop us doing this.
     * 
     * - RFC2616 14.9.3 Cache-Control: s-maxage the origin server specifies the
     * maximum age an object can be before it is considered stale. This
     * directive has the effect of proxy|must revalidate, which in turn means
     * simple ignore any max-stale setting.
     * 
     * - RFC2616 14.9.4 Cache-Control: max-age this header can appear in both
     * requests and responses. If both are specified, the smaller of the two
     * takes priority.
     * 
     * - RFC2616 14.21 Expires: if this request header exists in the cached
     * entity, and it's value is in the past, it has expired.
     * 
     */

    /* calculate age of object */
    age = ap_proxy_current_age(c, age_c);

    /* extract s-maxage */
    if (cc_cresp && ap_proxy_liststr(cc_cresp, "s-maxage", &val))
        smaxage = atoi(val);
    else
        smaxage = -1;

    /* extract max-age from request */
    if (cc_req && ap_proxy_liststr(cc_req, "max-age", &val))
        maxage_req = atoi(val);
    else
        maxage_req = -1;

    /* extract max-age from response */
    if (cc_cresp && ap_proxy_liststr(cc_cresp, "max-age", &val))
        maxage_cresp = atoi(val);
    else
        maxage_cresp = -1;

    /*
     * if both maxage request and response, the smaller one takes priority
     */
    if (-1 == maxage_req)
        maxage = maxage_cresp;
    else if (-1 == maxage_cresp)
        maxage = maxage_req;
    else
        maxage = MIN(maxage_req, maxage_cresp);

    /* extract max-stale */
    if (cc_req && ap_proxy_liststr(cc_req, "max-stale", &val))
        maxstale = atoi(val);
    else
        maxstale = 0;

    /* extract min-fresh */
    if (cc_req && ap_proxy_liststr(cc_req, "min-fresh", &val))
        minfresh = atoi(val);
    else
        minfresh = 0;

    /* override maxstale if must-revalidate or proxy-revalidate */
    if (maxstale && ((cc_cresp && ap_proxy_liststr(cc_cresp, "must-revalidate", NULL)) || (cc_cresp && ap_proxy_liststr(cc_cresp, "proxy-revalidate", NULL))))
        maxstale = 0;

    if (cachefp != NULL &&

    /* handle no-cache */
        !((cc_req && ap_proxy_liststr(cc_req, "no-cache", NULL)) ||
          (pragma_req && ap_proxy_liststr(pragma_req, "no-cache", NULL)) ||
          (cc_cresp && ap_proxy_liststr(cc_cresp, "no-cache", NULL)) ||
      (pragma_cresp && ap_proxy_liststr(pragma_cresp, "no-cache", NULL))) &&

    /* handle expiration */
        ((-1 < smaxage && age < (smaxage - minfresh)) ||
         (-1 < maxage && age < (maxage + maxstale - minfresh)) ||
         (c->expire != BAD_DATE && age < (c->expire - c->date + maxstale - minfresh)))
        ) {

        /* it's fresh darlings... */

        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Unexpired data available");

        /* set age header on response */
        ap_table_set(c->hdrs, "Age",
                     ap_psprintf(r->pool, "%lu", (unsigned long)age));

        /* add warning if maxstale overrode freshness calculation */
        if (!((-1 < smaxage && age < smaxage) ||
              (-1 < maxage && age < maxage) ||
              (c->expire != BAD_DATE && (c->expire - c->date) > age))) {
            /* make sure we don't stomp on a previous warning */
            ap_table_merge(c->hdrs, "Warning", "110 Response is stale");
        }

        /* check conditionals (If-Modified-Since, etc) */
        c->xcache = ap_pstrcat(r->pool, "HIT from ", ap_get_server_name(r), NULL);
        return ap_proxy_cache_conditional(r, c, cachefp);


d737 3
a739 12
    /*
     * at this point we have determined our cached data needs revalidation
     * but first - we check 1 thing:
     * 
     * RFC2616 14.9.4 - if "only-if-cached" specified, send a 504 Gateway
     * Timeout - we're not allowed to revalidate the object
     */
    if (ap_proxy_liststr(cc_req, "only-if-cached", NULL)) {
        if (cachefp)
            ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));
        return HTTP_GATEWAY_TIME_OUT;
    }
d741 7
d749 4
a752 33
    /*
     * If we already have cached data and a last-modified date, and it is not
     * a head request, then add an If-Modified-Since.
     * 
     * If we also have an Etag, then the object must have come from an HTTP/1.1
     * server. Add an If-None-Match as well.
     * 
     * See RFC2616 13.3.4
     */

    if (cachefp != NULL && !r->header_only) {

        const char *etag = ap_table_get(c->hdrs, "Etag");

        /* If-Modified-Since */
        if (c->lmod != BAD_DATE) {
            /*
             * use the later of the one from the request and the
             * last-modified date from the cache
             */
            if (c->ims == BAD_DATE || c->ims < c->lmod) {
                const char *q;

                if ((q = ap_table_get(c->hdrs, "Last-Modified")) != NULL)
                    ap_table_set(r->headers_in, "If-Modified-Since", (char *)q);
            }
        }

        /* If-None-Match */
        if (etag) {
            ap_table_set(r->headers_in, "If-None-Match", etag);
        }

a753 2


d756 1
a756 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Local copy not present or expired. Declining.");
d774 1
a774 1
                              const int is_HTTP1, int nocache)
d776 3
a778 3
#if defined(ULTRIX_BRAIN_DEATH) || defined(SINIX_D_RESOLVER_BUG)
    extern char *mktemp(char *template);
#endif
d781 1
d784 1
a784 1
    char buff[17 * 7 + 1];
d787 2
a788 5
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
    const char *cc_resp;
    table *req_hdrs;

    cc_resp = ap_table_get(resp_hdrs, "Cache-Control");
d792 4
a795 6
    /* we've received the response from the origin server */

    /*
     * read expiry date; if a bad date, then leave it so the client can read
     * it
     */
d798 1
a798 1
        expc = ap_parseHTTPdate(expire);
d800 1
a800 1
        expc = BAD_DATE;
d802 3
a804 1
    /* read the last-modified date; if the date is bad, then delete it */
d807 5
a811 5
        lmod = ap_parseHTTPdate(lmods);
        if (lmod == BAD_DATE) {
            /* kill last modified date */
            lmods = NULL;
        }
d814 1
a814 1
        lmod = BAD_DATE;
d816 25
a840 71

    /*
     * what responses should we not cache?
     * 
     * At this point we decide based on the response headers whether it is
     * appropriate _NOT_ to cache the data from the server. There are a whole
     * lot of conditions that prevent us from caching this data. They are
     * tested here one by one to be clear and unambiguous.
     */

    /*
     * RFC2616 13.4 we are allowed to cache 200, 203, 206, 300, 301 or 410 We
     * don't cache 206, because we don't (yet) cache partial responses. We
     * include 304 Not Modified here too as this is the origin server telling
     * us to serve the cached copy.
     */
    if ((r->status != HTTP_OK && r->status != HTTP_NON_AUTHORITATIVE && r->status != HTTP_MULTIPLE_CHOICES && r->status != HTTP_MOVED_PERMANENTLY && r->status != HTTP_NOT_MODIFIED) ||

    /* if a broken Expires header is present, don't cache it */
        (expire != NULL && expc == BAD_DATE) ||

    /*
     * if the server said 304 Not Modified but we have no cache file - pass
     * this untouched to the user agent, it's not for us.
     */
        (r->status == HTTP_NOT_MODIFIED && (c == NULL || c->fp == NULL)) ||

    /*
     * 200 OK response from HTTP/1.0 and up without a Last-Modified header
     */
        (r->status == HTTP_OK && lmods == NULL && is_HTTP1) ||

    /* HEAD requests */
        r->header_only ||

    /*
     * RFC2616 14.9.2 Cache-Control: no-store response indicating do not
     * cache, or stop now if you are trying to cache it
     */
        ap_proxy_liststr(cc_resp, "no-store", NULL) ||

    /*
     * RFC2616 14.9.1 Cache-Control: private this object is marked for this
     * user's eyes only. Behave as a tunnel.
     */
        ap_proxy_liststr(cc_resp, "private", NULL) ||

    /*
     * RFC2616 14.8 Authorisation: if authorisation is included in the
     * request, we don't cache, but we can cache if the following exceptions
     * are true: 1) If Cache-Control: s-maxage is included 2) If
     * Cache-Control: must-revalidate is included 3) If Cache-Control: public
     * is included
     */
        (ap_table_get(r->headers_in, "Authorization") != NULL

         && !(ap_proxy_liststr(cc_resp, "s-maxage", NULL) || ap_proxy_liststr(cc_resp, "must-revalidate", NULL) || ap_proxy_liststr(cc_resp, "public", NULL))
         ) ||

    /* or we've been asked not to cache it above */
        nocache) {

        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Response is not cacheable, unlinking %s", c->filename);

        /* close the file */
        if (c->fp != NULL) {
            ap_pclosef(r->pool, ap_bfileno(c->fp, B_WR));
            c->fp = NULL;
        }

        /* delete the previously cached file */
d843 1
a843 1
        return DECLINED;        /* send data to client but not cache */
d846 4
a849 13

    /*
     * It's safe to cache the response.
     * 
     * We now want to update the cache file header information with the new
     * date, last modified, expire and content length and write it away to
     * our cache file. First, we determine these values from the response,
     * using heuristics if appropriate.
     * 
     * In addition, we make HTTP/1.1 age calculations and write them away too.
     */

    /* Read the date. Generate one if one is not supplied */
d852 1
a852 1
        date = ap_parseHTTPdate(dates);
d854 1
a854 1
        date = BAD_DATE;
d858 1
a858 1
    if (date == BAD_DATE) {     /* No, or bad date */
d862 4
a865 4
        date = now;
        dates = ap_gm_timestr_822(r->pool, now);
        ap_table_set(resp_hdrs, "Date", dates);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Added date header");
a867 3
/* set response_time for HTTP/1.1 age calculations */
    c->resp_time = now;

d872 3
a874 3
        lmod = date;
        lmods = dates;
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Last modified is in the future, replacing with now");
d878 2
a879 2
        lmod = c->lmod;
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Reusing cached last modified");
d883 4
a886 5
    if (expire == NULL && c->fp != NULL) {      /* no expiry data sent in
                                                 * response */
        expire = ap_table_get(c->hdrs, "Expires");
        if (expire != NULL)
            expc = ap_parseHTTPdate(expire);
d895 1
a895 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Expiry date is %ld", (long)expc);
d897 10
a906 10
        if (lmod != BAD_DATE) {
            double x = (double)(date - lmod) * conf->cache.lmfactor;
            double maxex = conf->cache.maxexpire;
            if (x > maxex)
                x = maxex;
            expc = now + (int)x;
        }
        else
            expc = now + conf->cache.defaultexpire;
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Expiry date calculated %ld", (long)expc);
d912 1
a912 1
        c->len = -1;
d914 1
a914 1
        c->len = atoi(clen);
d916 11
a926 17
/* we have all the header information we need - write it to the cache file */
    c->version++;
    ap_proxy_sec2hex(date, buff + 17 * (0));
    buff[17 * (1) - 1] = ' ';
    ap_proxy_sec2hex(lmod, buff + 17 * (1));
    buff[17 * (2) - 1] = ' ';
    ap_proxy_sec2hex(expc, buff + 17 * (2));
    buff[17 * (3) - 1] = ' ';
    ap_proxy_sec2hex(c->version, buff + 17 * (3));
    buff[17 * (4) - 1] = ' ';
    ap_proxy_sec2hex(c->req_time, buff + 17 * (4));
    buff[17 * (5) - 1] = ' ';
    ap_proxy_sec2hex(c->resp_time, buff + 17 * (5));
    buff[17 * (6) - 1] = ' ';
    ap_proxy_sec2hex(c->len, buff + 17 * (6));
    buff[17 * (7) - 1] = '\n';
    buff[17 * (7)] = '\0';
d928 1
a928 8
/* Was the server response a 304 Not Modified?
 *
 * If it was, it means that we requested a revalidation, and that
 * the result of that revalidation was that the object was fresh.
 *
 */

/* if response from server 304 not modified */
d930 50
a979 20

/* Have the headers changed?
 *
 * if not - we fulfil the request and return now.
 */

        if (c->hdrs) {
            if (!ap_proxy_table_replace(c->hdrs, resp_hdrs)) {
                c->xcache = ap_pstrcat(r->pool, "HIT from ", ap_get_server_name(r), " (with revalidation)", NULL);
                return ap_proxy_cache_conditional(r, c, c->fp);
            }
        }
        else
            c->hdrs = resp_hdrs;
/* if we get here - the headers have changed. Go through the motions
 * of creating a new temporary cache file below, we'll then serve
 * the request like we would have in ap_proxy_cache_conditional()
 * above, and at the same time we will also rewrite the contents
 * to the new temporary file.
 */
d981 1
a981 16

/*
 * Ok - lets prepare and open the cached file
 *
 * If a cached file (in c->fp) is already open, then we want to
 * update that cached file. Copy the c->fp to c->origfp and open
 * up a new one.
 *
 * If the cached file (in c->fp) is NULL, we must open a new cached
 * file from scratch.
 *
 * The new cache file will be moved to it's final location in the
 * directory tree later, overwriting the old cache file should it exist.
 */

/* if a cache file was already open */
d983 2
a984 1
        c->origfp = c->fp;
d986 3
d990 7
a996 11
    while (1) {
/* create temporary filename */
#ifndef TPF
#define TMPFILESTR    "/tmpXXXXXX"
        if (conf->cache.root == NULL) {
            c = ap_proxy_cache_error(c);
            break;
        }
        c->tempfile = ap_palloc(r->pool, strlen(conf->cache.root) + sizeof(TMPFILESTR));
        strcpy(c->tempfile, conf->cache.root);
        strcat(c->tempfile, TMPFILESTR);
d998 23
a1020 71
        p = mktemp(c->tempfile);
#else
        if (conf->cache.root == NULL) {
            c = ap_proxy_cache_error(c);
            break;
        }
        c->tempfile = ap_palloc(r->pool, strlen(conf->cache.root) + 1 + L_tmpnam);
        strcpy(c->tempfile, conf->cache.root);
        strcat(c->tempfile, "/");
        p = tmpnam(NULL);
        strcat(c->tempfile, p);
#endif
        if (p == NULL) {
            c = ap_proxy_cache_error(c);
            break;
        }

        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Create temporary file %s", c->tempfile);

/* create the new file */
        c->fp = ap_proxy_create_cachefile(r, c->tempfile);
        if (NULL == c->fp) {
            c = ap_proxy_cache_error(c);
            break;
        }

/* write away the cache header and the URL */
        if (ap_bvputs(c->fp, buff, "X-URL: ", c->url, "\n", NULL) == -1) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                        "proxy: error writing cache file(%s)", c->tempfile);
            c = ap_proxy_cache_error(c);
            break;
        }

/* get original request headers */
        if (c->req_hdrs)
            req_hdrs = ap_copy_table(r->pool, c->req_hdrs);
        else
            req_hdrs = ap_copy_table(r->pool, r->headers_in);

/* remove hop-by-hop headers */
        ap_proxy_clear_connection(r->pool, req_hdrs);

/* save original request headers */
        if (c->req_hdrs)
            ap_table_do(ap_proxy_send_hdr_line, c, c->req_hdrs, NULL);
        else
            ap_table_do(ap_proxy_send_hdr_line, c, r->headers_in, NULL);
        if (ap_bputs(CRLF, c->fp) == -1) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                          "proxy: error writing request headers terminating CRLF to %s", c->tempfile);
            c = ap_proxy_cache_error(c);
            break;
        }
        break;
    }

/* Was the server response a 304 Not Modified?
 *
 * If so, we have some work to do that we didn't do when we first
 * checked above. We need to fulfil the request, and we need to
 * copy the body from the old object to the new one.
 */

/* if response from server 304 not modified */
    if (r->status == HTTP_NOT_MODIFIED) {

/* fulfil the request */
        c->xcache = ap_pstrcat(r->pool, "HIT from ", ap_get_server_name(r), " (with revalidation)", NULL);
        return ap_proxy_cache_conditional(r, c, c->fp);

d1030 2
a1031 2
    if (!c || !c->fp)
        return;
d1042 5
a1046 5
        if (bc != c->len) {
            ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR));  /* no need to flush */
            unlink(c->tempfile);
            return;
        }
d1050 3
a1052 3
        ap_pclosef(c->req->pool, c->fp->fd);    / no need to flush /
        unlink(c->tempfile);
        return;
d1057 2
a1058 2
        char buff[17];
        off_t curpos;
d1060 10
a1069 10
        c->len = bc;
        ap_bflush(c->fp);
        ap_proxy_sec2hex(c->len, buff);
        curpos = lseek(ap_bfileno(c->fp, B_WR), 17 * 6, SEEK_SET);
        if (curpos == -1)
            ap_log_error(APLOG_MARK, APLOG_ERR, s,
                      "proxy: error seeking on cache file %s", c->tempfile);
        else if (write(ap_bfileno(c->fp, B_WR), buff, sizeof(buff) - 1) == -1)
            ap_log_error(APLOG_MARK, APLOG_ERR, s,
                         "proxy: error updating cache file %s", c->tempfile);
d1073 6
a1078 6
        ap_log_error(APLOG_MARK, APLOG_ERR, s,
                     "proxy: error writing to cache file %s",
                     c->tempfile);
        ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR));
        unlink(c->tempfile);
        return;
d1081 5
a1085 5
    if (ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR))== -1) {
        ap_log_error(APLOG_MARK, APLOG_ERR, s,
                     "proxy: error closing cache file %s", c->tempfile);
        unlink(c->tempfile);
        return;
d1089 3
a1091 4
        ap_log_error(APLOG_MARK, APLOG_ERR, s,
                     "proxy: error deleting old cache file %s",
                     c->filename);
        (void)unlink(c->tempfile);
d1094 11
a1104 13
        char *p;
        proxy_server_conf *conf =
        (proxy_server_conf *)ap_get_module_config(s->module_config, &proxy_module);

        for (p = c->filename + strlen(conf->cache.root) + 1;;) {
            p = strchr(p, '/');
            if (!p)
                break;
            *p = '\0';
#if defined(WIN32) || defined(NETWARE)
            if (mkdir(c->filename) < 0 && errno != EEXIST)
#elif defined(__TANDEM)
                if (mkdir(c->filename, S_IRWXU | S_IRWXG | S_IRWXO) < 0 && errno != EEXIST)
d1106 15
a1120 16
            if (mkdir(c->filename, S_IREAD | S_IWRITE | S_IEXEC) < 0 && errno != EEXIST)
#endif                          /* WIN32 */
                ap_log_error(APLOG_MARK, APLOG_ERR, s,
                             "proxy: error creating cache directory %s",
                             c->filename);
            *p = '/';
            ++p;
        }
#if defined(OS2) || defined(WIN32) || defined(NETWARE) || defined(MPE)
        /* Under OS/2 use rename. */
        if (rename(c->tempfile, c->filename) == -1) {
            ap_log_error(APLOG_MARK, APLOG_ERR, s,
                         "proxy: error renaming cache file %s to %s",
                         c->tempfile, c->filename);
            (void)unlink(c->tempfile);
        }
d1123 9
a1131 7
        if (link(c->tempfile, c->filename) == -1)
            ap_log_error(APLOG_MARK, APLOG_ERR, s,
                         "proxy: error linking cache file %s to %s",
                         c->tempfile, c->filename);
        if (unlink(c->tempfile) == -1)
            ap_log_error(APLOG_MARK, APLOG_ERR, s,
                         "proxy: error deleting temp file %s", c->tempfile);
d1133 1
a1133 1
    }
@


1.1.1.4
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@d1527 1
a1527 1
        c->len = ap_strtol(clen, NULL, 10);
a1562 15
            /* recall at this point that c->len is already set from resp_hdrs.
               If Content-Length was NULL, then c->len is -1, otherwise it's
               set to whatever the value was. */
            if (c->len == 0 || c->len == -1) {
                const char *c_clen_str;
                off_t c_clen;
                if ( (c_clen_str = ap_table_get(c->hdrs, "Content-Length")) &&
                   ( (c_clen = ap_strtol(c_clen_str, NULL, 10)) > 0) ) {
                        ap_table_set(resp_hdrs, "Content-Length", c_clen_str);
                        c->len = c_clen;
                        ap_proxy_sec2hex(c->len, buff + 17 * (6));
                        buff[17 * (7) - 1] = '\n';
                        buff[17 * (7)] = '\0';
                }
            }
@


1.1.1.5
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
d1802 1
a1802 1
            ap_log_error(APLOG_MARK, APLOG_INFO, s,
@


