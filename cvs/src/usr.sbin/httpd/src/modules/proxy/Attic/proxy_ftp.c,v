head	1.19;
access;
symbols
	OPENBSD_5_5:1.18.0.14
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.10
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.8
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.14.0.14
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.12
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.10
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.8
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.5
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.4
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.3
	apache_1_3_27:1.1.1.3
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	apache_1_3_26:1.1.1.3
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.2.0.2
	OPENBSD_2_4_BASE:1.1.1.2
	apache_1_3_2:1.1.1.2
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	apache:1.1.1
	apache_1_2_6:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.18;

1.18
date	2011.04.06.11.35.33;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.14.19.35.38;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2008.05.25.11.46.27;	author mbalmer;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.09.08.06.28;	author mbalmer;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.09.12.13.10;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.17.18.57.05;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.21.13.11.36;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.08.18.24.57;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.08.18.21.17;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.19.21.31.16;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.29.02.08.06;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.29.10.21.45;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.22.18.15;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.25.18.29.52;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.06.29.43;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.03.01.01.06.28;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.03.25.07.08.50;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.25.07.08.50;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.10.01.17.19.42;	author beck;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.07.19.21.28.56;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.21.12.53.40;	author henning;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.17.17.03.22;	author henning;	state Exp;
branches;
next	;


desc
@@


1.19
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*	$OpenBSD: proxy_ftp.c,v 1.18 2011/04/06 11:35:33 miod Exp $ */

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/* FTP routines for Apache proxy */

#include "mod_proxy.h"
#include "http_main.h"
#include "http_log.h"
#include "http_core.h"

#define AUTODETECT_PWD

/*
 * Decodes a '%' escaped string, and returns the number of characters
 */
static int decodeenc(char *x)
{
    int i, j, ch;

    if (x[0] == '\0')
        return 0;               /* special case for no characters */
    for (i = 0, j = 0; x[i] != '\0'; i++, j++) {
/* decode it if not already done */
        ch = x[i];
        if (ch == '%' && ap_isxdigit(x[i + 1]) && ap_isxdigit(x[i + 2])) {
            ch = ap_proxy_hex2c(&x[i + 1]);
            i += 2;
        }
        x[j] = ch;
    }
    x[j] = '\0';
    return j;
}

/*
 * checks an encoded ftp string for bad characters, namely, CR, LF or
 * non-ascii character
 */
static int ftp_check_string(const char *x)
{
    int i, ch;

    for (i = 0; x[i] != '\0'; i++) {
        ch = x[i];
        if (ch == '%' && ap_isxdigit(x[i + 1]) && ap_isxdigit(x[i + 2])) {
            ch = ap_proxy_hex2c(&x[i + 1]);
            i += 2;
        }
        if (ch == CR || ch == LF || (OS_ASC(ch) & 0x80))
            return 0;
    }
    return 1;
}

/*
 * Canonicalise ftp URLs.
 */
int ap_proxy_ftp_canon(request_rec *r, char *url)
{
    char *user, *password, *host, *path, *parms, *strp, sport[7];
    pool *p = r->pool;
    const char *err;
    int port;

    port = DEFAULT_FTP_PORT;
    err = ap_proxy_canon_netloc(p, &url, &user, &password, &host, &port);
    if (err)
        return HTTP_BAD_REQUEST;
    if (user != NULL && !ftp_check_string(user))
        return HTTP_BAD_REQUEST;
    if (password != NULL && !ftp_check_string(password))
        return HTTP_BAD_REQUEST;

/* now parse path/parameters args, according to rfc1738 */
/* N.B. if this isn't a true proxy request, then the URL path
 * (but not query args) has already been decoded.
 * This gives rise to the problem of a ; being decoded into the
 * path.
 */
    strp = strchr(url, ';');
    if (strp != NULL) {
        *(strp++) = '\0';
        parms = ap_proxy_canonenc(p, strp, strlen(strp), enc_parm,
                                  r->proxyreq);
        if (parms == NULL)
            return HTTP_BAD_REQUEST;
    }
    else
        parms = "";

    path = ap_proxy_canonenc(p, url, strlen(url), enc_path, r->proxyreq);
    if (path == NULL)
        return HTTP_BAD_REQUEST;
    if (!ftp_check_string(path))
        return HTTP_BAD_REQUEST;

    if (r->proxyreq == NOT_PROXY && r->args != NULL) {
        if (strp != NULL) {
            strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_parm, STD_PROXY);
            if (strp == NULL)
                return HTTP_BAD_REQUEST;
            parms = ap_pstrcat(p, parms, "?", strp, NULL);
        }
        else {
            strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_fpath, STD_PROXY);
            if (strp == NULL)
                return HTTP_BAD_REQUEST;
            path = ap_pstrcat(p, path, "?", strp, NULL);
        }
        r->args = NULL;
    }

/* now, rebuild URL */

    if (port != DEFAULT_FTP_PORT)
        ap_snprintf(sport, sizeof(sport), ":%d", port);
    else
        sport[0] = '\0';

    r->filename = ap_pstrcat(p, "proxy:ftp://", (user != NULL) ? user : "",
                             (password != NULL) ? ":" : "",
                             (password != NULL) ? password : "",
                          (user != NULL) ? "@@" : "", host, sport, "/", path,
                             (parms[0] != '\0') ? ";" : "", parms, NULL);

    return OK;
}

/*
 * Returns the ftp status code;
 *  or -1 on I/O error, 0 on data error
 */
static int ftp_getrc(BUFF *ctrl)
{
    int len, status;
    char linebuff[100], buff[5];

    len = ap_bgets(linebuff, sizeof linebuff, ctrl);
    if (len == -1)
        return -1;
/* check format */
    if (len < 5 || !ap_isdigit(linebuff[0]) || !ap_isdigit(linebuff[1]) ||
     !ap_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
        status = 0;
    else
        status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';

    if (linebuff[len - 1] != '\n') {
        (void)ap_bskiplf(ctrl);
    }

/* skip continuation lines */
    if (linebuff[3] == '-') {
        memcpy(buff, linebuff, 3);
        buff[3] = ' ';
        do {
            len = ap_bgets(linebuff, sizeof linebuff, ctrl);
            if (len == -1)
                return -1;
            if (linebuff[len - 1] != '\n') {
                (void)ap_bskiplf(ctrl);
            }
        } while (memcmp(linebuff, buff, 4) != 0);
    }

    return status;
}

/*
 * Like ftp_getrc but returns both the ftp status code and
 * remembers the response message in the supplied buffer
 */
static int ftp_getrc_msg(BUFF *ctrl, char *msgbuf, int msglen)
{
    int len, status;
    char linebuff[100], buff[5];
    char *mb = msgbuf, *me = &msgbuf[msglen];

    len = ap_bgets(linebuff, sizeof linebuff, ctrl);
    if (len == -1)
        return -1;
    if (len < 5 || !ap_isdigit(linebuff[0]) || !ap_isdigit(linebuff[1]) ||
     !ap_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
        status = 0;
    else
        status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';

    mb = ap_cpystrn(mb, linebuff + 4, me - mb);

    if (linebuff[len - 1] != '\n')
        (void)ap_bskiplf(ctrl);

    if (linebuff[3] == '-') {
        memcpy(buff, linebuff, 3);
        buff[3] = ' ';
        do {
            len = ap_bgets(linebuff, sizeof linebuff, ctrl);
            if (len == -1)
                return -1;
            if (linebuff[len - 1] != '\n') {
                (void)ap_bskiplf(ctrl);
            }
            mb = ap_cpystrn(mb, linebuff + 4, me - mb);
        } while (memcmp(linebuff, buff, 4) != 0);
    }
    return status;
}

static long int send_dir(BUFF *data, request_rec *r, cache_req *c, char *cwd)
{
    char *buf, *buf2;
    size_t buf_size;
    char *filename;
    int searchidx = 0;
    char *searchptr = NULL;
    int firstfile = 1;
    unsigned long total_bytes_sent = 0;
    int n;
    conn_rec *con = r->connection;
    pool *p = r->pool;
    char *dir, *path, *reldir, *site, *type = NULL;
    char *basedir = "";         /* By default, path is relative to the $HOME
                                 * dir */

    /* create default sized buffers for the stuff below */
    buf_size = IOBUFSIZE;
    buf = ap_palloc(r->pool, buf_size);
    buf2 = ap_palloc(r->pool, buf_size);

    /* Save "scheme://site" prefix without password */
    site = ap_unparse_uri_components(p, &r->parsed_uri, UNP_OMITPASSWORD | UNP_OMITPATHINFO);
    /* ... and path without query args */
    path = ap_unparse_uri_components(p, &r->parsed_uri, UNP_OMITSITEPART | UNP_OMITQUERY);

    /* If path began with /%2f, change the basedir */
    if (strncasecmp(path, "/%2f", 4) == 0) {
        basedir = "/%2f";
    }

    /* Strip off a type qualifier. It is ignored for dir listings */
    if ((type = strstr(path, ";type=")) != NULL)
        *type++ = '\0';

    (void)decodeenc(path);

    while (path[1] == '/')      /* collapse multiple leading slashes to one */
        ++path;

    /* Copy path, strip (all except the last) trailing slashes */
    /* (the trailing slash is needed for the dir component loop below) */
    path = dir = ap_pstrcat(r->pool, path, "/", NULL);
    for (n = strlen(path); n > 1 && path[n - 1] == '/' && path[n - 2] == '/'; --n)
        path[n - 1] = '\0';

    /* print "ftp://host/" */
    n = ap_snprintf(buf, buf_size, DOCTYPE_HTML_3_2
                    "<html><head><title>%s%s%s</title>\n"
                    "<base href=\"%s%s%s\"></head>\n"
                    "<body><h2>Directory of "
                    "<a href=\"/\">%s</a>/",
                    site, basedir, ap_escape_html(p, path),
                    site, basedir, ap_escape_uri(p, path),
                    site);
    total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);

    /* Add a link to the root directory (if %2f hack was used) */
    if (basedir[0] != '\0') {
        total_bytes_sent += ap_proxy_bputs2("<a href=\"/%2f/\">%2f</a>/", con->client, c);
    }

    for (dir = path + 1; (dir = strchr(dir, '/')) != NULL;) {
        *dir = '\0';
        if ((reldir = strrchr(path + 1, '/')) == NULL) {
            reldir = path + 1;
        }
        else
            ++reldir;
        /* print "path/" component */
        ap_snprintf(buf, buf_size, "<a href=\"%s%s/\">%s</a>/",
                    basedir,
                    ap_escape_uri(p, path),
                    ap_escape_html(p, reldir));
        total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);
        *dir = '/';
        while (*dir == '/')
            ++dir;
    }

    /* If the caller has determined the current directory, and it differs */
    /* from what the client requested, then show the real name */
    if (cwd == NULL || strncmp(cwd, path, strlen(cwd)) == 0) {
        ap_snprintf(buf, buf_size, "</h2>\n<hr /><pre>");
    }
    else {
        ap_snprintf(buf, buf_size, "</h2>\n(%s)\n<hr /><pre>",
                    ap_escape_html(p, cwd));
    }
    total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);

    while (!con->aborted) {
        n = ap_bgets(buf, buf_size, data);
        if (n == -1) {          /* input error */
            if (c != NULL) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                              "proxy: error reading from %s", c->url);
                c = ap_proxy_cache_error(c);
            }
            break;
        }
        if (n == 0)
            break;              /* EOF */

        if (buf[n - 1] == '\n') /* strip trailing '\n' */
            buf[--n] = '\0';
        if (buf[n - 1] == '\r') /* strip trailing '\r' if present */
            buf[--n] = '\0';

        /* Handle unix-style symbolic link */
        if (buf[0] == 'l' && (filename = strstr(buf, " -> ")) != NULL) {
            char *link_ptr = filename;

            do {
                filename--;
            } while (filename[0] != ' ' && filename > buf);
            if (filename != buf)
                *(filename++) = '\0';
            *(link_ptr++) = '\0';
            ap_snprintf(buf2, buf_size, "%s <a href=\"%s\">%s %s</a>\n",
                        ap_escape_html(p, buf),
                        ap_escape_uri(p, filename),
                        ap_escape_html(p, filename),
                        ap_escape_html(p, link_ptr));
            ap_cpystrn(buf, buf2, buf_size);
            n = strlen(buf);
        }
        /* Handle unix style or DOS style directory  */
        else if (buf[0] == 'd' || buf[0] == '-' || buf[0] == 'l' || ap_isdigit(buf[0])) {
            if (ap_isdigit(buf[0])) {   /* handle DOS dir */
                searchptr = strchr(buf, '<');
                if (searchptr != NULL)
                    *searchptr = '[';
                searchptr = strchr(buf, '>');
                if (searchptr != NULL)
                    *searchptr = ']';
            }

            filename = strrchr(buf, ' ');
            *(filename++) = 0;

            /* handle filenames with spaces in 'em */
            if (!strcmp(filename, ".") || !strcmp(filename, "..") || firstfile) {
                firstfile = 0;
                searchidx = filename - buf;
            }
            else if (searchidx != 0 && buf[searchidx] != 0) {
                *(--filename) = ' ';
                buf[searchidx - 1] = 0;
                filename = &buf[searchidx];
            }

            /* Special handling for '.' and '..': append slash to link */
            if (!strcmp(filename, ".") || !strcmp(filename, "..") || buf[0] == 'd') {
                ap_snprintf(buf2, buf_size, "%s <a href=\"%s/\">%s</a>\n",
                         ap_escape_html(p, buf), ap_escape_uri(p, filename),
                            ap_escape_html(p, filename));
            }
            else {
                ap_snprintf(buf2, buf_size, "%s <a href=\"%s\">%s</a>\n",
                            ap_escape_html(p, buf),
                            ap_escape_uri(p, filename),
                            ap_escape_html(p, filename));
            }
            ap_cpystrn(buf, buf2, buf_size);
            n = strlen(buf);
        }
        /* else??? What about other OS's output formats? */
        else {
            strlcat(buf, "\n", buf_size);  /* re-append the newline char */
            ap_cpystrn(buf, ap_escape_html(p, buf), buf_size);
        }

        total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);

        ap_reset_timeout(r);    /* reset timeout after successfule write */
    }

    total_bytes_sent += ap_proxy_bputs2("</pre><hr />\n", con->client, c);
    total_bytes_sent += ap_proxy_bputs2(ap_psignature("", r), con->client, c);
    total_bytes_sent += ap_proxy_bputs2("</body></html>\n", con->client, c);

    ap_bclose(data);

    ap_bflush(con->client);

    return total_bytes_sent;
}

/* Common routine for failed authorization (i.e., missing or wrong password)
 * to an ftp service. This causes most browsers to retry the request
 * with username and password (which was presumably queried from the user)
 * supplied in the Authorization: header.
 * Note that we "invent" a realm name which consists of the
 * ftp://user@@host part of the reqest (sans password -if supplied but invalid-)
 */
static int ftp_unauthorized(request_rec *r, int log_it)
{
    r->proxyreq = NOT_PROXY;
    /*
     * Log failed requests if they supplied a password (log username/password
     * guessing attempts)
     */
    if (log_it)
        ap_log_rerror(APLOG_MARK, APLOG_INFO | APLOG_NOERRNO, r,
                      "proxy: missing or failed auth to %s",
                      ap_unparse_uri_components(r->pool,
                                         &r->parsed_uri, UNP_OMITPATHINFO));

    ap_table_setn(r->err_headers_out, "WWW-Authenticate",
                  ap_pstrcat(r->pool, "Basic realm=\"",
                          ap_unparse_uri_components(r->pool, &r->parsed_uri,
                                       UNP_OMITPASSWORD | UNP_OMITPATHINFO),
                             "\"", NULL));

    return HTTP_UNAUTHORIZED;
}

/* Set ftp server to TYPE {A,I,E} before transfer of a directory or file */
static int ftp_set_TYPE(request_rec *r, BUFF *ctrl, char xfer_type)
{
    static char old_type[2] = {'A', '\0'};      /* After logon, mode is ASCII */
    int ret = HTTP_OK;
    int rc;

    if (xfer_type == old_type[0])
        return ret;

    /* set desired type */
    old_type[0] = xfer_type;
    ap_bvputs(ctrl, "TYPE ", old_type, CRLF, NULL);
    ap_bflush(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: TYPE %s", old_type);

/* responses: 200, 421, 500, 501, 504, 530 */
    /* 200 Command okay. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 504 Command not implemented for that parameter. */
    /* 530 Not logged in. */
    rc = ftp_getrc(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
    if (rc == -1 || rc == 421) {
        ap_kill_timeout(r);
        ret = ap_proxyerror(r, HTTP_BAD_GATEWAY,
                            "Error reading from remote server");
    }
    else if (rc != 200 && rc != 504) {
        ap_kill_timeout(r);
        ret = ap_proxyerror(r, HTTP_BAD_GATEWAY,
                            "Unable to set transfer type");
    }
/* Allow not implemented */
    else if (rc == 504)
         /* ignore it silently */ ;

    return ret;
}

/* Common cleanup routine: close open BUFFers or sockets, and return an error */
static int ftp_cleanup_and_return(request_rec *r, BUFF *ctrl, BUFF *data, int csock, int dsock, int rc)
{
    if (ctrl != NULL)
        ap_bclose(ctrl);
    else if (csock != -1)
        ap_pclosesocket(r->pool, csock);

    if (data != NULL)
        ap_bclose(data);
    else if (dsock != -1)
        ap_pclosesocket(r->pool, dsock);

    ap_kill_timeout(r);

    return rc;
}

/*
 * Handles direct access of ftp:// URLs
 * Original (Non-PASV) version from
 * Troy Morrison <spiffnet@@zoom.com>
 * PASV added by Chuck
 */
int ap_proxy_ftp_handler(request_rec *r, cache_req *c, char *url)
{
    char *desthost, *path, *strp, *parms;
    char *strp2;
    char *cwd = NULL;
    char *user = NULL;
/*    char *account = NULL; how to supply an account in a URL? */
    const char *password = NULL;
    const char *err;
    int destport, i, j, len, rc, nocache = 0;
    int csd = 0, sock = -1, dsock = -1;
    struct sockaddr_storage server;
    struct addrinfo hints, *res, *res0;
    char portbuf[10];
    int error;
    struct in_addr destaddr;
    table *resp_hdrs;
    BUFF *ctrl = NULL;
    BUFF *data = NULL;
    pool *p = r->pool;
    char *destportstr = NULL;
    const char *urlptr = NULL;
    int one = 1;
    NET_SIZE_T clen;
    char xfer_type = 'A';       /* after ftp login, the default is ASCII */
    int get_dirlisting = 0;

    void *sconf = r->server->module_config;
    proxy_server_conf *conf =
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
    struct noproxy_entry *npent = (struct noproxy_entry *) conf->noproxies->elts;
    struct nocache_entry *ncent = (struct nocache_entry *) conf->nocaches->elts;

/* stuff for PASV mode */
    unsigned int presult, h0, h1, h2, h3, p0, p1;
    unsigned int paddr;
    unsigned short pport;
    struct sockaddr_storage data_addr;
    struct sockaddr_in *sin;
    int pasvmode = 0;
    char pasv[64];
    char *pstr, *host;
    int port;

/* stuff for LPSV/EPSV */
    unsigned int paf, holen, ho[16], polen, po[2];
    struct sockaddr_in6 *sin6;
    int lpsvmode = 0;
    char *cmd;

/* stuff for responses */
    char resp[MAX_STRING_LEN];
    char *size = NULL;

/* we only support GET and HEAD */

    if (r->method_number != M_GET)
        return HTTP_NOT_IMPLEMENTED;

/* We break the URL into host, port, path-search */

    host = r->parsed_uri.hostname;
    port = (r->parsed_uri.port != 0)
        ? r->parsed_uri.port
        : ap_default_port_for_request(r);
    path = ap_pstrdup(p, r->parsed_uri.path);
    if (path == NULL)
        path = "";
    else
        while (*path == '/')
            ++path;

    urlptr = strstr(url, "://");
    if (urlptr == NULL)
        return HTTP_BAD_REQUEST;
    urlptr += 3;
    destport = 21;
    strp = strchr(urlptr, '/');
    if (strp == NULL) {
        desthost = ap_pstrdup(p, urlptr);
        urlptr = "/";
    }
    else {
        char *q = ap_palloc(p, strp - urlptr + 1);
        memcpy(q, urlptr, strp - urlptr);
        q[strp - urlptr] = '\0';
        urlptr = strp;
        desthost = q;
    }

    strp2 = strchr(desthost, ':');
    if (strp2 != NULL) {
        *(strp2++) = '\0';
        if (ap_isdigit(*strp2)) {
            destport = atoi(strp2);
            destportstr = strp2;
        }
    }
    path = strchr(urlptr, '/')+1;
    
    /*
     * The "Authorization:" header must be checked first. We allow the user
     * to "override" the URL-coded user [ & password ] in the Browsers'
     * User&Password Dialog. NOTE that this is only marginally more secure
     * than having the password travel in plain as part of the URL, because
     * Basic Auth simply uuencodes the plain text password. But chances are
     * still smaller that the URL is logged regularly.
     */
    if ((password = ap_table_get(r->headers_in, "Authorization")) != NULL
        && strcasecmp(ap_getword(r->pool, &password, ' '), "Basic") == 0
        && (password = ap_pbase64decode(r->pool, password))[0] != ':') {
        /*
         * Note that this allocation has to be made from r->connection->pool
         * because it has the lifetime of the connection.  The other
         * allocations are temporary and can be tossed away any time.
         */
        user = ap_getword_nulls(r->connection->pool, &password, ':');
        r->connection->ap_auth_type = "Basic";
        r->connection->user = r->parsed_uri.user = user;
        nocache = 1;            /* This resource only accessible with
                                 * username/password */
    }
    else if ((user = r->parsed_uri.user) != NULL) {
        user = ap_pstrdup(p, user);
        decodeenc(user);
        if ((password = r->parsed_uri.password) != NULL) {
            char *tmp = ap_pstrdup(p, password);
            decodeenc(tmp);
            password = tmp;
        }
        nocache = 1;            /* This resource only accessible with
                                 * username/password */
    }
    else {
        user = "anonymous";
        password = "apache_proxy@@";
    }

    /* check if ProxyBlock directive on this host */
    destaddr.s_addr = ap_inet_addr(desthost);
    for (i = 0; i < conf->noproxies->nelts; i++) {
        if (destaddr.s_addr == npent[i].addr.s_addr ||
            (npent[i].name != NULL &&
          (npent[i].name[0] == '*' || strstr(desthost, npent[i].name) != NULL)))
            return ap_proxyerror(r, HTTP_FORBIDDEN,
                                 "Connect to remote machine blocked");
    }

    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: connect to %s:%d", desthost, destport);

    parms = strchr(url, ';');
    if (parms != NULL)
        *(parms++) = '\0';

    ap_snprintf(portbuf, sizeof(portbuf), "%d", port);
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    error = getaddrinfo(host, portbuf, &hints, &res0);
    if (error) {
        return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
           gai_strerror(error));
    }

    i = -1;
    for (res = res0; res; res = res->ai_next) {
      dsock = ap_psocket(p, server.ss_family, SOCK_STREAM, res->ai_protocol);
       if (sock == -1)
           continue;

    if (conf->recv_buffer_size > 0
        && setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
                      (const char *)&conf->recv_buffer_size, sizeof(int))
        == -1) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                      "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
    }

    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *)&one,
                   sizeof(one)) == -1) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
         "proxy: error setting reuseaddr option: setsockopt(SO_REUSEADDR)");
        ap_pclosesocket(p, sock);
            freeaddrinfo(res0);
        return HTTP_INTERNAL_SERVER_ERROR;
    }

        i = ap_proxy_doconnect(sock, res->ai_addr, r);
        if (i == 0){
            memcpy(&server, res->ai_addr, res->ai_addrlen);
            break;
        }
        ap_pclosesocket(p, sock);
    }
    freeaddrinfo(res0);
    if (i == -1) {
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                      ap_proxyerror(r, HTTP_BAD_GATEWAY, ap_pstrcat(r->pool,
                                    "Could not connect to remote machine: ",
                                                   strerror(errno), NULL)));
    }

    /* record request_time for HTTP/1.1 age calculation */
    c->req_time = time(NULL);

    ctrl = ap_bcreate(p, B_RDWR | B_SOCKET);
    ap_bpushfd(ctrl, sock, sock);
/* shouldn't we implement telnet control options here? */


    /* possible results: */
    /* 120 Service ready in nnn minutes. */
    /* 220 Service ready for new user. */
    /* 421 Service not available, closing control connection. */
    ap_hard_timeout("proxy ftp", r);
    i = ftp_getrc_msg(ctrl, resp, sizeof resp);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
    if (i == -1 || i == 421) {
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
    }
    if (i != 220) {
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                  ap_proxyerror(r, HTTP_BAD_GATEWAY, resp));
    }

    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: connected.");

    ap_bvputs(ctrl, "USER ", user, CRLF, NULL);
    ap_bflush(ctrl);            /* capture any errors */
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: USER %s", user);

    /* possible results; 230, 331, 332, 421, 500, 501, 530 */
    /* states: 1 - error, 2 - success; 3 - send password, 4,5 fail */
    /* 230 User logged in, proceed. */
    /* 331 User name okay, need password. */
    /* 332 Need account for login. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* (This may include errors such as command line too long.) */
    /* 501 Syntax error in parameters or arguments. */
    /* 530 Not logged in. */
    i = ftp_getrc(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
    if (i == -1 || i == 421) {
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
    }
    if (i == 530) {
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      ftp_unauthorized(r, 1));
    }
    if (i != 230 && i != 331) {
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      HTTP_BAD_GATEWAY);
    }

    if (i == 331) {             /* send password */
        if (password == NULL) {
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ftp_unauthorized(r, 0));
        }
        ap_bvputs(ctrl, "PASS ", password, CRLF, NULL);
        ap_bflush(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PASS %s", password);
        /* possible results 202, 230, 332, 421, 500, 501, 503, 530 */
        /* 230 User logged in, proceed. */
        /* 332 Need account for login. */
        /* 421 Service not available, closing control connection. */
        /* 500 Syntax error, command unrecognized. */
        /* 501 Syntax error in parameters or arguments. */
        /* 503 Bad sequence of commands. */
        /* 530 Not logged in. */
        i = ftp_getrc(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
        if (i == -1 || i == 421) {
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
        }
        if (i == 332) {
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_UNAUTHORIZED,
                                                 "Need account for login"));
        }
        /* @@@@@@ questionable -- we might as well return a 403 Forbidden here */
        if (i == 530)           /* log it: passwd guessing attempt? */
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ftp_unauthorized(r, 1));
        if (i != 230 && i != 202)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_BAD_GATEWAY);
    }

    /*
     * Special handling for leading "%2f": this enforces a "cwd /" out of the
     * $HOME directory which was the starting point after login
     */
    if (strncasecmp(path, "%2f", 3) == 0) {
        path += 3;
        while (*path == '/')    /* skip leading '/' (after root %2f) */
            ++path;
        ap_bputs("CWD /" CRLF, ctrl);
        ap_bflush(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: CWD /");

        /* possible results: 250, 421, 500, 501, 502, 530, 550 */
        /* 250 Requested file action okay, completed. */
        /* 421 Service not available, closing control connection. */
        /* 500 Syntax error, command unrecognized. */
        /* 501 Syntax error in parameters or arguments. */
        /* 502 Command not implemented. */
        /* 530 Not logged in. */
        /* 550 Requested action not taken. */
        i = ftp_getrc(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
        if (i == -1 || i == 421)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
        else if (i == 550)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_NOT_FOUND);
        else if (i != 250)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_BAD_GATEWAY);
    }

/* set the directory (walk directory component by component):
 * this is what we must do if we don't know the OS type of the remote
 * machine
 */
    for (; (strp = strchr(path, '/')) != NULL; path = strp + 1) {
        char *slash = strp;

        *slash = '\0';

        /* Skip multiple '/' (or trailing '/') to avoid 500 errors */
        while (strp[1] == '/')
            ++strp;
        if (strp[1] == '\0')
            break;

        len = decodeenc(path);  /* Note! This decodes a %2f -> "/" */
        if (strchr(path, '/'))  /* were there any '/' characters? */
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_REQUEST,
                       "Use of %2F is only allowed at the base directory"));

        ap_bvputs(ctrl, "CWD ", path, CRLF, NULL);
        ap_bflush(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: CWD %s", path);
        *slash = '/';

/* responses: 250, 421, 500, 501, 502, 530, 550 */
        /* 250 Requested file action okay, completed. */
        /* 421 Service not available, closing control connection. */
        /* 500 Syntax error, command unrecognized. */
        /* 501 Syntax error in parameters or arguments. */
        /* 502 Command not implemented. */
        /* 530 Not logged in. */
        /* 550 Requested action not taken. */
        i = ftp_getrc(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
        if (i == -1 || i == 421)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
        if (i == 550)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_NOT_FOUND);
        if (i == 500 || i == 501)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_REQUEST,
                      "Syntax error in filename (reported by ftp server)"));
        if (i != 250)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_BAD_GATEWAY);
    }

    if (parms != NULL && strncmp(parms, "type=", 5) == 0
        && ap_isalpha(parms[5])) {
        /*
         * "type=d" forces a dir listing. The other types (i|a|e) are
         * directly used for the ftp TYPE command
         */
        if (!(get_dirlisting = (parms[5] == 'd')))
            xfer_type = ap_toupper(parms[5]);

        /* Check valid types, rather than ignoring invalid types silently: */
        if (strchr("AEI", xfer_type) == NULL)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                      ap_proxyerror(r, HTTP_BAD_REQUEST, ap_pstrcat(r->pool,
                       "ftp proxy supports only types 'a', 'i', or 'e': \"",
                                           parms, "\" is invalid.", NULL)));
    }
    else {
        /* make binary transfers the default */
        xfer_type = 'I';
    }

/* try to set up PASV data connection first */
    dsock = ap_psocket_ex(p, PF_INET, SOCK_STREAM, IPPROTO_TCP, 1);
    if (dsock == -1) {
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
                                      "proxy: error creating PASV socket"));
    }

    if (conf->recv_buffer_size) {
        if (setsockopt(dsock, SOL_SOCKET, SO_RCVBUF,
                (const char *)&conf->recv_buffer_size, sizeof(int)) == -1) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                          "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
        }
    }

lpsvagain:
    if (server.ss_family == AF_INET)
      cmd = "PASV";
    else if (lpsvmode)
      cmd = "LPSV";
    else
      cmd = "EPSV";
    ap_bputs(cmd, ctrl);
    ap_bputs(CRLF, ctrl);
    ap_bflush(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: passive command issued");
/* possible results: 227, 421, 500, 501, 502, 530 */
    /* 227 Entering Passive Mode (h1,h2,h3,h4,p1,p2). */
    /* 228 Entering Long Passive Mode (...). */
    /* 229 Entering Extended Passive Mode (...). */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
    /* 530 Not logged in. */

    i = ap_bgets(pasv, sizeof(pasv), ctrl);
    if (i == -1 || i == 421) {
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
                               "proxy: passive: control connection is toast"));
    }
    else {
        pasv[i - 1] = '\0';
        pstr = strtok(pasv, " ");       /* separate result code */
        if (pstr != NULL) {
            presult = atoi(pstr);
            if (*(pstr + strlen(pstr) + 1) == '=')
                pstr += strlen(pstr) + 2;
            else {
                pstr = strtok(NULL, "(");       /* separate address & port
                                                 * params */
                if (pstr != NULL)
                    pstr = strtok(NULL, ")");
            }
        }
        else
            presult = atoi(pasv);

        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", presult);

        if (presult == 227 && pstr != NULL && (sscanf(pstr,
                 "%d,%d,%d,%d,%d,%d", &h3, &h2, &h1, &h0, &p1, &p0) == 6)) {
            /* pardon the parens, but it makes gcc happy */
            paddr = (((((h3 << 8) + h2) << 8) + h1) << 8) + h0;
            pport = (p1 << 8) + p0;
            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: contacting host %d.%d.%d.%d:%d",
                         h3, h2, h1, h0, pport);
            sin = (struct sockaddr_in *)&data_addr;
            sin->sin_family = AF_INET;
            sin->sin_len = sizeof(*sin);
            sin->sin_addr.s_addr = htonl(paddr);
            sin->sin_port = htons(pport);
            i = ap_proxy_doconnect(dsock, (struct sockaddr *)&data_addr, r);

            if (i == -1) {
                return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                                        ap_pstrcat(r->pool,
                                    "Could not connect to remote machine: ",
                                                   strerror(errno), NULL)));
            }
            pasvmode = 1;
	} else if (presult == 228 && pstr != NULL
		&& sscanf(pstr,
"%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u",
		    &paf, &holen, &ho[0], &ho[1], &ho[2], &ho[3],
		    &ho[4], &ho[5], &ho[6], &ho[7], &ho[8], &ho[9], &ho[10], &ho[11],
		    &ho[12], &ho[13], &ho[14], &ho[15], &polen, &po[0], &po[1]) == 21
		&& paf == 6 && holen == 16 && polen == 2) {
	    int i;
	    sin6 = (struct sockaddr_in6 *)&data_addr;
	    sin6->sin6_family = AF_INET6;
	    sin6->sin6_len = sizeof(*sin6);
	    for (i = 0; i < 16; i++)
		sin6->sin6_addr.s6_addr[i] = ho[i] & 0xff;
	    sin6->sin6_port = htons(((po[0] & 0xff) << 8) | (po[1] & 0xff));
	    i = ap_proxy_doconnect(dsock, (struct sockaddr *)&data_addr, r);

	    if (i == -1) {
		ap_kill_timeout(r);
		return ap_proxyerror(r, HTTP_BAD_GATEWAY,
				     ap_pstrcat(r->pool,
						"Could not connect to remote machine: ",
						strerror(errno), NULL));
	    }
 	    pasvmode = 1;
	} else if (presult == 229 && pstr != NULL
		&& pstr[0] == pstr[1] && pstr[0] == pstr[2]
		&& pstr[0] == pstr[strlen(pstr) - 1]) {
	    /* expect "|||port|" */
	    memcpy(&data_addr, &server, server.ss_len);
	    switch (data_addr.ss_family) {
	    case AF_INET:
		sin = (struct sockaddr_in *)&data_addr;
		sin->sin_port = htons(atoi(pstr + 3));
		break;
	    case AF_INET6:
		sin6 = (struct sockaddr_in6 *)&data_addr;
		sin6->sin6_port = htons(atoi(pstr + 3));
		break;
	    }
	    i = ap_proxy_doconnect(dsock, (struct sockaddr *)&data_addr, r);

	    if (i == -1) {
		ap_kill_timeout(r);
		return ap_proxyerror(r, HTTP_BAD_GATEWAY,
				     ap_pstrcat(r->pool,
						"Could not connect to remote machine: ",
						strerror(errno), NULL));
	    }
	    pasvmode = 1;
	} else if (!lpsvmode && strcmp(cmd, "EPSV") == 0) {
	    lpsvmode = 1;
	    goto lpsvagain;
        }
        else {
            ap_pclosesocket(p, dsock);  /* and try the regular way */
            dsock = -1;
        }
    }

    if (!pasvmode) {            /* set up data connection */
	clen = sizeof(server);
        if (getsockname(sock, (struct sockaddr *)&server, &clen) < 0) {
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
                                    "proxy: error getting socket address"));
        }

        dsock = ap_psocket_ex(p, server.ss_family, SOCK_STREAM, IPPROTO_TCP, 1);
        if (dsock == -1) {
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
                                           "proxy: error creating socket"));
        }

        if (setsockopt(dsock, SOL_SOCKET, SO_REUSEADDR, (void *)&one,
                       sizeof(one)) == -1) {
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
                                  "proxy: error setting reuseaddr option"));
        }

	if (bind(dsock, (struct sockaddr *) &server, server.ss_len) == -1)
	{
	    char hostnamebuf[MAXHOSTNAMELEN], portnamebuf[MAXHOSTNAMELEN];

	    getnameinfo((struct sockaddr *)&server,
		    server.ss_len,
		hostnamebuf, sizeof(hostnamebuf),
		portnamebuf, sizeof(portnamebuf),
		NI_NUMERICHOST | NI_NUMERICSERV);

            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, 
             ap_psprintf(p, "proxy: error binding to ftp data socket %s:%s",
                         hostnamebuf, portnamebuf)));
        }
        listen(dsock, 2);       /* only need a short queue */
    }

/* set request; "path" holds last path component */
    len = decodeenc(path);
    if (strchr(path, '/'))      /* were there any '/' characters? */
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      ap_proxyerror(r, HTTP_BAD_REQUEST,
                       "Use of %2F is only allowed at the base directory"));

    /* TM - if len == 0 then it must be a directory (you can't RETR nothing) */

    if (len == 0) {
        get_dirlisting = 1;
    }
    else {
        ap_bvputs(ctrl, "SIZE ", path, CRLF, NULL);
        ap_bflush(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: SIZE %s", path);
        i = ftp_getrc_msg(ctrl, resp, sizeof resp);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d with response %s", i, resp);
        if (i != 500) {         /* Size command not recognized */
            if (i == 550) {     /* Not a regular file */
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: SIZE shows this is a directory");
                get_dirlisting = 1;
                ap_bvputs(ctrl, "CWD ", path, CRLF, NULL);
                ap_bflush(ctrl);
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: CWD %s", path);

                /* possible results: 250, 421, 500, 501, 502, 530, 550 */
                /* 250 Requested file action okay, completed. */
                /* 421 Service not available, closing control connection. */
                /* 500 Syntax error, command unrecognized. */
                /* 501 Syntax error in parameters or arguments. */
                /* 502 Command not implemented. */
                /* 530 Not logged in. */
                /* 550 Requested action not taken. */
                i = ftp_getrc(ctrl);
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
                if (i == -1 || i == 421)
                    return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
                if (i == 550)
                    return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                                  HTTP_NOT_FOUND);
                if (i != 250)
                    return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                                  HTTP_BAD_GATEWAY);
                path = "";
                len = 0;
            }
            else if (i == 213) {/* Size command ok */
                for (j = 0; j < sizeof(resp)-1 && ap_isdigit(resp[j]); j++);
                resp[j] = '\0';
                if (resp[0] != '\0')
                    size = ap_pstrdup(p, resp);
            }
        }
    }

#ifdef AUTODETECT_PWD
    ap_bvputs(ctrl, "PWD", CRLF, NULL);
    ap_bflush(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PWD");
/* responses: 257, 500, 501, 502, 421, 550 */
    /* 257 "<directory-name>" <commentary> */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
    /* 550 Requested action not taken. */
    i = ftp_getrc_msg(ctrl, resp, sizeof resp);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PWD returned status %d", i);
    if (i == -1 || i == 421)
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
    if (i == 550)
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      HTTP_NOT_FOUND);
    if (i == 257) {
        const char *dirp = resp;
        cwd = ap_getword_conf(r->pool, &dirp);
    }
#endif                          /* AUTODETECT_PWD */

    if (get_dirlisting) {
        if (len != 0)
            ap_bvputs(ctrl, "LIST ", path, CRLF, NULL);
        else
            ap_bputs("LIST -lag" CRLF, ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: LIST %s", (len == 0 ? "" : path));
    }
    else {
        ftp_set_TYPE(r, ctrl, xfer_type);
        ap_bvputs(ctrl, "RETR ", path, CRLF, NULL);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: RETR %s", path);
    }
    ap_bflush(ctrl);
/* RETR: 110, 125, 150, 226, 250, 421, 425, 426, 450, 451, 500, 501, 530, 550
   NLST: 125, 150, 226, 250, 421, 425, 426, 450, 451, 500, 501, 502, 530 */
    /* 110 Restart marker reply. */
    /* 125 Data connection already open; transfer starting. */
    /* 150 File status okay; about to open data connection. */
    /* 226 Closing data connection. */
    /* 250 Requested file action okay, completed. */
    /* 421 Service not available, closing control connection. */
    /* 425 Can't open data connection. */
    /* 426 Connection closed; transfer aborted. */
    /* 450 Requested file action not taken. */
    /* 451 Requested action aborted. Local error in processing. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 530 Not logged in. */
    /* 550 Requested action not taken. */
    rc = ftp_getrc(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
    if (rc == -1 || rc == 421)
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
    if (rc == 550) {
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: RETR failed, trying LIST instead");
        get_dirlisting = 1;
        ftp_set_TYPE(r, ctrl, 'A');     /* directories must be transferred in
                                         * ASCII */

        ap_bvputs(ctrl, "CWD ", path, CRLF, NULL);
        ap_bflush(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: CWD %s", path);
        /* possible results: 250, 421, 500, 501, 502, 530, 550 */
        /* 250 Requested file action okay, completed. */
        /* 421 Service not available, closing control connection. */
        /* 500 Syntax error, command unrecognized. */
        /* 501 Syntax error in parameters or arguments. */
        /* 502 Command not implemented. */
        /* 530 Not logged in. */
        /* 550 Requested action not taken. */
        rc = ftp_getrc(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
        if (rc == -1 || rc == 421)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
        if (rc == 550)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_NOT_FOUND);
        if (rc != 250)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_BAD_GATEWAY);

#ifdef AUTODETECT_PWD
        ap_bvputs(ctrl, "PWD", CRLF, NULL);
        ap_bflush(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PWD");
/* responses: 257, 500, 501, 502, 421, 550 */
        /* 257 "<directory-name>" <commentary> */
        /* 421 Service not available, closing control connection. */
        /* 500 Syntax error, command unrecognized. */
        /* 501 Syntax error in parameters or arguments. */
        /* 502 Command not implemented. */
        /* 550 Requested action not taken. */
        i = ftp_getrc_msg(ctrl, resp, sizeof resp);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PWD returned status %d", i);
        if (i == -1 || i == 421)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
        if (i == 550)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_NOT_FOUND);
        if (i == 257) {
            const char *dirp = resp;
            cwd = ap_getword_conf(r->pool, &dirp);
        }
#endif                          /* AUTODETECT_PWD */

        ap_bputs("LIST -lag" CRLF, ctrl);
        ap_bflush(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: LIST -lag");
        rc = ftp_getrc(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
        if (rc == -1 || rc == 421)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
    }
    ap_kill_timeout(r);
    if (rc != 125 && rc != 150 && rc != 226 && rc != 250)
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      HTTP_BAD_GATEWAY);

    r->status = HTTP_OK;
    r->status_line = "200 OK";

    resp_hdrs = ap_make_table(p, 2);
    c->hdrs = resp_hdrs;

    ap_table_setn(resp_hdrs, "Date", ap_gm_timestr_822(r->pool, r->request_time));
    ap_table_setn(resp_hdrs, "Server", ap_get_server_version());

    if (get_dirlisting) {
        ap_table_setn(resp_hdrs, "Content-Type", "text/html");
    }
    else {
        if (r->content_type != NULL) {
            ap_table_setn(resp_hdrs, "Content-Type", r->content_type);
            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: Content-Type set to %s", r->content_type);
        }
        else {
            ap_table_setn(resp_hdrs, "Content-Type", ap_default_type(r));
        }
        if (xfer_type != 'A' && size != NULL) {
            /* We "trust" the ftp server to really serve (size) bytes... */
            ap_table_set(resp_hdrs, "Content-Length", size);
            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: Content-Length set to %s", size);
        }
    }
    if (r->content_encoding != NULL && r->content_encoding[0] != '\0') {
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: Content-Encoding set to %s", r->content_encoding);
        ap_table_setn(resp_hdrs, "Content-Encoding", r->content_encoding);
    }

/* check if NoCache directive on this host */
    if (nocache == 0) {
        for (i = 0; i < conf->nocaches->nelts; i++) {
            if (destaddr.s_addr == ncent[i].addr.s_addr ||
                (ncent[i].name != NULL &&
                 (ncent[i].name[0] == '*' ||
                  strstr(desthost, ncent[i].name) != NULL))) {
                nocache = 1;
                break;
            }
        }
    }

    i = ap_proxy_cache_update(c, resp_hdrs, 0, nocache);

    if (i != DECLINED) {
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock, i);
    }

    if (!pasvmode) {            /* wait for connection */
        ap_hard_timeout("proxy ftp data connect", r);
        clen = sizeof(server);
        do
            csd = accept(dsock, (struct sockaddr *)&server, &clen);
        while (csd == -1 && errno == EINTR);
        if (csd == -1) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                          "proxy: failed to accept data connection");
            if (c != NULL)
                c = ap_proxy_cache_error(c);
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_BAD_GATEWAY);
        }
        data = ap_bcreate(p, B_RDWR | B_SOCKET);
        ap_bpushfd(data, csd, -1);
        ap_kill_timeout(r);
    }
    else {
        data = ap_bcreate(p, B_RDWR | B_SOCKET);
        ap_bpushfd(data, dsock, dsock);
    }

    ap_hard_timeout("proxy receive", r);

    /* send response */
    /* write status line and headers to the cache file */
    ap_proxy_write_headers(c, ap_pstrcat(p, "HTTP/1.1 ", r->status_line, NULL), resp_hdrs);

    /* Setup the headers for our client from upstreams response-headers */
    ap_overlap_tables(r->headers_out, resp_hdrs, AP_OVERLAP_TABLES_SET);
    /* Add X-Cache header */
    ap_table_setn(r->headers_out, "X-Cache",
                  ap_pstrcat(r->pool, "MISS from ",
                             ap_get_server_name(r), NULL));
    /* The Content-Type of this response is the upstream one. */
    r->content_type = ap_table_get(r->headers_out, "Content-Type");
    /* finally output the headers to the client */
    ap_send_http_header(r);

/* send body */
    if (!r->header_only) {
        if (!get_dirlisting) {
/* we need to set this for ap_proxy_send_fb()... */
            if (c != NULL)
                c->cache_completion = 0;
            ap_proxy_send_fb(data, r, c, -1, 0, 0, conf->io_buffer_size);
        }
        else {
            send_dir(data, r, c, cwd);
        }
        /* ap_proxy_send_fb() closes the socket */
        data = NULL;
        dsock = -1;

        /*
         * We checked for 125||150||226||250 above. See if another rc is
         * pending, and fetch it:
         */
        if (rc == 125 || rc == 150)
            rc = ftp_getrc(ctrl);
    }
    else {
/* abort the transfer: we send the header only */
        ap_bputs("ABOR" CRLF, ctrl);
        ap_bflush(ctrl);
        if (data != NULL) {
            ap_bclose(data);
            data = NULL;
            dsock = -1;
        }
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: ABOR");
/* responses: 225, 226, 421, 500, 501, 502 */
        /* 225 Data connection open; no transfer in progress. */
        /* 226 Closing data connection. */
        /* 421 Service not available, closing control connection. */
        /* 500 Syntax error, command unrecognized. */
        /* 501 Syntax error in parameters or arguments. */
        /* 502 Command not implemented. */
        i = ftp_getrc(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
    }

    ap_kill_timeout(r);
    ap_proxy_cache_tidy(c);

/* finish */
    ap_bputs("QUIT" CRLF, ctrl);
    ap_bflush(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: QUIT");
/* responses: 221, 500 */
    /* 221 Service closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    i = ftp_getrc(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: QUIT: status %d", i);

    ap_bclose(ctrl);

    ap_rflush(r);               /* flush before garbage collection */

    ap_proxy_garbage_coll(r);

    return OK;
}
@


1.18
log
@Local variables storing integer values and printed with %d should be
declared as integer types, not pointers, really.
@
text
@d1 1
a1 1
/*	$OpenBSD: proxy_ftp.c,v 1.17 2009/12/14 19:35:38 deraadt Exp $ */
@


1.17
log
@wrote one byte too far, found by parfait; ok beck millert
@
text
@d1 1
a1 1
/*	$OpenBSD: proxy_ftp.c,v 1.16 2008/05/25 11:46:27 mbalmer Exp $ */
d591 2
a592 1
    char *pstr, *host, *port;
@


1.16
log
@de-register, remove #ifdefs and #ifndefs using SIN6_LEN, add OpenBSD cvs
markers.

no binary changes
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1185 1
a1185 1
                for (j = 0; j < sizeof resp && ap_isdigit(resp[j]); j++);
@


1.15
log
@Add support for IPv6 while keeping the default at IPv4 to not break
existing installations.  See the documentation for the IPv6 related
configuration.

This changes the module ABI since addresses are now struct addrinfo.

This has been tested by many people and run on production machines
for several months.

feedback many, ok todd
@
text
@d1 2
d275 1
a275 1
    register int n;
a1022 1
#ifdef SIN6_LEN
a1023 1
#endif
a1045 1
#ifdef SIN6_LEN
a1046 1
#endif
a1063 3
#ifndef SIN6_LEN
	    memcpy(&data_addr, &server, SA_LEN((struct sockaddr *)&server));
#else
a1064 1
#endif
a1116 3
#ifndef SIN6_LEN
	if (bind(dsock, (struct sockaddr *) &server, SA_LEN((struct sockaddr *)&server)) == -1)
#else
a1117 1
#endif
a1121 3
#ifndef SIN6_LEN
		    SA_LEN((struct sockaddr *)&server),
#else
a1122 1
#endif
@


1.14
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d559 4
a562 2
    struct sockaddr_in server;
    struct hostent server_hp;
d585 2
a586 1
    struct sockaddr_in data_addr;
d589 7
a595 1
    char *pstr;
d608 11
d701 9
a709 6
    memset(&server, 0, sizeof(struct sockaddr_in));
    server.sin_family = AF_INET;
    server.sin_port = htons((unsigned short)destport);
    err = ap_proxy_host2addr(desthost, &server_hp);
    if (err != NULL)
        return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, err);
d711 5
a715 6
    sock = ap_psocket_ex(p, PF_INET, SOCK_STREAM, IPPROTO_TCP, 1);
    if (sock == -1) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                      "proxy: error creating socket");
        return HTTP_INTERNAL_SERVER_ERROR;
    }
d730 1
d734 3
a736 6
    j = 0;
    while (server_hp.h_addr_list[j] != NULL) {
        memcpy(&server.sin_addr, server_hp.h_addr_list[j],
               sizeof(struct in_addr));
        i = ap_proxy_doconnect(sock, &server, r);
        if (i == 0)
d738 2
a739 1
        j++;
d741 1
d966 9
a974 1
    ap_bputs("PASV" CRLF, ctrl);
d976 1
a976 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PASV command issued");
d979 2
d991 1
a991 1
                               "proxy: PASV: control connection is toast"));
d1019 8
a1026 4
            data_addr.sin_family = AF_INET;
            data_addr.sin_addr.s_addr = htonl(paddr);
            data_addr.sin_port = htons(pport);
            i = ap_proxy_doconnect(dsock, &data_addr, r);
d1036 58
d1102 1
a1102 1
        clen = sizeof(struct sockaddr_in);
d1109 1
a1109 1
        dsock = ap_psocket_ex(p, PF_INET, SOCK_STREAM, IPPROTO_TCP, 1);
d1123 22
a1144 7
        if (bind(dsock, (struct sockaddr *)&server,
                 sizeof(struct sockaddr_in)) == -1) {

            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
             ap_psprintf(p, "proxy: error binding to ftp data socket %s:%d",
                         inet_ntoa(server.sin_addr), server.sin_port)));
d1391 1
a1391 1
        clen = sizeof(struct sockaddr_in);
@


1.13
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@a710 12
#ifdef SINIX_D_RESOLVER_BUG
    {
        struct in_addr *ip_addr = (struct in_addr *)*server_hp.h_addr_list;

        for (; ip_addr->s_addr != 0; ++ip_addr) {
            memcpy(&server.sin_addr, ip_addr, sizeof(struct in_addr));
            i = ap_proxy_doconnect(sock, &server, r);
            if (i == 0)
                break;
        }
    }
#else
a719 1
#endif
a746 18
#if 0
    if (i == 120) {
        /*
         * RFC2068 states: 14.38 Retry-After
         * 
         * The Retry-After response-header field can be used with a 503 (Service
         * Unavailable) response to indicate how long the service is expected
         * to be unavailable to the requesting client. The value of this
         * field can be either an HTTP-date or an integer number of seconds
         * (in decimal) after the time of the response. Retry-After  =
         * "Retry-After" ":" ( HTTP-date | delta-seconds )
         */
/**INDENT** Error@@756: Unbalanced parens */
        ap_set_header("Retry-After", ap_psprintf(p, "%u", 60 * wait_mins);
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                          ap_proxyerror(r, HTTP_SERVICE_UNAVAILABLE, resp));
    }
#endif
@


1.12
log
@merge apache 1.3.29 and mod_ssl 2.8.16
ok brad@@
@
text
@a694 1
#if !defined(TPF) && !defined(BEOS)
a701 1
#endif
a704 1
#ifndef _OSD_POSIX              /* BS2000 has this option "always on" */
a708 1
#endif                          /* _OSD_POSIX */
a746 3
#ifdef CHARSET_EBCDIC
    ap_bsetflag(ctrl, B_ASCII2EBCDIC | B_EBCDIC2ASCII, 1);
#endif                          /* CHARSET_EBCDIC */
a966 1
#if !defined (TPF) && !defined(BEOS)
a973 1
#endif
a1054 1
#ifndef _OSD_POSIX              /* BS2000 has this option "always on" */
a1057 1
#endif                          /* _OSD_POSIX */
a1271 3
#ifdef CHARSET_EBCDIC
        r->ebcdic.conv_out = 1; /* server-generated */
#endif
a1273 4
#ifdef CHARSET_EBCDIC
        r->ebcdic.conv_out = 0; /* do not convert what we read from the ftp
                                 * server */
#endif
a1350 3
#ifdef CHARSET_EBCDIC
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out);
#endif
@


1.11
log
@merge
@
text
@d550 2
a551 1
    char *host, *path, *strp, *parms;
d557 1
a557 1
    int port, i, j, len, rc, nocache = 0;
d566 2
d599 28
a626 11
    host = r->parsed_uri.hostname;
    port = (r->parsed_uri.port != 0)
        ? r->parsed_uri.port
        : ap_default_port_for_request(r);
    path = ap_pstrdup(p, r->parsed_uri.path);
    if (path == NULL)
        path = "";
    else
        while (*path == '/')
            ++path;

d666 1
a666 1
    destaddr.s_addr = ap_inet_addr(host);
d670 1
a670 1
          (npent[i].name[0] == '*' || strstr(host, npent[i].name) != NULL)))
d675 1
a675 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: connect to %s:%d", host, port);
d677 1
a677 1
    parms = strchr(path, ';');
d683 2
a684 2
    server.sin_port = htons((unsigned short)port);
    err = ap_proxy_host2addr(host, &server_hp);
d1316 1
a1316 1
                  strstr(host, ncent[i].name) != NULL))) {
@


1.10
log
@yes I am a dork
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
d668 1
a668 1
    sock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);
d947 1
a947 1
    dsock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);
d1035 1
a1035 1
        dsock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);
@


1.9
log
@string fixes; pval agrees
@
text
@d433 1
a433 1
            strlcat(buf, buf_size, "\n");  /* re-append the newline char */
@


1.8
log
@merge
@
text
@d433 1
a433 1
            strcat(buf, "\n");  /* re-append the newline char */
@


1.7
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d76 1
a76 1
        return 0;                /* special case for no characters */
d176 2
a177 2
                               (password != NULL) ? ":" : "",
                               (password != NULL) ? password : "",
d179 1
a179 1
                               (parms[0] != '\0') ? ";" : "", parms, NULL);
d198 1
a198 1
        !ap_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
d225 1
a225 1
 * Like ftp_getrc but returns both the ftp status code and 
d232 1
a232 2
    char *mb = msgbuf,
         *me = &msgbuf[msglen];
d238 1
a238 1
        !ap_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
d243 1
a243 1
    mb = ap_cpystrn(mb, linebuff+4, me - mb);
d258 1
a258 1
            mb = ap_cpystrn(mb, linebuff+4, me - mb);
d277 2
a278 1
    char *basedir = ""; /* By default, path is relative to the $HOME dir */
d286 1
a286 1
    site = ap_unparse_uri_components(p, &r->parsed_uri, UNP_OMITPASSWORD|UNP_OMITPATHINFO);
d288 1
a288 1
    path = ap_unparse_uri_components(p, &r->parsed_uri, UNP_OMITSITEPART|UNP_OMITQUERY);
d301 1
a301 1
    while (path[1] == '/') /* collapse multiple leading slashes to one */
d307 2
a308 2
    for (n = strlen(path); n > 1 && path[n-1] == '/' && path[n-2] == '/'; --n)
        path[n-1] = '\0';
d312 7
a318 7
                "<html><head><title>%s%s%s</title>\n"
                "<base href=\"%s%s%s\"></head>\n"
                "<body><h2>Directory of "
                "<a href=\"/\">%s</a>/",
                site, basedir, ap_escape_html(p,path),
                site, basedir, ap_escape_uri(p,path),
                site);
d326 1
a326 2
    for (dir = path+1; (dir = strchr(dir, '/')) != NULL; )
    {
d328 2
a329 2
        if ((reldir = strrchr(path+1, '/'))==NULL) {
            reldir = path+1;
d341 1
a341 1
          ++dir;
d346 1
a346 1
    if (cwd == NULL || strncmp (cwd, path, strlen(cwd)) == 0) {
d348 2
a349 1
    } else {
d360 1
a360 1
                    "proxy: error reading from %s", c->url);
d366 1
a366 1
            break;                /* EOF */
d368 1
a368 1
        if (buf[n-1] == '\n')  /* strip trailing '\n' */
d370 1
a370 1
        if (buf[n-1] == '\r')  /* strip trailing '\r' if present */
d374 1
a374 1
        if (buf[0] == 'l' && (filename=strstr(buf, " -> ")) != NULL) {
d385 1
a385 1
                        ap_escape_uri(p,filename),
d419 1
a419 1
                            ap_escape_html(p, buf), ap_escape_uri(p,filename),
d425 1
a425 1
                            ap_escape_uri(p,filename),
d433 1
a433 1
            strcat(buf, "\n"); /* re-append the newline char */
d439 1
a439 1
        ap_reset_timeout(r);        /* reset timeout after successfule write */
d460 1
a460 1
static int ftp_unauthorized (request_rec *r, int log_it)
d463 3
a465 2
    /* Log failed requests if they supplied a password
     * (log username/password guessing attempts)
d468 1
a468 1
        ap_log_rerror(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, r,
d471 1
a471 1
                      &r->parsed_uri, UNP_OMITPATHINFO));
d475 3
a477 3
                  ap_unparse_uri_components(r->pool, &r->parsed_uri,
                                            UNP_OMITPASSWORD|UNP_OMITPATHINFO),
                  "\"", NULL));
d485 1
a485 1
    static char old_type[2] = { 'A', '\0' }; /* After logon, mode is ASCII */
d496 1
a496 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: TYPE %s", old_type);
d506 1
a506 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
d510 1
a510 1
                             "Error reading from remote server");
d515 1
a515 1
                             "Unable to set transfer type");
d519 1
a519 1
        /* ignore it silently */;
d525 1
a525 2
static int
ftp_cleanup_and_return(request_rec *r, BUFF *ctrl, BUFF *data, int csock, int dsock, int rc)
d528 1
a528 1
      ap_bclose(ctrl);
d530 1
a530 1
      ap_pclosesocket(r->pool, csock);
d533 1
a533 1
      ap_bclose(data);
d535 1
a535 1
      ap_pclosesocket(r->pool, dsock);
d567 1
a567 1
    char xfer_type = 'A'; /* after ftp login, the default is ASCII */
d572 1
a572 1
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
d598 2
a599 2
            ? r->parsed_uri.port
            : ap_default_port_for_request(r);
d607 7
a613 7
    /* The "Authorization:" header must be checked first.
     * We allow the user to "override" the URL-coded user [ & password ]
     * in the Browsers' User&Password Dialog.
     * NOTE that this is only marginally more secure than having the
     * password travel in plain as part of the URL, because Basic Auth
     * simply uuencodes the plain text password. 
     * But chances are still smaller that the URL is logged regularly.
d618 4
a621 3
        /* Note that this allocation has to be made from r->connection->pool
         * because it has the lifetime of the connection.  The other allocations
         * are temporary and can be tossed away any time.
d623 1
a623 1
        user = ap_getword_nulls (r->connection->pool, &password, ':');
d626 2
a627 1
        nocache = 1;    /* This resource only accessible with username/password */
d637 2
a638 1
        nocache = 1;    /* This resource only accessible with username/password */
d650 1
a650 1
              (npent[i].name[0] == '*' || strstr(host, npent[i].name) != NULL)))
d655 1
a655 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: connect to %s:%d", host, port);
d671 1
a671 1
                     "proxy: error creating socket");
d678 4
a681 4
                       (const char *) &conf->recv_buffer_size, sizeof(int))
            == -1) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                         "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
d685 1
a685 1
    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &one,
d687 1
a687 1
#ifndef _OSD_POSIX /* BS2000 has this option "always on" */
d689 1
a689 1
                     "proxy: error setting reuseaddr option: setsockopt(SO_REUSEADDR)");
d692 1
a692 1
#endif /*_OSD_POSIX*/
d697 1
a697 1
        struct in_addr *ip_addr = (struct in_addr *) *server_hp.h_addr_list;
d721 1
a721 1
                                    strerror(errno), NULL)));
d732 2
a733 2
    ap_bsetflag(ctrl, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 1);
#endif /*CHARSET_EBCDIC*/
d741 1
a741 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
d744 2
a745 2
                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                    "Error reading from remote server"));
d749 2
a750 2
        /* RFC2068 states:
         * 14.38 Retry-After
d752 6
a757 6
         *  The Retry-After response-header field can be used with a 503 (Service
         *  Unavailable) response to indicate how long the service is expected to
         *  be unavailable to the requesting client. The value of this field can
         *  be either an HTTP-date or an integer number of seconds (in decimal)
         *  after the time of the response.
         *     Retry-After  = "Retry-After" ":" ( HTTP-date | delta-seconds )
d759 2
a760 1
        ap_set_header("Retry-After", ap_psprintf(p, "%u", 60*wait_mins);
d762 1
a762 1
                      ap_proxyerror(r, HTTP_SERVICE_UNAVAILABLE, resp));
d767 1
a767 1
                      ap_proxyerror(r, HTTP_BAD_GATEWAY, resp));
d770 1
a770 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: connected.");
d773 2
a774 2
    ap_bflush(ctrl);                        /* capture any errors */
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: USER %s", user);
d783 1
a783 1
    /*     (This may include errors such as command line too long.) */
d787 1
a787 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
d790 2
a791 2
                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                    "Error reading from remote server"));
d795 1
a795 1
                                      ftp_unauthorized (r, 1));
d805 1
a805 1
                                          ftp_unauthorized (r, 0));
d809 9
a817 9
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: PASS %s", password);
    /* possible results 202, 230, 332, 421, 500, 501, 503, 530 */
    /* 230 User logged in, proceed. */
    /* 332 Need account for login. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 503 Bad sequence of commands. */
    /* 530 Not logged in. */
d819 1
a819 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
d822 2
a823 2
                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                    "Error reading from remote server"));
d827 2
a828 2
                      ap_proxyerror(r, HTTP_UNAUTHORIZED,
                                 "Need account for login"));
d831 1
a831 1
        if (i == 530) /* log it: passwd guessing attempt? */
d833 1
a833 1
                                          ftp_unauthorized (r, 1));
d839 3
a841 2
    /* Special handling for leading "%2f": this enforces a "cwd /"
     * out of the $HOME directory which was the starting point after login
d845 1
a845 1
        while (*path == '/') /* skip leading '/' (after root %2f) */
d849 1
a849 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: CWD /");
d860 1
a860 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
d863 2
a864 2
                        ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                      "Error reading from remote server"));
d877 1
a877 1
    for ( ; (strp = strchr(path, '/')) != NULL ; path = strp + 1) {
d888 2
a889 2
        len = decodeenc(path); /* Note! This decodes a %2f -> "/" */
        if (strchr(path, '/')) /* were there any '/' characters? */
d891 2
a892 2
                        ap_proxyerror(r, HTTP_BAD_REQUEST,
                                      "Use of %2F is only allowed at the base directory"));
d896 1
a896 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: CWD %s", path);
d900 7
a906 7
    /* 250 Requested file action okay, completed. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
    /* 530 Not logged in. */
    /* 550 Requested action not taken. */
d908 1
a908 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
d911 2
a912 2
                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                    "Error reading from remote server"));
d918 2
a919 2
                      ap_proxyerror(r, HTTP_BAD_REQUEST,
                                    "Syntax error in filename (reported by ftp server)"));
d927 3
a929 2
        /* "type=d" forces a dir listing.
         * The other types (i|a|e) are directly used for the ftp TYPE command
d931 1
a931 1
        if ( ! (get_dirlisting = (parms[5] == 'd')))
d938 2
a939 2
                                    "ftp proxy supports only types 'a', 'i', or 'e': \"",
                                    parms, "\" is invalid.", NULL)));
d950 2
a951 2
                      ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, 
                                    "proxy: error creating PASV socket"));
d957 1
a957 1
               (const char *) &conf->recv_buffer_size, sizeof(int)) == -1) {
d959 1
a959 1
                         "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
d966 1
a966 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: PASV command issued");
d978 2
a979 2
                      ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, 
                                    "proxy: PASV: control connection is toast"));
d983 1
a983 1
        pstr = strtok(pasv, " ");        /* separate result code */
d988 3
a990 3
            else
            {
                pstr = strtok(NULL, "(");  /* separate address & port params */
d998 1
a998 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: returned status %d", presult);
d1005 2
a1006 2
            ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: contacting host %d.%d.%d.%d:%d",
                     h3, h2, h1, h0, pport);
d1014 4
a1017 4
                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                             ap_pstrcat(r->pool,
                                        "Could not connect to remote machine: ",
                                        strerror(errno), NULL)));
d1029 1
a1029 1
        if (getsockname(sock, (struct sockaddr *) &server, &clen) < 0) {
d1031 1
a1031 1
                      ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, 
d1038 2
a1039 2
                      ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, 
                                    "proxy: error creating socket"));
d1042 1
a1042 1
        if (setsockopt(dsock, SOL_SOCKET, SO_REUSEADDR, (void *) &one,
d1044 1
a1044 1
#ifndef _OSD_POSIX /* BS2000 has this option "always on" */
d1046 3
a1048 3
                      ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, 
                                    "proxy: error setting reuseaddr option"));
#endif /*_OSD_POSIX*/
d1051 1
a1051 1
        if (bind(dsock, (struct sockaddr *) &server,
d1055 3
a1057 3
                      ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, 
                        ap_psprintf(p, "proxy: error binding to ftp data socket %s:%d",
                           inet_ntoa(server.sin_addr), server.sin_port)));
d1059 1
a1059 1
        listen(dsock, 2);        /* only need a short queue */
d1064 1
a1064 1
    if (strchr(path, '/')) /* were there any '/' characters? */
d1066 2
a1067 2
                    ap_proxyerror(r, HTTP_BAD_REQUEST,
                                  "Use of %2F is only allowed at the base directory"));
d1077 1
a1077 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: SIZE %s", path);
d1079 1
a1079 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: returned status %d with response %s", i, resp);
d1082 1
a1082 1
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: SIZE shows this is a directory");
d1086 1
a1086 1
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: CWD %s", path);
d1097 1
a1097 1
                ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
d1100 2
a1101 2
                                ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                              "Error reading from remote server"));
d1111 2
a1112 3
            else if (i == 213) { /* Size command ok */
                for (j = 0; j < sizeof resp && ap_isdigit(resp[j]); j++)
                        ;
d1123 1
a1123 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: PWD");
d1132 1
a1132 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: PWD returned status %d", i);
d1135 2
a1136 2
                                ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                      "Error reading from remote server"));
d1144 1
a1144 1
#endif /*AUTODETECT_PWD*/
d1151 1
a1151 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: LIST %s", (len == 0 ? "" : path));
d1156 1
a1156 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: RETR %s", path);
d1176 1
a1176 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
d1179 2
a1180 2
                                ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                      "Error reading from remote server"));
d1182 1
a1182 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: RETR failed, trying LIST instead");
d1184 2
a1185 1
        ftp_set_TYPE(r, ctrl, 'A'); /* directories must be transferred in ASCII */
d1189 1
a1189 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: CWD %s", path);
d1199 1
a1199 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
d1202 2
a1203 2
                                ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                      "Error reading from remote server"));
d1214 1
a1214 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: PWD");
d1223 1
a1223 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: PWD returned status %d", i);
d1226 2
a1227 2
                                ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                      "Error reading from remote server"));
d1235 1
a1235 1
#endif /*AUTODETECT_PWD*/
d1239 1
a1239 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: LIST -lag");
d1241 1
a1241 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
d1244 2
a1245 2
                                ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                      "Error reading from remote server"));
d1250 1
a1250 1
                                          HTTP_BAD_GATEWAY);
d1269 2
a1270 1
        r->ebcdic.conv_out = 0; /* do not convert what we read from the ftp server */
d1274 1
a1274 1
            ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: Content-Type set to %s", r->content_type);
d1282 1
a1282 1
            ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: Content-Length set to %s", size);
d1286 1
a1286 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: Content-Encoding set to %s", r->content_encoding);
d1295 4
a1298 4
                  (ncent[i].name[0] == '*' ||
                   strstr(host, ncent[i].name) != NULL))) {
               nocache = 1;
               break;
d1313 1
a1313 1
            csd = accept(dsock, (struct sockaddr *) &server, &clen);
d1317 1
a1317 1
                         "proxy: failed to accept data connection");
d1337 1
a1337 1
    
d1343 1
a1343 1
                             ap_get_server_name(r), NULL)); 
d1345 1
a1345 1
    r->content_type = ap_table_get (r->headers_out, "Content-Type");
d1358 1
a1358 1
            ap_proxy_send_fb(data, r, c, -1, 0, conf->io_buffer_size);
d1367 3
a1369 2
        /* We checked for 125||150||226||250 above.
         * See if another rc is pending, and fetch it:
d1383 1
a1383 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: ABOR");
d1385 6
a1390 6
    /* 225 Data connection open; no transfer in progress. */
    /* 226 Closing data connection. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
d1392 1
a1392 1
        ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
d1401 1
a1401 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: QUIT");
d1406 1
a1406 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server, "FTP: QUIT: status %d", i);
d1410 1
a1410 1
    ap_rflush(r);        /* flush before garbage collection */
@


1.6
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
a67 2
DEF_Explain

d76 1
a76 1
	return 0;		/* special case for no characters */
d79 6
a84 6
	ch = x[i];
	if (ch == '%' && ap_isxdigit(x[i + 1]) && ap_isxdigit(x[i + 2])) {
	    ch = ap_proxy_hex2c(&x[i + 1]);
	    i += 2;
	}
	x[j] = ch;
d99 7
a105 7
	ch = x[i];
	if (ch == '%' && ap_isxdigit(x[i + 1]) && ap_isxdigit(x[i + 2])) {
	    ch = ap_proxy_hex2c(&x[i + 1]);
	    i += 2;
	}
	if (ch == CR || ch == LF || (OS_ASC(ch) & 0x80))
	    return 0;
d123 1
a123 1
	return HTTP_BAD_REQUEST;
d125 1
a125 1
	return HTTP_BAD_REQUEST;
d127 1
a127 1
	return HTTP_BAD_REQUEST;
d137 5
a141 5
	*(strp++) = '\0';
	parms = ap_proxy_canonenc(p, strp, strlen(strp), enc_parm,
				  r->proxyreq);
	if (parms == NULL)
	    return HTTP_BAD_REQUEST;
d144 1
a144 1
	parms = "";
d148 1
a148 1
	return HTTP_BAD_REQUEST;
d150 1
a150 1
	return HTTP_BAD_REQUEST;
d153 13
a165 13
	if (strp != NULL) {
	    strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_parm, STD_PROXY);
	    if (strp == NULL)
		return HTTP_BAD_REQUEST;
	    parms = ap_pstrcat(p, parms, "?", strp, NULL);
	}
	else {
	    strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_fpath, STD_PROXY);
	    if (strp == NULL)
		return HTTP_BAD_REQUEST;
	    path = ap_pstrcat(p, path, "?", strp, NULL);
	}
	r->args = NULL;
d171 1
a171 1
	ap_snprintf(sport, sizeof(sport), ":%d", port);
d173 1
a173 1
	sport[0] = '\0';
d176 4
a179 4
			       (password != NULL) ? ":" : "",
			       (password != NULL) ? password : "",
		          (user != NULL) ? "@@" : "", host, sport, "/", path,
			       (parms[0] != '\0') ? ";" : "", parms, NULL);
d188 1
a188 1
static int ftp_getrc(BUFF *f)
d193 1
a193 1
    len = ap_bgets(linebuff, sizeof linebuff, f);
d195 1
a195 1
	return -1;
d198 2
a199 2
	!ap_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
	status = 0;
d201 1
a201 1
	status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';
d204 1
a204 1
	(void)ap_bskiplf(f);
d209 10
a218 10
	memcpy(buff, linebuff, 3);
	buff[3] = ' ';
	do {
	    len = ap_bgets(linebuff, sizeof linebuff, f);
	    if (len == -1)
		return -1;
	    if (linebuff[len - 1] != '\n') {
		(void)ap_bskiplf(f);
	    }
	} while (memcmp(linebuff, buff, 4) != 0);
d228 1
a228 1
static int ftp_getrc_msg(BUFF *f, char *msgbuf, int msglen)
d233 1
a233 1
	 *me = &msgbuf[msglen];
d235 1
a235 1
    len = ap_bgets(linebuff, sizeof linebuff, f);
d237 1
a237 1
	return -1;
d239 2
a240 2
	!ap_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
	status = 0;
d242 1
a242 1
	status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';
d247 1
a247 1
	(void)ap_bskiplf(f);
d250 11
a260 11
	memcpy(buff, linebuff, 3);
	buff[3] = ' ';
	do {
	    len = ap_bgets(linebuff, sizeof linebuff, f);
	    if (len == -1)
		return -1;
	    if (linebuff[len - 1] != '\n') {
		(void)ap_bskiplf(f);
	    }
	    mb = ap_cpystrn(mb, linebuff+4, me - mb);
	} while (memcmp(linebuff, buff, 4) != 0);
d265 1
a265 1
static long int send_dir(BUFF *f, request_rec *r, cache_req *c, char *cwd)
d267 2
a268 2
    char buf[IOBUFSIZE];
    char buf2[IOBUFSIZE];
d274 1
a274 1
    register int n, o, w;
d276 8
a283 1
    char *dir, *path, *reldir, *site;
d286 1
a286 1
    site = ap_unparse_uri_components(r->pool, &r->parsed_uri, UNP_OMITPASSWORD|UNP_OMITPATHINFO);
d288 11
a298 1
    path = ap_unparse_uri_components(r->pool, &r->parsed_uri, UNP_OMITSITEPART|UNP_OMITQUERY);
d301 3
d305 1
d307 2
a308 2
    while ((n = strlen(path)) > 1 && path[n-1] == '/' && path[n-2] == '/')
	path[n-1] = '\0';
d311 8
a318 6
    n = ap_snprintf(buf, sizeof(buf), DOCTYPE_HTML_3_2
		"<HTML><HEAD><TITLE>%s%s</TITLE>\n"
		"<BASE HREF=\"%s%s\"></HEAD>\n"
		"<BODY><H2>Directory of "
		"<A HREF=\"/\">%s</A>/",
		site, path, site, path, site);
d321 6
a326 1
    while ((dir = strchr(dir+1, '/')) != NULL)
d328 15
a342 9
	*dir = '\0';
	if ((reldir = strrchr(path+1, '/'))==NULL)
	    reldir = path+1;
	else
	    ++reldir;
	/* print "path/" component */
	ap_snprintf(buf, sizeof(buf), "<A HREF=\"/%s/\">%s</A>/", path+1, reldir);
	total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);
	*dir = '/';
d344 1
d348 1
a348 1
	ap_snprintf(buf, sizeof(buf), "</H2>\n<HR><PRE>");
d350 2
a351 1
	ap_snprintf(buf, sizeof(buf), "</H2>\n(%s)\n<HR><PRE>", cwd);
d356 84
a439 79
	n = ap_bgets(buf, sizeof buf, f);
	if (n == -1) {		/* input error */
	    if (c != NULL) {
		ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
		    "proxy: error reading from %s", c->url);
		c = ap_proxy_cache_error(c);
	    }
	    break;
	}
	if (n == 0)
	    break;		/* EOF */
	if (buf[0] == 'l' && (filename=strstr(buf, " -> ")) != NULL) {
	    char *link_ptr = filename;

	    do {
		filename--;
	    } while (filename[0] != ' ');
	    *(filename++) = '\0';
	    *(link_ptr++) = '\0';
	    if ((n = strlen(link_ptr)) > 1 && link_ptr[n - 1] == '\n')
	      link_ptr[n - 1] = '\0';
	    ap_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s\">%s %s</A>\n", buf, filename, filename, link_ptr);
	    ap_cpystrn(buf, buf2, sizeof(buf));
	    n = strlen(buf);
	}
	else if (buf[0] == 'd' || buf[0] == '-' || buf[0] == 'l' || ap_isdigit(buf[0])) {
	    if (ap_isdigit(buf[0])) {	/* handle DOS dir */
		searchptr = strchr(buf, '<');
		if (searchptr != NULL)
		    *searchptr = '[';
		searchptr = strchr(buf, '>');
		if (searchptr != NULL)
		    *searchptr = ']';
	    }

	    filename = strrchr(buf, ' ');
	    *(filename++) = 0;
	    filename[strlen(filename) - 1] = 0;

	    /* handle filenames with spaces in 'em */
	    if (!strcmp(filename, ".") || !strcmp(filename, "..") || firstfile) {
		firstfile = 0;
		searchidx = filename - buf;
	    }
	    else if (searchidx != 0 && buf[searchidx] != 0) {
		*(--filename) = ' ';
		buf[searchidx - 1] = 0;
		filename = &buf[searchidx];
	    }

	    /* Special handling for '.' and '..' */
	    if (!strcmp(filename, ".") || !strcmp(filename, "..") || buf[0] == 'd') {
		ap_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s/\">%s</A>\n",
		    buf, filename, filename);
	    }
	    else {
		ap_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s\">%s</A>\n", buf, filename, filename);
	    }
	    ap_cpystrn(buf, buf2, sizeof(buf));
	    n = strlen(buf);
	}

	o = 0;
	total_bytes_sent += n;

	if (c != NULL && c->fp && ap_bwrite(c->fp, buf, n) != n) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
		"proxy: error writing to %s", c->tempfile);
	    c = ap_proxy_cache_error(c);
	}

	while (n && !r->connection->aborted) {
	    w = ap_bwrite(con->client, &buf[o], n);
	    if (w <= 0)
		break;
	    ap_reset_timeout(r);	/* reset timeout after successfule write */
	    n -= w;
	    o += w;
	}
d442 1
a442 1
    total_bytes_sent += ap_proxy_bputs2("</PRE><HR>\n", con->client, c);
d444 3
a446 1
    total_bytes_sent += ap_proxy_bputs2("</BODY></HTML>\n", con->client, c);
d467 4
a470 4
	ap_log_rerror(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, r,
		      "proxy: missing or failed auth to %s",
		      ap_unparse_uri_components(r->pool,
		      &r->parsed_uri, UNP_OMITPATHINFO));
d474 3
a476 3
		  ap_unparse_uri_components(r->pool, &r->parsed_uri,
					    UNP_OMITPASSWORD|UNP_OMITPATHINFO),
		  "\"", NULL));
d481 61
d556 2
a557 2
    int port, i, j, len, sock, dsock, rc, nocache = 0;
    int csd = 0;
d562 1
a562 1
    BUFF *f;
a565 1
    const long int zero = 0L;
d567 2
a568 1
    struct tbl_do_args tdo;
d592 1
a592 1
	return HTTP_NOT_IMPLEMENTED;
d598 2
a599 2
	    ? r->parsed_uri.port
	    : ap_default_port_for_request(r);
d601 5
a605 1
    path = (path != NULL && path[0] != '\0') ? &path[1] : "";
d616 10
a625 10
	&& strcasecmp(ap_getword(r->pool, &password, ' '), "Basic") == 0
	&& (password = ap_pbase64decode(r->pool, password))[0] != ':') {
	/* Note that this allocation has to be made from r->connection->pool
	 * because it has the lifetime of the connection.  The other allocations
	 * are temporary and can be tossed away any time.
	 */
	user = ap_getword_nulls (r->connection->pool, &password, ':');
	r->connection->ap_auth_type = "Basic";
	r->connection->user = r->parsed_uri.user = user;
	nocache = 1;	/* This resource only accessible with username/password */
d628 8
a635 8
	user = ap_pstrdup(p, user);
	decodeenc(user);
	if ((password = r->parsed_uri.password) != NULL) {
	    char *tmp = ap_pstrdup(p, password);
	    decodeenc(tmp);
	    password = tmp;
	}
	nocache = 1;	/* This resource only accessible with username/password */
d638 2
a639 2
	user = "anonymous";
	password = "apache_proxy@@";
d642 1
a642 1
/* check if ProxyBlock directive on this host */
d652 1
a652 1
    Explain2("FTP: connect to %s:%d", host, port);
d656 1
a656 1
	*(parms++) = '\0';
d660 1
a660 1
    server.sin_port = htons(port);
d663 1
a663 1
	return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, err);
d667 3
a669 3
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "proxy: error creating socket");
	return HTTP_INTERNAL_SERVER_ERROR;
d674 5
a678 5
	&& setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
		       (const char *) &conf->recv_buffer_size, sizeof(int))
	    == -1) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
d683 1
a683 1
		   sizeof(one)) == -1) {
d685 4
a688 4
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "proxy: error setting reuseaddr option: setsockopt(SO_REUSEADDR)");
	ap_pclosesocket(p, sock);
	return HTTP_INTERNAL_SERVER_ERROR;
d694 1
a694 1
	struct in_addr *ip_addr = (struct in_addr *) *server_hp.h_addr_list;
d696 6
a701 6
	for (; ip_addr->s_addr != 0; ++ip_addr) {
	    memcpy(&server.sin_addr, ip_addr, sizeof(struct in_addr));
	    i = ap_proxy_doconnect(sock, &server, r);
	    if (i == 0)
		break;
	}
d706 6
a711 6
	memcpy(&server.sin_addr, server_hp.h_addr_list[j],
	       sizeof(struct in_addr));
	i = ap_proxy_doconnect(sock, &server, r);
	if (i == 0)
	    break;
	j++;
d715 4
a718 4
	ap_pclosesocket(p, sock);
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, ap_pstrcat(r->pool,
				"Could not connect to remote machine: ",
				strerror(errno), NULL));
d721 5
a725 2
    f = ap_bcreate(p, B_RDWR | B_SOCKET);
    ap_bpushfd(f, sock, sock);
d729 1
a729 1
    ap_bsetflag(f, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 1);
d732 1
a732 1
/* possible results: */
d737 6
a742 6
    i = ftp_getrc_msg(f, resp, sizeof resp);
    Explain1("FTP: returned status %d", i);
    if (i == -1) {
	ap_kill_timeout(r);
	return ap_proxyerror(r, HTTP_BAD_GATEWAY,
			     "Error reading from remote server");
d746 13
a758 13
	ap_kill_timeout(r);
	/* RFC2068 states:
	 * 14.38 Retry-After
	 * 
	 *  The Retry-After response-header field can be used with a 503 (Service
	 *  Unavailable) response to indicate how long the service is expected to
	 *  be unavailable to the requesting client. The value of this field can
	 *  be either an HTTP-date or an integer number of seconds (in decimal)
	 *  after the time of the response.
	 *     Retry-After  = "Retry-After" ":" ( HTTP-date | delta-seconds )
	 */
	ap_set_header("Retry-After", ap_psprintf(p, "%u", 60*wait_mins);
	return ap_proxyerror(r, HTTP_SERVICE_UNAVAILABLE, resp);
d762 2
a763 2
	ap_kill_timeout(r);
	return ap_proxyerror(r, HTTP_BAD_GATEWAY, resp);
d766 1
a766 1
    Explain0("FTP: connected.");
d768 3
a770 3
    ap_bvputs(f, "USER ", user, CRLF, NULL);
    ap_bflush(f);			/* capture any errors */
    Explain1("FTP: USER %s", user);
d772 2
a773 2
/* possible results; 230, 331, 332, 421, 500, 501, 530 */
/* states: 1 - error, 2 - success; 3 - send password, 4,5 fail */
d782 6
a787 6
    i = ftp_getrc(f);
    Explain1("FTP: returned status %d", i);
    if (i == -1) {
	ap_kill_timeout(r);
	return ap_proxyerror(r, HTTP_BAD_GATEWAY,
			     "Error reading from remote server");
d790 2
a791 2
	ap_kill_timeout(r);
	return ftp_unauthorized (r, 1);	/* log it: user name guessing attempt? */
d794 2
a795 2
	ap_kill_timeout(r);
	return HTTP_BAD_GATEWAY;
d798 9
a806 8
    if (i == 331) {		/* send password */
	if (password == NULL) {
	    return ftp_unauthorized (r, 0);
	}
	ap_bvputs(f, "PASS ", password, CRLF, NULL);
	ap_bflush(f);
	Explain1("FTP: PASS %s", password);
/* possible results 202, 230, 332, 421, 500, 501, 503, 530 */
d814 52
a865 21
	i = ftp_getrc(f);
	Explain1("FTP: returned status %d", i);
	if (i == -1) {
	    ap_kill_timeout(r);
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY,
				 "Error reading from remote server");
	}
	if (i == 332) {
	    ap_kill_timeout(r);
	    return ap_proxyerror(r, HTTP_UNAUTHORIZED,
				 "Need account for login");
	}
	/* @@@@@@ questionable -- we might as well return a 403 Forbidden here */
	if (i == 530) {
	    ap_kill_timeout(r);
	    return ftp_unauthorized (r, 1); /* log it: passwd guessing attempt? */
	}
	if (i != 230 && i != 202) {
	    ap_kill_timeout(r);
	    return HTTP_BAD_GATEWAY;
	}
d872 22
a893 11
    for (;;) {
	strp = strchr(path, '/');
	if (strp == NULL)
	    break;
	*strp = '\0';

	len = decodeenc(path);
	ap_bvputs(f, "CWD ", path, CRLF, NULL);
	ap_bflush(f);
	Explain1("FTP: CWD %s", path);
	*strp = '/';
d902 32
a933 24
	i = ftp_getrc(f);
	Explain1("FTP: returned status %d", i);
	if (i == -1) {
	    ap_kill_timeout(r);
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY,
				 "Error reading from remote server");
	}
	if (i == 550) {
	    ap_kill_timeout(r);
	    return HTTP_NOT_FOUND;
	}
	if (i != 250) {
	    ap_kill_timeout(r);
	    return HTTP_BAD_GATEWAY;
	}

	path = strp + 1;
    }

    if (parms != NULL && strncmp(parms, "type=", 5) == 0) {
	parms += 5;
	if ((parms[0] != 'd' && parms[0] != 'a' && parms[0] != 'i') ||
	    parms[1] != '\0')
	    parms = "";
d935 3
a937 33
    else
	parms = "";

    /* changed to make binary transfers the default */

    if (parms[0] != 'a') {
	/* set type to image */
	/* TM - Added CRLF to the end of TYPE I, otherwise it hangs the
	   connection */
	ap_bputs("TYPE I" CRLF, f);
	ap_bflush(f);
	Explain0("FTP: TYPE I");
/* responses: 200, 421, 500, 501, 504, 530 */
    /* 200 Command okay. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 504 Command not implemented for that parameter. */
    /* 530 Not logged in. */
	i = ftp_getrc(f);
	Explain1("FTP: returned status %d", i);
	if (i == -1) {
	    ap_kill_timeout(r);
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY,
				 "Error reading from remote server");
	}
	if (i != 200 && i != 504) {
	    ap_kill_timeout(r);
	    return HTTP_BAD_GATEWAY;
	}
/* Allow not implemented */
	if (i == 504)
	    parms[0] = '\0';
d943 3
a945 5
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "proxy: error creating PASV socket");
	ap_bclose(f);
	ap_kill_timeout(r);
	return HTTP_INTERNAL_SERVER_ERROR;
d950 5
a954 5
	if (setsockopt(dsock, SOL_SOCKET, SO_RCVBUF,
	       (const char *) &conf->recv_buffer_size, sizeof(int)) == -1) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
	}
d958 3
a960 3
    ap_bputs("PASV" CRLF, f);
    ap_bflush(f);
    Explain0("FTP: PASV command issued");
d968 6
a973 8
    i = ap_bgets(pasv, sizeof(pasv), f);
    if (i == -1) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
		     "PASV: control connection is toast");
	ap_pclosesocket(p, dsock);
	ap_bclose(f);
	ap_kill_timeout(r);
	return HTTP_INTERNAL_SERVER_ERROR;
d976 59
a1034 63
	pasv[i - 1] = '\0';
	pstr = strtok(pasv, " ");	/* separate result code */
	if (pstr != NULL) {
	    presult = atoi(pstr);
	    if (*(pstr + strlen(pstr) + 1) == '=')
	        pstr += strlen(pstr) + 2;
	    else
	    {
	        pstr = strtok(NULL, "(");  /* separate address & port params */
		if (pstr != NULL)
		    pstr = strtok(NULL, ")");
	    }
	}
	else
	    presult = atoi(pasv);

	Explain1("FTP: returned status %d", presult);

	if (presult == 227 && pstr != NULL && (sscanf(pstr,
		 "%d,%d,%d,%d,%d,%d", &h3, &h2, &h1, &h0, &p1, &p0) == 6)) {
	    /* pardon the parens, but it makes gcc happy */
	    paddr = (((((h3 << 8) + h2) << 8) + h1) << 8) + h0;
	    pport = (p1 << 8) + p0;
	    Explain5("FTP: contacting host %d.%d.%d.%d:%d",
		     h3, h2, h1, h0, pport);
	    data_addr.sin_family = AF_INET;
	    data_addr.sin_addr.s_addr = htonl(paddr);
	    data_addr.sin_port = htons(pport);
	    i = ap_proxy_doconnect(dsock, &data_addr, r);

	    if (i == -1) {
		ap_kill_timeout(r);
		return ap_proxyerror(r, HTTP_BAD_GATEWAY,
				     ap_pstrcat(r->pool,
						"Could not connect to remote machine: ",
						strerror(errno), NULL));
	    }
	    else {
		pasvmode = 1;
	    }
	}
	else
	    ap_pclosesocket(p, dsock);	/* and try the regular way */
    }

    if (!pasvmode) {		/* set up data connection */
	clen = sizeof(struct sockaddr_in);
	if (getsockname(sock, (struct sockaddr *) &server, &clen) < 0) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "proxy: error getting socket address");
	    ap_bclose(f);
	    ap_kill_timeout(r);
	    return HTTP_INTERNAL_SERVER_ERROR;
	}

	dsock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (dsock == -1) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "proxy: error creating socket");
	    ap_bclose(f);
	    ap_kill_timeout(r);
	    return HTTP_INTERNAL_SERVER_ERROR;
	}
d1036 2
a1037 2
	if (setsockopt(dsock, SOL_SOCKET, SO_REUSEADDR, (void *) &one,
		       sizeof(one)) == -1) {
d1039 3
a1041 6
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "proxy: error setting reuseaddr option");
	    ap_pclosesocket(p, dsock);
	    ap_bclose(f);
	    ap_kill_timeout(r);
	    return HTTP_INTERNAL_SERVER_ERROR;
d1043 4
a1046 1
	}
d1048 6
a1053 12
	if (bind(dsock, (struct sockaddr *) &server,
		 sizeof(struct sockaddr_in)) == -1) {
	    char buff[22];

	    ap_snprintf(buff, sizeof(buff), "%s:%d", inet_ntoa(server.sin_addr), server.sin_port);
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "proxy: error binding to ftp data socket %s", buff);
	    ap_bclose(f);
	    ap_pclosesocket(p, dsock);
	    return HTTP_INTERNAL_SERVER_ERROR;
	}
	listen(dsock, 2);	/* only need a short queue */
d1058 4
d1066 1
a1066 1
	parms = "d";
d1069 44
a1112 46
	ap_bvputs(f, "SIZE ", path, CRLF, NULL);
	ap_bflush(f);
	Explain1("FTP: SIZE %s", path);
	i = ftp_getrc_msg(f, resp, sizeof resp);
	Explain2("FTP: returned status %d with response %s", i, resp);
	if (i != 500) {		/* Size command not recognized */
	    if (i == 550) {	/* Not a regular file */
		Explain0("FTP: SIZE shows this is a directory");
		parms = "d";
		ap_bvputs(f, "CWD ", path, CRLF, NULL);
		ap_bflush(f);
		Explain1("FTP: CWD %s", path);
		i = ftp_getrc(f);
		/* possible results: 250, 421, 500, 501, 502, 530, 550 */
		/* 250 Requested file action okay, completed. */
		/* 421 Service not available, closing control connection. */
		/* 500 Syntax error, command unrecognized. */
		/* 501 Syntax error in parameters or arguments. */
		/* 502 Command not implemented. */
		/* 530 Not logged in. */
		/* 550 Requested action not taken. */
		Explain1("FTP: returned status %d", i);
		if (i == -1) {
		    ap_kill_timeout(r);
		    return ap_proxyerror(r, HTTP_BAD_GATEWAY,
					 "Error reading from remote server");
		}
		if (i == 550) {
		    ap_kill_timeout(r);
		    return HTTP_NOT_FOUND;
		}
		if (i != 250) {
		    ap_kill_timeout(r);
		    return HTTP_BAD_GATEWAY;
		}
		path = "";
		len = 0;
	    }
	    else if (i == 213) { /* Size command ok */
		for (j = 0; j < sizeof resp && ap_isdigit(resp[j]); j++)
			;
		resp[j] = '\0';
		if (resp[0] != '\0')
		    size = ap_pstrdup(p, resp);
	    }
	}
d1116 3
a1118 3
    ap_bvputs(f, "PWD", CRLF, NULL);
    ap_bflush(f);
    Explain0("FTP: PWD");
d1126 9
a1134 11
    i = ftp_getrc_msg(f, resp, sizeof resp);
    Explain1("FTP: PWD returned status %d", i);
    if (i == -1 || i == 421) {
	ap_kill_timeout(r);
	return ap_proxyerror(r, HTTP_BAD_GATEWAY,
			     "Error reading from remote server");
    }
    if (i == 550) {
	ap_kill_timeout(r);
	return HTTP_NOT_FOUND;
    }
d1136 2
a1137 2
	const char *dirp = resp;
	cwd = ap_getword_conf(r->pool, &dirp);
d1141 6
a1146 6
    if (parms[0] == 'd') {
	if (len != 0)
	    ap_bvputs(f, "LIST ", path, CRLF, NULL);
	else
	    ap_bputs("LIST -lag" CRLF, f);
	Explain1("FTP: LIST %s", (len == 0 ? "" : path));
d1149 3
a1151 2
	ap_bvputs(f, "RETR ", path, CRLF, NULL);
	Explain1("FTP: RETR %s", path);
d1153 1
a1153 1
    ap_bflush(f);
d1170 6
a1175 7
    rc = ftp_getrc(f);
    Explain1("FTP: returned status %d", rc);
    if (rc == -1) {
	ap_kill_timeout(r);
	return ap_proxyerror(r, HTTP_BAD_GATEWAY,
			     "Error reading from remote server");
    }
d1177 27
a1203 28
	Explain0("FTP: RETR failed, trying LIST instead");
	parms = "d";
	ap_bvputs(f, "CWD ", path, CRLF, NULL);
	ap_bflush(f);
	Explain1("FTP: CWD %s", path);
	/* possible results: 250, 421, 500, 501, 502, 530, 550 */
	/* 250 Requested file action okay, completed. */
	/* 421 Service not available, closing control connection. */
	/* 500 Syntax error, command unrecognized. */
	/* 501 Syntax error in parameters or arguments. */
	/* 502 Command not implemented. */
	/* 530 Not logged in. */
	/* 550 Requested action not taken. */
	rc = ftp_getrc(f);
	Explain1("FTP: returned status %d", rc);
	if (rc == -1) {
	    ap_kill_timeout(r);
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY,
				 "Error reading from remote server");
	}
	if (rc == 550) {
	    ap_kill_timeout(r);
	    return HTTP_NOT_FOUND;
	}
	if (rc != 250) {
	    ap_kill_timeout(r);
	    return HTTP_BAD_GATEWAY;
	}
d1206 3
a1208 3
	ap_bvputs(f, "PWD", CRLF, NULL);
	ap_bflush(f);
	Explain0("FTP: PWD");
d1210 19
a1228 21
	/* 257 "<directory-name>" <commentary> */
	/* 421 Service not available, closing control connection. */
	/* 500 Syntax error, command unrecognized. */
	/* 501 Syntax error in parameters or arguments. */
	/* 502 Command not implemented. */
	/* 550 Requested action not taken. */
	i = ftp_getrc_msg(f, resp, sizeof resp);
	Explain1("FTP: PWD returned status %d", i);
	if (i == -1 || i == 421) {
	    ap_kill_timeout(r);
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY,
				 "Error reading from remote server");
	}
	if (i == 550) {
	    ap_kill_timeout(r);
	    return HTTP_NOT_FOUND;
	}
	if (i == 257) {
	    const char *dirp = resp;
	    cwd = ap_getword_conf(r->pool, &dirp);
	}
d1231 9
a1239 8
	ap_bputs("LIST -lag" CRLF, f);
	ap_bflush(f);
	Explain0("FTP: LIST -lag");
	rc = ftp_getrc(f);
	Explain1("FTP: returned status %d", rc);
	if (rc == -1)
	    return ap_proxyerror(r, HTTP_BAD_GATEWAY,
				 "Error reading from remote server");
d1243 2
a1244 1
	return HTTP_BAD_GATEWAY;
d1255 6
a1260 2
    if (parms[0] == 'd')
	ap_table_setn(resp_hdrs, "Content-Type", "text/html");
d1262 15
a1276 12
	if (r->content_type != NULL) {
	    ap_table_setn(resp_hdrs, "Content-Type", r->content_type);
	    Explain1("FTP: Content-Type set to %s", r->content_type);
	}
	else {
	    ap_table_setn(resp_hdrs, "Content-Type", ap_default_type(r));
	}
	if (parms[0] != 'a' && size != NULL) {
	    /* We "trust" the ftp server to really serve (size) bytes... */
	    ap_table_set(resp_hdrs, "Content-Length", size);
	    Explain1("FTP: Content-Length set to %s", size);
	}
d1279 2
a1280 2
	Explain1("FTP: Content-Encoding set to %s", r->content_encoding);
	ap_table_setn(resp_hdrs, "Content-Encoding", r->content_encoding);
d1285 9
a1293 9
	for (i = 0; i < conf->nocaches->nelts; i++) {
	    if (destaddr.s_addr == ncent[i].addr.s_addr ||
	        (ncent[i].name != NULL &&
		  (ncent[i].name[0] == '*' ||
		   strstr(host, ncent[i].name) != NULL))) {
	       nocache = 1;
	       break;
	    }
	}
d1299 20
a1318 25
	ap_pclosesocket(p, dsock);
	ap_bclose(f);
	return i;
    }

    if (!pasvmode) {		/* wait for connection */
	ap_hard_timeout("proxy ftp data connect", r);
	clen = sizeof(struct sockaddr_in);
	do
	    csd = accept(dsock, (struct sockaddr *) &server, &clen);
	while (csd == -1 && errno == EINTR);
	if (csd == -1) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "proxy: failed to accept data connection");
	    ap_pclosesocket(p, dsock);
	    ap_bclose(f);
	    ap_kill_timeout(r);
	    if (c != NULL)
		c = ap_proxy_cache_error(c);
	    return HTTP_BAD_GATEWAY;
	}
	ap_note_cleanups_for_socket(p, csd);
	data = ap_bcreate(p, B_RDWR | B_SOCKET);
	ap_bpushfd(data, csd, -1);
	ap_kill_timeout(r);
d1321 2
a1322 2
	data = ap_bcreate(p, B_RDWR | B_SOCKET);
	ap_bpushfd(data, dsock, dsock);
a1325 23
/* send response */
/* write status line */
    if (!r->assbackwards)
	ap_rvputs(r, "HTTP/1.0 ", r->status_line, CRLF, NULL);
    if (c != NULL && c->fp != NULL
	&& ap_bvputs(c->fp, "HTTP/1.0 ", r->status_line, CRLF, NULL) == -1) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
		"proxy: error writing CRLF to %s", c->tempfile);
	    c = ap_proxy_cache_error(c);
    }

/* send headers */
    tdo.req = r;
    tdo.cache = c;
    ap_table_do(ap_proxy_send_hdr_line, &tdo, resp_hdrs, NULL);

    if (!r->assbackwards)
	ap_rputs(CRLF, r);
    if (c != NULL && c->fp != NULL && ap_bputs(CRLF, c->fp) == -1) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
	    "proxy: error writing CRLF to %s", c->tempfile);
	c = ap_proxy_cache_error(c);
    }
d1327 18
a1344 2
    ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
    r->sent_bodyct = 1;
d1347 1
a1347 1
	if (parms[0] != 'd') {
d1349 16
a1364 13
	    if (c != NULL)
		c->cache_completion = 0;
	    ap_proxy_send_fb(data, r, c);
	} else
	    send_dir(data, r, c, cwd);

	if (rc == 125 || rc == 150)
	    rc = ftp_getrc(f);

	/* XXX: we checked for 125||150||226||250 above. This is redundant. */
	if (rc != 226 && rc != 250)
            /* XXX: we no longer log an "error writing to c->tempfile" - should we? */
	    c = ap_proxy_cache_error(c);
d1367 9
a1375 6
/* abort the transfer */
	ap_bputs("ABOR" CRLF, f);
	ap_bflush(f);
	if (!pasvmode)
	    ap_bclose(data);
	Explain0("FTP: ABOR");
d1383 2
a1384 2
	i = ftp_getrc(f);
	Explain1("FTP: returned status %d", i);
d1391 3
a1393 3
    ap_bputs("QUIT" CRLF, f);
    ap_bflush(f);
    Explain0("FTP: QUIT");
d1397 2
a1398 2
    i = ftp_getrc(f);
    Explain1("FTP: QUIT: status %d", i);
d1400 1
a1400 3
    if (pasvmode)
	ap_bclose(data);
    ap_bclose(f);
d1402 1
a1402 1
    ap_rflush(r);	/* flush before garbage collection */
@


1.5
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1996-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 6
a24 9
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
d26 4
a29 3
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
d31 3
a33 4
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
d35 4
a38 4
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 3
a52 5
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
d54 3
d539 5
a543 4
	if ((npent[i].name != NULL && strstr(host, npent[i].name) != NULL)
	    || destaddr.s_addr == npent[i].addr.s_addr || npent[i].name[0] == '*')
	    return ap_proxyerror(r, HTTP_FORBIDDEN,
				 "Connect to remote machine blocked");
d1162 10
a1171 4
    for (i = 0; i < conf->nocaches->nelts; i++) {
	if ((ncent[i].name != NULL && strstr(host, ncent[i].name) != NULL)
	    || destaddr.s_addr == ncent[i].addr.s_addr || ncent[i].name[0] == '*')
	    nocache = 1;
@


1.4
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d564 1
a564 1
#ifndef TPF
d818 1
a818 1
#ifndef TPF
@


1.3
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d105 1
a105 5
#ifndef CHARSET_EBCDIC
	if (ch == '\015' || ch == '\012' || (ch & 0x80))
#else /*CHARSET_EBCDIC*/
	if (ch == '\r' || ch == '\n' || (os_toascii[ch] & 0x80))
#endif /*CHARSET_EBCDIC*/
d139 2
a140 1
	parms = ap_proxy_canonenc(p, strp, strlen(strp), enc_parm, r->proxyreq);
d153 1
a153 1
    if (!r->proxyreq && r->args != NULL) {
d155 1
a155 1
	    strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_parm, 1);
d161 1
a161 1
	    strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_fpath, 1);
d420 1
a420 1
    r->proxyreq = 0;
d564 1
d572 1
d780 1
a780 1
	/* TM - Added \015\012 to the end of TYPE I, otherwise it hangs the
d818 1
d826 1
@


1.2
log
@Apache 1.3.4 merge
@
text
@d63 1
d81 1
a81 1
	if (ch == '%' && isxdigit(x[i + 1]) && isxdigit(x[i + 2])) {
d101 1
a101 1
	if (ch == '%' && isxdigit(x[i + 1]) && isxdigit(x[i + 2])) {
d294 1
a294 1
    n = ap_snprintf(buf, sizeof(buf), "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n"
d326 3
a328 1
	    if (c != NULL)
d330 1
d389 3
a391 1
	if (c != NULL && c->fp && ap_bwrite(c->fp, buf, n) != n)
d393 1
d513 1
a513 1
	&& (password = ap_uudecode(r->pool, password))[0] != ':') {
d543 2
a544 1
	    return ap_proxyerror(r, /*HTTP_FORBIDDEN*/ "Connect to remote machine blocked");
d558 1
a558 1
	return ap_proxyerror(r, err);	/* give up */
d609 1
a609 1
	return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ ap_pstrcat(r->pool,
d631 2
a632 1
	return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d648 1
a648 1
	return ap_proxyerror(r, /*HTTP_SERVICE_UNAVAILABLE*/ resp);
d653 1
a653 1
	return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ resp);
d676 2
a677 1
	return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d707 2
a708 1
	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d712 2
a713 1
	    return ap_proxyerror(r, /*HTTP_UNAUTHORIZED*/ "Need account for login");
d753 2
a754 1
	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d797 2
a798 1
	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d879 4
a882 3
		return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ ap_pstrcat(r->pool,
				"Could not connect to remote machine: ",
				strerror(errno), NULL));
d970 2
a971 1
		    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d1009 2
a1010 1
	return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d1054 2
a1055 1
	return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d1075 2
a1076 1
	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d1102 2
a1103 1
	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d1121 2
a1122 1
	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d1134 3
d1138 1
a1138 1
	ap_table_set(resp_hdrs, "Content-Type", "text/html");
d1141 1
a1141 1
	    ap_table_set(resp_hdrs, "Content-Type", r->content_type);
d1145 1
a1145 1
	    ap_table_set(resp_hdrs, "Content-Type", "text/plain");
d1153 4
a1198 4
#ifdef CHARSET_EBCDIC
/*    bsetflag(data, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);*/
#endif /*CHARSET_EBCDIC*/

d1205 5
a1209 2
	&& ap_bvputs(c->fp, "HTTP/1.0 ", r->status_line, CRLF, NULL) == -1)
	c = ap_proxy_cache_error(c);
d1218 3
a1220 1
    if (c != NULL && c->fp != NULL && ap_bputs(CRLF, c->fp) == -1)
d1222 1
d1241 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1996,1997 The Apache Group.  All rights reserved.
d23 2
a24 1
 *    prior written permission.
d26 5
a30 1
 * 5. Redistributions of any form whatsoever must retain the following
d62 3
d66 1
a66 1
extern int find_ct(request_rec *r);
d71 1
a71 2
static int
decodeenc(char *x)
d75 3
a77 3
    if (x[0] == '\0') return 0; /* special case for no characters */
    for (i=0, j=0; x[i] != '\0'; i++, j++)
    {
d80 2
a81 3
	if ( ch == '%' && isxdigit(x[i+1]) && isxdigit(x[i+2]))
	{
	    ch = proxy_hex2c(&x[i+1]);
d94 1
a94 2
static int
ftp_check_string(const char *x)
d98 1
a98 2
    for (i=0; x[i] != '\0'; i++)
    {
d100 2
a101 3
	if ( ch == '%' && isxdigit(x[i+1]) && isxdigit(x[i+2]))
	{
	    ch = proxy_hex2c(&x[i+1]);
d104 6
a109 1
	if (ch == '\015' || ch == '\012' || (ch & 0x80)) return 0;
d117 1
a117 2
int
proxy_ftp_canon(request_rec *r, char *url)
d119 2
a120 2
    char *user, *password, *host, *path, *parms, *p, sport[7];
    pool *pool=r->pool;
d125 7
a131 4
    err = proxy_canon_netloc(pool, &url, &user, &password, &host, &port);
    if (err) return BAD_REQUEST;
    if (user != NULL && !ftp_check_string(user)) return BAD_REQUEST;
    if (password != NULL && !ftp_check_string(password)) return BAD_REQUEST;
d139 8
a146 7
    p = strchr(url, ';');
    if (p != NULL)
    {
	*(p++) = '\0';
	parms = proxy_canonenc(pool, p, strlen(p), enc_parm, r->proxyreq);
	if (parms == NULL) return BAD_REQUEST;
    } else
d149 12
a160 11
    path = proxy_canonenc(pool, url, strlen(url), enc_path, r->proxyreq);
    if (path == NULL) return BAD_REQUEST;
    if (!ftp_check_string(path)) return BAD_REQUEST;

    if (!r->proxyreq && r->args != NULL)
    {
	if (p != NULL)
	{
	    p = proxy_canonenc(pool, r->args, strlen(r->args), enc_parm, 1);
	    if (p == NULL) return BAD_REQUEST;
	    parms = pstrcat(pool, parms, "?", p, NULL);
d162 5
a166 5
	else
	{
	    p = proxy_canonenc(pool, r->args, strlen(r->args), enc_fpath, 1);
	    if (p == NULL) return BAD_REQUEST;
	    path = pstrcat(pool, path, "?", p, NULL);
d173 4
a176 2
    if (port != DEFAULT_FTP_PORT) ap_snprintf(sport, sizeof(sport), ":%d", port);
    else sport[0] = '\0';
d178 5
a182 5
    r->filename = pstrcat(pool, "proxy:ftp://", (user != NULL) ? user : "",
			  (password != NULL) ? ":" : "",
			  (password != NULL) ? password : "",
			  (user != NULL) ? "@@" : "", host, sport, "/", path,
			  (parms[0] != '\0') ? ";" : "", parms, NULL);
d191 1
a191 2
static int
ftp_getrc(BUFF *f)
d193 1
a193 1
    int i, len, status;
d196 3
a198 2
    len = bgets(linebuff, 100, f);
    if (len == -1) return -1;
d200 2
a201 2
    if (len < 5 || !isdigit(linebuff[0]) || !isdigit(linebuff[1]) ||
	!isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
d206 2
a207 3
    if (linebuff[len-1] != '\n')
    {
	i = bskiplf(f);
d210 2
a211 3
/* skip continuation lines */    
    if (linebuff[3] == '-')
    {
d214 6
a219 7
	do
	{
	    len = bgets(linebuff, 100, f);
	    if (len == -1) return -1;
	    if (linebuff[len-1] != '\n')
	    {
		i = bskiplf(f);
d227 5
a231 2
static char *
encode_space(request_rec *r, char *path)
d233 31
a263 13
    pool *pool=r->pool;
    char *newpath;
    int i, j, len;

    len = strlen(path);
    newpath = palloc(pool, 3 * len + 1);
    for (i=0, j=0; i < len; i++, j++) {
	if (path[i] != ' ')
	    newpath[j] = path[i];
	else {
	    proxy_c2hex(' ', &newpath[j]);
	    j += 2;
	}
d265 1
a265 2
    newpath[j] = '\0';
    return newpath;
d268 1
a268 2
static long int
send_dir(BUFF *f, request_rec *r, BUFF *f2, struct cache_req *c, char *url)
a272 2
    char *tempurl;
    char *newurlptr;
d276 1
a276 2
    char urlptr[HUGE_STRING_LEN];
    long total_bytes_sent;
d279 1
d281 68
a348 41
    tempurl = pstrdup(r->pool, url);
    if ((n = strcspn(tempurl, "@@")) != strlen(tempurl))	/* hide user/passwd */
    {
	memmove(tempurl + (n - 5), tempurl, 6);
	tempurl += n - 5;	/* leave room for ftp:// */
    }

    n = decodeenc(tempurl);
    ap_snprintf(buf, sizeof(buf), "<HTML><HEAD><TITLE>%s</TITLE></HEAD><BODY><H1>Directory %s</H1><HR><PRE>", tempurl, tempurl);
    bwrite(con->client, buf, strlen(buf));
    if (f2 != NULL) bwrite(f2, buf, strlen(buf));
    total_bytes_sent=strlen(buf);
    while(!con->aborted)
    {
        n = bgets(buf, IOBUFSIZE, f);
        if (n == -1) /* input error */
        {
            if (f2 != NULL) f2 = proxy_cache_error(c);
            break;
        }
        if (n == 0) break; /* EOF */
        if(buf[0]=='l')
        {
            char *link;

            link=strstr(buf, " -> ");
            filename=link;
            do filename--; while (filename[0]!=' ');
            *(filename++)=0;
            *(link++)=0;
            ap_snprintf(urlptr, sizeof(urlptr), "%s%s%s",url,(url[strlen(url)-1]=='/' ? "" : "/"), filename);
            ap_snprintf(buf2, sizeof(urlptr), "%s <A HREF=\"%s\">%s %s</A>\015\012", buf, urlptr, filename, link);
            strncpy(buf, buf2, sizeof(buf)-1);
	    buf[sizeof(buf)-1] = '\0';
            n=strlen(buf);
        }
        else if (strrchr(buf, ' ') && (buf[0]=='d' || buf[0]=='-' || 
				       buf[0]=='l' || isdigit(buf[0])) ) {
	    if(isdigit(buf[0])) {		/* handle DOS dir */
	        searchptr = strchr(buf, '<');
	        if(searchptr != NULL)
d350 2
a351 2
	        searchptr = strchr(buf, '>');
	        if(searchptr != NULL)
a353 4
		
            filename=strrchr(buf, ' ');
            *(filename++)=0;
            filename[strlen(filename)-1]=0;
d355 6
a360 2
            /* handle filenames with spaces in 'em */
            if(!strcmp(filename, ".") || !strcmp(filename, "..") || firstfile) {
d362 7
a368 52
                searchidx = filename - buf;
            }
            else if (searchidx != 0 && buf[searchidx] != 0) {
                *(--filename) = ' ';
                buf[searchidx - 1] = 0;
                filename = &buf[searchidx];    
            }   

            /* Special handling for '.' and '..' */
            if (!strcmp(filename, "."))
            {
                ap_snprintf(urlptr, sizeof(urlptr), "%s",url);
                ap_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s\">%s</A>\015\012", buf, urlptr, filename);
            }
            else if (!strcmp(filename, ".."))
            {
                char temp[200];
                char newpath[200];
                char *method, *host, *path, *newfile;
   
                strncpy(temp, url, sizeof(temp)-1);
		temp[sizeof(temp)-1] = '\0';
                method=temp;

                host=strchr(method,':');
                if (host == NULL) host="";
                else *(host++)=0;
                host++; host++;
                
                path=strchr(host,'/');
                if (path == NULL) path="";
                else *(path++)=0;
                
                strncpy(newpath, path, sizeof(newpath)-1);
		newpath[sizeof(newpath)-1] = '\0';
                newfile=strrchr(newpath,'/');
                if (newfile) *(newfile)=0;
                else newpath[0]=0;

                ap_snprintf(urlptr, sizeof(urlptr), "%s://%s/%s",method,host,newpath);
                ap_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s\">%s</A>\015\012", buf, urlptr, filename);
            }
            else 
            {
                ap_snprintf(urlptr, sizeof(urlptr), "%s%s%s",url,(url[strlen(url)-1]=='/' ? "" : "/"), filename);
		newurlptr = encode_space(r, urlptr);
                ap_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s\">%s</A>\015\012", buf, newurlptr, filename);
            }
            strncpy(buf, buf2, sizeof(buf));
	    buf[sizeof(buf)-1] = '\0';
            n=strlen(buf);
        }      
d370 13
a382 1
        o=0;
d385 5
a389 5
	if (f2 != NULL)
	    if (bwrite(f2, buf, n) != n) f2 = proxy_cache_error(c);
	
        while(n && !r->connection->aborted) {
            w = bwrite(con->client, &buf[o], n);
d392 12
a403 12
	    reset_timeout(r); /* reset timeout after successfule write */
            n-=w;
            o+=w;
        }
    }
    bputs("</PRE><HR></BODY></HTML>\015\012", con->client);
    if (f2 != NULL) {
	bputs("</PRE><HR></BODY></HTML>\015\012", f2);
    }
    total_bytes_sent+=strlen(buf);
    bflush(con->client);
    
d407 28
d441 1
a441 2
int
proxy_ftp_handler(request_rec *r, struct cache_req *c, char *url)
d443 5
a447 1
    char *host, *path, *p, *user, *password, *parms;
d449 1
a449 2
    int port, userlen, i, j, len, sock, dsock, rc, nocache;
    int passlen = 0;
a452 1
    struct hdr_entry *hdr;
d454 2
a455 2
    array_header *resp_hdrs;
    BUFF *f, *cache;
d457 5
a461 3
    pool *pool=r->pool;
    const int one=1;
    const long int zero=0L;
d465 3
a467 3
        (proxy_server_conf *)get_module_config(sconf, &proxy_module);
    struct noproxy_entry *npent=(struct noproxy_entry *)conf->noproxies->elts;
    struct nocache_entry *ncent=(struct nocache_entry *)conf->nocaches->elts;
d477 5
a481 1
 
d484 2
a485 1
    if (r->method_number != M_GET) return NOT_IMPLEMENTED;
d489 38
a526 28
    host = pstrdup(pool, url + 6);
    port = DEFAULT_FTP_PORT;
    path = strchr(host, '/');
    if (path == NULL)
	path = "";
    else
	*(path++) = '\0';

    user = password = NULL;
    nocache = 0;
    p = strchr(host, '@@');
    if (p != NULL)
    {
	(*p++) = '\0';
	user = host;
	host = p;
/* find password */
	p = strchr(user, ':');
	if (p != NULL)
	{
	    *(p++) = '\0';
	    password = p;
	    passlen = decodeenc(password);
	}
	userlen = decodeenc(user);
	nocache = 1; /* don't cache when a username is supplied */
    } else
    {
a527 2
	userlen = 9;

a528 9
	passlen = strlen(password);
    }

    p = strchr(host, ':');
    if (p != NULL)
    {
	*(p++) = '\0';
	if (isdigit(*p))
	    port = atoi(p);
d532 5
a536 6
    destaddr.s_addr = inet_addr(host);
    for (i=0; i < conf->noproxies->nelts; i++)
    {
        if ((npent[i].name != NULL && strstr(host, npent[i].name) != NULL)
          || destaddr.s_addr == npent[i].addr.s_addr || npent[i].name[0] == '*')
            return proxyerror(r, "Connect to remote machine blocked");
d539 1
a539 1
    Explain2("FTP: connect to %s:%d",host,port);
d542 2
a543 1
    if (parms != NULL) *(parms++) = '\0';
d548 39
a586 9
    err = proxy_host2addr(host, &server_hp);
    if (err != NULL) return proxyerror(r, err); /* give up */

    sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sock == -1)
    {
	proxy_log_uerror("socket", NULL, "proxy: error creating socket",
	    r->server);
	return SERVER_ERROR;
d588 1
a588 11
    note_cleanups_for_fd(pool, sock);

    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const char *)&one,
		   sizeof(int)) == -1)
    {
	proxy_log_uerror("setsockopt", NULL,
	    "proxy: error setting reuseaddr option", r->server);
	pclosef(pool, sock);
	return SERVER_ERROR;
    }

d591 14
a604 9
        memcpy(&server.sin_addr, server_hp.h_addr_list[j],
            sizeof(struct in_addr));
        i = proxy_doconnect(sock, &server, r);
        if (i == 0)
            break; 
        j++;
    }   
    if (i == -1)
	return proxyerror(r, "Could not connect to remote machine");
d606 2
a607 2
    f = bcreate(pool, B_RDWR);
    bpushfd(f, sock, sock);
d610 10
a619 3
/* possible results: 120, 220, 421 */
    hard_timeout ("proxy ftp", r);
    i = ftp_getrc(f);
d622 2
a623 2
	kill_timeout(r);
	return proxyerror(r, "Error reading from remote server");
d625 17
d643 2
a644 2
	kill_timeout(r);
	return BAD_GATEWAY;
d649 4
a652 6
    bputs("USER ", f);
    bwrite(f, user, userlen);
    bputs("\015\012", f);
    bflush(f); /* capture any errors */
    Explain1("FTP: USER %s",user);
    
d655 8
d664 1
a664 1
    Explain1("FTP: returned status %d",i);
d666 2
a667 2
	kill_timeout(r);
	return proxyerror(r, "Error sending to remote server");
d670 2
a671 2
	kill_timeout(r);
	return proxyerror(r, "Not logged in");
d674 2
a675 2
	kill_timeout(r);
	return BAD_GATEWAY;
d677 8
a684 9
	
    if (i == 331) /* send password */
    {
	if (password == NULL) return FORBIDDEN;
	bputs("PASS ", f);
	bwrite(f, password, passlen);
	bputs("\015\012", f);
	bflush(f);
        Explain1("FTP: PASS %s",password);
d686 7
d694 1
a694 1
        Explain1("FTP: returned status %d",i);
d696 2
a697 2
	    kill_timeout(r);
	    return proxyerror(r, "Error sending to remote server");
d700 2
a701 2
	    kill_timeout(r);
	    return proxyerror(r, "Need account for login");
d703 1
d705 2
a706 2
	    kill_timeout(r);
	    return proxyerror(r, "Not logged in");
d709 2
a710 2
	    kill_timeout(r);
	    return BAD_GATEWAY;
d712 1
a712 1
    }  
d714 2
a715 2
/* set the directory */
/* this is what we must do if we don't know the OS type of the remote
d718 5
a722 5
    for (;;)
    {
	p = strchr(path, '/');
	if (p == NULL) break;
	*p = '\0';
d725 4
a728 5
	bputs("CWD ", f);
	bwrite(f, path, len);
	bputs("\015\012", f);
        bflush(f);
        Explain1("FTP: CWD %s",path);
d730 7
a736 1
/* 1,3 error, 2 success, 4,5 failure */
d738 1
a738 1
        Explain1("FTP: returned status %d",i);
d740 2
a741 2
	    kill_timeout(r);
	    return proxyerror(r, "Error sending to remote server");
d744 2
a745 2
	    kill_timeout(r);
	    return NOT_FOUND;
d748 2
a749 2
	    kill_timeout(r);
	    return BAD_GATEWAY;
d752 1
a752 1
	path = p + 1;
d755 1
a755 2
    if (parms != NULL && strncmp(parms, "type=", 5) == 0)
    {
d758 2
a759 1
	    parms[1] != '\0') parms = "";
d761 2
a762 1
    else parms = "";
d766 1
a766 2
    if (parms[0] != 'a')
    {
d768 5
a772 5
        /* TM - Added \015\012 to the end of TYPE I, otherwise it hangs the
           connection */
	bputs("TYPE I\015\012", f);
	bflush(f);
        Explain0("FTP: TYPE I");
d774 6
d781 1
a781 1
        Explain1("FTP: returned status %d",i);
d783 2
a784 2
	    kill_timeout(r);
	    return proxyerror(r, "Error sending to remote server");
d787 2
a788 2
	    kill_timeout(r);
	    return BAD_GATEWAY;
d796 15
a810 8
    dsock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (dsock == -1)
    { 
	proxy_log_uerror("socket", NULL, "proxy: error creating PASV socket",
	    r->server);
	pclosef(pool, sock);
	kill_timeout(r);
        return SERVER_ERROR;
a811 1
    note_cleanups_for_fd(pool, dsock);
d813 2
a814 2
    bputs("PASV\015\012", f);
    bflush(f);
d817 17
a833 13
    i = bgets(pasv, sizeof(pasv), f); 

    if (i == -1)
    {
	proxy_log_uerror("command", NULL, "PASV: control connection is toast",
	    r->server);
	pclosef(pool, dsock);
	pclosef(pool, sock);
	kill_timeout(r);
	return SERVER_ERROR;
    } else
    {
	pasv[i-1] = '\0';
d835 1
a835 2
	if (pstr != NULL)
	{
d837 8
a844 3
	    pstr = strtok(NULL, "(");	/* separate address & port params */
	    if (pstr != NULL)
		pstr = strtok(NULL, ")");
d852 1
a852 2
	    "%d,%d,%d,%d,%d,%d", &h3, &h2, &h1, &h0, &p1, &p0) == 6))
	{
d854 2
a855 2
            paddr = (((((h3 << 8) + h2) << 8) + h1) << 8) + h0;
            pport = (p1 << 8) + p0;
d857 5
a861 5
		h3, h2, h1, h0, pport);
            data_addr.sin_family = AF_INET;
            data_addr.sin_addr.s_addr = htonl(paddr);
            data_addr.sin_port = htons(pport);
	    i = proxy_doconnect(dsock, &data_addr, r);
d864 4
a867 2
		kill_timeout(r);
		return proxyerror(r, "Could not connect to remote machine");
d870 1
a870 3
	        data = bcreate(pool, B_RDWR); 
	        bpushfd(data, dsock, dsock);
	        pasvmode = 1;
d872 3
a874 2
	} else
	    pclosef(pool, dsock);	/* and try the regular way */
d877 33
a909 37
    if (!pasvmode)	/* set up data connection */
    {
        len = sizeof(struct sockaddr_in);
        if (getsockname(sock, (struct sockaddr *)&server, &len) < 0)
        {
	    proxy_log_uerror("getsockname", NULL,
	        "proxy: error getting socket address", r->server);
	    pclosef(pool, sock);
	    kill_timeout(r);
	    return SERVER_ERROR;
        }

        dsock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (dsock == -1)
        {
	    proxy_log_uerror("socket", NULL, "proxy: error creating socket",
	        r->server);
	    pclosef(pool, sock);
	    kill_timeout(r);
	    return SERVER_ERROR;
        }
        note_cleanups_for_fd(pool, dsock);

        if (setsockopt(dsock, SOL_SOCKET, SO_REUSEADDR, (const char *)&one,
		   sizeof(int)) == -1)
        {
	    proxy_log_uerror("setsockopt", NULL,
	        "proxy: error setting reuseaddr option", r->server);
	    pclosef(pool, dsock);
	    pclosef(pool, sock);
	    kill_timeout(r);
	    return SERVER_ERROR;
        }

        if (bind(dsock, (struct sockaddr *)&server,
            sizeof(struct sockaddr_in)) == -1)
        {
d913 7
a919 6
	    proxy_log_uerror("bind", buff,
	        "proxy: error binding to ftp data socket", r->server);
    	    pclosef(pool, sock);
    	    pclosef(pool, dsock);
        }
        listen(dsock, 2); /* only need a short queue */
d922 1
a922 1
/* set request */
d927 49
a975 40
    if(len==0)
    {
	parms="d";
    } else
    {
        bputs("SIZE ", f);
        bwrite(f, path, len);
        bputs("\015\012", f);
        bflush(f);
        Explain1("FTP: SIZE %s",path);
        i = ftp_getrc(f);
        Explain1("FTP: returned status %d", i);
        if (i != 500) /* Size command not recognized */
        {
            if (i==550) /* Not a regular file */
            {
                Explain0("FTP: SIZE shows this is a directory");
                parms="d";
                bputs("CWD ", f);
                bwrite(f, path, len);
                bputs("\015\012", f);
                bflush(f);
                Explain1("FTP: CWD %s",path);
                i = ftp_getrc(f);
                Explain1("FTP: returned status %d", i);
                if (i == -1) {
		    kill_timeout(r);
		    return proxyerror(r, "Error sending to remote server");
                }
                if (i == 550) {
		    kill_timeout(r);
		    return NOT_FOUND;
                }
                if (i != 250) {
		    kill_timeout(r);
		    return BAD_GATEWAY;
                }
                path=""; len=0;
            }
        }
d977 34
a1010 6
            
    if (parms[0] == 'd')
    {
	if (len != 0) bputs("LIST ", f);
	else bputs("LIST -lag", f);
        Explain1("FTP: LIST %s",(len==0 ? "" : path));
d1012 3
a1014 4
    else
    {
        bputs("RETR ", f);
        Explain1("FTP: RETR %s",path);
d1016 1
a1016 3
    bwrite(f, path, len);
    bputs("\015\012", f);
    bflush(f);
d1019 14
d1034 1
a1034 1
    Explain1("FTP: returned status %d",rc);
d1036 2
a1037 2
	kill_timeout(r);
	return proxyerror(r, "Error sending to remote server");
d1039 67
a1105 33
    if (rc == 550)
    {
       Explain0("FTP: RETR failed, trying LIST instead");
       parms="d";
       bputs("CWD ", f);
       bwrite(f, path, len);
       bputs("\015\012", f);
       bflush(f);
       Explain1("FTP: CWD %s", path);
       rc = ftp_getrc(f);
       Explain1("FTP: returned status %d", rc);
       if (rc == -1) {
          kill_timeout(r);
          return proxyerror(r, "Error sending to remote server");
       }
       if (rc == 550) {
          kill_timeout(r);
          return NOT_FOUND;
       }
       if (rc != 250) {
          kill_timeout(r);
          return BAD_GATEWAY;
       }

       bputs("LIST -lag\015\012", f);
       bflush(f);
       Explain0("FTP: LIST -lag");
       rc = ftp_getrc(f);
       Explain1("FTP: returned status %d", rc);
       if (rc == -1) return proxyerror(r, "Error sending to remote server");
    }   
    kill_timeout(r);
    if (rc != 125 && rc != 150 && rc != 226 && rc != 250) return BAD_GATEWAY;
d1107 1
a1107 1
    r->status = 200;
d1110 3
a1112 1
    resp_hdrs = make_array(pool, 2, sizeof(struct hdr_entry));
d1114 13
a1126 12
	proxy_add_header(resp_hdrs, "Content-Type", "text/html", HDR_REP);
    else
    {
        find_ct(r);
        if(r->content_type != NULL)
        {
            proxy_add_header(resp_hdrs, "Content-Type", r->content_type,
		HDR_REP);
            Explain1("FTP: Content-Type set to %s",r->content_type);
        } else
	{
	    proxy_add_header(resp_hdrs, "Content-Type", "text/plain", HDR_REP);
d1130 5
a1134 6
/* check if NoCache directive on this host */ 
    for (i=0; i < conf->nocaches->nelts; i++)
    {
        if ((ncent[i].name != NULL && strstr(host, ncent[i].name) != NULL)
          || destaddr.s_addr == ncent[i].addr.s_addr || ncent[i].name[0] == '*')
            nocache = 1;
d1137 5
a1141 6
    i = proxy_cache_update(c, resp_hdrs, 0, nocache);

    if (i != DECLINED)
    {
	pclosef(pool, dsock);
	pclosef(pool, sock);
a1143 1
    cache = c->fp;
d1145 24
a1168 20
    if (!pasvmode)	/* wait for connection */
    {
        hard_timeout ("proxy ftp data connect", r);
        len = sizeof(struct sockaddr_in);
        do csd = accept(dsock, (struct sockaddr *)&server, &len);
        while (csd == -1 && errno == EINTR);
        if (csd == -1)
        {
	    proxy_log_uerror("accept", NULL,
	        "proxy: failed to accept data connection", r->server);
	    pclosef(pool, dsock);
	    pclosef(pool, sock);
	    kill_timeout(r);
	    proxy_cache_error(c);
	    return BAD_GATEWAY;
        }
        note_cleanups_for_fd(pool, csd);
        data = bcreate(pool, B_RDWR);
        bpushfd(data, csd, -1);
	kill_timeout(r);
d1171 5
a1175 1
    hard_timeout ("proxy receive", r);
d1179 4
a1182 5
	rvputs(r, "HTTP/1.0 ", r->status_line, "\015\012", NULL);
    if (cache != NULL)
	if (bvputs(cache, "HTTP/1.0 ", r->status_line, "\015\012",
		   NULL) == -1)
	    cache = proxy_cache_error(c);
d1185 3
a1187 13
    len = resp_hdrs->nelts;
    hdr = (struct hdr_entry *)resp_hdrs->elts;
    for (i=0; i < len; i++)
    {
	if (hdr[i].field == NULL || hdr[i].value == NULL ||
	    hdr[i].value[0] == '\0') continue;
	if (!r->assbackwards)
	    rvputs(r, hdr[i].field, ": ", hdr[i].value, "\015\012", NULL);
	if (cache != NULL)
	    if (bvputs(cache, hdr[i].field, ": ", hdr[i].value, "\015\012",
		       NULL) == -1)
		cache = proxy_cache_error(c);
    }
d1189 4
a1192 3
    if (!r->assbackwards) rputs("\015\012", r);
    if (cache != NULL)
	if (bputs("\015\012", cache) == -1) cache = proxy_cache_error(c);
d1194 1
a1194 1
    bsetopt(r->connection->client, BO_BYTECT, &zero);
d1197 11
a1207 4
    if (!r->header_only)
    {
	if (parms[0] != 'd') proxy_send_fb(data, r, cache, c);
        else send_dir(data, r, cache, c, url);
d1209 3
a1211 2
	if (rc == 125 || rc == 150) rc = ftp_getrc(f);
	if (rc != 226 && rc != 250) proxy_cache_error(c);
d1213 1
a1213 2
    else
    {
d1215 2
a1216 2
	bputs("ABOR\015\012", f);
	bflush(f);
d1218 2
a1219 2
            pclosef(pool, csd);
        Explain0("FTP: ABOR");
d1221 6
d1228 1
a1228 1
        Explain1("FTP: returned status %d",i);
d1231 2
a1232 2
    kill_timeout(r);
    proxy_cache_tidy(c);
d1235 2
a1236 2
    bputs("QUIT\015\012", f);
    bflush(f);
d1238 5
a1242 1
/* responses: 221, 500 */    
d1244 3
a1246 4
    if (!pasvmode)
        pclosef(pool, csd);
    pclosef(pool, dsock);
    pclosef(pool, sock);
d1248 3
a1250 1
    proxy_garbage_coll(r);
a1253 1

@


1.1.1.1
log
@Initial import from apache 1.2.6
@
text
@@


1.1.1.2
log
@Apache 1.3.2
@
text
@d2 1
a2 1
 * Copyright (c) 1996-1998 The Apache Group.  All rights reserved.
d23 1
a23 2
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
d25 1
a25 5
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
a56 3
#include "http_log.h"

#define AUTODETECT_PWD
d58 1
a58 1
DEF_Explain
d63 2
a64 1
static int decodeenc(char *x)
d68 3
a70 3
    if (x[0] == '\0')
	return 0;		/* special case for no characters */
    for (i = 0, j = 0; x[i] != '\0'; i++, j++) {
d73 3
a75 2
	if (ch == '%' && isxdigit(x[i + 1]) && isxdigit(x[i + 2])) {
	    ch = ap_proxy_hex2c(&x[i + 1]);
d88 2
a89 1
static int ftp_check_string(const char *x)
d93 2
a94 1
    for (i = 0; x[i] != '\0'; i++) {
d96 3
a98 2
	if (ch == '%' && isxdigit(x[i + 1]) && isxdigit(x[i + 2])) {
	    ch = ap_proxy_hex2c(&x[i + 1]);
d101 1
a101 6
#ifndef CHARSET_EBCDIC
	if (ch == '\015' || ch == '\012' || (ch & 0x80))
#else /*CHARSET_EBCDIC*/
	if (ch == '\r' || ch == '\n' || (os_toascii[ch] & 0x80))
#endif /*CHARSET_EBCDIC*/
	    return 0;
d109 2
a110 1
int ap_proxy_ftp_canon(request_rec *r, char *url)
d112 2
a113 2
    char *user, *password, *host, *path, *parms, *strp, sport[7];
    pool *p = r->pool;
d118 4
a121 7
    err = ap_proxy_canon_netloc(p, &url, &user, &password, &host, &port);
    if (err)
	return HTTP_BAD_REQUEST;
    if (user != NULL && !ftp_check_string(user))
	return HTTP_BAD_REQUEST;
    if (password != NULL && !ftp_check_string(password))
	return HTTP_BAD_REQUEST;
d129 7
a135 8
    strp = strchr(url, ';');
    if (strp != NULL) {
	*(strp++) = '\0';
	parms = ap_proxy_canonenc(p, strp, strlen(strp), enc_parm, r->proxyreq);
	if (parms == NULL)
	    return HTTP_BAD_REQUEST;
    }
    else
d138 11
a148 12
    path = ap_proxy_canonenc(p, url, strlen(url), enc_path, r->proxyreq);
    if (path == NULL)
	return HTTP_BAD_REQUEST;
    if (!ftp_check_string(path))
	return HTTP_BAD_REQUEST;

    if (!r->proxyreq && r->args != NULL) {
	if (strp != NULL) {
	    strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_parm, 1);
	    if (strp == NULL)
		return HTTP_BAD_REQUEST;
	    parms = ap_pstrcat(p, parms, "?", strp, NULL);
d150 5
a154 5
	else {
	    strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_fpath, 1);
	    if (strp == NULL)
		return HTTP_BAD_REQUEST;
	    path = ap_pstrcat(p, path, "?", strp, NULL);
d161 2
a162 4
    if (port != DEFAULT_FTP_PORT)
	ap_snprintf(sport, sizeof(sport), ":%d", port);
    else
	sport[0] = '\0';
d164 5
a168 5
    r->filename = ap_pstrcat(p, "proxy:ftp://", (user != NULL) ? user : "",
			       (password != NULL) ? ":" : "",
			       (password != NULL) ? password : "",
		          (user != NULL) ? "@@" : "", host, sport, "/", path,
			       (parms[0] != '\0') ? ";" : "", parms, NULL);
d177 2
a178 1
static int ftp_getrc(BUFF *f)
d180 1
a180 1
    int len, status;
d183 2
a184 3
    len = ap_bgets(linebuff, sizeof linebuff, f);
    if (len == -1)
	return -1;
d186 2
a187 2
    if (len < 5 || !ap_isdigit(linebuff[0]) || !ap_isdigit(linebuff[1]) ||
	!ap_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
d192 3
a194 2
    if (linebuff[len - 1] != '\n') {
	(void)ap_bskiplf(f);
d197 3
a199 2
/* skip continuation lines */
    if (linebuff[3] == '-') {
d202 7
a208 6
	do {
	    len = ap_bgets(linebuff, sizeof linebuff, f);
	    if (len == -1)
		return -1;
	    if (linebuff[len - 1] != '\n') {
		(void)ap_bskiplf(f);
d216 2
a217 5
/*
 * Like ftp_getrc but returns both the ftp status code and 
 * remembers the response message in the supplied buffer
 */
static int ftp_getrc_msg(BUFF *f, char *msgbuf, int msglen)
d219 13
a231 31
    int len, status;
    char linebuff[100], buff[5];
    char *mb = msgbuf,
	 *me = &msgbuf[msglen];

    len = ap_bgets(linebuff, sizeof linebuff, f);
    if (len == -1)
	return -1;
    if (len < 5 || !ap_isdigit(linebuff[0]) || !ap_isdigit(linebuff[1]) ||
	!ap_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
	status = 0;
    else
	status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';

    mb = ap_cpystrn(mb, linebuff+4, me - mb);

    if (linebuff[len - 1] != '\n')
	(void)ap_bskiplf(f);

    if (linebuff[3] == '-') {
	memcpy(buff, linebuff, 3);
	buff[3] = ' ';
	do {
	    len = ap_bgets(linebuff, sizeof linebuff, f);
	    if (len == -1)
		return -1;
	    if (linebuff[len - 1] != '\n') {
		(void)ap_bskiplf(f);
	    }
	    mb = ap_cpystrn(mb, linebuff+4, me - mb);
	} while (memcmp(linebuff, buff, 4) != 0);
d233 2
a234 1
    return status;
d237 2
a238 1
static long int send_dir(BUFF *f, request_rec *r, cache_req *c, char *cwd)
d243 2
d248 2
a249 1
    unsigned long total_bytes_sent = 0;
a251 1
    char *dir, *path, *reldir, *site;
d253 41
a293 68
    /* Save "scheme://site" prefix without password */
    site = ap_unparse_uri_components(r->pool, &r->parsed_uri, UNP_OMITPASSWORD|UNP_OMITPATHINFO);
    /* ... and path without query args */
    path = ap_unparse_uri_components(r->pool, &r->parsed_uri, UNP_OMITSITEPART|UNP_OMITQUERY);
    (void)decodeenc(path);

    /* Copy path, strip (all except the last) trailing slashes */
    path = dir = ap_pstrcat(r->pool, path, "/", NULL);
    while ((n = strlen(path)) > 1 && path[n-1] == '/' && path[n-2] == '/')
	path[n-1] = '\0';

    /* print "ftp://host/" */
    n = ap_snprintf(buf, sizeof(buf), "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n"
		"<HTML><HEAD><TITLE>%s%s</TITLE>\n"
		"<BASE HREF=\"%s%s\"></HEAD>\n"
		"<BODY><H2>Directory of "
		"<A HREF=\"/\">%s</A>/",
		site, path, site, path, site);
    total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);

    while ((dir = strchr(dir+1, '/')) != NULL)
    {
	*dir = '\0';
	if ((reldir = strrchr(path+1, '/'))==NULL)
	    reldir = path+1;
	else
	    ++reldir;
	/* print "path/" component */
	ap_snprintf(buf, sizeof(buf), "<A HREF=\"/%s/\">%s</A>/", path+1, reldir);
	total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);
	*dir = '/';
    }
    /* If the caller has determined the current directory, and it differs */
    /* from what the client requested, then show the real name */
    if (cwd == NULL || strncmp (cwd, path, strlen(cwd)) == 0) {
	ap_snprintf(buf, sizeof(buf), "</H2>\n<HR><PRE>");
    } else {
	ap_snprintf(buf, sizeof(buf), "</H2>\n(%s)\n<HR><PRE>", cwd);
    }
    total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);

    while (!con->aborted) {
	n = ap_bgets(buf, sizeof buf, f);
	if (n == -1) {		/* input error */
	    if (c != NULL)
		c = ap_proxy_cache_error(c);
	    break;
	}
	if (n == 0)
	    break;		/* EOF */
	if (buf[0] == 'l' && (filename=strstr(buf, " -> ")) != NULL) {
	    char *link_ptr = filename;

	    do {
		filename--;
	    } while (filename[0] != ' ');
	    *(filename++) = '\0';
	    *(link_ptr++) = '\0';
	    if ((n = strlen(link_ptr)) > 1 && link_ptr[n - 1] == '\n')
	      link_ptr[n - 1] = '\0';
	    ap_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s\">%s %s</A>\n", buf, filename, filename, link_ptr);
	    ap_cpystrn(buf, buf2, sizeof(buf));
	    n = strlen(buf);
	}
	else if (buf[0] == 'd' || buf[0] == '-' || buf[0] == 'l' || ap_isdigit(buf[0])) {
	    if (ap_isdigit(buf[0])) {	/* handle DOS dir */
		searchptr = strchr(buf, '<');
		if (searchptr != NULL)
d295 2
a296 2
		searchptr = strchr(buf, '>');
		if (searchptr != NULL)
d299 4
d304 2
a305 6
	    filename = strrchr(buf, ' ');
	    *(filename++) = 0;
	    filename[strlen(filename) - 1] = 0;

	    /* handle filenames with spaces in 'em */
	    if (!strcmp(filename, ".") || !strcmp(filename, "..") || firstfile) {
d307 52
a358 7
		searchidx = filename - buf;
	    }
	    else if (searchidx != 0 && buf[searchidx] != 0) {
		*(--filename) = ' ';
		buf[searchidx - 1] = 0;
		filename = &buf[searchidx];
	    }
d360 1
a360 13
	    /* Special handling for '.' and '..' */
	    if (!strcmp(filename, ".") || !strcmp(filename, "..") || buf[0] == 'd') {
		ap_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s/\">%s</A>\n",
		    buf, filename, filename);
	    }
	    else {
		ap_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s\">%s</A>\n", buf, filename, filename);
	    }
	    ap_cpystrn(buf, buf2, sizeof(buf));
	    n = strlen(buf);
	}

	o = 0;
d363 5
a367 5
	if (c != NULL && c->fp && ap_bwrite(c->fp, buf, n) != n)
	    c = ap_proxy_cache_error(c);

	while (n && !r->connection->aborted) {
	    w = ap_bwrite(con->client, &buf[o], n);
d370 12
a381 12
	    ap_reset_timeout(r);	/* reset timeout after successfule write */
	    n -= w;
	    o += w;
	}
    }

    total_bytes_sent += ap_proxy_bputs2("</PRE><HR>\n", con->client, c);
    total_bytes_sent += ap_proxy_bputs2(ap_psignature("", r), con->client, c);
    total_bytes_sent += ap_proxy_bputs2("</BODY></HTML>\n", con->client, c);

    ap_bflush(con->client);

a384 28
/* Common routine for failed authorization (i.e., missing or wrong password)
 * to an ftp service. This causes most browsers to retry the request
 * with username and password (which was presumably queried from the user)
 * supplied in the Authorization: header.
 * Note that we "invent" a realm name which consists of the
 * ftp://user@@host part of the reqest (sans password -if supplied but invalid-)
 */
static int ftp_unauthorized (request_rec *r, int log_it)
{
    r->proxyreq = 0;
    /* Log failed requests if they supplied a password
     * (log username/password guessing attempts)
     */
    if (log_it)
	ap_log_rerror(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, r,
		      "proxy: missing or failed auth to %s",
		      ap_unparse_uri_components(r->pool,
		      &r->parsed_uri, UNP_OMITPATHINFO));

    ap_table_setn(r->err_headers_out, "WWW-Authenticate",
                  ap_pstrcat(r->pool, "Basic realm=\"",
		  ap_unparse_uri_components(r->pool, &r->parsed_uri,
					    UNP_OMITPASSWORD|UNP_OMITPATHINFO),
		  "\"", NULL));

    return HTTP_UNAUTHORIZED;
}

d391 2
a392 1
int ap_proxy_ftp_handler(request_rec *r, cache_req *c, char *url)
d394 1
a394 5
    char *host, *path, *strp, *parms;
    char *cwd = NULL;
    char *user = NULL;
/*    char *account = NULL; how to supply an account in a URL? */
    const char *password = NULL;
d396 2
a397 1
    int port, i, j, len, sock, dsock, rc, nocache = 0;
d401 1
d403 2
a404 2
    table *resp_hdrs;
    BUFF *f;
d406 3
a408 5
    pool *p = r->pool;
    int one = 1;
    const long int zero = 0L;
    NET_SIZE_T clen;
    struct tbl_do_args tdo;
d412 3
a414 3
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
    struct noproxy_entry *npent = (struct noproxy_entry *) conf->noproxies->elts;
    struct nocache_entry *ncent = (struct nocache_entry *) conf->nocaches->elts;
d424 1
a424 5

/* stuff for responses */
    char resp[MAX_STRING_LEN];
    char *size = NULL;

d427 1
a427 2
    if (r->method_number != M_GET)
	return HTTP_NOT_IMPLEMENTED;
d431 28
a458 38
    host = r->parsed_uri.hostname;
    port = (r->parsed_uri.port != 0)
	    ? r->parsed_uri.port
	    : ap_default_port_for_request(r);
    path = ap_pstrdup(p, r->parsed_uri.path);
    path = (path != NULL && path[0] != '\0') ? &path[1] : "";

    /* The "Authorization:" header must be checked first.
     * We allow the user to "override" the URL-coded user [ & password ]
     * in the Browsers' User&Password Dialog.
     * NOTE that this is only marginally more secure than having the
     * password travel in plain as part of the URL, because Basic Auth
     * simply uuencodes the plain text password. 
     * But chances are still smaller that the URL is logged regularly.
     */
    if ((password = ap_table_get(r->headers_in, "Authorization")) != NULL
	&& strcasecmp(ap_getword(r->pool, &password, ' '), "Basic") == 0
	&& (password = ap_uudecode(r->pool, password))[0] != ':') {
	/* Note that this allocation has to be made from r->connection->pool
	 * because it has the lifetime of the connection.  The other allocations
	 * are temporary and can be tossed away any time.
	 */
	user = ap_getword_nulls (r->connection->pool, &password, ':');
	r->connection->ap_auth_type = "Basic";
	r->connection->user = r->parsed_uri.user = user;
	nocache = 1;	/* This resource only accessible with username/password */
    }
    else if ((user = r->parsed_uri.user) != NULL) {
	user = ap_pstrdup(p, user);
	decodeenc(user);
	if ((password = r->parsed_uri.password) != NULL) {
	    char *tmp = ap_pstrdup(p, password);
	    decodeenc(tmp);
	    password = tmp;
	}
	nocache = 1;	/* This resource only accessible with username/password */
    }
    else {
d460 2
d463 9
d475 6
a480 5
    destaddr.s_addr = ap_inet_addr(host);
    for (i = 0; i < conf->noproxies->nelts; i++) {
	if ((npent[i].name != NULL && strstr(host, npent[i].name) != NULL)
	    || destaddr.s_addr == npent[i].addr.s_addr || npent[i].name[0] == '*')
	    return ap_proxyerror(r, /*HTTP_FORBIDDEN*/ "Connect to remote machine blocked");
d483 1
a483 1
    Explain2("FTP: connect to %s:%d", host, port);
d486 1
a486 2
    if (parms != NULL)
	*(parms++) = '\0';
d491 19
a509 39
    err = ap_proxy_host2addr(host, &server_hp);
    if (err != NULL)
	return ap_proxyerror(r, err);	/* give up */

    sock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sock == -1) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "proxy: error creating socket");
	return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (conf->recv_buffer_size > 0
	&& setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
		       (const char *) &conf->recv_buffer_size, sizeof(int))
	    == -1) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
    }

    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &one,
		   sizeof(one)) == -1) {
#ifndef _OSD_POSIX /* BS2000 has this option "always on" */
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "proxy: error setting reuseaddr option: setsockopt(SO_REUSEADDR)");
	ap_pclosesocket(p, sock);
	return HTTP_INTERNAL_SERVER_ERROR;
#endif /*_OSD_POSIX*/
    }

#ifdef SINIX_D_RESOLVER_BUG
    {
	struct in_addr *ip_addr = (struct in_addr *) *server_hp.h_addr_list;

	for (; ip_addr->s_addr != 0; ++ip_addr) {
	    memcpy(&server.sin_addr, ip_addr, sizeof(struct in_addr));
	    i = ap_proxy_doconnect(sock, &server, r);
	    if (i == 0)
		break;
	}
d511 1
a511 1
#else
d514 9
a522 14
	memcpy(&server.sin_addr, server_hp.h_addr_list[j],
	       sizeof(struct in_addr));
	i = ap_proxy_doconnect(sock, &server, r);
	if (i == 0)
	    break;
	j++;
    }
#endif
    if (i == -1) {
	ap_pclosesocket(p, sock);
	return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ ap_pstrcat(r->pool,
				"Could not connect to remote machine: ",
				strerror(errno), NULL));
    }
d524 2
a525 2
    f = ap_bcreate(p, B_RDWR | B_SOCKET);
    ap_bpushfd(f, sock, sock);
d528 3
a530 10
#ifdef CHARSET_EBCDIC
    ap_bsetflag(f, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 1);
#endif /*CHARSET_EBCDIC*/

/* possible results: */
    /* 120 Service ready in nnn minutes. */
    /* 220 Service ready for new user. */
    /* 421 Service not available, closing control connection. */
    ap_hard_timeout("proxy ftp", r);
    i = ftp_getrc_msg(f, resp, sizeof resp);
d533 2
a534 2
	ap_kill_timeout(r);
	return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
a535 17
#if 0
    if (i == 120) {
	ap_kill_timeout(r);
	/* RFC2068 states:
	 * 14.38 Retry-After
	 * 
	 *  The Retry-After response-header field can be used with a 503 (Service
	 *  Unavailable) response to indicate how long the service is expected to
	 *  be unavailable to the requesting client. The value of this field can
	 *  be either an HTTP-date or an integer number of seconds (in decimal)
	 *  after the time of the response.
	 *     Retry-After  = "Retry-After" ":" ( HTTP-date | delta-seconds )
	 */
	ap_set_header("Retry-After", ap_psprintf(p, "%u", 60*wait_mins);
	return ap_proxyerror(r, /*HTTP_SERVICE_UNAVAILABLE*/ resp);
    }
#endif
d537 2
a538 2
	ap_kill_timeout(r);
	return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ resp);
d543 6
a548 4
    ap_bvputs(f, "USER ", user, CRLF, NULL);
    ap_bflush(f);			/* capture any errors */
    Explain1("FTP: USER %s", user);

a550 8
    /* 230 User logged in, proceed. */
    /* 331 User name okay, need password. */
    /* 332 Need account for login. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /*     (This may include errors such as command line too long.) */
    /* 501 Syntax error in parameters or arguments. */
    /* 530 Not logged in. */
d552 1
a552 1
    Explain1("FTP: returned status %d", i);
d554 2
a555 2
	ap_kill_timeout(r);
	return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d558 2
a559 2
	ap_kill_timeout(r);
	return ftp_unauthorized (r, 1);	/* log it: user name guessing attempt? */
d562 2
a563 2
	ap_kill_timeout(r);
	return HTTP_BAD_GATEWAY;
d565 9
a573 8

    if (i == 331) {		/* send password */
	if (password == NULL) {
	    return ftp_unauthorized (r, 0);
	}
	ap_bvputs(f, "PASS ", password, CRLF, NULL);
	ap_bflush(f);
	Explain1("FTP: PASS %s", password);
a574 7
    /* 230 User logged in, proceed. */
    /* 332 Need account for login. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 503 Bad sequence of commands. */
    /* 530 Not logged in. */
d576 1
a576 1
	Explain1("FTP: returned status %d", i);
d578 2
a579 2
	    ap_kill_timeout(r);
	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d582 2
a583 2
	    ap_kill_timeout(r);
	    return ap_proxyerror(r, /*HTTP_UNAUTHORIZED*/ "Need account for login");
a584 1
	/* @@@@@@ questionable -- we might as well return a 403 Forbidden here */
d586 2
a587 2
	    ap_kill_timeout(r);
	    return ftp_unauthorized (r, 1); /* log it: passwd guessing attempt? */
d590 2
a591 2
	    ap_kill_timeout(r);
	    return HTTP_BAD_GATEWAY;
d593 1
a593 1
    }
d595 2
a596 2
/* set the directory (walk directory component by component):
 * this is what we must do if we don't know the OS type of the remote
d599 5
a603 5
    for (;;) {
	strp = strchr(path, '/');
	if (strp == NULL)
	    break;
	*strp = '\0';
d606 5
a610 4
	ap_bvputs(f, "CWD ", path, CRLF, NULL);
	ap_bflush(f);
	Explain1("FTP: CWD %s", path);
	*strp = '/';
d612 1
a612 7
    /* 250 Requested file action okay, completed. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
    /* 530 Not logged in. */
    /* 550 Requested action not taken. */
d614 1
a614 1
	Explain1("FTP: returned status %d", i);
d616 2
a617 2
	    ap_kill_timeout(r);
	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d620 2
a621 2
	    ap_kill_timeout(r);
	    return HTTP_NOT_FOUND;
d624 2
a625 2
	    ap_kill_timeout(r);
	    return HTTP_BAD_GATEWAY;
d628 1
a628 1
	path = strp + 1;
d631 2
a632 1
    if (parms != NULL && strncmp(parms, "type=", 5) == 0) {
d635 1
a635 2
	    parms[1] != '\0')
	    parms = "";
d637 1
a637 2
    else
	parms = "";
d641 2
a642 1
    if (parms[0] != 'a') {
d644 5
a648 5
	/* TM - Added \015\012 to the end of TYPE I, otherwise it hangs the
	   connection */
	ap_bputs("TYPE I" CRLF, f);
	ap_bflush(f);
	Explain0("FTP: TYPE I");
a649 6
    /* 200 Command okay. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 504 Command not implemented for that parameter. */
    /* 530 Not logged in. */
d651 1
a651 1
	Explain1("FTP: returned status %d", i);
d653 2
a654 2
	    ap_kill_timeout(r);
	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d657 2
a658 2
	    ap_kill_timeout(r);
	    return HTTP_BAD_GATEWAY;
d666 8
a673 15
    dsock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (dsock == -1) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
		     "proxy: error creating PASV socket");
	ap_bclose(f);
	ap_kill_timeout(r);
	return HTTP_INTERNAL_SERVER_ERROR;
    }

    if (conf->recv_buffer_size) {
	if (setsockopt(dsock, SOL_SOCKET, SO_RCVBUF,
	       (const char *) &conf->recv_buffer_size, sizeof(int)) == -1) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
	}
d675 1
d677 2
a678 2
    ap_bputs("PASV" CRLF, f);
    ap_bflush(f);
d681 13
a693 17
    /* 227 Entering Passive Mode (h1,h2,h3,h4,p1,p2). */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
    /* 530 Not logged in. */
    i = ap_bgets(pasv, sizeof(pasv), f);
    if (i == -1) {
	ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
		     "PASV: control connection is toast");
	ap_pclosesocket(p, dsock);
	ap_bclose(f);
	ap_kill_timeout(r);
	return HTTP_INTERNAL_SERVER_ERROR;
    }
    else {
	pasv[i - 1] = '\0';
d695 2
a696 1
	if (pstr != NULL) {
d698 3
a700 8
	    if (*(pstr + strlen(pstr) + 1) == '=')
	        pstr += strlen(pstr) + 2;
	    else
	    {
	        pstr = strtok(NULL, "(");  /* separate address & port params */
		if (pstr != NULL)
		    pstr = strtok(NULL, ")");
	    }
d708 2
a709 1
		 "%d,%d,%d,%d,%d,%d", &h3, &h2, &h1, &h0, &p1, &p0) == 6)) {
d711 2
a712 2
	    paddr = (((((h3 << 8) + h2) << 8) + h1) << 8) + h0;
	    pport = (p1 << 8) + p0;
d714 5
a718 5
		     h3, h2, h1, h0, pport);
	    data_addr.sin_family = AF_INET;
	    data_addr.sin_addr.s_addr = htonl(paddr);
	    data_addr.sin_port = htons(pport);
	    i = ap_proxy_doconnect(dsock, &data_addr, r);
d721 2
a722 4
		ap_kill_timeout(r);
		return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ ap_pstrcat(r->pool,
				"Could not connect to remote machine: ",
				strerror(errno), NULL));
d725 3
a727 1
		pasvmode = 1;
d729 2
a730 3
	}
	else
	    ap_pclosesocket(p, dsock);	/* and try the regular way */
d733 37
a769 33
    if (!pasvmode) {		/* set up data connection */
	clen = sizeof(struct sockaddr_in);
	if (getsockname(sock, (struct sockaddr *) &server, &clen) < 0) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "proxy: error getting socket address");
	    ap_bclose(f);
	    ap_kill_timeout(r);
	    return HTTP_INTERNAL_SERVER_ERROR;
	}

	dsock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (dsock == -1) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "proxy: error creating socket");
	    ap_bclose(f);
	    ap_kill_timeout(r);
	    return HTTP_INTERNAL_SERVER_ERROR;
	}

	if (setsockopt(dsock, SOL_SOCKET, SO_REUSEADDR, (void *) &one,
		       sizeof(one)) == -1) {
#ifndef _OSD_POSIX /* BS2000 has this option "always on" */
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "proxy: error setting reuseaddr option");
	    ap_pclosesocket(p, dsock);
	    ap_bclose(f);
	    ap_kill_timeout(r);
	    return HTTP_INTERNAL_SERVER_ERROR;
#endif /*_OSD_POSIX*/
	}

	if (bind(dsock, (struct sockaddr *) &server,
		 sizeof(struct sockaddr_in)) == -1) {
d773 6
a778 7
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "proxy: error binding to ftp data socket %s", buff);
	    ap_bclose(f);
	    ap_pclosesocket(p, dsock);
	    return HTTP_INTERNAL_SERVER_ERROR;
	}
	listen(dsock, 2);	/* only need a short queue */
d781 1
a781 1
/* set request; "path" holds last path component */
d786 40
a825 2
    if (len == 0) {
	parms = "d";
d827 6
a832 46
    else {
	ap_bvputs(f, "SIZE ", path, CRLF, NULL);
	ap_bflush(f);
	Explain1("FTP: SIZE %s", path);
	i = ftp_getrc_msg(f, resp, sizeof resp);
	Explain2("FTP: returned status %d with response %s", i, resp);
	if (i != 500) {		/* Size command not recognized */
	    if (i == 550) {	/* Not a regular file */
		Explain0("FTP: SIZE shows this is a directory");
		parms = "d";
		ap_bvputs(f, "CWD ", path, CRLF, NULL);
		ap_bflush(f);
		Explain1("FTP: CWD %s", path);
		i = ftp_getrc(f);
		/* possible results: 250, 421, 500, 501, 502, 530, 550 */
		/* 250 Requested file action okay, completed. */
		/* 421 Service not available, closing control connection. */
		/* 500 Syntax error, command unrecognized. */
		/* 501 Syntax error in parameters or arguments. */
		/* 502 Command not implemented. */
		/* 530 Not logged in. */
		/* 550 Requested action not taken. */
		Explain1("FTP: returned status %d", i);
		if (i == -1) {
		    ap_kill_timeout(r);
		    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
		}
		if (i == 550) {
		    ap_kill_timeout(r);
		    return HTTP_NOT_FOUND;
		}
		if (i != 250) {
		    ap_kill_timeout(r);
		    return HTTP_BAD_GATEWAY;
		}
		path = "";
		len = 0;
	    }
	    else if (i == 213) { /* Size command ok */
		for (j = 0; j < sizeof resp && ap_isdigit(resp[j]); j++)
			;
		resp[j] = '\0';
		if (resp[0] != '\0')
		    size = ap_pstrdup(p, resp);
	    }
	}
d834 4
a837 38

#ifdef AUTODETECT_PWD
    ap_bvputs(f, "PWD", CRLF, NULL);
    ap_bflush(f);
    Explain0("FTP: PWD");
/* responses: 257, 500, 501, 502, 421, 550 */
    /* 257 "<directory-name>" <commentary> */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
    /* 550 Requested action not taken. */
    i = ftp_getrc_msg(f, resp, sizeof resp);
    Explain1("FTP: PWD returned status %d", i);
    if (i == -1 || i == 421) {
	ap_kill_timeout(r);
	return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
    }
    if (i == 550) {
	ap_kill_timeout(r);
	return HTTP_NOT_FOUND;
    }
    if (i == 257) {
	const char *dirp = resp;
	cwd = ap_getword_conf(r->pool, &dirp);
    }
#endif /*AUTODETECT_PWD*/

    if (parms[0] == 'd') {
	if (len != 0)
	    ap_bvputs(f, "LIST ", path, CRLF, NULL);
	else
	    ap_bputs("LIST -lag" CRLF, f);
	Explain1("FTP: LIST %s", (len == 0 ? "" : path));
    }
    else {
	ap_bvputs(f, "RETR ", path, CRLF, NULL);
	Explain1("FTP: RETR %s", path);
d839 3
a841 1
    ap_bflush(f);
a843 14
    /* 110 Restart marker reply. */
    /* 125 Data connection already open; transfer starting. */
    /* 150 File status okay; about to open data connection. */
    /* 226 Closing data connection. */
    /* 250 Requested file action okay, completed. */
    /* 421 Service not available, closing control connection. */
    /* 425 Can't open data connection. */
    /* 426 Connection closed; transfer aborted. */
    /* 450 Requested file action not taken. */
    /* 451 Requested action aborted. Local error in processing. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 530 Not logged in. */
    /* 550 Requested action not taken. */
d845 1
a845 1
    Explain1("FTP: returned status %d", rc);
d847 2
a848 2
	ap_kill_timeout(r);
	return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
d850 33
a882 28
    if (rc == 550) {
	Explain0("FTP: RETR failed, trying LIST instead");
	parms = "d";
	ap_bvputs(f, "CWD ", path, CRLF, NULL);
	ap_bflush(f);
	Explain1("FTP: CWD %s", path);
	/* possible results: 250, 421, 500, 501, 502, 530, 550 */
	/* 250 Requested file action okay, completed. */
	/* 421 Service not available, closing control connection. */
	/* 500 Syntax error, command unrecognized. */
	/* 501 Syntax error in parameters or arguments. */
	/* 502 Command not implemented. */
	/* 530 Not logged in. */
	/* 550 Requested action not taken. */
	rc = ftp_getrc(f);
	Explain1("FTP: returned status %d", rc);
	if (rc == -1) {
	    ap_kill_timeout(r);
	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
	}
	if (rc == 550) {
	    ap_kill_timeout(r);
	    return HTTP_NOT_FOUND;
	}
	if (rc != 250) {
	    ap_kill_timeout(r);
	    return HTTP_BAD_GATEWAY;
	}
d884 1
a884 40
#ifdef AUTODETECT_PWD
	ap_bvputs(f, "PWD", CRLF, NULL);
	ap_bflush(f);
	Explain0("FTP: PWD");
/* responses: 257, 500, 501, 502, 421, 550 */
	/* 257 "<directory-name>" <commentary> */
	/* 421 Service not available, closing control connection. */
	/* 500 Syntax error, command unrecognized. */
	/* 501 Syntax error in parameters or arguments. */
	/* 502 Command not implemented. */
	/* 550 Requested action not taken. */
	i = ftp_getrc_msg(f, resp, sizeof resp);
	Explain1("FTP: PWD returned status %d", i);
	if (i == -1 || i == 421) {
	    ap_kill_timeout(r);
	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
	}
	if (i == 550) {
	    ap_kill_timeout(r);
	    return HTTP_NOT_FOUND;
	}
	if (i == 257) {
	    const char *dirp = resp;
	    cwd = ap_getword_conf(r->pool, &dirp);
	}
#endif /*AUTODETECT_PWD*/

	ap_bputs("LIST -lag" CRLF, f);
	ap_bflush(f);
	Explain0("FTP: LIST -lag");
	rc = ftp_getrc(f);
	Explain1("FTP: returned status %d", rc);
	if (rc == -1)
	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ "Error reading from remote server");
    }
    ap_kill_timeout(r);
    if (rc != 125 && rc != 150 && rc != 226 && rc != 250)
	return HTTP_BAD_GATEWAY;

    r->status = HTTP_OK;
d887 1
a887 3
    resp_hdrs = ap_make_table(p, 2);
    c->hdrs = resp_hdrs;

d889 12
a900 13
	ap_table_set(resp_hdrs, "Content-Type", "text/html");
    else {
	if (r->content_type != NULL) {
	    ap_table_set(resp_hdrs, "Content-Type", r->content_type);
	    Explain1("FTP: Content-Type set to %s", r->content_type);
	}
	else {
	    ap_table_set(resp_hdrs, "Content-Type", "text/plain");
	}
	if (parms[0] != 'a' && size != NULL) {
	    /* We "trust" the ftp server to really serve (size) bytes... */
	    ap_table_set(resp_hdrs, "Content-Length", size);
	    Explain1("FTP: Content-Length set to %s", size);
d904 6
a909 5
/* check if NoCache directive on this host */
    for (i = 0; i < conf->nocaches->nelts; i++) {
	if ((ncent[i].name != NULL && strstr(host, ncent[i].name) != NULL)
	    || destaddr.s_addr == ncent[i].addr.s_addr || ncent[i].name[0] == '*')
	    nocache = 1;
d912 6
a917 5
    i = ap_proxy_cache_update(c, resp_hdrs, 0, nocache);

    if (i != DECLINED) {
	ap_pclosesocket(p, dsock);
	ap_bclose(f);
d920 1
d922 20
a941 24
    if (!pasvmode) {		/* wait for connection */
	ap_hard_timeout("proxy ftp data connect", r);
	clen = sizeof(struct sockaddr_in);
	do
	    csd = accept(dsock, (struct sockaddr *) &server, &clen);
	while (csd == -1 && errno == EINTR);
	if (csd == -1) {
	    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
			 "proxy: failed to accept data connection");
	    ap_pclosesocket(p, dsock);
	    ap_bclose(f);
	    ap_kill_timeout(r);
	    if (c != NULL)
		c = ap_proxy_cache_error(c);
	    return HTTP_BAD_GATEWAY;
	}
	ap_note_cleanups_for_socket(p, csd);
	data = ap_bcreate(p, B_RDWR | B_SOCKET);
	ap_bpushfd(data, csd, -1);
	ap_kill_timeout(r);
    }
    else {
	data = ap_bcreate(p, B_RDWR | B_SOCKET);
	ap_bpushfd(data, dsock, dsock);
d944 1
a944 5
#ifdef CHARSET_EBCDIC
/*    bsetflag(data, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);*/
#endif /*CHARSET_EBCDIC*/

    ap_hard_timeout("proxy receive", r);
d948 5
a952 4
	ap_rvputs(r, "HTTP/1.0 ", r->status_line, CRLF, NULL);
    if (c != NULL && c->fp != NULL
	&& ap_bvputs(c->fp, "HTTP/1.0 ", r->status_line, CRLF, NULL) == -1)
	c = ap_proxy_cache_error(c);
d955 13
a967 3
    tdo.req = r;
    tdo.cache = c;
    ap_table_do(ap_proxy_send_hdr_line, &tdo, resp_hdrs, NULL);
d969 3
a971 4
    if (!r->assbackwards)
	ap_rputs(CRLF, r);
    if (c != NULL && c->fp != NULL && ap_bputs(CRLF, c->fp) == -1)
	c = ap_proxy_cache_error(c);
d973 1
a973 1
    ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
d976 4
a979 11
    if (!r->header_only) {
	if (parms[0] != 'd') {
/* we need to set this for ap_proxy_send_fb()... */
	    if (c != NULL)
		c->cache_completion = 0;
	    ap_proxy_send_fb(data, r, c);
	} else
	    send_dir(data, r, c, cwd);

	if (rc == 125 || rc == 150)
	    rc = ftp_getrc(f);
d981 2
a982 3
	/* XXX: we checked for 125||150||226||250 above. This is redundant. */
	if (rc != 226 && rc != 250)
	    c = ap_proxy_cache_error(c);
d984 2
a985 1
    else {
d987 2
a988 2
	ap_bputs("ABOR" CRLF, f);
	ap_bflush(f);
d990 2
a991 2
	    ap_bclose(data);
	Explain0("FTP: ABOR");
a992 6
    /* 225 Data connection open; no transfer in progress. */
    /* 226 Closing data connection. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 502 Command not implemented. */
d994 1
a994 1
	Explain1("FTP: returned status %d", i);
d997 2
a998 2
    ap_kill_timeout(r);
    ap_proxy_cache_tidy(c);
d1001 2
a1002 2
    ap_bputs("QUIT" CRLF, f);
    ap_bflush(f);
d1004 1
a1004 5
/* responses: 221, 500 */
    /* 221 Service closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    i = ftp_getrc(f);
    Explain1("FTP: QUIT: status %d", i);
d1006 4
a1009 3
    if (pasvmode)
	ap_bclose(data);
    ap_bclose(f);
d1011 1
a1011 3
    ap_rflush(r);	/* flush before garbage collection */

    ap_proxy_garbage_coll(r);
d1015 1
@


1.1.1.3
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 9
a24 6
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
d26 3
a28 4
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
d30 4
a33 3
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
d35 4
a38 4
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 5
a54 3
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
a55 3
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
a62 1
#include "http_core.h"
d66 2
d76 1
a76 1
        return 0;               /* special case for no characters */
d79 6
a84 6
        ch = x[i];
        if (ch == '%' && ap_isxdigit(x[i + 1]) && ap_isxdigit(x[i + 2])) {
            ch = ap_proxy_hex2c(&x[i + 1]);
            i += 2;
        }
        x[j] = ch;
d99 11
a109 7
        ch = x[i];
        if (ch == '%' && ap_isxdigit(x[i + 1]) && ap_isxdigit(x[i + 2])) {
            ch = ap_proxy_hex2c(&x[i + 1]);
            i += 2;
        }
        if (ch == CR || ch == LF || (OS_ASC(ch) & 0x80))
            return 0;
d127 1
a127 1
        return HTTP_BAD_REQUEST;
d129 1
a129 1
        return HTTP_BAD_REQUEST;
d131 1
a131 1
        return HTTP_BAD_REQUEST;
d141 4
a144 5
        *(strp++) = '\0';
        parms = ap_proxy_canonenc(p, strp, strlen(strp), enc_parm,
                                  r->proxyreq);
        if (parms == NULL)
            return HTTP_BAD_REQUEST;
d147 1
a147 1
        parms = "";
d151 1
a151 1
        return HTTP_BAD_REQUEST;
d153 1
a153 1
        return HTTP_BAD_REQUEST;
d155 14
a168 14
    if (r->proxyreq == NOT_PROXY && r->args != NULL) {
        if (strp != NULL) {
            strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_parm, STD_PROXY);
            if (strp == NULL)
                return HTTP_BAD_REQUEST;
            parms = ap_pstrcat(p, parms, "?", strp, NULL);
        }
        else {
            strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_fpath, STD_PROXY);
            if (strp == NULL)
                return HTTP_BAD_REQUEST;
            path = ap_pstrcat(p, path, "?", strp, NULL);
        }
        r->args = NULL;
d174 1
a174 1
        ap_snprintf(sport, sizeof(sport), ":%d", port);
d176 1
a176 1
        sport[0] = '\0';
d179 4
a182 4
                             (password != NULL) ? ":" : "",
                             (password != NULL) ? password : "",
                          (user != NULL) ? "@@" : "", host, sport, "/", path,
                             (parms[0] != '\0') ? ";" : "", parms, NULL);
d191 1
a191 1
static int ftp_getrc(BUFF *ctrl)
d196 1
a196 1
    len = ap_bgets(linebuff, sizeof linebuff, ctrl);
d198 1
a198 1
        return -1;
d201 2
a202 2
     !ap_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
        status = 0;
d204 1
a204 1
        status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';
d207 1
a207 1
        (void)ap_bskiplf(ctrl);
d212 10
a221 10
        memcpy(buff, linebuff, 3);
        buff[3] = ' ';
        do {
            len = ap_bgets(linebuff, sizeof linebuff, ctrl);
            if (len == -1)
                return -1;
            if (linebuff[len - 1] != '\n') {
                (void)ap_bskiplf(ctrl);
            }
        } while (memcmp(linebuff, buff, 4) != 0);
d228 1
a228 1
 * Like ftp_getrc but returns both the ftp status code and
d231 1
a231 1
static int ftp_getrc_msg(BUFF *ctrl, char *msgbuf, int msglen)
d235 2
a236 1
    char *mb = msgbuf, *me = &msgbuf[msglen];
d238 1
a238 1
    len = ap_bgets(linebuff, sizeof linebuff, ctrl);
d240 1
a240 1
        return -1;
d242 2
a243 2
     !ap_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
        status = 0;
d245 1
a245 1
        status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';
d247 1
a247 1
    mb = ap_cpystrn(mb, linebuff + 4, me - mb);
d250 1
a250 1
        (void)ap_bskiplf(ctrl);
d253 11
a263 11
        memcpy(buff, linebuff, 3);
        buff[3] = ' ';
        do {
            len = ap_bgets(linebuff, sizeof linebuff, ctrl);
            if (len == -1)
                return -1;
            if (linebuff[len - 1] != '\n') {
                (void)ap_bskiplf(ctrl);
            }
            mb = ap_cpystrn(mb, linebuff + 4, me - mb);
        } while (memcmp(linebuff, buff, 4) != 0);
d268 1
a268 1
static long int send_dir(BUFF *data, request_rec *r, cache_req *c, char *cwd)
d270 2
a271 2
    char *buf, *buf2;
    size_t buf_size;
d277 1
a277 1
    register int n;
d279 1
a279 9
    pool *p = r->pool;
    char *dir, *path, *reldir, *site, *type = NULL;
    char *basedir = "";         /* By default, path is relative to the $HOME
                                 * dir */

    /* create default sized buffers for the stuff below */
    buf_size = IOBUFSIZE;
    buf = ap_palloc(r->pool, buf_size);
    buf2 = ap_palloc(r->pool, buf_size);
d282 1
a282 1
    site = ap_unparse_uri_components(p, &r->parsed_uri, UNP_OMITPASSWORD | UNP_OMITPATHINFO);
d284 1
a284 11
    path = ap_unparse_uri_components(p, &r->parsed_uri, UNP_OMITSITEPART | UNP_OMITQUERY);

    /* If path began with /%2f, change the basedir */
    if (strncasecmp(path, "/%2f", 4) == 0) {
        basedir = "/%2f";
    }

    /* Strip off a type qualifier. It is ignored for dir listings */
    if ((type = strstr(path, ";type=")) != NULL)
        *type++ = '\0';

a286 3
    while (path[1] == '/')      /* collapse multiple leading slashes to one */
        ++path;

a287 1
    /* (the trailing slash is needed for the dir component loop below) */
d289 2
a290 2
    for (n = strlen(path); n > 1 && path[n - 1] == '/' && path[n - 2] == '/'; --n)
        path[n - 1] = '\0';
d293 6
a298 8
    n = ap_snprintf(buf, buf_size, DOCTYPE_HTML_3_2
                    "<html><head><title>%s%s%s</title>\n"
                    "<base href=\"%s%s%s\"></head>\n"
                    "<body><h2>Directory of "
                    "<a href=\"/\">%s</a>/",
                    site, basedir, ap_escape_html(p, path),
                    site, basedir, ap_escape_uri(p, path),
                    site);
d301 11
a311 21
    /* Add a link to the root directory (if %2f hack was used) */
    if (basedir[0] != '\0') {
        total_bytes_sent += ap_proxy_bputs2("<a href=\"/%2f/\">%2f</a>/", con->client, c);
    }

    for (dir = path + 1; (dir = strchr(dir, '/')) != NULL;) {
        *dir = '\0';
        if ((reldir = strrchr(path + 1, '/')) == NULL) {
            reldir = path + 1;
        }
        else
            ++reldir;
        /* print "path/" component */
        ap_snprintf(buf, buf_size, "<a href=\"%s%s/\">%s</a>/",
                    basedir,
                    ap_escape_uri(p, path),
                    ap_escape_html(p, reldir));
        total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);
        *dir = '/';
        while (*dir == '/')
            ++dir;
a312 1

d315 4
a318 6
    if (cwd == NULL || strncmp(cwd, path, strlen(cwd)) == 0) {
        ap_snprintf(buf, buf_size, "</h2>\n<hr /><pre>");
    }
    else {
        ap_snprintf(buf, buf_size, "</h2>\n(%s)\n<hr /><pre>",
                    ap_escape_html(p, cwd));
d323 73
a395 84
        n = ap_bgets(buf, buf_size, data);
        if (n == -1) {          /* input error */
            if (c != NULL) {
                ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
                              "proxy: error reading from %s", c->url);
                c = ap_proxy_cache_error(c);
            }
            break;
        }
        if (n == 0)
            break;              /* EOF */

        if (buf[n - 1] == '\n') /* strip trailing '\n' */
            buf[--n] = '\0';
        if (buf[n - 1] == '\r') /* strip trailing '\r' if present */
            buf[--n] = '\0';

        /* Handle unix-style symbolic link */
        if (buf[0] == 'l' && (filename = strstr(buf, " -> ")) != NULL) {
            char *link_ptr = filename;

            do {
                filename--;
            } while (filename[0] != ' ' && filename > buf);
            if (filename != buf)
                *(filename++) = '\0';
            *(link_ptr++) = '\0';
            ap_snprintf(buf2, buf_size, "%s <a href=\"%s\">%s %s</a>\n",
                        ap_escape_html(p, buf),
                        ap_escape_uri(p, filename),
                        ap_escape_html(p, filename),
                        ap_escape_html(p, link_ptr));
            ap_cpystrn(buf, buf2, buf_size);
            n = strlen(buf);
        }
        /* Handle unix style or DOS style directory  */
        else if (buf[0] == 'd' || buf[0] == '-' || buf[0] == 'l' || ap_isdigit(buf[0])) {
            if (ap_isdigit(buf[0])) {   /* handle DOS dir */
                searchptr = strchr(buf, '<');
                if (searchptr != NULL)
                    *searchptr = '[';
                searchptr = strchr(buf, '>');
                if (searchptr != NULL)
                    *searchptr = ']';
            }

            filename = strrchr(buf, ' ');
            *(filename++) = 0;

            /* handle filenames with spaces in 'em */
            if (!strcmp(filename, ".") || !strcmp(filename, "..") || firstfile) {
                firstfile = 0;
                searchidx = filename - buf;
            }
            else if (searchidx != 0 && buf[searchidx] != 0) {
                *(--filename) = ' ';
                buf[searchidx - 1] = 0;
                filename = &buf[searchidx];
            }

            /* Special handling for '.' and '..': append slash to link */
            if (!strcmp(filename, ".") || !strcmp(filename, "..") || buf[0] == 'd') {
                ap_snprintf(buf2, buf_size, "%s <a href=\"%s/\">%s</a>\n",
                         ap_escape_html(p, buf), ap_escape_uri(p, filename),
                            ap_escape_html(p, filename));
            }
            else {
                ap_snprintf(buf2, buf_size, "%s <a href=\"%s\">%s</a>\n",
                            ap_escape_html(p, buf),
                            ap_escape_uri(p, filename),
                            ap_escape_html(p, filename));
            }
            ap_cpystrn(buf, buf2, buf_size);
            n = strlen(buf);
        }
        /* else??? What about other OS's output formats? */
        else {
            strcat(buf, "\n");  /* re-append the newline char */
            ap_cpystrn(buf, ap_escape_html(p, buf), buf_size);
        }

        total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);

        ap_reset_timeout(r);    /* reset timeout after successfule write */
d398 1
a398 1
    total_bytes_sent += ap_proxy_bputs2("</pre><hr />\n", con->client, c);
d400 1
a400 3
    total_bytes_sent += ap_proxy_bputs2("</body></html>\n", con->client, c);

    ap_bclose(data);
d414 1
a414 1
static int ftp_unauthorized(request_rec *r, int log_it)
d416 3
a418 4
    r->proxyreq = NOT_PROXY;
    /*
     * Log failed requests if they supplied a password (log username/password
     * guessing attempts)
d421 4
a424 4
        ap_log_rerror(APLOG_MARK, APLOG_INFO | APLOG_NOERRNO, r,
                      "proxy: missing or failed auth to %s",
                      ap_unparse_uri_components(r->pool,
                                         &r->parsed_uri, UNP_OMITPATHINFO));
d428 3
a430 3
                          ap_unparse_uri_components(r->pool, &r->parsed_uri,
                                       UNP_OMITPASSWORD | UNP_OMITPATHINFO),
                             "\"", NULL));
a434 60
/* Set ftp server to TYPE {A,I,E} before transfer of a directory or file */
static int ftp_set_TYPE(request_rec *r, BUFF *ctrl, char xfer_type)
{
    static char old_type[2] = {'A', '\0'};      /* After logon, mode is ASCII */
    int ret = HTTP_OK;
    int rc;

    if (xfer_type == old_type[0])
        return ret;

    /* set desired type */
    old_type[0] = xfer_type;
    ap_bvputs(ctrl, "TYPE ", old_type, CRLF, NULL);
    ap_bflush(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: TYPE %s", old_type);

/* responses: 200, 421, 500, 501, 504, 530 */
    /* 200 Command okay. */
    /* 421 Service not available, closing control connection. */
    /* 500 Syntax error, command unrecognized. */
    /* 501 Syntax error in parameters or arguments. */
    /* 504 Command not implemented for that parameter. */
    /* 530 Not logged in. */
    rc = ftp_getrc(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
    if (rc == -1 || rc == 421) {
        ap_kill_timeout(r);
        ret = ap_proxyerror(r, HTTP_BAD_GATEWAY,
                            "Error reading from remote server");
    }
    else if (rc != 200 && rc != 504) {
        ap_kill_timeout(r);
        ret = ap_proxyerror(r, HTTP_BAD_GATEWAY,
                            "Unable to set transfer type");
    }
/* Allow not implemented */
    else if (rc == 504)
         /* ignore it silently */ ;

    return ret;
}

/* Common cleanup routine: close open BUFFers or sockets, and return an error */
static int ftp_cleanup_and_return(request_rec *r, BUFF *ctrl, BUFF *data, int csock, int dsock, int rc)
{
    if (ctrl != NULL)
        ap_bclose(ctrl);
    else if (csock != -1)
        ap_pclosesocket(r->pool, csock);

    if (data != NULL)
        ap_bclose(data);
    else if (dsock != -1)
        ap_pclosesocket(r->pool, dsock);

    ap_kill_timeout(r);

    return rc;
}

d449 2
a450 2
    int port, i, j, len, rc, nocache = 0;
    int csd = 0, sock = -1, dsock = -1;
d455 1
a455 1
    BUFF *ctrl = NULL;
d459 1
d461 1
a461 2
    char xfer_type = 'A';       /* after ftp login, the default is ASCII */
    int get_dirlisting = 0;
d465 1
a465 1
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
d485 1
a485 1
        return HTTP_NOT_IMPLEMENTED;
d491 2
a492 2
        ? r->parsed_uri.port
        : ap_default_port_for_request(r);
d494 1
a494 5
    if (path == NULL)
        path = "";
    else
        while (*path == '/')
            ++path;
d496 7
a502 7
    /*
     * The "Authorization:" header must be checked first. We allow the user
     * to "override" the URL-coded user [ & password ] in the Browsers'
     * User&Password Dialog. NOTE that this is only marginally more secure
     * than having the password travel in plain as part of the URL, because
     * Basic Auth simply uuencodes the plain text password. But chances are
     * still smaller that the URL is logged regularly.
d505 10
a514 12
        && strcasecmp(ap_getword(r->pool, &password, ' '), "Basic") == 0
        && (password = ap_pbase64decode(r->pool, password))[0] != ':') {
        /*
         * Note that this allocation has to be made from r->connection->pool
         * because it has the lifetime of the connection.  The other
         * allocations are temporary and can be tossed away any time.
         */
        user = ap_getword_nulls(r->connection->pool, &password, ':');
        r->connection->ap_auth_type = "Basic";
        r->connection->user = r->parsed_uri.user = user;
        nocache = 1;            /* This resource only accessible with
                                 * username/password */
d517 8
a524 9
        user = ap_pstrdup(p, user);
        decodeenc(user);
        if ((password = r->parsed_uri.password) != NULL) {
            char *tmp = ap_pstrdup(p, password);
            decodeenc(tmp);
            password = tmp;
        }
        nocache = 1;            /* This resource only accessible with
                                 * username/password */
d527 2
a528 2
        user = "anonymous";
        password = "apache_proxy@@";
d531 1
a531 1
    /* check if ProxyBlock directive on this host */
d534 3
a536 5
        if (destaddr.s_addr == npent[i].addr.s_addr ||
            (npent[i].name != NULL &&
          (npent[i].name[0] == '*' || strstr(host, npent[i].name) != NULL)))
            return ap_proxyerror(r, HTTP_FORBIDDEN,
                                 "Connect to remote machine blocked");
d539 1
a539 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: connect to %s:%d", host, port);
d543 1
a543 1
        *(parms++) = '\0';
d547 1
a547 1
    server.sin_port = htons((unsigned short)port);
d550 1
a550 1
        return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, err);
d554 3
a556 3
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                      "proxy: error creating socket");
        return HTTP_INTERNAL_SERVER_ERROR;
a558 1
#if !defined(TPF) && !defined(BEOS)
d560 5
a564 5
        && setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
                      (const char *)&conf->recv_buffer_size, sizeof(int))
        == -1) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                      "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
a565 1
#endif
d567 8
a574 8
    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *)&one,
                   sizeof(one)) == -1) {
#ifndef _OSD_POSIX              /* BS2000 has this option "always on" */
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
         "proxy: error setting reuseaddr option: setsockopt(SO_REUSEADDR)");
        ap_pclosesocket(p, sock);
        return HTTP_INTERNAL_SERVER_ERROR;
#endif                          /* _OSD_POSIX */
d579 1
a579 1
        struct in_addr *ip_addr = (struct in_addr *)*server_hp.h_addr_list;
d581 6
a586 6
        for (; ip_addr->s_addr != 0; ++ip_addr) {
            memcpy(&server.sin_addr, ip_addr, sizeof(struct in_addr));
            i = ap_proxy_doconnect(sock, &server, r);
            if (i == 0)
                break;
        }
d591 6
a596 6
        memcpy(&server.sin_addr, server_hp.h_addr_list[j],
               sizeof(struct in_addr));
        i = ap_proxy_doconnect(sock, &server, r);
        if (i == 0)
            break;
        j++;
d600 4
a603 4
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                      ap_proxyerror(r, HTTP_BAD_GATEWAY, ap_pstrcat(r->pool,
                                    "Could not connect to remote machine: ",
                                                   strerror(errno), NULL)));
d606 2
a607 5
    /* record request_time for HTTP/1.1 age calculation */
    c->req_time = time(NULL);

    ctrl = ap_bcreate(p, B_RDWR | B_SOCKET);
    ap_bpushfd(ctrl, sock, sock);
d611 2
a612 2
    ap_bsetflag(ctrl, B_ASCII2EBCDIC | B_EBCDIC2ASCII, 1);
#endif                          /* CHARSET_EBCDIC */
d614 1
a614 1
    /* possible results: */
d619 5
a623 6
    i = ftp_getrc_msg(ctrl, resp, sizeof resp);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
    if (i == -1 || i == 421) {
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
d627 13
a639 14
        /*
         * RFC2068 states: 14.38 Retry-After
         * 
         * The Retry-After response-header field can be used with a 503 (Service
         * Unavailable) response to indicate how long the service is expected
         * to be unavailable to the requesting client. The value of this
         * field can be either an HTTP-date or an integer number of seconds
         * (in decimal) after the time of the response. Retry-After  =
         * "Retry-After" ":" ( HTTP-date | delta-seconds )
         */
/**INDENT** Error@@756: Unbalanced parens */
        ap_set_header("Retry-After", ap_psprintf(p, "%u", 60 * wait_mins);
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                          ap_proxyerror(r, HTTP_SERVICE_UNAVAILABLE, resp));
d643 2
a644 2
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                  ap_proxyerror(r, HTTP_BAD_GATEWAY, resp));
d647 1
a647 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: connected.");
d649 3
a651 3
    ap_bvputs(ctrl, "USER ", user, CRLF, NULL);
    ap_bflush(ctrl);            /* capture any errors */
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: USER %s", user);
d653 2
a654 2
    /* possible results; 230, 331, 332, 421, 500, 501, 530 */
    /* states: 1 - error, 2 - success; 3 - send password, 4,5 fail */
d660 1
a660 1
    /* (This may include errors such as command line too long.) */
d663 5
a667 6
    i = ftp_getrc(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
    if (i == -1 || i == 421) {
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
d670 2
a671 2
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      ftp_unauthorized(r, 1));
d674 2
a675 2
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      HTTP_BAD_GATEWAY);
d678 34
a711 69
    if (i == 331) {             /* send password */
        if (password == NULL) {
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ftp_unauthorized(r, 0));
        }
        ap_bvputs(ctrl, "PASS ", password, CRLF, NULL);
        ap_bflush(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PASS %s", password);
        /* possible results 202, 230, 332, 421, 500, 501, 503, 530 */
        /* 230 User logged in, proceed. */
        /* 332 Need account for login. */
        /* 421 Service not available, closing control connection. */
        /* 500 Syntax error, command unrecognized. */
        /* 501 Syntax error in parameters or arguments. */
        /* 503 Bad sequence of commands. */
        /* 530 Not logged in. */
        i = ftp_getrc(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
        if (i == -1 || i == 421) {
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
        }
        if (i == 332) {
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_UNAUTHORIZED,
                                                 "Need account for login"));
        }
        /* @@@@@@ questionable -- we might as well return a 403 Forbidden here */
        if (i == 530)           /* log it: passwd guessing attempt? */
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ftp_unauthorized(r, 1));
        if (i != 230 && i != 202)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_BAD_GATEWAY);
    }

    /*
     * Special handling for leading "%2f": this enforces a "cwd /" out of the
     * $HOME directory which was the starting point after login
     */
    if (strncasecmp(path, "%2f", 3) == 0) {
        path += 3;
        while (*path == '/')    /* skip leading '/' (after root %2f) */
            ++path;
        ap_bputs("CWD /" CRLF, ctrl);
        ap_bflush(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: CWD /");

        /* possible results: 250, 421, 500, 501, 502, 530, 550 */
        /* 250 Requested file action okay, completed. */
        /* 421 Service not available, closing control connection. */
        /* 500 Syntax error, command unrecognized. */
        /* 501 Syntax error in parameters or arguments. */
        /* 502 Command not implemented. */
        /* 530 Not logged in. */
        /* 550 Requested action not taken. */
        i = ftp_getrc(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
        if (i == -1 || i == 421)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
        else if (i == 550)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_NOT_FOUND);
        else if (i != 250)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_BAD_GATEWAY);
d718 45
a762 2
    for (; (strp = strchr(path, '/')) != NULL; path = strp + 1) {
        char *slash = strp;
d764 1
a764 1
        *slash = '\0';
d766 27
a792 62
        /* Skip multiple '/' (or trailing '/') to avoid 500 errors */
        while (strp[1] == '/')
            ++strp;
        if (strp[1] == '\0')
            break;

        len = decodeenc(path);  /* Note! This decodes a %2f -> "/" */
        if (strchr(path, '/'))  /* were there any '/' characters? */
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_REQUEST,
                       "Use of %2F is only allowed at the base directory"));

        ap_bvputs(ctrl, "CWD ", path, CRLF, NULL);
        ap_bflush(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: CWD %s", path);
        *slash = '/';

/* responses: 250, 421, 500, 501, 502, 530, 550 */
        /* 250 Requested file action okay, completed. */
        /* 421 Service not available, closing control connection. */
        /* 500 Syntax error, command unrecognized. */
        /* 501 Syntax error in parameters or arguments. */
        /* 502 Command not implemented. */
        /* 530 Not logged in. */
        /* 550 Requested action not taken. */
        i = ftp_getrc(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
        if (i == -1 || i == 421)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
        if (i == 550)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_NOT_FOUND);
        if (i == 500 || i == 501)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_REQUEST,
                      "Syntax error in filename (reported by ftp server)"));
        if (i != 250)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_BAD_GATEWAY);
    }

    if (parms != NULL && strncmp(parms, "type=", 5) == 0
        && ap_isalpha(parms[5])) {
        /*
         * "type=d" forces a dir listing. The other types (i|a|e) are
         * directly used for the ftp TYPE command
         */
        if (!(get_dirlisting = (parms[5] == 'd')))
            xfer_type = ap_toupper(parms[5]);

        /* Check valid types, rather than ignoring invalid types silently: */
        if (strchr("AEI", xfer_type) == NULL)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                      ap_proxyerror(r, HTTP_BAD_REQUEST, ap_pstrcat(r->pool,
                       "ftp proxy supports only types 'a', 'i', or 'e': \"",
                                           parms, "\" is invalid.", NULL)));
    }
    else {
        /* make binary transfers the default */
        xfer_type = 'I';
d798 5
a802 3
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
                                      "proxy: error creating PASV socket"));
a804 1
#if !defined (TPF) && !defined(BEOS)
d806 5
a810 5
        if (setsockopt(dsock, SOL_SOCKET, SO_RCVBUF,
                (const char *)&conf->recv_buffer_size, sizeof(int)) == -1) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                          "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
        }
a811 1
#endif
d813 3
a815 3
    ap_bputs("PASV" CRLF, ctrl);
    ap_bflush(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PASV command issued");
d823 8
a830 6

    i = ap_bgets(pasv, sizeof(pasv), ctrl);
    if (i == -1 || i == 421) {
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
                               "proxy: PASV: control connection is toast"));
d833 87
a919 78
        pasv[i - 1] = '\0';
        pstr = strtok(pasv, " ");       /* separate result code */
        if (pstr != NULL) {
            presult = atoi(pstr);
            if (*(pstr + strlen(pstr) + 1) == '=')
                pstr += strlen(pstr) + 2;
            else {
                pstr = strtok(NULL, "(");       /* separate address & port
                                                 * params */
                if (pstr != NULL)
                    pstr = strtok(NULL, ")");
            }
        }
        else
            presult = atoi(pasv);

        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", presult);

        if (presult == 227 && pstr != NULL && (sscanf(pstr,
                 "%d,%d,%d,%d,%d,%d", &h3, &h2, &h1, &h0, &p1, &p0) == 6)) {
            /* pardon the parens, but it makes gcc happy */
            paddr = (((((h3 << 8) + h2) << 8) + h1) << 8) + h0;
            pport = (p1 << 8) + p0;
            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: contacting host %d.%d.%d.%d:%d",
                         h3, h2, h1, h0, pport);
            data_addr.sin_family = AF_INET;
            data_addr.sin_addr.s_addr = htonl(paddr);
            data_addr.sin_port = htons(pport);
            i = ap_proxy_doconnect(dsock, &data_addr, r);

            if (i == -1) {
                return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                                        ap_pstrcat(r->pool,
                                    "Could not connect to remote machine: ",
                                                   strerror(errno), NULL)));
            }
            pasvmode = 1;
        }
        else {
            ap_pclosesocket(p, dsock);  /* and try the regular way */
            dsock = -1;
        }
    }

    if (!pasvmode) {            /* set up data connection */
        clen = sizeof(struct sockaddr_in);
        if (getsockname(sock, (struct sockaddr *)&server, &clen) < 0) {
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
                                    "proxy: error getting socket address"));
        }

        dsock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);
        if (dsock == -1) {
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
                                           "proxy: error creating socket"));
        }

        if (setsockopt(dsock, SOL_SOCKET, SO_REUSEADDR, (void *)&one,
                       sizeof(one)) == -1) {
#ifndef _OSD_POSIX              /* BS2000 has this option "always on" */
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
                                  "proxy: error setting reuseaddr option"));
#endif                          /* _OSD_POSIX */
        }

        if (bind(dsock, (struct sockaddr *)&server,
                 sizeof(struct sockaddr_in)) == -1) {

            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
             ap_psprintf(p, "proxy: error binding to ftp data socket %s:%d",
                         inet_ntoa(server.sin_addr), server.sin_port)));
        }
        listen(dsock, 2);       /* only need a short queue */
a923 4
    if (strchr(path, '/'))      /* were there any '/' characters? */
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      ap_proxyerror(r, HTTP_BAD_REQUEST,
                       "Use of %2F is only allowed at the base directory"));
d928 1
a928 1
        get_dirlisting = 1;
d931 45
a975 43
        ap_bvputs(ctrl, "SIZE ", path, CRLF, NULL);
        ap_bflush(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: SIZE %s", path);
        i = ftp_getrc_msg(ctrl, resp, sizeof resp);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d with response %s", i, resp);
        if (i != 500) {         /* Size command not recognized */
            if (i == 550) {     /* Not a regular file */
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: SIZE shows this is a directory");
                get_dirlisting = 1;
                ap_bvputs(ctrl, "CWD ", path, CRLF, NULL);
                ap_bflush(ctrl);
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: CWD %s", path);

                /* possible results: 250, 421, 500, 501, 502, 530, 550 */
                /* 250 Requested file action okay, completed. */
                /* 421 Service not available, closing control connection. */
                /* 500 Syntax error, command unrecognized. */
                /* 501 Syntax error in parameters or arguments. */
                /* 502 Command not implemented. */
                /* 530 Not logged in. */
                /* 550 Requested action not taken. */
                i = ftp_getrc(ctrl);
                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
                if (i == -1 || i == 421)
                    return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
                if (i == 550)
                    return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                                  HTTP_NOT_FOUND);
                if (i != 250)
                    return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                                  HTTP_BAD_GATEWAY);
                path = "";
                len = 0;
            }
            else if (i == 213) {/* Size command ok */
                for (j = 0; j < sizeof resp && ap_isdigit(resp[j]); j++);
                resp[j] = '\0';
                if (resp[0] != '\0')
                    size = ap_pstrdup(p, resp);
            }
        }
d979 3
a981 3
    ap_bvputs(ctrl, "PWD", CRLF, NULL);
    ap_bflush(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PWD");
d989 10
a998 9
    i = ftp_getrc_msg(ctrl, resp, sizeof resp);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PWD returned status %d", i);
    if (i == -1 || i == 421)
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
    if (i == 550)
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      HTTP_NOT_FOUND);
d1000 2
a1001 2
        const char *dirp = resp;
        cwd = ap_getword_conf(r->pool, &dirp);
d1003 1
a1003 1
#endif                          /* AUTODETECT_PWD */
d1005 6
a1010 6
    if (get_dirlisting) {
        if (len != 0)
            ap_bvputs(ctrl, "LIST ", path, CRLF, NULL);
        else
            ap_bputs("LIST -lag" CRLF, ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: LIST %s", (len == 0 ? "" : path));
d1013 2
a1014 3
        ftp_set_TYPE(r, ctrl, xfer_type);
        ap_bvputs(ctrl, "RETR ", path, CRLF, NULL);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: RETR %s", path);
d1016 1
a1016 1
    ap_bflush(ctrl);
d1033 6
a1038 6
    rc = ftp_getrc(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
    if (rc == -1 || rc == 421)
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
d1040 27
a1066 28
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: RETR failed, trying LIST instead");
        get_dirlisting = 1;
        ftp_set_TYPE(r, ctrl, 'A');     /* directories must be transferred in
                                         * ASCII */

        ap_bvputs(ctrl, "CWD ", path, CRLF, NULL);
        ap_bflush(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: CWD %s", path);
        /* possible results: 250, 421, 500, 501, 502, 530, 550 */
        /* 250 Requested file action okay, completed. */
        /* 421 Service not available, closing control connection. */
        /* 500 Syntax error, command unrecognized. */
        /* 501 Syntax error in parameters or arguments. */
        /* 502 Command not implemented. */
        /* 530 Not logged in. */
        /* 550 Requested action not taken. */
        rc = ftp_getrc(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
        if (rc == -1 || rc == 421)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
        if (rc == 550)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_NOT_FOUND);
        if (rc != 250)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_BAD_GATEWAY);
d1069 3
a1071 3
        ap_bvputs(ctrl, "PWD", CRLF, NULL);
        ap_bflush(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PWD");
d1073 29
a1101 30
        /* 257 "<directory-name>" <commentary> */
        /* 421 Service not available, closing control connection. */
        /* 500 Syntax error, command unrecognized. */
        /* 501 Syntax error in parameters or arguments. */
        /* 502 Command not implemented. */
        /* 550 Requested action not taken. */
        i = ftp_getrc_msg(ctrl, resp, sizeof resp);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PWD returned status %d", i);
        if (i == -1 || i == 421)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
        if (i == 550)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_NOT_FOUND);
        if (i == 257) {
            const char *dirp = resp;
            cwd = ap_getword_conf(r->pool, &dirp);
        }
#endif                          /* AUTODETECT_PWD */

        ap_bputs("LIST -lag" CRLF, ctrl);
        ap_bflush(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: LIST -lag");
        rc = ftp_getrc(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
        if (rc == -1 || rc == 421)
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
                                       "Error reading from remote server"));
d1105 1
a1105 2
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                      HTTP_BAD_GATEWAY);
d1113 2
a1114 9
    ap_table_setn(resp_hdrs, "Date", ap_gm_timestr_822(r->pool, r->request_time));
    ap_table_setn(resp_hdrs, "Server", ap_get_server_version());

    if (get_dirlisting) {
        ap_table_setn(resp_hdrs, "Content-Type", "text/html");
#ifdef CHARSET_EBCDIC
        r->ebcdic.conv_out = 1; /* server-generated */
#endif
    }
d1116 12
a1127 20
#ifdef CHARSET_EBCDIC
        r->ebcdic.conv_out = 0; /* do not convert what we read from the ftp
                                 * server */
#endif
        if (r->content_type != NULL) {
            ap_table_setn(resp_hdrs, "Content-Type", r->content_type);
            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: Content-Type set to %s", r->content_type);
        }
        else {
            ap_table_setn(resp_hdrs, "Content-Type", ap_default_type(r));
        }
        if (xfer_type != 'A' && size != NULL) {
            /* We "trust" the ftp server to really serve (size) bytes... */
            ap_table_set(resp_hdrs, "Content-Length", size);
            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: Content-Length set to %s", size);
        }
    }
    if (r->content_encoding != NULL && r->content_encoding[0] != '\0') {
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: Content-Encoding set to %s", r->content_encoding);
        ap_table_setn(resp_hdrs, "Content-Encoding", r->content_encoding);
d1131 4
a1134 10
    if (nocache == 0) {
        for (i = 0; i < conf->nocaches->nelts; i++) {
            if (destaddr.s_addr == ncent[i].addr.s_addr ||
                (ncent[i].name != NULL &&
                 (ncent[i].name[0] == '*' ||
                  strstr(host, ncent[i].name) != NULL))) {
                nocache = 1;
                break;
            }
        }
d1140 25
a1164 20
        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock, i);
    }

    if (!pasvmode) {            /* wait for connection */
        ap_hard_timeout("proxy ftp data connect", r);
        clen = sizeof(struct sockaddr_in);
        do
            csd = accept(dsock, (struct sockaddr *)&server, &clen);
        while (csd == -1 && errno == EINTR);
        if (csd == -1) {
            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
                          "proxy: failed to accept data connection");
            if (c != NULL)
                c = ap_proxy_cache_error(c);
            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
                                          HTTP_BAD_GATEWAY);
        }
        data = ap_bcreate(p, B_RDWR | B_SOCKET);
        ap_bpushfd(data, csd, -1);
        ap_kill_timeout(r);
d1167 2
a1168 2
        data = ap_bcreate(p, B_RDWR | B_SOCKET);
        ap_bpushfd(data, dsock, dsock);
d1171 4
d1176 17
d1194 2
a1195 18
    /* send response */
    /* write status line and headers to the cache file */
    ap_proxy_write_headers(c, ap_pstrcat(p, "HTTP/1.1 ", r->status_line, NULL), resp_hdrs);

    /* Setup the headers for our client from upstreams response-headers */
    ap_overlap_tables(r->headers_out, resp_hdrs, AP_OVERLAP_TABLES_SET);
    /* Add X-Cache header */
    ap_table_setn(r->headers_out, "X-Cache",
                  ap_pstrcat(r->pool, "MISS from ",
                             ap_get_server_name(r), NULL));
    /* The Content-Type of this response is the upstream one. */
    r->content_type = ap_table_get(r->headers_out, "Content-Type");
    /* finally output the headers to the client */
    ap_send_http_header(r);

#ifdef CHARSET_EBCDIC
    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out);
#endif
d1198 1
a1198 1
        if (!get_dirlisting) {
d1200 12
a1211 17
            if (c != NULL)
                c->cache_completion = 0;
            ap_proxy_send_fb(data, r, c, -1, 0, 0, conf->io_buffer_size);
        }
        else {
            send_dir(data, r, c, cwd);
        }
        /* ap_proxy_send_fb() closes the socket */
        data = NULL;
        dsock = -1;

        /*
         * We checked for 125||150||226||250 above. See if another rc is
         * pending, and fetch it:
         */
        if (rc == 125 || rc == 150)
            rc = ftp_getrc(ctrl);
d1214 6
a1219 9
/* abort the transfer: we send the header only */
        ap_bputs("ABOR" CRLF, ctrl);
        ap_bflush(ctrl);
        if (data != NULL) {
            ap_bclose(data);
            data = NULL;
            dsock = -1;
        }
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: ABOR");
d1221 8
a1228 8
        /* 225 Data connection open; no transfer in progress. */
        /* 226 Closing data connection. */
        /* 421 Service not available, closing control connection. */
        /* 500 Syntax error, command unrecognized. */
        /* 501 Syntax error in parameters or arguments. */
        /* 502 Command not implemented. */
        i = ftp_getrc(ctrl);
        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
d1235 3
a1237 3
    ap_bputs("QUIT" CRLF, ctrl);
    ap_bflush(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: QUIT");
d1241 2
a1242 2
    i = ftp_getrc(ctrl);
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: QUIT: status %d", i);
d1244 3
a1246 1
    ap_bclose(ctrl);
d1248 1
a1248 1
    ap_rflush(r);               /* flush before garbage collection */
@


1.1.1.4
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
d668 1
a668 1
    sock = ap_psocket_ex(p, PF_INET, SOCK_STREAM, IPPROTO_TCP, 1);
d947 1
a947 1
    dsock = ap_psocket_ex(p, PF_INET, SOCK_STREAM, IPPROTO_TCP, 1);
d1035 1
a1035 1
        dsock = ap_psocket_ex(p, PF_INET, SOCK_STREAM, IPPROTO_TCP, 1);
@


1.1.1.5
log
@import Apache 1.3.29 and mod_ssl 2.8.16
@
text
@d550 1
a550 2
    char *desthost, *path, *strp, *parms;
    char *strp2;
d556 1
a556 1
    int destport, i, j, len, rc, nocache = 0;
a564 2
    char *destportstr = NULL;
    const char *urlptr = NULL;
d596 11
a606 28
    urlptr = strstr(url, "://");
    if (urlptr == NULL)
        return HTTP_BAD_REQUEST;
    urlptr += 3;
    destport = 21;
    strp = strchr(urlptr, '/');
    if (strp == NULL) {
        desthost = ap_pstrdup(p, urlptr);
        urlptr = "/";
    }
    else {
        char *q = ap_palloc(p, strp - urlptr + 1);
        memcpy(q, urlptr, strp - urlptr);
        q[strp - urlptr] = '\0';
        urlptr = strp;
        desthost = q;
    }

    strp2 = strchr(desthost, ':');
    if (strp2 != NULL) {
        *(strp2++) = '\0';
        if (ap_isdigit(*strp2)) {
            destport = atoi(strp2);
            destportstr = strp2;
        }
    }
    path = strchr(urlptr, '/')+1;
    
d646 1
a646 1
    destaddr.s_addr = ap_inet_addr(desthost);
d650 1
a650 1
          (npent[i].name[0] == '*' || strstr(desthost, npent[i].name) != NULL)))
d655 1
a655 1
    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: connect to %s:%d", desthost, destport);
d657 1
a657 1
    parms = strchr(url, ';');
d663 2
a664 2
    server.sin_port = htons((unsigned short)destport);
    err = ap_proxy_host2addr(desthost, &server_hp);
d1296 1
a1296 1
                  strstr(desthost, ncent[i].name) != NULL))) {
@


