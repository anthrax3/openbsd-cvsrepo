head	1.19;
access;
symbols
	OPENBSD_5_5:1.18.0.18
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.14
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.12
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.10
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.8
	OPENBSD_5_0:1.18.0.6
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.8
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.5
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.5
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.4
	apache_1_3_27:1.1.1.4
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	apache_1_3_26:1.1.1.3
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.1.2.0.2
	OPENBSD_2_4_BASE:1.1.1.2
	apache_1_3_2:1.1.1.2
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	apache:1.1.1
	apache_1_2_6:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.18;

1.18
date	2010.03.31.23.40.35;	author halex;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.26.04.49.50;	author fgsch;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2008.05.09.08.06.28;	author mbalmer;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.01.12.53.59;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.09.12.13.10;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.21.13.11.36;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.18.21.16.37;	author david;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.30.10.51.48;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.19.21.31.16;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.29.02.08.06;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.29.10.21.45;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.22.18.14;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.19.11.17.16;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.25.18.29.50;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.06.29.42;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.04.28.41;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.03.01.01.06.25;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.03.25.07.08.50;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.25.07.08.50;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.10.01.17.19.41;	author beck;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.07.19.21.28.54;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.07.19.48.13;	author henning;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.08.21.12.53.40;	author henning;	state Exp;
branches;
next	;

1.17.2.1
date	2010.05.14.15.19.11;	author stephan;	state Exp;
branches;
next	;


desc
@@


1.19
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

#include "mod_proxy.h"

#define CORE_PRIVATE

#include "http_log.h"
#include "http_main.h"
#include "http_vhost.h"
#include "http_request.h"

/* Some WWW schemes and their default ports; this is basically /etc/services */
/* This will become global when the protocol abstraction comes */
static struct proxy_services defports[] =
{
    {"http", DEFAULT_HTTP_PORT},
    {"ftp", DEFAULT_FTP_PORT},
    {"https", DEFAULT_HTTPS_PORT},
    {"gopher", DEFAULT_GOPHER_PORT},
    {"nntp", DEFAULT_NNTP_PORT},
    {"wais", DEFAULT_WAIS_PORT},
    {"snews", DEFAULT_SNEWS_PORT},
    {"prospero", DEFAULT_PROSPERO_PORT},
    {NULL, -1}                  /* unknown port */
};

/*
 * A Web proxy module. Stages:
 *
 *  translate_name: set filename to proxy:<URL>
 *  type_checker:   set type to PROXY_MAGIC_TYPE if filename begins proxy:
 *  fix_ups:        convert the URL stored in the filename to the
 *                  canonical form.
 *  handler:        handle proxy requests
 */

/* -------------------------------------------------------------- */
/* Translate the URL into a 'filename' */

static int alias_match(const char *uri, const char *alias_fakename)
{
    const char *end_fakename = alias_fakename + strlen(alias_fakename);
    const char *aliasp = alias_fakename, *urip = uri;

    while (aliasp < end_fakename) {
        if (*aliasp == '/') {
            /*
             * any number of '/' in the alias matches any number in the
             * supplied URI, but there must be at least one...
             */
            if (*urip != '/')
                return 0;

            while (*aliasp == '/')
                ++aliasp;
            while (*urip == '/')
                ++urip;
        }
        else {
            /* Other characters are compared literally */
            if (*urip++ != *aliasp++)
                return 0;
        }
    }

    /* Check last alias path component matched all the way */

    if (aliasp[-1] != '/' && *urip != '\0' && *urip != '/')
        return 0;

    /*
     * Return number of characters from URI which matched (may be greater
     * than length of alias, since we may have matched doubled slashes)
     */

    return urip - uri;
}

/* Detect if an absoluteURI should be proxied or not.  Note that we
 * have to do this during this phase because later phases are
 * "short-circuiting"... i.e. translate_names will end when the first
 * module returns OK.  So for example, if the request is something like:
 *
 * GET http://othervhost/cgi-bin/printenv HTTP/1.0
 *
 * mod_alias will notice the /cgi-bin part and ScriptAlias it and
 * short-circuit the proxy... just because of the ordering in the
 * configuration file.
 */
static int proxy_detect(request_rec *r)
{
    void *sconf = r->server->module_config;
    proxy_server_conf *conf;

    conf = (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);

    if (conf->req && r->parsed_uri.scheme) {
        /* but it might be something vhosted */
        if (!(r->parsed_uri.hostname
              && !strcasecmp(r->parsed_uri.scheme, ap_http_method(r))
              && ap_matches_request_vhost(r, r->parsed_uri.hostname,
        r->parsed_uri.port_str ? r->parsed_uri.port : ap_default_port(r)))) {
            r->proxyreq = STD_PROXY;
            r->uri = r->unparsed_uri;
            r->filename = ap_pstrcat(r->pool, "proxy:", r->uri, NULL);
            r->handler = "proxy-server";
        }
    }
    /* We need special treatment for CONNECT proxying: it has no scheme part */
    else if (conf->req && r->method_number == M_CONNECT
             && r->parsed_uri.hostname
             && r->parsed_uri.port_str) {
        r->proxyreq = STD_PROXY;
        r->uri = r->unparsed_uri;
        r->filename = ap_pstrcat(r->pool, "proxy:", r->uri, NULL);
        r->handler = "proxy-server";
    }
    return DECLINED;
}

static int proxy_trans(request_rec *r)
{
    void *sconf = r->server->module_config;
    proxy_server_conf *conf =
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
    int i, len;
    struct proxy_alias *ent = (struct proxy_alias *)conf->aliases->elts;

    if (r->proxyreq != NOT_PROXY) {
        /*
         * someone has already set up the proxy, it was possibly ourselves in
         * proxy_detect
         */
        return OK;
    }

    /*
     * XXX: since r->uri has been manipulated already we're not really
     * compliant with RFC1945 at this point.  But this probably isn't an
     * issue because this is a hybrid proxy/origin server.
     */

    for (i = 0; i < conf->aliases->nelts; i++) {
        len = alias_match(r->uri, ent[i].fake);

        if (len > 0) {
            if (ent[i].real[0] == '!' && ent[i].real[1] == '\0')
                return DECLINED;

            r->filename = ap_pstrcat(r->pool, "proxy:", ent[i].real,
                                     r->uri + len, NULL);
            r->handler = "proxy-server";
            r->proxyreq = PROXY_PASS;
            return OK;
        }
    }
    return DECLINED;
}

/* -------------------------------------------------------------- */
/* Fixup the filename */

/*
 * Canonicalise the URL
 */
static int proxy_fixup(request_rec *r)
{
    char *url, *p;
    int rc;

    if (r->proxyreq == NOT_PROXY || strncmp(r->filename, "proxy:", 6) != 0)
        return DECLINED;

    url = &r->filename[6];

/* canonicalise each specific scheme */
    if (ap_hook_use("ap::mod_proxy::canon",
                    AP_HOOK_SIG3(int,ptr,ptr),
                    AP_HOOK_DECLINE(DECLINED),
                    &rc, r, url) && rc != DECLINED)
        return rc;  
    else
    if (strncasecmp(url, "http:", 5) == 0)
        return ap_proxy_http_canon(r, url + 5, "http", DEFAULT_HTTP_PORT);
    else if (strncasecmp(url, "ftp:", 4) == 0)
        return ap_proxy_ftp_canon(r, url + 4);

    p = strchr(url, ':');
    if (p == NULL || p == url)
        return HTTP_BAD_REQUEST;

    return OK;                  /* otherwise; we've done the best we can */
}

static void proxy_init(server_rec *r, pool *p)
{
    ap_proxy_garbage_init(r, p);
    ap_hook_use("ap::mod_proxy::init", 
                AP_HOOK_SIG3(void,ptr,ptr), AP_HOOK_ALL, r, p);
}

static void proxy_addmod(module *m)
{
    /* export: ap_proxy_http_canon() as `ap::mod_proxy::http::canon' */
    ap_hook_configure("ap::mod_proxy::http::canon", 
                      AP_HOOK_SIG5(int,ptr,ptr,ptr,int), AP_HOOK_TOPMOST);
    ap_hook_register("ap::mod_proxy::http::canon", 
                     ap_proxy_http_canon, AP_HOOK_NOCTX);

    /* export: ap_proxy_http_handler() as `ap::mod_proxy::http::handler' */
    ap_hook_configure("ap::mod_proxy::http::handler", 
                      AP_HOOK_SIG6(int,ptr,ptr,ptr,ptr,int), AP_HOOK_TOPMOST);
    ap_hook_register("ap::mod_proxy::http::handler", 
                     ap_proxy_http_handler, AP_HOOK_NOCTX);

    /* export: ap_proxyerror() as `ap::mod_proxy::error' */
    ap_hook_configure("ap::mod_proxy::error", 
                      AP_HOOK_SIG3(int,ptr,ptr), AP_HOOK_TOPMOST);
    ap_hook_register("ap::mod_proxy::error", 
                     ap_proxyerror, AP_HOOK_NOCTX);
    return;
}

static void proxy_remmod(module *m)
{
	/* remove the hook references */
    ap_hook_unregister("ap::mod_proxy::http::canon", ap_proxy_http_canon);
    ap_hook_unregister("ap::mod_proxy::http::handler", ap_proxy_http_handler);
    ap_hook_unregister("ap::mod_proxy::error", ap_proxyerror);
    return;
}

/* Send a redirection if the request contains a hostname which is not */
/* fully qualified, i.e. doesn't have a domain name appended. Some proxy */
/* servers like Netscape's allow this and access hosts from the local */
/* domain in this case. I think it is better to redirect to a FQDN, since */
/* these will later be found in the bookmarks files. */
/* The "ProxyDomain" directive determines what domain will be appended */
static int proxy_needsdomain(request_rec *r, const char *url, const char *domain)
{
    char *nuri;
    const char *ref;

    /* We only want to worry about GETs */
    if (r->proxyreq == NOT_PROXY || r->method_number != M_GET || !r->parsed_uri.hostname)
        return DECLINED;

    /* If host does contain a dot already, or it is "localhost", decline */
    if (strchr(r->parsed_uri.hostname, '.') != NULL
        || strcasecmp(r->parsed_uri.hostname, "localhost") == 0)
        return DECLINED;        /* host name has a dot already */

    ref = ap_table_get(r->headers_in, "Referer");

    /* Reassemble the request, but insert the domain after the host name */
    /* Note that the domain name always starts with a dot */
    r->parsed_uri.hostname = ap_pstrcat(r->pool, r->parsed_uri.hostname,
                                        domain, NULL);
    nuri = ap_unparse_uri_components(r->pool,
                                     &r->parsed_uri,
                                     UNP_REVEALPASSWORD);

    ap_table_set(r->headers_out, "Location", nuri);
    ap_log_rerror(APLOG_MARK, APLOG_INFO | APLOG_NOERRNO, r,
                  "Domain missing: %s sent to %s%s%s", r->uri,
                  ap_unparse_uri_components(r->pool, &r->parsed_uri,
                                            UNP_OMITUSERINFO),
                  ref ? " from " : "", ref ? ref : "");

    return HTTP_MOVED_PERMANENTLY;
}

/* -------------------------------------------------------------- */
/* Invoke handler */

static int proxy_handler(request_rec *r)
{
    char *url, *scheme, *p;
    void *sconf = r->server->module_config;
    proxy_server_conf *conf =
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
    array_header *proxies = conf->proxies;
    struct proxy_remote *ents = (struct proxy_remote *) proxies->elts;
    int i, rc;
    cache_req *cr;
    int direct_connect = 0;
    const char *maxfwd_str;

    if (r->proxyreq == NOT_PROXY || strncmp(r->filename, "proxy:", 6) != 0)
        return DECLINED;

    if (r->method_number == M_TRACE &&
        (maxfwd_str = ap_table_get(r->headers_in, "Max-Forwards")) != NULL) {
        long maxfwd = ap_strtol(maxfwd_str, NULL, 10);
        if (maxfwd < 1) {
            int access_status;
            r->proxyreq = NOT_PROXY;
            if ((access_status = ap_send_http_trace(r)))
                ap_die(access_status, r);
            else
                ap_finalize_request_protocol(r);
            return OK;
        }
        ap_table_setn(r->headers_in, "Max-Forwards",
                ap_psprintf(r->pool, "%ld", (maxfwd > 0) ? maxfwd - 1 : 0));
    }

    if ((rc = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR)))
        return rc;

    url = r->filename + 6;
    p = strchr(url, ':');
    if (p == NULL)
        return HTTP_BAD_REQUEST;

    /* Try serve the request from the cache. If we succeed, we leave. */
    rc = ap_proxy_cache_check(r, url, &conf->cache, &cr);
    if (rc != DECLINED)
        return rc;

    /* If the host doesn't have a domain name, add one and redirect. */
    if (conf->domain != NULL) {
        rc = proxy_needsdomain(r, url, conf->domain);
        if (ap_is_HTTP_REDIRECT(rc))
            return HTTP_MOVED_PERMANENTLY;
    }

    *p = '\0';
    scheme = ap_pstrdup(r->pool, url);
    *p = ':';

    /* Check URI's destination host against NoProxy hosts */
    /* Bypass ProxyRemote server lookup if configured as NoProxy */
    /* we only know how to handle communication to a proxy via http */
    /* if (strcasecmp(scheme, "http") == 0) */
    {
        int ii;
        struct dirconn_entry *list = (struct dirconn_entry *)conf->dirconn->elts;

        for (direct_connect = ii = 0; ii < conf->dirconn->nelts && !direct_connect; ii++) {
            direct_connect = list[ii].matcher(&list[ii], r);
        }
#if DEBUGGING
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r,
                    (direct_connect) ? "NoProxy for %s" : "UseProxy for %s",
                      r->uri);
#endif
    }

/* firstly, try a proxy, unless a NoProxy directive is active */

    if (!direct_connect)
        for (i = 0; i < proxies->nelts; i++) {
            p = strchr(ents[i].scheme, ':');    /* is it a partial URL? */
            if (strcmp(ents[i].scheme, "*") == 0 ||
                (p == NULL && strcasecmp(scheme, ents[i].scheme) == 0) ||
                (p != NULL &&
            strncasecmp(url, ents[i].scheme, strlen(ents[i].scheme)) == 0)) {
                /*
                 * CONNECT is a special method that bypasses the normal proxy
                 * code.
                 */
		if (!ap_hook_use("ap::mod_proxy::handler",
				 AP_HOOK_SIG7(int,ptr,ptr,ptr,ptr,int,ptr),
				 AP_HOOK_DECLINE(DECLINED),
				 &rc, r, cr, url, 
				 ents[i].hostname, ents[i].port, 
				 ents[i].protocol) || rc == DECLINED) {
                if (r->method_number == M_CONNECT)
                    rc = ap_proxy_connect_handler(r, cr, url, ents[i].hostname,
                                                  ents[i].port);
/* we only know how to handle communication to a proxy via http */
                else if (strcasecmp(ents[i].protocol, "http") == 0)
                    rc = ap_proxy_http_handler(r, cr, url, ents[i].hostname,
                                               ents[i].port);
                else
                    rc = DECLINED;
		}

                /* an error or success */
                if (rc != DECLINED && rc != HTTP_BAD_GATEWAY)
                    return rc;
                /* we failed to talk to the upstream proxy */
            }
        }

    /* otherwise, try it direct */
    /* N.B. what if we're behind a firewall, where we must use a proxy or
     * give up??
     */

    /* handle the scheme */
    if (ap_hook_use("ap::mod_proxy::handler",
		    AP_HOOK_SIG7(int,ptr,ptr,ptr,ptr,int,ptr),
		    AP_HOOK_DECLINE(DECLINED),
		    &rc, r, cr, url, 
                    NULL, 0, scheme) && rc != DECLINED)
        return rc;
    if (r->method_number == M_CONNECT) {
        return ap_proxy_connect_handler(r, cr, url, NULL, 0);
    }
    if (strcasecmp(scheme, "http") == 0) {
        return ap_proxy_http_handler(r, cr, url, NULL, 0);
    }
    if (strcasecmp(scheme, "ftp") == 0) {
        return ap_proxy_ftp_handler(r, cr, url);
    }
    else {
        ap_log_rerror(APLOG_MARK, APLOG_WARNING | APLOG_NOERRNO, r,
                    "proxy: No protocol handler was valid for the URL %s. "
                    "If you are using a DSO version of mod_proxy, make sure "
                    "the proxy submodules are included in the configuration "
                    "using LoadModule.", r->uri);
        return HTTP_FORBIDDEN;
    }
}

/* -------------------------------------------------------------- */
/* Setup configurable data */

static void *
     create_proxy_config(pool *p, server_rec *s)
{
    proxy_server_conf *ps = ap_pcalloc(p, sizeof(proxy_server_conf));

    ps->proxies = ap_make_array(p, 10, sizeof(struct proxy_remote));
    ps->aliases = ap_make_array(p, 10, sizeof(struct proxy_alias));
    ps->raliases = ap_make_array(p, 10, sizeof(struct proxy_alias));
    ps->noproxies = ap_make_array(p, 10, sizeof(struct noproxy_entry));
    ps->dirconn = ap_make_array(p, 10, sizeof(struct dirconn_entry));
    ps->nocaches = ap_make_array(p, 10, sizeof(struct nocache_entry));
    ps->allowed_connect_ports = ap_make_array(p, 10, sizeof(int));
    ps->domain = NULL;
    ps->viaopt = via_off;       /* initially backward compatible with 1.3.1 */
    ps->viaopt_set = 0;         /* 0 means default */
    ps->req = 0;
    ps->req_set = 0;
    ps->recv_buffer_size = 0;   /* this default was left unset for some
                                 * reason */
    ps->recv_buffer_size_set = 0;
    ps->io_buffer_size = IOBUFSIZE;
    ps->io_buffer_size_set = 0;
    ps->preserve_host = 0;
    ps->preserve_host_set = 0;

    ps->cache.root = NULL;
    ps->cache.space = DEFAULT_CACHE_SPACE;
    ps->cache.space_set = 0;
    ps->cache.maxexpire = DEFAULT_CACHE_MAXEXPIRE;
    ps->cache.maxexpire_set = 0;
    ps->cache.defaultexpire = DEFAULT_CACHE_EXPIRE;
    ps->cache.defaultexpire_set = 0;
    ps->cache.lmfactor = DEFAULT_CACHE_LMFACTOR;
    ps->cache.lmfactor_set = 0;
    ps->cache.gcinterval = DEFAULT_CACHE_GCINTERVAL;
    ps->cache.gcinterval_set = 1;
    /* at these levels, the cache can have 2^18 directories (256,000)  */
    ps->cache.dirlevels = 3;
    ps->cache.dirlevels_set = 0;
    ps->cache.dirlength = 1;
    ps->cache.dirlength_set = 0;
    ps->cache.cache_completion = (float)DEFAULT_CACHE_COMPLETION;
    ps->cache.cache_completion_set = 0;

    return ps;
}

static void *
     merge_proxy_config(pool *p, void *basev,
                             void *overridesv)
{
    proxy_server_conf *ps = ap_pcalloc(p, sizeof(proxy_server_conf));
    proxy_server_conf *base = (proxy_server_conf *)basev;
    proxy_server_conf *overrides = (proxy_server_conf *)overridesv;

    ps->proxies = ap_append_arrays(p, base->proxies, overrides->proxies);
    ps->aliases = ap_append_arrays(p, base->aliases, overrides->aliases);
    ps->raliases = ap_append_arrays(p, base->raliases, overrides->raliases);
    ps->noproxies = ap_append_arrays(p, base->noproxies, overrides->noproxies);
    ps->dirconn = ap_append_arrays(p, base->dirconn, overrides->dirconn);
    ps->nocaches = ap_append_arrays(p, base->nocaches, overrides->nocaches);
    ps->allowed_connect_ports = ap_append_arrays(p, base->allowed_connect_ports, overrides->allowed_connect_ports);

    ps->domain = (overrides->domain == NULL) ? base->domain : overrides->domain;
    ps->viaopt = (overrides->viaopt_set == 0) ? base->viaopt : overrides->viaopt;
    ps->req = (overrides->req_set == 0) ? base->req : overrides->req;
    ps->recv_buffer_size = (overrides->recv_buffer_size_set == 0) ? base->recv_buffer_size : overrides->recv_buffer_size;
    ps->io_buffer_size = (overrides->io_buffer_size_set == 0) ? base->io_buffer_size : overrides->io_buffer_size;

    ps->preserve_host = (overrides->preserve_host_set == 0) ? base->preserve_host : overrides->preserve_host;

    ps->cache.root = (overrides->cache.root == NULL) ? base->cache.root : overrides->cache.root;
    ps->cache.space = (overrides->cache.space_set == 0) ? base->cache.space : overrides->cache.space;
    ps->cache.maxexpire = (overrides->cache.maxexpire_set == 0) ? base->cache.maxexpire : overrides->cache.maxexpire;
    ps->cache.defaultexpire = (overrides->cache.defaultexpire_set == 0) ? base->cache.defaultexpire : overrides->cache.defaultexpire;
    ps->cache.lmfactor = (overrides->cache.lmfactor_set == 0) ? base->cache.lmfactor : overrides->cache.lmfactor;
    ps->cache.gcinterval = (overrides->cache.gcinterval_set == 0) ? base->cache.gcinterval : overrides->cache.gcinterval;
    /* at these levels, the cache can have 2^18 directories (256,000)  */
    ps->cache.dirlevels = (overrides->cache.dirlevels_set == 0) ? base->cache.dirlevels : overrides->cache.dirlevels;
    ps->cache.dirlength = (overrides->cache.dirlength_set == 0) ? base->cache.dirlength : overrides->cache.dirlength;
    ps->cache.cache_completion = (overrides->cache.cache_completion_set == 0) ? base->cache.cache_completion : overrides->cache.cache_completion;

    return ps;
}

static const char *
     add_proxy(cmd_parms *cmd, void *dummy, char *f, char *r)
{
    server_rec *s = cmd->server;
    proxy_server_conf *conf =
    (proxy_server_conf *)ap_get_module_config(s->module_config, &proxy_module);
    struct proxy_remote *new;
    char *p, *q;
    int port;
    char *bl = NULL, *br = NULL;

    p = strchr(r, ':');
    if (p == NULL || p[1] != '/' || p[2] != '/' || p[3] == '\0')
	return "ProxyRemote: Bad syntax for a remote proxy server";
    bl = p + 3;
    if (*bl == '['){
	br = strrchr(bl+1, ']');
	if (br){
	    bl++;
	    *br = '\0';
	    if (*(br+1) == ':'){	/* [host]:xx */
		q = br+1;
	    }
	    else if (*(br+1) == '\0'){	/* [host] */
		q = NULL;
	    }
	    else
		q = strrchr(br, ':');	/* XXX */
	}
	else
	    q = strrchr(bl, ':');	/* XXX */
    }
    else
	q = strrchr(bl, ':');
    if (q != NULL) {
        if (sscanf(q + 1, "%u", &port) != 1 || port > 65535)
            return "ProxyRemote: Bad syntax for a remote proxy server (bad port number)";
        *q = '\0';
    }
    else
        port = -1;
    *p = '\0';
    if (strchr(f, ':') == NULL)
        ap_str_tolower(f);      /* lowercase scheme */
    ap_str_tolower(bl);         /* lowercase hostname */

    if (port == -1) {
        int i;
        for (i = 0; defports[i].scheme != NULL; i++)
            if (strcasecmp(defports[i].scheme, r) == 0)
                break;
        port = defports[i].port;
    }

    new = ap_push_array(conf->proxies);
    new->scheme = f;
    new->protocol = r;
    new->hostname = bl;
    new->port = port;
    return NULL;
}

static const char *
     add_pass(cmd_parms *cmd, void *dummy, char *f, char *r)
{
    server_rec *s = cmd->server;
    proxy_server_conf *conf =
    (proxy_server_conf *)ap_get_module_config(s->module_config, &proxy_module);
    struct proxy_alias *new;

    new = ap_push_array(conf->aliases);
    new->fake = f;
    new->real = r;
    return NULL;
}

static const char *
     add_pass_reverse(cmd_parms *cmd, void *dummy, char *f, char *r)
{
    server_rec *s = cmd->server;
    proxy_server_conf *conf;
    struct proxy_alias *new;

    conf = (proxy_server_conf *)ap_get_module_config(s->module_config,
                                                     &proxy_module);
    new = ap_push_array(conf->raliases);
    new->fake = f;
    new->real = r;
    return NULL;
}

static const char *
     set_proxy_exclude(cmd_parms *parms, void *dummy, char *arg)
{
    server_rec *s = parms->server;
    proxy_server_conf *conf =
    ap_get_module_config(s->module_config, &proxy_module);
    struct noproxy_entry *new;
    struct noproxy_entry *list = (struct noproxy_entry *) conf->noproxies->elts;
    struct hostent hp;
    int found = 0;
    int i;

    /* Don't duplicate entries */
    for (i = 0; i < conf->noproxies->nelts; i++) {
        if (strcasecmp(arg, list[i].name) == 0) /* ignore case for host names */
            found = 1;
    }

    if (!found) {
        new = ap_push_array(conf->noproxies);
        new->name = arg;
        /* Don't do name lookups on things that aren't dotted */
        if (strchr(arg, '.') != NULL && ap_proxy_host2addr(new->name, &hp) == NULL)
            /*
             * @@@@@@FIXME: This copies only the first of (possibly many) IP
             * addrs
             */
            memcpy(&new->addr, hp.h_addr, sizeof(struct in_addr));
        else
            new->addr.s_addr = 0;
    }
    return NULL;
}

/*
 * Set the ports CONNECT can use
 */
static const char *
     set_allowed_ports(cmd_parms *parms, void *dummy, char *arg)
{
    server_rec *s = parms->server;
    proxy_server_conf *conf =
    ap_get_module_config(s->module_config, &proxy_module);
    int *New;

    if (!ap_isdigit(arg[0]))
        return "AllowCONNECT: port number must be numeric";

    New = ap_push_array(conf->allowed_connect_ports);
    *New = atoi(arg);
    return NULL;
}

/* Similar to set_proxy_exclude(), but defining directly connected hosts,
 * which should never be accessed via the configured ProxyRemote servers
 */
static const char *
     set_proxy_dirconn(cmd_parms *parms, void *dummy, char *arg)
{
    server_rec *s = parms->server;
    proxy_server_conf *conf =
    ap_get_module_config(s->module_config, &proxy_module);
    struct dirconn_entry *New;
    struct dirconn_entry *list = (struct dirconn_entry *)conf->dirconn->elts;
    int found = 0;
    int i;

    /* Don't duplicate entries */
    for (i = 0; i < conf->dirconn->nelts; i++) {
        if (strcasecmp(arg, list[i].name) == 0)
            found = 1;
    }

    if (!found) {
        New = ap_push_array(conf->dirconn);
        New->name = arg;
        New->hostentry = NULL;

        if (ap_proxy_is_ipaddr(New, parms->pool)) {
#if DEBUGGING
            fprintf(stderr, "Parsed addr %s\n", inet_ntoa(New->addr));
            fprintf(stderr, "Parsed mask %s\n", inet_ntoa(New->mask));
#endif
        }
        else if (ap_proxy_is_domainname(New, parms->pool)) {
            ap_str_tolower(New->name);
#if DEBUGGING
            fprintf(stderr, "Parsed domain %s\n", New->name);
#endif
        }
        else if (ap_proxy_is_hostname(New, parms->pool)) {
            ap_str_tolower(New->name);
#if DEBUGGING
            fprintf(stderr, "Parsed host %s\n", New->name);
#endif
        }
        else {
            ap_proxy_is_word(New, parms->pool);
#if DEBUGGING
            fprintf(stderr, "Parsed word %s\n", New->name);
#endif
        }
    }
    return NULL;
}

static const char *
     set_proxy_domain(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);

    if (arg[0] != '.')
        return "ProxyDomain: domain name must start with a dot.";

    psf->domain = arg;
    return NULL;
}

static const char *
     set_proxy_req(cmd_parms *parms, void *dummy, int flag)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);

    psf->req = flag;
    psf->req_set = 1;
    return NULL;
}


static const char *
     set_cache_size(cmd_parms *parms, char *struct_ptr, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    int val;

    if (sscanf(arg, "%d", &val) != 1)
        return "CacheSize value must be an integer (kBytes)";
    psf->cache.space = val;
    psf->cache.space_set = 1;
    return NULL;
}

static const char *
     set_cache_root(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);

    psf->cache.root = arg;
    ap_server_strip_chroot(psf->cache.root, 1);

    return NULL;
}

static const char *
     set_cache_factor(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    double val;

    if (sscanf(arg, "%lg", &val) != 1)
        return "CacheLastModifiedFactor value must be a float";
    psf->cache.lmfactor = val;
    psf->cache.lmfactor_set = 1;

    return NULL;
}

static const char *
     set_cache_maxex(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    double val;

    if (sscanf(arg, "%lg", &val) != 1)
        return "CacheMaxExpire value must be a float";
    psf->cache.maxexpire = (int)(val * (double)SEC_ONE_HR);
    psf->cache.maxexpire_set = 1;
    return NULL;
}

static const char *
     set_cache_defex(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    double val;

    if (sscanf(arg, "%lg", &val) != 1)
        return "CacheDefaultExpire value must be a float";
    psf->cache.defaultexpire = (int)(val * (double)SEC_ONE_HR);
    psf->cache.defaultexpire_set = 1;
    return NULL;
}

static const char *
     set_cache_gcint(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    double val;

    if (sscanf(arg, "%lg", &val) != 1)
        return "CacheGcInterval value must be a float";
    psf->cache.gcinterval = (int)(val * (double)SEC_ONE_HR);
    psf->cache.gcinterval_set = 1;
    return NULL;
}

static const char *
     set_cache_dirlevels(cmd_parms *parms, char *struct_ptr, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    int val;

    val = atoi(arg);
    if (val < 1)
        return "CacheDirLevels value must be an integer greater than 0";
    if (val * psf->cache.dirlength > CACHEFILE_LEN)
        return "CacheDirLevels*CacheDirLength value must not be higher than 20";
    psf->cache.dirlevels = val;
    psf->cache.dirlevels_set = 1;
    return NULL;
}

static const char *
     set_cache_dirlength(cmd_parms *parms, char *struct_ptr, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    int val;

    val = atoi(arg);
    if (val < 1)
        return "CacheDirLength value must be an integer greater than 0";
    if (val * psf->cache.dirlevels > CACHEFILE_LEN)
        return "CacheDirLevels*CacheDirLength value must not be higher than 20";
    psf->cache.dirlength = val;
    psf->cache.dirlength_set = 1;
    return NULL;
}

static const char *
     set_cache_exclude(cmd_parms *parms, void *dummy, char *arg)
{
    server_rec *s = parms->server;
    proxy_server_conf *conf =
    ap_get_module_config(s->module_config, &proxy_module);
    struct nocache_entry *new;
    struct nocache_entry *list = (struct nocache_entry *) conf->nocaches->elts;
    struct hostent hp;
    int found = 0;
    int i;

    /* Don't duplicate entries */
    for (i = 0; i < conf->nocaches->nelts; i++) {
        if (strcasecmp(arg, list[i].name) == 0) /* ignore case for host names */
            found = 1;
    }

    if (!found) {
        new = ap_push_array(conf->nocaches);
        new->name = arg;
        /* Don't do name lookups on things that aren't dotted */
        if (strchr(arg, '.') != NULL && ap_proxy_host2addr(new->name, &hp) == NULL)
            /*
             * @@@@@@FIXME: This copies only the first of (possibly many) IP
             * addrs
             */
            memcpy(&new->addr, hp.h_addr, sizeof(struct in_addr));
        else
            new->addr.s_addr = 0;
    }
    return NULL;
}

static const char *
     set_recv_buffer_size(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    int s = atoi(arg);
    if (s < 512 && s != 0) {
        return "ProxyReceiveBufferSize must be >= 512 bytes, or 0 for system default.";
    }

    psf->recv_buffer_size = s;
    psf->recv_buffer_size_set = 1;
    return NULL;
}

static const char *
     set_io_buffer_size(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    long s = atol(arg);

    psf->io_buffer_size = ((s > IOBUFSIZE) ? s : IOBUFSIZE);
    psf->io_buffer_size_set = 1;
    return NULL;
}

static const char *
     set_cache_completion(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    int s = atoi(arg);
    if (s > 100 || s < 0) {
        return "CacheForceCompletion must be <= 100 percent, "
            "or 0 for system default.";
    }

    if (s > 0)
        psf->cache.cache_completion = ((float)s / 100);

    psf->cache.cache_completion_set = 1;
    return NULL;
}

static const char *
     set_via_opt(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);

    if (strcasecmp(arg, "Off") == 0)
        psf->viaopt = via_off;
    else if (strcasecmp(arg, "On") == 0)
        psf->viaopt = via_on;
    else if (strcasecmp(arg, "Block") == 0)
        psf->viaopt = via_block;
    else if (strcasecmp(arg, "Full") == 0)
        psf->viaopt = via_full;
    else {
        return "ProxyVia must be one of: "
            "off | on | full | block";
    }

    psf->viaopt_set = 1;
    return NULL;
}

static const char *
    set_preserve_host(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);

    if (strcasecmp(arg, "Off") == 0)
        psf->preserve_host = 0;
    else if (strcasecmp(arg, "On") == 0)
        psf->preserve_host = 1;
    else {
        return "ProxyPreserveHost must be one of: "
            "off | on";
    }

    psf->preserve_host_set = 1;
    return NULL;
}

static const handler_rec proxy_handlers[] =
{
    {"proxy-server", proxy_handler},
    {NULL}
};

static const command_rec proxy_cmds[] =
{
    {"ProxyRequests", set_proxy_req, NULL, RSRC_CONF, FLAG,
    "on if the true proxy requests should be accepted"},
    {"ProxyRemote", add_proxy, NULL, RSRC_CONF, TAKE2,
    "a scheme, partial URL or '*' and a proxy server"},
    {"ProxyPass", add_pass, NULL, RSRC_CONF, TAKE2,
    "a virtual path and a URL"},
    {"ProxyPassReverse", add_pass_reverse, NULL, RSRC_CONF, TAKE2,
    "a virtual path and a URL for reverse proxy behaviour"},
    {"ProxyBlock", set_proxy_exclude, NULL, RSRC_CONF, ITERATE,
    "A list of names, hosts or domains to which the proxy will not connect"},
    {"ProxyReceiveBufferSize", set_recv_buffer_size, NULL, RSRC_CONF, TAKE1,
    "Receive buffer size for outgoing HTTP and FTP connections in bytes"},
    {"ProxyIOBufferSize", set_io_buffer_size, NULL, RSRC_CONF, TAKE1,
    "IO buffer size for outgoing HTTP and FTP connections in bytes"},
    {"NoProxy", set_proxy_dirconn, NULL, RSRC_CONF, ITERATE,
    "A list of domains, hosts, or subnets to which the proxy will connect directly"},
    {"ProxyDomain", set_proxy_domain, NULL, RSRC_CONF, TAKE1,
    "The default intranet domain name (in absence of a domain in the URL)"},
    {"AllowCONNECT", set_allowed_ports, NULL, RSRC_CONF, ITERATE,
    "A list of ports which CONNECT may connect to"},
    {"ProxyPreserveHost", set_preserve_host, NULL, RSRC_CONF, TAKE1,
    "on if the host header should be preserved while proxying"},
    {"CacheRoot", set_cache_root, NULL, RSRC_CONF, TAKE1,
    "The directory to store cache files"},
    {"CacheSize", set_cache_size, NULL, RSRC_CONF, TAKE1,
    "The maximum disk space used by the cache in Kb"},
    {"CacheMaxExpire", set_cache_maxex, NULL, RSRC_CONF, TAKE1,
    "The maximum time in hours to cache a document"},
    {"CacheDefaultExpire", set_cache_defex, NULL, RSRC_CONF, TAKE1,
    "The default time in hours to cache a document"},
    {"CacheLastModifiedFactor", set_cache_factor, NULL, RSRC_CONF, TAKE1,
    "The factor used to estimate Expires date from LastModified date"},
    {"CacheGcInterval", set_cache_gcint, NULL, RSRC_CONF, TAKE1,
    "The interval between garbage collections, in hours"},
    {"CacheDirLevels", set_cache_dirlevels, NULL, RSRC_CONF, TAKE1,
    "The number of levels of subdirectories in the cache"},
    {"CacheDirLength", set_cache_dirlength, NULL, RSRC_CONF, TAKE1,
    "The number of characters in subdirectory names"},
    {"NoCache", set_cache_exclude, NULL, RSRC_CONF, ITERATE,
    "A list of names, hosts or domains for which caching is *not* provided"},
    {"CacheForceCompletion", set_cache_completion, NULL, RSRC_CONF, TAKE1,
    "Force a http cache completion after this percentage is loaded"},
    {"ProxyVia", set_via_opt, NULL, RSRC_CONF, TAKE1,
    "Configure Via: proxy header header to one of: on | off | block | full"},
    {NULL}
};

module MODULE_VAR_EXPORT proxy_module =
{
    STANDARD_MODULE_STUFF,
    proxy_init,                 /* initializer */
    NULL,                       /* create per-directory config structure */
    NULL,                       /* merge per-directory config structures */
    create_proxy_config,        /* create per-server config structure */
    merge_proxy_config,         /* merge per-server config structures */
    proxy_cmds,                 /* command table */
    proxy_handlers,             /* handlers */
    proxy_trans,                /* translate_handler */
    NULL,                       /* check_user_id */
    NULL,                       /* check auth */
    NULL,                       /* check access */
    NULL,                       /* type_checker */
    proxy_fixup,                /* pre-run fixups */
    NULL,                       /* logger */
    NULL,                       /* header parser */
    NULL,                       /* child_init */
    NULL,                       /* child_exit */
    proxy_detect                /* post read-request */
   ,proxy_addmod,		/* EAPI: add_module */
    proxy_remmod,		/* EAPI: remove_module */
    NULL,			/* EAPI: rewrite_command */
    NULL			/* EAPI: new_connection  */
};
@


1.18
log
@make ProxyPass exclude directives only exclude on match, instead of always
noted by Vasiliy Kiryanov, thanks!

ok stephan@@
@
text
@@


1.17
log
@Add ! support to ProxyPass to exclude directories from being proxied.
From Stephan A. Rickauer <stephan dot rickauer at startek dot ch> with
minor tweaks.  ok by many.
@
text
@d202 3
a204 2
        if (ent[i].real[0] == '!' && ent[i].real[1] == '\0')
            return DECLINED;
a205 1
        if (len > 0) {
@


1.17.2.1
log
@MFC, original commit from halex@@:
--------------------------------------------------------------------------
make ProxyPass exclude directives only exclude on match, instead of always
noted by Vasiliy Kiryanov, thanks!

ok stephan@@
--------------------------------------------------------------------------

unbreak for -stable, too. ok halex@@ and sthen@@
@
text
@d202 3
a205 3
            if (ent[i].real[0] == '!' && ent[i].real[1] == '\0')
                return DECLINED;

@


1.16
log
@Add support for IPv6 while keeping the default at IPv4 to not break
existing installations.  See the documentation for the IPv6 related
configuration.

This changes the module ABI since addresses are now struct addrinfo.

This has been tested by many people and run on production machines
for several months.

feedback many, ok todd
@
text
@d202 3
@


1.15
log
@add ProxyPreserveHost support to mod_proxy. it allows to pass the original
Host header to the backend. default off. henning@@ ok.
@
text
@d568 1
d572 21
a592 2
        return "ProxyRemote: Bad syntax for a remote proxy server";
    q = strchr(p + 3, ':');
d603 1
a603 1
    ap_str_tolower(p + 3);      /* lowercase hostname */
d616 1
a616 1
    new->hostname = p + 3;
@


1.14
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d496 2
d543 2
d980 19
d1027 2
@


1.13
log
@merge
@
text
@a221 1
#ifdef EAPI
a222 1
#endif /* EAPI */
a229 1
#ifdef EAPI
a235 1
#endif /* EAPI */
a250 1
#ifdef EAPI
a252 1
#endif
a254 1
#ifdef EAPI
a284 1
#endif /* EAPI */
a415 1
#ifdef EAPI
a421 1
#endif /* EAPI */
a430 1
#ifdef EAPI
a431 1
#endif /* EAPI */
a445 1
#ifdef EAPI
a451 1
#endif /* EAPI */
a1049 1
#ifdef EAPI
a1053 1
#endif
@


1.12
log
@#include "http_main.h" for the chroot functions
fixes some implicit declaration warnings
ok henning@@
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
@


1.11
log
@strip_chroot here as well.

pointed out by sengel at melshake dot com
@
text
@d64 1
@


1.10
log
@merge
@
text
@d791 1
@


1.9
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d102 3
a104 2
            /* any number of '/' in the alias matches any number in
             * the supplied URI, but there must be at least one...
d126 3
a128 3
    /* Return number of characters from URI which matched (may be
     * greater than length of alias, since we may have matched
     * doubled slashes)
d150 1
a150 1
    conf = (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
d154 4
a157 4
       if (!(r->parsed_uri.hostname
            && !strcasecmp(r->parsed_uri.scheme, ap_http_method(r))
            && ap_matches_request_vhost(r, r->parsed_uri.hostname,
               r->parsed_uri.port_str ? r->parsed_uri.port : ap_default_port(r)))) {
d168 4
a171 4
            r->proxyreq = STD_PROXY;
            r->uri = r->unparsed_uri;
            r->filename = ap_pstrcat(r->pool, "proxy:", r->uri, NULL);
            r->handler = "proxy-server";
d180 1
a180 1
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
d182 1
a182 1
    struct proxy_alias *ent = (struct proxy_alias *) conf->aliases->elts;
d185 3
a187 2
        /* someone has already set up the proxy, it was possibly ourselves
         * in proxy_detect
d192 4
a195 3
    /* XXX: since r->uri has been manipulated already we're not really
     * compliant with RFC1945 at this point.  But this probably isn't
     * an issue because this is a hybrid proxy/origin server.
d200 7
a206 7
            
       if (len > 0) {
           r->filename = ap_pstrcat(r->pool, "proxy:", ent[i].real,
                                 r->uri + len, NULL);
           r->handler = "proxy-server";
           r->proxyreq = PROXY_PASS;
           return OK;
d248 1
a248 1
    return OK;          /* otherwise; we've done the best we can */
d310 1
a310 1
     || strcasecmp(r->parsed_uri.hostname, "localhost") == 0)
d318 1
a318 1
                                     domain, NULL);
d320 2
a321 2
                                  &r->parsed_uri,
                                  UNP_REVEALPASSWORD);
d324 5
a328 5
    ap_log_rerror(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, r,
                "Domain missing: %s sent to %s%s%s", r->uri,
                ap_unparse_uri_components(r->pool, &r->parsed_uri,
                      UNP_OMITUSERINFO),
                ref ? " from " : "", ref ? ref : "");
d341 1
a341 1
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
d354 1
a354 1
        long maxfwd = strtol(maxfwd_str, NULL, 10);
d364 2
a365 2
        ap_table_setn(r->headers_in, "Max-Forwards", 
                      ap_psprintf(r->pool, "%ld", (maxfwd > 0) ? maxfwd-1 : 0));
d395 1
a395 1
    /*if (strcasecmp(scheme, "http") == 0) */
d398 1
a398 1
        struct dirconn_entry *list = (struct dirconn_entry *) conf->dirconn->elts;
d404 3
a406 3
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
                     (direct_connect) ? "NoProxy for %s" : "UseProxy for %s",
                     r->uri);
d418 4
a421 3
               strncasecmp(url, ents[i].scheme, strlen(ents[i].scheme)) == 0)) {
                /* CONNECT is a special method that bypasses the normal
                 * proxy code.
d433 1
a433 1
                                               ents[i].port);
d437 1
a437 1
                                            ents[i].port);
d451 5
a455 4
/* otherwise, try it direct */
/* N.B. what if we're behind a firewall, where we must use a proxy or
 * give up??
 */
d465 1
a465 1
    if (r->method_number == M_CONNECT)
d467 2
a468 1
    if (strcasecmp(scheme, "http") == 0)
d470 2
a471 1
    if (strcasecmp(scheme, "ftp") == 0)
d473 7
a479 1
    else
d481 1
d500 2
a501 2
    ps->viaopt = via_off; /* initially backward compatible with 1.3.1 */
    ps->viaopt_set = 0; /* 0 means default */
d504 2
a505 1
    ps->recv_buffer_size = 0; /* this default was left unset for some reason */
d534 1
a534 1
                        void *overridesv)
d537 2
a538 2
    proxy_server_conf *base = (proxy_server_conf *) basev;
    proxy_server_conf *overrides = (proxy_server_conf *) overridesv;
d573 1
a573 1
    (proxy_server_conf *) ap_get_module_config(s->module_config, &proxy_module);
d591 2
a592 2
        ap_str_tolower(f);              /* lowercase scheme */
    ap_str_tolower(p + 3);              /* lowercase hostname */
d615 1
a615 1
    (proxy_server_conf *) ap_get_module_config(s->module_config, &proxy_module);
d625 1
a625 1
    add_pass_reverse(cmd_parms *cmd, void *dummy, char *f, char *r)
d631 2
a632 2
    conf = (proxy_server_conf *)ap_get_module_config(s->module_config, 
                                                  &proxy_module);
d662 4
a665 1
            /*@@@@@@FIXME: This copies only the first of (possibly many) IP addrs */
d677 1
a677 1
    set_allowed_ports(cmd_parms *parms, void *dummy, char *arg)
d681 1
a681 1
      ap_get_module_config(s->module_config, &proxy_module);
d702 1
a702 1
    struct dirconn_entry *list = (struct dirconn_entry *) conf->dirconn->elts;
d819 1
a819 1
    psf->cache.maxexpire = (int) (val * (double) SEC_ONE_HR);
d833 1
a833 1
    psf->cache.defaultexpire = (int) (val * (double) SEC_ONE_HR);
d847 1
a847 1
    psf->cache.gcinterval = (int) (val * (double) SEC_ONE_HR);
d909 4
a912 1
            /*@@@@@@FIXME: This copies only the first of (possibly many) IP addrs */
d947 2
a948 2
static const char*
    set_cache_completion(cmd_parms *parms, void *dummy, char *arg)
d955 1
a955 1
               "or 0 for system default.";
d959 1
a959 1
      psf->cache.cache_completion = ((float)s / 100);
d962 1
a962 1
    return NULL;    
d965 2
a966 2
static const char*
    set_via_opt(cmd_parms *parms, void *dummy, char *arg)
d981 1
a981 1
               "off | on | full | block";
d985 1
a985 1
    return NULL;    
d997 1
a997 1
     "on if the true proxy requests should be accepted"},
d999 1
a999 1
     "a scheme, partial URL or '*' and a proxy server"},
d1001 1
a1001 1
     "a virtual path and a URL"},
d1003 1
a1003 1
     "a virtual path and a URL for reverse proxy behaviour"},
d1005 1
a1005 1
     "A list of names, hosts or domains to which the proxy will not connect"},
d1007 1
a1007 1
     "Receive buffer size for outgoing HTTP and FTP connections in bytes"},
d1009 1
a1009 1
     "IO buffer size for outgoing HTTP and FTP connections in bytes"},
d1011 1
a1011 1
     "A list of domains, hosts, or subnets to which the proxy will connect directly"},
d1013 1
a1013 1
     "The default intranet domain name (in absence of a domain in the URL)"},
d1015 1
a1015 1
     "A list of ports which CONNECT may connect to"},
d1017 1
a1017 1
     "The directory to store cache files"},
d1019 1
a1019 1
     "The maximum disk space used by the cache in Kb"},
d1021 1
a1021 1
     "The maximum time in hours to cache a document"},
d1023 1
a1023 1
     "The default time in hours to cache a document"},
d1025 1
a1025 1
     "The factor used to estimate Expires date from LastModified date"},
d1027 1
a1027 1
     "The interval between garbage collections, in hours"},
d1029 1
a1029 1
     "The number of levels of subdirectories in the cache"},
d1031 1
a1031 1
     "The number of characters in subdirectory names"},
d1033 1
a1033 1
     "A list of names, hosts or domains for which caching is *not* provided"},
d1035 1
a1035 1
     "Force a http cache completion after this percentage is loaded"},
d1037 1
a1037 1
     "Configure Via: proxy header header to one of: on | off | block | full"},
a1068 2


@


1.8
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d79 1
a79 1
    {NULL, -1}			/* unknown port */
d101 17
a117 17
	if (*aliasp == '/') {
	    /* any number of '/' in the alias matches any number in
	     * the supplied URI, but there must be at least one...
	     */
	    if (*urip != '/')
		return 0;

	    while (*aliasp == '/')
		++aliasp;
	    while (*urip == '/')
		++urip;
	}
	else {
	    /* Other characters are compared literally */
	    if (*urip++ != *aliasp++)
		return 0;
	}
d123 1
a123 1
	return 0;
d152 1
a152 1
	/* but it might be something vhosted */
d154 2
a155 2
	    && !strcasecmp(r->parsed_uri.scheme, ap_http_method(r))
	    && ap_matches_request_vhost(r, r->parsed_uri.hostname,
d157 4
a160 4
	    r->proxyreq = STD_PROXY;
	    r->uri = r->unparsed_uri;
	    r->filename = ap_pstrcat(r->pool, "proxy:", r->uri, NULL);
	    r->handler = "proxy-server";
d165 6
a170 6
	     && r->parsed_uri.hostname
	     && r->parsed_uri.port_str) {
	    r->proxyreq = STD_PROXY;
	    r->uri = r->unparsed_uri;
	    r->filename = ap_pstrcat(r->pool, "proxy:", r->uri, NULL);
	    r->handler = "proxy-server";
d184 4
a187 4
	/* someone has already set up the proxy, it was possibly ourselves
	 * in proxy_detect
	 */
	return OK;
d197 1
a197 1
	    
d204 1
a204 1
	}
d223 1
a223 1
	return DECLINED;
d237 1
a237 1
	return ap_proxy_http_canon(r, url + 5, "http", DEFAULT_HTTP_PORT);
d239 1
a239 1
	return ap_proxy_ftp_canon(r, url + 4);
d243 1
a243 1
	return HTTP_BAD_REQUEST;
d245 1
a245 1
    return OK;		/* otherwise; we've done the best we can */
d303 1
a303 1
	return DECLINED;
d308 1
a308 1
	return DECLINED;	/* host name has a dot already */
d315 1
a315 1
				     domain, NULL);
d317 2
a318 2
				  &r->parsed_uri,
				  UNP_REVEALPASSWORD);
d322 4
a325 4
		"Domain missing: %s sent to %s%s%s", r->uri,
		ap_unparse_uri_components(r->pool, &r->parsed_uri,
		      UNP_OMITUSERINFO),
		ref ? " from " : "", ref ? ref : "");
d347 1
a347 1
	return DECLINED;
d350 13
a362 13
	(maxfwd_str = ap_table_get(r->headers_in, "Max-Forwards")) != NULL) {
	long maxfwd = strtol(maxfwd_str, NULL, 10);
	if (maxfwd < 1) {
	    int access_status;
	    r->proxyreq = NOT_PROXY;
	    if ((access_status = ap_send_http_trace(r)))
		ap_die(access_status, r);
	    else
		ap_finalize_request_protocol(r);
	    return OK;
	}
	ap_table_setn(r->headers_in, "Max-Forwards", 
		      ap_psprintf(r->pool, "%ld", (maxfwd > 0) ? maxfwd-1 : 0));
d366 1
a366 1
	return rc;
d371 1
a371 1
	return HTTP_BAD_REQUEST;
d373 1
d376 1
a376 1
	return rc;
d380 3
a382 3
	rc = proxy_needsdomain(r, url, conf->domain);
	if (ap_is_HTTP_REDIRECT(rc))
	    return HTTP_MOVED_PERMANENTLY;
d394 2
a395 2
	int ii;
	struct dirconn_entry *list = (struct dirconn_entry *) conf->dirconn->elts;
d397 3
a399 3
	for (direct_connect = ii = 0; ii < conf->dirconn->nelts && !direct_connect; ii++) {
	    direct_connect = list[ii].matcher(&list[ii], r);
	}
d401 3
a403 3
	ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
		     (direct_connect) ? "NoProxy for %s" : "UseProxy for %s",
		     r->uri);
d410 9
a418 9
	for (i = 0; i < proxies->nelts; i++) {
	    p = strchr(ents[i].scheme, ':');	/* is it a partial URL? */
	    if (strcmp(ents[i].scheme, "*") == 0 ||
		(p == NULL && strcasecmp(scheme, ents[i].scheme) == 0) ||
		(p != NULL &&
	       strncasecmp(url, ents[i].scheme, strlen(ents[i].scheme)) == 0)) {
		/* CONNECT is a special method that bypasses the normal
		 * proxy code.
		 */
d427 3
a429 3
		if (r->method_number == M_CONNECT)
		    rc = ap_proxy_connect_handler(r, cr, url, ents[i].hostname,
					       ents[i].port);
d431 5
a435 5
		else if (strcasecmp(ents[i].protocol, "http") == 0)
		    rc = ap_proxy_http_handler(r, cr, url, ents[i].hostname,
					    ents[i].port);
		else
		    rc = DECLINED;
d440 6
a445 6
		/* an error or success */
		if (rc != DECLINED && rc != HTTP_BAD_GATEWAY)
		    return rc;
		/* we failed to talk to the upstream proxy */
	    }
	}
d461 1
a461 1
	return ap_proxy_connect_handler(r, cr, url, NULL, 0);
d463 1
a463 1
	return ap_proxy_http_handler(r, cr, url, NULL, 0);
d465 1
a465 1
	return ap_proxy_ftp_handler(r, cr, url);
d467 1
a467 1
	return HTTP_FORBIDDEN;
d492 2
d511 1
a511 1
    ps->cache.cache_completion = DEFAULT_CACHE_COMPLETION;
d537 1
d565 1
a565 1
	return "ProxyRemote: Bad syntax for a remote proxy server";
d568 3
a570 3
	if (sscanf(q + 1, "%u", &port) != 1 || port > 65535)
	    return "ProxyRemote: Bad syntax for a remote proxy server (bad port number)";
	*q = '\0';
d573 1
a573 1
	port = -1;
d576 2
a577 2
	ap_str_tolower(f);		/* lowercase scheme */
    ap_str_tolower(p + 3);		/* lowercase hostname */
d580 5
a584 5
	int i;
	for (i = 0; defports[i].scheme != NULL; i++)
	    if (strcasecmp(defports[i].scheme, r) == 0)
		break;
	port = defports[i].port;
d638 2
a639 2
	if (strcasecmp(arg, list[i].name) == 0) /* ignore case for host names */
	    found = 1;
d643 8
a650 8
	new = ap_push_array(conf->noproxies);
	new->name = arg;
	/* Don't do name lookups on things that aren't dotted */
	if (strchr(arg, '.') != NULL && ap_proxy_host2addr(new->name, &hp) == NULL)
	    /*@@@@@@FIXME: This copies only the first of (possibly many) IP addrs */
	    memcpy(&new->addr, hp.h_addr, sizeof(struct in_addr));
	else
	    new->addr.s_addr = 0;
d667 1
a667 1
	return "AllowCONNECT: port number must be numeric";
d690 2
a691 2
	if (strcasecmp(arg, list[i].name) == 0)
	    found = 1;
d695 3
a697 3
	New = ap_push_array(conf->dirconn);
	New->name = arg;
	New->hostentry = NULL;
d699 1
a699 1
	if (ap_proxy_is_ipaddr(New, parms->pool)) {
d701 2
a702 2
	    fprintf(stderr, "Parsed addr %s\n", inet_ntoa(New->addr));
	    fprintf(stderr, "Parsed mask %s\n", inet_ntoa(New->mask));
d704 3
a706 3
	}
	else if (ap_proxy_is_domainname(New, parms->pool)) {
	    ap_str_tolower(New->name);
d708 1
a708 1
	    fprintf(stderr, "Parsed domain %s\n", New->name);
d710 3
a712 3
	}
	else if (ap_proxy_is_hostname(New, parms->pool)) {
	    ap_str_tolower(New->name);
d714 1
a714 1
	    fprintf(stderr, "Parsed host %s\n", New->name);
d716 3
a718 3
	}
	else {
	    ap_proxy_is_word(New, parms->pool);
d720 1
a720 1
	    fprintf(stderr, "Parsed word %s\n", New->name);
d722 1
a722 1
	}
d734 1
a734 1
	return "ProxyDomain: domain name must start with a dot.";
d760 1
a760 1
	return "CacheSize value must be an integer (kBytes)";
d785 1
a785 1
	return "CacheLastModifiedFactor value must be a float";
d800 1
a800 1
	return "CacheMaxExpire value must be a float";
d814 1
a814 1
	return "CacheDefaultExpire value must be a float";
d828 1
a828 1
	return "CacheGcInterval value must be a float";
d843 1
a843 1
	return "CacheDirLevels value must be an integer greater than 0";
d845 1
a845 1
	return "CacheDirLevels*CacheDirLength value must not be higher than 20";
d860 1
a860 1
	return "CacheDirLength value must be an integer greater than 0";
d862 1
a862 1
	return "CacheDirLevels*CacheDirLength value must not be higher than 20";
d882 2
a883 2
	if (strcasecmp(arg, list[i].name) == 0) /* ignore case for host names */
	    found = 1;
d887 8
a894 8
	new = ap_push_array(conf->nocaches);
	new->name = arg;
	/* Don't do name lookups on things that aren't dotted */
	if (strchr(arg, '.') != NULL && ap_proxy_host2addr(new->name, &hp) == NULL)
	    /*@@@@@@FIXME: This copies only the first of (possibly many) IP addrs */
	    memcpy(&new->addr, hp.h_addr, sizeof(struct in_addr));
	else
	    new->addr.s_addr = 0;
d906 1
a906 1
	return "ProxyReceiveBufferSize must be >= 512 bytes, or 0 for system default.";
d914 12
d933 1
a933 1
	return "CacheForceCompletion must be <= 100 percent, "
d940 1
a940 1
    psf->cache.cache_completion = 1;
d959 1
a959 1
	return "ProxyVia must be one of: "
d987 2
d1023 18
a1040 18
    proxy_init,			/* initializer */
    NULL,			/* create per-directory config structure */
    NULL,			/* merge per-directory config structures */
    create_proxy_config,	/* create per-server config structure */
    merge_proxy_config,		/* merge per-server config structures */
    proxy_cmds,			/* command table */
    proxy_handlers,		/* handlers */
    proxy_trans,		/* translate_handler */
    NULL,			/* check_user_id */
    NULL,			/* check auth */
    NULL,			/* check access */
    NULL,			/* type_checker */
    proxy_fixup,		/* pre-run fixups */
    NULL,			/* logger */
    NULL,			/* header parser */
    NULL,			/* child_init */
    NULL,			/* child_exit */
    proxy_detect		/* post read-request */
@


1.7
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1996-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 20
a38 23
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 7
a56 6
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
d501 2
a502 2
    ps->cache.gcinterval = -1;
    ps->cache.gcinterval_set = 0;
@


1.6
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d350 1
a350 1
	int maxfwd = strtol(maxfwd_str, NULL, 10);
d361 1
a361 1
		      ap_psprintf(r->pool, "%d", (maxfwd > 0) ? maxfwd-1 : 0));
a1030 6
#ifdef NETWARE
int main(int argc, char *argv[]) 
{
    ExitThread(TSR_THREAD, 0);
}
#endif
@


1.5
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d250 4
@


1.4
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d156 1
a156 1
	    r->proxyreq = 1;
d166 1
a166 1
	    r->proxyreq = 1;
d182 1
a182 1
    if (r->proxyreq) {
d201 1
a201 1
           r->proxyreq = 1;
d221 1
a221 1
    if (!r->proxyreq || strncmp(r->filename, "proxy:", 6) != 0)
d297 1
a297 1
    if (!r->proxyreq || r->method_number != M_GET || !r->parsed_uri.hostname)
d341 1
a341 1
    if (!r->proxyreq || strncmp(r->filename, "proxy:", 6) != 0)
d349 1
a349 1
	    r->proxyreq = 0;
d481 1
d483 3
d489 1
d491 1
d493 1
d495 1
d497 1
d500 1
d502 1
d504 36
d738 1
d753 1
d778 1
d793 1
d807 1
d821 1
d838 1
d855 1
d901 1
d918 2
d942 1
d1004 1
a1004 1
    NULL,			/* merge per-server config structures */
d1025 8
@


1.3
log
@mod_ssl-2.2.3-1.3.4 (will require libssl-1.1 for https to work, but
mostly harmless otherwise).
@
text
@d610 1
a610 1
    if (!isdigit(arg[0]))
@


1.2
log
@Apache 1.3.4 merge
@
text
@d217 3
d227 8
d252 32
a283 1

d413 8
d430 3
d446 8
d959 6
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1996,1997 The Apache Group.  All rights reserved.
d23 2
a24 1
 *    prior written permission.
d26 5
a30 1
 * 5. Redistributions of any form whatsoever must retain the following
d60 6
d68 11
a78 10
static struct proxy_services defports[]={
    { "ftp",      DEFAULT_FTP_PORT},
    { "gopher",   DEFAULT_GOPHER_PORT},
    { "http",     DEFAULT_PORT},
    { "nntp",     DEFAULT_NNTP_PORT},
    { "wais",     DEFAULT_WAIS_PORT}, 
    { "https",    DEFAULT_HTTPS_PORT},
    { "snews",    DEFAULT_SNEWS_PORT},
    { "prospero", DEFAULT_PROSPERO_PORT},
    { NULL, -1}  /* unknown port */
d94 1
a94 2
static int
alias_match(char *uri, char *alias_fakename)
d96 2
a97 2
    char *end_fakename = alias_fakename + strlen (alias_fakename);
    char *aliasp = alias_fakename, *urip = uri;
d99 2
a100 4
    while (aliasp < end_fakename)
    {
	if (*aliasp == '/')
	{
d104 7
a110 4
	    if (*urip != '/') return 0;
	    
	    while (*aliasp == '/') ++ aliasp;
	    while (*urip == '/') ++ urip;
d114 2
a115 1
	    if (*urip++ != *aliasp++) return 0;
d132 43
a174 2
static int
proxy_trans(request_rec *r)
d178 10
a187 1
        (proxy_server_conf *)get_module_config(sconf, &proxy_module);
d189 4
a192 11
    if (r->proxyreq)
    {
	if (!conf->req) return DECLINED;
	
	r->filename = pstrcat(r->pool, "proxy:", r->uri, NULL);
	r->handler = "proxy-server";
	return OK;
    } else
    {
	int i, len;
	struct proxy_alias *ent=(struct proxy_alias *)conf->aliases->elts;
d194 9
a202 11
	for (i=0; i < conf->aliases->nelts; i++)
	{
	    len = alias_match(r->uri, ent[i].fake);

	    if (len > 0)
	    {
		r->filename = pstrcat(r->pool, "proxy:", ent[i].real,
				      r->uri + len, NULL);
		r->handler = "proxy-server";
		return OK;
	    }
a203 1
	return DECLINED;
d205 1
d214 1
a214 2
static int
proxy_fixup(request_rec *r)
a216 1
    int i;
d218 2
a219 1
    if (strncmp(r->filename, "proxy:", 6) != 0) return DECLINED;
d222 7
a228 1
/* lowercase the scheme */
d230 10
a239 2
    if (p == NULL || p == url) return BAD_REQUEST;
    for (i=0; i != p - url; i++) url[i] = tolower(url[i]);
d241 40
a280 6
/* canonicalise each specific scheme */
    if (strncmp(url, "http:", 5) == 0)
	return proxy_http_canon(r, url+5, "http", DEFAULT_PORT);
    else if (strncmp(url, "ftp:", 4) == 0)
	return proxy_ftp_canon(r, url+4);
    else return OK; /* otherwise; we've done the best we can */
d285 2
a286 3
 
static int
proxy_handler(request_rec *r)
d291 3
a293 3
        (proxy_server_conf *)get_module_config(sconf, &proxy_module);
    array_header *proxies=conf->proxies;
    struct proxy_remote *ents=(struct proxy_remote *)proxies->elts;
d295 3
a297 1
    struct cache_req *cr;
d299 2
a300 1
    if (strncmp(r->filename, "proxy:", 6) != 0) return DECLINED;
d302 17
a318 1
    if ((rc = setup_client_block(r, REQUEST_CHUNKED_ERROR)))
d323 2
a324 1
    if (p == NULL) return BAD_REQUEST;
d326 10
a335 2
    rc = proxy_cache_check(r, url, &conf->cache, &cr);
    if (rc != DECLINED) return rc;
d338 1
a338 1
    scheme = pstrdup(r->pool, url);
d341 19
a359 1
/* firstly, try a proxy */
d361 13
a373 8
    for (i=0; i < proxies->nelts; i++)
    {
	p = strchr(ents[i].scheme, ':');  /* is it a partial URL? */
	if (strcmp(ents[i].scheme, "*") == 0 || 
	    (p == NULL && strcasecmp(scheme, ents[i].scheme) == 0) ||
	    (p != NULL &&
	       strncasecmp(url, ents[i].scheme, strlen(ents[i].scheme)) == 0))
	{
d375 11
a385 8
	    if (strcasecmp(ents[i].protocol, "http") == 0)
		rc = proxy_http_handler(r, cr, url, ents[i].hostname,
		    ents[i].port);
	    else rc = DECLINED;

 /* an error or success */
	    if (rc != DECLINED && rc != BAD_GATEWAY) return rc;
 /* we failed to talk to the upstream proxy */
a386 1
    }
d394 1
a394 1
	return proxy_connect_handler(r, cr, url);
d396 1
a396 1
	return proxy_http_handler(r, cr, url, NULL, 0);
d398 3
a400 2
	return proxy_ftp_handler(r, cr, url);
    else return NOT_IMPLEMENTED;
d407 1
a407 1
create_proxy_config(pool *p, server_rec *s)
d409 1
a409 7
  proxy_server_conf *ps = pcalloc(p, sizeof(proxy_server_conf));

  ps->proxies = make_array(p, 10, sizeof(struct proxy_remote));
  ps->aliases = make_array(p, 10, sizeof(struct proxy_alias));
  ps->noproxies = make_array(p, 10, sizeof(struct noproxy_entry));
  ps->nocaches = make_array(p, 10, sizeof(struct nocache_entry));
  ps->req = 0;
d411 21
a431 9
  ps->cache.root = NULL;
  ps->cache.space = DEFAULT_CACHE_SPACE;
  ps->cache.maxexpire = DEFAULT_CACHE_MAXEXPIRE;
  ps->cache.defaultexpire = DEFAULT_CACHE_EXPIRE;
  ps->cache.lmfactor = DEFAULT_CACHE_LMFACTOR;
  ps->cache.gcinterval = -1;
  /* at these levels, the cache can have 2^18 directories (256,000)  */
  ps->cache.dirlevels=3;
  ps->cache.dirlength=1;
d433 1
a433 1
  return ps;
d437 1
a437 1
add_proxy(cmd_parms *cmd, void *dummy, char *f, char *r)
d441 1
a441 1
        (proxy_server_conf *)get_module_config(s->module_config,&proxy_module);
d448 1
a448 1
	return "Bad syntax for a remote proxy server";
d450 3
a452 4
    if (q != NULL)
    {
	if (sscanf(q+1, "%u", &port) != 1 || port > 65535)
	    return "Bad syntax for a remote proxy server (bad port number)";
d454 3
a456 1
    } else port = -1;
d458 3
a460 2
    if (strchr(f, ':') == NULL) str_tolower(f);     /* lowercase scheme */
    str_tolower(p + 3); /* lowercase hostname */
d462 1
a462 2
    if (port == -1)
    {
d464 3
a466 2
	for (i=0; defports[i].scheme != NULL; i++)
	    if (strcasecmp(defports[i].scheme, r) == 0) break;
d470 1
a470 1
    new = push_array (conf->proxies);
d479 1
a479 1
add_pass(cmd_parms *cmd, void *dummy, char *f, char *r)
d483 1
a483 1
        (proxy_server_conf *)get_module_config(s->module_config,&proxy_module);
d486 1
a486 1
    new = push_array (conf->aliases);
d493 16
a508 1
set_proxy_exclude(cmd_parms *parms, void *dummy, char *arg)
d512 1
a512 1
	get_module_config (s->module_config, &proxy_module);
d514 1
a514 1
    struct noproxy_entry *list=(struct noproxy_entry*)conf->noproxies->elts;
d520 2
a521 3
    for (i=0; i < conf->noproxies->nelts; i++)
    {
	if (strcmp(arg, list[i].name) == 0)
d525 2
a526 3
    if (!found)
    {
	new = push_array (conf->noproxies);
d529 2
a530 1
	if (strchr(arg, '.') != NULL && proxy_host2addr(new->name, &hp) == NULL)
d538 72
d611 1
a611 1
set_proxy_req(cmd_parms *parms, void *dummy, int flag)
d614 14
a627 1
	get_module_config (parms->server->module_config, &proxy_module);
d635 1
a635 1
set_cache_size(cmd_parms *parms, char *struct_ptr, char *arg)
d638 1
a638 1
	get_module_config (parms->server->module_config, &proxy_module);
d641 2
a642 1
    if (sscanf(arg, "%d", &val) != 1) return "Value must be an integer";
d648 1
a648 1
set_cache_root(cmd_parms *parms, void *dummy, char *arg)
d651 1
a651 1
	get_module_config (parms->server->module_config, &proxy_module);
d659 1
a659 1
set_cache_factor(cmd_parms *parms, void *dummy, char *arg)
d662 1
a662 1
	get_module_config (parms->server->module_config, &proxy_module);
d665 2
a666 1
    if (sscanf(arg, "%lg", &val) != 1) return "Value must be a float";
d673 1
a673 1
set_cache_maxex(cmd_parms *parms, void *dummy, char *arg)
d676 1
a676 1
	get_module_config (parms->server->module_config, &proxy_module);
d679 3
a681 2
    if (sscanf(arg, "%lg", &val) != 1) return "Value must be a float";
    psf->cache.maxexpire = (int)(val * (double)SEC_ONE_HR);
d686 1
a686 1
set_cache_defex(cmd_parms *parms, void *dummy, char *arg)
d689 1
a689 1
	get_module_config (parms->server->module_config, &proxy_module);
d692 3
a694 2
    if (sscanf(arg, "%lg", &val) != 1) return "Value must be a float";
    psf->cache.defaultexpire = (int)(val * (double)SEC_ONE_HR);
d699 1
a699 1
set_cache_gcint(cmd_parms *parms, void *dummy, char *arg)
d702 1
a702 1
	get_module_config (parms->server->module_config, &proxy_module);
d705 3
a707 2
    if (sscanf(arg, "%lg", &val) != 1) return "Value must be a float";
    psf->cache.gcinterval = (int)(val * (double)SEC_ONE_HR);
d712 1
a712 1
set_cache_dirlevels(cmd_parms *parms, char *struct_ptr, char *arg)
d715 1
a715 1
	get_module_config (parms->server->module_config, &proxy_module);
d718 5
a722 1
    if (sscanf(arg, "%d", &val) != 1) return "Value must be an integer";
d728 1
a728 1
set_cache_dirlength(cmd_parms *parms, char *struct_ptr, char *arg)
d731 1
a731 1
	get_module_config (parms->server->module_config, &proxy_module);
d734 5
a738 1
    if (sscanf(arg, "%d", &val) != 1) return "Value must be an integer";
d744 1
a744 1
set_cache_exclude(cmd_parms *parms, void *dummy, char *arg)
d748 1
a748 1
	get_module_config (s->module_config, &proxy_module);
d750 1
a750 1
    struct nocache_entry *list=(struct nocache_entry*)conf->nocaches->elts;
d756 2
a757 3
    for (i=0; i < conf->nocaches->nelts; i++)
    {
	if (strcmp(arg, list[i].name) == 0)
d761 2
a762 3
    if (!found)
    {
	new = push_array (conf->nocaches);
d765 2
a766 1
	if (strchr(arg, '.') != NULL && proxy_host2addr(new->name, &hp) == NULL)
d769 13
a781 1
	    new->addr.s_addr= 0;
d783 2
d788 42
a829 33
static handler_rec proxy_handlers[] = {
{ "proxy-server", proxy_handler },
{ NULL } 
};  
    
static command_rec proxy_cmds[] = {
{ "ProxyRequests", set_proxy_req, NULL, RSRC_CONF, FLAG,
  "on if the true proxy requests should be accepted"},
{ "ProxyRemote", add_proxy, NULL, RSRC_CONF, TAKE2,
    "a scheme, partial URL or '*' and a proxy server"},
{ "ProxyPass", add_pass, NULL, RSRC_CONF, TAKE2,
    "a virtual path and a URL"},
{ "ProxyBlock", set_proxy_exclude, NULL, RSRC_CONF, ITERATE,
    "A list of names, hosts or domains to which the proxy will not connect" },
{ "CacheRoot", set_cache_root, NULL, RSRC_CONF, TAKE1,
      "The directory to store cache files"},
{ "CacheSize", set_cache_size, NULL, RSRC_CONF, TAKE1,
      "The maximum disk space used by the cache in Kb"},
{ "CacheMaxExpire", set_cache_maxex, NULL, RSRC_CONF, TAKE1,
      "The maximum time in hours to cache a document"},
{ "CacheDefaultExpire", set_cache_defex, NULL, RSRC_CONF, TAKE1,
      "The default time in hours to cache a document"}, 
{ "CacheLastModifiedFactor", set_cache_factor, NULL, RSRC_CONF, TAKE1,
      "The factor used to estimate Expires date from LastModified date"},
{ "CacheGcInterval", set_cache_gcint, NULL, RSRC_CONF, TAKE1,
      "The interval between garbage collections, in hours"},
{ "CacheDirLevels", set_cache_dirlevels, NULL, RSRC_CONF, TAKE1,
    "The number of levels of subdirectories in the cache" },
{ "CacheDirLength", set_cache_dirlength, NULL, RSRC_CONF, TAKE1,
    "The number of characters in subdirectory names" },
{ "NoCache", set_cache_exclude, NULL, RSRC_CONF, ITERATE,
    "A list of names, hosts or domains for which caching is *not* provided" },
{ NULL }
d832 43
a874 17
module proxy_module = {
   STANDARD_MODULE_STUFF,
   NULL,                        /* initializer */
   NULL,                        /* create per-directory config structure */
   NULL,                        /* merge per-directory config structures */
   create_proxy_config,         /* create per-server config structure */
   NULL,                        /* merge per-server config structures */
   proxy_cmds,                  /* command table */
   proxy_handlers,              /* handlers */
   proxy_trans,                 /* translate_handler */
   NULL,                        /* check_user_id */
   NULL,                        /* check auth */
   NULL,                        /* check access */
   NULL,                        /* type_checker */
   proxy_fixup,                 /* pre-run fixups */
   NULL,                        /* logger */
   NULL                         /* header parser */
d877 22
@


1.1.1.1
log
@Initial import from apache 1.2.6
@
text
@@


1.1.1.2
log
@Apache 1.3.2
@
text
@d2 1
a2 1
 * Copyright (c) 1996-1998 The Apache Group.  All rights reserved.
d23 1
a23 2
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
d25 1
a25 5
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
a54 6
#define CORE_PRIVATE

#include "http_log.h"
#include "http_vhost.h"
#include "http_request.h"

d57 10
a66 11
static struct proxy_services defports[] =
{
    {"http", DEFAULT_HTTP_PORT},
    {"ftp", DEFAULT_FTP_PORT},
    {"https", DEFAULT_HTTPS_PORT},
    {"gopher", DEFAULT_GOPHER_PORT},
    {"nntp", DEFAULT_NNTP_PORT},
    {"wais", DEFAULT_WAIS_PORT},
    {"snews", DEFAULT_SNEWS_PORT},
    {"prospero", DEFAULT_PROSPERO_PORT},
    {NULL, -1}			/* unknown port */
d82 2
a83 1
static int alias_match(const char *uri, const char *alias_fakename)
d85 2
a86 2
    const char *end_fakename = alias_fakename + strlen(alias_fakename);
    const char *aliasp = alias_fakename, *urip = uri;
d88 4
a91 2
    while (aliasp < end_fakename) {
	if (*aliasp == '/') {
d95 4
a98 7
	    if (*urip != '/')
		return 0;

	    while (*aliasp == '/')
		++aliasp;
	    while (*urip == '/')
		++urip;
d102 1
a102 2
	    if (*urip++ != *aliasp++)
		return 0;
d119 2
a120 12
/* Detect if an absoluteURI should be proxied or not.  Note that we
 * have to do this during this phase because later phases are
 * "short-circuiting"... i.e. translate_names will end when the first
 * module returns OK.  So for example, if the request is something like:
 *
 * GET http://othervhost/cgi-bin/printenv HTTP/1.0
 *
 * mod_alias will notice the /cgi-bin part and ScriptAlias it and
 * short-circuit the proxy... just because of the ordering in the
 * configuration file.
 */
static int proxy_detect(request_rec *r)
d123 2
a124 1
    proxy_server_conf *conf;
d126 6
a131 38
    conf = (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);

    if (conf->req && r->parsed_uri.scheme) {
	/* but it might be something vhosted */
       if (!(r->parsed_uri.hostname
	    && !strcasecmp(r->parsed_uri.scheme, ap_http_method(r))
	    && ap_matches_request_vhost(r, r->parsed_uri.hostname,
               r->parsed_uri.port_str ? r->parsed_uri.port : ap_default_port(r)))) {
	    r->proxyreq = 1;
	    r->uri = r->unparsed_uri;
	    r->filename = ap_pstrcat(r->pool, "proxy:", r->uri, NULL);
	    r->handler = "proxy-server";
        }
    }
    /* We need special treatment for CONNECT proxying: it has no scheme part */
    else if (conf->req && r->method_number == M_CONNECT
	     && r->parsed_uri.hostname
	     && r->parsed_uri.port_str) {
	    r->proxyreq = 1;
	    r->uri = r->unparsed_uri;
	    r->filename = ap_pstrcat(r->pool, "proxy:", r->uri, NULL);
	    r->handler = "proxy-server";
    }
    return DECLINED;
}

static int proxy_trans(request_rec *r)
{
    void *sconf = r->server->module_config;
    proxy_server_conf *conf =
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
    int i, len;
    struct proxy_alias *ent = (struct proxy_alias *) conf->aliases->elts;

    if (r->proxyreq) {
	/* someone has already set up the proxy, it was possibly ourselves
	 * in proxy_detect
	 */
d133 4
a136 1
    }
d138 11
a148 14
    /* XXX: since r->uri has been manipulated already we're not really
     * compliant with RFC1945 at this point.  But this probably isn't
     * an issue because this is a hybrid proxy/origin server.
     */

    for (i = 0; i < conf->aliases->nelts; i++) {
        len = alias_match(r->uri, ent[i].fake);
	    
       if (len > 0) {
           r->filename = ap_pstrcat(r->pool, "proxy:", ent[i].real,
                                 r->uri + len, NULL);
           r->handler = "proxy-server";
           r->proxyreq = 1;
           return OK;
d150 1
a151 1
    return DECLINED;
d160 2
a161 1
static int proxy_fixup(request_rec *r)
d164 1
d166 1
a166 2
    if (!r->proxyreq || strncmp(r->filename, "proxy:", 6) != 0)
	return DECLINED;
d169 4
d175 5
a179 57
    if (strncasecmp(url, "http:", 5) == 0)
	return ap_proxy_http_canon(r, url + 5, "http", DEFAULT_HTTP_PORT);
    else if (strncasecmp(url, "ftp:", 4) == 0)
	return ap_proxy_ftp_canon(r, url + 4);

    p = strchr(url, ':');
    if (p == NULL || p == url)
	return HTTP_BAD_REQUEST;

    return OK;		/* otherwise; we've done the best we can */
}

static void proxy_init(server_rec *r, pool *p)
{
    ap_proxy_garbage_init(r, p);
}



/* Send a redirection if the request contains a hostname which is not */
/* fully qualified, i.e. doesn't have a domain name appended. Some proxy */
/* servers like Netscape's allow this and access hosts from the local */
/* domain in this case. I think it is better to redirect to a FQDN, since */
/* these will later be found in the bookmarks files. */
/* The "ProxyDomain" directive determines what domain will be appended */
static int proxy_needsdomain(request_rec *r, const char *url, const char *domain)
{
    char *nuri;
    const char *ref;

    /* We only want to worry about GETs */
    if (!r->proxyreq || r->method_number != M_GET || !r->parsed_uri.hostname)
	return DECLINED;

    /* If host does contain a dot already, or it is "localhost", decline */
    if (strchr(r->parsed_uri.hostname, '.') != NULL
     || strcasecmp(r->parsed_uri.hostname, "localhost") == 0)
	return DECLINED;	/* host name has a dot already */

    ref = ap_table_get(r->headers_in, "Referer");

    /* Reassemble the request, but insert the domain after the host name */
    /* Note that the domain name always starts with a dot */
    r->parsed_uri.hostname = ap_pstrcat(r->pool, r->parsed_uri.hostname,
				     domain, NULL);
    nuri = ap_unparse_uri_components(r->pool,
				  &r->parsed_uri,
				  UNP_REVEALPASSWORD);

    ap_table_set(r->headers_out, "Location", nuri);
    ap_log_rerror(APLOG_MARK, APLOG_INFO|APLOG_NOERRNO, r,
		"Domain missing: %s sent to %s%s%s", r->uri,
		ap_unparse_uri_components(r->pool, &r->parsed_uri,
		      UNP_OMITUSERINFO),
		ref ? " from " : "", ref ? ref : "");

    return HTTP_MOVED_PERMANENTLY;
d184 3
a186 2

static int proxy_handler(request_rec *r)
d191 3
a193 3
    (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
    array_header *proxies = conf->proxies;
    struct proxy_remote *ents = (struct proxy_remote *) proxies->elts;
d195 1
a195 3
    cache_req *cr;
    int direct_connect = 0;
    const char *maxfwd_str;
d197 1
a197 2
    if (!r->proxyreq || strncmp(r->filename, "proxy:", 6) != 0)
	return DECLINED;
d199 1
a199 17
    if (r->method_number == M_TRACE &&
	(maxfwd_str = ap_table_get(r->headers_in, "Max-Forwards")) != NULL) {
	int maxfwd = strtol(maxfwd_str, NULL, 10);
	if (maxfwd < 1) {
	    int access_status;
	    r->proxyreq = 0;
	    if ((access_status = ap_send_http_trace(r)))
		ap_die(access_status, r);
	    else
		ap_finalize_request_protocol(r);
	    return OK;
	}
	ap_table_setn(r->headers_in, "Max-Forwards", 
		      ap_psprintf(r->pool, "%d", (maxfwd > 0) ? maxfwd-1 : 0));
    }

    if ((rc = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR)))
d204 1
a204 2
    if (p == NULL)
	return HTTP_BAD_REQUEST;
d206 2
a207 10
    rc = ap_proxy_cache_check(r, url, &conf->cache, &cr);
    if (rc != DECLINED)
	return rc;

    /* If the host doesn't have a domain name, add one and redirect. */
    if (conf->domain != NULL) {
	rc = proxy_needsdomain(r, url, conf->domain);
	if (ap_is_HTTP_REDIRECT(rc))
	    return HTTP_MOVED_PERMANENTLY;
    }
d210 1
a210 1
    scheme = ap_pstrdup(r->pool, url);
d213 3
a215 4
    /* Check URI's destination host against NoProxy hosts */
    /* Bypass ProxyRemote server lookup if configured as NoProxy */
    /* we only know how to handle communication to a proxy via http */
    /*if (strcasecmp(scheme, "http") == 0) */
d217 15
a231 5
	int ii;
	struct dirconn_entry *list = (struct dirconn_entry *) conf->dirconn->elts;

	for (direct_connect = ii = 0; ii < conf->dirconn->nelts && !direct_connect; ii++) {
	    direct_connect = list[ii].matcher(&list[ii], r);
a232 5
#if DEBUGGING
	ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
		     (direct_connect) ? "NoProxy for %s" : "UseProxy for %s",
		     r->uri);
#endif
a234 29
/* firstly, try a proxy, unless a NoProxy directive is active */

    if (!direct_connect)
	for (i = 0; i < proxies->nelts; i++) {
	    p = strchr(ents[i].scheme, ':');	/* is it a partial URL? */
	    if (strcmp(ents[i].scheme, "*") == 0 ||
		(p == NULL && strcasecmp(scheme, ents[i].scheme) == 0) ||
		(p != NULL &&
	       strncasecmp(url, ents[i].scheme, strlen(ents[i].scheme)) == 0)) {
		/* CONNECT is a special method that bypasses the normal
		 * proxy code.
		 */
		if (r->method_number == M_CONNECT)
		    rc = ap_proxy_connect_handler(r, cr, url, ents[i].hostname,
					       ents[i].port);
/* we only know how to handle communication to a proxy via http */
		else if (strcasecmp(ents[i].protocol, "http") == 0)
		    rc = ap_proxy_http_handler(r, cr, url, ents[i].hostname,
					    ents[i].port);
		else
		    rc = DECLINED;

		/* an error or success */
		if (rc != DECLINED && rc != HTTP_BAD_GATEWAY)
		    return rc;
		/* we failed to talk to the upstream proxy */
	    }
	}

d241 1
a241 1
	return ap_proxy_connect_handler(r, cr, url, NULL, 0);
d243 1
a243 1
	return ap_proxy_http_handler(r, cr, url, NULL, 0);
d245 2
a246 3
	return ap_proxy_ftp_handler(r, cr, url);
    else
	return NOT_IMPLEMENTED;
d253 1
a253 1
     create_proxy_config(pool *p, server_rec *s)
d255 7
a261 1
    proxy_server_conf *ps = ap_pcalloc(p, sizeof(proxy_server_conf));
d263 9
a271 21
    ps->proxies = ap_make_array(p, 10, sizeof(struct proxy_remote));
    ps->aliases = ap_make_array(p, 10, sizeof(struct proxy_alias));
    ps->raliases = ap_make_array(p, 10, sizeof(struct proxy_alias));
    ps->noproxies = ap_make_array(p, 10, sizeof(struct noproxy_entry));
    ps->dirconn = ap_make_array(p, 10, sizeof(struct dirconn_entry));
    ps->nocaches = ap_make_array(p, 10, sizeof(struct nocache_entry));
    ps->allowed_connect_ports = ap_make_array(p, 10, sizeof(int));
    ps->domain = NULL;
    ps->viaopt = via_off; /* initially backward compatible with 1.3.1 */
    ps->req = 0;

    ps->cache.root = NULL;
    ps->cache.space = DEFAULT_CACHE_SPACE;
    ps->cache.maxexpire = DEFAULT_CACHE_MAXEXPIRE;
    ps->cache.defaultexpire = DEFAULT_CACHE_EXPIRE;
    ps->cache.lmfactor = DEFAULT_CACHE_LMFACTOR;
    ps->cache.gcinterval = -1;
    /* at these levels, the cache can have 2^18 directories (256,000)  */
    ps->cache.dirlevels = 3;
    ps->cache.dirlength = 1;
    ps->cache.cache_completion = DEFAULT_CACHE_COMPLETION;
d273 1
a273 1
    return ps;
d277 1
a277 1
     add_proxy(cmd_parms *cmd, void *dummy, char *f, char *r)
d281 1
a281 1
    (proxy_server_conf *) ap_get_module_config(s->module_config, &proxy_module);
d288 1
a288 1
	return "ProxyRemote: Bad syntax for a remote proxy server";
d290 4
a293 3
    if (q != NULL) {
	if (sscanf(q + 1, "%u", &port) != 1 || port > 65535)
	    return "ProxyRemote: Bad syntax for a remote proxy server (bad port number)";
d295 1
a295 3
    }
    else
	port = -1;
d297 2
a298 3
    if (strchr(f, ':') == NULL)
	ap_str_tolower(f);		/* lowercase scheme */
    ap_str_tolower(p + 3);		/* lowercase hostname */
d300 2
a301 1
    if (port == -1) {
d303 2
a304 3
	for (i = 0; defports[i].scheme != NULL; i++)
	    if (strcasecmp(defports[i].scheme, r) == 0)
		break;
d308 1
a308 1
    new = ap_push_array(conf->proxies);
d317 1
a317 1
     add_pass(cmd_parms *cmd, void *dummy, char *f, char *r)
d321 1
a321 1
    (proxy_server_conf *) ap_get_module_config(s->module_config, &proxy_module);
d324 1
a324 1
    new = ap_push_array(conf->aliases);
d331 1
a331 16
    add_pass_reverse(cmd_parms *cmd, void *dummy, char *f, char *r)
{
    server_rec *s = cmd->server;
    proxy_server_conf *conf;
    struct proxy_alias *new;

    conf = (proxy_server_conf *)ap_get_module_config(s->module_config, 
                                                  &proxy_module);
    new = ap_push_array(conf->raliases);
    new->fake = f;
    new->real = r;
    return NULL;
}

static const char *
     set_proxy_exclude(cmd_parms *parms, void *dummy, char *arg)
d335 1
a335 1
    ap_get_module_config(s->module_config, &proxy_module);
d337 1
a337 1
    struct noproxy_entry *list = (struct noproxy_entry *) conf->noproxies->elts;
d343 3
a345 2
    for (i = 0; i < conf->noproxies->nelts; i++) {
	if (strcasecmp(arg, list[i].name) == 0) /* ignore case for host names */
d349 3
a351 2
    if (!found) {
	new = ap_push_array(conf->noproxies);
d354 1
a354 2
	if (strchr(arg, '.') != NULL && ap_proxy_host2addr(new->name, &hp) == NULL)
	    /*@@@@@@FIXME: This copies only the first of (possibly many) IP addrs */
a361 72
/*
 * Set the ports CONNECT can use
 */
static const char *
    set_allowed_ports(cmd_parms *parms, void *dummy, char *arg)
{
    server_rec *s = parms->server;
    proxy_server_conf *conf =
      ap_get_module_config(s->module_config, &proxy_module);
    int *New;

    if (!isdigit(arg[0]))
	return "AllowCONNECT: port number must be numeric";

    New = ap_push_array(conf->allowed_connect_ports);
    *New = atoi(arg);
    return NULL;
}

/* Similar to set_proxy_exclude(), but defining directly connected hosts,
 * which should never be accessed via the configured ProxyRemote servers
 */
static const char *
     set_proxy_dirconn(cmd_parms *parms, void *dummy, char *arg)
{
    server_rec *s = parms->server;
    proxy_server_conf *conf =
    ap_get_module_config(s->module_config, &proxy_module);
    struct dirconn_entry *New;
    struct dirconn_entry *list = (struct dirconn_entry *) conf->dirconn->elts;
    int found = 0;
    int i;

    /* Don't duplicate entries */
    for (i = 0; i < conf->dirconn->nelts; i++) {
	if (strcasecmp(arg, list[i].name) == 0)
	    found = 1;
    }

    if (!found) {
	New = ap_push_array(conf->dirconn);
	New->name = arg;
	New->hostentry = NULL;

	if (ap_proxy_is_ipaddr(New, parms->pool)) {
#if DEBUGGING
	    fprintf(stderr, "Parsed addr %s\n", inet_ntoa(New->addr));
	    fprintf(stderr, "Parsed mask %s\n", inet_ntoa(New->mask));
#endif
	}
	else if (ap_proxy_is_domainname(New, parms->pool)) {
	    ap_str_tolower(New->name);
#if DEBUGGING
	    fprintf(stderr, "Parsed domain %s\n", New->name);
#endif
	}
	else if (ap_proxy_is_hostname(New, parms->pool)) {
	    ap_str_tolower(New->name);
#if DEBUGGING
	    fprintf(stderr, "Parsed host %s\n", New->name);
#endif
	}
	else {
	    ap_proxy_is_word(New, parms->pool);
#if DEBUGGING
	    fprintf(stderr, "Parsed word %s\n", New->name);
#endif
	}
    }
    return NULL;
}

d363 1
a363 1
     set_proxy_domain(cmd_parms *parms, void *dummy, char *arg)
d366 1
a366 14
    ap_get_module_config(parms->server->module_config, &proxy_module);

    if (arg[0] != '.')
	return "ProxyDomain: domain name must start with a dot.";

    psf->domain = arg;
    return NULL;
}

static const char *
     set_proxy_req(cmd_parms *parms, void *dummy, int flag)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
d374 1
a374 1
     set_cache_size(cmd_parms *parms, char *struct_ptr, char *arg)
d377 1
a377 1
    ap_get_module_config(parms->server->module_config, &proxy_module);
d380 1
a380 2
    if (sscanf(arg, "%d", &val) != 1)
	return "CacheSize value must be an integer (kBytes)";
d386 1
a386 1
     set_cache_root(cmd_parms *parms, void *dummy, char *arg)
d389 1
a389 1
    ap_get_module_config(parms->server->module_config, &proxy_module);
d397 1
a397 1
     set_cache_factor(cmd_parms *parms, void *dummy, char *arg)
d400 1
a400 1
    ap_get_module_config(parms->server->module_config, &proxy_module);
d403 1
a403 2
    if (sscanf(arg, "%lg", &val) != 1)
	return "CacheLastModifiedFactor value must be a float";
d410 1
a410 1
     set_cache_maxex(cmd_parms *parms, void *dummy, char *arg)
d413 1
a413 1
    ap_get_module_config(parms->server->module_config, &proxy_module);
d416 2
a417 3
    if (sscanf(arg, "%lg", &val) != 1)
	return "CacheMaxExpire value must be a float";
    psf->cache.maxexpire = (int) (val * (double) SEC_ONE_HR);
d422 1
a422 1
     set_cache_defex(cmd_parms *parms, void *dummy, char *arg)
d425 1
a425 1
    ap_get_module_config(parms->server->module_config, &proxy_module);
d428 2
a429 3
    if (sscanf(arg, "%lg", &val) != 1)
	return "CacheDefaultExpire value must be a float";
    psf->cache.defaultexpire = (int) (val * (double) SEC_ONE_HR);
d434 1
a434 1
     set_cache_gcint(cmd_parms *parms, void *dummy, char *arg)
d437 1
a437 1
    ap_get_module_config(parms->server->module_config, &proxy_module);
d440 2
a441 3
    if (sscanf(arg, "%lg", &val) != 1)
	return "CacheGcInterval value must be a float";
    psf->cache.gcinterval = (int) (val * (double) SEC_ONE_HR);
d446 1
a446 1
     set_cache_dirlevels(cmd_parms *parms, char *struct_ptr, char *arg)
d449 1
a449 1
    ap_get_module_config(parms->server->module_config, &proxy_module);
d452 1
a452 5
    val = atoi(arg);
    if (val < 1)
	return "CacheDirLevels value must be an integer greater than 0";
    if (val * psf->cache.dirlength > CACHEFILE_LEN)
	return "CacheDirLevels*CacheDirLength value must not be higher than 20";
d458 1
a458 1
     set_cache_dirlength(cmd_parms *parms, char *struct_ptr, char *arg)
d461 1
a461 1
    ap_get_module_config(parms->server->module_config, &proxy_module);
d464 1
a464 5
    val = atoi(arg);
    if (val < 1)
	return "CacheDirLength value must be an integer greater than 0";
    if (val * psf->cache.dirlevels > CACHEFILE_LEN)
	return "CacheDirLevels*CacheDirLength value must not be higher than 20";
d470 1
a470 1
     set_cache_exclude(cmd_parms *parms, void *dummy, char *arg)
d474 1
a474 1
    ap_get_module_config(s->module_config, &proxy_module);
d476 1
a476 1
    struct nocache_entry *list = (struct nocache_entry *) conf->nocaches->elts;
d482 3
a484 2
    for (i = 0; i < conf->nocaches->nelts; i++) {
	if (strcasecmp(arg, list[i].name) == 0) /* ignore case for host names */
d488 3
a490 2
    if (!found) {
	new = ap_push_array(conf->nocaches);
d493 1
a493 2
	if (strchr(arg, '.') != NULL && ap_proxy_host2addr(new->name, &hp) == NULL)
	    /*@@@@@@FIXME: This copies only the first of (possibly many) IP addrs */
d496 1
a496 13
	    new->addr.s_addr = 0;
    }
    return NULL;
}

static const char *
     set_recv_buffer_size(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    int s = atoi(arg);
    if (s < 512 && s != 0) {
	return "ProxyReceiveBufferSize must be >= 512 bytes, or 0 for system default.";
a497 2

    psf->recv_buffer_size = s;
d501 33
a533 42
static const char*
    set_cache_completion(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    int s = atoi(arg);
    if (s > 100 || s < 0) {
	return "CacheForceCompletion must be <= 100 percent, "
               "or 0 for system default.";
    }

    if (s > 0)
      psf->cache.cache_completion = ((float)s / 100);
    return NULL;    
}

static const char*
    set_via_opt(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);

    if (strcasecmp(arg, "Off") == 0)
        psf->viaopt = via_off;
    else if (strcasecmp(arg, "On") == 0)
        psf->viaopt = via_on;
    else if (strcasecmp(arg, "Block") == 0)
        psf->viaopt = via_block;
    else if (strcasecmp(arg, "Full") == 0)
        psf->viaopt = via_full;
    else {
	return "ProxyVia must be one of: "
               "off | on | full | block";
    }

    return NULL;    
}

static const handler_rec proxy_handlers[] =
{
    {"proxy-server", proxy_handler},
    {NULL}
d536 17
a552 43
static const command_rec proxy_cmds[] =
{
    {"ProxyRequests", set_proxy_req, NULL, RSRC_CONF, FLAG,
     "on if the true proxy requests should be accepted"},
    {"ProxyRemote", add_proxy, NULL, RSRC_CONF, TAKE2,
     "a scheme, partial URL or '*' and a proxy server"},
    {"ProxyPass", add_pass, NULL, RSRC_CONF, TAKE2,
     "a virtual path and a URL"},
    {"ProxyPassReverse", add_pass_reverse, NULL, RSRC_CONF, TAKE2,
     "a virtual path and a URL for reverse proxy behaviour"},
    {"ProxyBlock", set_proxy_exclude, NULL, RSRC_CONF, ITERATE,
     "A list of names, hosts or domains to which the proxy will not connect"},
    {"ProxyReceiveBufferSize", set_recv_buffer_size, NULL, RSRC_CONF, TAKE1,
     "Receive buffer size for outgoing HTTP and FTP connections in bytes"},
    {"NoProxy", set_proxy_dirconn, NULL, RSRC_CONF, ITERATE,
     "A list of domains, hosts, or subnets to which the proxy will connect directly"},
    {"ProxyDomain", set_proxy_domain, NULL, RSRC_CONF, TAKE1,
     "The default intranet domain name (in absence of a domain in the URL)"},
    {"AllowCONNECT", set_allowed_ports, NULL, RSRC_CONF, ITERATE,
     "A list of ports which CONNECT may connect to"},
    {"CacheRoot", set_cache_root, NULL, RSRC_CONF, TAKE1,
     "The directory to store cache files"},
    {"CacheSize", set_cache_size, NULL, RSRC_CONF, TAKE1,
     "The maximum disk space used by the cache in Kb"},
    {"CacheMaxExpire", set_cache_maxex, NULL, RSRC_CONF, TAKE1,
     "The maximum time in hours to cache a document"},
    {"CacheDefaultExpire", set_cache_defex, NULL, RSRC_CONF, TAKE1,
     "The default time in hours to cache a document"},
    {"CacheLastModifiedFactor", set_cache_factor, NULL, RSRC_CONF, TAKE1,
     "The factor used to estimate Expires date from LastModified date"},
    {"CacheGcInterval", set_cache_gcint, NULL, RSRC_CONF, TAKE1,
     "The interval between garbage collections, in hours"},
    {"CacheDirLevels", set_cache_dirlevels, NULL, RSRC_CONF, TAKE1,
     "The number of levels of subdirectories in the cache"},
    {"CacheDirLength", set_cache_dirlength, NULL, RSRC_CONF, TAKE1,
     "The number of characters in subdirectory names"},
    {"NoCache", set_cache_exclude, NULL, RSRC_CONF, ITERATE,
     "A list of names, hosts or domains for which caching is *not* provided"},
    {"CacheForceCompletion", set_cache_completion, NULL, RSRC_CONF, TAKE1,
     "Force a http cache completion after this percentage is loaded"},
    {"ProxyVia", set_via_opt, NULL, RSRC_CONF, TAKE1,
     "Configure Via: proxy header header to one of: on | off | block | full"},
    {NULL}
a554 22
module MODULE_VAR_EXPORT proxy_module =
{
    STANDARD_MODULE_STUFF,
    proxy_init,			/* initializer */
    NULL,			/* create per-directory config structure */
    NULL,			/* merge per-directory config structures */
    create_proxy_config,	/* create per-server config structure */
    NULL,			/* merge per-server config structures */
    proxy_cmds,			/* command table */
    proxy_handlers,		/* handlers */
    proxy_trans,		/* translate_handler */
    NULL,			/* check_user_id */
    NULL,			/* check auth */
    NULL,			/* check access */
    NULL,			/* type_checker */
    proxy_fixup,		/* pre-run fixups */
    NULL,			/* logger */
    NULL,			/* header parser */
    NULL,			/* child_init */
    NULL,			/* child_exit */
    proxy_detect		/* post read-request */
};
@


1.1.1.3
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 23
a38 20
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 6
a55 7
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
d78 1
a78 1
    {NULL, -1}                  /* unknown port */
d100 17
a116 18
        if (*aliasp == '/') {
            /*
             * any number of '/' in the alias matches any number in the
             * supplied URI, but there must be at least one...
             */
            if (*urip != '/')
                return 0;

            while (*aliasp == '/')
                ++aliasp;
            while (*urip == '/')
                ++urip;
        }
        else {
            /* Other characters are compared literally */
            if (*urip++ != *aliasp++)
                return 0;
        }
d122 1
a122 1
        return 0;
d124 3
a126 3
    /*
     * Return number of characters from URI which matched (may be greater
     * than length of alias, since we may have matched doubled slashes)
d148 1
a148 1
    conf = (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
d151 9
a159 9
        /* but it might be something vhosted */
        if (!(r->parsed_uri.hostname
              && !strcasecmp(r->parsed_uri.scheme, ap_http_method(r))
              && ap_matches_request_vhost(r, r->parsed_uri.hostname,
        r->parsed_uri.port_str ? r->parsed_uri.port : ap_default_port(r)))) {
            r->proxyreq = STD_PROXY;
            r->uri = r->unparsed_uri;
            r->filename = ap_pstrcat(r->pool, "proxy:", r->uri, NULL);
            r->handler = "proxy-server";
d164 6
a169 6
             && r->parsed_uri.hostname
             && r->parsed_uri.port_str) {
        r->proxyreq = STD_PROXY;
        r->uri = r->unparsed_uri;
        r->filename = ap_pstrcat(r->pool, "proxy:", r->uri, NULL);
        r->handler = "proxy-server";
d178 1
a178 1
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
d180 1
a180 1
    struct proxy_alias *ent = (struct proxy_alias *)conf->aliases->elts;
d182 5
a186 6
    if (r->proxyreq != NOT_PROXY) {
        /*
         * someone has already set up the proxy, it was possibly ourselves in
         * proxy_detect
         */
        return OK;
d189 3
a191 4
    /*
     * XXX: since r->uri has been manipulated already we're not really
     * compliant with RFC1945 at this point.  But this probably isn't an
     * issue because this is a hybrid proxy/origin server.
d196 8
a203 8

        if (len > 0) {
            r->filename = ap_pstrcat(r->pool, "proxy:", ent[i].real,
                                     r->uri + len, NULL);
            r->handler = "proxy-server";
            r->proxyreq = PROXY_PASS;
            return OK;
        }
d218 2
a219 2
    if (r->proxyreq == NOT_PROXY || strncmp(r->filename, "proxy:", 6) != 0)
        return DECLINED;
d225 1
a225 1
        return ap_proxy_http_canon(r, url + 5, "http", DEFAULT_HTTP_PORT);
d227 1
a227 1
        return ap_proxy_ftp_canon(r, url + 4);
d231 1
a231 1
        return HTTP_BAD_REQUEST;
d233 1
a233 1
    return OK;                  /* otherwise; we've done the best we can */
d255 2
a256 2
    if (r->proxyreq == NOT_PROXY || r->method_number != M_GET || !r->parsed_uri.hostname)
        return DECLINED;
d260 2
a261 2
        || strcasecmp(r->parsed_uri.hostname, "localhost") == 0)
        return DECLINED;        /* host name has a dot already */
d268 1
a268 1
                                        domain, NULL);
d270 2
a271 2
                                     &r->parsed_uri,
                                     UNP_REVEALPASSWORD);
d274 5
a278 5
    ap_log_rerror(APLOG_MARK, APLOG_INFO | APLOG_NOERRNO, r,
                  "Domain missing: %s sent to %s%s%s", r->uri,
                  ap_unparse_uri_components(r->pool, &r->parsed_uri,
                                            UNP_OMITUSERINFO),
                  ref ? " from " : "", ref ? ref : "");
d291 1
a291 1
    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
d299 2
a300 2
    if (r->proxyreq == NOT_PROXY || strncmp(r->filename, "proxy:", 6) != 0)
        return DECLINED;
d303 13
a315 13
        (maxfwd_str = ap_table_get(r->headers_in, "Max-Forwards")) != NULL) {
        long maxfwd = ap_strtol(maxfwd_str, NULL, 10);
        if (maxfwd < 1) {
            int access_status;
            r->proxyreq = NOT_PROXY;
            if ((access_status = ap_send_http_trace(r)))
                ap_die(access_status, r);
            else
                ap_finalize_request_protocol(r);
            return OK;
        }
        ap_table_setn(r->headers_in, "Max-Forwards",
                ap_psprintf(r->pool, "%ld", (maxfwd > 0) ? maxfwd - 1 : 0));
d319 1
a319 1
        return rc;
d324 1
a324 1
        return HTTP_BAD_REQUEST;
a325 1
    /* Try serve the request from the cache. If we succeed, we leave. */
d328 1
a328 1
        return rc;
d332 3
a334 3
        rc = proxy_needsdomain(r, url, conf->domain);
        if (ap_is_HTTP_REDIRECT(rc))
            return HTTP_MOVED_PERMANENTLY;
d344 1
a344 1
    /* if (strcasecmp(scheme, "http") == 0) */
d346 2
a347 2
        int ii;
        struct dirconn_entry *list = (struct dirconn_entry *)conf->dirconn->elts;
d349 3
a351 3
        for (direct_connect = ii = 0; ii < conf->dirconn->nelts && !direct_connect; ii++) {
            direct_connect = list[ii].matcher(&list[ii], r);
        }
d353 3
a355 3
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r,
                    (direct_connect) ? "NoProxy for %s" : "UseProxy for %s",
                      r->uri);
d362 12
a373 13
        for (i = 0; i < proxies->nelts; i++) {
            p = strchr(ents[i].scheme, ':');    /* is it a partial URL? */
            if (strcmp(ents[i].scheme, "*") == 0 ||
                (p == NULL && strcasecmp(scheme, ents[i].scheme) == 0) ||
                (p != NULL &&
            strncasecmp(url, ents[i].scheme, strlen(ents[i].scheme)) == 0)) {
                /*
                 * CONNECT is a special method that bypasses the normal proxy
                 * code.
                 */
                if (r->method_number == M_CONNECT)
                    rc = ap_proxy_connect_handler(r, cr, url, ents[i].hostname,
                                                  ents[i].port);
d375 17
a391 18
                else if (strcasecmp(ents[i].protocol, "http") == 0)
                    rc = ap_proxy_http_handler(r, cr, url, ents[i].hostname,
                                               ents[i].port);
                else
                    rc = DECLINED;

                /* an error or success */
                if (rc != DECLINED && rc != HTTP_BAD_GATEWAY)
                    return rc;
                /* we failed to talk to the upstream proxy */
            }
        }

    /* otherwise, try it direct */
    /* N.B. what if we're behind a firewall, where we must use a proxy or
     * give up??
     */

d393 8
a400 17
    if (r->method_number == M_CONNECT) {
        return ap_proxy_connect_handler(r, cr, url, NULL, 0);
    }
    if (strcasecmp(scheme, "http") == 0) {
        return ap_proxy_http_handler(r, cr, url, NULL, 0);
    }
    if (strcasecmp(scheme, "ftp") == 0) {
        return ap_proxy_ftp_handler(r, cr, url);
    }
    else {
        ap_log_rerror(APLOG_MARK, APLOG_WARNING | APLOG_NOERRNO, r,
                    "proxy: No protocol handler was valid for the URL %s. "
                    "If you are using a DSO version of mod_proxy, make sure "
                    "the proxy submodules are included in the configuration "
                    "using LoadModule.", r->uri);
        return HTTP_FORBIDDEN;
    }
d419 1
a419 2
    ps->viaopt = via_off;       /* initially backward compatible with 1.3.1 */
    ps->viaopt_set = 0;         /* 0 means default */
a420 6
    ps->req_set = 0;
    ps->recv_buffer_size = 0;   /* this default was left unset for some
                                 * reason */
    ps->recv_buffer_size_set = 0;
    ps->io_buffer_size = IOBUFSIZE;
    ps->io_buffer_size_set = 0;
a423 1
    ps->cache.space_set = 0;
a424 1
    ps->cache.maxexpire_set = 0;
a425 1
    ps->cache.defaultexpire_set = 0;
d427 1
a427 3
    ps->cache.lmfactor_set = 0;
    ps->cache.gcinterval = DEFAULT_CACHE_GCINTERVAL;
    ps->cache.gcinterval_set = 1;
a429 1
    ps->cache.dirlevels_set = 0;
d431 1
a431 39
    ps->cache.dirlength_set = 0;
    ps->cache.cache_completion = (float)DEFAULT_CACHE_COMPLETION;
    ps->cache.cache_completion_set = 0;

    return ps;
}

static void *
     merge_proxy_config(pool *p, void *basev,
                             void *overridesv)
{
    proxy_server_conf *ps = ap_pcalloc(p, sizeof(proxy_server_conf));
    proxy_server_conf *base = (proxy_server_conf *)basev;
    proxy_server_conf *overrides = (proxy_server_conf *)overridesv;

    ps->proxies = ap_append_arrays(p, base->proxies, overrides->proxies);
    ps->aliases = ap_append_arrays(p, base->aliases, overrides->aliases);
    ps->raliases = ap_append_arrays(p, base->raliases, overrides->raliases);
    ps->noproxies = ap_append_arrays(p, base->noproxies, overrides->noproxies);
    ps->dirconn = ap_append_arrays(p, base->dirconn, overrides->dirconn);
    ps->nocaches = ap_append_arrays(p, base->nocaches, overrides->nocaches);
    ps->allowed_connect_ports = ap_append_arrays(p, base->allowed_connect_ports, overrides->allowed_connect_ports);

    ps->domain = (overrides->domain == NULL) ? base->domain : overrides->domain;
    ps->viaopt = (overrides->viaopt_set == 0) ? base->viaopt : overrides->viaopt;
    ps->req = (overrides->req_set == 0) ? base->req : overrides->req;
    ps->recv_buffer_size = (overrides->recv_buffer_size_set == 0) ? base->recv_buffer_size : overrides->recv_buffer_size;
    ps->io_buffer_size = (overrides->io_buffer_size_set == 0) ? base->io_buffer_size : overrides->io_buffer_size;

    ps->cache.root = (overrides->cache.root == NULL) ? base->cache.root : overrides->cache.root;
    ps->cache.space = (overrides->cache.space_set == 0) ? base->cache.space : overrides->cache.space;
    ps->cache.maxexpire = (overrides->cache.maxexpire_set == 0) ? base->cache.maxexpire : overrides->cache.maxexpire;
    ps->cache.defaultexpire = (overrides->cache.defaultexpire_set == 0) ? base->cache.defaultexpire : overrides->cache.defaultexpire;
    ps->cache.lmfactor = (overrides->cache.lmfactor_set == 0) ? base->cache.lmfactor : overrides->cache.lmfactor;
    ps->cache.gcinterval = (overrides->cache.gcinterval_set == 0) ? base->cache.gcinterval : overrides->cache.gcinterval;
    /* at these levels, the cache can have 2^18 directories (256,000)  */
    ps->cache.dirlevels = (overrides->cache.dirlevels_set == 0) ? base->cache.dirlevels : overrides->cache.dirlevels;
    ps->cache.dirlength = (overrides->cache.dirlength_set == 0) ? base->cache.dirlength : overrides->cache.dirlength;
    ps->cache.cache_completion = (overrides->cache.cache_completion_set == 0) ? base->cache.cache_completion : overrides->cache.cache_completion;
d441 1
a441 1
    (proxy_server_conf *)ap_get_module_config(s->module_config, &proxy_module);
d448 1
a448 1
        return "ProxyRemote: Bad syntax for a remote proxy server";
d451 3
a453 3
        if (sscanf(q + 1, "%u", &port) != 1 || port > 65535)
            return "ProxyRemote: Bad syntax for a remote proxy server (bad port number)";
        *q = '\0';
d456 1
a456 1
        port = -1;
d459 2
a460 2
        ap_str_tolower(f);      /* lowercase scheme */
    ap_str_tolower(p + 3);      /* lowercase hostname */
d463 5
a467 5
        int i;
        for (i = 0; defports[i].scheme != NULL; i++)
            if (strcasecmp(defports[i].scheme, r) == 0)
                break;
        port = defports[i].port;
d483 1
a483 1
    (proxy_server_conf *)ap_get_module_config(s->module_config, &proxy_module);
d493 1
a493 1
     add_pass_reverse(cmd_parms *cmd, void *dummy, char *f, char *r)
d499 2
a500 2
    conf = (proxy_server_conf *)ap_get_module_config(s->module_config,
                                                     &proxy_module);
d521 2
a522 2
        if (strcasecmp(arg, list[i].name) == 0) /* ignore case for host names */
            found = 1;
d526 8
a533 11
        new = ap_push_array(conf->noproxies);
        new->name = arg;
        /* Don't do name lookups on things that aren't dotted */
        if (strchr(arg, '.') != NULL && ap_proxy_host2addr(new->name, &hp) == NULL)
            /*
             * @@@@@@FIXME: This copies only the first of (possibly many) IP
             * addrs
             */
            memcpy(&new->addr, hp.h_addr, sizeof(struct in_addr));
        else
            new->addr.s_addr = 0;
d542 1
a542 1
     set_allowed_ports(cmd_parms *parms, void *dummy, char *arg)
d546 1
a546 1
    ap_get_module_config(s->module_config, &proxy_module);
d549 2
a550 2
    if (!ap_isdigit(arg[0]))
        return "AllowCONNECT: port number must be numeric";
d567 1
a567 1
    struct dirconn_entry *list = (struct dirconn_entry *)conf->dirconn->elts;
d573 2
a574 2
        if (strcasecmp(arg, list[i].name) == 0)
            found = 1;
d578 3
a580 3
        New = ap_push_array(conf->dirconn);
        New->name = arg;
        New->hostentry = NULL;
d582 1
a582 1
        if (ap_proxy_is_ipaddr(New, parms->pool)) {
d584 2
a585 2
            fprintf(stderr, "Parsed addr %s\n", inet_ntoa(New->addr));
            fprintf(stderr, "Parsed mask %s\n", inet_ntoa(New->mask));
d587 3
a589 3
        }
        else if (ap_proxy_is_domainname(New, parms->pool)) {
            ap_str_tolower(New->name);
d591 1
a591 1
            fprintf(stderr, "Parsed domain %s\n", New->name);
d593 3
a595 3
        }
        else if (ap_proxy_is_hostname(New, parms->pool)) {
            ap_str_tolower(New->name);
d597 1
a597 1
            fprintf(stderr, "Parsed host %s\n", New->name);
d599 3
a601 3
        }
        else {
            ap_proxy_is_word(New, parms->pool);
d603 1
a603 1
            fprintf(stderr, "Parsed word %s\n", New->name);
d605 1
a605 1
        }
d617 1
a617 1
        return "ProxyDomain: domain name must start with a dot.";
a629 1
    psf->req_set = 1;
d642 1
a642 1
        return "CacheSize value must be an integer (kBytes)";
a643 1
    psf->cache.space_set = 1;
d666 1
a666 1
        return "CacheLastModifiedFactor value must be a float";
a667 1
    psf->cache.lmfactor_set = 1;
d680 2
a681 3
        return "CacheMaxExpire value must be a float";
    psf->cache.maxexpire = (int)(val * (double)SEC_ONE_HR);
    psf->cache.maxexpire_set = 1;
d693 2
a694 3
        return "CacheDefaultExpire value must be a float";
    psf->cache.defaultexpire = (int)(val * (double)SEC_ONE_HR);
    psf->cache.defaultexpire_set = 1;
d706 2
a707 3
        return "CacheGcInterval value must be a float";
    psf->cache.gcinterval = (int)(val * (double)SEC_ONE_HR);
    psf->cache.gcinterval_set = 1;
d720 1
a720 1
        return "CacheDirLevels value must be an integer greater than 0";
d722 1
a722 1
        return "CacheDirLevels*CacheDirLength value must not be higher than 20";
a723 1
    psf->cache.dirlevels_set = 1;
d736 1
a736 1
        return "CacheDirLength value must be an integer greater than 0";
d738 1
a738 1
        return "CacheDirLevels*CacheDirLength value must not be higher than 20";
a739 1
    psf->cache.dirlength_set = 1;
d757 2
a758 2
        if (strcasecmp(arg, list[i].name) == 0) /* ignore case for host names */
            found = 1;
d762 8
a769 11
        new = ap_push_array(conf->nocaches);
        new->name = arg;
        /* Don't do name lookups on things that aren't dotted */
        if (strchr(arg, '.') != NULL && ap_proxy_host2addr(new->name, &hp) == NULL)
            /*
             * @@@@@@FIXME: This copies only the first of (possibly many) IP
             * addrs
             */
            memcpy(&new->addr, hp.h_addr, sizeof(struct in_addr));
        else
            new->addr.s_addr = 0;
d781 1
a781 1
        return "ProxyReceiveBufferSize must be >= 512 bytes, or 0 for system default.";
a784 1
    psf->recv_buffer_size_set = 1;
d788 2
a789 14
static const char *
     set_io_buffer_size(cmd_parms *parms, void *dummy, char *arg)
{
    proxy_server_conf *psf =
    ap_get_module_config(parms->server->module_config, &proxy_module);
    long s = atol(arg);

    psf->io_buffer_size = ((s > IOBUFSIZE) ? s : IOBUFSIZE);
    psf->io_buffer_size_set = 1;
    return NULL;
}

static const char *
     set_cache_completion(cmd_parms *parms, void *dummy, char *arg)
d795 2
a796 2
        return "CacheForceCompletion must be <= 100 percent, "
            "or 0 for system default.";
d800 2
a801 4
        psf->cache.cache_completion = ((float)s / 100);

    psf->cache.cache_completion_set = 1;
    return NULL;
d804 2
a805 2
static const char *
     set_via_opt(cmd_parms *parms, void *dummy, char *arg)
d819 2
a820 2
        return "ProxyVia must be one of: "
            "off | on | full | block";
d823 1
a823 2
    psf->viaopt_set = 1;
    return NULL;
d835 1
a835 1
    "on if the true proxy requests should be accepted"},
d837 1
a837 1
    "a scheme, partial URL or '*' and a proxy server"},
d839 1
a839 1
    "a virtual path and a URL"},
d841 1
a841 1
    "a virtual path and a URL for reverse proxy behaviour"},
d843 1
a843 1
    "A list of names, hosts or domains to which the proxy will not connect"},
d845 1
a845 3
    "Receive buffer size for outgoing HTTP and FTP connections in bytes"},
    {"ProxyIOBufferSize", set_io_buffer_size, NULL, RSRC_CONF, TAKE1,
    "IO buffer size for outgoing HTTP and FTP connections in bytes"},
d847 1
a847 1
    "A list of domains, hosts, or subnets to which the proxy will connect directly"},
d849 1
a849 1
    "The default intranet domain name (in absence of a domain in the URL)"},
d851 1
a851 1
    "A list of ports which CONNECT may connect to"},
d853 1
a853 1
    "The directory to store cache files"},
d855 1
a855 1
    "The maximum disk space used by the cache in Kb"},
d857 1
a857 1
    "The maximum time in hours to cache a document"},
d859 1
a859 1
    "The default time in hours to cache a document"},
d861 1
a861 1
    "The factor used to estimate Expires date from LastModified date"},
d863 1
a863 1
    "The interval between garbage collections, in hours"},
d865 1
a865 1
    "The number of levels of subdirectories in the cache"},
d867 1
a867 1
    "The number of characters in subdirectory names"},
d869 1
a869 1
    "A list of names, hosts or domains for which caching is *not* provided"},
d871 1
a871 1
    "Force a http cache completion after this percentage is loaded"},
d873 1
a873 1
    "Configure Via: proxy header header to one of: on | off | block | full"},
d880 18
a897 18
    proxy_init,                 /* initializer */
    NULL,                       /* create per-directory config structure */
    NULL,                       /* merge per-directory config structures */
    create_proxy_config,        /* create per-server config structure */
    merge_proxy_config,         /* merge per-server config structures */
    proxy_cmds,                 /* command table */
    proxy_handlers,             /* handlers */
    proxy_trans,                /* translate_handler */
    NULL,                       /* check_user_id */
    NULL,                       /* check auth */
    NULL,                       /* check access */
    NULL,                       /* type_checker */
    proxy_fixup,                /* pre-run fixups */
    NULL,                       /* logger */
    NULL,                       /* header parser */
    NULL,                       /* child_init */
    NULL,                       /* child_exit */
    proxy_detect                /* post read-request */
@


1.1.1.4
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@a220 3
#ifdef EAPI
    int rc;
#endif /* EAPI */
a227 8
#ifdef EAPI
    if (ap_hook_use("ap::mod_proxy::canon",
                    AP_HOOK_SIG3(int,ptr,ptr),
                    AP_HOOK_DECLINE(DECLINED),
                    &rc, r, url) && rc != DECLINED)
        return rc;  
    else
#endif /* EAPI */
a242 4
#ifdef EAPI
    ap_hook_use("ap::mod_proxy::init", 
                AP_HOOK_SIG3(void,ptr,ptr), AP_HOOK_ALL, r, p);
#endif
d245 1
a245 32
#ifdef EAPI
static void proxy_addmod(module *m)
{
    /* export: ap_proxy_http_canon() as `ap::mod_proxy::http::canon' */
    ap_hook_configure("ap::mod_proxy::http::canon", 
                      AP_HOOK_SIG5(int,ptr,ptr,ptr,int), AP_HOOK_TOPMOST);
    ap_hook_register("ap::mod_proxy::http::canon", 
                     ap_proxy_http_canon, AP_HOOK_NOCTX);

    /* export: ap_proxy_http_handler() as `ap::mod_proxy::http::handler' */
    ap_hook_configure("ap::mod_proxy::http::handler", 
                      AP_HOOK_SIG6(int,ptr,ptr,ptr,ptr,int), AP_HOOK_TOPMOST);
    ap_hook_register("ap::mod_proxy::http::handler", 
                     ap_proxy_http_handler, AP_HOOK_NOCTX);

    /* export: ap_proxyerror() as `ap::mod_proxy::error' */
    ap_hook_configure("ap::mod_proxy::error", 
                      AP_HOOK_SIG3(int,ptr,ptr), AP_HOOK_TOPMOST);
    ap_hook_register("ap::mod_proxy::error", 
                     ap_proxyerror, AP_HOOK_NOCTX);
    return;
}

static void proxy_remmod(module *m)
{
	/* remove the hook references */
    ap_hook_unregister("ap::mod_proxy::http::canon", ap_proxy_http_canon);
    ap_hook_unregister("ap::mod_proxy::http::handler", ap_proxy_http_handler);
    ap_hook_unregister("ap::mod_proxy::error", ap_proxyerror);
    return;
}
#endif /* EAPI */
a376 8
#ifdef EAPI
		if (!ap_hook_use("ap::mod_proxy::handler",
				 AP_HOOK_SIG7(int,ptr,ptr,ptr,ptr,int,ptr),
				 AP_HOOK_DECLINE(DECLINED),
				 &rc, r, cr, url, 
				 ents[i].hostname, ents[i].port, 
				 ents[i].protocol) || rc == DECLINED) {
#endif /* EAPI */
a385 3
#ifdef EAPI
		}
#endif /* EAPI */
a399 8
#ifdef EAPI
    if (ap_hook_use("ap::mod_proxy::handler",
		    AP_HOOK_SIG7(int,ptr,ptr,ptr,ptr,int,ptr),
		    AP_HOOK_DECLINE(DECLINED),
		    &rc, r, cr, url, 
                    NULL, 0, scheme) && rc != DECLINED)
        return rc;
#endif /* EAPI */
a996 6
#ifdef EAPI
   ,proxy_addmod,		/* EAPI: add_module */
    proxy_remmod,		/* EAPI: remove_module */
    NULL,			/* EAPI: rewrite_command */
    NULL			/* EAPI: new_connection  */
#endif
@


1.1.1.5
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
@


