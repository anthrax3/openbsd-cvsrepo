head	1.15;
access;
symbols
	OPENBSD_5_5:1.14.0.26
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.22
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.20
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.18
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.16
	OPENBSD_5_0:1.14.0.14
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.12
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.10
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.6
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.8
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.12.0.18
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.16
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.14
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.12
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.10
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.8
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.3
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.2
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.1
	apache_1_3_27:1.1.1.1
	apache:1.1.1
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.14;

1.14
date	2008.07.04.14.39.37;	author mbalmer;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.09.08.06.28;	author mbalmer;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.17.18.57.06;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.21.13.11.36;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.01.15.53.41;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.29.02.08.06;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.29.10.21.46;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.22.18.18;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.15.13.11.21;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.30.05.35.10;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.19.11.17.22;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.25.18.29.54;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.06.29.46;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.03.01.04.28.53;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.07.19.48.14;	author henning;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.21.12.53.42;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.17.17.03.23;	author henning;	state Exp;
branches;
next	;


desc
@@


1.15
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*                      _             _
**  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
** | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
** | | | | | | (_) | (_| |   \__ \__ \ |  www.modssl.org
** |_| |_| |_|\___/ \__,_|___|___/___/_|  ftp.modssl.org
**                      |_____|
**  ssl_engine_ext.c
**  Extensions to other Apache parts
*/

/* ====================================================================
 * Copyright (c) 1998-2003 Ralf S. Engelschall. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials
 *    provided with the distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by
 *     Ralf S. Engelschall <rse@@engelschall.com> for use in the
 *     mod_ssl project (http://www.modssl.org/)."
 *
 * 4. The names "mod_ssl" must not be used to endorse or promote
 *    products derived from this software without prior written
 *    permission. For written permission, please contact
 *    rse@@engelschall.com.
 *
 * 5. Products derived from this software may not be called "mod_ssl"
 *    nor may "mod_ssl" appear in their names without prior
 *    written permission of Ralf S. Engelschall.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by
 *     Ralf S. Engelschall <rse@@engelschall.com> for use in the
 *     mod_ssl project (http://www.modssl.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY RALF S. ENGELSCHALL ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL RALF S. ENGELSCHALL OR
 * HIS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 */
                             /* ``Only those who attempt the absurd
                                  can achieve the impossible.''
                                           -- Unknown             */
#include "mod_ssl.h"


/*  _________________________________________________________________
**
**  SSL Extensions
**  _________________________________________________________________
*/

static void  ssl_ext_mlc_register(void);
static void  ssl_ext_mlc_unregister(void);
static void  ssl_ext_mr_register(void);
static void  ssl_ext_mr_unregister(void);
static void  ssl_ext_mp_register(void);
static void  ssl_ext_mp_unregister(void);
static void  ssl_ext_ms_register(void);
static void  ssl_ext_ms_unregister(void);

void ssl_ext_register(void)
{
    ssl_ext_mlc_register();
    ssl_ext_mr_register();
    ssl_ext_mp_register();
    ssl_ext_ms_register();
    return;
}

void ssl_ext_unregister(void)
{
    ssl_ext_mlc_unregister();
    ssl_ext_mr_unregister();
    ssl_ext_mp_unregister();
    ssl_ext_ms_unregister();
    return;
}

/*  _________________________________________________________________
**
**  SSL Extension to mod_log_config
**  _________________________________________________________________
*/

static char *ssl_ext_mlc_log_c(request_rec *r, char *a);
static char *ssl_ext_mlc_log_x(request_rec *r, char *a);

/*
 * register us for the mod_log_config function registering phase
 * to establish %{...}c and to be able to expand %{...}x variables.
 */
static void ssl_ext_mlc_register(void)
{
    ap_hook_register("ap::mod_log_config::log_c",
                     ssl_ext_mlc_log_c, AP_HOOK_NOCTX);
    ap_hook_register("ap::mod_log_config::log_x",
                     ssl_ext_mlc_log_x, AP_HOOK_NOCTX);
    return;
}

static void ssl_ext_mlc_unregister(void)
{
    ap_hook_unregister("ap::mod_log_config::log_c",
                       ssl_ext_mlc_log_c);
    ap_hook_unregister("ap::mod_log_config::log_x",
                       ssl_ext_mlc_log_x);
    return;
}

/*
 * implement the %{..}c log function
 * (we are the only function)
 */
static char *ssl_ext_mlc_log_c(request_rec *r, char *a)
{
    char *result;

    if (ap_ctx_get(r->connection->client->ctx, "ssl") == NULL)
        return NULL;
    result = NULL;
    if (strEQ(a, "version"))
        result = ssl_var_lookup(r->pool, r->server, r->connection, r, "SSL_PROTOCOL");
    else if (strEQ(a, "cipher"))
        result = ssl_var_lookup(r->pool, r->server, r->connection, r, "SSL_CIPHER");
    else if (strEQ(a, "subjectdn") || strEQ(a, "clientcert"))
        result = ssl_var_lookup(r->pool, r->server, r->connection, r, "SSL_CLIENT_S_DN");
    else if (strEQ(a, "issuerdn") || strEQ(a, "cacert"))
        result = ssl_var_lookup(r->pool, r->server, r->connection, r, "SSL_CLIENT_I_DN");
    else if (strEQ(a, "errcode"))
        result = "-";
    else if (strEQ(a, "errstr"))
        result = ap_ctx_get(r->connection->client->ctx, "ssl::verify::error");
    if (result != NULL && result[0] == NUL)
        result = NULL;
    return result;
}

/*
 * extend the implementation of the %{..}x log function
 * (there can be more functions)
 */
static char *ssl_ext_mlc_log_x(request_rec *r, char *a)
{
    char *result;

    result = NULL;
    if (ap_ctx_get(r->connection->client->ctx, "ssl") != NULL)
        result = ssl_var_lookup(r->pool, r->server, r->connection, r, a);
    if (result != NULL && result[0] == NUL)
        result = NULL;
    return result;
}

/*  _________________________________________________________________
**
**  SSL Extension to mod_rewrite
**  _________________________________________________________________
*/

static char *ssl_ext_mr_lookup_variable(request_rec *r, char *var);

/*
 * register us for the mod_rewrite lookup_variable() function
 */
static void ssl_ext_mr_register(void)
{
    ap_hook_register("ap::mod_rewrite::lookup_variable",
                     ssl_ext_mr_lookup_variable, AP_HOOK_NOCTX);
    return;
}

static void ssl_ext_mr_unregister(void)
{
    ap_hook_unregister("ap::mod_rewrite::lookup_variable",
                       ssl_ext_mr_lookup_variable);
    return;
}

static char *ssl_ext_mr_lookup_variable(request_rec *r, char *var)
{
    char *val;

    val = ssl_var_lookup(r->pool, r->server, r->connection, r, var);
    if (val[0] == NUL)
        val = NULL;
    return val;
}

/*  _________________________________________________________________
**
**  SSL Extension to mod_proxy
**  _________________________________________________________________
*/

static int   ssl_ext_mp_canon(request_rec *, char *);
static int   ssl_ext_mp_handler(request_rec *, void *, char *, char *, int, char *);
static int   ssl_ext_mp_set_destport(request_rec *);
static char *ssl_ext_mp_new_connection(request_rec *, BUFF *, char *);
static void  ssl_ext_mp_close_connection(void *);
static int   ssl_ext_mp_write_host_header(request_rec *, BUFF *, char *, char *, char *);
#ifdef SSL_EXPERIMENTAL_PROXY
static void  ssl_ext_mp_init(server_rec *, pool *);
static int   ssl_ext_mp_verify_cb(int, X509_STORE_CTX *);
static int   ssl_ext_mp_clientcert_cb(SSL *, X509 **, EVP_PKEY **);
#endif

/*
 * register us ...
 */
static void ssl_ext_mp_register(void)
{
#ifdef SSL_EXPERIMENTAL_PROXY
    ap_hook_register("ap::mod_proxy::init",
                     ssl_ext_mp_init, AP_HOOK_NOCTX);
#endif
    ap_hook_register("ap::mod_proxy::canon",
                     ssl_ext_mp_canon, AP_HOOK_NOCTX);
    ap_hook_register("ap::mod_proxy::handler",
                     ssl_ext_mp_handler, AP_HOOK_NOCTX);
    ap_hook_register("ap::mod_proxy::http::handler::set_destport",
                     ssl_ext_mp_set_destport, AP_HOOK_NOCTX);
    ap_hook_register("ap::mod_proxy::http::handler::new_connection",
                     ssl_ext_mp_new_connection, AP_HOOK_NOCTX);
    ap_hook_register("ap::mod_proxy::http::handler::write_host_header",
                     ssl_ext_mp_write_host_header, AP_HOOK_NOCTX);
    return;
}

static void ssl_ext_mp_unregister(void)
{
#ifdef SSL_EXPERIMENTAL_PROXY
    ap_hook_unregister("ap::mod_proxy::init", ssl_ext_mp_init);
#endif
    ap_hook_unregister("ap::mod_proxy::canon", ssl_ext_mp_canon);
    ap_hook_unregister("ap::mod_proxy::handler", ssl_ext_mp_handler);
    ap_hook_unregister("ap::mod_proxy::http::handler::set_destport",
                       ssl_ext_mp_set_destport);
    ap_hook_unregister("ap::mod_proxy::http::handler::new_connection",
                       ssl_ext_mp_new_connection);
    ap_hook_unregister("ap::mod_proxy::http::handler::write_host_header",
                       ssl_ext_mp_write_host_header);
    return;
}

/*
 * SSL proxy initialization
 */
#ifdef SSL_EXPERIMENTAL_PROXY
static void ssl_ext_mp_init(server_rec *s, pool *p)
{
    SSLSrvConfigRec *sc;
    char *cpVHostID;
    int nVerify;
    SSL_CTX *ctx;
    char *cp;
    STACK_OF(X509_INFO) *sk;

    /*
     * Initialize each virtual server 
     */
    ERR_clear_error();
    for (; s != NULL; s = s->next) {
        sc = mySrvConfig(s);
        cpVHostID = ssl_util_vhostid(p, s);
        
        if (sc->bProxyVerify == UNSET)
            sc->bProxyVerify = FALSE;

        /*
         *  Create new SSL context and configure callbacks
         */
        if (sc->nProxyProtocol == SSL_PROTOCOL_NONE) {
            ssl_log(s, SSL_LOG_ERROR,
                    "Init: (%s) No Proxy SSL protocols available [hint: SSLProxyProtocol]",
                    cpVHostID);
            ssl_die();
        }
        cp = ap_pstrcat(p, (sc->nProxyProtocol & SSL_PROTOCOL_SSLV2 ? "SSLv2, " : ""), 
                           (sc->nProxyProtocol & SSL_PROTOCOL_SSLV3 ? "SSLv3, " : ""), 
                           (sc->nProxyProtocol & SSL_PROTOCOL_TLSV1 ? "TLSv1, " : ""), NULL);
        cp[strlen(cp)-2] = NUL;
        ssl_log(s, SSL_LOG_TRACE, 
                "Init: (%s) Creating new proxy SSL context (protocols: %s)", 
                cpVHostID, cp);
        if (sc->nProxyProtocol == SSL_PROTOCOL_SSLV2)
            ctx = SSL_CTX_new(SSLv2_client_method());  /* only SSLv2 is left */ 
        else
            ctx = SSL_CTX_new(SSLv23_client_method()); /* be more flexible */
        if (ctx == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to create SSL Proxy context", cpVHostID);
            ssl_die();
        }
        sc->pSSLProxyCtx = ctx;
        SSL_CTX_set_options(ctx, SSL_OP_ALL);
        if (!(sc->nProxyProtocol & SSL_PROTOCOL_SSLV2))
            SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2);
        if (!(sc->nProxyProtocol & SSL_PROTOCOL_SSLV3))
            SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv3);
        if (!(sc->nProxyProtocol & SSL_PROTOCOL_TLSV1)) 
            SSL_CTX_set_options(ctx, SSL_OP_NO_TLSv1);

        if (sc->szProxyClientCertificateFile || sc->szProxyClientCertificatePath) {
            sk = sk_X509_INFO_new_null();
            if (sc->szProxyClientCertificateFile) 
                SSL_load_CrtAndKeyInfo_file(p, sk, sc->szProxyClientCertificateFile);
            if (sc->szProxyClientCertificatePath)
                SSL_load_CrtAndKeyInfo_path(p, sk, sc->szProxyClientCertificatePath);
            ssl_log(s, SSL_LOG_TRACE, "Init: (%s) loaded %d client certs for SSL proxy",
                    cpVHostID, sk_X509_INFO_num(sk));
            if (sk_X509_INFO_num(sk) > 0) {
                SSL_CTX_set_client_cert_cb(ctx, ssl_ext_mp_clientcert_cb);
                sc->skProxyClientCerts = sk;
            }
        }

        /*
         * Calculate OpenSSL verify type for verifying the remote server
         * certificate. We either verify it against our list of CA's, or don't
         * bother at all.
         */
        nVerify = SSL_VERIFY_NONE;
        if (sc->bProxyVerify)
            nVerify |= SSL_VERIFY_PEER;
        if (   nVerify & SSL_VERIFY_PEER 
            && sc->szProxyCACertificateFile == NULL 
            && sc->szProxyCACertificatePath == NULL) {
            ssl_log(s, SSL_LOG_ERROR,
                    "Init: (%s) SSLProxyVerify set to On but no CA certificates configured",
                    cpVHostID);
            ssl_die();
        }
        if (   nVerify & SSL_VERIFY_NONE
            && (   sc->szProxyCACertificateFile != NULL
                || sc->szProxyCACertificatePath != NULL)) {
            ssl_log(s, SSL_LOG_WARN, 
                    "init: (%s) CA certificates configured but ignored because SSLProxyVerify is Off",
                    cpVHostID);
        }
        SSL_CTX_set_verify(ctx, nVerify, ssl_ext_mp_verify_cb);

        /*
         * Enable session caching. We can safely use the same cache
         * as used for communicating with the other clients.
         */
        SSL_CTX_sess_set_new_cb(sc->pSSLProxyCtx,    ssl_callback_NewSessionCacheEntry);
        SSL_CTX_sess_set_get_cb(sc->pSSLProxyCtx,    ssl_callback_GetSessionCacheEntry);
        SSL_CTX_sess_set_remove_cb(sc->pSSLProxyCtx, ssl_callback_DelSessionCacheEntry);

        /*
         *  Configure SSL Cipher Suite
         */
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring permitted SSL ciphers for SSL proxy", cpVHostID);
        if (sc->szProxyCipherSuite != NULL) {
            if (!SSL_CTX_set_cipher_list(sc->pSSLProxyCtx, sc->szProxyCipherSuite)) {
                ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                        "Init: (%s) Unable to configure permitted SSL ciphers for SSL Proxy",
                        cpVHostID);
                ssl_die();
            }
        }

        /*
         * Configure Client Authentication details
         */
        if (sc->szProxyCACertificateFile != NULL || sc->szProxyCACertificatePath != NULL) {
             ssl_log(s, SSL_LOG_DEBUG, 
                     "Init: (%s) Configuring client verification locations for SSL Proxy", 
                     cpVHostID);
             if (!SSL_CTX_load_verify_locations(sc->pSSLProxyCtx,
                                                sc->szProxyCACertificateFile,
                                                sc->szProxyCACertificatePath)) {
                 ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR, 
                         "Init: (%s) Unable to configure SSL verify locations for SSL proxy",
                         cpVHostID);
                 ssl_die();
             }
        }
    }
    return;
}
#endif /* SSL_EXPERIMENTAL_PROXY */

static int ssl_ext_mp_canon(request_rec *r, char *url)
{
    int rc;

    if (strcEQn(url, "https:", 6)) {
        rc = OK;
        ap_hook_call("ap::mod_proxy::http::canon",
                     &rc, r, url+6, "https", DEFAULT_HTTPS_PORT);
        return rc;
    }
    return DECLINED;
}

static int ssl_ext_mp_handler(
    request_rec *r, void *cr, char *url, char *proxyhost, int proxyport, char *protocol)
{
    int rc;

    if (strcEQ(protocol, "https")) {
        ap_ctx_set(r->ctx, "ssl::proxy::enabled", PTRUE);
        ap_hook_call("ap::mod_proxy::http::handler",
                     &rc, r, cr, url, proxyhost, proxyport);
        return rc;
    }
    else {
        ap_ctx_set(r->ctx, "ssl::proxy::enabled", PFALSE);
    }
    return DECLINED;
}

static int ssl_ext_mp_set_destport(request_rec *r)
{
    if (ap_ctx_get(r->ctx, "ssl::proxy::enabled") == PTRUE)
        return DEFAULT_HTTPS_PORT;
    else
        return DEFAULT_HTTP_PORT;
}

static char *ssl_ext_mp_new_connection(request_rec *r, BUFF *fb,
    char *peer)
{
#ifndef SSL_EXPERIMENTAL_PROXY
    SSL_CTX *ssl_ctx;
#endif
    SSL *ssl;
    char *errmsg;
    int rc;
    char *cpVHostID;
    char *cpVHostMD5;
#ifdef SSL_EXPERIMENTAL_PROXY
    SSLSrvConfigRec *sc;
    char *cp;
#endif

    if (ap_ctx_get(r->ctx, "ssl::proxy::enabled") == PFALSE)
        return NULL;

    /*
     * Find context
     */
#ifdef SSL_EXPERIMENTAL_PROXY
    sc = mySrvConfig(r->server);
#endif
    cpVHostID = ssl_util_vhostid(r->pool, r->server);

    /*
     * Create a SSL context and handle
     */
#ifdef SSL_EXPERIMENTAL_PROXY
    ssl = SSL_new(sc->pSSLProxyCtx);
#else
    ssl_ctx = SSL_CTX_new(SSLv23_client_method());
    ssl = SSL_new(ssl_ctx);
#endif
    if (ssl == NULL) {
        errmsg = ap_psprintf(r->pool, "SSL proxy new failed (%s): peer %s: %s",
                             cpVHostID, peer, ERR_reason_error_string(ERR_get_error()));
        ap_ctx_set(fb->ctx, "ssl", NULL);
        return errmsg;
    }
    SSL_clear(ssl);
    cpVHostMD5 = ap_md5(r->pool, (unsigned char *)cpVHostID);
    if (!SSL_set_session_id_context(ssl, (unsigned char *)cpVHostMD5, strlen(cpVHostMD5))) {
        errmsg = ap_psprintf(r->pool, "Unable to set session id context to `%s': peer %s: %s",
                             cpVHostMD5, peer, ERR_reason_error_string(ERR_get_error()));
        ap_ctx_set(fb->ctx, "ssl", NULL);
        return errmsg;
    }
    SSL_set_fd(ssl, fb->fd);
#ifdef SSL_EXPERIMENTAL_PROXY
    SSL_set_app_data(ssl, fb->ctx);
#endif
    ap_ctx_set(fb->ctx, "ssl", ssl);
#ifdef SSL_EXPERIMENTAL_PROXY
    ap_ctx_set(fb->ctx, "ssl::proxy::server_rec", r->server);
    ap_ctx_set(fb->ctx, "ssl::proxy::peer", peer);
    ap_ctx_set(fb->ctx, "ssl::proxy::servername", cpVHostID);
    ap_ctx_set(fb->ctx, "ssl::proxy::verifyerror", NULL);
#endif

    /*
     * Give us a chance to gracefully close the connection
     */
    ap_register_cleanup(r->pool, (void *)fb,
                        ssl_ext_mp_close_connection, ssl_ext_mp_close_connection);

    /*
     * Establish the SSL connection
     */
    if ((rc = SSL_connect(ssl)) <= 0) {
#ifdef SSL_EXPERIMENTAL_PROXY
        if ((cp = (char *)ap_ctx_get(fb->ctx, "ssl::proxy::verifyerror")) != NULL) {
            SSL_set_shutdown(ssl, SSL_RECEIVED_SHUTDOWN); 
            SSL_smart_shutdown(ssl);
            SSL_free(ssl);
            ap_ctx_set(fb->ctx, "ssl", NULL);
            ap_bsetflag(fb, B_EOF|B_EOUT, 1);
            return NULL;
        }
#endif
        errmsg = ap_psprintf(r->pool, "SSL proxy connect failed (%s): peer %s: %s",
                             cpVHostID, peer, ERR_reason_error_string(ERR_get_error()));
        ssl_log(r->server, SSL_LOG_ERROR, "%s", errmsg);
        SSL_free(ssl);
        ap_ctx_set(fb->ctx, "ssl", NULL);
        return errmsg;
    }

    return NULL;
}

static void ssl_ext_mp_close_connection(void *_fb)
{
    BUFF *fb = _fb;
    SSL *ssl;
#ifndef SSL_EXPERIMENTAL_PROXY
    SSL_CTX *ctx;
#endif

    ssl = ap_ctx_get(fb->ctx, "ssl");
    if (ssl != NULL) {
#ifndef SSL_EXPERIMENTAL_PROXY
        ctx = SSL_get_SSL_CTX(ssl);
#endif
        SSL_set_shutdown(ssl, SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);
        SSL_smart_shutdown(ssl);
        SSL_free(ssl);
        ap_ctx_set(fb->ctx, "ssl", NULL);
#ifndef SSL_EXPERIMENTAL_PROXY
        if (ctx != NULL)
            SSL_CTX_free(ctx);
#endif
    }
    return;
}

static int ssl_ext_mp_write_host_header(
    request_rec *r, BUFF *fb, char *host, char *port, char *portstr)
{
    char defport[16];

    if (ap_ctx_get(r->ctx, "ssl::proxy::enabled") == PFALSE)
        return DECLINED;

    ap_snprintf(defport, sizeof(defport), "%d", DEFAULT_HTTPS_PORT);
    if (portstr != NULL && strcmp(portstr, defport)) {
        ap_bvputs(fb, "Host: ", host, ":", portstr, "\r\n", NULL);
        return OK;
    }
    return DECLINED;
}

#ifdef SSL_EXPERIMENTAL_PROXY

/* 
 * Callback for client certificate stuff.
 * If the remote site sent us a SSLv3 list of acceptable CA's then trawl the
 * table of client certs and send the first one that matches.
 */
static int ssl_ext_mp_clientcert_cb(SSL *ssl, X509 **x509, EVP_PKEY **pkey) 
{
    SSLSrvConfigRec *sc;
    X509_NAME *xnx;
    X509_NAME *issuer;
    X509_INFO *xi;
    char *peer;
    char *servername;
    server_rec *s;
    ap_ctx *pCtx;
    STACK_OF(X509_NAME) *sk;
    STACK_OF(X509_INFO) *pcerts;
    char *cp;
    int i, j;
    
    pCtx       = (ap_ctx *)SSL_get_app_data(ssl);
    s          = ap_ctx_get(pCtx, "ssl::proxy::server_rec");
    peer       = ap_ctx_get(pCtx, "ssl::proxy::peer");
    servername = ap_ctx_get(pCtx, "ssl::proxy::servername");

    sc         = mySrvConfig(s);
    pcerts     = sc->skProxyClientCerts;

    ssl_log(s, SSL_LOG_DEBUG, 
            "Proxy client certificate callback: (%s) entered", servername);

    if ((pcerts == NULL) || (sk_X509_INFO_num(pcerts) <= 0)) {
        ssl_log(s, SSL_LOG_TRACE,
                "Proxy client certificate callback: (%s) "
                "site wanted client certificate but none available", 
                servername);
        return 0;
    }                                                                     

    sk = SSL_get_client_CA_list(ssl);

    if ((sk == NULL) || (sk_X509_NAME_num(sk) <= 0)) {
        /* 
         * remote site didn't send us a list of acceptable CA certs, 
         * so lets send the first one we came across 
         */   
        xi = sk_X509_INFO_value(pcerts, 0);
        cp = X509_NAME_oneline(X509_get_subject_name(xi->x509), NULL, 0);
        ssl_log(s, SSL_LOG_DEBUG,
                "SSL Proxy: (%s) no acceptable CA list, sending %s", 
                servername, cp != NULL ? cp : "-unknown-");
        OPENSSL_free(cp);
        /* export structures to the caller */
        *x509 = xi->x509;
        *pkey = xi->x_pkey->dec_pkey;
        /* prevent OpenSSL freeing these structures */
        CRYPTO_add(&((*x509)->references), +1, CRYPTO_LOCK_X509_PKEY);
        CRYPTO_add(&((*pkey)->references), +1, CRYPTO_LOCK_X509_PKEY);
        return 1;
    }         

    for (i = 0; i < sk_X509_NAME_num(sk); i++) {
        xnx = sk_X509_NAME_value(sk, i);
        for (j = 0; j < sk_X509_INFO_num(pcerts); j++) {
            xi = sk_X509_INFO_value(pcerts,j);
            issuer = X509_get_issuer_name(xi->x509);
            if (X509_NAME_cmp(issuer, xnx) == 0) {
                cp = X509_NAME_oneline(X509_get_subject_name(xi->x509), NULL, 0);
                ssl_log(s, SSL_LOG_DEBUG, "SSL Proxy: (%s) sending %s", 
                        servername, cp != NULL ? cp : "-unknown-");
                OPENSSL_free(cp);
                /* export structures to the caller */
                *x509 = xi->x509;
                *pkey = xi->x_pkey->dec_pkey;
                /* prevent OpenSSL freeing these structures */
                CRYPTO_add(&((*x509)->references), +1, CRYPTO_LOCK_X509_PKEY);
                CRYPTO_add(&((*pkey)->references), +1, CRYPTO_LOCK_X509_PKEY);
                return 1;
            }
        }
    }
    ssl_log(s, SSL_LOG_TRACE,
            "Proxy client certificate callback: (%s) "
            "no client certificate found!?", servername);
    return 0; 
}

/*
 * This is the verify callback when we are connecting to a remote SSL server
 * from the proxy. Information is passed in via the SSL "ctx" app_data
 * mechanism. We pass in an Apache context in this field, which contains
 * server_rec of the server making the proxy connection from the
 * "ssl::proxy::server_rec" context.
 *
 * The result of the verification is passed back out to SSLERR via the return
 * value. We also store the error message in the "proxyverifyfailed" context,
 * so the caller of SSL_connect() can log a detailed error message.
 */
static int ssl_ext_mp_verify_cb(int ok, X509_STORE_CTX *ctx)
{
    SSLSrvConfigRec *sc;
    X509 *xs;
    int errnum;
    int errdepth;
    char *cp, *cp2;
    ap_ctx *pCtx;
    server_rec *s;
    SSL *ssl;
    char *peer;
    char *servername;

    ssl        = (SSL *)X509_STORE_CTX_get_app_data(ctx);
    pCtx       = (ap_ctx *)SSL_get_app_data(ssl);
    s          = ap_ctx_get(pCtx, "ssl::proxy::server_rec");
    peer       = ap_ctx_get(pCtx, "ssl::proxy::peer");
    servername = ap_ctx_get(pCtx, "ssl::proxy::servername");
    sc         = mySrvConfig(s);

    /*
     * Unless stated otherwise by the configuration, we really don't
     * care if the verification was okay or not, so lets return now
     * before we do anything involving memory or time.
     */
    if (sc->bProxyVerify == FALSE)
        return ok;
                     
    /*
     * Get verify ingredients
     */
    xs       = X509_STORE_CTX_get_current_cert(ctx);
    errnum   = X509_STORE_CTX_get_error(ctx);
    errdepth = X509_STORE_CTX_get_error_depth(ctx);

    /* 
     * Log verification information
     */
    cp  = X509_NAME_oneline(X509_get_subject_name(xs), NULL, 0);
    cp2 = X509_NAME_oneline(X509_get_issuer_name(xs),  NULL, 0);
    ssl_log(s, SSL_LOG_DEBUG,
            "SSL Proxy: (%s) Certificate Verification for remote server %s: "
            "depth: %d, subject: %s, issuer: %s", 
            servername, peer != NULL ? peer : "-unknown-",
            errdepth, cp != NULL ? cp : "-unknown-", 
            cp2 != NULL ? cp2 : "-unknown");
    OPENSSL_free(cp);
    OPENSSL_free(cp2);

    /*
     * If we already know it's not ok, log the real reason
     */
    if (!ok) {
        ssl_log(s, SSL_LOG_ERROR,
                "SSL Proxy: (%s) Certificate Verification failed for %s: "
                "Error (%d): %s", servername,
                peer != NULL ? peer : "-unknown-",
                errnum, X509_verify_cert_error_string(errnum));
        ap_ctx_set(pCtx, "ssl::proxy::verifyerror", 
                   (void *)X509_verify_cert_error_string(errnum));
        return ok;
    }

    /*
     * Check the depth of the certificate chain
     */
    if (sc->nProxyVerifyDepth > 0) {
        if (errdepth > sc->nProxyVerifyDepth) {
            ssl_log(s, SSL_LOG_ERROR,
                "SSL Proxy: (%s) Certificate Verification failed for %s: "
                "Certificate Chain too long "
                "(chain has %d certificates, but maximum allowed are only %d)", 
                servername, peer, errdepth, sc->nProxyVerifyDepth);
            ap_ctx_set(pCtx, "ssl::proxy::verifyerror",
                       (void *)X509_verify_cert_error_string(X509_V_ERR_CERT_CHAIN_TOO_LONG));
            ok = FALSE;
        }
    }

    /*
     * And finally signal OpenSSL the (perhaps changed) state
     */
    return (ok);
}

#endif /* SSL_EXPERIMENTAL_PROXY */

/*  _________________________________________________________________
**
**  SSL Extension to mod_status
**  _________________________________________________________________
*/

static void ssl_ext_ms_display(request_rec *, int, int);

static void ssl_ext_ms_register(void)
{
    ap_hook_register("ap::mod_status::display", ssl_ext_ms_display, AP_HOOK_NOCTX);
    return;
}

static void ssl_ext_ms_unregister(void)
{
    ap_hook_unregister("ap::mod_status::display", ssl_ext_ms_display);
    return;
}

static void ssl_ext_ms_display_cb(char *str, void *_r)
{
    request_rec *r = (request_rec *)_r;
    if (str != NULL)
        ap_rputs(str, r);
    return;
}

static void ssl_ext_ms_display(request_rec *r, int no_table_report, int short_report)
{
    SSLSrvConfigRec *sc = mySrvConfig(r->server);

    if (sc == NULL)
        return;
    if (short_report)
        return;
    ap_rputs("<hr>\n", r);
    ap_rputs("<table cellspacing=0 cellpadding=0>\n", r);
    ap_rputs("<tr><td bgcolor=\"#000000\">\n", r);
    ap_rputs("<b><font color=\"#ffffff\" face=\"Arial,Helvetica\">SSL/TLS Session Cache Status:</font></b>\r", r);
    ap_rputs("</td></tr>\n", r);
    ap_rputs("<tr><td bgcolor=\"#ffffff\">\n", r);
    ssl_scache_status(r->server, r->pool, ssl_ext_ms_display_cb, r);
    ap_rputs("</td></tr>\n", r);
    ap_rputs("</table>\n", r);
    return;
}

@


1.14
log
@Make the proxy module work with https again by allowing the destination
port to be set in the config file instead of using HTTP_DEFAULT_PORT
in all cases.  Prevent a segfault that would happen when the SSL
connection from the proxy fails.

Problem found and analyzed by Mischa Diehm; fix by me.
@
text
@@


1.13
log
@Add support for IPv6 while keeping the default at IPv4 to not break
existing installations.  See the documentation for the IPv6 related
configuration.

This changes the module ABI since addresses are now struct addrinfo.

This has been tested by many people and run on production machines
for several months.

feedback many, ok todd
@
text
@d444 2
a445 1
static char *ssl_ext_mp_new_connection(request_rec *r, BUFF *fb, char *peer)
d565 2
d570 2
a571 1
    if (portstr != NULL && port != DEFAULT_HTTPS_PORT) {
@


1.12
log
@merge apache 1.3.29 and mod_ssl 2.8.16
ok brad@@
@
text
@d221 1
a221 1
static int   ssl_ext_mp_write_host_header(request_rec *, BUFF *, char *, int, char *);
d562 1
a562 1
    request_rec *r, BUFF *fb, char *host, int port, char *portstr)
@


1.11
log
@merge
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2001 Ralf S. Engelschall. All rights reserved.
@


1.10
log
@various format string cleanups; tedu ok
@
text
@d627 1
a627 1
        free(cp);
d646 1
a646 1
                free(cp);
d720 2
a721 2
    free(cp);
    free(cp2);
@


1.9
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d527 1
a527 1
        ssl_log(r->server, SSL_LOG_ERROR, errmsg);
@


1.8
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d623 1
a623 1
        cp  = X509_NAME_oneline(X509_get_subject_name(xi->x509), NULL, 0);
@


1.7
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2000 Ralf S. Engelschall. All rights reserved.
@


1.6
log
@merge mod_ssl 2.6.6
@
text
@d282 1
@


1.5
log
@mod_ssl 2.6.4 merge
From brad@@
@
text
@d603 2
a604 1
    ssl_log(s, SSL_LOG_DEBUG, "Proxy client certificate callback: (%s) entered");
@


1.4
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d222 1
a222 1
#ifdef SSL_EXPERIMENTAL
d233 1
a233 1
#ifdef SSL_EXPERIMENTAL
d252 1
a252 1
#ifdef SSL_EXPERIMENTAL
d269 1
a269 1
#ifdef SSL_EXPERIMENTAL
d403 1
a403 1
#endif /* SSL_EXPERIMENTAL */
d445 1
a445 1
#ifndef SSL_EXPERIMENTAL
d453 1
a453 1
#ifdef SSL_EXPERIMENTAL
d464 1
a464 1
#ifdef SSL_EXPERIMENTAL
d472 1
a472 1
#ifdef SSL_EXPERIMENTAL
d485 1
a485 1
    cpVHostMD5 = ap_md5(r->pool, cpVHostID);
d493 1
a493 1
#ifdef SSL_EXPERIMENTAL
d497 1
a497 1
#ifdef SSL_EXPERIMENTAL
d514 1
a514 1
#ifdef SSL_EXPERIMENTAL
d539 1
d541 1
d545 1
d547 1
d552 1
d555 1
d573 1
a573 1
#ifdef SSL_EXPERIMENTAL
d693 8
d757 1
a757 1
#endif /* SSL_EXPERIMENTAL */
d792 2
@


1.3
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d216 11
a226 6
static int   ssl_ext_mp_canon(request_rec *r, char *url);
static int   ssl_ext_mp_handler(request_rec *r, void *cr, char *url, char *proxyhost, int proxyport, char *protocol);
static int   ssl_ext_mp_set_destport(request_rec *r);
static char *ssl_ext_mp_new_connection(request_rec *r, BUFF *fb);
static void  ssl_ext_mp_close_connection(void *_fb);
static int   ssl_ext_mp_write_host_header(request_rec *r, BUFF *fb, char *host, int port, char *portstr);
d233 4
d252 3
d266 139
d443 1
a443 1
static char *ssl_ext_mp_new_connection(request_rec *r, BUFF *fb)
d445 1
d447 1
d453 4
d460 7
d472 3
d476 5
a480 3
    if ((ssl = SSL_new(ssl_ctx)) == NULL) {
        errmsg = ap_pstrcat(r->pool, "SSL new failed (%s): ", cpVHostID,
                            ERR_reason_error_string(ERR_get_error()), NULL);
d487 2
a488 2
        errmsg = ap_pstrcat(r->pool, "Unable to set session id context to `%s': ", cpVHostMD5,
                            ERR_reason_error_string(ERR_get_error()), NULL);
d493 3
d497 6
d514 13
a526 2
        errmsg = ap_pstrcat(r->pool, "SSL connect failed (%s): ", cpVHostID,
                            ERR_reason_error_string(ERR_get_error()), NULL);
d539 1
d543 1
d548 2
d567 177
@


1.2
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d12 1
a12 1
 * Copyright (c) 1998-1999 Ralf S. Engelschall. All rights reserved.
d299 1
d316 7
a322 1
    SSL_set_session_id_context(ssl, (unsigned char *)cpVHostID, strlen(cpVHostID));
@


1.1
log
@mod_ssl-2.2.3-1.3.4 (will require libssl-1.1 for https to work, but
mostly harmless otherwise).
@
text
@d2 4
a5 4
**  _ __ ___   ___   __| |    ___ ___| |
** | '_ ` _ \ / _ \ / _` |   / __/ __| |
** | | | | | | (_) | (_| |   \__ \__ \ | mod_ssl - Apache Interface to SSLeay
** |_| |_| |_|\___/ \__,_|___|___/___/_| http://www.engelschall.com/sw/mod_ssl/
d30 1
a30 1
 *     mod_ssl project (http://www.engelschall.com/sw/mod_ssl/)."
d45 1
a45 1
 *     mod_ssl project (http://www.engelschall.com/sw/mod_ssl/)."
d79 2
d87 1
d96 1
d126 1
a126 1
    ap_hook_unregister("ap::mod_log_config::log_x", 
d142 1
a142 1
    if (strcmp(a, "version") == 0)
d144 1
a144 1
    else if (strcmp(a, "cipher") == 0)
d146 1
a146 1
    else if (strcmp(a, "subjectdn") == 0 || strcmp(a, "clientcert") == 0)
d148 1
a148 1
    else if (strcmp(a, "issuerdn") == 0 || strcmp(a, "cacert") == 0)
d150 1
a150 1
    else if (strcmp(a, "errcode") == 0)
d152 1
a152 1
    else if (strcmp(a, "errstr") == 0)
d195 1
a195 1
    ap_hook_unregister("ap::mod_rewrite::lookup_variable", 
d258 1
a258 1
    if (strncasecmp(url, "https:", 6) == 0) {
d272 2
a273 2
    if (strcasecmp(protocol, "https") == 0) {
        ap_ctx_set(r->ctx, "ssl_enabled", (void *)1);
d278 3
d286 1
a286 1
    if (ap_ctx_get(r->ctx, "ssl_enabled") == (void *)1)
d298 1
d300 1
a300 1
    if (ap_ctx_get(r->ctx, "ssl_enabled") != (void *)1)
d302 1
d308 6
a313 1
    ssl = SSL_new(ssl_ctx);
d315 1
d318 4
d329 1
a329 1
        errmsg = ap_pstrcat(r->pool, "SSL connect failed: ",
d332 1
d347 1
a347 1
        while (!SSL_shutdown(ssl));
d357 1
a357 1
    if (ap_ctx_get(r->ctx, "ssl_enabled") != (void *)1)
d365 47
@


1.1.1.1
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@d2 4
a5 4
**  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
** | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
** | | | | | | (_) | (_| |   \__ \__ \ |  www.modssl.org
** |_| |_| |_|\___/ \__,_|___|___/___/_|  ftp.modssl.org
d12 1
a12 1
 * Copyright (c) 1998-2001 Ralf S. Engelschall. All rights reserved.
d30 1
a30 1
 *     mod_ssl project (http://www.modssl.org/)."
d45 1
a45 1
 *     mod_ssl project (http://www.modssl.org/)."
a78 2
static void  ssl_ext_ms_register(void);
static void  ssl_ext_ms_unregister(void);
a84 1
    ssl_ext_ms_register();
a92 1
    ssl_ext_ms_unregister();
d122 1
a122 1
    ap_hook_unregister("ap::mod_log_config::log_x",
d138 1
a138 1
    if (strEQ(a, "version"))
d140 1
a140 1
    else if (strEQ(a, "cipher"))
d142 1
a142 1
    else if (strEQ(a, "subjectdn") || strEQ(a, "clientcert"))
d144 1
a144 1
    else if (strEQ(a, "issuerdn") || strEQ(a, "cacert"))
d146 1
a146 1
    else if (strEQ(a, "errcode"))
d148 1
a148 1
    else if (strEQ(a, "errstr"))
d191 1
a191 1
    ap_hook_unregister("ap::mod_rewrite::lookup_variable",
d212 6
a217 11
static int   ssl_ext_mp_canon(request_rec *, char *);
static int   ssl_ext_mp_handler(request_rec *, void *, char *, char *, int, char *);
static int   ssl_ext_mp_set_destport(request_rec *);
static char *ssl_ext_mp_new_connection(request_rec *, BUFF *, char *);
static void  ssl_ext_mp_close_connection(void *);
static int   ssl_ext_mp_write_host_header(request_rec *, BUFF *, char *, int, char *);
#ifdef SSL_EXPERIMENTAL_PROXY
static void  ssl_ext_mp_init(server_rec *, pool *);
static int   ssl_ext_mp_verify_cb(int, X509_STORE_CTX *);
static int   ssl_ext_mp_clientcert_cb(SSL *, X509 **, EVP_PKEY **);
#endif
a223 4
#ifdef SSL_EXPERIMENTAL_PROXY
    ap_hook_register("ap::mod_proxy::init",
                     ssl_ext_mp_init, AP_HOOK_NOCTX);
#endif
a238 3
#ifdef SSL_EXPERIMENTAL_PROXY
    ap_hook_unregister("ap::mod_proxy::init", ssl_ext_mp_init);
#endif
a249 140
/*
 * SSL proxy initialization
 */
#ifdef SSL_EXPERIMENTAL_PROXY
static void ssl_ext_mp_init(server_rec *s, pool *p)
{
    SSLSrvConfigRec *sc;
    char *cpVHostID;
    int nVerify;
    SSL_CTX *ctx;
    char *cp;
    STACK_OF(X509_INFO) *sk;

    /*
     * Initialize each virtual server 
     */
    ERR_clear_error();
    for (; s != NULL; s = s->next) {
        sc = mySrvConfig(s);
        cpVHostID = ssl_util_vhostid(p, s);
        
        if (sc->bProxyVerify == UNSET)
            sc->bProxyVerify = FALSE;

        /*
         *  Create new SSL context and configure callbacks
         */
        if (sc->nProxyProtocol == SSL_PROTOCOL_NONE) {
            ssl_log(s, SSL_LOG_ERROR,
                    "Init: (%s) No Proxy SSL protocols available [hint: SSLProxyProtocol]",
                    cpVHostID);
            ssl_die();
        }
        cp = ap_pstrcat(p, (sc->nProxyProtocol & SSL_PROTOCOL_SSLV2 ? "SSLv2, " : ""), 
                           (sc->nProxyProtocol & SSL_PROTOCOL_SSLV3 ? "SSLv3, " : ""), 
                           (sc->nProxyProtocol & SSL_PROTOCOL_TLSV1 ? "TLSv1, " : ""), NULL);
        cp[strlen(cp)-2] = NUL;
        ssl_log(s, SSL_LOG_TRACE, 
                "Init: (%s) Creating new proxy SSL context (protocols: %s)", 
                cpVHostID, cp);
        if (sc->nProxyProtocol == SSL_PROTOCOL_SSLV2)
            ctx = SSL_CTX_new(SSLv2_client_method());  /* only SSLv2 is left */ 
        else
            ctx = SSL_CTX_new(SSLv23_client_method()); /* be more flexible */
        if (ctx == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to create SSL Proxy context", cpVHostID);
            ssl_die();
        }
        sc->pSSLProxyCtx = ctx;
        SSL_CTX_set_options(ctx, SSL_OP_ALL);
        if (!(sc->nProxyProtocol & SSL_PROTOCOL_SSLV2))
            SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2);
        if (!(sc->nProxyProtocol & SSL_PROTOCOL_SSLV3))
            SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv3);
        if (!(sc->nProxyProtocol & SSL_PROTOCOL_TLSV1)) 
            SSL_CTX_set_options(ctx, SSL_OP_NO_TLSv1);

        if (sc->szProxyClientCertificateFile || sc->szProxyClientCertificatePath) {
            sk = sk_X509_INFO_new_null();
            if (sc->szProxyClientCertificateFile) 
                SSL_load_CrtAndKeyInfo_file(p, sk, sc->szProxyClientCertificateFile);
            if (sc->szProxyClientCertificatePath)
                SSL_load_CrtAndKeyInfo_path(p, sk, sc->szProxyClientCertificatePath);
            ssl_log(s, SSL_LOG_TRACE, "Init: (%s) loaded %d client certs for SSL proxy",
                    cpVHostID, sk_X509_INFO_num(sk));
            if (sk_X509_INFO_num(sk) > 0) {
                SSL_CTX_set_client_cert_cb(ctx, ssl_ext_mp_clientcert_cb);
                sc->skProxyClientCerts = sk;
            }
        }

        /*
         * Calculate OpenSSL verify type for verifying the remote server
         * certificate. We either verify it against our list of CA's, or don't
         * bother at all.
         */
        nVerify = SSL_VERIFY_NONE;
        if (sc->bProxyVerify)
            nVerify |= SSL_VERIFY_PEER;
        if (   nVerify & SSL_VERIFY_PEER 
            && sc->szProxyCACertificateFile == NULL 
            && sc->szProxyCACertificatePath == NULL) {
            ssl_log(s, SSL_LOG_ERROR,
                    "Init: (%s) SSLProxyVerify set to On but no CA certificates configured",
                    cpVHostID);
            ssl_die();
        }
        if (   nVerify & SSL_VERIFY_NONE
            && (   sc->szProxyCACertificateFile != NULL
                || sc->szProxyCACertificatePath != NULL)) {
            ssl_log(s, SSL_LOG_WARN, 
                    "init: (%s) CA certificates configured but ignored because SSLProxyVerify is Off",
                    cpVHostID);
        }
        SSL_CTX_set_verify(ctx, nVerify, ssl_ext_mp_verify_cb);

        /*
         * Enable session caching. We can safely use the same cache
         * as used for communicating with the other clients.
         */
        SSL_CTX_sess_set_new_cb(sc->pSSLProxyCtx,    ssl_callback_NewSessionCacheEntry);
        SSL_CTX_sess_set_get_cb(sc->pSSLProxyCtx,    ssl_callback_GetSessionCacheEntry);
        SSL_CTX_sess_set_remove_cb(sc->pSSLProxyCtx, ssl_callback_DelSessionCacheEntry);

        /*
         *  Configure SSL Cipher Suite
         */
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring permitted SSL ciphers for SSL proxy", cpVHostID);
        if (sc->szProxyCipherSuite != NULL) {
            if (!SSL_CTX_set_cipher_list(sc->pSSLProxyCtx, sc->szProxyCipherSuite)) {
                ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                        "Init: (%s) Unable to configure permitted SSL ciphers for SSL Proxy",
                        cpVHostID);
                ssl_die();
            }
        }

        /*
         * Configure Client Authentication details
         */
        if (sc->szProxyCACertificateFile != NULL || sc->szProxyCACertificatePath != NULL) {
             ssl_log(s, SSL_LOG_DEBUG, 
                     "Init: (%s) Configuring client verification locations for SSL Proxy", 
                     cpVHostID);
             if (!SSL_CTX_load_verify_locations(sc->pSSLProxyCtx,
                                                sc->szProxyCACertificateFile,
                                                sc->szProxyCACertificatePath)) {
                 ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR, 
                         "Init: (%s) Unable to configure SSL verify locations for SSL proxy",
                         cpVHostID);
                 ssl_die();
             }
        }
    }
    return;
}
#endif /* SSL_EXPERIMENTAL_PROXY */

d254 1
a254 1
    if (strcEQn(url, "https:", 6)) {
d268 2
a269 2
    if (strcEQ(protocol, "https")) {
        ap_ctx_set(r->ctx, "ssl::proxy::enabled", PTRUE);
a273 3
    else {
        ap_ctx_set(r->ctx, "ssl::proxy::enabled", PFALSE);
    }
d279 1
a279 1
    if (ap_ctx_get(r->ctx, "ssl::proxy::enabled") == PTRUE)
d285 1
a285 1
static char *ssl_ext_mp_new_connection(request_rec *r, BUFF *fb, char *peer)
a286 1
#ifndef SSL_EXPERIMENTAL_PROXY
a287 1
#endif
a290 6
    char *cpVHostID;
    char *cpVHostMD5;
#ifdef SSL_EXPERIMENTAL_PROXY
    SSLSrvConfigRec *sc;
    char *cp;
#endif
d292 1
a292 1
    if (ap_ctx_get(r->ctx, "ssl::proxy::enabled") == PFALSE)
a295 8
     * Find context
     */
#ifdef SSL_EXPERIMENTAL_PROXY
    sc = mySrvConfig(r->server);
#endif
    cpVHostID = ssl_util_vhostid(r->pool, r->server);

    /*
a297 3
#ifdef SSL_EXPERIMENTAL_PROXY
    ssl = SSL_new(sc->pSSLProxyCtx);
#else
a299 7
#endif
    if (ssl == NULL) {
        errmsg = ap_psprintf(r->pool, "SSL proxy new failed (%s): peer %s: %s",
                             cpVHostID, peer, ERR_reason_error_string(ERR_get_error()));
        ap_ctx_set(fb->ctx, "ssl", NULL);
        return errmsg;
    }
a300 7
    cpVHostMD5 = ap_md5(r->pool, (unsigned char *)cpVHostID);
    if (!SSL_set_session_id_context(ssl, (unsigned char *)cpVHostMD5, strlen(cpVHostMD5))) {
        errmsg = ap_psprintf(r->pool, "Unable to set session id context to `%s': peer %s: %s",
                             cpVHostMD5, peer, ERR_reason_error_string(ERR_get_error()));
        ap_ctx_set(fb->ctx, "ssl", NULL);
        return errmsg;
    }
a301 3
#ifdef SSL_EXPERIMENTAL_PROXY
    SSL_set_app_data(ssl, fb->ctx);
#endif
a302 10
#ifdef SSL_EXPERIMENTAL_PROXY
    ap_ctx_set(fb->ctx, "ssl::proxy::server_rec", r->server);
    ap_ctx_set(fb->ctx, "ssl::proxy::peer", peer);
    ap_ctx_set(fb->ctx, "ssl::proxy::servername", cpVHostID);
    ap_ctx_set(fb->ctx, "ssl::proxy::verifyerror", NULL);
#endif

    /*
     * Give us a chance to gracefully close the connection
     */
d310 2
a311 13
#ifdef SSL_EXPERIMENTAL_PROXY
        if ((cp = (char *)ap_ctx_get(fb->ctx, "ssl::proxy::verifyerror")) != NULL) {
            SSL_set_shutdown(ssl, SSL_RECEIVED_SHUTDOWN); 
            SSL_smart_shutdown(ssl);
            SSL_free(ssl);
            ap_ctx_set(fb->ctx, "ssl", NULL);
            ap_bsetflag(fb, B_EOF|B_EOUT, 1);
            return NULL;
        }
#endif
        errmsg = ap_psprintf(r->pool, "SSL proxy connect failed (%s): peer %s: %s",
                             cpVHostID, peer, ERR_reason_error_string(ERR_get_error()));
        ssl_log(r->server, SSL_LOG_ERROR, errmsg);
a312 1
        ap_ctx_set(fb->ctx, "ssl", NULL);
a322 3
#ifndef SSL_EXPERIMENTAL_PROXY
    SSL_CTX *ctx;
#endif
a325 3
#ifndef SSL_EXPERIMENTAL_PROXY
        ctx = SSL_get_SSL_CTX(ssl);
#endif
d327 1
a327 1
        SSL_smart_shutdown(ssl);
a329 4
#ifndef SSL_EXPERIMENTAL_PROXY
        if (ctx != NULL)
            SSL_CTX_free(ctx);
#endif
d337 1
a337 1
    if (ap_ctx_get(r->ctx, "ssl::proxy::enabled") == PFALSE)
a344 235
}

#ifdef SSL_EXPERIMENTAL_PROXY

/* 
 * Callback for client certificate stuff.
 * If the remote site sent us a SSLv3 list of acceptable CA's then trawl the
 * table of client certs and send the first one that matches.
 */
static int ssl_ext_mp_clientcert_cb(SSL *ssl, X509 **x509, EVP_PKEY **pkey) 
{
    SSLSrvConfigRec *sc;
    X509_NAME *xnx;
    X509_NAME *issuer;
    X509_INFO *xi;
    char *peer;
    char *servername;
    server_rec *s;
    ap_ctx *pCtx;
    STACK_OF(X509_NAME) *sk;
    STACK_OF(X509_INFO) *pcerts;
    char *cp;
    int i, j;
    
    pCtx       = (ap_ctx *)SSL_get_app_data(ssl);
    s          = ap_ctx_get(pCtx, "ssl::proxy::server_rec");
    peer       = ap_ctx_get(pCtx, "ssl::proxy::peer");
    servername = ap_ctx_get(pCtx, "ssl::proxy::servername");

    sc         = mySrvConfig(s);
    pcerts     = sc->skProxyClientCerts;

    ssl_log(s, SSL_LOG_DEBUG, 
            "Proxy client certificate callback: (%s) entered", servername);

    if ((pcerts == NULL) || (sk_X509_INFO_num(pcerts) <= 0)) {
        ssl_log(s, SSL_LOG_TRACE,
                "Proxy client certificate callback: (%s) "
                "site wanted client certificate but none available", 
                servername);
        return 0;
    }                                                                     

    sk = SSL_get_client_CA_list(ssl);

    if ((sk == NULL) || (sk_X509_NAME_num(sk) <= 0)) {
        /* 
         * remote site didn't send us a list of acceptable CA certs, 
         * so lets send the first one we came across 
         */   
        xi = sk_X509_INFO_value(pcerts, 0);
        cp = X509_NAME_oneline(X509_get_subject_name(xi->x509), NULL, 0);
        ssl_log(s, SSL_LOG_DEBUG,
                "SSL Proxy: (%s) no acceptable CA list, sending %s", 
                servername, cp != NULL ? cp : "-unknown-");
        free(cp);
        /* export structures to the caller */
        *x509 = xi->x509;
        *pkey = xi->x_pkey->dec_pkey;
        /* prevent OpenSSL freeing these structures */
        CRYPTO_add(&((*x509)->references), +1, CRYPTO_LOCK_X509_PKEY);
        CRYPTO_add(&((*pkey)->references), +1, CRYPTO_LOCK_X509_PKEY);
        return 1;
    }         

    for (i = 0; i < sk_X509_NAME_num(sk); i++) {
        xnx = sk_X509_NAME_value(sk, i);
        for (j = 0; j < sk_X509_INFO_num(pcerts); j++) {
            xi = sk_X509_INFO_value(pcerts,j);
            issuer = X509_get_issuer_name(xi->x509);
            if (X509_NAME_cmp(issuer, xnx) == 0) {
                cp = X509_NAME_oneline(X509_get_subject_name(xi->x509), NULL, 0);
                ssl_log(s, SSL_LOG_DEBUG, "SSL Proxy: (%s) sending %s", 
                        servername, cp != NULL ? cp : "-unknown-");
                free(cp);
                /* export structures to the caller */
                *x509 = xi->x509;
                *pkey = xi->x_pkey->dec_pkey;
                /* prevent OpenSSL freeing these structures */
                CRYPTO_add(&((*x509)->references), +1, CRYPTO_LOCK_X509_PKEY);
                CRYPTO_add(&((*pkey)->references), +1, CRYPTO_LOCK_X509_PKEY);
                return 1;
            }
        }
    }
    ssl_log(s, SSL_LOG_TRACE,
            "Proxy client certificate callback: (%s) "
            "no client certificate found!?", servername);
    return 0; 
}

/*
 * This is the verify callback when we are connecting to a remote SSL server
 * from the proxy. Information is passed in via the SSL "ctx" app_data
 * mechanism. We pass in an Apache context in this field, which contains
 * server_rec of the server making the proxy connection from the
 * "ssl::proxy::server_rec" context.
 *
 * The result of the verification is passed back out to SSLERR via the return
 * value. We also store the error message in the "proxyverifyfailed" context,
 * so the caller of SSL_connect() can log a detailed error message.
 */
static int ssl_ext_mp_verify_cb(int ok, X509_STORE_CTX *ctx)
{
    SSLSrvConfigRec *sc;
    X509 *xs;
    int errnum;
    int errdepth;
    char *cp, *cp2;
    ap_ctx *pCtx;
    server_rec *s;
    SSL *ssl;
    char *peer;
    char *servername;

    ssl        = (SSL *)X509_STORE_CTX_get_app_data(ctx);
    pCtx       = (ap_ctx *)SSL_get_app_data(ssl);
    s          = ap_ctx_get(pCtx, "ssl::proxy::server_rec");
    peer       = ap_ctx_get(pCtx, "ssl::proxy::peer");
    servername = ap_ctx_get(pCtx, "ssl::proxy::servername");
    sc         = mySrvConfig(s);

    /*
     * Unless stated otherwise by the configuration, we really don't
     * care if the verification was okay or not, so lets return now
     * before we do anything involving memory or time.
     */
    if (sc->bProxyVerify == FALSE)
        return ok;
                     
    /*
     * Get verify ingredients
     */
    xs       = X509_STORE_CTX_get_current_cert(ctx);
    errnum   = X509_STORE_CTX_get_error(ctx);
    errdepth = X509_STORE_CTX_get_error_depth(ctx);

    /* 
     * Log verification information
     */
    cp  = X509_NAME_oneline(X509_get_subject_name(xs), NULL, 0);
    cp2 = X509_NAME_oneline(X509_get_issuer_name(xs),  NULL, 0);
    ssl_log(s, SSL_LOG_DEBUG,
            "SSL Proxy: (%s) Certificate Verification for remote server %s: "
            "depth: %d, subject: %s, issuer: %s", 
            servername, peer != NULL ? peer : "-unknown-",
            errdepth, cp != NULL ? cp : "-unknown-", 
            cp2 != NULL ? cp2 : "-unknown");
    free(cp);
    free(cp2);

    /*
     * If we already know it's not ok, log the real reason
     */
    if (!ok) {
        ssl_log(s, SSL_LOG_ERROR,
                "SSL Proxy: (%s) Certificate Verification failed for %s: "
                "Error (%d): %s", servername,
                peer != NULL ? peer : "-unknown-",
                errnum, X509_verify_cert_error_string(errnum));
        ap_ctx_set(pCtx, "ssl::proxy::verifyerror", 
                   (void *)X509_verify_cert_error_string(errnum));
        return ok;
    }

    /*
     * Check the depth of the certificate chain
     */
    if (sc->nProxyVerifyDepth > 0) {
        if (errdepth > sc->nProxyVerifyDepth) {
            ssl_log(s, SSL_LOG_ERROR,
                "SSL Proxy: (%s) Certificate Verification failed for %s: "
                "Certificate Chain too long "
                "(chain has %d certificates, but maximum allowed are only %d)", 
                servername, peer, errdepth, sc->nProxyVerifyDepth);
            ap_ctx_set(pCtx, "ssl::proxy::verifyerror",
                       (void *)X509_verify_cert_error_string(X509_V_ERR_CERT_CHAIN_TOO_LONG));
            ok = FALSE;
        }
    }

    /*
     * And finally signal OpenSSL the (perhaps changed) state
     */
    return (ok);
}

#endif /* SSL_EXPERIMENTAL_PROXY */

/*  _________________________________________________________________
**
**  SSL Extension to mod_status
**  _________________________________________________________________
*/

static void ssl_ext_ms_display(request_rec *, int, int);

static void ssl_ext_ms_register(void)
{
    ap_hook_register("ap::mod_status::display", ssl_ext_ms_display, AP_HOOK_NOCTX);
    return;
}

static void ssl_ext_ms_unregister(void)
{
    ap_hook_unregister("ap::mod_status::display", ssl_ext_ms_display);
    return;
}

static void ssl_ext_ms_display_cb(char *str, void *_r)
{
    request_rec *r = (request_rec *)_r;
    if (str != NULL)
        ap_rputs(str, r);
    return;
}

static void ssl_ext_ms_display(request_rec *r, int no_table_report, int short_report)
{
    SSLSrvConfigRec *sc = mySrvConfig(r->server);

    if (sc == NULL)
        return;
    if (short_report)
        return;
    ap_rputs("<hr>\n", r);
    ap_rputs("<table cellspacing=0 cellpadding=0>\n", r);
    ap_rputs("<tr><td bgcolor=\"#000000\">\n", r);
    ap_rputs("<b><font color=\"#ffffff\" face=\"Arial,Helvetica\">SSL/TLS Session Cache Status:</font></b>\r", r);
    ap_rputs("</td></tr>\n", r);
    ap_rputs("<tr><td bgcolor=\"#ffffff\">\n", r);
    ssl_scache_status(r->server, r->pool, ssl_ext_ms_display_cb, r);
    ap_rputs("</td></tr>\n", r);
    ap_rputs("</table>\n", r);
    return;
@


1.1.1.2
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d627 1
a627 1
        OPENSSL_free(cp);
d646 1
a646 1
                OPENSSL_free(cp);
d720 2
a721 2
    OPENSSL_free(cp);
    OPENSSL_free(cp2);
@


1.1.1.3
log
@import Apache 1.3.29 and mod_ssl 2.8.16
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2003 Ralf S. Engelschall. All rights reserved.
@


