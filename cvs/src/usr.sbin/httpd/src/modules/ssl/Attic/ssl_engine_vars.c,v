head	1.19;
access;
symbols
	OPENBSD_5_5:1.18.0.40
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.36
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.34
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.32
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.30
	OPENBSD_5_0:1.18.0.28
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.26
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.24
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.20
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.22
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.18
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.16
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.14
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.12
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.10
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.8
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.6
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.3
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.2
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.1
	apache_1_3_27:1.1.1.1
	apache:1.1.1
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.10.0.6
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.18;

1.18
date	2004.12.06.13.14.10;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.17.18.57.06;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.21.13.11.36;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.18.12.43.29;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.07.20.23.06;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.19.21.31.16;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.15.02.37.49;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.29.10.21.47;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.15.22.18.19;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.30.05.35.11;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.19.11.17.23;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.25.18.29.56;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	99.12.08.02.45.50;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.10.01.23.50.44;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	99.09.30.19.46.10;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.06.29.48;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.03.01.04.29.00;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.07.19.48.14;	author henning;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.21.12.53.42;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.17.17.03.24;	author henning;	state Exp;
branches;
next	;


desc
@@


1.19
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*                      _             _
**  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
** | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
** | | | | | | (_) | (_| |   \__ \__ \ |  www.modssl.org
** |_| |_| |_|\___/ \__,_|___|___/___/_|  ftp.modssl.org
**                      |_____|
**  ssl_engine_vars.c
**  Variable Lookup Facility
*/

/* ====================================================================
 * Copyright (c) 1998-2003 Ralf S. Engelschall. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials
 *    provided with the distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by
 *     Ralf S. Engelschall <rse@@engelschall.com> for use in the
 *     mod_ssl project (http://www.modssl.org/)."
 *
 * 4. The names "mod_ssl" must not be used to endorse or promote
 *    products derived from this software without prior written
 *    permission. For written permission, please contact
 *    rse@@engelschall.com.
 *
 * 5. Products derived from this software may not be called "mod_ssl"
 *    nor may "mod_ssl" appear in their names without prior
 *    written permission of Ralf S. Engelschall.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by
 *     Ralf S. Engelschall <rse@@engelschall.com> for use in the
 *     mod_ssl project (http://www.modssl.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY RALF S. ENGELSCHALL ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL RALF S. ENGELSCHALL OR
 * HIS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 */
                             /* ``Those of you who think they
                                  know everything are very annoying
                                  to those of us who do.''
                                                  -- Unknown       */
#include "mod_ssl.h"


/*  _________________________________________________________________
**
**  Variable Lookup
**  _________________________________________________________________
*/

static char *ssl_var_lookup_header(pool *p, request_rec *r, const char *name);
static char *ssl_var_lookup_ssl(pool *p, conn_rec *c, char *var);
static char *ssl_var_lookup_ssl_cert(pool *p, X509 *xs, char *var);
static char *ssl_var_lookup_ssl_cert_dn(pool *p, X509_NAME *xsname, char *var);
static char *ssl_var_lookup_ssl_cert_valid(pool *p, ASN1_UTCTIME *tm);
static char *ssl_var_lookup_ssl_cert_serial(pool *p, X509 *xs);
static char *ssl_var_lookup_ssl_cert_chain(pool *p, STACK_OF(X509) *sk, char *var);
static char *ssl_var_lookup_ssl_cert_PEM(pool *p, X509 *xs);
static char *ssl_var_lookup_ssl_cert_verify(pool *p, conn_rec *c);
static char *ssl_var_lookup_ssl_cipher(pool *p, conn_rec *c, char *var);
static void  ssl_var_lookup_ssl_cipher_bits(SSL *ssl, int *usekeysize, int *algkeysize);
static char *ssl_var_lookup_ssl_version(pool *p, char *var);

void ssl_var_register(void)
{
    ap_hook_configure("ap::mod_ssl::var_lookup",
                      AP_HOOK_SIG6(ptr,ptr,ptr,ptr,ptr,ptr), AP_HOOK_DECLINE(NULL));
    ap_hook_register("ap::mod_ssl::var_lookup",
                     ssl_var_lookup, AP_HOOK_NOCTX);
    return;
}

void ssl_var_unregister(void)
{
    ap_hook_unregister("ap::mod_ssl::var_lookup", ssl_var_lookup);
    return;
}

char *ssl_var_lookup(pool *p, server_rec *s, conn_rec *c, request_rec *r, char *var)
{
    SSLModConfigRec *mc = myModConfig();
    char *result;
    BOOL resdup;
    time_t tc;
    struct tm *tm;

    result = NULL;
    resdup = TRUE;

    /*
     * When no pool is given try to find one
     */
    if (p == NULL) {
        if (r != NULL)
            p = r->pool;
        else if (c != NULL)
            p = c->pool;
        else
            p = mc->pPool;
    }

    /*
     * Request dependent stuff
     */
    if (r != NULL) {
        if (strcEQ(var, "HTTP_USER_AGENT"))
            result = ssl_var_lookup_header(p, r, "User-Agent");
        else if (strcEQ(var, "HTTP_REFERER"))
            result = ssl_var_lookup_header(p, r, "Referer");
        else if (strcEQ(var, "HTTP_COOKIE"))
            result = ssl_var_lookup_header(p, r, "Cookie");
        else if (strcEQ(var, "HTTP_FORWARDED"))
            result = ssl_var_lookup_header(p, r, "Forwarded");
        else if (strcEQ(var, "HTTP_HOST"))
            result = ssl_var_lookup_header(p, r, "Host");
        else if (strcEQ(var, "HTTP_PROXY_CONNECTION"))
            result = ssl_var_lookup_header(p, r, "Proxy-Connection");
        else if (strcEQ(var, "HTTP_ACCEPT"))
            result = ssl_var_lookup_header(p, r, "Accept");
        else if (strlen(var) > 5 && strcEQn(var, "HTTP:", 5))
            /* all other headers from which we are still not know about */
            result = ssl_var_lookup_header(p, r, var+5);
        else if (strcEQ(var, "THE_REQUEST"))
            result = r->the_request;
        else if (strcEQ(var, "REQUEST_METHOD"))
            result = (char *)(r->method);
        else if (strcEQ(var, "REQUEST_SCHEME"))
            result = ap_http_method(r);
        else if (strcEQ(var, "REQUEST_URI"))
            result = r->uri;
        else if (strcEQ(var, "SCRIPT_FILENAME") ||
                 strcEQ(var, "REQUEST_FILENAME"))
            result = r->filename;
        else if (strcEQ(var, "PATH_INFO"))
            result = r->path_info;
        else if (strcEQ(var, "QUERY_STRING"))
            result = r->args;
        else if (strcEQ(var, "REMOTE_HOST"))
            result = (char *)ap_get_remote_host(r->connection,
                                                r->per_dir_config, REMOTE_NAME);
        else if (strcEQ(var, "REMOTE_IDENT"))
            result = (char *)ap_get_remote_logname(r);
        else if (strcEQ(var, "IS_SUBREQ"))
            result = (r->main != NULL ? "true" : "false");
        else if (strcEQ(var, "DOCUMENT_ROOT"))
            result = (char *)ap_document_root(r);
        else if (strcEQ(var, "SERVER_ADMIN"))
            result = r->server->server_admin;
        else if (strcEQ(var, "SERVER_NAME"))
            result = (char *)ap_get_server_name(r);
        else if (strcEQ(var, "SERVER_PORT"))
            result = ap_psprintf(p, "%u", ap_get_server_port(r));
        else if (strcEQ(var, "SERVER_PROTOCOL"))
            result = r->protocol;
    }

    /*
     * Connection stuff
     */
    if (result == NULL && c != NULL) {
        if (strcEQ(var, "REMOTE_ADDR"))
            result = c->remote_ip;
        else if (strcEQ(var, "REMOTE_USER"))
            result = c->user;
        else if (strcEQ(var, "AUTH_TYPE"))
            result = c->ap_auth_type;
        else if (strlen(var) > 4 && strcEQn(var, "SSL_", 4))
            result = ssl_var_lookup_ssl(p, c, var+4);
        else if (strcEQ(var, "HTTPS")) {
            if (ap_ctx_get(c->client->ctx, "ssl") != NULL)
                result = "on";
            else
                result = "off";
        }
    }

    /*
     * Totally independent stuff
     */
    if (result == NULL) {
        if (strlen(var) > 12 && strcEQn(var, "SSL_VERSION_", 12))
            result = ssl_var_lookup_ssl_version(p, var+12);
        else if (strcEQ(var, "SERVER_SOFTWARE"))
            result = (char *)ap_get_server_version();
        else if (strcEQ(var, "API_VERSION")) {
            result = ap_psprintf(p, "%d", MODULE_MAGIC_NUMBER);
            resdup = FALSE;
        }
        else if (strcEQ(var, "TIME_YEAR")) {
            tc = time(NULL);
            tm = localtime(&tc);
            result = ap_psprintf(p, "%02d%02d",
                                 (tm->tm_year / 100) + 19, tm->tm_year % 100);
            resdup = FALSE;
        }
#define MKTIMESTR(format, tmfield) \
            tc = time(NULL); \
            tm = localtime(&tc); \
            result = ap_psprintf(p, format, tm->tmfield); \
            resdup = FALSE;
        else if (strcEQ(var, "TIME_MON")) {
            MKTIMESTR("%02d", tm_mon+1)
        }
        else if (strcEQ(var, "TIME_DAY")) {
            MKTIMESTR("%02d", tm_mday)
        }
        else if (strcEQ(var, "TIME_HOUR")) {
            MKTIMESTR("%02d", tm_hour)
        }
        else if (strcEQ(var, "TIME_MIN")) {
            MKTIMESTR("%02d", tm_min)
        }
        else if (strcEQ(var, "TIME_SEC")) {
            MKTIMESTR("%02d", tm_sec)
        }
        else if (strcEQ(var, "TIME_WDAY")) {
            MKTIMESTR("%d", tm_wday)
        }
        else if (strcEQ(var, "TIME")) {
            tc = time(NULL);
            tm = localtime(&tc);
            result = ap_psprintf(p,
                        "%02d%02d%02d%02d%02d%02d%02d", (tm->tm_year / 100) + 19,
                        (tm->tm_year % 100), tm->tm_mon+1, tm->tm_mday,
                        tm->tm_hour, tm->tm_min, tm->tm_sec);
            resdup = FALSE;
        }
        /* all other env-variables from the parent Apache process */
        else if (strlen(var) > 4 && strcEQn(var, "ENV:", 4)) {
            result = (char *)ap_table_get(r->notes, var+4);
            if (result == NULL)
                result = (char *)ap_table_get(r->subprocess_env, var+4);
            if (result == NULL)
                result = getenv(var+4);
        }
    }

    if (result != NULL && resdup)
        result = ap_pstrdup(p, result);
    if (result == NULL)
        result = "";
    return result;
}

static char *ssl_var_lookup_header(pool *p, request_rec *r, const char *name)
{
    array_header *hdrs_arr;
    table_entry *hdrs;
    int i;

    hdrs_arr = ap_table_elts(r->headers_in);
    hdrs = (table_entry *)hdrs_arr->elts;
    for (i = 0; i < hdrs_arr->nelts; ++i) {
        if (hdrs[i].key == NULL)
            continue;
        if (strcEQ(hdrs[i].key, name))
            return ap_pstrdup(p, hdrs[i].val);
    }
    return NULL;
}

static char *ssl_var_lookup_ssl(pool *p, conn_rec *c, char *var)
{
    char *result;
    X509 *xs;
    STACK_OF(X509) *sk;
    SSL *ssl;

    result = NULL;

    ssl = ap_ctx_get(c->client->ctx, "ssl");
    if (strlen(var) > 8 && strcEQn(var, "VERSION_", 8)) {
        result = ssl_var_lookup_ssl_version(p, var+8);
    }
    else if (ssl != NULL && strcEQ(var, "PROTOCOL")) {
        result = (char *)SSL_get_version(ssl);
    }
    else if (ssl != NULL && strcEQ(var, "SESSION_ID")) {
        SSL_SESSION *pSession = SSL_get_session(ssl);
        result = ap_pstrdup(p, SSL_SESSION_id2sz(pSession->session_id, 
                                                 pSession->session_id_length));
    }
    else if (ssl != NULL && strlen(var) >= 6 && strcEQn(var, "CIPHER", 6)) {
        result = ssl_var_lookup_ssl_cipher(p, c, var+6);
    }
    else if (ssl != NULL && strlen(var) > 18 && strcEQn(var, "CLIENT_CERT_CHAIN_", 18)) {
        sk = SSL_get_peer_cert_chain(ssl);
        result = ssl_var_lookup_ssl_cert_chain(p, sk, var+18);
    }
    else if (ssl != NULL && strcEQ(var, "CLIENT_VERIFY")) {
        result = ssl_var_lookup_ssl_cert_verify(p, c);
    }
    else if (ssl != NULL && strlen(var) > 7 && strcEQn(var, "CLIENT_", 7)) {
        if ((xs = SSL_get_peer_certificate(ssl)) != NULL) {
            result = ssl_var_lookup_ssl_cert(p, xs, var+7);
            X509_free(xs);
        }
    }
    else if (ssl != NULL && strlen(var) > 7 && strcEQn(var, "SERVER_", 7)) {
        if ((xs = SSL_get_certificate(ssl)) != NULL) {
            result = ssl_var_lookup_ssl_cert(p, xs, var+7);
            /* SSL_get_certificate() as of OpenSSL 0.9.7a does not increment
               the reference count the same way SSL_get_peer_certificate does,
               so no need to X509_free(xs) the stuff here. */
        }
    }
    return result;
}

static char *ssl_var_lookup_ssl_cert(pool *p, X509 *xs, char *var)
{
    char *result;
    BOOL resdup;
    X509_NAME *xsname;
    int nid;
    char *cp;

    result = NULL;
    resdup = TRUE;

    if (strcEQ(var, "M_VERSION")) {
        result = ap_psprintf(p, "%lu", X509_get_version(xs)+1);
        resdup = FALSE;
    }
    else if (strcEQ(var, "M_SERIAL")) {
        result = ssl_var_lookup_ssl_cert_serial(p, xs);
    }
    else if (strcEQ(var, "V_START")) {
        result = ssl_var_lookup_ssl_cert_valid(p, X509_get_notBefore(xs));
    }
    else if (strcEQ(var, "V_END")) {
        result = ssl_var_lookup_ssl_cert_valid(p, X509_get_notAfter(xs));
    }
    else if (strcEQ(var, "S_DN")) {
        xsname = X509_get_subject_name(xs);
        cp = X509_NAME_oneline(xsname, NULL, 0);
        result = ap_pstrdup(p, cp);
        OPENSSL_free(cp);
        resdup = FALSE;
    }
    else if (strlen(var) > 5 && strcEQn(var, "S_DN_", 5)) {
        xsname = X509_get_subject_name(xs);
        result = ssl_var_lookup_ssl_cert_dn(p, xsname, var+5);
        resdup = FALSE;
    }
    else if (strcEQ(var, "I_DN")) {
        xsname = X509_get_issuer_name(xs);
        cp = X509_NAME_oneline(xsname, NULL, 0);
        result = ap_pstrdup(p, cp);
        OPENSSL_free(cp);
        resdup = FALSE;
    }
    else if (strlen(var) > 5 && strcEQn(var, "I_DN_", 5)) {
        xsname = X509_get_issuer_name(xs);
        result = ssl_var_lookup_ssl_cert_dn(p, xsname, var+5);
        resdup = FALSE;
    }
    else if (strcEQ(var, "A_SIG")) {
        nid = OBJ_obj2nid(xs->cert_info->signature->algorithm);
        result = ap_pstrdup(p, (nid == NID_undef) ? "UNKNOWN" : OBJ_nid2ln(nid));
        resdup = FALSE;
    }
    else if (strcEQ(var, "A_KEY")) {
        nid = OBJ_obj2nid(xs->cert_info->key->algor->algorithm);
        result = ap_pstrdup(p, (nid == NID_undef) ? "UNKNOWN" : OBJ_nid2ln(nid));
        resdup = FALSE;
    }
    else if (strcEQ(var, "CERT")) {
        result = ssl_var_lookup_ssl_cert_PEM(p, xs);
    }

    if (result != NULL && resdup)
        result = ap_pstrdup(p, result);
    return result;
}

static const struct {
    char *name;
    int   nid;
} ssl_var_lookup_ssl_cert_dn_rec[] = {
    { "C",     NID_countryName            },
    { "ST",    NID_stateOrProvinceName    }, /* officially    (RFC2156) */
    { "SP",    NID_stateOrProvinceName    }, /* compatibility (SSLeay)  */
    { "L",     NID_localityName           },
    { "O",     NID_organizationName       },
    { "OU",    NID_organizationalUnitName },
    { "CN",    NID_commonName             },
    { "T",     NID_title                  },
    { "I",     NID_initials               },
    { "G",     NID_givenName              },
    { "S",     NID_surname                },
    { "D",     NID_description            },
    { "UID",   NID_x500UniqueIdentifier   },
    { "Email", NID_pkcs9_emailAddress     },
    { NULL,    0                          }
};

static char *ssl_var_lookup_ssl_cert_dn(pool *p, X509_NAME *xsname, char *var)
{
    char *result;
    X509_NAME_ENTRY *xsne;
    int i, j, n;

    result = NULL;

    for (i = 0; ssl_var_lookup_ssl_cert_dn_rec[i].name != NULL; i++) {
        if (strEQ(var, ssl_var_lookup_ssl_cert_dn_rec[i].name)) {
            for (j = 0; j < sk_X509_NAME_ENTRY_num(xsname->entries); j++) {
                xsne = sk_X509_NAME_ENTRY_value(xsname->entries, j);
                n = OBJ_obj2nid(xsne->object);
                if (n == ssl_var_lookup_ssl_cert_dn_rec[i].nid) {
                    result = ap_palloc(p, xsne->value->length+1);
                    ap_cpystrn(result, (char *)xsne->value->data, xsne->value->length+1);
                    result[xsne->value->length] = NUL;
                    break;
                }
            }
            break;
        }
    }
    return result;
}

static char *ssl_var_lookup_ssl_cert_valid(pool *p, ASN1_UTCTIME *tm)
{
    char *result;
    BIO* bio;
    int n;

    if ((bio = BIO_new(BIO_s_mem())) == NULL)
        return NULL;
    ASN1_UTCTIME_print(bio, tm);
    n = BIO_pending(bio);
    result = ap_pcalloc(p, n+1);
    n = BIO_read(bio, result, n);
    result[n] = NUL;
    BIO_free(bio);
    return result;
}

static char *ssl_var_lookup_ssl_cert_serial(pool *p, X509 *xs)
{
    char *result;
    BIO *bio;
    int n;

    if ((bio = BIO_new(BIO_s_mem())) == NULL)
        return NULL;
    i2a_ASN1_INTEGER(bio, X509_get_serialNumber(xs));
    n = BIO_pending(bio);
    result = ap_pcalloc(p, n+1);
    n = BIO_read(bio, result, n);
    result[n] = NUL;
    BIO_free(bio);
    return result;
}

static char *ssl_var_lookup_ssl_cert_chain(pool *p, STACK_OF(X509) *sk, char *var)
{
    char *result;
    X509 *xs;
    int n;

    result = NULL;

    if (strspn(var, "0123456789") == strlen(var)) {
        n = atoi(var);
        if (n < sk_X509_num(sk)) {
            xs = sk_X509_value(sk, n);
            result = ssl_var_lookup_ssl_cert_PEM(p, xs);
        }
    }

    return result;
}

static char *ssl_var_lookup_ssl_cert_PEM(pool *p, X509 *xs)
{
    char *result;
    BIO *bio;
    int n;

    if ((bio = BIO_new(BIO_s_mem())) == NULL)
        return NULL;
    PEM_write_bio_X509(bio, xs);
    n = BIO_pending(bio);
    result = ap_pcalloc(p, n+1);
    n = BIO_read(bio, result, n);
    result[n] = NUL;
    BIO_free(bio);
    return result;
}

static char *ssl_var_lookup_ssl_cert_verify(pool *p, conn_rec *c)
{
    char *result;
    long vrc;
    char *verr;
    char *vinfo;
    SSL *ssl;
    X509 *xs;

    result = NULL;
    ssl   = ap_ctx_get(c->client->ctx, "ssl");
    verr  = ap_ctx_get(c->client->ctx, "ssl::verify::error");
    vinfo = ap_ctx_get(c->client->ctx, "ssl::verify::info");
    vrc   = SSL_get_verify_result(ssl);
    xs    = SSL_get_peer_certificate(ssl);

    if (vrc == X509_V_OK && verr == NULL && vinfo == NULL && xs == NULL)
        /* no client verification done at all */
        result = "NONE";
    else if (vrc == X509_V_OK && verr == NULL && vinfo == NULL && xs != NULL)
        /* client verification done successful */
        result = "SUCCESS";
    else if (vrc == X509_V_OK && vinfo != NULL && strEQ(vinfo, "GENEROUS"))
        /* client verification done in generous way */
        result = "GENEROUS";
    else
        /* client verification failed */
        result = ap_psprintf(p, "FAILED:%s", verr);

    if (xs != NULL)
        X509_free(xs);

    return result;
}

static char *ssl_var_lookup_ssl_cipher(pool *p, conn_rec *c, char *var)
{
    char *result;
    BOOL resdup;
    int usekeysize, algkeysize;
    SSL *ssl;

    result = NULL;
    resdup = TRUE;

    ssl = ap_ctx_get(c->client->ctx, "ssl");
    ssl_var_lookup_ssl_cipher_bits(ssl, &usekeysize, &algkeysize);

    if (strEQ(var, ""))
        result = (ssl != NULL ? (char *)SSL_get_cipher_name(ssl) : NULL);
    else if (strcEQ(var, "_EXPORT"))
        result = (usekeysize < 56 ? "true" : "false");
    else if (strcEQ(var, "_USEKEYSIZE")) {
        result = ap_psprintf(p, "%d", usekeysize);
        resdup = FALSE;
    }
    else if (strcEQ(var, "_ALGKEYSIZE")) {
        result = ap_psprintf(p, "%d", algkeysize);
        resdup = FALSE;
    }

    if (result != NULL && resdup)
        result = ap_pstrdup(p, result);
    return result;
}

static void ssl_var_lookup_ssl_cipher_bits(SSL *ssl, int *usekeysize, int *algkeysize)
{
    SSL_CIPHER *cipher;

    *usekeysize = 0;
    *algkeysize = 0;
    if (ssl != NULL)
        if ((cipher = SSL_get_current_cipher(ssl)) != NULL)
            *usekeysize = SSL_CIPHER_get_bits(cipher, algkeysize);
    return;
}

static char *ssl_var_lookup_ssl_version(pool *p, char *var)
{
    char *result;
    char *cp, *cp2;

    result = NULL;

    if (strEQ(var, "PRODUCT")) {
#if defined(SSL_PRODUCT_NAME) && defined(SSL_PRODUCT_VERSION)
        result = ap_psprintf(p, "%s/%s", SSL_PRODUCT_NAME, SSL_PRODUCT_VERSION);
#else
        result = NULL;
#endif
    }
    else if (strEQ(var, "INTERFACE")) {
        result = ap_psprintf(p, "mod_ssl/%s", MOD_SSL_VERSION);
    }
    else if (strEQ(var, "LIBRARY")) {
        result = ap_pstrdup(p, SSL_LIBRARY_TEXT);
        if ((cp = strchr(result, ' ')) != NULL) {
            *cp = '/';
            if ((cp2 = strchr(cp, ' ')) != NULL)
                *cp2 = NUL;
        }
    }
    return result;
}

@


1.18
log
@kill more dead code, mostly inside #ifdef SOMENONSENSEONSTUPIDOSES
joint work by Michael Knudsen <e@@molioner.dk> and Daniel Ouellet
<daniel@@presscom.net> with my input
no change in binaries
@
text
@@


1.17
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@a415 1
#if SSL_LIBRARY_VERSION >= 0x00907000
a416 3
#else
    { "UID",   NID_uniqueIdentifier       },
#endif
@


1.16
log
@merge apache 1.3.29 and mod_ssl 2.8.16
ok brad@@
@
text
@a440 3
#ifdef CHARSET_EBCDIC
                    ascii2ebcdic(result, result, xsne->value->length);
#endif /* CHARSET_EBCDIC */
@


1.15
log
@merge
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2001 Ralf S. Engelschall. All rights reserved.
@


1.14
log
@kill unused #define which was a workaround with old OpenSSL versions
from David Krause, Thanks!
@
text
@d317 1
a317 1
        if ((xs = SSL_get_peer_certificate(ssl)) != NULL)
d319 2
d323 1
a323 1
        if ((xs = SSL_get_certificate(ssl)) != NULL)
d325 4
d361 1
a361 1
        free(cp);
d373 1
a373 1
        free(cp);
d552 4
@


1.13
log
@merge apache 1.3.27 and mod_ssl 2.8.11
@
text
@a393 4
#ifndef NID_uniqueIdentifier
#define NID_uniqueIdentifier             102
#endif

@


1.12
log
@merge
@
text
@d311 1
a311 1
        result = ssl_var_lookup_ssl_cert_chain(p, sk, var+17);
@


1.11
log
@Tweak to make this work with OpenSSL 0.9.7
@
text
@d414 3
d418 1
@


1.10
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d394 4
@


1.9
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2000 Ralf S. Engelschall. All rights reserved.
@


1.8
log
@mod_ssl 2.6.4 merge
From brad@@
@
text
@d303 2
a304 2
        result = ap_pstrdup(p, ssl_scache_id2sz(pSession->session_id, 
                                                pSession->session_id_length));
@


1.7
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d84 1
a84 1
static void  ssl_var_lookup_ssl_cipher_bits(char *cipher, int *usekeysize, int *algkeysize);
a548 1
    char *cipher;
d555 6
a560 8
    if (strEQ(var, "")) {
        ssl = ap_ctx_get(c->client->ctx, "ssl");
        result = (char *)SSL_get_cipher_name(ssl);
    }
    else if (strcEQ(var, "_EXPORT")) {
        ssl = ap_ctx_get(c->client->ctx, "ssl");
        cipher = (char *)SSL_get_cipher_name(ssl);
        ssl_var_lookup_ssl_cipher_bits(cipher, &usekeysize, &algkeysize);
a561 1
    }
a562 3
        ssl = ap_ctx_get(c->client->ctx, "ssl");
        cipher = (char *)SSL_get_cipher_name(ssl);
        ssl_var_lookup_ssl_cipher_bits(cipher, &usekeysize, &algkeysize);
a566 3
        ssl = ap_ctx_get(c->client->ctx, "ssl");
        cipher = (char *)SSL_get_cipher_name(ssl);
        ssl_var_lookup_ssl_cipher_bits(cipher, &usekeysize, &algkeysize);
d576 1
a576 58
/*
 * This structure is used instead of SSL_get_cipher_bits() because
 * this OpenSSL function has rounding problems, but we want the
 * correct sizes.
 */
static const struct {
    char *szName;
    int nUseKeySize;
    int nAlgKeySize;
} ssl_var_lookup_ssl_cipher_bits_rec[] = {

    { TLS1_TXT_RSA_EXPORT1024_WITH_RC4_56_MD5     /*EXP1024-RC4-MD5*/,    56, 128 },
    { TLS1_TXT_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5 /*EXP1024-RC2-CBC-MD5*/,56, 128 },
    { TLS1_TXT_RSA_EXPORT1024_WITH_DES_CBC_SHA    /*EXP1024-DES-CBC-SHA*/,56,  56 },

    { SSL3_TXT_RSA_IDEA_128_SHA          /*IDEA-CBC-SHA*/,           128, 128 },
    { SSL3_TXT_RSA_NULL_MD5              /*NULL-MD5*/,                 0,   0 },
    { SSL3_TXT_RSA_NULL_SHA              /*NULL-SHA*/,                 0,   0 },
    { SSL3_TXT_RSA_RC4_40_MD5            /*EXP-RC4-MD5*/,             40, 128 },
    { SSL3_TXT_RSA_RC4_128_MD5           /*RC4-MD5*/,                128, 128 },
    { SSL3_TXT_RSA_RC4_128_SHA           /*RC4-SHA*/,                128, 128 },
    { SSL3_TXT_RSA_RC2_40_MD5            /*EXP-RC2-CBC-MD5*/,         40, 128 },
    { SSL3_TXT_RSA_DES_40_CBC_SHA        /*EXP-DES-CBC-SHA*/,         40,  56 },
    { SSL3_TXT_RSA_DES_64_CBC_SHA        /*DES-CBC-SHA*/ ,            56,  56 },
    { SSL3_TXT_RSA_DES_192_CBC3_SHA      /*DES-CBC3-SHA*/ ,          168, 168 },
    { SSL3_TXT_DH_DSS_DES_40_CBC_SHA     /*EXP-DH-DSS-DES-CBC-SHA*/,  40,  56 },
    { SSL3_TXT_DH_DSS_DES_64_CBC_SHA     /*DH-DSS-DES-CBC-SHA*/,      56,  56 },
    { SSL3_TXT_DH_DSS_DES_192_CBC3_SHA   /*DH-DSS-DES-CBC3-SHA*/,    168, 168 },
    { SSL3_TXT_DH_RSA_DES_40_CBC_SHA     /*EXP-DH-RSA-DES-CBC-SHA*/,  40,  56 },
    { SSL3_TXT_DH_RSA_DES_64_CBC_SHA     /*DH-RSA-DES-CBC-SHA*/,      56,  56 },
    { SSL3_TXT_DH_RSA_DES_192_CBC3_SHA   /*DH-RSA-DES-CBC3-SHA*/,    168, 168 },
    { SSL3_TXT_EDH_DSS_DES_40_CBC_SHA    /*EXP-EDH-DSS-DES-CBC-SHA*/, 40,  56 },
    { SSL3_TXT_EDH_DSS_DES_64_CBC_SHA    /*EDH-DSS-DES-CBC-SHA*/,     56,  56 },
    { SSL3_TXT_EDH_DSS_DES_192_CBC3_SHA  /*EDH-DSS-DES-CBC3-SHA*/,   168, 168 },
    { SSL3_TXT_EDH_RSA_DES_40_CBC_SHA    /*EXP-EDH-RSA-DES-CBC*/,     40,  56 },
    { SSL3_TXT_EDH_RSA_DES_64_CBC_SHA    /*EDH-RSA-DES-CBC-SHA*/,     56,  56 },
    { SSL3_TXT_EDH_RSA_DES_192_CBC3_SHA  /*EDH-RSA-DES-CBC3-SHA*/,   168, 168 },
    { SSL3_TXT_ADH_RC4_40_MD5            /*EXP-ADH-RC4-MD5*/,         40, 128 },
    { SSL3_TXT_ADH_RC4_128_MD5           /*ADH-RC4-MD5*/,            128, 128 },
    { SSL3_TXT_ADH_DES_40_CBC_SHA        /*EXP-ADH-DES-CBC-SHA*/,     40, 128 },
    { SSL3_TXT_ADH_DES_64_CBC_SHA        /*ADH-DES-CBC-SHA*/,         56,  56 },
    { SSL3_TXT_ADH_DES_192_CBC_SHA       /*ADH-DES-CBC3-SHA*/,       168, 168 },
    { SSL3_TXT_FZA_DMS_NULL_SHA          /*FZA-NULL-SHA*/,             0,   0 },
    { SSL3_TXT_FZA_DMS_FZA_SHA           /*FZA-FZA-CBC-SHA*/,          0,   0 },
    { SSL3_TXT_FZA_DMS_RC4_SHA           /*FZA-RC4-SHA*/,            128, 128 },

    { SSL2_TXT_IDEA_128_CBC_WITH_MD5     /*IDEA-CBC-MD5*/,           128, 128 },
    { SSL2_TXT_DES_64_CFB64_WITH_MD5_1   /*DES-CFB-M1*/,              56,  56 },
    { SSL2_TXT_RC2_128_CBC_WITH_MD5      /*RC2-CBC-MD5*/,            128, 128 },
    { SSL2_TXT_DES_64_CBC_WITH_MD5       /*DES-CBC-MD5*/,             56,  56 },
    { SSL2_TXT_DES_192_EDE3_CBC_WITH_MD5 /*DES-CBC3-MD5*/,           168, 168 },
    { SSL2_TXT_RC4_64_WITH_MD5           /*RC4-64-MD5*/,              64,  64 },
    { SSL2_TXT_NULL                      /*NULL*/,                     0,   0 },

    { NULL,                                                            0,   0 }
};

static void ssl_var_lookup_ssl_cipher_bits(char *cipher, int *usekeysize, int *algkeysize)
d578 1
a578 1
    int n;
d582 3
a584 7
    for (n = 0; ssl_var_lookup_ssl_cipher_bits_rec[n].szName; n++) {
        if (strEQ(cipher, ssl_var_lookup_ssl_cipher_bits_rec[n].szName)) {
            *algkeysize = ssl_var_lookup_ssl_cipher_bits_rec[n].nAlgKeySize;
            *usekeysize = ssl_var_lookup_ssl_cipher_bits_rec[n].nUseKeySize;
            break;
        }
    }
@


1.6
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d299 1
a299 1
        result = SSL_get_version(ssl);
@


1.5
log
@mod_ssl 2.4.9 merge
@
text
@d12 1
a12 1
 * Copyright (c) 1998-1999 Ralf S. Engelschall. All rights reserved.
@


1.4
log
@Sync with mod_ssl v2.4.5. ok beck@@.
@
text
@d192 6
d399 2
a400 1
    { "SP",    NID_stateOrProvinceName    },
d405 6
@


1.3
log
@Sync with mod_ssl v2.4.4. ok beck@@.
@
text
@a594 1
    { SSL3_TXT_RSA_IDEA_128_SHA          /*IDEA-CBC-MD5*/,           128, 128 },
d619 1
@


1.2
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d82 1
d307 3
d475 1
a475 1
        if (sk_X509_num(sk) >= n) {
d498 31
@


1.1
log
@mod_ssl-2.2.3-1.3.4 (will require libssl-1.1 for https to work, but
mostly harmless otherwise).
@
text
@d2 4
a5 4
**  _ __ ___   ___   __| |    ___ ___| |
** | '_ ` _ \ / _ \ / _` |   / __/ __| |
** | | | | | | (_) | (_| |   \__ \__ \ | mod_ssl - Apache Interface to SSLeay
** |_| |_| |_|\___/ \__,_|___|___/___/_| http://www.engelschall.com/sw/mod_ssl/
d30 1
a30 1
 *     mod_ssl project (http://www.engelschall.com/sw/mod_ssl/)."
d45 1
a45 1
 *     mod_ssl project (http://www.engelschall.com/sw/mod_ssl/)."
d80 1
a80 1
static char *ssl_var_lookup_ssl_cert_chain(pool *p, STACK *sk, char *var);
d148 1
a148 1
            result = r->method;
d282 1
a282 1
    STACK *sk;
d287 1
d291 1
a291 2
    else if (strcEQ(var, "PROTOCOL")) {
        ssl = ap_ctx_get(c->client->ctx, "ssl");
d294 6
a299 1
    else if (strlen(var) >= 6 && strcEQn(var, "CIPHER", 6)) {
d302 1
a302 2
    else if (strlen(var) > 18 && strcEQn(var, "CLIENT_CERT_CHAIN_", 18)) {
        ssl = ap_ctx_get(c->client->ctx, "ssl");
d306 1
a306 2
    else if (strlen(var) > 7 && strcEQn(var, "CLIENT_", 7)) {
        ssl = ap_ctx_get(c->client->ctx, "ssl");
d310 1
a310 2
    else if (strlen(var) > 7 && strcEQn(var, "SERVER_", 7)) {
        ssl = ap_ctx_get(c->client->ctx, "ssl");
d408 2
a409 2
            for (j = 0; j < sk_num(xsname->entries); j++) {
                xsne = (X509_NAME_ENTRY *)sk_value(xsname->entries, j);
d414 3
d447 1
a447 1
    BIO* bio;
d461 1
a461 1
static char *ssl_var_lookup_ssl_cert_chain(pool *p, STACK *sk, char *var)
d471 2
a472 2
        if (sk_num(sk) >= n) {
            xs = (X509 *)sk_value(sk, n);
d510 1
a510 1
        result = SSL_get_cipher_name(ssl);
d514 1
a514 1
        cipher = SSL_get_cipher_name(ssl);
d520 1
a520 1
        cipher = SSL_get_cipher_name(ssl);
d527 1
a527 1
        cipher = SSL_get_cipher_name(ssl);
d540 1
a540 1
 * this SSLeay function has rounding problems, but we want the
d548 5
d584 1
d591 1
d629 1
a629 1
        result = ap_pstrdup(p, SSLeay_version(SSLEAY_VERSION));
@


1.1.1.1
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@d2 4
a5 4
**  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
** | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
** | | | | | | (_) | (_| |   \__ \__ \ |  www.modssl.org
** |_| |_| |_|\___/ \__,_|___|___/___/_|  ftp.modssl.org
d12 1
a12 1
 * Copyright (c) 1998-2001 Ralf S. Engelschall. All rights reserved.
d30 1
a30 1
 *     mod_ssl project (http://www.modssl.org/)."
d45 1
a45 1
 *     mod_ssl project (http://www.modssl.org/)."
d80 1
a80 1
static char *ssl_var_lookup_ssl_cert_chain(pool *p, STACK_OF(X509) *sk, char *var);
a81 1
static char *ssl_var_lookup_ssl_cert_verify(pool *p, conn_rec *c);
d83 1
a83 1
static void  ssl_var_lookup_ssl_cipher_bits(SSL *ssl, int *usekeysize, int *algkeysize);
d148 1
a148 1
            result = (char *)(r->method);
a190 6
        else if (strcEQ(var, "HTTPS")) {
            if (ap_ctx_get(c->client->ctx, "ssl") != NULL)
                result = "on";
            else
                result = "off";
        }
d282 1
a282 1
    STACK_OF(X509) *sk;
a286 1
    ssl = ap_ctx_get(c->client->ctx, "ssl");
d290 3
a292 7
    else if (ssl != NULL && strcEQ(var, "PROTOCOL")) {
        result = (char *)SSL_get_version(ssl);
    }
    else if (ssl != NULL && strcEQ(var, "SESSION_ID")) {
        SSL_SESSION *pSession = SSL_get_session(ssl);
        result = ap_pstrdup(p, SSL_SESSION_id2sz(pSession->session_id, 
                                                 pSession->session_id_length));
d294 1
a294 1
    else if (ssl != NULL && strlen(var) >= 6 && strcEQn(var, "CIPHER", 6)) {
d297 2
a298 1
    else if (ssl != NULL && strlen(var) > 18 && strcEQn(var, "CLIENT_CERT_CHAIN_", 18)) {
d300 1
a300 1
        result = ssl_var_lookup_ssl_cert_chain(p, sk, var+18);
d302 2
a303 4
    else if (ssl != NULL && strcEQ(var, "CLIENT_VERIFY")) {
        result = ssl_var_lookup_ssl_cert_verify(p, c);
    }
    else if (ssl != NULL && strlen(var) > 7 && strcEQn(var, "CLIENT_", 7)) {
d307 2
a308 1
    else if (ssl != NULL && strlen(var) > 7 && strcEQn(var, "SERVER_", 7)) {
d387 1
a387 2
    { "ST",    NID_stateOrProvinceName    }, /* officially    (RFC2156) */
    { "SP",    NID_stateOrProvinceName    }, /* compatibility (SSLeay)  */
a391 10
    { "T",     NID_title                  },
    { "I",     NID_initials               },
    { "G",     NID_givenName              },
    { "S",     NID_surname                },
    { "D",     NID_description            },
#if SSL_LIBRARY_VERSION >= 0x00907000
    { "UID",   NID_x500UniqueIdentifier   },
#else
    { "UID",   NID_uniqueIdentifier       },
#endif
d406 2
a407 2
            for (j = 0; j < sk_X509_NAME_ENTRY_num(xsname->entries); j++) {
                xsne = sk_X509_NAME_ENTRY_value(xsname->entries, j);
a411 3
#ifdef CHARSET_EBCDIC
                    ascii2ebcdic(result, result, xsne->value->length);
#endif /* CHARSET_EBCDIC */
d442 1
a442 1
    BIO *bio;
d456 1
a456 1
static char *ssl_var_lookup_ssl_cert_chain(pool *p, STACK_OF(X509) *sk, char *var)
d466 2
a467 2
        if (n < sk_X509_num(sk)) {
            xs = sk_X509_value(sk, n);
a491 31
static char *ssl_var_lookup_ssl_cert_verify(pool *p, conn_rec *c)
{
    char *result;
    long vrc;
    char *verr;
    char *vinfo;
    SSL *ssl;
    X509 *xs;

    result = NULL;
    ssl   = ap_ctx_get(c->client->ctx, "ssl");
    verr  = ap_ctx_get(c->client->ctx, "ssl::verify::error");
    vinfo = ap_ctx_get(c->client->ctx, "ssl::verify::info");
    vrc   = SSL_get_verify_result(ssl);
    xs    = SSL_get_peer_certificate(ssl);

    if (vrc == X509_V_OK && verr == NULL && vinfo == NULL && xs == NULL)
        /* no client verification done at all */
        result = "NONE";
    else if (vrc == X509_V_OK && verr == NULL && vinfo == NULL && xs != NULL)
        /* client verification done successful */
        result = "SUCCESS";
    else if (vrc == X509_V_OK && vinfo != NULL && strEQ(vinfo, "GENEROUS"))
        /* client verification done in generous way */
        result = "GENEROUS";
    else
        /* client verification failed */
        result = ap_psprintf(p, "FAILED:%s", verr);
    return result;
}

d496 1
d503 8
a510 6
    ssl = ap_ctx_get(c->client->ctx, "ssl");
    ssl_var_lookup_ssl_cipher_bits(ssl, &usekeysize, &algkeysize);

    if (strEQ(var, ""))
        result = (ssl != NULL ? (char *)SSL_get_cipher_name(ssl) : NULL);
    else if (strcEQ(var, "_EXPORT"))
d512 1
d514 3
d521 3
d533 51
a583 1
static void ssl_var_lookup_ssl_cipher_bits(SSL *ssl, int *usekeysize, int *algkeysize)
d585 1
a585 1
    SSL_CIPHER *cipher;
d589 7
a595 3
    if (ssl != NULL)
        if ((cipher = SSL_get_current_cipher(ssl)) != NULL)
            *usekeysize = SSL_CIPHER_get_bits(cipher, algkeysize);
d617 1
a617 1
        result = ap_pstrdup(p, SSL_LIBRARY_TEXT);
@


1.1.1.2
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d317 1
a317 1
        if ((xs = SSL_get_peer_certificate(ssl)) != NULL) {
a318 2
            X509_free(xs);
        }
d321 1
a321 1
        if ((xs = SSL_get_certificate(ssl)) != NULL) {
a322 4
            /* SSL_get_certificate() as of OpenSSL 0.9.7a does not increment
               the reference count the same way SSL_get_peer_certificate does,
               so no need to X509_free(xs) the stuff here. */
        }
d355 1
a355 1
        OPENSSL_free(cp);
d367 1
a367 1
        OPENSSL_free(cp);
a545 4

    if (xs != NULL)
        X509_free(xs);

@


1.1.1.3
log
@import Apache 1.3.29 and mod_ssl 2.8.16
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2003 Ralf S. Engelschall. All rights reserved.
@


