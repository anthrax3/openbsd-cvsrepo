head	1.13;
access;
symbols
	OPENBSD_5_5:1.12.0.40
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.36
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.34
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.32
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.30
	OPENBSD_5_0:1.12.0.28
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.26
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.24
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.20
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.22
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.18
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.16
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.14
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.12
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.2
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.1
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.1
	apache_1_3_27:1.1.1.1
	apache:1.1.1
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.12;

1.12
date	2004.12.06.13.14.10;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.16.18.42.09;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.17.18.57.06;	author henning;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2002.10.07.20.23.06;	author henning;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2002.07.19.21.31.16;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.28.21.22.42;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.29.10.21.47;	author beck;	state Exp;
branches
	1.5.2.1
	1.5.4.1;
next	1.4;

1.4
date	2000.03.19.11.17.23;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.25.18.29.56;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.06.29.47;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.03.01.04.28.59;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.07.19.48.14;	author henning;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.11.17.17.03.24;	author henning;	state Exp;
branches;
next	;

1.5.2.1
date	2002.03.13.20.21.01;	author miod;	state Exp;
branches;
next	;

1.5.4.1
date	2002.03.13.21.06.16;	author jason;	state Exp;
branches;
next	;

1.8.4.1
date	2004.06.11.08.40.55;	author brad;	state Exp;
branches;
next	;

1.9.2.1
date	2004.06.11.08.34.50;	author brad;	state Exp;
branches;
next	;


desc
@@


1.13
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*                      _             _
**  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
** | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
** | | | | | | (_) | (_| |   \__ \__ \ |  www.modssl.org
** |_| |_| |_|\___/ \__,_|___|___/___/_|  ftp.modssl.org
**                      |_____|
**  ssl_engine_rand.c
**  Random Number Generator Seeding
*/

/* ====================================================================
 * Copyright (c) 1998-2003 Ralf S. Engelschall. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials
 *    provided with the distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by
 *     Ralf S. Engelschall <rse@@engelschall.com> for use in the
 *     mod_ssl project (http://www.modssl.org/)."
 *
 * 4. The names "mod_ssl" must not be used to endorse or promote
 *    products derived from this software without prior written
 *    permission. For written permission, please contact
 *    rse@@engelschall.com.
 *
 * 5. Products derived from this software may not be called "mod_ssl"
 *    nor may "mod_ssl" appear in their names without prior
 *    written permission of Ralf S. Engelschall.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by
 *     Ralf S. Engelschall <rse@@engelschall.com> for use in the
 *     mod_ssl project (http://www.modssl.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY RALF S. ENGELSCHALL ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL RALF S. ENGELSCHALL OR
 * HIS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 */
                             /* ``The generation of random
                                  numbers is too important
                                  to be left to chance.'' */

#include "mod_ssl.h"


/*  _________________________________________________________________
**
**  Support for better seeding of SSL library's RNG
**  _________________________________________________________________
*/

static int ssl_rand_choosenum(int);
static int ssl_rand_feedfp(pool *, FILE *, int);

int ssl_rand_seed(server_rec *s, pool *p, ssl_rsctx_t nCtx, char *prefix)
{
    SSLModConfigRec *mc;
    array_header *apRandSeed;
    ssl_randseed_t *pRandSeeds;
    ssl_randseed_t *pRandSeed;
    unsigned char stackdata[256];
    int nReq, nDone;
    FILE *fp;
    int i, n, l;
    time_t t;
    pid_t pid;
    int m;

    mc = myModConfig();
    nReq  = 0;
    nDone = 0;
    apRandSeed = mc->aRandSeed;
    pRandSeeds = (ssl_randseed_t *)apRandSeed->elts;
    for (i = 0; i < apRandSeed->nelts; i++) {
        pRandSeed = &pRandSeeds[i];
        if (pRandSeed->nCtx == nCtx) {
            nReq += pRandSeed->nBytes;
            if (pRandSeed->nSrc == SSL_RSSRC_FILE) {
                /*
                 * seed in contents of an external file
                 */
                if ((fp = ap_pfopen(p, pRandSeed->cpPath, "r")) == NULL)
                    continue;
                nDone += ssl_rand_feedfp(p, fp, pRandSeed->nBytes);
                ap_pfclose(p, fp);
            }
            else if (pRandSeed->nSrc == SSL_RSSRC_EXEC) {
                /*
                 * seed in contents generated by an external program
                 */
                if ((fp = ssl_util_ppopen(s, p, ap_psprintf(p, "%s %d",
                                          pRandSeed->cpPath, pRandSeed->nBytes))) == NULL)
                    continue;
                nDone += ssl_rand_feedfp(p, fp, pRandSeed->nBytes);
                ssl_util_ppclose(s, p, fp);
            }
            else if (pRandSeed->nSrc == SSL_RSSRC_EGD) {
                /*
                 * seed in contents provided by the external
                 * Entropy Gathering Daemon (EGD)
                 */
                if ((n = RAND_egd_bytes(pRandSeed->cpPath, pRandSeed->nBytes)) == -1)
                    continue;
                nDone += n;
            }
            else if (pRandSeed->nSrc == SSL_RSSRC_BUILTIN) {
                /*
                 * seed in the current time (usually just 4 bytes)
                 */
                t = time(NULL);
                l = sizeof(time_t);
                RAND_seed((unsigned char *)&t, l);
                nDone += l;

                /*
                 * seed in the current process id (usually just 4 bytes)
                 */
                pid = getpid();
                l = sizeof(pid_t);
                RAND_seed((unsigned char *)&pid, l);
                nDone += l;
                
                /*
                 * seed in some current state of the run-time stack (128 bytes)
                 */
                n = ssl_rand_choosenum(sizeof(stackdata)-128-1);
                RAND_seed(stackdata+n, 128);
                nDone += 128;

                /*
                 * seed in extract data from the current scoreboard
                 */
                if (ap_scoreboard_image != NULL && SCOREBOARD_SIZE > 16) {
                    if ((m = ((SCOREBOARD_SIZE / 2) - 1)) > 1024)
                        m = 1024;
                    n = ssl_rand_choosenum(m);
                    RAND_seed(((unsigned char *)ap_scoreboard_image)+n, m);
                    nDone += m;
                }
            }
        }
    }
    ssl_log(s, SSL_LOG_INFO, "%sSeeding PRNG with %d bytes of entropy", prefix, nDone);

    if (RAND_status() == 0)
        ssl_log(s, SSL_LOG_WARN, "%sPRNG still contains insufficient entropy!", prefix);
    return nDone;
}

#define BUFSIZE 8192

static int ssl_rand_feedfp(pool *p, FILE *fp, int nReq)
{
    int nDone;
    unsigned char caBuf[BUFSIZE];
    int nBuf;
    int nRead;
    int nTodo;

    nDone = 0;
    nRead = BUFSIZE;
    nTodo = nReq;
    while (1) {
        if (nReq > 0)
            nRead = (nTodo < BUFSIZE ? nTodo : BUFSIZE);
        if ((nBuf = (int)fread(caBuf, 1, nRead, fp)) <= 0)
            break;
        RAND_seed(caBuf, nBuf);
        nDone += nBuf;
        if (nReq > 0) {
            nTodo -= nBuf;
            if (nTodo <= 0)
                break;
        }
    }
    return nDone;
}

/* Generate a random number in the range 1-h */
static int ssl_rand_choosenum(int h)
{
	return (int)(arc4random() / ((double)0xffffffffU + 1) * h + 1);
}

@


1.12
log
@kill more dead code, mostly inside #ifdef SOMENONSENSEONSTUPIDOSES
joint work by Michael Knudsen <e@@molioner.dk> and Daniel Ouellet
<daniel@@presscom.net> with my input
no change in binaries
@
text
@@


1.11
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@a118 1
#if SSL_LIBRARY_VERSION >= 0x00905100
a123 1
#if SSL_LIBRARY_VERSION >= 0x00906000
a124 3
#else
                if ((n = RAND_egd(pRandSeed->cpPath)) == -1)
#endif
a127 1
#endif
a166 1
#if SSL_LIBRARY_VERSION >= 0x00905100
a168 1
#endif
@


1.10
log
@Use arc4random(3) to compute random numbers, instead of using rand()
to produce a double, snprintf()ing that into a buffer and then
converting the string to an int with atoi().

ok millert@@ henning@@
@
text
@a103 3
#ifdef WIN32
                if ((fp = ap_pfopen(p, pRandSeed->cpPath, "rb")) == NULL)
#else
a104 1
#endif
@


1.9
log
@merge apache 1.3.29 and mod_ssl 2.8.16
ok brad@@
@
text
@d74 1
a74 1
static int ssl_rand_choosenum(int, int);
d158 1
a158 1
                n = ssl_rand_choosenum(0, sizeof(stackdata)-128-1);
d168 1
a168 1
                    n = ssl_rand_choosenum(0, m);
d213 2
a214 1
static int ssl_rand_choosenum(int l, int h)
d216 1
a216 10
    int i;
    char buf[50];

    srand((unsigned int)time(NULL));
    ap_snprintf(buf, sizeof(buf), "%.0f",
                (((double)(rand()%RAND_MAX)/RAND_MAX)*(h-l)));
    i = atoi(buf)+1;
    if (i < l) i = l;
    if (i > h) i = h;
    return i;
@


1.9.2.1
log
@MFC:
Fix by otto@@

Use arc4random(3) to compute random numbers, instead of using rand()
to produce a double, snprintf()ing that into a buffer and then
converting the string to an int with atoi().
@
text
@d74 1
a74 1
static int ssl_rand_choosenum(int);
d158 1
a158 1
                n = ssl_rand_choosenum(sizeof(stackdata)-128-1);
d168 1
a168 1
                    n = ssl_rand_choosenum(m);
d213 1
a213 2
/* Generate a random number in the range 1-h */
static int ssl_rand_choosenum(int h)
d215 10
a224 1
	return (int)(arc4random() / ((double)0xffffffffU + 1) * h + 1);
@


1.8
log
@merge apache 1.3.27 and mod_ssl 2.8.11
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2001 Ralf S. Engelschall. All rights reserved.
@


1.8.4.1
log
@MFC:
Fix by otto@@

Use arc4random(3) to compute random numbers, instead of using rand()
to produce a double, snprintf()ing that into a buffer and then
converting the string to an int with atoi().
@
text
@d74 1
a74 1
static int ssl_rand_choosenum(int);
d158 1
a158 1
                n = ssl_rand_choosenum(sizeof(stackdata)-128-1);
d168 1
a168 1
                    n = ssl_rand_choosenum(m);
d213 1
a213 2
/* Generate a random number in the range 1-h */
static int ssl_rand_choosenum(int h)
d215 10
a224 1
	return (int)(arc4random() / ((double)0xffffffffU + 1) * h + 1);
@


1.7
log
@merge
@
text
@d129 3
d133 1
@


1.6
log
@merge mod_ssl 2.8.7
--
Ok'd by: beck@@
@
text
@d104 3
d108 1
d162 2
a163 1
                    m = ((SCOREBOARD_SIZE / 2) - 1);
d175 1
a175 1
        ssl_log(s, SSL_LOG_WARN, "%sPRNG still contains not sufficient entropy!", prefix);
@


1.5
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d89 1
d155 1
a155 1
                 * seed in an 1KB extract of the current scoreboard
d157 5
a161 4
                if (ap_scoreboard_image != NULL) {
                    n = ssl_rand_choosenum(0, SCOREBOARD_SIZE-1024-1);
                    RAND_seed((unsigned char *)ap_scoreboard_image+n, 1024);
                    nDone += 1024;
@


1.5.4.1
log
@Pull in patch from current:
Fix (brad):
merge mod_ssl 2.8.7
@
text
@a88 1
    int m;
d154 1
a154 1
                 * seed in extract data from the current scoreboard
d156 4
a159 5
                if (ap_scoreboard_image != NULL && SCOREBOARD_SIZE > 16) {
                    m = ((SCOREBOARD_SIZE / 2) - 1);
                    n = ssl_rand_choosenum(0, m);
                    RAND_seed(((unsigned char *)ap_scoreboard_image)+n, m);
                    nDone += m;
@


1.5.2.1
log
@Upgrade mod_ssl to 2.8.7, to fix the recent vulnerability.

Requested, and patch from: brad@@
@
text
@a88 1
    int m;
d154 1
a154 1
                 * seed in extract data from the current scoreboard
d156 4
a159 5
                if (ap_scoreboard_image != NULL && SCOREBOARD_SIZE > 16) {
                    m = ((SCOREBOARD_SIZE / 2) - 1);
                    n = ssl_rand_choosenum(0, m);
                    RAND_seed(((unsigned char *)ap_scoreboard_image)+n, m);
                    nDone += m;
@


1.4
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2000 Ralf S. Engelschall. All rights reserved.
@


1.3
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d77 1
a77 1
int ssl_rand_seed(server_rec *s, pool *p, ssl_rsctx_t nCtx)
d83 1
d118 11
d145 7
d164 6
@


1.2
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d12 1
a12 1
 * Copyright (c) 1998-1999 Ralf S. Engelschall. All rights reserved.
@


1.1
log
@mod_ssl-2.2.3-1.3.4 (will require libssl-1.1 for https to work, but
mostly harmless otherwise).
@
text
@d2 4
a5 4
**  _ __ ___   ___   __| |    ___ ___| |
** | '_ ` _ \ / _ \ / _` |   / __/ __| |
** | | | | | | (_) | (_| |   \__ \__ \ | mod_ssl - Apache Interface to SSLeay
** |_| |_| |_|\___/ \__,_|___|___/___/_| http://www.engelschall.com/sw/mod_ssl/
d30 1
a30 1
 *     mod_ssl project (http://www.engelschall.com/sw/mod_ssl/)."
d45 1
a45 1
 *     mod_ssl project (http://www.engelschall.com/sw/mod_ssl/)."
d61 1
a61 1
                             /* ``The generation of random 
d111 2
a112 1
                if ((fp = ssl_util_ppopen(s, p, pRandSeed->cpPath)) == NULL)
d118 1
a118 1
                /* 
d134 1
a134 1
                /* 
d178 1
a178 1
{   
d181 1
a181 1
                
@


1.1.1.1
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@d2 4
a5 4
**  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
** | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
** | | | | | | (_) | (_| |   \__ \__ \ |  www.modssl.org
** |_| |_| |_|\___/ \__,_|___|___/___/_|  ftp.modssl.org
d12 1
a12 1
 * Copyright (c) 1998-2001 Ralf S. Engelschall. All rights reserved.
d30 1
a30 1
 *     mod_ssl project (http://www.modssl.org/)."
d45 1
a45 1
 *     mod_ssl project (http://www.modssl.org/)."
d61 1
a61 1
                             /* ``The generation of random
d77 1
a77 1
int ssl_rand_seed(server_rec *s, pool *p, ssl_rsctx_t nCtx, char *prefix)
a82 1
    unsigned char stackdata[256];
a87 1
    int m;
a101 3
#ifdef WIN32
                if ((fp = ap_pfopen(p, pRandSeed->cpPath, "rb")) == NULL)
#else
a102 1
#endif
d111 1
a111 2
                if ((fp = ssl_util_ppopen(s, p, ap_psprintf(p, "%s %d",
                                          pRandSeed->cpPath, pRandSeed->nBytes))) == NULL)
a115 15
#if SSL_LIBRARY_VERSION >= 0x00905100
            else if (pRandSeed->nSrc == SSL_RSSRC_EGD) {
                /*
                 * seed in contents provided by the external
                 * Entropy Gathering Daemon (EGD)
                 */
#if SSL_LIBRARY_VERSION >= 0x00906000
                if ((n = RAND_egd_bytes(pRandSeed->cpPath, pRandSeed->nBytes)) == -1)
#else
                if ((n = RAND_egd(pRandSeed->cpPath)) == -1)
#endif
                    continue;
                nDone += n;
            }
#endif
d117 1
a117 1
                /*
a131 7
                
                /*
                 * seed in some current state of the run-time stack (128 bytes)
                 */
                n = ssl_rand_choosenum(0, sizeof(stackdata)-128-1);
                RAND_seed(stackdata+n, 128);
                nDone += 128;
d133 2
a134 2
                /*
                 * seed in extract data from the current scoreboard
d136 4
a139 6
                if (ap_scoreboard_image != NULL && SCOREBOARD_SIZE > 16) {
                    if ((m = ((SCOREBOARD_SIZE / 2) - 1)) > 1024)
                        m = 1024;
                    n = ssl_rand_choosenum(0, m);
                    RAND_seed(((unsigned char *)ap_scoreboard_image)+n, m);
                    nDone += m;
a143 6
    ssl_log(s, SSL_LOG_INFO, "%sSeeding PRNG with %d bytes of entropy", prefix, nDone);

#if SSL_LIBRARY_VERSION >= 0x00905100
    if (RAND_status() == 0)
        ssl_log(s, SSL_LOG_WARN, "%sPRNG still contains insufficient entropy!", prefix);
#endif
d177 1
a177 1
{
d180 1
a180 1

@


1.1.1.2
log
@import Apache 1.3.29 and mod_ssl 2.8.16
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2003 Ralf S. Engelschall. All rights reserved.
@


