head	1.33;
access;
symbols
	OPENBSD_5_5:1.32.0.6
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.2
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.28.0.4
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.2
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.30
	OPENBSD_5_0:1.27.0.28
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.26
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.24
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.20
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.22
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.18
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.16
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.14
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.12
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.10
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.8
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.6
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.4
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.3
	OPENBSD_3_4:1.22.0.4
	OPENBSD_3_4_BASE:1.22
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.2
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.1
	apache_1_3_27:1.1.1.1
	apache:1.1.1
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.15.0.4
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.33
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.32;

1.32
date	2013.07.16.13.22.55;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2013.07.16.13.02.16;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2013.07.16.11.32.05;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2013.07.11.12.41.52;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2012.07.07.17.08.17;	author sthen;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.09.12.13.10;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.06.13.14.10;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.10.20.14.02.40;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.17.18.57.06;	author henning;	state Exp;
branches
	1.23.2.1
	1.23.4.1;
next	1.22;

1.22
date	2003.03.19.15.13.26;	author henning;	state Exp;
branches
	1.22.4.1;
next	1.21;

1.21
date	2003.03.14.09.28.14;	author ho;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.07.20.23.06;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.19.21.31.16;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.15.09.40.49;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.29.02.08.06;	author beck;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.28.21.22.42;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.29.10.21.46;	author beck;	state Exp;
branches
	1.15.2.1
	1.15.4.1;
next	1.14;

1.14
date	2000.12.15.22.18.18;	author beck;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.19.23.46.24;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.19.23.34.30;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.15.13.11.21;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.21.01.20.30;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.30.05.35.10;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.19.11.17.22;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.25.18.29.54;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	99.12.08.02.45.49;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	99.12.08.00.05.17;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.06.29.46;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.03.13.20.16.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.03.07.23.12.01;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.03.01.04.28.56;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.07.19.48.14;	author henning;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.21.12.53.42;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.17.17.03.23;	author henning;	state Exp;
branches;
next	;

1.15.2.1
date	2002.03.13.20.21.01;	author miod;	state Exp;
branches;
next	;

1.15.4.1
date	2002.03.13.21.06.15;	author jason;	state Exp;
branches;
next	;

1.22.4.1
date	2004.11.01.04.28.07;	author brad;	state Exp;
branches;
next	;

1.23.2.1
date	2004.11.01.03.28.43;	author brad;	state Exp;
branches;
next	;

1.23.4.1
date	2004.11.01.03.57.00;	author brad;	state Exp;
branches;
next	;


desc
@@


1.33
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/* $OpenBSD: ssl_engine_init.c,v 1.32 2013/07/16 13:22:55 jsing Exp $ */

/*                      _             _
**  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
** | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
** | | | | | | (_) | (_| |   \__ \__ \ |  www.modssl.org
** |_| |_| |_|\___/ \__,_|___|___/___/_|  ftp.modssl.org
**                      |_____|
**  ssl_engine_init.c
**  Initialization of Servers
*/

/* ====================================================================
 * Copyright (c) 1998-2003 Ralf S. Engelschall. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials
 *    provided with the distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by
 *     Ralf S. Engelschall <rse@@engelschall.com> for use in the
 *     mod_ssl project (http://www.modssl.org/)."
 *
 * 4. The names "mod_ssl" must not be used to endorse or promote
 *    products derived from this software without prior written
 *    permission. For written permission, please contact
 *    rse@@engelschall.com.
 *
 * 5. Products derived from this software may not be called "mod_ssl"
 *    nor may "mod_ssl" appear in their names without prior
 *    written permission of Ralf S. Engelschall.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by
 *     Ralf S. Engelschall <rse@@engelschall.com> for use in the
 *     mod_ssl project (http://www.modssl.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY RALF S. ENGELSCHALL ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL RALF S. ENGELSCHALL OR
 * HIS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 */

/* ====================================================================
 * Copyright (c) 1995-1999 Ben Laurie. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by Ben Laurie
 *    for use in the Apache-SSL HTTP server project."
 *
 * 4. The name "Apache-SSL Server" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission.
 *
 * 5. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by Ben Laurie
 *    for use in the Apache-SSL HTTP server project."
 *
 * THIS SOFTWARE IS PROVIDED BY BEN LAURIE ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL BEN LAURIE OR
 * HIS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 */
                             /* ``Recursive, adj.;
                                  see Recursive.''
                                        -- Unknown   */
#include "mod_ssl.h"


/*  _________________________________________________________________
**
**  Module Initialization
**  _________________________________________________________________
*/

/*
 *  Per-module initialization
 */
void ssl_init_Module(server_rec *s, pool *p)
{
    SSLModConfigRec *mc = myModConfig();
    SSLSrvConfigRec *sc;
    server_rec *s2;
    char *cp;
    int SSLenabled = 0;

    mc->nInitCount++;

    /*
     * Let us cleanup on restarts and exists
     */
    ap_register_cleanup(p, s, ssl_init_ModuleKill, ssl_init_ChildKill);

    /*
     * Any init round fixes the global config
     */
    ssl_config_global_create(); /* just to avoid problems */
    ssl_config_global_fix();

    /*
     *  try to fix the configuration and open the dedicated SSL
     *  logfile as early as possible
     */
    for (s2 = s; s2 != NULL; s2 = s2->next) {
        sc = mySrvConfig(s2);

        /* Fix up stuff that may not have been set */
        if (sc->bEnabled == UNSET)
            sc->bEnabled = FALSE;
        if (sc->nVerifyClient == SSL_CVERIFY_UNSET)
            sc->nVerifyClient = SSL_CVERIFY_NONE;
        if (sc->nVerifyDepth == UNSET)
            sc->nVerifyDepth = 1;
#ifdef SSL_EXPERIMENTAL_PROXY
        if (sc->nProxyVerifyDepth == UNSET)
            sc->nProxyVerifyDepth = 1;
#endif
        if (sc->nSessionCacheTimeout == UNSET)
            sc->nSessionCacheTimeout = SSL_SESSION_CACHE_TIMEOUT;
        if (sc->nPassPhraseDialogType == SSL_PPTYPE_UNSET)
            sc->nPassPhraseDialogType = SSL_PPTYPE_BUILTIN;

        /* Open the dedicated SSL logfile */
        if (!ap_server_is_chrooted())
            ssl_log_open(s, s2, p);
    }

    /*
     * Identification
     */
    if (mc->nInitCount == 1) {
        ssl_log(s, SSL_LOG_INFO, "Server: %s, Interface: %s, Library: %s",
                SERVER_BASEVERSION,
                ssl_var_lookup(p, NULL, NULL, NULL, "SSL_VERSION_INTERFACE"),
                ssl_var_lookup(p, NULL, NULL, NULL, "SSL_VERSION_LIBRARY"));
    }

    /*
     * Initialization round information
     */
    if (mc->nInitCount == 1)
        ssl_log(s, SSL_LOG_INFO, "Init: 1st startup round (still not detached)");
    else if (mc->nInitCount == 2)
        ssl_log(s, SSL_LOG_INFO, "Init: 2nd startup round (already detached)");
    else
        ssl_log(s, SSL_LOG_INFO, "Init: %d%s restart round (already detached)",
                mc->nInitCount-2, (mc->nInitCount-2) == 1 ? "st" : "nd");

#ifdef SSL_VENDOR
    ap_hook_use("ap::mod_ssl::vendor::init_module",
                AP_HOOK_SIG3(void,ptr,ptr), AP_HOOK_ALL, s, p);
#endif

    /*
     *  The initialization phase inside the Apache API is totally bogus.
     *  We actually have three non-trivial problems:
     *
     *  1. Under Unix the API does a 2-round initialization of modules while
     *     under Win32 it doesn't. This means we have to make sure that at
     *     least the pass phrase dialog doesn't occur twice.  We overcome this
     *     problem by using a counter (mc->nInitCount) which has to
     *     survive the init rounds.
     *
     *  2. Between the first and the second round Apache detaches from
     *     the terminal under Unix. This means that our pass phrase dialog
     *     _has_ to be done in the first round and _cannot_ be done in the
     *     second round.
     *
     *  3. When Dynamic Shared Object (DSO) mechanism is used under Unix the
     *     module segment (code & data) gets unloaded and re-loaded between
     *     the first and the second round. This means no global data survives
     *     between first and the second init round. We overcome this by using
     *     an entry ("ssl_module") inside the ap_global_ctx.
     *
     *  The situation as a table:
     *
     *  Unix/static Unix/DSO          Win32     Action Required
     *              (-DSHARED_MODULE) (-DWIN32)
     *  ----------- ----------------- --------- -----------------------------------
     *  -           load module       -         -
     *  init        init              init      SSL library init, Pass Phrase Dialog
     *  detach      detach            -         -
     *  -           reload module     -         -
     *  init        init              -         SSL library init, mod_ssl init
     *
     *  Ok, now try to solve this totally ugly situation...
     */

#ifdef SHARED_MODULE
    ssl_log(s, SSL_LOG_INFO, "Init: %snitializing %s library",
            mc->nInitCount == 1 ? "I" : "Rei", SSL_LIBRARY_NAME);
#ifdef SSL_EXPERIMENTAL_ENGINE
    ssl_init_Engine(s, p);
#endif
    ssl_init_SSLLibrary();
#else
    if (mc->nInitCount <= 2) {
        ssl_log(s, SSL_LOG_INFO, "Init: %snitializing %s library",
                mc->nInitCount == 1 ? "I" : "Rei", SSL_LIBRARY_NAME);
#ifdef SSL_EXPERIMENTAL_ENGINE
        ssl_init_Engine(s, p);
#endif
        ssl_init_SSLLibrary();
    }
#endif
    if (mc->nInitCount == 1) {
        ssl_pphrase_Handle(s, p);
        return;
    }

    for (s2 = s; s2 != NULL; s2 = s2->next) {
        sc = mySrvConfig(s2);
       /* find out if anyone's actually doing SSL */
        if (sc->bEnabled)
            SSLenabled = 1;
    }
    if (SSLenabled) /* skip expensive bits if we're not doing SSL */
      ssl_init_TmpKeysHandle(SSL_TKP_GEN, s, p);

    /*
     * SSL external crypto device ("engine") support
     */
#ifdef SSL_EXPERIMENTAL_ENGINE
    ssl_init_Engine(s, p);
#endif

    /*
     * Warn the user that he should use the session cache.
     * But we can operate without it, of course.
     */
    if (mc->nSessionCacheMode == SSL_SCMODE_UNSET) {
        ssl_log(s, SSL_LOG_WARN,
                "Init: Session Cache is not configured [hint: SSLSessionCache]");
        mc->nSessionCacheMode = SSL_SCMODE_NONE;
    }

    /*
     *  initialize the mutex handling and session caching
     */
    ssl_mutex_init(s, p);
    ssl_scache_init(s, p);

    /*
     * Seed the Pseudo Random Number Generator (PRNG)
     */
    ssl_rand_seed(s, p, SSL_RSCTX_STARTUP, "Init: ");

    /*
     *  allocate the temporary RSA keys and DH params
     */
    if (SSLenabled)  /* skip expensive bits if we're not doing SSL */
	ssl_init_TmpKeysHandle(SSL_TKP_ALLOC, s, p);

    /*
     *  initialize servers
     */
    ssl_log(s, SSL_LOG_INFO, "Init: Initializing (virtual) servers for SSL");
    for (s2 = s; s2 != NULL; s2 = s2->next) {
        sc = mySrvConfig(s2);
        /*
         * Either now skip this server when SSL is disabled for
         * it or give out some information about what we're
         * configuring.
         */
        if (!sc->bEnabled)
            continue;
        ssl_log(s2, SSL_LOG_INFO,
                "Init: Configuring server %s for SSL protocol",
                ssl_util_vhostid(p, s2));

        /*
         * Read the server certificate and key
         */
        ssl_init_ConfigureServer(s2, p, sc);
    }

    /*
     * Configuration consistency checks
     */
    ssl_init_CheckServers(s, p);

    /*
     *  Announce mod_ssl and SSL library in HTTP Server field
     *  as ``mod_ssl/X.X.X OpenSSL/X.X.X''
     */
    if ((cp = ssl_var_lookup(p, NULL, NULL, NULL, "SSL_VERSION_PRODUCT")) != NULL && cp[0] != NUL)
        ap_add_version_component(cp);
    ap_add_version_component(ssl_var_lookup(p, NULL, NULL, NULL, "SSL_VERSION_INTERFACE"));
    ap_add_version_component(ssl_var_lookup(p, NULL, NULL, NULL, "SSL_VERSION_LIBRARY"));

    return;
}

/*
 *  Initialize SSL library (also already needed for the pass phrase dialog)
 */
void ssl_init_SSLLibrary(void)
{
    SSL_load_error_strings();
    SSL_library_init();
    ssl_util_thread_setup();
    X509V3_add_standard_extensions();
    return;
}

/*
 * Support for external a Crypto Device ("engine"), usually
 * a hardware accellerator card for crypto operations.
 */
#ifdef SSL_EXPERIMENTAL_ENGINE
void ssl_init_Engine(server_rec *s, pool *p)
{
    SSLModConfigRec *mc = myModConfig();
    ENGINE *e;

    if (mc->szCryptoDevice != NULL) {
        if ((e = ENGINE_by_id(mc->szCryptoDevice)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to load Crypto Device API `%s'",
                    mc->szCryptoDevice);
            ssl_die();
        }
        if (strEQ(mc->szCryptoDevice, "chil")) 
            ENGINE_ctrl(e, ENGINE_CTRL_CHIL_SET_FORKCHECK, 1, 0, 0);
        if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to enable Crypto Device API `%s'",
                    mc->szCryptoDevice);
            ssl_die();
        }
        ENGINE_free(e);
    }
    return;
}
#endif

/*
 * Handle the Temporary RSA Keys and DH Params
 */
void ssl_init_TmpKeysHandle(int action, server_rec *s, pool *p)
{
    SSLModConfigRec *mc = myModConfig();
    ssl_asn1_t *asn1;
    unsigned char *ucp;
    RSA *rsa;
    DH *dh;

    /* Generate Keys and Params */
    if (action == SSL_TKP_GEN) {

        /* seed PRNG */
        ssl_rand_seed(s, p, SSL_RSCTX_STARTUP, "Init: ");

        /* generate 512 bit RSA key */
        ssl_log(s, SSL_LOG_INFO, "Init: Generating temporary RSA private keys (512/1024 bits)");
        if ((rsa = RSA_generate_key(512, RSA_F4, NULL, NULL)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR, 
                    "Init: Failed to generate temporary 512 bit RSA private key");
            ssl_die();
        }
        asn1 = (ssl_asn1_t *)ssl_ds_table_push(mc->tTmpKeys, "RSA:512");
        asn1->nData  = i2d_RSAPrivateKey(rsa, NULL);
        asn1->cpData = ap_palloc(mc->pPool, asn1->nData);
        ucp = asn1->cpData; i2d_RSAPrivateKey(rsa, &ucp); /* 2nd arg increments */
        RSA_free(rsa);

        /* generate 1024 bit RSA key */
        if ((rsa = RSA_generate_key(1024, RSA_F4, NULL, NULL)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR, 
                    "Init: Failed to generate temporary 1024 bit RSA private key");
            ssl_die();
        }
        asn1 = (ssl_asn1_t *)ssl_ds_table_push(mc->tTmpKeys, "RSA:1024");
        asn1->nData  = i2d_RSAPrivateKey(rsa, NULL);
        asn1->cpData = ap_palloc(mc->pPool, asn1->nData);
        ucp = asn1->cpData; i2d_RSAPrivateKey(rsa, &ucp); /* 2nd arg increments */
        RSA_free(rsa);

        ssl_log(s, SSL_LOG_INFO, "Init: Configuring temporary DH parameters (512/1024 bits)");

        /* import 512 bit DH param */
        if ((dh = ssl_dh_GetTmpParam(512)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to import temporary 512 bit DH parameters");
            ssl_die();
        }
        asn1 = (ssl_asn1_t *)ssl_ds_table_push(mc->tTmpKeys, "DH:512");
        asn1->nData  = i2d_DHparams(dh, NULL);
        asn1->cpData = ap_palloc(mc->pPool, asn1->nData);
        ucp = asn1->cpData; i2d_DHparams(dh, &ucp); /* 2nd arg increments */
        DH_free(dh);

        /* import 1024 bit DH param */
        if ((dh = ssl_dh_GetTmpParam(1024)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to import temporary 1024 bit DH parameters");
            ssl_die();
        }
        asn1 = (ssl_asn1_t *)ssl_ds_table_push(mc->tTmpKeys, "DH:1024");
        asn1->nData  = i2d_DHparams(dh, NULL);
        asn1->cpData = ap_palloc(mc->pPool, asn1->nData);
        ucp = asn1->cpData; i2d_DHparams(dh, &ucp); /* 2nd arg increments */
        DH_free(dh);
    }

    /* Allocate Keys and Params */
    else if (action == SSL_TKP_ALLOC) {

        ssl_log(s, SSL_LOG_INFO, "Init: Configuring temporary RSA private keys (512/1024 bits)");

        /* allocate 512 bit RSA key */
        if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tTmpKeys, "RSA:512")) != NULL) {
            ucp = asn1->cpData;
            if ((mc->pTmpKeys[SSL_TKPIDX_RSA512] = 
                 (void *)d2i_RSAPrivateKey(NULL, (const unsigned char **)&ucp, asn1->nData)) == NULL) {
                ssl_log(s, SSL_LOG_ERROR, "Init: Failed to load temporary 512 bit RSA private key");
                ssl_die();
            }
	    if (RSA_blinding_on ((RSA *)mc->pTmpKeys[SSL_TKPIDX_RSA512], NULL) != 1) {
		ssl_log(s, SSL_LOG_ERROR, "Init: Failed to add blinding for temporary 512 bit RSA private key");
                ssl_die();
	    }
        }

        /* allocate 1024 bit RSA key */
        if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tTmpKeys, "RSA:1024")) != NULL) {
            ucp = asn1->cpData;
            if ((mc->pTmpKeys[SSL_TKPIDX_RSA1024] = 
                 (void *)d2i_RSAPrivateKey(NULL, (const unsigned char **)&ucp, asn1->nData)) == NULL) {
                ssl_log(s, SSL_LOG_ERROR, "Init: Failed to load temporary 1024 bit RSA private key");
                ssl_die();
            }
	    if (RSA_blinding_on ((RSA *)mc->pTmpKeys[SSL_TKPIDX_RSA1024], NULL) != 1) {
		ssl_log(s, SSL_LOG_ERROR, "Init: Failed to add blinding for temporary 1024 bit RSA private key");
                ssl_die();
	    }
        }

        ssl_log(s, SSL_LOG_INFO, "Init: Configuring temporary DH parameters (512/1024 bits)");

        /* allocate 512 bit DH param */
        if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tTmpKeys, "DH:512")) != NULL) {
            ucp = asn1->cpData;
            if ((mc->pTmpKeys[SSL_TKPIDX_DH512] = 
                 (void *)d2i_DHparams(NULL, (const unsigned char **)&ucp, asn1->nData)) == NULL) {
                ssl_log(s, SSL_LOG_ERROR, "Init: Failed to load temporary 512 bit DH parameters");
                ssl_die();
            }
        }

        /* allocate 1024 bit DH param */
        if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tTmpKeys, "DH:1024")) != NULL) {
            ucp = asn1->cpData;
            if ((mc->pTmpKeys[SSL_TKPIDX_DH1024] = 
                 (void *)d2i_DHparams(NULL, (const unsigned char **)&ucp, asn1->nData)) == NULL) {
                ssl_log(s, SSL_LOG_ERROR, "Init: Failed to load temporary 1024 bit DH parameters");
                ssl_die();
            }
        }
    }

    /* Free Keys and Params */
    else if (action == SSL_TKP_FREE) {
        if (mc->pTmpKeys[SSL_TKPIDX_RSA512] != NULL) {
            RSA_free((RSA *)mc->pTmpKeys[SSL_TKPIDX_RSA512]);
            mc->pTmpKeys[SSL_TKPIDX_RSA512] = NULL;
        }
        if (mc->pTmpKeys[SSL_TKPIDX_RSA1024] != NULL) {
            RSA_free((RSA *)mc->pTmpKeys[SSL_TKPIDX_RSA1024]);
            mc->pTmpKeys[SSL_TKPIDX_RSA1024] = NULL;
        }
        if (mc->pTmpKeys[SSL_TKPIDX_DH512] != NULL) {
            DH_free((DH *)mc->pTmpKeys[SSL_TKPIDX_DH512]);
            mc->pTmpKeys[SSL_TKPIDX_DH512] = NULL;
        }
        if (mc->pTmpKeys[SSL_TKPIDX_DH1024] != NULL) {
            DH_free((DH *)mc->pTmpKeys[SSL_TKPIDX_DH1024]);
            mc->pTmpKeys[SSL_TKPIDX_DH1024] = NULL;
        }
    }
    return;
}

/*
 * Configure a particular server
 */
void ssl_init_ConfigureServer(server_rec *s, pool *p, SSLSrvConfigRec *sc)
{
    SSLModConfigRec *mc = myModConfig();
    int nVerify;
    char *cpVHostID;
    EVP_PKEY *pKey;
    SSL_CTX *ctx;
    EC_KEY *ecdhKey;
    STACK_OF(X509_NAME) *skCAList;
    ssl_asn1_t *asn1;
    unsigned char *ucp;
    char *cp;
    BOOL ok;
    BOOL bSkipFirst;
    int isca, pathlen;
    int i, n;

    /*
     * Create the server host:port string because we need it a lot
     */
    cpVHostID = ssl_util_vhostid(p, s);

    /*
     * Now check for important parameters and the
     * possibility that the user forgot to set them.
     */
    if (sc->szPublicCertFile[0] == NULL) {
        ssl_log(s, SSL_LOG_ERROR,
                "Init: (%s) No SSL Certificate set [hint: SSLCertificateFile]",
                cpVHostID);
        ssl_die();
    }

    /*
     *  Check for problematic re-initializations
     */
    if (sc->pPublicCert[SSL_AIDX_RSA] != NULL ||
        sc->pPublicCert[SSL_AIDX_DSA] != NULL   ) {
        ssl_log(s, SSL_LOG_ERROR,
                "Init: (%s) Illegal attempt to re-initialise SSL for server "
                "(theoretically shouldn't happen!)", cpVHostID);
        ssl_die();
    }

    /*
     *  Create the new per-server SSL context
     */
    if (sc->nProtocol == SSL_PROTOCOL_NONE) {
        ssl_log(s, SSL_LOG_ERROR,
                "Init: (%s) No SSL protocols available [hint: SSLProtocol]",
                cpVHostID);
        ssl_die();
    }
    cp = ap_pstrcat(p, (sc->nProtocol & SSL_PROTOCOL_SSLV2 ? "SSLv2, " : ""),
                       (sc->nProtocol & SSL_PROTOCOL_SSLV3 ? "SSLv3, " : ""),
                       (sc->nProtocol & SSL_PROTOCOL_TLSV1 ? "TLSv1, " : ""), NULL);
    cp[strlen(cp)-2] = NUL;
    ssl_log(s, SSL_LOG_TRACE,
            "Init: (%s) Creating new SSL context (protocols: %s)", cpVHostID, cp);
    ctx = SSL_CTX_new(SSLv23_server_method());
    SSL_CTX_set_options(ctx, SSL_OP_ALL);
    if (!(sc->nProtocol & SSL_PROTOCOL_SSLV2))
        SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2);
    if (!(sc->nProtocol & SSL_PROTOCOL_SSLV3))
        SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv3);
    if (!(sc->nProtocol & SSL_PROTOCOL_TLSV1))
        SSL_CTX_set_options(ctx, SSL_OP_NO_TLSv1);
    if (sc->bCompression == FALSE)
        SSL_CTX_set_options(ctx, SSL_OP_NO_COMPRESSION);
    if (sc->bHonorCipherOrder == TRUE)
    	SSL_CTX_set_options(ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);
    SSL_CTX_set_app_data(ctx, s);
    sc->pSSLCtx = ctx;

    /*
     * Configure additional context ingredients
     */
    SSL_CTX_set_options(ctx, SSL_OP_SINGLE_DH_USE);
    if (mc->nSessionCacheMode == SSL_SCMODE_NONE)
        SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);
    else
        SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_SERVER);

    /*
     * Disallow a session from being resumed during a renegotiation,
     * so that an acceptable cipher suite can be negotiated.
     */
    SSL_CTX_set_options(ctx, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);

    /*
     *  Configure callbacks for SSL context
     */
    nVerify = SSL_VERIFY_NONE;
    if (sc->nVerifyClient == SSL_CVERIFY_REQUIRE)
        nVerify |= SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
    if (   (sc->nVerifyClient == SSL_CVERIFY_OPTIONAL)
        || (sc->nVerifyClient == SSL_CVERIFY_OPTIONAL_NO_CA) )
        nVerify |= SSL_VERIFY_PEER;
    SSL_CTX_set_verify(ctx, nVerify,  ssl_callback_SSLVerify);
    SSL_CTX_sess_set_new_cb(ctx,      ssl_callback_NewSessionCacheEntry);
    SSL_CTX_sess_set_get_cb(ctx,      ssl_callback_GetSessionCacheEntry);
    SSL_CTX_sess_set_remove_cb(ctx,   ssl_callback_DelSessionCacheEntry);
    SSL_CTX_set_tmp_rsa_callback(ctx, ssl_callback_TmpRSA);
    SSL_CTX_set_tmp_dh_callback(ctx,  ssl_callback_TmpDH);
    SSL_CTX_set_info_callback(ctx,    ssl_callback_LogTracingState);

    /*
     *  Configure SSL Cipher Suite
     */
    if (sc->szCipherSuite != NULL) {
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring permitted SSL ciphers [%s]", 
                cpVHostID, sc->szCipherSuite);
        if (!SSL_CTX_set_cipher_list(ctx, sc->szCipherSuite)) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to configure permitted SSL ciphers",
                    cpVHostID);
            ssl_die();
        }
    }

    /*
     *  Configure ECDH Curve
     */
    if (sc->nECDHCurve > 0) {
        ecdhKey = EC_KEY_new_by_curve_name(sc->nECDHCurve);
        if (ecdhKey == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Failed to create new EC key using named curve",
                    cpVHostID);
            ssl_die();
        }
        SSL_CTX_set_tmp_ecdh(ctx, ecdhKey);
        SSL_CTX_set_options(ctx, SSL_OP_SINGLE_ECDH_USE);
        EC_KEY_free(ecdhKey);
    }

    /*
     * Configure Client Authentication details
     */
    if (sc->szCACertificateFile != NULL || sc->szCACertificatePath != NULL) {
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring client authentication", cpVHostID);
        if (!SSL_CTX_load_verify_locations(ctx,
                                           sc->szCACertificateFile,
                                           sc->szCACertificatePath)) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to configure verify locations "
                    "for client authentication", cpVHostID);
            ssl_die();
        }
        if ((skCAList = ssl_init_FindCAList(s, p, sc->szCACertificateFile,
                                            sc->szCACertificatePath)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR,
                    "Init: (%s) Unable to determine list of available "
                    "CA certificates for client authentication", cpVHostID);
            ssl_die();
        }
        SSL_CTX_set_client_CA_list(sc->pSSLCtx, skCAList);
    }

    /*
     * Configure Certificate Revocation List (CRL) Details
     */
    if (sc->szCARevocationFile != NULL || sc->szCARevocationPath != NULL) {
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring certificate revocation facility", cpVHostID);
        if ((sc->pRevocationStore =
                SSL_X509_STORE_create(sc->szCARevocationFile,
                                      sc->szCARevocationPath)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to configure X.509 CRL storage "
                    "for certificate revocation", cpVHostID);
            ssl_die();
        }
    }

    /*
     * Give a warning when no CAs were configured but client authentication
     * should take place. This cannot work.
     */
    if (sc->nVerifyClient == SSL_CVERIFY_REQUIRE) {
        skCAList = SSL_CTX_get_client_CA_list(ctx);
        if (sk_X509_NAME_num(skCAList) == 0)
            ssl_log(s, SSL_LOG_WARN,
                    "Init: Ops, you want to request client authentication, "
                    "but no CAs are known for verification!? "
                    "[Hint: SSLCACertificate*]");
    }

    /*
     *  Configure server certificate(s)
     */
    ok = FALSE;
    cp = ap_psprintf(p, "%s:RSA", cpVHostID);
    if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tPublicCert, cp)) != NULL) {
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring RSA server certificate", cpVHostID);
        ucp = asn1->cpData;
        if ((sc->pPublicCert[SSL_AIDX_RSA] = d2i_X509(NULL, &ucp, asn1->nData)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to import RSA server certificate",
                    cpVHostID);
            ssl_die();
        }
        if (SSL_CTX_use_certificate(ctx, sc->pPublicCert[SSL_AIDX_RSA]) <= 0) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to configure RSA server certificate",
                    cpVHostID);
            ssl_die();
        }
        ok = TRUE;
    }
    cp = ap_psprintf(p, "%s:DSA", cpVHostID);
    if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tPublicCert, cp)) != NULL) {
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring DSA server certificate", cpVHostID);
        ucp = asn1->cpData;
        if ((sc->pPublicCert[SSL_AIDX_DSA] = d2i_X509(NULL, &ucp, asn1->nData)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to import DSA server certificate",
                    cpVHostID);
            ssl_die();
        }
        if (SSL_CTX_use_certificate(ctx, sc->pPublicCert[SSL_AIDX_DSA]) <= 0) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to configure DSA server certificate",
                    cpVHostID);
            ssl_die();
        }
        ok = TRUE;
    }
    if (!ok) {
        ssl_log(s, SSL_LOG_ERROR,
                "Init: (%s) Ops, no RSA or DSA server certificate found?!", cpVHostID);
        ssl_log(s, SSL_LOG_ERROR,
                "Init: (%s) You have to perform a *full* server restart when you added or removed a certificate and/or key file", cpVHostID);
        ssl_die();
    }

    /*
     * Some information about the certificate(s)
     */
    for (i = 0; i < SSL_AIDX_MAX; i++) {
        if (sc->pPublicCert[i] != NULL) {
            if (SSL_X509_isSGC(sc->pPublicCert[i])) {
                ssl_log(s, SSL_LOG_INFO,
                        "Init: (%s) %s server certificate enables "
                        "Server Gated Cryptography (SGC)", 
                        cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"));
            }
            if (SSL_X509_getBC(sc->pPublicCert[i], &isca, &pathlen)) {
                if (isca)
                    ssl_log(s, SSL_LOG_WARN,
                        "Init: (%s) %s server certificate is a CA certificate "
                        "(BasicConstraints: CA == TRUE !?)",
                        cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"));
                if (pathlen > 0)
                    ssl_log(s, SSL_LOG_WARN,
                        "Init: (%s) %s server certificate is not a leaf certificate "
                        "(BasicConstraints: pathlen == %d > 0 !?)",
                        cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"), pathlen);
            }
            if (SSL_X509_getCN(p, sc->pPublicCert[i], &cp)) {
                if (ap_is_fnmatch(cp) &&
                    ap_fnmatch(cp, s->server_hostname, 
                               FNM_PERIOD|FNM_CASE_BLIND) == FNM_NOMATCH) {
                    ssl_log(s, SSL_LOG_WARN,
                        "Init: (%s) %s server certificate wildcard CommonName (CN) `%s' "
                        "does NOT match server name!?", cpVHostID, 
                        (i == SSL_AIDX_RSA ? "RSA" : "DSA"), cp);
                }
                else if (strNE(s->server_hostname, cp)) {
                    ssl_log(s, SSL_LOG_WARN,
                        "Init: (%s) %s server certificate CommonName (CN) `%s' "
                        "does NOT match server name!?", cpVHostID, 
                        (i == SSL_AIDX_RSA ? "RSA" : "DSA"), cp);
                }
            }
        }
    }

    /*
     *  Configure server private key(s)
     */
    ok = FALSE;
    cp = ap_psprintf(p, "%s:RSA", cpVHostID);
    if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tPrivateKey, cp)) != NULL) {
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring RSA server private key", cpVHostID);
        ucp = asn1->cpData;
        if ((sc->pPrivateKey[SSL_AIDX_RSA] = 
             d2i_PrivateKey(EVP_PKEY_RSA, NULL, &ucp, asn1->nData)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to import RSA server private key",
                    cpVHostID);
            ssl_die();
        }
        if (!RSA_blinding_on(sc->pPrivateKey[SSL_AIDX_RSA]->pkey.rsa, NULL)) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to enable RSA blinding (probably PRNG failure)",
                    cpVHostID);
            ssl_die();
        }
        if (SSL_CTX_use_PrivateKey(ctx, sc->pPrivateKey[SSL_AIDX_RSA]) <= 0) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to configure RSA server private key",
                    cpVHostID);
            ssl_die();
        }
        ok = TRUE;
    }
    cp = ap_psprintf(p, "%s:DSA", cpVHostID);
    if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tPrivateKey, cp)) != NULL) {
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring DSA server private key", cpVHostID);
        ucp = asn1->cpData;
        if ((sc->pPrivateKey[SSL_AIDX_DSA] = 
             d2i_PrivateKey(EVP_PKEY_DSA, NULL, &ucp, asn1->nData)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to import DSA server private key",
                    cpVHostID);
            ssl_die();
        }
        if (SSL_CTX_use_PrivateKey(ctx, sc->pPrivateKey[SSL_AIDX_DSA]) <= 0) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to configure DSA server private key",
                    cpVHostID);
            ssl_die();
        }
        ok = TRUE;
    }
    if (!ok) {
        ssl_log(s, SSL_LOG_ERROR,
                "Init: (%s) Ops, no RSA or DSA server private key found?!", cpVHostID);
        ssl_die();
    }

    /*
     * Optionally copy DSA parameters for certificate from private key
     * (see http://www.psy.uq.edu.au/~ftp/Crypto/ssleay/TODO.html)
     */
    if (   sc->pPublicCert[SSL_AIDX_DSA] != NULL
        && sc->pPrivateKey[SSL_AIDX_DSA] != NULL) {
        pKey = X509_get_pubkey(sc->pPublicCert[SSL_AIDX_DSA]);
        if (   pKey != NULL
            && EVP_PKEY_type(pKey->type) == EVP_PKEY_DSA 
            && EVP_PKEY_missing_parameters(pKey))
            EVP_PKEY_copy_parameters(pKey, sc->pPrivateKey[SSL_AIDX_DSA]);
    }

    /* 
     * Optionally configure extra server certificate chain certificates.
     * This is usually done by OpenSSL automatically when one of the
     * server cert issuers are found under SSLCACertificatePath or in
     * SSLCACertificateFile. But because these are intended for client
     * authentication it can conflict. For instance when you use a
     * Global ID server certificate you've to send out the intermediate
     * CA certificate, too. When you would just configure this with
     * SSLCACertificateFile and also use client authentication mod_ssl
     * would accept all clients also issued by this CA. Obviously this
     * isn't what we want in this situation. So this feature here exists
     * to allow one to explicity configure CA certificates which are
     * used only for the server certificate chain.
     */
    if (sc->szCertificateChain != NULL) {
        bSkipFirst = FALSE;
        for (i = 0; i < SSL_AIDX_MAX && sc->szPublicCertFile[i] != NULL; i++) {
            if (strEQ(sc->szPublicCertFile[i], sc->szCertificateChain)) {
                bSkipFirst = TRUE;
                break;
            }
        }
        if ((n = SSL_CTX_use_certificate_chain(ctx, sc->szCertificateChain, 
                                               bSkipFirst, NULL)) < 0) {
            ssl_log(s, SSL_LOG_ERROR,
                    "Init: (%s) Failed to configure CA certificate chain!", cpVHostID);
            ssl_die();
        }
        ssl_log(s, SSL_LOG_TRACE, "Init: (%s) Configuring "
                "server certificate chain (%d CA certificate%s)", cpVHostID,
                n, n == 1 ? "" : "s");
    }

#ifdef SSL_VENDOR
    ap_hook_use("ap::mod_ssl::vendor::configure_server",
                AP_HOOK_SIG4(void,ptr,ptr,ptr), AP_HOOK_ALL, 
                s, p, sc);
#endif

    return;
}

void ssl_init_CheckServers(server_rec *sm, pool *p)
{
    server_rec *s;
    server_rec **ps;
    SSLSrvConfigRec *sc;
    ssl_ds_table *t;
    pool *sp;
    char *key;
    BOOL bConflict;

    /*
     * Give out warnings when a server has HTTPS configured 
     * for the HTTP port or vice versa
     */
    for (s = sm; s != NULL; s = s->next) {
        sc = mySrvConfig(s);
        if (sc->bEnabled && s->port == DEFAULT_HTTP_PORT)
            ssl_log(sm, SSL_LOG_WARN,
                    "Init: (%s) You configured HTTPS(%d) on the standard HTTP(%d) port!",
                    ssl_util_vhostid(p, s), DEFAULT_HTTPS_PORT, DEFAULT_HTTP_PORT);
        if (!sc->bEnabled && s->port == DEFAULT_HTTPS_PORT)
            ssl_log(sm, SSL_LOG_WARN,
                    "Init: (%s) You configured HTTP(%d) on the standard HTTPS(%d) port!",
                    ssl_util_vhostid(p, s), DEFAULT_HTTP_PORT, DEFAULT_HTTPS_PORT);
    }

    /*
     * Give out warnings if more than one SSL-aware virtual server uses the
     * same IP:port. This doesn't work because mod_ssl then will always use
     * just the certificate/keys of one virtual host (which one cannot be said
     * easily - but that doesn't matter here).
     */
    sp = ap_make_sub_pool(p);
    t = ssl_ds_table_make(sp, sizeof(server_rec *));
    bConflict = FALSE;
    for (s = sm; s != NULL; s = s->next) {
        sc = mySrvConfig(s);
        if (!sc->bEnabled)
            continue;
        if (s->addrs == NULL)
            continue;
        key = ap_psprintf(sp, "%pA:%u", &s->addrs->host_addr, s->addrs->host_port);
        ps = ssl_ds_table_get(t, key);
        if (ps != NULL) {
            ssl_log(sm, SSL_LOG_WARN,
                    "Init: SSL server IP/port conflict: %s (%s:%d) vs. %s (%s:%d)",
                    ssl_util_vhostid(p, s), 
                    (s->defn_name != NULL ? s->defn_name : "unknown"),
                    s->defn_line_number,
                    ssl_util_vhostid(p, *ps),
                    ((*ps)->defn_name != NULL ? (*ps)->defn_name : "unknown"), 
                    (*ps)->defn_line_number);
            bConflict = TRUE;
            continue;
        }
        ps = ssl_ds_table_push(t, key);
        *ps = s;
    }
    ssl_ds_table_kill(t);
    ap_destroy_pool(sp);
    if (bConflict)
        ssl_log(sm, SSL_LOG_WARN,
                "Init: You should not use name-based virtual hosts in conjunction with SSL!!");

    return;
}

static int ssl_init_FindCAList_X509NameCmp(X509_NAME **a, X509_NAME **b)
{
    return(X509_NAME_cmp(*a, *b));
}

STACK_OF(X509_NAME) *ssl_init_FindCAList(server_rec *s, pool *pp, char *cpCAfile, char *cpCApath)
{
    STACK_OF(X509_NAME) *skCAList;
    STACK_OF(X509_NAME) *sk;
    DIR *dir;
    struct DIR_TYPE *direntry;
    char *cp;
    pool *p;
    int n;
    char buf[256];

    /*
     * Use a subpool so we don't bloat up the server pool which
     * is remains in memory for the complete operation time of
     * the server.
     */
    p = ap_make_sub_pool(pp);

    /*
     * Start with a empty stack/list where new
     * entries get added in sorted order.
     */
    skCAList = sk_X509_NAME_new(ssl_init_FindCAList_X509NameCmp);

    /*
     * Process CA certificate bundle file
     */
    if (cpCAfile != NULL) {
        sk = SSL_load_client_CA_file(cpCAfile);
        for (n = 0; sk != NULL && n < sk_X509_NAME_num(sk); n++) {
            X509_NAME *name = sk_X509_NAME_value(sk, n);
            ssl_log(s, SSL_LOG_TRACE,
                    "CA certificate: %s",
                    X509_NAME_oneline(name, buf, sizeof(buf)));
            if (sk_X509_NAME_find(skCAList, name) < 0)
                sk_X509_NAME_push(skCAList, name); /* will be freed when skCAList is */
            else
                X509_NAME_free(name);
        }
        sk_X509_NAME_free(sk);
    }

    /*
     * Process CA certificate path files
     */
    if (cpCApath != NULL) {
        dir = ap_popendir(p, cpCApath);
        while ((direntry = readdir(dir)) != NULL) {
            cp = ap_pstrcat(p, cpCApath, "/", direntry->d_name, NULL);
            sk = SSL_load_client_CA_file(cp);
            for (n = 0; sk != NULL && n < sk_X509_NAME_num(sk); n++) {
                X509_NAME *name = sk_X509_NAME_value(sk, n);
                ssl_log(s, SSL_LOG_TRACE,
                        "CA certificate: %s",
                        X509_NAME_oneline(name, buf, sizeof(buf)));
                if (sk_X509_NAME_find(skCAList, name) < 0)
                    sk_X509_NAME_push(skCAList, name);
                else
                    X509_NAME_free(name);
            }
            sk_X509_NAME_free(sk);
        }
        ap_pclosedir(p, dir);
    }

    /*
     * Cleanup
     */
    sk_X509_NAME_set_cmp_func(skCAList, NULL);
    ap_destroy_pool(p);

    return skCAList;
}

void ssl_init_Child(server_rec *s, pool *p)
{
     /* open the mutex lockfile */
     ssl_mutex_reinit(s, p);
     return;
}

void ssl_init_ChildKill(void *data)
{
    /* currently nothing to do */
    return;
}

void ssl_init_ModuleKill(void *data)
{
    SSLSrvConfigRec *sc;
    server_rec *s = (server_rec *)data;

    /*
     * Drop the session cache and mutex
     */
    ssl_scache_kill(s);
    ssl_mutex_kill(s);

    /* 
     * Destroy the temporary keys and params
     */
    ssl_init_TmpKeysHandle(SSL_TKP_FREE, s, NULL);

    /*
     * Free the non-pool allocated structures
     * in the per-server configurations
     */
    for (; s != NULL; s = s->next) {
        sc = mySrvConfig(s);
        if (sc->pRevocationStore != NULL) {
            X509_STORE_free(sc->pRevocationStore);
            sc->pRevocationStore = NULL;
        }
        if (sc->pPublicCert[SSL_AIDX_RSA] != NULL) {
            X509_free(sc->pPublicCert[SSL_AIDX_RSA]);
            sc->pPublicCert[SSL_AIDX_RSA] = NULL;
        }
        if (sc->pPublicCert[SSL_AIDX_DSA] != NULL) {
            X509_free(sc->pPublicCert[SSL_AIDX_DSA]);
            sc->pPublicCert[SSL_AIDX_DSA] = NULL;
        }
        if (sc->pPrivateKey[SSL_AIDX_RSA] != NULL) {
            EVP_PKEY_free(sc->pPrivateKey[SSL_AIDX_RSA]);
            sc->pPrivateKey[SSL_AIDX_RSA] = NULL;
        }
        if (sc->pPrivateKey[SSL_AIDX_DSA] != NULL) {
            EVP_PKEY_free(sc->pPrivateKey[SSL_AIDX_DSA]);
            sc->pPrivateKey[SSL_AIDX_DSA] = NULL;
        }
        if (sc->pSSLCtx != NULL) {
            SSL_CTX_free(sc->pSSLCtx);
            sc->pSSLCtx = NULL;
        }
    }

    /*
     * Try to kill the internals of the SSL library.
     */
#ifdef SHARED_MODULE
    ERR_free_strings();
    ERR_remove_state(0);
    EVP_cleanup();
#endif

    ssl_util_thread_cleanup();

    return;
}
@


1.32
log
@Disable SSL compression in order to mitigate CRIME attacks. Add
an SSLCompression option so that it can be turned back on, however on
this is currently a no-op due to the compile options for libssl.

Requested by and ok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.31 2013/07/16 13:02:16 jsing Exp $ */
@


1.31
log
@Enable ECDHE support in httpd via a SSLECDHCurve option. This specifies the
named curve to use when generating ephemeral EC keys for an ECDHE-based
cipher suite, or can be set to `none' to disable. The default is to use
a prime256v1 curve.

yay^Wok djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.30 2013/07/16 11:32:05 jsing Exp $ */
d593 2
@


1.30
log
@Define HonorCipherOrder as a FLAG (rather than as a TAKE1), so that it
works correctly as a boolean on/off flag. While here, rename the variable
so that it is consistent with existing naming scheme.

ok otto@@ djm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.29 2013/07/11 12:41:52 otto Exp $ */
d533 1
d643 16
@


1.29
log
@introduce HonorCipherOrder to use the server's order of preference of ciphers
ok djm@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.28 2012/07/07 17:08:17 sthen Exp $ */
d592 1
a592 1
    if (sc->cipher_server_pref == TRUE)
@


1.28
log
@allow httpd to build if sslv2 is disabled, ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.27 2005/02/09 12:13:10 henning Exp $ */
d592 2
@


1.27
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.26 2004/12/06 13:14:10 henning Exp $ */
d584 1
a584 4
    if (sc->nProtocol == SSL_PROTOCOL_SSLV2)
        ctx = SSL_CTX_new(SSLv2_server_method());  /* only SSLv2 is left */
    else
        ctx = SSL_CTX_new(SSLv23_server_method()); /* be more flexible */
@


1.26
log
@kill more dead code, mostly inside #ifdef SOMENONSENSEONSTUPIDOSES
joint work by Michael Knudsen <e@@molioner.dk> and Daniel Ouellet
<daniel@@presscom.net> with my input
no change in binaries
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.25 2004/12/02 19:42:47 henning Exp $ */
a610 1
#ifdef SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
a611 1
#endif
@


1.25
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.24 2004/10/20 14:02:40 henning Exp $ */
a127 1
#ifdef __OpenBSD__
a128 1
#endif
a250 3
#ifndef __OpenBSD__
        ssl_init_TmpKeysHandle(SSL_TKP_GEN, s, p);
#endif
a253 1
#ifdef __OpenBSD__
a261 1
#endif
a293 1
#ifdef __OpenBSD__
d295 1
a295 2
#endif
    ssl_init_TmpKeysHandle(SSL_TKP_ALLOC, s, p);
a453 1
#if SSL_LIBRARY_VERSION >= 0x00907000
a454 3
#else
                 (void *)d2i_RSAPrivateKey(NULL, &ucp, asn1->nData)) == NULL) {
#endif
a467 1
#if SSL_LIBRARY_VERSION >= 0x00907000
a468 3
#else
                 (void *)d2i_RSAPrivateKey(NULL, &ucp, asn1->nData)) == NULL) {
#endif
a483 1
#if SSL_LIBRARY_VERSION >= 0x00907000
a484 3
#else
                 (void *)d2i_DHparams(NULL, &ucp, asn1->nData)) == NULL) {
#endif
a493 1
#if SSL_LIBRARY_VERSION >= 0x00907000
a494 3
#else
                 (void *)d2i_DHparams(NULL, &ucp, asn1->nData)) == NULL) {
#endif
@


1.24
log
@merge changes from mod_ssl 2.8.20, in particular a fix for CAN-2004-0885
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.23 2003/11/17 18:57:06 henning Exp $ */
a180 5
#ifdef WIN32
        ssl_log(s, SSL_LOG_WARN, "You are using mod_ssl under Win32. " 
                "This combination is *NOT* officially supported. "
                "Use it at your own risk!");
#endif
a255 1
#ifndef WIN32
a256 1
#endif
a350 3
#ifdef WIN32
    CRYPTO_malloc_init();
#endif
@


1.23
log
@merge apache 1.3.29 and mod_ssl 2.8.16
ok brad@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.22 2003/03/19 15:13:26 henning Exp $ */
d641 8
@


1.23.4.1
log
@MFC:
Fix by henning@@

merge changes from mod_ssl 2.8.20, in particular a fix for CAN-2004-0885
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.23 2003/11/17 18:57:06 henning Exp $ */
a640 8

    /*
     * Disallow a session from being resumed during a renegotiation,
     * so that an acceptable cipher suite can be negotiated.
     */
#ifdef SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
    SSL_CTX_set_options(ctx, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
#endif
@


1.23.2.1
log
@MFC:
Fix by henning@@

merge changes from mod_ssl 2.8.20, in particular a fix for CAN-2004-0885
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.23 2003/11/17 18:57:06 henning Exp $ */
a640 8

    /*
     * Disallow a session from being resumed during a renegotiation,
     * so that an acceptable cipher suite can be negotiated.
     */
#ifdef SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
    SSL_CTX_set_options(ctx, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
#endif
@


1.22
log
@use RSA key blinding code from mod_ssl 2.8.13. differences to our own fix
that was already in are purely cosmetical, but this will make the future
merge of mod_ssl 2.8.13 easier.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.21 2003/03/14 09:28:14 ho Exp $ */
d14 1
a14 1
 * Copyright (c) 1998-2001 Ralf S. Engelschall. All rights reserved.
@


1.22.4.1
log
@MFC:
Fix by henning@@

merge changes from mod_ssl 2.8.20, in particular a fix for CAN-2004-0885
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.22 2003/03/19 15:13:26 henning Exp $ */
a640 8

    /*
     * Disallow a session from being resumed during a renegotiation,
     * so that an acceptable cipher suite can be negotiated.
     */
#ifdef SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
    SSL_CTX_set_options(ctx, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
#endif
@


1.21
log
@Add RSA blinding for private keys. markus@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.20 2002/10/07 20:23:06 henning Exp $ */
d835 1
a835 1
	if (RSA_blinding_on (sc->pPrivateKey[SSL_AIDX_RSA]->pkey.rsa, NULL) != 1) {
d837 1
a837 1
                    "Init: (%s) Unable to add blinding for RSA server private key",
@


1.20
log
@merge apache 1.3.27 and mod_ssl 2.8.11
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_engine_init.c,v 1.19 2002/07/19 21:31:16 henning Exp $ */
d481 4
d499 4
d832 6
@


1.19
log
@merge
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d242 3
d250 3
@


1.18
log
@don't try things we are not able to do if chrooted on graceful restarts.
this does not mean a chrooted httpd survives a graceful restart (yet).
@
text
@d937 1
a937 1
     * Give out warnings when more than one SSL-aware virtual server uses the
d949 2
d1012 1
d1015 5
a1019 3
                    X509_NAME_oneline(sk_X509_NAME_value(sk, n), buf, sizeof(buf)));
            if (sk_X509_NAME_find(skCAList, sk_X509_NAME_value(sk, n)) < 0)
                sk_X509_NAME_push(skCAList, sk_X509_NAME_value(sk, n));
d1033 1
d1036 5
a1040 3
                        X509_NAME_oneline(sk_X509_NAME_value(sk, n), buf, sizeof(buf)));
                if (sk_X509_NAME_find(skCAList, sk_X509_NAME_value(sk, n)) < 0)
                    sk_X509_NAME_push(skCAList, sk_X509_NAME_value(sk, n));
@


1.17
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d1 2
d169 2
a170 1
        ssl_log_open(s, s2, p);
a1121 1

@


1.16
log
@merge mod_ssl 2.8.7
--
Ok'd by: beck@@
@
text
@d441 1
a441 1
        /* no need to free dh, it's static */
d452 1
a452 1
        /* no need to free dh, it's static */
d986 1
d1006 1
a1006 1
        for(n = 0; sk != NULL && n < sk_X509_NAME_num(sk); n++) {
d1009 1
a1009 1
                    X509_NAME_oneline(sk_X509_NAME_value(sk, n), NULL, 0));
d1013 1
d1024 1
a1024 1
            for(n = 0; sk != NULL && n < sk_X509_NAME_num(sk); n++) {
d1027 1
a1027 1
                        X509_NAME_oneline(sk_X509_NAME_value(sk, n), NULL, 0));
d1031 1
d1080 4
@


1.15
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d126 1
a126 1
#ifdef __OpenBSD__    
d260 1
a260 1
	/* find out if anyone's actually doing ssl */
d264 1
a264 1
    if (SSLenabled) /* skip expensive bits if we're not doing ssl */
d299 2
a300 2
#ifdef __OpenBSD__    
    if (SSLenabled)  /* skip expensive bits if we're not doing ssl */
a306 1

d408 2
a409 2
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to generate temporary 512 bit RSA private key");
#if 0
a410 4
#else
	    ssl_log(s, SSL_LOG_ERROR, "Init: You probably have no RSA support in libcrypto. See ssl(8)");
	    return;
#endif
d420 2
a421 1
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to generate temporary 1024 bit RSA private key");
d785 2
a786 1
                    !ap_fnmatch(cp, s->server_hostname, FNM_PERIOD|FNM_CASE_BLIND)) {
d1107 2
@


1.15.4.1
log
@Pull in patch from current:
Fix (brad):
merge mod_ssl 2.8.7
@
text
@d126 1
a126 1
#ifdef __OpenBSD__
d259 1
a259 1
	sc = mySrvConfig(s2);
d261 2
a262 2
	if (sc->bEnabled)
	   SSLenabled = 1;
d299 2
a300 2
#ifdef __OpenBSD__
    if (SSLenabled)	/* skip expensive bits if we're not doing ssl */
d307 1
d409 2
a410 2
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR, 
                    "Init: Failed to generate temporary 512 bit RSA private key");
d412 4
d425 1
a425 2
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR, 
                    "Init: Failed to generate temporary 1024 bit RSA private key");
d789 1
a789 2
                    ap_fnmatch(cp, s->server_hostname, 
                               FNM_PERIOD|FNM_CASE_BLIND) == FNM_NOMATCH) {
a1109 2

    ssl_util_thread_cleanup();
@


1.15.2.1
log
@Upgrade mod_ssl to 2.8.7, to fix the recent vulnerability.

Requested, and patch from: brad@@
@
text
@d126 1
a126 1
#ifdef __OpenBSD__
d259 1
a259 1
	sc = mySrvConfig(s2);
d261 2
a262 2
	if (sc->bEnabled)
	   SSLenabled = 1;
d299 2
a300 2
#ifdef __OpenBSD__
    if (SSLenabled)	/* skip expensive bits if we're not doing ssl */
d307 1
d409 2
a410 2
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR, 
                    "Init: Failed to generate temporary 512 bit RSA private key");
d412 4
d425 1
a425 2
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR, 
                    "Init: Failed to generate temporary 1024 bit RSA private key");
d789 1
a789 2
                    ap_fnmatch(cp, s->server_hostname, 
                               FNM_PERIOD|FNM_CASE_BLIND) == FNM_NOMATCH) {
a1109 2

    ssl_util_thread_cleanup();
@


1.14
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2000 Ralf S. Engelschall. All rights reserved.
d468 3
d472 1
d482 3
d486 1
d498 3
d502 1
d512 3
d516 1
@


1.13
log
@cleanup
@
text
@d269 7
d359 29
@


1.12
log
@Bypass key generation if no SSL is not enabled in any (virtual) servers.
made fun and entertaining by the way apache initializes modules and DSO's
@
text
@d260 1
a260 5
        /*
         * Either now skip this server when SSL is disabled for
         * it or give out some information about what we're
         * configuring.
         */
@


1.11
log
@merge mod_ssl 2.6.6
@
text
@d126 3
d249 1
d251 1
d257 15
d296 3
d304 1
@


1.10
log
@Mod_SSL 2.6.5 - from brad@@, thanks.
@
text
@d1033 1
d1037 1
@


1.9
log
@mod_ssl 2.6.4 merge
From brad@@
@
text
@d1029 8
@


1.8
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d154 1
a154 1
#ifdef SSL_EXPERIMENTAL
d356 1
a356 1
#else 
d359 1
a359 1
#endif	
d828 6
@


1.7
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@a125 1
    int n;
d154 4
d271 1
a271 2
    n = ssl_rand_seed(s, p, SSL_RSCTX_STARTUP);
    ssl_log(s, SSL_LOG_INFO, "Init: Seeding PRNG with %d bytes of entropy", n);
d347 2
a348 1
        ssl_log(s, SSL_LOG_INFO, "Init: Generating temporary RSA private keys (512/1024 bits)");
d351 1
d354 1
d356 4
d552 1
a552 1
    if (mc->nSessionCacheMode == SSL_SCMODE_UNSET)
@


1.6
log
@mod_ssl 2.4.9 merge
@
text
@d12 1
a12 1
 * Copyright (c) 1998-1999 Ralf S. Engelschall. All rights reserved.
a348 9
#ifdef __OpenBSD__
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to generate temporary 512 bit RSA private key");
            ssl_log(s, SSL_LOG_ERROR, "Init: (SSL won't work without an RSA capable shared library)");
            ssl_log(s, SSL_LOG_ERROR, "Init: See ssl(8)");
            /* harmless in http only case. We'll get a fatal error below
             * if this didn't work and we try to init https servers
             */
            return;
#else
a350 1
#endif
d707 8
a714 1
                if (strNE(s->server_hostname, cp)) {
d883 1
a883 1
                "Init: You cannot use name-based virtual hosts in conjunction with SSL!!");
@


1.5
log
@ Mod_SSL 2.4.8 merge
@
text
@d167 1
a167 1
    if (mc->nInitCount == 1)
d172 6
@


1.4
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d237 1
d266 1
a266 1
     *  pre-generate the temporary RSA keys
d268 1
a268 43
    if (mc->pRSATmpKey512 == NULL) {
        ssl_log(s, SSL_LOG_INFO, "Init: Generating temporary RSA private keys (512/1024 bits)");
        mc->pRSATmpKey512 = RSA_generate_key(512, RSA_F4, NULL, NULL);
        if (mc->pRSATmpKey512 == NULL) {
#ifdef __OpenBSD__
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to generate temporary (512 b
it) RSA private key (SSL won't work without an RSA capable shared library)");
            ssl_log(s, SSL_LOG_ERROR, "Init: pkg_add ftp://ftp.openbsd.org/pub/O
penBSD/<version>/packages/<arch>/libssl-2.1.tgz if you are able to use RSA");
            /* harmless in http only case. We'll get a fatal error below
             * if this didn't work and we try to init https servers
             */
            return;
#else
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to generate temporary (512 b
it) RSA private key");
            ssl_die();
#endif

        }
        mc->pRSATmpKey1024 = RSA_generate_key(1024, RSA_F4, NULL, NULL);
        if (mc->pRSATmpKey1024 == NULL) {
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to generate temporary 1024 bit RSA private key");
            ssl_die();
        }
    }

    /*
     *  pre-configure the temporary DH parameters
     */
    if (mc->pDHTmpParam512 == NULL) {
        ssl_log(s, SSL_LOG_INFO, "Init: Configuring temporary DH parameters (512/1024 bits)");
        mc->pDHTmpParam512 = ssl_dh_GetTmpParam(512);
        if (mc->pDHTmpParam512 == NULL) {
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to configure temporary 512 bit DH parameters");
            ssl_die();
        }
        mc->pDHTmpParam1024 = ssl_dh_GetTmpParam(1024);
        if (mc->pDHTmpParam1024 == NULL) {
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to configure temporary 1024 bit DH parameters");
            ssl_die();
        }
    }
d326 143
d646 6
a651 1
        sc->pPublicCert[SSL_AIDX_RSA] = d2i_X509(NULL, &ucp, asn1->nData);
d665 6
a670 1
        sc->pPublicCert[SSL_AIDX_DSA] = d2i_X509(NULL, &ucp, asn1->nData);
d730 7
a736 2
        sc->pPrivateKey[SSL_AIDX_RSA] = 
            d2i_PrivateKey(EVP_PKEY_RSA, NULL, &ucp, asn1->nData);
d739 1
a739 1
                    "Init: (%s) Unable to configure server RSA private key",
d750 7
a756 2
        sc->pPrivateKey[SSL_AIDX_DSA] = 
            d2i_PrivateKey(EVP_PKEY_DSA, NULL, &ucp, asn1->nData);
d759 1
a759 1
                    "Init: (%s) Unable to configure server DSA private key",
d978 5
@


1.3
log
@proper URL for fetching package; evanc@@concer.to
@
text
@d2 4
a5 4
**  _ __ ___   ___   __| |    ___ ___| |
** | '_ ` _ \ / _ \ / _` |   / __/ __| |
** | | | | | | (_) | (_| |   \__ \__ \ | mod_ssl - Apache Interface to SSLeay
** |_| |_| |_|\___/ \__,_|___|___/___/_| http://www.engelschall.com/sw/mod_ssl/
d30 1
a30 1
 *     mod_ssl project (http://www.engelschall.com/sw/mod_ssl/)."
d45 1
a45 1
 *     mod_ssl project (http://www.engelschall.com/sw/mod_ssl/)."
d131 5
d161 1
a161 1
        ssl_log_open(s2, p);
d164 12
d184 5
d225 3
a227 1
    ssl_init_SSLLibrary(s);
d229 5
a233 2
    if (mc->nInitCount <= 2)
        ssl_init_SSLLibrary(s);
d265 1
a265 1
     *  pre-generate the temporary RSA key
d267 4
a270 4
    if (mc->pRSATmpKey == NULL) {
        ssl_log(s, SSL_LOG_INFO, "Init: Generating temporary (512 bit) RSA private key");
        mc->pRSATmpKey = RSA_generate_key(512, RSA_F4, NULL, NULL);
        if (mc->pRSATmpKey == NULL) {
d272 8
a279 6
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to generate temporary (512 bit) RSA private key (SSL won't work without an RSA capable shared library)");
	    ssl_log(s, SSL_LOG_ERROR, "Init: pkg_add ftp://ftp.openbsd.org/pub/OpenBSD/<version>/packages/<arch>/libssl-1.1.tgz if you are able to use RSA");
	    /* harmless in http only case. We'll get a fatal error below 
	     * if this didn't work and we try to init https servers 
             */ 
	    return; 
d281 2
a282 1
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to generate temporary (512 bit) RSA private key");
d285 23
d315 3
a317 17
    for (; s != NULL; s = s->next) {
        sc = mySrvConfig(s);

        /* 
         * Give out warnings when HTTPS is configured for
         * the HTTP port or vice versa
         */
        if (sc->bEnabled && s->port == DEFAULT_HTTP_PORT)
            ssl_log(s, SSL_LOG_WARN,
                    "Init: You configured HTTPS(%d) on the standard HTTP(%d) port!",
                    DEFAULT_HTTPS_PORT, DEFAULT_HTTP_PORT);
        if (!sc->bEnabled && s->port == DEFAULT_HTTPS_PORT)
            ssl_log(s, SSL_LOG_WARN,
                    "Init: You configured HTTP(%d) on the standard HTTPS(%d) port!",
                    DEFAULT_HTTP_PORT, DEFAULT_HTTPS_PORT);

        /* 
d324 1
a324 1
        ssl_log(s, SSL_LOG_INFO,
d326 1
a326 1
                ssl_util_vhostid(p, s));
d331 1
a331 1
        ssl_init_GetCertAndKey(s, p, sc);
d335 5
d354 1
a354 1
void ssl_init_SSLLibrary(server_rec *s)
a355 1
    ssl_log(s, SSL_LOG_INFO, "Init: Initializing %s library", SSL_LIBRARY_NAME);
d360 1
a360 1
    SSLeay_add_ssl_algorithms();
d362 1
d367 1
a367 1
 * Read the SSL Server Certificate and Key
d369 1
a369 1
void ssl_init_GetCertAndKey(server_rec *s, pool *p, SSLSrvConfigRec *sc)
d374 1
d376 1
a376 1
    STACK *skCAList;
d378 1
d380 4
d394 1
a394 1
    if (sc->szCertificateFile == NULL) {
d404 2
a405 1
    if (sc->px509Certificate) {
d421 2
a422 2
    cp = ap_pstrcat(p, (sc->nProtocol & SSL_PROTOCOL_SSLV2 ? "SSLv2, " : ""), 
                       (sc->nProtocol & SSL_PROTOCOL_SSLV3 ? "SSLv3, " : ""), 
d425 1
a425 1
    ssl_log(s, SSL_LOG_TRACE, 
d428 1
a428 1
        ctx = SSL_CTX_new(SSLv2_server_method());  /* only SSLv2 is left */ 
d431 1
d436 1
a436 1
    if (!(sc->nProtocol & SSL_PROTOCOL_TLSV1)) 
d442 9
d464 1
a469 2
    ssl_log(s, SSL_LOG_TRACE,
            "Init: (%s) Configuring permitted SSL ciphers", cpVHostID);
d471 4
a474 1
        if (!SSL_CTX_set_cipher_list(sc->pSSLCtx, sc->szCipherSuite)) {
d488 2
a489 2
        if (!SSL_CTX_load_verify_locations(sc->pSSLCtx,
                                           sc->szCACertificateFile, 
d507 16
d527 3
a529 3
        skCAList = SSL_CTX_get_client_CA_list(sc->pSSLCtx);
        if (sk_num(skCAList) == 0)
            ssl_log(s, SSL_LOG_WARN, 
d536 1
a536 1
     *  Configure server certificate
d538 32
a569 3
    ssl_log(s, SSL_LOG_TRACE,
            "Init: (%s) Configuring server certificate", cpVHostID);
    if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tPublicCert, cpVHostID)) == NULL) {
d571 1
a571 1
                "Init: (%s) Ops, can't find server certificate?!", cpVHostID);
a573 1
    sc->px509Certificate = d2i_X509(NULL, &(asn1->cpData), asn1->nData);
d576 1
a576 1
     *  Configure server private key
d578 66
a643 3
    ssl_log(s, SSL_LOG_TRACE,
            "Init: (%s) Configuring server private key", cpVHostID);
    if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tPrivateKey, cpVHostID)) == NULL) {
d645 1
a645 1
                "Init: (%s) Ops, can't find server private key?!", cpVHostID);
d648 111
a758 1
    sc->prsaKey = d2i_RSAPrivateKey(NULL, &(asn1->cpData), asn1->nData);
d768 1
a768 1
STACK *ssl_init_FindCAList(server_rec *s, pool *pp, char *cpCAfile, char *cpCApath)
d770 2
a771 2
    STACK *skCAList;
    STACK *sk;
d789 1
a789 1
    skCAList = sk_new(ssl_init_FindCAList_X509NameCmp);
d796 1
a796 1
        for(n = 0; sk != NULL && n < sk_num(sk); n++) {
d799 3
a801 3
                    X509_NAME_oneline((X509_NAME *)sk_value(sk, n), NULL, 0));
            if (sk_find(skCAList, sk_value(sk, n)) < 0)
                sk_push(skCAList, sk_value(sk, n));
d813 1
a813 1
            for(n = 0; sk != NULL && n < sk_num(sk); n++) {
d816 3
a818 3
                        X509_NAME_oneline((X509_NAME *)sk_value(sk, n), NULL, 0));
                if (sk_find(skCAList, sk_value(sk, n)) < 0)
                    sk_push(skCAList, sk_value(sk, n));
d827 1
a827 1
    sk_set_cmp_func(skCAList, NULL);
d836 1
a836 1
     ssl_mutex_open(s, p);
d838 47
@


1.2
log
@don't fatal out on init if RSA doesn't work, so as not to die if an RSA
libssl isn't installed and we only want to do http
@
text
@d246 1
a246 1
	    ssl_log(s, SSL_LOG_ERROR, "Init: pkg_add ftp://ftp.openbsd.org/pub/2.5/packages/<arch>/libssl-1.1.tgz if you are able to use RSA");
@


1.1
log
@mod_ssl-2.2.3-1.3.4 (will require libssl-1.1 for https to work, but
mostly harmless otherwise).
@
text
@d244 8
d254 1
@


1.1.1.1
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@d2 4
a5 4
**  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
** | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
** | | | | | | (_) | (_| |   \__ \__ \ |  www.modssl.org
** |_| |_| |_|\___/ \__,_|___|___/___/_|  ftp.modssl.org
d12 1
a12 1
 * Copyright (c) 1998-2001 Ralf S. Engelschall. All rights reserved.
d30 1
a30 1
 *     mod_ssl project (http://www.modssl.org/)."
d45 1
a45 1
 *     mod_ssl project (http://www.modssl.org/)."
d126 1
a130 5
     * Let us cleanup on restarts and exists
     */
    ap_register_cleanup(p, s, ssl_init_ModuleKill, ssl_init_ChildKill);

    /*
a149 4
#ifdef SSL_EXPERIMENTAL_PROXY
        if (sc->nProxyVerifyDepth == UNSET)
            sc->nProxyVerifyDepth = 1;
#endif
d156 1
a156 1
        ssl_log_open(s, s2, p);
a158 18
    /*
     * Identification
     */
    if (mc->nInitCount == 1) {
        ssl_log(s, SSL_LOG_INFO, "Server: %s, Interface: %s, Library: %s",
                SERVER_BASEVERSION,
                ssl_var_lookup(p, NULL, NULL, NULL, "SSL_VERSION_INTERFACE"),
                ssl_var_lookup(p, NULL, NULL, NULL, "SSL_VERSION_LIBRARY"));
#ifdef WIN32
        ssl_log(s, SSL_LOG_WARN, "You are using mod_ssl under Win32. " 
                "This combination is *NOT* officially supported. "
                "Use it at your own risk!");
#endif
    }

    /*
     * Initialization round information
     */
a166 5
#ifdef SSL_VENDOR
    ap_hook_use("ap::mod_ssl::vendor::init_module",
                AP_HOOK_SIG3(void,ptr,ptr), AP_HOOK_ALL, s, p);
#endif

d203 1
a203 6
    ssl_log(s, SSL_LOG_INFO, "Init: %snitializing %s library",
            mc->nInitCount == 1 ? "I" : "Rei", SSL_LIBRARY_NAME);
#ifdef SSL_EXPERIMENTAL_ENGINE
    ssl_init_Engine(s, p);
#endif
    ssl_init_SSLLibrary();
d205 2
a206 8
    if (mc->nInitCount <= 2) {
        ssl_log(s, SSL_LOG_INFO, "Init: %snitializing %s library",
                mc->nInitCount == 1 ? "I" : "Rei", SSL_LIBRARY_NAME);
#ifdef SSL_EXPERIMENTAL_ENGINE
        ssl_init_Engine(s, p);
#endif
        ssl_init_SSLLibrary();
    }
a209 1
        ssl_init_TmpKeysHandle(SSL_TKP_GEN, s, p);
d234 2
a235 1
    ssl_rand_seed(s, p, SSL_RSCTX_STARTUP, "Init: ");
d238 1
a238 1
     *  allocate the temporary RSA keys and DH params
d240 8
a247 1
    ssl_init_TmpKeysHandle(SSL_TKP_ALLOC, s, p);
d253 17
a269 3
    for (s2 = s; s2 != NULL; s2 = s2->next) {
        sc = mySrvConfig(s2);
        /*
d276 1
a276 1
        ssl_log(s2, SSL_LOG_INFO,
d278 1
a278 1
                ssl_util_vhostid(p, s2));
d283 1
a283 1
        ssl_init_ConfigureServer(s2, p, sc);
a286 5
     * Configuration consistency checks
     */
    ssl_init_CheckServers(s, p);

    /*
d301 1
a301 1
void ssl_init_SSLLibrary(void)
d303 1
d308 1
a308 1
    SSL_library_init();
a309 1
    X509V3_add_standard_extensions();
d314 1
a314 2
 * Support for external a Crypto Device ("engine"), usually
 * a hardware accellerator card for crypto operations.
d316 1
a316 182
#ifdef SSL_EXPERIMENTAL_ENGINE
void ssl_init_Engine(server_rec *s, pool *p)
{
    SSLModConfigRec *mc = myModConfig();
    ENGINE *e;

    if (mc->szCryptoDevice != NULL) {
        if ((e = ENGINE_by_id(mc->szCryptoDevice)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to load Crypto Device API `%s'",
                    mc->szCryptoDevice);
            ssl_die();
        }
        if (strEQ(mc->szCryptoDevice, "chil")) 
            ENGINE_ctrl(e, ENGINE_CTRL_CHIL_SET_FORKCHECK, 1, 0, 0);
        if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to enable Crypto Device API `%s'",
                    mc->szCryptoDevice);
            ssl_die();
        }
        ENGINE_free(e);
    }
    return;
}
#endif

/*
 * Handle the Temporary RSA Keys and DH Params
 */
void ssl_init_TmpKeysHandle(int action, server_rec *s, pool *p)
{
    SSLModConfigRec *mc = myModConfig();
    ssl_asn1_t *asn1;
    unsigned char *ucp;
    RSA *rsa;
    DH *dh;

    /* Generate Keys and Params */
    if (action == SSL_TKP_GEN) {

        /* seed PRNG */
        ssl_rand_seed(s, p, SSL_RSCTX_STARTUP, "Init: ");

        /* generate 512 bit RSA key */
        ssl_log(s, SSL_LOG_INFO, "Init: Generating temporary RSA private keys (512/1024 bits)");
        if ((rsa = RSA_generate_key(512, RSA_F4, NULL, NULL)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR, 
                    "Init: Failed to generate temporary 512 bit RSA private key");
            ssl_die();
        }
        asn1 = (ssl_asn1_t *)ssl_ds_table_push(mc->tTmpKeys, "RSA:512");
        asn1->nData  = i2d_RSAPrivateKey(rsa, NULL);
        asn1->cpData = ap_palloc(mc->pPool, asn1->nData);
        ucp = asn1->cpData; i2d_RSAPrivateKey(rsa, &ucp); /* 2nd arg increments */
        RSA_free(rsa);

        /* generate 1024 bit RSA key */
        if ((rsa = RSA_generate_key(1024, RSA_F4, NULL, NULL)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR, 
                    "Init: Failed to generate temporary 1024 bit RSA private key");
            ssl_die();
        }
        asn1 = (ssl_asn1_t *)ssl_ds_table_push(mc->tTmpKeys, "RSA:1024");
        asn1->nData  = i2d_RSAPrivateKey(rsa, NULL);
        asn1->cpData = ap_palloc(mc->pPool, asn1->nData);
        ucp = asn1->cpData; i2d_RSAPrivateKey(rsa, &ucp); /* 2nd arg increments */
        RSA_free(rsa);

        ssl_log(s, SSL_LOG_INFO, "Init: Configuring temporary DH parameters (512/1024 bits)");

        /* import 512 bit DH param */
        if ((dh = ssl_dh_GetTmpParam(512)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to import temporary 512 bit DH parameters");
            ssl_die();
        }
        asn1 = (ssl_asn1_t *)ssl_ds_table_push(mc->tTmpKeys, "DH:512");
        asn1->nData  = i2d_DHparams(dh, NULL);
        asn1->cpData = ap_palloc(mc->pPool, asn1->nData);
        ucp = asn1->cpData; i2d_DHparams(dh, &ucp); /* 2nd arg increments */
        DH_free(dh);

        /* import 1024 bit DH param */
        if ((dh = ssl_dh_GetTmpParam(1024)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR, "Init: Failed to import temporary 1024 bit DH parameters");
            ssl_die();
        }
        asn1 = (ssl_asn1_t *)ssl_ds_table_push(mc->tTmpKeys, "DH:1024");
        asn1->nData  = i2d_DHparams(dh, NULL);
        asn1->cpData = ap_palloc(mc->pPool, asn1->nData);
        ucp = asn1->cpData; i2d_DHparams(dh, &ucp); /* 2nd arg increments */
        DH_free(dh);
    }

    /* Allocate Keys and Params */
    else if (action == SSL_TKP_ALLOC) {

        ssl_log(s, SSL_LOG_INFO, "Init: Configuring temporary RSA private keys (512/1024 bits)");

        /* allocate 512 bit RSA key */
        if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tTmpKeys, "RSA:512")) != NULL) {
            ucp = asn1->cpData;
            if ((mc->pTmpKeys[SSL_TKPIDX_RSA512] = 
#if SSL_LIBRARY_VERSION >= 0x00907000
                 (void *)d2i_RSAPrivateKey(NULL, (const unsigned char **)&ucp, asn1->nData)) == NULL) {
#else
                 (void *)d2i_RSAPrivateKey(NULL, &ucp, asn1->nData)) == NULL) {
#endif
                ssl_log(s, SSL_LOG_ERROR, "Init: Failed to load temporary 512 bit RSA private key");
                ssl_die();
            }
        }

        /* allocate 1024 bit RSA key */
        if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tTmpKeys, "RSA:1024")) != NULL) {
            ucp = asn1->cpData;
            if ((mc->pTmpKeys[SSL_TKPIDX_RSA1024] = 
#if SSL_LIBRARY_VERSION >= 0x00907000
                 (void *)d2i_RSAPrivateKey(NULL, (const unsigned char **)&ucp, asn1->nData)) == NULL) {
#else
                 (void *)d2i_RSAPrivateKey(NULL, &ucp, asn1->nData)) == NULL) {
#endif
                ssl_log(s, SSL_LOG_ERROR, "Init: Failed to load temporary 1024 bit RSA private key");
                ssl_die();
            }
        }

        ssl_log(s, SSL_LOG_INFO, "Init: Configuring temporary DH parameters (512/1024 bits)");

        /* allocate 512 bit DH param */
        if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tTmpKeys, "DH:512")) != NULL) {
            ucp = asn1->cpData;
            if ((mc->pTmpKeys[SSL_TKPIDX_DH512] = 
#if SSL_LIBRARY_VERSION >= 0x00907000
                 (void *)d2i_DHparams(NULL, (const unsigned char **)&ucp, asn1->nData)) == NULL) {
#else
                 (void *)d2i_DHparams(NULL, &ucp, asn1->nData)) == NULL) {
#endif
                ssl_log(s, SSL_LOG_ERROR, "Init: Failed to load temporary 512 bit DH parameters");
                ssl_die();
            }
        }

        /* allocate 1024 bit DH param */
        if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tTmpKeys, "DH:1024")) != NULL) {
            ucp = asn1->cpData;
            if ((mc->pTmpKeys[SSL_TKPIDX_DH1024] = 
#if SSL_LIBRARY_VERSION >= 0x00907000
                 (void *)d2i_DHparams(NULL, (const unsigned char **)&ucp, asn1->nData)) == NULL) {
#else
                 (void *)d2i_DHparams(NULL, &ucp, asn1->nData)) == NULL) {
#endif
                ssl_log(s, SSL_LOG_ERROR, "Init: Failed to load temporary 1024 bit DH parameters");
                ssl_die();
            }
        }
    }

    /* Free Keys and Params */
    else if (action == SSL_TKP_FREE) {
        if (mc->pTmpKeys[SSL_TKPIDX_RSA512] != NULL) {
            RSA_free((RSA *)mc->pTmpKeys[SSL_TKPIDX_RSA512]);
            mc->pTmpKeys[SSL_TKPIDX_RSA512] = NULL;
        }
        if (mc->pTmpKeys[SSL_TKPIDX_RSA1024] != NULL) {
            RSA_free((RSA *)mc->pTmpKeys[SSL_TKPIDX_RSA1024]);
            mc->pTmpKeys[SSL_TKPIDX_RSA1024] = NULL;
        }
        if (mc->pTmpKeys[SSL_TKPIDX_DH512] != NULL) {
            DH_free((DH *)mc->pTmpKeys[SSL_TKPIDX_DH512]);
            mc->pTmpKeys[SSL_TKPIDX_DH512] = NULL;
        }
        if (mc->pTmpKeys[SSL_TKPIDX_DH1024] != NULL) {
            DH_free((DH *)mc->pTmpKeys[SSL_TKPIDX_DH1024]);
            mc->pTmpKeys[SSL_TKPIDX_DH1024] = NULL;
        }
    }
    return;
}

/*
 * Configure a particular server
 */
void ssl_init_ConfigureServer(server_rec *s, pool *p, SSLSrvConfigRec *sc)
a320 1
    EVP_PKEY *pKey;
d322 1
a322 1
    STACK_OF(X509_NAME) *skCAList;
a323 1
    unsigned char *ucp;
a324 4
    BOOL ok;
    BOOL bSkipFirst;
    int isca, pathlen;
    int i, n;
d335 1
a335 1
    if (sc->szPublicCertFile[0] == NULL) {
d345 1
a345 2
    if (sc->pPublicCert[SSL_AIDX_RSA] != NULL ||
        sc->pPublicCert[SSL_AIDX_DSA] != NULL   ) {
d361 2
a362 2
    cp = ap_pstrcat(p, (sc->nProtocol & SSL_PROTOCOL_SSLV2 ? "SSLv2, " : ""),
                       (sc->nProtocol & SSL_PROTOCOL_SSLV3 ? "SSLv3, " : ""),
d365 1
a365 1
    ssl_log(s, SSL_LOG_TRACE,
d368 1
a368 1
        ctx = SSL_CTX_new(SSLv2_server_method());  /* only SSLv2 is left */
a370 1
    SSL_CTX_set_options(ctx, SSL_OP_ALL);
d375 1
a375 1
    if (!(sc->nProtocol & SSL_PROTOCOL_TLSV1))
a380 9
     * Configure additional context ingredients
     */
    SSL_CTX_set_options(ctx, SSL_OP_SINGLE_DH_USE);
    if (mc->nSessionCacheMode == SSL_SCMODE_NONE)
        SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);
    else
        SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_SERVER);

    /*
a393 1
    SSL_CTX_set_tmp_dh_callback(ctx,  ssl_callback_TmpDH);
d399 2
d402 1
a402 4
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring permitted SSL ciphers [%s]", 
                cpVHostID, sc->szCipherSuite);
        if (!SSL_CTX_set_cipher_list(ctx, sc->szCipherSuite)) {
d416 2
a417 2
        if (!SSL_CTX_load_verify_locations(ctx,
                                           sc->szCACertificateFile,
a434 16
     * Configure Certificate Revocation List (CRL) Details
     */
    if (sc->szCARevocationFile != NULL || sc->szCARevocationPath != NULL) {
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring certificate revocation facility", cpVHostID);
        if ((sc->pRevocationStore =
                SSL_X509_STORE_create(sc->szCARevocationFile,
                                      sc->szCARevocationPath)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to configure X.509 CRL storage "
                    "for certificate revocation", cpVHostID);
            ssl_die();
        }
    }

    /*
d439 3
a441 3
        skCAList = SSL_CTX_get_client_CA_list(ctx);
        if (sk_X509_NAME_num(skCAList) == 0)
            ssl_log(s, SSL_LOG_WARN,
d448 1
a448 1
     *  Configure server certificate(s)
d450 3
a452 42
    ok = FALSE;
    cp = ap_psprintf(p, "%s:RSA", cpVHostID);
    if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tPublicCert, cp)) != NULL) {
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring RSA server certificate", cpVHostID);
        ucp = asn1->cpData;
        if ((sc->pPublicCert[SSL_AIDX_RSA] = d2i_X509(NULL, &ucp, asn1->nData)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to import RSA server certificate",
                    cpVHostID);
            ssl_die();
        }
        if (SSL_CTX_use_certificate(ctx, sc->pPublicCert[SSL_AIDX_RSA]) <= 0) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to configure RSA server certificate",
                    cpVHostID);
            ssl_die();
        }
        ok = TRUE;
    }
    cp = ap_psprintf(p, "%s:DSA", cpVHostID);
    if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tPublicCert, cp)) != NULL) {
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring DSA server certificate", cpVHostID);
        ucp = asn1->cpData;
        if ((sc->pPublicCert[SSL_AIDX_DSA] = d2i_X509(NULL, &ucp, asn1->nData)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to import DSA server certificate",
                    cpVHostID);
            ssl_die();
        }
        if (SSL_CTX_use_certificate(ctx, sc->pPublicCert[SSL_AIDX_DSA]) <= 0) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to configure DSA server certificate",
                    cpVHostID);
            ssl_die();
        }
        ok = TRUE;
    }
    if (!ok) {
        ssl_log(s, SSL_LOG_ERROR,
                "Init: (%s) Ops, no RSA or DSA server certificate found?!", cpVHostID);
d454 1
a454 1
                "Init: (%s) You have to perform a *full* server restart when you added or removed a certificate and/or key file", cpVHostID);
d457 1
d460 1
a460 1
     * Some information about the certificate(s)
d462 3
a464 84
    for (i = 0; i < SSL_AIDX_MAX; i++) {
        if (sc->pPublicCert[i] != NULL) {
            if (SSL_X509_isSGC(sc->pPublicCert[i])) {
                ssl_log(s, SSL_LOG_INFO,
                        "Init: (%s) %s server certificate enables "
                        "Server Gated Cryptography (SGC)", 
                        cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"));
            }
            if (SSL_X509_getBC(sc->pPublicCert[i], &isca, &pathlen)) {
                if (isca)
                    ssl_log(s, SSL_LOG_WARN,
                        "Init: (%s) %s server certificate is a CA certificate "
                        "(BasicConstraints: CA == TRUE !?)",
                        cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"));
                if (pathlen > 0)
                    ssl_log(s, SSL_LOG_WARN,
                        "Init: (%s) %s server certificate is not a leaf certificate "
                        "(BasicConstraints: pathlen == %d > 0 !?)",
                        cpVHostID, (i == SSL_AIDX_RSA ? "RSA" : "DSA"), pathlen);
            }
            if (SSL_X509_getCN(p, sc->pPublicCert[i], &cp)) {
                if (ap_is_fnmatch(cp) &&
                    ap_fnmatch(cp, s->server_hostname, 
                               FNM_PERIOD|FNM_CASE_BLIND) == FNM_NOMATCH) {
                    ssl_log(s, SSL_LOG_WARN,
                        "Init: (%s) %s server certificate wildcard CommonName (CN) `%s' "
                        "does NOT match server name!?", cpVHostID, 
                        (i == SSL_AIDX_RSA ? "RSA" : "DSA"), cp);
                }
                else if (strNE(s->server_hostname, cp)) {
                    ssl_log(s, SSL_LOG_WARN,
                        "Init: (%s) %s server certificate CommonName (CN) `%s' "
                        "does NOT match server name!?", cpVHostID, 
                        (i == SSL_AIDX_RSA ? "RSA" : "DSA"), cp);
                }
            }
        }
    }

    /*
     *  Configure server private key(s)
     */
    ok = FALSE;
    cp = ap_psprintf(p, "%s:RSA", cpVHostID);
    if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tPrivateKey, cp)) != NULL) {
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring RSA server private key", cpVHostID);
        ucp = asn1->cpData;
        if ((sc->pPrivateKey[SSL_AIDX_RSA] = 
             d2i_PrivateKey(EVP_PKEY_RSA, NULL, &ucp, asn1->nData)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to import RSA server private key",
                    cpVHostID);
            ssl_die();
        }
        if (SSL_CTX_use_PrivateKey(ctx, sc->pPrivateKey[SSL_AIDX_RSA]) <= 0) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to configure RSA server private key",
                    cpVHostID);
            ssl_die();
        }
        ok = TRUE;
    }
    cp = ap_psprintf(p, "%s:DSA", cpVHostID);
    if ((asn1 = (ssl_asn1_t *)ssl_ds_table_get(mc->tPrivateKey, cp)) != NULL) {
        ssl_log(s, SSL_LOG_TRACE,
                "Init: (%s) Configuring DSA server private key", cpVHostID);
        ucp = asn1->cpData;
        if ((sc->pPrivateKey[SSL_AIDX_DSA] = 
             d2i_PrivateKey(EVP_PKEY_DSA, NULL, &ucp, asn1->nData)) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to import DSA server private key",
                    cpVHostID);
            ssl_die();
        }
        if (SSL_CTX_use_PrivateKey(ctx, sc->pPrivateKey[SSL_AIDX_DSA]) <= 0) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to configure DSA server private key",
                    cpVHostID);
            ssl_die();
        }
        ok = TRUE;
    }
    if (!ok) {
d466 1
a466 1
                "Init: (%s) Ops, no RSA or DSA server private key found?!", cpVHostID);
d469 1
a469 119

    /*
     * Optionally copy DSA parameters for certificate from private key
     * (see http://www.psy.uq.edu.au/~ftp/Crypto/ssleay/TODO.html)
     */
    if (   sc->pPublicCert[SSL_AIDX_DSA] != NULL
        && sc->pPrivateKey[SSL_AIDX_DSA] != NULL) {
        pKey = X509_get_pubkey(sc->pPublicCert[SSL_AIDX_DSA]);
        if (   pKey != NULL
            && EVP_PKEY_type(pKey->type) == EVP_PKEY_DSA 
            && EVP_PKEY_missing_parameters(pKey))
            EVP_PKEY_copy_parameters(pKey, sc->pPrivateKey[SSL_AIDX_DSA]);
    }

    /* 
     * Optionally configure extra server certificate chain certificates.
     * This is usually done by OpenSSL automatically when one of the
     * server cert issuers are found under SSLCACertificatePath or in
     * SSLCACertificateFile. But because these are intended for client
     * authentication it can conflict. For instance when you use a
     * Global ID server certificate you've to send out the intermediate
     * CA certificate, too. When you would just configure this with
     * SSLCACertificateFile and also use client authentication mod_ssl
     * would accept all clients also issued by this CA. Obviously this
     * isn't what we want in this situation. So this feature here exists
     * to allow one to explicity configure CA certificates which are
     * used only for the server certificate chain.
     */
    if (sc->szCertificateChain != NULL) {
        bSkipFirst = FALSE;
        for (i = 0; i < SSL_AIDX_MAX && sc->szPublicCertFile[i] != NULL; i++) {
            if (strEQ(sc->szPublicCertFile[i], sc->szCertificateChain)) {
                bSkipFirst = TRUE;
                break;
            }
        }
        if ((n = SSL_CTX_use_certificate_chain(ctx, sc->szCertificateChain, 
                                               bSkipFirst, NULL)) < 0) {
            ssl_log(s, SSL_LOG_ERROR,
                    "Init: (%s) Failed to configure CA certificate chain!", cpVHostID);
            ssl_die();
        }
        ssl_log(s, SSL_LOG_TRACE, "Init: (%s) Configuring "
                "server certificate chain (%d CA certificate%s)", cpVHostID,
                n, n == 1 ? "" : "s");
    }

#ifdef SSL_VENDOR
    ap_hook_use("ap::mod_ssl::vendor::configure_server",
                AP_HOOK_SIG4(void,ptr,ptr,ptr), AP_HOOK_ALL, 
                s, p, sc);
#endif

    return;
}

void ssl_init_CheckServers(server_rec *sm, pool *p)
{
    server_rec *s;
    server_rec **ps;
    SSLSrvConfigRec *sc;
    ssl_ds_table *t;
    pool *sp;
    char *key;
    BOOL bConflict;

    /*
     * Give out warnings when a server has HTTPS configured 
     * for the HTTP port or vice versa
     */
    for (s = sm; s != NULL; s = s->next) {
        sc = mySrvConfig(s);
        if (sc->bEnabled && s->port == DEFAULT_HTTP_PORT)
            ssl_log(sm, SSL_LOG_WARN,
                    "Init: (%s) You configured HTTPS(%d) on the standard HTTP(%d) port!",
                    ssl_util_vhostid(p, s), DEFAULT_HTTPS_PORT, DEFAULT_HTTP_PORT);
        if (!sc->bEnabled && s->port == DEFAULT_HTTPS_PORT)
            ssl_log(sm, SSL_LOG_WARN,
                    "Init: (%s) You configured HTTP(%d) on the standard HTTPS(%d) port!",
                    ssl_util_vhostid(p, s), DEFAULT_HTTP_PORT, DEFAULT_HTTPS_PORT);
    }

    /*
     * Give out warnings if more than one SSL-aware virtual server uses the
     * same IP:port. This doesn't work because mod_ssl then will always use
     * just the certificate/keys of one virtual host (which one cannot be said
     * easily - but that doesn't matter here).
     */
    sp = ap_make_sub_pool(p);
    t = ssl_ds_table_make(sp, sizeof(server_rec *));
    bConflict = FALSE;
    for (s = sm; s != NULL; s = s->next) {
        sc = mySrvConfig(s);
        if (!sc->bEnabled)
            continue;
        if (s->addrs == NULL)
            continue;
        key = ap_psprintf(sp, "%pA:%u", &s->addrs->host_addr, s->addrs->host_port);
        ps = ssl_ds_table_get(t, key);
        if (ps != NULL) {
            ssl_log(sm, SSL_LOG_WARN,
                    "Init: SSL server IP/port conflict: %s (%s:%d) vs. %s (%s:%d)",
                    ssl_util_vhostid(p, s), 
                    (s->defn_name != NULL ? s->defn_name : "unknown"),
                    s->defn_line_number,
                    ssl_util_vhostid(p, *ps),
                    ((*ps)->defn_name != NULL ? (*ps)->defn_name : "unknown"), 
                    (*ps)->defn_line_number);
            bConflict = TRUE;
            continue;
        }
        ps = ssl_ds_table_push(t, key);
        *ps = s;
    }
    ssl_ds_table_kill(t);
    ap_destroy_pool(sp);
    if (bConflict)
        ssl_log(sm, SSL_LOG_WARN,
                "Init: You should not use name-based virtual hosts in conjunction with SSL!!");
d479 1
a479 1
STACK_OF(X509_NAME) *ssl_init_FindCAList(server_rec *s, pool *pp, char *cpCAfile, char *cpCApath)
d481 2
a482 2
    STACK_OF(X509_NAME) *skCAList;
    STACK_OF(X509_NAME) *sk;
a487 1
    char buf[256];
d500 1
a500 1
    skCAList = sk_X509_NAME_new(ssl_init_FindCAList_X509NameCmp);
d507 1
a507 2
        for (n = 0; sk != NULL && n < sk_X509_NAME_num(sk); n++) {
            X509_NAME *name = sk_X509_NAME_value(sk, n);
d510 3
a512 5
                    X509_NAME_oneline(name, buf, sizeof(buf)));
            if (sk_X509_NAME_find(skCAList, name) < 0)
                sk_X509_NAME_push(skCAList, name); /* will be freed when skCAList is */
            else
                X509_NAME_free(name);
a513 1
        sk_X509_NAME_free(sk);
d524 1
a524 2
            for (n = 0; sk != NULL && n < sk_X509_NAME_num(sk); n++) {
                X509_NAME *name = sk_X509_NAME_value(sk, n);
d527 3
a529 5
                        X509_NAME_oneline(name, buf, sizeof(buf)));
                if (sk_X509_NAME_find(skCAList, name) < 0)
                    sk_X509_NAME_push(skCAList, name);
                else
                    X509_NAME_free(name);
a530 1
            sk_X509_NAME_free(sk);
d538 1
a538 1
    sk_X509_NAME_set_cmp_func(skCAList, NULL);
d547 1
a547 1
     ssl_mutex_reinit(s, p);
a548 68
}

void ssl_init_ChildKill(void *data)
{
    /* currently nothing to do */
    return;
}

void ssl_init_ModuleKill(void *data)
{
    SSLSrvConfigRec *sc;
    server_rec *s = (server_rec *)data;

    /*
     * Drop the session cache and mutex
     */
    ssl_scache_kill(s);
    ssl_mutex_kill(s);

    /* 
     * Destroy the temporary keys and params
     */
    ssl_init_TmpKeysHandle(SSL_TKP_FREE, s, NULL);

    /*
     * Free the non-pool allocated structures
     * in the per-server configurations
     */
    for (; s != NULL; s = s->next) {
        sc = mySrvConfig(s);
        if (sc->pRevocationStore != NULL) {
            X509_STORE_free(sc->pRevocationStore);
            sc->pRevocationStore = NULL;
        }
        if (sc->pPublicCert[SSL_AIDX_RSA] != NULL) {
            X509_free(sc->pPublicCert[SSL_AIDX_RSA]);
            sc->pPublicCert[SSL_AIDX_RSA] = NULL;
        }
        if (sc->pPublicCert[SSL_AIDX_DSA] != NULL) {
            X509_free(sc->pPublicCert[SSL_AIDX_DSA]);
            sc->pPublicCert[SSL_AIDX_DSA] = NULL;
        }
        if (sc->pPrivateKey[SSL_AIDX_RSA] != NULL) {
            EVP_PKEY_free(sc->pPrivateKey[SSL_AIDX_RSA]);
            sc->pPrivateKey[SSL_AIDX_RSA] = NULL;
        }
        if (sc->pPrivateKey[SSL_AIDX_DSA] != NULL) {
            EVP_PKEY_free(sc->pPrivateKey[SSL_AIDX_DSA]);
            sc->pPrivateKey[SSL_AIDX_DSA] = NULL;
        }
        if (sc->pSSLCtx != NULL) {
            SSL_CTX_free(sc->pSSLCtx);
            sc->pSSLCtx = NULL;
        }
    }

    /*
     * Try to kill the internals of the SSL library.
     */
#ifdef SHARED_MODULE
    ERR_free_strings();
    ERR_remove_state(0);
    EVP_cleanup();
#endif

    ssl_util_thread_cleanup();

    return;
@


1.1.1.2
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@a797 6
        if (!RSA_blinding_on(sc->pPrivateKey[SSL_AIDX_RSA]->pkey.rsa, NULL)) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: (%s) Unable to enable RSA blinding (probably PRNG failure)",
                    cpVHostID);
            ssl_die();
        }
@


1.1.1.3
log
@import Apache 1.3.29 and mod_ssl 2.8.16
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2003 Ralf S. Engelschall. All rights reserved.
@


