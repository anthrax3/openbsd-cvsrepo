head	1.15;
access;
symbols
	OPENBSD_5_5:1.14.0.24
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.20
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.18
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.16
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.14
	OPENBSD_5_0:1.14.0.12
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.10
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.16
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.14
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.12
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.10
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.8
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.6
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.2
	OPENBSD_3_4:1.10.0.4
	OPENBSD_3_4_BASE:1.10
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.1
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.1
	apache_1_3_27:1.1.1.1
	apache:1.1.1
	OPENBSD_3_2:1.9.0.8
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.6
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.14;

1.14
date	2008.09.06.12.22.53;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.17.12.18.13;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.17.18.57.06;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.14.09.28.52;	author ho;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.29.10.21.47;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.21.01.20.30;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.30.05.35.11;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.25.18.29.56;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	99.12.08.02.45.49;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.12.08.00.05.18;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.10.01.23.50.44;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.06.29.47;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.03.01.04.28.59;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.07.19.48.14;	author henning;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.11.17.17.03.24;	author henning;	state Exp;
branches;
next	;


desc
@@


1.15
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*                      _             _
**  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
** | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
** | | | | | | (_) | (_| |   \__ \__ \ |  www.modssl.org
** |_| |_| |_|\___/ \__,_|___|___/___/_|  ftp.modssl.org
**                      |_____|
**  ssl_engine_pphrase.c
**  Pass Phrase Dialog
*/

/* ====================================================================
 * Copyright (c) 1998-2003 Ralf S. Engelschall. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials
 *    provided with the distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by
 *     Ralf S. Engelschall <rse@@engelschall.com> for use in the
 *     mod_ssl project (http://www.modssl.org/)."
 *
 * 4. The names "mod_ssl" must not be used to endorse or promote
 *    products derived from this software without prior written
 *    permission. For written permission, please contact
 *    rse@@engelschall.com.
 *
 * 5. Products derived from this software may not be called "mod_ssl"
 *    nor may "mod_ssl" appear in their names without prior
 *    written permission of Ralf S. Engelschall.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by
 *     Ralf S. Engelschall <rse@@engelschall.com> for use in the
 *     mod_ssl project (http://www.modssl.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY RALF S. ENGELSCHALL ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL RALF S. ENGELSCHALL OR
 * HIS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 */
                             /* ``Treat your password like your
                                  toothbrush. Don't let anybody
                                  else use it, and get a new one
                                  every six months.''
                                           -- Clifford Stoll     */
#include "mod_ssl.h"


/*  _________________________________________________________________
**
**  Pass Phrase and Private Key Handling
**  _________________________________________________________________
*/

#define STDERR_FILENO_STORE 50
#define BUILTIN_DIALOG_BACKOFF 2
#define BUILTIN_DIALOG_RETRIES 5

void ssl_pphrase_Handle(server_rec *s, pool *p)
{
    SSLModConfigRec *mc = myModConfig();
    SSLSrvConfigRec *sc;
    server_rec *pServ;
    char *cpVHostID;
    char szPath[MAX_STRING_LEN];
    EVP_PKEY *pPrivateKey;
    ssl_asn1_t *asn1;
    unsigned char *ucp;
    X509 *pX509Cert;
    FILE *fp;
    BOOL bReadable;
    ssl_ds_array *aPassPhrase;
    int nPassPhrase;
    int nPassPhraseCur;
    char *cpPassPhraseCur;
    int nPassPhraseRetry;
    int nPassPhraseDialog;
    int nPassPhraseDialogCur;
    BOOL bPassPhraseDialogOnce;
    char **cpp;
    int i, j;
    ssl_algo_t algoCert, algoKey, at;
    char *an;
    char *cp;

    /*
     * Start with a fresh pass phrase array
     */
    aPassPhrase       = ssl_ds_array_make(p, sizeof(char *));
    nPassPhrase       = 0;
    nPassPhraseDialog = 0;

    /*
     * Walk through all configured servers
     */
    for (pServ = s; pServ != NULL; pServ = pServ->next) {
        sc = mySrvConfig(pServ);

        if (!sc->bEnabled)
            continue;

        cpVHostID = ssl_util_vhostid(p, pServ);
        ssl_log(pServ, SSL_LOG_INFO,
                "Init: Loading certificate & private key of SSL-aware server %s",
                cpVHostID);

        /*
         * Read in server certificate(s): This is the easy part
         * because this file isn't encrypted in any way.
         */
        if (sc->szPublicCertFile[0] == NULL) {
            ssl_log(pServ, SSL_LOG_ERROR,
                    "Init: Server %s should be SSL-aware but has no certificate configured "
                    "[Hint: SSLCertificateFile]", cpVHostID);
            ssl_die();
        }
        algoCert = SSL_ALGO_UNKNOWN;
        algoKey  = SSL_ALGO_UNKNOWN;
        for (i = 0, j = 0; i < SSL_AIDX_MAX && sc->szPublicCertFile[i] != NULL; i++) {

            ap_cpystrn(szPath, sc->szPublicCertFile[i], sizeof(szPath));
            if ((fp = ap_pfopen(p, szPath, "r")) == NULL) {
                ssl_log(s, SSL_LOG_ERROR|SSL_ADD_ERRNO,
                        "Init: Can't open server certificate file %s", szPath);
                ssl_die();
            }
            if ((pX509Cert = SSL_read_X509(fp, NULL, NULL)) == NULL) {
                ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                        "Init: Unable to read server certificate from file %s", szPath);
                ssl_die();
            }
            ap_pfclose(p, fp);

            /*
             * check algorithm type of certificate and make
             * sure only one certificate per type is used.
             */
            at = ssl_util_algotypeof(pX509Cert, NULL);
            an = ssl_util_algotypestr(at);
            if (algoCert & at) {
                ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                        "Init: Multiple %s server certificates not allowed", an);
                ssl_die();
            }
            algoCert |= at;

            /*
             * Insert the certificate into global module configuration to let it
             * survive the processing between the 1st Apache API init round (where
             * we operate here) and the 2nd Apache init round (where the
             * certificate is actually used to configure mod_ssl's per-server
             * configuration structures).
             */
            cp = ap_psprintf(mc->pPool, "%s:%s", cpVHostID, an);
            asn1 = (ssl_asn1_t *)ssl_ds_table_push(mc->tPublicCert, cp);
            asn1->nData  = i2d_X509(pX509Cert, NULL);
            asn1->cpData = ap_palloc(mc->pPool, asn1->nData);
            ucp = asn1->cpData; i2d_X509(pX509Cert, &ucp); /* 2nd arg increments */

            /*
             * Free the X509 structure
             */
            X509_free(pX509Cert);

            /*
             * Read in the private key: This is the non-trivial part, because the
             * key is typically encrypted, so a pass phrase dialog has to be used
             * to request it from the user (or it has to be alternatively gathered
             * from a dialog program). The important point here is that ISPs
             * usually have hundrets of virtual servers configured and a lot of
             * them use SSL, so really we have to minimize the pass phrase
             * dialogs.
             *
             * The idea is this: When N virtual hosts are configured and all of
             * them use encrypted private keys with different pass phrases, we
             * have no chance and have to pop up N pass phrase dialogs. But
             * usually the admin is clever enough and uses the same pass phrase
             * for more private key files (typically he even uses one single pass
             * phrase for all). When this is the case we can minimize the dialogs
             * by trying to re-use already known/entered pass phrases.
             */
            if (sc->szPrivateKeyFile[j] != NULL)
                ap_cpystrn(szPath, sc->szPrivateKeyFile[j++], sizeof(szPath));

            /*
             * Try to read the private key file with the help of
             * the callback function which serves the pass
             * phrases to OpenSSL
             */
            myCtxVarSet(mc,  1, pServ);
            myCtxVarSet(mc,  2, p);
            myCtxVarSet(mc,  3, aPassPhrase);
            myCtxVarSet(mc,  4, &nPassPhraseCur);
            myCtxVarSet(mc,  5, &cpPassPhraseCur);
            myCtxVarSet(mc,  6, cpVHostID);
            myCtxVarSet(mc,  7, an);
            myCtxVarSet(mc,  8, &nPassPhraseDialog);
            myCtxVarSet(mc,  9, &nPassPhraseDialogCur);
            myCtxVarSet(mc, 10, &bPassPhraseDialogOnce);

            nPassPhraseCur        = 0;
            nPassPhraseRetry      = 0;
            nPassPhraseDialogCur  = 0;
            bPassPhraseDialogOnce = TRUE;

			pPrivateKey = NULL;

            for (;;) {
                /*
                 * Try to read the private key file with the help of
                 * the callback function which serves the pass
                 * phrases to OpenSSL
                 */
                if ((fp = ap_pfopen(p, szPath, "r")) == NULL) {
                    ssl_log(s, SSL_LOG_ERROR|SSL_ADD_ERRNO,
                            "Init: Can't open server private key file %s", szPath);
                    ssl_die();
                }
                cpPassPhraseCur = NULL;
                /* Ensure that the error stack is empty; otherwise the
                   OpenSSL UI code may dump it to stderr. */
                ERR_clear_error();
                bReadable = ((pPrivateKey = SSL_read_PrivateKey(fp, NULL,
                             ssl_pphrase_Handle_CB)) != NULL ? TRUE : FALSE);
                ap_pfclose(p, fp);

                /*
                 * when the private key file now was readable,
                 * it's fine and we go out of the loop
                 */
                if (bReadable)
                   break;

                /*
                 * when we have more remembered pass phrases
                 * try to reuse these first.
                 */
                if (nPassPhraseCur < nPassPhrase) {
                    nPassPhraseCur++;
                    continue;
                }

                /*
                 * else it's not readable and we have no more
                 * remembered pass phrases. Then this has to mean
                 * that the callback function popped up the dialog
                 * but a wrong pass phrase was entered.  We give the
                 * user (but not the dialog program) a few more
                 * chances...
                 */
                if (   sc->nPassPhraseDialogType == SSL_PPTYPE_BUILTIN
                    && cpPassPhraseCur != NULL
                    && nPassPhraseRetry < BUILTIN_DIALOG_RETRIES ) {
                    fprintf(stdout, "Apache:mod_ssl:Error: Pass phrase incorrect "
                            "(%d more retr%s permitted).\n",
                            (BUILTIN_DIALOG_RETRIES-nPassPhraseRetry),
                            (BUILTIN_DIALOG_RETRIES-nPassPhraseRetry) == 1 ? "y" : "ies");
                    nPassPhraseRetry++;
                    if (nPassPhraseRetry > BUILTIN_DIALOG_BACKOFF)
                        sleep((nPassPhraseRetry-BUILTIN_DIALOG_BACKOFF)*5);
                    continue;
                }

                /*
                 * Ok, anything else now means a fatal error.
                 */
                if (cpPassPhraseCur == NULL) {
                    ssl_log(pServ, SSL_LOG_ERROR|SSL_ADD_SSLERR, "Init: Private key not found");
                    if (sc->nPassPhraseDialogType == SSL_PPTYPE_BUILTIN) {
                        fprintf(stdout, "Apache:mod_ssl:Error: Private key not found.\n");
                        fprintf(stdout, "**Stopped\n");
                    }
                } else {
                    ssl_log(pServ, SSL_LOG_ERROR|SSL_ADD_SSLERR, "Init: Pass phrase incorrect");
                    if (sc->nPassPhraseDialogType == SSL_PPTYPE_BUILTIN) {
                        fprintf(stdout, "Apache:mod_ssl:Error: Pass phrase incorrect.\n");
                        fprintf(stdout, "**Stopped\n");
                    }
                }
                ssl_die();
            }

            if (pPrivateKey == NULL) {
                ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                        "Init: Unable to read server private key from file %s", szPath);
                ssl_die();
            }

            /*
             * check algorithm type of private key and make
             * sure only one private key per type is used.
             */
            at = ssl_util_algotypeof(NULL, pPrivateKey);
            an = ssl_util_algotypestr(at);
            if (algoKey & at) {
                ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                        "Init: Multiple %s server private keys not allowed", an);
                ssl_die();
            }
            algoKey |= at;

            /*
             * Log the type of reading
             */
            if (nPassPhraseDialogCur == 0)
                ssl_log(pServ, SSL_LOG_TRACE, 
                        "Init: (%s) unencrypted %s private key - pass phrase not required", 
                        cpVHostID, an);
            else {
                if (cpPassPhraseCur != NULL)
                    ssl_log(pServ, SSL_LOG_TRACE, 
                            "Init: (%s) encrypted %s private key - pass phrase requested", 
                            cpVHostID, an);
                else
                    ssl_log(pServ, SSL_LOG_TRACE, 
                            "Init: (%s) encrypted %s private key - pass phrase reused", 
                            cpVHostID, an);
            }

            /*
             * Ok, when we have one more pass phrase store it
             */
            if (cpPassPhraseCur != NULL) {
                cpp = (char **)ssl_ds_array_push(aPassPhrase);
                *cpp = cpPassPhraseCur;
                nPassPhrase++;
            }

	    /*
	     * For RSA keys, add blinding.
	     */
	    if (at == SSL_ALGO_RSA)
		    if (RSA_blinding_on (pPrivateKey->pkey.rsa, NULL) != 1) {
			    ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
				    "Init: RSA blinding failed for private key");
			    ssl_die();
		    }		
    
            /*
             * Insert private key into the global module configuration
             * (we convert it to a stand-alone DER byte sequence
             * because the SSL library uses static variables inside a
             * RSA structure which do not survive DSO reloads!)
             */
            cp = ap_psprintf(mc->pPool, "%s:%s", cpVHostID, an);
            asn1 = (ssl_asn1_t *)ssl_ds_table_push(mc->tPrivateKey, cp);
            asn1->nData  = i2d_PrivateKey(pPrivateKey, NULL);
            asn1->cpData = ap_palloc(mc->pPool, asn1->nData);
            ucp = asn1->cpData; i2d_PrivateKey(pPrivateKey, &ucp); /* 2nd arg increments */

            /*
             * Free the private key structure
             */
            EVP_PKEY_free(pPrivateKey);
        }
    }

    /*
     * Let the user know when we're successful.
     */
    if (nPassPhraseDialog > 0) {
        sc = mySrvConfig(s);
        if (sc->nPassPhraseDialogType == SSL_PPTYPE_BUILTIN) {
            fprintf(stdout, "\n");
            fprintf(stdout, "Ok: Pass Phrase Dialog successful.\n");
        }
    }

    /*
     * Wipe out the used memory from the
     * pass phrase array and then deallocate it
     */
    if (!ssl_ds_array_isempty(aPassPhrase)) {
        ssl_ds_array_wipeout(aPassPhrase);
        ssl_ds_array_kill(aPassPhrase);
        ssl_log(s, SSL_LOG_INFO, "Init: Wiped out the queried pass phrases from memory");
    }

    return;
}

int ssl_pphrase_Handle_CB(char *buf, int bufsize, int verify)
{
    SSLModConfigRec *mc = myModConfig();
    server_rec *s;
    pool *p;
    ssl_ds_array *aPassPhrase;
    SSLSrvConfigRec *sc;
    int *pnPassPhraseCur;
    char **cppPassPhraseCur;
    char *cpVHostID;
    char *cpAlgoType;
    int *pnPassPhraseDialog;
    int *pnPassPhraseDialogCur;
    BOOL *pbPassPhraseDialogOnce;
    int stderr_store;
    char **cpp;
    int len = -1;

    /*
     * Reconnect to the context of ssl_phrase_Handle()
     */
    s                      = myCtxVarGet(mc,  1, server_rec *);
    p                      = myCtxVarGet(mc,  2, pool *);
    aPassPhrase            = myCtxVarGet(mc,  3, ssl_ds_array *);
    pnPassPhraseCur        = myCtxVarGet(mc,  4, int *);
    cppPassPhraseCur       = myCtxVarGet(mc,  5, char **);
    cpVHostID              = myCtxVarGet(mc,  6, char *);
    cpAlgoType             = myCtxVarGet(mc,  7, char *);
    pnPassPhraseDialog     = myCtxVarGet(mc,  8, int *);
    pnPassPhraseDialogCur  = myCtxVarGet(mc,  9, int *);
    pbPassPhraseDialogOnce = myCtxVarGet(mc, 10, BOOL *);
    sc                     = mySrvConfig(s);

    (*pnPassPhraseDialog)++;
    (*pnPassPhraseDialogCur)++;

    /*
     * When remembered pass phrases are available use them...
     */
    if ((cpp = (char **)ssl_ds_array_get(aPassPhrase, *pnPassPhraseCur)) != NULL) {
        ap_cpystrn(buf, *cpp, bufsize);
        len = strlen(buf);
        return len;
    }

    /*
     * Builtin dialog
     */
    if (sc->nPassPhraseDialogType == SSL_PPTYPE_BUILTIN) {
        char *prompt;
        int i;

        ssl_log(s, SSL_LOG_INFO,
                "Init: Requesting pass phrase via builtin terminal dialog");

        /*
         * Reconnect STDERR to terminal (here STDOUT) because
         * at our init stage Apache already connected STDERR
         * to the general error logfile.
         */
        if ((stderr_store = open("/dev/null", O_WRONLY)) == -1)
            stderr_store = STDERR_FILENO_STORE;
        dup2(STDERR_FILENO, stderr_store);
        dup2(STDOUT_FILENO, STDERR_FILENO);

        /*
         * The first time display a header to inform the user about what
         * program he actually speaks to, which module is responsible for
         * this terminal dialog and why to the hell he has to enter
         * something...
         */
        if (*pnPassPhraseDialog == 1) {
            fprintf(stderr, "%s mod_ssl/%s (Pass Phrase Dialog)\n",
                    SERVER_BASEVERSION, MOD_SSL_VERSION);
            fprintf(stderr, "Some of your private key files are encrypted for security reasons.\n");
            fprintf(stderr, "In order to read them you have to provide us with the pass phrases.\n");
        }
        if (*pbPassPhraseDialogOnce) {
            *pbPassPhraseDialogOnce = FALSE;
            fprintf(stderr, "\n");
            fprintf(stderr, "Server %s (%s)\n", cpVHostID, cpAlgoType);
        }

        /*
         * Emulate the OpenSSL internal pass phrase dialog
         * (see crypto/pem/pem_lib.c:def_callback() for details)
         */
        prompt = "Enter pass phrase:";
        for (;;) {
            if ((i = EVP_read_pw_string(buf, bufsize, prompt, FALSE)) != 0) {
                PEMerr(PEM_F_PEM_DEF_CALLBACK,PEM_R_PROBLEMS_GETTING_PASSWORD);
                memset(buf, 0, (unsigned int)bufsize);
                return (-1);
            }
            len = strlen(buf);
            if (len < 1)
                fprintf(stderr, "Apache:mod_ssl:Error: Pass phrase empty (needs to be at least 1 character).\n");
            else
                break;
        }

        /*
         * Restore STDERR to Apache error logfile
         */
        dup2(stderr_store, STDERR_FILENO);
        close(stderr_store);
    }

    /*
     * Filter program
     */
    else if (sc->nPassPhraseDialogType == SSL_PPTYPE_FILTER) {
        char *cmd;
        char *result;

        ssl_log(s, SSL_LOG_INFO,
                "Init: Requesting pass phrase from dialog filter program (%s)",
                sc->szPassPhraseDialogPath);

        if (strchr(sc->szPassPhraseDialogPath, ' ') != NULL)
            cmd = ap_psprintf(p, "\"%s\" %s %s", sc->szPassPhraseDialogPath, cpVHostID, cpAlgoType);
        else
            cmd = ap_psprintf(p, "%s %s %s", sc->szPassPhraseDialogPath, cpVHostID, cpAlgoType);
        result = ssl_util_readfilter(s, p, cmd);
        ap_cpystrn(buf, result, bufsize);
        len = strlen(buf);
    }

    /*
     * Ok, we now have the pass phrase, so give it back
     */
    *cppPassPhraseCur = ap_pstrdup(p, buf);

    /*
     * And return it's length to OpenSSL...
     */
    return (len);
}

@


1.14
log
@adapt to API changes in OpenSSL 0.9.8h
@
text
@@


1.13
log
@Fix scoping error in fatal error check during passphrase/privkey handling.
henning@@, otto@@, robert@@ ok
@
text
@d492 1
a492 1
                PEMerr(PEM_F_DEF_CALLBACK,PEM_R_PROBLEMS_GETTING_PASSWORD);
@


1.12
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@d287 1
a287 1
                if (cpPassPhraseCur == NULL)
d293 1
a293 1
                else {
@


1.11
log
@merge apache 1.3.29 and mod_ssl 2.8.16
ok brad@@
@
text
@a452 3
#ifdef WIN32
        FILE *con;
#endif
a461 3
#ifdef WIN32
        stderr_store = STDERR_FILENO_STORE;
#else
a463 1
#endif
a464 6
#ifdef WIN32
        if ((con = fopen("con", "w")) != NULL)
            dup2(fileno(con), STDERR_FILENO);
        else
            dup2(STDOUT_FILENO, STDERR_FILENO);
#else
a465 1
#endif
a507 4
#ifdef WIN32
        if (con != NULL)
            fclose(con);
#endif
@


1.10
log
@RSA blinding for private keys here too.
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2001 Ralf S. Engelschall. All rights reserved.
d240 3
@


1.9
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d346 10
@


1.8
log
@Mod_SSL 2.6.5 - from brad@@, thanks.
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2000 Ralf S. Engelschall. All rights reserved.
@


1.7
log
@mod_ssl 2.6.4 merge
From brad@@
@
text
@d526 4
a529 1
        cmd = ap_psprintf(p, "%s %s %s", sc->szPassPhraseDialogPath, cpVHostID, cpAlgoType);
@


1.6
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d134 1
a134 1
                    "[Hint: SSLCertifcateFile]", cpVHostID);
d389 1
a389 1
int ssl_pphrase_Handle_CB(char *buf, int bufsize, int ask_twice)
d492 1
a492 1
            if ((i = EVP_read_pw_string(buf, bufsize, prompt, ask_twice)) != 0) {
@


1.5
log
@mod_ssl 2.4.9 merge
@
text
@d12 1
a12 1
 * Copyright (c) 1998-1999 Ralf S. Engelschall. All rights reserved.
@


1.4
log
@ Mod_SSL 2.4.8 merge
@
text
@d75 1
a75 1
#define STDERR_FILENO_STORE 10
d403 1
d452 7
a458 1
        dup2(STDERR_FILENO, STDERR_FILENO_STORE);
d507 2
a508 1
        dup2(STDERR_FILENO_STORE, STDERR_FILENO);
d510 2
a511 1
        fclose(con);
@


1.3
log
@Sync with mod_ssl v2.4.5. ok beck@@.
@
text
@d285 1
a285 1
                    ssl_log(pServ, SSL_LOG_ERROR|SSL_ADD_SSLERR, "Init: Private key not found.");
d291 1
a291 1
                    ssl_log(pServ, SSL_LOG_ERROR|SSL_ADD_SSLERR, "Init: Pass phrase incorrect.");
d439 3
d452 6
d459 1
d463 1
a463 1
         * program he actually speaks to, which modules is responsible for
d501 3
@


1.2
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d210 10
a219 9
            myCtxVarSet(mc, 1, pServ);
            myCtxVarSet(mc, 2, p);
            myCtxVarSet(mc, 3, aPassPhrase);
            myCtxVarSet(mc, 4, &nPassPhraseCur);
            myCtxVarSet(mc, 5, &cpPassPhraseCur);
            myCtxVarSet(mc, 6, cpVHostID);
            myCtxVarSet(mc, 7, &nPassPhraseDialog);
            myCtxVarSet(mc, 8, &nPassPhraseDialogCur);
            myCtxVarSet(mc, 9, &bPassPhraseDialogOnce);
d399 1
d409 10
a418 9
    s                      = myCtxVarGet(mc, 1, server_rec *);
    p                      = myCtxVarGet(mc, 2, pool *);
    aPassPhrase            = myCtxVarGet(mc, 3, ssl_ds_array *);
    pnPassPhraseCur        = myCtxVarGet(mc, 4, int *);
    cppPassPhraseCur       = myCtxVarGet(mc, 5, char **);
    cpVHostID              = myCtxVarGet(mc, 6, char *);
    pnPassPhraseDialog     = myCtxVarGet(mc, 7, int *);
    pnPassPhraseDialogCur  = myCtxVarGet(mc, 8, int *);
    pbPassPhraseDialogOnce = myCtxVarGet(mc, 9, BOOL *);
d466 1
a466 1
            fprintf(stderr, "Server %s\n", cpVHostID);
d504 1
a504 1
        cmd = ap_psprintf(p, "%s %s", sc->szPassPhraseDialogPath, cpVHostID);
@


1.1
log
@mod_ssl-2.2.3-1.3.4 (will require libssl-1.1 for https to work, but
mostly harmless otherwise).
@
text
@d2 4
a5 4
**  _ __ ___   ___   __| |    ___ ___| |
** | '_ ` _ \ / _ \ / _` |   / __/ __| |
** | | | | | | (_) | (_| |   \__ \__ \ | mod_ssl - Apache Interface to SSLeay
** |_| |_| |_|\___/ \__,_|___|___/___/_| http://www.engelschall.com/sw/mod_ssl/
d30 1
a30 1
 *     mod_ssl project (http://www.engelschall.com/sw/mod_ssl/)."
d45 1
a45 1
 *     mod_ssl project (http://www.engelschall.com/sw/mod_ssl/)."
d86 1
a88 1
    RSA *pRSAKey;
d101 4
d123 2
a124 2
        ssl_log(pServ, SSL_LOG_INFO, 
                "Init: Loading certificate & private key of SSL-aware server %s", 
d128 1
a128 1
         * Read in server certificate: This is the easy part
d131 1
a131 1
        if (sc->szCertificateFile == NULL) {
d137 16
a152 13
        ap_cpystrn(szPath, sc->szCertificateFile, sizeof(szPath));
        if ((fp = ap_pfopen(p, szPath, "r")) == NULL) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_ERRNO,
                    "Init: Can't open server certificate file %s", szPath);
            ssl_die();
        }
        pX509Cert = X509_new();
        if (!PEM_read_X509(fp, &pX509Cert, NULL)) {
            ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                    "Init: Unable to read server certificate from file %s", szPath);
            ssl_die();
        }
        ap_pfclose(p, fp);
d154 12
a165 11
        /*
         * Insert the certificate into global module configuration to let it
         * survive the processing between the 1st Apache API init round (where
         * we operate here) and the 2nd Apache init round (where the
         * certificate is actually used to configure mod_ssl's per-server
         * configuration structures).
         */
        asn1 = (ssl_asn1_t *)ssl_ds_table_push(mc->tPublicCert, cpVHostID);
        asn1->nData  = i2d_X509(pX509Cert, NULL);
        asn1->cpData = ap_palloc(mc->pPool, asn1->nData);
        ucp = asn1->cpData; i2d_X509(pX509Cert, &ucp); /* 2nd arg increments */
d167 12
a178 4
        /*
         * Free the X509 structure
         */
        X509_free(pX509Cert);
d180 4
a183 19
        /*
         * Read in the private key: This is the non-trivial part, because the
         * key is typically encrypted, so a pass phrase dialog has to be used
         * to request it from the user (or it has to be alternatively gathered
         * from a dialog program). The important point here is that ISPs
         * usually have hundrets of virtual servers configured and a lot of
         * them use SSL, so really we have to minimize the pass phrase
         * dialogs.
         *
         * The idea is this: When N virtual hosts are configured and all of
         * them use encrypted private keys with different pass phrases, we
         * have no chance and have to pop up N pass phrase dialogs. But
         * usually the admin is clever enough and uses the same pass phrase
         * for more private key files (typically he even uses one single pass
         * phrase for all). When this is the case we can minimize the dialogs
         * by trying to re-use already known/entered pass phrases.
         */
        if (sc->szKeyFile)
            ap_cpystrn(szPath, sc->szKeyFile, sizeof(szPath));
d185 19
a203 18
        /*
         * Spread context variables for callback function
         */
        myCtxVarSet(mc, 1, pServ);
        myCtxVarSet(mc, 2, p);
        myCtxVarSet(mc, 3, aPassPhrase);
        myCtxVarSet(mc, 4, &nPassPhraseCur);
        myCtxVarSet(mc, 5, &cpPassPhraseCur);
        myCtxVarSet(mc, 6, cpVHostID);
        myCtxVarSet(mc, 7, &nPassPhraseDialog);
        myCtxVarSet(mc, 8, &nPassPhraseDialogCur);
        myCtxVarSet(mc, 9, &bPassPhraseDialogOnce);

        pRSAKey = RSA_new();
        nPassPhraseCur        = 0;
        nPassPhraseRetry      = 0;
        nPassPhraseDialogCur  = 0;
        bPassPhraseDialogOnce = TRUE;
a204 1
        for (;;) {
d208 1
a208 1
             * phrases to SSLeay
d210 92
a301 3
            if ((fp = ap_pfopen(p, szPath, "r")) == NULL) {
                ssl_log(s, SSL_LOG_ERROR|SSL_ADD_ERRNO,
                        "Init: Can't open server private key file %s", szPath);
a303 4
            cpPassPhraseCur = NULL;
            bReadable = (PEM_read_RSAPrivateKey(fp, &pRSAKey,
                         ssl_pphrase_Handle_CB) ? TRUE : FALSE);
            ap_pfclose(p, fp);
d306 2
a307 2
             * when the private key file now was readable,
             * it's fine and we go out of the loop
d309 8
a316 2
            if (bReadable)
               break;
d319 1
a319 2
             * when we have more remembered pass phrases
             * try to reuse these first.
d321 13
a333 3
            if (nPassPhraseCur < nPassPhrase) {
                nPassPhraseCur++;
                continue;
d337 1
a337 6
             * else it's not readable and we have no more
             * remembered pass phrases. Then this has to mean
             * that the callback function popped up the dialog
             * but a wrong pass phrase was entered.  We give the
             * user (but not the dialog program) a few more
             * chances...
d339 4
a342 11
            if (   sc->nPassPhraseDialogType == SSL_PPTYPE_BUILTIN
                && cpPassPhraseCur != NULL
                && nPassPhraseRetry < BUILTIN_DIALOG_RETRIES ) {
                fprintf(stdout, "Apache:mod_ssl:Error: Pass phrase incorrect "
                        "(%d more retr%s permitted).\n",
                        (BUILTIN_DIALOG_RETRIES-nPassPhraseRetry),
                        (BUILTIN_DIALOG_RETRIES-nPassPhraseRetry) == 1 ? "y" : "ies");
                nPassPhraseRetry++;
                if (nPassPhraseRetry > BUILTIN_DIALOG_BACKOFF)
                    sleep((nPassPhraseRetry-BUILTIN_DIALOG_BACKOFF)*5);
                continue;
d346 4
a349 1
             * Ok, anything else now means a fatal error.
d351 5
a355 7
            if (sc->nPassPhraseDialogType == SSL_PPTYPE_BUILTIN) {
                fprintf(stdout, "Apache:mod_ssl:Error: Pass phrase incorrect.\n");
                fprintf(stdout, "**Stopped\n");
            }
            ssl_log(pServ, SSL_LOG_ERROR, "Init: Pass phrase incorrect.");
            ssl_die();
        }
d357 4
a360 25
        /*
         * Log the type of reading
         */
        if (nPassPhraseDialogCur == 0)
            ssl_log(pServ, SSL_LOG_TRACE,
                    "Init: (%s) unencrypted private key - pass phrase not required",
                    cpVHostID);
        else {
            if (cpPassPhraseCur != NULL)
                ssl_log(pServ, SSL_LOG_TRACE,
                        "Init: (%s) encrypted private key - pass phrase requested",
                        cpVHostID);
            else
                ssl_log(pServ, SSL_LOG_TRACE,
                        "Init: (%s) encrypted private key - pass phrase reused",
                        cpVHostID);
        }

        /*
         * Ok, when have one more pass phrase store it
         */
        if (cpPassPhraseCur != NULL) {
            cpp = (char **)ssl_ds_array_push(aPassPhrase);
            *cpp = cpPassPhraseCur;
            nPassPhrase++;
a361 16

        /*
         * Insert private key into the global module configuration
         * (we convert it to a stand-alone DER byte sequence
         * because the SSL library uses static variables inside a
         * RSA structure which do not survive DSO reloads!)
         */
        asn1 = (ssl_asn1_t *)ssl_ds_table_push(mc->tPrivateKey, cpVHostID);
        asn1->nData  = i2d_RSAPrivateKey(pRSAKey, NULL);
        asn1->cpData = ap_palloc(mc->pPool, asn1->nData);
        ucp = asn1->cpData; i2d_RSAPrivateKey(pRSAKey, &ucp); /* 2nd arg increments */

        /*
         * Free the RSA structure
         */
        RSA_free(pRSAKey);
d388 1
a388 1
int ssl_pphrase_Handle_CB(char *buf, int bufsize, int w)
d467 1
a467 1
         * Emulate the SSLeay internal pass phrase dialog
d472 1
a472 1
            if ((i = EVP_read_pw_string(buf, bufsize, prompt, w)) != 0) {
d478 2
a479 2
            if (len < 4)
                fprintf(stderr, "Apache:mod_ssl:Error: Pass phrase too short (needs to be at least 4 chars).\n");
d513 1
a513 1
     * And return it's length to SSLeay...
@


1.1.1.1
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@d2 4
a5 4
**  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
** | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
** | | | | | | (_) | (_| |   \__ \__ \ |  www.modssl.org
** |_| |_| |_|\___/ \__,_|___|___/___/_|  ftp.modssl.org
d12 1
a12 1
 * Copyright (c) 1998-2001 Ralf S. Engelschall. All rights reserved.
d30 1
a30 1
 *     mod_ssl project (http://www.modssl.org/)."
d45 1
a45 1
 *     mod_ssl project (http://www.modssl.org/)."
d75 1
a75 1
#define STDERR_FILENO_STORE 50
a85 1
    EVP_PKEY *pPrivateKey;
d88 1
a100 4
    int i, j;
    ssl_algo_t algoCert, algoKey, at;
    char *an;
    char *cp;
d119 2
a120 2
        ssl_log(pServ, SSL_LOG_INFO,
                "Init: Loading certificate & private key of SSL-aware server %s",
d124 1
a124 1
         * Read in server certificate(s): This is the easy part
d127 1
a127 1
        if (sc->szPublicCertFile[0] == NULL) {
d130 1
a130 1
                    "[Hint: SSLCertificateFile]", cpVHostID);
d133 13
a145 3
        algoCert = SSL_ALGO_UNKNOWN;
        algoKey  = SSL_ALGO_UNKNOWN;
        for (i = 0, j = 0; i < SSL_AIDX_MAX && sc->szPublicCertFile[i] != NULL; i++) {
d147 11
a157 12
            ap_cpystrn(szPath, sc->szPublicCertFile[i], sizeof(szPath));
            if ((fp = ap_pfopen(p, szPath, "r")) == NULL) {
                ssl_log(s, SSL_LOG_ERROR|SSL_ADD_ERRNO,
                        "Init: Can't open server certificate file %s", szPath);
                ssl_die();
            }
            if ((pX509Cert = SSL_read_X509(fp, NULL, NULL)) == NULL) {
                ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                        "Init: Unable to read server certificate from file %s", szPath);
                ssl_die();
            }
            ap_pfclose(p, fp);
d159 4
a162 12
            /*
             * check algorithm type of certificate and make
             * sure only one certificate per type is used.
             */
            at = ssl_util_algotypeof(pX509Cert, NULL);
            an = ssl_util_algotypestr(at);
            if (algoCert & at) {
                ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                        "Init: Multiple %s server certificates not allowed", an);
                ssl_die();
            }
            algoCert |= at;
d164 19
a182 12
            /*
             * Insert the certificate into global module configuration to let it
             * survive the processing between the 1st Apache API init round (where
             * we operate here) and the 2nd Apache init round (where the
             * certificate is actually used to configure mod_ssl's per-server
             * configuration structures).
             */
            cp = ap_psprintf(mc->pPool, "%s:%s", cpVHostID, an);
            asn1 = (ssl_asn1_t *)ssl_ds_table_push(mc->tPublicCert, cp);
            asn1->nData  = i2d_X509(pX509Cert, NULL);
            asn1->cpData = ap_palloc(mc->pPool, asn1->nData);
            ucp = asn1->cpData; i2d_X509(pX509Cert, &ucp); /* 2nd arg increments */
d184 18
a201 24
            /*
             * Free the X509 structure
             */
            X509_free(pX509Cert);

            /*
             * Read in the private key: This is the non-trivial part, because the
             * key is typically encrypted, so a pass phrase dialog has to be used
             * to request it from the user (or it has to be alternatively gathered
             * from a dialog program). The important point here is that ISPs
             * usually have hundrets of virtual servers configured and a lot of
             * them use SSL, so really we have to minimize the pass phrase
             * dialogs.
             *
             * The idea is this: When N virtual hosts are configured and all of
             * them use encrypted private keys with different pass phrases, we
             * have no chance and have to pop up N pass phrase dialogs. But
             * usually the admin is clever enough and uses the same pass phrase
             * for more private key files (typically he even uses one single pass
             * phrase for all). When this is the case we can minimize the dialogs
             * by trying to re-use already known/entered pass phrases.
             */
            if (sc->szPrivateKeyFile[j] != NULL)
                ap_cpystrn(szPath, sc->szPrivateKeyFile[j++], sizeof(szPath));
d203 1
d207 1
a207 1
             * phrases to OpenSSL
d209 3
a211 87
            myCtxVarSet(mc,  1, pServ);
            myCtxVarSet(mc,  2, p);
            myCtxVarSet(mc,  3, aPassPhrase);
            myCtxVarSet(mc,  4, &nPassPhraseCur);
            myCtxVarSet(mc,  5, &cpPassPhraseCur);
            myCtxVarSet(mc,  6, cpVHostID);
            myCtxVarSet(mc,  7, an);
            myCtxVarSet(mc,  8, &nPassPhraseDialog);
            myCtxVarSet(mc,  9, &nPassPhraseDialogCur);
            myCtxVarSet(mc, 10, &bPassPhraseDialogOnce);

            nPassPhraseCur        = 0;
            nPassPhraseRetry      = 0;
            nPassPhraseDialogCur  = 0;
            bPassPhraseDialogOnce = TRUE;

			pPrivateKey = NULL;

            for (;;) {
                /*
                 * Try to read the private key file with the help of
                 * the callback function which serves the pass
                 * phrases to OpenSSL
                 */
                if ((fp = ap_pfopen(p, szPath, "r")) == NULL) {
                    ssl_log(s, SSL_LOG_ERROR|SSL_ADD_ERRNO,
                            "Init: Can't open server private key file %s", szPath);
                    ssl_die();
                }
                cpPassPhraseCur = NULL;
                bReadable = ((pPrivateKey = SSL_read_PrivateKey(fp, NULL,
                             ssl_pphrase_Handle_CB)) != NULL ? TRUE : FALSE);
                ap_pfclose(p, fp);

                /*
                 * when the private key file now was readable,
                 * it's fine and we go out of the loop
                 */
                if (bReadable)
                   break;

                /*
                 * when we have more remembered pass phrases
                 * try to reuse these first.
                 */
                if (nPassPhraseCur < nPassPhrase) {
                    nPassPhraseCur++;
                    continue;
                }

                /*
                 * else it's not readable and we have no more
                 * remembered pass phrases. Then this has to mean
                 * that the callback function popped up the dialog
                 * but a wrong pass phrase was entered.  We give the
                 * user (but not the dialog program) a few more
                 * chances...
                 */
                if (   sc->nPassPhraseDialogType == SSL_PPTYPE_BUILTIN
                    && cpPassPhraseCur != NULL
                    && nPassPhraseRetry < BUILTIN_DIALOG_RETRIES ) {
                    fprintf(stdout, "Apache:mod_ssl:Error: Pass phrase incorrect "
                            "(%d more retr%s permitted).\n",
                            (BUILTIN_DIALOG_RETRIES-nPassPhraseRetry),
                            (BUILTIN_DIALOG_RETRIES-nPassPhraseRetry) == 1 ? "y" : "ies");
                    nPassPhraseRetry++;
                    if (nPassPhraseRetry > BUILTIN_DIALOG_BACKOFF)
                        sleep((nPassPhraseRetry-BUILTIN_DIALOG_BACKOFF)*5);
                    continue;
                }

                /*
                 * Ok, anything else now means a fatal error.
                 */
                if (cpPassPhraseCur == NULL)
                    ssl_log(pServ, SSL_LOG_ERROR|SSL_ADD_SSLERR, "Init: Private key not found");
                    if (sc->nPassPhraseDialogType == SSL_PPTYPE_BUILTIN) {
                        fprintf(stdout, "Apache:mod_ssl:Error: Private key not found.\n");
                        fprintf(stdout, "**Stopped\n");
                    }
                else {
                    ssl_log(pServ, SSL_LOG_ERROR|SSL_ADD_SSLERR, "Init: Pass phrase incorrect");
                    if (sc->nPassPhraseDialogType == SSL_PPTYPE_BUILTIN) {
                        fprintf(stdout, "Apache:mod_ssl:Error: Pass phrase incorrect.\n");
                        fprintf(stdout, "**Stopped\n");
                    }
                }
d214 4
d219 6
a224 5
            if (pPrivateKey == NULL) {
                ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                        "Init: Unable to read server private key from file %s", szPath);
                ssl_die();
            }
d227 2
a228 2
             * check algorithm type of private key and make
             * sure only one private key per type is used.
d230 3
a232 6
            at = ssl_util_algotypeof(NULL, pPrivateKey);
            an = ssl_util_algotypestr(at);
            if (algoKey & at) {
                ssl_log(s, SSL_LOG_ERROR|SSL_ADD_SSLERR,
                        "Init: Multiple %s server private keys not allowed", an);
                ssl_die();
a233 1
            algoKey |= at;
d236 6
a241 1
             * Log the type of reading
d243 11
a253 13
            if (nPassPhraseDialogCur == 0)
                ssl_log(pServ, SSL_LOG_TRACE, 
                        "Init: (%s) unencrypted %s private key - pass phrase not required", 
                        cpVHostID, an);
            else {
                if (cpPassPhraseCur != NULL)
                    ssl_log(pServ, SSL_LOG_TRACE, 
                            "Init: (%s) encrypted %s private key - pass phrase requested", 
                            cpVHostID, an);
                else
                    ssl_log(pServ, SSL_LOG_TRACE, 
                            "Init: (%s) encrypted %s private key - pass phrase reused", 
                            cpVHostID, an);
d257 1
a257 1
             * Ok, when we have one more pass phrase store it
d259 3
a261 4
            if (cpPassPhraseCur != NULL) {
                cpp = (char **)ssl_ds_array_push(aPassPhrase);
                *cpp = cpPassPhraseCur;
                nPassPhrase++;
d263 3
d267 17
a283 11
            /*
             * Insert private key into the global module configuration
             * (we convert it to a stand-alone DER byte sequence
             * because the SSL library uses static variables inside a
             * RSA structure which do not survive DSO reloads!)
             */
            cp = ap_psprintf(mc->pPool, "%s:%s", cpVHostID, an);
            asn1 = (ssl_asn1_t *)ssl_ds_table_push(mc->tPrivateKey, cp);
            asn1->nData  = i2d_PrivateKey(pPrivateKey, NULL);
            asn1->cpData = ap_palloc(mc->pPool, asn1->nData);
            ucp = asn1->cpData; i2d_PrivateKey(pPrivateKey, &ucp); /* 2nd arg increments */
d285 7
a291 4
            /*
             * Free the private key structure
             */
            EVP_PKEY_free(pPrivateKey);
d293 16
d335 1
a335 1
int ssl_pphrase_Handle_CB(char *buf, int bufsize, int verify)
a344 1
    char *cpAlgoType;
a347 1
    int stderr_store;
d354 9
a362 10
    s                      = myCtxVarGet(mc,  1, server_rec *);
    p                      = myCtxVarGet(mc,  2, pool *);
    aPassPhrase            = myCtxVarGet(mc,  3, ssl_ds_array *);
    pnPassPhraseCur        = myCtxVarGet(mc,  4, int *);
    cppPassPhraseCur       = myCtxVarGet(mc,  5, char **);
    cpVHostID              = myCtxVarGet(mc,  6, char *);
    cpAlgoType             = myCtxVarGet(mc,  7, char *);
    pnPassPhraseDialog     = myCtxVarGet(mc,  8, int *);
    pnPassPhraseDialogCur  = myCtxVarGet(mc,  9, int *);
    pbPassPhraseDialogOnce = myCtxVarGet(mc, 10, BOOL *);
a382 3
#ifdef WIN32
        FILE *con;
#endif
d392 1
a392 13
#ifdef WIN32
        stderr_store = STDERR_FILENO_STORE;
#else
        if ((stderr_store = open("/dev/null", O_WRONLY)) == -1)
            stderr_store = STDERR_FILENO_STORE;
#endif
        dup2(STDERR_FILENO, stderr_store);
#ifdef WIN32
        if ((con = fopen("con", "w")) != NULL)
            dup2(fileno(con), STDERR_FILENO);
        else
            dup2(STDOUT_FILENO, STDERR_FILENO);
#else
a393 1
#endif
d397 1
a397 1
         * program he actually speaks to, which module is responsible for
d410 1
a410 1
            fprintf(stderr, "Server %s (%s)\n", cpVHostID, cpAlgoType);
d414 1
a414 1
         * Emulate the OpenSSL internal pass phrase dialog
d419 1
a419 1
            if ((i = EVP_read_pw_string(buf, bufsize, prompt, FALSE)) != 0) {
d425 2
a426 2
            if (len < 1)
                fprintf(stderr, "Apache:mod_ssl:Error: Pass phrase empty (needs to be at least 1 character).\n");
d434 1
a434 6
        dup2(stderr_store, STDERR_FILENO);
        close(stderr_store);
#ifdef WIN32
        if (con != NULL)
            fclose(con);
#endif
d448 1
a448 4
        if (strchr(sc->szPassPhraseDialogPath, ' ') != NULL)
            cmd = ap_psprintf(p, "\"%s\" %s %s", sc->szPassPhraseDialogPath, cpVHostID, cpAlgoType);
        else
            cmd = ap_psprintf(p, "%s %s %s", sc->szPassPhraseDialogPath, cpVHostID, cpAlgoType);
d460 1
a460 1
     * And return it's length to OpenSSL...
@


1.1.1.2
log
@import Apache 1.3.29 and mod_ssl 2.8.16
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2003 Ralf S. Engelschall. All rights reserved.
a239 3
                /* Ensure that the error stack is empty; otherwise the
                   OpenSSL UI code may dump it to stderr. */
                ERR_clear_error();
@


