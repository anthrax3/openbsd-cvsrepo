head	1.24;
access;
symbols
	OPENBSD_5_5:1.23.0.6
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.19.0.20
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.18
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.16
	OPENBSD_5_0:1.19.0.14
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.12
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.10
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.6
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.14
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.12
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.10
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.8
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.6
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.3
	OPENBSD_3_4:1.14.0.4
	OPENBSD_3_4_BASE:1.14
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.2
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.2
	apache_1_3_27:1.1.1.1
	apache:1.1.1
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.4
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.24
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.23;

1.23
date	2013.07.16.13.22.55;	author jsing;	state Exp;
branches;
next	1.22;

1.22
date	2013.07.16.13.02.16;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2013.07.16.11.32.05;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2013.07.11.12.41.52;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.27.10.17.24;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.06.13.14.10;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.02.19.42.47;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.17.18.57.05;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.02.16.21.31;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.28.17.36.54;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.22.18.52.08;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.20.18.06.15;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.13.18.12.00;	author brad;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.03.29.10.21.46;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.15.22.18.18;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.21.01.20.30;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.30.05.35.10;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.19.11.17.21;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.25.18.29.54;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.12.08.02.45.49;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.12.08.00.05.17;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.06.29.46;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.03.01.04.28.52;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.07.19.48.14;	author henning;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.10.28.14.19.05;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.17.17.03.23;	author henning;	state Exp;
branches;
next	;

1.11.2.1
date	2002.03.13.20.21.01;	author miod;	state Exp;
branches;
next	;


desc
@@


1.24
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*                      _             _
**  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
** | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
** | | | | | | (_) | (_| |   \__ \__ \ |  www.modssl.org
** |_| |_| |_|\___/ \__,_|___|___/___/_|  ftp.modssl.org
**                      |_____|
**  ssl_engine_config.c
**  Apache Configuration Directives
*/

/* ====================================================================
 * Copyright (c) 1998-2003 Ralf S. Engelschall. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials
 *    provided with the distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by
 *     Ralf S. Engelschall <rse@@engelschall.com> for use in the
 *     mod_ssl project (http://www.modssl.org/)."
 *
 * 4. The names "mod_ssl" must not be used to endorse or promote
 *    products derived from this software without prior written
 *    permission. For written permission, please contact
 *    rse@@engelschall.com.
 *
 * 5. Products derived from this software may not be called "mod_ssl"
 *    nor may "mod_ssl" appear in their names without prior
 *    written permission of Ralf S. Engelschall.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by
 *     Ralf S. Engelschall <rse@@engelschall.com> for use in the
 *     mod_ssl project (http://www.modssl.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY RALF S. ENGELSCHALL ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL RALF S. ENGELSCHALL OR
 * HIS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 */

                                      /* ``Damned if you do,
                                           damned if you don't.''
                                               -- Unknown        */
#include "mod_ssl.h"


/*  _________________________________________________________________
**
**  Support for Global Configuration
**  _________________________________________________________________
*/

void ssl_hook_AddModule(module *m)
{
    if (m == &ssl_module) {
        /*
         * Announce us for the configuration files
         */
        ap_add_config_define("MOD_SSL");

        /*
         * Link ourself into the Apache kernel
         */
        ssl_var_register();
        ssl_ext_register();
        ssl_io_register();
#if defined(SSL_VENDOR) && defined(SSL_VENDOR_OBJS)
        ssl_vendor_register();
#endif
    }
    return;
}

void ssl_hook_RemoveModule(module *m)
{
    if (m == &ssl_module) {
        /*
         * Unlink ourself from the Apache kernel
         */
        ssl_var_unregister();
        ssl_ext_unregister();
        ssl_io_unregister();
#if defined(SSL_VENDOR) && defined(SSL_VENDOR_OBJS)
        ssl_vendor_unregister();
#endif
    }
    return;
}

void ssl_config_global_create(void)
{
    pool *pPool;
    SSLModConfigRec *mc;

    mc = ap_ctx_get(ap_global_ctx, "ssl_module");
    if (mc == NULL) {
        /*
         * allocate an own subpool which survives server restarts
         */
        pPool = ap_make_sub_pool(NULL);
        mc = (SSLModConfigRec *)ap_palloc(pPool, sizeof(SSLModConfigRec));
        mc->pPool = pPool;
        mc->bFixed = FALSE;

        /*
         * initialize per-module configuration
         */
        mc->nInitCount             = 0;
        mc->nSessionCacheMode      = SSL_SCMODE_UNSET;
        mc->szSessionCacheDataFile = NULL;
        mc->nSessionCacheDataSize  = 0;
        mc->pSessionCacheDataMM    = NULL;
        mc->tSessionCacheDataTable = NULL;
        mc->nMutexMode             = SSL_MUTEXMODE_UNSET;
        mc->szMutexFile            = NULL;
        mc->nMutexFD               = -1;
        mc->nMutexSEMID            = -1;
        mc->aRandSeed              = ap_make_array(pPool, 4, sizeof(ssl_randseed_t));
        mc->tPrivateKey            = ssl_ds_table_make(pPool, sizeof(ssl_asn1_t));
        mc->tPublicCert            = ssl_ds_table_make(pPool, sizeof(ssl_asn1_t));
        mc->tTmpKeys               = ssl_ds_table_make(pPool, sizeof(ssl_asn1_t));
#ifdef SSL_EXPERIMENTAL_ENGINE
        mc->szCryptoDevice         = NULL;
#endif

        (void)memset(mc->pTmpKeys, 0, SSL_TKPIDX_MAX*sizeof(void *));

#ifdef SSL_VENDOR
        mc->ctx = ap_ctx_new(pPool);
        ap_hook_use("ap::mod_ssl::vendor::config_global_create",
                AP_HOOK_SIG2(void,ptr), AP_HOOK_MODE_ALL, mc);
#endif

        /*
         * And push it into Apache's global context
         */
        ap_ctx_set(ap_global_ctx, "ssl_module", mc);
    }
    return;
}

void ssl_config_global_fix(void)
{
    SSLModConfigRec *mc = myModConfig();
    mc->bFixed = TRUE;
    return;
}

BOOL ssl_config_global_isfixed(void)
{
    SSLModConfigRec *mc = myModConfig();
    return (mc->bFixed);
}


/*  _________________________________________________________________
**
**  Configuration handling
**  _________________________________________________________________
*/

/*
 *  Create per-server SSL configuration
 */
void *ssl_config_server_create(pool *p, server_rec *s)
{
    SSLSrvConfigRec *sc;

    ssl_config_global_create();

    sc = ap_palloc(p, sizeof(SSLSrvConfigRec));
    sc->bEnabled               = UNSET;
    sc->bCompression           = FALSE;
    sc->szCACertificatePath    = NULL;
    sc->szCACertificateFile    = NULL;
    sc->szCertificateChain     = NULL;
    sc->szLogFile              = NULL;
    sc->szCipherSuite          = NULL;
    sc->nECDHCurve             = NID_X9_62_prime256v1;
    sc->bHonorCipherOrder      = UNSET;
    sc->nLogLevel              = SSL_LOG_NONE;
    sc->nVerifyDepth           = UNSET;
    sc->nVerifyClient          = SSL_CVERIFY_UNSET;
    sc->nSessionCacheTimeout   = UNSET;
    sc->nPassPhraseDialogType  = SSL_PPTYPE_UNSET;
    sc->szPassPhraseDialogPath = NULL;
    sc->nProtocol              = SSL_PROTOCOL_ALL;
    sc->fileLogFile            = NULL;
    sc->pSSLCtx                = NULL;
    sc->szCARevocationPath     = NULL;
    sc->szCARevocationFile     = NULL;
    sc->pRevocationStore       = NULL;

#ifdef SSL_EXPERIMENTAL_PROXY
    sc->nProxyVerifyDepth             = UNSET;
    sc->szProxyCACertificatePath      = NULL;
    sc->szProxyCACertificateFile      = NULL;
    sc->szProxyClientCertificateFile  = NULL;
    sc->szProxyClientCertificatePath  = NULL;
    sc->szProxyCipherSuite            = NULL;
    sc->nProxyProtocol                = SSL_PROTOCOL_ALL & ~SSL_PROTOCOL_TLSV1;
    sc->bProxyVerify                  = UNSET;
    sc->pSSLProxyCtx                  = NULL;
#endif

    (void)memset(sc->szPublicCertFile, 0, SSL_AIDX_MAX*sizeof(char *));
    (void)memset(sc->szPrivateKeyFile, 0, SSL_AIDX_MAX*sizeof(char *));
    (void)memset(sc->pPublicCert, 0, SSL_AIDX_MAX*sizeof(X509 *));
    (void)memset(sc->pPrivateKey, 0, SSL_AIDX_MAX*sizeof(EVP_PKEY *));

#ifdef SSL_VENDOR
    sc->ctx = ap_ctx_new(p);
    ap_hook_use("ap::mod_ssl::vendor::config_server_create",
                AP_HOOK_SIG4(void,ptr,ptr,ptr), AP_HOOK_MODE_ALL,
                p, s, sc);
#endif

    return sc;
}

/*
 *  Merge per-server SSL configurations
 */
void *ssl_config_server_merge(pool *p, void *basev, void *addv)
{
    SSLSrvConfigRec *base = (SSLSrvConfigRec *)basev;
    SSLSrvConfigRec *add  = (SSLSrvConfigRec *)addv;
    SSLSrvConfigRec *new  = (SSLSrvConfigRec *)ap_palloc(p, sizeof(SSLSrvConfigRec));
    int i;

    cfgMergeBool(bEnabled);
    cfgMergeBool(bCompression);
    cfgMergeString(szCACertificatePath);
    cfgMergeString(szCACertificateFile);
    cfgMergeString(szCertificateChain);
    cfgMergeString(szLogFile);
    cfgMergeString(szCipherSuite);
    cfgMerge(nECDHCurve, NID_X9_62_prime256v1);
    cfgMergeBool(bHonorCipherOrder);
    cfgMerge(nLogLevel, SSL_LOG_NONE);
    cfgMergeInt(nVerifyDepth);
    cfgMerge(nVerifyClient, SSL_CVERIFY_UNSET);
    cfgMergeInt(nSessionCacheTimeout);
    cfgMerge(nPassPhraseDialogType, SSL_PPTYPE_UNSET);
    cfgMergeString(szPassPhraseDialogPath);
    cfgMerge(nProtocol, SSL_PROTOCOL_ALL);
    cfgMerge(fileLogFile, NULL);
    cfgMerge(pSSLCtx, NULL);
    cfgMerge(szCARevocationPath, NULL);
    cfgMerge(szCARevocationFile, NULL);
    cfgMerge(pRevocationStore, NULL);

    for (i = 0; i < SSL_AIDX_MAX; i++) {
        cfgMergeString(szPublicCertFile[i]);
        cfgMergeString(szPrivateKeyFile[i]);
        cfgMerge(pPublicCert[i], NULL);
        cfgMerge(pPrivateKey[i], NULL);
    }

#ifdef SSL_VENDOR
    cfgMergeCtx(ctx);
    ap_hook_use("ap::mod_ssl::vendor::config_server_merge",
                AP_HOOK_SIG5(void,ptr,ptr,ptr,ptr), AP_HOOK_MODE_ALL,
                p, base, add, new);
#endif

#ifdef SSL_EXPERIMENTAL_PROXY
    cfgMergeInt(nProxyVerifyDepth);
    cfgMergeString(szProxyCACertificatePath);
    cfgMergeString(szProxyCACertificateFile);
    cfgMergeString(szProxyClientCertificateFile);
    cfgMergeString(szProxyClientCertificatePath);
    cfgMergeString(szProxyCipherSuite);
    cfgMerge(nProxyProtocol, (SSL_PROTOCOL_ALL & ~SSL_PROTOCOL_TLSV1));
    cfgMergeBool(bProxyVerify);
    cfgMerge(pSSLProxyCtx, NULL);
#endif

    return new;
}

/*
 *  Create per-directory SSL configuration
 */
void *ssl_config_perdir_create(pool *p, char *dir)
{
    SSLDirConfigRec *dc = ap_palloc(p, sizeof(SSLDirConfigRec));

    dc->bSSLRequired  = FALSE;
    dc->aRequirement  = ap_make_array(p, 4, sizeof(ssl_require_t));
    dc->nOptions      = SSL_OPT_NONE|SSL_OPT_RELSET;
    dc->nOptionsAdd   = SSL_OPT_NONE;
    dc->nOptionsDel   = SSL_OPT_NONE;

    dc->szCipherSuite          = NULL;
    dc->nVerifyClient          = SSL_CVERIFY_UNSET;
    dc->nVerifyDepth           = UNSET;
#ifdef SSL_EXPERIMENTAL_PERDIRCA
    dc->szCACertificatePath    = NULL;
    dc->szCACertificateFile    = NULL;
#endif

#ifdef SSL_VENDOR
    dc->ctx = ap_ctx_new(p);
    ap_hook_use("ap::mod_ssl::vendor::config_perdir_create",
                AP_HOOK_SIG4(void,ptr,ptr,ptr), AP_HOOK_MODE_ALL,
                p, dir, dc);
#endif

    return dc;
}

/*
 *  Merge per-directory SSL configurations
 */
void *ssl_config_perdir_merge(pool *p, void *basev, void *addv)
{
    SSLDirConfigRec *base = (SSLDirConfigRec *)basev;
    SSLDirConfigRec *add  = (SSLDirConfigRec *)addv;
    SSLDirConfigRec *new  = (SSLDirConfigRec *)ap_palloc(p,
                                               sizeof(SSLDirConfigRec));

    cfgMerge(bSSLRequired, FALSE);
    cfgMergeArray(aRequirement);

    if (add->nOptions & SSL_OPT_RELSET) {
        new->nOptionsAdd = (base->nOptionsAdd & ~(add->nOptionsDel)) | add->nOptionsAdd;
        new->nOptionsDel = (base->nOptionsDel & ~(add->nOptionsAdd)) | add->nOptionsDel;
        new->nOptions    = (base->nOptions    & ~(new->nOptionsDel)) | new->nOptionsAdd;
    }
    else {
        new->nOptions    = add->nOptions;
        new->nOptionsAdd = add->nOptionsAdd;
        new->nOptionsDel = add->nOptionsDel;
    }

    cfgMergeString(szCipherSuite);
    cfgMerge(nVerifyClient, SSL_CVERIFY_UNSET);
    cfgMergeInt(nVerifyDepth);
#ifdef SSL_EXPERIMENTAL_PERDIRCA
    cfgMergeString(szCACertificatePath);
    cfgMergeString(szCACertificateFile);
#endif

#ifdef SSL_VENDOR
    cfgMergeCtx(ctx);
    ap_hook_use("ap::mod_ssl::vendor::config_perdir_merge",
                AP_HOOK_SIG5(void,ptr,ptr,ptr,ptr), AP_HOOK_MODE_ALL,
                p, base, add, new);
#endif

    return new;
}

/*
 * Directive Rewriting
 */

char *ssl_hook_RewriteCommand(cmd_parms *cmd, void *config, const char *cmd_line)
{
#ifdef SSL_COMPAT
    return ssl_compat_directive(cmd->server, cmd->pool, cmd_line);
#else
    return NULL;
#endif
}

/*
 *  Configuration functions for particular directives
 */

const char *ssl_cmd_SSLMutex(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    const char *err;
    SSLModConfigRec *mc = myModConfig();

    if ((err = ap_check_cmd_context(cmd, GLOBAL_ONLY)) != NULL)
        return err;
    if (ssl_config_global_isfixed())
        return NULL;
    if (strcEQ(arg, "none")) {
        mc->nMutexMode  = SSL_MUTEXMODE_NONE;
    }
    else if (strlen(arg) > 5 && strcEQn(arg, "file:", 5)) {
        mc->nMutexMode  = SSL_MUTEXMODE_FILE;
        mc->szMutexFile = ap_psprintf(mc->pPool, "%s.%lu",
                                      ssl_util_server_root_relative(cmd->pool, "mutex", arg+5),
                                      (unsigned long)getpid());
    }
    else if (strcEQ(arg, "sem")) {
        mc->nMutexMode  = SSL_MUTEXMODE_SEM;
    }
    else
        return "SSLMutex: Invalid argument";
    return NULL;
}

const char *ssl_cmd_SSLPassPhraseDialog(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    const char *err;

    if ((err = ap_check_cmd_context(cmd, GLOBAL_ONLY)) != NULL)
        return err;
    if (strcEQ(arg, "builtin")) {
        sc->nPassPhraseDialogType  = SSL_PPTYPE_BUILTIN;
        sc->szPassPhraseDialogPath = NULL;
    }
    else if (strlen(arg) > 5 && strEQn(arg, "exec:", 5)) {
        sc->nPassPhraseDialogType  = SSL_PPTYPE_FILTER;
        sc->szPassPhraseDialogPath = ssl_util_server_root_relative(cmd->pool, "dialog", arg+5);
        if (!ssl_util_path_check(SSL_PCM_EXISTS, sc->szPassPhraseDialogPath))
            return ap_pstrcat(cmd->pool, "SSLPassPhraseDialog: file '",
                              sc->szPassPhraseDialogPath, "' does not exist", NULL);
    }
    else
        return "SSLPassPhraseDialog: Invalid argument";
    return NULL;
}

#ifdef SSL_EXPERIMENTAL_ENGINE
const char *ssl_cmd_SSLCryptoDevice(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLModConfigRec *mc = myModConfig();
    const char *err;
    ENGINE *e;
    static int loaded_engines = FALSE;

    /* early loading to make sure the engines are already 
       available for ENGINE_by_id() above... */
    if (!loaded_engines) {
        ENGINE_load_builtin_engines();
        loaded_engines = TRUE;
    }
    if ((err = ap_check_cmd_context(cmd, GLOBAL_ONLY)) != NULL)
        return err;
    if (strcEQ(arg, "builtin")) {
        mc->szCryptoDevice = NULL;
    }
    else if ((e = ENGINE_by_id(arg)) != NULL) {
        mc->szCryptoDevice = arg;
        ENGINE_free(e);
    }
    else
        return "SSLCryptoDevice: Invalid argument";
    return NULL;
}
#endif

const char *ssl_cmd_SSLRandomSeed(
    cmd_parms *cmd, char *struct_ptr, char *arg1, char *arg2, char *arg3)
{
    SSLModConfigRec *mc = myModConfig();
    const char *err;
    ssl_randseed_t *pRS;

    if ((err = ap_check_cmd_context(cmd, GLOBAL_ONLY)) != NULL)
        return err;
    if (ssl_config_global_isfixed())
        return NULL;
    pRS = ap_push_array(mc->aRandSeed);
    if (strcEQ(arg1, "startup"))
        pRS->nCtx = SSL_RSCTX_STARTUP;
    else if (strcEQ(arg1, "connect"))
        pRS->nCtx = SSL_RSCTX_CONNECT;
    else
        return ap_pstrcat(cmd->pool, "SSLRandomSeed: "
                          "invalid context: `", arg1, "'");
    if (strlen(arg2) > 5 && strEQn(arg2, "file:", 5)) {
        pRS->nSrc   = SSL_RSSRC_FILE;
        pRS->cpPath = ap_pstrdup(mc->pPool, ssl_util_server_root_relative(cmd->pool, "random", arg2+5));
    }
    else if (strlen(arg2) > 5 && strEQn(arg2, "exec:", 5)) {
        pRS->nSrc   = SSL_RSSRC_EXEC;
        pRS->cpPath = ap_pstrdup(mc->pPool, ssl_util_server_root_relative(cmd->pool, "random", arg2+5));
    }
    else if (strlen(arg2) > 4 && strEQn(arg2, "egd:", 4)) {
        pRS->nSrc   = SSL_RSSRC_EGD;
        pRS->cpPath = ap_pstrdup(mc->pPool, ssl_util_server_root_relative(cmd->pool, "random", arg2+4));
    }
    else if (strcEQ(arg2, "builtin")) {
        pRS->nSrc   = SSL_RSSRC_BUILTIN;
        pRS->cpPath = NULL;
    }
    else {
        pRS->nSrc   = SSL_RSSRC_FILE;
        pRS->cpPath = ap_pstrdup(mc->pPool, ssl_util_server_root_relative(cmd->pool, "random", arg2));
    }
    if (pRS->nSrc != SSL_RSSRC_BUILTIN)
        if (!ssl_util_path_check(SSL_PCM_EXISTS, pRS->cpPath))
            return ap_pstrcat(cmd->pool, "SSLRandomSeed: source path '",
                              pRS->cpPath, "' does not exist", NULL);
    if (arg3 == NULL)
        pRS->nBytes = 0; /* read whole file */
    else {
        if (pRS->nSrc == SSL_RSSRC_BUILTIN)
            return "SSLRandomSeed: byte specification not "
                   "allowed for builtin seed source";
        pRS->nBytes = atoi(arg3);
        if (pRS->nBytes < 0)
            return "SSLRandomSeed: invalid number of bytes specified";
    }
    return NULL;
}

const char *ssl_cmd_SSLEngine(
    cmd_parms *cmd, char *struct_ptr, int flag)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);

    sc->bEnabled = (flag ? TRUE : FALSE);
    return NULL;
}

const char *ssl_cmd_SSLCompression(
     cmd_parms *cmd, char *struct_ptr, int flag)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);

    sc->bCompression = (flag ? TRUE : FALSE);
    return NULL;
}

const char *ssl_cmd_SSLCipherSuite(
    cmd_parms *cmd, SSLDirConfigRec *dc, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);

    if (cmd->path == NULL || dc == NULL)
        sc->szCipherSuite = arg;
    else
        dc->szCipherSuite = arg;
    return NULL;
}

const char *ssl_cmd_SSLECDHCurve(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);

    if (strcEQ(arg, "none")) {
        sc->nECDHCurve = 0;
        return NULL;
    }

    sc->nECDHCurve = OBJ_sn2nid((const char *)arg);
    if (sc->nECDHCurve == 0) {
        return ap_pstrcat(cmd->pool, "SSLECDHCurve: unknown named curve '",
                          arg, "'", NULL);
    }

    return NULL;
}

const char *ssl_cmd_SSLHonorCipherOrder(
     cmd_parms *cmd, char *struct_ptr, int flag)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);

    sc->bHonorCipherOrder = (flag ? TRUE : FALSE);
    return NULL;
}

const char *ssl_cmd_SSLCertificateFile(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;
    int i;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ap_server_is_chrooted() && !ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISREG|SSL_PCM_ISNONZERO, cpPath))
        return ap_pstrcat(cmd->pool, "SSLCertificateFile: file '",
                          cpPath, "' does not exist or is empty", NULL);
    for (i = 0; i < SSL_AIDX_MAX && sc->szPublicCertFile[i] != NULL; i++)
        ;
    if (i == SSL_AIDX_MAX)
        return ap_psprintf(cmd->pool, "SSLCertificateFile: only up to %d "
                          "different certificates per virtual host allowed", 
                          SSL_AIDX_MAX);
    sc->szPublicCertFile[i] = cpPath;
    return NULL;
}

const char *ssl_cmd_SSLCertificateKeyFile(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;
    int i;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ap_server_is_chrooted() && !ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISREG|SSL_PCM_ISNONZERO, cpPath))
        return ap_pstrcat(cmd->pool, "SSLCertificateKeyFile: file '",
                          cpPath, "' does not exist or is empty", NULL);
    for (i = 0; i < SSL_AIDX_MAX && sc->szPrivateKeyFile[i] != NULL; i++)
        ;
    if (i == SSL_AIDX_MAX)
        return ap_psprintf(cmd->pool, "SSLCertificateKeyFile: only up to %d "
                          "different private keys per virtual host allowed", 
                          SSL_AIDX_MAX);
    sc->szPrivateKeyFile[i] = cpPath;
    return NULL;
}

const char *ssl_cmd_SSLCertificateChainFile(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ap_server_is_chrooted() && !ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISREG|SSL_PCM_ISNONZERO, cpPath))
        return ap_pstrcat(cmd->pool, "SSLCertificateChainFile: file '",
                          cpPath, "' does not exist or is empty", NULL);
    ap_server_strip_chroot(cpPath, 0);
    sc->szCertificateChain = cpPath;
    return NULL;
}

const char *ssl_cmd_SSLCACertificatePath(
    cmd_parms *cmd, SSLDirConfigRec *dc, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISDIR, cpPath))
        return ap_pstrcat(cmd->pool, "SSLCACertificatePath: directory '",
                          cpPath, "' does not exist", NULL);
#ifdef SSL_EXPERIMENTAL_PERDIRCA
    if (cmd->path == NULL || dc == NULL)
        sc->szCACertificatePath = cpPath;
    else
        dc->szCACertificatePath = cpPath;
#else
    sc->szCACertificatePath = cpPath;
#endif
    return NULL;
}

const char *ssl_cmd_SSLCACertificateFile(
    cmd_parms *cmd, SSLDirConfigRec *dc, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISREG|SSL_PCM_ISNONZERO, cpPath))
        return ap_pstrcat(cmd->pool, "SSLCACertificateFile: file '",
                          cpPath, "' does not exist or is empty", NULL);
#ifdef SSL_EXPERIMENTAL_PERDIRCA
    if (cmd->path == NULL || dc == NULL)
        sc->szCACertificateFile = cpPath;
    else
        dc->szCACertificateFile = cpPath;
#else
    sc->szCACertificateFile = cpPath;
#endif
    return NULL;
}

const char *ssl_cmd_SSLCARevocationPath(
    cmd_parms *cmd, SSLDirConfigRec *dc, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISDIR, cpPath))
        return ap_pstrcat(cmd->pool, "SSLCARecocationPath: directory '",
                          cpPath, "' does not exist", NULL);
    sc->szCARevocationPath = cpPath;
    return NULL;
}

const char *ssl_cmd_SSLCARevocationFile(
    cmd_parms *cmd, SSLDirConfigRec *dc, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISREG|SSL_PCM_ISNONZERO, cpPath))
        return ap_pstrcat(cmd->pool, "SSLCARevocationFile: file '",
                          cpPath, "' does not exist or is empty", NULL);
    sc->szCARevocationFile = cpPath;
    return NULL;
}

const char *ssl_cmd_SSLVerifyClient(
    cmd_parms *cmd, SSLDirConfigRec *dc, char *level)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    ssl_verify_t id;

    if (strEQ(level, "0") || strcEQ(level, "none"))
        id = SSL_CVERIFY_NONE;
    else if (strEQ(level, "1") || strcEQ(level, "optional"))
        id = SSL_CVERIFY_OPTIONAL;
    else if (strEQ(level, "2") || strcEQ(level, "require"))
        id = SSL_CVERIFY_REQUIRE;
    else if (strEQ(level, "3") || strcEQ(level, "optional_no_ca"))
        id = SSL_CVERIFY_OPTIONAL_NO_CA;
    else
        return "SSLVerifyClient: Invalid argument";
    if (cmd->path == NULL || dc == NULL)
        sc->nVerifyClient = id;
    else
        dc->nVerifyClient = id;
    return NULL;
}

const char *ssl_cmd_SSLVerifyDepth(
    cmd_parms *cmd, SSLDirConfigRec *dc, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    int d;

    d = atoi(arg);
    if (d < 0)
        return "SSLVerifyDepth: Invalid argument";
    if (cmd->path == NULL || dc == NULL)
        sc->nVerifyDepth = d;
    else
        dc->nVerifyDepth = d;
    return NULL;
}

const char *ssl_cmd_SSLSessionCache(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    const char *err;
    SSLModConfigRec *mc = myModConfig();
    char *cp, *cp2;
    int maxsize;

    if ((err = ap_check_cmd_context(cmd, GLOBAL_ONLY)) != NULL)
        return err;
    if (ssl_config_global_isfixed())
        return NULL;
    if (strcEQ(arg, "none")) {
        mc->nSessionCacheMode      = SSL_SCMODE_NONE;
        mc->szSessionCacheDataFile = NULL;
    }
    else if (strlen(arg) > 4 && strcEQn(arg, "dbm:", 4)) {
        mc->nSessionCacheMode      = SSL_SCMODE_DBM;
        mc->szSessionCacheDataFile = ap_pstrdup(mc->pPool,
                                     ssl_util_server_root_relative(cmd->pool, "scache", arg+4));
    }
    else if (   (strlen(arg) > 4 && strcEQn(arg, "shm:",   4)) 
             || (strlen(arg) > 6 && strcEQn(arg, "shmht:", 6))) {
        if (!ap_mm_useable())
            return "SSLSessionCache: shared memory cache not useable on this platform";
        mc->nSessionCacheMode      = SSL_SCMODE_SHMHT;
        cp = strchr(arg, ':');
        mc->szSessionCacheDataFile = ap_pstrdup(mc->pPool,
                                     ssl_util_server_root_relative(cmd->pool, "scache", cp+1));
        mc->tSessionCacheDataTable = NULL;
        mc->nSessionCacheDataSize  = 1024*512; /* 512KB */
        if ((cp = strchr(mc->szSessionCacheDataFile, '(')) != NULL) {
            *cp++ = NUL;
            if ((cp2 = strchr(cp, ')')) == NULL)
                return "SSLSessionCache: Invalid argument: no closing parenthesis";
            *cp2 = NUL;
            mc->nSessionCacheDataSize = atoi(cp);
            if (mc->nSessionCacheDataSize < 8192)
                return "SSLSessionCache: Invalid argument: size has to be >= 8192 bytes";
            maxsize = ap_mm_core_maxsegsize();
            if (mc->nSessionCacheDataSize >= maxsize)
                return ap_psprintf(cmd->pool, "SSLSessionCache: Invalid argument: "
                                   "size has to be < %d bytes on this platform", maxsize);
        }
    }
    else if (strlen(arg) > 6 && strcEQn(arg, "shmcb:", 6)) {
        if (!ap_mm_useable())
            return "SSLSessionCache: shared memory cache not useable on this platform";
        mc->nSessionCacheMode      = SSL_SCMODE_SHMCB;
        mc->szSessionCacheDataFile = ap_pstrdup(mc->pPool,
                                     ap_server_root_relative(cmd->pool, arg+6));
        mc->tSessionCacheDataTable = NULL;
        mc->nSessionCacheDataSize  = 1024*512; /* 512KB */
        if ((cp = strchr(mc->szSessionCacheDataFile, '(')) != NULL) {
            *cp++ = NUL;
            if ((cp2 = strchr(cp, ')')) == NULL)
                return "SSLSessionCache: Invalid argument: no closing parenthesis";
            *cp2 = NUL;
            mc->nSessionCacheDataSize = atoi(cp);
            if (mc->nSessionCacheDataSize < 8192)
                return "SSLSessionCache: Invalid argument: size has to be >= 8192 bytes";
            maxsize = ap_mm_core_maxsegsize();
            if (mc->nSessionCacheDataSize >= maxsize)
                return ap_psprintf(cmd->pool, "SSLSessionCache: Invalid argument: "
                                   "size has to be < %d bytes on this platform", maxsize);
        }
    }
	else
#ifdef SSL_VENDOR
        if (!ap_hook_use("ap::mod_ssl::vendor::cmd_sslsessioncache",
             AP_HOOK_SIG4(void,ptr,ptr,ptr), AP_HOOK_MODE_ALL,
             cmd, arg, mc))
#endif
        return "SSLSessionCache: Invalid argument";
    return NULL;
}

const char *ssl_cmd_SSLSessionCacheTimeout(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);

    sc->nSessionCacheTimeout = atoi(arg);
    if (sc->nSessionCacheTimeout < 0)
        return "SSLSessionCacheTimeout: Invalid argument";
    return NULL;
}

const char *ssl_cmd_SSLLog(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    const char *err;

    if ((err = ap_check_cmd_context(cmd,  NOT_IN_LIMIT|NOT_IN_DIRECTORY
                                         |NOT_IN_LOCATION|NOT_IN_FILES )) != NULL)
        return err;
    sc->szLogFile = arg;
    return NULL;
}

const char *ssl_cmd_SSLLogLevel(
    cmd_parms *cmd, char *struct_ptr, char *level)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    const char *err;

    if ((err = ap_check_cmd_context(cmd,  NOT_IN_LIMIT|NOT_IN_DIRECTORY
                                         |NOT_IN_LOCATION|NOT_IN_FILES )) != NULL)
        return err;
    if (strcEQ(level, "none"))
        sc->nLogLevel = SSL_LOG_NONE;
    else if (strcEQ(level, "error"))
        sc->nLogLevel = SSL_LOG_ERROR;
    else if (strcEQ(level, "warn"))
        sc->nLogLevel = SSL_LOG_WARN;
    else if (strcEQ(level, "info"))
        sc->nLogLevel = SSL_LOG_INFO;
    else if (strcEQ(level, "trace"))
        sc->nLogLevel = SSL_LOG_TRACE;
    else if (strcEQ(level, "debug"))
        sc->nLogLevel = SSL_LOG_DEBUG;
    else
        return "SSLLogLevel: Invalid argument";
    return NULL;
}

const char *ssl_cmd_SSLOptions(
    cmd_parms *cmd, SSLDirConfigRec *dc, const char *cpLine)
{
    ssl_opt_t opt;
    int first;
    char action;
    char *w;

    first = TRUE;
    while (cpLine[0] != NUL) {
        w = ap_getword_conf(cmd->pool, &cpLine);
        action = NUL;

        if (*w == '+' || *w == '-') {
            action = *(w++);
        }
        else if (first) {
            dc->nOptions = SSL_OPT_NONE;
            first = FALSE;
        }

        if (strcEQ(w, "StdEnvVars"))
            opt = SSL_OPT_STDENVVARS;
        else if (strcEQ(w, "CompatEnvVars"))
            opt = SSL_OPT_COMPATENVVARS;
        else if (strcEQ(w, "ExportCertData"))
            opt = SSL_OPT_EXPORTCERTDATA;
        else if (strcEQ(w, "FakeBasicAuth"))
            opt = SSL_OPT_FAKEBASICAUTH;
        else if (strcEQ(w, "StrictRequire"))
            opt = SSL_OPT_STRICTREQUIRE;
        else if (strcEQ(w, "OptRenegotiate"))
            opt = SSL_OPT_OPTRENEGOTIATE;
        else
            return ap_pstrcat(cmd->pool, "SSLOptions: Illegal option '", w, "'", NULL);

        if (action == '-') {
            dc->nOptionsAdd &= ~opt;
            dc->nOptionsDel |=  opt;
            dc->nOptions    &= ~opt;
        }
        else if (action == '+') {
            dc->nOptionsAdd |=  opt;
            dc->nOptionsDel &= ~opt;
            dc->nOptions    |=  opt;
        }
        else {
            dc->nOptions    = opt;
            dc->nOptionsAdd = opt;
            dc->nOptionsDel = SSL_OPT_NONE;
        }
    }
    return NULL;
}

const char *ssl_cmd_SSLRequireSSL(
    cmd_parms *cmd, SSLDirConfigRec *dc, char *cipher)
{
    dc->bSSLRequired = TRUE;
    return NULL;
}

const char *ssl_cmd_SSLRequire(
    cmd_parms *cmd, SSLDirConfigRec *dc, char *cpExpr)
{
    ssl_expr *mpExpr;
    ssl_require_t *pReqRec;

    if ((mpExpr = ssl_expr_comp(cmd->pool, cpExpr)) == NULL)
        return ap_pstrcat(cmd->pool, "SSLRequire: ", ssl_expr_get_error(), NULL);
    pReqRec = ap_push_array(dc->aRequirement);
    pReqRec->cpExpr = ap_pstrdup(cmd->pool, cpExpr);
    pReqRec->mpExpr = mpExpr;
    return NULL;
}

const char *ssl_cmd_SSLProtocol(
    cmd_parms *cmd, char *struct_ptr, const char *opt)
{
    SSLSrvConfigRec *sc;
    ssl_proto_t options, thisopt;
    char action;
    char *w;

    sc = mySrvConfig(cmd->server);
    options = SSL_PROTOCOL_NONE;
    while (opt[0] != NUL) {
        w = ap_getword_conf(cmd->pool, &opt);

        action = NUL;
        if (*w == '+' || *w == '-')
            action = *(w++);

        if (strcEQ(w, "SSLv2"))
            thisopt = SSL_PROTOCOL_SSLV2;
        else if (strcEQ(w, "SSLv3"))
            thisopt = SSL_PROTOCOL_SSLV3;
        else if (strcEQ(w, "TLSv1"))
            thisopt = SSL_PROTOCOL_TLSV1;
        else if (strcEQ(w, "all"))
            thisopt = SSL_PROTOCOL_ALL;
        else
            return ap_pstrcat(cmd->pool, "SSLProtocol: Illegal protocol '", w, "'", NULL);

        if (action == '-')
            options &= ~thisopt;
        else if (action == '+')
            options |= thisopt;
        else
            options = thisopt;
    }
    sc->nProtocol = options;
    return NULL;
}

#ifdef SSL_EXPERIMENTAL_PROXY

const char *ssl_cmd_SSLProxyProtocol(
    cmd_parms *cmd, char *struct_ptr, const char *opt)
{
    SSLSrvConfigRec *sc;
    ssl_proto_t options, thisopt;
    char action;
    char *w;

    sc = mySrvConfig(cmd->server);
    options = SSL_PROTOCOL_NONE;
    while (opt[0] != NUL) {
        w = ap_getword_conf(cmd->pool, &opt);

        action = NUL;
        if (*w == '+' || *w == '-')
            action = *(w++);

        if (strcEQ(w, "SSLv2"))
            thisopt = SSL_PROTOCOL_SSLV2;
        else if (strcEQ(w, "SSLv3"))
            thisopt = SSL_PROTOCOL_SSLV3;
        else if (strcEQ(w, "TLSv1"))
            thisopt = SSL_PROTOCOL_TLSV1;
        else if (strcEQ(w, "all"))
            thisopt = SSL_PROTOCOL_ALL;
        else
            return ap_pstrcat(cmd->pool, "SSLProxyProtocol: "
                              "Illegal protocol '", w, "'", NULL);
        if (action == '-')
            options &= ~thisopt;
        else if (action == '+')
            options |= thisopt;
        else
            options = thisopt;
    }
    sc->nProxyProtocol = options;
    return NULL;
}

const char *ssl_cmd_SSLProxyCipherSuite(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);

    sc->szProxyCipherSuite = arg;
    return NULL;
}

const char *ssl_cmd_SSLProxyVerify(
    cmd_parms *cmd, char *struct_ptr, int flag)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);

    sc->bProxyVerify = (flag ? TRUE : FALSE);
    return NULL;
}

const char *ssl_cmd_SSLProxyVerifyDepth(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    int d;

    d = atoi(arg);
    if (d < 0)
        return "SSLProxyVerifyDepth: Invalid argument";
    sc->nProxyVerifyDepth = d;
    return NULL;
}

const char *ssl_cmd_SSLProxyCACertificateFile(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISREG|SSL_PCM_ISNONZERO, cpPath))
        return ap_pstrcat(cmd->pool, "SSLProxyCACertificateFile: file '",
                          cpPath, "' does not exist or is empty", NULL);
    sc->szProxyCACertificateFile = cpPath;
    return NULL;
}

const char *ssl_cmd_SSLProxyCACertificatePath(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISDIR, cpPath))
        return ap_pstrcat(cmd->pool, "SSLProxyCACertificatePath: directory '",
                          cpPath, "' does not exist", NULL);
    sc->szProxyCACertificatePath = cpPath;
    return NULL;
}

const char *ssl_cmd_SSLProxyMachineCertificateFile(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISREG|SSL_PCM_ISNONZERO, cpPath))
        return ap_pstrcat(cmd->pool, "SSLProxyMachineCertFile: file '",
                          cpPath, "' does not exist or is empty", NULL);
    sc->szProxyClientCertificateFile = cpPath;
    return NULL;
}

const char *ssl_cmd_SSLProxyMachineCertificatePath(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISDIR, cpPath))
        return ap_pstrcat(cmd->pool, "SSLProxyMachineCertPath: directory '",
                          cpPath, "' does not exist", NULL);
    sc->szProxyClientCertificatePath = cpPath;
    return NULL;
}

#endif /* SSL_EXPERIMENTAL_PROXY */

@


1.23
log
@Disable SSL compression in order to mitigate CRIME attacks. Add
an SSLCompression option so that it can be turned back on, however on
this is currently a no-op due to the compile options for libssl.

Requested by and ok djm@@
@
text
@@


1.22
log
@Enable ECDHE support in httpd via a SSLECDHCurve option. This specifies the
named curve to use when generating ephemeral EC keys for an ECDHE-based
cipher suite, or can be set to `none' to disable. The default is to use
a prime256v1 curve.

yay^Wok djm@@
@
text
@d194 1
d253 1
d536 9
@


1.21
log
@Define HonorCipherOrder as a FLAG (rather than as a TAKE1), so that it
works correctly as a boolean on/off flag. While here, rename the variable
so that it is consistent with existing naming scheme.

ok otto@@ djm@@
@
text
@d199 2
a201 1
    sc->bHonorCipherOrder      = UNSET;
d257 1
d546 19
@


1.20
log
@introduce HonorCipherOrder to use the server's order of preference of ciphers
ok djm@@ guenther@@
@
text
@d200 1
a200 1
    sc->cipher_server_pref     = UNSET;
d256 1
a256 1
    cfgMergeBool(cipher_server_pref);
a534 8
const char *ssl_cmd_SSLHonorCipherOrder(
     cmd_parms *cmd, char *struct_ptr, int flag)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    sc->cipher_server_pref = flag?TRUE:FALSE;
    return NULL;
}

d544 9
@


1.19
log
@grammar fixes; from Jochem Kossen, system/5822;
ok henning
@
text
@d200 1
d256 1
d532 8
@


1.18
log
@kill more dead code, mostly inside #ifdef SOMENONSENSEONSTUPIDOSES
joint work by Michael Knudsen <e@@molioner.dk> and Daniel Ouellet
<daniel@@presscom.net> with my input
no change in binaries
@
text
@d431 1
a431 1
                              sc->szPassPhraseDialogPath, "' not exists", NULL);
d510 1
a510 1
                              pRS->cpPath, "' not exists", NULL);
d555 1
a555 1
                          cpPath, "' not exists or empty", NULL);
d576 1
a576 1
                          cpPath, "' not exists or empty", NULL);
d596 1
a596 1
                          cpPath, "' not exists or empty", NULL);
d611 1
a611 1
                          cpPath, "' not exists", NULL);
d632 1
a632 1
                          cpPath, "' not exists or empty", NULL);
d653 1
a653 1
                          cpPath, "' not exists", NULL);
d667 1
a667 1
                          cpPath, "' not exists or empty", NULL);
d1034 1
a1034 1
                          cpPath, "' not exists or empty", NULL);
d1048 1
a1048 1
                          cpPath, "' does not exists", NULL);
d1062 1
a1062 1
                          cpPath, "' not exists or empty", NULL);
d1076 1
a1076 1
                          cpPath, "' does not exists", NULL);
@


1.17
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@a406 1
#ifdef SSL_CAN_USE_SEM
a407 3
#else
        return "SSLMutex: Semaphores not available on this platform";
#endif
a444 1
#if SSL_LIBRARY_VERSION >= 0x00907000
a452 1
#endif
a494 1
#if SSL_LIBRARY_VERSION >= 0x00905100
a498 1
#endif
@


1.16
log
@merge apache 1.3.29 and mod_ssl 2.8.16
ok brad@@
@
text
@a400 1
#ifndef WIN32
a404 3
#else
        return "SSLMutex: Lockfiles not available on this platform";
#endif
@


1.15
log
@chroot handling for SSLCertificateChainFile, problem found and fix tested by
Sandor Palfy <netchan@@cotse.net>
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2001 Ralf S. Engelschall. All rights reserved.
@


1.14
log
@merge mod-ssl 2.8.12
fixes a cross site scripting bug
fixes 2 off-by-ones
@
text
@d606 1
a606 1
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISREG|SSL_PCM_ISNONZERO, cpPath))
d609 1
@


1.13
log
@don't try to recheck the pathes to server.crt and .key once chrooted
makes graceful restarts work when running SSL.
@
text
@d759 1
a759 1
            if (mc->nSessionCacheDataSize <= 8192)
d781 1
a781 1
            if (mc->nSessionCacheDataSize <= 8192)
@


1.12
log
@merge mod_ssl 2.8.4
--
Ok'd by: beck@@
@
text
@d565 1
a565 1
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISREG|SSL_PCM_ISNONZERO, cpPath))
d586 1
a586 1
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISREG|SSL_PCM_ISNONZERO, cpPath))
@


1.11
log
@merge mod_ssl 2.8.2
--
Ok'd by: beck@@
@
text
@d453 2
d456 7
@


1.11.2.1
log
@Upgrade mod_ssl to 2.8.7, to fix the recent vulnerability.

Requested, and patch from: brad@@
@
text
@a452 2
#if SSL_LIBRARY_VERSION >= 0x00907000
    static int loaded_engines = FALSE;
a453 7
    /* early loading to make sure the engines are already 
       available for ENGINE_by_id() above... */
    if (!loaded_engines) {
        ENGINE_load_builtin_engines();
        loaded_engines = TRUE;
    }
#endif
@


1.10
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@a757 1
#ifdef SSL_EXPERIMENTAL_SHMCB
a779 1
#endif
@


1.9
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2000 Ralf S. Engelschall. All rights reserved.
@


1.8
log
@Mod_SSL 2.6.5 - from brad@@, thanks.
@
text
@d143 3
d446 23
d734 2
a735 1
    else if (strlen(arg) > 4 && strcEQn(arg, "shm:", 4)) {
d738 2
a739 1
        mc->nSessionCacheMode      = SSL_SCMODE_SHM;
d741 24
a764 1
                                     ssl_util_server_root_relative(cmd->pool, "scache", arg+4));
d781 1
@


1.7
log
@mod_ssl 2.6.4 merge
From brad@@
@
text
@d401 1
a401 1
                                      ssl_util_server_root_relative(cmd->pool, arg+5),
d433 1
a433 1
        sc->szPassPhraseDialogPath = ssl_util_server_root_relative(cmd->pool, arg+5);
d464 1
a464 1
        pRS->cpPath = ap_pstrdup(mc->pPool, ssl_util_server_root_relative(cmd->pool, arg2+5));
d468 1
a468 1
        pRS->cpPath = ap_pstrdup(mc->pPool, ssl_util_server_root_relative(cmd->pool, arg2+5));
d473 1
a473 1
        pRS->cpPath = ap_pstrdup(mc->pPool, ssl_util_server_root_relative(cmd->pool, arg2+4));
d482 1
a482 1
        pRS->cpPath = ap_pstrdup(mc->pPool, ssl_util_server_root_relative(cmd->pool, arg2));
d529 1
a529 1
    cpPath = ssl_util_server_root_relative(cmd->pool, arg);
d550 1
a550 1
    cpPath = ssl_util_server_root_relative(cmd->pool, arg);
d570 1
a570 1
    cpPath = ssl_util_server_root_relative(cmd->pool, arg);
d584 1
a584 1
    cpPath = ssl_util_server_root_relative(cmd->pool, arg);
d605 1
a605 1
    cpPath = ssl_util_server_root_relative(cmd->pool, arg);
d626 1
a626 1
    cpPath = ssl_util_server_root_relative(cmd->pool, arg);
d640 1
a640 1
    cpPath = ssl_util_server_root_relative(cmd->pool, arg);
d706 1
a706 1
                                     ssl_util_server_root_relative(cmd->pool, arg+4));
d713 1
a713 1
                                     ssl_util_server_root_relative(cmd->pool, arg+4));
d983 1
a983 1
    cpPath = ssl_util_server_root_relative(cmd->pool, arg);
d997 1
a997 1
    cpPath = ssl_util_server_root_relative(cmd->pool, arg);
d1011 1
a1011 1
    cpPath = ssl_util_server_root_relative(cmd->pool, arg);
d1025 1
a1025 1
    cpPath = ssl_util_server_root_relative(cmd->pool, arg);
@


1.6
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d209 1
a209 1
#ifdef SSL_EXPERIMENTAL
d279 1
a279 1
#ifdef SSL_EXPERIMENTAL
d310 1
a310 1
#ifdef SSL_EXPERIMENTAL
d352 1
a352 1
#ifdef SSL_EXPERIMENTAL
d401 1
a401 1
                                      ap_server_root_relative(cmd->pool, arg+5),
d433 1
a433 1
        sc->szPassPhraseDialogPath = ap_server_root_relative(cmd->pool, arg+5);
d464 1
a464 1
        pRS->cpPath = ap_pstrdup(mc->pPool, ap_server_root_relative(cmd->pool, arg2+5));
d468 1
a468 1
        pRS->cpPath = ap_pstrdup(mc->pPool, ap_server_root_relative(cmd->pool, arg2+5));
d473 1
a473 1
        pRS->cpPath = ap_pstrdup(mc->pPool, ap_server_root_relative(cmd->pool, arg2+4));
d482 1
a482 1
        pRS->cpPath = ap_pstrdup(mc->pPool, ap_server_root_relative(cmd->pool, arg2));
d529 1
a529 1
    cpPath = ap_server_root_relative(cmd->pool, arg);
d550 1
a550 1
    cpPath = ap_server_root_relative(cmd->pool, arg);
d570 1
a570 1
    cpPath = ap_server_root_relative(cmd->pool, arg);
d584 1
a584 1
    cpPath = ap_server_root_relative(cmd->pool, arg);
d588 1
a588 1
#ifdef SSL_EXPERIMENTAL
d605 1
a605 1
    cpPath = ap_server_root_relative(cmd->pool, arg);
d609 1
a609 1
#ifdef SSL_EXPERIMENTAL
d626 1
a626 1
    cpPath = ap_server_root_relative(cmd->pool, arg);
d640 1
a640 1
    cpPath = ap_server_root_relative(cmd->pool, arg);
d706 1
a706 1
                                     ap_server_root_relative(cmd->pool, arg+4));
d713 1
a713 1
                                     ap_server_root_relative(cmd->pool, arg+4));
d905 1
a905 1
#ifdef SSL_EXPERIMENTAL
d983 1
a983 1
    cpPath = ap_server_root_relative(cmd->pool, arg);
d997 1
a997 1
    cpPath = ap_server_root_relative(cmd->pool, arg);
d1011 1
a1011 1
    cpPath = ap_server_root_relative(cmd->pool, arg);
d1025 1
a1025 1
    cpPath = ap_server_root_relative(cmd->pool, arg);
d1033 1
a1033 1
#endif /* SSL_EXPERIMENTAL */
@


1.5
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d209 12
d279 12
d470 6
d904 130
@


1.4
log
@mod_ssl 2.4.9 merge
@
text
@d12 1
a12 1
 * Copyright (c) 1998-1999 Ralf S. Engelschall. All rights reserved.
d622 1
a622 1
    int id;
@


1.3
log
@ Mod_SSL 2.4.8 merge
@
text
@d781 3
a783 1
        if (strcEQ(w, "CompatEnvVars"))
@


1.2
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@a129 4
        mc->pRSATmpKey512          = NULL;
        mc->pRSATmpKey1024         = NULL;
        mc->pDHTmpParam512         = NULL;
        mc->pDHTmpParam1024        = NULL;
d142 3
@


1.1
log
@mod_ssl-2.2.3-1.3.4 (will require libssl-1.1 for https to work, but
mostly harmless otherwise).
@
text
@d2 4
a5 4
**  _ __ ___   ___   __| |    ___ ___| |
** | '_ ` _ \ / _ \ / _` |   / __/ __| |
** | | | | | | (_) | (_| |   \__ \__ \ | mod_ssl - Apache Interface to SSLeay
** |_| |_| |_|\___/ \__,_|___|___/___/_| http://www.engelschall.com/sw/mod_ssl/
d30 1
a30 1
 *     mod_ssl project (http://www.engelschall.com/sw/mod_ssl/)."
d45 1
a45 1
 *     mod_ssl project (http://www.engelschall.com/sw/mod_ssl/)."
d88 3
d104 3
d130 4
a133 1
        mc->pRSATmpKey             = NULL;
d136 3
a143 1

d147 6
a191 2
    sc->szCertificateFile      = NULL;
    sc->szKeyFile              = NULL;
d194 1
a204 2
    sc->px509Certificate       = NULL;
    sc->prsaKey                = NULL;
d206 15
d233 1
a235 2
    cfgMergeString(szCertificateFile);
    cfgMergeString(szKeyFile);
d238 1
a248 2
    cfgMerge(px509Certificate, NULL);
    cfgMerge(prsaKey, NULL);
d250 17
d292 7
d334 7
d375 1
d378 1
a378 1
                                      ap_server_root_relative(cmd->pool, arg+5), 
d380 3
d459 1
a459 1
    if (arg3 == NULL) 
d464 1
a464 1
                   "allowd for builtin seed source";
d498 1
d504 7
a510 1
    sc->szCertificateFile = cpPath;
d519 1
d525 21
a545 1
    sc->szKeyFile = cpPath;
d578 1
a578 1
        return ap_pstrcat(cmd->pool, "SSLCACertificateKeyFile: file '",
d591 28
d663 2
d679 28
a706 1
    else
d788 4
@


1.1.1.1
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@d2 4
a5 4
**  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
** | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
** | | | | | | (_) | (_| |   \__ \__ \ |  www.modssl.org
** |_| |_| |_|\___/ \__,_|___|___/___/_|  ftp.modssl.org
d12 1
a12 1
 * Copyright (c) 1998-2001 Ralf S. Engelschall. All rights reserved.
d30 1
a30 1
 *     mod_ssl project (http://www.modssl.org/)."
d45 1
a45 1
 *     mod_ssl project (http://www.modssl.org/)."
a87 3
#if defined(SSL_VENDOR) && defined(SSL_VENDOR_OBJS)
        ssl_vendor_register();
#endif
a100 3
#if defined(SSL_VENDOR) && defined(SSL_VENDOR_OBJS)
        ssl_vendor_unregister();
#endif
d124 1
a126 3
        mc->nSessionCacheDataSize  = 0;
        mc->pSessionCacheDataMM    = NULL;
        mc->tSessionCacheDataTable = NULL;
d132 1
a134 12
        mc->tTmpKeys               = ssl_ds_table_make(pPool, sizeof(ssl_asn1_t));
#ifdef SSL_EXPERIMENTAL_ENGINE
        mc->szCryptoDevice         = NULL;
#endif

        (void)memset(mc->pTmpKeys, 0, SSL_TKPIDX_MAX*sizeof(void *));

#ifdef SSL_VENDOR
        mc->ctx = ap_ctx_new(pPool);
        ap_hook_use("ap::mod_ssl::vendor::config_global_create",
                AP_HOOK_SIG2(void,ptr), AP_HOOK_MODE_ALL, mc);
#endif
d175 2
a178 1
    sc->szCertificateChain     = NULL;
d189 2
a191 27
    sc->szCARevocationPath     = NULL;
    sc->szCARevocationFile     = NULL;
    sc->pRevocationStore       = NULL;

#ifdef SSL_EXPERIMENTAL_PROXY
    sc->nProxyVerifyDepth             = UNSET;
    sc->szProxyCACertificatePath      = NULL;
    sc->szProxyCACertificateFile      = NULL;
    sc->szProxyClientCertificateFile  = NULL;
    sc->szProxyClientCertificatePath  = NULL;
    sc->szProxyCipherSuite            = NULL;
    sc->nProxyProtocol                = SSL_PROTOCOL_ALL & ~SSL_PROTOCOL_TLSV1;
    sc->bProxyVerify                  = UNSET;
    sc->pSSLProxyCtx                  = NULL;
#endif

    (void)memset(sc->szPublicCertFile, 0, SSL_AIDX_MAX*sizeof(char *));
    (void)memset(sc->szPrivateKeyFile, 0, SSL_AIDX_MAX*sizeof(char *));
    (void)memset(sc->pPublicCert, 0, SSL_AIDX_MAX*sizeof(X509 *));
    (void)memset(sc->pPrivateKey, 0, SSL_AIDX_MAX*sizeof(EVP_PKEY *));

#ifdef SSL_VENDOR
    sc->ctx = ap_ctx_new(p);
    ap_hook_use("ap::mod_ssl::vendor::config_server_create",
                AP_HOOK_SIG4(void,ptr,ptr,ptr), AP_HOOK_MODE_ALL,
                p, s, sc);
#endif
a203 1
    int i;
d206 2
a209 1
    cfgMergeString(szCertificateChain);
d220 2
a222 29
    cfgMerge(szCARevocationPath, NULL);
    cfgMerge(szCARevocationFile, NULL);
    cfgMerge(pRevocationStore, NULL);

    for (i = 0; i < SSL_AIDX_MAX; i++) {
        cfgMergeString(szPublicCertFile[i]);
        cfgMergeString(szPrivateKeyFile[i]);
        cfgMerge(pPublicCert[i], NULL);
        cfgMerge(pPrivateKey[i], NULL);
    }

#ifdef SSL_VENDOR
    cfgMergeCtx(ctx);
    ap_hook_use("ap::mod_ssl::vendor::config_server_merge",
                AP_HOOK_SIG5(void,ptr,ptr,ptr,ptr), AP_HOOK_MODE_ALL,
                p, base, add, new);
#endif

#ifdef SSL_EXPERIMENTAL_PROXY
    cfgMergeInt(nProxyVerifyDepth);
    cfgMergeString(szProxyCACertificatePath);
    cfgMergeString(szProxyCACertificateFile);
    cfgMergeString(szProxyClientCertificateFile);
    cfgMergeString(szProxyClientCertificatePath);
    cfgMergeString(szProxyCipherSuite);
    cfgMerge(nProxyProtocol, (SSL_PROTOCOL_ALL & ~SSL_PROTOCOL_TLSV1));
    cfgMergeBool(bProxyVerify);
    cfgMerge(pSSLProxyCtx, NULL);
#endif
d243 1
a243 1
#ifdef SSL_EXPERIMENTAL_PERDIRCA
a247 7
#ifdef SSL_VENDOR
    dc->ctx = ap_ctx_new(p);
    ap_hook_use("ap::mod_ssl::vendor::config_perdir_create",
                AP_HOOK_SIG4(void,ptr,ptr,ptr), AP_HOOK_MODE_ALL,
                p, dir, dc);
#endif

d278 1
a278 1
#ifdef SSL_EXPERIMENTAL_PERDIRCA
a282 7
#ifdef SSL_VENDOR
    cfgMergeCtx(ctx);
    ap_hook_use("ap::mod_ssl::vendor::config_perdir_merge",
                AP_HOOK_SIG5(void,ptr,ptr,ptr,ptr), AP_HOOK_MODE_ALL,
                p, base, add, new);
#endif

a316 1
#ifndef WIN32
d319 1
a319 1
                                      ssl_util_server_root_relative(cmd->pool, "mutex", arg+5),
a320 3
#else
        return "SSLMutex: Lockfiles not available on this platform";
#endif
d348 1
a348 1
        sc->szPassPhraseDialogPath = ssl_util_server_root_relative(cmd->pool, "dialog", arg+5);
a357 32
#ifdef SSL_EXPERIMENTAL_ENGINE
const char *ssl_cmd_SSLCryptoDevice(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLModConfigRec *mc = myModConfig();
    const char *err;
    ENGINE *e;
#if SSL_LIBRARY_VERSION >= 0x00907000
    static int loaded_engines = FALSE;

    /* early loading to make sure the engines are already 
       available for ENGINE_by_id() above... */
    if (!loaded_engines) {
        ENGINE_load_builtin_engines();
        loaded_engines = TRUE;
    }
#endif
    if ((err = ap_check_cmd_context(cmd, GLOBAL_ONLY)) != NULL)
        return err;
    if (strcEQ(arg, "builtin")) {
        mc->szCryptoDevice = NULL;
    }
    else if ((e = ENGINE_by_id(arg)) != NULL) {
        mc->szCryptoDevice = arg;
        ENGINE_free(e);
    }
    else
        return "SSLCryptoDevice: Invalid argument";
    return NULL;
}
#endif

d379 1
a379 1
        pRS->cpPath = ap_pstrdup(mc->pPool, ssl_util_server_root_relative(cmd->pool, "random", arg2+5));
d383 1
a383 6
        pRS->cpPath = ap_pstrdup(mc->pPool, ssl_util_server_root_relative(cmd->pool, "random", arg2+5));
    }
#if SSL_LIBRARY_VERSION >= 0x00905100
    else if (strlen(arg2) > 4 && strEQn(arg2, "egd:", 4)) {
        pRS->nSrc   = SSL_RSSRC_EGD;
        pRS->cpPath = ap_pstrdup(mc->pPool, ssl_util_server_root_relative(cmd->pool, "random", arg2+4));
a384 1
#endif
d391 1
a391 1
        pRS->cpPath = ap_pstrdup(mc->pPool, ssl_util_server_root_relative(cmd->pool, "random", arg2));
d397 1
a397 1
    if (arg3 == NULL)
d402 1
a402 1
                   "allowed for builtin seed source";
a435 1
    int i;
d437 1
a437 1
    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
d441 1
a441 7
    for (i = 0; i < SSL_AIDX_MAX && sc->szPublicCertFile[i] != NULL; i++)
        ;
    if (i == SSL_AIDX_MAX)
        return ap_psprintf(cmd->pool, "SSLCertificateFile: only up to %d "
                          "different certificates per virtual host allowed", 
                          SSL_AIDX_MAX);
    sc->szPublicCertFile[i] = cpPath;
a449 1
    int i;
d451 1
a451 1
    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
d455 1
a455 21
    for (i = 0; i < SSL_AIDX_MAX && sc->szPrivateKeyFile[i] != NULL; i++)
        ;
    if (i == SSL_AIDX_MAX)
        return ap_psprintf(cmd->pool, "SSLCertificateKeyFile: only up to %d "
                          "different private keys per virtual host allowed", 
                          SSL_AIDX_MAX);
    sc->szPrivateKeyFile[i] = cpPath;
    return NULL;
}

const char *ssl_cmd_SSLCertificateChainFile(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISREG|SSL_PCM_ISNONZERO, cpPath))
        return ap_pstrcat(cmd->pool, "SSLCertificateChainFile: file '",
                          cpPath, "' not exists or empty", NULL);
    sc->szCertificateChain = cpPath;
d465 1
a465 1
    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
d469 1
a469 1
#ifdef SSL_EXPERIMENTAL_PERDIRCA
d486 1
a486 1
    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
d488 1
a488 1
        return ap_pstrcat(cmd->pool, "SSLCACertificateFile: file '",
d490 1
a490 1
#ifdef SSL_EXPERIMENTAL_PERDIRCA
a500 28
const char *ssl_cmd_SSLCARevocationPath(
    cmd_parms *cmd, SSLDirConfigRec *dc, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISDIR, cpPath))
        return ap_pstrcat(cmd->pool, "SSLCARecocationPath: directory '",
                          cpPath, "' not exists", NULL);
    sc->szCARevocationPath = cpPath;
    return NULL;
}

const char *ssl_cmd_SSLCARevocationFile(
    cmd_parms *cmd, SSLDirConfigRec *dc, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISREG|SSL_PCM_ISNONZERO, cpPath))
        return ap_pstrcat(cmd->pool, "SSLCARevocationFile: file '",
                          cpPath, "' not exists or empty", NULL);
    sc->szCARevocationFile = cpPath;
    return NULL;
}

d505 1
a505 1
    ssl_verify_t id;
a544 2
    char *cp, *cp2;
    int maxsize;
d557 1
a557 1
                                     ssl_util_server_root_relative(cmd->pool, "scache", arg+4));
d559 1
a559 52
    else if (   (strlen(arg) > 4 && strcEQn(arg, "shm:",   4)) 
             || (strlen(arg) > 6 && strcEQn(arg, "shmht:", 6))) {
        if (!ap_mm_useable())
            return "SSLSessionCache: shared memory cache not useable on this platform";
        mc->nSessionCacheMode      = SSL_SCMODE_SHMHT;
        cp = strchr(arg, ':');
        mc->szSessionCacheDataFile = ap_pstrdup(mc->pPool,
                                     ssl_util_server_root_relative(cmd->pool, "scache", cp+1));
        mc->tSessionCacheDataTable = NULL;
        mc->nSessionCacheDataSize  = 1024*512; /* 512KB */
        if ((cp = strchr(mc->szSessionCacheDataFile, '(')) != NULL) {
            *cp++ = NUL;
            if ((cp2 = strchr(cp, ')')) == NULL)
                return "SSLSessionCache: Invalid argument: no closing parenthesis";
            *cp2 = NUL;
            mc->nSessionCacheDataSize = atoi(cp);
            if (mc->nSessionCacheDataSize <= 8192)
                return "SSLSessionCache: Invalid argument: size has to be >= 8192 bytes";
            maxsize = ap_mm_core_maxsegsize();
            if (mc->nSessionCacheDataSize >= maxsize)
                return ap_psprintf(cmd->pool, "SSLSessionCache: Invalid argument: "
                                   "size has to be < %d bytes on this platform", maxsize);
        }
    }
    else if (strlen(arg) > 6 && strcEQn(arg, "shmcb:", 6)) {
        if (!ap_mm_useable())
            return "SSLSessionCache: shared memory cache not useable on this platform";
        mc->nSessionCacheMode      = SSL_SCMODE_SHMCB;
        mc->szSessionCacheDataFile = ap_pstrdup(mc->pPool,
                                     ap_server_root_relative(cmd->pool, arg+6));
        mc->tSessionCacheDataTable = NULL;
        mc->nSessionCacheDataSize  = 1024*512; /* 512KB */
        if ((cp = strchr(mc->szSessionCacheDataFile, '(')) != NULL) {
            *cp++ = NUL;
            if ((cp2 = strchr(cp, ')')) == NULL)
                return "SSLSessionCache: Invalid argument: no closing parenthesis";
            *cp2 = NUL;
            mc->nSessionCacheDataSize = atoi(cp);
            if (mc->nSessionCacheDataSize <= 8192)
                return "SSLSessionCache: Invalid argument: size has to be >= 8192 bytes";
            maxsize = ap_mm_core_maxsegsize();
            if (mc->nSessionCacheDataSize >= maxsize)
                return ap_psprintf(cmd->pool, "SSLSessionCache: Invalid argument: "
                                   "size has to be < %d bytes on this platform", maxsize);
        }
    }
	else
#ifdef SSL_VENDOR
        if (!ap_hook_use("ap::mod_ssl::vendor::cmd_sslsessioncache",
             AP_HOOK_SIG4(void,ptr,ptr,ptr), AP_HOOK_MODE_ALL,
             cmd, arg, mc))
#endif
d635 1
a635 3
        if (strcEQ(w, "StdEnvVars"))
            opt = SSL_OPT_STDENVVARS;
        else if (strcEQ(w, "CompatEnvVars"))
a640 4
        else if (strcEQ(w, "StrictRequire"))
            opt = SSL_OPT_STRICTREQUIRE;
        else if (strcEQ(w, "OptRenegotiate"))
            opt = SSL_OPT_OPTRENEGOTIATE;
a721 130

#ifdef SSL_EXPERIMENTAL_PROXY

const char *ssl_cmd_SSLProxyProtocol(
    cmd_parms *cmd, char *struct_ptr, const char *opt)
{
    SSLSrvConfigRec *sc;
    ssl_proto_t options, thisopt;
    char action;
    char *w;

    sc = mySrvConfig(cmd->server);
    options = SSL_PROTOCOL_NONE;
    while (opt[0] != NUL) {
        w = ap_getword_conf(cmd->pool, &opt);

        action = NUL;
        if (*w == '+' || *w == '-')
            action = *(w++);

        if (strcEQ(w, "SSLv2"))
            thisopt = SSL_PROTOCOL_SSLV2;
        else if (strcEQ(w, "SSLv3"))
            thisopt = SSL_PROTOCOL_SSLV3;
        else if (strcEQ(w, "TLSv1"))
            thisopt = SSL_PROTOCOL_TLSV1;
        else if (strcEQ(w, "all"))
            thisopt = SSL_PROTOCOL_ALL;
        else
            return ap_pstrcat(cmd->pool, "SSLProxyProtocol: "
                              "Illegal protocol '", w, "'", NULL);
        if (action == '-')
            options &= ~thisopt;
        else if (action == '+')
            options |= thisopt;
        else
            options = thisopt;
    }
    sc->nProxyProtocol = options;
    return NULL;
}

const char *ssl_cmd_SSLProxyCipherSuite(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);

    sc->szProxyCipherSuite = arg;
    return NULL;
}

const char *ssl_cmd_SSLProxyVerify(
    cmd_parms *cmd, char *struct_ptr, int flag)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);

    sc->bProxyVerify = (flag ? TRUE : FALSE);
    return NULL;
}

const char *ssl_cmd_SSLProxyVerifyDepth(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    int d;

    d = atoi(arg);
    if (d < 0)
        return "SSLProxyVerifyDepth: Invalid argument";
    sc->nProxyVerifyDepth = d;
    return NULL;
}

const char *ssl_cmd_SSLProxyCACertificateFile(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISREG|SSL_PCM_ISNONZERO, cpPath))
        return ap_pstrcat(cmd->pool, "SSLProxyCACertificateFile: file '",
                          cpPath, "' not exists or empty", NULL);
    sc->szProxyCACertificateFile = cpPath;
    return NULL;
}

const char *ssl_cmd_SSLProxyCACertificatePath(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISDIR, cpPath))
        return ap_pstrcat(cmd->pool, "SSLProxyCACertificatePath: directory '",
                          cpPath, "' does not exists", NULL);
    sc->szProxyCACertificatePath = cpPath;
    return NULL;
}

const char *ssl_cmd_SSLProxyMachineCertificateFile(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISREG|SSL_PCM_ISNONZERO, cpPath))
        return ap_pstrcat(cmd->pool, "SSLProxyMachineCertFile: file '",
                          cpPath, "' not exists or empty", NULL);
    sc->szProxyClientCertificateFile = cpPath;
    return NULL;
}

const char *ssl_cmd_SSLProxyMachineCertificatePath(
    cmd_parms *cmd, char *struct_ptr, char *arg)
{
    SSLSrvConfigRec *sc = mySrvConfig(cmd->server);
    char *cpPath;

    cpPath = ssl_util_server_root_relative(cmd->pool, "certkey", arg);
    if (!ssl_util_path_check(SSL_PCM_EXISTS|SSL_PCM_ISDIR, cpPath))
        return ap_pstrcat(cmd->pool, "SSLProxyMachineCertPath: directory '",
                          cpPath, "' does not exists", NULL);
    sc->szProxyClientCertificatePath = cpPath;
    return NULL;
}

#endif /* SSL_EXPERIMENTAL_PROXY */
@


1.1.1.2
log
@import apache 1.3.27 and mod_ssl 2.8.12
@
text
@d759 1
a759 1
            if (mc->nSessionCacheDataSize < 8192)
d781 1
a781 1
            if (mc->nSessionCacheDataSize < 8192)
@


1.1.1.3
log
@import Apache 1.3.29 and mod_ssl 2.8.16
@
text
@d12 1
a12 1
 * Copyright (c) 1998-2003 Ralf S. Engelschall. All rights reserved.
@


