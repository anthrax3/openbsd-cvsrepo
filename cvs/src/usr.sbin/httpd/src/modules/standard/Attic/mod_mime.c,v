head	1.15;
access;
symbols
	OPENBSD_5_5:1.14.0.44
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.40
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.38
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.36
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.34
	OPENBSD_5_0:1.14.0.32
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.30
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.28
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.24
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.26
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.22
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.20
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.18
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.16
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.14
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.12
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.10
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.8
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.6
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.4
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.3
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.2
	apache_1_3_27:1.1.1.2
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.14;

1.14
date	2003.11.17.18.57.06;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.21.13.11.37;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.18.21.16.37;	author david;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.08.17.40.46;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.15.16.06.11;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.11.13.40.14;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.29.02.08.06;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.29.10.21.50;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.15.22.18.25;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.19.11.17.27;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.25.18.30.02;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.06.29.54;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.03.01.01.06.50;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.44;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.44;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.29.03;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.21.12.53.41;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.11.17.17.03.23;	author henning;	state Exp;
branches;
next	;


desc
@@


1.15
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*	$OpenBSD: mod_mime.c,v 1.14 2003/11/17 18:57:06 henning Exp $ */

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/*
 * http_mime.c: Sends/gets MIME headers for requests
 * 
 * Rob McCool
 * 
 */

#define MIME_PRIVATE

#include "httpd.h"
#include "http_config.h"
#include "http_log.h"
#include "http_main.h"

/*
 * isascii(c) isn't universal, and even those places where it is
 * defined it's not always right for our needs.  Roll our own that
 * we can rely on.
 */
#define ap_isascii(c) ((OS_ASC(c) & 0x80) == 0)

typedef struct attrib_info {
    char *name;
} attrib_info;

typedef struct {
    table *forced_types;        /* Additional AddTyped stuff */
    table *encoding_types;      /* Added with AddEncoding... */
    table *charset_types;	/* Added with AddCharset... */
    table *language_types;      /* Added with AddLanguage... */
    table *handlers;            /* Added with AddHandler...  */
    array_header *handlers_remove; /* List of handlers to remove */
    array_header *types_remove;	/* List of MIME types to remove */
    array_header *encodings_remove; /* List of encodings to remove */

    char *type;                 /* Type forced with ForceType  */
    char *handler;              /* Handler forced with SetHandler */
    char *default_language;     /* Language if no AddLanguage ext found */
} mime_dir_config;

typedef struct param_s {
    char *attr;
    char *val;
    struct param_s *next;
} param;

typedef struct {
    char *type;
    char *subtype;
    param *param;
} content_type;

static char tspecial[] = {
    '(', ')', '<', '>', '@@', ',', ';', ':',
    '\\', '"', '/', '[', ']', '?', '=',
    '\0'
};

module MODULE_VAR_EXPORT mime_module;

static void *create_mime_dir_config(pool *p, char *dummy)
{
    mime_dir_config *new =
    (mime_dir_config *) ap_palloc(p, sizeof(mime_dir_config));

    new->forced_types = ap_make_table(p, 4);
    new->encoding_types = ap_make_table(p, 4);
    new->charset_types = ap_make_table(p, 4);
    new->language_types = ap_make_table(p, 4);
    new->handlers = ap_make_table(p, 4);
    new->handlers_remove = ap_make_array(p, 4, sizeof(attrib_info));
    new->types_remove = ap_make_array(p, 4, sizeof(attrib_info));
    new->encodings_remove = ap_make_array(p, 4, sizeof(attrib_info));

    new->type = NULL;
    new->handler = NULL;
    new->default_language = NULL;

    return new;
}

static void *merge_mime_dir_configs(pool *p, void *basev, void *addv)
{
    mime_dir_config *base = (mime_dir_config *) basev;
    mime_dir_config *add = (mime_dir_config *) addv;
    mime_dir_config *new =
        (mime_dir_config *) ap_palloc(p, sizeof(mime_dir_config));
    int i;
    attrib_info *suffix;

    new->forced_types = ap_overlay_tables(p, add->forced_types,
					  base->forced_types);
    new->encoding_types = ap_overlay_tables(p, add->encoding_types,
					    base->encoding_types);
    new->charset_types = ap_overlay_tables(p, add->charset_types,
					   base->charset_types);
    new->language_types = ap_overlay_tables(p, add->language_types,
					    base->language_types);
    new->handlers = ap_overlay_tables(p, add->handlers,
				      base->handlers);

    suffix = (attrib_info *) add->handlers_remove->elts;
    for (i = 0; i < add->handlers_remove->nelts; i++) {
        ap_table_unset(new->handlers, suffix[i].name);
    }
    suffix = (attrib_info *) add->types_remove->elts;
    for (i = 0; i < add->types_remove->nelts; i++) {
        ap_table_unset(new->forced_types, suffix[i].name);
    }
    suffix = (attrib_info *) add->encodings_remove->elts;
    for (i = 0; i < add->encodings_remove->nelts; i++) {
        ap_table_unset(new->encoding_types, suffix[i].name);
    }

    new->type = add->type ? add->type : base->type;
    new->handler = add->handler ? add->handler : base->handler;
    new->default_language = add->default_language ?
        add->default_language : base->default_language;

    return new;
}

static const char *add_type(cmd_parms *cmd, mime_dir_config *m, char *ct,
                            char *ext)
{
    if (*ext == '.')
	++ext;
	
    ap_str_tolower(ct);
    ap_table_setn(m->forced_types, ext, ct);
    return NULL;
}

static const char *add_encoding(cmd_parms *cmd, mime_dir_config *m, char *enc,
                                char *ext)
{
    if (*ext == '.')
        ++ext;
    ap_str_tolower(enc);
    ap_table_setn(m->encoding_types, ext, enc);
    return NULL;
}

static const char *add_charset(cmd_parms *cmd, mime_dir_config *m,
			       char *charset, char *ext)
{
    if (*ext == '.') {
	++ext;
    }
    ap_str_tolower(charset);
    ap_table_setn(m->charset_types, ext, charset);
    return NULL;
}

static const char *add_language(cmd_parms *cmd, mime_dir_config *m, char *lang,
                                char *ext)
{
    if (*ext == '.') {
	++ext;
    }
    ap_str_tolower(lang);
    ap_table_setn(m->language_types, ext, lang);
    return NULL;
}

static const char *add_handler(cmd_parms *cmd, mime_dir_config *m, char *hdlr,
                               char *ext)
{
    if (*ext == '.')
        ++ext;
    ap_str_tolower(hdlr);
    ap_table_setn(m->handlers, ext, hdlr);
    return NULL;
}

/*
 * Note handler names that should be un-added for this location.  This
 * will keep the association from being inherited, as well, but not
 * from being re-added at a subordinate level.
 */
static const char *remove_handler(cmd_parms *cmd, void *m, char *ext)
{
    mime_dir_config *mcfg = (mime_dir_config *) m;
    attrib_info *suffix;

    if (*ext == '.') {
        ++ext;
    }
    suffix = (attrib_info *) ap_push_array(mcfg->handlers_remove);
    suffix->name = ap_pstrdup(cmd->pool, ext);
    return NULL;
}

/*
 * Just like the previous function, except that it records encoding
 * associations to be undone.
 */
static const char *remove_encoding(cmd_parms *cmd, void *m, char *ext)
{
    mime_dir_config *mcfg = (mime_dir_config *) m;
    attrib_info *suffix;

    if (*ext == '.') {
        ++ext;
    }
    suffix = (attrib_info *) ap_push_array(mcfg->encodings_remove);
    suffix->name = ap_pstrdup(cmd->pool, ext);
    return NULL;
}

/*
 * Similar to the previous functions, except that it deals with filename
 * suffix/MIME-type associations.
 */
static const char *remove_type(cmd_parms *cmd, void *m, char *ext)
{
    mime_dir_config *mcfg = (mime_dir_config *) m;
    attrib_info *suffix;

    if (*ext == '.') {
        ++ext;
    }
    suffix = (attrib_info *) ap_push_array(mcfg->types_remove);
    suffix->name = ap_pstrdup(cmd->pool, ext);
    return NULL;
}

/* The sole bit of server configuration that the MIME module has is
 * the name of its config file, so...
 */

static const char *set_types_config(cmd_parms *cmd, void *dummy, char *arg)
{
    ap_set_module_config(cmd->server->module_config, &mime_module, arg);
    return NULL;
}

static const command_rec mime_cmds[] =
{
    {"AddType", add_type, NULL, OR_FILEINFO, ITERATE2,
     "a mime type followed by one or more file extensions"},
    {"AddEncoding", add_encoding, NULL, OR_FILEINFO, ITERATE2,
     "an encoding (e.g., gzip), followed by one or more file extensions"},
    {"AddCharset", add_charset, NULL, OR_FILEINFO, ITERATE2,
     "a charset (e.g., iso-2022-jp), followed by one or more file extensions"},
    {"AddLanguage", add_language, NULL, OR_FILEINFO, ITERATE2,
     "a language (e.g., fr), followed by one or more file extensions"},
    {"AddHandler", add_handler, NULL, OR_FILEINFO, ITERATE2,
     "a handler name followed by one or more file extensions"},
    {"ForceType", ap_set_string_slot_lower, 
     (void *)XtOffsetOf(mime_dir_config, type), OR_FILEINFO, TAKE1, 
     "a media type"},
    {"RemoveHandler", remove_handler, NULL, OR_FILEINFO, ITERATE,
     "one or more file extensions"},
    {"RemoveEncoding", remove_encoding, NULL, OR_FILEINFO, ITERATE,
     "one or more file extensions"},
    {"RemoveType", remove_type, NULL, OR_FILEINFO, ITERATE,
     "one or more file extensions"},
    {"SetHandler", ap_set_string_slot_lower, 
     (void *)XtOffsetOf(mime_dir_config, handler), OR_FILEINFO, TAKE1, 
     "a handler name"},
    {"TypesConfig", set_types_config, NULL, RSRC_CONF, TAKE1,
     "the MIME types config file"},
    {"DefaultLanguage", ap_set_string_slot,
     (void*)XtOffsetOf(mime_dir_config, default_language), OR_FILEINFO, TAKE1,
     "language to use for documents with no other language file extension" },
    {NULL}
};

/* Hash table  --- only one of these per daemon; virtual hosts can
 * get private versions through AddType...
 */

#define MIME_HASHSIZE (32)
#define hash(i) (ap_tolower(i) % MIME_HASHSIZE)

static table *hash_buckets[MIME_HASHSIZE];

static void init_mime(server_rec *s, pool *p)
{
    configfile_t *f;
    char l[MAX_STRING_LEN];
    int x;
    char *types_confname = ap_get_module_config(s->module_config, &mime_module);

    if (!types_confname)
        types_confname = TYPES_CONFIG_FILE;

    types_confname = ap_server_root_relative(p, types_confname);

    ap_server_strip_chroot(types_confname, 0); /* only needed at restart */

    if (!(f = ap_pcfg_openfile(p, types_confname))) {
        ap_log_error(APLOG_MARK, APLOG_ERR, s,
		     "could not open mime types config file %s.", types_confname);
        exit(1);
    }

    for (x = 0; x < MIME_HASHSIZE; x++)
        hash_buckets[x] = ap_make_table(p, 10);

    while (!(ap_cfg_getline(l, MAX_STRING_LEN, f))) {
        const char *ll = l, *ct;

        if (l[0] == '#')
            continue;
        ct = ap_getword_conf(p, &ll);

        while (ll[0]) {
            char *ext = ap_getword_conf(p, &ll);
            ap_str_tolower(ext);   /* ??? */
            ap_table_setn(hash_buckets[hash(ext[0])], ext, ct);
        }
    }
    ap_cfg_closefile(f);
}

static char *zap_sp(char *s)
{
    char *tp;

    if (s == NULL) {
	return (NULL);
    }
    if (*s == '\0') {
	return (s);
    }

    /* delete prefixed white space */
    for (; *s == ' ' || *s == '\t' || *s == '\n'; s++);

    /* delete postfixed white space */
    for (tp = s; *tp != '\0'; tp++);
    for (tp--; tp != s && (*tp == ' ' || *tp == '\t' || *tp == '\n'); tp--) {
	*tp = '\0';
    }
    return (s);
}

static int is_token(int c)
{
    int res;

    res = (ap_isascii(c) && ap_isgraph(c)
	   && (strchr(tspecial, c) == NULL)) ? 1 : -1;
    return res;
}

static int is_qtext(int c)
{
    int res;

    res = (ap_isascii(c) && (c != '"') && (c != '\\') && (c != '\n'))
	? 1 : -1;
    return res;
}

static int is_quoted_pair(char *s)
{
    int res = -1;
    int c;

    if (((s + 1) != NULL) && (*s == '\\')) {
	c = (int) *(s + 1);
	if (ap_isascii(c)) {
	    res = 1;
	}
    }
    return (res);
}

static content_type *analyze_ct(pool *p, char *s)
{
    char *tp, *mp, *cp;
    char *attribute, *value;
    int quoted = 0;

    content_type *ctp;
    param *pp, *npp;

    /* initialize ctp */
    ctp = (content_type *) ap_palloc(p, sizeof(content_type));
    ctp->type = NULL;
    ctp->subtype = NULL;
    ctp->param = NULL;

    tp = ap_pstrdup(p, s);

    mp = tp;
    cp = mp;

    /* getting a type */
    if (!(cp = strchr(mp, '/'))) {
	ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
		     "mod_mime: analyze_ct: cannot get media type from '%s'",
		     mp);
	return (NULL);
    }
    ctp->type = ap_pstrndup(p, mp, cp - mp);
    ctp->type = zap_sp(ctp->type);
    if (ctp->type == NULL || *(ctp->type) == '\0' ||
	strchr(ctp->type, ';') || strchr(ctp->type, ' ') ||
	strchr(ctp->type, '\t')) {
	ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
		     "Cannot get media subtype.");
	return (NULL);
    }

    /* getting a subtype */
    cp++;
    mp = cp;

    for (; *cp != ';' && *cp != '\0'; cp++);
    ctp->subtype = ap_pstrndup(p, mp, cp - mp);
    ctp->subtype = zap_sp(ctp->subtype);
    if ((ctp->subtype == NULL) || (*(ctp->subtype) == '\0') ||
	strchr(ctp->subtype, ' ') || strchr(ctp->subtype, '\t')) {
	ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
		     "Cannot get media subtype.");
	return (NULL);
    }
    cp = zap_sp(cp);
    if (cp == NULL || *cp == '\0') {
	return (ctp);
    }

    /* getting parameters */
    cp++;
    cp = zap_sp(cp);
    if (cp == NULL || *cp == '\0') {
	ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
		     "Cannot get media parameter.");
	return (NULL);
    }
    mp = cp;
    attribute = NULL;
    value = NULL;

    while (cp != NULL && *cp != '\0') {
	if (attribute == NULL) {
	    if (is_token((int) *cp) > 0) {
		cp++;
		continue;
	    }
	    else if (*cp == ' ' || *cp == '\t' || *cp == '\n') {
		cp++;
		continue;
	    }
	    else if (*cp == '=') {
		attribute = ap_pstrndup(p, mp, cp - mp);
		attribute = zap_sp(attribute);
		if (attribute == NULL || *attribute == '\0') {
		    ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
				 "Cannot get media parameter.");
		    return (NULL);
		}
		cp++;
		cp = zap_sp(cp);
		if (cp == NULL || *cp == '\0') {
		    ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
				 "Cannot get media parameter.");
		    return (NULL);
		}
		mp = cp;
		continue;
	    }
	    else {
		ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
			     "Cannot get media parameter.");
		return (NULL);
	    }
	}
	else {
	    if (mp == cp) {
		if (*cp == '"') {
		    quoted = 1;
		    cp++;
		}
		else {
		    quoted = 0;
		}
	    }
	    if (quoted > 0) {
		while (quoted && *cp != '\0') {
		    if (is_qtext((int) *cp) > 0) {
			cp++;
		    }
		    else if (is_quoted_pair(cp) > 0) {
			cp += 2;
		    }
		    else if (*cp == '"') {
			cp++;
			while (*cp == ' ' || *cp == '\t' || *cp == '\n') {
			    cp++;
			}
			if (*cp != ';' && *cp != '\0') {
			    ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
					 "Cannot get media parameter.");
			    return(NULL);
			}
			quoted = 0;
		    }
		    else {
			ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
				     "Cannot get media parameter.");
			return (NULL);
		    }
		}
	    }
	    else {
		while (1) {
		    if (is_token((int) *cp) > 0) {
			cp++;
		    }
		    else if (*cp == '\0' || *cp == ';') {
			break;
		    }
		    else {
			ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
				     "Cannot get media parameter.");
			return (NULL);
		    }
		}
	    }
	    value = ap_pstrndup(p, mp, cp - mp);
	    value = zap_sp(value);
	    if (value == NULL || *value == '\0') {
		ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
			     "Cannot get media parameter.");
		return (NULL);
	    }

	    pp = ap_palloc(p, sizeof(param));
	    pp->attr = attribute;
	    pp->val = value;
	    pp->next = NULL;

	    if (ctp->param == NULL) {
		ctp->param = pp;
	    }
	    else {
		npp = ctp->param;
		while (npp->next) {
		    npp = npp->next;
		}
		npp->next = pp;
	    }
	    quoted = 0;
	    attribute = NULL;
	    value = NULL;
	    if (*cp == '\0') {
		break;
	    }
	    cp++;
	    mp = cp;
	}
    }
    return (ctp);
}

static int find_ct(request_rec *r)
{
    mime_dir_config *conf;
    array_header *exception_list;
    const char *fn;
    char *ext;
    const char *type;
    const char *charset = NULL;
    int found_metadata = 0;

    if (S_ISDIR(r->finfo.st_mode)) {
        r->content_type = DIR_MAGIC_TYPE;
        return OK;
    }

    conf = (mime_dir_config *) ap_get_module_config(r->per_dir_config, 
                                                    &mime_module);

    exception_list = ap_make_array(r->pool, 2, sizeof(char *));

    /* Always drop the leading element */
    fn = strrchr(r->filename, '/');
    if (fn == NULL)
	fn = r->filename;
    else
        ++fn;

    /* The exception list keeps track of those filename components that
     * are not associated with extensions indicating metadata.
     * The base name is always the first exception (i.e., "txt.html" has
     * a basename of "txt" even though it might look like an extension).
     */
    ext = ap_getword(r->pool, &fn, '.');
    *((const char **) ap_push_array(exception_list)) = ext;

    /* Parse filename extensions, which can be in any order */
    while ((ext = ap_getword(r->pool, &fn, '.')) && *ext) {
        int found = 0;

        /* Check for Content-Type */
        if ((type = ap_table_get(conf->forced_types, ext))
            || (type = ap_table_get(hash_buckets[hash(*ext)], ext))) {
            r->content_type = type;
            found = 1;
        }

	/* Add charset to Content-Type */
	if ((type = ap_table_get(conf->charset_types, ext))) {
	    charset = type;
	    found = 1;
	}

        /* Check for Content-Language */
        if ((type = ap_table_get(conf->language_types, ext))) {
            const char **new;

            r->content_language = type;         /* back compat. only */
            if (!r->content_languages)
                r->content_languages = ap_make_array(r->pool, 2, sizeof(char *));
            new = (const char **) ap_push_array(r->content_languages);
            *new = type;
            found = 1;
        }

        /* Check for Content-Encoding */
        if ((type = ap_table_get(conf->encoding_types, ext))) {
            if (!r->content_encoding)
                r->content_encoding = type;
            else
                r->content_encoding = ap_pstrcat(r->pool, r->content_encoding,
                                              ", ", type, NULL);
            found = 1;
        }

        /* Check for a special handler, but not for proxy request */
        if ((type = ap_table_get(conf->handlers, ext))
	    && r->proxyreq == NOT_PROXY) {
            r->handler = type;
            found = 1;
        }

        if (found)
            found_metadata = 1;
        else
            *((const char **) ap_push_array(exception_list)) = ext;
    }

    /* Need to see a notes entry on r for unrecognized elements.
     * Somebody better claim them! If we did absolutly nothing,
     * skip the notes to alert mod_negotiation we are clueless.
     */
    if (found_metadata) {
        ap_table_setn(r->notes, "ap-mime-exceptions-list",
                      (void *) exception_list);
    }

    if (r->content_type) {
	content_type *ctp;
	char *ct;
	size_t ctlen;
	int override = 0;

	ctlen = sizeof(char) * (strlen(r->content_type) + 1);
	ct = (char *) ap_palloc(r->pool, ctlen);
	strlcpy(ct, r->content_type, ctlen);

	if ((ctp = analyze_ct(r->pool, ct))) {
	    param *pp = ctp->param;
	    r->content_type = ap_pstrcat(r->pool, ctp->type, "/",
					 ctp->subtype, NULL);
	    while (pp != NULL) {
		if (charset && !strcmp(pp->attr, "charset")) {
		    if (!override) {
			r->content_type = ap_pstrcat(r->pool, r->content_type,
						     "; charset=", charset,
						     NULL);
			override = 1;
		    }
		}
		else {
		    r->content_type = ap_pstrcat(r->pool, r->content_type,
						 "; ", pp->attr,
						 "=", pp->val,
						 NULL);
		}
		pp = pp->next;
	    }
	    if (charset && !override) {
		r->content_type = ap_pstrcat(r->pool, r->content_type,
					     "; charset=", charset,
					     NULL);
	    }
	}
    }

    /* Set default language, if none was specified by the extensions
     * and we have a DefaultLanguage setting in force
     */

    if (!r->content_languages && conf->default_language) {
        const char **new;

        r->content_language = conf->default_language; /* back compat. only */
        if (!r->content_languages)
            r->content_languages = ap_make_array(r->pool, 2, sizeof(char *));
        new = (const char **) ap_push_array(r->content_languages);
        *new = conf->default_language;
    }

    /* Check for overrides with ForceType/SetHandler */

    if (conf->type && strcmp(conf->type, "none"))
        r->content_type = conf->type;
    if (conf->handler && strcmp(conf->handler, "none"))
        r->handler = conf->handler;

    if (!r->content_type)
        return DECLINED;

    return OK;
}

module MODULE_VAR_EXPORT mime_module =
{
    STANDARD_MODULE_STUFF,
    init_mime,                  /* initializer */
    create_mime_dir_config,     /* dir config creator */
    merge_mime_dir_configs,     /* dir config merger */
    NULL,                       /* server config */
    NULL,                       /* merge server config */
    mime_cmds,                  /* command table */
    NULL,                       /* handlers */
    NULL,                       /* filename translation */
    NULL,                       /* check_user_id */
    NULL,                       /* check auth */
    NULL,                       /* check access */
    find_ct,                    /* type_checker */
    NULL,                       /* fixups */
    NULL,                       /* logger */
    NULL,                       /* header parser */
    NULL,                       /* child_init */
    NULL,                       /* child_exit */
    NULL                        /* post read-request */
};
@


1.14
log
@merge apache 1.3.29 and mod_ssl 2.8.16
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_mime.c,v 1.13 2003/08/21 13:11:37 henning Exp $ */
@


1.13
log
@merge
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_mime.c,v 1.12 2003/07/18 21:16:37 david Exp $ */
d355 1
a355 1
		     "could not open mime types log file %s.", types_confname);
@


1.12
log
@#include "http_main.h" for the chroot functions
fixes some implicit declaration warnings
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_mime.c,v 1.11 2003/04/08 17:40:46 henning Exp $ */
d6 1
a6 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
@


1.11
log
@string stuff; ok pval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_mime.c,v 1.10 2002/08/15 16:06:11 henning Exp $ */
d73 1
@


1.10
log
@$OpenBSD$ for modules with local changes
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d719 1
d722 3
a724 3
	ct = (char *) ap_palloc(r->pool,
				sizeof(char) * (strlen(r->content_type) + 1));
	strcpy(ct, r->content_type);
@


1.9
log
@chroot aware
@
text
@d1 2
@


1.8
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d348 2
@


1.7
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d395 1
a395 1
static int is_token(char c)
d404 1
a404 1
static int is_qtext(char c)
d618 3
a620 3
    const char *fn = strrchr(r->filename, '/');
    mime_dir_config *conf =
    (mime_dir_config *) ap_get_module_config(r->per_dir_config, &mime_module);
a621 1
    const char *orighandler = r->handler;
d624 1
d631 4
a634 4
    /* TM -- FIXME
     * if r->filename does not contain a '/', the following passes a null
     * pointer to getword, causing a SEGV ..
     */
d636 3
a638 1
    if (fn == NULL) {
d640 10
a649 1
    }
d697 13
a709 13
        /* This is to deal with cases such as foo.gif.bak, which we want
         * to not have a type. So if we find an unknown extension, we
         * zap the type/language/encoding and reset the handler
         */

        if (!found) {
            r->content_type = NULL;
            r->content_language = NULL;
            r->content_languages = NULL;
            r->content_encoding = NULL;
            r->handler = orighandler;
	    charset = NULL;
	}
@


1.6
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1995-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 20
a38 23
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 7
a56 6
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
@


1.5
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d78 1
a78 1
typedef struct handlers_info {
d80 1
a80 1
} handlers_info;
d88 3
a90 1
    array_header *handlers_remove;     /* List of handlers to remove */
d127 3
a129 1
    new->handlers_remove = ap_make_array(p, 4, sizeof(handlers_info));
d145 1
a145 6
    handlers_info *hand;

    hand = (handlers_info *) add->handlers_remove->elts;
    for (i = 0; i < add->handlers_remove->nelts; i++) {
        ap_table_unset(base->handlers, hand[i].name);
    }
d148 1
a148 1
					 base->forced_types);
d150 1
a150 1
                                         base->encoding_types);
d154 1
a154 1
                                         base->language_types);
d156 14
a169 1
                                   base->handlers);
d240 35
a274 1
    handlers_info *hand;
d279 2
a280 2
    hand = (handlers_info *) ap_push_array(mcfg->handlers_remove);
    hand->name = ap_pstrdup(cmd->pool, ext);
d310 4
@


1.4
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d348 1
a348 1
    res = (ap_isascii(c) && isgraph(c)
@


1.3
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d71 7
d85 1
d95 18
d122 1
d149 1
a149 1
                                       base->forced_types);
d152 2
d167 1
a167 1
static const char *add_type(cmd_parms *cmd, mime_dir_config * m, char *ct,
d171 2
a172 1
        ++ext;
d178 1
a178 1
static const char *add_encoding(cmd_parms *cmd, mime_dir_config * m, char *enc,
d188 12
a199 1
static const char *add_language(cmd_parms *cmd, mime_dir_config * m, char *lang,
d202 3
a204 2
    if (*ext == '.')
        ++ext;
d210 1
a210 1
static const char *add_handler(cmd_parms *cmd, mime_dir_config * m, char *hdlr,
d254 2
d322 243
d573 1
d585 3
a587 2
    if (fn == NULL)
        fn = r->filename;
d600 6
d629 2
a630 1
        if ((type = ap_table_get(conf->handlers, ext)) && !r->proxyreq) {
d646 3
a648 1
        }
d650 36
@


1.2
log
@Apache 1.3.4 merge
@
text
@d236 2
a237 7
/* MIME_HASHSIZE used to be 27 (26 chars and one "non-alpha" slot), but
 * with character sets like EBCDIC, this is insufficient because the
 * range 'a'...'z' is not contigous. Defining it as ('z'-'a'+2) is
 * equivalent to 27 in ASCII, and makes it work in EBCDIC.
 */
#define MIME_HASHSIZE ('z'-'a'+2)
#define hash(i) (ap_isalpha(i) ? (ap_tolower(i)) - 'a' : (MIME_HASHSIZE-1))
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1995-1998 The Apache Group.  All rights reserved.
d71 4
d80 1
d84 1
d98 1
d102 1
d112 8
a119 1
    (mime_dir_config *) ap_palloc(p, sizeof(mime_dir_config));
d132 2
d178 18
d219 2
d226 3
d260 1
a260 1
		     "httpd: could not open mime types log file %s.", types_confname);
d357 14
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 9
a24 6
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
d26 3
a28 4
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
d30 4
a33 3
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
d35 4
a38 4
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 5
a54 3
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
a55 3
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
a70 11
/*
 * isascii(c) isn't universal, and even those places where it is
 * defined it's not always right for our needs.  Roll our own that
 * we can rely on.
 */
#define ap_isascii(c) ((OS_ASC(c) & 0x80) == 0)

typedef struct attrib_info {
    char *name;
} attrib_info;

a73 1
    table *charset_types;	/* Added with AddCharset... */
a75 3
    array_header *handlers_remove; /* List of handlers to remove */
    array_header *types_remove;	/* List of MIME types to remove */
    array_header *encodings_remove; /* List of encodings to remove */
a78 1
    char *default_language;     /* Language if no AddLanguage ext found */
a80 18
typedef struct param_s {
    char *attr;
    char *val;
    struct param_s *next;
} param;

typedef struct {
    char *type;
    char *subtype;
    param *param;
} content_type;

static char tspecial[] = {
    '(', ')', '<', '>', '@@', ',', ';', ':',
    '\\', '"', '/', '[', ']', '?', '=',
    '\0'
};

a89 1
    new->charset_types = ap_make_table(p, 4);
a91 3
    new->handlers_remove = ap_make_array(p, 4, sizeof(attrib_info));
    new->types_remove = ap_make_array(p, 4, sizeof(attrib_info));
    new->encodings_remove = ap_make_array(p, 4, sizeof(attrib_info));
a94 1
    new->default_language = NULL;
d104 1
a104 3
        (mime_dir_config *) ap_palloc(p, sizeof(mime_dir_config));
    int i;
    attrib_info *suffix;
d107 1
a107 1
					  base->forced_types);
d109 1
a109 3
					    base->encoding_types);
    new->charset_types = ap_overlay_tables(p, add->charset_types,
					   base->charset_types);
d111 1
a111 1
					    base->language_types);
d113 1
a113 14
				      base->handlers);

    suffix = (attrib_info *) add->handlers_remove->elts;
    for (i = 0; i < add->handlers_remove->nelts; i++) {
        ap_table_unset(new->handlers, suffix[i].name);
    }
    suffix = (attrib_info *) add->types_remove->elts;
    for (i = 0; i < add->types_remove->nelts; i++) {
        ap_table_unset(new->forced_types, suffix[i].name);
    }
    suffix = (attrib_info *) add->encodings_remove->elts;
    for (i = 0; i < add->encodings_remove->nelts; i++) {
        ap_table_unset(new->encoding_types, suffix[i].name);
    }
a116 2
    new->default_language = add->default_language ?
        add->default_language : base->default_language;
d121 1
a121 1
static const char *add_type(cmd_parms *cmd, mime_dir_config *m, char *ct,
d125 1
a125 2
	++ext;
	
d131 1
a131 1
static const char *add_encoding(cmd_parms *cmd, mime_dir_config *m, char *enc,
d141 1
a141 12
static const char *add_charset(cmd_parms *cmd, mime_dir_config *m,
			       char *charset, char *ext)
{
    if (*ext == '.') {
	++ext;
    }
    ap_str_tolower(charset);
    ap_table_setn(m->charset_types, ext, charset);
    return NULL;
}

static const char *add_language(cmd_parms *cmd, mime_dir_config *m, char *lang,
d144 2
a145 3
    if (*ext == '.') {
	++ext;
    }
d151 1
a151 1
static const char *add_handler(cmd_parms *cmd, mime_dir_config *m, char *hdlr,
a160 52
/*
 * Note handler names that should be un-added for this location.  This
 * will keep the association from being inherited, as well, but not
 * from being re-added at a subordinate level.
 */
static const char *remove_handler(cmd_parms *cmd, void *m, char *ext)
{
    mime_dir_config *mcfg = (mime_dir_config *) m;
    attrib_info *suffix;

    if (*ext == '.') {
        ++ext;
    }
    suffix = (attrib_info *) ap_push_array(mcfg->handlers_remove);
    suffix->name = ap_pstrdup(cmd->pool, ext);
    return NULL;
}

/*
 * Just like the previous function, except that it records encoding
 * associations to be undone.
 */
static const char *remove_encoding(cmd_parms *cmd, void *m, char *ext)
{
    mime_dir_config *mcfg = (mime_dir_config *) m;
    attrib_info *suffix;

    if (*ext == '.') {
        ++ext;
    }
    suffix = (attrib_info *) ap_push_array(mcfg->encodings_remove);
    suffix->name = ap_pstrdup(cmd->pool, ext);
    return NULL;
}

/*
 * Similar to the previous functions, except that it deals with filename
 * suffix/MIME-type associations.
 */
static const char *remove_type(cmd_parms *cmd, void *m, char *ext)
{
    mime_dir_config *mcfg = (mime_dir_config *) m;
    attrib_info *suffix;

    if (*ext == '.') {
        ++ext;
    }
    suffix = (attrib_info *) ap_push_array(mcfg->types_remove);
    suffix->name = ap_pstrdup(cmd->pool, ext);
    return NULL;
}

a176 2
    {"AddCharset", add_charset, NULL, OR_FILEINFO, ITERATE2,
     "a charset (e.g., iso-2022-jp), followed by one or more file extensions"},
a183 6
    {"RemoveHandler", remove_handler, NULL, OR_FILEINFO, ITERATE,
     "one or more file extensions"},
    {"RemoveEncoding", remove_encoding, NULL, OR_FILEINFO, ITERATE,
     "one or more file extensions"},
    {"RemoveType", remove_type, NULL, OR_FILEINFO, ITERATE,
     "one or more file extensions"},
a188 3
    {"DefaultLanguage", ap_set_string_slot,
     (void*)XtOffsetOf(mime_dir_config, default_language), OR_FILEINFO, TAKE1,
     "language to use for documents with no other language file extension" },
d196 7
a202 2
#define MIME_HASHSIZE (32)
#define hash(i) (ap_tolower(i) % MIME_HASHSIZE)
d220 1
a220 1
		     "could not open mime types log file %s.", types_confname);
a242 243
static char *zap_sp(char *s)
{
    char *tp;

    if (s == NULL) {
	return (NULL);
    }
    if (*s == '\0') {
	return (s);
    }

    /* delete prefixed white space */
    for (; *s == ' ' || *s == '\t' || *s == '\n'; s++);

    /* delete postfixed white space */
    for (tp = s; *tp != '\0'; tp++);
    for (tp--; tp != s && (*tp == ' ' || *tp == '\t' || *tp == '\n'); tp--) {
	*tp = '\0';
    }
    return (s);
}

static int is_token(int c)
{
    int res;

    res = (ap_isascii(c) && ap_isgraph(c)
	   && (strchr(tspecial, c) == NULL)) ? 1 : -1;
    return res;
}

static int is_qtext(int c)
{
    int res;

    res = (ap_isascii(c) && (c != '"') && (c != '\\') && (c != '\n'))
	? 1 : -1;
    return res;
}

static int is_quoted_pair(char *s)
{
    int res = -1;
    int c;

    if (((s + 1) != NULL) && (*s == '\\')) {
	c = (int) *(s + 1);
	if (ap_isascii(c)) {
	    res = 1;
	}
    }
    return (res);
}

static content_type *analyze_ct(pool *p, char *s)
{
    char *tp, *mp, *cp;
    char *attribute, *value;
    int quoted = 0;

    content_type *ctp;
    param *pp, *npp;

    /* initialize ctp */
    ctp = (content_type *) ap_palloc(p, sizeof(content_type));
    ctp->type = NULL;
    ctp->subtype = NULL;
    ctp->param = NULL;

    tp = ap_pstrdup(p, s);

    mp = tp;
    cp = mp;

    /* getting a type */
    if (!(cp = strchr(mp, '/'))) {
	ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
		     "mod_mime: analyze_ct: cannot get media type from '%s'",
		     mp);
	return (NULL);
    }
    ctp->type = ap_pstrndup(p, mp, cp - mp);
    ctp->type = zap_sp(ctp->type);
    if (ctp->type == NULL || *(ctp->type) == '\0' ||
	strchr(ctp->type, ';') || strchr(ctp->type, ' ') ||
	strchr(ctp->type, '\t')) {
	ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
		     "Cannot get media subtype.");
	return (NULL);
    }

    /* getting a subtype */
    cp++;
    mp = cp;

    for (; *cp != ';' && *cp != '\0'; cp++);
    ctp->subtype = ap_pstrndup(p, mp, cp - mp);
    ctp->subtype = zap_sp(ctp->subtype);
    if ((ctp->subtype == NULL) || (*(ctp->subtype) == '\0') ||
	strchr(ctp->subtype, ' ') || strchr(ctp->subtype, '\t')) {
	ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
		     "Cannot get media subtype.");
	return (NULL);
    }
    cp = zap_sp(cp);
    if (cp == NULL || *cp == '\0') {
	return (ctp);
    }

    /* getting parameters */
    cp++;
    cp = zap_sp(cp);
    if (cp == NULL || *cp == '\0') {
	ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
		     "Cannot get media parameter.");
	return (NULL);
    }
    mp = cp;
    attribute = NULL;
    value = NULL;

    while (cp != NULL && *cp != '\0') {
	if (attribute == NULL) {
	    if (is_token((int) *cp) > 0) {
		cp++;
		continue;
	    }
	    else if (*cp == ' ' || *cp == '\t' || *cp == '\n') {
		cp++;
		continue;
	    }
	    else if (*cp == '=') {
		attribute = ap_pstrndup(p, mp, cp - mp);
		attribute = zap_sp(attribute);
		if (attribute == NULL || *attribute == '\0') {
		    ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
				 "Cannot get media parameter.");
		    return (NULL);
		}
		cp++;
		cp = zap_sp(cp);
		if (cp == NULL || *cp == '\0') {
		    ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
				 "Cannot get media parameter.");
		    return (NULL);
		}
		mp = cp;
		continue;
	    }
	    else {
		ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
			     "Cannot get media parameter.");
		return (NULL);
	    }
	}
	else {
	    if (mp == cp) {
		if (*cp == '"') {
		    quoted = 1;
		    cp++;
		}
		else {
		    quoted = 0;
		}
	    }
	    if (quoted > 0) {
		while (quoted && *cp != '\0') {
		    if (is_qtext((int) *cp) > 0) {
			cp++;
		    }
		    else if (is_quoted_pair(cp) > 0) {
			cp += 2;
		    }
		    else if (*cp == '"') {
			cp++;
			while (*cp == ' ' || *cp == '\t' || *cp == '\n') {
			    cp++;
			}
			if (*cp != ';' && *cp != '\0') {
			    ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
					 "Cannot get media parameter.");
			    return(NULL);
			}
			quoted = 0;
		    }
		    else {
			ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
				     "Cannot get media parameter.");
			return (NULL);
		    }
		}
	    }
	    else {
		while (1) {
		    if (is_token((int) *cp) > 0) {
			cp++;
		    }
		    else if (*cp == '\0' || *cp == ';') {
			break;
		    }
		    else {
			ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
				     "Cannot get media parameter.");
			return (NULL);
		    }
		}
	    }
	    value = ap_pstrndup(p, mp, cp - mp);
	    value = zap_sp(value);
	    if (value == NULL || *value == '\0') {
		ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
			     "Cannot get media parameter.");
		return (NULL);
	    }

	    pp = ap_palloc(p, sizeof(param));
	    pp->attr = attribute;
	    pp->val = value;
	    pp->next = NULL;

	    if (ctp->param == NULL) {
		ctp->param = pp;
	    }
	    else {
		npp = ctp->param;
		while (npp->next) {
		    npp = npp->next;
		}
		npp->next = pp;
	    }
	    quoted = 0;
	    attribute = NULL;
	    value = NULL;
	    if (*cp == '\0') {
		break;
	    }
	    cp++;
	    mp = cp;
	}
    }
    return (ctp);
}

d245 3
a247 3
    mime_dir_config *conf;
    array_header *exception_list;
    const char *fn;
d249 1
a250 2
    const char *charset = NULL;
    int found_metadata = 0;
d257 4
a260 4
    conf = (mime_dir_config *) ap_get_module_config(r->per_dir_config, 
                                                    &mime_module);

    exception_list = ap_make_array(r->pool, 2, sizeof(char *));
a261 2
    /* Always drop the leading element */
    fn = strrchr(r->filename, '/');
d263 1
a263 11
	fn = r->filename;
    else
        ++fn;

    /* The exception list keeps track of those filename components that
     * are not associated with extensions indicating metadata.
     * The base name is always the first exception (i.e., "txt.html" has
     * a basename of "txt" even though it might look like an extension).
     */
    ext = ap_getword(r->pool, &fn, '.');
    *((const char **) ap_push_array(exception_list)) = ext;
a275 6
	/* Add charset to Content-Type */
	if ((type = ap_table_get(conf->charset_types, ext))) {
	    charset = type;
	    found = 1;
	}

d299 1
a299 2
        if ((type = ap_table_get(conf->handlers, ext))
	    && r->proxyreq == NOT_PROXY) {
d304 12
a315 59
        if (found)
            found_metadata = 1;
        else
            *((const char **) ap_push_array(exception_list)) = ext;
    }

    /* Need to see a notes entry on r for unrecognized elements.
     * Somebody better claim them! If we did absolutly nothing,
     * skip the notes to alert mod_negotiation we are clueless.
     */
    if (found_metadata) {
        ap_table_setn(r->notes, "ap-mime-exceptions-list",
                      (void *) exception_list);
    }

    if (r->content_type) {
	content_type *ctp;
	char *ct;
	int override = 0;

	ct = (char *) ap_palloc(r->pool,
				sizeof(char) * (strlen(r->content_type) + 1));
	strcpy(ct, r->content_type);

	if ((ctp = analyze_ct(r->pool, ct))) {
	    param *pp = ctp->param;
	    r->content_type = ap_pstrcat(r->pool, ctp->type, "/",
					 ctp->subtype, NULL);
	    while (pp != NULL) {
		if (charset && !strcmp(pp->attr, "charset")) {
		    if (!override) {
			r->content_type = ap_pstrcat(r->pool, r->content_type,
						     "; charset=", charset,
						     NULL);
			override = 1;
		    }
		}
		else {
		    r->content_type = ap_pstrcat(r->pool, r->content_type,
						 "; ", pp->attr,
						 "=", pp->val,
						 NULL);
		}
		pp = pp->next;
	    }
	    if (charset && !override) {
		r->content_type = ap_pstrcat(r->pool, r->content_type,
					     "; charset=", charset,
					     NULL);
	    }
	}
    }

    /* Set default language, if none was specified by the extensions
     * and we have a DefaultLanguage setting in force
     */

    if (!r->content_languages && conf->default_language) {
        const char **new;
a316 5
        r->content_language = conf->default_language; /* back compat. only */
        if (!r->content_languages)
            r->content_languages = ap_make_array(r->pool, 2, sizeof(char *));
        new = (const char **) ap_push_array(r->content_languages);
        *new = conf->default_language;
@


1.1.1.3
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
@


1.1.1.4
log
@import Apache 1.3.29 and mod_ssl 2.8.16
@
text
@d350 1
a350 1
		     "could not open mime types config file %s.", types_confname);
@


