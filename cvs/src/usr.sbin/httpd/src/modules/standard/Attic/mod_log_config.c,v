head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.8
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.4
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.16
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.14
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.12
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.10
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.8
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.6
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.4
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.4
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.3
	apache_1_3_27:1.1.1.3
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.20;

1.20
date	2013.01.06.22.06.54;	author martynas;	state Exp;
branches;
next	1.19;

1.19
date	2010.02.25.07.49.53;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2008.10.03.19.36.36;	author mbalmer;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.09.12.13.10;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.02.19.42.48;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.15.12.17.18;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.21.13.11.36;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.18.21.16.37;	author david;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.19.21.31.16;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.17.11.19.10;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.29.02.08.06;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.29.10.21.49;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.15.22.18.24;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.19.11.17.27;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.25.18.30.02;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	99.09.29.06.29.54;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.03.01.04.29.08;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.01.06.47;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	98.10.11.19.45.17;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.43;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.43;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.29.02;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.07.19.48.13;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.21.12.53.41;	author henning;	state Exp;
branches;
next	;


desc
@@


1.21
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*	$OpenBSD: mod_log_config.c,v 1.20 2013/01/06 22:06:54 martynas Exp $ */

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/*
 * Modified by djm@@va.pubnix.com:
 * If no TransferLog is given explicitly, decline to log.
 *
 * This is module implements the TransferLog directive (same as the
 * common log module), and additional directives, LogFormat and CustomLog.
 *
 *
 * Syntax:
 *
 *    TransferLog fn      Logs transfers to fn in standard log format, unless
 *                        a custom format is set with LogFormat
 *    LogFormat format    Set a log format from TransferLog files
 *    CustomLog fn format
 *                        Log to file fn with format given by the format
 *                        argument
 *
 *    CookieLog fn        For backwards compatibility with old Cookie
 *                        logging module - now deprecated.
 *
 * There can be any number of TransferLog and CustomLog
 * commands. Each request will be logged to _ALL_ the
 * named files, in the appropriate format.
 *
 * If no TransferLog or CustomLog directive appears in a VirtualHost,
 * the request will be logged to the log file(s) defined outside
 * the virtual host section. If a TransferLog or CustomLog directive
 * appears in the VirtualHost section, the log files defined outside
 * the VirtualHost will _not_ be used. This makes this module compatible
 * with the CLF and config log modules, where the use of TransferLog
 * inside the VirtualHost section overrides its use outside.
 *
 * Examples:
 *
 *    TransferLog    logs/access_log
 *    <VirtualHost>
 *    LogFormat      "... custom format ..."
 *    TransferLog    log/virtual_only
 *    CustomLog      log/virtual_useragents "%t %{user-agent}i"
 *    </VirtualHost>
 *
 * This will log using CLF to access_log any requests handled by the
 * main server, while any requests to the virtual host will be logged
 * with the "... custom format..." to virtual_only _AND_ using
 * the custom user-agent log to virtual_useragents.
 *
 * Note that the NCSA referer and user-agent logs are easily added with
 * CustomLog:
 *   CustomLog   logs/referer  "%{referer}i -> %U"
 *   CustomLog   logs/agent    "%{user-agent}i"
 *
 * RefererIgnore functionality can be obtained with conditional
 * logging (SetEnvIf and CustomLog ... env=!VAR).
 *
 * But using this method allows much easier modification of the
 * log format, e.g. to log hosts along with UA:
 *   CustomLog   logs/referer "%{referer}i %U %h"
 *
 * The argument to LogFormat and CustomLog is a string, which can include
 * literal characters copied into the log files, and '%' directives as
 * follows:
 *
 * %...B:  bytes sent, excluding HTTP headers.
 * %...b:  bytes sent, excluding HTTP headers in CLF format, i.e. a '-'
 *         when no bytes where sent (rather than a '0'.
 * %...c:  Status of the connection.
 *         'X' = connection aborted before the response completed.
 *         '+' = connection may be kept alive after the response is sent.
 *         '-' = connection will be closed after the response is sent.
 * %...{FOOBAR}e:  The contents of the environment variable FOOBAR
 * %...f:  filename
 * %...h:  remote host
 * %...a:  remote IP-address
 * %...A:  local IP-address
 * %...{Foobar}i:  The contents of Foobar: header line(s) in the request
 *                 sent to the client.
 * %...l:  remote logname (from identd, if supplied)
 * %...{Foobar}n:  The contents of note "Foobar" from another module.
 * %...{Foobar}o:  The contents of Foobar: header line(s) in the reply.
 * %...p:  the port the request was served to
 * %...P:  the process ID of the child that serviced the request.
 * %...r:  first line of request
 * %...s:  status.  For requests that got internally redirected, this
 *         is status of the *original* request --- %...>s for the last.
 * %...t:  time, in common log format time format
 * %...{format}t:  The time, in the form given by format, which should
 *                 be in strftime(3) format.
 * %...T:  the time taken to serve the request, in seconds.
 * %...u:  remote user (from auth; may be bogus if return status (%s) is 401)
 * %...U:  the URL path requested.
 * %...v:  the configured name of the server (i.e. which virtual host?)
 * %...V:  the server name according to the UseCanonicalName setting
 * %...m:  the request method
 * %...H:  the request protocol
 * %...q:  the query string prepended by "?", or empty if no query string
 *
 * The '...' can be nothing at all (e.g. "%h %u %r %s %b"), or it can
 * indicate conditions for inclusion of the item (which will cause it
 * to be replaced with '-' if the condition is not met).  Note that
 * there is no escaping performed on the strings from %r, %...i and
 * %...o; some with long memories may remember that I thought this was
 * a bad idea, once upon a time, and I'm still not comfortable with
 * it, but it is difficult to see how to "do the right thing" with all
 * of '%..i', unless we URL-escape everything and break with CLF.
 *
 * The forms of condition are a list of HTTP status codes, which may
 * or may not be preceded by '!'.  Thus, '%400,501{User-agent}i' logs
 * User-agent: on 400 errors and 501 errors (Bad Request, Not
 * Implemented) only; '%!200,304,302{Referer}i' logs Referer: on all
 * requests which did *not* return some sort of normal status.
 *
 * The default LogFormat reproduces CLF; see below.
 *
 * The way this is supposed to work with virtual hosts is as follows:
 * a virtual host can have its own LogFormat, or its own TransferLog.
 * If it doesn't have its own LogFormat, it inherits from the main
 * server.  If it doesn't have its own TransferLog, it writes to the
 * same descriptor (meaning the same process for "| ...").
 *
 * --- rst */

#define DEFAULT_LOG_FORMAT "%h %l %u %t \"%r\" %>s %b"

#include "httpd.h"
#include "http_config.h"
#include "http_core.h"		/* For REMOTE_NAME */
#include "http_log.h"
#include "http_main.h"
#include "fdcache.h"
#include <limits.h>

module MODULE_VAR_EXPORT config_log_module;

static int xfer_flags = (O_WRONLY | O_APPEND | O_CREAT);
static mode_t xfer_mode = (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);

/* POSIX.1 defines PIPE_BUF as the maximum number of bytes that is
 * guaranteed to be atomic when writing a pipe.  And PIPE_BUF >= 512
 * is guaranteed.  So we'll just guess 512 in the event the system
 * doesn't have this.  Now, for file writes there is actually no limit,
 * the entire write is atomic.  Whether all systems implement this
 * correctly is another question entirely ... so we'll just use PIPE_BUF
 * because it's probably a good guess as to what is implemented correctly
 * everywhere.
 */
#ifdef PIPE_BUF
#define LOG_BUFSIZE     PIPE_BUF
#else
#define LOG_BUFSIZE     (512)
#endif

/*
 * multi_log_state is our per-(virtual)-server configuration. We store
 * an array of the logs we are going to use, each of type config_log_state.
 * If a default log format is given by LogFormat, store in default_format
 * (backward compat. with mod_log_config).  We also store for each virtual
 * server a pointer to the logs specified for the main server, so that if this
 * vhost has no logs defined, we can use the main server's logs instead.
 *
 * So, for the main server, config_logs contains a list of the log files
 * and server_config_logs in empty. For a vhost, server_config_logs
 * points to the same array as config_logs in the main server, and
 * config_logs points to the array of logs defined inside this vhost,
 * which might be empty.
 */
typedef struct {
	char		*default_format_string;
	array_header	*default_format;
	array_header	*config_logs;
	array_header	*server_config_logs;
	table		*formats;
} multi_log_state;

/*
 * config_log_state holds the status of a single log file. fname might
 * be NULL, which means this module does no logging for this
 * request. format might be NULL, in which case the default_format
 * from the multi_log_state should be used, or if that is NULL as
 * well, use the CLF. log_fd is -1 before the log file is opened and
 * set to a valid fd after it is opened.
 */
typedef struct {
	char		*fname;
	char		*format_string;
	array_header	*format;
	int		 log_fd;
	char		*condition_var;
#ifdef BUFFERED_LOGS
	int		 outcnt;
	char		 outbuf[LOG_BUFSIZE];
#endif
} config_log_state;

/*
 * Format items...
 * Note that many of these could have ap_sprintfs replaced with static buffers.
 */
typedef const char *(*item_key_func) (request_rec *, char *);

typedef struct {
	char		 ch;
	item_key_func	 func;
	char		*arg;
	int		 condition_sense;
	int		 want_orig;
	array_header	*conditions;
} log_format_item;

static char *
format_integer(pool *p, int i)
{
	return ap_psprintf(p, "%d", i);
}

static char *
pfmt(pool *p, int i)
{
	if (i <= 0)
		return "-";
	else
		return format_integer(p, i);
}

static const char *
constant_item(request_rec *dummy, char *stuff)
{
	return stuff;
}

static const char *
log_remote_host(request_rec *r, char *a)
{
	return ap_escape_logitem(r->pool, ap_get_remote_host(r->connection,
	    r->per_dir_config, REMOTE_NAME));
}

static const char *
log_remote_address(request_rec *r, char *a)
{
	return r->connection->remote_ip;
}

static const char *
log_local_address(request_rec *r, char *a)
{
	return r->connection->local_ip;
}

static const char *
log_remote_logname(request_rec *r, char *a)
{
	return ap_escape_logitem(r->pool, ap_get_remote_logname(r));
}

static const char *
log_remote_user(request_rec *r, char *a)
{
	char *rvalue = r->connection->user;

	if (rvalue == NULL)
		rvalue = "-";
	else if (strlen(rvalue) == 0)
		rvalue = "\"\"";
	else
		rvalue = ap_escape_logitem(r->pool, rvalue);
	return rvalue;
}

static const char *
log_request_line(request_rec *r, char *a)
{
	/*
         * NOTE: If the original request contained a password, we re-write the
         * request line here to contain XXXXXX instead: (note the truncation
         * before the protocol string for HTTP/0.9 requests) (note also that
         * r->the_request contains the unmodified request)
         */
	return ap_escape_logitem(r->pool,
	      (r->parsed_uri.password) ? ap_pstrcat(r->pool, r->method, " ",
		      ap_unparse_uri_components(r->pool, &r->parsed_uri, 0),
			    r->assbackwards ? NULL : " ", r->protocol, NULL)
				 : r->the_request
	);
}

static const char *
log_request_file(request_rec *r, char *a)
{
	return r->filename;
}

static const char *
log_request_uri(request_rec *r, char *a)
{
	return ap_escape_logitem(r->pool, r->uri);
}

static const char *
log_request_method(request_rec *r, char *a)
{
	return ap_escape_logitem(r->pool, r->method);
}

static const char *log_request_protocol(request_rec *r, char *a)
{
	return ap_escape_logitem(r->pool, r->protocol);
}

static const char *log_request_query(request_rec *r, char *a)
{
	return (r->args != NULL) ? ap_pstrcat(r->pool, "?",
	    ap_escape_logitem(r->pool, r->args), NULL)
	    : "";
}

static const char *
log_status(request_rec *r, char *a)
{
	return pfmt(r->pool, r->status);
}

static const char *
clf_log_bytes_sent(request_rec *r, char *a)
{
	if (!r->sent_bodyct)
		return "-";
	else {
		off_t bs;
		ap_bgetopt(r->connection->client, BO_BYTECT, &bs);
		return ap_psprintf(r->pool, "%qd", bs);
	}
}

static const char *
log_bytes_sent(request_rec *r, char *a)
{
	if (!r->sent_bodyct)
		return "0";
	else {
		off_t bs;
		ap_bgetopt(r->connection->client, BO_BYTECT, &bs);
		return ap_psprintf(r->pool, "%qd", bs);
	}
}

static const char *
log_header_in(request_rec *r, char *a)
{
	return ap_escape_logitem(r->pool, ap_table_get(r->headers_in, a));
}

static const char *
log_header_out(request_rec *r, char *a)
{
	const char *cp = ap_table_get(r->headers_out, a);

	if (!strcasecmp(a, "Content-type") && r->content_type)
		cp = ap_field_noparam(r->pool, r->content_type);

	if (cp)
		return cp;

	return ap_table_get(r->err_headers_out, a);
}

static const char *
log_note(request_rec *r, char *a)
{
	return ap_table_get(r->notes, a);
}

static const char *
log_env_var(request_rec *r, char *a)
{
	return ap_table_get(r->subprocess_env, a);
}

static const char *
log_request_time(request_rec *r, char *a)
{
	int timz;
	struct tm *t;
	char tstr[MAX_STRING_LEN];

	t = ap_get_gmtoff(&timz);

	if (a && *a)		/* Custom format */
		strftime(tstr, MAX_STRING_LEN, a, t);
	else {			/* CLF format */
		char sign = (timz < 0 ? '-' : '+');

		if (timz < 0)
			timz = -timz;

		ap_snprintf(tstr, sizeof(tstr),
		    "[%02d/%s/%d:%02d:%02d:%02d %c%.2d%.2d]",
		    t->tm_mday, ap_month_snames[t->tm_mon], t->tm_year + 1900,
		    t->tm_hour, t->tm_min, t->tm_sec,
		    sign, timz / 60, timz % 60);
	}

	return ap_pstrdup(r->pool, tstr);
}

static const char *
log_request_duration(request_rec *r, char *a)
{
	return ap_psprintf(r->pool, "%ld",
	    (long)(time(NULL) - r->request_time));
}

/*
 * These next two routines use the canonical name:port so that log
 * parsers don't need to duplicate all the vhost parsing crud.
 */
static const char *
log_virtual_host(request_rec *r, char *a)
{
	return r->server->server_hostname;
}

static const char *
log_server_port(request_rec *r, char *a)
{
	return ap_psprintf(r->pool, "%u",
	    r->server->port ? r->server->port : ap_default_port(r));
}

/*
 * This respects the setting of UseCanonicalName so that
 * the dynamic mass virtual hosting trick works better.
 */
static const char *
log_server_name(request_rec *r, char *a)
{
	return ap_get_server_name(r);
}

static const char *
log_child_pid(request_rec *r, char *a)
{
	return ap_psprintf(r->pool, "%ld", (long) getpid());
}

static const char *
log_connection_status(request_rec *r, char *a)
{
	if (r->connection->aborted)
		return "X";

	if ((r->connection->keepalive) &&
	    ((r->server->keep_alive_max - r->connection->keepalives) > 0))
		return "+";

	return "-";
}

/* Parsing the log format string */
static struct log_item_list {
	char ch;
	item_key_func func;
	int want_orig_default;
}             log_item_keys[] = {

	{
		'h', log_remote_host, 0
	},
	{
		'a', log_remote_address, 0
	},
	{
		'A', log_local_address, 0
	},
	{
		'l', log_remote_logname, 0
	},
	{
		'u', log_remote_user, 0
	},
	{
		't', log_request_time, 0
	},
	{
		'T', log_request_duration, 1
	},
	{
		'r', log_request_line, 1
	},
	{
		'f', log_request_file, 0
	},
	{
		'U', log_request_uri, 1
	},
	{
		's', log_status, 1
	},
	{
		'b', clf_log_bytes_sent, 0
	},
	{
		'B', log_bytes_sent, 0
	},
	{
		'i', log_header_in, 0
	},
	{
		'o', log_header_out, 0
	},
	{
		'n', log_note, 0
	},
	{
		'e', log_env_var, 0
	},
	{
		'V', log_server_name, 0
	},
	{
		'v', log_virtual_host, 0
	},
	{
		'p', log_server_port, 0
	},
	{
		'P', log_child_pid, 0
	},
	{
		'H', log_request_protocol, 0
	},
	{
		'm', log_request_method, 0
	},
	{
		'q', log_request_query, 0
	},
	{
		'c', log_connection_status, 0
	},
	{
		'\0'
	}
};

static struct log_item_list *
find_log_func(pool *p, char k)
{
	int i;
	struct log_item_list *lil;

	for (i = 0; log_item_keys[i].ch; ++i)
		if (k == log_item_keys[i].ch)
			return &log_item_keys[i];

	if (ap_hook_status(ap_psprintf(p, "ap::mod_log_config::log_%c", k))
	    != AP_HOOK_STATE_NOTEXISTANT) {
		lil = (struct log_item_list *)
		    ap_pcalloc(p, sizeof(struct log_item_list));
		if (lil == NULL)
			return NULL;
		lil->ch = k;
		lil->func = NULL;
		lil->want_orig_default = 0;
		return lil;
	}

	return NULL;
}

static char *
parse_log_misc_string(pool *p, log_format_item * it, const char **sa)
{
	const char *s;
	char *d;

	it->func = constant_item;
	it->conditions = NULL;

	s = *sa;
	while (*s && *s != '%')
		s++;

	/*
         * This might allocate a few chars extra if there's a backslash
         * escape in the format string.
         */
	it->arg = ap_palloc(p, s - *sa + 1);

	d = it->arg;
	s = *sa;
	while (*s && *s != '%') {
		if (*s != '\\')
			*d++ = *s++;
		else {
			s++;
			switch (*s) {
			case '\\':
				*d++ = '\\';
				s++;
				break;
			case 'n':
				*d++ = '\n';
				s++;
				break;
			case 't':
				*d++ = '\t';
				s++;
				break;
			default:
				/* copy verbatim */
				*d++ = '\\';
				/*
				 * Allow the loop to deal with this *s in
				 * the normal
				 * fashion so that it handles end of string etc.
				 * properly.
				 */
				break;
			}
		}
	}
	*d = '\0';

	*sa = s;
	return NULL;
}

static char *
parse_log_item(pool *p, log_format_item * it, const char **sa)
{
	const char *s = *sa;

	if (*s != '%')
		return parse_log_misc_string(p, it, sa);

	++s;
	it->condition_sense = 0;
	it->conditions = NULL;
	it->want_orig = -1;
	it->arg = "";		/* For safety's sake... */

	while (*s) {
		int i;
		struct log_item_list *l;

		switch (*s) {
		case '!':
			++s;
			it->condition_sense = !it->condition_sense;
			break;
		case '<':
			++s;
			it->want_orig = 1;
			break;
		case '>':
			++s;
			it->want_orig = 0;
			break;
		case ',':
			++s;
			break;
		case '{':
			++s;
			it->arg = ap_getword(p, &s, '}');
			break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			i = *s - '0';
			while (ap_isdigit(*++s))
				i = i * 10 + (*s) - '0';
			if (!it->conditions)
				it->conditions = ap_make_array(p, 4,
				    sizeof(int));
			*(int *)ap_push_array(it->conditions) = i;
			break;
		default:
			l = find_log_func(p, *s++);
			if (!l) {
				char dummy[2];

				dummy[0] = s[-1];
				dummy[1] = '\0';
				return ap_pstrcat(p, "Unrecognized LogFormat "
				    "directive %", dummy, NULL);
			}
			it->ch = s[-1];
			it->func = l->func;
			if (it->want_orig == -1)
				it->want_orig = l->want_orig_default;
			*sa = s;
			return NULL;
		}
	}

	return "Ran off end of LogFormat parsing args to some directive";
}

static array_header *
parse_log_string(pool *p, const char *s, const char **err)
{
	array_header *a = ap_make_array(p, 30, sizeof(log_format_item));
	char *res;

	while (*s) {
		if ((res = parse_log_item(p,
		    (log_format_item *)ap_push_array(a), &s))) {
			*err = res;
			return NULL;
		}
	}

	s = "\n";
	parse_log_item(p, (log_format_item *) ap_push_array(a), &s);
	return a;
}

/* Actually logging. */
static const char *
process_item(request_rec *r, request_rec *orig, log_format_item * item)
{
	const char *cp;

	/* First, see if we need to process this thing at all... */
	if (item->conditions && item->conditions->nelts != 0) {
		int i;
		int *conds = (int *)item->conditions->elts;
		int in_list = 0;

		for (i = 0; i < item->conditions->nelts; ++i) {
			if (r->status == conds[i]) {
				in_list = 1;
				break;
			}
		}

		if ((item->condition_sense && in_list)
		    || (!item->condition_sense && !in_list))
			return "-";
	}

	/* We do.  Do it... */
	if (item->func == NULL) {
		cp = NULL;
		ap_hook_use(ap_psprintf(r->pool, "ap::mod_log_config::log_%c",
		    item->ch), AP_HOOK_SIG3(ptr, ptr, ptr),
		    AP_HOOK_DECLINE(NULL), &cp, r, item->arg);
	} else
		cp = (*item->func) (item->want_orig ? orig : r, item->arg);
	return cp ? cp : "-";
}

#ifdef BUFFERED_LOGS
static void
flush_log(config_log_state * cls)
{
	if (cls->outcnt && cls->log_fd != -1) {
		write(cls->log_fd, cls->outbuf, cls->outcnt);
		cls->outcnt = 0;
	}
}
#endif

static int
config_log_transaction(request_rec *r, config_log_state * cls,
    array_header *default_format)
{
	log_format_item *items;
	char *str, *s;
	const char **strs;
	int *strl;
	request_rec *orig;
	int i;
	int len = 0;
	array_header *format;
	char *envar;

	if (cls->fname == NULL)
		return DECLINED;

	/*
         * See if we've got any conditional envariable-controlled
	 * logging decisions to make.
         */
	if (cls->condition_var != NULL) {
		envar = cls->condition_var;
		if (*envar != '!') {
			if (ap_table_get(r->subprocess_env, envar) == NULL)
				return DECLINED;
		} else {
			if (ap_table_get(r->subprocess_env, &envar[1]) != NULL)
				return DECLINED;
		}
	}

	format = cls->format ? cls->format : default_format;

	strs = ap_palloc(r->pool, sizeof(char *) * (format->nelts));
	strl = ap_palloc(r->pool, sizeof(int) * (format->nelts));
	items = (log_format_item *)format->elts;

	orig = r;
	while (orig->prev)
		orig = orig->prev;
	while (r->next)
		r = r->next;

	for (i = 0; i < format->nelts; ++i)
		strs[i] = process_item(r, orig, &items[i]);

	for (i = 0; i < format->nelts; ++i)
		len += strl[i] = strlen(strs[i]);

#ifdef BUFFERED_LOGS
	if (len + cls->outcnt > LOG_BUFSIZE)
		flush_log(cls);
	if (len >= LOG_BUFSIZE) {
		str = ap_palloc(r->pool, len + 1);
		for (i = 0, s = str; i < format->nelts; ++i) {
			memcpy(s, strs[i], strl[i]);
			s += strl[i];
		}
		write(cls->log_fd, str, len);
	} else {
		for (i = 0, s = &cls->outbuf[cls->outcnt]; i < format->nelts;
		    ++i) {
			memcpy(s, strs[i], strl[i]);
			s += strl[i];
		}
		cls->outcnt += len;
	}
#else
	str = ap_palloc(r->pool, len + 1);

	for (i = 0, s = str; i < format->nelts; ++i) {
		memcpy(s, strs[i], strl[i]);
		s += strl[i];
	}

	write(cls->log_fd, str, len);
#endif

	return OK;
}

static int
multi_log_transaction(request_rec *r)
{
	multi_log_state *mls =
	    ap_get_module_config(r->server->module_config, &config_log_module);
	config_log_state *clsarray;
	int i;

	/* Log this transaction.. */
	if (mls->config_logs->nelts) {
		clsarray = (config_log_state *) mls->config_logs->elts;
		for (i = 0; i < mls->config_logs->nelts; ++i) {
			config_log_state *cls = &clsarray[i];
			config_log_transaction(r, cls, mls->default_format);
		}
	} else if (mls->server_config_logs) {
		clsarray = (config_log_state *) mls->server_config_logs->elts;
		for (i = 0; i < mls->server_config_logs->nelts; ++i) {
			config_log_state *cls = &clsarray[i];
			config_log_transaction(r, cls, mls->default_format);
		}
	}

	return OK;
}

/* Module glue... */

static void *
make_config_log_state(pool *p, server_rec *s)
{
	multi_log_state *mls;

	mls = (multi_log_state *)ap_palloc(p, sizeof(multi_log_state));
	mls->config_logs = ap_make_array(p, 1, sizeof(config_log_state));
	mls->default_format_string = NULL;
	mls->default_format = NULL;
	mls->server_config_logs = NULL;
	mls->formats = ap_make_table(p, 4);
	ap_table_setn(mls->formats, "CLF", DEFAULT_LOG_FORMAT);

	return mls;
}

/*
 * Use the merger to simply add a pointer from the vhost log state
 * to the log of logs specified for the non-vhost configuration.  Make sure
 * vhosts inherit any globally-defined format names.
 */
static void *
merge_config_log_state(pool *p, void *basev, void *addv)
{
	multi_log_state *base = (multi_log_state *)basev;
	multi_log_state *add = (multi_log_state *)addv;

	add->server_config_logs = base->config_logs;
	if (!add->default_format) {
		add->default_format_string = base->default_format_string;
		add->default_format = base->default_format;
	}
	add->formats = ap_overlay_tables(p, base->formats, add->formats);

	return add;
}

/* Set the default logfile format, or define a nickname for a format string. */
static const char *
log_format(cmd_parms *cmd, void *dummy, char *fmt, char *name)
{
	const char *err_string = NULL;
	multi_log_state *mls =
	    ap_get_module_config(cmd->server->module_config,
	    &config_log_module);

	/*
         * If we were given two arguments, the second is a name to be
	 * given to the
         * format.  This syntax just defines the nickname - it doesn't actually
         * make the format the default.
         */
	if (name != NULL) {
		parse_log_string(cmd->pool, fmt, &err_string);
		if (err_string == NULL)
			ap_table_setn(mls->formats, name, fmt);
	} else {
		mls->default_format_string = fmt;
		mls->default_format = parse_log_string(cmd->pool, fmt,
		    &err_string);
	}
	return err_string;
}


static const char *
add_custom_log(cmd_parms *cmd, void *dummy, char *fn, char *fmt,
    char *envclause)
{
	const char *err_string = NULL;
	multi_log_state *mls = ap_get_module_config(cmd->server->module_config,
	    &config_log_module);
	config_log_state *cls;

	cls = (config_log_state *)ap_push_array(mls->config_logs);
	cls->condition_var = NULL;
	if (envclause != NULL) {
		if (strncasecmp(envclause, "env=", 4) != 0)
			return "error in condition clause";
		if ((envclause[4] == '\0')
		    || ((envclause[4] == '!') && (envclause[5] == '\0')))
			return "missing environment variable name";
		cls->condition_var = ap_pstrdup(cmd->pool, &envclause[4]);
	}

	cls->fname = fn;
	cls->format_string = fmt;
	if (fmt == NULL)
		cls->format = NULL;
	else
		cls->format = parse_log_string(cmd->pool, fmt, &err_string);
	cls->log_fd = -1;

	return err_string;
}

static const char *
set_transfer_log(cmd_parms *cmd, void *dummy, char *fn)
{
	return add_custom_log(cmd, dummy, fn, NULL, NULL);
}

static const char *
set_cookie_log(cmd_parms *cmd, void *dummy, char *fn)
{
	return add_custom_log(cmd, dummy, fn, "%{Cookie}n \"%r\" %t", NULL);
}

static const command_rec config_log_cmds[] =
{
	{"CustomLog", add_custom_log, NULL, RSRC_CONF, TAKE23,
		"a file name, a custom log format string or format name, "
	"and an optional \"env=\" clause (see docs)"},
	{"TransferLog", set_transfer_log, NULL, RSRC_CONF, TAKE1,
	"the filename of the access log"},
	{"LogFormat", log_format, NULL, RSRC_CONF, TAKE12,
	"a log format string (see docs) and an optional format name"},
	{"CookieLog", set_cookie_log, NULL, RSRC_CONF, TAKE1,
	"the filename of the cookie log"},
	{NULL}
};

static config_log_state *
open_config_log(server_rec *s, pool *p, config_log_state * cls,
    array_header *default_format)
{
	if (cls->log_fd > 0)
		return cls;	/* virtual config shared w/main server */

	if (cls->fname == NULL)
		return cls;	/* Leave it NULL to decline.  */

	if (*cls->fname == '|') {
		piped_log *pl;

		pl = ap_open_piped_log(p, cls->fname + 1);
		if (pl == NULL)
			exit(1);
		cls->log_fd = ap_piped_log_write_fd(pl);
	} else {
		char *fname = ap_server_root_relative(p, cls->fname);
		if (ap_server_chroot_desired())
			cls->log_fd = fdcache_open(fname, xfer_flags,
			    xfer_mode);
		else
			cls->log_fd = ap_popenf_ex(p, fname, xfer_flags,
			    xfer_mode, 1);

		if (cls->log_fd < 0) {
			ap_log_error(APLOG_MARK, APLOG_ERR, s,
			     "could not open transfer log file %s.", fname);
			exit(1);
		}
	}
#ifdef BUFFERED_LOGS
	cls->outcnt = 0;
#endif

	return cls;
}

static config_log_state *
open_multi_logs(server_rec *s, pool *p)
{
	int i;
	multi_log_state *mls = ap_get_module_config(s->module_config,
	    &config_log_module);
	config_log_state *clsarray;
	const char *dummy;
	const char *format;

	if (mls->default_format_string) {
		format = ap_table_get(mls->formats, mls->default_format_string);
		if (format)
			mls->default_format = parse_log_string(p, format,
			    &dummy);
	}

	if (!mls->default_format)
		mls->default_format = parse_log_string(p, DEFAULT_LOG_FORMAT,
		    &dummy);

	if (mls->config_logs->nelts) {
		clsarray = (config_log_state *) mls->config_logs->elts;
		for (i = 0; i < mls->config_logs->nelts; ++i) {
			config_log_state *cls = &clsarray[i];

			if (cls->format_string) {
				format = ap_table_get(mls->formats,
				    cls->format_string);
				if (format)
					cls->format = parse_log_string(p,
					    format, &dummy);
			}

			cls = open_config_log(s, p, cls, mls->default_format);
		}
	} else if (mls->server_config_logs) {
		clsarray = (config_log_state *) mls->server_config_logs->elts;
		for (i = 0; i < mls->server_config_logs->nelts; ++i) {
			config_log_state *cls = &clsarray[i];

			if (cls->format_string) {
				format = ap_table_get(mls->formats,
				    cls->format_string);
				if (format)
					cls->format = parse_log_string(p,
					    format, &dummy);
			}

			cls = open_config_log(s, p, cls, mls->default_format);
		}
	}

	return NULL;
}

static void
init_config_log(server_rec *s, pool *p)
{
	/*
         * First, do "physical" server, which gets default log fd and format for
         * the virtual servers, if they don't override...
         */
	open_multi_logs(s, p);

	/* Then, virtual servers */
	for (s = s->next; s; s = s->next)
		open_multi_logs(s, p);
}

#ifdef BUFFERED_LOGS
static void
flush_all_logs(server_rec *s, pool *p)
{
	multi_log_state *mls;
	array_header *log_list;
	config_log_state *clsarray;
	int i;

	for (; s; s = s->next) {
		mls = ap_get_module_config(s->module_config,
		    &config_log_module);
		log_list = NULL;
		if (mls->config_logs->nelts)
			log_list = mls->config_logs;
		else if (mls->server_config_logs)
			log_list = mls->server_config_logs;
		if (log_list) {
			clsarray = (config_log_state *) log_list->elts;
			for (i = 0; i < log_list->nelts; ++i)
				flush_log(&clsarray[i]);
		}
	}
}
#endif

module MODULE_VAR_EXPORT config_log_module =
{
	STANDARD_MODULE_STUFF,
	init_config_log,	/* initializer */
	NULL,			/* create per-dir config */
	NULL,			/* merge per-dir config */
	make_config_log_state,	/* server config */
	merge_config_log_state,	/* merge server config */
	config_log_cmds,	/* command table */
	NULL,			/* handlers */
	NULL,			/* filename translation */
	NULL,			/* check_user_id */
	NULL,			/* check auth */
	NULL,			/* check access */
	NULL,			/* type_checker */
	NULL,			/* fixups */
	multi_log_transaction,	/* logger */
	NULL,			/* header parser */
	NULL,			/* child_init */
#ifdef BUFFERED_LOGS
	flush_all_logs,		/* child_exit */
#else
	NULL,
#endif
	NULL			/* post read-request */
};
@


1.20
log
@acknowlege -> acknowledge
compatability -> compatibility

OK jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.19 2010/02/25 07:49:53 pyr Exp $ */
@


1.19
log
@fix some fallout from the >2G commit. namely allow for all byte counters to
report the correct size when it exceeds a long's capacity.

From Dan Harnett <daniel @@ harnett . name>
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.18 2008/10/03 19:36:36 mbalmer Exp $ */
d78 1
a78 1
 *    CookieLog fn        For backwards compatability with old Cookie
d89 1
a89 1
 * the VirtualHost will _not_ be used. This makes this module compatable
@


1.18
log
@KNF and readability changes; no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.17 2005/02/09 12:13:10 henning Exp $ */
d388 1
a388 1
		long int bs;
d390 1
a390 1
		return ap_psprintf(r->pool, "%ld", bs);
d400 1
a400 1
		long int bs;
d402 1
a402 1
		return ap_psprintf(r->pool, "%ld", bs);
@


1.17
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.16 2004/12/02 19:42:48 henning Exp $ */
d92 1
a92 1
 * 
d186 1
a186 1
#include "http_core.h"          /* For REMOTE_NAME */
a225 1

d227 5
a231 5
    char *default_format_string;
    array_header *default_format;
    array_header *config_logs;
    array_header *server_config_logs;
    table *formats;
a241 1

d243 5
a247 5
    char *fname;
    char *format_string;
    array_header *format;
    int log_fd;
    char *condition_var;
d249 2
a250 2
    int outcnt;
    char outbuf[LOG_BUFSIZE];
a257 1

d261 6
a266 6
    char ch;
    item_key_func func;
    char *arg;
    int condition_sense;
    int want_orig;
    array_header *conditions;
d269 2
a270 1
static char *format_integer(pool *p, int i)
d272 1
a272 1
    return ap_psprintf(p, "%d", i);
d275 2
a276 1
static char *pfmt(pool *p, int i)
d278 4
a281 6
    if (i <= 0) {
        return "-";
    }
    else {
        return format_integer(p, i);
    }
d284 2
a285 1
static const char *constant_item(request_rec *dummy, char *stuff)
d287 1
a287 1
    return stuff;
d290 2
a291 1
static const char *log_remote_host(request_rec *r, char *a)
d293 2
a294 2
    return ap_escape_logitem(r->pool, ap_get_remote_host(r->connection, r->per_dir_config,
                                    REMOTE_NAME));
d297 2
a298 1
static const char *log_remote_address(request_rec *r, char *a)
d300 1
a300 1
    return r->connection->remote_ip;
d303 2
a304 1
static const char *log_local_address(request_rec *r, char *a)
d306 1
a306 1
    return r->connection->local_ip;
d309 2
a310 1
static const char *log_remote_logname(request_rec *r, char *a)
d312 1
a312 1
    return ap_escape_logitem(r->pool, ap_get_remote_logname(r));
d315 2
a316 1
static const char *log_remote_user(request_rec *r, char *a)
d318 1
a318 1
    char *rvalue = r->connection->user;
d320 7
a326 9
    if (rvalue == NULL) {
        rvalue = "-";
    }
    else if (strlen(rvalue) == 0) {
        rvalue = "\"\"";
    }
    else
        rvalue = ap_escape_logitem(r->pool, rvalue);
    return rvalue;
d329 2
a330 1
static const char *log_request_line(request_rec *r, char *a)
d332 12
a343 11
	    /* NOTE: If the original request contained a password, we
	     * re-write the request line here to contain XXXXXX instead:
	     * (note the truncation before the protocol string for HTTP/0.9 requests)
	     * (note also that r->the_request contains the unmodified request)
	     */
    return ap_escape_logitem(r->pool,
			     (r->parsed_uri.password) ? ap_pstrcat(r->pool, r->method, " ",
					 ap_unparse_uri_components(r->pool, &r->parsed_uri, 0),
					 r->assbackwards ? NULL : " ", r->protocol, NULL)
					: r->the_request
			     );
d346 2
a347 1
static const char *log_request_file(request_rec *r, char *a)
d349 1
a349 1
    return r->filename;
d351 3
a353 1
static const char *log_request_uri(request_rec *r, char *a)
d355 1
a355 1
    return ap_escape_logitem(r->pool, r->uri);
d357 3
a359 1
static const char *log_request_method(request_rec *r, char *a)
d361 1
a361 1
    return ap_escape_logitem(r->pool, r->method);
d363 1
d366 1
a366 1
    return ap_escape_logitem(r->pool, r->protocol);
d368 1
d371 3
a373 3
    return (r->args != NULL) ? ap_pstrcat(r->pool, "?",
					  ap_escape_logitem(r->pool, r->args), NULL)
                             : "";
d375 3
a377 1
static const char *log_status(request_rec *r, char *a)
d379 1
a379 1
    return pfmt(r->pool, r->status);
d382 2
a383 1
static const char *clf_log_bytes_sent(request_rec *r, char *a)
d385 7
a391 8
    if (!r->sent_bodyct) {
        return "-";
    }
    else {
        long int bs;
        ap_bgetopt(r->connection->client, BO_BYTECT, &bs);
	return ap_psprintf(r->pool, "%ld", bs);
    }
d394 2
a395 1
static const char *log_bytes_sent(request_rec *r, char *a)
d397 7
a403 8
    if (!r->sent_bodyct) {
        return "0";
    }
    else {
        long int bs;
        ap_bgetopt(r->connection->client, BO_BYTECT, &bs);
	return ap_psprintf(r->pool, "%ld", bs);
    }
d406 2
a407 2

static const char *log_header_in(request_rec *r, char *a)
d409 1
a409 1
    return ap_escape_logitem(r->pool, ap_table_get(r->headers_in, a));
d412 2
a413 1
static const char *log_header_out(request_rec *r, char *a)
d415 9
a423 8
    const char *cp = ap_table_get(r->headers_out, a);
    if (!strcasecmp(a, "Content-type") && r->content_type) {
        cp = ap_field_noparam(r->pool, r->content_type);
    }
    if (cp) {
        return cp;
    }
    return ap_table_get(r->err_headers_out, a);
d426 2
a427 1
static const char *log_note(request_rec *r, char *a)
d429 1
a429 1
    return ap_table_get(r->notes, a);
d431 3
a433 1
static const char *log_env_var(request_rec *r, char *a)
d435 1
a435 1
    return ap_table_get(r->subprocess_env, a);
d438 2
a439 1
static const char *log_request_time(request_rec *r, char *a)
d441 3
a443 3
    int timz;
    struct tm *t;
    char tstr[MAX_STRING_LEN];
d445 1
a445 1
    t = ap_get_gmtoff(&timz);
d447 4
a450 5
    if (a && *a) {              /* Custom format */
        strftime(tstr, MAX_STRING_LEN, a, t);
    }
    else {                      /* CLF format */
        char sign = (timz < 0 ? '-' : '+');
d452 2
a453 8
        if (timz < 0) {
            timz = -timz;
        }
        ap_snprintf(tstr, sizeof(tstr), "[%02d/%s/%d:%02d:%02d:%02d %c%.2d%.2d]",
                t->tm_mday, ap_month_snames[t->tm_mon], t->tm_year+1900, 
                t->tm_hour, t->tm_min, t->tm_sec,
                sign, timz / 60, timz % 60);
    }
d455 8
a462 1
    return ap_pstrdup(r->pool, tstr);
d465 2
a466 1
static const char *log_request_duration(request_rec *r, char *a)
d468 2
a469 1
    return ap_psprintf(r->pool, "%ld", (long)(time(NULL) - r->request_time));
d472 2
a473 1
/* These next two routines use the canonical name:port so that log
d476 2
a477 1
static const char *log_virtual_host(request_rec *r, char *a)
d479 1
a479 1
    return r->server->server_hostname;
d482 2
a483 1
static const char *log_server_port(request_rec *r, char *a)
d485 2
a486 2
    return ap_psprintf(r->pool, "%u",
	r->server->port ? r->server->port : ap_default_port(r));
d489 2
a490 1
/* This respects the setting of UseCanonicalName so that
d493 2
a494 1
static const char *log_server_name(request_rec *r, char *a)
d496 1
a496 1
    return ap_get_server_name(r);
d499 2
a500 1
static const char *log_child_pid(request_rec *r, char *a)
d502 1
a502 1
    return ap_psprintf(r->pool, "%ld", (long) getpid());
d505 2
a506 1
static const char *log_connection_status(request_rec *r, char *a)
d508 2
a509 2
    if (r->connection->aborted)
        return "X";
d511 3
a513 4
    if ((r->connection->keepalive) &&
        ((r->server->keep_alive_max - r->connection->keepalives) > 0)) {
        return "+";
    }
d515 1
a515 1
    return "-";
d518 1
a518 5
/*****************************************************************
 *
 * Parsing the log format string
 */

d520 83
a602 83
    char ch;
    item_key_func func;
    int want_orig_default;
} log_item_keys[] = {

    {
        'h', log_remote_host, 0
    },
    {   
        'a', log_remote_address, 0 
    },
    {   
        'A', log_local_address, 0 
    },
    {
        'l', log_remote_logname, 0
    },
    {
        'u', log_remote_user, 0
    },
    {
        't', log_request_time, 0
    },
    {
        'T', log_request_duration, 1
    },
    {
        'r', log_request_line, 1
    },
    {
        'f', log_request_file, 0
    },
    {
        'U', log_request_uri, 1
    },
    {
        's', log_status, 1
    },
    {
        'b', clf_log_bytes_sent, 0
    },
    {
        'B', log_bytes_sent, 0
    },
    {
        'i', log_header_in, 0
    },
    {
        'o', log_header_out, 0
    },
    {
        'n', log_note, 0
    },
    {
        'e', log_env_var, 0
    },
    {
        'V', log_server_name, 0
    },
    {
        'v', log_virtual_host, 0
    },
    {
        'p', log_server_port, 0
    },
    {
        'P', log_child_pid, 0
    },
    {
        'H', log_request_protocol, 0
    },
    {
        'm', log_request_method, 0
    },
    {
        'q', log_request_query, 0
    },
    {
        'c', log_connection_status, 0
    },
    {
        '\0'
    }
d605 2
a606 1
static struct log_item_list *find_log_func(pool *p, char k)
d608 2
a609 2
    int i;
    struct log_item_list *lil;
d611 14
a624 44
    for (i = 0; log_item_keys[i].ch; ++i)
        if (k == log_item_keys[i].ch) {
            return &log_item_keys[i];
        }

    if (ap_hook_status(ap_psprintf(p, "ap::mod_log_config::log_%c", k)) 
        != AP_HOOK_STATE_NOTEXISTANT) {
        lil = (struct log_item_list *)
              ap_pcalloc(p, sizeof(struct log_item_list));
        if (lil == NULL)
            return NULL;
        lil->ch = k;
        lil->func = NULL;
        lil->want_orig_default = 0;
        return lil;
    }

    return NULL;
}

static char *parse_log_misc_string(pool *p, log_format_item *it,
                                   const char **sa)
{
    const char *s;
    char *d;

    it->func = constant_item;
    it->conditions = NULL;

    s = *sa;
    while (*s && *s != '%') {
	s++;
    }
    /*
     * This might allocate a few chars extra if there's a backslash
     * escape in the format string.
     */
    it->arg = ap_palloc(p, s - *sa + 1);

    d = it->arg;
    s = *sa;
    while (*s && *s != '%') {
	if (*s != '\\') {
	    *d++ = *s++;
d626 15
a640 5
	else {
	    s++;
	    switch (*s) {
	    case '\\':
		*d++ = '\\';
d642 44
a685 128
		break;
	    case 'n':
		*d++ = '\n';
		s++;
		break;
	    case 't':	
		*d++ = '\t';
		s++;
		break;
	    default:
		/* copy verbatim */
		*d++ = '\\';
		/*
		 * Allow the loop to deal with this *s in the normal
		 * fashion so that it handles end of string etc.
		 * properly.
		 */
		break;
	    }
	}
    }
    *d = '\0';

    *sa = s;
    return NULL;
}

static char *parse_log_item(pool *p, log_format_item *it, const char **sa)
{
    const char *s = *sa;

    if (*s != '%') {
        return parse_log_misc_string(p, it, sa);
    }

    ++s;
    it->condition_sense = 0;
    it->conditions = NULL;
    it->want_orig = -1;
    it->arg = "";               /* For safety's sake... */

    while (*s) {
        int i;
        struct log_item_list *l;

        switch (*s) {
        case '!':
            ++s;
            it->condition_sense = !it->condition_sense;
            break;

        case '<':
            ++s;
            it->want_orig = 1;
            break;

        case '>':
            ++s;
            it->want_orig = 0;
            break;

        case ',':
            ++s;
            break;

        case '{':
            ++s;
            it->arg = ap_getword(p, &s, '}');
            break;

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            i = *s - '0';
            while (ap_isdigit(*++s)) {
                i = i * 10 + (*s) - '0';
            }
            if (!it->conditions) {
                it->conditions = ap_make_array(p, 4, sizeof(int));
            }
            *(int *) ap_push_array(it->conditions) = i;
            break;

        default:
            l = find_log_func(p, *s++);
            if (!l) {
                char dummy[2];

                dummy[0] = s[-1];
                dummy[1] = '\0';
                return ap_pstrcat(p, "Unrecognized LogFormat directive %",
                               dummy, NULL);
            }
            it->ch = s[-1];
            it->func = l->func;
            if (it->want_orig == -1) {
                it->want_orig = l->want_orig_default;
            }
            *sa = s;
            return NULL;
        }
    }

    return "Ran off end of LogFormat parsing args to some directive";
}

static array_header *parse_log_string(pool *p, const char *s, const char **err)
{
    array_header *a = ap_make_array(p, 30, sizeof(log_format_item));
    char *res;

    while (*s) {
        if ((res = parse_log_item(p, (log_format_item *) ap_push_array(a), &s))) {
            *err = res;
            return NULL;
        }
    }

    s = "\n";
    parse_log_item(p, (log_format_item *) ap_push_array(a), &s);
    return a;
d688 77
a764 4
/*****************************************************************
 *
 * Actually logging.
 */
d766 2
a767 2
static const char *process_item(request_rec *r, request_rec *orig,
                          log_format_item *item)
d769 10
a778 1
    const char *cp;
d780 28
a807 1
    /* First, see if we need to process this thing at all... */
d809 9
a817 29
    if (item->conditions && item->conditions->nelts != 0) {
        int i;
        int *conds = (int *) item->conditions->elts;
        int in_list = 0;

        for (i = 0; i < item->conditions->nelts; ++i) {
            if (r->status == conds[i]) {
                in_list = 1;
                break;
            }
        }

        if ((item->condition_sense && in_list)
            || (!item->condition_sense && !in_list)) {
            return "-";
        }
    }

    /* We do.  Do it... */

    if (item->func == NULL) {
        cp = NULL;
        ap_hook_use(ap_psprintf(r->pool, "ap::mod_log_config::log_%c", item->ch),
                    AP_HOOK_SIG3(ptr,ptr,ptr), AP_HOOK_DECLINE(NULL),
                    &cp, r, item->arg);
    }
    else
    cp = (*item->func) (item->want_orig ? orig : r, item->arg);
    return cp ? cp : "-";
d821 2
a822 1
static void flush_log(config_log_state *cls)
d824 4
a827 4
    if (cls->outcnt && cls->log_fd != -1) {
        write(cls->log_fd, cls->outbuf, cls->outcnt);
        cls->outcnt = 0;
    }
d831 15
a845 25
static int config_log_transaction(request_rec *r, config_log_state *cls,
                                  array_header *default_format)
{
    log_format_item *items;
    char *str, *s;
    const char **strs;
    int *strl;
    request_rec *orig;
    int i;
    int len = 0;
    array_header *format;
    char *envar;

    if (cls->fname == NULL) {
        return DECLINED;
    }

    /*
     * See if we've got any conditional envariable-controlled logging decisions
     * to make.
     */
    if (cls->condition_var != NULL) {
	envar = cls->condition_var;
	if (*envar != '!') {
	    if (ap_table_get(r->subprocess_env, envar) == NULL) {
d847 14
a860 1
	    }
a861 6
	else {
	    if (ap_table_get(r->subprocess_env, &envar[1]) != NULL) {
		return DECLINED;
	    }
	}
    }
d863 14
a876 1
    format = cls->format ? cls->format : default_format;
d878 2
a879 19
    strs = ap_palloc(r->pool, sizeof(char *) * (format->nelts));
    strl = ap_palloc(r->pool, sizeof(int) * (format->nelts));
    items = (log_format_item *) format->elts;

    orig = r;
    while (orig->prev) {
        orig = orig->prev;
    }
    while (r->next) {
        r = r->next;
    }

    for (i = 0; i < format->nelts; ++i) {
        strs[i] = process_item(r, orig, &items[i]);
    }

    for (i = 0; i < format->nelts; ++i) {
        len += strl[i] = strlen(strs[i]);
    }
d882 17
a898 18
    if (len + cls->outcnt > LOG_BUFSIZE) {
        flush_log(cls);
    }
    if (len >= LOG_BUFSIZE) {
        str = ap_palloc(r->pool, len + 1);
        for (i = 0, s = str; i < format->nelts; ++i) {
            memcpy(s, strs[i], strl[i]);
            s += strl[i];
        }
        write(cls->log_fd, str, len);
    }
    else {
        for (i = 0, s = &cls->outbuf[cls->outcnt]; i < format->nelts; ++i) {
            memcpy(s, strs[i], strl[i]);
            s += strl[i];
        }
        cls->outcnt += len;
    }
d900 1
a900 1
    str = ap_palloc(r->pool, len + 1);
d902 4
a905 4
    for (i = 0, s = str; i < format->nelts; ++i) {
        memcpy(s, strs[i], strl[i]);
        s += strl[i];
    }
d907 1
a907 1
    write(cls->log_fd, str, len);
d910 1
a910 1
    return OK;
d913 2
a914 1
static int multi_log_transaction(request_rec *r)
d916 19
a934 4
    multi_log_state *mls = ap_get_module_config(r->server->module_config,
						&config_log_module);
    config_log_state *clsarray;
    int i;
d936 1
a936 21
    /*
     * Log this transaction..
     */
    if (mls->config_logs->nelts) {
        clsarray = (config_log_state *) mls->config_logs->elts;
        for (i = 0; i < mls->config_logs->nelts; ++i) {
            config_log_state *cls = &clsarray[i];

            config_log_transaction(r, cls, mls->default_format);
        }
    }
    else if (mls->server_config_logs) {
        clsarray = (config_log_state *) mls->server_config_logs->elts;
        for (i = 0; i < mls->server_config_logs->nelts; ++i) {
            config_log_state *cls = &clsarray[i];

            config_log_transaction(r, cls, mls->default_format);
        }
    }

    return OK;
d939 1
a939 4
/*****************************************************************
 *
 * Module glue...
 */
d941 2
a942 1
static void *make_config_log_state(pool *p, server_rec *s)
d944 1
a944 1
    multi_log_state *mls;
d946 7
a952 7
    mls = (multi_log_state *) ap_palloc(p, sizeof(multi_log_state));
    mls->config_logs = ap_make_array(p, 1, sizeof(config_log_state));
    mls->default_format_string = NULL;
    mls->default_format = NULL;
    mls->server_config_logs = NULL;
    mls->formats = ap_make_table(p, 4);
    ap_table_setn(mls->formats, "CLF", DEFAULT_LOG_FORMAT);
d954 1
a954 1
    return mls;
d962 5
d968 6
a973 4
static void *merge_config_log_state(pool *p, void *basev, void *addv)
{
    multi_log_state *base = (multi_log_state *) basev;
    multi_log_state *add = (multi_log_state *) addv;
d975 2
a976 6
    add->server_config_logs = base->config_logs;
    if (!add->default_format) {
        add->default_format_string = base->default_format_string;
        add->default_format = base->default_format;
    }
    add->formats = ap_overlay_tables(p, base->formats, add->formats);
d978 25
a1002 1
    return add;
d1005 30
a1034 61
/*
 * Set the default logfile format, or define a nickname for a format string.
 */
static const char *log_format(cmd_parms *cmd, void *dummy, char *fmt,
                              char *name)
{
    const char *err_string = NULL;
    multi_log_state *mls = ap_get_module_config(cmd->server->module_config,
						&config_log_module);

    /*
     * If we were given two arguments, the second is a name to be given to the
     * format.  This syntax just defines the nickname - it doesn't actually
     * make the format the default.
     */
    if (name != NULL) {
        parse_log_string(cmd->pool, fmt, &err_string);
        if (err_string == NULL) {
            ap_table_setn(mls->formats, name, fmt);
        }
    }
    else {
        mls->default_format_string = fmt;
        mls->default_format = parse_log_string(cmd->pool, fmt, &err_string);
    }
    return err_string;
}


static const char *add_custom_log(cmd_parms *cmd, void *dummy, char *fn,
                                  char *fmt, char *envclause)
{
    const char *err_string = NULL;
    multi_log_state *mls = ap_get_module_config(cmd->server->module_config,
						&config_log_module);
    config_log_state *cls;

    cls = (config_log_state *) ap_push_array(mls->config_logs);
    cls->condition_var = NULL;
    if (envclause != NULL) {
	if (strncasecmp(envclause, "env=", 4) != 0) {
	    return "error in condition clause";
	}
	if ((envclause[4] == '\0')
	    || ((envclause[4] == '!') && (envclause[5] == '\0'))) {
	    return "missing environment variable name";
	}
	cls->condition_var = ap_pstrdup(cmd->pool, &envclause[4]);
    }

    cls->fname = fn;
    cls->format_string = fmt;
    if (fmt == NULL) {
        cls->format = NULL;
    }
    else {
        cls->format = parse_log_string(cmd->pool, fmt, &err_string);
    }
    cls->log_fd = -1;

    return err_string;
d1037 2
a1038 1
static const char *set_transfer_log(cmd_parms *cmd, void *dummy, char *fn)
d1040 1
a1040 1
    return add_custom_log(cmd, dummy, fn, NULL, NULL);
d1043 2
a1044 1
static const char *set_cookie_log(cmd_parms *cmd, void *dummy, char *fn)
d1046 1
a1046 1
    return add_custom_log(cmd, dummy, fn, "%{Cookie}n \"%r\" %t", NULL);
d1051 10
a1060 10
    {"CustomLog", add_custom_log, NULL, RSRC_CONF, TAKE23,
     "a file name, a custom log format string or format name, "
     "and an optional \"env=\" clause (see docs)"},
    {"TransferLog", set_transfer_log, NULL, RSRC_CONF, TAKE1,
     "the filename of the access log"},
    {"LogFormat", log_format, NULL, RSRC_CONF, TAKE12,
     "a log format string (see docs) and an optional format name"},
    {"CookieLog", set_cookie_log, NULL, RSRC_CONF, TAKE1,
     "the filename of the cookie log"},
    {NULL}
d1063 32
a1094 34
static config_log_state *open_config_log(server_rec *s, pool *p,
                                         config_log_state *cls,
                                         array_header *default_format)
{
    if (cls->log_fd > 0) {
        return cls;             /* virtual config shared w/main server */
    }

    if (cls->fname == NULL) {
        return cls;             /* Leave it NULL to decline.  */
    }

    if (*cls->fname == '|') {
        piped_log *pl;

        pl = ap_open_piped_log(p, cls->fname + 1);
        if (pl == NULL) {
            exit(1);
        }
        cls->log_fd = ap_piped_log_write_fd(pl);
    }
    else {
        char *fname = ap_server_root_relative(p, cls->fname);
	if (ap_server_chroot_desired())
	    cls->log_fd = fdcache_open(fname, xfer_flags, xfer_mode);
	else
	    cls->log_fd = ap_popenf_ex(p, fname, xfer_flags, xfer_mode, 1);

        if (cls->log_fd < 0) {
            ap_log_error(APLOG_MARK, APLOG_ERR, s,
                         "could not open transfer log file %s.", fname);
            exit(1);
        }
    }
d1096 1
a1096 1
    cls->outcnt = 0;
d1099 1
a1099 1
    return cls;
d1102 2
a1103 1
static config_log_state *open_multi_logs(server_rec *s, pool *p)
d1105 32
a1136 27
    int i;
    multi_log_state *mls = ap_get_module_config(s->module_config,
                                             &config_log_module);
    config_log_state *clsarray;
    const char *dummy;
    const char *format;

    if (mls->default_format_string) {
	format = ap_table_get(mls->formats, mls->default_format_string);
	if (format) {
	    mls->default_format = parse_log_string(p, format, &dummy);
	}
    }    

    if (!mls->default_format) {
        mls->default_format = parse_log_string(p, DEFAULT_LOG_FORMAT, &dummy);
    }

    if (mls->config_logs->nelts) {
        clsarray = (config_log_state *) mls->config_logs->elts;
        for (i = 0; i < mls->config_logs->nelts; ++i) {
            config_log_state *cls = &clsarray[i];

	    if (cls->format_string) {
		format = ap_table_get(mls->formats, cls->format_string);
		if (format) {
		    cls->format = parse_log_string(p, format, &dummy);
d1138 12
a1149 1
	    }
d1151 1
a1151 12
            cls = open_config_log(s, p, cls, mls->default_format);
        }
    }
    else if (mls->server_config_logs) {
        clsarray = (config_log_state *) mls->server_config_logs->elts;
        for (i = 0; i < mls->server_config_logs->nelts; ++i) {
            config_log_state *cls = &clsarray[i];

	    if (cls->format_string) {
		format = ap_table_get(mls->formats, cls->format_string);
		if (format) {
		    cls->format = parse_log_string(p, format, &dummy);
d1153 1
a1153 5
	    }

            cls = open_config_log(s, p, cls, mls->default_format);
        }
    }
d1155 1
a1155 1
    return NULL;
d1158 2
a1159 1
static void init_config_log(server_rec *s, pool *p)
d1161 5
a1165 5
    /* First, do "physical" server, which gets default log fd and format
     * for the virtual servers, if they don't override...
     */

    open_multi_logs(s, p);
d1167 3
a1169 5
    /* Then, virtual servers */

    for (s = s->next; s; s = s->next) {
        open_multi_logs(s, p);
    }
d1173 2
a1174 1
static void flush_all_logs(server_rec *s, pool *p)
d1176 19
a1194 21
    multi_log_state *mls;
    array_header *log_list;
    config_log_state *clsarray;
    int i;

    for (; s; s = s->next) {
        mls = ap_get_module_config(s->module_config, &config_log_module);
        log_list = NULL;
        if (mls->config_logs->nelts) {
            log_list = mls->config_logs;
        }
        else if (mls->server_config_logs) {
            log_list = mls->server_config_logs;
        }
        if (log_list) {
            clsarray = (config_log_state *) log_list->elts;
            for (i = 0; i < log_list->nelts; ++i) {
                flush_log(&clsarray[i]);
            }
        }
    }
d1200 17
a1216 17
    STANDARD_MODULE_STUFF,
    init_config_log,            /* initializer */
    NULL,                       /* create per-dir config */
    NULL,                       /* merge per-dir config */
    make_config_log_state,      /* server config */
    merge_config_log_state,     /* merge server config */
    config_log_cmds,            /* command table */
    NULL,                       /* handlers */
    NULL,                       /* filename translation */
    NULL,                       /* check_user_id */
    NULL,                       /* check auth */
    NULL,                       /* check access */
    NULL,                       /* type_checker */
    NULL,                       /* fixups */
    multi_log_transaction,      /* logger */
    NULL,                       /* header parser */
    NULL,                       /* child_init */
d1218 1
a1218 1
    flush_all_logs,             /* child_exit */
d1220 1
a1220 1
    NULL,
d1222 1
a1222 1
    NULL                        /* post read-request */
@


1.16
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.15 2004/01/15 12:17:18 otto Exp $ */
a263 1
#ifdef EAPI
a264 1
#endif
a582 1
#ifdef EAPI
a583 3
#else /* EAPI */
static struct log_item_list *find_log_func(char k)
#endif /* EAPI */
a585 1
#ifdef EAPI
a586 1
#endif /* EAPI */
a592 1
#ifdef EAPI
a603 1
#endif /* EAPI */
a729 1
#ifdef EAPI
a730 3
#else /* EAPI */
            l = find_log_func(*s++);
#endif /* EAPI */
a738 1
#ifdef EAPI
a739 1
#endif
a800 1
#ifdef EAPI
a807 1
#endif
@


1.15
log
@Fix printf format string. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.14 2003/08/21 13:11:36 henning Exp $ */
a194 4
#if defined(OS2) || defined(WIN32) || defined(NETWARE)
/* OS/2 dosen't support users and groups */
static mode_t xfer_mode = (S_IREAD | S_IWRITE);
#else
a195 1
#endif
@


1.14
log
@merge
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.13 2003/07/18 21:16:37 david Exp $ */
d456 1
a456 1
    return ap_psprintf(r->pool, "%ld", time(NULL) - r->request_time);
@


1.13
log
@#include "http_main.h" for the chroot functions
fixes some implicit declaration warnings
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mod_log_config.c,v 1.12 2002/07/19 21:31:16 henning Exp $ */
d6 1
a6 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
d1119 2
a1120 1
	    cls->log_fd = ap_popenf(p, fname, xfer_flags, xfer_mode);
@


1.12
log
@merge
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d188 1
@


1.11
log
@o add ap_server_chroot_desired in http_main which just returns ap_server_chroot
o fdcache clean up on exit
o use fdcache for mod_log_config. survives graceful restarts now as long as
  no new logfile has to be opened. the latter is impossible because we lack
  the permission to do so once started.
@
text
@d300 2
a301 2
    return ap_get_remote_host(r->connection, r->per_dir_config,
                                    REMOTE_NAME);
d316 1
a316 1
    return ap_get_remote_logname(r);
d329 2
d341 2
a342 1
    return (r->parsed_uri.password) ? ap_pstrcat(r->pool, r->method, " ",
d345 2
a346 1
					: r->the_request;
d355 1
a355 1
    return r->uri;
d359 1
a359 1
    return r->method;
d363 1
a363 1
    return r->protocol;
d367 2
a368 1
    return (r->args != NULL) ? ap_pstrcat(r->pool, "?", r->args, NULL)
d403 1
a403 1
    return ap_table_get(r->headers_in, a);
d484 1
d497 1
@


1.10
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d1 2
d188 1
d1108 5
a1112 1
        if ((cls->log_fd = ap_popenf(p, fname, xfer_flags, xfer_mode)) < 0) {
@


1.9
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
@


1.8
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1995-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 20
a38 23
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 7
a56 6
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
d124 4
d476 9
d486 2
d570 3
@


1.7
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d186 1
a186 1
#if defined(OS2) || defined(WIN32)
@


1.6
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d397 1
a397 1
        cp = r->content_type;
@


1.5
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d120 3
a122 1
 * %...b:  bytes sent, excluding HTTP headers.
d146 3
d345 13
d363 12
d378 1
a378 1
        return "-";
d387 1
d517 4
a520 1
        'b', log_bytes_sent, 0
d545 9
@


1.4
log
@mod_ssl-2.2.3-1.3.4 (will require libssl-1.1 for https to work, but
mostly harmless otherwise).
@
text
@d109 2
a110 2
 * Except: no RefererIgnore functionality
 *         logs '-' if no Referer or User-Agent instead of nothing
d125 1
d142 2
a143 1
 * %...v:  the name of the server (i.e. which virtual host?)
d240 1
d296 5
a395 1
	size_t l;
d400 4
a403 5

        strftime(tstr, MAX_STRING_LEN, "[%d/%b/%Y:%H:%M:%S ", t);
	l = strlen(tstr);
        ap_snprintf(tstr + l, sizeof(tstr) - l,
                    "%c%.2d%.2d]", sign, timz / 60, timz % 60);
d428 8
d458 3
d501 3
a549 10
static char *log_format_substring(pool *p, const char *start,
                                  const char *end)
{
    char *res = ap_palloc(p, end - start + 1);

    strncpy(res, start, end - start);
    res[end - start] = '\0';
    return res;
}

d553 2
a554 1
    const char *s = *sa;
d559 1
d561 1
a561 1
        ++s;
d563 41
a603 1
    it->arg = log_format_substring(p, *sa, s);
a604 1

d783 1
d789 18
d865 1
a865 1
                                             &config_log_module);
d869 3
d899 1
a899 1
    multi_log_state *mls = (multi_log_state *) ap_palloc(p, sizeof(multi_log_state));
d901 1
d941 1
a941 1
                                             &config_log_module);
d961 1
d963 1
a963 1
                                  char *fmt)
d967 1
a967 1
                                             &config_log_module);
d971 12
d985 1
a985 1
    if (!fmt) {
d998 1
a998 1
    return add_custom_log(cmd, dummy, fn, NULL);
d1003 1
a1003 1
    return add_custom_log(cmd, dummy, fn, "%{Cookie}n \"%r\" %t");
d1008 3
a1010 2
    {"CustomLog", add_custom_log, NULL, RSRC_CONF, TAKE2,
     "a file name and a custom log format string or format name"},
@


1.3
log
@Apache 1.3.4 merge
@
text
@d252 3
d497 3
d501 1
d504 3
d513 14
d621 3
d625 1
d634 3
d698 9
@


1.2
log
@Apache 1.3.3 merge + proxy_segv fix
@
text
@d2 1
a2 1
 * Copyright (c) 1995-1998 The Apache Group.  All rights reserved.
d410 1
a410 1
    return ap_get_server_name(r);
d415 2
a416 1
    return ap_psprintf(r->pool, "%u", ap_get_server_port(r));
d917 1
a917 1
                         "httpd: could not open transfer log file %s.", fname);
@


1.1
log
@Initial revision
@
text
@d205 3
a207 4
 * (backward compat. with mod_log_config). We also store a pointer to
 * the logs specified for the main server for virtual servers, so that
 * if this vhost has now logs defined, we can use the main server's
 * logs instead.
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 23
a38 20
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 6
a55 7
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
d109 2
a110 2
 * RefererIgnore functionality can be obtained with conditional
 * logging (SetEnvIf and CustomLog ... env=!VAR).
d120 1
a120 7
 * %...B:  bytes sent, excluding HTTP headers.
 * %...b:  bytes sent, excluding HTTP headers in CLF format, i.e. a '-'
 *         when no bytes where sent (rather than a '0'.
 * %...c:  Status of the connection.
 *         'X' = connection aborted before the response completed.
 *         '+' = connection may be kept alive after the response is sent.
 *         '-' = connection will be closed after the response is sent.
a124 1
 * %...A:  local IP-address
d141 1
a141 5
 * %...v:  the configured name of the server (i.e. which virtual host?)
 * %...V:  the server name according to the UseCanonicalName setting
 * %...m:  the request method
 * %...H:  the request protocol
 * %...q:  the query string prepended by "?", or empty if no query string
d179 1
a179 1
#if defined(OS2) || defined(WIN32) || defined(NETWARE)
d205 4
a208 3
 * (backward compat. with mod_log_config).  We also store for each virtual
 * server a pointer to the logs specified for the main server, so that if this
 * vhost has no logs defined, we can use the main server's logs instead.
a238 1
    char *condition_var;
d282 2
a283 2
    return ap_escape_logitem(r->pool, ap_get_remote_host(r->connection, r->per_dir_config,
                                    REMOTE_NAME));
a290 5
static const char *log_local_address(request_rec *r, char *a)
{
    return r->connection->local_ip;
}

d293 1
a293 1
    return ap_escape_logitem(r->pool, ap_get_remote_logname(r));
a305 2
    else
        rvalue = ap_escape_logitem(r->pool, rvalue);
d316 1
a316 2
    return ap_escape_logitem(r->pool,
			     (r->parsed_uri.password) ? ap_pstrcat(r->pool, r->method, " ",
d319 1
a319 2
					: r->the_request
			     );
d328 1
a328 15
    return ap_escape_logitem(r->pool, r->uri);
}
static const char *log_request_method(request_rec *r, char *a)
{
    return ap_escape_logitem(r->pool, r->method);
}
static const char *log_request_protocol(request_rec *r, char *a)
{
    return ap_escape_logitem(r->pool, r->protocol);
}
static const char *log_request_query(request_rec *r, char *a)
{
    return (r->args != NULL) ? ap_pstrcat(r->pool, "?",
					  ap_escape_logitem(r->pool, r->args), NULL)
                             : "";
d335 1
a335 1
static const char *clf_log_bytes_sent(request_rec *r, char *a)
a346 13
static const char *log_bytes_sent(request_rec *r, char *a)
{
    if (!r->sent_bodyct) {
        return "0";
    }
    else {
        long int bs;
        ap_bgetopt(r->connection->client, BO_BYTECT, &bs);
	return ap_psprintf(r->pool, "%ld", bs);
    }
}


d349 1
a349 1
    return ap_escape_logitem(r->pool, ap_table_get(r->headers_in, a));
d356 1
a356 1
        cp = ap_field_noparam(r->pool, r->content_type);
d386 1
d391 5
a395 4
        ap_snprintf(tstr, sizeof(tstr), "[%02d/%s/%d:%02d:%02d:%02d %c%.2d%.2d]",
                t->tm_mday, ap_month_snames[t->tm_mon], t->tm_year+1900, 
                t->tm_hour, t->tm_min, t->tm_sec,
                sign, timz / 60, timz % 60);
d411 1
a411 1
    return r->server->server_hostname;
d416 1
a416 10
    return ap_psprintf(r->pool, "%u",
	r->server->port ? r->server->port : ap_default_port(r));
}

/* This respects the setting of UseCanonicalName so that
 * the dynamic mass virtual hosting trick works better.
 */
static const char *log_server_name(request_rec *r, char *a)
{
    return ap_get_server_name(r);
a423 13
static const char *log_connection_status(request_rec *r, char *a)
{
    if (r->connection->aborted)
        return "X";

    if ((r->connection->keepalive) &&
        ((r->server->keep_alive_max - r->connection->keepalives) > 0)) {
        return "+";
    }

    return "-";
}

a440 3
    {   
        'A', log_local_address, 0 
    },
d466 1
a466 4
        'b', clf_log_bytes_sent, 0
    },
    {
        'B', log_bytes_sent, 0
a480 3
        'V', log_server_name, 0
    },
    {
a489 12
        'H', log_request_protocol, 0
    },
    {
        'm', log_request_method, 0
    },
    {
        'q', log_request_query, 0
    },
    {
        'c', log_connection_status, 0
    },
    {
d506 10
d519 1
a519 2
    const char *s;
    char *d;
a523 1
    s = *sa;
d525 1
a525 1
	s++;
d527 2
a528 5
    /*
     * This might allocate a few chars extra if there's a backslash
     * escape in the format string.
     */
    it->arg = ap_palloc(p, s - *sa + 1);
a529 36
    d = it->arg;
    s = *sa;
    while (*s && *s != '%') {
	if (*s != '\\') {
	    *d++ = *s++;
	}
	else {
	    s++;
	    switch (*s) {
	    case '\\':
		*d++ = '\\';
		s++;
		break;
	    case 'n':
		*d++ = '\n';
		s++;
		break;
	    case 't':	
		*d++ = '\t';
		s++;
		break;
	    default:
		/* copy verbatim */
		*d++ = '\\';
		/*
		 * Allow the loop to deal with this *s in the normal
		 * fashion so that it handles end of string etc.
		 * properly.
		 */
		break;
	    }
	}
    }
    *d = '\0';

    *sa = s;
a691 1
    char *envar;
a696 18
    /*
     * See if we've got any conditional envariable-controlled logging decisions
     * to make.
     */
    if (cls->condition_var != NULL) {
	envar = cls->condition_var;
	if (*envar != '!') {
	    if (ap_table_get(r->subprocess_env, envar) == NULL) {
		return DECLINED;
	    }
	}
	else {
	    if (ap_table_get(r->subprocess_env, &envar[1]) != NULL) {
		return DECLINED;
	    }
	}
    }

d755 1
a755 1
						&config_log_module);
a758 3
    /*
     * Log this transaction..
     */
d786 1
a786 1
    multi_log_state *mls;
a787 1
    mls = (multi_log_state *) ap_palloc(p, sizeof(multi_log_state));
d827 1
a827 1
						&config_log_module);
a846 1

d848 1
a848 1
                                  char *fmt, char *envclause)
d852 1
a852 1
						&config_log_module);
a855 12
    cls->condition_var = NULL;
    if (envclause != NULL) {
	if (strncasecmp(envclause, "env=", 4) != 0) {
	    return "error in condition clause";
	}
	if ((envclause[4] == '\0')
	    || ((envclause[4] == '!') && (envclause[5] == '\0'))) {
	    return "missing environment variable name";
	}
	cls->condition_var = ap_pstrdup(cmd->pool, &envclause[4]);
    }

d858 1
a858 1
    if (fmt == NULL) {
d871 1
a871 1
    return add_custom_log(cmd, dummy, fn, NULL, NULL);
d876 1
a876 1
    return add_custom_log(cmd, dummy, fn, "%{Cookie}n \"%r\" %t", NULL);
d881 2
a882 3
    {"CustomLog", add_custom_log, NULL, RSRC_CONF, TAKE23,
     "a file name, a custom log format string or format name, "
     "and an optional \"env=\" clause (see docs)"},
d917 1
a917 1
                         "could not open transfer log file %s.", fname);
@


1.1.1.3
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@a264 3
#ifdef EAPI
    char ch;
#endif
a582 3
#ifdef EAPI
static struct log_item_list *find_log_func(pool *p, char k)
#else /* EAPI */
a583 1
#endif /* EAPI */
a585 3
#ifdef EAPI
    struct log_item_list *lil;
#endif /* EAPI */
a591 14
#ifdef EAPI
    if (ap_hook_status(ap_psprintf(p, "ap::mod_log_config::log_%c", k)) 
        != AP_HOOK_STATE_NOTEXISTANT) {
        lil = (struct log_item_list *)
              ap_pcalloc(p, sizeof(struct log_item_list));
        if (lil == NULL)
            return NULL;
        lil->ch = k;
        lil->func = NULL;
        lil->want_orig_default = 0;
        return lil;
    }
#endif /* EAPI */

a716 3
#ifdef EAPI
            l = find_log_func(p, *s++);
#else /* EAPI */
a717 1
#endif /* EAPI */
a725 3
#ifdef EAPI
            it->ch = s[-1];
#endif
a786 9
#ifdef EAPI
    if (item->func == NULL) {
        cp = NULL;
        ap_hook_use(ap_psprintf(r->pool, "ap::mod_log_config::log_%c", item->ch),
                    AP_HOOK_SIG3(ptr,ptr,ptr), AP_HOOK_DECLINE(NULL),
                    &cp, r, item->arg);
    }
    else
#endif
@


1.1.1.4
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
d1112 1
a1112 2
        if ((cls->log_fd = ap_popenf_ex(p, fname, xfer_flags, xfer_mode, 1))
             < 0) {
@


