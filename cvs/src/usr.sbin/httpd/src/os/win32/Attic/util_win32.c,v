head	1.8;
access;
symbols
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.3
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.3
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.2
	apache_1_3_27:1.1.1.2
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2004.12.02.21.35.49;	author henning;	state dead;
branches;
next	1.7;

1.7
date	2003.08.21.13.11.40;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.29.02.08.07;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.22.18.38;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	99.09.29.06.30.02;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.03.01.01.07.11;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	98.10.11.19.45.19;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.46;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.46;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.29.19;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.21.12.53.44;	author henning;	state Exp;
branches;
next	;


desc
@@


1.8
log
@king bula sez: in Attic/ you shall rot
@
text
@/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

#ifdef WIN32

#include <sys/stat.h>
#include <stdarg.h>
#include <time.h>
#include <stdlib.h>

#include "httpd.h"
#include "http_log.h"

/* Returns TRUE if the input string is a string
 * of one or more '.' characters.
 */
static BOOL OnlyDots(char *pString)
{
    char *c;

    if (*pString == '\0')
        return FALSE;

    for (c = pString;*c;c++)
        if (*c != '.')
            return FALSE;

    return TRUE;
}


/* Accepts as input a pathname, and tries to match it to an 
 * existing path and return the pathname in the case that
 * is present on the existing path.  This routine also
 * converts alias names to long names.
 *
 * WARNING: Folding to systemcase fails when /path/to/foo/../bar
 * is given and foo does not exist, is not a directory.
 */
API_EXPORT(char *) ap_os_systemcase_filename(pool *pPool, 
                                             const char *szFile)
{
    char *buf, *t, *r;
    const char *q, *p;
    BOOL bDone = FALSE;
    BOOL bFileExists = TRUE;
    HANDLE hFind;
    WIN32_FIND_DATA wfd;
    size_t buflen;
    int slack = 0;

    if (!szFile || strlen(szFile) == 0)
        return ap_pstrdup(pPool, "");

    buflen = strlen(szFile);
    t = buf = ap_palloc(pPool, buflen + 1);
    q = szFile;

    /* If there is drive information, copy it over. */ 
    if (szFile[1] == ':') {
        /* Lowercase, so that when systemcase is used for
         * comparison, d: designations will match
         */                 
        *(t++) = tolower(*(q++));
        *(t++) = *(q++);
    }
    else if ((*q == '/') || (*q == '\\')) {
        /* Get past the root path (/ or //foo/bar/) so we can go
         * on to normalize individual path elements.
         */
        *(t++) = '\\', ++q;
        if ((*q == '/') || (*q == '\\'))  /* UNC name */
        {
                /* Lower-case the machine name, so compares match.
                 * FindFirstFile won't parse \\machine alone
                 */
            *(t++) = '\\', ++q;
            for (p = q; *p && (*p != '/') && (*p != '\\'); ++p)
                /* continue */ ;
            if (*p || p > q) 
            {
                /* Lower-case the machine name, so compares match.
                 * FindFirstFile won't parse \\machine\share alone
                 */
                memcpy(t, q, p - q);
                t[p - q] = '\0';
                strlwr(t);
                t += p - q;
                q = p;
                if (*p) {
                    *(t++) = '\\', ++q;
                    for (p = q; *p && (*p != '/') && (*p != '\\'); ++p)
                        /* continue */ ;
                    if (*p || p > q) 
                    {
                        /* Copy the lower-cased share name.  FindFirstFile 
                         * cannot not find a \\machine\share name only 
                         */
                        memcpy(t, q, p - q);
                        t[p - q] = '\0';
                        strlwr(t);
                        t += p - q;
                        q = p;
                        if (*p)
                            *(t++) = '\\', ++q;
                        else
                            bFileExists = FALSE;
                    }
                    else
                        bFileExists = FALSE;
                }
                else
                    bFileExists = FALSE;
            }
            else
                bFileExists = FALSE;
        }
    }

    while (bFileExists) {

        /* parse past any leading slashes */
        for (; (*q == '/') || (*q == '\\'); ++q)
            *(t++) = '\\';

        /* break on end of string */
        if (!*q)
            break;

        /* get to the end of this path segment */
        for (p = q; *p && (*p != '/') && (*p != '\\'); ++p)
            /* continue */ ;
                
        /* copy the segment */
        memcpy(t, q, p - q);
        t[p - q] = '\0';

        /* Test for nasties that can exhibit undesired effects */
        if (strpbrk(t, "?\"<>*|:")) {
            t += p - q;
            q = p;
            break;
        }

        /* If the path exists so far, call FindFirstFile
         * again.  However, if this portion of the path contains
         * only '.' charaters, skip the call to FindFirstFile
         * since it will convert '.' and '..' to actual names.
         * On win32, '...' is an alias for '..', so we gain 
         * a bit of slack.
         */
        if (*t == '.' && OnlyDots(t)) {
            if (p - q == 3) {
                t += 2;
                q = p;
                ++slack;
            }
            else {
                t += p - q;
                q = p;
            }
            /* Paths of 4 dots or more are invalid */
            if (p - q > 3)
                break;
        }
        else {
            if ((hFind = FindFirstFile(buf, &wfd)) == INVALID_HANDLE_VALUE) {
                t += p - q;
                q = p;
                break;
            }
            else {
                size_t fnlen = strlen(wfd.cFileName);
                FindClose(hFind);
                /* the string length just changed, could have shrunk
                 * (trailing spaces or dots) or could have grown 
                 * (longer filename aliases).  Realloc as necessary
                 */
                slack -= fnlen - (p - q);
                if (slack < 0) {
                    char *n;
                    slack += buflen + fnlen - (p - q);
                    buflen += buflen + fnlen - (p - q);
                    n = ap_palloc(pPool, buflen + 1);
                    memcpy (n, buf, t - buf);
                    t = n + (t - buf);
                    buf = n;
                }
                memcpy(t, wfd.cFileName, fnlen);
                t += fnlen;
                q = p;
                if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                    break;
            }
        }
    }

    /* Convert all parsed '\'s to '/' for canonical form (doesn't touch
     * the non-existant portion of the path whatsoever.)
     */
    for (r = buf; r < t; ++r) {
        if (*r == '\\')
            *r = '/';
    }

    /* Copy the non-existant portion (minimally nul-terminates the string) */
    strcpy(t, q);
    
    return buf;
}


/*  Perform canonicalization with the exception that the
 *  input case is preserved.
 */
API_EXPORT(char *) ap_os_case_canonical_filename(pool *pPool, 
                                                 const char *szFile)
{
    char *pNewStr;
    char *s;
    char *p; 
    char *q;

    if (szFile == NULL || strlen(szFile) == 0)
        return ap_pstrdup(pPool, "");

    pNewStr = ap_pstrdup(pPool, szFile);

    /*  Change all '\' characters to '/' characters.
     *  While doing this, remove any trailing '.'.
     *  Also, blow away any directories with 3 or
     *  more '.'
     */
    for (p = pNewStr,s = pNewStr; *s; s++,p++) {
        if (*s == '\\' || *s == '/') {

            q = p;
            while (p > pNewStr && *(p-1) == '.')
                p--;

            if (p == pNewStr && q-p <= 2 && *p == '.')
                p = q;
            else if (p > pNewStr && p < q && *(p-1) == '/') {
                if (q-p > 2)
                    p--;
                else
                    p = q;
            }

            *p = '/';
        }
        else {
            *p = *s;
        }
    }
    *p = '\0';

    /*  Blow away any final trailing '.' since on Win32
     *  foo.bat == foo.bat. == foo.bat... etc.
     *  Also blow away any trailing spaces since
     *  "filename" == "filename "
     */
    q = p;
    while (p > pNewStr && (*(p-1) == '.' || *(p-1) == ' '))
        p--;
    if ((p > pNewStr) ||
        (p == pNewStr && q-p > 2))
        *p = '\0';
        

    /*  One more security issue to deal with.  Win32 allows
     *  you to create long filenames.  However, alias filenames
     *  are always created so that the filename will
     *  conform to 8.3 rules.  According to the Microsoft
     *  Developer's network CD (1/98) 
     *  "Automatically generated aliases are composed of the 
     *   first six characters of the filename plus ~n 
     *   (where n is a number) and the first three characters 
     *   after the last period."
     *  Here, we attempt to detect and decode these names.
     *
     *  XXX: Netware network clients may have alternate short names,
     *  simply truncated, with no embedded '~'.  Further, this behavior
     *  can be modified on WinNT volumes.  This was not a safe test,
     *  therefore exclude the '~' pretest.
     */
#ifdef WIN32_SHORT_FILENAME_INSECURE_BEHAVIOR
     p = strchr(pNewStr, '~');
     if (p != NULL)
#endif
    /* ap_os_systemcase_filename now changes the case of only
     * the pathname elements that are found.
     */
        pNewStr = ap_os_systemcase_filename(pPool, pNewStr);

    return pNewStr;
}

/*  Perform complete canonicalization.
 */
API_EXPORT(char *) ap_os_canonical_filename(pool *pPool, const char *szFile)
{
    char *pNewName;
    pNewName = ap_os_case_canonical_filename(pPool, szFile);
    strlwr(pNewName);
    return pNewName;
}


/*
 * ap_os_is_filename_valid is given a filename, and returns 0 if the filename
 * is not valid for use on this system. On Windows, this means it fails any
 * of the tests below. Otherwise returns 1.
 *
 * Test for filename validity on Win32. This is of tests come in part from
 * the MSDN article at "Technical Articles, Windows Platform, Base Services,
 * Guidelines, Making Room for Long Filenames" although the information
 * in MSDN about filename testing is incomplete or conflicting. There is a
 * similar set of tests in "Technical Articles, Windows Platform, Base Services,
 * Guidelines, Moving Unix Applications to Windows NT".
 *
 * The tests are:
 *
 * 1) total path length greater than MAX_PATH
 *
 * 2) anything using the octets 0-31 or characters " < > | :
 *    (these are reserved for Windows use in filenames. In addition
 *     each file system has its own additional characters that are
 *     invalid. See KB article Q100108 for more details).
 *
 * 3) anything ending in "." (no matter how many)
 *    (filename doc, doc. and doc... all refer to the same file)
 *
 * 4) any segment in which the basename (before first period) matches
 *    one of the DOS device names
 *    (the list comes from KB article Q100108 although some people
 *     reports that additional names such as "COM5" are also special
 *     devices).
 *
 * If the path fails ANY of these tests, the result must be to deny access.
 */

API_EXPORT(int) ap_os_is_filename_valid(const char *file)
{
    const char *segstart;
    unsigned int seglength;
    const char *pos;
    static const char * const invalid_characters = "?\"<>*|:";
    static const char * const invalid_filenames[] = { 
	"CON", "AUX", "COM1", "COM2", "COM3", 
	"COM4", "LPT1", "LPT2", "LPT3", "PRN", "NUL", NULL 
    };

    /* Test 1 */
    if (strlen(file) >= MAX_PATH) {
	/* Path too long for Windows. Note that this test is not valid
	 * if the path starts with //?/ or \\?\. */
	return 0;
    }

    pos = file;

    /* Skip any leading non-path components. This can be either a
     * drive letter such as C:, or a UNC path such as \\SERVER\SHARE\.
     * We continue and check the rest of the path based on the rules above.
     * This means we could eliminate valid filenames from servers which
     * are not running NT (such as Samba).
     */

    if (pos[0] && pos[1] == ':') {
	/* Skip leading drive letter */
	pos += 2;
    }
    else {
	if ((pos[0] == '\\' || pos[0] == '/') &&
	    (pos[1] == '\\' || pos[1] == '/')) {
	    /* Is a UNC, so skip the server name and share name */
	    pos += 2;
	    while (*pos && *pos != '/' && *pos != '\\')
		pos++;
	    if (!*pos) {
		/* No share name */
		return 0;
	    }
	    pos++;	/* Move to start of share name */
	    while (*pos && *pos != '/' && *pos != '\\')
		pos++;
	    if (!*pos) {
		/* No path information */
		return 0;
	    }
	}
    }

    while (*pos) {
	unsigned int idx;
	unsigned int baselength;

	while (*pos == '/' || *pos == '\\') {
    	    pos++;
	}
	if (*pos == '\0') {
	    break;
	}
	segstart = pos;	/* start of segment */
	while (*pos && *pos != '/' && *pos != '\\') {
	    pos++;
	}
	seglength = pos - segstart;
	/* 
	 * Now we have a segment of the path, starting at position "segstart"
	 * and length "seglength"
	 */

	/* Test 2 */
	for (idx = 0; idx < seglength; idx++) {
	    if ((segstart[idx] > 0 && segstart[idx] < 32) ||
		strchr(invalid_characters, segstart[idx])) {
		return 0;
	    }
	}

	/* Test 3 */
	if (segstart[seglength-1] == '.') {
	    return 0;
	}

	/* Test 4 */
	for (baselength = 0; baselength < seglength; baselength++) {
	    if (segstart[baselength] == '.') {
		break;
	    }
	}

	/* baselength is the number of characters in the base path of
	 * the segment (which could be the same as the whole segment length,
	 * if it does not include any dot characters). */
	if (baselength == 3 || baselength == 4) {
	    for (idx = 0; invalid_filenames[idx]; idx++) {
		if (strlen(invalid_filenames[idx]) == baselength &&
		    !strnicmp(invalid_filenames[idx], segstart, baselength)) {
		    return 0;
		}
	    }
	}
    }

    return 1;
}


API_EXPORT(ap_os_dso_handle_t) ap_os_dso_load(const char *module_name)
{
    UINT em;
    ap_os_dso_handle_t dsoh;
    char path[MAX_PATH], *p;
    /* Load the module...
     * per PR2555, the LoadLibraryEx function is very picky about slashes.
     * Debugging on NT 4 SP 6a reveals First Chance Exception within NTDLL.
     * LoadLibrary in the MS PSDK also reveals that it -explicitly- states
     * that backslashes must be used.
     *
     * Transpose '\' for '/' in the filename.
     */
    ap_cpystrn(path, module_name, MAX_PATH);
    p = path;
    while (p = strchr(p, '/'))
        *p = '\\';
    
    /* First assume the dso/dll's required by -this- dso are sitting in the 
     * same path or can be found in the usual places.  Failing that, let's
     * let that dso look in the apache root.
     */
    em = SetErrorMode(SEM_FAILCRITICALERRORS);
    dsoh = LoadLibraryEx(path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (!dsoh) {
        dsoh = LoadLibraryEx(path, NULL, 0);
    }
    SetErrorMode(em);
    return dsoh;
}

API_EXPORT(const char *) ap_os_dso_error(void)
{
    int len, nErrorCode;
    static char errstr[120];
    /* This is -not- threadsafe code, but it's about the best we can do.
     * mostly a potential problem for isapi modules, since LoadModule
     * errors are handled within a single config thread.
     */
    
    nErrorCode = GetLastError();
    len = ap_snprintf(errstr, sizeof(errstr), "(%d) ", nErrorCode);

    len += FormatMessage( 
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            nErrorCode,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), /* Default language */
            (LPTSTR) errstr + len,
            sizeof(errstr) - len,
            NULL 
        );
        /* FormatMessage may have appended a newline (\r\n). So remove it 
         * and use ": " instead like the Unix errors. The error may also
         * end with a . before the return - if so, trash it.
         */
    if (len > 1 && errstr[len-2] == '\r' && errstr[len-1] == '\n') {
        if (len > 2 && errstr[len-3] == '.')
            len--;
        errstr[len-2] = ':';
        errstr[len-1] = ' ';
    }
    return errstr;
}

#endif /* WIN32 */@


1.7
log
@merge
@
text
@@


1.6
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
@


1.5
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d1 60
a60 1
#include <windows.h>
d86 1
d91 3
d98 2
a99 3
    char buf[HUGE_STRING_LEN];
    char *pInputName;
    char *p, *q, *t;
d104 2
d107 1
a107 1
    if (!szFile || strlen(szFile) == 0 || strlen(szFile) >= sizeof(buf))
d110 3
a112 2
    t = buf;
    pInputName = ap_pstrdup(pPool, szFile);
a113 7
    /* First convert all slashes to \ so Win32 calls work OK */
    for (p = pInputName; *p; p++) {
        if (*p == '/')
            *p = '\\';
    }
    
    q = p = pInputName;
d115 2
a116 2
    if (pInputName[1] == ':') {
        /* This is correct - if systemcase is used for
d118 10
a127 13
         */                    
        *(t++) = tolower(*p++);
        *(t++) = *p++;
        q = p;

        /* If all we have is a drive letter, then we are done */
        if (!*p)
            bDone = TRUE;
    }    

    if (*p == '\\') {
        ++p;
        if (*p == '\\')  /* UNC name */
d129 7
a135 6
            /* Get past the machine name.  FindFirstFile */
            /* will not find a machine name only */
            *(t++) = '\\';
            ++q;
            p = strchr(p + 1, '\\'); 
            if (p)
d137 29
a165 13
                p++;
                /* Get past the share name.  FindFirstFile */
                /* will not find a \\machine\share name only */
                p = strchr(p, '\\'); 
                if (p) {
                    /* This was faulty - as of 1.3.13 \\machine\share 
                     * name is now always lowercased
                     */
                    strncpy(t,q,p-q);
                    strlwr(t);
                    t += p - q;
                    q = p;
                    p++;
d167 2
d170 1
a170 2

            if (!p) {
a171 2
                p = q;
            }
d175 1
a175 1
    p = strchr(p, '\\');
d177 3
a179 3
    while (!bDone) {
        if (p)
            *p = '\0';
d181 18
a198 2
        if (strchr(q, '*') || strchr(q, '?'))
            bFileExists = FALSE;
d204 2
a205 2
         * Note: in the call to OnlyDots, we may have to skip
         *       a leading slash.
d207 5
a211 5
        if (bFileExists && !OnlyDots((*q == '.' ? q : q+1))) {            
            hFind = FindFirstFile(pInputName, &wfd);
            
            if (hFind == INVALID_HANDLE_VALUE) {
                bFileExists = FALSE;
d214 2
a215 5
                FindClose(hFind);

                if (*q == '\\')
                    *(t++) = '\\';
                t = strchr(strcpy(t, wfd.cFileName), '\0');
d217 3
a219 14
        }
        
        if (!bFileExists || OnlyDots((*q == '.' ? q : q+1))) {
            /* XXX: Comparison could be faulty ...\unknown
             * names may not match!
             */
            strcpy(t, q);
            t = strchr(t, '\0');
        }
        
        if (p) {
            q = p;
            *p++ = '\\';
            p = strchr(p, '\\');
d222 28
a249 1
            bDone = TRUE;
d252 7
a258 6
    *t = '\0';
    
    /* Finally, convert all slashes to / so server code handles it ok */
    for (p = buf; *p; p++) {
        if (*p == '\\')
            *p = '/';
d261 4
a264 1
    return ap_pstrdup(pPool, buf);
d341 1
a341 1
     */     
d346 4
a349 45
     {
        char *pConvertedName, *pQstr, *pPstr;
        char buf[HUGE_STRING_LEN];
        /* We potentially have a short name.  Call 
         * ap_os_systemcase_filename to examine the filesystem
         * and possibly extract the long name.
         */
        pConvertedName = ap_os_systemcase_filename(pPool, pNewStr);

        /* Since we want to preserve the incoming case as much
         * as we can, compare for differences in the string and
         * only substitute in the path names that changed.
         */
        if (stricmp(pNewStr, pConvertedName)) {
            buf[0] = '\0';

            q = pQstr = pConvertedName;
            p = pPstr = pNewStr;
            do {
                q = strchr(q,'/');
                p = strchr(p,'/');

                if (p != NULL) {
                    *q = '\0';
                    *p = '\0';
                }

                if (stricmp(pQstr, pPstr)) 
                    strcat(buf, pQstr);   /* Converted name */
                else 
                    strcat(buf, pPstr);   /* Original name  */


                if (p != NULL) {
                    pQstr = q;
                    pPstr = p;
                    *q++ = '/';
                    *p++ = '/';
                }

            } while (p != NULL); 

            pNewStr = ap_pstrdup(pPool, buf);
        }
    }
a363 261
/* Win95 doesn't like trailing /s. NT and Unix don't mind. This works 
 * around the problem.
 * Errr... except if it is UNC and we are referring to the root of 
 * the UNC, we MUST have a trailing \ and we can't use /s. Jeez. 
 * Not sure if this refers to all UNCs or just roots,
 * but I'm going to fix it for all cases for now. (Ben)
 */

#undef stat
API_EXPORT(int) os_stat(const char *szPath, struct stat *pStat)
{
    int n;
    int len = strlen(szPath);
    
    if ((len == 0) || (len >= MAX_PATH)) {
        return -1;
    }

    if (szPath[0] == '/' && szPath[1] == '/') {
	char buf[_MAX_PATH];
	char *s;
	int nSlashes = 0;

	strcpy(buf, szPath);
	for (s = buf; *s; ++s) {
	    if (*s == '/') {
		*s = '\\';
		++nSlashes;
	    }
	}
	/* then we need to add one more to get \\machine\share\ */
	if (nSlashes == 3) {
            if (++len >= MAX_PATH) {
                return -1;
            }
	    *s++ = '\\';
	}
	*s = '\0';
	return stat(buf, pStat);
    }

    /*
     * Below removes the trailing /, however, do not remove
     * it in the case of 'x:/' or stat will fail
     */
    n = strlen(szPath);
    if ((szPath[n - 1] == '\\' || szPath[n - 1] == '/') &&
        !(n == 3 && szPath[1] == ':')) {
        char buf[_MAX_PATH];
        
        ap_assert(n < _MAX_PATH);
        strcpy(buf, szPath);
        buf[n - 1] = '\0';
        
        return stat(buf, pStat);
    }
    return stat(szPath, pStat);
}

/* Fix two really crap problems with Win32 spawn[lv]e*:
 *
 *  1. Win32 doesn't deal with spaces in argv.
 *  2. Win95 doesn't like / in cmdname.
 */

#undef _spawnv
API_EXPORT(int) os_spawnv(int mode, const char *cmdname,
			  const char *const *argv)
{
    int n;
    char **aszArgs;
    const char *szArg;
    char *szCmd;
    char *s;
    
    szCmd = _alloca(strlen(cmdname)+1);
    strcpy(szCmd, cmdname);
    for (s = szCmd; *s; ++s) {
        if (*s == '/') {
            *s = '\\';
	}
    }

    for (n = 0; argv[n]; ++n)
        ;

    aszArgs = _alloca((n + 1) * sizeof(const char *));

    for (n = 0; szArg = argv[n]; ++n) {
        if (strchr(szArg, ' ')) {
            int l = strlen(szArg);

            aszArgs[n] = _alloca(l + 2 + 1);
            aszArgs[n][0] = '"';
            strcpy(&aszArgs[n][1], szArg);
            aszArgs[n][l + 1] = '"';
            aszArgs[n][l + 2] = '\0';
        }
        else {
            aszArgs[n] = (char *)szArg;
        }
    }

    aszArgs[n] = NULL;

    return _spawnv(mode, szCmd, aszArgs);
}

#undef _spawnve
API_EXPORT(int) os_spawnve(int mode, const char *cmdname,
			   const char *const *argv, const char *const *envp)
{
    int n;
    char **aszArgs;
    const char *szArg;
    char *szCmd;
    char *s;
    
    szCmd = _alloca(strlen(cmdname)+1);
    strcpy(szCmd, cmdname);
    for (s = szCmd; *s; ++s) {
        if (*s == '/') {
            *s = '\\';
	}
    }
    
    for (n = 0; argv[n]; ++n)
        ;

    aszArgs = _alloca((n + 1)*sizeof(const char *));

    for (n = 0; szArg = argv[n]; ++n){
        if (strchr(szArg, ' ')) {
            int l = strlen(szArg);

            aszArgs[n] = _alloca(l + 2 + 1);
            aszArgs[n][0] = '"';
            strcpy(&aszArgs[n][1], szArg);
            aszArgs[n][l + 1] = '"';
            aszArgs[n][l + 2] = '\0';
        }
        else {
            aszArgs[n] = (char *)szArg;
        }
    }

    aszArgs[n] = NULL;

    return _spawnve(mode, szCmd, aszArgs, envp);
}

API_EXPORT_NONSTD(int) os_spawnle(int mode, const char *cmdname, ...)
{
    int n;
    va_list vlist;
    char **aszArgs;
    const char *szArg;
    const char *const *aszEnv;
    char *szCmd;
    char *s;
    
    szCmd = _alloca(strlen(cmdname)+1);
    strcpy(szCmd, cmdname);
    for (s = szCmd; *s; ++s) {
        if (*s == '/') {
            *s = '\\';
	}
    }

    va_start(vlist, cmdname);
    for (n = 0; va_arg(vlist, const char *); ++n)
        ;
    va_end(vlist);

    aszArgs = _alloca((n + 1) * sizeof(const char *));

    va_start(vlist, cmdname);
    for (n = 0; szArg = va_arg(vlist, const char *); ++n) {
        if (strchr(szArg, ' ')) {
            int l = strlen(szArg);

            aszArgs[n] = _alloca(l + 2 + 1);
            aszArgs[n][0] = '"';
            strcpy(&aszArgs[n][1], szArg);
            aszArgs[n][l + 1] = '"';
            aszArgs[n][l + 2] = '\0';
        }
        else {
            aszArgs[n] = (char *)szArg;
        }
    }

    aszArgs[n] = NULL;

    aszEnv = va_arg(vlist, const char *const *);
    va_end(vlist);
    
    return _spawnve(mode, szCmd, aszArgs, aszEnv);
}

#undef strftime

/* Partial replacement for strftime. This adds certain expandos to the
 * Windows version
 */

API_EXPORT(int) os_strftime(char *s, size_t max, const char *format,
                            const struct tm *tm) {
   /* If the new format string is bigger than max, the result string probably
    * won't fit anyway. When %-expandos are added, made sure the padding below
    * is enough.
    */
    char *new_format = (char *) _alloca(max + 11);
    size_t i, j, format_length = strlen(format);
    int return_value;
    int length_written;

    for (i = 0, j = 0; (i < format_length && j < max);) {
        if (format[i] != '%') {
            new_format[j++] = format[i++];
            continue;
        }
        switch (format[i+1]) {
            case 'D':
                /* Is this locale dependent? Shouldn't be...
                   Also note the year 2000 exposure here */
                memcpy(new_format + j, "%m/%d/%y", 8);
                i += 2;
                j += 8;
                break;
            case 'r':
                memcpy(new_format + j, "%I:%M:%S %p", 11);
                i += 2;
                j += 11;
                break;
            case 'T':
                memcpy(new_format + j, "%H:%M:%S", 8);
                i += 2;
                j += 8;
                break;
            case 'e':
                length_written = ap_snprintf(new_format + j, max - j, "%2d",
                    tm->tm_mday);
                j = (length_written == -1) ? max : (j + length_written);
                i += 2;
                break;
            default:
                /* We know we can advance two characters forward here. */
                new_format[j++] = format[i++];
                new_format[j++] = format[i++];
        }
    }
    if (j >= max) {
        *s = '\0';  /* Defensive programming, okay since output is undefined */
        return_value = 0;
    } else {
        new_format[j] = '\0';
        return_value = strftime(s, max, new_format, tm);
    }
    return return_value;
}
d548 1
a548 1
    len = ap_snprintf(errstr, sizeof(errstr) - len, "(%d) ", nErrorCode);
d571 2
@


1.4
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d37 1
a37 1
    char *p, *q;
d46 1
a46 1
    buf[0] = '\0';
d55 1
a55 1
    p = pInputName;
d58 6
a63 3
        buf[0] = tolower(*p++);
        buf[1] = *p++;
        buf[2] = '\0';
d66 1
a66 1
        if (strlen(pInputName) == 2)
d68 2
a69 3
    }
    
    q = p;
d71 2
a72 2
        p++;
        if (*p == '\\')  /* Possible UNC name */
a73 1
            p++;
d76 3
a78 1
            p = strchr(p, '\\'); 
d86 6
a91 1
                    strncat(buf,q,p-q);
d97 2
a98 1
            if (!p)
d100 1
d130 2
a131 2
                    strcat(buf,"\\");
                strcat(buf, wfd.cFileName);
d136 5
a140 1
            strcat(buf, q);
d152 1
d154 1
a154 1
    /* First convert all slashes to / so server code handles it ok */
d232 11
a242 3
     */
    p = strchr(pNewStr, '~');
    if (p != NULL) {
a287 1

d313 1
d315 1
a315 1
    if (strlen(szPath) == 0) {
a323 1
	ap_assert(strlen(szPath) < _MAX_PATH);
d333 3
d452 1
a452 1
API_EXPORT(int) os_spawnle(int mode, const char *cmdname, ...)
d608 1
a608 1
    if (strlen(file) > MAX_PATH) {
d702 66
@


1.3
log
@Apache 1.3.4 merge
@
text
@d574 1
a574 1
    char seglength;
d624 2
a625 2
	int idx;
	int baselength;
d645 1
a645 1
	    if (segstart[idx] < 32 ||
d668 2
a669 1
		if (!strnicmp(invalid_filenames[idx], segstart, baselength)) {
@


1.2
log
@Apache 1.3.3 merge + proxy_segv fix
@
text
@d4 2
d10 24
a33 3
/* Returns TRUE if the path is real, FALSE if it is PATH_INFO */
static BOOL sub_canonical_filename(char *szCanon, unsigned nCanon,
				   const char *szInFile)
d36 17
a52 21
    int n;
    char *szFilePart;
    char *s;
    int nSlashes;
    WIN32_FIND_DATA d;
    HANDLE h;
    const char *szFile;

    szFile = szInFile;
    s = strrchr(szFile, '\\');
    for (nSlashes = 0; s > szFile && s[-1] == '\\'; ++nSlashes, --s)
	;

    if (strlen(szFile)==2 && szFile[1]==':') {
        /*
         * If the file name is x:, do not call GetFullPathName
         * because it will use the current path of the executable
         */
        strcpy(buf,szFile);
        n = strlen(buf);
        szFilePart = buf + n;
d54 11
a64 2
    else {
        n = GetFullPathName(szFile, sizeof buf, buf, &szFilePart);
d66 22
a87 2
    ap_assert(n);
    ap_assert(n < sizeof buf);
d89 3
a91 15
    /*
     * There is an implicit assumption that szInFile will contain a '\'.
     * If this is not true (as in the case of <Directory *> or
     * <File .htaccess>) we would assert in some of the code below.  Therefore,
     * if we don't get any '\' in the file name, then use the file name we get
     * from GetFullPathName, because it will have at least one '\'.  If there
     * is no '\' in szInFile, it must just be a file name, so it should be
     * valid to use the name from GetFullPathName.  Be sure to adjust the
     * 's' variable so the rest of the code functions normally.
     * Note it is possible to get here when szFile == 'x:', but that is OK
     * because we will bail out of this routine early.
     */
    if (!s) {
        szFile = buf;
        s = strrchr(szFile, '\\');
d94 1
a94 7
    /* If we have \\machine\share, convert to \\machine\share\ */
    if (buf[0] == '\\' && buf[1] == '\\') {
	char *s = strchr(buf + 2, '\\');
	if (s && !strchr(s + 1, '\\')) {
	    strcat(s + 1, "\\");
	}
    }
d96 41
a136 5
    if (!strchr(buf, '*') && !strchr(buf, '?')) {
        h = FindFirstFile(buf, &d);
        if (h != INVALID_HANDLE_VALUE) {
            FindClose(h);
	}
d138 5
a142 2
    else {
        h = INVALID_HANDLE_VALUE;
d145 1
a145 58
    if (szFilePart < buf + 3) {
	ap_assert(strlen(buf) < nCanon);
        strcpy(szCanon, buf);
	/* a \ at the start means it is UNC, otherwise it is x: */
	if (szCanon[0] != '\\') {
	    ap_assert(ap_isalpha(szCanon[0]));
	    ap_assert(szCanon[1] == ':');
	    szCanon[2] = '/';
	}
	else {
	    char *s;

	    ap_assert(szCanon[1] == '\\');
	    for (s = szCanon; *s; ++s) {
		if (*s == '\\') {
		    *s = '/';
		}
	    }
	}
        return TRUE;
    }
    if (szFilePart != buf + 3) {
        char b2[_MAX_PATH];
	char b3[_MAX_PATH];
        ap_assert(szFilePart > buf + 3);
	/* avoid SEGVs on things like "Directory *" */
	ap_assert(s >= szFile && "this is a known bug");

	memcpy(b3, szFile, s - szFile);
	b3[s - szFile] = '\0';

/*        szFilePart[-1] = '\0'; */
        sub_canonical_filename(b2, sizeof b2, b3);

	ap_assert(strlen(b2)+1 < nCanon);
        strcpy(szCanon, b2);
        strcat(szCanon, "/");
    }
    else {
	ap_assert(strlen(buf) < nCanon);
        strcpy(szCanon, buf);
        szCanon[2] = '/';
        szCanon[3] = '\0';
    }
    if (h == INVALID_HANDLE_VALUE) {
	ap_assert(strlen(szCanon) + strlen(szFilePart) + nSlashes < nCanon);
	for (n = 0; n < nSlashes; ++n) {
	    strcat(szCanon, "/");
	}
        strcat(szCanon, szFilePart);
	return FALSE;
    }
    else {
	ap_assert(strlen(szCanon)+strlen(d.cFileName) < nCanon);
        strlwr(d.cFileName);
        strcat(szCanon, d.cFileName);
	return TRUE;
    }
d148 3
a150 3
/* UNC requires backslashes, hence the conversion before canonicalisation. 
 * Not sure how * many backslashes (could be that 
 * \\machine\share\some/path/is/ok for example). For now, do them all.
d152 2
a153 1
API_EXPORT(char *) ap_os_canonical_filename(pool *pPool, const char *szFile)
d155 14
a168 13
    char buf[HUGE_STRING_LEN];
    char b2[HUGE_STRING_LEN];
    const char *s;
    char *d;
    int nSlashes = 0;

    ap_assert(strlen(szFile) < sizeof b2);

    /* Eliminate directories consisting of three or more dots.
     * These act like ".." but are not detected by other machinery.
     * Also get rid of trailing .s on any path component, which are ignored
     * by the filesystem.  Simultaneously, rewrite / to \.
     * This is a bit of a kludge - Ben.
d170 18
a187 9
    if (strlen(szFile) == 1) {
        /*
         * If the file is only one char (like in the case of / or .) then
	 * just pass that through to sub_canonical_filename.  Convert a
	 * '/' to '\\' if necessary.
         */
        if (szFile[0] == '/') {
            b2[0] = '\\';
	}
d189 17
a205 2
            b2[0] = szFile[0];
	}
d207 20
a226 16
        b2[1] = '\0';
    }
    else {
        for (s = szFile, d = b2; (*d = *s); ++d, ++s) {
	    if (*s == '/') {
		*d = '\\';
	    }
	    if (*s == '.' && (s[1] == '/' || s[1] == '\\' || !s[1])) {
		while (*d == '.') {
		    --d;
		}
		if (*d == '\\') {
		    --d;
		}
	    }
	}
d228 3
a230 16
        /* Finally, a trailing slash(es) screws thing, so blow them away */
        for (nSlashes = 0; d > b2 && d[-1] == '\\'; --d, ++nSlashes)
	    ;
        /* XXXX this breaks '/' and 'c:/' cases */
        *d = '\0';
    }
    sub_canonical_filename(buf, sizeof buf, b2);

    buf[0] = ap_tolower(buf[0]);

    if (nSlashes) {
        /*
         * If there were additional trailing slashes, add them back on.
         * Be sure not to add more than were originally there though,
         * by checking to see if sub_canonical_filename added one;
         * this could happen in cases where the file name is 'd:/'
d232 26
a257 1
        ap_assert(strlen(buf)+nSlashes < sizeof buf);
d259 1
a259 2
        if (nSlashes && buf[strlen(buf)-1] == '/')
            nSlashes--;
d261 1
a261 2
        while (nSlashes--) {
            strcat(buf, "/");
d265 12
a276 1
    return ap_pstrdup(pPool, buf);
d291 3
a293 10

    /* be sure it is has a drive letter or is a UNC path; everything
     * _must_ be canonicalized before getting to this point.  
     */
    if (szPath[1] != ':' && szPath[1] != '/') {
	ap_log_error(APLOG_MARK, APLOG_ERR, NULL, 
		     "Invalid path in os_stat: \"%s\", "
		     "should have a drive letter or be a UNC path",
		     szPath);
	return (-1);
d296 1
a296 1
    if (szPath[0] == '/') {
d474 202
@


1.1
log
@Initial revision
@
text
@d26 12
a37 1
    n = GetFullPathName(szFile, sizeof buf, buf, &szFilePart);
d50 2
d196 15
a210 3
    ap_assert(strlen(buf)+nSlashes < sizeof buf);
    while (nSlashes--) {
        strcat(buf, "/");
d261 4
d266 2
a267 1
    if (szPath[n - 1] == '\\' || szPath[n - 1] == '/') {
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d1 1
a1 60
/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

#ifdef WIN32

a3 2
#include <time.h>
#include <stdlib.h>
d8 3
a10 4
/* Returns TRUE if the input string is a string
 * of one or more '.' characters.
 */
static BOOL OnlyDots(char *pString)
d12 32
a43 1
    char *c;
d45 7
a51 2
    if (*pString == '\0')
        return FALSE;
d53 9
a61 3
    for (c = pString;*c;c++)
        if (*c != '.')
            return FALSE;
d63 58
a120 1
    return TRUE;
d123 3
a125 8

/* Accepts as input a pathname, and tries to match it to an 
 * existing path and return the pathname in the case that
 * is present on the existing path.  This routine also
 * converts alias names to long names.
 *
 * WARNING: Folding to systemcase fails when /path/to/foo/../bar
 * is given and foo does not exist, is not a directory.
d127 1
a127 2
API_EXPORT(char *) ap_os_systemcase_filename(pool *pPool, 
                                             const char *szFile)
d129 19
a147 27
    char *buf, *t, *r;
    const char *q, *p;
    BOOL bDone = FALSE;
    BOOL bFileExists = TRUE;
    HANDLE hFind;
    WIN32_FIND_DATA wfd;
    size_t buflen;
    int slack = 0;

    if (!szFile || strlen(szFile) == 0)
        return ap_pstrdup(pPool, "");

    buflen = strlen(szFile);
    t = buf = ap_palloc(pPool, buflen + 1);
    q = szFile;

    /* If there is drive information, copy it over. */ 
    if (szFile[1] == ':') {
        /* Lowercase, so that when systemcase is used for
         * comparison, d: designations will match
         */                 
        *(t++) = tolower(*(q++));
        *(t++) = *(q++);
    }
    else if ((*q == '/') || (*q == '\\')) {
        /* Get past the root path (/ or //foo/bar/) so we can go
         * on to normalize individual path elements.
d149 8
a156 47
        *(t++) = '\\', ++q;
        if ((*q == '/') || (*q == '\\'))  /* UNC name */
        {
                /* Lower-case the machine name, so compares match.
                 * FindFirstFile won't parse \\machine alone
                 */
            *(t++) = '\\', ++q;
            for (p = q; *p && (*p != '/') && (*p != '\\'); ++p)
                /* continue */ ;
            if (*p || p > q) 
            {
                /* Lower-case the machine name, so compares match.
                 * FindFirstFile won't parse \\machine\share alone
                 */
                memcpy(t, q, p - q);
                t[p - q] = '\0';
                strlwr(t);
                t += p - q;
                q = p;
                if (*p) {
                    *(t++) = '\\', ++q;
                    for (p = q; *p && (*p != '/') && (*p != '\\'); ++p)
                        /* continue */ ;
                    if (*p || p > q) 
                    {
                        /* Copy the lower-cased share name.  FindFirstFile 
                         * cannot not find a \\machine\share name only 
                         */
                        memcpy(t, q, p - q);
                        t[p - q] = '\0';
                        strlwr(t);
                        t += p - q;
                        q = p;
                        if (*p)
                            *(t++) = '\\', ++q;
                        else
                            bFileExists = FALSE;
                    }
                    else
                        bFileExists = FALSE;
                }
                else
                    bFileExists = FALSE;
            }
            else
                bFileExists = FALSE;
        }
d158 14
d173 7
a179 1
    while (bFileExists) {
d181 1
a181 22
        /* parse past any leading slashes */
        for (; (*q == '/') || (*q == '\\'); ++q)
            *(t++) = '\\';

        /* break on end of string */
        if (!*q)
            break;

        /* get to the end of this path segment */
        for (p = q; *p && (*p != '/') && (*p != '\\'); ++p)
            /* continue */ ;
                
        /* copy the segment */
        memcpy(t, q, p - q);
        t[p - q] = '\0';

        /* Test for nasties that can exhibit undesired effects */
        if (strpbrk(t, "?\"<>*|:")) {
            t += p - q;
            q = p;
            break;
        }
d183 3
a185 51
        /* If the path exists so far, call FindFirstFile
         * again.  However, if this portion of the path contains
         * only '.' charaters, skip the call to FindFirstFile
         * since it will convert '.' and '..' to actual names.
         * On win32, '...' is an alias for '..', so we gain 
         * a bit of slack.
         */
        if (*t == '.' && OnlyDots(t)) {
            if (p - q == 3) {
                t += 2;
                q = p;
                ++slack;
            }
            else {
                t += p - q;
                q = p;
            }
            /* Paths of 4 dots or more are invalid */
            if (p - q > 3)
                break;
        }
        else {
            if ((hFind = FindFirstFile(buf, &wfd)) == INVALID_HANDLE_VALUE) {
                t += p - q;
                q = p;
                break;
            }
            else {
                size_t fnlen = strlen(wfd.cFileName);
                FindClose(hFind);
                /* the string length just changed, could have shrunk
                 * (trailing spaces or dots) or could have grown 
                 * (longer filename aliases).  Realloc as necessary
                 */
                slack -= fnlen - (p - q);
                if (slack < 0) {
                    char *n;
                    slack += buflen + fnlen - (p - q);
                    buflen += buflen + fnlen - (p - q);
                    n = ap_palloc(pPool, buflen + 1);
                    memcpy (n, buf, t - buf);
                    t = n + (t - buf);
                    buf = n;
                }
                memcpy(t, wfd.cFileName, fnlen);
                t += fnlen;
                q = p;
                if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                    break;
            }
        }
d188 18
a205 2
    /* Convert all parsed '\'s to '/' for canonical form (doesn't touch
     * the non-existant portion of the path whatsoever.)
d207 27
a233 3
    for (r = buf; r < t; ++r) {
        if (*r == '\\')
            *r = '/';
d236 11
a246 4
    /* Copy the non-existant portion (minimally nul-terminates the string) */
    strcpy(t, q);
    
    return buf;
d249 5
d255 3
a257 5
/*  Perform canonicalization with the exception that the
 *  input case is preserved.
 */
API_EXPORT(char *) ap_os_case_canonical_filename(pool *pPool, 
                                                 const char *szFile)
d259 4
a262 1
    char *pNewStr;
d264 8
a271 2
    char *p; 
    char *q;
d273 2
a274 2
    if (szFile == NULL || strlen(szFile) == 0)
        return ap_pstrdup(pPool, "");
d276 1
a276 1
    pNewStr = ap_pstrdup(pPool, szFile);
d278 9
a286 22
    /*  Change all '\' characters to '/' characters.
     *  While doing this, remove any trailing '.'.
     *  Also, blow away any directories with 3 or
     *  more '.'
     */
    for (p = pNewStr,s = pNewStr; *s; s++,p++) {
        if (*s == '\\' || *s == '/') {

            q = p;
            while (p > pNewStr && *(p-1) == '.')
                p--;

            if (p == pNewStr && q-p <= 2 && *p == '.')
                p = q;
            else if (p > pNewStr && p < q && *(p-1) == '/') {
                if (q-p > 2)
                    p--;
                else
                    p = q;
            }

            *p = '/';
d289 1
a289 1
            *p = *s;
a291 14
    *p = '\0';

    /*  Blow away any final trailing '.' since on Win32
     *  foo.bat == foo.bat. == foo.bat... etc.
     *  Also blow away any trailing spaces since
     *  "filename" == "filename "
     */
    q = p;
    while (p > pNewStr && (*(p-1) == '.' || *(p-1) == ' '))
        p--;
    if ((p > pNewStr) ||
        (p == pNewStr && q-p > 2))
        *p = '\0';
        
d293 1
a293 24
    /*  One more security issue to deal with.  Win32 allows
     *  you to create long filenames.  However, alias filenames
     *  are always created so that the filename will
     *  conform to 8.3 rules.  According to the Microsoft
     *  Developer's network CD (1/98) 
     *  "Automatically generated aliases are composed of the 
     *   first six characters of the filename plus ~n 
     *   (where n is a number) and the first three characters 
     *   after the last period."
     *  Here, we attempt to detect and decode these names.
     *
     *  XXX: Netware network clients may have alternate short names,
     *  simply truncated, with no embedded '~'.  Further, this behavior
     *  can be modified on WinNT volumes.  This was not a safe test,
     *  therefore exclude the '~' pretest.
     */
#ifdef WIN32_SHORT_FILENAME_INSECURE_BEHAVIOR
     p = strchr(pNewStr, '~');
     if (p != NULL)
#endif
    /* ap_os_systemcase_filename now changes the case of only
     * the pathname elements that are found.
     */
        pNewStr = ap_os_systemcase_filename(pPool, pNewStr);
d295 1
a295 1
    return pNewStr;
d298 3
a300 3
/*  Perform complete canonicalization.
 */
API_EXPORT(char *) ap_os_canonical_filename(pool *pPool, const char *szFile)
d302 11
a312 89
    char *pNewName;
    pNewName = ap_os_case_canonical_filename(pPool, szFile);
    strlwr(pNewName);
    return pNewName;
}


/*
 * ap_os_is_filename_valid is given a filename, and returns 0 if the filename
 * is not valid for use on this system. On Windows, this means it fails any
 * of the tests below. Otherwise returns 1.
 *
 * Test for filename validity on Win32. This is of tests come in part from
 * the MSDN article at "Technical Articles, Windows Platform, Base Services,
 * Guidelines, Making Room for Long Filenames" although the information
 * in MSDN about filename testing is incomplete or conflicting. There is a
 * similar set of tests in "Technical Articles, Windows Platform, Base Services,
 * Guidelines, Moving Unix Applications to Windows NT".
 *
 * The tests are:
 *
 * 1) total path length greater than MAX_PATH
 *
 * 2) anything using the octets 0-31 or characters " < > | :
 *    (these are reserved for Windows use in filenames. In addition
 *     each file system has its own additional characters that are
 *     invalid. See KB article Q100108 for more details).
 *
 * 3) anything ending in "." (no matter how many)
 *    (filename doc, doc. and doc... all refer to the same file)
 *
 * 4) any segment in which the basename (before first period) matches
 *    one of the DOS device names
 *    (the list comes from KB article Q100108 although some people
 *     reports that additional names such as "COM5" are also special
 *     devices).
 *
 * If the path fails ANY of these tests, the result must be to deny access.
 */

API_EXPORT(int) ap_os_is_filename_valid(const char *file)
{
    const char *segstart;
    unsigned int seglength;
    const char *pos;
    static const char * const invalid_characters = "?\"<>*|:";
    static const char * const invalid_filenames[] = { 
	"CON", "AUX", "COM1", "COM2", "COM3", 
	"COM4", "LPT1", "LPT2", "LPT3", "PRN", "NUL", NULL 
    };

    /* Test 1 */
    if (strlen(file) >= MAX_PATH) {
	/* Path too long for Windows. Note that this test is not valid
	 * if the path starts with //?/ or \\?\. */
	return 0;
    }

    pos = file;

    /* Skip any leading non-path components. This can be either a
     * drive letter such as C:, or a UNC path such as \\SERVER\SHARE\.
     * We continue and check the rest of the path based on the rules above.
     * This means we could eliminate valid filenames from servers which
     * are not running NT (such as Samba).
     */

    if (pos[0] && pos[1] == ':') {
	/* Skip leading drive letter */
	pos += 2;
    }
    else {
	if ((pos[0] == '\\' || pos[0] == '/') &&
	    (pos[1] == '\\' || pos[1] == '/')) {
	    /* Is a UNC, so skip the server name and share name */
	    pos += 2;
	    while (*pos && *pos != '/' && *pos != '\\')
		pos++;
	    if (!*pos) {
		/* No share name */
		return 0;
	    }
	    pos++;	/* Move to start of share name */
	    while (*pos && *pos != '/' && *pos != '\\')
		pos++;
	    if (!*pos) {
		/* No path information */
		return 0;
	    }
d315 3
d319 1
a319 27
    while (*pos) {
	unsigned int idx;
	unsigned int baselength;

	while (*pos == '/' || *pos == '\\') {
    	    pos++;
	}
	if (*pos == '\0') {
	    break;
	}
	segstart = pos;	/* start of segment */
	while (*pos && *pos != '/' && *pos != '\\') {
	    pos++;
	}
	seglength = pos - segstart;
	/* 
	 * Now we have a segment of the path, starting at position "segstart"
	 * and length "seglength"
	 */

	/* Test 2 */
	for (idx = 0; idx < seglength; idx++) {
	    if ((segstart[idx] > 0 && segstart[idx] < 32) ||
		strchr(invalid_characters, segstart[idx])) {
		return 0;
	    }
	}
d321 14
a334 4
	/* Test 3 */
	if (segstart[seglength-1] == '.') {
	    return 0;
	}
d336 1
a336 19
	/* Test 4 */
	for (baselength = 0; baselength < seglength; baselength++) {
	    if (segstart[baselength] == '.') {
		break;
	    }
	}

	/* baselength is the number of characters in the base path of
	 * the segment (which could be the same as the whole segment length,
	 * if it does not include any dot characters). */
	if (baselength == 3 || baselength == 4) {
	    for (idx = 0; invalid_filenames[idx]; idx++) {
		if (strlen(invalid_filenames[idx]) == baselength &&
		    !strnicmp(invalid_filenames[idx], segstart, baselength)) {
		    return 0;
		}
	    }
	}
    }
d338 1
a338 1
    return 1;
d341 1
a341 2

API_EXPORT(ap_os_dso_handle_t) ap_os_dso_load(const char *module_name)
d343 7
a349 15
    UINT em;
    ap_os_dso_handle_t dsoh;
    char path[MAX_PATH], *p;
    /* Load the module...
     * per PR2555, the LoadLibraryEx function is very picky about slashes.
     * Debugging on NT 4 SP 6a reveals First Chance Exception within NTDLL.
     * LoadLibrary in the MS PSDK also reveals that it -explicitly- states
     * that backslashes must be used.
     *
     * Transpose '\' for '/' in the filename.
     */
    ap_cpystrn(path, module_name, MAX_PATH);
    p = path;
    while (p = strchr(p, '/'))
        *p = '\\';
d351 29
a379 8
    /* First assume the dso/dll's required by -this- dso are sitting in the 
     * same path or can be found in the usual places.  Failing that, let's
     * let that dso look in the apache root.
     */
    em = SetErrorMode(SEM_FAILCRITICALERRORS);
    dsoh = LoadLibraryEx(path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (!dsoh) {
        dsoh = LoadLibraryEx(path, NULL, 0);
a380 3
    SetErrorMode(em);
    return dsoh;
}
d382 4
a385 8
API_EXPORT(const char *) ap_os_dso_error(void)
{
    int len, nErrorCode;
    static char errstr[120];
    /* This is -not- threadsafe code, but it's about the best we can do.
     * mostly a potential problem for isapi modules, since LoadModule
     * errors are handled within a single config thread.
     */
d387 1
a387 23
    nErrorCode = GetLastError();
    len = ap_snprintf(errstr, sizeof(errstr), "(%d) ", nErrorCode);

    len += FormatMessage( 
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            nErrorCode,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), /* Default language */
            (LPTSTR) errstr + len,
            sizeof(errstr) - len,
            NULL 
        );
        /* FormatMessage may have appended a newline (\r\n). So remove it 
         * and use ": " instead like the Unix errors. The error may also
         * end with a . before the return - if so, trash it.
         */
    if (len > 1 && errstr[len-2] == '\r' && errstr[len-1] == '\n') {
        if (len > 2 && errstr[len-3] == '.')
            len--;
        errstr[len-2] = ':';
        errstr[len-1] = ' ';
    }
    return errstr;
a388 2

#endif /* WIN32 */@


1.1.1.3
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
@


