head	1.11;
access;
symbols
	OPENBSD_5_5:1.10.0.24
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.20
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.18
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.16
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.14
	OPENBSD_5_0:1.10.0.12
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.10
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.3
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.2
	apache_1_3_27:1.1.1.2
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.1.1.0.10
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.8
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.6
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.10;

1.10
date	2008.10.06.20.50.18;	author mbalmer;	state Exp;
branches;
next	1.9;

1.9
date	2008.10.03.19.37.44;	author mbalmer;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.23.12.12.01;	author mbalmer;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.17.23.31.52;	author sobrado;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.02.19.42.48;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.21.13.11.41;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.08.17.57.33;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.29.02.08.08;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.22.18.42;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.52;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.52;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.29.24;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.21.12.53.45;	author henning;	state Exp;
branches;
next	;


desc
@@


1.11
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*	$OpenBSD: rotatelogs.c,v 1.10 2008/10/06 20:50:18 mbalmer Exp $ */

/*
 * Simple program to rotate Apache logs without having to kill the server.
 *
 * Contributed by Ben Laurie <ben@@algroup.co.uk>
 *
 * 12 Mar 1996
 */

#include <time.h>
#include <errno.h>
#include <fcntl.h>

#include "ap_config.h"

#define BUFSIZE        65536
#define ERRMSGSZ       82
#ifndef MAX_PATH
#define MAX_PATH       1024
#endif

int
main(int argc, char *argv[])
{
	char buf[BUFSIZE], buf2[MAX_PATH], errbuf[ERRMSGSZ];
	time_t tLogEnd = 0, tRotation;
	int nLogFD = -1, nLogFDprev = -1, nMessCount = 0, nRead, nWrite;
	int utc_offset = 0;
	int use_strftime = 0;
	time_t now;
	char *szLogRoot;

	if (argc < 3) {
		fprintf(stderr, "usage: %s logfile rotationtime [offset]\n\n",
		    argv[0]);
		fprintf(stderr, "Add this:\n\nTransferLog \"|%s /some/where "
		    "86400\"\n\n", argv[0]);
		fprintf(stderr,
		    "to httpd.conf. The generated name will be /some/where.nnnn"
		    " where nnnn is the\nsystem time at which the log nominally"
		    " starts (N.B. this time will always be a\nmultiple of the "
		    "rotation time, so you can synchronize cron scripts with "
		    "it).\nAt the end of each rotation time a new log is "
		    "started.\n");
		exit(1);
	}

	szLogRoot = argv[1];
	if (argc >= 4)
		utc_offset = atoi(argv[3]) * 60;

	tRotation = atoi(argv[2]);
	if (tRotation <= 0) {
		fprintf(stderr, "Rotation time must be > 0\n");
		exit(6);
	}

	use_strftime = (strstr(szLogRoot, "%") != NULL);
	for (;;) {
		nRead = read(0, buf, sizeof buf);
		now = time(NULL) + utc_offset;
		if (nRead == 0)
			exit(3);
		if (nRead < 0)
			if (errno != EINTR)
				exit(4);
		if (nLogFD >= 0 && (now >= tLogEnd || nRead < 0)) {
			nLogFDprev = nLogFD;
			nLogFD = -1;
		}
		if (nLogFD < 0) {
			time_t tLogStart = (now / tRotation) * tRotation;
			if (use_strftime) {
				struct tm *tm_now;
				tm_now = gmtime(&tLogStart);
				strftime(buf2, sizeof(buf2), szLogRoot, tm_now);
			} else
				snprintf(buf2, sizeof(buf2), "%s.%010d",
				    szLogRoot, (int)tLogStart);

			tLogEnd = tLogStart + tRotation;
			do {
				nLogFD = open(buf2, O_WRONLY | O_CREAT |
				    O_APPEND, 0666);
				if (nLogFD < 0 && nLogFDprev == -1) {
					fprintf(stderr, "rotatelogs: can't "
					    "open %s for writing: %s\n", buf2,
					    strerror(errno));
					sleep(2);
				}
			} while (nLogFD < 0 && nLogFDprev == -1);
			if (nLogFD < 0) {
				/*
				 * Uh-oh. Failed to open the new log file. Try
				 * to clear the previous log file, note the
				 * lost log entries, and keep on truckin'.
				 */
				nLogFD = nLogFDprev;
				snprintf(errbuf, sizeof(errbuf),
				    "Resetting log file due to error opening "
				    "new log file. %10d messages lost.\n",
				    nMessCount); 
				nWrite = strlen(errbuf);
				ftruncate(nLogFD, 0);
				write(nLogFD, errbuf, nWrite);
			} else
				close(nLogFDprev);
			nMessCount = 0;
		}
		do {
			nWrite = write(nLogFD, buf, nRead);
		} while (nWrite < 0 && errno == EINTR);
		if (nWrite != nRead) {
			nMessCount++;
			snprintf(errbuf, sizeof(errbuf),
			    "Error writing to log file. "
			    "%10d messages lost.\n", nMessCount);
			nWrite = strlen(errbuf);
			ftruncate(nLogFD, 0);
			write (nLogFD, errbuf, nWrite);
		} else
			nMessCount++; 
	}

	/* We never get here, but suppress the compile warning */
	return 0;
}
@


1.10
log
@Don't exit if the logfile specified on the command line can not be
created due to a path component not existing, but log the error and
retry.  This will repeatetly log an error, like it does without the patch,
but it will not slowly eat up memory.  This fixes pr 4228.
@
text
@d1 1
a1 1
/*	$OpenBSD: rotatelogs.c,v 1.9 2008/10/03 19:37:44 mbalmer Exp $ */
@


1.9
log
@Readability changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rotatelogs.c,v 1.8 2008/05/23 12:12:01 mbalmer Exp $ */
d83 10
a92 2
			nLogFD = open(buf2, O_WRONLY | O_CREAT | O_APPEND,
			    0666);
d99 8
a106 13
				if (nLogFDprev == -1) {
					perror(buf2);
					exit(2);
				} else {
					nLogFD = nLogFDprev;
					snprintf(errbuf, sizeof(errbuf),
					    "Resetting log file due to error "
					    "opening new log file. %10d "
					    "messages lost.\n",	nMessCount); 
					nWrite = strlen(errbuf);
					ftruncate(nLogFD, 0);
					write(nLogFD, errbuf, nWrite);
				}
@


1.8
log
@KNF and readability changes.  de-register, remove #ifndef SIN6_LEN defines.
Add OpenBSD cvs markers.

No binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d24 1
a24 1
main(int argc, char **argv)
a33 1

d122 1
d124 1
a124 1
	return (0);
@


1.7
log
@documentation tweaks.

ok (some time ago) jmc@@
@
text
@d1 2
a10 2

#include "ap_config.h"
d15 1
d23 2
a24 1
int main (int argc, char **argv)
d26 99
a124 101
    char buf[BUFSIZE], buf2[MAX_PATH], errbuf[ERRMSGSZ];
    time_t tLogEnd = 0, tRotation;
    int nLogFD = -1, nLogFDprev = -1, nMessCount = 0, nRead, nWrite;
    int utc_offset = 0;
    int use_strftime = 0;
    time_t now;
    char *szLogRoot;


    if (argc < 3) {
        fprintf(stderr, "usage: %s logfile rotationtime [offset]\n\n", argv[0]);
        fprintf(stderr,
                "Add this:\n\nTransferLog \"|%s /some/where 86400\"\n\n",
                argv[0]);
        fprintf(stderr,
                "to httpd.conf. The generated name will be /some/where.nnnn "
                "where nnnn is the\nsystem time at which the log nominally "
                "starts (N.B. this time will always be a\nmultiple of the "
                "rotation time, so you can synchronize cron scripts with it).\n"
                "At the end of each rotation time a new log is started.\n");
        exit(1);
    }

    szLogRoot = argv[1];
    if (argc >= 4) {
        utc_offset = atoi(argv[3]) * 60;
    }
    tRotation = atoi(argv[2]);
    if (tRotation <= 0) {
        fprintf(stderr, "Rotation time must be > 0\n");
        exit(6);
    }

    use_strftime = (strstr(szLogRoot, "%") != NULL);
    for (;;) {
        nRead = read(0, buf, sizeof buf);
        now = time(NULL) + utc_offset;
        if (nRead == 0)
            exit(3);
        if (nRead < 0)
            if (errno != EINTR)
                exit(4);
        if (nLogFD >= 0 && (now >= tLogEnd || nRead < 0)) {
            nLogFDprev = nLogFD;
            nLogFD = -1;
        }
        if (nLogFD < 0) {
            time_t tLogStart = (now / tRotation) * tRotation;
            if (use_strftime) {
                struct tm *tm_now;
                tm_now = gmtime(&tLogStart);
                strftime(buf2, sizeof(buf2), szLogRoot, tm_now);
            }
            else {
                snprintf(buf2, sizeof(buf2), "%s.%010d", szLogRoot, (int) tLogStart);
            }
            tLogEnd = tLogStart + tRotation;
            nLogFD = open(buf2, O_WRONLY | O_CREAT | O_APPEND, 0666);
            if (nLogFD < 0) {
                /* Uh-oh. Failed to open the new log file. Try to clear
                 * the previous log file, note the lost log entries,
                 * and keep on truckin'. */
                if (nLogFDprev == -1) {
                    perror(buf2);
                    exit(2);
                }
                else {
                    nLogFD = nLogFDprev;
                    snprintf(errbuf, sizeof(errbuf),
                            "Resetting log file due to error opening "
                            "new log file. %10d messages lost.\n",
                            nMessCount); 
                    nWrite = strlen(errbuf);
                    ftruncate(nLogFD, 0);
                    write(nLogFD, errbuf, nWrite);
                }
            }
            else {
                close(nLogFDprev);
            }
            nMessCount = 0;
        }
        do {
            nWrite = write(nLogFD, buf, nRead);
        } while (nWrite < 0 && errno == EINTR);
        if (nWrite != nRead) {
            nMessCount++;
            snprintf(errbuf, sizeof(errbuf),
                    "Error writing to log file. "
                    "%10d messages lost.\n",
                    nMessCount);
            nWrite = strlen(errbuf);
            ftruncate(nLogFD, 0);
            write (nLogFD, errbuf, nWrite);
        } 
        else {
            nMessCount++; 
        }
    }
    /* We never get here, but suppress the compile warning */
    return (0);
@


1.6
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@d34 1
a34 4
        fprintf(stderr,
                "Usage: %s <logfile> <rotation time in seconds> "
                "[offset minutes from UTC]\n\n",
                argv[0]);
@


1.5
log
@merge
@
text
@a14 3
#if defined(WIN32) || defined(OS2)
#include <io.h>
#endif
a31 5
#ifdef TPF
    /* set up signal handling to avoid default OPR-I007777 dump */
    signal(SIGPIPE, exit);
    signal(SIGTERM, exit);
#endif
a37 5
#ifdef OS2
        fprintf(stderr,
                "Add this:\n\nTransferLog \"|%s.exe /some/where 86400\"\n\n",
                argv[0]);
#else
a40 1
#endif
a59 4
#if defined(WIN32) || defined(OS2)
    setmode(0, O_BINARY);
#endif

a99 3
#ifdef WIN32
                    chsize(nLogFD, 0);
#else
a100 1
#endif
a118 3
#ifdef WIN32
            chsize(nLogFD, 0);
#else
a119 1
#endif
@


1.4
log
@string stuff, ok pval
@
text
@d15 4
d73 4
@


1.3
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d91 1
a91 1
                sprintf(buf2, "%s.%010d", szLogRoot, (int) tLogStart);
d105 1
a105 1
                    sprintf(errbuf,
d128 1
a128 1
            sprintf(errbuf,
@


1.2
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d15 2
a16 1
#define BUFSIZE		65536
d18 1
a18 1
#define MAX_PATH	1024
d23 6
a28 5
    char buf[BUFSIZE], buf2[MAX_PATH];
    time_t tLogEnd = 0;
    time_t tRotation;
    int nLogFD = -1;
    int nRead;
d31 11
a41 4
    if (argc != 3) {
	fprintf(stderr,
		"%s <logfile> <rotation time in seconds>\n\n",
		argv[0]);
d43 3
a45 3
	fprintf(stderr,
		"Add this:\n\nTransferLog \"|%s.exe /some/where 86400\"\n\n",
		argv[0]);
d47 3
a49 3
	fprintf(stderr,
		"Add this:\n\nTransferLog \"|%s /some/where 86400\"\n\n",
		argv[0]);
d51 7
a57 7
	fprintf(stderr,
		"to httpd.conf. The generated name will be /some/where.nnnn "
		"where nnnn is the\nsystem time at which the log nominally "
		"starts (N.B. this time will always be a\nmultiple of the "
		"rotation time, so you can synchronize cron scripts with it).\n"
		"At the end of each rotation time a new log is started.\n");
	exit(1);
d61 3
d66 2
a67 2
	fprintf(stderr, "Rotation time must be > 0\n");
	exit(6);
d70 1
d72 71
a142 24
	nRead = read(0, buf, sizeof buf);
	if (nRead == 0)
	    exit(3);
	if (nRead < 0)
	    if (errno != EINTR)
		exit(4);
	if (nLogFD >= 0 && (time(NULL) >= tLogEnd || nRead < 0)) {
	    close(nLogFD);
	    nLogFD = -1;
	}
	if (nLogFD < 0) {
	    time_t tLogStart = (time(NULL) / tRotation) * tRotation;
	    sprintf(buf2, "%s.%010d", szLogRoot, (int) tLogStart);
	    tLogEnd = tLogStart + tRotation;
	    nLogFD = open(buf2, O_WRONLY | O_CREAT | O_APPEND, 0666);
	    if (nLogFD < 0) {
		perror(buf2);
		exit(2);
	    }
	}
	if (write(nLogFD, buf, nRead) != nRead) {
	    perror(buf2);
	    exit(5);
	}
d144 1
a144 1
    /* We never get here, but surpress the compile warning */
@


1.1
log
@Initial revision
@
text
@a9 3
#define BUFSIZE		65536
#define MAX_PATH	1024

d15 5
d84 2
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d10 3
a17 6
#define BUFSIZE        65536
#define ERRMSGSZ       82
#ifndef MAX_PATH
#define MAX_PATH       1024
#endif

d20 5
a24 6
    char buf[BUFSIZE], buf2[MAX_PATH], errbuf[ERRMSGSZ];
    time_t tLogEnd = 0, tRotation;
    int nLogFD = -1, nLogFDprev = -1, nMessCount = 0, nRead, nWrite;
    int utc_offset = 0;
    int use_strftime = 0;
    time_t now;
d27 4
a30 11
#ifdef TPF
    /* set up signal handling to avoid default OPR-I007777 dump */
    signal(SIGPIPE, exit);
    signal(SIGTERM, exit);
#endif

    if (argc < 3) {
        fprintf(stderr,
                "Usage: %s <logfile> <rotation time in seconds> "
                "[offset minutes from UTC]\n\n",
                argv[0]);
d32 3
a34 3
        fprintf(stderr,
                "Add this:\n\nTransferLog \"|%s.exe /some/where 86400\"\n\n",
                argv[0]);
d36 3
a38 3
        fprintf(stderr,
                "Add this:\n\nTransferLog \"|%s /some/where 86400\"\n\n",
                argv[0]);
d40 7
a46 7
        fprintf(stderr,
                "to httpd.conf. The generated name will be /some/where.nnnn "
                "where nnnn is the\nsystem time at which the log nominally "
                "starts (N.B. this time will always be a\nmultiple of the "
                "rotation time, so you can synchronize cron scripts with it).\n"
                "At the end of each rotation time a new log is started.\n");
        exit(1);
a49 3
    if (argc >= 4) {
        utc_offset = atoi(argv[3]) * 60;
    }
d52 2
a53 2
        fprintf(stderr, "Rotation time must be > 0\n");
        exit(6);
a55 1
    use_strftime = (strstr(szLogRoot, "%") != NULL);
d57 24
a80 71
        nRead = read(0, buf, sizeof buf);
        now = time(NULL) + utc_offset;
        if (nRead == 0)
            exit(3);
        if (nRead < 0)
            if (errno != EINTR)
                exit(4);
        if (nLogFD >= 0 && (now >= tLogEnd || nRead < 0)) {
            nLogFDprev = nLogFD;
            nLogFD = -1;
        }
        if (nLogFD < 0) {
            time_t tLogStart = (now / tRotation) * tRotation;
            if (use_strftime) {
                struct tm *tm_now;
                tm_now = gmtime(&tLogStart);
                strftime(buf2, sizeof(buf2), szLogRoot, tm_now);
            }
            else {
                sprintf(buf2, "%s.%010d", szLogRoot, (int) tLogStart);
            }
            tLogEnd = tLogStart + tRotation;
            nLogFD = open(buf2, O_WRONLY | O_CREAT | O_APPEND, 0666);
            if (nLogFD < 0) {
                /* Uh-oh. Failed to open the new log file. Try to clear
                 * the previous log file, note the lost log entries,
                 * and keep on truckin'. */
                if (nLogFDprev == -1) {
                    perror(buf2);
                    exit(2);
                }
                else {
                    nLogFD = nLogFDprev;
                    sprintf(errbuf,
                            "Resetting log file due to error opening "
                            "new log file. %10d messages lost.\n",
                            nMessCount); 
                    nWrite = strlen(errbuf);
#ifdef WIN32
                    chsize(nLogFD, 0);
#else
                    ftruncate(nLogFD, 0);
#endif
                    write(nLogFD, errbuf, nWrite);
                }
            }
            else {
                close(nLogFDprev);
            }
            nMessCount = 0;
        }
        do {
            nWrite = write(nLogFD, buf, nRead);
        } while (nWrite < 0 && errno == EINTR);
        if (nWrite != nRead) {
            nMessCount++;
            sprintf(errbuf,
                    "Error writing to log file. "
                    "%10d messages lost.\n",
                    nMessCount);
            nWrite = strlen(errbuf);
#ifdef WIN32
            chsize(nLogFD, 0);
#else
            ftruncate(nLogFD, 0);
#endif
            write (nLogFD, errbuf, nWrite);
        } 
        else {
            nMessCount++; 
        }
a81 2
    /* We never get here, but suppress the compile warning */
    return (0);
@


1.1.1.3
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@a14 4
#if defined(WIN32) || defined(OS2)
#include <io.h>
#endif

a68 4

#if defined(WIN32) || defined(OS2)
    setmode(0, O_BINARY);
#endif
@


