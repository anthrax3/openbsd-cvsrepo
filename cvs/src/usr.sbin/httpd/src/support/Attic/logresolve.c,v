head	1.17;
access;
symbols
	OPENBSD_5_5:1.16.0.10
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.6
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.12
	OPENBSD_5_0:1.15.0.10
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.8
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.6
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.10
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.8
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.6
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.2
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.2
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.2
	apache_1_3_27:1.1.1.2
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.1.1.1.0.6
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.16;

1.16
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.21.00.38.22;	author martynas;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.23.12.12.01;	author mbalmer;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.17.23.31.52;	author sobrado;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.09.08.06.28;	author mbalmer;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.11.16.30.59;	author gilles;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.27.20.35.49;	author niallo;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.09.12.13.10;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.06.13.14.10;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.02.19.42.48;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.08.17.58.35;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.29.02.08.08;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.22.18.42;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.17.41;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.25.18.30.19;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.51;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.51;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.29.24;	author henning;	state Exp;
branches;
next	;


desc
@@


1.17
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*	$OpenBSD: logresolve.c,v 1.16 2012/03/04 04:05:15 fgsch Exp $	*/

/*
 * logresolve 1.1
 *
 * Tom Rathborne - tomr@@aceldama.com - http://www.aceldama.com/~tomr/
 * UUNET Canada, April 16, 1995
 *
 * Rewritten by David Robinson. (drtr@@ast.cam.ac.uk)
 *
 * usage: logresolve [-c] [-s filename] < access_log > access_log.new
 *
 * Arguments:
 *    -s filename     name of a file to record statistics
 *    -c              check the DNS for a matching A record for the host.
 *
 * Notes:
 *
 * To generate meaningful statistics from an HTTPD log file, it's good
 * to have the domain name of each machine that accessed your site, but
 * doing this on the fly can slow HTTPD down.
 *
 * Compiling NCSA HTTPD with the -DMINIMAL_DNS flag turns IP#->hostname
 * resolution off. Before running your stats program, just run your log
 * file through this program (logresolve) and all of your IP numbers will
 * be resolved into hostnames (where possible).
 *
 * logresolve takes an HTTPD access log (in the COMMON log file format,
 * or any other format that has the IP number/domain name as the first
 * field for that matter), and outputs the same file with all of the
 * domain names looked up. Where no domain name can be found, the IP
 * number is left in.
 *
 * To minimize impact on your nameserver, logresolve has its very own
 * internal hash-table cache. This means that each IP number will only
 * be looked up the first time it is found in the log file.
 *
 * The -c option causes logresolve to apply the same check as httpd
 * compiled with -DMAXIMUM_DNS; after finding the hostname from the IP
 * address, it looks up the IP addresses for the hostname and checks
 * that one of these matches the original address.
 */

#include "ap_config.h"
#include <sys/types.h>

#include <ctype.h>

#include <arpa/inet.h>

static void cgethost(struct sockaddr *sa, char *string, int check);
static int get_line(char *s, int n);
static void stats(FILE *output);
static void usage(void);


/* maximum line length */
#define MAXLINE 1024

/* maximum length of a domain name */
#ifndef MAXDNAME
#define MAXDNAME 256
#endif

/* number of buckets in cache hash table */
#define BUCKETS 256

/*
 * struct nsrec - record of nameservice for cache linked list
 * 
 * ipnum - IP number hostname - hostname noname - nonzero if IP number has no
 * hostname, i.e. hostname=IP number
 */
struct nsrec {
	struct sockaddr_storage	 addr;
	char			*hostname;
	int			 noname;
	struct nsrec		*next;
} *nscache[BUCKETS];

/* statistics - obvious */

#if !defined(h_errno)
extern int h_errno; /* some machines don't have this in their headers */
#endif

/* largest value for h_errno */
#define MAX_ERR (NO_ADDRESS)
#define UNKNOWN_ERR (MAX_ERR+1)
#define NO_REVERSE  (MAX_ERR+2)

static int cachehits = 0;
static int cachesize = 0;
static int entries = 0;
static int resolves = 0;
static int withname = 0;
static int errors[MAX_ERR + 3];

/*
 * cgethost - gets hostname by IP address, caching, and adding unresolvable
 * IP numbers with their IP number as hostname, setting noname flag
 */
static void
cgethost(struct sockaddr *sa, char *string, int check)
{
	uint32_t hashval;
	struct sockaddr_in *sin;
	struct sockaddr_in6 *sin6;
	struct nsrec **current, *new;
	char *name;
	char hostnamebuf[MAXHOSTNAMELEN];

	switch (sa->sa_family) {
	case AF_INET:
		hashval = ((struct sockaddr_in *)sa)->sin_addr.s_addr;
		break;
	case AF_INET6:
		hashval = *(uint32_t *)&(
		    (struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[12];
		break;
	default:
		hashval = 0;
		break;
	}

	current = &nscache[((hashval + (hashval >> 8) +
	    (hashval >> 16) + (hashval >> 24)) % BUCKETS)];

	while (*current) {
		if (sa->sa_len == (*current)->addr.ss_len
		    && memcmp(sa, &(*current)->addr, sa->sa_len) == 0)
			break;

		current = &(*current)->next;
	}

	if (*current == NULL) {
		cachesize++;
		new = (struct nsrec *)malloc(sizeof(struct nsrec));
		if (new == NULL) {
			perror("malloc");
			fprintf(stderr, "Insufficient memory\n");
			exit(1);
		}
		*current = new;
		new->next = NULL;

		memcpy(&new->addr, sa, sa->sa_len);

		new->noname = getnameinfo(sa, sa->sa_len, hostnamebuf,
		    sizeof(hostnamebuf), NULL, 0, 0);
		name = strdup(hostnamebuf);
		if (check) {
			struct addrinfo hints, *res;
			int error;
			memset(&hints, 0, sizeof(hints));
			hints.ai_family = PF_UNSPEC;
			error = getaddrinfo(hostnamebuf, NULL, &hints, &res);
			if (!error) {
				while (res) {
					if (sa->sa_len == res->ai_addrlen
					    && memcmp(sa, res->ai_addr,
					    sa->sa_len) == 0)
						break;

					res = res->ai_next;
				}
				if (!res)
					error++;
			}
			if (error) {
				getnameinfo(sa,	sa->sa_len, hostnamebuf,
				    sizeof(hostnamebuf), NULL, 0,
				    NI_NUMERICHOST);
				fprintf(stderr, "Bad host: %s != %s\n", name,
				    hostnamebuf);
				new->noname = NO_REVERSE;
				free(name);
				name = strdup(hostnamebuf);
			}
		}
		new->hostname = name;
		if (new->hostname == NULL) {
			perror("strdup");
			fprintf(stderr, "Insufficient memory\n");
			exit(1);
		}
	}
	else
		cachehits++;

	/* size of string == MAXDNAME +1 */
	strncpy(string, (*current)->hostname, MAXDNAME);
	string[MAXDNAME] = '\0';
}

/* prints various statistics to output */
static void
stats(FILE *output)
{
	int i;
	char *ipstring;
	struct nsrec *current;
	char *errstring[MAX_ERR + 3];
	char hostnamebuf[MAXHOSTNAMELEN];

	for (i = 0; i < MAX_ERR + 3; i++)
		errstring[i] = "Unknown error";
	errstring[HOST_NOT_FOUND] = "Host not found";
	errstring[TRY_AGAIN] = "Try again";
	errstring[NO_RECOVERY] = "Non recoverable error";
	errstring[NO_DATA] = "No data record";
	errstring[NO_ADDRESS] = "No address";
	errstring[NO_REVERSE] = "No reverse entry";

	fprintf(output, "logresolve Statistics:\n");

	fprintf(output, "Entries: %d\n", entries);
	fprintf(output, "    With name   : %d\n", withname);
	fprintf(output, "    Resolves    : %d\n", resolves);
	if (errors[HOST_NOT_FOUND])
		fprintf(output, "    - Not found : %d\n",
		    errors[HOST_NOT_FOUND]);
	if (errors[TRY_AGAIN])
		fprintf(output, "    - Try again : %d\n", errors[TRY_AGAIN]);
	if (errors[NO_DATA])
		fprintf(output, "    - No data   : %d\n", errors[NO_DATA]);
	if (errors[NO_ADDRESS])
		fprintf(output, "    - No address: %d\n", errors[NO_ADDRESS]);
	if (errors[NO_REVERSE])
		fprintf(output, "    - No reverse: %d\n", errors[NO_REVERSE]);
	fprintf(output, "Cache hits      : %d\n", cachehits);
	fprintf(output, "Cache size      : %d\n", cachesize);
	fprintf(output, "Cache buckets   :     IP number * hostname\n");

	for (i = 0; i < BUCKETS; i++)
		for (current = nscache[i]; current != NULL;
		    current = current->next) {
			getnameinfo((struct sockaddr *)&current->addr,
			    current->addr.ss_len, hostnamebuf,
			    sizeof(hostnamebuf), NULL, 0, NI_NUMERICHOST);
			ipstring = hostnamebuf;
			if (current->noname == 0)
				fprintf(output, "  %3d  %15s - %s\n", i,
				    ipstring, current->hostname);
			else {
				if (current->noname > MAX_ERR + 2)
					fprintf(output, "  %3d  %15s : Unknown "
					    "error\n", i, ipstring);
				else
					fprintf(output, "  %3d  %15s : %s\n",
					    i, ipstring,
				errstring[current->noname]);
			}
		}
}


/*gets a line from stdin */
static int
get_line(char *s, int n)
{
	if (!fgets(s, n, stdin))
		return (0);
	s[strcspn(s, "\n")] = '\0';
	return (1);
}

static void
usage(void)
{
	fprintf(stderr, "usage: logresolve [-c] [-s filename] < access_log "
	    "> access_log.new\n");
	exit(1);
}

int main
(int argc, char *argv[])
{
	char *bar, hoststring[MAXDNAME + 1], line[MAXLINE], *statfile;
	int i, check;
	struct addrinfo hints, *res;
	int error;
	int ch;

	check = 0;
	statfile = NULL;
	while ((ch = getopt(argc, argv, "s:c")) != -1) {
		switch (ch) {
		case 'c':
			check = 1;
			break;
		case 's':
			statfile = optarg;
			break;
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;
	if (argc > 0)
		usage();

	for (i = 0; i < BUCKETS; i++)
		nscache[i] = NULL;
	for (i = 0; i < MAX_ERR + 2; i++)
		errors[i] = 0;

	while (get_line(line, MAXLINE)) {
		if (line[0] == '\0')
			continue;
		entries++;
		if (!isdigit((int)line[0])) {	/* short cut */
			puts(line);
			withname++;
			continue;
		}
		bar = strchr(line, ' ');
		if (bar != NULL)
			*bar = '\0';
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = PF_UNSPEC;
		error = getaddrinfo(line, NULL, &hints, &res);
		if (error) {
			if (bar != NULL)
			*bar = ' ';
			puts(line);
			withname++;
			continue;
		}

		resolves++;

		cgethost(res->ai_addr, hoststring, check);
		if (bar != NULL)
			printf("%s %s\n", hoststring, bar + 1);
		else
			puts(hoststring);
		freeaddrinfo(res);
	}

	if (statfile != NULL) {
		FILE *fp;
		fp = fopen(statfile, "w");
		if (fp == NULL) {
			fprintf(stderr, "logresolve: could not open statistics "
			    "file '%s'\n", statfile);
			exit(1);
		}
		stats(fp);
		fclose(fp);
	}

	return (0);
}
@


1.16
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: logresolve.c,v 1.15 2009/06/21 00:38:22 martynas Exp $	*/
@


1.15
log
@fix rcs ids.  ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
a52 1
static int getline(char *s, int n);
d261 1
a261 1
getline(char *s, int n)
d311 1
a311 1
	while (getline(line, MAXLINE)) {
@


1.14
log
@KNF and readability changes.  de-register, remove #ifndef SIN6_LEN defines.
Add OpenBSD cvs markers.

No binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD $*/
@


1.13
log
@documentation tweaks.

ok (some time ago) jmc@@
@
text
@d1 2
a73 1

d75 5
a79 5
    struct sockaddr_storage addr;
    char *hostname;
    int noname;
    struct nsrec *next;
}    *nscache[BUCKETS];
d81 1
a81 3
/*
 * statistics - obvious
 */
d103 2
a104 2

static void cgethost (struct sockaddr *sa, char *string, int check)
d106 18
a123 32
    uint32_t hashval;
    struct sockaddr_in *sin;
    struct sockaddr_in6 *sin6;
    struct nsrec **current, *new;
    char *name;
    char hostnamebuf[MAXHOSTNAMELEN];

    switch (sa->sa_family) {
    case AF_INET:
	hashval = ((struct sockaddr_in *)sa)->sin_addr.s_addr;
	break;
    case AF_INET6:
	hashval = *(uint32_t *)&((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[12];
	break;
    default:
	hashval = 0;
	break;
    }

    current = &nscache[((hashval + (hashval >> 8) +
			 (hashval >> 16) + (hashval >> 24)) % BUCKETS)];

    while (*current) {
#ifndef SIN6_LEN
	if (SA_LEN(sa) == SA_LEN((struct sockaddr *)&(*current)->addr)
	 && memcmp(sa, &(*current)->addr, SA_LEN(sa)) == 0)
#else
	if (sa->sa_len == (*current)->addr.ss_len
	 && memcmp(sa, &(*current)->addr, sa->sa_len) == 0)
#endif
	{
	    break;
d126 2
a127 2
	current = &(*current)->next;
    }
d129 6
a134 7
    if (*current == NULL) {
	cachesize++;
	new = (struct nsrec *) malloc(sizeof(struct nsrec));
	if (new == NULL) {
	    perror("malloc");
	    fprintf(stderr, "Insufficient memory\n");
	    exit(1);
a135 2
	*current = new;
	new->next = NULL;
d137 12
a148 5
#ifndef SIN6_LEN
	memcpy(&new->addr, sa, SA_LEN(sa));
#else
	memcpy(&new->addr, sa, sa->sa_len);
#endif
d150 37
a186 27
	new->noname = getnameinfo(sa,
#ifndef SIN6_LEN
		SA_LEN(sa),
#else
		sa->sa_len,
#endif
		    hostnamebuf, sizeof(hostnamebuf), NULL, 0, 0);
	name = strdup(hostnamebuf);
	if (check) {
	    struct addrinfo hints, *res;
	    int error;
	    memset(&hints, 0, sizeof(hints));
	    hints.ai_family = PF_UNSPEC;
	    error = getaddrinfo(hostnamebuf, NULL, &hints, &res);
	    if (!error) {
		while (res) {
#ifndef SIN6_LEN
		    if (SA_LEN(sa) == res->ai_addrlen
		     && memcmp(sa, res->ai_addr, SA_LEN(sa)) == 0)
#else
		    if (sa->sa_len == res->ai_addrlen
		     && memcmp(sa, res->ai_addr, sa->sa_len) == 0)
#endif
		    {
			break;
		    }
		    res = res->ai_next;
a187 16
		if (!res)
		    error++;
	    }
	    if (error) {
		getnameinfo(sa,
#ifndef SIN6_LEN
		    SA_LEN(sa),
#else
		    sa->sa_len,
#endif
		    hostnamebuf, sizeof(hostnamebuf), NULL, 0, NI_NUMERICHOST);
		fprintf(stderr, "Bad host: %s != %s\n", name, hostnamebuf);
		new->noname = NO_REVERSE;
		free(name);
		name = strdup(hostnamebuf);
	    }
d189 6
a194 13
	new->hostname = name;
	if (new->hostname == NULL) {
	    perror("strdup");
	    fprintf(stderr, "Insufficient memory\n");
	    exit(1);
	}
    }
    else
	cachehits++;

    /* size of string == MAXDNAME +1 */
    strncpy(string, (*current)->hostname, MAXDNAME);
    string[MAXDNAME] = '\0';
d197 3
a199 5
/*
 * prints various statistics to output
 */

static void stats (FILE *output)
d201 55
a255 56
    int i;
    char *ipstring;
    struct nsrec *current;
    char *errstring[MAX_ERR + 3];
    char hostnamebuf[MAXHOSTNAMELEN];

    for (i = 0; i < MAX_ERR + 3; i++)
	errstring[i] = "Unknown error";
    errstring[HOST_NOT_FOUND] = "Host not found";
    errstring[TRY_AGAIN] = "Try again";
    errstring[NO_RECOVERY] = "Non recoverable error";
    errstring[NO_DATA] = "No data record";
    errstring[NO_ADDRESS] = "No address";
    errstring[NO_REVERSE] = "No reverse entry";

    fprintf(output, "logresolve Statistics:\n");

    fprintf(output, "Entries: %d\n", entries);
    fprintf(output, "    With name   : %d\n", withname);
    fprintf(output, "    Resolves    : %d\n", resolves);
    if (errors[HOST_NOT_FOUND])
	fprintf(output, "    - Not found : %d\n", errors[HOST_NOT_FOUND]);
    if (errors[TRY_AGAIN])
	fprintf(output, "    - Try again : %d\n", errors[TRY_AGAIN]);
    if (errors[NO_DATA])
	fprintf(output, "    - No data   : %d\n", errors[NO_DATA]);
    if (errors[NO_ADDRESS])
	fprintf(output, "    - No address: %d\n", errors[NO_ADDRESS]);
    if (errors[NO_REVERSE])
	fprintf(output, "    - No reverse: %d\n", errors[NO_REVERSE]);
    fprintf(output, "Cache hits      : %d\n", cachehits);
    fprintf(output, "Cache size      : %d\n", cachesize);
    fprintf(output, "Cache buckets   :     IP number * hostname\n");

    for (i = 0; i < BUCKETS; i++)
	for (current = nscache[i]; current != NULL; current = current->next) {
	    getnameinfo((struct sockaddr *)&current->addr,
#ifndef SIN6_LEN
		    SA_LEN((struct sockaddr *)&current->addr),
#else
		    current->addr.ss_len,
#endif
		    hostnamebuf, sizeof(hostnamebuf), NULL, 0, NI_NUMERICHOST);
	    ipstring = hostnamebuf;
	    if (current->noname == 0)
		fprintf(output, "  %3d  %15s - %s\n", i, ipstring,
			current->hostname);
	    else {
		if (current->noname > MAX_ERR + 2)
		    fprintf(output, "  %3d  %15s : Unknown error\n", i,
			    ipstring);
		else
		    fprintf(output, "  %3d  %15s : %s\n", i, ipstring,
			    errstring[current->noname]);
	    }
	}
d259 3
a261 5
/*
 * gets a line from stdin
 */

static int getline (char *s, int n)
d263 4
a266 4
    if (!fgets(s, n, stdin))
	return (0);
    s[strcspn(s, "\n")] = '\0';
    return (1);
d269 2
a270 1
static void usage(void)
d272 3
a274 3
    fprintf(stderr,
        "usage: logresolve [-c] [-s filename] < access_log > access_log.new\n");
    exit(1);
d277 2
a278 1
int main (int argc, char *argv[])
d280 19
a298 39
    char *bar, hoststring[MAXDNAME + 1], line[MAXLINE], *statfile;
    int i, check;
    struct addrinfo hints, *res;
    int error;
    int ch;

    check = 0;
    statfile = NULL;
    while ((ch = getopt(argc, argv, "s:c")) != -1) {
            switch (ch) {
            case 'c':
                    check = 1;
                    break;
            case 's':
                    statfile = optarg;
                    break;
            default:
                   usage();
            }
    }

    argc -= optind;
    argv += optind;
    if (argc > 0)
        usage();

    for (i = 0; i < BUCKETS; i++)
	nscache[i] = NULL;
    for (i = 0; i < MAX_ERR + 2; i++)
	errors[i] = 0;

    while (getline(line, MAXLINE)) {
	if (line[0] == '\0')
	    continue;
	entries++;
	if (!isdigit((int)line[0])) {	/* short cut */
	    puts(line);
	    withname++;
	    continue;
d300 42
a341 12
	bar = strchr(line, ' ');
	if (bar != NULL)
	    *bar = '\0';
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	error = getaddrinfo(line, NULL, &hints, &res);
	if (error) {
	    if (bar != NULL)
		*bar = ' ';
	    puts(line);
	    withname++;
	    continue;
d344 10
a353 17
	resolves++;

	cgethost(res->ai_addr, hoststring, check);
	if (bar != NULL)
	    printf("%s %s\n", hoststring, bar + 1);
	else
	    puts(hoststring);
	freeaddrinfo(res);
    }

    if (statfile != NULL) {
	FILE *fp;
	fp = fopen(statfile, "w");
	if (fp == NULL) {
	    fprintf(stderr, "logresolve: could not open statistics file '%s'\n"
		    ,statfile);
	    exit(1);
a354 3
	stats(fp);
	fclose(fp);
    }
d356 1
a356 1
    return (0);
@


1.12
log
@Add support for IPv6 while keeping the default at IPv4 to not break
existing installations.  See the documentation for the IPv6 related
configuration.

This changes the module ABI since addresses are now struct addrinfo.

This has been tested by many people and run on production machines
for several months.

feedback many, ok todd
@
text
@d9 1
a9 1
 * Usage: logresolve [-s filename] [-c] < access_log > new_log
d300 2
a301 2
    fprintf(stderr, "Usage: logresolve [-s statfile] [-c]");
    fprintf(stderr, " < input > output\n");
@


1.11
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d49 1
a49 1
static void cgethost(struct in_addr ipnum, char *string, int check);
d74 1
a74 1
    struct in_addr ipnum;
d105 1
a105 1
static void cgethost (struct in_addr ipnum, char *string, int check)
d107 3
a110 1
    struct hostent *hostdata;
d112 1
d114 26
a139 2
    current = &nscache[((ipnum.s_addr + (ipnum.s_addr >> 8) +
			 (ipnum.s_addr >> 16) + (ipnum.s_addr >> 24)) % BUCKETS)];
a140 1
    while (*current != NULL && ipnum.s_addr != (*current)->ipnum.s_addr)
d142 1
d155 5
a159 1
	new->ipnum = ipnum;
d161 27
a187 36
	hostdata = gethostbyaddr((const char *) &ipnum, sizeof(struct in_addr),
				 AF_INET);
	if (hostdata == NULL) {
	    if (h_errno > MAX_ERR)
		errors[UNKNOWN_ERR]++;
	    else
		errors[h_errno]++;
	    new->noname = h_errno;
	    name = strdup(inet_ntoa(ipnum));
	}
	else {
	    new->noname = 0;
	    name = strdup(hostdata->h_name);
	    if (check) {
		if (name == NULL) {
		    perror("strdup");
		    fprintf(stderr, "Insufficient memory\n");
		    exit(1);
		}
		hostdata = gethostbyname(name);
		if (hostdata != NULL) {
		    char **hptr;

		    for (hptr = hostdata->h_addr_list; *hptr != NULL; hptr++)
			if (((struct in_addr *) (*hptr))->s_addr == ipnum.s_addr)
			    break;
		    if (*hptr == NULL)
			hostdata = NULL;
		}
		if (hostdata == NULL) {
		    fprintf(stderr, "Bad host: %s != %s\n", name,
			    inet_ntoa(ipnum));
		    new->noname = NO_REVERSE;
		    free(name);
		    name = strdup(inet_ntoa(ipnum));
		    errors[NO_REVERSE]++;
d189 15
d231 1
d263 8
a270 1
	    ipstring = inet_ntoa(current->ipnum);
a306 1
    struct in_addr ipnum;
d309 2
d350 4
a353 2
	ipnum.s_addr = inet_addr(line);
	if (ipnum.s_addr == 0xffffffffu) {
d363 1
a363 1
	cgethost(ipnum, hoststring, check);
d368 1
@


1.10
log
@- convert to getopt(3)
- add a usage() function that exits non-zero

ok henning@@ otto@@
@
text
@a246 2
    char *cp;

d249 1
a249 3
    cp = strchr(s, '\n');
    if (cp)
	*cp = '\0';
@


1.9
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d52 1
d257 7
d269 1
d273 11
a283 15
    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-c") == 0)
	    check = 1;
	else if (strcmp(argv[i], "-s") == 0) {
	    if (i == argc - 1) {
		fprintf(stderr, "logresolve: missing filename to -s\n");
		exit(1);
	    }
	    i++;
	    statfile = argv[i];
	}
	else {
	    fprintf(stderr, "Usage: logresolve [-s statfile] [-c] < input > output\n");
	    exit(0);
	}
d286 4
@


1.8
log
@kill more dead code, mostly inside #ifdef SOMENONSENSEONSTUPIDOSES
joint work by Michael Knudsen <e@@molioner.dk> and Daniel Ouellet
<daniel@@presscom.net> with my input
no change in binaries
@
text
@d83 1
a83 1
#if !defined(h_errno) && !defined(CYGWIN)
@


1.7
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@a64 13
#if defined(NEED_STRDUP)
char *strdup (const char *str)
{
    char *dup;

    if (!(dup = (char *) malloc(strlen(str) + 1)))
	return NULL;
    dup = strlcpy(dup, str, strlen(str) + 1);

    return dup;
}
#endif

@


1.6
log
@trivial strcpy in code we don't even compile
@
text
@a46 2
#if !defined(MPE) && !defined(WIN32)
#ifndef BEOS
a47 6
#else
/* BeOS lacks the necessary files until we get the new networking */
#include <netinet/in.h>
#define NO_ADDRESS 4
#endif /* BEOS */
#endif /* !MPE && !WIN32*/
a274 5
#ifdef WIN32
    WSADATA wsaData;
    WSAStartup(0x101, &wsaData);
#endif

a328 4

#ifdef WIN32
     WSACleanup();
#endif
@


1.5
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d80 1
a80 1
    dup = strcpy(dup, str);
@


1.4
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d104 1
a104 1
#ifndef h_errno
d317 1
a317 1
	if (!isdigit(line[0])) {	/* short cut */
@


1.3
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d47 1
a47 1
#ifndef MPE
d55 1
a55 1
#endif /* MPE */
d108 1
a108 1
/* largeste value for h_errno */
d283 5
d342 4
@


1.2
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d48 1
d50 6
a55 1
#endif
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * Tom Rathborne - tomr@@uunet.ca - http://www.uunet.ca/~tomr/
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d4 1
a4 1
 * Tom Rathborne - tomr@@aceldama.com - http://www.aceldama.com/~tomr/
d47 1
a47 2
#if !defined(MPE) && !defined(WIN32)
#ifndef BEOS
d49 1
a49 6
#else
/* BeOS lacks the necessary files until we get the new networking */
#include <netinet/in.h>
#define NO_ADDRESS 4
#endif /* BEOS */
#endif /* !MPE && !WIN32*/
d98 1
a98 1
#if !defined(h_errno) && !defined(CYGWIN)
d102 1
a102 1
/* largest value for h_errno */
a276 5
#ifdef WIN32
    WSADATA wsaData;
    WSAStartup(0x101, &wsaData);
#endif

d306 1
a306 1
	if (!isdigit((int)line[0])) {	/* short cut */
a330 4

#ifdef WIN32
     WSACleanup();
#endif
@

