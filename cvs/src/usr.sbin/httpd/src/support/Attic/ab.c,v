head	1.19;
access;
symbols
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.5
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.4
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.3
	apache_1_3_27:1.1.1.3
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2005.06.28.12.58.53;	author robert;	state dead;
branches;
next	1.18;

1.18
date	2005.02.09.12.13.10;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.06.13.14.10;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.02.19.42.48;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.15.12.17.18;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.17.18.57.06;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.25.16.05.28;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.21.13.11.40;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.08.17.34.53;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.07.20.23.06;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.19.21.31.16;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.29.02.08.07;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.05.02.26.58;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.15.22.18.40;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.19.11.17.39;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.25.18.30.18;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.06.30.07;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.03.01.01.07.16;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.51;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.51;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.29.22;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.07.19.48.15;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.21.12.53.45;	author henning;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.17.17.03.26;	author henning;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove 'ab' (apache benchmark) from the tree because
we don't install it, and 'ab' itself is buggy so that
it will give false results.

ok henning@@
@
text
@/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/*
   ** This program is based on ZeusBench V1.0 written by Adam Twiss
   ** which is Copyright (c) 1996 by Zeus Technology Ltd. http://www.zeustech.net/
   **
   ** This software is provided "as is" and any express or implied waranties,
   ** including but not limited to, the implied warranties of merchantability and
   ** fitness for a particular purpose are disclaimed.  In no event shall
   ** Zeus Technology Ltd. be liable for any direct, indirect, incidental, special,
   ** exemplary, or consequential damaged (including, but not limited to,
   ** procurement of substitute good or services; loss of use, data, or profits;
   ** or business interruption) however caused and on theory of liability.  Whether
   ** in contract, strict liability or tort (including negligence or otherwise)
   ** arising in any way out of the use of this software, even if advised of the
   ** possibility of such damage.
   **
 */

/*
   ** HISTORY:
   **    - Originally written by Adam Twiss <adam@@zeus.co.uk>, March 1996
   **      with input from Mike Belshe <mbelshe@@netscape.com> and
   **      Michael Campanella <campanella@@stevms.enet.dec.com>
   **    - Enhanced by Dean Gaudet <dgaudet@@apache.org>, November 1997
   **    - Cleaned up by Ralf S. Engelschall <rse@@apache.org>, March 1998
   **    - POST and verbosity by Kurt Sussman <kls@@merlot.com>, August 1998
   **    - HTML table output added by David N. Welton <davidw@@prosa.it>, January 1999
   **    - Added Cookie, Arbitrary header and auth support. <dirkx@@webweaving.org>, April 1999
   ** Version 1.3d
   **    - Increased version number - as some of the socket/error handling has
   **      fundamentally changed - and will give fundamentally different results
   **      in situations where a server is dropping requests. Therefore you can
   **      no longer compare results of AB as easily. Hence the inc of the version.
   **      They should be closer to the truth though. Sander & <dirkx@@covalent.net>, End 2000.
   **    - Fixed proxy functionality, added median/mean statistics, added gnuplot
   **      output option, added _experimental/rudimentary_ SSL support. Added
   **      confidence guestimators and warnings. Sander & <dirkx@@covalent.net>, End 2000
   **    - Fixed serious int overflow issues which would cause realistic (longer
   **      than a few minutes) run's to have wrong (but believable) results. Added
   **	   trapping of connection errors which influenced measurements.
   **	   Contributed by Sander Temme - Early 2001
   **
 */
 /*
  * BUGS:
  *
  * - has various other poor buffer attacks related to the lazy parsing of
  *   response headers from the server
  * - doesn't implement much of HTTP/1.x, only accepts certain forms of
  *   responses
  * - (performance problem) heavy use of strstr shows up top in profile
  *   only an issue for loopback usage
  * - SSL implementation is a joke. Compile with:
  *	CFLAGS="-DUSE_SSL -I/usr/local/include" \
  *		LIBS="-L/usr/local/lib -lssl -lcrypto" \
  *		configure --your-other-options
  */


#define VERSION "1.3d"

/* -------------------------------------------------------------------- */

/* allow compilation outside an Apache build tree */
#ifdef NO_APACHE_INCLUDES
#include <sys/time.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <string.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/uio.h>

#define ap_select       select
#else				/* (!)NO_APACHE_INCLUDES */
#include "ap_config.h"
#include "ap.h"
#include <fcntl.h>
#include <sys/time.h>

#include <sys/types.h>
#include <sys/uio.h>

#endif				/* NO_APACHE_INCLUDES */

#ifdef	USE_SSL
#include <openssl/rsa.h>
#include <openssl/crypto.h>
#include <openssl/x509.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <openssl/ssl.h>
#endif

#include <math.h>
/* ------------------- DEFINITIONS -------------------------- */

/* maximum number of requests on a time limited test */
#define MAX_REQUESTS 50000

/* good old state hostname */
#define STATE_UNCONNECTED 0
#define STATE_CONNECTING  1
#define STATE_READ        2

#define CBUFFSIZE       512

struct connection {
    int fd;
    int state;
    int read;			/* amount of bytes read */
    int bread;			/* amount of body read */
    int length;			/* Content-Length value used for keep-alive */
    char cbuff[CBUFFSIZE];	/* a buffer to store server response header */
    int cbx;			/* offset in cbuffer */
    int keepalive;		/* non-zero if a keep-alive request */
    int gotheader;		/* non-zero if we have the entire header in
				 * cbuff */
    struct timeval start,	/* Start of connection */
            connect,		/* Connected, start writing */
            endwrite,		/* Request written */
            beginread,		/* First byte of input */
            done;		/* Connection closed */

#ifdef USE_SSL
    SSL *ssl;
#endif
};

struct data {
#ifdef USE_SSL
    /* XXX insert timings for ssl */
#endif
    int read;			/* number of bytes read */
    long starttime;		/* start time of connection in seconds since
				 * Jan. 1, 1970 */
    long waittime;		/* Between writing request and reading
				 * response */
    long ctime;			/* time in ms to connect */
    long time;			/* time in ms for connection */
};

#define ap_min(a,b) ((a)<(b))?(a):(b)
#define ap_max(a,b) ((a)>(b))?(a):(b)
#define _rnd(x) ((long)(x+0.5))

/* --------------------- GLOBALS ---------------------------- */

int verbosity = 0;		/* no verbosity by default */
int percentile = 1;		/* Show percentile served */
int confidence = 1;		/* Show confidence estimator and warnings */
int posting = 0;		/* GET by default */
long requests = 1;		/* Number of requests to make */
int heartbeatres = 100;		/* How often do we say we're alive */
int concurrency = 1;		/* Number of multiple requests to make */
int tlimit = 0;			/* time limit in cs */
int keepalive = 0;		/* try and do keepalive connections */
char servername[1024];		/* name that server reports */
char hostname[1024];		/* host name */
char proxyhost[1024];		/* proxy host name */
int proxyport = 0;		/* proxy port */
int isproxy = 0;
char path[1024];		/* path name */
char postfile[1024];		/* name of file containing post data */
char *postdata;			/* *buffer containing data from postfile */
char *gnuplot;			/* GNUplot file */
char *csvperc;			/* CSV Percentile file */
char url[1024];
char fullurl[1024];
char colonport[1024];
int postlen = 0;		/* length of data to be POSTed */
char content_type[1024];	/* content type to put in POST header */
char cookie[1024],		/* optional cookie line */
     auth[1024],		/* optional (basic/uuencoded)
				 * authentification */
     hdrs[4096];		/* optional arbitrary headers */
int port = 80;			/* port number */

int use_html = 0;		/* use html in the report */
char *tablestring;
char *trstring;
char *tdstring;

int doclen = 0;			/* the length the document should be */
long totalread = 0;		/* total number of bytes read */
long totalbread = 0;		/* totoal amount of entity body read */
long totalposted = 0;		/* total number of bytes posted, inc. headers */
long done = 0;			/* number of requests we have done */
long doneka = 0;		/* number of keep alive connections done */
long good = 0, bad = 0;		/* number of good and bad requests */
long epipe = 0;			/* number of broken pipe writes */

#ifdef USE_SSL
int ssl = 0;
SSL_CTX *ctx;
#endif
/* store error cases */
int err_length = 0, err_conn = 0, err_except = 0;
int err_response = 0;

struct timeval start, endtime;

/* global request (and its length) */
char request[1024];
int reqlen;

/* one global throw-away buffer to read stuff into */
char buffer[8192];

struct connection *con;		/* connection array */
struct data *stats;		/* date for each request */

fd_set readbits, writebits;	/* bits for select */
struct sockaddr_in server;	/* server addr structure */

#define ab_close(s) close(s)
#define ab_read(a,b,c) read(a,b,c)
#define ab_write(a,b,c) write(a,b,c)

static void close_connection(struct connection * c);
#if (defined(NO_WRITEV) || defined(USE_SSL))
#define USE_S_WRITE
static int s_write(struct connection * c, char *buff, int len);
#endif

/* --------------------------------------------------------- */

/* simple little function to perror and exit */

static void err(char *s)
{
    if (errno) {
	perror(s);
    }
    else {
	fprintf(stderr,"%s", s);
    }
    exit(errno ? errno : 1);
}

/* --------------------------------------------------------- */

/*
 * write out request to a connection - assumes we can write (small) request
 * out in one go into our new socket buffer
 */

static void write_request(struct connection * c)
{
/* XXX this sucks - SSL mode and writev() do not mix
 *     another artificial difference.
 */
#ifndef USE_S_WRITE
    struct iovec out[2];
    int outcnt = 1;
#endif
    int snd = 0;
    gettimeofday(&c->connect, 0);
#ifndef USE_S_WRITE
    out[0].iov_base = request;
    out[0].iov_len = reqlen;

    if (posting > 0) {
	out[1].iov_base = postdata;
	out[1].iov_len = postlen;
	outcnt = 2;
	totalposted += (reqlen + postlen);
    }
    snd = writev(c->fd, out, outcnt);
#else
    snd = s_write(c, request, reqlen);
    if (posting > 0) {
        snd += s_write(c, postdata, postlen);
        totalposted += (reqlen + postlen);
    }
#endif
    if (snd < 0) {
	bad++; 
	err_conn++;
        close_connection(c);
	return;
    } else
    if (snd != (reqlen + postlen)) {
	/* We cannot cope with this. */
	fprintf(stderr,"The entire post RQ could not be transmitted to the socket.\n");
	exit(1);
    }
    FD_SET(c->fd, &readbits);
    FD_CLR(c->fd, &writebits);
    c->state = STATE_READ;
    gettimeofday(&c->endwrite, 0);
}

/* --------------------------------------------------------- */

/*  Do actual data writing */

#ifdef USE_S_WRITE
static int s_write(struct connection * c, char *buff, int len)
{
	int left = len;
    do {
	int n;
#ifdef USE_SSL
	if (ssl) {
	    n = SSL_write(c->ssl, buff, left);
	    if (n < 0) {
		int e = SSL_get_error(c->ssl, n);
		/* XXXX probably wrong !!! */
		if ((e != SSL_ERROR_WANT_READ) && (e != SSL_ERROR_WANT_WRITE))
		    n = -1;
		else
		    n = 0;
	    };
	}
	else
#endif
    n = ab_write(c->fd, buff, left);

	if (n < 0) {
	    switch (errno) {
	    case EAGAIN:
		break;
	    case EPIPE:
		/* We've tried to write to a broken pipe. */
		epipe++;
		close_connection(c);
		return len-left;
	    default:
#ifdef USE_SSL
		if (ssl) {
			fprintf(stderr,"Error writing: ");
	    		ERR_print_errors_fp(stderr);
		} else
#endif
			perror("write");
		exit(1);
	    }
	}
	else if (n) {
	    if (verbosity >= 3)
		printf(" --> write(%x) %d (%d)\n", (unsigned char) buff[0], n, left);
	    buff += n;
	    left -= n;
	};
    } while (left > 0);
    
	return len - left;
}
#endif

/* --------------------------------------------------------- */

/* make an fd non blocking */

static void nonblock(int fd)
{
    int i = 1;
    ioctl(fd, FIONBIO, &i);
}

/* --------------------------------------------------------- */

/* returns the time in ms between two timevals */

static int timedif(struct timeval a, struct timeval b)
{
    register int us, s;

    us = a.tv_usec - b.tv_usec;
    us /= 1000;
    s = a.tv_sec - b.tv_sec;
    s *= 1000;
    return s + us;
}

/* --------------------------------------------------------- */

/* calculate and output results */

static int compradre(struct data * a, struct data * b)
{
    if ((a->ctime) < (b->ctime))
	return -1;
    if ((a->ctime) > (b->ctime))
	return +1;
    return 0;
}

static int comprando(struct data * a, struct data * b)
{
    if ((a->time) < (b->time))
	return -1;
    if ((a->time) > (b->time))
	return +1;
    return 0;
}

static int compri(struct data * a, struct data * b)
{
    int p = a->time - a->ctime;
    int q = b->time - b->ctime;
    if (p < q)
	return -1;
    if (p > q)
	return +1;
    return 0;
}

static int compwait(struct data * a, struct data * b)
{
    if ((a->waittime) < (b->waittime))
	return -1;
    if ((a->waittime) > (b->waittime))
	return 1;
    return 0;
}

static void output_results(void)
{
    long timetaken;
    long i;

    gettimeofday(&endtime, 0);
    timetaken = timedif(endtime, start);

    printf("\r                                                                           \r");
    printf("Server Software:        %s\n", servername);
    printf("Server Hostname:        %s\n", hostname);
    printf("Server Port:            %d\n", port);
    printf("\n");
    printf("Document Path:          %s\n", path);
    printf("Document Length:        %d bytes\n", doclen);
    printf("\n");
    printf("Concurrency Level:      %d\n", concurrency);
    printf("Time taken for tests:   %ld.%03ld seconds\n",
	   timetaken / 1000, timetaken % 1000);
    printf("Complete requests:      %ld\n", done);
    printf("Failed requests:        %ld\n", bad);
    if (bad)
	printf("   (Connect: %d, Length: %d, Exceptions: %d)\n",
	       err_conn, err_length, err_except);
    printf("Broken pipe errors:     %ld\n", epipe);
    if (err_response)
	printf("Non-2xx responses:      %d\n", err_response);
    if (keepalive)
	printf("Keep-Alive requests:    %ld\n", doneka);
    printf("Total transferred:      %ld bytes\n", totalread);
    if (posting > 0)
	printf("Total POSTed:           %ld\n", totalposted);
    printf("HTML transferred:       %ld bytes\n", totalbread);

    /* avoid divide by zero */
    if (timetaken) {
	printf("Requests per second:    %.2f [#/sec] (mean)\n", 1000 * (float) (done) / timetaken);
	printf("Time per request:       %.2f [ms] (mean)\n", concurrency * timetaken / (float) done);
	printf("Time per request:       %.2f [ms] (mean, across all concurrent requests)\n", timetaken / (float) done);
	printf("Transfer rate:          %.2f [Kbytes/sec] received\n",
	       (float) (totalread) / timetaken);
	if (posting > 0) {
	    printf("                        %.2f kb/s sent\n",
		   (float) (totalposted) / timetaken);
	    printf("                        %.2f kb/s total\n",
		   (float) (totalread + totalposted) / timetaken);
	}
    }
    if (requests>1) {
	/* work out connection times */
	double totalcon = 0, total = 0, totald = 0, totalwait = 0;
	long mincon = 9999999, mintot = 999999, mind = 99999, minwait = 99999;
	long maxcon = 0, maxtot = 0, maxd = 0, maxwait = 0;
	long meancon = 0, meantot = 0, meand = 0, meanwait = 0;
	double sdtot = 0, sdcon = 0, sdd = 0, sdwait = 0;

	for (i = 0; i < requests; i++) {
	    struct data s = stats[i];
	    mincon = ap_min(mincon, s.ctime);
	    mintot = ap_min(mintot, s.time);
	    mind = ap_min(mintot, s.time - s.ctime);
	    minwait = ap_min(minwait, s.waittime);

	    maxcon = ap_max(maxcon, s.ctime);
	    maxtot = ap_max(maxtot, s.time);
	    maxd = ap_max(maxd, s.time - s.ctime);
	    maxwait = ap_max(maxwait, s.waittime);

	    totalcon += s.ctime;
	    total += s.time;
	    totald += s.time - s.ctime;
	    totalwait += s.waittime;
	};
	totalcon /= requests;
	total /= requests;
	totald /= requests;
	totalwait /= requests;

	for (i = 0; i < requests; i++) {
	    struct data s = stats[i];
	    int a;
	    a = (s.time - total);
	    sdtot += a * a;
	    a = (s.ctime - totalcon);
	    sdcon += a * a;
	    a = (s.time - s.ctime - totald);
	    sdd += a * a;
	    a = (s.waittime - totalwait);
	    sdwait += a * a;
	};

	sdtot = (requests > 1) ? sqrt(sdtot / (requests - 1)) : 0;
	sdcon = (requests > 1) ? sqrt(sdcon / (requests - 1)) : 0;
	sdd = (requests > 1) ? sqrt(sdd / (requests - 1)) : 0;
	sdwait = (requests > 1) ? sqrt(sdwait / (requests - 1)) : 0;

	if (gnuplot) {
	    FILE *out = fopen(gnuplot, "w");
	    if (!out) {
		perror("Cannot open gnuplot output file");
		exit(1);
	    };
	    fprintf(out, "starttime\tseconds\tctime\tdtime\tttime\twait\n");
	    for (i = 0; i < requests; i++) {
		time_t sttime;
		char *tmstring;
		sttime = stats[i].starttime;
		tmstring = ctime(&sttime);
		tmstring[strlen(tmstring) - 1] = '\0';	/* ctime returns a
							 * string with a
							 * trailing newline */
		fprintf(out, "%s\t%ld\t%ld\t%ld\t%ld\t%ld\n",
			tmstring,
			(long)sttime,
			stats[i].ctime,
			stats[i].time - stats[i].ctime,
			stats[i].time,
			stats[i].waittime);
	    }
	    fclose(out);
	};

	/*
	 * XXX: what is better; this hideous cast of the copare function; or
	 * the four warnings during compile ? dirkx just does not know and
	 * hates both
	 */
	qsort(stats, requests, sizeof(struct data),
	      (int (*) (const void *, const void *)) compradre);
	if ((requests > 1) && (requests % 2))
	    meancon = (stats[requests / 2].ctime + stats[requests / 2 + 1].ctime) / 2;
	else
	    meancon = stats[requests / 2].ctime;

	qsort(stats, requests, sizeof(struct data),
	      (int (*) (const void *, const void *)) compri);
	if ((requests > 1) && (requests % 2))
	    meand = (stats[requests / 2].time + stats[requests / 2 + 1].time \
	    -stats[requests / 2].ctime - stats[requests / 2 + 1].ctime) / 2;
	else
	    meand = stats[requests / 2].time - stats[requests / 2].ctime;

	qsort(stats, requests, sizeof(struct data),
	      (int (*) (const void *, const void *)) compwait);
	if ((requests > 1) && (requests % 2))
	    meanwait = (stats[requests / 2].waittime + stats[requests / 2 + 1].waittime) / 2;
	else
	    meanwait = stats[requests / 2].waittime;

	qsort(stats, requests, sizeof(struct data),
	      (int (*) (const void *, const void *)) comprando);
	if ((requests > 1) && (requests % 2))
	    meantot = (stats[requests / 2].time + stats[requests / 2 + 1].time) / 2;
	else
	    meantot = stats[requests / 2].time;


	printf("\nConnnection Times (ms)\n");

	if (confidence) {
	    printf("              min  mean[+/-sd] median   max\n");
	    printf("Connect:    %5ld %5ld %6.1f  %5ld %5ld\n",
		   mincon, _rnd(totalcon), sdcon, meancon, maxcon);
	    printf("Processing: %5ld %5ld %6.1f  %5ld %5ld\n",
		   mind, _rnd(totald), sdd, meand, maxd);
	    printf("Waiting:    %5ld %5ld %6.1f  %5ld %5ld\n",
		   minwait, _rnd(totalwait), sdwait, meanwait, maxwait);
	    printf("Total:      %5ld %5ld %6.1f  %5ld %5ld\n", mintot, _rnd(total), sdtot, meantot, maxtot);

#define     SANE(what,avg,mean,sd) \
            { \
		double d = avg - mean; \
		if (d < 0) d = -d; \
		if (d > 2 * sd ) \
			printf("ERROR: The median and mean for " what " are more than twice the standard\n" \
			    "       deviation apart. These results are NOT reliable.\n"); \
		else if (d > sd ) \
			printf("WARING: The median and mean for " what " are not within a normal deviation\n" \
			    "        These results are propably not that reliable.\n"); \
	    }
	    SANE("the initial connection time", totalcon, meancon, sdcon);
	    SANE("the processing time", totald, meand, sdd);
	    SANE("the waiting time", totalwait, meanwait, sdwait);
	    SANE("the total time", total, meantot, sdtot);
	}
	else {
	    printf("              min   avg   max\n");
	    printf("Connect:    %5ld %5ld %5ld\n", mincon, _rnd(totalcon), maxcon);
	    printf("Processing: %5ld %5ld %5ld\n", mind, _rnd(totald), maxd);
	    printf("Total:      %5ld %5ld %5ld\n", mintot, _rnd(total), maxtot);
	};

	/* Sorted on total connect times */
	if (percentile && (requests > 1)) {
	    printf("\nPercentage of the requests served within a certain time (ms)\n");
	    printf("  50%%  %5ld\n", stats[(int) (requests * 0.50)].time);
	    printf("  66%%  %5ld\n", stats[(int) (requests * 0.66)].time);
	    printf("  75%%  %5ld\n", stats[(int) (requests * 0.75)].time);
	    printf("  80%%  %5ld\n", stats[(int) (requests * 0.80)].time);
	    printf("  90%%  %5ld\n", stats[(int) (requests * 0.90)].time);
	    printf("  95%%  %5ld\n", stats[(int) (requests * 0.95)].time);
	    printf("  98%%  %5ld\n", stats[(int) (requests * 0.98)].time);
	    printf("  99%%  %5ld\n", stats[(int) (requests * 0.99)].time);
	    printf(" 100%%  %5ld (last request)\n", stats[(int) (requests - 1)].time);
	    \
	};
	if (csvperc) {
	    FILE *out = fopen(csvperc, "w");
	    if (!out) {
		perror("Cannot open CSV output file");
		exit(1);
	    };
	    fprintf(out, "" "Percentage served" "," "Time in ms" "\n");
	    for (i = 0; i < 100; i++) {
		double d;
		if (i == 0)
		    d = stats[0].time;
		else if (i == 100)
		    d = stats[requests - 1].time;
		else
		    d = stats[(int) (0.5 + requests * i / 100.0)].time;
		fprintf(out, "%ld,%f\n", i, d);
	    }
	    fclose(out);
	};
    }
}

/* --------------------------------------------------------- */

/* calculate and output results in HTML  */

static void output_html_results(void)
{
    long timetaken;
    long i;

    gettimeofday(&endtime, 0);
    timetaken = timedif(endtime, start);

    printf("\n\n<table %s>\n", tablestring);
    printf("<tr %s><th colspan=2 %s>Server Software:</th>"
	   "<td colspan=2 %s>%s</td></tr>\n",
	   trstring, tdstring, tdstring, servername);
    printf("<tr %s><th colspan=2 %s>Server Hostname:</th>"
	   "<td colspan=2 %s>%s</td></tr>\n",
	   trstring, tdstring, tdstring, hostname);
    printf("<tr %s><th colspan=2 %s>Server Port:</th>"
	   "<td colspan=2 %s>%d</td></tr>\n",
	   trstring, tdstring, tdstring, port);
    printf("<tr %s><th colspan=2 %s>Document Path:</th>"
	   "<td colspan=2 %s>%s</td></tr>\n",
	   trstring, tdstring, tdstring, path);
    printf("<tr %s><th colspan=2 %s>Document Length:</th>"
	   "<td colspan=2 %s>%d bytes</td></tr>\n",
	   trstring, tdstring, tdstring, doclen);
    printf("<tr %s><th colspan=2 %s>Concurrency Level:</th>"
	   "<td colspan=2 %s>%d</td></tr>\n",
	   trstring, tdstring, tdstring, concurrency);
    printf("<tr %s><th colspan=2 %s>Time taken for tests:</th>"
	   "<td colspan=2 %s>%ld.%03ld seconds</td></tr>\n",
	   trstring, tdstring, tdstring, timetaken / 1000, timetaken % 1000);
    printf("<tr %s><th colspan=2 %s>Complete requests:</th>"
	   "<td colspan=2 %s>%ld</td></tr>\n",
	   trstring, tdstring, tdstring, done);
    printf("<tr %s><th colspan=2 %s>Failed requests:</th>"
	   "<td colspan=2 %s>%ld</td></tr>\n",
	   trstring, tdstring, tdstring, bad);
    if (bad)
	printf("<tr %s><td colspan=4 %s >   (Connect: %d, Length: %d, Exceptions: %d)</td></tr>\n",
	       trstring, tdstring, err_conn, err_length, err_except);
    if (err_response)
	printf("<tr %s><th colspan=2 %s>Non-2xx responses:</th>"
	       "<td colspan=2 %s>%d</td></tr>\n",
	       trstring, tdstring, tdstring, err_response);
    if (keepalive)
	printf("<tr %s><th colspan=2 %s>Keep-Alive requests:</th>"
	       "<td colspan=2 %s>%ld</td></tr>\n",
	       trstring, tdstring, tdstring, doneka);
    printf("<tr %s><th colspan=2 %s>Total transferred:</th>"
	   "<td colspan=2 %s>%ld bytes</td></tr>\n",
	   trstring, tdstring, tdstring, totalread);
    if (posting > 0)
	printf("<tr %s><th colspan=2 %s>Total POSTed:</th>"
	       "<td colspan=2 %s>%ld</td></tr>\n",
	       trstring, tdstring, tdstring, totalposted);
    printf("<tr %s><th colspan=2 %s>HTML transferred:</th>"
	   "<td colspan=2 %s>%ld bytes</td></tr>\n",
	   trstring, tdstring, tdstring, totalbread);

    /* avoid divide by zero */
    if (timetaken) {
	printf("<tr %s><th colspan=2 %s>Requests per second:</th>"
	       "<td colspan=2 %s>%.2f</td></tr>\n",
	   trstring, tdstring, tdstring, 1000 * (float) (done) / timetaken);
	printf("<tr %s><th colspan=2 %s>Transfer rate:</th>"
	       "<td colspan=2 %s>%.2f kb/s received</td></tr>\n",
	     trstring, tdstring, tdstring, (float) (totalread) / timetaken);
	if (posting > 0) {
	    printf("<tr %s><td colspan=2 %s>&nbsp;</td>"
		   "<td colspan=2 %s>%.2f kb/s sent</td></tr>\n",
		   trstring, tdstring, tdstring,
		   (float) (totalposted) / timetaken);
	    printf("<tr %s><td colspan=2 %s>&nbsp;</td>"
		   "<td colspan=2 %s>%.2f kb/s total</td></tr>\n",
		   trstring, tdstring, tdstring,
		   (float) (totalread + totalposted) / timetaken);
	}
    } {
	/* work out connection times */
	long totalcon = 0, total = 0;
	long mincon = 9999999, mintot = 999999;
	long maxcon = 0, maxtot = 0;

	for (i = 0; i < requests; i++) {
	    struct data s = stats[i];
	    mincon = ap_min(mincon, s.ctime);
	    mintot = ap_min(mintot, s.time);
	    maxcon = ap_max(maxcon, s.ctime);
	    maxtot = ap_max(maxtot, s.time);
	    totalcon += s.ctime;
	    total += s.time;
	}

	if (requests > 0) {	/* avoid division by zero (if 0 requests) */
	    printf("<tr %s><th %s colspan=4>Connnection Times (ms)</th></tr>\n",
		   trstring, tdstring);
	    printf("<tr %s><th %s>&nbsp;</th> <th %s>min</th>   <th %s>avg</th>   <th %s>max</th></tr>\n",
		   trstring, tdstring, tdstring, tdstring, tdstring);
	    printf("<tr %s><th %s>Connect:</th>"
		   "<td %s>%5ld</td>"
		   "<td %s>%5ld</td>"
		   "<td %s>%5ld</td></tr>\n",
		   trstring, tdstring, tdstring, mincon, tdstring, totalcon / requests, tdstring, maxcon);
	    printf("<tr %s><th %s>Processing:</th>"
		   "<td %s>%5ld</td>"
		   "<td %s>%5ld</td>"
		   "<td %s>%5ld</td></tr>\n",
		   trstring, tdstring, tdstring, mintot - mincon, tdstring,
		   (total / requests) - (totalcon / requests), tdstring, maxtot - maxcon);
	    printf("<tr %s><th %s>Total:</th>"
		   "<td %s>%5ld</td>"
		   "<td %s>%5ld</td>"
		   "<td %s>%5ld</td></tr>\n",
		   trstring, tdstring, tdstring, mintot, tdstring, total / requests, tdstring, maxtot);
	}
	printf("</table>\n");
    }
}

/* --------------------------------------------------------- */

/* start asnchronous non-blocking connection */

static void start_connect(struct connection * c)
{
    const char *what = "none";

    c->read = 0;
    c->bread = 0;
    c->keepalive = 0;
    c->cbx = 0;
    c->gotheader = 0;

    c->fd = socket(AF_INET, SOCK_STREAM, 0);
    if (c->fd < 0) {
	what = "SOCKET";
	goto _bad;
    };

#ifdef USE_SSL
    /*
     * XXX move nonblocker - so that measnurement needs to have its OWN
     * state engine OR cannot be compared to http.
     */
    if (!ssl)
#endif
	nonblock(c->fd);

again:
    gettimeofday(&c->start, 0);
    if (connect(c->fd, (struct sockaddr *) & server, sizeof(server)) < 0) {
	if (errno != EINPROGRESS) {
	    what = "CONNECT";
	    goto _bad;
	};
    }
    c->state = STATE_CONNECTING;

#ifdef USE_SSL
    /* XXX no proper freeing in error's */
    /*
     * XXX no proper choise of completely new connection or one which reuses
     * (older) session keys. Fundamentally unrealistic.
     */
    if (ssl) {
	int e;
	if (!(c->ssl = SSL_new(ctx))) {
	    fprintf(stderr, "Failed to set up new SSL context ");
	    ERR_print_errors_fp(stderr);
	    goto _bad;
	};
	SSL_set_connect_state(c->ssl);
	if ((e = SSL_set_fd(c->ssl, c->fd)) == -1) {
	    fprintf(stderr, "SSL fd init failed ");
	    ERR_print_errors_fp(stderr);
	    goto _bad;
	};
	if ((e = SSL_connect(c->ssl)) == -1) {
	    fprintf(stderr, "SSL connect failed ");
	    ERR_print_errors_fp(stderr);
	    goto _bad;
	};
	if (verbosity >= 1)
	    fprintf(stderr, "SSL connection OK: %s\n", SSL_get_cipher(c->ssl));
    }
#endif
#ifdef USE_SSL
    if (ssl)
	nonblock(c->fd);
#endif
    FD_SET(c->fd, &writebits);
    return;

_bad:
    ab_close(c->fd);
    err_conn++;
    bad++;
    if (bad > 10) {
	err("\nTest aborted after 10 failures\n\n");
    }
    goto again;
}

/* --------------------------------------------------------- */

/* close down connection and save stats */

static void close_connection(struct connection * c)
{
    if (c->read == 0 && c->keepalive) {
	/*
	 * server has legitimately shut down an idle keep alive request
	 */
	good--;			/* connection never happend */
    }
    else {
	if (good == 1) {
	    /* first time here */
	    doclen = c->bread;
	}
	else if (c->bread != doclen) {
	    bad++;
	    err_length++;
	}
	/* save out time */
	if (done < requests) {
	    struct data s;
	    if ((done) && (heartbeatres) && (!(done % heartbeatres))) {
		fprintf(stderr, "Completed %ld requests\n", done);
		fflush(stderr);
	    }
	    gettimeofday(&c->done, 0);
	    s.read = c->read;
	    s.starttime = c->start.tv_sec;
	    s.ctime = timedif(c->connect, c->start);
	    s.waittime = timedif(c->beginread, c->endwrite);
	    s.time = timedif(c->done, c->start);
	    stats[done++] = s;
	}
    }

    ab_close(c->fd);
    FD_CLR(c->fd, &readbits);
    FD_CLR(c->fd, &writebits);

    /* connect again */
    start_connect(c);
    return;
}

/* --------------------------------------------------------- */

/* read data from connection */

static void read_connection(struct connection * c)
{
    int r;
    char *part;
    char respcode[4];		/* 3 digits and null */

    gettimeofday(&c->beginread, 0);
#ifdef USE_SSL
    if (ssl) {
	r = SSL_read(c->ssl, buffer, sizeof(buffer));
	/* XXX fundamentally worng .. */
	if (r < 0 && SSL_get_error(c->ssl, r) == SSL_ERROR_WANT_READ) {
	    r = -1;
	    errno = EAGAIN;
	}
    }
    else
#endif
	r = ab_read(c->fd, buffer, sizeof(buffer));

    if (r == 0 || (r < 0 && errno != EAGAIN)) {
	good++;
	close_connection(c);
	return;
    }
    if (r < 0 && errno == EAGAIN)
	return;

    c->read += r;
    totalread += r;

    if (!c->gotheader) {
	char *s;
	int l = 4;
	int space = CBUFFSIZE - c->cbx - 1;	/* -1 to allow for 0
						 * terminator */
	int tocopy = (space < r) ? space : r;
	memcpy(c->cbuff + c->cbx, buffer, tocopy);
	c->cbx += tocopy;
	space -= tocopy;
	c->cbuff[c->cbx] = 0;	/* terminate for benefit of strstr */
	if (verbosity >= 4) {
	    printf("LOG: header received:\n%s\n", c->cbuff);
	}
	s = strstr(c->cbuff, "\r\n\r\n");
	/*
	 * this next line is so that we talk to NCSA 1.5 which blatantly
	 * breaks the http specification
	 */
	if (!s) {
	    s = strstr(c->cbuff, "\n\n");
	    l = 2;
	}
	if (!s) {
	    /* read rest next time */
	    if (space)
		return;
	    else {
		/*
		 * header is in invalid or too big - close connection
		 */
		ab_close(c->fd);
		if (bad++ > 10) {
		    err("\nTest aborted after 10 failures\n\n");
		}
		FD_CLR(c->fd, &writebits);
		start_connect(c);
	    }
	}
	else {
	    /* have full header */
	    if (!good) {
		/*
		 * this is first time, extract some interesting info
		 */
		char *p, *q;
		int qlen;
		p = strstr(c->cbuff, "Server:");
		q = servername; qlen = sizeof(servername);
		if (p) {
		    p += 8;
		    while (*p > 32 && qlen-- > 1) 
			*q++ = *p++;
		}
		*q = 0;
	    }
	    /*
	     * XXX: this parsing isn't even remotely HTTP compliant... but in
	     * the interest of speed it doesn't totally have to be, it just
	     * needs to be extended to handle whatever servers folks want to
	     * test against. -djg
	     */

	    /* check response code */
	    part = strstr(c->cbuff, "HTTP");	/* really HTTP/1.x_ */
            if (part && strlen(part) > strlen("HTTP/1.x_")) {
                strncpy(respcode, (part + strlen("HTTP/1.x_")), 3);
                respcode[3] = '\0';
            }
            else {
                strlcpy(respcode, "500", sizeof(respcode));
            }

	    if (respcode[0] != '2') {
		err_response++;
		if (verbosity >= 2)
		    printf("WARNING: Response code not 2xx (%s)\n", respcode);
	    }
	    else if (verbosity >= 3) {
		printf("LOG: Response code = %s\n", respcode);
	    }
	    c->gotheader = 1;
	    *s = 0;		/* terminate at end of header */
	    if (keepalive &&
		(strstr(c->cbuff, "Keep-Alive")
		 || strstr(c->cbuff, "keep-alive"))) {	/* for benefit of MSIIS */
		char *cl;
		cl = strstr(c->cbuff, "Content-Length:");
		/* handle NCSA, which sends Content-length: */
		if (!cl)
		    cl = strstr(c->cbuff, "Content-length:");
		if (cl) {
		    c->keepalive = 1;
		    c->length = atoi(cl + 16);
		}
	    }
	    c->bread += c->cbx - (s + l - c->cbuff) + r - tocopy;
	    totalbread += c->bread;
	}
    }
    else {
	/* outside header, everything we have read is entity body */
	c->bread += r;
	totalbread += r;
    }

    /*
     * cater for the case where we're using keepalives and doing HEAD
     * requests
     */
    if (c->keepalive && ((c->bread >= c->length) || (posting < 0))) {
	/* finished a keep-alive connection */
	good++;
	doneka++;
	/* save out time */
	if (good == 1) {
	    /* first time here */
	    doclen = c->bread;
	}
	else if (c->bread != doclen) {
	    bad++;
	    err_length++;
	}
	if (done < requests) {
	    struct data s;
	    if ((done) && (heartbeatres) && (!(done % heartbeatres))) {
		fprintf(stderr, "Completed %ld requests\n", done);
		fflush(stderr);
	    }
	    gettimeofday(&c->done, 0);
	    s.read = c->read;
	    s.starttime = c->start.tv_sec;
	    s.ctime = timedif(c->connect, c->start);
	    s.waittime = timedif(c->beginread, c->endwrite);
	    s.time = timedif(c->done, c->start);
	    stats[done++] = s;
	}
	c->keepalive = 0;
	c->length = 0;
	c->gotheader = 0;
	c->cbx = 0;
	c->read = c->bread = 0;
	write_request(c);
	c->start = c->connect;	/* zero connect time with keep-alive */
    }
}

/* --------------------------------------------------------- */

/* run the tests */

static void test(void)
{
    struct timeval timeout, now;
    fd_set sel_read, sel_except, sel_write;
    long i;
    int connectport;
    char * connecthost;
    char * url_on_request;

    /* There are four hostname's involved:
     * The 'hostname' from the URL, the
     * hostname of the proxy, the value which
     * is to go into the Host: header and
     * the hostname we connect to over TCP.
     */
    if (isproxy) {
	/* Connect to proxyhost:proxyport
         * And set Host: to the hostname and
	 * if not default :port of the URL.
	 * See RFC2616 - $14.23. But then in
	 * $5.2.1 it says that the Host: field
	 * when passed on MUST be ignored. So	
	 * perhaps we should NOT send any
	 * when we are proxying.
	 */
	connecthost  = proxyhost;
	connectport = proxyport;
    	url_on_request = fullurl;
    }
    else {
	/* When there is no proxy: 
	 * use the hostname to connect to,
	 * use the hostname in the Host:
	 * header; and do not quote a full
	 * URL in the GET/POST line.
	 */
	connecthost  = hostname;
	connectport = port;
    	url_on_request = path;
    }
    
    if (!use_html) {
	printf("Benchmarking %s (be patient)%s",
	       hostname, (heartbeatres ? "\n" : "..."));
	fflush(stdout);
    }
    {
	/* get server information */
	struct hostent *he;
	he = gethostbyname(connecthost);
	if (!he) {
	    char theerror[1024];
	    ap_snprintf(theerror, sizeof(theerror),
                        "Bad hostname: %s\n", connecthost);
	    err(theerror);
	}
	server.sin_family = he->h_addrtype;
	server.sin_port = htons(connectport);
	server.sin_addr.s_addr = ((unsigned long *) (he->h_addr_list[0]))[0];
    }

    con = malloc(concurrency * sizeof(struct connection));
    memset(con, 0, concurrency * sizeof(struct connection));

    stats = malloc(requests * sizeof(struct data));

    FD_ZERO(&readbits);
    FD_ZERO(&writebits);

    /* setup request */
    if (posting <= 0) {
	ap_snprintf(request, sizeof(request), 
                    "%s %s HTTP/1.0\r\n"
                    "User-Agent: ApacheBench/%s\r\n"
                    "%s" "%s" "%s"
                    "Host: %s%s\r\n"
                    "Accept: */*\r\n"
                    "%s" "\r\n",
                    (posting == 0) ? "GET" : "HEAD",
                    url_on_request,
                    VERSION,
                    keepalive ? "Connection: Keep-Alive\r\n" : "",
                    cookie, auth, 
                    hostname,colonport, hdrs);
    }
    else {
        ap_snprintf(request, sizeof(request),
                    "POST %s HTTP/1.0\r\n"
                    "User-Agent: ApacheBench/%s\r\n"
                    "%s" "%s" "%s"
                    "Host: %s%s\r\n"
                    "Accept: */*\r\n"
                    "Content-length: %d\r\n"
                    "Content-type: %s\r\n"
                    "%s"
                    "\r\n",
                    url_on_request,
                    VERSION,
                    keepalive ? "Connection: Keep-Alive\r\n" : "",
                    cookie, auth,
                    hostname, colonport, postlen,
                    (content_type[0]) ? content_type : "text/plain", hdrs);
    }

    if (verbosity >= 2)
	printf("INFO: POST header == \n---\n%s\n---\n", request);

    reqlen = strlen(request);

    /* ok - lets start */
    gettimeofday(&start, 0);

    /* initialise lots of requests */
    for (i = 0; i < concurrency; i++)
	start_connect(&con[i]);

    while (done < requests) {
	int n;
	/* setup bit arrays */
	memcpy(&sel_except, &readbits, sizeof(readbits));
	memcpy(&sel_read, &readbits, sizeof(readbits));
	memcpy(&sel_write, &writebits, sizeof(readbits));

	/* check for time limit expiry */
	gettimeofday(&now, 0);
	if (tlimit && timedif(now, start) >= (tlimit * 1000)) {
	    requests = done;	/* so stats are correct */
	}
	/* Timeout of 30 seconds. */
	timeout.tv_sec = 120;
	timeout.tv_usec = 0;
	n = ap_select(FD_SETSIZE, &sel_read, &sel_write, &sel_except, &timeout);
	if (!n) {
	    err("\nServer timed out\n\n");
	}
	if (n < 1)
	    err("select");

	for (i = 0; i < concurrency; i++) {
	    int s = con[i].fd;
	    if (FD_ISSET(s, &sel_except)) {
		bad++;
		err_except++;
		start_connect(&con[i]);
		continue;
	    }
	    if (FD_ISSET(s, &sel_read))
		read_connection(&con[i]);
	    if (FD_ISSET(s, &sel_write))
		write_request(&con[i]);
	}
    }

    if (heartbeatres)
	fprintf(stderr, "Finished %ld requests\n", done);
    else
	printf("..done\n");

    if (use_html)
	output_html_results();
    else
	output_results();
}

/* ------------------------------------------------------- */

/* display copyright information */
static void copyright(void)
{
    if (!use_html) {
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.18 $> apache-1.3");
	printf("Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\n");
	printf("Copyright (c) 1998-2002 The Apache Software Foundation, http://www.apache.org/\n");
	printf("\n");
    }
    else {
	printf("<p>\n");
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.18 $");
	printf(" Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/<br>\n");
	printf(" Copyright (c) 1998-2002 The Apache Software Foundation, http://www.apache.org/<br>\n");
	printf("</p>\n<p>\n");
    }
}

/* display usage information */
static void usage(char *progname)
{
    fprintf(stderr, "Usage: %s [options] [http"
#ifdef USE_SSL
	    "[s]"
#endif
	    "://]hostname[:port]/path\n", progname);
    fprintf(stderr, "Options are:\n");
    fprintf(stderr, "    -n requests     Number of requests to perform\n");
    fprintf(stderr, "    -c concurrency  Number of multiple requests to make\n");
    fprintf(stderr, "    -t timelimit    Seconds to max. wait for responses\n");
    fprintf(stderr, "    -p postfile     File containg data to POST\n");
    fprintf(stderr, "    -T content-type Content-type header for POSTing\n");
    fprintf(stderr, "    -v verbosity    How much troubleshooting info to print\n");
    fprintf(stderr, "    -w              Print out results in HTML tables\n");
    fprintf(stderr, "    -i              Use HEAD instead of GET\n");
    fprintf(stderr, "    -x attributes   String to insert as table attributes\n");
    fprintf(stderr, "    -y attributes   String to insert as tr attributes\n");
    fprintf(stderr, "    -z attributes   String to insert as td or th attributes\n");
    fprintf(stderr, "    -C attribute    Add cookie, eg. 'Apache=1234' (repeatable)\n");
    fprintf(stderr, "    -H attribute    Add Arbitrary header line, eg. 'Accept-Encoding: zop'\n");
    fprintf(stderr, "                    Inserted after all normal header lines. (repeatable)\n");
    fprintf(stderr, "    -A attribute    Add Basic WWW Authentication, the attributes\n");
    fprintf(stderr, "                    are a colon separated username and password.\n");
    fprintf(stderr, "    -P attribute    Add Basic Proxy Authentication, the attributes\n");
    fprintf(stderr, "                    are a colon separated username and password.\n");
    fprintf(stderr, "    -X proxy:port   Proxyserver and port number to use\n");
    fprintf(stderr, "    -V              Print version number and exit\n");
    fprintf(stderr, "    -k              Use HTTP KeepAlive feature\n");
    fprintf(stderr, "    -d              Do not show percentiles served table.\n");
    fprintf(stderr, "    -S              Do not show confidence estimators and warnings.\n");
    fprintf(stderr, "    -g filename     Output collected data to gnuplot format file.\n");
    fprintf(stderr, "    -e filename     Output CSV file with percentages served\n");
#ifdef USE_SSL
    fprintf(stderr, "    -s              Use httpS instead of HTTP (SSL)\n");
#endif
    fprintf(stderr, "    -h              Display usage information (this message)\n");
    exit(EINVAL);
}

/* ------------------------------------------------------- */

/* split URL into parts */

static int parse_url(char * purl)
{
    char *cp;
    char *h;
    char *p = NULL;

    if (strlen(purl) > 7 && strncmp(purl, "http://", 7) == 0)
	purl += 7;
    else
#ifdef USE_SSL
    if (strlen(purl) > 8 && strncmp(purl, "https://", 8) == 0) {
	purl += 8;
	ssl = 1;
	port = 443;
    }
#else
    if (strlen(purl) > 8 && strncmp(purl, "https://", 8) == 0) {
	fprintf(stderr, "SSL not compiled in; no https support\n");
	exit(1);
    }
#endif

    h = purl;
    if ((cp = strchr(purl, ':')) != NULL) {
	*cp++ = '\0';
	p = cp;
	purl = cp;
    }
    if ((cp = strchr(purl, '/')) == NULL)
	return 1;
    strlcpy(path, cp, sizeof(path));
    *cp = '\0';
    strlcpy(hostname, h, sizeof(hostname));
    if (p != NULL)
	port = atoi(p);

    if ((
#ifdef USE_SSL
	(ssl != 0) && (port != 443)) || ((ssl == 0) && 
#endif
	(port != 80))) 
   {
	ap_snprintf(colonport,sizeof(colonport),":%d",port);
   } else {
	colonport[0] = '\0';
   }
   return 0;
}

/* ------------------------------------------------------- */

/* read data to POST from file, save contents and length */

static int open_postfile(char *pfile)
{
    int postfd, status;
    struct stat postfilestat;

    if ((postfd = open(pfile, O_RDONLY)) == -1) {
	printf("Invalid postfile name (%s)\n", pfile);
	return errno;
    }
    if ((status = fstat(postfd, &postfilestat)) == -1) {
	perror("Can\'t stat postfile\n");
	return status;
    }
    postdata = malloc(postfilestat.st_size);
    if (!postdata) {
	printf("Can\'t alloc postfile buffer\n");
	return ENOMEM;
    }
    if (read(postfd, postdata, postfilestat.st_size) != postfilestat.st_size) {
	printf("error reading postfilen");
	return EIO;
    }
    postlen = postfilestat.st_size;
    return 0;
}

/* ------------------------------------------------------- */

extern char *optarg;
extern int optind, opterr, optopt;

/* sort out command-line args and call test */
int main(int argc, char **argv)
{
    int c, r, l;
    char tmp[1024];
    /* table defaults  */
    tablestring = "";
    trstring = "";
    tdstring = "bgcolor=white";
    cookie[0] = '\0';
    auth[0] = '\0';
    hdrs[0] = '\0';
    proxyhost[0] = '\0';
    optind = 1;
    while ((c = getopt(argc, argv, "n:c:t:T:p:v:kVhwix:y:z:C:H:P:A:g:X:de:Sq"
#ifdef USE_SSL
		       "s"
#endif
		       )) > 0) {
	switch (c) {
#ifdef USE_SSL
	case 's':
	    ssl = 1;
	    break;
#endif
	case 'n':
	    requests = atoi(optarg);
	    if (!requests) {
		err("Invalid number of requests\n");
	    }
	    break;
	case 'q':
	    heartbeatres = 0;
	    break;
	case 'k':
	    keepalive = 1;
	    break;
	case 'c':
	    concurrency = atoi(optarg);
	    break;
	case 'g':
	    gnuplot = strdup(optarg);
	    break;
	case 'd':
	    percentile = 0;
	    break;
	case 'e':
	    csvperc = strdup(optarg);
	    break;
	case 'S':
	    confidence = 0;
	    break;
	case 'i':
	    if (posting == 1)
		err("Cannot mix POST and HEAD");

	    posting = -1;
	    break;
	case 'p':
	    if (posting != 0)
		err("Cannot mix POST and HEAD");

	    if (0 == (r = open_postfile(optarg))) {
		posting = 1;
	    }
	    else if (postdata) {
		exit(r);
	    }
	    break;
	case 'v':
	    verbosity = atoi(optarg);
	    break;
	case 't':
	    tlimit = atoi(optarg);
	    requests = MAX_REQUESTS;	/* need to size data array on
					 * something */
	    break;
	case 'T':
	    strlcpy(content_type, optarg, sizeof(content_type));
	    break;
	case 'C':
	    strncat(cookie, "Cookie: ", sizeof(cookie)-strlen(cookie)-1);
	    strncat(cookie, optarg, sizeof(cookie)-strlen(cookie)-1);
	    strncat(cookie, "\r\n", sizeof(cookie)-strlen(cookie)-1);
	    break;
	case 'A':
	    /*
	     * assume username passwd already to be in colon separated form.
	     * Ready to be uu-encoded.
	     */
	    while (isspace((int)*optarg))
		optarg++;
            if (ap_base64encode_len(strlen(optarg)) > sizeof(tmp)) {
                fprintf(stderr, "%s: Authentication credentials too long\n",
                        argv[0]);
                exit(1);
            }
            l = ap_base64encode(tmp, optarg, strlen(optarg));
	    tmp[l] = '\0';

	    strncat(auth, "Authorization: Basic ", sizeof(auth)-strlen(auth)-1);
	    strncat(auth, tmp, sizeof(auth)-strlen(auth)-1);
	    strncat(auth, "\r\n", sizeof(auth)-strlen(auth)-1);
	    break;
	case 'P':
	    /*
	     * assume username passwd already to be in colon separated form.
	     */
	    while (isspace((int)*optarg))
		optarg++;
            if (ap_base64encode_len(strlen(optarg)) > sizeof(tmp)) {
                fprintf(stderr, "%s: Proxy credentials too long\n", argv[0]);
                exit(1);
            }
	    l = ap_base64encode(tmp, optarg, strlen(optarg));
	    tmp[l] = '\0';

	    strncat(auth, "Proxy-Authorization: Basic ", sizeof(auth)-strlen(auth)-1);
	    strncat(auth, tmp, sizeof(auth)-strlen(auth)-1);
	    strncat(auth, "\r\n", sizeof(auth)-strlen(auth)-1);
	    break;
	case 'X':
	    {
		char *p;
		/*
		 * assume proxy-name[:port]
		 */
		if ((p = strchr(optarg, ':'))) {
		    *p = '\0';
		    p++;
		    proxyport = atoi(p);
		};
		strlcpy(proxyhost, optarg, sizeof(proxyhost));
		isproxy = 1;
	    }
	    break;
	case 'H':
	    strncat(hdrs, optarg, sizeof(hdrs)-strlen(hdrs)-1);
	    strncat(hdrs, "\r\n", sizeof(hdrs)-strlen(hdrs)-1);
	    break;
	case 'V':
	    copyright();
	    exit(0);
	    break;
	case 'w':
	    use_html = 1;
	    break;
	    /*
	     * if any of the following three are used, turn on html output
	     * automatically
	     */
	case 'x':
	    use_html = 1;
	    tablestring = optarg;
	    break;
	case 'y':
	    use_html = 1;
	    trstring = optarg;
	    break;
	case 'z':
	    use_html = 1;
	    tdstring = optarg;
	    break;
	case 'h':
	    usage(argv[0]);
	    break;
	default:
	    fprintf(stderr, "%s: invalid option `%c'\n", argv[0], c);
	    usage(argv[0]);
	    break;
	}
    }
    if (optind != argc - 1) {
	fprintf(stderr, "%s: wrong number of arguments\n", argv[0]);
	usage(argv[0]);
    }
    strlcpy(url, argv[optind++], sizeof(url));
    strlcpy(fullurl, url, sizeof(fullurl));
    if (parse_url(url)) {
	fprintf(stderr, "%s: invalid URL\n", argv[0]);
	usage(argv[0]);
    }

    if ((heartbeatres) && (requests > 150)) {
	heartbeatres = requests / 10;	/* Print a line every 10% of requests */
	if (heartbeatres < 100)
	    heartbeatres = 100;	/* but never more often than once every 100
				 * connections. */
    }
    else
	/* if there are less than 150 requests; do not show
	 * the little tick/tock dots.
	 */
	heartbeatres = 0;

#ifdef USE_SSL
    SSL_library_init();
    if (!(ctx = SSL_CTX_new(SSLv2_client_method()))) {
	fprintf(stderr, "Could not init SSL CTX: ");
	ERR_print_errors_fp(stderr);
	exit(1);
    }
#endif
    signal(SIGPIPE, SIG_IGN);           /* Ignore writes to connections that
					 * have been closed at the other end.
					 * These writes are dealt with in the
					 * s_write() function. */

    copyright();
    test();

    exit(0);
}
@


1.18
log
@cleanup and unifdef'ing, no change in object files
work by Daniel Ouellet <daniel@@presscom.net>
@
text
@d1321 1
a1321 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.17 $> apache-1.3");
d1328 1
a1328 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.17 $");
@


1.17
log
@kill more dead code, mostly inside #ifdef SOMENONSENSEONSTUPIDOSES
joint work by Michael Knudsen <e@@molioner.dk> and Daniel Ouellet
<daniel@@presscom.net> with my input
no change in binaries
@
text
@a120 3
/* affects include files on Solaris */
#define BSD_COMP

a152 2
#if ((!defined(RSAREF)) && (!defined(SYSSSL)))
/* Libraries on most systems.. */
a158 9
#else
/* Libraries for RSAref and SYSSSL */
#include <rsa.h>
#include <crypto.h>
#include <x509.h>
#include <pem.h>
#include <err.h>
#include <ssl.h>
#endif
d1321 1
a1321 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.16 $> apache-1.3");
d1328 1
a1328 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.16 $");
@


1.16
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@a149 1
#ifndef NO_WRITEV
a151 1
#endif
d1335 1
a1335 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.15 $> apache-1.3");
d1342 1
a1342 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.15 $");
@


1.15
log
@Fix printf format string. ok henning@@
@
text
@a146 3
#ifdef CHARSET_EBCDIC
#include "ebcdic.h"
#endif
a147 1
#ifndef MPE
a148 1
#endif
a297 1
#ifndef BEOS
a300 5
#else
#define ab_close(s) closesocket(s)
#define ab_read(a,b,c) recv(a,b,c,0)
#define ab_write(a,b,c) send(a,b,c,0)
#endif
a440 3
#ifdef BEOS
    setsockopt(fd, SOL_SOCKET, SO_NONBLOCK, &i, sizeof(i));
#else
a441 1
#endif
a1022 1
#ifndef CHARSET_EBCDIC
a1023 3
#else				/* CHARSET_EBCDIC */
	ascii2ebcdic(c->cbuff + c->cbx, buffer, tocopy);
#endif				/* CHARSET_EBCDIC */
a1275 4
#ifdef CHARSET_EBCDIC
    ebcdic2ascii(request, request, reqlen);
#endif				/* CHARSET_EBCDIC */

d1337 1
a1337 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.14 $> apache-1.3");
d1344 1
a1344 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.14 $");
@


1.14
log
@merge apache 1.3.29 and mod_ssl 2.8.16
ok brad@@
@
text
@d629 1
a629 1
			sttime,
d1360 1
a1360 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.13 $> apache-1.3");
d1367 1
a1367 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.1.1.5 $");
@


1.13
log
@string shit
ok markus@@
@
text
@d1360 1
a1360 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.12 $> apache-1.3");
d1367 2
a1368 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.12 $");	printf(" Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/<br>\n");
d1595 6
a1600 1
	    l = ap_base64encode(tmp, optarg, strlen(optarg));
d1613 4
@


1.12
log
@merge
@
text
@d1105 1
a1105 1
                strcpy(respcode, "500");
d1360 1
a1360 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.11 $> apache-1.3");
d1367 1
a1367 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.11 $");	printf(" Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/<br>\n");
@


1.11
log
@string shit; ok pval
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
d1100 8
a1107 2
	    strncpy(respcode, (part + strlen("HTTP/1.x_")), 3);
	    respcode[3] = '\0';
d1360 1
a1360 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.10 $> apache-1.3");
d1367 1
a1367 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.10 $");	printf(" Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/<br>\n");
@


1.10
log
@merge apache 1.3.27 and mod_ssl 2.8.11
@
text
@a103 1
  * - uses strcpy/etc.
d1354 1
a1354 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.67 $> apache-1.3");
d1361 1
a1361 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.67 $");	printf(" Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/<br>\n");
d1442 1
a1442 1
    strcpy(path, cp);
d1444 1
a1444 1
    strcpy(hostname, h);
d1574 1
a1574 1
	    strcpy(content_type, optarg);
d1619 1
a1619 1
		strcpy(proxyhost, optarg);
d1663 2
a1664 2
    strcpy(url, argv[optind++]);
    strcpy(fullurl, url);
@


1.9
log
@merge
@
text
@d1082 1
d1084 1
a1084 1
		q = servername;
d1087 1
a1087 1
		    while (*p > 32)
d1310 1
a1310 1
	if (tlimit && timedif(now, start) > (tlimit * 1000)) {
d1355 1
a1355 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.65 $> apache-1.3");
d1362 1
a1362 2
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.65 $");
	printf(" Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/<br>\n");
d1578 3
a1580 3
	    strncat(cookie, "Cookie: ", sizeof(cookie));
	    strncat(cookie, optarg, sizeof(cookie));
	    strncat(cookie, "\r\n", sizeof(cookie));
d1592 3
a1594 3
	    strncat(auth, "Authorization: Basic ", sizeof(auth));
	    strncat(auth, tmp, sizeof(auth));
	    strncat(auth, "\r\n", sizeof(auth));
d1605 3
a1607 3
	    strncat(auth, "Proxy-Authorization: Basic ", sizeof(auth));
	    strncat(auth, tmp, sizeof(auth));
	    strncat(auth, "\r\n", sizeof(auth));
d1625 2
a1626 2
	    strncat(hdrs, optarg, sizeof(hdrs));
	    strncat(hdrs, "\r\n", sizeof(hdrs));
@


1.8
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d98 1
a98 1
   **	   Contributed by Sander Temme - <sctemme@@covalent.net>, Early 2001
d164 1
a164 1
#if ((!(RSAREF)) && (!(SYSSSL)))
d258 1
d292 1
a292 1
char request[512];
d315 3
a317 2
#if NO_WRITEV || USE_SSL
static void s_write(struct connection * c, char *buff, int len);
d347 1
a347 1
#if !NO_WRITEV && !USE_SSL
d351 1
d353 1
a353 1
#if !NO_WRITEV && !USE_SSL
d363 1
a363 1
    writev(c->fd, out, outcnt);
d365 1
a365 1
    s_write(c, request, reqlen);
d367 2
a368 2
	s_write(c, postdata, postlen);
	totalposted += (reqlen + postlen);
d371 11
a381 2

    c->state = STATE_READ;
d384 1
d392 2
a393 2
#if NO_WRITEV || USE_SSL
static void s_write(struct connection * c, char *buff, int len)
d395 1
d398 1
a398 1
#if USE_SSL
d400 1
a400 1
	    n = SSL_write(c->ssl, buff, len);
d403 1
a403 1
		/* XXXX propably wrong !!! */
d412 1
a412 1
	    n = ab_write(c->fd, buff, len);
d422 1
a422 1
		return;
d424 1
a424 1
#if USE_SSL
d436 1
a436 1
		printf(" --> write(%x) %d (%d)\n", (unsigned char) buff[0], n, len);
d438 1
a438 1
	    len -= n;
d440 3
a442 1
    } while (len > 0);
d642 1
a642 1
	 * hates both/
d884 1
a884 1
	goto bad;
d887 1
a887 1
#if USE_SSL
d889 1
a889 1
     * XXXX move nonblocker - so that measnurement needs to have its OWN
d899 1
a899 4
	if (errno == EINPROGRESS) {
	    c->state = STATE_CONNECTING;
	}
	else {
d901 1
a901 1
	    goto bad;
d904 1
a904 4
    else {
	/* connected first time */
	c->state = STATE_CONNECTING;
    }
d907 1
a907 1
    /* XX no proper freeing in error's */
d909 1
a909 1
     * XXXX no proper choise of completely new connection or one which reuses
d917 1
a917 1
	    goto bad;
d923 1
a923 1
	    goto bad;
d928 1
a928 1
	    goto bad;
d934 1
a934 1
#if USE_SSL
d941 1
a941 1
bad:
d944 2
a945 1
    if (bad++ > 10) {
d1009 1
a1009 1
#if USE_SSL
d1012 1
a1012 1
	/* XXX fundamwentally worng .. */
d1186 2
a1187 1
    char * url_on_request, * host;
d1197 7
a1203 3
         * And set Host: to the hostname of
         * the proxy - whistl quoting the
	 * full URL in the GET/POST line.
d1205 1
a1205 1
	host  = proxyhost;
d1216 1
a1216 1
	host  = hostname;
d1220 1
a1220 1

d1229 1
a1229 1
	he = gethostbyname(host);
d1232 2
a1233 1
	    sprintf(theerror, "Bad hostname: %s\n", host);
d1251 13
a1263 12
	sprintf(request, "%s %s HTTP/1.0\r\n"
		"User-Agent: ApacheBench/%s\r\n"
		"%s" "%s" "%s"
		"Host: %s\r\n"
		"Accept: */*\r\n"
		"%s" "\r\n",
		(posting == 0) ? "GET" : "HEAD",
		url_on_request,
		VERSION,
		keepalive ? "Connection: Keep-Alive\r\n" : "",
		cookie, auth, 
		host, hdrs);
d1266 16
a1281 15
	sprintf(request, "POST %s HTTP/1.0\r\n"
		"User-Agent: ApacheBench/%s\r\n"
		"%s" "%s" "%s"
		"Host: %s\r\n"
		"Accept: */*\r\n"
		"Content-length: %d\r\n"
		"Content-type: %s\r\n"
		"%s"
		"\r\n",
		url_on_request,
		VERSION,
		keepalive ? "Connection: Keep-Alive\r\n" : "",
		cookie, auth,
		host, postlen,
		(content_type[0]) ? content_type : "text/plain", hdrs);
d1354 1
a1354 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.59 $> apache-1.3");
d1361 1
a1361 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.59 $");
d1372 1
a1372 1
#if USE_SSL
d1402 1
a1402 1
#if USE_SSL
d1422 1
a1422 1
#if USE_SSL
d1448 12
a1459 1
    return 0;
d1512 1
a1512 1
#if USE_SSL
d1517 1
a1517 1
#if USE_SSL
@


1.7
log
@correct select(FD_SETSIZE,...) misuse
@
text
@d2 4
a5 1
 * Copyright (c) 1998-1999 The Apache Group.  All rights reserved.
d19 6
a24 9
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
d26 4
a29 3
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
d31 3
a33 4
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
d35 4
a38 4
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d50 3
a52 5
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
d54 3
d86 13
d101 15
a116 11
/*
 * BUGS:
 *
 * - uses strcpy/etc.
 * - has various other poor buffer attacks related to the lazy parsing of
 *   response headers from the server
 * - doesn't implement much of HTTP/1.x, only accepts certain forms of
 *   responses
 * - (performance problem) heavy use of strstr shows up top in profile
 *   only an issue for loopback usage
 */
d118 1
a118 1
#define VERSION "1.3c"
d120 1
a120 1
/*  -------------------------------------------------------------------- */
d140 1
d162 22
d207 9
a215 1
    struct timeval start, connect, done;
d219 3
d223 6
a228 2
    int ctime;			/* time in ms to connect */
    int time;			/* time in ms for connection */
d233 1
d238 2
d241 2
a242 1
int requests = 1;		/* Number of requests to make */
d248 3
d254 4
d272 12
a283 7
int totalread = 0;		/* total number of bytes read */
int totalbread = 0;		/* totoal amount of entity body read */
int totalposted = 0;		/* total number of bytes posted, inc. headers */
int done = 0;			/* number of requests we have done */
int doneka = 0;			/* number of keep alive connections done */
int good = 0, bad = 0;		/* number of good and bad requests */

a300 1
int fd_max;			/* for select */
d313 5
d328 1
a328 1
	printf("%s", s);
d330 1
a330 1
    exit(errno);
d335 4
a338 2
/* write out request to a connection - assumes we can write
   (small) request out in one go into our new socket buffer  */
d342 6
a347 2
#ifndef NO_WRITEV
    struct iovec out[2]; int outcnt = 1;
d350 1
a350 1
#ifndef NO_WRITEV
d354 1
a354 1
    if (posting>0) {
d360 1
a360 1
    writev(c->fd,out, outcnt);
d362 4
a365 4
    ab_write(c->fd,request,reqlen);
    if (posting>0) {
        ab_write(c->fd,postdata,postlen);
        totalposted += (reqlen + postlen);
d372 1
a372 1
    fd_max = fd_max < c->fd ? c->fd : fd_max;
d377 55
d463 38
d503 2
a504 1
    int timetaken;
d518 1
a518 1
    printf("Time taken for tests:   %d.%03d seconds\n",
d520 2
a521 2
    printf("Complete requests:      %d\n", done);
    printf("Failed requests:        %d\n", bad);
d525 1
d529 5
a533 5
	printf("Keep-Alive requests:    %d\n", doneka);
    printf("Total transferred:      %d bytes\n", totalread);
    if (posting>0)
	printf("Total POSTed:           %d\n", totalposted);
    printf("HTML transferred:       %d bytes\n", totalbread);
d537 4
a540 2
	printf("Requests per second:    %.2f\n", 1000 * (float) (done) / timetaken);
	printf("Transfer rate:          %.2f kb/s received\n",
d542 1
a542 1
	if (posting>0) {
d549 1
a549 2

    {
d551 5
a555 4
	int i;
	int totalcon = 0, total = 0;
	int mincon = 9999999, mintot = 999999;
	int maxcon = 0, maxtot = 0;
d561 3
d566 3
d571 114
d686 1
a686 2
	if (requests > 0) { /* avoid division by zero (if 0 requests) */
	    printf("\nConnnection Times (ms)\n");
d688 38
a725 6
	    printf("Connect:    %5d %5d %5d\n", mincon, totalcon / requests, maxcon);
	    printf("Processing: %5d %5d %5d\n",
		   mintot - mincon, (total / requests) - (totalcon / requests),
		   maxtot - maxcon);
	    printf("Total:      %5d %5d %5d\n", mintot, total / requests, maxtot);
	}
d735 2
a736 1
    int timetaken;
d761 1
a761 1
	   "<td colspan=2 %s>%d.%03d seconds</td></tr>\n",
d764 1
a764 1
	   "<td colspan=2 %s>%d</td></tr>\n",
d767 1
a767 1
	   "<td colspan=2 %s>%d</td></tr>\n",
d778 1
a778 1
	       "<td colspan=2 %s>%d</td></tr>\n",
d781 1
a781 1
	   "<td colspan=2 %s>%d bytes</td></tr>\n",
d783 1
a783 1
    if (posting>0)
d785 1
a785 1
	       "<td colspan=2 %s>%d</td></tr>\n",
d788 1
a788 1
	   "<td colspan=2 %s>%d bytes</td></tr>\n",
d799 1
a799 1
	if (posting>0) {
d809 1
a809 3
    }

    {
d811 3
a813 4
	int i;
	int totalcon = 0, total = 0;
	int mincon = 9999999, mintot = 999999;
	int maxcon = 0, maxtot = 0;
d825 1
a825 1
	if (requests > 0) { /* avoid division by zero (if 0 requests) */
d831 3
a833 3
		   "<td %s>%5d</td>"
		   "<td %s>%5d</td>"
		   "<td %s>%5d</td></tr>\n",
d836 3
a838 3
		   "<td %s>%5d</td>"
		   "<td %s>%5d</td>"
		   "<td %s>%5d</td></tr>\n",
d842 3
a844 3
		   "<td %s>%5d</td>"
		   "<td %s>%5d</td>"
		   "<td %s>%5d</td></tr>\n",
d857 2
d866 13
a878 2
    if (c->fd < 0)
	err("socket");
d880 1
a880 1
    nonblock(c->fd);
a881 1

a884 3
	    FD_SET(c->fd, &writebits);
	    fd_max = fd_max < c->fd ? c->fd : fd_max;
	    return;
d887 7
a893 7
	    ab_close(c->fd);
	    err_conn++;
	    if (bad++ > 10) {
		err("\nTest aborted after 10 failures\n\n");
	    }
	    start_connect(c);
	}
d896 32
a927 2
    /* connected first time */
    c->state = STATE_CONNECTING;
d929 9
a937 1
    fd_max = fd_max < c->fd ? c->fd : fd_max;
d947 3
a949 1
	/* server has legitimately shut down an idle keep alive request */
a960 1

d964 4
d970 1
d972 1
d997 13
a1009 1
    r = ab_read(c->fd, buffer, sizeof(buffer));
a1015 1

a1047 1

d1053 3
a1055 1
		/* header is in invalid or too big - close connection */
d1067 3
a1069 1
		/* this is first time, extract some interesting info */
a1079 1

a1098 1

d1124 4
a1127 1
    /* cater for the case where we're using keepalives and doing HEAD requests */
d1143 4
d1149 1
d1151 1
d1173 31
a1203 1
    int i;
d1206 2
a1207 1
	printf("Benchmarking %s (be patient)...", hostname);
a1209 1

d1213 6
a1218 3
	he = gethostbyname(hostname);
	if (!he)
	    err("bad hostname");
d1220 1
a1220 1
	server.sin_port = htons(port);
a1230 1
    fd_max = 0;
d1241 1
a1241 1
		path,
d1244 2
a1245 1
		cookie, auth, hostname, hdrs);
d1257 1
a1257 1
		path,
d1261 1
a1261 1
		hostname, postlen,
a1292 1

d1294 1
a1294 1
	timeout.tv_sec = 30;
d1296 1
a1296 2
	n = ap_select(fd_max + 1, &sel_read, &sel_write, &sel_except,
		      &timeout);
d1317 6
d1335 1
a1335 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.6 $> apache-1.3");
d1337 1
a1337 1
	printf("Copyright (c) 1998-1999 The Apache Group, http://www.apache.org/\n");
d1342 1
a1342 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.6 $");
d1344 1
a1344 1
	printf(" Copyright (c) 1998-1999 The Apache Group, http://www.apache.org/<br>\n");
d1352 5
a1356 1
    fprintf(stderr, "Usage: %s [options] [http://]hostname[:port]/path\n", progname);
d1361 1
a1361 1
    fprintf(stderr, "    -p postfile     File containing data to POST\n");
d1374 1
a1374 1
    fprintf(stderr, "    -p attribute    Add Basic Proxy Authentication, the attributes\n");
d1376 1
d1379 7
d1394 1
a1394 1
static int parse_url(char *url)
d1400 18
a1417 4
    if (strlen(url) > 7 && strncmp(url, "http://", 7) == 0)
	url += 7;
    h = url;
    if ((cp = strchr(url, ':')) != NULL) {
d1420 1
a1420 1
	url = cp;
d1422 1
a1422 1
    if ((cp = strchr(url, '/')) == NULL)
d1470 1
a1470 1
    int c, r,l;
a1471 1

d1479 1
d1481 5
a1485 1
    while ((c = getopt(argc, argv, "n:c:t:T:p:v:kVhwix:y:z:C:H:P:A:")) > 0) {
d1487 5
d1498 3
d1507 12
d1520 1
a1520 1
	    if (posting==1) 
d1526 1
a1526 1
	    if (posting!=0) 
d1547 1
a1547 1
	case 'C': 
d1552 4
a1555 3
	case 'A': 
	    /* assume username passwd already to be in colon separated form. Ready
	     * to be uu-encoded.
d1557 1
a1557 1
	    while(isspace(*optarg))
d1559 2
a1560 2
	    l=ap_base64encode(tmp,optarg,strlen(optarg));
	    tmp[l]='\0';
d1570 1
a1570 1
	    while(isspace(*optarg))
d1572 2
a1573 2
	    l=ap_base64encode(tmp,optarg,strlen(optarg));
	    tmp[l]='\0';
d1579 15
d1634 3
a1636 2

    if (parse_url(argv[optind++])) {
d1640 25
@


1.6
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d229 1
d290 1
d546 1
d562 1
d795 1
d861 2
a862 1
	n = ap_select(FD_SETSIZE, &sel_read, &sel_write, &sel_except, &timeout);
d895 1
a895 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.5 $> apache-1.3");
d902 1
a902 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.5 $");
@


1.5
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d122 2
d889 1
a889 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.38 $> apache-1.3");
d896 1
a896 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.38 $");
d911 1
a911 1
    fprintf(stderr, "    -p postfile     File containg data to POST\n");
d919 1
a919 1
    fprintf(stderr, "    -C attribute    Add cookie, eg. 'Apache=1234. (repeatable)\n");
d1065 1
a1065 1
	    strncat(auth, "Authorization: basic ", sizeof(auth));
d1078 1
a1078 1
	    strncat(auth, "Proxy-Authorization: basic ", sizeof(auth));
@


1.4
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d84 1
a84 1
   **    - Added Cookie, Arbitrary header and auth support. <dirkx@@webweaving.org>, April 199
d887 1
a887 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.37 $> apache-1.3");
d894 1
a894 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.37 $");
@


1.3
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d100 1
a100 1
#define VERSION "1.3a"
d131 1
d133 1
d229 10
d269 1
a269 1
    if (posting) {
d277 3
a279 3
    write(c->fd,request,reqlen);
    if (posting) {
        write(c->fd,postdata,postlen);
d296 3
d300 1
d350 1
a350 1
    if (posting)
d359 1
a359 1
	if (posting) {
d448 1
a448 1
    if (posting)
d464 1
a464 1
	if (posting) {
d545 1
a545 1
	    close(c->fd);
d555 2
a556 1
    write_request(c);
d590 1
a590 1
    close(c->fd);
d609 2
a610 1
    r = read(c->fd, buffer, sizeof(buffer));
d656 1
a656 1
		close(c->fd);
d724 2
a725 1
    if (c->keepalive && (c->bread >= c->length)) {
d791 2
a792 2
    if (!posting) {
	sprintf(request, "GET %s HTTP/1.0\r\n"
d797 2
a798 1
		"\r\n" "%s",
d887 1
a887 1
	printf("This is ApacheBench, Version %s\n", VERSION);
d894 1
a894 1
	printf(" This is ApacheBench, Version %s<br>\n", VERSION);
d913 1
d1007 1
a1007 1
    while ((c = getopt(argc, argv, "n:c:t:T:p:v:kVhwx:y:z:C:H:P:A:")) > 0) {
d1021 6
d1028 3
@


1.2
log
@Apache 1.3.4 merge
@
text
@d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer. 
d58 16
a73 16
/* 
** This program is based on ZeusBench V1.0 written by Adam Twiss 
** which is Copyright (c) 1996 by Zeus Technology Ltd. http://www.zeustech.net/
**
** This software is provided "as is" and any express or implied waranties, 
** including but not limited to, the implied warranties of merchantability and
** fitness for a particular purpose are disclaimed.  In no event shall 
** Zeus Technology Ltd. be liable for any direct, indirect, incidental, special, 
** exemplary, or consequential damaged (including, but not limited to, 
** procurement of substitute good or services; loss of use, data, or profits;
** or business interruption) however caused and on theory of liability.  Whether
** in contract, strict liability or tort (including negligence or otherwise) 
** arising in any way out of the use of this software, even if advised of the
** possibility of such damage.
**
*/
d76 11
a86 9
** HISTORY: 
**    - Originally written by Adam Twiss <adam@@zeus.co.uk>, March 1996
**      with input from Mike Belshe <mbelshe@@netscape.com> and 
**      Michael Campanella <campanella@@stevms.enet.dec.com>
**    - Enhanced by Dean Gaudet <dgaudet@@apache.org>, November 1997
**    - Cleaned up by Ralf S. Engelschall <rse@@apache.org>, March 1998 
**    - POST and verbosity by Kurt Sussman <kls@@merlot.com>, August 1998 
**
*/
d100 1
a100 1
#define VERSION "1.2"
d123 2
a124 2
#define ap_select	select
#else /* (!)NO_APACHE_INCLUDES */
d126 4
d132 7
a138 1
#endif /* NO_APACHE_INCLUDES */
d154 8
a161 7
    int read;                   /* amount of bytes read */
    int bread;                  /* amount of body read */
    int length;                 /* Content-Length value used for keep-alive */
    char cbuff[CBUFFSIZE];      /* a buffer to store server response header */
    int cbx;                    /* offset in cbuffer */
    int keepalive;              /* non-zero if a keep-alive request */
    int gotheader;              /* non-zero if we have the entire header in cbuff */
d166 3
a168 3
    int read;                   /* number of bytes read */
    int ctime;                  /* time in ms to connect */
    int time;                   /* time in ms for connection */
d176 31
a206 22
int verbosity = 0;              /* no verbosity by default */
int posting = 0;                /* GET by default */
int requests = 1;               /* Number of requests to make */
int concurrency = 1;            /* Number of multiple requests to make */
int tlimit = 0;                 /* time limit in cs */
int keepalive = 0;              /* try and do keepalive connections */
char servername[1024];          /* name that server reports */
char hostname[1024];            /* host name */
char path[1024];                /* path name */
char postfile[1024];            /* name of file containing post data */
char* postdata;                 /* *buffer containing data from postfile */
int postlen = 0;                /* length of data to be POSTed */
char content_type[1024];        /* content type to put in POST header */
int port = 80;                  /* port number */

int doclen = 0;                 /* the length the document should be */
int totalread = 0;              /* total number of bytes read */
int totalbread = 0;             /* totoal amount of entity body read */
int totalposted = 0;            /* total number of bytes posted, inc. headers */
int done = 0;                   /* number of requests we have done */
int doneka = 0;                 /* number of keep alive connections done */
int good = 0, bad = 0;          /* number of good and bad requests */
d221 2
a222 2
struct connection *con;         /* connection array */
struct data *stats;             /* date for each request */
d224 2
a225 2
fd_set readbits, writebits;     /* bits for select */
struct sockaddr_in server;      /* server addr structure */
d234 1
a234 1
    	perror(s);
d244 1
a244 1
/* write out request to a connection - assumes we can write 
d247 1
a247 1
static void write_request(struct connection *c)
d249 3
d253 13
a265 2
    /* XXX: this could use writev for posting -- more efficient -djg */
    write(c->fd, request, reqlen);
d267 2
a268 2
        write(c->fd,postdata, postlen);
        totalposted += (reqlen + postlen); 
d270 1
d323 1
a323 1
           timetaken / 1000, timetaken % 1000);
d327 2
a328 2
        printf("   (Connect: %d, Length: %d, Exceptions: %d)\n",
               err_conn, err_length, err_except);
d330 1
a330 1
        printf("Non-2xx responses:      %d\n", err_response);
d332 1
a332 1
        printf("Keep-Alive requests:    %d\n", doneka);
d335 1
a335 1
        printf("Total POSTed:           %d\n", totalposted);
d340 9
a348 9
        printf("Requests per second:    %.2f\n", 1000 * (float) (done) / timetaken);
        printf("Transfer rate:          %.2f kb/s received\n",
               (float) (totalread) / timetaken);
        if (posting) {
            printf("                        %.2f kb/s sent\n", 
       		    (float)(totalposted)/timetaken);
            printf("                        %.2f kb/s total\n", 
           	    (float)(totalread + totalposted)/timetaken);
        }
d352 148
a499 22
        /* work out connection times */
        int i;
        int totalcon = 0, total = 0;
        int mincon = 9999999, mintot = 999999;
        int maxcon = 0, maxtot = 0;

        for (i = 0; i < requests; i++) {
            struct data s = stats[i];
            mincon = ap_min(mincon, s.ctime);
            mintot = ap_min(mintot, s.time);
            maxcon = ap_max(maxcon, s.ctime);
            maxtot = ap_max(maxtot, s.time);
            totalcon += s.ctime;
            total += s.time;
        }
        printf("\nConnnection Times (ms)\n");
        printf("              min   avg   max\n");
        printf("Connect:    %5d %5d %5d\n", mincon, totalcon / requests, maxcon);
        printf("Processing: %5d %5d %5d\n", 
            mintot - mincon, (total/requests) - (totalcon/requests),
            maxtot - maxcon);
        printf("Total:      %5d %5d %5d\n", mintot, total / requests, maxtot);
d505 1
a505 1
/* start asynchronous non-blocking connection */
d507 1
a507 1
static void start_connect(struct connection *c)
d517 1
a517 1
        err("socket");
d522 14
a535 14
    if (connect(c->fd, (struct sockaddr *) &server, sizeof(server)) < 0) {
        if (errno == EINPROGRESS) {
            c->state = STATE_CONNECTING;
            FD_SET(c->fd, &writebits);
            return;
        }
        else {
            close(c->fd);
            err_conn++;
            if (bad++ > 10) {
                err("\nTest aborted after 10 failures\n\n");
            }
            start_connect(c);
        }
d546 1
a546 1
static void close_connection(struct connection *c)
d549 2
a550 2
        /* server has legitimately shut down an idle keep alive request */
        good--;                 /* connection never happend */
d553 18
a570 18
        if (good == 1) {
            /* first time here */
            doclen = c->bread;
        }
        else if (c->bread != doclen) {
            bad++;
            err_length++;
        }

        /* save out time */
        if (done < requests) {
            struct data s;
            gettimeofday(&c->done, 0);
            s.read = c->read;
            s.ctime = timedif(c->connect, c->start);
            s.time = timedif(c->done, c->start);
            stats[done++] = s;
        }
d586 1
a586 1
static void read_connection(struct connection *c)
d590 1
a590 1
    char respcode[4];  /* 3 digits and null */
d594 3
a596 3
        good++;
        close_connection(c);
        return;
d600 1
a600 1
        return;
d606 5
a610 4
        char *s;
        int l = 4;
        int space = CBUFFSIZE - c->cbx - 1;     /* -1 to allow for 0 terminator */
        int tocopy = (space < r) ? space : r;
d612 7
a618 7
        memcpy(c->cbuff + c->cbx, buffer, space);
#else /*CHARSET_EBCDIC*/
        ascii2ebcdic(c->cbuff + c->cbx, buffer, space);
#endif /*CHARSET_EBCDIC*/
        c->cbx += tocopy;
        space -= tocopy;
        c->cbuff[c->cbx] = 0;   /* terminate for benefit of strstr */
d622 49
a670 45
        s = strstr(c->cbuff, "\r\n\r\n");
        /* this next line is so that we talk to NCSA 1.5 which blatantly breaks 
           the http specifaction */
        if (!s) {
            s = strstr(c->cbuff, "\n\n");
            l = 2;
        }

        if (!s) {
            /* read rest next time */
            if (space)
                return;
            else {
                /* header is in invalid or too big - close connection */
                close(c->fd);
                if (bad++ > 10) {
                    err("\nTest aborted after 10 failures\n\n");
                }
                FD_CLR(c->fd, &writebits);
                start_connect(c);
            }
        }
        else {
            /* have full header */
            if (!good) {
                /* this is first time, extract some interesting info */
                char *p, *q;
                p = strstr(c->cbuff, "Server:");
                q = servername;
                if (p) {
                    p += 8;
                    while (*p > 32)
                        *q++ = *p++;
                }
                *q = 0;
            }

	    /* XXX: this parsing isn't even remotely HTTP compliant...
	     * but in the interest of speed it doesn't totally have to be,
	     * it just needs to be extended to handle whatever servers
	     * folks want to test against. -djg */

            /* check response code */
            part = strstr(c->cbuff, "HTTP");                /* really HTTP/1.x_ */
            strncpy(respcode, (part+strlen("HTTP/1.x_")), 3);
d672 5
a676 4
            if (respcode[0] != '2') {
                err_response++;
                if (verbosity >= 2) printf ("WARNING: Response code not 2xx (%s)\n", respcode);
            }
d678 2
a679 2
                printf("LOG: Response code = %s\n", respcode);
            }
d681 18
a698 18
            c->gotheader = 1;
            *s = 0;             /* terminate at end of header */
            if (keepalive &&
                (strstr(c->cbuff, "Keep-Alive")
                 || strstr(c->cbuff, "keep-alive"))) {  /* for benefit of MSIIS */
                char *cl;
                cl = strstr(c->cbuff, "Content-Length:");
                /* handle NCSA, which sends Content-length: */
                if (!cl)
                    cl = strstr(c->cbuff, "Content-length:");
                if (cl) {
                    c->keepalive = 1;
                    c->length = atoi(cl + 16);
                }
            }
            c->bread += c->cbx - (s + l - c->cbuff) + r - tocopy;
            totalbread += c->bread;
        }
d701 3
a703 3
        /* outside header, everything we have read is entity body */
        c->bread += r;
        totalbread += r;
d707 27
a733 27
        /* finished a keep-alive connection */
        good++;
        doneka++;
        /* save out time */
        if (good == 1) {
            /* first time here */
            doclen = c->bread;
        }
        else if (c->bread != doclen) {
            bad++;
            err_length++;
        }
        if (done < requests) {
            struct data s;
            gettimeofday(&c->done, 0);
            s.read = c->read;
            s.ctime = timedif(c->connect, c->start);
            s.time = timedif(c->done, c->start);
            stats[done++] = s;
        }
        c->keepalive = 0;
        c->length = 0;
        c->gotheader = 0;
        c->cbx = 0;
        c->read = c->bread = 0;
        write_request(c);
        c->start = c->connect;  /* zero connect time with keep-alive */
d747 4
a750 2
    printf("Benchmarking %s (be patient)...", hostname);
    fflush(stdout);
d753 8
a760 8
        /* get server information */
        struct hostent *he;
        he = gethostbyname(hostname);
        if (!he)
            err("bad hostname");
        server.sin_family = he->h_addrtype;
        server.sin_port = htons(port);
        server.sin_addr.s_addr = ((unsigned long *) (he->h_addr_list[0]))[0];
d774 9
a782 9
                     "User-Agent: ApacheBench/%s\r\n"
                     "%s"
                     "Host: %s\r\n"
                     "Accept: */*\r\n"
                     "\r\n", 
                     path, 
                     VERSION,
                     keepalive ? "Connection: Keep-Alive\r\n" : "", 
                     hostname);
d786 14
a799 12
                     "User-Agent: ApacheBench/%s\r\n"
                     "%s"
                     "Host: %s\r\n"
                     "Accept: */*\r\n"
                     "Content-length: %d\r\n"
                     "Content-type: %s\r\n"
                     "\r\n", 
                     path, 
                     VERSION,
                     keepalive ? "Connection: Keep-Alive\r\n" : "", 
                     hostname, postlen, 
                     (content_type[0]) ? content_type : "text/plain");
d802 2
a803 1
    if (verbosity >= 2) printf("INFO: POST header == \n---\n%s\n---\n", request);
d809 1
a809 1
#endif /*CHARSET_EBCDIC*/
d816 1
a816 1
        start_connect(&con[i]);
d819 35
a853 35
        int n;
        /* setup bit arrays */
        memcpy(&sel_except, &readbits, sizeof(readbits));
        memcpy(&sel_read, &readbits, sizeof(readbits));
        memcpy(&sel_write, &writebits, sizeof(readbits));

        /* check for time limit expiry */
        gettimeofday(&now, 0);
        if (tlimit && timedif(now, start) > (tlimit * 1000)) {
            requests = done;    /* so stats are correct */
        }

        /* Timeout of 30 seconds. */
        timeout.tv_sec = 30;
        timeout.tv_usec = 0;
        n = ap_select(FD_SETSIZE, &sel_read, &sel_write, &sel_except, &timeout);
        if (!n) {
            err("\nServer timed out\n\n");
        }
        if (n < 1)
            err("select");

        for (i = 0; i < concurrency; i++) {
            int s = con[i].fd;
            if (FD_ISSET(s, &sel_except)) {
                bad++;
                err_except++;
                start_connect(&con[i]);
                continue;
            }
            if (FD_ISSET(s, &sel_read))
                read_connection(&con[i]);
            if (FD_ISSET(s, &sel_write))
                write_request(&con[i]);
        }
d855 4
a858 1
    output_results();
d864 1
a864 1
static void copyright(void) 
d866 13
a878 4
    printf("This is ApacheBench, Version %s\n", VERSION);
    printf("Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\n");
    printf("Copyright (c) 1998-1999 The Apache Group, http://www.apache.org/\n");
    printf("\n");
d892 11
d919 2
a920 2
    if (strlen(url) > 7 && strncmp(url, "http://", 7) == 0) 
        url += 7;
d923 3
a925 3
        *cp++ = '\0';
        p = cp;
        url = cp;
d928 1
a928 1
        return 1;
d933 1
a933 1
        port = atoi(p);
d947 2
a948 2
        printf("Invalid postfile name (%s)\n", pfile);
        return errno;
d951 2
a952 2
        perror("Can\'t stat postfile\n");
        return status;
d956 2
a957 2
        printf("Can\'t alloc postfile buffer\n");
        return ENOMEM;
d960 2
a961 2
        printf("error reading postfilen");
        return EIO;
d975 10
a984 1
    int c, r;
d986 18
a1003 18
    while ((c = getopt(argc, argv, "n:c:t:T:p:v:kVh")) > 0) {
        switch (c) {
        case 'n':
            requests = atoi(optarg);
            if (!requests) {
                err("Invalid number of requests\n");
            }
            break;
        case 'k':
            keepalive = 1;
            break;
        case 'c':
            concurrency = atoi(optarg);
            break;
        case 'p':
            if (0 == (r = open_postfile(optarg))) {
                posting = 1;
            }
d1005 1
a1005 1
                exit(r);
d1007 82
a1088 27
            break;
        case 'v':
            verbosity = atoi(optarg);
            break;
        case 't':
            tlimit = atoi(optarg);
            requests = MAX_REQUESTS;    /* need to size data array on something */
            break;
        case 'T':
            strcpy(content_type, optarg);
            break;
        case 'V':
            copyright();
            exit(0);
            break;
        case 'h':
            usage(argv[0]);
            break;
        default:
            fprintf(stderr, "%s: invalid option `%c'\n", argv[0], c);
            usage(argv[0]);
            break;
        }
    }
    if (optind != argc-1) {
        fprintf(stderr, "%s: wrong number of arguments\n", argv[0]);
        usage(argv[0]);
d1092 2
a1093 2
        fprintf(stderr, "%s: invalid URL\n", argv[0]);
        usage(argv[0]);
a1100 1

@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1998 The Apache Group.  All rights reserved.
d158 2
a159 2
#define min(a,b) ((a)<(b))?(a):(b)
#define max(a,b) ((a)>(b))?(a):(b)
d323 4
a326 4
            mincon = min(mincon, s.ctime);
            mintot = min(mintot, s.time);
            maxcon = max(maxcon, s.ctime);
            maxtot = max(maxtot, s.time);
d342 1
a342 1
/* start asnchronous non-blocking connection */
d691 1
a691 1
    printf("Copyright (c) 1998 The Apache Group, http://www.apache.org/\n");
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d2 1
a2 4
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer.
d16 9
a24 6
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
d26 3
a28 4
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
d30 4
a33 3
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
d35 4
a38 4
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
d40 7
a46 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d50 5
a54 3
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
a55 3
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
d58 17
d76 9
a84 15
   ** This program is based on ZeusBench V1.0 written by Adam Twiss
   ** which is Copyright (c) 1996 by Zeus Technology Ltd. http://www.zeustech.net/
   **
   ** This software is provided "as is" and any express or implied waranties,
   ** including but not limited to, the implied warranties of merchantability and
   ** fitness for a particular purpose are disclaimed.  In no event shall
   ** Zeus Technology Ltd. be liable for any direct, indirect, incidental, special,
   ** exemplary, or consequential damaged (including, but not limited to,
   ** procurement of substitute good or services; loss of use, data, or profits;
   ** or business interruption) however caused and on theory of liability.  Whether
   ** in contract, strict liability or tort (including negligence or otherwise)
   ** arising in any way out of the use of this software, even if advised of the
   ** possibility of such damage.
   **
 */
d87 9
a95 23
   ** HISTORY:
   **    - Originally written by Adam Twiss <adam@@zeus.co.uk>, March 1996
   **      with input from Mike Belshe <mbelshe@@netscape.com> and
   **      Michael Campanella <campanella@@stevms.enet.dec.com>
   **    - Enhanced by Dean Gaudet <dgaudet@@apache.org>, November 1997
   **    - Cleaned up by Ralf S. Engelschall <rse@@apache.org>, March 1998
   **    - POST and verbosity by Kurt Sussman <kls@@merlot.com>, August 1998
   **    - HTML table output added by David N. Welton <davidw@@prosa.it>, January 1999
   **    - Added Cookie, Arbitrary header and auth support. <dirkx@@webweaving.org>, April 1999
   ** Version 1.3d
   **    - Increased version number - as some of the socket/error handling has
   **      fundamentally changed - and will give fundamentally different results
   **      in situations where a server is dropping requests. Therefore you can
   **      no longer compare results of AB as easily. Hence the inc of the version.
   **      They should be closer to the truth though. Sander & <dirkx@@covalent.net>, End 2000.
   **    - Fixed proxy functionality, added median/mean statistics, added gnuplot
   **      output option, added _experimental/rudimentary_ SSL support. Added
   **      confidence guestimators and warnings. Sander & <dirkx@@covalent.net>, End 2000
   **    - Fixed serious int overflow issues which would cause realistic (longer
   **      than a few minutes) run's to have wrong (but believable) results. Added
   **	   trapping of connection errors which influenced measurements.
   **	   Contributed by Sander Temme - Early 2001
   **
a96 16
 /*
  * BUGS:
  *
  * - uses strcpy/etc.
  * - has various other poor buffer attacks related to the lazy parsing of
  *   response headers from the server
  * - doesn't implement much of HTTP/1.x, only accepts certain forms of
  *   responses
  * - (performance problem) heavy use of strstr shows up top in profile
  *   only an issue for loopback usage
  * - SSL implementation is a joke. Compile with:
  *	CFLAGS="-DUSE_SSL -I/usr/local/include" \
  *		LIBS="-L/usr/local/lib -lssl -lcrypto" \
  *		configure --your-other-options
  */

d98 1
a98 1
#define VERSION "1.3d"
d100 1
a100 1
/* -------------------------------------------------------------------- */
a119 3
#include <signal.h>
#include <sys/types.h>
#include <sys/uio.h>
d121 2
a122 2
#define ap_select       select
#else				/* (!)NO_APACHE_INCLUDES */
a123 4
#include "ap.h"
#ifdef CHARSET_EBCDIC
#include "ebcdic.h"
#endif
a124 1
#ifndef MPE
d126 1
a126 30
#endif

#ifndef NO_WRITEV
#include <sys/types.h>
#include <sys/uio.h>
#endif

#endif				/* NO_APACHE_INCLUDES */

#ifdef	USE_SSL
#if ((!defined(RSAREF)) && (!defined(SYSSSL)))
/* Libraries on most systems.. */
#include <openssl/rsa.h>
#include <openssl/crypto.h>
#include <openssl/x509.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <openssl/ssl.h>
#else
/* Libraries for RSAref and SYSSSL */
#include <rsa.h>
#include <crypto.h>
#include <x509.h>
#include <pem.h>
#include <err.h>
#include <ssl.h>
#endif
#endif

#include <math.h>
d142 8
a149 17
    int read;			/* amount of bytes read */
    int bread;			/* amount of body read */
    int length;			/* Content-Length value used for keep-alive */
    char cbuff[CBUFFSIZE];	/* a buffer to store server response header */
    int cbx;			/* offset in cbuffer */
    int keepalive;		/* non-zero if a keep-alive request */
    int gotheader;		/* non-zero if we have the entire header in
				 * cbuff */
    struct timeval start,	/* Start of connection */
            connect,		/* Connected, start writing */
            endwrite,		/* Request written */
            beginread,		/* First byte of input */
            done;		/* Connection closed */

#ifdef USE_SSL
    SSL *ssl;
#endif
d153 3
a155 10
#ifdef USE_SSL
    /* XXX insert timings for ssl */
#endif
    int read;			/* number of bytes read */
    long starttime;		/* start time of connection in seconds since
				 * Jan. 1, 1970 */
    long waittime;		/* Between writing request and reading
				 * response */
    long ctime;			/* time in ms to connect */
    long time;			/* time in ms for connection */
d158 2
a159 3
#define ap_min(a,b) ((a)<(b))?(a):(b)
#define ap_max(a,b) ((a)>(b))?(a):(b)
#define _rnd(x) ((long)(x+0.5))
d163 23
a185 48
int verbosity = 0;		/* no verbosity by default */
int percentile = 1;		/* Show percentile served */
int confidence = 1;		/* Show confidence estimator and warnings */
int posting = 0;		/* GET by default */
long requests = 1;		/* Number of requests to make */
int heartbeatres = 100;		/* How often do we say we're alive */
int concurrency = 1;		/* Number of multiple requests to make */
int tlimit = 0;			/* time limit in cs */
int keepalive = 0;		/* try and do keepalive connections */
char servername[1024];		/* name that server reports */
char hostname[1024];		/* host name */
char proxyhost[1024];		/* proxy host name */
int proxyport = 0;		/* proxy port */
int isproxy = 0;
char path[1024];		/* path name */
char postfile[1024];		/* name of file containing post data */
char *postdata;			/* *buffer containing data from postfile */
char *gnuplot;			/* GNUplot file */
char *csvperc;			/* CSV Percentile file */
char url[1024];
char fullurl[1024];
char colonport[1024];
int postlen = 0;		/* length of data to be POSTed */
char content_type[1024];	/* content type to put in POST header */
char cookie[1024],		/* optional cookie line */
     auth[1024],		/* optional (basic/uuencoded)
				 * authentification */
     hdrs[4096];		/* optional arbitrary headers */
int port = 80;			/* port number */

int use_html = 0;		/* use html in the report */
char *tablestring;
char *trstring;
char *tdstring;

int doclen = 0;			/* the length the document should be */
long totalread = 0;		/* total number of bytes read */
long totalbread = 0;		/* totoal amount of entity body read */
long totalposted = 0;		/* total number of bytes posted, inc. headers */
long done = 0;			/* number of requests we have done */
long doneka = 0;		/* number of keep alive connections done */
long good = 0, bad = 0;		/* number of good and bad requests */
long epipe = 0;			/* number of broken pipe writes */

#ifdef USE_SSL
int ssl = 0;
SSL_CTX *ctx;
#endif
d193 1
a193 1
char request[1024];
d199 2
a200 2
struct connection *con;		/* connection array */
struct data *stats;		/* date for each request */
d202 2
a203 18
fd_set readbits, writebits;	/* bits for select */
struct sockaddr_in server;	/* server addr structure */

#ifndef BEOS
#define ab_close(s) close(s)
#define ab_read(a,b,c) read(a,b,c)
#define ab_write(a,b,c) write(a,b,c)
#else
#define ab_close(s) closesocket(s)
#define ab_read(a,b,c) recv(a,b,c,0)
#define ab_write(a,b,c) send(a,b,c,0)
#endif

static void close_connection(struct connection * c);
#if (defined(NO_WRITEV) || defined(USE_SSL))
#define USE_S_WRITE
static int s_write(struct connection * c, char *buff, int len);
#endif
d212 1
a212 1
	perror(s);
d215 1
a215 1
	fprintf(stderr,"%s", s);
d217 1
a217 1
    exit(errno ? errno : 1);
d222 2
a223 4
/*
 * write out request to a connection - assumes we can write (small) request
 * out in one go into our new socket buffer
 */
d225 1
a225 1
static void write_request(struct connection * c)
a226 8
/* XXX this sucks - SSL mode and writev() do not mix
 *     another artificial difference.
 */
#ifndef USE_S_WRITE
    struct iovec out[2];
    int outcnt = 1;
#endif
    int snd = 0;
d228 5
a232 28
#ifndef USE_S_WRITE
    out[0].iov_base = request;
    out[0].iov_len = reqlen;

    if (posting > 0) {
	out[1].iov_base = postdata;
	out[1].iov_len = postlen;
	outcnt = 2;
	totalposted += (reqlen + postlen);
    }
    snd = writev(c->fd, out, outcnt);
#else
    snd = s_write(c, request, reqlen);
    if (posting > 0) {
        snd += s_write(c, postdata, postlen);
        totalposted += (reqlen + postlen);
    }
#endif
    if (snd < 0) {
	bad++; 
	err_conn++;
        close_connection(c);
	return;
    } else
    if (snd != (reqlen + postlen)) {
	/* We cannot cope with this. */
	fprintf(stderr,"The entire post RQ could not be transmitted to the socket.\n");
	exit(1);
d234 2
a237 2
    c->state = STATE_READ;
    gettimeofday(&c->endwrite, 0);
a241 58
/*  Do actual data writing */

#ifdef USE_S_WRITE
static int s_write(struct connection * c, char *buff, int len)
{
	int left = len;
    do {
	int n;
#ifdef USE_SSL
	if (ssl) {
	    n = SSL_write(c->ssl, buff, left);
	    if (n < 0) {
		int e = SSL_get_error(c->ssl, n);
		/* XXXX probably wrong !!! */
		if ((e != SSL_ERROR_WANT_READ) && (e != SSL_ERROR_WANT_WRITE))
		    n = -1;
		else
		    n = 0;
	    };
	}
	else
#endif
    n = ab_write(c->fd, buff, left);

	if (n < 0) {
	    switch (errno) {
	    case EAGAIN:
		break;
	    case EPIPE:
		/* We've tried to write to a broken pipe. */
		epipe++;
		close_connection(c);
		return len-left;
	    default:
#ifdef USE_SSL
		if (ssl) {
			fprintf(stderr,"Error writing: ");
	    		ERR_print_errors_fp(stderr);
		} else
#endif
			perror("write");
		exit(1);
	    }
	}
	else if (n) {
	    if (verbosity >= 3)
		printf(" --> write(%x) %d (%d)\n", (unsigned char) buff[0], n, left);
	    buff += n;
	    left -= n;
	};
    } while (left > 0);
    
	return len - left;
}
#endif

/* --------------------------------------------------------- */

a246 3
#ifdef BEOS
    setsockopt(fd, SOL_SOCKET, SO_NONBLOCK, &i, sizeof(i));
#else
a247 1
#endif
a268 38
static int compradre(struct data * a, struct data * b)
{
    if ((a->ctime) < (b->ctime))
	return -1;
    if ((a->ctime) > (b->ctime))
	return +1;
    return 0;
}

static int comprando(struct data * a, struct data * b)
{
    if ((a->time) < (b->time))
	return -1;
    if ((a->time) > (b->time))
	return +1;
    return 0;
}

static int compri(struct data * a, struct data * b)
{
    int p = a->time - a->ctime;
    int q = b->time - b->ctime;
    if (p < q)
	return -1;
    if (p > q)
	return +1;
    return 0;
}

static int compwait(struct data * a, struct data * b)
{
    if ((a->waittime) < (b->waittime))
	return -1;
    if ((a->waittime) > (b->waittime))
	return 1;
    return 0;
}

d271 1
a271 2
    long timetaken;
    long i;
d285 4
a288 4
    printf("Time taken for tests:   %ld.%03ld seconds\n",
	   timetaken / 1000, timetaken % 1000);
    printf("Complete requests:      %ld\n", done);
    printf("Failed requests:        %ld\n", bad);
d290 2
a291 3
	printf("   (Connect: %d, Length: %d, Exceptions: %d)\n",
	       err_conn, err_length, err_except);
    printf("Broken pipe errors:     %ld\n", epipe);
d293 1
a293 1
	printf("Non-2xx responses:      %d\n", err_response);
d295 5
a299 5
	printf("Keep-Alive requests:    %ld\n", doneka);
    printf("Total transferred:      %ld bytes\n", totalread);
    if (posting > 0)
	printf("Total POSTed:           %ld\n", totalposted);
    printf("HTML transferred:       %ld bytes\n", totalbread);
d303 9
a311 11
	printf("Requests per second:    %.2f [#/sec] (mean)\n", 1000 * (float) (done) / timetaken);
	printf("Time per request:       %.2f [ms] (mean)\n", concurrency * timetaken / (float) done);
	printf("Time per request:       %.2f [ms] (mean, across all concurrent requests)\n", timetaken / (float) done);
	printf("Transfer rate:          %.2f [Kbytes/sec] received\n",
	       (float) (totalread) / timetaken);
	if (posting > 0) {
	    printf("                        %.2f kb/s sent\n",
		   (float) (totalposted) / timetaken);
	    printf("                        %.2f kb/s total\n",
		   (float) (totalread + totalposted) / timetaken);
	}
a312 73
    if (requests>1) {
	/* work out connection times */
	double totalcon = 0, total = 0, totald = 0, totalwait = 0;
	long mincon = 9999999, mintot = 999999, mind = 99999, minwait = 99999;
	long maxcon = 0, maxtot = 0, maxd = 0, maxwait = 0;
	long meancon = 0, meantot = 0, meand = 0, meanwait = 0;
	double sdtot = 0, sdcon = 0, sdd = 0, sdwait = 0;

	for (i = 0; i < requests; i++) {
	    struct data s = stats[i];
	    mincon = ap_min(mincon, s.ctime);
	    mintot = ap_min(mintot, s.time);
	    mind = ap_min(mintot, s.time - s.ctime);
	    minwait = ap_min(minwait, s.waittime);

	    maxcon = ap_max(maxcon, s.ctime);
	    maxtot = ap_max(maxtot, s.time);
	    maxd = ap_max(maxd, s.time - s.ctime);
	    maxwait = ap_max(maxwait, s.waittime);

	    totalcon += s.ctime;
	    total += s.time;
	    totald += s.time - s.ctime;
	    totalwait += s.waittime;
	};
	totalcon /= requests;
	total /= requests;
	totald /= requests;
	totalwait /= requests;

	for (i = 0; i < requests; i++) {
	    struct data s = stats[i];
	    int a;
	    a = (s.time - total);
	    sdtot += a * a;
	    a = (s.ctime - totalcon);
	    sdcon += a * a;
	    a = (s.time - s.ctime - totald);
	    sdd += a * a;
	    a = (s.waittime - totalwait);
	    sdwait += a * a;
	};

	sdtot = (requests > 1) ? sqrt(sdtot / (requests - 1)) : 0;
	sdcon = (requests > 1) ? sqrt(sdcon / (requests - 1)) : 0;
	sdd = (requests > 1) ? sqrt(sdd / (requests - 1)) : 0;
	sdwait = (requests > 1) ? sqrt(sdwait / (requests - 1)) : 0;

	if (gnuplot) {
	    FILE *out = fopen(gnuplot, "w");
	    if (!out) {
		perror("Cannot open gnuplot output file");
		exit(1);
	    };
	    fprintf(out, "starttime\tseconds\tctime\tdtime\tttime\twait\n");
	    for (i = 0; i < requests; i++) {
		time_t sttime;
		char *tmstring;
		sttime = stats[i].starttime;
		tmstring = ctime(&sttime);
		tmstring[strlen(tmstring) - 1] = '\0';	/* ctime returns a
							 * string with a
							 * trailing newline */
		fprintf(out, "%s\t%ld\t%ld\t%ld\t%ld\t%ld\n",
			tmstring,
			sttime,
			stats[i].ctime,
			stats[i].time - stats[i].ctime,
			stats[i].time,
			stats[i].waittime);
	    }
	    fclose(out);
	};
d314 23
a336 225
	/*
	 * XXX: what is better; this hideous cast of the copare function; or
	 * the four warnings during compile ? dirkx just does not know and
	 * hates both
	 */
	qsort(stats, requests, sizeof(struct data),
	      (int (*) (const void *, const void *)) compradre);
	if ((requests > 1) && (requests % 2))
	    meancon = (stats[requests / 2].ctime + stats[requests / 2 + 1].ctime) / 2;
	else
	    meancon = stats[requests / 2].ctime;

	qsort(stats, requests, sizeof(struct data),
	      (int (*) (const void *, const void *)) compri);
	if ((requests > 1) && (requests % 2))
	    meand = (stats[requests / 2].time + stats[requests / 2 + 1].time \
	    -stats[requests / 2].ctime - stats[requests / 2 + 1].ctime) / 2;
	else
	    meand = stats[requests / 2].time - stats[requests / 2].ctime;

	qsort(stats, requests, sizeof(struct data),
	      (int (*) (const void *, const void *)) compwait);
	if ((requests > 1) && (requests % 2))
	    meanwait = (stats[requests / 2].waittime + stats[requests / 2 + 1].waittime) / 2;
	else
	    meanwait = stats[requests / 2].waittime;

	qsort(stats, requests, sizeof(struct data),
	      (int (*) (const void *, const void *)) comprando);
	if ((requests > 1) && (requests % 2))
	    meantot = (stats[requests / 2].time + stats[requests / 2 + 1].time) / 2;
	else
	    meantot = stats[requests / 2].time;


	printf("\nConnnection Times (ms)\n");

	if (confidence) {
	    printf("              min  mean[+/-sd] median   max\n");
	    printf("Connect:    %5ld %5ld %6.1f  %5ld %5ld\n",
		   mincon, _rnd(totalcon), sdcon, meancon, maxcon);
	    printf("Processing: %5ld %5ld %6.1f  %5ld %5ld\n",
		   mind, _rnd(totald), sdd, meand, maxd);
	    printf("Waiting:    %5ld %5ld %6.1f  %5ld %5ld\n",
		   minwait, _rnd(totalwait), sdwait, meanwait, maxwait);
	    printf("Total:      %5ld %5ld %6.1f  %5ld %5ld\n", mintot, _rnd(total), sdtot, meantot, maxtot);

#define     SANE(what,avg,mean,sd) \
            { \
		double d = avg - mean; \
		if (d < 0) d = -d; \
		if (d > 2 * sd ) \
			printf("ERROR: The median and mean for " what " are more than twice the standard\n" \
			    "       deviation apart. These results are NOT reliable.\n"); \
		else if (d > sd ) \
			printf("WARING: The median and mean for " what " are not within a normal deviation\n" \
			    "        These results are propably not that reliable.\n"); \
	    }
	    SANE("the initial connection time", totalcon, meancon, sdcon);
	    SANE("the processing time", totald, meand, sdd);
	    SANE("the waiting time", totalwait, meanwait, sdwait);
	    SANE("the total time", total, meantot, sdtot);
	}
	else {
	    printf("              min   avg   max\n");
	    printf("Connect:    %5ld %5ld %5ld\n", mincon, _rnd(totalcon), maxcon);
	    printf("Processing: %5ld %5ld %5ld\n", mind, _rnd(totald), maxd);
	    printf("Total:      %5ld %5ld %5ld\n", mintot, _rnd(total), maxtot);
	};

	/* Sorted on total connect times */
	if (percentile && (requests > 1)) {
	    printf("\nPercentage of the requests served within a certain time (ms)\n");
	    printf("  50%%  %5ld\n", stats[(int) (requests * 0.50)].time);
	    printf("  66%%  %5ld\n", stats[(int) (requests * 0.66)].time);
	    printf("  75%%  %5ld\n", stats[(int) (requests * 0.75)].time);
	    printf("  80%%  %5ld\n", stats[(int) (requests * 0.80)].time);
	    printf("  90%%  %5ld\n", stats[(int) (requests * 0.90)].time);
	    printf("  95%%  %5ld\n", stats[(int) (requests * 0.95)].time);
	    printf("  98%%  %5ld\n", stats[(int) (requests * 0.98)].time);
	    printf("  99%%  %5ld\n", stats[(int) (requests * 0.99)].time);
	    printf(" 100%%  %5ld (last request)\n", stats[(int) (requests - 1)].time);
	    \
	};
	if (csvperc) {
	    FILE *out = fopen(csvperc, "w");
	    if (!out) {
		perror("Cannot open CSV output file");
		exit(1);
	    };
	    fprintf(out, "" "Percentage served" "," "Time in ms" "\n");
	    for (i = 0; i < 100; i++) {
		double d;
		if (i == 0)
		    d = stats[0].time;
		else if (i == 100)
		    d = stats[requests - 1].time;
		else
		    d = stats[(int) (0.5 + requests * i / 100.0)].time;
		fprintf(out, "%ld,%f\n", i, d);
	    }
	    fclose(out);
	};
    }
}

/* --------------------------------------------------------- */

/* calculate and output results in HTML  */

static void output_html_results(void)
{
    long timetaken;
    long i;

    gettimeofday(&endtime, 0);
    timetaken = timedif(endtime, start);

    printf("\n\n<table %s>\n", tablestring);
    printf("<tr %s><th colspan=2 %s>Server Software:</th>"
	   "<td colspan=2 %s>%s</td></tr>\n",
	   trstring, tdstring, tdstring, servername);
    printf("<tr %s><th colspan=2 %s>Server Hostname:</th>"
	   "<td colspan=2 %s>%s</td></tr>\n",
	   trstring, tdstring, tdstring, hostname);
    printf("<tr %s><th colspan=2 %s>Server Port:</th>"
	   "<td colspan=2 %s>%d</td></tr>\n",
	   trstring, tdstring, tdstring, port);
    printf("<tr %s><th colspan=2 %s>Document Path:</th>"
	   "<td colspan=2 %s>%s</td></tr>\n",
	   trstring, tdstring, tdstring, path);
    printf("<tr %s><th colspan=2 %s>Document Length:</th>"
	   "<td colspan=2 %s>%d bytes</td></tr>\n",
	   trstring, tdstring, tdstring, doclen);
    printf("<tr %s><th colspan=2 %s>Concurrency Level:</th>"
	   "<td colspan=2 %s>%d</td></tr>\n",
	   trstring, tdstring, tdstring, concurrency);
    printf("<tr %s><th colspan=2 %s>Time taken for tests:</th>"
	   "<td colspan=2 %s>%ld.%03ld seconds</td></tr>\n",
	   trstring, tdstring, tdstring, timetaken / 1000, timetaken % 1000);
    printf("<tr %s><th colspan=2 %s>Complete requests:</th>"
	   "<td colspan=2 %s>%ld</td></tr>\n",
	   trstring, tdstring, tdstring, done);
    printf("<tr %s><th colspan=2 %s>Failed requests:</th>"
	   "<td colspan=2 %s>%ld</td></tr>\n",
	   trstring, tdstring, tdstring, bad);
    if (bad)
	printf("<tr %s><td colspan=4 %s >   (Connect: %d, Length: %d, Exceptions: %d)</td></tr>\n",
	       trstring, tdstring, err_conn, err_length, err_except);
    if (err_response)
	printf("<tr %s><th colspan=2 %s>Non-2xx responses:</th>"
	       "<td colspan=2 %s>%d</td></tr>\n",
	       trstring, tdstring, tdstring, err_response);
    if (keepalive)
	printf("<tr %s><th colspan=2 %s>Keep-Alive requests:</th>"
	       "<td colspan=2 %s>%ld</td></tr>\n",
	       trstring, tdstring, tdstring, doneka);
    printf("<tr %s><th colspan=2 %s>Total transferred:</th>"
	   "<td colspan=2 %s>%ld bytes</td></tr>\n",
	   trstring, tdstring, tdstring, totalread);
    if (posting > 0)
	printf("<tr %s><th colspan=2 %s>Total POSTed:</th>"
	       "<td colspan=2 %s>%ld</td></tr>\n",
	       trstring, tdstring, tdstring, totalposted);
    printf("<tr %s><th colspan=2 %s>HTML transferred:</th>"
	   "<td colspan=2 %s>%ld bytes</td></tr>\n",
	   trstring, tdstring, tdstring, totalbread);

    /* avoid divide by zero */
    if (timetaken) {
	printf("<tr %s><th colspan=2 %s>Requests per second:</th>"
	       "<td colspan=2 %s>%.2f</td></tr>\n",
	   trstring, tdstring, tdstring, 1000 * (float) (done) / timetaken);
	printf("<tr %s><th colspan=2 %s>Transfer rate:</th>"
	       "<td colspan=2 %s>%.2f kb/s received</td></tr>\n",
	     trstring, tdstring, tdstring, (float) (totalread) / timetaken);
	if (posting > 0) {
	    printf("<tr %s><td colspan=2 %s>&nbsp;</td>"
		   "<td colspan=2 %s>%.2f kb/s sent</td></tr>\n",
		   trstring, tdstring, tdstring,
		   (float) (totalposted) / timetaken);
	    printf("<tr %s><td colspan=2 %s>&nbsp;</td>"
		   "<td colspan=2 %s>%.2f kb/s total</td></tr>\n",
		   trstring, tdstring, tdstring,
		   (float) (totalread + totalposted) / timetaken);
	}
    } {
	/* work out connection times */
	long totalcon = 0, total = 0;
	long mincon = 9999999, mintot = 999999;
	long maxcon = 0, maxtot = 0;

	for (i = 0; i < requests; i++) {
	    struct data s = stats[i];
	    mincon = ap_min(mincon, s.ctime);
	    mintot = ap_min(mintot, s.time);
	    maxcon = ap_max(maxcon, s.ctime);
	    maxtot = ap_max(maxtot, s.time);
	    totalcon += s.ctime;
	    total += s.time;
	}

	if (requests > 0) {	/* avoid division by zero (if 0 requests) */
	    printf("<tr %s><th %s colspan=4>Connnection Times (ms)</th></tr>\n",
		   trstring, tdstring);
	    printf("<tr %s><th %s>&nbsp;</th> <th %s>min</th>   <th %s>avg</th>   <th %s>max</th></tr>\n",
		   trstring, tdstring, tdstring, tdstring, tdstring);
	    printf("<tr %s><th %s>Connect:</th>"
		   "<td %s>%5ld</td>"
		   "<td %s>%5ld</td>"
		   "<td %s>%5ld</td></tr>\n",
		   trstring, tdstring, tdstring, mincon, tdstring, totalcon / requests, tdstring, maxcon);
	    printf("<tr %s><th %s>Processing:</th>"
		   "<td %s>%5ld</td>"
		   "<td %s>%5ld</td>"
		   "<td %s>%5ld</td></tr>\n",
		   trstring, tdstring, tdstring, mintot - mincon, tdstring,
		   (total / requests) - (totalcon / requests), tdstring, maxtot - maxcon);
	    printf("<tr %s><th %s>Total:</th>"
		   "<td %s>%5ld</td>"
		   "<td %s>%5ld</td>"
		   "<td %s>%5ld</td></tr>\n",
		   trstring, tdstring, tdstring, mintot, tdstring, total / requests, tdstring, maxtot);
	}
	printf("</table>\n");
d344 1
a344 1
static void start_connect(struct connection * c)
a345 2
    const char *what = "none";

d353 2
a354 13
    if (c->fd < 0) {
	what = "SOCKET";
	goto _bad;
    };

#ifdef USE_SSL
    /*
     * XXX move nonblocker - so that measnurement needs to have its OWN
     * state engine OR cannot be compared to http.
     */
    if (!ssl)
#endif
	nonblock(c->fd);
d356 1
a356 1
again:
a357 42
    if (connect(c->fd, (struct sockaddr *) & server, sizeof(server)) < 0) {
	if (errno != EINPROGRESS) {
	    what = "CONNECT";
	    goto _bad;
	};
    }
    c->state = STATE_CONNECTING;

#ifdef USE_SSL
    /* XXX no proper freeing in error's */
    /*
     * XXX no proper choise of completely new connection or one which reuses
     * (older) session keys. Fundamentally unrealistic.
     */
    if (ssl) {
	int e;
	if (!(c->ssl = SSL_new(ctx))) {
	    fprintf(stderr, "Failed to set up new SSL context ");
	    ERR_print_errors_fp(stderr);
	    goto _bad;
	};
	SSL_set_connect_state(c->ssl);
	if ((e = SSL_set_fd(c->ssl, c->fd)) == -1) {
	    fprintf(stderr, "SSL fd init failed ");
	    ERR_print_errors_fp(stderr);
	    goto _bad;
	};
	if ((e = SSL_connect(c->ssl)) == -1) {
	    fprintf(stderr, "SSL connect failed ");
	    ERR_print_errors_fp(stderr);
	    goto _bad;
	};
	if (verbosity >= 1)
	    fprintf(stderr, "SSL connection OK: %s\n", SSL_get_cipher(c->ssl));
    }
#endif
#ifdef USE_SSL
    if (ssl)
	nonblock(c->fd);
#endif
    FD_SET(c->fd, &writebits);
    return;
d359 14
a372 6
_bad:
    ab_close(c->fd);
    err_conn++;
    bad++;
    if (bad > 10) {
	err("\nTest aborted after 10 failures\n\n");
d374 3
a376 1
    goto again;
d383 1
a383 1
static void close_connection(struct connection * c)
d386 2
a387 4
	/*
	 * server has legitimately shut down an idle keep alive request
	 */
	good--;			/* connection never happend */
d390 18
a407 23
	if (good == 1) {
	    /* first time here */
	    doclen = c->bread;
	}
	else if (c->bread != doclen) {
	    bad++;
	    err_length++;
	}
	/* save out time */
	if (done < requests) {
	    struct data s;
	    if ((done) && (heartbeatres) && (!(done % heartbeatres))) {
		fprintf(stderr, "Completed %ld requests\n", done);
		fflush(stderr);
	    }
	    gettimeofday(&c->done, 0);
	    s.read = c->read;
	    s.starttime = c->start.tv_sec;
	    s.ctime = timedif(c->connect, c->start);
	    s.waittime = timedif(c->beginread, c->endwrite);
	    s.time = timedif(c->done, c->start);
	    stats[done++] = s;
	}
d410 1
a410 1
    ab_close(c->fd);
d423 1
a423 1
static void read_connection(struct connection * c)
d427 1
a427 1
    char respcode[4];		/* 3 digits and null */
d429 5
a433 9
    gettimeofday(&c->beginread, 0);
#ifdef USE_SSL
    if (ssl) {
	r = SSL_read(c->ssl, buffer, sizeof(buffer));
	/* XXX fundamentally worng .. */
	if (r < 0 && SSL_get_error(c->ssl, r) == SSL_ERROR_WANT_READ) {
	    r = -1;
	    errno = EAGAIN;
	}
a434 3
    else
#endif
	r = ab_read(c->fd, buffer, sizeof(buffer));
a435 5
    if (r == 0 || (r < 0 && errno != EAGAIN)) {
	good++;
	close_connection(c);
	return;
    }
d437 1
a437 1
	return;
d443 4
a446 5
	char *s;
	int l = 4;
	int space = CBUFFSIZE - c->cbx - 1;	/* -1 to allow for 0
						 * terminator */
	int tocopy = (space < r) ? space : r;
d448 7
a454 7
	memcpy(c->cbuff + c->cbx, buffer, tocopy);
#else				/* CHARSET_EBCDIC */
	ascii2ebcdic(c->cbuff + c->cbx, buffer, tocopy);
#endif				/* CHARSET_EBCDIC */
	c->cbx += tocopy;
	space -= tocopy;
	c->cbuff[c->cbx] = 0;	/* terminate for benefit of strstr */
d458 45
a502 51
	s = strstr(c->cbuff, "\r\n\r\n");
	/*
	 * this next line is so that we talk to NCSA 1.5 which blatantly
	 * breaks the http specification
	 */
	if (!s) {
	    s = strstr(c->cbuff, "\n\n");
	    l = 2;
	}
	if (!s) {
	    /* read rest next time */
	    if (space)
		return;
	    else {
		/*
		 * header is in invalid or too big - close connection
		 */
		ab_close(c->fd);
		if (bad++ > 10) {
		    err("\nTest aborted after 10 failures\n\n");
		}
		FD_CLR(c->fd, &writebits);
		start_connect(c);
	    }
	}
	else {
	    /* have full header */
	    if (!good) {
		/*
		 * this is first time, extract some interesting info
		 */
		char *p, *q;
		p = strstr(c->cbuff, "Server:");
		q = servername;
		if (p) {
		    p += 8;
		    while (*p > 32)
			*q++ = *p++;
		}
		*q = 0;
	    }
	    /*
	     * XXX: this parsing isn't even remotely HTTP compliant... but in
	     * the interest of speed it doesn't totally have to be, it just
	     * needs to be extended to handle whatever servers folks want to
	     * test against. -djg
	     */

	    /* check response code */
	    part = strstr(c->cbuff, "HTTP");	/* really HTTP/1.x_ */
	    strncpy(respcode, (part + strlen("HTTP/1.x_")), 3);
d504 4
a507 5
	    if (respcode[0] != '2') {
		err_response++;
		if (verbosity >= 2)
		    printf("WARNING: Response code not 2xx (%s)\n", respcode);
	    }
d509 21
a529 20
		printf("LOG: Response code = %s\n", respcode);
	    }
	    c->gotheader = 1;
	    *s = 0;		/* terminate at end of header */
	    if (keepalive &&
		(strstr(c->cbuff, "Keep-Alive")
		 || strstr(c->cbuff, "keep-alive"))) {	/* for benefit of MSIIS */
		char *cl;
		cl = strstr(c->cbuff, "Content-Length:");
		/* handle NCSA, which sends Content-length: */
		if (!cl)
		    cl = strstr(c->cbuff, "Content-length:");
		if (cl) {
		    c->keepalive = 1;
		    c->length = atoi(cl + 16);
		}
	    }
	    c->bread += c->cbx - (s + l - c->cbuff) + r - tocopy;
	    totalbread += c->bread;
	}
d532 33
a564 43
	/* outside header, everything we have read is entity body */
	c->bread += r;
	totalbread += r;
    }

    /*
     * cater for the case where we're using keepalives and doing HEAD
     * requests
     */
    if (c->keepalive && ((c->bread >= c->length) || (posting < 0))) {
	/* finished a keep-alive connection */
	good++;
	doneka++;
	/* save out time */
	if (good == 1) {
	    /* first time here */
	    doclen = c->bread;
	}
	else if (c->bread != doclen) {
	    bad++;
	    err_length++;
	}
	if (done < requests) {
	    struct data s;
	    if ((done) && (heartbeatres) && (!(done % heartbeatres))) {
		fprintf(stderr, "Completed %ld requests\n", done);
		fflush(stderr);
	    }
	    gettimeofday(&c->done, 0);
	    s.read = c->read;
	    s.starttime = c->start.tv_sec;
	    s.ctime = timedif(c->connect, c->start);
	    s.waittime = timedif(c->beginread, c->endwrite);
	    s.time = timedif(c->done, c->start);
	    stats[done++] = s;
	}
	c->keepalive = 0;
	c->length = 0;
	c->gotheader = 0;
	c->cbx = 0;
	c->read = c->bread = 0;
	write_request(c);
	c->start = c->connect;	/* zero connect time with keep-alive */
d576 5
a580 42
    long i;
    int connectport;
    char * connecthost;
    char * url_on_request;

    /* There are four hostname's involved:
     * The 'hostname' from the URL, the
     * hostname of the proxy, the value which
     * is to go into the Host: header and
     * the hostname we connect to over TCP.
     */
    if (isproxy) {
	/* Connect to proxyhost:proxyport
         * And set Host: to the hostname and
	 * if not default :port of the URL.
	 * See RFC2616 - $14.23. But then in
	 * $5.2.1 it says that the Host: field
	 * when passed on MUST be ignored. So	
	 * perhaps we should NOT send any
	 * when we are proxying.
	 */
	connecthost  = proxyhost;
	connectport = proxyport;
    	url_on_request = fullurl;
    }
    else {
	/* When there is no proxy: 
	 * use the hostname to connect to,
	 * use the hostname in the Host:
	 * header; and do not quote a full
	 * URL in the GET/POST line.
	 */
	connecthost  = hostname;
	connectport = port;
    	url_on_request = path;
    }
    
    if (!use_html) {
	printf("Benchmarking %s (be patient)%s",
	       hostname, (heartbeatres ? "\n" : "..."));
	fflush(stdout);
    }
d582 8
a589 12
	/* get server information */
	struct hostent *he;
	he = gethostbyname(connecthost);
	if (!he) {
	    char theerror[1024];
	    ap_snprintf(theerror, sizeof(theerror),
                        "Bad hostname: %s\n", connecthost);
	    err(theerror);
	}
	server.sin_family = he->h_addrtype;
	server.sin_port = htons(connectport);
	server.sin_addr.s_addr = ((unsigned long *) (he->h_addr_list[0]))[0];
d601 11
a611 14
    if (posting <= 0) {
	ap_snprintf(request, sizeof(request), 
                    "%s %s HTTP/1.0\r\n"
                    "User-Agent: ApacheBench/%s\r\n"
                    "%s" "%s" "%s"
                    "Host: %s%s\r\n"
                    "Accept: */*\r\n"
                    "%s" "\r\n",
                    (posting == 0) ? "GET" : "HEAD",
                    url_on_request,
                    VERSION,
                    keepalive ? "Connection: Keep-Alive\r\n" : "",
                    cookie, auth, 
                    hostname,colonport, hdrs);
d614 13
a626 16
        ap_snprintf(request, sizeof(request),
                    "POST %s HTTP/1.0\r\n"
                    "User-Agent: ApacheBench/%s\r\n"
                    "%s" "%s" "%s"
                    "Host: %s%s\r\n"
                    "Accept: */*\r\n"
                    "Content-length: %d\r\n"
                    "Content-type: %s\r\n"
                    "%s"
                    "\r\n",
                    url_on_request,
                    VERSION,
                    keepalive ? "Connection: Keep-Alive\r\n" : "",
                    cookie, auth,
                    hostname, colonport, postlen,
                    (content_type[0]) ? content_type : "text/plain", hdrs);
d629 1
a629 2
    if (verbosity >= 2)
	printf("INFO: POST header == \n---\n%s\n---\n", request);
d635 1
a635 1
#endif				/* CHARSET_EBCDIC */
d642 1
a642 1
	start_connect(&con[i]);
d645 35
a679 34
	int n;
	/* setup bit arrays */
	memcpy(&sel_except, &readbits, sizeof(readbits));
	memcpy(&sel_read, &readbits, sizeof(readbits));
	memcpy(&sel_write, &writebits, sizeof(readbits));

	/* check for time limit expiry */
	gettimeofday(&now, 0);
	if (tlimit && timedif(now, start) > (tlimit * 1000)) {
	    requests = done;	/* so stats are correct */
	}
	/* Timeout of 30 seconds. */
	timeout.tv_sec = 120;
	timeout.tv_usec = 0;
	n = ap_select(FD_SETSIZE, &sel_read, &sel_write, &sel_except, &timeout);
	if (!n) {
	    err("\nServer timed out\n\n");
	}
	if (n < 1)
	    err("select");

	for (i = 0; i < concurrency; i++) {
	    int s = con[i].fd;
	    if (FD_ISSET(s, &sel_except)) {
		bad++;
		err_except++;
		start_connect(&con[i]);
		continue;
	    }
	    if (FD_ISSET(s, &sel_read))
		read_connection(&con[i]);
	    if (FD_ISSET(s, &sel_write))
		write_request(&con[i]);
	}
d681 1
a681 10

    if (heartbeatres)
	fprintf(stderr, "Finished %ld requests\n", done);
    else
	printf("..done\n");

    if (use_html)
	output_html_results();
    else
	output_results();
d687 1
a687 1
static void copyright(void)
d689 4
a692 13
    if (!use_html) {
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.65 $> apache-1.3");
	printf("Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\n");
	printf("Copyright (c) 1998-2002 The Apache Software Foundation, http://www.apache.org/\n");
	printf("\n");
    }
    else {
	printf("<p>\n");
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.65 $");
	printf(" Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/<br>\n");
	printf(" Copyright (c) 1998-2002 The Apache Software Foundation, http://www.apache.org/<br>\n");
	printf("</p>\n<p>\n");
    }
d698 1
a698 5
    fprintf(stderr, "Usage: %s [options] [http"
#ifdef USE_SSL
	    "[s]"
#endif
	    "://]hostname[:port]/path\n", progname);
a705 13
    fprintf(stderr, "    -w              Print out results in HTML tables\n");
    fprintf(stderr, "    -i              Use HEAD instead of GET\n");
    fprintf(stderr, "    -x attributes   String to insert as table attributes\n");
    fprintf(stderr, "    -y attributes   String to insert as tr attributes\n");
    fprintf(stderr, "    -z attributes   String to insert as td or th attributes\n");
    fprintf(stderr, "    -C attribute    Add cookie, eg. 'Apache=1234' (repeatable)\n");
    fprintf(stderr, "    -H attribute    Add Arbitrary header line, eg. 'Accept-Encoding: zop'\n");
    fprintf(stderr, "                    Inserted after all normal header lines. (repeatable)\n");
    fprintf(stderr, "    -A attribute    Add Basic WWW Authentication, the attributes\n");
    fprintf(stderr, "                    are a colon separated username and password.\n");
    fprintf(stderr, "    -P attribute    Add Basic Proxy Authentication, the attributes\n");
    fprintf(stderr, "                    are a colon separated username and password.\n");
    fprintf(stderr, "    -X proxy:port   Proxyserver and port number to use\n");
a707 7
    fprintf(stderr, "    -d              Do not show percentiles served table.\n");
    fprintf(stderr, "    -S              Do not show confidence estimators and warnings.\n");
    fprintf(stderr, "    -g filename     Output collected data to gnuplot format file.\n");
    fprintf(stderr, "    -e filename     Output CSV file with percentages served\n");
#ifdef USE_SSL
    fprintf(stderr, "    -s              Use httpS instead of HTTP (SSL)\n");
#endif
d716 1
a716 1
static int parse_url(char * purl)
d722 7
a728 21
    if (strlen(purl) > 7 && strncmp(purl, "http://", 7) == 0)
	purl += 7;
    else
#ifdef USE_SSL
    if (strlen(purl) > 8 && strncmp(purl, "https://", 8) == 0) {
	purl += 8;
	ssl = 1;
	port = 443;
    }
#else
    if (strlen(purl) > 8 && strncmp(purl, "https://", 8) == 0) {
	fprintf(stderr, "SSL not compiled in; no https support\n");
	exit(1);
    }
#endif

    h = purl;
    if ((cp = strchr(purl, ':')) != NULL) {
	*cp++ = '\0';
	p = cp;
	purl = cp;
d730 2
a731 2
    if ((cp = strchr(purl, '/')) == NULL)
	return 1;
d736 2
a737 13
	port = atoi(p);

    if ((
#ifdef USE_SSL
	(ssl != 0) && (port != 443)) || ((ssl == 0) && 
#endif
	(port != 80))) 
   {
	ap_snprintf(colonport,sizeof(colonport),":%d",port);
   } else {
	colonport[0] = '\0';
   }
   return 0;
d750 2
a751 2
	printf("Invalid postfile name (%s)\n", pfile);
	return errno;
d754 2
a755 2
	perror("Can\'t stat postfile\n");
	return status;
d759 2
a760 2
	printf("Can\'t alloc postfile buffer\n");
	return ENOMEM;
d763 2
a764 2
	printf("error reading postfilen");
	return EIO;
d778 1
a778 10
    int c, r, l;
    char tmp[1024];
    /* table defaults  */
    tablestring = "";
    trstring = "";
    tdstring = "bgcolor=white";
    cookie[0] = '\0';
    auth[0] = '\0';
    hdrs[0] = '\0';
    proxyhost[0] = '\0';
d780 18
a797 51
    while ((c = getopt(argc, argv, "n:c:t:T:p:v:kVhwix:y:z:C:H:P:A:g:X:de:Sq"
#ifdef USE_SSL
		       "s"
#endif
		       )) > 0) {
	switch (c) {
#ifdef USE_SSL
	case 's':
	    ssl = 1;
	    break;
#endif
	case 'n':
	    requests = atoi(optarg);
	    if (!requests) {
		err("Invalid number of requests\n");
	    }
	    break;
	case 'q':
	    heartbeatres = 0;
	    break;
	case 'k':
	    keepalive = 1;
	    break;
	case 'c':
	    concurrency = atoi(optarg);
	    break;
	case 'g':
	    gnuplot = strdup(optarg);
	    break;
	case 'd':
	    percentile = 0;
	    break;
	case 'e':
	    csvperc = strdup(optarg);
	    break;
	case 'S':
	    confidence = 0;
	    break;
	case 'i':
	    if (posting == 1)
		err("Cannot mix POST and HEAD");

	    posting = -1;
	    break;
	case 'p':
	    if (posting != 0)
		err("Cannot mix POST and HEAD");

	    if (0 == (r = open_postfile(optarg))) {
		posting = 1;
	    }
d799 1
a799 1
		exit(r);
d801 32
a832 94
	    break;
	case 'v':
	    verbosity = atoi(optarg);
	    break;
	case 't':
	    tlimit = atoi(optarg);
	    requests = MAX_REQUESTS;	/* need to size data array on
					 * something */
	    break;
	case 'T':
	    strcpy(content_type, optarg);
	    break;
	case 'C':
	    strncat(cookie, "Cookie: ", sizeof(cookie));
	    strncat(cookie, optarg, sizeof(cookie));
	    strncat(cookie, "\r\n", sizeof(cookie));
	    break;
	case 'A':
	    /*
	     * assume username passwd already to be in colon separated form.
	     * Ready to be uu-encoded.
	     */
	    while (isspace((int)*optarg))
		optarg++;
	    l = ap_base64encode(tmp, optarg, strlen(optarg));
	    tmp[l] = '\0';

	    strncat(auth, "Authorization: Basic ", sizeof(auth));
	    strncat(auth, tmp, sizeof(auth));
	    strncat(auth, "\r\n", sizeof(auth));
	    break;
	case 'P':
	    /*
	     * assume username passwd already to be in colon separated form.
	     */
	    while (isspace((int)*optarg))
		optarg++;
	    l = ap_base64encode(tmp, optarg, strlen(optarg));
	    tmp[l] = '\0';

	    strncat(auth, "Proxy-Authorization: Basic ", sizeof(auth));
	    strncat(auth, tmp, sizeof(auth));
	    strncat(auth, "\r\n", sizeof(auth));
	    break;
	case 'X':
	    {
		char *p;
		/*
		 * assume proxy-name[:port]
		 */
		if ((p = strchr(optarg, ':'))) {
		    *p = '\0';
		    p++;
		    proxyport = atoi(p);
		};
		strcpy(proxyhost, optarg);
		isproxy = 1;
	    }
	    break;
	case 'H':
	    strncat(hdrs, optarg, sizeof(hdrs));
	    strncat(hdrs, "\r\n", sizeof(hdrs));
	    break;
	case 'V':
	    copyright();
	    exit(0);
	    break;
	case 'w':
	    use_html = 1;
	    break;
	    /*
	     * if any of the following three are used, turn on html output
	     * automatically
	     */
	case 'x':
	    use_html = 1;
	    tablestring = optarg;
	    break;
	case 'y':
	    use_html = 1;
	    trstring = optarg;
	    break;
	case 'z':
	    use_html = 1;
	    tdstring = optarg;
	    break;
	case 'h':
	    usage(argv[0]);
	    break;
	default:
	    fprintf(stderr, "%s: invalid option `%c'\n", argv[0], c);
	    usage(argv[0]);
	    break;
	}
a833 35
    if (optind != argc - 1) {
	fprintf(stderr, "%s: wrong number of arguments\n", argv[0]);
	usage(argv[0]);
    }
    strcpy(url, argv[optind++]);
    strcpy(fullurl, url);
    if (parse_url(url)) {
	fprintf(stderr, "%s: invalid URL\n", argv[0]);
	usage(argv[0]);
    }

    if ((heartbeatres) && (requests > 150)) {
	heartbeatres = requests / 10;	/* Print a line every 10% of requests */
	if (heartbeatres < 100)
	    heartbeatres = 100;	/* but never more often than once every 100
				 * connections. */
    }
    else
	/* if there are less than 150 requests; do not show
	 * the little tick/tock dots.
	 */
	heartbeatres = 0;

#ifdef USE_SSL
    SSL_library_init();
    if (!(ctx = SSL_CTX_new(SSLv2_client_method()))) {
	fprintf(stderr, "Could not init SSL CTX: ");
	ERR_print_errors_fp(stderr);
	exit(1);
    }
#endif
    signal(SIGPIPE, SIG_IGN);           /* Ignore writes to connections that
					 * have been closed at the other end.
					 * These writes are dealt with in the
					 * s_write() function. */
d840 1
@


1.1.1.3
log
@import apache 1.3.27 and mod_ssl 2.8.11
@
text
@a1081 1
		int qlen;
d1083 1
a1083 1
		q = servername; qlen = sizeof(servername);
d1086 1
a1086 1
		    while (*p > 32 && qlen-- > 1) 
d1309 1
a1309 1
	if (tlimit && timedif(now, start) >= (tlimit * 1000)) {
d1354 1
a1354 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.67 $> apache-1.3");
d1361 1
a1361 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.67 $");
d1578 3
a1580 3
	    strncat(cookie, "Cookie: ", sizeof(cookie)-strlen(cookie)-1);
	    strncat(cookie, optarg, sizeof(cookie)-strlen(cookie)-1);
	    strncat(cookie, "\r\n", sizeof(cookie)-strlen(cookie)-1);
d1592 3
a1594 3
	    strncat(auth, "Authorization: Basic ", sizeof(auth)-strlen(auth)-1);
	    strncat(auth, tmp, sizeof(auth)-strlen(auth)-1);
	    strncat(auth, "\r\n", sizeof(auth)-strlen(auth)-1);
d1605 3
a1607 3
	    strncat(auth, "Proxy-Authorization: Basic ", sizeof(auth)-strlen(auth)-1);
	    strncat(auth, tmp, sizeof(auth)-strlen(auth)-1);
	    strncat(auth, "\r\n", sizeof(auth)-strlen(auth)-1);
d1625 2
a1626 2
	    strncat(hdrs, optarg, sizeof(hdrs)-strlen(hdrs)-1);
	    strncat(hdrs, "\r\n", sizeof(hdrs)-strlen(hdrs)-1);
@


1.1.1.4
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
d1101 2
a1102 8
            if (part && strlen(part) > strlen("HTTP/1.x_")) {
                strncpy(respcode, (part + strlen("HTTP/1.x_")), 3);
                respcode[3] = '\0';
            }
            else {
                strcpy(respcode, "500");
            }

d1355 1
a1355 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.69 $> apache-1.3");
d1362 1
a1362 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.69 $");
@


1.1.1.5
log
@import Apache 1.3.29 and mod_ssl 2.8.16
@
text
@d1361 1
a1361 1
	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.70 $> apache-1.3");
d1368 1
a1368 1
	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.70 $");
d1596 1
a1596 6
            if (ap_base64encode_len(strlen(optarg)) > sizeof(tmp)) {
                fprintf(stderr, "%s: Authentication credentials too long\n",
                        argv[0]);
                exit(1);
            }
            l = ap_base64encode(tmp, optarg, strlen(optarg));
a1608 4
            if (ap_base64encode_len(strlen(optarg)) > sizeof(tmp)) {
                fprintf(stderr, "%s: Proxy credentials too long\n", argv[0]);
                exit(1);
            }
@


