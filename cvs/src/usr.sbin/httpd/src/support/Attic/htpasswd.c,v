head	1.20;
access;
symbols
	OPENBSD_5_5:1.19.0.10
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.6
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.4
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.2
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.14
	OPENBSD_5_0:1.18.0.12
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.10
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.8
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.4
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.8
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.3
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.3
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.2
	apache_1_3_27:1.1.1.2
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2014.04.22.14.47.27;	author henning;	state dead;
branches;
next	1.19;

1.19
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	2008.08.11.17.15.56;	author tobias;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.23.12.12.01;	author mbalmer;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.26.17.13.55;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.25.14.01.37;	author robert;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.24.09.43.11;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.14.15.30.54;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.06.13.14.10;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.02.19.42.48;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.26.02.12.21;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.21.13.11.40;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.02.14.18.13;	author avsm;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.08.17.35.37;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.23.20.03.13;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.29.02.08.08;	author beck;	state Exp;
branches
	1.5.2.1
	1.5.4.1;
next	1.4;

1.4
date	2000.12.15.22.18.41;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.25.18.30.19;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.06.30.09;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.51;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.51;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.29.23;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.21.12.53.45;	author henning;	state Exp;
branches;
next	;

1.5.2.1
date	2003.01.22.23.48.57;	author miod;	state Exp;
branches;
next	;

1.5.4.1
date	2002.11.04.14.49.20;	author jason;	state Exp;
branches;
next	;


desc
@@


1.20
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@/*	$OpenBSD: htpasswd.c,v 1.19 2012/03/04 04:05:15 fgsch Exp $ */

/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

/******************************************************************************
 ******************************************************************************
 * NOTE! This program is not safe as a setuid executable!  Do not make it
 * setuid!
 ******************************************************************************
 *****************************************************************************/
/*
 * htpasswd.c: simple program for manipulating password file for
 * the Apache HTTP server
 * 
 * Originally by Rob McCool
 *
 * Exit values:
 *  0: Success
 *  1: Failure; file access/permission problem
 *  2: Failure; command line syntax problem (usage message issued)
 *  3: Failure; password verification failure
 *  4: Failure; operation interrupted (such as with CTRL/C)
 *  5: Failure; buffer would overflow (username, filename, or computed
 *     record too long)
 *  6: Failure; username contains illegal or reserved characters
 */

#include "ap_config.h"
#include <sys/types.h>
#include <signal.h>
#include <errno.h>
#include "ap.h"
#include "ap_md5.h"
#include "ap_sha1.h"

#define LF 10
#define CR 13

#define MAX_STRING_LEN 256
#define ALG_PLAIN 0
#define ALG_CRYPT 1
#define ALG_APMD5 2
#define ALG_APSHA 3 
#define ALG_APBLF 4

#define INTR_MSG "\nInterrupted.\n"

#define ERR_FILEPERM 1
#define ERR_SYNTAX 2
#define ERR_PWMISMATCH 3
#define ERR_INTERRUPTED 4
#define ERR_OVERFLOW 5
#define ERR_BADUSER 6

/*
 * This needs to be declared statically so the signal handler can
 * access it.
 */
static char tempfilename[MAX_STRING_LEN];
/*
 * If our platform knows about the tmpnam() external buffer size, create
 * a buffer to pass in.  This is needed in a threaded environment, or
 * one that thinks it is (like HP-UX).
 */
#ifdef L_tmpnam
static char tname_buf[L_tmpnam];
#else
static char *tname_buf = NULL;
#endif

/*
 * Get a line of input from the user, not including any terminating
 * newline.
 */
static int
get_line(char *s, int n, FILE *f)
{
	int i = 0;

	while (1) {
		s[i] = (char) fgetc(f);

		if (s[i] == CR)
			s[i] = fgetc(f);

		if ((s[i] == 0x4) || (s[i] == LF) || (i == (n - 1))) {
			s[i] = '\0';
			return (feof(f) ? 1 : 0);
		}
		++i;
	}
}

static void
putline(FILE *f, char *l)
{
	int x;

	for (x = 0; l[x]; x++)
		fputc(l[x], f);

	fputc('\n', f);
}

/*
 * Make a password record from the given information.  A zero return
 * indicates success; failure means that the output buffer contains an
 * error message instead.
 */
static int
mkrecord(char *user, char *record, size_t rlen, char *passwd, int alg)
{
	char *pw;
	char cpw[120];
	char pwin[MAX_STRING_LEN];
	char pwv[MAX_STRING_LEN];
	char salt[33];

	if (passwd != NULL)
		pw = passwd;
	else {
		if (ap_getpass("New password: ", pwin, sizeof(pwin)) != 0) {
			ap_snprintf(record, (rlen - 1), "password too long "
			    "(>%lu)", (unsigned long)(sizeof(pwin) - 1));
			return ERR_OVERFLOW;
		}
		ap_getpass("Re-type new password: ", pwv, sizeof(pwv));
		if (strcmp(pwin, pwv) != 0) {
			ap_cpystrn(record, "password verification error",
			    (rlen - 1));
			return ERR_PWMISMATCH;
		}
		pw = pwin;
		memset(pwv, '\0', sizeof(pwin));
	}
	switch (alg) {
	case ALG_APSHA:
		/* XXX cpw >= 28 + strlen(sha1) chars - fixed len SHA */
		ap_sha1_base64(pw, strlen(pw), cpw);
		break;
	case ALG_APMD5: 
		ap_to64(&salt[0], arc4random(), 8);
		salt[8] = '\0';

		ap_MD5Encode((const unsigned char *)pw,
		    (const unsigned char *)salt, cpw, sizeof(cpw));
		break;
	case ALG_PLAIN:
		/* XXX this len limitation is not in sync with any HTTPd len. */
		ap_cpystrn(cpw ,pw, sizeof(cpw));
		break;
	case ALG_CRYPT:
		ap_to64(&salt[0], arc4random(), 8);
		salt[8] = '\0';

		ap_cpystrn(cpw, (char *)crypt(pw, salt), sizeof(cpw) - 1);
		break;
	case ALG_APBLF:
	default:
		strlcpy(salt, bcrypt_gensalt(6), sizeof(salt));
		strlcpy(cpw, (char *)crypt(pw, salt), sizeof(cpw));
		break;
	}
	memset(pw, '\0', strlen(pw));

	/*
	 * Check to see if the buffer is large enough to hold the username,
	 * hash, and delimiters.
	 */
	if ((strlen(user) + 1 + strlen(cpw)) > (rlen - 1)) {
		ap_cpystrn(record, "resultant record too long", (rlen - 1));
		return ERR_OVERFLOW;
	}
	snprintf(record, rlen, "%s:%s", user, cpw);
	return 0;
}

static int
usage(void)
{
	fprintf(stderr, "Usage:\thtpasswd [-c] [-d | -l | -m | -p | -s ] "
	    "passwordfile username\n");
	fprintf(stderr, "\thtpasswd -b [-c] [-d | -l | -m | -p | -s] "
	    "passwordfile username password\n");
	fprintf(stderr, "\thtpasswd -n [-d | -l | -m | -p | -s] username\n");
	fprintf(stderr, "\thtpasswd -bn [-d | -l | -m | -p | -s] username "
	    "password\n");
	return ERR_SYNTAX;
}

static void
interrupted(void)
{
	write(STDERR_FILENO, INTR_MSG, sizeof(INTR_MSG) - 1);
	if (tempfilename[0] != '\0')
		unlink(tempfilename);

	_exit(ERR_INTERRUPTED);
}

/*
 * Check to see if the specified file can be opened for the given
 * access.
 */
static int
accessible(char *fname, char *mode)
{
	FILE *s;

	s = fopen(fname, mode);
	if (s == NULL)
		return 0;

	fclose(s);
	return 1;
}

/* Return true if a file is readable. */
static int
readable(char *fname)
{
	return accessible(fname, "r");
}

/* Return true if the specified file can be opened for write access. */
static int
writable(char *fname)
{
	return accessible(fname, "a");
}

/* Return true if the named file exists, regardless of permissions. */
static int
exists(char *fname)
{
	struct stat sbuf;
	int check;

	check = stat(fname, &sbuf);
	return ((check == -1) && (errno == ENOENT)) ? 0 : 1;
}

/*
 * Copy from the current position of one file to the current position
 * of another.
 */
static void
copy_file(FILE *target, FILE *source)
{
	static char line[MAX_STRING_LEN];

	while (fgets(line, sizeof(line), source) != NULL)
		fputs(line, target);
}

/*
 * Let's do it.  We end up doing a lot of file opening and closing,
 * but what do we care?  This application isn't run constantly.
 */
int
main(int argc, char *argv[])
{
	FILE *ftemp = NULL;
	FILE *fpw = NULL;
	char user[MAX_STRING_LEN];
	char password[MAX_STRING_LEN];
	char record[MAX_STRING_LEN];
	char line[MAX_STRING_LEN];
	char pwfilename[MAX_STRING_LEN];
	char *arg;
	int found = 0;
	int alg = ALG_APBLF;
	int newfile = 0;
	int nofile = 0;
	int noninteractive = 0;
	int i;
	int args_left = 2;
	int tfd;
	int ch;

	signal(SIGINT, (void (*)(int)) interrupted);

	/*
	 * Preliminary check to make sure they provided at least
	 * three arguments, we'll do better argument checking as 
	 * we parse the command line.
	 */
	if (argc < 3)
		return usage();

	/*
	* Go through the argument list and pick out any options.  They
	* have to precede any other arguments.
	*/
	while ((ch = getopt(argc, argv, "bcdlnmsp")) != -1) {
		switch (ch) {
		case 'b':
			noninteractive++;
			args_left++;
			break;
		case 'c':
			newfile++;
			break;
		case 'd':
			alg = ALG_CRYPT;
			break;
		case 'l':
			alg = ALG_APBLF;
			break;
		case 'n':
			nofile++;
			args_left--;
			break;
		case 'm':
			alg = ALG_APMD5;
			break;
		case 's':
			alg = ALG_APSHA;
			break;
		case 'p':
			alg = ALG_PLAIN;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	i = argc - args_left;

	/*
	 * Make sure we still have exactly the right number of arguments left
	 * (the filename, the username, and possibly the password if -b was
	 * specified).
	 */
	if (argc != args_left)
		return usage();

	if (newfile && nofile) {
		fprintf(stderr, "%s: -c and -n options conflict\n", argv[0]);
		return ERR_SYNTAX;
	}
	if (nofile)
		i--;
	else {
		if (strlen(argv[i]) > (sizeof(pwfilename) - 1)) {
			fprintf(stderr, "%s: filename too long\n", argv[0]);
			return ERR_OVERFLOW;
		}
		strlcpy(pwfilename, argv[i], sizeof(pwfilename));
		if (strlen(argv[i + 1]) > (sizeof(user) - 1)) {
			fprintf(stderr, "%s: username too long (>%lu)\n",
			    argv[0], (unsigned long)(sizeof(user) - 1));
			return ERR_OVERFLOW;
		}
	}
	strlcpy(user, argv[i + 1], sizeof(user));
	if ((arg = strchr(user, ':')) != NULL) {
		fprintf(stderr, "%s: username contains illegal character '%c'"
		    "\n", argv[0], *arg);
		return ERR_BADUSER;
	}
	if (noninteractive) {
		if (strlen(argv[i + 2]) > (sizeof(password) - 1)) {
			fprintf(stderr, "%s: password too long (>%lu)\n",
			    argv[0], (unsigned long)(sizeof(password) - 1));
			return ERR_OVERFLOW;
		}
		strlcpy(password, argv[i + 2], sizeof(password));
	}

	if (alg == ALG_PLAIN) {
		fprintf(stderr,"Warning: storing passwords as plain text might "
		    "just not work on this platform.\n");
	}
	if (!nofile) {
		/*
		 * Only do the file checks if we're supposed to frob it.
		 *
		 * Verify that the file exists if -c was omitted.  We give a
		 * special message if it doesn't.
		 */
		if ((!newfile) && (!exists(pwfilename))) {
			fprintf(stderr, "%s: cannot modify file %s; use '-c' "
			    "to create it\n", argv[0], pwfilename);
			perror("fopen");
			exit(ERR_FILEPERM);
		}
		/*
		 * Verify that we can read the existing file in the case of an
		 * update to it (rather than creation of a new one).
		 */
		if ((! newfile) && (! readable(pwfilename))) {
			fprintf(stderr, "%s: cannot open file %s for read "
			    "access\n", argv[0], pwfilename);
			perror("fopen");
			exit(ERR_FILEPERM);
		}
		/*
		 * Now check to see if we can preserve an existing file in case
		 * of password verification errors on a -c operation.
		 */
		if (newfile && exists(pwfilename) && (! readable(pwfilename))) {
			fprintf(stderr, "%s: cannot open file %s for read "
			    "access\n%s: existing auth data would be lost on "
			    "password mismatch", argv[0], pwfilename, argv[0]);
			perror("fopen");
			exit(ERR_FILEPERM);
		}
		/* Now verify that the file is writable! */
		if (! writable(pwfilename)) {
			fprintf(stderr, "%s: cannot open file %s for write "
			    "access\n",	argv[0], pwfilename);
			perror("fopen");
			exit(ERR_FILEPERM);
		}
	}

	/*
	 * All the file access checks (if any) have been made.  Time to go to
	 * work; try to create the record for the username in question.  If
	 * that fails, there's no need to waste any time on file manipulations.
	 * Any error message text is returned in the record buffer, since
	 * the mkrecord() routine doesn't have access to argv[].
	 */
	i = mkrecord(user, record, sizeof(record) - 1,
	    noninteractive ? password : NULL, alg);
	if (i != 0) {
		fprintf(stderr, "%s: %s\n", argv[0], record);
		exit(i);
	}
	if (nofile) {
		printf("%s\n", record);
		exit(0);
	}

	/*
	 * We can access the files the right way, and we have a record
	 * to add or update.  Let's do it..
	 */
	errno = 0;
	strlcpy(tempfilename, "/tmp/htpasswd-XXXXXXXXXX", sizeof(tempfilename));
	tfd = mkstemp(tempfilename);
	if (tfd == -1 || (ftemp = fdopen(tfd, "w+")) == NULL) {
		fprintf(stderr, "%s: unable to create temporary file '%s'\n",
		    argv[0], tempfilename);
		perror("open");
		exit(ERR_FILEPERM);
	}
	/*
	 * If we're not creating a new file, copy records from the existing
	 * one to the temporary file until we find the specified user.
	 */
	if (! newfile) {
		char scratch[MAX_STRING_LEN];

		fpw = fopen(pwfilename, "r");
		while (! (get_line(line, sizeof(line), fpw))) {
			char *colon;

			if ((line[0] == '#') || (line[0] == '\0')) {
				putline(ftemp, line);
				continue;
			}
			strlcpy(scratch, line, sizeof(scratch));
			/* See if this is our user. */
			colon = strchr(scratch, ':');
			if (colon != NULL)
				*colon = '\0';

			if (strcmp(user, scratch) != 0) {
				putline(ftemp, line);
				continue;
			}
			found++;
			break;
		}
	}
	if (found)
		fprintf(stderr, "Updating ");
	else
		fprintf(stderr, "Adding ");
	fprintf(stderr, "password for user %s\n", user);
	/*
	 * Now add the user record we created.
	 */
	putline(ftemp, record);
	/*
	 * If we're updating an existing file, there may be additional
	 * records beyond the one we're updating, so copy them.
	 */
	if (! newfile) {
		copy_file(ftemp, fpw);
		fclose(fpw);
	}
	/*
	 * The temporary file now contains the information that should be
	 * in the actual password file.  Close the open files, re-open them
	 * in the appropriate mode, and copy them file to the real one.
	 */
	fclose(ftemp);
	fpw = fopen(pwfilename, "w+");
	ftemp = fopen(tempfilename, "r");
	copy_file(fpw, ftemp);
	fclose(fpw);
	fclose(ftemp);
	unlink(tempfilename);
	return 0;
}
@


1.19
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.18 2008/08/11 17:15:56 tobias Exp $ */
@


1.18
log
@Use only safe functions in signal handlers.

ok millert, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.17 2008/05/23 12:12:01 mbalmer Exp $ */
d133 1
a133 1
getline(char *s, int n, FILE *f)
d516 1
a516 1
		while (! (getline(line, sizeof(line), fpw))) {
@


1.17
log
@KNF and readability changes.  de-register, remove #ifndef SIN6_LEN defines.
Add OpenBSD cvs markers.

No binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d103 1
d251 1
a251 1
	fprintf(stderr, "Interrupted.\n");
d255 1
a255 1
	exit(ERR_INTERRUPTED);
@


1.16
log
@remove the unneccessary options descriptions from usage();
noticed by Igor Sobrado
ok henning
@
text
@d1 2
d131 2
a132 1
static int getline(char *s, int n, FILE *f)
d134 1
a134 4
    register int i = 0;

    while (1) {
	s[i] = (char) fgetc(f);
d136 2
a137 3
	if (s[i] == CR) {
	    s[i] = fgetc(f);
	}
d139 8
a146 3
	if ((s[i] == 0x4) || (s[i] == LF) || (i == (n - 1))) {
	    s[i] = '\0';
	    return (feof(f) ? 1 : 0);
a147 2
	++i;
    }
d150 2
a151 1
static void putline(FILE *f, char *l)
d153 1
a153 1
    int x;
d155 4
a158 4
    for (x = 0; l[x]; x++) {
	fputc(l[x], f);
    }
    fputc('\n', f);
d166 2
a167 2
static int mkrecord(char *user, char *record, size_t rlen, char *passwd,
		    int alg)
d169 63
a231 67
    char *pw;
    char cpw[120];
    char pwin[MAX_STRING_LEN];
    char pwv[MAX_STRING_LEN];
    char salt[33];

    if (passwd != NULL) {
	pw = passwd;
    }
    else {
	if (ap_getpass("New password: ", pwin, sizeof(pwin)) != 0) {
	    ap_snprintf(record, (rlen - 1), "password too long (>%lu)",
			(unsigned long) (sizeof(pwin) - 1));
	    return ERR_OVERFLOW;
	}
	ap_getpass("Re-type new password: ", pwv, sizeof(pwv));
	if (strcmp(pwin, pwv) != 0) {
	    ap_cpystrn(record, "password verification error", (rlen - 1));
	    return ERR_PWMISMATCH;
	}
	pw = pwin;
        memset(pwv, '\0', sizeof(pwin));
    }
    switch (alg) {

    case ALG_APSHA:
	/* XXX cpw >= 28 + strlen(sha1) chars - fixed len SHA */
 	ap_sha1_base64(pw,strlen(pw),cpw);
	break;

    case ALG_APMD5: 
        ap_to64(&salt[0], arc4random(), 8);
        salt[8] = '\0';

	ap_MD5Encode((const unsigned char *)pw, (const unsigned char *)salt,
		     cpw, sizeof(cpw));
	break;

    case ALG_PLAIN:
	/* XXX this len limitation is not in sync with any HTTPd len. */
	ap_cpystrn(cpw,pw,sizeof(cpw));
	break;

    case ALG_CRYPT:
        ap_to64(&salt[0], arc4random(), 8);
        salt[8] = '\0';

	ap_cpystrn(cpw, (char *)crypt(pw, salt), sizeof(cpw) - 1);
	break;
    case ALG_APBLF:
    default:
	strlcpy(salt, bcrypt_gensalt(6), sizeof(salt));
	strlcpy(cpw, (char *)crypt(pw, salt), sizeof(cpw));
	break;
    }
    memset(pw, '\0', strlen(pw));

    /*
     * Check to see if the buffer is large enough to hold the username,
     * hash, and delimiters.
     */
    if ((strlen(user) + 1 + strlen(cpw)) > (rlen - 1)) {
	ap_cpystrn(record, "resultant record too long", (rlen - 1));
	return ERR_OVERFLOW;
    }
    snprintf(record, rlen, "%s:%s", user, cpw);
    return 0;
d234 2
a235 1
static int usage(void)
d237 8
a244 5
    fprintf(stderr, "Usage:\thtpasswd [-c] [-d | -l | -m | -p | -s ] passwordfile username\n");
    fprintf(stderr, "\thtpasswd -b [-c] [-d | -l | -m | -p | -s] passwordfile username password\n");
    fprintf(stderr, "\thtpasswd -n [-d | -l | -m | -p | -s] username\n");
    fprintf(stderr, "\thtpasswd -bn [-d | -l | -m | -p | -s] username password\n");
    return ERR_SYNTAX;
d247 2
a248 1
static void interrupted(void)
d250 5
a254 5
    fprintf(stderr, "Interrupted.\n");
    if (tempfilename[0] != '\0') {
	unlink(tempfilename);
    }
    exit(ERR_INTERRUPTED);
d261 2
a262 1
static int accessible(char *fname, char *mode)
d264 5
a268 1
    FILE *s;
d270 2
a271 6
    s = fopen(fname, mode);
    if (s == NULL) {
	return 0;
    }
    fclose(s);
    return 1;
d274 3
a276 4
/*
 * Return true if a file is readable.
 */
static int readable(char *fname)
d278 1
a278 1
    return accessible(fname, "r");
d281 3
a283 4
/*
 * Return true if the specified file can be opened for write access.
 */
static int writable(char *fname)
d285 1
a285 1
    return accessible(fname, "a");
d288 3
a290 4
/*
 * Return true if the named file exists, regardless of permissions.
 */
static int exists(char *fname)
d292 2
a293 2
    struct stat sbuf;
    int check;
d295 2
a296 2
    check = stat(fname, &sbuf);
    return ((check == -1) && (errno == ENOENT)) ? 0 : 1;
d303 2
a304 1
static void copy_file(FILE *target, FILE *source)
d306 1
a306 1
    static char line[MAX_STRING_LEN];
d308 2
a309 3
    while (fgets(line, sizeof(line), source) != NULL) {
	fputs(line, target);
    }
d316 2
a317 1
int main(int argc, char *argv[])
d319 157
a475 117
    FILE *ftemp = NULL;
    FILE *fpw = NULL;
    char user[MAX_STRING_LEN];
    char password[MAX_STRING_LEN];
    char record[MAX_STRING_LEN];
    char line[MAX_STRING_LEN];
    char pwfilename[MAX_STRING_LEN];
    char *arg;
    int found = 0;
    int alg = ALG_APBLF;
    int newfile = 0;
    int nofile = 0;
    int noninteractive = 0;
    int i;
    int args_left = 2;
    int tfd;
    int ch;
    
    signal(SIGINT, (void (*)(int)) interrupted);

    /*
     * Preliminary check to make sure they provided at least
     * three arguments, we'll do better argument checking as 
     * we parse the command line.
     */
    if (argc < 3) {
	return usage();
    }

    /*
     * Go through the argument list and pick out any options.  They
     * have to precede any other arguments.
     */
    while ((ch = getopt(argc, argv, "bcdlnmsp")) != -1) {
	    switch (ch) {
	    case 'b':
		    noninteractive++;
		    args_left++;
		    break;
	    case 'c':
		    newfile++;
		    break;
	    case 'd':
		    alg = ALG_CRYPT;
		    break;
	    case 'l':
		    alg = ALG_APBLF;
		    break;
	    case 'n':
		    nofile++;
		    args_left--;
		    break;
	    case 'm':
		    alg = ALG_APMD5;
		    break;
	    case 's':
		    alg = ALG_APSHA;
		    break;
	    case 'p':
		    alg = ALG_PLAIN;
		    break;
	    default:
		    usage();
	    }
    }
    argc -= optind;
    argv += optind;

    i = argc - args_left;
    
    /*
     * Make sure we still have exactly the right number of arguments left
     * (the filename, the username, and possibly the password if -b was
     * specified).
     */
    if (argc != args_left) {
	return usage();
    }
    if (newfile && nofile) {
	fprintf(stderr, "%s: -c and -n options conflict\n", argv[0]);
	return ERR_SYNTAX;
    }
    if (nofile) {
	i--;
    }
    else {
	if (strlen(argv[i]) > (sizeof(pwfilename) - 1)) {
	    fprintf(stderr, "%s: filename too long\n", argv[0]);
	    return ERR_OVERFLOW;
	}
	strlcpy(pwfilename, argv[i], sizeof(pwfilename));
	if (strlen(argv[i + 1]) > (sizeof(user) - 1)) {
	    fprintf(stderr, "%s: username too long (>%lu)\n", argv[0],
		    (unsigned long)(sizeof(user) - 1));
	    return ERR_OVERFLOW;
	}
    }
    strlcpy(user, argv[i + 1], sizeof(user));
    if ((arg = strchr(user, ':')) != NULL) {
	fprintf(stderr, "%s: username contains illegal character '%c'\n",
		argv[0], *arg);
	return ERR_BADUSER;
    }
    if (noninteractive) {
	if (strlen(argv[i + 2]) > (sizeof(password) - 1)) {
	    fprintf(stderr, "%s: password too long (>%lu)\n", argv[0],
		    (unsigned long)(sizeof(password) - 1));
	    return ERR_OVERFLOW;
	}
	strlcpy(password, argv[i + 2], sizeof(password));
    }

    if (alg == ALG_PLAIN) {
	fprintf(stderr,"Warning: storing passwords as plain text might "
		"just not work on this platform.\n");
    }
    if (! nofile) {
d477 5
a481 4
	 * Only do the file checks if we're supposed to frob it.
	 *
	 * Verify that the file exists if -c was omitted.  We give a special
	 * message if it doesn't.
d483 9
a491 6
	if ((! newfile) && (! exists(pwfilename))) {
	    fprintf(stderr,
		    "%s: cannot modify file %s; use '-c' to create it\n",
		    argv[0], pwfilename);
	    perror("fopen");
	    exit(ERR_FILEPERM);
d493 1
d495 2
a496 2
	 * Verify that we can read the existing file in the case of an update
	 * to it (rather than creation of a new one).
d498 8
a505 5
	if ((! newfile) && (! readable(pwfilename))) {
	    fprintf(stderr, "%s: cannot open file %s for read access\n",
		    argv[0], pwfilename);
	    perror("fopen");
	    exit(ERR_FILEPERM);
d508 2
a509 2
	 * Now check to see if we can preserve an existing file in case
	 * of password verification errors on a -c operation.
d511 41
a551 7
	if (newfile && exists(pwfilename) && (! readable(pwfilename))) {
	    fprintf(stderr, "%s: cannot open file %s for read access\n"
		    "%s: existing auth data would be lost on "
		    "password mismatch",
		    argv[0], pwfilename, argv[0]);
	    perror("fopen");
	    exit(ERR_FILEPERM);
d554 3
a556 1
	 * Now verify that the file is writable!
d558 4
a561 88
	if (! writable(pwfilename)) {
	    fprintf(stderr, "%s: cannot open file %s for write access\n",
		    argv[0], pwfilename);
	    perror("fopen");
	    exit(ERR_FILEPERM);
	}
    }

    /*
     * All the file access checks (if any) have been made.  Time to go to work;
     * try to create the record for the username in question.  If that
     * fails, there's no need to waste any time on file manipulations.
     * Any error message text is returned in the record buffer, since
     * the mkrecord() routine doesn't have access to argv[].
     */
    i = mkrecord(user, record, sizeof(record) - 1,
		 noninteractive ? password : NULL,
		 alg);
    if (i != 0) {
	fprintf(stderr, "%s: %s\n", argv[0], record);
	exit(i);
    }
    if (nofile) {
	printf("%s\n", record);
	exit(0);
    }

    /*
     * We can access the files the right way, and we have a record
     * to add or update.  Let's do it..
     */
    errno = 0;
    strlcpy(tempfilename, "/tmp/htpasswd-XXXXXXXXXX", sizeof(tempfilename));
    tfd = mkstemp(tempfilename);
    if (tfd == -1 || (ftemp = fdopen(tfd, "w+")) == NULL) {
	fprintf(stderr, "%s: unable to create temporary file '%s'\n", argv[0],
		tempfilename);
	perror("open");
	exit(ERR_FILEPERM);
    }
    /*
     * If we're not creating a new file, copy records from the existing
     * one to the temporary file until we find the specified user.
     */
    if (! newfile) {
	char scratch[MAX_STRING_LEN];

	fpw = fopen(pwfilename, "r");
	while (! (getline(line, sizeof(line), fpw))) {
	    char *colon;

	    if ((line[0] == '#') || (line[0] == '\0')) {
		putline(ftemp, line);
		continue;
	    }
	    strlcpy(scratch, line, sizeof(scratch));
	    /*
	     * See if this is our user.
	     */
	    colon = strchr(scratch, ':');
	    if (colon != NULL) {
		*colon = '\0';
	    }
	    if (strcmp(user, scratch) != 0) {
		putline(ftemp, line);
		continue;
	    }
	    found++;
	    break;
	}
    }
    if (found) {
	fprintf(stderr, "Updating ");
    }
    else {
	fprintf(stderr, "Adding ");
    }
    fprintf(stderr, "password for user %s\n", user);
    /*
     * Now add the user record we created.
     */
    putline(ftemp, record);
    /*
     * If we're updating an existing file, there may be additional
     * records beyond the one we're updating, so copy them.
     */
    if (! newfile) {
	copy_file(ftemp, fpw);
d563 3
a565 14
    }
    /*
     * The temporary file now contains the information that should be
     * in the actual password file.  Close the open files, re-open them
     * in the appropriate mode, and copy them file to the real one.
     */
    fclose(ftemp);
    fpw = fopen(pwfilename, "w+");
    ftemp = fopen(tempfilename, "r");
    copy_file(fpw, ftemp);
    fclose(fpw);
    fclose(ftemp);
    unlink(tempfilename);
    return 0;
@


1.15
log
@use getopt() for argument list parsing
ok otto@@ henning@@
@
text
@a240 8
    fprintf(stderr, " -b  Use the password from the command line rather than prompting for it.\n");
    fprintf(stderr, " -c  Create a new file.\n");
    fprintf(stderr, " -l  Force Blowfish-based CRYPT encryption of the password(default).\n");
    fprintf(stderr, " -d  Force DES-based CRYPT encryption of the password.\n");
    fprintf(stderr, " -m  Force MD5 encryption of the password.\n");
    fprintf(stderr, " -n  Don't update file; display results on stdout.\n");
    fprintf(stderr, " -p  Do not encrypt the password (plaintext).\n");
    fprintf(stderr, " -s  Force SHA encryption of the password.\n");
@


1.14
log
@support blowfish encryption in the password files and use it by default
From: Sergey Smitienko <hunter@@comsys.com.ua>, markus ok
@
text
@d340 2
a341 1

d357 30
a386 34
    for (i = 1; i < argc; i++) {
	arg = argv[i];
	if (*arg != '-') {
	    break;
	}
	while (*++arg != '\0') {
	    if (*arg == 'c') {
		newfile++;
	    }
	    else if (*arg == 'n') {
		nofile++;
		args_left--;
	    }
	    else if (*arg == 'm') {
		alg = ALG_APMD5;
	    }
	    else if (*arg == 's') {
		alg = ALG_APSHA;
	    }
	    else if (*arg == 'p') {
		alg = ALG_PLAIN;
	    }
	    else if (*arg == 'd') {
		alg = ALG_CRYPT;
	    }
	    else if (*arg == 'l') {
		alg = ALG_APBLF;
	    }
	    else if (*arg == 'b') {
		noninteractive++;
		args_left++;
	    }
	    else {
		return usage();
a387 1
	}
d389 2
d392 2
d399 1
a399 1
    if ((argc - i) != args_left) {
@


1.13
log
@sync usage() w/ SYNOPSIS and remove some verbosity;
ok henning@@
@
text
@d99 2
d170 1
a170 1
    char salt[9];
a209 1
    default:
d215 5
d237 4
a240 4
    fprintf(stderr, "Usage:\thtpasswd [-c] [-d | -m | -p | -s] passwordfile username\n");
    fprintf(stderr, "\thtpasswd -b [-c] [-d | -m | -p | -s] passwordfile username password\n");
    fprintf(stderr, "\thtpasswd -n [-d | -m | -p | -s] username\n");
    fprintf(stderr, "\thtpasswd -bn [-d | -m | -p | -s] username password\n");
d243 2
a244 1
    fprintf(stderr, " -d  Force CRYPT encryption of the password (default).\n");
d333 1
a333 1
    int alg = ALG_CRYPT;
d380 3
@


1.12
log
@kill more dead code, mostly inside #ifdef SOMENONSENSEONSTUPIDOSES
joint work by Michael Knudsen <e@@molioner.dk> and Daniel Ouellet
<daniel@@presscom.net> with my input
no change in binaries
@
text
@d231 5
a235 5
    fprintf(stderr, "Usage:\n");
    fprintf(stderr, "\thtpasswd [-cmdps] passwordfile username\n");
    fprintf(stderr, "\thtpasswd -b[cmdps] passwordfile username password\n\n");
    fprintf(stderr, "\thtpasswd -n[mdps] username\n");
    fprintf(stderr, "\thtpasswd -nb[mdps] username password\n");
d237 2
a239 5
    fprintf(stderr, " -m  Force MD5 encryption of the password"
	".\n");
    fprintf(stderr, " -d  Force CRYPT encryption of the password"
	    " (default)"
	    ".\n");
a241 6
    fprintf(stderr, " -b  Use the password from the command line rather "
	    "than prompting for it.\n");
    fprintf(stderr,
	    "On Windows, TPF and NetWare systems the '-m' flag is used by default.\n");
    fprintf(stderr,
	    "On all other systems, the '-p' flag will probably not work.\n");
@


1.11
log
@big time httpd cleanup
this diff removes a lot of #ifdef'd stuff that is irrelevant for us.
done by Daniel Ouellet after my advice.
tested by many, ok miod@@
@
text
@a90 5
#ifdef HAVE_CRYPT_H
#include <crypt.h>
#endif


@


1.10
log
@use a much more random salt; prompted by ast@@domdv.de
@
text
@a83 1
#ifndef NETWARE
a84 1
#endif
a94 5
#ifdef WIN32
#include <conio.h>
#include "../os/win32/getopt.h"
#define unlink _unlink
#endif
a95 1
#ifndef CHARSET_EBCDIC
a97 4
#else /*CHARSET_EBCDIC*/
#define LF '\n'
#define CR '\r'
#endif /*CHARSET_EBCDIC*/
a178 4
#ifdef TPF
        fprintf(stderr, "Invalid entry. The -b option is required on TPF.\n");
        return usage();
#else
a190 1
#endif /* TPF */
a243 3
#if defined(WIN32) || defined(TPF) || defined(NETWARE)
	" (default)"
#endif
a245 1
#if (!(defined(WIN32) || defined(TPF) || defined(NETWARE)))
a246 1
#endif
a304 3
#ifdef WIN32
    struct _stat sbuf;
#else
a305 1
#endif
a307 3
#ifdef WIN32
    check = _stat(fname, &sbuf);
#else
a308 1
#endif
a405 5
#ifdef NETWARE
    UnAugmentAsterisk(TRUE);
    SetCurrentNameSpace(NW_NS_LONG);
    SetTargetNameSpace(NW_NS_LONG);
#endif
a439 13
#ifdef WIN32
    if (alg == ALG_CRYPT) {
	alg = ALG_APMD5;
	fprintf(stderr, "Automatically using MD5 format on Windows.\n");
    }
#elif defined(TPF) || defined(NETWARE)
    if (alg == ALG_CRYPT) {
        alg = ALG_APMD5;
        fprintf(stderr, "Automatically using MD5 format.\n");
     }
#endif

#if (!(defined(WIN32) || defined(TPF) || defined(NETWARE)))
a443 1
#endif
@


1.9
log
@merge
@
text
@d217 1
a217 2
        (void) srand((int) time((time_t *) NULL));
        ap_to64(&salt[0], rand(), 8);
d231 1
a231 2
        (void) srand((int) time((time_t *) NULL));
        ap_to64(&salt[0], rand(), 8);
@


1.8
log
@bump mktemp/mkstemp randomness from 6 -> 10 X's
henning@@ ok
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
@


1.7
log
@more strcpy & friends bye-bye; ok pval
@
text
@d566 1
a566 1
    strlcpy(tempfilename, "/tmp/htpasswd-XXXXXX", sizeof(tempfilename));
@


1.6
log
@Replace tmpnam() with mkstemp() to avoid possible /tmp race.
Problem found by David Wagner (among others).
@
text
@d249 1
a249 3
    strcpy(record, user);
    strcat(record, ":");
    strcat(record, cpw);
d455 1
a455 1
	strcpy(pwfilename, argv[i]);
d462 1
a462 1
    strcpy(user, argv[i + 1]);
d474 1
a474 1
	strcpy(password, argv[i + 2]);
d566 1
a566 1
    strcpy(tempfilename, "/tmp/htpasswd-XXXXXX");
d589 1
a589 1
	    strcpy(scratch, line);
@


1.5
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d128 1
a128 1
static char *tempfilename;
d288 1
a288 1
    if (tempfilename != NULL) {
d380 1
a381 1
    tempfilename = NULL;
d568 3
a570 12
    tempfilename = tmpnam(tname_buf);
    if ((tempfilename == NULL) || (*tempfilename == '\0')) {
	fprintf(stderr, "%s: unable to generate temporary filename\n",
		argv[0]);
	if (errno == 0) {
	    errno = ENOENT;
	}
	perror("tmpnam");
	exit(ERR_FILEPERM);
    }
    ftemp = fopen(tempfilename, "w+");
    if (ftemp == NULL) {
d573 1
a573 1
	perror("fopen");
@


1.5.2.1
log
@Pull in patch from current:
Fix (millert):
Replace tmpnam() with mkstemp() to avoid possible /tmp race.
Problem found by David Wagner (among others).
@
text
@d128 1
a128 1
static char tempfilename[MAX_STRING_LEN];
d288 1
a288 1
    if (tempfilename[0] != '\0') {
a379 1
    int tfd;
d381 1
d568 12
a579 3
    strcpy(tempfilename, "/tmp/htpasswd-XXXXXX");
    tfd = mkstemp(tempfilename);
    if (tfd == -1 || (ftemp = fdopen(tfd, "w+")) == NULL) {
d582 1
a582 1
	perror("open");
@


1.5.4.1
log
@Pull in patch from current:
Fix (millert):
Replace tmpnam() with mkstemp() to avoid possible /tmp race.
Problem found by David Wagner (among others).
@
text
@d128 1
a128 1
static char tempfilename[MAX_STRING_LEN];
d288 1
a288 1
    if (tempfilename[0] != '\0') {
a379 1
    int tfd;
d381 1
d568 12
a579 3
    strcpy(tempfilename, "/tmp/htpasswd-XXXXXX");
    tfd = mkstemp(tempfilename);
    if (tfd == -1 || (ftemp = fdopen(tfd, "w+")) == NULL) {
d582 1
a582 1
	perror("open");
@


1.4
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d4 1
a4 1
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
d196 2
a197 2
	    ap_snprintf(record, (rlen - 1), "password too long (>%d)",
			sizeof(pwin) - 1);
d440 5
d459 2
a460 2
	    fprintf(stderr, "%s: username too long (>%d)\n", argv[0],
		    sizeof(user) - 1);
d472 2
a473 2
	    fprintf(stderr, "%s: password too long (>%d)\n", argv[0],
		    sizeof(password) - 1);
@


1.3
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d2 4
a5 1
 * Copyright (c) 1995-1999 The Apache Group.  All rights reserved.
d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d19 20
a38 23
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * 4. The names "Apache Server" and "Apache Group" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the Apache Group
 *    for use in the Apache HTTP server project (http://www.apache.org/)."
 *
 * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
d40 8
a47 7
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
d51 7
a57 6
 * individuals on behalf of the Apache Group and was originally based
 * on public domain software written at the National Center for
 * Supercomputing Applications, University of Illinois, Urbana-Champaign.
 * For more information on the Apache Group and the Apache HTTP server
 * project, please see <http://www.apache.org/>.
 *
d93 4
d129 10
d260 2
d263 1
d265 1
a265 1
#if defined(WIN32) || defined(TPF)
d270 1
a270 1
#if (!(defined(WIN32) || defined(TPF)))
d279 1
a279 1
	    "On Windows and TPF systems the '-m' flag is used by default.\n");
d376 1
d406 4
d440 6
a445 3
    if (strlen(argv[i]) > (sizeof(pwfilename) - 1)) {
	fprintf(stderr, "%s: filename too long\n", argv[0]);
	return ERR_OVERFLOW;
d447 11
a457 5
    strcpy(pwfilename, argv[i]);
    if (strlen(argv[i + 1]) > (sizeof(user) - 1)) {
	fprintf(stderr, "%s: username too long (>%d)\n", argv[0],
		sizeof(user) - 1);
	return ERR_OVERFLOW;
d479 1
a479 1
#elif defined(TPF)
d486 1
a486 1
#if (!(defined(WIN32) || defined(TPF)))
d492 45
a536 39
    /*
     * Verify that the file exists if -c was omitted.  We give a special
     * message if it doesn't.
     */
    if ((! newfile) && (! exists(pwfilename))) {
	fprintf(stderr, "%s: cannot modify file %s; use '-c' to create it\n",
		argv[0], pwfilename);
	perror("fopen");
	exit(ERR_FILEPERM);
    }
    /*
     * Verify that we can read the existing file in the case of an update
     * to it (rather than creation of a new one).
     */
    if ((! newfile) && (! readable(pwfilename))) {
	fprintf(stderr, "%s: cannot open file %s for read access\n",
		argv[0], pwfilename);
	perror("fopen");
	exit(ERR_FILEPERM);
    }
    /*
     * Now check to see if we can preserve an existing file in case
     * of password verification errors on a -c operation.
     */
    if (newfile && exists(pwfilename) && (! readable(pwfilename))) {
	fprintf(stderr, "%s: cannot open file %s for read access\n"
		"%s: existing auth data would be lost on password mismatch",
		argv[0], pwfilename, argv[0]);
	perror("fopen");
	exit(ERR_FILEPERM);
    }
    /*
     * Now verify that the file is writable!
     */
    if (! writable(pwfilename)) {
	fprintf(stderr, "%s: cannot open file %s for write access\n",
		argv[0], pwfilename);
	perror("fopen");
	exit(ERR_FILEPERM);
d540 1
a540 1
     * All the file access checks have been made.  Time to go to work;
d553 4
d562 11
a572 1
    tempfilename = tmpnam(NULL);
d575 2
a576 1
	fprintf(stderr, "%s: unable to create temporary file\n", argv[0]);
@


1.2
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d82 1
d84 1
d175 4
d191 1
d446 5
@


1.1
log
@Initial revision
@
text
@d1 57
d65 2
a66 1
 * htpasswd.c: simple program for manipulating password file for NCSA httpd
d68 11
a78 1
 * Rob McCool
d84 10
d104 11
d116 5
a120 25
char *tn;

static char *strd(char *s)
{
    char *d;

    d = (char *) malloc(strlen(s) + 1);
    strcpy(d, s);
    return (d);
}

static void getword(char *word, char *line, char stop)
{
    int x = 0, y;

    for (x = 0; ((line[x]) && (line[x] != stop)); x++)
	word[x] = line[x];

    word[x] = '\0';
    if (line[x])
	++x;
    y = 0;

    while ((line[y++] = line[x++]));
}
d122 4
d133 1
a133 1
	if (s[i] == CR)
d135 1
d149 1
a149 1
    for (x = 0; l[x]; x++)
d151 1
d155 13
d169 89
a257 3
/* From local_passwd.c (C) Regents of Univ. of California blah blah */
static unsigned char itoa64[] =	/* 0 ... 63 => ascii - 64 */
"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
d259 1
a259 1
static void to64(register char *s, register long v, register int n)
d261 3
a263 3
    while (--n >= 0) {
	*s++ = itoa64[v & 0x3f];
	v >>= 6;
d265 1
d268 3
a270 3
#ifdef MPE
/* MPE lacks getpass() and a way to suppress stdin echo.  So for now, just
 * issue the prompt and read the results with echo.  (Ugh).
d272 1
a272 2

static char *getpass(const char *prompt)
d274 1
d276 3
a278 7
    static char password[81];

    fputs(prompt, stderr);
    gets((char *) &password);

    if (strlen((char *) &password) > 8) {
	password[8] = '\0';
d280 3
d284 6
a289 1
    return (char *) &password;
d292 7
a298 1
#endif
d300 4
a303 1
static void add_password(char *user, FILE *f)
d305 6
a310 1
    char *pw, *cpw, salt[3];
d312 6
a317 13
    pw = strd((char *) getpass("New password:"));
    if (strcmp(pw, (char *) getpass("Re-type new password:"))) {
	fprintf(stderr, "They don't match, sorry.\n");
	if (tn)
	    unlink(tn);
	exit(1);
    }
    (void) srand((int) time((time_t *) NULL));
    to64(&salt[0], rand(), 2);
    salt[2] = '\0';
    cpw = (char *)crypt(pw, salt);
    free(pw);
    fprintf(f, "%s:%s\n", user, cpw);
d320 5
a324 1
static void usage(void)
d326 1
a326 4
    fprintf(stderr, "Usage: htpasswd [-c] passwordfile username\n");
    fprintf(stderr, "The -c flag creates a new file.\n");
    exit(1);
}
d328 3
a330 6
static void interrupted(void)
{
    fprintf(stderr, "Interrupted.\n");
    if (tn)
	unlink(tn);
    exit(1);
d333 4
d339 2
a340 1
    FILE *tfp, *f;
d342 2
d345 232
a576 74
    char l[MAX_STRING_LEN];
    char w[MAX_STRING_LEN];
    char command[MAX_STRING_LEN];
    int found;

    tn = NULL;
    signal(SIGINT, (void (*)()) interrupted);
    if (argc == 4) {
	if (strcmp(argv[1], "-c"))
	    usage();
      if (!(tfp = fopen(argv[2], "w+"))) {
	    fprintf(stderr, "Could not open passwd file %s for writing.\n",
		    argv[2]);
	    perror("fopen");
	    exit(1);
	}
	printf("Adding password for %s.\n", argv[3]);
	add_password(argv[3], tfp);
	fclose(tfp);
	exit(0);
    }
    else if (argc != 3)
	usage();

    tn = tmpnam(NULL);
    if (!(tfp = fopen(tn, "w+"))) {
	fprintf(stderr, "Could not open temp file.\n");
	exit(1);
    }

    if (!(f = fopen(argv[1], "r+"))) {
	fprintf(stderr,
		"Could not open passwd file %s for reading.\n", argv[1]);
	fprintf(stderr, "Use -c option to create new one.\n");
	exit(1);
    }
    strcpy(user, argv[2]);

    found = 0;
    while (!(getline(line, MAX_STRING_LEN, f))) {
	if (found || (line[0] == '#') || (!line[0])) {
	    putline(tfp, line);
	    continue;
	}
	strcpy(l, line);
	getword(w, l, ':');
	if (strcmp(user, w)) {
	    putline(tfp, line);
	    continue;
	}
	else {
	    printf("Changing password for user %s\n", user);
	    add_password(user, tfp);
	    found = 1;
	}
    }
    if (!found) {
	printf("Adding user %s\n", user);
	add_password(user, tfp);
    }
/*
* make a copy from the tmp file to the actual file
*/  
        rewind(f);
        rewind(tfp);
        while ( fgets(command,MAX_STRING_LEN,tfp) != NULL)
        {
                fputs(command,f);
        } 

    fclose(f);
    fclose(tfp);
    unlink(tn);
    exit(0);
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@a0 59
/* ====================================================================
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Apache" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 *
 * Portions of this software are based upon public domain software
 * originally written at the National Center for Supercomputing Applications,
 * University of Illinois, Urbana-Champaign.
 */

d8 1
a8 2
 * htpasswd.c: simple program for manipulating password file for
 * the Apache HTTP server
d10 1
a10 11
 * Originally by Rob McCool
 *
 * Exit values:
 *  0: Success
 *  1: Failure; file access/permission problem
 *  2: Failure; command line syntax problem (usage message issued)
 *  3: Failure; password verification failure
 *  4: Failure; operation interrupted (such as with CTRL/C)
 *  5: Failure; buffer would overflow (username, filename, or computed
 *     record too long)
 *  6: Failure; username contains illegal or reserved characters
a13 1
#ifndef NETWARE
a14 1
#endif
a15 14
#include <errno.h>
#include "ap.h"
#include "ap_md5.h"
#include "ap_sha1.h"

#ifdef HAVE_CRYPT_H
#include <crypt.h>
#endif

#ifdef WIN32
#include <conio.h>
#include "../os/win32/getopt.h"
#define unlink _unlink
#endif
a25 11
#define ALG_PLAIN 0
#define ALG_CRYPT 1
#define ALG_APMD5 2
#define ALG_APSHA 3 

#define ERR_FILEPERM 1
#define ERR_SYNTAX 2
#define ERR_PWMISMATCH 3
#define ERR_INTERRUPTED 4
#define ERR_OVERFLOW 5
#define ERR_BADUSER 6
d27 25
a51 15
/*
 * This needs to be declared statically so the signal handler can
 * access it.
 */
static char *tempfilename;
/*
 * If our platform knows about the tmpnam() external buffer size, create
 * a buffer to pass in.  This is needed in a threaded environment, or
 * one that thinks it is (like HP-UX).
 */
#ifdef L_tmpnam
static char tname_buf[L_tmpnam];
#else
static char *tname_buf = NULL;
#endif
a52 4
/*
 * Get a line of input from the user, not including any terminating
 * newline.
 */
d60 1
a60 1
	if (s[i] == CR) {
a61 1
	}
d75 1
a75 1
    for (x = 0; l[x]; x++) {
d77 13
a90 1
    fputc('\n', f);
d93 3
a95 4
/*
 * Make a password record from the given information.  A zero return
 * indicates success; failure means that the output buffer contains an
 * error message instead.
d97 2
a98 2
static int mkrecord(char *user, char *record, size_t rlen, char *passwd,
		    int alg)
a99 5
    char *pw;
    char cpw[120];
    char pwin[MAX_STRING_LEN];
    char pwv[MAX_STRING_LEN];
    char salt[9];
d101 1
a101 23
    if (passwd != NULL) {
	pw = passwd;
    }
    else {
#ifdef TPF
        fprintf(stderr, "Invalid entry. The -b option is required on TPF.\n");
        return usage();
#else
	if (ap_getpass("New password: ", pwin, sizeof(pwin)) != 0) {
	    ap_snprintf(record, (rlen - 1), "password too long (>%lu)",
			(unsigned long) (sizeof(pwin) - 1));
	    return ERR_OVERFLOW;
	}
	ap_getpass("Re-type new password: ", pwv, sizeof(pwv));
	if (strcmp(pwin, pwv) != 0) {
	    ap_cpystrn(record, "password verification error", (rlen - 1));
	    return ERR_PWMISMATCH;
	}
	pw = pwin;
        memset(pwv, '\0', sizeof(pwin));
#endif /* TPF */
    }
    switch (alg) {
d103 2
a104 24
    case ALG_APSHA:
	/* XXX cpw >= 28 + strlen(sha1) chars - fixed len SHA */
 	ap_sha1_base64(pw,strlen(pw),cpw);
	break;

    case ALG_APMD5: 
        (void) srand((int) time((time_t *) NULL));
        ap_to64(&salt[0], rand(), 8);
        salt[8] = '\0';

	ap_MD5Encode((const unsigned char *)pw, (const unsigned char *)salt,
		     cpw, sizeof(cpw));
	break;

    case ALG_PLAIN:
	/* XXX this len limitation is not in sync with any HTTPd len. */
	ap_cpystrn(cpw,pw,sizeof(cpw));
	break;

    case ALG_CRYPT:
    default:
        (void) srand((int) time((time_t *) NULL));
        ap_to64(&salt[0], rand(), 8);
        salt[8] = '\0';
d106 2
a107 2
	ap_cpystrn(cpw, (char *)crypt(pw, salt), sizeof(cpw) - 1);
	break;
a108 1
    memset(pw, '\0', strlen(pw));
d110 1
a110 12
    /*
     * Check to see if the buffer is large enough to hold the username,
     * hash, and delimiters.
     */
    if ((strlen(user) + 1 + strlen(cpw)) > (rlen - 1)) {
	ap_cpystrn(record, "resultant record too long", (rlen - 1));
	return ERR_OVERFLOW;
    }
    strcpy(record, user);
    strcat(record, ":");
    strcat(record, cpw);
    return 0;
a112 17
static int usage(void)
{
    fprintf(stderr, "Usage:\n");
    fprintf(stderr, "\thtpasswd [-cmdps] passwordfile username\n");
    fprintf(stderr, "\thtpasswd -b[cmdps] passwordfile username password\n\n");
    fprintf(stderr, "\thtpasswd -n[mdps] username\n");
    fprintf(stderr, "\thtpasswd -nb[mdps] username password\n");
    fprintf(stderr, " -c  Create a new file.\n");
    fprintf(stderr, " -n  Don't update file; display results on stdout.\n");
    fprintf(stderr, " -m  Force MD5 encryption of the password"
#if defined(WIN32) || defined(TPF) || defined(NETWARE)
	" (default)"
#endif
	".\n");
    fprintf(stderr, " -d  Force CRYPT encryption of the password"
#if (!(defined(WIN32) || defined(TPF) || defined(NETWARE)))
	    " (default)"
a113 11
	    ".\n");
    fprintf(stderr, " -p  Do not encrypt the password (plaintext).\n");
    fprintf(stderr, " -s  Force SHA encryption of the password.\n");
    fprintf(stderr, " -b  Use the password from the command line rather "
	    "than prompting for it.\n");
    fprintf(stderr,
	    "On Windows, TPF and NetWare systems the '-m' flag is used by default.\n");
    fprintf(stderr,
	    "On all other systems, the '-p' flag will probably not work.\n");
    return ERR_SYNTAX;
}
d115 1
a115 14
static void interrupted(void)
{
    fprintf(stderr, "Interrupted.\n");
    if (tempfilename != NULL) {
	unlink(tempfilename);
    }
    exit(ERR_INTERRUPTED);
}

/*
 * Check to see if the specified file can be opened for the given
 * access.
 */
static int accessible(char *fname, char *mode)
d117 1
a117 1
    FILE *s;
d119 6
a124 3
    s = fopen(fname, mode);
    if (s == NULL) {
	return 0;
d126 6
a131 2
    fclose(s);
    return 1;
d134 1
a134 4
/*
 * Return true if a file is readable.
 */
static int readable(char *fname)
d136 3
a138 1
    return accessible(fname, "r");
d141 1
a141 4
/*
 * Return true if the specified file can be opened for write access.
 */
static int writable(char *fname)
d143 4
a146 1
    return accessible(fname, "a");
a148 37
/*
 * Return true if the named file exists, regardless of permissions.
 */
static int exists(char *fname)
{
#ifdef WIN32
    struct _stat sbuf;
#else
    struct stat sbuf;
#endif
    int check;

#ifdef WIN32
    check = _stat(fname, &sbuf);
#else
    check = stat(fname, &sbuf);
#endif
    return ((check == -1) && (errno == ENOENT)) ? 0 : 1;
}

/*
 * Copy from the current position of one file to the current position
 * of another.
 */
static void copy_file(FILE *target, FILE *source)
{
    static char line[MAX_STRING_LEN];

    while (fgets(line, sizeof(line), source) != NULL) {
	fputs(line, target);
    }
}

/*
 * Let's do it.  We end up doing a lot of file opening and closing,
 * but what do we care?  This application isn't run constantly.
 */
d151 1
a151 2
    FILE *ftemp = NULL;
    FILE *fpw = NULL;
a152 2
    char password[MAX_STRING_LEN];
    char record[MAX_STRING_LEN];
d154 13
a166 168
    char pwfilename[MAX_STRING_LEN];
    char *arg;
    int found = 0;
    int alg = ALG_CRYPT;
    int newfile = 0;
    int nofile = 0;
    int noninteractive = 0;
    int i;
    int args_left = 2;

    tempfilename = NULL;
    signal(SIGINT, (void (*)(int)) interrupted);

    /*
     * Preliminary check to make sure they provided at least
     * three arguments, we'll do better argument checking as 
     * we parse the command line.
     */
    if (argc < 3) {
	return usage();
    }

    /*
     * Go through the argument list and pick out any options.  They
     * have to precede any other arguments.
     */
    for (i = 1; i < argc; i++) {
	arg = argv[i];
	if (*arg != '-') {
	    break;
	}
	while (*++arg != '\0') {
	    if (*arg == 'c') {
		newfile++;
	    }
	    else if (*arg == 'n') {
		nofile++;
		args_left--;
	    }
	    else if (*arg == 'm') {
		alg = ALG_APMD5;
	    }
	    else if (*arg == 's') {
		alg = ALG_APSHA;
	    }
	    else if (*arg == 'p') {
		alg = ALG_PLAIN;
	    }
	    else if (*arg == 'd') {
		alg = ALG_CRYPT;
	    }
	    else if (*arg == 'b') {
		noninteractive++;
		args_left++;
	    }
	    else {
		return usage();
	    }
	}
    }

    /*
     * Make sure we still have exactly the right number of arguments left
     * (the filename, the username, and possibly the password if -b was
     * specified).
     */
    if ((argc - i) != args_left) {
	return usage();
    }
#ifdef NETWARE
    UnAugmentAsterisk(TRUE);
    SetCurrentNameSpace(NW_NS_LONG);
    SetTargetNameSpace(NW_NS_LONG);
#endif
    if (newfile && nofile) {
	fprintf(stderr, "%s: -c and -n options conflict\n", argv[0]);
	return ERR_SYNTAX;
    }
    if (nofile) {
	i--;
    }
    else {
	if (strlen(argv[i]) > (sizeof(pwfilename) - 1)) {
	    fprintf(stderr, "%s: filename too long\n", argv[0]);
	    return ERR_OVERFLOW;
	}
	strcpy(pwfilename, argv[i]);
	if (strlen(argv[i + 1]) > (sizeof(user) - 1)) {
	    fprintf(stderr, "%s: username too long (>%lu)\n", argv[0],
		    (unsigned long)(sizeof(user) - 1));
	    return ERR_OVERFLOW;
	}
    }
    strcpy(user, argv[i + 1]);
    if ((arg = strchr(user, ':')) != NULL) {
	fprintf(stderr, "%s: username contains illegal character '%c'\n",
		argv[0], *arg);
	return ERR_BADUSER;
    }
    if (noninteractive) {
	if (strlen(argv[i + 2]) > (sizeof(password) - 1)) {
	    fprintf(stderr, "%s: password too long (>%lu)\n", argv[0],
		    (unsigned long)(sizeof(password) - 1));
	    return ERR_OVERFLOW;
	}
	strcpy(password, argv[i + 2]);
    }

#ifdef WIN32
    if (alg == ALG_CRYPT) {
	alg = ALG_APMD5;
	fprintf(stderr, "Automatically using MD5 format on Windows.\n");
    }
#elif defined(TPF) || defined(NETWARE)
    if (alg == ALG_CRYPT) {
        alg = ALG_APMD5;
        fprintf(stderr, "Automatically using MD5 format.\n");
     }
#endif

#if (!(defined(WIN32) || defined(TPF) || defined(NETWARE)))
    if (alg == ALG_PLAIN) {
	fprintf(stderr,"Warning: storing passwords as plain text might "
		"just not work on this platform.\n");
    }
#endif
    if (! nofile) {
	/*
	 * Only do the file checks if we're supposed to frob it.
	 *
	 * Verify that the file exists if -c was omitted.  We give a special
	 * message if it doesn't.
	 */
	if ((! newfile) && (! exists(pwfilename))) {
	    fprintf(stderr,
		    "%s: cannot modify file %s; use '-c' to create it\n",
		    argv[0], pwfilename);
	    perror("fopen");
	    exit(ERR_FILEPERM);
	}
	/*
	 * Verify that we can read the existing file in the case of an update
	 * to it (rather than creation of a new one).
	 */
	if ((! newfile) && (! readable(pwfilename))) {
	    fprintf(stderr, "%s: cannot open file %s for read access\n",
		    argv[0], pwfilename);
	    perror("fopen");
	    exit(ERR_FILEPERM);
	}
	/*
	 * Now check to see if we can preserve an existing file in case
	 * of password verification errors on a -c operation.
	 */
	if (newfile && exists(pwfilename) && (! readable(pwfilename))) {
	    fprintf(stderr, "%s: cannot open file %s for read access\n"
		    "%s: existing auth data would be lost on "
		    "password mismatch",
		    argv[0], pwfilename, argv[0]);
	    perror("fopen");
	    exit(ERR_FILEPERM);
	}
	/*
	 * Now verify that the file is writable!
	 */
	if (! writable(pwfilename)) {
	    fprintf(stderr, "%s: cannot open file %s for write access\n",
		    argv[0], pwfilename);
d168 1
a168 1
	    exit(ERR_FILEPERM);
d170 3
a172 18
    }

    /*
     * All the file access checks (if any) have been made.  Time to go to work;
     * try to create the record for the username in question.  If that
     * fails, there's no need to waste any time on file manipulations.
     * Any error message text is returned in the record buffer, since
     * the mkrecord() routine doesn't have access to argv[].
     */
    i = mkrecord(user, record, sizeof(record) - 1,
		 noninteractive ? password : NULL,
		 alg);
    if (i != 0) {
	fprintf(stderr, "%s: %s\n", argv[0], record);
	exit(i);
    }
    if (nofile) {
	printf("%s\n", record);
d175 2
d178 50
a227 85
    /*
     * We can access the files the right way, and we have a record
     * to add or update.  Let's do it..
     */
    errno = 0;
    tempfilename = tmpnam(tname_buf);
    if ((tempfilename == NULL) || (*tempfilename == '\0')) {
	fprintf(stderr, "%s: unable to generate temporary filename\n",
		argv[0]);
	if (errno == 0) {
	    errno = ENOENT;
	}
	perror("tmpnam");
	exit(ERR_FILEPERM);
    }
    ftemp = fopen(tempfilename, "w+");
    if (ftemp == NULL) {
	fprintf(stderr, "%s: unable to create temporary file '%s'\n", argv[0],
		tempfilename);
	perror("fopen");
	exit(ERR_FILEPERM);
    }
    /*
     * If we're not creating a new file, copy records from the existing
     * one to the temporary file until we find the specified user.
     */
    if (! newfile) {
	char scratch[MAX_STRING_LEN];

	fpw = fopen(pwfilename, "r");
	while (! (getline(line, sizeof(line), fpw))) {
	    char *colon;

	    if ((line[0] == '#') || (line[0] == '\0')) {
		putline(ftemp, line);
		continue;
	    }
	    strcpy(scratch, line);
	    /*
	     * See if this is our user.
	     */
	    colon = strchr(scratch, ':');
	    if (colon != NULL) {
		*colon = '\0';
	    }
	    if (strcmp(user, scratch) != 0) {
		putline(ftemp, line);
		continue;
	    }
	    found++;
	    break;
	}
    }
    if (found) {
	fprintf(stderr, "Updating ");
    }
    else {
	fprintf(stderr, "Adding ");
    }
    fprintf(stderr, "password for user %s\n", user);
    /*
     * Now add the user record we created.
     */
    putline(ftemp, record);
    /*
     * If we're updating an existing file, there may be additional
     * records beyond the one we're updating, so copy them.
     */
    if (! newfile) {
	copy_file(ftemp, fpw);
	fclose(fpw);
    }
    /*
     * The temporary file now contains the information that should be
     * in the actual password file.  Close the open files, re-open them
     * in the appropriate mode, and copy them file to the real one.
     */
    fclose(ftemp);
    fpw = fopen(pwfilename, "w+");
    ftemp = fopen(tempfilename, "r");
    copy_file(fpw, ftemp);
    fclose(fpw);
    fclose(ftemp);
    unlink(tempfilename);
    return 0;
@


1.1.1.3
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
@


