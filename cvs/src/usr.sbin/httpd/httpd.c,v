head	1.65;
access;
symbols
	OPENBSD_6_1:1.65.0.2
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.56.0.2
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.38.0.4
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17;
locks; strict;
comment	@ * @;


1.65
date	2017.03.25.17.25.34;	author claudio;	state Exp;
branches;
next	1.64;
commitid	43NsM2S8LTb1McoD;

1.64
date	2017.01.23.04.25.05;	author deraadt;	state Exp;
branches;
next	1.63;
commitid	NeJrtXDNhZqhGXfa;

1.63
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.62;
commitid	eA8b246voAapPTkX;

1.62
date	2016.09.28.12.01.04;	author reyk;	state Exp;
branches;
next	1.61;
commitid	iF3bh0NN3JRVXz7J;

1.61
date	2016.09.02.11.25.14;	author reyk;	state Exp;
branches;
next	1.60;
commitid	GjKzhVfFFKgNZ4YN;

1.60
date	2016.09.01.09.47.03;	author rzalamena;	state Exp;
branches;
next	1.59;
commitid	kOwNifk43Y8HrMUc;

1.59
date	2016.08.30.13.46.37;	author rzalamena;	state Exp;
branches;
next	1.58;
commitid	41KmQxu1NNvgAlwM;

1.58
date	2016.08.26.12.24.21;	author rzalamena;	state Exp;
branches;
next	1.57;
commitid	DjkH3CPbmaCOtzZ5;

1.57
date	2016.08.16.18.41.57;	author tedu;	state Exp;
branches;
next	1.56;
commitid	eyeRGwF24702KeRh;

1.56
date	2016.06.10.12.09.48;	author florian;	state Exp;
branches;
next	1.55;
commitid	Yi1lbSaNx6dLGrRo;

1.55
date	2016.05.22.19.19.21;	author jung;	state Exp;
branches;
next	1.54;
commitid	5TpZ5et3ZQ72sXY7;

1.54
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches;
next	1.53;
commitid	LQHdRRMF0nq0fugE;

1.53
date	2015.12.03.11.46.25;	author reyk;	state Exp;
branches;
next	1.52;
commitid	MjVkI8WBXvjkg1UG;

1.52
date	2015.12.03.07.01.29;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	opH6ReAwZyssRVBy;

1.51
date	2015.12.02.15.13.00;	author reyk;	state Exp;
branches;
next	1.50;
commitid	VcVtArSBXuXwQYz0;

1.50
date	2015.11.23.20.56.14;	author reyk;	state Exp;
branches;
next	1.49;
commitid	V1t7bAFyH2Xn6Kqj;

1.49
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.48;
commitid	T3JBYxNT0thPuavp;

1.48
date	2015.11.21.12.40.59;	author reyk;	state Exp;
branches;
next	1.47;
commitid	NAdDmgxUAp5Vg17B;

1.47
date	2015.11.19.21.32.53;	author mmcc;	state Exp;
branches;
next	1.46;
commitid	5eZwzlxhGA7nTpwJ;

1.46
date	2015.11.05.18.00.43;	author florian;	state Exp;
branches;
next	1.45;
commitid	b2ejv9chtKlQ0St8;

1.45
date	2015.10.31.10.10.44;	author jung;	state Exp;
branches;
next	1.44;
commitid	poWnQcuq5JxfU7Qd;

1.44
date	2015.10.28.15.50.04;	author mmcc;	state Exp;
branches;
next	1.43;
commitid	WG70BMcPJXuThAwm;

1.43
date	2015.10.28.15.45.51;	author mmcc;	state Exp;
branches;
next	1.42;
commitid	QBvvEAq5YraeWDSQ;

1.42
date	2015.10.26.11.03.29;	author jung;	state Exp;
branches;
next	1.41;
commitid	ZoZzu55CjyM1BGsk;

1.41
date	2015.10.14.08.02.38;	author reyk;	state Exp;
branches;
next	1.40;
commitid	jfLAS2kBtQ76ATNE;

1.40
date	2015.10.13.07.57.13;	author reyk;	state Exp;
branches;
next	1.39;
commitid	eRpR6Xfo42iR98SK;

1.39
date	2015.08.20.13.00.23;	author reyk;	state Exp;
branches;
next	1.38;
commitid	WDQybNKi4LiEFw8K;

1.38
date	2015.07.18.06.00.43;	author reyk;	state Exp;
branches;
next	1.37;
commitid	GYrjpgr4p814WbAx;

1.37
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches;
next	1.36;
commitid	GouatFiJVxwlAVIQ;

1.36
date	2015.05.28.17.08.09;	author florian;	state Exp;
branches;
next	1.35;
commitid	CuYEPULhoEPTPxJv;

1.35
date	2015.02.23.18.43.18;	author reyk;	state Exp;
branches;
next	1.34;
commitid	xe3hvTl4EsdtcfCj;

1.34
date	2015.02.12.10.05.29;	author reyk;	state Exp;
branches;
next	1.33;
commitid	eiL3BkcA1VXRVRJ2;

1.33
date	2015.02.10.08.12.29;	author florian;	state Exp;
branches;
next	1.32;
commitid	mWYYH04t95KXgJsq;

1.32
date	2015.02.08.00.00.59;	author reyk;	state Exp;
branches;
next	1.31;
commitid	T0lfZLuka5kZO7cg;

1.31
date	2015.01.21.22.21.05;	author reyk;	state Exp;
branches;
next	1.30;
commitid	64Zc6bef54Vu2Noy;

1.30
date	2015.01.19.19.37.50;	author reyk;	state Exp;
branches;
next	1.29;
commitid	95e2Z6BqzOOfEsll;

1.29
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	Uu5nFG3wCl0LACBb;

1.28
date	2014.12.11.17.06.55;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	6jFZftXlktiAX96V;

1.27
date	2014.12.04.02.44.42;	author tedu;	state Exp;
branches;
next	1.26;
commitid	A2H8wpKaas7ra1zW;

1.26
date	2014.11.22.00.24.22;	author tedu;	state Exp;
branches;
next	1.25;
commitid	zQJPNUJ5J7GRL1zG;

1.25
date	2014.11.21.17.49.10;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	xEhS1JfYx97ksIYD;

1.24
date	2014.11.11.15.54.45;	author beck;	state Exp;
branches;
next	1.23;
commitid	ki9qbAAMZ7dFJTRL;

1.23
date	2014.10.22.09.48.03;	author reyk;	state Exp;
branches;
next	1.22;
commitid	6UIQ1JUjIEqOoSI1;

1.22
date	2014.09.29.19.30.47;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	MS0GNEU2JBJZ5mx1;

1.21
date	2014.09.05.10.04.20;	author reyk;	state Exp;
branches;
next	1.20;
commitid	L018oMJIofTIKQBT;

1.20
date	2014.09.01.09.32.43;	author reyk;	state Exp;
branches;
next	1.19;
commitid	jMu1buTp6ZpC9q0x;

1.19
date	2014.08.13.16.04.28;	author reyk;	state Exp;
branches;
next	1.18;
commitid	rO4nAEntB2c9vXlM;

1.18
date	2014.08.13.08.08.55;	author chrisz;	state Exp;
branches;
next	1.17;
commitid	k98N1gNewULxYdw6;

1.17
date	2014.08.05.15.36.59;	author reyk;	state Exp;
branches
	1.17.4.1;
next	1.16;
commitid	0eZ0KmX2vQuZV9Ts;

1.16
date	2014.08.05.09.24.21;	author jsg;	state Exp;
branches;
next	1.15;
commitid	NFtWiwbcZQWHRBUA;

1.15
date	2014.08.04.15.49.28;	author reyk;	state Exp;
branches;
next	1.14;
commitid	LDlAyIlUWDBjADa5;

1.14
date	2014.08.04.14.49.24;	author reyk;	state Exp;
branches;
next	1.13;
commitid	vp0mWPeKkmrTbblJ;

1.13
date	2014.08.04.11.09.25;	author reyk;	state Exp;
branches;
next	1.12;
commitid	Dj6ALT3dpIHqBQcw;

1.12
date	2014.08.02.09.54.13;	author reyk;	state Exp;
branches;
next	1.11;
commitid	5XKYTFjUCKotRnfJ;

1.11
date	2014.08.01.21.59.56;	author reyk;	state Exp;
branches;
next	1.10;
commitid	x6XXpbpENAdHhEQS;

1.10
date	2014.07.26.09.59.14;	author reyk;	state Exp;
branches;
next	1.9;
commitid	3z5hk6YFMflTwMyj;

1.9
date	2014.07.25.21.29.58;	author reyk;	state Exp;
branches;
next	1.8;
commitid	smhDJiNevxTCWh6A;

1.8
date	2014.07.25.16.23.19;	author reyk;	state Exp;
branches;
next	1.7;
commitid	xxvqODaQzmLv14My;

1.7
date	2014.07.24.08.32.36;	author reyk;	state Exp;
branches;
next	1.6;
commitid	quJMC73DegnsF51x;

1.6
date	2014.07.23.23.10.27;	author reyk;	state Exp;
branches;
next	1.5;
commitid	VVSKvNDgT6LEcjyk;

1.5
date	2014.07.23.22.56.00;	author reyk;	state Exp;
branches;
next	1.4;
commitid	jUMJThPtNcjHVTS0;

1.4
date	2014.07.23.22.02.02;	author reyk;	state Exp;
branches;
next	1.3;
commitid	2WxTyiNOZ9AJbuTa;

1.3
date	2014.07.23.19.03.56;	author reyk;	state Exp;
branches;
next	1.2;
commitid	ZUW6ktdLBGFDHF5g;

1.2
date	2014.07.13.14.17.37;	author reyk;	state Exp;
branches;
next	1.1;
commitid	4gg9IcDTWDACYa56;

1.1
date	2014.07.12.23.34.54;	author reyk;	state Exp;
branches;
next	;
commitid	U5OqzWAgis3Sb3uE;

1.17.4.1
date	2014.11.20.07.48.45;	author jasper;	state Exp;
branches;
next	;
commitid	aoUNgrdXQt2mQs98;


desc
@@


1.65
log
@Implement TLS ticket support in httpd. Off by default. Use
	tls ticket lifetime default
to turn it on with a 2h ticket lifetime.
Rekeying happens after a quarter of that time.
OK reky@@ and bob@@
@
text
@/*	$OpenBSD: httpd.c,v 1.64 2017/01/23 04:25:05 deraadt Exp $	*/

/*
 * Copyright (c) 2014 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/resource.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <signal.h>
#include <getopt.h>
#include <netdb.h>
#include <fnmatch.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <syslog.h>
#include <unistd.h>
#include <ctype.h>
#include <pwd.h>

#include "httpd.h"

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

__dead void	 usage(void);

int		 parent_configure(struct httpd *);
void		 parent_configure_done(struct httpd *);
void		 parent_reload(struct httpd *, unsigned int, const char *);
void		 parent_reopen(struct httpd *);
void		 parent_sig_handler(int, short, void *);
void		 parent_shutdown(struct httpd *);
int		 parent_dispatch_server(int, struct privsep_proc *,
		    struct imsg *);
int		 parent_dispatch_logger(int, struct privsep_proc *,
		    struct imsg *);
void		 parent_tls_ticket_rekey_start(struct server *);
void		 parent_tls_ticket_rekey(int, short, void *);

struct httpd			*httpd_env;

static struct privsep_proc procs[] = {
	{ "server",	PROC_SERVER, parent_dispatch_server, server },
	{ "logger",	PROC_LOGGER, parent_dispatch_logger, logger }
};

void
parent_sig_handler(int sig, short event, void *arg)
{
	struct privsep	*ps = arg;

	switch (sig) {
	case SIGTERM:
	case SIGINT:
		parent_shutdown(ps->ps_env);
		break;
	case SIGHUP:
		log_info("%s: reload requested with SIGHUP", __func__);

		/*
		 * This is safe because libevent uses async signal handlers
		 * that run in the event loop and not in signal context.
		 */
		parent_reload(ps->ps_env, CONFIG_RELOAD, NULL);
		break;
	case SIGPIPE:
		/* ignore */
		break;
	case SIGUSR1:
		log_info("%s: reopen requested with SIGUSR1", __func__);

		parent_reopen(ps->ps_env);
		break;
	default:
		fatalx("unexpected signal");
	}
}

__dead void
usage(void)
{
	extern char	*__progname;

	fprintf(stderr, "usage: %s [-dnv] [-D macro=value] [-f file]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	int			 c;
	unsigned int		 proc;
	int			 debug = 0, verbose = 0;
	uint32_t		 opts = 0;
	struct httpd		*env;
	struct privsep		*ps;
	const char		*conffile = CONF_FILE;
	enum privsep_procid	 proc_id = PROC_PARENT;
	int			 proc_instance = 0;
	const char		*errp, *title = NULL;
	int			 argc0 = argc;

	while ((c = getopt(argc, argv, "dD:nf:I:P:v")) != -1) {
		switch (c) {
		case 'd':
			debug = 2;
			break;
		case 'D':
			if (cmdline_symset(optarg) < 0)
				log_warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'n':
			debug = 2;
			opts |= HTTPD_OPT_NOACTION;
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'v':
			verbose++;
			opts |= HTTPD_OPT_VERBOSE;
			break;
		case 'P':
			title = optarg;
			proc_id = proc_getid(procs, nitems(procs), title);
			if (proc_id == PROC_MAX)
				fatalx("invalid process name");
			break;
		case 'I':
			proc_instance = strtonum(optarg, 0,
			    PROC_MAX_INSTANCES, &errp);
			if (errp)
				fatalx("invalid process instance");
			break;
		default:
			usage();
		}
	}

	/* log to stderr until daemonized */
	log_init(debug ? debug : 1, LOG_DAEMON);

	argc -= optind;
	if (argc > 0)
		usage();

	if ((env = calloc(1, sizeof(*env))) == NULL ||
	    (ps = calloc(1, sizeof(*ps))) == NULL)
		exit(1);

	httpd_env = env;
	env->sc_ps = ps;
	ps->ps_env = env;
	TAILQ_INIT(&ps->ps_rcsocks);
	env->sc_conffile = conffile;
	env->sc_opts = opts;

	if (parse_config(env->sc_conffile, env) == -1)
		exit(1);

	if (geteuid())
		errx(1, "need root privileges");

	if ((ps->ps_pw =  getpwnam(HTTPD_USER)) == NULL)
		errx(1, "unknown user %s", HTTPD_USER);

	/* Configure the control socket */
	ps->ps_csock.cs_name = NULL;

	log_init(debug, LOG_DAEMON);
	log_setverbose(verbose);

	if (env->sc_opts & HTTPD_OPT_NOACTION)
		ps->ps_noaction = 1;

	ps->ps_instances[PROC_SERVER] = env->sc_prefork_server;
	ps->ps_instance = proc_instance;
	if (title != NULL)
		ps->ps_title[proc_id] = title;

	if (env->sc_chroot == NULL)
		env->sc_chroot = ps->ps_pw->pw_dir;
	for (proc = 0; proc < nitems(procs); proc++)
		procs[proc].p_chroot = env->sc_chroot;

	if (env->sc_logdir == NULL) {
		if (asprintf(&env->sc_logdir, "%s%s", env->sc_chroot,
			HTTPD_LOGROOT) == -1)
			errx(1, "malloc failed");
	}

	/* only the parent returns */
	proc_init(ps, procs, nitems(procs), argc0, argv, proc_id);

	log_procinit("parent");
	if (!debug && daemon(1, 0) == -1)
		err(1, "failed to daemonize");

	if (ps->ps_noaction == 0)
		log_info("startup");

	if (pledge("stdio rpath wpath cpath inet dns sendfd", NULL) == -1)
		fatal("pledge");

	event_init();

	signal_set(&ps->ps_evsigint, SIGINT, parent_sig_handler, ps);
	signal_set(&ps->ps_evsigterm, SIGTERM, parent_sig_handler, ps);
	signal_set(&ps->ps_evsighup, SIGHUP, parent_sig_handler, ps);
	signal_set(&ps->ps_evsigpipe, SIGPIPE, parent_sig_handler, ps);
	signal_set(&ps->ps_evsigusr1, SIGUSR1, parent_sig_handler, ps);

	signal_add(&ps->ps_evsigint, NULL);
	signal_add(&ps->ps_evsigterm, NULL);
	signal_add(&ps->ps_evsighup, NULL);
	signal_add(&ps->ps_evsigpipe, NULL);
	signal_add(&ps->ps_evsigusr1, NULL);

	proc_connect(ps);

	if (load_config(env->sc_conffile, env) == -1) {
		proc_kill(env->sc_ps);
		exit(1);
	}

	if (env->sc_opts & HTTPD_OPT_NOACTION) {
		fprintf(stderr, "configuration OK\n");
		proc_kill(env->sc_ps);
		exit(0);
	}

	/* initialize the TLS session id to a random key for all procs */
	arc4random_buf(env->sc_tls_sid, sizeof(env->sc_tls_sid));

	if (parent_configure(env) == -1)
		fatalx("configuration failed");

	event_dispatch();

	parent_shutdown(env);
	/* NOTREACHED */

	return (0);
}

int
parent_configure(struct httpd *env)
{
	int			 id;
	struct ctl_flags	 cf;
	int			 ret = -1;
	struct server		*srv;
	struct media_type	*media;
	struct auth		*auth;

	RB_FOREACH(media, mediatypes, env->sc_mediatypes) {
		if (config_setmedia(env, media) == -1)
			fatal("send media");
	}

	TAILQ_FOREACH(auth, env->sc_auth, auth_entry) {
		if (config_setauth(env, auth) == -1)
			fatal("send auth");
	}

	/* First send the servers... */
	TAILQ_FOREACH(srv, env->sc_servers, srv_entry) {
		if (srv->srv_conf.flags & SRVFLAG_LOCATION)
			continue;
		/* start the rekey of the tls ticket keys */
		if (srv->srv_conf.flags & SRVFLAG_TLS &&
		    srv->srv_conf.tls_ticket_lifetime)
			parent_tls_ticket_rekey_start(srv);
		if (config_setserver(env, srv) == -1)
			fatal("send server");
	}
	/* ...and now send the locations */
	TAILQ_FOREACH(srv, env->sc_servers, srv_entry) {
		if ((srv->srv_conf.flags & SRVFLAG_LOCATION) == 0)
			continue;
		if (config_setserver(env, srv) == -1)
			fatal("send location");
	}

	/* The servers need to reload their config. */
	env->sc_reload = env->sc_prefork_server + 1;

	for (id = 0; id < PROC_MAX; id++) {
		if (id == privsep_process)
			continue;
		cf.cf_opts = env->sc_opts;
		cf.cf_flags = env->sc_flags;
		memcpy(cf.cf_tls_sid, env->sc_tls_sid, sizeof(cf.cf_tls_sid));

		proc_compose(env->sc_ps, id, IMSG_CFG_DONE, &cf, sizeof(cf));
	}

	ret = 0;

	config_purge(env, CONFIG_ALL);
	return (ret);
}

void
parent_reload(struct httpd *env, unsigned int reset, const char *filename)
{
	if (env->sc_reload) {
		log_debug("%s: already in progress: %d pending",
		    __func__, env->sc_reload);
		return;
	}

	/* Switch back to the default config file */
	if (filename == NULL || *filename == '\0')
		filename = env->sc_conffile;

	log_debug("%s: level %d config file %s", __func__, reset, filename);

	config_purge(env, CONFIG_ALL);

	if (reset == CONFIG_RELOAD) {
		if (load_config(filename, env) == -1) {
			log_debug("%s: failed to load config file %s",
			    __func__, filename);
		}

		config_setreset(env, CONFIG_ALL);

		if (parent_configure(env) == -1) {
			log_debug("%s: failed to commit config from %s",
			    __func__, filename);
		}
	} else
		config_setreset(env, reset);
}

void
parent_reopen(struct httpd *env)
{
	proc_compose(env->sc_ps, PROC_LOGGER, IMSG_CTL_REOPEN, NULL, 0);
}

void
parent_configure_done(struct httpd *env)
{
	int	 id;

	if (env->sc_reload == 0) {
		log_warnx("%s: configuration already finished", __func__);
		return;
	}

	env->sc_reload--;
	if (env->sc_reload == 0) {
		for (id = 0; id < PROC_MAX; id++) {
			if (id == privsep_process)
				continue;

			proc_compose(env->sc_ps, id, IMSG_CTL_START, NULL, 0);
		}
	}
}

void
parent_shutdown(struct httpd *env)
{
	config_purge(env, CONFIG_ALL);

	proc_kill(env->sc_ps);
	control_cleanup(&env->sc_ps->ps_csock);
	if (env->sc_ps->ps_csock.cs_name != NULL)
		(void)unlink(env->sc_ps->ps_csock.cs_name);

	free(env->sc_ps);
	free(env);

	log_info("parent terminating, pid %d", getpid());

	exit(0);
}

int
parent_dispatch_server(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct privsep		*ps = p->p_ps;
	struct httpd		*env = ps->ps_env;

	switch (imsg->hdr.type) {
	case IMSG_CFG_DONE:
		parent_configure_done(env);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
parent_dispatch_logger(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct privsep		*ps = p->p_ps;
	struct httpd		*env = ps->ps_env;
	unsigned int		 v;
	char			*str = NULL;

	switch (imsg->hdr.type) {
	case IMSG_CTL_RESET:
		IMSG_SIZE_CHECK(imsg, &v);
		memcpy(&v, imsg->data, sizeof(v));
		parent_reload(env, v, NULL);
		break;
	case IMSG_CTL_RELOAD:
		if (IMSG_DATA_SIZE(imsg) > 0)
			str = get_string(imsg->data, IMSG_DATA_SIZE(imsg));
		parent_reload(env, CONFIG_RELOAD, str);
		free(str);
		break;
	case IMSG_CTL_SHUTDOWN:
		parent_shutdown(env);
		break;
	case IMSG_CTL_REOPEN:
		parent_reopen(env);
		break;
	case IMSG_CFG_DONE:
		parent_configure_done(env);
		break;
	case IMSG_LOG_OPEN:
		if (logger_open_priv(imsg) == -1)
			fatalx("failed to open log file");
		break;
	default:
		return (-1);
	}

	return (0);
}

void
parent_tls_ticket_rekey_start(struct server *srv)
{
	struct timeval		 tv;

	server_generate_ticket_key(&srv->srv_conf);

	evtimer_set(&srv->srv_evt, parent_tls_ticket_rekey, srv);
	timerclear(&tv);
	tv.tv_sec = srv->srv_conf.tls_ticket_lifetime / 4;
	evtimer_add(&srv->srv_evt, &tv);
}

void
parent_tls_ticket_rekey(int fd, short events, void *arg)
{
	struct server		*srv = arg;
	struct timeval		 tv;

	server_generate_ticket_key(&srv->srv_conf);
	proc_compose_imsg(httpd_env->sc_ps, PROC_SERVER, -1,
	    IMSG_TLSTICKET_REKEY, -1, -1, &srv->srv_conf.tls_ticket_key,
	    sizeof(srv->srv_conf.tls_ticket_key));
	explicit_bzero(&srv->srv_conf.tls_ticket_key,
	    sizeof(srv->srv_conf.tls_ticket_key));

	evtimer_set(&srv->srv_evt, parent_tls_ticket_rekey, srv);
	timerclear(&tv);
	tv.tv_sec = srv->srv_conf.tls_ticket_lifetime / 4;
	evtimer_add(&srv->srv_evt, &tv);
}

/*
 * Utility functions
 */

void
event_again(struct event *ev, int fd, short event,
    void (*fn)(int, short, void *),
    struct timeval *start, struct timeval *end, void *arg)
{
	struct timeval tv_next, tv_now, tv;

	getmonotime(&tv_now);
	memcpy(&tv_next, end, sizeof(tv_next));
	timersub(&tv_now, start, &tv_now);
	timersub(&tv_next, &tv_now, &tv_next);

	memset(&tv, 0, sizeof(tv));
	if (timercmp(&tv_next, &tv, >))
		memcpy(&tv, &tv_next, sizeof(tv));

	event_del(ev);
	event_set(ev, fd, event, fn, arg);
	event_add(ev, &tv);
}

int
expand_string(char *label, size_t len, const char *srch, const char *repl)
{
	char *tmp;
	char *p, *q;

	if ((tmp = calloc(1, len)) == NULL) {
		log_debug("%s: calloc", __func__);
		return (-1);
	}
	p = q = label;
	while ((q = strstr(p, srch)) != NULL) {
		*q = '\0';
		if ((strlcat(tmp, p, len) >= len) ||
		    (strlcat(tmp, repl, len) >= len)) {
			log_debug("%s: string too long", __func__);
			free(tmp);
			return (-1);
		}
		q += strlen(srch);
		p = q;
	}
	if (strlcat(tmp, p, len) >= len) {
		log_debug("%s: string too long", __func__);
		free(tmp);
		return (-1);
	}
	(void)strlcpy(label, tmp, len);	/* always fits */
	free(tmp);

	return (0);
}

const char *
canonicalize_host(const char *host, char *name, size_t len)
{
	struct sockaddr_in	 sin4;
	struct sockaddr_in6	 sin6;
	size_t			 i, j;
	size_t			 plen;
	char			 c;

	if (len < 2)
		goto fail;

	/*
	 * Canonicalize an IPv4/6 address
	 */
	if (inet_pton(AF_INET, host, &sin4) == 1)
		return (inet_ntop(AF_INET, &sin4, name, len));
	if (inet_pton(AF_INET6, host, &sin6) == 1)
		return (inet_ntop(AF_INET6, &sin6, name, len));

	/*
	 * Canonicalize a hostname
	 */

	/* 1. remove repeated dots and convert upper case to lower case */
	plen = strlen(host);
	memset(name, 0, len);
	for (i = j = 0; i < plen; i++) {
		if (j >= (len - 1))
			goto fail;
		c = tolower((unsigned char)host[i]);
		if ((c == '.') && (j == 0 || name[j - 1] == '.'))
			continue;
		name[j++] = c;
	}

	/* 2. remove trailing dots */
	for (i = j; i > 0; i--) {
		if (name[i - 1] != '.')
			break;
		name[i - 1] = '\0';
		j--;
	}
	if (j <= 0)
		goto fail;

	return (name);

 fail:
	errno = EINVAL;
	return (NULL);
}

const char *
url_decode(char *url)
{
	char		*p, *q;
	char		 hex[3];
	unsigned long	 x;

	hex[2] = '\0';
	p = q = url;

	while (*p != '\0') {
		switch (*p) {
		case '%':
			/* Encoding character is followed by two hex chars */
			if (!(isxdigit((unsigned char)p[1]) &&
			    isxdigit((unsigned char)p[2])))
				return (NULL);

			hex[0] = p[1];
			hex[1] = p[2];

			/*
			 * We don't have to validate "hex" because it is
			 * guaranteed to include two hex chars followed by nul.
			 */
			x = strtoul(hex, NULL, 16);
			*q = (char)x;
			p += 2;
			break;
		default:
			*q = *p;
			break;
		}
		p++;
		q++;
	}
	*q = '\0';

	return (url);
}

const char *
canonicalize_path(const char *input, char *path, size_t len)
{
	const char	*i;
	char		*p, *start, *end;

	/* assuming input starts with '/' and is nul-terminated */
	i = input;
	p = path;

	if (*input != '/' || len < 3)
		return (NULL);

	start = p;
	end = p + (len - 1);

	while (*i != '\0') {
		/* Detect truncation */
		if (p >= end)
			return (NULL);

		/* 1. check for special path elements */
		if (i[0] == '/') {
			if (i[1] == '/') {
				/* a) skip repeating '//' slashes */
				while (i[1] == '/')
					i++;
				continue;
			} else if (i[1] == '.' && i[2] == '.' &&
			    (i[3] == '/' || i[3] == '\0')) {
				/* b) revert '..' to previous directory */
				i += 3;
				while (p > start && *p != '/')
					p--;
				*p = '\0';
				continue;
			} else if (i[1] == '.' &&
			    (i[2] == '/' || i[2] == '\0')) {
				/* c) skip unnecessary '.' current dir */
				i += 2;
				continue;
			}
		}

		/* 2. copy any other characters */
		*p++ = *i;
		i++;
	}
	if (p == start)
		*p++ = '/';
	*p++ = '\0';

	return (path);
}

size_t
path_info(char *path)
{
	char		*p, *start, *end, ch;
	struct stat	 st;
	int		 ret;

	start = path;
	end = start + strlen(path);

	for (p = end; p > start; p--) {
		/* Scan every path component from the end and at each '/' */
		if (p < end && *p != '/')
			continue;

		/* Temporarily cut the path component out */
		ch = *p;
		*p = '\0';
		ret = stat(path, &st);
		*p = ch;

		/* Break if the initial path component was found */
		if (ret == 0)
			break;
	}

	return (p - start);
}

char *
url_encode(const char *src)
{
	static char	 hex[] = "0123456789ABCDEF";
	char		*dp, *dst;
	unsigned char	 c;

	/* We need 3 times the memory if every letter is encoded. */
	if ((dst = calloc(3, strlen(src) + 1)) == NULL)
		return (NULL);

	for (dp = dst; *src != 0; src++) {
		c = (unsigned char) *src;
		if (c == ' ' || c == '#' || c == '%' || c == '?' || c == '"' ||
		    c == '&' || c == '<' || c <= 0x1f || c >= 0x7f) {
			*dp++ = '%';
			*dp++ = hex[c >> 4];
			*dp++ = hex[c & 0x0f];
		} else
			*dp++ = *src;
	}
	return (dst);
}

char*
escape_html(const char* src)
{
	char		*dp, *dst;

	/* We need 5 times the memory if every letter is "&" */
	if ((dst = calloc(5, strlen(src) + 1)) == NULL)
		return NULL;

	for (dp = dst; *src != 0; src++) {
		if (*src == '<') {
			*dp++ = '&';
			*dp++ = 'l';
			*dp++ = 't';
			*dp++ = ';';
		} else if (*src == '>') {
			*dp++ = '&';
			*dp++ = 'g';
			*dp++ = 't';
			*dp++ = ';';
		} else if (*src == '&') {
			*dp++ = '&';
			*dp++ = 'a';
			*dp++ = 'm';
			*dp++ = 'p';
			*dp++ = ';';
		} else
			*dp++ = *src;
	}
	return (dst);
}

void
socket_rlimit(int maxfd)
{
	struct rlimit	 rl;

	if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("socket_rlimit: failed to get resource limit");
	log_debug("%s: max open files %llu", __func__, rl.rlim_max);

	/*
	 * Allow the maximum number of open file descriptors for this
	 * login class (which should be the class "daemon" by default).
	 */
	if (maxfd == -1)
		rl.rlim_cur = rl.rlim_max;
	else
		rl.rlim_cur = MAXIMUM(rl.rlim_max, (rlim_t)maxfd);
	if (setrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("socket_rlimit: failed to set resource limit");
}

char *
evbuffer_getline(struct evbuffer *evb)
{
	uint8_t		*ptr = EVBUFFER_DATA(evb);
	size_t		 len = EVBUFFER_LENGTH(evb);
	char		*str;
	size_t		 i;

	/* Safe version of evbuffer_readline() */
	if ((str = get_string(ptr, len)) == NULL)
		return (NULL);

	for (i = 0; str[i] != '\0'; i++) {
		if (str[i] == '\r' || str[i] == '\n')
			break;
	}

	if (i == len) {
		free(str);
		return (NULL);
	}

	str[i] = '\0';

	if ((i + 1) < len) {
		if (ptr[i] == '\r' && ptr[i + 1] == '\n')
			i++;
	}

	evbuffer_drain(evb, ++i);

	return (str);
}

char *
get_string(uint8_t *ptr, size_t len)
{
	size_t	 i;

	for (i = 0; i < len; i++)
		if (!(isprint((unsigned char)ptr[i]) ||
		    isspace((unsigned char)ptr[i])))
			break;

	return strndup(ptr, i);
}

void *
get_data(uint8_t *ptr, size_t len)
{
	uint8_t		*data;

	if ((data = malloc(len)) == NULL)
		return (NULL);
	memcpy(data, ptr, len);

	return (data);
}

int
sockaddr_cmp(struct sockaddr *a, struct sockaddr *b, int prefixlen)
{
	struct sockaddr_in	*a4, *b4;
	struct sockaddr_in6	*a6, *b6;
	uint32_t		 av[4], bv[4], mv[4];

	if (a->sa_family == AF_UNSPEC || b->sa_family == AF_UNSPEC)
		return (0);
	else if (a->sa_family > b->sa_family)
		return (1);
	else if (a->sa_family < b->sa_family)
		return (-1);

	if (prefixlen == -1)
		memset(&mv, 0xff, sizeof(mv));

	switch (a->sa_family) {
	case AF_INET:
		a4 = (struct sockaddr_in *)a;
		b4 = (struct sockaddr_in *)b;

		av[0] = a4->sin_addr.s_addr;
		bv[0] = b4->sin_addr.s_addr;
		if (prefixlen != -1)
			mv[0] = prefixlen2mask(prefixlen);

		if ((av[0] & mv[0]) > (bv[0] & mv[0]))
			return (1);
		if ((av[0] & mv[0]) < (bv[0] & mv[0]))
			return (-1);
		break;
	case AF_INET6:
		a6 = (struct sockaddr_in6 *)a;
		b6 = (struct sockaddr_in6 *)b;

		memcpy(&av, &a6->sin6_addr.s6_addr, 16);
		memcpy(&bv, &b6->sin6_addr.s6_addr, 16);
		if (prefixlen != -1)
			prefixlen2mask6(prefixlen, mv);

		if ((av[3] & mv[3]) > (bv[3] & mv[3]))
			return (1);
		if ((av[3] & mv[3]) < (bv[3] & mv[3]))
			return (-1);
		if ((av[2] & mv[2]) > (bv[2] & mv[2]))
			return (1);
		if ((av[2] & mv[2]) < (bv[2] & mv[2]))
			return (-1);
		if ((av[1] & mv[1]) > (bv[1] & mv[1]))
			return (1);
		if ((av[1] & mv[1]) < (bv[1] & mv[1]))
			return (-1);
		if ((av[0] & mv[0]) > (bv[0] & mv[0]))
			return (1);
		if ((av[0] & mv[0]) < (bv[0] & mv[0]))
			return (-1);
		break;
	}

	return (0);
}

uint32_t
prefixlen2mask(uint8_t prefixlen)
{
	if (prefixlen == 0)
		return (0);

	if (prefixlen > 32)
		prefixlen = 32;

	return (htonl(0xffffffff << (32 - prefixlen)));
}

struct in6_addr *
prefixlen2mask6(uint8_t prefixlen, uint32_t *mask)
{
	static struct in6_addr  s6;
	int			i;

	if (prefixlen > 128)
		prefixlen = 128;

	memset(&s6, 0, sizeof(s6));
	for (i = 0; i < prefixlen / 8; i++)
		s6.s6_addr[i] = 0xff;
	i = prefixlen % 8;
	if (i)
		s6.s6_addr[prefixlen / 8] = 0xff00 >> i;

	memcpy(mask, &s6, sizeof(s6));

	return (&s6);
}

int
accept_reserve(int sockfd, struct sockaddr *addr, socklen_t *addrlen,
    int reserve, volatile int *counter)
{
	int ret;
	if (getdtablecount() + reserve +
	    *counter >= getdtablesize()) {
		errno = EMFILE;
		return (-1);
	}

	if ((ret = accept4(sockfd, addr, addrlen, SOCK_NONBLOCK)) > -1) {
		(*counter)++;
		DPRINTF("%s: inflight incremented, now %d",__func__, *counter);
	}
	return (ret);
}

struct kv *
kv_add(struct kvtree *keys, char *key, char *value)
{
	struct kv	*kv, *oldkv;

	if (key == NULL)
		return (NULL);
	if ((kv = calloc(1, sizeof(*kv))) == NULL)
		return (NULL);
	if ((kv->kv_key = strdup(key)) == NULL) {
		free(kv);
		return (NULL);
	}
	if (value != NULL &&
	    (kv->kv_value = strdup(value)) == NULL) {
		free(kv->kv_key);
		free(kv);
		return (NULL);
	}
	TAILQ_INIT(&kv->kv_children);

	if ((oldkv = RB_INSERT(kvtree, keys, kv)) != NULL) {
		TAILQ_INSERT_TAIL(&oldkv->kv_children, kv, kv_entry);
		kv->kv_parent = oldkv;
	}

	return (kv);
}

int
kv_set(struct kv *kv, char *fmt, ...)
{
	va_list		  ap;
	char		*value = NULL;
	struct kv	*ckv;
	int		ret;

	va_start(ap, fmt);
	ret = vasprintf(&value, fmt, ap);
	va_end(ap);
	if (ret == -1)
		return (-1);

	/* Remove all children */
	while ((ckv = TAILQ_FIRST(&kv->kv_children)) != NULL) {
		TAILQ_REMOVE(&kv->kv_children, ckv, kv_entry);
		kv_free(ckv);
		free(ckv);
	}

	/* Set the new value */
	free(kv->kv_value);
	kv->kv_value = value;

	return (0);
}

int
kv_setkey(struct kv *kv, char *fmt, ...)
{
	va_list  ap;
	char	*key = NULL;
	int	ret;

	va_start(ap, fmt);
	ret = vasprintf(&key, fmt, ap);
	va_end(ap);
	if (ret == -1)
		return (-1);

	free(kv->kv_key);
	kv->kv_key = key;

	return (0);
}

void
kv_delete(struct kvtree *keys, struct kv *kv)
{
	struct kv	*ckv;

	RB_REMOVE(kvtree, keys, kv);

	/* Remove all children */
	while ((ckv = TAILQ_FIRST(&kv->kv_children)) != NULL) {
		TAILQ_REMOVE(&kv->kv_children, ckv, kv_entry);
		kv_free(ckv);
		free(ckv);
	}

	kv_free(kv);
	free(kv);
}

struct kv *
kv_extend(struct kvtree *keys, struct kv *kv, char *value)
{
	char		*newvalue;

	if (kv == NULL) {
		return (NULL);
	} else if (kv->kv_value != NULL) {
		if (asprintf(&newvalue, "%s%s", kv->kv_value, value) == -1)
			return (NULL);

		free(kv->kv_value);
		kv->kv_value = newvalue;
	} else if ((kv->kv_value = strdup(value)) == NULL)
		return (NULL);

	return (kv);
}

void
kv_purge(struct kvtree *keys)
{
	struct kv	*kv;

	while ((kv = RB_MIN(kvtree, keys)) != NULL)
		kv_delete(keys, kv);
}

void
kv_free(struct kv *kv)
{
	free(kv->kv_key);
	kv->kv_key = NULL;
	free(kv->kv_value);
	kv->kv_value = NULL;
	memset(kv, 0, sizeof(*kv));
}

struct kv *
kv_inherit(struct kv *dst, struct kv *src)
{
	memset(dst, 0, sizeof(*dst));
	memcpy(dst, src, sizeof(*dst));
	TAILQ_INIT(&dst->kv_children);

	if (src->kv_key != NULL) {
		if ((dst->kv_key = strdup(src->kv_key)) == NULL) {
			kv_free(dst);
			return (NULL);
		}
	}
	if (src->kv_value != NULL) {
		if ((dst->kv_value = strdup(src->kv_value)) == NULL) {
			kv_free(dst);
			return (NULL);
		}
	}

	return (dst);
}

int
kv_log(struct evbuffer *log, struct kv *kv)
{
	char	*msg;

	if (log == NULL)
		return (0);
	if (asprintf(&msg, " [%s%s%s]",
	    kv->kv_key == NULL ? "(unknown)" : kv->kv_key,
	    kv->kv_value == NULL ? "" : ": ",
	    kv->kv_value == NULL ? "" : kv->kv_value) == -1)
		return (-1);
	if (evbuffer_add(log, msg, strlen(msg)) == -1) {
		free(msg);
		return (-1);
	}
	free(msg);

	return (0);
}

struct kv *
kv_find(struct kvtree *keys, struct kv *kv)
{
	struct kv	*match;
	const char	*key;

	if (kv->kv_flags & KV_FLAG_GLOBBING) {
		/* Test header key using shell globbing rules */
		key = kv->kv_key == NULL ? "" : kv->kv_key;
		RB_FOREACH(match, kvtree, keys) {
			if (fnmatch(key, match->kv_key, FNM_CASEFOLD) == 0)
				break;
		}
	} else {
		/* Fast tree-based lookup only works without globbing */
		match = RB_FIND(kvtree, keys, kv);
	}

	return (match);
}

int
kv_cmp(struct kv *a, struct kv *b)
{
	return (strcasecmp(a->kv_key, b->kv_key));
}

RB_GENERATE(kvtree, kv, kv_node, kv_cmp);

struct media_type *
media_add(struct mediatypes *types, struct media_type *media)
{
	struct media_type	*entry;

	if ((entry = RB_FIND(mediatypes, types, media)) != NULL) {
		log_debug("%s: duplicated entry for \"%s\"", __func__,
		    media->media_name);
		return (NULL);
	}

	if ((entry = malloc(sizeof(*media))) == NULL)
		return (NULL);

	memcpy(entry, media, sizeof(*entry));
	if (media->media_encoding != NULL &&
	    (entry->media_encoding = strdup(media->media_encoding)) == NULL) {
		free(entry);
		return (NULL);
	}
	RB_INSERT(mediatypes, types, entry);

	return (entry);
}

void
media_delete(struct mediatypes *types, struct media_type *media)
{
	RB_REMOVE(mediatypes, types, media);

	free(media->media_encoding);
	free(media);
}

void
media_purge(struct mediatypes *types)
{
	struct media_type	*media;

	while ((media = RB_MIN(mediatypes, types)) != NULL)
		media_delete(types, media);
}

struct media_type *
media_find(struct mediatypes *types, const char *file)
{
	struct media_type	*match, media;
	char			*p;

	/* Last component of the file name */
	p = strchr(file, '\0');
	while (p > file && p[-1] != '.' && p[-1] != '/')
		p--;
	if (*p == '\0')
		return (NULL);

	if (strlcpy(media.media_name, p,
	    sizeof(media.media_name)) >=
	    sizeof(media.media_name)) {
		return (NULL);
	}

	/* Find media type by extension name */
	match = RB_FIND(mediatypes, types, &media);

	return (match);
}

struct media_type *
media_find_config(struct httpd *env, struct server_config *srv_conf,
    const char *file)
{
	struct media_type	*match;

	if ((match = media_find(env->sc_mediatypes, file)) != NULL)
		return (match);
	else if (srv_conf->flags & SRVFLAG_DEFAULT_TYPE)
		return (&srv_conf->default_type);

	/* fallback to the global default type */
	return (&env->sc_default_type);
}

int
media_cmp(struct media_type *a, struct media_type *b)
{
	return (strcasecmp(a->media_name, b->media_name));
}

RB_GENERATE(mediatypes, media_type, media_entry, media_cmp);

struct auth *
auth_add(struct serverauth *serverauth, struct auth *auth)
{
	struct auth		*entry;

	TAILQ_FOREACH(entry, serverauth, auth_entry) {
		if (strcmp(entry->auth_htpasswd, auth->auth_htpasswd) == 0)
			return (entry);
	}

	if ((entry = calloc(1, sizeof(*entry))) == NULL)
		return (NULL);

	memcpy(entry, auth, sizeof(*entry));

	TAILQ_INSERT_TAIL(serverauth, entry, auth_entry);

	return (entry);
}

struct auth *
auth_byid(struct serverauth *serverauth, uint32_t id)
{
	struct auth	*auth;

	TAILQ_FOREACH(auth, serverauth, auth_entry) {
		if (auth->auth_id == id)
			return (auth);
	}

	return (NULL);
}

void
auth_free(struct serverauth *serverauth, struct auth *auth)
{
	TAILQ_REMOVE(serverauth, auth, auth_entry);
}


const char *
print_host(struct sockaddr_storage *ss, char *buf, size_t len)
{
	if (getnameinfo((struct sockaddr *)ss, ss->ss_len,
	    buf, len, NULL, 0, NI_NUMERICHOST) != 0) {
		buf[0] = '\0';
		return (NULL);
	}
	return (buf);
}

const char *
print_time(struct timeval *a, struct timeval *b, char *buf, size_t len)
{
	struct timeval		tv;
	unsigned long		h, sec, min;

	timerclear(&tv);
	timersub(a, b, &tv);
	sec = tv.tv_sec % 60;
	min = tv.tv_sec / 60 % 60;
	h = tv.tv_sec / 60 / 60;

	snprintf(buf, len, "%.2lu:%.2lu:%.2lu", h, min, sec);
	return (buf);
}

const char *
printb_flags(const uint32_t v, const char *bits)
{
	static char	 buf[2][BUFSIZ];
	static int	 idx = 0;
	int		 i, any = 0;
	char		 c, *p, *r;

	p = r = buf[++idx % 2];
	memset(p, 0, BUFSIZ);

	if (bits) {
		bits++;
		while ((i = *bits++)) {
			if (v & (1 << (i - 1))) {
				if (any) {
					*p++ = ',';
					*p++ = ' ';
				}
				any = 1;
				for (; (c = *bits) > 32; bits++) {
					if (c == '_')
						*p++ = ' ';
					else
						*p++ =
						    tolower((unsigned char)c);
				}
			} else
				for (; *bits > 32; bits++)
					;
		}
	}

	return (r);
}

void
getmonotime(struct timeval *tv)
{
	struct timespec	 ts;

	if (clock_gettime(CLOCK_MONOTONIC, &ts))
		fatal("clock_gettime");

	TIMESPEC_TO_TIMEVAL(tv, &ts);
}
@


1.64
log
@Split pledge "ioctl" into "tape" and "bpf", and allow SIOCGIFGROUP only
upon "inet".  Adjust the 4 programs that care about this.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.63 2017/01/09 14:49:22 reyk Exp $	*/
d60 2
d257 3
d295 4
d318 1
d462 32
@


1.63
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.62 2016/09/28 12:01:04 reyk Exp $	*/
d225 1
a225 2
	if (pledge("stdio rpath wpath cpath inet dns ioctl sendfd",
	    NULL) == -1)
@


1.62
log
@sync proc.c from switchd, includes minor cast qual fix and removal of p_env.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.61 2016/09/02 11:25:14 reyk Exp $	*/
d194 1
a194 1
	log_verbose(verbose);
@


1.61
log
@proc.c tweaks: Rename proc_listento() to proc_accept() as it is the
receiving side of proc_connect().  Move some code from main into
proc_init(), the function is now called by parent and children, not
just the parent and it is less copy + paste for other daemons.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.60 2016/09/01 09:47:03 rzalamena Exp $	*/
d401 2
a402 1
	struct httpd		*env = p->p_env;
d418 2
a419 1
	struct httpd		*env = p->p_env;
@


1.60
log
@Teach httpd/proc.c how to fork+exec.

This commit implemented the basic functions to proc.c to make it not rely
on global variables, malloc()ed memory and CLOEXEC pipes.

Fix child proc titles from reyk@@
ok reyk@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.59 2016/08/30 13:46:37 rzalamena Exp $	*/
a119 1
	struct privsep_proc	*p;
d201 2
d215 2
a216 18
	if (proc_id != PROC_PARENT) {
		p = NULL;
		for (proc = 0; proc < nitems(procs); proc++) {
			if (procs[proc].p_id != proc_id)
				continue;

			p = &procs[proc];
			break;
		}
		if (p == NULL || p->p_init == NULL)
			fatalx("%s: process %d missing process initialization",
			    __func__, proc_id);

		ps->ps_title[proc_id] = title;
		p->p_init(ps, p);

		fatalx("failed to initiate child process");
	}
a217 1
	proc_init(ps, procs, nitems(procs), argc0, argv);
@


1.59
log
@Terminate daemon using the socket status instead of watching SIGCHLD or
kill()ing child process.

"Looks good to me" millert@@
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.58 2016/08/26 12:24:21 rzalamena Exp $	*/
d120 5
d126 1
a126 1
	while ((c = getopt(argc, argv, "dD:nf:v")) != -1) {
d147 12
a196 3
	if (!debug && daemon(1, 0) == -1)
		err(1, "failed to daemonize");

a198 2
	else
		log_info("startup");
d201 1
d214 20
a233 1
	proc_init(ps, procs, nitems(procs));
d235 5
d259 1
a259 1
	proc_listen(ps, procs, nitems(procs));
@


1.58
log
@Kill the ps_ninstances from proc.c.

We got the same information in ps_instances[proc] (more accurate) and
we avoid allocating unnecessary memory for pipe storage.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.57 2016/08/16 18:41:57 tedu Exp $	*/
a22 1
#include <sys/wait.h>
a71 3
	int		 die = 0, status, fail, id;
	pid_t		 pid;
	char		*cause;
d76 1
a76 43
		die = 1;
		/* FALLTHROUGH */
	case SIGCHLD:
		do {
			int len;

			pid = waitpid(WAIT_ANY, &status, WNOHANG);
			if (pid <= 0)
				continue;

			fail = 0;
			if (WIFSIGNALED(status)) {
				fail = 1;
				len = asprintf(&cause, "terminated; signal %d",
				    WTERMSIG(status));
			} else if (WIFEXITED(status)) {
				if (WEXITSTATUS(status) != 0) {
					fail = 1;
					len = asprintf(&cause,
					    "exited abnormally");
				} else
					len = asprintf(&cause, "exited okay");
			} else
				fatalx("unexpected cause of SIGCHLD");

			if (len == -1)
				fatal("asprintf");

			die = 1;

			for (id = 0; id < PROC_MAX; id++)
				if (pid == ps->ps_pid[id]) {
					if (fail)
						log_warnx("lost child: %s %s",
						    ps->ps_title[id], cause);
					break;
				}

			free(cause);
		} while (pid > 0 || (pid == -1 && errno == EINTR));

		if (die)
			parent_shutdown(ps->ps_env);
d204 1
a204 1
	if (pledge("stdio rpath wpath cpath inet dns proc ioctl sendfd",
a211 1
	signal_set(&ps->ps_evsigchld, SIGCHLD, parent_sig_handler, ps);
a217 1
	signal_add(&ps->ps_evsigchld, NULL);
@


1.57
log
@stop including sys/param.h for nitems. define locally as needed.
ok natano reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.56 2016/06/10 12:09:48 florian Exp $	*/
a234 1
	ps->ps_ninstances = env->sc_prefork_server;
@


1.56
log
@& expands to the maximum amount of needed space; fix comment.
Pointed out by Frank Schoep, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.55 2016/05/22 19:19:21 jung Exp $	*/
a18 1
#include <sys/param.h>	/* nitems */
@


1.55
log
@fix unbalanced va_start and va_end macros

from Hiltjo Posthuma

"do." deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.54 2016/02/02 17:51:11 sthen Exp $	*/
d747 1
a747 1
	/* We need 5 times the memory if every letter is "<" or ">". */
@


1.54
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.53 2015/12/03 11:46:25 reyk Exp $	*/
d1003 1
d1006 3
a1008 1
	if (vasprintf(&value, fmt, ap) == -1)
a1009 1
	va_end(ap);
d1030 1
d1033 3
a1035 1
	if (vasprintf(&key, fmt, ap) == -1)
a1036 1
	va_end(ap);
@


1.53
log
@Remove unnecessary NULL checks before free().

From Jan Schreiber
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.52 2015/12/03 07:01:29 deraadt Exp $	*/
a249 2

	setproctitle("parent");
@


1.52
log
@the grammar can prompt DNS lookups, so pledge "dns" also.
from Gregor Best, discussed with florian
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.51 2015/12/02 15:13:00 reyk Exp $	*/
d1200 2
a1201 2
	if (media->media_encoding != NULL)
		free(media->media_encoding);
@


1.51
log
@sync with relayd, use proc_compose()
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.50 2015/11/23 20:56:14 reyk Exp $	*/
d254 1
a254 1
	if (pledge("stdio rpath wpath cpath inet proc ioctl sendfd",
@


1.50
log
@Retire socket_set_blockmode() in favor of the SOCK_NONBLOCK type flag.
As done in iked and snmpd.

OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.49 2015/11/22 13:27:13 reyk Exp $	*/
d342 1
a342 2
		proc_compose_imsg(env->sc_ps, id, -1, IMSG_CFG_DONE, -1,
		    &cf, sizeof(cf));
d387 1
a387 2
	proc_compose_imsg(env->sc_ps, PROC_LOGGER, -1, IMSG_CTL_REOPEN,
	    -1, NULL, 0);
d406 1
a406 2
			proc_compose_imsg(env->sc_ps, id, -1, IMSG_CTL_START,
			    -1, NULL, 0);
@


1.49
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.48 2015/11/21 12:40:59 reyk Exp $	*/
d966 1
a966 1
	if ((ret = accept(sockfd, addr, addrlen)) > -1) {
@


1.48
log
@Move local logging functions into httpd.c, and sync log.c with relayd -
both daemons are now sharing the same file.  No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.47 2015/11/19 21:32:53 mmcc Exp $	*/
d41 1
d194 2
a195 1
	log_init(debug ? debug : 1);	/* log to stderr until daemonized */
d224 1
a224 1
	log_init(debug);
d252 1
@


1.47
log
@Simplify all instances of get_string() and get_data() using malloc() and
strndup().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.46 2015/11/05 18:00:43 florian Exp $	*/
d36 1
d1299 75
@


1.46
log
@pledge(2) for httpd.

1) The main process listens on sockets and accepts connections. It
creates and opens log files, creates and kills child processes. On
start up and on receiving a HUP signal it parses the configuration. It
passes on file descriptors for logging or requests to it's children.
2) The logger process writes log messages to a file descriptor passed
in from the main process.
3) The server process reads the request from a file descriptor passed
in from the main process. It reads a file or creates a directory index
to send a response.
Additionally this process handles fastcgi requests. It connects to
AF_UNIX, AF_INET or AF_INET6 sockets. A re-factoring might make it
possible to drop the additional fastcgi privileges when only static
files are served.

with deraadt@@ some time ago
prodding & OK deraadt@@
tweaks and OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.45 2015/10/31 10:10:44 jung Exp $	*/
a833 1
	char	*str;
d840 1
a840 5
	if ((str = calloc(1, i + 1)) == NULL)
		return (NULL);
	memcpy(str, ptr, i);

	return (str);
d848 1
a848 1
	if ((data = calloc(1, len)) == NULL)
@


1.45
log
@revert -r1.42 as it breaks slowcgi and php-fpm setups as reported by jturner
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.44 2015/10/28 15:50:04 mmcc Exp $	*/
d249 4
@


1.44
log
@Remove a few more NULL-checks before free.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.43 2015/10/28 15:45:51 mmcc Exp $	*/
d698 1
a698 1
		if (p <= end && *p != '/')
@


1.43
log
@While I'm in here, drop a NULL-check before free.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.42 2015/10/26 11:03:29 jung Exp $	*/
d1019 1
a1019 2
	if (kv->kv_value != NULL)
		free(kv->kv_value);
d1036 1
a1036 2
	if (kv->kv_key != NULL)
		free(kv->kv_key);
d1091 1
a1091 3
	if (kv->kv_key != NULL) {
		free(kv->kv_key);
	}
d1093 1
a1093 3
	if (kv->kv_value != NULL) {
		free(kv->kv_value);
	}
@


1.42
log
@fix PATH_INFO for / requests

diff from Denis Fondras

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.41 2015/10/14 08:02:38 reyk Exp $	*/
d457 1
a457 2
		if (str != NULL)
			free(str);
@


1.41
log
@Two more char -> unsigned char in ctype functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.40 2015/10/13 07:57:13 reyk Exp $	*/
d699 1
a699 1
		if (p < end && *p != '/')
@


1.40
log
@Pass unsigned chars to ctype functions.

From Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.39 2015/08/20 13:00:23 reyk Exp $	*/
d834 2
a835 1
		if (!(isprint(ptr[i]) || isspace(ptr[i])))
@


1.39
log
@Change httpd(8) to use C99-style fixed-width integers (uintN_t instead
of u_intN_t) and replace u_int with unsigned int.  Mixing both
variants is a bad style and most contributors seem to prefer this
style; it also helps us to get used to it, portability, and
standardization.

Theoretically no binary change, except one in practice: httpd.o has a
different checksum because gcc with -O2 pads/optimizes "struct
privsep" differently when using "unsigned int" instead "u_int" for the
affected members.  "u_int" is just a typedef of "unsigned int", -O0
doesn't build the difference and clang with -O2 doesn't do it either -
it is just another curiosity from gcc-land.

OK semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.38 2015/07/18 06:00:43 reyk Exp $	*/
d568 1
a568 1
		c = tolower(host[i]);
d605 2
a606 1
			if (!(isxdigit(p[1]) && isxdigit(p[2])))
@


1.38
log
@Allow to change the default media type globally or per-location,
eg. default type text/html.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.37 2015/06/03 02:24:36 millert Exp $	*/
d52 1
a52 1
void		 parent_reload(struct httpd *, u_int, const char *);
d161 1
a161 1
	u_int32_t		 opts = 0;
d345 1
a345 1
parent_reload(struct httpd *env, u_int reset, const char *filename)
d444 1
a444 1
	u_int			 v;
d594 3
a596 3
	char	*p, *q;
	char	 hex[3];
	u_long	 x;
d795 1
a795 1
	u_int8_t	*ptr = EVBUFFER_DATA(evb);
d827 1
a827 1
get_string(u_int8_t *ptr, size_t len)
d844 1
a844 1
get_data(u_int8_t *ptr, size_t len)
d846 1
a846 1
	u_int8_t	*data;
d860 1
a860 1
	u_int32_t		 av[4], bv[4], mv[4];
d918 2
a919 2
u_int32_t
prefixlen2mask(u_int8_t prefixlen)
d931 1
a931 1
prefixlen2mask6(u_int8_t prefixlen, u_int32_t *mask)
d1288 1
a1288 1
auth_byid(struct serverauth *serverauth, u_int32_t id)
@


1.37
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.36 2015/05/28 17:08:09 florian Exp $	*/
d1220 1
a1220 1
media_find(struct mediatypes *types, char *file)
d1242 15
@


1.36
log
@Do not try to unlink the control socket in an unprivileged child
process on shutdown.
Found while working on tame(2).
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.35 2015/02/23 18:43:18 reyk Exp $	*/
d83 2
d92 1
a92 1
				asprintf(&cause, "terminated; signal %d",
d97 2
a98 1
					asprintf(&cause, "exited abnormally");
d100 1
a100 1
					asprintf(&cause, "exited okay");
d103 3
@


1.35
log
@Allow to specify CGI variables as macros in redirection strings, eg.
block return 301 "http://www.example.com/$REQUEST_URI"

OK tedu@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.34 2015/02/12 10:05:29 reyk Exp $	*/
d213 1
a213 1
	ps->ps_csock.cs_name = HTTPD_SOCKET;
d407 2
@


1.34
log
@Rename escape_uri() to url_encode() because it is the opposite of
url_decode().  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.33 2015/02/10 08:12:29 florian Exp $	*/
d495 33
@


1.33
log
@Encode directory listings.
Problem pointed out by remco AT d-compu.dyndns.org some time ago.
Input / OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.32 2015/02/08 00:00:59 reyk Exp $	*/
d674 2
a675 2
char*
escape_uri(const char *src)
d683 1
a683 1
		return NULL;
@


1.32
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.31 2015/01/21 22:21:05 reyk Exp $	*/
d672 56
@


1.31
log
@httpd is based on relayd and had included many headers that are only
needed by its ancestor.  jsg@@, include-what-you-use, and some manual
review helped to cleanup the headers (take iwyu with a grain of salt).
Based on common practice, httpd.h now also includes the necessary
headers for itself.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.30 2015/01/19 19:37:50 reyk Exp $	*/
d587 1
a587 1
	return(url);
@


1.30
log
@Decouple auth parameters from struct server_config into struct auth.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.29 2015/01/16 06:40:17 deraadt Exp $	*/
a25 1
#include <sys/signal.h>
a26 1
#include <net/if.h>
a29 1
#include <string.h>
d32 3
a34 1
#include <fcntl.h>
@


1.29
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.28 2014/12/11 17:06:55 schwarze Exp $	*/
d293 1
d300 5
d1155 39
@


1.28
log
@When scanning backwards for the last dot in a filename,
stop at the '/' marking the beginning of the filename.
This allows to configure a Content-Type for a filename without a dot.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.27 2014/12/04 02:44:42 tedu Exp $	*/
d19 1
d26 1
d47 2
d685 1
a685 1
		rl.rlim_cur = MAX(rl.rlim_max, (rlim_t)maxfd);
@


1.27
log
@stop viral header propagation. none of this code uses sys/hash.h
from Max Fillinger
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.26 2014/11/22 00:24:22 tedu Exp $	*/
d1119 5
a1123 3
	if ((p = strrchr(file, '.')) == NULL) {
		p = file;
	} else if (*p++ == '\0') {
d1125 1
a1125 1
	}
@


1.26
log
@use size_t where appropriate. ok deraadt reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.25 2014/11/21 17:49:10 deraadt Exp $	*/
a24 1
#include <sys/hash.h>
a41 2
#include <sha1.h>
#include <md5.h>
@


1.25
log
@white space begone
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.24 2014/11/11 15:54:45 beck Exp $	*/
d496 1
a496 1
	u_int			 i, j;
d695 1
a695 1
	u_int		 i;
@


1.24
log
@Allow the log directory to be configurable in the config file, rather than
fixed as /logs within the chroot.  As this httpd is properly privesp'ed this
has the nice property of allowing us to put the logs outside the chroot if
we want to.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.23 2014/10/22 09:48:03 reyk Exp $	*/
d568 1
a568 1
			x = strtoul(hex, NULL, 16);		
@


1.23
log
@URL-decode the request path.

Tested by ajacoutot@@ and others
OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.22 2014/09/29 19:30:47 deraadt Exp $	*/
d233 6
@


1.22
log
@whitespace spotted while studying the code
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.21 2014/09/05 10:04:20 reyk Exp $	*/
d536 40
@


1.21
log
@Remove a limitation that only allowed to specify a server name once.
The key has been changed to server name + address + port and now it is
possible to use the same server name for multiple servers with
different addresses, eg. http://www.example.com and
https://www.example.com/.

OK doug@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.20 2014/09/01 09:32:43 reyk Exp $	*/
d664 1
a664 1
	
@


1.20
log
@Replace the code to get the FastCGI Status header with a proper way to
parse and write the headers using the http response descriptor.  This
allows to add other tweaks, like support for chunked encoding, later.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.19 2014/08/13 16:04:28 reyk Exp $	*/
d292 1
d294 2
d298 7
@


1.19
log
@Provide a failsafe version of the path_info() function that doesn't
need a temporary path variable.  Based on an initial diff from
chrisz@@.

"Commit any failsafe version and I'm ok with it" chrisz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.18 2014/08/13 08:08:55 chrisz Exp $	*/
d631 34
@


1.18
log
@fix early loop termination in httpd path_info()
without this fix httpd always put at least the first
path component in SCRIPT_NAME even when it did not exist.
Now for completely non-existant paths everything goes into
PATH_INFO.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.17 2014/08/05 15:36:59 reyk Exp $	*/
d583 2
a584 2
ssize_t
path_info(char *name)
d586 1
a586 2
	char		*p, *start, *end;
	char		 path[MAXPATHLEN];
d588 1
a588 3

	if (strlcpy(path, name, sizeof(path)) >= sizeof(path))
		return (-1);
d593 3
a595 2
	for (p = end; p >= start; p--) {
		if (*p != '/')
d597 9
a605 1
		if (stat(path, &st) == 0)
a606 1
		*p = '\0';
d609 1
a609 1
	return (strlen(path));
@


1.17
log
@Improve logging to allow per- server/location log files.  The log
files can also be owned by root now: they're opened by the parent and
send to the logger process with fd passing.  This also works with reload.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.16 2014/08/05 09:24:21 jsg Exp $	*/
d596 1
a596 1
	for (p = end; p > start; p--) {
@


1.17.4.1
log
@httpd was developed very rapidly in the weeks before 5.6 release,
and it has a few flaws.  It would be nice to get these flaws fully
remediated before the next release, and that requires the community
to want to use it.
Therefore here is a "jumbo" patch that brings in the most important fixes.

committing on behalf of reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.17 2014/08/05 15:36:59 reyk Exp $	*/
a291 1
	/* First send the servers... */
a292 2
		if (srv->srv_conf.flags & SRVFLAG_LOCATION)
			continue;
a295 7
	/* ...and now send the locations */
	TAILQ_FOREACH(srv, env->sc_servers, srv_entry) {
		if ((srv->srv_conf.flags & SRVFLAG_LOCATION) == 0)
			continue;
		if (config_setserver(env, srv) == -1)
			fatal("send location");
	}
a528 40
url_decode(char *url)
{
	char	*p, *q;
	char	 hex[3];
	u_long	 x;

	hex[2] = '\0';
	p = q = url;

	while (*p != '\0') {
		switch (*p) {
		case '%':
			/* Encoding character is followed by two hex chars */
			if (!(isxdigit(p[1]) && isxdigit(p[2])))
				return (NULL);

			hex[0] = p[1];
			hex[1] = p[2];

			/*
			 * We don't have to validate "hex" because it is
			 * guaranteed to include two hex chars followed by nul.
			 */
			x = strtoul(hex, NULL, 16);		
			*q = (char)x;
			p += 2;
			break;
		default:
			*q = *p;
			break;
		}
		p++;
		q++;
	}
	*q = '\0';

	return(url);
}

const char *
d583 2
a584 2
size_t
path_info(char *path)
d586 2
a587 1
	char		*p, *start, *end, ch;
d589 3
a591 1
	int		 ret;
d597 1
a597 2
		/* Scan every path component from the end and at each '/' */
		if (p < end && *p != '/')
d599 2
a600 3

		/* Temporarily cut the path component out */
		ch = *p;
a601 6
		ret = stat(path, &st);
		*p = ch;

		/* Break if the initial path component was found */
		if (ret == 0)
			break;
d604 1
a604 1
	return (p - start);
a625 34
}

char *
evbuffer_getline(struct evbuffer *evb)
{
	u_int8_t	*ptr = EVBUFFER_DATA(evb);
	size_t		 len = EVBUFFER_LENGTH(evb);
	char		*str;
	u_int		 i;

	/* Safe version of evbuffer_readline() */
	if ((str = get_string(ptr, len)) == NULL)
		return (NULL);

	for (i = 0; str[i] != '\0'; i++) {
		if (str[i] == '\r' || str[i] == '\n')
			break;
	}

	if (i == len) {
		free(str);
		return (NULL);
	}

	str[i] = '\0';

	if ((i + 1) < len) {
		if (ptr[i] == '\r' && ptr[i + 1] == '\n')
			i++;
	}

	evbuffer_drain(evb, ++i);

	return (str);
@


1.16
log
@add a config option to specify the chroot directory
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.15 2014/08/04 15:49:28 reyk Exp $	*/
d229 2
d438 4
@


1.15
log
@Add initial support for log files in /var/www/logs/.  Logging with
syslog is still supported but disabled by default.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.14 2014/08/04 14:49:24 reyk Exp $	*/
d153 1
d228 3
@


1.14
log
@Implement PATH_INFO and add DOCUMENT_ROOT.
PATH_INFO was requested by naddy@@ who successfully tested it with "cvsweb".

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.13 2014/08/04 11:09:25 reyk Exp $	*/
d53 1
d58 2
d64 2
a65 1
	{ "server",	PROC_SERVER, parent_dispatch_server, server }
d129 5
d239 1
d246 1
d292 1
a292 1
	env->sc_reload = env->sc_prefork_server;
d344 7
d394 36
@


1.13
log
@httpd doesn't support SSL/TLS yet, remove the remaining bits.
The secrect plan is to add it later using the ressl wrapper library.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.12 2014/08/02 09:54:13 reyk Exp $	*/
d22 1
d517 24
@


1.12
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.11 2014/08/01 21:59:56 reyk Exp $	*/
a43 2

#include <openssl/ssl.h>
@


1.11
log
@remove the global "log updates/all" option that came from relayd.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.10 2014/07/26 09:59:14 reyk Exp $	*/
d493 1
a493 1
			} else if (i[1] == '.' && i[2] == '.' && 
@


1.10
log
@bzero is over, memset is cool.  pointed out by halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.9 2014/07/25 21:29:58 reyk Exp $	*/
a195 3

	if (debug)
		env->sc_opts |= HTTPD_OPT_LOGUPDATE;
@


1.9
log
@Canonicalize the request path once without the docroot and prepend the
docroot only only when it's needed.  Suggested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.8 2014/07/25 16:23:19 reyk Exp $	*/
d657 1
a657 1
	bzero(&s6, sizeof(s6));
@


1.8
log
@Add support for "virtual hosts" aka. server blocks aka. multiple
servers with the same or "overlapping" IP address but a different name.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.7 2014/07/24 08:32:36 reyk Exp $	*/
d469 1
a469 1
canonicalize_path(const char *root, const char *input, char *path, size_t len)
a472 1
	size_t		 n;
a476 8

	/* prepend root directory, if specified */
	if (root != NULL) {
		if ((n = strlcpy(path, root, len)) >= len)
			return (NULL);
		len -= n;
		p += n;
	}
@


1.7
log
@Plug a memleak by correctly free'ing the HTTP descriptor that contains
all the headers etc. of a connection.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.6 2014/07/23 23:10:27 reyk Exp $	*/
d580 96
@


1.6
log
@When canonicalizing the path, it is better to fail on truncation.

Pointed out by Doug Hogan.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.5 2014/07/23 22:56:00 reyk Exp $	*/
a722 2
	if (kv->kv_type == KEY_TYPE_NONE)
		return;
@


1.5
log
@I wanted to know if people pay attention.

Doug Hogan found an off-by-one.  More improvements will follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.4 2014/07/23 22:02:02 reyk Exp $	*/
d493 5
a497 1
	while (*i != '\0' && p < end) {
@


1.4
log
@The media_encoding is not used in parse.y but stack garbage could lead
to a double free; set it to NULL.

This should fix a problem that was found by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.3 2014/07/23 19:03:56 reyk Exp $	*/
d493 1
a493 4
	/* Set path pointer and make sure that we start with '/' */
	*p = '\0';

	while (*i != '\0' && p <= end) {
@


1.3
log
@Add canonicalize_path() to canonicalize the requested URL path.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.2 2014/07/13 14:17:37 reyk Exp $	*/
d823 5
@


1.2
log
@Add support for media types (aka. MIME types): the types section is
compatible to nginx' mime.types file which can be included directly.
If not present, use a few built-in defaults for html, css, txt, jpeg,
gif, png, and js.
@
text
@d1 1
a1 1
/*	$OpenBSD: httpd.c,v 1.1 2014/07/12 23:34:54 reyk Exp $	*/
d466 63
@


1.1
log
@Add httpd(8), an attempt to turn the relayd(8) codebase into a simple
web server.  It is not finished yet and I just started it today, but
the goal is to provide an HTTP server that a) provides minimal
features, b) serves static files, c) provides FastCGI support, and d)
follows common coding practices of OpenBSD.

It will neither support plugins, nor custom memory allocators, EBCDIC
support, PCRE or any other things that can be found elsewhere.
httpd(8) is not intended to provide a fully-featured replacement for
nginx(8) or the Apache, but it will provide enough functionality that
is needed in the OpenBSD base system.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d272 6
d281 1
a281 1
			fatal("create server");
d299 1
a299 1
	config_purge(env, CONFIG_ALL & ~CONFIG_SERVERS);
d744 69
@

