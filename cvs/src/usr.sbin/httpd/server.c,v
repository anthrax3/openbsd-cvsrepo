head	1.111;
access;
symbols
	OPENBSD_6_2:1.111.0.4
	OPENBSD_6_2_BASE:1.111
	OPENBSD_6_1:1.108.0.4
	OPENBSD_6_1_BASE:1.108
	OPENBSD_6_0:1.85.0.2
	OPENBSD_6_0_BASE:1.85
	OPENBSD_5_9:1.83.0.2
	OPENBSD_5_9_BASE:1.83
	OPENBSD_5_8:1.74.0.4
	OPENBSD_5_8_BASE:1.74
	OPENBSD_5_7:1.60.0.2
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.39.0.2
	OPENBSD_5_6_BASE:1.39;
locks; strict;
comment	@ * @;


1.111
date	2017.08.11.18.48.56;	author jsing;	state Exp;
branches;
next	1.110;
commitid	RqXM9HKDTTdTxuJj;

1.110
date	2017.07.19.17.36.25;	author jsing;	state Exp;
branches;
next	1.109;
commitid	iwgcHXMRTsRFF08F;

1.109
date	2017.04.17.21.58.27;	author deraadt;	state Exp;
branches;
next	1.108;
commitid	SXNMqgpfWp4td1q1;

1.108
date	2017.03.25.17.25.34;	author claudio;	state Exp;
branches;
next	1.107;
commitid	43NsM2S8LTb1McoD;

1.107
date	2017.02.07.12.27.42;	author reyk;	state Exp;
branches;
next	1.106;
commitid	39LWvR7k2X9Ou0Vd;

1.106
date	2017.02.02.22.19.59;	author reyk;	state Exp;
branches;
next	1.105;
commitid	wAyoqiU7jG1NUkqx;

1.105
date	2017.01.31.20.08.13;	author beck;	state Exp;
branches;
next	1.104;
commitid	jy23J2tcjBk6tmpM;

1.104
date	2017.01.31.17.25.05;	author beck;	state Exp;
branches;
next	1.103;
commitid	5i64f70pNYe9lAFL;

1.103
date	2017.01.31.16.18.57;	author beck;	state Exp;
branches;
next	1.102;
commitid	xEmNr0q3vZFvI7yp;

1.102
date	2017.01.31.12.20.05;	author reyk;	state Exp;
branches;
next	1.101;
commitid	XR1cvuA4hTrraqr8;

1.101
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.100;
commitid	eA8b246voAapPTkX;

1.100
date	2016.11.17.14.58.37;	author jsing;	state Exp;
branches;
next	1.99;
commitid	qe3C1kKli1l0Rwr7;

1.99
date	2016.11.17.14.52.48;	author jsing;	state Exp;
branches;
next	1.98;
commitid	9adJPMuYYFWkfsUD;

1.98
date	2016.11.10.13.21.58;	author jca;	state Exp;
branches;
next	1.97;
commitid	bzuS4pGsUAgOV3uT;

1.97
date	2016.11.06.16.05.02;	author beck;	state Exp;
branches;
next	1.96;
commitid	QEpVHlshRZb972xs;

1.96
date	2016.11.06.10.49.38;	author beck;	state Exp;
branches;
next	1.95;
commitid	49Xfy4fsPamn6Ga1;

1.95
date	2016.08.30.14.31.53;	author rzalamena;	state Exp;
branches;
next	1.94;
commitid	aFS6ntUbudjiLont;

1.94
date	2016.08.27.11.13.16;	author rzalamena;	state Exp;
branches;
next	1.93;
commitid	9y7IlhMzSGJO9BSx;

1.93
date	2016.08.26.10.46.39;	author rzalamena;	state Exp;
branches;
next	1.92;
commitid	JNQbvPaxb6nMCsuY;

1.92
date	2016.08.22.15.02.18;	author jsing;	state Exp;
branches;
next	1.91;
commitid	kgucYc6Cn9YK2ZhC;

1.91
date	2016.08.16.18.41.57;	author tedu;	state Exp;
branches;
next	1.90;
commitid	eyeRGwF24702KeRh;

1.90
date	2016.08.16.17.10.01;	author reyk;	state Exp;
branches;
next	1.89;
commitid	94SinSEjLSXhUcpn;

1.89
date	2016.08.16.08.36.29;	author reyk;	state Exp;
branches;
next	1.88;
commitid	bkTfSe8iTcjatukt;

1.88
date	2016.08.15.16.12.34;	author jsing;	state Exp;
branches;
next	1.87;
commitid	ywDK1QHdQbsHLFgT;

1.87
date	2016.08.15.14.14.55;	author jsing;	state Exp;
branches;
next	1.86;
commitid	jAoX4Twb1LLio9hZ;

1.86
date	2016.08.15.13.48.24;	author jsing;	state Exp;
branches;
next	1.85;
commitid	el084N3wYoLArEkM;

1.85
date	2016.04.28.17.18.06;	author jsing;	state Exp;
branches;
next	1.84;
commitid	2tTZ0tt4IvPM3yPX;

1.84
date	2016.04.19.16.22.34;	author jsing;	state Exp;
branches;
next	1.83;
commitid	GLYc9hTIRv97nyFb;

1.83
date	2015.12.02.15.13.00;	author reyk;	state Exp;
branches;
next	1.82;
commitid	VcVtArSBXuXwQYz0;

1.82
date	2015.11.23.20.56.14;	author reyk;	state Exp;
branches;
next	1.81;
commitid	V1t7bAFyH2Xn6Kqj;

1.81
date	2015.11.05.18.00.43;	author florian;	state Exp;
branches;
next	1.80;
commitid	b2ejv9chtKlQ0St8;

1.80
date	2015.09.11.13.21.09;	author jsing;	state Exp;
branches;
next	1.79;
commitid	mhccJWq4pv69uAMV;

1.79
date	2015.09.10.13.53.13;	author beck;	state Exp;
branches;
next	1.78;
commitid	VgSt9YiVCvOSBoiV;

1.78
date	2015.09.10.10.42.40;	author beck;	state Exp;
branches;
next	1.77;
commitid	VAT9OcVfc8kr9jjr;

1.77
date	2015.09.10.10.15.46;	author jsing;	state Exp;
branches;
next	1.76;
commitid	Ojpt1S15ActmNxzg;

1.76
date	2015.09.07.14.46.24;	author reyk;	state Exp;
branches;
next	1.75;
commitid	3N8ZbJM1mbV6AuOV;

1.75
date	2015.08.20.13.00.23;	author reyk;	state Exp;
branches;
next	1.74;
commitid	WDQybNKi4LiEFw8K;

1.74
date	2015.08.03.11.45.17;	author florian;	state Exp;
branches;
next	1.73;
commitid	R0hlkHQJt4QQvq7o;

1.73
date	2015.07.29.22.03.41;	author reyk;	state Exp;
branches;
next	1.72;
commitid	rol6YjSk5cC38ac4;

1.72
date	2015.07.29.20.03.14;	author florian;	state Exp;
branches;
next	1.71;
commitid	UvkQRTHkUu4OhiEw;

1.71
date	2015.07.18.22.19.50;	author reyk;	state Exp;
branches;
next	1.70;
commitid	g5sVLwTWWtLsXmAh;

1.70
date	2015.07.16.16.29.25;	author florian;	state Exp;
branches;
next	1.69;
commitid	lZ8k3sH29eTMhooJ;

1.69
date	2015.07.15.23.16.38;	author reyk;	state Exp;
branches;
next	1.68;
commitid	RzY5FSK1wD1o0SL4;

1.68
date	2015.07.15.17.29.11;	author jsing;	state Exp;
branches;
next	1.67;
commitid	rAMqYyOLHg0RBj1X;

1.67
date	2015.07.15.17.11.14;	author jsing;	state Exp;
branches;
next	1.66;
commitid	izIlKkPLXjqkqxAA;

1.66
date	2015.07.15.16.00.39;	author jsing;	state Exp;
branches;
next	1.65;
commitid	fH3yCV9YOBuXQu46;

1.65
date	2015.07.15.14.49.42;	author jsing;	state Exp;
branches;
next	1.64;
commitid	RcxuELvRBND8Urpq;

1.64
date	2015.07.15.14.39.13;	author jsing;	state Exp;
branches;
next	1.63;
commitid	s4U3ZM538b4htSLh;

1.63
date	2015.04.23.16.59.28;	author florian;	state Exp;
branches;
next	1.62;
commitid	xJMypmVro7EYofLg;

1.62
date	2015.04.11.14.52.49;	author jsing;	state Exp;
branches;
next	1.61;
commitid	fd75nyz36psdYmck;

1.61
date	2015.03.15.22.08.45;	author florian;	state Exp;
branches;
next	1.60;
commitid	CdJAqROMMjgUOnXV;

1.60
date	2015.02.23.09.52.28;	author reyk;	state Exp;
branches
	1.60.2.1;
next	1.59;
commitid	B29u2pUBEvUKwwD1;

1.59
date	2015.02.12.04.40.23;	author jsing;	state Exp;
branches;
next	1.58;
commitid	4hspTe8KgQAkgFb0;

1.58
date	2015.02.12.04.23.17;	author jsing;	state Exp;
branches;
next	1.57;
commitid	YIftjrdQsRMjeEvV;

1.57
date	2015.02.07.23.56.02;	author reyk;	state Exp;
branches;
next	1.56;
commitid	XXpdSU1rkGa1nBd8;

1.56
date	2015.02.07.06.26.28;	author jsing;	state Exp;
branches;
next	1.55;
commitid	Jsq1AV9W6epuXQBP;

1.55
date	2015.02.07.01.23.12;	author reyk;	state Exp;
branches;
next	1.54;
commitid	tJajgOHQ1aZRGbKl;

1.54
date	2015.01.21.22.21.05;	author reyk;	state Exp;
branches;
next	1.53;
commitid	64Zc6bef54Vu2Noy;

1.53
date	2015.01.19.19.37.50;	author reyk;	state Exp;
branches;
next	1.52;
commitid	95e2Z6BqzOOfEsll;

1.52
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	Uu5nFG3wCl0LACBb;

1.51
date	2015.01.13.09.21.15;	author reyk;	state Exp;
branches;
next	1.50;
commitid	vlRoyiZgaC5QvCo7;

1.50
date	2015.01.06.14.07.48;	author reyk;	state Exp;
branches;
next	1.49;
commitid	hbuEM4rAFoNpF9Xp;

1.49
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.48;
commitid	XnjIOhurXdX5o1V9;

1.48
date	2014.12.12.14.45.59;	author reyk;	state Exp;
branches;
next	1.47;
commitid	j2F3LZ1OyONol7u9;

1.47
date	2014.12.04.02.44.42;	author tedu;	state Exp;
branches;
next	1.46;
commitid	A2H8wpKaas7ra1zW;

1.46
date	2014.10.31.13.49.52;	author jsing;	state Exp;
branches;
next	1.45;
commitid	ezNS1yQDKKs563EI;

1.45
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.44;
commitid	2uw1UTO4k6erpWzK;

1.44
date	2014.10.03.13.41.03;	author jsing;	state Exp;
branches;
next	1.43;
commitid	X12q3o7x2TkIHU8i;

1.43
date	2014.10.02.19.22.43;	author reyk;	state Exp;
branches;
next	1.42;
commitid	fE54qSJpQK0UmfPw;

1.42
date	2014.09.05.10.04.20;	author reyk;	state Exp;
branches;
next	1.41;
commitid	L018oMJIofTIKQBT;

1.41
date	2014.09.02.16.20.41;	author reyk;	state Exp;
branches;
next	1.40;
commitid	Z5PKhfXhMri1amPw;

1.40
date	2014.08.27.09.51.53;	author reyk;	state Exp;
branches;
next	1.39;
commitid	qtXok691Ni7DYKHX;

1.39
date	2014.08.06.18.38.11;	author reyk;	state Exp;
branches
	1.39.2.1;
next	1.38;
commitid	QwIkF9OyNOAMdals;

1.38
date	2014.08.06.16.10.02;	author jsing;	state Exp;
branches;
next	1.37;
commitid	TMTchhrgmfgO0N0S;

1.37
date	2014.08.06.16.09.02;	author jsing;	state Exp;
branches;
next	1.36;
commitid	CZdtcBfBkirUWTpH;

1.36
date	2014.08.06.15.08.04;	author florian;	state Exp;
branches;
next	1.35;
commitid	JiDxX0IDmc7NLOCZ;

1.35
date	2014.08.06.12.56.58;	author reyk;	state Exp;
branches;
next	1.34;
commitid	riXTx0iMqjDxBeF1;

1.34
date	2014.08.06.11.24.12;	author reyk;	state Exp;
branches;
next	1.33;
commitid	uOQWAqZrGtAeribj;

1.33
date	2014.08.06.09.40.04;	author reyk;	state Exp;
branches;
next	1.32;
commitid	Hl1pLhoWCAkXjky4;

1.32
date	2014.08.06.09.36.31;	author reyk;	state Exp;
branches;
next	1.31;
commitid	3LE5yBvWStUuSW90;

1.31
date	2014.08.06.04.39.50;	author jsg;	state Exp;
branches;
next	1.30;
commitid	0zHxFYFk1GxHKsXZ;

1.30
date	2014.08.06.02.04.42;	author jsing;	state Exp;
branches;
next	1.29;
commitid	Wq3y58SpTrH6PeRm;

1.29
date	2014.08.05.15.36.59;	author reyk;	state Exp;
branches;
next	1.28;
commitid	0eZ0KmX2vQuZV9Ts;

1.28
date	2014.08.04.18.12.15;	author reyk;	state Exp;
branches;
next	1.27;
commitid	x0mQG5OVVgk9h47j;

1.27
date	2014.08.04.17.38.12;	author reyk;	state Exp;
branches;
next	1.26;
commitid	QN0gng3yApfUkUG0;

1.26
date	2014.08.04.15.49.28;	author reyk;	state Exp;
branches;
next	1.25;
commitid	LDlAyIlUWDBjADa5;

1.25
date	2014.08.04.11.09.25;	author reyk;	state Exp;
branches;
next	1.24;
commitid	Dj6ALT3dpIHqBQcw;

1.24
date	2014.08.03.20.43.03;	author reyk;	state Exp;
branches;
next	1.23;
commitid	TtWvHWpY8PUl6hQO;

1.23
date	2014.08.03.10.26.44;	author reyk;	state Exp;
branches;
next	1.22;
commitid	J4iRjIQasNlCySVe;

1.22
date	2014.08.02.11.52.01;	author reyk;	state Exp;
branches;
next	1.21;
commitid	bdxHYKjcY9PJGrJu;

1.21
date	2014.08.01.22.24.05;	author reyk;	state Exp;
branches;
next	1.20;
commitid	GXr73HMBmpwnofsc;

1.20
date	2014.08.01.21.59.56;	author reyk;	state Exp;
branches;
next	1.19;
commitid	x6XXpbpENAdHhEQS;

1.19
date	2014.08.01.08.34.46;	author florian;	state Exp;
branches;
next	1.18;
commitid	SQpmoq716KYwsw94;

1.18
date	2014.07.31.14.25.14;	author reyk;	state Exp;
branches;
next	1.17;
commitid	QkmIVLoOhhCQIxFE;

1.17
date	2014.07.30.13.49.48;	author reyk;	state Exp;
branches;
next	1.16;
commitid	xXDeSGReD1XsNQaP;

1.16
date	2014.07.30.10.05.14;	author reyk;	state Exp;
branches;
next	1.15;
commitid	crg28r1097elBMcd;

1.15
date	2014.07.29.16.38.34;	author reyk;	state Exp;
branches;
next	1.14;
commitid	uPF64ecFCa3bHbkt;

1.14
date	2014.07.29.12.16.36;	author reyk;	state Exp;
branches;
next	1.13;
commitid	9PurumxX3SjNH6Pz;

1.13
date	2014.07.25.23.30.58;	author reyk;	state Exp;
branches;
next	1.12;
commitid	3E0HntdxEq94QrDK;

1.12
date	2014.07.25.23.23.39;	author reyk;	state Exp;
branches;
next	1.11;
commitid	ovF3df8kR0MciR0p;

1.11
date	2014.07.25.16.23.19;	author reyk;	state Exp;
branches;
next	1.10;
commitid	xxvqODaQzmLv14My;

1.10
date	2014.07.25.13.10.18;	author reyk;	state Exp;
branches;
next	1.9;
commitid	e2fiCfjHRfxIZTmx;

1.9
date	2014.07.25.12.46.23;	author reyk;	state Exp;
branches;
next	1.8;
commitid	nFELL2a0ZqVmRooJ;

1.8
date	2014.07.24.08.32.36;	author reyk;	state Exp;
branches;
next	1.7;
commitid	quJMC73DegnsF51x;

1.7
date	2014.07.23.13.26.39;	author reyk;	state Exp;
branches;
next	1.6;
commitid	zAAnmSLr14THdHMx;

1.6
date	2014.07.16.10.25.28;	author reyk;	state Exp;
branches;
next	1.5;
commitid	ogHdcewg1QccxeTT;

1.5
date	2014.07.14.00.19.48;	author reyk;	state Exp;
branches;
next	1.4;
commitid	PY8fkGzrfhDzml1J;

1.4
date	2014.07.13.15.07.50;	author reyk;	state Exp;
branches;
next	1.3;
commitid	g1b0NbSrZCfJqpHu;

1.3
date	2014.07.13.14.46.52;	author reyk;	state Exp;
branches;
next	1.2;
commitid	zoXak7G3t7o6K0h2;

1.2
date	2014.07.13.14.17.37;	author reyk;	state Exp;
branches;
next	1.1;
commitid	4gg9IcDTWDACYa56;

1.1
date	2014.07.12.23.34.54;	author reyk;	state Exp;
branches;
next	;
commitid	U5OqzWAgis3Sb3uE;

1.39.2.1
date	2014.11.20.07.48.45;	author jasper;	state Exp;
branches;
next	1.39.2.2;
commitid	aoUNgrdXQt2mQs98;

1.39.2.2
date	2015.04.30.22.19.15;	author sthen;	state Exp;
branches;
next	;
commitid	v5LRtUFo8PNXyb7L;

1.60.2.1
date	2015.04.30.22.18.41;	author sthen;	state Exp;
branches;
next	;
commitid	sP9Krk3Xw8e5fg23;


desc
@@


1.111
log
@Convert httpd to tls_config_set_ecdhecurves(), allowing a list of curves
to be specified, rather than a single curve.

ok beck@@
@
text
@/*	$OpenBSD: server.c,v 1.110 2017/07/19 17:36:25 jsing Exp $	*/

/*
 * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/tree.h>

#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <event.h>
#include <imsg.h>
#include <tls.h>
#include <vis.h>

#include "httpd.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

int		 server_dispatch_parent(int, struct privsep_proc *,
		    struct imsg *);
int		 server_dispatch_logger(int, struct privsep_proc *,
		    struct imsg *);
void		 server_shutdown(void);

void		 server_init(struct privsep *, struct privsep_proc *p, void *);
void		 server_launch(void);
int		 server_socket(struct sockaddr_storage *, in_port_t,
		    struct server_config *, int, int);
int		 server_socket_listen(struct sockaddr_storage *, in_port_t,
		    struct server_config *);
struct server	*server_byid(uint32_t);

int		 server_tls_init(struct server *);
void		 server_tls_readcb(int, short, void *);
void		 server_tls_writecb(int, short, void *);
void		 server_tls_handshake(int, short, void *);

void		 server_accept(int, short, void *);
void		 server_input(struct client *);
void		 server_inflight_dec(struct client *, const char *);

extern void	 bufferevent_read_pressure_cb(struct evbuffer *, size_t,
		    size_t, void *);

volatile int server_clients;
volatile int server_inflight = 0;
uint32_t server_cltid;

static struct privsep_proc procs[] = {
	{ "parent",	PROC_PARENT,	server_dispatch_parent },
	{ "logger",	PROC_LOGGER,	server_dispatch_logger }
};

void
server(struct privsep *ps, struct privsep_proc *p)
{
	proc_run(ps, p, procs, nitems(procs), server_init, NULL);
	server_http();
}

void
server_shutdown(void)
{
	config_purge(httpd_env, CONFIG_ALL);
	usleep(200);	/* XXX server needs to shutdown last */
}

int
server_privinit(struct server *srv)
{
	struct server	*s;

	if (srv->srv_conf.flags & SRVFLAG_LOCATION)
		return (0);

	log_debug("%s: adding server %s", __func__, srv->srv_conf.name);

	/*
	 * There's no need to open a new socket if a server with the
	 * same address already exists.
	 */
	TAILQ_FOREACH(s, httpd_env->sc_servers, srv_entry) {
		if (s != srv && s->srv_s != -1 &&
		    s->srv_conf.port == srv->srv_conf.port &&
		    sockaddr_cmp((struct sockaddr *)&s->srv_conf.ss,
		    (struct sockaddr *)&srv->srv_conf.ss,
		    s->srv_conf.prefixlen) == 0)
			return (0);
	}

	/* Open listening socket in the privileged process */
	if ((srv->srv_s = server_socket_listen(&srv->srv_conf.ss,
	    srv->srv_conf.port, &srv->srv_conf)) == -1)
		return (-1);

	return (0);
}

int
server_tls_cmp(struct server *s1, struct server *s2, int match_keypair)
{
	struct server_config	*sc1, *sc2;

	sc1 = &s1->srv_conf;
	sc2 = &s2->srv_conf;

	if (sc1->tls_protocols != sc2->tls_protocols)
		return (-1);
	if (sc1->tls_ticket_lifetime != sc2->tls_ticket_lifetime)
		return (-1);
	if (strcmp(sc1->tls_ciphers, sc2->tls_ciphers) != 0)
		return (-1);
	if (strcmp(sc1->tls_dhe_params, sc2->tls_dhe_params) != 0)
		return (-1);
	if (strcmp(sc1->tls_ecdhe_curves, sc2->tls_ecdhe_curves) != 0)
		return (-1);

	if (match_keypair) {
		if (strcmp(sc1->tls_cert_file, sc2->tls_cert_file) != 0)
			return (-1);
		if (strcmp(sc1->tls_key_file, sc2->tls_key_file) != 0)
			return (-1);
	}

	return (0);
}

int
server_tls_load_keypair(struct server *srv)
{
	if ((srv->srv_conf.flags & SRVFLAG_TLS) == 0)
		return (0);

	if ((srv->srv_conf.tls_cert = tls_load_file(srv->srv_conf.tls_cert_file,
	    &srv->srv_conf.tls_cert_len, NULL)) == NULL)
		return (-1);
	log_debug("%s: using certificate %s", __func__,
	    srv->srv_conf.tls_cert_file);

	/* XXX allow to specify password for encrypted key */
	if ((srv->srv_conf.tls_key = tls_load_file(srv->srv_conf.tls_key_file,
	    &srv->srv_conf.tls_key_len, NULL)) == NULL)
		return (-1);
	log_debug("%s: using private key %s", __func__,
	    srv->srv_conf.tls_key_file);

	return (0);
}

int
server_tls_load_ocsp(struct server *srv)
{
	if ((srv->srv_conf.flags & SRVFLAG_TLS) == 0)
		return (0);

	if (srv->srv_conf.tls_ocsp_staple_file == NULL)
		return (0);

	if ((srv->srv_conf.tls_ocsp_staple = tls_load_file(
	    srv->srv_conf.tls_ocsp_staple_file,
	    &srv->srv_conf.tls_ocsp_staple_len, NULL)) == NULL)
		return (-1);
	log_debug("%s: using ocsp staple from %s", __func__,
	    srv->srv_conf.tls_ocsp_staple_file);

	return (0);
}

int
server_tls_init(struct server *srv)
{
	struct server_config *srv_conf;

	if ((srv->srv_conf.flags & SRVFLAG_TLS) == 0)
		return (0);

	log_debug("%s: setting up tls for %s", __func__, srv->srv_conf.name);

	if (tls_init() != 0) {
		log_warnx("%s: failed to initialise tls", __func__);
		return (-1);
	}
	if ((srv->srv_tls_config = tls_config_new()) == NULL) {
		log_warnx("%s: failed to get tls config", __func__);
		return (-1);
	}
	if ((srv->srv_tls_ctx = tls_server()) == NULL) {
		log_warnx("%s: failed to get tls server", __func__);
		return (-1);
	}

	if (tls_config_set_protocols(srv->srv_tls_config,
	    srv->srv_conf.tls_protocols) != 0) {
		log_warnx("%s: failed to set tls protocols: %s",
		    __func__, tls_config_error(srv->srv_tls_config));
		return (-1);
	}
	if (tls_config_set_ciphers(srv->srv_tls_config,
	    srv->srv_conf.tls_ciphers) != 0) {
		log_warnx("%s: failed to set tls ciphers: %s",
		    __func__, tls_config_error(srv->srv_tls_config));
		return (-1);
	}
	if (tls_config_set_dheparams(srv->srv_tls_config,
	    srv->srv_conf.tls_dhe_params) != 0) {
		log_warnx("%s: failed to set tls dhe params: %s",
		    __func__, tls_config_error(srv->srv_tls_config));
		return (-1);
	}
	if (tls_config_set_ecdhecurves(srv->srv_tls_config,
	    srv->srv_conf.tls_ecdhe_curves) != 0) {
		log_warnx("%s: failed to set tls ecdhe curves: %s",
		    __func__, tls_config_error(srv->srv_tls_config));
		return (-1);
	}

	if (tls_config_set_keypair_ocsp_mem(srv->srv_tls_config,
	    srv->srv_conf.tls_cert, srv->srv_conf.tls_cert_len,
	    srv->srv_conf.tls_key, srv->srv_conf.tls_key_len,
	    srv->srv_conf.tls_ocsp_staple,
	    srv->srv_conf.tls_ocsp_staple_len) != 0) {
		log_warnx("%s: failed to set tls certificate/key: %s",
		    __func__, tls_config_error(srv->srv_tls_config));
		return (-1);
	}

	TAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {
		if (srv_conf->tls_cert == NULL || srv_conf->tls_key == NULL)
			continue;
		log_debug("%s: adding keypair for server %s", __func__,
		    srv->srv_conf.name);
		if (tls_config_add_keypair_ocsp_mem(srv->srv_tls_config,
		    srv_conf->tls_cert, srv_conf->tls_cert_len,
		    srv_conf->tls_key, srv_conf->tls_key_len,
		    srv_conf->tls_ocsp_staple,
		    srv_conf->tls_ocsp_staple_len) != 0) {
			log_warnx("%s: failed to add tls keypair", __func__);
			return (-1);
		}
	}

	/* set common session ID among all processes */
	if (tls_config_set_session_id(srv->srv_tls_config,
	    httpd_env->sc_tls_sid, sizeof(httpd_env->sc_tls_sid)) == -1) {
		log_warnx("%s: could not set the TLS session ID: %s",
		    __func__, tls_config_error(srv->srv_tls_config));
		return (-1);
	}

	/* ticket support */
	if (srv->srv_conf.tls_ticket_lifetime) {
		if (tls_config_set_session_lifetime(srv->srv_tls_config,
		    srv->srv_conf.tls_ticket_lifetime) == -1) {
			log_warnx("%s: could not set the TLS session lifetime: "
			    "%s", __func__,
			    tls_config_error(srv->srv_tls_config));
			return (-1);
		}
		tls_config_add_ticket_key(srv->srv_tls_config,
		    srv->srv_conf.tls_ticket_key.tt_keyrev,
		    srv->srv_conf.tls_ticket_key.tt_key,
		    sizeof(srv->srv_conf.tls_ticket_key.tt_key));
		explicit_bzero(&srv->srv_conf.tls_ticket_key,
		    sizeof(srv->srv_conf.tls_ticket_key));
	}

	if (tls_configure(srv->srv_tls_ctx, srv->srv_tls_config) != 0) {
		log_warnx("%s: failed to configure tls - %s", __func__,
		    tls_error(srv->srv_tls_ctx));
		return (-1);
	}

	/* We're now done with the public/private key... */
	tls_config_clear_keys(srv->srv_tls_config);
	freezero(srv->srv_conf.tls_cert, srv->srv_conf.tls_cert_len);
	freezero(srv->srv_conf.tls_key, srv->srv_conf.tls_key_len);
	srv->srv_conf.tls_cert = NULL;
	srv->srv_conf.tls_key = NULL;
	srv->srv_conf.tls_cert_len = 0;
	srv->srv_conf.tls_key_len = 0;

	return (0);
}

void
server_generate_ticket_key(struct server_config *srv_conf)
{
	struct server_tls_ticket *key = &srv_conf->tls_ticket_key;

	key->tt_id = srv_conf->id;
	key->tt_keyrev = arc4random();
	arc4random_buf(key->tt_key, sizeof(key->tt_key));
}

void
server_init(struct privsep *ps, struct privsep_proc *p, void *arg)
{
	server_http();

	if (config_init(ps->ps_env) == -1)
		fatal("failed to initialize configuration");

	/* We use a custom shutdown callback */
	p->p_shutdown = server_shutdown;

	/* Unlimited file descriptors (use system limits) */
	socket_rlimit(-1);

	if (pledge("stdio rpath inet unix recvfd", NULL) == -1)
		fatal("pledge");

#if 0
	/* Schedule statistics timer */
	evtimer_set(&ps->ps_env->sc_statev, server_statistics, NULL);
	memcpy(&tv, &ps->ps_env->sc_statinterval, sizeof(tv));
	evtimer_add(&ps->ps_env->sc_statev, &tv);
#endif
}

void
server_launch(void)
{
	struct server		*srv;

	TAILQ_FOREACH(srv, httpd_env->sc_servers, srv_entry) {
		log_debug("%s: configuring server %s", __func__,
		    srv->srv_conf.name);

		server_tls_init(srv);
		server_http_init(srv);

		log_debug("%s: running server %s", __func__,
		    srv->srv_conf.name);

		event_set(&srv->srv_ev, srv->srv_s, EV_READ,
		    server_accept, srv);
		event_add(&srv->srv_ev, NULL);
		evtimer_set(&srv->srv_evt, server_accept, srv);
	}
}

void
server_purge(struct server *srv)
{
	struct client		*clt;
	struct server_config	*srv_conf;

	/* shutdown and remove server */
	if (event_initialized(&srv->srv_ev))
		event_del(&srv->srv_ev);
	if (evtimer_initialized(&srv->srv_evt))
		evtimer_del(&srv->srv_evt);

	if (srv->srv_s != -1)
		close(srv->srv_s);
	TAILQ_REMOVE(httpd_env->sc_servers, srv, srv_entry);

	/* cleanup sessions */
	while ((clt =
	    SPLAY_ROOT(&srv->srv_clients)) != NULL)
		server_close(clt, NULL);

	/* cleanup hosts */
	while ((srv_conf =
	    TAILQ_FIRST(&srv->srv_hosts)) != NULL) {
		TAILQ_REMOVE(&srv->srv_hosts, srv_conf, entry);

		/* It might point to our own "default" entry */
		if (srv_conf != &srv->srv_conf) {
			serverconfig_free(srv_conf);
			free(srv_conf);
		}
	}

	tls_config_free(srv->srv_tls_config);
	tls_free(srv->srv_tls_ctx);

	free(srv);
}

void
serverconfig_free(struct server_config *srv_conf)
{
	free(srv_conf->return_uri);
	free(srv_conf->tls_cert_file);
	free(srv_conf->tls_key_file);
	free(srv_conf->tls_ocsp_staple_file);
	free(srv_conf->tls_ocsp_staple);
	freezero(srv_conf->tls_cert, srv_conf->tls_cert_len);
	freezero(srv_conf->tls_key, srv_conf->tls_key_len);
}

void
serverconfig_reset(struct server_config *srv_conf)
{
	srv_conf->auth = NULL;
	srv_conf->return_uri = NULL;
	srv_conf->tls_cert = NULL;
	srv_conf->tls_cert_file = NULL;
	srv_conf->tls_key = NULL;
	srv_conf->tls_key_file = NULL;
	srv_conf->tls_ocsp_staple = NULL;
	srv_conf->tls_ocsp_staple_file = NULL;
}

struct server *
server_byaddr(struct sockaddr *addr, in_port_t port)
{
	struct server	*srv;

	TAILQ_FOREACH(srv, httpd_env->sc_servers, srv_entry) {
		if (port == srv->srv_conf.port &&
		    sockaddr_cmp((struct sockaddr *)&srv->srv_conf.ss,
		    addr, srv->srv_conf.prefixlen) == 0)
			return (srv);
	}

	return (NULL);
}

struct server_config *
serverconfig_byid(uint32_t id)
{
	struct server		*srv;
	struct server_config	*srv_conf;

	TAILQ_FOREACH(srv, httpd_env->sc_servers, srv_entry) {
		if (srv->srv_conf.id == id)
			return (&srv->srv_conf);
		TAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {
			if (srv_conf->id == id)
				return (srv_conf);
		}
	}

	return (NULL);
}

struct server *
server_byid(uint32_t id)
{
	struct server	*srv;

	TAILQ_FOREACH(srv, httpd_env->sc_servers, srv_entry) {
		if (srv->srv_conf.id == id)
			return (srv);
	}
	return (NULL);
}

int
server_foreach(int (*srv_cb)(struct server *,
    struct server_config *, void *), void *arg)
{
	struct server		*srv;
	struct server_config	*srv_conf;

	TAILQ_FOREACH(srv, httpd_env->sc_servers, srv_entry) {
		if ((srv_cb)(srv, &srv->srv_conf, arg) == -1)
			return (-1);
		TAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {
			if ((srv_cb)(srv, srv_conf, arg) == -1)
				return (-1);
		}
	}

	return (0);
}

struct server *
server_match(struct server *s2, int match_name)
{
	struct server	*s1;

	/* Attempt to find matching server. */
	TAILQ_FOREACH(s1, httpd_env->sc_servers, srv_entry) {
		if ((s1->srv_conf.flags & SRVFLAG_LOCATION) != 0)
			continue;
		if (match_name) {
			if (strcmp(s1->srv_conf.name, s2->srv_conf.name) != 0)
				continue;
		}
		if (s1->srv_conf.port != s2->srv_conf.port)
			continue;
		if (sockaddr_cmp(
		    (struct sockaddr *)&s1->srv_conf.ss,
		    (struct sockaddr *)&s2->srv_conf.ss,
		    s1->srv_conf.prefixlen) != 0)
			continue;

		return (s1);
	}

	return (NULL);
}

int
server_socket_af(struct sockaddr_storage *ss, in_port_t port)
{
	switch (ss->ss_family) {
	case AF_INET:
		((struct sockaddr_in *)ss)->sin_port = port;
		((struct sockaddr_in *)ss)->sin_len =
		    sizeof(struct sockaddr_in);
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)ss)->sin6_port = port;
		((struct sockaddr_in6 *)ss)->sin6_len =
		    sizeof(struct sockaddr_in6);
		break;
	default:
		return (-1);
	}

	return (0);
}

in_port_t
server_socket_getport(struct sockaddr_storage *ss)
{
	switch (ss->ss_family) {
	case AF_INET:
		return (((struct sockaddr_in *)ss)->sin_port);
	case AF_INET6:
		return (((struct sockaddr_in6 *)ss)->sin6_port);
	default:
		return (0);
	}

	/* NOTREACHED */
	return (0);
}

int
server_socket(struct sockaddr_storage *ss, in_port_t port,
    struct server_config *srv_conf, int fd, int reuseport)
{
	struct linger	lng;
	int		s = -1, val;

	if (server_socket_af(ss, port) == -1)
		goto bad;

	s = fd == -1 ? socket(ss->ss_family, SOCK_STREAM | SOCK_NONBLOCK,
	    IPPROTO_TCP) : fd;
	if (s == -1)
		goto bad;

	/*
	 * Socket options
	 */
	memset(&lng, 0, sizeof(lng));
	if (setsockopt(s, SOL_SOCKET, SO_LINGER, &lng, sizeof(lng)) == -1)
		goto bad;
	if (reuseport) {
		val = 1;
		if (setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &val,
		    sizeof(int)) == -1)
			goto bad;
	}
	if (srv_conf->tcpflags & TCPFLAG_BUFSIZ) {
		val = srv_conf->tcpbufsiz;
		if (setsockopt(s, SOL_SOCKET, SO_RCVBUF,
		    &val, sizeof(val)) == -1)
			goto bad;
		val = srv_conf->tcpbufsiz;
		if (setsockopt(s, SOL_SOCKET, SO_SNDBUF,
		    &val, sizeof(val)) == -1)
			goto bad;
	}

	/*
	 * IP options
	 */
	if (srv_conf->tcpflags & TCPFLAG_IPTTL) {
		val = (int)srv_conf->tcpipttl;
		switch (ss->ss_family) {
		case AF_INET:
			if (setsockopt(s, IPPROTO_IP, IP_TTL,
			    &val, sizeof(val)) == -1)
				goto bad;
			break;
		case AF_INET6:
			if (setsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
			    &val, sizeof(val)) == -1)
				goto bad;
			break;
		}
	}
	if (srv_conf->tcpflags & TCPFLAG_IPMINTTL) {
		val = (int)srv_conf->tcpipminttl;
		switch (ss->ss_family) {
		case AF_INET:
			if (setsockopt(s, IPPROTO_IP, IP_MINTTL,
			    &val, sizeof(val)) == -1)
				goto bad;
			break;
		case AF_INET6:
			if (setsockopt(s, IPPROTO_IPV6, IPV6_MINHOPCOUNT,
			    &val, sizeof(val)) == -1)
				goto bad;
			break;
		}
	}

	/*
	 * TCP options
	 */
	if (srv_conf->tcpflags & (TCPFLAG_NODELAY|TCPFLAG_NNODELAY)) {
		if (srv_conf->tcpflags & TCPFLAG_NNODELAY)
			val = 0;
		else
			val = 1;
		if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY,
		    &val, sizeof(val)) == -1)
			goto bad;
	}
	if (srv_conf->tcpflags & (TCPFLAG_SACK|TCPFLAG_NSACK)) {
		if (srv_conf->tcpflags & TCPFLAG_NSACK)
			val = 0;
		else
			val = 1;
		if (setsockopt(s, IPPROTO_TCP, TCP_SACK_ENABLE,
		    &val, sizeof(val)) == -1)
			goto bad;
	}

	return (s);

 bad:
	if (s != -1)
		close(s);
	return (-1);
}

int
server_socket_listen(struct sockaddr_storage *ss, in_port_t port,
    struct server_config *srv_conf)
{
	int s;

	if ((s = server_socket(ss, port, srv_conf, -1, 1)) == -1)
		return (-1);

	if (bind(s, (struct sockaddr *)ss, ss->ss_len) == -1)
		goto bad;
	if (listen(s, srv_conf->tcpbacklog) == -1)
		goto bad;

	return (s);

 bad:
	close(s);
	return (-1);
}

int
server_socket_connect(struct sockaddr_storage *ss, in_port_t port,
    struct server_config *srv_conf)
{
	int	s;

	if ((s = server_socket(ss, port, srv_conf, -1, 0)) == -1)
		return (-1);

	if (connect(s, (struct sockaddr *)ss, ss->ss_len) == -1) {
		if (errno != EINPROGRESS)
			goto bad;
	}

	return (s);

 bad:
	close(s);
	return (-1);
}

void
server_tls_readcb(int fd, short event, void *arg)
{
	struct bufferevent	*bufev = arg;
	struct client		*clt = bufev->cbarg;
	char			 rbuf[IBUF_READ_SIZE];
	int			 what = EVBUFFER_READ;
	int			 howmuch = IBUF_READ_SIZE;
	ssize_t			 ret;
	size_t			 len;

	if (event == EV_TIMEOUT) {
		what |= EVBUFFER_TIMEOUT;
		goto err;
	}

	if (bufev->wm_read.high != 0)
		howmuch = MINIMUM(sizeof(rbuf), bufev->wm_read.high);

	ret = tls_read(clt->clt_tls_ctx, rbuf, howmuch);
	if (ret == TLS_WANT_POLLIN || ret == TLS_WANT_POLLOUT) {
		goto retry;
	} else if (ret < 0) {
		what |= EVBUFFER_ERROR;
		goto err;
	}
	len = ret;

	if (len == 0) {
		what |= EVBUFFER_EOF;
		goto err;
	}

	if (evbuffer_add(bufev->input, rbuf, len) == -1) {
		what |= EVBUFFER_ERROR;
		goto err;
	}

	server_bufferevent_add(&bufev->ev_read, bufev->timeout_read);

	len = EVBUFFER_LENGTH(bufev->input);
	if (bufev->wm_read.low != 0 && len < bufev->wm_read.low)
		return;
	if (bufev->wm_read.high != 0 && len > bufev->wm_read.high) {
		struct evbuffer *buf = bufev->input;
		event_del(&bufev->ev_read);
		evbuffer_setcb(buf, bufferevent_read_pressure_cb, bufev);
		return;
	}

	if (bufev->readcb != NULL)
		(*bufev->readcb)(bufev, bufev->cbarg);
	return;

 retry:
	server_bufferevent_add(&bufev->ev_read, bufev->timeout_read);
	return;

 err:
	(*bufev->errorcb)(bufev, what, bufev->cbarg);
}

void
server_tls_writecb(int fd, short event, void *arg)
{
	struct bufferevent	*bufev = arg;
	struct client		*clt = bufev->cbarg;
	ssize_t			 ret;
	short			 what = EVBUFFER_WRITE;
	size_t			 len;

	if (event == EV_TIMEOUT) {
		what |= EVBUFFER_TIMEOUT;
		goto err;
	}

	if (EVBUFFER_LENGTH(bufev->output)) {
		ret = tls_write(clt->clt_tls_ctx,
		    EVBUFFER_DATA(bufev->output),
		    EVBUFFER_LENGTH(bufev->output));
		if (ret == TLS_WANT_POLLIN || ret == TLS_WANT_POLLOUT) {
			goto retry;
		} else if (ret < 0) {
			what |= EVBUFFER_ERROR;
			goto err;
		}
		len = ret;
		evbuffer_drain(bufev->output, len);
	}

	if (EVBUFFER_LENGTH(bufev->output) != 0)
		server_bufferevent_add(&bufev->ev_write, bufev->timeout_write);

	if (bufev->writecb != NULL &&
	    EVBUFFER_LENGTH(bufev->output) <= bufev->wm_write.low)
		(*bufev->writecb)(bufev, bufev->cbarg);
	return;

 retry:
	server_bufferevent_add(&bufev->ev_write, bufev->timeout_write);
	return;

 err:
	(*bufev->errorcb)(bufev, what, bufev->cbarg);
}

void
server_input(struct client *clt)
{
	struct server_config	*srv_conf = clt->clt_srv_conf;
	evbuffercb		 inrd = server_read;
	evbuffercb		 inwr = server_write;
	socklen_t		 slen;

	if (server_httpdesc_init(clt) == -1) {
		server_close(clt, "failed to allocate http descriptor");
		return;
	}

	clt->clt_toread = TOREAD_HTTP_HEADER;
	inrd = server_read_http;

	slen = sizeof(clt->clt_sndbufsiz);
	if (getsockopt(clt->clt_s, SOL_SOCKET, SO_SNDBUF,
	    &clt->clt_sndbufsiz, &slen) == -1) {
		server_close(clt, "failed to get send buffer size");
		return;
	}

	/*
	 * Client <-> Server
	 */
	clt->clt_bev = bufferevent_new(clt->clt_s, inrd, inwr,
	    server_error, clt);
	if (clt->clt_bev == NULL) {
		server_close(clt, "failed to allocate input buffer event");
		return;
	}

	if (srv_conf->flags & SRVFLAG_TLS) {
		event_set(&clt->clt_bev->ev_read, clt->clt_s, EV_READ,
		    server_tls_readcb, clt->clt_bev);
		event_set(&clt->clt_bev->ev_write, clt->clt_s, EV_WRITE,
		    server_tls_writecb, clt->clt_bev);
	}

	/* Adjust write watermark to the socket buffer output size */
	bufferevent_setwatermark(clt->clt_bev, EV_WRITE,
	    SERVER_MIN_PREFETCHED * clt->clt_sndbufsiz, 0);
	/* Read at most amount of data that fits in one fcgi record. */
	bufferevent_setwatermark(clt->clt_bev, EV_READ, 0, FCGI_CONTENT_SIZE);

	bufferevent_settimeout(clt->clt_bev,
	    srv_conf->requesttimeout.tv_sec, srv_conf->requesttimeout.tv_sec);
	bufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);
}

void
server_write(struct bufferevent *bev, void *arg)
{
	struct client		*clt = arg;
	struct evbuffer		*dst = EVBUFFER_OUTPUT(bev);

	if (EVBUFFER_LENGTH(dst) == 0 &&
	    clt->clt_toread == TOREAD_HTTP_NONE)
		goto done;

	getmonotime(&clt->clt_tv_last);

	if (clt->clt_done)
		goto done;

	if (clt->clt_srvbev && clt->clt_srvbev_throttled) {
		bufferevent_enable(clt->clt_srvbev, EV_READ);
		clt->clt_srvbev_throttled = 0;
	}

	return;
 done:
	(*bev->errorcb)(bev, EVBUFFER_WRITE, bev->cbarg);
	return;
}

void
server_dump(struct client *clt, const void *buf, size_t len)
{
	if (!len)
		return;

	/*
	 * This function will dump the specified message directly
	 * to the underlying client, without waiting for success
	 * of non-blocking events etc. This is useful to print an
	 * error message before gracefully closing the client.
	 */
	if (clt->clt_tls_ctx != NULL)
		(void)tls_write(clt->clt_tls_ctx, buf, len);
	else
		(void)write(clt->clt_s, buf, len);
}

void
server_read(struct bufferevent *bev, void *arg)
{
	struct client		*clt = arg;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);

	getmonotime(&clt->clt_tv_last);

	if (!EVBUFFER_LENGTH(src))
		return;
	if (server_bufferevent_write_buffer(clt, src) == -1)
		goto fail;
	if (clt->clt_done)
		goto done;

	if (EVBUFFER_LENGTH(EVBUFFER_OUTPUT(clt->clt_bev)) > (size_t)
	    SERVER_MAX_PREFETCH * clt->clt_sndbufsiz) {
		bufferevent_disable(clt->clt_srvbev, EV_READ);
		clt->clt_srvbev_throttled = 1;
	}

	return;
 done:
	(*bev->errorcb)(bev, EVBUFFER_READ, bev->cbarg);
	return;
 fail:
	server_close(clt, strerror(errno));
}

void
server_error(struct bufferevent *bev, short error, void *arg)
{
	struct client		*clt = arg;
	struct evbuffer		*dst;

	if (error & EVBUFFER_TIMEOUT) {
		server_abort_http(clt, 408, "timeout");
		return;
	}
	if (error & EVBUFFER_ERROR) {
		if (errno == EFBIG) {
			bufferevent_enable(bev, EV_READ);
			return;
		}
		server_close(clt, "buffer event error");
		return;
	}
	if (error & EVBUFFER_EOF) {
		server_close(clt, "closed");
		return;
	}
	if (error & (EVBUFFER_READ|EVBUFFER_WRITE)) {
		bufferevent_disable(bev, EV_READ|EV_WRITE);

		clt->clt_done = 1;

		dst = EVBUFFER_OUTPUT(clt->clt_bev);
		if (EVBUFFER_LENGTH(dst)) {
			/* Finish writing all data first */
			bufferevent_enable(clt->clt_bev, EV_WRITE);
			return;
		}

		server_close(clt, "done");
		return;
	}
	server_close(clt, "unknown event error");
	return;
}

void
server_accept(int fd, short event, void *arg)
{
	struct server		*srv = arg;
	struct client		*clt = NULL;
	socklen_t		 slen;
	struct sockaddr_storage	 ss;
	int			 s = -1;

	event_add(&srv->srv_ev, NULL);
	if ((event & EV_TIMEOUT))
		return;

	slen = sizeof(ss);
	if ((s = accept_reserve(fd, (struct sockaddr *)&ss,
	    &slen, FD_RESERVE, &server_inflight)) == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			struct timeval evtpause = { 1, 0 };

			event_del(&srv->srv_ev);
			evtimer_add(&srv->srv_evt, &evtpause);
			log_debug("%s: deferring connections", __func__);
		}
		return;
	}
	if (server_clients >= SERVER_MAX_CLIENTS)
		goto err;

	if ((clt = calloc(1, sizeof(*clt))) == NULL)
		goto err;

	/* Pre-allocate log buffer */
	clt->clt_log = evbuffer_new();
	if (clt->clt_log == NULL)
		goto err;

	clt->clt_s = s;
	clt->clt_fd = -1;
	clt->clt_toread = TOREAD_UNLIMITED;
	clt->clt_srv = srv;
	clt->clt_srv_conf = &srv->srv_conf;
	clt->clt_id = ++server_cltid;
	clt->clt_srv_id = srv->srv_conf.id;
	clt->clt_pid = getpid();
	clt->clt_inflight = 1;

	/* get local address */
	slen = sizeof(clt->clt_srv_ss);
	if (getsockname(s, (struct sockaddr *)&clt->clt_srv_ss,
	    &slen) == -1) {
		server_close(clt, "listen address lookup failed");
		return;
	}

	/* get client address */
	memcpy(&clt->clt_ss, &ss, sizeof(clt->clt_ss));

	/* get ports */
	switch (ss.ss_family) {
	case AF_INET:
		clt->clt_port = ((struct sockaddr_in *)&ss)->sin_port;
		break;
	case AF_INET6:
		clt->clt_port = ((struct sockaddr_in6 *)&ss)->sin6_port;
		break;
	}

	getmonotime(&clt->clt_tv_start);
	memcpy(&clt->clt_tv_last, &clt->clt_tv_start, sizeof(clt->clt_tv_last));

	server_clients++;
	SPLAY_INSERT(client_tree, &srv->srv_clients, clt);

	/* Pre-allocate output buffer */
	clt->clt_output = evbuffer_new();
	if (clt->clt_output == NULL) {
		server_close(clt, "failed to allocate output buffer");
		return;
	}

	if (srv->srv_conf.flags & SRVFLAG_TLS) {
		if (tls_accept_socket(srv->srv_tls_ctx, &clt->clt_tls_ctx,
		    clt->clt_s) != 0) {
			server_close(clt, "failed to setup tls context");
			return;
		}
		event_again(&clt->clt_ev, clt->clt_s, EV_TIMEOUT|EV_READ,
		    server_tls_handshake, &clt->clt_tv_start,
		    &srv->srv_conf.timeout, clt);
		return;
	}

	server_input(clt);
	return;

 err:
	if (s != -1) {
		close(s);
		free(clt);
		/*
		 * the client struct was not completely set up, but still
		 * counted as an inflight client. account for this.
		 */
		server_inflight_dec(NULL, __func__);
	}
}

void
server_tls_handshake(int fd, short event, void *arg)
{
	struct client *clt = (struct client *)arg;
	struct server *srv = (struct server *)clt->clt_srv;
	int ret;

	if (event == EV_TIMEOUT) {
		server_close(clt, "tls handshake timeout");
		return;
	}

	if (srv->srv_tls_ctx == NULL || clt->clt_tls_ctx == NULL)
		fatalx("NULL tls context");

	ret = tls_handshake(clt->clt_tls_ctx);
	if (ret == 0) {
		server_input(clt);
	} else if (ret == TLS_WANT_POLLIN) {
		event_again(&clt->clt_ev, clt->clt_s, EV_TIMEOUT|EV_READ,
		    server_tls_handshake, &clt->clt_tv_start,
		    &srv->srv_conf.timeout, clt);
	} else if (ret == TLS_WANT_POLLOUT) {
		event_again(&clt->clt_ev, clt->clt_s, EV_TIMEOUT|EV_WRITE,
		    server_tls_handshake, &clt->clt_tv_start,
		    &srv->srv_conf.timeout, clt);
	} else {
		log_debug("%s: tls handshake failed - %s", __func__,
		    tls_error(clt->clt_tls_ctx));
		server_close(clt, "tls handshake failed");
	}
}

void
server_inflight_dec(struct client *clt, const char *why)
{
	if (clt != NULL) {
		/* the flight already left inflight mode. */
		if (clt->clt_inflight == 0)
			return;
		clt->clt_inflight = 0;
	}

	/* the file was never opened, thus this was an inflight client. */
	server_inflight--;
	DPRINTF("%s: inflight decremented, now %d, %s",
	    __func__, server_inflight, why);
}

void
server_sendlog(struct server_config *srv_conf, int cmd, const char *emsg, ...)
{
	va_list		 ap;
	char		*msg;
	int		 ret;
	struct iovec	 iov[2];

	if (srv_conf->flags & SRVFLAG_SYSLOG) {
		va_start(ap, emsg);
		if (cmd == IMSG_LOG_ACCESS)
			vlog(LOG_INFO, emsg, ap);
		else
			vlog(LOG_DEBUG, emsg, ap);
		va_end(ap);
		return;
	}

	va_start(ap, emsg);
	ret = vasprintf(&msg, emsg, ap);
	va_end(ap);
	if (ret == -1) {
		log_warn("%s: vasprintf", __func__);
		return;
	}

	iov[0].iov_base = &srv_conf->id;
	iov[0].iov_len = sizeof(srv_conf->id);
	iov[1].iov_base = msg;
	iov[1].iov_len = strlen(msg) + 1;

	if (proc_composev(httpd_env->sc_ps, PROC_LOGGER, cmd, iov, 2) != 0) {
		log_warn("%s: failed to compose imsg", __func__);
		return;
	}
}

void
server_log(struct client *clt, const char *msg)
{
	char			 ibuf[HOST_NAME_MAX+1], obuf[HOST_NAME_MAX+1];
	struct server_config	*srv_conf = clt->clt_srv_conf;
	char			*ptr = NULL, *vmsg = NULL;
	int			 debug_cmd = -1;

	switch (srv_conf->logformat) {
	case LOG_FORMAT_CONNECTION:
		debug_cmd = IMSG_LOG_ACCESS;
		break;
	default:
		if (log_getverbose() > 1)
			debug_cmd = IMSG_LOG_ERROR;
		if (EVBUFFER_LENGTH(clt->clt_log)) {
			while ((ptr =
			    evbuffer_readline(clt->clt_log)) != NULL) {
				server_sendlog(srv_conf,
				    IMSG_LOG_ACCESS, "%s", ptr);
				free(ptr);
			}
		}
		break;
	}

	if (debug_cmd != -1 && msg != NULL) {
		memset(ibuf, 0, sizeof(ibuf));
		memset(obuf, 0, sizeof(obuf));
		(void)print_host(&clt->clt_ss, ibuf, sizeof(ibuf));
		(void)server_http_host(&clt->clt_srv_ss, obuf, sizeof(obuf));
		if (EVBUFFER_LENGTH(clt->clt_log) &&
		    evbuffer_add_printf(clt->clt_log, "\n") != -1)
			ptr = evbuffer_readline(clt->clt_log);
		(void)stravis(&vmsg, msg, HTTPD_LOGVIS);
		server_sendlog(srv_conf, debug_cmd, "server %s, "
		    "client %d (%d active), %s:%u -> %s, "
		    "%s%s%s", srv_conf->name, clt->clt_id, server_clients,
		    ibuf, ntohs(clt->clt_port), obuf, vmsg == NULL ? "" : vmsg,
		    ptr == NULL ? "" : ",", ptr == NULL ? "" : ptr);
		free(vmsg);
		free(ptr);
	}
}

void
server_close(struct client *clt, const char *msg)
{
	struct server		*srv = clt->clt_srv;

	SPLAY_REMOVE(client_tree, &srv->srv_clients, clt);

	/* free the HTTP descriptors incl. headers */
	server_close_http(clt);

	event_del(&clt->clt_ev);
	if (clt->clt_bev != NULL)
		bufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);
	if (clt->clt_srvbev != NULL)
		bufferevent_disable(clt->clt_srvbev, EV_READ|EV_WRITE);

	server_log(clt, msg);

	if (clt->clt_bev != NULL)
		bufferevent_free(clt->clt_bev);
	if (clt->clt_output != NULL)
		evbuffer_free(clt->clt_output);
	if (clt->clt_srvevb != NULL)
		evbuffer_free(clt->clt_srvevb);

	if (clt->clt_srvbev != NULL)
		bufferevent_free(clt->clt_srvbev);
	if (clt->clt_fd != -1)
		close(clt->clt_fd);
	if (clt->clt_s != -1)
		close(clt->clt_s);

	if (clt->clt_tls_ctx != NULL)
		tls_close(clt->clt_tls_ctx);
	tls_free(clt->clt_tls_ctx);

	server_inflight_dec(clt, __func__);

	if (clt->clt_log != NULL)
		evbuffer_free(clt->clt_log);

	free(clt);
	server_clients--;
}

int
server_dispatch_parent(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct server			*srv;
	struct server_tls_ticket	 key;

	switch (imsg->hdr.type) {
	case IMSG_CFG_MEDIA:
		config_getmedia(httpd_env, imsg);
		break;
	case IMSG_CFG_AUTH:
		config_getauth(httpd_env, imsg);
		break;
	case IMSG_CFG_SERVER:
		config_getserver(httpd_env, imsg);
		break;
	case IMSG_CFG_TLS:
		config_getserver_tls(httpd_env, imsg);
		break;
	case IMSG_CFG_DONE:
		config_getcfg(httpd_env, imsg);
		break;
	case IMSG_CTL_START:
		server_launch();
		break;
	case IMSG_CTL_RESET:
		config_getreset(httpd_env, imsg);
		break;
	case IMSG_TLSTICKET_REKEY:
		IMSG_SIZE_CHECK(imsg, (&key));
		memcpy(&key, imsg->data, sizeof(key));
		/* apply to the right server */
		srv = server_byid(key.tt_id);
		if (srv) {
			tls_config_add_ticket_key(srv->srv_tls_config,
			    key.tt_keyrev, key.tt_key, sizeof(key.tt_key));
		}
		break;
	default:
		return (-1);
	}

	return (0);
}

int
server_dispatch_logger(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	switch (imsg->hdr.type) {
	default:
		return (-1);
	}

	return (0);
}

int
server_bufferevent_add(struct event *ev, int timeout)
{
	struct timeval tv, *ptv = NULL;

	if (timeout) {
		timerclear(&tv);
		tv.tv_sec = timeout;
		ptv = &tv;
	}

	return (event_add(ev, ptv));
}

int
server_bufferevent_printf(struct client *clt, const char *fmt, ...)
{
	int	 ret;
	va_list	 ap;
	char	*str;

	va_start(ap, fmt);
	ret = vasprintf(&str, fmt, ap);
	va_end(ap);

	if (ret == -1)
		return (ret);

	ret = server_bufferevent_print(clt, str);
	free(str);

	return (ret);
}

int
server_bufferevent_print(struct client *clt, const char *str)
{
	if (clt->clt_bev == NULL)
		return (evbuffer_add(clt->clt_output, str, strlen(str)));
	return (bufferevent_write(clt->clt_bev, str, strlen(str)));
}

int
server_bufferevent_write_buffer(struct client *clt, struct evbuffer *buf)
{
	if (clt->clt_bev == NULL)
		return (evbuffer_add_buffer(clt->clt_output, buf));
	return (bufferevent_write_buffer(clt->clt_bev, buf));
}

int
server_bufferevent_write_chunk(struct client *clt,
    struct evbuffer *buf, size_t size)
{
	int ret;
	ret = server_bufferevent_write(clt, buf->buffer, size);
	if (ret != -1)
		evbuffer_drain(buf, size);
	return (ret);
}

int
server_bufferevent_write(struct client *clt, void *data, size_t size)
{
	if (clt->clt_bev == NULL)
		return (evbuffer_add(clt->clt_output, data, size));
	return (bufferevent_write(clt->clt_bev, data, size));
}

int
server_client_cmp(struct client *a, struct client *b)
{
	return ((int)a->clt_id - b->clt_id);
}

SPLAY_GENERATE(client_tree, client, clt_nodes, server_client_cmp);
@


1.110
log
@Rework the way that TLS configuration is sent/received via imsgs, so that
are no longer limited by the 16KB maximum size of a single imsg.
Configuration data that is larger than a single message is now chunked and
sent via multiple imsgs.

Prompted by a diff from Jack Burton <jack at saosce dot com dot au>.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.109 2017/04/17 21:58:27 deraadt Exp $	*/
d145 1
a145 1
	if (strcmp(sc1->tls_ecdhe_curve, sc2->tls_ecdhe_curve) != 0)
d240 3
a242 3
	if (tls_config_set_ecdhecurve(srv->srv_tls_config,
	    srv->srv_conf.tls_ecdhe_curve) != 0) {
		log_warnx("%s: failed to set tls ecdhe curve: %s",
@


1.109
log
@some freezero() calls
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.108 2017/03/25 17:25:34 claudio Exp $	*/
d1283 1
a1283 1
		config_gettls(httpd_env, imsg);
@


1.108
log
@Implement TLS ticket support in httpd. Off by default. Use
	tls ticket lifetime default
to turn it on with a 2h ticket lifetime.
Rekeying happens after a quarter of that time.
OK reky@@ and bob@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.107 2017/02/07 12:27:42 reyk Exp $	*/
d305 2
a306 4
	explicit_bzero(srv->srv_conf.tls_cert, srv->srv_conf.tls_cert_len);
	explicit_bzero(srv->srv_conf.tls_key, srv->srv_conf.tls_key_len);
	free(srv->srv_conf.tls_cert);
	free(srv->srv_conf.tls_key);
d419 2
a420 10

	if (srv_conf->tls_cert != NULL) {
		explicit_bzero(srv_conf->tls_cert, srv_conf->tls_cert_len);
		free(srv_conf->tls_cert);
	}

	if (srv_conf->tls_key != NULL) {
		explicit_bzero(srv_conf->tls_key, srv_conf->tls_key_len);
		free(srv_conf->tls_key);
	}
@


1.107
log
@/tmp/cvsspEkok
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.106 2017/02/02 22:19:59 reyk Exp $	*/
d61 1
d139 2
d272 25
d318 10
d479 12
d1279 3
d1303 10
@


1.106
log
@Fix support for HTTP pipelining by handling all requests in the buffer.

Tested & OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.105 2017/01/31 20:08:13 beck Exp $	*/
d821 1
a821 1
	    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);
d905 1
a905 1
		server_close(clt, "buffer event timeout");
@


1.105
log
@remove extra call setting OCSP staple now that it is done above
using keypair_ocsp..
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.104 2017/01/31 17:25:05 beck Exp $	*/
a838 2

	bufferevent_enable(bev, EV_READ);
@


1.104
log
@Correct mistake I made when converting this to new funciton
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.103 2017/01/31 16:18:57 beck Exp $	*/
a251 9
	}

	if (srv->srv_conf.tls_ocsp_staple != NULL) {
		if (tls_config_set_ocsp_staple_mem(srv->srv_tls_config,
		    srv->srv_conf.tls_ocsp_staple,
		    srv->srv_conf.tls_ocsp_staple_len) != 0 ) {
			log_warnx("%s: failed to add ocsp staple", __func__);
			return (-1);
		}
@


1.103
log
@Add tls_config_[add|set]keypair_ocsp functions so that ocsp staples may be
added associated to a keypair used for SNI, and are usable for more than
just the "main" certificate. Modify httpd to use this.
Bump libtls minor.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.102 2017/01/31 12:20:05 reyk Exp $	*/
d247 2
a248 1
	    srv_conf->tls_ocsp_staple, srv_conf->tls_ocsp_staple_len) != 0) {
@


1.102
log
@Do not set EVBUFFER_EOF on read/write errors and handle EOF correctly.

Either libevent or the TLS callback can trigger an EOF when the
connection is closed.

OK sunil@@ jung@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.101 2017/01/09 14:49:22 reyk Exp $	*/
d244 1
a244 1
	if (tls_config_set_keypair_mem(srv->srv_tls_config,
d246 2
a247 1
	    srv->srv_conf.tls_key, srv->srv_conf.tls_key_len) != 0) {
d267 1
a267 1
		if (tls_config_add_keypair_mem(srv->srv_tls_config,
d269 3
a271 1
		    srv_conf->tls_key, srv_conf->tls_key_len) != 0) {
a272 10
			return (-1);
		}
		if (srv_conf->tls_ocsp_staple == NULL)
			continue;
		log_debug("%s: adding ocsp staple for server %s", __func__,
		    srv->srv_conf.name);
		if (tls_config_set_ocsp_staple_mem(srv->srv_tls_config,
		    srv_conf->tls_ocsp_staple, srv_conf->tls_ocsp_staple_len)
		    != 0 ) {
			log_warnx("%s: failed to add ocsp staple", __func__);
@


1.101
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.100 2016/11/17 14:58:37 jsing Exp $	*/
d864 1
a864 1
	(*bev->errorcb)(bev, EVBUFFER_WRITE|EVBUFFER_EOF, bev->cbarg);
d909 1
a909 1
	(*bev->errorcb)(bev, EVBUFFER_READ|EVBUFFER_EOF, bev->cbarg);
d933 5
a937 1
	if (error & (EVBUFFER_READ|EVBUFFER_WRITE|EVBUFFER_EOF)) {
@


1.100
log
@Check the return value of tls_config_set_protocols(), now that it returns
an int.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.99 2016/11/17 14:52:48 jsing Exp $	*/
a1155 1
	extern int		 verbose;
d1162 1
a1162 1
		if (verbose > 1)
@


1.99
log
@Move OCSP loading into a separate function - it is not part of the keypair
and this way we can give a separate specific error message.

ok beck@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.98 2016/11/10 13:21:58 jca Exp $	*/
d219 6
a224 3
	tls_config_set_protocols(srv->srv_tls_config,
	    srv->srv_conf.tls_protocols);

@


1.98
log
@Fix tcp ip ttl / minttl on IPv6 sockets.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.97 2016/11/06 16:05:02 beck Exp $	*/
d161 2
a162 3
	if ((srv->srv_conf.tls_cert = tls_load_file(
	    srv->srv_conf.tls_cert_file, &srv->srv_conf.tls_cert_len,
	    NULL)) == NULL)
d168 2
a169 3
	if ((srv->srv_conf.tls_key = tls_load_file(
	    srv->srv_conf.tls_key_file, &srv->srv_conf.tls_key_len,
	    NULL)) == NULL)
d174 18
a191 9
	if (srv->srv_conf.tls_ocsp_staple_file != NULL) {
		if ((srv->srv_conf.tls_ocsp_staple = tls_load_file(
		    srv->srv_conf.tls_ocsp_staple_file,
		    &srv->srv_conf.tls_ocsp_staple_len,
		    NULL)) == NULL)
			return (-1);
		log_debug("%s: using ocsp staple from %s", __func__,
		    srv->srv_conf.tls_ocsp_staple_file);
	}
@


1.97
log
@conditionalize ocsp load properly
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.96 2016/11/06 10:49:38 beck Exp $	*/
d572 12
a583 3
		if (setsockopt(s, IPPROTO_IP, IP_TTL,
		    &val, sizeof(val)) == -1)
			goto bad;
d587 12
a598 3
		if (setsockopt(s, IPPROTO_IP, IP_MINTTL,
		    &val, sizeof(val)) == -1)
			goto bad;
@


1.96
log
@Add OCSP stapling support to httpd
ok jsing@@ bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.95 2016/08/30 14:31:53 rzalamena Exp $	*/
d176 9
a184 7
	if ((srv->srv_conf.tls_ocsp_staple = tls_load_file(
	    srv->srv_conf.tls_ocsp_staple_file,
	    &srv->srv_conf.tls_ocsp_staple_len,
	    NULL)) == NULL)
		return (-1);
	log_debug("%s: using ocsp staple from %s", __func__,
	    srv->srv_conf.tls_ocsp_staple_file);
@


1.95
log
@Kill (remove) the ps_pid from privsep struct since it is not being used
anymore. Also fix the process initialization prototypes.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.94 2016/08/27 11:13:16 rzalamena Exp $	*/
d176 8
d240 9
d260 10
d384 2
d407 2
@


1.94
log
@Kill p_instance from proc.c and remove static proc_id unused variables.

To keep the debug functionality intact and correct we'll use the pid
field in the imsg header to pass the instance number. Remember to always
pass 'ps_instance + 1' otherwise libutil will fill imsg header pid field
with the imsgbuf pid (which is the current process pid).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.93 2016/08/26 10:46:39 rzalamena Exp $	*/
d83 1
a83 1
pid_t
d86 1
a86 2
	pid_t	 pid;
	pid = proc_run(ps, p, procs, nitems(procs), server_init, NULL);
a87 1
	return (pid);
@


1.93
log
@Replace the static env variables with a single global variable.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.92 2016/08/22 15:02:18 jsing Exp $	*/
a77 2
int				 proc_id;

a274 3
	/* Set to current prefork id */
	proc_id = p->p_instance;

a968 3

	/* Increment the per-relay client counter */
	//srv->srv_stats[proc_id].last++;
@


1.92
log
@Enable SNI support in httpd(8).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.91 2016/08/16 18:41:57 tedu Exp $	*/
a77 1
static struct httpd		*env = NULL;
a88 1
	env = ps->ps_env;
d90 1
a90 1
	server_http(env);
d97 1
a97 1
	config_purge(env, CONFIG_ALL);
d115 1
a115 1
	TAILQ_FOREACH(s, env->sc_servers, srv_entry) {
d272 1
a272 1
	server_http(ps->ps_env);
d291 3
a293 3
	evtimer_set(&env->sc_statev, server_statistics, NULL);
	memcpy(&tv, &env->sc_statinterval, sizeof(tv));
	evtimer_add(&env->sc_statev, &tv);
d302 1
a302 1
	TAILQ_FOREACH(srv, env->sc_servers, srv_entry) {
d333 1
a333 1
	TAILQ_REMOVE(env->sc_servers, srv, srv_entry);
d392 1
a392 1
	TAILQ_FOREACH(srv, env->sc_servers, srv_entry) {
d408 1
a408 1
	TAILQ_FOREACH(srv, env->sc_servers, srv_entry) {
d427 1
a427 1
	TAILQ_FOREACH(srv, env->sc_servers, srv_entry) {
d445 1
a445 1
	TAILQ_FOREACH(s1, env->sc_servers, srv_entry) {
d1092 1
a1092 1
	if (proc_composev(env->sc_ps, PROC_LOGGER, cmd, iov, 2) != 0) {
d1194 1
a1194 1
		config_getmedia(env, imsg);
d1197 1
a1197 1
		config_getauth(env, imsg);
d1200 1
a1200 1
		config_getserver(env, imsg);
d1203 1
a1203 1
		config_gettls(env, imsg);
d1206 1
a1206 1
		config_getcfg(env, imsg);
d1212 1
a1212 1
		config_getreset(env, imsg);
@


1.91
log
@stop including sys/param.h for nitems. define locally as needed.
ok natano reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.90 2016/08/16 17:10:01 reyk Exp $	*/
d135 1
a135 1
server_tls_cmp(struct server *s1, struct server *s2)
a143 4
	if (strcmp(sc1->tls_cert_file, sc2->tls_cert_file) != 0)
		return (-1);
	if (strcmp(sc1->tls_key_file, sc2->tls_key_file) != 0)
		return (-1);
d151 7
d188 2
d238 13
d305 3
@


1.90
log
@Turn "TLS handshake failed -" log message into a debug message - it
happens way too often and does not provide much information.

OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.89 2016/08/16 08:36:29 reyk Exp $	*/
a18 1
#include <sys/param.h>	/* nitems */
@


1.89
log
@Rename server_handshake_tls() to server_tls_handshake() to align with
the other server_tls_* functions (and I like the prefix notation
better).  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.88 2016/08/15 16:12:34 jsing Exp $	*/
d1021 1
a1021 1
		log_warnx("%s: tls handshake failed - %s", __func__,
@


1.88
log
@Move server_match() from parse.y to server.c; use env instead of conf,
which is actually the same thing (cluebat from reyk@@).
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.87 2016/08/15 14:14:55 jsing Exp $	*/
d66 1
a68 1
void		 server_handshake_tls(int, short, void *);
d974 1
a974 1
		    server_handshake_tls, &clt->clt_tv_start,
d995 1
a995 1
server_handshake_tls(int fd, short event, void *arg)
d1014 1
a1014 1
		    server_handshake_tls, &clt->clt_tv_start,
d1018 1
a1018 1
		    server_handshake_tls, &clt->clt_tv_start,
@


1.87
log
@Use lowercase 'tls' in debug and log messages for consistency.

Requested by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.86 2016/08/15 13:48:24 jsing Exp $	*/
d419 27
@


1.86
log
@Make httpd stricter with respect to TLS configuration - in particular, do
not allow TLS and non-TLS to be configured on the same port, do not allow
TLS options to be specified without a TLS listener and ensure that the TLS
options are the same when a server is specified on the same address/port.
Currently, these configurations are permitted but do not work as intended.

Also factor out and reuse the server matching code, which was previously
duplicated.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.85 2016/04/28 17:18:06 jsing Exp $	*/
d189 1
a189 1
	log_debug("%s: setting up TLS for %s", __func__, srv->srv_conf.name);
d235 1
a235 1
		log_warnx("%s: failed to configure TLS - %s", __func__,
d975 1
a975 1
		server_close(clt, "TLS handshake timeout");
d994 1
a994 1
		log_warnx("%s: TLS handshake failed - %s", __func__,
d996 1
a996 1
		server_close(clt, "TLS handshake failed");
@


1.85
log
@Include the TLS configuration errors in log messages. Also set the
certificate and private key at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.84 2016/04/19 16:22:34 jsing Exp $	*/
d130 24
@


1.84
log
@Use log_warnx() instead of log_warn() when the failure will not have
resulted in errno being set.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.83 2015/12/02 15:13:00 reyk Exp $	*/
d185 2
a186 1
		log_warnx("%s: failed to set tls ciphers", __func__);
d191 2
a192 1
		log_warnx("%s: failed to set tls dhe params", __func__);
d197 2
a198 1
		log_warnx("%s: failed to set tls ecdhe curve", __func__);
d202 2
a203 6
	if (tls_config_set_cert_mem(srv->srv_tls_config,
	    srv->srv_conf.tls_cert, srv->srv_conf.tls_cert_len) != 0) {
		log_warnx("%s: failed to set tls cert", __func__);
		return (-1);
	}
	if (tls_config_set_key_mem(srv->srv_tls_config,
d205 2
a206 1
		log_warnx("%s: failed to set tls key", __func__);
@


1.83
log
@sync with relayd, use proc_compose()
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.82 2015/11/23 20:56:14 reyk Exp $	*/
d168 1
a168 1
		log_warn("%s: failed to initialise tls", __func__);
d172 1
a172 1
		log_warn("%s: failed to get tls config", __func__);
d176 1
a176 1
		log_warn("%s: failed to get tls server", __func__);
d185 1
a185 1
		log_warn("%s: failed to set tls ciphers", __func__);
d190 1
a190 1
		log_warn("%s: failed to set tls dhe params", __func__);
d195 1
a195 1
		log_warn("%s: failed to set tls ecdhe curve", __func__);
d201 1
a201 1
		log_warn("%s: failed to set tls cert", __func__);
d206 1
a206 1
		log_warn("%s: failed to set tls key", __func__);
d211 1
a211 1
		log_warn("%s: failed to configure TLS - %s", __func__,
@


1.82
log
@Retire socket_set_blockmode() in favor of the SOCK_NONBLOCK type flag.
As done in iked and snmpd.

OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.81 2015/11/05 18:00:43 florian Exp $	*/
d1023 1
a1023 2
	if (proc_composev_imsg(env->sc_ps, PROC_LOGGER, -1, cmd, -1, iov,
	    2) != 0) {
@


1.81
log
@pledge(2) for httpd.

1) The main process listens on sockets and accepts connections. It
creates and opens log files, creates and kills child processes. On
start up and on receiving a HUP signal it parses the configuration. It
passes on file descriptors for logging or requests to it's children.
2) The logger process writes log messages to a file descriptor passed
in from the main process.
3) The server process reads the request from a file descriptor passed
in from the main process. It reads a file or creates a directory index
to send a response.
Additionally this process handles fastcgi requests. It connects to
AF_UNIX, AF_INET or AF_INET6 sockets. A re-factoring might make it
possible to drop the additional fastcgi privileges when only static
files are served.

with deraadt@@ some time ago
prodding & OK deraadt@@
tweaks and OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.80 2015/09/11 13:21:09 jsing Exp $	*/
d444 2
a445 1
	s = fd == -1 ? socket(ss->ss_family, SOCK_STREAM, IPPROTO_TCP) : fd;
a460 2
	if (fcntl(s, F_SETFL, O_NONBLOCK) == -1)
		goto bad;
a858 3
		goto err;

	if (fcntl(s, F_SETFL, O_NONBLOCK) == -1)
@


1.80
log
@Fix server_handshake_tls() - we should only call server_input() in the case
where the handshake has successfully completed.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.79 2015/09/10 13:53:13 beck Exp $	*/
d246 3
@


1.79
log
@fix return type for tls_read/write
jointly with jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.78 2015/09/10 10:42:40 beck Exp $	*/
d956 1
a956 1
	if (srv->srv_tls_ctx == NULL)
d960 3
a962 1
	if (ret == TLS_WANT_POLLIN) {
d970 1
a970 1
	} else if (ret != 0) {
a973 1
		return;
a974 3

	server_input(clt);
	return;
@


1.78
log
@fix after libtls api changes
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.77 2015/09/10 10:15:46 jsing Exp $	*/
d566 1
a566 1
	int			 ret;
d625 1
a625 1
	int			 ret;
@


1.77
log
@Update httpd to call tls_handshake() after tls_accept_socket().

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.76 2015/09/07 14:46:24 reyk Exp $	*/
d577 2
a578 2
	ret = tls_read(clt->clt_tls_ctx, rbuf, howmuch, &len);
	if (ret == TLS_READ_AGAIN || ret == TLS_WRITE_AGAIN) {
d580 1
a580 1
	} else if (ret != 0) {
d584 1
d637 2
a638 2
		    EVBUFFER_LENGTH(bufev->output), &len);
		if (ret == TLS_READ_AGAIN || ret == TLS_WRITE_AGAIN) {
d640 1
a640 1
		} else if (ret != 0) {
d644 1
a745 2
	size_t			 outlen;

d756 1
a756 1
		(void)tls_write(clt->clt_tls_ctx, buf, len, &outlen);
d960 1
a960 1
	if (ret == TLS_READ_AGAIN) {
d964 1
a964 1
	} else if (ret == TLS_WRITE_AGAIN) {
@


1.76
log
@Fix a regression that was introduced with server.c r1.64: Do NOT free
srv_conf->auth in serverconfig_free() because it was not allocated in
config_getserver() but assigned as a reference by id from a global
list that is maintained independently.  This fixes a potential
double-free.  This fix also makes srv_conf->auth "const" to emphasize
that the read-only auth pointer was not allocated here.

OK jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.75 2015/08/20 13:00:23 reyk Exp $	*/
d68 1
a68 1
void		 server_accept_tls(int, short, void *);
d918 5
d924 1
a924 1
		    server_accept_tls, &clt->clt_tv_start,
d945 1
a945 1
server_accept_tls(int fd, short event, void *arg)
d952 1
a952 1
		server_close(clt, "TLS accept timeout");
d959 1
a959 2
	ret = tls_accept_socket(srv->srv_tls_ctx, &clt->clt_tls_ctx,
	    clt->clt_s);
d962 1
a962 1
		    server_accept_tls, &clt->clt_tv_start,
d966 1
a966 1
		    server_accept_tls, &clt->clt_tv_start,
d969 3
a971 3
		log_warnx("%s: TLS accept failed - %s", __func__,
		    tls_error(srv->srv_tls_ctx));
		server_close(clt, "TLS accept failed");
@


1.75
log
@Change httpd(8) to use C99-style fixed-width integers (uintN_t instead
of u_intN_t) and replace u_int with unsigned int.  Mixing both
variants is a bad style and most contributors seem to prefer this
style; it also helps us to get used to it, portability, and
standardization.

Theoretically no binary change, except one in practice: httpd.o has a
different checksum because gcc with -O2 pads/optimizes "struct
privsep" differently when using "unsigned int" instead "u_int" for the
affected members.  "u_int" is just a typedef of "unsigned int", -O0
doesn't build the difference and clang with -O2 doesn't do it either -
it is just another curiosity from gcc-land.

OK semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.74 2015/08/03 11:45:17 florian Exp $	*/
a315 1
	free(srv_conf->auth);
@


1.74
log
@Fix rev 1.70 of server.c by only re-enabling the bufferevent if we
previously disabled it because we were reading to fast (from disk).
Problem noted and tracked down to that commit by weerd@@ and
independently by stsp@@.
Tested by weerd@@, stsp@@, reyk@@
OK bluhm@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.73 2015/07/29 22:03:41 reyk Exp $	*/
d77 1
a77 1
u_int32_t server_cltid;
d359 1
a359 1
serverconfig_byid(u_int32_t id)
@


1.73
log
@backout the previous:  it broke wordpress somehow.
we need more care to find a proper fix for the fastcgi headers.

acknowledged by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.72 2015/07/29 20:03:14 florian Exp $	*/
d731 1
a731 1
	if (clt->clt_srvbev && !(clt->clt_srvbev->enabled & EV_READ))
d733 2
d778 4
a781 2
	    SERVER_MAX_PREFETCH * clt->clt_sndbufsiz)
		bufferevent_disable(bev, EV_READ);
@


1.72
log
@Read fcgi response records until we have the whole http header and can
parse it. Otherwise http headers can leak into the body.
Pointed out by Jean-Philippe Ouellet on bugs@@ Thanks!
OK reyk, commit ASAP deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.71 2015/07/18 22:19:50 reyk Exp $	*/
a1095 2
	if (clt->clt_fcgi_http_header_evb != NULL)
		evbuffer_free(clt->clt_fcgi_http_header_evb);
@


1.71
log
@libtls has been changed to set SSL_MODE_ENABLE_PARTIAL_WRITE and
SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER by default.  This gives
tls_write() a similar short write semantics as write(2) and a
workaround in httpd to cope with the previous differences can be
removed.  Specifically, httpd can stop copying data into a local
buffer that was used to keep it around for repeated writes.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.70 2015/07/16 16:29:25 florian Exp $	*/
d1096 2
@


1.70
log
@If we can read faster from disk than send data to the client stop
reading from disk when we hold a certain amount of data in
RAM. Re-enable reading once we send enough data to the
client. Otherwise we might end up with the whole file (which can be
huge) in RAM.
Reported by Matthew Martin ( matt.a.martin AT gmail ) on bugs@@,
thanks!
OK reyk@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.69 2015/07/15 23:16:38 reyk Exp $	*/
d635 3
a637 11
		if (clt->clt_buf == NULL) {
			clt->clt_buflen = EVBUFFER_LENGTH(bufev->output);
			if ((clt->clt_buf = malloc(clt->clt_buflen)) == NULL) {
				what |= EVBUFFER_ERROR;
				goto err;
			}
			bcopy(EVBUFFER_DATA(bufev->output),
			    clt->clt_buf, clt->clt_buflen);
		}
		ret = tls_write(clt->clt_tls_ctx, clt->clt_buf,
		    clt->clt_buflen, &len);
a645 5
	if (clt->clt_buf != NULL) {
		free(clt->clt_buf);
		clt->clt_buf = NULL;
		clt->clt_buflen = 0;
	}
d656 1
a656 2
	if (clt->clt_buflen != 0)
		server_bufferevent_add(&bufev->ev_write, bufev->timeout_write);
a659 5
	if (clt->clt_buf != NULL) {
		free(clt->clt_buf);
		clt->clt_buf = NULL;
		clt->clt_buflen = 0;
	}
@


1.69
log
@Escape the message in server_log() as well.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.68 2015/07/15 17:29:11 jsing Exp $	*/
d724 1
a724 1
	    clt->clt_sndbufsiz, 0);
d749 4
d793 5
@


1.68
log
@Close connections that fail to complete a TLS handshake.

Based on a diff from Jack Burton <jack at saosce dot com dot au>.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.67 2015/07/15 17:11:14 jsing Exp $	*/
d44 1
d1041 1
a1041 1
	char			*ptr = NULL;
d1071 1
d1075 1
a1075 1
		    ibuf, ntohs(clt->clt_port), obuf, msg,
d1077 2
a1078 2
		if (ptr != NULL)
			free(ptr);
@


1.67
log
@Fix typo in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.66 2015/07/15 16:00:39 jsing Exp $	*/
d973 1
@


1.66
log
@Send the TLS certificate and key via separate imsgs, rather than
including them in the IMSG_CFG_SERVER imsg. This allows the certificate
and key to each be almost 16KB (the maximum size for an imsg), rather than
having a combined total of less than 16KB (which can be reached with large
keys, certificate bundles or by including text versions of certificates).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.65 2015/07/15 14:49:42 jsing Exp $	*/
d938 1
a938 1
		 * the client struct was not completly set up, but still
@


1.65
log
@Explicitly check for and handle EOF on a TLS connection.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.64 2015/07/15 14:39:13 jsing Exp $	*/
d1136 3
@


1.64
log
@Fix memory leaks that can occur when config_getserver() fails.

config.c r1.34 and r1.30 introduced potential memory leaks for auth and
return_uri when config_getserver fails. Fix this by switching to
serverconfig_free() and adding the missing free for srv_conf->auth.
While here, make serverconfig_free() a little more bulletproof by
explicit_bzero()ing key material.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.63 2015/04/23 16:59:28 florian Exp $	*/
d582 5
@


1.63
log
@We cannot log errors with server_close() before allocating
clt_log evbuffer.
server_close() calls server_log() which uses ctl_log.
Crash reported by Daniel Jakots <vigdis AT chown DOT me>, thanks!
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.62 2015/04/11 14:52:49 jsing Exp $	*/
d315 1
a317 1
	free(srv_conf->tls_cert);
d319 10
a328 1
	free(srv_conf->tls_key);
d334 1
a334 2
	srv_conf->tls_cert_file = srv_conf->tls_key_file = NULL;
	srv_conf->tls_cert = srv_conf->tls_key = NULL;
d336 4
a339 1
	srv_conf->auth = NULL;
@


1.62
log
@Always check the return value of proc_composev_imsg() and handle failures
appropriately. Otherwise imsg construction can silently fail, resulting in
non-obvious problems.

Found the hard way by Theodore Wynnychenko.

ok doug@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.61 2015/03/15 22:08:45 florian Exp $	*/
d855 5
a903 7
		return;
	}

	/* Pre-allocate log buffer */
	clt->clt_log = evbuffer_new();
	if (clt->clt_log == NULL) {
		server_close(clt, "failed to allocate log buffer");
@


1.61
log
@Prevent use after free.
While here unconditionally free clt and move declaration of
server_inflight_dec() into server.c
Found while investigating if (foo != NULL) free(foo) patterns pointed
out by Markus Elfring.
OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.60 2015/02/23 09:52:28 reyk Exp $	*/
d1013 5
a1017 1
	proc_composev_imsg(env->sc_ps, PROC_LOGGER, -1, cmd, -1, iov, 2);
@


1.60
log
@Add return_uri to serverconfig_reset() to avoid using garbage from the
imsg buffer.

Debugging & OK halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.59 2015/02/12 04:40:23 jsing Exp $	*/
d69 1
d922 1
a922 2
		if (clt != NULL)
			free(clt);
d927 1
a927 1
		server_inflight_dec(clt, __func__);
@


1.60.2.1
log
@MFC usr.sbin/httpd/server.c:1.62->1.63, req by florian@@

We cannot log errors with server_close() before allocating
clt_log evbuffer.
server_close() calls server_log() which uses ctl_log.
Crash reported by Daniel Jakots <vigdis AT chown DOT me>, thanks!
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.60 2015/02/23 09:52:28 reyk Exp $	*/
a853 5
	/* Pre-allocate log buffer */
	clt->clt_log = evbuffer_new();
	if (clt->clt_log == NULL)
		goto err;

d898 7
@


1.59
log
@Allow TLS protocols to be specified via a "tls protocols" configuration
option.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.58 2015/02/12 04:23:17 jsing Exp $	*/
d326 1
@


1.58
log
@Change TLS_PROTOCOLS_DEFAULT to be TLSv1.2 only. Add a TLS_PROTOCOLS_ALL
that includes all currently supported protocols (TLSv1.0, TLSv1.1 and
TLSv1.2). Change all users of libtls to use TLS_PROTOCOLS_ALL so that they
maintain existing behaviour.

Discussed with tedu@@ and reyk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.57 2015/02/07 23:56:02 reyk Exp $	*/
d178 2
a179 1
	tls_config_set_protocols(srv->srv_tls_config, TLS_PROTOCOLS_ALL);
@


1.57
log
@Remove server_load_file() in favor of tls_load_file(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.56 2015/02/07 06:26:28 jsing Exp $	*/
d177 2
@


1.56
log
@Add httpd configuration options to allow the specification of DHE
parameters and the ECDHE curve. This primarily allows for DHE cipher suites
to be enabled.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.55 2015/02/07 01:23:12 reyk Exp $	*/
a132 30
static char *
server_load_file(const char *filename, off_t *len)
{
	struct stat		 st;
	off_t			 size;
	char			*buf = NULL;
	int			 fd;

	if ((fd = open(filename, O_RDONLY)) == -1)
		return (NULL);
	if (fstat(fd, &st) != 0)
		goto fail;
	size = st.st_size;
	if ((buf = calloc(1, size + 1)) == NULL)
		goto fail;
	if (read(fd, buf, size) != size)
		goto fail;

	close(fd);

	*len = size;
	return (buf);

 fail:
	free(buf);
	close(fd);

	return (NULL);
}

d139 3
a141 2
	if ((srv->srv_conf.tls_cert = server_load_file(
	    srv->srv_conf.tls_cert_file, &srv->srv_conf.tls_cert_len)) == NULL)
d146 4
a149 2
	if ((srv->srv_conf.tls_key = server_load_file(
	    srv->srv_conf.tls_key_file, &srv->srv_conf.tls_key_len)) == NULL)
d321 2
a322 2
	srv_conf->tls_cert_file = srv_conf->tls_cert =
	    srv_conf->tls_key_file = srv_conf->tls_key = NULL;
@


1.55
log
@Add support for blocking, dropping, and redirecting requests.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.54 2015/01/21 22:21:05 reyk Exp $	*/
d210 11
@


1.54
log
@httpd is based on relayd and had included many headers that are only
needed by its ancestor.  jsg@@, include-what-you-use, and some manual
review helped to cleanup the headers (take iwyu with a grain of salt).
Based on common practice, httpd.h now also includes the necessary
headers for itself.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.53 2015/01/19 19:37:50 reyk Exp $	*/
d327 1
@


1.53
log
@Decouple auth parameters from struct server_config into struct auth.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.52 2015/01/16 06:40:17 deraadt Exp $	*/
a24 1
#include <sys/un.h>
a27 1
#include <net/if.h>
a28 1
#include <netinet/ip.h>
d30 1
d32 4
a37 1
#include <stdlib.h>
a40 3
#include <stdio.h>
#include <err.h>
#include <pwd.h>
d42 1
a42 1
#include <fnmatch.h>
@


1.52
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.51 2015/01/13 09:21:15 reyk Exp $	*/
d340 1
d1125 3
@


1.51
log
@bump copyright year
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.50 2015/01/06 14:07:48 reyk Exp $	*/
d19 1
d49 2
d575 1
a575 1
		howmuch = MIN(sizeof(rbuf), bufev->wm_read.high);
d1031 1
a1031 1
	char			 ibuf[MAXHOSTNAMELEN], obuf[MAXHOSTNAMELEN];
@


1.50
log
@Only open a socket once for each unique "listen on" statement.  This
prevents running out of file descriptors when loading a configuration
with many aliases.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.49 2014/12/21 00:54:49 guenther Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 - 2014 Reyk Floeter <reyk@@openbsd.org>
@


1.49
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.48 2014/12/12 14:45:59 reyk Exp $	*/
d104 2
d111 14
d296 2
a297 1
	close(srv->srv_s);
@


1.48
log
@Like previously done in relayd, change the keyword "ssl" to "tls" to
reflect reality.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.47 2014/12/04 02:44:42 tedu Exp $	*/
a31 1
#include <arpa/inet.h>
@


1.47
log
@stop viral header propagation. none of this code uses sys/hash.h
from Max Fillinger
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.46 2014/10/31 13:49:52 jsing Exp $	*/
d62 3
a64 3
int		 server_ssl_init(struct server *);
void		 server_ssl_readcb(int, short, void *);
void		 server_ssl_writecb(int, short, void *);
d67 1
a67 1
void		 server_accept_ssl(int, short, void *);
d148 1
a148 1
server_ssl_load_keypair(struct server *srv)
d150 1
a150 1
	if ((srv->srv_conf.flags & SRVFLAG_SSL) == 0)
d153 2
a154 2
	if ((srv->srv_conf.ssl_cert = server_load_file(
	    srv->srv_conf.ssl_cert_file, &srv->srv_conf.ssl_cert_len)) == NULL)
d157 1
a157 1
	    srv->srv_conf.ssl_cert_file);
d159 2
a160 2
	if ((srv->srv_conf.ssl_key = server_load_file(
	    srv->srv_conf.ssl_key_file, &srv->srv_conf.ssl_key_len)) == NULL)
d163 1
a163 1
	    srv->srv_conf.ssl_key_file);
d169 1
a169 1
server_ssl_init(struct server *srv)
d171 1
a171 1
	if ((srv->srv_conf.flags & SRVFLAG_SSL) == 0)
d174 1
a174 1
	log_debug("%s: setting up SSL for %s", __func__, srv->srv_conf.name);
d190 1
a190 1
	    srv->srv_conf.ssl_ciphers) != 0) {
d195 1
a195 1
	    srv->srv_conf.ssl_cert, srv->srv_conf.ssl_cert_len) != 0) {
d200 1
a200 1
	    srv->srv_conf.ssl_key, srv->srv_conf.ssl_key_len) != 0) {
d206 1
a206 1
		log_warn("%s: failed to configure SSL - %s", __func__,
d213 8
a220 8
	explicit_bzero(srv->srv_conf.ssl_cert, srv->srv_conf.ssl_cert_len);
	explicit_bzero(srv->srv_conf.ssl_key, srv->srv_conf.ssl_key_len);
	free(srv->srv_conf.ssl_cert);
	free(srv->srv_conf.ssl_key);
	srv->srv_conf.ssl_cert = NULL;
	srv->srv_conf.ssl_key = NULL;
	srv->srv_conf.ssl_cert_len = 0;
	srv->srv_conf.ssl_key_len = 0;
d256 1
a256 1
		server_ssl_init(srv);
d310 4
a313 4
	free(srv_conf->ssl_cert_file);
	free(srv_conf->ssl_cert);
	free(srv_conf->ssl_key_file);
	free(srv_conf->ssl_key);
d319 2
a320 2
	srv_conf->ssl_cert_file = srv_conf->ssl_cert =
	    srv_conf->ssl_key_file = srv_conf->ssl_key = NULL;
d540 1
a540 1
server_ssl_readcb(int fd, short event, void *arg)
d596 1
a596 1
server_ssl_writecb(int fd, short event, void *arg)
d690 1
a690 1
	if (srv_conf->flags & SRVFLAG_SSL) {
d692 1
a692 1
		    server_ssl_readcb, clt->clt_bev);
d694 1
a694 1
		    server_ssl_writecb, clt->clt_bev);
d901 1
a901 1
	if (srv->srv_conf.flags & SRVFLAG_SSL) {
d903 1
a903 1
		    server_accept_ssl, &clt->clt_tv_start,
d925 1
a925 1
server_accept_ssl(int fd, short event, void *arg)
d932 1
a932 1
		server_close(clt, "SSL accept timeout");
d943 1
a943 1
		    server_accept_ssl, &clt->clt_tv_start,
d947 1
a947 1
		    server_accept_ssl, &clt->clt_tv_start,
d950 1
a950 1
		log_warnx("%s: SSL accept failed - %s", __func__,
@


1.46
log
@Update httpd(8) to use libtls instead of libressl.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.45 2014/10/25 03:23:49 lteo Exp $	*/
a26 1
#include <sys/hash.h>
@


1.45
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.44 2014/10/03 13:41:03 jsing Exp $	*/
d46 1
a46 1
#include <ressl.h>
d177 2
a178 2
	if (ressl_init() != 0) {
		log_warn("%s: failed to initialise ressl", __func__);
d181 2
a182 2
	if ((srv->srv_ressl_config = ressl_config_new()) == NULL) {
		log_warn("%s: failed to get ressl config", __func__);
d185 2
a186 2
	if ((srv->srv_ressl_ctx = ressl_server()) == NULL) {
		log_warn("%s: failed to get ressl server", __func__);
d190 1
a190 1
	if (ressl_config_set_ciphers(srv->srv_ressl_config,
d192 1
a192 1
		log_warn("%s: failed to set ressl ciphers", __func__);
d195 1
a195 1
	if (ressl_config_set_cert_mem(srv->srv_ressl_config,
d197 1
a197 1
		log_warn("%s: failed to set ressl cert", __func__);
d200 1
a200 1
	if (ressl_config_set_key_mem(srv->srv_ressl_config,
d202 1
a202 1
		log_warn("%s: failed to set ressl key", __func__);
d206 1
a206 1
	if (ressl_configure(srv->srv_ressl_ctx, srv->srv_ressl_config) != 0) {
d208 1
a208 1
		    ressl_error(srv->srv_ressl_ctx));
d213 1
a213 1
	ressl_config_clear_keys(srv->srv_ressl_config);
d302 2
a303 2
	ressl_config_free(srv->srv_ressl_config);
	ressl_free(srv->srv_ressl_ctx);
d559 2
a560 2
	ret = ressl_read(clt->clt_ressl_ctx, rbuf, howmuch, &len);
	if (ret == RESSL_READ_AGAIN || ret == RESSL_WRITE_AGAIN) {
d620 1
a620 1
		ret = ressl_write(clt->clt_ressl_ctx, clt->clt_buf,
d622 1
a622 1
		if (ret == RESSL_READ_AGAIN || ret == RESSL_WRITE_AGAIN) {
d745 2
a746 2
	if (clt->clt_ressl_ctx != NULL)
		(void)ressl_write(clt->clt_ressl_ctx, buf, len, &outlen);
d937 2
a938 2
	if (srv->srv_ressl_ctx == NULL)
		fatalx("NULL ressl context");
d940 1
a940 1
	ret = ressl_accept_socket(srv->srv_ressl_ctx, &clt->clt_ressl_ctx,
d942 1
a942 1
	if (ret == RESSL_READ_AGAIN) {
d946 1
a946 1
	} else if (ret == RESSL_WRITE_AGAIN) {
d952 1
a952 1
		    ressl_error(srv->srv_ressl_ctx));
d1087 3
a1089 3
	if (clt->clt_ressl_ctx != NULL)
		ressl_close(clt->clt_ressl_ctx);
	ressl_free(clt->clt_ressl_ctx);
@


1.44
log
@Update ressl configuration to handle recent changes in the library.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.43 2014/10/02 19:22:43 reyk Exp $	*/
a29 1
#include <netinet/in_systm.h>
@


1.43
log
@Fix an error case that was never handled ending up in an endless event
loop that could eat all CPU.  I thought that the previous (correct)
commit fixed it which wasn't the case.  But this one is obvious.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.42 2014/09/05 10:04:20 reyk Exp $	*/
d191 15
a205 6
	ressl_config_set_ciphers(srv->srv_ressl_config,
	    srv->srv_conf.ssl_ciphers);
	ressl_config_set_cert_mem(srv->srv_ressl_config,
	    srv->srv_conf.ssl_cert, srv->srv_conf.ssl_cert_len);
	ressl_config_set_key_mem(srv->srv_ressl_config,
	    srv->srv_conf.ssl_key, srv->srv_conf.ssl_key_len);
d214 1
@


1.42
log
@Remove a limitation that only allowed to specify a server name once.
The key has been changed to server name + address + port and now it is
possible to use the same server name for multiple servers with
different addresses, eg. http://www.example.com and
https://www.example.com/.

OK doug@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.41 2014/09/02 16:20:41 reyk Exp $	*/
d774 8
d797 1
a797 5
	if (error & EVBUFFER_ERROR && errno == EFBIG) {
		bufferevent_enable(bev, EV_READ);
		return;
	}
	server_close(clt, "buffer event error");
@


1.41
log
@FastCGI did not support persistent connections.  Add initial support
for persistent connections with FastCGI by implementing chunked
Transfer-Encoding.  This only works with HTTP/1.1.

With input and help from florian@@ who found some FastCGI edge cases.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.40 2014/08/27 09:51:53 reyk Exp $	*/
d288 1
a288 2
			free(srv_conf->ssl_cert);
			free(srv_conf->ssl_key);
d297 16
@


1.40
log
@Write all data before closing the server socket if the output buffer
is not empty.  This fixes a bug of short responses that could happen
with large files or fcgi data on connections with a higher latency.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.39 2014/08/06 18:38:11 reyk Exp $	*/
d1121 20
@


1.39
log
@Use memset(buf instead of memset(&buf.

Pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.38 2014/08/06 16:10:02 jsing Exp $	*/
d753 1
a758 4
	if (error & EVBUFFER_ERROR && errno == EFBIG) {
		bufferevent_enable(bev, EV_READ);
		return;
	}
d763 8
d772 4
@


1.39.2.1
log
@httpd was developed very rapidly in the weeks before 5.6 release,
and it has a few flaws.  It would be nice to get these flaws fully
remediated before the next release, and that requires the community
to want to use it.
Therefore here is a "jumbo" patch that brings in the most important fixes.

committing on behalf of reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.39 2014/08/06 18:38:11 reyk Exp $	*/
d288 2
a289 1
			serverconfig_free(srv_conf);
a299 16
void
serverconfig_free(struct server_config *srv_conf)
{
	free(srv_conf->ssl_cert_file);
	free(srv_conf->ssl_cert);
	free(srv_conf->ssl_key_file);
	free(srv_conf->ssl_key);
}

void
serverconfig_reset(struct server_config *srv_conf)
{
	srv_conf->ssl_cert_file = srv_conf->ssl_cert =
	    srv_conf->ssl_key_file = srv_conf->ssl_key = NULL;
}

a752 1
	struct evbuffer		*dst;
d758 2
a759 6
	if (error & EVBUFFER_ERROR) {
		if (errno == EFBIG) {
			bufferevent_enable(bev, EV_READ);
			return;
		}
		server_close(clt, "buffer event error");
a765 8

		dst = EVBUFFER_OUTPUT(clt->clt_bev);
		if (EVBUFFER_LENGTH(dst)) {
			/* Finish writing all data first */
			bufferevent_enable(clt->clt_bev, EV_WRITE);
			return;
		}

d769 1
a769 1
	server_close(clt, "unknown event error");
a1111 20
}

int
server_bufferevent_printf(struct client *clt, const char *fmt, ...)
{
	int	 ret;
	va_list	 ap;
	char	*str;

	va_start(ap, fmt);
	ret = vasprintf(&str, fmt, ap);
	va_end(ap);

	if (ret == -1)
		return (ret);

	ret = server_bufferevent_print(clt, str);
	free(str);

	return (ret);
@


1.39.2.2
log
@MFC usr.sbin/httpd/server.c:1.62->1.63, req by florian@@

We cannot log errors with server_close() before allocating
clt_log evbuffer.
server_close() calls server_log() which uses ctl_log.
Crash reported by Daniel Jakots <vigdis AT chown DOT me>, thanks!
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.39.2.1 2014/11/20 07:48:45 jasper Exp $	*/
a838 5
	/* Pre-allocate log buffer */
	clt->clt_log = evbuffer_new();
	if (clt->clt_log == NULL)
		goto err;

d883 7
@


1.38
log
@Also clean up the public key when it is no longer needed.

ok deraadt@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.36 2014/08/06 15:08:04 florian Exp $	*/
d1001 2
a1002 2
		memset(&ibuf, 0, sizeof(ibuf));
		memset(&obuf, 0, sizeof(obuf));
@


1.37
log
@Configure the default SSL ciphers as HIGH:!aNULL.

ok deraadt@@ reyk@@
@
text
@d204 2
a205 1
	/* We're now done with the key... */
d207 1
d209 1
d211 1
@


1.36
log
@http POST support
with & OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.35 2014/08/06 12:56:58 reyk Exp $	*/
d191 2
@


1.35
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.34 2014/08/06 11:24:12 reyk Exp $	*/
d671 2
@


1.34
log
@The watermark exposed a bug in server_write that broke keep-alive
support.  Instead of calling server_close from server_write, we have
to proceed to the next connection by calling the error handler.

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.33 2014/08/06 09:40:04 reyk Exp $	*/
d558 1
a558 1
retry:
d562 1
a562 1
err:
d614 1
a614 1
retry:
d619 1
a619 1
err:
@


1.33
log
@Bring back the last read (done) / last write (done) messages instead of just
"done" to simplify connection debugging.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.32 2014/08/06 09:36:31 reyk Exp $	*/
d691 2
d695 1
a695 1
	server_close(clt, "last write (done)");
a732 1
	bufferevent_enable(bev, EV_READ);
d735 1
a735 1
	server_close(clt, "last read (done)");
@


1.32
log
@Adjust the read/write watermarks according to the TCP send buffer.
This fixes sending of large files.  Previously, httpd was reading the
input file too quickly and could run out of memory when filling the
input buffer.

Found by jsg@@
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.31 2014/08/06 04:39:50 jsg Exp $	*/
d693 1
a693 1
	server_close(clt, "done");
d734 1
a734 1
	server_close(clt, "done");
@


1.31
log
@add missing va_start/va_end calls
ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.30 2014/08/06 02:04:42 jsing Exp $	*/
d634 1
d644 7
d667 4
@


1.30
log
@Load the SSL public/private keys in the parent process, then provide them
to the privsep process via imsg. This allows the keys to be moved out of
the chroot (now /etc/ssl/server.crt, /etc/ssl/private/server.key).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.29 2014/08/05 15:36:59 reyk Exp $	*/
d927 1
d932 1
@


1.29
log
@Improve logging to allow per- server/location log files.  The log
files can also be owned by root now: they're opened by the parent and
send to the logger process with fd passing.  This also works with reload.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.28 2014/08/04 18:12:15 reyk Exp $	*/
d119 51
d191 4
a194 6
	/*
	 * XXX Make these configurable and move keys out of the chroot.
	 * XXX The RSA privsep code in relayd should be adopted to ressl.
	 */
	ressl_config_set_cert_file(srv->srv_ressl_config, HTTPD_SSL_CERT);
	ressl_config_set_key_file(srv->srv_ressl_config, HTTPD_SSL_KEY);
d202 6
d281 3
a283 1
		if (srv_conf != &srv->srv_conf)
d285 1
@


1.28
log
@Temporarily move the default location of the SSL/TLS server key and
certificate from /var/www/ to /var/www/conf/.  Don't get scared - this
will be changed soon!  They're currently located in the chroot
directory but will be moved outside as soon as we adopted some of the
key privsep from relayd in ressl/httpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.27 2014/08/04 17:38:12 reyk Exp $	*/
d25 1
d40 1
d251 37
d861 1
a861 1
server_log_access(const char *emsg, ...)
d863 4
a866 3
	va_list	 ap;
	char	*msg;
	int	 ret;
d868 5
a872 5
	va_start(ap, emsg);
	ret = vasprintf(&msg, emsg, ap);
	va_end(ap);
	if (ret == -1) {
		log_warn("%s: vasprintf", __func__);
a875 11
	proc_compose_imsg(env->sc_ps, PROC_LOGGER, -1,
	    IMSG_LOG_ACCESS, -1, msg, strlen(msg) + 1);
}

void
server_log_error(const char *emsg, ...)
{
	va_list	 ap;
	char	*msg;
	int	 ret;

d884 6
a889 2
	proc_compose_imsg(env->sc_ps, PROC_LOGGER, -1,
	    IMSG_LOG_ERROR, -1, msg, strlen(msg) + 1);
d898 1
a898 2
	void			(*log_infocb)(const char *, ...);
	void			(*log_debugcb)(const char *, ...);
a900 8
	if (srv_conf->flags & SRVFLAG_SYSLOG) {
		log_infocb = log_info;
		log_debugcb = log_debug;
	} else {
		log_infocb = server_log_access;
		log_debugcb = server_log_error;
	}

d903 1
a903 1
		log_debugcb = server_log_error;
d906 2
a907 2
		if (verbose <= 1)
			log_debugcb = NULL;
d911 2
a912 1
				(log_infocb)("%s", ptr);
d919 1
a919 1
	if (log_debugcb != NULL && msg != NULL) {
d927 1
a927 1
		(log_debugcb)("server %s, "
@


1.27
log
@Proxy commit for jsing@@:
"Add TLS/SSL support to httpd, based on the recent ressl commits."

From jsing@@
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.26 2014/08/04 15:49:28 reyk Exp $	*/
d138 6
a143 3
	/* XXX - make these configurable. */
	ressl_config_set_cert_file(srv->srv_ressl_config, "/server.crt");
	ressl_config_set_key_file(srv->srv_ressl_config, "/server.key");
@


1.26
log
@Add initial support for log files in /var/www/logs/.  Logging with
syslog is still supported but disabled by default.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.25 2014/08/04 11:09:25 reyk Exp $	*/
d45 1
d62 4
d67 1
d117 34
d182 1
d225 3
d411 118
d536 1
a536 2
		server_close(clt,
		    "failed to allocate http descriptor");
d553 7
d588 2
d599 2
a600 3
#if 0
	if (cre->ssl != NULL)
		(void)SSL_write(cre->ssl, buf, len);
a601 1
#endif
d744 7
d768 35
d940 4
@


1.25
log
@httpd doesn't support SSL/TLS yet, remove the remaining bits.
The secrect plan is to add it later using the ressl wrapper library.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.24 2014/08/03 20:43:03 reyk Exp $	*/
d50 2
d75 2
a76 1
	{ "parent",	PROC_PARENT,	server_dispatch_parent }
d609 38
d652 11
a662 2
	void			(*log_cb)(const char *, ...) = NULL;
	extern int		 debug;
d666 1
a666 1
		log_cb = log_info;
d669 2
a670 2
		if (debug)
			log_cb = log_debug;
d674 1
a674 1
				log_info("%s", ptr);
d681 1
a681 1
	if (log_cb != NULL && msg != NULL) {
d689 1
a689 1
		log_cb("server %s, "
d759 11
@


1.24
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.23 2014/08/03 10:26:44 reyk Exp $	*/
a44 3

#include <openssl/dh.h>
#include <openssl/ssl.h>
@


1.23
log
@Add another log mode "connection" for a relayd(8)-style log entry after
each connection, not every request.  The code was already there and enabled
on debug, I just turned it into an alternative log format.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.22 2014/08/02 11:52:01 reyk Exp $	*/
d262 1
a262 1
			sizeof(int)) == -1)
d626 1
a626 1
			   evbuffer_readline(clt->clt_log)) != NULL) {
@


1.22
log
@Allow to specify a FastCGI TCP socket on localhost (eg. :9000).  Used
for debugging, you should prefer local UNIX sockets, but it helped to
find an issue that will be fixed with the next commit.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.21 2014/08/01 22:24:05 reyk Exp $	*/
d609 1
a609 1
server_log(struct client *clt)
d611 5
a615 1
	char		*ptr = NULL;
d617 16
a632 2
	if (!EVBUFFER_LENGTH(clt->clt_log))
		return;
d634 15
a648 3
	while ((ptr = evbuffer_readline(clt->clt_log)) != NULL) {
		log_info("%s", ptr);
		free(ptr);
a654 1
	char			 ibuf[MAXHOSTNAMELEN], obuf[MAXHOSTNAMELEN];
a655 2
	struct server_config	*srv_conf = clt->clt_srv_conf;
	extern int		 debug;
d668 1
a668 12
	server_log(clt);

	if (debug && msg != NULL) {
		memset(&ibuf, 0, sizeof(ibuf));
		memset(&obuf, 0, sizeof(obuf));
		(void)print_host(&clt->clt_ss, ibuf, sizeof(ibuf));
		(void)server_http_host(&clt->clt_srv_ss, obuf, sizeof(obuf));
		log_debug("server %s, "
		    "client %d (%d active), %s:%u -> %s, "
		    "%s", srv_conf->name, clt->clt_id, server_clients,
		    ibuf, ntohs(clt->clt_port), obuf, msg);
	}
@


1.21
log
@Use the log buffer to defer the logging until the connection is closed
or the request completed.  Turn the old log message into a debug message.

ok doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.20 2014/08/01 21:59:56 reyk Exp $	*/
d337 21
@


1.20
log
@remove the global "log updates/all" option that came from relayd.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.19 2014/08/01 08:34:46 florian Exp $	*/
d588 14
a604 1
	char			*ptr = NULL;
d607 1
d620 3
a622 1
	if (msg != NULL) {
d627 1
a627 4
		if (EVBUFFER_LENGTH(clt->clt_log) &&
		    evbuffer_add_printf(clt->clt_log, "\r\n") != -1)
			ptr = evbuffer_readline(clt->clt_log);
		log_info("server %s, "
d629 2
a630 5
		    "%s%s%s", srv_conf->name, clt->clt_id, server_clients,
		    ibuf, ntohs(clt->clt_port), obuf, msg,
		    ptr == NULL ? "" : ",", ptr == NULL ? "" : ptr);
		if (ptr != NULL)
			free(ptr);
@


1.19
log
@Correctly parse fcgi records if we don't get the whole record in one
bufferevent_read().
Input/OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.18 2014/07/31 14:25:14 reyk Exp $	*/
d606 1
a606 1
	if ((env->sc_opts & HTTPD_OPT_LOGUPDATE) && msg != NULL) {
@


1.18
log
@One bufferevent can be shared by file and fcgi.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.17 2014/07/30 13:49:48 reyk Exp $	*/
d627 2
@


1.17
log
@Make "location" work with name-based virtual servers.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.16 2014/07/30 10:05:14 reyk Exp $	*/
d603 2
a604 2
	if (clt->clt_file != NULL)
		bufferevent_disable(clt->clt_file, EV_READ|EV_WRITE);
d628 2
a629 2
	if (clt->clt_file != NULL)
		bufferevent_free(clt->clt_file);
@


1.16
log
@Add "location" keyword to specify path-specific configuration in
servers, for example auto index for a sub-directory only.  Internally,
a "location" is just a special type of a "virtual" server.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.15 2014/07/29 16:38:34 reyk Exp $	*/
a195 13
			return (srv);
	}

	return (NULL);
}

struct server *
server_byname(const char *name)
{
	struct server	*srv;

	TAILQ_FOREACH(srv, env->sc_servers, srv_entry) {
		if (strcmp(srv->srv_conf.name, name) == 0)
@


1.15
log
@The inflight decremented message should only be printed with DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.14 2014/07/29 12:16:36 reyk Exp $	*/
d99 3
d196 13
@


1.14
log
@Move configurable TCP options into struct server_config.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.13 2014/07/25 23:30:58 reyk Exp $	*/
d580 1
a580 1
	log_debug("%s: inflight decremented, now %d, %s",
@


1.13
log
@Differentiate servers by address and port, not just by address.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.12 2014/07/25 23:23:39 reyk Exp $	*/
d58 1
a58 1
		    struct server *, int, int);
d60 1
a60 1
		    struct server *);
d102 1
a102 1
	    srv->srv_conf.port, srv)) == -1)
d238 1
a238 1
    struct server *srv, int fd, int reuseport)
d264 2
a265 2
	if (srv->srv_tcpflags & TCPFLAG_BUFSIZ) {
		val = srv->srv_tcpbufsiz;
d269 1
a269 1
		val = srv->srv_tcpbufsiz;
d278 2
a279 2
	if (srv->srv_tcpflags & TCPFLAG_IPTTL) {
		val = (int)srv->srv_tcpipttl;
d284 2
a285 2
	if (srv->srv_tcpflags & TCPFLAG_IPMINTTL) {
		val = (int)srv->srv_tcpipminttl;
d294 2
a295 2
	if (srv->srv_tcpflags & (TCPFLAG_NODELAY|TCPFLAG_NNODELAY)) {
		if (srv->srv_tcpflags & TCPFLAG_NNODELAY)
d303 2
a304 2
	if (srv->srv_tcpflags & (TCPFLAG_SACK|TCPFLAG_NSACK)) {
		if (srv->srv_tcpflags & TCPFLAG_NSACK)
d323 1
a323 1
    struct server *srv)
d327 1
a327 1
	if ((s = server_socket(ss, port, srv, -1, 1)) == -1)
d332 1
a332 1
	if (listen(s, srv->srv_tcpbacklog) == -1)
@


1.12
log
@It is recommended to use a URL in the Location header of 3xx
responses.  To accomplish this, add some semantics to retrieve the
server host name of a connection: either IP, IP:PORT (if not 80) or
[IP6]:PORT, or Host value (if valid).
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.11 2014/07/25 16:23:19 reyk Exp $	*/
d185 1
a185 1
server_byaddr(struct sockaddr *addr)
d190 2
a191 1
		if (sockaddr_cmp((struct sockaddr *)&srv->srv_conf.ss,
@


1.11
log
@Add support for "virtual hosts" aka. server blocks aka. multiple
servers with the same or "overlapping" IP address but a different name.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.10 2014/07/25 13:10:18 reyk Exp $	*/
d506 13
a526 1
	memcpy(&clt->clt_ss, &ss, sizeof(clt->clt_ss));
d586 2
a587 1
	char			 ibuf[128], obuf[128], *ptr = NULL;
d606 1
a606 1
		(void)print_host(&srv_conf->ss, obuf, sizeof(obuf));
d611 1
a611 1
		    "client %d (%d active), %s -> %s:%d, "
d613 1
a613 1
		    ibuf, obuf, ntohs(clt->clt_port), msg,
@


1.10
log
@Split server and server_config.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.9 2014/07/25 12:46:23 reyk Exp $	*/
d154 2
a155 1
	struct client	*clt;
d171 10
d182 14
@


1.9
log
@Rename a field, needed later, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.8 2014/07/24 08:32:36 reyk Exp $	*/
d319 3
a321 3
	struct server	*srv = clt->clt_srv;
	evbuffercb	 inrd = server_read;
	evbuffercb	 inwr = server_write;
d343 1
a343 1
	    srv->srv_conf.timeout.tv_sec, srv->srv_conf.timeout.tv_sec);
d476 1
d549 3
a551 2
	char		 ibuf[128], obuf[128], *ptr = NULL;
	struct server	*srv = clt->clt_srv;
d568 1
a568 1
		(void)print_host(&srv->srv_conf.ss, obuf, sizeof(obuf));
d574 1
a574 1
		    "%s%s%s", srv->srv_conf.name, clt->clt_id, server_clients,
@


1.8
log
@Plug a memleak by correctly free'ing the HTTP descriptor that contains
all the headers etc. of a connection.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.7 2014/07/23 13:26:39 reyk Exp $	*/
d319 1
a319 1
	struct server	*srv = clt->clt_server;
d475 1
a475 1
	clt->clt_server = srv;
d477 1
a477 1
	clt->clt_serverid = srv->srv_conf.id;
d549 1
a549 1
	struct server	*srv = clt->clt_server;
@


1.7
log
@Correctly shutdown the servers when the process is terminating;
prevents a crash on exit.  With debugging help from blambert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.6 2014/07/16 10:25:28 reyk Exp $	*/
d553 3
d581 1
a581 1
	else if (clt->clt_output != NULL)
@


1.6
log
@Implement file descriptor accounting.  The concept was taken from
relayd but had to be adjusted for httpd.  It now handles single-pass
HTTP connections, persistent connections with multiple requests, and
body-less HEAD requests.  With input from benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.5 2014/07/14 00:19:48 reyk Exp $	*/
d149 22
@


1.5
log
@first step towards keep-alive/persistent connections support
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.4 2014/07/13 15:07:50 reyk Exp $	*/
a391 1
	struct evbuffer		*dst;
d405 1
a405 14

		if (bev != clt->clt_bev) {
			dst = EVBUFFER_OUTPUT(clt->clt_bev);
			if (EVBUFFER_LENGTH(dst))
				return;
		} else
			return;

		if (clt->clt_persist) {
			server_reset_http(clt);
			bufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);
			return;
		} else
			server_close(clt, "done");
d457 1
d503 1
a503 3
		server_inflight--;
		log_debug("%s: inflight decremented, now %d",
		    __func__, server_inflight);
d508 16
d563 2
d566 1
a566 12
	if (clt->clt_s != -1) {
		close(clt->clt_s);
		if (/* XXX */ -1) {
			/*
			 * the output was never connected,
			 * thus this was an inflight client.
			 */
			server_inflight--;
			log_debug("%s: clients inflight decremented, now %d",
			    __func__, server_inflight);
		}
	}
@


1.4
log
@Finish writing the output before closing the connection
(adopted from relayd).
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.3 2014/07/13 14:46:52 reyk Exp $	*/
d329 5
d414 6
a419 1
		server_close(clt, "done");
@


1.3
log
@Close the connection after the response is completed (no Keepalive yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.2 2014/07/13 14:17:37 reyk Exp $	*/
d387 1
d401 8
a409 1

@


1.2
log
@Add support for media types (aka. MIME types): the types section is
compatible to nginx' mime.types file which can be included directly.
If not present, use a few built-in defaults for html, css, txt, jpeg,
gif, png, and js.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.1 2014/07/12 23:34:54 reyk Exp $	*/
d400 1
a402 1
//		server_close(con, "done");
@


1.1
log
@Add httpd(8), an attempt to turn the relayd(8) codebase into a simple
web server.  It is not finished yet and I just started it today, but
the goal is to provide an HTTP server that a) provides minimal
features, b) serves static files, c) provides FastCGI support, and d)
follows common coding practices of OpenBSD.

It will neither support plugins, nor custom memory allocators, EBCDIC
support, PCRE or any other things that can be found elsewhere.
httpd(8) is not intended to provide a fully-featured replacement for
nginx(8) or the Apache, but it will provide enough functionality that
is needed in the OpenBSD base system.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d569 3
@

