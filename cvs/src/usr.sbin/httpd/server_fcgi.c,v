head	1.74;
access;
symbols
	OPENBSD_6_0:1.68.0.2
	OPENBSD_6_0_BASE:1.68
	OPENBSD_5_9:1.67.0.2
	OPENBSD_5_9_BASE:1.67
	OPENBSD_5_8:1.63.0.4
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.29.0.2
	OPENBSD_5_6_BASE:1.29;
locks; strict;
comment	@ * @;


1.74
date	2017.01.21.11.32.04;	author guenther;	state Exp;
branches;
next	1.73;
commitid	DpBZlpar7mq0CJFq;

1.73
date	2016.10.07.07.37.29;	author patrick;	state Exp;
branches;
next	1.72;
commitid	Hz4c5yf9qgQaHh39;

1.72
date	2016.10.07.07.33.54;	author patrick;	state Exp;
branches;
next	1.71;
commitid	xh7H0EmJPFfnMwXZ;

1.71
date	2016.09.01.11.13.18;	author florian;	state Exp;
branches;
next	1.70;
commitid	RC3HXj7tjvlwnsNW;

1.70
date	2016.09.01.10.59.38;	author reyk;	state Exp;
branches;
next	1.69;
commitid	a0vgTMcaG5L6YvdV;

1.69
date	2016.08.30.10.54.42;	author florian;	state Exp;
branches;
next	1.68;
commitid	DrhLELl2yXwxn1oo;

1.68
date	2016.04.24.20.09.45;	author chrisz;	state Exp;
branches;
next	1.67;
commitid	KfJqLRgIpnkMekd4;

1.67
date	2015.11.23.20.56.15;	author reyk;	state Exp;
branches;
next	1.66;
commitid	V1t7bAFyH2Xn6Kqj;

1.66
date	2015.10.08.09.40.32;	author jsg;	state Exp;
branches;
next	1.65;
commitid	0J0q7Q8rpgFNUPvD;

1.65
date	2015.10.08.09.32.13;	author jsg;	state Exp;
branches;
next	1.64;
commitid	4bGLq78CBlB1yMAL;

1.64
date	2015.08.20.13.00.23;	author reyk;	state Exp;
branches;
next	1.63;
commitid	WDQybNKi4LiEFw8K;

1.63
date	2015.08.03.11.45.17;	author florian;	state Exp;
branches;
next	1.62;
commitid	R0hlkHQJt4QQvq7o;

1.62
date	2015.07.31.00.10.51;	author benno;	state Exp;
branches;
next	1.61;
commitid	fAnDDuLHMOr8xOWK;

1.61
date	2015.07.29.22.03.41;	author reyk;	state Exp;
branches;
next	1.60;
commitid	rol6YjSk5cC38ac4;

1.60
date	2015.07.29.20.03.14;	author florian;	state Exp;
branches;
next	1.59;
commitid	UvkQRTHkUu4OhiEw;

1.59
date	2015.07.28.10.13.42;	author florian;	state Exp;
branches;
next	1.58;
commitid	56VJo3sOrqcfbiEf;

1.58
date	2015.07.19.16.34.35;	author blambert;	state Exp;
branches;
next	1.57;
commitid	3Bw9Pj95V9rkHcnv;

1.57
date	2015.07.18.22.42.24;	author blambert;	state Exp;
branches;
next	1.56;
commitid	xjBNjKP3YMSnAfWD;

1.56
date	2015.07.18.16.42.39;	author blambert;	state Exp;
branches;
next	1.55;
commitid	9zZz9mLTamRQTOZO;

1.55
date	2015.07.17.20.44.57;	author reyk;	state Exp;
branches;
next	1.54;
commitid	OsQz0mXYIXoKSGCG;

1.54
date	2015.06.09.08.50.52;	author jung;	state Exp;
branches;
next	1.53;
commitid	p4wYCukX9riMfwi2;

1.53
date	2015.03.26.09.01.51;	author florian;	state Exp;
branches;
next	1.52;
commitid	2FBXWSvR54DjGbv9;

1.52
date	2015.02.23.19.22.43;	author chrisz;	state Exp;
branches;
next	1.51;
commitid	uw8yeSn1kZqwdz0b;

1.51
date	2015.01.21.22.23.24;	author reyk;	state Exp;
branches;
next	1.50;
commitid	TdBP3Ps5E1MgPmyk;

1.50
date	2015.01.21.22.21.05;	author reyk;	state Exp;
branches;
next	1.49;
commitid	64Zc6bef54Vu2Noy;

1.49
date	2015.01.19.20.00.07;	author florian;	state Exp;
branches;
next	1.48;
commitid	uDWn7Rj546an5NG2;

1.48
date	2015.01.19.19.37.50;	author reyk;	state Exp;
branches;
next	1.47;
commitid	95e2Z6BqzOOfEsll;

1.47
date	2015.01.18.14.01.17;	author florian;	state Exp;
branches;
next	1.46;
commitid	7n1dHfzjQzsDnx3e;

1.46
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	Uu5nFG3wCl0LACBb;

1.45
date	2015.01.13.08.54.01;	author reyk;	state Exp;
branches;
next	1.44;
commitid	0Jft4oLyBDerF2Bp;

1.44
date	2015.01.04.22.23.58;	author chrisz;	state Exp;
branches;
next	1.43;
commitid	PxQkOIiHP7NqIPYy;

1.43
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.42;
commitid	XnjIOhurXdX5o1V9;

1.42
date	2014.12.12.14.45.59;	author reyk;	state Exp;
branches;
next	1.41;
commitid	j2F3LZ1OyONol7u9;

1.41
date	2014.12.04.02.44.42;	author tedu;	state Exp;
branches;
next	1.40;
commitid	A2H8wpKaas7ra1zW;

1.40
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.39;
commitid	2uw1UTO4k6erpWzK;

1.39
date	2014.09.29.19.30.47;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	MS0GNEU2JBJZ5mx1;

1.38
date	2014.09.02.16.20.41;	author reyk;	state Exp;
branches;
next	1.37;
commitid	Z5PKhfXhMri1amPw;

1.37
date	2014.09.01.12.28.11;	author reyk;	state Exp;
branches;
next	1.36;
commitid	nmHcNAREi5kGe99Q;

1.36
date	2014.09.01.09.32.43;	author reyk;	state Exp;
branches;
next	1.35;
commitid	jMu1buTp6ZpC9q0x;

1.35
date	2014.08.29.13.01.46;	author reyk;	state Exp;
branches;
next	1.34;
commitid	s1q2vKQd3ZNYgiRk;

1.34
date	2014.08.21.19.23.10;	author chrisz;	state Exp;
branches;
next	1.33;
commitid	JCs4fDUGf9JXsJFG;

1.33
date	2014.08.13.18.00.54;	author chrisz;	state Exp;
branches;
next	1.32;
commitid	YK5ljTpEGzYshx1K;

1.32
date	2014.08.13.16.04.28;	author reyk;	state Exp;
branches;
next	1.31;
commitid	rO4nAEntB2c9vXlM;

1.31
date	2014.08.11.15.26.33;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	smXMhDejg5Cb0w4h;

1.30
date	2014.08.08.18.29.42;	author reyk;	state Exp;
branches;
next	1.29;
commitid	J4bMyiFa6dPdfodH;

1.29
date	2014.08.07.12.43.22;	author florian;	state Exp;
branches
	1.29.2.1;
next	1.28;
commitid	DffkHnAs7gX3mPy3;

1.28
date	2014.08.07.10.52.34;	author florian;	state Exp;
branches;
next	1.27;
commitid	lLboq6Th9WODTWYm;

1.27
date	2014.08.06.21.08.47;	author reyk;	state Exp;
branches;
next	1.26;
commitid	PQ8QU755jvS8eLoN;

1.26
date	2014.08.06.20.56.23;	author florian;	state Exp;
branches;
next	1.25;
commitid	QfzlnDkT2tmovjuj;

1.25
date	2014.08.06.18.40.15;	author reyk;	state Exp;
branches;
next	1.24;
commitid	7S5dYsM7QGo06eer;

1.24
date	2014.08.06.18.38.11;	author reyk;	state Exp;
branches;
next	1.23;
commitid	QwIkF9OyNOAMdals;

1.23
date	2014.08.06.15.08.04;	author florian;	state Exp;
branches;
next	1.22;
commitid	JiDxX0IDmc7NLOCZ;

1.22
date	2014.08.06.13.40.18;	author florian;	state Exp;
branches;
next	1.21;
commitid	VY8rb60iAnEjGyYC;

1.21
date	2014.08.04.18.00.06;	author reyk;	state Exp;
branches;
next	1.20;
commitid	PmcJTI0LH9gT1u3y;

1.20
date	2014.08.04.14.49.24;	author reyk;	state Exp;
branches;
next	1.19;
commitid	vp0mWPeKkmrTbblJ;

1.19
date	2014.08.04.11.09.25;	author reyk;	state Exp;
branches;
next	1.18;
commitid	Dj6ALT3dpIHqBQcw;

1.18
date	2014.08.03.22.06.51;	author florian;	state Exp;
branches;
next	1.17;
commitid	cSZswwhT6ncEldfc;

1.17
date	2014.08.03.20.43.03;	author reyk;	state Exp;
branches;
next	1.16;
commitid	TtWvHWpY8PUl6hQO;

1.16
date	2014.08.03.20.39.40;	author reyk;	state Exp;
branches;
next	1.15;
commitid	SI4ST45AyhzT510m;

1.15
date	2014.08.03.12.26.19;	author reyk;	state Exp;
branches;
next	1.14;
commitid	nLaH9MjCgoWopkfz;

1.14
date	2014.08.03.11.16.10;	author reyk;	state Exp;
branches;
next	1.13;
commitid	fIgJJaAKavK3V1Ms;

1.13
date	2014.08.03.10.38.42;	author reyk;	state Exp;
branches;
next	1.12;
commitid	lpiW4RIQS9K1qof1;

1.12
date	2014.08.02.17.42.24;	author florian;	state Exp;
branches;
next	1.11;
commitid	I8kTPaecxqxpxLX2;

1.11
date	2014.08.02.17.05.18;	author florian;	state Exp;
branches;
next	1.10;
commitid	Jee6bm4wBB35H4JN;

1.10
date	2014.08.02.11.59.04;	author florian;	state Exp;
branches;
next	1.9;
commitid	7Eu2GywYiMY9AEGz;

1.9
date	2014.08.02.11.52.01;	author reyk;	state Exp;
branches;
next	1.8;
commitid	bdxHYKjcY9PJGrJu;

1.8
date	2014.08.02.09.54.13;	author reyk;	state Exp;
branches;
next	1.7;
commitid	5XKYTFjUCKotRnfJ;

1.7
date	2014.08.01.18.26.32;	author florian;	state Exp;
branches;
next	1.6;
commitid	7kiPG4alSYMFQqzT;

1.6
date	2014.08.01.08.34.46;	author florian;	state Exp;
branches;
next	1.5;
commitid	SQpmoq716KYwsw94;

1.5
date	2014.07.31.18.07.11;	author reyk;	state Exp;
branches;
next	1.4;
commitid	vNGac2qPq7P5adZU;

1.4
date	2014.07.31.17.55.09;	author reyk;	state Exp;
branches;
next	1.3;
commitid	2oJScuzXVXi93eTv;

1.3
date	2014.07.31.14.25.14;	author reyk;	state Exp;
branches;
next	1.2;
commitid	QkmIVLoOhhCQIxFE;

1.2
date	2014.07.31.14.18.38;	author reyk;	state Exp;
branches;
next	1.1;
commitid	YuIDlOouHxlacCk2;

1.1
date	2014.07.31.09.23.53;	author florian;	state Exp;
branches;
next	;
commitid	4jka4N6hQtuBEhDN;

1.29.2.1
date	2014.11.20.07.48.45;	author jasper;	state Exp;
branches;
next	;
commitid	aoUNgrdXQt2mQs98;


desc
@@


1.74
log
@The POSIX APIs that that sockaddrs all ignore the s*_len field in the
incoming socket, so userspace doesn't need to set it unless it has its
own reasons for tracking the size along with the sockaddr.

ok phessler@@ deraadt@@ florian@@
@
text
@/*	$OpenBSD: server_fcgi.c,v 1.73 2016/10/07 07:37:29 patrick Exp $	*/

/*
 * Copyright (c) 2014 Florian Obser <florian@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <limits.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <ctype.h>
#include <event.h>
#include <unistd.h>

#include "httpd.h"
#include "http.h"

#define FCGI_PADDING_SIZE	 255
#define FCGI_RECORD_SIZE	 \
    (sizeof(struct fcgi_record_header) + FCGI_CONTENT_SIZE + FCGI_PADDING_SIZE)

#define FCGI_BEGIN_REQUEST	 1
#define FCGI_ABORT_REQUEST	 2
#define FCGI_END_REQUEST	 3
#define FCGI_PARAMS		 4
#define FCGI_STDIN		 5
#define FCGI_STDOUT		 6
#define FCGI_STDERR		 7
#define FCGI_DATA		 8
#define FCGI_GET_VALUES		 9
#define FCGI_GET_VALUES_RESULT	10
#define FCGI_UNKNOWN_TYPE	11
#define FCGI_MAXTYPE		(FCGI_UNKNOWN_TYPE)

#define FCGI_RESPONDER		 1

struct fcgi_record_header {
	uint8_t		version;
	uint8_t		type;
	uint16_t	id;
	uint16_t	content_len;
	uint8_t		padding_len;
	uint8_t		reserved;
} __packed;

struct fcgi_begin_request_body {
	uint16_t	role;
	uint8_t		flags;
	uint8_t		reserved[5];
} __packed;

struct server_fcgi_param {
	int		total_len;
	uint8_t		buf[FCGI_RECORD_SIZE];
};

int	server_fcgi_header(struct client *, unsigned int);
void	server_fcgi_read(struct bufferevent *, void *);
int	server_fcgi_writeheader(struct client *, struct kv *, void *);
int	server_fcgi_writechunk(struct client *);
int	server_fcgi_getheaders(struct client *);
int	fcgi_add_param(struct server_fcgi_param *, const char *, const char *,
	    struct client *);

int
server_fcgi(struct httpd *env, struct client *clt)
{
	struct server_fcgi_param	 param;
	struct server_config		*srv_conf = clt->clt_srv_conf;
	struct http_descriptor		*desc = clt->clt_descreq;
	struct fcgi_record_header	*h;
	struct fcgi_begin_request_body	*begin;
	char				 hbuf[HOST_NAME_MAX+1];
	size_t				 scriptlen;
	int				 pathlen;
	int				 fd = -1, ret;
	const char			*stripped, *p, *alias, *errstr = NULL;
	char				*str, *script = NULL;

	if (srv_conf->socket[0] == ':') {
		struct sockaddr_storage	 ss;
		in_port_t		 port;

		p = srv_conf->socket + 1;

		port = strtonum(p, 0, 0xffff, &errstr);
		if (errstr != NULL) {
			log_warn("%s: strtonum %s, %s", __func__, p, errstr);
			goto fail;
		}
		memset(&ss, 0, sizeof(ss));
		ss.ss_family = AF_INET;
		((struct sockaddr_in *)
		    &ss)->sin_addr.s_addr = htonl(INADDR_LOOPBACK);
		port = htons(port);

		if ((fd = server_socket_connect(&ss, port, srv_conf)) == -1)
			goto fail;
	} else {
		struct sockaddr_un	 sun;

		if ((fd = socket(AF_UNIX,
		    SOCK_STREAM | SOCK_NONBLOCK, 0)) == -1)
			goto fail;

		memset(&sun, 0, sizeof(sun));
		sun.sun_family = AF_UNIX;
		if (strlcpy(sun.sun_path, srv_conf->socket,
		    sizeof(sun.sun_path)) >= sizeof(sun.sun_path)) {
			errstr = "socket path to long";
			goto fail;
		}

		if (connect(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1)
			goto fail;
	}

	memset(hbuf, 0, sizeof(hbuf));
	clt->clt_fcgi.state = FCGI_READ_HEADER;
	clt->clt_fcgi.toread = sizeof(struct fcgi_record_header);
	clt->clt_fcgi.status = 200;
	clt->clt_fcgi.headersdone = 0;

	if (clt->clt_srvevb != NULL)
		evbuffer_free(clt->clt_srvevb);

	clt->clt_srvevb = evbuffer_new();
	if (clt->clt_srvevb == NULL) {
		errstr = "failed to allocate evbuffer";
		goto fail;
	}

	close(clt->clt_fd);
	clt->clt_fd = fd;

	if (clt->clt_srvbev != NULL)
		bufferevent_free(clt->clt_srvbev);

	clt->clt_srvbev_throttled = 0;
	clt->clt_srvbev = bufferevent_new(fd, server_fcgi_read,
	    NULL, server_file_error, clt);
	if (clt->clt_srvbev == NULL) {
		errstr = "failed to allocate fcgi buffer event";
		goto fail;
	}

	memset(&param, 0, sizeof(param));

	h = (struct fcgi_record_header *)&param.buf;
	h->version = 1;
	h->type = FCGI_BEGIN_REQUEST;
	h->id = htons(1);
	h->content_len = htons(sizeof(struct fcgi_begin_request_body));
	h->padding_len = 0;

	begin = (struct fcgi_begin_request_body *)&param.buf[sizeof(struct
	    fcgi_record_header)];
	begin->role = htons(FCGI_RESPONDER);

	if (bufferevent_write(clt->clt_srvbev, &param.buf,
	    sizeof(struct fcgi_record_header) +
	    sizeof(struct fcgi_begin_request_body)) == -1) {
		errstr = "failed to write to evbuffer";
		goto fail;
	}

	h->type = FCGI_PARAMS;
	h->content_len = param.total_len = 0;

	alias = desc->http_path_alias != NULL
	    ? desc->http_path_alias
	    : desc->http_path;

	stripped = server_root_strip(alias, srv_conf->strip);
	if ((pathlen = asprintf(&script, "%s%s", srv_conf->root, stripped))
	    == -1) {
		errstr = "failed to get script name";
		goto fail;
	}

	scriptlen = path_info(script);
	/*
	 * no part of root should show up in PATH_INFO.
	 * therefore scriptlen should be >= strlen(root)
	 */
	if (scriptlen < strlen(srv_conf->root))
		scriptlen = strlen(srv_conf->root);
	if ((int)scriptlen < pathlen) {
		if (fcgi_add_param(&param, "PATH_INFO",
		    script + scriptlen, clt) == -1) {
			errstr = "failed to encode param";
			goto fail;
		}
		script[scriptlen] = '\0';
	} else {
		/* RFC 3875 mandates that PATH_INFO is empty if not set */
		if (fcgi_add_param(&param, "PATH_INFO", "", clt) == -1) {
			errstr = "failed to encode param";
			goto fail;
		}
	}

	/*
	 * calculate length of http SCRIPT_NAME:
	 * add length of stripped prefix,
	 * subtract length of prepended local root
	 */
	scriptlen += (stripped - alias) - strlen(srv_conf->root);
	if ((str = strndup(alias, scriptlen)) == NULL)
		goto fail;
	ret = fcgi_add_param(&param, "SCRIPT_NAME", str, clt);
	free(str);
	if (ret == -1) {
		errstr = "failed to encode param";
		goto fail;
	}
	if (fcgi_add_param(&param, "SCRIPT_FILENAME", script, clt) == -1) {
		errstr = "failed to encode param";
		goto fail;
	}

	if (desc->http_query) {
		if (fcgi_add_param(&param, "QUERY_STRING", desc->http_query,
		    clt) == -1) {
			errstr = "failed to encode param";
			goto fail;
		}
	} else if (fcgi_add_param(&param, "QUERY_STRING", "", clt) == -1) {
		errstr = "failed to encode param";
		goto fail;
	}

	if (fcgi_add_param(&param, "DOCUMENT_ROOT", srv_conf->root,
	    clt) == -1) {
		errstr = "failed to encode param";
		goto fail;
	}
	if (fcgi_add_param(&param, "DOCUMENT_URI", alias,
	    clt) == -1) {
		errstr = "failed to encode param";
		goto fail;
	}
	if (fcgi_add_param(&param, "GATEWAY_INTERFACE", "CGI/1.1",
	    clt) == -1) {
		errstr = "failed to encode param";
		goto fail;
	}

	if (srv_conf->flags & SRVFLAG_AUTH) {
		if (fcgi_add_param(&param, "REMOTE_USER",
		    clt->clt_remote_user, clt) == -1) {
			errstr = "failed to encode param";
			goto fail;
		}
	}

	/* Add HTTP_* headers */
	if (server_headers(clt, desc, server_fcgi_writeheader, &param) == -1) {
		errstr = "failed to encode param";
		goto fail;
	}

	if (srv_conf->flags & SRVFLAG_TLS)
		if (fcgi_add_param(&param, "HTTPS", "on", clt) == -1) {
			errstr = "failed to encode param";
			goto fail;
		}

	(void)print_host(&clt->clt_ss, hbuf, sizeof(hbuf));
	if (fcgi_add_param(&param, "REMOTE_ADDR", hbuf, clt) == -1) {
		errstr = "failed to encode param";
		goto fail;
	}

	(void)snprintf(hbuf, sizeof(hbuf), "%d", ntohs(clt->clt_port));
	if (fcgi_add_param(&param, "REMOTE_PORT", hbuf, clt) == -1) {
		errstr = "failed to encode param";
		goto fail;
	}

	if (fcgi_add_param(&param, "REQUEST_METHOD",
	    server_httpmethod_byid(desc->http_method), clt) == -1) {
		errstr = "failed to encode param";
		goto fail;
	}

	if (!desc->http_query) {
		if (fcgi_add_param(&param, "REQUEST_URI", desc->http_path,
		    clt) == -1) {
			errstr = "failed to encode param";
			goto fail;
		}
	} else {
		if (asprintf(&str, "%s?%s", desc->http_path,
		    desc->http_query) == -1) {
			errstr = "failed to encode param";
			goto fail;
		}
		ret = fcgi_add_param(&param, "REQUEST_URI", str, clt);
		free(str);
		if (ret == -1) {
			errstr = "failed to encode param";
			goto fail;
		}
	}

	(void)print_host(&clt->clt_srv_ss, hbuf, sizeof(hbuf));
	if (fcgi_add_param(&param, "SERVER_ADDR", hbuf, clt) == -1) {
		errstr = "failed to encode param";
		goto fail;
	}

	(void)snprintf(hbuf, sizeof(hbuf), "%d",
	    ntohs(server_socket_getport(&clt->clt_srv_ss)));
	if (fcgi_add_param(&param, "SERVER_PORT", hbuf, clt) == -1) {
		errstr = "failed to encode param";
		goto fail;
	}

	if (fcgi_add_param(&param, "SERVER_NAME", srv_conf->name,
	    clt) == -1) {
		errstr = "failed to encode param";
		goto fail;
	}

	if (fcgi_add_param(&param, "SERVER_PROTOCOL", desc->http_version,
	    clt) == -1) {
		errstr = "failed to encode param";
		goto fail;
	}

	if (fcgi_add_param(&param, "SERVER_SOFTWARE", HTTPD_SERVERNAME,
	    clt) == -1) {
		errstr = "failed to encode param";
		goto fail;
	}

	if (param.total_len != 0) {	/* send last params record */
		if (bufferevent_write(clt->clt_srvbev, &param.buf,
		    sizeof(struct fcgi_record_header) +
		    ntohs(h->content_len)) == -1) {
			errstr = "failed to write to client evbuffer";
			goto fail;
		}
	}

	/* send "no more params" message */
	h->content_len = 0;
	if (bufferevent_write(clt->clt_srvbev, &param.buf,
	    sizeof(struct fcgi_record_header)) == -1) {
		errstr = "failed to write to client evbuffer";
		goto fail;
	}

	bufferevent_settimeout(clt->clt_srvbev,
	    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);
	bufferevent_enable(clt->clt_srvbev, EV_READ|EV_WRITE);
	if (clt->clt_toread != 0) {
		server_read_httpcontent(clt->clt_bev, clt);
		bufferevent_enable(clt->clt_bev, EV_READ);
	} else {
		bufferevent_disable(clt->clt_bev, EV_READ);
		fcgi_add_stdin(clt, NULL);
	}

	if (strcmp(desc->http_version, "HTTP/1.1") == 0) {
		clt->clt_fcgi.chunked = 1;
	} else {
		/* HTTP/1.0 does not support chunked encoding */
		clt->clt_fcgi.chunked = 0;
		clt->clt_persist = 0;
	}
	clt->clt_fcgi.end = 0;
	clt->clt_done = 0;

	free(script);
	return (0);
 fail:
	free(script);
	if (errstr == NULL)
		errstr = strerror(errno);
	if (fd != -1 && clt->clt_fd != fd)
		close(fd);
	server_abort_http(clt, 500, errstr);
	return (-1);
}

int
fcgi_add_stdin(struct client *clt, struct evbuffer *evbuf)
{
	struct fcgi_record_header	h;

	memset(&h, 0, sizeof(h));
	h.version = 1;
	h.type = FCGI_STDIN;
	h.id = htons(1);
	h.padding_len = 0;

	if (evbuf == NULL) {
		h.content_len = 0;
		return bufferevent_write(clt->clt_srvbev, &h,
		    sizeof(struct fcgi_record_header));
	} else {
		h.content_len = htons(EVBUFFER_LENGTH(evbuf));
		if (bufferevent_write(clt->clt_srvbev, &h,
		    sizeof(struct fcgi_record_header)) == -1)
			return -1;
		return bufferevent_write_buffer(clt->clt_srvbev, evbuf);
	}
	return (0);
}

int
fcgi_add_param(struct server_fcgi_param *p, const char *key,
    const char *val, struct client *clt)
{
	struct fcgi_record_header	*h;
	int				 len = 0;
	int				 key_len = strlen(key);
	int				 val_len = strlen(val);
	uint8_t				*param;

	len += key_len + val_len;
	len += key_len > 127 ? 4 : 1;
	len += val_len > 127 ? 4 : 1;

	DPRINTF("%s: %s[%d] => %s[%d], total_len: %d", __func__, key, key_len,
	    val, val_len, p->total_len);

	if (len > FCGI_CONTENT_SIZE)
		return (-1);

	if (p->total_len + len > FCGI_CONTENT_SIZE) {
		if (bufferevent_write(clt->clt_srvbev, p->buf,
		    sizeof(struct fcgi_record_header) + p->total_len) == -1)
			return (-1);
		p->total_len = 0;
	}

	h = (struct fcgi_record_header *)p->buf;
	param = p->buf + sizeof(*h) + p->total_len;

	if (key_len > 127) {
		*param++ = ((key_len >> 24) & 0xff) | 0x80;
		*param++ = ((key_len >> 16) & 0xff);
		*param++ = ((key_len >> 8) & 0xff);
		*param++ = (key_len & 0xff);
	} else
		*param++ = key_len;

	if (val_len > 127) {
		*param++ = ((val_len >> 24) & 0xff) | 0x80;
		*param++ = ((val_len >> 16) & 0xff);
		*param++ = ((val_len >> 8) & 0xff);
		*param++ = (val_len & 0xff);
	} else
		*param++ = val_len;

	memcpy(param, key, key_len);
	param += key_len;
	memcpy(param, val, val_len);

	p->total_len += len;

	h->content_len = htons(p->total_len);
	return (0);
}

void
server_fcgi_read(struct bufferevent *bev, void *arg)
{
	uint8_t				 buf[FCGI_RECORD_SIZE];
	struct client			*clt = (struct client *) arg;
	struct fcgi_record_header	*h;
	size_t				 len;
	char				*ptr;

	do {
		len = bufferevent_read(bev, buf, clt->clt_fcgi.toread);
		if (evbuffer_add(clt->clt_srvevb, buf, len) == -1) {
			server_abort_http(clt, 500, "short write");
			return;
		}
		clt->clt_fcgi.toread -= len;
		DPRINTF("%s: len: %lu toread: %d state: %d type: %d",
		    __func__, len, clt->clt_fcgi.toread,
		    clt->clt_fcgi.state, clt->clt_fcgi.type);

		if (clt->clt_fcgi.toread != 0)
			return;

		switch (clt->clt_fcgi.state) {
		case FCGI_READ_HEADER:
			clt->clt_fcgi.state = FCGI_READ_CONTENT;
			h = (struct fcgi_record_header *)
			    EVBUFFER_DATA(clt->clt_srvevb);
			DPRINTF("%s: record header: version %d type %d id %d "
			    "content len %d padding %d", __func__,
			    h->version, h->type, ntohs(h->id),
			    ntohs(h->content_len), h->padding_len);
			clt->clt_fcgi.type = h->type;
			clt->clt_fcgi.toread = ntohs(h->content_len);
			clt->clt_fcgi.padding_len = h->padding_len;
			evbuffer_drain(clt->clt_srvevb,
			    EVBUFFER_LENGTH(clt->clt_srvevb));
			if (clt->clt_fcgi.toread != 0)
				break;
			else if (clt->clt_fcgi.type == FCGI_STDOUT &&
			    !clt->clt_chunk) {
				server_abort_http(clt, 500, "empty stdout");
				return;
			}

			/* fallthrough if content_len == 0 */
		case FCGI_READ_CONTENT:
			switch (clt->clt_fcgi.type) {
			case FCGI_STDERR:
				if (EVBUFFER_LENGTH(clt->clt_srvevb) > 0 &&
				    (ptr = get_string(
				    EVBUFFER_DATA(clt->clt_srvevb),
				    EVBUFFER_LENGTH(clt->clt_srvevb)))
				    != NULL) {
					server_sendlog(clt->clt_srv_conf,
					    IMSG_LOG_ERROR, "%s", ptr);
					free(ptr);
				}
				break;
			case FCGI_STDOUT:
				++clt->clt_chunk;
				if (!clt->clt_fcgi.headersdone) {
					clt->clt_fcgi.headersdone =
					    server_fcgi_getheaders(clt);
					if (clt->clt_fcgi.headersdone) {
						if (server_fcgi_header(clt,
						    clt->clt_fcgi.status)
						    == -1) {
							server_abort_http(clt,
							    500,
							    "malformed fcgi "
							    "headers");
							return;
						}
					}
					if (!EVBUFFER_LENGTH(clt->clt_srvevb))
						break;
				}
				/* FALLTHROUGH */
			case FCGI_END_REQUEST:
				if (server_fcgi_writechunk(clt) == -1) {
					server_abort_http(clt, 500,
					    "encoding error");
					return;
				}
				break;
			}
			evbuffer_drain(clt->clt_srvevb,
			    EVBUFFER_LENGTH(clt->clt_srvevb));
			if (!clt->clt_fcgi.padding_len) {
				clt->clt_fcgi.state = FCGI_READ_HEADER;
				clt->clt_fcgi.toread =
				    sizeof(struct fcgi_record_header);
			} else {
				clt->clt_fcgi.state = FCGI_READ_PADDING;
				clt->clt_fcgi.toread =
				    clt->clt_fcgi.padding_len;
			}
			break;
		case FCGI_READ_PADDING:
			evbuffer_drain(clt->clt_srvevb,
			    EVBUFFER_LENGTH(clt->clt_srvevb));
			clt->clt_fcgi.state = FCGI_READ_HEADER;
			clt->clt_fcgi.toread =
			    sizeof(struct fcgi_record_header);
			break;
		}
	} while (len > 0);
}

int
server_fcgi_header(struct client *clt, unsigned int code)
{
	struct server_config	*srv_conf = clt->clt_srv_conf;
	struct http_descriptor	*desc = clt->clt_descreq;
	struct http_descriptor	*resp = clt->clt_descresp;
	const char		*error;
	char			 tmbuf[32];
	struct kv		*kv, *cl, key;

	if (desc == NULL || (error = server_httperror_byid(code)) == NULL)
		return (-1);

	if (server_log_http(clt, code, 0) == -1)
		return (-1);

	/* Add error codes */
	if (kv_setkey(&resp->http_pathquery, "%u", code) == -1 ||
	    kv_set(&resp->http_pathquery, "%s", error) == -1)
		return (-1);

	/* Add headers */
	if (kv_add(&resp->http_headers, "Server", HTTPD_SERVERNAME) == NULL)
		return (-1);

	/* Set chunked encoding */
	if (clt->clt_fcgi.chunked) {
		/* XXX Should we keep and handle Content-Length instead? */
		key.kv_key = "Content-Length";
		if ((kv = kv_find(&resp->http_headers, &key)) != NULL)
			kv_delete(&resp->http_headers, kv);

		/*
		 * XXX What if the FastCGI added some kind of Transfer-Encoding?
		 * XXX like gzip, deflate or even "chunked"?
		 */
		if (kv_add(&resp->http_headers,
		    "Transfer-Encoding", "chunked") == NULL)
			return (-1);
	}

	/* Is it a persistent connection? */
	if (clt->clt_persist) {
		if (kv_add(&resp->http_headers,
		    "Connection", "keep-alive") == NULL)
			return (-1);
	} else if (kv_add(&resp->http_headers, "Connection", "close") == NULL)
		return (-1);

	/* HSTS header */
	if (srv_conf->flags & SRVFLAG_SERVER_HSTS) {
		if ((cl =
		    kv_add(&resp->http_headers, "Strict-Transport-Security",
		    NULL)) == NULL ||
		    kv_set(cl, "max-age=%d%s%s", srv_conf->hsts_max_age,
		    srv_conf->hsts_flags & HSTSFLAG_SUBDOMAINS ?
		    "; includeSubDomains" : "",
		    srv_conf->hsts_flags & HSTSFLAG_PRELOAD ?
		    "; preload" : "") == -1)
			return (-1);
	}

	/* Date header is mandatory and should be added as late as possible */
	if (server_http_time(time(NULL), tmbuf, sizeof(tmbuf)) <= 0 ||
	    kv_add(&resp->http_headers, "Date", tmbuf) == NULL)
		return (-1);

	/* Write initial header (fcgi might append more) */
	if (server_writeresponse_http(clt) == -1 ||
	    server_bufferevent_print(clt, "\r\n") == -1 ||
	    server_headers(clt, resp, server_writeheader_http, NULL) == -1 ||
	    server_bufferevent_print(clt, "\r\n") == -1)
		return (-1);

	return (0);
}

int
server_fcgi_writeheader(struct client *clt, struct kv *hdr, void *arg)
{
	struct server_fcgi_param	*param = arg;
	char				*val, *name, *p;
	const char			*key;
	int				 ret;

	if (hdr->kv_flags & KV_FLAG_INVALID)
		return (0);

	/* The key might have been updated in the parent */
	if (hdr->kv_parent != NULL && hdr->kv_parent->kv_key != NULL)
		key = hdr->kv_parent->kv_key;
	else
		key = hdr->kv_key;

	val = hdr->kv_value;

	if (strcasecmp(key, "Content-Length") == 0 ||
	    strcasecmp(key, "Content-Type") == 0) {
		if ((name = strdup(key)) == NULL)
			return (-1);
	} else {
		if (asprintf(&name, "HTTP_%s", key) == -1)
			return (-1);
	}

	/*
	 * RFC 7230 defines a header field-name as a "token" and a "token"
	 * is defined as one or more characters for which isalpha or
	 * isdigit is true plus a list of additional characters.
	 * According to RFC 3875 a CGI environment variable is created
	 * by converting all letters to upper case and replacing '-'
	 * with '_'.
	 */
	for (p = name; *p != '\0'; p++) {
		if (isalpha((unsigned char)*p))
			*p = toupper((unsigned char)*p);
		else if (!(*p == '!' || *p == '#' || *p == '$' || *p == '%' ||
		    *p == '&' || *p == '\'' || *p == '*' || *p == '+' ||
		    *p == '.' || *p == '^' || *p == '_' || *p == '`' ||
		    *p == '|' || *p == '~' || isdigit((unsigned char)*p)))
			*p = '_';
	}

	ret = fcgi_add_param(param, name, val, clt);
	free(name);

	return (ret);
}

int
server_fcgi_writechunk(struct client *clt)
{
	struct evbuffer *evb = clt->clt_srvevb;
	size_t		 len;

	if (clt->clt_fcgi.type == FCGI_END_REQUEST) {
		len = 0;
	} else
		len = EVBUFFER_LENGTH(evb);

	if (clt->clt_fcgi.chunked) {
		/* If len is 0, make sure to write the end marker only once */
		if (len == 0 && clt->clt_fcgi.end++)
			return (0);
		if (server_bufferevent_printf(clt, "%zx\r\n", len) == -1 ||
		    server_bufferevent_write_chunk(clt, evb, len) == -1 ||
		    server_bufferevent_print(clt, "\r\n") == -1)
			return (-1);
	} else if (len)
		return (server_bufferevent_write_buffer(clt, evb));

	return (0);
}

int
server_fcgi_getheaders(struct client *clt)
{
	struct http_descriptor	*resp = clt->clt_descresp;
	struct evbuffer		*evb = clt->clt_srvevb;
	int			 code, ret;
	char			*line, *key, *value;
	const char		*errstr;

	while ((line = evbuffer_getline(evb)) != NULL && *line != '\0') {
		key = line;

		if ((value = strchr(key, ':')) == NULL)
			break;

		*value++ = '\0';
		value += strspn(value, " \t");

		DPRINTF("%s: %s: %s", __func__, key, value);

		if (strcasecmp("Status", key) == 0) {
			value[strcspn(value, " \t")] = '\0';
			code = (int)strtonum(value, 100, 600, &errstr);
			if (errstr != NULL || server_httperror_byid(
			    code) == NULL)
				code = 200;
			clt->clt_fcgi.status = code;
		} else {
			(void)kv_add(&resp->http_headers, key, value);
		}
		free(line);
	}

	ret = (line != NULL && *line == '\0');

	free(line);
	return ret;
}
@


1.73
log
@The strchr() call either returns a NULL pointer, on which the code will
break out of the loop, or a pointer to ':'.  Thus the extra check for
':' is unnecessary and can be removed.

ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.72 2016/10/07 07:33:54 patrick Exp $	*/
a122 1
		size_t			 len;
d130 3
a132 4
		len = strlcpy(sun.sun_path,
		    srv_conf->socket, sizeof(sun.sun_path));
		if (len >= sizeof(sun.sun_path)) {
			errstr = "socket path too long";
a134 1
		sun.sun_len = len;
@


1.72
log
@Empty lines cause server_fcgi_getheaders() to immediately return.
Unfortunately in that case the line was not freed.  This lead to a
memleak on each request.  Thus, save the return value prior to
returning, free the line and return the saved value.

ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.71 2016/09/01 11:13:18 florian Exp $	*/
d772 3
a774 6
		if (*value == ':') {
			*value++ = '\0';
			value += strspn(value, " \t");
		} else {
			*value++ = '\0';
		}
@


1.71
log
@struct client starts to become the kitchen sink. Move fastcgi data to
its own struct. Requested by and OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.70 2016/09/01 10:59:38 reyk Exp $	*/
d763 1
a763 1
	int			 code;
d794 4
a797 1
	return (line != NULL && *line == '\0');
@


1.70
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.69 2016/08/30 10:54:42 florian Exp $	*/
d144 4
a147 4
	clt->clt_fcgi_state = FCGI_READ_HEADER;
	clt->clt_fcgi_toread = sizeof(struct fcgi_record_header);
	clt->clt_fcgi_status = 200;
	clt->clt_fcgi_headersdone = 0;
d392 1
a392 1
		clt->clt_fcgi_chunked = 1;
d395 1
a395 1
		clt->clt_fcgi_chunked = 0;
d398 1
a398 1
	clt->clt_fcgi_end = 0;
d504 1
a504 1
		len = bufferevent_read(bev, buf, clt->clt_fcgi_toread);
d509 1
a509 1
		clt->clt_fcgi_toread -= len;
d511 2
a512 2
		    __func__, len, clt->clt_fcgi_toread,
		    clt->clt_fcgi_state, clt->clt_fcgi_type);
d514 1
a514 1
		if (clt->clt_fcgi_toread != 0)
d517 1
a517 1
		switch (clt->clt_fcgi_state) {
d519 1
a519 1
			clt->clt_fcgi_state = FCGI_READ_CONTENT;
d526 3
a528 3
			clt->clt_fcgi_type = h->type;
			clt->clt_fcgi_toread = ntohs(h->content_len);
			clt->clt_fcgi_padding_len = h->padding_len;
d531 1
a531 1
			if (clt->clt_fcgi_toread != 0)
d533 1
a533 1
			else if (clt->clt_fcgi_type == FCGI_STDOUT &&
d541 1
a541 1
			switch (clt->clt_fcgi_type) {
d555 2
a556 2
				if (!clt->clt_fcgi_headersdone) {
					clt->clt_fcgi_headersdone =
d558 1
a558 1
					if (clt->clt_fcgi_headersdone) {
d560 1
a560 1
						    clt->clt_fcgi_status)
d583 3
a585 3
			if (!clt->clt_fcgi_padding_len) {
				clt->clt_fcgi_state = FCGI_READ_HEADER;
				clt->clt_fcgi_toread =
d588 3
a590 3
				clt->clt_fcgi_state = FCGI_READ_PADDING;
				clt->clt_fcgi_toread =
				    clt->clt_fcgi_padding_len;
d596 2
a597 2
			clt->clt_fcgi_state = FCGI_READ_HEADER;
			clt->clt_fcgi_toread =
d630 1
a630 1
	if (clt->clt_fcgi_chunked) {
d739 1
a739 1
	if (clt->clt_fcgi_type == FCGI_END_REQUEST) {
d744 1
a744 1
	if (clt->clt_fcgi_chunked) {
d746 1
a746 1
		if (len == 0 && clt->clt_fcgi_end++)
d787 1
a787 1
			clt->clt_fcgi_status = code;
@


1.69
log
@Do not assume that the full http response header is in the first
fastcgi stdout record. Keep processing stdout records until we found
the header / body separator and only then generate the header
response.
Problem reported by many.

OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.68 2016/04/24 20:09:45 chrisz Exp $	*/
d556 1
a556 1
					clt->clt_fcgi_headersdone = 
@


1.68
log
@Always pass QUERY_STRING variable.
According to the RFC it is empty when no query string was found.
From Tim Baumgard <openbsd@@bmgrd.com>o

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.67 2015/11/23 20:56:15 reyk Exp $	*/
d146 2
d554 14
a567 7
				if (++clt->clt_chunk == 1) {
					if (server_fcgi_header(clt,
					    server_fcgi_getheaders(clt))
					    == -1) {
						server_abort_http(clt, 500,
						    "malformed fcgi headers");
						return;
d763 1
a763 1
	int			 code = 200;
d787 1
d794 1
a794 1
	return (code);
@


1.67
log
@Retire socket_set_blockmode() in favor of the SOCK_NONBLOCK type flag.
As done in iked and snmpd.

OK jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.66 2015/10/08 09:40:32 jsg Exp $	*/
d245 1
a245 1
	if (desc->http_query)
d251 4
@


1.66
log
@fix an fd leak if socket connection fails; from Carlin Bingham
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.65 2015/10/08 09:32:13 jsg Exp $	*/
d125 2
a126 1
		if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
a141 2

	socket_set_blockmode(fd, BM_NONBLOCK);
@


1.65
log
@fix a typo; from Carlin Bingham
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.64 2015/08/20 13:00:23 reyk Exp $	*/
d402 2
@


1.64
log
@Change httpd(8) to use C99-style fixed-width integers (uintN_t instead
of u_intN_t) and replace u_int with unsigned int.  Mixing both
variants is a bad style and most contributors seem to prefer this
style; it also helps us to get used to it, portability, and
standardization.

Theoretically no binary change, except one in practice: httpd.o has a
different checksum because gcc with -O2 pads/optimizes "struct
privsep" differently when using "unsigned int" instead "u_int" for the
affected members.  "u_int" is just a typedef of "unsigned int", -O0
doesn't build the difference and clang with -O2 doesn't do it either -
it is just another curiosity from gcc-land.

OK semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.63 2015/08/03 11:45:17 florian Exp $	*/
d133 1
a133 1
			errstr = "socket path to long";
@


1.63
log
@Fix rev 1.70 of server.c by only re-enabling the bufferevent if we
previously disabled it because we were reading to fast (from disk).
Problem noted and tracked down to that commit by weerd@@ and
independently by stsp@@.
Tested by weerd@@, stsp@@, reyk@@
OK bluhm@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.62 2015/07/31 00:10:51 benno Exp $	*/
d79 1
a79 1
int	server_fcgi_header(struct client *, u_int);
d591 1
a591 1
server_fcgi_header(struct client *clt, u_int code)
@


1.62
log
@repair hsts header output, wrong format strings caused broken
Strict-Transport-Security headers. Add __format__ attribute to
kv_set() and kv_setkey() to make it easier to spot such problems.

Found by and fix from Donovan Watteau <tsoomi -AT- gmail -DOT- com>,
thanks for your help.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.61 2015/07/29 22:03:41 reyk Exp $	*/
d163 1
@


1.61
log
@backout the previous:  it broke wordpress somehow.
we need more care to find a proper fix for the fastcgi headers.

acknowledged by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.60 2015/07/29 20:03:14 florian Exp $	*/
d606 1
a606 1
	if (kv_setkey(&resp->http_pathquery, "%lu", code) == -1 ||
d643 1
a643 1
		    kv_set(cl, "max-age=%d%s%s%s", srv_conf->hsts_max_age,
@


1.60
log
@Read fcgi response records until we have the whole http header and can
parse it. Otherwise http headers can leak into the body.
Pointed out by Jean-Philippe Ouellet on bugs@@ Thanks!
OK reyk, commit ASAP deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.59 2015/07/28 10:13:42 florian Exp $	*/
a78 2
enum fcgihttpheaderstate
	server_fcgi_read_header(struct client *);
a156 8
	if (clt->clt_fcgi_http_header_evb != NULL)
		evbuffer_free(clt->clt_fcgi_http_header_evb);

	if ((clt->clt_fcgi_http_header_evb = evbuffer_new()) == NULL) {
		errstr = "failed to allocate evbuffer";
		goto fail;
	}

d546 1
a546 19
				clt->clt_chunk++;
				if (clt->clt_fcgi_http_header_state ==
				    FCGI_HTTP_HEADER_UNREAD) {
					clt->clt_fcgi_http_header_state =
					    server_fcgi_read_header(clt);
					if (clt->clt_fcgi_http_header_state ==
					    FCGI_HTTP_HEADER_ERROR) {
						server_abort_http(clt,
						    500, "out of memory");
						return;
					}
					if (clt->clt_fcgi_http_header_state ==
				    	    FCGI_HTTP_HEADER_UNREAD)
						break;
				}
				if (clt->clt_fcgi_http_header_state == 
				    FCGI_HTTP_HEADER_READ) {
					clt->clt_fcgi_http_header_state = 
					    FCGI_HTTP_HEADER_DONE;
a588 29
enum fcgihttpheaderstate
server_fcgi_read_header(struct client *clt)
{
	size_t	 len;
	int	 ret = FCGI_HTTP_HEADER_UNREAD;
	u_char	*ptr;
	
	if ((ptr = evbuffer_find(clt->clt_srvevb, "\r\n\r\n", 4)) !=  NULL) {
		len = ptr - EVBUFFER_DATA(clt->clt_srvevb) + 4;
		if (evbuffer_add(clt->clt_fcgi_http_header_evb,
		    EVBUFFER_DATA(clt->clt_srvevb), len) == -1)
			ret = FCGI_HTTP_HEADER_ERROR;
		ret = FCGI_HTTP_HEADER_READ;
	} else if ((ptr = evbuffer_find(clt->clt_srvevb, "\n\n", 2)) !=  NULL) {
		len = ptr - EVBUFFER_DATA(clt->clt_srvevb) + 2;
		if (evbuffer_add(clt->clt_fcgi_http_header_evb,
		    EVBUFFER_DATA(clt->clt_srvevb), len) == -1)
			ret = FCGI_HTTP_HEADER_ERROR;
		ret = FCGI_HTTP_HEADER_READ;
	} else {
		len = EVBUFFER_LENGTH(clt->clt_srvevb);
		if (evbuffer_add_buffer(clt->clt_fcgi_http_header_evb,
		    clt->clt_srvevb) == -1)
			ret = FCGI_HTTP_HEADER_ERROR;
	}
	evbuffer_drain(clt->clt_srvevb, len);
	return (ret);
}

d656 1
a656 1
	/* Write header */
d747 1
a747 1
	struct evbuffer		*evb = clt->clt_fcgi_http_header_evb;
@


1.59
log
@add HSTS to fcgi responses
OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.58 2015/07/19 16:34:35 blambert Exp $	*/
d79 2
d159 8
d556 19
a574 1
				if (++clt->clt_chunk == 1) {
d617 29
d713 1
a713 1
	/* Write initial header (fcgi might append more) */
d804 1
a804 1
	struct evbuffer		*evb = clt->clt_srvevb;
@


1.58
log
@handle error returns from bufferevent_write()

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.57 2015/07/18 22:42:24 blambert Exp $	*/
d592 1
d597 1
a597 1
	struct kv		*kv, key;
d637 13
@


1.57
log
@remove XXX and handle error return from evbuffer_add()

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.56 2015/07/18 16:42:39 blambert Exp $	*/
d183 1
a183 1
	bufferevent_write(clt->clt_srvbev, &param.buf,
d185 4
a188 1
	    sizeof(struct fcgi_begin_request_body));
d358 1
a358 1
		bufferevent_write(clt->clt_srvbev, &param.buf,
d360 4
a363 1
		    ntohs(h->content_len));
d368 5
a372 2
	bufferevent_write(clt->clt_srvbev, &param.buf,
	    sizeof(struct fcgi_record_header));
d451 3
a453 2
		bufferevent_write(clt->clt_srvbev, p->buf,
		    sizeof(struct fcgi_record_header) + p->total_len);
@


1.56
log
@treat asprintf failure in REQUEST_URI case as a fatal error

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.55 2015/07/17 20:44:57 reyk Exp $	*/
d487 4
a490 2
		/* XXX error handling */
		evbuffer_add(clt->clt_srvevb, buf, len);
@


1.55
log
@According to RFC 3875 PATH_INFO should either contain a full path or
be empty ("").  It was not set at all when there is nothing to set
which caused problems with some FastCGI applications (like
Flask/Python through uWSGI).

From hrkfdn via github
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.54 2015/06/09 08:50:52 jung Exp $	*/
d309 6
a314 2
	} else if (asprintf(&str, "%s?%s", desc->http_path,
	    desc->http_query) != -1) {
@


1.54
log
@plug fd leak found by Todd Mortimer

ok claudio deraadt florian
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.53 2015/03/26 09:01:51 florian Exp $	*/
d215 6
@


1.53
log
@Allow more characters in CGI environment variables as specified by RFC
7230 and RFC 3875.
sthen@@ suggested to add a comment to explain where the list of
characters is coming from.
Found the hard way and initial diff from Tim van der Molen (tbvdm at
xs4all), thanks! Some more allowed characters added by me.
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.52 2015/02/23 19:22:43 chrisz Exp $	*/
d35 1
d157 1
d159 1
@


1.52
log
@Use the rewritten (index file appended) uri as DOCUMENT_URI.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.51 2015/01/21 22:23:24 reyk Exp $	*/
d655 8
d666 4
a669 1
		else
@


1.51
log
@Ooops, no need to include sys/cdefs.h.

Pointed out by florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.50 2015/01/21 22:21:05 reyk Exp $	*/
d245 1
a245 1
	if (fcgi_add_param(&param, "DOCUMENT_URI", desc->http_path,
@


1.50
log
@httpd is based on relayd and had included many headers that are only
needed by its ancestor.  jsg@@, include-what-you-use, and some manual
review helped to cleanup the headers (take iwyu with a grain of salt).
Based on common practice, httpd.h now also includes the necessary
headers for itself.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.49 2015/01/19 20:00:07 florian Exp $	*/
a22 1
#include <sys/cdefs.h>
@


1.49
log
@s/clt_fcgi_remote_user/clt_remote_user/
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.48 2015/01/19 19:37:50 reyk Exp $	*/
a19 1
#include <sys/queue.h>
a20 1
#include <sys/stat.h>
d23 1
a23 1
#include <sys/tree.h>
a24 1
#include <net/if.h>
d26 1
a26 2
#include <netinet/ip.h>
#include <netinet/tcp.h>
d28 1
a29 1
#include <fcntl.h>
a31 1
#include <unistd.h>
d33 1
a34 1
#include <err.h>
@


1.48
log
@Decouple auth parameters from struct server_config into struct auth.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.47 2015/01/18 14:01:17 florian Exp $	*/
d264 1
a264 1
		    clt->clt_fcgi_remote_user, clt) == -1) {
@


1.47
log
@First stab at implementing basic auth.
Currently the htpasswd file needs to be in the chroot; will hopefully
improved soonish.
Based on a diff from Oscar Linderholm many months ago but turned into
a complete rewrite.
input/OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.46 2015/01/16 06:40:17 deraadt Exp $	*/
d262 1
a262 1
	if (srv_conf->flags & SRVFLAG_AUTH_BASIC) {
@


1.46
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.45 2015/01/13 08:54:01 reyk Exp $	*/
d260 8
@


1.45
log
@Abort if fcgi_chunked is not true to avoid sending additional garbage
after the response.

Found by Erik Lax

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.44 2015/01/04 22:23:58 chrisz Exp $	*/
d100 1
a100 1
	char				 hbuf[MAXHOSTNAMELEN];
@


1.44
log
@add new url stripping option:

strip number
	Strip number path components from the beginning of the
	request URI before looking up the stripped-down URI at
	the document root.


reviewed with much patience and OK by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.43 2014/12/21 00:54:49 guenther Exp $	*/
a676 4
	/* If len is 0, make sure to write the end marker only once */
	if (len == 0 && clt->clt_fcgi_end++)
		return (0);

d678 3
d685 1
a685 1
	} else
@


1.43
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.42 2014/12/12 14:45:59 reyk Exp $	*/
d104 2
a105 2
	const char			*errstr = NULL;
	char				*str, *p, *script = NULL;
d193 7
a199 3
	if ((pathlen = asprintf(&script, "%s%s", srv_conf->root,
	    desc->http_path_alias != NULL ?
	    desc->http_path_alias : desc->http_path)) == -1) {
d220 11
a230 2
	if (fcgi_add_param(&param, "SCRIPT_NAME",
	    script + strlen(srv_conf->root), clt) == -1) {
@


1.42
log
@Like previously done in relayd, change the keyword "ssl" to "tls" to
reflect reality.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.41 2014/12/04 02:44:42 tedu Exp $	*/
a30 1
#include <arpa/inet.h>
@


1.41
log
@stop viral header propagation. none of this code uses sys/hash.h
from Max Fillinger
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.40 2014/10/25 03:23:49 lteo Exp $	*/
d256 1
a256 1
	if (srv_conf->flags & SRVFLAG_SSL)
@


1.40
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.39 2014/09/29 19:30:47 deraadt Exp $	*/
a25 1
#include <sys/hash.h>
@


1.39
log
@whitespace spotted while studying the code
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.38 2014/09/02 16:20:41 reyk Exp $	*/
a28 1
#include <netinet/in_systm.h>
@


1.38
log
@FastCGI did not support persistent connections.  Add initial support
for persistent connections with FastCGI by implementing chunked
Transfer-Encoding.  This only works with HTTP/1.1.

With input and help from florian@@ who found some FastCGI edge cases.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.37 2014/09/01 12:28:11 reyk Exp $	*/
d132 1
a132 1
	
d479 2
a480 2
			     h->version, h->type, ntohs(h->id),
			     ntohs(h->content_len), h->padding_len);
@


1.37
log
@Don't pass the local buffer array by reference.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.36 2014/09/01 09:32:43 reyk Exp $	*/
d90 1
d351 8
a358 5
	/*
	 * persist is not supported yet because we don't get the
	 * Content-Length from slowcgi and don't support chunked encoding.
	 */
	clt->clt_persist = 0;
d465 3
a467 2
		DPRINTF("%s: len: %lu toread: %d state: %d", __func__, len,
		    clt->clt_fcgi_toread, clt->clt_fcgi_state);
d496 4
a499 3
			if (clt->clt_fcgi_type == FCGI_STDERR &&
			    EVBUFFER_LENGTH(clt->clt_srvevb) > 0) {
				if ((ptr = get_string(
d507 21
a527 8
			}
			if (clt->clt_fcgi_type == FCGI_STDOUT &&
			    EVBUFFER_LENGTH(clt->clt_srvevb) > 0) {
				if (++clt->clt_chunk == 1)
					server_fcgi_header(clt,
					    server_fcgi_getheaders(clt));
				server_bufferevent_write_buffer(clt,
				    clt->clt_srvevb);
d559 1
d576 16
d654 26
@


1.36
log
@Replace the code to get the FastCGI Status header with a proper way to
parse and write the headers using the http response descriptor.  This
allows to add other tweaks, like support for chunked encoding, later.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.35 2014/08/29 13:01:46 reyk Exp $	*/
d457 1
a457 1
		len = bufferevent_read(bev, &buf, clt->clt_fcgi_toread);
d459 1
a459 1
		evbuffer_add(clt->clt_srvevb, &buf, len);
@


1.35
log
@Use two instead of one http descriptor for request and response.

OK chrisz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.34 2014/08/21 19:23:10 chrisz Exp $	*/
d90 1
a92 1
int	get_status(struct evbuffer *);
d506 1
a506 1
					    get_status(clt->clt_srvevb));
d572 2
a573 1
	    server_headers(clt, resp, server_writeheader_http, NULL) == -1)
d621 1
a621 1
get_status(struct evbuffer *bev)
d623 28
a650 16
	int code;
	char *statusline, *tok;
	const char *errstr;

	/* XXX This is a hack. We need to parse the response header. */
	code = 200;
	if (strncmp(EVBUFFER_DATA(bev), "Status: ", strlen("Status: ")) == 0) {
		statusline = get_string(EVBUFFER_DATA(bev),
		    EVBUFFER_LENGTH(bev));
		if (strtok(statusline, " ") != NULL) {
			if ((tok = strtok(NULL, " ")) != NULL) {
				code = (int) strtonum(tok, 100, 600, &errstr);
				if (errstr != NULL || server_httperror_byid(
				   code) == NULL)
					code = 200;
			}
d652 1
a652 1
		free(statusline);
d654 2
a655 1
	return code;
@


1.34
log
@Add Last-Modified: HTTP header.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.33 2014/08/13 18:00:54 chrisz Exp $	*/
d99 1
a99 1
	struct http_descriptor		*desc = clt->clt_desc;
d252 1
a252 1
	if (server_headers(clt, server_fcgi_writeheader, &param) == -1) {
d536 2
a537 1
	struct http_descriptor	*desc = clt->clt_desc;
a546 2
	kv_purge(&desc->http_headers);

d548 2
a549 2
	if (kv_setkey(&desc->http_pathquery, "%lu", code) == -1 ||
	    kv_set(&desc->http_pathquery, "%s", error) == -1)
d553 1
a553 1
	if (kv_add(&desc->http_headers, "Server", HTTPD_SERVERNAME) == NULL)
d558 1
a558 1
		if (kv_add(&desc->http_headers,
d561 1
a561 1
	} else if (kv_add(&desc->http_headers, "Connection", "close") == NULL)
d566 1
a566 1
	    kv_add(&desc->http_headers, "Date", tmbuf) == NULL)
d572 1
a572 1
	    server_headers(clt, server_writeheader_http, NULL) == -1)
@


1.33
log
@For a non-existent root we don't want the root prefix to show up in
PATH_INFO.
Therefore put a lower bound of strlen(root) on scriptlen.
This makes perfect sense for virtual FastCGI scripts which run chrooted
in another directory from httpd.


ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.32 2014/08/13 16:04:28 reyk Exp $	*/
d565 3
a567 3
	/* Date header is mandatory and should be added last */
	server_http_date(tmbuf, sizeof(tmbuf));
	if (kv_add(&desc->http_headers, "Date", tmbuf) == NULL)
@


1.32
log
@Provide a failsafe version of the path_info() function that doesn't
need a temporary path variable.  Based on an initial diff from
chrisz@@.

"Commit any failsafe version and I'm ok with it" chrisz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.31 2014/08/11 15:26:33 deraadt Exp $	*/
d103 2
a104 1
	ssize_t				 scriptlen, pathlen;
d195 1
a195 1
	if ((pathlen = (ssize_t)asprintf(&script, "%s%s", srv_conf->root,
d202 8
a209 1
	if ((scriptlen = path_info(script)) < pathlen) {
@


1.31
log
@make a few variables more local
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.30 2014/08/08 18:29:42 reyk Exp $	*/
d103 1
a103 1
	ssize_t				 scriptlen;
d194 1
a194 1
	if (asprintf(&script, "%s%s", srv_conf->root,
d196 1
a196 2
	    desc->http_path_alias : desc->http_path) == -1 ||
	    (scriptlen = path_info(script)) == -1) {
d201 1
a201 1
	if (scriptlen) {
@


1.30
log
@When opening directories, re-match the location after the index file
has been appended.  This allows to use a fastcgi target as the default
index, for example index.php.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.29 2014/08/07 12:43:22 florian Exp $	*/
a97 1
	char				 hbuf[MAXHOSTNAMELEN];
d99 1
a99 2
	struct http_descriptor		*desc	= clt->clt_desc;
	struct sockaddr_un		 sun;
d102 1
a102 1
	size_t				 len;
a106 2
	in_port_t			 port;
	struct sockaddr_storage		 ss;
d109 3
d128 3
@


1.29
log
@Don't try to ouput FCGI_STDERR into error.log if there is no data.
Problem noticed by naddy@@, OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.28 2014/08/07 10:52:34 florian Exp $	*/
d193 2
a194 1
	    desc->http_path) == -1 ||
@


1.29.2.1
log
@httpd was developed very rapidly in the weeks before 5.6 release,
and it has a few flaws.  It would be nice to get these flaws fully
remediated before the next release, and that requires the community
to want to use it.
Therefore here is a "jumbo" patch that brings in the most important fixes.

committing on behalf of reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.29 2014/08/07 12:43:22 florian Exp $	*/
a89 2
int	server_fcgi_writechunk(struct client *);
int	server_fcgi_getheaders(struct client *);
d92 1
d98 1
d100 1
a100 1
	struct http_descriptor		*desc = clt->clt_descreq;
d105 1
a105 3
	char				 hbuf[MAXHOSTNAMELEN];
	size_t				 scriptlen;
	int				 pathlen;
d192 3
a194 3
	if ((pathlen = asprintf(&script, "%s%s", srv_conf->root,
	    desc->http_path_alias != NULL ?
	    desc->http_path_alias : desc->http_path)) == -1) {
d199 1
a199 8
	scriptlen = path_info(script);
	/*
	 * no part of root should show up in PATH_INFO.
	 * therefore scriptlen should be >= strlen(root)
	 */
	if (scriptlen < strlen(srv_conf->root))
		scriptlen = strlen(srv_conf->root);
	if ((int)scriptlen < pathlen) {
d242 1
a242 1
	if (server_headers(clt, desc, server_fcgi_writeheader, &param) == -1) {
d340 5
a344 8
	if (strcmp(desc->http_version, "HTTP/1.1") == 0) {
		clt->clt_fcgi_chunked = 1;
	} else {
		/* HTTP/1.0 does not support chunked encoding */
		clt->clt_fcgi_chunked = 0;
		clt->clt_persist = 0;
	}
	clt->clt_fcgi_end = 0;
d447 1
a447 1
		len = bufferevent_read(bev, buf, clt->clt_fcgi_toread);
d449 1
a449 1
		evbuffer_add(clt->clt_srvevb, buf, len);
d481 3
a483 4
			switch (clt->clt_fcgi_type) {
			case FCGI_STDERR:
				if (EVBUFFER_LENGTH(clt->clt_srvevb) > 0 &&
				    (ptr = get_string(
d491 8
a498 21
				break;
			case FCGI_STDOUT:
				if (++clt->clt_chunk == 1) {
					if (server_fcgi_header(clt,
					    server_fcgi_getheaders(clt))
					    == -1) {
						server_abort_http(clt, 500,
						    "malformed fcgi headers");
						return;
					}
					if (!EVBUFFER_LENGTH(clt->clt_srvevb))
						break;
				}
				/* FALLTHROUGH */
			case FCGI_END_REQUEST:
				if (server_fcgi_writechunk(clt) == -1) {
					server_abort_http(clt, 500,
					    "encoding error");
					return;
				}
				break;
d526 1
a526 2
	struct http_descriptor	*desc = clt->clt_descreq;
	struct http_descriptor	*resp = clt->clt_descresp;
a528 1
	struct kv		*kv, key;
d536 2
d539 2
a540 2
	if (kv_setkey(&resp->http_pathquery, "%lu", code) == -1 ||
	    kv_set(&resp->http_pathquery, "%s", error) == -1)
d544 1
a544 1
	if (kv_add(&resp->http_headers, "Server", HTTPD_SERVERNAME) == NULL)
a546 16
	/* Set chunked encoding */
	if (clt->clt_fcgi_chunked) {
		/* XXX Should we keep and handle Content-Length instead? */
		key.kv_key = "Content-Length";
		if ((kv = kv_find(&resp->http_headers, &key)) != NULL)
			kv_delete(&resp->http_headers, kv);

		/*
		 * XXX What if the FastCGI added some kind of Transfer-Encoding?
		 * XXX like gzip, deflate or even "chunked"?
		 */
		if (kv_add(&resp->http_headers,
		    "Transfer-Encoding", "chunked") == NULL)
			return (-1);
	}

d549 1
a549 1
		if (kv_add(&resp->http_headers,
d552 1
a552 1
	} else if (kv_add(&resp->http_headers, "Connection", "close") == NULL)
d555 3
a557 3
	/* Date header is mandatory and should be added as late as possible */
	if (server_http_time(time(NULL), tmbuf, sizeof(tmbuf)) <= 0 ||
	    kv_add(&resp->http_headers, "Date", tmbuf) == NULL)
d563 1
a563 2
	    server_headers(clt, resp, server_writeheader_http, NULL) == -1 ||
	    server_bufferevent_print(clt, "\r\n") == -1)
d611 1
a611 1
server_fcgi_writechunk(struct client *clt)
d613 16
a628 52
	struct evbuffer *evb = clt->clt_srvevb;
	size_t		 len;

	if (clt->clt_fcgi_type == FCGI_END_REQUEST) {
		len = 0;
	} else
		len = EVBUFFER_LENGTH(evb);

	/* If len is 0, make sure to write the end marker only once */
	if (len == 0 && clt->clt_fcgi_end++)
		return (0);

	if (clt->clt_fcgi_chunked) {
		if (server_bufferevent_printf(clt, "%zx\r\n", len) == -1 ||
		    server_bufferevent_write_chunk(clt, evb, len) == -1 ||
		    server_bufferevent_print(clt, "\r\n") == -1)
			return (-1);
	} else
		return (server_bufferevent_write_buffer(clt, evb));

	return (0);
}

int
server_fcgi_getheaders(struct client *clt)
{
	struct http_descriptor	*resp = clt->clt_descresp;
	struct evbuffer		*evb = clt->clt_srvevb;
	int			 code = 200;
	char			*line, *key, *value;
	const char		*errstr;

	while ((line = evbuffer_getline(evb)) != NULL && *line != '\0') {
		key = line;

		if ((value = strchr(key, ':')) == NULL)
			break;
		if (*value == ':') {
			*value++ = '\0';
			value += strspn(value, " \t");
		} else {
			*value++ = '\0';
		}

		if (strcasecmp("Status", key) == 0) {
			value[strcspn(value, " \t")] = '\0';
			code = (int)strtonum(value, 100, 600, &errstr);
			if (errstr != NULL || server_httperror_byid(
			    code) == NULL)
				code = 200;
		} else {
			(void)kv_add(&resp->http_headers, key, value);
d630 1
a630 1
		free(line);
d632 1
a632 2

	return (code);
@


1.28
log
@Opportunistically try to parse "Status: $code" in the very first
response from the fcgi daemon and use that code as HTTP response
code. If it doesn't work out fall back to code 200.
This might fix naddy@@'s issue with redirects in cvsweb.
To be revisited after unlock.
Discussed with & grudgingly OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.27 2014/08/06 21:08:47 reyk Exp $	*/
d481 2
a482 1
			if (clt->clt_fcgi_type == FCGI_STDERR && len) {
@


1.27
log
@Write STDERR from the CGI to the web server error log as intended.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.26 2014/08/06 20:56:23 florian Exp $	*/
d92 1
d494 2
a495 1
					server_fcgi_header(clt, 200);
d607 25
@


1.26
log
@If the very first fcgi STDOUT record has length 0 the cgi script
didn't send anything back. This is an internal server error.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.25 2014/08/06 18:40:15 reyk Exp $	*/
d443 1
d480 10
@


1.25
log
@Always zero-out the fcgi record header for STDIN data.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.24 2014/08/06 18:38:11 reyk Exp $	*/
d471 5
@


1.24
log
@Use memset(buf instead of memset(&buf.

Pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.23 2014/08/06 15:08:04 florian Exp $	*/
d361 1
@


1.23
log
@http POST support
with & OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.22 2014/08/06 13:40:18 florian Exp $	*/
d147 1
a147 1
	memset(&hbuf, 0, sizeof(hbuf));
@


1.22
log
@Content-Length and Content-Type are transmitted as CONTENT_LENGTH and
CONTENT_TYPE environment variables to cgi scripts, without the HTTP_
prefix.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.21 2014/08/04 18:00:06 reyk Exp $	*/
a47 1
#define FCGI_CONTENT_SIZE	 65535
a327 5
	h->type = FCGI_STDIN;

	bufferevent_write(clt->clt_srvbev, &param.buf,
	    sizeof(struct fcgi_record_header));

d331 7
a337 1
	bufferevent_disable(clt->clt_bev, EV_READ);
d354 24
@


1.21
log
@Add HTTPS = on CGI variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.20 2014/08/04 14:49:24 reyk Exp $	*/
d544 8
a551 2
	if (asprintf(&name, "HTTP_%s", key) == -1)
		return (-1);
@


1.20
log
@Implement PATH_INFO and add DOCUMENT_ROOT.
PATH_INFO was requested by naddy@@ who successfully tested it with "cvsweb".

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.19 2014/08/04 11:09:25 reyk Exp $	*/
d246 6
@


1.19
log
@httpd doesn't support SSL/TLS yet, remove the remaining bits.
The secrect plan is to add it later using the ressl wrapper library.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.18 2014/08/03 22:06:51 florian Exp $	*/
d105 1
d108 1
a108 1
	char				*str, *p;
d192 4
a195 3
	if (fcgi_add_param(&param, "SCRIPT_NAME", desc->http_path,
	    clt) == -1) {
		errstr = "failed to encode param";
d199 3
a201 5
	if (asprintf(&str, "%s%s", srv_conf->root, desc->http_path) != -1) {
		ret = fcgi_add_param(&param, "SCRIPT_FILENAME", str,
		    clt);
		free(str);
		if (ret == -1) {
d205 11
d225 5
d340 1
d343 1
@


1.18
log
@c-type functions / makros need a cast to unsigned char, not int
"feel free to commit" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.17 2014/08/03 20:43:03 reyk Exp $	*/
a43 2

#include <openssl/ssl.h>
@


1.17
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.16 2014/08/03 20:39:40 reyk Exp $	*/
d526 2
a527 2
		if (isalpha((int)*p))
			*p = (char)toupper((int)*p);
@


1.16
log
@Dynamically pass HTTP request headers as protocol-specific HTTP_* CGI
meta-variables.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.15 2014/08/03 12:26:19 reyk Exp $	*/
d261 1
a261 1
		if (ret == -1) {	
@


1.15
log
@Add function to iterate all headers.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.14 2014/08/03 11:16:10 reyk Exp $	*/
d41 1
d85 5
d92 3
a94 2
int	fcgi_add_param(uint8_t *, const char *, const char *, int *,
    struct client *);
d99 1
a99 1
	uint8_t				 buf[FCGI_RECORD_SIZE];
a105 1
	struct kv			*kv, key;
d107 1
a107 1
	int				 fd = -1, total_len, ret;
d173 1
a173 1
	memset(&buf, 0, sizeof(buf));
d175 1
a175 1
	h = (struct fcgi_record_header *) &buf;
d182 1
a182 1
	begin = (struct fcgi_begin_request_body *) &buf[sizeof(struct
d186 1
a186 1
	bufferevent_write(clt->clt_srvbev, &buf,
d191 1
a191 1
	h->content_len = total_len = 0;
d193 1
a193 1
	if (fcgi_add_param(buf, "SCRIPT_NAME", desc->http_path, &total_len,
d200 2
a201 2
		ret = fcgi_add_param(buf, "SCRIPT_FILENAME", str,
		    &total_len, clt);
d210 2
a211 2
		if (fcgi_add_param(buf, "QUERY_STRING", desc->http_query,
		    &total_len, clt) == -1) {
d216 1
a216 1
	if (fcgi_add_param(buf, "DOCUMENT_URI", desc->http_path, &total_len,
d221 1
a221 1
	if (fcgi_add_param(buf, "GATEWAY_INTERFACE", "CGI/1.1", &total_len,
d227 5
a231 62
	key.kv_key = "Accept";
	if ((kv = kv_find(&desc->http_headers, &key)) != NULL &&
	    kv->kv_value != NULL)
		if (fcgi_add_param(buf, "HTTP_ACCEPT", kv->kv_value,
		    &total_len, clt) == -1) {
			errstr = "failed to encode param";
			goto fail;
		}

	key.kv_key = "Accept-Encoding";
	if ((kv = kv_find(&desc->http_headers, &key)) != NULL &&
	    kv->kv_value != NULL)
		if (fcgi_add_param(buf, "HTTP_ACCEPT_ENCODING", kv->kv_value,
		    &total_len, clt) == -1) {
			errstr = "failed to encode param";
			goto fail;
		}

	key.kv_key = "Accept-Language";
	if ((kv = kv_find(&desc->http_headers, &key)) != NULL &&
	    kv->kv_value != NULL)
		if (fcgi_add_param(buf, "HTTP_ACCEPT_LANGUAGE", kv->kv_value,
		    &total_len, clt) == -1) {
			errstr = "failed to encode param";
			goto fail;
		}

	key.kv_key = "Connection";
	if ((kv = kv_find(&desc->http_headers, &key)) != NULL &&
	    kv->kv_value != NULL)
		if (fcgi_add_param(buf, "HTTP_CONNECTION", kv->kv_value,
		    &total_len, clt) == -1) {
			errstr = "failed to encode param";
			goto fail;
		}

	key.kv_key = "Cookie";
	if ((kv = kv_find(&desc->http_headers, &key)) != NULL &&
	    kv->kv_value != NULL)
		if (fcgi_add_param(buf, "HTTP_COOKIE", kv->kv_value,
		    &total_len, clt) == -1) {
			errstr = "failed to encode param";
			goto fail;
		}

	key.kv_key = "Host";
	if ((kv = kv_find(&desc->http_headers, &key)) != NULL &&
	    kv->kv_value != NULL)
		if (fcgi_add_param(buf, "HTTP_HOST", kv->kv_value,
		    &total_len, clt) == -1) {
			errstr = "failed to encode param";
			goto fail;
		}

	key.kv_key = "User-Agent";
	if ((kv = kv_find(&desc->http_headers, &key)) != NULL &&
	    kv->kv_value != NULL)
		if (fcgi_add_param(buf, "HTTP_USER_AGENT", kv->kv_value,
		    &total_len, clt) == -1) {
			errstr = "failed to encode param";
			goto fail;
		}
d234 1
a234 1
	if (fcgi_add_param(buf, "REMOTE_ADDR", hbuf, &total_len, clt) == -1) {
d240 1
a240 1
	if (fcgi_add_param(buf, "REMOTE_PORT", hbuf, &total_len, clt) == -1) {
d245 2
a246 2
	if (fcgi_add_param(buf, "REQUEST_METHOD",
	    server_httpmethod_byid(desc->http_method), &total_len, clt) == -1) {
d252 2
a253 2
		if (fcgi_add_param(buf, "REQUEST_URI", desc->http_path,
		    &total_len, clt) == -1) {
d259 1
a259 2
		ret = fcgi_add_param(buf, "REQUEST_URI", str,
		    &total_len, clt);
d268 1
a268 1
	if (fcgi_add_param(buf, "SERVER_ADDR", hbuf, &total_len, clt) == -1) {
d275 1
a275 1
	if (fcgi_add_param(buf, "SERVER_PORT", hbuf, &total_len, clt) == -1) {
d280 1
a280 1
	if (fcgi_add_param(buf, "SERVER_NAME", srv_conf->name, &total_len,
d286 2
a287 2
	if (fcgi_add_param(buf, "SERVER_PROTOCOL", desc->http_version,
	    &total_len, clt) == -1) {
d292 1
a292 1
	if (fcgi_add_param(buf, "SERVER_SOFTWARE", HTTPD_SERVERNAME, &total_len,
d298 2
a299 2
	if (total_len != 0) {	/* send last params record */
		bufferevent_write(clt->clt_srvbev, &buf,
d306 1
a306 1
	bufferevent_write(clt->clt_srvbev, &buf,
d311 1
a311 1
	bufferevent_write(clt->clt_srvbev, &buf,
d335 2
a336 2
fcgi_add_param(uint8_t *buf, const char *key, const char *val, int *total_len,
    struct client *clt)
d349 1
a349 1
	    val, val_len, *total_len);
d354 4
a357 4
	if (*total_len + len > FCGI_CONTENT_SIZE) {
		bufferevent_write(clt->clt_srvbev, buf,
		    sizeof(struct fcgi_record_header) + *total_len);
		*total_len = 0;
d360 2
a361 2
	h = (struct fcgi_record_header *) buf;
	param = buf + sizeof(struct fcgi_record_header) + *total_len;
d383 1
a383 1
	*total_len += len;
d385 1
a385 1
	h->content_len = htons(*total_len);
d497 1
a497 1
	    server_headers(clt, server_writeheader_http) == -1)
d501 35
@


1.14
log
@Split fastcgi socket path and document root option and add the
SCRIPT_FILENAME CGI param with a prepended root.  This fixes php-fpm
that expects SCRIPT_FILENAME and also works with slowcgi if you
configure the root correctly.  For example, if SCRIPT_NAME and
REQUEST_URI are /php/index.php, root is /htdocs, SCRIPT_FILENAME will
be /htdocs/php/index.php.  As tested and discussed with florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.13 2014/08/03 10:38:42 reyk Exp $	*/
d549 1
a549 1
	    server_writeheader_http(clt) == -1)
@


1.13
log
@Add missing log call for FastCGI requests.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.12 2014/08/02 17:42:24 florian Exp $	*/
d101 1
a101 1
	int				 fd = -1, total_len;
d103 1
a103 1
	char				*request_uri, *p;
d107 2
a108 2
	if (srv_conf->path[0] == ':') {
		p = srv_conf->path + 1;
d130 1
a130 1
		    srv_conf->path, sizeof(sun.sun_path));
d193 10
d308 1
a308 1
	} else if (asprintf(&request_uri, "%s?%s", desc->http_path,
d310 4
a313 2
		if (fcgi_add_param(buf, "REQUEST_URI", request_uri, &total_len,
		    clt) == -1) {
a316 1
		free(request_uri);
@


1.12
log
@don't leak fcgi fd
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.11 2014/08/02 17:05:18 florian Exp $	*/
d506 3
@


1.11
log
@Padding of fcgi records is optional, but if we receive padding data we
should read it.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.10 2014/08/02 11:59:04 florian Exp $	*/
d156 1
@


1.10
log
@We need to read from the fcgi bufferevent until it's empty because the
event handler will not be called again if no new data arrives.
Debugged with and OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.9 2014/08/02 11:52:01 reyk Exp $	*/
d454 3
a456 2
			    "content len %d", __func__, h->version, h->type,
			    ntohs(h->id), ntohs(h->content_len));
d459 1
d476 13
d492 1
@


1.9
log
@Allow to specify a FastCGI TCP socket on localhost (eg. :9000).  Used
for debugging, you should prefer local UNIX sockets, but it helped to
find an issue that will be fixed with the next commit.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.8 2014/08/02 09:54:13 reyk Exp $	*/
d437 8
a444 22
	len = bufferevent_read(bev, &buf, clt->clt_fcgi_toread);
	/* XXX error handling */
	evbuffer_add(clt->clt_srvevb, &buf, len);
	clt->clt_fcgi_toread -= len;
	DPRINTF("%s: len: %lu toread: %d state: %d", __func__, len,
	    clt->clt_fcgi_toread, clt->clt_fcgi_state);

	if (clt->clt_fcgi_toread != 0)
		return;

	switch (clt->clt_fcgi_state) {
	case FCGI_READ_HEADER:
		clt->clt_fcgi_state = FCGI_READ_CONTENT;
		h = (struct fcgi_record_header *)
		    EVBUFFER_DATA(clt->clt_srvevb);
		DPRINTF("%s: record header: version %d type %d id %d "
		    "content len %d", __func__, h->version, h->type,
		    ntohs(h->id), ntohs(h->content_len));
		clt->clt_fcgi_type = h->type;
		clt->clt_fcgi_toread = ntohs(h->content_len);
		evbuffer_drain(clt->clt_srvevb,
		    EVBUFFER_LENGTH(clt->clt_srvevb));
d446 1
a446 1
			break;
d448 31
a478 15
		/* fallthrough if content_len == 0 */
	case FCGI_READ_CONTENT:
		if (clt->clt_fcgi_type == FCGI_STDOUT &&
		    EVBUFFER_LENGTH(clt->clt_srvevb) > 0) {
			if (++clt->clt_chunk == 1)
				server_fcgi_header(clt, 200);
			server_bufferevent_write_buffer(clt,
			    clt->clt_srvevb);
		}
		evbuffer_drain(clt->clt_srvevb,
		    EVBUFFER_LENGTH(clt->clt_srvevb));
		clt->clt_fcgi_state = FCGI_READ_HEADER;
		clt->clt_fcgi_toread =
		    sizeof(struct fcgi_record_header);
	}
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.7 2014/08/01 18:26:32 florian Exp $	*/
d101 1
a101 1
	int				 fd, total_len;
d103 33
a135 1
	char				*request_uri;
d137 2
a138 10
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		goto fail;

	bzero(&sun, sizeof(sun));
	bzero(&hbuf, sizeof(hbuf));
	sun.sun_family = AF_UNIX;
	len = strlcpy(sun.sun_path, srv_conf->path, sizeof(sun.sun_path));
	if (len >= sizeof(sun.sun_path)) {
		errstr = "socket path to long";
		goto fail;
a139 1
	sun.sun_len = len;
d141 1
a141 2
	if (connect(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1)
		goto fail;
d143 1
d166 1
a166 1
	bzero(&buf, sizeof(buf));
@


1.7
log
@Rewrite fcgi_add_param and hand over a lot more http headers etc. to
the cgi script.
OK reyk@@
"blanket OK" for changes in httpd for the time beeing from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.6 2014/08/01 08:34:46 florian Exp $	*/
d92 2
d97 1
a97 1
	struct fcgi_record_header 	*h;
a102 2
	uint8_t				 buf[FCGI_RECORD_SIZE];
	char				 hbuf[MAXHOSTNAMELEN];
d409 4
a412 4
	struct client *clt = (struct client *) arg;
	struct fcgi_record_header 	*h;
	uint8_t	 buf[FCGI_RECORD_SIZE];
	size_t	 len;
@


1.6
log
@Correctly parse fcgi records if we don't get the whole record in one
bufferevent_read().
Input/OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.5 2014/07/31 18:07:11 reyk Exp $	*/
d86 2
a87 1
int	fcgi_add_param(uint8_t *, char *, char *, int);
d97 3
a99 2
	size_t				 len, total_len;
	int				 fd;
d102 2
a103 1
	uint8_t				*params;
d109 1
d161 128
a288 2
	h->content_len = 0;
	params = &buf[sizeof(struct fcgi_record_header)];
d290 6
a295 1
	total_len = 0;
d297 5
a301 4
	len = fcgi_add_param(params, "SCRIPT_NAME", desc->http_path,
	    FCGI_CONTENT_SIZE);
	params += len;
	total_len += len;
d303 4
a306 5
	if (desc->http_query) {
		len = fcgi_add_param(params, "QUERY_STRING", desc->http_query,
		    FCGI_CONTENT_SIZE);
		params += len;
		total_len += len;
d309 5
a313 1
	h->content_len = htons(total_len);
d315 5
a319 3
	bufferevent_write(clt->clt_srvbev, &buf,
	    sizeof(struct fcgi_record_header) +
	    ntohs(h->content_len));
d321 1
a322 1

d352 2
a353 1
fcgi_add_param(uint8_t *buf, char *key, char *val, int size)
d355 21
a375 8
	int len = 0;
	DPRINTF("%s: %s => %s", __func__, key, val);
	buf[0] = strlen(key);
	len++;
	buf[1] = strlen(val);
	len++;
	len += strlcpy(buf + len, key, size - len);
	len += strlcpy(buf + len, val, size - len);
d377 27
a403 1
	return len;
@


1.5
log
@Only write the HTTP header for the first fastcgi chunk.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.4 2014/07/31 17:55:09 reyk Exp $	*/
d117 12
d233 39
a271 17
	len = bufferevent_read(bev, &buf, FCGI_RECORD_SIZE);
	DPRINTF("%s: %lu", __func__, len);
	
	h = (struct fcgi_record_header *) &buf;
	DPRINTF("%s: record header: version %d type %d id %d content len %d",
	    __func__, h->version, h->type, ntohs(h->id),
	    ntohs(h->content_len));

	if (h->type == FCGI_STDOUT && ntohs(h->content_len) > 0) {
		DPRINTF("%s", (char *) &buf +
                    sizeof(struct fcgi_record_header));

		if (++clt->clt_chunk == 1)
			server_fcgi_header(clt, 200);
		server_bufferevent_write(clt, (char *)&buf +
		    sizeof(struct fcgi_record_header),
		    len - sizeof(struct fcgi_record_header));
@


1.4
log
@some fastcgi improvements:
- DPRINTF instead of log_info for internal debugging.
- submit QUERY_STRING, if it exists
- use a proper function to create an HTTP header.
- use server_file_error() to detect EOF and fastcgi stream errors.
- disable keep-alive/persist for now until we have a reliable way to
get the content length from the cgi response or support chunked
encoding.

"Cool, jep" florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.3 2014/07/31 14:25:14 reyk Exp $	*/
d233 2
a234 1
		server_fcgi_header(clt, 200);
@


1.3
log
@One bufferevent can be shared by file and fcgi.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.2 2014/07/31 14:18:38 reyk Exp $	*/
d84 1
a85 1
void	server_fcgi_error(struct bufferevent *, short, void *);
a101 1
	log_info("server_fcgi");
a113 1
	log_info("path: %s", sun.sun_path);
d119 1
d121 1
a121 1
	    NULL, server_fcgi_error, clt);
a125 3
	bufferevent_settimeout(clt->clt_srvbev,
	    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);
	bufferevent_enable(clt->clt_srvbev, EV_READ);
d154 8
a161 1
	
d178 12
d202 1
a202 1
	log_info("%s => %s", key, val);
d222 1
a222 2

	log_info("server_fcgi_read: %lu", len);
d225 4
a228 5
	log_info("h->version: %d", h->version);
	log_info("h->type: %d", h->type);
	log_info("h->id: %d", ntohs(h->id));
	log_info("h->content_len: %d", ntohs(h->content_len));
	
d230 7
a236 6
		log_info("%s", (char*) &buf +
		     sizeof(struct fcgi_record_header));
		server_bufferevent_print(clt, "HTTP/1.1 200 OK\r\n");
		server_bufferevent_print(clt, (char*) &buf +
		     sizeof(struct fcgi_record_header));
		
d240 2
a241 2
void
server_fcgi_error(struct bufferevent *bev, short error, void *arg)
d243 38
a280 1
	log_info("server_fcgi_error: %d", error);
@


1.2
log
@Allow to specify a non-default fastcgi socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: server_fcgi.c,v 1.1 2014/07/31 09:23:53 florian Exp $	*/
d76 1
a76 1
}__packed;
d82 1
a82 1
}__packed;
d119 3
a121 3
	if (clt->clt_fcgi != NULL)
		bufferevent_free(clt->clt_fcgi);
	clt->clt_fcgi = bufferevent_new(fd, server_fcgi_read,
d123 1
a123 1
	if (clt->clt_fcgi == NULL) {
d127 1
a127 1
	bufferevent_settimeout(clt->clt_fcgi,
d129 1
a129 1
	bufferevent_enable(clt->clt_fcgi, EV_READ);
d144 1
a144 1
	bufferevent_write(clt->clt_fcgi, &buf,
d161 1
a161 1
	bufferevent_write(clt->clt_fcgi, &buf,
d167 1
a167 1
	bufferevent_write(clt->clt_fcgi, &buf,
d172 1
a172 1
	bufferevent_write(clt->clt_fcgi, &buf,
@


1.1
log
@Put in first stab at fastcgi. Very early work in progress. Putting it
in now so that we can quickly work on it in tree. Requested by reyk@@.
deraadt@@ is OK with this according to reyk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d108 1
a108 1
	len = strlcpy(sun.sun_path, "/run/slowcgi.sock", sizeof(sun.sun_path));
@

