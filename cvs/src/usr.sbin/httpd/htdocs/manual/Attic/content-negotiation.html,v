head	1.10;
access;
symbols
	OPENBSD_5_5:1.9.0.38
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.34
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.32
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.30
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.28
	OPENBSD_5_0:1.9.0.26
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.24
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.22
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.18
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.20
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.16
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.14
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.12
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.10
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.8
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.6
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.3
	apache_1_3_27:1.1.1.3
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	apache_1_3_26:1.1.1.3
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.2.0.2
	OPENBSD_2_4_BASE:1.1.1.2
	apache_1_3_2:1.1.1.2
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	apache:1.1.1
	apache_1_2_6:1.1.1;
locks; strict;
comment	@# @;


1.10
date	2014.04.22.14.47.24;	author henning;	state dead;
branches;
next	1.9;

1.9
date	2005.07.29.23.55.39;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.17.19.13.43;	author henning;	state dead;
branches;
next	1.7;

1.7
date	2002.03.29.02.08.04;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.12.07.56.46;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.29.10.21.25;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.22.17.19;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.06.28.57;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.03.01.01.05.03;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.03.25.07.08.30;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.25.07.08.30;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.10.01.17.19.54;	author beck;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.07.19.21.27.19;	author henning;	state Exp;
branches;
next	;


desc
@@


1.10
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator" content="HTML Tidy, see www.w3.org" />

    <title>Apache Content Negotiation</title>
  </head>
  <!-- Background white, links blue (unvisited), navy (visited), red (active) -->

  <body bgcolor="#FFFFFF" text="#000000" link="#0000FF"
  vlink="#000080" alink="#FF0000">
        <div align="CENTER">
      <img src="images/sub.gif" alt="[APACHE DOCUMENTATION]" /> 

      <h3>Apache HTTP Server</h3>
    </div>



    <h1 align="CENTER">Content Negotiation</h1>

    <p>Apache's support for content negotiation has been updated to
    meet the HTTP/1.1 specification. It can choose the best
    representation of a resource based on the browser-supplied
    preferences for media type, languages, character set and
    encoding. It is also implements a couple of features to give
    more intelligent handling of requests from browsers which send
    incomplete negotiation information.</p>

    <p>Content negotiation is provided by the <a
    href="mod/mod_negotiation.html">mod_negotiation</a> module,
    which is compiled in by default.</p>
    <hr />

    <h2>About Content Negotiation</h2>

    <p>A resource may be available in several different
    representations. For example, it might be available in
    different languages or different media types, or a combination.
    One way of selecting the most appropriate choice is to give the
    user an index page, and let them select. However it is often
    possible for the server to choose automatically. This works
    because browsers can send as part of each request information
    about what representations they prefer. For example, a browser
    could indicate that it would like to see information in French,
    if possible, else English will do. Browsers indicate their
    preferences by headers in the request. To request only French
    representations, the browser would send</p>
<pre>
  Accept-Language: fr
</pre>

    <p>Note that this preference will only be applied when there is
    a choice of representations and they vary by language.</p>

    <p>As an example of a more complex request, this browser has
    been configured to accept French and English, but prefer
    French, and to accept various media types, preferring HTML over
    plain text or other text types, and preferring GIF or JPEG over
    other media types, but also allowing any other media type as a
    last resort:</p>
<pre>
  Accept-Language: fr; q=1.0, en; q=0.5
  Accept: text/html; q=1.0, text/*; q=0.8, image/gif; q=0.6,
        image/jpeg; q=0.6, image/*; q=0.5, */*; q=0.1
</pre>
    Apache 1.2 supports 'server driven' content negotiation, as
    defined in the HTTP/1.1 specification. It fully supports the
    Accept, Accept-Language, Accept-Charset and Accept-Encoding
    request headers. Apache 1.3.4 also supports 'transparent'
    content negotiation, which is an experimental negotiation
    protocol defined in RFC 2295 and RFC 2296. It does not offer
    support for 'feature negotiation' as defined in these RFCs. 

    <p>A <strong>resource</strong> is a conceptual entity
    identified by a URI (RFC 2396). An HTTP server like Apache
    provides access to <strong>representations</strong> of the
    resource(s) within its namespace, with each representation in
    the form of a sequence of bytes with a defined media type,
    character set, encoding, etc. Each resource may be associated
    with zero, one, or more than one representation at any given
    time. If multiple representations are available, the resource
    is referred to as <strong>negotiable</strong> and each of its
    representations is termed a <strong>variant</strong>. The ways
    in which the variants for a negotiable resource vary are called
    the <strong>dimensions</strong> of negotiation.</p>

    <h2>Negotiation in Apache</h2>

    <p>In order to negotiate a resource, the server needs to be
    given information about each of the variants. This is done in
    one of two ways:</p>

    <ul>
      <li>Using a type map (<em>i.e.</em>, a <code>*.var</code>
      file) which names the files containing the variants
      explicitly, or</li>

      <li>Using a 'MultiViews' search, where the server does an
      implicit filename pattern match and chooses from among the
      results.</li>
    </ul>

    <h3>Using a type-map file</h3>

    <p>A type map is a document which is associated with the
    handler named <code>type-map</code> (or, for
    backwards-compatibility with older Apache configurations, the
    mime type <code>application/x-type-map</code>). Note that to
    use this feature, you must have a handler set in the
    configuration that defines a file suffix as
    <code>type-map</code>; this is best done with a</p>
<pre>
  AddHandler type-map .var
</pre>
    in the server configuration file. See the comments in the
    sample config file for more details. 

    <p>Type map files have an entry for each available variant;
    these entries consist of contiguous HTTP-format header lines.
    Entries for different variants are separated by blank lines.
    Blank lines are illegal within an entry. It is conventional to
    begin a map file with an entry for the combined entity as a
    whole (although this is not required, and if present will be
    ignored). An example map file is:</p>
<pre>
  URI: foo

  URI: foo.en.html
  Content-type: text/html
  Content-language: en

  URI: foo.fr.de.html
  Content-type: text/html;charset=iso-8859-2
  Content-language: fr, de
</pre>
    If the variants have different source qualities, that may be
    indicated by the "qs" parameter to the media type, as in this
    picture (available as jpeg, gif, or ASCII-art): 
<pre>
  URI: foo

  URI: foo.jpeg
  Content-type: image/jpeg; qs=0.8

  URI: foo.gif
  Content-type: image/gif; qs=0.5

  URI: foo.txt
  Content-type: text/plain; qs=0.01
</pre>

    <p>qs values can vary in the range 0.000 to 1.000. Note that
    any variant with a qs value of 0.000 will never be chosen.
    Variants with no 'qs' parameter value are given a qs factor of
    1.0. The qs parameter indicates the relative 'quality' of this
    variant compared to the other available variants, independent
    of the client's capabilities. For example, a jpeg file is
    usually of higher source quality than an ascii file if it is
    attempting to represent a photograph. However, if the resource
    being represented is an original ascii art, then an ascii
    representation would have a higher source quality than a jpeg
    representation. A qs value is therefore specific to a given
    variant depending on the nature of the resource it
    represents.</p>

    <p>The full list of headers recognized is:</p>

    <dl>
      <dt><code>URI:</code></dt>

      <dd>uri of the file containing the variant (of the given
      media type, encoded with the given content encoding). These
      are interpreted as URLs relative to the map file; they must
      be on the same server (!), and they must refer to files to
      which the client would be granted access if they were to be
      requested directly.</dd>

      <dt><code>Content-Type:</code></dt>

      <dd>media type --- charset, level and "qs" parameters may be
      given. These are often referred to as MIME types; typical
      media types are <code>image/gif</code>,
      <code>text/plain</code>, or
      <code>text/html;&nbsp;level=3</code>.</dd>

      <dt><code>Content-Language:</code></dt>

      <dd>The languages of the variant, specified as an Internet
      standard language tag from RFC 1766 (<em>e.g.</em>,
      <code>en</code> for English, <code>kr</code> for Korean,
      <em>etc.</em>).</dd>

      <dt><code>Content-Encoding:</code></dt>

      <dd>If the file is compressed, or otherwise encoded, rather
      than containing the actual raw data, this says how that was
      done. Apache only recognizes encodings that are defined by an
      <a href="mod/mod_mime.html#addencoding">AddEncoding</a>
      directive. This normally includes the encodings
      <code>x-compress</code> for compress'd files, and
      <code>x-gzip</code> for gzip'd files. The <code>x-</code>
      prefix is ignored for encoding comparisons.</dd>

      <dt><code>Content-Length:</code></dt>

      <dd>The size of the file. Specifying content lengths in the
      type-map allows the server to compare file sizes without
      checking the actual files.</dd>

      <dt><code>Description:</code></dt>

      <dd>A human-readable textual description of the variant. If
      Apache cannot find any appropriate variant to return, it will
      return an error response which lists all available variants
      instead. Such a variant list will include the human-readable
      variant descriptions.</dd>
    </dl>

    <h3>Multiviews</h3>

    <p><code>MultiViews</code> is a per-directory option, meaning
    it can be set with an <code>Options</code> directive within a
    <code>&lt;Directory&gt;</code>, <code>&lt;Location&gt;</code>
    or <code>&lt;Files&gt;</code> section in
    <code>access.conf</code>, or (if <code>AllowOverride</code> is
    properly set) in <code>.htaccess</code> files. Note that
    <code>Options All</code> does not set <code>MultiViews</code>;
    you have to ask for it by name.</p>

    <p>The effect of <code>MultiViews</code> is as follows: if the
    server receives a request for <code>/some/dir/foo</code>, if
    <code>/some/dir</code> has <code>MultiViews</code> enabled, and
    <code>/some/dir/foo</code> does <em>not</em> exist, then the
    server reads the directory looking for files named foo.*, and
    effectively fakes up a type map which names all those files,
    assigning them the same media types and content-encodings it
    would have if the client had asked for one of them by name. It
    then chooses the best match to the client's requirements.</p>

    <p><code>MultiViews</code> may also apply to searches for the
    file named by the <code>DirectoryIndex</code> directive, if the
    server is trying to index a directory. If the configuration
    files specify</p>
<pre>
  DirectoryIndex index
</pre>
    then the server will arbitrate between <code>index.html</code>
    and <code>index.html3</code> if both are present. If neither
    are present, and <code>index.cgi</code> is there, the server
    will run it. 

    <p>If one of the files found when reading the directive is a
    CGI script, it's not obvious what should happen. The code gives
    that case special treatment --- if the request was a POST, or a
    GET with QUERY_ARGS or PATH_INFO, the script is given an
    extremely high quality rating, and generally invoked; otherwise
    it is given an extremely low quality rating, which generally
    causes one of the other views (if any) to be retrieved.</p>

    <h2>The Negotiation Methods</h2>
    After Apache has obtained a list of the variants for a given
    resource, either from a type-map file or from the filenames in
    the directory, it invokes one of two methods to decide on the
    'best' variant to return, if any. It is not necessary to know
    any of the details of how negotiation actually takes place in
    order to use Apache's content negotiation features. However the
    rest of this document explains the methods used for those
    interested. 

    <p>There are two negotiation methods:</p>

    <ol>
      <li><strong>Server driven negotiation with the Apache
      algorithm</strong> is used in the normal case. The Apache
      algorithm is explained in more detail below. When this
      algorithm is used, Apache can sometimes 'fiddle' the quality
      factor of a particular dimension to achieve a better result.
      The ways Apache can fiddle quality factors is explained in
      more detail below.</li>

      <li><strong>Transparent content negotiation</strong> is used
      when the browser specifically requests this through the
      mechanism defined in RFC 2295. This negotiation method gives
      the browser full control over deciding on the 'best' variant,
      the result is therefore dependent on the specific algorithms
      used by the browser. As part of the transparent negotiation
      process, the browser can ask Apache to run the 'remote
      variant selection algorithm' defined in RFC 2296.</li>
    </ol>

    <h3>Dimensions of Negotiation</h3>

    <table>
      <tr valign="top">
        <th>Dimension</th>

        <th>Notes</th>
      </tr>

      <tr valign="top">
        <td>Media Type</td>

        <td>Browser indicates preferences with the Accept header
        field. Each item can have an associated quality factor.
        Variant description can also have a quality factor (the
        "qs" parameter).</td>
      </tr>

      <tr valign="top">
        <td>Language</td>

        <td>Browser indicates preferences with the Accept-Language
        header field. Each item can have a quality factor. Variants
        can be associated with none, one or more than one
        language.</td>
      </tr>

      <tr valign="top">
        <td>Encoding</td>

        <td>Browser indicates preference with the Accept-Encoding
        header field. Each item can have a quality factor.</td>
      </tr>

      <tr valign="top">
        <td>Charset</td>

        <td>Browser indicates preference with the Accept-Charset
        header field. Each item can have a quality factor. Variants
        can indicate a charset as a parameter of the media
        type.</td>
      </tr>
    </table>

    <h3>Apache Negotiation Algorithm</h3>

    <p>Apache can use the following algorithm to select the 'best'
    variant (if any) to return to the browser. This algorithm is
    not further configurable. It operates as follows:</p>

    <ol>
      <li>First, for each dimension of the negotiation, check the
      appropriate <em>Accept*</em> header field and assign a
      quality to each variant. If the <em>Accept*</em> header for
      any dimension implies that this variant is not acceptable,
      eliminate it. If no variants remain, go to step 4.</li>

      <li>
        Select the 'best' variant by a process of elimination. Each
        of the following tests is applied in order. Any variants
        not selected at each test are eliminated. After each test,
        if only one variant remains, select it as the best match
        and proceed to step 3. If more than one variant remains,
        move on to the next test. 

        <ol>
          <li>Multiply the quality factor from the Accept header
          with the quality-of-source factor for this variant's
          media type, and select the variants with the highest
          value.</li>

          <li>Select the variants with the highest language quality
          factor.</li>

          <li>Select the variants with the best language match,
          using either the order of languages in the
          Accept-Language header (if present), or else the order of
          languages in the <code>LanguagePriority</code> directive
          (if present).</li>

          <li>Select the variants with the highest 'level' media
          parameter (used to give the version of text/html media
          types).</li>

          <li>Select variants with the best charset media
          parameters, as given on the Accept-Charset header line.
          Charset ISO-8859-1 is acceptable unless explicitly
          excluded. Variants with a <code>text/*</code> media type
          but not explicitly associated with a particular charset
          are assumed to be in ISO-8859-1.</li>

          <li>Select those variants which have associated charset
          media parameters that are <em>not</em> ISO-8859-1. If
          there are no such variants, select all variants
          instead.</li>

          <li>Select the variants with the best encoding. If there
          are variants with an encoding that is acceptable to the
          user-agent, select only these variants. Otherwise if
          there is a mix of encoded and non-encoded variants,
          select only the unencoded variants. If either all
          variants are encoded or all variants are not encoded,
          select all variants.</li>

          <li>Select the variants with the smallest content
          length.</li>

          <li>Select the first variant of those remaining. This
          will be either the first listed in the type-map file, or
          when variants are read from the directory, the one whose
          file name comes first when sorted using ASCII code
          order.</li>
        </ol>
      </li>

      <li>The algorithm has now selected one 'best' variant, so
      return it as the response. The HTTP response header Vary is
      set to indicate the dimensions of negotiation (browsers and
      caches can use this information when caching the resource).
      End.</li>

      <li><p>To get here means no variant was selected (because none
      are acceptable to the browser). Return a 406 status (meaning
      "No acceptable representation") with a response body
      consisting of an HTML document listing the available
      variants. Also set the HTTP Vary header to indicate the
      dimensions of variance.</p>

      <p>You should be aware that the error message returned by Apache is
      necessarily rather terse and might confuse some users (even though it
      lists the available alternatives). If you want to avoid users seeing this
      error page, you should organize your documents such that a document in a
      default language (or with a default encoding etc.) is always returned if a
      document is not available in any of the languages, encodings etc. the
      browser asked for.</p>

      <p>In particular, if you want a document in a default language to
      be returned if a document is not available in any of the languages
      a browser asked for, you should create a document with no language
      attribute set.  See <a href="#nolanguage">Variants with no
      Language</a> below for details.</p></li>
    </ol>

    <h2><a id="better" name="better">Fiddling with Quality
    Values</a></h2>

    <p>Apache sometimes changes the quality values from what would
    be expected by a strict interpretation of the Apache
    negotiation algorithm above. This is to get a better result
    from the algorithm for browsers which do not send full or
    accurate information. Some of the most popular browsers send
    Accept header information which would otherwise result in the
    selection of the wrong variant in many cases. If a browser
    sends full and correct information these fiddles will not be
    applied.</p>

    <h3>Media Types and Wildcards</h3>

    <p>The Accept: request header indicates preferences for media
    types. It can also include 'wildcard' media types, such as
    "image/*" or "*/*" where the * matches any string. So a request
    including:</p>
<pre>
  Accept: image/*, */*
</pre>
    would indicate that any type starting "image/" is acceptable,
    as is any other type (so the first "image/*" is redundant).
    Some browsers routinely send wildcards in addition to explicit
    types they can handle. For example: 
<pre>
  Accept: text/html, text/plain, image/gif, image/jpeg, */*
</pre>
    The intention of this is to indicate that the explicitly listed
    types are preferred, but if a different representation is
    available, that is ok too. However under the basic algorithm,
    as given above, the */* wildcard has exactly equal preference
    to all the other types, so they are not being preferred. The
    browser should really have sent a request with a lower quality
    (preference) value for *.*, such as: 
<pre>
  Accept: text/html, text/plain, image/gif, image/jpeg, */*; q=0.01
</pre>
    The explicit types have no quality factor, so they default to a
    preference of 1.0 (the highest). The wildcard */* is given a
    low preference of 0.01, so other types will only be returned if
    no variant matches an explicitly listed type. 

    <p>If the Accept: header contains <em>no</em> q factors at all,
    Apache sets the q value of "*/*", if present, to 0.01 to
    emulate the desired behaviour. It also sets the q value of
    wildcards of the format "type/*" to 0.02 (so these are
    preferred over matches against "*/*". If any media type on the
    Accept: header contains a q factor, these special values are
    <em>not</em> applied, so requests from browsers which send the
    correct information to start with work as expected.</p>

    <h3><a id="nolanguage" name="nolanguage">Variants with no Language</a></h3>

    <p>If some of the variants for a particular resource have a
    language attribute, and some do not, those variants with no
    language are given a very low language quality factor of
    0.001.</p>

    <p>The reason for setting this language quality factor for variant
    with no language to a very low value is to allow for a default
    variant which can be supplied if none of the other variants match
    the browser's language preferences. This allows you to avoid users
    seeing a "406" error page if their browser is set to only accept
    languages which you do not offer for the resource that was
    requested.</p>

    <p>For example, consider the situation with Multiviews enabled and
    three variants:</p>

    <ul>
      <li>foo.en.html, language en</li>

      <li>foo.fr.html, language en</li>

      <li>foo.html, no language</li>
    </ul>

    <p>The meaning of a variant with no language is that it is always
    acceptable to the browser. If the request is for <code>foo</code>
    and the Accept-Language header includes either en or fr (or both)
    one of foo.en.html or foo.fr.html will be returned. If the browser
    does not list either en or fr as acceptable, foo.html will be
    returned instead.  If the client requests <code>foo.html</code>
    instead, then no negotiation will occur since the exact match
    will be returned.  To avoid this problem, it is sometimes helpful
    to name the "no language" variant <code>foo.html.html</code> to assure
    that Multiviews and language negotiation will come into play.</p>

    <h2>Extensions to Transparent Content Negotiation</h2>
    Apache extends the transparent content negotiation protocol
    (RFC 2295) as follows. A new <code>{encoding ..}</code> element
    is used in variant lists to label variants which are available
    with a specific content-encoding only. The implementation of
    the RVSA/1.0 algorithm (RFC 2296) is extended to recognize
    encoded variants in the list, and to use them as candidate
    variants whenever their encodings are acceptable according to
    the Accept-Encoding request header. The RVSA/1.0 implementation
    does not round computed quality factors to 5 decimal places
    before choosing the best variant. 

    <h2>Note on hyperlinks and naming conventions</h2>

    <p>If you are using language negotiation you can choose between
    different naming conventions, because files can have more than
    one extension, and the order of the extensions is normally
    irrelevant (see <a href="mod/mod_mime.html">mod_mime</a>
    documentation for details).</p>

    <p>A typical file has a MIME-type extension (<em>e.g.</em>,
    <samp>html</samp>), maybe an encoding extension (<em>e.g.</em>,
    <samp>gz</samp>), and of course a language extension
    (<em>e.g.</em>, <samp>en</samp>) when we have different
    language variants of this file.</p>

    <p>Examples:</p>

    <ul>
      <li>foo.en.html</li>

      <li>foo.html.en</li>

      <li>foo.en.html.gz</li>
    </ul>

    <p>Here some more examples of filenames together with valid and
    invalid hyperlinks:</p>

    <table border="1" cellpadding="8" cellspacing="0">
      <tr>
        <th>Filename</th>

        <th>Valid hyperlink</th>

        <th>Invalid hyperlink</th>
      </tr>

      <tr>
        <td><em>foo.html.en</em></td>

        <td>foo<br />
         foo.html</td>

        <td>-</td>
      </tr>

      <tr>
        <td><em>foo.en.html</em></td>

        <td>foo</td>

        <td>foo.html</td>
      </tr>

      <tr>
        <td><em>foo.html.en.gz</em></td>

        <td>foo<br />
         foo.html</td>

        <td>foo.gz<br />
         foo.html.gz</td>
      </tr>

      <tr>
        <td><em>foo.en.html.gz</em></td>

        <td>foo</td>

        <td>foo.html<br />
         foo.html.gz<br />
         foo.gz</td>
      </tr>

      <tr>
        <td><em>foo.gz.html.en</em></td>

        <td>foo<br />
         foo.gz<br />
         foo.gz.html</td>

        <td>foo.html</td>
      </tr>

      <tr>
        <td><em>foo.html.gz.en</em></td>

        <td>foo<br />
         foo.html<br />
         foo.html.gz</td>

        <td>foo.gz</td>
      </tr>
    </table>

    <p>Looking at the table above you will notice that it is always
    possible to use the name without any extensions in a hyperlink
    (<em>e.g.</em>, <samp>foo</samp>). The advantage is that you
    can hide the actual type of a document rsp. file and can change
    it later, <em>e.g.</em>, from <samp>html</samp> to
    <samp>shtml</samp> or <samp>cgi</samp> without changing any
    hyperlink references.</p>

    <p>If you want to continue to use a MIME-type in your
    hyperlinks (<em>e.g.</em> <samp>foo.html</samp>) the language
    extension (including an encoding extension if there is one)
    must be on the right hand side of the MIME-type extension
    (<em>e.g.</em>, <samp>foo.html.en</samp>).</p>

    <h2>Note on Caching</h2>

    <p>When a cache stores a representation, it associates it with
    the request URL. The next time that URL is requested, the cache
    can use the stored representation. But, if the resource is
    negotiable at the server, this might result in only the first
    requested variant being cached and subsequent cache hits might
    return the wrong response. To prevent this, Apache normally
    marks all responses that are returned after content negotiation
    as non-cacheable by HTTP/1.0 clients. Apache also supports the
    HTTP/1.1 protocol features to allow caching of negotiated
    responses.</p>

    <p>For requests which come from a HTTP/1.0 compliant client
    (either a browser or a cache), the directive
    <tt>CacheNegotiatedDocs</tt> can be used to allow caching of
    responses which were subject to negotiation. This directive can
    be given in the server config or virtual host, and takes no
    arguments. It has no effect on requests from HTTP/1.1 clients. 
        <hr />

    <h3 align="CENTER">Apache HTTP Server</h3>
    <a href="./"><img src="images/index.gif" alt="Index" /></a>

    </p>
  </body>
</html>



@


1.9
log
@from tamas tevesz:
==> de-multiviewification complete.

(rename *.html.html -> *.html)
@
text
@@


1.8
log
@these are gone since some time too
@
text
@d1 2
d425 12
a436 12
   neccessarily rather terse and might confuse some users (even though it
   lists the available alternatives). If you want to avoid users seeing this
   error page, you should organize your documents such that a document in a
   default language (or with a default encoding etc.) is always returned if a
   document is not available in any of the languages, encodings etc. the
   browser asked for.</p>

   <p>In particular, if you want a document in a default language to
   be returned if a document is not available in any of the languages
   a browser asked for, you should create a document with no language
   attribute set.  See <a href="#nolanguage">Variants with no
   Language</a> below for details.</p></li>
d485 1
a485 1
    emulate the desired behavior. It also sets the q value of
d492 1
a492 1
    <h3><a name="nolanguage">Variants with no Language</a></h3>
d504 1
a504 1
    languages which you do not offer for the ressource that was
d524 1
a524 1
    instead, then no negotation will occur since the exact match
d636 1
a636 1
    possible to use the name without any extensions in an hyperlink
d676 2
@


1.7
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@@


1.6
log
@Apache 1.3.23+mod_ssl-2.8.6-1.3.23 merge
@
text
@d415 1
a415 1
      <li>To get here means no variant was selected (because none
d420 15
a434 1
      dimensions of variance.</li>
d490 1
a490 1
    <h3>Variants with no Language</h3>
d497 10
a506 5
    <p>The reason for setting this language quality factor for
    variant with no language to a very low value is to allow for a
    default variant which can be supplied if none of the other
    variants match the browser's language preferences. For example,
    consider the situation with three variants:</p>
d516 4
a519 4
    <p>The meaning of a variant with no language is that it is
    always acceptable to the browser. If the request
    Accept-Language header includes either en or fr (or both) one
    of foo.en.html or foo.fr.html will be returned. If the browser
d521 5
a525 1
    returned instead.</p>
@


1.5
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d1 2
a2 51
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>Apache Content Negotiation</TITLE>
</HEAD>

<!-- Background white, links blue (unvisited), navy (visited), red (active) -->
<BODY
 BGCOLOR="#FFFFFF"
 TEXT="#000000"
 LINK="#0000FF"
 VLINK="#000080"
 ALINK="#FF0000"
>
<DIV ALIGN="CENTER">
 <IMG SRC="images/sub.gif" ALT="[APACHE DOCUMENTATION]">
 <H3>
  Apache HTTP Server
 </H3>
</DIV>

<H1 ALIGN="CENTER">Content Negotiation</H1>

<P>
Apache's support for content negotiation has been updated to meet the
HTTP/1.1 specification. It can choose the best representation of a
resource based on the browser-supplied preferences for media type,
languages, character set and encoding.  It is also implements a
couple of features to give more intelligent handling of requests from
browsers which send incomplete negotiation information.  <P>

Content negotiation is provided by the
<A HREF="mod/mod_negotiation.html">mod_negotiation</A> module,
which is compiled in by default.

<HR>

<H2>About Content Negotiation</H2>

<P>
A resource may be available in several different representations. For
example, it might be available in different languages or different
media types, or a combination.  One way of selecting the most
appropriate choice is to give the user an index page, and let them
select. However it is often possible for the server to choose
automatically. This works because browsers can send as part of each
request information about what representations they prefer. For
example, a browser could indicate that it would like to see
information in French, if possible, else English will do. Browsers
indicate their preferences by headers in the request. To request only
French representations, the browser would send
d4 48
a51 1
<PRE>
d53 1
a53 1
</PRE>
d55 2
a56 10
<P>
Note that this preference will only be applied when there is a choice
of representations and they vary by language.
<P>

As an example of a more complex request, this browser has been
configured to accept French and English, but prefer French, and to
accept various media types, preferring HTML over plain text or other
text types, and preferring GIF or JPEG over other media types, but also
allowing any other media type as a last resort:
d58 7
a64 1
<PRE>
d68 48
a115 48
</PRE>

Apache 1.2 supports 'server driven' content negotiation, as defined in
the HTTP/1.1 specification. It fully supports the Accept,
Accept-Language, Accept-Charset and Accept-Encoding request headers.
Apache 1.3.4 also supports 'transparent' content negotiation, which is
an experimental negotiation protocol defined in RFC 2295 and RFC 2296.
It does not offer support for 'feature negotiation' as defined in
these RFCs.  
<P>

A <STRONG>resource</STRONG> is a conceptual entity identified by a URI
(RFC 2396).  An HTTP server like Apache provides access to
<STRONG>representations</STRONG> of the resource(s) within its namespace,
with each representation in the form of a sequence of bytes with a
defined media type, character set, encoding, etc.  Each resource may be
associated with zero, one, or more than one representation
at any given time.  If multiple representations are available,
the resource is referred to as <STRONG>negotiable</STRONG> and each of its
representations is termed a <STRONG>variant</STRONG>. The ways in which the
variants for a negotiable resource vary are called the
<STRONG>dimensions</STRONG> of negotiation.

<H2>Negotiation in Apache</H2>

<P>
In order to negotiate a resource, the server needs to be given
information about each of the variants. This is done in one of two
ways:

<UL>
  <LI> Using a type map (<EM>i.e.</EM>, a <CODE>*.var</CODE> file) which
       names the files containing the variants explicitly, or
  <LI> Using a 'MultiViews' search, where the server does an implicit
       filename pattern match and chooses from among the results.
</UL>

<H3>Using a type-map file</H3>

<P>
A type map is a document which is associated with the handler
named <CODE>type-map</CODE> (or, for backwards-compatibility with
older Apache configurations, the mime type
<CODE>application/x-type-map</CODE>).  Note that to use this feature,
you must have a handler set in the configuration that defines a
file suffix as <CODE>type-map</CODE>; this is best done with a

<PRE>
d117 12
a128 14
</PRE>

in the server configuration file.  See the comments in the sample config
file for more details. <P>

Type map files have an entry for each available variant; these entries
consist of contiguous HTTP-format header lines.  Entries for
different variants are separated by blank lines.  Blank lines are
illegal within an entry.  It is conventional to begin a map file with
an entry for the combined entity as a whole (although this
is not required, and if present will be ignored). An example
map file is:

<PRE>
d138 5
a142 7
</PRE>

If the variants have different source qualities, that may be indicated
by the "qs" parameter to the media type, as in this picture (available
as jpeg, gif, or ASCII-art):

<PRE>
d153 1
a153 2
</PRE>
<P>
d155 93
a247 79
qs values can vary in the range 0.000 to 1.000. Note that any variant with
a qs value of 0.000 will never be chosen. Variants with no 'qs'
parameter value are given a qs factor of 1.0. The qs parameter indicates
the relative 'quality' of this variant compared to the other available
variants, independent of the client's capabilities.  For example, a jpeg
file is usually of higher source quality than an ascii file if it is
attempting to represent a photograph.  However, if the resource being
represented is an original ascii art, then an ascii representation would
have a higher source quality than a jpeg representation.  A qs value
is therefore specific to a given variant depending on the nature of
the resource it represents.

<P>
The full list of headers recognized is:

<DL>
  <DT> <CODE>URI:</CODE>
  <DD> uri of the file containing the variant (of the given media
       type, encoded with the given content encoding).  These are
       interpreted as URLs relative to the map file; they must be on
       the same server (!), and they must refer to files to which the
       client would be granted access if they were to be requested
       directly.
  <DT> <CODE>Content-Type:</CODE>
  <DD> media type --- charset, level and "qs" parameters may be given.  These
       are often referred to as MIME types; typical media types are
       <CODE>image/gif</CODE>, <CODE>text/plain</CODE>, or
       <CODE>text/html;&nbsp;level=3</CODE>.
  <DT> <CODE>Content-Language:</CODE>
  <DD> The languages of the variant, specified as an Internet standard
       language tag from RFC 1766 (<EM>e.g.</EM>, <CODE>en</CODE> for English,
       <CODE>kr</CODE> for Korean, <EM>etc.</EM>).
  <DT> <CODE>Content-Encoding:</CODE>
  <DD> If the file is compressed, or otherwise encoded, rather than
       containing the actual raw data, this says how that was done.
       Apache only recognizes encodings that are defined by an
       <A HREF="mod/mod_mime.html#addencoding">AddEncoding</A> directive.
       This normally includes the encodings <CODE>x-compress</CODE>
       for compress'd files, and <CODE>x-gzip</CODE> for gzip'd files.
       The <CODE>x-</CODE> prefix is ignored for encoding comparisons.
  <DT> <CODE>Content-Length:</CODE>
  <DD> The size of the file.  Specifying content
       lengths in the type-map allows the server to compare file sizes
       without checking the actual files.
  <DT> <CODE>Description:</CODE>
  <DD> A human-readable textual description of the variant.  If Apache cannot
       find any appropriate variant to return, it will return an error 
       response which lists all available variants instead.  Such a variant
       list will include the human-readable variant descriptions.
</DL>

<H3>Multiviews</H3>

<P>
<CODE>MultiViews</CODE> is a per-directory option, meaning it can be set with
an <CODE>Options</CODE> directive within a <CODE>&lt;Directory&gt;</CODE>,
<CODE>&lt;Location&gt;</CODE> or <CODE>&lt;Files&gt;</CODE>
section in <CODE>access.conf</CODE>, or (if <CODE>AllowOverride</CODE>
is properly set) in <CODE>.htaccess</CODE> files.  Note that
<CODE>Options All</CODE> does not set <CODE>MultiViews</CODE>; you
have to ask for it by name.

<P>
The effect of <CODE>MultiViews</CODE> is as follows: if the server
receives a request for <CODE>/some/dir/foo</CODE>, if
<CODE>/some/dir</CODE> has <CODE>MultiViews</CODE> enabled, and
<CODE>/some/dir/foo</CODE> does <EM>not</EM> exist, then the server reads the
directory looking for files named foo.*, and effectively fakes up a
type map which names all those files, assigning them the same media
types and content-encodings it would have if the client had asked for
one of them by name.  It then chooses the best match to the client's
requirements.

<P>
<CODE>MultiViews</CODE> may also apply to searches for the file named by the
<CODE>DirectoryIndex</CODE> directive, if the server is trying to
index a directory. If the configuration files specify

<PRE>
d249 194
a442 169
</PRE>

then the server will arbitrate between <CODE>index.html</CODE>
and <CODE>index.html3</CODE> if both are present.  If neither are
present, and <CODE>index.cgi</CODE> is there, the server will run it.

<P>
If one of the files found when reading the directive is a CGI script,
it's not obvious what should happen.  The code gives that case
special treatment --- if the request was a POST, or a GET with
QUERY_ARGS or PATH_INFO, the script is given an extremely high quality
rating, and generally invoked; otherwise it is given an extremely low
quality rating, which generally causes one of the other views (if any)
to be retrieved.

<H2>The Negotiation Methods</H2>

After Apache has obtained a list of the variants for a given resource,
either from a type-map file or from the filenames in the directory, it
invokes one of two methods to decide on the 'best' variant to
return, if any.  It is not necessary to know any of the details of how
negotiation actually takes place in order to use Apache's content
negotiation features. However the rest of this document explains the
methods used for those interested.
<P>

There are two negotiation methods:

<OL> 

<LI><STRONG>Server driven negotiation with the Apache
algorithm</STRONG> is used in the normal case.  The Apache algorithm is
explained in more detail below.  When this algorithm is used, Apache
can sometimes 'fiddle' the quality factor of a particular dimension to
achieve a better result. The ways Apache can fiddle quality factors is
explained in more detail below.

<LI><STRONG>Transparent content negotiation</STRONG> is used when the
browser specifically requests this through the mechanism defined in RFC
2295.  This negotiation method gives the browser full control over
deciding on the 'best' variant, the result is therefore dependent on
the specific algorithms used by the browser.  As part of the
transparent negotiation process, the browser can ask Apache to run the
'remote variant selection algorithm' defined in RFC 2296.  

</OL>


<H3>Dimensions of Negotiation</H3>

<TABLE>
<TR valign="top">
<TH>Dimension
<TH>Notes
<TR valign="top">
<TD>Media Type
<TD>Browser indicates preferences with the Accept header field. Each item
can have an associated quality factor. Variant description can also
have a quality factor (the "qs" parameter).
<TR valign="top">
<TD>Language
<TD>Browser indicates preferences with the Accept-Language header field.
Each item can have a quality factor. Variants can be associated with none, one
or more than one language.
<TR valign="top">
<TD>Encoding
<TD>Browser indicates preference with the Accept-Encoding header field.
Each item can have a quality factor.
<TR valign="top">
<TD>Charset
<TD>Browser indicates preference with the Accept-Charset header field.
Each item can have a quality factor.
Variants can indicate a charset as a parameter of the media type.
</TABLE>

<H3>Apache Negotiation Algorithm</H3>

<P>
Apache can use the following algorithm to select the 'best' variant
(if any) to return to the browser.  This algorithm is not
further configurable. It operates as follows:

<OL>
<LI>First, for each dimension of the negotiation, check the appropriate
<EM>Accept*</EM> header field and assign a quality to each
variant. If the <EM>Accept*</EM> header for any dimension implies that this
variant is not acceptable, eliminate it. If no variants remain, go
to step 4.

<LI>Select the 'best' variant by a process of elimination. Each of the
following tests is applied in order. Any variants not selected at each
test are eliminated. After each test, if only one variant remains,
select it as the best match and proceed to step 3. If more than one
variant remains, move on to the next test.

<OL>
<LI>Multiply the quality factor from the Accept header with the
  quality-of-source factor for this variant's media type, and select
  the variants with the highest value.

<LI>Select the variants with the highest language quality factor.

<LI>Select the variants with the best language match, using either the
  order of languages in the Accept-Language header (if present), or else 
  the order of languages in the <CODE>LanguagePriority</CODE> 
  directive (if present).

<LI>Select the variants with the highest 'level' media parameter
  (used to give the version of text/html media types).

<LI>Select variants with the best charset media parameters,
  as given on the Accept-Charset header line. Charset ISO-8859-1
  is acceptable unless explicitly excluded. Variants with a
  <CODE>text/*</CODE> media type but not explicitly associated
  with a particular charset are assumed to be in ISO-8859-1.

<LI>Select those variants which have associated
    charset media parameters that are <EM>not</EM> ISO-8859-1.
    If there are no such variants, select all variants instead.

<LI>Select the variants with the best encoding. If there are
  variants with an encoding that is acceptable to the user-agent,
  select only these variants. Otherwise if there is a mix of encoded
  and non-encoded variants, select only the unencoded variants.
  If either all variants are encoded or all variants are not encoded, 
  select all variants.

<LI>Select the variants with the smallest content length.

<LI>Select the first variant of those remaining. This will be either the
  first listed in the type-map file, or when variants are read from
  the directory, the one whose file name comes first when sorted using
  ASCII code order.

</OL>

<LI>The algorithm has now selected one 'best' variant, so return
  it as the response. The HTTP response header Vary is set to indicate the
  dimensions of negotiation (browsers and caches can use this
  information when caching the resource). End.

<LI>To get here means no variant was selected (because none are acceptable
  to the browser). Return a 406 status (meaning "No acceptable representation")
  with a response body consisting of an HTML document listing the
  available variants. Also set the HTTP Vary header to indicate the
  dimensions of variance.

</OL>

<H2><A NAME="better">Fiddling with Quality Values</A></H2>

<P> 
Apache sometimes changes the quality values from what would be
expected by a strict interpretation of the Apache negotiation
algorithm above. This is to get a better result from the algorithm for
browsers which do not send full or accurate information. Some of the
most popular browsers send Accept header information which would
otherwise result in the selection of the wrong variant in many
cases. If a browser sends full and correct information these fiddles
will not be applied.
<P>

<H3>Media Types and Wildcards</H3>

<P>
The Accept: request header indicates preferences for media types. It
can also include 'wildcard' media types, such as "image/*" or "*/*"
where the * matches any string. So a request including:
<PRE>
d444 6
a449 7
</PRE>

would indicate that any type starting "image/" is acceptable,
as is any other type (so the first "image/*" is redundant). Some
browsers routinely send wildcards in addition to explicit types they
can handle. For example:
<PRE>
d451 9
a459 10
</PRE>

The intention of this is to indicate that the explicitly
listed types are preferred, but if a different representation is
available, that is ok too. However under the basic algorithm, as given
above, the */* wildcard has exactly equal preference to all the other
types, so they are not being preferred. The browser should really have
sent a request with a lower quality (preference) value for *.*, such
as:
<PRE>
d461 190
a650 167
</PRE>

The explicit types have no quality factor, so they default to a
preference of 1.0 (the highest). The wildcard */* is given
a low preference of 0.01, so other types will only be returned if
no variant matches an explicitly listed type.
<P>

If the Accept: header contains <EM>no</EM> q factors at all, Apache sets
the q value of "*/*", if present, to 0.01 to emulate the desired
behavior. It also sets the q value of wildcards of the format
"type/*" to 0.02 (so these are preferred over matches against
"*/*". If any media type on the Accept: header contains a q factor,
these special values are <EM>not</EM> applied, so requests from browsers
which send the correct information to start with work as expected.

<H3>Variants with no Language</H3>

<P>
If some of the variants for a particular resource have a language
attribute, and some do not, those variants with no language
are given a very low language quality factor of 0.001.<P>

The reason for setting this language quality factor for
variant with no language to a very low value is to allow
for a default variant which can be supplied if none of the
other variants match the browser's language preferences.

For example, consider the situation with three variants:

<UL>
<LI>foo.en.html, language en
<LI>foo.fr.html, language en
<LI>foo.html, no language
</UL>

<P>
The meaning of a variant with no language is that it is
always acceptable to the browser. If the request Accept-Language
header includes either en or fr (or both) one of foo.en.html
or foo.fr.html will be returned. If the browser does not list
either en or fr as acceptable, foo.html will be returned instead.

<H2>Extensions to Transparent Content Negotiation</H2>

Apache extends the transparent content negotiation protocol (RFC 2295)
as follows.  A new <CODE> {encoding ..}</CODE> element is used in
variant lists to label variants which are available with a specific
content-encoding only. The implementation of the
RVSA/1.0 algorithm (RFC 2296) is extended to recognize encoded
variants in the list, and to use them as candidate variants whenever
their encodings are acceptable according to the Accept-Encoding
request header.  The RVSA/1.0 implementation does not round computed
quality factors to 5 decimal places before choosing the best variant.

<H2>Note on hyperlinks and naming conventions</H2>

<P>
If you are using language negotiation you can choose between
different naming conventions, because files can have more than one
extension, and the order of the extensions is normally irrelevant
(see <A HREF="mod/mod_mime.html">mod_mime</A> documentation for details).
<P>
A typical file has a MIME-type extension (<EM>e.g.</EM>, <SAMP>html</SAMP>),
maybe an encoding extension (<EM>e.g.</EM>, <SAMP>gz</SAMP>), and of course a
language extension (<EM>e.g.</EM>, <SAMP>en</SAMP>) when we have different
language variants of this file.

<P>
Examples:
<UL>
<LI>foo.en.html
<LI>foo.html.en
<LI>foo.en.html.gz
</UL>

<P>
Here some more examples of filenames together with valid and invalid
hyperlinks:
</P>

<TABLE BORDER=1 CELLPADDING=8 CELLSPACING=0>
<TR>
 <TH>Filename</TH>
 <TH>Valid hyperlink</TH>
 <TH>Invalid hyperlink</TH>
</TR>
<TR>
 <TD><EM>foo.html.en</EM></TD>
 <TD>foo<BR>
     foo.html</TD>
 <TD>-</TD>
</TR>
<TR>
 <TD><EM>foo.en.html</EM></TD>
 <TD>foo</TD>
 <TD>foo.html</TD>
</TR>
<TR>
 <TD><EM>foo.html.en.gz</EM></TD>
 <TD>foo<BR>
     foo.html</TD>
 <TD>foo.gz<BR>
     foo.html.gz</TD>
</TR>
<TR>
 <TD><EM>foo.en.html.gz</EM></TD>
 <TD>foo</TD>
 <TD>foo.html<BR>
     foo.html.gz<BR>
     foo.gz</TD>
</TR>
<TR>
 <TD><EM>foo.gz.html.en</EM></TD>
 <TD>foo<BR>
     foo.gz<BR>
     foo.gz.html</TD>
 <TD>foo.html</TD>
</TR>
<TR>
 <TD><EM>foo.html.gz.en</EM></TD>
 <TD>foo<BR>
     foo.html<BR>
     foo.html.gz</TD>
 <TD>foo.gz</TD>
</TR>
</TABLE>

<P>
Looking at the table above you will notice that it is always possible to
use the name without any extensions  in an hyperlink (<EM>e.g.</EM>, <SAMP>foo</SAMP>).
The advantage is that you can hide the actual type of a
document rsp. file and can change it later, <EM>e.g.</EM>, from <SAMP>html</SAMP>
to <SAMP>shtml</SAMP> or <SAMP>cgi</SAMP> without changing any
hyperlink references.

<P>
If you want to continue to use a MIME-type in your hyperlinks (<EM>e.g.</EM>
<SAMP>foo.html</SAMP>) the language extension (including an encoding extension
if there is one) must be on the right hand side of the MIME-type extension
(<EM>e.g.</EM>, <SAMP>foo.html.en</SAMP>).


<H2>Note on Caching</H2>

<P>
When a cache stores a representation, it associates it with the request URL.
The next time that URL is requested, the cache can use the stored
representation. But, if the resource is negotiable at the server,
this might result in only the first requested variant being cached and
subsequent cache hits might return the wrong response. To prevent this,
Apache normally marks all responses that are returned after content negotiation
as non-cacheable by HTTP/1.0 clients. Apache also supports the HTTP/1.1
protocol features to allow caching of negotiated responses. <P>

For requests which come from a HTTP/1.0 compliant client (either a
browser or a cache), the directive <TT>CacheNegotiatedDocs</TT> can be
used to allow caching of responses which were subject to negotiation.
This directive can be given in the server config or virtual host, and
takes no arguments. It has no effect on requests from HTTP/1.1 clients.

<HR>
 <H3 ALIGN="CENTER">
  Apache HTTP Server
 </H3>

<A HREF="./"><IMG SRC="images/index.gif" ALT="Index"></A>
a651 2
</BODY>
</HTML>
@


1.4
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d120 1
a120 1
  AddHandler type-map var
d348 1
a348 1
  else the order of languages in the <CODE>LanguagePriority</CODE> 
@


1.3
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d18 1
a18 1
  Apache HTTP Server Version 1.3
d287 3
a289 1
'remote variant selection algorithm' defined in RFC 2296.  </UL>
d596 1
a596 1
  Apache HTTP Server Version 1.3
@


1.2
log
@Apache 1.3.4 merge
@
text
@d77 17
a93 8
<P>

The terms used in content negotiation are: a <STRONG>resource</STRONG> is an
item which can be requested of a server, which might be selected as
the result of a content negotiation algorithm. If a resource is
available in several formats, these are called <STRONG>representations</STRONG>
or <STRONG>variants</STRONG>. The ways in which the variants for a particular
resource vary are called the <STRONG>dimensions</STRONG> of negotiation.
d104 3
a106 3
       names the files containing the variants explicitly
  <LI> Or using a 'MultiViews' search, where the server does an implicit
       filename pattern match, and chooses from among the results.
d116 1
a116 1
you've got to have a <CODE>SetHandler</CODE> some place which defines a
d118 1
a119 1

d121 1
d123 2
a124 3
</PRE>
in <CODE>srm.conf</CODE>.  See comments in the sample config files for
details. <P>
d127 1
a127 1
consist of contiguous RFC822-format header lines.  Entries for
d133 1
a134 1

d142 1
a142 1
  Content-type: text/html; charset=iso-8859-2
d149 1
a160 1

d164 1
a164 1
qs values can vary between 0.000 and 1.000. Note that any variant with
d166 9
a174 1
parameter value are given a qs factor of 1.0.  <P>
d176 1
d187 1
a187 1
  <DT> <CODE>Content-type:</CODE>
d192 1
a192 1
  <DT> <CODE>Content-language:</CODE>
d194 1
a194 1
       language code (<EM>e.g.</EM>, <CODE>en</CODE> for English,
d196 1
a196 1
  <DT> <CODE>Content-encoding:</CODE>
d199 14
a212 8
       For compressed files (the only case where this generally comes
       up), content encoding should be
       <CODE>x-compress</CODE>, or <CODE>x-gzip</CODE>, as appropriate.
  <DT> <CODE>Content-length:</CODE>
  <DD> The size of the file.  Clients can ask to receive a given media
       type only if the variant isn't too big; specifying a content
       length in the map allows the server to compare against these
       thresholds without checking the actual file.
d218 2
a219 2
This is a per-directory option, meaning it can be set with an
<CODE>Options</CODE> directive within a <CODE>&lt;Directory&gt;</CODE>,
d224 1
a224 2
have to ask for it by name.  (Fixing this is a one-line change to
<CODE>http_core.h</CODE>).
a226 1

d235 1
a235 1
requirements, and forwards them along.
d238 3
a241 3
This applies to searches for the file named by the
<CODE>DirectoryIndex</CODE> directive, if the server is trying to
index a directory; if the configuration files specify
a242 1

d244 1
d246 1
a246 1
</PRE> then the server will arbitrate between <CODE>index.html</CODE>
a250 1

d259 1
a259 1
<H2>The Negotiation Algorithm</H2>
d263 26
a288 10
applies a algorithm to decide on the 'best' variant to return, if
any. To do this it calculates a quality value for each variant in each
of the dimensions of variance. It is not necessary to know any of the
details of how negotiation actually takes place in order to use Apache's
content negotiation features. However the rest of this document
explains in detail the algorithm used for those interested.  <P>

In some circumstances, Apache can 'fiddle' the quality factor of a
particular dimension to achieve a better result. The ways Apache can
fiddle quality factors is explained in more detail below.
d293 2
a294 1
<TR><TH>Dimension
d296 3
a298 2
<TR><TD>Media Type
<TD>Browser indicates preferences on Accept: header. Each item
d300 15
a314 11
have a quality factor.
<TR><TD>Language
<TD>Browser indicates preferences on Accept-Language: header. Each
item
can have a quality factor. Variants can be associated with none, one
or more languages.
<TR><TD>Encoding
<TD>Browser indicates preference with Accept-Encoding: header.
<TR><TD>Charset
<TD>Browser indicates preference with Accept-Charset: header. Variants
can indicate a charset as a parameter of the media type.
d320 3
a322 3
Apache uses an algorithm to select the 'best' variant (if any) to
return to the browser. This algorithm is not configurable. It operates
like this:
d325 3
a327 4
<LI>
Firstly, for each dimension of the negotiation, the appropriate
Accept header is checked and a quality assigned to this each
variant. If the Accept header for any dimension means that this
d331 5
a335 5
<LI>Select the 'best' variant by a process of elimination. Each of
the following tests is applied in order. Any variants not selected at
each stage are eliminated. After each test, if only one variant
remains, it is selected as the best match. If more than one variant
remains, move onto the next test.
d340 1
a340 1
  the variants with the highest value
d342 1
a342 1
<LI>Select the variants with the highest language quality factor
d345 3
a347 3
  order of languages on the <CODE>LanguagePriority</CODE> directive (if
  present),
  else the order of languages on the Accept-Language header.
d352 10
d369 1
a369 6
<LI>Select only variants with acceptable charset media parameters,
  as given on the Accept-Charset header line. Charset ISO-8859-1
  is always acceptable. Variants not associated with a particular
  charset are assumed to be in ISO-8859-1.

<LI>Select the variants with the smallest content length
d371 4
a374 3
<LI>Select the first variant of those remaining (this will be either the
first listed in the type-map file, or the first read from the directory)
and go to stage 3.
d383 1
a383 1
<LI>To get here means no variant was selected (because non are acceptable
d393 1
a393 1
<P>
d395 7
a401 7
expected by a strict interpretation of the algorithm above. This is to
get a better result from the algorithm for browsers which do not send
full or accurate information. Some of the most popular browsers send
Accept header information which would otherwise result in the
selection of the wrong variant in many cases. If a browser
sends full and correct information these fiddles will not
be applied.
d474 12
d577 1
a577 1
When a cache stores a document, it associates it with the request URL.
d579 3
a581 4
document, provided it is still within date. But if the resource is
subject to content negotiation at the server, this would result in
only the first requested variant being cached, and subsequent cache
hits could return the wrong response. To prevent this,
d590 1
a590 2
takes no arguments. It has no effect on requests from HTTP/1.1
clients.
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
  Apache HTTP Server Version 1.2
d22 1
a22 1
<h1 ALIGN="CENTER">Content Negotiation</h1>
d24 1
d30 1
a30 1
browsers which send incomplete negotiation information.  <p>
d32 2
a33 2
Content negotiation is provided by the 
<a href="mod/mod_negotiation.html">mod_negotiation</a> module,
d36 1
a36 1
<hr>
d38 1
a38 1
<h2>About Content Negotiation</h2>
d40 1
d53 1
a53 1
<pre>
d55 1
a55 1
</pre>
d57 1
d59 2
a60 2
of representations and they vary by language. 
<p>
d68 1
a68 1
<pre>
d72 1
a72 1
</pre>
d77 1
a77 1
<p>
d79 1
a79 1
The terms used in content negotiation are: a <b>resource</b> is an
d82 3
a84 3
available in several formats, these are called <b>representations</b>
or <b>variants</b>. The ways in which the variants for a particular
resource vary are called the <b>dimensions</b> of negotiation.
d86 1
a86 1
<h2>Negotiation in Apache</h2>
d88 1
d91 1
a91 1
ways: 
d93 2
a94 2
<ul>
  <li> Using a type map (i.e., a <code>*.var</code> file) which
d96 1
a96 1
  <li> Or using a 'MultiViews' search, where the server does an implicit 
d98 1
a98 1
</ul>
d100 1
a100 1
<h3>Using a type-map file</h3>
d102 1
d104 1
a104 1
named <code>type-map</code> (or, for backwards-compatibility with
d106 4
a109 4
<code>application/x-type-map</code>).  Note that to use this feature,
you've got to have a <code>SetHandler</code> some place which defines a
file suffix as <code>type-map</code>; this is best done with a
<pre>
d113 3
a115 3
</pre>
in <code>srm.conf</code>.  See comments in the sample config files for
details. <p>
d124 1
a124 1
<pre>
d135 1
a135 1
</pre>
d140 1
a140 1
<pre>
d152 2
a153 2
</pre>
<p>
d157 1
a157 1
parameter value are given a qs factor of 1.0.  <p>
d161 3
a163 3
<dl>
  <dt> <code>URI:</code>
  <dd> uri of the file containing the variant (of the given media
d168 3
a170 3
       directly. 
  <dt> <code>Content-type:</code>
  <dd> media type --- charset, level and "qs" parameters may be given.  These
d172 8
a179 8
       <code>image/gif</code>, <code>text/plain</code>, or
       <code>text/html;&nbsp;level=3</code>.
  <dt> <code>Content-language:</code>
  <dd> The languages of the variant, specified as an Internet standard
       language code (e.g., <code>en</code> for English,
       <code>kr</code> for Korean, etc.).
  <dt> <code>Content-encoding:</code>
  <dd> If the file is compressed, or otherwise encoded, rather than
d183 3
a185 3
       <code>x-compress</code>, or <code>x-gzip</code>, as appropriate.
  <dt> <code>Content-length:</code>
  <dd> The size of the file.  Clients can ask to receive a given media
d189 1
a189 1
</dl>
d191 1
a191 1
<h3>Multiviews</h3>
d193 1
d195 5
a199 5
<code>Options</code> directive within a <code>&lt;Directory&gt;</code>,
<code>&lt;Location&gt;</code> or <code>&lt;Files&gt;</code>
section in <code>access.conf</code>, or (if <code>AllowOverride</code>
is properly set) in <code>.htaccess</code> files.  Note that
<code>Options All</code> does not set <code>MultiViews</code>; you
d201 1
a201 1
<code>http_core.h</code>).
d203 1
a203 1
<p>
d205 4
a208 4
The effect of <code>MultiViews</code> is as follows: if the server
receives a request for <code>/some/dir/foo</code>, if
<code>/some/dir</code> has <code>MultiViews</code> enabled, and
<code>/some/dir/foo</code> does <em>not</em> exist, then the server reads the
d215 1
a215 1
<p>
d218 1
a218 1
<code>DirectoryIndex</code> directive, if the server is trying to
d220 1
a220 1
<pre>
d224 3
a226 3
</pre> then the server will arbitrate between <code>index.html</code>
and <code>index.html3</code> if both are present.  If neither are
present, and <code>index.cgi</code> is there, the server will run it.
d228 1
a228 1
<p>
d238 1
a238 1
<h2>The Negotiation Algorithm</h2>
d247 1
a247 1
explains in detail the algorithm used for those interested.  <p>
d253 1
a253 1
<h3>Dimensions of Negotiation</h3>
d255 5
a259 5
<table>
<tr><th>Dimension
<th>Notes
<tr><td>Media Type
<td>Browser indicates preferences on Accept: header. Each item 
d262 2
a263 2
<tr><td>Language
<td>Browser indicates preferences on Accept-Language: header. Each
d267 4
a270 4
<tr><td>Encoding
<td>Browser indicates preference with Accept-Encoding: header.
<tr><td>Charset
<td>Browser indicates preference with Accept-Charset: header. Variants
d272 1
a272 1
</table>
d274 1
a274 1
<h3>Apache Negotiation Algorithm</h3>
d276 1
a279 1
<p>
d281 2
a282 2
<ol>
<li>
d289 1
a289 1
<li>Select the 'best' variant by a process of elimination. Each of
d295 2
a296 2
<ol>
<li>Multiply the quality factor from the Accept header with the
d300 1
a300 1
<li>Select the variants with the highest language quality factor
d302 3
a304 2
<li>Select the variants with the best language match, using either the
  order of languages on the <code>LanguagePriority</code> directive (if present),
d307 2
a308 2
<li>Select the variants with the highest 'level' media parameter
  (used to give the version of text/html media types). 
d310 6
a315 3
<li>Select only unencoded variants, if there is a mix of encoded
  and non-encoded variants. If either all variants are encoded
  or all variants are not encoded, select all.
d317 1
a317 1
<li>Select only variants with acceptable charset media parameters,
d322 1
a322 1
<li>Select the variants with the smallest content length
d324 1
a324 1
<li>Select the first variant of those remaining (this will be either the
d328 1
a328 1
</ol>
d330 1
a330 1
<li>The algorithm has now selected one 'best' variant, so return
d335 1
a335 1
<li>To get here means no variant was selected (because non are acceptable
d341 3
a343 2
</ol>
<h2><a name="better">Fiddling with Quality Values</a></h2>
d345 1
d354 1
a354 1
<p>
d356 1
a356 1
<h3>Media Types and Wildcards</h3>
d358 1
d362 1
a362 1
<pre>
d364 1
a364 1
</pre>
d370 1
a370 1
<pre>
d372 1
a372 1
</pre>
d381 1
a381 1
<pre>
d383 1
a383 1
</pre>
d388 2
a389 2
no variant matches an explicitly listed type. 
<p>
d391 1
a391 1
If the Accept: header contains <i>no</i> q factors at all, Apache sets
d396 1
a396 1
these special values are <i>not</i> applied, so requests from browsers
d399 1
a399 1
<h3>Variants with no Language</h3>
d401 1
d404 1
a404 1
are given a very low language quality factor of 0.001.<p>
d409 1
a409 1
other variants match the browser's language preferences. 
d413 5
a417 5
<ul>
<li>foo.en.html, language en
<li>foo.fr.html, language en
<li>foo.html, no language
</ul>
d419 1
d426 86
a511 1
<h2>Note on Caching</h2>
d513 4
d522 1
a522 1
hits could return the wrong response. To prevent this, 
d524 1
a524 1
as non-cacheable by HTTP/1.0 clients. Apache also supports the HTTP/1.1 
d528 1
a528 1
browser or a cache), the directive <tt>CacheNegotiatedDocs</tt> can be
d535 3
a537 3
<H3 ALIGN="CENTER">
 Apache HTTP Server Version 1.2
</H3>
@


1.1.1.1
log
@Initial import from apache 1.2.6
@
text
@@


1.1.1.2
log
@Apache 1.3.2
@
text
@d18 1
a18 1
  Apache HTTP Server Version 1.3
d22 1
a22 1
<H1 ALIGN="CENTER">Content Negotiation</H1>
a23 1
<P>
d29 1
a29 1
browsers which send incomplete negotiation information.  <P>
d31 2
a32 2
Content negotiation is provided by the
<A HREF="mod/mod_negotiation.html">mod_negotiation</A> module,
d35 1
a35 1
<HR>
d37 1
a37 1
<H2>About Content Negotiation</H2>
a38 1
<P>
d51 1
a51 1
<PRE>
d53 1
a53 1
</PRE>
a54 1
<P>
d56 2
a57 2
of representations and they vary by language.
<P>
d65 1
a65 1
<PRE>
d69 1
a69 1
</PRE>
d74 1
a74 1
<P>
d76 1
a76 1
The terms used in content negotiation are: a <STRONG>resource</STRONG> is an
d79 3
a81 3
available in several formats, these are called <STRONG>representations</STRONG>
or <STRONG>variants</STRONG>. The ways in which the variants for a particular
resource vary are called the <STRONG>dimensions</STRONG> of negotiation.
d83 1
a83 1
<H2>Negotiation in Apache</H2>
a84 1
<P>
d87 1
a87 1
ways:
d89 2
a90 2
<UL>
  <LI> Using a type map (<EM>i.e.</EM>, a <CODE>*.var</CODE> file) which
d92 1
a92 1
  <LI> Or using a 'MultiViews' search, where the server does an implicit
d94 1
a94 1
</UL>
d96 1
a96 1
<H3>Using a type-map file</H3>
a97 1
<P>
d99 1
a99 1
named <CODE>type-map</CODE> (or, for backwards-compatibility with
d101 4
a104 4
<CODE>application/x-type-map</CODE>).  Note that to use this feature,
you've got to have a <CODE>SetHandler</CODE> some place which defines a
file suffix as <CODE>type-map</CODE>; this is best done with a
<PRE>
d108 3
a110 3
</PRE>
in <CODE>srm.conf</CODE>.  See comments in the sample config files for
details. <P>
d119 1
a119 1
<PRE>
d130 1
a130 1
</PRE>
d135 1
a135 1
<PRE>
d147 2
a148 2
</PRE>
<P>
d152 1
a152 1
parameter value are given a qs factor of 1.0.  <P>
d156 3
a158 3
<DL>
  <DT> <CODE>URI:</CODE>
  <DD> uri of the file containing the variant (of the given media
d163 3
a165 3
       directly.
  <DT> <CODE>Content-type:</CODE>
  <DD> media type --- charset, level and "qs" parameters may be given.  These
d167 8
a174 8
       <CODE>image/gif</CODE>, <CODE>text/plain</CODE>, or
       <CODE>text/html;&nbsp;level=3</CODE>.
  <DT> <CODE>Content-language:</CODE>
  <DD> The languages of the variant, specified as an Internet standard
       language code (<EM>e.g.</EM>, <CODE>en</CODE> for English,
       <CODE>kr</CODE> for Korean, <EM>etc.</EM>).
  <DT> <CODE>Content-encoding:</CODE>
  <DD> If the file is compressed, or otherwise encoded, rather than
d178 3
a180 3
       <CODE>x-compress</CODE>, or <CODE>x-gzip</CODE>, as appropriate.
  <DT> <CODE>Content-length:</CODE>
  <DD> The size of the file.  Clients can ask to receive a given media
d184 1
a184 1
</DL>
d186 1
a186 1
<H3>Multiviews</H3>
a187 1
<P>
d189 5
a193 5
<CODE>Options</CODE> directive within a <CODE>&lt;Directory&gt;</CODE>,
<CODE>&lt;Location&gt;</CODE> or <CODE>&lt;Files&gt;</CODE>
section in <CODE>access.conf</CODE>, or (if <CODE>AllowOverride</CODE>
is properly set) in <CODE>.htaccess</CODE> files.  Note that
<CODE>Options All</CODE> does not set <CODE>MultiViews</CODE>; you
d195 1
a195 1
<CODE>http_core.h</CODE>).
d197 1
a197 1
<P>
d199 4
a202 4
The effect of <CODE>MultiViews</CODE> is as follows: if the server
receives a request for <CODE>/some/dir/foo</CODE>, if
<CODE>/some/dir</CODE> has <CODE>MultiViews</CODE> enabled, and
<CODE>/some/dir/foo</CODE> does <EM>not</EM> exist, then the server reads the
d209 1
a209 1
<P>
d212 1
a212 1
<CODE>DirectoryIndex</CODE> directive, if the server is trying to
d214 1
a214 1
<PRE>
d218 3
a220 3
</PRE> then the server will arbitrate between <CODE>index.html</CODE>
and <CODE>index.html3</CODE> if both are present.  If neither are
present, and <CODE>index.cgi</CODE> is there, the server will run it.
d222 1
a222 1
<P>
d232 1
a232 1
<H2>The Negotiation Algorithm</H2>
d241 1
a241 1
explains in detail the algorithm used for those interested.  <P>
d247 1
a247 1
<H3>Dimensions of Negotiation</H3>
d249 5
a253 5
<TABLE>
<TR><TH>Dimension
<TH>Notes
<TR><TD>Media Type
<TD>Browser indicates preferences on Accept: header. Each item
d256 2
a257 2
<TR><TD>Language
<TD>Browser indicates preferences on Accept-Language: header. Each
d261 4
a264 4
<TR><TD>Encoding
<TD>Browser indicates preference with Accept-Encoding: header.
<TR><TD>Charset
<TD>Browser indicates preference with Accept-Charset: header. Variants
d266 1
a266 1
</TABLE>
d268 1
a268 1
<H3>Apache Negotiation Algorithm</H3>
a269 1
<P>
d273 1
d275 2
a276 2
<OL>
<LI>
d283 1
a283 1
<LI>Select the 'best' variant by a process of elimination. Each of
d289 2
a290 2
<OL>
<LI>Multiply the quality factor from the Accept header with the
d294 1
a294 1
<LI>Select the variants with the highest language quality factor
d296 2
a297 3
<LI>Select the variants with the best language match, using either the
  order of languages on the <CODE>LanguagePriority</CODE> directive (if
  present),
d300 2
a301 2
<LI>Select the variants with the highest 'level' media parameter
  (used to give the version of text/html media types).
d303 1
a303 1
<LI>Select only unencoded variants, if there is a mix of encoded
d307 1
a307 1
<LI>Select only variants with acceptable charset media parameters,
d312 1
a312 1
<LI>Select the variants with the smallest content length
d314 1
a314 1
<LI>Select the first variant of those remaining (this will be either the
d318 1
a318 1
</OL>
d320 1
a320 1
<LI>The algorithm has now selected one 'best' variant, so return
d325 1
a325 1
<LI>To get here means no variant was selected (because non are acceptable
d331 2
a332 3
</OL>

<H2><A NAME="better">Fiddling with Quality Values</A></H2>
a333 1
<P>
d342 1
a342 1
<P>
d344 1
a344 1
<H3>Media Types and Wildcards</H3>
a345 1
<P>
d349 1
a349 1
<PRE>
d351 1
a351 1
</PRE>
d357 1
a357 1
<PRE>
d359 1
a359 1
</PRE>
d368 1
a368 1
<PRE>
d370 1
a370 1
</PRE>
d375 2
a376 2
no variant matches an explicitly listed type.
<P>
d378 1
a378 1
If the Accept: header contains <EM>no</EM> q factors at all, Apache sets
d383 1
a383 1
these special values are <EM>not</EM> applied, so requests from browsers
d386 1
a386 1
<H3>Variants with no Language</H3>
a387 1
<P>
d390 1
a390 1
are given a very low language quality factor of 0.001.<P>
d395 1
a395 1
other variants match the browser's language preferences.
d399 5
a403 5
<UL>
<LI>foo.en.html, language en
<LI>foo.fr.html, language en
<LI>foo.html, no language
</UL>
a404 1
<P>
d411 1
a411 86
<H2>Note on hyperlinks and naming conventions</H2>

<P>
If you are using language negotiation you can choose between
different naming conventions, because files can have more than one
extension, and the order of the extensions is normally irrelevant
(see <A HREF="mod/mod_mime.html">mod_mime</A> documentation for details).
<P>
A typical file has a MIME-type extension (<EM>e.g.</EM>, <SAMP>html</SAMP>),
maybe an encoding extension (<EM>e.g.</EM>, <SAMP>gz</SAMP>), and of course a
language extension (<EM>e.g.</EM>, <SAMP>en</SAMP>) when we have different
language variants of this file.

<P>
Examples:
<UL>
<LI>foo.en.html
<LI>foo.html.en
<LI>foo.en.html.gz
</UL>

<P>
Here some more examples of filenames together with valid and invalid
hyperlinks:
</P>

<TABLE BORDER=1 CELLPADDING=8 CELLSPACING=0>
<TR>
 <TH>Filename</TH>
 <TH>Valid hyperlink</TH>
 <TH>Invalid hyperlink</TH>
</TR>
<TR>
 <TD><EM>foo.html.en</EM></TD>
 <TD>foo<BR>
     foo.html</TD>
 <TD>-</TD>
</TR>
<TR>
 <TD><EM>foo.en.html</EM></TD>
 <TD>foo</TD>
 <TD>foo.html</TD>
</TR>
<TR>
 <TD><EM>foo.html.en.gz</EM></TD>
 <TD>foo<BR>
     foo.html</TD>
 <TD>foo.gz<BR>
     foo.html.gz</TD>
</TR>
<TR>
 <TD><EM>foo.en.html.gz</EM></TD>
 <TD>foo</TD>
 <TD>foo.html<BR>
     foo.html.gz<BR>
     foo.gz</TD>
</TR>
<TR>
 <TD><EM>foo.gz.html.en</EM></TD>
 <TD>foo<BR>
     foo.gz<BR>
     foo.gz.html</TD>
 <TD>foo.html</TD>
</TR>
<TR>
 <TD><EM>foo.html.gz.en</EM></TD>
 <TD>foo<BR>
     foo.html<BR>
     foo.html.gz</TD>
 <TD>foo.gz</TD>
</TR>
</TABLE>

<P>
Looking at the table above you will notice that it is always possible to
use the name without any extensions  in an hyperlink (<EM>e.g.</EM>, <SAMP>foo</SAMP>).
The advantage is that you can hide the actual type of a
document rsp. file and can change it later, <EM>e.g.</EM>, from <SAMP>html</SAMP>
to <SAMP>shtml</SAMP> or <SAMP>cgi</SAMP> without changing any
hyperlink references.

<P>
If you want to continue to use a MIME-type in your hyperlinks (<EM>e.g.</EM>
<SAMP>foo.html</SAMP>) the language extension (including an encoding extension
if there is one) must be on the right hand side of the MIME-type extension
(<EM>e.g.</EM>, <SAMP>foo.html.en</SAMP>).
a412 4

<H2>Note on Caching</H2>

<P>
d418 1
a418 1
hits could return the wrong response. To prevent this,
d420 1
a420 1
as non-cacheable by HTTP/1.0 clients. Apache also supports the HTTP/1.1
d424 1
a424 1
browser or a cache), the directive <TT>CacheNegotiatedDocs</TT> can be
d431 3
a433 3
 <H3 ALIGN="CENTER">
  Apache HTTP Server Version 1.3
 </H3>
@


1.1.1.3
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d1 51
a51 2
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
d53 1
a53 48
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator" content="HTML Tidy, see www.w3.org" />

    <title>Apache Content Negotiation</title>
  </head>
  <!-- Background white, links blue (unvisited), navy (visited), red (active) -->

  <body bgcolor="#FFFFFF" text="#000000" link="#0000FF"
  vlink="#000080" alink="#FF0000">
        <div align="CENTER">
      <img src="images/sub.gif" alt="[APACHE DOCUMENTATION]" /> 

      <h3>Apache HTTP Server</h3>
    </div>



    <h1 align="CENTER">Content Negotiation</h1>

    <p>Apache's support for content negotiation has been updated to
    meet the HTTP/1.1 specification. It can choose the best
    representation of a resource based on the browser-supplied
    preferences for media type, languages, character set and
    encoding. It is also implements a couple of features to give
    more intelligent handling of requests from browsers which send
    incomplete negotiation information.</p>

    <p>Content negotiation is provided by the <a
    href="mod/mod_negotiation.html">mod_negotiation</a> module,
    which is compiled in by default.</p>
    <hr />

    <h2>About Content Negotiation</h2>

    <p>A resource may be available in several different
    representations. For example, it might be available in
    different languages or different media types, or a combination.
    One way of selecting the most appropriate choice is to give the
    user an index page, and let them select. However it is often
    possible for the server to choose automatically. This works
    because browsers can send as part of each request information
    about what representations they prefer. For example, a browser
    could indicate that it would like to see information in French,
    if possible, else English will do. Browsers indicate their
    preferences by headers in the request. To request only French
    representations, the browser would send</p>
<pre>
d55 1
a55 1
</pre>
d57 10
a66 2
    <p>Note that this preference will only be applied when there is
    a choice of representations and they vary by language.</p>
d68 1
a68 7
    <p>As an example of a more complex request, this browser has
    been configured to accept French and English, but prefer
    French, and to accept various media types, preferring HTML over
    plain text or other text types, and preferring GIF or JPEG over
    other media types, but also allowing any other media type as a
    last resort:</p>
<pre>
d72 54
a125 61
</pre>
    Apache 1.2 supports 'server driven' content negotiation, as
    defined in the HTTP/1.1 specification. It fully supports the
    Accept, Accept-Language, Accept-Charset and Accept-Encoding
    request headers. Apache 1.3.4 also supports 'transparent'
    content negotiation, which is an experimental negotiation
    protocol defined in RFC 2295 and RFC 2296. It does not offer
    support for 'feature negotiation' as defined in these RFCs. 

    <p>A <strong>resource</strong> is a conceptual entity
    identified by a URI (RFC 2396). An HTTP server like Apache
    provides access to <strong>representations</strong> of the
    resource(s) within its namespace, with each representation in
    the form of a sequence of bytes with a defined media type,
    character set, encoding, etc. Each resource may be associated
    with zero, one, or more than one representation at any given
    time. If multiple representations are available, the resource
    is referred to as <strong>negotiable</strong> and each of its
    representations is termed a <strong>variant</strong>. The ways
    in which the variants for a negotiable resource vary are called
    the <strong>dimensions</strong> of negotiation.</p>

    <h2>Negotiation in Apache</h2>

    <p>In order to negotiate a resource, the server needs to be
    given information about each of the variants. This is done in
    one of two ways:</p>

    <ul>
      <li>Using a type map (<em>i.e.</em>, a <code>*.var</code>
      file) which names the files containing the variants
      explicitly, or</li>

      <li>Using a 'MultiViews' search, where the server does an
      implicit filename pattern match and chooses from among the
      results.</li>
    </ul>

    <h3>Using a type-map file</h3>

    <p>A type map is a document which is associated with the
    handler named <code>type-map</code> (or, for
    backwards-compatibility with older Apache configurations, the
    mime type <code>application/x-type-map</code>). Note that to
    use this feature, you must have a handler set in the
    configuration that defines a file suffix as
    <code>type-map</code>; this is best done with a</p>
<pre>
  AddHandler type-map .var
</pre>
    in the server configuration file. See the comments in the
    sample config file for more details. 

    <p>Type map files have an entry for each available variant;
    these entries consist of contiguous HTTP-format header lines.
    Entries for different variants are separated by blank lines.
    Blank lines are illegal within an entry. It is conventional to
    begin a map file with an entry for the combined entity as a
    whole (although this is not required, and if present will be
    ignored). An example map file is:</p>
<pre>
d133 1
a133 1
  Content-type: text/html;charset=iso-8859-2
d135 6
a140 5
</pre>
    If the variants have different source qualities, that may be
    indicated by the "qs" parameter to the media type, as in this
    picture (available as jpeg, gif, or ASCII-art): 
<pre>
a150 1
</pre>
d152 70
a221 93
    <p>qs values can vary in the range 0.000 to 1.000. Note that
    any variant with a qs value of 0.000 will never be chosen.
    Variants with no 'qs' parameter value are given a qs factor of
    1.0. The qs parameter indicates the relative 'quality' of this
    variant compared to the other available variants, independent
    of the client's capabilities. For example, a jpeg file is
    usually of higher source quality than an ascii file if it is
    attempting to represent a photograph. However, if the resource
    being represented is an original ascii art, then an ascii
    representation would have a higher source quality than a jpeg
    representation. A qs value is therefore specific to a given
    variant depending on the nature of the resource it
    represents.</p>

    <p>The full list of headers recognized is:</p>

    <dl>
      <dt><code>URI:</code></dt>

      <dd>uri of the file containing the variant (of the given
      media type, encoded with the given content encoding). These
      are interpreted as URLs relative to the map file; they must
      be on the same server (!), and they must refer to files to
      which the client would be granted access if they were to be
      requested directly.</dd>

      <dt><code>Content-Type:</code></dt>

      <dd>media type --- charset, level and "qs" parameters may be
      given. These are often referred to as MIME types; typical
      media types are <code>image/gif</code>,
      <code>text/plain</code>, or
      <code>text/html;&nbsp;level=3</code>.</dd>

      <dt><code>Content-Language:</code></dt>

      <dd>The languages of the variant, specified as an Internet
      standard language tag from RFC 1766 (<em>e.g.</em>,
      <code>en</code> for English, <code>kr</code> for Korean,
      <em>etc.</em>).</dd>

      <dt><code>Content-Encoding:</code></dt>

      <dd>If the file is compressed, or otherwise encoded, rather
      than containing the actual raw data, this says how that was
      done. Apache only recognizes encodings that are defined by an
      <a href="mod/mod_mime.html#addencoding">AddEncoding</a>
      directive. This normally includes the encodings
      <code>x-compress</code> for compress'd files, and
      <code>x-gzip</code> for gzip'd files. The <code>x-</code>
      prefix is ignored for encoding comparisons.</dd>

      <dt><code>Content-Length:</code></dt>

      <dd>The size of the file. Specifying content lengths in the
      type-map allows the server to compare file sizes without
      checking the actual files.</dd>

      <dt><code>Description:</code></dt>

      <dd>A human-readable textual description of the variant. If
      Apache cannot find any appropriate variant to return, it will
      return an error response which lists all available variants
      instead. Such a variant list will include the human-readable
      variant descriptions.</dd>
    </dl>

    <h3>Multiviews</h3>

    <p><code>MultiViews</code> is a per-directory option, meaning
    it can be set with an <code>Options</code> directive within a
    <code>&lt;Directory&gt;</code>, <code>&lt;Location&gt;</code>
    or <code>&lt;Files&gt;</code> section in
    <code>access.conf</code>, or (if <code>AllowOverride</code> is
    properly set) in <code>.htaccess</code> files. Note that
    <code>Options All</code> does not set <code>MultiViews</code>;
    you have to ask for it by name.</p>

    <p>The effect of <code>MultiViews</code> is as follows: if the
    server receives a request for <code>/some/dir/foo</code>, if
    <code>/some/dir</code> has <code>MultiViews</code> enabled, and
    <code>/some/dir/foo</code> does <em>not</em> exist, then the
    server reads the directory looking for files named foo.*, and
    effectively fakes up a type map which names all those files,
    assigning them the same media types and content-encodings it
    would have if the client had asked for one of them by name. It
    then chooses the best match to the client's requirements.</p>

    <p><code>MultiViews</code> may also apply to searches for the
    file named by the <code>DirectoryIndex</code> directive, if the
    server is trying to index a directory. If the configuration
    files specify</p>
<pre>
d223 137
a359 208
</pre>
    then the server will arbitrate between <code>index.html</code>
    and <code>index.html3</code> if both are present. If neither
    are present, and <code>index.cgi</code> is there, the server
    will run it. 

    <p>If one of the files found when reading the directive is a
    CGI script, it's not obvious what should happen. The code gives
    that case special treatment --- if the request was a POST, or a
    GET with QUERY_ARGS or PATH_INFO, the script is given an
    extremely high quality rating, and generally invoked; otherwise
    it is given an extremely low quality rating, which generally
    causes one of the other views (if any) to be retrieved.</p>

    <h2>The Negotiation Methods</h2>
    After Apache has obtained a list of the variants for a given
    resource, either from a type-map file or from the filenames in
    the directory, it invokes one of two methods to decide on the
    'best' variant to return, if any. It is not necessary to know
    any of the details of how negotiation actually takes place in
    order to use Apache's content negotiation features. However the
    rest of this document explains the methods used for those
    interested. 

    <p>There are two negotiation methods:</p>

    <ol>
      <li><strong>Server driven negotiation with the Apache
      algorithm</strong> is used in the normal case. The Apache
      algorithm is explained in more detail below. When this
      algorithm is used, Apache can sometimes 'fiddle' the quality
      factor of a particular dimension to achieve a better result.
      The ways Apache can fiddle quality factors is explained in
      more detail below.</li>

      <li><strong>Transparent content negotiation</strong> is used
      when the browser specifically requests this through the
      mechanism defined in RFC 2295. This negotiation method gives
      the browser full control over deciding on the 'best' variant,
      the result is therefore dependent on the specific algorithms
      used by the browser. As part of the transparent negotiation
      process, the browser can ask Apache to run the 'remote
      variant selection algorithm' defined in RFC 2296.</li>
    </ol>

    <h3>Dimensions of Negotiation</h3>

    <table>
      <tr valign="top">
        <th>Dimension</th>

        <th>Notes</th>
      </tr>

      <tr valign="top">
        <td>Media Type</td>

        <td>Browser indicates preferences with the Accept header
        field. Each item can have an associated quality factor.
        Variant description can also have a quality factor (the
        "qs" parameter).</td>
      </tr>

      <tr valign="top">
        <td>Language</td>

        <td>Browser indicates preferences with the Accept-Language
        header field. Each item can have a quality factor. Variants
        can be associated with none, one or more than one
        language.</td>
      </tr>

      <tr valign="top">
        <td>Encoding</td>

        <td>Browser indicates preference with the Accept-Encoding
        header field. Each item can have a quality factor.</td>
      </tr>

      <tr valign="top">
        <td>Charset</td>

        <td>Browser indicates preference with the Accept-Charset
        header field. Each item can have a quality factor. Variants
        can indicate a charset as a parameter of the media
        type.</td>
      </tr>
    </table>

    <h3>Apache Negotiation Algorithm</h3>

    <p>Apache can use the following algorithm to select the 'best'
    variant (if any) to return to the browser. This algorithm is
    not further configurable. It operates as follows:</p>

    <ol>
      <li>First, for each dimension of the negotiation, check the
      appropriate <em>Accept*</em> header field and assign a
      quality to each variant. If the <em>Accept*</em> header for
      any dimension implies that this variant is not acceptable,
      eliminate it. If no variants remain, go to step 4.</li>

      <li>
        Select the 'best' variant by a process of elimination. Each
        of the following tests is applied in order. Any variants
        not selected at each test are eliminated. After each test,
        if only one variant remains, select it as the best match
        and proceed to step 3. If more than one variant remains,
        move on to the next test. 

        <ol>
          <li>Multiply the quality factor from the Accept header
          with the quality-of-source factor for this variant's
          media type, and select the variants with the highest
          value.</li>

          <li>Select the variants with the highest language quality
          factor.</li>

          <li>Select the variants with the best language match,
          using either the order of languages in the
          Accept-Language header (if present), or else the order of
          languages in the <code>LanguagePriority</code> directive
          (if present).</li>

          <li>Select the variants with the highest 'level' media
          parameter (used to give the version of text/html media
          types).</li>

          <li>Select variants with the best charset media
          parameters, as given on the Accept-Charset header line.
          Charset ISO-8859-1 is acceptable unless explicitly
          excluded. Variants with a <code>text/*</code> media type
          but not explicitly associated with a particular charset
          are assumed to be in ISO-8859-1.</li>

          <li>Select those variants which have associated charset
          media parameters that are <em>not</em> ISO-8859-1. If
          there are no such variants, select all variants
          instead.</li>

          <li>Select the variants with the best encoding. If there
          are variants with an encoding that is acceptable to the
          user-agent, select only these variants. Otherwise if
          there is a mix of encoded and non-encoded variants,
          select only the unencoded variants. If either all
          variants are encoded or all variants are not encoded,
          select all variants.</li>

          <li>Select the variants with the smallest content
          length.</li>

          <li>Select the first variant of those remaining. This
          will be either the first listed in the type-map file, or
          when variants are read from the directory, the one whose
          file name comes first when sorted using ASCII code
          order.</li>
        </ol>
      </li>

      <li>The algorithm has now selected one 'best' variant, so
      return it as the response. The HTTP response header Vary is
      set to indicate the dimensions of negotiation (browsers and
      caches can use this information when caching the resource).
      End.</li>

      <li><p>To get here means no variant was selected (because none
      are acceptable to the browser). Return a 406 status (meaning
      "No acceptable representation") with a response body
      consisting of an HTML document listing the available
      variants. Also set the HTTP Vary header to indicate the
      dimensions of variance.</p>

      <p>You should be aware that the error message returned by Apache is
   neccessarily rather terse and might confuse some users (even though it
   lists the available alternatives). If you want to avoid users seeing this
   error page, you should organize your documents such that a document in a
   default language (or with a default encoding etc.) is always returned if a
   document is not available in any of the languages, encodings etc. the
   browser asked for.</p>

   <p>In particular, if you want a document in a default language to
   be returned if a document is not available in any of the languages
   a browser asked for, you should create a document with no language
   attribute set.  See <a href="#nolanguage">Variants with no
   Language</a> below for details.</p></li>
    </ol>

    <h2><a id="better" name="better">Fiddling with Quality
    Values</a></h2>

    <p>Apache sometimes changes the quality values from what would
    be expected by a strict interpretation of the Apache
    negotiation algorithm above. This is to get a better result
    from the algorithm for browsers which do not send full or
    accurate information. Some of the most popular browsers send
    Accept header information which would otherwise result in the
    selection of the wrong variant in many cases. If a browser
    sends full and correct information these fiddles will not be
    applied.</p>

    <h3>Media Types and Wildcards</h3>

    <p>The Accept: request header indicates preferences for media
    types. It can also include 'wildcard' media types, such as
    "image/*" or "*/*" where the * matches any string. So a request
    including:</p>
<pre>
d361 7
a367 6
</pre>
    would indicate that any type starting "image/" is acceptable,
    as is any other type (so the first "image/*" is redundant).
    Some browsers routinely send wildcards in addition to explicit
    types they can handle. For example: 
<pre>
d369 10
a378 9
</pre>
    The intention of this is to indicate that the explicitly listed
    types are preferred, but if a different representation is
    available, that is ok too. However under the basic algorithm,
    as given above, the */* wildcard has exactly equal preference
    to all the other types, so they are not being preferred. The
    browser should really have sent a request with a lower quality
    (preference) value for *.*, such as: 
<pre>
d380 157
a536 199
</pre>
    The explicit types have no quality factor, so they default to a
    preference of 1.0 (the highest). The wildcard */* is given a
    low preference of 0.01, so other types will only be returned if
    no variant matches an explicitly listed type. 

    <p>If the Accept: header contains <em>no</em> q factors at all,
    Apache sets the q value of "*/*", if present, to 0.01 to
    emulate the desired behavior. It also sets the q value of
    wildcards of the format "type/*" to 0.02 (so these are
    preferred over matches against "*/*". If any media type on the
    Accept: header contains a q factor, these special values are
    <em>not</em> applied, so requests from browsers which send the
    correct information to start with work as expected.</p>

    <h3><a name="nolanguage">Variants with no Language</a></h3>

    <p>If some of the variants for a particular resource have a
    language attribute, and some do not, those variants with no
    language are given a very low language quality factor of
    0.001.</p>

    <p>The reason for setting this language quality factor for variant
    with no language to a very low value is to allow for a default
    variant which can be supplied if none of the other variants match
    the browser's language preferences. This allows you to avoid users
    seeing a "406" error page if their browser is set to only accept
    languages which you do not offer for the ressource that was
    requested.</p>

    <p>For example, consider the situation with Multiviews enabled and
    three variants:</p>

    <ul>
      <li>foo.en.html, language en</li>

      <li>foo.fr.html, language en</li>

      <li>foo.html, no language</li>
    </ul>

    <p>The meaning of a variant with no language is that it is always
    acceptable to the browser. If the request is for <code>foo</code>
    and the Accept-Language header includes either en or fr (or both)
    one of foo.en.html or foo.fr.html will be returned. If the browser
    does not list either en or fr as acceptable, foo.html will be
    returned instead.  If the client requests <code>foo.html</code>
    instead, then no negotation will occur since the exact match
    will be returned.  To avoid this problem, it is sometimes helpful
    to name the "no language" variant <code>foo.html.html</code> to assure
    that Multiviews and language negotiation will come into play.</p>

    <h2>Extensions to Transparent Content Negotiation</h2>
    Apache extends the transparent content negotiation protocol
    (RFC 2295) as follows. A new <code>{encoding ..}</code> element
    is used in variant lists to label variants which are available
    with a specific content-encoding only. The implementation of
    the RVSA/1.0 algorithm (RFC 2296) is extended to recognize
    encoded variants in the list, and to use them as candidate
    variants whenever their encodings are acceptable according to
    the Accept-Encoding request header. The RVSA/1.0 implementation
    does not round computed quality factors to 5 decimal places
    before choosing the best variant. 

    <h2>Note on hyperlinks and naming conventions</h2>

    <p>If you are using language negotiation you can choose between
    different naming conventions, because files can have more than
    one extension, and the order of the extensions is normally
    irrelevant (see <a href="mod/mod_mime.html">mod_mime</a>
    documentation for details).</p>

    <p>A typical file has a MIME-type extension (<em>e.g.</em>,
    <samp>html</samp>), maybe an encoding extension (<em>e.g.</em>,
    <samp>gz</samp>), and of course a language extension
    (<em>e.g.</em>, <samp>en</samp>) when we have different
    language variants of this file.</p>

    <p>Examples:</p>

    <ul>
      <li>foo.en.html</li>

      <li>foo.html.en</li>

      <li>foo.en.html.gz</li>
    </ul>

    <p>Here some more examples of filenames together with valid and
    invalid hyperlinks:</p>

    <table border="1" cellpadding="8" cellspacing="0">
      <tr>
        <th>Filename</th>

        <th>Valid hyperlink</th>

        <th>Invalid hyperlink</th>
      </tr>

      <tr>
        <td><em>foo.html.en</em></td>

        <td>foo<br />
         foo.html</td>

        <td>-</td>
      </tr>

      <tr>
        <td><em>foo.en.html</em></td>

        <td>foo</td>

        <td>foo.html</td>
      </tr>

      <tr>
        <td><em>foo.html.en.gz</em></td>

        <td>foo<br />
         foo.html</td>

        <td>foo.gz<br />
         foo.html.gz</td>
      </tr>

      <tr>
        <td><em>foo.en.html.gz</em></td>

        <td>foo</td>

        <td>foo.html<br />
         foo.html.gz<br />
         foo.gz</td>
      </tr>

      <tr>
        <td><em>foo.gz.html.en</em></td>

        <td>foo<br />
         foo.gz<br />
         foo.gz.html</td>

        <td>foo.html</td>
      </tr>

      <tr>
        <td><em>foo.html.gz.en</em></td>

        <td>foo<br />
         foo.html<br />
         foo.html.gz</td>

        <td>foo.gz</td>
      </tr>
    </table>

    <p>Looking at the table above you will notice that it is always
    possible to use the name without any extensions in an hyperlink
    (<em>e.g.</em>, <samp>foo</samp>). The advantage is that you
    can hide the actual type of a document rsp. file and can change
    it later, <em>e.g.</em>, from <samp>html</samp> to
    <samp>shtml</samp> or <samp>cgi</samp> without changing any
    hyperlink references.</p>

    <p>If you want to continue to use a MIME-type in your
    hyperlinks (<em>e.g.</em> <samp>foo.html</samp>) the language
    extension (including an encoding extension if there is one)
    must be on the right hand side of the MIME-type extension
    (<em>e.g.</em>, <samp>foo.html.en</samp>).</p>

    <h2>Note on Caching</h2>

    <p>When a cache stores a representation, it associates it with
    the request URL. The next time that URL is requested, the cache
    can use the stored representation. But, if the resource is
    negotiable at the server, this might result in only the first
    requested variant being cached and subsequent cache hits might
    return the wrong response. To prevent this, Apache normally
    marks all responses that are returned after content negotiation
    as non-cacheable by HTTP/1.0 clients. Apache also supports the
    HTTP/1.1 protocol features to allow caching of negotiated
    responses.</p>

    <p>For requests which come from a HTTP/1.0 compliant client
    (either a browser or a cache), the directive
    <tt>CacheNegotiatedDocs</tt> can be used to allow caching of
    responses which were subject to negotiation. This directive can
    be given in the server config or virtual host, and takes no
    arguments. It has no effect on requests from HTTP/1.1 clients. 
        <hr />

    <h3 align="CENTER">Apache HTTP Server</h3>
    <a href="./"><img src="images/index.gif" alt="Index" /></a>

    </p>
  </body>
</html>
d538 2
@


