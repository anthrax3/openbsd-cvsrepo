head	1.7;
access;
symbols
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.3
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.3
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.2
	apache_1_3_27:1.1.1.2
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	apache_1_3_26:1.1.1.2
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.6
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.4
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	apache_1_3_2:1.1.1.1
	apache:1.1.1;
locks; strict;
comment	@# @;


1.7
date	2005.07.27.20.54.44;	author jmc;	state dead;
branches;
next	1.6;

1.6
date	2003.08.21.13.11.31;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.12.07.56.46;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.29.10.21.26;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.22.17.20;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	98.10.11.19.45.04;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.01.17.19.55;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.01.17.19.55;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.07.19.21.27.21;	author henning;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.21.12.53.29;	author henning;	state Exp;
branches;
next	;


desc
@@


1.7
log
@from tamas tevesz:

==> remove of a number of alien platforms
==> remove broken links in sitemap.html
==> remove unreferenced install_1_1.html
@
text
@<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator" content="HTML Tidy, see www.w3.org" />

    <title>The Apache EBCDIC Port</title>
  </head>
  <!-- background white, links blue (unvisited), navy (visited), red (active) -->

  <body bgcolor="#ffffff" text="#000000" link="#0000ff"
  vlink="#000080" alink="#ff0000">
        <div align="CENTER">
      <img src="images/sub.gif" alt="[APACHE DOCUMENTATION]" /> 

      <h3>Apache HTTP Server</h3>
    </div>



    <h1 align="center">Overview of the Apache EBCDIC Port</h1>

    <p>As of Version 1.3, the Apache HTTP Server includes a port to
    (non-ASCII) mainframe machines which use the EBCDIC character
    set as their native codeset.<br />
     (Initially, that support covered only the Fujitsu-Siemens
    family of mainframes running the <a
    href="http://www.fujitsu-siemens.com/rl/products/software/bs2000bc.html">
    BS2000/OSD operating system</a>, a mainframe OS which features
    a SVR4-derived POSIX subsystem. Later, the two IBM mainframe
    operating systems TPF and OS/390 were added).</p>
    <hr />

    <h2 align="center"><a id="ebcdic" name="ebcdic">EBCDIC-related
    conversion functions</a></h2>
    The EBCDIC related directives <a
    href="mod/core.html#ebcdicconvert">EBCDICConvert</a>, <a
    href="mod/core.html#ebcdicconvertbytype">EBCDICConvertByType</a>,
    and <a href="mod/core.html#ebcdickludge">EBCDICKludge</a> are
    available <b>only if the platform's character set is EBCDIC</b>
    (This is currently only the case on Fujitsu-Siemens' BS2000/OSD
    and IBM's OS/390 and TPF operating systems). EBCDIC stands for
    <em>Extended Binary-Coded-Decimal Interchange Code</em> and is
    the codeset used on mainframe machines, in contrast to ASCII
    which is ubiquitous on almost all micro computers today. ASCII
    (or its extension <em>latin1</em>) is the basis for the HTTP
    transfer protocol, therefore all EBCDIC-based platforms need a
    way to configure the code set conversion rules required between
    the EBCDIC based mainframe host and the HTTP socket
    protocol.<br />
     

    <p>On an EBCDIC based system, HTML files and other text files
    are usually saved encoded in the native EBCDIC code set, while
    image files and other binary data are stored with identical
    encoding as on ASCII based machines. When the Apache server
    accesses documents, it must therefore make a distinction
    between text files (to be converted to/from ASCII, depending on
    the transfer direction) and binary files (to be delivered
    unconverted). Such a distinction can be made based on the
    assigned MIME type, or based on the file extension
    (<em>i.e.</em>, files sharing a common file suffix).</p>

    <p>By default, the configuration is symmetric for input and
    output (<em>i.e.</em>, when a PUT request is executed for a
    document which was returned by a previous GET request, then the
    resulting uploaded copy should be identical to the original
    file). However, the conversion directives allow for specifying
    different conversions for input and output.</p>

    <p>The directives <a
    href="mod/core.html#ebcdicconvert">EBCDICConvert</a> and <a
    href="mod/core.html#ebcdicconvertbytype">EBCDICConvertByType</a>
    are used to assign the conversion setting (On or Off) based on
    file extensions or MIME types. Each configuration setting can
    be defined for input only (<em>e.g.</em>, PUT method), output
    only (<em>e.g.</em>, GET method), or both input and output. By
    default, the conversion setting is applied for input and
    output.</p>

    <p>Note that after modifying the conversion settings for a
    group of files, it is not sufficient to restart the server. The
    reason for this is the fact that a cached copy of a document
    (in a browser or proxy cache) will not get revalidated by
    contents, but only by date. Since the modification time of the
    document did not change, browsers will assume they can reuse
    the cached copy.<br />
     To recover from this situation, you must either clear all
    cached copies (browser and proxy cache!), or update the
    modification time of the documents (using the
    <code>touch</code> command on the server).</p>

    <p>Note also that server-parsed documents (CGI scripts, .shtml
    files, and other interpreted files like PHP scripts etc.) are
    not subject to any input conversion and must therefore be
    stored in EBCDIC form on the server side.</p>

    <p>In absense of any <a
    href="mod/core.html#ebcdicconvertbytype">EBCDICConvertByType</a>
    directive, and if no matching <a
    href="mod/core.html#ebcdicconvert">EBCDICConvert</a> was found,
    Apache falls back to an internal heuristic which assumes that
    all documents with MIME types starting with
    <samp>"text/"</samp>, <samp>"message/"</samp> or
    <samp>"multipart/"</samp> as well as the MIME type
    <samp>"application/x-www-form-urlencoded"</samp> are text
    documents stored in EBCDIC, whereas all other documents are
    binary files.</p>

    <p>In order to provide backward compatibility with older
    versions of apache, the <a
    href="mod/core.html#ebcdickludge">EBCDICKludge</a> directive
    allows for a less powerful mechanism to control the conversion
    of documents to and from EBCDIC.</p>

    <p><strong>Note</strong>:</p>

    <blockquote>
      The EBCDICKludge directive is deprecated, since its
      functionality is superseded by the more powerful <a
      href="mod/core.html#ebcdicconvert">EBCDICConvert</a> and <a
      href="mod/core.html#ebcdicconvertbytype">EBCDICConvertByType</a>
      directives.
    </blockquote>
    <br />
     <br />
     

    <p>The directives are applied in the following order:</p>

    <ol>
      <li>First, the configured <a
      href="mod/core.html#ebcdicconvert">EBCDICConvert</a>
      directives in the current context are evaluated in
      configuration file order. As soon as a matching file
      extension is found, the search stops and the configured
      conversion is applied.<br />
       EBCDICConvert settings inherited from parent directories are
      tested after the more specific (deeper) directory
      levels.</li>

      <li>If the <a
      href="mod/core.html#ebcdickludge">EBCDICKludge</a> is in
      effect, the next step tests for a MIME type of the format
      <samp><i>type/</i><b>x-ascii-</b><i>subtype</i></samp>. If
      the document has such a type, then the
      <samp>"<b>x-ascii-</b>"</samp> substring is removed and the
      conversion set to <samp>Off</samp>.</li>

      <li>In the next step, the configured <a
      href="mod/core.html#ebcdicconvertbytype">EBCDICConvertByType</a>
      directives are evaluated in configuration file order. If the
      document has a matching MIME type, the search stops and the
      configured conversion is applied.<br />
       EBCDICConvertByType settings inherited from parent
      directories are tested after the more specific (deeper)
      directory levels.<br />
       If no <a
      href="mod/core.html#ebcdicconvertbytype">EBCDICConvertByType</a>
      directive at all exists in the current context, the server
      falls back to the simple heuristics which assume that MIME
      types starting with "text/", "message/" or "multipart/" (plus
      the special type "application/x-www-form-urlencoded" used in
      simple POST requests) imply a conversion, while all the rest
      is delivered unconverted (<em>i.e.</em>, binary).</li>
    </ol>
    <br />
     <br />
     
    <hr />

    <h2 align="center"><a id="tech" name="tech">Technical
    Details</a></h2>

    <p>Since all Apache input and output is based upon the BUFF
    data type and its methods, the easiest solution was to add the
    actual conversion to the BUFF handling routines. The conversion
    must be settable at any time, so BUFF flags were added which
    define whether a BUFF object has currently enabled conversion
    or not. Two such flags exist: one for data read from the client
    (ASCII to EBCDIC conversion) and one for data returned to the
    client (EBCDIC to ASCII conversion).</p>

    <p>During sending of the header, Apache determines (based on
    the returned MIME type for the request) whether conversion
    should be used or the document returned unconverted. It uses
    this decision to initialize the BUFF flag when the response
    output begins. Modules should therefore determine the MIME type
    for the current request before initiating the response by
    calling ap_send_http_headers().</p>

    <p>The BUFF flag is modified at several points in the HTTP
    protocol:</p>

    <ul>
      <li><strong>set</strong> (In and Out) before a request is
      received (because the request and the request header lines
      are always in ASCII format)</li>

      <li><strong>set/unset</strong> (for Input data) when the
      request body is received - depending on the content type of
      the request body (because the request body may contain ASCII
      text or a binary file)</li>

      <li><strong>set</strong> (for returned Output) before a
      response header is sent (because the response header lines
      are always in ASCII format)</li>

      <li><strong>set/unset</strong> (for returned Output) when the
      response body is sent - depending on the content type of the
      response body (because the response body may contain text or
      a binary file)</li>
    </ul>
    Additional transparent transitions may occur for
    extracting/inserting the HTTP/1.1 chunking information
    from/into the input/output body data stream, and for generating
    <em>multipart</em> headers for <em>range</em> requests. (See
    RFC2616 and src/main/http_protocol.c for details.) 
    <hr />

    <h2 align="center"><a id="port" name="port">Porting
    Notes</a></h2>

    <ol>
      <li>
        The relevant changes in the source are #ifdef'ed into two
        categories: 

        <dl>
          <dt><code><strong>#ifdef
          CHARSET_EBCDIC</strong></code></dt>

          <dd>Code which is needed for any EBCDIC based machine.
          This includes character translations, differences in
          contiguity of the two character sets, flags which
          indicate which part of the HTTP protocol has to be
          converted and which part doesn't <em>etc.</em></dd>

          <dt><code><strong>#ifdef _OSD_POSIX | TPF |
          OS390</strong></code></dt>

          <dd>Code which is needed for the Fujitsu-Siemens
          BS2000/OSD | IBM TPF | IBM OS390 mainframe platforms
          only. This deals with include file differences and socket
          and fork implementation topics which are only required on
          the respective platform.<br />
          </dd>
        </dl>
      </li>

      <li>The possibility to translate between ASCII and EBCDIC at
      the socket level (on BS2000 POSIX, there is a socket option
      which supports this) was intentionally <em>not</em> chosen,
      because the byte stream at the HTTP protocol level consists
      of a mixture of protocol related strings and non-protocol
      related raw file data. HTTP protocol strings are always
      encoded in ASCII (the GET request, any Header: lines, the
      chunking information <em>etc.</em>) whereas the file transfer
      parts (<em>i.e.</em>, GIF images, CGI output <em>etc.</em>)
      should usually be just "passed through" by the server. This
      separation between "protocol string" and "raw data" is
      reflected in the server code by functions like bgets() or
      rvputs() for strings, and functions like bwrite() for binary
      data. A global translation of everything would therefore be
      inadequate.<br />
       (In the case of text files of course, provisions must be
      made so that EBCDIC documents are always served in
      ASCII)<br />
       This port therefore features a built-in protocol level
      conversion for the server-internal strings (which the
      compiler translated to EBCDIC strings) and thus for all
      server-generated documents.<br />
      </li>

      <li>By examining the call hierarchy for the BUFF management
      routines, I added an "ebcdic/ascii conversion layer" which
      would be crossed on every puts/write/get/gets, and conversion
      flags which allowed enabling/disabling the conversions
      on-the-fly. Usually, a document crosses this layer twice from
      its origin source (a file or CGI output) to its destination
      (the requesting client): <samp>file -&gt; Apache</samp>, and
      <samp>Apache -&gt; client</samp>.<br />
       The server can now read the header lines of a CGI-script
      output in EBCDIC format, and then find out that the remainder
      of the script's output is in ASCII (like in the case of the
      output of a WWW Counter program: the document body contains a
      GIF image). All header processing is done in the native
      EBCDIC format; the server then determines, based on the type
      of document being served, whether the document body (except
      for the chunking information, of course) is in ASCII already
      or must be converted from EBCDIC.<br />
      </li>

      <li>
        By default, Apache assumes that documents with the MIME
        types "text/*", "message/*", "multipart/*" and
        "application/x-www-form-urlencoded" are text documents and
        are stored as EBCDIC files, whereas all other files are
        binary files (and stored in a byte-identical encoding as on
        an ASCII machine).<br />
         These defaults can be overridden on a <a
        href="mod/core.html#ebcdicconvertbytype">by-MIME-type</a>
        and/or <a
        href="mod/core.html#ebcdicconvert">by-file-extension</a>
        basis, using the directives 
<pre>
     <a
href="mod/core.html#ebcdicconvertbytype">EBCDICConvertByType</a> {On|Off}[={In|Out|InOut}] <em>mimetype</em> [...]
     <a
href="mod/core.html#ebcdicconvert">EBCDICConvert</a>       {On|Off}[={In|Out|InOut}] <em>fileext</em> [...]
   
</pre>
        where the <em>mimetype</em> argument may contain
        wildcards.<br />
      </li>

      <li>Before adding the flexible conversion, non-text documents
      were always served "binary" without conversion. This seemed
      to be the most sensible choice for, .<em>e.g.</em>,
      GIF/ZIP/AU file types (It of course requires the user to copy
      them to the mainframe host using the "rcp -b" binary switch),
      but proved to be inadequate for MIME types like
      <samp>model/vrml</samp>, <samp>application/postscript</samp>
      and <samp>application/x-javascript</samp>.<br />
      </li>

      <li>Server parsed files are always assumed to be in native
      (<em>i.e.</em>, EBCDIC) format as used on the machine
      (because they do not cross the conversion layer when being
      read), and are converted after processing.<br />
      </li>

      <li>For CGI output, the CGI script determines whether a
      conversion is needed or not: by setting the appropriate
      Content-Type, text files can be converted, or GIF output can
      be passed through unmodified (depending on the conversion
      configured in the script's context).<br />
      </li>
    </ol>
    <hr />

    <h2 align="center"><a id="store" name="store">Document Storage
    Notes</a></h2>

    <h3 align="center">Binary Files</h3>

    <p>When exchanging binary files between the mainframe host and
    a Unix machine or Windows PC, be sure to use the ftp "binary"
    (<samp>TYPE I</samp>) command, or use the
    <samp>rcp&nbsp;-b</samp> command from the mainframe host (the
    -b switch is not supported in unix rcp's).</p>

    <h3 align="center">Text Documents</h3>

    <p>The default assumption of the server is that Text Files
    (<em>i.e.</em>, all files whose <samp>Content-Type:</samp>
    starts with <samp>text/</samp>) are stored in the native
    character set of the host, EBCDIC.</p>

    <h3 align="center">Server Side Included Documents</h3>

    <p>SSI documents must currently be stored in EBCDIC only. No
    provision is made to convert them from ASCII before processing.
    The same holds for other interpreted languages, like mod_perl
    or mod_php.</p>
        <hr />

    <h3 align="CENTER">Apache HTTP Server</h3>
    <a href="./"><img src="images/index.gif" alt="Index" /></a>

  </body>
</html>

@


1.6
log
@merge
@
text
@@


1.5
log
@Apache 1.3.23+mod_ssl-2.8.6-1.3.23 merge
@
text
@d29 1
a29 1
    href="http://www.fujitsu-siemens.com/servers/bs2osd/osdbc_us.htm">
@


1.4
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d1 2
a2 513
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>The Apache EBCDIC Port</TITLE>
</HEAD>

<!-- Background white, links blue (unvisited), navy (visited), red (active) -->
<BODY
 BGCOLOR="#FFFFFF"
 TEXT="#000000"
 LINK="#0000FF"
 VLINK="#000080"
 ALINK="#FF0000"
>
<DIV ALIGN="CENTER">
 <IMG SRC="images/sub.gif" ALT="[APACHE DOCUMENTATION]">
 <H3>
  Apache HTTP Server
 </H3>
</DIV>

<H1 ALIGN="CENTER">Overview of the Apache EBCDIC Port</H1>

 <P>
  Version 1.3 of the Apache HTTP Server is the first version which
  includes a port to a (non-ASCII) mainframe machine which uses
  the EBCDIC character set as its native codeset.<BR>
  (It is the SIEMENS family of mainframes running the
  <A HREF="http://www.siemens.de/servers/bs2osd/osdbc_us.htm">BS2000/OSD
  operating system</A>. This mainframe OS nowadays features a
  SVR4-derived POSIX subsystem).
 </P>

 <P>
 The port was started initially to
 </P>

  <UL>
  <LI> prove the feasibility of porting
       <A HREF="http://dev.apache.org/">the Apache HTTP server</A>
       to this platform
  <LI> find a "worthy and capable" successor for the venerable
       <A HREF="http://www.w3.org/Daemon/">CERN-3.0</A> daemon
       (which was ported a couple of years ago), and to
  <LI> prove that Apache's preforking process model can on this platform
       easily outperform the accept-fork-serve model used by CERN by a
       factor of 5 or more.
  </UL>

 <P>
  This document serves as a rationale to describe some of the design
  decisions of the port to this machine.
 </P>

 <H2 ALIGN=CENTER>Design Goals</H2>
 <P>
  One objective of the EBCDIC port was to maintain enough backwards
  compatibility with the (EBCDIC) CERN server to make the transition to
  the new server attractive and easy. This required the addition of
  a configurable method to define whether a HTML document was stored
  in ASCII (the only format accepted by the old server) or in EBCDIC
  (the native document format in the POSIX subsystem, and therefore
  the only realistic format in which the other POSIX tools like grep
  or sed could operate on the documents). The current solution to
  this is a "pseudo-MIME-format" which is intercepted and
  interpreted by the Apache server (see below). Future versions
  might solve the problem by defining an "ebcdic-handler" for all
  documents which must be converted.
 </P>

 <H2 ALIGN=CENTER>Technical Solution</H2>
 <P>
  Since all Apache input and output is based upon the BUFF data type
  and its methods, the easiest solution was to add the conversion to
  the BUFF handling routines. The conversion must be settable at any
  time, so a BUFF flag was added which defines whether a BUFF object
  has currently enabled conversion or not. This flag is modified at
  several points in the HTTP protocol:
 </P>

  <UL>
   <LI><STRONG>set</STRONG> before a request is received (because the
       request and the request header lines are always in ASCII
       format)

   <LI><STRONG>set/unset</STRONG> when the request body is
       received - depending on the content type of the request body
       (because the request body may contain ASCII text or a binary file)

   <LI><STRONG>set</STRONG> before a reply header is sent (because the
       response header lines are always in ASCII format)

   <LI><STRONG>set/unset</STRONG> when the response body is
       sent - depending on the content type of the response body
       (because the response body may contain text or a binary file)
  </UL>

<H2 ALIGN=CENTER>Porting Notes</H2>

  <OL>
   <LI>
   The relevant changes in the source are #ifdef'ed into two
   categories:
   <DL>
    <DT><CODE><STRONG>#ifdef CHARSET_EBCDIC</STRONG></CODE>
    <DD>Code which is needed for any EBCDIC based machine. This
	includes character translations, differences in
	contiguity of the two character sets, flags which
	indicate which part of the HTTP protocol has to be
	converted and which part doesn't <EM>etc.</EM>
    <DT><CODE><STRONG>#ifdef _OSD_POSIX</STRONG></CODE>
    <DD>Code which is needed for the SIEMENS BS2000/OSD
	mainframe platform only. This deals with include file
	differences and socket implementation topics which are
	only required on the BS2000/OSD platform.
   <BR>
   </DL>
   </LI>

   <LI>
    The possibility to translate between ASCII and EBCDIC at the
    socket level (on BS2000 POSIX, there is a socket option which
    supports this) was intentionally <EM>not</EM> chosen, because
    the byte stream at the HTTP protocol level consists of a
    mixture of protocol related strings and non-protocol related
    raw file data. HTTP protocol strings are always encoded in
    ASCII (the GET request, any Header: lines, the chunking
    information <EM>etc.</EM>) whereas the file transfer parts (<EM>i.e.</EM>, GIF
    images, CGI output <EM>etc.</EM>) should usually be just "passed through"
    by the server. This separation between "protocol string" and
    "raw data" is reflected in the server code by functions like
    bgets() or rvputs() for strings, and functions like bwrite()
    for binary data. A global translation of everything would
    therefore be inadequate.<BR>
    (In the case of text files of course, provisions must be made so
    that EBCDIC documents are always served in ASCII)
   <BR>
   </LI>

   <LI>
    This port therefore features a built-in protocol level conversion
    for the server-internal strings (which the compiler translated to
    EBCDIC strings) and thus for all server-generated documents.
    The hard coded ASCII escapes \012 and \015 which are
    ubiquitous in the server code are an exception: they are
    already the binary encoding of the ASCII \n and \r and must
    not be converted to ASCII a second time. This exception is
    only relevant for server-generated strings; and <EM>external</EM>
    EBCDIC documents are not expected to contain ASCII newline characters.
   <BR>
   </LI>

   <LI>
    By examining the call hierarchy for the BUFF management
    routines, I added an "ebcdic/ascii conversion layer" which
    would be crossed on every puts/write/get/gets, and a
    conversion flag which allowed enabling/disabling the
    conversions on-the-fly. Usually, a document crosses this
    layer twice from its origin source (a file or CGI output) to
    its destination (the requesting client): <SAMP>file -&gt;
    Apache</SAMP>, and <SAMP>Apache -&gt; client</SAMP>.<BR>
    The server can now read the header
    lines of a CGI-script output in EBCDIC format, and then find
    out that the remainder of the script's output is in ASCII
    (like in the case of the output of a WWW Counter program: the
    document body contains a GIF image). All header processing is
    done in the native EBCDIC format; the server then determines,
    based on the type of document being served, whether the
    document body (except for the chunking information, of
    course) is in ASCII already or must be converted from EBCDIC.
   <BR>
   </LI>

   <LI>
    For Text documents (MIME types text/plain, text/html <EM>etc.</EM>),
    an implicit translation to ASCII can be used, or (if the
    users prefer to store some documents in raw ASCII form for
    faster serving, or because the files reside on a NFS-mounted
    directory tree) can be served without conversion.
    <BR>
    <STRONG>Example:</STRONG><BLOCKQUOTE>
	to serve files with the suffix .ahtml as a raw ASCII text/html
	document without implicit conversion (and suffix .ascii
	as ASCII text/plain), use the directives:<PRE>
      AddType  text/x-ascii-html  .ahtml
      AddType  text/x-ascii-plain .ascii
      </PRE></BLOCKQUOTE>
    Similarly, any text/XXXX MIME type can be served as "raw ASCII" by
    configuring a MIME type "text/x-ascii-XXXX" for it using AddType.
   <BR>
   </LI>

   <LI>
    Non-text documents are always served "binary" without conversion.
    This seems to be the most sensible choice for, .<EM>e.g.</EM>, GIF/ZIP/AU
    file types. This of course requires the user to copy them to the
    mainframe host using the "rcp -b" binary switch.
   <BR>
   </LI>

   <LI>
    Server parsed files are always assumed to be in native (<EM>i.e.</EM>,
    EBCDIC) format as used on the machine, and are converted after
    processing.
   <BR>
   </LI>

   <LI>
    For CGI output, the CGI script determines whether a conversion is
    needed or not: by setting the appropriate Content-Type, text files
    can be converted, or GIF output can be passed through unmodified.
    An example for the latter case is the wwwcount program which we ported
    as well.
   <BR>
   </LI>
  </OL>

 <H2 ALIGN=CENTER>Document Storage Notes</H2>
  <H3 ALIGN=CENTER>Binary Files</H3>
   <P>
    All files with a <SAMP>Content-Type:</SAMP> which does not
    start with <SAMP>text/</SAMP> are regarded as <EM>binary files</EM>
    by the server and are not subject to any conversion.
    Examples for binary files are GIF images, gzip-compressed
    files and the like.
   </P>
   <P>
    When exchanging binary files between the mainframe host and a
    Unix machine or Windows PC, be sure to use the ftp "binary"
    (<SAMP>TYPE I</SAMP>) command, or use the
    <SAMP>rcp&nbsp;-b</SAMP> command from the mainframe host
    (the -b switch is not supported in unix rcp's).
   </P>

  <H3 ALIGN=CENTER>Text Documents</H3>
   <P>
    The default assumption of the server is that Text Files
    (<EM>i.e.</EM>, all files whose <SAMP>Content-Type:</SAMP> starts with
    <SAMP>text/</SAMP>) are stored in the native character
    set of the host, EBCDIC.
   </P>

  <H3 ALIGN=CENTER>Server Side Included Documents</H3>
   <P>
    SSI documents must currently be stored in EBCDIC only. No
    provision is made to convert it from ASCII before processing.
   </P>

 <H2 ALIGN=CENTER>Apache Modules' Status</H2>
 <TABLE BORDER="1" ALIGN="middle">
  <TR>
   <TH>Module
   <TH>Status
   <TH>Notes
  </TR>

  <TR>
   <TD ALIGN=LEFT>http_core
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_access
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_actions
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_alias
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_asis
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_auth
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_auth_anon
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_auth_db
   <TD ALIGN=CENTER>?
   <TD>with own libdb.a
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_auth_dbm
   <TD ALIGN=CENTER>?
   <TD>with own libdb.a
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_autoindex
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_cern_meta
   <TD ALIGN=CENTER>?
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_cgi
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_digest
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_dir
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_so
   <TD ALIGN=CENTER>-
   <TD>no shared libs
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_env
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_example
   <TD ALIGN=CENTER>-
   <TD>(test bed only)
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_expires
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_headers
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_imap
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_include
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_info
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_log_agent
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_log_config
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_log_referer
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_mime
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_mime_magic
   <TD ALIGN=CENTER>?
   <TD>not ported yet
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_negotiation
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_proxy
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_rewrite
   <TD ALIGN=CENTER>+
   <TD>untested
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_setenvif
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_speling
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_status
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_unique_id
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_userdir
   <TD ALIGN=CENTER>+
   <TD>
  </TR>

  <TR>
   <TD ALIGN=LEFT>mod_usertrack
   <TD ALIGN=CENTER>?
   <TD>untested
  </TR>
 </TABLE>

 <H2 ALIGN=CENTER>Third Party Modules' Status</H2>
 <TABLE BORDER="1" ALIGN="middle">
  <TR>
   <TH>Module
   <TH>Status
   <TH>Notes
  </TR>

  <TR>
   <TD ALIGN=LEFT><A HREF="http://java.apache.org/">mod_jserv</A>
   <TD ALIGN=CENTER>-
   <TD>JAVA still being ported.
  </TR>

  <TR>
   <TD ALIGN=LEFT><A HREF="http://www.php.net/">mod_php3</A>
   <TD ALIGN=CENTER>+
   <TD>mod_php3 runs fine, with LDAP and GD and FreeType libraries
  </TR>

  <TR>
   <TD ALIGN=LEFT
   ><A HREF="http://hpwww.ec-lyon.fr/~vincent/apache/mod_put.html">mod_put</A>
   <TD ALIGN=CENTER>?
   <TD>untested
  </TR>

  <TR>
   <TD ALIGN=LEFT
   ><A HREF="ftp://hachiman.vidya.com/pub/apache/">mod_session</A>
   <TD ALIGN=CENTER>-
   <TD>untested
  </TR>

 </TABLE>

<HR>
 <H3 ALIGN="CENTER">
  Apache HTTP Server
 </H3>
d4 370
a373 1
<A HREF="./"><IMG SRC="images/index.gif" ALT="Index"></A>
a374 2
</BODY>
</HTML>
@


1.3
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d36 2
a48 1
 </P>
d79 2
a96 1
 </P>
d99 1
a99 1
 <P>
d116 1
d118 1
a118 1
   </LI><BR>
d137 2
a138 1
   </LI><BR>
d150 2
a151 1
   </LI><BR>
d171 2
a172 1
   </LI><BR>
d190 2
a191 1
   </LI><BR>
d198 2
a199 1
   </LI><BR>
d205 2
a206 1
   </LI><BR>
d214 2
a215 1
   </LI><BR>
a216 1
 </P>
d250 1
a250 1
 <TABLE BORDER ALIGN=middle>
d475 1
a475 1
 <TABLE BORDER ALIGN=middle>
@


1.2
log
@Apache 1.3.3 merge + proxy_segv fix
@
text
@d18 1
a18 1
  Apache HTTP Server Version 1.3
d503 1
a503 1
  Apache HTTP Server Version 1.3
@


1.1
log
@Initial revision
@
text
@d28 2
a29 2
  (It is the SIEMENS NIXDORF family of mainframes running the
  <A HREF="http://www.sni.de/servers/bs2osd/osdbc_us.htm">BS2000/OSD
d110 1
a110 1
    <DD>Code which is needed for the BS2000 SIEMENS NIXDORF
d112 1
a112 1
	differences and socket implementations topics which are
d406 1
a406 1
   <TD ALIGN=CENTER>-
d482 1
a482 1
   <TD>mod_php3 runs fine, with LDAP and GD libraries
@


1.1.1.1
log
@Apache 1.3.2
@
text
@@


1.1.1.2
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d1 504
a504 2
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
d506 1
a506 370
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator" content="HTML Tidy, see www.w3.org" />

    <title>The Apache EBCDIC Port</title>
  </head>
  <!-- background white, links blue (unvisited), navy (visited), red (active) -->

  <body bgcolor="#ffffff" text="#000000" link="#0000ff"
  vlink="#000080" alink="#ff0000">
        <div align="CENTER">
      <img src="images/sub.gif" alt="[APACHE DOCUMENTATION]" /> 

      <h3>Apache HTTP Server</h3>
    </div>



    <h1 align="center">Overview of the Apache EBCDIC Port</h1>

    <p>As of Version 1.3, the Apache HTTP Server includes a port to
    (non-ASCII) mainframe machines which use the EBCDIC character
    set as their native codeset.<br />
     (Initially, that support covered only the Fujitsu-Siemens
    family of mainframes running the <a
    href="http://www.fujitsu-siemens.com/servers/bs2osd/osdbc_us.htm">
    BS2000/OSD operating system</a>, a mainframe OS which features
    a SVR4-derived POSIX subsystem. Later, the two IBM mainframe
    operating systems TPF and OS/390 were added).</p>
    <hr />

    <h2 align="center"><a id="ebcdic" name="ebcdic">EBCDIC-related
    conversion functions</a></h2>
    The EBCDIC related directives <a
    href="mod/core.html#ebcdicconvert">EBCDICConvert</a>, <a
    href="mod/core.html#ebcdicconvertbytype">EBCDICConvertByType</a>,
    and <a href="mod/core.html#ebcdickludge">EBCDICKludge</a> are
    available <b>only if the platform's character set is EBCDIC</b>
    (This is currently only the case on Fujitsu-Siemens' BS2000/OSD
    and IBM's OS/390 and TPF operating systems). EBCDIC stands for
    <em>Extended Binary-Coded-Decimal Interchange Code</em> and is
    the codeset used on mainframe machines, in contrast to ASCII
    which is ubiquitous on almost all micro computers today. ASCII
    (or its extension <em>latin1</em>) is the basis for the HTTP
    transfer protocol, therefore all EBCDIC-based platforms need a
    way to configure the code set conversion rules required between
    the EBCDIC based mainframe host and the HTTP socket
    protocol.<br />
     

    <p>On an EBCDIC based system, HTML files and other text files
    are usually saved encoded in the native EBCDIC code set, while
    image files and other binary data are stored with identical
    encoding as on ASCII based machines. When the Apache server
    accesses documents, it must therefore make a distinction
    between text files (to be converted to/from ASCII, depending on
    the transfer direction) and binary files (to be delivered
    unconverted). Such a distinction can be made based on the
    assigned MIME type, or based on the file extension
    (<em>i.e.</em>, files sharing a common file suffix).</p>

    <p>By default, the configuration is symmetric for input and
    output (<em>i.e.</em>, when a PUT request is executed for a
    document which was returned by a previous GET request, then the
    resulting uploaded copy should be identical to the original
    file). However, the conversion directives allow for specifying
    different conversions for input and output.</p>

    <p>The directives <a
    href="mod/core.html#ebcdicconvert">EBCDICConvert</a> and <a
    href="mod/core.html#ebcdicconvertbytype">EBCDICConvertByType</a>
    are used to assign the conversion setting (On or Off) based on
    file extensions or MIME types. Each configuration setting can
    be defined for input only (<em>e.g.</em>, PUT method), output
    only (<em>e.g.</em>, GET method), or both input and output. By
    default, the conversion setting is applied for input and
    output.</p>

    <p>Note that after modifying the conversion settings for a
    group of files, it is not sufficient to restart the server. The
    reason for this is the fact that a cached copy of a document
    (in a browser or proxy cache) will not get revalidated by
    contents, but only by date. Since the modification time of the
    document did not change, browsers will assume they can reuse
    the cached copy.<br />
     To recover from this situation, you must either clear all
    cached copies (browser and proxy cache!), or update the
    modification time of the documents (using the
    <code>touch</code> command on the server).</p>

    <p>Note also that server-parsed documents (CGI scripts, .shtml
    files, and other interpreted files like PHP scripts etc.) are
    not subject to any input conversion and must therefore be
    stored in EBCDIC form on the server side.</p>

    <p>In absense of any <a
    href="mod/core.html#ebcdicconvertbytype">EBCDICConvertByType</a>
    directive, and if no matching <a
    href="mod/core.html#ebcdicconvert">EBCDICConvert</a> was found,
    Apache falls back to an internal heuristic which assumes that
    all documents with MIME types starting with
    <samp>"text/"</samp>, <samp>"message/"</samp> or
    <samp>"multipart/"</samp> as well as the MIME type
    <samp>"application/x-www-form-urlencoded"</samp> are text
    documents stored in EBCDIC, whereas all other documents are
    binary files.</p>

    <p>In order to provide backward compatibility with older
    versions of apache, the <a
    href="mod/core.html#ebcdickludge">EBCDICKludge</a> directive
    allows for a less powerful mechanism to control the conversion
    of documents to and from EBCDIC.</p>

    <p><strong>Note</strong>:</p>

    <blockquote>
      The EBCDICKludge directive is deprecated, since its
      functionality is superseded by the more powerful <a
      href="mod/core.html#ebcdicconvert">EBCDICConvert</a> and <a
      href="mod/core.html#ebcdicconvertbytype">EBCDICConvertByType</a>
      directives.
    </blockquote>
    <br />
     <br />
     

    <p>The directives are applied in the following order:</p>

    <ol>
      <li>First, the configured <a
      href="mod/core.html#ebcdicconvert">EBCDICConvert</a>
      directives in the current context are evaluated in
      configuration file order. As soon as a matching file
      extension is found, the search stops and the configured
      conversion is applied.<br />
       EBCDICConvert settings inherited from parent directories are
      tested after the more specific (deeper) directory
      levels.</li>

      <li>If the <a
      href="mod/core.html#ebcdickludge">EBCDICKludge</a> is in
      effect, the next step tests for a MIME type of the format
      <samp><i>type/</i><b>x-ascii-</b><i>subtype</i></samp>. If
      the document has such a type, then the
      <samp>"<b>x-ascii-</b>"</samp> substring is removed and the
      conversion set to <samp>Off</samp>.</li>

      <li>In the next step, the configured <a
      href="mod/core.html#ebcdicconvertbytype">EBCDICConvertByType</a>
      directives are evaluated in configuration file order. If the
      document has a matching MIME type, the search stops and the
      configured conversion is applied.<br />
       EBCDICConvertByType settings inherited from parent
      directories are tested after the more specific (deeper)
      directory levels.<br />
       If no <a
      href="mod/core.html#ebcdicconvertbytype">EBCDICConvertByType</a>
      directive at all exists in the current context, the server
      falls back to the simple heuristics which assume that MIME
      types starting with "text/", "message/" or "multipart/" (plus
      the special type "application/x-www-form-urlencoded" used in
      simple POST requests) imply a conversion, while all the rest
      is delivered unconverted (<em>i.e.</em>, binary).</li>
    </ol>
    <br />
     <br />
     
    <hr />

    <h2 align="center"><a id="tech" name="tech">Technical
    Details</a></h2>

    <p>Since all Apache input and output is based upon the BUFF
    data type and its methods, the easiest solution was to add the
    actual conversion to the BUFF handling routines. The conversion
    must be settable at any time, so BUFF flags were added which
    define whether a BUFF object has currently enabled conversion
    or not. Two such flags exist: one for data read from the client
    (ASCII to EBCDIC conversion) and one for data returned to the
    client (EBCDIC to ASCII conversion).</p>

    <p>During sending of the header, Apache determines (based on
    the returned MIME type for the request) whether conversion
    should be used or the document returned unconverted. It uses
    this decision to initialize the BUFF flag when the response
    output begins. Modules should therefore determine the MIME type
    for the current request before initiating the response by
    calling ap_send_http_headers().</p>

    <p>The BUFF flag is modified at several points in the HTTP
    protocol:</p>

    <ul>
      <li><strong>set</strong> (In and Out) before a request is
      received (because the request and the request header lines
      are always in ASCII format)</li>

      <li><strong>set/unset</strong> (for Input data) when the
      request body is received - depending on the content type of
      the request body (because the request body may contain ASCII
      text or a binary file)</li>

      <li><strong>set</strong> (for returned Output) before a
      response header is sent (because the response header lines
      are always in ASCII format)</li>

      <li><strong>set/unset</strong> (for returned Output) when the
      response body is sent - depending on the content type of the
      response body (because the response body may contain text or
      a binary file)</li>
    </ul>
    Additional transparent transitions may occur for
    extracting/inserting the HTTP/1.1 chunking information
    from/into the input/output body data stream, and for generating
    <em>multipart</em> headers for <em>range</em> requests. (See
    RFC2616 and src/main/http_protocol.c for details.) 
    <hr />

    <h2 align="center"><a id="port" name="port">Porting
    Notes</a></h2>

    <ol>
      <li>
        The relevant changes in the source are #ifdef'ed into two
        categories: 

        <dl>
          <dt><code><strong>#ifdef
          CHARSET_EBCDIC</strong></code></dt>

          <dd>Code which is needed for any EBCDIC based machine.
          This includes character translations, differences in
          contiguity of the two character sets, flags which
          indicate which part of the HTTP protocol has to be
          converted and which part doesn't <em>etc.</em></dd>

          <dt><code><strong>#ifdef _OSD_POSIX | TPF |
          OS390</strong></code></dt>

          <dd>Code which is needed for the Fujitsu-Siemens
          BS2000/OSD | IBM TPF | IBM OS390 mainframe platforms
          only. This deals with include file differences and socket
          and fork implementation topics which are only required on
          the respective platform.<br />
          </dd>
        </dl>
      </li>

      <li>The possibility to translate between ASCII and EBCDIC at
      the socket level (on BS2000 POSIX, there is a socket option
      which supports this) was intentionally <em>not</em> chosen,
      because the byte stream at the HTTP protocol level consists
      of a mixture of protocol related strings and non-protocol
      related raw file data. HTTP protocol strings are always
      encoded in ASCII (the GET request, any Header: lines, the
      chunking information <em>etc.</em>) whereas the file transfer
      parts (<em>i.e.</em>, GIF images, CGI output <em>etc.</em>)
      should usually be just "passed through" by the server. This
      separation between "protocol string" and "raw data" is
      reflected in the server code by functions like bgets() or
      rvputs() for strings, and functions like bwrite() for binary
      data. A global translation of everything would therefore be
      inadequate.<br />
       (In the case of text files of course, provisions must be
      made so that EBCDIC documents are always served in
      ASCII)<br />
       This port therefore features a built-in protocol level
      conversion for the server-internal strings (which the
      compiler translated to EBCDIC strings) and thus for all
      server-generated documents.<br />
      </li>

      <li>By examining the call hierarchy for the BUFF management
      routines, I added an "ebcdic/ascii conversion layer" which
      would be crossed on every puts/write/get/gets, and conversion
      flags which allowed enabling/disabling the conversions
      on-the-fly. Usually, a document crosses this layer twice from
      its origin source (a file or CGI output) to its destination
      (the requesting client): <samp>file -&gt; Apache</samp>, and
      <samp>Apache -&gt; client</samp>.<br />
       The server can now read the header lines of a CGI-script
      output in EBCDIC format, and then find out that the remainder
      of the script's output is in ASCII (like in the case of the
      output of a WWW Counter program: the document body contains a
      GIF image). All header processing is done in the native
      EBCDIC format; the server then determines, based on the type
      of document being served, whether the document body (except
      for the chunking information, of course) is in ASCII already
      or must be converted from EBCDIC.<br />
      </li>

      <li>
        By default, Apache assumes that documents with the MIME
        types "text/*", "message/*", "multipart/*" and
        "application/x-www-form-urlencoded" are text documents and
        are stored as EBCDIC files, whereas all other files are
        binary files (and stored in a byte-identical encoding as on
        an ASCII machine).<br />
         These defaults can be overridden on a <a
        href="mod/core.html#ebcdicconvertbytype">by-MIME-type</a>
        and/or <a
        href="mod/core.html#ebcdicconvert">by-file-extension</a>
        basis, using the directives 
<pre>
     <a
href="mod/core.html#ebcdicconvertbytype">EBCDICConvertByType</a> {On|Off}[={In|Out|InOut}] <em>mimetype</em> [...]
     <a
href="mod/core.html#ebcdicconvert">EBCDICConvert</a>       {On|Off}[={In|Out|InOut}] <em>fileext</em> [...]
   
</pre>
        where the <em>mimetype</em> argument may contain
        wildcards.<br />
      </li>

      <li>Before adding the flexible conversion, non-text documents
      were always served "binary" without conversion. This seemed
      to be the most sensible choice for, .<em>e.g.</em>,
      GIF/ZIP/AU file types (It of course requires the user to copy
      them to the mainframe host using the "rcp -b" binary switch),
      but proved to be inadequate for MIME types like
      <samp>model/vrml</samp>, <samp>application/postscript</samp>
      and <samp>application/x-javascript</samp>.<br />
      </li>

      <li>Server parsed files are always assumed to be in native
      (<em>i.e.</em>, EBCDIC) format as used on the machine
      (because they do not cross the conversion layer when being
      read), and are converted after processing.<br />
      </li>

      <li>For CGI output, the CGI script determines whether a
      conversion is needed or not: by setting the appropriate
      Content-Type, text files can be converted, or GIF output can
      be passed through unmodified (depending on the conversion
      configured in the script's context).<br />
      </li>
    </ol>
    <hr />

    <h2 align="center"><a id="store" name="store">Document Storage
    Notes</a></h2>

    <h3 align="center">Binary Files</h3>

    <p>When exchanging binary files between the mainframe host and
    a Unix machine or Windows PC, be sure to use the ftp "binary"
    (<samp>TYPE I</samp>) command, or use the
    <samp>rcp&nbsp;-b</samp> command from the mainframe host (the
    -b switch is not supported in unix rcp's).</p>

    <h3 align="center">Text Documents</h3>

    <p>The default assumption of the server is that Text Files
    (<em>i.e.</em>, all files whose <samp>Content-Type:</samp>
    starts with <samp>text/</samp>) are stored in the native
    character set of the host, EBCDIC.</p>

    <h3 align="center">Server Side Included Documents</h3>

    <p>SSI documents must currently be stored in EBCDIC only. No
    provision is made to convert them from ASCII before processing.
    The same holds for other interpreted languages, like mod_perl
    or mod_php.</p>
        <hr />

    <h3 align="CENTER">Apache HTTP Server</h3>
    <a href="./"><img src="images/index.gif" alt="Index" /></a>

  </body>
</html>
d508 2
@


1.1.1.3
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d29 1
a29 1
    href="http://www.fujitsu-siemens.com/rl/products/software/bs2000bc.html">
@


