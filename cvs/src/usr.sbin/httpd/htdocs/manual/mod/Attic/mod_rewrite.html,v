head	1.15;
access;
symbols
	OPENBSD_5_5:1.14.0.10
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.6
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.4
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.28
	OPENBSD_5_0:1.13.0.26
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.24
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.22
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.18
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.20
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.16
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.14
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.12
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.10
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.4
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.3
	apache_1_3_27:1.1.1.3
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	apache_1_3_26:1.1.1.3
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.2.0.2
	OPENBSD_2_4_BASE:1.1.1.2
	apache_1_3_2:1.1.1.2
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	apache:1.1.1
	apache_1_2_6:1.1.1;
locks; strict;
comment	@# @;


1.15
date	2014.04.22.14.47.24;	author henning;	state dead;
branches;
next	1.14;

1.14
date	2012.02.24.06.19.00;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.29.23.55.40;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.17.19.05.47;	author henning;	state dead;
branches;
next	1.11;

1.11
date	2003.08.21.13.11.33;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.19.21.31.14;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.29.02.08.04;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.12.07.56.48;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.29.10.21.33;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.15.22.17.39;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.19.11.16.36;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.25.18.29.27;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	99.09.29.06.29.06;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.03.01.01.05.24;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.03.25.07.08.34;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.25.07.08.34;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.10.01.17.20.06;	author beck;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.07.19.21.27.58;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.08.21.12.53.33;	author henning;	state Exp;
branches;
next	;


desc
@@


1.15
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--%hypertext -->
<!-- mod_rewrite.html                                 -->
<!-- Documentation for the mod_rewrite Apache module  -->

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator" content="HTML Tidy, see www.w3.org" />

    <title>Apache module mod_rewrite</title>
  </head>
  <!-- Background white, links blue (unvisited), navy (visited), red (active) -->

  <body bgcolor="#FFFFFF" text="#000000" link="#0000FF"
  vlink="#000080" alink="#FF0000">
    <blockquote>
      <!-- page indentation -->
          <div align="CENTER">
      <img src="../images/sub.gif" alt="[APACHE DOCUMENTATION]" /> 

      <h3>Apache HTTP Server Version 1.3</h3>
    </div>

      <br />
       

      <h1 align="CENTER">Module mod_rewrite<br />
       URL Rewriting Engine</h1>

      <p>This module provides a rule-based rewriting engine to
      rewrite requested URLs on the fly.</p>

      <p><a href="module-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="module-dict.html#SourceFile"
      rel="Help"><strong>Source File:</strong></a>
      mod_rewrite.c<br />
       <a href="module-dict.html#ModuleIdentifier"
      rel="Help"><strong>Module Identifier:</strong></a>
      rewrite_module<br />
       <a href="module-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Available in
      Apache 1.2 and later.</p>
      <hr noshade="noshade" size="1" />
      <br />
       

      <h2>Summary</h2>

      <blockquote>
        <blockquote>
          <blockquote>
            <em>``The great thing about mod_rewrite is it gives you
            all the configurability and flexibility of Sendmail.
            The downside to mod_rewrite is that it gives you all
            the configurability and flexibility of Sendmail.''</em>
            

            <div align="RIGHT">
              -- Brian Behlendorf<br />
               Apache Group
            </div>
          </blockquote>
        </blockquote>
      </blockquote>

      <blockquote>
        <blockquote>
          <blockquote>
            <em>`` Despite the tons of examples and docs,
            mod_rewrite is voodoo. Damned cool voodoo, but still
            voodoo. ''</em> 

            <div align="RIGHT">
              -- Brian Moore<br />
               bem@@news.cmc.net
            </div>
          </blockquote>
        </blockquote>
      </blockquote>
      Welcome to mod_rewrite, the Swiss Army Knife of URL
      manipulation! 

      <p>This module uses a rule-based rewriting engine (based on a
      regular-expression parser) to rewrite requested URLs on the
      fly. It supports an unlimited number of rules and an
      unlimited number of attached rule conditions for each rule to
      provide a really flexible and powerful URL manipulation
      mechanism. The URL manipulations can depend on various tests,
      for instance server variables, environment variables, HTTP
      headers, time stamps and even external database lookups in
      various formats can be used to achieve a really granular URL
      matching.</p>

      <p>This module operates on the full URLs (including the
      path-info part) both in per-server context
      (<code>httpd.conf</code>) and per-directory context
      (<code>.htaccess</code>) and can even generate query-string
      parts on result. The rewritten result can lead to internal
      sub-processing, external request redirection or even to an
      internal proxy throughput.</p>

      <p>But all this functionality and flexibility has its
      drawback: complexity. So don't expect to understand this
      entire module in just one day.</p>

      <p>This module was invented and originally written in April
      1996<br />
       and gifted exclusively to the The Apache Group in July 1997
      by</p>

      <blockquote>
        <a href="http://www.engelschall.com/"><code>Ralf S.
        Engelschall</code></a><br />
         <a
        href="mailto:rse@@engelschall.com"><code>rse@@engelschall.com</code></a><br />
         <a
        href="http://www.engelschall.com/"><code>www.engelschall.com</code></a>
      </blockquote>
      <hr noshade="noshade" size="1" />

      <h2>Table Of Contents</h2>

      <p><strong>Internal Processing</strong></p>

      <ul>
        <li><a href="#InternalAPI">API Phases</a></li>

        <li><a href="#InternalRuleset">Ruleset Processing</a></li>

        <li><a href="#InternalBackRefs">Regex Back-Reference
        Availability</a></li>
      </ul>

      <p><strong>Configuration Directives</strong></p>

      <ul>
        <li><a href="#RewriteEngine">RewriteEngine</a></li>

        <li><a href="#RewriteOptions">RewriteOptions</a></li>

        <li><a href="#RewriteLog">RewriteLog</a></li>

        <li><a href="#RewriteLogLevel">RewriteLogLevel</a></li>

        <li><a href="#RewriteLock">RewriteLock</a></li>

        <li><a href="#RewriteMap">RewriteMap</a></li>

        <li><a href="#RewriteBase">RewriteBase</a></li>

        <li><a href="#RewriteCond">RewriteCond</a></li>

        <li><a href="#RewriteRule">RewriteRule</a></li>
      </ul>
      <strong>Miscellaneous</strong> 

      <ul>
        <li><a href="#EnvVar">Environment Variables</a></li>

        <li><a href="#Solutions">Practical Solutions</a></li>
      </ul>
      <hr noshade="noshade" size="1" />

      <center>
        <h1><a id="Internal" name="Internal">Internal
        Processing</a></h1>
      </center>
      <hr noshade="noshade" size="1" />

      <p>The internal processing of this module is very complex but
      needs to be explained once even to the average user to avoid
      common mistakes and to let you exploit its full
      functionality.</p>

      <h2><a id="InternalAPI" name="InternalAPI">API
      Phases</a></h2>

      <p>First you have to understand that when Apache processes a
      HTTP request it does this in phases. A hook for each of these
      phases is provided by the Apache API. Mod_rewrite uses two of
      these hooks: the URL-to-filename translation hook which is
      used after the HTTP request has been read but before any
      authorization starts and the Fixup hook which is triggered
      after the authorization phases and after the per-directory
      config files (<code>.htaccess</code>) have been read, but
      before the content handler is activated.</p>

      <p>So, after a request comes in and Apache has determined the
      corresponding server (or virtual server) the rewriting engine
      starts processing of all mod_rewrite directives from the
      per-server configuration in the URL-to-filename phase. A few
      steps later when the final data directories are found, the
      per-directory configuration directives of mod_rewrite are
      triggered in the Fixup phase. In both situations mod_rewrite
      rewrites URLs either to new URLs or to filenames, although
      there is no obvious distinction between them. This is a usage
      of the API which was not intended to be this way when the API
      was designed, but as of Apache 1.x this is the only way
      mod_rewrite can operate. To make this point more clear
      remember the following two points:</p>

      <ol>
        <li>Although mod_rewrite rewrites URLs to URLs, URLs to
        filenames and even filenames to filenames, the API
        currently provides only a URL-to-filename hook. In Apache
        2.0 the two missing hooks will be added to make the
        processing more clear. But this point has no drawbacks for
        the user, it is just a fact which should be remembered:
        Apache does more in the URL-to-filename hook than the API
        intends for it.</li>

        <li>
          Unbelievably mod_rewrite provides URL manipulations in
          per-directory context, <em>i.e.</em>, within
          <code>.htaccess</code> files, although these are reached
          a very long time after the URLs have been translated to
          filenames. It has to be this way because
          <code>.htaccess</code> files live in the filesystem, so
          processing has already reached this stage. In other
          words: According to the API phases at this time it is too
          late for any URL manipulations. To overcome this chicken
          and egg problem mod_rewrite uses a trick: When you
          manipulate a URL/filename in per-directory context
          mod_rewrite first rewrites the filename back to its
          corresponding URL (which is usually impossible, but see
          the <code>RewriteBase</code> directive below for the
          trick to achieve this) and then initiates a new internal
          sub-request with the new URL. This restarts processing of
          the API phases. 

          <p>Again mod_rewrite tries hard to make this complicated
          step totally transparent to the user, but you should
          remember here: While URL manipulations in per-server
          context are really fast and efficient, per-directory
          rewrites are slow and inefficient due to this chicken and
          egg problem. But on the other hand this is the only way
          mod_rewrite can provide (locally restricted) URL
          manipulations to the average user.</p>
        </li>
      </ol>

      <p>Don't forget these two points!</p>

      <h2><a id="InternalRuleset" name="InternalRuleset">Ruleset
      Processing</a></h2>
      Now when mod_rewrite is triggered in these two API phases, it
      reads the configured rulesets from its configuration
      structure (which itself was either created on startup for
      per-server context or during the directory walk of the Apache
      kernel for per-directory context). Then the URL rewriting
      engine is started with the contained ruleset (one or more
      rules together with their conditions). The operation of the
      URL rewriting engine itself is exactly the same for both
      configuration contexts. Only the final result processing is
      different. 

      <p>The order of rules in the ruleset is important because the
      rewriting engine processes them in a special (and not very
      obvious) order. The rule is this: The rewriting engine loops
      through the ruleset rule by rule (<code>RewriteRule</code>
      directives) and when a particular rule matches it optionally
      loops through existing corresponding conditions
      (<code>RewriteCond</code> directives). For historical reasons
      the conditions are given first, and so the control flow is a
      little bit long-winded. See Figure 1 for more details.</p>

      <div align="CENTER">
        <table cellspacing="0" cellpadding="2" border="0">
          <tr>
            <td bgcolor="#CCCCCC"><img
            src="../images/mod_rewrite_fig1.gif" width="428"
            height="385"
            alt="[Needs graphics capability to display]" /></td>
          </tr>

          <tr>
            <td align="CENTER"><strong>Figure 1:</strong> The
            control flow through the rewriting ruleset</td>
          </tr>
        </table>
      </div>

      <p>As you can see, first the URL is matched against the
      <em>Pattern</em> of each rule. When it fails mod_rewrite
      immediately stops processing this rule and continues with the
      next rule. If the <em>Pattern</em> matches, mod_rewrite looks
      for corresponding rule conditions. If none are present, it
      just substitutes the URL with a new value which is
      constructed from the string <em>Substitution</em> and goes on
      with its rule-looping. But if conditions exist, it starts an
      inner loop for processing them in the order that they are
      listed. For conditions the logic is different: we don't match
      a pattern against the current URL. Instead we first create a
      string <em>TestString</em> by expanding variables,
      back-references, map lookups, <em>etc.</em> and then we try
      to match <em>CondPattern</em> against it. If the pattern
      doesn't match, the complete set of conditions and the
      corresponding rule fails. If the pattern matches, then the
      next condition is processed until no more conditions are
      available. If all conditions match, processing is continued
      with the substitution of the URL with
      <em>Substitution</em>.</p>

      <h2><a id="quoting" name="quoting">Quoting Special
      Characters</a></h2>

      <p>As of Apache 1.3.20, special characters in
      <i>TestString</i> and <i>Substitution</i> strings can be
      escaped (that is, treated as normal characters without their
      usual special meaning) by prefixing them with a slosh ('\')
      character. In other words, you can include an actual
      dollar-sign character in a <i>Substitution</i> string by
      using '<code>\$</code>'; this keeps mod_rewrite from trying
      to treat it as a backreference.</p>

      <h2><a id="InternalBackRefs" name="InternalBackRefs">Regex
      Back-Reference Availability</a></h2>
      One important thing here has to be remembered: Whenever you
      use parentheses in <em>Pattern</em> or in one of the
      <em>CondPattern</em>, back-references are internally created
      which can be used with the strings <code>$N</code> and
      <code>%N</code> (see below). These are available for creating
      the strings <em>Substitution</em> and <em>TestString</em>.
      Figure 2 shows to which locations the back-references are
      transferred for expansion.

      <div align="CENTER">
        <table cellspacing="0" cellpadding="2" border="0">
          <tr>
            <td bgcolor="#CCCCCC"><img
            src="../images/mod_rewrite_fig2.gif" width="381"
            height="179"
            alt="[Needs graphics capability to display]" /></td>
          </tr>

          <tr>
            <td align="CENTER"><strong>Figure 2:</strong> The
            back-reference flow through a rule</td>
          </tr>
        </table>
      </div>

      <p>We know this was a crash course on mod_rewrite's internal
      processing. But you will benefit from this knowledge when
      reading the following documentation of the available
      directives.</p>
      <hr noshade="noshade" size="1" />

      <center>
        <h1><a id="Configuration"
        name="Configuration">Configuration Directives</a></h1>
      </center>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteEngine"
      name="RewriteEngine">RewriteEngine</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteEngine
      on|off<br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> <code>RewriteEngine
      off</code><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config,
      virtual host, directory, .htaccess<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a> FileInfo<br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache
      1.2<br />
       

      <p>The <code>RewriteEngine</code> directive enables or
      disables the runtime rewriting engine. If it is set to
      <code>off</code> this module does no runtime processing at
      all. It does not even update the <code>SCRIPT_URx</code>
      environment variables.</p>

      <p>Use this directive to disable the module instead of
      commenting out all the <code>RewriteRule</code>
      directives!</p>

      <p>Note that, by default, rewrite configurations are not
      inherited. This means that you need to have a
      <code>RewriteEngine on</code> directive for each virtual host
      in which you wish to use it.</p>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteOptions"
      name="RewriteOptions">RewriteOptions</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteOptions
      <em>Option</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> <code>RewriteOptions
      MaxRedirects=10</code><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config,
      virtual host, directory, .htaccess<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a> FileInfo<br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache
      1.2; <code>MaxRedirects</code> is available in Apache 1.3.28 and
      later<br />


      <p>The <code>RewriteOptions</code> directive sets some
      special options for the current per-server or per-directory
      configuration. The <em>Option</em> strings can be one of the
      following:</p>

      <dl>
      <dt><code>inherit</code></dt>
      <dd>This forces the current configuration to inherit the
      configuration of the parent. In per-virtual-server context
      this means that the maps, conditions and rules of the main
      server are inherited. In per-directory context this means
      that conditions and rules of the parent directory's
      <code>.htaccess</code> configuration are inherited.</dd>

      <dt><code>MaxRedirects=<var>number</var></code></dt>
      <dd>In order to prevent endless loops of internal redirects
      issued by per-directory <code>RewriteRule</code>s,
      <code>mod_rewrite</code> aborts the request after reaching a
      maximum number of such redirects and responds with an 500 Internal
      Server Error. If you really need more internal redirects than 10
      per request, you may increase the default to the desired value.</dd>
      </dl>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteLog" name="RewriteLog">RewriteLog</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteLog
      <em>file-path</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> <em>None</em><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config,
      virtual host<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a> <em>Not
      applicable</em><br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache
      1.2<br />
       

      <p>The <code>RewriteLog</code> directive sets the name of the
      file to which the server logs any rewriting actions it
      performs. If the name does not begin with a slash
      ('<code>/</code>') then it is assumed to be relative to the
      <em>Server Root</em>. The directive should occur only once
      per server config.</p>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Note</strong>: To disable the logging of
          rewriting actions it is not recommended to set
          <em>file-path</em> to <code>/dev/null</code>, because
          although the rewriting engine does not then output to a
          logfile it still creates the logfile output internally.
          <strong>This will slow down the server with no advantage
          to the administrator!</strong> To disable logging either
          remove or comment out the <code>RewriteLog</code>
          directive or use <code>RewriteLogLevel 0</code>!</td>
        </tr>
      </table>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Security</strong>: See the <a
          href="../misc/security_tips.html">Apache Security
          Tips</a> document for details on why your security could
          be compromised if the directory where logfiles are stored
          is writable by anyone other than the user that starts the
          server.</td>
        </tr>
      </table>

      <p><strong>Example:</strong></p>

      <blockquote>
<pre>
RewriteLog "/usr/local/var/apache/logs/rewrite.log"
</pre>
      </blockquote>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteLogLevel"
      name="RewriteLogLevel">RewriteLogLevel</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteLogLevel
      <em>Level</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a>
      <code>RewriteLogLevel 0</code><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config,
      virtual host<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a> <em>Not
      applicable</em><br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache
      1.2<br />
       

      <p>The <code>RewriteLogLevel</code> directive sets the
      verbosity level of the rewriting logfile. The default level 0
      means no logging, while 9 or more means that practically all
      actions are logged.</p>

      <p>To disable the logging of rewriting actions simply set
      <em>Level</em> to 0. This disables all rewrite action
      logs.</p>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Notice:</strong> Using a high value for
          <em>Level</em> will slow down your Apache server
          dramatically! Use the rewriting logfile at a
          <em>Level</em> greater than 2 only for debugging!</td>
        </tr>
      </table>

      <p><strong>Example:</strong></p>

      <blockquote>
<pre>
RewriteLogLevel 3
</pre>
      </blockquote>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteLock"
      name="RewriteLock">RewriteLock</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteLock
      <em>file-path</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> <em>None</em><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a> <em>Not
      applicable</em><br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache
      1.3<br />
       

      <p>This directive sets the filename for a synchronization
      lockfile which mod_rewrite needs to communicate with
      <samp>RewriteMap</samp> <em>programs</em>. Set this lockfile
      to a local path (not on a NFS-mounted device) when you want
      to use a rewriting map-program. It is not required for other
      types of rewriting maps.</p>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteMap" name="RewriteMap">RewriteMap</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteMap
      <em>MapName</em> <em>MapType</em>:<em>MapSource</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> not used per
      default<br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config,
      virtual host<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a> <em>Not
      applicable</em><br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache 1.2
      (partially), Apache 1.3<br />
       

      <p>The <code>RewriteMap</code> directive defines a
      <em>Rewriting Map</em> which can be used inside rule
      substitution strings by the mapping-functions to
      insert/substitute fields through a key lookup. The source of
      this lookup can be of various types.</p>

      <p>The <a id="mapfunc" name="mapfunc"><em>MapName</em></a> is
      the name of the map and will be used to specify a
      mapping-function for the substitution strings of a rewriting
      rule via one of the following constructs:</p>

      <blockquote>
        <strong><code>${</code> <em>MapName</em> <code>:</code>
        <em>LookupKey</em> <code>}</code><br />
         <code>${</code> <em>MapName</em> <code>:</code>
        <em>LookupKey</em> <code>|</code> <em>DefaultValue</em>
        <code>}</code></strong>
      </blockquote>
      When such a construct occurs the map <em>MapName</em> is
      consulted and the key <em>LookupKey</em> is looked-up. If the
      key is found, the map-function construct is substituted by
      <em>SubstValue</em>. If the key is not found then it is
      substituted by <em>DefaultValue</em> or by the empty string
      if no <em>DefaultValue</em> was specified. 

      <p>The following combinations for <em>MapType</em> and
      <em>MapSource</em> can be used:</p>

      <ul>
        <li>
          <strong>Standard Plain Text</strong><br />
           MapType: <code>txt</code>, MapSource: Unix filesystem
          path to valid regular file 

          <p>This is the standard rewriting map feature where the
          <em>MapSource</em> is a plain ASCII file containing
          either blank lines, comment lines (starting with a '#'
          character) or pairs like the following - one per
          line.</p>

          <blockquote>
            <strong><em>MatchingKey</em>
            <em>SubstValue</em></strong>
          </blockquote>

          <p>Example:</p>

          <table border="0" cellspacing="1" cellpadding="5"
          bgcolor="#F0F0F0">
            <tr>
              <td>
<pre>
##
##  map.txt -- rewriting map
##

Ralf.S.Engelschall    rse   # Bastard Operator From Hell
Mr.Joe.Average        joe   # Mr. Average
</pre>
              </td>
            </tr>
          </table>

          <table border="0" cellspacing="1" cellpadding="5"
          bgcolor="#F0F0F0">
            <tr>
              <td>
<pre>
RewriteMap real-to-user txt:/path/to/file/map.txt
</pre>
              </td>
            </tr>
          </table>
        </li>

        <li>
          <strong>Randomized Plain Text</strong><br />
           MapType: <code>rnd</code>, MapSource: Unix filesystem
          path to valid regular file 

          <p>This is identical to the Standard Plain Text variant
          above but with a special post-processing feature: After
          looking up a value it is parsed according to contained
          ``<code>|</code>'' characters which have the meaning of
          ``or''. In other words they indicate a set of
          alternatives from which the actual returned value is
          chosen randomly. Although this sounds crazy and useless,
          it was actually designed for load balancing in a reverse
          proxy situation where the looked up values are server
          names. Example:</p>

          <table border="0" cellspacing="1" cellpadding="5"
          bgcolor="#F0F0F0">
            <tr>
              <td>
<pre>
##
##  map.txt -- rewriting map
##

static   www1|www2|www3|www4
dynamic  www5|www6
</pre>
              </td>
            </tr>
          </table>

          <table border="0" cellspacing="1" cellpadding="5"
          bgcolor="#F0F0F0">
            <tr>
              <td>
<pre>
RewriteMap servers rnd:/path/to/file/map.txt
</pre>
              </td>
            </tr>
          </table>
        </li>

        <li>
          <strong>Hash File</strong><br />
           MapType: <code>dbm</code>, MapSource: Unix filesystem
          path to valid regular file 

          <p>Here the source is a binary NDBM format file
          containing the same contents as a <em>Plain Text</em>
          format file, but in a special representation which is
          optimized for really fast lookups. You can create such a
          file with any NDBM tool or with the following Perl
          script:</p>

          <table border="0" cellspacing="1" cellpadding="5"
          bgcolor="#F0F0F0">
            <tr>
              <td>
<pre>
#!/path/to/bin/perl
##
##  txt2dbm -- convert txt map to dbm format
##

use NDBM_File;
use Fcntl;

($txtmap, $dbmmap) = @@ARGV;

open(TXT, "&lt;$txtmap") or die "Couldn't open $txtmap!\n";
tie (%DB, 'NDBM_File', $dbmmap,O_RDWR|O_TRUNC|O_CREAT, 0644) or die "Couldn't create $dbmmap!\n";

while (&lt;TXT&gt;) {
  next if (/^\s*#/ or /^\s*$/);
  $DB{$1} = $2 if (/^\s*(\S+)\s+(\S+)/);
}

untie %DB;
close(TXT);
</pre>
              </td>
            </tr>
          </table>

          <table border="0" cellspacing="1" cellpadding="5"
          bgcolor="#F0F0F0">
            <tr>
              <td>
<pre>
$ txt2dbm map.txt map.db
</pre>
              </td>
            </tr>
          </table>
        </li>

        <li>
          <strong>Internal Function</strong><br />
           MapType: <code>int</code>, MapSource: Internal Apache
          function 

          <p>Here the source is an internal Apache function.
          Currently you cannot create your own, but the following
          functions already exists:</p>

          <ul>
            <li><strong>toupper</strong>:<br />
             Converts the looked up key to all upper case.</li>

            <li><strong>tolower</strong>:<br />
             Converts the looked up key to all lower case.</li>

            <li><strong>escape</strong>:<br />
             Translates special characters in the looked up key to
            hex-encodings.</li>

            <li><strong>unescape</strong>:<br />
             Translates hex-encodings in the looked up key back to
            special characters.</li>
          </ul>
        </li>

        <li>
          <strong>External Rewriting Program</strong><br />
           MapType: <code>prg</code>, MapSource: Unix filesystem
          path to valid regular file 

          <p>Here the source is a program, not a map file. To
          create it you can use the language of your choice, but
          the result has to be a executable (<em>i.e.</em>, either
          object-code or a script with the magic cookie trick
          '<code>#!/path/to/interpreter</code>' as the first
          line).</p>

          <p>This program is started once at startup of the Apache
          servers and then communicates with the rewriting engine
          over its <code>stdin</code> and <code>stdout</code>
          file-handles. For each map-function lookup it will
          receive the key to lookup as a newline-terminated string
          on <code>stdin</code>. It then has to give back the
          looked-up value as a newline-terminated string on
          <code>stdout</code> or the four-character string
          ``<code>NULL</code>'' if it fails (<em>i.e.</em>, there
          is no corresponding value for the given key). A trivial
          program which will implement a 1:1 map (<em>i.e.</em>,
          key == value) could be:</p>

          <table border="0" cellspacing="1" cellpadding="5"
          bgcolor="#F0F0F0">
            <tr>
              <td>
<pre>
#!/usr/bin/perl
$| = 1;
while (&lt;STDIN&gt;) {
    # ...put here any transformations or lookups...
    print $_;
}
</pre>
              </td>
            </tr>
          </table>

          <p>But be very careful:<br />
          </p>

          <ol>
            <li>``<em>Keep it simple, stupid</em>'' (KISS), because
            if this program hangs it will hang the Apache server
            when the rule occurs.</li>

            <li>Avoid one common mistake: never do buffered I/O on
            <code>stdout</code>! This will cause a deadloop! Hence
            the ``<code>$|=1</code>'' in the above example...</li>

            <li>Use the <samp>RewriteLock</samp> directive to
            define a lockfile mod_rewrite can use to synchronize
            the communication to the program. By default no such
            synchronization takes place.</li>
          </ol>
        </li>
      </ul>
      The <code>RewriteMap</code> directive can occur more than
      once. For each mapping-function use one
      <code>RewriteMap</code> directive to declare its rewriting
      mapfile. While you cannot <strong>declare</strong> a map in
      per-directory context it is of course possible to
      <strong>use</strong> this map in per-directory context. 

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Note:</strong> For plain text and DBM format
          files the looked-up keys are cached in-core until the
          <code>mtime</code> of the mapfile changes or the server
          does a restart. This way you can have map-functions in
          rules which are used for <strong>every</strong> request.
          This is no problem, because the external lookup only
          happens once!</td>
        </tr>
      </table>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteBase"
      name="RewriteBase">RewriteBase</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteBase
      <em>URL-path</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> <em>default is the
      physical directory path</em><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> directory,
      .htaccess<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a>
      <em>FileInfo</em><br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache
      1.2<br />
       

      <p>The <code>RewriteBase</code> directive explicitly sets the
      base URL for per-directory rewrites. As you will see below,
      <code>RewriteRule</code> can be used in per-directory config
      files (<code>.htaccess</code>). There it will act locally,
      <em>i.e.</em>, the local directory prefix is stripped at this
      stage of processing and your rewriting rules act only on the
      remainder. At the end it is automatically added back to the
      path.</p>

      <p>When a substitution occurs for a new URL, this module has
      to re-inject the URL into the server processing. To be able
      to do this it needs to know what the corresponding URL-prefix
      or URL-base is. By default this prefix is the corresponding
      filepath itself. <strong>But at most websites URLs are NOT
      directly related to physical filename paths, so this
      assumption will usually be wrong!</strong> There you have to
      use the <code>RewriteBase</code> directive to specify the
      correct URL-prefix.</p>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Notice:</strong> If your webserver's URLs are
          <strong>not</strong> directly related to physical file
          paths, you have to use <code>RewriteBase</code> in every
          <code>.htaccess</code> files where you want to use
          <code>RewriteRule</code> directives.</td>
        </tr>
      </table>

      <p><strong>Example:</strong></p>

      <blockquote>
        Assume the following per-directory config file: 

        <table border="0" cellspacing="1" cellpadding="5"
        bgcolor="#F0F0F0">
          <tr>
            <td>
<pre>
#
#  /abc/def/.htaccess -- per-dir config file for directory /abc/def
#  Remember: /abc/def is the physical path of /xyz, <em>i.e.</em>, the server
#            has a 'Alias /xyz /abc/def' directive <em>e.g.</em>
#

RewriteEngine On

#  let the server know that we were reached via /xyz and not
#  via the physical path prefix /abc/def
RewriteBase   /xyz

#  now the rewriting rules
RewriteRule   ^oldstuff\.html$  newstuff.html
</pre>
            </td>
          </tr>
        </table>

        <p>In the above example, a request to
        <code>/xyz/oldstuff.html</code> gets correctly rewritten to
        the physical file <code>/abc/def/newstuff.html</code>.</p>

        <table width="70%" border="0" bgcolor="#E0E0F0"
        cellspacing="0" cellpadding="10">
          <tr>
            <td>
              <font size="-1"><strong>Note - For Apache
              hackers:</strong><br />
               The following list gives detailed information about
              the internal processing steps:</font> 
<pre>
<font size="-1">Request:
  /xyz/oldstuff.html

Internal Processing:
  /xyz/oldstuff.html     -&gt; /abc/def/oldstuff.html  (per-server Alias)
  /abc/def/oldstuff.html -&gt; /abc/def/newstuff.html  (per-dir    RewriteRule)
  /abc/def/newstuff.html -&gt; /xyz/newstuff.html      (per-dir    RewriteBase)
  /xyz/newstuff.html     -&gt; /abc/def/newstuff.html  (per-server Alias)

Result:
  /abc/def/newstuff.html
</font>
</pre>
              <font size="-1">This seems very complicated but is
              the correct Apache internal processing, because the
              per-directory rewriting comes too late in the
              process. So, when it occurs the (rewritten) request
              has to be re-injected into the Apache kernel! BUT:
              While this seems like a serious overhead, it really
              isn't, because this re-injection happens fully
              internally to the Apache server and the same
              procedure is used by many other operations inside
              Apache. So, you can be sure the design and
              implementation is correct.</font> 
            </td>
          </tr>
        </table>
      </blockquote>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteCond"
      name="RewriteCond">RewriteCond</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteCond
      <em>TestString</em> <em>CondPattern</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> <em>None</em><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config,
      virtual host, directory, .htaccess<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a>
      <em>FileInfo</em><br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache 1.2
      (partially), Apache 1.3<br />
       

      <p>The <code>RewriteCond</code> directive defines a rule
      condition. Precede a <code>RewriteRule</code> directive with
      one or more <code>RewriteCond</code> directives. The
      following rewriting rule is only used if its pattern matches
      the current state of the URI <strong>and</strong> if these
      additional conditions apply too.</p>

      <p><em>TestString</em> is a string which can contains the
      following expanded constructs in addition to plain text:</p>

      <ul>
        <li>
          <strong>RewriteRule backreferences</strong>: These are
          backreferences of the form 

          <blockquote>
            <strong><code>$N</code></strong>
          </blockquote>
          (0 &lt;= N &lt;= 9) which provide access to the grouped
          parts (parenthesis!) of the pattern from the
          corresponding <code>RewriteRule</code> directive (the one
          following the current bunch of <code>RewriteCond</code>
          directives).
        </li>

        <li>
          <strong>RewriteCond backreferences</strong>: These are
          backreferences of the form 

          <blockquote>
            <strong><code>%N</code></strong>
          </blockquote>
          (1 &lt;= N &lt;= 9) which provide access to the grouped
          parts (parentheses!) of the pattern from the last matched
          <code>RewriteCond</code> directive in the current bunch
          of conditions.
        </li>

        <li>
          <strong>RewriteMap expansions</strong>: These are
          expansions of the form 

          <blockquote>
            <strong><code>${mapname:key|default}</code></strong>
          </blockquote>
          See <a href="#mapfunc">the documentation for
          RewriteMap</a> for more details.
        </li>

        <li>
          <strong>Server-Variables</strong>: These are variables of
          the form 

          <blockquote>
            <strong><code>%{</code> <em>NAME_OF_VARIABLE</em>
            <code>}</code></strong>
          </blockquote>
          where <em>NAME_OF_VARIABLE</em> can be a string taken
          from the following list: 

          <table bgcolor="#F0F0F0" cellspacing="0" cellpadding="5">
            <tr>
              <td valign="TOP">
                <strong>HTTP headers:</strong> 

                <p><font size="-1">HTTP_USER_AGENT<br />
                 HTTP_REFERER<br />
                 HTTP_COOKIE<br />
                 HTTP_FORWARDED<br />
                 HTTP_HOST<br />
                 HTTP_PROXY_CONNECTION<br />
                 HTTP_ACCEPT<br />
                </font></p>
              </td>

              <td valign="TOP">
                <strong>connection &amp; request:</strong> 

                <p><font size="-1">REMOTE_ADDR<br />
                 REMOTE_HOST<br />
                 REMOTE_USER<br />
                 REMOTE_IDENT<br />
                 REQUEST_METHOD<br />
                 SCRIPT_FILENAME<br />
                 PATH_INFO<br />
                 QUERY_STRING<br />
                 AUTH_TYPE<br />
                </font></p>
              </td>
            </tr>

            <tr>
              <td valign="TOP">
                <strong>server internals:</strong> 

                <p><font size="-1">DOCUMENT_ROOT<br />
                 SERVER_ADMIN<br />
                 SERVER_NAME<br />
                 SERVER_ADDR<br />
                 SERVER_PORT<br />
                 SERVER_PROTOCOL<br />
                 SERVER_SOFTWARE<br />
                </font></p>
              </td>

              <td valign="TOP">
                <strong>system stuff:</strong> 

                <p><font size="-1">TIME_YEAR<br />
                 TIME_MON<br />
                 TIME_DAY<br />
                 TIME_HOUR<br />
                 TIME_MIN<br />
                 TIME_SEC<br />
                 TIME_WDAY<br />
                 TIME<br />
                </font></p>
              </td>

              <td valign="TOP">
                <strong>specials:</strong> 

                <p><font size="-1">API_VERSION<br />
                 THE_REQUEST<br />
                 REQUEST_URI<br />
                 REQUEST_FILENAME<br />
                 IS_SUBREQ<br />
                </font></p>
              </td>
            </tr>
          </table>

          <table width="70%" border="0" bgcolor="#E0E0F0"
          cellspacing="0" cellpadding="10">
            <tr>
              <td>
                <p><strong>Notice:</strong> These variables all
                correspond to the similarly named HTTP
                MIME-headers, C variables of the Apache server or
                <code>struct tm</code> fields of the Unix system.
                Most are documented elsewhere in the Manual or in
                the CGI specification. Those that are special to
                mod_rewrite include:</p>

                <dl>
                  <dt><code>IS_SUBREQ</code></dt>

                  <dd>Will contain the text "true" if the request
                  currently being processed is a sub-request,
                  "false" otherwise. Sub-requests may be generated
                  by modules that need to resolve additional files
                  or URIs in order to complete their tasks.</dd>

                  <dt><code>API_VERSION</code></dt>

                  <dd>This is the version of the Apache module API
                  (the internal interface between server and
                  module) in the current httpd build, as defined in
                  include/ap_mmn.h. The module API version
                  corresponds to the version of Apache in use (in
                  the release version of Apache 1.3.14, for
                  instance, it is 19990320:10), but is mainly of
                  interest to module authors.</dd>

                  <dt><code>THE_REQUEST</code></dt>

                  <dd>The full HTTP request line sent by the
                  browser to the server (e.g., "<code>GET
                  /index.html HTTP/1.1</code>"). This does not
                  include any additional headers sent by the
                  browser.</dd>

                  <dt><code>REQUEST_URI</code></dt>

                  <dd>The resource requested in the HTTP request
                  line. (In the example above, this would be
                  "/index.html".)</dd>

                  <dt><code>REQUEST_FILENAME</code></dt>

                  <dd>The full local filesystem path to the file or
                  script matching the request.</dd>
                </dl>
              </td>
            </tr>
          </table>
        </li>
      </ul>

      <p>Special Notes:</p>

      <ol>
        <li>The variables SCRIPT_FILENAME and REQUEST_FILENAME
        contain the same value, <em>i.e.</em>, the value of the
        <code>filename</code> field of the internal
        <code>request_rec</code> structure of the Apache server.
        The first name is just the commonly known CGI variable name
        while the second is the consistent counterpart to
        REQUEST_URI (which contains the value of the
        <code>uri</code> field of <code>request_rec</code>).</li>

        <li>There is the special format:
        <code>%{ENV:variable}</code> where <em>variable</em> can be
        any environment variable. This is looked-up via internal
        Apache structures and (if not found there) via
        <code>getenv()</code> from the Apache server process.</li>

        <li>There is the special format:
        <code>%{HTTP:header}</code> where <em>header</em> can be
        any HTTP MIME-header name. This is looked-up from the HTTP
        request. Example: <code>%{HTTP:Proxy-Connection}</code> is
        the value of the HTTP header
        ``<code>Proxy-Connection:</code>''.</li>

        <li>There is the special format
        <code>%{LA-U:variable}</code> for look-aheads which perform
        an internal (URL-based) sub-request to determine the final
        value of <em>variable</em>. Use this when you want to use a
        variable for rewriting which is actually set later in an
        API phase and thus is not available at the current stage.
        For instance when you want to rewrite according to the
        <code>REMOTE_USER</code> variable from within the
        per-server context (<code>httpd.conf</code> file) you have
        to use <code>%{LA-U:REMOTE_USER}</code> because this
        variable is set by the authorization phases which come
        <em>after</em> the URL translation phase where mod_rewrite
        operates. On the other hand, because mod_rewrite implements
        its per-directory context (<code>.htaccess</code> file) via
        the Fixup phase of the API and because the authorization
        phases come <em>before</em> this phase, you just can use
        <code>%{REMOTE_USER}</code> there.</li>

        <li>There is the special format:
        <code>%{LA-F:variable}</code> which performs an internal
        (filename-based) sub-request to determine the final value
        of <em>variable</em>. Most of the time this is the same as
        LA-U above.</li>
      </ol>

      <p><em>CondPattern</em> is the condition pattern,
      <em>i.e.</em>, a regular expression which is applied to the
      current instance of the <em>TestString</em>, <em>i.e.</em>,
      <em>TestString</em> is evaluated and then matched against
      <em>CondPattern</em>.</p>

      <p><strong>Remember:</strong> <em>CondPattern</em> is a
      standard <em>Extended Regular Expression</em> with some
      additions:</p>

      <ol>
        <li>You can prefix the pattern string with a
        '<code>!</code>' character (exclamation mark) to specify a
        <strong>non</strong>-matching pattern.</li>

        <li>
          There are some special variants of <em>CondPatterns</em>.
          Instead of real regular expression strings you can also
          use one of the following: 

          <ul>
            <li>'<strong>&lt;CondPattern</strong>' (is lexically
            lower)<br />
             Treats the <em>CondPattern</em> as a plain string and
            compares it lexically to <em>TestString</em>. True if
            <em>TestString</em> is lexically lower than
            <em>CondPattern</em>.</li>

            <li>'<strong>&gt;CondPattern</strong>' (is lexically
            greater)<br />
             Treats the <em>CondPattern</em> as a plain string and
            compares it lexically to <em>TestString</em>. True if
            <em>TestString</em> is lexically greater than
            <em>CondPattern</em>.</li>

            <li>'<strong>=CondPattern</strong>' (is lexically
            equal)<br />
             Treats the <em>CondPattern</em> as a plain string and
            compares it lexically to <em>TestString</em>. True if
            <em>TestString</em> is lexically equal to
            <em>CondPattern</em>, i.e the two strings are exactly
            equal (character by character). If <em>CondPattern</em>
            is just <samp>""</samp> (two quotation marks) this
            compares <em>TestString</em> to the empty string.</li>

            <li>'<strong>-d</strong>' (is
            <strong>d</strong>irectory)<br />
             Treats the <em>TestString</em> as a pathname and tests
            if it exists and is a directory.</li>

            <li>'<strong>-f</strong>' (is regular
            <strong>f</strong>ile)<br />
             Treats the <em>TestString</em> as a pathname and tests
            if it exists and is a regular file.</li>

            <li>'<strong>-s</strong>' (is regular file with
            <strong>s</strong>ize)<br />
             Treats the <em>TestString</em> as a pathname and tests
            if it exists and is a regular file with size greater
            than zero.</li>

            <li>'<strong>-l</strong>' (is symbolic
            <strong>l</strong>ink)<br />
             Treats the <em>TestString</em> as a pathname and tests
            if it exists and is a symbolic link.</li>

            <li>'<strong>-F</strong>' (is existing file via
            subrequest)<br />
             Checks if <em>TestString</em> is a valid file and
            accessible via all the server's currently-configured
            access controls for that path. This uses an internal
            subrequest to determine the check, so use it with care
            because it decreases your servers performance!</li>

            <li>'<strong>-U</strong>' (is existing URL via
            subrequest)<br />
             Checks if <em>TestString</em> is a valid URL and
            accessible via all the server's currently-configured
            access controls for that path. This uses an internal
            subrequest to determine the check, so use it with care
            because it decreases your server's performance!</li>
          </ul>

          <table width="70%" border="0" bgcolor="#E0E0F0"
          cellspacing="0" cellpadding="10">
            <tr>
              <td><strong>Notice:</strong> All of these tests can
              also be prefixed by an exclamation mark ('!') to
              negate their meaning.</td>
            </tr>
          </table>
        </li>
      </ol>

      <p>Additionally you can set special flags for
      <em>CondPattern</em> by appending</p>

      <blockquote>
        <strong><code>[</code><em>flags</em><code>]</code></strong>
      </blockquote>
      as the third argument to the <code>RewriteCond</code>
      directive. <em>Flags</em> is a comma-separated list of the
      following flags: 

      <ul>
        <li>'<strong><code>nocase|NC</code></strong>'
        (<strong>n</strong>o <strong>c</strong>ase)<br />
         This makes the test case-insensitive, <em>i.e.</em>, there
        is no difference between 'A-Z' and 'a-z' both in the
        expanded <em>TestString</em> and the <em>CondPattern</em>.
        This flag is effective only for comparisons between
        <em>TestString</em> and <em>CondPattern</em>. It has no
        effect on filesystem and subrequest checks.</li>

        <li>
          '<strong><code>ornext|OR</code></strong>'
          (<strong>or</strong> next condition)<br />
           Use this to combine rule conditions with a local OR
          instead of the implicit AND. Typical example: 

          <blockquote>
<pre>
RewriteCond %{REMOTE_HOST}  ^host1.*  [OR]
RewriteCond %{REMOTE_HOST}  ^host2.*  [OR]
RewriteCond %{REMOTE_HOST}  ^host3.*
RewriteRule ...some special stuff for any of these hosts...
</pre>
          </blockquote>
          Without this flag you would have to write the cond/rule
          three times.
        </li>
      </ul>

      <p><strong>Example:</strong></p>

      <blockquote>
        To rewrite the Homepage of a site according to the
        ``<code>User-Agent:</code>'' header of the request, you can
        use the following: 

        <blockquote>
<pre>
RewriteCond  %{HTTP_USER_AGENT}  ^Mozilla.*
RewriteRule  ^/$                 /homepage.max.html  [L]

RewriteCond  %{HTTP_USER_AGENT}  ^Lynx.*
RewriteRule  ^/$                 /homepage.min.html  [L]

RewriteRule  ^/$                 /homepage.std.html  [L]
</pre>
        </blockquote>
        Interpretation: If you use Netscape Navigator as your
        browser (which identifies itself as 'Mozilla'), then you
        get the max homepage, which includes Frames, <em>etc.</em>
        If you use the Lynx browser (which is Terminal-based), then
        you get the min homepage, which contains no images, no
        tables, <em>etc.</em> If you use any other browser you get
        the standard homepage.
      </blockquote>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteRule"
      name="RewriteRule">RewriteRule</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteRule
      <em>Pattern</em> <em>Substitution</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> <em>None</em><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config,
      virtual host, directory, .htaccess<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a>
      <em>FileInfo</em><br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache 1.2
      (partially), Apache 1.3<br />
       

      <p>The <code>RewriteRule</code> directive is the real
      rewriting workhorse. The directive can occur more than once.
      Each directive then defines one single rewriting rule. The
      <strong>definition order</strong> of these rules is
      <strong>important</strong>, because this order is used when
      applying the rules at run-time.</p>

      <p><a id="patterns" name="patterns"><em>Pattern</em></a> can
      be (for Apache 1.1.x a System V8 and for Apache 1.2.x and
      later a POSIX) <a id="regexp" name="regexp">regular
      expression</a> which gets applied to the current URL. Here
      ``current'' means the value of the URL when this rule gets
      applied. This may not be the originally requested URL,
      because any number of rules may already
      have matched and made alterations to it.</p>

      <p>Some hints about the syntax of regular expressions:</p>

      <table bgcolor="#F0F0F0" cellspacing="0" cellpadding="5">
        <tr>
          <td valign="TOP">
<pre>
<strong>Text:</strong>
  <strong><code>.</code></strong>           Any single character
  <strong><code>[</code></strong>chars<strong><code>]</code></strong>     Character class: One  of chars
  <strong><code>[^</code></strong>chars<strong><code>]</code></strong>    Character class: None of chars
  text1<strong><code>|</code></strong>text2 Alternative: text1 or text2

<strong>Quantifiers:</strong>
  <strong><code>?</code></strong>           0 or 1 of the preceding text
  <strong><code>*</code></strong>           0 or N of the preceding text (N &gt; 0)
  <strong><code>+</code></strong>           1 or N of the preceding text (N &gt; 1)

<strong>Grouping:</strong>
  <strong><code>(</code></strong>text<strong><code>)</code></strong>      Grouping of text
              (either to set the borders of an alternative or
              for making backreferences where the <strong>N</strong>th group can 
              be used on the RHS of a RewriteRule with <code>$</code><strong>N</strong>)

<strong>Anchors:</strong>
  <strong><code>^</code></strong>           Start of line anchor
  <strong><code>$</code></strong>           End   of line anchor

<strong>Escaping:</strong>
  <strong><code>\</code></strong>char       escape that particular char
              (for instance to specify the chars "<code>.[]()</code>" <em>etc.</em>)
</pre>
          </td>
        </tr>
      </table>

      <p>For more information about regular expressions either have
      a look at your local regex(3) manpage or its
      <code>src/regex/regex.3</code> copy in the Apache 1.3
      distribution. If you are interested in more detailed
      information about regular expressions and their variants
      (POSIX regex, Perl regex, <em>etc.</em>) have a look at the
      following dedicated book on this topic:</p>

      <blockquote>
        <em>Mastering Regular Expressions</em><br />
         Jeffrey E.F. Friedl<br />
         Nutshell Handbook Series<br />
         O'Reilly &amp; Associates, Inc. 1997<br />
         ISBN 1-56592-257-3<br />
      </blockquote>

      <p>Additionally in mod_rewrite the NOT character
      ('<code>!</code>') is a possible pattern prefix. This gives
      you the ability to negate a pattern; to say, for instance:
      ``<em>if the current URL does <strong>NOT</strong> match this
      pattern</em>''. This can be used for exceptional cases, where
      it is easier to match the negative pattern, or as a last
      default rule.</p>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Notice:</strong> When using the NOT character
          to negate a pattern you cannot have grouped wildcard
          parts in the pattern. This is impossible because when the
          pattern does NOT match, there are no contents for the
          groups. In consequence, if negated patterns are used, you
          cannot use <code>$N</code> in the substitution
          string!</td>
        </tr>
      </table>

      <p><a id="rhs" name="rhs"><em>Substitution</em></a> of a
      rewriting rule is the string which is substituted for (or
      replaces) the original URL for which <em>Pattern</em>
      matched. Beside plain text you can use</p>

      <ol>
        <li>back-references <code>$N</code> to the RewriteRule
        pattern</li>

        <li>back-references <code>%N</code> to the last matched
        RewriteCond pattern</li>

        <li>server-variables as in rule condition test-strings
        (<code>%{VARNAME}</code>)</li>

        <li><a href="#mapfunc">mapping-function</a> calls
        (<code>${mapname:key|default}</code>)</li>
      </ol>
      Back-references are <code>$</code><strong>N</strong>
      (<strong>N</strong>=0..9) identifiers which will be replaced
      by the contents of the <strong>N</strong>th group of the
      matched <em>Pattern</em>. The server-variables are the same
      as for the <em>TestString</em> of a <code>RewriteCond</code>
      directive. The mapping-functions come from the
      <code>RewriteMap</code> directive and are explained there.
      These three types of variables are expanded in the order of
      the above list. 

      <p>As already mentioned above, all the rewriting rules are
      applied to the <em>Substitution</em> (in the order of
      definition in the config file). The URL is <strong>completely
      replaced</strong> by the <em>Substitution</em> and the
      rewriting process goes on until there are no more rules
      unless explicitly terminated by a
      <code><strong>L</strong></code> flag - see below.</p>

      <p>There is a special substitution string named
      '<code>-</code>' which means: <strong>NO
      substitution</strong>! Sounds silly? No, it is useful to
      provide rewriting rules which <strong>only</strong> match
      some URLs but do no substitution, <em>e.g.</em>, in
      conjunction with the <strong>C</strong> (chain) flag to be
      able to have more than one pattern to be applied before a
      substitution occurs.</p>

      <p>One more note: You can even create URLs in the
      substitution string containing a query string part. Just use
      a question mark inside the substitution string to indicate
      that the following stuff should be re-injected into the
      QUERY_STRING. When you want to erase an existing query
      string, end the substitution string with just the question
      mark.</p>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Note</strong>: There is a special feature:
          When you prefix a substitution field with
          <code>http://</code><em>thishost</em>[<em>:thisport</em>]
          then <strong>mod_rewrite</strong> automatically strips it
          out. This auto-reduction on implicit external redirect
          URLs is a useful and important feature when used in
          combination with a mapping-function which generates the
          hostname part. Have a look at the first example in the
          example section below to understand this.</td>
        </tr>
      </table>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Remember:</strong> An unconditional external
          redirect to your own server will not work with the prefix
          <code>http://thishost</code> because of this feature. To
          achieve such a self-redirect, you have to use the
          <strong>R</strong>-flag (see below).</td>
        </tr>
      </table>

      <p>Additionally you can set special flags for
      <em>Substitution</em> by appending</p>

      <blockquote>
        <strong><code>[</code><em>flags</em><code>]</code></strong>
      </blockquote>
      as the third argument to the <code>RewriteRule</code>
      directive. <em>Flags</em> is a comma-separated list of the
      following flags: 

      <ul>
        <li>
          '<strong><code>redirect|R</code>
          [=<em>code</em>]</strong>' (force <a id="redirect"
          name="redirect"><strong>r</strong>edirect</a>)<br />
           Prefix <em>Substitution</em> with
          <code>http://thishost[:thisport]/</code> (which makes the
          new URL a URI) to force a external redirection. If no
          <em>code</em> is given a HTTP response of 302 (MOVED
          TEMPORARILY) is used. If you want to use other response
          codes in the range 300-400 just specify them as a number
          or use one of the following symbolic names:
          <code>temp</code> (default), <code>permanent</code>,
          <code>seeother</code>. Use it for rules which should
          canonicalize the URL and give it back to the client,
          <em>e.g.</em>, translate ``<code>/~</code>'' into
          ``<code>/u/</code>'' or always append a slash to
          <code>/u/</code><em>user</em>, etc.<br />
           

          <p><strong>Note:</strong> When you use this flag, make
          sure that the substitution field is a valid URL! If not,
          you are redirecting to an invalid location! And remember
          that this flag itself only prefixes the URL with
          <code>http://thishost[:thisport]/</code>, rewriting
          continues. Usually you also want to stop and do the
          redirection immediately. To stop the rewriting you also
          have to provide the 'L' flag.</p>
        </li>

        <li>'<strong><code>forbidden|F</code></strong>' (force URL
        to be <strong>f</strong>orbidden)<br />
         This forces the current URL to be forbidden,
        <em>i.e.</em>, it immediately sends back a HTTP response of
        403 (FORBIDDEN). Use this flag in conjunction with
        appropriate RewriteConds to conditionally block some
        URLs.</li>

        <li>'<strong><code>gone|G</code></strong>' (force URL to be
        <strong>g</strong>one)<br />
         This forces the current URL to be gone, <em>i.e.</em>, it
        immediately sends back a HTTP response of 410 (GONE). Use
        this flag to mark pages which no longer exist as gone.</li>

        <li>
          '<strong><code>proxy|P</code></strong>' (force
          <strong>p</strong>roxy)<br />
           This flag forces the substitution part to be internally
          forced as a proxy request and immediately (<em>i.e.</em>,
          rewriting rule processing stops here) put through the <a
          href="mod_proxy.html">proxy module</a>. You have to make
          sure that the substitution string is a valid URI
          (<em>e.g.</em>, typically starting with
          <code>http://</code><em>hostname</em>) which can be
          handled by the Apache proxy module. If not you get an
          error from the proxy module. Use this flag to achieve a
          more powerful implementation of the <a
          href="mod_proxy.html#proxypass">ProxyPass</a> directive,
          to map some remote stuff into the namespace of the local
          server. 

          <p>Notice: To use this functionality make sure you have
          the proxy module compiled into your Apache server
          program. If you don't know please check whether
          <code>mod_proxy.c</code> is part of the ``<code>httpd
          -l</code>'' output. If yes, this functionality is
          available to mod_rewrite. If not, then you first have to
          rebuild the ``<code>httpd</code>'' program with mod_proxy
          enabled.</p>
        </li>

        <li>'<strong><code>last|L</code></strong>'
        (<strong>l</strong>ast rule)<br />
         Stop the rewriting process here and don't apply any more
        rewriting rules. This corresponds to the Perl
        <code>last</code> command or the <code>break</code> command
        from the C language. Use this flag to prevent the currently
        rewritten URL from being rewritten further by following
        rules. For example, use it to rewrite the root-path URL
        ('<code>/</code>') to a real one, <em>e.g.</em>,
        '<code>/e/www/</code>'.</li>

        <li>'<strong><code>next|N</code></strong>'
        (<strong>n</strong>ext round)<br />
         Re-run the rewriting process (starting again with the
        first rewriting rule). Here the URL to match is again not
        the original URL but the URL from the last rewriting rule.
        This corresponds to the Perl <code>next</code> command or
        the <code>continue</code> command from the C language. Use
        this flag to restart the rewriting process, <em>i.e.</em>,
        to immediately go to the top of the loop.<br />
         <strong>But be careful not to create an infinite
        loop!</strong></li>

        <li>'<strong><code>chain|C</code></strong>'
        (<strong>c</strong>hained with next rule)<br />
         This flag chains the current rule with the next rule
        (which itself can be chained with the following rule,
        <em>etc.</em>). This has the following effect: if a rule
        matches, then processing continues as usual, <em>i.e.</em>,
        the flag has no effect. If the rule does
        <strong>not</strong> match, then all following chained
        rules are skipped. For instance, use it to remove the
        ``<code>.www</code>'' part inside a per-directory rule set
        when you let an external redirect happen (where the
        ``<code>.www</code>'' part should not to occur!).</li>

        <li>
        '<strong><code>type|T</code></strong>=<em>MIME-type</em>'
        (force MIME <strong>t</strong>ype)<br />
         Force the MIME-type of the target file to be
        <em>MIME-type</em>. For instance, this can be used to
        simulate the <code>mod_alias</code> directive
        <code>ScriptAlias</code> which internally forces all files
        inside the mapped directory to have a MIME type of
        ``<code>application/x-httpd-cgi</code>''.</li>

        <li>
          '<strong><code>nosubreq|NS</code></strong>' (used only if
          <strong>n</strong>o internal
          <strong>s</strong>ub-request)<br />
           This flag forces the rewriting engine to skip a
          rewriting rule if the current request is an internal
          sub-request. For instance, sub-requests occur internally
          in Apache when <code>mod_include</code> tries to find out
          information about possible directory default files
          (<code>index.xxx</code>). On sub-requests it is not
          always useful and even sometimes causes a failure to if
          the complete set of rules are applied. Use this flag to
          exclude some rules.<br />
           

          <p>Use the following rule for your decision: whenever you
          prefix some URLs with CGI-scripts to force them to be
          processed by the CGI-script, the chance is high that you
          will run into problems (or even overhead) on
          sub-requests. In these cases, use this flag.</p>
        </li>

        <li>'<strong><code>nocase|NC</code></strong>'
        (<strong>n</strong>o <strong>c</strong>ase)<br />
         This makes the <em>Pattern</em> case-insensitive,
        <em>i.e.</em>, there is no difference between 'A-Z' and
        'a-z' when <em>Pattern</em> is matched against the current
        URL.</li>

        <li>'<strong><code>qsappend|QSA</code></strong>'
        (<strong>q</strong>uery <strong>s</strong>tring
        <strong>a</strong>ppend)<br />
         This flag forces the rewriting engine to append a query
        string part in the substitution string to the existing one
        instead of replacing it. Use this when you want to add more
        data to the query string via a rewrite rule.</li>

        <li>
          '<strong><code>noescape|NE</code></strong>'
          (<strong>n</strong>o URI <strong>e</strong>scaping of
          output)<br />
           This flag keeps mod_rewrite from applying the usual URI
          escaping rules to the result of a rewrite. Ordinarily,
          special characters (such as '%', '$', ';', and so on)
          will be escaped into their hexcode equivalents ('%25',
          '%24', and '%3B', respectively); this flag prevents this
          from being done. This allows percent symbols to appear in
          the output, as in 
<pre>
    RewriteRule /foo/(.*) /bar?arg=P1\%3d$1 [R,NE]
   
</pre>
          which would turn '<code>/foo/zed</code>' into a safe
          request for '<code>/bar?arg=P1=zed</code>'. 

          <table width="70%" border="0" bgcolor="#E0E0F0"
          cellspacing="0" cellpadding="10">
            <tr>
              <td><strong>Notice:</strong> The
              <code>noescape</code> flag is only available with
              Apache 1.3.20 and later versions.</td>
            </tr>
          </table>
        </li>

        <li>
          '<strong><code>passthrough|PT</code></strong>'
          (<strong>p</strong>ass <strong>t</strong>hrough to next
          handler)<br />
           This flag forces the rewriting engine to set the
          <code>uri</code> field of the internal
          <code>request_rec</code> structure to the value of the
          <code>filename</code> field. This flag is just a hack to
          be able to post-process the output of
          <code>RewriteRule</code> directives by
          <code>Alias</code>, <code>ScriptAlias</code>,
          <code>Redirect</code>, <em>etc.</em> directives from
          other URI-to-filename translators. A trivial example to
          show the semantics: If you want to rewrite
          <code>/abc</code> to <code>/def</code> via the rewriting
          engine of <code>mod_rewrite</code> and then
          <code>/def</code> to <code>/ghi</code> with
          <code>mod_alias</code>: 
<pre>
    RewriteRule ^/abc(.*)  /def$1 [PT]
    Alias       /def       /ghi
   
</pre>
          If you omit the <code>PT</code> flag then
          <code>mod_rewrite</code> will do its job fine,
          <em>i.e.</em>, it rewrites <code>uri=/abc/...</code> to
          <code>filename=/def/...</code> as a full API-compliant
          URI-to-filename translator should do. Then
          <code>mod_alias</code> comes and tries to do a
          URI-to-filename transition which will not work. 

          <p>Note: <strong>You have to use this flag if you want to
          intermix directives of different modules which contain
          URL-to-filename translators</strong>. The typical example
          is the use of <code>mod_alias</code> and
          <code>mod_rewrite</code>..</p>
        </li>

        <li>'<strong><code>skip|S</code></strong>=<em>num</em>'
        (<strong>s</strong>kip next rule(s))<br />
         This flag forces the rewriting engine to skip the next
        <em>num</em> rules in sequence when the current rule
        matches. Use this to make pseudo if-then-else constructs:
        The last rule of the then-clause becomes
        <code>skip=N</code> where N is the number of rules in the
        else-clause. (This is <strong>not</strong> the same as the
        'chain|C' flag!)</li>

        <li>
        '<strong><code>env|E=</code></strong><em>VAR</em>:<em>VAL</em>'
        (set <strong>e</strong>nvironment variable)<br />
         This forces an environment variable named <em>VAR</em> to
        be set to the value <em>VAL</em>, where <em>VAL</em> can
        contain regexp backreferences <code>$N</code> and
        <code>%N</code> which will be expanded. You can use this
        flag more than once to set more than one variable. The
        variables can be later dereferenced in many situations, but
        usually from within XSSI (via <code>&lt;!--#echo
        var="VAR"--&gt;</code>) or CGI (<em>e.g.</em>
        <code>$ENV{'VAR'}</code>). Additionally you can dereference
        it in a following RewriteCond pattern via
        <code>%{ENV:VAR}</code>. Use this to strip but remember
        information from URLs.</li>
      </ul>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td>
            <strong>Note:</strong> Never forget that
            <em>Pattern</em> is applied to a complete URL in
            per-server configuration files. <strong>But in
            per-directory configuration files, the per-directory
            prefix (which always is the same for a specific
            directory!) is automatically <em>removed</em> for the
            pattern matching and automatically <em>added</em> after
            the substitution has been done.</strong> This feature
            is essential for many sorts of rewriting, because
            without this prefix stripping you have to match the
            parent directory which is not always possible. 

            <p>There is one exception: If a substitution string
            starts with ``<code>http://</code>'' then the directory
            prefix will <strong>not</strong> be added and an
            external redirect or proxy throughput (if flag
            <strong>P</strong> is used!) is forced!</p>
          </td>
        </tr>
      </table>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Note:</strong> To enable the rewriting engine
          for per-directory configuration files you need to set
          ``<code>RewriteEngine On</code>'' in these files
          <strong>and</strong> ``<code>Options
          FollowSymLinks</code>'' must be enabled. If your
          administrator has disabled override of
          <code>FollowSymLinks</code> for a user's directory, then
          you cannot use the rewriting engine. This restriction is
          needed for security reasons.</td>
        </tr>
      </table>

      <p>Here are all possible substitution combinations and their
      meanings:</p>

      <p><strong>Inside per-server configuration
      (<code>httpd.conf</code>)<br />
       for request ``<code>GET
      /somepath/pathinfo</code>'':</strong><br />
      </p>

      <table bgcolor="#F0F0F0" cellspacing="0" cellpadding="5">
        <tr>
          <td>
<pre>
<strong>Given Rule</strong>                                      <strong>Resulting Substitution</strong>
----------------------------------------------  ----------------------------------
^/somepath(.*) otherpath$1                      not supported, because invalid!

^/somepath(.*) otherpath$1  [R]                 not supported, because invalid!

^/somepath(.*) otherpath$1  [P]                 not supported, because invalid!
----------------------------------------------  ----------------------------------
^/somepath(.*) /otherpath$1                     /otherpath/pathinfo

^/somepath(.*) /otherpath$1 [R]                 http://thishost/otherpath/pathinfo
                                                via external redirection

^/somepath(.*) /otherpath$1 [P]                 not supported, because silly!
----------------------------------------------  ----------------------------------
^/somepath(.*) http://thishost/otherpath$1      /otherpath/pathinfo

^/somepath(.*) http://thishost/otherpath$1 [R]  http://thishost/otherpath/pathinfo
                                                via external redirection

^/somepath(.*) http://thishost/otherpath$1 [P]  not supported, because silly!
----------------------------------------------  ----------------------------------
^/somepath(.*) http://otherhost/otherpath$1     http://otherhost/otherpath/pathinfo
                                                via external redirection

^/somepath(.*) http://otherhost/otherpath$1 [R] http://otherhost/otherpath/pathinfo
                                                via external redirection
                                                (the [R] flag is redundant)

^/somepath(.*) http://otherhost/otherpath$1 [P] http://otherhost/otherpath/pathinfo
                                                via internal proxy
</pre>
          </td>
        </tr>
      </table>

      <p><strong>Inside per-directory configuration for
      <code>/somepath</code><br />
       (<em>i.e.</em>, file <code>.htaccess</code> in dir
      <code>/physical/path/to/somepath</code> containing
      <code>RewriteBase /somepath</code>)<br />
       for request ``<code>GET
      /somepath/localpath/pathinfo</code>'':</strong><br />
      </p>

      <table bgcolor="#F0F0F0" cellspacing="0" cellpadding="5">
        <tr>
          <td>
<pre>
<strong>Given Rule</strong>                                      <strong>Resulting Substitution</strong>
----------------------------------------------  ----------------------------------
^localpath(.*) otherpath$1                      /somepath/otherpath/pathinfo

^localpath(.*) otherpath$1  [R]                 http://thishost/somepath/otherpath/pathinfo
                                                via external redirection

^localpath(.*) otherpath$1  [P]                 not supported, because silly!
----------------------------------------------  ----------------------------------
^localpath(.*) /otherpath$1                     /otherpath/pathinfo

^localpath(.*) /otherpath$1 [R]                 http://thishost/otherpath/pathinfo
                                                via external redirection

^localpath(.*) /otherpath$1 [P]                 not supported, because silly!
----------------------------------------------  ----------------------------------
^localpath(.*) http://thishost/otherpath$1      /otherpath/pathinfo

^localpath(.*) http://thishost/otherpath$1 [R]  http://thishost/otherpath/pathinfo
                                                via external redirection

^localpath(.*) http://thishost/otherpath$1 [P]  not supported, because silly!
----------------------------------------------  ----------------------------------
^localpath(.*) http://otherhost/otherpath$1     http://otherhost/otherpath/pathinfo
                                                via external redirection

^localpath(.*) http://otherhost/otherpath$1 [R] http://otherhost/otherpath/pathinfo
                                                via external redirection
                                                (the [R] flag is redundant)

^localpath(.*) http://otherhost/otherpath$1 [P] http://otherhost/otherpath/pathinfo
                                                via internal proxy
</pre>
          </td>
        </tr>
      </table>

      <p><strong>Example:</strong></p>

      <blockquote>
        We want to rewrite URLs of the form 

        <blockquote>
          <code>/</code> <em>Language</em> <code>/~</code>
          <em>Realname</em> <code>/.../</code> <em>File</em>
        </blockquote>
        into 

        <blockquote>
          <code>/u/</code> <em>Username</em> <code>/.../</code>
          <em>File</em> <code>.</code> <em>Language</em>
        </blockquote>

        <p>We take the rewrite mapfile from above and save it under
        <code>/path/to/file/map.txt</code>. Then we only have to
        add the following lines to the Apache server configuration
        file:</p>

        <blockquote>
<pre>
RewriteLog   /path/to/file/rewrite.log
RewriteMap   real-to-user               txt:/path/to/file/map.txt
RewriteRule  ^/([^/]+)/~([^/]+)/(.*)$   /u/${real-to-user:$2|nobody}/$3.$1
</pre>
        </blockquote>
      </blockquote>
      <hr noshade="noshade" size="1" />

      <center>
        <h1><a id="Miscelleneous"
        name="Miscelleneous">Miscellaneous</a></h1>
      </center>
      <hr noshade="noshade" size="1" />

      <h2><a id="EnvVar" name="EnvVar">Environment
      Variables</a></h2>
      This module keeps track of two additional (non-standard)
      CGI/SSI environment variables named <code>SCRIPT_URL</code>
      and <code>SCRIPT_URI</code>. These contain the
      <em>logical</em> Web-view to the current resource, while the
      standard CGI/SSI variables <code>SCRIPT_NAME</code> and
      <code>SCRIPT_FILENAME</code> contain the <em>physical</em>
      System-view. 

      <p>Notice: These variables hold the URI/URL <em>as they were
      initially requested</em>, <em>i.e.</em>, <em>before</em> any
      rewriting. This is important because the rewriting process is
      primarily used to rewrite logical URLs to physical
      pathnames.</p>

      <p><strong>Example:</strong></p>

      <blockquote>
<pre>
SCRIPT_NAME=/sw/lib/w3s/tree/global/u/rse/.www/index.html
SCRIPT_FILENAME=/u/rse/.www/index.html
SCRIPT_URL=/u/rse/
SCRIPT_URI=http://en1.engelschall.com/u/rse/
</pre>
      </blockquote>
      <hr noshade="noshade" size="1" />

      <h2><a id="Solutions" name="Solutions">Practical
      Solutions</a></h2>
      We also have an <a href="../misc/rewriteguide.html">URL
      Rewriting Guide</a> available, which provides a collection of
      practical solutions for URL-based problems. There you can
      find real-life rulesets and additional information about
      mod_rewrite. 
    </blockquote>
        <hr />

    <h3 align="CENTER">Apache HTTP Server Version 1.3</h3>
    <a href="./"><img src="../images/index.gif" alt="Index" /></a>
    <a href="../"><img src="../images/home.gif" alt="Home" /></a>

    <!-- page indentation -->
    <!--/%hypertext -->
  </body>
</html>



@


1.14
log
@Correct the spelling of "transferred" and "transferring"

from Tobias Ulmer (tobiasu at tmux.org); ok jmc@@, krw@@
@
text
@@


1.13
log
@from tamas tevesz:
==> de-multiviewification complete.

(rename *.html.html -> *.html)
@
text
@d329 1
a329 1
      transfered for expansion. 
@


1.12
log
@this is historic as of 1.3.29
@
text
@d1 2
a1853 14

          <table width="70%" border="0" bgcolor="#E0E0F0"
          cellspacing="0" cellpadding="10">
            <tr>
              <td><font size="-1"><strong>Note - For Apache
              hackers:</strong><br />
               If the current Apache API had a filename-to-filename
              hook additionally to the URI-to-filename hook then we
              wouldn't need this flag! But without such a hook this
              flag is the only solution. The Apache Group has
              discussed this problem and will add such a hook in
              Apache version 2.0.</font> </td>
            </tr>
          </table>
d2105 2
@


1.11
log
@merge
@
text
@@


1.10
log
@merge
@
text
@d401 2
a402 1
      rel="Help"><strong>Default:</strong></a> <em>None</em><br />
d414 3
a416 2
      1.2<br />
       
d423 17
a439 9
      <ul>
        <li>'<strong><code>inherit</code></strong>'<br />
         This forces the current configuration to inherit the
        configuration of the parent. In per-virtual-server context
        this means that the maps, conditions and rules of the main
        server are inherited. In per-directory context this means
        that conditions and rules of the parent directory's
        <code>.htaccess</code> configuration are inherited.</li>
      </ul>
d475 1
a475 1
          <em>Filename</em> to <code>/dev/null</code>, because
@


1.9
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d2095 3
a2097 1
      mod_rewrite.     <hr />
a2102 1
    </blockquote>
@


1.8
log
@Apache 1.3.23+mod_ssl-2.8.6-1.3.23 merge
@
text
@d739 3
d743 4
a746 2
open(TXT, "&lt;$txtmap");
dbmopen(%DB, $dbmmap, 0644);
d748 2
a749 2
    next if (m|^s*#.*| or m|^s*$|);
    $DB{$1} = $2 if (m|^\s*(\S+)\s+(\S+)$|);
d751 3
a753 2
dbmclose(%DB);
close(TXT)
@


1.7
log
@Apache 1.3.19+mod_ssl 2.8.1 merge - also adds shared build of mod_headers
and mod_expire
@
text
@d1 2
a2 1
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
d6 485
a490 488
<HTML>
<HEAD>
<TITLE>Apache module mod_rewrite</TITLE>
</HEAD>

<!-- Background white, links blue (unvisited), navy (visited), red (active) -->
<BODY
 BGCOLOR="#FFFFFF"
 TEXT="#000000"
 LINK="#0000FF"
 VLINK="#000080"
 ALINK="#FF0000"
>
<BLOCKQUOTE><!-- page indentation -->
<DIV ALIGN="CENTER">
 <IMG SRC="../images/sub.gif" ALT="[APACHE DOCUMENTATION]">
 <H3>
  Apache HTTP Server Version 1.3
 </H3>
</DIV>


<BR>
<H1 ALIGN="CENTER">Module mod_rewrite<BR>URL Rewriting Engine</H1>

<p>This module provides a rule-based rewriting engine to rewrite requested
URLs on the fly.</p>

<P><A
HREF="module-dict.html#Status"
REL="Help"
><STRONG>Status:</STRONG></A> Extension
<BR>
<A
HREF="module-dict.html#SourceFile"
REL="Help"
><STRONG>Source File:</STRONG></A> mod_rewrite.c
<BR>
<A
HREF="module-dict.html#ModuleIdentifier"
REL="Help"
><STRONG>Module Identifier:</STRONG></A> rewrite_module
<BR>
<A
HREF="module-dict.html#Compatibility"
REL="Help"
><STRONG>Compatibility:</STRONG></A> Available in Apache 1.2 and later.
</P>


<P>
<HR NOSHADE SIZE=1>

<BR>
<H2>Summary</H2>

<BLOCKQUOTE>
<BLOCKQUOTE>
<BLOCKQUOTE>
<EM>``The great thing about mod_rewrite is it gives you all the
configurability and flexibility of Sendmail. The downside to
mod_rewrite is that it gives you all the configurability and
flexibility of Sendmail.''</EM>
<DIV ALIGN=RIGHT>
-- Brian Behlendorf<BR>
Apache Group
</DIV>
</BLOCKQUOTE>
</BLOCKQUOTE>
</BLOCKQUOTE>

<BLOCKQUOTE>
<BLOCKQUOTE>
<BLOCKQUOTE>
<EM>``
Despite the tons of examples and docs, mod_rewrite
is voodoo. Damned cool voodoo, but still voodoo.
''</EM>
<DIV ALIGN=RIGHT>
-- Brian Moore<BR>
bem@@news.cmc.net
</DIV>
</BLOCKQUOTE>
</BLOCKQUOTE>
</BLOCKQUOTE>

Welcome to mod_rewrite, the Swiss Army Knife of URL manipulation!

<P>
This module uses a rule-based rewriting engine (based on a regular-expression
parser) to rewrite requested URLs on the fly. It supports an unlimited number
of rules and an unlimited number of attached rule conditions for each rule to
provide a really flexible and powerful URL manipulation mechanism.  The URL
manipulations can depend on various tests, for instance server variables,
environment variables, HTTP headers, time stamps and even external database
lookups in various formats can be used to achieve a really granular URL
matching. 

<P>
This module operates on the full URLs (including the path-info part) both in
per-server context (<CODE>httpd.conf</CODE>) and per-directory context
(<CODE>.htaccess</CODE>) and can even generate query-string parts on result.
The rewritten result can lead to internal sub-processing, external request
redirection or even to an internal proxy throughput.

<P>
But all this functionality and flexibility has its drawback: complexity. So
don't expect to understand this entire module in just one day.

<P>
This module was invented and originally written in April 1996<BR>
and gifted exclusively to the The Apache Group in July 1997 by

<P>
<BLOCKQUOTE>
<A HREF="http://www.engelschall.com/"><CODE>Ralf S. Engelschall</CODE></A><BR>
<A HREF="mailto:rse@@engelschall.com"><CODE>rse@@engelschall.com</CODE></A><BR>
<A HREF="http://www.engelschall.com/"><CODE>www.engelschall.com</CODE></A>
</BLOCKQUOTE>

<P>
<HR NOSHADE SIZE=1>

<H2>Table Of Contents</H2>

<P>
<STRONG>Internal Processing</STRONG>
<UL>
    <LI><A HREF="#InternalAPI">API Phases</A>
    <LI><A HREF="#InternalRuleset">Ruleset Processing</A>
    <LI><A HREF="#InternalBackRefs">Regex Back-Reference Availability</A>
</UL>
<P>
<STRONG>Configuration Directives</STRONG>
<UL>
    <LI><A HREF="#RewriteEngine">RewriteEngine</A>
    <LI><A HREF="#RewriteOptions">RewriteOptions</A>
    <LI><A HREF="#RewriteLog">RewriteLog</A>
    <LI><A HREF="#RewriteLogLevel">RewriteLogLevel</A>
    <LI><A HREF="#RewriteLock">RewriteLock</A>
    <LI><A HREF="#RewriteMap">RewriteMap</A>
    <LI><A HREF="#RewriteBase">RewriteBase</A>
    <LI><A HREF="#RewriteCond">RewriteCond</A>
    <LI><A HREF="#RewriteRule">RewriteRule</A>
</UL>
<STRONG>Miscellaneous</STRONG>
<UL>
    <LI><A HREF="#EnvVar">Environment Variables</A>
    <LI><A HREF="#Solutions">Practical Solutions</A>
</UL>

<P>
<HR NOSHADE SIZE=1>

<CENTER>
<H1><A NAME="Internal">Internal Processing</A></H1>
</CENTER>

<P>
<HR NOSHADE SIZE=1>

<P>
The internal processing of this module is very complex but needs to be
explained once even to the average user to avoid common mistakes and to let
you exploit its full functionality. 

<H2><A NAME="InternalAPI">API Phases</A></H2>

<P>
First you have to understand that when Apache processes a HTTP request it does
this in phases. A hook for each of these phases is provided by the Apache API.
Mod_rewrite uses two of these hooks: the URL-to-filename translation hook
which is used after the HTTP request has been read but before any authorization
starts and the Fixup hook which is triggered after the authorization phases
and after the per-directory config files (<CODE>.htaccess</CODE>) have been 
read, but before the content handler is activated.

<P>
So, after a request comes in and Apache has determined the corresponding
server (or virtual server) the rewriting engine starts processing of all
mod_rewrite directives from the per-server configuration in the
URL-to-filename phase. A few steps later when the final data directories are
found, the per-directory configuration directives of mod_rewrite are triggered
in the Fixup phase. In both situations mod_rewrite rewrites URLs either to new
URLs or to filenames, although there is no obvious distinction between them.
This is a usage of the API which was not intended to be this way when the API
was designed, but as of Apache 1.x this is the only way mod_rewrite can
operate. To make this point more clear remember the following two points:

<OL>
<LI>Although mod_rewrite rewrites URLs to URLs, URLs to filenames and
    even filenames to filenames, the API currently provides only a
    URL-to-filename hook.  In Apache 2.0 the two missing hooks will be
    added to make the processing more clear. But this point has no
    drawbacks for the user, it is just a fact which should be
    remembered: Apache does more in the URL-to-filename hook than the
    API intends for it.
<P>
<LI>Unbelievably mod_rewrite provides URL manipulations in per-directory
    context, <EM>i.e.</EM>, within <CODE>.htaccess</CODE> files,
    although these are reached a very long time after the URLs have
    been translated to filenames.  It has to be this way because
    <CODE>.htaccess</CODE> files live in the filesystem, so processing
    has already reached this stage.  In other words: According to the
    API phases at this time it is too late for any URL manipulations.
    To overcome this chicken and egg problem mod_rewrite uses a trick:
    When you manipulate a URL/filename in per-directory context
    mod_rewrite first rewrites the filename back to its corresponding
    URL (which is usually impossible, but see the <CODE>RewriteBase</CODE>
    directive below for the trick to achieve this) and then initiates
    a new internal sub-request with the new URL. This restarts
    processing of the API phases.
    <P>
    Again mod_rewrite tries hard to make this complicated step totally
    transparent to the user, but you should remember here: While URL
    manipulations in per-server context are really fast and efficient,
    per-directory rewrites are slow and inefficient due to this chicken and
    egg problem. But on the other hand this is the only way mod_rewrite can
    provide (locally restricted) URL manipulations to the average user.
</OL>

<P>
Don't forget these two points!

<H2><A NAME="InternalRuleset">Ruleset Processing</A></H2>

Now when mod_rewrite is triggered in these two API phases, it reads the
configured rulesets from its configuration structure (which itself was either
created on startup for per-server context or during the directory walk of the
Apache kernel for per-directory context).  Then the URL rewriting engine is
started with the contained ruleset (one or more rules together with their
conditions). The operation of the URL rewriting engine itself is exactly the
same for both configuration contexts. Only the final result processing is
different.

<P>
The order of rules in the ruleset is important because the rewriting engine
processes them in a special (and not very obvious) order.  The
rule is this: The rewriting engine loops through the ruleset rule by rule
(<CODE>RewriteRule</CODE> directives) and when a particular rule matches it
optionally loops through existing corresponding conditions
(<CODE>RewriteCond</CODE> directives).  For historical reasons the conditions 
are given first, and so the control flow is a little bit long-winded. See
Figure 1 for more details.

<P>
<DIV ALIGN=CENTER>
<TABLE CELLSPACING=0 CELLPADDING=2 BORDER=0>
<TR>
<TD BGCOLOR="#CCCCCC"><IMG 
    SRC="../images/mod_rewrite_fig1.gif"
    WIDTH="428" HEIGHT="385"
    ALT="[Needs graphics capability to display]"></TD>
</TR>
<TR>
<TD ALIGN=CENTER>
<STRONG>Figure 1:</STRONG> The control flow through the rewriting ruleset
</TD>
</TR>
</TABLE>
</DIV>

<P>
As you can see, first the URL is matched against the <EM>Pattern</EM> of each
rule. When it fails mod_rewrite immediately stops processing this rule and
continues with the next rule. If the <EM>Pattern</EM> matches, mod_rewrite
looks for corresponding rule conditions. If none are present, it just
substitutes the URL with a new value which is constructed from the string
<EM>Substitution</EM> and goes on with its rule-looping. But if conditions
exist, it starts an inner loop for processing them in the order that
they are listed. For conditions the logic is different: we don't match a
pattern against the current URL. Instead we first create a string
<EM>TestString</EM> by expanding variables, back-references, map lookups,
<EM>etc.</EM> and then we try to match <EM>CondPattern</EM> against it. If the
pattern doesn't match, the complete set of conditions and the corresponding
rule fails.  If the pattern matches, then the next condition is processed
until no more conditions are available. If all conditions match, processing
is continued with the substitution of the URL with <EM>Substitution</EM>.

<H2><A NAME="InternalBackRefs">Regex Back-Reference Availability</A></H2>

One important thing here has to be remembered: Whenever you
use parentheses in <EM>Pattern</EM> or in one of the <EM>CondPattern</EM>,
back-references are internally created which can be used with the
strings <CODE>$N</CODE> and <CODE>%N</CODE> (see below). These
are available for creating the strings <EM>Substitution</EM> and
<EM>TestString</EM>. Figure 2 shows to which locations the back-references are
transfered for expansion.

<P>
<DIV ALIGN=CENTER>
<TABLE  CELLSPACING=0 CELLPADDING=2 BORDER=0>
<TR>
<TD BGCOLOR="#CCCCCC"><IMG 
    SRC="../images/mod_rewrite_fig2.gif"
    WIDTH="381" HEIGHT="179"
    ALT="[Needs graphics capability to display]"></TD>
</TR>
<TR>
<TD ALIGN=CENTER>
<STRONG>Figure 2:</STRONG> The back-reference flow through a rule
</TD>
</TR>
</TABLE>
</DIV>

<P>
We know this was a crash course on mod_rewrite's internal processing.  But
you will benefit from this knowledge when reading the following documentation
of the available directives.

<P>
<HR NOSHADE SIZE=1>

<CENTER>
<H1><A NAME="Configuration">Configuration Directives</A></H1>
</CENTER>

<P>
<HR NOSHADE SIZE=1>

<H3><A NAME="RewriteEngine">RewriteEngine</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A>
    RewriteEngine on|off<BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A>
    <CODE>RewriteEngine off</CODE><BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A>
    server config, virtual host, directory, .htaccess<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> FileInfo<BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2<BR>

<P>
The <CODE>RewriteEngine</CODE> directive enables or disables the runtime
rewriting engine. If it is set to <CODE>off</CODE> this module does no runtime
processing at all. It does not even update the <CODE>SCRIPT_URx</CODE>
environment variables.

<P>
Use this directive to disable the module instead of commenting out
all the <CODE>RewriteRule</CODE> directives!

<P>
Note that, by default, rewrite configurations are not inherited.
This means that you need to have a <CODE>RewriteEngine on</CODE>
directive for each virtual host in which you wish to use it.

<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteOptions">RewriteOptions</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> RewriteOptions <EM>Option</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> <EM>None</EM><BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> server config, virtual host, directory,
    .htaccess<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> FileInfo<BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2<BR>

<P>
The <CODE>RewriteOptions</CODE> directive sets some special options for the
current per-server or per-directory configuration. The <EM>Option</EM>
strings can be one of the following:

<UL>
<LI>'<STRONG><CODE>inherit</CODE></STRONG>'<BR>
    This forces the current configuration to inherit the configuration of the
    parent. In per-virtual-server context this means that the maps,
    conditions and rules of the main server are inherited. In per-directory
    context this means that conditions and rules of the parent directory's
    <CODE>.htaccess</CODE> configuration are inherited.
</UL>

<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteLog">RewriteLog</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> RewriteLog <EM>Filename</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> <EM>None</EM><BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> server config, virtual host<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> <EM>Not applicable</EM><BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2<BR>

<P>
The <CODE>RewriteLog</CODE> directive sets the name of the file to which the
server logs any rewriting actions it performs. If the name does not begin
with a slash ('<CODE>/</CODE>') then it is assumed to be relative to the
<EM>Server Root</EM>.  The directive should occur only once per server
config.

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Note</STRONG>: To disable the logging of rewriting actions it is
not recommended to set <EM>Filename</EM>
to <CODE>/dev/null</CODE>, because although the rewriting engine does
not then output to a logfile it still creates the logfile
output internally. <STRONG>This will slow down the server with no advantage
to the administrator!</STRONG>
To disable logging either remove or comment out the
<CODE>RewriteLog</CODE> directive or use <CODE>RewriteLogLevel 0</CODE>!
</TD></TR>
</TABLE>

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Security</STRONG>: See the <A
HREF="../misc/security_tips.html">Apache Security
Tips</A> document for details on why your security could be compromised if the
directory where logfiles are stored is writable by anyone other than the user
that starts the server.
</TD></TR>
</TABLE>

<P>
<STRONG>Example:</STRONG>
<BLOCKQUOTE>
<PRE>
d492 47
a538 2
</PRE>
</BLOCKQUOTE>
d540 2
a541 59
<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteLogLevel">RewriteLogLevel</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> RewriteLogLevel <EM>Level</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> <CODE>RewriteLogLevel 0</CODE>
<BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> server config, virtual host<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> <EM>Not applicable</EM><BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2<BR>

<P>
The <CODE>RewriteLogLevel</CODE> directive sets the verbosity level of the
rewriting
logfile.  The default level 0 means no logging, while 9 or more means
that practically all actions are logged.

<P>
To disable the logging of rewriting actions simply set <EM>Level</EM> to 0.
This disables all rewrite action logs.

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice:</STRONG> Using a high value for <EM>Level</EM> will slow down
your Apache server dramatically! Use the rewriting logfile at
a <EM>Level</EM> greater than 2 only for debugging!
</TD></TR>
</TABLE>


<P>
<STRONG>Example:</STRONG>
<BLOCKQUOTE>
<PRE>
d543 107
a649 125
</PRE>
</BLOCKQUOTE>

<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteLock">RewriteLock</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> RewriteLock <EM>Filename</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> <EM>None</EM><BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> server config<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> <EM>Not applicable</EM><BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.3<BR>

<P>
This directive sets the filename for a synchronization lockfile which
mod_rewrite needs to communicate with <SAMP>RewriteMap</SAMP>
<EM>programs</EM>. Set this lockfile to a local path (not on a NFS-mounted
device) when you want to use a rewriting map-program. It is not required for
other types of rewriting maps.

<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteMap">RewriteMap</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> RewriteMap <EM>MapName </EM>
    <EM>MapType</EM>:<EM>MapSource</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> not used per default<BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> server config, virtual host<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> <EM>Not applicable</EM><BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2 (partially), Apache 1.3<BR>

<P>
The <CODE>RewriteMap</CODE> directive defines a <EM>Rewriting Map</EM>
which can be used inside rule substitution strings by the mapping-functions
to insert/substitute fields through a key lookup. The source of this
lookup can be of various types.
<P>

The <A NAME="mapfunc"><EM>MapName</EM></A> is the name of the map and will
be used to specify a mapping-function for the substitution strings of a
rewriting rule via one of the following constructs:

<BLOCKQUOTE><STRONG>
<CODE>${</CODE> <EM>MapName</EM> <CODE>:</CODE> <EM>LookupKey</EM>
<CODE>}</CODE><BR>
<CODE>${</CODE> <EM>MapName</EM> <CODE>:</CODE> <EM>LookupKey</EM>
<CODE>|</CODE> <EM>DefaultValue</EM> <CODE>}</CODE>
</STRONG></BLOCKQUOTE>

When such a construct occurs the map <EM>MapName</EM>
is consulted and the key <EM>LookupKey</EM> is looked-up. If the key is
found, the map-function construct is substituted by <EM>SubstValue</EM>. If
the key is not found then it is substituted by <EM>DefaultValue</EM> or
by the empty string if no <EM>DefaultValue</EM> was specified.

<P>
The following combinations for <EM>MapType</EM> and <EM>MapSource</EM>
can be used:

<UL>
<LI><STRONG>Standard Plain Text</STRONG><BR>
    MapType: <CODE>txt</CODE>, MapSource: Unix filesystem path to valid regular
    file
    <P>
    This is the standard rewriting map feature where the <EM>MapSource</EM> is
    a plain ASCII file containing either blank lines, comment lines (starting
    with a '#' character) or pairs like the following - one per line.

    <BLOCKQUOTE><STRONG>
    <EM>MatchingKey</EM>  <EM>SubstValue</EM>
    </STRONG></BLOCKQUOTE>

    <P>
    Example:
<P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
<TR><TD><PRE>
d656 10
a665 6
</PRE></TD></TR>
</TABLE>

<P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
<TR><TD><PRE>
d667 27
a693 22
</PRE></TD></TR>
</TABLE>

<P>
<LI><STRONG>Randomized Plain Text</STRONG><BR>
    MapType: <CODE>rnd</CODE>, MapSource: Unix filesystem path to valid regular
    file
    <P>
    This is identical to the Standard Plain Text variant above but with a
    special
    post-processing feature: After looking up a value it is parsed according
    to contained ``<CODE>|</CODE>'' characters which have the meaning of
    ``or''.
    In other words they indicate a set of alternatives from which the actual
    returned value is chosen randomly. Although this sounds crazy and useless,
    it
    was actually designed for load balancing in a reverse proxy situation where
    the looked up values are server names.
    Example:
<P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
<TR><TD><PRE>
d700 10
a709 6
</PRE></TD></TR>
</TABLE>

<P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
<TR><TD><PRE>
d711 23
a733 15
</PRE></TD></TR>
</TABLE>

<P>
<LI><STRONG>Hash File</STRONG><BR>
    MapType: <CODE>dbm</CODE>, MapSource: Unix filesystem path to valid
    regular file
    <P>
    Here the source is a binary NDBM format file containing the same contents
    as a <EM>Plain Text</EM> format file, but in a special representation
    which is optimized for really fast lookups. You can create such a file with
    any NDBM tool or with the following Perl script:
    <P>
    <TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
    <TR><TD><PRE>
d747 74
a820 46
close(TXT)</PRE></TD></TR>
    </TABLE>
    <P>
    <TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
    <TR><TD><PRE>$ txt2dbm map.txt map.db </PRE></TD></TR>
    </TABLE>
<P>
<LI><STRONG>Internal Function</STRONG><BR>
    MapType: <CODE>int</CODE>, MapSource: Internal Apache function
    <P>
    Here the source is an internal Apache function. Currently you cannot
    create your own, but the following functions already exists:
    <UL> 
    <LI><STRONG>toupper</STRONG>:<BR>
        Converts the looked up key to all upper case.
    <LI><STRONG>tolower</STRONG>:<BR>
        Converts the looked up key to all lower case.
    <LI><STRONG>escape</STRONG>:<BR>
        Translates special characters in the looked up key to hex-encodings.
    <LI><STRONG>unescape</STRONG>:<BR>
        Translates hex-encodings in the looked up key back to special characters.
    </UL>
<P>
<LI><STRONG>External Rewriting Program</STRONG><BR>
    MapType: <CODE>prg</CODE>, MapSource: Unix filesystem path to valid
    regular file
    <P>
    Here the source is a program, not a map file. To create it you
    can use the language of your choice, but the result has to be a
    executable (<EM>i.e.</EM>, either object-code or a script with the
    magic cookie trick '<CODE>#!/path/to/interpreter</CODE>' as the
    first line).
    <P>
    This program is started once at startup of the Apache servers and then
    communicates with the rewriting engine over its <CODE>stdin</CODE> and
    <CODE>stdout</CODE> file-handles.  For each map-function lookup it will
    receive the key to lookup as a newline-terminated string on
    <CODE>stdin</CODE>. It then has to give back the looked-up value as a
    newline-terminated string on <CODE>stdout</CODE> or the four-character
    string ``<CODE>NULL</CODE>'' if it fails (<EM>i.e.</EM>, there is no
    corresponding value
    for the given key). A trivial program which will implement a 1:1 map
    (<EM>i.e.</EM>, key == value) could be:
    <P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
<TR><TD><PRE>
d827 108
a934 107
</PRE></TD></TR>
</TABLE>
    <P>
    But be very careful:<BR>
    <OL>
    <LI>``<EM>Keep it simple, stupid</EM>'' (KISS), because
        if this program hangs it will hang the Apache server
        when the rule occurs.
    <LI>Avoid one common mistake: never do buffered I/O on <CODE>stdout</CODE>!
        This will cause a deadloop! Hence the ``<CODE>$|=1</CODE>'' in the
        above example...
    <LI>Use the <SAMP>RewriteLock</SAMP> directive to define a lockfile
        mod_rewrite can use to synchronize the communication to the program.
        By default no such synchronization takes place.
    </OL>
</UL>

The <CODE>RewriteMap</CODE> directive can occur more than once. For each
mapping-function use one <CODE>RewriteMap</CODE> directive to declare its
rewriting mapfile. While you cannot <STRONG>declare</STRONG> a map in
per-directory context it is of course possible to <STRONG>use</STRONG>
this map in per-directory context.

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Note:</STRONG> For plain text and DBM format files the looked-up
keys are cached in-core
until the <CODE>mtime</CODE> of the mapfile changes or the server does a
restart. This way you can have map-functions in rules which are used
for <STRONG>every</STRONG> request. This is no problem, because the
external lookup only happens once!
</TD></TR>
</TABLE>

<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteBase">RewriteBase</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> RewriteBase <EM>BaseURL</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> <EM>default is the physical directory path</EM>
<BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> directory, .htaccess<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> <EM>FileInfo</EM><BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2<BR>

<P>
The <CODE>RewriteBase</CODE> directive explicitly sets the base URL for
per-directory rewrites. As you will see below, <CODE>RewriteRule</CODE> can be
used in per-directory config files (<CODE>.htaccess</CODE>). There it will act
locally, <EM>i.e.</EM>, the local directory prefix is stripped at this stage of
processing and your rewriting rules act only on the remainder. At the end
it is automatically added back to the path.

<P>
When a substitution occurs for a new URL, this module has to re-inject the URL
into the server processing. To be able to do this it needs to know what the
corresponding URL-prefix or URL-base is. By default this prefix is the
corresponding filepath itself. <STRONG>But at most websites URLs are
NOT directly related to physical filename paths, so this
assumption will usually be wrong!</STRONG> There you have to use the
<CODE>RewriteBase</CODE> directive to specify the correct URL-prefix.

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice:</STRONG> If your webserver's URLs are <STRONG>not</STRONG>
directly related to physical file paths, you have to use
<CODE>RewriteBase</CODE> in every
<CODE>.htaccess</CODE> files where you want to use <CODE>RewriteRule</CODE>
directives.
</TD></TR>
</TABLE>

<P>
<STRONG>Example:</STRONG>

<BLOCKQUOTE>
   Assume the following per-directory config file:

<P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
<TR><TD><PRE>
d937 2
a938 2
#  Remember: /abc/def is the physical path of /xyz, <EM>i.e.</EM>, the server
#            has a 'Alias /xyz /abc/def' directive <EM>e.g.</EM>
d949 19
a967 19
</PRE></TD></TR>
</TABLE>

<P>
In the above example, a request to <CODE>/xyz/oldstuff.html</CODE>
gets correctly
rewritten to the physical file <CODE>/abc/def/newstuff.html</CODE>.

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<FONT SIZE=-1>
<STRONG>Note - For Apache hackers:</STRONG><BR>
The following list gives detailed information about the internal
processing steps:

<P>
<PRE>
Request:
d978 399
a1376 1
</PRE>
d1378 2
a1379 340
This seems very complicated but is the correct Apache internal processing,
because the per-directory rewriting comes too late in the process.  So,
when it occurs the (rewritten) request has to be re-injected into the Apache
kernel! BUT: While this seems like a serious overhead, it really isn't, because
this re-injection happens fully internally to the Apache server and the same
procedure is used by many other operations inside Apache. So, you can be
sure the design and implementation is correct.
</FONT>
</TD></TR>
</TABLE>

</BLOCKQUOTE>


<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteCond">RewriteCond</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> RewriteCond <EM>TestString</EM>
    <EM>CondPattern</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> <EM>None</EM><BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> server config, virtual host, directory,
     .htaccess<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> <EM>FileInfo</EM><BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2 (partially), Apache 1.3<BR>

<P>
The <CODE>RewriteCond</CODE> directive defines a rule condition. Precede a
<CODE>RewriteRule</CODE> directive with one or more <CODE>RewriteCond</CODE>
directives.

The following rewriting rule is only used if its pattern matches the current
state of the URI <STRONG>and</STRONG> if these additional conditions apply
too.

<P>
<EM>TestString</EM> is a string which can contains the following
expanded constructs in addition to plain text:

<UL>
<LI><STRONG>RewriteRule backreferences</STRONG>: These are backreferences of
    the form

<BLOCKQUOTE><STRONG>
<CODE>$N</CODE>
</STRONG></BLOCKQUOTE>

(0 &lt;= N &lt;= 9) which provide access to the grouped parts (parenthesis!)
of the pattern from the corresponding <CODE>RewriteRule</CODE> directive (the
one following the current bunch of <CODE>RewriteCond</CODE> directives).

<P>
<LI><STRONG>RewriteCond backreferences</STRONG>: These are backreferences of
the form

<BLOCKQUOTE><STRONG>
<CODE>%N</CODE>
</STRONG></BLOCKQUOTE>

(1 &lt;= N &lt;= 9) which provide access to the grouped parts (parentheses!) of
the pattern from the last matched <CODE>RewriteCond</CODE> directive in the
current bunch of conditions.

<P>
<LI><STRONG>RewriteMap expansions</STRONG>: These are expansions of the form

<BLOCKQUOTE><STRONG>
<CODE>${mapname:key|default}</CODE>
</STRONG></BLOCKQUOTE>

See <A HREF="#mapfunc">the documentation for RewriteMap</A> for more details.

<P>
<LI><STRONG>Server-Variables</STRONG>: These are variables
    of the form

<BLOCKQUOTE><STRONG>
<CODE>%{</CODE> <EM>NAME_OF_VARIABLE</EM> <CODE>}</CODE>
</STRONG></BLOCKQUOTE>

where <EM>NAME_OF_VARIABLE</EM> can be a string
taken from the following list:

<P>
<TABLE BGCOLOR="#F0F0F0" CELLSPACING=0 CELLPADDING=5>
<TR>
<TD VALIGN=TOP>
<STRONG>HTTP headers:</STRONG><P>
<FONT SIZE=-1>
HTTP_USER_AGENT<BR>
HTTP_REFERER<BR>
HTTP_COOKIE<BR>
HTTP_FORWARDED<BR>
HTTP_HOST<BR>
HTTP_PROXY_CONNECTION<BR>
HTTP_ACCEPT<BR>
</FONT>
</TD>

<TD VALIGN=TOP>
<STRONG>connection &amp; request:</STRONG><P>
<FONT SIZE=-1>
REMOTE_ADDR<BR>
REMOTE_HOST<BR>
REMOTE_USER<BR>
REMOTE_IDENT<BR>
REQUEST_METHOD<BR>
SCRIPT_FILENAME<BR>
PATH_INFO<BR>
QUERY_STRING<BR>
AUTH_TYPE<BR>
</FONT>
</TD>

</TR>
<TR>

<TD VALIGN=TOP>
<STRONG>server internals:</STRONG><P>
<FONT SIZE=-1>
DOCUMENT_ROOT<BR>
SERVER_ADMIN<BR>
SERVER_NAME<BR>
SERVER_ADDR<BR>
SERVER_PORT<BR>
SERVER_PROTOCOL<BR>
SERVER_SOFTWARE<BR>
</FONT>
</TD>

<TD VALIGN=TOP>
<STRONG>system stuff:</STRONG><P>
<FONT SIZE=-1>
TIME_YEAR<BR>
TIME_MON<BR>
TIME_DAY<BR>
TIME_HOUR<BR>
TIME_MIN<BR>
TIME_SEC<BR>
TIME_WDAY<BR>
TIME<BR>
</FONT>
</TD>

<TD VALIGN=TOP>
<STRONG>specials:</STRONG><P>
<FONT SIZE=-1>
API_VERSION<BR>
THE_REQUEST<BR>
REQUEST_URI<BR>
REQUEST_FILENAME<BR>
IS_SUBREQ<BR>
</FONT>
</TD>
</TR>
</TABLE>

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice:</STRONG> These variables all correspond to the similarly named
HTTP MIME-headers, C variables of the Apache server or <CODE>struct tm</CODE>
fields of the Unix system.
</TD></TR>
</TABLE>

</UL>

<P>
Special Notes:

<OL>
<LI>The variables SCRIPT_FILENAME and REQUEST_FILENAME contain the same
value, <EM>i.e.</EM>, the value of the <CODE>filename</CODE> field of
the internal
<CODE>request_rec</CODE> structure of the Apache server. The first name is
just the
commonly known CGI variable name while the second is the consistent
counterpart to REQUEST_URI (which contains the value of the <CODE>uri</CODE>
field of <CODE>request_rec</CODE>).

<P>
<LI>There is the special format: <CODE>%{ENV:variable}</CODE> where
<EM>variable</EM> can be any environment variable. This is looked-up via
internal Apache structures and (if not found there) via <CODE>getenv()</CODE>
from the Apache server process.

<P>
<LI>There is the special format: <CODE>%{HTTP:header}</CODE> where
<EM>header</EM> can be any HTTP MIME-header name. This is looked-up
from the HTTP request. Example: <CODE>%{HTTP:Proxy-Connection}</CODE>
is the value of the HTTP header ``<CODE>Proxy-Connection:</CODE>''.

<P>
<LI>There is the special format <CODE>%{LA-U:variable}</CODE> for look-aheads
which perform an internal (URL-based) sub-request to determine the final value
of <EM>variable</EM>. Use this when you want to use a variable for rewriting
which is actually set later in an API phase and thus is not available at the
current stage. For instance when you want to rewrite according to the
<CODE>REMOTE_USER</CODE> variable from within the per-server context
(<CODE>httpd.conf</CODE> file) you have to use <CODE>%{LA-U:REMOTE_USER}</CODE>
because this variable is set by the authorization phases which come
<EM>after</EM> the URL translation phase where mod_rewrite operates. On the
other hand, because mod_rewrite implements its per-directory context
(<CODE>.htaccess</CODE> file) via the Fixup phase of the API and because the
authorization phases come <EM>before</EM> this phase, you just can use
<CODE>%{REMOTE_USER}</CODE> there.

<P>
<LI>There is the special format: <CODE>%{LA-F:variable}</CODE> which performs an
internal (filename-based) sub-request to determine the final value of
<EM>variable</EM>. Most of the time this is the same as LA-U above.
</OL>

<P>
<EM>CondPattern</EM> is the condition pattern, <EM>i.e.</EM>, a regular
expression
which is applied to the current instance of the <EM>TestString</EM>,
<EM>i.e.</EM>, <EM>TestString</EM> is evaluated and then matched against
<EM>CondPattern</EM>.

<P>
<STRONG>Remember:</STRONG> <EM>CondPattern</EM> is a standard
<EM>Extended Regular Expression</EM> with some additions:

<OL>
<LI>You can prefix the pattern string with a '<CODE>!</CODE>' character
(exclamation mark) to specify a <STRONG>non</STRONG>-matching pattern.

<P>
<LI>
There are some special variants of <EM>CondPatterns</EM>. Instead of real
regular expression strings you can also use one of the following:
<P>
<UL>
<LI>'<STRONG>&lt;CondPattern</STRONG>' (is lexically lower)<BR>
Treats the <EM>CondPattern</EM> as a plain string and compares it
lexically to <EM>TestString</EM>. True if
<EM>TestString</EM> is lexically lower than <EM>CondPattern</EM>.
<P>
<LI>'<STRONG>&gt;CondPattern</STRONG>' (is lexically greater)<BR>
Treats the <EM>CondPattern</EM> as a plain string and compares it
lexically to <EM>TestString</EM>. True if
<EM>TestString</EM> is lexically greater than <EM>CondPattern</EM>.
<P>
<LI>'<STRONG>=CondPattern</STRONG>' (is lexically equal)<BR>
Treats the <EM>CondPattern</EM> as a plain string and compares it
lexically to <EM>TestString</EM>. True if
<EM>TestString</EM> is lexically equal to <EM>CondPattern</EM>, i.e the
two strings are exactly equal (character by character).
If <EM>CondPattern</EM> is just <SAMP>""</SAMP> (two quotation marks) this
compares <EM>TestString</EM> to the empty string.
<P>
<LI>'<STRONG>-d</STRONG>' (is <STRONG>d</STRONG>irectory)<BR>
Treats the <EM>TestString</EM> as a pathname and
tests if it exists and is a directory.
<P>
<LI>'<STRONG>-f</STRONG>' (is regular <STRONG>f</STRONG>ile)<BR>
Treats the <EM>TestString</EM> as a pathname and
tests if it exists and is a regular file.
<P>
<LI>'<STRONG>-s</STRONG>' (is regular file with <STRONG>s</STRONG>ize)<BR>
Treats the <EM>TestString</EM> as a pathname and
tests if it exists and is a regular file with size greater than zero.
<P>
<LI>'<STRONG>-l</STRONG>' (is symbolic <STRONG>l</STRONG>ink)<BR>
Treats the <EM>TestString</EM> as a pathname and
tests if it exists and is a symbolic link.
<P>
<LI>'<STRONG>-F</STRONG>' (is existing file via subrequest)<BR>
Checks if <EM>TestString</EM> is a valid file and accessible via all the
server's currently-configured access controls for that path.  This uses an
internal subrequest to determine the check, so use it with care because it
decreases your servers performance!
<P>
<LI>'<STRONG>-U</STRONG>' (is existing URL via subrequest)<BR>
Checks if <EM>TestString</EM> is a valid URL and accessible via all the
server's
currently-configured access controls for that path.  This uses an internal
subrequest to determine the check, so use it with care because it decreases
your server's performance!
</UL>
<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice:</STRONG>
All of these tests can also be prefixed by an exclamation mark ('!')
to negate their meaning.
</TD></TR>
</TABLE>
</OL>

<P>
Additionally you can set special flags for <EM>CondPattern</EM> by appending

<BLOCKQUOTE><STRONG>
<CODE>[</CODE><EM>flags</EM><CODE>]</CODE>
</STRONG></BLOCKQUOTE>

as the third argument to the <CODE>RewriteCond</CODE> directive. <EM>Flags</EM>
is a comma-separated list of the following flags:

<UL>
<LI>'<STRONG><CODE>nocase|NC</CODE></STRONG>' (<STRONG>n</STRONG>o <STRONG>c</STRONG>ase)<BR>
    This makes the test case-insensitive, <EM>i.e.</EM>, there is
    no difference between 'A-Z' and 'a-z' both in the expanded
    <EM>TestString</EM> and the <EM>CondPattern</EM>.
    This flag is effective only for comparisons between
    <EM>TestString</EM> and <EM>CondPattern</EM>.  It has no
    effect on filesystem and subrequest checks.
<P>
<LI>'<STRONG><CODE>ornext|OR</CODE></STRONG>' (<STRONG>or</STRONG> next condition)<BR>
    Use this to combine rule conditions with a local OR instead of the
    implicit AND. Typical example:
    <P>
<BLOCKQUOTE><PRE>
d1384 13
a1396 7
</PRE></BLOCKQUOTE>
    Without this flag you would have to write the cond/rule three times.
</UL>

<P>
<STRONG>Example:</STRONG>
<BLOCKQUOTE>
d1398 2
a1399 4
To rewrite the Homepage of a site according to the ``<CODE>User-Agent:</CODE>''
header of the request, you can use the following:

<BLOCKQUOTE><PRE>
d1407 66
a1472 77
</PRE></BLOCKQUOTE>

Interpretation: If you use Netscape Navigator as your browser (which identifies
itself as 'Mozilla'), then you get the max homepage, which includes
Frames, <EM>etc.</EM> If you use the Lynx browser (which is Terminal-based), then you
get the min homepage, which contains no images, no tables, <EM>etc.</EM>  If you
use any other browser you get the standard homepage.
</BLOCKQUOTE>

<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteRule">RewriteRule</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> RewriteRule <EM>Pattern</EM> <EM>Substitution</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> <EM>None</EM><BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> server config, virtual host, directory, .htaccess<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> <EM>FileInfo</EM><BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2 (partially), Apache 1.3<BR>

<P>
The <CODE>RewriteRule</CODE> directive is the real rewriting workhorse.  The
directive can occur more than once. Each directive then defines one single
rewriting rule.  The <STRONG>definition order</STRONG> of these rules is
<STRONG>important</STRONG>, because this order is used when applying the rules at
run-time.

<P>
<A NAME="patterns"><EM>Pattern</EM></A> can be (for Apache
1.1.x a System V8 and for Apache 1.2.x and later a POSIX) <A
NAME="regexp">regular expression</A> which gets applied to the current
URL. Here ``current'' means the value of the URL when this rule gets
applied. This may not be the originally requested URL, because no
longer existingany number of rules may already have matched and made
alterations to it.

<P>
Some hints about the syntax of regular expressions:

<P>
<TABLE BGCOLOR="#F0F0F0" CELLSPACING=0 CELLPADDING=5>
<TR>
<TD VALIGN=TOP>
<PRE>
<STRONG>Text:</STRONG>
  <STRONG><CODE>.</CODE></STRONG>           Any single character
  <STRONG><CODE>[</CODE></STRONG>chars<STRONG><CODE>]</CODE></STRONG>     Character class: One  of chars
  <STRONG><CODE>[^</CODE></STRONG>chars<STRONG><CODE>]</CODE></STRONG>    Character class: None of chars
  text1<STRONG><CODE>|</CODE></STRONG>text2 Alternative: text1 or text2

<STRONG>Quantifiers:</STRONG>
  <STRONG><CODE>?</CODE></STRONG>           0 or 1 of the preceding text
  <STRONG><CODE>*</CODE></STRONG>           0 or N of the preceding text (N &gt; 0)
  <STRONG><CODE>+</CODE></STRONG>           1 or N of the preceding text (N &gt; 1)
d1474 2
a1475 2
<STRONG>Grouping:</STRONG>
  <STRONG><CODE>(</CODE></STRONG>text<STRONG><CODE>)</CODE></STRONG>      Grouping of text
d1477 2
a1478 2
              for making backreferences where the <STRONG>N</STRONG>th group can 
              be used on the RHS of a RewriteRule with <CODE>$</CODE><STRONG>N</STRONG>)
d1480 339
a1818 240
<STRONG>Anchors:</STRONG>
  <STRONG><CODE>^</CODE></STRONG>           Start of line anchor
  <STRONG><CODE>$</CODE></STRONG>           End   of line anchor

<STRONG>Escaping:</STRONG>
  <STRONG><CODE>\</CODE></STRONG>char       escape that particular char
              (for instance to specify the chars "<CODE>.[]()</CODE>" <EM>etc.</EM>)
</PRE>
</TD>
</TR>
</TABLE>

<P>
For more information about regular expressions either have a look at your
local regex(3) manpage or its <CODE>src/regex/regex.3</CODE> copy in the
Apache 1.3 distribution.  If you are interested in more detailed
information about regular expressions and their variants (POSIX regex, Perl
regex, <EM>etc.</EM>) have a look at the following dedicated book on this topic: 

<BLOCKQUOTE>
<EM>Mastering Regular Expressions</EM><BR>
Jeffrey E.F. Friedl<BR>
Nutshell Handbook Series<BR>
O'Reilly &amp; Associates, Inc. 1997<BR>
ISBN 1-56592-257-3<BR>
</BLOCKQUOTE>

<P>
Additionally in mod_rewrite the NOT character ('<CODE>!</CODE>') is a possible
pattern prefix. This gives you the ability to negate a pattern; to say, for
instance: ``<EM>if the current URL does <STRONG>NOT</STRONG> match this
pattern</EM>''. This can be used for exceptional cases, where it is easier to
match the negative pattern, or as a last default rule.

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice:</STRONG> When using the NOT character to negate a pattern you cannot
have grouped wildcard parts in the pattern. This is impossible because when
the pattern does NOT match, there are no contents for the groups. In
consequence, if negated patterns are used, you cannot use <CODE>$N</CODE> in the
substitution string!
</TD></TR>
</TABLE>

<P>
<A NAME="rhs"><EM>Substitution</EM></A> of a rewriting rule is the string
which is substituted for (or replaces) the original URL for which
<EM>Pattern</EM> matched.  Beside plain text you can use

<OL>
<LI>back-references <CODE>$N</CODE> to the RewriteRule pattern
<LI>back-references <CODE>%N</CODE> to the last matched RewriteCond pattern
<LI>server-variables as in rule condition test-strings (<CODE>%{VARNAME}</CODE>)
<LI><A HREF="#mapfunc">mapping-function</A> calls (<CODE>${mapname:key|default}</CODE>)
</OL>

Back-references are <CODE>$</CODE><STRONG>N</STRONG> (<STRONG>N</STRONG>=0..9) identifiers which
will be replaced by the contents of the <STRONG>N</STRONG>th group of the matched
<EM>Pattern</EM>. The server-variables are the same as for the
<EM>TestString</EM> of a <CODE>RewriteCond</CODE> directive. The
mapping-functions come from the <CODE>RewriteMap</CODE> directive and are
explained there. These three types of variables are expanded in the order of
the above list.

<P>
As already mentioned above, all the rewriting rules are applied to the
<EM>Substitution</EM> (in the order of definition in the config file).  The
URL is <STRONG>completely replaced</STRONG> by the <EM>Substitution</EM> and the
rewriting process goes on until there are no more rules unless explicitly
terminated by a <CODE><STRONG>L</STRONG></CODE> flag - see below.

<P>
There is a special substitution string named '<CODE>-</CODE>' which means:
<STRONG>NO substitution</STRONG>! Sounds silly? No, it is useful to provide rewriting
rules which <STRONG>only</STRONG> match some URLs but do no substitution, <EM>e.g.</EM>, in
conjunction with the <STRONG>C</STRONG> (chain) flag to be able to have more than one
pattern to be applied before a substitution occurs.

<P>
One more note: You can even create URLs in the substitution string containing
a query string part. Just use a question mark inside the substitution string
to indicate that the following stuff should be re-injected into the
QUERY_STRING.  When you want to erase an existing query string, end the
substitution string with just the question mark.

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Note</STRONG>: There is a special feature: When you prefix a substitution
field with <CODE>http://</CODE><EM>thishost</EM>[<EM>:thisport</EM>] then
<STRONG>mod_rewrite</STRONG> automatically strips it out.   This auto-reduction on
implicit external redirect URLs is a useful and important feature when
used in combination with a mapping-function which generates the hostname
part.  Have a look at the first example in the example section below to
understand this.
</TD></TR>
</TABLE>

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Remember:</STRONG> An unconditional external redirect to your own server will
not work with the prefix <CODE>http://thishost</CODE> because of this feature.
To achieve such a self-redirect, you have to use the <STRONG>R</STRONG>-flag (see
below).
</TD></TR>
</TABLE>

<P>
Additionally you can set special flags for <EM>Substitution</EM> by appending

<BLOCKQUOTE><STRONG>
<CODE>[</CODE><EM>flags</EM><CODE>]</CODE>
</STRONG></BLOCKQUOTE>

as the third argument to the <CODE>RewriteRule</CODE> directive. <EM>Flags</EM> is a
comma-separated list of the following flags:

<UL>
<LI>'<STRONG><CODE>redirect|R</CODE> [=<EM>code</EM>]</STRONG>' (force <A NAME="redirect"><STRONG>r</STRONG>edirect</A>)<BR>
    Prefix <EM>Substitution</EM>
    with <CODE>http://thishost[:thisport]/</CODE> (which makes the new URL a URI) to
    force a external redirection. If no <EM>code</EM> is given a HTTP response
    of 302 (MOVED TEMPORARILY) is used. If you want to use other response
    codes in the range 300-400 just specify them as a number or use
    one of the following symbolic names: <CODE>temp</CODE> (default), <CODE>permanent</CODE>,
    <CODE>seeother</CODE>.
    Use it for rules which should
    canonicalize the URL and give it back to the client, <EM>e.g.</EM>, translate
    ``<CODE>/~</CODE>'' into ``<CODE>/u/</CODE>'' or always append a slash to
    <CODE>/u/</CODE><EM>user</EM>, etc.<BR>
    <P>
    <STRONG>Note:</STRONG> When you use this flag, make sure that the
    substitution field is a valid URL! If not, you are redirecting to an
    invalid location!  And remember that this flag itself only prefixes the
    URL with <CODE>http://thishost[:thisport]/</CODE>, rewriting continues.
    Usually you also want to stop and do the redirection immediately.  To stop
    the rewriting you also have to provide the 'L' flag.
<P>
<LI>'<STRONG><CODE>forbidden|F</CODE></STRONG>' (force URL to be <STRONG>f</STRONG>orbidden)<BR>
    This forces the current URL to be forbidden, <EM>i.e.</EM>, it immediately sends
    back a HTTP response of 403 (FORBIDDEN). Use this flag in conjunction with
    appropriate RewriteConds to conditionally block some URLs.
<P>
<LI>'<STRONG><CODE>gone|G</CODE></STRONG>' (force URL to be <STRONG>g</STRONG>one)<BR>
    This forces the current URL to be gone, <EM>i.e.</EM>, it immediately sends back a
    HTTP response of 410 (GONE). Use this flag to mark pages which no longer
    exist as gone.
<P>
<LI>'<STRONG><CODE>proxy|P</CODE></STRONG>' (force <STRONG>p</STRONG>roxy)<BR>
    This flag forces the substitution part to be internally forced as a proxy
    request and immediately (<EM>i.e.</EM>, rewriting rule processing stops here) put
    through the <A HREF="mod_proxy.html">proxy module</A>. You have to make
    sure that the substitution string is a valid URI (<EM>e.g.</EM>,  typically starting
    with <CODE>http://</CODE><EM>hostname</EM>) which can be handled by the
    Apache proxy module. If not you get an error from the proxy module. Use
    this flag to achieve a more powerful implementation of the <A
    HREF="mod_proxy.html#proxypass">ProxyPass</A> directive, to map some
    remote stuff into the namespace of the local server.
    <P>
    Notice: To use this functionality make sure you have the proxy module
    compiled into your Apache server program.  If you don't know please check
    whether <CODE>mod_proxy.c</CODE> is part of the ``<CODE>httpd -l</CODE>''
    output. If yes, this functionality is available to mod_rewrite. If not,
    then you first have to rebuild the ``<CODE>httpd</CODE>'' program with
    mod_proxy enabled.
<P>
<LI>'<STRONG><CODE>last|L</CODE></STRONG>' (<STRONG>l</STRONG>ast rule)<BR>
    Stop the rewriting process here and
    don't apply any more rewriting rules. This corresponds to the Perl
    <CODE>last</CODE> command or the <CODE>break</CODE> command from the C
    language. Use this flag to prevent the currently rewritten URL from being
    rewritten further by following rules. For
    example, use it to rewrite the root-path URL ('<CODE>/</CODE>') to a real
    one, <EM>e.g.</EM>, '<CODE>/e/www/</CODE>'.
<P>
<LI>'<STRONG><CODE>next|N</CODE></STRONG>' (<STRONG>n</STRONG>ext round)<BR>
    Re-run the rewriting process (starting again with the first rewriting
    rule). Here the URL to match is again not the original URL but the URL
    from the last rewriting rule.  This corresponds to the Perl
    <CODE>next</CODE> command or the <CODE>continue</CODE> command from the C
    language. Use this flag to restart the rewriting process, <EM>i.e.</EM>,  to
    immediately go to the top of the loop. <BR>
    <STRONG>But be careful not to create an infinite loop!</STRONG>
<P>
<LI>'<STRONG><CODE>chain|C</CODE></STRONG>' (<STRONG>c</STRONG>hained with next rule)<BR>
    This flag chains the current rule with the next rule (which itself can
    be chained with the following rule, <EM>etc.</EM>). This has the following
    effect: if a rule matches, then processing continues as usual, <EM>i.e.</EM>, the
    flag has no effect. If the rule does <STRONG>not</STRONG> match, then all following
    chained rules are skipped.   For instance, use it to remove the
    ``<CODE>.www</CODE>'' part inside a per-directory rule set when you let an
    external redirect happen (where the ``<CODE>.www</CODE>'' part should not to
    occur!).
<P>
<LI>'<STRONG><CODE>type|T</CODE></STRONG>=<EM>MIME-type</EM>' (force MIME <STRONG>t</STRONG>ype)<BR>
    Force the MIME-type of the target file to be <EM>MIME-type</EM>. For
    instance, this can be used to simulate the <CODE>mod_alias</CODE>
    directive <CODE>ScriptAlias</CODE> which internally forces all files inside
    the mapped directory to have a MIME type of
    ``<CODE>application/x-httpd-cgi</CODE>''.
<P>
<LI>'<STRONG><CODE>nosubreq|NS</CODE></STRONG>' (used only if <STRONG>n</STRONG>o internal <STRONG>s</STRONG>ub-request)<BR>
    This flag forces the rewriting engine to skip a rewriting rule if the
    current request is an internal sub-request. For instance, sub-requests
    occur internally in Apache when <CODE>mod_include</CODE> tries to find out
    information about possible directory default files (<CODE>index.xxx</CODE>).
    On sub-requests it is not always useful and even sometimes causes a failure to
    if the complete set of rules are applied. Use this flag to exclude some rules.<BR>
    <P>
    Use the following rule for your decision: whenever you prefix some URLs
    with CGI-scripts to force them to be processed by the CGI-script, the
    chance is high that you will run into problems (or even overhead) on sub-requests.
    In these cases, use this flag.
<P>
<LI>'<STRONG><CODE>nocase|NC</CODE></STRONG>' (<STRONG>n</STRONG>o <STRONG>c</STRONG>ase)<BR>
	This makes the <EM>Pattern</EM> case-insensitive, <EM>i.e.</EM>, there is
	no difference between 'A-Z' and 'a-z' when <EM>Pattern</EM> is matched
	against the current URL.
<P>
<LI>'<STRONG><CODE>qsappend|QSA</CODE></STRONG>' (<STRONG>q</STRONG>uery <STRONG>s</STRONG>tring
    <STRONG>a</STRONG>ppend)<BR> 
    This flag forces the rewriting engine to append a query
    string part in the substitution string to the existing one instead of
    replacing it.  Use this when you want to add more data to the query string
    via a rewrite rule.
<P>
<LI>'<STRONG><CODE>passthrough|PT</CODE></STRONG>' (<STRONG>p</STRONG>ass <STRONG>t</STRONG>hrough to next handler)<BR>
    This flag forces the rewriting engine to set the <CODE>uri</CODE> field
    of the internal <CODE>request_rec</CODE> structure to the value
    of the <CODE>filename</CODE> field.  This flag is just a hack to be able
    to post-process the output of <CODE>RewriteRule</CODE> directives by
    <CODE>Alias</CODE>, <CODE>ScriptAlias</CODE>, <CODE>Redirect</CODE>, <EM>etc.</EM> directives
    from other URI-to-filename translators. A trivial example to show the
    semantics:
    If you want to rewrite <CODE>/abc</CODE> to <CODE>/def</CODE> via the rewriting
    engine of <CODE>mod_rewrite</CODE> and then <CODE>/def</CODE> to <CODE>/ghi</CODE>
    with <CODE>mod_alias</CODE>:
    <PRE>
d1821 112
a1932 86
    </PRE>
    If you omit the <CODE>PT</CODE> flag then <CODE>mod_rewrite</CODE>
    will do its job fine, <EM>i.e.</EM>, it rewrites <CODE>uri=/abc/...</CODE> to
    <CODE>filename=/def/...</CODE> as a full API-compliant URI-to-filename
    translator should do. Then <CODE>mod_alias</CODE> comes and tries to do a
    URI-to-filename transition which will not work.
    <P>
    Note: <STRONG>You have to use this flag if you want to intermix directives
    of different modules which contain URL-to-filename translators</STRONG>. The
    typical example is the use of <CODE>mod_alias</CODE> and
    <CODE>mod_rewrite</CODE>..
<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<font size=-1>
    <STRONG>Note - For Apache hackers:</STRONG><BR>
    If the current Apache API had a
    filename-to-filename hook additionally to the URI-to-filename hook then
    we wouldn't need this flag!  But without  such a hook this flag is the
    only solution. The Apache Group has discussed this problem and will
    add such a hook in Apache version 2.0.
</FONT>
</TD></TR>
</TABLE>
<P>
<LI>'<STRONG><CODE>skip|S</CODE></STRONG>=<EM>num</EM>' (<STRONG>s</STRONG>kip next rule(s))<BR>
    This flag forces the rewriting engine to skip the next <EM>num</EM> rules
    in sequence when the current rule matches. Use this to make pseudo
    if-then-else constructs: The last rule of the then-clause becomes
    <CODE>skip=N</CODE> where N is the number of rules in the else-clause.
    (This is <STRONG>not</STRONG> the same as the 'chain|C' flag!)
<P>
<LI>'<STRONG><CODE>env|E=</CODE></STRONG><EM>VAR</EM>:<EM>VAL</EM>' (set <STRONG>e</STRONG>nvironment variable)<BR>
    This forces an environment variable named <EM>VAR</EM> to be set to the
    value <EM>VAL</EM>, where <EM>VAL</EM> can contain regexp backreferences
    <CODE>$N</CODE> and <CODE>%N</CODE> which will be expanded. You can use this flag
    more than once to set more than one variable. The variables can be later
    dereferenced in many situations, but usually from
    within XSSI (via <CODE>&lt;!--#echo var="VAR"--&gt;</CODE>) or CGI (<EM>e.g.</EM>
    <CODE>$ENV{'VAR'}</CODE>).  Additionally you can dereference it in a
    following RewriteCond pattern via <CODE>%{ENV:VAR}</CODE>. Use this to strip
    but remember information from URLs.
</UL>

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Note:</STRONG> Never forget that <EM>Pattern</EM> is applied to a complete URL
in per-server configuration files. <STRONG>But in per-directory configuration
files, the per-directory prefix (which always is the same for a specific
directory!) is automatically <EM>removed</EM> for the pattern matching and
automatically <EM>added</EM> after the substitution has been done.</STRONG> This feature is
essential for many sorts of rewriting, because without this prefix stripping
you have to match the parent directory which is not always possible.
<P>
There is one exception: If a substitution string starts with
``<CODE>http://</CODE>'' then the directory prefix will <STRONG>not</STRONG> be added and an
external redirect or proxy throughput (if flag <STRONG>P</STRONG> is used!) is forced!
</TD></TR>
</TABLE>

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Note:</STRONG> To enable the rewriting engine for per-directory configuration files
you need to set ``<CODE>RewriteEngine On</CODE>'' in these files <STRONG>and</STRONG>
``<CODE>Options FollowSymLinks</CODE>'' must be enabled. If your administrator has
disabled override of <CODE>FollowSymLinks</CODE> for a user's directory, then
you cannot use the rewriting engine.  This restriction is needed for
security reasons.
</TD></TR>
</TABLE>

<P>
Here are all possible substitution combinations and their meanings:

<P>
<STRONG>Inside per-server configuration (<CODE>httpd.conf</CODE>)<BR>
for request ``<CODE>GET /somepath/pathinfo</CODE>'':</STRONG><BR>

<P>
<TABLE BGCOLOR="#F0F0F0" CELLSPACING=0 CELLPADDING=5>
<TR>
<TD>
<PRE>
<STRONG>Given Rule</STRONG>                                      <STRONG>Resulting Substitution</STRONG>
d1963 19
a1981 17
</PRE>
</TD>
</TR>
</TABLE>

<P>
<STRONG>Inside per-directory configuration for <CODE>/somepath</CODE><BR>
(<EM>i.e.</EM>, file <CODE>.htaccess</CODE> in dir <CODE>/physical/path/to/somepath</CODE> containing
<CODE>RewriteBase /somepath</CODE>)<BR> for
request ``<CODE>GET /somepath/localpath/pathinfo</CODE>'':</STRONG><BR>

<P>
<TABLE BGCOLOR="#F0F0F0" CELLSPACING=0 CELLPADDING=5>
<TR>
<TD>
<PRE>
<STRONG>Given Rule</STRONG>                                      <STRONG>Resulting Substitution</STRONG>
d2013 25
a2037 25
</PRE>
</TD>
</TR>
</TABLE>

<P>
<STRONG>Example:</STRONG>
<P>
<BLOCKQUOTE>
We want to rewrite URLs of the form
<BLOCKQUOTE>
<CODE>/</CODE> <EM>Language</EM>
<CODE>/~</CODE> <EM>Realname</EM>
<CODE>/.../</CODE> <EM>File</EM>
</BLOCKQUOTE>
into
<BLOCKQUOTE>
<CODE>/u/</CODE> <EM>Username</EM>
<CODE>/.../</CODE> <EM>File</EM>
<CODE>.</CODE> <EM>Language</EM>
</BLOCKQUOTE>
<P>
We take the rewrite mapfile from above and save it under
<CODE>/path/to/file/map.txt</CODE>. Then we only have to add the
following lines to the Apache server configuration file:
d2039 2
a2040 2
<BLOCKQUOTE>
<PRE>
d2044 26
a2069 4
</PRE>
</BLOCKQUOTE>

</BLOCKQUOTE>
d2071 1
a2071 2
<P>
<HR NOSHADE SIZE=1>
d2073 2
a2074 26
<CENTER>
<H1><A NAME="Miscelleneous">Miscellaneous</A></H1>
</CENTER>

<P>
<HR NOSHADE SIZE=1>

<H2><A NAME="EnvVar">Environment Variables</A></H2>

This module keeps track of two additional (non-standard) CGI/SSI environment
variables named <CODE>SCRIPT_URL</CODE> and <CODE>SCRIPT_URI</CODE>. These contain
the <EM>logical</EM> Web-view to the current resource, while the standard CGI/SSI
variables <CODE>SCRIPT_NAME</CODE> and <CODE>SCRIPT_FILENAME</CODE> contain the
<EM>physical</EM> System-view. 

<P>
Notice: These variables hold the URI/URL <EM>as they were initially
requested</EM>, <EM>i.e.</EM>, <EM>before</EM> any rewriting. This is
important because the rewriting process is primarily used to rewrite logical
URLs to physical pathnames.

<P>
<STRONG>Example:</STRONG>

<BLOCKQUOTE>
<PRE>
d2079 21
a2099 21
</PRE>
</BLOCKQUOTE>

<P>
<HR NOSHADE SIZE=1>

<H2><A NAME="Solutions">Practical Solutions</A></H2>

We also have an <a href="../misc/rewriteguide.html">URL Rewriting
Guide</a> available, which provides a collection of practical solutions
for URL-based problems. There you can find real-life rulesets and
additional information about mod_rewrite.

<HR>

<H3 ALIGN="CENTER">
 Apache HTTP Server Version 1.3
</H3>

<A HREF="./"><IMG SRC="../images/index.gif" ALT="Index"></A>
<A HREF="../"><IMG SRC="../images/home.gif" ALT="Home"></A>
a2100 4
</BLOCKQUOTE><!-- page indentation -->
</BODY>
</HTML>
<!--/%hypertext -->
@


1.6
log
@apache 1.3.14 + mod_ssl 2.7.1 merge
@
text
@d331 1
a331 1
    <CODE>RewriteEngine</CODE> {<CODE>on,off</CODE>}<BR>
d336 1
a336 1
    <STRONG><CODE>RewriteEngine off</CODE></STRONG><BR>
d382 1
a382 1
><STRONG>Syntax:</STRONG></A> <CODE>RewriteOptions</CODE> <EM>Option</EM><BR>
d431 1
a431 1
><STRONG>Syntax:</STRONG></A> <CODE>RewriteLog</CODE> <EM>Filename</EM><BR>
d505 1
a505 1
><STRONG>Syntax:</STRONG></A> <CODE>RewriteLogLevel</CODE> <EM>Level</EM><BR>
d509 1
a509 1
><STRONG>Default:</STRONG></A> <STRONG><CODE>RewriteLogLevel 0</CODE></STRONG>
d568 1
a568 1
><STRONG>Syntax:</STRONG></A> <CODE>RewriteLock</CODE> <EM>Filename</EM><BR>
d609 2
a610 2
><STRONG>Syntax:</STRONG></A> <CODE>RewriteMap</CODE> <EM>MapName </EM>
    <EM>MapType</EM><CODE>:</CODE><EM>MapSource</EM><BR>
d853 1
a853 1
><STRONG>Syntax:</STRONG></A> <CODE>RewriteBase</CODE> <EM>BaseURL</EM><BR>
d984 1
a984 1
><STRONG>Syntax:</STRONG></A> <CODE>RewriteCond</CODE> <EM>TestString</EM>
d1050 9
d1293 3
d1342 1
a1342 1
><STRONG>Syntax:</STRONG></A> <CODE>RewriteRule</CODE> <EM>Pattern</EM> <EM>Substitution</EM><BR>
d1717 1
a1717 1
``<CODE>Option FollowSymLinks</CODE>'' must be enabled. If your administrator has
@


1.5
log
@apache 1.3.12 + mod_ssl 2.6.2 merge
@
text
@d30 24
a53 8
This module is contained in the <CODE>mod_rewrite.c</CODE> file, with Apache
1.2 and later. It provides a rule-based rewriting engine to rewrite requested
URLs on the fly. It is not compiled into the server by default. To use
<CODE>mod_rewrite</CODE> you have to enable the following line in the server
build <CODE>Configuration</CODE> file:
<PRE>
    AddModule  modules/standard/mod_rewrite.o
</PRE>
d287 1
a287 1
use parentheses in <EM>Pattern</EM> or in one of the <EM>CondPattern</EM>
d291 1
a291 1
<EM>TestCond</EM>. Figure 2 shows to which locations the back-references are
@


1.4
log
@Apache 1.3.11 + mod_ssl 2.5.0 merge
@
text
@d90 1
a90 1
(<CODE>.htaccess</CODE>) and even can generate query-string parts on result.
d96 1
a96 1
don't expect to understand this module in its whole in just one day.
d161 1
a161 1
which is used after the HTTP request was read and before any authorization
d163 2
a164 2
and after the per-directory config files (<CODE>.htaccess</CODE>) where read,
but before the content handler is activated.
d168 1
a168 1
server (or virtual server) the rewriting engine start processing of all
d172 1
a172 1
in the Fixup phase. In both situations mod_rewrite either rewrites URLs to new
d174 1
a174 1
This is a usage of the API which was not intended this way when the API
d179 7
a185 7
<LI>The API currently provides only a URL-to-filename hook. Although
    mod_rewrite rewrites URLs to URLs, URLs to filenames and even
    filenames to filenames. In Apache 2.0 the two missing hooks 
    will be added to make the processing more clear. But this
    point has no drawbacks for the user, it is just a fact which
    should be remembered: Apache does more in the URL-to-filename hook
    then the API intends for it.
d188 13
a200 13
    context, <EM>i.e.</EM>, within <CODE>.htaccess</CODE> files, although
    these are
    reached a very long time after the URLs were translated to filenames (this
    has to be this way, because <CODE>.htaccess</CODE> files stay in the
    filesystem, so processing has already been reached this stage of
    processing). In other words: According to the API phases at this time it
    is too late for any URL manipulations.  To overcome this chicken and egg
    problem mod_rewrite uses a trick: When you manipulate a URL/filename in
    per-directory context mod_rewrite first rewrites the filename back to its
    corresponding URL (which it usually impossible, but see the
    <CODE>RewriteBase</CODE> directive below for the trick to achieve this)
    and then initiates a new internal sub-request with the new URL. This leads
    to a new processing of the API phases from the beginning. 
d217 1
a217 1
created on startup for per-server context or while the directory walk of the
d221 1
a221 1
same for both configuration contexts. Just the final result processing is
d226 1
a226 1
processes them in a special order. And this order is not very obvious. The
d228 1
a228 1
(<CODE>RewriteRule</CODE> directives!) and when a particular rule matched it
d230 2
a231 2
(<CODE>RewriteCond</CODE> directives). Because of historical reasons the 
conditions are given first, the control flow is a little bit winded. See
d254 1
a254 1
continues with the next rule. If the <EM>Pattern</EM> matched, mod_rewrite
d257 3
a259 3
<EM>Substitution</EM> and goes on with its rule-looping. But
if conditions exists, it starts an inner loop for processing them in order
they are listed. For conditions the logic is different: We don't match a
d265 2
a266 2
until no more condition is available. If all conditions matched processing is
continued with the substitution of the URL with <EM>Substitution</EM>.
d271 3
a273 3
use parenthesis in <EM>Pattern</EM> or in one of the <EM>CondPattern</EM>
back-reference are internally created which can be used with the
strings <CODE>$N</CODE> and <CODE>%N</CODE> (see below). And these
d275 2
a276 2
<EM>TestCond</EM>. Figure 2 shows at which locations the back-references are
transfered to for expansion.
d296 1
a296 1
We know, this was a crash course of mod_rewrite's internal processing.  But
d351 1
a351 1
all <CODE>RewriteRule</CODE> directives!
d356 1
a356 1
directive for each virtual host you wish to use it in.
d402 1
a402 1
    conditions and rules of the main server gets inherited. In per-directory
d404 1
a404 1
    <CODE>.htaccess</CODE> configuration gets inherited.
d451 1
a451 1
<STRONG>Notice</STRONG>: To disable the logging of rewriting actions it is
d454 1
a454 1
not create output to a logfile it still creates the logfile
d517 1
a517 1
The <CODE>RewriteLogLevel</CODE> directive set the verbosity level of the
d530 2
a531 3
your Apache
server dramatically! Use the rewriting logfile only for debugging or at least
at <EM>Level</EM> not greater than 2!
d583 1
a583 1
all other types of rewriting maps.
d642 1
a642 1
the empty string if no <EM>DefaultValue</EM> was specified.
d691 2
a692 2
    ``or''.  Or
    in other words: they indicate a set of alternatives from which the actual
d769 2
a770 2
    Here the source is a Unix program, not a map file. To create it you can use
    the language of your choice, but the result has to be a run-able Unix
d772 2
a773 2
    magic cookie trick '<CODE>#!/path/to/interpreter</CODE>' as the first
    line).
d775 1
a775 1
    This program gets started once at startup of the Apache servers and then
d791 1
a791 2
    # ...here any transformations
    # or lookups should occur...
d799 2
a800 2
    <LI>``<EM>Keep the program simple, stupid</EM>'' (KISS), because
        if this program hangs it will lead to a hang of the Apache server
d807 1
a807 1
        Per default no such synchronization takes place.
d820 1
a820 1
<STRONG>Notice:</STRONG> For plain text and DBM format files the looked-up
d870 1
a870 1
it is automatically added.
d877 2
a878 2
<STRONG>NOT</STRONG> directly related to physical filename paths, so this
assumption will be usually be wrong!</STRONG> There you have to use the
d909 1
a909 1
#  let the server know that we are reached via /xyz and not
d927 1
a927 1
<STRONG>Notice - For the Apache hackers:</STRONG><BR>
d950 1
a950 1
this re-injection happens fully internal to the Apache server and the same
d1029 1
a1029 1
(1 &lt;= N &lt;= 9) which provide access to the grouped parts (parenthesis!) of
d1042 1
a1042 1
of the following list:
d1121 1
a1121 1
<STRONG>Notice:</STRONG> These variables all correspond to the similar named
d1158 1
a1158 1
which actually is set later in an API phase and thus is not available at the
d1170 1
a1170 1
<LI>There is the special format: <CODE>%{LA-F:variable}</CODE> which perform an
d1172 1
a1172 1
<EM>variable</EM>. This is the most of the time the same as LA-U above.
d1178 2
a1179 2
which gets applied to the current instance of the <EM>TestString</EM>,
<EM>i.e.</EM>, <EM>TestString</EM> gets evaluated and then matched against
d1187 1
a1187 1
<LI>You can precede the pattern string with a '<CODE>!</CODE>' character
d1196 1
a1196 1
<LI>'<STRONG>&lt;CondPattern</STRONG>' (is lexicographically lower)<BR>
d1198 2
a1199 2
lexicographically to <EM>TestString</EM> and results in a true expression if
<EM>TestString</EM> is lexicographically lower than <EM>CondPattern</EM>.
d1201 1
a1201 1
<LI>'<STRONG>&gt;CondPattern</STRONG>' (is lexicographically greater)<BR>
d1203 2
a1204 2
lexicographically to <EM>TestString</EM> and results in a true expression if
<EM>TestString</EM> is lexicographically greater than <EM>CondPattern</EM>.
d1206 1
a1206 1
<LI>'<STRONG>=CondPattern</STRONG>' (is lexicographically equal)<BR>
d1208 2
a1209 2
lexicographically to <EM>TestString</EM> and results in a true expression if
<EM>TestString</EM> is lexicographically equal to <EM>CondPattern</EM>, i.e the
d1212 1
a1212 1
compares <EM>TestString</EM> against the empty string.
d1247 1
a1247 1
All of these tests can also be prefixed by a not ('!') character
d1265 1
a1265 1
    This makes the condition test case-insensitive, <EM>i.e.</EM>, there is
d1279 1
a1279 1
    Without this flag you had to write down the cond/rule three times.
d1348 7
a1354 6
<A NAME="patterns"><EM>Pattern</EM></A> can be (for Apache 1.1.x a System
V8 and for Apache 1.2.x a POSIX) <A NAME="regexp">regular expression</A>
which gets applied to the current URL. Here ``current'' means the value of the
URL when this rule gets applied. This may not be the original requested
URL, because there could be any number of rules before which already matched
and made alterations to it.
d1372 1
a1372 1
  <STRONG><CODE>*</CODE></STRONG>           0 or N of the preceding text (N &gt; 1)
d1396 2
a1397 2
Apache 1.3 distribution.  When you are interested in more detailed and deeper
information about regular expressions and its variants (POSIX regex, Perl
d1411 3
a1413 3
instance: ``<EM>if the current URL does <STRONG>NOT</STRONG> match to this
pattern</EM>''. This can be used for special cases where it is better to match
the negative pattern or as a last default rule.
d1450 2
a1451 2
rewriting process goes on until there are no more rules (unless explicitly
terminated by a <CODE><STRONG>L</STRONG></CODE> flag - see below).
d1470 1
a1470 1
<STRONG>Notice</STRONG>: There is a special feature. When you prefix a substitution
d1510 1
a1510 1
    canonicalize the URL and gives it back to the client, <EM>e.g.</EM>, translate
d1514 1
a1514 1
    <STRONG>Notice:</STRONG> When you use this flag, make sure that the
d1517 1
a1517 1
    URL with <CODE>http://thishost[:thisport]/</CODE>, but rewriting goes on.
d1528 2
a1529 2
    HTTP response of 410 (GONE). Use this flag to mark no longer existing
    pages as gone.
d1554 1
a1554 1
    rewritten further by following rules which may be wrong. For
d1565 1
a1565 1
    <STRONG>But be careful not to create a deadloop!</STRONG>
d1569 1
a1569 1
    also be chained with its following rule, <EM>etc.</EM>). This has the following
d1630 1
a1630 1
    Notice: <STRONG>You have to use this flag if you want to intermix directives
d1638 1
a1638 1
    <STRONG>Notice - For the Apache hackers:</STRONG><BR>
d1643 1
a1643 1
    add such hooks into Apache version 2.0.
d1652 1
a1652 1
    a <CODE>skip=N</CODE> where N is the number of rules in the else-clause.
d1660 1
a1660 1
    dereferenced at a lot of situations, but the usual location will be from
d1662 1
a1662 1
    <CODE>$ENV{'VAR'}</CODE>).  But additionally you can also dereference it in a
d1670 1
a1670 1
<STRONG>Notice:</STRONG> Never forget that <EM>Pattern</EM> gets applied to a complete URL
d1673 1
a1673 1
directory!) gets automatically <EM>removed</EM> for the pattern matching and
d1679 1
a1679 1
``<CODE>http://</CODE>'' then the directory prefix will be <STRONG>not</STRONG> added and a
d1687 1
a1687 1
<STRONG>Notice:</STRONG> To enable the rewriting engine for per-directory configuration files
d1689 1
a1689 1
``<CODE>Option FollowSymLinks</CODE>'' enabled. If your administrator has
d1843 1
a1843 1
requested</EM>, <EM>i.e.</EM>, in a state <EM>before</EM> any rewriting. This is
@


1.3
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d96 1
a96 1
don't expect to understand this module in it's whole in just one day.
d1019 3
a1021 4
(1 &lt;= N &lt;= 9) which provide access to the grouped parts (parenthesis!)
of the
pattern from the corresponding <CODE>RewriteRule</CODE> directive (the one
following the current bunch of <CODE>RewriteCond</CODE> directives).
d1439 1
a1439 1
Back-references are <CODE>$</CODE><STRONG>N</STRONG> (<STRONG>N</STRONG>=1..9) identifiers which
d1865 4
a1868 9
There is a comprehensive collection of practical solutions for URL-based
problems available by the author of mod_rewrite.  Here you will find real-life
rulesets and additional information.

<BLOCKQUOTE>
<STRONG>Apache URL Rewriting Guide</STRONG><BR>
<STRONG><A HREF="http://www.engelschall.com/pw/apache/rewriteguide/"
        >http://www.engelschall.com/pw/apache/rewriteguide/</A></STRONG>
</BLOCKQUOTE>
@


1.2
log
@Apache 1.3.4 merge
@
text
@d561 1
a561 1
><STRONG>Context:</STRONG></A> server config, virtual host<BR>
d584 1
a584 1
SAMP using all other types of rewriting maps.
d1087 1
@


1.1
log
@Initial revision
@
text
@d5 4
a8 4
<html>
<head>
<title>Apache module mod_rewrite</title>
</head>
d18 1
d22 1
a22 1
  Apache HTTP Server Version 1.2
d27 2
a28 1
<h1 ALIGN="CENTER">Module mod_rewrite</h1>
d30 220
a249 36
This module is contained in the <code>mod_rewrite.c</code> file, with Apache
1.2 and later.  It provides a rule-based rewriting engine to rewrite requested
URLs on the fly.   <code>mod_rewrite</code> is not compiled into the server by
default. To use <code>mod_rewrite</code> you have to enable the following line
in the server build Configuration file:
<pre>
    Module  rewrite_module   mod_rewrite.o
</pre>

<h2>Summary</h2>

This module uses a rule-based rewriting engine (based on a
regular-expression parser) to rewrite requested URLs on the fly.

<p>
It supports an unlimited number of additional rule conditions (which can
operate on a lot of variables, including HTTP headers) for granular
matching and external database lookups (either via plain text
tables, DBM hash files or external processes) for advanced URL
substitution.

<p>
It operates on the full URLs (including the PATH_INFO part) both in per-server
context (httpd.conf) and per-dir context (.htaccess) and even can generate
QUERY_STRING parts on result.   The rewritten result can lead to internal
sub-processing, external request redirection or to internal proxy throughput.

<p>
This module was originally written in April 1996 and 
gifted exclusively to the The Apache Group in July 1997 by
<p>
<blockquote>
    <i>Ralf S. Engelschall</i><br>
    <a href="mailto:rse@@engelschall.com"><tt>rse@@engelschall.com</tt></a><br>
    <a href="http://www.engelschall.com/"><tt>www.engelschall.com</tt></a>
</blockquote>
d251 43
a293 3
<!--%hypertext -->
<HR>
<!--/%hypertext -->
d295 52
a346 34
<p>
<h2>Directives</h2>

<ul>
    <li><a href="#RewriteEngine">RewriteEngine</a>
    <li><a href="#RewriteOptions">RewriteOptions</a>
    <li><a href="#RewriteLog">RewriteLog</a>
    <li><a href="#RewriteLogLevel">RewriteLogLevel</a>
    <li><a href="#RewriteMap">RewriteMap</a>
    <li><a href="#RewriteBase">RewriteBase</a>
    <li><a href="#RewriteCond">RewriteCond</a>
    <li><a href="#RewriteRule">RewriteRule</a>
</ul>

<!--%hypertext -->
<hr>
<!--/%hypertext -->


<center>
<a name="Configuration">
<h1>Configuration Directives</h1>
</a>
</center>

<a name="RewriteEngine"><h3>RewriteEngine</h3></a>
<strong>Syntax:</strong> <code>RewriteEngine</code> {<code>on,off</code>}<br>
<strong>Default:</strong> <strong><code>RewriteEngine off</code></strong><br>
<strong>Context:</strong> server config, virtual host, per-directory config<br>
<p>

The <tt>RewriteEngine</tt> directive enables or disables the
runtime rewriting engine. If it is set to <code>off</code> this module does
no runtime processing at all. It does not even update the <tt>SCRIPT_URx</tt>
d349 1
a349 1
<p>
d351 1
a351 11
all <tt>RewriteRule</tt> directives!

<p>
<hr noshade size=1>
<p>

<a name="RewriteOptions"><h3>RewriteOptions</h3></a>
<strong>Syntax:</strong> <code>RewriteOptions</code> <em>Option</em> ...<br>
<strong>Default:</strong> -<em>None</em>-<br>
<strong>Context:</strong> server config, virtual host, per-directory config<br>
<p>
d353 43
a395 2
The <tt>RewriteOption</tt> directive sets some special options for the
current per-server or per-directory configuration. The <em>Option</em>
d398 2
a399 2
<ul>
<li>'<strong><code>inherit</code></strong>'<br>
d404 2
a405 2
    <tt>.htaccess</tt> configuration gets inherited.
</ul>
d407 33
a439 9
<p>
<hr noshade size=1>
<p>

<a name="RewriteLog"><h3>RewriteLog</h3></a>
<strong>Syntax:</strong> <code>RewriteLog</code> <em>Filename</em><br>
<strong>Default:</strong> -<em>None</em>-<br>
<strong>Context:</strong> server config, virtual host<br>
<p>
d441 2
a442 1
The <tt>RewriteLog</tt> directive sets the name of the file to which the
d444 2
a445 2
with a slash ('<tt>/</tt>') then it is assumed to be relative to the
<em>Server Root</em>.  The directive should occur only once per server
d448 6
a453 6
<p>
<table width="70%" border=0 bgcolor="#f0f0f0" cellspacing=0 cellpadding=10>
<tr><td>
To disable the logging of rewriting actions it is not recommended
to set <em>Filename</em>
to <code>/dev/null</code>, because although the rewriting engine does
d455 2
a456 2
output internally. <b>This will slow down the server with no advantage to the
administrator!</b>
d458 10
a467 10
<tt>RewriteLog</tt> directive or use <tt>RewriteLogLevel 0</tt>!
</td></tr>
</table>

<p>
<table width="70%" border=0 bgcolor="#fff0f0" cellspacing=0 cellpadding=10>
<tr><td>
SECURITY: See the <a
href="../misc/security_tips.html">Apache Security
Tips</a> document for details on why your security could be compromised if the
d470 2
a471 2
</td></tr>
</table>
d473 4
a476 4
<p>
<b>Example:</b>
<blockquote>
<pre>
d478 2
a479 12
</pre>
</blockquote>

<p>
<hr noshade size=1>
<p>

<a name="RewriteLogLevel"><h3>RewriteLogLevel</h3></a>
<strong>Syntax:</strong> <code>RewriteLogLevel</code> <em>Level</em><br>
<strong>Default:</strong> <strong><code>RewriteLogLevel 0</code></strong><br>
<strong>Context:</strong> server config, virtual host<br>
<p>
d481 38
a518 1
The <tt>RewriteLogLevel</tt> directive set the verbosity level of the rewriting
d522 2
a523 2
<p>
To disable the logging of rewriting actions simply set <em>Level</em> to 0.
d526 5
a530 4
<p>
<table width="70%" border=0 bgcolor="#f0f0f0" cellspacing=0 cellpadding=10>
<tr><td>
<b>Notice:</b> Using a high value for <i>Level</i> will slow down your Apache
d532 3
a534 3
at <em>Level</em> not greater than 2!
</td></tr>
</table>
d537 4
a540 4
<p>
<b>Example:</b>
<blockquote>
<pre>
d542 2
a543 2
</pre>
</blockquote>
d545 75
a619 9
<p>
<hr noshade size=1>
<p>

<a name="RewriteMap"><h3>RewriteMap</h3></a>
<strong>Syntax:</strong> <code>RewriteMap</code> <em>Mapname</em> <code>{txt,dbm,prg}:</code><em>Filename</em><br>
<strong>Default:</strong> not used per default<br>
<strong>Context:</strong> server config, virtual host<br>
<p>
d621 2
a622 1
The <tt>RewriteMap</tt> directive defines an external <em>Rewriting Map</em>
d624 3
a626 2
to insert/substitute fields through a key lookup.
<p>
d628 1
a628 1
The <a name="mapfunc"><em>Mapname</em></a> is the name of the map and will
d630 1
a630 1
rewriting rule via
d632 38
a669 38
<blockquote><strong>
<code>${</code> <em>Mapname</em> <code>:</code> <em>LookupKey</em>
<code>|</code> <em>DefaultValue</em> <code>}</code>
</strong></blockquote>

When such a directive occurs the map <em>Mapname</em>
is consulted and the key <em>LookupKey</em> is looked-up. If the key is
found, the map-function directive is substituted by <em>SubstValue</em>. If
the key is not found then it is substituted by <em>DefaultValue</em>.

<p>
The <em>Filename</em> must be a valid Unix filepath, containing one
of the following formats:

<ol>
<li><b>Plain Text Format</b>
    <p>
    This is a ASCII file which contains either blank lines, comment lines
    (starting with a '#' character) or

    <blockquote><strong>
    <em>MatchingKey</em>  <em>SubstValue</em>
    </strong></blockquote>

    pairs - one per line. You can create such files either manually,
    using your favorite editor, or by using the programs
    <tt>mapcollect</tt> and <tt>mapmerge</tt> from the <tt>support</tt>
    directory of the <b>mod_rewrite</b> distribution.
    <p>
    To declare such a map prefix, <em>Filename</em> with a <code>txt:</code>
    string as in the following example:

<p>
<table border=0 cellspacing=1 cellpadding=5 bgcolor="#f0f0f0">
<tr><td><pre>
#
#   map.real-to-user -- maps realnames to usernames
#
d672 99
a770 25
Dr.Fred.Klabuster     fred  # Mr. DAU
</pre></td></tr>
</table>

<p>
<table border=0 cellspacing=1 cellpadding=5 bgcolor="#f0f0f0">
<tr><td><pre>
RewriteMap real-to-host txt:/path/to/file/map.real-to-user
</pre></td></tr>
</table>

<p>
<li><b>DBM Hashfile Format</b>
    <p>
    This is a binary NDBM format file containing the
    same contents as the <em>Plain Text Format</em> files. You can create
    such a file with any NDBM tool or with the <tt>dbmmanage</tt> program
    from the <tt>support</tt> directory of the Apache distribution.
    <p>
    To declare such a map prefix <em>Filename</em> with a <code>dbm:</code>
    string.
<p>
<li><b>Program Format</b>
    <p>
    This is a Unix executable, not a lookup file.  To create it you can use
d772 4
a775 3
    binary (i.e. either object-code or a script with the
    magic cookie trick '<tt>#!/path/to/interpreter</tt>' as the first line).
    <p>
d777 2
a778 2
    communicates with the rewriting engine over its <tt>stdin</tt> and
    <tt>stdout</tt> file-handles.  For each map-function lookup it will
d780 4
a783 3
    <tt>stdin</tt>. It then has to give back the looked-up value as a
    newline-terminated string on <tt>stdout</tt> or the four-character string
    ``<tt>NULL</tt>'' if it fails (i.e. there is no corresponding value
d785 4
a788 4
    (i.e. key == value) could be:
    <p>
<table border=0 cellspacing=1 cellpadding=5 bgcolor="#f0f0f0">
<tr><td><pre>
d796 6
a801 6
</pre></td></tr>
</table>
    <p>
    <b>But be very careful:</b><br>
    <ol>
    <li>``<i>Keep the program simple, stupid</i>'' (KISS), because
d804 21
a824 20
    <li>Avoid one common mistake: never do buffered I/O on <tt>stdout</tt>!
    This will cause a deadloop! Hence the ``<tt>$|=1</tt>'' in the above
    example...
    </ol>
    <p>
    To declare such a map prefix <em>Filename</em> with a <code>prg:</code>
    string.
</ol>

The <tt>RewriteMap</tt> directive can occur more than once. For each
mapping-function use one <tt>RewriteMap</tt> directive to declare its
rewriting mapfile. While you cannot <b>declare</b> a map in per-directory
context it is of course possible to <b>use</b> this map in per-directory
context.

<p>
<table width="70%" border=0 bgcolor="#f0f0f0" cellspacing=0 cellpadding=10>
<tr><td>
For plain text and DBM format files the looked-up keys are cached in-core
until the <tt>mtime</tt> of the mapfile changes or the server does a
d826 45
a870 20
for <b>every</b> request. This is no problem, because the external lookup
only happens once!
</td></tr>
</table>


<p>
<hr noshade size=1>
<p>

<a name="RewriteBase"><h3>RewriteBase</h3></a>
<strong>Syntax:</strong> <code>RewriteBase</code> <em>BaseURL</em><br>
<strong>Default:</strong> <em>default is the physical directory path</em><br>
<strong>Context:</strong> per-directory config<br>
<p>

The <tt>RewriteBase</tt> directive explicitly sets the base URL for
per-directory rewrites. As you will see below, <tt>RewriteRule</tt> can be
used in per-directory config files (<tt>.htaccess</tt>). There it will act
locally, i.e. the local directory prefix is stripped at this stage of
d874 16
a889 15
<p>
When a substitution occurs for a new URL, this module has to
re-inject the URL into the server processing. To be able to do this it needs
to know what the corresponding URL-prefix or URL-base is. By default this
prefix is the corresponding filepath itself. <b>But at most websites URLs are
<b>NOT</b> directly related to physical filename paths, so this assumption
will be usually be wrong!</b> There you have to use the <tt>RewriteBase</tt>
directive to specify the correct URL-prefix.

<p>
<table width="70%" border=0 bgcolor="#fff0f0" cellspacing=0 cellpadding=10>
<tr><td>
So, if your webserver's URLs are <b>not</b> directly
related to physical file paths, you have to use <tt>RewriteBase</tt> in every
<tt>.htaccess</tt> files where you want to use <tt>RewriteRule</tt>
d891 2
a892 2
</td></tr>
</table>
d894 2
a895 2
<p>
<b>Example:</b>
d897 1
a897 1
<blockquote>
d900 3
a902 3
<p>
<table border=0 cellspacing=1 cellpadding=5 bgcolor="#f0f0f0">
<tr><td><pre>
d905 2
a906 2
#  Remember: /abc/def is the physical path of /xyz, i.e. the server
#            has a 'Alias /xyz /abc/def' directive e.g.
d917 2
a918 2
</pre></td></tr>
</table>
d920 10
a929 9
<p>
In the above example, a request to <tt>/xyz/oldstuff.html</tt> gets correctly
rewritten to the physical file <tt>/abc/def/newstuff.html</tt>.

<p>
<table width="70%" border=0 bgcolor="#fff0f0" cellspacing=0 cellpadding=10>
<tr><td>
<font size=-1>
<b>For the Apache hackers:</b><br>
d933 2
a934 2
<p>
<pre>
d939 4
a942 4
  /xyz/oldstuff.html     -&gt; /abc/def/oldstuff.html    (per-server Alias)
  /abc/def/oldstuff.html -&gt; /abc/def/newstuff.html    (per-dir    RewriteRule)
  /abc/def/newstuff.html -&gt; /xyz/newstuff.html        (per-dir    RewriteBase)
  /xyz/newstuff.html     -&gt; /abc/def/newstuff.html    (per-server Alias)
d946 1
a946 1
</pre>
d955 46
a1000 19
</font>
</td></tr>
</table>

</blockquote>


<p>
<hr noshade size=1>
<p>

<a name="RewriteCond"><h3>RewriteCond</h3></a>
<strong>Syntax:</strong> <code>RewriteCond</code> <em>TestString</em> <em>CondPattern</em><br>
<strong>Default:</strong> -<em>None</em>-<br>
<strong>Context:</strong> server config, virtual host, per-directory config<br>
<p>

The <tt>RewriteCond</tt> directive defines a rule condition. Precede a
<tt>RewriteRule</tt> directive with one or more <tt>RewriteCond</tt>
d1004 2
a1005 4
state of the URI <b>AND</b> if these additional conditions apply, too.

<p>
<em>TestString</em> is a string which contains server-variables of the form
d1007 36
a1042 3
<blockquote><strong>
<tt>%{</tt> <em>NAME_OF_VARIABLE</em> <tt>}</tt>
</strong></blockquote>
d1044 1
a1044 1
where <em>NAME_OF_VARIABLE</em> can be a string
d1047 81
a1127 30
<p>
<table bgcolor="#f0f0f0" cellspacing=0 cellpadding=5>
<tr>
<td valign=top>
<b>HTTP headers:</b><p>
<font size=-1>
HTTP_USER_AGENT<br>
HTTP_REFERER<br>
HTTP_COOKIE<br>
HTTP_FORWARDED<br>
HTTP_HOST<br>
HTTP_PROXY_CONNECTION<br>
HTTP_ACCEPT<br>
</font>
</td>

<td valign=top>
<b>connection &amp; request:</b><p>
<font size=-1>
REMOTE_ADDR<br>
REMOTE_HOST<br>
REMOTE_USER<br>
REMOTE_IDENT<br>
REQUEST_METHOD<br>
SCRIPT_FILENAME<br>
PATH_INFO<br>
QUERY_STRING<br>
AUTH_TYPE<br>
</font>
</td>
d1129 1
a1129 2
</tr>
<tr>
d1131 2
a1132 26
<td valign=top>
<b>server internals:</b><p>
<font size=-1>
DOCUMENT_ROOT<br>
SERVER_ADMIN<br>
SERVER_NAME<br>
SERVER_PORT<br>
SERVER_PROTOCOL<br>
SERVER_SOFTWARE<br>
SERVER_VERSION<br>
</font>
</td>

<td valign=top>
<b>system stuff:</b><p>
<font size=-1>
TIME_YEAR<br>
TIME_MON<br>
TIME_DAY<br>
TIME_HOUR<br>
TIME_MIN<br>
TIME_SEC<br>
TIME_WDAY<br>
TIME<br>
</font>
</td>
d1134 6
a1139 29
<td valign=top>
<b>specials:</b><p>
<font size=-1>
API_VERSION<br>
THE_REQUEST<br>
REQUEST_URI<br>
REQUEST_FILENAME<br>
IS_SUBREQ<br>
</font>
</td>
</tr>
</table>


<p>
<table width="70%" border=0 bgcolor="#f0f0f0" cellspacing=0 cellpadding=10>
<tr><td>
These variables all correspond to the similar named HTTP MIME-headers, C
variables of the Apache server or <tt>struct tm</tt> fields of the Unix
system.
</td></tr>
</table>

<p>
Special Notes:
<ol>
<li>The variables SCRIPT_FILENAME and REQUEST_FILENAME contain the same
value, i.e. the value of the <tt>filename</tt> field of the internal
<tt>request_rec</tt> structure of the Apache server. The first name is just the
d1141 2
a1142 2
counterpart to REQUEST_URI (which contains the value of the <tt>uri</tt>
field of <tt>request_rec</tt>).
d1144 51
a1194 40
<p>
<li>There is the special format: <tt>%{ENV:variable}</tt> where
<i>variable</i> can be any environment variable. This is looked-up via
internal Apache structures and (if not found there) via <tt>getenv()</tt> from
the Apache server process.

<p>
<li>There is the special format: <tt>%{HTTP:header}</tt> where
<i>header</i> can be any HTTP MIME-header name. This is looked-up
from the HTTP request. Example: <tt>%{HTTP:Proxy-Connection}</tt>
is the value of the HTTP header ``<tt>Proxy-Connection:</tt>''.

<p>
<li>There is the special format: <tt>%{LA-U:url}</tt>
for look-aheads like <tt>-U</tt>. This performs a internal sub-request to
look-ahead for the final value of <i>url</i>.

<p>
<li>There is the special format: <tt>%{LA-F:file}</tt>
for look-aheads like <tt>-F</tt>. This performs a internal sub-request to
look-ahead for the final value of <i>file</i>.
</ol>

<p>
<em>CondPattern</em> is the condition pattern, i.e. a regular expression
which gets applied to the current instance of the <em>TestString</em>, i.e.
<em>TestString</em> gets evaluated and then matched against
<em>CondPattern</em>.

<p>
<b>Remember:</b> <em>CondPattern</em> is a standard
<em>Extended Regular Expression</em> with some additions:

<ol>
<li>You can precede the pattern string with a '<tt>!</tt>' character
(exclamation mark) to specify a <b>non</b>-matching pattern.

<p>
<li>
There are some special variants of <em>CondPatterns</em>. Instead of real
d1196 16
a1211 16
<p>
<ul>
<li>'<b>&lt;CondPattern</b>' (is lexicographically lower)<br>
Treats the <i>CondPattern</i> as a plain string and compares it
lexicographically to <i>TestString</i> and results in a true expression if
<i>TestString</i> is lexicographically lower then <i>CondPattern</i>.
<p>
<li>'<b>&gt;CondPattern</b>' (is lexicographically greater)<br>
Treats the <i>CondPattern</i> as a plain string and compares it
lexicographically to <i>TestString</i> and results in a true expression if
<i>TestString</i> is lexicographically greater then <i>CondPattern</i>.
<p>
<li>'<b>=CondPattern</b>' (is lexicographically equal)<br>
Treats the <i>CondPattern</i> as a plain string and compares it
lexicographically to <i>TestString</i> and results in a true expression if
<i>TestString</i> is lexicographically equal to <i>CondPattern</i>, i.e the
d1213 5
a1217 3
<p>
<li>'<b>-d</b>' (is <b>d</b>irectory)<br>
Treats the <i>TestString</i> as a pathname and
d1219 3
a1221 3
<p>
<li>'<b>-f</b>' (is regular <b>f</b>ile)<br>
Treats the <i>TestString</i> as a pathname and
d1223 7
a1229 7
<p>
<li>'<b>-s</b>' (is regular file with <b>s</b>ize)<br>
Treats the <i>TestString</i> as a pathname and
tests if it exists and is a regular file with size greater then zero.
<p>
<li>'<b>-l</b>' (is symbolic <b>l</b>ink)<br>
Treats the <i>TestString</i> as a pathname and
d1231 3
a1233 3
<p>
<li>'<b>-F</b>' (is existing file via subrequest)<br>
Checks if <i>TestString</i> is a valid file and accessible via all the
d1237 4
a1240 3
<p>
<li>'<b>-U</b>' (is existing URL via subrequest)<br>
Checks if <i>TestString</i> is a valid URL and accessible via all the server's
d1243 7
a1249 4
your servers performance!
</ul>
<p>
Notice: All of these tests can also be prefixed by a not ('!') character
d1251 10
a1260 8
</ol>

<p>
Additionally you can set special flags for <em>CondPattern</em> by appending

<blockquote><strong>
<code>[</code><em>flags</em><code>]</code>
</strong></blockquote>
d1262 1
a1262 1
as the third argument to the <tt>RewriteCond</tt> directive. <em>Flags</em>
d1265 3
a1267 3
<ul>
<li>'<strong><code>nocase|NC</code></strong>' (<b>n</b>o <b>c</b>ase)<br>
    This makes the condition test case-insensitive, i.e. there is
d1269 3
a1271 3
    <em>TestString</em> and the <em>CondPattern</em>.
<p>
<li>'<strong><code>ornext|OR</code></strong>' (<b>or</b> next condition)<br>
d1274 2
a1275 2
    <p>
<blockquote><pre>
d1280 1
a1280 1
</pre></blockquote>
d1282 1
a1282 1
</ul>
d1284 3
a1286 3
<p>
<b>Example:</b>
<blockquote>
d1288 1
a1288 1
To rewrite the Homepage of a site according to the ``<tt>User-Agent:</tt>''
d1291 1
a1291 1
<blockquote><pre>
d1299 1
a1299 1
</pre></blockquote>
d1303 2
a1304 2
Frames, etc. If you use the Lynx browser (which is Terminal-based), then you
get the min homepage, which contains no images, no tables, etc.  If you
d1306 1
a1306 1
</blockquote>
d1308 33
a1340 8
<p>
<hr noshade size=1>
<p>

<a name="RewriteRule"><h3>RewriteRule</h3></a>
<strong>Syntax:</strong> <code>RewriteRule</code> <em>Pattern</em> <em>Substitution</em><br>
<strong>Default:</strong> -<em>None</em>-<br>
<strong>Context:</strong> server config, virtual host, per-directory config<br>
d1342 2
a1343 2
<p>
The <tt>RewriteRule</tt> directive is the real rewriting workhorse.  The
d1345 2
a1346 2
rewriting rule.  The <b>definition order</b> of these rules is
<b>important</b>, because this order is used when applying the rules at
d1349 3
a1351 3
<p>
<a name="patterns"><em>Pattern</em></a> can be (for Apache 1.1.x a System
V8 and for Apache 1.2.x a POSIX) <a name="regexp">regular expression</a>
d1357 1
a1357 1
<p>
d1360 60
a1419 35
<p>
<table bgcolor="#f0f0f0" cellspacing=0 cellpadding=5>
<tr>
<td valign=top>
<pre>
<strong><code>^</code></strong>           Start of line
<strong><code>$</code></strong>           End of line
<strong><code>.</code></strong>           Any single character
<strong><code>[</code></strong>chars<strong><code>]</code></strong>     One of chars
<strong><code>[^</code></strong>chars<strong><code>]</code></strong>    None of chars

<strong><code>?</code></strong>           0 or 1 of the preceding char
<strong><code>*</code></strong>           0 or N of the preceding char
<strong><code>+</code></strong>           1 or N of the preceding char

<strong><code>\</code></strong>char       escape that specific char
            (e.g. for specifying the chars "<code>.[]()</code>" etc.)

<strong><code>(</code></strong>string<strong><code>)</code></strong>    Grouping of chars (the <b>N</b>th group can be used on the RHS with <code>$</code><b>N</b>)
</pre>
</td>
</tr>
</table>

<p>
Additionally the NOT character ('<tt>!</tt>') is a possible pattern
prefix. This gives you the ability to negate a pattern; to say, for instance: ``<i>if
the current URL does <b>NOT</b> match to this pattern</i>''. This can be used
for special cases where it is better to match the negative pattern or as a
last default rule.

<p>
<table width="70%" border=0 bgcolor="#fff0f0" cellspacing=0 cellpadding=10>
<tr><td>
<b>Notice!</b> When using the NOT character to negate a pattern you cannot
d1422 1
a1422 1
consequence, if negated patterns are used, you cannot use <tt>$N</tt> in the
d1424 2
a1425 2
</td></tr>
</table>
d1427 2
a1428 2
<p>
<a name="rhs"><em>Substitution</em></a> of a rewriting rule is the string
d1430 1
a1430 1
<em>Pattern</em> matched.  Beside plain text you can use
d1432 12
a1443 11
<ol>
<li>pattern-group back-references (<code>$N</code>)
<li>server-variables as in rule condition test-strings (<code>%{VARNAME}</code>)
<li><a href="#mapfunc">mapping-function</a> calls (<code>${mapname:key|default}</code>)
</ol>

Back-references are <code>$</code><b>N</b> (<b>N</b>=1..9) identifiers which
will be replaced by the contents of the <b>N</b>th group of the matched
<em>Pattern</em>. The server-variables are the same as for the
<em>TestString</em> of a <tt>RewriteCond</tt> directive. The
mapping-functions come from the <tt>RewriteMap</tt> directive and are
d1447 1
a1447 1
<p>
d1449 2
a1450 2
<em>Substitution</em> (in the order of definition in the config file).  The
URL is <b>completely replaced</b> by the <em>Substitution</em> and the
d1452 1
a1452 1
terminated by a <code><b>L</b></code> flag - see below).
d1454 5
a1458 5
<p>
There is a special substitution string named '<tt>-</tt>' which means:
<b>NO substitution</b>! Sounds silly? No, it is useful to provide rewriting
rules which <b>only</b> match some URLs but do no substitution, e.g. in
conjunction with the <b>C</b> (chain) flag to be able to have more than one
d1461 1
a1461 1
<p>
d1468 6
a1473 6
<p>
<table width="70%" border=0 bgcolor="#fff0f0" cellspacing=0 cellpadding=10>
<tr><td>
<b>Notice</b>: There is a special feature. When you prefix a substitution
field with <tt>http://</tt><em>thishost</em>[<em>:thisport</em>] then
<b>mod_rewrite</b> automatically strips it out.   This auto-reduction on
d1478 9
a1486 4
<p>
<b>Remember:</b> An unconditional external redirect to your own server will
not work with the prefix <tt>http://thishost</tt> because of this feature.
To achieve such a self-redirect, you have to use the <b>R</b>-flag (see
d1488 2
a1489 2
</td></tr>
</table>
d1491 2
a1492 2
<p>
Additionally you can set special flags for <em>Substitution</em> by appending
d1494 3
a1496 3
<blockquote><strong>
<code>[</code><em>flags</em><code>]</code>
</strong></blockquote>
d1498 1
a1498 1
as the third argument to the <tt>RewriteRule</tt> directive. <em>Flags</em> is a
d1501 5
a1505 5
<ul>
<li>'<strong><code>redirect|R</code>[=<i>code</i>]</strong>' (force <a name="redirect"><b>r</b>edirect</a>)<br>
    Prefix <em>Substitution</em>
    with <code>http://thishost[:thisport]/</code> (which makes the new URL a URI) to
    force a external redirection. If no <i>code</i> is given a HTTP response
d1508 2
a1509 2
    one of the following symbolic names: <tt>temp</tt> (default), <tt>permanent</tt>,
    <tt>seeother</tt>.
d1511 5
a1515 5
    canonicalize the URL and gives it back to the client, e.g. translate
    ``<code>/~</code>'' into ``<code>/u/</code>'' or always append a slash to
    <code>/u/</code><em>user</em>, etc.<br>
    <p>
    <b>Notice:</b> When you use this flag, make sure that the
d1518 1
a1518 1
    URL with <code>http://thishost[:thisport]/</code>, but rewriting goes on.
d1521 3
a1523 3
<p>
<li>'<strong><code>forbidden|F</code></strong>' (force URL to be <b>f</b>orbidden)<br>
    This forces the current URL to be forbidden, i.e. it immediately sends
d1526 3
a1528 3
<p>
<li>'<strong><code>gone|G</code></strong>' (force URL to be <b>g</b>one)<br>
    This forces the current URL to be gone, i.e. it immediately sends back a
d1531 2
a1532 2
<p>
<li>'<strong><code>proxy|P</code></strong>' (force <b>p</b>roxy)<br>
d1534 17
a1550 15
    request and immediately (i.e. rewriting rule processing stops here) put
    through the proxy module. You have to make sure that the substitution
    string is a valid URI (e.g. typically <tt>http://</tt>) which can
    be handled by the Apache proxy module. If not you get an error from
    the proxy module. Use this flag to achieve a more powerful implementation
    of the <tt>mod_proxy</tt> directive <tt>ProxyPass</tt>, to map
    some remote stuff into the namespace of the local server.
    <p>
    Notice: <b>You really have to put <tt>ProxyRequests On</tt> into your
    server configuration to prevent proxy requests from leading to core-dumps
    inside the Apache kernel. If you have not compiled in the proxy module,
    then there is no core-dump problem, because mod_rewrite checks for
    existence of the proxy module and if lost forbids proxy URLs.  </b>
<p>
<li>'<strong><code>last|L</code></strong>' (<b>l</b>ast rule)<br>
d1553 1
a1553 1
    <code>last</code> command or the <code>break</code> command from the C
d1556 4
a1559 4
    example, use it to rewrite the root-path URL ('<code>/</code>') to a real
    one, e.g. '<code>/e/www/</code>'.
<p>
<li>'<strong><code>next|N</code></strong>' (<b>n</b>ext round)<br>
d1563 6
a1568 6
    <code>next</code> command or the <code>continue</code> command from the C
    language. Use this flag to restart the rewriting process, i.e.  to
    immediately go to the top of the loop. <br>
    <b>But be careful not to create a deadloop!</b>
<p>
<li>'<strong><code>chain|C</code></strong>' (<b>c</b>hained with next rule)<br>
d1570 3
a1572 3
    also be chained with its following rule, etc.). This has the following
    effect: if a rule matches, then processing continues as usual, i.e. the
    flag has no effect. If the rule does <b>not</b> match, then all following
d1574 2
a1575 2
    ``<tt>.www</tt>'' part inside a per-directory rule set when you let an
    external redirect happen (where the ``<tt>.www</tt>'' part should not to
d1577 5
a1581 5
<p>
<li>'<strong><code>type|T</code></strong>=<em>mime-type</em>' (force MIME <b>t</b>ype)<br>
    Force the MIME-type of the target file to be <em>mime-type</em>. For
    instance, this can be used to simulate the old <tt>mod_alias</tt>
    directive <tt>ScriptAlias</tt> which internally forces all files inside
d1583 3
a1585 3
    ``<tt>application/x-httpd-cgi</tt>''.
<p>
<li>'<strong><code>nosubreq|NS</code></strong>' (used only if <b>n</b>o internal <b>s</b>ub-request)<br>
d1588 2
a1589 2
    occur internally in Apache when <tt>mod_include</tt> tries to find out
    information about possible directory default files (<tt>index.xxx</tt>).
d1591 2
a1592 2
    if the complete set of rules are applied. Use this flag to exclude some rules.<br>
    <p>
d1597 8
a1604 3
<p>
<li>'<strong><code>qsappend|QSA</code></strong>' (<b>q</b>uery <b>s</b>tring
    <b>a</b>ppend)<br> 
d1609 7
a1615 7
<p>
<li>'<strong><code>passthrough|PT</code></strong>' (<b>p</b>ass <b>t</b>hrough to next handler)<br>
    This flag forces the rewriting engine to set the <code>uri</code> field
    of the internal <code>request_rec</code> structure to the value
    of the <code>filename</code> field.  This flag is just a hack to be able
    to post-process the output of <tt>RewriteRule</tt> directives by
    <tt>Alias</tt>, <tt>ScriptAlias</tt>, <tt>Redirect</tt>, etc. directives
d1618 4
a1621 4
    If you want to rewrite <tt>/abc</tt> to <tt>/def</tt> via the rewriting
    engine of <tt>mod_rewrite</tt> and then <tt>/def</tt> to <tt>/ghi</tt>
    with <tt>mod_alias</tt>:
    <pre>
d1624 5
a1628 5
    </pre>
    If you omit the <tt>PT</tt> flag then <tt>mod_rewrite</tt>
    will do its job fine, i.e. it rewrites <tt>uri=/abc/...</tt> to
    <tt>filename=/def/...</tt> as a full API-compliant URI-to-filename
    translator should do. Then <tt>mod_alias</tt> comes and tries to do a
d1630 8
a1637 8
    <p>
    Notice: <b>You have to use this flag if you want to intermix directives
    of different modules which contain URL-to-filename translators</b>. The
    typical example is the use of <tt>mod_alias</tt> and
    <tt>mod_rewrite</tt>..
<p>
<table width="70%" border=0 bgcolor="#fff0f0" cellspacing=0 cellpadding=10>
<tr><td>
d1639 1
a1639 1
    <b>For the Apache hackers:</b><br>
d1645 6
a1650 6
</font>
</td></tr>
</table>
<p>
<li>'<strong><code>skip|S</code></strong>=<em>num</em>' (<b>s</b>kip next rule(s))<br>
    This flag forces the rewriting engine to skip the next <em>num</em> rules
d1653 20
a1672 20
    a <tt>skip=N</tt> where N is the number of rules in the else-clause.
    (This is <b>not</b> the same as the 'chain|C' flag!)
<p>
<li>'<strong><code>env|E=</code></strong><i>VAR</i>:<i>VAL</i>' (set <b>e</b>nvironment variable)<br>
    This forces an environment variable named <i>VAR</i> to be set to the value
    <i>VAL</i>, where <i>VAL</i> can contain regexp backreferences <tt>$N</tt>
    which will be expanded. You can use this flag more than once to set more
    than one variable. The variables can be later dereferenced at a lot of
    situations, but the usual location will be from within XSSI (via
        <tt>&lt;!--#echo var="VAR"--&gt;</tt>) or CGI (e.g. <tt>$ENV{'VAR'}</tt>).
        But additionally you can also dereference it in a following RewriteCond
        pattern via <tt>%{ENV:VAR}</tt>. Use this to strip but remember
        information from URLs.
</ul>

<p>
<table width="70%" border=0 bgcolor="#fff0f0" cellspacing=0 cellpadding=10>
<tr><td>
Remember: Never forget that <em>Pattern</em> gets applied to a complete URL
in per-server configuration files. <b>But in per-directory configuration
d1674 2
a1675 2
directory!) gets automatically <em>removed</em> for the pattern matching and
automatically <em>added</em> after the substitution has been done.</b> This feature is
d1678 1
a1678 1
<p>
d1680 12
a1691 12
``<tt>http://</tt>'' then the directory prefix will be <b>not</b> added and a
external redirect or proxy throughput (if flag <b>P</b> is used!) is forced!
</td></tr>
</table>

<p>
<table width="70%" border=0 bgcolor="#fff0f0" cellspacing=0 cellpadding=10>
<tr><td>
Notice!  To enable the rewriting engine for per-directory configuration files
you need to set ``<tt>RewriteEngine On</tt>'' in these files <b>and</b>
``<tt>Option FollowSymLinks</tt>'' enabled. If your administrator has
disabled override of <tt>FollowSymLinks</tt> for a user's directory, then
d1694 2
a1695 2
</td></tr>
</table>
d1697 1
a1697 1
<p>
d1700 10
a1709 10
<p>
<b>Inside per-server configuration (<tt>httpd.conf</tt>)<br>
for request ``<tt>GET /somepath/pathinfo</tt>'':</b><br>

<p>
<table bgcolor="#f0f0f0" cellspacing=0 cellpadding=5>
<tr>
<td>
<pre>
<b>Given Rule</b>                                      <b>Resulting Substitution</b>
d1740 17
a1756 17
</pre>
</td>
</tr>
</table>

<p>
<b>Inside per-directory configuration for <tt>/somepath</tt><br>
(i.e. file <tt>.htaccess</tt> in dir <tt>/physical/path/to/somepath</tt> containing
<tt>RewriteBase /somepath</tt>)<br> for
request ``<tt>GET /somepath/localpath/pathinfo</tt>'':</b><br>

<p>
<table bgcolor="#f0f0f0" cellspacing=0 cellpadding=5>
<tr>
<td>
<pre>
<b>Given Rule</b>                                      <b>Resulting Substitution</b>
d1788 9
a1796 10
</pre>
</td>
</tr>
</table>


<p>
<b>Example:</b>
<p>
<blockquote>
d1798 5
a1802 5
<blockquote>
<code>/</code> <em>Language</em>
<code>/~</code> <em>Realname</em>
<code>/.../</code> <em>File</em>
</blockquote>
d1804 6
a1809 6
<blockquote>
<code>/u/</code> <em>Username</em>
<code>/.../</code> <em>File</em>
<code>.</code> <em>Language</em>
</blockquote>
<p>
d1811 1
a1811 1
<code>/anywhere/map.real-to-user</code>. Then we only have to add the
d1814 4
a1817 4
<blockquote>
<pre>
RewriteLog   /anywhere/rewrite.log
RewriteMap   real-to-user               txt:/anywhere/map.real-to-host
d1819 16
a1834 18
</pre>
</blockquote>
</blockquote>


<!--%hypertext -->
<hr>
<!--/%hypertext -->

<center>
<a name="Additional">
<h1>Additional Features</h1>
</a>
</center>

<a name="EnvVar">
<h2>Environment Variables</h2>
</a>
d1837 8
a1844 8
variables named <tt>SCRIPT_URL</tt> and <tt>SCRIPT_URI</tt>. These contain
the <em>logical</em> Web-view to the current resource, while the standard CGI/SSI
variables <tt>SCRIPT_NAME</tt> and <tt>SCRIPT_FILENAME</tt> contain the
<em>physical</em> System-view. 

<p>
Notice: These variables hold the URI/URL <em>as they were initially
requested</em>, i.e. in a state <em>before</em> any rewriting. This is
d1848 2
a1849 2
<p>
<b>Example:</b>
d1851 3
a1853 3
<blockquote>
<pre>
SCRIPT_NAME=/v/sw/free/lib/apache/global/u/rse/.www/index.html
d1856 18
a1873 3
SCRIPT_URI=http://en2.en.sdm.de/u/rse/
</pre>
</blockquote>
d1875 1
a1876 1
<HR>
d1878 1
a1878 1
 Apache HTTP Server Version 1.2
d1884 1
@


1.1.1.1
log
@Initial import from apache 1.2.6
@
text
@@


1.1.1.2
log
@Apache 1.3.2
@
text
@d5 4
a8 4
<HTML>
<HEAD>
<TITLE>Apache module mod_rewrite</TITLE>
</HEAD>
a17 1
<BLOCKQUOTE><!-- page indentation -->
d21 1
a21 1
  Apache HTTP Server Version 1.3
d26 1
a26 2
<BR>
<H1 ALIGN="CENTER">Module mod_rewrite<BR>URL Rewriting Engine</H1>
d28 40
a67 220
This module is contained in the <CODE>mod_rewrite.c</CODE> file, with Apache
1.2 and later. It provides a rule-based rewriting engine to rewrite requested
URLs on the fly. It is not compiled into the server by default. To use
<CODE>mod_rewrite</CODE> you have to enable the following line in the server
build <CODE>Configuration</CODE> file:
<PRE>
    AddModule  modules/standard/mod_rewrite.o
</PRE>

<P>
<HR NOSHADE SIZE=1>

<BR>
<H2>Summary</H2>

<BLOCKQUOTE>
<BLOCKQUOTE>
<BLOCKQUOTE>
<EM>``The great thing about mod_rewrite is it gives you all the
configurability and flexibility of Sendmail. The downside to
mod_rewrite is that it gives you all the configurability and
flexibility of Sendmail.''</EM>
<DIV ALIGN=RIGHT>
-- Brian Behlendorf<BR>
Apache Group
</DIV>
</BLOCKQUOTE>
</BLOCKQUOTE>
</BLOCKQUOTE>

<BLOCKQUOTE>
<BLOCKQUOTE>
<BLOCKQUOTE>
<EM>``
Despite the tons of examples and docs, mod_rewrite
is voodoo. Damned cool voodoo, but still voodoo.
''</EM>
<DIV ALIGN=RIGHT>
-- Brian Moore<BR>
bem@@news.cmc.net
</DIV>
</BLOCKQUOTE>
</BLOCKQUOTE>
</BLOCKQUOTE>

Welcome to mod_rewrite, the Swiss Army Knife of URL manipulation!

<P>
This module uses a rule-based rewriting engine (based on a regular-expression
parser) to rewrite requested URLs on the fly. It supports an unlimited number
of rules and an unlimited number of attached rule conditions for each rule to
provide a really flexible and powerful URL manipulation mechanism.  The URL
manipulations can depend on various tests, for instance server variables,
environment variables, HTTP headers, time stamps and even external database
lookups in various formats can be used to achieve a really granular URL
matching. 

<P>
This module operates on the full URLs (including the path-info part) both in
per-server context (<CODE>httpd.conf</CODE>) and per-directory context
(<CODE>.htaccess</CODE>) and even can generate query-string parts on result.
The rewritten result can lead to internal sub-processing, external request
redirection or even to an internal proxy throughput.

<P>
But all this functionality and flexibility has its drawback: complexity. So
don't expect to understand this module in it's whole in just one day.

<P>
This module was invented and originally written in April 1996<BR>
and gifted exclusively to the The Apache Group in July 1997 by

<P>
<BLOCKQUOTE>
<A HREF="http://www.engelschall.com/"><CODE>Ralf S. Engelschall</CODE></A><BR>
<A HREF="mailto:rse@@engelschall.com"><CODE>rse@@engelschall.com</CODE></A><BR>
<A HREF="http://www.engelschall.com/"><CODE>www.engelschall.com</CODE></A>
</BLOCKQUOTE>

<P>
<HR NOSHADE SIZE=1>

<H2>Table Of Contents</H2>

<P>
<STRONG>Internal Processing</STRONG>
<UL>
    <LI><A HREF="#InternalAPI">API Phases</A>
    <LI><A HREF="#InternalRuleset">Ruleset Processing</A>
    <LI><A HREF="#InternalBackRefs">Regex Back-Reference Availability</A>
</UL>
<P>
<STRONG>Configuration Directives</STRONG>
<UL>
    <LI><A HREF="#RewriteEngine">RewriteEngine</A>
    <LI><A HREF="#RewriteOptions">RewriteOptions</A>
    <LI><A HREF="#RewriteLog">RewriteLog</A>
    <LI><A HREF="#RewriteLogLevel">RewriteLogLevel</A>
    <LI><A HREF="#RewriteLock">RewriteLock</A>
    <LI><A HREF="#RewriteMap">RewriteMap</A>
    <LI><A HREF="#RewriteBase">RewriteBase</A>
    <LI><A HREF="#RewriteCond">RewriteCond</A>
    <LI><A HREF="#RewriteRule">RewriteRule</A>
</UL>
<STRONG>Miscellaneous</STRONG>
<UL>
    <LI><A HREF="#EnvVar">Environment Variables</A>
    <LI><A HREF="#Solutions">Practical Solutions</A>
</UL>

<P>
<HR NOSHADE SIZE=1>

<CENTER>
<H1><A NAME="Internal">Internal Processing</A></H1>
</CENTER>

<P>
<HR NOSHADE SIZE=1>

<P>
The internal processing of this module is very complex but needs to be
explained once even to the average user to avoid common mistakes and to let
you exploit its full functionality. 

<H2><A NAME="InternalAPI">API Phases</A></H2>

<P>
First you have to understand that when Apache processes a HTTP request it does
this in phases. A hook for each of these phases is provided by the Apache API.
Mod_rewrite uses two of these hooks: the URL-to-filename translation hook
which is used after the HTTP request was read and before any authorization
starts and the Fixup hook which is triggered after the authorization phases
and after the per-directory config files (<CODE>.htaccess</CODE>) where read,
but before the content handler is activated.

<P>
So, after a request comes in and Apache has determined the corresponding
server (or virtual server) the rewriting engine start processing of all
mod_rewrite directives from the per-server configuration in the
URL-to-filename phase. A few steps later when the final data directories are
found, the per-directory configuration directives of mod_rewrite are triggered
in the Fixup phase. In both situations mod_rewrite either rewrites URLs to new
URLs or to filenames, although there is no obvious distinction between them.
This is a usage of the API which was not intended this way when the API
was designed, but as of Apache 1.x this is the only way mod_rewrite can
operate. To make this point more clear remember the following two points:

<OL>
<LI>The API currently provides only a URL-to-filename hook. Although
    mod_rewrite rewrites URLs to URLs, URLs to filenames and even
    filenames to filenames. In Apache 2.0 the two missing hooks 
    will be added to make the processing more clear. But this
    point has no drawbacks for the user, it is just a fact which
    should be remembered: Apache does more in the URL-to-filename hook
    then the API intends for it.
<P>
<LI>Unbelievably mod_rewrite provides URL manipulations in per-directory
    context, <EM>i.e.</EM>, within <CODE>.htaccess</CODE> files, although
    these are
    reached a very long time after the URLs were translated to filenames (this
    has to be this way, because <CODE>.htaccess</CODE> files stay in the
    filesystem, so processing has already been reached this stage of
    processing). In other words: According to the API phases at this time it
    is too late for any URL manipulations.  To overcome this chicken and egg
    problem mod_rewrite uses a trick: When you manipulate a URL/filename in
    per-directory context mod_rewrite first rewrites the filename back to its
    corresponding URL (which it usually impossible, but see the
    <CODE>RewriteBase</CODE> directive below for the trick to achieve this)
    and then initiates a new internal sub-request with the new URL. This leads
    to a new processing of the API phases from the beginning. 
    <P>
    Again mod_rewrite tries hard to make this complicated step totally
    transparent to the user, but you should remember here: While URL
    manipulations in per-server context are really fast and efficient,
    per-directory rewrites are slow and inefficient due to this chicken and
    egg problem. But on the other hand this is the only way mod_rewrite can
    provide (locally restricted) URL manipulations to the average user.
</OL>

<P>
Don't forget these two points!

<H2><A NAME="InternalRuleset">Ruleset Processing</A></H2>

Now when mod_rewrite is triggered in these two API phases, it reads the
configured rulesets from its configuration structure (which itself was either
created on startup for per-server context or while the directory walk of the
Apache kernel for per-directory context).  Then the URL rewriting engine is
started with the contained ruleset (one or more rules together with their
conditions). The operation of the URL rewriting engine itself is exactly the
same for both configuration contexts. Just the final result processing is
different.

<P>
The order of rules in the ruleset is important because the rewriting engine
processes them in a special order. And this order is not very obvious. The
rule is this: The rewriting engine loops through the ruleset rule by rule
(<CODE>RewriteRule</CODE> directives!) and when a particular rule matched it
optionally loops through existing corresponding conditions
(<CODE>RewriteCond</CODE> directives). Because of historical reasons the 
conditions are given first, the control flow is a little bit winded. See
Figure 1 for more details.

<P>
<DIV ALIGN=CENTER>
<TABLE CELLSPACING=0 CELLPADDING=2 BORDER=0>
<TR>
<TD BGCOLOR="#CCCCCC"><IMG 
    SRC="../images/mod_rewrite_fig1.gif"
    WIDTH="428" HEIGHT="385"
    ALT="[Needs graphics capability to display]"></TD>
</TR>
<TR>
<TD ALIGN=CENTER>
<STRONG>Figure 1:</STRONG> The control flow through the rewriting ruleset
</TD>
</TR>
</TABLE>
</DIV>
d69 2
a70 43
<P>
As you can see, first the URL is matched against the <EM>Pattern</EM> of each
rule. When it fails mod_rewrite immediately stops processing this rule and
continues with the next rule. If the <EM>Pattern</EM> matched, mod_rewrite
looks for corresponding rule conditions. If none are present, it just
substitutes the URL with a new value which is constructed from the string
<EM>Substitution</EM> and goes on with its rule-looping. But if conditions But
if conditions exists, it starts an inner loop for processing them in order
they are listed. For conditions the logic is different: We don't match a
pattern against the current URL. Instead we first create a string
<EM>TestString</EM> by expanding variables, back-references, map lookups, <EM>etc.</EM>
and then we try to match <EM>TestPattern</EM> against it. If the pattern
doesn't match, the complete set of conditions and the corresponding rule fails.
If the pattern matches, then the next condition is processed until no more
condition is available. If all conditions matched processing is continued with
the substitution of the URL with <EM>Substitution</EM>.

<H2><A NAME="InternalBackRefs">Regex Back-Reference Availability</A></H2>

One important thing here has to be remembered: Whenever you
use parenthesis in <EM>Pattern</EM> or in one of the <EM>TestPattern</EM>
back-reference are internally created which can be used with the
strings <CODE>$N</CODE> and <CODE>%N</CODE> (see below). And these
are available for creating the strings <EM>Substitution</EM> and
<EM>TestCond</EM>. Figure 2 shows at which locations the back-references are
transfered to for expansion.

<P>
<DIV ALIGN=CENTER>
<TABLE  CELLSPACING=0 CELLPADDING=2 BORDER=0>
<TR>
<TD BGCOLOR="#CCCCCC"><IMG 
    SRC="../images/mod_rewrite_fig2.gif"
    WIDTH="381" HEIGHT="179"
    ALT="[Needs graphics capability to display]"></TD>
</TR>
<TR>
<TD ALIGN=CENTER>
<STRONG>Figure 2:</STRONG> The back-reference flow through a rule
</TD>
</TR>
</TABLE>
</DIV>
d72 31
a102 52
<P>
We know, this was a crash course of mod_rewrite's internal processing.  But
you will benefit from this knowledge when reading the following documentation
of the available directives.

<P>
<HR NOSHADE SIZE=1>

<CENTER>
<H1><A NAME="Configuration">Configuration Directives</A></H1>
</CENTER>

<P>
<HR NOSHADE SIZE=1>

<H3><A NAME="RewriteEngine">RewriteEngine</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A>
    <CODE>RewriteEngine</CODE> {<CODE>on,off</CODE>}<BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A>
    <STRONG><CODE>RewriteEngine off</CODE></STRONG><BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A>
    server config, virtual host, directory, .htaccess<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> FileInfo<BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2<BR>

<P>
The <CODE>RewriteEngine</CODE> directive enables or disables the runtime
rewriting engine. If it is set to <CODE>off</CODE> this module does no runtime
processing at all. It does not even update the <CODE>SCRIPT_URx</CODE>
d105 1
a105 1
<P>
d107 11
a117 1
all <CODE>RewriteRule</CODE> directives!
d119 2
a120 43
<P>
Note that, by default, rewrite configurations are not inherited.
This means that you need to have a <CODE>RewriteEngine on</CODE>
directive for each virtual host you wish to use it in.

<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteOptions">RewriteOptions</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> <CODE>RewriteOptions</CODE> <EM>Option</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> <EM>None</EM><BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> server config, virtual host, directory,
    .htaccess<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> FileInfo<BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2<BR>

<P>
The <CODE>RewriteOptions</CODE> directive sets some special options for the
current per-server or per-directory configuration. The <EM>Option</EM>
d123 2
a124 2
<UL>
<LI>'<STRONG><CODE>inherit</CODE></STRONG>'<BR>
d129 2
a130 2
    <CODE>.htaccess</CODE> configuration gets inherited.
</UL>
d132 9
a140 33
<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteLog">RewriteLog</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> <CODE>RewriteLog</CODE> <EM>Filename</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> <EM>None</EM><BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> server config, virtual host<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> <EM>Not applicable</EM><BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2<BR>
d142 1
a142 2
<P>
The <CODE>RewriteLog</CODE> directive sets the name of the file to which the
d144 2
a145 2
with a slash ('<CODE>/</CODE>') then it is assumed to be relative to the
<EM>Server Root</EM>.  The directive should occur only once per server
d148 6
a153 6
<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice</STRONG>: To disable the logging of rewriting actions it is
not recommended to set <EM>Filename</EM>
to <CODE>/dev/null</CODE>, because although the rewriting engine does
d155 2
a156 2
output internally. <STRONG>This will slow down the server with no advantage
to the administrator!</STRONG>
d158 10
a167 10
<CODE>RewriteLog</CODE> directive or use <CODE>RewriteLogLevel 0</CODE>!
</TD></TR>
</TABLE>

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Security</STRONG>: See the <A
HREF="../misc/security_tips.html">Apache Security
Tips</A> document for details on why your security could be compromised if the
d170 2
a171 2
</TD></TR>
</TABLE>
d173 4
a176 4
<P>
<STRONG>Example:</STRONG>
<BLOCKQUOTE>
<PRE>
d178 12
a189 2
</PRE>
</BLOCKQUOTE>
d191 1
a191 38
<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteLogLevel">RewriteLogLevel</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> <CODE>RewriteLogLevel</CODE> <EM>Level</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> <STRONG><CODE>RewriteLogLevel 0</CODE></STRONG>
<BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> server config, virtual host<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> <EM>Not applicable</EM><BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2<BR>

<P>
The <CODE>RewriteLogLevel</CODE> directive set the verbosity level of the
rewriting
d195 2
a196 2
<P>
To disable the logging of rewriting actions simply set <EM>Level</EM> to 0.
d199 4
a202 5
<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice:</STRONG> Using a high value for <EM>Level</EM> will slow down
your Apache
d204 3
a206 3
at <EM>Level</EM> not greater than 2!
</TD></TR>
</TABLE>
d209 4
a212 4
<P>
<STRONG>Example:</STRONG>
<BLOCKQUOTE>
<PRE>
d214 2
a215 2
</PRE>
</BLOCKQUOTE>
d217 9
a225 75
<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteLock">RewriteLock</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> <CODE>RewriteLock</CODE> <EM>Filename</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> <EM>None</EM><BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> server config, virtual host<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> <EM>Not applicable</EM><BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.3<BR>

<P>
This directive sets the filename for a synchronization lockfile which
mod_rewrite needs to communicate with <SAMP>RewriteMap</SAMP>
<EM>programs</EM>. Set this lockfile to a local path (not on a NFS-mounted
device) when you want to use a rewriting map-program. It is not required for
SAMP using all other types of rewriting maps.

<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteMap">RewriteMap</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> <CODE>RewriteMap</CODE> <EM>MapName </EM>
    <EM>MapType</EM><CODE>:</CODE><EM>MapSource</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> not used per default<BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> server config, virtual host<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> <EM>Not applicable</EM><BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2 (partially), Apache 1.3<BR>
d227 1
a227 2
<P>
The <CODE>RewriteMap</CODE> directive defines a <EM>Rewriting Map</EM>
d229 2
a230 3
to insert/substitute fields through a key lookup. The source of this
lookup can be of various types.
<P>
d232 1
a232 1
The <A NAME="mapfunc"><EM>MapName</EM></A> is the name of the map and will
d234 1
a234 1
rewriting rule via one of the following constructs:
d236 38
a273 38
<BLOCKQUOTE><STRONG>
<CODE>${</CODE> <EM>MapName</EM> <CODE>:</CODE> <EM>LookupKey</EM>
<CODE>}</CODE><BR>
<CODE>${</CODE> <EM>MapName</EM> <CODE>:</CODE> <EM>LookupKey</EM>
<CODE>|</CODE> <EM>DefaultValue</EM> <CODE>}</CODE>
</STRONG></BLOCKQUOTE>

When such a construct occurs the map <EM>MapName</EM>
is consulted and the key <EM>LookupKey</EM> is looked-up. If the key is
found, the map-function construct is substituted by <EM>SubstValue</EM>. If
the key is not found then it is substituted by <EM>DefaultValue</EM> or
the empty string if no <EM>DefaultValue</EM> was specified.

<P>
The following combinations for <EM>MapType</EM> and <EM>MapSource</EM>
can be used:

<UL>
<LI><STRONG>Standard Plain Text</STRONG><BR>
    MapType: <CODE>txt</CODE>, MapSource: Unix filesystem path to valid regular
    file
    <P>
    This is the standard rewriting map feature where the <EM>MapSource</EM> is
    a plain ASCII file containing either blank lines, comment lines (starting
    with a '#' character) or pairs like the following - one per line.

    <BLOCKQUOTE><STRONG>
    <EM>MatchingKey</EM>  <EM>SubstValue</EM>
    </STRONG></BLOCKQUOTE>

    <P>
    Example:
<P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
<TR><TD><PRE>
##
##  map.txt -- rewriting map
##
d276 25
a300 95
Mr.Joe.Average        joe   # Mr. Average
</PRE></TD></TR>
</TABLE>

<P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
<TR><TD><PRE>
RewriteMap real-to-user txt:/path/to/file/map.txt
</PRE></TD></TR>
</TABLE>

<P>
<LI><STRONG>Randomized Plain Text</STRONG><BR>
    MapType: <CODE>rnd</CODE>, MapSource: Unix filesystem path to valid regular
    file
    <P>
    This is identical to the Standard Plain Text variant above but with a
    special
    post-processing feature: After looking up a value it is parsed according
    to contained ``<CODE>|</CODE>'' characters which have the meaning of
    ``or''.  Or
    in other words: they indicate a set of alternatives from which the actual
    returned value is chosen randomly. Although this sounds crazy and useless,
    it
    was actually designed for load balancing in a reverse proxy situation where
    the looked up values are server names.
    Example:
<P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
<TR><TD><PRE>
##
##  map.txt -- rewriting map
##

static   www1|www2|www3|www4
dynamic  www5|www6
</PRE></TD></TR>
</TABLE>

<P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
<TR><TD><PRE>
RewriteMap servers rnd:/path/to/file/map.txt
</PRE></TD></TR>
</TABLE>

<P>
<LI><STRONG>Hash File</STRONG><BR>
    MapType: <CODE>dbm</CODE>, MapSource: Unix filesystem path to valid
    regular file
    <P>
    Here the source is a binary NDBM format file containing the same contents
    as a <EM>Plain Text</EM> format file, but in a special representation
    which is optimized for really fast lookups. You can create such a file with
    any NDBM tool or with the following Perl script:
    <P>
    <TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
    <TR><TD><PRE>
#!/path/to/bin/perl
##
##  txt2dbm -- convert txt map to dbm format
##

($txtmap, $dbmmap) = @@ARGV;
open(TXT, "&lt;$txtmap");
dbmopen(%DB, $dbmmap, 0644);
while (&lt;TXT&gt;) {
    next if (m|^s*#.*| or m|^s*$|);
    $DB{$1} = $2 if (m|^\s*(\S+)\s+(\S+)$|);
}
dbmclose(%DB);
close(TXT)</PRE></TD></TR>
    </TABLE>
    <P>
    <TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
    <TR><TD><PRE>$ txt2dbm map.txt map.db </PRE></TD></TR>
    </TABLE>
<P>
<LI><STRONG>Internal Function</STRONG><BR>
    MapType: <CODE>int</CODE>, MapSource: Internal Apache function
    <P>
    Here the source is an internal Apache function. Currently you cannot
    create your own, but the following functions already exists:
    <UL> 
    <LI><STRONG>toupper</STRONG>:<BR>
        Converts the looked up key to all upper case.
    <LI><STRONG>tolower</STRONG>:<BR>
        Converts the looked up key to all lower case.
    </UL>
<P>
<LI><STRONG>External Rewriting Program</STRONG><BR>
    MapType: <CODE>prg</CODE>, MapSource: Unix filesystem path to valid
    regular file
    <P>
    Here the source is a Unix program, not a map file. To create it you can use
d302 3
a304 4
    executable (<EM>i.e.</EM>, either object-code or a script with the
    magic cookie trick '<CODE>#!/path/to/interpreter</CODE>' as the first
    line).
    <P>
d306 2
a307 2
    communicates with the rewriting engine over its <CODE>stdin</CODE> and
    <CODE>stdout</CODE> file-handles.  For each map-function lookup it will
d309 3
a311 4
    <CODE>stdin</CODE>. It then has to give back the looked-up value as a
    newline-terminated string on <CODE>stdout</CODE> or the four-character
    string ``<CODE>NULL</CODE>'' if it fails (<EM>i.e.</EM>, there is no
    corresponding value
d313 4
a316 4
    (<EM>i.e.</EM>, key == value) could be:
    <P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
<TR><TD><PRE>
d324 6
a329 6
</PRE></TD></TR>
</TABLE>
    <P>
    But be very careful:<BR>
    <OL>
    <LI>``<EM>Keep the program simple, stupid</EM>'' (KISS), because
d332 20
a351 21
    <LI>Avoid one common mistake: never do buffered I/O on <CODE>stdout</CODE>!
        This will cause a deadloop! Hence the ``<CODE>$|=1</CODE>'' in the
        above example...
    <LI>Use the <SAMP>RewriteLock</SAMP> directive to define a lockfile
        mod_rewrite can use to synchronize the communication to the program.
        Per default no such synchronization takes place.
    </OL>
</UL>

The <CODE>RewriteMap</CODE> directive can occur more than once. For each
mapping-function use one <CODE>RewriteMap</CODE> directive to declare its
rewriting mapfile. While you cannot <STRONG>declare</STRONG> a map in
per-directory context it is of course possible to <STRONG>use</STRONG>
this map in per-directory context.

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice:</STRONG> For plain text and DBM format files the looked-up
keys are cached in-core
until the <CODE>mtime</CODE> of the mapfile changes or the server does a
d353 20
a372 45
for <STRONG>every</STRONG> request. This is no problem, because the
external lookup only happens once!
</TD></TR>
</TABLE>

<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteBase">RewriteBase</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> <CODE>RewriteBase</CODE> <EM>BaseURL</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> <EM>default is the physical directory path</EM>
<BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> directory, .htaccess<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> <EM>FileInfo</EM><BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2<BR>

<P>
The <CODE>RewriteBase</CODE> directive explicitly sets the base URL for
per-directory rewrites. As you will see below, <CODE>RewriteRule</CODE> can be
used in per-directory config files (<CODE>.htaccess</CODE>). There it will act
locally, <EM>i.e.</EM>, the local directory prefix is stripped at this stage of
d376 15
a390 16
<P>
When a substitution occurs for a new URL, this module has to re-inject the URL
into the server processing. To be able to do this it needs to know what the
corresponding URL-prefix or URL-base is. By default this prefix is the
corresponding filepath itself. <STRONG>But at most websites URLs are
<STRONG>NOT</STRONG> directly related to physical filename paths, so this
assumption will be usually be wrong!</STRONG> There you have to use the
<CODE>RewriteBase</CODE> directive to specify the correct URL-prefix.

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice:</STRONG> If your webserver's URLs are <STRONG>not</STRONG>
directly related to physical file paths, you have to use
<CODE>RewriteBase</CODE> in every
<CODE>.htaccess</CODE> files where you want to use <CODE>RewriteRule</CODE>
d392 2
a393 2
</TD></TR>
</TABLE>
d395 2
a396 2
<P>
<STRONG>Example:</STRONG>
d398 1
a398 1
<BLOCKQUOTE>
d401 3
a403 3
<P>
<TABLE BORDER=0 CELLSPACING=1 CELLPADDING=5 BGCOLOR="#F0F0F0">
<TR><TD><PRE>
d406 2
a407 2
#  Remember: /abc/def is the physical path of /xyz, <EM>i.e.</EM>, the server
#            has a 'Alias /xyz /abc/def' directive <EM>e.g.</EM>
d418 2
a419 2
</PRE></TD></TR>
</TABLE>
d421 9
a429 10
<P>
In the above example, a request to <CODE>/xyz/oldstuff.html</CODE>
gets correctly
rewritten to the physical file <CODE>/abc/def/newstuff.html</CODE>.

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<FONT SIZE=-1>
<STRONG>Notice - For the Apache hackers:</STRONG><BR>
d433 2
a434 2
<P>
<PRE>
d439 4
a442 4
  /xyz/oldstuff.html     -&gt; /abc/def/oldstuff.html  (per-server Alias)
  /abc/def/oldstuff.html -&gt; /abc/def/newstuff.html  (per-dir    RewriteRule)
  /abc/def/newstuff.html -&gt; /xyz/newstuff.html      (per-dir    RewriteBase)
  /xyz/newstuff.html     -&gt; /abc/def/newstuff.html  (per-server Alias)
d446 1
a446 1
</PRE>
d455 19
a473 46
</FONT>
</TD></TR>
</TABLE>

</BLOCKQUOTE>


<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteCond">RewriteCond</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> <CODE>RewriteCond</CODE> <EM>TestString</EM>
    <EM>CondPattern</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> <EM>None</EM><BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> server config, virtual host, directory,
     .htaccess<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> <EM>FileInfo</EM><BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2 (partially), Apache 1.3<BR>

<P>
The <CODE>RewriteCond</CODE> directive defines a rule condition. Precede a
<CODE>RewriteRule</CODE> directive with one or more <CODE>RewriteCond</CODE>
d477 4
a480 2
state of the URI <STRONG>and</STRONG> if these additional conditions apply
too.
d482 3
a484 36
<P>
<EM>TestString</EM> is a string which can contains the following
expanded constructs in addition to plain text:

<UL>
<LI><STRONG>RewriteRule backreferences</STRONG>: These are backreferences of
    the form

<BLOCKQUOTE><STRONG>
<CODE>$N</CODE>
</STRONG></BLOCKQUOTE>

(1 &lt;= N &lt;= 9) which provide access to the grouped parts (parenthesis!)
of the
pattern from the corresponding <CODE>RewriteRule</CODE> directive (the one
following the current bunch of <CODE>RewriteCond</CODE> directives).

<P>
<LI><STRONG>RewriteCond backreferences</STRONG>: These are backreferences of
the form

<BLOCKQUOTE><STRONG>
<CODE>%N</CODE>
</STRONG></BLOCKQUOTE>

(1 &lt;= N &lt;= 9) which provide access to the grouped parts (parenthesis!) of
the pattern from the last matched <CODE>RewriteCond</CODE> directive in the
current bunch of conditions.

<P>
<LI><STRONG>Server-Variables</STRONG>: These are variables
    of the form

<BLOCKQUOTE><STRONG>
<CODE>%{</CODE> <EM>NAME_OF_VARIABLE</EM> <CODE>}</CODE>
</STRONG></BLOCKQUOTE>
d486 1
a486 1
where <EM>NAME_OF_VARIABLE</EM> can be a string
d489 60
a548 81
<P>
<TABLE BGCOLOR="#F0F0F0" CELLSPACING=0 CELLPADDING=5>
<TR>
<TD VALIGN=TOP>
<STRONG>HTTP headers:</STRONG><P>
<FONT SIZE=-1>
HTTP_USER_AGENT<BR>
HTTP_REFERER<BR>
HTTP_COOKIE<BR>
HTTP_FORWARDED<BR>
HTTP_HOST<BR>
HTTP_PROXY_CONNECTION<BR>
HTTP_ACCEPT<BR>
</FONT>
</TD>

<TD VALIGN=TOP>
<STRONG>connection &amp; request:</STRONG><P>
<FONT SIZE=-1>
REMOTE_ADDR<BR>
REMOTE_HOST<BR>
REMOTE_USER<BR>
REMOTE_IDENT<BR>
REQUEST_METHOD<BR>
SCRIPT_FILENAME<BR>
PATH_INFO<BR>
QUERY_STRING<BR>
AUTH_TYPE<BR>
</FONT>
</TD>

</TR>
<TR>

<TD VALIGN=TOP>
<STRONG>server internals:</STRONG><P>
<FONT SIZE=-1>
DOCUMENT_ROOT<BR>
SERVER_ADMIN<BR>
SERVER_NAME<BR>
SERVER_PORT<BR>
SERVER_PROTOCOL<BR>
SERVER_SOFTWARE<BR>
</FONT>
</TD>

<TD VALIGN=TOP>
<STRONG>system stuff:</STRONG><P>
<FONT SIZE=-1>
TIME_YEAR<BR>
TIME_MON<BR>
TIME_DAY<BR>
TIME_HOUR<BR>
TIME_MIN<BR>
TIME_SEC<BR>
TIME_WDAY<BR>
TIME<BR>
</FONT>
</TD>

<TD VALIGN=TOP>
<STRONG>specials:</STRONG><P>
<FONT SIZE=-1>
API_VERSION<BR>
THE_REQUEST<BR>
REQUEST_URI<BR>
REQUEST_FILENAME<BR>
IS_SUBREQ<BR>
</FONT>
</TD>
</TR>
</TABLE>

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice:</STRONG> These variables all correspond to the similar named
HTTP MIME-headers, C variables of the Apache server or <CODE>struct tm</CODE>
fields of the Unix system.
</TD></TR>
</TABLE>
d550 22
a571 1
</UL>
d573 1
a573 1
<P>
d575 4
a578 7

<OL>
<LI>The variables SCRIPT_FILENAME and REQUEST_FILENAME contain the same
value, <EM>i.e.</EM>, the value of the <CODE>filename</CODE> field of
the internal
<CODE>request_rec</CODE> structure of the Apache server. The first name is
just the
d580 2
a581 2
counterpart to REQUEST_URI (which contains the value of the <CODE>uri</CODE>
field of <CODE>request_rec</CODE>).
d583 40
a622 51
<P>
<LI>There is the special format: <CODE>%{ENV:variable}</CODE> where
<EM>variable</EM> can be any environment variable. This is looked-up via
internal Apache structures and (if not found there) via <CODE>getenv()</CODE>
from the Apache server process.

<P>
<LI>There is the special format: <CODE>%{HTTP:header}</CODE> where
<EM>header</EM> can be any HTTP MIME-header name. This is looked-up
from the HTTP request. Example: <CODE>%{HTTP:Proxy-Connection}</CODE>
is the value of the HTTP header ``<CODE>Proxy-Connection:</CODE>''.

<P>
<LI>There is the special format <CODE>%{LA-U:variable}</CODE> for look-aheads
which perform an internal (URL-based) sub-request to determine the final value
of <EM>variable</EM>. Use this when you want to use a variable for rewriting
which actually is set later in an API phase and thus is not available at the
current stage. For instance when you want to rewrite according to the
<CODE>REMOTE_USER</CODE> variable from within the per-server context
(<CODE>httpd.conf</CODE> file) you have to use <CODE>%{LA-U:REMOTE_USER}</CODE>
because this variable is set by the authorization phases which come
<EM>after</EM> the URL translation phase where mod_rewrite operates. On the
other hand, because mod_rewrite implements its per-directory context
(<CODE>.htaccess</CODE> file) via the Fixup phase of the API and because the
authorization phases come <EM>before</EM> this phase, you just can use
<CODE>%{REMOTE_USER}</CODE> there.

<P>
<LI>There is the special format: <CODE>%{LA-F:variable}</CODE> which perform an
internal (filename-based) sub-request to determine the final value of
<EM>variable</EM>. This is the most of the time the same as LA-U above.
</OL>

<P>
<EM>CondPattern</EM> is the condition pattern, <EM>i.e.</EM>, a regular
expression
which gets applied to the current instance of the <EM>TestString</EM>,
<EM>i.e.</EM>, <EM>TestString</EM> gets evaluated and then matched against
<EM>CondPattern</EM>.

<P>
<STRONG>Remember:</STRONG> <EM>CondPattern</EM> is a standard
<EM>Extended Regular Expression</EM> with some additions:

<OL>
<LI>You can precede the pattern string with a '<CODE>!</CODE>' character
(exclamation mark) to specify a <STRONG>non</STRONG>-matching pattern.

<P>
<LI>
There are some special variants of <EM>CondPatterns</EM>. Instead of real
d624 16
a639 16
<P>
<UL>
<LI>'<STRONG>&lt;CondPattern</STRONG>' (is lexicographically lower)<BR>
Treats the <EM>CondPattern</EM> as a plain string and compares it
lexicographically to <EM>TestString</EM> and results in a true expression if
<EM>TestString</EM> is lexicographically lower than <EM>CondPattern</EM>.
<P>
<LI>'<STRONG>&gt;CondPattern</STRONG>' (is lexicographically greater)<BR>
Treats the <EM>CondPattern</EM> as a plain string and compares it
lexicographically to <EM>TestString</EM> and results in a true expression if
<EM>TestString</EM> is lexicographically greater than <EM>CondPattern</EM>.
<P>
<LI>'<STRONG>=CondPattern</STRONG>' (is lexicographically equal)<BR>
Treats the <EM>CondPattern</EM> as a plain string and compares it
lexicographically to <EM>TestString</EM> and results in a true expression if
<EM>TestString</EM> is lexicographically equal to <EM>CondPattern</EM>, i.e the
d641 3
a643 5
If <EM>CondPattern</EM> is just <SAMP>""</SAMP> (two quotation marks) this
compares <EM>TestString</EM> against the empty string.
<P>
<LI>'<STRONG>-d</STRONG>' (is <STRONG>d</STRONG>irectory)<BR>
Treats the <EM>TestString</EM> as a pathname and
d645 3
a647 3
<P>
<LI>'<STRONG>-f</STRONG>' (is regular <STRONG>f</STRONG>ile)<BR>
Treats the <EM>TestString</EM> as a pathname and
d649 7
a655 7
<P>
<LI>'<STRONG>-s</STRONG>' (is regular file with <STRONG>s</STRONG>ize)<BR>
Treats the <EM>TestString</EM> as a pathname and
tests if it exists and is a regular file with size greater than zero.
<P>
<LI>'<STRONG>-l</STRONG>' (is symbolic <STRONG>l</STRONG>ink)<BR>
Treats the <EM>TestString</EM> as a pathname and
d657 3
a659 3
<P>
<LI>'<STRONG>-F</STRONG>' (is existing file via subrequest)<BR>
Checks if <EM>TestString</EM> is a valid file and accessible via all the
d663 3
a665 4
<P>
<LI>'<STRONG>-U</STRONG>' (is existing URL via subrequest)<BR>
Checks if <EM>TestString</EM> is a valid URL and accessible via all the
server's
d668 4
a671 7
your server's performance!
</UL>
<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice:</STRONG>
All of these tests can also be prefixed by a not ('!') character
d673 8
a680 10
</TD></TR>
</TABLE>
</OL>

<P>
Additionally you can set special flags for <EM>CondPattern</EM> by appending

<BLOCKQUOTE><STRONG>
<CODE>[</CODE><EM>flags</EM><CODE>]</CODE>
</STRONG></BLOCKQUOTE>
d682 1
a682 1
as the third argument to the <CODE>RewriteCond</CODE> directive. <EM>Flags</EM>
d685 3
a687 3
<UL>
<LI>'<STRONG><CODE>nocase|NC</CODE></STRONG>' (<STRONG>n</STRONG>o <STRONG>c</STRONG>ase)<BR>
    This makes the condition test case-insensitive, <EM>i.e.</EM>, there is
d689 3
a691 3
    <EM>TestString</EM> and the <EM>CondPattern</EM>.
<P>
<LI>'<STRONG><CODE>ornext|OR</CODE></STRONG>' (<STRONG>or</STRONG> next condition)<BR>
d694 2
a695 2
    <P>
<BLOCKQUOTE><PRE>
d700 1
a700 1
</PRE></BLOCKQUOTE>
d702 1
a702 1
</UL>
d704 3
a706 3
<P>
<STRONG>Example:</STRONG>
<BLOCKQUOTE>
d708 1
a708 1
To rewrite the Homepage of a site according to the ``<CODE>User-Agent:</CODE>''
d711 1
a711 1
<BLOCKQUOTE><PRE>
d719 1
a719 1
</PRE></BLOCKQUOTE>
d723 2
a724 2
Frames, <EM>etc.</EM> If you use the Lynx browser (which is Terminal-based), then you
get the min homepage, which contains no images, no tables, <EM>etc.</EM>  If you
d726 1
a726 1
</BLOCKQUOTE>
d728 8
a735 33
<P>
<HR NOSHADE SIZE=1>
<P>

<H3><A NAME="RewriteRule">RewriteRule</A></H3>
<A
 HREF="directive-dict.html#Syntax"
 REL="Help"
><STRONG>Syntax:</STRONG></A> <CODE>RewriteRule</CODE> <EM>Pattern</EM> <EM>Substitution</EM><BR>
<A
 HREF="directive-dict.html#Default"
 REL="Help"
><STRONG>Default:</STRONG></A> <EM>None</EM><BR>
<A
 HREF="directive-dict.html#Context"
 REL="Help"
><STRONG>Context:</STRONG></A> server config, virtual host, directory, .htaccess<BR>
<A
 HREF="directive-dict.html#Override"
 REL="Help"
><STRONG>Override:</STRONG></A> <EM>FileInfo</EM><BR>
<A
 HREF="directive-dict.html#Status"
 REL="Help"
><STRONG>Status:</STRONG></A> Extension<BR>
<A
 HREF="directive-dict.html#Module"
 REL="Help"
><STRONG>Module:</STRONG></A> mod_rewrite.c<BR>
<A
 HREF="directive-dict.html#Compatibility"
 REL="Help"
><STRONG>Compatibility:</STRONG></A> Apache 1.2 (partially), Apache 1.3<BR>
d737 2
a738 2
<P>
The <CODE>RewriteRule</CODE> directive is the real rewriting workhorse.  The
d740 2
a741 2
rewriting rule.  The <STRONG>definition order</STRONG> of these rules is
<STRONG>important</STRONG>, because this order is used when applying the rules at
d744 3
a746 3
<P>
<A NAME="patterns"><EM>Pattern</EM></A> can be (for Apache 1.1.x a System
V8 and for Apache 1.2.x a POSIX) <A NAME="regexp">regular expression</A>
d752 1
a752 1
<P>
d755 35
a789 60
<P>
<TABLE BGCOLOR="#F0F0F0" CELLSPACING=0 CELLPADDING=5>
<TR>
<TD VALIGN=TOP>
<PRE>
<STRONG>Text:</STRONG>
  <STRONG><CODE>.</CODE></STRONG>           Any single character
  <STRONG><CODE>[</CODE></STRONG>chars<STRONG><CODE>]</CODE></STRONG>     Character class: One  of chars
  <STRONG><CODE>[^</CODE></STRONG>chars<STRONG><CODE>]</CODE></STRONG>    Character class: None of chars
  text1<STRONG><CODE>|</CODE></STRONG>text2 Alternative: text1 or text2

<STRONG>Quantifiers:</STRONG>
  <STRONG><CODE>?</CODE></STRONG>           0 or 1 of the preceding text
  <STRONG><CODE>*</CODE></STRONG>           0 or N of the preceding text (N &gt; 1)
  <STRONG><CODE>+</CODE></STRONG>           1 or N of the preceding text (N &gt; 1)

<STRONG>Grouping:</STRONG>
  <STRONG><CODE>(</CODE></STRONG>text<STRONG><CODE>)</CODE></STRONG>      Grouping of text
              (either to set the borders of an alternative or
              for making backreferences where the <STRONG>N</STRONG>th group can 
              be used on the RHS of a RewriteRule with <CODE>$</CODE><STRONG>N</STRONG>)

<STRONG>Anchors:</STRONG>
  <STRONG><CODE>^</CODE></STRONG>           Start of line anchor
  <STRONG><CODE>$</CODE></STRONG>           End   of line anchor

<STRONG>Escaping:</STRONG>
  <STRONG><CODE>\</CODE></STRONG>char       escape that particular char
              (for instance to specify the chars "<CODE>.[]()</CODE>" <EM>etc.</EM>)
</PRE>
</TD>
</TR>
</TABLE>

<P>
For more information about regular expressions either have a look at your
local regex(3) manpage or its <CODE>src/regex/regex.3</CODE> copy in the
Apache 1.3 distribution.  When you are interested in more detailed and deeper
information about regular expressions and its variants (POSIX regex, Perl
regex, <EM>etc.</EM>) have a look at the following dedicated book on this topic: 

<BLOCKQUOTE>
<EM>Mastering Regular Expressions</EM><BR>
Jeffrey E.F. Friedl<BR>
Nutshell Handbook Series<BR>
O'Reilly &amp; Associates, Inc. 1997<BR>
ISBN 1-56592-257-3<BR>
</BLOCKQUOTE>

<P>
Additionally in mod_rewrite the NOT character ('<CODE>!</CODE>') is a possible
pattern prefix. This gives you the ability to negate a pattern; to say, for
instance: ``<EM>if the current URL does <STRONG>NOT</STRONG> match to this
pattern</EM>''. This can be used for special cases where it is better to match
the negative pattern or as a last default rule.

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice:</STRONG> When using the NOT character to negate a pattern you cannot
d792 1
a792 1
consequence, if negated patterns are used, you cannot use <CODE>$N</CODE> in the
d794 2
a795 2
</TD></TR>
</TABLE>
d797 2
a798 2
<P>
<A NAME="rhs"><EM>Substitution</EM></A> of a rewriting rule is the string
d800 1
a800 1
<EM>Pattern</EM> matched.  Beside plain text you can use
d802 11
a812 12
<OL>
<LI>back-references <CODE>$N</CODE> to the RewriteRule pattern
<LI>back-references <CODE>%N</CODE> to the last matched RewriteCond pattern
<LI>server-variables as in rule condition test-strings (<CODE>%{VARNAME}</CODE>)
<LI><A HREF="#mapfunc">mapping-function</A> calls (<CODE>${mapname:key|default}</CODE>)
</OL>

Back-references are <CODE>$</CODE><STRONG>N</STRONG> (<STRONG>N</STRONG>=1..9) identifiers which
will be replaced by the contents of the <STRONG>N</STRONG>th group of the matched
<EM>Pattern</EM>. The server-variables are the same as for the
<EM>TestString</EM> of a <CODE>RewriteCond</CODE> directive. The
mapping-functions come from the <CODE>RewriteMap</CODE> directive and are
d816 1
a816 1
<P>
d818 2
a819 2
<EM>Substitution</EM> (in the order of definition in the config file).  The
URL is <STRONG>completely replaced</STRONG> by the <EM>Substitution</EM> and the
d821 1
a821 1
terminated by a <CODE><STRONG>L</STRONG></CODE> flag - see below).
d823 5
a827 5
<P>
There is a special substitution string named '<CODE>-</CODE>' which means:
<STRONG>NO substitution</STRONG>! Sounds silly? No, it is useful to provide rewriting
rules which <STRONG>only</STRONG> match some URLs but do no substitution, <EM>e.g.</EM>, in
conjunction with the <STRONG>C</STRONG> (chain) flag to be able to have more than one
d830 1
a830 1
<P>
d837 6
a842 6
<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice</STRONG>: There is a special feature. When you prefix a substitution
field with <CODE>http://</CODE><EM>thishost</EM>[<EM>:thisport</EM>] then
<STRONG>mod_rewrite</STRONG> automatically strips it out.   This auto-reduction on
d847 4
a850 9
</TD></TR>
</TABLE>

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Remember:</STRONG> An unconditional external redirect to your own server will
not work with the prefix <CODE>http://thishost</CODE> because of this feature.
To achieve such a self-redirect, you have to use the <STRONG>R</STRONG>-flag (see
d852 2
a853 2
</TD></TR>
</TABLE>
d855 2
a856 2
<P>
Additionally you can set special flags for <EM>Substitution</EM> by appending
d858 3
a860 3
<BLOCKQUOTE><STRONG>
<CODE>[</CODE><EM>flags</EM><CODE>]</CODE>
</STRONG></BLOCKQUOTE>
d862 1
a862 1
as the third argument to the <CODE>RewriteRule</CODE> directive. <EM>Flags</EM> is a
d865 5
a869 5
<UL>
<LI>'<STRONG><CODE>redirect|R</CODE> [=<EM>code</EM>]</STRONG>' (force <A NAME="redirect"><STRONG>r</STRONG>edirect</A>)<BR>
    Prefix <EM>Substitution</EM>
    with <CODE>http://thishost[:thisport]/</CODE> (which makes the new URL a URI) to
    force a external redirection. If no <EM>code</EM> is given a HTTP response
d872 2
a873 2
    one of the following symbolic names: <CODE>temp</CODE> (default), <CODE>permanent</CODE>,
    <CODE>seeother</CODE>.
d875 5
a879 5
    canonicalize the URL and gives it back to the client, <EM>e.g.</EM>, translate
    ``<CODE>/~</CODE>'' into ``<CODE>/u/</CODE>'' or always append a slash to
    <CODE>/u/</CODE><EM>user</EM>, etc.<BR>
    <P>
    <STRONG>Notice:</STRONG> When you use this flag, make sure that the
d882 1
a882 1
    URL with <CODE>http://thishost[:thisport]/</CODE>, but rewriting goes on.
d885 3
a887 3
<P>
<LI>'<STRONG><CODE>forbidden|F</CODE></STRONG>' (force URL to be <STRONG>f</STRONG>orbidden)<BR>
    This forces the current URL to be forbidden, <EM>i.e.</EM>, it immediately sends
d890 3
a892 3
<P>
<LI>'<STRONG><CODE>gone|G</CODE></STRONG>' (force URL to be <STRONG>g</STRONG>one)<BR>
    This forces the current URL to be gone, <EM>i.e.</EM>, it immediately sends back a
d895 2
a896 2
<P>
<LI>'<STRONG><CODE>proxy|P</CODE></STRONG>' (force <STRONG>p</STRONG>roxy)<BR>
d898 15
a912 17
    request and immediately (<EM>i.e.</EM>, rewriting rule processing stops here) put
    through the <A HREF="mod_proxy.html">proxy module</A>. You have to make
    sure that the substitution string is a valid URI (<EM>e.g.</EM>,  typically starting
    with <CODE>http://</CODE><EM>hostname</EM>) which can be handled by the
    Apache proxy module. If not you get an error from the proxy module. Use
    this flag to achieve a more powerful implementation of the <A
    HREF="mod_proxy.html#proxypass">ProxyPass</A> directive, to map some
    remote stuff into the namespace of the local server.
    <P>
    Notice: To use this functionality make sure you have the proxy module
    compiled into your Apache server program.  If you don't know please check
    whether <CODE>mod_proxy.c</CODE> is part of the ``<CODE>httpd -l</CODE>''
    output. If yes, this functionality is available to mod_rewrite. If not,
    then you first have to rebuild the ``<CODE>httpd</CODE>'' program with
    mod_proxy enabled.
<P>
<LI>'<STRONG><CODE>last|L</CODE></STRONG>' (<STRONG>l</STRONG>ast rule)<BR>
d915 1
a915 1
    <CODE>last</CODE> command or the <CODE>break</CODE> command from the C
d918 4
a921 4
    example, use it to rewrite the root-path URL ('<CODE>/</CODE>') to a real
    one, <EM>e.g.</EM>, '<CODE>/e/www/</CODE>'.
<P>
<LI>'<STRONG><CODE>next|N</CODE></STRONG>' (<STRONG>n</STRONG>ext round)<BR>
d925 6
a930 6
    <CODE>next</CODE> command or the <CODE>continue</CODE> command from the C
    language. Use this flag to restart the rewriting process, <EM>i.e.</EM>,  to
    immediately go to the top of the loop. <BR>
    <STRONG>But be careful not to create a deadloop!</STRONG>
<P>
<LI>'<STRONG><CODE>chain|C</CODE></STRONG>' (<STRONG>c</STRONG>hained with next rule)<BR>
d932 3
a934 3
    also be chained with its following rule, <EM>etc.</EM>). This has the following
    effect: if a rule matches, then processing continues as usual, <EM>i.e.</EM>, the
    flag has no effect. If the rule does <STRONG>not</STRONG> match, then all following
d936 2
a937 2
    ``<CODE>.www</CODE>'' part inside a per-directory rule set when you let an
    external redirect happen (where the ``<CODE>.www</CODE>'' part should not to
d939 5
a943 5
<P>
<LI>'<STRONG><CODE>type|T</CODE></STRONG>=<EM>MIME-type</EM>' (force MIME <STRONG>t</STRONG>ype)<BR>
    Force the MIME-type of the target file to be <EM>MIME-type</EM>. For
    instance, this can be used to simulate the old <CODE>mod_alias</CODE>
    directive <CODE>ScriptAlias</CODE> which internally forces all files inside
d945 3
a947 3
    ``<CODE>application/x-httpd-cgi</CODE>''.
<P>
<LI>'<STRONG><CODE>nosubreq|NS</CODE></STRONG>' (used only if <STRONG>n</STRONG>o internal <STRONG>s</STRONG>ub-request)<BR>
d950 2
a951 2
    occur internally in Apache when <CODE>mod_include</CODE> tries to find out
    information about possible directory default files (<CODE>index.xxx</CODE>).
d953 2
a954 2
    if the complete set of rules are applied. Use this flag to exclude some rules.<BR>
    <P>
d959 3
a961 3
<P>
<LI>'<STRONG><CODE>qsappend|QSA</CODE></STRONG>' (<STRONG>q</STRONG>uery <STRONG>s</STRONG>tring
    <STRONG>a</STRONG>ppend)<BR> 
d966 7
a972 7
<P>
<LI>'<STRONG><CODE>passthrough|PT</CODE></STRONG>' (<STRONG>p</STRONG>ass <STRONG>t</STRONG>hrough to next handler)<BR>
    This flag forces the rewriting engine to set the <CODE>uri</CODE> field
    of the internal <CODE>request_rec</CODE> structure to the value
    of the <CODE>filename</CODE> field.  This flag is just a hack to be able
    to post-process the output of <CODE>RewriteRule</CODE> directives by
    <CODE>Alias</CODE>, <CODE>ScriptAlias</CODE>, <CODE>Redirect</CODE>, <EM>etc.</EM> directives
d975 4
a978 4
    If you want to rewrite <CODE>/abc</CODE> to <CODE>/def</CODE> via the rewriting
    engine of <CODE>mod_rewrite</CODE> and then <CODE>/def</CODE> to <CODE>/ghi</CODE>
    with <CODE>mod_alias</CODE>:
    <PRE>
d981 5
a985 5
    </PRE>
    If you omit the <CODE>PT</CODE> flag then <CODE>mod_rewrite</CODE>
    will do its job fine, <EM>i.e.</EM>, it rewrites <CODE>uri=/abc/...</CODE> to
    <CODE>filename=/def/...</CODE> as a full API-compliant URI-to-filename
    translator should do. Then <CODE>mod_alias</CODE> comes and tries to do a
d987 8
a994 8
    <P>
    Notice: <STRONG>You have to use this flag if you want to intermix directives
    of different modules which contain URL-to-filename translators</STRONG>. The
    typical example is the use of <CODE>mod_alias</CODE> and
    <CODE>mod_rewrite</CODE>..
<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
d996 1
a996 1
    <STRONG>Notice - For the Apache hackers:</STRONG><BR>
d1002 6
a1007 6
</FONT>
</TD></TR>
</TABLE>
<P>
<LI>'<STRONG><CODE>skip|S</CODE></STRONG>=<EM>num</EM>' (<STRONG>s</STRONG>kip next rule(s))<BR>
    This flag forces the rewriting engine to skip the next <EM>num</EM> rules
d1010 20
a1029 20
    a <CODE>skip=N</CODE> where N is the number of rules in the else-clause.
    (This is <STRONG>not</STRONG> the same as the 'chain|C' flag!)
<P>
<LI>'<STRONG><CODE>env|E=</CODE></STRONG><EM>VAR</EM>:<EM>VAL</EM>' (set <STRONG>e</STRONG>nvironment variable)<BR>
    This forces an environment variable named <EM>VAR</EM> to be set to the
    value <EM>VAL</EM>, where <EM>VAL</EM> can contain regexp backreferences
    <CODE>$N</CODE> and <CODE>%N</CODE> which will be expanded. You can use this flag
    more than once to set more than one variable. The variables can be later
    dereferenced at a lot of situations, but the usual location will be from
    within XSSI (via <CODE>&lt;!--#echo var="VAR"--&gt;</CODE>) or CGI (<EM>e.g.</EM>
    <CODE>$ENV{'VAR'}</CODE>).  But additionally you can also dereference it in a
    following RewriteCond pattern via <CODE>%{ENV:VAR}</CODE>. Use this to strip
    but remember information from URLs.
</UL>

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice:</STRONG> Never forget that <EM>Pattern</EM> gets applied to a complete URL
in per-server configuration files. <STRONG>But in per-directory configuration
d1031 2
a1032 2
directory!) gets automatically <EM>removed</EM> for the pattern matching and
automatically <EM>added</EM> after the substitution has been done.</STRONG> This feature is
d1035 1
a1035 1
<P>
d1037 12
a1048 12
``<CODE>http://</CODE>'' then the directory prefix will be <STRONG>not</STRONG> added and a
external redirect or proxy throughput (if flag <STRONG>P</STRONG> is used!) is forced!
</TD></TR>
</TABLE>

<P>
<TABLE WIDTH="70%" BORDER=0 BGCOLOR="#E0E0F0" CELLSPACING=0 CELLPADDING=10>
<TR><TD>
<STRONG>Notice:</STRONG> To enable the rewriting engine for per-directory configuration files
you need to set ``<CODE>RewriteEngine On</CODE>'' in these files <STRONG>and</STRONG>
``<CODE>Option FollowSymLinks</CODE>'' enabled. If your administrator has
disabled override of <CODE>FollowSymLinks</CODE> for a user's directory, then
d1051 2
a1052 2
</TD></TR>
</TABLE>
d1054 1
a1054 1
<P>
d1057 10
a1066 10
<P>
<STRONG>Inside per-server configuration (<CODE>httpd.conf</CODE>)<BR>
for request ``<CODE>GET /somepath/pathinfo</CODE>'':</STRONG><BR>

<P>
<TABLE BGCOLOR="#F0F0F0" CELLSPACING=0 CELLPADDING=5>
<TR>
<TD>
<PRE>
<STRONG>Given Rule</STRONG>                                      <STRONG>Resulting Substitution</STRONG>
d1097 17
a1113 17
</PRE>
</TD>
</TR>
</TABLE>

<P>
<STRONG>Inside per-directory configuration for <CODE>/somepath</CODE><BR>
(<EM>i.e.</EM>, file <CODE>.htaccess</CODE> in dir <CODE>/physical/path/to/somepath</CODE> containing
<CODE>RewriteBase /somepath</CODE>)<BR> for
request ``<CODE>GET /somepath/localpath/pathinfo</CODE>'':</STRONG><BR>

<P>
<TABLE BGCOLOR="#F0F0F0" CELLSPACING=0 CELLPADDING=5>
<TR>
<TD>
<PRE>
<STRONG>Given Rule</STRONG>                                      <STRONG>Resulting Substitution</STRONG>
d1145 10
a1154 9
</PRE>
</TD>
</TR>
</TABLE>

<P>
<STRONG>Example:</STRONG>
<P>
<BLOCKQUOTE>
d1156 5
a1160 5
<BLOCKQUOTE>
<CODE>/</CODE> <EM>Language</EM>
<CODE>/~</CODE> <EM>Realname</EM>
<CODE>/.../</CODE> <EM>File</EM>
</BLOCKQUOTE>
d1162 6
a1167 6
<BLOCKQUOTE>
<CODE>/u/</CODE> <EM>Username</EM>
<CODE>/.../</CODE> <EM>File</EM>
<CODE>.</CODE> <EM>Language</EM>
</BLOCKQUOTE>
<P>
d1169 1
a1169 1
<CODE>/path/to/file/map.txt</CODE>. Then we only have to add the
d1172 4
a1175 4
<BLOCKQUOTE>
<PRE>
RewriteLog   /path/to/file/rewrite.log
RewriteMap   real-to-user               txt:/path/to/file/map.txt
d1177 18
a1194 16
</PRE>
</BLOCKQUOTE>

</BLOCKQUOTE>

<P>
<HR NOSHADE SIZE=1>

<CENTER>
<H1><A NAME="Miscelleneous">Miscellaneous</A></H1>
</CENTER>

<P>
<HR NOSHADE SIZE=1>

<H2><A NAME="EnvVar">Environment Variables</A></H2>
d1197 8
a1204 8
variables named <CODE>SCRIPT_URL</CODE> and <CODE>SCRIPT_URI</CODE>. These contain
the <EM>logical</EM> Web-view to the current resource, while the standard CGI/SSI
variables <CODE>SCRIPT_NAME</CODE> and <CODE>SCRIPT_FILENAME</CODE> contain the
<EM>physical</EM> System-view. 

<P>
Notice: These variables hold the URI/URL <EM>as they were initially
requested</EM>, <EM>i.e.</EM>, in a state <EM>before</EM> any rewriting. This is
d1208 2
a1209 2
<P>
<STRONG>Example:</STRONG>
d1211 3
a1213 3
<BLOCKQUOTE>
<PRE>
SCRIPT_NAME=/sw/lib/w3s/tree/global/u/rse/.www/index.html
d1216 4
a1219 18
SCRIPT_URI=http://en1.engelschall.com/u/rse/
</PRE>
</BLOCKQUOTE>

<P>
<HR NOSHADE SIZE=1>

<H2><A NAME="Solutions">Practical Solutions</A></H2>

There is a comprehensive collection of practical solutions for URL-based
problems available by the author of mod_rewrite.  Here you will find real-life
rulesets and additional information.

<BLOCKQUOTE>
<STRONG>Apache URL Rewriting Guide</STRONG><BR>
<STRONG><A HREF="http://www.engelschall.com/pw/apache/rewriteguide/"
        >http://www.engelschall.com/pw/apache/rewriteguide/</A></STRONG>
</BLOCKQUOTE>
a1221 1

d1223 1
a1223 1
 Apache HTTP Server Version 1.3
a1228 1
</BLOCKQUOTE><!-- page indentation -->
@


1.1.1.3
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d1 1
a1 2
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
d5 472
a476 485

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator" content="HTML Tidy, see www.w3.org" />

    <title>Apache module mod_rewrite</title>
  </head>
  <!-- Background white, links blue (unvisited), navy (visited), red (active) -->

  <body bgcolor="#FFFFFF" text="#000000" link="#0000FF"
  vlink="#000080" alink="#FF0000">
    <blockquote>
      <!-- page indentation -->
          <div align="CENTER">
      <img src="../images/sub.gif" alt="[APACHE DOCUMENTATION]" /> 

      <h3>Apache HTTP Server Version 1.3</h3>
    </div>

      <br />
       

      <h1 align="CENTER">Module mod_rewrite<br />
       URL Rewriting Engine</h1>

      <p>This module provides a rule-based rewriting engine to
      rewrite requested URLs on the fly.</p>

      <p><a href="module-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="module-dict.html#SourceFile"
      rel="Help"><strong>Source File:</strong></a>
      mod_rewrite.c<br />
       <a href="module-dict.html#ModuleIdentifier"
      rel="Help"><strong>Module Identifier:</strong></a>
      rewrite_module<br />
       <a href="module-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Available in
      Apache 1.2 and later.</p>
      <hr noshade="noshade" size="1" />
      <br />
       

      <h2>Summary</h2>

      <blockquote>
        <blockquote>
          <blockquote>
            <em>``The great thing about mod_rewrite is it gives you
            all the configurability and flexibility of Sendmail.
            The downside to mod_rewrite is that it gives you all
            the configurability and flexibility of Sendmail.''</em>
            

            <div align="RIGHT">
              -- Brian Behlendorf<br />
               Apache Group
            </div>
          </blockquote>
        </blockquote>
      </blockquote>

      <blockquote>
        <blockquote>
          <blockquote>
            <em>`` Despite the tons of examples and docs,
            mod_rewrite is voodoo. Damned cool voodoo, but still
            voodoo. ''</em> 

            <div align="RIGHT">
              -- Brian Moore<br />
               bem@@news.cmc.net
            </div>
          </blockquote>
        </blockquote>
      </blockquote>
      Welcome to mod_rewrite, the Swiss Army Knife of URL
      manipulation! 

      <p>This module uses a rule-based rewriting engine (based on a
      regular-expression parser) to rewrite requested URLs on the
      fly. It supports an unlimited number of rules and an
      unlimited number of attached rule conditions for each rule to
      provide a really flexible and powerful URL manipulation
      mechanism. The URL manipulations can depend on various tests,
      for instance server variables, environment variables, HTTP
      headers, time stamps and even external database lookups in
      various formats can be used to achieve a really granular URL
      matching.</p>

      <p>This module operates on the full URLs (including the
      path-info part) both in per-server context
      (<code>httpd.conf</code>) and per-directory context
      (<code>.htaccess</code>) and can even generate query-string
      parts on result. The rewritten result can lead to internal
      sub-processing, external request redirection or even to an
      internal proxy throughput.</p>

      <p>But all this functionality and flexibility has its
      drawback: complexity. So don't expect to understand this
      entire module in just one day.</p>

      <p>This module was invented and originally written in April
      1996<br />
       and gifted exclusively to the The Apache Group in July 1997
      by</p>

      <blockquote>
        <a href="http://www.engelschall.com/"><code>Ralf S.
        Engelschall</code></a><br />
         <a
        href="mailto:rse@@engelschall.com"><code>rse@@engelschall.com</code></a><br />
         <a
        href="http://www.engelschall.com/"><code>www.engelschall.com</code></a>
      </blockquote>
      <hr noshade="noshade" size="1" />

      <h2>Table Of Contents</h2>

      <p><strong>Internal Processing</strong></p>

      <ul>
        <li><a href="#InternalAPI">API Phases</a></li>

        <li><a href="#InternalRuleset">Ruleset Processing</a></li>

        <li><a href="#InternalBackRefs">Regex Back-Reference
        Availability</a></li>
      </ul>

      <p><strong>Configuration Directives</strong></p>

      <ul>
        <li><a href="#RewriteEngine">RewriteEngine</a></li>

        <li><a href="#RewriteOptions">RewriteOptions</a></li>

        <li><a href="#RewriteLog">RewriteLog</a></li>

        <li><a href="#RewriteLogLevel">RewriteLogLevel</a></li>

        <li><a href="#RewriteLock">RewriteLock</a></li>

        <li><a href="#RewriteMap">RewriteMap</a></li>

        <li><a href="#RewriteBase">RewriteBase</a></li>

        <li><a href="#RewriteCond">RewriteCond</a></li>

        <li><a href="#RewriteRule">RewriteRule</a></li>
      </ul>
      <strong>Miscellaneous</strong> 

      <ul>
        <li><a href="#EnvVar">Environment Variables</a></li>

        <li><a href="#Solutions">Practical Solutions</a></li>
      </ul>
      <hr noshade="noshade" size="1" />

      <center>
        <h1><a id="Internal" name="Internal">Internal
        Processing</a></h1>
      </center>
      <hr noshade="noshade" size="1" />

      <p>The internal processing of this module is very complex but
      needs to be explained once even to the average user to avoid
      common mistakes and to let you exploit its full
      functionality.</p>

      <h2><a id="InternalAPI" name="InternalAPI">API
      Phases</a></h2>

      <p>First you have to understand that when Apache processes a
      HTTP request it does this in phases. A hook for each of these
      phases is provided by the Apache API. Mod_rewrite uses two of
      these hooks: the URL-to-filename translation hook which is
      used after the HTTP request has been read but before any
      authorization starts and the Fixup hook which is triggered
      after the authorization phases and after the per-directory
      config files (<code>.htaccess</code>) have been read, but
      before the content handler is activated.</p>

      <p>So, after a request comes in and Apache has determined the
      corresponding server (or virtual server) the rewriting engine
      starts processing of all mod_rewrite directives from the
      per-server configuration in the URL-to-filename phase. A few
      steps later when the final data directories are found, the
      per-directory configuration directives of mod_rewrite are
      triggered in the Fixup phase. In both situations mod_rewrite
      rewrites URLs either to new URLs or to filenames, although
      there is no obvious distinction between them. This is a usage
      of the API which was not intended to be this way when the API
      was designed, but as of Apache 1.x this is the only way
      mod_rewrite can operate. To make this point more clear
      remember the following two points:</p>

      <ol>
        <li>Although mod_rewrite rewrites URLs to URLs, URLs to
        filenames and even filenames to filenames, the API
        currently provides only a URL-to-filename hook. In Apache
        2.0 the two missing hooks will be added to make the
        processing more clear. But this point has no drawbacks for
        the user, it is just a fact which should be remembered:
        Apache does more in the URL-to-filename hook than the API
        intends for it.</li>

        <li>
          Unbelievably mod_rewrite provides URL manipulations in
          per-directory context, <em>i.e.</em>, within
          <code>.htaccess</code> files, although these are reached
          a very long time after the URLs have been translated to
          filenames. It has to be this way because
          <code>.htaccess</code> files live in the filesystem, so
          processing has already reached this stage. In other
          words: According to the API phases at this time it is too
          late for any URL manipulations. To overcome this chicken
          and egg problem mod_rewrite uses a trick: When you
          manipulate a URL/filename in per-directory context
          mod_rewrite first rewrites the filename back to its
          corresponding URL (which is usually impossible, but see
          the <code>RewriteBase</code> directive below for the
          trick to achieve this) and then initiates a new internal
          sub-request with the new URL. This restarts processing of
          the API phases. 

          <p>Again mod_rewrite tries hard to make this complicated
          step totally transparent to the user, but you should
          remember here: While URL manipulations in per-server
          context are really fast and efficient, per-directory
          rewrites are slow and inefficient due to this chicken and
          egg problem. But on the other hand this is the only way
          mod_rewrite can provide (locally restricted) URL
          manipulations to the average user.</p>
        </li>
      </ol>

      <p>Don't forget these two points!</p>

      <h2><a id="InternalRuleset" name="InternalRuleset">Ruleset
      Processing</a></h2>
      Now when mod_rewrite is triggered in these two API phases, it
      reads the configured rulesets from its configuration
      structure (which itself was either created on startup for
      per-server context or during the directory walk of the Apache
      kernel for per-directory context). Then the URL rewriting
      engine is started with the contained ruleset (one or more
      rules together with their conditions). The operation of the
      URL rewriting engine itself is exactly the same for both
      configuration contexts. Only the final result processing is
      different. 

      <p>The order of rules in the ruleset is important because the
      rewriting engine processes them in a special (and not very
      obvious) order. The rule is this: The rewriting engine loops
      through the ruleset rule by rule (<code>RewriteRule</code>
      directives) and when a particular rule matches it optionally
      loops through existing corresponding conditions
      (<code>RewriteCond</code> directives). For historical reasons
      the conditions are given first, and so the control flow is a
      little bit long-winded. See Figure 1 for more details.</p>

      <div align="CENTER">
        <table cellspacing="0" cellpadding="2" border="0">
          <tr>
            <td bgcolor="#CCCCCC"><img
            src="../images/mod_rewrite_fig1.gif" width="428"
            height="385"
            alt="[Needs graphics capability to display]" /></td>
          </tr>

          <tr>
            <td align="CENTER"><strong>Figure 1:</strong> The
            control flow through the rewriting ruleset</td>
          </tr>
        </table>
      </div>

      <p>As you can see, first the URL is matched against the
      <em>Pattern</em> of each rule. When it fails mod_rewrite
      immediately stops processing this rule and continues with the
      next rule. If the <em>Pattern</em> matches, mod_rewrite looks
      for corresponding rule conditions. If none are present, it
      just substitutes the URL with a new value which is
      constructed from the string <em>Substitution</em> and goes on
      with its rule-looping. But if conditions exist, it starts an
      inner loop for processing them in the order that they are
      listed. For conditions the logic is different: we don't match
      a pattern against the current URL. Instead we first create a
      string <em>TestString</em> by expanding variables,
      back-references, map lookups, <em>etc.</em> and then we try
      to match <em>CondPattern</em> against it. If the pattern
      doesn't match, the complete set of conditions and the
      corresponding rule fails. If the pattern matches, then the
      next condition is processed until no more conditions are
      available. If all conditions match, processing is continued
      with the substitution of the URL with
      <em>Substitution</em>.</p>

      <h2><a id="quoting" name="quoting">Quoting Special
      Characters</a></h2>

      <p>As of Apache 1.3.20, special characters in
      <i>TestString</i> and <i>Substitution</i> strings can be
      escaped (that is, treated as normal characters without their
      usual special meaning) by prefixing them with a slosh ('\')
      character. In other words, you can include an actual
      dollar-sign character in a <i>Substitution</i> string by
      using '<code>\$</code>'; this keeps mod_rewrite from trying
      to treat it as a backreference.</p>

      <h2><a id="InternalBackRefs" name="InternalBackRefs">Regex
      Back-Reference Availability</a></h2>
      One important thing here has to be remembered: Whenever you
      use parentheses in <em>Pattern</em> or in one of the
      <em>CondPattern</em>, back-references are internally created
      which can be used with the strings <code>$N</code> and
      <code>%N</code> (see below). These are available for creating
      the strings <em>Substitution</em> and <em>TestString</em>.
      Figure 2 shows to which locations the back-references are
      transfered for expansion. 

      <div align="CENTER">
        <table cellspacing="0" cellpadding="2" border="0">
          <tr>
            <td bgcolor="#CCCCCC"><img
            src="../images/mod_rewrite_fig2.gif" width="381"
            height="179"
            alt="[Needs graphics capability to display]" /></td>
          </tr>

          <tr>
            <td align="CENTER"><strong>Figure 2:</strong> The
            back-reference flow through a rule</td>
          </tr>
        </table>
      </div>

      <p>We know this was a crash course on mod_rewrite's internal
      processing. But you will benefit from this knowledge when
      reading the following documentation of the available
      directives.</p>
      <hr noshade="noshade" size="1" />

      <center>
        <h1><a id="Configuration"
        name="Configuration">Configuration Directives</a></h1>
      </center>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteEngine"
      name="RewriteEngine">RewriteEngine</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteEngine
      on|off<br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> <code>RewriteEngine
      off</code><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config,
      virtual host, directory, .htaccess<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a> FileInfo<br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache
      1.2<br />
       

      <p>The <code>RewriteEngine</code> directive enables or
      disables the runtime rewriting engine. If it is set to
      <code>off</code> this module does no runtime processing at
      all. It does not even update the <code>SCRIPT_URx</code>
      environment variables.</p>

      <p>Use this directive to disable the module instead of
      commenting out all the <code>RewriteRule</code>
      directives!</p>

      <p>Note that, by default, rewrite configurations are not
      inherited. This means that you need to have a
      <code>RewriteEngine on</code> directive for each virtual host
      in which you wish to use it.</p>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteOptions"
      name="RewriteOptions">RewriteOptions</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteOptions
      <em>Option</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> <em>None</em><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config,
      virtual host, directory, .htaccess<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a> FileInfo<br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache
      1.2<br />
       

      <p>The <code>RewriteOptions</code> directive sets some
      special options for the current per-server or per-directory
      configuration. The <em>Option</em> strings can be one of the
      following:</p>

      <ul>
        <li>'<strong><code>inherit</code></strong>'<br />
         This forces the current configuration to inherit the
        configuration of the parent. In per-virtual-server context
        this means that the maps, conditions and rules of the main
        server are inherited. In per-directory context this means
        that conditions and rules of the parent directory's
        <code>.htaccess</code> configuration are inherited.</li>
      </ul>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteLog" name="RewriteLog">RewriteLog</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteLog
      <em>file-path</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> <em>None</em><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config,
      virtual host<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a> <em>Not
      applicable</em><br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache
      1.2<br />
       

      <p>The <code>RewriteLog</code> directive sets the name of the
      file to which the server logs any rewriting actions it
      performs. If the name does not begin with a slash
      ('<code>/</code>') then it is assumed to be relative to the
      <em>Server Root</em>. The directive should occur only once
      per server config.</p>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Note</strong>: To disable the logging of
          rewriting actions it is not recommended to set
          <em>Filename</em> to <code>/dev/null</code>, because
          although the rewriting engine does not then output to a
          logfile it still creates the logfile output internally.
          <strong>This will slow down the server with no advantage
          to the administrator!</strong> To disable logging either
          remove or comment out the <code>RewriteLog</code>
          directive or use <code>RewriteLogLevel 0</code>!</td>
        </tr>
      </table>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Security</strong>: See the <a
          href="../misc/security_tips.html">Apache Security
          Tips</a> document for details on why your security could
          be compromised if the directory where logfiles are stored
          is writable by anyone other than the user that starts the
          server.</td>
        </tr>
      </table>

      <p><strong>Example:</strong></p>

      <blockquote>
<pre>
d478 2
a479 45
</pre>
      </blockquote>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteLogLevel"
      name="RewriteLogLevel">RewriteLogLevel</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteLogLevel
      <em>Level</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a>
      <code>RewriteLogLevel 0</code><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config,
      virtual host<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a> <em>Not
      applicable</em><br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache
      1.2<br />
       

      <p>The <code>RewriteLogLevel</code> directive sets the
      verbosity level of the rewriting logfile. The default level 0
      means no logging, while 9 or more means that practically all
      actions are logged.</p>

      <p>To disable the logging of rewriting actions simply set
      <em>Level</em> to 0. This disables all rewrite action
      logs.</p>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Notice:</strong> Using a high value for
          <em>Level</em> will slow down your Apache server
          dramatically! Use the rewriting logfile at a
          <em>Level</em> greater than 2 only for debugging!</td>
        </tr>
      </table>
d481 63
a543 1
      <p><strong>Example:</strong></p>
d545 122
a666 110
      <blockquote>
<pre>
RewriteLogLevel 3
</pre>
      </blockquote>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteLock"
      name="RewriteLock">RewriteLock</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteLock
      <em>file-path</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> <em>None</em><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a> <em>Not
      applicable</em><br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache
      1.3<br />
       

      <p>This directive sets the filename for a synchronization
      lockfile which mod_rewrite needs to communicate with
      <samp>RewriteMap</samp> <em>programs</em>. Set this lockfile
      to a local path (not on a NFS-mounted device) when you want
      to use a rewriting map-program. It is not required for other
      types of rewriting maps.</p>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteMap" name="RewriteMap">RewriteMap</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteMap
      <em>MapName</em> <em>MapType</em>:<em>MapSource</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> not used per
      default<br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config,
      virtual host<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a> <em>Not
      applicable</em><br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache 1.2
      (partially), Apache 1.3<br />
       

      <p>The <code>RewriteMap</code> directive defines a
      <em>Rewriting Map</em> which can be used inside rule
      substitution strings by the mapping-functions to
      insert/substitute fields through a key lookup. The source of
      this lookup can be of various types.</p>

      <p>The <a id="mapfunc" name="mapfunc"><em>MapName</em></a> is
      the name of the map and will be used to specify a
      mapping-function for the substitution strings of a rewriting
      rule via one of the following constructs:</p>

      <blockquote>
        <strong><code>${</code> <em>MapName</em> <code>:</code>
        <em>LookupKey</em> <code>}</code><br />
         <code>${</code> <em>MapName</em> <code>:</code>
        <em>LookupKey</em> <code>|</code> <em>DefaultValue</em>
        <code>}</code></strong>
      </blockquote>
      When such a construct occurs the map <em>MapName</em> is
      consulted and the key <em>LookupKey</em> is looked-up. If the
      key is found, the map-function construct is substituted by
      <em>SubstValue</em>. If the key is not found then it is
      substituted by <em>DefaultValue</em> or by the empty string
      if no <em>DefaultValue</em> was specified. 

      <p>The following combinations for <em>MapType</em> and
      <em>MapSource</em> can be used:</p>

      <ul>
        <li>
          <strong>Standard Plain Text</strong><br />
           MapType: <code>txt</code>, MapSource: Unix filesystem
          path to valid regular file 

          <p>This is the standard rewriting map feature where the
          <em>MapSource</em> is a plain ASCII file containing
          either blank lines, comment lines (starting with a '#'
          character) or pairs like the following - one per
          line.</p>

          <blockquote>
            <strong><em>MatchingKey</em>
            <em>SubstValue</em></strong>
          </blockquote>

          <p>Example:</p>

          <table border="0" cellspacing="1" cellpadding="5"
          bgcolor="#F0F0F0">
            <tr>
              <td>
<pre>
d673 6
a678 10
</pre>
              </td>
            </tr>
          </table>

          <table border="0" cellspacing="1" cellpadding="5"
          bgcolor="#F0F0F0">
            <tr>
              <td>
<pre>
d680 22
a701 27
</pre>
              </td>
            </tr>
          </table>
        </li>

        <li>
          <strong>Randomized Plain Text</strong><br />
           MapType: <code>rnd</code>, MapSource: Unix filesystem
          path to valid regular file 

          <p>This is identical to the Standard Plain Text variant
          above but with a special post-processing feature: After
          looking up a value it is parsed according to contained
          ``<code>|</code>'' characters which have the meaning of
          ``or''. In other words they indicate a set of
          alternatives from which the actual returned value is
          chosen randomly. Although this sounds crazy and useless,
          it was actually designed for load balancing in a reverse
          proxy situation where the looked up values are server
          names. Example:</p>

          <table border="0" cellspacing="1" cellpadding="5"
          bgcolor="#F0F0F0">
            <tr>
              <td>
<pre>
d708 6
a713 10
</pre>
              </td>
            </tr>
          </table>

          <table border="0" cellspacing="1" cellpadding="5"
          bgcolor="#F0F0F0">
            <tr>
              <td>
<pre>
d715 15
a729 23
</pre>
              </td>
            </tr>
          </table>
        </li>

        <li>
          <strong>Hash File</strong><br />
           MapType: <code>dbm</code>, MapSource: Unix filesystem
          path to valid regular file 

          <p>Here the source is a binary NDBM format file
          containing the same contents as a <em>Plain Text</em>
          format file, but in a special representation which is
          optimized for really fast lookups. You can create such a
          file with any NDBM tool or with the following Perl
          script:</p>

          <table border="0" cellspacing="1" cellpadding="5"
          bgcolor="#F0F0F0">
            <tr>
              <td>
<pre>
a734 3
use NDBM_File;
use Fcntl;

d736 2
a737 4

open(TXT, "&lt;$txtmap") or die "Couldn't open $txtmap!\n";
tie (%DB, 'NDBM_File', $dbmmap,O_RDWR|O_TRUNC|O_CREAT, 0644) or die "Couldn't create $dbmmap!\n";

d739 2
a740 2
  next if (/^\s*#/ or /^\s*$/);
  $DB{$1} = $2 if (/^\s*(\S+)\s+(\S+)/);
d742 43
a784 76

untie %DB;
close(TXT);
</pre>
              </td>
            </tr>
          </table>

          <table border="0" cellspacing="1" cellpadding="5"
          bgcolor="#F0F0F0">
            <tr>
              <td>
<pre>
$ txt2dbm map.txt map.db
</pre>
              </td>
            </tr>
          </table>
        </li>

        <li>
          <strong>Internal Function</strong><br />
           MapType: <code>int</code>, MapSource: Internal Apache
          function 

          <p>Here the source is an internal Apache function.
          Currently you cannot create your own, but the following
          functions already exists:</p>

          <ul>
            <li><strong>toupper</strong>:<br />
             Converts the looked up key to all upper case.</li>

            <li><strong>tolower</strong>:<br />
             Converts the looked up key to all lower case.</li>

            <li><strong>escape</strong>:<br />
             Translates special characters in the looked up key to
            hex-encodings.</li>

            <li><strong>unescape</strong>:<br />
             Translates hex-encodings in the looked up key back to
            special characters.</li>
          </ul>
        </li>

        <li>
          <strong>External Rewriting Program</strong><br />
           MapType: <code>prg</code>, MapSource: Unix filesystem
          path to valid regular file 

          <p>Here the source is a program, not a map file. To
          create it you can use the language of your choice, but
          the result has to be a executable (<em>i.e.</em>, either
          object-code or a script with the magic cookie trick
          '<code>#!/path/to/interpreter</code>' as the first
          line).</p>

          <p>This program is started once at startup of the Apache
          servers and then communicates with the rewriting engine
          over its <code>stdin</code> and <code>stdout</code>
          file-handles. For each map-function lookup it will
          receive the key to lookup as a newline-terminated string
          on <code>stdin</code>. It then has to give back the
          looked-up value as a newline-terminated string on
          <code>stdout</code> or the four-character string
          ``<code>NULL</code>'' if it fails (<em>i.e.</em>, there
          is no corresponding value for the given key). A trivial
          program which will implement a 1:1 map (<em>i.e.</em>,
          key == value) could be:</p>

          <table border="0" cellspacing="1" cellpadding="5"
          bgcolor="#F0F0F0">
            <tr>
              <td>
<pre>
d788 2
a789 1
    # ...put here any transformations or lookups...
d792 107
a898 108
</pre>
              </td>
            </tr>
          </table>

          <p>But be very careful:<br />
          </p>

          <ol>
            <li>``<em>Keep it simple, stupid</em>'' (KISS), because
            if this program hangs it will hang the Apache server
            when the rule occurs.</li>

            <li>Avoid one common mistake: never do buffered I/O on
            <code>stdout</code>! This will cause a deadloop! Hence
            the ``<code>$|=1</code>'' in the above example...</li>

            <li>Use the <samp>RewriteLock</samp> directive to
            define a lockfile mod_rewrite can use to synchronize
            the communication to the program. By default no such
            synchronization takes place.</li>
          </ol>
        </li>
      </ul>
      The <code>RewriteMap</code> directive can occur more than
      once. For each mapping-function use one
      <code>RewriteMap</code> directive to declare its rewriting
      mapfile. While you cannot <strong>declare</strong> a map in
      per-directory context it is of course possible to
      <strong>use</strong> this map in per-directory context. 

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Note:</strong> For plain text and DBM format
          files the looked-up keys are cached in-core until the
          <code>mtime</code> of the mapfile changes or the server
          does a restart. This way you can have map-functions in
          rules which are used for <strong>every</strong> request.
          This is no problem, because the external lookup only
          happens once!</td>
        </tr>
      </table>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteBase"
      name="RewriteBase">RewriteBase</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteBase
      <em>URL-path</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> <em>default is the
      physical directory path</em><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> directory,
      .htaccess<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a>
      <em>FileInfo</em><br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache
      1.2<br />
       

      <p>The <code>RewriteBase</code> directive explicitly sets the
      base URL for per-directory rewrites. As you will see below,
      <code>RewriteRule</code> can be used in per-directory config
      files (<code>.htaccess</code>). There it will act locally,
      <em>i.e.</em>, the local directory prefix is stripped at this
      stage of processing and your rewriting rules act only on the
      remainder. At the end it is automatically added back to the
      path.</p>

      <p>When a substitution occurs for a new URL, this module has
      to re-inject the URL into the server processing. To be able
      to do this it needs to know what the corresponding URL-prefix
      or URL-base is. By default this prefix is the corresponding
      filepath itself. <strong>But at most websites URLs are NOT
      directly related to physical filename paths, so this
      assumption will usually be wrong!</strong> There you have to
      use the <code>RewriteBase</code> directive to specify the
      correct URL-prefix.</p>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Notice:</strong> If your webserver's URLs are
          <strong>not</strong> directly related to physical file
          paths, you have to use <code>RewriteBase</code> in every
          <code>.htaccess</code> files where you want to use
          <code>RewriteRule</code> directives.</td>
        </tr>
      </table>

      <p><strong>Example:</strong></p>

      <blockquote>
        Assume the following per-directory config file: 

        <table border="0" cellspacing="1" cellpadding="5"
        bgcolor="#F0F0F0">
          <tr>
            <td>
<pre>
d901 2
a902 2
#  Remember: /abc/def is the physical path of /xyz, <em>i.e.</em>, the server
#            has a 'Alias /xyz /abc/def' directive <em>e.g.</em>
d907 1
a907 1
#  let the server know that we were reached via /xyz and not
d913 19
a931 19
</pre>
            </td>
          </tr>
        </table>

        <p>In the above example, a request to
        <code>/xyz/oldstuff.html</code> gets correctly rewritten to
        the physical file <code>/abc/def/newstuff.html</code>.</p>

        <table width="70%" border="0" bgcolor="#E0E0F0"
        cellspacing="0" cellpadding="10">
          <tr>
            <td>
              <font size="-1"><strong>Note - For Apache
              hackers:</strong><br />
               The following list gives detailed information about
              the internal processing steps:</font> 
<pre>
<font size="-1">Request:
d942 1
a942 399
</font>
</pre>
              <font size="-1">This seems very complicated but is
              the correct Apache internal processing, because the
              per-directory rewriting comes too late in the
              process. So, when it occurs the (rewritten) request
              has to be re-injected into the Apache kernel! BUT:
              While this seems like a serious overhead, it really
              isn't, because this re-injection happens fully
              internally to the Apache server and the same
              procedure is used by many other operations inside
              Apache. So, you can be sure the design and
              implementation is correct.</font> 
            </td>
          </tr>
        </table>
      </blockquote>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteCond"
      name="RewriteCond">RewriteCond</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteCond
      <em>TestString</em> <em>CondPattern</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> <em>None</em><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config,
      virtual host, directory, .htaccess<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a>
      <em>FileInfo</em><br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache 1.2
      (partially), Apache 1.3<br />
       

      <p>The <code>RewriteCond</code> directive defines a rule
      condition. Precede a <code>RewriteRule</code> directive with
      one or more <code>RewriteCond</code> directives. The
      following rewriting rule is only used if its pattern matches
      the current state of the URI <strong>and</strong> if these
      additional conditions apply too.</p>

      <p><em>TestString</em> is a string which can contains the
      following expanded constructs in addition to plain text:</p>

      <ul>
        <li>
          <strong>RewriteRule backreferences</strong>: These are
          backreferences of the form 

          <blockquote>
            <strong><code>$N</code></strong>
          </blockquote>
          (0 &lt;= N &lt;= 9) which provide access to the grouped
          parts (parenthesis!) of the pattern from the
          corresponding <code>RewriteRule</code> directive (the one
          following the current bunch of <code>RewriteCond</code>
          directives).
        </li>

        <li>
          <strong>RewriteCond backreferences</strong>: These are
          backreferences of the form 

          <blockquote>
            <strong><code>%N</code></strong>
          </blockquote>
          (1 &lt;= N &lt;= 9) which provide access to the grouped
          parts (parentheses!) of the pattern from the last matched
          <code>RewriteCond</code> directive in the current bunch
          of conditions.
        </li>

        <li>
          <strong>RewriteMap expansions</strong>: These are
          expansions of the form 

          <blockquote>
            <strong><code>${mapname:key|default}</code></strong>
          </blockquote>
          See <a href="#mapfunc">the documentation for
          RewriteMap</a> for more details.
        </li>

        <li>
          <strong>Server-Variables</strong>: These are variables of
          the form 

          <blockquote>
            <strong><code>%{</code> <em>NAME_OF_VARIABLE</em>
            <code>}</code></strong>
          </blockquote>
          where <em>NAME_OF_VARIABLE</em> can be a string taken
          from the following list: 

          <table bgcolor="#F0F0F0" cellspacing="0" cellpadding="5">
            <tr>
              <td valign="TOP">
                <strong>HTTP headers:</strong> 

                <p><font size="-1">HTTP_USER_AGENT<br />
                 HTTP_REFERER<br />
                 HTTP_COOKIE<br />
                 HTTP_FORWARDED<br />
                 HTTP_HOST<br />
                 HTTP_PROXY_CONNECTION<br />
                 HTTP_ACCEPT<br />
                </font></p>
              </td>

              <td valign="TOP">
                <strong>connection &amp; request:</strong> 

                <p><font size="-1">REMOTE_ADDR<br />
                 REMOTE_HOST<br />
                 REMOTE_USER<br />
                 REMOTE_IDENT<br />
                 REQUEST_METHOD<br />
                 SCRIPT_FILENAME<br />
                 PATH_INFO<br />
                 QUERY_STRING<br />
                 AUTH_TYPE<br />
                </font></p>
              </td>
            </tr>

            <tr>
              <td valign="TOP">
                <strong>server internals:</strong> 

                <p><font size="-1">DOCUMENT_ROOT<br />
                 SERVER_ADMIN<br />
                 SERVER_NAME<br />
                 SERVER_ADDR<br />
                 SERVER_PORT<br />
                 SERVER_PROTOCOL<br />
                 SERVER_SOFTWARE<br />
                </font></p>
              </td>

              <td valign="TOP">
                <strong>system stuff:</strong> 

                <p><font size="-1">TIME_YEAR<br />
                 TIME_MON<br />
                 TIME_DAY<br />
                 TIME_HOUR<br />
                 TIME_MIN<br />
                 TIME_SEC<br />
                 TIME_WDAY<br />
                 TIME<br />
                </font></p>
              </td>

              <td valign="TOP">
                <strong>specials:</strong> 

                <p><font size="-1">API_VERSION<br />
                 THE_REQUEST<br />
                 REQUEST_URI<br />
                 REQUEST_FILENAME<br />
                 IS_SUBREQ<br />
                </font></p>
              </td>
            </tr>
          </table>

          <table width="70%" border="0" bgcolor="#E0E0F0"
          cellspacing="0" cellpadding="10">
            <tr>
              <td>
                <p><strong>Notice:</strong> These variables all
                correspond to the similarly named HTTP
                MIME-headers, C variables of the Apache server or
                <code>struct tm</code> fields of the Unix system.
                Most are documented elsewhere in the Manual or in
                the CGI specification. Those that are special to
                mod_rewrite include:</p>

                <dl>
                  <dt><code>IS_SUBREQ</code></dt>

                  <dd>Will contain the text "true" if the request
                  currently being processed is a sub-request,
                  "false" otherwise. Sub-requests may be generated
                  by modules that need to resolve additional files
                  or URIs in order to complete their tasks.</dd>

                  <dt><code>API_VERSION</code></dt>

                  <dd>This is the version of the Apache module API
                  (the internal interface between server and
                  module) in the current httpd build, as defined in
                  include/ap_mmn.h. The module API version
                  corresponds to the version of Apache in use (in
                  the release version of Apache 1.3.14, for
                  instance, it is 19990320:10), but is mainly of
                  interest to module authors.</dd>

                  <dt><code>THE_REQUEST</code></dt>

                  <dd>The full HTTP request line sent by the
                  browser to the server (e.g., "<code>GET
                  /index.html HTTP/1.1</code>"). This does not
                  include any additional headers sent by the
                  browser.</dd>

                  <dt><code>REQUEST_URI</code></dt>

                  <dd>The resource requested in the HTTP request
                  line. (In the example above, this would be
                  "/index.html".)</dd>

                  <dt><code>REQUEST_FILENAME</code></dt>

                  <dd>The full local filesystem path to the file or
                  script matching the request.</dd>
                </dl>
              </td>
            </tr>
          </table>
        </li>
      </ul>

      <p>Special Notes:</p>

      <ol>
        <li>The variables SCRIPT_FILENAME and REQUEST_FILENAME
        contain the same value, <em>i.e.</em>, the value of the
        <code>filename</code> field of the internal
        <code>request_rec</code> structure of the Apache server.
        The first name is just the commonly known CGI variable name
        while the second is the consistent counterpart to
        REQUEST_URI (which contains the value of the
        <code>uri</code> field of <code>request_rec</code>).</li>

        <li>There is the special format:
        <code>%{ENV:variable}</code> where <em>variable</em> can be
        any environment variable. This is looked-up via internal
        Apache structures and (if not found there) via
        <code>getenv()</code> from the Apache server process.</li>

        <li>There is the special format:
        <code>%{HTTP:header}</code> where <em>header</em> can be
        any HTTP MIME-header name. This is looked-up from the HTTP
        request. Example: <code>%{HTTP:Proxy-Connection}</code> is
        the value of the HTTP header
        ``<code>Proxy-Connection:</code>''.</li>

        <li>There is the special format
        <code>%{LA-U:variable}</code> for look-aheads which perform
        an internal (URL-based) sub-request to determine the final
        value of <em>variable</em>. Use this when you want to use a
        variable for rewriting which is actually set later in an
        API phase and thus is not available at the current stage.
        For instance when you want to rewrite according to the
        <code>REMOTE_USER</code> variable from within the
        per-server context (<code>httpd.conf</code> file) you have
        to use <code>%{LA-U:REMOTE_USER}</code> because this
        variable is set by the authorization phases which come
        <em>after</em> the URL translation phase where mod_rewrite
        operates. On the other hand, because mod_rewrite implements
        its per-directory context (<code>.htaccess</code> file) via
        the Fixup phase of the API and because the authorization
        phases come <em>before</em> this phase, you just can use
        <code>%{REMOTE_USER}</code> there.</li>

        <li>There is the special format:
        <code>%{LA-F:variable}</code> which performs an internal
        (filename-based) sub-request to determine the final value
        of <em>variable</em>. Most of the time this is the same as
        LA-U above.</li>
      </ol>

      <p><em>CondPattern</em> is the condition pattern,
      <em>i.e.</em>, a regular expression which is applied to the
      current instance of the <em>TestString</em>, <em>i.e.</em>,
      <em>TestString</em> is evaluated and then matched against
      <em>CondPattern</em>.</p>

      <p><strong>Remember:</strong> <em>CondPattern</em> is a
      standard <em>Extended Regular Expression</em> with some
      additions:</p>

      <ol>
        <li>You can prefix the pattern string with a
        '<code>!</code>' character (exclamation mark) to specify a
        <strong>non</strong>-matching pattern.</li>

        <li>
          There are some special variants of <em>CondPatterns</em>.
          Instead of real regular expression strings you can also
          use one of the following: 

          <ul>
            <li>'<strong>&lt;CondPattern</strong>' (is lexically
            lower)<br />
             Treats the <em>CondPattern</em> as a plain string and
            compares it lexically to <em>TestString</em>. True if
            <em>TestString</em> is lexically lower than
            <em>CondPattern</em>.</li>

            <li>'<strong>&gt;CondPattern</strong>' (is lexically
            greater)<br />
             Treats the <em>CondPattern</em> as a plain string and
            compares it lexically to <em>TestString</em>. True if
            <em>TestString</em> is lexically greater than
            <em>CondPattern</em>.</li>

            <li>'<strong>=CondPattern</strong>' (is lexically
            equal)<br />
             Treats the <em>CondPattern</em> as a plain string and
            compares it lexically to <em>TestString</em>. True if
            <em>TestString</em> is lexically equal to
            <em>CondPattern</em>, i.e the two strings are exactly
            equal (character by character). If <em>CondPattern</em>
            is just <samp>""</samp> (two quotation marks) this
            compares <em>TestString</em> to the empty string.</li>

            <li>'<strong>-d</strong>' (is
            <strong>d</strong>irectory)<br />
             Treats the <em>TestString</em> as a pathname and tests
            if it exists and is a directory.</li>

            <li>'<strong>-f</strong>' (is regular
            <strong>f</strong>ile)<br />
             Treats the <em>TestString</em> as a pathname and tests
            if it exists and is a regular file.</li>

            <li>'<strong>-s</strong>' (is regular file with
            <strong>s</strong>ize)<br />
             Treats the <em>TestString</em> as a pathname and tests
            if it exists and is a regular file with size greater
            than zero.</li>

            <li>'<strong>-l</strong>' (is symbolic
            <strong>l</strong>ink)<br />
             Treats the <em>TestString</em> as a pathname and tests
            if it exists and is a symbolic link.</li>

            <li>'<strong>-F</strong>' (is existing file via
            subrequest)<br />
             Checks if <em>TestString</em> is a valid file and
            accessible via all the server's currently-configured
            access controls for that path. This uses an internal
            subrequest to determine the check, so use it with care
            because it decreases your servers performance!</li>

            <li>'<strong>-U</strong>' (is existing URL via
            subrequest)<br />
             Checks if <em>TestString</em> is a valid URL and
            accessible via all the server's currently-configured
            access controls for that path. This uses an internal
            subrequest to determine the check, so use it with care
            because it decreases your server's performance!</li>
          </ul>

          <table width="70%" border="0" bgcolor="#E0E0F0"
          cellspacing="0" cellpadding="10">
            <tr>
              <td><strong>Notice:</strong> All of these tests can
              also be prefixed by an exclamation mark ('!') to
              negate their meaning.</td>
            </tr>
          </table>
        </li>
      </ol>

      <p>Additionally you can set special flags for
      <em>CondPattern</em> by appending</p>

      <blockquote>
        <strong><code>[</code><em>flags</em><code>]</code></strong>
      </blockquote>
      as the third argument to the <code>RewriteCond</code>
      directive. <em>Flags</em> is a comma-separated list of the
      following flags: 

      <ul>
        <li>'<strong><code>nocase|NC</code></strong>'
        (<strong>n</strong>o <strong>c</strong>ase)<br />
         This makes the test case-insensitive, <em>i.e.</em>, there
        is no difference between 'A-Z' and 'a-z' both in the
        expanded <em>TestString</em> and the <em>CondPattern</em>.
        This flag is effective only for comparisons between
        <em>TestString</em> and <em>CondPattern</em>. It has no
        effect on filesystem and subrequest checks.</li>

        <li>
          '<strong><code>ornext|OR</code></strong>'
          (<strong>or</strong> next condition)<br />
           Use this to combine rule conditions with a local OR
          instead of the implicit AND. Typical example: 
d944 328
a1271 2
          <blockquote>
<pre>
d1276 10
a1285 13
</pre>
          </blockquote>
          Without this flag you would have to write the cond/rule
          three times.
        </li>
      </ul>

      <p><strong>Example:</strong></p>

      <blockquote>
        To rewrite the Homepage of a site according to the
        ``<code>User-Agent:</code>'' header of the request, you can
        use the following: 
d1287 1
a1287 2
        <blockquote>
<pre>
d1295 1
a1295 66
</pre>
        </blockquote>
        Interpretation: If you use Netscape Navigator as your
        browser (which identifies itself as 'Mozilla'), then you
        get the max homepage, which includes Frames, <em>etc.</em>
        If you use the Lynx browser (which is Terminal-based), then
        you get the min homepage, which contains no images, no
        tables, <em>etc.</em> If you use any other browser you get
        the standard homepage.
      </blockquote>
      <hr noshade="noshade" size="1" />

      <h3><a id="RewriteRule"
      name="RewriteRule">RewriteRule</a></h3>
      <a href="directive-dict.html#Syntax"
      rel="Help"><strong>Syntax:</strong></a> RewriteRule
      <em>Pattern</em> <em>Substitution</em><br />
       <a href="directive-dict.html#Default"
      rel="Help"><strong>Default:</strong></a> <em>None</em><br />
       <a href="directive-dict.html#Context"
      rel="Help"><strong>Context:</strong></a> server config,
      virtual host, directory, .htaccess<br />
       <a href="directive-dict.html#Override"
      rel="Help"><strong>Override:</strong></a>
      <em>FileInfo</em><br />
       <a href="directive-dict.html#Status"
      rel="Help"><strong>Status:</strong></a> Extension<br />
       <a href="directive-dict.html#Module"
      rel="Help"><strong>Module:</strong></a> mod_rewrite.c<br />
       <a href="directive-dict.html#Compatibility"
      rel="Help"><strong>Compatibility:</strong></a> Apache 1.2
      (partially), Apache 1.3<br />
       

      <p>The <code>RewriteRule</code> directive is the real
      rewriting workhorse. The directive can occur more than once.
      Each directive then defines one single rewriting rule. The
      <strong>definition order</strong> of these rules is
      <strong>important</strong>, because this order is used when
      applying the rules at run-time.</p>

      <p><a id="patterns" name="patterns"><em>Pattern</em></a> can
      be (for Apache 1.1.x a System V8 and for Apache 1.2.x and
      later a POSIX) <a id="regexp" name="regexp">regular
      expression</a> which gets applied to the current URL. Here
      ``current'' means the value of the URL when this rule gets
      applied. This may not be the originally requested URL,
      because any number of rules may already
      have matched and made alterations to it.</p>

      <p>Some hints about the syntax of regular expressions:</p>

      <table bgcolor="#F0F0F0" cellspacing="0" cellpadding="5">
        <tr>
          <td valign="TOP">
<pre>
<strong>Text:</strong>
  <strong><code>.</code></strong>           Any single character
  <strong><code>[</code></strong>chars<strong><code>]</code></strong>     Character class: One  of chars
  <strong><code>[^</code></strong>chars<strong><code>]</code></strong>    Character class: None of chars
  text1<strong><code>|</code></strong>text2 Alternative: text1 or text2

<strong>Quantifiers:</strong>
  <strong><code>?</code></strong>           0 or 1 of the preceding text
  <strong><code>*</code></strong>           0 or N of the preceding text (N &gt; 0)
  <strong><code>+</code></strong>           1 or N of the preceding text (N &gt; 1)
d1297 77
a1373 2
<strong>Grouping:</strong>
  <strong><code>(</code></strong>text<strong><code>)</code></strong>      Grouping of text
d1375 2
a1376 2
              for making backreferences where the <strong>N</strong>th group can 
              be used on the RHS of a RewriteRule with <code>$</code><strong>N</strong>)
d1378 235
a1612 339
<strong>Anchors:</strong>
  <strong><code>^</code></strong>           Start of line anchor
  <strong><code>$</code></strong>           End   of line anchor

<strong>Escaping:</strong>
  <strong><code>\</code></strong>char       escape that particular char
              (for instance to specify the chars "<code>.[]()</code>" <em>etc.</em>)
</pre>
          </td>
        </tr>
      </table>

      <p>For more information about regular expressions either have
      a look at your local regex(3) manpage or its
      <code>src/regex/regex.3</code> copy in the Apache 1.3
      distribution. If you are interested in more detailed
      information about regular expressions and their variants
      (POSIX regex, Perl regex, <em>etc.</em>) have a look at the
      following dedicated book on this topic:</p>

      <blockquote>
        <em>Mastering Regular Expressions</em><br />
         Jeffrey E.F. Friedl<br />
         Nutshell Handbook Series<br />
         O'Reilly &amp; Associates, Inc. 1997<br />
         ISBN 1-56592-257-3<br />
      </blockquote>

      <p>Additionally in mod_rewrite the NOT character
      ('<code>!</code>') is a possible pattern prefix. This gives
      you the ability to negate a pattern; to say, for instance:
      ``<em>if the current URL does <strong>NOT</strong> match this
      pattern</em>''. This can be used for exceptional cases, where
      it is easier to match the negative pattern, or as a last
      default rule.</p>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Notice:</strong> When using the NOT character
          to negate a pattern you cannot have grouped wildcard
          parts in the pattern. This is impossible because when the
          pattern does NOT match, there are no contents for the
          groups. In consequence, if negated patterns are used, you
          cannot use <code>$N</code> in the substitution
          string!</td>
        </tr>
      </table>

      <p><a id="rhs" name="rhs"><em>Substitution</em></a> of a
      rewriting rule is the string which is substituted for (or
      replaces) the original URL for which <em>Pattern</em>
      matched. Beside plain text you can use</p>

      <ol>
        <li>back-references <code>$N</code> to the RewriteRule
        pattern</li>

        <li>back-references <code>%N</code> to the last matched
        RewriteCond pattern</li>

        <li>server-variables as in rule condition test-strings
        (<code>%{VARNAME}</code>)</li>

        <li><a href="#mapfunc">mapping-function</a> calls
        (<code>${mapname:key|default}</code>)</li>
      </ol>
      Back-references are <code>$</code><strong>N</strong>
      (<strong>N</strong>=0..9) identifiers which will be replaced
      by the contents of the <strong>N</strong>th group of the
      matched <em>Pattern</em>. The server-variables are the same
      as for the <em>TestString</em> of a <code>RewriteCond</code>
      directive. The mapping-functions come from the
      <code>RewriteMap</code> directive and are explained there.
      These three types of variables are expanded in the order of
      the above list. 

      <p>As already mentioned above, all the rewriting rules are
      applied to the <em>Substitution</em> (in the order of
      definition in the config file). The URL is <strong>completely
      replaced</strong> by the <em>Substitution</em> and the
      rewriting process goes on until there are no more rules
      unless explicitly terminated by a
      <code><strong>L</strong></code> flag - see below.</p>

      <p>There is a special substitution string named
      '<code>-</code>' which means: <strong>NO
      substitution</strong>! Sounds silly? No, it is useful to
      provide rewriting rules which <strong>only</strong> match
      some URLs but do no substitution, <em>e.g.</em>, in
      conjunction with the <strong>C</strong> (chain) flag to be
      able to have more than one pattern to be applied before a
      substitution occurs.</p>

      <p>One more note: You can even create URLs in the
      substitution string containing a query string part. Just use
      a question mark inside the substitution string to indicate
      that the following stuff should be re-injected into the
      QUERY_STRING. When you want to erase an existing query
      string, end the substitution string with just the question
      mark.</p>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Note</strong>: There is a special feature:
          When you prefix a substitution field with
          <code>http://</code><em>thishost</em>[<em>:thisport</em>]
          then <strong>mod_rewrite</strong> automatically strips it
          out. This auto-reduction on implicit external redirect
          URLs is a useful and important feature when used in
          combination with a mapping-function which generates the
          hostname part. Have a look at the first example in the
          example section below to understand this.</td>
        </tr>
      </table>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Remember:</strong> An unconditional external
          redirect to your own server will not work with the prefix
          <code>http://thishost</code> because of this feature. To
          achieve such a self-redirect, you have to use the
          <strong>R</strong>-flag (see below).</td>
        </tr>
      </table>

      <p>Additionally you can set special flags for
      <em>Substitution</em> by appending</p>

      <blockquote>
        <strong><code>[</code><em>flags</em><code>]</code></strong>
      </blockquote>
      as the third argument to the <code>RewriteRule</code>
      directive. <em>Flags</em> is a comma-separated list of the
      following flags: 

      <ul>
        <li>
          '<strong><code>redirect|R</code>
          [=<em>code</em>]</strong>' (force <a id="redirect"
          name="redirect"><strong>r</strong>edirect</a>)<br />
           Prefix <em>Substitution</em> with
          <code>http://thishost[:thisport]/</code> (which makes the
          new URL a URI) to force a external redirection. If no
          <em>code</em> is given a HTTP response of 302 (MOVED
          TEMPORARILY) is used. If you want to use other response
          codes in the range 300-400 just specify them as a number
          or use one of the following symbolic names:
          <code>temp</code> (default), <code>permanent</code>,
          <code>seeother</code>. Use it for rules which should
          canonicalize the URL and give it back to the client,
          <em>e.g.</em>, translate ``<code>/~</code>'' into
          ``<code>/u/</code>'' or always append a slash to
          <code>/u/</code><em>user</em>, etc.<br />
           

          <p><strong>Note:</strong> When you use this flag, make
          sure that the substitution field is a valid URL! If not,
          you are redirecting to an invalid location! And remember
          that this flag itself only prefixes the URL with
          <code>http://thishost[:thisport]/</code>, rewriting
          continues. Usually you also want to stop and do the
          redirection immediately. To stop the rewriting you also
          have to provide the 'L' flag.</p>
        </li>

        <li>'<strong><code>forbidden|F</code></strong>' (force URL
        to be <strong>f</strong>orbidden)<br />
         This forces the current URL to be forbidden,
        <em>i.e.</em>, it immediately sends back a HTTP response of
        403 (FORBIDDEN). Use this flag in conjunction with
        appropriate RewriteConds to conditionally block some
        URLs.</li>

        <li>'<strong><code>gone|G</code></strong>' (force URL to be
        <strong>g</strong>one)<br />
         This forces the current URL to be gone, <em>i.e.</em>, it
        immediately sends back a HTTP response of 410 (GONE). Use
        this flag to mark pages which no longer exist as gone.</li>

        <li>
          '<strong><code>proxy|P</code></strong>' (force
          <strong>p</strong>roxy)<br />
           This flag forces the substitution part to be internally
          forced as a proxy request and immediately (<em>i.e.</em>,
          rewriting rule processing stops here) put through the <a
          href="mod_proxy.html">proxy module</a>. You have to make
          sure that the substitution string is a valid URI
          (<em>e.g.</em>, typically starting with
          <code>http://</code><em>hostname</em>) which can be
          handled by the Apache proxy module. If not you get an
          error from the proxy module. Use this flag to achieve a
          more powerful implementation of the <a
          href="mod_proxy.html#proxypass">ProxyPass</a> directive,
          to map some remote stuff into the namespace of the local
          server. 

          <p>Notice: To use this functionality make sure you have
          the proxy module compiled into your Apache server
          program. If you don't know please check whether
          <code>mod_proxy.c</code> is part of the ``<code>httpd
          -l</code>'' output. If yes, this functionality is
          available to mod_rewrite. If not, then you first have to
          rebuild the ``<code>httpd</code>'' program with mod_proxy
          enabled.</p>
        </li>

        <li>'<strong><code>last|L</code></strong>'
        (<strong>l</strong>ast rule)<br />
         Stop the rewriting process here and don't apply any more
        rewriting rules. This corresponds to the Perl
        <code>last</code> command or the <code>break</code> command
        from the C language. Use this flag to prevent the currently
        rewritten URL from being rewritten further by following
        rules. For example, use it to rewrite the root-path URL
        ('<code>/</code>') to a real one, <em>e.g.</em>,
        '<code>/e/www/</code>'.</li>

        <li>'<strong><code>next|N</code></strong>'
        (<strong>n</strong>ext round)<br />
         Re-run the rewriting process (starting again with the
        first rewriting rule). Here the URL to match is again not
        the original URL but the URL from the last rewriting rule.
        This corresponds to the Perl <code>next</code> command or
        the <code>continue</code> command from the C language. Use
        this flag to restart the rewriting process, <em>i.e.</em>,
        to immediately go to the top of the loop.<br />
         <strong>But be careful not to create an infinite
        loop!</strong></li>

        <li>'<strong><code>chain|C</code></strong>'
        (<strong>c</strong>hained with next rule)<br />
         This flag chains the current rule with the next rule
        (which itself can be chained with the following rule,
        <em>etc.</em>). This has the following effect: if a rule
        matches, then processing continues as usual, <em>i.e.</em>,
        the flag has no effect. If the rule does
        <strong>not</strong> match, then all following chained
        rules are skipped. For instance, use it to remove the
        ``<code>.www</code>'' part inside a per-directory rule set
        when you let an external redirect happen (where the
        ``<code>.www</code>'' part should not to occur!).</li>

        <li>
        '<strong><code>type|T</code></strong>=<em>MIME-type</em>'
        (force MIME <strong>t</strong>ype)<br />
         Force the MIME-type of the target file to be
        <em>MIME-type</em>. For instance, this can be used to
        simulate the <code>mod_alias</code> directive
        <code>ScriptAlias</code> which internally forces all files
        inside the mapped directory to have a MIME type of
        ``<code>application/x-httpd-cgi</code>''.</li>

        <li>
          '<strong><code>nosubreq|NS</code></strong>' (used only if
          <strong>n</strong>o internal
          <strong>s</strong>ub-request)<br />
           This flag forces the rewriting engine to skip a
          rewriting rule if the current request is an internal
          sub-request. For instance, sub-requests occur internally
          in Apache when <code>mod_include</code> tries to find out
          information about possible directory default files
          (<code>index.xxx</code>). On sub-requests it is not
          always useful and even sometimes causes a failure to if
          the complete set of rules are applied. Use this flag to
          exclude some rules.<br />
           

          <p>Use the following rule for your decision: whenever you
          prefix some URLs with CGI-scripts to force them to be
          processed by the CGI-script, the chance is high that you
          will run into problems (or even overhead) on
          sub-requests. In these cases, use this flag.</p>
        </li>

        <li>'<strong><code>nocase|NC</code></strong>'
        (<strong>n</strong>o <strong>c</strong>ase)<br />
         This makes the <em>Pattern</em> case-insensitive,
        <em>i.e.</em>, there is no difference between 'A-Z' and
        'a-z' when <em>Pattern</em> is matched against the current
        URL.</li>

        <li>'<strong><code>qsappend|QSA</code></strong>'
        (<strong>q</strong>uery <strong>s</strong>tring
        <strong>a</strong>ppend)<br />
         This flag forces the rewriting engine to append a query
        string part in the substitution string to the existing one
        instead of replacing it. Use this when you want to add more
        data to the query string via a rewrite rule.</li>

        <li>
          '<strong><code>noescape|NE</code></strong>'
          (<strong>n</strong>o URI <strong>e</strong>scaping of
          output)<br />
           This flag keeps mod_rewrite from applying the usual URI
          escaping rules to the result of a rewrite. Ordinarily,
          special characters (such as '%', '$', ';', and so on)
          will be escaped into their hexcode equivalents ('%25',
          '%24', and '%3B', respectively); this flag prevents this
          from being done. This allows percent symbols to appear in
          the output, as in 
<pre>
    RewriteRule /foo/(.*) /bar?arg=P1\%3d$1 [R,NE]
   
</pre>
          which would turn '<code>/foo/zed</code>' into a safe
          request for '<code>/bar?arg=P1=zed</code>'. 

          <table width="70%" border="0" bgcolor="#E0E0F0"
          cellspacing="0" cellpadding="10">
            <tr>
              <td><strong>Notice:</strong> The
              <code>noescape</code> flag is only available with
              Apache 1.3.20 and later versions.</td>
            </tr>
          </table>
        </li>

        <li>
          '<strong><code>passthrough|PT</code></strong>'
          (<strong>p</strong>ass <strong>t</strong>hrough to next
          handler)<br />
           This flag forces the rewriting engine to set the
          <code>uri</code> field of the internal
          <code>request_rec</code> structure to the value of the
          <code>filename</code> field. This flag is just a hack to
          be able to post-process the output of
          <code>RewriteRule</code> directives by
          <code>Alias</code>, <code>ScriptAlias</code>,
          <code>Redirect</code>, <em>etc.</em> directives from
          other URI-to-filename translators. A trivial example to
          show the semantics: If you want to rewrite
          <code>/abc</code> to <code>/def</code> via the rewriting
          engine of <code>mod_rewrite</code> and then
          <code>/def</code> to <code>/ghi</code> with
          <code>mod_alias</code>: 
<pre>
d1615 86
a1700 112
   
</pre>
          If you omit the <code>PT</code> flag then
          <code>mod_rewrite</code> will do its job fine,
          <em>i.e.</em>, it rewrites <code>uri=/abc/...</code> to
          <code>filename=/def/...</code> as a full API-compliant
          URI-to-filename translator should do. Then
          <code>mod_alias</code> comes and tries to do a
          URI-to-filename transition which will not work. 

          <p>Note: <strong>You have to use this flag if you want to
          intermix directives of different modules which contain
          URL-to-filename translators</strong>. The typical example
          is the use of <code>mod_alias</code> and
          <code>mod_rewrite</code>..</p>

          <table width="70%" border="0" bgcolor="#E0E0F0"
          cellspacing="0" cellpadding="10">
            <tr>
              <td><font size="-1"><strong>Note - For Apache
              hackers:</strong><br />
               If the current Apache API had a filename-to-filename
              hook additionally to the URI-to-filename hook then we
              wouldn't need this flag! But without such a hook this
              flag is the only solution. The Apache Group has
              discussed this problem and will add such a hook in
              Apache version 2.0.</font> </td>
            </tr>
          </table>
        </li>

        <li>'<strong><code>skip|S</code></strong>=<em>num</em>'
        (<strong>s</strong>kip next rule(s))<br />
         This flag forces the rewriting engine to skip the next
        <em>num</em> rules in sequence when the current rule
        matches. Use this to make pseudo if-then-else constructs:
        The last rule of the then-clause becomes
        <code>skip=N</code> where N is the number of rules in the
        else-clause. (This is <strong>not</strong> the same as the
        'chain|C' flag!)</li>

        <li>
        '<strong><code>env|E=</code></strong><em>VAR</em>:<em>VAL</em>'
        (set <strong>e</strong>nvironment variable)<br />
         This forces an environment variable named <em>VAR</em> to
        be set to the value <em>VAL</em>, where <em>VAL</em> can
        contain regexp backreferences <code>$N</code> and
        <code>%N</code> which will be expanded. You can use this
        flag more than once to set more than one variable. The
        variables can be later dereferenced in many situations, but
        usually from within XSSI (via <code>&lt;!--#echo
        var="VAR"--&gt;</code>) or CGI (<em>e.g.</em>
        <code>$ENV{'VAR'}</code>). Additionally you can dereference
        it in a following RewriteCond pattern via
        <code>%{ENV:VAR}</code>. Use this to strip but remember
        information from URLs.</li>
      </ul>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td>
            <strong>Note:</strong> Never forget that
            <em>Pattern</em> is applied to a complete URL in
            per-server configuration files. <strong>But in
            per-directory configuration files, the per-directory
            prefix (which always is the same for a specific
            directory!) is automatically <em>removed</em> for the
            pattern matching and automatically <em>added</em> after
            the substitution has been done.</strong> This feature
            is essential for many sorts of rewriting, because
            without this prefix stripping you have to match the
            parent directory which is not always possible. 

            <p>There is one exception: If a substitution string
            starts with ``<code>http://</code>'' then the directory
            prefix will <strong>not</strong> be added and an
            external redirect or proxy throughput (if flag
            <strong>P</strong> is used!) is forced!</p>
          </td>
        </tr>
      </table>

      <table width="70%" border="0" bgcolor="#E0E0F0"
      cellspacing="0" cellpadding="10">
        <tr>
          <td><strong>Note:</strong> To enable the rewriting engine
          for per-directory configuration files you need to set
          ``<code>RewriteEngine On</code>'' in these files
          <strong>and</strong> ``<code>Options
          FollowSymLinks</code>'' must be enabled. If your
          administrator has disabled override of
          <code>FollowSymLinks</code> for a user's directory, then
          you cannot use the rewriting engine. This restriction is
          needed for security reasons.</td>
        </tr>
      </table>

      <p>Here are all possible substitution combinations and their
      meanings:</p>

      <p><strong>Inside per-server configuration
      (<code>httpd.conf</code>)<br />
       for request ``<code>GET
      /somepath/pathinfo</code>'':</strong><br />
      </p>

      <table bgcolor="#F0F0F0" cellspacing="0" cellpadding="5">
        <tr>
          <td>
<pre>
<strong>Given Rule</strong>                                      <strong>Resulting Substitution</strong>
d1731 17
a1747 19
</pre>
          </td>
        </tr>
      </table>

      <p><strong>Inside per-directory configuration for
      <code>/somepath</code><br />
       (<em>i.e.</em>, file <code>.htaccess</code> in dir
      <code>/physical/path/to/somepath</code> containing
      <code>RewriteBase /somepath</code>)<br />
       for request ``<code>GET
      /somepath/localpath/pathinfo</code>'':</strong><br />
      </p>

      <table bgcolor="#F0F0F0" cellspacing="0" cellpadding="5">
        <tr>
          <td>
<pre>
<strong>Given Rule</strong>                                      <strong>Resulting Substitution</strong>
d1779 25
a1803 25
</pre>
          </td>
        </tr>
      </table>

      <p><strong>Example:</strong></p>

      <blockquote>
        We want to rewrite URLs of the form 

        <blockquote>
          <code>/</code> <em>Language</em> <code>/~</code>
          <em>Realname</em> <code>/.../</code> <em>File</em>
        </blockquote>
        into 

        <blockquote>
          <code>/u/</code> <em>Username</em> <code>/.../</code>
          <em>File</em> <code>.</code> <em>Language</em>
        </blockquote>

        <p>We take the rewrite mapfile from above and save it under
        <code>/path/to/file/map.txt</code>. Then we only have to
        add the following lines to the Apache server configuration
        file:</p>
d1805 2
a1806 2
        <blockquote>
<pre>
d1810 28
a1837 26
</pre>
        </blockquote>
      </blockquote>
      <hr noshade="noshade" size="1" />

      <center>
        <h1><a id="Miscelleneous"
        name="Miscelleneous">Miscellaneous</a></h1>
      </center>
      <hr noshade="noshade" size="1" />

      <h2><a id="EnvVar" name="EnvVar">Environment
      Variables</a></h2>
      This module keeps track of two additional (non-standard)
      CGI/SSI environment variables named <code>SCRIPT_URL</code>
      and <code>SCRIPT_URI</code>. These contain the
      <em>logical</em> Web-view to the current resource, while the
      standard CGI/SSI variables <code>SCRIPT_NAME</code> and
      <code>SCRIPT_FILENAME</code> contain the <em>physical</em>
      System-view. 

      <p>Notice: These variables hold the URI/URL <em>as they were
      initially requested</em>, <em>i.e.</em>, <em>before</em> any
      rewriting. This is important because the rewriting process is
      primarily used to rewrite logical URLs to physical
      pathnames.</p>
d1839 2
a1840 1
      <p><strong>Example:</strong></p>
d1842 2
a1843 2
      <blockquote>
<pre>
d1848 26
a1873 22
</pre>
      </blockquote>
      <hr noshade="noshade" size="1" />

      <h2><a id="Solutions" name="Solutions">Practical
      Solutions</a></h2>
      We also have an <a href="../misc/rewriteguide.html">URL
      Rewriting Guide</a> available, which provides a collection of
      practical solutions for URL-based problems. There you can
      find real-life rulesets and additional information about
      mod_rewrite. 
    </blockquote>
        <hr />

    <h3 align="CENTER">Apache HTTP Server Version 1.3</h3>
    <a href="./"><img src="../images/index.gif" alt="Index" /></a>
    <a href="../"><img src="../images/home.gif" alt="Home" /></a>

    <!-- page indentation -->
    <!--/%hypertext -->
  </body>
</html>
d1875 4
@


1.1.1.4
log
@import apache 1.3.28 and mod_ssl 2.8.15
@
text
@d401 1
a401 2
      rel="Help"><strong>Default:</strong></a> <code>RewriteOptions
      MaxRedirects=10</code><br />
d413 2
a414 3
      1.2; <code>MaxRedirects</code> is available in Apache 1.3.28 and
      later<br />

d421 9
a429 17
      <dl>
      <dt><code>inherit</code></dt>
      <dd>This forces the current configuration to inherit the
      configuration of the parent. In per-virtual-server context
      this means that the maps, conditions and rules of the main
      server are inherited. In per-directory context this means
      that conditions and rules of the parent directory's
      <code>.htaccess</code> configuration are inherited.</dd>

      <dt><code>MaxRedirects=<var>number</var></code></dt>
      <dd>In order to prevent endless loops of internal redirects
      issued by per-directory <code>RewriteRule</code>s,
      <code>mod_rewrite</code> aborts the request after reaching a
      maximum number of such redirects and responds with an 500 Internal
      Server Error. If you really need more internal redirects than 10
      per request, you may increase the default to the desired value.</dd>
      </dl>
d465 1
a465 1
          <em>file-path</em> to <code>/dev/null</code>, because
@


