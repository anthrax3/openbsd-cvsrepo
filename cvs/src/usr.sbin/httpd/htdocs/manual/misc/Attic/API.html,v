head	1.6;
access;
symbols
	OPENBSD_5_5:1.5.0.44
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.40
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.38
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.36
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.34
	OPENBSD_5_0:1.5.0.32
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.30
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.28
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.24
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.26
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.22
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.20
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.18
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	apache_1_3_29-mod_ssl_2_8_16:1.1.1.4
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	apache_1_3_28-mod_ssl_2_8_15:1.1.1.3
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	apache_1_3_27-mod_ssl_2_8_12:1.1.1.3
	apache_1_3_27:1.1.1.3
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	apache_1_3_26:1.1.1.3
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.2.0.10
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.8
	OPENBSD_2_8:1.2.0.6
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.2.0.4
	OPENBSD_2_5_BASE:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.2
	OPENBSD_2_4_BASE:1.1.1.2
	apache_1_3_2:1.1.1.2
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	apache:1.1.1
	apache_1_2_6:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2014.04.22.14.47.24;	author henning;	state dead;
branches;
next	1.5;

1.5
date	2003.11.17.18.57.05;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.29.02.08.04;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.12.07.56.47;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.06.29.00;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.03.25.07.08.35;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.25.07.08.35;	author beck;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.10.01.17.20.08;	author beck;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.07.19.21.28.04;	author henning;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.11.17.17.03.14;	author henning;	state Exp;
branches;
next	;


desc
@@


1.6
log
@this commit is really florian@@'s, since he's the one who made removal
of our forked apache possible by his work on nginx and slowcgi, but he
doesn't want it - so it is my pleasure to tedu it. I spent so much work
on chroot in it 10 years ago - and am very happy to see it go now, nginx
is a far better choice today.
Bye bye, Apache, won't miss you.
@
text
@<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator" content="HTML Tidy, see www.w3.org" />

    <title>Apache API notes</title>
  </head>
  <!-- Background white, links blue (unvisited), navy (visited), red (active) -->

  <body bgcolor="#FFFFFF" text="#000000" link="#0000FF"
  vlink="#000080" alink="#FF0000">
        <div align="CENTER">
      <img src="../images/sub.gif" alt="[APACHE DOCUMENTATION]" /> 

      <h3>Apache HTTP Server Version 1.3</h3>
    </div>


    <h1 align="CENTER">Apache API notes</h1>
    These are some notes on the Apache API and the data structures
    you have to deal with, <em>etc.</em> They are not yet nearly
    complete, but hopefully, they will help you get your bearings.
    Keep in mind that the API is still subject to change as we gain
    experience with it. (See the TODO file for what <em>might</em>
    be coming). However, it will be easy to adapt modules to any
    changes that are made. (We have more modules to adapt than you
    do). 

    <p>A few notes on general pedagogical style here. In the
    interest of conciseness, all structure declarations here are
    incomplete --- the real ones have more slots that I'm not
    telling you about. For the most part, these are reserved to one
    component of the server core or another, and should be altered
    by modules with caution. However, in some cases, they really
    are things I just haven't gotten around to yet. Welcome to the
    bleeding edge.</p>

    <p>Finally, here's an outline, to give you some bare idea of
    what's coming up, and in what order:</p>

    <ul>
      <li>
        <a href="#basics">Basic concepts.</a> 

        <ul>
          <li><a href="#HMR">Handlers, Modules, and
          Requests</a></li>

          <li><a href="#moduletour">A brief tour of a
          module</a></li>
        </ul>
      </li>

      <li>
        <a href="#handlers">How handlers work</a> 

        <ul>
          <li><a href="#req_tour">A brief tour of the
          <code>request_rec</code></a></li>

          <li><a href="#req_orig">Where request_rec structures come
          from</a></li>

          <li><a href="#req_return">Handling requests, declining,
          and returning error codes</a></li>

          <li><a href="#resp_handlers">Special considerations for
          response handlers</a></li>

          <li><a href="#auth_handlers">Special considerations for
          authentication handlers</a></li>

          <li><a href="#log_handlers">Special considerations for
          logging handlers</a></li>
        </ul>
      </li>

      <li><a href="#pools">Resource allocation and resource
      pools</a></li>

      <li>
        <a href="#config">Configuration, commands and the like</a> 

        <ul>
          <li><a href="#per-dir">Per-directory configuration
          structures</a></li>

          <li><a href="#commands">Command handling</a></li>

          <li><a href="#servconf">Side notes --- per-server
          configuration, virtual servers, <em>etc</em>.</a></li>
        </ul>
      </li>
    </ul>

    <h2><a id="basics" name="basics">Basic concepts.</a></h2>
    We begin with an overview of the basic concepts behind the API,
    and how they are manifested in the code. 

    <h3><a id="HMR" name="HMR">Handlers, Modules, and
    Requests</a></h3>
    Apache breaks down request handling into a series of steps,
    more or less the same way the Netscape server API does
    (although this API has a few more stages than NetSite does, as
    hooks for stuff I thought might be useful in the future). These
    are: 

    <ul>
      <li>URI -&gt; Filename translation</li>

      <li>Auth ID checking [is the user who they say they
      are?]</li>

      <li>Auth access checking [is the user authorized
      <em>here</em>?]</li>

      <li>Access checking other than auth</li>

      <li>Determining MIME type of the object requested</li>

      <li>`Fixups' --- there aren't any of these yet, but the phase
      is intended as a hook for possible extensions like
      <code>SetEnv</code>, which don't really fit well
      elsewhere.</li>

      <li>Actually sending a response back to the client.</li>

      <li>Logging the request</li>
    </ul>
    These phases are handled by looking at each of a succession of
    <em>modules</em>, looking to see if each of them has a handler
    for the phase, and attempting invoking it if so. The handler
    can typically do one of three things: 

    <ul>
      <li><em>Handle</em> the request, and indicate that it has
      done so by returning the magic constant <code>OK</code>.</li>

      <li><em>Decline</em> to handle the request, by returning the
      magic integer constant <code>DECLINED</code>. In this case,
      the server behaves in all respects as if the handler simply
      hadn't been there.</li>

      <li>Signal an error, by returning one of the HTTP error
      codes. This terminates normal handling of the request,
      although an ErrorDocument may be invoked to try to mop up,
      and it will be logged in any case.</li>
    </ul>
    Most phases are terminated by the first module that handles
    them; however, for logging, `fixups', and non-access
    authentication checking, all handlers always run (barring an
    error). Also, the response phase is unique in that modules may
    declare multiple handlers for it, via a dispatch table keyed on
    the MIME type of the requested object. Modules may declare a
    response-phase handler which can handle <em>any</em> request,
    by giving it the key <code>*/*</code> (<em>i.e.</em>, a
    wildcard MIME type specification). However, wildcard handlers
    are only invoked if the server has already tried and failed to
    find a more specific response handler for the MIME type of the
    requested object (either none existed, or they all declined). 

    <p>The handlers themselves are functions of one argument (a
    <code>request_rec</code> structure. vide infra), which returns
    an integer, as above.</p>

    <h3><a id="moduletour" name="moduletour">A brief tour of a
    module</a></h3>
    At this point, we need to explain the structure of a module.
    Our candidate will be one of the messier ones, the CGI module
    --- this handles both CGI scripts and the
    <code>ScriptAlias</code> config file command. It's actually a
    great deal more complicated than most modules, but if we're
    going to have only one example, it might as well be the one
    with its fingers in every place. 

    <p>Let's begin with handlers. In order to handle the CGI
    scripts, the module declares a response handler for them.
    Because of <code>ScriptAlias</code>, it also has handlers for
    the name translation phase (to recognize
    <code>ScriptAlias</code>ed URIs), the type-checking phase (any
    <code>ScriptAlias</code>ed request is typed as a CGI
    script).</p>

    <p>The module needs to maintain some per (virtual) server
    information, namely, the <code>ScriptAlias</code>es in effect;
    the module structure therefore contains pointers to a functions
    which builds these structures, and to another which combines
    two of them (in case the main server and a virtual server both
    have <code>ScriptAlias</code>es declared).</p>

    <p>Finally, this module contains code to handle the
    <code>ScriptAlias</code> command itself. This particular module
    only declares one command, but there could be more, so modules
    have <em>command tables</em> which declare their commands, and
    describe where they are permitted, and how they are to be
    invoked.</p>

    <p>A final note on the declared types of the arguments of some
    of these commands: a <code>pool</code> is a pointer to a
    <em>resource pool</em> structure; these are used by the server
    to keep track of the memory which has been allocated, files
    opened, <em>etc.</em>, either to service a particular request,
    or to handle the process of configuring itself. That way, when
    the request is over (or, for the configuration pool, when the
    server is restarting), the memory can be freed, and the files
    closed, <em>en masse</em>, without anyone having to write
    explicit code to track them all down and dispose of them. Also,
    a <code>cmd_parms</code> structure contains various information
    about the config file being read, and other status information,
    which is sometimes of use to the function which processes a
    config-file command (such as <code>ScriptAlias</code>). With no
    further ado, the module itself:</p>
<pre>
/* Declarations of handlers. */

int translate_scriptalias (request_rec *);
int type_scriptalias (request_rec *);
int cgi_handler (request_rec *);

/* Subsidiary dispatch table for response-phase handlers, by MIME type */

handler_rec cgi_handlers[] = {
{ "application/x-httpd-cgi", cgi_handler },
{ NULL }
};

/* Declarations of routines to manipulate the module's configuration
 * info.  Note that these are returned, and passed in, as void *'s;
 * the server core keeps track of them, but it doesn't, and can't,
 * know their internal structure.
 */

void *make_cgi_server_config (pool *);
void *merge_cgi_server_config (pool *, void *, void *);

/* Declarations of routines to handle config-file commands */

extern char *script_alias(cmd_parms *, void *per_dir_config, char *fake,
                          char *real);

command_rec cgi_cmds[] = {
{ "ScriptAlias", script_alias, NULL, RSRC_CONF, TAKE2,
    "a fakename and a realname"},
{ NULL }
};

module cgi_module = {
   STANDARD_MODULE_STUFF,
   NULL,                     /* initializer */
   NULL,                     /* dir config creator */
   NULL,                     /* dir merger --- default is to override */
   make_cgi_server_config,   /* server config */
   merge_cgi_server_config,  /* merge server config */
   cgi_cmds,                 /* command table */
   cgi_handlers,             /* handlers */
   translate_scriptalias,    /* filename translation */
   NULL,                     /* check_user_id */
   NULL,                     /* check auth */
   NULL,                     /* check access */
   type_scriptalias,         /* type_checker */
   NULL,                     /* fixups */
   NULL,                     /* logger */
   NULL                      /* header parser */
};
</pre>

    <h2><a id="handlers" name="handlers">How handlers work</a></h2>
    The sole argument to handlers is a <code>request_rec</code>
    structure. This structure describes a particular request which
    has been made to the server, on behalf of a client. In most
    cases, each connection to the client generates only one
    <code>request_rec</code> structure. 

    <h3><a id="req_tour" name="req_tour">A brief tour of the
    <code>request_rec</code></a></h3>
    The <code>request_rec</code> contains pointers to a resource
    pool which will be cleared when the server is finished handling
    the request; to structures containing per-server and
    per-connection information, and most importantly, information
    on the request itself. 

    <p>The most important such information is a small set of
    character strings describing attributes of the object being
    requested, including its URI, filename, content-type and
    content-encoding (these being filled in by the translation and
    type-check handlers which handle the request,
    respectively).</p>

    <p>Other commonly used data items are tables giving the MIME
    headers on the client's original request, MIME headers to be
    sent back with the response (which modules can add to at will),
    and environment variables for any subprocesses which are
    spawned off in the course of servicing the request. These
    tables are manipulated using the <code>ap_table_get</code> and
    <code>ap_table_set</code> routines.</p>

    <blockquote>
      Note that the <samp>Content-type</samp> header value
      <em>cannot</em> be set by module content-handlers using the
      <samp>ap_table_*()</samp> routines. Rather, it is set by
      pointing the <samp>content_type</samp> field in the
      <samp>request_rec</samp> structure to an appropriate string.
      <em>E.g.</em>, 
<pre>
  r-&gt;content_type = "text/html";
</pre>
    </blockquote>
    Finally, there are pointers to two data structures which, in
    turn, point to per-module configuration structures.
    Specifically, these hold pointers to the data structures which
    the module has built to describe the way it has been configured
    to operate in a given directory (via <code>.htaccess</code>
    files or <code>&lt;Directory&gt;</code> sections), for private
    data it has built in the course of servicing the request (so
    modules' handlers for one phase can pass `notes' to their
    handlers for other phases). There is another such configuration
    vector in the <code>server_rec</code> data structure pointed to
    by the <code>request_rec</code>, which contains per (virtual)
    server configuration data. 

    <p>Here is an abridged declaration, giving the fields most
    commonly used:</p>
<pre>
struct request_rec {

  pool *pool;
  conn_rec *connection;
  server_rec *server;

  /* What object is being requested */

  char *uri;
  char *filename;
  char *path_info;
  char *args;           /* QUERY_ARGS, if any */
  struct stat finfo;    /* Set by server core;
                         * st_mode set to zero if no such file */

  char *content_type;
  char *content_encoding;

  /* MIME header environments, in and out.  Also, an array containing
   * environment variables to be passed to subprocesses, so people can
   * write modules to add to that environment.
   *
   * The difference between headers_out and err_headers_out is that
   * the latter are printed even on error, and persist across internal
   * redirects (so the headers printed for ErrorDocument handlers will
   * have them).
   */

  table *headers_in;
  table *headers_out;
  table *err_headers_out;
  table *subprocess_env;

  /* Info about the request itself... */

  int header_only;     /* HEAD request, as opposed to GET */
  char *protocol;      /* Protocol, as given to us, or HTTP/0.9 */
  char *method;        /* GET, HEAD, POST, <em>etc.</em> */
  int method_number;   /* M_GET, M_POST, <em>etc.</em> */

  /* Info for logging */

  char *the_request;
  int bytes_sent;

  /* A flag which modules can set, to indicate that the data being
   * returned is volatile, and clients should be told not to cache it.
   */

  int no_cache;

  /* Various other config info which may change with .htaccess files
   * These are config vectors, with one void* pointer for each module
   * (the thing pointed to being the module's business).
   */

  void *per_dir_config;   /* Options set in config files, <em>etc.</em> */
  void *request_config;   /* Notes on *this* request */

};

</pre>

    <h3><a id="req_orig" name="req_orig">Where request_rec
    structures come from</a></h3>
    Most <code>request_rec</code> structures are built by reading
    an HTTP request from a client, and filling in the fields.
    However, there are a few exceptions: 

    <ul>
      <li>If the request is to an imagemap, a type map
      (<em>i.e.</em>, a <code>*.var</code> file), or a CGI script
      which returned a local `Location:', then the resource which
      the user requested is going to be ultimately located by some
      URI other than what the client originally supplied. In this
      case, the server does an <em>internal redirect</em>,
      constructing a new <code>request_rec</code> for the new URI,
      and processing it almost exactly as if the client had
      requested the new URI directly.</li>

      <li>If some handler signaled an error, and an
      <code>ErrorDocument</code> is in scope, the same internal
      redirect machinery comes into play.</li>

      <li>
        Finally, a handler occasionally needs to investigate `what
        would happen if' some other request were run. For instance,
        the directory indexing module needs to know what MIME type
        would be assigned to a request for each directory entry, in
        order to figure out what icon to use. 

        <p>Such handlers can construct a <em>sub-request</em>,
        using the functions <code>ap_sub_req_lookup_file</code>,
        <code>ap_sub_req_lookup_uri</code>, and
        <code>ap_sub_req_method_uri</code>; these construct a new
        <code>request_rec</code> structure and processes it as you
        would expect, up to but not including the point of actually
        sending a response. (These functions skip over the access
        checks if the sub-request is for a file in the same
        directory as the original request).</p>

        <p>(Server-side includes work by building sub-requests and
        then actually invoking the response handler for them, via
        the function <code>ap_run_sub_req</code>).</p>
      </li>
    </ul>

    <h3><a id="req_return" name="req_return">Handling requests,
    declining, and returning error codes</a></h3>
    As discussed above, each handler, when invoked to handle a
    particular <code>request_rec</code>, has to return an
    <code>int</code> to indicate what happened. That can either be 

    <ul>
      <li>OK --- the request was handled successfully. This may or
      may not terminate the phase.</li>

      <li>DECLINED --- no erroneous condition exists, but the
      module declines to handle the phase; the server tries to find
      another.</li>

      <li>an HTTP error code, which aborts handling of the
      request.</li>
    </ul>
    Note that if the error code returned is <code>REDIRECT</code>,
    then the module should put a <code>Location</code> in the
    request's <code>headers_out</code>, to indicate where the
    client should be redirected <em>to</em>. 

    <h3><a id="resp_handlers" name="resp_handlers">Special
    considerations for response handlers</a></h3>
    Handlers for most phases do their work by simply setting a few
    fields in the <code>request_rec</code> structure (or, in the
    case of access checkers, simply by returning the correct error
    code). However, response handlers have to actually send a
    request back to the client. 

    <p>They should begin by sending an HTTP response header, using
    the function <code>ap_send_http_header</code>. (You don't have
    to do anything special to skip sending the header for HTTP/0.9
    requests; the function figures out on its own that it shouldn't
    do anything). If the request is marked
    <code>header_only</code>, that's all they should do; they
    should return after that, without attempting any further
    output.</p>

    <p>Otherwise, they should produce a request body which responds
    to the client as appropriate. The primitives for this are
    <code>ap_rputc</code> and <code>ap_rprintf</code>, for
    internally generated output, and <code>ap_send_fd</code>, to
    copy the contents of some <code>FILE *</code> straight to the
    client.</p>

    <p>At this point, you should more or less understand the
    following piece of code, which is the handler which handles
    <code>GET</code> requests which have no more specific handler;
    it also shows how conditional <code>GET</code>s can be handled,
    if it's desirable to do so in a particular response handler ---
    <code>ap_set_last_modified</code> checks against the
    <code>If-modified-since</code> value supplied by the client, if
    any, and returns an appropriate code (which will, if nonzero,
    be USE_LOCAL_COPY). No similar considerations apply for
    <code>ap_set_content_length</code>, but it returns an error
    code for symmetry.</p>
<pre>
int default_handler (request_rec *r)
{
    int errstatus;
    FILE *f;

    if (r-&gt;method_number != M_GET) return DECLINED;
    if (r-&gt;finfo.st_mode == 0) return NOT_FOUND;

    if ((errstatus = ap_set_content_length (r, r-&gt;finfo.st_size))) {
        return errstatus;
    }

    r-&gt;mtime = r-&gt;finfo.st_mtime;
    ap_set_last_modified (r);

    f = ap_pfopen (r-&gt;pool, r-&gt;filename, "r");

    if (f == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
             "file permissions deny server access: %s", r-&gt;filename);
        return FORBIDDEN;
    }

    ap_soft_timeout ("send", r);
    ap_send_http_header (r);

    if (!r-&gt;header_only) ap_send_fd (f, r);
    ap_pfclose (r-&gt;pool, f);

    ap_kill_timeout (r);
    return OK;
}
</pre>
    Finally, if all of this is too much of a challenge, there are a
    few ways out of it. First off, as shown above, a response
    handler which has not yet produced any output can simply return
    an error code, in which case the server will automatically
    produce an error response. Secondly, it can punt to some other
    handler by invoking <code>ap_internal_redirect</code>, which is
    how the internal redirection machinery discussed above is
    invoked. A response handler which has internally redirected
    should always return <code>OK</code>. 

    <p>(Invoking <code>ap_internal_redirect</code> from handlers
    which are <em>not</em> response handlers will lead to serious
    confusion).</p>

    <h3><a id="auth_handlers" name="auth_handlers">Special
    considerations for authentication handlers</a></h3>
    Stuff that should be discussed here in detail: 

    <ul>
      <li>Authentication-phase handlers not invoked unless auth is
      configured for the directory.</li>

      <li>Common auth configuration stored in the core per-dir
      configuration; it has accessors <code>ap_auth_type</code>,
      <code>ap_auth_name</code>, and <code>ap_requires</code>.</li>

      <li>Common routines, to handle the protocol end of things, at
      least for HTTP basic authentication
      (<code>ap_get_basic_auth_pw</code>, which sets the
      <code>connection-&gt;user</code> structure field
      automatically, and <code>ap_note_basic_auth_failure</code>,
      which arranges for the proper <code>WWW-Authenticate:</code>
      header to be sent back).</li>
    </ul>

    <h3><a id="log_handlers" name="log_handlers">Special
    considerations for logging handlers</a></h3>
    When a request has internally redirected, there is the question
    of what to log. Apache handles this by bundling the entire
    chain of redirects into a list of <code>request_rec</code>
    structures which are threaded through the
    <code>r-&gt;prev</code> and <code>r-&gt;next</code> pointers.
    The <code>request_rec</code> which is passed to the logging
    handlers in such cases is the one which was originally built
    for the initial request from the client; note that the
    bytes_sent field will only be correct in the last request in
    the chain (the one for which a response was actually sent). 

    <h2><a id="pools" name="pools">Resource allocation and resource
    pools</a></h2>

    <p>One of the problems of writing and designing a server-pool
    server is that of preventing leakage, that is, allocating
    resources (memory, open files, <em>etc.</em>), without
    subsequently releasing them. The resource pool machinery is
    designed to make it easy to prevent this from happening, by
    allowing resource to be allocated in such a way that they are
    <em>automatically</em> released when the server is done with
    them.</p>

    <p>The way this works is as follows: the memory which is
    allocated, file opened, <em>etc.</em>, to deal with a
    particular request are tied to a <em>resource pool</em> which
    is allocated for the request. The pool is a data structure
    which itself tracks the resources in question.</p>

    <p>When the request has been processed, the pool is
    <em>cleared</em>. At that point, all the memory associated with
    it is released for reuse, all files associated with it are
    closed, and any other clean-up functions which are associated
    with the pool are run. When this is over, we can be confident
    that all the resource tied to the pool have been released, and
    that none of them have leaked.</p>

    <p>Server restarts, and allocation of memory and resources for
    per-server configuration, are handled in a similar way. There
    is a <em>configuration pool</em>, which keeps track of
    resources which were allocated while reading the server
    configuration files, and handling the commands therein (for
    instance, the memory that was allocated for per-server module
    configuration, log files and other files that were opened, and
    so forth). When the server restarts, and has to reread the
    configuration files, the configuration pool is cleared, and so
    the memory and file descriptors which were taken up by reading
    them the last time are made available for reuse.</p>

    <p>It should be noted that use of the pool machinery isn't
    generally obligatory, except for situations like logging
    handlers, where you really need to register cleanups to make
    sure that the log file gets closed when the server restarts
    (this is most easily done by using the function <code><a
    href="#pool-files">ap_pfopen</a></code>, which also arranges
    for the underlying file descriptor to be closed before any
    child processes, such as for CGI scripts, are
    <code>exec</code>ed), or in case you are using the timeout
    machinery (which isn't yet even documented here). However,
    there are two benefits to using it: resources allocated to a
    pool never leak (even if you allocate a scratch string, and
    just forget about it); also, for memory allocation,
    <code>ap_palloc</code> is generally faster than
    <code>malloc</code>.</p>

    <p>We begin here by describing how memory is allocated to
    pools, and then discuss how other resources are tracked by the
    resource pool machinery.</p>

    <h3>Allocation of memory in pools</h3>

    <p>Memory is allocated to pools by calling the function
    <code>ap_palloc</code>, which takes two arguments, one being a
    pointer to a resource pool structure, and the other being the
    amount of memory to allocate (in <code>char</code>s). Within
    handlers for handling requests, the most common way of getting
    a resource pool structure is by looking at the
    <code>pool</code> slot of the relevant
    <code>request_rec</code>; hence the repeated appearance of the
    following idiom in module code:</p>
<pre>
int my_handler(request_rec *r)
{
    struct my_structure *foo;
    ...

    foo = (foo *)ap_palloc (r-&gt;pool, sizeof(my_structure));
}
</pre>

    <p>Note that <em>there is no <code>ap_pfree</code></em> ---
    <code>ap_palloc</code>ed memory is freed only when the
    associated resource pool is cleared. This means that
    <code>ap_palloc</code> does not have to do as much accounting
    as <code>malloc()</code>; all it does in the typical case is to
    round up the size, bump a pointer, and do a range check.</p>

    <p>(It also raises the possibility that heavy use of
    <code>ap_palloc</code> could cause a server process to grow
    excessively large. There are two ways to deal with this, which
    are dealt with below; briefly, you can use <code>malloc</code>,
    and try to be sure that all of the memory gets explicitly
    <code>free</code>d, or you can allocate a sub-pool of the main
    pool, allocate your memory in the sub-pool, and clear it out
    periodically. The latter technique is discussed in the section
    on sub-pools below, and is used in the directory-indexing code,
    in order to avoid excessive storage allocation when listing
    directories with thousands of files).</p>

    <h3>Allocating initialized memory</h3>

    <p>There are functions which allocate initialized memory, and
    are frequently useful. The function <code>ap_pcalloc</code> has
    the same interface as <code>ap_palloc</code>, but clears out
    the memory it allocates before it returns it. The function
    <code>ap_pstrdup</code> takes a resource pool and a <code>char
    *</code> as arguments, and allocates memory for a copy of the
    string the pointer points to, returning a pointer to the copy.
    Finally <code>ap_pstrcat</code> is a varargs-style function,
    which takes a pointer to a resource pool, and at least two
    <code>char *</code> arguments, the last of which must be
    <code>NULL</code>. It allocates enough memory to fit copies of
    each of the strings, as a unit; for instance:</p>
<pre>
     ap_pstrcat (r-&gt;pool, "foo", "/", "bar", NULL);
</pre>

    <p>returns a pointer to 8 bytes worth of memory, initialized to
    <code>"foo/bar"</code>.</p>

    <h3><a id="pools-used" name="pools-used">Commonly-used pools in
    the Apache Web server</a></h3>

    <p>A pool is really defined by its lifetime more than anything
    else. There are some static pools in http_main which are passed
    to various non-http_main functions as arguments at opportune
    times. Here they are:</p>

    <dl compact="compact">
      <dt>permanent_pool</dt>

      <dd>
        <ul>
          <li>never passed to anything else, this is the ancestor
          of all pools</li>
        </ul>
      </dd>

      <dt>pconf</dt>

      <dd>
        <ul>
          <li>subpool of permanent_pool</li>

          <li>created at the beginning of a config "cycle"; exists
          until the server is terminated or restarts; passed to all
          config-time routines, either via cmd-&gt;pool, or as the
          "pool *p" argument on those which don't take pools</li>

          <li>passed to the module init() functions</li>
        </ul>
      </dd>

      <dt>ptemp</dt>

      <dd>
        <ul>
          <li>sorry I lie, this pool isn't called this currently in
          1.3, I renamed it this in my pthreads development. I'm
          referring to the use of ptrans in the parent... contrast
          this with the later definition of ptrans in the
          child.</li>

          <li>subpool of permanent_pool</li>

          <li>created at the beginning of a config "cycle"; exists
          until the end of config parsing; passed to config-time
          routines <em>via</em> cmd-&gt;temp_pool. Somewhat of a
          "bastard child" because it isn't available everywhere.
          Used for temporary scratch space which may be needed by
          some config routines but which is deleted at the end of
          config.</li>
        </ul>
      </dd>

      <dt>pchild</dt>

      <dd>
        <ul>
          <li>subpool of permanent_pool</li>

          <li>created when a child is spawned (or a thread is
          created); lives until that child (thread) is
          destroyed</li>

          <li>passed to the module child_init functions</li>

          <li>destruction happens right after the child_exit
          functions are called... (which may explain why I think
          child_exit is redundant and unneeded)</li>
        </ul>
      </dd>

      <dt>ptrans</dt>

      <dd>
        <ul>
          <li>should be a subpool of pchild, but currently is a
          subpool of permanent_pool, see above</li>

          <li>cleared by the child before going into the accept()
          loop to receive a connection</li>

          <li>used as connection-&gt;pool</li>
        </ul>
      </dd>

      <dt>r-&gt;pool</dt>

      <dd>
        <ul>
          <li>for the main request this is a subpool of
          connection-&gt;pool; for subrequests it is a subpool of
          the parent request's pool.</li>

          <li>exists until the end of the request (<em>i.e.</em>,
          ap_destroy_sub_req, or in child_main after
          process_request has finished)</li>

          <li>note that r itself is allocated from r-&gt;pool;
          <em>i.e.</em>, r-&gt;pool is first created and then r is
          the first thing palloc()d from it</li>
        </ul>
      </dd>
    </dl>

    <p>For almost everything folks do, r-&gt;pool is the pool to
    use. But you can see how other lifetimes, such as pchild, are
    useful to some modules... such as modules that need to open a
    database connection once per child, and wish to clean it up
    when the child dies.</p>

    <p>You can also see how some bugs have manifested themself,
    such as setting connection-&gt;user to a value from r-&gt;pool
    -- in this case connection exists for the lifetime of ptrans,
    which is longer than r-&gt;pool (especially if r-&gt;pool is a
    subrequest!). So the correct thing to do is to allocate from
    connection-&gt;pool.</p>

    <p>And there was another interesting bug in
    mod_include/mod_cgi. You'll see in those that they do this test
    to decide if they should use r-&gt;pool or r-&gt;main-&gt;pool.
    In this case the resource that they are registering for cleanup
    is a child process. If it were registered in r-&gt;pool, then
    the code would wait() for the child when the subrequest
    finishes. With mod_include this could be any old #include, and
    the delay can be up to 3 seconds... and happened quite
    frequently. Instead the subprocess is registered in
    r-&gt;main-&gt;pool which causes it to be cleaned up when the
    entire request is done -- <em>i.e.</em>, after the output has
    been sent to the client and logging has happened.</p>

    <h3><a id="pool-files" name="pool-files">Tracking open files,
    etc.</a></h3>

    <p>As indicated above, resource pools are also used to track
    other sorts of resources besides memory. The most common are
    open files. The routine which is typically used for this is
    <code>ap_pfopen</code>, which takes a resource pool and two
    strings as arguments; the strings are the same as the typical
    arguments to <code>fopen</code>, <em>e.g.</em>,</p>
<pre>
     ...
     FILE *f = ap_pfopen (r-&gt;pool, r-&gt;filename, "r");

     if (f == NULL) { ... } else { ... }
</pre>

    <p>There is also a <code>ap_popenf</code> routine, which
    parallels the lower-level <code>open</code> system call. Both
    of these routines arrange for the file to be closed when the
    resource pool in question is cleared.</p>

    <p>Unlike the case for memory, there <em>are</em> functions to
    close files allocated with <code>ap_pfopen</code>, and
    <code>ap_popenf</code>, namely <code>ap_pfclose</code> and
    <code>ap_pclosef</code>. (This is because, on many systems, the
    number of files which a single process can have open is quite
    limited). It is important to use these functions to close files
    allocated with <code>ap_pfopen</code> and
    <code>ap_popenf</code>, since to do otherwise could cause fatal
    errors on systems such as Linux, which react badly if the same
    <code>FILE*</code> is closed more than once.</p>

    <p>(Using the <code>close</code> functions is not mandatory,
    since the file will eventually be closed regardless, but you
    should consider it in cases where your module is opening, or
    could open, a lot of files).</p>

    <h3>Other sorts of resources --- cleanup functions</h3>

    <blockquote>
      More text goes here. Describe the the cleanup primitives in
      terms of which the file stuff is implemented; also,
      <code>spawn_process</code>.
    </blockquote>

    <p>Pool cleanups live until clear_pool() is called:
    clear_pool(a) recursively calls destroy_pool() on all subpools
    of a; then calls all the cleanups for a; then releases all the
    memory for a. destroy_pool(a) calls clear_pool(a) and then
    releases the pool structure itself. <em>i.e.</em>,
    clear_pool(a) doesn't delete a, it just frees up all the
    resources and you can start using it again immediately.</p>

    <h3>Fine control --- creating and dealing with sub-pools, with
    a note on sub-requests</h3>
    On rare occasions, too-free use of <code>ap_palloc()</code> and
    the associated primitives may result in undesirably profligate
    resource allocation. You can deal with such a case by creating
    a <em>sub-pool</em>, allocating within the sub-pool rather than
    the main pool, and clearing or destroying the sub-pool, which
    releases the resources which were associated with it. (This
    really <em>is</em> a rare situation; the only case in which it
    comes up in the standard module set is in case of listing
    directories, and then only with <em>very</em> large
    directories. Unnecessary use of the primitives discussed here
    can hair up your code quite a bit, with very little gain). 

    <p>The primitive for creating a sub-pool is
    <code>ap_make_sub_pool</code>, which takes another pool (the
    parent pool) as an argument. When the main pool is cleared, the
    sub-pool will be destroyed. The sub-pool may also be cleared or
    destroyed at any time, by calling the functions
    <code>ap_clear_pool</code> and <code>ap_destroy_pool</code>,
    respectively. (The difference is that
    <code>ap_clear_pool</code> frees resources associated with the
    pool, while <code>ap_destroy_pool</code> also deallocates the
    pool itself. In the former case, you can allocate new resources
    within the pool, and clear it again, and so forth; in the
    latter case, it is simply gone).</p>

    <p>One final note --- sub-requests have their own resource
    pools, which are sub-pools of the resource pool for the main
    request. The polite way to reclaim the resources associated
    with a sub request which you have allocated (using the
    <code>ap_sub_req_...</code> functions) is
    <code>ap_destroy_sub_req</code>, which frees the resource pool.
    Before calling this function, be sure to copy anything that you
    care about which might be allocated in the sub-request's
    resource pool into someplace a little less volatile (for
    instance, the filename in its <code>request_rec</code>
    structure).</p>

    <p>(Again, under most circumstances, you shouldn't feel obliged
    to call this function; only 2K of memory or so are allocated
    for a typical sub request, and it will be freed anyway when the
    main request pool is cleared. It is only when you are
    allocating many, many sub-requests for a single main request
    that you should seriously consider the
    <code>ap_destroy_...</code> functions).</p>

    <h2><a id="config" name="config">Configuration, commands and
    the like</a></h2>
    One of the design goals for this server was to maintain
    external compatibility with the NCSA 1.3 server --- that is, to
    read the same configuration files, to process all the
    directives therein correctly, and in general to be a drop-in
    replacement for NCSA. On the other hand, another design goal
    was to move as much of the server's functionality into modules
    which have as little as possible to do with the monolithic
    server core. The only way to reconcile these goals is to move
    the handling of most commands from the central server into the
    modules. 

    <p>However, just giving the modules command tables is not
    enough to divorce them completely from the server core. The
    server has to remember the commands in order to act on them
    later. That involves maintaining data which is private to the
    modules, and which can be either per-server, or per-directory.
    Most things are per-directory, including in particular access
    control and authorization information, but also information on
    how to determine file types from suffixes, which can be
    modified by <code>AddType</code> and <code>DefaultType</code>
    directives, and so forth. In general, the governing philosophy
    is that anything which <em>can</em> be made configurable by
    directory should be; per-server information is generally used
    in the standard set of modules for information like
    <code>Alias</code>es and <code>Redirect</code>s which come into
    play before the request is tied to a particular place in the
    underlying file system.</p>

    <p>Another requirement for emulating the NCSA server is being
    able to handle the per-directory configuration files, generally
    called <code>.htaccess</code> files, though even in the NCSA
    server they can contain directives which have nothing at all to
    do with access control. Accordingly, after URI -&gt; filename
    translation, but before performing any other phase, the server
    walks down the directory hierarchy of the underlying
    filesystem, following the translated pathname, to read any
    <code>.htaccess</code> files which might be present. The
    information which is read in then has to be <em>merged</em>
    with the applicable information from the server's own config
    files (either from the <code>&lt;Directory&gt;</code> sections
    in <code>access.conf</code>, or from defaults in
    <code>srm.conf</code>, which actually behaves for most purposes
    almost exactly like <code>&lt;Directory /&gt;</code>).</p>

    <p>Finally, after having served a request which involved
    reading <code>.htaccess</code> files, we need to discard the
    storage allocated for handling them. That is solved the same
    way it is solved wherever else similar problems come up, by
    tying those structures to the per-transaction resource
    pool.</p>

    <h3><a id="per-dir" name="per-dir">Per-directory configuration
    structures</a></h3>
    Let's look out how all of this plays out in
    <code>mod_mime.c</code>, which defines the file typing handler
    which emulates the NCSA server's behavior of determining file
    types from suffixes. What we'll be looking at, here, is the
    code which implements the <code>AddType</code> and
    <code>AddEncoding</code> commands. These commands can appear in
    <code>.htaccess</code> files, so they must be handled in the
    module's private per-directory data, which in fact, consists of
    two separate <code>table</code>s for MIME types and encoding
    information, and is declared as follows: 
<pre>
typedef struct {
    table *forced_types;      /* Additional AddTyped stuff */
    table *encoding_types;    /* Added with AddEncoding... */
} mime_dir_config;
</pre>
    When the server is reading a configuration file, or
    <code>&lt;Directory&gt;</code> section, which includes one of
    the MIME module's commands, it needs to create a
    <code>mime_dir_config</code> structure, so those commands have
    something to act on. It does this by invoking the function it
    finds in the module's `create per-dir config slot', with two
    arguments: the name of the directory to which this
    configuration information applies (or <code>NULL</code> for
    <code>srm.conf</code>), and a pointer to a resource pool in
    which the allocation should happen. 

    <p>(If we are reading a <code>.htaccess</code> file, that
    resource pool is the per-request resource pool for the request;
    otherwise it is a resource pool which is used for configuration
    data, and cleared on restarts. Either way, it is important for
    the structure being created to vanish when the pool is cleared,
    by registering a cleanup on the pool if necessary).</p>

    <p>For the MIME module, the per-dir config creation function
    just <code>ap_palloc</code>s the structure above, and a creates
    a couple of <code>table</code>s to fill it. That looks like
    this:</p>
<pre>
void *create_mime_dir_config (pool *p, char *dummy)
{
    mime_dir_config *new =
      (mime_dir_config *) ap_palloc (p, sizeof(mime_dir_config));

    new-&gt;forced_types = ap_make_table (p, 4);
    new-&gt;encoding_types = ap_make_table (p, 4);

    return new;
}
</pre>
    Now, suppose we've just read in a <code>.htaccess</code> file.
    We already have the per-directory configuration structure for
    the next directory up in the hierarchy. If the
    <code>.htaccess</code> file we just read in didn't have any
    <code>AddType</code> or <code>AddEncoding</code> commands, its
    per-directory config structure for the MIME module is still
    valid, and we can just use it. Otherwise, we need to merge the
    two structures somehow. 

    <p>To do that, the server invokes the module's per-directory
    config merge function, if one is present. That function takes
    three arguments: the two structures being merged, and a
    resource pool in which to allocate the result. For the MIME
    module, all that needs to be done is overlay the tables from
    the new per-directory config structure with those from the
    parent:</p>
<pre>
void *merge_mime_dir_configs (pool *p, void *parent_dirv, void *subdirv)
{
    mime_dir_config *parent_dir = (mime_dir_config *)parent_dirv;
    mime_dir_config *subdir = (mime_dir_config *)subdirv;
    mime_dir_config *new =
      (mime_dir_config *)ap_palloc (p, sizeof(mime_dir_config));

    new-&gt;forced_types = ap_overlay_tables (p, subdir-&gt;forced_types,
                                        parent_dir-&gt;forced_types);
    new-&gt;encoding_types = ap_overlay_tables (p, subdir-&gt;encoding_types,
                                          parent_dir-&gt;encoding_types);

    return new;
}
</pre>
    As a note --- if there is no per-directory merge function
    present, the server will just use the subdirectory's
    configuration info, and ignore the parent's. For some modules,
    that works just fine (<em>e.g.</em>, for the includes module,
    whose per-directory configuration information consists solely
    of the state of the <code>XBITHACK</code>), and for those
    modules, you can just not declare one, and leave the
    corresponding structure slot in the module itself
    <code>NULL</code>. 

    <h3><a id="commands" name="commands">Command handling</a></h3>
    Now that we have these structures, we need to be able to figure
    out how to fill them. That involves processing the actual
    <code>AddType</code> and <code>AddEncoding</code> commands. To
    find commands, the server looks in the module's <code>command
    table</code>. That table contains information on how many
    arguments the commands take, and in what formats, where it is
    permitted, and so forth. That information is sufficient to
    allow the server to invoke most command-handling functions with
    pre-parsed arguments. Without further ado, let's look at the
    <code>AddType</code> command handler, which looks like this
    (the <code>AddEncoding</code> command looks basically the same,
    and won't be shown here): 
<pre>
char *add_type(cmd_parms *cmd, mime_dir_config *m, char *ct, char *ext)
{
    if (*ext == '.') ++ext;
    ap_table_set (m-&gt;forced_types, ext, ct);
    return NULL;
}
</pre>
    This command handler is unusually simple. As you can see, it
    takes four arguments, two of which are pre-parsed arguments,
    the third being the per-directory configuration structure for
    the module in question, and the fourth being a pointer to a
    <code>cmd_parms</code> structure. That structure contains a
    bunch of arguments which are frequently of use to some, but not
    all, commands, including a resource pool (from which memory can
    be allocated, and to which cleanups should be tied), and the
    (virtual) server being configured, from which the module's
    per-server configuration data can be obtained if required. 

    <p>Another way in which this particular command handler is
    unusually simple is that there are no error conditions which it
    can encounter. If there were, it could return an error message
    instead of <code>NULL</code>; this causes an error to be
    printed out on the server's <code>stderr</code>, followed by a
    quick exit, if it is in the main config files; for a
    <code>.htaccess</code> file, the syntax error is logged in the
    server error log (along with an indication of where it came
    from), and the request is bounced with a server error response
    (HTTP error status, code 500).</p>

    <p>The MIME module's command table has entries for these
    commands, which look like this:</p>
<pre>
command_rec mime_cmds[] = {
{ "AddType", add_type, NULL, OR_FILEINFO, TAKE2,
    "a mime type followed by a file extension" },
{ "AddEncoding", add_encoding, NULL, OR_FILEINFO, TAKE2,
    "an encoding (<em>e.g.</em>, gzip), followed by a file extension" },
{ NULL }
};
</pre>
    The entries in these tables are: 

    <ul>
      <li>The name of the command</li>

      <li>The function which handles it</li>

      <li>a <code>(void *)</code> pointer, which is passed in the
      <code>cmd_parms</code> structure to the command handler ---
      this is useful in case many similar commands are handled by
      the same function.</li>

      <li>A bit mask indicating where the command may appear. There
      are mask bits corresponding to each
      <code>AllowOverride</code> option, and an additional mask
      bit, <code>RSRC_CONF</code>, indicating that the command may
      appear in the server's own config files, but <em>not</em> in
      any <code>.htaccess</code> file.</li>

      <li>A flag indicating how many arguments the command handler
      wants pre-parsed, and how they should be passed in.
      <code>TAKE2</code> indicates two pre-parsed arguments. Other
      options are <code>TAKE1</code>, which indicates one
      pre-parsed argument, <code>FLAG</code>, which indicates that
      the argument should be <code>On</code> or <code>Off</code>,
      and is passed in as a boolean flag, <code>RAW_ARGS</code>,
      which causes the server to give the command the raw, unparsed
      arguments (everything but the command name itself). There is
      also <code>ITERATE</code>, which means that the handler looks
      the same as <code>TAKE1</code>, but that if multiple
      arguments are present, it should be called multiple times,
      and finally <code>ITERATE2</code>, which indicates that the
      command handler looks like a <code>TAKE2</code>, but if more
      arguments are present, then it should be called multiple
      times, holding the first argument constant.</li>

      <li>Finally, we have a string which describes the arguments
      that should be present. If the arguments in the actual config
      file are not as required, this string will be used to help
      give a more specific error message. (You can safely leave
      this <code>NULL</code>).</li>
    </ul>
    Finally, having set this all up, we have to use it. This is
    ultimately done in the module's handlers, specifically for its
    file-typing handler, which looks more or less like this; note
    that the per-directory configuration structure is extracted
    from the <code>request_rec</code>'s per-directory configuration
    vector by using the <code>ap_get_module_config</code> function.
    
<pre>
int find_ct(request_rec *r)
{
    int i;
    char *fn = ap_pstrdup (r-&gt;pool, r-&gt;filename);
    mime_dir_config *conf = (mime_dir_config *)
             ap_get_module_config(r-&gt;per_dir_config, &amp;mime_module);
    char *type;

    if (S_ISDIR(r-&gt;finfo.st_mode)) {
        r-&gt;content_type = DIR_MAGIC_TYPE;
        return OK;
    }

    if((i=ap_rind(fn,'.')) &lt; 0) return DECLINED;
    ++i;

    if ((type = ap_table_get (conf-&gt;encoding_types, &amp;fn[i])))
    {
        r-&gt;content_encoding = type;

        /* go back to previous extension to try to use it as a type */

        fn[i-1] = '\0';
        if((i=ap_rind(fn,'.')) &lt; 0) return OK;
        ++i;
    }

    if ((type = ap_table_get (conf-&gt;forced_types, &amp;fn[i])))
    {
        r-&gt;content_type = type;
    }

    return OK;
}

</pre>

    <h3><a id="servconf" name="servconf">Side notes --- per-server
    configuration, virtual servers, <em>etc</em>.</a></h3>
    The basic ideas behind per-server module configuration are
    basically the same as those for per-directory configuration;
    there is a creation function and a merge function, the latter
    being invoked where a virtual server has partially overridden
    the base server configuration, and a combined structure must be
    computed. (As with per-directory configuration, the default if
    no merge function is specified, and a module is configured in
    some virtual server, is that the base configuration is simply
    ignored). 

    <p>The only substantial difference is that when a command needs
    to configure the per-server private module data, it needs to go
    to the <code>cmd_parms</code> data to get at it. Here's an
    example, from the alias module, which also indicates how a
    syntax error can be returned (note that the per-directory
    configuration argument to the command handler is declared as a
    dummy, since the module doesn't actually have per-directory
    config data):</p>
<pre>
char *add_redirect(cmd_parms *cmd, void *dummy, char *f, char *url)
{
    server_rec *s = cmd-&gt;server;
    alias_server_conf *conf = (alias_server_conf *)
            ap_get_module_config(s-&gt;module_config,&amp;alias_module);
    alias_entry *new = ap_push_array (conf-&gt;redirects);

    if (!ap_is_url (url)) return "Redirect to non-URL";

    new-&gt;fake = f; new-&gt;real = url;
    return NULL;
}
</pre>
        <hr />

    <h3 align="CENTER">Apache HTTP Server Version 1.3</h3>
    <a href="./"><img src="../images/index.gif" alt="Index" /></a>
    <a href="../"><img src="../images/home.gif" alt="Home" /></a>

  </body>
</html>

@


1.5
log
@merge apache 1.3.29 and mod_ssl 2.8.16
ok brad@@
@
text
@@


1.4
log
@fix half baked abortion of a merge to 1.3.23 and take
tree to apache-1.3.24+mod+ssl2.8.8
@
text
@d499 1
a499 1
    if ((errstatus = ap_set_content_length (r, r-&gt;finfo.st_size)) {
@


1.3
log
@Apache 1.3.23+mod_ssl-2.8.6-1.3.23 merge
@
text
@d499 1
a499 2
    if ((errstatus = ap_set_content_length (r, r-&gt;finfo.st_size))
    || (errstatus = ap_set_last_modified (r, r-&gt;finfo.st_mtime)))
d501 4
d506 1
a506 1
    f = fopen (r-&gt;filename, "r");
d509 2
a510 2
        log_reason("file permissions deny server access",
                   r-&gt;filename, r);
d514 1
a514 1
    register_timeout ("send", r);
d517 1
a517 1
    if (!r-&gt;header_only) send_fd (f, r);
d519 2
@


1.2
log
@Apache 1.3.9 + Mod_ssl 2.4.2 - now builds with apaci nastiness.
@
text
@d1 2
a2 169
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML><HEAD>
<TITLE>Apache API notes</TITLE>
</HEAD>
<!-- Background white, links blue (unvisited), navy (visited), red (active) -->
<BODY
 BGCOLOR="#FFFFFF"
 TEXT="#000000"
 LINK="#0000FF"
 VLINK="#000080"
 ALINK="#FF0000"
>
<DIV ALIGN="CENTER">
 <IMG SRC="../images/sub.gif" ALT="[APACHE DOCUMENTATION]">
 <H3>
  Apache HTTP Server Version 1.3
 </H3>
</DIV>

<H1 ALIGN="CENTER">Apache API notes</H1>

These are some notes on the Apache API and the data structures you
have to deal with, <EM>etc.</EM>  They are not yet nearly complete, but
hopefully, they will help you get your bearings.  Keep in mind that
the API is still subject to change as we gain experience with it.
(See the TODO file for what <EM>might</EM> be coming).  However,
it will be easy to adapt modules to any changes that are made.
(We have more modules to adapt than you do).
<P>

A few notes on general pedagogical style here.  In the interest of
conciseness, all structure declarations here are incomplete --- the
real ones have more slots that I'm not telling you about.  For the
most part, these are reserved to one component of the server core or
another, and should be altered by modules with caution.  However, in
some cases, they really are things I just haven't gotten around to
yet.  Welcome to the bleeding edge.<P>

Finally, here's an outline, to give you some bare idea of what's
coming up, and in what order:

<UL>
<LI> <A HREF="#basics">Basic concepts.</A>
<MENU>
 <LI> <A HREF="#HMR">Handlers, Modules, and Requests</A>
 <LI> <A HREF="#moduletour">A brief tour of a module</A>
</MENU>
<LI> <A HREF="#handlers">How handlers work</A>
<MENU>
 <LI> <A HREF="#req_tour">A brief tour of the <CODE>request_rec</CODE></A>
 <LI> <A HREF="#req_orig">Where request_rec structures come from</A>
 <LI> <A HREF="#req_return">Handling requests, declining, and returning error
  codes</A>
 <LI> <A HREF="#resp_handlers">Special considerations for response handlers</A>
 <LI> <A HREF="#auth_handlers">Special considerations for authentication
  handlers</A>
 <LI> <A HREF="#log_handlers">Special considerations for logging handlers</A>
</MENU>
<LI> <A HREF="#pools">Resource allocation and resource pools</A>
<LI> <A HREF="#config">Configuration, commands and the like</A>
<MENU>
 <LI> <A HREF="#per-dir">Per-directory configuration structures</A>
 <LI> <A HREF="#commands">Command handling</A>
 <LI> <A HREF="#servconf">Side notes --- per-server configuration,
  virtual servers, <EM>etc</EM>.</A>
</MENU>
</UL>

<H2><A NAME="basics">Basic concepts.</A></H2>

We begin with an overview of the basic concepts behind the
API, and how they are manifested in the code.

<H3><A NAME="HMR">Handlers, Modules, and Requests</A></H3>

Apache breaks down request handling into a series of steps, more or
less the same way the Netscape server API does (although this API has
a few more stages than NetSite does, as hooks for stuff I thought
might be useful in the future).  These are:

<UL>
  <LI> URI -&gt; Filename translation
  <LI> Auth ID checking [is the user who they say they are?]
  <LI> Auth access checking [is the user authorized <EM>here</EM>?]
  <LI> Access checking other than auth
  <LI> Determining MIME type of the object requested
  <LI> `Fixups' --- there aren't any of these yet, but the phase is
       intended as a hook for possible extensions like
       <CODE>SetEnv</CODE>, which don't really fit well elsewhere.
  <LI> Actually sending a response back to the client.
  <LI> Logging the request
</UL>

These phases are handled by looking at each of a succession of
<EM>modules</EM>, looking to see if each of them has a handler for the
phase, and attempting invoking it if so.  The handler can typically do
one of three things:

<UL>
  <LI> <EM>Handle</EM> the request, and indicate that it has done so
       by returning the magic constant <CODE>OK</CODE>.
  <LI> <EM>Decline</EM> to handle the request, by returning the magic
       integer constant <CODE>DECLINED</CODE>.  In this case, the
       server behaves in all respects as if the handler simply hadn't
       been there.
  <LI> Signal an error, by returning one of the HTTP error codes.
       This terminates normal handling of the request, although an
       ErrorDocument may be invoked to try to mop up, and it will be
       logged in any case.
</UL>

Most phases are terminated by the first module that handles them;
however, for logging, `fixups', and non-access authentication
checking, all handlers always run (barring an error).  Also, the
response phase is unique in that modules may declare multiple handlers
for it, via a dispatch table keyed on the MIME type of the requested
object.  Modules may declare a response-phase handler which can handle
<EM>any</EM> request, by giving it the key <CODE>*/*</CODE> (<EM>i.e.</EM>, a
wildcard MIME type specification).  However, wildcard handlers are
only invoked if the server has already tried and failed to find a more
specific response handler for the MIME type of the requested object
(either none existed, or they all declined).<P>

The handlers themselves are functions of one argument (a
<CODE>request_rec</CODE> structure. vide infra), which returns an
integer, as above.<P>

<H3><A NAME="moduletour">A brief tour of a module</A></H3>

At this point, we need to explain the structure of a module.  Our
candidate will be one of the messier ones, the CGI module --- this
handles both CGI scripts and the <CODE>ScriptAlias</CODE> config file
command.  It's actually a great deal more complicated than most
modules, but if we're going to have only one example, it might as well
be the one with its fingers in every place.<P>

Let's begin with handlers.  In order to handle the CGI scripts, the
module declares a response handler for them. Because of
<CODE>ScriptAlias</CODE>, it also has handlers for the name
translation phase (to recognize <CODE>ScriptAlias</CODE>ed URIs), the
type-checking phase (any <CODE>ScriptAlias</CODE>ed request is typed
as a CGI script).<P>

The module needs to maintain some per (virtual)
server information, namely, the <CODE>ScriptAlias</CODE>es in effect;
the module structure therefore contains pointers to a functions which
builds these structures, and to another which combines two of them (in
case the main server and a virtual server both have
<CODE>ScriptAlias</CODE>es declared).<P>

Finally, this module contains code to handle the
<CODE>ScriptAlias</CODE> command itself.  This particular module only
declares one command, but there could be more, so modules have
<EM>command tables</EM> which declare their commands, and describe
where they are permitted, and how they are to be invoked.  <P>

A final note on the declared types of the arguments of some of these
commands: a <CODE>pool</CODE> is a pointer to a <EM>resource pool</EM>
structure; these are used by the server to keep track of the memory
which has been allocated, files opened, <EM>etc.</EM>, either to service a
particular request, or to handle the process of configuring itself.
That way, when the request is over (or, for the configuration pool,
when the server is restarting), the memory can be freed, and the files
closed, <EM>en masse</EM>, without anyone having to write explicit code to
track them all down and dispose of them.  Also, a
<CODE>cmd_parms</CODE> structure contains various information about
the config file being read, and other status information, which is
sometimes of use to the function which processes a config-file command
(such as <CODE>ScriptAlias</CODE>).
d4 212
a215 3
With no further ado, the module itself:

<PRE>
d267 1
a267 3
</PRE>

<H2><A NAME="handlers">How handlers work</A></H2>
d269 38
a306 31
The sole argument to handlers is a <CODE>request_rec</CODE> structure.
This structure describes a particular request which has been made to
the server, on behalf of a client.  In most cases, each connection to
the client generates only one <CODE>request_rec</CODE> structure.<P>

<H3><A NAME="req_tour">A brief tour of the <CODE>request_rec</CODE></A></H3>

The <CODE>request_rec</CODE> contains pointers to a resource pool
which will be cleared when the server is finished handling the
request; to structures containing per-server and per-connection
information, and most importantly, information on the request itself.<P>

The most important such information is a small set of character
strings describing attributes of the object being requested, including
its URI, filename, content-type and content-encoding (these being filled
in by the translation and type-check handlers which handle the
request, respectively). <P>

Other commonly used data items are tables giving the MIME headers on
the client's original request, MIME headers to be sent back with the
response (which modules can add to at will), and environment variables
for any subprocesses which are spawned off in the course of servicing
the request.  These tables are manipulated using the
<CODE>ap_table_get</CODE> and <CODE>ap_table_set</CODE> routines. <P>
<BLOCKQUOTE>
 Note that the <SAMP>Content-type</SAMP> header value <EM>cannot</EM> be
 set by module content-handlers using the <SAMP>ap_table_*()</SAMP>
 routines.  Rather, it is set by pointing the <SAMP>content_type</SAMP>
 field in the <SAMP>request_rec</SAMP> structure to an appropriate
 string.  <EM>E.g.</EM>,
 <PRE>
d308 18
a325 17
 </PRE>
</BLOCKQUOTE>
Finally, there are pointers to two data structures which, in turn,
point to per-module configuration structures.  Specifically, these
hold pointers to the data structures which the module has built to
describe the way it has been configured to operate in a given
directory (via <CODE>.htaccess</CODE> files or
<CODE>&lt;Directory&gt;</CODE> sections), for private data it has
built in the course of servicing the request (so modules' handlers for
one phase can pass `notes' to their handlers for other phases).  There
is another such configuration vector in the <CODE>server_rec</CODE>
data structure pointed to by the <CODE>request_rec</CODE>, which
contains per (virtual) server configuration data.<P>

Here is an abridged declaration, giving the fields most commonly used:<P>

<PRE>
d363 2
a364 2
  char *method;        /* GET, HEAD, POST, <EM>etc.</EM> */
  int method_number;   /* M_GET, M_POST, <EM>etc.</EM> */
d382 1
a382 1
  void *per_dir_config;   /* Options set in config files, <EM>etc.</EM> */
d387 1
a387 96
</PRE>

<H3><A NAME="req_orig">Where request_rec structures come from</A></H3>

Most <CODE>request_rec</CODE> structures are built by reading an HTTP
request from a client, and filling in the fields.  However, there are
a few exceptions:

<UL>
  <LI> If the request is to an imagemap, a type map (<EM>i.e.</EM>, a
       <CODE>*.var</CODE> file), or a CGI script which returned a
       local `Location:', then the resource which the user requested
       is going to be ultimately located by some URI other than what
       the client originally supplied.  In this case, the server does
       an <EM>internal redirect</EM>, constructing a new
       <CODE>request_rec</CODE> for the new URI, and processing it
       almost exactly as if the client had requested the new URI
       directly. <P>

  <LI> If some handler signaled an error, and an
       <CODE>ErrorDocument</CODE> is in scope, the same internal
       redirect machinery comes into play.<P>

  <LI> Finally, a handler occasionally needs to investigate `what
       would happen if' some other request were run.  For instance,
       the directory indexing module needs to know what MIME type
       would be assigned to a request for each directory entry, in
       order to figure out what icon to use.<P>

       Such handlers can construct a <EM>sub-request</EM>, using the
       functions <CODE>ap_sub_req_lookup_file</CODE>,
       <CODE>ap_sub_req_lookup_uri</CODE>, and
       <CODE>ap_sub_req_method_uri</CODE>; these construct a new
       <CODE>request_rec</CODE> structure and processes it as you
       would expect, up to but not including the point of actually
       sending a response.  (These functions skip over the access
       checks if the sub-request is for a file in the same directory
       as the original request).<P>

       (Server-side includes work by building sub-requests and then
       actually invoking the response handler for them, via the
       function <CODE>ap_run_sub_req</CODE>).
</UL>

<H3><A NAME="req_return">Handling requests, declining, and returning error
 codes</A></H3>

As discussed above, each handler, when invoked to handle a particular
<CODE>request_rec</CODE>, has to return an <CODE>int</CODE> to
indicate what happened.  That can either be

<UL>
  <LI> OK --- the request was handled successfully.  This may or may
       not terminate the phase.
  <LI> DECLINED --- no erroneous condition exists, but the module
       declines to handle the phase; the server tries to find another.
  <LI> an HTTP error code, which aborts handling of the request.
</UL>

Note that if the error code returned is <CODE>REDIRECT</CODE>, then
the module should put a <CODE>Location</CODE> in the request's
<CODE>headers_out</CODE>, to indicate where the client should be
redirected <EM>to</EM>. <P>

<H3><A NAME="resp_handlers">Special considerations for response
 handlers</A></H3>

Handlers for most phases do their work by simply setting a few fields
in the <CODE>request_rec</CODE> structure (or, in the case of access
checkers, simply by returning the correct error code).  However,
response handlers have to actually send a request back to the client. <P>

They should begin by sending an HTTP response header, using the
function <CODE>ap_send_http_header</CODE>.  (You don't have to do
anything special to skip sending the header for HTTP/0.9 requests; the
function figures out on its own that it shouldn't do anything).  If
the request is marked <CODE>header_only</CODE>, that's all they should
do; they should return after that, without attempting any further
output.  <P>

Otherwise, they should produce a request body which responds to the
client as appropriate.  The primitives for this are <CODE>ap_rputc</CODE>
and <CODE>ap_rprintf</CODE>, for internally generated output, and
<CODE>ap_send_fd</CODE>, to copy the contents of some <CODE>FILE *</CODE>
straight to the client.  <P>

At this point, you should more or less understand the following piece
of code, which is the handler which handles <CODE>GET</CODE> requests
which have no more specific handler; it also shows how conditional
<CODE>GET</CODE>s can be handled, if it's desirable to do so in a
particular response handler --- <CODE>ap_set_last_modified</CODE> checks
against the <CODE>If-modified-since</CODE> value supplied by the
client, if any, and returns an appropriate code (which will, if
nonzero, be USE_LOCAL_COPY).   No similar considerations apply for
<CODE>ap_set_content_length</CODE>, but it returns an error code for
symmetry.<P>
d389 102
a490 1
<PRE>
d500 1
a500 1
	|| (errstatus = ap_set_last_modified (r, r-&gt;finfo.st_mtime)))
d518 119
a636 113
</PRE>

Finally, if all of this is too much of a challenge, there are a few
ways out of it.  First off, as shown above, a response handler which
has not yet produced any output can simply return an error code, in
which case the server will automatically produce an error response.
Secondly, it can punt to some other handler by invoking
<CODE>ap_internal_redirect</CODE>, which is how the internal redirection
machinery discussed above is invoked.  A response handler which has
internally redirected should always return <CODE>OK</CODE>. <P>

(Invoking <CODE>ap_internal_redirect</CODE> from handlers which are
<EM>not</EM> response handlers will lead to serious confusion).

<H3><A NAME="auth_handlers">Special considerations for authentication
 handlers</A></H3>

Stuff that should be discussed here in detail:

<UL>
  <LI> Authentication-phase handlers not invoked unless auth is
       configured for the directory.
  <LI> Common auth configuration stored in the core per-dir
       configuration; it has accessors <CODE>ap_auth_type</CODE>,
       <CODE>ap_auth_name</CODE>, and <CODE>ap_requires</CODE>.
  <LI> Common routines, to handle the protocol end of things, at least
       for HTTP basic authentication (<CODE>ap_get_basic_auth_pw</CODE>,
       which sets the <CODE>connection-&gt;user</CODE> structure field
       automatically, and <CODE>ap_note_basic_auth_failure</CODE>, which
       arranges for the proper <CODE>WWW-Authenticate:</CODE> header
       to be sent back).
</UL>

<H3><A NAME="log_handlers">Special considerations for logging handlers</A></H3>

When a request has internally redirected, there is the question of
what to log.  Apache handles this by bundling the entire chain of
redirects into a list of <CODE>request_rec</CODE> structures which are
threaded through the <CODE>r-&gt;prev</CODE> and <CODE>r-&gt;next</CODE>
pointers.  The <CODE>request_rec</CODE> which is passed to the logging
handlers in such cases is the one which was originally built for the
initial request from the client; note that the bytes_sent field will
only be correct in the last request in the chain (the one for which a
response was actually sent).

<H2><A NAME="pools">Resource allocation and resource pools</A></H2>
<P>
One of the problems of writing and designing a server-pool server is
that of preventing leakage, that is, allocating resources (memory,
open files, <EM>etc.</EM>), without subsequently releasing them.  The resource
pool machinery is designed to make it easy to prevent this from
happening, by allowing resource to be allocated in such a way that
they are <EM>automatically</EM> released when the server is done with
them.
</P>
<P>
The way this works is as follows:  the memory which is allocated, file
opened, <EM>etc.</EM>, to deal with a particular request are tied to a
<EM>resource pool</EM> which is allocated for the request.  The pool
is a data structure which itself tracks the resources in question.
</P>
<P>
When the request has been processed, the pool is <EM>cleared</EM>.  At
that point, all the memory associated with it is released for reuse,
all files associated with it are closed, and any other clean-up
functions which are associated with the pool are run.  When this is
over, we can be confident that all the resource tied to the pool have
been released, and that none of them have leaked.
</P>
<P>
Server restarts, and allocation of memory and resources for per-server
configuration, are handled in a similar way.  There is a
<EM>configuration pool</EM>, which keeps track of resources which were
allocated while reading the server configuration files, and handling
the commands therein (for instance, the memory that was allocated for
per-server module configuration, log files and other files that were
opened, and so forth).  When the server restarts, and has to reread
the configuration files, the configuration pool is cleared, and so the
memory and file descriptors which were taken up by reading them the
last time are made available for reuse.
</P>
<P>
It should be noted that use of the pool machinery isn't generally
obligatory, except for situations like logging handlers, where you
really need to register cleanups to make sure that the log file gets
closed when the server restarts (this is most easily done by using the
function <CODE><A HREF="#pool-files">ap_pfopen</A></CODE>, which also
arranges for the underlying file descriptor to be closed before any
child processes, such as for CGI scripts, are <CODE>exec</CODE>ed), or
in case you are using the timeout machinery (which isn't yet even
documented here).  However, there are two benefits to using it:
resources allocated to a pool never leak (even if you allocate a
scratch string, and just forget about it); also, for memory
allocation, <CODE>ap_palloc</CODE> is generally faster than
<CODE>malloc</CODE>.
</P>
<P>
We begin here by describing how memory is allocated to pools, and then
discuss how other resources are tracked by the resource pool
machinery.
</P>
<H3>Allocation of memory in pools</H3>
<P>
Memory is allocated to pools by calling the function
<CODE>ap_palloc</CODE>, which takes two arguments, one being a pointer to
a resource pool structure, and the other being the amount of memory to
allocate (in <CODE>char</CODE>s).  Within handlers for handling
requests, the most common way of getting a resource pool structure is
by looking at the <CODE>pool</CODE> slot of the relevant
<CODE>request_rec</CODE>; hence the repeated appearance of the
following idiom in module code:
</P>
<PRE>
d644 36
a679 36
</PRE>
<P>
Note that <EM>there is no <CODE>ap_pfree</CODE></EM> ---
<CODE>ap_palloc</CODE>ed memory is freed only when the associated
resource pool is cleared.  This means that <CODE>ap_palloc</CODE> does not
have to do as much accounting as <CODE>malloc()</CODE>; all it does in
the typical case is to round up the size, bump a pointer, and do a
range check.
</P>
<P>
(It also raises the possibility that heavy use of <CODE>ap_palloc</CODE>
could cause a server process to grow excessively large.  There are
two ways to deal with this, which are dealt with below; briefly, you
can use <CODE>malloc</CODE>, and try to be sure that all of the memory
gets explicitly <CODE>free</CODE>d, or you can allocate a sub-pool of
the main pool, allocate your memory in the sub-pool, and clear it out
periodically.  The latter technique is discussed in the section on
sub-pools below, and is used in the directory-indexing code, in order
to avoid excessive storage allocation when listing directories with
thousands of files).
</P>
<H3>Allocating initialized memory</H3>
<P>
There are functions which allocate initialized memory, and are
frequently useful.  The function <CODE>ap_pcalloc</CODE> has the same
interface as <CODE>ap_palloc</CODE>, but clears out the memory it
allocates before it returns it.  The function <CODE>ap_pstrdup</CODE>
takes a resource pool and a <CODE>char *</CODE> as arguments, and
allocates memory for a copy of the string the pointer points to,
returning a pointer to the copy.  Finally <CODE>ap_pstrcat</CODE> is a
varargs-style function, which takes a pointer to a resource pool, and
at least two <CODE>char *</CODE> arguments, the last of which must be
<CODE>NULL</CODE>.  It allocates enough memory to fit copies of each
of the strings, as a unit; for instance:
</P>
<PRE>
d681 147
a827 139
</PRE>
<P>
returns a pointer to 8 bytes worth of memory, initialized to
<CODE>"foo/bar"</CODE>.
</P>
<H3><A NAME="pools-used">Commonly-used pools in the Apache Web server</A></H3>
<P>
A pool is really defined by its lifetime more than anything else.  There
are some static pools in http_main which are passed to various
non-http_main functions as arguments at opportune times.  Here they are:
</P>
<DL COMPACT>
 <DT>permanent_pool
 </DT>
 <DD>
  <UL>
   <LI>never passed to anything else, this is the ancestor of all pools
   </LI>
  </UL>
 </DD>
 <DT>pconf
 </DT>
 <DD>
  <UL>
   <LI>subpool of permanent_pool
   </LI>
   <LI>created at the beginning of a config "cycle"; exists until the
    server is terminated or restarts; passed to all config-time
    routines, either via cmd-&gt;pool, or as the "pool *p" argument on
    those which don't take pools
   </LI>
   <LI>passed to the module init() functions
   </LI>
  </UL>
 </DD>
 <DT>ptemp
 </DT>
 <DD>
  <UL>
   <LI>sorry I lie, this pool isn't called this currently in 1.3, I
    renamed it this in my pthreads development.  I'm referring to
    the use of ptrans in the parent... contrast this with the later
    definition of ptrans in the child.
   </LI>
   <LI>subpool of permanent_pool
   </LI>
   <LI>created at the beginning of a config "cycle"; exists until the
    end of config parsing; passed to config-time routines <EM>via</EM>
    cmd-&gt;temp_pool.  Somewhat of a "bastard child" because it isn't
    available everywhere.  Used for temporary scratch space which
    may be needed by some config routines but which is deleted at
    the end of config.
   </LI>
  </UL>
 </DD>
 <DT>pchild
 </DT>
 <DD>
  <UL>
   <LI>subpool of permanent_pool
   </LI>
   <LI>created when a child is spawned (or a thread is created); lives
    until that child (thread) is destroyed
   </LI>
   <LI>passed to the module child_init functions
   </LI>
   <LI>destruction happens right after the child_exit functions are
    called... (which may explain why I think child_exit is redundant
    and unneeded)
   </LI>
  </UL>
 </DD>
 <DT>ptrans
 <DT>
 <DD>
  <UL>
   <LI>should be a subpool of pchild, but currently is a subpool of
    permanent_pool, see above
   </LI>
   <LI>cleared by the child before going into the accept() loop to receive
    a connection
   </LI>
   <LI>used as connection-&gt;pool
   </LI>
  </UL>
 </DD>
 <DT>r-&gt;pool
 </DT>
 <DD>
  <UL>
   <LI>for the main request this is a subpool of connection-&gt;pool; for
    subrequests it is a subpool of the parent request's pool.
   </LI>
   <LI>exists until the end of the request (<EM>i.e.</EM>,
    ap_destroy_sub_req, or
    in child_main after process_request has finished)
   </LI>
   <LI>note that r itself is allocated from r-&gt;pool; <EM>i.e.</EM>,
    r-&gt;pool is
    first created and then r is the first thing palloc()d from it
   </LI>
  </UL>
 </DD>
</DL>
<P>
For almost everything folks do, r-&gt;pool is the pool to use.  But you
can see how other lifetimes, such as pchild, are useful to some
modules... such as modules that need to open a database connection once
per child, and wish to clean it up when the child dies.
</P>
<P>
You can also see how some bugs have manifested themself, such as setting
connection-&gt;user to a value from r-&gt;pool -- in this case
connection exists
for the lifetime of ptrans, which is longer than r-&gt;pool (especially if
r-&gt;pool is a subrequest!).  So the correct thing to do is to allocate
from connection-&gt;pool.
</P>
<P>
And there was another interesting bug in mod_include/mod_cgi.  You'll see
in those that they do this test to decide if they should use r-&gt;pool
or r-&gt;main-&gt;pool.  In this case the resource that they are registering
for cleanup is a child process.  If it were registered in r-&gt;pool,
then the code would wait() for the child when the subrequest finishes.
With mod_include this could be any old #include, and the delay can be up
to 3 seconds... and happened quite frequently.  Instead the subprocess
is registered in r-&gt;main-&gt;pool which causes it to be cleaned up when
the entire request is done -- <EM>i.e.</EM>, after the output has been sent to
the client and logging has happened.
</P>
<H3><A NAME="pool-files">Tracking open files, etc.</A></H3>
<P>
As indicated above, resource pools are also used to track other sorts
of resources besides memory.  The most common are open files.  The
routine which is typically used for this is <CODE>ap_pfopen</CODE>, which
takes a resource pool and two strings as arguments; the strings are
the same as the typical arguments to <CODE>fopen</CODE>, <EM>e.g.</EM>,
</P>
<PRE>
d832 1
a832 139
</PRE>
<P>
There is also a <CODE>ap_popenf</CODE> routine, which parallels the
lower-level <CODE>open</CODE> system call.  Both of these routines
arrange for the file to be closed when the resource pool in question
is cleared.
</P>
<P>
Unlike the case for memory, there <EM>are</EM> functions to close
files allocated with <CODE>ap_pfopen</CODE>, and <CODE>ap_popenf</CODE>,
namely <CODE>ap_pfclose</CODE> and <CODE>ap_pclosef</CODE>.  (This is
because, on many systems, the number of files which a single process
can have open is quite limited).  It is important to use these
functions to close files allocated with <CODE>ap_pfopen</CODE> and
<CODE>ap_popenf</CODE>, since to do otherwise could cause fatal errors on
systems such as Linux, which react badly if the same
<CODE>FILE*</CODE> is closed more than once.
</P>
<P>
(Using the <CODE>close</CODE> functions is not mandatory, since the
file will eventually be closed regardless, but you should consider it
in cases where your module is opening, or could open, a lot of files).
</P>
<H3>Other sorts of resources --- cleanup functions</H3>
<BLOCKQUOTE>
More text goes here.  Describe the the cleanup primitives in terms of
which the file stuff is implemented; also, <CODE>spawn_process</CODE>.
</BLOCKQUOTE>
<P>
Pool cleanups live until clear_pool() is called:  clear_pool(a) recursively
calls destroy_pool() on all subpools of a; then calls all the cleanups for a; 
then releases all the memory for a.  destroy_pool(a) calls clear_pool(a) 
and then releases the pool structure itself.  <EM>i.e.</EM>, clear_pool(a) doesn't
delete a, it just frees up all the resources and you can start using it
again immediately. 
</P>
<H3>Fine control --- creating and dealing with sub-pools, with a note
on sub-requests</H3>

On rare occasions, too-free use of <CODE>ap_palloc()</CODE> and the
associated primitives may result in undesirably profligate resource
allocation.  You can deal with such a case by creating a
<EM>sub-pool</EM>, allocating within the sub-pool rather than the main
pool, and clearing or destroying the sub-pool, which releases the
resources which were associated with it.  (This really <EM>is</EM> a
rare situation; the only case in which it comes up in the standard
module set is in case of listing directories, and then only with
<EM>very</EM> large directories.  Unnecessary use of the primitives
discussed here can hair up your code quite a bit, with very little
gain). <P>

The primitive for creating a sub-pool is <CODE>ap_make_sub_pool</CODE>,
which takes another pool (the parent pool) as an argument.  When the
main pool is cleared, the sub-pool will be destroyed.  The sub-pool
may also be cleared or destroyed at any time, by calling the functions
<CODE>ap_clear_pool</CODE> and <CODE>ap_destroy_pool</CODE>, respectively.
(The difference is that <CODE>ap_clear_pool</CODE> frees resources
associated with the pool, while <CODE>ap_destroy_pool</CODE> also
deallocates the pool itself.  In the former case, you can allocate new
resources within the pool, and clear it again, and so forth; in the
latter case, it is simply gone). <P>

One final note --- sub-requests have their own resource pools, which
are sub-pools of the resource pool for the main request.  The polite
way to reclaim the resources associated with a sub request which you
have allocated (using the <CODE>ap_sub_req_...</CODE> functions)
is <CODE>ap_destroy_sub_req</CODE>, which frees the resource pool.
Before calling this function, be sure to copy anything that you care
about which might be allocated in the sub-request's resource pool into
someplace a little less volatile (for instance, the filename in its
<CODE>request_rec</CODE> structure). <P>

(Again, under most circumstances, you shouldn't feel obliged to call
this function; only 2K of memory or so are allocated for a typical sub
request, and it will be freed anyway when the main request pool is
cleared.  It is only when you are allocating many, many sub-requests
for a single main request that you should seriously consider the
<CODE>ap_destroy_...</CODE> functions).

<H2><A NAME="config">Configuration, commands and the like</A></H2>

One of the design goals for this server was to maintain external
compatibility with the NCSA 1.3 server --- that is, to read the same
configuration files, to process all the directives therein correctly,
and in general to be a drop-in replacement for NCSA.  On the other
hand, another design goal was to move as much of the server's
functionality into modules which have as little as possible to do with
the monolithic server core.  The only way to reconcile these goals is
to move the handling of most commands from the central server into the
modules.  <P>

However, just giving the modules command tables is not enough to
divorce them completely from the server core.  The server has to
remember the commands in order to act on them later.  That involves
maintaining data which is private to the modules, and which can be
either per-server, or per-directory.  Most things are per-directory,
including in particular access control and authorization information,
but also information on how to determine file types from suffixes,
which can be modified by <CODE>AddType</CODE> and
<CODE>DefaultType</CODE> directives, and so forth.  In general, the
governing philosophy is that anything which <EM>can</EM> be made
configurable by directory should be; per-server information is
generally used in the standard set of modules for information like
<CODE>Alias</CODE>es and <CODE>Redirect</CODE>s which come into play
before the request is tied to a particular place in the underlying
file system. <P>

Another requirement for emulating the NCSA server is being able to
handle the per-directory configuration files, generally called
<CODE>.htaccess</CODE> files, though even in the NCSA server they can
contain directives which have nothing at all to do with access
control.  Accordingly, after URI -&gt; filename translation, but before
performing any other phase, the server walks down the directory
hierarchy of the underlying filesystem, following the translated
pathname, to read any <CODE>.htaccess</CODE> files which might be
present.  The information which is read in then has to be
<EM>merged</EM> with the applicable information from the server's own
config files (either from the <CODE>&lt;Directory&gt;</CODE> sections
in <CODE>access.conf</CODE>, or from defaults in
<CODE>srm.conf</CODE>, which actually behaves for most purposes almost
exactly like <CODE>&lt;Directory /&gt;</CODE>).<P>

Finally, after having served a request which involved reading
<CODE>.htaccess</CODE> files, we need to discard the storage allocated
for handling them.  That is solved the same way it is solved wherever
else similar problems come up, by tying those structures to the
per-transaction resource pool.  <P>

<H3><A NAME="per-dir">Per-directory configuration structures</A></H3>

Let's look out how all of this plays out in <CODE>mod_mime.c</CODE>,
which defines the file typing handler which emulates the NCSA server's
behavior of determining file types from suffixes.  What we'll be
looking at, here, is the code which implements the
<CODE>AddType</CODE> and <CODE>AddEncoding</CODE> commands.  These
commands can appear in <CODE>.htaccess</CODE> files, so they must be
handled in the module's private per-directory data, which in fact,
consists of two separate <CODE>table</CODE>s for MIME types and
encoding information, and is declared as follows:
d834 150
a983 1
<PRE>
d988 24
a1011 24
</PRE>

When the server is reading a configuration file, or
<CODE>&lt;Directory&gt;</CODE> section, which includes one of the MIME
module's commands, it needs to create a <CODE>mime_dir_config</CODE>
structure, so those commands have something to act on.  It does this
by invoking the function it finds in the module's `create per-dir
config slot', with two arguments: the name of the directory to which
this configuration information applies (or <CODE>NULL</CODE> for
<CODE>srm.conf</CODE>), and a pointer to a resource pool in which the
allocation should happen. <P>

(If we are reading a <CODE>.htaccess</CODE> file, that resource pool
is the per-request resource pool for the request; otherwise it is a
resource pool which is used for configuration data, and cleared on
restarts.  Either way, it is important for the structure being created
to vanish when the pool is cleared, by registering a cleanup on the
pool if necessary). <P>

For the MIME module, the per-dir config creation function just
<CODE>ap_palloc</CODE>s the structure above, and a creates a couple of
<CODE>table</CODE>s to fill it.  That looks like this:

<PRE>
d1022 18
a1039 18
</PRE>

Now, suppose we've just read in a <CODE>.htaccess</CODE> file.  We
already have the per-directory configuration structure for the next
directory up in the hierarchy.  If the <CODE>.htaccess</CODE> file we
just read in didn't have any <CODE>AddType</CODE> or
<CODE>AddEncoding</CODE> commands, its per-directory config structure
for the MIME module is still valid, and we can just use it.
Otherwise, we need to merge the two structures somehow. <P>

To do that, the server invokes the module's per-directory config merge
function, if one is present.  That function takes three arguments:
the two structures being merged, and a resource pool in which to
allocate the result.  For the MIME module, all that needs to be done
is overlay the tables from the new per-directory config structure with
those from the parent:

<PRE>
d1054 25
a1078 25
</PRE>

As a note --- if there is no per-directory merge function present, the
server will just use the subdirectory's configuration info, and ignore
the parent's.  For some modules, that works just fine (<EM>e.g.</EM>, for the
includes module, whose per-directory configuration information
consists solely of the state of the <CODE>XBITHACK</CODE>), and for
those modules, you can just not declare one, and leave the
corresponding structure slot in the module itself <CODE>NULL</CODE>.<P>

<H3><A NAME="commands">Command handling</A></H3>

Now that we have these structures, we need to be able to figure out
how to fill them.  That involves processing the actual
<CODE>AddType</CODE> and <CODE>AddEncoding</CODE> commands.  To find
commands, the server looks in the module's <CODE>command table</CODE>.
That table contains information on how many arguments the commands
take, and in what formats, where it is permitted, and so forth.  That
information is sufficient to allow the server to invoke most
command-handling functions with pre-parsed arguments.  Without further
ado, let's look at the <CODE>AddType</CODE> command handler, which
looks like this (the <CODE>AddEncoding</CODE> command looks basically
the same, and won't be shown here):

<PRE>
d1085 26
a1110 26
</PRE>

This command handler is unusually simple.  As you can see, it takes
four arguments, two of which are pre-parsed arguments, the third being
the per-directory configuration structure for the module in question,
and the fourth being a pointer to a <CODE>cmd_parms</CODE> structure.
That structure contains a bunch of arguments which are frequently of
use to some, but not all, commands, including a resource pool (from
which memory can be allocated, and to which cleanups should be tied),
and the (virtual) server being configured, from which the module's
per-server configuration data can be obtained if required.<P>

Another way in which this particular command handler is unusually
simple is that there are no error conditions which it can encounter.
If there were, it could return an error message instead of
<CODE>NULL</CODE>; this causes an error to be printed out on the
server's <CODE>stderr</CODE>, followed by a quick exit, if it is in
the main config files; for a <CODE>.htaccess</CODE> file, the syntax
error is logged in the server error log (along with an indication of
where it came from), and the request is bounced with a server error
response (HTTP error status, code 500). <P>

The MIME module's command table has entries for these commands, which
look like this:

<PRE>
d1115 1
a1115 1
    "an encoding (<EM>e.g.</EM>, gzip), followed by a file extension" },
d1118 2
a1119 1
</PRE>
d1121 2
a1122 1
The entries in these tables are:
d1124 1
a1124 42
<UL>
  <LI> The name of the command
  <LI> The function which handles it
  <LI> a <CODE>(void *)</CODE> pointer, which is passed in the
       <CODE>cmd_parms</CODE> structure to the command handler ---
       this is useful in case many similar commands are handled by the
       same function.
  <LI> A bit mask indicating where the command may appear.  There are
       mask bits corresponding to each <CODE>AllowOverride</CODE>
       option, and an additional mask bit, <CODE>RSRC_CONF</CODE>,
       indicating that the command may appear in the server's own
       config files, but <EM>not</EM> in any <CODE>.htaccess</CODE>
       file.
  <LI> A flag indicating how many arguments the command handler wants
       pre-parsed, and how they should be passed in.
       <CODE>TAKE2</CODE> indicates two pre-parsed arguments.  Other
       options are <CODE>TAKE1</CODE>, which indicates one pre-parsed
       argument, <CODE>FLAG</CODE>, which indicates that the argument
       should be <CODE>On</CODE> or <CODE>Off</CODE>, and is passed in
       as a boolean flag, <CODE>RAW_ARGS</CODE>, which causes the
       server to give the command the raw, unparsed arguments
       (everything but the command name itself).  There is also
       <CODE>ITERATE</CODE>, which means that the handler looks the
       same as <CODE>TAKE1</CODE>, but that if multiple arguments are
       present, it should be called multiple times, and finally
       <CODE>ITERATE2</CODE>, which indicates that the command handler
       looks like a <CODE>TAKE2</CODE>, but if more arguments are
       present, then it should be called multiple times, holding the
       first argument constant.
  <LI> Finally, we have a string which describes the arguments that
       should be present.  If the arguments in the actual config file
       are not as required, this string will be used to help give a
       more specific error message.  (You can safely leave this
       <CODE>NULL</CODE>).
</UL>

Finally, having set this all up, we have to use it.  This is
ultimately done in the module's handlers, specifically for its
file-typing handler, which looks more or less like this; note that the
per-directory configuration structure is extracted from the
<CODE>request_rec</CODE>'s per-directory configuration vector by using
the <CODE>ap_get_module_config</CODE> function.
d1126 43
a1168 1
<PRE>
d1204 1
a1204 21
</PRE>

<H3><A NAME="servconf">Side notes --- per-server configuration, virtual
 servers, <EM>etc</EM>.</A></H3>

The basic ideas behind per-server module configuration are basically
the same as those for per-directory configuration; there is a creation
function and a merge function, the latter being invoked where a
virtual server has partially overridden the base server configuration,
and a combined structure must be computed.  (As with per-directory
configuration, the default if no merge function is specified, and a
module is configured in some virtual server, is that the base
configuration is simply ignored). <P>

The only substantial difference is that when a command needs to
configure the per-server private module data, it needs to go to the
<CODE>cmd_parms</CODE> data to get at it.  Here's an example, from the
alias module, which also indicates how a syntax error can be returned
(note that the per-directory configuration argument to the command
handler is declared as a dummy, since the module doesn't actually have
per-directory config data):
d1206 21
a1226 1
<PRE>
d1239 2
a1240 2
</PRE>
<HR>
d1242 3
a1244 3
<H3 ALIGN="CENTER">
 Apache HTTP Server Version 1.3
</H3>
d1246 2
a1247 2
<A HREF="./"><IMG SRC="../images/index.gif" ALT="Index"></A>
<A HREF="../"><IMG SRC="../images/home.gif" ALT="Home"></A>
a1248 1
</BODY></HTML>
@


1.1
log
@Initial revision
@
text
@d2 3
a4 3
<html><head>
<title>Apache API notes</title>
</head>
d16 1
a16 1
  Apache HTTP Server Version 1.2
d20 1
a20 1
<h1 ALIGN="CENTER">Apache API notes</h1>
d23 1
a23 1
have to deal with, etc.  They are not yet nearly complete, but
d26 1
a26 1
(See the TODO file for what <em>might</em> be coming).  However,
d29 1
a29 1
<p>
d37 1
a37 1
yet.  Welcome to the bleeding edge.<p>
d42 26
a67 23
<ul>
<li> <a href="#basics">Basic concepts.</a>
<menu>
 <li> <a href="#HMR">Handlers, Modules, and Requests</a>
 <li> <a href="#moduletour">A brief tour of a module</a>
</menu>
<li> <a href="#handlers">How handlers work</a>
<menu>
 <li> <a href="#req_tour">A brief tour of the <code>request_rec</code></a>
 <li> <a href="#req_orig">Where request_rec structures come from</a>
 <li> <a href="#req_return">Handling requests, declining, and returning error codes</a>
 <li> <a href="#resp_handlers">Special considerations for response handlers</a>
 <li> <a href="#auth_handlers">Special considerations for authentication handlers</a>
 <li> <a href="#log_handlers">Special considerations for logging handlers</a>
</menu>
<li> <a href="#pools">Resource allocation and resource pools</a>
<li> <a href="#config">Configuration, commands and the like</a>
<menu>
 <li> <a href="#per-dir">Per-directory configuration structures</a>
 <li> <a href="#commands">Command handling</a>
 <li> <a href="#servconf">Side notes --- per-server configuration, virtual servers, etc.</a>
</menu>
</ul>
d69 1
a69 1
<h2><a name="basics">Basic concepts.</a></h2>
d71 1
a71 1
We begin with an overview of the basic concepts behind the 
d74 1
a74 1
<h3><a name="HMR">Handlers, Modules, and Requests</a></h3>
d81 7
a87 7
<ul>
  <li> URI -&gt; Filename translation
  <li> Auth ID checking [is the user who they say they are?]
  <li> Auth access checking [is the user authorized <em>here</em>?]
  <li> Access checking other than auth
  <li> Determining MIME type of the object requested
  <li> `Fixups' --- there aren't any of these yet, but the phase is
d89 4
a92 4
       <code>SetEnv</code>, which don't really fit well elsewhere.
  <li> Actually sending a response back to the client.  
  <li> Logging the request
</ul>
d95 1
a95 1
<em>modules</em>, looking to see if each of them has a handler for the
d99 5
a103 5
<ul>
  <li> <em>Handle</em> the request, and indicate that it has done so
       by returning the magic constant <code>OK</code>.  
  <li> <em>Decline</em> to handle the request, by returning the magic
       integer constant <code>DECLINED</code>.  In this case, the
d106 1
a106 1
  <li> Signal an error, by returning one of the HTTP error codes.
d110 1
a110 1
</ul>
d118 1
a118 1
<em>any</em> request, by giving it the key <code>*/*</code> (i.e., a
d122 1
a122 1
(either none existed, or they all declined).<p>
d125 2
a126 2
<code>request_rec</code> structure. vide infra), which returns an
integer, as above.<p>
d128 1
a128 1
<h3><a name="moduletour">A brief tour of a module</a></h3>
d132 1
a132 1
handles both CGI scripts and the <code>ScriptAlias</code> config file
d135 1
a135 1
be the one with its fingers in every place.<p>
d139 4
a142 4
<code>ScriptAlias</code>, it also has handlers for the name
translation phase (to recognize <code>ScriptAlias</code>ed URIs), the
type-checking phase (any <code>ScriptAlias</code>ed request is typed
as a CGI script).<p>
d145 1
a145 1
server information, namely, the <code>ScriptAlias</code>es in effect;
d149 1
a149 1
<code>ScriptAlias</code>es declared).<p>
d152 1
a152 1
<code>ScriptAlias</code> command itself.  This particular module only
d154 2
a155 2
<em>command tables</em> which declare their commands, and describe
where they are permitted, and how they are to be invoked.  <p>
d158 1
a158 1
commands: a <code>pool</code> is a pointer to a <em>resource pool</em>
d160 1
a160 1
which has been allocated, files opened, etc., either to service a
d164 1
a164 1
closed, <i>en masse</i>, without anyone having to write explicit code to
d166 1
a166 1
<code>cmd_parms</code> structure contains various information about
d169 1
a169 1
(such as <code>ScriptAlias</code>).
d172 2
a173 2
 
<pre>
d225 1
a225 1
</pre>
d227 1
a227 1
<h2><a name="handlers">How handlers work</a></h2>
d229 1
a229 1
The sole argument to handlers is a <code>request_rec</code> structure.
d232 1
a232 1
the client generates only one <code>request_rec</code> structure.<p>
d234 1
a234 1
<h3><a name="req_tour">A brief tour of the <code>request_rec</code></a></h3>
d236 1
a236 1
The <code>request_rec</code> contains pointers to a resource pool
d239 1
a239 1
information, and most importantly, information on the request itself.<p>
d245 1
a245 1
request, respectively). <p>
d252 1
a252 1
<code>table_get</code> and <code>table_set</code> routines. <p>
d255 1
a255 1
 set by module content-handlers using the <SAMP>table_*()</SAMP>
d267 2
a268 2
directory (via <code>.htaccess</code> files or
<code>&lt;Directory&gt;</code> sections), for private data it has
d271 3
a273 3
is another such configuration vector in the <code>server_rec</code>
data structure pointed to by the <code>request_rec</code>, which
contains per (virtual) server configuration data.<p>
d275 1
a275 1
Here is an abridged declaration, giving the fields most commonly used:<p>
d277 1
a277 1
<pre>
d285 1
a285 1
  
d292 1
a292 1
  
d295 1
a295 1
  
d305 1
a305 1
  
d312 1
a312 1
  
d315 2
a316 2
  char *method;        /* GET, HEAD, POST, etc. */
  int method_number;   /* M_GET, M_POST, etc. */
d333 2
a334 2
  
  void *per_dir_config;   /* Options set in config files, etc. */
d336 1
a336 1
  
d339 1
a339 1
</pre>
d341 1
a341 1
<h3><a name="req_orig">Where request_rec structures come from</a></h3>
d343 1
a343 1
Most <code>request_rec</code> structures are built by reading an HTTP
d347 3
a349 3
<ul>
  <li> If the request is to an imagemap, a type map (i.e., a
       <code>*.var</code> file), or a CGI script which returned a
d353 2
a354 2
       an <em>internal redirect</em>, constructing a new
       <code>request_rec</code> for the new URI, and processing it
d356 1
a356 1
       directly. <p>
d358 3
a360 3
  <li> If some handler signaled an error, and an
       <code>ErrorDocument</code> is in scope, the same internal
       redirect machinery comes into play.<p>
d362 1
a362 1
  <li> Finally, a handler occasionally needs to investigate `what
d366 1
a366 1
       order to figure out what icon to use.<p>
d368 5
a372 4
       Such handlers can construct a <em>sub-request</em>, using the
       functions <code>sub_req_lookup_file</code> and
       <code>sub_req_lookup_uri</code>; this constructs a new
       <code>request_rec</code> structure and processes it as you
d376 1
a376 1
       as the original request).<p>
d380 2
a381 2
       function <code>run_sub_request</code>).
</ul>
d383 2
a384 1
<h3><a name="req_return">Handling requests, declining, and returning error codes</a></h3>
d387 1
a387 1
<code>request_rec</code>, has to return an <code>int</code> to
d390 2
a391 2
<ul>
  <li> OK --- the request was handled successfully.  This may or may
d393 1
a393 1
  <li> DECLINED --- no erroneous condition exists, but the module
d395 2
a396 2
  <li> an HTTP error code, which aborts handling of the request.
</ul>
d398 4
a401 4
Note that if the error code returned is <code>REDIRECT</code>, then
the module should put a <code>Location</code> in the request's
<code>headers_out</code>, to indicate where the client should be
redirected <em>to</em>. <p>
d403 2
a404 1
<h3><a name="resp_handlers">Special considerations for response handlers</a></h3>
d407 1
a407 1
in the <code>request_rec</code> structure (or, in the case of access
d409 1
a409 1
response handlers have to actually send a request back to the client. <p>
d412 1
a412 1
function <code>send_http_header</code>.  (You don't have to do
d415 1
a415 1
the request is marked <code>header_only</code>, that's all they should
d417 1
a417 1
output.  <p>
d420 4
a423 4
client as appropriate.  The primitives for this are <code>rputc</code>
and <code>rprintf</code>, for internally generated output, and
<code>send_fd</code>, to copy the contents of some <code>FILE *</code>
straight to the client.  <p>
d426 1
a426 1
of code, which is the handler which handles <code>GET</code> requests
d428 3
a430 3
<code>GET</code>s can be handled, if it's desirable to do so in a
particular response handler --- <code>set_last_modified</code> checks
against the <code>If-modified-since</code> value supplied by the
d433 2
a434 2
<code>set_content_length</code>, but it returns an error code for
symmetry.<p>
d436 1
a436 1
<pre>
d441 1
a441 1
    
d445 2
a446 2
    if ((errstatus = set_content_length (r, r-&gt;finfo.st_size))
        || (errstatus = set_last_modified (r, r-&gt;finfo.st_mtime)))
d448 1
a448 1
    
d456 1
a456 1
      
d458 1
a458 1
    send_http_header (r);
d461 1
a461 1
    pfclose (r-&gt;pool, f);
d464 1
a464 1
</pre>
d471 1
a471 1
<code>internal_redirect</code>, which is how the internal redirection
d473 1
a473 1
internally redirected should always return <code>OK</code>. <p>
d475 2
a476 2
(Invoking <code>internal_redirect</code> from handlers which are
<em>not</em> response handlers will lead to serious confusion).
d478 2
a479 1
<h3><a name="auth_handlers">Special considerations for authentication handlers</a></h3>
d483 2
a484 2
<ul>
  <li> Authentication-phase handlers not invoked unless auth is
d486 8
a493 8
  <li> Common auth configuration stored in the core per-dir
       configuration; it has accessors <code>auth_type</code>,
       <code>auth_name</code>, and <code>requires</code>.
  <li> Common routines, to handle the protocol end of things, at least
       for HTTP basic authentication (<code>get_basic_auth_pw</code>,
       which sets the <code>connection-&gt;user</code> structure field
       automatically, and <code>note_basic_auth_failure</code>, which
       arranges for the proper <code>WWW-Authenticate:</code> header
d495 1
a495 1
</ul>
d497 1
a497 1
<h3><a name="log_handlers">Special considerations for logging handlers</a></h3>
d501 3
a503 3
redirects into a list of <code>request_rec</code> structures which are
threaded through the <code>r-&gt;prev</code> and <code>r-&gt;next</code>
pointers.  The <code>request_rec</code> which is passed to the logging
d507 1
a507 3
response was actually sent). 

<h2><a name="pools">Resource allocation and resource pools</a></h2>
d509 2
d513 1
a513 1
open files, etc.), without subsequently releasing them.  The resource
d516 4
a519 3
they are <em>automatically</em> released when the server is done with
them. <p>

d521 6
a526 5
opened, etc., to deal with a particular request are tied to a
<em>resource pool</em> which is allocated for the request.  The pool
is a data structure which itself tracks the resources in question. <p>

When the request has been processed, the pool is <em>cleared</em>.  At
d531 3
a533 2
been released, and that none of them have leaked. <p>

d536 1
a536 1
<em>configuration pool</em>, which keeps track of resources which were
d543 3
a545 2
last time are made available for reuse. <p>

d550 1
a550 1
function <code><a href="#pool-files">pfopen</a></code>, which also
d552 1
a552 1
child processes, such as for CGI scripts, are <code>exec</code>ed), or
d557 4
a560 3
allocation, <code>palloc</code> is generally faster than
<code>malloc</code>.<p>

d564 3
a566 3

<h3>Allocation of memory in pools</h3>

d568 1
a568 1
<code>palloc</code>, which takes two arguments, one being a pointer to
d570 1
a570 1
allocate (in <code>char</code>s).  Within handlers for handling
d572 2
a573 2
by looking at the <code>pool</code> slot of the relevant
<code>request_rec</code>; hence the repeated appearance of the
d575 2
a576 2

<pre>
d582 1
a582 1
    foo = (foo *)palloc (r->pool, sizeof(my_structure));
d584 6
a589 6
</pre>

Note that <em>there is no <code>pfree</code></em> ---
<code>palloc</code>ed memory is freed only when the associated
resource pool is cleared.  This means that <code>palloc</code> does not
have to do as much accounting as <code>malloc()</code>; all it does in
d591 4
a594 3
range check.<p>

(It also raises the possibility that heavy use of <code>palloc</code>
d597 2
a598 2
can use <code>malloc</code>, and try to be sure that all of the memory
gets explicitly <code>free</code>d, or you can allocate a sub-pool of
d604 3
a606 3

<h3>Allocating initialized memory</h3>

d608 4
a611 4
frequently useful.  The function <code>pcalloc</code> has the same
interface as <code>palloc</code>, but clears out the memory it
allocates before it returns it.  The function <code>pstrdup</code>
takes a resource pool and a <code>char *</code> as arguments, and
d613 1
a613 1
returning a pointer to the copy.  Finally <code>pstrcat</code> is a
d615 2
a616 2
at least two <code>char *</code> arguments, the last of which must be
<code>NULL</code>.  It allocates enough memory to fit copies of each
d618 5
a622 5

<pre>
     pstrcat (r->pool, "foo", "/", "bar", NULL);
</pre>

d624 129
a752 4
<code>"foo/bar"</code>.

<h3><a name="pool-files">Tracking open files, etc.</a></h3>

d755 1
a755 1
routine which is typically used for this is <code>pfopen</code>, which
d757 3
a759 3
the same as the typical arguments to <code>fopen</code>, e.g.,

<pre>
d761 1
a761 1
     FILE *f = pfopen (r->pool, r->filename, "r");
d764 4
a767 4
</pre>

There is also a <code>popenf</code> routine, which parallels the
lower-level <code>open</code> system call.  Both of these routines
d769 6
a774 5
is cleared.  <p>

Unlike the case for memory, there <em>are</em> functions to close
files allocated with <code>pfopen</code>, and <code>popenf</code>,
namely <code>pfclose</code> and <code>pclosef</code>.  (This is
d777 2
a778 2
functions to close files allocated with <code>pfopen</code> and
<code>popenf</code>, since to do otherwise could cause fatal errors on
d780 4
a783 3
<code>FILE*</code> is closed more than once. <p>

(Using the <code>close</code> functions is not mandatory, since the
d786 3
a788 3

<h3>Other sorts of resources --- cleanup functions</h3>

d790 12
a801 4
which the file stuff is implemented; also, <code>spawn_process</code>. 

<h3>Fine control --- creating and dealing with sub-pools, with a note
on sub-requests</h3>
d803 1
a803 1
On rare occasions, too-free use of <code>palloc()</code> and the
d806 1
a806 1
<em>sub-pool</em>, allocating within the sub-pool rather than the main
d808 1
a808 1
resources which were associated with it.  (This really <em>is</em> a
d811 1
a811 1
<em>very</em> large directories.  Unnecessary use of the primitives
d813 1
a813 1
gain). <p>
d815 1
a815 1
The primitive for creating a sub-pool is <code>make_sub_pool</code>,
d819 3
a821 3
<code>clear_pool</code> and <code>destroy_pool</code>, respectively.
(The difference is that <code>clear_pool</code> frees resources
associated with the pool, while <code>destroy_pool</code> also
d824 1
a824 1
latter case, it is simply gone). <p>
d829 2
a830 2
have allocated (using the <code>sub_req_lookup_...</code> functions)
is <code>destroy_sub_request</code>, which frees the resource pool.
d834 1
a834 1
<code>request_rec</code> structure). <p>
d841 1
a841 1
<code>destroy...</code> functions).
d843 1
a843 1
<h2><a name="config">Configuration, commands and the like</a></h2>
d853 1
a853 1
modules.  <p>
d862 3
a864 3
which can be modified by <code>AddType</code> and
<code>DefaultType</code> directives, and so forth.  In general, the
governing philosophy is that anything which <em>can</em> be made
d867 1
a867 1
<code>Alias</code>es and <code>Redirect</code>s which come into play
d869 1
a869 1
file system. <p>
d873 1
a873 1
<code>.htaccess</code> files, though even in the NCSA server they can
d878 1
a878 1
pathname, to read any <code>.htaccess</code> files which might be
d880 5
a884 5
<em>merged</em> with the applicable information from the server's own
config files (either from the <code>&lt;Directory&gt;</code> sections
in <code>access.conf</code>, or from defaults in
<code>srm.conf</code>, which actually behaves for most purposes almost
exactly like <code>&lt;Directory /&gt;</code>).<p>
d887 1
a887 1
<code>.htaccess</code> files, we need to discard the storage allocated
d890 1
a890 1
per-transaction resource pool.  <p>
d892 1
a892 1
<h3><a name="per-dir">Per-directory configuration structures</a></h3>
d894 1
a894 1
Let's look out how all of this plays out in <code>mod_mime.c</code>,
d898 2
a899 2
<code>AddType</code> and <code>AddEncoding</code> commands.  These
commands can appear in <code>.htaccess</code> files, so they must be
d901 1
a901 1
consists of two separate <code>table</code>s for MIME types and
d904 1
a904 1
<pre>
d909 1
a909 1
</pre>
d912 2
a913 2
<code>&lt;Directory&gt;</code> section, which includes one of the MIME
module's commands, it needs to create a <code>mime_dir_config</code>
d917 3
a919 3
this configuration information applies (or <code>NULL</code> for
<code>srm.conf</code>), and a pointer to a resource pool in which the
allocation should happen. <p>
d921 1
a921 1
(If we are reading a <code>.htaccess</code> file, that resource pool
d926 1
a926 1
pool if necessary). <p>
d929 2
a930 2
<code>palloc</code>s the structure above, and a creates a couple of
<code>table</code>s to fill it.  That looks like this:
d932 1
a932 1
<pre>
d936 4
a939 1
      (mime_dir_config *) palloc (p, sizeof(mime_dir_config));
a940 3
    new-&gt;forced_types = make_table (p, 4);
    new-&gt;encoding_types = make_table (p, 4);
    
d943 1
a943 1
</pre>
d945 1
a945 1
Now, suppose we've just read in a <code>.htaccess</code> file.  We
d947 3
a949 3
directory up in the hierarchy.  If the <code>.htaccess</code> file we
just read in didn't have any <code>AddType</code> or
<code>AddEncoding</code> commands, its per-directory config structure
d951 1
a951 1
Otherwise, we need to merge the two structures somehow. <p>
d960 1
a960 1
<pre>
d966 1
a966 1
      (mime_dir_config *)palloc (p, sizeof(mime_dir_config));
d968 1
a968 1
    new-&gt;forced_types = overlay_tables (p, subdir-&gt;forced_types,
d970 1
a970 1
    new-&gt;encoding_types = overlay_tables (p, subdir-&gt;encoding_types,
d975 1
a975 1
</pre>
d979 1
a979 1
the parent's.  For some modules, that works just fine (e.g., for the
d981 1
a981 1
consists solely of the state of the <code>XBITHACK</code>), and for
d983 1
a983 1
corresponding structure slot in the module itself <code>NULL</code>.<p>
d985 1
a985 1
<h3><a name="commands">Command handling</a></h3>
d989 2
a990 2
<code>AddType</code> and <code>AddEncoding</code> commands.  To find
commands, the server looks in the module's <code>command table</code>.
d995 2
a996 2
ado, let's look at the <code>AddType</code> command handler, which
looks like this (the <code>AddEncoding</code> command looks basically
d999 1
a999 1
<pre>
d1003 1
a1003 1
    table_set (m-&gt;forced_types, ext, ct);
d1006 1
a1006 1
</pre>
d1011 1
a1011 1
and the fourth being a pointer to a <code>cmd_parms</code> structure.
d1016 1
a1016 1
per-server configuration data can be obtained if required.<p>
d1021 3
a1023 3
<code>NULL</code>; this causes an error to be printed out on the
server's <code>stderr</code>, followed by a quick exit, if it is in
the main config files; for a <code>.htaccess</code> file, the syntax
d1026 1
a1026 1
response (HTTP error status, code 500). <p>
d1031 1
a1031 1
<pre>
d1033 1
a1033 1
{ "AddType", add_type, NULL, OR_FILEINFO, TAKE2, 
d1035 2
a1036 2
{ "AddEncoding", add_encoding, NULL, OR_FILEINFO, TAKE2, 
    "an encoding (e.g., gzip), followed by a file extension" },
d1039 1
a1039 1
</pre>
d1043 5
a1047 5
<ul>
  <li> The name of the command
  <li> The function which handles it
  <li> a <code>(void *)</code> pointer, which is passed in the
       <code>cmd_parms</code> structure to the command handler ---
d1050 3
a1052 3
  <li> A bit mask indicating where the command may appear.  There are
       mask bits corresponding to each <code>AllowOverride</code>
       option, and an additional mask bit, <code>RSRC_CONF</code>,
d1054 1
a1054 1
       config files, but <em>not</em> in any <code>.htaccess</code>
d1056 1
a1056 1
  <li> A flag indicating how many arguments the command handler wants
d1058 5
a1062 5
       <code>TAKE2</code> indicates two pre-parsed arguments.  Other
       options are <code>TAKE1</code>, which indicates one pre-parsed
       argument, <code>FLAG</code>, which indicates that the argument
       should be <code>On</code> or <code>Off</code>, and is passed in
       as a boolean flag, <code>RAW_ARGS</code>, which causes the
d1065 2
a1066 2
       <code>ITERATE</code>, which means that the handler looks the
       same as <code>TAKE1</code>, but that if multiple arguments are
d1068 2
a1069 2
       <code>ITERATE2</code>, which indicates that the command handler
       looks like a <code>TAKE2</code>, but if more arguments are
d1072 1
a1072 1
  <li> Finally, we have a string which describes the arguments that
d1076 2
a1077 2
       <code>NULL</code>). 
</ul>
d1083 2
a1084 2
<code>request_rec</code>'s per-directory configuration vector by using
the <code>get_module_config</code> function.
d1086 1
a1086 1
<pre>
d1090 1
a1090 1
    char *fn = pstrdup (r->pool, r->filename);
d1092 1
a1092 1
             get_module_config(r->per_dir_config, &amp;mime_module);
d1095 2
a1096 2
    if (S_ISDIR(r->finfo.st_mode)) {
        r->content_type = DIR_MAGIC_TYPE;
d1099 2
a1100 2
    
    if((i=rind(fn,'.')) &lt; 0) return DECLINED;
d1103 1
a1103 1
    if ((type = table_get (conf->encoding_types, &amp;fn[i])))
d1105 1
a1105 1
        r->content_encoding = type;
d1110 1
a1110 1
        if((i=rind(fn,'.')) &lt; 0) return OK;
d1114 1
a1114 1
    if ((type = table_get (conf->forced_types, &amp;fn[i])))
d1116 1
a1116 1
        r->content_type = type;
d1118 1
a1118 1
    
d1122 1
a1122 1
</pre>
d1124 2
a1125 1
<h3><a name="servconf">Side notes --- per-server configuration, virtual servers, etc.</a></h3>
d1134 1
a1134 1
configuration is simply ignored). <p>
d1138 1
a1138 1
<code>cmd_parms</code> data to get at it.  Here's an example, from the
d1144 1
a1144 1
<pre>
d1147 1
a1147 1
    server_rec *s = cmd->server;
d1149 4
a1152 2
            get_module_config(s-&gt;module_config,&amp;alias_module);
    alias_entry *new = push_array (conf-&gt;redirects);
a1153 2
    if (!is_url (url)) return "Redirect to non-URL";
    
d1157 1
a1157 1
</pre>
d1159 1
d1161 1
a1161 1
 Apache HTTP Server Version 1.2
d1167 1
a1167 1
</body></html>
@


1.1.1.1
log
@Initial import from apache 1.2.6
@
text
@@


1.1.1.2
log
@Apache 1.3.2
@
text
@d2 3
a4 3
<HTML><HEAD>
<TITLE>Apache API notes</TITLE>
</HEAD>
d16 1
a16 1
  Apache HTTP Server Version 1.3
d20 1
a20 1
<H1 ALIGN="CENTER">Apache API notes</H1>
d23 1
a23 1
have to deal with, <EM>etc.</EM>  They are not yet nearly complete, but
d26 1
a26 1
(See the TODO file for what <EM>might</EM> be coming).  However,
d29 1
a29 1
<P>
d37 1
a37 1
yet.  Welcome to the bleeding edge.<P>
d42 23
a64 26
<UL>
<LI> <A HREF="#basics">Basic concepts.</A>
<MENU>
 <LI> <A HREF="#HMR">Handlers, Modules, and Requests</A>
 <LI> <A HREF="#moduletour">A brief tour of a module</A>
</MENU>
<LI> <A HREF="#handlers">How handlers work</A>
<MENU>
 <LI> <A HREF="#req_tour">A brief tour of the <CODE>request_rec</CODE></A>
 <LI> <A HREF="#req_orig">Where request_rec structures come from</A>
 <LI> <A HREF="#req_return">Handling requests, declining, and returning error
  codes</A>
 <LI> <A HREF="#resp_handlers">Special considerations for response handlers</A>
 <LI> <A HREF="#auth_handlers">Special considerations for authentication
  handlers</A>
 <LI> <A HREF="#log_handlers">Special considerations for logging handlers</A>
</MENU>
<LI> <A HREF="#pools">Resource allocation and resource pools</A>
<LI> <A HREF="#config">Configuration, commands and the like</A>
<MENU>
 <LI> <A HREF="#per-dir">Per-directory configuration structures</A>
 <LI> <A HREF="#commands">Command handling</A>
 <LI> <A HREF="#servconf">Side notes --- per-server configuration,
  virtual servers, <EM>etc</EM>.</A>
</MENU>
</UL>
d66 1
a66 1
<H2><A NAME="basics">Basic concepts.</A></H2>
d68 1
a68 1
We begin with an overview of the basic concepts behind the
d71 1
a71 1
<H3><A NAME="HMR">Handlers, Modules, and Requests</A></H3>
d78 7
a84 7
<UL>
  <LI> URI -&gt; Filename translation
  <LI> Auth ID checking [is the user who they say they are?]
  <LI> Auth access checking [is the user authorized <EM>here</EM>?]
  <LI> Access checking other than auth
  <LI> Determining MIME type of the object requested
  <LI> `Fixups' --- there aren't any of these yet, but the phase is
d86 4
a89 4
       <CODE>SetEnv</CODE>, which don't really fit well elsewhere.
  <LI> Actually sending a response back to the client.
  <LI> Logging the request
</UL>
d92 1
a92 1
<EM>modules</EM>, looking to see if each of them has a handler for the
d96 5
a100 5
<UL>
  <LI> <EM>Handle</EM> the request, and indicate that it has done so
       by returning the magic constant <CODE>OK</CODE>.
  <LI> <EM>Decline</EM> to handle the request, by returning the magic
       integer constant <CODE>DECLINED</CODE>.  In this case, the
d103 1
a103 1
  <LI> Signal an error, by returning one of the HTTP error codes.
d107 1
a107 1
</UL>
d115 1
a115 1
<EM>any</EM> request, by giving it the key <CODE>*/*</CODE> (<EM>i.e.</EM>, a
d119 1
a119 1
(either none existed, or they all declined).<P>
d122 2
a123 2
<CODE>request_rec</CODE> structure. vide infra), which returns an
integer, as above.<P>
d125 1
a125 1
<H3><A NAME="moduletour">A brief tour of a module</A></H3>
d129 1
a129 1
handles both CGI scripts and the <CODE>ScriptAlias</CODE> config file
d132 1
a132 1
be the one with its fingers in every place.<P>
d136 4
a139 4
<CODE>ScriptAlias</CODE>, it also has handlers for the name
translation phase (to recognize <CODE>ScriptAlias</CODE>ed URIs), the
type-checking phase (any <CODE>ScriptAlias</CODE>ed request is typed
as a CGI script).<P>
d142 1
a142 1
server information, namely, the <CODE>ScriptAlias</CODE>es in effect;
d146 1
a146 1
<CODE>ScriptAlias</CODE>es declared).<P>
d149 1
a149 1
<CODE>ScriptAlias</CODE> command itself.  This particular module only
d151 2
a152 2
<EM>command tables</EM> which declare their commands, and describe
where they are permitted, and how they are to be invoked.  <P>
d155 1
a155 1
commands: a <CODE>pool</CODE> is a pointer to a <EM>resource pool</EM>
d157 1
a157 1
which has been allocated, files opened, <EM>etc.</EM>, either to service a
d161 1
a161 1
closed, <EM>en masse</EM>, without anyone having to write explicit code to
d163 1
a163 1
<CODE>cmd_parms</CODE> structure contains various information about
d166 1
a166 1
(such as <CODE>ScriptAlias</CODE>).
d169 2
a170 2

<PRE>
d222 1
a222 1
</PRE>
d224 1
a224 1
<H2><A NAME="handlers">How handlers work</A></H2>
d226 1
a226 1
The sole argument to handlers is a <CODE>request_rec</CODE> structure.
d229 1
a229 1
the client generates only one <CODE>request_rec</CODE> structure.<P>
d231 1
a231 1
<H3><A NAME="req_tour">A brief tour of the <CODE>request_rec</CODE></A></H3>
d233 1
a233 1
The <CODE>request_rec</CODE> contains pointers to a resource pool
d236 1
a236 1
information, and most importantly, information on the request itself.<P>
d242 1
a242 1
request, respectively). <P>
d249 1
a249 1
<CODE>ap_table_get</CODE> and <CODE>ap_table_set</CODE> routines. <P>
d252 1
a252 1
 set by module content-handlers using the <SAMP>ap_table_*()</SAMP>
d264 2
a265 2
directory (via <CODE>.htaccess</CODE> files or
<CODE>&lt;Directory&gt;</CODE> sections), for private data it has
d268 3
a270 3
is another such configuration vector in the <CODE>server_rec</CODE>
data structure pointed to by the <CODE>request_rec</CODE>, which
contains per (virtual) server configuration data.<P>
d272 1
a272 1
Here is an abridged declaration, giving the fields most commonly used:<P>
d274 1
a274 1
<PRE>
d282 1
a282 1

d289 1
a289 1

d292 1
a292 1

d302 1
a302 1

d309 1
a309 1

d312 2
a313 2
  char *method;        /* GET, HEAD, POST, <EM>etc.</EM> */
  int method_number;   /* M_GET, M_POST, <EM>etc.</EM> */
d330 2
a331 2

  void *per_dir_config;   /* Options set in config files, <EM>etc.</EM> */
d333 1
a333 1

d336 1
a336 1
</PRE>
d338 1
a338 1
<H3><A NAME="req_orig">Where request_rec structures come from</A></H3>
d340 1
a340 1
Most <CODE>request_rec</CODE> structures are built by reading an HTTP
d344 3
a346 3
<UL>
  <LI> If the request is to an imagemap, a type map (<EM>i.e.</EM>, a
       <CODE>*.var</CODE> file), or a CGI script which returned a
d350 2
a351 2
       an <EM>internal redirect</EM>, constructing a new
       <CODE>request_rec</CODE> for the new URI, and processing it
d353 1
a353 1
       directly. <P>
d355 3
a357 3
  <LI> If some handler signaled an error, and an
       <CODE>ErrorDocument</CODE> is in scope, the same internal
       redirect machinery comes into play.<P>
d359 1
a359 1
  <LI> Finally, a handler occasionally needs to investigate `what
d363 1
a363 1
       order to figure out what icon to use.<P>
d365 4
a368 4
       Such handlers can construct a <EM>sub-request</EM>, using the
       functions <CODE>ap_sub_req_lookup_file</CODE> and
       <CODE>ap_sub_req_lookup_uri</CODE>; this constructs a new
       <CODE>request_rec</CODE> structure and processes it as you
d372 1
a372 1
       as the original request).<P>
d376 2
a377 2
       function <CODE>run_sub_request</CODE>).
</UL>
d379 1
a379 2
<H3><A NAME="req_return">Handling requests, declining, and returning error
 codes</A></H3>
d382 1
a382 1
<CODE>request_rec</CODE>, has to return an <CODE>int</CODE> to
d385 2
a386 2
<UL>
  <LI> OK --- the request was handled successfully.  This may or may
d388 1
a388 1
  <LI> DECLINED --- no erroneous condition exists, but the module
d390 2
a391 2
  <LI> an HTTP error code, which aborts handling of the request.
</UL>
d393 4
a396 4
Note that if the error code returned is <CODE>REDIRECT</CODE>, then
the module should put a <CODE>Location</CODE> in the request's
<CODE>headers_out</CODE>, to indicate where the client should be
redirected <EM>to</EM>. <P>
d398 1
a398 2
<H3><A NAME="resp_handlers">Special considerations for response
 handlers</A></H3>
d401 1
a401 1
in the <CODE>request_rec</CODE> structure (or, in the case of access
d403 1
a403 1
response handlers have to actually send a request back to the client. <P>
d406 1
a406 1
function <CODE>ap_send_http_header</CODE>.  (You don't have to do
d409 1
a409 1
the request is marked <CODE>header_only</CODE>, that's all they should
d411 1
a411 1
output.  <P>
d414 4
a417 4
client as appropriate.  The primitives for this are <CODE>ap_rputc</CODE>
and <CODE>ap_rprintf</CODE>, for internally generated output, and
<CODE>ap_send_fd</CODE>, to copy the contents of some <CODE>FILE *</CODE>
straight to the client.  <P>
d420 1
a420 1
of code, which is the handler which handles <CODE>GET</CODE> requests
d422 3
a424 3
<CODE>GET</CODE>s can be handled, if it's desirable to do so in a
particular response handler --- <CODE>ap_set_last_modified</CODE> checks
against the <CODE>If-modified-since</CODE> value supplied by the
d427 2
a428 2
<CODE>ap_set_content_length</CODE>, but it returns an error code for
symmetry.<P>
d430 1
a430 1
<PRE>
d435 1
a435 1

d439 2
a440 2
    if ((errstatus = ap_set_content_length (r, r-&gt;finfo.st_size))
	|| (errstatus = ap_set_last_modified (r, r-&gt;finfo.st_mtime)))
d442 1
a442 1

d450 1
a450 1

d452 1
a452 1
    ap_send_http_header (r);
d455 1
a455 1
    ap_pfclose (r-&gt;pool, f);
d458 1
a458 1
</PRE>
d465 1
a465 1
<CODE>ap_internal_redirect</CODE>, which is how the internal redirection
d467 1
a467 1
internally redirected should always return <CODE>OK</CODE>. <P>
d469 2
a470 2
(Invoking <CODE>ap_internal_redirect</CODE> from handlers which are
<EM>not</EM> response handlers will lead to serious confusion).
d472 1
a472 2
<H3><A NAME="auth_handlers">Special considerations for authentication
 handlers</A></H3>
d476 2
a477 2
<UL>
  <LI> Authentication-phase handlers not invoked unless auth is
d479 8
a486 8
  <LI> Common auth configuration stored in the core per-dir
       configuration; it has accessors <CODE>ap_auth_type</CODE>,
       <CODE>ap_auth_name</CODE>, and <CODE>ap_requires</CODE>.
  <LI> Common routines, to handle the protocol end of things, at least
       for HTTP basic authentication (<CODE>ap_get_basic_auth_pw</CODE>,
       which sets the <CODE>connection-&gt;user</CODE> structure field
       automatically, and <CODE>ap_note_basic_auth_failure</CODE>, which
       arranges for the proper <CODE>WWW-Authenticate:</CODE> header
d488 1
a488 1
</UL>
d490 1
a490 1
<H3><A NAME="log_handlers">Special considerations for logging handlers</A></H3>
d494 3
a496 3
redirects into a list of <CODE>request_rec</CODE> structures which are
threaded through the <CODE>r-&gt;prev</CODE> and <CODE>r-&gt;next</CODE>
pointers.  The <CODE>request_rec</CODE> which is passed to the logging
d500 3
a502 1
response was actually sent).
a503 2
<H2><A NAME="pools">Resource allocation and resource pools</A></H2>
<P>
d506 1
a506 1
open files, <EM>etc.</EM>), without subsequently releasing them.  The resource
d509 3
a511 4
they are <EM>automatically</EM> released when the server is done with
them.
</P>
<P>
d513 5
a517 6
opened, <EM>etc.</EM>, to deal with a particular request are tied to a
<EM>resource pool</EM> which is allocated for the request.  The pool
is a data structure which itself tracks the resources in question.
</P>
<P>
When the request has been processed, the pool is <EM>cleared</EM>.  At
d522 2
a523 3
been released, and that none of them have leaked.
</P>
<P>
d526 1
a526 1
<EM>configuration pool</EM>, which keeps track of resources which were
d533 2
a534 3
last time are made available for reuse.
</P>
<P>
d539 1
a539 1
function <CODE><A HREF="#pool-files">ap_pfopen</A></CODE>, which also
d541 1
a541 1
child processes, such as for CGI scripts, are <CODE>exec</CODE>ed), or
d546 3
a548 4
allocation, <CODE>ap_palloc</CODE> is generally faster than
<CODE>malloc</CODE>.
</P>
<P>
d552 3
a554 3
</P>
<H3>Allocation of memory in pools</H3>
<P>
d556 1
a556 1
<CODE>ap_palloc</CODE>, which takes two arguments, one being a pointer to
d558 1
a558 1
allocate (in <CODE>char</CODE>s).  Within handlers for handling
d560 2
a561 2
by looking at the <CODE>pool</CODE> slot of the relevant
<CODE>request_rec</CODE>; hence the repeated appearance of the
d563 2
a564 2
</P>
<PRE>
d570 1
a570 1
    foo = (foo *)ap_palloc (r-&gt;pool, sizeof(my_structure));
d572 6
a577 6
</PRE>
<P>
Note that <EM>there is no <CODE>ap_pfree</CODE></EM> ---
<CODE>ap_palloc</CODE>ed memory is freed only when the associated
resource pool is cleared.  This means that <CODE>ap_palloc</CODE> does not
have to do as much accounting as <CODE>malloc()</CODE>; all it does in
d579 3
a581 4
range check.
</P>
<P>
(It also raises the possibility that heavy use of <CODE>ap_palloc</CODE>
d584 2
a585 2
can use <CODE>malloc</CODE>, and try to be sure that all of the memory
gets explicitly <CODE>free</CODE>d, or you can allocate a sub-pool of
d591 3
a593 3
</P>
<H3>Allocating initialized memory</H3>
<P>
d595 4
a598 4
frequently useful.  The function <CODE>ap_pcalloc</CODE> has the same
interface as <CODE>ap_palloc</CODE>, but clears out the memory it
allocates before it returns it.  The function <CODE>ap_pstrdup</CODE>
takes a resource pool and a <CODE>char *</CODE> as arguments, and
d600 1
a600 1
returning a pointer to the copy.  Finally <CODE>ap_pstrcat</CODE> is a
d602 2
a603 2
at least two <CODE>char *</CODE> arguments, the last of which must be
<CODE>NULL</CODE>.  It allocates enough memory to fit copies of each
d605 5
a609 5
</P>
<PRE>
     ap_pstrcat (r-&gt;pool, "foo", "/", "bar", NULL);
</PRE>
<P>
d611 4
a614 128
<CODE>"foo/bar"</CODE>.
</P>
<H3><A NAME="pools-used">Commonly-used pools in the Apache Web server</A></H3>
<P>
A pool is really defined by its lifetime more than anything else.  There
are some static pools in http_main which are passed to various
non-http_main functions as arguments at opportune times.  Here they are:
</P>
<DL COMPACT>
 <DT>permanent_pool
 </DT>
 <DD>
  <UL>
   <LI>never passed to anything else, this is the ancestor of all pools
   </LI>
  </UL>
 </DD>
 <DT>pconf
 </DT>
 <DD>
  <UL>
   <LI>subpool of permanent_pool
   </LI>
   <LI>created at the beginning of a config "cycle"; exists until the
    server is terminated or restarts; passed to all config-time
    routines, either via cmd-&gt;pool, or as the "pool *p" argument on
    those which don't take pools
   </LI>
   <LI>passed to the module init() functions
   </LI>
  </UL>
 </DD>
 <DT>ptemp
 </DT>
 <DD>
  <UL>
   <LI>sorry I lie, this pool isn't called this currently in 1.3, I
    renamed it this in my pthreads development.  I'm referring to
    the use of ptrans in the parent... contrast this with the later
    definition of ptrans in the child.
   </LI>
   <LI>subpool of permanent_pool
   </LI>
   <LI>created at the beginning of a config "cycle"; exists until the
    end of config parsing; passed to config-time routines <EM>via</EM>
    cmd-&gt;temp_pool.  Somewhat of a "bastard child" because it isn't
    available everywhere.  Used for temporary scratch space which
    may be needed by some config routines but which is deleted at
    the end of config.
   </LI>
  </UL>
 </DD>
 <DT>pchild
 </DT>
 <DD>
  <UL>
   <LI>subpool of permanent_pool
   </LI>
   <LI>created when a child is spawned (or a thread is created); lives
    until that child (thread) is destroyed
   </LI>
   <LI>passed to the module child_init functions
   </LI>
   <LI>destruction happens right after the child_exit functions are
    called... (which may explain why I think child_exit is redundant
    and unneeded)
   </LI>
  </UL>
 </DD>
 <DT>ptrans
 <DT>
 <DD>
  <UL>
   <LI>should be a subpool of pchild, but currently is a subpool of
    permanent_pool, see above
   </LI>
   <LI>cleared by the child before going into the accept() loop to receive
    a connection
   </LI>
   <LI>used as connection-&gt;pool
   </LI>
  </UL>
 </DD>
 <DT>r-&gt;pool
 </DT>
 <DD>
  <UL>
   <LI>for the main request this is a subpool of connection-&gt;pool; for
    subrequests it is a subpool of the parent request's pool.
   </LI>
   <LI>exists until the end of the request (<EM>i.e.</EM>, destroy_sub_req, or
    in child_main after process_request has finished)
   </LI>
   <LI>note that r itself is allocated from r-&gt;pool; <EM>i.e.</EM>,
    r-&gt;pool is
    first created and then r is the first thing palloc()d from it
   </LI>
  </UL>
 </DD>
</DL>
<P>
For almost everything folks do, r-&gt;pool is the pool to use.  But you
can see how other lifetimes, such as pchild, are useful to some
modules... such as modules that need to open a database connection once
per child, and wish to clean it up when the child dies.
</P>
<P>
You can also see how some bugs have manifested themself, such as setting
connection-&gt;user to a value from r-&gt;pool -- in this case
connection exists
for the lifetime of ptrans, which is longer than r-&gt;pool (especially if
r-&gt;pool is a subrequest!).  So the correct thing to do is to allocate
from connection-&gt;pool.
</P>
<P>
And there was another interesting bug in mod_include/mod_cgi.  You'll see
in those that they do this test to decide if they should use r-&gt;pool
or r-&gt;main-&gt;pool.  In this case the resource that they are registering
for cleanup is a child process.  If it were registered in r-&gt;pool,
then the code would wait() for the child when the subrequest finishes.
With mod_include this could be any old #include, and the delay can be up
to 3 seconds... and happened quite frequently.  Instead the subprocess
is registered in r-&gt;main-&gt;pool which causes it to be cleaned up when
the entire request is done -- <EM>i.e.</EM>, after the output has been sent to
the client and logging has happened.
</P>
<H3><A NAME="pool-files">Tracking open files, etc.</A></H3>
<P>
d617 1
a617 1
routine which is typically used for this is <CODE>ap_pfopen</CODE>, which
d619 3
a621 3
the same as the typical arguments to <CODE>fopen</CODE>, <EM>e.g.</EM>,
</P>
<PRE>
d623 1
a623 1
     FILE *f = ap_pfopen (r-&gt;pool, r-&gt;filename, "r");
d626 4
a629 4
</PRE>
<P>
There is also a <CODE>ap_popenf</CODE> routine, which parallels the
lower-level <CODE>open</CODE> system call.  Both of these routines
d631 5
a635 6
is cleared.
</P>
<P>
Unlike the case for memory, there <EM>are</EM> functions to close
files allocated with <CODE>ap_pfopen</CODE>, and <CODE>ap_popenf</CODE>,
namely <CODE>ap_pfclose</CODE> and <CODE>ap_pclosef</CODE>.  (This is
d638 2
a639 2
functions to close files allocated with <CODE>ap_pfopen</CODE> and
<CODE>ap_popenf</CODE>, since to do otherwise could cause fatal errors on
d641 3
a643 4
<CODE>FILE*</CODE> is closed more than once.
</P>
<P>
(Using the <CODE>close</CODE> functions is not mandatory, since the
d646 3
a648 3
</P>
<H3>Other sorts of resources --- cleanup functions</H3>
<BLOCKQUOTE>
d650 4
a653 12
which the file stuff is implemented; also, <CODE>spawn_process</CODE>.
</BLOCKQUOTE>
<P>
Pool cleanups live until clear_pool() is called:  clear_pool(a) recursively
calls destroy_pool() on all subpools of a; then calls all the cleanups for a; 
then releases all the memory for a.  destroy_pool(a) calls clear_pool(a) 
and then releases the pool structure itself.  <EM>i.e.</EM>, clear_pool(a) doesn't
delete a, it just frees up all the resources and you can start using it
again immediately. 
</P>
<H3>Fine control --- creating and dealing with sub-pools, with a note
on sub-requests</H3>
d655 1
a655 1
On rare occasions, too-free use of <CODE>ap_palloc()</CODE> and the
d658 1
a658 1
<EM>sub-pool</EM>, allocating within the sub-pool rather than the main
d660 1
a660 1
resources which were associated with it.  (This really <EM>is</EM> a
d663 1
a663 1
<EM>very</EM> large directories.  Unnecessary use of the primitives
d665 1
a665 1
gain). <P>
d667 1
a667 1
The primitive for creating a sub-pool is <CODE>ap_make_sub_pool</CODE>,
d671 3
a673 3
<CODE>ap_clear_pool</CODE> and <CODE>ap_destroy_pool</CODE>, respectively.
(The difference is that <CODE>ap_clear_pool</CODE> frees resources
associated with the pool, while <CODE>ap_destroy_pool</CODE> also
d676 1
a676 1
latter case, it is simply gone). <P>
d681 2
a682 2
have allocated (using the <CODE>ap_sub_req_lookup_...</CODE> functions)
is <CODE>ap_destroy_sub_req</CODE>, which frees the resource pool.
d686 1
a686 1
<CODE>request_rec</CODE> structure). <P>
d693 1
a693 1
<CODE>ap_destroy...</CODE> functions).
d695 1
a695 1
<H2><A NAME="config">Configuration, commands and the like</A></H2>
d705 1
a705 1
modules.  <P>
d714 3
a716 3
which can be modified by <CODE>AddType</CODE> and
<CODE>DefaultType</CODE> directives, and so forth.  In general, the
governing philosophy is that anything which <EM>can</EM> be made
d719 1
a719 1
<CODE>Alias</CODE>es and <CODE>Redirect</CODE>s which come into play
d721 1
a721 1
file system. <P>
d725 1
a725 1
<CODE>.htaccess</CODE> files, though even in the NCSA server they can
d730 1
a730 1
pathname, to read any <CODE>.htaccess</CODE> files which might be
d732 5
a736 5
<EM>merged</EM> with the applicable information from the server's own
config files (either from the <CODE>&lt;Directory&gt;</CODE> sections
in <CODE>access.conf</CODE>, or from defaults in
<CODE>srm.conf</CODE>, which actually behaves for most purposes almost
exactly like <CODE>&lt;Directory /&gt;</CODE>).<P>
d739 1
a739 1
<CODE>.htaccess</CODE> files, we need to discard the storage allocated
d742 1
a742 1
per-transaction resource pool.  <P>
d744 1
a744 1
<H3><A NAME="per-dir">Per-directory configuration structures</A></H3>
d746 1
a746 1
Let's look out how all of this plays out in <CODE>mod_mime.c</CODE>,
d750 2
a751 2
<CODE>AddType</CODE> and <CODE>AddEncoding</CODE> commands.  These
commands can appear in <CODE>.htaccess</CODE> files, so they must be
d753 1
a753 1
consists of two separate <CODE>table</CODE>s for MIME types and
d756 1
a756 1
<PRE>
d761 1
a761 1
</PRE>
d764 2
a765 2
<CODE>&lt;Directory&gt;</CODE> section, which includes one of the MIME
module's commands, it needs to create a <CODE>mime_dir_config</CODE>
d769 3
a771 3
this configuration information applies (or <CODE>NULL</CODE> for
<CODE>srm.conf</CODE>), and a pointer to a resource pool in which the
allocation should happen. <P>
d773 1
a773 1
(If we are reading a <CODE>.htaccess</CODE> file, that resource pool
d778 1
a778 1
pool if necessary). <P>
d781 2
a782 2
<CODE>ap_palloc</CODE>s the structure above, and a creates a couple of
<CODE>table</CODE>s to fill it.  That looks like this:
d784 1
a784 1
<PRE>
d788 1
a788 4
      (mime_dir_config *) ap_palloc (p, sizeof(mime_dir_config));

    new-&gt;forced_types = ap_make_table (p, 4);
    new-&gt;encoding_types = ap_make_table (p, 4);
d790 3
d795 1
a795 1
</PRE>
d797 1
a797 1
Now, suppose we've just read in a <CODE>.htaccess</CODE> file.  We
d799 3
a801 3
directory up in the hierarchy.  If the <CODE>.htaccess</CODE> file we
just read in didn't have any <CODE>AddType</CODE> or
<CODE>AddEncoding</CODE> commands, its per-directory config structure
d803 1
a803 1
Otherwise, we need to merge the two structures somehow. <P>
d812 1
a812 1
<PRE>
d818 1
a818 1
      (mime_dir_config *)ap_palloc (p, sizeof(mime_dir_config));
d820 1
a820 1
    new-&gt;forced_types = ap_overlay_tables (p, subdir-&gt;forced_types,
d822 1
a822 1
    new-&gt;encoding_types = ap_overlay_tables (p, subdir-&gt;encoding_types,
d827 1
a827 1
</PRE>
d831 1
a831 1
the parent's.  For some modules, that works just fine (<EM>e.g.</EM>, for the
d833 1
a833 1
consists solely of the state of the <CODE>XBITHACK</CODE>), and for
d835 1
a835 1
corresponding structure slot in the module itself <CODE>NULL</CODE>.<P>
d837 1
a837 1
<H3><A NAME="commands">Command handling</A></H3>
d841 2
a842 2
<CODE>AddType</CODE> and <CODE>AddEncoding</CODE> commands.  To find
commands, the server looks in the module's <CODE>command table</CODE>.
d847 2
a848 2
ado, let's look at the <CODE>AddType</CODE> command handler, which
looks like this (the <CODE>AddEncoding</CODE> command looks basically
d851 1
a851 1
<PRE>
d855 1
a855 1
    ap_table_set (m-&gt;forced_types, ext, ct);
d858 1
a858 1
</PRE>
d863 1
a863 1
and the fourth being a pointer to a <CODE>cmd_parms</CODE> structure.
d868 1
a868 1
per-server configuration data can be obtained if required.<P>
d873 3
a875 3
<CODE>NULL</CODE>; this causes an error to be printed out on the
server's <CODE>stderr</CODE>, followed by a quick exit, if it is in
the main config files; for a <CODE>.htaccess</CODE> file, the syntax
d878 1
a878 1
response (HTTP error status, code 500). <P>
d883 1
a883 1
<PRE>
d885 1
a885 1
{ "AddType", add_type, NULL, OR_FILEINFO, TAKE2,
d887 2
a888 2
{ "AddEncoding", add_encoding, NULL, OR_FILEINFO, TAKE2,
    "an encoding (<EM>e.g.</EM>, gzip), followed by a file extension" },
d891 1
a891 1
</PRE>
d895 5
a899 5
<UL>
  <LI> The name of the command
  <LI> The function which handles it
  <LI> a <CODE>(void *)</CODE> pointer, which is passed in the
       <CODE>cmd_parms</CODE> structure to the command handler ---
d902 3
a904 3
  <LI> A bit mask indicating where the command may appear.  There are
       mask bits corresponding to each <CODE>AllowOverride</CODE>
       option, and an additional mask bit, <CODE>RSRC_CONF</CODE>,
d906 1
a906 1
       config files, but <EM>not</EM> in any <CODE>.htaccess</CODE>
d908 1
a908 1
  <LI> A flag indicating how many arguments the command handler wants
d910 5
a914 5
       <CODE>TAKE2</CODE> indicates two pre-parsed arguments.  Other
       options are <CODE>TAKE1</CODE>, which indicates one pre-parsed
       argument, <CODE>FLAG</CODE>, which indicates that the argument
       should be <CODE>On</CODE> or <CODE>Off</CODE>, and is passed in
       as a boolean flag, <CODE>RAW_ARGS</CODE>, which causes the
d917 2
a918 2
       <CODE>ITERATE</CODE>, which means that the handler looks the
       same as <CODE>TAKE1</CODE>, but that if multiple arguments are
d920 2
a921 2
       <CODE>ITERATE2</CODE>, which indicates that the command handler
       looks like a <CODE>TAKE2</CODE>, but if more arguments are
d924 1
a924 1
  <LI> Finally, we have a string which describes the arguments that
d928 2
a929 2
       <CODE>NULL</CODE>).
</UL>
d935 2
a936 2
<CODE>request_rec</CODE>'s per-directory configuration vector by using
the <CODE>ap_get_module_config</CODE> function.
d938 1
a938 1
<PRE>
d942 1
a942 1
    char *fn = ap_pstrdup (r-&gt;pool, r-&gt;filename);
d944 1
a944 1
             ap_get_module_config(r-&gt;per_dir_config, &amp;mime_module);
d947 2
a948 2
    if (S_ISDIR(r-&gt;finfo.st_mode)) {
        r-&gt;content_type = DIR_MAGIC_TYPE;
d951 2
a952 2

    if((i=ap_rind(fn,'.')) &lt; 0) return DECLINED;
d955 1
a955 1
    if ((type = ap_table_get (conf-&gt;encoding_types, &amp;fn[i])))
d957 1
a957 1
        r-&gt;content_encoding = type;
d962 1
a962 1
        if((i=ap_rind(fn,'.')) &lt; 0) return OK;
d966 1
a966 1
    if ((type = ap_table_get (conf-&gt;forced_types, &amp;fn[i])))
d968 1
a968 1
        r-&gt;content_type = type;
d970 1
a970 1

d974 1
a974 1
</PRE>
d976 1
a976 2
<H3><A NAME="servconf">Side notes --- per-server configuration, virtual
 servers, <EM>etc</EM>.</A></H3>
d985 1
a985 1
configuration is simply ignored). <P>
d989 1
a989 1
<CODE>cmd_parms</CODE> data to get at it.  Here's an example, from the
d995 1
a995 1
<PRE>
d998 1
a998 1
    server_rec *s = cmd-&gt;server;
d1000 2
a1001 4
            ap_get_module_config(s-&gt;module_config,&amp;alias_module);
    alias_entry *new = ap_push_array (conf-&gt;redirects);

    if (!ap_is_url (url)) return "Redirect to non-URL";
d1003 2
d1008 1
a1008 1
</PRE>
a1009 1

d1011 1
a1011 1
 Apache HTTP Server Version 1.3
d1017 1
a1017 1
</BODY></HTML>
@


1.1.1.3
log
@import apache 1.3.26 + mod_ssl 2.8.10
@
text
@d1 169
a169 2
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
d171 3
a173 212
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator" content="HTML Tidy, see www.w3.org" />

    <title>Apache API notes</title>
  </head>
  <!-- Background white, links blue (unvisited), navy (visited), red (active) -->

  <body bgcolor="#FFFFFF" text="#000000" link="#0000FF"
  vlink="#000080" alink="#FF0000">
        <div align="CENTER">
      <img src="../images/sub.gif" alt="[APACHE DOCUMENTATION]" /> 

      <h3>Apache HTTP Server Version 1.3</h3>
    </div>


    <h1 align="CENTER">Apache API notes</h1>
    These are some notes on the Apache API and the data structures
    you have to deal with, <em>etc.</em> They are not yet nearly
    complete, but hopefully, they will help you get your bearings.
    Keep in mind that the API is still subject to change as we gain
    experience with it. (See the TODO file for what <em>might</em>
    be coming). However, it will be easy to adapt modules to any
    changes that are made. (We have more modules to adapt than you
    do). 

    <p>A few notes on general pedagogical style here. In the
    interest of conciseness, all structure declarations here are
    incomplete --- the real ones have more slots that I'm not
    telling you about. For the most part, these are reserved to one
    component of the server core or another, and should be altered
    by modules with caution. However, in some cases, they really
    are things I just haven't gotten around to yet. Welcome to the
    bleeding edge.</p>

    <p>Finally, here's an outline, to give you some bare idea of
    what's coming up, and in what order:</p>

    <ul>
      <li>
        <a href="#basics">Basic concepts.</a> 

        <ul>
          <li><a href="#HMR">Handlers, Modules, and
          Requests</a></li>

          <li><a href="#moduletour">A brief tour of a
          module</a></li>
        </ul>
      </li>

      <li>
        <a href="#handlers">How handlers work</a> 

        <ul>
          <li><a href="#req_tour">A brief tour of the
          <code>request_rec</code></a></li>

          <li><a href="#req_orig">Where request_rec structures come
          from</a></li>

          <li><a href="#req_return">Handling requests, declining,
          and returning error codes</a></li>

          <li><a href="#resp_handlers">Special considerations for
          response handlers</a></li>

          <li><a href="#auth_handlers">Special considerations for
          authentication handlers</a></li>

          <li><a href="#log_handlers">Special considerations for
          logging handlers</a></li>
        </ul>
      </li>

      <li><a href="#pools">Resource allocation and resource
      pools</a></li>

      <li>
        <a href="#config">Configuration, commands and the like</a> 

        <ul>
          <li><a href="#per-dir">Per-directory configuration
          structures</a></li>

          <li><a href="#commands">Command handling</a></li>

          <li><a href="#servconf">Side notes --- per-server
          configuration, virtual servers, <em>etc</em>.</a></li>
        </ul>
      </li>
    </ul>

    <h2><a id="basics" name="basics">Basic concepts.</a></h2>
    We begin with an overview of the basic concepts behind the API,
    and how they are manifested in the code. 

    <h3><a id="HMR" name="HMR">Handlers, Modules, and
    Requests</a></h3>
    Apache breaks down request handling into a series of steps,
    more or less the same way the Netscape server API does
    (although this API has a few more stages than NetSite does, as
    hooks for stuff I thought might be useful in the future). These
    are: 

    <ul>
      <li>URI -&gt; Filename translation</li>

      <li>Auth ID checking [is the user who they say they
      are?]</li>

      <li>Auth access checking [is the user authorized
      <em>here</em>?]</li>

      <li>Access checking other than auth</li>

      <li>Determining MIME type of the object requested</li>

      <li>`Fixups' --- there aren't any of these yet, but the phase
      is intended as a hook for possible extensions like
      <code>SetEnv</code>, which don't really fit well
      elsewhere.</li>

      <li>Actually sending a response back to the client.</li>

      <li>Logging the request</li>
    </ul>
    These phases are handled by looking at each of a succession of
    <em>modules</em>, looking to see if each of them has a handler
    for the phase, and attempting invoking it if so. The handler
    can typically do one of three things: 

    <ul>
      <li><em>Handle</em> the request, and indicate that it has
      done so by returning the magic constant <code>OK</code>.</li>

      <li><em>Decline</em> to handle the request, by returning the
      magic integer constant <code>DECLINED</code>. In this case,
      the server behaves in all respects as if the handler simply
      hadn't been there.</li>

      <li>Signal an error, by returning one of the HTTP error
      codes. This terminates normal handling of the request,
      although an ErrorDocument may be invoked to try to mop up,
      and it will be logged in any case.</li>
    </ul>
    Most phases are terminated by the first module that handles
    them; however, for logging, `fixups', and non-access
    authentication checking, all handlers always run (barring an
    error). Also, the response phase is unique in that modules may
    declare multiple handlers for it, via a dispatch table keyed on
    the MIME type of the requested object. Modules may declare a
    response-phase handler which can handle <em>any</em> request,
    by giving it the key <code>*/*</code> (<em>i.e.</em>, a
    wildcard MIME type specification). However, wildcard handlers
    are only invoked if the server has already tried and failed to
    find a more specific response handler for the MIME type of the
    requested object (either none existed, or they all declined). 

    <p>The handlers themselves are functions of one argument (a
    <code>request_rec</code> structure. vide infra), which returns
    an integer, as above.</p>

    <h3><a id="moduletour" name="moduletour">A brief tour of a
    module</a></h3>
    At this point, we need to explain the structure of a module.
    Our candidate will be one of the messier ones, the CGI module
    --- this handles both CGI scripts and the
    <code>ScriptAlias</code> config file command. It's actually a
    great deal more complicated than most modules, but if we're
    going to have only one example, it might as well be the one
    with its fingers in every place. 

    <p>Let's begin with handlers. In order to handle the CGI
    scripts, the module declares a response handler for them.
    Because of <code>ScriptAlias</code>, it also has handlers for
    the name translation phase (to recognize
    <code>ScriptAlias</code>ed URIs), the type-checking phase (any
    <code>ScriptAlias</code>ed request is typed as a CGI
    script).</p>

    <p>The module needs to maintain some per (virtual) server
    information, namely, the <code>ScriptAlias</code>es in effect;
    the module structure therefore contains pointers to a functions
    which builds these structures, and to another which combines
    two of them (in case the main server and a virtual server both
    have <code>ScriptAlias</code>es declared).</p>

    <p>Finally, this module contains code to handle the
    <code>ScriptAlias</code> command itself. This particular module
    only declares one command, but there could be more, so modules
    have <em>command tables</em> which declare their commands, and
    describe where they are permitted, and how they are to be
    invoked.</p>

    <p>A final note on the declared types of the arguments of some
    of these commands: a <code>pool</code> is a pointer to a
    <em>resource pool</em> structure; these are used by the server
    to keep track of the memory which has been allocated, files
    opened, <em>etc.</em>, either to service a particular request,
    or to handle the process of configuring itself. That way, when
    the request is over (or, for the configuration pool, when the
    server is restarting), the memory can be freed, and the files
    closed, <em>en masse</em>, without anyone having to write
    explicit code to track them all down and dispose of them. Also,
    a <code>cmd_parms</code> structure contains various information
    about the config file being read, and other status information,
    which is sometimes of use to the function which processes a
    config-file command (such as <code>ScriptAlias</code>). With no
    further ado, the module itself:</p>
<pre>
d225 3
a227 1
</pre>
d229 31
a259 38
    <h2><a id="handlers" name="handlers">How handlers work</a></h2>
    The sole argument to handlers is a <code>request_rec</code>
    structure. This structure describes a particular request which
    has been made to the server, on behalf of a client. In most
    cases, each connection to the client generates only one
    <code>request_rec</code> structure. 

    <h3><a id="req_tour" name="req_tour">A brief tour of the
    <code>request_rec</code></a></h3>
    The <code>request_rec</code> contains pointers to a resource
    pool which will be cleared when the server is finished handling
    the request; to structures containing per-server and
    per-connection information, and most importantly, information
    on the request itself. 

    <p>The most important such information is a small set of
    character strings describing attributes of the object being
    requested, including its URI, filename, content-type and
    content-encoding (these being filled in by the translation and
    type-check handlers which handle the request,
    respectively).</p>

    <p>Other commonly used data items are tables giving the MIME
    headers on the client's original request, MIME headers to be
    sent back with the response (which modules can add to at will),
    and environment variables for any subprocesses which are
    spawned off in the course of servicing the request. These
    tables are manipulated using the <code>ap_table_get</code> and
    <code>ap_table_set</code> routines.</p>

    <blockquote>
      Note that the <samp>Content-type</samp> header value
      <em>cannot</em> be set by module content-handlers using the
      <samp>ap_table_*()</samp> routines. Rather, it is set by
      pointing the <samp>content_type</samp> field in the
      <samp>request_rec</samp> structure to an appropriate string.
      <em>E.g.</em>, 
<pre>
d261 17
a277 18
</pre>
    </blockquote>
    Finally, there are pointers to two data structures which, in
    turn, point to per-module configuration structures.
    Specifically, these hold pointers to the data structures which
    the module has built to describe the way it has been configured
    to operate in a given directory (via <code>.htaccess</code>
    files or <code>&lt;Directory&gt;</code> sections), for private
    data it has built in the course of servicing the request (so
    modules' handlers for one phase can pass `notes' to their
    handlers for other phases). There is another such configuration
    vector in the <code>server_rec</code> data structure pointed to
    by the <code>request_rec</code>, which contains per (virtual)
    server configuration data. 

    <p>Here is an abridged declaration, giving the fields most
    commonly used:</p>
<pre>
d315 2
a316 2
  char *method;        /* GET, HEAD, POST, <em>etc.</em> */
  int method_number;   /* M_GET, M_POST, <em>etc.</em> */
d334 1
a334 1
  void *per_dir_config;   /* Options set in config files, <em>etc.</em> */
d339 1
a339 1
</pre>
d341 95
a435 102
    <h3><a id="req_orig" name="req_orig">Where request_rec
    structures come from</a></h3>
    Most <code>request_rec</code> structures are built by reading
    an HTTP request from a client, and filling in the fields.
    However, there are a few exceptions: 

    <ul>
      <li>If the request is to an imagemap, a type map
      (<em>i.e.</em>, a <code>*.var</code> file), or a CGI script
      which returned a local `Location:', then the resource which
      the user requested is going to be ultimately located by some
      URI other than what the client originally supplied. In this
      case, the server does an <em>internal redirect</em>,
      constructing a new <code>request_rec</code> for the new URI,
      and processing it almost exactly as if the client had
      requested the new URI directly.</li>

      <li>If some handler signaled an error, and an
      <code>ErrorDocument</code> is in scope, the same internal
      redirect machinery comes into play.</li>

      <li>
        Finally, a handler occasionally needs to investigate `what
        would happen if' some other request were run. For instance,
        the directory indexing module needs to know what MIME type
        would be assigned to a request for each directory entry, in
        order to figure out what icon to use. 

        <p>Such handlers can construct a <em>sub-request</em>,
        using the functions <code>ap_sub_req_lookup_file</code>,
        <code>ap_sub_req_lookup_uri</code>, and
        <code>ap_sub_req_method_uri</code>; these construct a new
        <code>request_rec</code> structure and processes it as you
        would expect, up to but not including the point of actually
        sending a response. (These functions skip over the access
        checks if the sub-request is for a file in the same
        directory as the original request).</p>

        <p>(Server-side includes work by building sub-requests and
        then actually invoking the response handler for them, via
        the function <code>ap_run_sub_req</code>).</p>
      </li>
    </ul>

    <h3><a id="req_return" name="req_return">Handling requests,
    declining, and returning error codes</a></h3>
    As discussed above, each handler, when invoked to handle a
    particular <code>request_rec</code>, has to return an
    <code>int</code> to indicate what happened. That can either be 

    <ul>
      <li>OK --- the request was handled successfully. This may or
      may not terminate the phase.</li>

      <li>DECLINED --- no erroneous condition exists, but the
      module declines to handle the phase; the server tries to find
      another.</li>

      <li>an HTTP error code, which aborts handling of the
      request.</li>
    </ul>
    Note that if the error code returned is <code>REDIRECT</code>,
    then the module should put a <code>Location</code> in the
    request's <code>headers_out</code>, to indicate where the
    client should be redirected <em>to</em>. 

    <h3><a id="resp_handlers" name="resp_handlers">Special
    considerations for response handlers</a></h3>
    Handlers for most phases do their work by simply setting a few
    fields in the <code>request_rec</code> structure (or, in the
    case of access checkers, simply by returning the correct error
    code). However, response handlers have to actually send a
    request back to the client. 

    <p>They should begin by sending an HTTP response header, using
    the function <code>ap_send_http_header</code>. (You don't have
    to do anything special to skip sending the header for HTTP/0.9
    requests; the function figures out on its own that it shouldn't
    do anything). If the request is marked
    <code>header_only</code>, that's all they should do; they
    should return after that, without attempting any further
    output.</p>

    <p>Otherwise, they should produce a request body which responds
    to the client as appropriate. The primitives for this are
    <code>ap_rputc</code> and <code>ap_rprintf</code>, for
    internally generated output, and <code>ap_send_fd</code>, to
    copy the contents of some <code>FILE *</code> straight to the
    client.</p>

    <p>At this point, you should more or less understand the
    following piece of code, which is the handler which handles
    <code>GET</code> requests which have no more specific handler;
    it also shows how conditional <code>GET</code>s can be handled,
    if it's desirable to do so in a particular response handler ---
    <code>ap_set_last_modified</code> checks against the
    <code>If-modified-since</code> value supplied by the client, if
    any, and returns an appropriate code (which will, if nonzero,
    be USE_LOCAL_COPY). No similar considerations apply for
    <code>ap_set_content_length</code>, but it returns an error
    code for symmetry.</p>
<pre>
d444 2
a445 1
    if ((errstatus = ap_set_content_length (r, r-&gt;finfo.st_size)) {
a446 1
    }
d448 1
a448 4
    r-&gt;mtime = r-&gt;finfo.st_mtime;
    ap_set_last_modified (r);

    f = ap_pfopen (r-&gt;pool, r-&gt;filename, "r");
d451 2
a452 2
        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
             "file permissions deny server access: %s", r-&gt;filename);
d456 1
a456 1
    ap_soft_timeout ("send", r);
d459 1
a459 1
    if (!r-&gt;header_only) ap_send_fd (f, r);
a460 2

    ap_kill_timeout (r);
d463 113
a575 119
</pre>
    Finally, if all of this is too much of a challenge, there are a
    few ways out of it. First off, as shown above, a response
    handler which has not yet produced any output can simply return
    an error code, in which case the server will automatically
    produce an error response. Secondly, it can punt to some other
    handler by invoking <code>ap_internal_redirect</code>, which is
    how the internal redirection machinery discussed above is
    invoked. A response handler which has internally redirected
    should always return <code>OK</code>. 

    <p>(Invoking <code>ap_internal_redirect</code> from handlers
    which are <em>not</em> response handlers will lead to serious
    confusion).</p>

    <h3><a id="auth_handlers" name="auth_handlers">Special
    considerations for authentication handlers</a></h3>
    Stuff that should be discussed here in detail: 

    <ul>
      <li>Authentication-phase handlers not invoked unless auth is
      configured for the directory.</li>

      <li>Common auth configuration stored in the core per-dir
      configuration; it has accessors <code>ap_auth_type</code>,
      <code>ap_auth_name</code>, and <code>ap_requires</code>.</li>

      <li>Common routines, to handle the protocol end of things, at
      least for HTTP basic authentication
      (<code>ap_get_basic_auth_pw</code>, which sets the
      <code>connection-&gt;user</code> structure field
      automatically, and <code>ap_note_basic_auth_failure</code>,
      which arranges for the proper <code>WWW-Authenticate:</code>
      header to be sent back).</li>
    </ul>

    <h3><a id="log_handlers" name="log_handlers">Special
    considerations for logging handlers</a></h3>
    When a request has internally redirected, there is the question
    of what to log. Apache handles this by bundling the entire
    chain of redirects into a list of <code>request_rec</code>
    structures which are threaded through the
    <code>r-&gt;prev</code> and <code>r-&gt;next</code> pointers.
    The <code>request_rec</code> which is passed to the logging
    handlers in such cases is the one which was originally built
    for the initial request from the client; note that the
    bytes_sent field will only be correct in the last request in
    the chain (the one for which a response was actually sent). 

    <h2><a id="pools" name="pools">Resource allocation and resource
    pools</a></h2>

    <p>One of the problems of writing and designing a server-pool
    server is that of preventing leakage, that is, allocating
    resources (memory, open files, <em>etc.</em>), without
    subsequently releasing them. The resource pool machinery is
    designed to make it easy to prevent this from happening, by
    allowing resource to be allocated in such a way that they are
    <em>automatically</em> released when the server is done with
    them.</p>

    <p>The way this works is as follows: the memory which is
    allocated, file opened, <em>etc.</em>, to deal with a
    particular request are tied to a <em>resource pool</em> which
    is allocated for the request. The pool is a data structure
    which itself tracks the resources in question.</p>

    <p>When the request has been processed, the pool is
    <em>cleared</em>. At that point, all the memory associated with
    it is released for reuse, all files associated with it are
    closed, and any other clean-up functions which are associated
    with the pool are run. When this is over, we can be confident
    that all the resource tied to the pool have been released, and
    that none of them have leaked.</p>

    <p>Server restarts, and allocation of memory and resources for
    per-server configuration, are handled in a similar way. There
    is a <em>configuration pool</em>, which keeps track of
    resources which were allocated while reading the server
    configuration files, and handling the commands therein (for
    instance, the memory that was allocated for per-server module
    configuration, log files and other files that were opened, and
    so forth). When the server restarts, and has to reread the
    configuration files, the configuration pool is cleared, and so
    the memory and file descriptors which were taken up by reading
    them the last time are made available for reuse.</p>

    <p>It should be noted that use of the pool machinery isn't
    generally obligatory, except for situations like logging
    handlers, where you really need to register cleanups to make
    sure that the log file gets closed when the server restarts
    (this is most easily done by using the function <code><a
    href="#pool-files">ap_pfopen</a></code>, which also arranges
    for the underlying file descriptor to be closed before any
    child processes, such as for CGI scripts, are
    <code>exec</code>ed), or in case you are using the timeout
    machinery (which isn't yet even documented here). However,
    there are two benefits to using it: resources allocated to a
    pool never leak (even if you allocate a scratch string, and
    just forget about it); also, for memory allocation,
    <code>ap_palloc</code> is generally faster than
    <code>malloc</code>.</p>

    <p>We begin here by describing how memory is allocated to
    pools, and then discuss how other resources are tracked by the
    resource pool machinery.</p>

    <h3>Allocation of memory in pools</h3>

    <p>Memory is allocated to pools by calling the function
    <code>ap_palloc</code>, which takes two arguments, one being a
    pointer to a resource pool structure, and the other being the
    amount of memory to allocate (in <code>char</code>s). Within
    handlers for handling requests, the most common way of getting
    a resource pool structure is by looking at the
    <code>pool</code> slot of the relevant
    <code>request_rec</code>; hence the repeated appearance of the
    following idiom in module code:</p>
<pre>
d583 36
a618 36
</pre>

    <p>Note that <em>there is no <code>ap_pfree</code></em> ---
    <code>ap_palloc</code>ed memory is freed only when the
    associated resource pool is cleared. This means that
    <code>ap_palloc</code> does not have to do as much accounting
    as <code>malloc()</code>; all it does in the typical case is to
    round up the size, bump a pointer, and do a range check.</p>

    <p>(It also raises the possibility that heavy use of
    <code>ap_palloc</code> could cause a server process to grow
    excessively large. There are two ways to deal with this, which
    are dealt with below; briefly, you can use <code>malloc</code>,
    and try to be sure that all of the memory gets explicitly
    <code>free</code>d, or you can allocate a sub-pool of the main
    pool, allocate your memory in the sub-pool, and clear it out
    periodically. The latter technique is discussed in the section
    on sub-pools below, and is used in the directory-indexing code,
    in order to avoid excessive storage allocation when listing
    directories with thousands of files).</p>

    <h3>Allocating initialized memory</h3>

    <p>There are functions which allocate initialized memory, and
    are frequently useful. The function <code>ap_pcalloc</code> has
    the same interface as <code>ap_palloc</code>, but clears out
    the memory it allocates before it returns it. The function
    <code>ap_pstrdup</code> takes a resource pool and a <code>char
    *</code> as arguments, and allocates memory for a copy of the
    string the pointer points to, returning a pointer to the copy.
    Finally <code>ap_pstrcat</code> is a varargs-style function,
    which takes a pointer to a resource pool, and at least two
    <code>char *</code> arguments, the last of which must be
    <code>NULL</code>. It allocates enough memory to fit copies of
    each of the strings, as a unit; for instance:</p>
<pre>
d620 138
a757 147
</pre>

    <p>returns a pointer to 8 bytes worth of memory, initialized to
    <code>"foo/bar"</code>.</p>

    <h3><a id="pools-used" name="pools-used">Commonly-used pools in
    the Apache Web server</a></h3>

    <p>A pool is really defined by its lifetime more than anything
    else. There are some static pools in http_main which are passed
    to various non-http_main functions as arguments at opportune
    times. Here they are:</p>

    <dl compact="compact">
      <dt>permanent_pool</dt>

      <dd>
        <ul>
          <li>never passed to anything else, this is the ancestor
          of all pools</li>
        </ul>
      </dd>

      <dt>pconf</dt>

      <dd>
        <ul>
          <li>subpool of permanent_pool</li>

          <li>created at the beginning of a config "cycle"; exists
          until the server is terminated or restarts; passed to all
          config-time routines, either via cmd-&gt;pool, or as the
          "pool *p" argument on those which don't take pools</li>

          <li>passed to the module init() functions</li>
        </ul>
      </dd>

      <dt>ptemp</dt>

      <dd>
        <ul>
          <li>sorry I lie, this pool isn't called this currently in
          1.3, I renamed it this in my pthreads development. I'm
          referring to the use of ptrans in the parent... contrast
          this with the later definition of ptrans in the
          child.</li>

          <li>subpool of permanent_pool</li>

          <li>created at the beginning of a config "cycle"; exists
          until the end of config parsing; passed to config-time
          routines <em>via</em> cmd-&gt;temp_pool. Somewhat of a
          "bastard child" because it isn't available everywhere.
          Used for temporary scratch space which may be needed by
          some config routines but which is deleted at the end of
          config.</li>
        </ul>
      </dd>

      <dt>pchild</dt>

      <dd>
        <ul>
          <li>subpool of permanent_pool</li>

          <li>created when a child is spawned (or a thread is
          created); lives until that child (thread) is
          destroyed</li>

          <li>passed to the module child_init functions</li>

          <li>destruction happens right after the child_exit
          functions are called... (which may explain why I think
          child_exit is redundant and unneeded)</li>
        </ul>
      </dd>

      <dt>ptrans</dt>

      <dd>
        <ul>
          <li>should be a subpool of pchild, but currently is a
          subpool of permanent_pool, see above</li>

          <li>cleared by the child before going into the accept()
          loop to receive a connection</li>

          <li>used as connection-&gt;pool</li>
        </ul>
      </dd>

      <dt>r-&gt;pool</dt>

      <dd>
        <ul>
          <li>for the main request this is a subpool of
          connection-&gt;pool; for subrequests it is a subpool of
          the parent request's pool.</li>

          <li>exists until the end of the request (<em>i.e.</em>,
          ap_destroy_sub_req, or in child_main after
          process_request has finished)</li>

          <li>note that r itself is allocated from r-&gt;pool;
          <em>i.e.</em>, r-&gt;pool is first created and then r is
          the first thing palloc()d from it</li>
        </ul>
      </dd>
    </dl>

    <p>For almost everything folks do, r-&gt;pool is the pool to
    use. But you can see how other lifetimes, such as pchild, are
    useful to some modules... such as modules that need to open a
    database connection once per child, and wish to clean it up
    when the child dies.</p>

    <p>You can also see how some bugs have manifested themself,
    such as setting connection-&gt;user to a value from r-&gt;pool
    -- in this case connection exists for the lifetime of ptrans,
    which is longer than r-&gt;pool (especially if r-&gt;pool is a
    subrequest!). So the correct thing to do is to allocate from
    connection-&gt;pool.</p>

    <p>And there was another interesting bug in
    mod_include/mod_cgi. You'll see in those that they do this test
    to decide if they should use r-&gt;pool or r-&gt;main-&gt;pool.
    In this case the resource that they are registering for cleanup
    is a child process. If it were registered in r-&gt;pool, then
    the code would wait() for the child when the subrequest
    finishes. With mod_include this could be any old #include, and
    the delay can be up to 3 seconds... and happened quite
    frequently. Instead the subprocess is registered in
    r-&gt;main-&gt;pool which causes it to be cleaned up when the
    entire request is done -- <em>i.e.</em>, after the output has
    been sent to the client and logging has happened.</p>

    <h3><a id="pool-files" name="pool-files">Tracking open files,
    etc.</a></h3>

    <p>As indicated above, resource pools are also used to track
    other sorts of resources besides memory. The most common are
    open files. The routine which is typically used for this is
    <code>ap_pfopen</code>, which takes a resource pool and two
    strings as arguments; the strings are the same as the typical
    arguments to <code>fopen</code>, <em>e.g.</em>,</p>
<pre>
d762 139
a900 1
</pre>
d902 1
a902 150
    <p>There is also a <code>ap_popenf</code> routine, which
    parallels the lower-level <code>open</code> system call. Both
    of these routines arrange for the file to be closed when the
    resource pool in question is cleared.</p>

    <p>Unlike the case for memory, there <em>are</em> functions to
    close files allocated with <code>ap_pfopen</code>, and
    <code>ap_popenf</code>, namely <code>ap_pfclose</code> and
    <code>ap_pclosef</code>. (This is because, on many systems, the
    number of files which a single process can have open is quite
    limited). It is important to use these functions to close files
    allocated with <code>ap_pfopen</code> and
    <code>ap_popenf</code>, since to do otherwise could cause fatal
    errors on systems such as Linux, which react badly if the same
    <code>FILE*</code> is closed more than once.</p>

    <p>(Using the <code>close</code> functions is not mandatory,
    since the file will eventually be closed regardless, but you
    should consider it in cases where your module is opening, or
    could open, a lot of files).</p>

    <h3>Other sorts of resources --- cleanup functions</h3>

    <blockquote>
      More text goes here. Describe the the cleanup primitives in
      terms of which the file stuff is implemented; also,
      <code>spawn_process</code>.
    </blockquote>

    <p>Pool cleanups live until clear_pool() is called:
    clear_pool(a) recursively calls destroy_pool() on all subpools
    of a; then calls all the cleanups for a; then releases all the
    memory for a. destroy_pool(a) calls clear_pool(a) and then
    releases the pool structure itself. <em>i.e.</em>,
    clear_pool(a) doesn't delete a, it just frees up all the
    resources and you can start using it again immediately.</p>

    <h3>Fine control --- creating and dealing with sub-pools, with
    a note on sub-requests</h3>
    On rare occasions, too-free use of <code>ap_palloc()</code> and
    the associated primitives may result in undesirably profligate
    resource allocation. You can deal with such a case by creating
    a <em>sub-pool</em>, allocating within the sub-pool rather than
    the main pool, and clearing or destroying the sub-pool, which
    releases the resources which were associated with it. (This
    really <em>is</em> a rare situation; the only case in which it
    comes up in the standard module set is in case of listing
    directories, and then only with <em>very</em> large
    directories. Unnecessary use of the primitives discussed here
    can hair up your code quite a bit, with very little gain). 

    <p>The primitive for creating a sub-pool is
    <code>ap_make_sub_pool</code>, which takes another pool (the
    parent pool) as an argument. When the main pool is cleared, the
    sub-pool will be destroyed. The sub-pool may also be cleared or
    destroyed at any time, by calling the functions
    <code>ap_clear_pool</code> and <code>ap_destroy_pool</code>,
    respectively. (The difference is that
    <code>ap_clear_pool</code> frees resources associated with the
    pool, while <code>ap_destroy_pool</code> also deallocates the
    pool itself. In the former case, you can allocate new resources
    within the pool, and clear it again, and so forth; in the
    latter case, it is simply gone).</p>

    <p>One final note --- sub-requests have their own resource
    pools, which are sub-pools of the resource pool for the main
    request. The polite way to reclaim the resources associated
    with a sub request which you have allocated (using the
    <code>ap_sub_req_...</code> functions) is
    <code>ap_destroy_sub_req</code>, which frees the resource pool.
    Before calling this function, be sure to copy anything that you
    care about which might be allocated in the sub-request's
    resource pool into someplace a little less volatile (for
    instance, the filename in its <code>request_rec</code>
    structure).</p>

    <p>(Again, under most circumstances, you shouldn't feel obliged
    to call this function; only 2K of memory or so are allocated
    for a typical sub request, and it will be freed anyway when the
    main request pool is cleared. It is only when you are
    allocating many, many sub-requests for a single main request
    that you should seriously consider the
    <code>ap_destroy_...</code> functions).</p>

    <h2><a id="config" name="config">Configuration, commands and
    the like</a></h2>
    One of the design goals for this server was to maintain
    external compatibility with the NCSA 1.3 server --- that is, to
    read the same configuration files, to process all the
    directives therein correctly, and in general to be a drop-in
    replacement for NCSA. On the other hand, another design goal
    was to move as much of the server's functionality into modules
    which have as little as possible to do with the monolithic
    server core. The only way to reconcile these goals is to move
    the handling of most commands from the central server into the
    modules. 

    <p>However, just giving the modules command tables is not
    enough to divorce them completely from the server core. The
    server has to remember the commands in order to act on them
    later. That involves maintaining data which is private to the
    modules, and which can be either per-server, or per-directory.
    Most things are per-directory, including in particular access
    control and authorization information, but also information on
    how to determine file types from suffixes, which can be
    modified by <code>AddType</code> and <code>DefaultType</code>
    directives, and so forth. In general, the governing philosophy
    is that anything which <em>can</em> be made configurable by
    directory should be; per-server information is generally used
    in the standard set of modules for information like
    <code>Alias</code>es and <code>Redirect</code>s which come into
    play before the request is tied to a particular place in the
    underlying file system.</p>

    <p>Another requirement for emulating the NCSA server is being
    able to handle the per-directory configuration files, generally
    called <code>.htaccess</code> files, though even in the NCSA
    server they can contain directives which have nothing at all to
    do with access control. Accordingly, after URI -&gt; filename
    translation, but before performing any other phase, the server
    walks down the directory hierarchy of the underlying
    filesystem, following the translated pathname, to read any
    <code>.htaccess</code> files which might be present. The
    information which is read in then has to be <em>merged</em>
    with the applicable information from the server's own config
    files (either from the <code>&lt;Directory&gt;</code> sections
    in <code>access.conf</code>, or from defaults in
    <code>srm.conf</code>, which actually behaves for most purposes
    almost exactly like <code>&lt;Directory /&gt;</code>).</p>

    <p>Finally, after having served a request which involved
    reading <code>.htaccess</code> files, we need to discard the
    storage allocated for handling them. That is solved the same
    way it is solved wherever else similar problems come up, by
    tying those structures to the per-transaction resource
    pool.</p>

    <h3><a id="per-dir" name="per-dir">Per-directory configuration
    structures</a></h3>
    Let's look out how all of this plays out in
    <code>mod_mime.c</code>, which defines the file typing handler
    which emulates the NCSA server's behavior of determining file
    types from suffixes. What we'll be looking at, here, is the
    code which implements the <code>AddType</code> and
    <code>AddEncoding</code> commands. These commands can appear in
    <code>.htaccess</code> files, so they must be handled in the
    module's private per-directory data, which in fact, consists of
    two separate <code>table</code>s for MIME types and encoding
    information, and is declared as follows: 
<pre>
d907 24
a930 24
</pre>
    When the server is reading a configuration file, or
    <code>&lt;Directory&gt;</code> section, which includes one of
    the MIME module's commands, it needs to create a
    <code>mime_dir_config</code> structure, so those commands have
    something to act on. It does this by invoking the function it
    finds in the module's `create per-dir config slot', with two
    arguments: the name of the directory to which this
    configuration information applies (or <code>NULL</code> for
    <code>srm.conf</code>), and a pointer to a resource pool in
    which the allocation should happen. 

    <p>(If we are reading a <code>.htaccess</code> file, that
    resource pool is the per-request resource pool for the request;
    otherwise it is a resource pool which is used for configuration
    data, and cleared on restarts. Either way, it is important for
    the structure being created to vanish when the pool is cleared,
    by registering a cleanup on the pool if necessary).</p>

    <p>For the MIME module, the per-dir config creation function
    just <code>ap_palloc</code>s the structure above, and a creates
    a couple of <code>table</code>s to fill it. That looks like
    this:</p>
<pre>
d941 18
a958 18
</pre>
    Now, suppose we've just read in a <code>.htaccess</code> file.
    We already have the per-directory configuration structure for
    the next directory up in the hierarchy. If the
    <code>.htaccess</code> file we just read in didn't have any
    <code>AddType</code> or <code>AddEncoding</code> commands, its
    per-directory config structure for the MIME module is still
    valid, and we can just use it. Otherwise, we need to merge the
    two structures somehow. 

    <p>To do that, the server invokes the module's per-directory
    config merge function, if one is present. That function takes
    three arguments: the two structures being merged, and a
    resource pool in which to allocate the result. For the MIME
    module, all that needs to be done is overlay the tables from
    the new per-directory config structure with those from the
    parent:</p>
<pre>
d973 25
a997 25
</pre>
    As a note --- if there is no per-directory merge function
    present, the server will just use the subdirectory's
    configuration info, and ignore the parent's. For some modules,
    that works just fine (<em>e.g.</em>, for the includes module,
    whose per-directory configuration information consists solely
    of the state of the <code>XBITHACK</code>), and for those
    modules, you can just not declare one, and leave the
    corresponding structure slot in the module itself
    <code>NULL</code>. 

    <h3><a id="commands" name="commands">Command handling</a></h3>
    Now that we have these structures, we need to be able to figure
    out how to fill them. That involves processing the actual
    <code>AddType</code> and <code>AddEncoding</code> commands. To
    find commands, the server looks in the module's <code>command
    table</code>. That table contains information on how many
    arguments the commands take, and in what formats, where it is
    permitted, and so forth. That information is sufficient to
    allow the server to invoke most command-handling functions with
    pre-parsed arguments. Without further ado, let's look at the
    <code>AddType</code> command handler, which looks like this
    (the <code>AddEncoding</code> command looks basically the same,
    and won't be shown here): 
<pre>
d1004 26
a1029 26
</pre>
    This command handler is unusually simple. As you can see, it
    takes four arguments, two of which are pre-parsed arguments,
    the third being the per-directory configuration structure for
    the module in question, and the fourth being a pointer to a
    <code>cmd_parms</code> structure. That structure contains a
    bunch of arguments which are frequently of use to some, but not
    all, commands, including a resource pool (from which memory can
    be allocated, and to which cleanups should be tied), and the
    (virtual) server being configured, from which the module's
    per-server configuration data can be obtained if required. 

    <p>Another way in which this particular command handler is
    unusually simple is that there are no error conditions which it
    can encounter. If there were, it could return an error message
    instead of <code>NULL</code>; this causes an error to be
    printed out on the server's <code>stderr</code>, followed by a
    quick exit, if it is in the main config files; for a
    <code>.htaccess</code> file, the syntax error is logged in the
    server error log (along with an indication of where it came
    from), and the request is bounced with a server error response
    (HTTP error status, code 500).</p>

    <p>The MIME module's command table has entries for these
    commands, which look like this:</p>
<pre>
d1034 1
a1034 1
    "an encoding (<em>e.g.</em>, gzip), followed by a file extension" },
d1037 1
a1037 2
</pre>
    The entries in these tables are: 
d1039 1
a1039 2
    <ul>
      <li>The name of the command</li>
d1041 42
a1082 1
      <li>The function which handles it</li>
d1084 1
a1084 43
      <li>a <code>(void *)</code> pointer, which is passed in the
      <code>cmd_parms</code> structure to the command handler ---
      this is useful in case many similar commands are handled by
      the same function.</li>

      <li>A bit mask indicating where the command may appear. There
      are mask bits corresponding to each
      <code>AllowOverride</code> option, and an additional mask
      bit, <code>RSRC_CONF</code>, indicating that the command may
      appear in the server's own config files, but <em>not</em> in
      any <code>.htaccess</code> file.</li>

      <li>A flag indicating how many arguments the command handler
      wants pre-parsed, and how they should be passed in.
      <code>TAKE2</code> indicates two pre-parsed arguments. Other
      options are <code>TAKE1</code>, which indicates one
      pre-parsed argument, <code>FLAG</code>, which indicates that
      the argument should be <code>On</code> or <code>Off</code>,
      and is passed in as a boolean flag, <code>RAW_ARGS</code>,
      which causes the server to give the command the raw, unparsed
      arguments (everything but the command name itself). There is
      also <code>ITERATE</code>, which means that the handler looks
      the same as <code>TAKE1</code>, but that if multiple
      arguments are present, it should be called multiple times,
      and finally <code>ITERATE2</code>, which indicates that the
      command handler looks like a <code>TAKE2</code>, but if more
      arguments are present, then it should be called multiple
      times, holding the first argument constant.</li>

      <li>Finally, we have a string which describes the arguments
      that should be present. If the arguments in the actual config
      file are not as required, this string will be used to help
      give a more specific error message. (You can safely leave
      this <code>NULL</code>).</li>
    </ul>
    Finally, having set this all up, we have to use it. This is
    ultimately done in the module's handlers, specifically for its
    file-typing handler, which looks more or less like this; note
    that the per-directory configuration structure is extracted
    from the <code>request_rec</code>'s per-directory configuration
    vector by using the <code>ap_get_module_config</code> function.
    
<pre>
d1120 21
a1140 1
</pre>
d1142 1
a1142 21
    <h3><a id="servconf" name="servconf">Side notes --- per-server
    configuration, virtual servers, <em>etc</em>.</a></h3>
    The basic ideas behind per-server module configuration are
    basically the same as those for per-directory configuration;
    there is a creation function and a merge function, the latter
    being invoked where a virtual server has partially overridden
    the base server configuration, and a combined structure must be
    computed. (As with per-directory configuration, the default if
    no merge function is specified, and a module is configured in
    some virtual server, is that the base configuration is simply
    ignored). 

    <p>The only substantial difference is that when a command needs
    to configure the per-server private module data, it needs to go
    to the <code>cmd_parms</code> data to get at it. Here's an
    example, from the alias module, which also indicates how a
    syntax error can be returned (note that the per-directory
    configuration argument to the command handler is declared as a
    dummy, since the module doesn't actually have per-directory
    config data):</p>
<pre>
d1155 2
a1156 2
</pre>
        <hr />
d1158 3
a1160 3
    <h3 align="CENTER">Apache HTTP Server Version 1.3</h3>
    <a href="./"><img src="../images/index.gif" alt="Index" /></a>
    <a href="../"><img src="../images/home.gif" alt="Home" /></a>
d1162 2
a1163 2
  </body>
</html>
d1165 1
@


1.1.1.4
log
@import Apache 1.3.29 and mod_ssl 2.8.16
@
text
@d499 1
a499 1
    if ((errstatus = ap_set_content_length (r, r-&gt;finfo.st_size))) {
@


