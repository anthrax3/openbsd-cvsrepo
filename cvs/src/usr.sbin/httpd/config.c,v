head	1.52;
access;
symbols
	OPENBSD_6_1:1.51.0.4
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.46.0.2
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.42.0.4
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.21.0.2
	OPENBSD_5_6_BASE:1.21;
locks; strict;
comment	@ * @;


1.52
date	2017.05.28.10.37.26;	author benno;	state Exp;
branches;
next	1.51;
commitid	uoabWwRtZPFIlwfI;

1.51
date	2017.03.25.17.25.34;	author claudio;	state Exp;
branches;
next	1.50;
commitid	43NsM2S8LTb1McoD;

1.50
date	2016.11.06.10.49.38;	author beck;	state Exp;
branches;
next	1.49;
commitid	49Xfy4fsPamn6Ga1;

1.49
date	2016.10.12.10.57.30;	author reyk;	state Exp;
branches;
next	1.48;
commitid	bwf7lQ6uLNV5tXt6;

1.48
date	2016.09.01.16.07.55;	author reyk;	state Exp;
branches;
next	1.47;
commitid	YFwxiLzXqpxhffPN;

1.47
date	2016.08.15.14.14.55;	author jsing;	state Exp;
branches;
next	1.46;
commitid	jAoX4Twb1LLio9hZ;

1.46
date	2016.05.31.15.28.08;	author jsing;	state Exp;
branches;
next	1.45;
commitid	NbWO7qMPRWBzifot;

1.45
date	2016.04.28.14.20.11;	author jsing;	state Exp;
branches;
next	1.44;
commitid	QyxLnTjK6WHT3hH3;

1.44
date	2015.12.02.15.13.00;	author reyk;	state Exp;
branches;
next	1.43;
commitid	VcVtArSBXuXwQYz0;

1.43
date	2015.08.20.13.00.23;	author reyk;	state Exp;
branches;
next	1.42;
commitid	WDQybNKi4LiEFw8K;

1.42
date	2015.07.19.05.17.27;	author reyk;	state Exp;
branches;
next	1.41;
commitid	jdqdR7UPKnGDga2T;

1.41
date	2015.07.18.06.00.43;	author reyk;	state Exp;
branches;
next	1.40;
commitid	GYrjpgr4p814WbAx;

1.40
date	2015.07.18.05.41.18;	author florian;	state Exp;
branches;
next	1.39;
commitid	2Fg8acs1mTRftiTA;

1.39
date	2015.07.15.16.00.39;	author jsing;	state Exp;
branches;
next	1.38;
commitid	fH3yCV9YOBuXQu46;

1.38
date	2015.07.15.14.39.13;	author jsing;	state Exp;
branches;
next	1.37;
commitid	s4U3ZM538b4htSLh;

1.37
date	2015.04.11.14.52.49;	author jsing;	state Exp;
branches;
next	1.36;
commitid	fd75nyz36psdYmck;

1.36
date	2015.02.23.11.48.41;	author reyk;	state Exp;
branches;
next	1.35;
commitid	AZx6LGGN9iRPB1TW;

1.35
date	2015.02.07.23.56.02;	author reyk;	state Exp;
branches;
next	1.34;
commitid	XXpdSU1rkGa1nBd8;

1.34
date	2015.02.07.01.23.12;	author reyk;	state Exp;
branches;
next	1.33;
commitid	tJajgOHQ1aZRGbKl;

1.33
date	2015.02.05.10.46.17;	author reyk;	state Exp;
branches;
next	1.32;
commitid	HnRWeyUXqxq2rOKj;

1.32
date	2015.01.21.22.21.05;	author reyk;	state Exp;
branches;
next	1.31;
commitid	64Zc6bef54Vu2Noy;

1.31
date	2015.01.19.21.07.33;	author reyk;	state Exp;
branches;
next	1.30;
commitid	Cr1mCt0wWEAa8BcS;

1.30
date	2015.01.19.19.37.50;	author reyk;	state Exp;
branches;
next	1.29;
commitid	95e2Z6BqzOOfEsll;

1.29
date	2015.01.13.09.21.15;	author reyk;	state Exp;
branches;
next	1.28;
commitid	vlRoyiZgaC5QvCo7;

1.28
date	2015.01.06.14.07.48;	author reyk;	state Exp;
branches;
next	1.27;
commitid	hbuEM4rAFoNpF9Xp;

1.27
date	2015.01.03.15.49.18;	author reyk;	state Exp;
branches;
next	1.26;
commitid	9CmQ2ohpRPUtdzFN;

1.26
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.25;
commitid	XnjIOhurXdX5o1V9;

1.25
date	2014.12.12.14.45.59;	author reyk;	state Exp;
branches;
next	1.24;
commitid	j2F3LZ1OyONol7u9;

1.24
date	2014.12.07.16.05.08;	author florian;	state Exp;
branches;
next	1.23;
commitid	nagRglXdsM0Ut0HJ;

1.23
date	2014.11.22.00.24.22;	author tedu;	state Exp;
branches;
next	1.22;
commitid	zQJPNUJ5J7GRL1zG;

1.22
date	2014.09.05.10.04.20;	author reyk;	state Exp;
branches;
next	1.21;
commitid	L018oMJIofTIKQBT;

1.21
date	2014.08.06.18.21.14;	author reyk;	state Exp;
branches
	1.21.2.1;
next	1.20;
commitid	jZUEHtimlVJa4lx5;

1.20
date	2014.08.06.02.04.42;	author jsing;	state Exp;
branches;
next	1.19;
commitid	Wq3y58SpTrH6PeRm;

1.19
date	2014.08.05.18.01.10;	author reyk;	state Exp;
branches;
next	1.18;
commitid	bNgJHQQ6lNzksAJO;

1.18
date	2014.08.05.15.36.59;	author reyk;	state Exp;
branches;
next	1.17;
commitid	0eZ0KmX2vQuZV9Ts;

1.17
date	2014.08.05.14.35.47;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	Ayitb2RpfUCmZdTb;

1.16
date	2014.08.04.18.00.06;	author reyk;	state Exp;
branches;
next	1.15;
commitid	PmcJTI0LH9gT1u3y;

1.15
date	2014.08.04.17.38.12;	author reyk;	state Exp;
branches;
next	1.14;
commitid	QN0gng3yApfUkUG0;

1.14
date	2014.08.04.15.49.28;	author reyk;	state Exp;
branches;
next	1.13;
commitid	LDlAyIlUWDBjADa5;

1.13
date	2014.08.04.11.09.25;	author reyk;	state Exp;
branches;
next	1.12;
commitid	Dj6ALT3dpIHqBQcw;

1.12
date	2014.08.03.11.16.10;	author reyk;	state Exp;
branches;
next	1.11;
commitid	fIgJJaAKavK3V1Ms;

1.11
date	2014.08.02.21.21.47;	author doug;	state Exp;
branches;
next	1.10;
commitid	eYHmkmq5eeXpnLSo;

1.10
date	2014.07.31.14.18.38;	author reyk;	state Exp;
branches;
next	1.9;
commitid	YuIDlOouHxlacCk2;

1.9
date	2014.07.31.13.28.15;	author reyk;	state Exp;
branches;
next	1.8;
commitid	HDnnTvoJZbrXmrWp;

1.8
date	2014.07.31.09.34.57;	author reyk;	state Exp;
branches;
next	1.7;
commitid	KZnViLTHk4UhEJQd;

1.7
date	2014.07.30.13.49.48;	author reyk;	state Exp;
branches;
next	1.6;
commitid	xXDeSGReD1XsNQaP;

1.6
date	2014.07.30.10.05.14;	author reyk;	state Exp;
branches;
next	1.5;
commitid	crg28r1097elBMcd;

1.5
date	2014.07.25.23.30.58;	author reyk;	state Exp;
branches;
next	1.4;
commitid	3E0HntdxEq94QrDK;

1.4
date	2014.07.25.16.23.19;	author reyk;	state Exp;
branches;
next	1.3;
commitid	xxvqODaQzmLv14My;

1.3
date	2014.07.23.13.26.39;	author reyk;	state Exp;
branches;
next	1.2;
commitid	zAAnmSLr14THdHMx;

1.2
date	2014.07.13.14.17.37;	author reyk;	state Exp;
branches;
next	1.1;
commitid	4gg9IcDTWDACYa56;

1.1
date	2014.07.12.23.34.54;	author reyk;	state Exp;
branches;
next	;
commitid	U5OqzWAgis3Sb3uE;

1.21.2.1
date	2014.11.20.07.48.45;	author jasper;	state Exp;
branches;
next	;
commitid	aoUNgrdXQt2mQs98;


desc
@@


1.52
log
@use __func__ in log messages.
From Hiltjo Posthuma hiltjo -AT codemadness -DOT- org, thanks!
ok florian, claudio
@
text
@/*	$OpenBSD: config.c,v 1.51 2017/03/25 17:25:34 claudio Exp $	*/

/*
 * Copyright (c) 2011 - 2015 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/time.h>
#include <sys/uio.h>

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <imsg.h>

#include "httpd.h"

int	 config_getserver_config(struct httpd *, struct server *,
	    struct imsg *);
int	 config_getserver_auth(struct httpd *, struct server_config *);

int
config_init(struct httpd *env)
{
	struct privsep	*ps = env->sc_ps;
	unsigned int	 what;

	/* Global configuration */
	if (privsep_process == PROC_PARENT)
		env->sc_prefork_server = SERVER_NUMPROC;

	ps->ps_what[PROC_PARENT] = CONFIG_ALL;
	ps->ps_what[PROC_SERVER] =
	    CONFIG_SERVERS|CONFIG_MEDIA|CONFIG_AUTH;
	ps->ps_what[PROC_LOGGER] = CONFIG_SERVERS;

	/* Other configuration */
	what = ps->ps_what[privsep_process];

	if (what & CONFIG_SERVERS) {
		if ((env->sc_servers =
		    calloc(1, sizeof(*env->sc_servers))) == NULL)
			return (-1);
		TAILQ_INIT(env->sc_servers);
	}

	if (what & CONFIG_MEDIA) {
		if ((env->sc_mediatypes =
		    calloc(1, sizeof(*env->sc_mediatypes))) == NULL)
			return (-1);
		RB_INIT(env->sc_mediatypes);
	}

	if (what & CONFIG_AUTH) {
		if ((env->sc_auth =
		    calloc(1, sizeof(*env->sc_auth))) == NULL)
			return (-1);
		TAILQ_INIT(env->sc_auth);
	}

	return (0);
}

void
config_purge(struct httpd *env, unsigned int reset)
{
	struct privsep		*ps = env->sc_ps;
	struct server		*srv;
	struct auth		*auth;
	unsigned int		 what;

	what = ps->ps_what[privsep_process] & reset;

	if (what & CONFIG_SERVERS && env->sc_servers != NULL) {
		while ((srv = TAILQ_FIRST(env->sc_servers)) != NULL)
			server_purge(srv);
	}

	if (what & CONFIG_MEDIA && env->sc_mediatypes != NULL)
		media_purge(env->sc_mediatypes);

	if (what & CONFIG_AUTH && env->sc_auth != NULL) {
		while ((auth = TAILQ_FIRST(env->sc_auth)) != NULL) {
			auth_free(env->sc_auth, auth);
			free(auth);
		}
	}
}

int
config_setreset(struct httpd *env, unsigned int reset)
{
	struct privsep	*ps = env->sc_ps;
	int		 id;

	for (id = 0; id < PROC_MAX; id++) {
		if ((reset & ps->ps_what[id]) == 0 ||
		    id == privsep_process)
			continue;
		proc_compose(ps, id, IMSG_CTL_RESET,
		    &reset, sizeof(reset));
	}

	return (0);
}

int
config_getreset(struct httpd *env, struct imsg *imsg)
{
	unsigned int	 mode;

	IMSG_SIZE_CHECK(imsg, &mode);
	memcpy(&mode, imsg->data, sizeof(mode));

	config_purge(env, mode);

	return (0);
}

int
config_getcfg(struct httpd *env, struct imsg *imsg)
{
	struct privsep		*ps = env->sc_ps;
	struct ctl_flags	 cf;
	unsigned int		 what;

	if (IMSG_DATA_SIZE(imsg) != sizeof(cf))
		return (0); /* ignore */

	/* Update runtime flags */
	memcpy(&cf, imsg->data, sizeof(cf));
	env->sc_opts = cf.cf_opts;
	env->sc_flags = cf.cf_flags;
	memcpy(env->sc_tls_sid, cf.cf_tls_sid, sizeof(env->sc_tls_sid));

	what = ps->ps_what[privsep_process];

	if (privsep_process != PROC_PARENT)
		proc_compose(env->sc_ps, PROC_PARENT,
		    IMSG_CFG_DONE, NULL, 0);

	return (0);
}

int
config_setserver(struct httpd *env, struct server *srv)
{
	struct privsep		*ps = env->sc_ps;
	struct server_config	 s;
	int			 id;
	int			 fd, n, m;
	struct iovec		 iov[6];
	size_t			 c;
	unsigned int		 what;

	/* opens listening sockets etc. */
	if (server_privinit(srv) == -1)
		return (-1);

	for (id = 0; id < PROC_MAX; id++) {
		what = ps->ps_what[id];

		if ((what & CONFIG_SERVERS) == 0 || id == privsep_process)
			continue;

		DPRINTF("%s: sending %s \"%s[%u]\" to %s fd %d", __func__,
		    (srv->srv_conf.flags & SRVFLAG_LOCATION) ?
		    "location" : "server",
		    srv->srv_conf.name, srv->srv_conf.id,
		    ps->ps_title[id], srv->srv_s);

		memcpy(&s, &srv->srv_conf, sizeof(s));

		c = 0;
		iov[c].iov_base = &s;
		iov[c++].iov_len = sizeof(s);
		if (srv->srv_conf.return_uri_len != 0) {
			iov[c].iov_base = srv->srv_conf.return_uri;
			iov[c++].iov_len = srv->srv_conf.return_uri_len;
		}

		if (id == PROC_SERVER &&
		    (srv->srv_conf.flags & SRVFLAG_LOCATION) == 0) {
			/* XXX imsg code will close the fd after 1st call */
			n = -1;
			proc_range(ps, id, &n, &m);
			for (n = 0; n < m; n++) {
				if (srv->srv_s == -1)
					fd = -1;
				else if ((fd = dup(srv->srv_s)) == -1)
					return (-1);
				if (proc_composev_imsg(ps, id, n,
				    IMSG_CFG_SERVER, -1, fd, iov, c) != 0) {
					log_warn("%s: failed to compose "
					    "IMSG_CFG_SERVER imsg for `%s'",
					    __func__, srv->srv_conf.name);
					return (-1);
				}

				/* Prevent fd exhaustion in the parent. */
				if (proc_flush_imsg(ps, id, n) == -1) {
					log_warn("%s: failed to flush "
					    "IMSG_CFG_SERVER imsg for `%s'",
					    __func__, srv->srv_conf.name);
					return (-1);
				}
			}

			/* Configure TLS if necessary. */
			config_settls(env, srv);
		} else {
			if (proc_composev(ps, id, IMSG_CFG_SERVER,
			    iov, c) != 0) {
				log_warn("%s: failed to compose "
				    "IMSG_CFG_SERVER imsg for `%s'",
				    __func__, srv->srv_conf.name);
				return (-1);
			}
		}
	}

	/* Close server socket early to prevent fd exhaustion in the parent. */
	if (srv->srv_s != -1) {
		close(srv->srv_s);
		srv->srv_s = -1;
	}

	explicit_bzero(&srv->srv_conf.tls_ticket_key,
	    sizeof(srv->srv_conf.tls_ticket_key));

	return (0);
}

int
config_settls(struct httpd *env, struct server *srv)
{
	struct privsep		*ps = env->sc_ps;
	struct server_config	*srv_conf = &srv->srv_conf;
	struct tls_config	 tls;
	struct iovec		 iov[2];
	size_t			 c;

	if ((srv_conf->flags & SRVFLAG_TLS) == 0)
		return (0);

	log_debug("%s: configuring tls for %s", __func__, srv_conf->name);

	if (srv_conf->tls_cert_len != 0) {
		DPRINTF("%s: sending tls cert \"%s[%u]\" to %s fd %d", __func__,
		    srv_conf->name, srv_conf->id, ps->ps_title[PROC_SERVER],
		    srv->srv_s);

		memset(&tls, 0, sizeof(tls));
		tls.id = srv_conf->id;
		tls.tls_cert_len = srv_conf->tls_cert_len;

		c = 0;
		iov[c].iov_base = &tls;
		iov[c++].iov_len = sizeof(tls);
		iov[c].iov_base = srv_conf->tls_cert;
		iov[c++].iov_len = srv_conf->tls_cert_len;

		if (proc_composev(ps, PROC_SERVER, IMSG_CFG_TLS, iov, c) != 0) {
			log_warn("%s: failed to compose IMSG_CFG_TLS imsg for "
			    "`%s'", __func__, srv_conf->name);
			return (-1);
		}
	}

	if (srv_conf->tls_key_len != 0) {
		DPRINTF("%s: sending tls key \"%s[%u]\" to %s fd %d", __func__,
		    srv_conf->name, srv_conf->id, ps->ps_title[PROC_SERVER],
		    srv->srv_s);

		memset(&tls, 0, sizeof(tls));
		tls.id = srv_conf->id;
		tls.tls_key_len = srv_conf->tls_key_len;

		c = 0;
		iov[c].iov_base = &tls;
		iov[c++].iov_len = sizeof(tls);
		iov[c].iov_base = srv_conf->tls_key;
		iov[c++].iov_len = srv_conf->tls_key_len;

		if (proc_composev(ps, PROC_SERVER, IMSG_CFG_TLS, iov, c) != 0) {
			log_warn("%s: failed to compose IMSG_CFG_TLS imsg for "
			    "`%s'", __func__, srv_conf->name);
			return (-1);
		}
	}

	if (srv_conf->tls_ocsp_staple_len != 0) {
		DPRINTF("%s: sending ocsp staple \"%s[%u]\" to %s fd %d",
		    __func__, srv_conf->name, srv_conf->id,
		    ps->ps_title[PROC_SERVER], srv->srv_s);

		memset(&tls, 0, sizeof(tls));
		tls.id = srv_conf->id;
		tls.tls_ocsp_staple_len = srv_conf->tls_ocsp_staple_len;

		c = 0;
		iov[c].iov_base = &tls;
		iov[c++].iov_len = sizeof(tls);
		iov[c].iov_base = srv_conf->tls_ocsp_staple;
		iov[c++].iov_len = srv_conf->tls_ocsp_staple_len;

		if (proc_composev(ps, PROC_SERVER, IMSG_CFG_TLS, iov, c) != 0) {
			log_warn("%s: failed to compose IMSG_CFG_TLS imsg for "
			    "`%s'", __func__, srv_conf->name);
			return (-1);
		}
	}

	return (0);
}

int
config_getserver_auth(struct httpd *env, struct server_config *srv_conf)
{
	struct privsep		*ps = env->sc_ps;

	if ((ps->ps_what[privsep_process] & CONFIG_AUTH) == 0 ||
	    (srv_conf->flags & SRVFLAG_AUTH) == 0)
		return (0);

	if ((srv_conf->auth = auth_byid(env->sc_auth,
	    srv_conf->auth_id)) == NULL)
		return (-1);

	return (0);
}

int
config_getserver_config(struct httpd *env, struct server *srv,
    struct imsg *imsg)
{
#ifdef DEBUG
	struct privsep		*ps = env->sc_ps;
#endif
	struct server_config	*srv_conf, *parent;
	uint8_t			*p = imsg->data;
	unsigned int		 f;
	size_t			 s;

	if ((srv_conf = calloc(1, sizeof(*srv_conf))) == NULL)
		return (-1);

	IMSG_SIZE_CHECK(imsg, srv_conf);
	memcpy(srv_conf, p, sizeof(*srv_conf));
	s = sizeof(*srv_conf);

	/* Reset these variables to avoid free'ing invalid pointers */
	serverconfig_reset(srv_conf);

	TAILQ_FOREACH(parent, &srv->srv_hosts, entry) {
		if (strcmp(parent->name, srv_conf->name) == 0)
			break;
	}
	if (parent == NULL)
		parent = &srv->srv_conf;

	if (config_getserver_auth(env, srv_conf) != 0)
		goto fail;

	/*
	 * Get variable-length values for the virtual host.  The tls_* ones
	 * aren't needed in the virtual hosts unless we implement SNI.
	 */
	if (srv_conf->return_uri_len != 0) {
		if ((srv_conf->return_uri = get_data(p + s,
		    srv_conf->return_uri_len)) == NULL)
			goto fail;
		s += srv_conf->return_uri_len;
	}

	if (srv_conf->flags & SRVFLAG_LOCATION) {
		/* Inherit configuration from the parent */
		f = SRVFLAG_INDEX|SRVFLAG_NO_INDEX;
		if ((srv_conf->flags & f) == 0) {
			srv_conf->flags |= parent->flags & f;
			(void)strlcpy(srv_conf->index, parent->index,
			    sizeof(srv_conf->index));
		}

		f = SRVFLAG_AUTO_INDEX|SRVFLAG_NO_AUTO_INDEX;
		if ((srv_conf->flags & f) == 0)
			srv_conf->flags |= parent->flags & f;

		f = SRVFLAG_SOCKET|SRVFLAG_FCGI;
		if ((srv_conf->flags & f) == SRVFLAG_FCGI) {
			srv_conf->flags |= f;
			(void)strlcpy(srv_conf->socket, HTTPD_FCGI_SOCKET,
			    sizeof(srv_conf->socket));
		}

		f = SRVFLAG_ROOT;
		if ((srv_conf->flags & f) == 0) {
			srv_conf->flags |= parent->flags & f;
			(void)strlcpy(srv_conf->root, parent->root,
			    sizeof(srv_conf->root));
		}

		f = SRVFLAG_FCGI|SRVFLAG_NO_FCGI;
		if ((srv_conf->flags & f) == 0)
			srv_conf->flags |= parent->flags & f;

		f = SRVFLAG_LOG|SRVFLAG_NO_LOG;
		if ((srv_conf->flags & f) == 0) {
			srv_conf->flags |= parent->flags & f;
			srv_conf->logformat = parent->logformat;
		}

		f = SRVFLAG_SYSLOG|SRVFLAG_NO_SYSLOG;
		if ((srv_conf->flags & f) == 0)
			srv_conf->flags |= parent->flags & f;

		f = SRVFLAG_AUTH|SRVFLAG_NO_AUTH;
		if ((srv_conf->flags & f) == 0) {
			srv_conf->flags |= parent->flags & f;
			srv_conf->auth = parent->auth;
			srv_conf->auth_id = parent->auth_id;
			(void)strlcpy(srv_conf->auth_realm,
			    parent->auth_realm,
			    sizeof(srv_conf->auth_realm));
		}

		f = SRVFLAG_TLS;
		srv_conf->flags |= parent->flags & f;

		f = SRVFLAG_ACCESS_LOG;
		if ((srv_conf->flags & f) == 0) {
			srv_conf->flags |= parent->flags & f;
			(void)strlcpy(srv_conf->accesslog,
			    parent->accesslog,
			    sizeof(srv_conf->accesslog));
		}

		f = SRVFLAG_ERROR_LOG;
		if ((srv_conf->flags & f) == 0) {
			srv_conf->flags |= parent->flags & f;
			(void)strlcpy(srv_conf->errorlog,
			    parent->errorlog,
			    sizeof(srv_conf->errorlog));
		}

		f = SRVFLAG_BLOCK|SRVFLAG_NO_BLOCK;
		if ((srv_conf->flags & f) == 0) {
			free(srv_conf->return_uri);
			srv_conf->flags |= parent->flags & f;
			srv_conf->return_code = parent->return_code;
			srv_conf->return_uri_len = parent->return_uri_len;
			if (srv_conf->return_uri_len &&
			    (srv_conf->return_uri =
			    strdup(parent->return_uri)) == NULL)
				goto fail;
		}

		f = SRVFLAG_DEFAULT_TYPE;
		if ((srv_conf->flags & f) == 0) {
			srv_conf->flags |= parent->flags & f;
			memcpy(&srv_conf->default_type,
			    &parent->default_type, sizeof(struct media_type));
		}

		f = SRVFLAG_SERVER_HSTS;
		srv_conf->flags |= parent->flags & f;
		srv_conf->hsts_max_age = parent->hsts_max_age;
		srv_conf->hsts_flags = parent->hsts_flags;

		memcpy(&srv_conf->timeout, &parent->timeout,
		    sizeof(srv_conf->timeout));
		srv_conf->maxrequests = parent->maxrequests;
		srv_conf->maxrequestbody = parent->maxrequestbody;

		DPRINTF("%s: %s %d location \"%s\", "
		    "parent \"%s[%u]\", flags: %s",
		    __func__, ps->ps_title[privsep_process], ps->ps_instance,
		    srv_conf->location, parent->name, parent->id,
		    printb_flags(srv_conf->flags, SRVFLAG_BITS));
	} else {
		/* Add a new "virtual" server */
		DPRINTF("%s: %s %d server \"%s[%u]\", parent \"%s[%u]\", "
		    "flags: %s", __func__,
		    ps->ps_title[privsep_process], ps->ps_instance,
		    srv_conf->name, srv_conf->id, parent->name, parent->id,
		    printb_flags(srv_conf->flags, SRVFLAG_BITS));
	}

	TAILQ_INSERT_TAIL(&srv->srv_hosts, srv_conf, entry);

	return (0);

 fail:
	serverconfig_free(srv_conf);
	free(srv_conf);
	return (-1);
}

int
config_getserver(struct httpd *env, struct imsg *imsg)
{
#ifdef DEBUG
	struct privsep		*ps = env->sc_ps;
#endif
	struct server		*srv = NULL;
	struct server_config	 srv_conf;
	uint8_t			*p = imsg->data;
	size_t			 s;

	IMSG_SIZE_CHECK(imsg, &srv_conf);
	memcpy(&srv_conf, p, sizeof(srv_conf));
	s = sizeof(srv_conf);

	/* Reset these variables to avoid free'ing invalid pointers */
	serverconfig_reset(&srv_conf);

	if ((IMSG_DATA_SIZE(imsg) - s) < (size_t)srv_conf.return_uri_len) {
		log_debug("%s: invalid message length", __func__);
		goto fail;
	}

	/* Check if server with matching listening socket already exists */
	if ((srv = server_byaddr((struct sockaddr *)
	    &srv_conf.ss, srv_conf.port)) != NULL) {
		/* Add "host" to existing listening server */
		if (imsg->fd != -1) {
			if (srv->srv_s == -1)
				srv->srv_s = imsg->fd;
			else
				close(imsg->fd);
		}
		return (config_getserver_config(env, srv, imsg));
	}

	if (srv_conf.flags & SRVFLAG_LOCATION)
		fatalx("invalid location");

	/* Otherwise create a new server */
	if ((srv = calloc(1, sizeof(*srv))) == NULL)
		goto fail;

	memcpy(&srv->srv_conf, &srv_conf, sizeof(srv->srv_conf));
	srv->srv_s = imsg->fd;

	if (config_getserver_auth(env, &srv->srv_conf) != 0)
		goto fail;

	SPLAY_INIT(&srv->srv_clients);
	TAILQ_INIT(&srv->srv_hosts);

	TAILQ_INSERT_TAIL(&srv->srv_hosts, &srv->srv_conf, entry);
	TAILQ_INSERT_TAIL(env->sc_servers, srv, srv_entry);

	DPRINTF("%s: %s %d configuration \"%s[%u]\", flags: %s", __func__,
	    ps->ps_title[privsep_process], ps->ps_instance,
	    srv->srv_conf.name, srv->srv_conf.id,
	    printb_flags(srv->srv_conf.flags, SRVFLAG_BITS));

	/*
	 * Get all variable-length values for the parent server.
	 */
	if (srv->srv_conf.return_uri_len != 0) {
		if ((srv->srv_conf.return_uri = get_data(p + s,
		    srv->srv_conf.return_uri_len)) == NULL)
			goto fail;
		s += srv->srv_conf.return_uri_len;
	}

	return (0);

 fail:
	if (imsg->fd != -1)
		close(imsg->fd);
	if (srv != NULL)
		serverconfig_free(&srv->srv_conf);
	free(srv);

	return (-1);
}

int
config_gettls(struct httpd *env, struct imsg *imsg)
{
#ifdef DEBUG
	struct privsep		*ps = env->sc_ps;
#endif
	struct server_config	*srv_conf = NULL;
	struct tls_config	 tls_conf;
	uint8_t			*p = imsg->data;
	size_t			 s;

	IMSG_SIZE_CHECK(imsg, &tls_conf);
	memcpy(&tls_conf, p, sizeof(tls_conf));
	s = sizeof(tls_conf);

	if ((IMSG_DATA_SIZE(imsg) - s) <
	    (tls_conf.tls_cert_len + tls_conf.tls_key_len +
	    tls_conf.tls_ocsp_staple_len)) {
		log_debug("%s: invalid message length", __func__);
		goto fail;
	}

	if ((srv_conf = serverconfig_byid(tls_conf.id)) == NULL) {
		log_debug("%s: server not found", __func__);
		goto fail;
	}

	DPRINTF("%s: %s %d tls configuration \"%s[%u]\"", __func__,
	    ps->ps_title[privsep_process], ps->ps_instance,
	    srv_conf->name, srv_conf->id);

	if (tls_conf.tls_cert_len != 0) {
		srv_conf->tls_cert_len = tls_conf.tls_cert_len;
		if ((srv_conf->tls_cert = get_data(p + s,
		    tls_conf.tls_cert_len)) == NULL)
			goto fail;
		s += tls_conf.tls_cert_len;
	}
	if (tls_conf.tls_key_len != 0) {
		srv_conf->tls_key_len = tls_conf.tls_key_len;
		if ((srv_conf->tls_key = get_data(p + s,
		    tls_conf.tls_key_len)) == NULL)
			goto fail;
		s += tls_conf.tls_key_len;
	}
	if (tls_conf.tls_ocsp_staple_len != 0) {
		srv_conf->tls_ocsp_staple_len = tls_conf.tls_ocsp_staple_len;
		if ((srv_conf->tls_ocsp_staple = get_data(p + s,
		    tls_conf.tls_ocsp_staple_len)) == NULL)
			goto fail;
		s += tls_conf.tls_ocsp_staple_len;
	}

	return (0);

 fail:
	return (-1);
}

int
config_setmedia(struct httpd *env, struct media_type *media)
{
	struct privsep		*ps = env->sc_ps;
	int			 id;
	unsigned int		 what;

	for (id = 0; id < PROC_MAX; id++) {
		what = ps->ps_what[id];

		if ((what & CONFIG_MEDIA) == 0 || id == privsep_process)
			continue;

		DPRINTF("%s: sending media \"%s\" to %s", __func__,
		    media->media_name, ps->ps_title[id]);

		proc_compose(ps, id, IMSG_CFG_MEDIA, media, sizeof(*media));
	}

	return (0);
}

int
config_getmedia(struct httpd *env, struct imsg *imsg)
{
#ifdef DEBUG
	struct privsep		*ps = env->sc_ps;
#endif
	struct media_type	 media;
	uint8_t			*p = imsg->data;

	IMSG_SIZE_CHECK(imsg, &media);
	memcpy(&media, p, sizeof(media));

	if (media_add(env->sc_mediatypes, &media) == NULL) {
		log_debug("%s: failed to add media \"%s\"",
		    __func__, media.media_name);
		return (-1);
	}

	DPRINTF("%s: %s %d received media \"%s\"", __func__,
	    ps->ps_title[privsep_process], ps->ps_instance,
	    media.media_name);

	return (0);
}

int
config_setauth(struct httpd *env, struct auth *auth)
{
	struct privsep		*ps = env->sc_ps;
	int			 id;
	unsigned int		 what;

	for (id = 0; id < PROC_MAX; id++) {
		what = ps->ps_what[id];

		if ((what & CONFIG_AUTH) == 0 || id == privsep_process)
			continue;

		DPRINTF("%s: sending auth \"%s[%u]\" to %s", __func__,
		    auth->auth_htpasswd, auth->auth_id, ps->ps_title[id]);

		proc_compose(ps, id, IMSG_CFG_AUTH, auth, sizeof(*auth));
	}

	return (0);
}

int
config_getauth(struct httpd *env, struct imsg *imsg)
{
#ifdef DEBUG
	struct privsep		*ps = env->sc_ps;
#endif
	struct auth		 auth;
	uint8_t			*p = imsg->data;

	IMSG_SIZE_CHECK(imsg, &auth);
	memcpy(&auth, p, sizeof(auth));

	if (auth_add(env->sc_auth, &auth) == NULL) {
		log_debug("%s: failed to add auth \"%s[%u]\"",
		    __func__, auth.auth_htpasswd, auth.auth_id);
		return (-1);
	}

	DPRINTF("%s: %s %d received auth \"%s[%u]\"", __func__,
	    ps->ps_title[privsep_process], ps->ps_instance,
	    auth.auth_htpasswd, auth.auth_id);

	return (0);
}
@


1.51
log
@Implement TLS ticket support in httpd. Off by default. Use
	tls ticket lifetime default
to turn it on with a 2h ticket lifetime.
Rekeying happens after a quarter of that time.
OK reky@@ and bob@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.50 2016/11/06 10:49:38 beck Exp $	*/
d308 3
a310 3
		DPRINTF("%s: sending ocsp staple \"%s[%u]\" to %s fd %d", __func__,
		    srv_conf->name, srv_conf->id, ps->ps_title[PROC_SERVER],
		    srv->srv_s);
@


1.50
log
@Add OCSP stapling support to httpd
ok jsing@@ bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.49 2016/10/12 10:57:30 reyk Exp $	*/
d149 1
d242 3
@


1.49
log
@Prevent fd exhaustion in the parent when loading the listening server
sockets by sending the fd one-by-one.  This allows to start httpd with
max 32 server instances and many server sockets without changing the
default rlimits in any way.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.48 2016/09/01 16:07:55 reyk Exp $	*/
d303 22
d608 2
a609 1
	    (tls_conf.tls_cert_len + tls_conf.tls_key_len)) {
d636 7
@


1.48
log
@The fork+exec diff broke "what?!", the ps_what field determines the
configuration that has to be initialized in each process and was
inherited from the parent instead of setting it everywhere.  I'm
surprised that it worked.

OK florian
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.47 2016/08/15 14:14:55 jsing Exp $	*/
d213 8
d234 6
@


1.47
log
@Use lowercase 'tls' in debug and log messages for consistency.

Requested by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.46 2016/05/31 15:28:08 jsing Exp $	*/
d44 1
a44 1
	if (privsep_process == PROC_PARENT) {
d47 4
a50 5
		ps->ps_what[PROC_PARENT] = CONFIG_ALL;
		ps->ps_what[PROC_SERVER] =
		    CONFIG_SERVERS|CONFIG_MEDIA|CONFIG_AUTH;
		ps->ps_what[PROC_LOGGER] = CONFIG_SERVERS;
	}
@


1.46
log
@Unbreak compilation with -DDEBUG.

From Fabian Raetz <fabian dot raetz at gmail dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.45 2016/04/28 14:20:11 jsing Exp $	*/
d244 1
a244 1
	log_debug("%s: configuring TLS for %s", __func__, srv_conf->name);
d247 1
a247 1
		DPRINTF("%s: sending TLS cert \"%s[%u]\" to %s fd %d", __func__,
d269 1
a269 1
		DPRINTF("%s: sending TLS key \"%s[%u]\" to %s fd %d", __func__,
d583 1
a583 1
	DPRINTF("%s: %s %d TLS configuration \"%s[%u]\"", __func__,
@


1.45
log
@Simplify TLS configuration handling. Instead of matching by address/port,
match by configuration ID. This also prevents a memory leak when there are
multiple certificates specified for the same server.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.44 2015/12/02 15:13:00 reyk Exp $	*/
d585 1
a585 1
	    srv_conf->name, srv->srv_conf.id);
@


1.44
log
@sync with relayd, use proc_compose()
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.43 2015/08/20 13:00:23 reyk Exp $	*/
d236 1
d241 1
a241 1
	if ((srv->srv_conf.flags & SRVFLAG_TLS) == 0)
d244 1
a244 1
	log_debug("%s: configuring TLS for %s", __func__, srv->srv_conf.name);
d246 1
a246 1
	if (srv->srv_conf.tls_cert_len != 0) {
d248 2
a249 2
		    srv->srv_conf.name, srv->srv_conf.id,
		    ps->ps_title[PROC_SERVER], srv->srv_s);
d252 2
a253 4
		tls.id = srv->srv_conf.id;
		tls.port = srv->srv_conf.port;
		memcpy(&tls.ss, &srv->srv_conf.ss, sizeof(tls.ss));
		tls.tls_cert_len = srv->srv_conf.tls_cert_len;
d258 2
a259 2
		iov[c].iov_base = srv->srv_conf.tls_cert;
		iov[c++].iov_len = srv->srv_conf.tls_cert_len;
d263 1
a263 1
			    "`%s'", __func__, srv->srv_conf.name);
d268 1
a268 1
	if (srv->srv_conf.tls_key_len != 0) {
d270 2
a271 2
		    srv->srv_conf.name, srv->srv_conf.id,
		    ps->ps_title[PROC_SERVER], srv->srv_s);
d274 2
a275 4
		tls.id = srv->srv_conf.id;
		tls.port = srv->srv_conf.port;
		memcpy(&tls.ss, &srv->srv_conf.ss, sizeof(tls.ss));
		tls.tls_key_len = srv->srv_conf.tls_key_len;
d280 2
a281 2
		iov[c].iov_base = srv->srv_conf.tls_key;
		iov[c++].iov_len = srv->srv_conf.tls_key_len;
d285 1
a285 1
			    "`%s'", __func__, srv->srv_conf.name);
d563 1
a563 1
	struct server		*srv = NULL;
d578 1
a578 3
	/* Find server with matching listening socket. */
	if ((srv = server_byaddr((struct sockaddr *)
	    &tls_conf.ss, tls_conf.port)) == NULL) {
d585 1
a585 1
	    srv->srv_conf.name, srv->srv_conf.id);
d588 2
a589 2
		srv->srv_conf.tls_cert_len = tls_conf.tls_cert_len;
		if ((srv->srv_conf.tls_cert = get_data(p + s,
d595 2
a596 2
		srv->srv_conf.tls_key_len = tls_conf.tls_key_len;
		if ((srv->srv_conf.tls_key = get_data(p + s,
@


1.43
log
@Change httpd(8) to use C99-style fixed-width integers (uintN_t instead
of u_intN_t) and replace u_int with unsigned int.  Mixing both
variants is a bad style and most contributors seem to prefer this
style; it also helps us to get used to it, portability, and
standardization.

Theoretically no binary change, except one in practice: httpd.o has a
different checksum because gcc with -O2 pads/optimizes "struct
privsep" differently when using "unsigned int" instead "u_int" for the
affected members.  "u_int" is just a typedef of "unsigned int", -O0
doesn't build the difference and clang with -O2 doesn't do it either -
it is just another curiosity from gcc-land.

OK semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.42 2015/07/19 05:17:27 reyk Exp $	*/
d116 1
a116 1
		proc_compose_imsg(ps, id, -1, IMSG_CTL_RESET, -1,
d154 2
a155 2
		proc_compose_imsg(env->sc_ps, PROC_PARENT, -1,
		    IMSG_CFG_DONE, -1, NULL, 0);
d208 1
a208 1
				    IMSG_CFG_SERVER, fd, iov, c) != 0) {
d219 1
a219 1
			if (proc_composev_imsg(ps, id, -1, IMSG_CFG_SERVER, -1,
d262 1
a262 2
		if (proc_composev_imsg(ps, PROC_SERVER, -1, IMSG_CFG_TLS, -1,
		    iov, c) != 0) {
d286 1
a286 2
		if (proc_composev_imsg(ps, PROC_SERVER, -1, IMSG_CFG_TLS, -1,
		    iov, c) != 0) {
d629 1
a629 2
		proc_compose_imsg(ps, id, -1, IMSG_CFG_MEDIA, -1,
		    media, sizeof(*media));
d676 1
a676 2
		proc_compose_imsg(ps, id, -1, IMSG_CFG_AUTH, -1,
		    auth, sizeof(*auth));
@


1.42
log
@For the completeness of HSTS, add the non-standard preload option.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.41 2015/07/18 06:00:43 reyk Exp $	*/
d41 1
a41 1
	u_int		 what;
d81 1
a81 1
config_purge(struct httpd *env, u_int reset)
d86 1
a86 1
	u_int			 what;
d107 1
a107 1
config_setreset(struct httpd *env, u_int reset)
d126 1
a126 1
	u_int		 mode;
d141 1
a141 1
	u_int			 what;
d169 1
a169 1
	u_int			 what;
d322 2
a323 2
	u_int8_t		*p = imsg->data;
	u_int			 f;
d488 1
a488 1
	u_int8_t		*p = imsg->data;
d570 1
a570 1
	u_int8_t		*p = imsg->data;
d620 1
a620 1
	u_int			 what;
d645 1
a645 1
	u_int8_t		*p = imsg->data;
d668 1
a668 1
	u_int			 what;
d693 1
a693 1
	u_int8_t		*p = imsg->data;
@


1.41
log
@Allow to change the default media type globally or per-location,
eg. default type text/html.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.40 2015/07/18 05:41:18 florian Exp $	*/
d449 1
a449 1
		srv_conf->hsts_subdomains = parent->hsts_subdomains;
@


1.40
log
@Implement HTTP Strict Transport Security (HSTS).
Input & OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.39 2015/07/15 16:00:39 jsing Exp $	*/
d437 7
@


1.39
log
@Send the TLS certificate and key via separate imsgs, rather than
including them in the IMSG_CFG_SERVER imsg. This allows the certificate
and key to each be almost 16KB (the maximum size for an imsg), rather than
having a combined total of less than 16KB (which can be reached with large
keys, certificate bundles or by including text versions of certificates).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.38 2015/07/15 14:39:13 jsing Exp $	*/
d438 5
@


1.38
log
@Fix memory leaks that can occur when config_getserver() fails.

config.c r1.34 and r1.30 introduced potential memory leaks for auth and
return_uri when config_getserver fails. Fix this by switching to
serverconfig_free() and adding the missing free for srv_conf->auth.
While here, make serverconfig_free() a little more bulletproof by
explicit_bzero()ing key material.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.37 2015/04/11 14:52:49 jsing Exp $	*/
a195 8
		if (srv->srv_conf.tls_cert_len != 0) {
			iov[c].iov_base = srv->srv_conf.tls_cert;
			iov[c++].iov_len = srv->srv_conf.tls_cert_len;
		}
		if (srv->srv_conf.tls_key_len != 0) {
			iov[c].iov_base = srv->srv_conf.tls_key;
			iov[c++].iov_len = srv->srv_conf.tls_key_len;
		}
d215 3
d233 66
d486 1
a486 3
	if ((IMSG_DATA_SIZE(imsg) - s) <
	    (srv_conf.tls_cert_len + srv_conf.tls_key_len +
	    srv_conf.return_uri_len)) {
d537 47
a583 1
	if (srv->srv_conf.tls_cert_len != 0) {
d585 1
a585 1
		    srv->srv_conf.tls_cert_len)) == NULL)
d587 1
a587 1
		s += srv->srv_conf.tls_cert_len;
d589 2
a590 1
	if (srv->srv_conf.tls_key_len != 0) {
d592 1
a592 1
		    srv->srv_conf.tls_key_len)) == NULL)
d594 1
a594 1
		s += srv->srv_conf.tls_key_len;
a599 6
	if (imsg->fd != -1)
		close(imsg->fd);
	if (srv != NULL)
		serverconfig_free(&srv->srv_conf);
	free(srv);

@


1.37
log
@Always check the return value of proc_composev_imsg() and handle failures
appropriately. Otherwise imsg construction can silently fail, resulting in
non-obvious problems.

Found the hard way by Theodore Wynnychenko.

ok doug@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.36 2015/02/23 11:48:41 reyk Exp $	*/
d496 2
a497 4
	if (srv != NULL) {
		free(srv->srv_conf.tls_cert);
		free(srv->srv_conf.tls_key);
	}
@


1.36
log
@Fix an issues that was found by halex@@: we didn't set the return_uri
in non-location virtual hosts.  Add comments clarify the
variable-length values.

OK halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.35 2015/02/07 23:56:02 reyk Exp $	*/
d215 7
a221 2
				proc_composev_imsg(ps, id, n,
				    IMSG_CFG_SERVER, fd, iov, c);
d224 7
a230 2
			proc_composev_imsg(ps, id, -1, IMSG_CFG_SERVER, -1,
			    iov, c);
@


1.35
log
@Remove server_load_file() in favor of tls_load_file(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.34 2015/02/07 01:23:12 reyk Exp $	*/
d275 11
d358 1
a365 7
		} else {
			if (srv_conf->return_uri_len != 0) {
				if ((srv_conf->return_uri = get_data(p + s,
				    srv_conf->return_uri_len)) == NULL)
					goto fail;
				s += srv_conf->return_uri_len;
			}
d416 2
a417 1
	    (srv_conf.tls_cert_len + srv_conf.tls_key_len)) {
d459 3
@


1.34
log
@Add support for blocking, dropping, and redirecting requests.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.33 2015/02/05 10:46:17 reyk Exp $	*/
d410 1
a410 1
	if ((off_t)(IMSG_DATA_SIZE(imsg) - s) <
@


1.33
log
@Add missing error case to free allocated server_config on failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.32 2015/01/21 22:21:05 reyk Exp $	*/
d192 4
d253 1
d260 1
d345 18
d453 6
@


1.32
log
@httpd is based on relayd and had included many headers that are only
needed by its ancestor.  jsg@@, include-what-you-use, and some manual
review helped to cleanup the headers (take iwyu with a grain of salt).
Based on common practice, httpd.h now also includes the necessary
headers for itself.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.31 2015/01/19 21:07:33 reyk Exp $	*/
d267 1
a267 1
		return (-1);
d361 5
@


1.31
log
@No need to include pfvar.h, another leftover from relayd.  It was also
used for portrange operators which weren't used in httpd.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.30 2015/01/19 19:37:50 reyk Exp $	*/
a19 2
#include <sys/socket.h>
#include <sys/stat.h>
d21 2
a24 5
#include <net/if.h>
#include <netinet/in.h>
#include <net/route.h>

#include <ctype.h>
a25 5
#include <err.h>
#include <errno.h>
#include <event.h>
#include <limits.h>
#include <stdint.h>
a26 1
#include <stdarg.h>
a27 1
#include <netdb.h>
d29 1
a29 1
#include <ifaddrs.h>
@


1.30
log
@Decouple auth parameters from struct server_config into struct auth.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.29 2015/01/13 09:21:15 reyk Exp $	*/
a25 1
#include <net/pfvar.h>
@


1.29
log
@bump copyright year
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.28 2015/01/06 14:07:48 reyk Exp $	*/
d48 1
d61 2
a62 1
		ps->ps_what[PROC_SERVER] = CONFIG_SERVERS|CONFIG_MEDIA;
d83 7
d98 1
d110 7
d237 16
d279 3
d323 10
d417 2
a418 4
	if ((srv = calloc(1, sizeof(*srv))) == NULL) {
		close(imsg->fd);
		return (-1);
	}
d423 3
d453 2
d508 48
@


1.28
log
@Only open a socket once for each unique "listen on" statement.  This
prevents running out of file descriptors when loading a configuration
with many aliases.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.27 2015/01/03 15:49:18 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2011 - 2014 Reyk Floeter <reyk@@openbsd.org>
@


1.27
log
@Support alias names and multiple listen statements per server block.
The implementation is done in the parser by expanding each
alias/listen into an independent server configuration; this makes it
easier to handle internally without adding additional loops or
conditions.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.26 2014/12/21 00:54:49 guenther Exp $	*/
d203 3
a205 1
				if ((fd = dup(srv->srv_s)) == -1)
a215 3
	close(srv->srv_s);
	srv->srv_s = -1;

d358 6
a363 2
		if (imsg->fd != -1)
			close(imsg->fd);
@


1.26
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.25 2014/12/12 14:45:59 reyk Exp $	*/
d177 3
a179 1
		DPRINTF("%s: sending server \"%s[%u]\" to %s fd %d", __func__,
@


1.25
log
@Like previously done in relayd, change the keyword "ssl" to "tls" to
reflect reality.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.24 2014/12/07 16:05:08 florian Exp $	*/
a27 2
#include <arpa/inet.h>
#include <arpa/nameser.h>
@


1.24
log
@Avoid NULL deref in error case; found with llvm.
OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.23 2014/11/22 00:24:22 tedu Exp $	*/
d188 3
a190 3
		if (srv->srv_conf.ssl_cert_len != 0) {
			iov[c].iov_base = srv->srv_conf.ssl_cert;
			iov[c++].iov_len = srv->srv_conf.ssl_cert_len;
d192 3
a194 3
		if (srv->srv_conf.ssl_key_len != 0) {
			iov[c].iov_base = srv->srv_conf.ssl_key;
			iov[c++].iov_len = srv->srv_conf.ssl_key_len;
d288 1
a288 1
		f = SRVFLAG_SSL;
d350 1
a350 1
	    (srv_conf.ssl_cert_len + srv_conf.ssl_key_len)) {
d387 3
a389 3
	if (srv->srv_conf.ssl_cert_len != 0) {
		if ((srv->srv_conf.ssl_cert = get_data(p + s,
		    srv->srv_conf.ssl_cert_len)) == NULL)
d391 1
a391 1
		s += srv->srv_conf.ssl_cert_len;
d393 3
a395 3
	if (srv->srv_conf.ssl_key_len != 0) {
		if ((srv->srv_conf.ssl_key = get_data(p + s,
		    srv->srv_conf.ssl_key_len)) == NULL)
d397 1
a397 1
		s += srv->srv_conf.ssl_key_len;
d404 2
a405 2
		free(srv->srv_conf.ssl_cert);
		free(srv->srv_conf.ssl_key);
@


1.23
log
@use size_t where appropriate. ok deraadt reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.22 2014/09/05 10:04:20 reyk Exp $	*/
d403 4
a406 2
	free(srv->srv_conf.ssl_cert);
	free(srv->srv_conf.ssl_key);
@


1.22
log
@Remove a limitation that only allowed to specify a server name once.
The key has been changed to server name + address + port and now it is
possible to use the same server name for multiple servers with
different addresses, eg. http://www.example.com and
https://www.example.com/.

OK doug@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.21 2014/08/06 18:21:14 reyk Exp $	*/
d349 1
a349 1
	if ((u_int)(IMSG_DATA_SIZE(imsg) - s) <
@


1.21
log
@Limit the body size in client requests (eg. POST data) to 1M by default;
add a configuration option to change the limit.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.20 2014/08/06 02:04:42 jsing Exp $	*/
d179 3
a181 2
		DPRINTF("%s: sending server %s to %s fd %d", __func__,
		    srv->srv_conf.name, ps->ps_title[id], srv->srv_s);
d227 1
a227 1
	struct server_config	*srv_conf;
d237 10
d251 2
a252 2
			srv_conf->flags |= srv->srv_conf.flags & f;
			(void)strlcpy(srv_conf->index, srv->srv_conf.index,
d258 1
a258 1
			srv_conf->flags |= srv->srv_conf.flags & f;
d269 2
a270 2
			srv_conf->flags |= srv->srv_conf.flags & f;
			(void)strlcpy(srv_conf->root, srv->srv_conf.root,
d276 1
a276 1
			srv_conf->flags |= srv->srv_conf.flags & f;
d280 2
a281 2
			srv_conf->flags |= srv->srv_conf.flags & f;
			srv_conf->logformat = srv->srv_conf.logformat;
d286 1
a286 1
			srv_conf->flags |= srv->srv_conf.flags & f;
d289 1
a289 1
		srv_conf->flags |= srv->srv_conf.flags & f;
d293 1
a293 1
			srv_conf->flags |= srv->srv_conf.flags & f;
d295 1
a295 1
			    srv->srv_conf.accesslog,
d301 1
a301 1
			srv_conf->flags |= srv->srv_conf.flags & f;
d303 1
a303 1
			    srv->srv_conf.errorlog,
d307 1
a307 1
		memcpy(&srv_conf->timeout, &srv->srv_conf.timeout,
d309 2
a310 2
		srv_conf->maxrequests = srv->srv_conf.maxrequests;
		srv_conf->maxrequestbody = srv->srv_conf.maxrequestbody;
d313 1
a313 1
		    "parent \"%s\", flags: %s",
d315 1
a315 1
		    srv_conf->location, srv->srv_conf.name,
d319 4
a322 3
		DPRINTF("%s: %s %d server \"%s\", parent \"%s\", flags: %s",
		    __func__, ps->ps_title[privsep_process], ps->ps_instance,
		    srv_conf->name, srv->srv_conf.name,
d346 3
d382 1
a382 1
	DPRINTF("%s: %s %d configuration \"%s\", flags: %s", __func__,
d384 1
a384 1
	    srv->srv_conf.name,
@


1.21.2.1
log
@httpd was developed very rapidly in the weeks before 5.6 release,
and it has a few flaws.  It would be nice to get these flaws fully
remediated before the next release, and that requires the community
to want to use it.
Therefore here is a "jumbo" patch that brings in the most important fixes.

committing on behalf of reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.21 2014/08/06 18:21:14 reyk Exp $	*/
d226 1
a226 1
	struct server_config	*srv_conf, *parent;
a235 10
	/* Reset these variables to avoid free'ing invalid pointers */
	serverconfig_reset(srv_conf);

	TAILQ_FOREACH(parent, &srv->srv_hosts, entry) {
		if (strcmp(parent->name, srv_conf->name) == 0)
			break;
	}
	if (parent == NULL)
		parent = &srv->srv_conf;

d240 2
a241 2
			srv_conf->flags |= parent->flags & f;
			(void)strlcpy(srv_conf->index, parent->index,
d247 1
a247 1
			srv_conf->flags |= parent->flags & f;
d258 2
a259 2
			srv_conf->flags |= parent->flags & f;
			(void)strlcpy(srv_conf->root, parent->root,
d265 1
a265 1
			srv_conf->flags |= parent->flags & f;
d269 2
a270 2
			srv_conf->flags |= parent->flags & f;
			srv_conf->logformat = parent->logformat;
d275 1
a275 1
			srv_conf->flags |= parent->flags & f;
d278 1
a278 1
		srv_conf->flags |= parent->flags & f;
d282 1
a282 1
			srv_conf->flags |= parent->flags & f;
d284 1
a284 1
			    parent->accesslog,
d290 1
a290 1
			srv_conf->flags |= parent->flags & f;
d292 1
a292 1
			    parent->errorlog,
d296 1
a296 1
		memcpy(&srv_conf->timeout, &parent->timeout,
d298 2
a299 2
		srv_conf->maxrequests = parent->maxrequests;
		srv_conf->maxrequestbody = parent->maxrequestbody;
a332 3

	/* Reset these variables to avoid free'ing invalid pointers */
	serverconfig_reset(&srv_conf);
@


1.20
log
@Load the SSL public/private keys in the parent process, then provide them
to the privsep process via imsg. This allows the keys to be moved out of
the chroot (now /etc/ssl/server.crt, /etc/ssl/private/server.key).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.19 2014/08/05 18:01:10 reyk Exp $	*/
d299 1
@


1.19
log
@Add configuration options for the most-important connection limits:
max requests (per connection) and timeout.  We don't want to add too
many button, and there are good defaults, but these ones are kind of
mandatory.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.18 2014/08/05 15:36:59 reyk Exp $	*/
d187 8
d324 1
a324 1
	struct server		*srv;
d333 6
d371 13
d385 7
@


1.18
log
@Improve logging to allow per- server/location log files.  The log
files can also be owned by root now: they're opened by the parent and
send to the logger process with fd passing.  This also works with reload.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.17 2014/08/05 14:35:47 deraadt Exp $	*/
d287 4
@


1.17
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.16 2014/08/04 18:00:06 reyk Exp $	*/
d63 1
a63 1
		ps->ps_what[PROC_LOGGER] = 0;
d271 16
@


1.16
log
@Add HTTPS = on CGI variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.15 2014/08/04 17:38:12 reyk Exp $	*/
d282 1
a282 1
    		    printb_flags(srv_conf->flags, SRVFLAG_BITS));
@


1.15
log
@Proxy commit for jsing@@:
"Add TLS/SSL support to httpd, based on the recent ressl commits."

From jsing@@
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.14 2014/08/04 15:49:28 reyk Exp $	*/
d268 3
@


1.14
log
@Add initial support for log files in /var/www/logs/.  Logging with
syslog is still supported but disabled by default.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.13 2014/08/04 11:09:25 reyk Exp $	*/
d308 1
a308 2
		return (config_getserver_config(env,
		    srv, imsg));
@


1.13
log
@httpd doesn't support SSL/TLS yet, remove the remaining bits.
The secrect plan is to add it later using the ressl wrapper library.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.12 2014/08/03 11:16:10 reyk Exp $	*/
d63 1
d265 6
a270 1
		DPRINTF("%s: %s %d received location \"%s\", parent \"%s\"",
d272 2
a273 1
		    srv_conf->location, srv->srv_conf.name);
d276 1
a276 1
		DPRINTF("%s: %s %d received server \"%s\", parent \"%s\"",
d278 2
a279 1
		    srv_conf->name, srv->srv_conf.name);
d330 1
a330 1
	DPRINTF("%s: %s %d received configuration \"%s\"", __func__,
d332 2
a333 1
	    srv->srv_conf.name);
@


1.12
log
@Split fastcgi socket path and document root option and add the
SCRIPT_FILENAME CGI param with a prepended root.  This fixes php-fpm
that expects SCRIPT_FILENAME and also works with slowcgi if you
configure the root correctly.  For example, if SCRIPT_NAME and
REQUEST_URI are /php/index.php, root is /htdocs, SCRIPT_FILENAME will
be /htdocs/php/index.php.  As tested and discussed with florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.11 2014/08/02 21:21:47 doug Exp $	*/
d39 1
a44 2

#include <openssl/ssl.h>
@


1.11
log
@Locations now inherit access log settings from the server.

Add log to the server flags.

input/"Looks ok" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.10 2014/07/31 14:18:38 reyk Exp $	*/
d241 1
a241 1
		f = SRVFLAG_PATH|SRVFLAG_FCGI;
d243 3
a245 4
			(void)strlcpy(srv_conf->path,
			    HTTPD_FCGI_SOCKET,
			    sizeof(srv_conf->path));
			srv_conf->flags |= SRVFLAG_PATH;
d248 1
a248 1
		f = SRVFLAG_PATH;
d250 3
a252 3
			(void)strlcpy(srv_conf->path,
			    srv->srv_conf.path,
			    sizeof(srv_conf->path));
@


1.10
log
@Allow to specify a non-default fastcgi socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.9 2014/07/31 13:28:15 reyk Exp $	*/
d259 6
@


1.9
log
@Rename the "docroot" variable to "path" because it will be used for
either files or the fastcgi socket (and there's no need to use a union yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.8 2014/07/31 09:34:57 reyk Exp $	*/
d240 8
@


1.8
log
@Add a configuration variable "fastcgi" to enable it per server or location.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.7 2014/07/30 13:49:48 reyk Exp $	*/
d241 1
a241 1
		f = SRVFLAG_DOCROOT;
d243 3
a245 3
			(void)strlcpy(srv_conf->docroot,
			    srv->srv_conf.docroot,
			    sizeof(srv_conf->docroot));
@


1.7
log
@Make "location" work with name-based virtual servers.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.6 2014/07/30 10:05:14 reyk Exp $	*/
d247 4
@


1.6
log
@Add "location" keyword to specify path-specific configuration in
servers, for example auto index for a sub-directory only.  Internally,
a "location" is just a special type of a "virtual" server.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.5 2014/07/25 23:30:58 reyk Exp $	*/
a277 8
	if (srv_conf.flags & SRVFLAG_LOCATION) {
		if ((srv = server_byname(srv_conf.name)) == NULL) {
			log_warnx("%s: invalid location", __func__);
			return (-1);
		}
		return (config_getserver_config(env, srv, imsg));
	}

d282 2
a283 1
		close(imsg->fd);
d287 3
@


1.5
log
@Differentiate servers by address and port, not just by address.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.4 2014/07/25 16:23:19 reyk Exp $	*/
d188 2
a189 1
		if (id == PROC_SERVER) {
d220 1
d228 30
a259 4
	DPRINTF("%s: %s %d received configuration \"%s\", parent \"%s\"",
	    __func__, ps->ps_title[privsep_process], ps->ps_instance,
	    srv_conf->name, srv->srv_conf.name);

d277 8
@


1.4
log
@Add support for "virtual hosts" aka. server blocks aka. multiple
servers with the same or "overlapping" IP address but a different name.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.3 2014/07/23 13:26:39 reyk Exp $	*/
d252 1
a252 1
	    &srv_conf.ss)) != NULL) {
@


1.3
log
@Correctly shutdown the servers when the process is terminating;
prevents a crash on exit.  With debugging help from blambert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.2 2014/07/13 14:17:37 reyk Exp $	*/
d49 3
d211 25
d242 1
d246 14
d265 1
a265 4
	IMSG_SIZE_CHECK(imsg, &srv->srv_conf);
	memcpy(&srv->srv_conf, p, sizeof(srv->srv_conf));
	s = sizeof(srv->srv_conf);

d269 3
@


1.2
log
@Add support for media types (aka. MIME types): the types section is
compatible to nginx' mime.types file which can be included directly.
If not present, use a few built-in defaults for html, css, txt, jpeg,
gif, png, and js.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.1 2014/07/12 23:34:54 reyk Exp $	*/
d93 2
a94 4
		while ((srv = TAILQ_FIRST(env->sc_servers)) != NULL) {
			TAILQ_REMOVE(env->sc_servers, srv, srv_entry);
			free(srv);
		}
@


1.1
log
@Add httpd(8), an attempt to turn the relayd(8) codebase into a simple
web server.  It is not finished yet and I just started it today, but
the goal is to provide an HTTP server that a) provides minimal
features, b) serves static files, c) provides FastCGI support, and d)
follows common coding practices of OpenBSD.

It will neither support plugins, nor custom memory allocators, EBCDIC
support, PCRE or any other things that can be found elsewhere.
httpd(8) is not intended to provide a fully-featured replacement for
nginx(8) or the Apache, but it will provide enough functionality that
is needed in the OpenBSD base system.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 1
a60 1
		ps->ps_what[PROC_SERVER] = CONFIG_SERVERS;
d73 7
d98 3
d236 48
@

