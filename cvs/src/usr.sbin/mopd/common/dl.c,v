head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.4
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.8.0.28
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.24
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.26
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.18
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	MOPD254:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	MOPD253:1.1.1.1
	MAJA:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2017.07.29.07.18.03;	author florian;	state Exp;
branches;
next	1.10;
commitid	B2nY1wH8vA5b25nk;

1.10
date	2017.01.21.08.33.51;	author krw;	state Exp;
branches;
next	1.9;
commitid	xpTSTOgSQRGS1RiF;

1.9
date	2016.12.25.16.40.06;	author krw;	state Exp;
branches;
next	1.8;
commitid	qVghsbRQPfYVwJZ6;

1.8
date	2009.10.27.23.59.52;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.17.13.17.07;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.15.11.55.48;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.14.20.37.28;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.01.00.56.51;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.02.21.38.39;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	96.09.21.19.11.26;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.13.49.16;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.13.49.16;	author maja;	state Exp;
branches;
next	;


desc
@@


1.11
log
@change if ((a == b)) to if (a == b); silences noisy on-by-default
"equality comparison with extraneous parentheses
[-Wparentheses-equality]" clang warning.
OK deraadt, kettenis
@
text
@/*	$OpenBSD: dl.c,v 1.10 2017/01/21 08:33:51 krw Exp $ */

/*
 * Copyright (c) 1993-95 Mats O Jansson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "os.h"
#include "common/get.h"
#include "common/print.h"
#include "common/mopdef.h"

void
mopDumpDL(FILE *fd, u_char *pkt, int trans)
{
	int	i, idx = 0;
	long	tmpl;
	u_char	tmpc, c, program[17], code, *ucp;
	u_short	len, tmps, moplen;

	len = mopGetLength(pkt, trans);

	switch (trans) {
	case TRANS_8023:
		idx = 22;
		moplen = len - 8;
		break;
	default:
		idx = 16;
		moplen = len;
	}
	code = mopGetChar(pkt, &idx);

	switch (code) {
	case MOP_K_CODE_MLT:
		tmpc = mopGetChar(pkt, &idx);	/* Load Number */
		fprintf(fd, "Load Number  :   %02x\n", tmpc);

		if (moplen > 6) {
			tmpl = mopGetLong(pkt, &idx);/* Load Address */
			fprintf(fd, "Load Address : %08lx\n", tmpl);
		}

		if (moplen > 10) {
			for (i = 0; i < (moplen - 10); i++) {
				if ((i % 16) == 0) {
					if ((i / 16) == 0)
						fprintf(fd,
						    "Image Data   : %04x ",
						    moplen-10);
					else
						fprintf(fd,
						    "                    ");
				}

				fprintf(fd, "%02x ", mopGetChar(pkt, &idx));
				if ((i % 16) == 15)
					fprintf(fd, "\n");
			}

			if ((i % 16) != 15)
				fprintf(fd, "\n");
		}

		tmpl = mopGetLong(pkt, &idx);	/* Load Address */
		fprintf(fd, "Xfer Address : %08lx\n", tmpl);
		break;
	case MOP_K_CODE_DCM:
		/* Empty Message */
		break;
	case MOP_K_CODE_MLD:
		tmpc = mopGetChar(pkt, &idx);	/* Load Number */
		fprintf(fd, "Load Number  :   %02x\n", tmpc);

		tmpl = mopGetLong(pkt, &idx);	/* Load Address */
		fprintf(fd, "Load Address : %08lx\n", tmpl);

		if (moplen > 6) {
			for (i = 0; i < (moplen - 6); i++) {
				if ((i % 16) == 0) {
					if ((i / 16) == 0)
						fprintf(fd,
						    "Image Data   : %04x ",
						    moplen-6);
					else
						fprintf(fd,
						    "                    ");
				}

				fprintf(fd, "%02x ", mopGetChar(pkt, &idx));
				if ((i % 16) == 15)
					fprintf(fd, "\n");
			}

			if ((i % 16) != 15)
				fprintf(fd, "\n");
		}
		break;
	case MOP_K_CODE_ASV:
		/* Empty Message */
		break;
	case MOP_K_CODE_RMD:
		tmpl = mopGetLong(pkt, &idx);	/* Memory Address */
		fprintf(fd, "Mem Address  : %08lx\n", tmpl);
		tmps = mopGetShort(pkt, &idx);	/* Count */
		fprintf(fd, "Count        : %04x (%d)\n", tmps, tmps);
		break;
	case MOP_K_CODE_RPR:
		tmpc = mopGetChar(pkt, &idx);	/* Device Type */
		fprintf(fd, "Device Type  :   %02x ", tmpc);
		mopPrintDevice(fd, tmpc);
		fprintf(fd, "\n");

		tmpc = mopGetChar(pkt, &idx);	/* Format Version */
		fprintf(fd, "Format       :   %02x\n", tmpc);

		tmpc = mopGetChar(pkt, &idx);	/* Program Type */
		fprintf(fd, "Program Type :   %02x ", tmpc);
		mopPrintPGTY(fd, tmpc);
		fprintf(fd, "\n");

		program[0] = 0;
		tmpc = mopGetChar(pkt, &idx);	/* Software ID Len */
		for (i = 0; i < tmpc; i++) {
			program[i] = mopGetChar(pkt, &idx);
			program[i + 1] = '\0';
		}

		fprintf(fd, "Software     :   %02x '%s'\n", tmpc, program);

		tmpc = mopGetChar(pkt, &idx);	/* Processor */
		fprintf(fd, "Processor    :   %02x ", tmpc);
		mopPrintBPTY(fd, tmpc);
		fprintf(fd, "\n");

		mopPrintInfo(fd, pkt, &idx, moplen, code, trans);

		break;
	case MOP_K_CODE_RML:

		tmpc = mopGetChar(pkt, &idx);	/* Load Number */
		fprintf(fd, "Load Number  :   %02x\n", tmpc);

		tmpc = mopGetChar(pkt, &idx);	/* Error */
		fprintf(fd, "Error        :   %02x (", tmpc);
		if (tmpc == 0)
			fprintf(fd, "no error)\n");
		else
			fprintf(fd, "error)\n");

		break;
	case MOP_K_CODE_RDS:

		tmpc = mopGetChar(pkt, &idx);	/* Device Type */
		fprintf(fd, "Device Type  :   %02x ", tmpc);
		mopPrintDevice(fd, tmpc);
		fprintf(fd, "\n");

		tmpc = mopGetChar(pkt, &idx);	/* Format Version */
		fprintf(fd, "Format       :   %02x\n", tmpc);

		tmpl = mopGetLong(pkt, &idx);	/* Memory Size */
		fprintf(fd, "Memory Size  : %08lx\n", tmpl);

		tmpc = mopGetChar(pkt, &idx);	/* Bits */
		fprintf(fd, "Bits         :   %02x\n", tmpc);

		mopPrintInfo(fd, pkt, &idx, moplen, code, trans);

		break;
	case MOP_K_CODE_MDD:

		tmpl = mopGetLong(pkt, &idx);	/* Memory Address */
		fprintf(fd, "Mem Address  : %08lx\n", tmpl);

		if (moplen > 5) {
			for (i = 0; i < (moplen - 5); i++) {
				if ((i % 16) == 0) {
					if ((i / 16) == 0)
						fprintf(fd,
						    "Image Data   : %04x ",
						    moplen-5);
					else
						fprintf(fd,
						    "                    ");
				}
				fprintf(fd, "%02x ",  mopGetChar(pkt, &idx));
				if ((i % 16) == 15)
					fprintf(fd, "\n");
			}
			if ((i % 16) != 15)
				fprintf(fd, "\n");
		}

		break;
	case MOP_K_CODE_PLT:

		tmpc = mopGetChar(pkt, &idx);	/* Load Number */
		fprintf(fd, "Load Number  :   %02x\n", tmpc);

		tmpc = mopGetChar(pkt, &idx);	/* Parameter Type */
		while (tmpc != MOP_K_PLTP_END) {
			c = mopGetChar(pkt, &idx);	/* Parameter Length */
			switch (tmpc) {
			case MOP_K_PLTP_TSN:		/* Target Name */
				fprintf(fd, "Target Name  :   %02x '", c);
				for (i = 0; i < c; i++)
					fprintf(fd, "%c",
					    mopGetChar(pkt, &idx));
				fprintf(fd, "'\n");
				break;
			case MOP_K_PLTP_TSA:		/* Target Address */
				fprintf(fd, "Target Addr  :   %02x ", c);
				for (i = 0; i < c; i++)
					fprintf(fd, "%02x ",
					    mopGetChar(pkt, &idx));
				fprintf(fd, "\n");
				break;
			case MOP_K_PLTP_HSN:		/* Host Name */
				fprintf(fd, "Host Name    :   %02x '", c);
				for (i = 0; i < c; i++)
					fprintf(fd, "%c",
					    mopGetChar(pkt, &idx));
				fprintf(fd, "'\n");
				break;
			case MOP_K_PLTP_HSA:		/* Host Address */
				fprintf(fd, "Host Addr    :   %02x ", c);
				for (i = 0; i < c; i++)
					fprintf(fd, "%02x ",
					    mopGetChar(pkt, &idx));
				fprintf(fd, "\n");
				break;
			case MOP_K_PLTP_HST:		/* Host Time */
				ucp = pkt + idx; idx = idx + 10;
				fprintf(fd, "Host Time    : ");
				mopPrintTime(fd, ucp);
				fprintf(fd, "\n");
				break;
			default:
				break;
			}
			tmpc = mopGetChar(pkt, &idx);	/* Parameter Type */
		}

		tmpl = mopGetLong(pkt, &idx);	/* Transfer Address */
		fprintf(fd, "Transfer Addr: %08lx\n", tmpl);

		break;
	default:
		break;
	}
}
@


1.10
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.9 2016/12/25 16:40:06 krw Exp $ */
d165 1
a165 1
		if ((tmpc == 0))
@


1.9
log
@Add some {}'s to eliminate "ambiguous else" warnings from gcc.

ok tb@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.8 2009/10/27 23:59:52 deraadt Exp $ */
d18 1
a18 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, 
d20 1
a20 1
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
@


1.8
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.7 2006/04/17 13:17:07 maja Exp $ */
d99 1
a99 1
				if ((i % 16) == 0)
d107 1
@


1.7
log
@Make the code lint friendly. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.6 2006/04/15 11:55:48 maja Exp $ */
a25 5

#ifndef lint
static const char rcsid[] =
    "$OpenBSD: dl.c,v 1.6 2006/04/15 11:55:48 maja Exp $";
#endif
@


1.6
log
@Fix some bugs in printing of MOP packets. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.5 2004/04/14 20:37:28 henning Exp $ */
d27 1
a27 1
#ifndef LINT
d29 1
a29 1
    "$OpenBSD: dl.c,v 1.5 2004/04/14 20:37:28 henning Exp $";
d40 1
a40 1
	int	i, index = 0;
d49 1
a49 1
		index = 22;
d53 1
a53 1
		index = 16;
d56 1
a56 1
	code = mopGetChar(pkt, &index);
d60 1
a60 1
		tmpc = mopGetChar(pkt, &index);	/* Load Number */
d64 1
a64 1
			tmpl = mopGetLong(pkt, &index);/* Load Address */
a68 1
#ifndef SHORT_PRINT
d80 1
a80 1
				fprintf(fd, "%02x ", mopGetChar(pkt, &index));
a86 3
#else
			index = index + moplen - 10;
#endif
d89 1
a89 1
		tmpl = mopGetLong(pkt, &index);	/* Load Address */
d96 1
a96 1
		tmpc = mopGetChar(pkt, &index);	/* Load Number */
d99 1
a99 1
		tmpl = mopGetLong(pkt, &index);	/* Load Address */
a102 1
#ifndef SHORT_PRINT
d113 1
a113 1
				fprintf(fd, "%02x ", mopGetChar(pkt, &index));
a119 3
#else
			index = index + moplen - 6;
#endif
d126 1
a126 1
		tmpl = mopGetLong(pkt, &index);	/* Memory Address */
d128 1
a128 1
		tmps = mopGetShort(pkt, &index);	/* Count */
d132 1
a132 1
		tmpc = mopGetChar(pkt, &index);	/* Device Type */
d137 1
a137 1
		tmpc = mopGetChar(pkt, &index);	/* Format Version */
d140 1
a140 1
		tmpc = mopGetChar(pkt, &index);	/* Program Type */
d146 1
a146 1
		tmpc = mopGetChar(pkt, &index);	/* Software ID Len */
d148 1
a148 1
			program[i] = mopGetChar(pkt, &index);
d154 1
a154 1
		tmpc = mopGetChar(pkt, &index);	/* Processor */
d159 1
a159 1
		mopPrintInfo(fd, pkt, &index, moplen, code, trans);
d164 1
a164 1
		tmpc = mopGetChar(pkt, &index);	/* Load Number */
d167 2
a168 2
		tmpc = mopGetChar(pkt, &index);	/* Error */
		(void)fprintf(fd, "Error        :   %02x (", tmpc);
d177 1
a177 1
		tmpc = mopGetChar(pkt, &index);	/* Device Type */
d182 1
a182 1
		tmpc = mopGetChar(pkt, &index);	/* Format Version */
d185 1
a185 1
		tmpl = mopGetLong(pkt, &index);	/* Memory Size */
d188 1
a188 1
		tmpc = mopGetChar(pkt, &index);	/* Bits */
d191 1
a191 1
		mopPrintInfo(fd, pkt, &index, moplen, code, trans);
d196 1
a196 1
		tmpl = mopGetLong(pkt, &index);	/* Memory Address */
a199 1
#ifndef SHORT_PRINT
d210 1
a210 1
				fprintf(fd, "%02x ",  mopGetChar(pkt, &index));
a215 3
#else
			index = index + moplen - 5;
#endif
d221 1
a221 1
		tmpc = mopGetChar(pkt, &index);	/* Load Number */
d224 1
a224 1
		tmpc = mopGetChar(pkt, &index);	/* Parameter Type */
d226 1
a226 1
			c = mopGetChar(pkt, &index);	/* Parameter Length */
d232 1
a232 1
					    mopGetChar(pkt, &index));
d239 1
a239 1
					    mopGetChar(pkt, &index));
d246 1
a246 1
					    mopGetChar(pkt, &index));
d253 1
a253 1
					    mopGetChar(pkt, &index));
d257 1
a257 1
				ucp = pkt + index; index = index + 10;
d265 1
a265 1
			tmpc = mopGetChar(pkt, &index);	/* Parameter Type */
d268 2
a269 2
		tmpl = mopGetLong(pkt, &index);	/* Transfer Address */
		(void)fprintf(fd, "Transfer Addr: %08lx\n", tmpl);
a275 2


@


1.5
log
@4000 lines worth of cleanup, KNF, Knall&Rauch elemination and such
tested by hshoexer, "don't wait for me" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c, v 1.4 2003/12/01 00:56:51 avsm Exp $ */
d29 1
a29 1
    "$OpenBSD: dl.c, v 1.4 2003/12/01 00:56:51 avsm Exp $";
d241 1
a241 1
				fprintf(fd, "Target Name  :   %02x '", tmpc);
d255 1
a255 1
				fprintf(fd, "Host Name    :   %02x '", tmpc);
@


1.4
log
@-Wall cleanup: trim unused vars, right format strings, constify rcsids,
braces where needed, add missing prototypes.

tested and ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.3 2003/06/02 21:38:39 maja Exp $ */
d18 1
a18 1
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
d20 1
a20 1
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
d28 2
a29 1
static const char rcsid[] = "$OpenBSD: dl.c,v 1.3 2003/06/02 21:38:39 maja Exp $";
d38 1
a38 4
mopDumpDL(fd, pkt, trans)
	FILE	*fd;
	u_char 	*pkt;
	int	 trans;
d40 1
a40 1
	int	i,index = 0;
d42 2
a43 2
	u_char	tmpc,c,program[17],code,*ucp;
	u_short	len,tmps,moplen;
d56 2
a57 2
	code = mopGetChar(pkt,&index);
	
d60 3
a62 4
		
		tmpc = mopGetChar(pkt,&index);	/* Load Number */
		(void)fprintf(fd,"Load Number  :   %02x\n",tmpc);
		
d64 2
a65 2
			tmpl = mopGetLong(pkt,&index);/* Load Address */
			(void)fprintf(fd,"Load Address : %08lx\n",tmpl);
d67 1
a67 1
		
d72 7
a78 8
					if ((i / 16) == 0) {
					 	(void)fprintf(fd,
						       "Image Data   : %04x ",
							      moplen-10);
					} else {
						(void)fprintf(fd,
						       "                    ");
				        }
d80 2
a81 3
				
				(void)fprintf(fd, "%02x ",
					      mopGetChar(pkt,&index));
d83 1
a83 1
					(void)fprintf(fd,"\n");
d85 1
a85 1
			
d87 1
a87 1
				(void)fprintf(fd,"\n");
d92 3
a94 4
		
		tmpl = mopGetLong(pkt,&index);	/* Load Address */
		(void)fprintf(fd,"Xfer Address : %08lx\n",tmpl);
		
a96 1

a97 1

d100 6
a105 7
		
		tmpc = mopGetChar(pkt,&index);	/* Load Number */
		(void)fprintf(fd,"Load Number  :   %02x\n",tmpc);
		
		tmpl = mopGetLong(pkt,&index);	/* Load Address */
		(void)fprintf(fd,"Load Address : %08lx\n",tmpl);
		
d109 10
a118 12
				if ((i % 16) == 0) {
					if ((i / 16) == 0) {
						(void)fprintf(fd,
						       "Image Data   : %04x ",
							      moplen-6);
					} else {
						(void)fprintf(fd,
						       "                    ");
					}
				}
				(void)fprintf(fd,"%02x ",
					      mopGetChar(pkt,&index));
d120 1
a120 1
					(void)fprintf(fd,"\n");
d124 1
a124 1
				(void)fprintf(fd,"\n");
a128 1
		
a130 1
		
a131 1
		
d134 4
a137 7

		tmpl = mopGetLong(pkt,&index);	/* Memory Address */
		(void)fprintf(fd,"Mem Address  : %08lx\n",tmpl);
		
		tmps = mopGetShort(pkt,&index);	/* Count */
		(void)fprintf(fd,"Count        : %04x (%d)\n",tmps,tmps);
		
d140 13
a152 12
		
		tmpc = mopGetChar(pkt,&index);	/* Device Type */
		(void)fprintf(fd, "Device Type  :   %02x ",tmpc);
		mopPrintDevice(fd, tmpc); (void)fprintf(fd, "\n");
		
		tmpc = mopGetChar(pkt,&index);	/* Format Version */
		(void)fprintf(fd,"Format       :   %02x\n",tmpc);
		
		tmpc = mopGetChar(pkt,&index);	/* Program Type */
		(void)fprintf(fd,"Program Type :   %02x ",tmpc);
		mopPrintPGTY(fd, tmpc); (void)fprintf(fd, "\n");
		
d154 1
a154 1
		tmpc = mopGetChar(pkt,&index);	/* Software ID Len */
d156 2
a157 2
			program[i] = mopGetChar(pkt,&index);
			program[i+1] = '\0';
d159 8
a166 7
		
		(void)fprintf(fd,"Software     :   %02x '%s'\n",tmpc,program);
		
		tmpc = mopGetChar(pkt,&index);	/* Processor */
		(void)fprintf(fd,"Processor    :   %02x ",tmpc);
		mopPrintBPTY(fd, tmpc); (void)fprintf(fd, "\n");
		
d168 1
a168 1
		
d171 11
a181 12
		
		tmpc = mopGetChar(pkt,&index);	/* Load Number */
		(void)fprintf(fd,"Load Number  :   %02x\n",tmpc);
		
		tmpc = mopGetChar(pkt,&index);	/* Error */
		(void)fprintf(fd,"Error        :   %02x (",tmpc);
		if ((tmpc == 0)) {
			(void)fprintf(fd,"no error)\n");
		} else {
		  	(void)fprintf(fd,"error)\n");
		}
		
d184 15
a198 14
		
		tmpc = mopGetChar(pkt,&index);	/* Device Type */
		(void)fprintf(fd, "Device Type  :   %02x ",tmpc);
		mopPrintDevice(fd, tmpc); (void)fprintf(fd, "\n");
		
		tmpc = mopGetChar(pkt,&index);	/* Format Version */
		(void)fprintf(fd,"Format       :   %02x\n",tmpc);
		
		tmpl = mopGetLong(pkt,&index);	/* Memory Size */
		(void)fprintf(fd,"Memory Size  : %08lx\n",tmpl);
		
		tmpc = mopGetChar(pkt,&index);	/* Bits */
		(void)fprintf(fd,"Bits         :   %02x\n",tmpc);
		
d200 1
a200 1
		
d203 4
a206 4
		
		tmpl = mopGetLong(pkt,&index);	/* Memory Address */
		(void)fprintf(fd,"Mem Address  : %08lx\n",tmpl);
		
d211 7
a217 8
					if ((i / 16) == 0) {
						(void)fprintf(fd,
						       "Image Data   : %04x ",
							      moplen-5);
					} else {
						(void)fprintf(fd,
						       "                    ");
				        }
d219 1
a219 2
				(void)fprintf(fd,"%02x ",
					      mopGetChar(pkt,&index));
d221 1
a221 1
					(void)fprintf(fd,"\n");
d224 1
a224 1
				(void)fprintf(fd,"\n");
d229 1
a229 1
		
d232 5
a236 5
		
		tmpc = mopGetChar(pkt,&index);	/* Load Number */
		(void)fprintf(fd,"Load Number  :   %02x\n",tmpc);
		
		tmpc = mopGetChar(pkt,&index);	/* Parameter Type */
d238 2
a239 2
			c = mopGetChar(pkt,&index);	/* Parameter Length */
			switch(tmpc) {
d241 5
a245 7
				(void)fprintf(fd,"Target Name  :   %02x '",
					      tmpc);
				for (i = 0; i < ((int) c); i++) {
					(void)fprintf(fd,"%c",
						    mopGetChar(pkt,&index));
				}
				(void)fprintf(fd,"'\n");
d248 5
a252 6
				(void)fprintf(fd,"Target Addr  :   %02x ",c);
				for (i = 0; i < ((int) c); i++) {
					(void)fprintf(fd,"%02x ",
						    mopGetChar(pkt,&index));
				}
				(void)fprintf(fd,"\n");
d255 5
a259 7
				(void)fprintf(fd,"Host Name    :   %02x '",
					      tmpc);
				for (i = 0; i < ((int) c); i++) {
					(void)fprintf(fd,"%c",
						    mopGetChar(pkt,&index));
				}
				(void)fprintf(fd,"'\n");
d262 5
a266 6
				(void)fprintf(fd,"Host Addr    :   %02x ",c);
				for (i = 0; i < ((int) c); i++) {
					(void)fprintf(fd,"%02x ",
						    mopGetChar(pkt,&index));
				}
				(void)fprintf(fd,"\n");
d270 1
a270 1
				(void)fprintf(fd,"Host Time    : ");
d272 1
a272 1
				(void)fprintf(fd,"\n");
d277 1
a277 1
			tmpc = mopGetChar(pkt,&index);/* Parameter Type */
d279 4
a282 4
		
		tmpl = mopGetLong(pkt,&index);	/* Transfer Address */
		(void)fprintf(fd,"Transfer Addr: %08lx\n",tmpl);
		
@


1.3
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: dl.c,v 1.2 1996/09/21 19:11:26 maja Exp $ */
d28 1
a28 1
static char rcsid[] = "$OpenBSD: dl.c,v 1.2 1996/09/21 19:11:26 maja Exp $";
d68 1
a68 1
			(void)fprintf(fd,"Load Address : %08x\n",tmpl);
d99 1
a99 1
		(void)fprintf(fd,"Xfer Address : %08x\n",tmpl);
d113 1
a113 1
		(void)fprintf(fd,"Load Address : %08x\n",tmpl);
d150 1
a150 1
		(void)fprintf(fd,"Mem Address  : %08x\n",tmpl);
d209 1
a209 1
		(void)fprintf(fd,"Memory Size  : %08x\n",tmpl);
d220 1
a220 1
		(void)fprintf(fd,"Mem Address  : %08x\n",tmpl);
d304 1
a304 1
		(void)fprintf(fd,"Transfer Addr: %08x\n",tmpl);
@


1.2
log
@Replace $Id with $OpenBSD, 3:rd try. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d28 1
a28 1
static char rcsid[] = "$OpenBSD: dl.c,v 1.1.1.1 1996/09/21 13:49:16 maja Exp $";
@


1.1
log
@Initial revision
@
text
@d1 2
d33 1
a33 1
static char rcsid[] = "$Id: dl.c,v 1.7 1996/08/05 07:37:53 moj Exp $";
@


1.1.1.1
log
@Initial import of mopd-2.5.3. -moj
@
text
@@
