head	1.18;
access;
symbols
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.8
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.4
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.12
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.10
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.16
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.12
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.10
	OPENBSD_2_8:1.3.0.8
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	MOPD254:1.3
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	MOPD253:1.1.1.1
	MAJA:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2017.01.21.08.33.51;	author krw;	state Exp;
branches;
next	1.17;
commitid	xpTSTOgSQRGS1RiF;

1.17
date	2014.12.13.14.44.59;	author miod;	state Exp;
branches;
next	1.16;
commitid	KfI83DTUbjunQXXj;

1.16
date	2014.11.30.13.47.42;	author miod;	state Exp;
branches;
next	1.15;
commitid	f4fuAdlPzO19rknL;

1.15
date	2013.10.17.08.02.21;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2013.07.05.21.02.07;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.27.23.59.52;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.11.05.18.38;	author maja;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.29.16.26.56;	author maja;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.20.08.52.52;	author maja;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.17.16.23.01;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.14.20.37.28;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.01.00.56.51;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.21.38.39;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.07.07.58.21;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.12.12.03.03;	author heko;	state Exp;
branches;
next	1.3;

1.3
date	99.03.27.14.31.21;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	96.09.21.19.11.31;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.13.49.16;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.13.49.16;	author maja;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: file.c,v 1.17 2014/12/13 14:44:59 miod Exp $ */

/*
 * Copyright (c) 1995-96 Mats O Jansson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "os.h"
#include "common.h"
#include "file.h"
#include "mopdef.h"
#include <stddef.h>

#ifndef NOAOUT
#if defined(__OpenBSD__)
#include <sys/exec.h>
#endif
#if defined(__bsdi__)
#define NOAOUT
#endif
#if defined(__FreeBSD__)
#include <sys/imgact_aout.h>
#endif
#if !defined(MID_I386)
#define MID_I386 134
#endif
#if !defined(MID_SPARC)
#define MID_SPARC 138
#endif
#if !defined(MID_VAX)
#define MID_VAX 140
#endif
#endif

#ifndef NOELF
#if defined(__OpenBSD__)
#include <sys/exec_elf.h>
#else
#define NOELF
#endif
#endif

#ifndef NOELF
#if !defined(_LP64)
#define NOELF64
#endif
#endif

#ifndef NOAOUT
static int	getCLBYTES(int);
static int	getMID(int, int);
#endif

const char *
FileTypeName(mopd_imagetype type)
{

	switch (type) {
	case IMAGE_TYPE_MOP:
		return ("MOP");

	case IMAGE_TYPE_ELF32:
		return ("Elf32");

	case IMAGE_TYPE_ELF64:
		return ("Elf64");

	case IMAGE_TYPE_AOUT:
		return ("a.out");
	}

	abort();
}

void
mopFilePutLX(u_char *buf, int idx, u_int32_t value, int cnt)
{
	int i;
	for (i = 0; i < cnt; i++) {
		buf[idx+i] = value % 256;
		value = value / 256;
	}
}

void
mopFilePutBX(u_char *buf, int idx, u_int32_t value, int cnt)
{
	int i;
	for (i = 0; i < cnt; i++) {
		buf[idx+cnt-1-i] = value % 256;
		value = value / 256;
	}
}

u_int32_t
mopFileGetLX(u_char *buf, int idx, int cnt)
{
	u_int32_t ret = 0;
	int i;

	for (i = 0; i < cnt; i++) {
		int j = idx + cnt - 1 - i;
		if (j < 0)
			abort();
		ret = ret * 256 + buf[j];
	}

	return(ret);
}

u_int32_t
mopFileGetBX(u_char *buf, int idx, int cnt)
{
	u_int32_t ret = 0;
	int i;

	for (i = 0; i < cnt; i++) {
		int j = idx + i;
		if (j < 0)
			abort();
		ret = ret * 256 + buf[j];
	}

	return(ret);
}

#if !defined(NOELF) && !defined(NOELF64)
u_int64_t
mopFileGetLXX(u_char *buf, int idx, int cnt)
{
	u_int64_t ret = 0;
	int i;

	for (i = 0; i < cnt; i++) {
		int j = idx + cnt - 1 - i;
		if (j < 0)
			abort();
		ret = ret * 256 + buf[j];
	}

	return(ret);
}

u_int64_t
mopFileGetBXX(u_char *buf, int idx, int cnt)
{
	u_int64_t ret = 0;
	int i;

	for (i = 0; i < cnt; i++) {
		int j = idx + i;
		if (j < 0)
			abort();
		ret = ret * 256 + buf[j];
	}

	return(ret);
}
#endif

void
mopFileSwapX(u_char *buf, int idx, int cnt)
{
	int i;
	u_char c;

	for (i = 0; i < (cnt / 2); i++) {
		c = buf[idx+i];
		buf[idx+i] = buf[idx+cnt-1-i];
		buf[idx+cnt-1-i] = c;
	}

}

int
CheckMopFile(int fd)
{
	u_char	header[512];
	short	image_type;

	if (read(fd, header, 512) != 512)
		return(-1);

	(void)lseek(fd, (off_t) 0, SEEK_SET);

	image_type = (u_short)(header[IHD_W_ALIAS+1]*256 + header[IHD_W_ALIAS]);

	switch(image_type) {
	case IHD_C_NATIVE:		/* Native mode image (VAX)   */
	case IHD_C_RSX:			/* RSX image produced by TKB */
	case IHD_C_BPA:			/* BASIC plus analog         */
	case IHD_C_ALIAS:		/* Alias		     */
	case IHD_C_CLI:			/* Image is CLI		     */
	case IHD_C_PMAX:		/* PMAX system image	     */
	case IHD_C_ALPHA:		/* ALPHA system image	     */
		break;
	default:
		return(-1);
	}

	return(0);
}

int
GetMopFileInfo(struct dllist *dl, int info)
{
	u_char		header[512];
	short		image_type;
	u_int32_t	load_addr, xfr_addr, isd, iha, hbcnt, isize;

	if (read(dl->ldfd, header, 512) != 512)
		return(-1);

	image_type = (u_short)(header[IHD_W_ALIAS+1]*256 +
			       header[IHD_W_ALIAS]);

	switch (image_type) {
	case IHD_C_NATIVE:		/* Native mode image (VAX)   */
		isd = (header[IHD_W_SIZE+1]*256 +
		       header[IHD_W_SIZE]);
		iha = (header[IHD_W_ACTIVOFF+1]*256 +
		       header[IHD_W_ACTIVOFF]);
		hbcnt = (header[IHD_B_HDRBLKCNT]);
		isize = (header[isd+ISD_W_PAGCNT+1]*256 +
			 header[isd+ISD_W_PAGCNT]) * 512;
		load_addr = ((header[isd+ISD_V_VPN+1]*256 +
			      header[isd+ISD_V_VPN]) & ISD_M_VPN)
				* 512;
		xfr_addr = (header[iha+IHA_L_TFRADR1+3]*0x1000000 +
			    header[iha+IHA_L_TFRADR1+2]*0x10000 +
			    header[iha+IHA_L_TFRADR1+1]*0x100 +
			    header[iha+IHA_L_TFRADR1]) & 0x7fffffff;
		if (info == INFO_PRINT) {
			printf("Native Image (VAX)\n");
			printf("Header Block Count: %d\n",hbcnt);
			printf("Image Size:         %08x\n",isize);
			printf("Load Address:       %08x\n",load_addr);
			printf("Transfer Address:   %08x\n",xfr_addr);
		}
		break;
	case IHD_C_RSX:			/* RSX image produced by TKB */
		hbcnt = header[L_BBLK+1]*256 + header[L_BBLK];
		isize = (header[L_BLDZ+1]*256 + header[L_BLDZ]) * 64;
		load_addr = header[L_BSA+1]*256 + header[L_BSA];
		xfr_addr  = header[L_BXFR+1]*256 + header[L_BXFR];
		if (info == INFO_PRINT) {
			printf("RSX Image\n");
			printf("Header Block Count: %d\n",hbcnt);
			printf("Image Size:         %08x\n",isize);
			printf("Load Address:       %08x\n",load_addr);
			printf("Transfer Address:   %08x\n",xfr_addr);
		}
		break;
	case IHD_C_BPA:			/* BASIC plus analog         */
		if (info == INFO_PRINT) {
			printf("BASIC-Plus Image, not supported\n");
		}
		return(-1);
		break;
	case IHD_C_ALIAS:		/* Alias		     */
		if (info == INFO_PRINT) {
			printf("Alias, not supported\n");
		}
		return(-1);
		break;
	case IHD_C_CLI:			/* Image is CLI		     */
		if (info == INFO_PRINT) {
			printf("CLI, not supported\n");
		}
		return(-1);
		break;
	case IHD_C_PMAX:		/* PMAX system image	     */
		isd = (header[IHD_W_SIZE+1]*256 +
		       header[IHD_W_SIZE]);
		iha = (header[IHD_W_ACTIVOFF+1]*256 +
		       header[IHD_W_ACTIVOFF]);
		hbcnt = (header[IHD_B_HDRBLKCNT]);
		isize = (header[isd+ISD_W_PAGCNT+1]*256 +
			 header[isd+ISD_W_PAGCNT]) * 512;
		load_addr = (header[isd+ISD_V_VPN+1]*256 +
			     header[isd+ISD_V_VPN]) * 512;
		xfr_addr = (header[iha+IHA_L_TFRADR1+3]*0x1000000 +
			    header[iha+IHA_L_TFRADR1+2]*0x10000 +
			    header[iha+IHA_L_TFRADR1+1]*0x100 +
			    header[iha+IHA_L_TFRADR1]);
		if (info == INFO_PRINT) {
			printf("PMAX Image \n");
			printf("Header Block Count: %d\n",hbcnt);
			printf("Image Size:         %08x\n",isize);
			printf("Load Address:       %08x\n",load_addr);
			printf("Transfer Address:   %08x\n",xfr_addr);
		}
		break;
	case IHD_C_ALPHA:		/* ALPHA system image	     */
		isd = (header[EIHD_L_ISDOFF+3]*0x1000000 +
		       header[EIHD_L_ISDOFF+2]*0x10000 +
		       header[EIHD_L_ISDOFF+1]*0x100 +
		       header[EIHD_L_ISDOFF]);
		hbcnt = (header[EIHD_L_HDRBLKCNT+3]*0x1000000 +
			 header[EIHD_L_HDRBLKCNT+2]*0x10000 +
			 header[EIHD_L_HDRBLKCNT+1]*0x100 +
			 header[EIHD_L_HDRBLKCNT]);
		isize = (header[isd+EISD_L_SECSIZE+3]*0x1000000 +
			 header[isd+EISD_L_SECSIZE+2]*0x10000 +
			 header[isd+EISD_L_SECSIZE+1]*0x100 +
			 header[isd+EISD_L_SECSIZE]);
		load_addr = 0;
		xfr_addr = 0;
		if (info == INFO_PRINT) {
			printf("Alpha Image \n");
			printf("Header Block Count: %d\n",hbcnt);
			printf("Image Size:         %08x\n",isize);
			printf("Load Address:       %08x\n",load_addr);
			printf("Transfer Address:   %08x\n",xfr_addr);
		}
		break;
	default:
		if (info == INFO_PRINT) {
			printf("Unknown Image (%d)\n",image_type);
		}
		return(-1);
	}

	dl->image_type = IMAGE_TYPE_MOP;
	dl->loadaddr = load_addr;
	dl->xferaddr = xfr_addr;

	return(0);
}

#ifndef NOAOUT
static int
getMID(int old_mid, int new_mid)
{
	int	mid;

	mid = old_mid;

	switch (new_mid) {
	case MID_I386:
		mid = MID_I386;
		break;
#ifdef MID_M68K
	case MID_M68K:
		mid = MID_M68K;
		break;
#endif
#ifdef MID_M68K4K
	case MID_M68K4K:
		mid = MID_M68K4K;
		break;
#endif
#ifdef MID_NS32532
	case MID_NS32532:
		mid = MID_NS32532;
		break;
#endif
	case MID_SPARC:
		mid = MID_SPARC;
		break;
#ifdef MID_PMAX
	case MID_PMAX:
		mid = MID_PMAX;
		break;
#endif
#ifdef MID_VAX
	case MID_VAX:
		mid = MID_VAX;
		break;
#endif
#ifdef MID_ALPHA
	case MID_ALPHA:
		mid = MID_ALPHA;
		break;
#endif
#ifdef MID_MIPS
	case MID_MIPS:
		mid = MID_MIPS;
		break;
#endif
#ifdef MID_ARM6
	case MID_ARM6:
		mid = MID_ARM6;
		break;
#endif
	default:
		break;
	}

	return(mid);
}

static int
getCLBYTES(int mid)
{
	int	clbytes;

	switch (mid) {
#ifdef MID_VAX
	case MID_VAX:
		clbytes = 1024;
		break;
#endif
#ifdef MID_I386
	case MID_I386:
#endif
#ifdef MID_M68K4K
	case MID_M68K4K:
#endif
#ifdef MID_NS32532
	case MID_NS32532:
#endif
#ifdef MID_PMAX
	case MID_PMAX:
#endif
#ifdef MID_MIPS
	case MID_MIPS:
#endif
#ifdef MID_ARM6
	case MID_ARM6:
#endif
#if defined(MID_I386) || defined(MID_M68K4K) || defined(MID_NS32532) || \
    defined(MID_PMAX) || defined(MID_MIPS) || defined(MID_ARM6)
		clbytes = 4096;
		break;
#endif
#ifdef MID_M68K
	case MID_M68K:
#endif
#ifdef MID_ALPHA
	case MID_ALPHA:
#endif
#ifdef MID_SPARC
	case MID_SPARC:
#endif
#if defined(MID_M68K) || defined(MID_ALPHA) || defined(MID_SPARC)
		clbytes = 8192;
		break;
#endif
	default:
		clbytes = 0;
	}

	return(clbytes);
}
#endif

int
CheckElfFile(int fd)
{
#ifdef NOELF
	return(-1);
#else
	Elf32_Ehdr ehdr;

	(void)lseek(fd, (off_t) 0, SEEK_SET);

	if (read(fd, (char *)&ehdr, sizeof(ehdr)) != sizeof(ehdr))
		return(-1);

	if (ehdr.e_ident[0] != ELFMAG0 ||
	    ehdr.e_ident[1] != ELFMAG1 ||
	    ehdr.e_ident[2] != ELFMAG2 ||
	    ehdr.e_ident[3] != ELFMAG3)
		return(-1);

	/* Must be Elf32 or Elf64... */
	if (ehdr.e_ident[EI_CLASS] != ELFCLASS32 &&
	    ehdr.e_ident[EI_CLASS] != ELFCLASS64)
		return(-1);

	return(0);
#endif /* NOELF */
}

int
GetElf32FileInfo(struct dllist *dl, int info)
{
#ifdef NOELF
	return(-1);
#else
	Elf32_Ehdr ehdr;
	Elf32_Phdr phdr;
	uint32_t e_machine, e_entry;
	uint32_t e_phoff, e_phentsize, e_phnum;
	int ei_data, i;

	(void)lseek(dl->ldfd, (off_t) 0, SEEK_SET);

	if (read(dl->ldfd, (char *)&ehdr, sizeof(ehdr)) != sizeof(ehdr))
		return(-1);

	if (ehdr.e_ident[0] != ELFMAG0 ||
	    ehdr.e_ident[1] != ELFMAG1 ||
	    ehdr.e_ident[2] != ELFMAG2 ||
	    ehdr.e_ident[3] != ELFMAG3)
		return(-1);

	/* Must be Elf32... */
	if (ehdr.e_ident[EI_CLASS] != ELFCLASS32)
		return(-1);

	ei_data = ehdr.e_ident[EI_DATA];

	switch (ei_data) {
	case ELFDATA2LSB:
		e_machine = mopFileGetLX((u_char *) &ehdr,
		    offsetof(Elf32_Ehdr, e_machine),
		    sizeof(ehdr.e_machine));
		e_entry = mopFileGetLX((u_char *) &ehdr,
		    offsetof(Elf32_Ehdr, e_entry),
		    sizeof(ehdr.e_entry));

		e_phoff = mopFileGetLX((u_char *) &ehdr,
		    offsetof(Elf32_Ehdr, e_phoff),
		    sizeof(ehdr.e_phoff));
		e_phentsize = mopFileGetLX((u_char *) &ehdr,
		    offsetof(Elf32_Ehdr, e_phentsize),
		    sizeof(ehdr.e_phentsize));
		e_phnum = mopFileGetLX((u_char *) &ehdr,
		    offsetof(Elf32_Ehdr, e_phnum),
		    sizeof(ehdr.e_phnum));
		break;

	case ELFDATA2MSB:
		e_machine = mopFileGetBX((u_char *) &ehdr,
		    offsetof(Elf32_Ehdr, e_machine),
		    sizeof(ehdr.e_machine));
		e_entry = mopFileGetBX((u_char *) &ehdr,
		    offsetof(Elf32_Ehdr, e_entry),
		    sizeof(ehdr.e_entry));

		e_phoff = mopFileGetBX((u_char *) &ehdr,
		    offsetof(Elf32_Ehdr, e_phoff),
		    sizeof(ehdr.e_phoff));
		e_phentsize = mopFileGetBX((u_char *) &ehdr,
		    offsetof(Elf32_Ehdr, e_phentsize),
		    sizeof(ehdr.e_phentsize));
		e_phnum = mopFileGetBX((u_char *) &ehdr,
		    offsetof(Elf32_Ehdr, e_phnum),
		    sizeof(ehdr.e_phnum));
		break;

	default:
		return(-1);
	}

	if (e_phnum > SEC_MAX)
		return(-1);
	dl->e_nsec = e_phnum;
	for (i = 0; i < dl->e_nsec; i++) {
		if (lseek(dl->ldfd, (off_t) e_phoff + (i * e_phentsize),
		    SEEK_SET) == (off_t) -1)
			return(-1);
		if (read(dl->ldfd, (char *) &phdr, sizeof(phdr)) !=
		    sizeof(phdr))
			return(-1);

		switch (ei_data) {
		case ELFDATA2LSB:
			dl->e_sections[i].s_foff =
			    mopFileGetLX((u_char *) &phdr,
			    offsetof(Elf32_Phdr, p_offset),
			    sizeof(phdr.p_offset));
			dl->e_sections[i].s_vaddr =
			    mopFileGetLX((u_char *) &phdr,
			    offsetof(Elf32_Phdr, p_vaddr),
			    sizeof(phdr.p_vaddr));
			dl->e_sections[i].s_fsize =
			    mopFileGetLX((u_char *) &phdr,
			    offsetof(Elf32_Phdr, p_filesz),
			    sizeof(phdr.p_filesz));
			dl->e_sections[i].s_msize =
			    mopFileGetLX((u_char *) &phdr,
			    offsetof(Elf32_Phdr, p_memsz),
			    sizeof(phdr.p_memsz));
			break;

		case ELFDATA2MSB:
			dl->e_sections[i].s_foff =
			    mopFileGetBX((u_char *) &phdr,
			    offsetof(Elf32_Phdr, p_offset),
			    sizeof(phdr.p_offset));
			dl->e_sections[i].s_vaddr =
			    mopFileGetBX((u_char *) &phdr,
			    offsetof(Elf32_Phdr, p_vaddr),
			    sizeof(phdr.p_vaddr));
			dl->e_sections[i].s_fsize =
			    mopFileGetBX((u_char *) &phdr,
			    offsetof(Elf32_Phdr, p_filesz),
			    sizeof(phdr.p_filesz));
			dl->e_sections[i].s_msize =
			    mopFileGetBX((u_char *) &phdr,
			    offsetof(Elf32_Phdr, p_memsz),
			    sizeof(phdr.p_memsz));
			break;

		default:
			return(-1);
		}
	}
	/*
	 * In addition to padding between segments, this also
	 * takes care of memsz > filesz.
	 */
	for (i = 0; i < dl->e_nsec - 1; i++) {
		dl->e_sections[i].s_pad =
		    dl->e_sections[i + 1].s_vaddr -
		    (dl->e_sections[i].s_vaddr + dl->e_sections[i].s_fsize);
	}
	dl->e_sections[dl->e_nsec - 1].s_pad =
	    dl->e_sections[dl->e_nsec - 1].s_msize -
	    dl->e_sections[dl->e_nsec - 1].s_fsize;
	/*
	 * Now compute the logical offsets for each section.
	 */
	dl->e_sections[0].s_loff = 0;
	for (i = 1; i < dl->e_nsec; i++) {
		dl->e_sections[i].s_loff =
		    dl->e_sections[i - 1].s_loff +
		    dl->e_sections[i - 1].s_fsize +
		    dl->e_sections[i - 1].s_pad;
	}

	dl->image_type = IMAGE_TYPE_ELF32;
	dl->loadaddr = 0;
#if 0
	dl->xferaddr = e_entry;		/* will relocate itself if necessary */
#else
	dl->xferaddr = e_entry - dl->e_sections[0].s_vaddr;
#endif

	/* Print info about the image. */
	if (info == INFO_PRINT) {
		printf("Elf32 image (");
		switch (e_machine) {
#ifdef EM_VAX
		case EM_VAX:
			printf("VAX");
			break;
#endif
		default:
			printf("machine %d", e_machine);
			break;
		}
		printf(")\n");
		printf("Transfer Address:   %08x\n", dl->xferaddr);
		printf("Program Sections:   %d\n", dl->e_nsec);
		for (i = 0; i < dl->e_nsec; i++) {
			printf(" S%d File Size:      %08x\n", i,
			    dl->e_sections[i].s_fsize);
			printf(" S%d Pad Size:       %08x\n", i,
			    dl->e_sections[i].s_pad);
		}
	}

	dl->e_machine = e_machine;

	dl->e_curpos = 0;
	dl->e_cursec = 0;

	return(0);
#endif /* NOELF */
}

int
GetElf64FileInfo(struct dllist *dl, int info)
{
#if defined(NOELF) || defined(NOELF64)
	return(-1);
#else
	Elf64_Ehdr ehdr;
	Elf64_Phdr phdr;
	uint32_t e_machine;
	uint32_t e_phentsize, e_phnum;
	uint64_t e_entry, e_phoff;
	int ei_data, i;

	(void)lseek(dl->ldfd, (off_t) 0, SEEK_SET);

	if (read(dl->ldfd, (char *)&ehdr, sizeof(ehdr)) != sizeof(ehdr))
		return(-1);

	if (ehdr.e_ident[0] != ELFMAG0 ||
	    ehdr.e_ident[1] != ELFMAG1 ||
	    ehdr.e_ident[2] != ELFMAG2 ||
	    ehdr.e_ident[3] != ELFMAG3)
		return(-1);

	/* Must be Elf64... */
	if (ehdr.e_ident[EI_CLASS] != ELFCLASS64)
		return(-1);

	ei_data = ehdr.e_ident[EI_DATA];

	switch (ei_data) {
	case ELFDATA2LSB:
		e_machine = mopFileGetLX((u_char *) &ehdr,
		    offsetof(Elf64_Ehdr, e_machine),
		    sizeof(ehdr.e_machine));
		e_entry = mopFileGetLXX((u_char *) &ehdr,
		    offsetof(Elf64_Ehdr, e_entry),
		    sizeof(ehdr.e_entry));

		e_phoff = mopFileGetLXX((u_char *) &ehdr,
		    offsetof(Elf64_Ehdr, e_phoff),
		    sizeof(ehdr.e_phoff));
		e_phentsize = mopFileGetLX((u_char *) &ehdr,
		    offsetof(Elf64_Ehdr, e_phentsize),
		    sizeof(ehdr.e_phentsize));
		e_phnum = mopFileGetLX((u_char *) &ehdr,
		    offsetof(Elf64_Ehdr, e_phnum),
		    sizeof(ehdr.e_phnum));
		break;

	case ELFDATA2MSB:
		e_machine = mopFileGetBX((u_char *) &ehdr,
		    offsetof(Elf64_Ehdr, e_machine),
		    sizeof(ehdr.e_machine));
		e_entry = mopFileGetBXX((u_char *) &ehdr,
		    offsetof(Elf64_Ehdr, e_entry),
		    sizeof(ehdr.e_entry));

		e_phoff = mopFileGetBXX((u_char *) &ehdr,
		    offsetof(Elf64_Ehdr, e_phoff),
		    sizeof(ehdr.e_phoff));
		e_phentsize = mopFileGetBX((u_char *) &ehdr,
		    offsetof(Elf64_Ehdr, e_phentsize),
		    sizeof(ehdr.e_phentsize));
		e_phnum = mopFileGetBX((u_char *) &ehdr,
		    offsetof(Elf64_Ehdr, e_phnum),
		    sizeof(ehdr.e_phnum));
		break;

	default:
		return(-1);
	}

	if (e_phnum > SEC_MAX)
		return(-1);
	dl->e_nsec = e_phnum;
	for (i = 0; i < dl->e_nsec; i++) {
		if (lseek(dl->ldfd, (off_t) e_phoff + (i * e_phentsize),
		    SEEK_SET) == (off_t) -1)
			return(-1);
		if (read(dl->ldfd, (char *) &phdr, sizeof(phdr)) !=
		    sizeof(phdr))
			return(-1);

		switch (ei_data) {
		case ELFDATA2LSB:
			dl->e_sections[i].s_foff =
			    mopFileGetLX((u_char *) &phdr,
			    offsetof(Elf64_Phdr, p_offset),
			    sizeof(phdr.p_offset));
			dl->e_sections[i].s_vaddr =
			    mopFileGetLX((u_char *) &phdr,
			    offsetof(Elf64_Phdr, p_vaddr),
			    sizeof(phdr.p_vaddr));
			dl->e_sections[i].s_fsize =
			    mopFileGetLX((u_char *) &phdr,
			    offsetof(Elf64_Phdr, p_filesz),
			    sizeof(phdr.p_filesz));
			dl->e_sections[i].s_msize =
			    mopFileGetLX((u_char *) &phdr,
			    offsetof(Elf64_Phdr, p_memsz),
			    sizeof(phdr.p_memsz));
			break;

		case ELFDATA2MSB:
			dl->e_sections[i].s_foff =
			    mopFileGetBX((u_char *) &phdr,
			    offsetof(Elf64_Phdr, p_offset),
			    sizeof(phdr.p_offset));
			dl->e_sections[i].s_vaddr =
			    mopFileGetBX((u_char *) &phdr,
			    offsetof(Elf64_Phdr, p_vaddr),
			    sizeof(phdr.p_vaddr));
			dl->e_sections[i].s_fsize =
			    mopFileGetBX((u_char *) &phdr,
			    offsetof(Elf64_Phdr, p_filesz),
			    sizeof(phdr.p_filesz));
			dl->e_sections[i].s_msize =
			    mopFileGetBX((u_char *) &phdr,
			    offsetof(Elf64_Phdr, p_memsz),
			    sizeof(phdr.p_memsz));
			break;

		default:
			return(-1);
		}
	}
	/*
	 * In addition to padding between segments, this also
	 * takes care of memsz > filesz.
	 */
	for (i = 0; i < dl->e_nsec - 1; i++) {
		dl->e_sections[i].s_pad =
		    dl->e_sections[i + 1].s_vaddr -
		    (dl->e_sections[i].s_vaddr + dl->e_sections[i].s_fsize);
	}
	dl->e_sections[dl->e_nsec - 1].s_pad =
	    dl->e_sections[dl->e_nsec - 1].s_msize -
	    dl->e_sections[dl->e_nsec - 1].s_fsize;
	/*
	 * Now compute the logical offsets for each section.
	 */
	dl->e_sections[0].s_loff = 0;
	for (i = 1; i < dl->e_nsec; i++) {
		dl->e_sections[i].s_loff =
		    dl->e_sections[i - 1].s_loff +
		    dl->e_sections[i - 1].s_fsize +
		    dl->e_sections[i - 1].s_pad;
	}

	dl->image_type = IMAGE_TYPE_ELF64;
	dl->loadaddr = 0;
#if 0
	dl->xferaddr = e_entry;		/* will relocate itself if necessary */
#else
	dl->xferaddr = e_entry - dl->e_sections[0].s_vaddr;
#endif

	/* Print info about the image. */
	if (info == INFO_PRINT) {
		printf("Elf64 image (");
		switch (e_machine) {
#ifdef EM_ALPHA
		case EM_ALPHA:
#endif
#ifdef EM_ALPHA_EXP
		case EM_ALPHA_EXP:
#endif
#if defined(EM_ALPHA) || defined(EM_ALPHA_EXP)
			printf("ALPHA");
			break;
#endif
		default:
			printf("machine %d", e_machine);
			break;
		}
		printf(")\n");
		printf("Transfer Address:   %08x\n", dl->xferaddr);
		printf("Program Sections:   %d\n", dl->e_nsec);
		for (i = 0; i < dl->e_nsec; i++) {
			printf(" S%d File Size:      %08x\n", i,
			    dl->e_sections[i].s_fsize);
			printf(" S%d Pad Size:       %08x\n", i,
			    dl->e_sections[i].s_pad);
		}
	}

	dl->e_machine = e_machine;

	dl->e_curpos = 0;
	dl->e_cursec = 0;

	return(0);
#endif /* NOELF || NOELF64 */
}

int
CheckAOutFile(int fd)
{
#ifdef NOAOUT
	return(-1);
#else
	struct exec ex, ex_swap;
	int	mid = -1;

	if (read(fd, (char *)&ex, sizeof(ex)) != sizeof(ex))
		return(-1);

	(void)lseek(fd, (off_t) 0, SEEK_SET);

	if (read(fd, (char *)&ex_swap, sizeof(ex_swap)) != sizeof(ex_swap))
		return(-1);

	(void)lseek(fd, (off_t) 0, SEEK_SET);

	mid = getMID(mid, N_GETMID (ex));

	if (mid == -1) {
		mid = getMID(mid, N_GETMID (ex_swap));
	}

	if (mid != -1) {
		return(0);
	} else {
		return(-1);
	}
#endif /* NOAOUT */
}

int
GetAOutFileInfo(struct dllist *dl, int info)
{
#ifdef NOAOUT
	return(-1);
#else
	struct exec ex, ex_swap;
	u_int32_t	mid = -1;
	u_int32_t	magic, clbytes, clofset;

	if (read(dl->ldfd, (char *)&ex, sizeof(ex)) != sizeof(ex))
		return(-1);

	(void)lseek(dl->ldfd, (off_t) 0, SEEK_SET);

	if (read(dl->ldfd, (char *)&ex_swap,
		 sizeof(ex_swap)) != sizeof(ex_swap))
		return(-1);

	mopFileSwapX((u_char *)&ex_swap, 0, 4);

	mid = getMID(mid, N_GETMID (ex));

	if (mid == (uint32_t)-1) {
		mid = getMID(mid, N_GETMID (ex_swap));
		if (mid != (uint32_t)-1) {
			mopFileSwapX((u_char *)&ex, 0, 4);
		}
	}

	if (mid == (uint32_t)-1) {
		return(-1);
	}

	if (N_BADMAG (ex)) {
		return(-1);
	}

	switch (mid) {
	case MID_I386:
#ifdef MID_NS32532
	case MID_NS32532:
#endif
#ifdef MID_PMAX
	case MID_PMAX:
#endif
#ifdef MID_VAX
	case MID_VAX:
#endif
#ifdef MID_ALPHA
	case MID_ALPHA:
#endif
#ifdef MID_ARM6
	case MID_ARM6:
#endif
		ex.a_text  = mopFileGetLX((u_char *)&ex_swap,  4, 4);
		ex.a_data  = mopFileGetLX((u_char *)&ex_swap,  8, 4);
		ex.a_bss   = mopFileGetLX((u_char *)&ex_swap, 12, 4);
		ex.a_syms  = mopFileGetLX((u_char *)&ex_swap, 16, 4);
		ex.a_entry = mopFileGetLX((u_char *)&ex_swap, 20, 4);
		ex.a_trsize= mopFileGetLX((u_char *)&ex_swap, 24, 4);
		ex.a_drsize= mopFileGetLX((u_char *)&ex_swap, 28, 4);
		break;
#ifdef MID_M68K
	case MID_M68K:
#endif
#ifdef MID_M68K4K
	case MID_M68K4K:
#endif
	case MID_SPARC:
#ifdef MID_MIPS
	case MID_MIPS:
#endif
		ex.a_text  = mopFileGetBX((u_char *)&ex_swap,  4, 4);
		ex.a_data  = mopFileGetBX((u_char *)&ex_swap,  8, 4);
		ex.a_bss   = mopFileGetBX((u_char *)&ex_swap, 12, 4);
		ex.a_syms  = mopFileGetBX((u_char *)&ex_swap, 16, 4);
		ex.a_entry = mopFileGetBX((u_char *)&ex_swap, 20, 4);
		ex.a_trsize= mopFileGetBX((u_char *)&ex_swap, 24, 4);
		ex.a_drsize= mopFileGetBX((u_char *)&ex_swap, 28, 4);
		break;
	default:
		break;
	}

	if (info == INFO_PRINT) {
		printf("a.out image (");
		switch (N_GETMID (ex)) {
		case MID_I386:
			printf("i386");
			break;
#ifdef MID_M68K
		case MID_M68K:
			printf("m68k");
			break;
#endif
#ifdef MID_M68K4K
		case MID_M68K4K:
			printf("m68k 4k");
			break;
#endif
#ifdef MID_NS32532
		case MID_NS32532:
			printf("pc532");
			break;
#endif
		case MID_SPARC:
			printf("sparc");
			break;
#ifdef MID_PMAX
		case MID_PMAX:
			printf("pmax");
			break;
#endif
#ifdef MID_VAX
		case MID_VAX:
			printf("vax");
			break;
#endif
#ifdef MID_ALPHA
		case MID_ALPHA:
			printf("alpha");
			break;
#endif
#ifdef MID_MIPS
		case MID_MIPS:
			printf("mips");
			break;
#endif
#ifdef MID_ARM6
		case MID_ARM6:
			printf("arm32");
			break;
#endif
		default:
			break;
		}
		printf(") Magic: ");
		switch (N_GETMAGIC (ex)) {
		case OMAGIC:
			printf("OMAGIC");
			break;
		case NMAGIC:
			printf("NMAGIC");
			break;
		case ZMAGIC:
			printf("ZMAGIC");
			break;
		case QMAGIC:
			printf("QMAGIC");
			break;
		default:
			printf("Unknown %ld", (long) N_GETMAGIC (ex));
		}
		printf("\n");
		printf("Size of text:       %08lx\n", (long)ex.a_text);
		printf("Size of data:       %08lx\n", (long)ex.a_data);
		printf("Size of bss:        %08lx\n", (long)ex.a_bss);
		printf("Size of symbol tab: %08lx\n", (long)ex.a_syms);
		printf("Transfer Address:   %08lx\n", (long)ex.a_entry);
		printf("Size of reloc text: %08lx\n", (long)ex.a_trsize);
		printf("Size of reloc data: %08lx\n", (long)ex.a_drsize);
	}

	magic = N_GETMAGIC (ex);
	clbytes = getCLBYTES(mid);
	clofset = clbytes - 1;

	dl->image_type = IMAGE_TYPE_AOUT;
	dl->loadaddr = 0;
	dl->xferaddr = ex.a_entry;

	dl->a_text = ex.a_text;
	if (magic == ZMAGIC || magic == NMAGIC) {
		dl->a_text_fill = clbytes - (ex.a_text & clofset);
		if (dl->a_text_fill == clbytes)
			dl->a_text_fill = 0;
	} else
		dl->a_text_fill = 0;
	dl->a_data = ex.a_data;
	if (magic == ZMAGIC || magic == NMAGIC) {
		dl->a_data_fill = clbytes - (ex.a_data & clofset);
		if (dl->a_data_fill == clbytes)
			dl->a_data_fill = 0;
	} else
		dl->a_data_fill = 0;
	dl->a_bss = ex.a_bss;
	if (magic == ZMAGIC || magic == NMAGIC) {
		dl->a_bss_fill = clbytes - (ex.a_bss & clofset);
		if (dl->a_bss_fill == clbytes)
			dl->a_bss_fill = 0;
	} else {
		dl->a_bss_fill = clbytes -
		    ((ex.a_text+ex.a_data+ex.a_bss) & clofset);
		if (dl->a_bss_fill == clbytes)
			dl->a_bss_fill = 0;
	}
	dl->a_mid = mid;

	return(0);
#endif /* NOAOUT */
}

int
GetFileInfo(struct dllist *dl, int info)
{
	int error;

	error = CheckElfFile(dl->ldfd);
	if (error == 0) {
		error = GetElf32FileInfo(dl, info);
		if (error != 0)
			error = GetElf64FileInfo(dl, info);
		if (error != 0) {
			return(-1);
		}
		return (0);
	}

	error = CheckAOutFile(dl->ldfd);
	if (error == 0) {
		error = GetAOutFileInfo(dl, info);
		if (error != 0) {
			return(-1);
		}
		return (0);
	}

	error = CheckMopFile(dl->ldfd);
	if (error == 0) {
		error = GetMopFileInfo(dl, info);
		if (error != 0) {
			return(-1);
		}
		return (0);
	}

	/* Unknown file format. */
	return(-1);
}

ssize_t
mopFileRead(struct dllist *dlslot, u_char *buf)
{
	ssize_t len, outlen;
	int	bsz, sec;
	int32_t	pos, notdone, total;
	uint32_t secoff;

	switch (dlslot->image_type) {
	case IMAGE_TYPE_MOP:
		len = read(dlslot->ldfd,buf,dlslot->dl_bsz);
		break;

	case IMAGE_TYPE_ELF32:
	case IMAGE_TYPE_ELF64:
		sec = dlslot->e_cursec;

		/*
		 * We're pretty simplistic here.  We do only file-backed
		 * or only zero-fill.
		 */

		/* Determine offset into section. */
		secoff = dlslot->e_curpos - dlslot->e_sections[sec].s_loff;

		/*
		 * If we're in the file-backed part of the section,
		 * transmit some of the file.
		 */
		if (secoff < dlslot->e_sections[sec].s_fsize) {
			bsz = dlslot->e_sections[sec].s_fsize - secoff;
			if (bsz > dlslot->dl_bsz)
				bsz = dlslot->dl_bsz;
			if (lseek(dlslot->ldfd,
			    dlslot->e_sections[sec].s_foff + secoff,
			    SEEK_SET) == (off_t) -1)
				return (-1);
			len = read(dlslot->ldfd, buf, bsz);
		}
		/*
		 * Otherwise, if we're in the zero-fill part of the
		 * section, transmit some zeros.
		 */
		else if (secoff < (dlslot->e_sections[sec].s_fsize +
				   dlslot->e_sections[sec].s_pad)) {
			bsz = dlslot->e_sections[sec].s_pad -
			    (secoff - dlslot->e_sections[sec].s_fsize);
			if (bsz > dlslot->dl_bsz)
				bsz = dlslot->dl_bsz;
			memset(buf, 0, (len = bsz));
		}
		/*
		 * ...and if we haven't hit either of those cases,
		 * that's the end of the image.
		 */
		else {
			return (0);
		}
		/*
		 * Advance the logical image pointer.
		 */
		dlslot->e_curpos += bsz;
		if (dlslot->e_curpos >= (dlslot->e_sections[sec].s_loff +
					 dlslot->e_sections[sec].s_fsize +
					 dlslot->e_sections[sec].s_pad))
			if (++sec != dlslot->e_nsec)
				dlslot->e_cursec = sec;
		break;

	case IMAGE_TYPE_AOUT:
		bsz = dlslot->dl_bsz;
		pos = dlslot->a_lseek;
		len = 0;

		total = dlslot->a_text;

		if (pos < total) {
			notdone = total - pos;
			if (notdone <= bsz) {
				outlen = read(dlslot->ldfd,&buf[len],notdone);
			} else {
				outlen = read(dlslot->ldfd,&buf[len],bsz);
			}
			len = len + outlen;
			pos = pos + outlen;
			bsz = bsz - outlen;
		}

		total = total + dlslot->a_text_fill;

		if ((bsz > 0) && (pos < total)) {
			notdone = total - pos;
			if (notdone <= bsz) {
				outlen = notdone;
			} else {
				outlen = bsz;
			}
			memset(&buf[len], 0, outlen);
			len = len + outlen;
			pos = pos + outlen;
			bsz = bsz - outlen;
		}

		total = total + dlslot->a_data;

		if ((bsz > 0) && (pos < total)) {
			notdone = total - pos;
			if (notdone <= bsz) {
				outlen = read(dlslot->ldfd,&buf[len],notdone);
			} else {
				outlen = read(dlslot->ldfd,&buf[len],bsz);
			}
			len = len + outlen;
			pos = pos + outlen;
			bsz = bsz - outlen;
		}

		total = total + dlslot->a_data_fill;

		if ((bsz > 0) && (pos < total)) {
			notdone = total - pos;
			if (notdone <= bsz) {
				outlen = notdone;
			} else {
				outlen = bsz;
			}
			memset(&buf[len], 0, outlen);
			len = len + outlen;
			pos = pos + outlen;
			bsz = bsz - outlen;
		}

		total = total + dlslot->a_bss;

		if ((bsz > 0) && (pos < total)) {
			notdone = total - pos;
			if (notdone <= bsz) {
				outlen = notdone;
			} else {
				outlen = bsz;
			}
			memset(&buf[len], 0, outlen);
			len = len + outlen;
			pos = pos + outlen;
			bsz = bsz - outlen;
		}

		total = total + dlslot->a_bss_fill;

		if ((bsz > 0) && (pos < total)) {
			notdone = total - pos;
			if (notdone <= bsz) {
				outlen = notdone;
			} else {
				outlen = bsz;
			}
			memset(&buf[len], 0, outlen);
			len = len + outlen;
			pos = pos + outlen;
			bsz = bsz - outlen;
		}

		dlslot->a_lseek = pos;
		break;

	default:
		abort();
	}

	return(len);
}
@


1.17
log
@Give the mop suite the ability to process alpha Elf64 files and create mop
alpha images of them.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.16 2014/11/30 13:47:42 miod Exp $ */
d894 1
a894 1
	
d899 1
a899 1
	
d1230 1
a1230 1
		
d1259 1
a1259 1
		
d1286 1
a1286 1
		
d1301 1
a1301 1
		
d1316 1
a1316 1
		
@


1.16
log
@In mopFileRead(), make sure to never increment e_cursec beyond e_nsec, so
that the next call to this function will not access e_sections[] out of
bounds.

Repairs mopa.out(1) behaviour noticed by sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.15 2013/10/17 08:02:21 deraadt Exp $ */
d62 6
d84 3
d146 34
d205 1
a205 2
	image_type = (u_short)(header[IHD_W_ALIAS+1]*256 +
			       header[IHD_W_ALIAS]);
d208 10
a217 10
		case IHD_C_NATIVE:		/* Native mode image (VAX)   */
		case IHD_C_RSX:			/* RSX image produced by TKB */
		case IHD_C_BPA:			/* BASIC plus analog         */
		case IHD_C_ALIAS:		/* Alias		     */
		case IHD_C_CLI:			/* Image is CLI		     */
		case IHD_C_PMAX:		/* PMAX system image	     */
		case IHD_C_ALPHA:		/* ALPHA system image	     */
			break;
		default:
			return(-1);
d236 105
a340 105
	switch(image_type) {
		case IHD_C_NATIVE:		/* Native mode image (VAX)   */
			isd = (header[IHD_W_SIZE+1]*256 +
			       header[IHD_W_SIZE]);
			iha = (header[IHD_W_ACTIVOFF+1]*256 +
			       header[IHD_W_ACTIVOFF]);
			hbcnt = (header[IHD_B_HDRBLKCNT]);
			isize = (header[isd+ISD_W_PAGCNT+1]*256 +
				 header[isd+ISD_W_PAGCNT]) * 512;
			load_addr = ((header[isd+ISD_V_VPN+1]*256 +
				      header[isd+ISD_V_VPN]) & ISD_M_VPN)
					* 512;
			xfr_addr = (header[iha+IHA_L_TFRADR1+3]*0x1000000 +
				    header[iha+IHA_L_TFRADR1+2]*0x10000 +
				    header[iha+IHA_L_TFRADR1+1]*0x100 +
				    header[iha+IHA_L_TFRADR1]) & 0x7fffffff;
			if (info == INFO_PRINT) {
				printf("Native Image (VAX)\n");
				printf("Header Block Count: %d\n",hbcnt);
				printf("Image Size:         %08x\n",isize);
				printf("Load Address:       %08x\n",load_addr);
				printf("Transfer Address:   %08x\n",xfr_addr);
			}
			break;
		case IHD_C_RSX:			/* RSX image produced by TKB */
			hbcnt = header[L_BBLK+1]*256 + header[L_BBLK];
			isize = (header[L_BLDZ+1]*256 + header[L_BLDZ]) * 64;
			load_addr = header[L_BSA+1]*256 + header[L_BSA];
			xfr_addr  = header[L_BXFR+1]*256 + header[L_BXFR];
			if (info == INFO_PRINT) {
				printf("RSX Image\n");
				printf("Header Block Count: %d\n",hbcnt);
				printf("Image Size:         %08x\n",isize);
				printf("Load Address:       %08x\n",load_addr);
				printf("Transfer Address:   %08x\n",xfr_addr);
			}
			break;
		case IHD_C_BPA:			/* BASIC plus analog         */
			if (info == INFO_PRINT) {
				printf("BASIC-Plus Image, not supported\n");
			}
			return(-1);
			break;
		case IHD_C_ALIAS:		/* Alias		     */
			if (info == INFO_PRINT) {
				printf("Alias, not supported\n");
			}
			return(-1);
			break;
		case IHD_C_CLI:			/* Image is CLI		     */
			if (info == INFO_PRINT) {
				printf("CLI, not supported\n");
			}
			return(-1);
			break;
		case IHD_C_PMAX:		/* PMAX system image	     */
			isd = (header[IHD_W_SIZE+1]*256 +
			       header[IHD_W_SIZE]);
			iha = (header[IHD_W_ACTIVOFF+1]*256 +
			       header[IHD_W_ACTIVOFF]);
			hbcnt = (header[IHD_B_HDRBLKCNT]);
			isize = (header[isd+ISD_W_PAGCNT+1]*256 +
				 header[isd+ISD_W_PAGCNT]) * 512;
			load_addr = (header[isd+ISD_V_VPN+1]*256 +
				     header[isd+ISD_V_VPN]) * 512;
			xfr_addr = (header[iha+IHA_L_TFRADR1+3]*0x1000000 +
				    header[iha+IHA_L_TFRADR1+2]*0x10000 +
				    header[iha+IHA_L_TFRADR1+1]*0x100 +
				    header[iha+IHA_L_TFRADR1]);
			if (info == INFO_PRINT) {
				printf("PMAX Image \n");
				printf("Header Block Count: %d\n",hbcnt);
				printf("Image Size:         %08x\n",isize);
				printf("Load Address:       %08x\n",load_addr);
				printf("Transfer Address:   %08x\n",xfr_addr);
			}
			break;
		case IHD_C_ALPHA:		/* ALPHA system image	     */
			isd = (header[EIHD_L_ISDOFF+3]*0x1000000 +
			       header[EIHD_L_ISDOFF+2]*0x10000 +
			       header[EIHD_L_ISDOFF+1]*0x100 +
			       header[EIHD_L_ISDOFF]);
			hbcnt = (header[EIHD_L_HDRBLKCNT+3]*0x1000000 +
				 header[EIHD_L_HDRBLKCNT+2]*0x10000 +
				 header[EIHD_L_HDRBLKCNT+1]*0x100 +
				 header[EIHD_L_HDRBLKCNT]);
			isize = (header[isd+EISD_L_SECSIZE+3]*0x1000000 +
				 header[isd+EISD_L_SECSIZE+2]*0x10000 +
				 header[isd+EISD_L_SECSIZE+1]*0x100 +
				 header[isd+EISD_L_SECSIZE]);
			load_addr = 0;
			xfr_addr = 0;
			if (info == INFO_PRINT) {
				printf("Alpha Image \n");
				printf("Header Block Count: %d\n",hbcnt);
				printf("Image Size:         %08x\n",isize);
				printf("Load Address:       %08x\n",load_addr);
				printf("Transfer Address:   %08x\n",xfr_addr);
			}
			break;
		default:
			if (info == INFO_PRINT) {
				printf("Unknown Image (%d)\n",image_type);
			}
			return(-1);
d486 3
a488 2
	/* Must be Elf32... */
	if (ehdr.e_ident[EI_CLASS] != ELFCLASS32)
d496 1
a496 1
GetElfFileInfo(struct dllist *dl, int info)
d686 196
d1120 1
a1120 1
	int	error;
d1124 3
a1126 1
		error = GetElfFileInfo(dl, info);
d1169 1
@


1.15
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.14 2013/07/05 21:02:07 miod Exp $ */
d978 2
a979 1
			dlslot->e_cursec++;
@


1.14
log
@Teach mopd and mopa.out about ELF files, and allow forthcoming VAX ELF boot
blocks to be converted to working mop binaries. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.13 2009/10/27 23:59:52 deraadt Exp $ */
d34 2
a35 2
#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <sys/exec_aout.h>
d55 1
a55 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
@


1.13
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.12 2006/05/11 05:18:38 maja Exp $ */
d28 4
a31 4
#include "common/common.h"
#include "common/mopdef.h"

#define INFO_PRINT 1
d54 31
d86 1
a86 1
mopFilePutLX(u_char *buf, int idx, u_long value, int cnt)
d90 2
a91 2
		buf[idx+i] = (u_char)(value % 256);
		value = (u_char)(value / 256);
d96 1
a96 1
mopFilePutBX(u_char *buf, int idx, u_long value, int cnt)
d100 1
a100 1
		buf[idx+cnt-1-i] = (u_char)(value % 256);
d105 2
a106 2
u_long
mopFileGetLX(void *buffer, int idx, int cnt)
d108 2
a109 3
	u_long	 ret = 0;
	int	 i;
	u_char	*buf = (u_char *)buffer;
d111 6
a116 2
	for (i = 0; i < cnt; i++)
		ret = ret*256 + buf[idx+cnt-1-i];
d118 1
a118 1
	return (ret);
d121 2
a122 2
u_long
mopFileGetBX(void *buffer, int idx, int cnt)
d124 2
a125 3
	u_long	 ret = 0;
	int	 i;
	u_char	*buf = (u_char *)buffer;
d127 6
a132 2
	for (i = 0; i < cnt; i++)
		ret = ret*256 + buf[idx+i];
d134 1
a134 1
	return (ret);
d138 1
a138 1
mopFileSwapX(void *buffer, int idx, int cnt)
d140 2
a141 3
	int	 i;
	u_char	 c;
	u_char	*buf = (u_char *)buffer;
d158 1
a158 1
		return (-1);
d160 1
a160 1
	lseek(fd, 0, SEEK_SET);
d162 2
a163 1
	image_type = (short)mopFileGetLX(header,IHD_W_ALIAS,2);
d165 1
a165 1
	switch (image_type) {
d175 1
a175 1
			return (-1);
d178 1
a178 1
	return (0);
d182 1
a182 1
GetMopFileInfo(int fd, u_long *load, u_long *xfr, int info)
d184 3
a186 3
	u_char	header[512];
	short	image_type, isd, iha;
	u_long	load_addr, xfr_addr, isize, hbcnt;
d188 2
a189 2
	if (read(fd, header, 512) != 512)
		return (-1);
d191 2
a192 1
	image_type = (short)mopFileGetLX(header,IHD_W_ALIAS,2);
d194 1
a194 1
	switch (image_type) {
d196 14
a209 8
			isd = (short)mopFileGetLX(header,IHD_W_SIZE,2);
			iha = (short)mopFileGetLX(header,IHD_W_ACTIVOFF,2);
			hbcnt = header[IHD_B_HDRBLKCNT];
			isize = mopFileGetLX(header,isd+ISD_W_PAGCNT,2) * 512;
			load_addr = (mopFileGetLX(header,isd+ISD_V_VPN,2) &
			    ISD_M_VPN) * 512;
			xfr_addr = mopFileGetLX(header,iha+IHA_L_TFRADR1,4) &
			    0x7fffffff;
d212 4
a215 4
				printf("Header Block Count: %lu\n", hbcnt);
				printf("Image Size:         %08lx\n", isize);
				printf("Load Address:       %08lx\n", load_addr);
				printf("Transfer Address:   %08lx\n", xfr_addr);
d219 4
a222 4
			hbcnt = mopFileGetLX(header,L_BBLK,2);
			isize = mopFileGetLX(header,L_BLDZ,2) * 64;
			load_addr = mopFileGetLX(header,L_BSA,2);
			xfr_addr = mopFileGetLX(header,L_BXFR,2);
d225 4
a228 4
				printf("Header Block Count: %lu\n",hbcnt);
				printf("Image Size:         %08lx\n", isize);
				printf("Load Address:       %08lx\n", load_addr);
				printf("Transfer Address:   %08lx\n", xfr_addr);
d235 2
a236 1
			return (-1);
d241 2
a242 1
			return (-1);
d247 2
a248 1
			return (-1);
d250 13
a262 6
			isd = (short)mopFileGetLX(header,IHD_W_SIZE,2);
			iha = (short)mopFileGetLX(header,IHD_W_ACTIVOFF,2);
			hbcnt = header[IHD_B_HDRBLKCNT];
			isize = mopFileGetLX(header,isd+ISD_W_PAGCNT,2) * 512;
			load_addr = mopFileGetLX(header,isd+ISD_V_VPN,2) * 512;
			xfr_addr = mopFileGetLX(header,iha+IHA_L_TFRADR1,4);
d265 4
a268 4
				printf("Header Block Count: %lu\n", hbcnt);
				printf("Image Size:         %08lx\n", isize);
				printf("Load Address:       %08lx\n", load_addr);
				printf("Transfer Address:   %08lx\n", xfr_addr);
d272 12
a283 3
			isd = (short)mopFileGetLX(header,EIHD_L_ISDOFF,4);
			hbcnt = mopFileGetLX(header,EIHD_L_HDRBLKCNT,4);
			isize = mopFileGetLX(header,isd+EISD_L_SECSIZE,4);
d288 4
a291 4
				printf("Header Block Count: %lu\n", hbcnt);
				printf("Image Size:         %08lx\n", isize);
				printf("Load Address:       %08lx\n", load_addr);
				printf("Transfer Address:   %08lx\n", xfr_addr);
d296 1
a296 1
				printf("Unknown Image (%d)\n", image_type);
d298 1
a298 1
			return (-1);
d301 3
a303 5
	if (load != NULL)
		*load = load_addr;

	if (xfr != NULL)
		*xfr  = xfr_addr;
d305 1
a305 1
	return (0);
d309 1
a309 1
int
d367 1
a367 1
	return (mid);
d370 1
a370 1
u_int
d373 1
a373 1
	u_int	clbytes;
d381 1
d383 1
a389 1
	case MID_SPARC:				/* It might be 8192 */
d399 2
d403 1
d410 4
a413 1
#if defined(MID_M68K) || defined(MID_ALPHA)
d421 1
a421 1
	return (clbytes);
d426 217
d646 1
a646 1
	return (-1);
d648 2
a649 2
	struct exec	ex, ex_swap;
	int		mid = -1;
d651 2
a652 2
	if (read(fd, &ex, sizeof(ex)) != (ssize_t)sizeof(ex))
		return (-1);
d654 4
a657 1
	lseek(fd, 0, SEEK_SET);
d659 3
a661 2
	if (read(fd, &ex_swap, sizeof(ex_swap)) != (ssize_t)sizeof(ex_swap))
		return (-1);
d663 3
a665 1
	lseek(fd, 0, SEEK_SET);
d667 5
a671 9
	mid = getMID(mid, (int)N_GETMID(ex));

	if (mid == -1)
		mid = getMID(mid, (int)N_GETMID(ex_swap));

	if (mid != -1)
		return (0);
	else
		return (-1);
d676 1
a676 3
GetAOutFileInfo(int fd, u_long *load, u_long *xfr, u_long *a_text,
    u_long *a_text_fill, u_long *a_data, u_long *a_data_fill, u_long *a_bss,
    u_long *a_bss_fill, int *aout, int info)
d679 1
a679 1
	return (-1);
d681 3
a683 3
	struct exec	ex, ex_swap;
	int		mid = -1;
	u_long		magic, clbytes, clofset;
d685 2
a686 2
	if (read(fd, &ex, sizeof(ex)) != (ssize_t)sizeof(ex))
		return (-1);
d688 1
a688 1
	lseek(fd, 0, SEEK_SET);
d690 3
a692 2
	if (read(fd, &ex_swap, sizeof(ex_swap)) != (ssize_t)sizeof(ex_swap))
		return (-1);
d694 1
a694 1
	mopFileSwapX(&ex_swap, 0, 4);
d696 1
a696 1
	mid = getMID(mid, (int)N_GETMID(ex));
d698 5
a702 4
	if (mid == -1) {
		mid = getMID(mid, (int)N_GETMID(ex_swap));
		if (mid != -1)
			mopFileSwapX(&ex, 0, 4);
d705 3
a707 2
	if (mid == -1)
		return (-1);
d709 3
a711 2
	if (N_BADMAG(ex))
		return (-1);
d730 7
a736 7
		ex.a_text   = (u_int)mopFileGetLX(&ex_swap,  4, 4);
		ex.a_data   = (u_int)mopFileGetLX(&ex_swap,  8, 4);
		ex.a_bss    = (u_int)mopFileGetLX(&ex_swap, 12, 4);
		ex.a_syms   = (u_int)mopFileGetLX(&ex_swap, 16, 4);
		ex.a_entry  = (u_int)mopFileGetLX(&ex_swap, 20, 4);
		ex.a_trsize = (u_int)mopFileGetLX(&ex_swap, 24, 4);
		ex.a_drsize = (u_int)mopFileGetLX(&ex_swap, 28, 4);
d748 7
a754 7
		ex.a_text   = (u_int)mopFileGetBX(&ex_swap,  4, 4);
		ex.a_data   = (u_int)mopFileGetBX(&ex_swap,  8, 4);
		ex.a_bss    = (u_int)mopFileGetBX(&ex_swap, 12, 4);
		ex.a_syms   = (u_int)mopFileGetBX(&ex_swap, 16, 4);
		ex.a_entry  = (u_int)mopFileGetBX(&ex_swap, 20, 4);
		ex.a_trsize = (u_int)mopFileGetBX(&ex_swap, 24, 4);
		ex.a_drsize = (u_int)mopFileGetBX(&ex_swap, 28, 4);
d762 1
a762 1
		switch (N_GETMID(ex)) {
d827 1
a827 1
			printf("Unknown %d",N_GETMAGIC (ex));
d830 7
a836 7
		printf("Size of text:       %08x\n", ex.a_text);
		printf("Size of data:       %08x\n", ex.a_data);
		printf("Size of bss:        %08x\n", ex.a_bss);
		printf("Size of symbol tab: %08x\n", ex.a_syms);
		printf("Transfer Address:   %08x\n", ex.a_entry);
		printf("Size of reloc text: %08x\n", ex.a_trsize);
		printf("Size of reloc data: %08x\n", ex.a_drsize);
d838 2
a839 1
	magic = N_GETMAGIC(ex);
d843 28
a870 44
	if (load != NULL)
		*load   = 0;

	if (xfr != NULL)
		*xfr = ex.a_entry;

	if (a_text != NULL)
		*a_text = ex.a_text;

	if (a_text_fill != NULL) {
		if (magic == ZMAGIC || magic == NMAGIC) {
			*a_text_fill = clbytes - (ex.a_text & clofset);
			if (*a_text_fill == clbytes)
				*a_text_fill = 0;
		} else
			*a_text_fill = 0;
	}

	if (a_data != NULL)
		*a_data = ex.a_data;

	if (a_data_fill != NULL) {
		if (magic == ZMAGIC || magic == NMAGIC) {
			*a_data_fill = clbytes - (ex.a_data & clofset);
			if (*a_data_fill == clbytes)
				*a_data_fill = 0;
		} else
			*a_data_fill = 0;
	}

	if (a_bss != NULL)
		*a_bss  = ex.a_bss;

	if (a_bss_fill != NULL) {
		if (magic == ZMAGIC || magic == NMAGIC) {
			*a_bss_fill = clbytes - (ex.a_bss & clofset);
			if (*a_bss_fill == clbytes)
				*a_bss_fill = 0;
		} else {
			*a_bss_fill = clbytes -
			    ((ex.a_text + ex.a_data + ex.a_bss) & clofset);
			if (*a_text_fill == clbytes)
				*a_text_fill = 0;
	        }
d872 1
d874 1
a874 4
	if (aout != NULL)
		*aout = mid;

	return (0);
d879 21
a899 15
GetFileInfo(int fd, u_long *load, u_long *xfr, int *aout, u_long *a_text,
    u_long *a_text_fill, u_long *a_data, u_long *a_data_fill, u_long *a_bss,
    u_long *a_bss_fill, int info)
{
	int	err;

	err = CheckAOutFile(fd);

	if (err == 0) {
		err = GetAOutFileInfo(fd, load, xfr, a_text, a_text_fill,
		    a_data, a_data_fill, a_bss, a_bss_fill, aout, info);
		if (err != 0)
			return (-1);
	} else {
		err = CheckMopFile(fd);
d901 7
a907 7
		if (err == 0) {
			err = GetMopFileInfo(fd, load, xfr, info);
			if (err != 0)
				return (-1);
			*aout = -1;
		} else
			return (-1);
d910 2
a911 1
	return (0);
d918 6
a923 4
	u_long	bsz, total, notdone;
	off_t	pos;
	
	if (dlslot->aout == -1)
d925 57
a981 1
	else {
d987 4
a990 4

		if (pos < (off_t)total) {
			notdone = total - (u_long)pos;
			if (notdone <= bsz)
d992 1
a992 1
			else
d994 1
d997 1
a997 1
			bsz = bsz - (u_long)outlen;
d1002 8
a1009 7
		if ((bsz > 0) && (pos < (off_t)total)) {
			notdone = total - (u_long)pos;
			if (notdone <= bsz)
				outlen = (ssize_t)notdone;
			else
				outlen = (ssize_t)bsz;
			bzero(&buf[len],(u_long)outlen);
d1012 1
a1012 1
			bsz = bsz - (u_long)outlen;
d1016 4
a1019 4

		if ((bsz > 0) && (pos < (off_t)total)) {
			notdone = total - (u_long)pos;
			if (notdone <= bsz)
d1021 1
a1021 1
			else
d1023 1
d1026 1
a1026 1
			bsz = bsz - (u_long)outlen;
d1031 8
a1038 7
		if ((bsz > 0) && (pos < (off_t)total)) {
			notdone = total - (u_long)pos;
			if (notdone <= bsz)
				outlen = (ssize_t)notdone;
			else
				outlen = (ssize_t)bsz;
			bzero(&buf[len],(u_long)outlen);
d1041 1
a1041 1
			bsz = bsz - (u_long)outlen;
d1043 1
a1043 1

d1046 8
a1053 7
		if ((bsz > 0) && (pos < (off_t)total)) {
			notdone = total - (u_long)pos;
			if (notdone <= bsz)
				outlen = (ssize_t)notdone;
			else
				outlen = (ssize_t)bsz;
			bzero(&buf[len],(u_long)outlen);
d1056 1
a1056 1
			bsz = bsz - (u_long)outlen;
d1058 1
a1058 1

d1061 8
a1068 7
		if ((bsz > 0) && (pos < (off_t)total)) {
			notdone = total - (u_long)pos;
			if (notdone <= bsz)
				outlen = (ssize_t)notdone;
			else
				outlen = (ssize_t)bsz;
			bzero(&buf[len],(u_long)outlen);
d1071 1
a1071 1
			bsz = bsz - (u_long)outlen;
d1073 1
a1073 1

d1075 1
d1077 2
d1081 1
a1081 1
	return (len);
@


1.12
log
@Some more delint. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.11 2006/04/29 16:26:56 maja Exp $ */
a25 5

#ifndef lint
static const char rcsid[] =
    "$OpenBSD: file.c,v 1.11 2006/04/29 16:26:56 maja Exp $";
#endif
@


1.11
log
@Change the compile time option -DINFO into a runtime option to get ride
of some lint warnings. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.10 2006/04/20 08:52:52 maja Exp $ */
d29 1
a29 1
    "$OpenBSD: file.c,v 1.10 2006/04/20 08:52:52 maja Exp $";
d64 2
a65 2
		buf[idx+i] = value % 256;
		value = value / 256;
d74 1
a74 1
		buf[idx+cnt-1-i] = value % 256;
d131 1
a131 1
	image_type = header[IHD_W_ALIAS+1] * 256 + header[IHD_W_ALIAS];
d153 2
a154 2
	short	image_type;
	u_long	load_addr, xfr_addr, isd, iha, hbcnt, isize;
d159 1
a159 1
	image_type = header[IHD_W_ALIAS+1] * 256 + header[IHD_W_ALIAS];
d163 2
a164 3
			isd = header[IHD_W_SIZE + 1] * 256 + header[IHD_W_SIZE];
			iha = header[IHD_W_ACTIVOFF + 1] * 256 +
			    header[IHD_W_ACTIVOFF];
d166 5
a170 8
			isize = (header[isd + ISD_W_PAGCNT + 1] * 256 +
			    header[isd + ISD_W_PAGCNT]) * 512;
			load_addr = ((header[isd + ISD_V_VPN + 1] * 256 +
			    header[isd+ISD_V_VPN]) & ISD_M_VPN) * 512;
			xfr_addr = (header[iha + IHA_L_TFRADR1 + 3] * 0x1000000+
			    header[iha + IHA_L_TFRADR1 + 2] * 0x10000 +
			    header[iha + IHA_L_TFRADR1 + 1] * 0x100 +
			    header[iha + IHA_L_TFRADR1]) & 0x7fffffff;
d180 4
a183 5
			hbcnt = header[L_BBLK + 1] * 256 + header[L_BBLK];
			isize = (header[L_BLDZ + 1] * 256 + header[L_BLDZ]) *
			    64;
			load_addr = header[L_BSA+1] * 256 + header[L_BSA];
			xfr_addr  = header[L_BXFR+1] * 256 + header[L_BXFR];
d208 2
a209 3
			isd = header[IHD_W_SIZE+1] * 256 + header[IHD_W_SIZE];
			iha = header[IHD_W_ACTIVOFF+1] * 256 +
			    header[IHD_W_ACTIVOFF];
d211 3
a213 8
			isize = (header[isd + ISD_W_PAGCNT + 1] * 256 +
			    header[isd + ISD_W_PAGCNT]) * 512;
			load_addr = (header[isd + ISD_V_VPN + 1] * 256 +
				     header[isd + ISD_V_VPN]) * 512;
			xfr_addr = (header[iha + IHA_L_TFRADR1 + 3] * 0x1000000+
				    header[iha + IHA_L_TFRADR1 + 2] * 0x10000 +
				    header[iha + IHA_L_TFRADR1 + 1] * 0x100 +
				    header[iha + IHA_L_TFRADR1]);
d223 3
a225 12
			isd = (header[EIHD_L_ISDOFF + 3] * 0x1000000 +
			       header[EIHD_L_ISDOFF + 2] * 0x10000 +
			       header[EIHD_L_ISDOFF + 1] * 0x100 +
			       header[EIHD_L_ISDOFF]);
			hbcnt = (header[EIHD_L_HDRBLKCNT + 3] * 0x1000000 +
				 header[EIHD_L_HDRBLKCNT + 2] * 0x10000 +
				 header[EIHD_L_HDRBLKCNT + 1] * 0x100 +
				 header[EIHD_L_HDRBLKCNT]);
			isize = (header[isd+EISD_L_SECSIZE + 3] * 0x1000000 +
				 header[isd+EISD_L_SECSIZE + 2] * 0x10000 +
				 header[isd+EISD_L_SECSIZE + 1] * 0x100 +
				 header[isd+EISD_L_SECSIZE]);
d314 1
a314 1
int
d317 1
a317 1
	int	clbytes;
d371 1
a371 1
	if (read(fd, &ex, sizeof(ex)) != sizeof(ex))
d376 1
a376 1
	if (read(fd, &ex_swap, sizeof(ex_swap)) != sizeof(ex_swap))
d405 1
a405 1
	if (read(fd, &ex, sizeof(ex)) != sizeof(ex))
d410 1
a410 1
	if (read(fd, &ex_swap, sizeof(ex_swap)) != sizeof(ex_swap))
d446 7
a452 7
		ex.a_text   = mopFileGetLX(&ex_swap,  4, 4);
		ex.a_data   = mopFileGetLX(&ex_swap,  8, 4);
		ex.a_bss    = mopFileGetLX(&ex_swap, 12, 4);
		ex.a_syms   = mopFileGetLX(&ex_swap, 16, 4);
		ex.a_entry  = mopFileGetLX(&ex_swap, 20, 4);
		ex.a_trsize = mopFileGetLX(&ex_swap, 24, 4);
		ex.a_drsize = mopFileGetLX(&ex_swap, 28, 4);
d464 7
a470 7
		ex.a_text  = mopFileGetBX(&ex_swap,  4, 4);
		ex.a_data  = mopFileGetBX(&ex_swap,  8, 4);
		ex.a_bss   = mopFileGetBX(&ex_swap, 12, 4);
		ex.a_syms  = mopFileGetBX(&ex_swap, 16, 4);
		ex.a_entry = mopFileGetBX(&ex_swap, 20, 4);
		ex.a_trsize= mopFileGetBX(&ex_swap, 24, 4);
		ex.a_drsize= mopFileGetBX(&ex_swap, 28, 4);
d644 3
a646 3
	int	bsz;
	long	pos, notdone, total;

d656 2
a657 2
		if (pos < total) {
			notdone = total - pos;
d664 1
a664 1
			bsz = bsz - outlen;
d669 2
a670 2
		if ((bsz > 0) && (pos < total)) {
			notdone = total - pos;
d672 1
a672 1
				outlen = notdone;
d674 2
a675 2
				outlen = bsz;
			bzero(&buf[len],outlen);
d678 1
a678 1
			bsz = bsz - outlen;
d683 2
a684 2
		if ((bsz > 0) && (pos < total)) {
			notdone = total - pos;
d691 1
a691 1
			bsz = bsz - outlen;
d696 2
a697 2
		if ((bsz > 0) && (pos < total)) {
			notdone = total - pos;
d699 1
a699 1
				outlen = notdone;
d701 2
a702 2
				outlen = bsz;
			bzero(&buf[len],outlen);
d705 1
a705 1
			bsz = bsz - outlen;
d710 2
a711 2
		if ((bsz > 0) && (pos < total)) {
			notdone = total - pos;
d713 1
a713 1
				outlen = notdone;
d715 2
a716 2
				outlen = bsz;
			bzero(&buf[len],outlen);
d719 1
a719 1
			bsz = bsz - outlen;
d724 2
a725 2
		if ((bsz > 0) && (pos < total)) {
			notdone = total - pos;
d727 1
a727 1
				outlen = notdone;
d729 2
a730 2
				outlen = bsz;
			bzero(&buf[len],outlen);
d733 1
a733 1
			bsz = bsz - outlen;
@


1.10
log
@More delint. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.9 2006/04/17 16:23:01 deraadt Exp $ */
d29 1
a29 1
    "$OpenBSD: file.c,v 1.9 2006/04/17 16:23:01 deraadt Exp $";
d36 2
d150 1
a150 1
GetMopFileInfo(int fd, u_long *load, u_long *xfr)
d175 7
a181 7
#ifdef INFO
			printf("Native Image (VAX)\n");
			printf("Header Block Count: %lu\n", hbcnt);
			printf("Image Size:         %08lx\n", isize);
			printf("Load Address:       %08lx\n", load_addr);
			printf("Transfer Address:   %08lx\n", xfr_addr);
#endif
d189 7
a195 7
#ifdef INFO
			printf("RSX Image\n");
			printf("Header Block Count: %lu\n",hbcnt);
			printf("Image Size:         %08lx\n", isize);
			printf("Load Address:       %08lx\n", load_addr);
			printf("Transfer Address:   %08lx\n", xfr_addr);
#endif
d198 3
a200 3
#ifdef INFO
			printf("BASIC-Plus Image, not supported\n");
#endif
d203 3
a205 3
#ifdef INFO
			printf("Alias, not supported\n");
#endif
d208 3
a210 3
#ifdef INFO
			printf("CLI, not supported\n");
#endif
d225 7
a231 7
#ifdef INFO
			printf("PMAX Image \n");
			printf("Header Block Count: %lu\n", hbcnt);
			printf("Image Size:         %08lx\n", isize);
			printf("Load Address:       %08lx\n", load_addr);
			printf("Transfer Address:   %08lx\n", xfr_addr);
#endif
d248 7
a254 7
#ifdef INFO
			printf("Alpha Image \n");
			printf("Header Block Count: %lu\n", hbcnt);
			printf("Image Size:         %08lx\n", isize);
			printf("Load Address:       %08lx\n", load_addr);
			printf("Transfer Address:   %08lx\n", xfr_addr);
#endif
d257 3
a259 3
#ifdef INFO
			printf("Unknown Image (%d)\n", image_type);
#endif
d401 1
a401 1
	mid = getMID(mid, N_GETMID(ex));
d404 1
a404 1
		mid = getMID(mid, N_GETMID(ex_swap));
d416 1
a416 1
    u_long *a_bss_fill, int *aout)
d435 1
a435 1
	mid = getMID(mid, N_GETMID(ex));
d438 1
a438 1
		mid = getMID(mid, N_GETMID(ex_swap));
d496 6
a501 6
#ifdef INFO
	printf("a.out image (");
	switch (N_GETMID(ex)) {
	case MID_I386:
		printf("i386");
		break;
d503 3
a505 3
	case MID_M68K:
		printf("m68k");
		break;
d508 3
a510 3
	case MID_M68K4K:
		printf("m68k 4k");
		break;
d513 3
a515 3
	case MID_NS32532:
		printf("pc532");
		break;
d517 3
a519 3
	case MID_SPARC:
		printf("sparc");
		break;
d521 3
a523 3
	case MID_PMAX:
		printf("pmax");
		break;
d526 3
a528 3
	case MID_VAX:
		printf("vax");
		break;
d531 3
a533 3
	case MID_ALPHA:
		printf("alpha");
		break;
d536 3
a538 3
	case MID_MIPS:
		printf("mips");
		break;
d541 3
a543 3
	case MID_ARM6:
		printf("arm32");
		break;
d545 28
a572 2
	default:
		break;
a573 26
	printf(") Magic: ");
	switch (N_GETMAGIC (ex)) {
	case OMAGIC:
		printf("OMAGIC");
		break;
	case NMAGIC:
		printf("NMAGIC");
		break;
	case ZMAGIC:
		printf("ZMAGIC");
		break;
	case QMAGIC:
		printf("QMAGIC");
		break;
	default:
		printf("Unknown %d",N_GETMAGIC (ex));
	}
	printf("\n");
	printf("Size of text:       %08x\n", ex.a_text);
	printf("Size of data:       %08x\n", ex.a_data);
	printf("Size of bss:        %08x\n", ex.a_bss);
	printf("Size of symbol tab: %08x\n", ex.a_syms);
	printf("Transfer Address:   %08x\n", ex.a_entry);
	printf("Size of reloc text: %08x\n", ex.a_trsize);
	printf("Size of reloc data: %08x\n", ex.a_drsize);
#endif
d634 1
a634 1
    u_long *a_bss_fill)
d642 1
a642 1
		    a_data, a_data_fill, a_bss, a_bss_fill, aout);
d649 1
a649 1
			err = GetMopFileInfo(fd, load, xfr);
@


1.9
log
@more cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.8 2004/04/14 20:37:28 henning Exp $ */
d29 1
a29 1
    "$OpenBSD: file.c,v 1.8 2004/04/14 20:37:28 henning Exp $";
d58 1
a58 1
mopFilePutLX(u_char *buf, int index, u_long value, int cnt)
d62 1
a62 1
		buf[index + i] = value % 256;
d68 1
a68 1
mopFilePutBX(u_char *buf, int index, u_long value, int cnt)
d72 1
a72 1
		buf[index + cnt - 1 - i] = value % 256;
d78 1
a78 1
mopFileGetLX(void *buffer, int index, int cnt)
d85 1
a85 1
		ret = ret*256 + buf[index+cnt - 1 - i];
d91 1
a91 1
mopFileGetBX(void *buffer, int index, int cnt)
d98 1
a98 1
		ret = ret*256 + buf[index + i];
d104 1
a104 1
mopFileSwapX(void *buffer, int index, int cnt)
d111 3
a113 3
		c = buf[index + i];
		buf[index + i] = buf[index + cnt - 1 - i];
		buf[index + cnt - 1 - i] = c;
a199 1
			break;
a204 1
			break;
a209 1
			break;
@


1.8
log
@4000 lines worth of cleanup, KNF, Knall&Rauch elemination and such
tested by hshoexer, "don't wait for me" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.7 2003/12/01 00:56:51 avsm Exp $ */
d27 1
a27 1
#ifndef LINT
d29 1
a29 1
    "$OpenBSD: file.c,v 1.7 2003/12/01 00:56:51 avsm Exp $";
@


1.7
log
@-Wall cleanup: trim unused vars, right format strings, constify rcsids,
braces where needed, add missing prototypes.

tested and ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.6 2003/06/02 21:38:39 maja Exp $ */
d28 2
a29 1
static const char rcsid[] = "$OpenBSD: file.c,v 1.6 2003/06/02 21:38:39 maja Exp $";
d58 1
a58 4
mopFilePutLX(buf, index, value, cnt)
	u_char	*buf;
	int	index, cnt;
	u_long	value;
d62 1
a62 1
		buf[index+i] = value % 256;
d68 1
a68 4
mopFilePutBX(buf, index, value, cnt)
	u_char	*buf;
	int	index, cnt;
	u_long	value;
d72 1
a72 1
		buf[index+cnt-1-i] = value % 256;
d78 1
a78 3
mopFileGetLX(buf, index, cnt)
	u_char	*buf;
	int	index, cnt;
d80 3
a82 2
	u_long ret = 0;
	int i;
d84 2
a85 3
	for (i = 0; i < cnt; i++) {
		ret = ret*256 + buf[index+cnt-1-i];
	}
d87 1
a87 1
	return(ret);
d91 1
a91 3
mopFileGetBX(buf, index, cnt)
	u_char	*buf;
	int	index, cnt;
d93 3
a95 2
	u_long ret = 0;
	int i;
d97 2
a98 3
	for (i = 0; i < cnt; i++) {
		ret = ret*256 + buf[index+i];
	}
d100 1
a100 1
	return(ret);
d104 1
a104 3
mopFileSwapX(buf, index, cnt)
	u_char	*buf;
	int	index, cnt;
d106 3
a108 2
	int i;
	u_char c;
d111 3
a113 3
		c = buf[index+i];
		buf[index+i] = buf[index+cnt-1-i];
		buf[index+cnt-1-i] = c;
d119 1
a119 2
CheckMopFile(fd)
	int	fd;
d125 1
a125 1
		return(-1);
d127 1
a127 1
	(void)lseek(fd, (off_t) 0, SEEK_SET);
d129 1
a129 2
	image_type = (u_short)(header[IHD_W_ALIAS+1]*256 +
			       header[IHD_W_ALIAS]);
d131 1
a131 1
	switch(image_type) {
d141 1
a141 1
			return(-1);
d144 1
a144 1
	return(0);
d148 1
a148 3
GetMopFileInfo(fd, load, xfr)
	int	fd;
	u_long	*load, *xfr;
d155 1
a155 1
		return(-1);
d157 1
a157 2
	image_type = (u_short)(header[IHD_W_ALIAS+1]*256 +
			       header[IHD_W_ALIAS]);
d159 1
a159 1
	switch(image_type) {
d161 12
a172 14
			isd = (header[IHD_W_SIZE+1]*256 +
			       header[IHD_W_SIZE]);
			iha = (header[IHD_W_ACTIVOFF+1]*256 +
			       header[IHD_W_ACTIVOFF]);
			hbcnt = (header[IHD_B_HDRBLKCNT]);
			isize = (header[isd+ISD_W_PAGCNT+1]*256 +
				 header[isd+ISD_W_PAGCNT]) * 512;
			load_addr = ((header[isd+ISD_V_VPN+1]*256 +
				      header[isd+ISD_V_VPN]) & ISD_M_VPN)
					* 512;
			xfr_addr = (header[iha+IHA_L_TFRADR1+3]*0x1000000 +
				    header[iha+IHA_L_TFRADR1+2]*0x10000 +
				    header[iha+IHA_L_TFRADR1+1]*0x100 +
				    header[iha+IHA_L_TFRADR1]) & 0x7fffffff;
d175 4
a178 4
			printf("Header Block Count: %lu\n",hbcnt);
			printf("Image Size:         %08lx\n",isize);
			printf("Load Address:       %08lx\n",load_addr);
			printf("Transfer Address:   %08lx\n",xfr_addr);
d182 5
a186 4
			hbcnt = header[L_BBLK+1]*256 + header[L_BBLK];
			isize = (header[L_BLDZ+1]*256 + header[L_BLDZ]) * 64;
			load_addr = header[L_BSA+1]*256 + header[L_BSA];
			xfr_addr  = header[L_BXFR+1]*256 + header[L_BXFR];
d190 3
a192 3
			printf("Image Size:         %08lx\n",isize);
			printf("Load Address:       %08lx\n",load_addr);
			printf("Transfer Address:   %08lx\n",xfr_addr);
d199 1
a199 1
			return(-1);
d205 1
a205 1
			return(-1);
d211 1
a211 1
			return(-1);
d214 12
a225 13
			isd = (header[IHD_W_SIZE+1]*256 +
			       header[IHD_W_SIZE]);
			iha = (header[IHD_W_ACTIVOFF+1]*256 +
			       header[IHD_W_ACTIVOFF]);
			hbcnt = (header[IHD_B_HDRBLKCNT]);
			isize = (header[isd+ISD_W_PAGCNT+1]*256 +
				 header[isd+ISD_W_PAGCNT]) * 512;
			load_addr = (header[isd+ISD_V_VPN+1]*256 +
				     header[isd+ISD_V_VPN]) * 512;
			xfr_addr = (header[iha+IHA_L_TFRADR1+3]*0x1000000 +
				    header[iha+IHA_L_TFRADR1+2]*0x10000 +
				    header[iha+IHA_L_TFRADR1+1]*0x100 +
				    header[iha+IHA_L_TFRADR1]);
d228 4
a231 4
			printf("Header Block Count: %lu\n",hbcnt);
			printf("Image Size:         %08lx\n",isize);
			printf("Load Address:       %08lx\n",load_addr);
			printf("Transfer Address:   %08lx\n",xfr_addr);
d235 3
a237 3
			isd = (header[EIHD_L_ISDOFF+3]*0x1000000 +
			       header[EIHD_L_ISDOFF+2]*0x10000 +
			       header[EIHD_L_ISDOFF+1]*0x100 +
d239 3
a241 3
			hbcnt = (header[EIHD_L_HDRBLKCNT+3]*0x1000000 +
				 header[EIHD_L_HDRBLKCNT+2]*0x10000 +
				 header[EIHD_L_HDRBLKCNT+1]*0x100 +
d243 3
a245 3
			isize = (header[isd+EISD_L_SECSIZE+3]*0x1000000 +
				 header[isd+EISD_L_SECSIZE+2]*0x10000 +
				 header[isd+EISD_L_SECSIZE+1]*0x100 +
d251 4
a254 4
			printf("Header Block Count: %lu\n",hbcnt);
			printf("Image Size:         %08lx\n",isize);
			printf("Load Address:       %08lx\n",load_addr);
			printf("Transfer Address:   %08lx\n",xfr_addr);
d259 1
a259 1
			printf("Unknown Image (%d)\n",image_type);
d261 1
a261 1
			return(-1);
d264 1
a264 1
	if (load != NULL) {
a265 1
	}
d267 1
a267 1
	if (xfr != NULL) {
a268 1
	}
d270 1
a270 1
	return(0);
d275 1
a275 2
getMID(old_mid,new_mid)
	int	old_mid, new_mid;
d332 1
a332 1
	return(mid);
d336 1
a336 2
getCLBYTES(mid)
	int	mid;
d379 1
a379 1
	return(clbytes);
d384 1
a384 2
CheckAOutFile(fd)
	int	fd;
d387 1
a387 1
	return(-1);
d389 5
a393 2
	struct exec ex, ex_swap;
	int	mid = -1;
d395 1
a395 2
	if (read(fd, (char *)&ex, sizeof(ex)) != sizeof(ex))
		return(-1);
d397 2
a398 8
	(void)lseek(fd, (off_t) 0, SEEK_SET);
	
	if (read(fd, (char *)&ex_swap, sizeof(ex_swap)) != sizeof(ex_swap))
		return(-1);

	(void)lseek(fd, (off_t) 0, SEEK_SET);
	
	mid = getMID(mid, N_GETMID (ex));
d400 6
a405 3
	if (mid == -1) {
		mid = getMID(mid, N_GETMID (ex_swap));
	}
d407 4
a410 5
	if (mid != -1) {
		return(0);
	} else {
		return(-1);
	}
d415 3
a417 5
GetAOutFileInfo(fd, load, xfr, a_text, a_text_fill,
		a_data, a_data_fill, a_bss, a_bss_fill, aout)
	int	fd, *aout;
	u_long	*load, *xfr, *a_text, *a_text_fill;
	u_long	*a_data, *a_data_fill, *a_bss, *a_bss_fill;
d420 1
a420 1
	return(-1);
d422 3
a424 3
	struct exec ex, ex_swap;
	int	mid = -1;
	u_long	magic, clbytes, clofset;
d426 2
a427 2
	if (read(fd, (char *)&ex, sizeof(ex)) != sizeof(ex))
		return(-1);
d429 1
a429 1
	(void)lseek(fd, (off_t) 0, SEEK_SET);
d431 2
a432 2
	if (read(fd, (char *)&ex_swap, sizeof(ex_swap)) != sizeof(ex_swap))
		return(-1);
d434 1
a434 1
	mopFileSwapX((u_char *)&ex_swap, 0, 4);
d436 1
a436 1
	mid = getMID(mid, N_GETMID (ex));
d439 3
a441 4
		mid = getMID(mid, N_GETMID (ex_swap));
		if (mid != -1) {
			mopFileSwapX((u_char *)&ex, 0, 4);
		}
d444 2
a445 3
	if (mid == -1) {
		return(-1);
	}
d447 2
a448 3
	if (N_BADMAG (ex)) {
		return(-1);
	}
d467 7
a473 7
		ex.a_text  = mopFileGetLX((u_char *)&ex_swap,  4, 4);
		ex.a_data  = mopFileGetLX((u_char *)&ex_swap,  8, 4);
		ex.a_bss   = mopFileGetLX((u_char *)&ex_swap, 12, 4);
		ex.a_syms  = mopFileGetLX((u_char *)&ex_swap, 16, 4);
		ex.a_entry = mopFileGetLX((u_char *)&ex_swap, 20, 4);
		ex.a_trsize= mopFileGetLX((u_char *)&ex_swap, 24, 4);
		ex.a_drsize= mopFileGetLX((u_char *)&ex_swap, 28, 4);
d485 7
a491 7
		ex.a_text  = mopFileGetBX((u_char *)&ex_swap,  4, 4);
		ex.a_data  = mopFileGetBX((u_char *)&ex_swap,  8, 4);
		ex.a_bss   = mopFileGetBX((u_char *)&ex_swap, 12, 4);
		ex.a_syms  = mopFileGetBX((u_char *)&ex_swap, 16, 4);
		ex.a_entry = mopFileGetBX((u_char *)&ex_swap, 20, 4);
		ex.a_trsize= mopFileGetBX((u_char *)&ex_swap, 24, 4);
		ex.a_drsize= mopFileGetBX((u_char *)&ex_swap, 28, 4);
d499 1
a499 1
	switch (N_GETMID (ex)) {
d567 7
a573 7
	printf("Size of text:       %08x\n",ex.a_text);
	printf("Size of data:       %08x\n",ex.a_data);
	printf("Size of bss:        %08x\n",ex.a_bss);
	printf("Size of symbol tab: %08x\n",ex.a_syms);
	printf("Transfer Address:   %08x\n",ex.a_entry);
	printf("Size of reloc text: %08x\n",ex.a_trsize);
	printf("Size of reloc data: %08x\n",ex.a_drsize);
d575 1
a575 1
	magic = N_GETMAGIC (ex);
d579 1
a579 1
	if (load != NULL) {
a580 1
	}
d582 2
a583 3
	if (xfr != NULL) {
		*xfr    = ex.a_entry;
	}
d585 1
a585 1
	if (a_text != NULL) {
a586 1
	}
d591 1
a591 1
			if (*a_text_fill == clbytes) {
d593 1
a593 2
			}
		} else {
a594 1
	        }
d597 1
a597 1
	if (a_data != NULL) {
a598 1
	}
d603 1
a603 1
			if (*a_data_fill == clbytes) {
d605 1
a605 2
			}
		} else {
a606 1
	        }
d609 1
a609 1
	if (a_bss != NULL) {
a610 1
	}
d615 1
a615 1
			if (*a_bss_fill == clbytes) {
a616 1
			}
d619 2
a620 2
				((ex.a_text+ex.a_data+ex.a_bss) & clofset);
			if (*a_text_fill == clbytes) {
a621 1
			}
d625 1
a625 1
	if (aout != NULL) {
a626 1
	}
d628 1
a628 1
	return(0);
d633 3
a635 5
GetFileInfo(fd, load, xfr, aout,
	    a_text, a_text_fill, a_data, a_data_fill, a_bss, a_bss_fill)
	int	fd, *aout;
	u_long	*load, *xfr, *a_text, *a_text_fill;
	u_long	*a_data, *a_data_fill, *a_bss, *a_bss_fill;
d642 4
a645 8
		err = GetAOutFileInfo(fd, load, xfr,
				      a_text, a_text_fill,
				      a_data, a_data_fill,
				      a_bss, a_bss_fill,
				      aout);
		if (err != 0) {
			return(-1);
		}
d648 1
a648 1
		
d651 2
a652 3
			if (err != 0) {
				return(-1);
			}
d654 2
a655 3
		} else {
			return(-1);
		}
d658 1
a658 1
	return(0);
d662 1
a662 3
mopFileRead(dlslot, buf)
	struct dllist *dlslot;
	u_char	*buf;
d668 1
a668 1
	if (dlslot->aout == -1) {
d670 1
a670 1
	} else {
d676 1
a676 1
		
d679 1
a679 1
			if (notdone <= bsz) {
d681 1
a681 1
			} else {
a682 1
			}
d692 1
a692 1
			if (notdone <= bsz) {
d694 1
a694 1
			} else {
a695 1
			}
d703 1
a703 1
		
d706 1
a706 1
			if (notdone <= bsz) {
d708 1
a708 1
			} else {
a709 1
			}
d719 1
a719 1
			if (notdone <= bsz) {
d721 1
a721 1
			} else {
a722 1
			}
d728 1
a728 1
		
d733 1
a733 1
			if (notdone <= bsz) {
d735 1
a735 1
			} else {
a736 1
			}
d742 1
a742 1
		
d747 1
a747 1
			if (notdone <= bsz) {
d749 1
a749 1
			} else {
a750 1
			}
d756 1
a756 1
		
d761 1
a761 1
	return(len);
@


1.6
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.5 2002/09/07 07:58:21 maja Exp $ */
d28 1
a28 1
static char rcsid[] = "$OpenBSD: file.c,v 1.5 2002/09/07 07:58:21 maja Exp $";
d192 4
a195 4
			printf("Header Block Count: %d\n",hbcnt);
			printf("Image Size:         %08x\n",isize);
			printf("Load Address:       %08x\n",load_addr);
			printf("Transfer Address:   %08x\n",xfr_addr);
d205 4
a208 4
			printf("Header Block Count: %d\n",hbcnt);
			printf("Image Size:         %08x\n",isize);
			printf("Load Address:       %08x\n",load_addr);
			printf("Transfer Address:   %08x\n",xfr_addr);
d245 4
a248 4
			printf("Header Block Count: %d\n",hbcnt);
			printf("Image Size:         %08x\n",isize);
			printf("Load Address:       %08x\n",load_addr);
			printf("Transfer Address:   %08x\n",xfr_addr);
d268 4
a271 4
			printf("Header Block Count: %d\n",hbcnt);
			printf("Image Size:         %08x\n",isize);
			printf("Load Address:       %08x\n",load_addr);
			printf("Transfer Address:   %08x\n",xfr_addr);
@


1.5
log
@pedantic ansify. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.4 2001/08/12 12:03:03 heko Exp $ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d28 1
a28 1
static char rcsid[] = "$OpenBSD: file.c,v 1.4 2001/08/12 12:03:03 heko Exp $";
@


1.4
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.3 1999/03/27 14:31:21 maja Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: file.c,v 1.3 1999/03/27 14:31:21 maja Exp $";
d581 1
@


1.3
log
@Upgrade to 2.5.4. Mopprobe is working again, and some linux support. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.2 1996/09/21 19:11:31 maja Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: file.c,v 1.2 1996/09/21 19:11:31 maja Exp $";
d440 1
a440 1
#endif NOAOUT
d674 1
a674 1
#endif NOAOUT
@


1.2
log
@Replace $Id with $OpenBSD, 3:rd try. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: file.c,v 1.1.1.1 1996/09/21 13:49:16 maja Exp $";
d50 6
a324 3
/*###323 [cc] for each function it appears in.)%%%*/
/*###323 [cc] (Each undeclared identifier is reported only once%%%*/
/*###323 [cc] `MID_SPARC' undeclared (first use this function)%%%*/
d354 1
a354 1
/*###352 [cc] syntax error before `}'%%%*/
a408 1
/*###406 [cc] syntax error before `int'%%%*/
a418 1
/*###416 [cc] `fd' undeclared (first use this function)%%%*/
a442 1
/*###440 [cc] syntax error before `int'%%%*/
d528 1
a528 1
/*###525 [cc] syntax error before `}'%%%*/
a611 1
/*###608 [cc] `load' undeclared (first use this function)%%%*/
a615 1
/*###612 [cc] `xfr' undeclared (first use this function)%%%*/
a619 1
/*###616 [cc] `a_text' undeclared (first use this function)%%%*/
a623 1
/*###620 [cc] `a_text_fill' undeclared (first use this function)%%%*/
a634 1
/*###631 [cc] `a_data' undeclared (first use this function)%%%*/
a638 1
/*###635 [cc] `a_data_fill' undeclared (first use this function)%%%*/
a649 1
/*###646 [cc] `a_bss' undeclared (first use this function)%%%*/
a653 1
/*###650 [cc] `a_bss_fill' undeclared (first use this function)%%%*/
a668 1
/*###665 [cc] `aout' undeclared (first use this function)%%%*/
a676 1
/*###673 [cc] syntax error before `int'%%%*/
a714 1
/*###711 [cc] syntax error before `mopFileRead'%%%*/
a722 1
/*###719 [cc] `dlslot' undeclared (first use this function)%%%*/
a723 1
/*###720 [cc] `buf' undeclared (first use this function)%%%*/
a734 1
/*###731 [cc] subscripted value is neither array nor pointer%%%*/
a736 1
/*###733 [cc] subscripted value is neither array nor pointer%%%*/
a752 1
/*###749 [cc] subscripted value is neither array nor pointer%%%*/
a763 1
/*###760 [cc] subscripted value is neither array nor pointer%%%*/
a765 1
/*###762 [cc] subscripted value is neither array nor pointer%%%*/
a781 1
/*###778 [cc] subscripted value is neither array nor pointer%%%*/
a796 1
/*###793 [cc] subscripted value is neither array nor pointer%%%*/
a811 1
/*###808 [cc] subscripted value is neither array nor pointer%%%*/
a823 1
/*###820 [cc] syntax error at end of input%%%*/
@


1.1
log
@Initial revision
@
text
@d1 2
d33 1
a33 1
static char rcsid[] = "$Id: file.c,v 1.4 1996/08/16 22:39:22 moj Exp $";
@


1.1.1.1
log
@Initial import of mopd-2.5.3. -moj
@
text
@@
