head	1.17;
access;
symbols
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.12
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.8
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.10
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.16
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.12
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.10
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.8
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	MOPD254:1.3
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	MOPD253:1.1.1.1
	MAJA:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2017.01.21.08.33.51;	author krw;	state Exp;
branches;
next	1.16;
commitid	xpTSTOgSQRGS1RiF;

1.16
date	2013.11.24.21.32.31;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2013.07.05.21.02.07;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.52;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.17.16.23.01;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.14.20.37.28;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.01.00.56.51;	author avsm;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.07.10.16.46;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.31.09.06.46;	author maja;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.19.22.19.08;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.02.21.38.39;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.07.08.09.49;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.10.21.05.25;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.20.17.45.33;	author bitblt;	state Exp;
branches;
next	1.3;

1.3
date	99.03.27.14.31.21;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	96.09.21.19.11.23;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.13.49.16;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.13.49.16;	author maja;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: device.c,v 1.16 2013/11/24 21:32:31 deraadt Exp $ */

/*
 * Copyright (c) 1993-95 Mats O Jansson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "os.h"
#include "common.h"
#include "device.h"
#include "mopdef.h"
#include "pf.h"

struct if_info	*iflist;		/* Interface List		*/

#ifdef	DEV_NEW_CONF
/*
 * Return ethernet address for interface
 */

void
deviceEthAddr(char *ifname, u_char *eaddr)
{
	struct sockaddr_dl	*sdl;
	struct ifaddrs		*ifap, *ifa;

	if (getifaddrs(&ifap) != 0) {
		syslog(LOG_ERR, "deviceEthAddr: getifaddrs: %m");
		exit(1);
	}

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
		if (sdl->sdl_family != AF_LINK || sdl->sdl_type != IFT_ETHER ||
		    sdl->sdl_alen != 6)
			continue;
		if (!strcmp(ifa->ifa_name, ifname)) {
			bcopy(LLADDR(sdl), eaddr, 6);
			freeifaddrs(ifap);
			return;
		}
	}

	syslog(LOG_ERR, "deviceEthAddr: Never saw interface `%s'!", ifname);
	exit(1);
}
#endif	/* DEV_NEW_CONF */

void
deviceOpen(char *ifname, u_short proto, int trans)
{
	struct if_info	*p, tmp;

	strncpy(tmp.if_name, ifname, sizeof(tmp.if_name) - 1);
	tmp.if_name[sizeof(tmp.if_name) - 1] = 0;
	tmp.iopen = pfInit;

	switch (proto) {
	case MOP_K_PROTO_RC:
		tmp.read = mopReadRC;
		tmp.fd   = mopOpenRC(&tmp, trans);
		break;
	case MOP_K_PROTO_DL:
		tmp.read = mopReadDL;
		tmp.fd   = mopOpenDL(&tmp, trans);
		break;
	default:
		break;
	}

	if (tmp.fd != -1) {
		p = malloc(sizeof(*p));
		if (p == 0) {
			syslog(LOG_ERR, "deviceOpen: malloc: %m");
			exit(1);
		}

		p->next = iflist;
		iflist = p;

		strlcpy(p->if_name, tmp.if_name, IFNAME_SIZE);
		p->iopen   = tmp.iopen;
		p->write   = pfWrite;
		p->read    = tmp.read;
		bzero(p->eaddr, sizeof(p->eaddr));
		p->fd      = tmp.fd;

#ifdef	DEV_NEW_CONF
		deviceEthAddr(p->if_name, &p->eaddr[0]);
#else
		p->eaddr[0] = tmp.eaddr[0];
		p->eaddr[1] = tmp.eaddr[1];
		p->eaddr[2] = tmp.eaddr[2];
		p->eaddr[3] = tmp.eaddr[3];
		p->eaddr[4] = tmp.eaddr[4];
		p->eaddr[5] = tmp.eaddr[5];
#endif	/* DEV_NEW_CONF */

#ifdef LINUX2_PF
		{
			int s;

			s = socket(AF_INET, SOCK_DGRAM, 0);
			pfEthAddr(s, p->if_name, &p->eaddr[0]);
			close(s);
		}
#endif
	}
}

void
deviceInitOne(char *ifname)
{
	char	interface[IFNAME_SIZE];
	struct if_info *p;
	int	trans;
#ifdef _AIX
	char	dev[IFNAME_SIZE];
	int	unit,j;

	unit = 0;
	for (j = 0; j < strlen(ifname); j++) {
		if (isalpha((unsigned char)ifname[j]))
			dev[j] = ifname[j];
		else
			if (isdigit((unsigned char)ifname[j])) {
				unit = unit * 10 + ifname[j] - '0';
				dev[j] = '\0';
			}
	}

	if ((strlen(dev) == 2) && (dev[0] == 'e') &&
	    ((dev[1] == 'n') || (dev[1] == 't')))
		snprintf(interface, sizeof(interface), "ent%d\0", unit);
	else
		snprintf(interface, sizeof(interface), "%s%d\0", dev, unit);
#else
	snprintf(interface, sizeof(interface), "%s", ifname);
#endif /* _AIX */

	/* Ok, init it just once */
	p = iflist;
	for (p = iflist; p; p = p->next)
		if (strcmp(p->if_name, interface) == 0)
			return;

	syslog(LOG_INFO, "Initialized %s", interface);

	/* Ok, get transport information */
	trans = pfTrans(interface);

#ifndef NORC
	/* Start with MOP Remote Console */
	switch (trans) {
	case TRANS_ETHER:
		deviceOpen(interface, MOP_K_PROTO_RC, TRANS_ETHER);
		break;
	case TRANS_8023:
		deviceOpen(interface, MOP_K_PROTO_RC, TRANS_8023);
		break;
	case TRANS_ETHER + TRANS_8023:
		deviceOpen(interface, MOP_K_PROTO_RC, TRANS_ETHER);
		deviceOpen(interface, MOP_K_PROTO_RC, TRANS_8023);
		break;
	case TRANS_ETHER + TRANS_8023 + TRANS_AND:
		deviceOpen(interface, MOP_K_PROTO_RC, TRANS_ETHER + TRANS_8023);
		break;
	}
#endif

#ifndef NODL
	/* and next MOP Dump/Load */
	switch (trans) {
	case TRANS_ETHER:
		deviceOpen(interface, MOP_K_PROTO_DL, TRANS_ETHER);
		break;
	case TRANS_8023:
		deviceOpen(interface, MOP_K_PROTO_DL, TRANS_8023);
		break;
	case TRANS_ETHER + TRANS_8023:
		deviceOpen(interface, MOP_K_PROTO_DL, TRANS_ETHER);
		deviceOpen(interface, MOP_K_PROTO_DL, TRANS_8023);
		break;
	case TRANS_ETHER + TRANS_8023 + TRANS_AND:
		deviceOpen(interface, MOP_K_PROTO_DL, TRANS_ETHER + TRANS_8023);
		break;
	}
#endif

}

/*
 * Initialize all "candidate" interfaces that are in the system
 * configuration list.  A "candidate" is up, not loopback and not
 * point to point.
 */
void
deviceInitAll()
{
#ifdef DEV_NEW_CONF
	struct sockaddr_dl	*sdl;
	struct ifaddrs		*ifap, *ifa;

	if (getifaddrs(&ifap) != 0) {
		syslog(LOG_ERR, "deviceInitAll: getifaddrs: %m");
		exit(1);
	}

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
		if (sdl->sdl_family != AF_LINK || sdl->sdl_type != IFT_ETHER ||
		    sdl->sdl_alen != 6)
			continue;
		if ((ifa->ifa_flags &
		    (IFF_UP | IFF_LOOPBACK | IFF_POINTOPOINT)) != IFF_UP)
			continue;
		deviceInitOne(ifa->ifa_name);
	}
	freeifaddrs(ifap);
#else
	struct ifaddrs	*ifap, *ifa;

	if (getifaddrs(&ifap) != 0) {
		syslog(LOG_ERR, "deviceInitAll: getifaddrs: %m");
		exit(1);
	}

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (/*(ifa->ifa_flags & IFF_UP) == 0 ||*/
		    ifa->ifa_flags & IFF_LOOPBACK ||
		    ifa->ifa_flags & IFF_POINTOPOINT)
			continue;
		deviceInitOne(ifa->ifa_name);
	}
	freeifaddrs(ifap);
#endif
}
@


1.16
log
@more ctype cleanups
checked by jca
@
text
@d1 1
a1 1
/*	$OpenBSD: device.c,v 1.15 2013/07/05 21:02:07 miod Exp $ */
d160 1
a160 1
	/* Ok, init it just once */	
@


1.15
log
@Teach mopd and mopa.out about ELF files, and allow forthcoming VAX ELF boot
blocks to be converted to working mop binaries. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.c,v 1.14 2009/10/27 23:59:52 deraadt Exp $ */
d142 1
a142 1
		if (isalpha(ifname[j]))
d145 1
a145 1
			if (isdigit(ifname[j])) {
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: device.c,v 1.13 2006/04/17 16:23:01 deraadt Exp $ */
d28 4
a31 2
#include "common/common.h"
#include "common/mopdef.h"
a33 8

void mopReadDL(void);
void mopReadRC(void);
int  mopOpenDL(struct if_info *, int);
int  mopOpenRC(struct if_info *, int);
int  pfTrans();
int  pfInit();
int  pfWrite();
@


1.13
log
@more cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: device.c,v 1.12 2004/04/14 20:37:28 henning Exp $ */
a25 5

#ifndef lint
static const char rcsid[] =
    "$OpenBSD: device.c,v 1.12 2004/04/14 20:37:28 henning Exp $";
#endif
@


1.12
log
@4000 lines worth of cleanup, KNF, Knall&Rauch elemination and such
tested by hshoexer, "don't wait for me" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: device.c,v 1.11 2003/12/01 00:56:51 avsm Exp $ */
d27 1
a27 1
#ifndef LINT
d29 1
a29 1
    "$OpenBSD: device.c,v 1.11 2003/12/01 00:56:51 avsm Exp $";
@


1.11
log
@-Wall cleanup: trim unused vars, right format strings, constify rcsids,
braces where needed, add missing prototypes.

tested and ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: device.c,v 1.10 2003/11/07 10:16:46 jmc Exp $ */
d28 2
a29 1
static const char rcsid[] = "$OpenBSD: device.c,v 1.10 2003/11/07 10:16:46 jmc Exp $";
d36 1
a36 1
struct	if_info *iflist;		/* Interface List		*/
d38 2
a39 2
void mopReadDL();
void mopReadRC();
d52 1
a52 3
deviceEthAddr(ifname, eaddr)
	char *ifname;
        u_char *eaddr;
d54 2
a55 2
	struct sockaddr_dl *sdl;
	struct ifaddrs *ifap, *ifa;
d68 1
a68 1
			bcopy((caddr_t)LLADDR(sdl), (caddr_t)eaddr, 6);
d80 1
a80 4
deviceOpen(ifname, proto, trans)
	char	*ifname;
	u_short	 proto;
	int	 trans;
d82 5
a86 1
	struct if_info *p, tmp;
a87 4
	strncpy(tmp.if_name,ifname,sizeof(tmp.if_name) - 1);
	tmp.if_name[sizeof(tmp.if_name)-1] = 0;
	tmp.iopen   = pfInit;
	
d100 1
a100 1
	
d102 1
a102 2
		
		p = (struct if_info *)malloc(sizeof(*p));
d104 2
a105 2
		syslog(LOG_ERR, "deviceOpen: malloc: %m");
		exit(1);
d107 1
a107 1
	
d111 1
a111 2
		strncpy(p->if_name,tmp.if_name, IFNAME_SIZE -1);
		p->if_name[IFNAME_SIZE -1] = 0;
d115 1
a115 1
		bzero((char *)p->eaddr,sizeof(p->eaddr));
d119 1
a119 1
		deviceEthAddr(p->if_name,&p->eaddr[0]);
d121 6
a126 6
		p->eaddr[0]= tmp.eaddr[0];
		p->eaddr[1]= tmp.eaddr[1];
		p->eaddr[2]= tmp.eaddr[2];
		p->eaddr[3]= tmp.eaddr[3];
		p->eaddr[4]= tmp.eaddr[4];
		p->eaddr[5]= tmp.eaddr[5];
d128 1
a128 1
	
d133 4
a136 5
			s = socket(AF_INET,SOCK_DGRAM,0);
			pfEthAddr(s,p->if_name,&p->eaddr[0]);
			(void) close(s);
			
		}	
d142 1
a142 2
deviceInitOne(ifname)
	char	*ifname;
d150 1
a150 1
	
d153 1
a153 1
		if (isalpha(ifname[j])) {
d155 1
a155 1
		} else {
d157 1
a157 1
				unit = unit*10 + ifname[j] - '0';
a159 9
		}
	}
	
	if ((strlen(dev) == 2) &&
	    (dev[0] == 'e') &&
	    ((dev[1] == 'n') || (dev[1] == 't'))) {
		snprintf(interface,sizeof(interface),"ent%d\0",unit);
	} else {
		snprintf(interface,sizeof(interface),"%s%d\0",dev,unit);
d161 6
d168 1
a168 1
	snprintf(interface,sizeof(interface),"%s",ifname);
d171 1
a171 2
	/* Ok, init it just once */
	
d173 2
a174 2
	for (p = iflist; p; p = p->next)  {
		if (strcmp(p->if_name,interface) == 0) {
a175 2
		}
	}
a179 1
	
a183 1

d186 1
a186 1
		deviceOpen(interface,MOP_K_PROTO_RC,TRANS_ETHER);
d189 1
a189 1
		deviceOpen(interface,MOP_K_PROTO_RC,TRANS_8023);
d191 3
a193 3
	case TRANS_ETHER+TRANS_8023:
		deviceOpen(interface,MOP_K_PROTO_RC,TRANS_ETHER);
		deviceOpen(interface,MOP_K_PROTO_RC,TRANS_8023);
d195 2
a196 2
	case TRANS_ETHER+TRANS_8023+TRANS_AND:
		deviceOpen(interface,MOP_K_PROTO_RC,TRANS_ETHER+TRANS_8023);
a202 1

d205 1
a205 1
		deviceOpen(interface,MOP_K_PROTO_DL,TRANS_ETHER);
d208 1
a208 1
		deviceOpen(interface,MOP_K_PROTO_DL,TRANS_8023);
d210 3
a212 3
	case TRANS_ETHER+TRANS_8023:
		deviceOpen(interface,MOP_K_PROTO_DL,TRANS_ETHER);
		deviceOpen(interface,MOP_K_PROTO_DL,TRANS_8023);
d214 2
a215 2
	case TRANS_ETHER+TRANS_8023+TRANS_AND:
		deviceOpen(interface,MOP_K_PROTO_DL,TRANS_ETHER+TRANS_8023);
d231 2
a232 2
	struct sockaddr_dl *sdl;
	struct ifaddrs *ifap, *ifa;
d251 1
a251 1
	struct ifaddrs *ifap, *ifa;
@


1.10
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: device.c,v 1.9 2003/08/31 09:06:46 maja Exp $ */
d28 1
a28 1
static char rcsid[] = "$OpenBSD: device.c,v 1.9 2003/08/31 09:06:46 maja Exp $";
a54 3
	char inbuf[8192];
	struct ifconf ifc;
	struct ifreq *ifr;
a55 2
	int fd;
	int i, len;
@


1.9
log
@Make deviceInitAll work again. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: device.c,v 1.8 2003/08/19 22:19:08 itojun Exp $ */
d28 1
a28 1
static char rcsid[] = "$OpenBSD: device.c,v 1.8 2003/08/19 22:19:08 itojun Exp $";
d47 1
a47 1
 * Return ethernet adress for interface
@


1.8
log
@rewrite SIOCGIFCONF into getifaddrs.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: device.c,v 1.7 2003/06/02 21:38:39 maja Exp $ */
d28 1
a28 1
static char rcsid[] = "$OpenBSD: device.c,v 1.7 2003/06/02 21:38:39 maja Exp $";
d262 1
a262 1
		sdl = (struct sockaddr_dl *)ifa->ifa_next;
@


1.7
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: device.c,v 1.6 2002/09/07 08:09:49 maja Exp $ */
d28 1
a28 1
static char rcsid[] = "$OpenBSD: device.c,v 1.6 2002/09/07 08:09:49 maja Exp $";
d61 1
d63 2
a64 7
	/* We cannot use SIOCGIFADDR on the BPF descriptor.
	   We must instead get all the interfaces with SIOCGIFCONF
	   and find the right one.  */

	/* Use datagram socket to get Ethernet address. */
	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		syslog(LOG_ERR, "deviceEthAddr: socket: %m");
d68 2
a69 12
	ifc.ifc_len = sizeof(inbuf);
	ifc.ifc_buf = inbuf;
	if (ioctl(fd, SIOCGIFCONF, (caddr_t)&ifc) < 0 ||
	    ifc.ifc_len < sizeof(struct ifreq)) {
		syslog(LOG_ERR, "deviceEthAddr: SIOGIFCONF: %m");
		exit(1);
	}
	ifr = ifc.ifc_req;
	for (i = 0; i < ifc.ifc_len;
	     i += len, ifr = (struct ifreq *)((caddr_t)ifr + len)) {
		len = sizeof(ifr->ifr_name) + ifr->ifr_addr.sa_len;
		sdl = (struct sockaddr_dl *)&ifr->ifr_addr;
d73 1
a73 1
		if (!strncmp(ifr->ifr_name, ifname, sizeof(ifr->ifr_name))) {
d75 1
d252 1
a252 4
#ifdef	DEV_NEW_CONF
	char inbuf[8192];
	struct ifconf ifc;
	struct ifreq *ifr;
d254 1
a254 2
	int fd;
	int i, len;
d256 2
a257 2
	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		syslog(LOG_ERR, "deviceInitAll: socket: %m");
d261 2
a262 12
	ifc.ifc_len = sizeof(inbuf);
	ifc.ifc_buf = inbuf;
	if (ioctl(fd, SIOCGIFCONF, (caddr_t)&ifc) < 0 ||
	    ifc.ifc_len < sizeof(struct ifreq)) {
		syslog(LOG_ERR, "deviceInitAll: SIOCGIFCONF: %m");
		exit(1);
	}
	ifr = ifc.ifc_req;
	for (i = 0; i < ifc.ifc_len;
	     i += len, ifr = (struct ifreq *)((caddr_t)ifr + len)) {
		len = sizeof(ifr->ifr_name) + ifr->ifr_addr.sa_len;
		sdl = (struct sockaddr_dl *)&ifr->ifr_addr;
d266 1
a266 5
		if (ioctl(fd, SIOCGIFFLAGS, (caddr_t)ifr) < 0) {
			syslog(LOG_ERR, "deviceInitAll: SIOCGIFFLAGS: %m");
			continue;
		}
		if ((ifr->ifr_flags &
d269 1
a269 1
		deviceInitOne(ifr->ifr_name);
d271 1
a271 1
	(void) close(fd);
d273 1
a273 4
	int fd;
	int n;
	struct ifreq ibuf[8], *ifrp;
	struct ifconf ifc;
d275 2
a276 2
	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		syslog(LOG_ERR, "deviceInitAll: old socket: %m");
d279 5
a283 16
	ifc.ifc_len = sizeof ibuf;
	ifc.ifc_buf = (caddr_t)ibuf;
	if (ioctl(fd, SIOCGIFCONF, (char *)&ifc) < 0 ||
	    ifc.ifc_len < sizeof(struct ifreq)) {
		syslog(LOG_ERR, "deviceInitAll: old SIOCGIFCONF: %m");
		exit(1);
	}
	ifrp = ibuf;
	n = ifc.ifc_len / sizeof(*ifrp);
	for (; --n >= 0; ++ifrp) {
		if (ioctl(fd, SIOCGIFFLAGS, (char *)ifrp) < 0) {
			continue;
		}
		if (/*(ifrp->ifr_flags & IFF_UP) == 0 ||*/
		    ifrp->ifr_flags & IFF_LOOPBACK ||
		    ifrp->ifr_flags & IFF_POINTOPOINT)
d285 1
a285 1
		deviceInitOne(ifrp->ifr_name);
d287 2
a288 3
	
	(void) close(fd);
#endif /* DEV_NEW_CONF */
@


1.6
log
@off by one fix from aaron@@. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: device.c,v 1.5 2002/06/10 21:05:25 maja Exp $ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d28 1
a28 1
static char rcsid[] = "$OpenBSD: device.c,v 1.5 2002/06/10 21:05:25 maja Exp $";
@


1.5
log
@Remove NO__P since __P has been removed. Found by hin@@ -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: device.c,v 1.4 2000/02/20 17:45:33 bitblt Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: device.c,v 1.4 2000/02/20 17:45:33 bitblt Exp $";
d112 1
a112 1
	tmp.if_name[sizeof(tmp.if_name)] = 0;
@


1.4
log
@

string manipluation paranoia changes.  Most probably not exploitable.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.c,v 1.3 1999/03/27 14:31:21 maja Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: device.c,v 1.3 1999/03/27 14:31:21 maja Exp $";
a43 4
#ifdef NO__P
int  mopOpenDL(/* struct if_info *, int */);
int  mopOpenRC(/* struct if_info *, int */);
#else
d46 3
a48 4
#endif
int pfTrans();
int pfInit();
int pfWrite();
@


1.3
log
@Upgrade to 2.5.4. Mopprobe is working again, and some linux support. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: device.c,v 1.2 1996/09/21 19:11:23 maja Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: device.c,v 1.2 1996/09/21 19:11:23 maja Exp $";
d116 2
a117 1
	strcpy(tmp.if_name,ifname);
d144 2
a145 1
		strcpy(p->if_name,tmp.if_name);
d202 1
a202 1
		sprintf(interface,"ent%d\0",unit);
d204 1
a204 1
		sprintf(interface,"%s%d\0",dev,unit);
d207 1
a207 1
	sprintf(interface,"%s",ifname);
@


1.2
log
@Replace $Id with $OpenBSD, 3:rd try. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: device.c,v 1.1.1.1 1996/09/21 13:49:16 maja Exp $";
d161 10
@


1.1
log
@Initial revision
@
text
@d1 2
d33 1
a33 1
static char rcsid[] = "$Id: device.c,v 1.21 1996/08/08 00:00:59 moj Exp $";
@


1.1.1.1
log
@Initial import of mopd-2.5.3. -moj
@
text
@@
