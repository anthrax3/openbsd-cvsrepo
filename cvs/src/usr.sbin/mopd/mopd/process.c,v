head	1.22;
access;
symbols
	OPENBSD_6_1:1.21.0.8
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.12
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.4
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.8
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.6
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.17.0.16
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.12
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.10
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.14.0.8
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.8.0.8
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	MOPD254:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	MOPD253:1.1.1.1
	MAJA:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2017.07.29.07.18.03;	author florian;	state Exp;
branches;
next	1.21;
commitid	B2nY1wH8vA5b25nk;

1.21
date	2015.11.16.23.47.52;	author millert;	state Exp;
branches;
next	1.20;
commitid	HZ87Bb4KdgnmVTiN;

1.20
date	2013.07.05.21.02.07;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.12.16.52.22;	author maja;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.52;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.29.16.26.56;	author maja;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.17.18.55.36;	author maja;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.17.16.23.01;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.15.21.42.53;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.12.20.01.12;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.01.00.56.51;	author avsm;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.21.38.39;	author maja;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.07.07.58.21;	author maja;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.13.10.13.27;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.04.23.46.23;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.04.22.00.07;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.03.23.24.42;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.03.13.55.28;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.28.23.52.58;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.20.17.45.34;	author bitblt;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	96.09.21.19.12.26;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.13.49.17;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.13.49.17;	author maja;	state Exp;
branches;
next	;

1.3.2.1
date	2000.07.05.22.42.20;	author jason;	state Exp;
branches;
next	;


desc
@@


1.22
log
@change if ((a == b)) to if (a == b); silences noisy on-by-default
"equality comparison with extraneous parentheses
[-Wparentheses-equality]" clang warning.
OK deraadt, kettenis
@
text
@/*	$OpenBSD: process.c,v 1.21 2015/11/16 23:47:52 millert Exp $ */

/*
 * Copyright (c) 1993-95 Mats O Jansson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "os.h"
#include "common/common.h"
#include "common/mopdef.h"
#include "common/nmadef.h"
#include "common/get.h"
#include "common/put.h"
#include "common/print.h"
#include "common/pf.h"
#include "common/cmp.h"
#include "common/dl.h"
#include "common/rc.h"
#include "common/file.h"

extern int	DebugFlag;

struct dllist dllist[MAXDL];		/* dump/load list		*/

void
mopProcessInfo(u_char *pkt, int *idx, u_short moplen, struct dllist *dl_rpr,
    int trans)
{
	u_short	itype, tmps;
	u_char	ilen, tmpc, device;

	device = 0;

	switch (trans) {
	case TRANS_ETHER:
		moplen = moplen + 16;
		break;
	case TRANS_8023:
		moplen = moplen + 14;
		break;
	}

	itype = mopGetShort(pkt, idx);

	while (*idx < (int)(moplen)) {
		ilen  = mopGetChar(pkt, idx);
		switch (itype) {
		case 0:
			tmpc = mopGetChar(pkt, idx);
			*idx = *idx + tmpc;
			break;
		case MOP_K_INFO_VER:
			*idx = *idx + 3;
			break;
		case MOP_K_INFO_MFCT:
		case MOP_K_INFO_RTM:
		case MOP_K_INFO_CSZ:
		case MOP_K_INFO_RSZ:
			mopGetShort(pkt, idx);
			break;
		case MOP_K_INFO_CNU:
		case MOP_K_INFO_HWA:
			*idx = *idx + 6;
			break;
		case MOP_K_INFO_TIME:
			*idx = *idx + 10;
			break;
		case MOP_K_INFO_SOFD:
			device = mopGetChar(pkt, idx);
			break;
		case MOP_K_INFO_SFID:
			tmpc = mopGetChar(pkt, idx);
			*idx = *idx + tmpc;
			break;
		case MOP_K_INFO_PRTY:
		case MOP_K_INFO_DLTY:
			mopGetChar(pkt, idx);
			break;
		case MOP_K_INFO_DLBSZ:
			tmps = mopGetShort(pkt, idx);
			dl_rpr->dl_bsz = tmps;
			break;
		default:
			if (((device == NMA_C_SOFD_LCS) ||  /* DECserver 100 */
			     (device == NMA_C_SOFD_DS2) ||  /* DECserver 200 */
			     (device == NMA_C_SOFD_DP2) ||  /* DECserver 250 */
			     (device == NMA_C_SOFD_DS3)) && /* DECserver 300 */
			    ((itype > 101) && (itype < 107))) {
				switch (itype) {
				case 102:
				case 103:
				case 105:
				case 106:
					*idx = *idx + ilen;
					break;
				case 104:
					mopGetShort(pkt, idx);
					break;
				}
			} else
				*idx = *idx + ilen;
		}
		itype = mopGetShort(pkt, idx);
	}
}

void
mopSendASV(u_char *dst, u_char *src, struct if_info *ii, int trans)
{
	u_char	 pkt[200];
	int	 idx;

	idx = 0;
	mopPutHeader(pkt, &idx, dst, src, MOP_K_PROTO_DL, trans);

	mopPutChar(pkt, &idx, MOP_K_CODE_ASV);

	mopPutLength(pkt, trans, idx);

	if (DebugFlag == DEBUG_ONELINE)
		mopPrintOneline(stdout, pkt, trans);

	if (DebugFlag >= DEBUG_HEADER) {
		mopPrintHeader(stdout, pkt, trans);
		mopPrintMopHeader(stdout, pkt, trans);
	}

	if (DebugFlag >= DEBUG_INFO)
		mopDumpDL(stdout, pkt, trans);

	if (pfWrite(ii->fd, pkt, idx, trans) != idx)
		if (DebugFlag)
			warnx("pfWrite() error");
}

void
mopStartLoad(u_char *dst, u_char *src, struct dllist *dl_rpr, int trans)
{
	int	 len;
	int	 i, slot;
	u_char	 pkt[BUFSIZE];
	int	 idx;
	u_char	 mopcode = MOP_K_CODE_MLD;

	slot = -1;

	/* Look if we have a non terminated load, if so, use it's slot */
	for (i = 0; i < MAXDL && slot == -1; i++)
		if (dllist[i].status != DL_STATUS_FREE)
			if (mopCmpEAddr(dllist[i].eaddr, dst) == 0)
				slot = i;

	/* If no slot yet, then find first free */
	for (i = 0; slot == -1 && i < MAXDL; i++)
		if (dllist[i].status == DL_STATUS_FREE) {
			slot = i;
			bcopy(dst,  dllist[i].eaddr, 6);
		}

	/* If no slot yet, then return. No slot is free */	
	if (slot == -1)
		return;

	/* Ok, save info from RPR */
	dllist[slot] = *dl_rpr;
	dllist[slot].status = DL_STATUS_READ_IMGHDR;

	/* Get Load and Transfer Address. */
	GetFileInfo(&dllist[slot], 0);

	dllist[slot].nloadaddr = dllist[slot].loadaddr;
	dllist[slot].lseek     = lseek(dllist[slot].ldfd, 0L, SEEK_CUR);
	dllist[slot].a_lseek   = 0;

	dllist[slot].count     = 0;
	if ((dllist[slot].dl_bsz >= 1492) || (dllist[slot].dl_bsz == 0))
		dllist[slot].dl_bsz = 1492;
	if (dllist[slot].dl_bsz == 1030)	/* VS/uVAX 2000 needs this */
		dllist[slot].dl_bsz = 1000;
	if (trans == TRANS_8023)
		dllist[slot].dl_bsz = dllist[slot].dl_bsz - 8;

	idx = 0;
	mopPutHeader(pkt, &idx, dst, src, MOP_K_PROTO_DL, trans);
	mopPutChar(pkt, &idx, mopcode);

	mopPutChar(pkt, &idx, dllist[slot].count);
	mopPutLong(pkt, &idx, dllist[slot].loadaddr);

	len = mopFileRead(&dllist[slot], &pkt[idx]);

	dllist[slot].nloadaddr = dllist[slot].loadaddr + len;
	idx = idx + len;

	mopPutLength(pkt, trans, idx);

	if (DebugFlag == DEBUG_ONELINE)
		mopPrintOneline(stdout, pkt, trans);

	if (DebugFlag >= DEBUG_HEADER) {
		mopPrintHeader(stdout, pkt, trans);
		mopPrintMopHeader(stdout, pkt, trans);
	}

	if (DebugFlag >= DEBUG_INFO)
		mopDumpDL(stdout, pkt, trans);

	if (pfWrite(dllist[slot].ii->fd, pkt, idx, trans) != idx)
		if (DebugFlag)
			warnx("pfWrite() error");

	dllist[slot].status = DL_STATUS_SENT_MLD;
}

void
mopNextLoad(u_char *dst, u_char *src, u_char new_count, int trans)
{
	int	 len;
	int	 i, slot;
	u_char	 pkt[BUFSIZE];
	int	 idx, pidx;
	char	 line[100],hname[17],*p;

	slot = -1;

	for (i = 0; i < MAXDL && slot == -1; i++)
		if (dllist[i].status != DL_STATUS_FREE) {
			if (mopCmpEAddr(dst, dllist[i].eaddr) == 0)
				slot = i;
		}

	/* If no slot yet, then return. No slot is free */	
	if (slot == -1)
		return;

	if (new_count == ((dllist[slot].count+1) % 256)) {
		dllist[slot].loadaddr = dllist[slot].nloadaddr;
		dllist[slot].count    = new_count;
	} else
		return;

	if (dllist[slot].status == DL_STATUS_SENT_PLT) {
		close(dllist[slot].ldfd);
		dllist[slot].ldfd = 0;
		dllist[slot].status = DL_STATUS_FREE;
		snprintf(line, sizeof(line),
		    "%x:%x:%x:%x:%x:%x Load completed",
		    dst[0], dst[1], dst[2], dst[3], dst[4], dst[5]);
		syslog(LOG_INFO, "%s", line);
		return;
	}

	dllist[slot].lseek = lseek(dllist[slot].ldfd, 0L, SEEK_CUR);

	if (dllist[slot].dl_bsz >= 1492)
		dllist[slot].dl_bsz = 1492;

	idx = 0;
	mopPutHeader(pkt, &idx, dst, src, MOP_K_PROTO_DL, trans);
	pidx = idx;
	mopPutChar(pkt, &idx, MOP_K_CODE_MLD);
	mopPutChar(pkt, &idx, dllist[slot].count);
	mopPutLong(pkt, &idx, dllist[slot].loadaddr);

	len = mopFileRead(&dllist[slot], &pkt[idx]);

	if (len > 0) {
		dllist[slot].nloadaddr = dllist[slot].loadaddr + len;
		idx = idx + len;

		mopPutLength(pkt, trans, idx);
	} else {
		if (len == 0) {
			i = gethostname(hname, sizeof(hname));
			p = strchr(hname, '.');
			if (p != NULL)
				*p = 0;

			idx = pidx;
			mopPutChar(pkt, &idx, MOP_K_CODE_PLT);
			mopPutChar(pkt, &idx, dllist[slot].count);
			mopPutChar(pkt, &idx, MOP_K_PLTP_HSN);
			mopPutChar(pkt, &idx, (int)strlen(hname));
			mopPutMulti(pkt, &idx, (u_char *)hname, (int)strlen(hname));
			mopPutChar(pkt, &idx, MOP_K_PLTP_HSA);
			mopPutChar(pkt, &idx, 6);
			mopPutMulti(pkt, &idx, src, 6);
			mopPutChar(pkt, &idx, MOP_K_PLTP_HST);
			mopPutTime(pkt, &idx, 0);
			mopPutChar(pkt, &idx, 0);
			mopPutLong(pkt, &idx, dllist[slot].xferaddr);

			mopPutLength(pkt, trans, idx);

			dllist[slot].status = DL_STATUS_SENT_PLT;
		} else {
			dllist[slot].status = DL_STATUS_FREE;
			return;
		}
	}

	if (DebugFlag == DEBUG_ONELINE)
		mopPrintOneline(stdout, pkt, trans);

	if (DebugFlag >= DEBUG_HEADER) {
		mopPrintHeader(stdout, pkt, trans);
		mopPrintMopHeader(stdout, pkt, trans);
	}

	if (DebugFlag >= DEBUG_INFO)
		mopDumpDL(stdout, pkt, trans);

	if (pfWrite(dllist[slot].ii->fd, pkt, idx, trans) != idx)
		if (DebugFlag)
			warnx("pfWrite() error");
}

/* ARGSUSED */
void
mopProcessDL(FILE *fd, struct if_info *ii, u_char *pkt, int *idx, u_char *dst,
    u_char *src, int trans, u_short len)
{
	u_char		tmpc;
	u_short		moplen;
	u_char		pfile[129], mopcode;
	char		filename[FILENAME_MAX];
	char		line[100];
	int		i, nfd;
	struct dllist	dl, *dl_rpr;
	u_char		load;

	if (DebugFlag == DEBUG_ONELINE)
		mopPrintOneline(stdout, pkt, trans);

	if (DebugFlag >= DEBUG_HEADER) {
		mopPrintHeader(stdout, pkt, trans);
		mopPrintMopHeader(stdout, pkt, trans);
	}

	if (DebugFlag >= DEBUG_INFO)
		mopDumpDL(stdout, pkt, trans);

	moplen  = mopGetLength(pkt, trans);
	mopcode = mopGetChar(pkt, idx);

	switch (mopcode) {
	case MOP_K_CODE_MLT:
		break;
	case MOP_K_CODE_DCM:
		break;
	case MOP_K_CODE_MLD:
		break;
	case MOP_K_CODE_ASV:
		break;
	case MOP_K_CODE_RMD:
		break;
	case MOP_K_CODE_RPR:
		mopGetChar(pkt, idx);			/* Device Type */
		tmpc = mopGetChar(pkt, idx);		/* Format Version */
		if ((tmpc != MOP_K_RPR_FORMAT) &&
		    (tmpc != MOP_K_RPR_FORMAT_V3)) {
			fprintf(stderr, "mopd: Unknown RPR Format (%d) from ",
			    tmpc);
			mopPrintHWA(stderr, src);
			fprintf(stderr, "\n");
		}

		mopGetChar(pkt, idx);			/* Program Type */

		tmpc = mopGetChar(pkt, idx);		/* Software ID Len */
		if (tmpc > sizeof(pfile) - 1)
			return;
		for (i = 0; i < tmpc; i++) {
			pfile[i] = mopGetChar(pkt, idx);
			pfile[i+1] = '\0';
		}

		if (tmpc == 0) {
			/* In a normal implementation of a MOP Loader this */
			/* would cause a question to NML (DECnet) if this  */
			/* node is known and if so what image to load. But */
			/* we don't have DECnet so we don't have anybody   */
			/* to ask. My solution is to use the ethernet addr */
			/* as filename. Implementing a database would be   */
			/* overkill.					   */
			snprintf((char *)pfile, sizeof pfile,
			    "%02x%02x%02x%02x%02x%02x%c",
			    src[0], src[1], src[2], src[3], src[4], src[5], 0);
		}

		mopGetChar(pkt, idx);			/* Processor */

		dl_rpr = &dl;
		bzero(dl_rpr, sizeof(*dl_rpr));
		dl_rpr->ii = ii;
		bcopy(src, dl_rpr->eaddr, 6);
		mopProcessInfo(pkt, idx, moplen, dl_rpr, trans);

		snprintf(filename, sizeof(filename), "%s.SYS", pfile);
		if ((mopCmpEAddr(dst, dl_mcst) == 0)) {
			if ((nfd = open(filename, O_RDONLY, 0)) != -1) {
				close(nfd);
				mopSendASV(src, ii->eaddr, ii, trans);
				snprintf(line, sizeof(line),
				    "%x:%x:%x:%x:%x:%x (%d) Do you have %s? "
				    "(Yes)", src[0], src[1], src[2], src[3],
				    src[4], src[5], trans, pfile);
			} else {
				snprintf(line, sizeof(line),
				    "%x:%x:%x:%x:%x:%x (%d) Do you have %s? "
				    "(No)", src[0], src[1], src[2], src[3],
				    src[4], src[5], trans, pfile);
			}
			syslog(LOG_INFO, "%s", line);
		} else {
			if ((mopCmpEAddr(dst, ii->eaddr) == 0)) {
				dl_rpr->ldfd = open(filename, O_RDONLY, 0);
				mopStartLoad(src, ii->eaddr, dl_rpr, trans);
				snprintf(line, sizeof(line),
				    "%x:%x:%x:%x:%x:%x Send me %s",
				    src[0], src[1], src[2], src[3], src[4],
				    src[5], pfile);
				syslog(LOG_INFO, "%s", line);
			}
		}
		break;
	case MOP_K_CODE_RML:
		load = mopGetChar(pkt, idx);		/* Load Number	*/
		mopGetChar(pkt, idx);			/* Error	*/
		if ((mopCmpEAddr(dst, ii->eaddr) == 0))
			mopNextLoad(src, ii->eaddr, load, trans);
		break;
	case MOP_K_CODE_RDS:
		break;
	case MOP_K_CODE_MDD:
		break;
	case MOP_K_CODE_CCP:
		break;
	case MOP_K_CODE_PLT:
		break;
	default:
		break;
	}
}

/* ARGSUSED */
void
mopProcessRC(FILE *fd, struct if_info *ii, u_char *pkt, int *idx, u_char dst,
    u_char *src, int trans, u_short len)
{
	u_char		tmpc;
	u_short		tmps, moplen = 0;
	u_char		mopcode;
	struct dllist	dl, *dl_rpr;

	if (DebugFlag == DEBUG_ONELINE)
		mopPrintOneline(stdout, pkt, trans);

	if (DebugFlag >= DEBUG_HEADER) {
		mopPrintHeader(stdout, pkt, trans);
		mopPrintMopHeader(stdout, pkt, trans);
	}

	if (DebugFlag >= DEBUG_INFO)
		mopDumpRC(stdout, pkt, trans);

	moplen  = mopGetLength(pkt, trans);
	mopcode = mopGetChar(pkt, idx);

	switch (mopcode) {
	case MOP_K_CODE_RID:
		break;
	case MOP_K_CODE_BOT:
		break;
	case MOP_K_CODE_SID:
		tmpc = mopGetChar(pkt, idx);		/* Reserved */

		if ((DebugFlag >= DEBUG_INFO))
			fprintf(stderr, "Reserved     :   %02x\n", tmpc);

		tmps = mopGetShort(pkt, idx);		/* Receipt # */
		if ((DebugFlag >= DEBUG_INFO))
			fprintf(stderr, "Receipt Nbr  : %04x\n", tmps);

		dl_rpr = &dl;
		bzero(dl_rpr, sizeof(*dl_rpr));
		dl_rpr->ii = ii;
		bcopy(src, dl_rpr->eaddr, 6);
		mopProcessInfo(pkt, idx, moplen, dl_rpr, trans);
		break;
	case MOP_K_CODE_RQC:
		break;
	case MOP_K_CODE_CNT:
		break;
	case MOP_K_CODE_RVC:
		break;
	case MOP_K_CODE_RLC:
		break;
	case MOP_K_CODE_CCP:
		break;
	case MOP_K_CODE_CRA:
		break;
	default:
		break;
	}
}
@


1.21
log
@Replace remaining calls to index(3) with strchr(3).  OK jca@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.20 2013/07/05 21:02:07 miod Exp $ */
d139 1
a139 1
	if ((DebugFlag == DEBUG_ONELINE))
d142 1
a142 1
	if ((DebugFlag >= DEBUG_HEADER)) {
d147 1
a147 1
	if ((DebugFlag >= DEBUG_INFO))
d216 1
a216 1
	if ((DebugFlag == DEBUG_ONELINE))
d219 1
a219 1
	if ((DebugFlag >= DEBUG_HEADER)) {
d224 1
a224 1
	if ((DebugFlag >= DEBUG_INFO))
d255 1
a255 1
	if ((new_count == ((dllist[slot].count+1) % 256))) {
d321 1
a321 1
	if ((DebugFlag == DEBUG_ONELINE))
d324 1
a324 1
	if ((DebugFlag >= DEBUG_HEADER)) {
d329 1
a329 1
	if ((DebugFlag >= DEBUG_INFO))
d351 1
a351 1
	if ((DebugFlag == DEBUG_ONELINE))
d354 1
a354 1
	if ((DebugFlag >= DEBUG_HEADER)) {
d359 1
a359 1
	if ((DebugFlag >= DEBUG_INFO))
d475 1
a475 1
	if ((DebugFlag == DEBUG_ONELINE))
d478 1
a478 1
	if ((DebugFlag >= DEBUG_HEADER)) {
d483 1
a483 1
	if ((DebugFlag >= DEBUG_INFO))
@


1.20
log
@Teach mopd and mopa.out about ELF files, and allow forthcoming VAX ELF boot
blocks to be converted to working mop binaries. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.19 2009/11/12 16:52:22 maja Exp $ */
d294 1
a294 1
			p = index(hname, '.');
@


1.19
log
@Make life easier for parfait. I corporation with deraadt. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.18 2009/10/27 23:59:52 deraadt Exp $ */
d188 1
a188 5
	GetFileInfo(dllist[slot].ldfd, &dllist[slot].loadaddr,
	    &dllist[slot].xferaddr, &dllist[slot].aout,
	    &dllist[slot].a_text, &dllist[slot].a_text_fill,
	    &dllist[slot].a_data, &dllist[slot].a_data_fill,
	    &dllist[slot].a_bss,  &dllist[slot].a_bss_fill, 0);
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.17 2006/04/29 16:26:56 maja Exp $ */
d167 1
a167 1
	for (i = 0; i < MAXDL; i++)
d173 5
a177 7
	if (slot == -1)
		for (i = 0; i < MAXDL; i++)
			if (dllist[i].status == DL_STATUS_FREE)
				if (slot == -1) {
					slot = i;
					bcopy(dst,  dllist[i].eaddr, 6);
				}
d249 1
a249 1
	for (i = 0; i < MAXDL; i++)
@


1.17
log
@Change the compile time option -DINFO into a runtime option to get ride
of some lint warnings. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.16 2006/04/17 18:55:36 maja Exp $ */
a25 5

#ifndef lint
static const char rcsid[] =
    "$OpenBSD: process.c,v 1.16 2006/04/17 18:55:36 maja Exp $";
#endif
@


1.16
log
@Remove 'ipc' in PLT message and replace it with current hostname.
Some more code cleanup and make lint happier. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.15 2006/04/17 16:23:01 deraadt Exp $ */
d29 1
a29 1
    "$OpenBSD: process.c,v 1.15 2006/04/17 16:23:01 deraadt Exp $";
d199 1
a199 1
	    &dllist[slot].a_bss,  &dllist[slot].a_bss_fill);
@


1.15
log
@more cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.14 2004/04/15 21:42:53 henning Exp $ */
d29 1
a29 1
    "$OpenBSD: process.c,v 1.14 2004/04/15 21:42:53 henning Exp $";
a44 1
extern u_char	buf[];
d50 1
a50 1
mopProcessInfo(u_char *pkt, int *index, u_short moplen, struct dllist *dl_rpr,
a54 1
	u_char	uc1, uc2, uc3, *ucp;
d67 1
a67 1
	itype = mopGetShort(pkt, index);
d69 2
a70 2
	while (*index < (int)(moplen)) {
		ilen  = mopGetChar(pkt, index);
d73 2
a74 2
			tmpc  = mopGetChar(pkt, index);
			*index = *index + tmpc;
d77 1
a77 3
			uc1 = mopGetChar(pkt, index);
			uc2 = mopGetChar(pkt, index);
			uc3 = mopGetChar(pkt, index);
a79 5
			tmps = mopGetShort(pkt, index);
			break;
		case MOP_K_INFO_CNU:
			ucp = pkt + *index; *index = *index + 6;
			break;
a80 2
			tmps = mopGetShort(pkt, index);
			break;
a81 2
			tmps = mopGetShort(pkt, index);
			break;
d83 1
a83 1
			tmps = mopGetShort(pkt, index);
d85 1
d87 1
a87 1
			ucp = pkt + *index; *index = *index + 6;
d90 1
a90 1
			ucp = pkt + *index; *index = *index + 10;
d93 1
a93 1
			device = mopGetChar(pkt, index);
d96 2
a97 2
			tmpc = mopGetChar(pkt, index);
			ucp = pkt + *index; *index = *index + tmpc;
a99 2
			tmpc = mopGetChar(pkt, index);
			break;
d101 1
a101 1
			tmpc = mopGetChar(pkt, index);
d104 1
a104 1
			tmps = mopGetShort(pkt, index);
d108 4
a111 4
			if (((device = NMA_C_SOFD_LCS) ||   /* DECserver 100 */
			    (device = NMA_C_SOFD_DS2) ||   /* DECserver 200 */
			    (device = NMA_C_SOFD_DP2) ||   /* DECserver 250 */
			    (device = NMA_C_SOFD_DS3)) &&  /* DECserver 300 */
a114 3
					ucp = pkt + *index;
					*index = *index + ilen;
					break;
d116 3
a118 2
					ucp = pkt + *index;
					*index = *index + ilen;
d121 1
a121 9
					tmps = mopGetShort(pkt, index);
					break;
				case 105:
					ucp = pkt + *index;
					*index = *index + ilen;
					break;
				case 106:
					ucp = pkt + *index;
					*index = *index + ilen;
d125 1
a125 1
				ucp = pkt + *index; *index = *index + ilen;
d127 1
a127 1
		itype = mopGetShort(pkt, index);
d134 2
a135 4
	u_char	 pkt[200], *p;
	int	 index;
	u_char	 mopcode = MOP_K_CODE_ASV;
	u_short	 newlen = 0, ptype = MOP_K_PROTO_DL;
d137 2
a138 2
	index = 0;
	mopPutHeader(pkt, &index, dst, src, ptype, trans);
d140 1
a140 2
	p = &pkt[index];
	mopPutChar(pkt, &index, mopcode);
d142 1
a142 2
	mopPutLength(pkt, trans, index);
	newlen = mopGetLength(pkt, trans);
d155 1
a155 1
	if (pfWrite(ii->fd, pkt, index, trans) != index)
d165 2
a166 2
	u_char	 pkt[BUFSIZE], *p;
	int	 index;
a167 1
	u_short	 newlen, ptype = MOP_K_PROTO_DL;
d213 3
a215 4
	index = 0;
	mopPutHeader(pkt, &index, dst, src, ptype, trans);
	p = &pkt[index];
	mopPutChar(pkt, &index, mopcode);
d217 2
a218 2
	mopPutChar(pkt, &index, dllist[slot].count);
	mopPutLong(pkt, &index, dllist[slot].loadaddr);
d220 1
a220 1
	len = mopFileRead(&dllist[slot], &pkt[index]);
d223 1
a223 1
	index = index + len;
d225 1
a225 2
	mopPutLength(pkt, trans, index);
	newlen = mopGetLength(pkt, trans);
d238 1
a238 1
	if (pfWrite(dllist[slot].ii->fd, pkt, index, trans) != index)
d250 3
a252 5
	u_char	 pkt[BUFSIZE], *p;
	int	 index, pindex;
	char	 line[100];
	u_short  newlen = 0, ptype = MOP_K_PROTO_DL;
	u_char	 mopcode;
d288 6
a293 8
	index = 0;
	mopPutHeader(pkt, &index, dst, src, ptype, trans);
	p = &pkt[index];
	mopcode = MOP_K_CODE_MLD;
	pindex = index;
	mopPutChar(pkt, &index, mopcode);
	mopPutChar(pkt, &index, dllist[slot].count);
	mopPutLong(pkt, &index, dllist[slot].loadaddr);
d295 1
a295 1
	len = mopFileRead(&dllist[slot], &pkt[index]);
d299 1
a299 1
		index = index + len;
d301 1
a301 2
		mopPutLength(pkt, trans, index);
		newlen = mopGetLength(pkt, trans);
d304 18
a321 14
			index = pindex;
			mopcode = MOP_K_CODE_PLT;
			mopPutChar(pkt, &index, mopcode);
			mopPutChar(pkt, &index, dllist[slot].count);
			mopPutChar(pkt, &index, MOP_K_PLTP_HSN);
			mopPutChar(pkt, &index, 3);
			mopPutMulti(pkt, &index, (u_char *) "ipc", 3);
			mopPutChar(pkt, &index, MOP_K_PLTP_HSA);
			mopPutChar(pkt, &index, 6);
			mopPutMulti(pkt, &index, src, 6);
			mopPutChar(pkt, &index, MOP_K_PLTP_HST);
			mopPutTime(pkt, &index, 0);
			mopPutChar(pkt, &index, 0);
			mopPutLong(pkt, &index, dllist[slot].xferaddr);
d323 1
a323 2
			mopPutLength(pkt, trans, index);
			newlen = mopGetLength(pkt, trans);
d343 1
a343 1
	if (pfWrite(dllist[slot].ii->fd, pkt, index, trans) != index)
d348 1
d350 1
a350 1
mopProcessDL(FILE *fd, struct if_info *ii, u_char *pkt, int *index, u_char *dst,
d358 1
a358 1
	int		i, nfd, iindex;
d360 1
a360 1
	u_char		rpr_pgty, load;
d374 1
a374 1
	mopcode = mopGetChar(pkt, index);
d388 2
a389 2
		tmpc = mopGetChar(pkt, index);		/* Device Type */
		tmpc = mopGetChar(pkt, index);		/* Format Version */
d398 1
a398 1
		rpr_pgty = mopGetChar(pkt, index);	/* Program Type */
d400 1
a400 1
		tmpc = mopGetChar(pkt, index);		/* Software ID Len */
d404 1
a404 1
			pfile[i] = mopGetChar(pkt, index);
d421 1
a421 1
		tmpc = mopGetChar(pkt, index);		/* Processor */
a422 1
		iindex = *index;
d427 1
a427 1
		mopProcessInfo(pkt, index, moplen, dl_rpr, trans);
d458 2
a459 2
		load = mopGetChar(pkt, index);		/* Load Number	*/
		tmpc = mopGetChar(pkt, index);		/* Error	*/
d476 1
d478 1
a478 1
mopProcessRC(FILE *fd, struct if_info *ii, u_char *pkt, int *index, u_char dst,
d498 1
a498 1
	mopcode = mopGetChar(pkt, index);
d506 1
a506 1
		tmpc = mopGetChar(pkt, index);		/* Reserved */
d511 1
a511 1
		tmps = mopGetShort(pkt, index);		/* Receipt # */
d513 1
a513 1
			fprintf(stderr, "Receipt Nbr  : %04x\n", tmpc);
d519 1
a519 1
		mopProcessInfo(pkt, index, moplen, dl_rpr, trans);
@


1.14
log
@chroot and drop privileges to _mopd:_mopd after initialization.
testing and ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.13 2004/04/12 20:01:12 henning Exp $ */
d27 1
a27 1
#ifndef LINT
d29 1
a29 1
    "$OpenBSD: process.c,v 1.13 2004/04/12 20:01:12 henning Exp $";
@


1.13
log
@~1000 lines worth of ansi, KNF, various cleaning, replacing a homebrown
daemon() equivalent and such things, theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.12 2003/12/01 00:56:51 avsm Exp $ */
d29 1
a29 1
    "$OpenBSD: process.c,v 1.12 2003/12/01 00:56:51 avsm Exp $";
d462 1
a462 2
		snprintf(filename, sizeof(filename), "%s/%s.SYS",
		    MOP_FILE_PATH, pfile);
@


1.12
log
@-Wall cleanup: trim unused vars, right format strings, constify rcsids,
braces where needed, add missing prototypes.

tested and ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.11 2003/06/02 21:38:39 maja Exp $ */
d28 2
a29 1
static const char rcsid[] = "$OpenBSD: process.c,v 1.11 2003/06/02 21:38:39 maja Exp $";
d51 2
a52 5
mopProcessInfo(pkt,index,moplen,dl_rpr,trans)
	u_char  *pkt;
	int     *index, trans;
	u_short moplen;
	struct  dllist  *dl_rpr;
d54 4
a57 4
        u_short itype,tmps;
	u_char  ilen ,tmpc,device;
	u_char  uc1,uc2,uc3,*ucp;
	
d60 1
a60 1
	switch(trans) {
d69 1
a69 1
	itype = mopGetShort(pkt,index); 
d72 1
a72 1
		ilen  = mopGetChar(pkt,index);
d75 1
a75 1
			tmpc  = mopGetChar(pkt,index);
d79 3
a81 3
			uc1 = mopGetChar(pkt,index);
			uc2 = mopGetChar(pkt,index);
			uc3 = mopGetChar(pkt,index);
d84 1
a84 1
			tmps = mopGetShort(pkt,index);
d90 1
a90 1
			tmps = mopGetShort(pkt,index);
d93 1
a93 1
			tmps = mopGetShort(pkt,index);
d96 1
a96 1
			tmps = mopGetShort(pkt,index);
d105 1
a105 1
			device = mopGetChar(pkt,index);
d108 1
a108 1
			tmpc = mopGetChar(pkt,index);
d112 1
a112 1
			tmpc = mopGetChar(pkt,index);
d115 1
a115 1
			tmpc = mopGetChar(pkt,index);
d118 1
a118 1
			tmps = mopGetShort(pkt,index);
d123 4
a126 5
			     (device = NMA_C_SOFD_DS2) ||   /* DECserver 200 */
			     (device = NMA_C_SOFD_DP2) ||   /* DECserver 250 */
			     (device = NMA_C_SOFD_DS3)) &&  /* DECserver 300 */
			    ((itype > 101) && (itype < 107)))
			{
d137 1
a137 1
					tmps = mopGetShort(pkt,index);
d147 2
a148 2
				};
			} else {
a149 1
			};
d151 2
a152 2
		itype = mopGetShort(pkt,index); 
        }
d156 1
a156 4
mopSendASV(dst, src, ii, trans)
	u_char	*dst,*src;
	struct if_info *ii;
	int	 trans;
d158 1
a158 1
        u_char	 pkt[200], *p;
d161 1
a161 1
	u_short	 newlen = 0,ptype = MOP_K_PROTO_DL;
d167 2
a168 2
	mopPutChar(pkt,&index,mopcode);
	
d172 1
a172 1
	if ((DebugFlag == DEBUG_ONELINE)) {
a173 1
	}
d179 2
a180 2
	
	if ((DebugFlag >= DEBUG_INFO)) {
a181 1
	}
d183 3
a185 5
	if (pfWrite(ii->fd, pkt, index, trans) != index) {
		if (DebugFlag) {
			(void)fprintf(stderr, "error pfWrite()\n");
		}
	}
d189 1
a189 4
mopStartLoad(dst, src, dl_rpr, trans)
	u_char	*dst,*src;
	struct dllist *dl_rpr;
	int	 trans;
d196 1
a196 1
	u_short	 newlen,ptype = MOP_K_PROTO_DL;
d199 1
a199 1
	
d201 4
a205 8
	for (i = 0; i < MAXDL; i++) {
		if (dllist[i].status != DL_STATUS_FREE) {
			if (mopCmpEAddr(dllist[i].eaddr,dst) == 0) {
				slot = i;
			}
		}
	}
	
d207 3
a209 4

	if (slot == -1) {
		for (i = 0; i < MAXDL; i++) {
			if (dllist[i].status == DL_STATUS_FREE) {
d212 1
a212 2
					bcopy((char *)dst,
					      (char *)dllist[i].eaddr, 6);
a213 3
			}
		}
	}
d215 1
a215 2
	/* If no slot yet, then return. No slot is free */
	
d218 1
a218 1
	
a219 1

d222 1
a222 1
	
d224 5
a228 8

	GetFileInfo(dllist[slot].ldfd,
		    &dllist[slot].loadaddr,
		    &dllist[slot].xferaddr,
		    &dllist[slot].aout,
		    &dllist[slot].a_text, &dllist[slot].a_text_fill,
		    &dllist[slot].a_data, &dllist[slot].a_data_fill,
		    &dllist[slot].a_bss,  &dllist[slot].a_bss_fill);
d231 1
a231 1
	dllist[slot].lseek     = lseek(dllist[slot].ldfd,0L,SEEK_CUR);
d245 1
a245 1
	mopPutChar (pkt,&index,mopcode);
d247 2
a248 2
	mopPutChar (pkt,&index,dllist[slot].count);
	mopPutLong (pkt,&index,dllist[slot].loadaddr);
d250 1
a250 1
	len = mopFileRead(&dllist[slot],&pkt[index]);
d258 1
a258 1
	if ((DebugFlag == DEBUG_ONELINE)) {
a259 1
	}
d265 2
a266 2
	
	if ((DebugFlag >= DEBUG_INFO)) {
a267 1
	}
d269 3
a271 5
	if (pfWrite(dllist[slot].ii->fd, pkt, index, trans) != index) {
		if (DebugFlag) {
			(void)fprintf(stderr, "error pfWrite()\n");
		}
	}
d277 1
a277 3
mopNextLoad(dst, src, new_count, trans)
	u_char	*dst,*src,new_count;
	int	 trans;
d284 1
a284 1
	u_short  newlen = 0,ptype = MOP_K_PROTO_DL;
d288 2
a289 2
	
	for (i = 0; i < MAXDL; i++) {
d291 1
a291 1
			if (mopCmpEAddr(dst,dllist[i].eaddr) == 0)
a293 1
	}
d295 1
a295 2
	/* If no slot yet, then return. No slot is free */
	
d302 1
a302 1
	} else {
a303 1
	}
d309 3
a311 3
		snprintf(line,sizeof(line),
			"%x:%x:%x:%x:%x:%x Load completed",
			dst[0],dst[1],dst[2],dst[3],dst[4],dst[5]);
d316 2
a317 2
	dllist[slot].lseek     = lseek(dllist[slot].ldfd,0L,SEEK_CUR);
	
d320 1
a320 1
	
d326 7
a332 8
	mopPutChar (pkt,&index,mopcode);
	mopPutChar (pkt,&index,dllist[slot].count);
	mopPutLong (pkt,&index,dllist[slot].loadaddr);

	len = mopFileRead(&dllist[slot],&pkt[index]);
	
	if (len > 0 ) {
			
a337 1
		
d342 12
a353 12
			mopPutChar (pkt,&index,mopcode);
			mopPutChar (pkt,&index,dllist[slot].count);
			mopPutChar (pkt,&index,MOP_K_PLTP_HSN);
 			mopPutChar (pkt,&index,3);
			mopPutMulti(pkt,&index,(u_char *) "ipc",3);
			mopPutChar (pkt,&index,MOP_K_PLTP_HSA);
			mopPutChar (pkt,&index,6);
			mopPutMulti(pkt,&index,src,6);
			mopPutChar (pkt,&index,MOP_K_PLTP_HST);
			mopPutTime (pkt,&index, 0);
			mopPutChar (pkt,&index,0);
			mopPutLong (pkt,&index,dllist[slot].xferaddr);
d357 1
a357 1
		
d365 1
a365 1
	if ((DebugFlag == DEBUG_ONELINE)) {
a366 1
	}
d372 2
a373 2
	
	if ((DebugFlag >= DEBUG_INFO)) {
a374 1
	}
d376 3
a378 5
	if (pfWrite(dllist[slot].ii->fd, pkt, index, trans) != index) {
		if (DebugFlag) {
			(void)fprintf(stderr, "error pfWrite()\n");
		}
	}
d382 2
a383 6
mopProcessDL(fd, ii, pkt, index, dst, src, trans, len)
	FILE	*fd;
	struct if_info *ii;
	u_char	*pkt, *dst, *src;
	int	*index, trans;
	u_short	 len;
d385 8
a392 8
	u_char  tmpc;
	u_short moplen;
	u_char  pfile[129], mopcode;
	char    filename[FILENAME_MAX];
	char    line[100];
	int     i,nfd,iindex;
	struct dllist dl,*dl_rpr;
	u_char  rpr_pgty,load;
d394 1
a394 1
	if ((DebugFlag == DEBUG_ONELINE)) {
a395 1
	}
d401 2
a402 2
	
	if ((DebugFlag >= DEBUG_INFO)) {
a403 1
	}
d406 1
a406 1
	mopcode = mopGetChar(pkt,index);
d420 2
a421 4
		
		tmpc = mopGetChar(pkt,index);		/* Device Type */
		
		tmpc = mopGetChar(pkt,index);		/* Format Version */
d424 4
a427 3
			(void)fprintf(stderr,"mopd: Unknown RPR Format (%d) from ",tmpc);
			mopPrintHWA(stderr,src);
			(void)fprintf(stderr,"\n");
d429 4
a432 4
		
		rpr_pgty = mopGetChar(pkt,index);	/* Program Type */
		
		tmpc = mopGetChar(pkt,index);		/* Software ID Len */
d436 1
a436 1
			pfile[i] = mopGetChar(pkt,index);
d448 1
a448 1
			snprintf((char *)pfile,sizeof pfile,
d450 1
a450 1
			    src[0],src[1],src[2],src[3],src[4],src[5],0);
d452 3
a454 3
		
		tmpc = mopGetChar(pkt,index);		/* Processor */
	
d457 1
a457 1
		bzero(dl_rpr,sizeof(*dl_rpr));
d459 2
a460 2
		bcopy((char *)src, (char *)(dl_rpr->eaddr), 6);
		mopProcessInfo(pkt,index,moplen,dl_rpr,trans);
d462 3
a464 3
		snprintf(filename,sizeof(filename),
			"%s/%s.SYS", MOP_FILE_PATH, pfile);
		if ((mopCmpEAddr(dst,dl_mcst) == 0)) {
d468 4
a471 4
				snprintf(line,sizeof(line),
					"%x:%x:%x:%x:%x:%x (%d) Do you have %s? (Yes)",
					src[0],src[1],src[2],
					src[3],src[4],src[5],trans,pfile);
d473 4
a476 4
				snprintf(line,sizeof(line),
					"%x:%x:%x:%x:%x:%x (%d) Do you have %s? (No)",
					src[0],src[1],src[2],
					src[3],src[4],src[5],trans,pfile);
d480 1
a480 1
			if ((mopCmpEAddr(dst,ii->eaddr) == 0)) {
d483 4
a486 4
				snprintf(line,sizeof(line),
					"%x:%x:%x:%x:%x:%x Send me %s",
					src[0],src[1],src[2],
					src[3],src[4],src[5],pfile);
a489 1
		
d492 3
a494 6
		
		load = mopGetChar(pkt,index);		/* Load Number	*/
		
		tmpc = mopGetChar(pkt,index);		/* Error	*/
		
		if ((mopCmpEAddr(dst,ii->eaddr) == 0)) {
a495 2
		}
		
d511 2
a512 6
mopProcessRC(fd, ii, pkt, index, dst, src, trans, len)
	FILE	*fd;
	struct if_info *ii;
	u_char	*pkt, *dst, *src;
	int	*index, trans;
	u_short	 len;
d514 4
a517 4
	u_char	 tmpc;
	u_short	 tmps, moplen = 0;
	u_char   mopcode;
	struct dllist dl,*dl_rpr;
d519 1
a519 1
	if ((DebugFlag == DEBUG_ONELINE)) {
a520 1
	}
d526 2
a527 2
	
	if ((DebugFlag >= DEBUG_INFO)) {
a528 1
	}
d531 1
a531 1
	mopcode = mopGetChar(pkt,index);
d539 9
a547 12
		
		tmpc = mopGetChar(pkt,index);		/* Reserved */
		
		if ((DebugFlag >= DEBUG_INFO)) {
			(void)fprintf(stderr, "Reserved     :   %02x\n",tmpc);
		}
		
		tmps = mopGetShort(pkt,index);		/* Receipt # */
		if ((DebugFlag >= DEBUG_INFO)) {
			(void)fprintf(stderr, "Receipt Nbr  : %04x\n",tmpc);
		}
		
d549 1
a549 1
		bzero(dl_rpr,sizeof(*dl_rpr));
d551 2
a552 3
		bcopy((char *)src, (char *)(dl_rpr->eaddr), 6);
		mopProcessInfo(pkt,index,moplen,dl_rpr,trans);
		
a569 1

@


1.11
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.10 2002/09/07 07:58:21 maja Exp $ */
d28 1
a28 1
static char rcsid[] = "$OpenBSD: process.c,v 1.10 2002/09/07 07:58:21 maja Exp $";
@


1.10
log
@pedantic ansify. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.9 2002/07/13 10:13:27 deraadt Exp $ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d28 1
a28 1
static char rcsid[] = "$OpenBSD: process.c,v 1.9 2002/07/13 10:13:27 deraadt Exp $";
@


1.9
log
@use snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.8 2000/07/04 23:46:23 maja Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: process.c,v 1.8 2000/07/04 23:46:23 maja Exp $";
a52 2
extern char	dl_mcst[];		/* Dump/Load Multicast		*/
extern char	rc_mcst[];		/* Remote Console Multicast	*/
d390 1
a390 1
			mopPutMulti(pkt,&index,"ipc",3);
d503 1
a503 1
			snprintf(pfile,sizeof pfile,
@


1.8
log
@File of the week :-) If Tertiary Loader data link size might not be set.
Since Ethernet is the only data link supported assume datalink to be
1492. Found when ragge@@ludd.luth.se tried to boot a VAX 6000/400. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.7 2000/07/04 22:00:07 aaron Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: process.c,v 1.7 2000/07/04 22:00:07 aaron Exp $";
d505 3
a507 2
			sprintf(pfile,"%02x%02x%02x%02x%02x%02x%c",
				src[0],src[1],src[2],src[3],src[4],src[5],0);
@


1.7
log
@If the spec allows 128-character filenames, our buffer has to be at least 129
characters to hold the trailing NULL. This also fixes a one-byte overflow.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.6 2000/07/03 23:24:42 niklas Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: process.c,v 1.6 2000/07/03 23:24:42 niklas Exp $";
d270 1
a270 1
	if (dllist[slot].dl_bsz >= 1492)
@


1.6
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.5 2000/07/03 13:55:28 maja Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: process.c,v 1.5 2000/07/03 13:55:28 maja Exp $";
d441 1
a441 1
	u_char  pfile[128], mopcode;
d490 1
a490 1
		if (tmpc > sizeof(pfile))
@


1.5
log
@Ignore filenames that are longer than spec allows (128 for MOP V4.0.0).
Matt Power <mhpower@@mit.edu>. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.4 2000/06/28 23:52:58 deraadt Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: process.c,v 1.4 2000/06/28 23:52:58 deraadt Exp $";
d490 1
a490 1
		if (tempc > sizeof(pfile))
@


1.4
log
@creating line ourselves, but just in case, use %s with syslog
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.3 2000/02/20 17:45:34 bitblt Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: process.c,v 1.3 2000/02/20 17:45:34 bitblt Exp $";
d441 1
a441 1
	u_char  pfile[17], mopcode;
d490 2
@


1.3
log
@

string manipluation paranoia changes.  Most probably not exploitable.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.2 1996/09/21 19:12:26 maja Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: process.c,v 1.2 1996/09/21 19:12:26 maja Exp $";
d356 1
a356 1
		syslog(LOG_INFO, line);
d532 1
a532 1
			syslog(LOG_INFO, line);
d541 1
a541 1
				syslog(LOG_INFO, line);
@


1.3.2.1
log
@Pull in patches from current:
Fixes (maja,aaron,niklas,deraadt,bitblt):
File of the week :-) If Tertiary Loader data link size might not be set.
Since Ethernet is the only data link supported assume datalink to be
1492. Found when ragge@@ludd.luth.se tried to boot a VAX 6000/400. -moj

If the spec allows 128-character filenames, our buffer has to be at least 129
characters to hold the trailing NULL. This also fixes a one-byte overflow.

typo

Ignore filenames that are longer than spec allows (128 for MOP V4.0.0).
Matt Power <mhpower@@mit.edu>. -moj

creating line ourselves, but just in case, use %s with syslog

string manipluation paranoia changes.  Most probably not exploitable.
@
text
@d1 1
a1 1
/*	$OpenBSD: process.c,v 1.8 2000/07/04 23:46:23 maja Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: process.c,v 1.8 2000/07/04 23:46:23 maja Exp $";
d270 1
a270 1
	if ((dllist[slot].dl_bsz >= 1492) || (dllist[slot].dl_bsz == 0))
d356 1
a356 1
		syslog(LOG_INFO, "%s", line);
d441 1
a441 1
	u_char  pfile[129], mopcode;
a489 2
		if (tmpc > sizeof(pfile) - 1)
			return;
d532 1
a532 1
			syslog(LOG_INFO, "%s", line);
d541 1
a541 1
				syslog(LOG_INFO, "%s", line);
@


1.2
log
@Replace $Id with $OpenBSD, 3:rd try. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: process.c,v 1.1.1.1 1996/09/21 13:49:17 maja Exp $";
d353 1
a353 1
		sprintf(line,
d516 2
a517 1
		sprintf(filename,"%s/%s.SYS", MOP_FILE_PATH, pfile);
d522 1
a522 1
				sprintf(line,
d527 1
a527 1
				sprintf(line,
d537 1
a537 1
				sprintf(line,
@


1.1
log
@Initial revision
@
text
@d1 2
d33 1
a33 1
static char rcsid[] = "$Id: process.c,v 1.21 1996/08/22 17:04:07 moj Exp $";
@


1.1.1.1
log
@Initial import of mopd-2.5.3. -moj
@
text
@@
