head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.14
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.12
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.8
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.8
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.13.0.12
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.10
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.10.0.16
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.12
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.12
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.10
	OPENBSD_2_8:1.5.0.8
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	MOPD254:1.5
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	MOPD253:1.1.1.1
	MAJA:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.02.09.23.00.14;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	822YD61EeG0Xl9Na;

1.14
date	2013.07.05.21.02.07;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.01.08.14.26;	author mk;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.27.23.59.52;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.11.13.42.32;	author sobrado;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.16.20.18.27;	author maja;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.01.00.56.51;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.21.38.39;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.10.21.05.25;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.28.04;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.03.27.14.31.22;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	98.03.19.07.39.44;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.44.29;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.09.21.19.12.35;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	96.09.21.13.49.17;	author maja;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.21.13.49.17;	author maja;	state Exp;
branches;
next	;


desc
@@


1.15
log
@clean up flags++ instances around getopt()
ok florian
@
text
@/*	$OpenBSD: mopprobe.c,v 1.14 2013/07/05 21:02:07 miod Exp $ */

/*
 * Copyright (c) 1993-96 Mats O Jansson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * mopprobe - MOP Probe Utility
 *
 * Usage:	mopprobe [-3 | -4] [-aov] interface
 */

#include "os.h"
#include "common/common.h"
#include "common/mopdef.h"
#include "common/device.h"
#include "common/print.h"
#include "common/get.h"
#include "common/cmp.h"
#include "common/pf.h"
#include "common/nmadef.h"

/*
 * The list of all interfaces that are being listened to.
 */
struct if_info *iflist;

void   Usage(void);
void   mopProcess(struct if_info *, u_char *);

struct once {
	u_char	eaddr[6];		/* Ethernet addr */
	struct once *next;		/* Next one */
};

int     AllFlag = 0;		/* listen on "all" interfaces  */
int	Not3Flag = 0;		/* Not MOP V3 messages         */
int	Not4Flag = 0;		/* Not MOP V4 messages         */
int	VerboseFlag = 0;	/* Print All Announces	       */
int     OnceFlag = 0;		/* print only once             */
int	promisc = 1;		/* Need promisc mode           */
extern char *__progname;
struct once *root = NULL;

int
main(int argc, char *argv[])
{
	int     op;
	char   *interface;

	/* All error reporting is done through syslogs. */
	openlog(__progname, LOG_PID | LOG_CONS, LOG_DAEMON);

	opterr = 0;
	while ((op = getopt(argc, argv, "34aov")) != -1) {
		switch (op) {
		case '3':
			Not3Flag = 1;
			break;
		case '4':
			Not4Flag = 1;
			break;
		case 'a':
			AllFlag = 1;
			break;
		case 'o':
			OnceFlag = 1;
			break;
		case 'v':
			VerboseFlag = 1;
			break;
		default:
			Usage();
			/* NOTREACHED */
		}
	}
	interface = argv[optind++];
	
	if ((AllFlag && interface) ||
	    (!AllFlag && interface == 0) ||
	    (Not3Flag && Not4Flag))
		Usage();

	if (AllFlag)
 		deviceInitAll();
	else
		deviceInitOne(interface);

	Loop();
	/* NOTREACHED */
}

void
Usage()
{
	fprintf(stderr, "usage: %s [-3 | -4] [-aov] interface\n", __progname);
	exit(1);
}

/*
 * Process incoming packages.
 */
void
mopProcess(struct if_info *ii, u_char *pkt)
{
	u_char	*dst, *src, mopcode, tmpc, device, ilen;
	u_short	 ptype, moplen = 0, itype;
	int	 idx, trans, len, i, hwa = 0;
	struct once *o = NULL;
	
	/* We don't known with transport, Guess! */

	trans = mopGetTrans(pkt, 0);

	/* Ok, return if we don't wan't this message */

	if ((trans == TRANS_ETHER) && Not3Flag) return;
	if ((trans == TRANS_8023) && Not4Flag)	return;

	idx = 0;
	mopGetHeader(pkt, &idx, &dst, &src, &ptype, &len, trans);

	/* Ignore our own transmissions */

	if (mopCmpEAddr(ii->eaddr,src) == 0)
		return;

	/* Just check multicast */

	if (mopCmpEAddr(rc_mcst,dst) != 0) {
		return;
	}
	
	switch(ptype) {
	case MOP_K_PROTO_RC:
		break;
	default:
		return;
	}
	
	if (OnceFlag) {
		o = root;
		while (o != NULL) {
			if (mopCmpEAddr(o->eaddr,src) == 0)
				return;
			o = o->next;
		}
		o = (struct once *)malloc(sizeof(*o));
		o->eaddr[0] = src[0];
		o->eaddr[1] = src[1];
		o->eaddr[2] = src[2];
		o->eaddr[3] = src[3];
		o->eaddr[4] = src[4];
		o->eaddr[5] = src[5];
		o->next = root;
		root = o;
	}

	moplen  = mopGetLength(pkt, trans);
	mopcode	= mopGetChar(pkt,&idx);

	/* Just process System Information */

	if (mopcode != MOP_K_CODE_SID) {
		return;
	}
	
	mopGetChar(pkt,&idx);			/* Reserved */
	mopGetShort(pkt,&idx);			/* Receipt # */
		
	device = 0;

	switch(trans) {
	case TRANS_ETHER:
		moplen = moplen + 16;
		break;
	case TRANS_8023:
		moplen = moplen + 14;
		break;
	}

	itype = mopGetShort(pkt,&idx); 

	while (idx < (int)(moplen)) {
		ilen  = mopGetChar(pkt,&idx);
		switch (itype) {
		case 0:
			tmpc  = mopGetChar(pkt,&idx);
			idx = idx + tmpc;
			break;
		case MOP_K_INFO_VER:
			idx = idx + 3;
			break;
		case MOP_K_INFO_MFCT:
		case MOP_K_INFO_RTM:
		case MOP_K_INFO_CSZ:
		case MOP_K_INFO_RSZ:
			idx = idx + 2;
			break;
		case MOP_K_INFO_HWA:
			hwa = idx;
			/* FALLTHROUGH */
		case MOP_K_INFO_CNU:
			idx = idx + 6;
			break;
		case MOP_K_INFO_TIME:
			idx = idx + 10;
			break;
	        case MOP_K_INFO_SOFD:
			device = mopGetChar(pkt,&idx);
			if (VerboseFlag && 
			    (device != NMA_C_SOFD_LCS) &&   /* DECserver 100 */
			    (device != NMA_C_SOFD_DS2) &&   /* DECserver 200 */
			    (device != NMA_C_SOFD_DP2) &&   /* DECserver 250 */
			    (device != NMA_C_SOFD_DS3))     /* DECserver 300 */
			{
				mopPrintHWA(stdout, src);
				fprintf(stdout," # ");
				mopPrintDevice(stdout, device);
				fprintf(stdout," ");
				mopPrintHWA(stdout, &pkt[hwa]);
				fprintf(stdout,"\n");
			}
			break;
		case MOP_K_INFO_SFID:
			tmpc = mopGetChar(pkt,&idx);
			if ((tmpc > 0) && (tmpc < 17)) 
				idx = idx + tmpc;
			break;
		case MOP_K_INFO_PRTY:
			idx = idx + 1;
			break;
		case MOP_K_INFO_DLTY:
			idx = idx + 1;
			break;
	        case MOP_K_INFO_DLBSZ:
			idx = idx + 2;
			break;
		default:
			if (((device == NMA_C_SOFD_LCS) ||  /* DECserver 100 */
			     (device == NMA_C_SOFD_DS2) ||  /* DECserver 200 */
			     (device == NMA_C_SOFD_DP2) ||  /* DECserver 250 */
			     (device == NMA_C_SOFD_DS3)) && /* DECserver 300 */
			    ((itype > 101) && (itype < 107)))
			{
				switch (itype) {
				case 102:
				case 103:
				case 106:
					idx = idx + ilen;
					break;
				case 104:
					idx = idx + 2;
					break;
				case 105:
					mopPrintHWA(stdout, src);
					fprintf(stdout," ");
					for (i = 0; i < ilen; i++) {
						fprintf(stdout, "%c",pkt[idx+i]);
					}
					idx = idx + ilen;
					fprintf(stdout, "\n");
					break;
				};
			} else {
				idx = idx + ilen;
			};
		}
		itype = mopGetShort(pkt,&idx); 
	}
}
@


1.14
log
@Teach mopd and mopa.out about ELF files, and allow forthcoming VAX ELF boot
blocks to be converted to working mop binaries. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: mopprobe.c,v 1.13 2010/05/01 08:14:26 mk Exp $ */
d78 1
a78 1
			Not3Flag++;
d81 1
a81 1
			Not4Flag++;
d84 1
a84 1
			AllFlag++;
d87 1
a87 1
			OnceFlag++;
d90 1
a90 1
			VerboseFlag++;
@


1.13
log
@incomming -> incoming

The ones found in gnu/ left out by intention.

ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: mopprobe.c,v 1.12 2009/10/27 23:59:52 deraadt Exp $ */
a47 1
__dead void   Loop(void);
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mopprobe.c,v 1.11 2009/07/11 13:42:32 sobrado Exp $ */
d122 1
a122 1
 * Process incomming packages.
@


1.11
log
@synchronize the synopsis and usage of mopa.out(1); mopchk(1) can handle
more than one filename at a time; add a description for -3 and -4
in mopd(8), and document -v; remove a duplicate flag in mopprobe(1);
use a better style for synopses; sort flags and arguments.

written with help by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mopprobe.c,v 1.10 2006/04/16 20:18:27 maja Exp $ */
a25 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: mopprobe.c,v 1.10 2006/04/16 20:18:27 maja Exp $";
#endif
@


1.10
log
@Some cleanup and delint. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: mopprobe.c,v 1.9 2003/12/01 00:56:51 avsm Exp $ */
d28 1
a28 1
static const char rcsid[] = "$OpenBSD: mopprobe.c,v 1.9 2003/12/01 00:56:51 avsm Exp $";
d34 1
a34 2
 * Usage:	mopprobe -a [ -3 | -4 ] [-v] [-o]
 *		mopprobe [ -3 | -4 ] [-v] [-o] interface
d121 1
a121 3
	fprintf(stderr, "usage: %s -a [ -3 | -4 ] [-v] [-o]\n", __progname);
	fprintf(stderr, "       %s [ -3 | -4 ] [-v] [-o] interface\n",
	    __progname);
@


1.9
log
@-Wall cleanup: trim unused vars, right format strings, constify rcsids,
braces where needed, add missing prototypes.

tested and ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mopprobe.c,v 1.8 2003/06/02 21:38:39 maja Exp $ */
d27 2
a28 2
#ifndef LINT
static const char rcsid[] = "$OpenBSD: mopprobe.c,v 1.8 2003/06/02 21:38:39 maja Exp $";
d49 1
a49 2
 * The list of all interfaces that are being listened to.  rarp_loop()
 * "selects" on the descriptors in this list.
d68 1
a68 1
char	*Program;
d72 1
a72 3
main(argc, argv)
	int     argc;
	char  **argv;
a76 9
	extern int optind, opterr;

	if ((Program = strrchr(argv[0], '/')))
		Program++;
	else
		Program = argv[0];
	if (*Program == '-')
		Program++;

d78 1
a78 1
	openlog(Program, LOG_PID | LOG_CONS, LOG_DAEMON);
d116 1
d122 3
a124 2
	(void) fprintf(stderr, "usage: %s -a [ -3 | -4 ] [-v] [-o]\n",Program);
	(void) fprintf(stderr, "       %s [ -3 | -4 ] [-v] [-o] interface\n",Program);
d132 1
a132 3
mopProcess(ii, pkt)
	struct if_info *ii;
	u_char *pkt;
d135 2
a136 2
	u_short	 ptype, moplen = 0, tmps, itype;
	int	 index, trans, len, i, hwa = 0;
d148 2
a149 2
	index = 0;
	mopGetHeader(pkt, &index, &dst, &src, &ptype, &len, trans);
d188 1
a188 1
	mopcode	= mopGetChar(pkt,&index);
d196 2
a197 2
	tmpc = mopGetChar(pkt,&index);		/* Reserved */
	tmps = mopGetShort(pkt,&index);		/* Receipt # */
d210 1
a210 1
	itype = mopGetShort(pkt,&index); 
d212 2
a213 2
	while (index < (int)(moplen)) {
		ilen  = mopGetChar(pkt,&index);
d216 2
a217 2
			tmpc  = mopGetChar(pkt,&index);
			index = index + tmpc;
d220 1
a220 1
			index = index + 3;
a222 5
			index = index + 2;
			break;
		case MOP_K_INFO_CNU:
			index = index + 6;
			break;
a223 2
			index = index + 2;
			break;
a224 2
			index = index + 2;
			break;
d226 1
a226 1
			index = index + 2;
d229 4
a232 2
			hwa = index;
			index = index + 6;
d235 1
a235 1
			index = index + 10;
d238 1
a238 1
			device = mopGetChar(pkt,&index);
d246 1
a246 1
				(void)fprintf(stdout," # ");
d248 1
a248 1
				(void)fprintf(stdout," ");
d250 1
a250 1
				(void)fprintf(stdout,"\n");
d254 3
a256 3
			tmpc = mopGetChar(pkt,&index);
			if ((index > 0) && (index < 17)) 
			  index = index + tmpc;
d259 1
a259 1
			index = index + 1;
d262 1
a262 1
			index = index + 1;
d265 1
a265 1
			index = index + 2;
d268 4
a271 4
			if (((device = NMA_C_SOFD_LCS) ||   /* DECserver 100 */
			     (device = NMA_C_SOFD_DS2) ||   /* DECserver 200 */
			     (device = NMA_C_SOFD_DP2) ||   /* DECserver 250 */
			     (device = NMA_C_SOFD_DS3)) &&  /* DECserver 300 */
a275 2
					index = index + ilen;
					break;
d277 2
a278 1
					index = index + ilen;
d281 1
a281 1
					index = index + 2;
d285 1
a285 1
					(void)fprintf(stdout," ");
d287 1
a287 1
					  (void)fprintf(stdout, "%c",pkt[index+i]);
d289 2
a290 5
					index = index + ilen;
					(void)fprintf(stdout, "\n");
					break;
				case 106:
					index = index + ilen;
d294 1
a294 1
				index = index + ilen;
d297 1
a297 1
		itype = mopGetShort(pkt,&index); 
a299 1

@


1.8
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: mopprobe.c,v 1.7 2002/06/10 21:05:25 maja Exp $ */
d28 1
a28 1
static char rcsid[] = "$OpenBSD: mopprobe.c,v 1.7 2002/06/10 21:05:25 maja Exp $";
d54 1
a54 1
void   Loop(void);
@


1.7
log
@Remove NO__P since __P has been removed. Found by hin@@ -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: mopprobe.c,v 1.6 2002/02/16 21:28:04 millert Exp $ */
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d28 1
a28 1
static char rcsid[] = "$OpenBSD: mopprobe.c,v 1.6 2002/02/16 21:28:04 millert Exp $";
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mopprobe.c,v 1.5 1999/03/27 14:31:22 maja Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: mopprobe.c,v 1.5 1999/03/27 14:31:22 maja Exp $";
a58 5
#ifdef NO__P
void   Loop	     (/* void */);
void   Usage         (/* void */);
void   mopProcess    (/* struct if_info *, u_char * */);
#else
a61 1
#endif
@


1.5
log
@Upgrade to 2.5.4. Mopprobe is working again, and some linux support. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: mopprobe.c,v 1.4 1998/03/19 07:39:44 deraadt Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: mopprobe.c,v 1.4 1998/03/19 07:39:44 deraadt Exp $";
d64 3
a66 3
void   Loop	     __P((void));
void   Usage         __P((void));
void   mopProcess    __P((struct if_info *, u_char *));
@


1.4
log
@main returns int
@
text
@d1 1
a1 1
/*	$OpenBSD: mopprobe.c,v 1.3 1997/01/15 23:44:29 millert Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: mopprobe.c,v 1.3 1997/01/15 23:44:29 millert Exp $";
d39 2
a40 2
 * Usage:	mopprobe -a [ -3 | -4 ]
 *		mopprobe [ -3 | -4 ] interface
d69 5
a74 1
int     DebugFlag = 0;		/* print debugging messages    */
d77 2
a78 1
int     oflag = 0;		/* print only once             */
d81 1
d104 1
a104 1
	while ((op = getopt(argc, argv, "ado")) != -1) {
d115 2
a116 2
		case 'd':
			DebugFlag++;
d118 2
a119 2
		case 'o':
			oflag++;
a120 1

d144 2
a145 2
	(void) fprintf(stderr, "usage: %s -a [ -3 | -4 ]\n",Program);
	(void) fprintf(stderr, "       %s [ -3 | -4 ] interface\n",Program);
d157 4
a160 8
	u_char  *dst, *src, *p, mopcode, tmpc, ilen;
	u_short *ptype, moplen, tmps, itype, len;
	int	index, i, device, trans;

	dst	= pkt;
	src	= pkt+6;
	ptype   = (u_short *)(pkt+12);
	index   = 0;
d162 13
a174 14
	if (*ptype < 1600) {
		len = *ptype;
		trans = TRANS_8023;
		ptype = (u_short *)(pkt+20);
		p = pkt+22;
		if (Not4Flag) return;
	} else {
		len = 0;
		trans = TRANS_ETHER;
		p = pkt+14;
		if (Not3Flag) return;
	}
	
	/* Ignore our own messages */
d176 1
a176 1
	if (mopCmpEAddr(ii->eaddr,src) == 0) {
a177 1
	}
d185 2
a186 3
	switch (trans) {
	case TRANS_8023:
		moplen = len;
d189 19
a207 1
		moplen = mopGetShort(pkt,&index);
d209 3
a211 1
	mopcode	= mopGetChar(p,&index);
d219 13
a231 2
	tmpc	= mopGetChar(pkt,&index);		/* Reserved  */
	tmps	= mopGetShort(pkt,&index);		/* Receipt # */
d233 1
a233 3
	device	= 0;					/* Unknown Device */
	
	itype	= mopGetShort(pkt,&index);
d235 2
a236 2
	while (index < (int)(moplen + 2)) {
		ilen	= mopGetChar(pkt,&index);
d242 1
a242 1
	        case MOP_K_INFO_VER:
d261 1
d269 13
d315 2
a316 2
					(void)fprintf(stdout,"%x:%x:%x:%x:%x:%x\t",
						      src[0],src[1],src[2],src[3],src[4],src[5]);
a332 1

@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: mopprobe.c,v 1.2 1996/09/21 19:12:35 maja Exp $ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: mopprobe.c,v 1.2 1996/09/21 19:12:35 maja Exp $";
d77 1
a77 1
void
@


1.2
log
@Replace $Id with $OpenBSD, 3:rd try. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d33 1
a33 1
static char rcsid[] = "$OpenBSD: mopprobe.c,v 1.1.1.1 1996/09/21 13:49:17 maja Exp $";
d98 1
a98 1
	while ((op = getopt(argc, argv, "ado")) != EOF) {
@


1.1
log
@Initial revision
@
text
@d1 2
d33 1
a33 1
static char rcsid[] = "$Id: mopprobe.c,v 1.11 1996/08/11 22:16:10 moj Exp $";
@


1.1.1.1
log
@Initial import of mopd-2.5.3. -moj
@
text
@@

