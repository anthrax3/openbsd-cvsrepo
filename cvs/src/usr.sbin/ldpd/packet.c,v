head	1.70;
access;
symbols
	OPENBSD_6_1_BASE:1.70
	OPENBSD_6_0:1.68.0.2
	OPENBSD_6_0_BASE:1.68
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.70
date	2017.03.04.00.06.10;	author renato;	state Exp;
branches;
next	1.69;
commitid	GMDFIgs8eMuH7Rxe;

1.69
date	2017.03.03.23.44.35;	author renato;	state Exp;
branches;
next	1.68;
commitid	mV5MMkodXlL2okSe;

1.68
date	2016.07.16.19.24.30;	author renato;	state Exp;
branches;
next	1.67;
commitid	LXVlFOsFAoTwgzCX;

1.67
date	2016.07.01.23.36.38;	author renato;	state Exp;
branches;
next	1.66;
commitid	h9Qy21EPYXbAFnoh;

1.66
date	2016.07.01.23.29.55;	author renato;	state Exp;
branches;
next	1.65;
commitid	OkOx7tFZtmlIlivU;

1.65
date	2016.07.01.23.14.31;	author renato;	state Exp;
branches;
next	1.64;
commitid	DKNC9fIizmSRxKR1;

1.64
date	2016.06.18.17.31.32;	author renato;	state Exp;
branches;
next	1.63;
commitid	Ou0pUplgSHSojMsH;

1.63
date	2016.06.13.20.19.40;	author renato;	state Exp;
branches;
next	1.62;
commitid	pBNsEb3sqMOC0tnw;

1.62
date	2016.06.13.20.13.34;	author renato;	state Exp;
branches;
next	1.61;
commitid	PXA9uYNvrI5vhKkE;

1.61
date	2016.06.09.17.57.55;	author renato;	state Exp;
branches;
next	1.60;
commitid	7YekI91rDVQGqoYc;

1.60
date	2016.06.09.17.41.52;	author renato;	state Exp;
branches;
next	1.59;
commitid	HRYA8VSZq7kmQzE4;

1.59
date	2016.06.06.15.30.59;	author renato;	state Exp;
branches;
next	1.58;
commitid	DG8Q9ksVqeiXuWBB;

1.58
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.57;
commitid	TLlfi1Pk0Z97z8HM;

1.57
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.56;
commitid	AQBoOveMRKjtVfFv;

1.56
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.55;
commitid	t07H0Mk6WGdVWB0W;

1.55
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.54;
commitid	D7VvXbswyzx5Ahb2;

1.54
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.53;
commitid	VpAym8dVR6eY4drQ;

1.53
date	2016.05.23.17.00.40;	author renato;	state Exp;
branches;
next	1.52;
commitid	3KHOYftnvJzmjKLP;

1.52
date	2016.05.23.16.20.59;	author renato;	state Exp;
branches;
next	1.51;
commitid	nAtgYzDo97D7UnEI;

1.51
date	2016.05.23.16.18.51;	author renato;	state Exp;
branches;
next	1.50;
commitid	0IKOnhMGNkMbV1lE;

1.50
date	2016.05.23.16.16.44;	author renato;	state Exp;
branches;
next	1.49;
commitid	lsfNt5ZefaCVBrpj;

1.49
date	2016.05.23.16.08.18;	author renato;	state Exp;
branches;
next	1.48;
commitid	BnqFnJhiKFbG4Dc4;

1.48
date	2016.05.23.16.06.08;	author renato;	state Exp;
branches;
next	1.47;
commitid	mFYncmucef6YwZ48;

1.47
date	2016.05.23.16.04.04;	author renato;	state Exp;
branches;
next	1.46;
commitid	sfghEB6dR4Eaf77g;

1.46
date	2016.05.23.16.01.59;	author renato;	state Exp;
branches;
next	1.45;
commitid	mPlo1gOiTGCVTctp;

1.45
date	2016.05.23.15.47.24;	author renato;	state Exp;
branches;
next	1.44;
commitid	Eng7dm0NElMq9Yi3;

1.44
date	2016.05.23.15.43.11;	author renato;	state Exp;
branches;
next	1.43;
commitid	weS0xzAgWBV4f0dh;

1.43
date	2016.05.23.15.14.08;	author renato;	state Exp;
branches;
next	1.42;
commitid	l3e6PhvoAh8C7elc;

1.42
date	2016.05.23.14.49.56;	author renato;	state Exp;
branches;
next	1.41;
commitid	lTtxmGfFyaMMzQOH;

1.41
date	2015.07.21.04.43.28;	author renato;	state Exp;
branches;
next	1.40;
commitid	QaTrdqMa9i0CUoyW;

1.40
date	2015.07.21.04.39.28;	author renato;	state Exp;
branches;
next	1.39;
commitid	KR83ZYzpLqbp9L95;

1.39
date	2015.07.19.21.01.56;	author renato;	state Exp;
branches;
next	1.38;
commitid	3CZZKtMxWnvDQhpO;

1.38
date	2015.04.04.15.04.49;	author renato;	state Exp;
branches;
next	1.37;
commitid	qo9Bu1ttYyrDu0mo;

1.37
date	2015.02.09.11.54.24;	author claudio;	state Exp;
branches;
next	1.36;
commitid	LTeEOygtHEq8pPcX;

1.36
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.35;
commitid	2uw1UTO4k6erpWzK;

1.35
date	2014.07.12.19.22.32;	author krw;	state Exp;
branches;
next	1.34;
commitid	XAgbiXPNNyS0mzjf;

1.34
date	2013.11.26.11.59.38;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2013.10.17.17.47.05;	author renato;	state Exp;
branches;
next	1.32;

1.32
date	2013.10.15.20.31.14;	author renato;	state Exp;
branches;
next	1.31;

1.31
date	2013.10.15.20.27.40;	author renato;	state Exp;
branches;
next	1.30;

1.30
date	2013.10.15.19.59.53;	author renato;	state Exp;
branches;
next	1.29;

1.29
date	2013.10.15.16.47.24;	author renato;	state Exp;
branches;
next	1.28;

1.28
date	2013.06.05.19.19.10;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.04.02.34.48;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2013.06.04.02.25.28;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2013.06.03.16.53.49;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.01.19.01.32;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2013.06.01.18.47.07;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2013.06.01.18.35.02;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.01.18.24.28;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.01.18.16.35;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.01.01.39.04;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.30.15.49.33;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2012.04.12.17.33.43;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.12.01.52.04;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2011.01.10.12.28.25;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2010.11.04.09.52.16;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.14.13.49.09;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.01.12.22.33;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.29.12.09.28;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.15.15.37.51;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.04.15.15.31.55;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.15.15.04.23;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.26.16.00.09;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.25.17.40.46;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.01.11.09.58;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.22.34.45;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.70
log
@Implement RFC 5561 (LDP Capabilities).

This patch per-se doesn't introduce any useful functionality, but prepares
the ground for new enhancements to ldpd (i.e. implementation of new RFCs
that make use of LDP capabilities).
@
text
@/*	$OpenBSD: packet.c,v 1.69 2017/03/03 23:44:35 renato Exp $ */

/*
 * Copyright (c) 2013, 2016 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 * Copyright (c) 2004, 2005, 2008 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <net/if_dl.h>
#include <unistd.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>

#include "ldpd.h"
#include "ldpe.h"
#include "log.h"

static struct iface		*disc_find_iface(unsigned int, int,
				    union ldpd_addr *, int);
static void			 session_read(int, short, void *);
static void			 session_write(int, short, void *);
static ssize_t			 session_get_pdu(struct ibuf_read *, char **);
static void			 tcp_close(struct tcp_conn *);
static struct pending_conn	*pending_conn_new(int, int, union ldpd_addr *);
static void			 pending_conn_timeout(int, short, void *);

int
gen_ldp_hdr(struct ibuf *buf, uint16_t size)
{
	struct ldp_hdr	ldp_hdr;

	memset(&ldp_hdr, 0, sizeof(ldp_hdr));
	ldp_hdr.version = htons(LDP_VERSION);
	/* exclude the 'Version' and 'PDU Length' fields from the total */
	ldp_hdr.length = htons(size - LDP_HDR_DEAD_LEN);
	ldp_hdr.lsr_id = leconf->rtr_id.s_addr;
	ldp_hdr.lspace_id = 0;

	return (ibuf_add(buf, &ldp_hdr, LDP_HDR_SIZE));
}

int
gen_msg_hdr(struct ibuf *buf, uint16_t type, uint16_t size)
{
	static int	msgcnt = 0;
	struct ldp_msg	msg;

	memset(&msg, 0, sizeof(msg));
	msg.type = htons(type);
	/* exclude the 'Type' and 'Length' fields from the total */
	msg.length = htons(size - LDP_MSG_DEAD_LEN);
	msg.id = htonl(++msgcnt);

	return (ibuf_add(buf, &msg, sizeof(msg)));
}

/* send packets */
int
send_packet(int fd, int af, union ldpd_addr *dst, struct iface_af *ia,
    void *pkt, size_t len)
{
	struct sockaddr		*sa;

	switch (af) {
	case AF_INET:
		if (ia && IN_MULTICAST(ntohl(dst->v4.s_addr))) {
			/* set outgoing interface for multicast traffic */
			if (sock_set_ipv4_mcast(ia->iface) == -1) {
				log_debug("%s: error setting multicast "
				    "interface, %s", __func__, ia->iface->name);
				return (-1);
			}
		}
		break;
	case AF_INET6:
		if (ia && IN6_IS_ADDR_MULTICAST(&dst->v6)) {
			/* set outgoing interface for multicast traffic */
			if (sock_set_ipv6_mcast(ia->iface) == -1) {
				log_debug("%s: error setting multicast "
				    "interface, %s", __func__, ia->iface->name);
				return (-1);
			}
		}
		break;
	default:
		fatalx("send_packet: unknown af");
	}

	sa = addr2sa(af, dst, LDP_PORT);
	if (sendto(fd, pkt, len, 0, sa, sa->sa_len) == -1) {
		log_warn("%s: error sending packet to %s", __func__,
		    log_sockaddr(sa));
		return (-1);
	}

	return (0);
}

/* Discovery functions */
#define CMSG_MAXLEN max(sizeof(struct sockaddr_dl), sizeof(struct in6_pktinfo))
void
disc_recv_packet(int fd, short event, void *bula)
{
	union {
		struct	cmsghdr hdr;
		char	buf[CMSG_SPACE(CMSG_MAXLEN)];
	} cmsgbuf;
	struct msghdr		 m;
	struct sockaddr_storage	 from;
	struct iovec		 iov;
	char			*buf;
	struct cmsghdr		*cmsg;
	ssize_t			 r;
	int			 multicast;
	int			 af;
	union ldpd_addr		 src;
	unsigned int		 ifindex = 0;
	struct iface		*iface;
	uint16_t		 len;
	struct ldp_hdr		 ldp_hdr;
	uint16_t		 pdu_len;
	struct ldp_msg		 msg;
	uint16_t		 msg_len;
	struct in_addr		 lsr_id;

	if (event != EV_READ)
		return;

	/* setup buffer */
	memset(&m, 0, sizeof(m));
	iov.iov_base = buf = pkt_ptr;
	iov.iov_len = IBUF_READ_SIZE;
	m.msg_name = &from;
	m.msg_namelen = sizeof(from);
	m.msg_iov = &iov;
	m.msg_iovlen = 1;
	m.msg_control = &cmsgbuf.buf;
	m.msg_controllen = sizeof(cmsgbuf.buf);

	if ((r = recvmsg(fd, &m, 0)) == -1) {
		if (errno != EAGAIN && errno != EINTR)
			log_debug("%s: read error: %s", __func__,
			    strerror(errno));
		return;
	}

	multicast = (m.msg_flags & MSG_MCAST) ? 1 : 0;
	sa2addr((struct sockaddr *)&from, &af, &src);
	if (bad_addr(af, &src)) {
		log_debug("%s: invalid source address: %s", __func__,
		    log_addr(af, &src));
		return;
	}

	for (cmsg = CMSG_FIRSTHDR(&m); cmsg != NULL;
	    cmsg = CMSG_NXTHDR(&m, cmsg)) {
		if (af == AF_INET && cmsg->cmsg_level == IPPROTO_IP &&
		    cmsg->cmsg_type == IP_RECVIF) {
			ifindex = ((struct sockaddr_dl *)
			    CMSG_DATA(cmsg))->sdl_index;
			break;
		}
		if (af == AF_INET6 && cmsg->cmsg_level == IPPROTO_IPV6 &&
		    cmsg->cmsg_type == IPV6_PKTINFO) {
			ifindex = ((struct in6_pktinfo *)
			    CMSG_DATA(cmsg))->ipi6_ifindex;
			break;
		}
	}

	/* find a matching interface */
	iface = disc_find_iface(ifindex, af, &src, multicast);
	if (iface == NULL)
		return;

	/* check packet size */
	len = (uint16_t)r;
	if (len < (LDP_HDR_SIZE + LDP_MSG_SIZE) || len > LDP_MAX_LEN) {
		log_debug("%s: bad packet size, source %s", __func__,
		    log_addr(af, &src));
		return;
	}

	/* LDP header sanity checks */
	memcpy(&ldp_hdr, buf, sizeof(ldp_hdr));
	if (ntohs(ldp_hdr.version) != LDP_VERSION) {
		log_debug("%s: invalid LDP version %d, source %s", __func__,
		    ntohs(ldp_hdr.version), log_addr(af, &src));
		return;
	}
	if (ntohs(ldp_hdr.lspace_id) != 0) {
		log_debug("%s: invalid label space %u, source %s", __func__,
		    ntohs(ldp_hdr.lspace_id), log_addr(af, &src));
		return;
	}
	/* check "PDU Length" field */
	pdu_len = ntohs(ldp_hdr.length);
	if ((pdu_len < (LDP_HDR_PDU_LEN + LDP_MSG_SIZE)) ||
	    (pdu_len > (len - LDP_HDR_DEAD_LEN))) {
		log_debug("%s: invalid LDP packet length %u, source %s",
		    __func__, ntohs(ldp_hdr.length), log_addr(af, &src));
		return;
	}
	buf += LDP_HDR_SIZE;
	len -= LDP_HDR_SIZE;

	lsr_id.s_addr = ldp_hdr.lsr_id;

	/*
	 * For UDP, we process only the first message of each packet. This does
	 * not impose any restrictions since LDP uses UDP only for sending Hello
	 * packets.
	 */
	memcpy(&msg, buf, sizeof(msg));

	/* check "Message Length" field */
	msg_len = ntohs(msg.length);
	if (msg_len < LDP_MSG_LEN || ((msg_len + LDP_MSG_DEAD_LEN) > pdu_len)) {
		log_debug("%s: invalid LDP message length %u, source %s",
		    __func__, ntohs(msg.length), log_addr(af, &src));
		return;
	}
	buf += LDP_MSG_SIZE;
	len -= LDP_MSG_SIZE;

	/* switch LDP packet type */
	switch (ntohs(msg.type)) {
	case MSG_TYPE_HELLO:
		recv_hello(lsr_id, &msg, af, &src, iface, multicast, buf, len);
		break;
	default:
		log_debug("%s: unknown LDP packet type, source %s", __func__,
		    log_addr(af, &src));
	}
}

static struct iface *
disc_find_iface(unsigned int ifindex, int af, union ldpd_addr *src,
    int multicast)
{
	struct iface	*iface;
	struct iface_af	*ia;
	struct if_addr	*if_addr;
	in_addr_t	 mask;

	iface = if_lookup(leconf, ifindex);
	if (iface == NULL)
		return (NULL);

	/*
	 * For unicast packets, we just need to make sure that the interface
	 * is enabled for the given address-family.
	 */
	if (!multicast) {
		ia = iface_af_get(iface, af);
		if (ia->enabled)
			return (iface);
		return (NULL);
	}

	switch (af) {
	case AF_INET:
		LIST_FOREACH(if_addr, &iface->addr_list, entry) {
			if (if_addr->af != AF_INET)
				continue;

			switch (iface->type) {
			case IF_TYPE_POINTOPOINT:
				if (if_addr->dstbrd.v4.s_addr == src->v4.s_addr)
					return (iface);
				break;
			default:
				mask = prefixlen2mask(if_addr->prefixlen);
				if ((if_addr->addr.v4.s_addr & mask) ==
				    (src->v4.s_addr & mask))
					return (iface);
				break;
			}
		}
		break;
	case AF_INET6:
		if (IN6_IS_ADDR_LINKLOCAL(&src->v6))
			return (iface);
		break;
	default:
		fatalx("disc_find_iface: unknown af");
	}

	return (NULL);
}

void
session_accept(int fd, short event, void *bula)
{
	struct sockaddr_storage	 src;
	socklen_t		 len = sizeof(src);
	int			 newfd;
	int			 af;
	union ldpd_addr		 addr;
	struct nbr		*nbr;
	struct pending_conn	*pconn;

	if (!(event & EV_READ))
		return;

	newfd = accept4(fd, (struct sockaddr *)&src, &len,
	    SOCK_NONBLOCK | SOCK_CLOEXEC);
	if (newfd == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			accept_pause();
		} else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			log_debug("%s: accept error: %s", __func__,
			    strerror(errno));
		return;
	}

	sa2addr((struct sockaddr *)&src, &af, &addr);

	/*
	 * Since we don't support label spaces, we can identify this neighbor
	 * just by its source address. This way we don't need to wait for its
	 * Initialization message to know who we are talking to.
	 */
	nbr = nbr_find_addr(af, &addr);
	if (nbr == NULL) {
		/*
		 * According to RFC 5036, we would need to send a No Hello
		 * Error Notification message and close this TCP connection
		 * right now. But doing so would trigger the backoff exponential
		 * timer in the remote peer, which would considerably slow down
		 * the session establishment process. The trick here is to wait
		 * five seconds before sending the Notification Message. There's
		 * a good chance that the remote peer will send us a Hello
		 * message within this interval, so it's worth waiting before
		 * taking a more drastic measure.
		 */
		pconn = pending_conn_find(af, &addr);
		if (pconn)
			close(newfd);
		else
			pending_conn_new(newfd, af, &addr);
		return;
	}
	/* protection against buggy implementations */
	if (nbr_session_active_role(nbr)) {
		close(newfd);
		return;
	}
	if (nbr->state != NBR_STA_PRESENT) {
		log_debug("%s: lsr-id %s: rejecting additional transport "
		    "connection", __func__, inet_ntoa(nbr->id));
		close(newfd);
		return;
	}

	session_accept_nbr(nbr, newfd);
}

void
session_accept_nbr(struct nbr *nbr, int fd)
{
	struct nbr_params	*nbrp;
	int			 opt;
	socklen_t		 len;

	nbrp = nbr_params_find(leconf, nbr->id);
	if (nbr_gtsm_check(fd, nbr, nbrp)) {
		close(fd);
		return;
	}

	if (nbrp && nbrp->auth.method == AUTH_MD5SIG) {
		if (sysdep.no_pfkey || sysdep.no_md5sig) {
			log_warnx("md5sig configured but not available");
			close(fd);
			return;
		}

		len = sizeof(opt);
		if (getsockopt(fd, IPPROTO_TCP, TCP_MD5SIG, &opt, &len) == -1)
			fatal("getsockopt TCP_MD5SIG");
		if (!opt) {	/* non-md5'd connection! */
			log_warnx("connection attempt without md5 signature");
			close(fd);
			return;
		}
	}

	nbr->tcp = tcp_new(fd, nbr);
	nbr_fsm(nbr, NBR_EVT_MATCH_ADJ);
}

static void
session_read(int fd, short event, void *arg)
{
	struct nbr	*nbr = arg;
	struct tcp_conn	*tcp = nbr->tcp;
	struct ldp_hdr	*ldp_hdr;
	struct ldp_msg	*msg;
	char		*buf, *pdu;
	ssize_t		 n, len;
	uint16_t	 pdu_len, msg_len, msg_size, max_pdu_len;
	int		 ret;

	if (event != EV_READ)
		return;

	if ((n = read(fd, tcp->rbuf->buf + tcp->rbuf->wpos,
	    sizeof(tcp->rbuf->buf) - tcp->rbuf->wpos)) == -1) {
		if (errno != EINTR && errno != EAGAIN) {
			log_warn("%s: read error", __func__);
			nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
			return;
		}
		/* retry read */
		return;
	}
	if (n == 0) {
		/* connection closed */
		log_debug("%s: connection closed by remote end", __func__);
		nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
		return;
	}
	tcp->rbuf->wpos += n;

	while ((len = session_get_pdu(tcp->rbuf, &buf)) > 0) {
		pdu = buf;
		ldp_hdr = (struct ldp_hdr *)pdu;
		if (ntohs(ldp_hdr->version) != LDP_VERSION) {
			session_shutdown(nbr, S_BAD_PROTO_VER, 0, 0);
			free(buf);
			return;
		}

		pdu_len = ntohs(ldp_hdr->length);
		/*
	 	 * RFC 5036 - Section 3.5.3:
		 * "Prior to completion of the negotiation, the maximum
		 * allowable length is 4096 bytes".
		 */
		if (nbr->state == NBR_STA_OPER)
			max_pdu_len = nbr->max_pdu_len;
		else
			max_pdu_len = LDP_MAX_LEN;
		if (pdu_len < (LDP_HDR_PDU_LEN + LDP_MSG_SIZE) ||
		    pdu_len > max_pdu_len) {
			session_shutdown(nbr, S_BAD_PDU_LEN, 0, 0);
			free(buf);
			return;
		}
		pdu_len -= LDP_HDR_PDU_LEN;
		if (ldp_hdr->lsr_id != nbr->id.s_addr ||
		    ldp_hdr->lspace_id != 0) {
			session_shutdown(nbr, S_BAD_LDP_ID, 0, 0);
			free(buf);
			return;
		}
		pdu += LDP_HDR_SIZE;
		len -= LDP_HDR_SIZE;

		nbr_fsm(nbr, NBR_EVT_PDU_RCVD);

		while (len >= LDP_MSG_SIZE) {
			uint16_t type;

			msg = (struct ldp_msg *)pdu;
			type = ntohs(msg->type);
			msg_len = ntohs(msg->length);
			if (msg_len < LDP_MSG_LEN ||
			    (msg_len + LDP_MSG_DEAD_LEN) > pdu_len) {
				session_shutdown(nbr, S_BAD_TLV_LEN, msg->id,
				    msg->type);
				free(buf);
				return;
			}
			msg_size = msg_len + LDP_MSG_DEAD_LEN;
			pdu_len -= msg_size;

			/* check for error conditions earlier */
			switch (type) {
			case MSG_TYPE_INIT:
				if ((nbr->state != NBR_STA_INITIAL) &&
				    (nbr->state != NBR_STA_OPENSENT)) {
					session_shutdown(nbr, S_SHUTDOWN,
					    msg->id, msg->type);
					free(buf);
					return;
				}
				break;
			case MSG_TYPE_KEEPALIVE:
				if ((nbr->state == NBR_STA_INITIAL) ||
				    (nbr->state == NBR_STA_OPENSENT)) {
					session_shutdown(nbr, S_SHUTDOWN,
					    msg->id, msg->type);
					free(buf);
					return;
				}
				break;
			default:
				if (nbr->state != NBR_STA_OPER) {
					session_shutdown(nbr, S_SHUTDOWN,
					    msg->id, msg->type);
					free(buf);
					return;
				}
				break;
			}

			/* switch LDP packet type */
			switch (type) {
			case MSG_TYPE_NOTIFICATION:
				ret = recv_notification(nbr, pdu, msg_size);
				break;
			case MSG_TYPE_INIT:
				ret = recv_init(nbr, pdu, msg_size);
				break;
			case MSG_TYPE_KEEPALIVE:
				ret = recv_keepalive(nbr, pdu, msg_size);
				break;
			case MSG_TYPE_CAPABILITY:
				ret = recv_capability(nbr, pdu, msg_size);
				break;
			case MSG_TYPE_ADDR:
			case MSG_TYPE_ADDRWITHDRAW:
				ret = recv_address(nbr, pdu, msg_size);
				break;
			case MSG_TYPE_LABELMAPPING:
			case MSG_TYPE_LABELREQUEST:
			case MSG_TYPE_LABELWITHDRAW:
			case MSG_TYPE_LABELRELEASE:
			case MSG_TYPE_LABELABORTREQ:
				ret = recv_labelmessage(nbr, pdu, msg_size,
				    type);
				break;
			default:
				log_debug("%s: unknown LDP message from nbr %s",
				    __func__, inet_ntoa(nbr->id));
				if (!(ntohs(msg->type) & UNKNOWN_FLAG))
					send_notification(nbr->tcp,
					    S_UNKNOWN_MSG, msg->id, msg->type);
				/* ignore the message */
				ret = 0;
				break;
			}

			if (ret == -1) {
				/* parser failed, giving up */
				free(buf);
				return;
			}

			/* Analyse the next message */
			pdu += msg_size;
			len -= msg_size;
		}
		free(buf);
		if (len != 0) {
			session_shutdown(nbr, S_BAD_PDU_LEN, 0, 0);
			return;
		}
	}
}

static void
session_write(int fd, short event, void *arg)
{
	struct tcp_conn *tcp = arg;
	struct nbr	*nbr = tcp->nbr;

	if (!(event & EV_WRITE))
		return;

	if (msgbuf_write(&tcp->wbuf.wbuf) <= 0)
		if (errno != EAGAIN && nbr)
			nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);

	if (nbr == NULL && !tcp->wbuf.wbuf.queued) {
		/*
		 * We are done sending the notification message, now we can
		 * close the socket.
		 */
		tcp_close(tcp);
		return;
	}

	evbuf_event_add(&tcp->wbuf);
}

void
session_shutdown(struct nbr *nbr, uint32_t status, uint32_t msg_id,
    uint32_t msg_type)
{
	switch (nbr->state) {
	case NBR_STA_PRESENT:
		if (nbr_pending_connect(nbr))
			event_del(&nbr->ev_connect);
		break;
	case NBR_STA_INITIAL:
	case NBR_STA_OPENREC:
	case NBR_STA_OPENSENT:
	case NBR_STA_OPER:
		log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));

		send_notification(nbr->tcp, status, msg_id, msg_type);

		nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
		break;
	default:
		fatalx("session_shutdown: unknown neighbor state");
	}
}

void
session_close(struct nbr *nbr)
{
	log_debug("%s: closing session with lsr-id %s", __func__,
	    inet_ntoa(nbr->id));

	tcp_close(nbr->tcp);
	nbr_stop_ktimer(nbr);
	nbr_stop_ktimeout(nbr);
	nbr_stop_itimeout(nbr);
}

static ssize_t
session_get_pdu(struct ibuf_read *r, char **b)
{
	struct ldp_hdr	l;
	size_t		av, dlen, left;

	av = r->wpos;
	if (av < sizeof(l))
		return (0);

	memcpy(&l, r->buf, sizeof(l));
	dlen = ntohs(l.length) + LDP_HDR_DEAD_LEN;
	if (dlen > av)
		return (0);

	if ((*b = malloc(dlen)) == NULL)
		return (-1);

	memcpy(*b, r->buf, dlen);
	if (dlen < av) {
		left = av - dlen;
		memmove(r->buf, r->buf + dlen, left);
		r->wpos = left;
	} else
		r->wpos = 0;

	return (dlen);
}

struct tcp_conn *
tcp_new(int fd, struct nbr *nbr)
{
	struct tcp_conn *tcp;

	if ((tcp = calloc(1, sizeof(*tcp))) == NULL)
		fatal(__func__);

	tcp->fd = fd;
	evbuf_init(&tcp->wbuf, tcp->fd, session_write, tcp);

	if (nbr) {
		if ((tcp->rbuf = calloc(1, sizeof(struct ibuf_read))) == NULL)
			fatal(__func__);

		event_set(&tcp->rev, tcp->fd, EV_READ | EV_PERSIST,
		    session_read, nbr);
		event_add(&tcp->rev, NULL);
		tcp->nbr = nbr;
	}

	return (tcp);
}

static void
tcp_close(struct tcp_conn *tcp)
{
	/* try to flush write buffer */
	msgbuf_write(&tcp->wbuf.wbuf);
	evbuf_clear(&tcp->wbuf);

	if (tcp->nbr) {
		event_del(&tcp->rev);
		free(tcp->rbuf);
		tcp->nbr->tcp = NULL;
	}

	close(tcp->fd);
	accept_unpause();
	free(tcp);
}

static struct pending_conn *
pending_conn_new(int fd, int af, union ldpd_addr *addr)
{
	struct pending_conn	*pconn;
	struct timeval		 tv;

	if ((pconn = calloc(1, sizeof(*pconn))) == NULL)
		fatal(__func__);

	pconn->fd = fd;
	pconn->af = af;
	pconn->addr = *addr;
	evtimer_set(&pconn->ev_timeout, pending_conn_timeout, pconn);
	TAILQ_INSERT_TAIL(&global.pending_conns, pconn, entry);

	timerclear(&tv);
	tv.tv_sec = PENDING_CONN_TIMEOUT;
	if (evtimer_add(&pconn->ev_timeout, &tv) == -1)
		fatal(__func__);

	return (pconn);
}

void
pending_conn_del(struct pending_conn *pconn)
{
	if (evtimer_pending(&pconn->ev_timeout, NULL) &&
	    evtimer_del(&pconn->ev_timeout) == -1)
		fatal(__func__);

	TAILQ_REMOVE(&global.pending_conns, pconn, entry);
	free(pconn);
}

struct pending_conn *
pending_conn_find(int af, union ldpd_addr *addr)
{
	struct pending_conn	*pconn;

	TAILQ_FOREACH(pconn, &global.pending_conns, entry)
		if (af == pconn->af &&
		    ldp_addrcmp(af, addr, &pconn->addr) == 0)
			return (pconn);

	return (NULL);
}

static void
pending_conn_timeout(int fd, short event, void *arg)
{
	struct pending_conn	*pconn = arg;
	struct tcp_conn		*tcp;

	log_debug("%s: no adjacency with remote end: %s", __func__,
	    log_addr(pconn->af, &pconn->addr));

	/*
	 * Create a write buffer detached from any neighbor to send a
	 * notification message reliably.
	 */
	tcp = tcp_new(pconn->fd, NULL);
	send_notification(tcp, S_NO_HELLO, 0, 0);
	msgbuf_write(&tcp->wbuf.wbuf);

	pending_conn_del(pconn);
}
@


1.69
log
@Kill send_notification_nbr().

Be more clever and trigger the PDU SENT event inside send_notification()
when tcp->nbr is set. This way we can eliminate send_notification_nbr()
and always use send_notification() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.68 2016/07/16 19:24:30 renato Exp $ */
d521 1
a521 7
			case MSG_TYPE_ADDR:
			case MSG_TYPE_ADDRWITHDRAW:
			case MSG_TYPE_LABELMAPPING:
			case MSG_TYPE_LABELREQUEST:
			case MSG_TYPE_LABELWITHDRAW:
			case MSG_TYPE_LABELRELEASE:
			case MSG_TYPE_LABELABORTREQ:
a528 2
			default:
				break;
d541 3
@


1.68
log
@Remove potential overflow when validating message's length.

Also, use uint16_t for msg_type on gen_msg_hdr().
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.67 2016/07/01 23:36:38 renato Exp $ */
d566 1
a566 1
					send_notification_nbr(nbr,
d631 1
a631 1
		send_notification_nbr(nbr, status, msg_id, msg_type);
d784 1
a784 1
	send_notification(S_NO_HELLO, tcp, 0, 0);
@


1.67
log
@More renaming and whitespace cleanup.

No binary change after "strip -s".
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.66 2016/07/01 23:29:55 renato Exp $ */
d60 1
a60 1
gen_msg_hdr(struct ibuf *buf, uint32_t type, uint16_t size)
d491 2
a492 2
			msg_size = msg_len + LDP_MSG_DEAD_LEN;
			if (msg_len < LDP_MSG_LEN || msg_size > pdu_len) {
d498 1
@


1.66
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.65 2016/07/01 23:14:31 renato Exp $ */
d69 1
a69 1
	msg.msgid = htonl(++msgcnt);
d125 1
a125 1
	struct msghdr		 msg;
d139 1
a139 1
	struct ldp_msg		 ldp_msg;
d147 1
a147 1
	memset(&msg, 0, sizeof(msg));
d150 6
a155 6
	msg.msg_name = &from;
	msg.msg_namelen = sizeof(from);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = &cmsgbuf.buf;
	msg.msg_controllen = sizeof(cmsgbuf.buf);
d157 1
a157 1
	if ((r = recvmsg(fd, &msg, 0)) == -1) {
d164 1
a164 1
	multicast = (msg.msg_flags & MSG_MCAST) ? 1 : 0;
d172 2
a173 2
	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;
	    cmsg = CMSG_NXTHDR(&msg, cmsg)) {
d231 1
a231 1
	memcpy(&ldp_msg, buf, sizeof(ldp_msg));
d234 1
a234 1
	msg_len = ntohs(ldp_msg.length);
d237 1
a237 1
		    __func__, ntohs(ldp_msg.length), log_addr(af, &src));
d244 1
a244 1
	switch (ntohs(ldp_msg.type)) {
d246 1
a246 2
		recv_hello(lsr_id, &ldp_msg, af, &src, iface, multicast,
		    buf, len);
d421 1
a421 1
	struct ldp_msg	*ldp_msg;
d488 3
a490 3
			ldp_msg = (struct ldp_msg *)pdu;
			type = ntohs(ldp_msg->type);
			msg_len = ntohs(ldp_msg->length);
d493 2
a494 2
				session_shutdown(nbr, S_BAD_TLV_LEN,
				    ldp_msg->msgid, ldp_msg->type);
d506 1
a506 1
					    ldp_msg->msgid, ldp_msg->type);
d515 1
a515 1
					    ldp_msg->msgid, ldp_msg->type);
d529 1
a529 1
					    ldp_msg->msgid, ldp_msg->type);
d564 1
a564 1
				if (!(ntohs(ldp_msg->type) & UNKNOWN_FLAG))
d566 1
a566 2
					    S_UNKNOWN_MSG, ldp_msg->msgid,
					    ldp_msg->type);
d616 2
a617 2
session_shutdown(struct nbr *nbr, uint32_t status, uint32_t msgid,
    uint32_t type)
d630 1
a630 1
		send_notification_nbr(nbr, status, msgid, type);
@


1.65
log
@Add GTSM support (RFC 6720).

This also finishes the missing bits from our RFC 7552 implementation
because GTSM is mandatory for LDPv6.

To avoid any kind of interoperability problems, I included a few
knobs to enable/disable GTSM on a per-address-family and per-neighbor
basis. Cisco's LDPv6 implementation, for instance, doesn't support GTSM.

"reads good" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.64 2016/06/18 17:31:32 renato Exp $ */
a474 1

a480 1

d484 1
a484 2
		if (nbr->state == NBR_STA_OPER)
			nbr_fsm(nbr, NBR_EVT_PDU_RCVD);
@


1.64
log
@Fix removal of dual-stack neighbors.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.63 2016/06/13 20:19:40 renato Exp $ */
d390 5
@


1.63
log
@Implement a timeout for the session initialization FSM.

This prevents neighbors stuck in the initialization FSM to linger forever
as long as the associated transport connection is up.

This timeout can be seen in the 'Session Initialization State Transition
Diagram' of RFC 5036. The RFC, however, doesn't specify how much we
should wait. Let's use 180 seconds for that, the default LDP hold time.

Fixes IxANVL LDP test 6.15.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.62 2016/06/13 20:13:34 renato Exp $ */
a631 3
		/* try to flush write buffer, if it fails tough shit */
		msgbuf_write(&nbr->tcp->wbuf.wbuf);

d707 2
@


1.62
log
@Rework the handling of Hello packets.

With the introduction of IPv6 support by RFC 7552, the handling of Hello
packets in ldpd became something incredibly complex. Neighbors can change
from single-stack LDP to dual-stack and vice-versa. They can change
their transport preference, their transport addresses (IPv4 and IPv6)
and even start or stop sending the Dual-Stack TLV. We also have to take
care to reject things like multiple adjacencies advertising different
transport-addresses for the same neighbor. ldpd was failing for some of
the cases mentioned above, this patch fixes these issues and attempts
to make the code easier to read.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.61 2016/06/09 17:57:55 renato Exp $ */
d651 1
@


1.61
log
@Do set the Message ID for Hello messages too.

In the original LDP specification, there was no circumstance where a
Notification message could be sent in response to a Hello message. So
setting the Message ID field for Hello packets was useless.

This changed with RFC 7552, where Hello packets can trigger the "Transport
Connection Mismatch" notification when the local and remote transport
preferences doesn't match. In this case, having a meaningful Message ID
in the Hello packets can aid in testing and troubleshooting.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.60 2016/06/09 17:41:52 renato Exp $ */
d627 1
a627 1
	case NBR_STA_OPER:	
@


1.60
log
@Do not shut down the session upon receiving unknown messages.

RFC 5036 says the following about the receipt of unknown messages:
  "Unknown message bit.  Upon receipt of an unknown message, if U is
  clear (=0), a notification is returned to the message originator;
  if U is set (=1), the unknown message is silently ignored".

We were correctly ignoring unknown messages when the U-bit was set. But
when this bit was not set, we were shutting down the session when the
correct thing to do is to just send a non-fatal notification message.

Fix IxANVL LDP test 22.13.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.59 2016/06/06 15:30:59 renato Exp $ */
d69 1
a69 2
	if (type != MSG_TYPE_HELLO)
		msg.msgid = htonl(++msgcnt);
@


1.59
log
@Speed up session establishment after config reload.

If we change a neighbor's password or the global transport-address,
cancel the affected pending connects and, when playing the active role
of the session establishment process, try to connect again right away
with the new password and/or transport-address.

Without this patch we have to wait for the timeout of the pending
connects, which might be a lot of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.58 2016/05/23 19:14:03 renato Exp $ */
d562 1
a562 1
				log_debug("%s: unknown LDP packet from nbr %s",
d564 5
a568 7
				if (!(ntohs(ldp_msg->type) & UNKNOWN_FLAG)) {
					session_shutdown(nbr, S_UNKNOWN_MSG,
					    ldp_msg->msgid, ldp_msg->type);
					free(buf);
					return;
				}
				/* unknown flag is set, ignore the message */
@


1.58
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.57 2016/05/23 19:11:42 renato Exp $ */
d622 10
a631 2
	if (nbr->tcp == NULL)
		return;
d633 1
a633 1
	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));
d635 2
a636 1
	send_notification_nbr(nbr, status, msgid, type);
d638 5
a642 4
	/* try to flush write buffer, if it fails tough shit */
	msgbuf_write(&nbr->tcp->wbuf.wbuf);

	nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
@


1.57
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.56 2016/05/23 19:09:25 renato Exp $ */
d4 1
@


1.56
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.55 2016/05/23 18:58:48 renato Exp $ */
a20 3
#include <sys/socket.h>
#include <sys/uio.h>

a21 1
#include <netinet/ip.h>
a24 1
#include <fcntl.h>
a25 1

a26 1
#include <event.h>
d31 1
a31 1
#include "ldp.h"
a32 1
#include "ldpe.h"
@


1.55
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.54 2016/05/23 17:43:42 renato Exp $ */
d42 8
a49 7
extern struct ldpd_conf        *leconf;
extern struct ldpd_sysdep	sysdep;

struct iface	*disc_find_iface(unsigned int, int, union ldpd_addr *, int);
ssize_t		 session_get_pdu(struct ibuf_read *, char **);

static int	 msgcnt = 0;
d69 1
d263 1
a263 1
struct iface *
d419 1
a419 1
void
d600 1
a600 1
void
d653 1
a653 1
ssize_t
d706 1
a706 1
void
d722 1
a722 1
struct pending_conn *
d769 1
a769 1
void
@


1.54
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d45 1
a45 1
struct iface	*disc_find_iface(unsigned int, struct in_addr, int);
d82 2
a83 2
send_packet(int fd, struct iface *iface, void *pkt, size_t len,
    struct sockaddr_in *dst)
d85 21
a105 6
	/* set outgoing interface for multicast traffic */
	if (iface && IN_MULTICAST(ntohl(dst->sin_addr.s_addr)))
		if (sock_set_ipv4_mcast(iface) == -1) {
			log_warn("%s: error setting multicast interface, %s",
			    __func__, iface->name);
			return (-1);
d107 4
d112 2
a113 2
	if (sendto(fd, pkt, len, 0, (struct sockaddr *)dst,
	    sizeof(*dst)) == -1) {
d115 1
a115 1
		    inet_ntoa(dst->sin_addr));
d123 1
d129 1
a129 1
		char	buf[CMSG_SPACE(sizeof(struct sockaddr_dl))];
a130 1
	struct sockaddr_in	 src;
d132 1
d138 2
d156 2
a157 2
	msg.msg_name = &src;
	msg.msg_namelen = sizeof(src);
d171 2
a172 1
	if (bad_ip_addr(src.sin_addr)) {
d174 1
a174 1
		    inet_ntoa(src.sin_addr));
d180 1
a180 1
		if (cmsg->cmsg_level == IPPROTO_IP &&
d186 6
d195 1
a195 1
	iface = disc_find_iface(ifindex, src.sin_addr, multicast);
d203 1
a203 1
		    inet_ntoa(src.sin_addr));
d211 1
a211 1
		    ntohs(ldp_hdr.version), inet_ntoa(src.sin_addr));
d216 1
a216 1
		    ntohs(ldp_hdr.lspace_id), inet_ntoa(src.sin_addr));
d224 1
a224 1
		    __func__, ntohs(ldp_hdr.length), inet_ntoa(src.sin_addr));
d243 1
a243 1
		    __func__, ntohs(ldp_msg.length), inet_ntoa(src.sin_addr));
d252 1
a252 1
		recv_hello(lsr_id, &ldp_msg, src.sin_addr, iface, multicast,
d257 1
a257 1
		    inet_ntoa(src.sin_addr));
d262 1
a262 1
disc_find_iface(unsigned int ifindex, struct in_addr src,
d266 1
d268 1
d274 10
a283 2
	if (!multicast)
		return (iface);
d285 18
a302 13
	LIST_FOREACH(if_addr, &iface->addr_list, entry) {
		switch (iface->type) {
		case IF_TYPE_POINTOPOINT:
			if (ifindex == iface->ifindex &&
			    if_addr->dstbrd.s_addr == src.s_addr)
				return (iface);
			break;
		default:
			if (ifindex == iface->ifindex &&
			    (if_addr->addr.s_addr & if_addr->mask.s_addr) ==
			    (src.s_addr & if_addr->mask.s_addr))
				return (iface);
			break;
d304 7
d319 1
a319 1
	struct sockaddr_in	 src;
d322 2
d346 2
d353 1
a353 1
	nbr = nbr_find_addr(src.sin_addr);
d366 1
a366 1
		pconn = pending_conn_find(src.sin_addr);
d370 1
a370 1
			pending_conn_new(newfd, src.sin_addr);
d721 1
a721 1
pending_conn_new(int fd, struct in_addr addr)
d730 2
a731 1
	pconn->addr = addr;
d755 1
a755 1
pending_conn_find(struct in_addr addr)
d760 2
a761 1
		if (addr.s_addr == pconn->addr.s_addr)
d774 1
a774 1
	    inet_ntoa(pconn->addr));
@


1.53
log
@Move setsockopt helper functions to a separate file.

IPv6 support is coming and we don't want to pollute the interface.c file
with too many of these helper functions.

Also, rename these functions from if_set_* to sock_set_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.52 2016/05/23 16:20:59 renato Exp $ */
d51 1
a51 1
gen_ldp_hdr(struct ibuf *buf, u_int16_t size)
d55 1
a55 1
	bzero(&ldp_hdr, sizeof(ldp_hdr));
d66 1
a66 1
gen_msg_tlv(struct ibuf *buf, u_int32_t type, u_int16_t size)
d70 1
a70 4
	/* We want just the size of the value */
	size -= TLV_HDR_LEN;

	bzero(&msg, sizeof(msg));
d72 2
a73 1
	msg.length = htons(size);
d108 1
a108 1
		struct cmsghdr hdr;
a113 3
	struct ldp_hdr		 ldp_hdr;
	struct ldp_msg		 ldp_msg;
	struct iface		*iface = NULL;
d117 1
a117 1
	u_int16_t		 len;
d119 7
d131 1
a131 1
	bzero(&msg, sizeof(msg));
d165 4
a168 1
	len = (u_int16_t)r;
d170 4
a173 5
	/* find a matching interface */
	if ((fd == leconf->ldp_discovery_socket) &&
	    (iface = disc_find_iface(ifindex, src.sin_addr)) == NULL) {
		log_debug("disc_recv_packet: cannot find a matching subnet "
		    "on interface index %d for %s", ifindex,
d179 4
a182 2
	if (len < LDP_HDR_SIZE || len > LDP_MAX_LEN) {
		log_debug("disc_recv_packet: bad packet size");
d185 3
a187 5
	bcopy(buf, &ldp_hdr, sizeof(ldp_hdr));

	if (ntohs(ldp_hdr.version) != LDP_VERSION) {
		log_debug("dsc_recv_packet: invalid LDP version %d",
		    ldp_hdr.version);
d190 6
a195 5

	if (ntohs(ldp_hdr.length) >
	    len - sizeof(ldp_hdr.version) - sizeof(ldp_hdr.length)) {
		log_debug("disc_recv_packet: invalid LDP packet length %u",
		    ntohs(ldp_hdr.length));
d198 2
d201 14
a214 3
	if (len < LDP_HDR_SIZE + LDP_MSG_LEN) {
		log_debug("disc_recv_packet: invalid LDP packet length %d",
		    ntohs(ldp_hdr.length));
d217 2
a218 2

	bcopy(buf + LDP_HDR_SIZE, &ldp_msg, sizeof(ldp_msg));
d223 2
a224 1
		recv_hello(iface, src.sin_addr, buf, len);
d371 2
a372 2
	int		 msg_size;
	u_int16_t	 pdu_len;
d435 2
a436 2
		while (len >= LDP_MSG_LEN) {
			u_int16_t type;
d440 3
a442 4

			pdu_len = ntohs(ldp_msg->length) + TLV_HDR_LEN;
			if (pdu_len > len ||
			    pdu_len < LDP_MSG_LEN - TLV_HDR_LEN) {
d448 1
d569 2
a570 2
session_shutdown(struct nbr *nbr, u_int32_t status, u_int32_t msgid,
    u_int32_t type)
@


1.52
log
@Standardize some log messages and fix some inconsistencies.

We were using several different names for the same thing in our log
messages: neighbor, neighbor ID, nbr ID and LSR ID.

Standardize to always use "lsr-id" to refer to a neighbor.

Also:
* Use log_warnx() instead of log_warn() when appropriate;
* Use fatal(x) instead of err(x) when appropriate;
* Fix some inconsistent log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.51 2016/05/23 16:18:51 renato Exp $ */
d89 1
a89 1
		if (if_set_mcast(iface) == -1) {
@


1.51
log
@Make neighbor parameters per lsr-id not per transport-address.

With the advent of IPv6 support, a single neighbor can have two different
transport-addresses: one for ipv4 and one for ipv6. In order to define
neighbor-specific parameters in an indistinguishable way, define them
by lsr-id. This way we can switch between LDPov4 and LDPov6 and keep
the same configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.50 2016/05/23 16:16:44 renato Exp $ */
d556 1
a556 1
	log_debug("%s: nbr ID %s", __func__, inet_ntoa(nbr->id));
d569 1
a569 1
	log_debug("%s: closing session with nbr ID %s", __func__,
@


1.50
log
@Rework the way we handle income connection requests.

The logic of the previous code was to accept all TCP connection requests
(destined to port 646) and create a tcp_conn structure for each them. Once
the first packet of a connection was received, we would analyze the
LDP Initialization message and identify its origin by looking at the
LSR-ID field.

When parsing a received TCP packet, we would need to distinguish between
two cases: tcp packet from an LDP neighbor and tcp packet from a newborn
connection (not associated with any neighbor yet). For this reason,
the session_read() function was quite complicated.

Also, we were not keeping track of the allocated tcp_conn structures. So,
we were subject to memory leaks and even DOS attacks.

With this patch, we also accept all TCP connection requests, but with two
major differences:
* We identify the neighbor by the source address of the SYN
  packet. This is possible because we don't support label spaces, so
  the transport-address by itself is enough to identify a neighbor,
  we don't need to wait for the Initialization message;
* If there's no matching adjacency for this neighbor, then we start a
  timer of 5 seconds. If we receive a Hello packet from this neighbor
  within this interval, then we stop this timer and move on in
  the Initialization state machine. Otherwise, we send a No Hello
  Notification message and close the socket. We try to avoid sending
  the No Hello notification as much as possible because it triggers the
  backoff exponential in the remote peer, which considerably slow down
  the session establishment process.

In summary, this new approach allows for a simpler code and fixes the
memory leak problem mentioned before.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.49 2016/05/23 16:08:18 renato Exp $ */
d321 1
a321 1
	nbrp = nbr_params_find(leconf, nbr->raddr);
@


1.49
log
@Several improvements in the parsing of UDP/Hello packets.

* Fix check of the packet's size and the "PDU Length" field;
* Add check for the "Message Length" field;
* Check for invalid labelspace earlier.
* Use if_lookup() on disc_recv_iface() to reduce one level of identation;

Additionally, add the following safeguards:
* Check for unicast link hellos;
* Check for multicast targeted hellos;
* Validate packet's source address;
* Validate received transport-address.

Put the ancillary function bad_ip_addr() into a new file, util.c, which
will be used later for several other things.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.48 2016/05/23 16:06:08 renato Exp $ */
d250 1
d252 2
a253 3
	socklen_t		 len = sizeof(src);
	struct nbr_params	*nbrp;
	int			 opt;
d274 48
a321 1
	nbrp = nbr_params_find(leconf, src.sin_addr);
d325 1
a325 1
			close(newfd);
d330 1
a330 2
		if (getsockopt(newfd, IPPROTO_TCP, TCP_MD5SIG,
		    &opt, &len) == -1)
d333 2
a334 3
			log_warnx(
			    "connection attempt without md5 signature");
			close(newfd);
d339 2
a340 1
	tcp_new(newfd, NULL);
d346 2
a347 2
	struct tcp_conn	*tcp = arg;
	struct nbr	*nbr = tcp->nbr;
d355 1
a355 2
	if (event != EV_READ) {
		log_debug("%s: spurious event", __func__);
a356 1
	}
d362 1
a362 4
			if (nbr)
				nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
			else
				tcp_close(tcp);
d371 1
a371 4
		if (nbr)
			nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
		else
			tcp_close(tcp);
d380 1
a380 7
			if (nbr)
				session_shutdown(nbr, S_BAD_PROTO_VER, 0, 0);
			else {
				send_notification(S_BAD_PROTO_VER, tcp, 0, 0);
				msgbuf_write(&tcp->wbuf.wbuf);
				tcp_close(tcp);
			}
d391 1
a391 1
		if (nbr && nbr->state == NBR_STA_OPER)
d397 1
a397 7
			if (nbr)
				session_shutdown(nbr, S_BAD_PDU_LEN, 0, 0);
			else {
				send_notification(S_BAD_PDU_LEN, tcp, 0, 0);
				msgbuf_write(&tcp->wbuf.wbuf);
				tcp_close(tcp);
			}
d403 5
a407 26
		if (nbr) {
			if (ldp_hdr->lsr_id != nbr->id.s_addr ||
			    ldp_hdr->lspace_id != 0) {
				session_shutdown(nbr, S_BAD_LDP_ID, 0, 0);
				free(buf);
				return;
			}
		} else {
			nbr = nbr_find_ldpid(ldp_hdr->lsr_id);
			if (!nbr) {
				send_notification(S_NO_HELLO, tcp, 0, 0);
				msgbuf_write(&tcp->wbuf.wbuf);
				tcp_close(tcp);
				free(buf);
				return;
			}
			/* handle duplicate SYNs */
			if (nbr->tcp) {
				tcp_close(tcp);
				free(buf);
				return;
			}

			nbr->tcp = tcp;
			tcp->nbr = nbr;
			nbr_fsm(nbr, NBR_EVT_MATCH_ADJ);
d528 8
a535 1
	struct nbr *nbr = tcp->nbr;
d537 8
a544 7
	if (event & EV_WRITE) {
		if (msgbuf_write(&tcp->wbuf.wbuf) <= 0 && errno != EAGAIN) {
			if (nbr)
				nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
		}
	} else
		log_debug("%s: spurious event", __func__);
d553 3
a572 2
	nbr->tcp = NULL;

a612 5
	if ((tcp->rbuf = calloc(1, sizeof(struct ibuf_read))) == NULL)
		fatal(__func__);

	if (nbr)
		tcp->nbr = nbr;
d616 10
a625 2
	event_set(&tcp->rev, tcp->fd, EV_READ | EV_PERSIST, session_read, tcp);
	event_add(&tcp->rev, NULL);
d634 7
a640 1
	event_del(&tcp->rev);
a642 1
	free(tcp->rbuf);
d644 65
@


1.48
log
@Don't ignore notification messages before the session is operational.

This was preventing us from triggering the backoff exponential timer
after receiving a 'No Hello' notification.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.47 2016/05/23 16:04:04 renato Exp $ */
d45 1
a45 1
struct iface	*disc_find_iface(unsigned int, struct in_addr);
d145 8
d214 2
a215 1
disc_find_iface(unsigned int ifindex, struct in_addr src)
d220 22
a241 16
	LIST_FOREACH(iface, &leconf->iface_list, entry)
		LIST_FOREACH(if_addr, &iface->addr_list, entry)
			switch (iface->type) {
			case IF_TYPE_POINTOPOINT:
				if (ifindex == iface->ifindex &&
				    if_addr->dstbrd.s_addr == src.s_addr)
					return (iface);
				break;
			default:
				if (ifindex == iface->ifindex &&
				    (if_addr->addr.s_addr &
					if_addr->mask.s_addr) ==
				    (src.s_addr & if_addr->mask.s_addr))
					return (iface);
				break;
			}
@


1.47
log
@Improve the parser of TCP/session packets.

Add more safeguards against malformed packets and fix existing ones. Also,
rename a few variables and constants to match their real meaning. For
example, rename gen_msg_tlv() to gen_msg_hdr() because this function
generates an LDP header, not a TLV.

Finally, clean-up all the send_* functions so they all follow the same
pattern.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.46 2016/05/23 16:01:59 renato Exp $ */
a430 1
			case MSG_TYPE_NOTIFICATION:
a437 1
			default:
d444 2
@


1.46
log
@Respect the received Max PDU Length field.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.45 2016/05/23 15:47:24 renato Exp $ */
d57 2
a58 5

	/* We want just the size of the value */
	size -= TLV_HDR_LEN;

	ldp_hdr.length = htons(size);
d344 1
a344 1
		if (nbr->state == NBR_STA_OPER)
d348 1
a348 1
		if (pdu_len < (LDP_HDR_PDU_LEN + LDP_MSG_LEN) ||
d360 1
d452 1
a452 1
				msg_size = recv_notification(nbr, pdu, pdu_len);
d455 1
a455 1
				msg_size = recv_init(nbr, pdu, pdu_len);
d458 1
a458 1
				msg_size = recv_keepalive(nbr, pdu, pdu_len);
d462 1
a462 1
				msg_size = recv_address(nbr, pdu, pdu_len);
d469 2
a470 2
				msg_size = recv_labelmessage(nbr, pdu,
				    pdu_len, type);
d482 1
a482 1
				msg_size = ntohs(ldp_msg->length);
d486 1
a486 1
			if (msg_size == -1) {
d493 2
a494 2
			pdu += msg_size + TLV_HDR_LEN;
			len -= msg_size + TLV_HDR_LEN;
d559 1
a559 1
	dlen = ntohs(l.length) + TLV_HDR_LEN;
@


1.45
log
@Move some code around.

This patch doesn't introduce any logical change.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.44 2016/05/23 15:43:11 renato Exp $ */
d342 9
d352 1
a352 1
		    pdu_len > LDP_MAX_LEN) {
@


1.44
log
@Add knob to configure the transport address.

This will be especially important when we add support for IPv6, because
we'll not be able to use the router-id as the transport-address in
this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.43 2016/05/23 15:14:08 renato Exp $ */
a233 32
struct tcp_conn *
tcp_new(int fd, struct nbr *nbr)
{
	struct tcp_conn *tcp;

	if ((tcp = calloc(1, sizeof(*tcp))) == NULL)
		fatal(__func__);
	if ((tcp->rbuf = calloc(1, sizeof(struct ibuf_read))) == NULL)
		fatal(__func__);

	if (nbr)
		tcp->nbr = nbr;

	tcp->fd = fd;
	evbuf_init(&tcp->wbuf, tcp->fd, session_write, tcp);
	event_set(&tcp->rev, tcp->fd, EV_READ | EV_PERSIST, session_read, tcp);
	event_add(&tcp->rev, NULL);

	return (tcp);
}

void
tcp_close(struct tcp_conn *tcp)
{
	evbuf_clear(&tcp->wbuf);
	event_del(&tcp->rev);
	close(tcp->fd);
	accept_unpause();
	free(tcp->rbuf);
	free(tcp);
}

d568 32
@


1.43
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.42 2016/05/23 14:49:56 renato Exp $ */
d62 1
a62 1
	ldp_hdr.lsr_id = ldpe_router_id();
@


1.42
log
@Call accept_unpause() when any TCP socket is closed.

We were calling accept_unpause() only when an LDP session is shut
down. But, during the LDP session establishment process, we may have
TCP sockets that are not associated with any neighbor. If we close one
of these sockets, we must call accept_unpause() too.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.41 2015/07/21 04:43:28 renato Exp $ */
d93 2
a94 2
			log_warn("send_packet: error setting multicast "
			    "interface, %s", iface->name);
d100 1
a100 1
		log_warn("send_packet: error sending packet to %s",
d144 1
a144 1
			log_debug("disc_recv_packet: read error: %s",
d203 1
a203 1
		log_debug("recv_packet: unknown LDP packet type, source %s",
d240 1
a240 1
		fatal("tcp_new");
d242 1
a242 1
		fatal("tcp_new");
d289 1
a289 1
			log_debug("sess_recv_packet: accept error: %s",
d330 1
a330 1
		log_debug("session_read: spurious event");
d337 1
a337 1
			log_warn("session_read: read error");
d349 1
a349 1
		log_debug("session_read: connection closed by remote end");
d498 2
a499 2
				log_debug("session_read: unknown LDP packet "
				    "from nbr %s", inet_ntoa(nbr->id));
d541 1
a541 1
		log_debug("session_write: spurious event");
d550 1
a550 1
	log_debug("session_shutdown: nbr ID %s", inet_ntoa(nbr->id));
d563 1
a563 1
	log_debug("session_close: closing session with nbr ID %s",
@


1.41
log
@Add configuration reload support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.40 2015/07/21 04:39:28 renato Exp $ */
d261 1
a570 2

	accept_unpause();
@


1.40
log
@Improve handling of addresses on ldpe.

This is a preliminary work for the the next patch (sigup config
reload). We want to make sure that the ldpe process can handle duplicated
addresses.

The idea is to alloc two different if_addr structures for each address,
and link one in the global list of addresses (used to send address
messages) and link the other to the associated interface list of
addresses.

Doing that we will be able to call kif_redistribute() after reloading
the config file and activate the new LDP enabled interfaces.

NOTE: Interfaces are created at config parse time and the child
processes inherit them on fork() so there's no need to send a status
update at startup.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.39 2015/07/19 21:01:56 renato Exp $ */
d293 1
a293 1
	nbrp = nbr_params_find(src.sin_addr);
@


1.39
log
@Implement md5 authentication support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.38 2015/04/04 15:04:49 renato Exp $ */
d215 1
a215 1
		LIST_FOREACH(if_addr, &iface->addr_list, iface_entry)
@


1.38
log
@Give more detailed information on a couple of debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.37 2015/02/09 11:54:24 claudio Exp $ */
d26 1
d43 1
d271 2
d291 20
@


1.37
log
@More SOCK_NONBLOCK | SOCK_CLOEXEC love and one less session_socket_blockmode
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.36 2014/10/25 03:23:49 lteo Exp $ */
d98 2
a99 1
		log_warn("send_packet: error sending packet");
d161 3
a163 1
		log_debug("disc_recv_packet: cannot find a matching interface");
@


1.36
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.35 2014/07/12 19:22:32 krw Exp $ */
d270 2
a271 1
	newfd = accept(fd, (struct sockaddr *)&src, &len);
a284 2

	session_socket_blockmode(newfd, BM_NONBLOCK);
@


1.35
log
@msgbuf_write() <= 0 for a few more daemons.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.34 2013/11/26 11:59:38 henning Exp $ */
a24 1
#include <netinet/in_systm.h>
@


1.34
log
@deal with msgbuf_write EAGAIN, ok gilles benno
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.32 2013/10/15 20:31:14 renato Exp $ */
d510 1
a510 1
		if (msgbuf_write(&tcp->wbuf.wbuf) == -1 && errno != EAGAIN) {
@


1.33
log
@Improve parsing of label mapping messages and merge all recv_label*
functions into a single generic function.

Add a few error checks and implement parsing of optional tlvs.
Putting it all together helps avoid to code duplication and improve
maintainability.
@
text
@d510 1
a510 1
		if (msgbuf_write(&tcp->wbuf.wbuf) == -1) {
@


1.32
log
@Improve debug and error logs.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.31 2013/10/15 20:27:40 renato Exp $ */
a463 2
				msg_size = recv_labelmapping(nbr, pdu, pdu_len);
				break;
a464 2
				msg_size = recv_labelrequest(nbr, pdu, pdu_len);
				break;
a465 2
				msg_size = recv_labelwithdraw(nbr, pdu, pdu_len);
				break;
d467 3
a469 1
				msg_size = recv_labelrelease(nbr, pdu, pdu_len);
a470 1
			case MSG_TYPE_LABELABORTREQ:
@


1.31
log
@Generate the NBR_EVT_PDU_RCVD event in a single point.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.30 2013/10/15 19:59:53 renato Exp $ */
d529 1
a529 2
	log_debug("session_shutdown: nbr ID %s, status %x",
	    inet_ntoa(nbr->id), status);
@


1.30
log
@Improve parsing of LDP messages.
Add more sanity checks and send proper notification messages on error
conditions.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.29 2013/10/15 16:47:24 renato Exp $ */
d391 3
@


1.29
log
@Ignore messages that have Unknown flag set.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.28 2013/06/05 19:19:10 miod Exp $ */
d348 2
a349 1
		if (pdu_len < LDP_HDR_SIZE || pdu_len > LDP_MAX_LEN) {
d351 1
a351 1
				session_shutdown(nbr, S_BAD_MSG_LEN, 0, 0);
d353 1
a353 1
				send_notification(S_BAD_MSG_LEN, tcp, 0, 0);
a408 3
			case MSG_TYPE_NOTIFICATION:
				/* notifications are always processed */
				break;
d427 1
@


1.28
log
@Fix build on vax
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.27 2013/06/04 02:34:48 claudio Exp $ */
d477 9
a485 2
				free(buf);
				return;
@


1.27
log
@Always accept TCP connection requests and identify to which neighbor
it belongs only _after_ receiving an Initialization message containing
the information we need. Before an Initialization message is received,
the TCP connection shouldn't be associated with any neighbor/adjacency.
Therefor refactor that part into a own module.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.26 2013/06/04 02:25:28 claudio Exp $ */
d392 2
d395 1
a395 1
			u_int16_t type = ntohs(ldp_msg->type);
@


1.26
log
@Implement support for adjacencies and targeted hellos
Refactor adjacencies out of the neighbor handling so that it is possible to
have more complex topologies with targeted sessions.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.25 2013/06/03 16:53:49 claudio Exp $ */
d230 31
a264 1
	struct nbr		*nbr = NULL;
d288 1
a288 16
	nbr = nbr_find_ip(src.sin_addr.s_addr);
	if (nbr == NULL) {
		struct ibuf	*buf;
		/* If there is no neighbor matching there is no
		   Hello adjacency: try to send notification */
		log_warnx("Connection attempt from unknown neighbor %s: %s",
		    inet_ntoa(src.sin_addr), "NO HELLO");
		buf = send_notification(S_NO_HELLO, 0, 0);
		write(newfd, buf->buf, buf->wpos);
		ibuf_free(buf);
		close(newfd);
		return;
	}

	nbr->fd = newfd;
	nbr_fsm(nbr, NBR_EVT_CONNECT_UP);
d294 2
a295 1
	struct nbr	*nbr = arg;
d308 2
a309 2
	if ((n = read(fd, nbr->rbuf->buf + nbr->rbuf->wpos,
	    sizeof(nbr->rbuf->buf) - nbr->rbuf->wpos)) == -1) {
d312 4
a315 1
			nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
d324 4
a327 1
		nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
d330 1
a330 1
	nbr->rbuf->wpos += n;
d332 1
a332 1
	while ((len = session_get_pdu(nbr->rbuf, &buf)) > 0) {
d336 7
a342 1
			session_shutdown(nbr, S_BAD_PROTO_VER, 0, 0);
d349 7
a355 1
			session_shutdown(nbr, S_BAD_MSG_LEN, 0, 0);
d360 26
a385 5
		if (ldp_hdr->lsr_id != nbr->id.s_addr ||
		    ldp_hdr->lspace_id != 0) {
			session_shutdown(nbr, S_BAD_LDP_ID, 0, 0);
			free(buf);
			return;
d500 2
a501 1
	struct nbr *nbr = arg;
d504 4
a507 2
		if (msgbuf_write(&nbr->wbuf.wbuf) == -1)
			nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
d511 1
a511 1
	evbuf_event_add(&nbr->wbuf);
d524 1
a524 1
	msgbuf_write(&nbr->wbuf.wbuf);
d535 2
a536 2
	evbuf_clear(&nbr->wbuf);
	event_del(&nbr->rev);
a540 1
	close(nbr->fd);
@


1.25
log
@Implement support for multiple addresses per interface.
This replaces the way addresses and interface are chained together.
In ospfd there was a 1 to 1 mapping (with iface clones) but LDP does
not have that limitation.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.24 2013/06/01 19:01:32 claudio Exp $ */
d84 1
a84 1
/* send and receive packets */
d86 2
a87 1
send_packet(struct iface *iface, void *pkt, size_t len, struct sockaddr_in *dst)
d90 1
a90 1
	if (IN_MULTICAST(ntohl(dst->sin_addr.s_addr)))
d97 3
a99 4
	if (sendto(iface->discovery_fd, pkt, len, 0,
	    (struct sockaddr *)dst, sizeof(*dst)) == -1) {
		log_warn("send_packet: error sending packet on interface %s",
		    iface->name);
d119 1
a119 1
	struct iface		*iface;
d159 2
a160 1
	if ((iface = disc_find_iface(ifindex, src.sin_addr)) == NULL) {
a177 7
	if (ldp_hdr.lspace_id != 0) {
		log_debug("disc_recv_packet: invalid label space "
		    "ID %s, interface %s", ldp_hdr.lspace_id,
		    iface->name);
		return;
	}

d199 2
a200 2
		log_debug("recv_packet: unknown LDP packet type, interface %s",
		    iface->name);
@


1.24
log
@Improve error handling on session_read
* Don't try to send a Shutdown message if the connection is already
  closed or a read error occured;
* As per RFC 5036, send a Shutdown message if an unexpected message is
  received during the initialization process;
* Check if the whole LSR ID of received messages is correct;
* On ldpe_dispatch_main(), ignore the messages from the lde process
  whose associated neighbor is not in the operational state.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.23 2013/06/01 18:47:07 claudio Exp $ */
d42 3
a44 1
struct iface	*find_iface(struct ldpd_conf *, unsigned int, struct in_addr);
a116 1
	struct ldpd_conf	*xconf = bula;
d159 1
a159 1
	if ((iface = find_iface(xconf, ifindex, src.sin_addr)) == NULL) {
d211 1
a211 1
find_iface(struct ldpd_conf *xconf, unsigned int ifindex, struct in_addr src)
d213 2
a214 1
	struct iface	*iface = NULL;
d216 16
a231 16
	/* returned interface needs to be active */
	LIST_FOREACH(iface, &xconf->iface_list, entry) {
		switch (iface->type) {
		case IF_TYPE_POINTOPOINT:
			if (ifindex == iface->ifindex &&
			    iface->dst.s_addr == src.s_addr)
				return (iface);
			break;
		default:
			if (ifindex == iface->ifindex &&
			    (iface->addr.s_addr & iface->mask.s_addr) ==
			    (src.s_addr & iface->mask.s_addr))
				return (iface);
			break;
		}
	}
@


1.23
log
@Drop support for per-interface labelspaces.
Support for per-interface labelspaces is only necessary for legacy ATM/FR
interfaces running in cell-mode. We shouldn't worry about this.
For platform-wide label spaces the label space id is always 0.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.22 2013/06/01 18:35:02 claudio Exp $ */
a41 2
int		 ldp_hdr_sanity_check(struct ldp_hdr *, u_int16_t,
		    const struct iface *);
d176 4
a179 1
	if (ldp_hdr_sanity_check(&ldp_hdr, len, iface) == -1)
d181 1
a197 1

a208 17
int
ldp_hdr_sanity_check(struct ldp_hdr *ldp_hdr, u_int16_t len,
    const struct iface *iface)
{
	struct in_addr		 addr;

	if (ldp_hdr->lspace_id != 0) {
		addr.s_addr = ldp_hdr->lspace_id;
		log_debug("ldp_hdr_sanity_check: invalid label space "
		    "ID %s, interface %s", inet_ntoa(addr),
		    iface->name);
		return (-1);
	}

	return (0);
}

a283 1
	struct iface	*iface = nbr->iface;
d299 2
a300 1
			session_shutdown(nbr, S_SHUTDOWN, 0, 0);
d308 2
a309 1
		session_shutdown(nbr, S_SHUTDOWN, 0, 0);
d330 2
a331 1
		if (ldp_hdr_sanity_check(ldp_hdr, len, iface) == -1) {
d342 1
d347 2
a348 1
				session_shutdown(nbr, S_BAD_TLV_LEN, 0, 0);
d353 40
d394 1
a394 1
			switch (ntohs(ldp_msg->type)) {
a420 1
			case MSG_TYPE_HELLO:
d423 1
a423 1
				    "type interface %s", iface->name);
@


1.22
log
@Drop support for passive interfaces.
Support for passive interfaces was inherited from ospfd but it doesn't
make any sense at all for ldpd.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.21 2013/06/01 18:24:28 claudio Exp $ */
d50 1
a50 1
gen_ldp_hdr(struct ibuf *buf, struct iface *iface, u_int16_t size)
d62 1
a62 2
	if (iface)
		ldp_hdr.lspace_id = iface->lspace_id;
d214 1
a214 1
	if (ldp_hdr->lspace_id != iface->lspace_id) {
d285 1
a285 1
		buf = send_notification(S_NO_HELLO, NULL, 0, 0);
@


1.21
log
@Use the nbr_stop_[*]timer functions
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.20 2013/06/01 18:16:35 claudio Exp $ */
d236 1
a236 2
			    iface->dst.s_addr == src.s_addr &&
			    !iface->passive)
d242 1
a242 2
			    (src.s_addr & iface->mask.s_addr) &&
			    !iface->passive)
@


1.20
log
@After returning from accept, we got a TCP connection not a LDP session.
Rename event/actions in the discovery FSM to avoid confusion
* NBR_EVT_SESSION_UP -> NBR_EVT_CONNECT_UP
* NBR_ACT_SESSION_EST -> NBR_ACT_CONNECT_SETUP
* nbr_act_session_establish -> nbr_act_connect_setup
* NBR_ACT_INIT_SEND -> NBR_ACT_PASSIVE_INIT
* NBR_ACT_STRT_KTIMER -> NBR_ACT_SESSION_EST
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.19 2013/06/01 01:39:04 claudio Exp $ */
d460 2
a461 4
	if (evtimer_pending(&nbr->keepalive_timer, NULL))
		evtimer_del(&nbr->keepalive_timer);
	if (evtimer_pending(&nbr->keepalive_timeout, NULL))
		evtimer_del(&nbr->keepalive_timeout);
@


1.19
log
@Don't set the Message ID for hello messages.
The Message ID field is used by notification messages to identify a
given message.  This is the behavior adopted by Cisco IOS.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.18 2013/05/30 15:49:33 claudio Exp $ */
d296 1
a296 1
	nbr_fsm(nbr, NBR_EVT_SESSION_UP);
@


1.18
log
@Improve sanity checks on received UDP messages
The actual meaning of the "PDU Length" field is the total length
of the LDP PDU, excluding the "Version" and "PDU Length" fields (as
per RFC 5036, section 3.1).
Diff from Renato Westphal [renatowestphal at gmail.com]
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.17 2013/03/11 17:40:11 deraadt Exp $ */
d79 2
a80 1
	msg.msgid = htonl(++msgcnt);
@


1.17
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.16 2012/04/12 17:33:43 claudio Exp $ */
a124 1
	int			 l;
d178 1
a178 1
	if ((l = ldp_hdr_sanity_check(&ldp_hdr, len, iface)) == -1)
d181 3
a183 2
	if (l > len) {
		log_debug("disc_recv_packet: invalid LDP packet length %d",
d222 1
a222 1
	return (ntohs(ldp_hdr->length));
d307 1
a307 1
	int		 l, msg_size;
d347 1
a347 1
		if ((l = ldp_hdr_sanity_check(ldp_hdr, len, iface)) == -1) {
@


1.16
log
@accept pacing ldpd way. Since this daemon has multiple listening fds
we add them all to a accept queue that does the pacing with the
accept_pause() and accept_unpause() calls.
With and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.15 2011/03/12 01:52:04 claudio Exp $ */
d271 2
a272 1
		} else if (errno != EWOULDBLOCK && errno != EINTR)
@


1.15
log
@Log the fact that a session was not accepted because of missing HELLOs.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.14 2011/01/10 12:28:25 claudio Exp $ */
d260 1
a260 1
	if (event != EV_READ)
d265 9
a273 2
		log_debug("sess_recv_packet: accept error: %s",
		    strerror(errno));
d464 1
@


1.14
log
@Fix a bad heritage from ospfd. Make neighbors independent of interfaces.
They are not bound as strongly as in ospf and causes problems when the
TCP connection is established from an not connected IP (e.g. a loopback).
Use three RB trees to sort the neighbor list by id, addr and peerid.
More cleanup is needed but this makes ldpd work against peers using
loopback IPs. Problem found, reported and fix tested again by Marcel Wiget.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.13 2010/11/04 09:52:16 claudio Exp $ */
d277 2
@


1.13
log
@Rewrite all packet parsers to be more careful about alignment. Until
now ldpd had no chance to run on a strict alignment architecture but
this makes ldpd happy on sparc64. Be careful to do all needed overflow
checks and try to make all parsing functions look similar.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.12 2010/05/26 13:56:08 nicm Exp $ */
a44 1
struct iface	*session_find_iface(struct ldpd_conf *, struct in_addr);
d62 2
a63 1
	ldp_hdr.lspace_id = iface->lspace_id;
a255 2
	struct ldpd_conf	*xconf = bula;
	struct iface		*iface;
d272 1
a272 7
	if ((iface = session_find_iface(xconf, src.sin_addr)) == NULL) {
		log_debug("sess_recv_packet: cannot find a matching interface");
		close(newfd);
		return;
	}

	nbr = nbr_find_ip(iface, src.sin_addr.s_addr);
d277 1
a277 1
		buf = send_notification(S_NO_HELLO, iface, 0, 0);
a454 25
}

struct iface *
session_find_iface(struct ldpd_conf *xconf, struct in_addr src)
{
	struct iface	*iface = NULL;

	/* returned interface needs to be active */
	LIST_FOREACH(iface, &xconf->iface_list, entry) {
		switch (iface->type) {
		case IF_TYPE_POINTOPOINT:
			if (iface->dst.s_addr == src.s_addr &&
			    !iface->passive)
				return (iface);
			break;
		default:
			if ((iface->addr.s_addr & iface->mask.s_addr) ==
			    (src.s_addr & iface->mask.s_addr) &&
			    !iface->passive)
				return (iface);
			break;
		}
	}

	return (NULL);
@


1.12
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.11 2010/05/14 13:49:09 claudio Exp $ */
d118 2
a119 2
	struct ldp_hdr		*ldp_hdr;
	struct ldp_msg		*ldp_msg;
d171 1
a171 1
	ldp_hdr = (struct ldp_hdr *)buf;
d173 1
a173 1
	if (ntohs(ldp_hdr->version) != LDP_VERSION) {
d175 1
a175 1
		    ldp_hdr->version);
d179 1
a179 1
	if ((l = ldp_hdr_sanity_check(ldp_hdr, len, iface)) == -1)
d184 1
a184 1
		    ntohs(ldp_hdr->length));
a187 2
	ldp_msg = (struct ldp_msg *)(buf + LDP_HDR_SIZE);

d190 1
a190 1
		    ntohs(ldp_hdr->length));
d194 3
d198 1
a198 1
	switch (ntohs(ldp_msg->type)) {
d377 1
a379 3
			case MSG_TYPE_ADDRWITHDRAW:
				msg_size = recv_address_withdraw(nbr, pdu, pdu_len);
				break;
d395 2
a396 2
				log_debug("session_read: unknown LDP packet type "
				    "interface %s", iface->name);
@


1.11
log
@Do not send notifications directly onto the wire. Decide in the caller how
to send the notification. On accept use write() else queue message and try
to send the queued messages out via msgbuf_write(). This may still fail but
is better then the code beforehands.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.10 2010/05/01 12:22:33 jsg Exp $ */
d46 1
a46 1
ssize_t		 session_get_pdu(struct buf_read *, char **);
d51 1
a51 1
gen_ldp_hdr(struct buf *buf, struct iface *iface, u_int16_t size)
d65 1
a65 1
	return (buf_add(buf, &ldp_hdr, LDP_HDR_SIZE));
d69 1
a69 1
gen_msg_tlv(struct buf *buf, u_int32_t type, u_int16_t size)
d81 1
a81 1
	return (buf_add(buf, &msg, sizeof(msg)));
d134 1
a134 1
	iov.iov_len = READ_BUF_SIZE;
d281 1
a281 1
		struct buf	*buf;
d286 1
a286 1
		buf_free(buf);
d492 1
a492 1
session_get_pdu(struct buf_read *r, char **b)
@


1.10
log
@split up a multiple assignment so we aren't casting an lvalue.
ok michele@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.9 2010/04/29 12:09:28 claudio Exp $ */
a278 1
	/* XXX */
d281 1
d283 4
a286 2
		   Hello adjacency: send notification */
		send_notification(S_NO_HELLO, iface, newfd, 0, 0);
d442 3
a444 2
	if (status != S_SHUTDOWN)
		send_notification_nbr(nbr, S_SHUTDOWN, msgid, type);
@


1.9
log
@Remove some more ospfd-ism from the interface code. This time remove
of most of the IF_TYPE_ special cases and most interface types.
Point-to-point and broadcast still present because of find_iface()
which needs addtional fixing.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.8 2010/04/15 15:37:51 claudio Exp $ */
d327 2
a328 1
		ldp_hdr = (struct ldp_hdr *)pdu = buf;
@


1.8
log
@session_shutdown() issues a NBR_EVT_CLOSE_SESSION and therefore a
session_close() which does the event_del(&nbr->rev) so no need to do it
twice. There is also no need to send two S_SHUTDOWN messages.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.7 2010/04/15 15:31:55 claudio Exp $ */
d213 6
a218 16
	if (iface->type != IF_TYPE_VIRTUALLINK) {
		if (ldp_hdr->lspace_id != iface->lspace_id) {
			addr.s_addr = ldp_hdr->lspace_id;
			log_debug("ldp_hdr_sanity_check: invalid label space "
			    "ID %s, interface %s", inet_ntoa(addr),
			    iface->name);
			return (-1);
		}
	} else {
		if (ldp_hdr->lspace_id != 0) {
			addr.s_addr = ldp_hdr->lspace_id;
			log_debug("ldp_hdr_sanity_check: invalid label space "
			    "ID %s, interface %s", inet_ntoa(addr),
			    iface->name);
			return (-1);
		}
a231 5
		case IF_TYPE_VIRTUALLINK:
			if ((src.s_addr == iface->dst.s_addr) &&
			    !iface->passive)
				return (iface);
			break;
a469 5
		case IF_TYPE_VIRTUALLINK:
			if ((src.s_addr == iface->dst.s_addr) &&
			    !iface->passive)
				return (iface);
			break;
@


1.7
log
@Fix fd leak in error case.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.6 2010/04/15 15:04:23 claudio Exp $ */
a327 2
			/* XXX find better error */
			event_del(&nbr->rev);
a335 1
		event_del(&nbr->rev);
d450 3
d454 2
a455 1
	send_notification_nbr(nbr, S_SHUTDOWN, msgid, type);
@


1.6
log
@Instead of having three ways of setting fds non-blocking use
session_socket_blockmode() everywhere.
Additionally make two fatal() distinguishable.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.5 2010/03/26 16:00:09 claudio Exp $ */
d290 1
@


1.5
log
@event_del() the read event when hitting a read error or when closing the
file descriptor. If not done, we will loop forever on this event.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.4 2010/02/25 17:40:46 claudio Exp $ */
d286 1
a286 4
	if (fcntl(newfd, F_SETFL, O_NONBLOCK) == -1) {
		log_debug("sess_recv_packet: unable to set non blocking flag");
		return;
	}
@


1.4
log
@Do not use bufferevent for something that's already covered in the imsg
buffer API. This fixes a few possible problems in session_read and does
some further cleanup in various places. Wrap msgbuf into evbuf to add
libevent functionality and use buf_read to handle the read side of a
session.  OK michele@@ and dlg@@ did not see anything evil
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.3 2009/11/01 11:09:58 michele Exp $ */
d331 1
d468 1
@


1.3
log
@Initialize "len" before using it in accept(2).

Found by Christophe Fillot

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.2 2009/06/05 22:34:45 michele Exp $ */
d46 1
d179 4
a182 2
	if (ntohs(ldp_hdr->length) > len ||
	    len <= sizeof(struct ldp_hdr)) {
a187 3
	if ((l = ldp_hdr_sanity_check(ldp_hdr, len, iface)) == -1)
		return;

d190 1
a190 1
	if (len < LDP_MSG_LEN) {
d267 1
a267 1
session_recv_packet(int fd, short event, void *bula)
d311 1
a311 1
session_read(struct bufferevent *bev, void *arg)
d313 1
a313 1
	struct nbr	*nbr = (struct nbr *)arg;
d317 3
a319 1
	u_int16_t	 len = EVBUFFER_LENGTH(EVBUFFER_INPUT(bev));
a320 3
	char		 buffer[LDP_MAX_LEN];
	char		*buf = buffer;
	int		 l, msg_size = 0;
d322 2
a323 7
	bufferevent_read(bev, buf, len);

another_packet:
	ldp_hdr = (struct ldp_hdr *)buf;

	if (ntohs(ldp_hdr->version) != LDP_VERSION) {
		session_shutdown(nbr, S_BAD_PROTO_VER, 0, 0);
d327 8
a334 4
	pdu_len = ntohs(ldp_hdr->length);

	if (pdu_len < LDP_HDR_SIZE || pdu_len > LDP_MAX_LEN) {
		session_shutdown(nbr, S_BAD_MSG_LEN, 0, 0);
d337 4
a340 2

	if ((l = ldp_hdr_sanity_check(ldp_hdr, len, iface)) == -1)
d342 2
d345 7
a351 2
	buf += LDP_HDR_SIZE;
	len -= LDP_HDR_SIZE;
d353 6
a358 4
	pdu_len -= LDP_HDR_SIZE - PDU_HDR_SIZE;

	while (pdu_len > LDP_MSG_LEN) {
		ldp_msg = (struct ldp_msg *)buf;
d360 3
a362 34
		/* switch LDP packet type */
		switch (ntohs(ldp_msg->type)) {
		case MSG_TYPE_NOTIFICATION:
			msg_size = recv_notification(nbr, buf, pdu_len);
			break;
		case MSG_TYPE_INIT:
			msg_size = recv_init(nbr, buf, pdu_len);
			break;
		case MSG_TYPE_KEEPALIVE:
			msg_size = recv_keepalive(nbr, buf, pdu_len);
			break;
		case MSG_TYPE_ADDR:
			msg_size = recv_address(nbr, buf, pdu_len);
			break;
		case MSG_TYPE_ADDRWITHDRAW:
			msg_size = recv_address_withdraw(nbr, buf, pdu_len);
			break;
		case MSG_TYPE_LABELMAPPING:
			msg_size = recv_labelmapping(nbr, buf, pdu_len);
			break;
		case MSG_TYPE_LABELREQUEST:
			msg_size = recv_labelrequest(nbr, buf, pdu_len);
			break;
		case MSG_TYPE_LABELWITHDRAW:
			msg_size = recv_labelwithdraw(nbr, buf, pdu_len);
			break;
		case MSG_TYPE_LABELRELEASE:
			msg_size = recv_labelrelease(nbr, buf, pdu_len);
			break;
		case MSG_TYPE_LABELABORTREQ:
		case MSG_TYPE_HELLO:
		default:
			log_debug("session_read: unknown LDP packet type "
			    "interface %s", iface->name);
d366 65
a430 1
		if (msg_size < 0)
d432 1
a432 5

		/* Analyse the next message */
		buf += msg_size + TLV_HDR_LEN;
		len -= msg_size + TLV_HDR_LEN;
		pdu_len -= msg_size + TLV_HDR_LEN;
a433 3

	if (len > LDP_HDR_SIZE)
		goto another_packet;
d437 1
a437 1
session_error(struct bufferevent *bev, short what, void *arg)
d441 7
a447 1
	nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
d466 2
a472 1
	bufferevent_free(nbr->bev);
d504 29
@


1.2
log
@Correctly send notification messages when errors occur.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d273 2
a274 1
	int			 newfd, len;
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d300 1
a300 1
		send_notification(S_NO_HELLO, iface, newfd);
d328 1
a328 5
		log_debug("session_read: nbr ID %s invalid LDP version %d",
		    inet_ntoa(nbr->id), ldp_hdr->version);
		send_notification_nbr(nbr, S_BAD_PROTO_VER);
		session_close(nbr);
		/* XXX: notify lde */
d335 1
a335 4
		log_debug("session_read: packet malformed");
		send_notification_nbr(nbr, S_BAD_MSG_LEN);
		session_close(nbr);
		/* XXX: notify lde */
d401 1
a401 1
session_write(struct bufferevent *bev, void *arg)
d403 3
d409 2
a410 1
session_error(struct bufferevent *bev, short what, void *arg)
d412 2
a413 1
	struct nbr *nbr = arg;
@

