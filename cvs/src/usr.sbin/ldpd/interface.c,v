head	1.50;
access;
symbols
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.47.0.2
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.4
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.50
date	2017.03.03.23.41.27;	author renato;	state Exp;
branches;
next	1.49;
commitid	lvj5kMm2TzZDSXqr;

1.49
date	2017.03.03.23.36.06;	author renato;	state Exp;
branches;
next	1.48;
commitid	nsyffCkbHeLwduqi;

1.48
date	2016.09.03.16.07.08;	author renato;	state Exp;
branches;
next	1.47;
commitid	fYTaUp1tzXub9AKi;

1.47
date	2016.07.01.23.29.55;	author renato;	state Exp;
branches;
next	1.46;
commitid	OkOx7tFZtmlIlivU;

1.46
date	2016.06.18.17.31.32;	author renato;	state Exp;
branches;
next	1.45;
commitid	Ou0pUplgSHSojMsH;

1.45
date	2016.06.09.17.26.32;	author renato;	state Exp;
branches;
next	1.44;
commitid	iKrQLOonXcGPkDwb;

1.44
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.43;
commitid	TLlfi1Pk0Z97z8HM;

1.43
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.42;
commitid	AQBoOveMRKjtVfFv;

1.42
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.41;
commitid	t07H0Mk6WGdVWB0W;

1.41
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.40;
commitid	D7VvXbswyzx5Ahb2;

1.40
date	2016.05.23.18.41.59;	author renato;	state Exp;
branches;
next	1.39;
commitid	zjb4P8L4wSROotP5;

1.39
date	2016.05.23.18.40.15;	author renato;	state Exp;
branches;
next	1.38;
commitid	LYl0nXLaUb8GwBRC;

1.38
date	2016.05.23.18.33.56;	author renato;	state Exp;
branches;
next	1.37;
commitid	YK3Z5X8iSxlfPhoT;

1.37
date	2016.05.23.18.28.22;	author renato;	state Exp;
branches;
next	1.36;
commitid	FV8IR5RMrg1EHRis;

1.36
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.35;
commitid	VpAym8dVR6eY4drQ;

1.35
date	2016.05.23.17.00.40;	author renato;	state Exp;
branches;
next	1.34;
commitid	3KHOYftnvJzmjKLP;

1.34
date	2016.05.23.16.31.27;	author renato;	state Exp;
branches;
next	1.33;
commitid	c72xshgOyJT70vM6;

1.33
date	2016.05.23.16.27.16;	author renato;	state Exp;
branches;
next	1.32;
commitid	cGXVHKZkPMEKUfRM;

1.32
date	2016.05.23.16.20.59;	author renato;	state Exp;
branches;
next	1.31;
commitid	nAtgYzDo97D7UnEI;

1.31
date	2016.05.23.16.14.36;	author renato;	state Exp;
branches;
next	1.30;
commitid	hNzA87VdOHsaOms9;

1.30
date	2016.05.23.15.57.50;	author renato;	state Exp;
branches;
next	1.29;
commitid	412vkTYh5W4EltoT;

1.29
date	2016.05.23.15.49.31;	author renato;	state Exp;
branches;
next	1.28;
commitid	RpMaNILGRIfJM8EJ;

1.28
date	2016.05.23.15.47.24;	author renato;	state Exp;
branches;
next	1.27;
commitid	Eng7dm0NElMq9Yi3;

1.27
date	2016.05.23.15.14.07;	author renato;	state Exp;
branches;
next	1.26;
commitid	l3e6PhvoAh8C7elc;

1.26
date	2015.09.27.17.30.38;	author stsp;	state Exp;
branches;
next	1.25;
commitid	pKhBZfZX0D7hOGSk;

1.25
date	2015.07.21.04.43.28;	author renato;	state Exp;
branches;
next	1.24;
commitid	QaTrdqMa9i0CUoyW;

1.24
date	2015.07.21.04.39.28;	author renato;	state Exp;
branches;
next	1.23;
commitid	KR83ZYzpLqbp9L95;

1.23
date	2015.07.19.21.04.38;	author renato;	state Exp;
branches;
next	1.22;
commitid	jI3o3zBRaRv2piIx;

1.22
date	2015.03.21.18.32.01;	author renato;	state Exp;
branches;
next	1.21;
commitid	Q890u5RO8xyMjkAO;

1.21
date	2015.03.21.18.25.08;	author renato;	state Exp;
branches;
next	1.20;
commitid	CeOnxdy8lmM2xe7l;

1.20
date	2013.10.15.20.41.09;	author renato;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.04.02.39.10;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.04.02.28.27;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2013.06.04.02.25.28;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2013.06.04.00.41.18;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2013.06.03.17.01.59;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2013.06.03.16.53.49;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.01.18.35.02;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.01.18.26.40;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2013.05.30.16.22.52;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2013.05.30.16.19.31;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2012.05.14.10.17.21;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.10.12.28.25;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.19.15.28.51;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.29.12.09.28;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.15.15.39.32;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2010.04.15.15.04.23;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2010.02.18.10.50.14;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Minor tweaks.
@
text
@/*	$OpenBSD: interface.c,v 1.49 2017/03/03 23:36:06 renato Exp $ */

/*
 * Copyright (c) 2013, 2016 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005, 2008 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>

#include "ldpd.h"
#include "ldpe.h"
#include "log.h"

static struct if_addr	*if_addr_new(struct kaddr *);
static struct if_addr	*if_addr_lookup(struct if_addr_head *, struct kaddr *);
static int		 if_start(struct iface *, int);
static int		 if_reset(struct iface *, int);
static void		 if_update_af(struct iface_af *, int);
static void		 if_hello_timer(int, short, void *);
static void		 if_start_hello_timer(struct iface_af *);
static void		 if_stop_hello_timer(struct iface_af *);
static int		 if_join_ipv4_group(struct iface *, struct in_addr *);
static int		 if_leave_ipv4_group(struct iface *, struct in_addr *);
static int		 if_join_ipv6_group(struct iface *, struct in6_addr *);
static int		 if_leave_ipv6_group(struct iface *, struct in6_addr *);

struct iface *
if_new(struct kif *kif)
{
	struct iface		*iface;

	if ((iface = calloc(1, sizeof(*iface))) == NULL)
		fatal("if_new: calloc");

	strlcpy(iface->name, kif->ifname, sizeof(iface->name));

	/* get type */
	if (kif->flags & IFF_POINTOPOINT)
		iface->type = IF_TYPE_POINTOPOINT;
	if (kif->flags & IFF_BROADCAST &&
	    kif->flags & IFF_MULTICAST)
		iface->type = IF_TYPE_BROADCAST;

	/* get index and flags */
	LIST_INIT(&iface->addr_list);
	iface->ifindex = kif->ifindex;
	iface->rdomain = kif->rdomain;
	iface->flags = kif->flags;
	iface->linkstate = kif->link_state;
	iface->if_type = kif->if_type;

	/* ipv4 */
	iface->ipv4.af = AF_INET;
	iface->ipv4.iface = iface;
	iface->ipv4.enabled = 0;
	iface->ipv4.state = IF_STA_DOWN;
	LIST_INIT(&iface->ipv4.adj_list);

	/* ipv6 */
	iface->ipv6.af = AF_INET6;
	iface->ipv6.iface = iface;
	iface->ipv6.enabled = 0;
	iface->ipv6.state = IF_STA_DOWN;
	LIST_INIT(&iface->ipv6.adj_list);

	return (iface);
}

void
if_exit(struct iface *iface)
{
	struct if_addr		*if_addr;

	log_debug("%s: interface %s", __func__, iface->name);

	if (iface->ipv4.state == IF_STA_ACTIVE)
		if_reset(iface, AF_INET);
	if (iface->ipv6.state == IF_STA_ACTIVE)
		if_reset(iface, AF_INET6);

	while ((if_addr = LIST_FIRST(&iface->addr_list)) != NULL) {
		LIST_REMOVE(if_addr, entry);
		free(if_addr);
	}
}

struct iface *
if_lookup(struct ldpd_conf *xconf, unsigned short ifindex)
{
	struct iface *iface;

	LIST_FOREACH(iface, &xconf->iface_list, entry)
		if (iface->ifindex == ifindex)
			return (iface);

	return (NULL);
}

struct iface_af *
iface_af_get(struct iface *iface, int af)
{
	switch (af) {
	case AF_INET:
		return (&iface->ipv4);
	case AF_INET6:
		return (&iface->ipv6);
	default:
		fatalx("iface_af_get: unknown af");
	}
}

static struct if_addr *
if_addr_new(struct kaddr *ka)
{
	struct if_addr	*if_addr;

	if ((if_addr = calloc(1, sizeof(*if_addr))) == NULL)
		fatal(__func__);

	if_addr->af = ka->af;
	if_addr->addr = ka->addr;
	if_addr->prefixlen = ka->prefixlen;
	if_addr->dstbrd = ka->dstbrd;

	return (if_addr);
}

static struct if_addr *
if_addr_lookup(struct if_addr_head *addr_list, struct kaddr *ka)
{
	struct if_addr	*if_addr;
	int		 af = ka->af;

	LIST_FOREACH(if_addr, addr_list, entry)
		if (!ldp_addrcmp(af, &if_addr->addr, &ka->addr) &&
		    if_addr->prefixlen == ka->prefixlen &&
		    !ldp_addrcmp(af, &if_addr->dstbrd, &ka->dstbrd))
			return (if_addr);

	return (NULL);
}

void
if_addr_add(struct kaddr *ka)
{
	struct iface		*iface;
	struct if_addr		*if_addr;
	struct nbr		*nbr;

	if (if_addr_lookup(&global.addr_list, ka) == NULL) {
		if_addr = if_addr_new(ka);

		LIST_INSERT_HEAD(&global.addr_list, if_addr, entry);
		RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
			if (nbr->state != NBR_STA_OPER)
				continue;
			if (if_addr->af == AF_INET && !nbr->v4_enabled)
				continue;
			if (if_addr->af == AF_INET6 && !nbr->v6_enabled)
				continue;

			send_address_single(nbr, if_addr, 0);
		}
	}

	iface = if_lookup(leconf, ka->ifindex);
	if (iface) {
		if (ka->af == AF_INET6 && IN6_IS_ADDR_LINKLOCAL(&ka->addr.v6))
			iface->linklocal = ka->addr.v6;

		if (if_addr_lookup(&iface->addr_list, ka) == NULL) {
			if_addr = if_addr_new(ka);
			LIST_INSERT_HEAD(&iface->addr_list, if_addr, entry);
			if_update(iface, if_addr->af);
		}
	}
}

void
if_addr_del(struct kaddr *ka)
{
	struct iface		*iface;
	struct if_addr		*if_addr;
	struct nbr		*nbr;

	iface = if_lookup(leconf, ka->ifindex);
	if (iface) {
		if (ka->af == AF_INET6 &&
		    IN6_ARE_ADDR_EQUAL(&iface->linklocal, &ka->addr.v6))
			memset(&iface->linklocal, 0, sizeof(iface->linklocal));

		if_addr = if_addr_lookup(&iface->addr_list, ka);
		if (if_addr) {
			LIST_REMOVE(if_addr, entry);
			if_update(iface, if_addr->af);
			free(if_addr);
		}
	}

	if_addr = if_addr_lookup(&global.addr_list, ka);
	if (if_addr) {
		RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
			if (nbr->state != NBR_STA_OPER)
				continue;
			if (if_addr->af == AF_INET && !nbr->v4_enabled)
				continue;
			if (if_addr->af == AF_INET6 && !nbr->v6_enabled)
				continue;
			send_address_single(nbr, if_addr, 1);
		}
		LIST_REMOVE(if_addr, entry);
		free(if_addr);
	}
}

static int
if_start(struct iface *iface, int af)
{
	struct iface_af		*ia;
	struct timeval		 now;

	log_debug("%s: %s address-family %s", __func__, iface->name,
	    af_name(af));

	ia = iface_af_get(iface, af);

	gettimeofday(&now, NULL);
	ia->uptime = now.tv_sec;

	switch (af) {
	case AF_INET:
		if (if_join_ipv4_group(iface, &global.mcast_addr_v4))
			return (-1);
		break;
	case AF_INET6:
		if (if_join_ipv6_group(iface, &global.mcast_addr_v6))
			return (-1);
		break;
	default:
		fatalx("if_start: unknown af");
	}

	send_hello(HELLO_LINK, ia, NULL);

	evtimer_set(&ia->hello_timer, if_hello_timer, ia);
	if_start_hello_timer(ia);
	return (0);
}

static int
if_reset(struct iface *iface, int af)
{
	struct iface_af		*ia;
	struct adj		*adj;

	log_debug("%s: %s address-family %s", __func__, iface->name,
	    af_name(af));

	ia = iface_af_get(iface, af);
	if_stop_hello_timer(ia);

	while ((adj = LIST_FIRST(&ia->adj_list)) != NULL)
		adj_del(adj, S_SHUTDOWN);

	/* try to cleanup */
	switch (af) {
	case AF_INET:
		if (global.ipv4.ldp_disc_socket != -1)
			if_leave_ipv4_group(iface, &global.mcast_addr_v4);
		break;
	case AF_INET6:
		if (global.ipv6.ldp_disc_socket != -1)
			if_leave_ipv6_group(iface, &global.mcast_addr_v6);
		break;
	default:
		fatalx("if_start: unknown af");
	}

	return (0);
}

static void
if_update_af(struct iface_af *ia, int link_ok)
{
	int			 addr_ok = 0, socket_ok, rtr_id_ok;
	struct if_addr		*if_addr;

	switch (ia->af) {
	case AF_INET:
		/*
		 * NOTE: for LDPv4, each interface should have at least one
		 * valid IP address otherwise they can not be enabled.
		 */
		LIST_FOREACH(if_addr, &ia->iface->addr_list, entry) {
			if (if_addr->af == AF_INET) {
				addr_ok = 1;
				break;
			}
		}
		break;
	case AF_INET6:
		/* for IPv6 the link-local address is enough. */
		if (IN6_IS_ADDR_LINKLOCAL(&ia->iface->linklocal))
			addr_ok = 1;
		break;
	default:
		fatalx("if_update_af: unknown af");
	}

	if ((ldp_af_global_get(&global, ia->af))->ldp_disc_socket != -1)
		socket_ok = 1;
	else
		socket_ok = 0;

	if (leconf->rtr_id.s_addr != INADDR_ANY)
		rtr_id_ok = 1;
	else
		rtr_id_ok = 0;

	if (ia->state == IF_STA_DOWN) {
		if (!ia->enabled || !link_ok || !addr_ok || !socket_ok ||
		    !rtr_id_ok)
			return;

		ia->state = IF_STA_ACTIVE;
		if_start(ia->iface, ia->af);
	} else if (ia->state == IF_STA_ACTIVE) {
		if (ia->enabled && link_ok && addr_ok && socket_ok && rtr_id_ok)
			return;

		ia->state = IF_STA_DOWN;
		if_reset(ia->iface, ia->af);
	}
}

void
if_update(struct iface *iface, int af)
{
	int			 link_ok;

	link_ok = (iface->flags & IFF_UP) &&
	    LINK_STATE_IS_UP(iface->linkstate);

	if (af == AF_INET || af == AF_UNSPEC)
		if_update_af(&iface->ipv4, link_ok);
	if (af == AF_INET6 || af == AF_UNSPEC)
		if_update_af(&iface->ipv6, link_ok);
}

void
if_update_all(int af)
{
	struct iface		*iface;

	LIST_FOREACH(iface, &leconf->iface_list, entry)
		if_update(iface, af);
}

/* timers */
/* ARGSUSED */
static void
if_hello_timer(int fd, short event, void *arg)
{
	struct iface_af		*ia = arg;

	send_hello(HELLO_LINK, ia, NULL);
	if_start_hello_timer(ia);
}

static void
if_start_hello_timer(struct iface_af *ia)
{
	struct timeval		 tv;

	timerclear(&tv);
	tv.tv_sec = ia->hello_interval;
	if (evtimer_add(&ia->hello_timer, &tv) == -1)
		fatal(__func__);
}

static void
if_stop_hello_timer(struct iface_af *ia)
{
	if (evtimer_pending(&ia->hello_timer, NULL) &&
	    evtimer_del(&ia->hello_timer) == -1)
		fatal(__func__);
}

struct ctl_iface *
if_to_ctl(struct iface_af *ia)
{
	static struct ctl_iface	 ictl;
	struct timeval		 now;
	struct adj		*adj;

	ictl.af = ia->af;
	memcpy(ictl.name, ia->iface->name, sizeof(ictl.name));
	ictl.ifindex = ia->iface->ifindex;
	ictl.state = ia->state;
	ictl.flags = ia->iface->flags;
	ictl.linkstate = ia->iface->linkstate;
	ictl.type = ia->iface->type;
	ictl.if_type = ia->iface->if_type;
	ictl.hello_holdtime = ia->hello_holdtime;
	ictl.hello_interval = ia->hello_interval;

	gettimeofday(&now, NULL);
	if (ia->state != IF_STA_DOWN &&
	    ia->uptime != 0) {
		ictl.uptime = now.tv_sec - ia->uptime;
	} else
		ictl.uptime = 0;

	ictl.adj_cnt = 0;
	LIST_FOREACH(adj, &ia->adj_list, ia_entry)
		ictl.adj_cnt++;

	return (&ictl);
}

/* multicast membership sockopts */
in_addr_t
if_get_ipv4_addr(struct iface *iface)
{
	struct if_addr		*if_addr;

	LIST_FOREACH(if_addr, &iface->addr_list, entry)
		if (if_addr->af == AF_INET)
			return (if_addr->addr.v4.s_addr);

	return (INADDR_ANY);
}

static int
if_join_ipv4_group(struct iface *iface, struct in_addr *addr)
{
	struct ip_mreq		 mreq;

	log_debug("%s: interface %s addr %s", __func__, iface->name,
	    inet_ntoa(*addr));

	mreq.imr_multiaddr = *addr;
	mreq.imr_interface.s_addr = if_get_ipv4_addr(iface);

	if (setsockopt(global.ipv4.ldp_disc_socket, IPPROTO_IP,
	    IP_ADD_MEMBERSHIP, (void *)&mreq, sizeof(mreq)) < 0) {
		log_warn("%s: error IP_ADD_MEMBERSHIP, interface %s address %s",
		     __func__, iface->name, inet_ntoa(*addr));
		return (-1);
	}
	return (0);
}

static int
if_leave_ipv4_group(struct iface *iface, struct in_addr *addr)
{
	struct ip_mreq		 mreq;

	log_debug("%s: interface %s addr %s", __func__, iface->name,
	    inet_ntoa(*addr));

	mreq.imr_multiaddr = *addr;
	mreq.imr_interface.s_addr = if_get_ipv4_addr(iface);

	if (setsockopt(global.ipv4.ldp_disc_socket, IPPROTO_IP,
	    IP_DROP_MEMBERSHIP, (void *)&mreq, sizeof(mreq)) < 0) {
		log_warn("%s: error IP_DROP_MEMBERSHIP, interface %s "
		    "address %s", __func__, iface->name, inet_ntoa(*addr));
		return (-1);
	}

	return (0);
}

static int
if_join_ipv6_group(struct iface *iface, struct in6_addr *addr)
{
	struct ipv6_mreq	 mreq;

	log_debug("%s: interface %s addr %s", __func__, iface->name,
	    log_in6addr(addr));

	mreq.ipv6mr_multiaddr = *addr;
	mreq.ipv6mr_interface = iface->ifindex;

	if (setsockopt(global.ipv6.ldp_disc_socket, IPPROTO_IPV6,
	    IPV6_JOIN_GROUP, &mreq, sizeof(mreq)) < 0) {
		log_warn("%s: error IPV6_JOIN_GROUP, interface %s address %s",
		    __func__, iface->name, log_in6addr(addr));
		return (-1);
	}

	return (0);
}

static int
if_leave_ipv6_group(struct iface *iface, struct in6_addr *addr)
{
	struct ipv6_mreq	 mreq;

	log_debug("%s: interface %s addr %s", __func__, iface->name,
	    log_in6addr(addr));

	mreq.ipv6mr_multiaddr = *addr;
	mreq.ipv6mr_interface = iface->ifindex;

	if (setsockopt(global.ipv6.ldp_disc_socket, IPPROTO_IPV6,
	    IPV6_LEAVE_GROUP, (void *)&mreq, sizeof(mreq)) < 0) {
		log_warn("%s: error IPV6_LEAVE_GROUP, interface %s address %s",
		    __func__, iface->name, log_in6addr(addr));
		return (-1);
	}

	return (0);
}
@


1.49
log
@Allow to run on a non-default rdomain.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.48 2016/09/03 16:07:08 renato Exp $ */
a85 12
struct iface *
if_lookup(struct ldpd_conf *xconf, unsigned short ifindex)
{
	struct iface *iface;

	LIST_FOREACH(iface, &xconf->iface_list, entry)
		if (iface->ifindex == ifindex)
			return (iface);

	return (NULL);
}

d102 12
@


1.48
log
@Rework the sending of address messages.

* Respect the session's negotiated maximum pdu length and split the
  sending of our local addresses into multiple messages if necessary;

* Log sent/received addresses;

* Add new wrappers to send only one address (send_address_single)
  and to send all addresses of the given address-family
  (send_address_all). These wrappers create a temporary list of addresses
  to be sent, and send_address() then acts on this last.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.47 2016/07/01 23:29:55 renato Exp $ */
d64 1
@


1.47
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.46 2016/06/18 17:31:32 renato Exp $ */
d178 1
a178 1
			send_address(nbr, if_addr->af, if_addr, 0);
d225 1
a225 1
			send_address(nbr, if_addr->af, if_addr, 1);
@


1.46
log
@Fix removal of dual-stack neighbors.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.45 2016/06/09 17:26:32 renato Exp $ */
d85 12
d98 1
a98 1
if_del(struct iface *iface)
a112 14

	free(iface);
}

struct iface *
if_lookup(struct ldpd_conf *xconf, unsigned short ifindex)
{
	struct iface *iface;

	LIST_FOREACH(iface, &xconf->iface_list, entry)
		if (iface->ifindex == ifindex)
			return (iface);

	return (NULL);
@


1.45
log
@Send a fatal notification when the last hello adjacency is deleted.

RFC 5036 says:
  "When the last Hello adjacency for an LDP session is
  deleted, the LSR terminates the LDP session by sending a Notification
  message and closing the transport connection".

Send a "Hold Timer Expired" notification when the triggering event is
a hello hold time timeout. In the other cases, like disabling LDP on an
interface, send a "Shutdown" notification instead.

Before this patch we were just closing the neighbor's transport
connection.

Fixes the following ANVL LDP tests: 7.17 and 23.3.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.44 2016/05/23 19:14:03 renato Exp $ */
d281 1
a281 1
		adj_del(adj, 1, S_SHUTDOWN);
@


1.44
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.43 2016/05/23 19:11:42 renato Exp $ */
d281 1
a281 1
		adj_del(adj);
@


1.43
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.42 2016/05/23 19:09:25 renato Exp $ */
d4 1
@


1.42
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.41 2016/05/23 18:58:48 renato Exp $ */
a20 1
#include <sys/ioctl.h>
a21 2
#include <sys/socket.h>
#include <netinet/in.h>
a22 6
#include <net/if.h>
#include <net/if_types.h>
#include <fcntl.h>
#include <ctype.h>
#include <err.h>
#include <stdio.h>
a23 1
#include <unistd.h>
a24 1
#include <event.h>
d27 1
a27 1
#include "ldp.h"
a28 1
#include "ldpe.h"
@


1.41
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.40 2016/05/23 18:41:59 renato Exp $ */
d42 12
a53 5
extern struct ldpd_conf        *leconf;

void		 if_hello_timer(int, short, void *);
void		 if_start_hello_timer(struct iface_af *);
void		 if_stop_hello_timer(struct iface_af *);
d141 1
a141 1
struct if_addr *
d157 1
a157 1
struct if_addr *
d245 1
a245 1
int
d279 1
a279 1
int
d311 1
a311 1
void
d390 1
a390 1
void
d399 1
a399 1
void
d410 1
a410 1
void
d463 1
a463 1
int
d483 1
a483 1
int
d504 1
a504 1
int
d525 1
a525 1
int
@


1.40
log
@Enable changing the router-id via config reload.

Now ldpd can start without a router-id, since it can be set later. Since
a router-id of 0.0.0.0 is invalid, interfaces and targeted-neighbors
will check for a valid router-id in order to be activated.

When the router-id is changed, all the neighborships are reset.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.39 2016/05/23 18:40:15 renato Exp $ */
d45 2
a46 2
void		 if_start_hello_timer(struct iface *);
void		 if_stop_hello_timer(struct iface *);
a55 5
	iface->state = IF_STA_DOWN;

	LIST_INIT(&iface->addr_list);
	LIST_INIT(&iface->adj_list);

d66 1
d72 14
d94 1
a94 2
	if (iface->state == IF_STA_ACTIVE)
		if_reset(iface);
d96 4
a99 1
	log_debug("%s: interface %s", __func__, iface->name);
d121 13
d142 1
d144 1
a144 1
	if_addr->mask = ka->mask;
d153 2
a154 1
	struct if_addr *if_addr;
d157 3
a159 3
		if (if_addr->addr.s_addr == ka->addr.s_addr &&
		    if_addr->mask.s_addr == ka->mask.s_addr &&
		    if_addr->dstbrd.s_addr == ka->dstbrd.s_addr)
d179 4
d184 1
a184 1
			send_address(nbr, if_addr, 0);
d189 9
a197 5
	if (iface &&
	    if_addr_lookup(&iface->addr_list, ka) == NULL) {
		if_addr = if_addr_new(ka);
		LIST_INSERT_HEAD(&iface->addr_list, if_addr, entry);
		if_update(iface);
d210 4
d217 1
a218 1
			if_update(iface);
d227 5
a231 1
			send_address(nbr, if_addr, 1);
d239 1
a239 1
if_start(struct iface *iface)
d241 1
a241 1
	struct in_addr		 addr;
d244 4
a247 1
	log_debug("%s: %s", __func__, iface->name);
d250 1
a250 1
	iface->uptime = now.tv_sec;
d252 12
a263 3
	inet_aton(AllRouters, &addr);
	if (if_join_group(iface, &addr))
		return (-1);
d265 1
a265 1
	send_hello(HELLO_LINK, iface, NULL);
d267 2
a268 2
	evtimer_set(&iface->hello_timer, if_hello_timer, iface);
	if_start_hello_timer(iface);
d273 1
a273 1
if_reset(struct iface *iface)
d275 1
a275 1
	struct in_addr		 addr;
d278 2
a279 1
	log_debug("%s: %s", __func__, iface->name);
d281 4
a284 1
	while ((adj = LIST_FIRST(&iface->adj_list)) != NULL)
a286 2
	if_stop_hello_timer(iface);

d288 11
a298 3
	if (global.ldp_disc_socket != -1) {
		inet_aton(AllRouters, &addr);
		if_leave_group(iface, &addr);
d304 2
a305 2
int
if_update(struct iface *iface)
d307 2
a308 2
	int			 link_ok, addr_ok = 0, socket_ok, rtr_id_ok;
	int			 ret;
d310 21
a330 2
	link_ok = (iface->flags & IFF_UP) &&
	    LINK_STATE_IS_UP(iface->linkstate);
d332 1
a332 3
	addr_ok = !LIST_EMPTY(&iface->addr_list);

	if (global.ldp_disc_socket != -1)
d342 10
a351 3
	if (iface->state == IF_STA_DOWN) {
		if (!link_ok || !addr_ok || !socket_ok || !rtr_id_ok)
			return (0);
d353 4
d358 4
a361 5
		iface->state = IF_STA_ACTIVE;
		ret = if_start(iface);
	} else {
		if (link_ok && addr_ok && socket_ok && rtr_id_ok)
			return (0);
d363 2
a364 3
		iface->state = IF_STA_DOWN;
		ret = if_reset(iface);
	}
d366 4
a369 1
	return (ret);
d373 1
a373 1
if_update_all(void)
d378 1
a378 1
		if_update(iface);
d386 1
a386 1
	struct iface		*iface = arg;
d388 2
a389 2
	send_hello(HELLO_LINK, iface, NULL);
	if_start_hello_timer(iface);
d393 1
a393 1
if_start_hello_timer(struct iface *iface)
d398 2
a399 2
	tv.tv_sec = iface->hello_interval;
	if (evtimer_add(&iface->hello_timer, &tv) == -1)
d404 1
a404 1
if_stop_hello_timer(struct iface *iface)
d406 2
a407 2
	if (evtimer_pending(&iface->hello_timer, NULL) &&
	    evtimer_del(&iface->hello_timer) == -1)
d412 1
a412 1
if_to_ctl(struct iface *iface)
d418 10
a427 9
	memcpy(ictl.name, iface->name, sizeof(ictl.name));
	ictl.ifindex = iface->ifindex;
	ictl.state = iface->state;
	ictl.hello_holdtime = iface->hello_holdtime;
	ictl.hello_interval = iface->hello_interval;
	ictl.flags = iface->flags;
	ictl.type = iface->type;
	ictl.linkstate = iface->linkstate;
	ictl.if_type = iface->if_type;
d430 3
a432 3
	if (iface->state != IF_STA_DOWN &&
	    iface->uptime != 0) {
		ictl.uptime = now.tv_sec - iface->uptime;
d437 1
a437 1
	LIST_FOREACH(adj, &iface->adj_list, iface_entry)
d443 13
a455 1
/* misc */
d457 1
a457 1
if_join_group(struct iface *iface, struct in_addr *addr)
a459 1
	struct if_addr		*if_addr;
a463 1
	if_addr = LIST_FIRST(&iface->addr_list);
d465 1
a465 1
	mreq.imr_interface = if_addr->addr;
d467 2
a468 2
	if (setsockopt(global.ldp_disc_socket, IPPROTO_IP, IP_ADD_MEMBERSHIP,
	    (void *)&mreq, sizeof(mreq)) < 0) {
d477 1
a477 1
if_leave_group(struct iface *iface, struct in_addr *addr)
a479 1
	struct if_addr		*if_addr;
a483 4
	if_addr = LIST_FIRST(&iface->addr_list);
	if (!if_addr)
		return (0);

d485 1
a485 1
	mreq.imr_interface = if_addr->addr;
d487 2
a488 2
	if (setsockopt(global.ldp_disc_socket, IPPROTO_IP, IP_DROP_MEMBERSHIP,
	    (void *)&mreq, sizeof(mreq)) < 0) {
d491 42
@


1.39
log
@Several fixes in the config reload handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.38 2016/05/23 18:33:56 renato Exp $ */
d242 1
a242 1
	int			 link_ok, addr_ok = 0, socket_ok;
d255 5
d261 1
a261 1
		if (!link_ok || !addr_ok || !socket_ok)
d268 1
a268 1
		if (link_ok && addr_ok && socket_ok)
@


1.38
log
@Create network sockets on the parent process.

We drop our privileges in ldpe right after we create the network sockets.
The problem is that we might want to change the transport-address and
reload the config, in which case we need new sockets. To allow that,
always create the network sockets in the parent process and pass them
to ldpe via imsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.37 2016/05/23 18:28:22 renato Exp $ */
d231 4
a234 2
	inet_aton(AllRouters, &addr);
	if_leave_group(iface, &addr);
@


1.37
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).

In addition, copy in_addr structs directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.36 2016/05/23 17:43:42 renato Exp $ */
a96 7
void
if_init(struct iface *iface)
{
	/* set event handlers for interface */
	evtimer_set(&iface->hello_timer, if_hello_timer, iface);
}

d211 2
d240 12
a251 1
	int ret;
d254 1
a254 3
		if (!(iface->flags & IFF_UP) ||
		    !LINK_STATE_IS_UP(iface->linkstate) ||
		    LIST_EMPTY(&iface->addr_list))
d257 1
d261 1
a261 3
		if ((iface->flags & IFF_UP) &&
		    LINK_STATE_IS_UP(iface->linkstate) &&
		    !LIST_EMPTY(&iface->addr_list))
d269 9
@


1.36
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d124 3
a126 3
	if_addr->addr.s_addr = ka->addr.s_addr;
	if_addr->mask.s_addr = ka->mask.s_addr;
	if_addr->dstbrd.s_addr = ka->dstbrd.s_addr;
d340 2
a341 2
	mreq.imr_multiaddr.s_addr = addr->s_addr;
	mreq.imr_interface.s_addr = if_addr->addr.s_addr;
d365 2
a366 2
	mreq.imr_multiaddr.s_addr = addr->s_addr;
	mreq.imr_interface.s_addr = if_addr->addr.s_addr;
@


1.35
log
@Move setsockopt helper functions to a separate file.

IPv6 support is coming and we don't want to pollute the interface.c file
with too many of these helper functions.

Also, rename these functions from if_set_* to sock_set_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.34 2016/05/23 16:31:27 renato Exp $ */
d98 1
a98 1
if_init(struct ldpd_conf *xconf, struct iface *iface)
a101 2

	iface->discovery_fd = xconf->ldp_discovery_socket;
d105 1
a105 1
if_lookup(struct ldpd_conf *xconf, u_short ifindex)
a330 129
if_set_mcast_ttl(int fd, u_int8_t ttl)
{
	if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,
	    (char *)&ttl, sizeof(ttl)) < 0) {
		log_warn("%s: error setting IP_MULTICAST_TTL to %d",
		    __func__, ttl);
		return (-1);
	}

	return (0);
}

int
if_set_tos(int fd, int tos)
{
	if (setsockopt(fd, IPPROTO_IP, IP_TOS, (int *)&tos, sizeof(tos)) < 0) {
		log_warn("%s: error setting IP_TOS to 0x%x", __func__, tos);
		return (-1);
	}

	return (0);
}

int
if_set_recvif(int fd, int enable)
{
	if (setsockopt(fd, IPPROTO_IP, IP_RECVIF, &enable,
	    sizeof(enable)) < 0) {
		log_warn("%s: error setting IP_RECVIF", __func__);
		return (-1);
	}
	return (0);
}

void
if_set_recvbuf(int fd)
{
	int	bsize;

	bsize = 65535;
	while (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &bsize,
	    sizeof(bsize)) == -1)
		bsize /= 2;
}

int
if_set_reuse(int fd, int enable)
{
	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &enable,
	    sizeof(int)) < 0) {
		log_warn("%s: error setting SO_REUSEADDR", __func__);
		return (-1);
	}

	return (0);
}

/*
 * only one JOIN or DROP per interface and address is allowed so we need
 * to keep track of what is added and removed.
 */
struct if_group_count {
	LIST_ENTRY(if_group_count)	entry;
	struct in_addr			addr;
	unsigned int			ifindex;
	int				count;
};

LIST_HEAD(,if_group_count) ifglist = LIST_HEAD_INITIALIZER(ifglist);

int
if_set_mcast_ttl(int fd, uint8_t ttl)
{
	if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,
	    (char *)&ttl, sizeof(ttl)) < 0) {
		log_warn("%s: error setting IP_MULTICAST_TTL to %d",
		    __func__, ttl);
		return (-1);
	}

	return (0);
}

int
if_set_tos(int fd, int tos)
{
	if (setsockopt(fd, IPPROTO_IP, IP_TOS, (int *)&tos, sizeof(tos)) < 0) {
		log_warn("%s: error setting IP_TOS to 0x%x", __func__, tos);
		return (-1);
	}

	return (0);
}

int
if_set_recvif(int fd, int enable)
{
	if (setsockopt(fd, IPPROTO_IP, IP_RECVIF, &enable,
	    sizeof(enable)) < 0) {
		log_warn("%s: error setting IP_RECVIF", __func__);
		return (-1);
	}
	return (0);
}

void
if_set_recvbuf(int fd)
{
	int	bsize;

	bsize = 65535;
	while (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &bsize,
	    sizeof(bsize)) == -1)
		bsize /= 2;
}

int
if_set_reuse(int fd, int enable)
{
	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &enable,
	    sizeof(int)) < 0) {
		log_warn("%s: error setting SO_REUSEADDR", __func__);
		return (-1);
	}

	return (0);
}

int
a333 1
	struct if_group_count	*ifg;
d336 2
a337 15
	LIST_FOREACH(ifg, &ifglist, entry)
		if (iface->ifindex == ifg->ifindex &&
		    addr->s_addr == ifg->addr.s_addr)
			break;
	if (ifg == NULL) {
		if ((ifg = calloc(1, sizeof(*ifg))) == NULL)
			fatal(__func__);
		ifg->addr.s_addr = addr->s_addr;
		ifg->ifindex = iface->ifindex;
		LIST_INSERT_HEAD(&ifglist, ifg, entry);
	}

	if (ifg->count++ != 0)
		/* already joined */
		return (0);
d343 4
a346 7
	if (setsockopt(iface->discovery_fd, IPPROTO_IP,
	    IP_ADD_MEMBERSHIP, (void *)&mreq, sizeof(mreq)) < 0) {
		log_warn("%s: error IP_ADD_MEMBERSHIP, "
		    "interface %s address %s", __func__, iface->name,
		    inet_ntoa(*addr));
		LIST_REMOVE(ifg, entry);
		free(ifg);
a355 1
	struct if_group_count	*ifg;
d358 2
a359 14
	LIST_FOREACH(ifg, &ifglist, entry)
		if (iface->ifindex == ifg->ifindex &&
		    addr->s_addr == ifg->addr.s_addr)
			break;

	/* if interface is not found just try to drop membership */
	if (ifg) {
		if (--ifg->count != 0)
			/* others still joined */
			return (0);

		LIST_REMOVE(ifg, entry);
		free(ifg);
	}
d368 2
a369 2
	if (setsockopt(iface->discovery_fd, IPPROTO_IP,
	    IP_DROP_MEMBERSHIP, (void *)&mreq, sizeof(mreq)) < 0) {
a371 62
		return (-1);
	}

	return (0);
}

int
if_set_mcast(struct iface *iface)
{
	struct if_addr		*if_addr;

	if_addr = LIST_FIRST(&iface->addr_list);

	if (setsockopt(global.ldp_disc_socket, IPPROTO_IP, IP_MULTICAST_IF,
	    &if_addr->addr.s_addr, sizeof(if_addr->addr.s_addr)) < 0) {
		log_debug("%s: error setting IP_MULTICAST_IF, interface %s",
		    __func__, iface->name);
		return (-1);
	}

	return (0);
}

int
if_set_mcast_loop(int fd)
{
	uint8_t	loop = 0;

	if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP,
	    (char *)&loop, sizeof(loop)) < 0) {
		log_warn("%s: error setting IP_MULTICAST_LOOP", __func__);
		return (-1);
	}

	return (0);
}

int
if_set_mcast(struct iface *iface)
{
	struct if_addr		*if_addr;

	if_addr = LIST_FIRST(&iface->addr_list);

	if (setsockopt(global.ldp_disc_socket, IPPROTO_IP, IP_MULTICAST_IF,
	    &if_addr->addr.s_addr, sizeof(if_addr->addr.s_addr)) < 0) {
		log_debug("%s: error setting IP_MULTICAST_IF, interface %s",
		    __func__, iface->name);
		return (-1);
	}

	return (0);
}

int
if_set_mcast_loop(int fd)
{
	u_int8_t	loop = 0;

	if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP,
	    (char *)&loop, sizeof(loop)) < 0) {
		log_warn("%s: error setting IP_MULTICAST_LOOP", __func__);
@


1.34
log
@Remove unnecessary mirroring of sockets.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.33 2016/05/23 16:27:16 renato Exp $ */
d404 58
d533 31
@


1.33
log
@Simplify removal of targeted neighbors and adjacencies.

Unlink these structures inside their own delete function rather than from
the outside.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.32 2016/05/23 16:20:59 renato Exp $ */
d488 1
a488 1
	if (setsockopt(iface->discovery_fd, IPPROTO_IP, IP_MULTICAST_IF,
@


1.32
log
@Standardize some log messages and fix some inconsistencies.

We were using several different names for the same thing in our log
messages: neighbor, neighbor ID, nbr ID and LSR ID.

Standardize to always use "lsr-id" to refer to a neighbor.

Also:
* Use log_warnx() instead of log_warn() when appropriate;
* Use fatal(x) instead of err(x) when appropriate;
* Fix some inconsistent log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.31 2016/05/23 16:14:36 renato Exp $ */
d232 1
a232 2
	while ((adj = LIST_FIRST(&iface->adj_list)) != NULL) {
		LIST_REMOVE(adj, iface_entry);
a233 1
	}
@


1.31
log
@More renaming.

Rename a few more things to improve readability.

* s/F_PW_CONTROLWORD_CONF/F_PW_CWORD_CONF/ (shorter)
* s/F_PW_CONTROLWORD/F_PW_CWORD/ (shorter)
* s/LDPD_FLAG_*/F_LDPD_*/ (consistency)
* s/lde_nbr_address/lde_addr/ (shorter)
* s/ldp_discovery_socket/ldp_disc_socket/ (shorter)
* s/ldp_ediscovery_socket/ldp_edisc_socket/ (shorter)
* s/ldp_sendboth/main_imsg_compose_both/ (consistency)
* s/cons/total/ (makes more sense)
* s/kaddr/ka/ (consistency with remaining code)
* Always use 'ln' for lde_nbrs (consistency)
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.30 2016/05/23 15:57:50 renato Exp $ */
d54 1
a54 1
		err(1, "if_new: calloc");
@


1.30
log
@Remove duplicated code in timer functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.29 2016/05/23 15:49:31 renato Exp $ */
d119 1
a119 1
if_addr_new(struct kaddr *kaddr)
d126 3
a128 3
	if_addr->addr.s_addr = kaddr->addr.s_addr;
	if_addr->mask.s_addr = kaddr->mask.s_addr;
	if_addr->dstbrd.s_addr = kaddr->dstbrd.s_addr;
d134 1
a134 1
if_addr_lookup(struct if_addr_head *addr_list, struct kaddr *kaddr)
d139 3
a141 3
		if (if_addr->addr.s_addr == kaddr->addr.s_addr &&
		    if_addr->mask.s_addr == kaddr->mask.s_addr &&
		    if_addr->dstbrd.s_addr == kaddr->dstbrd.s_addr)
@


1.29
log
@We don't need a separate function for sending address withdraws.

Address and Address Withdraw messages have the exact same format, only
their type is different.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.28 2016/05/23 15:47:24 renato Exp $ */
d219 1
a219 1
	/* hello timer needs to be started in any case */
d277 1
a277 2
	struct iface *iface = arg;
	struct timeval tv;
d280 1
a280 6

	/* reschedule hello_timer */
	timerclear(&tv);
	tv.tv_sec = iface->hello_interval;
	if (evtimer_add(&iface->hello_timer, &tv) == -1)
		fatal(__func__);
d286 1
a286 3
	struct timeval tv;

	send_hello(HELLO_LINK, iface, NULL);
@


1.28
log
@Move some code around.

This patch doesn't introduce any logical change.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.27 2016/05/23 15:14:07 renato Exp $ */
d162 1
a162 1
			send_address(nbr, if_addr);
d197 1
a197 1
			send_address_withdraw(nbr, if_addr);
@


1.27
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.26 2015/09/27 17:30:38 stsp Exp $ */
a146 2
/* timers */
/* ARGSUSED */
d148 1
a148 1
if_hello_timer(int fd, short event, void *arg)
d150 11
a160 2
	struct iface *iface = arg;
	struct timeval tv;
d162 3
a164 1
	send_hello(HELLO_LINK, iface, NULL);
d166 7
a172 5
	/* reschedule hello_timer */
	timerclear(&tv);
	tv.tv_sec = iface->hello_interval;
	if (evtimer_add(&iface->hello_timer, &tv) == -1)
		fatal(__func__);
d176 1
a176 1
if_start_hello_timer(struct iface *iface)
d178 3
a180 1
	struct timeval tv;
d182 9
a190 1
	send_hello(HELLO_LINK, iface, NULL);
d192 10
a201 12
	timerclear(&tv);
	tv.tv_sec = iface->hello_interval;
	if (evtimer_add(&iface->hello_timer, &tv) == -1)
		fatal(__func__);
}

void
if_stop_hello_timer(struct iface *iface)
{
	if (evtimer_pending(&iface->hello_timer, NULL) &&
	    evtimer_del(&iface->hello_timer) == -1)
		fatal(__func__);
d270 38
@


1.26
log
@As done for bgpd recently, rename if_mediatype to if_type in ldpd.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.25 2015/07/21 04:43:28 renato Exp $ */
d87 1
a87 1
	log_debug("if_del: interface %s", iface->name);
d124 1
a124 1
		fatal("if_addr_new");
d161 1
a161 1
		fatal("if_hello_timer");
d174 1
a174 1
		fatal("if_start_hello_timer");
d182 1
a182 1
		fatal("if_stop_hello_timer");
d191 1
a191 1
	log_debug("if_start: %s", iface->name);
d211 1
a211 1
	log_debug("if_reset: %s", iface->name);
d290 2
a291 2
		log_warn("if_set_mcast_ttl: error setting "
		    "IP_MULTICAST_TTL to %d", ttl);
d302 1
a302 1
		log_warn("if_set_tos: error setting IP_TOS to 0x%x", tos);
d314 1
a314 1
		log_warn("if_set_recvif: error setting IP_RECVIF");
d336 1
a336 1
		log_warn("if_set_reuse: error setting SO_REUSEADDR");
d369 1
a369 1
			fatal("if_join_group");
d385 2
a386 2
		log_warn("if_join_group: error IP_ADD_MEMBERSHIP, "
		    "interface %s address %s", iface->name,
d426 2
a427 3
		log_warn("if_leave_group: error IP_DROP_MEMBERSHIP, "
		    "interface %s address %s", iface->name,
		    inet_ntoa(*addr));
d443 2
a444 2
		log_debug("if_set_mcast: error setting "
		    "IP_MULTICAST_IF, interface %s", iface->name);
d458 1
a458 1
		log_warn("if_set_mcast_loop: error setting IP_MULTICAST_LOOP");
@


1.25
log
@Add configuration reload support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.24 2015/07/21 04:39:28 renato Exp $ */
d74 1
a74 1
	iface->media_type = kif->media_type;
d268 1
a268 1
	ictl.mediatype = iface->media_type;
@


1.24
log
@Improve handling of addresses on ldpe.

This is a preliminary work for the the next patch (sigup config
reload). We want to make sure that the ldpe process can handle duplicated
addresses.

The idea is to alloc two different if_addr structures for each address,
and link one in the global list of addresses (used to send address
messages) and link the other to the associated interface list of
addresses.

Doing that we will be able to call kif_redistribute() after reloading
the config file and activate the new LDP enabled interfaces.

NOTE: Interfaces are created at config parse time and the child
processes inherit them on fork() so there's no need to send a status
update at startup.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.23 2015/07/19 21:04:38 renato Exp $ */
d107 1
a107 1
if_lookup(u_short ifindex)
d111 1
a111 1
	LIST_FOREACH(iface, &leconf->iface_list, entry)
@


1.23
log
@Add missing LIST_INIT's.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.22 2015/03/21 18:32:01 renato Exp $ */
d89 4
a92 2
	while ((if_addr = LIST_FIRST(&iface->addr_list)) != NULL)
		LIST_REMOVE(if_addr, iface_entry);
d114 29
@


1.22
log
@Remove interface finite state machine.

In the name of simplicity, remove the interface FSM that was inherited
from ospfd. In ldpd interfaces are just up or down, so keeping a
FSM for that is an overkill. Now instead of calling if_fsm(), just
call if_update() whenever a relevant event occurs (status change,
address addition/removal).

Additional notes:
1 - s/if_act_/if_/

2 - Remove the IMSG_IFUP and IMSG_IFDOWN events. Now whenever an
interface changes its state a IMSG_IFSTATUS event will be generated
with the new status.

kroute.c ldpd.h ldpe.c ldpe.h CVS:
----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.21 2015/03/21 18:25:08 renato Exp $ */
d57 3
@


1.21
log
@ldpd: Remove attached adjacencies whenever an interface is disabled
for whatever reason.

If one interface is disabled, the holdtimer of the attached adjacencies
will eventually timeout after a few seconds. But there's no need
to wait when we know that the interface is disabled. In these cases,
remove the attached adjacencies to speedup the convergence process.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.20 2013/10/15 20:41:09 renato Exp $ */
a43 3
int		 if_act_start(struct iface *);
int		 if_act_reset(struct iface *);
int		 if_act_update(struct iface *);
a46 86
struct nbr	*if_elect(struct nbr *, struct nbr *);

struct {
	int			state;
	enum iface_event	event;
	enum iface_action	action;
	int			new_state;
} iface_fsm[] = {
    /* current state	event that happened	action to take	resulting state */
    {IF_STA_DOWN,	IF_EVT_DOWN,		IF_ACT_NOTHING,	0},
    {IF_STA_DOWN,	IF_EVT_UP,		IF_ACT_UPDATE,	0},
    {IF_STA_DOWN,	IF_EVT_NEWADDR,		IF_ACT_UPDATE,	0},
    {IF_STA_DOWN,	IF_EVT_DELADDR,		IF_ACT_NOTHING,	0},
    {IF_STA_ACTIVE,	IF_EVT_DOWN,		IF_ACT_RST,	IF_STA_DOWN},
    {IF_STA_ACTIVE,	IF_EVT_NEWADDR,		IF_ACT_NOTHING,	0},
    {IF_STA_ACTIVE,	IF_EVT_DELADDR,		IF_ACT_UPDATE,	0},
    {-1,		IF_EVT_NOTHING,		IF_ACT_NOTHING,	0},
};

const char * const if_event_names[] = {
	"NOTHING",
	"UP",
	"DOWN",
	"NEWADDR",
	"DELADDR"
};

const char * const if_action_names[] = {
	"NOTHING",
	"UPDATE",
	"RESET"
};

int
if_fsm(struct iface *iface, enum iface_event event)
{
	int	old_state;
	int	new_state = 0;
	int	i, ret = 0;

	old_state = iface->state;

	for (i = 0; iface_fsm[i].state != -1; i++)
		if ((iface_fsm[i].state & old_state) &&
		    (iface_fsm[i].event == event)) {
			new_state = iface_fsm[i].new_state;
			break;
		}

	if (iface_fsm[i].state == -1) {
		/* event outside of the defined fsm, ignore it. */
		log_debug("if_fsm: interface %s, "
		    "event %s not expected in state %s", iface->name,
		    if_event_names[event], if_state_name(old_state));
		return (0);
	}

	switch (iface_fsm[i].action) {
	case IF_ACT_UPDATE:
		ret = if_act_update(iface);
		break;
	case IF_ACT_RST:
		ret = if_act_reset(iface);
		break;
	case IF_ACT_NOTHING:
		/* do nothing */
		break;
	}

	if (ret) {
		log_debug("if_fsm: error changing state for interface %s, "
		    "event %s, state %s", iface->name, if_event_names[event],
		    if_state_name(old_state));
		return (-1);
	}

	if (new_state != 0)
		iface->state = new_state;

	log_debug("if_fsm: event %s resulted in action %s and changing "
	    "state for interface %s from %s to %s",
	    if_event_names[event], if_action_names[iface_fsm[i].action],
	    iface->name, if_state_name(old_state), if_state_name(iface->state));

	return (ret);
}
d82 1
a82 1
		if_act_reset(iface);
a150 1
/* actions */
d152 1
a152 1
if_act_start(struct iface *iface)
d157 2
d172 1
a172 1
if_act_reset(struct iface *iface)
d177 2
d194 1
a194 1
if_act_update(struct iface *iface)
d199 3
a201 5
		if (!((iface->flags & IFF_UP) &&
		    LINK_STATE_IS_UP(iface->linkstate)))
			return (0);

		if (LIST_EMPTY(&iface->addr_list))
d205 1
a205 1
		ret = if_act_start(iface);
d207 3
a209 1
		if (!LIST_EMPTY(&iface->addr_list))
d213 1
a213 1
		ret = if_act_reset(iface);
@


1.20
log
@Minor fixes on if_del() and nbr_new().

if_del(): this function is always called after an IF_EVT_DOWN event so
there's no need to cleanup things here;

nbr_new(): C structs shouldn't be copied directly.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.19 2013/06/04 02:39:10 claudio Exp $ */
a167 1
	struct adj		*adj;
d170 3
a174 4
	while ((adj = LIST_FIRST(&iface->adj_list)) != NULL) {
		LIST_REMOVE(adj, iface_entry);
		adj_del(adj);
	}
d263 6
@


1.19
log
@Speed-up the session establishment process
* Send an extra Hello message before attempting to connect to a remote
  peer to guarantee that it formed an adjacency with us as well;
* Don't wait for the first timeout to send the first Hello message.
Both tricks together will allow for fast session establish since with both
optimizations passive role neighbors can open the connection immediatly by
sending and receiving the hellos at the same time as the TCP session.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.18 2013/06/04 02:28:27 claudio Exp $ */
a171 2

	if_stop_hello_timer(iface);
@


1.18
log
@Cleanup ctl commands and remove unused variables inherited from ospfd
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.17 2013/06/04 02:25:28 claudio Exp $ */
d227 2
@


1.17
log
@Implement support for adjacencies and targeted hellos
Refactor adjacencies out of the neighbor handling so that it is possible to
have more complex topologies with targeted sessions.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.16 2013/06/04 00:41:18 claudio Exp $ */
d156 1
a156 2
	/* get mtu, index and flags */
	iface->mtu = kif->mtu;
a160 1
	iface->baudrate = kif->baudrate;
d305 2
a306 1
	struct timeval		 tv, now, res;
a308 1
	ictl.rtr_id.s_addr = ldpe_router_id();
d311 1
a311 3
	ictl.mtu = iface->mtu;
	ictl.baudrate = iface->baudrate;
	ictl.holdtime = iface->hello_holdtime;
a316 1
	ictl.priority = iface->priority;
a318 6
	if (evtimer_pending(&iface->hello_timer, &tv)) {
		timersub(&tv, &now, &res);
		ictl.hello_timer = res.tv_sec;
	} else
		ictl.hello_timer = -1;

d324 4
@


1.16
log
@fix some minor issues before proceeding with the remaining patches from
Renato Westphal. Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.15 2013/06/03 17:01:59 claudio Exp $ */
d170 1
d177 4
d216 1
a216 1
	send_hello(iface);
d315 1
a315 1
	ictl.holdtime = iface->holdtime;
@


1.15
log
@Remove the IMSG_NEIGHBOR_CHANGE message
Unlike OSPF, LDP has no concept of intermediate states. A session is
either operational or not operational as far as the label distribution
engine (lde) is concerned. In this case, the IMSG_NEIGHBOR_UP and
IMSG_NEIGHBOR_DOWN messages are enough.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.14 2013/06/03 16:53:49 claudio Exp $ */
a245 7
	if (!((iface->flags & IFF_UP) &&
	    LINK_STATE_IS_UP(iface->linkstate))) {
		log_debug("if_act_start: interface %s link down",
		    iface->name);
		return (0);
	}

a251 1
	iface->state = IF_STA_ACTIVE;
@


1.14
log
@Implement support for multiple addresses per interface.
This replaces the way addresses and interface are chained together.
In ospfd there was a 1 to 1 mapping (with iface clones) but LDP does
not have that limitation.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.13 2013/06/01 18:35:02 claudio Exp $ */
a145 2

	LIST_INIT(&iface->lde_nbr_list);
@


1.13
log
@Drop support for passive interfaces.
Support for passive interfaces was inherited from ospfd but it doesn't
make any sense at all for ldpd.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.12 2013/06/01 18:26:40 claudio Exp $ */
d42 5
d59 7
a65 2
    {IF_STA_DOWN,	IF_EVT_UP,		IF_ACT_STRT,	0},
    {IF_STA_ANY,	IF_EVT_DOWN,		IF_ACT_RST,	IF_STA_DOWN},
d72 3
a74 1
	"DOWN"
d79 1
a79 1
	"START",
d108 2
a109 2
	case IF_ACT_STRT:
		ret = if_act_start(iface);
d138 1
a138 1
if_new(struct kif *kif, struct kif_addr *ka)
a165 7
	/* set address, mask and p2p addr */
	iface->addr = ka->addr;
	iface->mask = ka->mask;
	if (kif->flags & IFF_POINTOPOINT) {
		iface->dst = ka->dstbrd;
	}

d172 2
d176 4
a179 2
	if (evtimer_pending(&iface->hello_timer, NULL))
		evtimer_del(&iface->hello_timer);
d193 12
d236 2
a237 1
	if (evtimer_del(&iface->hello_timer) == -1)
d275 1
d277 26
a302 3
	if (if_leave_group(iface, &addr)) {
		log_warnx("if_act_reset: error leaving group %s, "
		    "interface %s", inet_ntoa(addr), iface->name);
d304 2
a305 1
	return (0);
a314 2
	memcpy(&ictl.addr, &iface->addr, sizeof(ictl.addr));
	memcpy(&ictl.mask, &iface->mask, sizeof(ictl.mask));
d421 1
d439 1
d441 1
a441 1
	mreq.imr_interface.s_addr = iface->addr.s_addr;
d448 2
d460 1
d468 11
a478 2
	if (ifg && --ifg->count != 0)
		/* others still joined */
d482 1
a482 1
	mreq.imr_interface.s_addr = iface->addr.s_addr;
a491 4
	if (ifg) {
		LIST_REMOVE(ifg, entry);
		free(ifg);
	}
d498 4
d503 1
a503 1
	    &iface->addr.s_addr, sizeof(iface->addr.s_addr)) < 0) {
@


1.12
log
@Don't allow enabling LDP on loopback and carp interfaces.
LDP should be allowed only on physical or tunnel interfaces.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.11 2013/05/30 16:22:52 claudio Exp $ */
a281 1
	ictl.passive = iface->passive;
@


1.11
log
@Fix bug when starting ldpd with a configured interface in the down state.
If a given interface is down at startup, don't promote it to the ACTIVE
state.
Diff from Renato Westphal [renatowestphal at gmail.com]
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.10 2013/05/30 16:19:31 claudio Exp $ */
a54 1
    {IF_STA_LOOPBACK,	IF_EVT_DOWN,		IF_ACT_NOTHING,	IF_STA_DOWN},
a144 4
	if (kif->flags & IFF_LOOPBACK) {
		iface->type = IF_TYPE_POINTOPOINT;
		iface->state = IF_STA_LOOPBACK;
	}
a230 7
	}

	if (iface->media_type == IFT_CARP && iface->passive == 0) {
		/* force passive mode on carp interfaces */
		log_warnx("if_act_start: forcing interface %s to passive",
		    iface->name);
		iface->passive = 1;
@


1.10
log
@Stop trying to send hello messages if the interface is down.
Diff from Renato Westphal [renatowestphal at gmail.com]
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.9 2012/05/14 10:17:21 sthen Exp $ */
d54 1
a54 1
    {IF_STA_DOWN,	IF_EVT_UP,		IF_ACT_STRT,	IF_STA_ACTIVE},
d251 1
a251 1
	iface->state = IF_STA_DOWN;
@


1.9
log
@Don't display a nonsense uptime for an inactive interface. ldpd fix from
Rafael Zalamena on tech@@, I also applied it to ospfd.  ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.8 2011/07/04 04:34:14 claudio Exp $ */
d262 2
@


1.8
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.7 2011/01/10 12:28:25 claudio Exp $ */
d301 2
a302 1
	if (iface->state != IF_STA_DOWN) {
@


1.7
log
@Fix a bad heritage from ospfd. Make neighbors independent of interfaces.
They are not bound as strongly as in ospf and causes problems when the
TCP connection is established from an not connected IP (e.g. a loopback).
Use three RB trees to sort the neighbor list by id, addr and peerid.
More cleanup is needed but this makes ldpd work against peers using
loopback IPs. Problem found, reported and fix tested again by Marcel Wiget.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.6 2010/05/19 15:28:51 claudio Exp $ */
d232 1
a232 3
	    (LINK_STATE_IS_UP(iface->linkstate) ||
	    (iface->linkstate == LINK_STATE_UNKNOWN &&
	    iface->media_type != IFT_CARP)))) {
@


1.6
log
@Remove yet another ospf leftover that is not needed here. This time
neighbor self and all the madness surrounding this amazing concept.
LDP is not self aware so there is no need for this.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.5 2010/04/29 12:09:28 claudio Exp $ */
a135 1
	LIST_INIT(&iface->nbr_list);
a171 2
	struct nbr	*nbr = NULL;

a173 4
	/* clear lists etc */
	while ((nbr = LIST_FIRST(&iface->nbr_list)) != NULL)
		nbr_del(nbr);

a262 1
/*	struct nbr		*nbr = NULL; */
a269 8
/*
	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr_fsm(nbr, NBR_EVT_KILL_NBR)) {
			log_debug("if_act_reset: error killing neighbor %s",
			    inet_ntoa(nbr->id));
		}
	}
*/
a277 1
	struct nbr		*nbr;
a285 2
	ictl.nbr_cnt = 0;
	ictl.adj_cnt = 0;
a306 3

	LIST_FOREACH(nbr, &iface->nbr_list, entry)
		ictl.nbr_cnt++;
@


1.5
log
@Remove some more ospfd-ism from the interface code. This time remove
of most of the IF_TYPE_ special cases and most interface types.
Point-to-point and broadcast still present because of find_iface()
which needs addtional fixing.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.4 2010/04/15 15:39:32 claudio Exp $ */
a189 3
	/* init the dummy local neighbor */
	iface->self = nbr_new(ldpe_router_id(), iface->ifindex, iface, 1);

d327 1
a327 3
	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr == iface->self)
			continue;
a328 1
	}
@


1.4
log
@Cleanup the interface FSM by removing most of the ospfd specific states
that have nothing to do with LDP.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.3 2010/04/15 15:04:23 claudio Exp $ */
a59 2
static int vlink_cnt = 0;

a138 9
	if (kif == NULL) {
		iface->type = IF_TYPE_VIRTUALLINK;
		snprintf(iface->name, sizeof(iface->name), "vlink%d",
		    vlink_cnt++);
		iface->flags |= IFF_UP;
		iface->mtu = IP_MSS;
		return (iface);
	}

d260 2
a261 6
	switch (iface->type) {
	case IF_TYPE_VIRTUALLINK:
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_NBMA:
		log_debug("if_act_start: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
d263 1
a263 10
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		inet_aton(AllRouters, &addr);
		if (if_join_group(iface, &addr))
			return (-1);
		iface->state = IF_STA_DOWN;
		break;
	default:
		fatalx("if_act_start: unknown interface type");
	}
d276 4
a279 19
	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		inet_aton(AllRouters, &addr);
		if (if_leave_group(iface, &addr)) {
			log_warnx("if_act_reset: error leaving group %s, "
			    "interface %s", inet_ntoa(addr), iface->name);
		}
		break;
	case IF_TYPE_VIRTUALLINK:
		/* nothing */
		break;
	case IF_TYPE_NBMA:
	case IF_TYPE_POINTOMULTIPOINT:
		log_debug("if_act_reset: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
		return (-1);
	default:
		fatalx("if_act_reset: unknown interface type");
d417 18
a434 14
	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		LIST_FOREACH(ifg, &ifglist, entry)
			if (iface->ifindex == ifg->ifindex &&
			    addr->s_addr == ifg->addr.s_addr)
				break;
		if (ifg == NULL) {
			if ((ifg = calloc(1, sizeof(*ifg))) == NULL)
				fatal("if_join_group");
			ifg->addr.s_addr = addr->s_addr;
			ifg->ifindex = iface->ifindex;
			LIST_INSERT_HEAD(&ifglist, ifg, entry);
		}
d436 5
a440 20
		if (ifg->count++ != 0)
			/* already joined */
			return (0);

		mreq.imr_multiaddr.s_addr = addr->s_addr;
		mreq.imr_interface.s_addr = iface->addr.s_addr;

		if (setsockopt(iface->discovery_fd, IPPROTO_IP,
		    IP_ADD_MEMBERSHIP, (void *)&mreq, sizeof(mreq)) < 0) {
			log_warn("if_join_group: error IP_ADD_MEMBERSHIP, "
			    "interface %s address %s", iface->name,
			    inet_ntoa(*addr));
			return (-1);
		}
		break;
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_VIRTUALLINK:
	case IF_TYPE_NBMA:
		log_debug("if_join_group: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
a441 2
	default:
		fatalx("if_join_group: unknown interface type");
a442 1

d452 12
a463 23
	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		LIST_FOREACH(ifg, &ifglist, entry)
			if (iface->ifindex == ifg->ifindex &&
			    addr->s_addr == ifg->addr.s_addr)
				break;

		/* if interface is not found just try to drop membership */
		if (ifg && --ifg->count != 0)
			/* others still joined */
			return (0);

		mreq.imr_multiaddr.s_addr = addr->s_addr;
		mreq.imr_interface.s_addr = iface->addr.s_addr;

		if (setsockopt(iface->discovery_fd, IPPROTO_IP,
		    IP_DROP_MEMBERSHIP, (void *)&mreq, sizeof(mreq)) < 0) {
			log_warn("if_leave_group: error IP_DROP_MEMBERSHIP, "
			    "interface %s address %s", iface->name,
			    inet_ntoa(*addr));
			return (-1);
		}
d465 5
a469 10
		if (ifg) {
			LIST_REMOVE(ifg, entry);
			free(ifg);
		}
		break;
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_VIRTUALLINK:
	case IF_TYPE_NBMA:
		log_debug("if_leave_group: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
a470 2
	default:
		fatalx("if_leave_group: unknown interface type");
d473 4
d483 4
a486 15
	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		if (setsockopt(iface->discovery_fd, IPPROTO_IP, IP_MULTICAST_IF,
		    &iface->addr.s_addr, sizeof(iface->addr.s_addr)) < 0) {
			log_debug("if_set_mcast: error setting "
			    "IP_MULTICAST_IF, interface %s", iface->name);
			return (-1);
		}
		break;
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_VIRTUALLINK:
	case IF_TYPE_NBMA:
		log_debug("if_set_mcast: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
a487 2
	default:
		fatalx("if_set_mcast: unknown interface type");
@


1.3
log
@Instead of having three ways of setting fds non-blocking use
session_socket_blockmode() everywhere.
Additionally make two fatal() distinguishable.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.2 2010/02/18 10:50:14 claudio Exp $ */
d55 1
a271 6
	case IF_TYPE_POINTOPOINT:
		inet_aton(AllRouters, &addr);
		if (if_join_group(iface, &addr))
			return (-1);
		iface->state = IF_STA_POINTTOPOINT;
		break;
a272 2
		iface->state = IF_STA_POINTTOPOINT;
		break;
d278 1
@


1.2
log
@We need to set SO_REUSEADDR before doing the bind() of the tcp socket.
It does not help to set SO_REUSEPORT after doing the bind.
Fixes failures to start ldpd because of TIME_WAIT sessions.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
a441 12

int
if_set_nonblock(int fd)
{
	if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0) {
		log_warn("if_set_nonblock: error setting O_NONBLOCK");
		return (-1);
	}

	return (0);
}

@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d434 1
a434 1
	if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &enable,
d436 1
a436 1
		log_warn("if_set_reuse: error setting SO_REUSEPORT");
@

