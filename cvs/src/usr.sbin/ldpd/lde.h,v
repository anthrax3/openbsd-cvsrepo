head	1.50;
access;
symbols
	OPENBSD_6_2_BASE:1.50
	OPENBSD_6_1:1.50.0.4
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.43.0.2
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.18.0.10
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.8
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.6
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.50
date	2017.03.04.00.21.48;	author renato;	state Exp;
branches;
next	1.49;
commitid	luKtDak9oSLriyOU;

1.49
date	2017.03.04.00.15.35;	author renato;	state Exp;
branches;
next	1.48;
commitid	BOl8emh4A0ljUk3b;

1.48
date	2017.03.04.00.12.26;	author renato;	state Exp;
branches;
next	1.47;
commitid	bHPjS8k63pM8XVeR;

1.47
date	2017.03.04.00.09.17;	author renato;	state Exp;
branches;
next	1.46;
commitid	tAFME29r3wKSl8xr;

1.46
date	2017.03.04.00.03.04;	author renato;	state Exp;
branches;
next	1.45;
commitid	QsrgLdkTVf5ppNUE;

1.45
date	2017.03.03.23.41.27;	author renato;	state Exp;
branches;
next	1.44;
commitid	lvj5kMm2TzZDSXqr;

1.44
date	2016.09.02.17.10.34;	author renato;	state Exp;
branches;
next	1.43;
commitid	azy8IeWn9oiqxwik;

1.43
date	2016.07.01.23.36.38;	author renato;	state Exp;
branches;
next	1.42;
commitid	h9Qy21EPYXbAFnoh;

1.42
date	2016.07.01.23.33.46;	author renato;	state Exp;
branches;
next	1.41;
commitid	o5yBQ1cPVCcMZ7gA;

1.41
date	2016.06.18.17.13.05;	author renato;	state Exp;
branches;
next	1.40;
commitid	C9BDjZlAk1G5zEq3;

1.40
date	2016.06.18.01.25.53;	author renato;	state Exp;
branches;
next	1.39;
commitid	ru2TxJdOjUpe8t8d;

1.39
date	2016.05.23.19.16.00;	author renato;	state Exp;
branches;
next	1.38;
commitid	wKGrbgE7dtbu6ic6;

1.38
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.37;
commitid	TLlfi1Pk0Z97z8HM;

1.37
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.36;
commitid	AQBoOveMRKjtVfFv;

1.36
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.35;
commitid	t07H0Mk6WGdVWB0W;

1.35
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.34;
commitid	D7VvXbswyzx5Ahb2;

1.34
date	2016.05.23.18.46.13;	author renato;	state Exp;
branches;
next	1.33;
commitid	6J1vRySyD703dZ8m;

1.33
date	2016.05.23.18.36.55;	author renato;	state Exp;
branches;
next	1.32;
commitid	Ba6Sgjw90tNqVKLo;

1.32
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.31;
commitid	VpAym8dVR6eY4drQ;

1.31
date	2016.05.23.16.33.32;	author renato;	state Exp;
branches;
next	1.30;
commitid	mFupE64RyIWQWfMY;

1.30
date	2016.05.23.16.14.36;	author renato;	state Exp;
branches;
next	1.29;
commitid	hNzA87VdOHsaOms9;

1.29
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.28;
commitid	puLLDX1XPNc3GxB9;

1.28
date	2015.07.21.04.48.42;	author renato;	state Exp;
branches;
next	1.27;
commitid	AMGkBBNYB6bWMC2O;

1.27
date	2015.07.21.04.46.51;	author renato;	state Exp;
branches;
next	1.26;
commitid	vYpvRbGMQ79lkA2Y;

1.26
date	2015.07.19.20.54.16;	author renato;	state Exp;
branches;
next	1.25;
commitid	AcGJH529uphBS2D2;

1.25
date	2015.07.19.18.34.32;	author renato;	state Exp;
branches;
next	1.24;
commitid	KRfbPnwCvwQrLOu3;

1.24
date	2015.07.19.18.27.59;	author renato;	state Exp;
branches;
next	1.23;
commitid	9kOXzqr0NuJAc5FM;

1.23
date	2013.10.15.20.36.30;	author renato;	state Exp;
branches;
next	1.22;

1.22
date	2013.10.15.20.34.03;	author renato;	state Exp;
branches;
next	1.21;

1.21
date	2013.10.15.20.21.25;	author renato;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.03.17.01.59;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.01.18.47.07;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2010.11.04.09.49.07;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.26.12.08.14;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.21.08.24.06;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.30.22.15.02;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.30.05.21.38;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.23.16.26.47;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.23.15.42.07;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.02.11.56.29;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.25.13.29.45;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.25.09.31.25;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.19.15.28.51;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.05.11.15.02.36;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.19.12.49.21;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.28.09.48.46;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.08.18.59.29;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.19.17.10.09;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.22.34.45;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Send VPLS MAC withdrawals.

RFC 4762 says that MAC address withdrawal messages can be used to
improve convergence time in VPLS networks. This patch makes ldpd send
MAC withdrawals whenever a non-pseudowire interface pertaining to a
VPLS goes down. The processing of received MAC withdrawals will be
implemented later.
@
text
@/*	$OpenBSD: lde.h,v 1.49 2017/03/04 00:15:35 renato Exp $ */

/*
 * Copyright (c) 2013, 2016 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _LDE_H_
#define _LDE_H_

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>

enum fec_type {
	FEC_TYPE_IPV4,
	FEC_TYPE_IPV6,
	FEC_TYPE_PWID
};

struct fec {
	RB_ENTRY(fec)		entry;
	enum fec_type		type;
	union {
		struct {
			struct in_addr	prefix;
			uint8_t		prefixlen;
		} ipv4;
		struct {
			struct in6_addr	prefix;
			uint8_t		prefixlen;
		} ipv6;
		struct {
			uint16_t	type;
			uint32_t	pwid;
			struct in_addr	lsr_id;
		} pwid;
	} u;
};
RB_HEAD(fec_tree, fec);
RB_PROTOTYPE(fec_tree, fec, entry, fec_compare)

/* request entries */
struct lde_req {
	struct fec		 fec;
	uint32_t		 msg_id;
};

/* mapping entries */
struct lde_map {
	struct fec		 fec;
	LIST_ENTRY(lde_map)	 entry;
	struct lde_nbr		*nexthop;
	struct map		 map;
};

/* withdraw entries */
struct lde_wdraw {
	struct fec		 fec;
	uint32_t		 label;
};

/* Addresses belonging to neighbor */
struct lde_addr {
	TAILQ_ENTRY(lde_addr)	 entry;
	int			 af;
	union ldpd_addr		 addr;
};

/* just the info LDE needs */
struct lde_nbr {
	RB_ENTRY(lde_nbr)	 entry;
	uint32_t		 peerid;
	struct in_addr		 id;
	int			 v4_enabled;	/* announce/process v4 msgs */
	int			 v6_enabled;	/* announce/process v6 msgs */
	int			 flags;		/* capabilities */
	struct fec_tree		 recv_req;
	struct fec_tree		 sent_req;
	struct fec_tree		 recv_map;
	struct fec_tree		 sent_map;
	struct fec_tree		 sent_wdraw;
	TAILQ_HEAD(, lde_addr)	 addr_list;
};
RB_HEAD(nbr_tree, lde_nbr);
RB_PROTOTYPE(nbr_tree, lde_nbr, entry, lde_nbr_compare)

struct fec_nh {
	LIST_ENTRY(fec_nh)	 entry;
	int			 af;
	union ldpd_addr		 nexthop;
	uint32_t		 remote_label;
	uint8_t			 priority;
};

struct fec_node {
	struct fec		 fec;

	LIST_HEAD(, fec_nh)	 nexthops;	/* fib nexthops */
	LIST_HEAD(, lde_map)	 downstream;	/* recv mappings */
	LIST_HEAD(, lde_map)	 upstream;	/* sent mappings */

	uint32_t		 local_label;
	void			*data;		/* fec specific data */
};

#define LDE_GC_INTERVAL 300

extern struct ldpd_conf	*ldeconf;
extern struct fec_tree	 ft;
extern struct nbr_tree	 lde_nbrs;
extern struct event	 gc_timer;

/* lde.c */
void		 lde(int, int);
int		 lde_imsg_compose_ldpe(int, uint32_t, pid_t, void *, uint16_t);
uint32_t	 lde_assign_label(void);
void		 lde_send_change_klabel(struct fec_node *, struct fec_nh *);
void		 lde_send_delete_klabel(struct fec_node *, struct fec_nh *);
void		 lde_fec2map(struct fec *, struct map *);
void		 lde_map2fec(struct map *, struct in_addr, struct fec *);
void		 lde_send_labelmapping(struct lde_nbr *, struct fec_node *,
		    int);
void		 lde_send_labelwithdraw(struct lde_nbr *, struct fec_node *,
		    struct map *, struct status_tlv *);
void		 lde_send_labelwithdraw_wcard(struct lde_nbr *, uint32_t);
void		 lde_send_labelwithdraw_twcard_prefix(struct lde_nbr *,
		    uint16_t, uint32_t);
void		 lde_send_labelwithdraw_twcard_pwid(struct lde_nbr *, uint16_t,
		    uint32_t);
void		 lde_send_labelwithdraw_pwid_wcard(struct lde_nbr *, uint16_t,
		    uint32_t);
void		 lde_send_labelrelease(struct lde_nbr *, struct fec_node *,
		    struct map *, uint32_t);
void		 lde_send_notification(struct lde_nbr *, uint32_t, uint32_t,
		    uint16_t);
void		 lde_send_notification_eol_prefix(struct lde_nbr *, int);
void		 lde_send_notification_eol_pwid(struct lde_nbr *, uint16_t);
struct lde_nbr	*lde_nbr_find_by_lsrid(struct in_addr);
struct lde_nbr	*lde_nbr_find_by_addr(int, union ldpd_addr *);
struct lde_map	*lde_map_add(struct lde_nbr *, struct fec_node *, int);
void		 lde_map_del(struct lde_nbr *, struct lde_map *, int);
struct lde_req	*lde_req_add(struct lde_nbr *, struct fec *, int);
void		 lde_req_del(struct lde_nbr *, struct lde_req *, int);
struct lde_wdraw *lde_wdraw_add(struct lde_nbr *, struct fec_node *);
void		 lde_wdraw_del(struct lde_nbr *, struct lde_wdraw *);
void		 lde_change_egress_label(int, int);
struct lde_addr	*lde_address_find(struct lde_nbr *, int,
		    union ldpd_addr *);

/* lde_lib.c */
void		 fec_init(struct fec_tree *);
struct fec	*fec_find(struct fec_tree *, struct fec *);
int		 fec_insert(struct fec_tree *, struct fec *);
int		 fec_remove(struct fec_tree *, struct fec *);
void		 fec_clear(struct fec_tree *, void (*)(void *));
void		 rt_dump(pid_t);
void		 fec_snap(struct lde_nbr *);
void		 fec_tree_clear(void);
struct fec_nh	*fec_nh_find(struct fec_node *, int, union ldpd_addr *,
		    uint8_t);
uint32_t	 egress_label(enum fec_type);
void		 lde_kernel_insert(struct fec *, int, union ldpd_addr *,
		    uint8_t, int, void *);
void		 lde_kernel_remove(struct fec *, int, union ldpd_addr *,
		    uint8_t);
void		 lde_check_mapping(struct map *, struct lde_nbr *);
void		 lde_check_request(struct map *, struct lde_nbr *);
void		 lde_check_request_wcard(struct map *, struct lde_nbr *);
void		 lde_check_release(struct map *, struct lde_nbr *);
void		 lde_check_release_wcard(struct map *, struct lde_nbr *);
void		 lde_check_withdraw(struct map *, struct lde_nbr *);
void		 lde_check_withdraw_wcard(struct map *, struct lde_nbr *);
int		 lde_wildcard_apply(struct map *, struct fec *,
		    struct lde_map *);
void		 lde_gc_timer(int, short, void *);
void		 lde_gc_start_timer(void);
void		 lde_gc_stop_timer(void);

/* l2vpn.c */
struct l2vpn	*l2vpn_new(const char *);
struct l2vpn	*l2vpn_find(struct ldpd_conf *, const char *);
void		 l2vpn_del(struct l2vpn *);
void		 l2vpn_init(struct l2vpn *);
void		 l2vpn_exit(struct l2vpn *);
struct l2vpn_if	*l2vpn_if_new(struct l2vpn *, struct kif *);
struct l2vpn_if	*l2vpn_if_find(struct l2vpn *, unsigned int);
void		 l2vpn_if_update(struct l2vpn_if *);
struct l2vpn_pw	*l2vpn_pw_new(struct l2vpn *, struct kif *);
struct l2vpn_pw *l2vpn_pw_find(struct l2vpn *, unsigned int);
void		 l2vpn_pw_init(struct l2vpn_pw *);
void		 l2vpn_pw_exit(struct l2vpn_pw *);
void		 l2vpn_pw_reset(struct l2vpn_pw *);
int		 l2vpn_pw_ok(struct l2vpn_pw *, struct fec_nh *);
int		 l2vpn_pw_negotiate(struct lde_nbr *, struct fec_node *,
		    struct map *);
void		 l2vpn_send_pw_status(struct lde_nbr *, uint32_t, struct fec *);
void		 l2vpn_send_pw_status_wcard(struct lde_nbr *, uint32_t,
		    uint16_t, uint32_t);
void		 l2vpn_recv_pw_status(struct lde_nbr *, struct notify_msg *);
void		 l2vpn_recv_pw_status_wcard(struct lde_nbr *,
		    struct notify_msg *);
void		 l2vpn_sync_pws(int, union ldpd_addr *);
void		 l2vpn_pw_ctl(pid_t);
void		 l2vpn_binding_ctl(pid_t);

#endif	/* _LDE_H_ */
@


1.49
log
@Implement RFC 5919 (LDP End-of-LIB).
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.48 2017/03/04 00:12:26 renato Exp $ */
d201 1
@


1.48
log
@Implement RFC 6667 (Typed Wildcard FEC for PWid).
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.47 2017/03/04 00:09:17 renato Exp $ */
d90 1
d150 2
@


1.47
log
@Implement RFC 5918 (Typed Wildcard FEC).
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.46 2017/03/04 00:03:04 renato Exp $ */
d141 2
@


1.46
log
@Implement support for PWid group wildcards.

This was missing from our original RFC 4447 VPLS implementation. Now
ldpd understands group wildcards as mandated by the RFC, but we still
don't send them ourselves. I can't see any case in which sending a group
wildcard would be useful, but nonetheless this patch provides a function
called lde_send_labelwithdraw_pwid_wcard() which is ready to be used in
the future anytime we feel like it might be useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.45 2017/03/03 23:41:27 renato Exp $ */
d139 2
d177 1
@


1.45
log
@Minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.44 2016/09/02 17:10:34 renato Exp $ */
d137 4
a140 2
		    uint32_t, struct status_tlv *);
void		 lde_send_labelwithdraw_all(struct fec_node *, uint32_t);
d142 1
a142 1
		    uint32_t);
d179 2
d201 3
a203 1
void		 l2vpn_send_pw_status(uint32_t, uint32_t, struct fec *);
d205 2
@


1.44
log
@lde() and ldpe() should return void.

Remove these leftovers from the pre-fork+exec era.

Spotted by and ok rzalamena@@ ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.43 2016/07/01 23:36:38 renato Exp $ */
d141 2
a142 1
void		 lde_send_notification(uint32_t, uint32_t, uint32_t, uint16_t);
@


1.43
log
@More renaming and whitespace cleanup.

No binary change after "strip -s".
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.42 2016/07/01 23:33:46 renato Exp $ */
d127 1
a127 1
pid_t		 lde(int, int);
@


1.42
log
@Be more compliant with RFC 4447.

When sending a label withdraw during the pseudowire Control Word
negotiation, append a "Wrong C-bit" status TLV after the FEC TLV (in
conformance to RFC 4447 section 6.2). Apparently this has no use other
than aiding in troubleshooting.

Also, extend the recv_labelmessage() function to accept Status TLVs and
ignore them instead of shutting down the session.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.41 2016/06/18 17:13:05 renato Exp $ */
d58 2
a59 2
	struct fec		fec;
	uint32_t		msgid;
@


1.41
log
@Fix memory leak found with valgrind.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.40 2016/06/18 01:25:53 renato Exp $ */
d137 1
a137 1
		    uint32_t);
@


1.40
log
@Fix small LIB<->LFIB synchronization issue.

ldpd operates only with the best routes of each IP prefix. In other words,
the routes with the lowest priorities.

When a route with a better priority is detected (possibly with a different
nexthop), we should uninstall the labels from the "old" routes and try
to install a new label for the new route (if there's one available in
the LIB).

In this specific case, ldpd was failing to uninstall the labels from the
old routes because it wasn't keeping track of each route's priority in
lde. With this missing bit of information, the parent process had no way
to get the correct label to uninstall when processing a IMSG_KLABEL_DELETE
message.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.39 2016/05/23 19:16:00 renato Exp $ */
d185 1
@


1.39
log
@Improve security by calling exec after fork.

For each child process (lde and ldpe), re-exec ldpd with a special
"per-role" getopt flag. This way we have seperate ASLR/cookies per
process.

Based on a similar patch for bgpd, from claudio@@

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.38 2016/05/23 19:14:03 renato Exp $ */
d105 1
d163 2
a164 1
struct fec_nh	*fec_nh_find(struct fec_node *, int, union ldpd_addr *);
d166 4
a169 2
void		 lde_kernel_insert(struct fec *, int, union ldpd_addr *, int, void *);
void		 lde_kernel_remove(struct fec *, int, union ldpd_addr *);
@


1.38
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.37 2016/05/23 19:11:42 renato Exp $ */
d126 1
a126 1
pid_t		 lde(struct ldpd_conf *, int [2], int [2], int [2]);
@


1.37
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.36 2016/05/23 19:09:25 renato Exp $ */
d4 2
@


1.36
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.35 2016/05/23 18:58:48 renato Exp $ */
d23 1
a23 1
#include <sys/time.h>
a24 3
#include <sys/queue.h>
#include <event.h>
#include <limits.h>
@


1.35
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.34 2016/05/23 18:46:13 renato Exp $ */
a28 2
RB_HEAD(fec_tree, fec);

d54 1
a55 1
extern struct fec_tree ft;
d98 2
d119 7
d127 15
a141 14
pid_t		lde(struct ldpd_conf *, int [2], int [2], int [2]);
int		lde_imsg_compose_parent(int, pid_t, void *, uint16_t);
int		lde_imsg_compose_ldpe(int, uint32_t, pid_t, void *, uint16_t);
uint32_t	lde_assign_label(void);
void		lde_fec2map(struct fec *, struct map *);
void		lde_map2fec(struct map *, struct in_addr, struct fec *);

void	lde_send_change_klabel(struct fec_node *, struct fec_nh *);
void	lde_send_delete_klabel(struct fec_node *, struct fec_nh *);
void	lde_send_labelmapping(struct lde_nbr *, struct fec_node *, int);
void	lde_send_labelwithdraw(struct lde_nbr *, struct fec_node *, uint32_t);
void	lde_send_labelwithdraw_all(struct fec_node *, uint32_t);
void	lde_send_labelrelease(struct lde_nbr *, struct fec_node *, uint32_t);
void	lde_send_notification(uint32_t, uint32_t, uint32_t, uint16_t);
d144 4
a147 4
struct lde_map *lde_map_add(struct lde_nbr *, struct fec_node *, int);
void		lde_map_del(struct lde_nbr *, struct lde_map *, int);
struct lde_req *lde_req_add(struct lde_nbr *, struct fec *, int);
void		lde_req_del(struct lde_nbr *, struct lde_req *, int);
d149 4
a152 7
void		  lde_wdraw_del(struct lde_nbr *, struct lde_wdraw *);
void		lde_change_egress_label(int, int);

int			 lde_address_add(struct lde_nbr *, struct lde_addr *);
struct lde_addr		*lde_address_find(struct lde_nbr *, int,
			    union ldpd_addr *);
int			 lde_address_del(struct lde_nbr *, struct lde_addr *);
d156 1
a158 1
struct fec	*fec_find(struct fec_tree *, struct fec *);
a159 1

a162 1

a172 1
void		 lde_label_list_free(struct lde_nbr *);
a176 3
#define LDE_GC_INTERVAL 300
extern struct event gc_timer;

a187 1
void		 l2vpn_pw_fec(struct l2vpn_pw *, struct fec *);
@


1.34
log
@Introduce a garbage collector for dead entries in the LIB.

If we lose a route and all of its associated labels, then there's no
point on keeping an entry for it in the LIB.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.33 2016/05/23 18:36:55 renato Exp $ */
d33 1
d46 4
d82 2
a83 1
	struct in_addr		 addr;
d88 11
a98 11
	RB_ENTRY(lde_nbr)		 entry;
	struct in_addr			 id;

	struct fec_tree			 recv_req;
	struct fec_tree			 sent_req;
	struct fec_tree			 recv_map;
	struct fec_tree			 sent_map;
	struct fec_tree			 sent_wdraw;
	TAILQ_HEAD(, lde_addr)		 addr_list;

	uint32_t			 peerid;
d103 2
a104 1
	struct in_addr		 nexthop;
d135 1
a135 1
struct lde_nbr	*lde_nbr_find_by_addr(struct in_addr);
d142 1
a142 1
void		lde_change_egress_label(int);
d144 4
a147 3
int			 lde_address_add(struct lde_nbr *, struct in_addr *);
struct lde_addr		*lde_address_find(struct lde_nbr *, struct in_addr *);
int			 lde_address_del(struct lde_nbr *, struct in_addr *);
d160 1
a160 1
struct fec_nh	*fec_nh_find(struct fec_node *, struct in_addr);
d162 2
a163 2
void		 lde_kernel_insert(struct fec *, struct in_addr, int, void *);
void		 lde_kernel_remove(struct fec *, struct in_addr);
d196 1
a196 1
void		 l2vpn_sync_pws(struct in_addr);
@


1.33
log
@Don't create l2vpn targeted neighbors inside the config parser.

When removing a configured pseudowire, we remove the associated tnbr
in ldpe_l2vpn_pw_exit(). So, when a new pseudowire is configured, it
makes sense to create its tnbr in ldpe_l2vpn_pw_init() to keep things
consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.32 2016/05/23 17:43:42 renato Exp $ */
d163 6
@


1.32
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a172 1
void		 l2vpn_pw_del(struct l2vpn_pw *);
d174 1
@


1.31
log
@Minor adjustments in l2vpn code.

* Define a new constant for the default pseudowire type;
* On l2vpn_new(), initialize the l2vpn lists with LIST_NEW (cosmetic
  because the struct was calloc'ed);
* Add a const qualifier to the second parameter of l2vpn_find();
* Remove l2vpn_if_del() and use just free() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.30 2016/05/23 16:14:36 renato Exp $ */
d42 1
a42 1
			u_int8_t	prefixlen;
d45 3
a47 3
			u_int16_t	type;
			u_int32_t	pwid;
			struct in_addr	nexthop;
d57 1
a57 1
	u_int32_t		msgid;
d71 1
a71 1
	u_int32_t		 label;
d92 1
a92 1
	u_int32_t			 peerid;
d96 3
a98 5
	LIST_ENTRY(fec_nh)	entry;

	struct in_addr		nexthop;
	u_int32_t		remote_label;
	void			*data;		/* fec specific data */
d102 1
a102 1
	struct fec		fec;
d104 3
a106 3
	LIST_HEAD(, fec_nh)	nexthops;	/* fib nexthops */
	LIST_HEAD(, lde_map)	downstream;	/* recv mappings */
	LIST_HEAD(, lde_map)	upstream;	/* sent mappings */
d108 2
a109 1
	u_int32_t		local_label;
d114 3
a116 3
int		lde_imsg_compose_parent(int, pid_t, void *, u_int16_t);
int		lde_imsg_compose_ldpe(int, u_int32_t, pid_t, void *, u_int16_t);
u_int32_t	lde_assign_label(void);
d123 6
a128 4
void	lde_send_labelwithdraw(struct lde_nbr *, struct fec_node *);
void	lde_send_labelrelease(struct lde_nbr *, struct fec_node *, u_int32_t);
void	lde_send_notification(u_int32_t, u_int32_t, u_int32_t, u_int32_t);

d135 1
a135 1
struct lde_nbr *lde_find_address(struct in_addr);
d153 1
d179 2
a180 2
    struct map *);
void		 l2vpn_send_pw_status(u_int32_t, u_int32_t, struct fec *);
@


1.30
log
@More renaming.

Rename a few more things to improve readability.

* s/F_PW_CONTROLWORD_CONF/F_PW_CWORD_CONF/ (shorter)
* s/F_PW_CONTROLWORD/F_PW_CWORD/ (shorter)
* s/LDPD_FLAG_*/F_LDPD_*/ (consistency)
* s/lde_nbr_address/lde_addr/ (shorter)
* s/ldp_discovery_socket/ldp_disc_socket/ (shorter)
* s/ldp_ediscovery_socket/ldp_edisc_socket/ (shorter)
* s/ldp_sendboth/main_imsg_compose_both/ (consistency)
* s/cons/total/ (makes more sense)
* s/kaddr/ka/ (consistency with remaining code)
* Always use 'ln' for lde_nbrs (consistency)
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.29 2015/07/21 04:52:29 renato Exp $ */
d164 1
a164 1
struct l2vpn	*l2vpn_find(struct ldpd_conf *, char *);
a168 1
void		 l2vpn_if_del(struct l2vpn_if *l);
@


1.29
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.28 2015/07/21 04:48:42 renato Exp $ */
d75 3
a77 3
struct lde_nbr_address {
	TAILQ_ENTRY(lde_nbr_address)	entry;
	struct in_addr			addr;
d90 1
a90 1
	TAILQ_HEAD(, lde_nbr_address)	 addr_list;
d137 1
a137 1
struct lde_nbr_address	*lde_address_find(struct lde_nbr *, struct in_addr *);
@


1.28
log
@Record all fields of the received label mappings.

Since we implement the Liberal Label Retention mode, we need to record
all fields of the received label mappings so the messages can be processed
later when there is a matching nexthop for the advertised FECs.

This will be important when we implement VPLS because we need to retain
information like the pseudowire's interface MTU and Group ID.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.27 2015/07/21 04:46:51 renato Exp $ */
d31 5
d38 12
a49 2
	struct in_addr		prefix;
	u_int8_t		prefixlen;
d100 1
a110 1
	u_int8_t		flags;
d118 2
d123 1
a123 1
void	lde_send_labelmapping(struct lde_nbr *, struct fec_node *);
a143 1
struct fec	*fec_find_prefix(struct fec_tree *, in_addr_t, u_int8_t);
d151 3
a153 2
void		 lde_kernel_insert(struct kroute *);
void		 lde_kernel_remove(struct kroute *);
d161 23
@


1.27
log
@Rename structures and functions to be more generic.

LDP work with FECs, where a FEC can be a prefix, a pseudowire and so on.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.26 2015/07/19 20:54:16 renato Exp $ */
d50 1
a50 1
	u_int32_t		 label;
@


1.26
log
@Rework label mapping algorithms to be more in line with the RFC.

This patch presents a thoroughly review of the label mapping
algorithms. Most of the changes are minor bug fixes in the handling of
received label messages.

Additional improvements:
* Add a few more references to the Appendix A of the RFC5036 ("LDP
  Label Distribution Procedures") into the code;
* Add full multipath support;
* Send label withdraws when appropriate;
* Add label withdraw/release wildcard support.

NOTE: As a result of implementing only the "Liberal Label Retention" and
"Downstream Unsolicited" modes, we will never send a label request
("Request  Never"). And that means that we can ignore the following
notification messages: "Label Request Aborted", "No Label Resources",
"No Route" and "Label Resources Available". The following algorithms
mentioned in the RFC can also be ignored: "Timeout of Deferred Label
Request", "Detect Local Label Resources Have Become Available" and
"Receive Label Abort Request".

Now, considering that we only support one combination of all modes of
operation, we can say that we have an almost complete implementation of
the protocol.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.25 2015/07/19 18:34:32 renato Exp $ */
d37 1
a37 1
extern struct fec_tree rt;
d80 2
a81 2
struct rt_lsp {
	LIST_ENTRY(rt_lsp)	entry;
d87 1
a87 1
struct rt_node {
d90 1
a90 1
	LIST_HEAD(, rt_lsp)	lsp;		/* label switching pathes */
d104 5
a108 5
void	lde_send_change_klabel(struct rt_node *, struct rt_lsp *);
void	lde_send_delete_klabel(struct rt_node *, struct rt_lsp *);
void	lde_send_labelmapping(struct lde_nbr *, struct rt_node *);
void	lde_send_labelwithdraw(struct lde_nbr *, struct rt_node *);
void	lde_send_labelrelease(struct lde_nbr *, struct rt_node *, u_int32_t);
d111 1
a111 1
struct lde_map *lde_map_add(struct lde_nbr *, struct rt_node *, int);
d115 1
a115 1
struct lde_wdraw *lde_wdraw_add(struct lde_nbr *, struct rt_node *);
d132 2
a133 2
void		 rt_snap(struct lde_nbr *);
void		 rt_clear(void);
@


1.25
log
@Uninstall associated label bindings when a neighbor is down.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.24 2015/07/19 18:27:59 renato Exp $ */
d39 1
a39 5
/*
 * fec tree of pending label request
 * Note: currently only one outstanding request per FEC can be tracked but
 *       should not be a problem since ldpd does not support multipath for now.
 */
d53 6
d107 1
a107 1
void	lde_send_labelrequest(struct lde_nbr *, struct rt_node *);
a110 1
void		lde_nbr_do_mappings(struct rt_node *);
d115 2
d140 1
d142 1
@


1.24
log
@Rework kroute.c to send only the best routes to lde.

This is major rework of the kroute.c code. The idea is remove complexity
from the lde process by making kroute.c advertise only the lowest priority
routes of each prefix.

kroute.c now keeps track of all routes using three different structures:
kroute_prefix, kroute_priority and kroute_node.

kroute_prefix represents a prefix and contains an ordered list of
priorities (kroute_priority) and for each priority there is a list of
nexthops (kroute_node). Arranging the routes using these three structures
allows for the writing of a simpler code, easier to understand.

Whenever a route is removed, if there's another route for the same prefix,
but with a lower priority, this route is immediately sent to lde.

Additional fixes:
* On RTM_CHANGE, remove the old route before installing the new one;
* On IMSG_CTL_KROUTE_ADDR, show all nexthops for multpath routes;
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.23 2013/10/15 20:36:30 renato Exp $ */
d36 2
@


1.23
log
@Simplify the lde_nbr_new() function.

There's no need the pass a whole lde_nbr structure as argument if we
want only the neighbor IP address.

Also, remove the lde_nbr_del() prototype on lde.h because it's a
duplicate.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.22 2013/10/15 20:34:03 renato Exp $ */
a80 1
	u_int8_t		priority;
@


1.22
log
@Simplify the code by avoiding direct calls to imsg_compose_event().
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.21 2013/10/15 20:21:25 renato Exp $ */
a107 1
void		lde_nbr_del(struct lde_nbr *);
@


1.21
log
@Fix whitespace and other style issues.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.20 2013/06/03 17:01:59 claudio Exp $ */
d97 1
@


1.20
log
@Remove the IMSG_NEIGHBOR_CHANGE message
Unlike OSPF, LDP has no concept of intermediate states. A session is
either operational or not operational as far as the label distribution
engine (lde) is concerned. In this case, the IMSG_NEIGHBOR_UP and
IMSG_NEIGHBOR_DOWN messages are enough.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.19 2013/06/01 18:47:07 claudio Exp $ */
d44 1
a44 1
	u_int32_t		msgid;	
a113 1

@


1.19
log
@Drop support for per-interface labelspaces.
Support for per-interface labelspaces is only necessary for legacy ATM/FR
interfaces running in cell-mode. We shouldn't worry about this.
For platform-wide label spaces the label space id is always 0.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.18 2010/11/04 09:49:07 claudio Exp $ */
a73 2
	unsigned int			 ifindex;
	int				 state;
@


1.18
log
@Only consider pathes with highest priority when replying to label
requests. Else a priority inversion may happen that would build
label switching pathes that use inactive routes.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.17 2010/10/26 12:08:14 claudio Exp $ */
a75 2

	u_int16_t			 lspace;
a93 1
	u_int16_t		lspace;
@


1.17
log
@Change lde_check_request(), lde_check_mapping(), lde_send_labelmapping(),
lde_send_labelrequest(), and lde_nbr_do_mappings() to follow the
algorithms defined in Appendix A of RFC 5036. Added comments and
markers for better understanding and to find missing bits.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.16 2010/10/21 08:24:06 claudio Exp $ */
d85 1
@


1.16
log
@Start implementing the missing lablemapping messages in the LDE and
fix the existing ones to correctly track outstanding request and
sent / recv mappings.
Looks good to michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.15 2010/06/30 22:15:02 claudio Exp $ */
d103 7
a109 7
void		lde_send_change_klabel(struct rt_node *, struct rt_lsp *);
void		lde_send_delete_klabel(struct rt_node *, struct rt_lsp *);
void		lde_send_labelmapping(u_int32_t, struct map *);
void		lde_send_labelrequest(u_int32_t, struct map *);
void		lde_send_labelrelease(u_int32_t, struct map *);
void		lde_send_notification(u_int32_t, u_int32_t, u_int32_t,
		   u_int32_t);
d115 2
@


1.15
log
@Make it possible to store multiple LSP to a FEC. This is another step to
handle multipath routes in MPLS.
Looks good to michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.14 2010/06/30 05:21:38 claudio Exp $ */
d114 1
d131 1
a131 1
void		 rt_snap(u_int32_t);
d139 1
@


1.14
log
@Kill IMSG_KLABEL_INSERT and all the related functions around it.
IMSG_KLABEL_CHANGE is smart enough to know when something is a change
or an insert.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.13 2010/06/23 16:26:47 claudio Exp $ */
d80 7
a88 1
	struct in_addr		nexthop;
d90 1
a94 1
	u_int32_t		remote_label;
a96 1
	u_int8_t		present;	/* Is it present in fib? */
d103 2
a104 2
void		lde_send_change_klabel(struct rt_node *);
void		lde_send_delete_klabel(struct rt_node *);
d113 1
@


1.13
log
@Fix comment.  Downstream is towards the destination of a LSP.
Therefor the list holds the recv mappings and not the sent mappings.
ldpd sends his mappings upstream.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.12 2010/06/23 15:42:07 claudio Exp $ */
a97 1
void		lde_send_insert_klabel(struct rt_node *);
@


1.12
log
@Kill rt_node->invalid it is not used by anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.11 2010/06/02 11:56:29 claudio Exp $ */
d84 2
a85 2
	LIST_HEAD(, lde_map)	upstream;	/* recv mappings */
	LIST_HEAD(, lde_map)	downstream;	/* sent mappings */
@


1.11
log
@Start reworking the LDE. Implement a FEC RB tree that can be used for the
route table and the per neighbor request and mapping lists.
The received and sent mappings are added to the per neighbor RB tree and
additionally linked to the route table. This makes lookups, etc. a lot
easier. While there flip the neighbor hash list over to a RB tree.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.10 2010/05/25 13:29:45 claudio Exp $ */
a90 1
	u_int8_t		invalid;
@


1.10
log
@Remove another leftover from ospfd. ldpd does not have a concept of ext_tag
and so there is no need to carry ext_tag and rtlabels around.
"Yes! kill kill kill" michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.9 2010/05/25 09:31:25 claudio Exp $ */
d29 6
a34 5
/* Label mapping request pending */
struct lde_req_entry {
	TAILQ_ENTRY(lde_req_entry)	entry;
	struct in_addr			prefix;
	u_int8_t			prefixlen;
d37 16
a52 6
/* Label mapping message sent */
struct lde_map_entry {
	TAILQ_ENTRY(lde_map_entry)	entry;
	struct in_addr			prefix;
	u_int32_t			label;
	u_int8_t			prefixlen;
d63 1
a63 1
	LIST_ENTRY(lde_nbr)		 hash, entry;
d66 5
a70 3
	TAILQ_HEAD(, lde_req_entry)	 req_list;
	TAILQ_HEAD(, lde_map_entry)	 recv_map_list;
	TAILQ_HEAD(, lde_map_entry)	 sent_map_list;
a71 1
	TAILQ_HEAD(, rt_label)		 labels_list;
a79 9
struct rt_node;

struct rt_label {
	TAILQ_ENTRY(rt_label)	 node_l, nbr_l;
	struct lde_nbr		*nexthop;
	struct rt_node		*node;
	u_int32_t		 label;
};

d81 1
a81 3
	RB_ENTRY(rt_node)	entry;
	TAILQ_HEAD(, rt_label)	labels_list;
	struct in_addr		prefix;
d84 3
a88 1

a90 1
	u_int8_t		prefixlen;
d98 1
a98 1
u_int32_t	lde_router_id(void);
d109 1
d118 7
a124 9
void		 rt_init(void);
int		 rt_compare(struct rt_node *, struct rt_node *);
int		 rt_insert(struct rt_node *);
int		 rt_remove(struct rt_node *);
struct rt_node	*rt_find(in_addr_t, u_int8_t);
void		 rt_clear(void);
void		 route_reset_timers(struct rt_node *);
int		 route_start_timeout(struct rt_node *);
void		 route_start_garbage(struct rt_node *);
d127 2
@


1.9
log
@Kill a bogus bzero() and introduce an empty lde_check_release().
That function will be needed soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.8 2010/05/19 15:28:51 claudio Exp $ */
a85 1
	u_int32_t		ext_tag;
@


1.8
log
@Remove yet another ospf leftover that is not needed here. This time
neighbor self and all the madness surrounding this amazing concept.
LDP is not self aware so there is no need for this.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.7 2010/05/11 15:02:36 claudio Exp $ */
d131 1
@


1.7
log
@sort struct by size and kill some unneeded spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.6 2010/02/19 12:49:21 claudio Exp $ */
a62 1
	int				 self;
@


1.6
log
@If a neighbor goes down we need to cleanup the LIB from all FEC that point
via that neighbor. Fixes a use after free and an additional NULL dereference
in a log_debug is fixed as well.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.5 2009/09/28 09:48:46 michele Exp $ */
d40 1
a41 1
	u_int32_t			label;
d96 11
a106 12
pid_t		 lde(struct ldpd_conf *, int [2], int [2], int [2]);
int		 lde_imsg_compose_ldpe(int, u_int32_t, pid_t, void *,
		     u_int16_t);
u_int32_t	 lde_router_id(void);
void		 lde_send_insert_klabel(struct rt_node *);
void		 lde_send_change_klabel(struct rt_node *);
void		 lde_send_delete_klabel(struct rt_node *);
void		 lde_send_labelmapping(u_int32_t, struct map *);
void		 lde_send_labelrequest(u_int32_t, struct map *);
void		 lde_send_labelrelease(u_int32_t, struct map *);
void		 lde_send_notification(u_int32_t, u_int32_t, u_int32_t,
		    u_int32_t);
d108 1
a108 1
void		 lde_nbr_del(struct lde_nbr *);
@


1.5
log
@When a route is deleted, ldpd should remove labels associated with it from
lfib (the kernel lib) but not from the lib. These could be used later on when
the route come back.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.4 2009/07/08 18:59:29 michele Exp $ */
d59 1
d69 2
d72 3
a74 1
	TAILQ_ENTRY(rt_label)	 entry;
a75 1
	struct lde_nbr		*nexthop;
d133 1
@


1.4
log
@Detect nexthop change.
React installing the label associated with the new nexthop
in the kernel routing table.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.3 2009/06/19 17:10:09 michele Exp $ */
d126 1
@


1.3
log
@When operating in liberal mode, retain labels even if they aren't learnt
from current nexthop.

ok laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.2 2009/06/05 22:34:45 michele Exp $ */
d125 1
a125 1
void		 lde_insert(struct kroute *);
@


1.2
log
@Correctly send notification messages when errors occur.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.h,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d88 1
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d101 2
a102 1
void		 lde_send_notification(u_int32_t, u_int32_t);
@

