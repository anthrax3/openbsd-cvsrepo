head	1.42;
access;
symbols
	OPENBSD_6_2_BASE:1.42
	OPENBSD_6_1:1.42.0.4
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.34.0.2
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.42
date	2017.03.04.00.21.48;	author renato;	state Exp;
branches;
next	1.41;
commitid	luKtDak9oSLriyOU;

1.41
date	2017.03.04.00.15.35;	author renato;	state Exp;
branches;
next	1.40;
commitid	BOl8emh4A0ljUk3b;

1.40
date	2017.03.04.00.12.26;	author renato;	state Exp;
branches;
next	1.39;
commitid	bHPjS8k63pM8XVeR;

1.39
date	2017.03.04.00.09.17;	author renato;	state Exp;
branches;
next	1.38;
commitid	tAFME29r3wKSl8xr;

1.38
date	2017.03.04.00.06.10;	author renato;	state Exp;
branches;
next	1.37;
commitid	GMDFIgs8eMuH7Rxe;

1.37
date	2017.03.03.23.56.54;	author renato;	state Exp;
branches;
next	1.36;
commitid	CJgAK1Io2ZIX3ZiK;

1.36
date	2017.03.03.23.41.27;	author renato;	state Exp;
branches;
next	1.35;
commitid	lvj5kMm2TzZDSXqr;

1.35
date	2016.09.03.16.07.08;	author renato;	state Exp;
branches;
next	1.34;
commitid	fYTaUp1tzXub9AKi;

1.34
date	2016.07.15.17.09.25;	author renato;	state Exp;
branches;
next	1.33;
commitid	VGEMIeHBWOrVJjkU;

1.33
date	2016.07.01.23.36.38;	author renato;	state Exp;
branches;
next	1.32;
commitid	h9Qy21EPYXbAFnoh;

1.32
date	2016.07.01.23.22.42;	author renato;	state Exp;
branches;
next	1.31;
commitid	KNtlNq8t1jai5pAy;

1.31
date	2016.07.01.23.18.24;	author renato;	state Exp;
branches;
next	1.30;
commitid	0lNPHoosw9NBNZNy;

1.30
date	2016.07.01.23.14.31;	author renato;	state Exp;
branches;
next	1.29;
commitid	DKNC9fIizmSRxKR1;

1.29
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.28;
commitid	TLlfi1Pk0Z97z8HM;

1.28
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.27;
commitid	AQBoOveMRKjtVfFv;

1.27
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.26;
commitid	D7VvXbswyzx5Ahb2;

1.26
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.25;
commitid	VpAym8dVR6eY4drQ;

1.25
date	2016.05.23.16.33.32;	author renato;	state Exp;
branches;
next	1.24;
commitid	mFupE64RyIWQWfMY;

1.24
date	2016.05.23.16.12.28;	author renato;	state Exp;
branches;
next	1.23;
commitid	vVUYnEJVjv7IWE6u;

1.23
date	2016.05.23.16.10.23;	author renato;	state Exp;
branches;
next	1.22;
commitid	dfHsmfmr62xnFBxd;

1.22
date	2016.05.23.16.04.04;	author renato;	state Exp;
branches;
next	1.21;
commitid	sfghEB6dR4Eaf77g;

1.21
date	2016.05.23.15.53.40;	author renato;	state Exp;
branches;
next	1.20;
commitid	1oKfyTeVVyhfWeTI;

1.20
date	2016.05.23.15.47.24;	author renato;	state Exp;
branches;
next	1.19;
commitid	Eng7dm0NElMq9Yi3;

1.19
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.18;
commitid	puLLDX1XPNc3GxB9;

1.18
date	2015.07.19.20.54.17;	author renato;	state Exp;
branches;
next	1.17;
commitid	AcGJH529uphBS2D2;

1.17
date	2015.03.21.18.34.01;	author renato;	state Exp;
branches;
next	1.16;
commitid	cFXa8ucj1hCSVYz6;

1.16
date	2013.10.17.17.52.21;	author renato;	state Exp;
branches;
next	1.15;

1.15
date	2013.10.15.19.59.53;	author renato;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.15.16.47.24;	author renato;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.04.02.25.28;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.04.01.32.16;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.01.01.34.57;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2013.05.30.16.14.50;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.10.11.58.39;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.10.11.52.04;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.04.09.52.16;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.26.12.59.03;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.17.08.07.04;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.15.14.55.12;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.25.17.40.46;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2009.12.09.12.19.29;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Send VPLS MAC withdrawals.

RFC 4762 says that MAC address withdrawal messages can be used to
improve convergence time in VPLS networks. This patch makes ldpd send
MAC withdrawals whenever a non-pseudowire interface pertaining to a
VPLS goes down. The processing of received MAC withdrawals will be
implemented later.
@
text
@/*	$OpenBSD: ldp.h,v 1.41 2017/03/04 00:15:35 renato Exp $ */

/*
 * Copyright (c) 2013, 2016 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 * Copyright (c) 2004, 2005, 2008 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* LDP protocol definitions */

#ifndef _LDP_H_
#define _LDP_H_

#include <sys/types.h>

/* misc */
#define LDP_VERSION		1
#define LDP_PORT		646
#define LDP_MAX_LEN		4096

/* All Routers on this Subnet group multicast addresses */
#define AllRouters_v4		"224.0.0.2"
#define AllRouters_v6		"ff02::2"

#define LINK_DFLT_HOLDTIME	15
#define TARGETED_DFLT_HOLDTIME	45
#define MIN_HOLDTIME		3
#define MAX_HOLDTIME		0xffff
#define	INFINITE_HOLDTIME	0xffff

#define DEFAULT_KEEPALIVE	180
#define MIN_KEEPALIVE		3
#define MAX_KEEPALIVE		0xffff
#define KEEPALIVE_PER_PERIOD	3
#define INIT_FSM_TIMEOUT	15

#define	DEFAULT_HELLO_INTERVAL	5
#define	MIN_HELLO_INTERVAL	1
#define	MAX_HELLO_INTERVAL	0xffff

#define	INIT_DELAY_TMR		15
#define	MAX_DELAY_TMR		120

#define	MIN_PWID_ID		1
#define	MAX_PWID_ID		0xffffffff

#define	DEFAULT_L2VPN_MTU	1500
#define	MIN_L2VPN_MTU		512
#define	MAX_L2VPN_MTU		0xffff

/* LDP message types */
#define MSG_TYPE_NOTIFICATION	0x0001
#define MSG_TYPE_HELLO		0x0100
#define MSG_TYPE_INIT		0x0200
#define MSG_TYPE_KEEPALIVE	0x0201
#define MSG_TYPE_CAPABILITY	0x0202 /* RFC 5561 */
#define MSG_TYPE_ADDR		0x0300
#define MSG_TYPE_ADDRWITHDRAW	0x0301
#define MSG_TYPE_LABELMAPPING	0x0400
#define MSG_TYPE_LABELREQUEST	0x0401
#define MSG_TYPE_LABELWITHDRAW	0x0402
#define MSG_TYPE_LABELRELEASE	0x0403
#define MSG_TYPE_LABELABORTREQ	0x0404

/* LDP TLV types */
#define TLV_TYPE_FEC		0x0100
#define TLV_TYPE_ADDRLIST	0x0101
#define TLV_TYPE_HOPCOUNT	0x0103
#define TLV_TYPE_PATHVECTOR	0x0104
#define TLV_TYPE_GENERICLABEL	0x0200
#define TLV_TYPE_ATMLABEL	0x0201
#define TLV_TYPE_FRLABEL	0x0202
#define TLV_TYPE_STATUS		0x0300
#define TLV_TYPE_EXTSTATUS	0x0301
#define TLV_TYPE_RETURNEDPDU	0x0302
#define TLV_TYPE_RETURNEDMSG	0x0303
#define TLV_TYPE_COMMONHELLO	0x0400
#define TLV_TYPE_IPV4TRANSADDR	0x0401
#define TLV_TYPE_CONFIG		0x0402
#define TLV_TYPE_IPV6TRANSADDR	0x0403
#define TLV_TYPE_COMMONSESSION	0x0500
#define TLV_TYPE_ATMSESSIONPAR	0x0501
#define TLV_TYPE_FRSESSION	0x0502
#define TLV_TYPE_LABELREQUEST	0x0600
/* RFC 4447 */
#define TLV_TYPE_MAC_LIST	0x8404
#define TLV_TYPE_PW_STATUS	0x896A
#define TLV_TYPE_PW_IF_PARAM	0x096B
#define TLV_TYPE_PW_GROUP_ID	0x096C
/* RFC 5561 */
#define TLV_TYPE_RETURNED_TLVS	0x8304
#define TLV_TYPE_DYNAMIC_CAP	0x8506
/* RFC 5918 */
#define TLV_TYPE_TWCARD_CAP	0x850B
/* RFC 5919 */
#define TLV_TYPE_UNOTIF_CAP	0x8603
/* RFC 7552 */
#define TLV_TYPE_DUALSTACK	0x8701

/* LDP header */
struct ldp_hdr {
	uint16_t	version;
	uint16_t	length;
	uint32_t	lsr_id;
	uint16_t	lspace_id;
} __packed;

#define	LDP_HDR_SIZE		10	/* actual size of the LDP header */
#define	LDP_HDR_PDU_LEN		6	/* minimum "PDU Length" */
#define LDP_HDR_DEAD_LEN	4

/* TLV record */
struct tlv {
	uint16_t	type;
	uint16_t	length;
};
#define	TLV_HDR_SIZE		4

struct ldp_msg {
	uint16_t	type;
	uint16_t	length;
	uint32_t	id;
	/* Mandatory Parameters */
	/* Optional Parameters */
} __packed;

#define LDP_MSG_SIZE		8	/* minimum size of LDP message */
#define LDP_MSG_LEN		4	/* minimum "Message Length" */
#define LDP_MSG_DEAD_LEN	4

#define	UNKNOWN_FLAG		0x8000
#define	FORWARD_FLAG		0xc000

struct hello_prms_tlv {
	uint16_t	type;
	uint16_t	length;
	uint16_t	holdtime;
	uint16_t	flags;
};
#define F_HELLO_TARGETED	0x8000
#define F_HELLO_REQ_TARG	0x4000
#define F_HELLO_GTSM		0x2000

struct hello_prms_opt4_tlv {
	uint16_t	type;
	uint16_t	length;
	uint32_t	value;
};

struct hello_prms_opt16_tlv {
	uint16_t	type;
	uint16_t	length;
	uint8_t		value[16];
};

#define DUAL_STACK_LDPOV4	4
#define DUAL_STACK_LDPOV6	6

#define F_HELLO_TLV_RCVD_ADDR	0x01
#define F_HELLO_TLV_RCVD_CONF	0x02
#define F_HELLO_TLV_RCVD_DS	0x04

#define	S_SUCCESS	0x00000000
#define	S_BAD_LDP_ID	0x80000001
#define	S_BAD_PROTO_VER	0x80000002
#define	S_BAD_PDU_LEN	0x80000003
#define	S_UNKNOWN_MSG	0x00000004
#define	S_BAD_MSG_LEN	0x80000005
#define	S_UNKNOWN_TLV	0x00000006
#define	S_BAD_TLV_LEN	0x80000007
#define	S_BAD_TLV_VAL	0x80000008
#define	S_HOLDTIME_EXP	0x80000009
#define	S_SHUTDOWN	0x8000000A
#define	S_LOOP_DETECTED	0x0000000B
#define	S_UNKNOWN_FEC	0x0000000C
#define	S_NO_ROUTE	0x0000000D
#define	S_NO_LABEL_RES	0x0000000E
#define	S_AVAILABLE	0x0000000F
#define	S_NO_HELLO	0x80000010
#define	S_PARM_ADV_MODE	0x80000011
#define	S_MAX_PDU_LEN	0x80000012
#define	S_PARM_L_RANGE	0x80000013
#define	S_KEEPALIVE_TMR	0x80000014
#define	S_LAB_REQ_ABRT	0x00000015
#define	S_MISS_MSG	0x00000016
#define	S_UNSUP_ADDR	0x00000017
#define	S_KEEPALIVE_BAD	0x80000018
#define	S_INTERN_ERR	0x80000019
/* RFC 4447 */
#define S_ILLEGAL_CBIT	0x00000024
#define S_WRONG_CBIT	0x00000025
#define S_INCPT_BITRATE	0x00000026
#define S_CEP_MISCONF	0x00000027
#define S_PW_STATUS	0x00000028
#define S_UNASSIGN_TAI	0x00000029
#define S_MISCONF_ERR	0x0000002A
#define S_WITHDRAW_MTHD	0x0000002B
/* RFC 5561 */
#define	S_UNSSUPORTDCAP	0x0000002E
/* RFC 5919 */
#define	S_ENDOFLIB	0x0000002F
/* RFC 7552 */
#define	S_TRANS_MISMTCH	0x80000032
#define	S_DS_NONCMPLNCE	0x80000033

struct sess_prms_tlv {
	uint16_t	type;
	uint16_t	length;
	uint16_t	proto_version;
	uint16_t	keepalive_time;
	uint8_t		reserved;
	uint8_t		pvlim;
	uint16_t	max_pdu_len;
	uint32_t	lsr_id;
	uint16_t	lspace_id;
} __packed;

#define SESS_PRMS_SIZE		18
#define SESS_PRMS_LEN		14

struct status_tlv {
	uint16_t	type;
	uint16_t	length;
	uint32_t	status_code;
	uint32_t	msg_id;
	uint16_t	msg_type;
} __packed;

#define STATUS_SIZE		14
#define STATUS_TLV_LEN		10
#define	STATUS_FATAL		0x80000000

struct capability_tlv {
	uint16_t	type;
	uint16_t	length;
	uint8_t		reserved;
};
#define STATE_BIT		0x80

#define F_CAP_TLV_RCVD_DYNAMIC	0x01
#define F_CAP_TLV_RCVD_TWCARD	0x02
#define F_CAP_TLV_RCVD_UNOTIF	0x04

#define CAP_TLV_DYNAMIC_SIZE	5
#define CAP_TLV_DYNAMIC_LEN	1

#define CAP_TLV_TWCARD_SIZE	5
#define CAP_TLV_TWCARD_LEN	1

#define CAP_TLV_UNOTIF_SIZE	5
#define CAP_TLV_UNOTIF_LEN	1

#define	AF_IPV4			0x1
#define	AF_IPV6			0x2

struct address_list_tlv {
	uint16_t	type;
	uint16_t	length;
	uint16_t	family;
	/* address entries */
} __packed;

#define ADDR_LIST_SIZE		6

#define FEC_ELM_WCARD_LEN	1
#define FEC_ELM_PREFIX_MIN_LEN	4
#define FEC_PWID_ELM_MIN_LEN	8
#define FEC_PWID_SIZE		4
#define FEC_ELM_TWCARD_MIN_LEN	3

#define	MAP_TYPE_WILDCARD	0x01
#define	MAP_TYPE_PREFIX		0x02
#define	MAP_TYPE_TYPED_WCARD	0x05
#define	MAP_TYPE_PWID		0x80
#define	MAP_TYPE_GENPWID	0x81

#define CONTROL_WORD_FLAG	0x8000
#define PW_TYPE_ETHERNET_TAGGED	0x0004
#define PW_TYPE_ETHERNET	0x0005
#define PW_TYPE_WILDCARD	0x7FFF
#define DEFAULT_PW_TYPE		PW_TYPE_ETHERNET

#define PW_TWCARD_RESERVED_BIT	0x8000

/* RFC 4447 Sub-TLV record */
struct subtlv {
	uint8_t		type;
	uint8_t		length;
};
#define	SUBTLV_HDR_SIZE		2

#define SUBTLV_IFMTU		0x01
#define SUBTLV_VLANID		0x06

#define FEC_SUBTLV_IFMTU_SIZE	4
#define FEC_SUBTLV_VLANID_SIZE	4

struct label_tlv {
	uint16_t	type;
	uint16_t	length;
	uint32_t	label;
};
#define LABEL_TLV_SIZE		8
#define LABEL_TLV_LEN		4

struct reqid_tlv {
	uint16_t	type;
	uint16_t	length;
	uint32_t	reqid;
};
#define REQID_TLV_SIZE		8
#define REQID_TLV_LEN		4

struct pw_status_tlv {
	uint16_t	type;
	uint16_t	length;
	uint32_t	value;
};
#define PW_STATUS_TLV_SIZE	8
#define PW_STATUS_TLV_LEN	4

#define PW_FORWARDING		0
#define PW_NOT_FORWARDING	(1 << 0)
#define PW_LOCAL_RX_FAULT	(1 << 1)
#define PW_LOCAL_TX_FAULT	(1 << 2)
#define PW_PSN_RX_FAULT		(1 << 3)
#define PW_PSN_TX_FAULT		(1 << 4)

#define	NO_LABEL		UINT32_MAX

#endif /* !_LDP_H_ */
@


1.41
log
@Implement RFC 5919 (LDP End-of-LIB).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.40 2017/03/04 00:12:26 renato Exp $ */
d98 1
@


1.40
log
@Implement RFC 6667 (Typed Wildcard FEC for PWid).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.39 2017/03/04 00:09:17 renato Exp $ */
d106 2
d211 2
d253 1
d260 3
@


1.39
log
@Implement RFC 5918 (Typed Wildcard FEC).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.38 2017/03/04 00:06:10 renato Exp $ */
d283 1
d285 2
@


1.38
log
@Implement RFC 5561 (LDP Capabilities).

This patch per-se doesn't introduce any useful functionality, but prepares
the ground for new enhancements to ldpd (i.e. implementation of new RFCs
that make use of LDP capabilities).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.37 2017/03/03 23:56:54 renato Exp $ */
d104 2
d248 1
d253 3
d272 1
d276 1
@


1.37
log
@The PW Status is an unknown TLV.

Without this fix, any LDP speaker that doesn't implement RFC 4447 will
shut down the session upon receipt of a PWid Label Mapping (unless the
use of the PW-Status TLV is disabled via configuration).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.36 2017/03/03 23:41:27 renato Exp $ */
d68 1
d101 3
d205 2
d237 12
@


1.36
log
@Minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.35 2016/09/03 16:07:08 renato Exp $ */
d97 1
a97 1
#define TLV_TYPE_PW_STATUS	0x096A
@


1.35
log
@Rework the sending of address messages.

* Respect the session's negotiated maximum pdu length and split the
  sending of our local addresses into multiple messages if necessary;

* Log sent/received addresses;

* Add new wrappers to send only one address (send_address_single)
  and to send all addresses of the given address-family
  (send_address_all). These wrappers create a temporary list of addresses
  to be sent, and send_address() then acts on this last.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.34 2016/07/15 17:09:25 renato Exp $ */
d247 1
@


1.34
log
@Improve logging of reserved labels.

Print "exp-null" and "imp-null" instead of "0" and "3", for example. Also,
remove print_label() and print_pw_type() from ldpctl.c and use the
equivalent functions from ldpd's log.c.

While here, be more paranoid and use UINT32_MAX instead of UINT_MAX
for NO_LABEL.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.33 2016/07/01 23:36:38 renato Exp $ */
d241 2
@


1.33
log
@More renaming and whitespace cleanup.

No binary change after "strip -s".
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.32 2016/07/01 23:22:42 renato Exp $ */
d300 1
a300 1
#define	NO_LABEL		UINT_MAX
@


1.32
log
@Decrease the initialization FSM timeout.

The previous value of 180 was just too long. If a neighbor get stuck in
the initialization FSM for more than 15 seconds, then there's certainly
something wrong and the session should be dropped.

A potential case of a neighbor getting stuck in the initialization
FSM is when both the local and the remote LSRs disable the LDPv4 GTSM
negotiation and there's a mismatch in their GTSM configuration (one is
enabled for GTSM while the other is not).

In this case, a smaller timeout allows for a quicker recovery of the
session when the configuration is fixed on either side.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.31 2016/07/01 23:18:24 renato Exp $ */
d120 1
a120 1
#define	TLV_HDR_LEN		4
d125 1
a125 1
	uint32_t	msgid;
a142 1

d218 1
d261 1
a261 1
#define	SUBTLV_HDR_LEN		2
d266 2
a267 2
#define FEC_SUBTLV_IFMTU_LEN	4
#define FEC_SUBTLV_VLANID_LEN	4
d274 2
a275 2

#define LABEL_TLV_LEN		8
d282 2
a283 2

#define REQID_TLV_LEN		8
d290 2
a291 2

#define PW_STATUS_TLV_LEN	8
@


1.31
log
@Rename hello flags to keep consistent with the rest of the code.

Flag constants should start with F_.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.30 2016/07/01 23:14:31 renato Exp $ */
d47 1
@


1.30
log
@Add GTSM support (RFC 6720).

This also finishes the missing bits from our RFC 7552 implementation
because GTSM is mandatory for LDPv6.

To avoid any kind of interoperability problems, I included a few
knobs to enable/disable GTSM on a per-address-family and per-neighbor
basis. Cisco's LDPv6 implementation, for instance, doesn't support GTSM.

"reads good" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.29 2016/05/23 19:14:03 renato Exp $ */
d143 3
a145 3
#define TARGETED_HELLO		0x8000
#define REQUEST_TARG_HELLO	0x4000
#define GTSM_HELLO		0x2000
@


1.29
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.28 2016/05/23 19:11:42 renato Exp $ */
d145 1
@


1.28
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.27 2016/05/23 18:58:48 renato Exp $ */
d4 1
@


1.27
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.26 2016/05/23 17:43:42 renato Exp $ */
d25 1
a25 1
#include <netinet/in.h>
@


1.26
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d30 1
a30 1
#define AllRouters		"224.0.0.2"
d32 3
a34 1
#define LDP_MAX_LEN		4096
d98 2
d151 12
d199 3
@


1.25
log
@Minor adjustments in l2vpn code.

* Define a new constant for the default pseudowire type;
* On l2vpn_new(), initialize the l2vpn lists with LIST_NEW (cosmetic
  because the struct was calloc'ed);
* Add a const qualifier to the second parameter of l2vpn_find();
* Remove l2vpn_if_del() and use just free() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.24 2016/05/23 16:12:28 renato Exp $ */
d99 4
a102 4
	u_int16_t		version;
	u_int16_t		length;
	u_int32_t		lsr_id;
	u_int16_t		lspace_id;
d111 2
a112 2
	u_int16_t	type;
	u_int16_t	length;
d117 3
a119 3
	u_int16_t	type;
	u_int16_t	length;
	u_int32_t	msgid;
d132 4
a135 4
	u_int16_t	type;
	u_int16_t	length;
	u_int16_t	holdtime;
	u_int16_t	flags;
d142 3
a144 3
	u_int16_t	type;
	u_int16_t	length;
	u_int32_t	value;
d185 9
a193 9
	u_int16_t	type;
	u_int16_t	length;
	u_int16_t	proto_version;
	u_int16_t	keepalive_time;
	u_int8_t	reserved;
	u_int8_t	pvlim;
	u_int16_t	max_pdu_len;
	u_int32_t	lsr_id;
	u_int16_t	lspace_id;
d199 5
a203 5
	u_int16_t	type;
	u_int16_t	length;
	u_int32_t	status_code;
	u_int32_t	msg_id;
	u_int16_t	msg_type;
d214 3
a216 3
	u_int16_t	type;
	u_int16_t	length;
	u_int16_t	family;
d236 2
a237 2
	u_int8_t	type;
	u_int8_t	length;
d248 3
a250 3
	u_int16_t	type;
	u_int16_t	length;
	u_int32_t	label;
d256 3
a258 3
	u_int16_t	type;
	u_int16_t	length;
	u_int32_t	reqid;
d264 3
a266 3
	u_int16_t	type;
	u_int16_t	length;
	u_int32_t	value;
@


1.24
log
@Rename a few constants to avoid confusion.

In ldpd we have the map structure, which is used to represent a label message,
and the fec structure, used to store FECs in the LIB.

As of now, ldpd supports two type of FECs:
* IPv4 prefix (FEC_TYPE_IPV4);
* PWID (FEC_TYPE_PWID).

For the label messages, the following contants were being used:
* FEC_WILDCARD;
* FEC_PREFIX (IPv4 or IPv6);
* FEC_PWID.

Since these contants have similar names to the previous ones, rename
them to:
* MAP_TYPE_WILDCARD;
* MAP_TYPE_PREFIX;
* MAP_TYPE_PWID.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.23 2016/05/23 16:10:23 renato Exp $ */
d232 1
@


1.23
log
@Remove unused code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.22 2016/05/23 16:04:04 renato Exp $ */
d223 5
a227 4
#define	FEC_WILDCARD		0x01
#define	FEC_PREFIX		0x02
#define	FEC_PWID		0x80
#define	FEC_GENPWID		0x81
@


1.22
log
@Improve the parser of TCP/session packets.

Add more safeguards against malformed packets and fix existing ones. Also,
rename a few variables and constants to match their real meaning. For
example, rename gen_msg_tlv() to gen_msg_hdr() because this function
generates an LDP header, not a TLV.

Finally, clean-up all the send_* functions so they all follow the same
pattern.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.21 2016/05/23 15:53:40 renato Exp $ */
a146 1
#define HELLO_PRMS_SIZE		8
@


1.21
log
@Validate received hello holdtime and keepalive time.

Refuse a keepalive time of zero because it's invalid. For the hello
holdtime, zero is valid and means infinite.

Additionally, refuse values smaller than three for both the keepalive
timer and the hello holdtime. The keepalive/hello interval is calculated
as one third of their holdtime, which means that if the holdtime is one
or two, the calculated interval would be zero using integer arithmetic.

If anyone wants to use such a small holdtime, he or she should use
BFD instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.20 2016/05/23 15:47:24 renato Exp $ */
d105 3
a107 2
#define	LDP_HDR_SIZE		10
#define	LDP_HDR_PDU_LEN		6
d124 3
a126 1
#define LDP_MSG_LEN		8
@


1.20
log
@Move some code around.

This patch doesn't introduce any logical change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.19 2015/07/21 04:52:29 renato Exp $ */
d36 1
a36 1
#define MIN_HOLDTIME		1
d41 1
a41 1
#define MIN_KEEPALIVE		1
@


1.19
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.18 2015/07/19 20:54:17 renato Exp $ */
a127 3
#define TARGETED_HELLO		0x8000
#define REQUEST_TARG_HELLO	0x4000

d134 3
@


1.18
log
@Rework label mapping algorithms to be more in line with the RFC.

This patch presents a thoroughly review of the label mapping
algorithms. Most of the changes are minor bug fixes in the handling of
received label messages.

Additional improvements:
* Add a few more references to the Appendix A of the RFC5036 ("LDP
  Label Distribution Procedures") into the code;
* Add full multipath support;
* Send label withdraws when appropriate;
* Add label withdraw/release wildcard support.

NOTE: As a result of implementing only the "Liberal Label Retention" and
"Downstream Unsolicited" modes, we will never send a label request
("Request  Never"). And that means that we can ignore the following
notification messages: "Label Request Aborted", "No Label Resources",
"No Route" and "Label Resources Available". The following algorithms
mentioned in the RFC can also be ignored: "Timeout of Deferred Label
Request", "Detect Local Label Resources Have Become Available" and
"Receive Label Abort Request".

Now, considering that we only support one combination of all modes of
operation, we can say that we have an almost complete implementation of
the protocol.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.17 2015/03/21 18:34:01 renato Exp $ */
d52 7
d92 4
d172 9
d208 3
a217 3
#define	ADDR_IPV4		0x1
#define	ADDR_IPV6		0x2

d220 1
d223 19
a241 1
#define	FEC_IPV4		0x0001
d258 15
@


1.17
log
@Remove unused variables and functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.16 2013/10/17 17:52:21 renato Exp $ */
d198 2
a199 1
#define FEC_ELM_MIN_LEN		4
@


1.16
log
@Respect the max pdu length and merge all send_label* functions into
a single generic function.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.15 2013/10/15 19:59:53 renato Exp $ */
a196 6

/* This struct is badly aligned so use two 32 bit fields */
struct fec_elm {
	u_int32_t	hdr;
	u_int32_t	addr;
};
@


1.15
log
@Improve parsing of LDP messages.
Add more sanity checks and send proper notification messages on error
conditions.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.14 2013/10/15 16:47:24 renato Exp $ */
a193 2

#define	BASIC_LABEL_MAP_LEN	24
@


1.14
log
@Ignore messages that have Unknown flag set.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.13 2013/06/04 02:25:28 claudio Exp $ */
d95 1
@


1.13
log
@Implement support for adjacencies and targeted hellos
Refactor adjacencies out of the neighbor handling so that it is possible to
have more complex topologies with targeted sessions.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.12 2013/06/04 01:32:16 claudio Exp $ */
a112 1
#define	UNKNOWN_FLAGS_MASK	0xc000
@


1.12
log
@Properly implement the exponential backoff timer on session initialization

According with the section 2.5.3 of RFC 5036, an LSR must throttle its
session setup retry attempts with an exponential backoff in situations
where Initialization messages are being NAK'd (because of disagreements
on session parameters). It doesn't mention using this procedure for TCP
connection failures. With that said, start the inactive delay timer only
after receiving an appropriate notification message.

When playing the active role of the initialization process, throttle the
session setup retry attempts by not connecting to the remote peer. When
playing the passive role, throttle the session setup retry attempts by
delaying the processing of the received Initialization message.

Diff by Renato Westphal, adjusted by myself
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.11 2013/06/01 01:34:57 claudio Exp $ */
a35 2

#define DEFAULT_HOLDTIME	15
d47 1
a47 1
#define	MAX_HELLO_INTERVAL	0xffff	/* XXX */
a50 1
#define DEFAULT_NBR_TMOUT	86400	/* 24 hours */
@


1.11
log
@Always advertise the Router-ID as the transport address.
RFC 5036 - Section 2.5.2 says:
    An LSR MUST advertise the same transport address in all
    Hellos that advertise the same label space...
To satisfy this condition, always advertise the Router-ID as the
transport address by using the "IPv4 Transport Address" TLV in the
generated Hello messages.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.10 2013/05/30 16:14:50 claudio Exp $ */
d52 1
@


1.10
log
@Simplify hello holdtime calculation and stop the timeout timer if the
holdtime is "infinite".
Diff from Renato Westphal [renatowestphal at gmail.com]
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.9 2011/01/10 11:58:39 claudio Exp $ */
d127 6
@


1.9
log
@Better optional parameter parsing. Ignore unknown TLVs that have
the U flag set. Kill struct hello_opt_parms_tlv since it is now
unused.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.8 2011/01/10 11:52:04 claudio Exp $ */
a33 1
#define INFINITE_TMR		(-1)
d40 1
a96 1
#define	INFINITE_HOLDTIME	0xffff
@


1.8
log
@Rename struct fec_tlv to struct tlv since it is just the generic
TLV header which will be used in different places shortly.
Cleanup the ldp.h header file a tiny bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.7 2010/11/04 09:52:16 claudio Exp $ */
a222 6

struct hello_opt_parms_tlv {
	u_int16_t	type;
	u_int16_t	length;
	u_int32_t	value;
};
@


1.7
log
@Rewrite all packet parsers to be more careful about alignment. Until
now ldpd had no chance to run on a strict alignment architecture but
this makes ldpd happy on sparc64. Be careful to do all needed overflow
checks and try to make all parsing functions look similar.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.6 2010/10/26 12:59:03 claudio Exp $ */
d100 6
a114 1
#define	TLV_HDR_LEN		4
a196 6
struct fec_tlv {
	u_int16_t	type;
	u_int16_t	length;
	/* fec elm entries */
};

a203 1

a205 1

@


1.6
log
@Implement the optional label request message ID TLV.
Currently on the genaration side is done.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.5 2010/05/17 08:07:04 claudio Exp $ */
d106 1
a106 1
};
d122 1
a122 1
	u_int16_t	reserved;
d125 2
d164 1
a164 1
};
d174 1
a174 1
};
d185 1
a185 1
};
@


1.5
log
@The host address encoding of FEC was killed in RFC5036 and we're happy
about that. OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.4 2010/04/15 14:55:12 claudio Exp $ */
d216 8
@


1.4
log
@struct ldp_hdr has probably the worst possible layout (ending with a single
u_int16_t) and must therefor be __packed or sizeof() returns a to large size
and causes some very nasty issues.
"embrace __packed" dlg@@ OK michele@@
While there add new notification status types defined in RFC5036
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.3 2010/02/25 17:40:46 claudio Exp $ */
a205 1
#define	FEC_ADDRESS		0x03
@


1.3
log
@Do not use bufferevent for something that's already covered in the imsg
buffer API. This fixes a few possible problems in session_read and does
some further cleanup in various places. Wrap msgbuf into evbuf to add
libevent functionality and use buf_read to handle the read side of a
session.  OK michele@@ and dlg@@ did not see anything evil
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.2 2009/12/09 12:19:29 michele Exp $ */
d94 1
a94 1
};
d149 2
@


1.2
log
@Enable parsing of the optional Transport Address TLV in the hello
message.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldp.h,v 1.1 2009/06/01 20:59:45 michele Exp $ */
a93 1
	u_int8_t		pad;
a95 2
#define	PDU_HDR_SIZE		4

d108 1
a108 1
#define LDP_MSG_LEN		6
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d217 9
a225 2
#define LABEL_TLV_LEN	8
#define	NO_LABEL	UINT_MAX
@

