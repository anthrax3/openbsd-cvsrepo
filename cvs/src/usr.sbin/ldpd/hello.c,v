head	1.57;
access;
symbols
	OPENBSD_6_2_BASE:1.57
	OPENBSD_6_1:1.57.0.6
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.57.0.2
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.57
date	2016.07.16.19.20.16;	author renato;	state Exp;
branches;
next	1.56;
commitid	YLPvWL4I6VM5sc5a;

1.56
date	2016.07.01.23.36.38;	author renato;	state Exp;
branches;
next	1.55;
commitid	h9Qy21EPYXbAFnoh;

1.55
date	2016.07.01.23.29.55;	author renato;	state Exp;
branches;
next	1.54;
commitid	OkOx7tFZtmlIlivU;

1.54
date	2016.07.01.23.18.24;	author renato;	state Exp;
branches;
next	1.53;
commitid	0lNPHoosw9NBNZNy;

1.53
date	2016.07.01.23.14.31;	author renato;	state Exp;
branches;
next	1.52;
commitid	DKNC9fIizmSRxKR1;

1.52
date	2016.06.27.19.18.54;	author renato;	state Exp;
branches;
next	1.51;
commitid	c6CoftL15tiD3a66;

1.51
date	2016.06.27.19.06.33;	author renato;	state Exp;
branches;
next	1.50;
commitid	OXyvybFBtSb4ppHx;

1.50
date	2016.06.18.17.31.32;	author renato;	state Exp;
branches;
next	1.49;
commitid	Ou0pUplgSHSojMsH;

1.49
date	2016.06.13.23.01.37;	author renato;	state Exp;
branches;
next	1.48;
commitid	6Kn577N67pcmgY5D;

1.48
date	2016.06.13.20.13.34;	author renato;	state Exp;
branches;
next	1.47;
commitid	PXA9uYNvrI5vhKkE;

1.47
date	2016.06.11.02.06.46;	author renato;	state Exp;
branches;
next	1.46;
commitid	KSofkM3w1opoYAs6;

1.46
date	2016.06.11.01.55.35;	author renato;	state Exp;
branches;
next	1.45;
commitid	GgWpGoWeBPM557df;

1.45
date	2016.06.09.17.26.32;	author renato;	state Exp;
branches;
next	1.44;
commitid	iKrQLOonXcGPkDwb;

1.44
date	2016.06.08.23.14.03;	author renato;	state Exp;
branches;
next	1.43;
commitid	JIHEOMViIDrpgG9R;

1.43
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.42;
commitid	TLlfi1Pk0Z97z8HM;

1.42
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.41;
commitid	AQBoOveMRKjtVfFv;

1.41
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.40;
commitid	t07H0Mk6WGdVWB0W;

1.40
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.39;
commitid	D7VvXbswyzx5Ahb2;

1.39
date	2016.05.23.18.33.56;	author renato;	state Exp;
branches;
next	1.38;
commitid	YK3Z5X8iSxlfPhoT;

1.38
date	2016.05.23.18.28.22;	author renato;	state Exp;
branches;
next	1.37;
commitid	FV8IR5RMrg1EHRis;

1.37
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.36;
commitid	VpAym8dVR6eY4drQ;

1.36
date	2016.05.23.16.31.27;	author renato;	state Exp;
branches;
next	1.35;
commitid	c72xshgOyJT70vM6;

1.35
date	2016.05.23.16.20.59;	author renato;	state Exp;
branches;
next	1.34;
commitid	nAtgYzDo97D7UnEI;

1.34
date	2016.05.23.16.14.36;	author renato;	state Exp;
branches;
next	1.33;
commitid	hNzA87VdOHsaOms9;

1.33
date	2016.05.23.16.08.18;	author renato;	state Exp;
branches;
next	1.32;
commitid	BnqFnJhiKFbG4Dc4;

1.32
date	2016.05.23.16.04.04;	author renato;	state Exp;
branches;
next	1.31;
commitid	sfghEB6dR4Eaf77g;

1.31
date	2016.05.23.15.53.40;	author renato;	state Exp;
branches;
next	1.30;
commitid	1oKfyTeVVyhfWeTI;

1.30
date	2016.05.23.15.43.11;	author renato;	state Exp;
branches;
next	1.29;
commitid	weS0xzAgWBV4f0dh;

1.29
date	2016.05.23.15.14.07;	author renato;	state Exp;
branches;
next	1.28;
commitid	l3e6PhvoAh8C7elc;

1.28
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.27;
commitid	puLLDX1XPNc3GxB9;

1.27
date	2015.07.21.04.43.28;	author renato;	state Exp;
branches;
next	1.26;
commitid	QaTrdqMa9i0CUoyW;

1.26
date	2015.07.21.04.40.56;	author renato;	state Exp;
branches;
next	1.25;
commitid	aaU19t2dCdAdF6ZH;

1.25
date	2015.04.04.15.09.47;	author renato;	state Exp;
branches;
next	1.24;
commitid	LIJMvAJU0aJtE45t;

1.24
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.23;
commitid	2uw1UTO4k6erpWzK;

1.23
date	2013.10.15.20.31.13;	author renato;	state Exp;
branches;
next	1.22;

1.22
date	2013.10.15.20.21.24;	author renato;	state Exp;
branches;
next	1.21;

1.21
date	2013.10.15.20.13.47;	author renato;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.04.02.25.28;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.04.00.56.49;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.01.19.28.55;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2013.06.01.18.47.07;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2013.06.01.18.35.02;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2013.06.01.01.34.56;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2013.05.31.14.10.10;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2013.05.30.16.14.50;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2011.03.12.01.57.13;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.10.12.28.25;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2011.01.10.12.05.22;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.10.11.58.39;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.08.14.50.29;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.04.09.52.16;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.19.15.28.51;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.16.21.35.50;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.09.12.19.29;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.22.34.45;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Fix parsing of mal-formed optional TLVs/Sub-TLVs.

We must detect if a TLV's length extends beyond the end of the containing
message. And, if so, send a fatal "Bad TLV Length" notification message.

Found with the Mu Dynamics Mu-8000 protocol fuzzer.
@
text
@/*	$OpenBSD: hello.c,v 1.56 2016/07/01 23:36:38 renato Exp $ */

/*
 * Copyright (c) 2013, 2016 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <arpa/inet.h>
#include <string.h>

#include "ldpd.h"
#include "ldpe.h"
#include "log.h"

static int	gen_hello_prms_tlv(struct ibuf *buf, uint16_t, uint16_t);
static int	gen_opt4_hello_prms_tlv(struct ibuf *, uint16_t, uint32_t);
static int	gen_opt16_hello_prms_tlv(struct ibuf *, uint16_t, uint8_t *);
static int	gen_ds_hello_prms_tlv(struct ibuf *, uint32_t);
static int	tlv_decode_hello_prms(char *, uint16_t, uint16_t *, uint16_t *);
static int	tlv_decode_opt_hello_prms(char *, uint16_t, int *, int,
		    union ldpd_addr *, uint32_t *, uint16_t *);

int
send_hello(enum hello_type type, struct iface_af *ia, struct tnbr *tnbr)
{
	int			 af;
	union ldpd_addr		 dst;
	uint16_t		 size, holdtime = 0, flags = 0;
	int			 fd = 0;
	struct ibuf		*buf;
	int			 err = 0;

	switch (type) {
	case HELLO_LINK:
		af = ia->af;
		holdtime = ia->hello_holdtime;
		flags = 0;
		fd = (ldp_af_global_get(&global, af))->ldp_disc_socket;

		/* multicast destination address */
		switch (af) {
		case AF_INET:
			if (!(leconf->ipv4.flags & F_LDPD_AF_NO_GTSM))
				flags |= F_HELLO_GTSM;
			dst.v4 = global.mcast_addr_v4;
			break;
		case AF_INET6:
			dst.v6 = global.mcast_addr_v6;
			break;
		default:
			fatalx("send_hello: unknown af");
		}
		break;
	case HELLO_TARGETED:
		af = tnbr->af;
		holdtime = tnbr->hello_holdtime;
		flags = F_HELLO_TARGETED;
		if ((tnbr->flags & F_TNBR_CONFIGURED) || tnbr->pw_count)
			flags |= F_HELLO_REQ_TARG;
		fd = (ldp_af_global_get(&global, af))->ldp_edisc_socket;

		/* unicast destination address */
		dst = tnbr->addr;
		break;
	default:
		fatalx("send_hello: unknown hello type");
	}

	/* calculate message size */
	size = LDP_HDR_SIZE + LDP_MSG_SIZE + sizeof(struct hello_prms_tlv);
	switch (af) {
	case AF_INET:
		size += sizeof(struct hello_prms_opt4_tlv);
		break;
	case AF_INET6:
		size += sizeof(struct hello_prms_opt16_tlv);
		break;
	default:
		fatalx("send_hello: unknown af");
	}
	size += sizeof(struct hello_prms_opt4_tlv);
	if (ldp_is_dual_stack(leconf))
		size += sizeof(struct hello_prms_opt4_tlv);

	/* generate message */
	if ((buf = ibuf_open(size)) == NULL)
		fatal(__func__);

	err |= gen_ldp_hdr(buf, size);
	size -= LDP_HDR_SIZE;
	err |= gen_msg_hdr(buf, MSG_TYPE_HELLO, size);
	err |= gen_hello_prms_tlv(buf, holdtime, flags);

	/*
	 * RFC 7552 - Section 6.1:
	 * "An LSR MUST include only the transport address whose address
	 * family is the same as that of the IP packet carrying the Hello
	 * message".
	 */
	switch (af) {
	case AF_INET:
		err |= gen_opt4_hello_prms_tlv(buf, TLV_TYPE_IPV4TRANSADDR,
		    leconf->ipv4.trans_addr.v4.s_addr);
		break;
	case AF_INET6:
		err |= gen_opt16_hello_prms_tlv(buf, TLV_TYPE_IPV6TRANSADDR,
		    leconf->ipv6.trans_addr.v6.s6_addr);
		break;
	default:
		fatalx("send_hello: unknown af");
	}

	err |= gen_opt4_hello_prms_tlv(buf, TLV_TYPE_CONFIG,
	    htonl(global.conf_seqnum));

   	/*
	 * RFC 7552 - Section 6.1.1:
	 * "A Dual-stack LSR (i.e., an LSR supporting Dual-stack LDP for a peer)
	 * MUST include the Dual-Stack capability TLV in all of its LDP Hellos".
	 */
	if (ldp_is_dual_stack(leconf))
		err |= gen_ds_hello_prms_tlv(buf, leconf->trans_pref);

	if (err) {
		ibuf_free(buf);
		return (-1);
	}

	send_packet(fd, af, &dst, ia, buf->buf, buf->wpos);
	ibuf_free(buf);

	return (0);
}

void
recv_hello(struct in_addr lsr_id, struct ldp_msg *msg, int af,
    union ldpd_addr *src, struct iface *iface, int multicast, char *buf,
    uint16_t len)
{
	struct adj		*adj = NULL;
	struct nbr		*nbr, *nbrt;
	uint16_t		 holdtime, flags;
	int			 tlvs_rcvd;
	int			 ds_tlv;
	union ldpd_addr		 trans_addr;
	uint32_t		 scope_id = 0;
	uint32_t		 conf_seqnum;
	uint16_t		 trans_pref;
	int			 r;
	struct hello_source	 source;
	struct iface_af		*ia = NULL;
	struct tnbr		*tnbr = NULL;

	r = tlv_decode_hello_prms(buf, len, &holdtime, &flags);
	if (r == -1) {
		log_debug("%s: lsr-id %s: failed to decode params", __func__,
		    inet_ntoa(lsr_id));
		return;
	}
	/* safety checks */
	if (holdtime != 0 && holdtime < MIN_HOLDTIME) {
		log_debug("%s: lsr-id %s: invalid hello holdtime (%u)",
		    __func__, inet_ntoa(lsr_id), holdtime);
		return;
	}
	if (multicast && (flags & F_HELLO_TARGETED)) {
		log_debug("%s: lsr-id %s: multicast targeted hello", __func__,
		    inet_ntoa(lsr_id));
		return;
	}
	if (!multicast && !((flags & F_HELLO_TARGETED))) {
		log_debug("%s: lsr-id %s: unicast link hello", __func__,
		    inet_ntoa(lsr_id));
		return;
	}
	buf += r;
	len -= r;

	r = tlv_decode_opt_hello_prms(buf, len, &tlvs_rcvd, af, &trans_addr,
	    &conf_seqnum, &trans_pref);
	if (r == -1) {
		log_debug("%s: lsr-id %s: failed to decode optional params",
		    __func__, inet_ntoa(lsr_id));
		return;
	}
	if (r != len) {
		log_debug("%s: lsr-id %s: unexpected data in message",
		    __func__, inet_ntoa(lsr_id));
		return;
	}

	/* implicit transport address */
	if (!(tlvs_rcvd & F_HELLO_TLV_RCVD_ADDR))
		trans_addr = *src;
	if (bad_addr(af, &trans_addr)) {
		log_debug("%s: lsr-id %s: invalid transport address %s",
		    __func__, inet_ntoa(lsr_id), log_addr(af, &trans_addr));
		return;
	}
	if (af == AF_INET6 && IN6_IS_SCOPE_EMBED(&trans_addr.v6)) {
		/*
	 	 * RFC 7552 - Section 6.1:
		 * "An LSR MUST use a global unicast IPv6 address in an IPv6
		 * Transport Address optional object of outgoing targeted
		 * Hellos and check for the same in incoming targeted Hellos
		 * (i.e., MUST discard the targeted Hello if it failed the
		 * check)".
		 */
		if (flags & F_HELLO_TARGETED) {
			log_debug("%s: lsr-id %s: invalid targeted hello "
			    "transport address %s", __func__, inet_ntoa(lsr_id),
			     log_addr(af, &trans_addr));
			return;
		}
		scope_id = iface->ifindex;
	}

	memset(&source, 0, sizeof(source));
	if (flags & F_HELLO_TARGETED) {
		/*
	 	 * RFC 7552 - Section 5.2:
		* "The link-local IPv6 addresses MUST NOT be used as the
		* targeted LDP Hello packet's source or destination addresses".
		*/
		if (af == AF_INET6 && IN6_IS_SCOPE_EMBED(&src->v6)) {
			log_debug("%s: lsr-id %s: targeted hello with "
			    "link-local source address", __func__,
			    inet_ntoa(lsr_id));
			return;
		}

		tnbr = tnbr_find(leconf, af, src);

		/* remove the dynamic tnbr if the 'R' bit was cleared */
		if (tnbr && (tnbr->flags & F_TNBR_DYNAMIC) &&
		    !((flags & F_HELLO_REQ_TARG))) {
			tnbr->flags &= ~F_TNBR_DYNAMIC;
			tnbr = tnbr_check(tnbr);
		}

		if (!tnbr) {
			if (!((flags & F_HELLO_REQ_TARG) &&
			    ((ldp_af_conf_get(leconf, af))->flags &
			    F_LDPD_AF_THELLO_ACCEPT)))
				return;

			tnbr = tnbr_new(leconf, af, src);
			tnbr->flags |= F_TNBR_DYNAMIC;
			tnbr_update(tnbr);
			LIST_INSERT_HEAD(&leconf->tnbr_list, tnbr, entry);
		}

		source.type = HELLO_TARGETED;
		source.target = tnbr;
	} else {
		ia = iface_af_get(iface, af);
		source.type = HELLO_LINK;
		source.link.ia = ia;
		source.link.src_addr = *src;
	}

	adj = adj_find(&source);
	nbr = nbr_find_ldpid(lsr_id.s_addr);

	/* check dual-stack tlv */
	ds_tlv = (tlvs_rcvd & F_HELLO_TLV_RCVD_DS) ? 1 : 0;
	if (ds_tlv && trans_pref != leconf->trans_pref) {
		/*
	 	 * RFC 7552 - Section 6.1.1:
		 * "If the Dual-Stack capability TLV is present and the remote
		 * preference does not match the local preference (or does not
		 * get recognized), then the LSR MUST discard the Hello message
		 * and log an error.
		 * If an LDP session was already in place, then the LSR MUST
		 * send a fatal Notification message with status code of
		 * 'Transport Connection Mismatch' and reset the session".
		 */
		log_debug("%s: lsr-id %s: remote transport preference does not "
		    "match the local preference", __func__, inet_ntoa(lsr_id));
		if (nbr)
			session_shutdown(nbr, S_TRANS_MISMTCH, msg->id,
			    msg->type);
		if (adj)
			adj_del(adj, S_SHUTDOWN);
		return;
	}

	/*
	 * Check for noncompliant dual-stack neighbor according to
	 * RFC 7552 section 6.1.1.
	 */
	if (nbr && !ds_tlv) {
		switch (af) {
		case AF_INET:
			if (nbr_adj_count(nbr, AF_INET6) > 0) {
				session_shutdown(nbr, S_DS_NONCMPLNCE,
				    msg->id, msg->type);
				return;
			}
			break;
		case AF_INET6:
			if (nbr_adj_count(nbr, AF_INET) > 0) {
				session_shutdown(nbr, S_DS_NONCMPLNCE,
				    msg->id, msg->type);
				return;
			}
			break;
		default:
			fatalx("recv_hello: unknown af");
		}
	}

	/*
	 * Protections against misconfigured networks and buggy implementations.
	 */
	if (nbr && nbr->af == af &&
	    (ldp_addrcmp(af, &nbr->raddr, &trans_addr) ||
	    nbr->raddr_scope != scope_id)) {
		log_warnx("%s: lsr-id %s: hello packet advertising a different "
		    "transport address", __func__, inet_ntoa(lsr_id));
		if (adj)
			adj_del(adj, S_SHUTDOWN);
		return;
	}
	if (nbr == NULL) {
		nbrt = nbr_find_addr(af, &trans_addr);
		if (nbrt) {
			log_debug("%s: transport address %s is already being "
			    "used by lsr-id %s", __func__, log_addr(af,
			    &trans_addr), inet_ntoa(nbrt->id));
			if (adj)
				adj_del(adj, S_SHUTDOWN);
			return;
		}
	}

	if (adj == NULL) {
		adj = adj_new(lsr_id, &source, &trans_addr);
		if (nbr) {
			adj->nbr = nbr;
			LIST_INSERT_HEAD(&nbr->adj_list, adj, nbr_entry);
		}
	}

	/*
	 * If the hello adjacency's address-family doesn't match the local
	 * preference, then an adjacency is still created but we don't attempt
	 * to start an LDP session.
	 */
	if (nbr == NULL && (!ds_tlv ||
	    ((trans_pref == DUAL_STACK_LDPOV4 && af == AF_INET) ||
	    (trans_pref == DUAL_STACK_LDPOV6 && af == AF_INET6))))
		nbr = nbr_new(lsr_id, af, ds_tlv, &trans_addr, scope_id);

	/* dynamic LDPv4 GTSM negotiation as per RFC 6720 */
	if (nbr) {
		if (flags & F_HELLO_GTSM)
			nbr->flags |= F_NBR_GTSM_NEGOTIATED;
		else
			nbr->flags &= ~F_NBR_GTSM_NEGOTIATED;
	}

	/* update neighbor's configuration sequence number */
	if (nbr && (tlvs_rcvd & F_HELLO_TLV_RCVD_CONF)) {
		if (conf_seqnum > nbr->conf_seqnum &&
		    nbr_pending_idtimer(nbr))
			nbr_stop_idtimer(nbr);
		nbr->conf_seqnum = conf_seqnum;
	}

	/* always update the holdtime to properly handle runtime changes */
	switch (source.type) {
	case HELLO_LINK:
		if (holdtime == 0)
			holdtime = LINK_DFLT_HOLDTIME;

		adj->holdtime = min(ia->hello_holdtime, holdtime);
		break;
	case HELLO_TARGETED:
		if (holdtime == 0)
			holdtime = TARGETED_DFLT_HOLDTIME;

		adj->holdtime = min(tnbr->hello_holdtime, holdtime);
	}
	if (adj->holdtime != INFINITE_HOLDTIME)
		adj_start_itimer(adj);
	else
		adj_stop_itimer(adj);

	if (nbr && nbr->state == NBR_STA_PRESENT && !nbr_pending_idtimer(nbr) &&
	    nbr_session_active_role(nbr) && !nbr_pending_connect(nbr))
		nbr_establish_connection(nbr);
}

static int
gen_hello_prms_tlv(struct ibuf *buf, uint16_t holdtime, uint16_t flags)
{
	struct hello_prms_tlv	parms;

	memset(&parms, 0, sizeof(parms));
	parms.type = htons(TLV_TYPE_COMMONHELLO);
	parms.length = htons(sizeof(parms.holdtime) + sizeof(parms.flags));
	parms.holdtime = htons(holdtime);
	parms.flags = htons(flags);

	return (ibuf_add(buf, &parms, sizeof(parms)));
}

static int
gen_opt4_hello_prms_tlv(struct ibuf *buf, uint16_t type, uint32_t value)
{
	struct hello_prms_opt4_tlv	parms;

	memset(&parms, 0, sizeof(parms));
	parms.type = htons(type);
	parms.length = htons(sizeof(parms.value));
	parms.value = value;

	return (ibuf_add(buf, &parms, sizeof(parms)));
}

static int
gen_opt16_hello_prms_tlv(struct ibuf *buf, uint16_t type, uint8_t *value)
{
	struct hello_prms_opt16_tlv	parms;

	memset(&parms, 0, sizeof(parms));
	parms.type = htons(type);
	parms.length = htons(sizeof(parms.value));
	memcpy(&parms.value, value, sizeof(parms.value));

	return (ibuf_add(buf, &parms, sizeof(parms)));
}

static int
gen_ds_hello_prms_tlv(struct ibuf *buf, uint32_t value)
{
	if (leconf->flags & F_LDPD_DS_CISCO_INTEROP)
		value = htonl(value);
	else
		value = htonl(value << 28);

	return (gen_opt4_hello_prms_tlv(buf, TLV_TYPE_DUALSTACK, value));
}

static int
tlv_decode_hello_prms(char *buf, uint16_t len, uint16_t *holdtime,
    uint16_t *flags)
{
	struct hello_prms_tlv	tlv;

	if (len < sizeof(tlv))
		return (-1);
	memcpy(&tlv, buf, sizeof(tlv));

	if (tlv.type != htons(TLV_TYPE_COMMONHELLO))
		return (-1);
	if (ntohs(tlv.length) != sizeof(tlv) - TLV_HDR_SIZE)
		return (-1);

	*holdtime = ntohs(tlv.holdtime);
	*flags = ntohs(tlv.flags);

	return (sizeof(tlv));
}

static int
tlv_decode_opt_hello_prms(char *buf, uint16_t len, int *tlvs_rcvd, int af,
    union ldpd_addr *addr, uint32_t *conf_number, uint16_t *trans_pref)
{
	struct tlv	tlv;
	uint16_t	tlv_len;
	int		total = 0;

	*tlvs_rcvd = 0;
	memset(addr, 0, sizeof(*addr));
	*conf_number = 0;
	*trans_pref = 0;

	/*
	 * RFC 7552 - Section 6.1:
	 * "An LSR SHOULD accept the Hello message that contains both IPv4 and
	 * IPv6 Transport Address optional objects but MUST use only the
	 * transport address whose address family is the same as that of the
	 * IP packet carrying the Hello message.  An LSR SHOULD accept only
	 * the first Transport Address optional object for a given address
	 * family in the received Hello message and ignore the rest if the
	 * LSR receives more than one Transport Address optional object for a
	 * given address family".
	 */
	while (len >= sizeof(tlv)) {
		memcpy(&tlv, buf, TLV_HDR_SIZE);
		tlv_len = ntohs(tlv.length);
		if (tlv_len + TLV_HDR_SIZE > len)
			return (-1);
		buf += TLV_HDR_SIZE;
		len -= TLV_HDR_SIZE;
		total += TLV_HDR_SIZE;

		switch (ntohs(tlv.type)) {
		case TLV_TYPE_IPV4TRANSADDR:
			if (tlv_len != sizeof(addr->v4))
				return (-1);
			if (af != AF_INET)
				return (-1);
			if (*tlvs_rcvd & F_HELLO_TLV_RCVD_ADDR)
				break;
			memcpy(&addr->v4, buf, sizeof(addr->v4));
			*tlvs_rcvd |= F_HELLO_TLV_RCVD_ADDR;
			break;
		case TLV_TYPE_IPV6TRANSADDR:
			if (tlv_len != sizeof(addr->v6))
				return (-1);
			if (af != AF_INET6)
				return (-1);
			if (*tlvs_rcvd & F_HELLO_TLV_RCVD_ADDR)
				break;
			memcpy(&addr->v6, buf, sizeof(addr->v6));
			*tlvs_rcvd |= F_HELLO_TLV_RCVD_ADDR;
			break;
		case TLV_TYPE_CONFIG:
			if (tlv_len != sizeof(uint32_t))
				return (-1);
			memcpy(conf_number, buf, sizeof(uint32_t));
			*tlvs_rcvd |= F_HELLO_TLV_RCVD_CONF;
			break;
		case TLV_TYPE_DUALSTACK:
			if (tlv_len != sizeof(uint32_t))
				return (-1);
   			/*
	 		 * RFC 7552 - Section 6.1:
			 * "A Single-stack LSR does not need to use the
			 * Dual-Stack capability in Hello messages and SHOULD
			 * ignore this capability if received".
			 */
			if (!ldp_is_dual_stack(leconf))
				break;
			/* Shame on you, Cisco! */
			if (leconf->flags & F_LDPD_DS_CISCO_INTEROP) {
				memcpy(trans_pref, buf + sizeof(uint16_t),
				    sizeof(uint16_t));
				*trans_pref = ntohs(*trans_pref);
			} else {
				memcpy(trans_pref, buf , sizeof(uint16_t));
				*trans_pref = ntohs(*trans_pref) >> 12;
			}
			*tlvs_rcvd |= F_HELLO_TLV_RCVD_DS;
			break;
		default:
			/* if unknown flag set, ignore TLV */
			if (!(ntohs(tlv.type) & UNKNOWN_FLAG))
				return (-1);
			break;
		}
		buf += tlv_len;
		len -= tlv_len;
		total += tlv_len;
	}

	return (total);
}
@


1.56
log
@More renaming and whitespace cleanup.

No binary change after "strip -s".
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.55 2016/07/01 23:29:55 renato Exp $ */
d506 3
a511 1
		tlv_len = ntohs(tlv.length);
@


1.55
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.54 2016/07/01 23:18:24 renato Exp $ */
d149 1
a149 1
recv_hello(struct in_addr lsr_id, struct ldp_msg *lm, int af,
d294 2
a295 2
			session_shutdown(nbr, S_TRANS_MISMTCH, lm->msgid,
			    lm->type);
d310 1
a310 1
				    lm->msgid, lm->type);
d317 1
a317 1
				    lm->msgid, lm->type);
d471 1
a471 1
	if (ntohs(tlv.length) != sizeof(tlv) - TLV_HDR_LEN)
d505 4
a508 4
		memcpy(&tlv, buf, TLV_HDR_LEN);
		buf += TLV_HDR_LEN;
		len -= TLV_HDR_LEN;
		total += TLV_HDR_LEN;
@


1.54
log
@Rename hello flags to keep consistent with the rest of the code.

Flag constants should start with F_.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.53 2016/07/01 23:14:31 renato Exp $ */
d236 1
a236 1
		* targeted LDP Hello packet's source or destination addresses.
@


1.53
log
@Add GTSM support (RFC 6720).

This also finishes the missing bits from our RFC 7552 implementation
because GTSM is mandatory for LDPv6.

To avoid any kind of interoperability problems, I included a few
knobs to enable/disable GTSM on a per-address-family and per-neighbor
basis. Cisco's LDPv6 implementation, for instance, doesn't support GTSM.

"reads good" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.52 2016/06/27 19:18:54 renato Exp $ */
d57 1
a57 1
				flags |= GTSM_HELLO;
d70 1
a70 1
		flags = TARGETED_HELLO;
d72 1
a72 1
			flags |= REQUEST_TARG_HELLO;
d179 1
a179 1
	if (multicast && (flags & TARGETED_HELLO)) {
d184 1
a184 1
	if (!multicast && !((flags & TARGETED_HELLO))) {
d222 1
a222 1
		if (flags & TARGETED_HELLO) {
d232 1
a232 1
	if (flags & TARGETED_HELLO) {
d249 1
a249 1
		    !((flags & REQUEST_TARG_HELLO))) {
d255 1
a255 1
			if (!((flags & REQUEST_TARG_HELLO) &&
d370 1
a370 1
		if (flags & GTSM_HELLO)
@


1.52
log
@Fix inverted logic in recv_hello().

Bug introduced by rev1.48 two weeks ago. We were not respecting the
advertised transport connection preference (LDPoIPv4 or LDPoIPv6),
the fix is pretty obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.51 2016/06/27 19:06:33 renato Exp $ */
d56 2
d367 8
@


1.51
log
@Handle ibuf_add() errors.

tweaks from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.50 2016/06/18 17:31:32 renato Exp $ */
d362 2
a363 2
	    ((trans_pref == DUAL_STACK_LDPOV4 && af != AF_INET) ||
	    (trans_pref == DUAL_STACK_LDPOV6 && af != AF_INET6))))
@


1.50
log
@Fix removal of dual-stack neighbors.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.49 2016/06/13 23:01:37 renato Exp $ */
d44 1
d100 1
a100 1
	gen_ldp_hdr(buf, size);
d102 2
a103 2
	gen_msg_hdr(buf, MSG_TYPE_HELLO, size);
	gen_hello_prms_tlv(buf, holdtime, flags);
d113 1
a113 1
		gen_opt4_hello_prms_tlv(buf, TLV_TYPE_IPV4TRANSADDR,
d117 1
a117 1
		gen_opt16_hello_prms_tlv(buf, TLV_TYPE_IPV6TRANSADDR,
d124 1
a124 1
	gen_opt4_hello_prms_tlv(buf, TLV_TYPE_CONFIG,
d133 6
a138 1
		gen_ds_hello_prms_tlv(buf, leconf->trans_pref);
@


1.49
log
@Implement support for the Configuration Sequence Number TLV.

The Configuration Sequence Number optional TLV is documented in RFC 5036,
pages 53 and 54.

Fixes IxANVL LDP test 23.10.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.48 2016/06/13 20:13:34 renato Exp $ */
d289 1
a289 1
			adj_del(adj, 0, 0);
d327 1
a327 1
			adj_del(adj, 0, 0);
d337 1
a337 1
				adj_del(adj, 0, 0);
@


1.48
log
@Rework the handling of Hello packets.

With the introduction of IPv6 support by RFC 7552, the handling of Hello
packets in ldpd became something incredibly complex. Neighbors can change
from single-stack LDP to dual-stack and vice-versa. They can change
their transport preference, their transport addresses (IPv4 and IPv6)
and even start or stop sending the Dual-Stack TLV. We also have to take
care to reject things like multiple adjacencies advertising different
transport-addresses for the same neighbor. ldpd was failing for some of
the cases mentioned above, this patch fixes these issues and attempts
to make the code easier to read.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.47 2016/06/11 02:06:46 renato Exp $ */
d91 1
d123 3
d152 1
a152 1
	uint32_t		 conf_number;
d185 1
a185 1
	    &conf_number, &trans_pref);
d359 8
@


1.47
log
@Parse the whole Hello packet before processing it.

In the case of an error, we want to return as soon as possible to avoid
having to clean things up.

This fixes a bug where we could create a dynamic targeted neighbor in
response to a malformed packet.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.46 2016/06/11 01:55:35 renato Exp $ */
d142 1
a142 1
	struct nbr		*nbr;
d204 1
a204 1
		 * An LSR MUST use a global unicast IPv6 address in an IPv6
d210 4
a213 1
		if (flags & TARGETED_HELLO)
d215 1
d289 22
a310 5
	if (adj == NULL) {
		adj = adj_new(lsr_id, &source, &trans_addr);
		if (nbr) {
			adj->nbr = nbr;
			LIST_INSERT_HEAD(&nbr->adj_list, adj, nbr_entry);
d314 12
d327 2
a328 11
		/*
		 * The hello adjacency's address-family doesn't match the local
		 * preference.
		 */
		if (ds_tlv &&
		    ((trans_pref == DUAL_STACK_LDPOV4 && af != AF_INET) ||
		    (trans_pref == DUAL_STACK_LDPOV6 && af != AF_INET6)))
			return;

		nbr = nbr_find_addr(af, &trans_addr);
		if (nbr) {
d331 3
a333 1
			    &trans_addr), inet_ntoa(nbr->id));
d336 1
d338 5
a342 26
		/* create new adjacency and new neighbor */
		nbr = nbr_new(lsr_id, af, ds_tlv, &trans_addr, scope_id);
	} else {
		/*
		 * Check for noncompliant dual-stack neighbor according to
		 * RFC 7552 section 6.1.1.
		 */
		if (!ds_tlv) {
			switch (af) {
			case AF_INET:
				if (nbr_adj_count(nbr, AF_INET6) > 0) {
					session_shutdown(nbr, S_DS_NONCMPLNCE,
					    lm->msgid, lm->type);
					return;
				}
				break;
			case AF_INET6:
				if (nbr_adj_count(nbr, AF_INET) > 0) {
					session_shutdown(nbr, S_DS_NONCMPLNCE,
					    lm->msgid, lm->type);
					return;
				}
				break;
			default:
				fatalx("recv_hello: unknown af");
			}
d344 1
d346 9
a354 13
		/*
		 * Protection against misconfigured networks and buggy
		 * implementations.
		 */
		if (af == nbr->af &&
		    (ldp_addrcmp(af, &nbr->raddr, &trans_addr) ||
		    nbr->raddr_scope != scope_id)) {
			log_warnx("%s: lsr-id %s: ignoring hello packet "
			    "advertising different transport address", __func__,
			    inet_ntoa(lsr_id));
			return;
		}
	}
d375 2
a376 2
	if (nbr->state == NBR_STA_PRESENT && nbr_session_active_role(nbr) &&
	    !nbr_pending_connect(nbr) && !nbr_pending_idtimer(nbr))
@


1.46
log
@Make all TLV parsing functions look the same for consistency.

Also, add one more safety check in recv_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.45 2016/06/09 17:26:32 renato Exp $ */
d161 1
a166 4
	buf += r;
	len -= r;

	/* safety checks */
d177 37
a256 35
	}

	r = tlv_decode_opt_hello_prms(buf, len, &tlvs_rcvd, af, &trans_addr,
	    &conf_number, &trans_pref);
	if (r == -1) {
		log_debug("%s: lsr-id %s: failed to decode optional params",
		    __func__, inet_ntoa(lsr_id));
		return;
	}
	if (r != len) {
		log_debug("%s: lsr-id %s: unexpected data in message",
		    __func__, inet_ntoa(lsr_id));
		return;
	}

	/* implicit transport address */
	if (!(tlvs_rcvd & F_HELLO_TLV_RCVD_ADDR))
		trans_addr = *src;
	if (bad_addr(af, &trans_addr)) {
		log_debug("%s: lsr-id %s: invalid transport address %s",
		    __func__, inet_ntoa(lsr_id), log_addr(af, &trans_addr));
		return;
	}
	if (af == AF_INET6 && IN6_IS_SCOPE_EMBED(&trans_addr.v6)) {
		/*
	 	 * RFC 7552 - Section 6.1:
		 * An LSR MUST use a global unicast IPv6 address in an IPv6
		 * Transport Address optional object of outgoing targeted
		 * Hellos and check for the same in incoming targeted Hellos
		 * (i.e., MUST discard the targeted Hello if it failed the
		 * check)".
		 */
		if (source.type == HELLO_TARGETED)
			return;
		scope_id = iface->ifindex;
@


1.45
log
@Send a fatal notification when the last hello adjacency is deleted.

RFC 5036 says:
  "When the last Hello adjacency for an LDP session is
  deleted, the LSR terminates the LDP session by sending a Notification
  message and closing the transport connection".

Send a "Hold Timer Expired" notification when the triggering event is
a hello hold time timeout. In the other cases, like disabling LDP on an
interface, send a "Shutdown" notification instead.

Before this patch we were just closing the neighbor's transport
connection.

Fixes the following ANVL LDP tests: 7.17 and 23.3.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.44 2016/06/08 23:14:03 renato Exp $ */
d475 4
a478 1
		memcpy(&tlv, buf, sizeof(tlv));
d480 1
d489 1
a489 1
			memcpy(&addr->v4, buf + TLV_HDR_LEN, sizeof(addr->v4));
d499 1
a499 1
			memcpy(&addr->v6, buf + TLV_HDR_LEN, sizeof(addr->v6));
d505 1
a505 2
			memcpy(conf_number, buf + TLV_HDR_LEN,
			    sizeof(uint32_t));
d521 2
a522 2
				memcpy(trans_pref, buf + TLV_HDR_LEN +
				    sizeof(uint16_t), sizeof(uint16_t));
d525 1
a525 2
				memcpy(trans_pref, buf + TLV_HDR_LEN,
				    sizeof(uint16_t));
d536 3
a538 3
		buf += TLV_HDR_LEN + tlv_len;
		len -= TLV_HDR_LEN + tlv_len;
		total += TLV_HDR_LEN + tlv_len;
@


1.44
log
@Discard Hello packet if advertised transport address is of different AF.

IxANVL LDP test 5.13 was failing for ldpd(8) because we were not
discarding IPv4 Hello messages with an IPv6 transport address (and
vice-versa).

Once again, the RFC is not very explicit about what to do in this
case. Since the IPv4 and IPv6 Transport Address TLVs are optional,
what we were doing is to just ignore them in this case and use source
address of the packet as the implicit transport address.

But the IxANVL team had a different interpretation on this. They think
that discarding the Hello message is the right thing to do in this case.
Let's follow their interpretation because that's probably what most
implementations are doing.

NOTE1: with this patch we still keep ignoring additional Transport Address
TLVs as specified in RFC 7552;
NOTE2: in order to check if a Transport Address TLV was already received
or not, use the F_HELLO_TLV_RCVD_ADDR flag instead of comparing if the
address is zero or not (easier to read).

Fixes IxANVL LDP test 5.13.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.43 2016/05/23 19:14:03 renato Exp $ */
d282 1
a282 1
			adj_del(adj);
@


1.43
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.42 2016/05/23 19:11:42 renato Exp $ */
d481 3
a483 1
			if (af != AF_INET || ldp_addrisset(AF_INET, addr))
d491 3
a493 1
			if (af != AF_INET6 || ldp_addrisset(AF_INET6, addr))
@


1.42
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.41 2016/05/23 19:09:25 renato Exp $ */
d4 1
@


1.41
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.40 2016/05/23 18:58:48 renato Exp $ */
a19 5
#include <sys/socket.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <netinet/ip.h>
a20 5
#include <net/if_dl.h>

#include <errno.h>
#include <event.h>
#include <stdlib.h>
d24 1
a24 1
#include "ldp.h"
a25 1
#include "ldpe.h"
@


1.40
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.39 2016/05/23 18:33:56 renato Exp $ */
d38 7
a44 9
extern struct ldpd_conf        *leconf;

int	tlv_decode_hello_prms(char *, uint16_t, uint16_t *, uint16_t *);
int	tlv_decode_opt_hello_prms(char *, uint16_t, int *, int,
	    union ldpd_addr *, uint32_t *, uint16_t *);
int	gen_hello_prms_tlv(struct ibuf *buf, uint16_t, uint16_t);
int	gen_opt4_hello_prms_tlv(struct ibuf *, uint16_t, uint32_t);
int	gen_opt16_hello_prms_tlv(struct ibuf *, uint16_t, uint8_t *);
int	gen_ds_hello_prms_tlv(struct ibuf *, uint32_t);
d388 1
a388 1
int
d402 1
a402 1
int
d415 1
a415 1
int
d428 1
a428 1
int
d439 1
a439 1
int
d460 1
a460 1
int
@


1.39
log
@Create network sockets on the parent process.

We drop our privileges in ldpe right after we create the network sockets.
The problem is that we might want to change the transport-address and
reload the config, in which case we need new sockets. To allow that,
always create the network sockets in the parent process and pass them
to ldpe via imsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.38 2016/05/23 18:28:22 renato Exp $ */
d41 2
a42 2
int	tlv_decode_opt_hello_prms(char *, uint16_t, struct in_addr *,
	    uint32_t *);
d45 2
d49 1
a49 1
send_hello(enum hello_type type, struct iface *iface, struct tnbr *tnbr)
d51 2
a52 2
	struct sockaddr_in	 dst;
	struct ibuf		*buf;
d55 1
a55 4

	dst.sin_port = htons(LDP_PORT);
	dst.sin_family = AF_INET;
	dst.sin_len = sizeof(struct sockaddr_in);
d59 2
a60 2
		inet_aton(AllRouters, &dst.sin_addr);
		holdtime = iface->hello_holdtime;
d62 13
a74 1
		fd = global.ldp_disc_socket;
d77 1
a77 1
		dst.sin_addr = tnbr->addr;
d82 4
a85 1
		fd = global.ldp_edisc_socket;
d87 2
d91 14
a104 2
	size = LDP_HDR_SIZE + LDP_MSG_SIZE + sizeof(struct hello_prms_tlv) +
	    sizeof(struct hello_prms_opt4_tlv);
a113 2
	gen_opt4_hello_prms_tlv(buf, TLV_TYPE_IPV4TRANSADDR,
	    leconf->trans_addr.s_addr);
d115 28
a142 1
	send_packet(fd, iface, buf->buf, buf->wpos, &dst);
d149 3
a151 2
recv_hello(struct in_addr lsr_id, struct ldp_msg *lm, struct in_addr src,
    struct iface *iface, int multicast, char *buf, uint16_t len)
d153 1
a153 1
	struct adj		*adj;
d156 4
a159 1
	struct in_addr		 transport_addr;
d161 1
d164 1
d195 13
a207 1
		tnbr = tnbr_find(leconf, src);
d218 2
a219 1
			    leconf->flags & F_LDPD_TH_ACCEPT))
d222 1
a222 1
			tnbr = tnbr_new(leconf, src);
d231 1
d233 2
a234 2
		source.link.iface = iface;
		source.link.src_addr = src;
d237 2
a238 2
	r = tlv_decode_opt_hello_prms(buf, len, &transport_addr,
	    &conf_number);
d251 3
a253 3
	if (transport_addr.s_addr == INADDR_ANY)
		transport_addr = src;
	if (bad_ip_addr(transport_addr)) {
d255 1
a255 1
		    __func__, inet_ntoa(lsr_id), inet_ntoa(transport_addr));
d258 13
d272 1
d274 50
a323 1
	if (!nbr) {
d325 1
a325 2
		nbr = nbr_new(lsr_id, transport_addr);
		adj = adj_new(nbr, &source, transport_addr);
d327 36
a362 10
		adj = adj_find(nbr, &source);
		if (!adj) {
			/* create new adjacency for existing neighbor */
			adj = adj_new(nbr, &source, transport_addr);

			if (nbr->raddr.s_addr != transport_addr.s_addr)
				log_warnx("%s: lsr-id %s: multiple "
				    "adjacencies advertising different "
				    "transport addresses", __func__,
				    inet_ntoa(lsr_id));
d372 1
a372 1
		adj->holdtime = min(iface->hello_holdtime, holdtime);
d411 1
a411 1
	parms.length = htons(4);
d418 24
d463 2
a464 2
tlv_decode_opt_hello_prms(char *buf, uint16_t len, struct in_addr *addr,
    uint32_t *conf_number)
d470 1
d473 1
d475 11
d491 9
a499 1
			if (tlv_len != sizeof(uint32_t))
d501 4
a504 1
			memcpy(addr, buf + TLV_HDR_LEN, sizeof(uint32_t));
d511 24
@


1.38
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).

In addition, copy in_addr structs directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.37 2016/05/23 17:43:42 renato Exp $ */
d152 1
a152 1
			tnbr_init(tnbr);
@


1.37
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d66 1
a66 1
		dst.sin_addr.s_addr = tnbr->addr.s_addr;
d161 1
a161 1
		source.link.src_addr.s_addr = src.s_addr;
d179 1
a179 1
		transport_addr.s_addr = src.s_addr;
@


1.36
log
@Remove unnecessary mirroring of sockets.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.35 2016/05/23 16:20:59 renato Exp $ */
d40 5
a44 5
int	tlv_decode_hello_prms(char *, u_int16_t, u_int16_t *, u_int16_t *);
int	tlv_decode_opt_hello_prms(char *, u_int16_t, struct in_addr *,
	    u_int32_t *);
int	gen_hello_prms_tlv(struct ibuf *buf, u_int16_t, u_int16_t);
int	gen_opt4_hello_prms_tlv(struct ibuf *, u_int16_t, u_int32_t);
d51 1
a51 1
	u_int16_t		 size, holdtime = 0, flags = 0;
d96 2
a97 1
recv_hello(struct iface *iface, struct in_addr src, char *buf, u_int16_t len)
a98 2
	struct ldp_msg		 hello;
	struct ldp_hdr		 ldp;
d101 1
a101 1
	struct in_addr		 lsr_id;
d103 1
a103 2
	u_int32_t		 conf_number;
	u_int16_t		 holdtime, flags;
a107 10
	bcopy(buf, &ldp, sizeof(ldp));
	buf += LDP_HDR_SIZE;
	len -= LDP_HDR_SIZE;

	bcopy(buf, &hello, sizeof(hello));
	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);

	lsr_id.s_addr = ldp.lsr_id;

d134 1
a134 1
	bzero(&source, sizeof(source));
d152 1
a152 1
			tnbr_init(leconf, tnbr);
d230 1
a230 1
gen_hello_prms_tlv(struct ibuf *buf, u_int16_t holdtime, u_int16_t flags)
d234 1
a234 1
	bzero(&parms, sizeof(parms));
d244 1
a244 1
gen_opt4_hello_prms_tlv(struct ibuf *buf, u_int16_t type, u_int32_t value)
d248 1
a248 1
	bzero(&parms, sizeof(parms));
d257 2
a258 2
tlv_decode_hello_prms(char *buf, u_int16_t len, u_int16_t *holdtime,
    u_int16_t *flags)
d264 1
a264 1
	bcopy(buf, &tlv, sizeof(tlv));
d278 2
a279 2
tlv_decode_opt_hello_prms(char *buf, u_int16_t len, struct in_addr *addr,
    u_int32_t *conf_number)
d282 2
a283 2
	int		cons = 0;
	u_int16_t	tlv_len;
d285 1
a285 1
	bzero(addr, sizeof(*addr));
d289 1
a289 1
		bcopy(buf, &tlv, sizeof(tlv));
d293 1
a293 1
			if (tlv_len != sizeof(u_int32_t))
d295 1
a295 1
			bcopy(buf + TLV_HDR_LEN, addr, sizeof(u_int32_t));
d298 1
a298 1
			if (tlv_len != sizeof(u_int32_t))
d300 2
a301 2
			bcopy(buf + TLV_HDR_LEN, conf_number,
			    sizeof(u_int32_t));
@


1.35
log
@Standardize some log messages and fix some inconsistencies.

We were using several different names for the same thing in our log
messages: neighbor, neighbor ID, nbr ID and LSR ID.

Standardize to always use "lsr-id" to refer to a neighbor.

Also:
* Use log_warnx() instead of log_warn() when appropriate;
* Use fatal(x) instead of err(x) when appropriate;
* Fix some inconsistent log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.34 2016/05/23 16:14:36 renato Exp $ */
d63 1
a63 1
		fd = iface->discovery_fd;
d71 1
a71 1
		fd = tnbr->discovery_fd;
@


1.34
log
@More renaming.

Rename a few more things to improve readability.

* s/F_PW_CONTROLWORD_CONF/F_PW_CWORD_CONF/ (shorter)
* s/F_PW_CONTROLWORD/F_PW_CWORD/ (shorter)
* s/LDPD_FLAG_*/F_LDPD_*/ (consistency)
* s/lde_nbr_address/lde_addr/ (shorter)
* s/ldp_discovery_socket/ldp_disc_socket/ (shorter)
* s/ldp_ediscovery_socket/ldp_edisc_socket/ (shorter)
* s/ldp_sendboth/main_imsg_compose_both/ (consistency)
* s/cons/total/ (makes more sense)
* s/kaddr/ka/ (consistency with remaining code)
* Always use 'ln' for lde_nbrs (consistency)
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.33 2016/05/23 16:08:18 renato Exp $ */
d122 1
a122 1
		log_debug("%s: neighbor %s: failed to decode params", __func__,
d127 1
a127 1
		log_debug("%s: neighbor %s: invalid hello holdtime (%u)",
d136 1
a136 1
		log_debug("%s: neighbor %s: multicast targeted hello", __func__,
d141 1
a141 1
		log_debug("%s: neighbor %s: unicast link hello", __func__,
d179 1
a179 1
		log_debug("%s: neighbor %s: failed to decode optional params",
d184 1
a184 1
		log_debug("%s: neighbor %s: unexpected data in message",
d193 1
a193 1
		log_debug("%s: neighbor %s: invalid transport address %s",
d210 1
a210 1
				log_warnx("%s: neighbor %s: multiple "
@


1.33
log
@Several improvements in the parsing of UDP/Hello packets.

* Fix check of the packet's size and the "PDU Length" field;
* Add check for the "Message Length" field;
* Check for invalid labelspace earlier.
* Use if_lookup() on disc_recv_iface() to reduce one level of identation;

Additionally, add the following safeguards:
* Check for unicast link hellos;
* Check for multicast targeted hellos;
* Validate packet's source address;
* Validate received transport-address.

Put the ancillary function bad_ip_addr() into a new file, util.c, which
will be used later for several other things.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.32 2016/05/23 16:04:04 renato Exp $ */
d159 1
a159 1
			    leconf->flags & LDPD_FLAG_TH_ACCEPT))
d323 1
a323 1
		cons += TLV_HDR_LEN + tlv_len;
d326 1
a326 1
	return (cons);
@


1.32
log
@Improve the parser of TCP/session packets.

Add more safeguards against malformed packets and fix existing ones. Also,
rename a few variables and constants to match their real meaning. For
example, rename gen_msg_tlv() to gen_msg_hdr() because this function
generates an LDP header, not a TLV.

Finally, clean-up all the send_* functions so they all follow the same
pattern.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.31 2016/05/23 15:53:40 renato Exp $ */
d131 14
a170 5
		if (ldp.lspace_id != 0) {
			log_debug("%s: invalid label space ID %u, interface %s",
			    __func__, ldp.lspace_id, iface->name);
			return;
		}
a175 3
	buf += r;
	len -= r;

a182 3
	if (transport_addr.s_addr == INADDR_ANY)
		transport_addr.s_addr = src.s_addr;

d189 10
a198 1
	nbr = nbr_find_ldpid(ldp.lsr_id);
a230 1

d278 2
a280 3
		return (-1);

	if (tlv.type != htons(TLV_TYPE_COMMONHELLO))
@


1.31
log
@Validate received hello holdtime and keepalive time.

Refuse a keepalive time of zero because it's invalid. For the hello
holdtime, zero is valid and means infinite.

Additionally, refuse values smaller than three for both the keepalive
timer and the hello holdtime. The keepalive/hello interval is calculated
as one third of their holdtime, which means that if the holdtime is one
or two, the calculated interval would be zero using integer arithmetic.

If anyone wants to use such a small holdtime, he or she should use
BFD instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.30 2016/05/23 15:43:11 renato Exp $ */
d75 5
a79 1
	if ((buf = ibuf_open(LDP_MAX_LEN)) == NULL)
a81 4
	size = LDP_HDR_SIZE + sizeof(struct ldp_msg) +
	    sizeof(struct hello_prms_tlv) +
	    sizeof(struct hello_prms_opt4_tlv);

a82 1

d84 1
a84 3

	gen_msg_tlv(buf, MSG_TYPE_HELLO, size);

@


1.30
log
@Add knob to configure the transport address.

This will be especially important when we add support for IPv6, because
we'll not be able to use the router-id as the transport-address in
this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.29 2016/05/23 15:14:07 renato Exp $ */
d127 5
@


1.29
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.28 2015/07/21 04:52:29 renato Exp $ */
d89 2
a90 1
	gen_opt4_hello_prms_tlv(buf, TLV_TYPE_IPV4TRANSADDR, ldpe_router_id());
d195 1
a195 1
			if (nbr->addr.s_addr != transport_addr.s_addr)
@


1.28
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.27 2015/07/21 04:43:28 renato Exp $ */
d76 1
a76 1
		fatal("send_hello");
d124 1
a124 1
		log_debug("recv_hello: neighbor %s: failed to decode params",
d155 2
a156 3
			log_debug("recv_hello: invalid label space "
			    "ID %u, interface %s", ldp.lspace_id,
			    iface->name);
d170 2
a171 2
		log_debug("recv_hello: neighbor %s: failed to decode "
		    "optional params", inet_ntoa(lsr_id));
d178 2
a179 2
		log_debug("recv_hello: neighbor %s: unexpected data in message",
		    inet_ntoa(lsr_id));
d195 1
a195 1
				log_warnx("recv_hello: neighbor %s: multiple "
d197 2
a198 1
				    "transport addresses", inet_ntoa(lsr_id));
@


1.27
log
@Add configuration reload support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.26 2015/07/21 04:40:56 renato Exp $ */
d69 1
a69 1
		if (tnbr->flags & F_TNBR_CONFIGURED)
@


1.26
log
@Assorted fixes and code cleanup for targeted neighbors.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.25 2015/04/04 15:09:47 renato Exp $ */
d131 1
a131 1
		tnbr = tnbr_find(src);
@


1.25
log
@Remove unused parameter from adj_new().

The adjacency holdtime is set in recv_hello().

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.24 2014/10/25 03:23:49 lteo Exp $ */
d132 8
d145 2
a146 3
			tnbr = tnbr_new(leconf, src, 0);
			if (!tnbr)
				return;
d150 1
@


1.24
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.23 2013/10/15 20:31:13 renato Exp $ */
d180 1
a180 1
		adj = adj_new(nbr, &source, holdtime, transport_addr);
d185 1
a185 1
			adj = adj_new(nbr, &source, holdtime, transport_addr);
@


1.23
log
@Improve debug and error logs.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.22 2013/10/15 20:21:24 renato Exp $ */
a23 1
#include <netinet/in_systm.h>
@


1.22
log
@Fix whitespace and other style issues.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.21 2013/10/15 20:13:47 renato Exp $ */
d149 1
a149 1
			    "ID %s, interface %s", ldp.lspace_id,
@


1.21
log
@Since a targeted neighbor can be created both by configuration and
on runtime, the ldpd_conf structure used should be passed as an
argument to avoid segfaults.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.20 2013/06/04 02:25:28 claudio Exp $ */
d200 2
a201 4
		if (iface->hello_holdtime < holdtime)
			adj->holdtime = iface->hello_holdtime;
		else
			adj->holdtime = holdtime;
d206 2
a207 5
		if (tnbr->hello_holdtime < holdtime)
			adj->holdtime = tnbr->hello_holdtime;
		else
			adj->holdtime = holdtime;
		break;
@


1.20
log
@Implement support for adjacencies and targeted hellos
Refactor adjacencies out of the neighbor handling so that it is possible to
have more complex topologies with targeted sessions.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.19 2013/06/04 00:56:49 claudio Exp $ */
d138 1
a138 1
			tnbr = tnbr_new(src, 0);
@


1.19
log
@Minor adjustments in the initialization FSM
* Remove the unused NBR_EVT_DOWN event;
* Print the FSM transitions before performing the appropriate actions. In
  this way nested calls to nbr_fsm() won't print the state transitions in
  reverse order;
* When playing the active role of the initialization process, transition
  from NBA_STA_PRESENT to NBR_STA_INITIAL before going to NBR_STA_OPENSENT;
* Call session_shutdown() on nbr_ktimeout() to remove duplicated code;
* Notify the lde process when a neighbor is deleted (discovery timeout);
* Fix a few memory leaks on nbr_del().
Diff from Renato Westphal.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.18 2013/06/01 19:28:55 claudio Exp $ */
d39 2
d44 2
a45 2
int	gen_hello_prms_tlv(struct iface *, struct ibuf *);
int	gen_opt4_hello_prms_tlv(struct iface *, struct ibuf *);
d48 1
a48 1
send_hello(struct iface *iface)
d52 2
a53 1
	u_int16_t		 size;
d58 17
a74 1
	inet_aton(AllRouters, &dst.sin_addr);
d89 2
a90 2
	gen_hello_prms_tlv(iface, buf);
	gen_opt4_hello_prms_tlv(iface, buf);
d92 1
a92 1
	send_packet(iface, buf->buf, buf->wpos, &dst);
d103 2
a104 2
	struct nbr		*nbr = NULL;
	struct in_addr		 address;
d106 1
d110 2
d130 28
d161 2
a162 1
	r = tlv_decode_opt_hello_prms(buf, len, &address, &conf_number);
d168 3
d179 15
a193 1
		struct in_addr	a;
d195 7
a201 2
		if (address.s_addr == INADDR_ANY)
			a = src;
d203 3
a205 8
			a = address;

		nbr = nbr_new(lsr_id, a);

		/* set neighbor parameters */
		nbr->hello_type = flags;

		/* XXX: lacks support for targeted hellos */
d207 3
a209 4
			holdtime = LINK_DFLT_HOLDTIME;

		if (iface->holdtime < holdtime)
			nbr->holdtime = iface->holdtime;
d211 2
a212 1
			nbr->holdtime = holdtime;
d215 4
a218 1
	nbr_fsm(nbr, NBR_EVT_HELLO_RCVD);
d226 1
a226 1
gen_hello_prms_tlv(struct iface *iface, struct ibuf *buf)
d233 2
a234 3
	/* XXX */
	parms.holdtime = htons(iface->holdtime);
	parms.flags = 0;
d240 1
a240 1
gen_opt4_hello_prms_tlv(struct iface *iface, struct ibuf *buf)
d245 1
a245 1
	parms.type = htons(TLV_TYPE_IPV4TRANSADDR);
d247 1
a247 1
	parms.value = ldpe_router_id();
@


1.18
log
@The keepalive timeout should be configured on a global basis and not per
interface.
Remove the iface pointer from the 'nbr' structure because it's not
needed anymore.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.17 2013/06/01 18:47:07 claudio Exp $ */
d86 1
d99 2
a102 1
		address.s_addr = ldp.lsr_id;
d104 1
a104 1
		    inet_ntoa(address));
a112 1
		address.s_addr = ldp.lsr_id;
d114 1
a114 1
		    "optional params", inet_ntoa(address));
a117 1
		address.s_addr = ldp.lsr_id;
d119 1
a119 1
		    inet_ntoa(address));
d132 1
a132 1
		nbr = nbr_new(ldp.lsr_id, a);
@


1.17
log
@Drop support for per-interface labelspaces.
Support for per-interface labelspaces is only necessary for legacy ATM/FR
interfaces running in cell-mode. We shouldn't worry about this.
For platform-wide label spaces the label space id is always 0.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.16 2013/06/01 18:35:02 claudio Exp $ */
d132 1
a132 1
		nbr = nbr_new(ldp.lsr_id, iface, a);
@


1.16
log
@Drop support for passive interfaces.
Support for passive interfaces was inherited from ospfd but it doesn't
make any sense at all for ldpd.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.15 2013/06/01 01:34:56 claudio Exp $ */
d64 1
a64 1
	gen_ldp_hdr(buf, iface, size);
d123 1
a123 1
	nbr = nbr_find_ldpid(ldp.lsr_id, ldp.lspace_id);
d132 1
a132 1
		nbr = nbr_new(ldp.lsr_id, ldp.lspace_id, iface, a);
@


1.15
log
@Always advertise the Router-ID as the transport address.
RFC 5036 - Section 2.5.2 says:
    An LSR MUST advertise the same transport address in all
    Hellos that advertise the same label space...
To satisfy this condition, always advertise the Router-ID as the
transport address by using the "IPv4 Transport Address" TLV in the
generated Hello messages.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.14 2013/05/31 14:10:10 claudio Exp $ */
a55 3

	if (iface->passive)
		return (0);
@


1.14
log
@When the ldpe process calls connect(), it doesn't regain control until
either the connection is made or an error occurs. The time the process
is blocked can be significantly large to the point of other LDP sessions
being torn down because of their holdtime. Besides that, the ldpctl
program gets unresponsive if the ldpe process is blocked. Fix these
issues by using a non-blocking connect.
Diff from Renato Westphal [renatowestphal at gmail.com]
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.13 2013/05/30 16:14:50 claudio Exp $ */
d42 2
a43 1
int	gen_hello_prms_tlv(struct iface *, struct ibuf *, u_int16_t);
d64 2
a65 1
	    sizeof(struct hello_prms_tlv);
d73 2
a74 3
	size -= sizeof(struct ldp_msg);

	gen_hello_prms_tlv(iface, buf, size);
d152 2
a153 3
	if (ntohl(nbr->addr.s_addr) < ntohl(nbr->iface->addr.s_addr) &&
	    nbr->state == NBR_STA_PRESENT && !nbr_pending_connect(nbr) &&
	    !nbr_pending_idtimer(nbr))
d158 1
a158 1
gen_hello_prms_tlv(struct iface *iface, struct ibuf *buf, u_int16_t size)
a161 3
	/* We want just the size of the value */
	size -= TLV_HDR_LEN;

d164 1
a164 1
	parms.length = htons(size);
d168 13
@


1.13
log
@Simplify hello holdtime calculation and stop the timeout timer if the
holdtime is "infinite".
Diff from Renato Westphal [renatowestphal at gmail.com]
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.12 2011/03/12 01:57:13 claudio Exp $ */
d152 3
a154 2
	    nbr->state == NBR_STA_PRESENT && !nbr_pending_idtimer(nbr))
		nbr_act_session_establish(nbr, 1);
@


1.12
log
@Bad bad Claudio. Fix an evil bug that caused nbr addr_tree corruption.
Do not insert neighbors first to the address tree and then assign the
address to the struct. Instead pass the address to nbr_new() so all
keys for the various RB trees are available when setting the neighbor up.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.11 2011/01/10 12:28:25 claudio Exp $ */
d139 5
a143 8
		if (holdtime == 0) {
			/* XXX: lacks support for targeted hellos */
			if (iface->holdtime < LINK_DFLT_HOLDTIME)
				nbr->holdtime = iface->holdtime;
			else
				nbr->holdtime = LINK_DFLT_HOLDTIME;
		} else if (holdtime == INFINITE_HOLDTIME) {
			/* No timeout for this neighbor */
d145 2
a146 6
		} else {
			if (iface->holdtime < holdtime)
				nbr->holdtime = iface->holdtime;
			else
				nbr->holdtime = holdtime;
		}
@


1.11
log
@Fix a bad heritage from ospfd. Make neighbors independent of interfaces.
They are not bound as strongly as in ospf and causes problems when the
TCP connection is established from an not connected IP (e.g. a loopback).
Use three RB trees to sort the neighbor list by id, addr and peerid.
More cleanup is needed but this makes ldpd work against peers using
loopback IPs. Problem found, reported and fix tested again by Marcel Wiget.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.10 2011/01/10 12:05:22 claudio Exp $ */
d127 1
a127 1
		nbr = nbr_new(ldp.lsr_id, ldp.lspace_id, iface);
a128 1
		/* set neighbor parameters */
d130 1
a130 1
			nbr->addr.s_addr = src.s_addr;
d132 3
a134 1
			nbr->addr.s_addr = address.s_addr;
d136 1
@


1.10
log
@Make sure the tlv length is exactly the size we expect.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.9 2011/01/10 11:58:39 claudio Exp $ */
d125 1
a125 1
	nbr = nbr_find_ldpid(iface, ldp.lsr_id, ldp.lspace_id);
@


1.9
log
@Better optional parameter parsing. Ignore unknown TLVs that have
the U flag set. Kill struct hello_opt_parms_tlv since it is now
unused.
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.8 2011/01/08 14:50:29 claudio Exp $ */
d217 1
a217 1
			if (tlv_len < sizeof(u_int32_t))
d222 1
a222 1
			if (tlv_len < sizeof(u_int32_t))
@


1.8
log
@Count the right values for the consumed counter.
Problem found and fix provided by Marcel Wiget <mwiget () gmail ! com>
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.7 2010/11/04 09:52:16 claudio Exp $ */
d205 3
a207 2
	struct hello_opt_parms_tlv	tlv;
	int				cons = 0;
d214 1
a214 4

		if (ntohs(tlv.length) < sizeof(u_int32_t))
			return (-1);

d217 3
a219 1
			addr->s_addr = tlv.value;
d222 4
a225 1
			*conf_number = ntohl(tlv.value);
d228 4
a231 1
			return (-1);
d233 3
a235 4

		len -= sizeof(tlv);
		buf += sizeof(tlv);
		cons += sizeof(tlv);
@


1.7
log
@Rewrite all packet parsers to be more careful about alignment. Until
now ldpd had no chance to run on a strict alignment architecture but
this makes ldpd happy on sparc64. Be careful to do all needed overflow
checks and try to make all parsing functions look similar.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.6 2010/05/26 13:56:07 nicm Exp $ */
d230 1
a230 1
		cons += sizeof(cons);
@


1.6
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.5 2010/05/19 15:28:51 claudio Exp $ */
d39 4
a42 5
struct hello_prms_tlv	*tlv_decode_hello_prms(char *, u_int16_t);
int			 tlv_decode_opt_hello_prms(char *, u_int16_t,
			    struct in_addr *, u_int32_t *);
int			 gen_hello_prms_tlv(struct iface *, struct ibuf *,
			    u_int16_t);
d84 2
a85 2
	struct ldp_msg		*hello;
	u_int32_t		 messageid;
a86 2
	struct hello_prms_tlv	*cpt;
	struct ldp_hdr		*ldp;
d89 2
d92 1
a92 2
	ldp = (struct ldp_hdr *)buf;

d96 1
a96 7
	hello = (struct ldp_msg *)buf;

	if ((len - TLV_HDR_LEN) < ntohs(hello->length))
		return;

	messageid = hello->msgid;

d100 5
a104 2
	cpt = tlv_decode_hello_prms(buf, len);
	if (cpt == NULL)
d106 1
d108 2
a109 2
	buf += sizeof(struct hello_prms_tlv);
	len -= sizeof(struct hello_prms_tlv);
d111 13
a123 1
	tlv_decode_opt_hello_prms(buf, len, &address, &conf_number);
d125 1
a125 1
	nbr = nbr_find_ldpid(iface, ldp->lsr_id, ldp->lspace_id);
d127 1
a127 1
		nbr = nbr_new(ldp->lsr_id, ldp->lspace_id, iface);
d135 1
a135 1
		nbr->hello_type = cpt->reserved;
d137 1
a137 1
		if (cpt->holdtime == 0) {
d143 1
a143 1
		} else if (cpt->holdtime == INFINITE_HOLDTIME) {
d147 1
a147 1
			if (iface->holdtime < ntohs(cpt->holdtime))
d150 1
a150 1
				nbr->holdtime = ntohs(cpt->holdtime);
d174 1
a174 1
	parms.reserved = 0;
d179 3
a181 2
struct hello_prms_tlv *
tlv_decode_hello_prms(char *buf, u_int16_t len)
d183 1
a183 1
	struct hello_prms_tlv	*tlv;
d185 3
a187 1
	tlv = (struct hello_prms_tlv *)buf;
d189 2
a190 3
	if (len < sizeof(*tlv) || ntohs(tlv->length) !=
	    (sizeof(tlv->holdtime) + sizeof(tlv->reserved)))
		return (NULL);
d192 2
a193 2
	if ((tlv->type & ~UNKNOWN_FLAGS_MASK) != htons(TLV_TYPE_COMMONHELLO))
		return (NULL);
d195 2
a196 2
	if ((tlv->type & UNKNOWN_FLAGS_MASK) != 0)
		return (NULL);
d198 1
a198 1
	return (tlv);
d205 2
a206 1
	struct hello_opt_parms_tlv	*tlv;
d211 2
a212 2
	while (len >= sizeof(*tlv)) {
		tlv = (struct hello_opt_parms_tlv *)buf;
d214 1
a214 1
		if (tlv->length < sizeof(u_int32_t))
d217 1
a217 1
		switch (ntohs(tlv->type)) {
d219 1
a219 1
			addr->s_addr = tlv->value;
d222 1
a222 1
			*conf_number = ntohl(tlv->value);
d228 3
a230 2
		len -= sizeof(*tlv);
		buf += sizeof(*tlv);
d233 1
a233 1
	return (0);
@


1.5
log
@Remove yet another ospf leftover that is not needed here. This time
neighbor self and all the madness surrounding this amazing concept.
LDP is not self aware so there is no need for this.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.4 2010/02/16 21:35:50 michele Exp $ */
d42 1
a42 1
int			 gen_hello_prms_tlv(struct iface *, struct buf *,
d49 1
a49 1
	struct buf		*buf;
d60 1
a60 1
	if ((buf = buf_open(LDP_MAX_LEN)) == NULL)
d77 1
a77 1
	buf_free(buf);
d154 1
a154 1
gen_hello_prms_tlv(struct iface *iface, struct buf *buf, u_int16_t size)
d168 1
a168 1
	return (buf_add(buf, &parms, sizeof(parms)));
@


1.4
log
@Make ldpd less verbose.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.3 2009/12/09 12:19:29 michele Exp $ */
d119 1
a119 1
		nbr = nbr_new(ldp->lsr_id, ldp->lspace_id, iface, 0);
@


1.3
log
@Enable parsing of the optional Transport Address TLV in the hello
message.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.2 2009/06/05 22:34:45 michele Exp $ */
a59 2
	log_debug("send_hello: iface %s", iface->name);

a91 2

	log_debug("recv_hello: neighbor %s", inet_ntoa(src));
@


1.2
log
@Correctly send notification messages when errors occur.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hello.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d40 2
a41 1
int			 tlv_decode_opt_hello_prms(char *, u_int16_t);
d92 2
d119 1
a119 1
	tlv_decode_opt_hello_prms(buf, len);
d126 5
a130 1
		nbr->addr.s_addr = src.s_addr;
d152 1
a152 1
	if (nbr->addr.s_addr < nbr->iface->addr.s_addr &&
d196 2
a197 1
tlv_decode_opt_hello_prms(char *buf, u_int16_t len)
d199 26
a224 1
	/* XXX: todo */
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d101 1
a101 2
	if ((len - TLV_HDR_LEN) < ntohs(hello->length)) {
		/* XXX: send notification */
a102 1
	}
@

