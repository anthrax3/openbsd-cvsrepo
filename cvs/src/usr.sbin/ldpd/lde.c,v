head	1.73;
access;
symbols
	OPENBSD_6_0:1.62.0.2
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.38.0.4
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.73
date	2017.03.04.00.15.35;	author renato;	state Exp;
branches;
next	1.72;
commitid	BOl8emh4A0ljUk3b;

1.72
date	2017.03.04.00.12.26;	author renato;	state Exp;
branches;
next	1.71;
commitid	bHPjS8k63pM8XVeR;

1.71
date	2017.03.04.00.09.17;	author renato;	state Exp;
branches;
next	1.70;
commitid	tAFME29r3wKSl8xr;

1.70
date	2017.03.04.00.03.04;	author renato;	state Exp;
branches;
next	1.69;
commitid	QsrgLdkTVf5ppNUE;

1.69
date	2017.03.03.23.41.27;	author renato;	state Exp;
branches;
next	1.68;
commitid	lvj5kMm2TzZDSXqr;

1.68
date	2017.01.20.12.19.18;	author benno;	state Exp;
branches;
next	1.67;
commitid	qrjsXLNhiS0G91tf;

1.67
date	2016.09.02.17.10.34;	author renato;	state Exp;
branches;
next	1.66;
commitid	azy8IeWn9oiqxwik;

1.66
date	2016.09.02.17.05.23;	author renato;	state Exp;
branches;
next	1.65;
commitid	BTIYKtPuCdvvDUQW;

1.65
date	2016.09.02.17.03.24;	author renato;	state Exp;
branches;
next	1.64;
commitid	oHghF3eNQnFZklxo;

1.64
date	2016.08.08.21.42.13;	author renato;	state Exp;
branches;
next	1.63;
commitid	06qO3EMtrAUwDN60;

1.63
date	2016.08.08.16.45.51;	author renato;	state Exp;
branches;
next	1.62;
commitid	wXIuSV6JZlfbC22E;

1.62
date	2016.07.18.21.10.37;	author benno;	state Exp;
branches;
next	1.61;
commitid	BWYySJ4mItuEVXus;

1.61
date	2016.07.01.23.36.38;	author renato;	state Exp;
branches;
next	1.60;
commitid	h9Qy21EPYXbAFnoh;

1.60
date	2016.07.01.23.33.46;	author renato;	state Exp;
branches;
next	1.59;
commitid	o5yBQ1cPVCcMZ7gA;

1.59
date	2016.06.18.01.25.53;	author renato;	state Exp;
branches;
next	1.58;
commitid	ru2TxJdOjUpe8t8d;

1.58
date	2016.05.23.19.16.00;	author renato;	state Exp;
branches;
next	1.57;
commitid	wKGrbgE7dtbu6ic6;

1.57
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.56;
commitid	TLlfi1Pk0Z97z8HM;

1.56
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.55;
commitid	AQBoOveMRKjtVfFv;

1.55
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.54;
commitid	t07H0Mk6WGdVWB0W;

1.54
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.53;
commitid	D7VvXbswyzx5Ahb2;

1.53
date	2016.05.23.18.55.21;	author renato;	state Exp;
branches;
next	1.52;
commitid	85kONxXVWUqI2Jhb;

1.52
date	2016.05.23.18.46.13;	author renato;	state Exp;
branches;
next	1.51;
commitid	6J1vRySyD703dZ8m;

1.51
date	2016.05.23.18.31.12;	author renato;	state Exp;
branches;
next	1.50;
commitid	nHUSXWKa1vdMbRgF;

1.50
date	2016.05.23.18.28.22;	author renato;	state Exp;
branches;
next	1.49;
commitid	FV8IR5RMrg1EHRis;

1.49
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.48;
commitid	VpAym8dVR6eY4drQ;

1.48
date	2016.05.23.16.54.22;	author renato;	state Exp;
branches;
next	1.47;
commitid	LfWxXXNhiR6poNUS;

1.47
date	2016.05.23.16.50.11;	author renato;	state Exp;
branches;
next	1.46;
commitid	m8Ss6gJrSm004qfC;

1.46
date	2016.05.23.16.43.57;	author renato;	state Exp;
branches;
next	1.45;
commitid	yXgTKNKOaRXeBjel;

1.45
date	2016.05.23.16.20.59;	author renato;	state Exp;
branches;
next	1.44;
commitid	nAtgYzDo97D7UnEI;

1.44
date	2016.05.23.16.14.36;	author renato;	state Exp;
branches;
next	1.43;
commitid	hNzA87VdOHsaOms9;

1.43
date	2016.05.23.16.12.28;	author renato;	state Exp;
branches;
next	1.42;
commitid	vVUYnEJVjv7IWE6u;

1.42
date	2016.05.23.15.47.24;	author renato;	state Exp;
branches;
next	1.41;
commitid	Eng7dm0NElMq9Yi3;

1.41
date	2016.05.23.15.14.07;	author renato;	state Exp;
branches;
next	1.40;
commitid	l3e6PhvoAh8C7elc;

1.40
date	2015.12.05.13.11.48;	author claudio;	state Exp;
branches;
next	1.39;
commitid	c8UgZO1MU5iqaNd3;

1.39
date	2015.10.23.10.10.17;	author renato;	state Exp;
branches;
next	1.38;
commitid	h0sld05bAD8ou8Ag;

1.38
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.37;
commitid	puLLDX1XPNc3GxB9;

1.37
date	2015.07.21.04.48.42;	author renato;	state Exp;
branches;
next	1.36;
commitid	AMGkBBNYB6bWMC2O;

1.36
date	2015.07.21.04.46.51;	author renato;	state Exp;
branches;
next	1.35;
commitid	vYpvRbGMQ79lkA2Y;

1.35
date	2015.07.21.04.45.21;	author renato;	state Exp;
branches;
next	1.34;
commitid	DOwVSvrpKsgJLpe1;

1.34
date	2015.07.21.04.43.28;	author renato;	state Exp;
branches;
next	1.33;
commitid	QaTrdqMa9i0CUoyW;

1.33
date	2015.07.19.20.54.16;	author renato;	state Exp;
branches;
next	1.32;
commitid	AcGJH529uphBS2D2;

1.32
date	2015.07.19.20.50.03;	author renato;	state Exp;
branches;
next	1.31;
commitid	HQ4RevpYoLNvLRj2;

1.31
date	2015.07.19.18.34.32;	author renato;	state Exp;
branches;
next	1.30;
commitid	KRfbPnwCvwQrLOu3;

1.30
date	2015.03.21.18.34.01;	author renato;	state Exp;
branches;
next	1.29;
commitid	cFXa8ucj1hCSVYz6;

1.29
date	2014.07.12.20.16.38;	author krw;	state Exp;
branches;
next	1.28;
commitid	lIxCxHhVEpsmXOdi;

1.28
date	2013.11.26.11.59.38;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2013.10.15.20.36.30;	author renato;	state Exp;
branches;
next	1.26;

1.26
date	2013.10.15.20.34.02;	author renato;	state Exp;
branches;
next	1.25;

1.25
date	2013.10.15.20.21.25;	author renato;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.04.00.45.00;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2013.06.03.17.01.59;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2010.10.26.12.08.14;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2010.10.21.08.24.06;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.30.22.15.02;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.30.05.21.38;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.30.01.47.11;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.09.13.32.15;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.07.13.24.23;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.02.11.56.29;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.25.13.29.45;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.25.09.35.45;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.19.15.28.51;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.11.15.01.46;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.03.10.17.05;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2010.03.01.09.05.07;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.19.12.49.21;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.02.20.34.58;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.28.09.48.46;	author michele;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.01.13.30.55;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.08.18.59.29;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.06.08.09.43;	author pyr;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.22.34.45;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.73
log
@Implement RFC 5919 (LDP End-of-LIB).
@
text
@/*	$OpenBSD: lde.c,v 1.72 2017/03/04 00:12:26 renato Exp $ */

/*
 * Copyright (c) 2013, 2016 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2004, 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netmpls/mpls.h>
#include <arpa/inet.h>
#include <errno.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <pwd.h>
#include <unistd.h>
#include <limits.h>

#include "ldp.h"
#include "ldpd.h"
#include "ldpe.h"
#include "log.h"
#include "lde.h"

static void		 lde_sig_handler(int sig, short, void *);
static __dead void	 lde_shutdown(void);
static int		 lde_imsg_compose_parent(int, pid_t, void *, uint16_t);
static void		 lde_dispatch_imsg(int, short, void *);
static void		 lde_dispatch_parent(int, short, void *);
static __inline	int	 lde_nbr_compare(struct lde_nbr *,
			    struct lde_nbr *);
static struct lde_nbr	*lde_nbr_new(uint32_t, struct lde_nbr *);
static void		 lde_nbr_del(struct lde_nbr *);
static struct lde_nbr	*lde_nbr_find(uint32_t);
static void		 lde_nbr_clear(void);
static void		 lde_nbr_addr_update(struct lde_nbr *,
			    struct lde_addr *, int);
static void		 lde_map_free(void *);
static int		 lde_address_add(struct lde_nbr *, struct lde_addr *);
static int		 lde_address_del(struct lde_nbr *, struct lde_addr *);
static void		 lde_address_list_free(struct lde_nbr *);

RB_GENERATE(nbr_tree, lde_nbr, entry, lde_nbr_compare)

struct ldpd_conf	*ldeconf;
struct nbr_tree		 lde_nbrs = RB_INITIALIZER(&lde_nbrs);

static struct imsgev	*iev_ldpe;
static struct imsgev	*iev_main;

/* ARGSUSED */
static void
lde_sig_handler(int sig, short event, void *arg)
{
	/*
	 * signal handler rules don't apply, libevent decouples for us
	 */

	switch (sig) {
	case SIGINT:
	case SIGTERM:
		lde_shutdown();
		/* NOTREACHED */
	default:
		fatalx("unexpected signal");
	}
}

/* label decision engine */
void
lde(int debug, int verbose)
{
	struct event		 ev_sigint, ev_sigterm;
	struct timeval		 now;
	struct passwd		*pw;

	ldeconf = config_new_empty();

	log_init(debug);
	log_verbose(verbose);

	setproctitle("label decision engine");
	ldpd_process = PROC_LDE_ENGINE;
	log_procname = log_procnames[PROC_LDE_ENGINE];

	if ((pw = getpwnam(LDPD_USER)) == NULL)
		fatal("getpwnam");

	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	if (pledge("stdio recvfd", NULL) == -1)
		fatal("pledge");

	event_init();

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, lde_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, lde_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	/* setup pipe and event handler to the parent process */
	if ((iev_main = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_main->ibuf, 3);
	iev_main->handler = lde_dispatch_parent;
	iev_main->events = EV_READ;
	event_set(&iev_main->ev, iev_main->ibuf.fd, iev_main->events,
	    iev_main->handler, iev_main);
	event_add(&iev_main->ev, NULL);

	/* setup and start the LIB garbage collector */
	evtimer_set(&gc_timer, lde_gc_timer, NULL);
	lde_gc_start_timer();

	gettimeofday(&now, NULL);
	global.uptime = now.tv_sec;

	event_dispatch();

	lde_shutdown();
}

static __dead void
lde_shutdown(void)
{
	/* close pipes */
	msgbuf_clear(&iev_ldpe->ibuf.w);
	close(iev_ldpe->ibuf.fd);
	msgbuf_clear(&iev_main->ibuf.w);
	close(iev_main->ibuf.fd);

	lde_gc_stop_timer();
	lde_nbr_clear();
	fec_tree_clear();

	config_clear(ldeconf);

	free(iev_ldpe);
	free(iev_main);

	log_info("label decision engine exiting");
	exit(0);
}

/* imesg */
static int
lde_imsg_compose_parent(int type, pid_t pid, void *data, uint16_t datalen)
{
	return (imsg_compose_event(iev_main, type, 0, pid, -1, data, datalen));
}

int
lde_imsg_compose_ldpe(int type, uint32_t peerid, pid_t pid, void *data,
    uint16_t datalen)
{
	return (imsg_compose_event(iev_ldpe, type, peerid, pid,
	     -1, data, datalen));
}

/* ARGSUSED */
static void
lde_dispatch_imsg(int fd, short event, void *bula)
{
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct imsg		 imsg;
	struct lde_nbr		*ln;
	struct map		 map;
	struct lde_addr		 lde_addr;
	struct notify_msg	 nm;
	ssize_t			 n;
	int			 shut = 0, verbose;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("lde_dispatch_imsg: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_LABEL_MAPPING_FULL:
			ln = lde_nbr_find(imsg.hdr.peerid);
			if (ln == NULL) {
				log_debug("%s: cannot find lde neighbor",
				    __func__);
				break;
			}

			fec_snap(ln);
			break;
		case IMSG_LABEL_MAPPING:
		case IMSG_LABEL_REQUEST:
		case IMSG_LABEL_RELEASE:
		case IMSG_LABEL_WITHDRAW:
		case IMSG_LABEL_ABORT:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(map))
				fatalx("lde_dispatch_imsg: wrong imsg len");
			memcpy(&map, imsg.data, sizeof(map));

			ln = lde_nbr_find(imsg.hdr.peerid);
			if (ln == NULL) {
				log_debug("%s: cannot find lde neighbor",
				    __func__);
				break;
			}

			switch (imsg.hdr.type) {
			case IMSG_LABEL_MAPPING:
				lde_check_mapping(&map, ln);
				break;
			case IMSG_LABEL_REQUEST:
				lde_check_request(&map, ln);
				break;
			case IMSG_LABEL_RELEASE:
				lde_check_release(&map, ln);
				break;
			case IMSG_LABEL_WITHDRAW:
				lde_check_withdraw(&map, ln);
				break;
			case IMSG_LABEL_ABORT:
				/* not necessary */
				break;
			}
			break;
		case IMSG_ADDRESS_ADD:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(lde_addr))
				fatalx("lde_dispatch_imsg: wrong imsg len");
			memcpy(&lde_addr, imsg.data, sizeof(lde_addr));

			ln = lde_nbr_find(imsg.hdr.peerid);
			if (ln == NULL) {
				log_debug("%s: cannot find lde neighbor",
				    __func__);
				break;
			}
			if (lde_address_add(ln, &lde_addr) < 0) {
				log_debug("%s: cannot add address %s, it "
				    "already exists", __func__,
				    log_addr(lde_addr.af, &lde_addr.addr));
			}
			break;
		case IMSG_ADDRESS_DEL:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(lde_addr))
				fatalx("lde_dispatch_imsg: wrong imsg len");
			memcpy(&lde_addr, imsg.data, sizeof(lde_addr));

			ln = lde_nbr_find(imsg.hdr.peerid);
			if (ln == NULL) {
				log_debug("%s: cannot find lde neighbor",
				    __func__);
				break;
			}
			if (lde_address_del(ln, &lde_addr) < 0) {
				log_debug("%s: cannot delete address %s, it "
				    "does not exist", __func__,
				    log_addr(lde_addr.af, &lde_addr.addr));
			}
			break;
		case IMSG_NOTIFICATION:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(nm))
				fatalx("lde_dispatch_imsg: wrong imsg len");
			memcpy(&nm, imsg.data, sizeof(nm));

			ln = lde_nbr_find(imsg.hdr.peerid);
			if (ln == NULL) {
				log_debug("%s: cannot find lde neighbor",
				    __func__);
				break;
			}

			switch (nm.status_code) {
			case S_PW_STATUS:
				l2vpn_recv_pw_status(ln, &nm);
				break;
			case S_ENDOFLIB:
				/*
				 * Do nothing for now. Should be useful in
				 * the future when we implement LDP-IGP
				 * Synchronization (RFC 5443) and Graceful
				 * Restart (RFC 3478).
				 */
			default:
				break;
			}
			break;
		case IMSG_NEIGHBOR_UP:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct lde_nbr))
				fatalx("lde_dispatch_imsg: wrong imsg len");

			if (lde_nbr_find(imsg.hdr.peerid))
				fatalx("lde_dispatch_imsg: "
				    "neighbor already exists");
			lde_nbr_new(imsg.hdr.peerid, imsg.data);
			break;
		case IMSG_NEIGHBOR_DOWN:
			lde_nbr_del(lde_nbr_find(imsg.hdr.peerid));
			break;
		case IMSG_CTL_SHOW_LIB:
			rt_dump(imsg.hdr.pid);

			lde_imsg_compose_ldpe(IMSG_CTL_END, 0,
			    imsg.hdr.pid, NULL, 0);
			break;
		case IMSG_CTL_SHOW_L2VPN_PW:
			l2vpn_pw_ctl(imsg.hdr.pid);

			lde_imsg_compose_ldpe(IMSG_CTL_END, 0,
			    imsg.hdr.pid, NULL, 0);
			break;
		case IMSG_CTL_SHOW_L2VPN_BINDING:
			l2vpn_binding_ctl(imsg.hdr.pid);

			lde_imsg_compose_ldpe(IMSG_CTL_END, 0,
			    imsg.hdr.pid, NULL, 0);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			/* already checked by ldpe */
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		default:
			log_debug("%s: unexpected imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
static void
lde_dispatch_parent(int fd, short event, void *bula)
{
	static struct ldpd_conf	*nconf;
	struct iface		*niface;
	struct tnbr		*ntnbr;
	struct nbr_params	*nnbrp;
	static struct l2vpn	*nl2vpn;
	struct l2vpn_if		*nlif;
	struct l2vpn_pw		*npw;
	struct imsg		 imsg;
	struct kroute		 kr;
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	ssize_t			 n;
	int			 shut = 0;
	struct fec		 fec;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("lde_dispatch_parent: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_NETWORK_ADD:
		case IMSG_NETWORK_DEL:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(kr)) {
				log_warnx("%s: wrong imsg len", __func__);
				break;
			}
			memcpy(&kr, imsg.data, sizeof(kr));

			switch (kr.af) {
			case AF_INET:
				fec.type = FEC_TYPE_IPV4;
				fec.u.ipv4.prefix = kr.prefix.v4;
				fec.u.ipv4.prefixlen = kr.prefixlen;
				break;
			case AF_INET6:
				fec.type = FEC_TYPE_IPV6;
				fec.u.ipv6.prefix = kr.prefix.v6;
				fec.u.ipv6.prefixlen = kr.prefixlen;
				break;
			default:
				fatalx("lde_dispatch_parent: unknown af");
			}

			switch (imsg.hdr.type) {
			case IMSG_NETWORK_ADD:
				lde_kernel_insert(&fec, kr.af, &kr.nexthop,
				    kr.priority, kr.flags & F_CONNECTED, NULL);
				break;
			case IMSG_NETWORK_DEL:
				lde_kernel_remove(&fec, kr.af, &kr.nexthop,
				    kr.priority);
				break;
			}
			break;
		case IMSG_SOCKET_IPC:
			if (iev_ldpe) {
				log_warnx("%s: received unexpected imsg fd "
				    "to ldpe", __func__);
				break;
			}
			if ((fd = imsg.fd) == -1) {
				log_warnx("%s: expected to receive imsg fd to "
				    "ldpe but didn't receive any", __func__);
				break;
			}

			if ((iev_ldpe = malloc(sizeof(struct imsgev))) == NULL)
				fatal(NULL);
			imsg_init(&iev_ldpe->ibuf, fd);
			iev_ldpe->handler = lde_dispatch_imsg;
			iev_ldpe->events = EV_READ;
			event_set(&iev_ldpe->ev, iev_ldpe->ibuf.fd,
			    iev_ldpe->events, iev_ldpe->handler, iev_ldpe);
			event_add(&iev_ldpe->ev, NULL);
			break;
		case IMSG_RECONF_CONF:
			if ((nconf = malloc(sizeof(struct ldpd_conf))) ==
			    NULL)
				fatal(NULL);
			memcpy(nconf, imsg.data, sizeof(struct ldpd_conf));

			LIST_INIT(&nconf->iface_list);
			LIST_INIT(&nconf->tnbr_list);
			LIST_INIT(&nconf->nbrp_list);
			LIST_INIT(&nconf->l2vpn_list);
			break;
		case IMSG_RECONF_IFACE:
			if ((niface = malloc(sizeof(struct iface))) == NULL)
				fatal(NULL);
			memcpy(niface, imsg.data, sizeof(struct iface));

			LIST_INIT(&niface->addr_list);
			LIST_INIT(&niface->ipv4.adj_list);
			LIST_INIT(&niface->ipv6.adj_list);
			niface->ipv4.iface = niface;
			niface->ipv6.iface = niface;

			LIST_INSERT_HEAD(&nconf->iface_list, niface, entry);
			break;
		case IMSG_RECONF_TNBR:
			if ((ntnbr = malloc(sizeof(struct tnbr))) == NULL)
				fatal(NULL);
			memcpy(ntnbr, imsg.data, sizeof(struct tnbr));

			LIST_INSERT_HEAD(&nconf->tnbr_list, ntnbr, entry);
			break;
		case IMSG_RECONF_NBRP:
			if ((nnbrp = malloc(sizeof(struct nbr_params))) == NULL)
				fatal(NULL);
			memcpy(nnbrp, imsg.data, sizeof(struct nbr_params));

			LIST_INSERT_HEAD(&nconf->nbrp_list, nnbrp, entry);
			break;
		case IMSG_RECONF_L2VPN:
			if ((nl2vpn = malloc(sizeof(struct l2vpn))) == NULL)
				fatal(NULL);
			memcpy(nl2vpn, imsg.data, sizeof(struct l2vpn));

			LIST_INIT(&nl2vpn->if_list);
			LIST_INIT(&nl2vpn->pw_list);

			LIST_INSERT_HEAD(&nconf->l2vpn_list, nl2vpn, entry);
			break;
		case IMSG_RECONF_L2VPN_IF:
			if ((nlif = malloc(sizeof(struct l2vpn_if))) == NULL)
				fatal(NULL);
			memcpy(nlif, imsg.data, sizeof(struct l2vpn_if));

			nlif->l2vpn = nl2vpn;
			LIST_INSERT_HEAD(&nl2vpn->if_list, nlif, entry);
			break;
		case IMSG_RECONF_L2VPN_PW:
			if ((npw = malloc(sizeof(struct l2vpn_pw))) == NULL)
				fatal(NULL);
			memcpy(npw, imsg.data, sizeof(struct l2vpn_pw));

			npw->l2vpn = nl2vpn;
			LIST_INSERT_HEAD(&nl2vpn->pw_list, npw, entry);
			break;
		case IMSG_RECONF_END:
			merge_config(ldeconf, nconf);
			nconf = NULL;
			break;
		default:
			log_debug("%s: unexpected imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

uint32_t
lde_assign_label(void)
{
	static uint32_t label = MPLS_LABEL_RESERVED_MAX;

	/* XXX some checks needed */
	label++;
	return (label);
}

void
lde_send_change_klabel(struct fec_node *fn, struct fec_nh *fnh)
{
	struct kroute	kr;
	struct kpw	kpw;
	struct l2vpn_pw	*pw;

	switch (fn->fec.type) {
	case FEC_TYPE_IPV4:
		memset(&kr, 0, sizeof(kr));
		kr.af = AF_INET;
		kr.prefix.v4 = fn->fec.u.ipv4.prefix;
		kr.prefixlen = fn->fec.u.ipv4.prefixlen;
		kr.nexthop.v4 = fnh->nexthop.v4;
		kr.local_label = fn->local_label;
		kr.remote_label = fnh->remote_label;
		kr.priority = fnh->priority;

		lde_imsg_compose_parent(IMSG_KLABEL_CHANGE, 0, &kr,
		    sizeof(kr));

		if (fn->fec.u.ipv4.prefixlen == 32)
			l2vpn_sync_pws(AF_INET, (union ldpd_addr *)
			    &fn->fec.u.ipv4.prefix);
		break;
	case FEC_TYPE_IPV6:
		memset(&kr, 0, sizeof(kr));
		kr.af = AF_INET6;
		kr.prefix.v6 = fn->fec.u.ipv6.prefix;
		kr.prefixlen = fn->fec.u.ipv6.prefixlen;
		kr.nexthop.v6 = fnh->nexthop.v6;
		kr.local_label = fn->local_label;
		kr.remote_label = fnh->remote_label;
		kr.priority = fnh->priority;

		lde_imsg_compose_parent(IMSG_KLABEL_CHANGE, 0, &kr,
		    sizeof(kr));

		if (fn->fec.u.ipv6.prefixlen == 128)
			l2vpn_sync_pws(AF_INET6, (union ldpd_addr *)
			    &fn->fec.u.ipv6.prefix);
		break;
	case FEC_TYPE_PWID:
		if (fn->local_label == NO_LABEL ||
		    fnh->remote_label == NO_LABEL)
			return;

		pw = (struct l2vpn_pw *) fn->data;
		pw->flags |= F_PW_STATUS_UP;

		memset(&kpw, 0, sizeof(kpw));
		kpw.ifindex = pw->ifindex;
		kpw.pw_type = fn->fec.u.pwid.type;
		kpw.af = pw->af;
		kpw.nexthop = pw->addr;
		kpw.local_label = fn->local_label;
		kpw.remote_label = fnh->remote_label;
		kpw.flags = pw->flags;

		lde_imsg_compose_parent(IMSG_KPWLABEL_CHANGE, 0, &kpw,
		    sizeof(kpw));
		break;
	}
}

void
lde_send_delete_klabel(struct fec_node *fn, struct fec_nh *fnh)
{
	struct kroute	 kr;
	struct kpw	 kpw;
	struct l2vpn_pw	*pw;

	switch (fn->fec.type) {
	case FEC_TYPE_IPV4:
		memset(&kr, 0, sizeof(kr));
		kr.af = AF_INET;
		kr.prefix.v4 = fn->fec.u.ipv4.prefix;
		kr.prefixlen = fn->fec.u.ipv4.prefixlen;
		kr.nexthop.v4 = fnh->nexthop.v4;
		kr.local_label = fn->local_label;
		kr.remote_label = fnh->remote_label;
		kr.priority = fnh->priority;

		lde_imsg_compose_parent(IMSG_KLABEL_DELETE, 0, &kr,
		    sizeof(kr));

		if (fn->fec.u.ipv4.prefixlen == 32)
			l2vpn_sync_pws(AF_INET, (union ldpd_addr *)
			    &fn->fec.u.ipv4.prefix);
		break;
	case FEC_TYPE_IPV6:
		memset(&kr, 0, sizeof(kr));
		kr.af = AF_INET6;
		kr.prefix.v6 = fn->fec.u.ipv6.prefix;
		kr.prefixlen = fn->fec.u.ipv6.prefixlen;
		kr.nexthop.v6 = fnh->nexthop.v6;
		kr.local_label = fn->local_label;
		kr.remote_label = fnh->remote_label;
		kr.priority = fnh->priority;

		lde_imsg_compose_parent(IMSG_KLABEL_DELETE, 0, &kr,
		    sizeof(kr));

		if (fn->fec.u.ipv6.prefixlen == 128)
			l2vpn_sync_pws(AF_INET6, (union ldpd_addr *)
			    &fn->fec.u.ipv6.prefix);
		break;
	case FEC_TYPE_PWID:
		pw = (struct l2vpn_pw *) fn->data;
		if (!(pw->flags & F_PW_STATUS_UP))
			return;
		pw->flags &= ~F_PW_STATUS_UP;

		memset(&kpw, 0, sizeof(kpw));
		kpw.ifindex = pw->ifindex;
		kpw.pw_type = fn->fec.u.pwid.type;
		kpw.af = pw->af;
		kpw.nexthop = pw->addr;
		kpw.local_label = fn->local_label;
		kpw.remote_label = fnh->remote_label;
		kpw.flags = pw->flags;

		lde_imsg_compose_parent(IMSG_KPWLABEL_DELETE, 0, &kpw,
		    sizeof(kpw));
		break;
	}
}

void
lde_fec2map(struct fec *fec, struct map *map)
{
	memset(map, 0, sizeof(*map));

	switch (fec->type) {
	case FEC_TYPE_IPV4:
		map->type = MAP_TYPE_PREFIX;
		map->fec.prefix.af = AF_INET;
		map->fec.prefix.prefix.v4 = fec->u.ipv4.prefix;
		map->fec.prefix.prefixlen = fec->u.ipv4.prefixlen;
		break;
	case FEC_TYPE_IPV6:
		map->type = MAP_TYPE_PREFIX;
		map->fec.prefix.af = AF_INET6;
		map->fec.prefix.prefix.v6 = fec->u.ipv6.prefix;
		map->fec.prefix.prefixlen = fec->u.ipv6.prefixlen;
		break;
	case FEC_TYPE_PWID:
		map->type = MAP_TYPE_PWID;
		map->fec.pwid.type = fec->u.pwid.type;
		map->fec.pwid.group_id = 0;
		map->flags |= F_MAP_PW_ID;
		map->fec.pwid.pwid = fec->u.pwid.pwid;
		break;
	}
}

void
lde_map2fec(struct map *map, struct in_addr lsr_id, struct fec *fec)
{
	memset(fec, 0, sizeof(*fec));

	switch (map->type) {
	case MAP_TYPE_PREFIX:
		switch (map->fec.prefix.af) {
		case AF_INET:
			fec->type = FEC_TYPE_IPV4;
			fec->u.ipv4.prefix = map->fec.prefix.prefix.v4;
			fec->u.ipv4.prefixlen = map->fec.prefix.prefixlen;
			break;
		case AF_INET6:
			fec->type = FEC_TYPE_IPV6;
			fec->u.ipv6.prefix = map->fec.prefix.prefix.v6;
			fec->u.ipv6.prefixlen = map->fec.prefix.prefixlen;
			break;
		default:
			fatalx("lde_map2fec: unknown af");
			break;
		}
		break;
	case MAP_TYPE_PWID:
		fec->type = FEC_TYPE_PWID;
		fec->u.pwid.type = map->fec.pwid.type;
		fec->u.pwid.pwid = map->fec.pwid.pwid;
		fec->u.pwid.lsr_id = lsr_id;
		break;
	}
}

void
lde_send_labelmapping(struct lde_nbr *ln, struct fec_node *fn, int single)
{
	struct lde_req	*lre;
	struct lde_map	*me;
	struct map	 map;
	struct l2vpn_pw	*pw;

	/*
	 * This function skips SL.1 - 3 and SL.9 - 14 because the label
	 * allocation is done way earlier (because of the merging nature of
	 * ldpd).
	 */

	lde_fec2map(&fn->fec, &map);
	switch (fn->fec.type) {
	case FEC_TYPE_IPV4:
		if (!ln->v4_enabled)
			return;
		break;
	case FEC_TYPE_IPV6:
		if (!ln->v6_enabled)
			return;
		break;
	case FEC_TYPE_PWID:
		pw = (struct l2vpn_pw *) fn->data;
		if (pw == NULL || pw->lsr_id.s_addr != ln->id.s_addr)
			/* not the remote end of the pseudowire */
			return;

		map.flags |= F_MAP_PW_IFMTU;
		map.fec.pwid.ifmtu = pw->l2vpn->mtu;
		if (pw->flags & F_PW_CWORD)
			map.flags |= F_MAP_PW_CWORD;
		if (pw->flags & F_PW_STATUSTLV) {
			map.flags |= F_MAP_PW_STATUS;
			/* VPLS are always up */
			map.pw_status = PW_FORWARDING;
		}
		break;
	}
	map.label = fn->local_label;

	/* SL.6: is there a pending request for this mapping? */
	lre = (struct lde_req *)fec_find(&ln->recv_req, &fn->fec);
	if (lre) {
		/* set label request msg id in the mapping response. */
		map.requestid = lre->msg_id;
		map.flags = F_MAP_REQ_ID;

		/* SL.7: delete record of pending request */
		lde_req_del(ln, lre, 0);
	}

	/* SL.4: send label mapping */
	lde_imsg_compose_ldpe(IMSG_MAPPING_ADD, ln->peerid, 0,
	    &map, sizeof(map));
	if (single)
		lde_imsg_compose_ldpe(IMSG_MAPPING_ADD_END, ln->peerid, 0,
		    NULL, 0);

	/* SL.5: record sent label mapping */
	me = (struct lde_map *)fec_find(&ln->sent_map, &fn->fec);
	if (me == NULL)
		me = lde_map_add(ln, fn, 1);
	me->map = map;
}

void
lde_send_labelwithdraw(struct lde_nbr *ln, struct fec_node *fn,
    struct map *wcard, struct status_tlv *st)
{
	struct lde_wdraw	*lw;
	struct map		 map;
	struct fec		*f;
	struct l2vpn_pw		*pw;

	if (fn) {
		lde_fec2map(&fn->fec, &map);
		switch (fn->fec.type) {
		case FEC_TYPE_IPV4:
			if (!ln->v4_enabled)
				return;
			break;
		case FEC_TYPE_IPV6:
			if (!ln->v6_enabled)
				return;
			break;
		case FEC_TYPE_PWID:
			pw = (struct l2vpn_pw *) fn->data;
			if (pw == NULL || pw->lsr_id.s_addr != ln->id.s_addr)
				/* not the remote end of the pseudowire */
				return;

			if (pw->flags & F_PW_CWORD)
				map.flags |= F_MAP_PW_CWORD;
			break;
		}
		map.label = fn->local_label;
	} else
		memcpy(&map, wcard, sizeof(map));

	if (st) {
		map.st.status_code = st->status_code;
		map.st.msg_id = st->msg_id;
		map.st.msg_type = st->msg_type;
		map.flags |= F_MAP_STATUS;
	}

	/* SWd.1: send label withdraw. */
	lde_imsg_compose_ldpe(IMSG_WITHDRAW_ADD, ln->peerid, 0,
 	    &map, sizeof(map));
	lde_imsg_compose_ldpe(IMSG_WITHDRAW_ADD_END, ln->peerid, 0, NULL, 0);

	/* SWd.2: record label withdraw. */
	if (fn) {
		lw = (struct lde_wdraw *)fec_find(&ln->sent_wdraw, &fn->fec);
		if (lw == NULL)
			lw = lde_wdraw_add(ln, fn);
		lw->label = map.label;
	} else {
		struct lde_map *me;

		RB_FOREACH(f, fec_tree, &ft) {
			fn = (struct fec_node *)f;
			me = (struct lde_map *)fec_find(&ln->sent_map, &fn->fec);
			if (lde_wildcard_apply(wcard, &fn->fec, me) == 0)
				continue;

			lw = (struct lde_wdraw *)fec_find(&ln->sent_wdraw,
			    &fn->fec);
			if (lw == NULL)
				lw = lde_wdraw_add(ln, fn);
			lw->label = map.label;
		}
	}
}

void
lde_send_labelwithdraw_wcard(struct lde_nbr *ln, uint32_t label)
{
	struct map	 wcard;

	memset(&wcard, 0, sizeof(wcard));
	wcard.type = MAP_TYPE_WILDCARD;
	wcard.label = label;
	lde_send_labelwithdraw(ln, NULL, &wcard, NULL);
}

void
lde_send_labelwithdraw_twcard_prefix(struct lde_nbr *ln, uint16_t af,
    uint32_t label)
{
	struct map	 wcard;

	memset(&wcard, 0, sizeof(wcard));
	wcard.type = MAP_TYPE_TYPED_WCARD;
	wcard.fec.twcard.type = MAP_TYPE_PREFIX;
	wcard.fec.twcard.u.prefix_af = af;
	wcard.label = label;
	lde_send_labelwithdraw(ln, NULL, &wcard, NULL);
}

void
lde_send_labelwithdraw_twcard_pwid(struct lde_nbr *ln, uint16_t pw_type,
    uint32_t label)
{
	struct map	 wcard;

	memset(&wcard, 0, sizeof(wcard));
	wcard.type = MAP_TYPE_TYPED_WCARD;
	wcard.fec.twcard.type = MAP_TYPE_PWID;
	wcard.fec.twcard.u.pw_type = pw_type;
	wcard.label = label;
	lde_send_labelwithdraw(ln, NULL, &wcard, NULL);
}

void
lde_send_labelwithdraw_pwid_wcard(struct lde_nbr *ln, uint16_t pw_type,
    uint32_t group_id)
{
	struct map	 wcard;

	memset(&wcard, 0, sizeof(wcard));
	wcard.type = MAP_TYPE_PWID;
	wcard.fec.pwid.type = pw_type;
	wcard.fec.pwid.group_id = group_id;
	/* we can not append a Label TLV when using PWid group wildcards. */
	wcard.label = NO_LABEL;
	lde_send_labelwithdraw(ln, NULL, &wcard, NULL);
}

void
lde_send_labelrelease(struct lde_nbr *ln, struct fec_node *fn,
    struct map *wcard, uint32_t label)
{
	struct map		 map;
	struct l2vpn_pw		*pw;

	if (fn) {
		lde_fec2map(&fn->fec, &map);
		switch (fn->fec.type) {
		case FEC_TYPE_IPV4:
			if (!ln->v4_enabled)
				return;
			break;
		case FEC_TYPE_IPV6:
			if (!ln->v6_enabled)
				return;
			break;
		case FEC_TYPE_PWID:
			pw = (struct l2vpn_pw *) fn->data;
			if (pw == NULL || pw->lsr_id.s_addr != ln->id.s_addr)
				/* not the remote end of the pseudowire */
				return;

			if (pw->flags & F_PW_CWORD)
				map.flags |= F_MAP_PW_CWORD;
			break;
		}
	} else
		memcpy(&map, wcard, sizeof(map));
	map.label = label;

	lde_imsg_compose_ldpe(IMSG_RELEASE_ADD, ln->peerid, 0,
	    &map, sizeof(map));
	lde_imsg_compose_ldpe(IMSG_RELEASE_ADD_END, ln->peerid, 0, NULL, 0);
}

void
lde_send_notification(struct lde_nbr *ln, uint32_t status_code, uint32_t msg_id,
    uint16_t msg_type)
{
	struct notify_msg nm;

	memset(&nm, 0, sizeof(nm));
	nm.status_code = status_code;
	/* 'msg_id' and 'msg_type' should be in network byte order */
	nm.msg_id = msg_id;
	nm.msg_type = msg_type;

	lde_imsg_compose_ldpe(IMSG_NOTIFICATION_SEND, ln->peerid, 0,
	    &nm, sizeof(nm));
}

void
lde_send_notification_eol_prefix(struct lde_nbr *ln, int af)
{
	struct notify_msg nm;

	memset(&nm, 0, sizeof(nm));
	nm.status_code = S_ENDOFLIB;
	nm.fec.type = MAP_TYPE_TYPED_WCARD;
	nm.fec.fec.twcard.type = MAP_TYPE_PREFIX;
	nm.fec.fec.twcard.u.prefix_af = af;
	nm.flags |= F_NOTIF_FEC;

	lde_imsg_compose_ldpe(IMSG_NOTIFICATION_SEND, ln->peerid, 0,
	    &nm, sizeof(nm));
}

void
lde_send_notification_eol_pwid(struct lde_nbr *ln, uint16_t pw_type)
{
	struct notify_msg nm;

	memset(&nm, 0, sizeof(nm));
	nm.status_code = S_ENDOFLIB;
	nm.fec.type = MAP_TYPE_TYPED_WCARD;
	nm.fec.fec.twcard.type = MAP_TYPE_PWID;
	nm.fec.fec.twcard.u.pw_type = pw_type;
	nm.flags |= F_NOTIF_FEC;

	lde_imsg_compose_ldpe(IMSG_NOTIFICATION_SEND, ln->peerid, 0,
	    &nm, sizeof(nm));
}

static __inline int
lde_nbr_compare(struct lde_nbr *a, struct lde_nbr *b)
{
	return (a->peerid - b->peerid);
}

static struct lde_nbr *
lde_nbr_new(uint32_t peerid, struct lde_nbr *new)
{
	struct lde_nbr	*ln;

	if ((ln = calloc(1, sizeof(*ln))) == NULL)
		fatal(__func__);

	ln->id = new->id;
	ln->v4_enabled = new->v4_enabled;
	ln->v6_enabled = new->v6_enabled;
	ln->flags = new->flags;
	ln->peerid = peerid;
	fec_init(&ln->recv_map);
	fec_init(&ln->sent_map);
	fec_init(&ln->recv_req);
	fec_init(&ln->sent_req);
	fec_init(&ln->sent_wdraw);

	TAILQ_INIT(&ln->addr_list);

	if (RB_INSERT(nbr_tree, &lde_nbrs, ln) != NULL)
		fatalx("lde_nbr_new: RB_INSERT failed");

	return (ln);
}

static void
lde_nbr_del(struct lde_nbr *ln)
{
	struct fec		*f;
	struct fec_node		*fn;
	struct fec_nh		*fnh;
	struct l2vpn_pw		*pw;

	if (ln == NULL)
		return;

	/* uninstall received mappings */
	RB_FOREACH(f, fec_tree, &ft) {
		fn = (struct fec_node *)f;

		LIST_FOREACH(fnh, &fn->nexthops, entry) {
			switch (f->type) {
			case FEC_TYPE_IPV4:
			case FEC_TYPE_IPV6:
				if (!lde_address_find(ln, fnh->af,
				    &fnh->nexthop))
					continue;
				break;
			case FEC_TYPE_PWID:
				if (f->u.pwid.lsr_id.s_addr != ln->id.s_addr)
					continue;
				pw = (struct l2vpn_pw *) fn->data;
				if (pw)
					l2vpn_pw_reset(pw);
				break;
			default:
				break;
			}

			lde_send_delete_klabel(fn, fnh);
			fnh->remote_label = NO_LABEL;
		}
	}

	lde_address_list_free(ln);

	fec_clear(&ln->recv_map, lde_map_free);
	fec_clear(&ln->sent_map, lde_map_free);
	fec_clear(&ln->recv_req, free);
	fec_clear(&ln->sent_req, free);
	fec_clear(&ln->sent_wdraw, free);

	RB_REMOVE(nbr_tree, &lde_nbrs, ln);

	free(ln);
}

static struct lde_nbr *
lde_nbr_find(uint32_t peerid)
{
	struct lde_nbr		 ln;

	ln.peerid = peerid;

	return (RB_FIND(nbr_tree, &lde_nbrs, &ln));
}

struct lde_nbr *
lde_nbr_find_by_lsrid(struct in_addr addr)
{
	struct lde_nbr		*ln;

	RB_FOREACH(ln, nbr_tree, &lde_nbrs)
		if (ln->id.s_addr == addr.s_addr)
			return (ln);

	return (NULL);
}

struct lde_nbr *
lde_nbr_find_by_addr(int af, union ldpd_addr *addr)
{
	struct lde_nbr		*ln;

	RB_FOREACH(ln, nbr_tree, &lde_nbrs)
		if (lde_address_find(ln, af, addr) != NULL)
			return (ln);

	return (NULL);
}

static void
lde_nbr_clear(void)
{
	struct lde_nbr	*ln;

	 while ((ln = RB_ROOT(&lde_nbrs)) != NULL)
		lde_nbr_del(ln);
}

static void
lde_nbr_addr_update(struct lde_nbr *ln, struct lde_addr *lde_addr, int removed)
{
	struct fec		*fec;
	struct fec_node		*fn;
	struct fec_nh		*fnh;
	struct lde_map		*me;

	RB_FOREACH(fec, fec_tree, &ln->recv_map) {
		fn = (struct fec_node *)fec_find(&ft, fec);
		switch (fec->type) {
		case FEC_TYPE_IPV4:
			if (lde_addr->af != AF_INET)
				continue;
			break;
		case FEC_TYPE_IPV6:
			if (lde_addr->af != AF_INET6)
				continue;
			break;
		default:
			continue;
		}

		LIST_FOREACH(fnh, &fn->nexthops, entry) {
			if (ldp_addrcmp(fnh->af, &fnh->nexthop,
			    &lde_addr->addr))
				continue;

			if (removed) {
				lde_send_delete_klabel(fn, fnh);
				fnh->remote_label = NO_LABEL;
			} else {
				me = (struct lde_map *)fec;
				fnh->remote_label = me->map.label;
				lde_send_change_klabel(fn, fnh);
			}
			break;
		}
	}
}

struct lde_map *
lde_map_add(struct lde_nbr *ln, struct fec_node *fn, int sent)
{
	struct lde_map  *me;

	me = calloc(1, sizeof(*me));
	if (me == NULL)
		fatal(__func__);

	me->fec = fn->fec;
	me->nexthop = ln;

	if (sent) {
		LIST_INSERT_HEAD(&fn->upstream, me, entry);
		if (fec_insert(&ln->sent_map, &me->fec))
			log_warnx("failed to add %s to sent map",
			    log_fec(&me->fec));
			/* XXX on failure more cleanup is needed */
	} else {
		LIST_INSERT_HEAD(&fn->downstream, me, entry);
		if (fec_insert(&ln->recv_map, &me->fec))
			log_warnx("failed to add %s to recv map",
			    log_fec(&me->fec));
	}

	return (me);
}

void
lde_map_del(struct lde_nbr *ln, struct lde_map *me, int sent)
{
	if (sent)
		fec_remove(&ln->sent_map, &me->fec);
	else
		fec_remove(&ln->recv_map, &me->fec);

	lde_map_free(me);
}

static void
lde_map_free(void *ptr)
{
	struct lde_map	*map = ptr;

	LIST_REMOVE(map, entry);
	free(map);
}

struct lde_req *
lde_req_add(struct lde_nbr *ln, struct fec *fec, int sent)
{
	struct fec_tree	*t;
	struct lde_req	*lre;

	t = sent ? &ln->sent_req : &ln->recv_req;

	lre = calloc(1, sizeof(*lre));
	if (lre != NULL) {
		lre->fec = *fec;

		if (fec_insert(t, &lre->fec)) {
			log_warnx("failed to add %s to %s req",
			    log_fec(&lre->fec), sent ? "sent" : "recv");
			free(lre);
			return (NULL);
		}
	}

	return (lre);
}

void
lde_req_del(struct lde_nbr *ln, struct lde_req *lre, int sent)
{
	if (sent)
		fec_remove(&ln->sent_req, &lre->fec);
	else
		fec_remove(&ln->recv_req, &lre->fec);

	free(lre);
}

struct lde_wdraw *
lde_wdraw_add(struct lde_nbr *ln, struct fec_node *fn)
{
	struct lde_wdraw  *lw;

	lw = calloc(1, sizeof(*lw));
	if (lw == NULL)
		fatal(__func__);

	lw->fec = fn->fec;

	if (fec_insert(&ln->sent_wdraw, &lw->fec))
		log_warnx("failed to add %s to sent wdraw",
		    log_fec(&lw->fec));

	return (lw);
}

void
lde_wdraw_del(struct lde_nbr *ln, struct lde_wdraw *lw)
{
	fec_remove(&ln->sent_wdraw, &lw->fec);
	free(lw);
}

void
lde_change_egress_label(int af, int was_implicit)
{
	struct lde_nbr	*ln;
	struct fec	*f;
	struct fec_node	*fn;

	RB_FOREACH(ln, nbr_tree, &lde_nbrs) {
		/* explicit withdraw */
		if (was_implicit)
			lde_send_labelwithdraw_wcard(ln, MPLS_LABEL_IMPLNULL);
		else {
			if (ln->v4_enabled)
				lde_send_labelwithdraw_wcard(ln,
				    MPLS_LABEL_IPV4NULL);
			if (ln->v6_enabled)
				lde_send_labelwithdraw_wcard(ln,
				    MPLS_LABEL_IPV6NULL);
		}

		/* advertise new label of connected prefixes */
		RB_FOREACH(f, fec_tree, &ft) {
			fn = (struct fec_node *)f;
			if (fn->local_label > MPLS_LABEL_RESERVED_MAX)
				continue;

			switch (af) {
			case AF_INET:
				if (fn->fec.type != FEC_TYPE_IPV4)
					continue;
				break;
			case AF_INET6:
				if (fn->fec.type != FEC_TYPE_IPV6)
					continue;
				break;
			default:
				fatalx("lde_change_egress_label: unknown af");
			}

			fn->local_label = egress_label(fn->fec.type);
			lde_send_labelmapping(ln, fn, 0);
		}

		lde_imsg_compose_ldpe(IMSG_MAPPING_ADD_END, ln->peerid, 0,
		    NULL, 0);
	}
}

static int
lde_address_add(struct lde_nbr *ln, struct lde_addr *lde_addr)
{
	struct lde_addr		*new;

	if (lde_address_find(ln, lde_addr->af, &lde_addr->addr) != NULL)
		return (-1);

	if ((new = calloc(1, sizeof(*new))) == NULL)
		fatal(__func__);

	new->af = lde_addr->af;
	new->addr = lde_addr->addr;
	TAILQ_INSERT_TAIL(&ln->addr_list, new, entry);

	/* reevaluate the previously received mappings from this neighbor */
	lde_nbr_addr_update(ln, lde_addr, 0);

	return (0);
}

static int
lde_address_del(struct lde_nbr *ln, struct lde_addr *lde_addr)
{
	lde_addr = lde_address_find(ln, lde_addr->af, &lde_addr->addr);
	if (lde_addr == NULL)
		return (-1);

	/* reevaluate the previously received mappings from this neighbor */
	lde_nbr_addr_update(ln, lde_addr, 1);

	TAILQ_REMOVE(&ln->addr_list, lde_addr, entry);
	free(lde_addr);

	return (0);
}

struct lde_addr *
lde_address_find(struct lde_nbr *ln, int af, union ldpd_addr *addr)
{
	struct lde_addr		*lde_addr;

	TAILQ_FOREACH(lde_addr, &ln->addr_list, entry)
		if (lde_addr->af == af &&
		    ldp_addrcmp(af, &lde_addr->addr, addr) == 0)
			return (lde_addr);

	return (NULL);
}

static void
lde_address_list_free(struct lde_nbr *ln)
{
	struct lde_addr		*lde_addr;

	while ((lde_addr = TAILQ_FIRST(&ln->addr_list)) != NULL) {
		TAILQ_REMOVE(&ln->addr_list, lde_addr, entry);
		free(lde_addr);
	}
}
@


1.72
log
@Implement RFC 6667 (Typed Wildcard FEC for PWid).
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.71 2017/03/04 00:09:17 renato Exp $ */
d316 7
d1000 32
d1049 1
@


1.71
log
@Implement RFC 5918 (Typed Wildcard FEC).
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.70 2017/03/04 00:03:04 renato Exp $ */
d907 14
@


1.70
log
@Implement support for PWid group wildcards.

This was missing from our original RFC 4447 VPLS implementation. Now
ldpd understands group wildcards as mandated by the RFC, but we still
don't send them ourselves. I can't see any case in which sending a group
wildcard would be useful, but nonetheless this patch provides a function
called lde_send_labelwithdraw_pwid_wcard() which is ready to be used in
the future anytime we feel like it might be useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.69 2017/03/03 23:41:27 renato Exp $ */
d893 14
@


1.69
log
@Minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.68 2017/01/20 12:19:18 benno Exp $ */
d256 1
a256 4
				if (map.type == MAP_TYPE_WILDCARD)
					lde_check_release_wcard(&map, ln);
				else
					lde_check_release(&map, ln);
d259 1
a259 4
				if (map.type == MAP_TYPE_WILDCARD)
					lde_check_withdraw_wcard(&map, ln);
				else
					lde_check_withdraw(&map, ln);
d817 2
a818 2
lde_send_labelwithdraw(struct lde_nbr *ln, struct fec_node *fn, uint32_t label,
    struct status_tlv *st)
d847 2
a848 5
	} else {
		memset(&map, 0, sizeof(map));
		map.type = MAP_TYPE_WILDCARD;
		map.label = label;
	}
d869 2
d873 3
d887 1
a887 1
lde_send_labelwithdraw_all(struct fec_node *fn, uint32_t label)
d889 13
a901 1
	struct lde_nbr		*ln;
d903 7
a909 2
	RB_FOREACH(ln, nbr_tree, &lde_nbrs)
		lde_send_labelwithdraw(ln, fn, label, NULL);
d913 2
a914 1
lde_send_labelrelease(struct lde_nbr *ln, struct fec_node *fn, uint32_t label)
d940 2
a941 4
	} else {
		memset(&map, 0, sizeof(map));
		map.type = MAP_TYPE_WILDCARD;
	}
d1250 1
a1250 2
			lde_send_labelwithdraw(ln, NULL, MPLS_LABEL_IMPLNULL,
			    NULL);
d1253 2
a1254 2
				lde_send_labelwithdraw(ln, NULL,
				    MPLS_LABEL_IPV4NULL, NULL);
d1256 2
a1257 2
				lde_send_labelwithdraw(ln, NULL,
				    MPLS_LABEL_IPV6NULL, NULL);
@


1.68
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

removal of log_rtmsg() aproved by claudio@@

ok claudio@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.67 2016/09/02 17:10:34 renato Exp $ */
d47 1
a47 1
static __inline		 int lde_nbr_compare(struct lde_nbr *,
d938 1
a938 1
lde_send_notification(uint32_t peerid, uint32_t status_code, uint32_t msg_id,
d949 1
a949 1
	lde_imsg_compose_ldpe(IMSG_NOTIFICATION_SEND, peerid, 0,
@


1.67
log
@lde() and ldpe() should return void.

Remove these leftovers from the pre-fork+exec era.

Spotted by and ok rzalamena@@ ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.66 2016/09/02 17:05:23 renato Exp $ */
d101 1
@


1.66
log
@Reevaluate received mappings upon receipt of address message.

If a neighbor was a nexthop for a given set of prefixes but it's not
anymore, then we should uninstall the associated label mappings (if any)
from the kernel.  The same applies for the other way round (neighbor
wasn't a nexthop for a given set of prefixes but now is).

This issue is only evident when we have multiple links between a pair
of LSRs. Generally, when a link is shut down, the whole LDP is torn down
and all label mappings uninstalled automatically.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.65 2016/09/02 17:03:24 renato Exp $ */
d87 1
a87 1
pid_t
a147 3
	/* NOTREACHED */

	return (0);
@


1.65
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.64 2016/08/08 21:42:13 renato Exp $ */
d53 2
d1082 41
d1294 3
d1306 3
@


1.64
log
@Use exit(3) instead of _exit(2) in the child processes.

Since recently the child processes call exec() after fork(), so they should
stop using _exit(2) and use exit(3) instead when shutting down.

Ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.63 2016/08/08 16:45:51 renato Exp $ */
d43 1
a43 1
static void		 lde_shutdown(void);
d151 1
a151 1
static void
d154 6
a165 1
	msgbuf_clear(&iev_ldpe->ibuf.w);
a166 1
	msgbuf_clear(&iev_main->ibuf.w);
@


1.63
log
@Normalize the received prefixes.

We need to use ldp_applymask() to normalize the received
prefixes. Example: 10.1.1.0/16 -> 10.1.0.0/16.

Additionally, stop using IANA's AF numbers in map->fec.prefix.af and use
AF_INET/AF_INET6 instead. This makes the code much simpler, use AF_IPV[46]
only when necessary (decoding/encoding prefixes).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.62 2016/07/18 21:10:37 benno Exp $ */
d166 1
a166 1
	_exit(0);
@


1.62
log
@add format attributes to log functions and fix am error when using
log_warnx()

ok renato@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.61 2016/07/01 23:36:38 renato Exp $ */
d698 1
a698 1
		map->fec.prefix.af = AF_IPV4;
d704 1
a704 1
		map->fec.prefix.af = AF_IPV6;
d726 1
a726 1
		case AF_IPV4:
d731 1
a731 1
		case AF_IPV6:
@


1.61
log
@More renaming and whitespace cleanup.

No binary change after "strip -s".
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.60 2016/07/01 23:33:46 renato Exp $ */
d1137 1
a1137 1
			log_warnx("failed to add %s/%u to %s req",
@


1.60
log
@Be more compliant with RFC 4447.

When sending a label withdraw during the pseudowire Control Word
negotiation, append a "Wrong C-bit" status TLV after the FEC TLV (in
conformance to RFC 4447 section 6.2). Apparently this has no use other
than aiding in troubleshooting.

Also, extend the recv_labelmessage() function to accept Status TLVs and
ignore them instead of shutting down the session.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.59 2016/06/18 01:25:53 renato Exp $ */
d314 1
a314 1
			switch (nm.status) {
d797 1
a797 1
		map.requestid = lre->msgid;
d820 1
a820 1
    struct status_tlv *status)
d855 4
a858 4
	if (status) {
		map.status.code = status->status_code;
		map.status.msg_id = status->msg_id;
		map.status.msg_type = status->msg_type;
d934 2
a935 2
lde_send_notification(uint32_t peerid, uint32_t code, uint32_t msgid,
    uint16_t type)
d940 4
a943 4
	nm.status = code;
	/* 'msgid' and 'type' should be in network byte order */
	nm.messageid = msgid;
	nm.type = type;
@


1.59
log
@Fix small LIB<->LFIB synchronization issue.

ldpd operates only with the best routes of each IP prefix. In other words,
the routes with the lowest priorities.

When a route with a better priority is detected (possibly with a different
nexthop), we should uninstall the labels from the "old" routes and try
to install a new label for the new route (if there's one available in
the LIB).

In this specific case, ldpd was failing to uninstall the labels from the
old routes because it wasn't keeping track of each route's priority in
lde. With this missing bit of information, the parent process had no way
to get the correct label to uninstall when processing a IMSG_KLABEL_DELETE
message.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.58 2016/05/23 19:16:00 renato Exp $ */
d819 2
a820 1
lde_send_labelwithdraw(struct lde_nbr *ln, struct fec_node *fn, uint32_t label)
d855 7
d892 1
a892 1
		lde_send_labelwithdraw(ln, fn, label);
d1193 2
a1194 1
			lde_send_labelwithdraw(ln, NULL, MPLS_LABEL_IMPLNULL);
d1198 1
a1198 1
				    MPLS_LABEL_IPV4NULL);
d1201 1
a1201 1
				    MPLS_LABEL_IPV6NULL);
@


1.58
log
@Improve security by calling exec after fork.

For each child process (lde and ldpe), re-exec ldpd with a special
"per-role" getopt flag. This way we have seperate ASLR/cookies per
process.

Based on a similar patch for bgpd, from claudio@@

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.57 2016/05/23 19:14:03 renato Exp $ */
d439 1
a439 1
				    kr.flags & F_CONNECTED, NULL);
d442 2
a443 1
				lde_kernel_remove(&fec, kr.af, &kr.nexthop);
d578 1
d595 1
d643 1
d660 1
@


1.57
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.56 2016/05/23 19:11:42 renato Exp $ */
d86 1
a86 2
lde(struct ldpd_conf *xconf, int pipe_parent2lde[2], int pipe_ldpe2lde[2],
    int pipe_parent2ldpe[2])
a90 2
	pid_t			 pid;
	struct l2vpn		*l2vpn;
d92 1
a92 9
	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
		/* NOTREACHED */
	case 0:
		break;
	default:
		return (pid);
	}
d94 2
a95 1
	ldeconf = xconf;
d113 1
a113 1
	if (pledge("stdio", NULL) == -1)
d126 2
a127 8
	/* setup pipes */
	close(pipe_ldpe2lde[0]);
	close(pipe_parent2lde[0]);
	close(pipe_parent2ldpe[0]);
	close(pipe_parent2ldpe[1]);

	if ((iev_ldpe = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_main = malloc(sizeof(struct imsgev))) == NULL)
d129 1
a129 3
	imsg_init(&iev_ldpe->ibuf, pipe_ldpe2lde[1]);
	iev_ldpe->handler = lde_dispatch_imsg;
	imsg_init(&iev_main->ibuf, pipe_parent2lde[1]);
a130 7

	/* setup event handler */
	iev_ldpe->events = EV_READ;
	event_set(&iev_ldpe->ev, iev_ldpe->ibuf.fd, iev_ldpe->events,
	    iev_ldpe->handler, iev_ldpe);
	event_add(&iev_ldpe->ev, NULL);

a142 4
	/* initialize l2vpns */
	LIST_FOREACH(l2vpn, &ldeconf->l2vpn_list, entry)
		l2vpn_init(l2vpn);

d445 21
@


1.56
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.55 2016/05/23 19:09:25 renato Exp $ */
d4 1
@


1.55
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.54 2016/05/23 18:58:48 renato Exp $ */
d22 1
a23 1
#include <sys/queue.h>
a26 1
#include <err.h>
d33 1
a33 1
#include <event.h>
@


1.54
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.53 2016/05/23 18:55:21 renato Exp $ */
d42 15
a56 16
void		 lde_sig_handler(int sig, short, void *);
void		 lde_shutdown(void);
void		 lde_dispatch_imsg(int, short, void *);
void		 lde_dispatch_parent(int, short, void *);

struct lde_nbr	*lde_nbr_find(uint32_t);
struct lde_nbr	*lde_nbr_new(uint32_t, struct lde_nbr *);
void		 lde_nbr_del(struct lde_nbr *);
void		 lde_nbr_clear(void);

void		 lde_map_free(void *);
void		 lde_address_list_free(struct lde_nbr *);

struct ldpd_conf	*ldeconf = NULL, *nconf = NULL;
struct imsgev		*iev_ldpe;
struct imsgev		*iev_main;
d58 1
a58 1
static __inline int lde_nbr_compare(struct lde_nbr *, struct lde_nbr *);
d60 2
a61 3
RB_HEAD(nbr_tree, lde_nbr);
RB_PROTOTYPE(nbr_tree, lde_nbr, entry, lde_nbr_compare)
RB_GENERATE(nbr_tree, lde_nbr, entry, lde_nbr_compare)
d63 2
a64 1
struct nbr_tree lde_nbrs = RB_INITIALIZER(&lde_nbrs);
d67 1
a67 1
void
d180 1
a180 1
void
d199 1
a199 1
int
d214 1
a214 1
void
d404 1
a404 1
void
d407 1
d950 1
a950 1
struct lde_nbr *
d976 1
a976 1
void
d1028 1
a1028 1
struct lde_nbr *
d1062 1
a1062 1
void
d1110 1
a1110 1
void
d1226 1
a1226 1
int
d1244 1
a1244 1
int
d1270 1
a1270 1
void
@


1.53
log
@Assorted fixes and small cleanup.

Nothing really interesting here.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.52 2016/05/23 18:46:13 renato Exp $ */
d48 1
a48 1
struct lde_nbr	*lde_nbr_new(uint32_t, struct in_addr *);
d223 1
a223 1
	struct in_addr		 addr;
d299 1
a299 1
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(addr))
d301 1
a301 1
			memcpy(&addr, imsg.data, sizeof(addr));
d309 1
a309 1
			if (lde_address_add(ln, &addr) < 0) {
d312 1
a312 1
				    inet_ntoa(addr));
d316 1
a316 1
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(addr))
d318 1
a318 1
			memcpy(&addr, imsg.data, sizeof(addr));
d326 1
a326 1
			if (lde_address_del(ln, &addr) < 0) {
d329 1
a329 1
				    inet_ntoa(addr));
d353 2
a354 1
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(addr))
d443 1
d450 10
a459 9
			fec.type = FEC_TYPE_IPV4;
			fec.u.ipv4.prefix = kr.prefix;
			fec.u.ipv4.prefixlen = kr.prefixlen;
			lde_kernel_insert(&fec, kr.nexthop,
			    kr.flags & F_CONNECTED, NULL);
			break;
		case IMSG_NETWORK_DEL:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(kr)) {
				log_warnx("%s: wrong imsg len", __func__);
d461 2
a463 1
			memcpy(&kr, imsg.data, sizeof(kr));
d465 9
a473 4
			fec.type = FEC_TYPE_IPV4;
			fec.u.ipv4.prefix = kr.prefix;
			fec.u.ipv4.prefixlen = kr.prefixlen;
			lde_kernel_remove(&fec, kr.nexthop);
d492 4
a495 1
			LIST_INIT(&niface->adj_list);
d579 2
a580 1
		kr.prefix = fn->fec.u.ipv4.prefix;
d582 17
a599 1
		kr.nexthop = fnh->nexthop;
d605 3
a607 3
		if (fnh->remote_label != NO_LABEL &&
		    fn->fec.u.ipv4.prefixlen == 32)
			l2vpn_sync_pws(fn->fec.u.ipv4.prefix);
d620 2
a621 1
		kpw.nexthop = fnh->nexthop;
d642 2
a643 1
		kr.prefix = fn->fec.u.ipv4.prefix;
d645 1
a646 1
		kr.nexthop = fnh->nexthop;
d653 18
a670 1
			l2vpn_sync_pws(fn->fec.u.ipv4.prefix);
d681 2
a682 1
		kpw.nexthop = fnh->nexthop;
d701 9
a709 2
		map->fec.ipv4.prefix = fec->u.ipv4.prefix;
		map->fec.ipv4.prefixlen = fec->u.ipv4.prefixlen;
d728 15
a742 3
		fec->type = FEC_TYPE_IPV4;
		fec->u.ipv4.prefix = map->fec.ipv4.prefix;
		fec->u.ipv4.prefixlen = map->fec.ipv4.prefixlen;
d768 10
a777 1
	if (fn->fec.type == FEC_TYPE_PWID) {
d792 1
d831 10
a840 2
		map.label = fn->local_label;
		if (fn->fec.type == FEC_TYPE_PWID) {
d848 1
d850 1
d898 10
a907 1
		if (fn->fec.type == FEC_TYPE_PWID) {
d915 1
d951 1
a951 1
lde_nbr_new(uint32_t peerid, struct in_addr *id)
d958 3
a960 1
	ln->id = *id;
d994 3
a996 1
				if (!lde_address_find(ln, &fnh->nexthop))
d1051 1
a1051 1
lde_nbr_find_by_addr(struct in_addr addr)
d1056 1
a1056 1
		if (lde_address_find(ln, &addr) != NULL)
d1179 1
a1179 1
lde_change_egress_label(int was_implicit)
d1185 12
a1196 5
	/* explicit withdraw */
	if (was_implicit)
		lde_send_labelwithdraw_all(NULL, MPLS_LABEL_IMPLNULL);
	else
		lde_send_labelwithdraw_all(NULL, MPLS_LABEL_IPV4NULL);
d1198 1
a1198 2
	/* update label of connected prefixes */
	RB_FOREACH(ln, nbr_tree, &lde_nbrs) {
d1204 13
d1227 1
a1227 1
lde_address_add(struct lde_nbr *ln, struct in_addr *addr)
d1231 1
a1231 1
	if (lde_address_find(ln, addr) != NULL)
d1237 2
a1238 1
	new->addr = *addr;
d1245 1
a1245 1
lde_address_del(struct lde_nbr *ln, struct in_addr *addr)
d1247 1
a1247 3
	struct lde_addr		*lde_addr;

	lde_addr = lde_address_find(ln, addr);
d1258 1
a1258 1
lde_address_find(struct lde_nbr *ln, struct in_addr *addr)
d1263 2
a1264 1
		if (lde_addr->addr.s_addr == addr->s_addr)
@


1.52
log
@Introduce a garbage collector for dead entries in the LIB.

If we lose a route and all of its associated labels, then there's no
point on keeping an entry for it in the LIB.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.51 2016/05/23 18:31:12 renato Exp $ */
a308 1

a313 1

a325 1

a330 1

a354 1
			memcpy(&addr, imsg.data, sizeof(addr));
d359 1
a359 1
			lde_nbr_new(imsg.hdr.peerid, &addr);
d554 1
a554 1
	return label;
d1108 1
a1108 1
	struct lde_addr		*address;
d1113 1
a1113 1
	if ((address = calloc(1, sizeof(*address))) == NULL)
d1116 2
a1117 5
	address->addr = *addr;

	TAILQ_INSERT_TAIL(&ln->addr_list, address, entry);

	log_debug("%s: added %s", __func__, inet_ntoa(*addr));
d1125 1
a1125 1
	struct lde_addr		*address;
d1127 2
a1128 2
	address = lde_address_find(ln, addr);
	if (address == NULL)
d1131 2
a1132 5
	TAILQ_REMOVE(&ln->addr_list, address, entry);

	free(address);

	log_debug("%s: deleted %s", __func__, inet_ntoa(*addr));
d1140 1
a1140 1
	struct lde_addr		*address = NULL;
d1142 3
a1144 4
	TAILQ_FOREACH(address, &ln->addr_list, entry) {
		if (address->addr.s_addr == addr->s_addr)
			return (address);
	}
d1152 1
a1152 1
	struct lde_addr		*addr;
d1154 3
a1156 3
	while ((addr = TAILQ_FIRST(&ln->addr_list)) != NULL) {
		TAILQ_REMOVE(&ln->addr_list, addr, entry);
		free(addr);
@


1.51
log
@Fix bugs in pseudowire parameters negotiation.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.50 2016/05/23 18:28:22 renato Exp $ */
d162 4
d184 1
@


1.50
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).

In addition, copy in_addr structs directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.49 2016/05/23 17:43:42 renato Exp $ */
d879 4
a882 3
	struct fec	*f;
	struct fec_node	*fn;
	struct fec_nh	*fnh;
d900 3
@


1.49
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d449 1
a449 1
			fec.u.ipv4.prefix.s_addr = kr.prefix.s_addr;
d462 1
a462 1
			fec.u.ipv4.prefix.s_addr = kr.prefix.s_addr;
d567 1
a567 1
		kr.prefix.s_addr = fn->fec.u.ipv4.prefix.s_addr;
d570 1
a570 1
		kr.nexthop.s_addr = fnh->nexthop.s_addr;
d591 1
a591 1
		kpw.nexthop.s_addr = fnh->nexthop.s_addr;
d612 1
a612 1
		kr.prefix.s_addr = fn->fec.u.ipv4.prefix.s_addr;
d615 1
a615 1
		kr.nexthop.s_addr = fnh->nexthop.s_addr;
d633 1
a633 1
		kpw.nexthop.s_addr = fnh->nexthop.s_addr;
d673 1
a673 1
		fec->u.ipv4.prefix.s_addr = map->fec.ipv4.prefix.s_addr;
d740 1
a740 1
	memcpy(&me->map, &map, sizeof(map));
d860 1
a860 1
	ln->id.s_addr = id->s_addr;
d1112 1
a1112 1
	address->addr.s_addr = addr->s_addr;
@


1.48
log
@Rework L2VPN code.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.47 2016/05/23 16:50:11 renato Exp $ */
d47 2
a48 2
struct lde_nbr	*lde_nbr_find(u_int32_t);
struct lde_nbr	*lde_nbr_new(u_int32_t, struct in_addr *);
d59 8
d163 1
a163 1
	ldeconf->uptime = now.tv_sec;
d196 1
a196 1
lde_imsg_compose_parent(int type, pid_t pid, void *data, u_int16_t datalen)
d202 2
a203 2
lde_imsg_compose_ldpe(int type, u_int32_t peerid, pid_t pid, void *data,
    u_int16_t datalen)
d244 2
a245 2
			nbr = lde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL) {
d248 1
a248 1
				return;
d251 1
a251 1
			fec_snap(nbr);
d266 1
a266 1
				return;
d298 2
a299 2
			nbr = lde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL) {
d302 1
a302 1
				return;
d305 1
a305 1
			if (lde_address_add(nbr, &addr) < 0) {
d317 2
a318 2
			nbr = lde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL) {
d321 1
a321 1
				return;
d324 1
a324 1
			if (lde_address_del(nbr, &addr) < 0) {
d340 1
a340 1
				return;
a472 1
			LIST_INIT(&nconf->addr_list);
d547 1
a547 1
u_int32_t
d550 1
a550 1
	static u_int32_t label = MPLS_LABEL_RESERVED_MAX;
d566 1
a566 1
		bzero(&kr, sizeof(kr));
d588 1
a588 1
		bzero(&kpw, sizeof(kpw));
d611 1
a611 1
		bzero(&kr, sizeof(kr));
d630 1
a630 1
		bzero(&kpw, sizeof(kpw));
d647 1
a647 1
	bzero(map, sizeof(*map));
d668 1
a668 1
	bzero(fec, sizeof(*fec));
a698 1
	bzero(&map, sizeof(map));
a699 1

d744 1
a744 1
lde_send_labelwithdraw(struct lde_nbr *ln, struct fec_node *fn)
a748 1
	struct fec_nh		*fnh = NULL;
a750 8
	if (fn->fec.type == FEC_TYPE_PWID) {
		fnh = fec_nh_find(fn, ln->id);
		if (fnh == NULL)
			/* not the other end of the pseudowire */
			return;
	}

	bzero(&map, sizeof(map));
d754 5
a759 2
		if (fn->fec.type == FEC_TYPE_PWID) {
			pw = (struct l2vpn_pw *) fnh->data;
d764 3
a766 2
		map.type = FEC_WILDCARD;
		map.label = NO_LABEL;
d794 10
a803 1
lde_send_labelrelease(struct lde_nbr *ln, struct fec_node *fn, u_int32_t label)
a805 1
	struct fec_nh		*fnh = NULL;
a807 8
	if (fn->fec.type == FEC_TYPE_PWID) {
		fnh = fec_nh_find(fn, ln->id);
		if (fnh == NULL)
			/* not the other end of the pseudowire */
			return;
	}

	bzero(&map, sizeof(map));
d810 5
a815 2
		if (fn->fec.type == FEC_TYPE_PWID) {
			pw = (struct l2vpn_pw *) fnh->data;
d819 4
a822 2
	} else
		map.type = FEC_WILDCARD;
d831 2
a832 2
lde_send_notification(u_int32_t peerid, u_int32_t code, u_int32_t msgid,
    u_int32_t type)
d836 1
a836 3
	bzero(&nm, sizeof(nm));

	/* Every field is in host byte order, to keep things clear */
d838 2
a839 1
	nm.messageid = ntohl(msgid);
a845 8
static __inline int lde_nbr_compare(struct lde_nbr *, struct lde_nbr *);

RB_HEAD(nbr_tree, lde_nbr);
RB_PROTOTYPE(nbr_tree, lde_nbr, entry, lde_nbr_compare)
RB_GENERATE(nbr_tree, lde_nbr, entry, lde_nbr_compare)

struct nbr_tree lde_nbrs = RB_INITIALIZER(&lde_nbrs);

d853 1
a853 11
lde_nbr_find(u_int32_t peerid)
{
	struct lde_nbr	n;

	n.peerid = peerid;

	return (RB_FIND(nbr_tree, &lde_nbrs, &n));
}

struct lde_nbr *
lde_nbr_new(u_int32_t peerid, struct in_addr *id)
@


1.47
log
@Remove protection that was prevent pseudowires to be updated in the kernel.

During the setup of a pseudowire, it might change its parameters
(e.g. control-word) once the negotiation with the remote peer is done.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.46 2016/05/23 16:43:57 renato Exp $ */
d578 1
a578 1
		pw = (struct l2vpn_pw *) fnh->data;
d618 1
a618 1
		pw = (struct l2vpn_pw *) fnh->data;
d659 1
a659 1
lde_map2fec(struct map *map, struct in_addr nbrid, struct fec *fec)
d673 1
a673 1
		fec->u.pwid.nexthop.s_addr = nbrid.s_addr;
a683 1
	struct fec_nh	*fnh;
d696 3
a698 3
		fnh = fec_nh_find(fn, ln->id);
		if (fnh == NULL)
			/* not the other end of the pseudowire */
a700 1
		pw = (struct l2vpn_pw *) fnh->data;
d905 11
a915 3
			if (lde_address_find(ln, &fnh->nexthop)) {
				lde_send_delete_klabel(fn, fnh);
				fnh->remote_label = NO_LABEL;
d917 3
d946 24
a1174 13
}

struct lde_nbr *
lde_find_address(struct in_addr address)
{
	struct lde_nbr	*ln;

	RB_FOREACH(ln, nbr_tree, &lde_nbrs) {
		if (lde_address_find(ln, &address) != NULL)
			return (ln);
	}

	return (NULL);
@


1.46
log
@Make send_labelmessage() more robust.

Immediately return from this function if the given list of mappings
is empty. This way we have more freedom when sending label messages,
not having to care with corner cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.45 2016/05/23 16:20:59 renato Exp $ */
a578 2
		if (pw->flags & F_PW_STATUS_UP)
			return;
@


1.45
log
@Standardize some log messages and fix some inconsistencies.

We were using several different names for the same thing in our log
messages: neighbor, neighbor ID, nbr ID and LSR ID.

Standardize to always use "lsr-id" to refer to a neighbor.

Also:
* Use log_warnx() instead of log_warn() when appropriate;
* Use fatal(x) instead of err(x) when appropriate;
* Fix some inconsistent log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.44 2016/05/23 16:14:36 renato Exp $ */
a1060 1
	int		 count = 0;
a1076 1
			count++;
d1078 3
a1080 3
		if (count > 0)
			lde_imsg_compose_ldpe(IMSG_MAPPING_ADD_END,
			    ln->peerid, 0, NULL, 0);
@


1.44
log
@More renaming.

Rename a few more things to improve readability.

* s/F_PW_CONTROLWORD_CONF/F_PW_CWORD_CONF/ (shorter)
* s/F_PW_CONTROLWORD/F_PW_CWORD/ (shorter)
* s/LDPD_FLAG_*/F_LDPD_*/ (consistency)
* s/lde_nbr_address/lde_addr/ (shorter)
* s/ldp_discovery_socket/ldp_disc_socket/ (shorter)
* s/ldp_ediscovery_socket/ldp_edisc_socket/ (shorter)
* s/ldp_sendboth/main_imsg_compose_both/ (consistency)
* s/cons/total/ (makes more sense)
* s/kaddr/ka/ (consistency with remaining code)
* Always use 'ln' for lde_nbrs (consistency)
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.43 2016/05/23 16:12:28 renato Exp $ */
d251 1
a251 1
				fatalx("invalid size of OE request");
d287 1
a287 1
				fatalx("invalid size of OE request");
d306 1
a306 1
				fatalx("invalid size of OE request");
d318 1
a318 1
				    "does not exists", __func__,
d325 1
a325 1
				fatalx("invalid size of OE request");
d345 1
a345 1
				fatalx("invalid size of OE request");
@


1.43
log
@Rename a few constants to avoid confusion.

In ldpd we have the map structure, which is used to represent a label message,
and the fec structure, used to store FECs in the LIB.

As of now, ldpd supports two type of FECs:
* IPv4 prefix (FEC_TYPE_IPV4);
* PWID (FEC_TYPE_PWID).

For the label messages, the following contants were being used:
* FEC_WILDCARD;
* FEC_PREFIX (IPv4 or IPv6);
* FEC_PWID.

Since these contants have similar names to the previous ones, rename
them to:
* MAP_TYPE_WILDCARD;
* MAP_TYPE_PREFIX;
* MAP_TYPE_PWID.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.42 2016/05/23 15:47:24 renato Exp $ */
d208 1
a208 1
	struct lde_nbr		 *nbr;
d254 2
a255 2
			nbr = lde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL) {
d263 1
a263 1
				lde_check_mapping(&map, nbr);
d266 1
a266 1
				lde_check_request(&map, nbr);
d270 1
a270 1
					lde_check_release_wcard(&map, nbr);
d272 1
a272 1
					lde_check_release(&map, nbr);
d276 1
a276 1
					lde_check_withdraw_wcard(&map, nbr);
d278 1
a278 1
					lde_check_withdraw(&map, nbr);
d328 2
a329 2
			nbr = lde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL) {
d337 1
a337 1
				l2vpn_recv_pw_status(nbr, &nm);
d707 1
a707 1
		if (pw->flags & F_PW_CONTROLWORD)
d765 1
a765 1
			if (pw->flags & F_PW_CONTROLWORD)
d817 1
a817 1
			if (pw->flags & F_PW_CONTROLWORD)
d873 1
a873 1
	struct lde_nbr	*nbr;
d875 1
a875 1
	if ((nbr = calloc(1, sizeof(*nbr))) == NULL)
d878 7
a884 7
	nbr->id.s_addr = id->s_addr;
	nbr->peerid = peerid;
	fec_init(&nbr->recv_map);
	fec_init(&nbr->sent_map);
	fec_init(&nbr->recv_req);
	fec_init(&nbr->sent_req);
	fec_init(&nbr->sent_wdraw);
d886 1
a886 1
	TAILQ_INIT(&nbr->addr_list);
d888 1
a888 1
	if (RB_INSERT(nbr_tree, &lde_nbrs, nbr) != NULL)
d891 1
a891 1
	return (nbr);
d895 1
a895 1
lde_nbr_del(struct lde_nbr *nbr)
d901 1
a901 1
	if (nbr == NULL)
d909 1
a909 1
			if (lde_address_find(nbr, &fnh->nexthop)) {
d916 1
a916 1
	lde_address_list_free(nbr);
d918 5
a922 5
	fec_clear(&nbr->recv_map, lde_map_free);
	fec_clear(&nbr->sent_map, lde_map_free);
	fec_clear(&nbr->recv_req, free);
	fec_clear(&nbr->sent_req, free);
	fec_clear(&nbr->sent_wdraw, free);
d924 1
a924 1
	RB_REMOVE(nbr_tree, &lde_nbrs, nbr);
d926 1
a926 1
	free(nbr);
d932 1
a932 1
	struct lde_nbr	n;
d934 1
a934 1
	n.peerid = peerid;
d936 1
a936 1
	return (RB_FIND(nbr_tree, &lde_nbrs, &n));
d942 1
a942 1
	struct lde_nbr	*nbr;
d944 2
a945 2
	 while ((nbr = RB_ROOT(&lde_nbrs)) != NULL)
		lde_nbr_del(nbr);
d1087 1
a1087 1
lde_address_add(struct lde_nbr *lr, struct in_addr *addr)
d1089 1
a1089 1
	struct lde_nbr_address	*address;
d1091 1
a1091 1
	if (lde_address_find(lr, addr) != NULL)
d1099 1
a1099 1
	TAILQ_INSERT_TAIL(&lr->addr_list, address, entry);
d1107 1
a1107 1
lde_address_del(struct lde_nbr *lr, struct in_addr *addr)
d1109 1
a1109 1
	struct lde_nbr_address	*address;
d1111 1
a1111 1
	address = lde_address_find(lr, addr);
d1115 1
a1115 1
	TAILQ_REMOVE(&lr->addr_list, address, entry);
d1124 2
a1125 2
struct lde_nbr_address *
lde_address_find(struct lde_nbr *lr, struct in_addr *addr)
d1127 1
a1127 1
	struct lde_nbr_address	*address = NULL;
d1129 1
a1129 1
	TAILQ_FOREACH(address, &lr->addr_list, entry) {
d1138 1
a1138 1
lde_address_list_free(struct lde_nbr *nbr)
d1140 1
a1140 1
	struct lde_nbr_address	*addr;
d1142 2
a1143 2
	while ((addr = TAILQ_FIRST(&nbr->addr_list)) != NULL) {
		TAILQ_REMOVE(&nbr->addr_list, addr, entry);
@


1.42
log
@Move some code around.

This patch doesn't introduce any logical change.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.41 2016/05/23 15:14:07 renato Exp $ */
d269 1
a269 1
				if (map.type == FEC_WILDCARD)
d275 1
a275 1
				if (map.type == FEC_WILDCARD)
d646 1
a646 1
		map->type = FEC_PREFIX;
d651 1
a651 1
		map->type = FEC_PWID;
d666 1
a666 1
	case FEC_PREFIX:
d671 1
a671 1
	case FEC_PWID:
@


1.41
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.40 2015/12/05 13:11:48 claudio Exp $ */
d929 10
d1055 31
a1105 13
struct lde_nbr_address *
lde_address_find(struct lde_nbr *lr, struct in_addr *addr)
{
	struct lde_nbr_address	*address = NULL;

	TAILQ_FOREACH(address, &lr->addr_list, entry) {
		if (address->addr.s_addr == addr->s_addr)
			return (address);
	}

	return (NULL);
}

d1122 13
@


1.40
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.39 2015/10/23 10:10:17 renato Exp $ */
d238 2
a239 2
				log_debug("lde_dispatch_imsg: cannot find "
				    "lde neighbor");
d256 2
a257 2
				log_debug("lde_dispatch_imsg: cannot find "
				    "lde neighbor");
d292 2
a293 2
				log_debug("lde_dispatch_imsg: cannot find "
				    "lde neighbor");
d298 2
a299 2
				log_debug("lde_dispatch_imsg: cannot add "
				    "address %s, it already exists",
d311 2
a312 2
				log_debug("lde_dispatch_imsg: cannot find "
				    "lde neighbor");
d317 2
a318 2
				log_debug("lde_dispatch_imsg: cannot delete "
				    "address %s, it does not exists",
d330 2
a331 2
				log_debug("lde_dispatch_imsg: cannot find "
				    "lde neighbor");
d380 1
a380 1
			log_debug("lde_dispatch_imsg: unexpected imsg %d",
d435 1
a435 2
				log_warnx("lde_dispatch_parent: "
				    "wrong imsg len");
d448 1
a448 2
				log_warnx("lde_dispatch_parent: "
				    "wrong imsg len");
d525 1
a525 1
			log_debug("lde_dispatch_parent: unexpected imsg %d",
d876 1
a876 1
		fatal("lde_nbr_new");
d945 1
a945 1
		fatal("lde_map_add");
d1027 1
a1027 1
		fatal("lde_wdraw_add");
d1054 1
a1054 1
		fatal("lde_address_add");
d1060 1
a1060 1
	log_debug("lde_address_add: added %s", inet_ntoa(*addr));
d1091 1
a1091 1
	log_debug("lde_address_del: deleted %s", inet_ntoa(*addr));
@


1.39
log
@Add pledge(2) to the child processes.

This is almost identical to the eigrpd(8) pledge diff, with the exception
that the parent process can not be pledged bacause of a SIOCSETMPWCFG
ioctl used to configure pseudowires.

Looks good to deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.38 2015/07/21 04:52:29 renato Exp $ */
d216 1
a216 1
		if ((n = imsg_read(ibuf)) == -1)
d230 1
a230 1
			fatal("lde_dispatch_imsg: imsg_read error");
d414 1
a414 1
		if ((n = imsg_read(ibuf)) == -1)
d428 1
a428 1
			fatal("lde_dispatch_parent: imsg_read error");
@


1.38
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.37 2015/07/21 04:48:42 renato Exp $ */
d115 3
@


1.37
log
@Record all fields of the received label mappings.

Since we implement the Liberal Label Retention mode, we need to record
all fields of the received label mappings so the messages can be processed
later when there is a matching nexthop for the advertised FECs.

This will be important when we implement VPLS because we need to retain
information like the pseudowire's interface MTU and Group ID.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.36 2015/07/21 04:46:51 renato Exp $ */
d86 1
d154 4
d208 1
d266 1
a266 1
				if (map.flags & F_MAP_WILDCARD)
d272 1
a272 1
				if (map.flags & F_MAP_WILDCARD)
d320 20
d359 12
d399 3
d408 1
d438 5
a442 1
			lde_kernel_insert(&kr);
d452 4
a455 1
			lde_kernel_remove(&kr);
d467 1
d493 26
d553 2
d556 33
a588 4
	bzero(&kr, sizeof(kr));
	kr.prefix.s_addr = fn->fec.prefix.s_addr;
	kr.prefixlen = fn->fec.prefixlen;
	kr.local_label = fn->local_label;
d590 4
a593 4
	kr.nexthop.s_addr = fnh->nexthop.s_addr;
	kr.remote_label = fnh->remote_label;

	lde_imsg_compose_parent(IMSG_KLABEL_CHANGE, 0, &kr, sizeof(kr));
d600 11
d612 2
a613 4
	bzero(&kr, sizeof(kr));
	kr.prefix.s_addr = fn->fec.prefix.s_addr;
	kr.prefixlen = fn->fec.prefixlen;
	kr.local_label = fn->local_label;
d615 27
a641 2
	kr.nexthop.s_addr = fnh->nexthop.s_addr;
	kr.remote_label = fnh->remote_label;
d643 14
a656 1
	lde_imsg_compose_parent(IMSG_KLABEL_DELETE, 0, &kr, sizeof(kr));
d660 21
a680 1
lde_send_labelmapping(struct lde_nbr *ln, struct fec_node *fn)
d685 2
d695 19
a714 2
	map.prefix = fn->fec.prefix;
	map.prefixlen = fn->fec.prefixlen;
d730 3
d747 9
d759 1
d761 6
a766 2
		map.prefix = fn->fec.prefix;
		map.prefixlen = fn->fec.prefixlen;
d768 1
a769 1
		map.flags = F_MAP_WILDCARD;
d799 10
a808 1
	struct map	 map;
d812 7
a818 2
		map.prefix = fn->fec.prefix;
		map.prefixlen = fn->fec.prefixlen;
d820 1
a820 1
		map.flags = F_MAP_WILDCARD;
d952 2
a953 2
			log_warnx("failed to add %s/%u to sent map",
			    inet_ntoa(me->fec.prefix), me->fec.prefixlen);
d958 2
a959 2
			log_warnx("failed to add %s/%u to recv map",
			    inet_ntoa(me->fec.prefix), me->fec.prefixlen);
d999 1
a999 2
			    inet_ntoa(lre->fec.prefix), lre->fec.prefixlen,
			    sent ? "sent" : "recv");
d1031 2
a1032 2
		log_warnx("failed to add %s/%u to sent wdraw",
		    inet_ntoa(lw->fec.prefix), lw->fec.prefixlen);
@


1.36
log
@Rename structures and functions to be more generic.

LDP work with FECs, where a FEC can be a prefix, a pseudowire and so on.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.35 2015/07/21 04:45:21 renato Exp $ */
d542 1
a542 1
	me->label = map.label;
@


1.35
log
@Reuse merge_config() logic to simplify the shutdown of each process.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.34 2015/07/21 04:43:28 renato Exp $ */
d165 1
a165 1
	rt_clear();
d234 1
a234 1
			rt_snap(nbr);
d474 1
a474 1
lde_send_change_klabel(struct rt_node *rr, struct rt_lsp *rl)
d479 3
a481 3
	kr.prefix.s_addr = rr->fec.prefix.s_addr;
	kr.prefixlen = rr->fec.prefixlen;
	kr.local_label = rr->local_label;
d483 2
a484 2
	kr.nexthop.s_addr = rl->nexthop.s_addr;
	kr.remote_label = rl->remote_label;
d490 1
a490 1
lde_send_delete_klabel(struct rt_node *rr, struct rt_lsp *rl)
d495 3
a497 3
	kr.prefix.s_addr = rr->fec.prefix.s_addr;
	kr.prefixlen = rr->fec.prefixlen;
	kr.local_label = rr->local_label;
d499 2
a500 2
	kr.nexthop.s_addr = rl->nexthop.s_addr;
	kr.remote_label = rl->remote_label;
d506 1
a506 1
lde_send_labelmapping(struct lde_nbr *ln, struct rt_node *rn)
d519 3
a521 3
	map.label = rn->local_label;
	map.prefix = rn->fec.prefix;
	map.prefixlen = rn->fec.prefixlen;
d524 1
a524 1
	lre = (struct lde_req *)fec_find(&ln->recv_req, &rn->fec);
d539 1
a539 1
	me = (struct lde_map *)fec_find(&ln->sent_map, &rn->fec);
d541 1
a541 1
		me = lde_map_add(ln, rn, 1);
d546 1
a546 1
lde_send_labelwithdraw(struct lde_nbr *ln, struct rt_node *rn)
d553 4
a556 4
	if (rn) {
		map.label = rn->local_label;
		map.prefix = rn->fec.prefix;
		map.prefixlen = rn->fec.prefixlen;
d568 2
a569 2
	if (rn) {
		lw = (struct lde_wdraw *)fec_find(&ln->sent_wdraw, &rn->fec);
d571 1
a571 1
			lw = lde_wdraw_add(ln, rn);
d574 2
a575 2
		RB_FOREACH(f, fec_tree, &rt) {
			rn = (struct rt_node *)f;
d578 1
a578 1
			    &rn->fec);
d580 1
a580 1
				lw = lde_wdraw_add(ln, rn);
d587 1
a587 1
lde_send_labelrelease(struct lde_nbr *ln, struct rt_node *rn, u_int32_t label)
d592 3
a594 3
	if (rn) {
		map.prefix = rn->fec.prefix;
		map.prefixlen = rn->fec.prefixlen;
d673 2
a674 2
	struct rt_node	*rn;
	struct rt_lsp	*rl;
d680 2
a681 2
	RB_FOREACH(f, fec_tree, &rt) {
		rn = (struct rt_node *)f;
d683 4
a686 4
		LIST_FOREACH(rl, &rn->lsp, entry) {
			if (lde_address_find(nbr, &rl->nexthop)) {
				lde_send_delete_klabel(rn, rl);
				rl->remote_label = NO_LABEL;
d714 1
a714 1
lde_map_add(struct lde_nbr *ln, struct rt_node *rn, int sent)
d722 1
a722 1
	me->fec = rn->fec;
d726 1
a726 1
		LIST_INSERT_HEAD(&rn->upstream, me, entry);
d732 1
a732 1
		LIST_INSERT_HEAD(&rn->downstream, me, entry);
d764 1
a764 1
	struct fec_tree	*ft;
d767 1
a767 1
	ft = sent ? &ln->sent_req : &ln->recv_req;
d773 1
a773 1
		if (fec_insert(ft, &lre->fec)) {
d797 1
a797 1
lde_wdraw_add(struct lde_nbr *ln, struct rt_node *rn)
d805 1
a805 1
	lw->fec = rn->fec;
@


1.34
log
@Add configuration reload support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.33 2015/07/19 20:54:16 renato Exp $ */
d167 2
a172 1
	free(ldeconf);
@


1.33
log
@Rework label mapping algorithms to be more in line with the RFC.

This patch presents a thoroughly review of the label mapping
algorithms. Most of the changes are minor bug fixes in the handling of
received label messages.

Additional improvements:
* Add a few more references to the Appendix A of the RFC5036 ("LDP
  Label Distribution Procedures") into the code;
* Add full multipath support;
* Send label withdraws when appropriate;
* Add label withdraw/release wildcard support.

NOTE: As a result of implementing only the "Liberal Label Retention" and
"Downstream Unsolicited" modes, we will never send a label request
("Request  Never"). And that means that we can ignore the following
notification messages: "Label Request Aborted", "No Label Resources",
"No Route" and "Label Resources Available". The following algorithms
mentioned in the RFC can also be ignored: "Timeout of Deferred Label
Request", "Detect Local Label Resources Have Become Available" and
"Receive Label Abort Request".

Now, considering that we only support one combination of all modes of
operation, we can say that we have an almost complete implementation of
the protocol.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.32 2015/07/19 20:50:03 renato Exp $ */
d357 3
d413 4
d419 22
d443 2
@


1.32
log
@Remove incomplete support for unnecessary modes of  operation.

LDP has several modes of operation, it was designed in that way so it
could run on legacy equipment like ATM/FR switches with very strict
memory limitations.

For modern hardware there's no point on using either the "Conservative
Label Retention" or "Downstream On Demand" modes of operation since they
save memory at cost of blackholing traffic when routing changes. Major
vendors implement only the "Liberal Label Retention" and "Downstream
Unsolicited" modes for non ATM/FR hardware. Let's do that too.

As for using either "Independent Control" or "Ordered Control", let's
stick with the first option mainly because it's easier to implement
and because it doesn't really matter which control mode is used. For
reference, Cisco implements only "Independent Control" and Juniper only
"Ordered Control". Both modes are interoperable.

The point of supporting only one combination of all modes of operation
is that it will allow for the writing of a simpler code without removing
useful functionality.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.31 2015/07/19 18:34:32 renato Exp $ */
a233 2
			lde_imsg_compose_ldpe(IMSG_MAPPING_ADD_END,
			    imsg.hdr.peerid, 0, NULL, 0);
d259 4
a262 1
				lde_check_release(&map, nbr);
d265 7
a271 1
				lde_check_withdraw(&map, nbr);
a272 3
			default:
				log_warnx("type %d not yet handled. nbr %s",
				    imsg.hdr.type, inet_ntoa(nbr->id));
a473 25
lde_send_labelrequest(struct lde_nbr *ln, struct rt_node *rn)
{
	struct map	 map;

	/* TODO check if status of peer is OK to send requests (SLRq.2 & 6)
	 * For now assume no peer will send no-label-resource notifications */

	/* check if request is already pending */
	if (fec_find(&ln->sent_req, &rn->fec) != NULL)
		return;
	/* and try to add request to pending list */
	lde_req_add(ln, &rn->fec, 1);
	/* msgid does not matter since only one req can be pending */

	bzero(&map, sizeof(map));
	map.prefix = rn->fec.prefix;
	map.prefixlen = rn->fec.prefixlen;

	lde_imsg_compose_ldpe(IMSG_REQUEST_ADD, ln->peerid, 0,
	    &map, sizeof(map));
	lde_imsg_compose_ldpe(IMSG_REQUEST_ADD_END, ln->peerid, 0,
	    NULL, 0);
}

void
d481 1
a481 1
	 * This function skips SL.1 - 3 and SL.9 - 14 because the lable
d491 1
a491 1
	/* is there a pending request for this mapping? */
d497 2
d502 5
d511 33
d545 7
a551 4
	lde_imsg_compose_ldpe(IMSG_MAPPING_ADD, ln->peerid, 0,
	    &map, sizeof(map));
	lde_imsg_compose_ldpe(IMSG_MAPPING_ADD_END, ln->peerid, 0,
	    NULL, 0);
d560 6
a565 6
	map.prefix = rn->fec.prefix;
	map.prefixlen = rn->fec.prefixlen;
	if (label != NO_LABEL) {
		map.flags = F_MAP_OPTLABEL;
		map.label = label;
	}
d569 1
a569 2
	lde_imsg_compose_ldpe(IMSG_RELEASE_ADD_END, ln->peerid, 0,
	    NULL, 0);
a680 25
void
lde_nbr_do_mappings(struct rt_node *rn)
{
	struct lde_nbr	*ln;
	struct lde_map	*me;
	struct lde_req	*lre;

	/* This handles LMp.17-31 for lde_check_mapping() */

	RB_FOREACH(ln, nbr_tree, &lde_nbrs) {
		/* LMp.18 Did we already send a mapping to this peer? */
		me = (struct lde_map *)fec_find(&ln->sent_map, &rn->fec);
		if (me && me->label == rn->local_label)
			/* same mapping already sent, skip */
			/* TODO LMp.22-27 Loop detection check */
			continue;

		/* LMp.28 Is this from a pending request? */
		lre = (struct lde_req *)fec_find(&ln->recv_req, &rn->fec);

		lde_send_labelmapping(ln, rn);
		/* LMp.30 & 31 are not needed because labels are always added */
	}
}

d762 25
@


1.31
log
@Uninstall associated label bindings when a neighbor is down.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.30 2015/03/21 18:34:01 renato Exp $ */
a678 6

		/* Check for the only case where no mapping should be sent.
		 * This is the On Demand case of LMp.29  */
		if (ldeconf->mode & MODE_ADV_ONDEMAND && lre == NULL)
			/* adv. on demand but no req pending, skip */
			continue;
@


1.30
log
@Remove unused variables and functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.29 2014/07/12 20:16:38 krw Exp $ */
d619 4
d625 12
@


1.29
log
@Close connections when msgbuf_write() returns 0.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.28 2013/11/26 11:59:38 henning Exp $ */
a200 1
	struct timespec		 tp;
a202 1
	time_t			 now;
a216 3

	clock_gettime(CLOCK_MONOTONIC, &tp);
	now = tp.tv_sec;
@


1.28
log
@deal with msgbuf_write EAGAIN, ok gilles benno
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.26 2013/10/15 20:34:02 renato Exp $ */
d214 1
a214 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d216 2
d372 1
a372 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d374 2
@


1.27
log
@Simplify the lde_nbr_new() function.

There's no need the pass a whole lde_nbr structure as argument if we
want only the neighbor IP address.

Also, remove the lde_nbr_del() prototype on lde.h because it's a
duplicate.

OK claudio@@
@
text
@d214 1
a214 1
		if (msgbuf_write(&ibuf->w) == -1)
d370 1
a370 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.26
log
@Simplify the code by avoiding direct calls to imsg_compose_event().
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.25 2013/10/15 20:21:25 renato Exp $ */
d48 1
a48 1
struct lde_nbr	*lde_nbr_new(u_int32_t, struct lde_nbr *);
d199 1
a199 1
	struct lde_nbr		 rn, *nbr;
d313 1
a313 1
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(rn))
d315 1
a315 1
			memcpy(&rn, imsg.data, sizeof(rn));
d320 1
a320 1
			lde_nbr_new(imsg.hdr.peerid, &rn);
d594 1
a594 1
lde_nbr_new(u_int32_t peerid, struct lde_nbr *new)
d601 1
a601 1
	memcpy(nbr, new, sizeof(*nbr));
@


1.25
log
@Fix whitespace and other style issues.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.24 2013/06/04 00:45:00 claudio Exp $ */
d177 7
d328 2
a329 2
			imsg_compose_event(iev_ldpe, IMSG_CTL_END, 0,
			    imsg.hdr.pid, -1, NULL, 0);
d451 1
a451 2
	imsg_compose_event(iev_main, IMSG_KLABEL_CHANGE, 0, 0, -1,
	     &kr, sizeof(kr));
d467 1
a467 2
	imsg_compose_event(iev_main, IMSG_KLABEL_DELETE, 0, 0, -1,
	     &kr, sizeof(kr));
d489 4
a492 4
	imsg_compose_event(iev_ldpe, IMSG_REQUEST_ADD, ln->peerid, 0,
	     -1, &map, sizeof(map));
	imsg_compose_event(iev_ldpe, IMSG_REQUEST_ADD_END, ln->peerid, 0,
	     -1, NULL, 0);
d527 4
a530 4
	imsg_compose_event(iev_ldpe, IMSG_MAPPING_ADD, ln->peerid, 0,
	     -1, &map, sizeof(map));
	imsg_compose_event(iev_ldpe, IMSG_MAPPING_ADD_END, ln->peerid, 0,
	     -1, NULL, 0);
d545 5
a549 5
	
	imsg_compose_event(iev_ldpe, IMSG_RELEASE_ADD, ln->peerid, 0,
	    -1, &map, sizeof(map));
	imsg_compose_event(iev_ldpe, IMSG_RELEASE_ADD_END, ln->peerid, 0,
	    -1, NULL, 0);
d565 2
a566 2
	imsg_compose_event(iev_ldpe, IMSG_NOTIFICATION_SEND, peerid, 0,
	    -1, &nm, sizeof(nm));
@


1.24
log
@Minor adjustments in the startup of the lde and ldpe processes
The 'ldpd_process' variable should be set as soon as possible in the
initialization of each process. In that way if something goes wrong in
the initialization we will know in which process the problem happened.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.23 2013/06/03 17:01:59 claudio Exp $ */
d706 1
a706 1
	
d750 1
a750 1
	
@


1.23
log
@Remove the IMSG_NEIGHBOR_CHANGE message
Unlike OSPF, LDP has no concept of intermediate states. A session is
either operational or not operational as far as the label distribution
engine (lde) is concerned. In this case, the IMSG_NEIGHBOR_UP and
IMSG_NEIGHBOR_DOWN messages are enough.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.22 2010/10/26 12:08:14 claudio Exp $ */
d99 3
a108 3

	setproctitle("label decision engine");
	ldpd_process = PROC_LDE_ENGINE;
@


1.22
log
@Change lde_check_request(), lde_check_mapping(), lde_send_labelmapping(),
lde_send_labelrequest(), and lde_nbr_do_mappings() to follow the
algorithms defined in Appendix A of RFC 5036. Added comments and
markers for better understanding and to find missing bits.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.21 2010/10/21 08:24:06 claudio Exp $ */
d198 1
a198 1
	int			 state, shut = 0, verbose;
a317 11
		case IMSG_NEIGHBOR_CHANGE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(state))
				fatalx("invalid size of OE request");
			memcpy(&state, imsg.data, sizeof(state));

			nbr = lde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			nbr->state = state;
			break;
a591 3

	if (lde_nbr_find(peerid))
		return (NULL);
@


1.21
log
@Start implementing the missing lablemapping messages in the LDE and
fix the existing ones to correctly track outstanding request and
sent / recv mappings.
Looks good to michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.20 2010/06/30 22:15:02 claudio Exp $ */
d477 1
a477 1
lde_send_labelrequest(u_int32_t peerid, struct map *map)
d479 19
a497 3
	imsg_compose_event(iev_ldpe, IMSG_REQUEST_ADD, peerid, 0,
	     -1, map, sizeof(*map));
	imsg_compose_event(iev_ldpe, IMSG_REQUEST_ADD_END, peerid, 0,
d502 1
a502 1
lde_send_labelmapping(u_int32_t peerid, struct map *map)
d504 32
a535 3
	imsg_compose_event(iev_ldpe, IMSG_MAPPING_ADD, peerid, 0,
	     -1, map, sizeof(*map));
	imsg_compose_event(iev_ldpe, IMSG_MAPPING_ADD_END, peerid, 0,
d540 1
a540 1
lde_send_labelrelease(u_int32_t peerid, struct map *map)
d542 13
a554 3
	imsg_compose_event(iev_ldpe, IMSG_RELEASE_ADD, peerid, 0,
	    -1, map, sizeof(*map));
	imsg_compose_event(iev_ldpe, IMSG_RELEASE_ADD_END, peerid, 0,
a656 1
	struct map	 map;
d658 2
a659 3
	struct lde_map	*lm;
	struct lde_req	*lr;
	struct rt_lsp	*rl;
d661 1
a661 3
	map.label = rn->local_label;
	map.prefix = rn->fec.prefix;
	map.prefixlen = rn->fec.prefixlen;
d664 3
a666 3
		/* Did we already send a mapping to this peer? */
		lm = (struct lde_map *)fec_find(&ln->sent_map, &rn->fec);
		if (lm && lm->label == map.label) {
d668 1
a669 1
		}
d671 6
a676 3
		/* Is this from a pending request? */
		lr = (struct lde_req *)fec_find(&ln->recv_req, &rn->fec);
		if (ldeconf->mode & MODE_ADV_ONDEMAND && lr == NULL)
d680 2
a681 24
		if (ldeconf->mode & MODE_DIST_ORDERED) {
			/* ordered mode needs the downstream path to be
			 * ready before we can send the mapping upstream */
			LIST_FOREACH(rl, &rn->lsp, entry) {
				if (rl->remote_label != NO_LABEL)
					/* at least on LSP exists */
					break;
			}
			if (rl == NULL)
				continue;
		}

		if (lr) {
			/* set label request msg id in the mapping response. */
			map.requestid = lr->msgid;
			map.flags = F_MAP_REQ_ID;
			fec_remove(&ln->sent_req, &lr->fec);
		}

		if (lm == NULL)
			lm = lde_map_add(ln, rn, 1);
		lm->label = map.label;

		lde_send_labelmapping(ln->peerid, &map);
d702 1
d731 35
@


1.20
log
@Make it possible to store multiple LSP to a FEC. This is another step to
handle multipath routes in MPLS.
Looks good to michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.19 2010/06/30 05:21:38 claudio Exp $ */
d222 6
a227 1
			rt_snap(imsg.hdr.peerid);
d229 1
d259 3
d615 1
a615 1
		if (lm && lm->label == map.label)
d618 1
d630 3
a632 3
				/* no remote-label, skip */
				if (rl->remote_label == NO_LABEL)
					continue;
d645 2
a646 13
		if (lm == NULL) {
			lm = calloc(1, sizeof(*lm));
			if (lm == NULL)
				fatal("lde_nbr_do_mappings");
			lm->fec = rn->fec;
			lm->nexthop = ln;

			LIST_INSERT_HEAD(&rn->upstream, lm, entry);
			if (fec_insert(&ln->sent_map, &lm->fec))
				log_warnx("failed to add %s/%u to sent map",
				    inet_ntoa(lm->fec.prefix),
				    lm->fec.prefixlen);
		}
d678 11
@


1.19
log
@Kill IMSG_KLABEL_INSERT and all the related functions around it.
IMSG_KLABEL_CHANGE is smart enough to know when something is a change
or an insert.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.18 2010/06/30 01:47:11 claudio Exp $ */
d434 1
a434 1
lde_send_change_klabel(struct rt_node *r)
d439 6
a444 5
	kr.prefix.s_addr = r->fec.prefix.s_addr;
	kr.prefixlen = r->fec.prefixlen;
	kr.nexthop.s_addr = r->nexthop.s_addr;
	kr.local_label = r->local_label;
	kr.remote_label = r->remote_label;
d451 1
a451 1
lde_send_delete_klabel(struct rt_node *r)
d456 6
a461 2
	kr.prefix.s_addr = r->fec.prefix.s_addr;
	kr.prefixlen = r->fec.prefixlen;
d593 1
d597 1
a597 1
	struct map	 map;
d619 6
a624 3
			if (rn->nexthop.s_addr != INADDR_ANY &&
			    rn->remote_label == NO_LABEL)
				/* not local FEC but no remote-label, skip */
d652 27
@


1.18
log
@Switch prefix in struct map to a struct in_addr instead of a u_int32_t.
Needed for further clean etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.17 2010/06/09 13:32:15 claudio Exp $ */
a430 16
}

void
lde_send_insert_klabel(struct rt_node *r)
{
	struct kroute	kr;

	bzero(&kr, sizeof(kr));
	kr.prefix.s_addr = r->fec.prefix.s_addr;
	kr.prefixlen = r->fec.prefixlen;
	kr.nexthop.s_addr = r->nexthop.s_addr;
	kr.local_label = r->local_label;
	kr.remote_label = r->remote_label;

	imsg_compose_event(iev_main, IMSG_KLABEL_INSERT, 0, 0, -1,
	     &kr, sizeof(kr));
@


1.17
log
@More useful warning message.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.16 2010/06/07 13:24:23 claudio Exp $ */
d610 1
a610 1
	map.prefix = rn->fec.prefix.s_addr;
@


1.16
log
@Store all labels in ldpd in host byte order without any additional shifting.
Add the necessary ntohl() and shifts in various places and cleanup the byte
order mess we had before. michele@@ agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.15 2010/06/02 11:56:29 claudio Exp $ */
d254 2
a255 1
				log_warnx("not yet");
@


1.15
log
@Start reworking the LDE. Implement a FEC RB tree that can be used for the
route table and the per neighbor request and mapping lists.
The received and sent mappings are added to the per neighbor RB tree and
additionally linked to the route table. This makes lookups, etc. a lot
easier. While there flip the neighbor hash list over to a RB tree.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.14 2010/05/25 13:29:45 claudio Exp $ */
d429 1
a429 1
	return (htonl(label << MPLS_LABEL_OFFSET));
d608 1
a608 2
	map.label = (ntohl(rn->local_label) & MPLS_LABEL_MASK) >>
	    MPLS_LABEL_OFFSET;
@


1.14
log
@Remove another leftover from ospfd. ldpd does not have a concept of ext_tag
and so there is no need to carry ext_tag and rtlabels around.
"Yes! kill kill kill" michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.13 2010/05/25 09:35:45 claudio Exp $ */
d25 1
a46 2
void		 lde_nbr_init(u_int32_t);
void		 lde_nbr_free(void);
d50 1
d52 1
a53 2
void		 lde_req_list_free(struct lde_nbr *);
void		 lde_map_list_free(struct lde_nbr *);
a115 1
	lde_nbr_init(NBR_HASHSIZE);
a149 2
	rt_init();

d164 1
a166 2
	lde_nbr_free();

d423 1
a423 1
lde_router_id(void)
d425 5
a429 1
	return (ldeconf->rtr_id.s_addr);
d438 2
a439 1
	kr.prefix.s_addr = r->prefix.s_addr;
a442 1
	kr.prefixlen = r->prefixlen;
d454 2
a455 1
	kr.prefix.s_addr = r->prefix.s_addr;
a458 1
	kr.prefixlen = r->prefixlen;
d470 2
a471 2
	kr.prefix.s_addr = r->prefix.s_addr;
	kr.prefixlen = r->prefixlen;
d521 1
a521 20
LIST_HEAD(lde_nbr_head, lde_nbr);

struct nbr_table {
	struct lde_nbr_head	*hashtbl;
	u_int32_t		 hashmask;
} ldenbrtable;

#define LDE_NBR_HASH(x)		\
	&ldenbrtable.hashtbl[(x) & ldenbrtable.hashmask]

void
lde_nbr_init(u_int32_t hashsize)
{
	u_int32_t		 hs, i;

	for (hs = 1; hs < hashsize; hs <<= 1)
		;
	ldenbrtable.hashtbl = calloc(hs, sizeof(struct lde_nbr_head));
	if (ldenbrtable.hashtbl == NULL)
		fatal("lde_nbr_init");
d523 3
a525 2
	for (i = 0; i < hs; i++)
		LIST_INIT(&ldenbrtable.hashtbl[i]);
d527 1
a527 2
	ldenbrtable.hashmask = hs - 1;
}
d529 2
a530 2
void
lde_nbr_free(void)
d532 1
a532 1
	free(ldenbrtable.hashtbl);
d538 1
a538 2
	struct lde_nbr_head	*head;
	struct lde_nbr		*nbr;
d540 1
a540 1
	head = LDE_NBR_HASH(peerid);
d542 1
a542 6
	LIST_FOREACH(nbr, head, hash) {
		if (nbr->peerid == peerid)
			return (nbr);
	}

	return (NULL);
d548 1
a548 3
	struct lde_nbr_head	*head;
	struct lde_nbr		*nbr;
	struct iface		*iface;
d558 5
d565 3
a567 14
	TAILQ_INIT(&nbr->req_list);
	TAILQ_INIT(&nbr->sent_map_list);
	TAILQ_INIT(&nbr->recv_map_list);
	TAILQ_INIT(&nbr->labels_list);

	head = LDE_NBR_HASH(peerid);
	LIST_INSERT_HEAD(head, nbr, hash);

	LIST_FOREACH(iface, &ldeconf->iface_list, entry) {
		if (iface->ifindex == new->ifindex) {
			LIST_INSERT_HEAD(&iface->lde_nbr_list, nbr, entry);
			break;
		}
	}
a577 2
	lde_req_list_free(nbr);
	lde_map_list_free(nbr);
a578 1
	lde_label_list_free(nbr);
d580 7
a586 2
	LIST_REMOVE(nbr, hash);
	LIST_REMOVE(nbr, entry);
d591 79
a731 27
void
lde_req_list_free(struct lde_nbr *nbr)
{
	struct lde_req_entry	*req;

	while ((req = TAILQ_FIRST(&nbr->req_list)) != NULL) {
		TAILQ_REMOVE(&nbr->req_list, req, entry);
		free(req);
	}
}

void
lde_map_list_free(struct lde_nbr *nbr)
{
	struct lde_map_entry	*map;

	while ((map = TAILQ_FIRST(&nbr->recv_map_list)) != NULL) {
		TAILQ_REMOVE(&nbr->recv_map_list, map, entry);
		free(map);
	}

	while ((map = TAILQ_FIRST(&nbr->sent_map_list)) != NULL) {
		TAILQ_REMOVE(&nbr->sent_map_list, map, entry);
		free(map);
	}
}

a734 1
	struct iface	*iface;
d737 3
a739 5
	LIST_FOREACH(iface, &ldeconf->iface_list, entry) {
		LIST_FOREACH(ln, &iface->lde_nbr_list, entry) {
			if (lde_address_find(ln, &address) != NULL)
				return (ln);
		}
@


1.13
log
@Add upcomming IMSG_LABEL_RELEASE, IMSG_LABEL_WITHDRAW and IMSG_LABEL_ABORT.
Add missing bits to struct map and restructure/simplify the lde.c imsg
code.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.12 2010/05/19 15:28:51 claudio Exp $ */
a443 1
	kr.ext_tag = r->ext_tag;
a459 1
	kr.ext_tag = r->ext_tag;
@


1.12
log
@Remove yet another ospf leftover that is not needed here. This time
neighbor self and all the madness surrounding this amazing concept.
LDP is not self aware so there is no need for this.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.11 2010/05/11 15:01:46 claudio Exp $ */
a225 14
		case IMSG_LABEL_MAPPING:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(map))
				fatalx("invalid size of OE request");
			memcpy(&map, imsg.data, sizeof(map));

			nbr = lde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL) {
				log_debug("lde_dispatch_imsg: cannot find "
				    "lde neighbor");
				return;
			}

			lde_check_mapping(&map, nbr);
			break;
a230 1

d232 1
d234 3
d248 13
a260 1
			lde_check_request(&map, nbr);
@


1.11
log
@Kill IMSG_RECONF_AREA. LDP does not have a concept of areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.10 2010/03/03 10:17:05 claudio Exp $ */
a58 1
struct lde_nbr		*nbrself;
a535 1
	struct lde_nbr_head	*head;
a547 10

	if ((nbrself = calloc(1, sizeof(*nbrself))) == NULL)
		fatal("lde_nbr_init");

	nbrself->id.s_addr = lde_router_id();
	nbrself->peerid = NBR_IDSELF;
	nbrself->state = NBR_STA_DOWN;
	nbrself->self = 1;
	head = LDE_NBR_HASH(NBR_IDSELF);
	LIST_INSERT_HEAD(head, nbrself, hash);
a552 1
	free(nbrself);
@


1.10
log
@Rework the kroute code by stealing some code from ospfd and massaging it
a lot more. Main reason for this is to add priority support. Additionally
add some additional NO_LABEL fixes.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.9 2010/03/01 09:05:07 claudio Exp $ */
a405 2
			break;
		case IMSG_RECONF_AREA:
@


1.9
log
@nitpicking, NULL instead of 0 in lde_imsg_compose_ldpe() call.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.8 2010/02/19 12:49:21 claudio Exp $ */
a356 1
	struct rroute		 rr;
d381 1
a381 1
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(rr)) {
d386 1
a386 3
			memcpy(&rr, imsg.data, sizeof(rr));

			lde_kernel_insert(&rr.kr);
d388 1
a398 1

@


1.8
log
@If a neighbor goes down we need to cleanup the LIB from all FEC that point
via that neighbor. Fixes a use after free and an additional NULL dereference
in a log_debug is fixed as well.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.7 2009/11/02 20:34:58 claudio Exp $ */
d245 1
a245 1
			    imsg.hdr.peerid, 0, 0, 0);
@


1.7
log
@More IMSG_CTL_LOG_VERBOSE, still doing the same toggeling of log_debug().
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.6 2009/09/28 09:48:46 michele Exp $ */
d610 1
d625 17
a728 16
}

void
lde_nbr_del(struct lde_nbr *nbr)
{
	if (nbr == NULL)
		return;

	lde_req_list_free(nbr);
	lde_map_list_free(nbr);
	lde_address_list_free(nbr);

	LIST_REMOVE(nbr, hash);
	LIST_REMOVE(nbr, entry);

	free(nbr);
@


1.6
log
@When a route is deleted, ldpd should remove labels associated with it from
lfib (the kernel lib) but not from the lib. These could be used later on when
the route come back.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.5 2009/08/01 13:30:55 michele Exp $ */
d204 1
a204 1
	int			 state, shut = 0;
d329 5
@


1.5
log
@Pass the right size of the structure "map" to the ldpd engine.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.4 2009/07/08 18:59:29 michele Exp $ */
a387 9
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(rr)) {
				log_warnx("lde_dispatch_parent: "
				    "wrong imsg len");
				break;
			}
			memcpy(&rr, imsg.data, sizeof(rr));

			break;
		case IMSG_KROUTE_GET:
d395 2
a396 8
/*			if ((rn = rt_find(kr.prefix.s_addr, kr.prefixlen,
			    DT_NET)) != NULL)
				lde_send_change_kroute(rn);
			else*/
				/* should not happen */
				imsg_compose_event(iev_main,
				    IMSG_KLABEL_DELETE, 0,
				    0, -1, &kr, sizeof(kr));
@


1.4
log
@Detect nexthop change.
React installing the label associated with the new nexthop
in the kernel routing table.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.3 2009/06/06 08:09:43 pyr Exp $ */
d499 1
a499 1
	     -1, map, sizeof(map));
d508 1
a508 1
	     -1, map, sizeof(map));
d517 1
a517 1
	    -1, map, sizeof(map));
@


1.3
log
@make ldpd imsg-in-a-lib ready too.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.2 2009/06/05 22:34:45 michele Exp $ */
d384 1
a384 1
			lde_insert(&rr.kr);
@


1.2
log
@Correctly send notification messages when errors occur.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d57 2
a58 2
struct imsgbuf		*ibuf_ldpe;
struct imsgbuf		*ibuf_main;
d134 2
a135 2
	if ((ibuf_ldpe = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
d137 4
a140 2
	imsg_init(ibuf_ldpe, pipe_ldpe2lde[1], lde_dispatch_imsg);
	imsg_init(ibuf_main, pipe_parent2lde[1], lde_dispatch_parent);
d143 9
a151 9
	ibuf_ldpe->events = EV_READ;
	event_set(&ibuf_ldpe->ev, ibuf_ldpe->fd, ibuf_ldpe->events,
	    ibuf_ldpe->handler, ibuf_ldpe);
	event_add(&ibuf_ldpe->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);
d173 4
a176 4
	msgbuf_clear(&ibuf_ldpe->w);
	free(ibuf_ldpe);
	msgbuf_clear(&ibuf_main->w);
	free(ibuf_main);
d187 2
a188 1
	return (imsg_compose(ibuf_ldpe, type, peerid, pid, data, datalen));
d195 2
a196 1
	struct imsgbuf		*ibuf = bula;
d327 2
a328 2
			imsg_compose(ibuf_ldpe, IMSG_CTL_END, 0, imsg.hdr.pid,
			    NULL, 0);
d338 1
a338 1
		imsg_event_add(ibuf);
d341 1
a341 1
		event_del(&ibuf->ev);
d353 2
a354 1
	struct imsgbuf		*ibuf = bula;
d409 3
a411 2
				imsg_compose(ibuf_main, IMSG_KLABEL_DELETE, 0,
				    0, &kr, sizeof(kr));
d434 1
a434 1
		imsg_event_add(ibuf);
d437 1
a437 1
		event_del(&ibuf->ev);
d461 2
a462 1
	imsg_compose(ibuf_main, IMSG_KLABEL_INSERT, 0, 0, &kr, sizeof(kr));
d478 2
a479 1
	imsg_compose(ibuf_main, IMSG_KLABEL_CHANGE, 0, 0, &kr, sizeof(kr));
d491 2
a492 1
	imsg_compose(ibuf_main, IMSG_KLABEL_DELETE, 0, 0, &kr, sizeof(kr));
d498 4
a501 2
	imsg_compose(ibuf_ldpe, IMSG_REQUEST_ADD, peerid, 0, map, sizeof(map));
	imsg_compose(ibuf_ldpe, IMSG_REQUEST_ADD_END, peerid, 0, NULL, 0);
d507 4
a510 2
	imsg_compose(ibuf_ldpe, IMSG_MAPPING_ADD, peerid, 0, map, sizeof(map));
	imsg_compose(ibuf_ldpe, IMSG_MAPPING_ADD_END, peerid, 0, NULL, 0);
d516 4
a519 2
	imsg_compose(ibuf_ldpe, IMSG_RELEASE_ADD, peerid, 0, map, sizeof(map));
	imsg_compose(ibuf_ldpe, IMSG_RELEASE_ADD_END, peerid, 0, NULL, 0);
d535 2
a536 2
	imsg_compose(ibuf_ldpe, IMSG_NOTIFICATION_SEND, peerid, 0, &nm,
	    sizeof(nm));
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d508 2
a509 1
lde_send_notification(u_int32_t peerid, u_int32_t code)
d511 11
a521 2
	imsg_compose(ibuf_ldpe, IMSG_NOTIFICATION_SEND, peerid, 0, &code,
	    sizeof(u_int32_t));
@

