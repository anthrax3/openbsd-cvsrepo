head	1.74;
access;
symbols
	OPENBSD_6_2:1.74.0.2
	OPENBSD_6_2_BASE:1.74
	OPENBSD_6_1:1.74.0.4
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.67.0.2
	OPENBSD_6_0_BASE:1.67
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.74
date	2017.03.04.00.21.48;	author renato;	state Exp;
branches;
next	1.73;
commitid	luKtDak9oSLriyOU;

1.73
date	2017.03.03.23.41.27;	author renato;	state Exp;
branches;
next	1.72;
commitid	lvj5kMm2TzZDSXqr;

1.72
date	2017.03.03.23.30.57;	author renato;	state Exp;
branches;
next	1.71;
commitid	mvwmKJi9MZW7VKOy;

1.71
date	2017.01.20.12.19.18;	author benno;	state Exp;
branches;
next	1.70;
commitid	qrjsXLNhiS0G91tf;

1.70
date	2016.09.02.17.10.34;	author renato;	state Exp;
branches;
next	1.69;
commitid	azy8IeWn9oiqxwik;

1.69
date	2016.09.02.17.03.24;	author renato;	state Exp;
branches;
next	1.68;
commitid	oHghF3eNQnFZklxo;

1.68
date	2016.08.08.21.42.13;	author renato;	state Exp;
branches;
next	1.67;
commitid	06qO3EMtrAUwDN60;

1.67
date	2016.06.18.17.31.32;	author renato;	state Exp;
branches;
next	1.66;
commitid	Ou0pUplgSHSojMsH;

1.66
date	2016.06.13.23.01.37;	author renato;	state Exp;
branches;
next	1.65;
commitid	6Kn577N67pcmgY5D;

1.65
date	2016.06.13.20.15.58;	author renato;	state Exp;
branches;
next	1.64;
commitid	tHSOojUwG1vQtHLQ;

1.64
date	2016.06.09.17.26.32;	author renato;	state Exp;
branches;
next	1.63;
commitid	iKrQLOonXcGPkDwb;

1.63
date	2016.06.08.23.30.07;	author renato;	state Exp;
branches;
next	1.62;
commitid	HVCFOK1E6L5k34rQ;

1.62
date	2016.06.06.16.42.41;	author renato;	state Exp;
branches;
next	1.61;
commitid	1iRJyXrhohyNUnrn;

1.61
date	2016.05.23.19.16.00;	author renato;	state Exp;
branches;
next	1.60;
commitid	wKGrbgE7dtbu6ic6;

1.60
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.59;
commitid	TLlfi1Pk0Z97z8HM;

1.59
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.58;
commitid	AQBoOveMRKjtVfFv;

1.58
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.57;
commitid	t07H0Mk6WGdVWB0W;

1.57
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.56;
commitid	D7VvXbswyzx5Ahb2;

1.56
date	2016.05.23.18.55.21;	author renato;	state Exp;
branches;
next	1.55;
commitid	85kONxXVWUqI2Jhb;

1.55
date	2016.05.23.18.41.59;	author renato;	state Exp;
branches;
next	1.54;
commitid	zjb4P8L4wSROotP5;

1.54
date	2016.05.23.18.40.15;	author renato;	state Exp;
branches;
next	1.53;
commitid	LYl0nXLaUb8GwBRC;

1.53
date	2016.05.23.18.36.55;	author renato;	state Exp;
branches;
next	1.52;
commitid	Ba6Sgjw90tNqVKLo;

1.52
date	2016.05.23.18.35.10;	author renato;	state Exp;
branches;
next	1.51;
commitid	FN04z1XBSIOURhwg;

1.51
date	2016.05.23.18.33.56;	author renato;	state Exp;
branches;
next	1.50;
commitid	YK3Z5X8iSxlfPhoT;

1.50
date	2016.05.23.18.25.30;	author renato;	state Exp;
branches;
next	1.49;
commitid	CR4Vr5IW5Uyetn11;

1.49
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.48;
commitid	VpAym8dVR6eY4drQ;

1.48
date	2016.05.23.15.51.36;	author renato;	state Exp;
branches;
next	1.47;
commitid	4SA6xpqUeqf2FhUJ;

1.47
date	2016.05.23.15.47.24;	author renato;	state Exp;
branches;
next	1.46;
commitid	Eng7dm0NElMq9Yi3;

1.46
date	2016.05.23.15.43.11;	author renato;	state Exp;
branches;
next	1.45;
commitid	weS0xzAgWBV4f0dh;

1.45
date	2016.05.23.15.20.21;	author renato;	state Exp;
branches;
next	1.44;
commitid	a7hHpMh5LFrAzM40;

1.44
date	2016.05.23.15.14.07;	author renato;	state Exp;
branches;
next	1.43;
commitid	l3e6PhvoAh8C7elc;

1.43
date	2016.05.23.14.59.50;	author renato;	state Exp;
branches;
next	1.42;
commitid	Zbc4sTxSIKWZvMzM;

1.42
date	2016.05.23.14.55.41;	author renato;	state Exp;
branches;
next	1.41;
commitid	BMjojZPSfj43vinq;

1.41
date	2015.12.05.13.11.48;	author claudio;	state Exp;
branches;
next	1.40;
commitid	c8UgZO1MU5iqaNd3;

1.40
date	2015.10.23.10.10.17;	author renato;	state Exp;
branches;
next	1.39;
commitid	h0sld05bAD8ou8Ag;

1.39
date	2015.07.21.05.04.12;	author renato;	state Exp;
branches;
next	1.38;
commitid	xx9kMymPWvtBzJZ5;

1.38
date	2015.07.21.05.02.57;	author renato;	state Exp;
branches;
next	1.37;
commitid	HgM2vLtnZjFgxhpg;

1.37
date	2015.07.21.04.58.48;	author renato;	state Exp;
branches;
next	1.36;
commitid	zvZYEuz9wxbvZ2db;

1.36
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.35;
commitid	puLLDX1XPNc3GxB9;

1.35
date	2015.07.21.04.45.21;	author renato;	state Exp;
branches;
next	1.34;
commitid	DOwVSvrpKsgJLpe1;

1.34
date	2015.07.21.04.43.28;	author renato;	state Exp;
branches;
next	1.33;
commitid	QaTrdqMa9i0CUoyW;

1.33
date	2015.07.21.04.39.28;	author renato;	state Exp;
branches;
next	1.32;
commitid	KR83ZYzpLqbp9L95;

1.32
date	2015.07.19.21.01.56;	author renato;	state Exp;
branches;
next	1.31;
commitid	3CZZKtMxWnvDQhpO;

1.31
date	2015.07.19.20.54.17;	author renato;	state Exp;
branches;
next	1.30;
commitid	AcGJH529uphBS2D2;

1.30
date	2015.03.21.18.32.01;	author renato;	state Exp;
branches;
next	1.29;
commitid	Q890u5RO8xyMjkAO;

1.29
date	2015.03.21.18.29.22;	author renato;	state Exp;
branches;
next	1.28;
commitid	Wgvwy341dQIEt2wY;

1.28
date	2015.03.21.17.33.10;	author renato;	state Exp;
branches;
next	1.27;
commitid	QpeopzghLxHVsa8S;

1.27
date	2015.02.10.01.03.54;	author claudio;	state Exp;
branches;
next	1.26;
commitid	cLo6tZgL6zd4cYfb;

1.26
date	2015.02.09.11.54.24;	author claudio;	state Exp;
branches;
next	1.25;
commitid	LTeEOygtHEq8pPcX;

1.25
date	2014.11.18.20.54.28;	author krw;	state Exp;
branches;
next	1.24;
commitid	yCis8OrOsfixbKpI;

1.24
date	2014.07.12.20.16.38;	author krw;	state Exp;
branches;
next	1.23;
commitid	lIxCxHhVEpsmXOdi;

1.23
date	2013.11.26.11.59.38;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2013.10.17.17.52.21;	author renato;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.04.02.25.28;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.04.00.45.00;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.04.00.41.18;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.03.16.53.49;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2013.06.01.19.01.32;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2012.04.12.17.33.43;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2011.01.10.12.28.25;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2010.10.26.12.03.11;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.01.13.54.54;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.08.09.41.05;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.19.15.28.51;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.11.15.01.46;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.04.29.12.09.28;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.15.15.04.23;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.25.17.40.46;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.18.10.50.14;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.06.08.09.43;	author pyr;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.22.34.45;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Send VPLS MAC withdrawals.

RFC 4762 says that MAC address withdrawal messages can be used to
improve convergence time in VPLS networks. This patch makes ldpd send
MAC withdrawals whenever a non-pseudowire interface pertaining to a
VPLS goes down. The processing of received MAC withdrawals will be
implemented later.
@
text
@/*	$OpenBSD: ldpe.c,v 1.73 2017/03/03 23:41:27 renato Exp $ */

/*
 * Copyright (c) 2013, 2016 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2008 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <pwd.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <errno.h>

#include "ldpd.h"
#include "ldpe.h"
#include "lde.h"
#include "control.h"
#include "log.h"

static void	 ldpe_sig_handler(int, short, void *);
static __dead void ldpe_shutdown(void);
static void	 ldpe_dispatch_main(int, short, void *);
static void	 ldpe_dispatch_lde(int, short, void *);
static void	 ldpe_dispatch_pfkey(int, short, void *);
static void	 ldpe_setup_sockets(int, int, int, int);
static void	 ldpe_close_sockets(int);
static void	 ldpe_iface_af_ctl(struct ctl_conn *, int, unsigned int);

struct ldpd_conf	*leconf;
struct ldpd_sysdep	 sysdep;

static struct imsgev	*iev_main;
static struct imsgev	*iev_lde;
static struct event	 pfkey_ev;

/* ARGSUSED */
static void
ldpe_sig_handler(int sig, short event, void *bula)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		ldpe_shutdown();
		/* NOTREACHED */
	default:
		fatalx("unexpected signal");
	}
}

/* label distribution protocol engine */
void
ldpe(int debug, int verbose, char *sockname)
{
	struct passwd		*pw;
	struct event		 ev_sigint, ev_sigterm;

	leconf = config_new_empty();

	log_init(debug);
	log_verbose(verbose);

	setproctitle("ldp engine");
	ldpd_process = PROC_LDP_ENGINE;
	log_procname = log_procnames[ldpd_process];

	/* create ldpd control socket outside chroot */
	global.csock = sockname;
	if (control_init(global.csock) == -1)
		fatalx("control socket setup failed");

	LIST_INIT(&global.addr_list);
	LIST_INIT(&global.adj_list);
	TAILQ_INIT(&global.pending_conns);
	if (inet_pton(AF_INET, AllRouters_v4, &global.mcast_addr_v4) != 1)
		fatal("inet_pton");
	if (inet_pton(AF_INET6, AllRouters_v6, &global.mcast_addr_v6) != 1)
		fatal("inet_pton");
	global.pfkeysock = pfkey_init();

	if ((pw = getpwnam(LDPD_USER)) == NULL)
		fatal("getpwnam");

	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	if (pledge("stdio cpath inet mcast recvfd", NULL) == -1)
		fatal("pledge");

	event_init();
	accept_init();

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, ldpe_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, ldpe_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	/* setup pipe and event handler to the parent process */
	if ((iev_main = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_main->ibuf, 3);
	iev_main->handler = ldpe_dispatch_main;
	iev_main->events = EV_READ;
	event_set(&iev_main->ev, iev_main->ibuf.fd, iev_main->events,
	    iev_main->handler, iev_main);
	event_add(&iev_main->ev, NULL);

	if (sysdep.no_pfkey == 0) {
		event_set(&pfkey_ev, global.pfkeysock, EV_READ | EV_PERSIST,
		    ldpe_dispatch_pfkey, NULL);
		event_add(&pfkey_ev, NULL);
	}

	/* mark sockets as closed */
	global.ipv4.ldp_disc_socket = -1;
	global.ipv4.ldp_edisc_socket = -1;
	global.ipv4.ldp_session_socket = -1;
	global.ipv6.ldp_disc_socket = -1;
	global.ipv6.ldp_edisc_socket = -1;
	global.ipv6.ldp_session_socket = -1;

	/* listen on ldpd control socket */
	TAILQ_INIT(&ctl_conns);
	control_listen();

	if ((pkt_ptr = calloc(1, IBUF_READ_SIZE)) == NULL)
		fatal(__func__);

	event_dispatch();

	ldpe_shutdown();
}

static __dead void
ldpe_shutdown(void)
{
	struct if_addr		*if_addr;
	struct adj		*adj;

	/* close pipes */
	msgbuf_write(&iev_lde->ibuf.w);
	msgbuf_clear(&iev_lde->ibuf.w);
	close(iev_lde->ibuf.fd);
	msgbuf_write(&iev_main->ibuf.w);
	msgbuf_clear(&iev_main->ibuf.w);
	close(iev_main->ibuf.fd);

	control_cleanup(global.csock);
	config_clear(leconf);

	if (sysdep.no_pfkey == 0) {
		event_del(&pfkey_ev);
		close(global.pfkeysock);
	}
	ldpe_close_sockets(AF_INET);
	ldpe_close_sockets(AF_INET6);

	/* remove addresses from global list */
	while ((if_addr = LIST_FIRST(&global.addr_list)) != NULL) {
		LIST_REMOVE(if_addr, entry);
		free(if_addr);
	}
	while ((adj = LIST_FIRST(&global.adj_list)) != NULL)
		adj_del(adj, S_SHUTDOWN);

	/* clean up */
	free(iev_lde);
	free(iev_main);
	free(pkt_ptr);

	log_info("ldp engine exiting");
	exit(0);
}

/* imesg */
int
ldpe_imsg_compose_parent(int type, pid_t pid, void *data, uint16_t datalen)
{
	return (imsg_compose_event(iev_main, type, 0, pid, -1, data, datalen));
}

int
ldpe_imsg_compose_lde(int type, uint32_t peerid, pid_t pid, void *data,
    uint16_t datalen)
{
	return (imsg_compose_event(iev_lde, type, peerid, pid, -1,
	    data, datalen));
}

/* ARGSUSED */
static void
ldpe_dispatch_main(int fd, short event, void *bula)
{
	static struct ldpd_conf	*nconf;
	struct iface		*niface;
	struct tnbr		*ntnbr;
	struct nbr_params	*nnbrp;
	static struct l2vpn	*l2vpn, *nl2vpn;
	struct l2vpn_if		*lif = NULL, *nlif;
	struct l2vpn_pw		*npw;
	struct imsg		 imsg;
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct iface		*iface = NULL;
	struct kif		*kif;
	int			 af;
	enum socket_type	*socket_type;
	static int		 disc_socket = -1;
	static int		 edisc_socket = -1;
	static int		 session_socket = -1;
	struct nbr		*nbr;
	struct nbr_params	*nbrp;
	int			 n, shut = 0;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("ldpe_dispatch_main: msgbuf_write");
		if (n == 0)
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("ldpe_dispatch_main: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_IFSTATUS:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct kif))
				fatalx("IFSTATUS imsg with wrong len");
			kif = imsg.data;

			iface = if_lookup(leconf, kif->ifindex);
			if (iface) {
				iface->flags = kif->flags;
				iface->linkstate = kif->link_state;
				if_update(iface, AF_UNSPEC);
				break;
			}

			LIST_FOREACH(l2vpn, &leconf->l2vpn_list, entry) {
				lif = l2vpn_if_find(l2vpn, kif->ifindex);
				if (lif) {
					lif->flags = kif->flags;
					lif->linkstate = kif->link_state;
					memcpy(lif->mac, kif->mac,
					    sizeof(lif->mac));
					l2vpn_if_update(lif);
					break;
				}
			}
			break;
		case IMSG_NEWADDR:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct kaddr))
				fatalx("NEWADDR imsg with wrong len");

			if_addr_add(imsg.data);
			break;
		case IMSG_DELADDR:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct kaddr))
				fatalx("DELADDR imsg with wrong len");

			if_addr_del(imsg.data);
			break;
		case IMSG_SOCKET_IPC:
			if (iev_lde) {
				log_warnx("%s: received unexpected imsg fd "
				    "to lde", __func__);
				break;
			}
			if ((fd = imsg.fd) == -1) {
				log_warnx("%s: expected to receive imsg fd to "
				    "lde but didn't receive any", __func__);
				break;
			}

			if ((iev_lde = malloc(sizeof(struct imsgev))) == NULL)
				fatal(NULL);
			imsg_init(&iev_lde->ibuf, fd);
			iev_lde->handler = ldpe_dispatch_lde;
			iev_lde->events = EV_READ;
			event_set(&iev_lde->ev, iev_lde->ibuf.fd,
			    iev_lde->events, iev_lde->handler, iev_lde);
			event_add(&iev_lde->ev, NULL);
			break;
		case IMSG_CLOSE_SOCKETS:
			af = imsg.hdr.peerid;

			RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
				if (nbr->af != af)
					continue;
				session_shutdown(nbr, S_SHUTDOWN, 0, 0);
				pfkey_remove(nbr);
			}
			ldpe_close_sockets(af);
			if_update_all(af);
			tnbr_update_all(af);

			disc_socket = -1;
			edisc_socket = -1;
			session_socket = -1;
			if ((ldp_af_conf_get(leconf, af))->flags &
			    F_LDPD_AF_ENABLED)
				ldpe_imsg_compose_parent(IMSG_REQUEST_SOCKETS,
				    af, NULL, 0);
			break;
		case IMSG_SOCKET_NET:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(enum socket_type))
				fatalx("SOCKET_NET imsg with wrong len");
			socket_type = imsg.data;

			switch (*socket_type) {
			case LDP_SOCKET_DISC:
				disc_socket = imsg.fd;
				break;
			case LDP_SOCKET_EDISC:
				edisc_socket = imsg.fd;
				break;
			case LDP_SOCKET_SESSION:
				session_socket = imsg.fd;
				break;
			}
			break;
		case IMSG_SETUP_SOCKETS:
			af = imsg.hdr.peerid;
			if (disc_socket == -1 || edisc_socket == -1 ||
			    session_socket == -1) {
				if (disc_socket != -1)
					close(disc_socket);
				if (edisc_socket != -1)
					close(edisc_socket);
				if (session_socket != -1)
					close(session_socket);
				break;
			}

			ldpe_setup_sockets(af, disc_socket, edisc_socket,
			    session_socket);
			if_update_all(af);
			tnbr_update_all(af);
			RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
				if (nbr->af != af)
					continue;
				nbr->laddr = (ldp_af_conf_get(leconf,
				    af))->trans_addr;
				nbrp = nbr_params_find(leconf, nbr->id);
				if (nbrp && pfkey_establish(nbr, nbrp) == -1)
					fatalx("pfkey setup failed");
				if (nbr_session_active_role(nbr))
					nbr_establish_connection(nbr);
			}
			break;
		case IMSG_RECONF_CONF:
			if ((nconf = malloc(sizeof(struct ldpd_conf))) ==
			    NULL)
				fatal(NULL);
			memcpy(nconf, imsg.data, sizeof(struct ldpd_conf));

			LIST_INIT(&nconf->iface_list);
			LIST_INIT(&nconf->tnbr_list);
			LIST_INIT(&nconf->nbrp_list);
			LIST_INIT(&nconf->l2vpn_list);
			break;
		case IMSG_RECONF_IFACE:
			if ((niface = malloc(sizeof(struct iface))) == NULL)
				fatal(NULL);
			memcpy(niface, imsg.data, sizeof(struct iface));

			LIST_INIT(&niface->addr_list);
			LIST_INIT(&niface->ipv4.adj_list);
			LIST_INIT(&niface->ipv6.adj_list);
			niface->ipv4.iface = niface;
			niface->ipv6.iface = niface;

			LIST_INSERT_HEAD(&nconf->iface_list, niface, entry);
			break;
		case IMSG_RECONF_TNBR:
			if ((ntnbr = malloc(sizeof(struct tnbr))) == NULL)
				fatal(NULL);
			memcpy(ntnbr, imsg.data, sizeof(struct tnbr));

			LIST_INSERT_HEAD(&nconf->tnbr_list, ntnbr, entry);
			break;
		case IMSG_RECONF_NBRP:
			if ((nnbrp = malloc(sizeof(struct nbr_params))) == NULL)
				fatal(NULL);
			memcpy(nnbrp, imsg.data, sizeof(struct nbr_params));

			LIST_INSERT_HEAD(&nconf->nbrp_list, nnbrp, entry);
			break;
		case IMSG_RECONF_L2VPN:
			if ((nl2vpn = malloc(sizeof(struct l2vpn))) == NULL)
				fatal(NULL);
			memcpy(nl2vpn, imsg.data, sizeof(struct l2vpn));

			LIST_INIT(&nl2vpn->if_list);
			LIST_INIT(&nl2vpn->pw_list);

			LIST_INSERT_HEAD(&nconf->l2vpn_list, nl2vpn, entry);
			break;
		case IMSG_RECONF_L2VPN_IF:
			if ((nlif = malloc(sizeof(struct l2vpn_if))) == NULL)
				fatal(NULL);
			memcpy(nlif, imsg.data, sizeof(struct l2vpn_if));

			nlif->l2vpn = nl2vpn;
			LIST_INSERT_HEAD(&nl2vpn->if_list, nlif, entry);
			break;
		case IMSG_RECONF_L2VPN_PW:
			if ((npw = malloc(sizeof(struct l2vpn_pw))) == NULL)
				fatal(NULL);
			memcpy(npw, imsg.data, sizeof(struct l2vpn_pw));

			npw->l2vpn = nl2vpn;
			LIST_INSERT_HEAD(&nl2vpn->pw_list, npw, entry);
			break;
		case IMSG_RECONF_END:
			merge_config(leconf, nconf);
			nconf = NULL;
			global.conf_seqnum++;
			break;
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_KROUTE_ADDR:
		case IMSG_CTL_IFINFO:
		case IMSG_CTL_END:
			control_imsg_relay(&imsg);
			break;
		default:
			log_debug("ldpe_dispatch_main: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
static void
ldpe_dispatch_lde(int fd, short event, void *bula)
{
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct imsg		 imsg;
	struct map		 map;
	struct notify_msg	 nm;
	int			 n, shut = 0;
	struct nbr		*nbr = NULL;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("ldpe_dispatch_lde: msgbuf_write");
		if (n == 0)
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("ldpe_dispatch_lde: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_MAPPING_ADD:
		case IMSG_RELEASE_ADD:
		case IMSG_REQUEST_ADD:
		case IMSG_WITHDRAW_ADD:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(map))
				fatalx("invalid size of map request");
			memcpy(&map, imsg.data, sizeof(map));

			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL) {
				log_debug("ldpe_dispatch_lde: cannot find "
				    "neighbor");
				break;
			}
			if (nbr->state != NBR_STA_OPER)
				break;

			switch (imsg.hdr.type) {
			case IMSG_MAPPING_ADD:
				mapping_list_add(&nbr->mapping_list, &map);
				break;
			case IMSG_RELEASE_ADD:
				mapping_list_add(&nbr->release_list, &map);
				break;
			case IMSG_REQUEST_ADD:
				mapping_list_add(&nbr->request_list, &map);
				break;
			case IMSG_WITHDRAW_ADD:
				mapping_list_add(&nbr->withdraw_list, &map);
				break;
			}
			break;
		case IMSG_MAPPING_ADD_END:
		case IMSG_RELEASE_ADD_END:
		case IMSG_REQUEST_ADD_END:
		case IMSG_WITHDRAW_ADD_END:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL) {
				log_debug("ldpe_dispatch_lde: cannot find "
				    "neighbor");
				break;
			}
			if (nbr->state != NBR_STA_OPER)
				break;

			switch (imsg.hdr.type) {
			case IMSG_MAPPING_ADD_END:
				send_labelmessage(nbr, MSG_TYPE_LABELMAPPING,
				    &nbr->mapping_list);
				break;
			case IMSG_RELEASE_ADD_END:
				send_labelmessage(nbr, MSG_TYPE_LABELRELEASE,
				    &nbr->release_list);
				break;
			case IMSG_REQUEST_ADD_END:
				send_labelmessage(nbr, MSG_TYPE_LABELREQUEST,
				    &nbr->request_list);
				break;
			case IMSG_WITHDRAW_ADD_END:
				send_labelmessage(nbr, MSG_TYPE_LABELWITHDRAW,
				    &nbr->withdraw_list);
				break;
			}
			break;
		case IMSG_NOTIFICATION_SEND:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(nm))
				fatalx("invalid size of OE request");
			memcpy(&nm, imsg.data, sizeof(nm));

			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL) {
				log_debug("ldpe_dispatch_lde: cannot find "
				    "neighbor");
				break;
			}
			if (nbr->state != NBR_STA_OPER)
				break;

			send_notification_full(nbr->tcp, &nm);
			break;
		case IMSG_CTL_END:
		case IMSG_CTL_SHOW_LIB:
		case IMSG_CTL_SHOW_L2VPN_PW:
		case IMSG_CTL_SHOW_L2VPN_BINDING:
			control_imsg_relay(&imsg);
			break;
		default:
			log_debug("ldpe_dispatch_lde: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
static void
ldpe_dispatch_pfkey(int fd, short event, void *bula)
{
	if (event & EV_READ) {
		if (pfkey_read(fd, NULL) == -1) {
			fatal("pfkey_read failed, exiting...");
		}
	}
}

static void
ldpe_setup_sockets(int af, int disc_socket, int edisc_socket,
    int session_socket)
{
	struct ldpd_af_global	*af_global;

	af_global = ldp_af_global_get(&global, af);

	/* discovery socket */
	af_global->ldp_disc_socket = disc_socket;
	event_set(&af_global->disc_ev, af_global->ldp_disc_socket,
	    EV_READ|EV_PERSIST, disc_recv_packet, NULL);
	event_add(&af_global->disc_ev, NULL);

	/* extended discovery socket */
	af_global->ldp_edisc_socket = edisc_socket;
	event_set(&af_global->edisc_ev, af_global->ldp_edisc_socket,
	    EV_READ|EV_PERSIST, disc_recv_packet, NULL);
	event_add(&af_global->edisc_ev, NULL);

	/* session socket */
	af_global->ldp_session_socket = session_socket;
	accept_add(af_global->ldp_session_socket, session_accept, NULL);
}

static void
ldpe_close_sockets(int af)
{
	struct ldpd_af_global	*af_global;

	af_global = ldp_af_global_get(&global, af);

	/* discovery socket */
	if (event_initialized(&af_global->disc_ev))
		event_del(&af_global->disc_ev);
	if (af_global->ldp_disc_socket != -1) {
		close(af_global->ldp_disc_socket);
		af_global->ldp_disc_socket = -1;
	}

	/* extended discovery socket */
	if (event_initialized(&af_global->edisc_ev))
		event_del(&af_global->edisc_ev);
	if (af_global->ldp_edisc_socket != -1) {
		close(af_global->ldp_edisc_socket);
		af_global->ldp_edisc_socket = -1;
	}

	/* session socket */
	if (af_global->ldp_session_socket != -1) {
		accept_del(af_global->ldp_session_socket);
		close(af_global->ldp_session_socket);
		af_global->ldp_session_socket = -1;
	}
}

void
ldpe_reset_nbrs(int af)
{
	struct nbr		*nbr;

	RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
		if (nbr->af == af)
			session_shutdown(nbr, S_SHUTDOWN, 0, 0);
	}
}

void
ldpe_reset_ds_nbrs(void)
{
	struct nbr		*nbr;

	RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
		if (nbr->ds_tlv)
			session_shutdown(nbr, S_SHUTDOWN, 0, 0);
	}
}

void
ldpe_remove_dynamic_tnbrs(int af)
{
	struct tnbr		*tnbr, *safe;

	LIST_FOREACH_SAFE(tnbr, &leconf->tnbr_list, entry, safe) {
		if (tnbr->af != af)
			continue;

		tnbr->flags &= ~F_TNBR_DYNAMIC;
		tnbr_check(tnbr);
	}
}

void
ldpe_stop_init_backoff(int af)
{
	struct nbr		*nbr;

	RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
		if (nbr->af == af && nbr_pending_idtimer(nbr)) {
			nbr_stop_idtimer(nbr);
			nbr_establish_connection(nbr);
		}
	}
}

static void
ldpe_iface_af_ctl(struct ctl_conn *c, int af, unsigned int idx)
{
	struct iface		*iface;
	struct iface_af		*ia;
	struct ctl_iface	*ictl;

	LIST_FOREACH(iface, &leconf->iface_list, entry) {
		if (idx == 0 || idx == iface->ifindex) {
			ia = iface_af_get(iface, af);
			if (!ia->enabled)
				continue;

			ictl = if_to_ctl(ia);
			imsg_compose_event(&c->iev, IMSG_CTL_SHOW_INTERFACE,
			    0, 0, -1, ictl, sizeof(struct ctl_iface));
		}
	}
}

void
ldpe_iface_ctl(struct ctl_conn *c, unsigned int idx)
{
	ldpe_iface_af_ctl(c, AF_INET, idx);
	ldpe_iface_af_ctl(c, AF_INET6, idx);
}

void
ldpe_adj_ctl(struct ctl_conn *c)
{
	struct nbr	*nbr;
	struct adj	*adj;
	struct ctl_adj	*actl;

	RB_FOREACH(nbr, nbr_addr_head, &nbrs_by_addr) {
		LIST_FOREACH(adj, &nbr->adj_list, nbr_entry) {
			actl = adj_to_ctl(adj);
			imsg_compose_event(&c->iev, IMSG_CTL_SHOW_DISCOVERY,
			    0, 0, -1, actl, sizeof(struct ctl_adj));
		}
	}
	/* show adjacencies not associated with any neighbor */
	LIST_FOREACH(adj, &global.adj_list, global_entry) {
		if (adj->nbr != NULL)
			continue;

		actl = adj_to_ctl(adj);
		imsg_compose_event(&c->iev, IMSG_CTL_SHOW_DISCOVERY, 0, 0,
		    -1, actl, sizeof(struct ctl_adj));
	}

	imsg_compose_event(&c->iev, IMSG_CTL_END, 0, 0, -1, NULL, 0);
}

void
ldpe_nbr_ctl(struct ctl_conn *c)
{
	struct nbr	*nbr;
	struct ctl_nbr	*nctl;

	RB_FOREACH(nbr, nbr_addr_head, &nbrs_by_addr) {
		nctl = nbr_to_ctl(nbr);
		imsg_compose_event(&c->iev, IMSG_CTL_SHOW_NBR, 0, 0, -1, nctl,
		    sizeof(struct ctl_nbr));
	}
	imsg_compose_event(&c->iev, IMSG_CTL_END, 0, 0, -1, NULL, 0);
}

void
mapping_list_add(struct mapping_head *mh, struct map *map)
{
	struct mapping_entry	*me;

	me = calloc(1, sizeof(*me));
	if (me == NULL)
		fatal(__func__);
	me->map = *map;

	TAILQ_INSERT_TAIL(mh, me, entry);
}

void
mapping_list_clr(struct mapping_head *mh)
{
	struct mapping_entry	*me;

	while ((me = TAILQ_FIRST(mh)) != NULL) {
		TAILQ_REMOVE(mh, me, entry);
		free(me);
	}
}
@


1.73
log
@Minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.72 2017/03/03 23:30:57 renato Exp $ */
d224 2
a225 2
	static struct l2vpn	*nl2vpn;
	struct l2vpn_if		*nlif;
d268 4
a271 1
			if (!iface)
d273 1
d275 11
a285 3
			iface->flags = kif->flags;
			iface->linkstate = kif->link_state;
			if_update(iface, AF_UNSPEC);
@


1.72
log
@Allow to specify an alternate control socket.

This is required to run multiple instances of ldpd.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.71 2017/01/20 12:19:18 benno Exp $ */
d733 1
a733 2
			imsg_compose_event(&c->iev,
			     IMSG_CTL_SHOW_INTERFACE,
@


1.71
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

removal of log_rtmsg() aproved by claudio@@

ok claudio@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.70 2016/09/02 17:10:34 renato Exp $ */
d69 1
a69 1
ldpe(int debug, int verbose)
d84 2
a85 1
	if (control_init() == -1)
d174 1
a174 1
	control_cleanup();
@


1.70
log
@lde() and ldpe() should return void.

Remove these leftovers from the pre-fork+exec era.

Spotted by and ok rzalamena@@ ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.69 2016/09/02 17:03:24 renato Exp $ */
d81 1
@


1.69
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.68 2016/08/08 21:42:13 renato Exp $ */
d68 1
a68 1
pid_t
a155 2
	/* NOTREACHED */
	return (0);
@


1.68
log
@Use exit(3) instead of _exit(2) in the child processes.

Since recently the child processes call exec() after fork(), so they should
stop using _exit(2) and use exit(3) instead when shutting down.

Ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.67 2016/06/18 17:31:32 renato Exp $ */
d38 1
a38 1
static void	 ldpe_shutdown(void);
d160 1
a160 1
static void
d166 8
a192 2
	msgbuf_write(&iev_lde->ibuf.w);
	msgbuf_clear(&iev_lde->ibuf.w);
a193 2
	msgbuf_write(&iev_main->ibuf.w);
	msgbuf_clear(&iev_main->ibuf.w);
@


1.67
log
@Fix removal of dual-stack neighbors.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.66 2016/06/13 23:01:37 renato Exp $ */
d194 1
a194 1
	_exit(0);
@


1.66
log
@Implement support for the Configuration Sequence Number TLV.

The Configuration Sequence Number optional TLV is documented in RFC 5036,
pages 53 and 54.

Fixes IxANVL LDP test 23.10.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.65 2016/06/13 20:15:58 renato Exp $ */
d182 1
a182 1
		adj_del(adj, 1, S_SHUTDOWN);
@


1.65
log
@Do not create sockets for disabled address-families.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.64 2016/06/09 17:26:32 renato Exp $ */
d441 1
@


1.64
log
@Send a fatal notification when the last hello adjacency is deleted.

RFC 5036 says:
  "When the last Hello adjacency for an LDP session is
  deleted, the LSR terminates the LDP session by sending a Notification
  message and closing the transport connection".

Send a "Hold Timer Expired" notification when the triggering event is
a hello hold time timeout. In the other cases, like disabling LDP on an
interface, send a "Shutdown" notification instead.

Before this patch we were just closing the neighbor's transport
connection.

Fixes the following ANVL LDP tests: 7.17 and 23.3.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.63 2016/06/08 23:30:07 renato Exp $ */
d322 4
a325 2
			ldpe_imsg_compose_parent(IMSG_REQUEST_SOCKETS, af,
			    NULL, 0);
@


1.63
log
@Fix quick reconnect when the transport address is changed.

When the transport address is changed, we can't try to reconnect to the
neighbors inside merge_af() because the ldpe process still didn't receive
the new network sockets from the parent at this point. To resolve this,
try to reconnect just after we receive these sockets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.62 2016/06/06 16:42:41 renato Exp $ */
d182 1
a182 1
		adj_del(adj);
@


1.62
log
@Fix imsg parameter passing

When ldpe requests new network sockets to the parent process (after the
transport-address is changed), it must specify the desired address-family
(IPv4 or IPv6). We can use the 'pid' or 'peerid' members of the imsg_hdr
structure for this. Use 'pid' for convenience (no need to extend the
wrapper function, ldpe_imsg_compose_parent()).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.61 2016/05/23 19:16:00 renato Exp $ */
d233 2
d309 6
d360 11
@


1.61
log
@Improve security by calling exec after fork.

For each child process (lde and ldpe), re-exec ldpd with a special
"per-role" getopt flag. This way we have seperate ASLR/cookies per
process.

Based on a similar patch for bgpd, from claudio@@

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.60 2016/05/23 19:14:03 renato Exp $ */
d314 1
a314 1
			ldpe_imsg_compose_parent(IMSG_REQUEST_SOCKETS, 0,
@


1.60
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.59 2016/05/23 19:11:42 renato Exp $ */
d69 1
a69 2
ldpe(struct ldpd_conf *xconf, int pipe_parent2ldpe[2], int pipe_ldpe2lde[2],
    int pipe_parent2lde[2])
a70 1
	struct l2vpn		*l2vpn;
a72 1
	pid_t			 pid;
d74 1
a74 8
	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}
d76 2
a77 1
	leconf = xconf;
d122 2
a123 8
	/* setup pipes */
	close(pipe_parent2ldpe[0]);
	close(pipe_ldpe2lde[1]);
	close(pipe_parent2lde[0]);
	close(pipe_parent2lde[1]);

	if ((iev_lde = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_main = malloc(sizeof(struct imsgev))) == NULL)
d125 1
a125 3
	imsg_init(&iev_lde->ibuf, pipe_ldpe2lde[0]);
	iev_lde->handler = ldpe_dispatch_lde;
	imsg_init(&iev_main->ibuf, pipe_parent2ldpe[1]);
a126 7

	/* setup event handler */
	iev_lde->events = EV_READ;
	event_set(&iev_lde->ev, iev_lde->ibuf.fd, iev_lde->events,
	    iev_lde->handler, iev_lde);
	event_add(&iev_lde->ev, NULL);

a152 4
	/* create targeted neighbors for l2vpn pseudowires */
	LIST_FOREACH(l2vpn, &leconf->l2vpn_list, entry)
		ldpe_l2vpn_init(l2vpn);

d282 21
@


1.59
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.58 2016/05/23 19:09:25 renato Exp $ */
d4 1
@


1.58
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.57 2016/05/23 18:58:48 renato Exp $ */
a21 6
#include <sys/socket.h>
#include <sys/queue.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <net/if_types.h>
a24 1
#include <fcntl.h>
a26 1
#include <event.h>
a27 1
#include <err.h>
a28 1
#include <stdio.h>
a29 1
#include "ldp.h"
@


1.57
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.56 2016/05/23 18:55:21 renato Exp $ */
d47 8
a54 2
void	 ldpe_sig_handler(int, short, void *);
void	 ldpe_shutdown(void);
d56 1
a56 4
struct ldpd_conf	*leconf = NULL, *nconf;
struct imsgev		*iev_main;
struct imsgev		*iev_lde;
struct event		 pfkey_ev;
d59 4
d64 1
a64 1
void
d112 1
a112 1
	global.pfkeysock = pfkey_init(&sysdep);
d198 1
a198 1
void
d251 1
a251 1
void
d254 1
d461 1
a461 1
void
d595 1
a595 1
void
d605 3
a607 2
void
ldpe_setup_sockets(int af, int disc_socket, int edisc_socket, int session_socket)
d630 1
a630 1
void
d710 1
a710 1
void
@


1.56
log
@Assorted fixes and small cleanup.

Nothing really interesting here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.55 2016/05/23 18:41:59 renato Exp $ */
d35 1
d53 1
a53 3
struct event		 disc_ev;
struct event		 edisc_ev;
struct event             pfkey_ev;
d99 1
d101 4
d166 6
a171 3
	global.ldp_disc_socket = -1;
	global.ldp_edisc_socket = -1;
	global.ldp_session_socket = -1;
d195 1
d204 2
a205 1
	ldpe_close_sockets();
d212 2
d258 1
d297 1
a297 1
			if_update(iface);
d314 5
a318 3
			ldpe_close_sockets();
			if_update_all();
			tnbr_update_all();
d345 1
d357 1
a357 1
			ldpe_setup_sockets(disc_socket, edisc_socket,
d359 2
a360 2
			if_update_all();
			tnbr_update_all();
d379 4
a382 1
			LIST_INIT(&niface->adj_list);
d598 1
a598 1
ldpe_setup_sockets(int disc_socket, int edisc_socket, int session_socket)
d600 4
d605 2
a606 2
	global.ldp_disc_socket = disc_socket;
	event_set(&disc_ev, global.ldp_disc_socket,
d608 1
a608 1
	event_add(&disc_ev, NULL);
d611 2
a612 2
	global.ldp_edisc_socket = edisc_socket;
	event_set(&edisc_ev, global.ldp_edisc_socket,
d614 1
a614 1
	event_add(&edisc_ev, NULL);
d617 2
a618 2
	global.ldp_session_socket = session_socket;
	accept_add(global.ldp_session_socket, session_accept, NULL);
d622 1
a622 1
ldpe_close_sockets(void)
d624 4
d629 5
a633 5
	if (event_initialized(&disc_ev))
		event_del(&disc_ev);
	if (global.ldp_disc_socket != -1) {
		close(global.ldp_disc_socket);
		global.ldp_disc_socket = -1;
d637 5
a641 5
	if (event_initialized(&edisc_ev))
		event_del(&edisc_ev);
	if (global.ldp_edisc_socket != -1) {
		close(global.ldp_edisc_socket);
		global.ldp_edisc_socket = -1;
d645 15
a659 4
	if (global.ldp_session_socket != -1) {
		accept_del(global.ldp_session_socket);
		close(global.ldp_session_socket);
		global.ldp_session_socket = -1;
d664 1
a664 1
ldpe_reset_nbrs(void)
d668 4
a671 2
	RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id)
		session_shutdown(nbr, S_SHUTDOWN, 0, 0);
d675 1
a675 1
ldpe_remove_dynamic_tnbrs(void)
d680 3
d689 1
a689 1
ldpe_stop_init_backoff(void)
d694 1
a694 1
		if (nbr_pending_idtimer(nbr)) {
d702 1
a702 1
ldpe_iface_ctl(struct ctl_conn *c, unsigned int idx)
d705 1
d710 5
a714 1
			ictl = if_to_ctl(iface);
d723 7
d732 1
a733 2
	struct iface	*iface;
	struct tnbr	*tnbr;
d736 2
a737 3
	/* basic discovery mechanism */
	LIST_FOREACH(iface, &leconf->iface_list, entry)
		LIST_FOREACH(adj, &iface->adj_list, iface_entry) {
d742 10
a751 8

	/* extended discovery mechanism */
	LIST_FOREACH(tnbr, &leconf->tnbr_list, entry)
		if (tnbr->adj) {
			actl = adj_to_ctl(tnbr->adj);
			imsg_compose_event(&c->iev, IMSG_CTL_SHOW_DISCOVERY,
			    0, 0, -1, actl, sizeof(struct ctl_adj));
		}
d762 1
a762 1
	RB_FOREACH(nbr, nbr_pid_head, &nbrs_by_pid) {
@


1.55
log
@Enable changing the router-id via config reload.

Now ldpd can start without a router-id, since it can be set later. Since
a router-id of 0.0.0.0 is invalid, interfaces and targeted-neighbors
will check for a valid router-id in order to be activated.

When the router-id is changed, all the neighborships are reset.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.54 2016/05/23 18:40:15 renato Exp $ */
d277 1
a278 1
			kif = imsg.data;
@


1.54
log
@Several fixes in the config reload handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.53 2016/05/23 18:36:55 renato Exp $ */
d624 9
@


1.53
log
@Don't create l2vpn targeted neighbors inside the config parser.

When removing a configured pseudowire, we remove the associated tnbr
in ldpe_l2vpn_pw_exit(). So, when a new pseudowire is configured, it
makes sense to create its tnbr in ldpe_l2vpn_pw_init() to keep things
consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.52 2016/05/23 18:35:10 renato Exp $ */
d623 24
@


1.52
log
@Add an exception for kernels built without PFKEYv2 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.51 2016/05/23 18:33:56 renato Exp $ */
d76 1
d172 4
@


1.51
log
@Create network sockets on the parent process.

We drop our privileges in ldpe right after we create the network sockets.
The problem is that we might want to change the transport-address and
reload the config, in which case we need new sockets. To allow that,
always create the network sockets in the parent process and pass them
to ldpe via imsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.50 2016/05/23 18:25:30 renato Exp $ */
d154 5
a158 3
	event_set(&pfkey_ev, global.pfkeysock, EV_READ | EV_PERSIST,
	    ldpe_dispatch_pfkey, NULL);
	event_add(&pfkey_ev, NULL);
d187 4
a190 3
	event_del(&pfkey_ev);
	close(global.pfkeysock);

@


1.50
log
@Move socket creation and setup into a specialized function.

Right now we use three network sockets in ldpd:
* the discovery socket (udp+mcast);
* the extended discovery socket (udp);
* the session socket (tcp).

When we introduce IPv6 support, we'll get three more sockets. In order
to prevent code duplication in the future, add a specialized function
that creates a socket according to the given type (and address-family
later). This also improves readability because it makes it easier to
see the differences between each socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.49 2016/05/23 17:43:42 renato Exp $ */
a75 2
	struct iface		*iface;
	struct tnbr		*tnbr;
a101 11
	/* create network sockets */
	global.ldp_disc_socket = ldp_create_socket(LDP_SOCKET_DISC);
	if (global.ldp_disc_socket == -1)
		fatal("error creating discovery socket");
	global.ldp_edisc_socket = ldp_create_socket(LDP_SOCKET_EDISC);
	if (global.ldp_edisc_socket == -1)
		fatal("error binding extended discovery socket");
	global.ldp_session_socket = ldp_create_socket(LDP_SOCKET_SESSION);
	if (global.ldp_session_socket == -1)
		fatal("error creating session socket");

d115 1
a115 1
	if (pledge("stdio cpath inet mcast", NULL) == -1)
d158 4
a161 7
	event_set(&disc_ev, global.ldp_disc_socket,
	    EV_READ|EV_PERSIST, disc_recv_packet, NULL);
	event_add(&disc_ev, NULL);

	event_set(&edisc_ev, global.ldp_edisc_socket,
	    EV_READ|EV_PERSIST, disc_recv_packet, NULL);
	event_add(&edisc_ev, NULL);
a162 1
	accept_add(global.ldp_session_socket, session_accept, NULL);
a169 8
	/* initialize interfaces */
	LIST_FOREACH(iface, &leconf->iface_list, entry)
		if_init(iface);

	/* start configured targeted neighbors */
	LIST_FOREACH(tnbr, &leconf->tnbr_list, entry)
		tnbr_init(tnbr);

a185 3
	event_del(&disc_ev);
	event_del(&edisc_ev);
	accept_del(global.ldp_session_socket);
d187 2
a188 3
	close(global.ldp_disc_socket);
	close(global.ldp_edisc_socket);
	close(global.ldp_session_socket);
d239 4
d293 46
d568 47
@


1.49
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a79 1
	struct sockaddr_in	 disc_addr, sess_addr;
a80 1
	int			 opt;
d104 3
a106 4
	/* create the discovery UDP socket */
	if ((global.ldp_disc_socket = socket(AF_INET,
	    SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC,
	    IPPROTO_UDP)) == -1)
d108 2
a109 38

	if (sock_set_reuse(global.ldp_disc_socket, 1) == -1)
		fatal("sock_set_reuse");

	disc_addr.sin_family = AF_INET;
	disc_addr.sin_port = htons(LDP_PORT);
	disc_addr.sin_addr.s_addr = INADDR_ANY;
	if (bind(global.ldp_disc_socket, (struct sockaddr *)&disc_addr,
	    sizeof(disc_addr)) == -1)
		fatal("error binding discovery socket");

	/* set some defaults */
	if (sock_set_ipv4_mcast_ttl(global.ldp_disc_socket,
	    IP_DEFAULT_MULTICAST_TTL) == -1)
		fatal("sock_set_ipv4_mcast_ttl");
	if (sock_set_ipv4_mcast_loop(global.ldp_disc_socket) == -1)
		fatal("sock_set_ipv4_mcast_loop");
	if (sock_set_ipv4_tos(global.ldp_disc_socket,
	    IPTOS_PREC_INTERNETCONTROL) == -1)
		fatal("sock_set_ipv4_tos");
	if (sock_set_ipv4_recvif(global.ldp_disc_socket, 1) == -1)
		fatal("sock_set_ipv4_recvif");
	sock_set_recvbuf(global.ldp_disc_socket);

	/* create the extended discovery UDP socket */
	if ((global.ldp_edisc_socket = socket(AF_INET,
	    SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC,
	    IPPROTO_UDP)) == -1)
		fatal("error creating extended discovery socket");

	if (sock_set_reuse(global.ldp_edisc_socket, 1) == -1)
		fatal("sock_set_reuse");

	disc_addr.sin_family = AF_INET;
	disc_addr.sin_port = htons(LDP_PORT);
	disc_addr.sin_addr.s_addr = xconf->trans_addr.s_addr;
	if (bind(global.ldp_edisc_socket, (struct sockaddr *)&disc_addr,
	    sizeof(disc_addr)) == -1)
d111 2
a112 13

	/* set some defaults */
	if (sock_set_ipv4_tos(global.ldp_edisc_socket,
	    IPTOS_PREC_INTERNETCONTROL) == -1)
		fatal("sock_set_ipv4_tos");
	if (sock_set_ipv4_recvif(global.ldp_edisc_socket, 1) == -1)
		fatal("sock_set_ipv4_recvif");
	sock_set_recvbuf(global.ldp_edisc_socket);

	/* create the session TCP socket */
	if ((global.ldp_session_socket = socket(AF_INET,
	    SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC,
	    IPPROTO_TCP)) == -1)
a114 28
	if (sock_set_reuse(global.ldp_session_socket, 1) == -1)
		fatal("sock_set_reuse");

	sess_addr.sin_family = AF_INET;
	sess_addr.sin_port = htons(LDP_PORT);
	sess_addr.sin_addr = xconf->trans_addr;
	if (bind(global.ldp_session_socket, (struct sockaddr *)&sess_addr,
	    sizeof(sess_addr)) == -1)
		fatal("error binding session socket");

	if (listen(global.ldp_session_socket, LDP_BACKLOG) == -1)
		fatal("error in listen on session socket");

	opt = 1;
	if (setsockopt(global.ldp_session_socket, IPPROTO_TCP, TCP_MD5SIG,
	    &opt, sizeof(opt)) == -1) {
		if (errno == ENOPROTOOPT) {	/* system w/o md5sig */
			log_warnx("md5sig not available, disabling");
			sysdep.no_md5sig = 1;
		} else
			fatal("setsockopt TCP_MD5SIG");
	}

	/* set some defaults */
	if (sock_set_ipv4_tos(global.ldp_session_socket,
	    IPTOS_PREC_INTERNETCONTROL) == -1)
		fatal("sock_set_ipv4_tos");

d171 2
a172 2
	event_set(&disc_ev, global.ldp_disc_socket, EV_READ|EV_PERSIST,
	    disc_recv_packet, NULL);
d175 2
a176 2
	event_set(&edisc_ev, global.ldp_edisc_socket, EV_READ|EV_PERSIST,
	    disc_recv_packet, NULL);
@


1.48
log
@pledge() earlier on ldpe.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.47 2016/05/23 15:47:24 renato Exp $ */
d102 3
a104 1
	leconf->pfkeysock = pfkey_init(&sysdep);
d107 1
a107 5
	disc_addr.sin_family = AF_INET;
	disc_addr.sin_port = htons(LDP_PORT);
	disc_addr.sin_addr.s_addr = INADDR_ANY;

	if ((xconf->ldp_discovery_socket = socket(AF_INET,
d112 2
a113 2
	if (if_set_reuse(xconf->ldp_discovery_socket, 1) == -1)
		fatal("if_set_reuse");
d115 4
a118 1
	if (bind(xconf->ldp_discovery_socket, (struct sockaddr *)&disc_addr,
d123 1
a123 1
	if (if_set_mcast_ttl(xconf->ldp_discovery_socket,
d125 4
a128 4
		fatal("if_set_mcast_ttl");
	if (if_set_mcast_loop(xconf->ldp_discovery_socket) == -1)
		fatal("if_set_mcast_loop");
	if (if_set_tos(xconf->ldp_discovery_socket,
d130 4
a133 4
		fatal("if_set_tos");
	if (if_set_recvif(xconf->ldp_discovery_socket, 1) == -1)
		fatal("if_set_recvif");
	if_set_recvbuf(xconf->ldp_discovery_socket);
d136 1
a136 5
	disc_addr.sin_family = AF_INET;
	disc_addr.sin_port = htons(LDP_PORT);
	disc_addr.sin_addr.s_addr = xconf->trans_addr.s_addr;

	if ((xconf->ldp_ediscovery_socket = socket(AF_INET,
d141 2
a142 2
	if (if_set_reuse(xconf->ldp_ediscovery_socket, 1) == -1)
		fatal("if_set_reuse");
d144 4
a147 1
	if (bind(xconf->ldp_ediscovery_socket, (struct sockaddr *)&disc_addr,
d152 1
a152 1
	if (if_set_tos(xconf->ldp_ediscovery_socket,
d154 4
a157 4
		fatal("if_set_tos");
	if (if_set_recvif(xconf->ldp_ediscovery_socket, 1) == -1)
		fatal("if_set_recvif");
	if_set_recvbuf(xconf->ldp_ediscovery_socket);
d160 1
a160 5
	sess_addr.sin_family = AF_INET;
	sess_addr.sin_port = htons(LDP_PORT);
	sess_addr.sin_addr.s_addr = INADDR_ANY;

	if ((xconf->ldp_session_socket = socket(AF_INET,
d165 2
a166 2
	if (if_set_reuse(xconf->ldp_session_socket, 1) == -1)
		fatal("if_set_reuse");
d168 4
a171 1
	if (bind(xconf->ldp_session_socket, (struct sockaddr *)&sess_addr,
d175 1
a175 1
	if (listen(xconf->ldp_session_socket, LDP_BACKLOG) == -1)
d179 1
a179 1
	if (setsockopt(xconf->ldp_session_socket, IPPROTO_TCP, TCP_MD5SIG,
d189 1
a189 1
	if (if_set_tos(xconf->ldp_session_socket,
d191 1
a191 1
		fatal("if_set_tos");
d245 1
a245 1
	event_set(&pfkey_ev, leconf->pfkeysock, EV_READ | EV_PERSIST,
d249 2
a250 2
	event_set(&disc_ev, leconf->ldp_discovery_socket,
	    EV_READ|EV_PERSIST, disc_recv_packet, NULL);
d253 2
a254 2
	event_set(&edisc_ev, leconf->ldp_ediscovery_socket,
	    EV_READ|EV_PERSIST, disc_recv_packet, NULL);
d257 1
a257 1
	accept_add(leconf->ldp_session_socket, session_accept, NULL);
d267 1
a267 1
		if_init(xconf, iface);
d271 1
a271 1
		tnbr_init(xconf, tnbr);
d291 5
a295 5
	accept_del(leconf->ldp_session_socket);
	close(leconf->pfkeysock);
	close(leconf->ldp_discovery_socket);
	close(leconf->ldp_ediscovery_socket);
	close(leconf->ldp_session_socket);
d298 1
a298 1
	while ((if_addr = LIST_FIRST(&leconf->addr_list)) != NULL) {
d318 1
a318 1
ldpe_imsg_compose_parent(int type, pid_t pid, void *data, u_int16_t datalen)
d324 2
a325 2
ldpe_imsg_compose_lde(int type, u_int32_t peerid, pid_t pid,
    void *data, u_int16_t datalen)
a385 13
			ka = imsg.data;

			if (if_addr_lookup(&leconf->addr_list, ka) == NULL) {
				if_addr = if_addr_new(ka);

				LIST_INSERT_HEAD(&leconf->addr_list, if_addr,
				    entry);
				RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
					if (nbr->state != NBR_STA_OPER)
						continue;
					send_address(nbr, if_addr);
				}
			}
d387 1
a387 8
			iface = if_lookup(leconf, ka->ifindex);
			if (iface &&
			    if_addr_lookup(&iface->addr_list, ka) == NULL) {
				if_addr = if_addr_new(ka);
				LIST_INSERT_HEAD(&iface->addr_list, if_addr,
				    entry);
				if_update(iface);
			}
a392 11
			ka = imsg.data;

			iface = if_lookup(leconf, ka->ifindex);
			if (iface) {
				if_addr = if_addr_lookup(&iface->addr_list, ka);
				if (if_addr) {
					LIST_REMOVE(if_addr, entry);
					free(if_addr);
					if_update(iface);
				}
			}
d394 1
a394 10
			if_addr = if_addr_lookup(&leconf->addr_list, ka);
			if (if_addr) {
				RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
					if (nbr->state != NBR_STA_OPER)
						continue;
					send_address_withdraw(nbr, if_addr);
				}
				LIST_REMOVE(if_addr, entry);
				free(if_addr);
			}
a402 1
			LIST_INIT(&nconf->addr_list);
a625 6
}

u_int32_t
ldpe_router_id(void)
{
	return (leconf->rtr_id.s_addr);
@


1.47
log
@Move some code around.

This patch doesn't introduce any logical change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.46 2016/05/23 15:43:11 renato Exp $ */
d207 3
a272 3

	if (pledge("stdio cpath inet mcast", NULL) == -1)
		fatal("pledge");
@


1.46
log
@Add knob to configure the transport address.

This will be especially important when we add support for IPv6, because
we'll not be able to use the router-id as the transport-address in
this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.45 2016/05/23 15:20:21 renato Exp $ */
a45 3
extern struct nbr_id_head	nbrs_by_id;
RB_PROTOTYPE(nbr_id_head, nbr, id_tree, nbr_id_compare)

a345 1
	struct if_addr		*if_addr = NULL;
a346 1
	struct kaddr		*ka;
a347 1
	struct nbr		*nbr;
d677 57
a753 16
	}
}

void
ldpe_iface_ctl(struct ctl_conn *c, unsigned int idx)
{
	struct iface		*iface;
	struct ctl_iface	*ictl;

	LIST_FOREACH(iface, &leconf->iface_list, entry) {
		if (idx == 0 || idx == iface->ifindex) {
			ictl = if_to_ctl(iface);
			imsg_compose_event(&c->iev,
			     IMSG_CTL_SHOW_INTERFACE,
			    0, 0, -1, ictl, sizeof(struct ctl_iface));
		}
@


1.45
log
@Clear the configuration before closing the network sockets.

This fixes some errors and warnings when ldpd is shutting down.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.44 2016/05/23 15:14:07 renato Exp $ */
d140 1
a140 1
	disc_addr.sin_addr.s_addr = xconf->rtr_id.s_addr;
@


1.44
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.43 2016/05/23 14:59:50 renato Exp $ */
d290 1
a305 2

	config_clear(leconf);
@


1.43
log
@Explicitly close the pfkey socket on exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.42 2016/05/23 14:55:41 renato Exp $ */
d264 1
a264 1
		fatal("ldpe");
d690 1
a690 1
		fatal("mapping_list_add");
@


1.42
log
@Call accept_del() on exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.41 2015/12/05 13:11:48 claudio Exp $ */
d85 1
a85 1
	int			 pfkeysock, opt;
a100 2
	pfkeysock = pfkey_init(&sysdep);

d105 2
d246 1
a246 1
	event_set(&pfkey_ev, pfkeysock, EV_READ | EV_PERSIST,
d291 1
d295 1
a295 1
	event_del(&pfkey_ev);
@


1.41
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.40 2015/10/23 10:10:17 renato Exp $ */
d293 1
@


1.40
log
@Add pledge(2) to the child processes.

This is almost identical to the eigrpd(8) pledge diff, with the exception
that the parent process can not be pledged bacause of a SIOCSETMPWCFG
ioctl used to configure pseudowires.

Looks good to deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.39 2015/07/21 05:04:12 renato Exp $ */
d355 1
a355 1
		if ((n = imsg_read(ibuf)) == -1)
d369 1
a369 1
			fatal("ldpe_dispatch_main: imsg_read error");
d543 1
a543 1
		if ((n = imsg_read(ibuf)) == -1)
d557 1
a557 1
			fatal("ldpe_dispatch_lde: imsg_read error");
@


1.39
log
@Call control_cleanup() from the ldpe process, where it belongs.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.38 2015/07/21 05:02:57 renato Exp $ */
d273 3
@


1.38
log
@Rename, move and reuse mapping list functions.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.37 2015/07/21 04:58:48 renato Exp $ */
d285 2
@


1.37
log
@Fix some awful ipc synchronization issues.

Under some rare circumstances the following can happen:
1 - one neighbor sends a label withdraw followed by a fatal notification
    message;
2 - ldpe parses the label withdraw and sends it to lde;
3 - ldpe parses the fatal notification message and closes the session;
4 - lde processes the label withdraw and asks ldpe to send a label release;
5 - at around the same time, ldpe restarts the session with the neighbor;
6 - ldpe processes the lde message and then sends a label release to the new
    neighbor.

The problem is that we don't want a message enqueue to a neighbor to be sent
after the session is restarted. If a session is closed, all the enqueued
messages should be discarded.

To acomplish this, we update the peerid of the nbr structure everytime the
session is established.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.36 2015/07/21 04:52:29 renato Exp $ */
d576 1
a576 1
				nbr_mapping_add(nbr, &nbr->mapping_list, &map);
d579 1
a579 1
				nbr_mapping_add(nbr, &nbr->release_list, &map);
d582 1
a582 1
				nbr_mapping_add(nbr, &nbr->request_list, &map);
d585 1
a585 1
				nbr_mapping_add(nbr, &nbr->withdraw_list, &map);
d674 24
@


1.36
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.35 2015/07/21 04:45:21 renato Exp $ */
d569 1
a569 1
				return;
d572 1
a572 1
				return;
d597 1
a597 1
				return;
d600 1
a600 1
				return;
d630 1
a630 1
				return;
d633 1
a633 1
				return;
@


1.35
log
@Reuse merge_config() logic to simplify the shutdown of each process.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.34 2015/07/21 04:43:28 renato Exp $ */
d336 3
d447 1
d473 26
d635 1
a635 2
			send_notification_nbr(nbr, nm.status,
			    htonl(nm.messageid), htonl(nm.type));
d639 2
@


1.34
log
@Add configuration reload support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.33 2015/07/21 04:39:28 renato Exp $ */
d55 2
d250 1
a250 1
	event_set(&leconf->disc_ev, leconf->ldp_discovery_socket,
d252 1
a252 1
	event_add(&leconf->disc_ev, NULL);
d254 1
a254 1
	event_set(&leconf->edisc_ev, leconf->ldp_ediscovery_socket,
d256 1
a256 1
	event_add(&leconf->edisc_ev, NULL);
d284 8
a291 3
	struct if_addr	*if_addr;
	struct iface	*iface;
	struct tnbr	*tnbr;
d299 1
a299 15
	/* stop all interfaces */
	while ((iface = LIST_FIRST(&leconf->iface_list)) != NULL) {
		LIST_REMOVE(iface, entry);
		if_del(iface);
	}

	/* stop all targeted neighbors */
	while ((tnbr = LIST_FIRST(&leconf->tnbr_list)) != NULL) {
		LIST_REMOVE(tnbr, entry);
		tnbr_del(tnbr);
	}

	close(leconf->ldp_discovery_socket);
	close(leconf->ldp_ediscovery_socket);
	close(leconf->ldp_session_socket);
a307 1
	free(leconf);
@


1.33
log
@Improve handling of addresses on ldpe.

This is a preliminary work for the the next patch (sigup config
reload). We want to make sure that the ldpe process can handle duplicated
addresses.

The idea is to alloc two different if_addr structures for each address,
and link one in the global list of addresses (used to send address
messages) and link the other to the associated interface list of
addresses.

Doing that we will be able to call kif_redistribute() after reloading
the config file and activate the new LDP enabled interfaces.

NOTE: Interfaces are created at config parse time and the child
processes inherit them on fork() so there's no need to send a status
update at startup.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.32 2015/07/19 21:01:56 renato Exp $ */
d341 12
a352 9
	struct imsg	 imsg;
	struct imsgev	*iev = bula;
	struct imsgbuf  *ibuf = &iev->ibuf;
	struct iface	*iface = NULL;
	struct if_addr	*if_addr = NULL;
	struct kif	*kif;
	struct kaddr	*ka;
	int		 n, shut = 0;
	struct nbr	*nbr;
d380 1
a380 1
			iface = if_lookup(kif->ifindex);
d406 1
a406 1
			iface = if_lookup(ka->ifindex);
d421 1
a421 1
			iface = if_lookup(ka->ifindex);
d443 9
d454 22
d478 2
@


1.32
log
@Implement md5 authentication support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.31 2015/07/19 20:54:17 renato Exp $ */
d282 1
d286 6
d345 1
a345 1
	struct if_addr	*if_addr = NULL, *a;
d347 1
a347 1
	struct kaddr	*kaddr;
d374 1
a374 1
				fatalx("IFINFO imsg with wrong len");
d389 1
a389 1
			kaddr = imsg.data;
d391 2
a392 2
			if ((if_addr = calloc(1, sizeof(*if_addr))) == NULL)
				fatal("ldpe_dispatch_main");
d394 7
a400 10
			if_addr->addr.s_addr = kaddr->addr.s_addr;
			if_addr->mask.s_addr = kaddr->mask.s_addr;
			if_addr->dstbrd.s_addr = kaddr->dstbrd.s_addr;

			LIST_INSERT_HEAD(&leconf->addr_list, if_addr,
			    global_entry);
			RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
				if (nbr->state != NBR_STA_OPER)
					continue;
				send_address(nbr, if_addr);
d403 4
a406 2
			iface = if_lookup(kaddr->ifindex);
			if (iface) {
d408 1
a408 1
				    iface_entry);
d416 1
a416 1
			kaddr = imsg.data;
d418 1
a418 11
			LIST_FOREACH(a, &leconf->addr_list, global_entry)
				if (a->addr.s_addr == kaddr->addr.s_addr &&
				    a->mask.s_addr == kaddr->mask.s_addr &&
				    a->dstbrd.s_addr == kaddr->dstbrd.s_addr)
					break;
			if_addr = a;
			if (!if_addr)
				break;

			LIST_REMOVE(if_addr, global_entry);
			iface = if_lookup(kaddr->ifindex);
d420 6
a425 2
				LIST_REMOVE(if_addr, iface_entry);
				if_update(iface);
d428 9
a436 4
			RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
				if (nbr->state != NBR_STA_OPER)
					continue;
				send_address_withdraw(nbr, if_addr);
a437 2

			free(if_addr);
@


1.31
log
@Rework label mapping algorithms to be more in line with the RFC.

This patch presents a thoroughly review of the label mapping
algorithms. Most of the changes are minor bug fixes in the handling of
received label messages.

Additional improvements:
* Add a few more references to the Appendix A of the RFC5036 ("LDP
  Label Distribution Procedures") into the code;
* Add full multipath support;
* Send label withdraws when appropriate;
* Add label withdraw/release wildcard support.

NOTE: As a result of implementing only the "Liberal Label Retention" and
"Downstream Unsolicited" modes, we will never send a label request
("Request  Never"). And that means that we can ignore the following
notification messages: "Label Request Aborted", "No Label Resources",
"No Route" and "Label Resources Available". The following algorithms
mentioned in the RFC can also be ignored: "Timeout of Deferred Label
Request", "Detect Local Label Resources Have Become Available" and
"Receive Label Abort Request".

Now, considering that we only support one combination of all modes of
operation, we can say that we have an almost complete implementation of
the protocol.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.30 2015/03/21 18:32:01 renato Exp $ */
d25 1
d55 2
d83 1
d99 2
d180 10
d244 4
d594 11
@


1.30
log
@Remove interface finite state machine.

In the name of simplicity, remove the interface FSM that was inherited
from ospfd. In ldpd interfaces are just up or down, so keeping a
FSM for that is an overkill. Now instead of calling if_fsm(), just
call if_update() whenever a relevant event occurs (status change,
address addition/removal).

Additional notes:
1 - s/if_act_/if_/

2 - Remove the IMSG_IFUP and IMSG_IFDOWN events. Now whenever an
interface changes its state a IMSG_IFSTATUS event will be generated
with the new status.

kroute.c ldpd.h ldpe.c ldpe.h CVS:
----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.29 2015/03/21 18:29:22 renato Exp $ */
d479 1
d503 3
d511 1
d533 4
@


1.29
log
@Don't try to send address withdraws to neighbors that are unreachable
after an address removal in the system.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.28 2015/03/21 17:33:10 renato Exp $ */
a266 4
		if (if_fsm(iface, IF_EVT_DOWN)) {
			log_debug("error stopping interface %s",
			    iface->name);
		}
a344 2
		case IMSG_IFUP:
		case IMSG_IFDOWN:
d356 1
a356 10
			switch (imsg.hdr.type) {
			case IMSG_IFUP:
				if_fsm(iface, IF_EVT_UP);
				break;
			case IMSG_IFDOWN:
				if_fsm(iface, IF_EVT_DOWN);
				break;
			default:
				break;
			}
d383 1
a383 1
				if_fsm(iface, IF_EVT_NEWADDR);
d405 1
a405 1
				if_fsm(iface, IF_EVT_DELADDR);
@


1.28
log
@Close extended discovery socket on exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.27 2015/02/10 01:03:54 claudio Exp $ */
d417 6
a428 5
			iface = if_lookup(kaddr->ifindex);
			if (iface) {
				LIST_REMOVE(if_addr, iface_entry);
				if_fsm(iface, IF_EVT_DELADDR);
			}
@


1.27
log
@Pass SOCK_NONBLOCK | SOCK_CLOEXEC to some more sockets. We never want to
sleep on a socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.26 2015/02/09 11:54:24 claudio Exp $ */
d282 1
@


1.26
log
@More SOCK_NONBLOCK | SOCK_CLOEXEC love and one less session_socket_blockmode
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.25 2014/11/18 20:54:28 krw Exp $ */
d104 2
a105 1
	if ((xconf->ldp_discovery_socket = socket(AF_INET, SOCK_DGRAM,
d134 2
a135 1
	if ((xconf->ldp_ediscovery_socket = socket(AF_INET, SOCK_DGRAM,
@


1.25
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.24 2014/07/12 20:16:38 krw Exp $ */
d157 2
a158 1
	if ((xconf->ldp_session_socket = socket(AF_INET, SOCK_STREAM,
a175 1
	session_socket_blockmode(xconf->ldp_session_socket, BM_NONBLOCK);
@


1.24
log
@Close connections when msgbuf_write() returns 0.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.23 2013/11/26 11:59:38 henning Exp $ */
a36 1
#include <stdlib.h>
@


1.23
log
@deal with msgbuf_write EAGAIN, ok gilles benno
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.21 2013/06/04 02:25:28 claudio Exp $ */
d333 1
a333 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d335 2
d475 1
a475 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d477 2
@


1.22
log
@Respect the max pdu length and merge all send_label* functions into
a single generic function.
@
text
@d333 1
a333 1
		if (msgbuf_write(&ibuf->w) == -1)
d473 1
a473 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.21
log
@Implement support for adjacencies and targeted hellos
Refactor adjacencies out of the neighbor handling so that it is possible to
have more complex topologies with targeted sessions.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.20 2013/06/04 00:45:00 claudio Exp $ */
d526 2
a527 1
				send_labelmapping(nbr);
d530 2
a531 1
				send_labelrelease(nbr);
d534 2
a535 1
				send_labelrequest(nbr);
@


1.20
log
@Minor adjustments in the startup of the lde and ldpe processes
The 'ldpd_process' variable should be set as soon as possible in the
initialization of each process. In that way if something goes wrong in
the initialization we will know in which process the problem happened.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.19 2013/06/04 00:41:18 claudio Exp $ */
d76 1
d109 3
d129 24
d228 1
a228 1
	    EV_READ|EV_PERSIST, disc_recv_packet, leconf);
d231 5
a235 1
	accept_add(leconf->ldp_session_socket, session_accept, leconf);
d247 4
d262 1
d274 6
d281 1
@


1.19
log
@fix some minor issues before proceeding with the remaining patches from
Renato Westphal. Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.18 2013/06/03 16:53:49 claudio Exp $ */
d90 5
a149 2
	leconf = xconf;

a156 3

	setproctitle("ldp engine");
	ldpd_process = PROC_LDP_ENGINE;
@


1.18
log
@Implement support for multiple addresses per interface.
This replaces the way addresses and interface are chained together.
In ospfd there was a 1 to 1 mapping (with iface clones) but LDP does
not have that limitation.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.17 2013/06/01 19:01:32 claudio Exp $ */
d334 3
a336 3
			if_addr->addr = kaddr->addr;
			if_addr->mask = kaddr->mask;
			if_addr->dstbrd = kaddr->dstbrd;
@


1.17
log
@Improve error handling on session_read
* Don't try to send a Shutdown message if the connection is already
  closed or a read error occured;
* As per RFC 5036, send a Shutdown message if an unexpected message is
  received during the initialization process;
* Check if the whole LSR ID of received messages is correct;
* On ldpe_dispatch_main(), ignore the messages from the lde process
  whose associated neighbor is not in the operational state.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.16 2012/04/12 17:33:43 claudio Exp $ */
d46 3
a51 2
void	 recv_packet(int, short, void *);

d211 2
a212 2
	/* start interfaces */
	LIST_FOREACH(iface, &leconf->iface_list, entry) {
a213 5
		if (if_fsm(iface, IF_EVT_UP)) {
			log_debug("error starting interface %s",
			    iface->name);
		}
	}
d228 1
a228 1
	LIST_FOREACH(iface, &leconf->iface_list, entry) {
d233 2
d276 1
d278 3
a280 1
	int		 n, link_new, link_old, shut = 0;
d300 3
a302 1
		case IMSG_IFINFO:
d306 1
d308 66
a373 2
			link_new = (kif->flags & IFF_UP) &&
			    LINK_STATE_IS_UP(kif->link_state);
d375 4
a378 22
			LIST_FOREACH(iface, &leconf->iface_list, entry) {
				if (kif->ifindex == iface->ifindex) {
					link_old = (iface->flags & IFF_UP) &&
					    LINK_STATE_IS_UP(iface->linkstate);
					iface->flags = kif->flags;
					iface->linkstate = kif->link_state;

					if (link_new == link_old)
						continue;
					if (link_new) {
						if_fsm(iface, IF_EVT_UP);
						log_warnx("interface %s up",
						    iface->name);
						/* XXX: send address msg */
					} else {
						if_fsm(iface, IF_EVT_DOWN);
						log_warnx("interface %s down",
						    iface->name);
						/* XXX: send address withdraw
						   msg */
					}
				}
d380 1
@


1.16
log
@accept pacing ldpd way. Since this daemon has multiple listening fds
we add them all to a accept queue that does the pacing with the
accept_pause() and accept_unpause() calls.
With and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.15 2011/07/04 04:34:14 claudio Exp $ */
d402 2
d426 2
d452 2
@


1.15
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.14 2011/01/10 12:28:25 claudio Exp $ */
d163 1
d202 1
a202 4
	event_set(&leconf->sess_ev, leconf->ldp_session_socket,
	    EV_READ|EV_PERSIST, session_accept, leconf);
	event_add(&leconf->sess_ev, NULL);

@


1.14
log
@Fix a bad heritage from ospfd. Make neighbors independent of interfaces.
They are not bound as strongly as in ospf and causes problems when the
TCP connection is established from an not connected IP (e.g. a loopback).
Use three RB trees to sort the neighbor list by id, addr and peerid.
More cleanup is needed but this makes ldpd work against peers using
loopback IPs. Problem found, reported and fix tested again by Marcel Wiget.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.13 2010/10/26 12:03:11 claudio Exp $ */
d307 1
a307 3
			    (LINK_STATE_IS_UP(kif->link_state) ||
			    (kif->link_state == LINK_STATE_UNKNOWN &&
			    kif->media_type != IFT_CARP));
d312 1
a312 4
					    (LINK_STATE_IS_UP(iface->linkstate)
					    || (iface->linkstate ==
					    LINK_STATE_UNKNOWN &&
					    iface->media_type != IFT_CARP));
@


1.13
log
@Shuffle the deck chairs to make the code more compact.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.12 2010/09/01 13:54:54 claudio Exp $ */
a162 1
	nbr_init(NBR_HASHSIZE);
a498 19
}

void
ldpe_nbr_ctl(struct ctl_conn *c)
{
	struct iface	*iface;
	struct nbr	*nbr;
	struct ctl_nbr	*nctl;

	LIST_FOREACH(iface, &leconf->iface_list, entry) {
		LIST_FOREACH(nbr, &iface->nbr_list, entry) {
			nctl = nbr_to_ctl(nbr);
			imsg_compose_event(&c->iev,
			    IMSG_CTL_SHOW_NBR, 0, 0, -1, nctl,
			    sizeof(struct ctl_nbr));
		}
	}

	imsg_compose_event(&c->iev, IMSG_CTL_END, 0, 0, -1, NULL, 0);
@


1.12
log
@s/lfib/fib/ for more consitency with the other routing daemons.
This started manly because of ldpctl beeing inconsistent and me misstyping
lfib almost every time.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.11 2010/07/08 09:41:05 claudio Exp $ */
d398 2
d401 1
a401 1
				fatalx("invalid size of OE request");
d411 11
a421 1
			nbr_mapping_add(nbr, &nbr->mapping_list, &map);
d424 2
d433 10
a442 12
			send_labelmapping(nbr);
			break;
		case IMSG_RELEASE_ADD:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(map))
				fatalx("invalid size of OE request");
			memcpy(&map, imsg.data, sizeof(map));

			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL) {
				log_debug("ldpe_dispatch_lde: cannot find "
				    "neighbor");
				return;
a443 11

			nbr_mapping_add(nbr, &nbr->release_list, &map);
			break;
		case IMSG_RELEASE_ADD_END:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL) {
				log_debug("ldpe_dispatch_lde: cannot find "
				    "neighbor");
				return;
			}
			send_labelrelease(nbr);
a458 23
			break;
		case IMSG_REQUEST_ADD:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(map))
				fatalx("invalid size of OE request");
			memcpy(&map, imsg.data, sizeof(map));

			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL) {
				log_debug("ldpe_dispatch_lde: cannot find "
				    "neighbor");
				return;
			}

			nbr_mapping_add(nbr, &nbr->request_list, &map);
			break;
		case IMSG_REQUEST_ADD_END:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL) {
				log_debug("ldpe_dispatch_lde: cannot find "
				    "neighbor");
				return;
			}
			send_labelrequest(nbr);
@


1.11
log
@Kill more code in kroute.c that is unneeded in ldpd. ldpd is a bit strange
since it does not care that much about reachability of routes. The idea is
to have diverse LSP in the kernel and the kernel should then decide which
path should be used.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.10 2010/05/26 13:56:07 nicm Exp $ */
a53 1
int			 oe_nofib;
a144 2
	if (leconf->flags & LDPD_FLAG_NO_LFIB_UPDATE)
		oe_nofib = 1;
a505 9
}

void
ldpe_fib_update(int type)
{
	if (type == IMSG_CTL_LFIB_COUPLE)
		oe_nofib = 0;
	if (type == IMSG_CTL_LFIB_DECOUPLE)
		oe_nofib = 1;
@


1.10
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.9 2010/05/19 15:28:51 claudio Exp $ */
d285 1
a285 1
	int		 n, link_ok, shut = 0;
d310 1
a310 1
			link_ok = (kif->flags & IFF_UP) &&
d317 5
d325 3
a327 1
					if (link_ok) {
@


1.9
log
@Remove yet another ospf leftover that is not needed here. This time
neighbor self and all the madness surrounding this amazing concept.
LDP is not self aware so there is no need for this.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.8 2010/05/11 15:01:46 claudio Exp $ */
d213 1
a213 1
	if ((pkt_ptr = calloc(1, READ_BUF_SIZE)) == NULL)
@


1.8
log
@Kill IMSG_RECONF_AREA. LDP does not have a concept of areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.7 2010/04/29 12:09:28 claudio Exp $ */
d538 4
a541 6
			if (iface->self != nbr) {
				nctl = nbr_to_ctl(nbr);
				imsg_compose_event(&c->iev,
				    IMSG_CTL_SHOW_NBR, 0, 0, -1, nctl,
				    sizeof(struct ctl_nbr));
			}
@


1.7
log
@Remove some more ospfd-ism from the interface code. This time remove
of most of the IF_TYPE_ special cases and most interface types.
Point-to-point and broadcast still present because of find_iface()
which needs addtional fixing.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.6 2010/04/15 15:04:23 claudio Exp $ */
a335 2
			break;
		case IMSG_RECONF_AREA:
@


1.6
log
@Instead of having three ways of setting fds non-blocking use
session_socket_blockmode() everywhere.
Additionally make two fatal() distinguishable.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.5 2010/02/25 17:40:46 claudio Exp $ */
d316 1
a316 2
				if (kif->ifindex == iface->ifindex &&
				    iface->type != IF_TYPE_VIRTUALLINK) {
@


1.5
log
@Do not use bufferevent for something that's already covered in the imsg
buffer API. This fixes a few possible problems in session_read and does
some further cleanup in various places. Wrap msgbuf into evbuf to add
libevent functionality and use buf_read to handle the read side of a
session.  OK michele@@ and dlg@@ did not see anything evil
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.4 2010/02/18 10:50:14 claudio Exp $ */
d143 1
a143 2
	if (if_set_nonblock(xconf->ldp_session_socket) == -1)
		fatal("if_set_nonblock");
d295 1
a295 1
			fatal("msgbuf_write");
d386 1
a386 1
			fatal("msgbuf_write");
@


1.4
log
@We need to set SO_REUSEADDR before doing the bind() of the tcp socket.
It does not help to set SO_REUSEPORT after doing the bind.
Fixes failures to start ldpd because of TIME_WAIT sessions.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.3 2009/06/06 08:09:43 pyr Exp $ */
d207 1
a207 1
	    EV_READ|EV_PERSIST, session_recv_packet, leconf);
@


1.3
log
@make ldpd imsg-in-a-lib ready too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.2 2009/06/05 22:34:45 michele Exp $ */
d129 3
a142 2
	if (if_set_reuse(xconf->ldp_session_socket, 1) == -1)
		fatal("if_set_reuse");
@


1.2
log
@Correctly send notification messages when errors occur.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d52 2
a53 2
struct imsgbuf		*ibuf_main;
struct imsgbuf		*ibuf_lde;
d182 2
a183 2
	if ((ibuf_lde = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
d185 4
a188 2
	imsg_init(ibuf_lde, pipe_ldpe2lde[0], ldpe_dispatch_lde);
	imsg_init(ibuf_main, pipe_parent2ldpe[1], ldpe_dispatch_main);
d191 9
a199 9
	ibuf_lde->events = EV_READ;
	event_set(&ibuf_lde->ev, ibuf_lde->fd, ibuf_lde->events,
	    ibuf_lde->handler, ibuf_lde);
	event_add(&ibuf_lde->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);
d248 6
a253 6
	msgbuf_write(&ibuf_lde->w);
	msgbuf_clear(&ibuf_lde->w);
	free(ibuf_lde);
	msgbuf_write(&ibuf_main->w);
	msgbuf_clear(&ibuf_main->w);
	free(ibuf_main);
d265 1
a265 1
	return (imsg_compose(ibuf_main, type, 0, pid, data, datalen));
d272 2
a273 1
	return (imsg_compose(ibuf_lde, type, peerid, pid, data, datalen));
d281 2
a282 1
	struct imsgbuf  *ibuf = bula;
d358 1
a358 1
		imsg_event_add(ibuf);
d361 1
a361 1
		event_del(&ibuf->ev);
d370 2
a371 1
	struct imsgbuf		*ibuf = bula;
d493 1
a493 1
		imsg_event_add(ibuf);
d496 1
a496 1
		event_del(&ibuf->ev);
d525 3
a527 2
			imsg_compose(&c->ibuf, IMSG_CTL_SHOW_INTERFACE,
			    0, 0, ictl, sizeof(struct ctl_iface));
d543 2
a544 2
				imsg_compose(&c->ibuf,
				    IMSG_CTL_SHOW_NBR, 0, 0, nctl,
d550 1
a550 1
	imsg_compose(&c->ibuf, IMSG_CTL_END, 0, 0, NULL, 0);
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d369 1
a370 1
	u_int32_t		 code;
d439 1
a439 1
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(code))
d441 1
a441 1
			memcpy(&code, imsg.data, sizeof(code));
d450 2
a451 1
			send_notification_nbr(nbr, code);
@

