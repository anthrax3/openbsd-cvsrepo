head	1.46;
access;
symbols
	OPENBSD_6_1:1.46.0.4
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.40.0.2
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.46
date	2017.03.04.00.15.35;	author renato;	state Exp;
branches;
next	1.45;
commitid	BOl8emh4A0ljUk3b;

1.45
date	2017.03.04.00.06.10;	author renato;	state Exp;
branches;
next	1.44;
commitid	GMDFIgs8eMuH7Rxe;

1.44
date	2017.03.03.23.50.45;	author renato;	state Exp;
branches;
next	1.43;
commitid	2u5VjeFQJD7hTJEX;

1.43
date	2017.03.03.23.47.41;	author renato;	state Exp;
branches;
next	1.42;
commitid	hbVgri2kBCNjHTrW;

1.42
date	2017.03.03.23.44.35;	author renato;	state Exp;
branches;
next	1.41;
commitid	mV5MMkodXlL2okSe;

1.41
date	2016.09.02.17.08.02;	author renato;	state Exp;
branches;
next	1.40;
commitid	BOhRdj3Gcm8K4Ipy;

1.40
date	2016.07.16.19.20.16;	author renato;	state Exp;
branches;
next	1.39;
commitid	YLPvWL4I6VM5sc5a;

1.39
date	2016.07.01.23.36.38;	author renato;	state Exp;
branches;
next	1.38;
commitid	h9Qy21EPYXbAFnoh;

1.38
date	2016.07.01.23.33.46;	author renato;	state Exp;
branches;
next	1.37;
commitid	o5yBQ1cPVCcMZ7gA;

1.37
date	2016.07.01.23.29.55;	author renato;	state Exp;
branches;
next	1.36;
commitid	OkOx7tFZtmlIlivU;

1.36
date	2016.06.27.19.06.33;	author renato;	state Exp;
branches;
next	1.35;
commitid	OXyvybFBtSb4ppHx;

1.35
date	2016.06.11.01.55.35;	author renato;	state Exp;
branches;
next	1.34;
commitid	GgWpGoWeBPM557df;

1.34
date	2016.06.11.01.52.33;	author renato;	state Exp;
branches;
next	1.33;
commitid	XfOzUytCPs9UnIQ9;

1.33
date	2016.06.11.01.46.36;	author renato;	state Exp;
branches;
next	1.32;
commitid	u4rx6q4TyXyUJBXY;

1.32
date	2016.06.11.01.44.02;	author renato;	state Exp;
branches;
next	1.31;
commitid	vwBDqzjY8KdySFgq;

1.31
date	2016.06.08.22.00.12;	author renato;	state Exp;
branches;
next	1.30;
commitid	Co6Yvo8cUldsZY71;

1.30
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.29;
commitid	AQBoOveMRKjtVfFv;

1.29
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.28;
commitid	t07H0Mk6WGdVWB0W;

1.28
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.27;
commitid	VpAym8dVR6eY4drQ;

1.27
date	2016.05.23.16.54.22;	author renato;	state Exp;
branches;
next	1.26;
commitid	LfWxXXNhiR6poNUS;

1.26
date	2016.05.23.16.29.22;	author renato;	state Exp;
branches;
next	1.25;
commitid	TvYWPJTlFdeHPfB0;

1.25
date	2016.05.23.16.25.11;	author renato;	state Exp;
branches;
next	1.24;
commitid	rbQYKxfpthpZ0H0X;

1.24
date	2016.05.23.16.20.59;	author renato;	state Exp;
branches;
next	1.23;
commitid	nAtgYzDo97D7UnEI;

1.23
date	2016.05.23.16.16.44;	author renato;	state Exp;
branches;
next	1.22;
commitid	lsfNt5ZefaCVBrpj;

1.22
date	2016.05.23.16.12.28;	author renato;	state Exp;
branches;
next	1.21;
commitid	vVUYnEJVjv7IWE6u;

1.21
date	2016.05.23.16.04.04;	author renato;	state Exp;
branches;
next	1.20;
commitid	sfghEB6dR4Eaf77g;

1.20
date	2016.05.23.15.59.55;	author renato;	state Exp;
branches;
next	1.19;
commitid	2jPamx70j4TMPRN1;

1.19
date	2016.05.23.15.14.08;	author renato;	state Exp;
branches;
next	1.18;
commitid	l3e6PhvoAh8C7elc;

1.18
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.17;
commitid	puLLDX1XPNc3GxB9;

1.17
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.16;
commitid	2uw1UTO4k6erpWzK;

1.16
date	2013.10.15.20.31.13;	author renato;	state Exp;
branches;
next	1.15;

1.15
date	2013.10.15.19.59.53;	author renato;	state Exp;
branches;
next	1.14;

1.14
date	2013.06.04.02.34.48;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.04.01.32.16;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.01.19.42.07;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.01.18.47.07;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.01.18.35.02;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.20.23.12.33;	author jasper;	state Exp;
branches;
next	1.8;

1.8
date	2010.11.04.09.52.16;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.14.13.49.09;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.12.13.31.35;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.15.15.44.37;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.20.21.28.39;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.22.34.45;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Implement RFC 5919 (LDP End-of-LIB).
@
text
@/*	$OpenBSD: notification.c,v 1.45 2017/03/04 00:06:10 renato Exp $ */

/*
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <arpa/inet.h>
#include <string.h>

#include "ldpd.h"
#include "ldp.h"
#include "log.h"
#include "ldpe.h"

static int	 gen_returned_tlvs(struct ibuf *, uint16_t, uint16_t, char *);
static void	 log_msg_notification(int, struct nbr *, struct notify_msg *);

void
send_notification_full(struct tcp_conn *tcp, struct notify_msg *nm)
{
	struct ibuf	*buf;
	uint16_t	 size;
	int		 err = 0;

	/* calculate size */
	size = LDP_HDR_SIZE + LDP_MSG_SIZE + STATUS_SIZE;
	if (nm->flags & F_NOTIF_PW_STATUS)
		size += PW_STATUS_TLV_SIZE;
	if (nm->flags & F_NOTIF_FEC)
		size += len_fec_tlv(&nm->fec);
	if (nm->flags & F_NOTIF_RETURNED_TLVS)
		size += TLV_HDR_SIZE * 2 + nm->rtlvs.length;

	if ((buf = ibuf_open(size)) == NULL)
		fatal(__func__);

	err |= gen_ldp_hdr(buf, size);
	size -= LDP_HDR_SIZE;
	err |= gen_msg_hdr(buf, MSG_TYPE_NOTIFICATION, size);
	err |= gen_status_tlv(buf, nm->status_code, nm->msg_id, nm->msg_type);
	/* optional tlvs */
	if (nm->flags & F_NOTIF_PW_STATUS)
		err |= gen_pw_status_tlv(buf, nm->pw_status);
	if (nm->flags & F_NOTIF_FEC)
		err |= gen_fec_tlv(buf, &nm->fec);
	if (nm->flags & F_NOTIF_RETURNED_TLVS)
		err |= gen_returned_tlvs(buf, nm->rtlvs.type, nm->rtlvs.length,
		    nm->rtlvs.data);
	if (err) {
		ibuf_free(buf);
		return;
	}

	if (tcp->nbr) {
		log_msg_notification(1, tcp->nbr, nm);
		nbr_fsm(tcp->nbr, NBR_EVT_PDU_SENT);
	}

	evbuf_enqueue(&tcp->wbuf, buf);
}

/* send a notification without optional tlvs */
void
send_notification(struct tcp_conn *tcp, uint32_t status_code, uint32_t msg_id,
    uint16_t msg_type)
{
	struct notify_msg	 nm;

	memset(&nm, 0, sizeof(nm));
	nm.status_code = status_code;
	nm.msg_id = msg_id;
	nm.msg_type = msg_type;

	send_notification_full(tcp, &nm);
}

void
send_notification_rtlvs(struct nbr *nbr, uint32_t status_code, uint32_t msg_id,
    uint16_t msg_type, uint16_t tlv_type, uint16_t tlv_len, char *tlv_data)
{
	struct notify_msg	 nm;

	memset(&nm, 0, sizeof(nm));
	nm.status_code = status_code;
	nm.msg_id = msg_id;
	nm.msg_type = msg_type;
	/* do not append the given TLV if it's too big (shouldn't happen) */
	if (tlv_len < 1024) {
		nm.rtlvs.type = tlv_type;
		nm.rtlvs.length = tlv_len;
		nm.rtlvs.data = tlv_data;
		nm.flags |= F_NOTIF_RETURNED_TLVS;
	}

	send_notification_full(nbr->tcp, &nm);
}

int
recv_notification(struct nbr *nbr, char *buf, uint16_t len)
{
	struct ldp_msg		msg;
	struct status_tlv	st;
	struct notify_msg	nm;
	int			tlen;

	memcpy(&msg, buf, sizeof(msg));
	buf += LDP_MSG_SIZE;
	len -= LDP_MSG_SIZE;

	if (len < STATUS_SIZE) {
		session_shutdown(nbr, S_BAD_MSG_LEN, msg.id, msg.type);
		return (-1);
	}
	memcpy(&st, buf, sizeof(st));

	if (ntohs(st.length) > STATUS_SIZE - TLV_HDR_SIZE ||
	    ntohs(st.length) > len - TLV_HDR_SIZE) {
		session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
		return (-1);
	}
	buf += STATUS_SIZE;
	len -= STATUS_SIZE;

	memset(&nm, 0, sizeof(nm));
	nm.status_code = ntohl(st.status_code);

	/* Optional Parameters */
	while (len > 0) {
		struct tlv 	tlv;
		uint16_t	tlv_type;
		uint16_t	tlv_len;

		if (len < sizeof(tlv)) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
			return (-1);
		}

		memcpy(&tlv, buf, TLV_HDR_SIZE);
		tlv_type = ntohs(tlv.type);
		tlv_len = ntohs(tlv.length);
		if (tlv_len + TLV_HDR_SIZE > len) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
			return (-1);
		}
		buf += TLV_HDR_SIZE;
		len -= TLV_HDR_SIZE;

		switch (tlv_type) {
		case TLV_TYPE_EXTSTATUS:
		case TLV_TYPE_RETURNEDPDU:
		case TLV_TYPE_RETURNEDMSG:
			/* TODO is there any use for this? */
			break;
		case TLV_TYPE_PW_STATUS:
			if (tlv_len != 4) {
				session_shutdown(nbr, S_BAD_TLV_LEN,
				    msg.id, msg.type);
				return (-1);
			}

			nm.pw_status = ntohl(*(uint32_t *)buf);
			nm.flags |= F_NOTIF_PW_STATUS;
			break;
		case TLV_TYPE_FEC:
			if ((tlen = tlv_decode_fec_elm(nbr, &msg, buf,
			    tlv_len, &nm.fec)) == -1)
				return (-1);
			/* allow only one fec element */
			if (tlen != tlv_len) {
				session_shutdown(nbr, S_BAD_TLV_VAL,
				    msg.id, msg.type);
				return (-1);
			}
			nm.flags |= F_NOTIF_FEC;
			break;
		default:
			if (!(ntohs(tlv.type) & UNKNOWN_FLAG))
				send_notification_rtlvs(nbr, S_UNKNOWN_TLV,
				    msg.id, msg.type, tlv_type, tlv_len, buf);
			/* ignore unknown tlv */
			break;
		}
		buf += tlv_len;
		len -= tlv_len;
	}

	/* sanity checks */
	switch (nm.status_code) {
	case S_PW_STATUS:
		if (!(nm.flags & (F_NOTIF_PW_STATUS|F_NOTIF_FEC))) {
			send_notification(nbr->tcp, S_MISS_MSG,
			    msg.id, msg.type);
			return (-1);
		}

		switch (nm.fec.type) {
		case MAP_TYPE_PWID:
			break;
		default:
			send_notification(nbr->tcp, S_BAD_TLV_VAL,
			    msg.id, msg.type);
			return (-1);
		}
		break;
	case S_ENDOFLIB:
		if (!(nm.flags & F_NOTIF_FEC)) {
			send_notification(nbr->tcp, S_MISS_MSG,
			    msg.id, msg.type);
			return (-1);
		}
		if (nm.fec.type != MAP_TYPE_TYPED_WCARD) {
			send_notification(nbr->tcp, S_BAD_TLV_VAL,
			    msg.id, msg.type);
			return (-1);
		}
		break;
	default:
		break;
	}

	log_msg_notification(0, nbr, &nm);

	if (st.status_code & htonl(STATUS_FATAL)) {
		if (nbr->state == NBR_STA_OPENSENT)
			nbr_start_idtimer(nbr);

		nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
		return (-1);
	}

	/* lde needs to know about a few notification messages */
	switch (nm.status_code) {
	case S_PW_STATUS:
	case S_ENDOFLIB:
		ldpe_imsg_compose_lde(IMSG_NOTIFICATION, nbr->peerid, 0,
		    &nm, sizeof(nm));
		break;
	default:
		break;
	}

	return (0);
}

int
gen_status_tlv(struct ibuf *buf, uint32_t status_code, uint32_t msg_id,
    uint16_t msg_type)
{
	struct status_tlv	st;

	memset(&st, 0, sizeof(st));
	st.type = htons(TLV_TYPE_STATUS);
	st.length = htons(STATUS_TLV_LEN);
	st.status_code = htonl(status_code);
	/*
	 * For convenience, msg_id and msg_type are already in network
	 * byte order.
	 */
	st.msg_id = msg_id;
	st.msg_type = msg_type;

	return (ibuf_add(buf, &st, STATUS_SIZE));
}

static int
gen_returned_tlvs(struct ibuf *buf, uint16_t type, uint16_t length,
    char *tlv_data)
{
	struct tlv	 rtlvs;
	struct tlv	 tlv;
	int		 err;

	rtlvs.type = htons(TLV_TYPE_RETURNED_TLVS);
	rtlvs.length = htons(length + TLV_HDR_SIZE);
	tlv.type = htons(type);
	tlv.length = htons(length);

	err = ibuf_add(buf, &rtlvs, sizeof(rtlvs));
	err |= ibuf_add(buf, &tlv, sizeof(tlv));
	err |= ibuf_add(buf, tlv_data, length);

	return (err);
}

void
log_msg_notification(int out, struct nbr *nbr, struct notify_msg *nm)
{
	const char	*dir = (out) ? "out" : "in";

	if (nm->status_code & STATUS_FATAL) {
		log_warnx("msg-%s: notification: lsr-id %s, status %s "
		    "(fatal error)", dir, inet_ntoa(nbr->id),
		    status_code_name(nm->status_code));
		return;
	}

	log_debug("msg-%s: notification: lsr-id %s, status %s", dir,
	    inet_ntoa(nbr->id), status_code_name(nm->status_code));
	if (nm->flags & F_NOTIF_FEC)
		log_debug("msg-%s: notification:   fec %s", dir,
		    log_map(&nm->fec));
	if (nm->flags & F_NOTIF_PW_STATUS)
		log_debug("msg-%s: notification:   pw-status %s", dir,
		    (nm->pw_status) ? "not forwarding" : "forwarding");
}
@


1.45
log
@Implement RFC 5561 (LDP Capabilities).

This patch per-se doesn't introduce any useful functionality, but prepares
the ground for new enhancements to ldpd (i.e. implementation of new RFCs
that make use of LDP capabilities).
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.44 2017/03/03 23:50:45 renato Exp $ */
d42 2
a43 10
	if (nm->flags & F_NOTIF_FEC) {
		size += TLV_HDR_SIZE;
		switch (nm->fec.type) {
		case MAP_TYPE_PWID:
			size += FEC_PWID_ELM_MIN_LEN;
			if (nm->fec.flags & F_MAP_PW_ID)
				size += sizeof(uint32_t);
			break;
		}
	}
d200 3
a202 1
	if (nm.status_code == S_PW_STATUS) {
d217 15
d244 4
a247 1
	if (nm.status_code == S_PW_STATUS)
d250 4
@


1.44
log
@Create helper functions to log sent/received messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.43 2017/03/03 23:47:41 renato Exp $ */
d28 1
d52 2
d67 3
d98 21
d151 1
d160 1
d169 1
a169 1
		switch (ntohs(tlv.type)) {
d199 2
a200 2
				send_notification(nbr->tcp, S_UNKNOWN_TLV,
				    msg.id, msg.type);
d260 20
@


1.43
log
@Provide more detailed output when logging notification messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.42 2017/03/03 23:44:35 renato Exp $ */
d28 2
d70 1
a70 9
		log_debug("msg-out: notification: lsr-id %s, status %s%s",
		    inet_ntoa(tcp->nbr->id), status_code_name(nm->status_code),
		    (nm->status_code & STATUS_FATAL) ? " (fatal)" : "");
		if (nm->flags & F_NOTIF_FEC)
			log_debug("msg-out: notification:   fec %s",
			    log_map(&nm->fec));
		if (nm->flags & F_NOTIF_PW_STATUS)
			log_debug("msg-out: notification:   pw-status %s",
			    (nm->pw_status) ? "not forwarding" : "forwarding");
d196 1
a196 8
	log_warnx("msg-in: notification: lsr-id %s, status %s%s",
	    inet_ntoa(nbr->id), status_code_name(ntohl(st.status_code)),
	    (st.status_code & htonl(STATUS_FATAL)) ? " (fatal)" : "");
	if (nm.flags & F_NOTIF_FEC)
		log_debug("msg-in: notification:   fec %s", log_map(&nm.fec));
	if (nm.flags & F_NOTIF_PW_STATUS)
		log_debug("msg-in: notification:   pw-status %s",
		    (nm.pw_status) ? "not forwarding" : "forwarding");
d231 22
@


1.42
log
@Kill send_notification_nbr().

Be more clever and trigger the PDU SENT event inside send_notification()
when tcp->nbr is set. This way we can eliminate send_notification_nbr()
and always use send_notification() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.41 2016/09/02 17:08:02 renato Exp $ */
d71 6
d205 5
@


1.41
log
@Improve logging of sent and received messages.

* Standardize the logging format of sent and received messages:
  "msg-[in|out]: message type: lsr-id A.B.C.D [additional info]";

* Log sent label messages as well, not only the received ones;

* Move the logging of sent notification messages from
  send_notification_nbr() to send_notification_full(), this way notification
  triggered by the lde process are logged as well;

* Minor clean-up.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.40 2016/07/16 19:20:16 renato Exp $ */
d67 1
a67 1
	if (tcp->nbr)
d71 2
d79 1
a79 1
send_notification(uint32_t status_code, struct tcp_conn *tcp, uint32_t msg_id,
a91 8
void
send_notification_nbr(struct nbr *nbr, uint32_t status_code, uint32_t msg_id,
    uint16_t msg_type)
{
	send_notification(status_code, nbr->tcp, msg_id, msg_type);
	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
}

d170 1
a170 1
				send_notification_nbr(nbr, S_UNKNOWN_TLV,
d181 1
a181 1
			send_notification_nbr(nbr, S_MISS_MSG,
d190 1
a190 1
			send_notification_nbr(nbr, S_BAD_TLV_VAL,
@


1.40
log
@Fix parsing of mal-formed optional TLVs/Sub-TLVs.

We must detect if a TLV's length extends beyond the end of the containing
message. And, if so, send a fatal "Bad TLV Length" notification message.

Found with the Mu Dynamics Mu-8000 protocol fuzzer.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.39 2016/07/01 23:36:38 renato Exp $ */
d67 5
a93 3
	log_debug("%s: lsr-id %s, status %s", __func__, inet_ntoa(nbr->id),
	     status_code_name(status_code));

d202 3
a204 8
	if (st.status_code & htonl(STATUS_FATAL))
		log_warnx("received notification from lsr-id %s: %s",
		    inet_ntoa(nbr->id),
		    status_code_name(ntohl(st.status_code)));
	else
		log_debug("received non-fatal notification from lsr-id "
		    "%s: %s", inet_ntoa(nbr->id),
		    status_code_name(ntohl(st.status_code)));
@


1.39
log
@More renaming and whitespace cleanup.

No binary change after "strip -s".
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.38 2016/07/01 23:33:46 renato Exp $ */
d131 1
a131 2
			session_shutdown(nbr, S_BAD_TLV_LEN, msg.id,
			    msg.type);
d136 5
a142 1
		tlv_len = ntohs(tlv.length);
d173 1
a173 1
			if (!(ntohs(tlv.type) & UNKNOWN_FLAG)) {
a175 1
			}
@


1.38
log
@Be more compliant with RFC 4447.

When sending a label withdraw during the pseudowire Control Word
negotiation, append a "Wrong C-bit" status TLV after the FEC TLV (in
conformance to RFC 4447 section 6.2). Apparently this has no use other
than aiding in troubleshooting.

Also, extend the recv_labelmessage() function to accept Status TLVs and
ignore them instead of shutting down the session.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.37 2016/07/01 23:29:55 renato Exp $ */
d38 1
a38 1
		size += PW_STATUS_TLV_LEN;
d40 1
a40 1
		size += TLV_HDR_LEN;
d56 1
a56 1
	err |= gen_status_tlv(buf, nm->status, nm->messageid, nm->type);
d72 2
a73 2
send_notification(uint32_t status, struct tcp_conn *tcp, uint32_t msgid,
    uint16_t type)
d78 3
a80 3
	nm.status = status;
	nm.messageid = msgid;
	nm.type = type;
d86 2
a87 2
send_notification_nbr(struct nbr *nbr, uint32_t status, uint32_t msgid,
    uint16_t type)
d90 1
a90 1
	     notification_name(status));
d92 1
a92 1
	send_notification(status, nbr->tcp, msgid, type);
d99 1
a99 1
	struct ldp_msg		not;
d104 1
a104 1
	memcpy(&not, buf, sizeof(not));
d109 1
a109 1
		session_shutdown(nbr, S_BAD_MSG_LEN, not.msgid, not.type);
d114 3
a116 3
	if (ntohs(st.length) > STATUS_SIZE - TLV_HDR_LEN ||
	    ntohs(st.length) > len - TLV_HDR_LEN) {
		session_shutdown(nbr, S_BAD_TLV_LEN, not.msgid, not.type);
d123 1
a123 1
	nm.status = ntohl(st.status_code);
d131 2
a132 2
			session_shutdown(nbr, S_BAD_TLV_LEN, not.msgid,
			    not.type);
d136 3
a138 3
		memcpy(&tlv, buf, TLV_HDR_LEN);
		buf += TLV_HDR_LEN;
		len -= TLV_HDR_LEN;
d150 1
a150 1
				    not.msgid, not.type);
d158 1
a158 1
			if ((tlen = tlv_decode_fec_elm(nbr, &not, buf,
d164 1
a164 1
				    not.msgid, not.type);
d172 1
a172 1
				    not.msgid, not.type);
d181 1
a181 1
	if (nm.status == S_PW_STATUS) {
d184 1
a184 1
			    not.msgid, not.type);
d193 1
a193 1
			    not.msgid, not.type);
d201 1
a201 1
		    notification_name(ntohl(st.status_code)));
d205 1
a205 1
		    notification_name(ntohl(st.status_code)));
d215 1
a215 1
	if (nm.status == S_PW_STATUS)
d223 2
a224 1
gen_status_tlv(struct ibuf *buf, uint32_t status, uint32_t msgid, uint16_t type)
a228 1

d231 7
a237 5
	st.status_code = htonl(status);

	/* for convenience, msgid and type are already in network byte order */
	st.msg_id = msgid;
	st.msg_type = type;
@


1.37
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.36 2016/06/27 19:06:33 renato Exp $ */
a27 2
static int	 gen_status_tlv(struct ibuf *, uint32_t, uint32_t, uint16_t);

d222 1
a222 1
static int
@


1.36
log
@Handle ibuf_add() errors.

tweaks from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.35 2016/06/11 01:55:35 renato Exp $ */
d28 1
a28 1
static int	 gen_status_tlv(struct ibuf *, uint32_t, uint32_t, uint32_t);
d201 1
a201 1
		log_warnx("received notification from neighbor %s: %s",
d205 1
a205 1
		log_debug("received non-fatal notification from neighbor "
d225 1
a225 1
gen_status_tlv(struct ibuf *buf, uint32_t status, uint32_t msgid, uint32_t type)
@


1.35
log
@Make all TLV parsing functions look the same for consistency.

Also, add one more safety check in recv_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.34 2016/06/11 01:52:33 renato Exp $ */
d35 1
d55 1
a55 1
	gen_ldp_hdr(buf, size);
d57 2
a58 2
	gen_msg_hdr(buf, MSG_TYPE_NOTIFICATION, size);
	gen_status_tlv(buf, nm->status, nm->messageid, nm->type);
d61 1
a61 1
		gen_pw_status_tlv(buf, nm->pw_status);
d63 5
a67 1
		gen_fec_tlv(buf, &nm->fec);
@


1.34
log
@Make it possible to parse unknown TLVs in the future.

In the parsing of label and notification messages, we were always
unsetting the first bit of the TLV type before comparing it against the
types we know. We should not do this because our type constants can have
this bit set when appropriate.

By now the only unknown TLV supported by ldpd(8) is TLV_TYPE_DUALSTACK,
which is only used in Hello messages. But we might change this in the
future with support for MAC List TLVs and maybe RFC 7473.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.33 2016/06/11 01:46:36 renato Exp $ */
d125 1
d133 1
a133 1
		memcpy(&tlv, buf, sizeof(tlv));
d136 1
d145 1
a145 1
			if (ntohs(tlv.length) != 4) {
d156 1
a156 1
			    ntohs(tlv.length), &nm.fec)) == -1)
d159 1
a159 1
			if (tlen != ntohs(tlv.length)) {
d174 2
a175 2
		buf += ntohs(tlv.length);
		len -= ntohs(tlv.length);
@


1.33
log
@Use uint16_t for notification type.

This doesn't fix any bug as we were already using uint16_t everywhere
else.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.32 2016/06/11 01:44:02 renato Exp $ */
d136 1
a136 1
		switch (ntohs(tlv.type) & ~UNKNOWN_FLAG) {
@


1.32
log
@Fix parsing of multiple optional TLVs in label and notification messages.

We were accepting at most one optional TLV.

Fixes IxANVL LDP test 15.3.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.31 2016/06/08 22:00:12 renato Exp $ */
d70 1
a70 1
    uint32_t type)
d84 1
a84 1
    uint32_t type)
@


1.31
log
@Change what we consider a NACK for our Initialization messages.

RFC 5036 says the following:
  "It is possible for a pair of incompatibly configured LSRs that
  disagree on session parameters to engage in an endless sequence of
  messages as each NAKs the other's Initialization messages with Error
  Notification messages.

  An LSR MUST throttle its session setup retry attempts with an
  exponential backoff in situations where Initialization messages are
  being NAK'd".

The problem here is that the RFC is not very explicit of what can be
a NACK. We were considering only the following notification messages
as NACKs:
* Session Rejected/No Hello;
* Session Rejected/Parameters Advertisement Mode;
* Session Rejected/Parameters Max PDU Length;
* Session Rejected/Parameters Label Range;
* Session Rejected/Bad KeepAlive Time.

It turns out that some implementations can NACK with a Shutdown
notification. And there's the possibility of other implementations using
different notifications as well.

To fix this, consider any fatal notification as a NACK when the neighbor
is in the OPENSENT state (i.e. we sent an Initialization and we're
waiting for a response).

Fixes the following ANVL LDP tests: 6.19, 6.21 and 6.22
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.30 2016/05/23 19:11:42 renato Exp $ */
a132 5
		if (ntohs(tlv.length) > len - TLV_HDR_LEN) {
			session_shutdown(nbr, S_BAD_TLV_LEN, not.msgid,
			    not.type);
			return (-1);
		}
@


1.30
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.29 2016/05/23 19:09:25 renato Exp $ */
d208 1
a208 6
		if ((st.status_code == htonl(S_NO_HELLO) ||
		    st.status_code == htonl(S_PARM_ADV_MODE) ||
		    st.status_code == htonl(S_MAX_PDU_LEN) ||
		    st.status_code == htonl(S_PARM_L_RANGE) ||
		    st.status_code == htonl(S_KEEPALIVE_BAD))
		    && nbr_session_active_role(nbr))
@


1.29
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.28 2016/05/23 17:43:42 renato Exp $ */
a19 5
#include <sys/socket.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <netinet/ip.h>
a20 6
#include <net/if_dl.h>
#include <unistd.h>

#include <errno.h>
#include <event.h>
#include <stdlib.h>
@


1.28
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d39 1
a39 1
int	gen_status_tlv(struct ibuf *, uint32_t, uint32_t, uint32_t);
d238 1
a238 1
int
@


1.27
log
@Rework L2VPN code.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.26 2016/05/23 16:29:22 renato Exp $ */
d39 1
a39 1
int	gen_status_tlv(struct ibuf *, u_int32_t, u_int32_t, u_int32_t);
d45 1
a45 1
	u_int16_t	 size;
d57 1
a57 1
				size += sizeof(u_int32_t);
d80 2
a81 2
send_notification(u_int32_t status, struct tcp_conn *tcp, u_int32_t msgid,
    u_int32_t type)
d85 1
a85 1
	bzero(&nm, sizeof(nm));
d94 2
a95 2
send_notification_nbr(struct nbr *nbr, u_int32_t status, u_int32_t msgid,
    u_int32_t type)
d105 1
a105 1
recv_notification(struct nbr *nbr, char *buf, u_int16_t len)
d112 3
a114 4
	bcopy(buf, &not, sizeof(not));

	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);
d120 1
a120 1
	bcopy(buf, &st, sizeof(st));
d130 1
a130 1
	bzero(&nm, sizeof(nm));
d143 1
a143 1
		bcopy(buf, &tlv, sizeof(tlv));
d165 1
a165 1
			nm.pw_status = ntohl(*(u_int32_t *)buf);
d239 1
a239 2
gen_status_tlv(struct ibuf *buf, u_int32_t status, u_int32_t msgid,
    u_int32_t type)
d243 1
a243 1
	bzero(&st, sizeof(st));
@


1.26
log
@Fix byte order issues with notification messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.25 2016/05/23 16:25:11 renato Exp $ */
a201 1
		case MAP_TYPE_GENPWID:
@


1.25
log
@Remove unnecessary break statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.24 2016/05/23 16:20:59 renato Exp $ */
d252 3
a254 2
	st.msg_id = htonl(msgid);
	st.msg_type = htonl(type);
@


1.24
log
@Standardize some log messages and fix some inconsistencies.

We were using several different names for the same thing in our log
messages: neighbor, neighbor ID, nbr ID and LSR ID.

Standardize to always use "lsr-id" to refer to a neighbor.

Also:
* Use log_warnx() instead of log_warn() when appropriate;
* Use fatal(x) instead of err(x) when appropriate;
* Fix some inconsistent log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.23 2016/05/23 16:16:44 renato Exp $ */
a207 1
			break;
@


1.23
log
@Rework the way we handle income connection requests.

The logic of the previous code was to accept all TCP connection requests
(destined to port 646) and create a tcp_conn structure for each them. Once
the first packet of a connection was received, we would analyze the
LDP Initialization message and identify its origin by looking at the
LSR-ID field.

When parsing a received TCP packet, we would need to distinguish between
two cases: tcp packet from an LDP neighbor and tcp packet from a newborn
connection (not associated with any neighbor yet). For this reason,
the session_read() function was quite complicated.

Also, we were not keeping track of the allocated tcp_conn structures. So,
we were subject to memory leaks and even DOS attacks.

With this patch, we also accept all TCP connection requests, but with two
major differences:
* We identify the neighbor by the source address of the SYN
  packet. This is possible because we don't support label spaces, so
  the transport-address by itself is enough to identify a neighbor,
  we don't need to wait for the Initialization message;
* If there's no matching adjacency for this neighbor, then we start a
  timer of 5 seconds. If we receive a Hello packet from this neighbor
  within this interval, then we stop this timer and move on in
  the Initialization state machine. Otherwise, we send a No Hello
  Notification message and close the socket. We try to avoid sending
  the No Hello notification as much as possible because it triggers the
  backoff exponential in the remote peer, which considerably slow down
  the session establishment process.

In summary, this new approach allows for a simpler code and fixes the
memory leak problem mentioned before.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.22 2016/05/23 16:12:28 renato Exp $ */
d97 1
a97 1
	log_debug("%s: nbr ID %s, status %s", __func__, inet_ntoa(nbr->id),
@


1.22
log
@Rename a few constants to avoid confusion.

In ldpd we have the map structure, which is used to represent a label message,
and the fec structure, used to store FECs in the LIB.

As of now, ldpd supports two type of FECs:
* IPv4 prefix (FEC_TYPE_IPV4);
* PWID (FEC_TYPE_PWID).

For the label messages, the following contants were being used:
* FEC_WILDCARD;
* FEC_PREFIX (IPv4 or IPv6);
* FEC_PWID.

Since these contants have similar names to the previous ones, rename
them to:
* MAP_TYPE_WILDCARD;
* MAP_TYPE_PREFIX;
* MAP_TYPE_PWID.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.21 2016/05/23 16:04:04 renato Exp $ */
a46 4
	if (tcp->nbr)
		log_debug("%s: nbr ID %s, status %s", __func__,
		    inet_ntoa(tcp->nbr->id), notification_name(nm->status));

d97 3
@


1.21
log
@Improve the parser of TCP/session packets.

Add more safeguards against malformed packets and fix existing ones. Also,
rename a few variables and constants to match their real meaning. For
example, rename gen_msg_tlv() to gen_msg_hdr() because this function
generates an LDP header, not a TLV.

Finally, clean-up all the send_* functions so they all follow the same
pattern.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.20 2016/05/23 15:59:55 renato Exp $ */
d58 1
a58 1
		case FEC_PWID:
d202 2
a203 2
		case FEC_PWID:
		case FEC_GENPWID:
@


1.20
log
@Fix issue with the exponential backoff timer.

Do not start the exponential backoff timer when playing the passive role
of the session establishment process.

RFC 5036 - Section 2.5.3 says:
"The specific session establishment action that must be
delayed is the attempt to open the session transport connection by
the LSR playing the active role".
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.19 2016/05/23 15:14:08 renato Exp $ */
a50 3
	if ((buf = ibuf_open(LDP_MAX_LEN)) == NULL)
		fatal(__func__);

d52 1
a52 1
	size = LDP_HDR_SIZE + sizeof(struct ldp_msg) + STATUS_SIZE;
d66 3
a69 1

d71 1
a71 3

	gen_msg_tlv(buf, MSG_TYPE_NOTIFICATION, size);

d239 1
a239 1
	return (ntohs(not.length));
@


1.19
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.18 2015/07/21 04:52:29 renato Exp $ */
d226 1
a226 1
		if (st.status_code == htonl(S_NO_HELLO) ||
d231 1
@


1.18
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.17 2014/10/25 03:23:49 lteo Exp $ */
d48 1
a48 1
		log_debug("send_notification_full: nbr ID %s, status %s",
d52 1
a52 1
		fatal("send_notification");
@


1.17
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.16 2013/10/15 20:31:13 renato Exp $ */
d42 1
a42 12
send_notification_nbr(struct nbr *nbr, u_int32_t status, u_int32_t msgid,
    u_int32_t type)
{
	log_debug("send_notification_nbr: nbr ID %s, status %s",
	    inet_ntoa(nbr->id), notification_name(status));
	send_notification(status, nbr->tcp, msgid, type);
	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
}

void
send_notification(u_int32_t status, struct tcp_conn *tcp, u_int32_t msgid,
    u_int32_t type)
d47 4
d54 1
d56 12
d75 6
a80 1
	size -= sizeof(struct ldp_msg);
d82 2
a83 1
	gen_status_tlv(buf, status, msgid, type);
d85 21
a105 1
	evbuf_enqueue(&tcp->wbuf, buf);
d113 2
a114 2

	log_debug("recv_notification: neighbor ID %s", inet_ntoa(nbr->id));
d132 64
d197 18
a214 1
	/* TODO optional parameters: ext status, returned PDU and msg */
d236 4
a239 1
	/* XXX in some cases we should inform the RDE about non-fatal ones */
d256 2
a257 2
	st.msg_id = msgid;
	st.msg_type = type;
@


1.16
log
@Improve debug and error logs.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.15 2013/10/15 19:59:53 renato Exp $ */
a23 1
#include <netinet/in_systm.h>
@


1.15
log
@Improve parsing of LDP messages.
Add more sanity checks and send proper notification messages on error
conditions.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.14 2013/06/04 02:34:48 claudio Exp $ */
d46 2
@


1.14
log
@Always accept TCP connection requests and identify to which neighbor
it belongs only _after_ receiving an Initialization message containing
the information we need. Before an Initialization message is received,
the TCP connection shouldn't be associated with any neighbor/adjacency.
Therefor refactor that part into a own module.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.13 2013/06/04 01:32:16 claudio Exp $ */
d115 2
a116 1
		    st.status_code == htonl(S_PARM_L_RANGE))
@


1.13
log
@Properly implement the exponential backoff timer on session initialization

According with the section 2.5.3 of RFC 5036, an LSR must throttle its
session setup retry attempts with an exponential backoff in situations
where Initialization messages are being NAK'd (because of disagreements
on session parameters). It doesn't mention using this procedure for TCP
connection failures. With that said, start the inactive delay timer only
after receiving an appropriate notification message.

When playing the active role of the initialization process, throttle the
session setup retry attempts by not connecting to the remote peer. When
playing the passive role, throttle the session setup retry attempts by
delaying the processing of the received Initialization message.

Diff by Renato Westphal, adjusted by myself
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.12 2013/06/01 19:42:07 claudio Exp $ */
d46 1
a46 4
	struct ibuf	*buf;

	buf = send_notification(status, msgid, type);
	evbuf_enqueue(&nbr->wbuf, buf);
d50 3
a52 2
struct ibuf *
send_notification(u_int32_t status, u_int32_t msgid, u_int32_t type)
d72 1
a72 1
	return (buf);
@


1.12
log
@Restart the keepalive timer whenever a LDP PDU is sent. There is no need
to send a keepalive packet when a other PDU was sent out.
Also add a missing NBR_EVT_PDU_RCVD call to recv_address() which restarts
the session keepalive timeout. All other places already do that.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.11 2013/06/01 18:47:07 claudio Exp $ */
d114 6
@


1.11
log
@Drop support for per-interface labelspaces.
Support for per-interface labelspaces is only necessary for legacy ATM/FR
interfaces running in cell-mode. We shouldn't worry about this.
For platform-wide label spaces the label space id is always 0.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.10 2013/06/01 18:35:02 claudio Exp $ */
d50 1
@


1.10
log
@Drop support for passive interfaces.
Support for passive interfaces was inherited from ospfd but it doesn't
make any sense at all for ldpd.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.9 2011/01/20 23:12:33 jasper Exp $ */
d48 1
a48 1
	buf = send_notification(status, nbr->iface, msgid, type);
d53 1
a53 2
send_notification(u_int32_t status, struct iface *iface, u_int32_t msgid,
    u_int32_t type)
d63 1
a63 1
	gen_ldp_hdr(buf, iface, size);
@


1.9
log
@- tyop, recieve -> receive

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.8 2010/11/04 09:52:16 claudio Exp $ */
a46 3

	if (nbr->iface->passive)
		return;
@


1.8
log
@Rewrite all packet parsers to be more careful about alignment. Until
now ldpd had no chance to run on a strict alignment architecture but
this makes ldpd happy on sparc64. Be careful to do all needed overflow
checks and try to make all parsing functions look similar.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.7 2010/05/26 13:56:08 nicm Exp $ */
d108 1
a108 1
		log_warnx("recieved notification from neighbor %s: %s",
d112 1
a112 1
		log_debug("recieved non-fatal notification from neighbor "
@


1.7
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.6 2010/05/14 13:49:09 claudio Exp $ */
d83 2
a84 2
	struct ldp_msg		*not;
	struct status_tlv	*st;
d88 1
a88 6
	not = (struct ldp_msg *)buf;

	if ((len - TLV_HDR_LEN) < ntohs(not->length)) {
		session_shutdown(nbr, S_BAD_MSG_LEN, not->msgid, not->type);
		return (-1);
	}
d93 5
a97 1
	st = (struct status_tlv *)buf;
d99 3
a101 3
	if (len < STATUS_SIZE ||
	    (STATUS_SIZE - TLV_HDR_LEN) != ntohs(st->length)) {
		session_shutdown(nbr, S_BAD_TLV_LEN, not->msgid, not->type);
d105 3
a107 1
	if (st->status_code & htonl(STATUS_FATAL))
d110 1
a110 1
		    notification_name(ntohl(st->status_code)));
d114 1
a114 1
		    notification_name(ntohl(st->status_code)));
d116 1
a116 1
	if (st->status_code & htonl(STATUS_FATAL)) {
d120 1
d122 1
a122 1
	return (ntohs(not->length));
@


1.6
log
@Do not send notifications directly onto the wire. Decide in the caller how
to send the notification. On accept use write() else queue message and try
to send the queued messages out via msgbuf_write(). This may still fail but
is better then the code beforehands.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.5 2010/05/12 13:31:35 claudio Exp $ */
d40 1
a40 1
int	gen_status_tlv(struct buf *, u_int32_t, u_int32_t, u_int32_t);
d46 1
a46 1
	struct buf	*buf;
d55 1
a55 1
struct buf *
d59 1
a59 1
	struct buf	*buf;
d62 1
a62 1
	if ((buf = buf_open(LDP_MAX_LEN)) == NULL)
d124 1
a124 1
gen_status_tlv(struct buf *buf, u_int32_t status, u_int32_t msgid,
d138 1
a138 1
	return (buf_add(buf, &st, STATUS_SIZE));
@


1.5
log
@Make sure there is a difference in the log of non-fatal and fatal
notifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.4 2010/04/15 15:44:37 claudio Exp $ */
d46 2
d51 2
a52 3
	log_debug("send_notification: neighbor ID %s", inet_ntoa(nbr->id));

	send_notification(status, nbr->iface, nbr->fd, msgid, type);
d55 3
a57 3
void
send_notification(u_int32_t status, struct iface *iface, int fd,
    u_int32_t msgid, u_int32_t type)
d77 1
a77 2
	write(fd, buf->buf, buf->wpos);
	buf_free(buf);
@


1.4
log
@Log recieved notifications in a human understanable way. Makes debugging
a bit easier.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.3 2010/02/20 21:28:39 michele Exp $ */
d111 2
a112 2
		log_debug("recieved notification from neighbor %s: %s",
		    inet_ntoa(nbr->id),
@


1.3
log
@Make send_* functions return void (and not int) as they can just succeed
or fatal().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.2 2009/06/05 22:34:45 michele Exp $ */
d105 9
@


1.2
log
@Correctly send notification messages when errors occur.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: notification.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d42 1
a42 1
int
d47 1
a47 1
		return (0);
d51 1
a51 1
	return (send_notification(status, nbr->iface, nbr->fd, msgid, type));
d54 1
a54 1
int
a77 2

	return (0);
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d40 1
a40 1
int	gen_status_tlv(struct buf *, int);
d43 2
a44 1
send_notification_nbr(struct nbr *nbr, u_int32_t status)
d51 1
a51 1
	return (send_notification(status, nbr->iface, nbr->fd));
d55 2
a56 1
send_notification(int status, struct iface *iface, int fd)
d74 1
a74 1
	gen_status_tlv(buf, status);
a86 1
	u_int32_t		 messageid;
d93 1
a93 1
		/* XXX: send notification */
a96 2
	messageid = not->msgid;

d104 1
a104 1
		/* XXX: send notification */
d117 2
a118 1
gen_status_tlv(struct buf *buf, int status)
d128 2
a129 3
	/* XXX */
	st.msg_id = 0;
	st.msg_type = 0;
@

