head	1.37;
access;
symbols
	OPENBSD_6_1:1.37.0.2
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.37
date	2017.03.04.00.15.35;	author renato;	state Exp;
branches;
next	1.36;
commitid	BOl8emh4A0ljUk3b;

1.36
date	2017.03.04.00.09.17;	author renato;	state Exp;
branches;
next	1.35;
commitid	tAFME29r3wKSl8xr;

1.35
date	2017.03.04.00.06.10;	author renato;	state Exp;
branches;
next	1.34;
commitid	GMDFIgs8eMuH7Rxe;

1.34
date	2017.03.03.23.44.35;	author renato;	state Exp;
branches;
next	1.33;
commitid	mV5MMkodXlL2okSe;

1.33
date	2016.07.16.19.20.16;	author renato;	state Exp;
branches;
next	1.32;
commitid	YLPvWL4I6VM5sc5a;

1.32
date	2016.07.01.23.36.38;	author renato;	state Exp;
branches;
next	1.31;
commitid	h9Qy21EPYXbAFnoh;

1.31
date	2016.07.01.23.29.55;	author renato;	state Exp;
branches;
next	1.30;
commitid	OkOx7tFZtmlIlivU;

1.30
date	2016.06.27.19.06.33;	author renato;	state Exp;
branches;
next	1.29;
commitid	OXyvybFBtSb4ppHx;

1.29
date	2016.06.11.01.55.35;	author renato;	state Exp;
branches;
next	1.28;
commitid	GgWpGoWeBPM557df;

1.28
date	2016.06.08.21.28.09;	author renato;	state Exp;
branches;
next	1.27;
commitid	wLF0xY2vA77W54FU;

1.27
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.26;
commitid	AQBoOveMRKjtVfFv;

1.26
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.25;
commitid	t07H0Mk6WGdVWB0W;

1.25
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.24;
commitid	D7VvXbswyzx5Ahb2;

1.24
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.23;
commitid	VpAym8dVR6eY4drQ;

1.23
date	2016.05.23.16.20.59;	author renato;	state Exp;
branches;
next	1.22;
commitid	nAtgYzDo97D7UnEI;

1.22
date	2016.05.23.16.14.36;	author renato;	state Exp;
branches;
next	1.21;
commitid	hNzA87VdOHsaOms9;

1.21
date	2016.05.23.16.04.04;	author renato;	state Exp;
branches;
next	1.20;
commitid	sfghEB6dR4Eaf77g;

1.20
date	2016.05.23.16.01.59;	author renato;	state Exp;
branches;
next	1.19;
commitid	mPlo1gOiTGCVTctp;

1.19
date	2016.05.23.15.59.55;	author renato;	state Exp;
branches;
next	1.18;
commitid	2jPamx70j4TMPRN1;

1.18
date	2016.05.23.15.43.11;	author renato;	state Exp;
branches;
next	1.17;
commitid	weS0xzAgWBV4f0dh;

1.17
date	2016.05.23.15.41.04;	author renato;	state Exp;
branches;
next	1.16;
commitid	GWVZlQK3ZbMPg5pq;

1.16
date	2016.05.23.15.14.07;	author renato;	state Exp;
branches;
next	1.15;
commitid	l3e6PhvoAh8C7elc;

1.15
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.14;
commitid	2uw1UTO4k6erpWzK;

1.14
date	2013.10.15.20.21.25;	author renato;	state Exp;
branches;
next	1.13;

1.13
date	2013.10.15.19.59.52;	author renato;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.04.02.34.48;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.04.01.32.16;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.01.19.28.55;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.01.18.47.07;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.01.18.35.02;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.10.12.02.48;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.11.04.09.52.16;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.25.17.40.46;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.20.21.28.39;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.22.34.45;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Implement RFC 5919 (LDP End-of-LIB).
@
text
@/*	$OpenBSD: init.c,v 1.36 2017/03/04 00:09:17 renato Exp $ */

/*
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <arpa/inet.h>
#include <string.h>

#include "ldpd.h"
#include "ldpe.h"
#include "log.h"

static int	gen_init_prms_tlv(struct ibuf *, struct nbr *);
static int	gen_cap_dynamic_tlv(struct ibuf *);
static int	gen_cap_twcard_tlv(struct ibuf *, int);
static int	gen_cap_unotif_tlv(struct ibuf *, int);

void
send_init(struct nbr *nbr)
{
	struct ibuf		*buf;
	uint16_t		 size;
	int			 err = 0;

	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));

	size = LDP_HDR_SIZE + LDP_MSG_SIZE + SESS_PRMS_SIZE +
	    CAP_TLV_DYNAMIC_SIZE + CAP_TLV_TWCARD_SIZE + CAP_TLV_UNOTIF_SIZE;
	if ((buf = ibuf_open(size)) == NULL)
		fatal(__func__);

	err |= gen_ldp_hdr(buf, size);
	size -= LDP_HDR_SIZE;
	err |= gen_msg_hdr(buf, MSG_TYPE_INIT, size);
	err |= gen_init_prms_tlv(buf, nbr);
	err |= gen_cap_dynamic_tlv(buf);
	err |= gen_cap_twcard_tlv(buf, 1);
	err |= gen_cap_unotif_tlv(buf, 1);
	if (err) {
		ibuf_free(buf);
		return;
	}

	evbuf_enqueue(&nbr->tcp->wbuf, buf);
}

int
recv_init(struct nbr *nbr, char *buf, uint16_t len)
{
	struct ldp_msg		msg;
	struct sess_prms_tlv	sess;
	uint16_t		max_pdu_len;
	int			caps_rcvd = 0;

	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));

	memcpy(&msg, buf, sizeof(msg));
	buf += LDP_MSG_SIZE;
	len -= LDP_MSG_SIZE;

	if (len < SESS_PRMS_SIZE) {
		session_shutdown(nbr, S_BAD_MSG_LEN, msg.id, msg.type);
		return (-1);
	}
	memcpy(&sess, buf, sizeof(sess));
	if (ntohs(sess.length) != SESS_PRMS_LEN) {
		session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
		return (-1);
	}
	if (ntohs(sess.proto_version) != LDP_VERSION) {
		session_shutdown(nbr, S_BAD_PROTO_VER, msg.id, msg.type);
		return (-1);
	}
	if (ntohs(sess.keepalive_time) < MIN_KEEPALIVE) {
		session_shutdown(nbr, S_KEEPALIVE_BAD, msg.id, msg.type);
		return (-1);
	}
	if (sess.lsr_id != leconf->rtr_id.s_addr ||
	    ntohs(sess.lspace_id) != 0) {
		session_shutdown(nbr, S_NO_HELLO, msg.id, msg.type);
		return (-1);
	}

	buf += SESS_PRMS_SIZE;
	len -= SESS_PRMS_SIZE;

	/* Optional Parameters */
	while (len > 0) {
		struct tlv 	tlv;
		uint16_t	tlv_type;
		uint16_t	tlv_len;

		if (len < sizeof(tlv)) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
			return (-1);
		}

		memcpy(&tlv, buf, TLV_HDR_SIZE);
		tlv_type = ntohs(tlv.type);
		tlv_len = ntohs(tlv.length);
		if (tlv_len + TLV_HDR_SIZE > len) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
			return (-1);
		}
		buf += TLV_HDR_SIZE;
		len -= TLV_HDR_SIZE;

		/*
		 * RFC 5561 - Section 6:
		 * "The S-bit of a Capability Parameter in an Initialization
		 * message MUST be 1 and SHOULD be ignored on receipt".
		 */
		switch (tlv_type) {
		case TLV_TYPE_ATMSESSIONPAR:
			session_shutdown(nbr, S_BAD_TLV_VAL, msg.id, msg.type);
			return (-1);
		case TLV_TYPE_FRSESSION:
			session_shutdown(nbr, S_BAD_TLV_VAL, msg.id, msg.type);
			return (-1);
		case TLV_TYPE_DYNAMIC_CAP:
			if (tlv_len != CAP_TLV_DYNAMIC_LEN) {
				session_shutdown(nbr, S_BAD_TLV_LEN, msg.id,
				    msg.type);
				return (-1);
			}

			if (caps_rcvd & F_CAP_TLV_RCVD_DYNAMIC) {
				session_shutdown(nbr, S_BAD_TLV_VAL, msg.id,
				    msg.type);
				return (-1);
			}
			caps_rcvd |= F_CAP_TLV_RCVD_DYNAMIC;

			nbr->flags |= F_NBR_CAP_DYNAMIC;

			log_debug("%s: lsr-id %s announced the Dynamic "
			    "Capability Announcement capability", __func__,
			    inet_ntoa(nbr->id));
			break;
		case TLV_TYPE_TWCARD_CAP:
			if (tlv_len != CAP_TLV_TWCARD_LEN) {
				session_shutdown(nbr, S_BAD_TLV_LEN, msg.id,
				    msg.type);
				return (-1);
			}

			if (caps_rcvd & F_CAP_TLV_RCVD_TWCARD) {
				session_shutdown(nbr, S_BAD_TLV_VAL, msg.id,
				    msg.type);
				return (-1);
			}
			caps_rcvd |= F_CAP_TLV_RCVD_TWCARD;

			nbr->flags |= F_NBR_CAP_TWCARD;

			log_debug("%s: lsr-id %s announced the Typed Wildcard "
			    "FEC capability", __func__, inet_ntoa(nbr->id));
			break;
		case TLV_TYPE_UNOTIF_CAP:
			if (tlv_len != CAP_TLV_UNOTIF_LEN) {
				session_shutdown(nbr, S_BAD_TLV_LEN, msg.id,
				    msg.type);
				return (-1);
			}

			if (caps_rcvd & F_CAP_TLV_RCVD_UNOTIF) {
				session_shutdown(nbr, S_BAD_TLV_VAL, msg.id,
				    msg.type);
				return (-1);
			}
			caps_rcvd |= F_CAP_TLV_RCVD_UNOTIF;

			nbr->flags |= F_NBR_CAP_UNOTIF;

			log_debug("%s: lsr-id %s announced the Unrecognized "
			    "Notification capability", __func__,
			    inet_ntoa(nbr->id));
			break;
		default:
			if (!(ntohs(tlv.type) & UNKNOWN_FLAG))
				send_notification_rtlvs(nbr, S_UNSSUPORTDCAP,
				    msg.id, msg.type, tlv_type, tlv_len, buf);
			/* ignore unknown tlv */
			break;
		}
		buf += tlv_len;
		len -= tlv_len;
	}

	nbr->keepalive = min(nbr_get_keepalive(nbr->af, nbr->id),
	    ntohs(sess.keepalive_time));

	max_pdu_len = ntohs(sess.max_pdu_len);
	/*
	 * RFC 5036 - Section 3.5.3:
	 * "A value of 255 or less specifies the default maximum length of
	 * 4096 octets".
	 */
	if (max_pdu_len <= 255)
		max_pdu_len = LDP_MAX_LEN;
	nbr->max_pdu_len = min(max_pdu_len, LDP_MAX_LEN);

	nbr_fsm(nbr, NBR_EVT_INIT_RCVD);

	return (0);
}

void
send_capability(struct nbr *nbr, uint16_t capability, int enable)
{
	struct ibuf		*buf;
	uint16_t		 size;
	int			 err = 0;

	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));

	size = LDP_HDR_SIZE + LDP_MSG_SIZE + CAP_TLV_DYNAMIC_SIZE;
	if ((buf = ibuf_open(size)) == NULL)
		fatal(__func__);

	err |= gen_ldp_hdr(buf, size);
	size -= LDP_HDR_SIZE;
	err |= gen_msg_hdr(buf, MSG_TYPE_CAPABILITY, size);

	switch (capability) {
	case TLV_TYPE_TWCARD_CAP:
		err |= gen_cap_twcard_tlv(buf, enable);
		break;
	case TLV_TYPE_UNOTIF_CAP:
		err |= gen_cap_unotif_tlv(buf, enable);
		break;
	case TLV_TYPE_DYNAMIC_CAP:
		/*
		 * RFC 5561 - Section 9:
		 * "An LDP speaker MUST NOT include the Dynamic Capability
		 * Announcement Parameter in Capability messages sent to
		 * its peers".
		 */
		/* FALLTHROUGH */
	default:
		fatalx("send_capability: unsupported capability");
	}

	if (err) {
		ibuf_free(buf);
		return;
	}

	evbuf_enqueue(&nbr->tcp->wbuf, buf);
	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
}

int
recv_capability(struct nbr *nbr, char *buf, uint16_t len)
{
	struct ldp_msg	 msg;
	int		 enable = 0;
	int		 caps_rcvd = 0;

	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));

	memcpy(&msg, buf, sizeof(msg));
	buf += LDP_MSG_SIZE;
	len -= LDP_MSG_SIZE;

	/* Optional Parameters */
	while (len > 0) {
		struct tlv 	 tlv;
		uint16_t	 tlv_type;
		uint16_t	 tlv_len;
		uint8_t		 reserved;

		if (len < sizeof(tlv)) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
			return (-1);
		}

		memcpy(&tlv, buf, TLV_HDR_SIZE);
		tlv_type = ntohs(tlv.type);
		tlv_len = ntohs(tlv.length);
		if (tlv_len + TLV_HDR_SIZE > len) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
			return (-1);
		}
		buf += TLV_HDR_SIZE;
		len -= TLV_HDR_SIZE;

		switch (tlv_type) {
		case TLV_TYPE_TWCARD_CAP:
			if (tlv_len != CAP_TLV_TWCARD_LEN) {
				session_shutdown(nbr, S_BAD_TLV_LEN, msg.id,
				    msg.type);
				return (-1);
			}

			if (caps_rcvd & F_CAP_TLV_RCVD_TWCARD) {
				session_shutdown(nbr, S_BAD_TLV_VAL, msg.id,
				    msg.type);
				return (-1);
			}
			caps_rcvd |= F_CAP_TLV_RCVD_TWCARD;

			memcpy(&reserved, buf, sizeof(reserved));
			enable = reserved & STATE_BIT;
			if (enable)
				nbr->flags |= F_NBR_CAP_TWCARD;
			else
				nbr->flags &= ~F_NBR_CAP_TWCARD;

			log_debug("%s: lsr-id %s %s the Typed Wildcard FEC "
			    "capability", __func__, inet_ntoa(nbr->id),
			    (enable) ? "announced" : "withdrew");
			break;
		case TLV_TYPE_UNOTIF_CAP:
			if (tlv_len != CAP_TLV_UNOTIF_LEN) {
				session_shutdown(nbr, S_BAD_TLV_LEN, msg.id,
				    msg.type);
				return (-1);
			}

			if (caps_rcvd & F_CAP_TLV_RCVD_UNOTIF) {
				session_shutdown(nbr, S_BAD_TLV_VAL, msg.id,
				    msg.type);
				return (-1);
			}
			caps_rcvd |= F_CAP_TLV_RCVD_UNOTIF;

			memcpy(&reserved, buf, sizeof(reserved));
			enable = reserved & STATE_BIT;
			if (enable)
				nbr->flags |= F_NBR_CAP_UNOTIF;
			else
				nbr->flags &= ~F_NBR_CAP_UNOTIF;

			log_debug("%s: lsr-id %s %s the Unrecognized "
			    "Notification capability", __func__,
			    inet_ntoa(nbr->id), (enable) ? "announced" :
			    "withdrew");
			break;
		case TLV_TYPE_DYNAMIC_CAP:
			/*
		 	 * RFC 5561 - Section 9:
			 * "An LDP speaker that receives a Capability message
			 * from a peer that includes the Dynamic Capability
			 * Announcement Parameter SHOULD silently ignore the
			 * parameter and process any other Capability Parameters
			 * in the message".
			 */
			/* FALLTHROUGH */
		default:
			if (!(ntohs(tlv.type) & UNKNOWN_FLAG))
				send_notification_rtlvs(nbr, S_UNSSUPORTDCAP,
				    msg.id, msg.type, tlv_type, tlv_len, buf);
			/* ignore unknown tlv */
			break;
		}
		buf += tlv_len;
		len -= tlv_len;
	}

	nbr_fsm(nbr, NBR_EVT_PDU_RCVD);

	return (0);
}

static int
gen_init_prms_tlv(struct ibuf *buf, struct nbr *nbr)
{
	struct sess_prms_tlv	parms;

	memset(&parms, 0, sizeof(parms));
	parms.type = htons(TLV_TYPE_COMMONSESSION);
	parms.length = htons(SESS_PRMS_LEN);
	parms.proto_version = htons(LDP_VERSION);
	parms.keepalive_time = htons(nbr_get_keepalive(nbr->af, nbr->id));
	parms.reserved = 0;
	parms.pvlim = 0;
	parms.max_pdu_len = 0;
	parms.lsr_id = nbr->id.s_addr;
	parms.lspace_id = 0;

	return (ibuf_add(buf, &parms, SESS_PRMS_SIZE));
}

static int
gen_cap_dynamic_tlv(struct ibuf *buf)
{
	struct capability_tlv	cap;

	memset(&cap, 0, sizeof(cap));
	cap.type = htons(TLV_TYPE_DYNAMIC_CAP);
	cap.length = htons(CAP_TLV_DYNAMIC_LEN);
	/* the S-bit is always 1 for the Dynamic Capability Announcement */
	cap.reserved = STATE_BIT;

	return (ibuf_add(buf, &cap, CAP_TLV_DYNAMIC_SIZE));
}

static int
gen_cap_twcard_tlv(struct ibuf *buf, int enable)
{
	struct capability_tlv	cap;

	memset(&cap, 0, sizeof(cap));
	cap.type = htons(TLV_TYPE_TWCARD_CAP);
	cap.length = htons(CAP_TLV_TWCARD_LEN);
	if (enable)
		cap.reserved = STATE_BIT;

	return (ibuf_add(buf, &cap, CAP_TLV_TWCARD_SIZE));
}

static int
gen_cap_unotif_tlv(struct ibuf *buf, int enable)
{
	struct capability_tlv	cap;

	memset(&cap, 0, sizeof(cap));
	cap.type = htons(TLV_TYPE_UNOTIF_CAP);
	cap.length = htons(CAP_TLV_UNOTIF_LEN);
	if (enable)
		cap.reserved = STATE_BIT;

	return (ibuf_add(buf, &cap, CAP_TLV_UNOTIF_SIZE));
}
@


1.36
log
@Implement RFC 5918 (Typed Wildcard FEC).
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.35 2017/03/04 00:06:10 renato Exp $ */
d30 1
d42 1
a42 1
	    CAP_TLV_DYNAMIC_SIZE + CAP_TLV_TWCARD_SIZE;
d52 1
d173 20
d243 3
d328 26
d425 14
@


1.35
log
@Implement RFC 5561 (LDP Capabilities).

This patch per-se doesn't introduce any useful functionality, but prepares
the ground for new enhancements to ldpd (i.e. implementation of new RFCs
that make use of LDP capabilities).
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.34 2017/03/03 23:44:35 renato Exp $ */
d29 1
d41 1
a41 1
	    CAP_TLV_DYNAMIC_SIZE;
d50 1
d152 19
d218 3
d246 2
d260 1
d278 25
d360 14
@


1.34
log
@Kill send_notification_nbr().

Be more clever and trigger the PDU SENT event inside send_notification()
when tcp->nbr is set. This way we can eliminate send_notification_nbr()
and always use send_notification() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.33 2016/07/16 19:20:16 renato Exp $ */
d28 1
d39 2
a40 1
	size = LDP_HDR_SIZE + LDP_MSG_SIZE + SESS_PRMS_SIZE;
a46 1
	size -= LDP_MSG_SIZE;
d48 1
d63 1
d100 1
d109 1
d118 6
a123 1
		switch (ntohs(tlv.type)) {
d130 20
d152 2
a153 2
				send_notification(nbr->tcp, S_UNKNOWN_TLV,
				    msg.id, msg.type);
d179 98
d294 14
@


1.33
log
@Fix parsing of mal-formed optional TLVs/Sub-TLVs.

We must detect if a TLV's length extends beyond the end of the containing
message. And, if so, send a fatal "Bad TLV Length" notification message.

Found with the Mu Dynamics Mu-8000 protocol fuzzer.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.32 2016/07/01 23:36:38 renato Exp $ */
d122 1
a122 1
				send_notification_nbr(nbr, S_UNKNOWN_TLV,
@


1.32
log
@More renaming and whitespace cleanup.

No binary change after "strip -s".
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.31 2016/07/01 23:29:55 renato Exp $ */
a27 1
static int	tlv_decode_opt_init_prms(char *, uint16_t);
a60 1
	int			r;
d94 35
a128 5
	/* just ignore all optional TLVs for now */
	r = tlv_decode_opt_init_prms(buf, len);
	if (r == -1 || r != len) {
		session_shutdown(nbr, S_BAD_TLV_VAL, msg.id, msg.type);
		return (-1);
a165 35
}

static int
tlv_decode_opt_init_prms(char *buf, uint16_t len)
{
	struct tlv	tlv;
	uint16_t	tlv_len;
	int		total = 0;

	 while (len >= sizeof(tlv)) {
		memcpy(&tlv, buf, TLV_HDR_SIZE);
		buf += TLV_HDR_SIZE;
		len -= TLV_HDR_SIZE;
		total += TLV_HDR_SIZE;
		tlv_len = ntohs(tlv.length);

		switch (ntohs(tlv.type)) {
		case TLV_TYPE_ATMSESSIONPAR:
			log_warnx("ATM session parameter present");
			return (-1);
		case TLV_TYPE_FRSESSION:
			log_warnx("FR session parameter present");
			return (-1);
		default:
			/* if unknown flag set, ignore TLV */
			if (!(ntohs(tlv.type) & UNKNOWN_FLAG))
				return (-1);
			break;
		}
		buf += tlv_len;
		len -= tlv_len;
		total += tlv_len;
	}

	return (total);
@


1.31
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.30 2016/06/27 19:06:33 renato Exp $ */
d59 1
a59 1
	struct ldp_msg		init;
d66 1
a66 1
	memcpy(&init, buf, sizeof(init));
d71 1
a71 1
		session_shutdown(nbr, S_BAD_MSG_LEN, init.msgid, init.type);
d75 2
a76 2
	if (ntohs(sess.length) != SESS_PRMS_SIZE - TLV_HDR_LEN) {
		session_shutdown(nbr, S_BAD_TLV_LEN, init.msgid, init.type);
d80 1
a80 1
		session_shutdown(nbr, S_BAD_PROTO_VER, init.msgid, init.type);
d84 1
a84 1
		session_shutdown(nbr, S_KEEPALIVE_BAD, init.msgid, init.type);
d89 1
a89 1
		session_shutdown(nbr, S_NO_HELLO, init.msgid, init.type);
d99 1
a99 1
		session_shutdown(nbr, S_BAD_TLV_VAL, init.msgid, init.type);
d128 1
a128 1
	parms.length = htons(SESS_PRMS_SIZE - TLV_HDR_LEN);
d148 4
a151 4
		memcpy(&tlv, buf, TLV_HDR_LEN);
		buf += TLV_HDR_LEN;
		len -= TLV_HDR_LEN;
		total += TLV_HDR_LEN;
@


1.30
log
@Handle ibuf_add() errors.

tweaks from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.29 2016/06/11 01:55:35 renato Exp $ */
d27 1
a27 1
static int	gen_init_prms_tlv(struct ibuf *, struct nbr *, uint16_t);
d47 1
a47 1
	err |= gen_init_prms_tlv(buf, nbr, size);
a74 4
	if (ntohs(sess.keepalive_time) < MIN_KEEPALIVE) {
		session_shutdown(nbr, S_KEEPALIVE_BAD, init.msgid, init.type);
		return (-1);
	}
d83 4
d122 1
a122 1
gen_init_prms_tlv(struct ibuf *buf, struct nbr *nbr, uint16_t size)
d128 1
a128 1
	parms.length = htons(size - TLV_HDR_LEN);
@


1.29
log
@Make all TLV parsing functions look the same for consistency.

Also, add one more safety check in recv_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.28 2016/06/08 21:28:09 renato Exp $ */
d35 1
d43 1
a43 1
	gen_ldp_hdr(buf, size);
d45 1
a45 1
	gen_msg_hdr(buf, MSG_TYPE_INIT, size);
d47 5
a51 1
	gen_init_prms_tlv(buf, nbr, size);
@


1.28
log
@Add one more safety check for Initialization messages.

RFC 5036 says the following about the "Receiver LDP Identifier" field:
  "Identifies the receiver's label space.  This LDP Identifier, together
  with the sender's LDP Identifier in the PDU header, enables the receiver
  to match the Initialization message with one of its Hello adjacencies;

  If there is no matching Hello adjacency, the LSR MUST send a Session
  Rejected/No Hello Notification message in response to the Initialization
  message and not establish the session".

This is one more case of LDP being more complex than what it should have
been.  Since LDP support MPLS label spaces (for ATM and FR), just the
sender's LSR-ID in the PDU header is not enough for identifying an Hello
adjacency. We also need the receiver's label space, and that's what this
field gives us. In fact, this field contains the full receiver's LSR-ID,
but the IP part doesn't really matter.

Since we don't support label spaces (and never will), we were happily
ignoring this field. This patch changes this to fix some errors with ANVL.

Fixes the following ANVL LDP tests: 6.5, 6.6 and 6.11.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.27 2016/05/23 19:11:42 renato Exp $ */
d57 1
d92 2
a93 1
	if (tlv_decode_opt_init_prms(buf, len) == -1) {
d143 4
a146 1
		memcpy(&tlv, buf, sizeof(tlv));
d148 1
d162 3
a164 3
		buf += TLV_HDR_LEN + tlv_len;
		len -= TLV_HDR_LEN + tlv_len;
		total += TLV_HDR_LEN + tlv_len;
@


1.27
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.26 2016/05/23 19:09:25 renato Exp $ */
a72 1

a76 1

d79 5
@


1.26
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.25 2016/05/23 18:58:48 renato Exp $ */
a19 5
#include <sys/socket.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <netinet/ip.h>
a20 6
#include <net/if_dl.h>
#include <unistd.h>

#include <errno.h>
#include <event.h>
#include <stdlib.h>
d24 1
a24 1
#include "ldp.h"
a25 1
#include "ldpe.h"
@


1.25
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.24 2016/05/23 17:43:42 renato Exp $ */
d39 2
a40 4
extern struct ldpd_conf        *leconf;

int	gen_init_prms_tlv(struct ibuf *, struct nbr *, uint16_t);
int	tlv_decode_opt_init_prms(char *, uint16_t);
d123 1
a123 1
int
d142 1
a142 1
int
@


1.24
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d107 1
a107 1
	nbr->keepalive = min(nbr_get_keepalive(nbr->raddr),
d134 1
a134 1
	parms.keepalive_time = htons(nbr_get_keepalive(nbr->raddr));
@


1.23
log
@Standardize some log messages and fix some inconsistencies.

We were using several different names for the same thing in our log
messages: neighbor, neighbor ID, nbr ID and LSR ID.

Standardize to always use "lsr-id" to refer to a neighbor.

Also:
* Use log_warnx() instead of log_warn() when appropriate;
* Use fatal(x) instead of err(x) when appropriate;
* Fix some inconsistent log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.22 2016/05/23 16:14:36 renato Exp $ */
d41 2
a42 2
int	gen_init_prms_tlv(struct ibuf *, struct nbr *, u_int16_t);
int	tlv_decode_opt_init_prms(char *, u_int16_t);
d48 1
a48 1
	u_int16_t		 size;
d66 1
a66 1
recv_init(struct nbr *nbr, char *buf, u_int16_t len)
d74 3
a76 4
	bcopy(buf, &init, sizeof(init));

	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);
d82 5
a86 1
	bcopy(buf, &sess, sizeof(sess));
d126 1
a126 1
gen_init_prms_tlv(struct ibuf *buf, struct nbr *nbr, u_int16_t size)
d130 1
a130 4
	/* We want just the size of the value */
	size -= TLV_HDR_LEN;

	bzero(&parms, sizeof(parms));
d132 1
a132 1
	parms.length = htons(size);
d145 1
a145 1
tlv_decode_opt_init_prms(char *buf, u_int16_t len)
d148 2
a149 2
	int		cons = 0;
	u_int16_t	tlv_len;
d152 1
a152 1
		bcopy(buf, &tlv, sizeof(tlv));
@


1.22
log
@More renaming.

Rename a few more things to improve readability.

* s/F_PW_CONTROLWORD_CONF/F_PW_CWORD_CONF/ (shorter)
* s/F_PW_CONTROLWORD/F_PW_CWORD/ (shorter)
* s/LDPD_FLAG_*/F_LDPD_*/ (consistency)
* s/lde_nbr_address/lde_addr/ (shorter)
* s/ldp_discovery_socket/ldp_disc_socket/ (shorter)
* s/ldp_ediscovery_socket/ldp_edisc_socket/ (shorter)
* s/ldp_sendboth/main_imsg_compose_both/ (consistency)
* s/cons/total/ (makes more sense)
* s/kaddr/ka/ (consistency with remaining code)
* Always use 'ln' for lde_nbrs (consistency)
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.21 2016/05/23 16:04:04 renato Exp $ */
d50 1
a50 1
	log_debug("%s: neighbor ID %s", __func__, inet_ntoa(nbr->id));
d72 1
a72 1
	log_debug("%s: neighbor ID %s", __func__, inet_ntoa(nbr->id));
@


1.21
log
@Improve the parser of TCP/session packets.

Add more safeguards against malformed packets and fix existing ones. Also,
rename a few variables and constants to match their real meaning. For
example, rename gen_msg_tlv() to gen_msg_hdr() because this function
generates an LDP header, not a TLV.

Finally, clean-up all the send_* functions so they all follow the same
pattern.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.20 2016/05/23 16:01:59 renato Exp $ */
d169 1
a169 1
		cons += TLV_HDR_LEN + tlv_len;
d172 1
a172 1
	return (cons);
@


1.20
log
@Respect the received Max PDU Length field.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.19 2016/05/23 15:59:55 renato Exp $ */
d52 2
a53 1
	if ((buf = ibuf_open(LDP_MAX_LEN)) == NULL)
a55 2
	size = LDP_HDR_SIZE + sizeof(struct ldp_msg) + SESS_PRMS_SIZE;

a56 1

d58 2
a59 5

	gen_msg_tlv(buf, MSG_TYPE_INIT, size);

	size -= sizeof(struct ldp_msg);

d85 1
a85 2
	if (ntohs(sess.length) != SESS_PRMS_SIZE - TLV_HDR_LEN ||
	    ntohs(sess.length) > len - TLV_HDR_LEN) {
d119 1
a119 1
	return (ntohs(init.length));
@


1.19
log
@Fix issue with the exponential backoff timer.

Do not start the exponential backoff timer when playing the passive role
of the session establishment process.

RFC 5036 - Section 2.5.3 says:
"The specific session establishment action that must be
delayed is the attempt to open the session transport connection by
the LSR playing the active role".
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.18 2016/05/23 15:43:11 renato Exp $ */
d75 1
d112 10
@


1.18
log
@Add knob to configure the transport address.

This will be especially important when we add support for IPv6, because
we'll not be able to use the router-id as the transport-address in
this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.17 2016/05/23 15:41:04 renato Exp $ */
d112 1
a112 2
	if (!nbr_pending_idtimer(nbr))
		nbr_fsm(nbr, NBR_EVT_INIT_RCVD);
@


1.17
log
@Allow setting the session holdtime per neighbor.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.16 2016/05/23 15:14:07 renato Exp $ */
d109 1
a109 1
	nbr->keepalive = min(nbr_get_keepalive(nbr->addr),
d130 1
a130 1
	parms.keepalive_time = htons(nbr_get_keepalive(nbr->addr));
@


1.16
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.15 2014/10/25 03:23:49 lteo Exp $ */
d109 2
a110 1
	nbr->keepalive = min(leconf->keepalive, ntohs(sess.keepalive_time));
d130 1
a130 1
	parms.keepalive_time = htons(leconf->keepalive);
@


1.15
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.14 2013/10/15 20:21:25 renato Exp $ */
d50 1
a50 1
	log_debug("send_init: neighbor ID %s", inet_ntoa(nbr->id));
d53 1
a53 1
		fatal("send_init");
d76 1
a76 1
	log_debug("recv_init: neighbor ID %s", inet_ntoa(nbr->id));
@


1.14
log
@Fix whitespace and other style issues.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.13 2013/10/15 19:59:52 renato Exp $ */
a23 1
#include <netinet/in_systm.h>
@


1.13
log
@Improve parsing of LDP messages.
Add more sanity checks and send proper notification messages on error
conditions.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.12 2013/06/04 02:34:48 claudio Exp $ */
d110 1
a110 4
	if (leconf->keepalive < ntohs(sess.keepalive_time))
		nbr->keepalive = leconf->keepalive;
	else
		nbr->keepalive = ntohs(sess.keepalive_time);
@


1.12
log
@Always accept TCP connection requests and identify to which neighbor
it belongs only _after_ receiving an Initialization message containing
the information we need. Before an Initialization message is received,
the TCP connection shouldn't be associated with any neighbor/adjacency.
Therefor refactor that part into a own module.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.11 2013/06/04 01:32:16 claudio Exp $ */
d93 5
@


1.11
log
@Properly implement the exponential backoff timer on session initialization

According with the section 2.5.3 of RFC 5036, an LSR must throttle its
session setup retry attempts with an exponential backoff in situations
where Initialization messages are being NAK'd (because of disagreements
on session parameters). It doesn't mention using this procedure for TCP
connection failures. With that said, start the inactive delay timer only
after receiving an appropriate notification message.

When playing the active role of the initialization process, throttle the
session setup retry attempts by not connecting to the remote peer. When
playing the passive role, throttle the session setup retry attempts by
delaying the processing of the received Initialization message.

Diff by Renato Westphal, adjusted by myself
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.10 2013/06/01 19:28:55 claudio Exp $ */
d68 1
a68 1
	evbuf_enqueue(&nbr->wbuf, buf);
@


1.10
log
@The keepalive timeout should be configured on a global basis and not per
interface.
Remove the iface pointer from the 'nbr' structure because it's not
needed anymore.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.9 2013/06/01 18:47:07 claudio Exp $ */
d110 2
a111 1
	nbr_fsm(nbr, NBR_EVT_INIT_RCVD);
@


1.9
log
@Drop support for per-interface labelspaces.
Support for per-interface labelspaces is only necessary for legacy ATM/FR
interfaces running in cell-mode. We shouldn't worry about this.
For platform-wide label spaces the label space id is always 0.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.8 2013/06/01 18:35:02 claudio Exp $ */
d40 2
d105 2
a106 2
	if (nbr->iface->keepalive < ntohs(sess.keepalive_time))
		nbr->keepalive = nbr->iface->keepalive;
d127 1
a127 1
	parms.keepalive_time = htons(nbr->iface->keepalive);
@


1.8
log
@Drop support for passive interfaces.
Support for passive interfaces was inherited from ospfd but it doesn't
make any sense at all for ldpd.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.7 2011/01/10 12:02:48 claudio Exp $ */
d56 1
a56 1
	gen_ldp_hdr(buf, nbr->iface, size);
a129 1
	/* XXX: nbr lspace */
@


1.7
log
@Implement optional parameter handling for initialization messages.
This will now correctly ignore TLV with U flag set -- like the FT
extension used by JunOS. The function is built after
tlv_decode_opt_hello_prms().
Problem reported and fix tested by Marcel Wiget.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.6 2010/11/04 09:52:16 claudio Exp $ */
a47 3

	if (nbr->iface->passive)
		return;
@


1.6
log
@Rewrite all packet parsers to be more careful about alignment. Until
now ldpd had no chance to run on a strict alignment architecture but
this makes ldpd happy on sparc64. Be careful to do all needed overflow
checks and try to make all parsing functions look similar.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.5 2010/05/26 13:56:07 nicm Exp $ */
d41 1
d92 1
a92 1
	    ntohs(sess.length) != len - TLV_HDR_LEN) {
d97 8
a104 1
	/* ATM and Frame Relay optional attributes not supported */
d137 31
@


1.5
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.4 2010/02/25 17:40:46 claudio Exp $ */
d74 2
a75 2
	struct ldp_msg		*init;
	struct sess_prms_tlv	*sess_tlv;
d79 1
a79 6
	init = (struct ldp_msg *)buf;

	if ((len - TLV_HDR_LEN) < ntohs(init->length)) {
		session_shutdown(nbr, S_BAD_MSG_LEN, init->msgid, init->type);
		return (-1);
	}
d84 5
a88 1
	sess_tlv = (struct sess_prms_tlv *)buf;
d90 3
a92 3
	if (len < SESS_PRMS_SIZE ||
	    ntohs(sess_tlv->length) != (SESS_PRMS_SIZE - TLV_HDR_LEN)) {
		session_shutdown(nbr, S_BAD_TLV_LEN, init->msgid, init->type);
d96 3
a98 1
	if (nbr->iface->keepalive < ntohs(sess_tlv->keepalive_time))
d101 1
a101 1
		nbr->keepalive = ntohs(sess_tlv->keepalive_time);
d105 1
a105 1
	return (ntohs(init->length));
@


1.4
log
@Do not use bufferevent for something that's already covered in the imsg
buffer API. This fixes a few possible problems in session_read and does
some further cleanup in various places. Wrap msgbuf into evbuf to add
libevent functionality and use buf_read to handle the read side of a
session.  OK michele@@ and dlg@@ did not see anything evil
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.3 2010/02/20 21:28:39 michele Exp $ */
d40 1
a40 1
int	gen_init_prms_tlv(struct buf *, struct nbr *, u_int16_t);
d45 1
a45 1
	struct buf		*buf;
d53 1
a53 1
	if ((buf = buf_open(LDP_MAX_LEN)) == NULL)
d108 1
a108 1
gen_init_prms_tlv(struct buf *buf, struct nbr *nbr, u_int16_t size)
d127 1
a127 1
	return (buf_add(buf, &parms, SESS_PRMS_SIZE));
@


1.3
log
@Make send_* functions return void (and not int) as they can just succeed
or fatal().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.2 2009/06/05 22:34:45 michele Exp $ */
d68 1
a68 2
	bufferevent_write(nbr->bev, buf->buf, buf->wpos);
	buf_free(buf);
@


1.2
log
@Correctly send notification messages when errors occur.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d42 1
a42 1
int
d49 1
a49 1
		return (0);
a69 2

	return (0);
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a77 1
	u_int32_t		 messageid;
d85 1
a85 1
		/* XXX: send notification */
a88 2
	messageid = init->msgid;

d96 1
a96 1
		/* XXX: send notification */
@

