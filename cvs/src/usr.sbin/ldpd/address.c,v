head	1.35;
access;
symbols
	OPENBSD_6_2:1.35.0.6
	OPENBSD_6_2_BASE:1.35
	OPENBSD_6_1:1.35.0.4
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.29.0.2
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.6.0.10
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.8
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.35
date	2017.03.04.00.21.48;	author renato;	state Exp;
branches;
next	1.34;
commitid	luKtDak9oSLriyOU;

1.34
date	2017.03.04.00.18.43;	author renato;	state Exp;
branches;
next	1.33;
commitid	Upc3v5cgHwJM76Pc;

1.33
date	2017.03.03.23.53.50;	author renato;	state Exp;
branches;
next	1.32;
commitid	VAh39R8zbnV1488i;

1.32
date	2017.03.03.23.50.45;	author renato;	state Exp;
branches;
next	1.31;
commitid	2u5VjeFQJD7hTJEX;

1.31
date	2017.03.03.23.44.35;	author renato;	state Exp;
branches;
next	1.30;
commitid	mV5MMkodXlL2okSe;

1.30
date	2016.09.03.16.07.08;	author renato;	state Exp;
branches;
next	1.29;
commitid	fYTaUp1tzXub9AKi;

1.29
date	2016.07.16.19.24.30;	author renato;	state Exp;
branches;
next	1.28;
commitid	LXVlFOsFAoTwgzCX;

1.28
date	2016.07.01.23.36.38;	author renato;	state Exp;
branches;
next	1.27;
commitid	h9Qy21EPYXbAFnoh;

1.27
date	2016.07.01.23.29.55;	author renato;	state Exp;
branches;
next	1.26;
commitid	OkOx7tFZtmlIlivU;

1.26
date	2016.06.27.19.06.33;	author renato;	state Exp;
branches;
next	1.25;
commitid	OXyvybFBtSb4ppHx;

1.25
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.24;
commitid	AQBoOveMRKjtVfFv;

1.24
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.23;
commitid	t07H0Mk6WGdVWB0W;

1.23
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.22;
commitid	D7VvXbswyzx5Ahb2;

1.22
date	2016.05.23.18.55.21;	author renato;	state Exp;
branches;
next	1.21;
commitid	85kONxXVWUqI2Jhb;

1.21
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.20;
commitid	VpAym8dVR6eY4drQ;

1.20
date	2016.05.23.16.04.04;	author renato;	state Exp;
branches;
next	1.19;
commitid	sfghEB6dR4Eaf77g;

1.19
date	2016.05.23.15.49.31;	author renato;	state Exp;
branches;
next	1.18;
commitid	RpMaNILGRIfJM8EJ;

1.18
date	2016.05.23.15.14.07;	author renato;	state Exp;
branches;
next	1.17;
commitid	l3e6PhvoAh8C7elc;

1.17
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.16;
commitid	puLLDX1XPNc3GxB9;

1.16
date	2015.07.21.04.39.28;	author renato;	state Exp;
branches;
next	1.15;
commitid	KR83ZYzpLqbp9L95;

1.15
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.14;
commitid	2uw1UTO4k6erpWzK;

1.14
date	2013.10.15.20.27.40;	author renato;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.04.02.34.48;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.04.00.41.18;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.03.16.53.49;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.01.19.42.07;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.01.19.01.32;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.01.18.47.07;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.01.18.35.02;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.11.04.09.52.16;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.25.17.40.46;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.20.21.28.39;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.22.34.45;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Send VPLS MAC withdrawals.

RFC 4762 says that MAC address withdrawal messages can be used to
improve convergence time in VPLS networks. This patch makes ldpd send
MAC withdrawals whenever a non-pseudowire interface pertaining to a
VPLS goes down. The processing of received MAC withdrawals will be
implemented later.
@
text
@/*	$OpenBSD: address.c,v 1.34 2017/03/04 00:18:43 renato Exp $ */

/*
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>

#include "ldpd.h"
#include "ldpe.h"
#include "lde.h"
#include "log.h"

static void	 send_address(struct nbr *, int, struct if_addr_head *,
		    unsigned int, int);
static int	 gen_address_list_tlv(struct ibuf *, int, struct if_addr_head *,
		    unsigned int);
static int	 gen_mac_list_tlv(struct ibuf *, uint8_t *);
static void	 address_list_add(struct if_addr_head *, struct if_addr *);
static void	 address_list_clr(struct if_addr_head *);
static void	 log_msg_address(int, uint16_t, struct nbr *, int,
		    union ldpd_addr *);
static void	 log_msg_mac_withdrawal(int, struct nbr *, uint8_t *);

static void
send_address(struct nbr *nbr, int af, struct if_addr_head *addr_list,
    unsigned int addr_count, int withdraw)
{
	struct ibuf	*buf;
	uint16_t	 msg_type;
	uint8_t		 addr_size;
	struct if_addr	*if_addr;
	uint16_t	 size;
	unsigned int	 tlv_addr_count = 0;
	int		 err = 0;

	/* nothing to send */
	if (LIST_EMPTY(addr_list))
		return;

	if (!withdraw)
		msg_type = MSG_TYPE_ADDR;
	else
		msg_type = MSG_TYPE_ADDRWITHDRAW;

	switch (af) {
	case AF_INET:
		addr_size = sizeof(struct in_addr);
		break;
	case AF_INET6:
		addr_size = sizeof(struct in6_addr);
		break;
	default:
		fatalx("send_address: unknown af");
	}

	while ((if_addr = LIST_FIRST(addr_list)) != NULL) {
		/*
		 * Send as many addresses as possible - respect the session's
		 * negotiated maximum pdu length.
		 */
		size = LDP_HDR_SIZE + LDP_MSG_SIZE + ADDR_LIST_SIZE;
		if (size + addr_count * addr_size <= nbr->max_pdu_len)
			tlv_addr_count = addr_count;
		else
			tlv_addr_count = (nbr->max_pdu_len - size) / addr_size;
		size += tlv_addr_count * addr_size;
		addr_count -= tlv_addr_count;

		if ((buf = ibuf_open(size)) == NULL)
			fatal(__func__);

		err |= gen_ldp_hdr(buf, size);
		size -= LDP_HDR_SIZE;
		err |= gen_msg_hdr(buf, msg_type, size);
		size -= LDP_MSG_SIZE;
		err |= gen_address_list_tlv(buf, af, addr_list, tlv_addr_count);
		if (err) {
			address_list_clr(addr_list);
			ibuf_free(buf);
			return;
		}

		while ((if_addr = LIST_FIRST(addr_list)) != NULL) {
			log_msg_address(1, msg_type, nbr, af, &if_addr->addr);

			LIST_REMOVE(if_addr, entry);
			free(if_addr);
			if (--tlv_addr_count == 0)
				break;
		}

		evbuf_enqueue(&nbr->tcp->wbuf, buf);
	}

	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
}

void
send_address_single(struct nbr *nbr, struct if_addr *if_addr, int withdraw)
{
	struct if_addr_head	 addr_list;

	LIST_INIT(&addr_list);
	address_list_add(&addr_list, if_addr);
	send_address(nbr, if_addr->af, &addr_list, 1, withdraw);
}

void
send_address_all(struct nbr *nbr, int af)
{
	struct if_addr_head	 addr_list;
	struct if_addr		*if_addr;
	unsigned int		 addr_count = 0;

	LIST_INIT(&addr_list);
	LIST_FOREACH(if_addr, &global.addr_list, entry) {
		if (if_addr->af != af)
			continue;

		address_list_add(&addr_list, if_addr);
		addr_count++;
	}

	send_address(nbr, af, &addr_list, addr_count, 0);
}

void
send_mac_withdrawal(struct nbr *nbr, struct map *fec, uint8_t *mac)
{
	struct ibuf	*buf;
	uint16_t	 size;
	int		 err;

	size = LDP_HDR_SIZE + LDP_MSG_SIZE + ADDR_LIST_SIZE + len_fec_tlv(fec) +
	    TLV_HDR_SIZE;
	if (mac)
		size += ETHER_ADDR_LEN;

	if ((buf = ibuf_open(size)) == NULL)
		fatal(__func__);

	err = gen_ldp_hdr(buf, size);
	size -= LDP_HDR_SIZE;
	err |= gen_msg_hdr(buf, MSG_TYPE_ADDRWITHDRAW, size);
	size -= LDP_MSG_SIZE;
	err |= gen_address_list_tlv(buf, AF_INET, NULL, 0);
	err |= gen_fec_tlv(buf, fec);
	err |= gen_mac_list_tlv(buf, mac);
	if (err) {
		ibuf_free(buf);
		return;
	}

	log_msg_mac_withdrawal(1, nbr, mac);

	evbuf_enqueue(&nbr->tcp->wbuf, buf);

	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
}

int
recv_address(struct nbr *nbr, char *buf, uint16_t len)
{
	struct ldp_msg		msg;
	uint16_t		msg_type;
	enum imsg_type		type;
	struct address_list_tlv	alt;
	uint16_t		alt_len;
	uint16_t		alt_family;
	struct lde_addr		lde_addr;

	memcpy(&msg, buf, sizeof(msg));
	msg_type = ntohs(msg.type);
	switch (msg_type) {
	case MSG_TYPE_ADDR:
		type = IMSG_ADDRESS_ADD;
		break;
	case MSG_TYPE_ADDRWITHDRAW:
		type = IMSG_ADDRESS_DEL;
		break;
	default:
		fatalx("recv_address: unexpected msg type");
	}
	buf += LDP_MSG_SIZE;
	len -= LDP_MSG_SIZE;

	/* Address List TLV */
	if (len < ADDR_LIST_SIZE) {
		session_shutdown(nbr, S_BAD_MSG_LEN, msg.id, msg.type);
		return (-1);
	}
	memcpy(&alt, buf, sizeof(alt));
	alt_len = ntohs(alt.length);
	alt_family = ntohs(alt.family);
	if (alt_len > len - TLV_HDR_SIZE) {
		session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
		return (-1);
	}
	if (ntohs(alt.type) != TLV_TYPE_ADDRLIST) {
		send_notification(nbr->tcp, S_MISS_MSG, msg.id, msg.type);
		return (-1);
	}
	switch (alt_family) {
	case AF_IPV4:
		if (!nbr->v4_enabled)
			/* just ignore the message */
			return (0);
		break;
	case AF_IPV6:
		if (!nbr->v6_enabled)
			/* just ignore the message */
			return (0);
		break;
	default:
		send_notification(nbr->tcp, S_UNSUP_ADDR, msg.id, msg.type);
		return (-1);
	}
	alt_len -= sizeof(alt.family);
	buf += sizeof(alt);
	len -= sizeof(alt);

	/* Process all received addresses */
	while (alt_len > 0) {
		switch (alt_family) {
		case AF_IPV4:
			if (alt_len < sizeof(struct in_addr)) {
				session_shutdown(nbr, S_BAD_TLV_LEN, msg.id,
				    msg.type);
				return (-1);
			}

			memset(&lde_addr, 0, sizeof(lde_addr));
			lde_addr.af = AF_INET;
			memcpy(&lde_addr.addr, buf, sizeof(struct in_addr));

			buf += sizeof(struct in_addr);
			len -= sizeof(struct in_addr);
			alt_len -= sizeof(struct in_addr);
			break;
		case AF_IPV6:
			if (alt_len < sizeof(struct in6_addr)) {
				session_shutdown(nbr, S_BAD_TLV_LEN, msg.id,
				    msg.type);
				return (-1);
			}

			memset(&lde_addr, 0, sizeof(lde_addr));
			lde_addr.af = AF_INET6;
			memcpy(&lde_addr.addr, buf, sizeof(struct in6_addr));

			buf += sizeof(struct in6_addr);
			len -= sizeof(struct in6_addr);
			alt_len -= sizeof(struct in6_addr);
			break;
		default:
			fatalx("recv_address: unknown af");
		}

		log_msg_address(0, msg_type, nbr, lde_addr.af, &lde_addr.addr);

		ldpe_imsg_compose_lde(type, nbr->peerid, 0, &lde_addr,
		    sizeof(lde_addr));
	}

	/* Optional Parameters */
	while (len > 0) {
		struct tlv 	tlv;
		uint16_t	tlv_type;
		uint16_t	tlv_len;

		if (len < sizeof(tlv)) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
			return (-1);
		}

		memcpy(&tlv, buf, TLV_HDR_SIZE);
		tlv_type = ntohs(tlv.type);
		tlv_len = ntohs(tlv.length);
		if (tlv_len + TLV_HDR_SIZE > len) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
			return (-1);
		}
		buf += TLV_HDR_SIZE;
		len -= TLV_HDR_SIZE;

		switch (tlv_type) {
		default:
			if (!(ntohs(tlv.type) & UNKNOWN_FLAG))
				send_notification_rtlvs(nbr, S_UNKNOWN_TLV,
				    msg.id, msg.type, tlv_type, tlv_len, buf);
			/* ignore unknown tlv */
			break;
		}
		buf += tlv_len;
		len -= tlv_len;
	}

	return (0);
}

static int
gen_address_list_tlv(struct ibuf *buf, int af, struct if_addr_head *addr_list,
    unsigned int tlv_addr_count)
{
	struct address_list_tlv	 alt;
	uint16_t		 addr_size;
	struct if_addr		*if_addr;
	int			 err = 0;

	memset(&alt, 0, sizeof(alt));
	alt.type = htons(TLV_TYPE_ADDRLIST);

	switch (af) {
	case AF_INET:
		alt.family = htons(AF_IPV4);
		addr_size = sizeof(struct in_addr);
		break;
	case AF_INET6:
		alt.family = htons(AF_IPV6);
		addr_size = sizeof(struct in6_addr);
		break;
	default:
		fatalx("gen_address_list_tlv: unknown af");
	}
	alt.length = htons(sizeof(alt.family) + addr_size * tlv_addr_count);

	err |= ibuf_add(buf, &alt, sizeof(alt));
	if (addr_list == NULL)
		return (err);

	LIST_FOREACH(if_addr, addr_list, entry) {
		err |= ibuf_add(buf, &if_addr->addr, addr_size);
		if (--tlv_addr_count == 0)
			break;
	}

	return (err);
}

static int
gen_mac_list_tlv(struct ibuf *buf, uint8_t *mac)
{
	struct tlv	 tlv;
	int		 err;

	memset(&tlv, 0, sizeof(tlv));
	tlv.type = htons(TLV_TYPE_MAC_LIST);
	if (mac)
		tlv.length = htons(ETHER_ADDR_LEN);
	err = ibuf_add(buf, &tlv, sizeof(tlv));
	if (mac)
		err |= ibuf_add(buf, mac, ETHER_ADDR_LEN);

	return (err);
}

static void
address_list_add(struct if_addr_head *addr_list, struct if_addr *if_addr)
{
	struct if_addr		*new;

	new = malloc(sizeof(*new));
	if (new == NULL)
		fatal(__func__);
	*new = *if_addr;

	LIST_INSERT_HEAD(addr_list, new, entry);
}

static void
address_list_clr(struct if_addr_head *addr_list)
{
	struct if_addr		*if_addr;

	while ((if_addr = LIST_FIRST(addr_list)) != NULL) {
		LIST_REMOVE(if_addr, entry);
		free(if_addr);
	}
}

static void
log_msg_address(int out, uint16_t msg_type, struct nbr *nbr, int af,
    union ldpd_addr *addr)
{
	log_debug("msg-%s: %s: lsr-id %s, address %s", (out) ? "out" : "in",
	    msg_name(msg_type), inet_ntoa(nbr->id), log_addr(af, addr));
}

static void
log_msg_mac_withdrawal(int out, struct nbr *nbr, uint8_t *mac)
{
	log_debug("msg-%s: mac withdrawal: lsr-id %s, mac %s",
	    (out) ? "out" : "in", inet_ntoa(nbr->id),
	    (mac) ? ether_ntoa((struct ether_addr *)mac) : "wildcard");
}
@


1.34
log
@Fix parsing of optional tlvs in address messages.

We were aborting the session upon receipt of MAC Address Withdrawal
messages. Now make the parser aware that optional TLVs are possible in
address messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.33 2017/03/03 23:53:50 renato Exp $ */
d31 3
a33 2
static int	 gen_address_list_tlv(struct ibuf *, uint16_t, int,
		    struct if_addr_head *, unsigned int);
d38 1
d92 1
a92 2
		err |= gen_address_list_tlv(buf, size, af, addr_list,
		    tlv_addr_count);
d143 34
d318 2
a319 2
gen_address_list_tlv(struct ibuf *buf, uint16_t size, int af,
    struct if_addr_head *addr_list, unsigned int tlv_addr_count)
a327 1
	alt.length = htons(size - TLV_HDR_SIZE);
d341 1
d344 3
d356 17
d403 8
@


1.33
log
@Send correct status code on error condition.

The Unknown TLV status code is reserved for cases where we don't know
how to process a given TLV and its Unknown TLV bit is not set.

In the case of Address Messages, the Address List TLV is mandatory and
should appear before any optional TLV in the message. If that doesn't
happen the correct status notification to send is "Missing Message
Parameters" (non-fatal error).

Also, add a missing htons when creating an Address List TLV. Since the
value of TLV_TYPE_ADDRLIST is 0x0101 this missing htons wasn't noticed
earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.32 2017/03/03 23:50:45 renato Exp $ */
d147 1
d149 2
a150 1
	enum imsg_type		type;
d154 11
a172 1

d174 3
a176 1
	if (ntohs(alt.length) != len - TLV_HDR_SIZE) {
d184 1
a184 1
	switch (ntohs(alt.family)) {
d199 1
d203 3
a205 8
	msg_type = ntohs(msg.type);
	if (msg_type == MSG_TYPE_ADDR)
		type = IMSG_ADDRESS_ADD;
	else
		type = IMSG_ADDRESS_DEL;

	while (len > 0) {
		switch (ntohs(alt.family)) {
d207 1
a207 1
			if (len < sizeof(struct in_addr)) {
d219 1
d222 1
a222 1
			if (len < sizeof(struct in6_addr)) {
d234 1
d244 33
@


1.32
log
@Create helper functions to log sent/received messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.31 2017/03/03 23:44:35 renato Exp $ */
d167 1
a167 1
		session_shutdown(nbr, S_UNKNOWN_TLV, msg.id, msg.type);
d247 1
a247 1
	alt.type = TLV_TYPE_ADDRLIST;
@


1.31
log
@Kill send_notification_nbr().

Be more clever and trigger the PDU SENT event inside send_notification()
when tcp->nbr is set. This way we can eliminate send_notification_nbr()
and always use send_notification() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.30 2016/09/03 16:07:08 renato Exp $ */
d35 2
d99 1
a99 3
			log_debug("msg-out: %s: lsr-id %s, address %s",
			    msg_name(msg_type), inet_ntoa(nbr->id),
			    log_addr(af, &if_addr->addr));
d228 1
a228 3
		log_debug("msg-in: %s: lsr-id %s, address %s",
		    msg_name(msg_type), inet_ntoa(nbr->id),
		    log_addr(lde_addr.af, &lde_addr.addr));
d295 8
@


1.30
log
@Rework the sending of address messages.

* Respect the session's negotiated maximum pdu length and split the
  sending of our local addresses into multiple messages if necessary;

* Log sent/received addresses;

* Add new wrappers to send only one address (send_address_single)
  and to send all addresses of the given address-family
  (send_address_all). These wrappers create a temporary list of addresses
  to be sent, and send_address() then acts on this last.
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.29 2016/07/16 19:24:30 renato Exp $ */
d182 1
a182 1
		send_notification_nbr(nbr, S_UNSUP_ADDR, msg.id, msg.type);
@


1.29
log
@Remove potential overflow when validating message's length.

Also, use uint16_t for msg_type on gen_msg_hdr().
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.28 2016/07/01 23:36:38 renato Exp $ */
d21 1
d29 10
a38 5
static int	gen_address_list_tlv(struct ibuf *, uint16_t, int,
		    struct if_addr *);

void
send_address(struct nbr *nbr, int af, struct if_addr *if_addr, int withdraw)
d42 2
d45 1
a45 1
	int		 iface_count = 0;
d48 4
a56 8
	if (if_addr == NULL) {
		LIST_FOREACH(if_addr, &global.addr_list, entry)
			if (if_addr->af == af)
				iface_count++;
	} else
		iface_count = 1;

	size = LDP_HDR_SIZE + LDP_MSG_SIZE + sizeof(struct address_list_tlv);
d59 1
a59 1
		size += iface_count * sizeof(struct in_addr);
d62 1
a62 1
		size += iface_count * sizeof(struct in6_addr);
d68 38
a105 2
	if ((buf = ibuf_open(size)) == NULL)
		fatal(__func__);
d107 1
a107 8
	err |= gen_ldp_hdr(buf, size);
	size -= LDP_HDR_SIZE;
	err |= gen_msg_hdr(buf, msg_type, size);
	size -= LDP_MSG_SIZE;
	err |= gen_address_list_tlv(buf, size, af, if_addr);
	if (err) {
		ibuf_free(buf);
		return;
d110 24
a133 1
	evbuf_enqueue(&nbr->tcp->wbuf, buf);
d135 5
a139 1
	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
d146 1
d156 1
a156 1
	if (len < sizeof(alt)) {
d188 2
a189 1
	if (ntohs(msg.type) == MSG_TYPE_ADDR)
d228 3
a230 3
		log_debug("%s: lsr-id %s address %s%s", __func__,
		    inet_ntoa(nbr->id), log_addr(lde_addr.af, &lde_addr.addr),
		    ntohs(msg.type) == MSG_TYPE_ADDR ? "" : " (withdraw)");
d241 1
a241 1
    struct if_addr *if_addr)
d245 1
d251 1
d266 1
a266 7
	if (if_addr == NULL) {
		LIST_FOREACH(if_addr, &global.addr_list, entry) {
			if (if_addr->af != af)
				continue;
			err |= ibuf_add(buf, &if_addr->addr, addr_size);
		}
	} else
d268 3
d273 24
@


1.28
log
@More renaming and whitespace cleanup.

No binary change after "strip -s".
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.27 2016/07/01 23:29:55 renato Exp $ */
d35 1
a35 1
	uint32_t	 msg_type;
@


1.27
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.26 2016/06/27 19:06:33 renato Exp $ */
d85 1
a85 1
	struct ldp_msg		addr;
d90 1
a90 1
	memcpy(&addr, buf, sizeof(addr));
d96 1
a96 1
		session_shutdown(nbr, S_BAD_MSG_LEN, addr.msgid, addr.type);
d101 2
a102 2
	if (ntohs(alt.length) != len - TLV_HDR_LEN) {
		session_shutdown(nbr, S_BAD_TLV_LEN, addr.msgid, addr.type);
d106 1
a106 1
		session_shutdown(nbr, S_UNKNOWN_TLV, addr.msgid, addr.type);
d121 1
a121 1
		send_notification_nbr(nbr, S_UNSUP_ADDR, addr.msgid, addr.type);
d127 1
a127 1
	if (ntohs(addr.type) == MSG_TYPE_ADDR)
d136 2
a137 2
				session_shutdown(nbr, S_BAD_TLV_LEN, addr.msgid,
				    addr.type);
d150 2
a151 2
				session_shutdown(nbr, S_BAD_TLV_LEN, addr.msgid,
				    addr.type);
d168 1
a168 1
		    ntohs(addr.type) == MSG_TYPE_ADDR ? "" : " (withdraw)");
d187 1
a187 1
	alt.length = htons(size - TLV_HDR_LEN);
@


1.26
log
@Handle ibuf_add() errors.

tweaks from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.25 2016/05/23 19:11:42 renato Exp $ */
d166 1
a166 1
		log_debug("%s: neighbor ID %s address %s%s", __func__,
@


1.25
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.24 2016/05/23 19:09:25 renato Exp $ */
d28 1
a28 1
static void	gen_address_list_tlv(struct ibuf *, uint16_t, int,
d38 1
d67 1
a67 1
	gen_ldp_hdr(buf, size);
d69 1
a69 1
	gen_msg_hdr(buf, msg_type, size);
d71 5
a75 1
	gen_address_list_tlv(buf, size, af, if_addr);
d177 1
a177 1
static void
d183 1
d201 1
a201 2
	ibuf_add(buf, &alt, sizeof(alt));

d204 3
a206 2
			if (if_addr->af == af)
				ibuf_add(buf, &if_addr->addr, addr_size);
d209 3
a211 1
		ibuf_add(buf, &if_addr->addr, addr_size);
@


1.24
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.23 2016/05/23 18:58:48 renato Exp $ */
a19 5
#include <sys/socket.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <netinet/ip.h>
a20 6
#include <net/if_dl.h>
#include <unistd.h>

#include <errno.h>
#include <event.h>
#include <stdlib.h>
@


1.23
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.22 2016/05/23 18:55:21 renato Exp $ */
d39 2
a40 3
extern struct ldpd_conf        *leconf;

void	gen_address_list_tlv(struct ibuf *, uint16_t, int, struct if_addr *);
d183 1
a183 1
void
@


1.22
log
@Assorted fixes and small cleanup.

Nothing really interesting here.
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.21 2016/05/23 17:43:42 renato Exp $ */
d35 2
a36 1
#include "ldp.h"
a37 1
#include "ldpe.h"
d41 1
a41 1
void	gen_address_list_tlv(struct ibuf *, struct if_addr *, uint16_t);
d44 1
a44 1
send_address(struct nbr *nbr, struct if_addr *if_addr, int withdraw)
d58 2
a59 1
			iface_count++;
d63 11
a73 2
	size = LDP_HDR_SIZE + LDP_MSG_SIZE + sizeof(struct address_list_tlv) +
	    iface_count * sizeof(struct in_addr);
d82 1
a82 1
	gen_address_list_tlv(buf, if_addr, size);
d95 1
a97 5
	if (ntohs(addr.type) == MSG_TYPE_ADDR)
		type = IMSG_ADDRESS_ADD;
	else
		type = IMSG_ADDRESS_DEL;

d116 12
a127 3

	/* For now we only support IPv4 */
	if (alt.family != htons(AF_IPV4)) {
d134 4
a137 3
	while (len >= sizeof(struct in_addr)) {
		ldpe_imsg_compose_lde(type, nbr->peerid, 0,
		    buf, sizeof(struct in_addr));
d139 37
a175 3
		buf += sizeof(struct in_addr);
		len -= sizeof(struct in_addr);
	}
d177 2
a178 3
	if (len != 0) {
		session_shutdown(nbr, S_BAD_TLV_LEN, addr.msgid, addr.type);
		return (-1);
d185 2
a186 1
gen_address_list_tlv(struct ibuf *buf, struct if_addr *if_addr, uint16_t size)
d189 1
a189 1

d194 12
a205 2
	/* XXX: just ipv4 for now */
	alt.family = htons(AF_IPV4);
d210 4
a213 2
		LIST_FOREACH(if_addr, &global.addr_list, entry)
			ibuf_add(buf, &if_addr->addr, sizeof(if_addr->addr));
d215 1
a215 1
		ibuf_add(buf, &if_addr->addr, sizeof(if_addr->addr));
@


1.21
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a86 2
	log_debug("%s: lsr-id %s%s", __func__, inet_ntoa(nbr->id),
	    ntohs(addr.type) == MSG_TYPE_ADDR ? "" : " address withdraw");
d95 1
a101 1

a105 1

a115 1

@


1.20
log
@Improve the parser of TCP/session packets.

Add more safeguards against malformed packets and fix existing ones. Also,
rename a few variables and constants to match their real meaning. For
example, rename gen_msg_tlv() to gen_msg_hdr() because this function
generates an LDP header, not a TLV.

Finally, clean-up all the send_* functions so they all follow the same
pattern.
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.19 2016/05/23 15:49:31 renato Exp $ */
d41 1
a41 1
void	gen_address_list_tlv(struct ibuf *, struct if_addr *, u_int16_t);
d44 1
a44 1
send_address(struct nbr *nbr, struct if_addr *if_addr)
d47 3
a49 1
	u_int16_t	 size, iface_count = 0;
d51 4
a54 4
	log_debug("%s: neighbor ID %s", __func__, inet_ntoa(nbr->id));

	if ((buf = ibuf_open(LDP_MAX_LEN)) == NULL)
		fatal(__func__);
d56 2
a57 2
	if (if_addr == NULL)
		LIST_FOREACH(if_addr, &leconf->addr_list, entry)
d59 1
a59 1
	else
d62 1
a62 2
	size = LDP_HDR_SIZE + sizeof(struct ldp_msg) +
	    sizeof(struct address_list_tlv) +
d65 3
a68 1

d70 2
a71 5

	gen_msg_tlv(buf, msg_type, size);

	size -= sizeof(struct ldp_msg);

d75 1
d80 1
a80 1
recv_address(struct nbr *nbr, char *buf, u_int16_t len)
d86 2
a87 2
	bcopy(buf, &addr, sizeof(addr));
	log_debug("recv_address: neighbor ID %s%s", inet_ntoa(nbr->id),
d102 1
a102 1
	bcopy(buf, &alt, sizeof(alt));
d140 1
a140 2
gen_address_list_tlv(struct ibuf *buf, struct if_addr *if_addr,
    u_int16_t size)
a143 2
	/* We want just the size of the value */
	size -= TLV_HDR_LEN;
d145 1
a145 1
	bzero(&alt, sizeof(alt));
d147 1
a147 1
	alt.length = htons(size);
d153 2
a154 2
	if (if_addr == NULL)
		LIST_FOREACH(if_addr, &leconf->addr_list, entry)
d156 1
a156 1
	else
a157 28
}

void
send_address_withdraw(struct nbr *nbr, struct if_addr *if_addr)
{
	struct ibuf	*buf;
	u_int16_t	 size;

	log_debug("%s: neighbor ID %s", __func__, inet_ntoa(nbr->id));

	if ((buf = ibuf_open(LDP_MAX_LEN)) == NULL)
		fatal(__func__);

	size = LDP_HDR_SIZE + sizeof(struct ldp_msg) +
	    sizeof(struct address_list_tlv) + sizeof(struct in_addr);

	gen_ldp_hdr(buf, size);

	size -= LDP_HDR_SIZE;

	gen_msg_tlv(buf, MSG_TYPE_ADDRWITHDRAW, size);

	size -= sizeof(struct ldp_msg);

	gen_address_list_tlv(buf, if_addr, size);

	evbuf_enqueue(&nbr->tcp->wbuf, buf);
	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
@


1.19
log
@We don't need a separate function for sending address withdraws.

Address and Address Withdraw messages have the exact same format, only
their type is different.
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.18 2016/05/23 15:14:07 renato Exp $ */
d93 2
a94 2
	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);
d135 1
a135 1
	return (ntohs(addr.length));
@


1.18
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.17 2015/07/21 04:52:29 renato Exp $ */
d68 1
a68 1
	gen_msg_tlv(buf, MSG_TYPE_ADDR, size);
@


1.17
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.16 2015/07/21 04:39:28 renato Exp $ */
d49 1
a49 1
	log_debug("send_address: neighbor ID %s", inet_ntoa(nbr->id));
d52 1
a52 1
		fatal("send_address");
d168 1
a168 1
	log_debug("send_address_withdraw: neighbor ID %s", inet_ntoa(nbr->id));
d171 1
a171 1
		fatal("send_address_withdraw");
@


1.16
log
@Improve handling of addresses on ldpe.

This is a preliminary work for the the next patch (sigup config
reload). We want to make sure that the ldpe process can handle duplicated
addresses.

The idea is to alloc two different if_addr structures for each address,
and link one in the global list of addresses (used to send address
messages) and link the other to the associated interface list of
addresses.

Doing that we will be able to call kif_redistribute() after reloading
the config file and activate the new LDP enabled interfaces.

NOTE: Interfaces are created at config parse time and the child
processes inherit them on fork() so there's no need to send a status
update at startup.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.15 2014/10/25 03:23:49 lteo Exp $ */
d114 1
a114 1
	if (alt.family != htons(ADDR_IPV4)) {
d151 1
a151 1
	alt.family = htons(ADDR_IPV4);
@


1.15
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.14 2013/10/15 20:27:40 renato Exp $ */
d55 1
a55 1
		LIST_FOREACH(if_addr, &leconf->addr_list, global_entry)
d156 1
a156 1
		LIST_FOREACH(if_addr, &leconf->addr_list, global_entry)
@


1.14
log
@Generate the NBR_EVT_PDU_RCVD event in a single point.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.13 2013/06/04 02:34:48 claudio Exp $ */
a23 1
#include <netinet/in_systm.h>
@


1.13
log
@Always accept TCP connection requests and identify to which neighbor
it belongs only _after_ receiving an Initialization message containing
the information we need. Before an Initialization message is received,
the TCP connection shouldn't be associated with any neighbor/adjacency.
Therefor refactor that part into a own module.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.12 2013/06/04 00:41:18 claudio Exp $ */
a134 2

	nbr_fsm(nbr, NBR_EVT_PDU_RCVD);
@


1.12
log
@fix some minor issues before proceeding with the remaining patches from
Renato Westphal. Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.11 2013/06/03 16:53:49 claudio Exp $ */
d75 1
a75 1
	evbuf_enqueue(&nbr->wbuf, buf);
d189 1
a189 1
	evbuf_enqueue(&nbr->wbuf, buf);
@


1.11
log
@Implement support for multiple addresses per interface.
This replaces the way addresses and interface are chained together.
In ospfd there was a 1 to 1 mapping (with iface clones) but LDP does
not have that limitation.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.10 2013/06/01 19:42:07 claudio Exp $ */
d166 1
a166 1
send_address_withdraw(struct nbr *nbr,  struct if_addr *if_addr)
@


1.10
log
@Restart the keepalive timer whenever a LDP PDU is sent. There is no need
to send a keepalive packet when a other PDU was sent out.
Also add a missing NBR_EVT_PDU_RCVD call to recv_address() which restarts
the session keepalive timeout. All other places already do that.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.9 2013/06/01 19:01:32 claudio Exp $ */
d42 1
a42 1
void	gen_address_list_tlv(struct ibuf *, struct iface *, u_int16_t);
d45 1
a45 1
send_address(struct nbr *nbr, struct iface *iface)
a47 1
	struct iface	*niface;
d55 2
a56 3
	/* XXX: multiple address on the same iface? */
	if (iface == NULL)
		LIST_FOREACH(niface, &leconf->iface_list, entry)
d73 1
a73 1
	gen_address_list_tlv(buf, iface, size);
d142 2
a143 1
gen_address_list_tlv(struct ibuf *buf, struct iface *iface, u_int16_t size)
a145 1
	struct iface		*niface;
d158 3
a160 3
	if (iface == NULL)
		LIST_FOREACH(niface, &leconf->iface_list, entry)
			ibuf_add(buf, &niface->addr, sizeof(niface->addr));
d162 1
a162 1
		ibuf_add(buf, &iface->addr, sizeof(iface->addr));
d166 1
a166 1
send_address_withdraw(struct nbr *nbr, struct iface *iface)
d176 2
a177 2
	/* XXX: multiple address on the same iface? */
	size = LDP_HDR_SIZE + sizeof(struct ldp_msg) + sizeof(struct in_addr);
d187 1
a187 1
	gen_address_list_tlv(buf, iface, size);
@


1.9
log
@Improve error handling on session_read
* Don't try to send a Shutdown message if the connection is already
  closed or a read error occured;
* As per RFC 5036, send a Shutdown message if an unexpected message is
  received during the initialization process;
* Check if the whole LSR ID of received messages is correct;
* On ldpe_dispatch_main(), ignore the messages from the lde process
  whose associated neighbor is not in the operational state.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.8 2013/06/01 18:47:07 claudio Exp $ */
d78 1
d138 2
d192 1
@


1.8
log
@Drop support for per-interface labelspaces.
Support for per-interface labelspaces is only necessary for legacy ATM/FR
interfaces running in cell-mode. We shouldn't worry about this.
For platform-wide label spaces the label space id is always 0.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.7 2013/06/01 18:35:02 claudio Exp $ */
a85 6

	if (nbr->state != NBR_STA_OPER) {
		log_debug("recv_address: neighbor ID %s not operational",
		    inet_ntoa(nbr->id));
		return (-1);
	}
@


1.7
log
@Drop support for passive interfaces.
Support for passive interfaces was inherited from ospfd but it doesn't
make any sense at all for ldpd.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.6 2010/11/04 09:52:16 claudio Exp $ */
d67 1
a67 1
	gen_ldp_hdr(buf, nbr->iface, size);
d184 1
a184 1
	gen_ldp_hdr(buf, nbr->iface, size);
@


1.6
log
@Rewrite all packet parsers to be more careful about alignment. Until
now ldpd had no chance to run on a strict alignment architecture but
this makes ldpd happy on sparc64. Be careful to do all needed overflow
checks and try to make all parsing functions look similar.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.5 2010/05/26 13:56:07 nicm Exp $ */
a50 3
	if (nbr->iface->passive)
		return;

a174 3

	if (nbr->iface->passive)
		return;
@


1.5
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.4 2010/02/25 17:40:46 claudio Exp $ */
d86 3
a88 4
	struct ldp_msg		*addr;
	struct address_list_tlv	*alt;
	struct in_addr		*address;
	u_int32_t		 addrs_len;
d90 5
a94 1
	log_debug("recv_address: neighbor ID %s", inet_ntoa(nbr->id));
d96 7
a102 2
	if (nbr->state != NBR_STA_OPER)
		return (-1);
d104 2
a105 1
	addr = (struct ldp_msg *)buf;
d107 2
a108 2
	if ((len - TLV_HDR_LEN) < ntohs(addr->length)) {
		session_shutdown(nbr, S_BAD_MSG_LEN, addr->msgid, addr->type);
d112 1
a112 2
	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);
d114 2
a115 5
	alt = (struct address_list_tlv *)buf;

	if (len < sizeof(*alt) ||
	    (len - TLV_HDR_LEN) < ntohs(alt->length)) {
		session_shutdown(nbr, S_BAD_TLV_LEN, addr->msgid, addr->type);
d119 2
a120 4
	addrs_len = (ntohs(alt->length) - sizeof(alt->family));

	if (alt->type != TLV_TYPE_ADDRLIST) {
		session_shutdown(nbr, S_UNKNOWN_TLV, addr->msgid, addr->type);
d125 2
a126 3
	if (alt->family != htons(ADDR_IPV4)) {
		send_notification_nbr(nbr, S_UNSUP_ADDR, addr->msgid,
		    addr->type);
d130 2
a131 3
	buf += sizeof(*alt);
	len -= sizeof(*alt);
	address = (struct in_addr *)buf;
d133 3
a135 3
	while (addrs_len >= sizeof(address)) {
		ldpe_imsg_compose_lde(IMSG_ADDRESS_ADD, nbr->peerid, 0,
		    address, sizeof(*address));
d137 2
a138 2
		address++;
		addrs_len -= sizeof(*address);
d141 6
a146 1
	return (ntohs(addr->length));
a200 53
}

int
recv_address_withdraw(struct nbr *nbr, char *buf, u_int16_t len)
{
	struct ldp_msg		*aw;
	struct address_list_tlv	*alt;
	struct in_addr		*address;

	log_debug("recv_address_withdraw: neighbor ID %s", inet_ntoa(nbr->id));

	aw = (struct ldp_msg *)buf;

	if ((len - TLV_HDR_LEN) < ntohs(aw->length)) {
		session_shutdown(nbr, S_BAD_MSG_LEN, aw->msgid, aw->type);
		return (-1);
	}

	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);

	alt = (struct address_list_tlv *)buf;

	if (len < sizeof(*alt) ||
	    (len - TLV_HDR_LEN) < ntohs(alt->length)) {
		session_shutdown(nbr, S_BAD_TLV_LEN, aw->msgid, aw->type);
		return (-1);
	}

	if (alt->type != TLV_TYPE_ADDRLIST) {
		session_shutdown(nbr, S_UNKNOWN_TLV, aw->msgid, aw->type);
		return (-1);
	}

	/* For now we just support IPv4 */
	if (alt->family != AF_INET) {
		send_notification_nbr(nbr, S_UNSUP_ADDR, aw->msgid, aw->type);
		return (-1);
	}

	buf += sizeof(*alt);
	len -= sizeof(*alt);
	address = (struct in_addr *)buf;

	while (len >= sizeof(address)) {
		ldpe_imsg_compose_lde(IMSG_ADDRESS_DEL, nbr->peerid, 0,
		    address, sizeof(*address));

		address++;
		len -= sizeof(*address);
	}

	return (ntohs(aw->length));
@


1.4
log
@Do not use bufferevent for something that's already covered in the imsg
buffer API. This fixes a few possible problems in session_read and does
some further cleanup in various places. Wrap msgbuf into evbuf to add
libevent functionality and use buf_read to handle the read side of a
session.  OK michele@@ and dlg@@ did not see anything evil
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.3 2010/02/20 21:28:39 michele Exp $ */
d42 1
a42 1
void	gen_address_list_tlv(struct buf *, struct iface *, u_int16_t);
d47 1
a47 1
	struct buf	*buf;
d56 1
a56 1
	if ((buf = buf_open(LDP_MAX_LEN)) == NULL)
d144 1
a144 1
gen_address_list_tlv(struct buf *buf, struct iface *iface, u_int16_t size)
d158 1
a158 1
	buf_add(buf, &alt, sizeof(alt));
d162 1
a162 1
			buf_add(buf, &niface->addr, sizeof(niface->addr));
d164 1
a164 1
		buf_add(buf, &iface->addr, sizeof(iface->addr));
d170 1
a170 1
	struct buf	*buf;
d178 1
a178 1
	if ((buf = buf_open(LDP_MAX_LEN)) == NULL)
@


1.3
log
@Make send_* functions return void (and not int) as they can just succeed
or fatal().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.2 2009/06/05 22:34:45 michele Exp $ */
d80 1
a80 2
	bufferevent_write(nbr->bev, buf->buf, buf->wpos);
	buf_free(buf);
d194 1
a194 2
	bufferevent_write(nbr->bev, buf->buf, buf->wpos);
	buf_free(buf);
@


1.2
log
@Correctly send notification messages when errors occur.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: address.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d44 1
a44 1
int
d52 1
a52 1
		return (0);
a81 2

	return (0);
d168 1
a168 1
int
d175 1
a175 1
		return (0);
a196 2

	return (0);
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d92 1
a92 1
	u_int32_t		 messageid, addrs_len;
d102 1
a102 1
		/* XXX: send notification */
a105 2
	messageid = addr->msgid;

d113 1
a113 1
		/* XXX: send notification */
d120 1
a120 1
		/* XXX: send notification */
d126 2
a127 1
		/* XXX: send notification */
a208 1
	u_int32_t		 messageid;
a213 1

d215 1
a215 1
		/* XXX: send notification */
a218 2
	messageid = aw->msgid;

d226 1
a226 1
		/* XXX: send notification */
d231 1
a231 1
		/* XXX: send notification */
d237 1
a237 1
		/* XXX: send notification */
@

