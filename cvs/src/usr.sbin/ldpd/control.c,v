head	1.29;
access;
symbols
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.29
date	2017.03.03.23.30.57;	author renato;	state Exp;
branches;
next	1.28;
commitid	mvwmKJi9MZW7VKOy;

1.28
date	2017.01.08.23.04.42;	author krw;	state Exp;
branches;
next	1.27;
commitid	T1ZdV0xhVeBLIhr0;

1.27
date	2016.05.23.19.20.55;	author renato;	state Exp;
branches;
next	1.26;
commitid	8nGP7z5tJSygyBn7;

1.26
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.25;
commitid	AQBoOveMRKjtVfFv;

1.25
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.24;
commitid	t07H0Mk6WGdVWB0W;

1.24
date	2016.05.23.18.55.21;	author renato;	state Exp;
branches;
next	1.23;
commitid	85kONxXVWUqI2Jhb;

1.23
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.22;
commitid	VpAym8dVR6eY4drQ;

1.22
date	2016.05.23.16.20.59;	author renato;	state Exp;
branches;
next	1.21;
commitid	nAtgYzDo97D7UnEI;

1.21
date	2016.05.23.15.14.07;	author renato;	state Exp;
branches;
next	1.20;
commitid	l3e6PhvoAh8C7elc;

1.20
date	2016.05.23.14.57.45;	author renato;	state Exp;
branches;
next	1.19;
commitid	rcIrXk0WYkMzKbw8;

1.19
date	2016.05.23.14.55.41;	author renato;	state Exp;
branches;
next	1.18;
commitid	BMjojZPSfj43vinq;

1.18
date	2016.05.23.14.49.56;	author renato;	state Exp;
branches;
next	1.17;
commitid	lTtxmGfFyaMMzQOH;

1.17
date	2015.12.05.13.11.48;	author claudio;	state Exp;
branches;
next	1.16;
commitid	c8UgZO1MU5iqaNd3;

1.16
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.15;
commitid	puLLDX1XPNc3GxB9;

1.15
date	2015.02.09.11.54.24;	author claudio;	state Exp;
branches;
next	1.14;
commitid	LTeEOygtHEq8pPcX;

1.14
date	2014.07.11.16.43.33;	author krw;	state Exp;
branches;
next	1.13;
commitid	TgA9QmI8ib2B7iAZ;

1.13
date	2013.11.26.11.59.38;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.04.02.25.28;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2012.04.12.17.33.43;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.01.13.54.54;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.14.11.52.19;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.25.21.07.31;	author michele;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.21.20.53.20;	author michele;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.08.15.54.50;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.02.19.10.02;	author mk;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.02.20.34.58;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.06.08.09.43;	author pyr;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Allow to specify an alternate control socket.

This is required to run multiple instances of ldpd.

OK claudio@@
@
text
@/*	$OpenBSD: control.c,v 1.28 2017/01/08 23:04:42 krw Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/un.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ldpd.h"
#include "ldpe.h"
#include "log.h"
#include "control.h"

#define	CONTROL_BACKLOG	5

static void		 control_accept(int, short, void *);
static struct ctl_conn	*control_connbyfd(int);
static struct ctl_conn	*control_connbypid(pid_t);
static void		 control_close(int);
static void		 control_dispatch_imsg(int, short, void *);

struct ctl_conns	 ctl_conns;

static int		 control_fd;

int
control_init(char *path)
{
	struct sockaddr_un	 sun;
	int			 fd;
	mode_t			 old_umask;

	if ((fd = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    0)) == -1) {
		log_warn("%s: socket", __func__);
		return (-1);
	}

	memset(&sun, 0, sizeof(sun));
	sun.sun_family = AF_UNIX;
	strlcpy(sun.sun_path, path, sizeof(sun.sun_path));

	if (unlink(path) == -1)
		if (errno != ENOENT) {
			log_warn("%s: unlink %s", __func__, path);
			close(fd);
			return (-1);
		}

	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		log_warn("%s: bind: %s", __func__, path);
		close(fd);
		umask(old_umask);
		return (-1);
	}
	umask(old_umask);

	if (chmod(path, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
		log_warn("%s: chmod", __func__);
		close(fd);
		(void)unlink(path);
		return (-1);
	}

	control_fd = fd;

	return (0);
}

int
control_listen(void)
{
	if (listen(control_fd, CONTROL_BACKLOG) == -1) {
		log_warn("%s: listen", __func__);
		return (-1);
	}

	return (accept_add(control_fd, control_accept, NULL));
}

void
control_cleanup(char *path)
{
	accept_del(control_fd);
	close(control_fd);
	unlink(path);
}

/* ARGSUSED */
static void
control_accept(int listenfd, short event, void *bula)
{
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_un	 sun;
	struct ctl_conn		*c;

	len = sizeof(sun);
	if ((connfd = accept4(listenfd, (struct sockaddr *)&sun, &len,
	    SOCK_NONBLOCK | SOCK_CLOEXEC)) == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE)
			accept_pause();
		else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			log_warn("%s: accept4", __func__);
		return;
	}

	if ((c = calloc(1, sizeof(struct ctl_conn))) == NULL) {
		log_warn(__func__);
		close(connfd);
		return;
	}

	imsg_init(&c->iev.ibuf, connfd);
	c->iev.handler = control_dispatch_imsg;
	c->iev.events = EV_READ;
	event_set(&c->iev.ev, c->iev.ibuf.fd, c->iev.events,
	    c->iev.handler, &c->iev);
	event_add(&c->iev.ev, NULL);

	TAILQ_INSERT_TAIL(&ctl_conns, c, entry);
}

static struct ctl_conn *
control_connbyfd(int fd)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->iev.ibuf.fd == fd)
			break;
	}

	return (c);
}

static struct ctl_conn *
control_connbypid(pid_t pid)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->iev.ibuf.pid == pid)
			break;
	}

	return (c);
}

static void
control_close(int fd)
{
	struct ctl_conn	*c;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warnx("%s: fd %d: not found", __func__, fd);
		return;
	}

	msgbuf_clear(&c->iev.ibuf.w);
	TAILQ_REMOVE(&ctl_conns, c, entry);

	event_del(&c->iev.ev);
	close(c->iev.ibuf.fd);
	accept_unpause();
	free(c);
}

/* ARGSUSED */
static void
control_dispatch_imsg(int fd, short event, void *bula)
{
	struct ctl_conn	*c;
	struct imsg	 imsg;
	ssize_t		 n;
	unsigned int	 ifidx;
	int		 verbose;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warnx("%s: fd %d: not found", __func__, fd);
		return;
	}

	if (event & EV_READ) {
		if (((n = imsg_read(&c->iev.ibuf)) == -1 && errno != EAGAIN) ||
		    n == 0) {
			control_close(fd);
			return;
		}
	}
	if (event & EV_WRITE) {
		if (msgbuf_write(&c->iev.ibuf.w) <= 0 && errno != EAGAIN) {
			control_close(fd);
			return;
		}
	}

	for (;;) {
		if ((n = imsg_get(&c->iev.ibuf, &imsg)) == -1) {
			control_close(fd);
			return;
		}

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CTL_FIB_COUPLE:
		case IMSG_CTL_FIB_DECOUPLE:
		case IMSG_CTL_RELOAD:
			c->iev.ibuf.pid = imsg.hdr.pid;
			ldpe_imsg_compose_parent(imsg.hdr.type, 0, NULL, 0);
			break;
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_KROUTE_ADDR:
		case IMSG_CTL_IFINFO:
			c->iev.ibuf.pid = imsg.hdr.pid;
			ldpe_imsg_compose_parent(imsg.hdr.type,
			    imsg.hdr.pid, imsg.data,
			    imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
		case IMSG_CTL_SHOW_INTERFACE:
			if (imsg.hdr.len == IMSG_HEADER_SIZE +
			    sizeof(ifidx)) {
				memcpy(&ifidx, imsg.data, sizeof(ifidx));
				ldpe_iface_ctl(c, ifidx);
				imsg_compose_event(&c->iev, IMSG_CTL_END, 0,
				    0, -1, NULL, 0);
			}
			break;
		case IMSG_CTL_SHOW_DISCOVERY:
			ldpe_adj_ctl(c);
			break;
		case IMSG_CTL_SHOW_LIB:
		case IMSG_CTL_SHOW_L2VPN_PW:
		case IMSG_CTL_SHOW_L2VPN_BINDING:
			c->iev.ibuf.pid = imsg.hdr.pid;
			ldpe_imsg_compose_lde(imsg.hdr.type, 0, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
		case IMSG_CTL_SHOW_NBR:
			ldpe_nbr_ctl(c);
			break;
		case IMSG_CTL_CLEAR_NBR:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct ctl_nbr))
				break;

			nbr_clear_ctl(imsg.data);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(verbose))
				break;

			/* forward to other processes */
			ldpe_imsg_compose_parent(imsg.hdr.type, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			ldpe_imsg_compose_lde(imsg.hdr.type, 0, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);

			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		default:
			log_debug("%s: error handling imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}

	imsg_event_add(&c->iev);
}

int
control_imsg_relay(struct imsg *imsg)
{
	struct ctl_conn	*c;

	if ((c = control_connbypid(imsg->hdr.pid)) == NULL)
		return (0);

	return (imsg_compose_event(&c->iev, imsg->hdr.type, 0, imsg->hdr.pid,
	    -1, imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE));
}
@


1.28
log
@Replace hand-rolled for(;;) traversal of ctl_conns TAILQ with
TAILQ_FOREACH().

No intentional functional change.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.27 2016/05/23 19:20:55 renato Exp $ */
d45 1
a45 1
control_init(void)
d59 1
a59 1
	strlcpy(sun.sun_path, LDPD_SOCKET, sizeof(sun.sun_path));
d61 1
a61 1
	if (unlink(LDPD_SOCKET) == -1)
d63 1
a63 1
			log_warn("%s: unlink %s", __func__, LDPD_SOCKET);
d70 1
a70 1
		log_warn("%s: bind: %s", __func__, LDPD_SOCKET);
d77 1
a77 1
	if (chmod(LDPD_SOCKET, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
d80 1
a80 1
		(void)unlink(LDPD_SOCKET);
d101 1
a101 1
control_cleanup(void)
d105 1
a105 1
	unlink(LDPD_SOCKET);
@


1.27
log
@Add support for manually resetting neighbors.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.26 2016/05/23 19:11:42 renato Exp $ */
d153 4
a156 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.fd != fd;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
d166 4
a169 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.pid != pid;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
@


1.26
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.25 2016/05/23 19:09:25 renato Exp $ */
d265 7
@


1.25
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.24 2016/05/23 18:55:21 renato Exp $ */
a20 1
#include <sys/socket.h>
a22 1
#include <fcntl.h>
a27 1
#include "ldp.h"
@


1.24
log
@Assorted fixes and small cleanup.

Nothing really interesting here.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.23 2016/05/23 17:43:42 renato Exp $ */
d37 5
a41 3
struct ctl_conn	*control_connbyfd(int);
struct ctl_conn	*control_connbypid(pid_t);
void		 control_close(int);
d45 1
a45 1
int control_fd;
d112 1
a112 1
void
d151 1
a151 1
struct ctl_conn *
d163 1
a163 1
struct ctl_conn *
d175 1
a175 1
void
d195 1
a195 1
void
@


1.23
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d41 2
a92 1

@


1.22
log
@Standardize some log messages and fix some inconsistencies.

We were using several different names for the same thing in our log
messages: neighbor, neighbor ID, nbr ID and LSR ID.

Standardize to always use "lsr-id" to refer to a neighbor.

Also:
* Use log_warnx() instead of log_warn() when appropriate;
* Use fatal(x) instead of err(x) when appropriate;
* Fix some inconsistent log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.21 2016/05/23 15:14:07 renato Exp $ */
d56 1
a56 1
	bzero(&sun, sizeof(sun));
@


1.21
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.20 2016/05/23 14:57:45 renato Exp $ */
d128 1
a128 1
			log_warn("%s: accept", __func__);
d178 1
a178 1
		log_warn("%s: fd %d: not found", __func__, fd);
d202 1
a202 1
		log_warn("%s: fd %d: not found", __func__, fd);
@


1.20
log
@imsg_* returns ssize_t

Pulled from ospfd. Original author: claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.19 2016/05/23 14:55:41 renato Exp $ */
d52 1
a52 1
		log_warn("control_init: socket");
d62 1
a62 1
			log_warn("control_init: unlink %s", LDPD_SOCKET);
d69 1
a69 1
		log_warn("control_init: bind: %s", LDPD_SOCKET);
d77 1
a77 1
		log_warn("control_init: chmod");
d93 1
a93 1
		log_warn("control_listen: listen");
d128 1
a128 1
			log_warn("control_accept: accept");
d133 1
a133 1
		log_warn("control_accept");
d178 1
a178 1
		log_warn("control_close: fd %d: not found", fd);
d202 1
a202 1
		log_warn("control_dispatch_imsg: fd %d: not found", fd);
d281 2
a282 2
			log_debug("control_dispatch_imsg: "
			    "error handling imsg %d", imsg.hdr.type);
@


1.19
log
@Call accept_del() on exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.18 2016/05/23 14:49:56 renato Exp $ */
d197 1
a197 1
	int		 n;
@


1.18
log
@Call accept_unpause() when any TCP socket is closed.

We were calling accept_unpause() only when an LDP session is shut
down. But, during the LDP session establishment process, we may have
TCP sockets that are not associated with any neighbor. If we close one
of these sockets, we must call accept_unpause() too.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.17 2015/12/05 13:11:48 claudio Exp $ */
d103 2
@


1.17
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.16 2015/07/21 04:52:29 renato Exp $ */
d185 1
a186 1
	accept_unpause();
@


1.16
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.15 2015/02/09 11:54:24 claudio Exp $ */
d205 2
a206 1
		if ((n = imsg_read(&c->iev.ibuf)) == -1 || n == 0) {
@


1.15
log
@More SOCK_NONBLOCK | SOCK_CLOEXEC love and one less session_socket_blockmode
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.14 2014/07/11 16:43:33 krw Exp $ */
d254 2
@


1.14
log
@Close the control fd when it has reported EOF.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.13 2013/11/26 11:59:38 henning Exp $ */
d50 2
a51 1
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
a82 1
	session_socket_blockmode(fd, BM_NONBLOCK);
d116 2
a117 1
	if ((connfd = accept(listenfd, (struct sockaddr *)&sun, &len)) == -1) {
a129 2
	session_socket_blockmode(connfd, BM_NONBLOCK);

a295 17
}

void
session_socket_blockmode(int fd, enum blockmodes bm)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		fatal("fcntl F_GETFL");

	if (bm == BM_NONBLOCK)
		flags |= O_NONBLOCK;
	else
		flags &= ~O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fcntl F_SETFL");
@


1.13
log
@deal with msgbuf_write EAGAIN, ok gilles benno
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.11 2013/03/11 17:40:11 deraadt Exp $ */
d212 1
a212 1
		if (msgbuf_write(&c->iev.ibuf.w) == -1 && errno != EAGAIN) {
@


1.12
log
@Implement support for adjacencies and targeted hellos
Refactor adjacencies out of the neighbor handling so that it is possible to
have more complex topologies with targeted sessions.
From Renato Westphal
@
text
@d212 1
a212 1
		if (msgbuf_write(&c->iev.ibuf.w) == -1) {
@


1.11
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.10 2012/04/12 17:33:43 claudio Exp $ */
d250 3
@


1.10
log
@accept pacing ldpd way. Since this daemon has multiple listening fds
we add them all to a accept queue that does the pacing with the
accept_pause() and accept_unpause() calls.
With and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.9 2010/09/01 13:54:54 claudio Exp $ */
d123 2
a124 1
		else if (errno != EWOULDBLOCK && errno != EINTR)
@


1.9
log
@s/lfib/fib/ for more consitency with the other routing daemons.
This started manly because of ldpctl beeing inconsistent and me misstyping
lfib almost every time.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.8 2010/05/14 11:52:19 claudio Exp $ */
d41 2
d83 1
a83 1
	control_state.fd = fd;
d92 1
a92 1
	if (listen(control_state.fd, CONTROL_BACKLOG) == -1) {
d97 1
a97 5
	event_set(&control_state.ev, control_state.fd, EV_READ | EV_PERSIST,
	    control_accept, NULL);
	event_add(&control_state.ev, NULL);

	return (0);
d116 8
a123 3
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&sun, &len)) == -1) {
		if (errno != EWOULDBLOCK && errno != EINTR)
d186 1
@


1.8
log
@Use calloc() instead of malloc() to allocate the connection structure. This
way the memory is zeroed. This is equivalent to the relayd commit by reyk.
OK reyk, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.7 2010/02/25 21:07:31 michele Exp $ */
d223 2
a224 4
		case IMSG_CTL_LFIB_COUPLE:
		case IMSG_CTL_LFIB_DECOUPLE:
			ldpe_fib_update(imsg.hdr.type);
			/* FALLTHROUGH */
@


1.7
log
@Whitespaces cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.6 2010/02/21 20:53:20 michele Exp $ */
d127 1
a127 1
	if ((c = malloc(sizeof(struct ctl_conn))) == NULL) {
@


1.6
log
@Kill double declaration of control_imsg_relay().

From Christiano F. Haesbaert.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.5 2009/12/08 15:54:50 jsg Exp $ */
d269 1
a269 1
			break;		
@


1.5
log
@porcesses -> processes
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.4 2009/12/02 19:10:02 mk Exp $ */
a35 2

int control_imsg_relay(struct imsg *imsg);
@


1.4
log
@log_warn() consistency.

`OK' claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.3 2009/11/02 20:34:58 claudio Exp $ */
d263 1
a263 1
			/* forward to other porcesses */
@


1.3
log
@More IMSG_CTL_LOG_VERBOSE, still doing the same toggeling of log_debug().
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.2 2009/06/06 08:09:43 pyr Exp $ */
d123 1
a123 1
			log_warn("control_accept");
@


1.2
log
@make ldpd imsg-in-a-lib ready too.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d195 1
d258 14
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d135 6
a140 5
	imsg_init(&c->ibuf, connfd, control_dispatch_imsg);
	c->ibuf.events = EV_READ;
	event_set(&c->ibuf.ev, c->ibuf.fd, c->ibuf.events,
	    c->ibuf.handler, &c->ibuf);
	event_add(&c->ibuf.ev, NULL);
d150 1
a150 1
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.fd != fd;
d162 1
a162 1
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.pid != pid;
d179 1
a179 1
	msgbuf_clear(&c->ibuf.w);
d182 2
a183 2
	event_del(&c->ibuf.ev);
	close(c->ibuf.fd);
d202 1
a202 1
		if ((n = imsg_read(&c->ibuf)) == -1 || n == 0) {
d208 1
a208 1
		if (msgbuf_write(&c->ibuf.w) == -1) {
d215 1
a215 1
		if ((n = imsg_get(&c->ibuf, &imsg)) == -1) {
d229 1
a229 1
			c->ibuf.pid = imsg.hdr.pid;
d235 1
a235 1
			c->ibuf.pid = imsg.hdr.pid;
d245 2
a246 2
				imsg_compose(&c->ibuf, IMSG_CTL_END, 0,
				    0, NULL, 0);
d250 1
a250 1
			c->ibuf.pid = imsg.hdr.pid;
d265 1
a265 1
	imsg_event_add(&c->ibuf);
d276 2
a277 2
	return (imsg_compose(&c->ibuf, imsg->hdr.type, 0, imsg->hdr.pid,
	    imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE));
@

