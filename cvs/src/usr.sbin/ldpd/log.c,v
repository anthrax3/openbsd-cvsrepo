head	1.34;
access;
symbols
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.29.0.2
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.8
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.9.0.6
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.4
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.34
date	2017.03.21.12.06.55;	author bluhm;	state Exp;
branches;
next	1.33;
commitid	6uuBMurt3Uh42fgX;

1.33
date	2017.01.20.12.19.18;	author benno;	state Exp;
branches;
next	1.32;
commitid	qrjsXLNhiS0G91tf;

1.32
date	2016.09.02.17.08.02;	author renato;	state Exp;
branches;
next	1.31;
commitid	BOhRdj3Gcm8K4Ipy;

1.31
date	2016.08.08.21.42.13;	author renato;	state Exp;
branches;
next	1.30;
commitid	06qO3EMtrAUwDN60;

1.30
date	2016.08.08.16.45.51;	author renato;	state Exp;
branches;
next	1.29;
commitid	wXIuSV6JZlfbC22E;

1.29
date	2016.07.15.17.09.25;	author renato;	state Exp;
branches;
next	1.28;
commitid	VGEMIeHBWOrVJjkU;

1.28
date	2016.07.01.23.36.38;	author renato;	state Exp;
branches;
next	1.27;
commitid	h9Qy21EPYXbAFnoh;

1.27
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.26;
commitid	AQBoOveMRKjtVfFv;

1.26
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.25;
commitid	t07H0Mk6WGdVWB0W;

1.25
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.24;
commitid	D7VvXbswyzx5Ahb2;

1.24
date	2016.05.23.18.55.21;	author renato;	state Exp;
branches;
next	1.23;
commitid	85kONxXVWUqI2Jhb;

1.23
date	2016.05.23.18.33.56;	author renato;	state Exp;
branches;
next	1.22;
commitid	YK3Z5X8iSxlfPhoT;

1.22
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.21;
commitid	VpAym8dVR6eY4drQ;

1.21
date	2016.05.23.16.54.22;	author renato;	state Exp;
branches;
next	1.20;
commitid	LfWxXXNhiR6poNUS;

1.20
date	2016.05.23.16.20.59;	author renato;	state Exp;
branches;
next	1.19;
commitid	nAtgYzDo97D7UnEI;

1.19
date	2016.05.23.16.12.28;	author renato;	state Exp;
branches;
next	1.18;
commitid	vVUYnEJVjv7IWE6u;

1.18
date	2016.05.23.15.47.24;	author renato;	state Exp;
branches;
next	1.17;
commitid	Eng7dm0NElMq9Yi3;

1.17
date	2016.05.23.15.26.35;	author renato;	state Exp;
branches;
next	1.16;
commitid	jDnLeU9v0f1mzM3K;

1.16
date	2016.05.23.15.14.07;	author renato;	state Exp;
branches;
next	1.15;
commitid	l3e6PhvoAh8C7elc;

1.15
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.14;
commitid	puLLDX1XPNc3GxB9;

1.14
date	2015.07.19.20.54.17;	author renato;	state Exp;
branches;
next	1.13;
commitid	AcGJH529uphBS2D2;

1.13
date	2014.11.03.18.44.36;	author bluhm;	state Exp;
branches;
next	1.12;
commitid	8nAFL7sqdqdC8oHX;

1.12
date	2013.06.04.02.25.28;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.01.20.13.04;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.01.18.26.40;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2011.08.20.19.02.28;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.02.14.34.04;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.10.13.22.25;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.09.14.01.03;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.29.12.09.28;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.15.15.44.37;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2010.04.15.15.39.32;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.02.20.34.58;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.34
log
@From a syslog perspective it does not make sense to log fatal and
warn with the same severity.  Switch log_warn() to LOG_ERR and keep
fatal() at LOG_CRIT.
OK reyk@@ florian@@
@
text
@/*	$OpenBSD: log.c,v 1.33 2017/01/20 12:19:18 benno Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <netdb.h>
#include <limits.h>

#include "log.h"
#include "ldpd.h"

int		 debug;
int		 verbose;
const char	*log_procname;

void
log_init(int n_debug)
{
	extern char	*__progname;

	debug = n_debug;

	if (!debug)
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_DAEMON);

	tzset();
}

void
log_verbose(int v)
{
	verbose = v;
}

void
logit(int pri, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	vlog(pri, fmt, ap);
	va_end(ap);
}

void
vlog(int pri, const char *fmt, va_list ap)
{
	char	*nfmt;

	if (debug) {
		/* best effort in out of mem situations */
		if (asprintf(&nfmt, "%s\n", fmt) == -1) {
			vfprintf(stderr, fmt, ap);
			fprintf(stderr, "\n");
		} else {
			vfprintf(stderr, nfmt, ap);
			free(nfmt);
		}
		fflush(stderr);
	} else
		vsyslog(pri, fmt, ap);
}

void
log_warn(const char *emsg, ...)
{
	char	*nfmt;
	va_list	 ap;

	/* best effort to even work in out of memory situations */
	if (emsg == NULL)
		logit(LOG_ERR, "%s", strerror(errno));
	else {
		va_start(ap, emsg);

		if (asprintf(&nfmt, "%s: %s", emsg, strerror(errno)) == -1) {
			/* we tried it... */
			vlog(LOG_ERR, emsg, ap);
			logit(LOG_ERR, "%s", strerror(errno));
		} else {
			vlog(LOG_ERR, nfmt, ap);
			free(nfmt);
		}
		va_end(ap);
	}
}

void
log_warnx(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_ERR, emsg, ap);
	va_end(ap);
}

void
log_info(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_INFO, emsg, ap);
	va_end(ap);
}

void
log_debug(const char *emsg, ...)
{
	va_list	 ap;

	if (verbose & LDPD_OPT_VERBOSE) {
		va_start(ap, emsg);
		vlog(LOG_DEBUG, emsg, ap);
		va_end(ap);
	}
}

void
fatal(const char *emsg)
{
	if (emsg == NULL)
		logit(LOG_CRIT, "fatal in %s: %s", log_procname,
		    strerror(errno));
	else
		if (errno)
			logit(LOG_CRIT, "fatal in %s: %s: %s",
			    log_procname, emsg, strerror(errno));
		else
			logit(LOG_CRIT, "fatal in %s: %s",
			    log_procname, emsg);

	exit(1);
}

void
fatalx(const char *emsg)
{
	errno = 0;
	fatal(emsg);
}
@


1.33
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

removal of log_rtmsg() aproved by claudio@@

ok claudio@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.32 2016/09/02 17:08:02 renato Exp $ */
d91 1
a91 1
		logit(LOG_CRIT, "%s", strerror(errno));
d97 2
a98 2
			vlog(LOG_CRIT, emsg, ap);
			logit(LOG_CRIT, "%s", strerror(errno));
d100 1
a100 1
			vlog(LOG_CRIT, nfmt, ap);
d113 1
a113 1
	vlog(LOG_CRIT, emsg, ap);
@


1.32
log
@Improve logging of sent and received messages.

* Standardize the logging format of sent and received messages:
  "msg-[in|out]: message type: lsr-id A.B.C.D [additional info]";

* Log sent label messages as well, not only the received ones;

* Move the logging of sent notification messages from
  send_notification_nbr() to send_notification_full(), this way notification
  triggered by the lde process are logged as well;

* Minor clean-up.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.31 2016/08/08 21:42:13 renato Exp $ */
a18 4
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netmpls/mpls.h>
d28 1
a29 9
#include "ldpe.h"
#include "lde.h"
#include "log.h"

static const char * const procnames[] = {
	"parent",
	"ldpe",
	"lde"
};
d31 3
a33 4
static void	 vlog(int, const char *, va_list);

static int	 debug;
static int	 verbose;
d64 1
a64 1
static void
d143 1
a143 1
		logit(LOG_CRIT, "fatal in %s: %s", procnames[ldpd_process],
d148 1
a148 1
			    procnames[ldpd_process], emsg, strerror(errno));
d151 1
a151 1
			    procnames[ldpd_process], emsg);
a160 426
}

#define NUM_LOGS	4
const char *
log_sockaddr(void *vp)
{
	static char	 buf[NUM_LOGS][NI_MAXHOST];
	static int	 round = 0;
	struct sockaddr	*sa = vp;

	round = (round + 1) % NUM_LOGS;

	if (getnameinfo(sa, sa->sa_len, buf[round], NI_MAXHOST, NULL, 0,
	    NI_NUMERICHOST))
		return ("(unknown)");
	else
		return (buf[round]);
}

const char *
log_in6addr(const struct in6_addr *addr)
{
	struct sockaddr_in6	sa_in6;

	memset(&sa_in6, 0, sizeof(sa_in6));
	sa_in6.sin6_len = sizeof(sa_in6);
	sa_in6.sin6_family = AF_INET6;
	sa_in6.sin6_addr = *addr;

	recoverscope(&sa_in6);

	return (log_sockaddr(&sa_in6));
}

const char *
log_in6addr_scope(const struct in6_addr *addr, unsigned int ifindex)
{
	struct sockaddr_in6	sa_in6;

	memset(&sa_in6, 0, sizeof(sa_in6));
	sa_in6.sin6_len = sizeof(sa_in6);
	sa_in6.sin6_family = AF_INET6;
	sa_in6.sin6_addr = *addr;

	addscope(&sa_in6, ifindex);

	return (log_sockaddr(&sa_in6));
}

const char *
log_addr(int af, const union ldpd_addr *addr)
{
	static char	 buf[NUM_LOGS][INET6_ADDRSTRLEN];
	static int	 round = 0;

	switch (af) {
	case AF_INET:
		round = (round + 1) % NUM_LOGS;
		if (inet_ntop(AF_INET, &addr->v4, buf[round],
		    sizeof(buf[round])) == NULL)
			return ("???");
		return (buf[round]);
	case AF_INET6:
		return (log_in6addr(&addr->v6));
	default:
		break;
	}

	return ("???");
}

#define	TF_BUFS	4
#define	TF_LEN	32

char *
log_label(uint32_t label)
{
	char		*buf;
	static char	 tfbuf[TF_BUFS][TF_LEN];	/* ring buffer */
	static int	 idx = 0;

	buf = tfbuf[idx++];
	if (idx == TF_BUFS)
		idx = 0;

	switch (label) {
	case NO_LABEL:
		snprintf(buf, TF_LEN, "-");
		break;
	case MPLS_LABEL_IMPLNULL:
		snprintf(buf, TF_LEN, "imp-null");
		break;
	case MPLS_LABEL_IPV4NULL:
	case MPLS_LABEL_IPV6NULL:
		snprintf(buf, TF_LEN, "exp-null");
		break;
	default:
		snprintf(buf, TF_LEN, "%u", label);
		break;
	}

	return (buf);
}

char *
log_hello_src(const struct hello_source *src)
{
	static char buf[64];

	switch (src->type) {
	case HELLO_LINK:
		snprintf(buf, sizeof(buf), "iface %s",
		    src->link.ia->iface->name);
		break;
	case HELLO_TARGETED:
		snprintf(buf, sizeof(buf), "source %s",
		    log_addr(src->target->af, &src->target->addr));
		break;
	}

	return (buf);
}

const char *
log_map(const struct map *map)
{
	static char	buf[64];

	switch (map->type) {
	case MAP_TYPE_WILDCARD:
		if (snprintf(buf, sizeof(buf), "wildcard") < 0)
			return ("???");
		break;
	case MAP_TYPE_PREFIX:
		if (snprintf(buf, sizeof(buf), "%s/%u",
		    log_addr(map->fec.prefix.af, &map->fec.prefix.prefix),
		    map->fec.prefix.prefixlen) == -1)
			return ("???");
		break;
	case MAP_TYPE_PWID:
		if (snprintf(buf, sizeof(buf), "pwid %u (%s)",
		    map->fec.pwid.pwid,
		    pw_type_name(map->fec.pwid.type)) == -1)
			return ("???");
		break;
	default:
		return ("???");
	}

	return (buf);
}

const char *
log_fec(const struct fec *fec)
{
	static char	buf[64];
	union ldpd_addr	addr;

	switch (fec->type) {
	case FEC_TYPE_IPV4:
		addr.v4 = fec->u.ipv4.prefix;
		if (snprintf(buf, sizeof(buf), "ipv4 %s/%u",
		    log_addr(AF_INET, &addr), fec->u.ipv4.prefixlen) == -1)
			return ("???");
		break;
	case FEC_TYPE_IPV6:
		addr.v6 = fec->u.ipv6.prefix;
		if (snprintf(buf, sizeof(buf), "ipv6 %s/%u",
		    log_addr(AF_INET6, &addr), fec->u.ipv6.prefixlen) == -1)
			return ("???");
		break;
	case FEC_TYPE_PWID:
		if (snprintf(buf, sizeof(buf),
		    "pwid %u (%s) - %s",
		    fec->u.pwid.pwid, pw_type_name(fec->u.pwid.type),
		    inet_ntoa(fec->u.pwid.lsr_id)) == -1)
			return ("???");
		break;
	default:
		return ("???");
	}

	return (buf);
}

/* names */
const char *
af_name(int af)
{
	switch (af) {
	case AF_INET:
		return ("ipv4");
	case AF_INET6:
		return ("ipv6");
	case AF_MPLS:
		return ("mpls");
	default:
		return ("UNKNOWN");
	}
}

const char *
socket_name(int type)
{
	switch (type) {
	case LDP_SOCKET_DISC:
		return ("discovery");
	case LDP_SOCKET_EDISC:
		return ("extended discovery");
	case LDP_SOCKET_SESSION:
		return ("session");
	default:
		return ("UNKNOWN");
	}
}

const char *
nbr_state_name(int state)
{
	switch (state) {
	case NBR_STA_PRESENT:
		return ("PRESENT");
	case NBR_STA_INITIAL:
		return ("INITIALIZED");
	case NBR_STA_OPENREC:
		return ("OPENREC");
	case NBR_STA_OPENSENT:
		return ("OPENSENT");
	case NBR_STA_OPER:
		return ("OPERATIONAL");
	default:
		return ("UNKNOWN");
	}
}

const char *
if_state_name(int state)
{
	switch (state) {
	case IF_STA_DOWN:
		return ("DOWN");
	case IF_STA_ACTIVE:
		return ("ACTIVE");
	default:
		return ("UNKNOWN");
	}
}

const char *
if_type_name(enum iface_type type)
{
	switch (type) {
	case IF_TYPE_POINTOPOINT:
		return ("POINTOPOINT");
	case IF_TYPE_BROADCAST:
		return ("BROADCAST");
	}
	/* NOTREACHED */
	return ("UNKNOWN");
}

const char *
msg_name(uint16_t msg)
{
	static char buf[16];

	switch (msg) {
	case MSG_TYPE_NOTIFICATION:
		return ("notification");
	case MSG_TYPE_HELLO:
		return ("hello");
	case MSG_TYPE_INIT:
		return ("initialization");
	case MSG_TYPE_KEEPALIVE:
		return ("keepalive");
	case MSG_TYPE_ADDR:
		return ("address");
	case MSG_TYPE_ADDRWITHDRAW:
		return ("address withdraw");
	case MSG_TYPE_LABELMAPPING:
		return ("label mapping");
	case MSG_TYPE_LABELREQUEST:
		return ("label request");
	case MSG_TYPE_LABELWITHDRAW:
		return ("label withdraw");
	case MSG_TYPE_LABELRELEASE:
		return ("label release");
	case MSG_TYPE_LABELABORTREQ:
	default:
		snprintf(buf, sizeof(buf), "[%08x]", msg);
		return (buf);
	}
}

const char *
status_code_name(uint32_t status)
{
	static char buf[16];

	switch (status) {
	case S_SUCCESS:
		return ("Success");
	case S_BAD_LDP_ID:
		return ("Bad LDP Identifier");
	case S_BAD_PROTO_VER:
		return ("Bad Protocol Version");
	case S_BAD_PDU_LEN:
		return ("Bad PDU Length");
	case S_UNKNOWN_MSG:
		return ("Unknown Message Type");
	case S_BAD_MSG_LEN:
		return ("Bad Message Length");
	case S_UNKNOWN_TLV:
		return ("Unknown TLV");
	case S_BAD_TLV_LEN:
		return ("Bad TLV Length");
	case S_BAD_TLV_VAL:
		return ("Malformed TLV Value");
	case S_HOLDTIME_EXP:
		return ("Hold Timer Expired");
	case S_SHUTDOWN:
		return ("Shutdown");
	case S_LOOP_DETECTED:
		return ("Loop Detected");
	case S_UNKNOWN_FEC:
		return ("Unknown FEC");
	case S_NO_ROUTE:
		return ("No Route");
	case S_NO_LABEL_RES:
		return ("No Label Resources");
	case S_AVAILABLE:
		return ("Label Resources Available");
	case S_NO_HELLO:
		return ("Session Rejected, No Hello");
	case S_PARM_ADV_MODE:
		return ("Rejected Advertisement Mode Parameter");
	case S_MAX_PDU_LEN:
		return ("Rejected Max PDU Length Parameter");
	case S_PARM_L_RANGE:
		return ("Rejected Label Range Parameter");
	case S_KEEPALIVE_TMR:
		return ("KeepAlive Timer Expired");
	case S_LAB_REQ_ABRT:
		return ("Label Request Aborted");
	case S_MISS_MSG:
		return ("Missing Message Parameters");
	case S_UNSUP_ADDR:
		return ("Unsupported Address Family");
	case S_KEEPALIVE_BAD:
		return ("Bad KeepAlive Time");
	case S_INTERN_ERR:
		return ("Internal Error");
	case S_ILLEGAL_CBIT:
		return ("Illegal C-Bit");
	case S_WRONG_CBIT:
		return ("Wrong C-Bit");
	case S_INCPT_BITRATE:
		return ("Incompatible bit-rate");
	case S_CEP_MISCONF:
		return ("CEP-TDM mis-configuration");
	case S_PW_STATUS:
		return ("PW Status");
	case S_UNASSIGN_TAI:
		return ("Unassigned/Unrecognized TAI");
	case S_MISCONF_ERR:
		return ("Generic Misconfiguration Error");
	case S_WITHDRAW_MTHD:
		return ("Label Withdraw PW Status Method");
	case S_TRANS_MISMTCH:
		return ("Transport Connection Mismatch");
	case S_DS_NONCMPLNCE:
		return ("Dual-Stack Noncompliance");
	default:
		snprintf(buf, sizeof(buf), "[%08x]", status);
		return (buf);
	}
}

const char *
pw_type_name(uint16_t pw_type)
{
	static char buf[64];

	switch (pw_type) {
	case PW_TYPE_ETHERNET_TAGGED:
		return ("Eth Tagged");
	case PW_TYPE_ETHERNET:
		return ("Ethernet");
	default:
		snprintf(buf, sizeof(buf), "[%0x]", pw_type);
		return (buf);
	}
}

static char *msgtypes[] = {
	"",
	"RTM_ADD: Add Route",
	"RTM_DELETE: Delete Route",
	"RTM_CHANGE: Change Metrics or flags",
	"RTM_GET: Report Metrics",
	"RTM_LOSING: Kernel Suspects Partitioning",
	"RTM_REDIRECT: Told to use different route",
	"RTM_MISS: Lookup failed on this address",
	"RTM_LOCK: fix specified metrics",
	"RTM_OLDADD: caused by SIOCADDRT",
	"RTM_OLDDEL: caused by SIOCDELRT",
	"RTM_RESOLVE: Route created by cloning",
	"RTM_NEWADDR: address being added to iface",
	"RTM_DELADDR: address being removed from iface",
	"RTM_IFINFO: iface status change",
	"RTM_IFANNOUNCE: iface arrival/departure",
	"RTM_DESYNC: route socket overflow",
};

void
log_rtmsg(unsigned char rtm_type)
{
	if (!(verbose & LDPD_OPT_VERBOSE2))
		return;

	if (rtm_type > 0 &&
	    rtm_type < sizeof(msgtypes)/sizeof(msgtypes[0]))
		log_debug("kernel message: %s", msgtypes[rtm_type]);
	else
		log_debug("kernel message: rtm_type %d out of range",
		    rtm_type);
@


1.31
log
@Use exit(3) instead of _exit(2) in the child processes.

Since recently the child processes call exec() after fork(), so they should
stop using _exit(2) and use exit(3) instead when shutting down.

Ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.30 2016/08/08 16:45:51 renato Exp $ */
d433 33
@


1.30
log
@Normalize the received prefixes.

We need to use ldp_applymask() to normalize the received
prefixes. Example: 10.1.1.0/16 -> 10.1.0.0/16.

Additionally, stop using IANA's AF numbers in map->fec.prefix.af and use
AF_INET/AF_INET6 instead. This makes the code much simpler, use AF_IPV[46]
only when necessary (decoding/encoding prefixes).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.29 2016/07/15 17:09:25 renato Exp $ */
d166 1
a166 4
	if (ldpd_process == PROC_MAIN)
		exit(1);
	else				/* parent copes via SIGCHLD */
		_exit(1);
@


1.29
log
@Improve logging of reserved labels.

Print "exp-null" and "imp-null" instead of "0" and "3", for example. Also,
remove print_label() and print_pw_type() from ldpctl.c and use the
equivalent functions from ldpd's log.c.

While here, be more paranoid and use UINT32_MAX instead of UINT_MAX
for NO_LABEL.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.28 2016/07/01 23:36:38 renato Exp $ */
a303 1
	int		af;
a310 11
		switch (map->fec.prefix.af) {
		case AF_IPV4:
			af = AF_INET;
			break;
		case AF_IPV6:
			af = AF_INET6;
			break;
		default:
			return ("???");
		}

d312 1
a312 1
		    log_addr(af, &map->fec.prefix.prefix),
@


1.28
log
@More renaming and whitespace cleanup.

No binary change after "strip -s".
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.27 2016/05/23 19:11:42 renato Exp $ */
d19 2
d22 1
d30 1
d248 126
a547 93
}

char *
log_hello_src(const struct hello_source *src)
{
	static char buffer[64];

	switch (src->type) {
	case HELLO_LINK:
		snprintf(buffer, sizeof(buffer), "iface %s",
		    src->link.ia->iface->name);
		break;
	case HELLO_TARGETED:
		snprintf(buffer, sizeof(buffer), "source %s",
		    log_addr(src->target->af, &src->target->addr));
		break;
	}

	return (buffer);
}

const char *
log_map(const struct map *map)
{
	static char	buf[64];
	int		af;

	switch (map->type) {
	case MAP_TYPE_WILDCARD:
		if (snprintf(buf, sizeof(buf), "wildcard") < 0)
			return ("???");
		break;
	case MAP_TYPE_PREFIX:
		switch (map->fec.prefix.af) {
		case AF_IPV4:
			af = AF_INET;
			break;
		case AF_IPV6:
			af = AF_INET6;
			break;
		default:
			return ("???");
		}

		if (snprintf(buf, sizeof(buf), "%s/%u",
		    log_addr(af, &map->fec.prefix.prefix),
		    map->fec.prefix.prefixlen) == -1)
			return ("???");
		break;
	case MAP_TYPE_PWID:
		if (snprintf(buf, sizeof(buf), "pwid %u (%s)",
		    map->fec.pwid.pwid,
		    pw_type_name(map->fec.pwid.type)) == -1)
			return ("???");
		break;
	default:
		return ("???");
	}

	return (buf);
}

const char *
log_fec(const struct fec *fec)
{
	static char	buf[64];
	union ldpd_addr	addr;

	switch (fec->type) {
	case FEC_TYPE_IPV4:
		addr.v4 = fec->u.ipv4.prefix;
		if (snprintf(buf, sizeof(buf), "ipv4 %s/%u",
		    log_addr(AF_INET, &addr), fec->u.ipv4.prefixlen) == -1)
			return ("???");
		break;
	case FEC_TYPE_IPV6:
		addr.v6 = fec->u.ipv6.prefix;
		if (snprintf(buf, sizeof(buf), "ipv6 %s/%u",
		    log_addr(AF_INET6, &addr), fec->u.ipv6.prefixlen) == -1)
			return ("???");
		break;
	case FEC_TYPE_PWID:
		if (snprintf(buf, sizeof(buf),
		    "pwid %u (%s) - %s",
		    fec->u.pwid.pwid, pw_type_name(fec->u.pwid.type),
		    inet_ntoa(fec->u.pwid.lsr_id)) == -1)
			return ("???");
		break;
	default:
		return ("???");
	}

	return (buf);
@


1.27
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.26 2016/05/23 19:09:25 renato Exp $ */
d321 1
a321 1
notification_name(uint32_t status)
@


1.26
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.25 2016/05/23 18:58:48 renato Exp $ */
a18 3
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
a19 1

a20 1
#include <stdarg.h>
@


1.25
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.24 2016/05/23 18:55:21 renato Exp $ */
d44 4
a47 2
int	debug;
int	verbose;
d78 1
a78 1
void
@


1.24
log
@Assorted fixes and small cleanup.

Nothing really interesting here.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.23 2016/05/23 18:33:56 renato Exp $ */
d31 1
d178 69
d249 15
d397 4
d431 1
a431 1
		    src->link.iface->name);
d435 1
a435 1
		    inet_ntoa(src->target->addr));
d446 1
a446 1
	char		pstr[64];
d454 11
d466 2
a467 2
		    inet_ntop(AF_INET, &map->fec.ipv4.prefix, pstr,
		    sizeof(pstr)), map->fec.ipv4.prefixlen) == -1)
d487 1
a487 1
	char		pstr[32];
d491 9
a499 3
		if (snprintf(buf, sizeof(buf), "%s/%u",
		    inet_ntop(AF_INET, &fec->u.ipv4.prefix, pstr,
		    sizeof(pstr)), fec->u.ipv4.prefixlen) == -1)
@


1.23
log
@Create network sockets on the parent process.

We drop our privileges in ldpe right after we create the network sockets.
The problem is that we might want to change the transport-address and
reload the config, in which case we need new sockets. To allow that,
always create the network sockets in the parent process and pass them
to ldpe via imsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.22 2016/05/23 17:43:42 renato Exp $ */
d354 1
a354 1
log_map(struct map *map)
d384 1
a384 1
log_fec(struct fec *fec)
@


1.22
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d178 15
@


1.21
log
@Rework L2VPN code.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.20 2016/05/23 16:20:59 renato Exp $ */
d224 1
a224 1
notification_name(u_int32_t status)
d304 1
a304 1
pw_type_name(u_int16_t pw_type)
d416 1
a416 1
log_rtmsg(u_char rtm_type)
@


1.20
log
@Standardize some log messages and fix some inconsistencies.

We were using several different names for the same thing in our log
messages: neighbor, neighbor ID, nbr ID and LSR ID.

Standardize to always use "lsr-id" to refer to a neighbor.

Also:
* Use log_warnx() instead of log_warn() when appropriate;
* Use fatal(x) instead of err(x) when appropriate;
* Fix some inconsistent log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.19 2016/05/23 16:12:28 renato Exp $ */
d385 1
a385 1
		    inet_ntoa(fec->u.pwid.nexthop)) == -1)
@


1.19
log
@Rename a few constants to avoid confusion.

In ldpd we have the map structure, which is used to represent a label message,
and the fec structure, used to store FECs in the LIB.

As of now, ldpd supports two type of FECs:
* IPv4 prefix (FEC_TYPE_IPV4);
* PWID (FEC_TYPE_PWID).

For the label messages, the following contants were being used:
* FEC_WILDCARD;
* FEC_PREFIX (IPv4 or IPv6);
* FEC_PWID.

Since these contants have similar names to the previous ones, rename
them to:
* MAP_TYPE_WILDCARD;
* MAP_TYPE_PREFIX;
* MAP_TYPE_PWID.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.18 2016/05/23 15:47:24 renato Exp $ */
d193 1
a193 1
		return ("UNKNW");
d206 1
a206 1
		return ("UNKNW");
@


1.18
log
@Move some code around.

This patch doesn't introduce any logical change.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.17 2016/05/23 15:26:35 renato Exp $ */
d345 1
a345 1
	case FEC_WILDCARD:
d349 1
a349 1
	case FEC_PREFIX:
d355 1
a355 1
	case FEC_PWID:
@


1.17
log
@Fix logging of wildcard label mappings.

If snprintf fails, a value less than 0 is returned.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.16 2016/05/23 15:14:07 renato Exp $ */
d33 1
d317 19
@


1.16
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.15 2015/07/21 04:52:29 renato Exp $ */
d326 1
a326 1
		if (snprintf(buf, sizeof(buf), "wildcard"))
@


1.15
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.14 2015/07/19 20:54:17 renato Exp $ */
d403 1
a403 1
		log_debug("rtmsg_process: %s", msgtypes[rtm_type]);
d405 1
a405 1
		log_debug("rtmsg_process: rtm_type %d out of range",
@


1.14
log
@Rework label mapping algorithms to be more in line with the RFC.

This patch presents a thoroughly review of the label mapping
algorithms. Most of the changes are minor bug fixes in the handling of
received label messages.

Additional improvements:
* Add a few more references to the Appendix A of the RFC5036 ("LDP
  Label Distribution Procedures") into the code;
* Add full multipath support;
* Send label withdraws when appropriate;
* Add label withdraw/release wildcard support.

NOTE: As a result of implementing only the "Liberal Label Retention" and
"Downstream Unsolicited" modes, we will never send a label request
("Request  Never"). And that means that we can ignore the following
notification messages: "Label Request Aborted", "No Label Resources",
"No Route" and "Label Resources Available". The following algorithms
mentioned in the RFC can also be ignored: "Timeout of Deferred Label
Request", "Detect Local Label Resources Have Become Available" and
"Receive Label Abort Request".

Now, considering that we only support one combination of all modes of
operation, we can say that we have an almost complete implementation of
the protocol.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.13 2014/11/03 18:44:36 bluhm Exp $ */
d33 1
d280 16
d303 1
a303 1
log_fec(struct map *map)
d305 47
a351 1
	static char	buf[32];
d354 15
a368 6
	if (map->flags & F_MAP_WILDCARD)
		return ("wildcard");

	if (snprintf(buf, sizeof(buf), "%s/%u",
	    inet_ntop(AF_INET, &map->prefix, pstr, sizeof(pstr)),
	    map->prefixlen) == -1)
d370 1
@


1.13
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.12 2013/06/04 02:25:28 claudio Exp $ */
d290 3
@


1.12
log
@Implement support for adjacencies and targeted hellos
Refactor adjacencies out of the neighbor handling so that it is possible to
have more complex topologies with targeted sessions.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.11 2013/06/01 20:13:04 claudio Exp $ */
a42 2

void	 logit(int, const char *, ...);
@


1.11
log
@Filter out route messages we don't need and log kernel messages in
super verbose mode.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.10 2013/06/01 18:26:40 claudio Exp $ */
a181 2
	case NBR_STA_DOWN:
		return ("DOWN");
@


1.10
log
@Don't allow enabling LDP on loopback and carp interfaces.
LDP should be allowed only on physical or tunnel interfaces.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.9 2011/08/20 19:02:28 sthen Exp $ */
d143 1
a143 1
	if (verbose) {
d301 34
@


1.9
log
@Decouple log_verbose() from log_init() so the verbose flag stays set with
"-v" (previously only "-vd" worked). Similar to recent ospfd commit.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.8 2010/09/02 14:34:04 claudio Exp $ */
a204 2
	case IF_STA_LOOPBACK:
		return ("LOOP");
@


1.8
log
@NBR_STA_SESSION, NBR_STA_UP, and NBR_STA_ACTIVE represent all the same
group of states (all but NBR_STA_DOWN). Clean up this confusion and remove
NBR_STA_UP and NBR_STA_ACTIVE.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.7 2010/06/10 13:22:25 claudio Exp $ */
a51 1
	verbose = n_debug;
@


1.7
log
@No need to print FEC twice. Remove it in the log function.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.6 2010/06/09 14:01:03 claudio Exp $ */
a194 2
	case NBR_STA_ACTIVE:
		return ("ACTIVE");
@


1.6
log
@Move the logging of FEC changes to the LDE and print the FEC and label
information. This is more useful.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.5 2010/04/29 12:09:28 claudio Exp $ */
d300 1
a300 1
	if (snprintf(buf, sizeof(buf), "FEC %s/%u",
d303 1
a303 1
		return ("FEC ???");
@


1.5
log
@Remove some more ospfd-ism from the interface code. This time remove
of most of the IF_TYPE_ special cases and most interface types.
Point-to-point and broadcast still present because of find_iface()
which needs addtional fixing.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.4 2010/04/15 15:44:37 claudio Exp $ */
d19 5
d292 14
@


1.4
log
@Log recieved notifications in a human understanable way. Makes debugging
a bit easier.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.3 2010/04/15 15:39:32 claudio Exp $ */
a219 6
	case IF_TYPE_NBMA:
		return ("NBMA");
	case IF_TYPE_POINTOMULTIPOINT:
		return ("POINTOMULTIPOINT");
	case IF_TYPE_VIRTUALLINK:
		return ("VIRTUALLINK");
@


1.3
log
@Cleanup the interface FSM by removing most of the ospfd specific states
that have nothing to do with LDP.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.2 2009/11/02 20:34:58 claudio Exp $ */
d229 64
@


1.2
log
@More IMSG_CTL_LOG_VERBOSE, still doing the same toggeling of log_debug().
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
a204 4
	case IF_STA_POINTTOPOINT:
		return ("P2P");
	case IF_STA_DROTHER:
		return ("OTHER");
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d37 1
d47 1
d56 6
d139 1
a139 1
	if (debug) {
@

