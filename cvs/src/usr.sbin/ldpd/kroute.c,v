head	1.65;
access;
symbols
	OPENBSD_6_1:1.65.0.4
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.61.0.2
	OPENBSD_6_0_BASE:1.61
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.25.0.8
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.6
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.4
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.65
date	2017.03.04.00.21.48;	author renato;	state Exp;
branches;
next	1.64;
commitid	luKtDak9oSLriyOU;

1.64
date	2017.03.03.23.41.27;	author renato;	state Exp;
branches;
next	1.63;
commitid	lvj5kMm2TzZDSXqr;

1.63
date	2017.03.03.23.36.06;	author renato;	state Exp;
branches;
next	1.62;
commitid	nsyffCkbHeLwduqi;

1.62
date	2017.01.20.12.19.18;	author benno;	state Exp;
branches;
next	1.61;
commitid	qrjsXLNhiS0G91tf;

1.61
date	2016.06.18.01.25.53;	author renato;	state Exp;
branches;
next	1.60;
commitid	ru2TxJdOjUpe8t8d;

1.60
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.59;
commitid	TLlfi1Pk0Z97z8HM;

1.59
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.58;
commitid	AQBoOveMRKjtVfFv;

1.58
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.57;
commitid	t07H0Mk6WGdVWB0W;

1.57
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.56;
commitid	D7VvXbswyzx5Ahb2;

1.56
date	2016.05.23.18.55.21;	author renato;	state Exp;
branches;
next	1.55;
commitid	85kONxXVWUqI2Jhb;

1.55
date	2016.05.23.18.40.15;	author renato;	state Exp;
branches;
next	1.54;
commitid	LYl0nXLaUb8GwBRC;

1.54
date	2016.05.23.18.28.22;	author renato;	state Exp;
branches;
next	1.53;
commitid	FV8IR5RMrg1EHRis;

1.53
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.52;
commitid	VpAym8dVR6eY4drQ;

1.52
date	2016.05.23.16.20.59;	author renato;	state Exp;
branches;
next	1.51;
commitid	nAtgYzDo97D7UnEI;

1.51
date	2016.05.23.16.14.36;	author renato;	state Exp;
branches;
next	1.50;
commitid	hNzA87VdOHsaOms9;

1.50
date	2016.05.23.15.38.58;	author renato;	state Exp;
branches;
next	1.49;
commitid	Ti1jaPNpo1kOa5Wa;

1.49
date	2016.05.23.15.16.16;	author renato;	state Exp;
branches;
next	1.48;
commitid	Fo2PH1H37dQeE6a2;

1.48
date	2016.05.23.15.14.07;	author renato;	state Exp;
branches;
next	1.47;
commitid	l3e6PhvoAh8C7elc;

1.47
date	2015.09.27.17.30.38;	author stsp;	state Exp;
branches;
next	1.46;
commitid	pKhBZfZX0D7hOGSk;

1.46
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.45;
commitid	puLLDX1XPNc3GxB9;

1.45
date	2015.07.21.04.43.28;	author renato;	state Exp;
branches;
next	1.44;
commitid	QaTrdqMa9i0CUoyW;

1.44
date	2015.07.21.04.39.28;	author renato;	state Exp;
branches;
next	1.43;
commitid	KR83ZYzpLqbp9L95;

1.43
date	2015.07.19.18.27.59;	author renato;	state Exp;
branches;
next	1.42;
commitid	9kOXzqr0NuJAc5FM;

1.42
date	2015.07.17.21.26.05;	author claudio;	state Exp;
branches;
next	1.41;
commitid	eOyXWhMLRdJDAdPY;

1.41
date	2015.04.04.16.21.48;	author renato;	state Exp;
branches;
next	1.40;
commitid	Ei5FsjhzSGT2pffu;

1.40
date	2015.03.21.18.34.01;	author renato;	state Exp;
branches;
next	1.39;
commitid	cFXa8ucj1hCSVYz6;

1.39
date	2015.03.21.18.32.01;	author renato;	state Exp;
branches;
next	1.38;
commitid	Q890u5RO8xyMjkAO;

1.38
date	2015.03.21.18.20.19;	author renato;	state Exp;
branches;
next	1.37;
commitid	hFwfVjQtb1CZchyG;

1.37
date	2015.02.11.05.56.51;	author claudio;	state Exp;
branches;
next	1.36;
commitid	0Q9lBJlXtnIy6uDi;

1.36
date	2015.02.10.08.25.51;	author claudio;	state Exp;
branches;
next	1.35;
commitid	wwvr8MK7KuO6yF9J;

1.35
date	2015.02.10.01.03.54;	author claudio;	state Exp;
branches;
next	1.34;
commitid	cLo6tZgL6zd4cYfb;

1.34
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	Uu5nFG3wCl0LACBb;

1.33
date	2014.06.23.03.46.17;	author guenther;	state Exp;
branches;
next	1.32;
commitid	uXnRK9VvnFZsAqfW;

1.32
date	2013.10.30.17.24.34;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.10.15.21.54.19;	author renato;	state Exp;
branches;
next	1.30;

1.30
date	2013.10.15.20.21.25;	author renato;	state Exp;
branches;
next	1.29;

1.29
date	2013.06.04.00.41.18;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2013.06.03.16.56.47;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.03.16.53.49;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2013.06.01.20.13.04;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2011.06.26.19.19.23;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2010.10.20.12.16.41;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2010.10.15.13.18.45;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2010.10.07.12.38.00;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.01.13.54.54;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2010.07.12.14.35.13;	author bluhm;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.08.09.41.05;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.30.05.27.56;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.30.05.21.38;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.30.05.07.09;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.30.02.09.22;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.21.19.43.36;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.07.13.24.23;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.25.13.29.45;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.19.13.13.36;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.13.15.39.29;	author michele;	state Exp;
branches;
next	1.9;

1.9
date	2010.03.25.12.05.18;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.24.19.13.10;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.03.10.17.05;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.19.12.47.29;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.28.09.48.46;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2009.08.06.09.07.49;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.13.19.04.26;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.22.40.24;	author chris;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Send VPLS MAC withdrawals.

RFC 4762 says that MAC address withdrawal messages can be used to
improve convergence time in VPLS networks. This patch makes ldpd send
MAC withdrawals whenever a non-pseudowire interface pertaining to a
VPLS goes down. The processing of received MAC withdrawals will be
implemented later.
@
text
@/*	$OpenBSD: kroute.c,v 1.64 2017/03/03 23:41:27 renato Exp $ */

/*
 * Copyright (c) 2015, 2016 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/sysctl.h>
#include <arpa/inet.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>
#include <netmpls/mpls.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "ldpd.h"
#include "log.h"

struct {
	uint32_t		rtseq;
	pid_t			pid;
	int			fib_sync;
	int			fd;
	int			ioctl_fd;
	struct event		ev;
	unsigned int		rdomain;
} kr_state;

struct kroute_node {
	TAILQ_ENTRY(kroute_node)	 entry;
	struct kroute_priority		*kprio;		/* back pointer */
	struct kroute			 r;
};

struct kroute_priority {
	TAILQ_ENTRY(kroute_priority)	 entry;
	struct kroute_prefix		*kp;		/* back pointer */
	uint8_t				 priority;
	TAILQ_HEAD(, kroute_node)	 nexthops;
};

struct kroute_prefix {
	RB_ENTRY(kroute_prefix)		 entry;
	int				 af;
	union ldpd_addr			 prefix;
	uint8_t				 prefixlen;
	TAILQ_HEAD(plist, kroute_priority) priorities;
};
RB_HEAD(kroute_tree, kroute_prefix);
RB_PROTOTYPE(kroute_tree, kroute_prefix, entry, kroute_compare)

struct kif_addr {
	TAILQ_ENTRY(kif_addr)	 entry;
	struct kaddr		 a;
};

struct kif_node {
	RB_ENTRY(kif_node)	 entry;
	TAILQ_HEAD(, kif_addr)	 addrs;
	struct kif		 k;
	struct kpw		*kpw;
};
RB_HEAD(kif_tree, kif_node);
RB_PROTOTYPE(kif_tree, kif_node, entry, kif_compare)

static void		 kr_dispatch_msg(int, short, void *);
static void		 kr_redist_remove(struct kroute *);
static int		 kr_redist_eval(struct kroute *);
static void		 kr_redistribute(struct kroute_prefix *);
static __inline int	 kroute_compare(struct kroute_prefix *,
			    struct kroute_prefix *);
static struct kroute_prefix	*kroute_find_prefix(int, union ldpd_addr *,
			    uint8_t);
static struct kroute_priority	*kroute_find_prio(struct kroute_prefix *,
			    uint8_t);
static struct kroute_node	*kroute_find_gw(struct kroute_priority *,
				    union ldpd_addr *);
static int		 kroute_insert(struct kroute *);
static int		 kroute_uninstall(struct kroute_node *);
static int		 kroute_remove(struct kroute *);
static void		 kroute_clear(void);
static __inline int	 kif_compare(struct kif_node *, struct kif_node *);
static struct kif_node	*kif_find(unsigned short);
static struct kif_node	*kif_insert(unsigned short);
static int		 kif_remove(struct kif_node *);
static struct kif_node	*kif_update(unsigned short, int, struct if_data *,
			    struct sockaddr_dl *, int *);
static struct kroute_priority	*kroute_match(int, union ldpd_addr *);
static uint8_t		 prefixlen_classful(in_addr_t);
static void		 get_rtaddrs(int, struct sockaddr *,
			    struct sockaddr **);
static void		 if_change(unsigned short, int, struct if_data *,
		 	   struct sockaddr_dl *);
static void		 if_newaddr(unsigned short, struct sockaddr *,
			    struct sockaddr *, struct sockaddr *);
static void		 if_deladdr(unsigned short, struct sockaddr *,
			    struct sockaddr *, struct sockaddr *);
static void		 if_announce(void *);
static int		 send_rtmsg(int, int, struct kroute *, int);
static int		 send_rtmsg_v4(int fd, int, struct kroute *, int);
static int		 send_rtmsg_v6(int fd, int, struct kroute *, int);
static int		 fetchtable(void);
static int		 fetchifs(void);
static int		 dispatch_rtmsg(void);
static int		 rtmsg_process(char *, size_t);
static int		 rtmsg_process_route(struct rt_msghdr *,
			    struct sockaddr *[RTAX_MAX]);
static int		 kmpw_install(const char *, struct kpw *);
static int		 kmpw_uninstall(const char *);

RB_GENERATE(kroute_tree, kroute_prefix, entry, kroute_compare)
RB_GENERATE(kif_tree, kif_node, entry, kif_compare)

static struct kroute_tree	 krt = RB_INITIALIZER(&krt);
static struct kif_tree		 kit = RB_INITIALIZER(&kit);

int
kif_init(void)
{
	if (fetchifs() == -1)
		return (-1);

	return (0);
}

int
kr_init(int fs, unsigned int rdomain)
{
	int		opt = 0, rcvbuf, default_rcvbuf;
	socklen_t	optlen;
	unsigned int	rtfilter;

	kr_state.fib_sync = fs;
	kr_state.rdomain = rdomain;

	if ((kr_state.fd = socket(AF_ROUTE,
	    SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK, 0)) == -1) {
		log_warn("%s: socket", __func__);
		return (-1);
	}

	/* not interested in my own messages */
	if (setsockopt(kr_state.fd, SOL_SOCKET, SO_USELOOPBACK,
	    &opt, sizeof(opt)) == -1)
		log_warn("%s: setsockopt(SO_USELOOPBACK)", __func__);

	/* filter out unwanted messages */
	rtfilter = ROUTE_FILTER(RTM_ADD) | ROUTE_FILTER(RTM_GET) |
	    ROUTE_FILTER(RTM_CHANGE) | ROUTE_FILTER(RTM_DELETE) |
	    ROUTE_FILTER(RTM_IFINFO) | ROUTE_FILTER(RTM_NEWADDR) |
	    ROUTE_FILTER(RTM_DELADDR) | ROUTE_FILTER(RTM_IFANNOUNCE);

	if (setsockopt(kr_state.fd, PF_ROUTE, ROUTE_MSGFILTER,
	    &rtfilter, sizeof(rtfilter)) == -1)
		log_warn("%s: setsockopt(ROUTE_MSGFILTER)", __func__);

	/* grow receive buffer, don't wanna miss messages */
	optlen = sizeof(default_rcvbuf);
	if (getsockopt(kr_state.fd, SOL_SOCKET, SO_RCVBUF,
	    &default_rcvbuf, &optlen) == -1)
		log_warn("%s: getsockopt SOL_SOCKET SO_RCVBUF", __func__);
	else
		for (rcvbuf = MAX_RTSOCK_BUF;
		    rcvbuf > default_rcvbuf &&
		    setsockopt(kr_state.fd, SOL_SOCKET, SO_RCVBUF,
		    &rcvbuf, sizeof(rcvbuf)) == -1 && errno == ENOBUFS;
		    rcvbuf /= 2)
			;	/* nothing */

	kr_state.pid = getpid();
	kr_state.rtseq = 1;

	if (fetchtable() == -1)
		return (-1);

	event_set(&kr_state.ev, kr_state.fd, EV_READ | EV_PERSIST,
	    kr_dispatch_msg, NULL);
	event_add(&kr_state.ev, NULL);

	if ((kr_state.ioctl_fd = socket(AF_INET,
	    SOCK_DGRAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0)) == -1) {
		log_warn("%s: ioctl socket", __func__);
		return (-1);
	}

	return (0);
}

void
kif_redistribute(const char *ifname)
{
	struct kif_node		*kif;
	struct kif_addr		*ka;

	RB_FOREACH(kif, kif_tree, &kit) {
		if (kif->k.rdomain != kr_state.rdomain)
			continue;

		if (ifname && strcmp(kif->k.ifname, ifname) != 0)
			continue;

		TAILQ_FOREACH(ka, &kif->addrs, entry)
			main_imsg_compose_ldpe(IMSG_NEWADDR, 0, &ka->a,
			    sizeof(ka->a));
	}
}

int
kr_change(struct kroute *kr)
{
	struct kroute_prefix	*kp;
	struct kroute_priority	*kprio;
	struct kroute_node	*kn;
	int			 action = RTM_ADD;

	kp = kroute_find_prefix(kr->af, &kr->prefix, kr->prefixlen);
	if (kp == NULL)
		goto miss;

	kprio = kroute_find_prio(kp, kr->priority);
	if (kprio == NULL)
		goto miss;

	kn = kroute_find_gw(kprio, &kr->nexthop);
	if (kn == NULL)
		goto miss;

	if (kn->r.flags & F_LDPD_INSERTED)
		action = RTM_CHANGE;

	kn->r.local_label = kr->local_label;
	kn->r.remote_label = kr->remote_label;
	kn->r.flags = kn->r.flags | F_LDPD_INSERTED;

	/* send update */
	if (send_rtmsg(kr_state.fd, action, &kn->r, AF_MPLS) == -1)
		return (-1);

	if (ldp_addrisset(kn->r.af, &kn->r.nexthop) &&
	    kn->r.remote_label != NO_LABEL) {
		if (send_rtmsg(kr_state.fd, RTM_CHANGE, &kn->r, AF_INET) == -1)
			return (-1);
	}

	return (0);

 miss:
	log_warnx("%s: lost FEC %s/%d nexthop %s", __func__,
	    log_addr(kr->af, &kr->prefix), kr->prefixlen,
	    log_addr(kr->af, &kr->nexthop));
	return (-1);
}

int
kr_delete(struct kroute *kr)
{
	struct kroute_prefix	*kp;
	struct kroute_priority	*kprio;
	struct kroute_node	*kn;
	int			 update = 0;

	kp = kroute_find_prefix(kr->af, &kr->prefix, kr->prefixlen);
	if (kp == NULL)
		return (0);
	kprio = kroute_find_prio(kp, kr->priority);
	if (kprio == NULL)
		return (0);
	kn = kroute_find_gw(kprio, &kr->nexthop);
	if (kn == NULL)
		return (0);

	if (!(kn->r.flags & F_LDPD_INSERTED))
		return (0);
	if (ldp_addrisset(kn->r.af, &kn->r.nexthop) &&
	    kn->r.remote_label != NO_LABEL)
		update = 1;

	/* kill MPLS LSP */
	if (send_rtmsg(kr_state.fd, RTM_DELETE, &kn->r, AF_MPLS) == -1)
		return (-1);

	kn->r.flags &= ~F_LDPD_INSERTED;
	kn->r.local_label = NO_LABEL;
	kn->r.remote_label = NO_LABEL;

	if (update &&
	    send_rtmsg(kr_state.fd, RTM_CHANGE, &kn->r, AF_INET) == -1)
		return (-1);

	return (0);
}

void
kr_shutdown(void)
{
	kr_fib_decouple();
	kroute_clear();
	kif_clear();
}

void
kr_fib_couple(void)
{
	struct kroute_prefix	*kp;
	struct kroute_priority	*kprio;
	struct kroute_node	*kn;
	struct kif_node		*kif;

	if (kr_state.fib_sync == 1)	/* already coupled */
		return;

	kr_state.fib_sync = 1;

	RB_FOREACH(kp, kroute_tree, &krt) {
		kprio = TAILQ_FIRST(&kp->priorities);
		if (kprio == NULL)
			continue;

		TAILQ_FOREACH(kn, &kprio->nexthops, entry) {
			if (!(kn->r.flags & F_LDPD_INSERTED))
				continue;

			send_rtmsg(kr_state.fd, RTM_ADD, &kn->r, AF_MPLS);

			if (ldp_addrisset(kn->r.af, &kn->r.nexthop) &&
			    kn->r.remote_label != NO_LABEL) {
				send_rtmsg(kr_state.fd, RTM_CHANGE,
				    &kn->r, AF_INET);
			}
		}
	}

	RB_FOREACH(kif, kif_tree, &kit)
		if (kif->kpw)
			kmpw_install(kif->k.ifname, kif->kpw);

	log_info("kernel routing table coupled");
}

void
kr_fib_decouple(void)
{
	struct kroute_prefix	*kp;
	struct kroute_priority	*kprio;
	struct kroute_node	*kn;
	uint32_t		 rl;
	struct kif_node		*kif;

	if (kr_state.fib_sync == 0)	/* already decoupled */
		return;

	RB_FOREACH(kp, kroute_tree, &krt) {
		kprio = TAILQ_FIRST(&kp->priorities);
		if (kprio == NULL)
			continue;

		TAILQ_FOREACH(kn, &kprio->nexthops, entry) {
			if (!(kn->r.flags & F_LDPD_INSERTED))
				continue;

			send_rtmsg(kr_state.fd, RTM_DELETE,
			    &kn->r, AF_MPLS);

			if (ldp_addrisset(kn->r.af, &kn->r.nexthop) &&
			    kn->r.remote_label != NO_LABEL) {
				rl = kn->r.remote_label;
				kn->r.remote_label = NO_LABEL;
				send_rtmsg(kr_state.fd, RTM_CHANGE,
				    &kn->r, AF_INET);
				kn->r.remote_label = rl;
			}
		}
	}

	RB_FOREACH(kif, kif_tree, &kit)
		if (kif->kpw)
			kmpw_uninstall(kif->k.ifname);

	kr_state.fib_sync = 0;
	log_info("kernel routing table decoupled");
}

void
kr_change_egress_label(int af, int was_implicit)
{
	struct kroute_prefix	*kp;
	struct kroute_priority	*kprio;
	struct kroute_node	*kn;

	RB_FOREACH(kp, kroute_tree, &krt) {
		if (kp->af != af)
			continue;

		TAILQ_FOREACH(kprio, &kp->priorities, entry) {
			TAILQ_FOREACH(kn, &kprio->nexthops, entry) {
				if (kn->r.local_label > MPLS_LABEL_RESERVED_MAX)
					continue;

				if (!was_implicit) {
					kn->r.local_label = MPLS_LABEL_IMPLNULL;
					continue;
				}

				switch (kn->r.af) {
				case AF_INET:
					kn->r.local_label = MPLS_LABEL_IPV4NULL;
					break;
				case AF_INET6:
					kn->r.local_label = MPLS_LABEL_IPV6NULL;
					break;
				default:
					break;
				}
			}
		}
	}
}

/* ARGSUSED */
static void
kr_dispatch_msg(int fd, short event, void *bula)
{
	if (dispatch_rtmsg() == -1)
		event_loopexit(NULL);
}

void
kr_show_route(struct imsg *imsg)
{
	struct kroute_prefix	*kp;
	struct kroute_priority	*kprio;
	struct kroute_node	*kn;
	int			 flags;
	struct kroute		 kr;

	switch (imsg->hdr.type) {
	case IMSG_CTL_KROUTE:
		if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(flags)) {
			log_warnx("%s: wrong imsg len", __func__);
			return;
		}
		memcpy(&flags, imsg->data, sizeof(flags));

		RB_FOREACH(kp, kroute_tree, &krt)
			TAILQ_FOREACH(kprio, &kp->priorities, entry)
				TAILQ_FOREACH(kn, &kprio->nexthops, entry) {
					if (flags && !(kn->r.flags & flags))
						continue;

					main_imsg_compose_ldpe(IMSG_CTL_KROUTE,
					    imsg->hdr.pid, &kn->r,
					    sizeof(kn->r));
				}
		break;
	case IMSG_CTL_KROUTE_ADDR:
		if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(kr)) {
			log_warnx("%s: wrong imsg len", __func__);
			return;
		}
		memcpy(&kr, imsg->data, sizeof(kr));

		kprio = kroute_match(kr.af, &kr.prefix);
		if (kprio == NULL)
			break;

		TAILQ_FOREACH(kn, &kprio->nexthops, entry)
			main_imsg_compose_ldpe(IMSG_CTL_KROUTE, imsg->hdr.pid,
			    &kn->r, sizeof(kn->r));
		break;
	default:
		log_debug("%s: error handling imsg", __func__);
		break;
	}
	main_imsg_compose_ldpe(IMSG_CTL_END, imsg->hdr.pid, NULL, 0);
}

void
kr_ifinfo(char *ifname, pid_t pid)
{
	struct kif_node	*kif;

	RB_FOREACH(kif, kif_tree, &kit)
		if (ifname == NULL || !strcmp(ifname, kif->k.ifname)) {
			main_imsg_compose_ldpe(IMSG_CTL_IFINFO,
			    pid, &kif->k, sizeof(kif->k));
		}

	main_imsg_compose_ldpe(IMSG_CTL_END, pid, NULL, 0);
}

static void
kr_redist_remove(struct kroute *kr)
{
	/* was the route redistributed? */
	if ((kr->flags & F_REDISTRIBUTED) == 0)
		return;

	/* remove redistributed flag */
	kr->flags &= ~F_REDISTRIBUTED;
	main_imsg_compose_lde(IMSG_NETWORK_DEL, 0, kr, sizeof(*kr));
}

static int
kr_redist_eval(struct kroute *kr)
{
	/* was the route redistributed? */
	if (kr->flags & F_REDISTRIBUTED)
		goto dont_redistribute;

	/* Dynamic routes are not redistributable. */
	if (kr->flags & F_DYNAMIC)
		goto dont_redistribute;

	/* filter-out non-redistributable addresses */
	if (bad_addr(kr->af, &kr->prefix) ||
	    (kr->af == AF_INET6 && IN6_IS_SCOPE_EMBED(&kr->prefix.v6)))
		goto dont_redistribute;

	/* do not redistribute the default route */
	if (kr->prefixlen == 0)
		goto dont_redistribute;

	/*
	 * Consider networks with nexthop loopback as not redistributable
	 * unless it is a reject or blackhole route.
	 */
	switch (kr->af) {
	case AF_INET:
		if (kr->nexthop.v4.s_addr == htonl(INADDR_LOOPBACK) &&
		    !(kr->flags & (F_BLACKHOLE|F_REJECT)))
			goto dont_redistribute;
		break;
	case AF_INET6:
		if (IN6_IS_ADDR_LOOPBACK(&kr->nexthop.v6) &&
		    !(kr->flags & (F_BLACKHOLE|F_REJECT)))
			goto dont_redistribute;
		break;
	default:
		log_debug("%s: unexpected address-family", __func__);
		break;
	}

	/* prefix should be redistributed */
	kr->flags |= F_REDISTRIBUTED;
	main_imsg_compose_lde(IMSG_NETWORK_ADD, 0, kr, sizeof(*kr));
	return (1);

 dont_redistribute:
	return (0);
}

static void
kr_redistribute(struct kroute_prefix *kp)
{
	struct kroute_priority	*kprio;
	struct kroute_node	*kn;

	TAILQ_FOREACH_REVERSE(kprio, &kp->priorities, plist, entry) {
		if (kprio == TAILQ_FIRST(&kp->priorities)) {
			TAILQ_FOREACH(kn, &kprio->nexthops, entry)
				kr_redist_eval(&kn->r);
		} else {
			TAILQ_FOREACH(kn, &kprio->nexthops, entry)
				kr_redist_remove(&kn->r);
		}
	}
}

/* rb-tree compare */
static __inline int
kroute_compare(struct kroute_prefix *a, struct kroute_prefix *b)
{
	int		 addrcmp;

	if (a->af < b->af)
		return (-1);
	if (a->af > b->af)
		return (1);

	addrcmp = ldp_addrcmp(a->af, &a->prefix, &b->prefix);
	if (addrcmp != 0)
		return (addrcmp);

	if (a->prefixlen < b->prefixlen)
		return (-1);
	if (a->prefixlen > b->prefixlen)
		return (1);

	return (0);
}

/* tree management */
static struct kroute_prefix *
kroute_find_prefix(int af, union ldpd_addr *prefix, uint8_t prefixlen)
{
	struct kroute_prefix	 s;

	s.af = af;
	s.prefix = *prefix;
	s.prefixlen = prefixlen;

	return (RB_FIND(kroute_tree, &krt, &s));
}

static struct kroute_priority *
kroute_find_prio(struct kroute_prefix *kp, uint8_t prio)
{
	struct kroute_priority	*kprio;

	/* RTP_ANY here picks the lowest priority node */
	if (prio == RTP_ANY)
		return (TAILQ_FIRST(&kp->priorities));

	TAILQ_FOREACH(kprio, &kp->priorities, entry)
		if (kprio->priority == prio)
			return (kprio);

	return (NULL);
}

static struct kroute_node *
kroute_find_gw(struct kroute_priority *kprio, union ldpd_addr *nh)
{
	struct kroute_node	*kn;

	TAILQ_FOREACH(kn, &kprio->nexthops, entry)
		if (ldp_addrcmp(kprio->kp->af, &kn->r.nexthop, nh) == 0)
			return (kn);

	return (NULL);
}

static int
kroute_insert(struct kroute *kr)
{
	struct kroute_prefix	*kp;
	struct kroute_priority	*kprio, *tmp;
	struct kroute_node	*kn;

	kp = kroute_find_prefix(kr->af, &kr->prefix, kr->prefixlen);
	if (kp == NULL) {
		kp = calloc(1, sizeof((*kp)));
		if (kp == NULL)
			fatal(__func__);
		kp->af = kr->af;
		kp->prefix = kr->prefix;
		kp->prefixlen = kr->prefixlen;
		TAILQ_INIT(&kp->priorities);
		RB_INSERT(kroute_tree, &krt, kp);
	}

	kprio = kroute_find_prio(kp, kr->priority);
	if (kprio == NULL) {
		kprio = calloc(1, sizeof(*kprio));
		if (kprio == NULL)
			fatal(__func__);
		kprio->kp = kp;
		kprio->priority = kr->priority;
		TAILQ_INIT(&kprio->nexthops);

		/* lower priorities first */
		TAILQ_FOREACH(tmp, &kp->priorities, entry)
			if (tmp->priority > kprio->priority)
				break;
		if (tmp)
			TAILQ_INSERT_BEFORE(tmp, kprio, entry);
		else
			TAILQ_INSERT_TAIL(&kp->priorities, kprio, entry);
	}

	kn = kroute_find_gw(kprio, &kr->nexthop);
	if (kn == NULL) {
		kn = calloc(1, sizeof(*kn));
		if (kn == NULL)
			fatal(__func__);
		kn->kprio = kprio;
		kn->r = *kr;
		TAILQ_INSERT_TAIL(&kprio->nexthops, kn, entry);
	}

	kr_redistribute(kp);
	return (0);
}

static int
kroute_uninstall(struct kroute_node *kn)
{
	/* kill MPLS LSP if one was installed */
	if (kn->r.flags & F_LDPD_INSERTED)
		if (send_rtmsg(kr_state.fd, RTM_DELETE, &kn->r, AF_MPLS) ==
		    -1)
			return (-1);

	return (0);
}

static int
kroute_remove(struct kroute *kr)
{
	struct kroute_prefix	*kp;
	struct kroute_priority	*kprio;
	struct kroute_node	*kn;

	kp = kroute_find_prefix(kr->af, &kr->prefix, kr->prefixlen);
	if (kp == NULL)
		goto notfound;
	kprio = kroute_find_prio(kp, kr->priority);
	if (kprio == NULL)
		goto notfound;
	kn = kroute_find_gw(kprio, &kr->nexthop);
	if (kn == NULL)
		goto notfound;

	kr_redist_remove(&kn->r);
	kroute_uninstall(kn);

	TAILQ_REMOVE(&kprio->nexthops, kn, entry);
	free(kn);

	if (TAILQ_EMPTY(&kprio->nexthops)) {
		TAILQ_REMOVE(&kp->priorities, kprio, entry);
		free(kprio);
	}

	if (TAILQ_EMPTY(&kp->priorities)) {
		if (RB_REMOVE(kroute_tree, &krt, kp) == NULL) {
			log_warnx("%s failed for %s/%u", __func__,
			    log_addr(kr->af, &kr->prefix), kp->prefixlen);
			return (-1);
		}
		free(kp);
	} else
		kr_redistribute(kp);

	return (0);

 notfound:
	log_warnx("%s failed to find %s/%u", __func__,
	    log_addr(kr->af, &kr->prefix), kr->prefixlen);
	return (-1);
}

static void
kroute_clear(void)
{
	struct kroute_prefix	*kp;
	struct kroute_priority	*kprio;
	struct kroute_node	*kn;

	while ((kp = RB_MIN(kroute_tree, &krt)) != NULL) {
		while ((kprio = TAILQ_FIRST(&kp->priorities)) != NULL) {
			while ((kn = TAILQ_FIRST(&kprio->nexthops)) != NULL) {
				kr_redist_remove(&kn->r);
				kroute_uninstall(kn);
				TAILQ_REMOVE(&kprio->nexthops, kn, entry);
				free(kn);
			}
			TAILQ_REMOVE(&kp->priorities, kprio, entry);
			free(kprio);
		}
		RB_REMOVE(kroute_tree, &krt, kp);
		free(kp);
	}
}

static __inline int
kif_compare(struct kif_node *a, struct kif_node *b)
{
	return (b->k.ifindex - a->k.ifindex);
}

/* tree management */
static struct kif_node *
kif_find(unsigned short ifindex)
{
	struct kif_node	s;

	memset(&s, 0, sizeof(s));
	s.k.ifindex = ifindex;

	return (RB_FIND(kif_tree, &kit, &s));
}

struct kif *
kif_findname(char *ifname)
{
	struct kif_node	*kif;

	RB_FOREACH(kif, kif_tree, &kit)
		if (!strcmp(ifname, kif->k.ifname))
			return (&kif->k);

	return (NULL);
}

static struct kif_node *
kif_insert(unsigned short ifindex)
{
	struct kif_node	*kif;

	if ((kif = calloc(1, sizeof(struct kif_node))) == NULL)
		return (NULL);

	kif->k.ifindex = ifindex;
	TAILQ_INIT(&kif->addrs);

	if (RB_INSERT(kif_tree, &kit, kif) != NULL)
		fatalx("kif_insert: RB_INSERT");

	return (kif);
}

static int
kif_remove(struct kif_node *kif)
{
	struct kif_addr	*ka;

	if (RB_REMOVE(kif_tree, &kit, kif) == NULL) {
		log_warnx("RB_REMOVE(kif_tree, &kit, kif)");
		return (-1);
	}

	while ((ka = TAILQ_FIRST(&kif->addrs)) != NULL) {
		main_imsg_compose_ldpe(IMSG_DELADDR, 0, &ka->a, sizeof(ka->a));
		TAILQ_REMOVE(&kif->addrs, ka, entry);
		free(ka);
	}
	free(kif);
	return (0);
}

void
kif_clear(void)
{
	struct kif_node	*kif;

	while ((kif = RB_MIN(kif_tree, &kit)) != NULL)
		kif_remove(kif);
}

static struct kif_node *
kif_update(unsigned short ifindex, int flags, struct if_data *ifd,
    struct sockaddr_dl *sdl, int *link_old)
{
	struct kif_node		*kif;

	if ((kif = kif_find(ifindex)) == NULL) {
		if ((kif = kif_insert(ifindex)) == NULL)
			return (NULL);
	} else
		*link_old = (kif->k.flags & IFF_UP) &&
		    LINK_STATE_IS_UP(kif->k.link_state);

	kif->k.flags = flags;
	kif->k.link_state = ifd->ifi_link_state;
	if (sdl)
		memcpy(kif->k.mac, LLADDR(sdl), sizeof(kif->k.mac));
	kif->k.if_type = ifd->ifi_type;
	kif->k.baudrate = ifd->ifi_baudrate;
	kif->k.mtu = ifd->ifi_mtu;
	kif->k.rdomain = ifd->ifi_rdomain;

	if (sdl && sdl->sdl_family == AF_LINK) {
		if (sdl->sdl_nlen >= sizeof(kif->k.ifname))
			memcpy(kif->k.ifname, sdl->sdl_data,
			    sizeof(kif->k.ifname) - 1);
		else if (sdl->sdl_nlen > 0)
			memcpy(kif->k.ifname, sdl->sdl_data,
			    sdl->sdl_nlen);
		/* string already terminated via calloc() */
	}

	return (kif);
}

static struct kroute_priority *
kroute_match(int af, union ldpd_addr *key)
{
	int			 i, maxprefixlen;
	struct kroute_prefix	*kp;
	struct kroute_priority	*kprio;
	union ldpd_addr		 addr;

	switch (af) {
	case AF_INET:
		maxprefixlen = 32;
		break;
	case AF_INET6:
		maxprefixlen = 128;
		break;
	default:
		log_warnx("%s: unknown af", __func__);
		return (NULL);
	}

	for (i = maxprefixlen; i >= 0; i--) {
		ldp_applymask(af, &addr, key, i);

		kp = kroute_find_prefix(af, &addr, i);
		if (kp == NULL)
			continue;

		kprio = kroute_find_prio(kp, RTP_ANY);
		if (kprio != NULL)
			return (kprio);
	}

	return (NULL);
}

/* misc */
static uint8_t
prefixlen_classful(in_addr_t ina)
{
	/* it hurt to write this. */

	if (ina >= 0xf0000000U)		/* class E */
		return (32);
	else if (ina >= 0xe0000000U)	/* class D */
		return (4);
	else if (ina >= 0xc0000000U)	/* class C */
		return (24);
	else if (ina >= 0x80000000U)	/* class B */
		return (16);
	else				/* class A */
		return (8);
}

#define	ROUNDUP(a)	\
    (((a) & (sizeof(long) - 1)) ? (1 + ((a) | (sizeof(long) - 1))) : (a))

static void
get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info)
{
	int	i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    ROUNDUP(sa->sa_len));
		} else
			rti_info[i] = NULL;
	}
}

static void
if_change(unsigned short ifindex, int flags, struct if_data *ifd,
    struct sockaddr_dl *sdl)
{
	struct kif_node		*kif;
	struct kif_addr		*ka;
	int			 link_old = 0, link_new;

	kif = kif_update(ifindex, flags, ifd, sdl, &link_old);
	if (!kif) {
		log_warn("%s: kif_update(%u)", __func__, ifindex);
		return;
	}
	link_new = (kif->k.flags & IFF_UP) &&
	    LINK_STATE_IS_UP(kif->k.link_state);

	if (link_new == link_old)
		return;

	main_imsg_compose_ldpe(IMSG_IFSTATUS, 0, &kif->k, sizeof(struct kif));
	if (link_new) {
		TAILQ_FOREACH(ka, &kif->addrs, entry)
			main_imsg_compose_ldpe(IMSG_NEWADDR, 0, &ka->a,
			    sizeof(ka->a));
	} else {
		TAILQ_FOREACH(ka, &kif->addrs, entry)
			main_imsg_compose_ldpe(IMSG_DELADDR, 0, &ka->a,
			    sizeof(ka->a));
	}
}

static void
if_newaddr(unsigned short ifindex, struct sockaddr *ifa, struct sockaddr *mask,
    struct sockaddr *brd)
{
	struct kif_node		*kif;
	struct sockaddr_in	*ifa4, *mask4, *brd4;
	struct sockaddr_in6	*ifa6, *mask6, *brd6;
	struct kif_addr		*ka;

	if (ifa == NULL)
		return;
	if ((kif = kif_find(ifindex)) == NULL) {
		log_warnx("%s: corresponding if %d not found", __func__,
		    ifindex);
		return;
	}

	switch (ifa->sa_family) {
	case AF_INET:
		ifa4 = (struct sockaddr_in *) ifa;
		mask4 = (struct sockaddr_in *) mask;
		brd4 = (struct sockaddr_in *) brd;

		/* filter out unwanted addresses */
		if (bad_addr_v4(ifa4->sin_addr))
			return;

		if ((ka = calloc(1, sizeof(struct kif_addr))) == NULL)
			fatal("if_newaddr");
		ka->a.addr.v4 = ifa4->sin_addr;
		if (mask4)
			ka->a.prefixlen =
			    mask2prefixlen(mask4->sin_addr.s_addr);
		if (brd4)
			ka->a.dstbrd.v4 = brd4->sin_addr;
		break;
	case AF_INET6:
		ifa6 = (struct sockaddr_in6 *) ifa;
		mask6 = (struct sockaddr_in6 *) mask;
		brd6 = (struct sockaddr_in6 *) brd;

		/* We only care about link-local and global-scope. */
		if (bad_addr_v6(&ifa6->sin6_addr))
			return;

		clearscope(&ifa6->sin6_addr);

		if ((ka = calloc(1, sizeof(struct kif_addr))) == NULL)
			fatal("if_newaddr");
		ka->a.addr.v6 = ifa6->sin6_addr;
		if (mask6)
			ka->a.prefixlen = mask2prefixlen6(mask6);
		if (brd6)
			ka->a.dstbrd.v6 = brd6->sin6_addr;
		break;
	default:
		return;
	}

	ka->a.ifindex = ifindex;
	ka->a.af = ifa->sa_family;
	TAILQ_INSERT_TAIL(&kif->addrs, ka, entry);

	/* notify ldpe about new address */
	main_imsg_compose_ldpe(IMSG_NEWADDR, 0, &ka->a, sizeof(ka->a));
}

static void
if_deladdr(unsigned short ifindex, struct sockaddr *ifa, struct sockaddr *mask,
    struct sockaddr *brd)
{
	struct kif_node		*kif;
	struct sockaddr_in	*ifa4, *mask4, *brd4;
	struct sockaddr_in6	*ifa6, *mask6, *brd6;
	struct kaddr		 k;
	struct kif_addr		*ka, *nka;

	if (ifa == NULL)
		return;
	if ((kif = kif_find(ifindex)) == NULL) {
		log_warnx("%s: corresponding if %d not found", __func__,
		    ifindex);
		return;
	}

	memset(&k, 0, sizeof(k));
	k.af = ifa->sa_family;
	switch (ifa->sa_family) {
	case AF_INET:
		ifa4 = (struct sockaddr_in *) ifa;
		mask4 = (struct sockaddr_in *) mask;
		brd4 = (struct sockaddr_in *) brd;

		/* filter out unwanted addresses */
		if (bad_addr_v4(ifa4->sin_addr))
			return;

		k.addr.v4 = ifa4->sin_addr;
		if (mask4)
			k.prefixlen = mask2prefixlen(mask4->sin_addr.s_addr);
		if (brd4)
			k.dstbrd.v4 = brd4->sin_addr;
		break;
	case AF_INET6:
		ifa6 = (struct sockaddr_in6 *) ifa;
		mask6 = (struct sockaddr_in6 *) mask;
		brd6 = (struct sockaddr_in6 *) brd;

		/* We only care about link-local and global-scope. */
		if (bad_addr_v6(&ifa6->sin6_addr))
			return;

		clearscope(&ifa6->sin6_addr);

		k.addr.v6 = ifa6->sin6_addr;
		if (mask6)
			k.prefixlen = mask2prefixlen6(mask6);
		if (brd6)
			k.dstbrd.v6 = brd6->sin6_addr;
		break;
	default:
		return;
	}

	for (ka = TAILQ_FIRST(&kif->addrs); ka != NULL; ka = nka) {
		nka = TAILQ_NEXT(ka, entry);

		if (ka->a.af != k.af ||
		    ka->a.prefixlen != k.prefixlen ||
		    ldp_addrcmp(ka->a.af, &ka->a.addr, &k.addr))
			continue;

		/* notify ldpe about removed address */
		main_imsg_compose_ldpe(IMSG_DELADDR, 0, &ka->a, sizeof(ka->a));
		TAILQ_REMOVE(&kif->addrs, ka, entry);
		free(ka);
		return;
	}
}

static void
if_announce(void *msg)
{
	struct if_announcemsghdr	*ifan;
	struct kif_node			*kif;

	ifan = msg;

	switch (ifan->ifan_what) {
	case IFAN_ARRIVAL:
		kif = kif_insert(ifan->ifan_index);
		if (kif)
			strlcpy(kif->k.ifname, ifan->ifan_name,
			    sizeof(kif->k.ifname));
		break;
	case IFAN_DEPARTURE:
		kif = kif_find(ifan->ifan_index);
		if (kif)
			kif_remove(kif);
		break;
	}
}

/* rtsock */
static int
send_rtmsg(int fd, int action, struct kroute *kr, int family)
{
	switch (kr->af) {
	case AF_INET:
		return (send_rtmsg_v4(fd, action, kr, family));
	case AF_INET6:
		return (send_rtmsg_v6(fd, action, kr, family));
	default:
		fatalx("send_rtmsg: unknown af");
	}
}

static int
send_rtmsg_v4(int fd, int action, struct kroute *kr, int family)
{
	struct iovec		iov[5];
	struct rt_msghdr	hdr;
	struct sockaddr_mpls	label_in, label_out;
	struct sockaddr_in	dst, mask, nexthop;
	int			iovcnt = 0;

	if (kr_state.fib_sync == 0)
		return (0);

	/*
	 * Reserved labels (implicit and explicit NULL) should not be added
	 * to the FIB.
	 */
	if (family == AF_MPLS && kr->local_label < MPLS_LABEL_RESERVED_MAX)
		return (0);

	/* initialize header */
	memset(&hdr, 0, sizeof(hdr));
	hdr.rtm_version = RTM_VERSION;

	hdr.rtm_type = action;
	hdr.rtm_flags = RTF_UP;
	hdr.rtm_fmask = RTF_MPLS;
	hdr.rtm_seq = kr_state.rtseq++;	/* overflow doesn't matter */
	hdr.rtm_msglen = sizeof(hdr);
	hdr.rtm_hdrlen = sizeof(struct rt_msghdr);
	hdr.rtm_priority = kr->priority;
	hdr.rtm_tableid = kr_state.rdomain;	/* rtableid */
	/* adjust iovec */
	iov[iovcnt].iov_base = &hdr;
	iov[iovcnt++].iov_len = sizeof(hdr);

	if (family == AF_MPLS) {
		memset(&label_in, 0, sizeof(label_in));
		label_in.smpls_len = sizeof(label_in);
		label_in.smpls_family = AF_MPLS;
		label_in.smpls_label =
		    htonl(kr->local_label << MPLS_LABEL_OFFSET);
		/* adjust header */
		hdr.rtm_flags |= RTF_MPLS | RTF_MPATH;
		hdr.rtm_addrs |= RTA_DST;
		hdr.rtm_msglen += sizeof(label_in);
		/* adjust iovec */
		iov[iovcnt].iov_base = &label_in;
		iov[iovcnt++].iov_len = sizeof(label_in);
	} else {
		memset(&dst, 0, sizeof(dst));
		dst.sin_len = sizeof(dst);
		dst.sin_family = AF_INET;
		dst.sin_addr = kr->prefix.v4;
		/* adjust header */
		hdr.rtm_addrs |= RTA_DST;
		hdr.rtm_msglen += sizeof(dst);
		/* adjust iovec */
		iov[iovcnt].iov_base = &dst;
		iov[iovcnt++].iov_len = sizeof(dst);
	}

	memset(&nexthop, 0, sizeof(nexthop));
	nexthop.sin_len = sizeof(nexthop);
	nexthop.sin_family = AF_INET;
	nexthop.sin_addr = kr->nexthop.v4;
	/* adjust header */
	hdr.rtm_flags |= RTF_GATEWAY;
	hdr.rtm_addrs |= RTA_GATEWAY;
	hdr.rtm_msglen += sizeof(nexthop);
	/* adjust iovec */
	iov[iovcnt].iov_base = &nexthop;
	iov[iovcnt++].iov_len = sizeof(nexthop);

	if (family == AF_INET) {
		memset(&mask, 0, sizeof(mask));
		mask.sin_len = sizeof(mask);
		mask.sin_family = AF_INET;
		mask.sin_addr.s_addr = prefixlen2mask(kr->prefixlen);
		/* adjust header */
		hdr.rtm_addrs |= RTA_NETMASK;
		hdr.rtm_msglen += sizeof(mask);
		/* adjust iovec */
		iov[iovcnt].iov_base = &mask;
		iov[iovcnt++].iov_len = sizeof(mask);
	}

	/* If action is RTM_DELETE we have to get rid of MPLS infos */
	if (kr->remote_label != NO_LABEL && action != RTM_DELETE) {
		memset(&label_out, 0, sizeof(label_out));
		label_out.smpls_len = sizeof(label_out);
		label_out.smpls_family = AF_MPLS;
		label_out.smpls_label =
		    htonl(kr->remote_label << MPLS_LABEL_OFFSET);
		/* adjust header */
		hdr.rtm_addrs |= RTA_SRC;
		hdr.rtm_flags |= RTF_MPLS;
		hdr.rtm_msglen += sizeof(label_out);
		/* adjust iovec */
		iov[iovcnt].iov_base = &label_out;
		iov[iovcnt++].iov_len = sizeof(label_out);

		if (kr->remote_label == MPLS_LABEL_IMPLNULL) {
			if (family == AF_MPLS)
				hdr.rtm_mpls = MPLS_OP_POP;
			else
				return (0);
		} else {
			if (family == AF_MPLS)
				hdr.rtm_mpls = MPLS_OP_SWAP;
			else
				hdr.rtm_mpls = MPLS_OP_PUSH;
		}
	}

 retry:
	if (writev(fd, iov, iovcnt) == -1) {
		if (errno == ESRCH) {
			if (hdr.rtm_type == RTM_CHANGE && family == AF_MPLS) {
				hdr.rtm_type = RTM_ADD;
				goto retry;
			} else if (hdr.rtm_type == RTM_DELETE) {
				log_info("route %s/%u vanished before delete",
				    inet_ntoa(kr->prefix.v4), kr->prefixlen);
				return (-1);
			}
		}
		log_warn("%s action %u, af %s, prefix %s/%u", __func__,
		    hdr.rtm_type, af_name(family), inet_ntoa(kr->prefix.v4),
		    kr->prefixlen);
		return (-1);
	}

	return (0);
}

static int
send_rtmsg_v6(int fd, int action, struct kroute *kr, int family)
{
	return (0);
}

static int
fetchtable(void)
{
	size_t			 len;
	int			 mib[7];
	char			*buf;
	int			 rv;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = 0;
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;
	mib[6] = kr_state.rdomain;	/* rtableid */

	if (sysctl(mib, 7, NULL, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		return (-1);
	}
	if ((buf = malloc(len)) == NULL) {
		log_warn(__func__);
		return (-1);
	}
	if (sysctl(mib, 7, buf, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		free(buf);
		return (-1);
	}

	rv = rtmsg_process(buf, len);
	free(buf);

	return (rv);
}

static int
fetchifs(void)
{
	size_t			 len;
	int			 mib[6];
	char			*buf;
	int			 rv;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = 0;	/* wildcard */
	mib[4] = NET_RT_IFLIST;
	mib[5] = 0;

	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		return (-1);
	}
	if ((buf = malloc(len)) == NULL) {
		log_warn(__func__);
		return (-1);
	}
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		free(buf);
		return (-1);
	}

	rv = rtmsg_process(buf, len);
	free(buf);

	return (rv);
}

static int
dispatch_rtmsg(void)
{
	char			 buf[RT_BUF_SIZE];
	ssize_t			 n;

	if ((n = read(kr_state.fd, &buf, sizeof(buf))) == -1) {
		if (errno == EAGAIN || errno == EINTR)
			return (0);
		log_warn("%s: read error", __func__);
		return (-1);
	}

	if (n == 0) {
		log_warnx("routing socket closed");
		return (-1);
	}

	return (rtmsg_process(buf, n));
}

static int
rtmsg_process(char *buf, size_t len)
{
	struct rt_msghdr	*rtm;
	struct if_msghdr	 ifm;
	struct ifa_msghdr	*ifam;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	size_t			 offset;
	char			*next;

	for (offset = 0; offset < len; offset += rtm->rtm_msglen) {
		next = buf + offset;
		rtm = (struct rt_msghdr *)next;
		if (len < offset + sizeof(unsigned short) ||
		    len < offset + rtm->rtm_msglen)
			fatalx("rtmsg_process: partial rtm in buffer");
		if (rtm->rtm_version != RTM_VERSION)
			continue;

		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

		switch (rtm->rtm_type) {
		case RTM_ADD:
		case RTM_GET:
		case RTM_CHANGE:
		case RTM_DELETE:
			if (rtm->rtm_errno)		/* failed attempts... */
				continue;

			if (rtm->rtm_tableid != kr_state.rdomain)
				continue;

			if (rtm->rtm_type == RTM_GET &&
			    rtm->rtm_pid != kr_state.pid)
				continue;

			/* Skip ARP/ND cache and broadcast routes. */
			if (rtm->rtm_flags & (RTF_LLINFO|RTF_BROADCAST))
				continue;

			/* LDP should follow the IGP and ignore BGP routes */
			if (rtm->rtm_priority == RTP_BGP)
				continue;

			if (rtmsg_process_route(rtm, rti_info) == -1)
				return (-1);
		}

		switch (rtm->rtm_type) {
		case RTM_IFINFO:
			memcpy(&ifm, next, sizeof(ifm));
			if_change(ifm.ifm_index, ifm.ifm_flags, &ifm.ifm_data,
			    (struct sockaddr_dl *)rti_info[RTAX_IFP]);
			break;
		case RTM_NEWADDR:
			ifam = (struct ifa_msghdr *)rtm;
			if ((ifam->ifam_addrs & (RTA_NETMASK | RTA_IFA |
			    RTA_BRD)) == 0)
				break;

			if_newaddr(ifam->ifam_index,
			    (struct sockaddr *)rti_info[RTAX_IFA],
			    (struct sockaddr *)rti_info[RTAX_NETMASK],
			    (struct sockaddr *)rti_info[RTAX_BRD]);
			break;
		case RTM_DELADDR:
			ifam = (struct ifa_msghdr *)rtm;
			if ((ifam->ifam_addrs & (RTA_NETMASK | RTA_IFA |
			    RTA_BRD)) == 0)
				break;

			if_deladdr(ifam->ifam_index,
			    (struct sockaddr *)rti_info[RTAX_IFA],
			    (struct sockaddr *)rti_info[RTAX_NETMASK],
			    (struct sockaddr *)rti_info[RTAX_BRD]);
			break;
		case RTM_IFANNOUNCE:
			if_announce(next);
			break;
		default:
			/* ignore for now */
			break;
		}
	}

	return (offset);
}

static int
rtmsg_process_route(struct rt_msghdr *rtm, struct sockaddr *rti_info[RTAX_MAX])
{
	struct sockaddr		*sa;
	struct sockaddr_in	*sa_in;
	struct sockaddr_in6	*sa_in6;
	struct kroute		 kr;
	struct kroute_prefix	*kp;
	struct kroute_priority	*kprio;
	struct kroute_node	*kn;

	if ((sa = rti_info[RTAX_DST]) == NULL)
		return (-1);

	memset(&kr, 0, sizeof(kr));
	kr.af = sa->sa_family;
	switch (kr.af) {
	case AF_INET:
		kr.prefix.v4 = ((struct sockaddr_in *)sa)->sin_addr;
		sa_in = (struct sockaddr_in *) rti_info[RTAX_NETMASK];
		if (sa_in != NULL && sa_in->sin_len != 0)
			kr.prefixlen = mask2prefixlen(sa_in->sin_addr.s_addr);
		else if (rtm->rtm_flags & RTF_HOST)
			kr.prefixlen = 32;
		else if (kr.prefix.v4.s_addr == INADDR_ANY)
			kr.prefixlen = 0;
		else
			kr.prefixlen = prefixlen_classful(kr.prefix.v4.s_addr);
		break;
	case AF_INET6:
		kr.prefix.v6 = ((struct sockaddr_in6 *)sa)->sin6_addr;
		sa_in6 = (struct sockaddr_in6 *)rti_info[RTAX_NETMASK];
		if (sa_in6 != NULL && sa_in6->sin6_len != 0)
			kr.prefixlen = mask2prefixlen6(sa_in6);
		else if (rtm->rtm_flags & RTF_HOST)
			kr.prefixlen = 128;
		else if (IN6_IS_ADDR_UNSPECIFIED(&kr.prefix.v6))
			kr.prefixlen = 0;
		else
			fatalx("in6 net addr without netmask");
		break;
	default:
		return (0);
	}
	kr.ifindex = rtm->rtm_index;
	if ((sa = rti_info[RTAX_GATEWAY]) != NULL) {
		switch (sa->sa_family) {
		case AF_INET:
			kr.nexthop.v4 = ((struct sockaddr_in *)sa)->sin_addr;
			break;
		case AF_INET6:
			sa_in6 = (struct sockaddr_in6 *)sa;
			recoverscope(sa_in6);
			kr.nexthop.v6 = sa_in6->sin6_addr;
			if (sa_in6->sin6_scope_id)
				kr.ifindex = sa_in6->sin6_scope_id;
			break;
		case AF_LINK:
			kr.flags |= F_CONNECTED;
			break;
		}
	}

	if (rtm->rtm_flags & RTF_STATIC)
		kr.flags |= F_STATIC;
	if (rtm->rtm_flags & RTF_BLACKHOLE)
		kr.flags |= F_BLACKHOLE;
	if (rtm->rtm_flags & RTF_REJECT)
		kr.flags |= F_REJECT;
	if (rtm->rtm_flags & RTF_DYNAMIC)
		kr.flags |= F_DYNAMIC;
	/* routes attached to connected or loopback interfaces */
	if (rtm->rtm_flags & RTF_CONNECTED ||
	    ldp_addrcmp(kr.af, &kr.prefix, &kr.nexthop) == 0)
		kr.flags |= F_CONNECTED;
	kr.priority = rtm->rtm_priority;

	if (rtm->rtm_type == RTM_CHANGE) {
		/*
		 * The kernel doesn't allow RTM_CHANGE for multipath routes.
		 * If we got this message we know that the route has only one
		 * nexthop and we should remove it before installing the same
		 * route with the new nexthop.
		 */
		kp = kroute_find_prefix(kr.af, &kr.prefix, kr.prefixlen);
		if (kp) {
			kprio = kroute_find_prio(kp, kr.priority);
			if (kprio) {
				kn = TAILQ_FIRST(&kprio->nexthops);
				if (kn)
					kroute_remove(&kn->r);
			}
		}
	}

	kn = NULL;
	kp = kroute_find_prefix(kr.af, &kr.prefix, kr.prefixlen);
	if (kp) {
		kprio = kroute_find_prio(kp, kr.priority);
		if (kprio)
			kn = kroute_find_gw(kprio, &kr.nexthop);
	}

	if (rtm->rtm_type == RTM_DELETE) {
		if (kn == NULL)
			return (0);
		return (kroute_remove(&kr));
	}

	if (!ldp_addrisset(kr.af, &kr.nexthop) && !(kr.flags & F_CONNECTED)) {
		log_warnx("%s: no nexthop for %s/%u", __func__,
		    log_addr(kr.af, &kr.prefix), kr.prefixlen);
		return (-1);
	}

	if (kn != NULL) {
		/* update route */
		kn->r = kr;
		kr_redistribute(kp);
	} else {
		kr.local_label = NO_LABEL;
		kr.remote_label = NO_LABEL;
		kroute_insert(&kr);
	}

	return (0);
}

int
kmpw_set(struct kpw *kpw)
{
	struct kif_node		*kif;

	kif = kif_find(kpw->ifindex);
	if (kif == NULL) {
		log_warnx("%s: failed to find mpw by index (%u)", __func__,
		    kpw->ifindex);
		return (-1);
	}

	if (kif->kpw == NULL)
		kif->kpw = malloc(sizeof(*kif->kpw));
	*kif->kpw = *kpw;

	return (kmpw_install(kif->k.ifname, kpw));
}

int
kmpw_unset(struct kpw *kpw)
{
	struct kif_node		*kif;

	kif = kif_find(kpw->ifindex);
	if (kif == NULL) {
		log_warnx("%s: failed to find mpw by index (%u)", __func__,
		    kpw->ifindex);
		return (-1);
	}

	if (kif->kpw == NULL) {
		log_warnx("%s: %s is not set", __func__, kif->k.ifname);
		return (-1);
	}

	free(kif->kpw);
	kif->kpw = NULL;
	return (kmpw_uninstall(kif->k.ifname));
}

static int
kmpw_install(const char *ifname, struct kpw *kpw)
{
	struct ifreq		 ifr;
	struct ifmpwreq		 imr;

	memset(&imr, 0, sizeof(imr));
	switch (kpw->pw_type) {
	case PW_TYPE_ETHERNET:
		imr.imr_type = IMR_TYPE_ETHERNET;
		break;
	case PW_TYPE_ETHERNET_TAGGED:
		imr.imr_type = IMR_TYPE_ETHERNET_TAGGED;
		break;
	default:
		log_warnx("%s: unhandled pseudowire type (%#X)", __func__,
		    kpw->pw_type);
		return (-1);
	}

	if (kpw->flags & F_PW_CWORD)
		imr.imr_flags |= IMR_FLAG_CONTROLWORD;

	memcpy(&imr.imr_nexthop, addr2sa(kpw->af, &kpw->nexthop, 0),
	    sizeof(imr.imr_nexthop));

	imr.imr_lshim.shim_label = kpw->local_label;
	imr.imr_rshim.shim_label = kpw->remote_label;

	memset(&ifr, 0, sizeof(ifr));
	strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
	ifr.ifr_data = (caddr_t) &imr;
	if (ioctl(kr_state.ioctl_fd, SIOCSETMPWCFG, &ifr)) {
		log_warn("ioctl SIOCSETMPWCFG");
		return (-1);
	}

	return (0);
}

static int
kmpw_uninstall(const char *ifname)
{
	struct ifreq		 ifr;
	struct ifmpwreq		 imr;

	memset(&ifr, 0, sizeof(ifr));
	memset(&imr, 0, sizeof(imr));
	strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
	ifr.ifr_data = (caddr_t) &imr;
	if (ioctl(kr_state.ioctl_fd, SIOCSETMPWCFG, &ifr)) {
		log_warn("ioctl SIOCSETMPWCFG");
		return (-1);
	}

	return (0);
}
@


1.64
log
@Minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.63 2017/03/03 23:36:06 renato Exp $ */
d28 1
d877 2
@


1.63
log
@Allow to run on a non-default rdomain.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.62 2017/01/20 12:19:18 benno Exp $ */
d267 1
a267 1
miss:
d568 1
a568 1
dont_redistribute:
d757 1
a757 1
notfound:
d1287 1
a1287 1
retry:
@


1.62
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

removal of log_rtmsg() aproved by claudio@@

ok claudio@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.61 2016/06/18 01:25:53 renato Exp $ */
d46 1
d147 1
a147 1
kr_init(int fs)
d154 1
d216 3
d879 1
d1203 1
d1328 1
a1328 1
	mib[6] = 0;	/* rtableid */
d1436 1
a1436 1
			if (rtm->rtm_tableid != 0)
@


1.61
log
@Fix small LIB<->LFIB synchronization issue.

ldpd operates only with the best routes of each IP prefix. In other words,
the routes with the lowest priorities.

When a route with a better priority is detected (possibly with a different
nexthop), we should uninstall the labels from the "old" routes and try
to install a new label for the new route (if there's one available in
the LIB).

In this specific case, ldpd was failing to uninstall the labels from the
old routes because it wasn't keeping track of each route's priority in
lde. With this missing bit of information, the parent process had no way
to get the correct label to uninstall when processing a IMSG_KLABEL_DELETE
message.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.60 2016/05/23 19:14:03 renato Exp $ */
a1416 1
		log_rtmsg(rtm->rtm_type);
@


1.60
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.59 2016/05/23 19:11:42 renato Exp $ */
d235 1
a235 1
	kprio = kroute_find_prio(kp, RTP_ANY);
d280 1
a280 1
	kprio = kroute_find_prio(kp, RTP_ANY);
@


1.59
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.58 2016/05/23 19:09:25 renato Exp $ */
d4 1
@


1.58
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.57 2016/05/23 18:58:48 renato Exp $ */
a24 3
#include <sys/tree.h>
#include <sys/uio.h>
#include <netinet/in.h>
a25 1
#include <net/if.h>
a26 1
#include <net/if_types.h>
a28 1
#include <err.h>
a29 2
#include <fcntl.h>
#include <stdio.h>
@


1.57
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.56 2016/05/23 18:55:21 renato Exp $ */
d75 2
d89 2
d92 5
a96 4
void			 kr_redist_remove(struct kroute *);
int			 kr_redist_eval(struct kroute *);
void			 kr_redistribute(struct kroute_prefix *);
int			 kroute_compare(struct kroute_prefix *,
d98 15
a112 16

struct kroute_prefix	*kroute_find_prefix(int, union ldpd_addr *, uint8_t);
struct kroute_priority	*kroute_find_prio(struct kroute_prefix *, uint8_t);
struct kroute_node	*kroute_find_gw(struct kroute_priority *,
			    union ldpd_addr *);

int			 kroute_insert(struct kroute *);
int			 kroute_uninstall(struct kroute_node *);
int			 kroute_remove(struct kroute *);
void			 kroute_clear(void);

int			 kif_compare(struct kif_node *, struct kif_node *);
struct kif_node		*kif_find(unsigned short);
struct kif_node		*kif_insert(unsigned short);
int			 kif_remove(struct kif_node *);
struct kif_node		*kif_update(unsigned short, int, struct if_data *,
d114 22
a136 24
struct kroute_priority	*kroute_match(int, union ldpd_addr *);

uint8_t		prefixlen_classful(in_addr_t);
void		get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
void		if_change(unsigned short, int, struct if_data *,
		    struct sockaddr_dl *);
void		if_newaddr(unsigned short, struct sockaddr *, struct sockaddr *,
		    struct sockaddr *);
void		if_deladdr(unsigned short, struct sockaddr *, struct sockaddr *,
		    struct sockaddr *);
void		if_announce(void *);

int		send_rtmsg(int, int, struct kroute *, int);
int		send_rtmsg_v4(int, int, struct kroute *, int);
int		send_rtmsg_v6(int, int, struct kroute *, int);
int		dispatch_rtmsg(void);
int		fetchtable(void);
int		fetchifs(void);
int		rtmsg_process(char *, size_t);
int		rtmsg_process_route(struct rt_msghdr *,
		    struct sockaddr *[RTAX_MAX]);

RB_HEAD(kroute_tree, kroute_prefix)	krt = RB_INITIALIZER(&krt);
RB_PROTOTYPE(kroute_tree, kroute_prefix, entry, kroute_compare)
d138 1
d140 2
a141 3
RB_HEAD(kif_tree, kif_node)		kit = RB_INITIALIZER(&kit);
RB_PROTOTYPE(kif_tree, kif_node, entry, kif_compare)
RB_GENERATE(kif_tree, kif_node, entry, kif_compare)
d442 1
a442 1
void
d513 1
a513 1
void
d525 1
a525 1
int
d574 1
a574 1
void
d592 1
a592 1
int
d615 1
a615 1
struct kroute_prefix *
d627 1
a627 1
struct kroute_priority *
d643 1
a643 1
struct kroute_node *
d655 1
a655 1
int
d707 1
a707 1
int
d719 1
a719 1
int
d765 1
a765 1
void
d788 1
a788 1
int
d795 1
a795 1
struct kif_node *
d818 1
a818 1
struct kif_node *
d835 1
a835 1
int
d863 1
a863 1
struct kif_node *
d895 1
a895 1
struct kroute_priority *
d931 1
a931 1
uint8_t
d951 1
a951 1
void
d966 1
a966 1
void
d997 1
a997 1
void
d1064 1
a1064 1
void
d1137 1
a1137 1
void
d1161 1
a1161 1
int
d1174 1
a1174 1
int
d1308 1
a1308 1
int
d1314 1
a1314 1
int
d1350 1
a1350 1
int
d1385 1
a1385 1
int
d1406 1
a1406 1
int
d1496 1
a1496 1
int
d1665 1
a1665 1
int
d1705 1
a1705 1
int
@


1.56
log
@Assorted fixes and small cleanup.

Nothing really interesting here.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.55 2016/05/23 18:40:15 renato Exp $ */
d70 2
a71 1
	struct in_addr			 prefix;
d88 11
a98 9
void	kr_redist_remove(struct kroute *);
int	kr_redist_eval(struct kroute *);
void	kr_redistribute(struct kroute_prefix *);
int	kroute_compare(struct kroute_prefix *, struct kroute_prefix *);

struct kroute_prefix	*kroute_find(in_addr_t, uint8_t);
struct kroute_priority	*kroute_find_prio(in_addr_t, uint8_t, uint8_t);
struct kroute_node	*kroute_find_gw(in_addr_t, uint8_t, uint8_t,
			    struct in_addr);
d111 1
a111 1
struct kroute_priority	*kroute_match(in_addr_t);
d117 4
a120 4
void		if_newaddr(unsigned short, struct sockaddr_in *,
		    struct sockaddr_in *, struct sockaddr_in *);
void		if_deladdr(unsigned short, struct sockaddr_in *,
		    struct sockaddr_in *, struct sockaddr_in *);
d123 3
a125 1
int		send_rtmsg(int, int, struct kroute *, uint32_t);
d130 2
d229 1
a229 1
kr_change(struct kroute *kroute)
d231 2
a234 1
	char			 buf[16];
d236 11
a246 8
	kn = kroute_find_gw(kroute->prefix.s_addr, kroute->prefixlen,
	    RTP_ANY, kroute->nexthop);
	if (kn == NULL) {
		log_warnx("%s: lost FEC %s/%d nexthop %s", __func__,
		    inet_ntoa(kroute->prefix), kroute->prefixlen,
		    inet_ntop(AF_INET, &kroute->nexthop, buf, sizeof(buf)));
		return (-1);
	}
d251 2
a252 2
	kn->r.local_label = kroute->local_label;
	kn->r.remote_label = kroute->remote_label;
d259 1
a259 1
	if (kn->r.nexthop.s_addr != INADDR_ANY &&
d266 6
d275 1
a275 1
kr_delete(struct kroute *kroute)
d277 2
d282 7
a288 2
	kn = kroute_find_gw(kroute->prefix.s_addr, kroute->prefixlen,
	    RTP_ANY, kroute->nexthop);
d294 1
a294 1
	if (kn->r.nexthop.s_addr != INADDR_ANY &&
d345 1
a345 1
			if (kn->r.nexthop.s_addr != INADDR_ANY &&
d384 1
a384 1
			if (kn->r.nexthop.s_addr != INADDR_ANY &&
d404 1
a404 1
kr_change_egress_label(int was_implicit)
d411 3
d419 1
a419 1
				if (!was_implicit)
d421 5
a425 1
				else
d427 7
d454 1
a454 1
	struct in_addr		 addr;
d467 6
a472 5
					if (!flags || kn->r.flags & flags)
						main_imsg_compose_ldpe(
						    IMSG_CTL_KROUTE,
						    imsg->hdr.pid,
						    &kn->r, sizeof(kn->r));
d476 1
a476 2
		if (imsg->hdr.len != IMSG_HEADER_SIZE +
		    sizeof(struct in_addr)) {
d480 5
a484 1
		memcpy(&addr, imsg->data, sizeof(addr));
a485 1
		kprio = kroute_match(addr.s_addr);
a525 2
	uint32_t	 a;

d534 7
a540 8
	/*
	 * We consider the loopback net, default route, multicast and
	 * experimental addresses as not redistributable.
	 */
	a = ntohl(kr->prefix.s_addr);
	if (IN_MULTICAST(a) || IN_BADCLASS(a) ||
	    (kr->prefixlen == 0) ||
	    (a >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET)
d542 1
d547 15
a561 3
	if (kr->nexthop.s_addr == htonl(INADDR_LOOPBACK) &&
	    !(kr->flags & (F_BLACKHOLE|F_REJECT)))
		goto dont_redistribute;
d593 3
a595 1
	if (ntohl(a->prefix.s_addr) < ntohl(b->prefix.s_addr))
d597 1
a597 1
	if (ntohl(a->prefix.s_addr) > ntohl(b->prefix.s_addr))
d599 5
d614 1
a614 1
kroute_find(in_addr_t prefix, uint8_t prefixlen)
d618 2
a619 1
	s.prefix.s_addr = prefix;
d626 1
a626 1
kroute_find_prio(in_addr_t prefix, uint8_t prefixlen, uint8_t prio)
a627 1
	struct kroute_prefix	*kp;
a629 3
	if ((kp = kroute_find(prefix, prefixlen)) == NULL)
		return (NULL);

d642 1
a642 2
kroute_find_gw(in_addr_t prefix, uint8_t prefixlen, uint8_t prio,
    struct in_addr nh)
a643 1
	struct kroute_priority	*kprio;
a645 3
	if ((kprio = kroute_find_prio(prefix, prefixlen, prio)) == NULL)
		return (NULL);

d647 1
a647 1
		if (kn->r.nexthop.s_addr == nh.s_addr)
d657 1
a657 1
	struct kroute_priority	*kprio, *tmp = NULL;
d660 1
a660 1
	kp = kroute_find(kr->prefix.s_addr, kr->prefixlen);
d662 1
a662 1
		kp = calloc(1, sizeof(struct kroute_prefix));
d665 1
d672 1
a672 2
	kprio = kroute_find_prio(kr->prefix.s_addr, kr->prefixlen,
	    kr->priority);
d674 1
a674 1
		kprio = calloc(1, sizeof(struct kroute_priority));
d682 7
a688 7
		TAILQ_FOREACH(tmp, &kp->priorities, entry) {
			if (tmp->priority > kr->priority) {
				TAILQ_INSERT_BEFORE(tmp, kprio, entry);
				goto done;
			}
		}
		TAILQ_INSERT_TAIL(&kp->priorities, kprio, entry);
d691 1
a691 3
done:
	kn = kroute_find_gw(kr->prefix.s_addr, kr->prefixlen, kr->priority,
	    kr->nexthop);
d693 1
a693 1
		kn = calloc(1, sizeof(struct kroute_node));
d724 9
a732 9
	kn = kroute_find_gw(kr->prefix.s_addr, kr->prefixlen, kr->priority,
	    kr->nexthop);
	if (kn == NULL) {
		log_warnx("%s failed to find %s/%u", __func__,
		    inet_ntoa(kr->prefix), kr->prefixlen);
		return (-1);
	}
	kprio = kn->kprio;
	kp = kprio->kp;
d748 1
a748 1
			    inet_ntoa(kp->prefix), kp->prefixlen);
d756 5
d894 1
a894 1
kroute_match(in_addr_t key)
d896 2
a897 1
	int			 i;
d899 20
d920 2
a921 4
	/* we will never match the default route */
	for (i = 32; i > 0; i--)
		if ((kprio = kroute_find_prio(key & prefixlen2mask(i), i,
		    RTP_ANY)) != NULL)
d923 1
a923 4

	/* if we don't have a match yet, try to find a default route */
	if ((kprio = kroute_find_prio(0, 0, RTP_ANY)) != NULL)
		return (kprio);
d996 2
a997 2
if_newaddr(unsigned short ifindex, struct sockaddr_in *ifa,
    struct sockaddr_in *mask, struct sockaddr_in *brd)
d999 4
a1002 3
	struct kif_node *kif;
	struct kif_addr *ka;
	uint32_t	 a;
d1004 1
a1004 1
	if (ifa == NULL || ifa->sin_family != AF_INET)
d1011 40
a1050 3
	a = ntohl(ifa->sin_addr.s_addr);
	if (IN_MULTICAST(a) || IN_BADCLASS(a) ||
	    (a >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET)
d1052 1
a1053 2
	if ((ka = calloc(1, sizeof(struct kif_addr))) == NULL)
		fatal(__func__);
d1055 1
a1055 10
	ka->a.addr = ifa->sin_addr;
	if (mask)
		ka->a.mask = mask->sin_addr;
	else
		ka->a.mask.s_addr = INADDR_NONE;
	if (brd)
		ka->a.dstbrd = brd->sin_addr;
	else
		ka->a.dstbrd.s_addr = INADDR_NONE;

d1063 2
a1064 2
if_deladdr(unsigned short ifindex, struct sockaddr_in *ifa,
    struct sockaddr_in *mask, struct sockaddr_in *brd)
d1066 5
a1070 2
	struct kif_node *kif;
	struct kif_addr *ka, *nka;
d1072 1
a1072 1
	if (ifa == NULL || ifa->sin_family != AF_INET)
d1080 39
d1122 3
a1124 1
		if (ka->a.addr.s_addr != ifa->sin_addr.s_addr)
d1160 14
a1173 1
send_rtmsg(int fd, int action, struct kroute *kr, uint32_t family)
d1223 1
a1223 1
		dst.sin_addr = kr->prefix;
d1235 1
a1235 1
	nexthop.sin_addr = kr->nexthop;
d1293 1
a1293 1
				    inet_ntoa(kr->prefix), kr->prefixlen);
d1297 3
a1299 2
		log_warn("%s action %u, AF %d, prefix %s/%u", __func__,
		    hdr.rtm_type, family, inet_ntoa(kr->prefix), kr->prefixlen);
d1307 6
d1323 1
a1323 1
	mib[3] = AF_INET;
d1359 1
a1359 1
	mib[3] = AF_INET;
a1410 8
	struct sockaddr_in	*sa_in;
	struct kroute_priority	*kprio;
	struct kroute_node	*kn;
	struct kroute		 kr;
	struct in_addr		 prefix, nexthop;
	uint8_t			 prefixlen, prio;
	int			 flags;
	unsigned short		 ifindex = 0;
a1423 6
		prefix.s_addr = 0;
		prefixlen = 0;
		nexthop.s_addr = 0;
		prio = 0;
		flags = 0;

a1441 3
			if ((sa = rti_info[RTAX_DST]) == NULL)
				continue;

a1448 1
			prio = rtm->rtm_priority;
d1450 1
a1450 65
			switch (sa->sa_family) {
			case AF_INET:
				prefix = ((struct sockaddr_in *)sa)->sin_addr;
				sa_in = (struct sockaddr_in *)
				    rti_info[RTAX_NETMASK];
				if (sa_in != NULL) {
					if (sa_in->sin_len != 0)
						prefixlen = mask2prefixlen(
						    sa_in->sin_addr.s_addr);
				} else if (rtm->rtm_flags & RTF_HOST)
					prefixlen = 32;
				else
					prefixlen =
					    prefixlen_classful(prefix.s_addr);
				if (rtm->rtm_flags & RTF_STATIC)
					flags |= F_STATIC;
				if (rtm->rtm_flags & RTF_BLACKHOLE)
					flags |= F_BLACKHOLE;
				if (rtm->rtm_flags & RTF_REJECT)
					flags |= F_REJECT;
				if (rtm->rtm_flags & RTF_DYNAMIC)
					flags |= F_DYNAMIC;
				break;
			default:
				continue;
			}

			ifindex = rtm->rtm_index;
			if ((sa = rti_info[RTAX_GATEWAY]) != NULL) {
				switch (sa->sa_family) {
				case AF_INET:
					if (rtm->rtm_flags & RTF_CONNECTED) {
						flags |= F_CONNECTED;
						break;
					}
					nexthop = ((struct
					    sockaddr_in *)sa)->sin_addr;
					break;
				case AF_LINK:
					/*
					 * Traditional BSD connected routes have
					 * a gateway of type AF_LINK.
					 */
					flags |= F_CONNECTED;
					break;
				}
			}
		}

		switch (rtm->rtm_type) {
		case RTM_CHANGE:
			/*
			 * The kernel doesn't allow RTM_CHANGE for multipath
			 * routes. If we got this message we know that the
			 * route has only one nexthop and we should remove
			 * it before installing the same route with a new
			 * nexthop.
			 */
			if ((kprio = kroute_find_prio(prefix.s_addr,
			    prefixlen, prio)) == NULL) {
				log_warnx("%s: route not found", __func__);
				return (-1);
			}
			kn = TAILQ_FIRST(&kprio->nexthops);
			if (kn && kroute_remove(&kn->r) == -1)
a1451 3
			break;
		default:
			break;
a1454 38
		case RTM_ADD:
		case RTM_GET:
		case RTM_CHANGE:
			if (nexthop.s_addr == 0 && !(flags & F_CONNECTED)) {
				log_warnx("no nexthop for %s/%u",
				    inet_ntoa(prefix), prefixlen);
				continue;
			}

			/* routes attached to loopback interfaces */
			if (prefix.s_addr == nexthop.s_addr)
				flags |= F_CONNECTED;

			if (kroute_find_gw(prefix.s_addr, prefixlen, prio,
			    nexthop) != NULL)
				break;

			memset(&kr, 0, sizeof(kr));
			kr.prefix = prefix;
			kr.prefixlen = prefixlen;
			kr.nexthop = nexthop;
			kr.flags = flags;
			kr.ifindex = ifindex;
			kr.priority = prio;
			kr.local_label = NO_LABEL;
			kr.remote_label = NO_LABEL;
			kroute_insert(&kr);
			break;
		case RTM_DELETE:
			/* get the correct route */
			if ((kn = kroute_find_gw(prefix.s_addr, prefixlen,
			    prio, nexthop)) == NULL) {
				log_warnx("%s: route not found", __func__);
				return (-1);
			}
			if (kroute_remove(&kn->r) == -1)
				return (-1);
			break;
d1467 3
a1469 3
			    (struct sockaddr_in *)rti_info[RTAX_IFA],
			    (struct sockaddr_in *)rti_info[RTAX_NETMASK],
			    (struct sockaddr_in *)rti_info[RTAX_BRD]);
d1478 3
a1480 3
			    (struct sockaddr_in *)rti_info[RTAX_IFA],
			    (struct sockaddr_in *)rti_info[RTAX_NETMASK],
			    (struct sockaddr_in *)rti_info[RTAX_BRD]);
d1495 128
a1665 1
	struct sockaddr_in	*sin;
d1686 2
a1687 4
	sin = (struct sockaddr_in *) &imr.imr_nexthop;
	sin->sin_family = AF_INET;
	sin->sin_addr = kpw->nexthop;
	sin->sin_len = sizeof(struct sockaddr_in);
@


1.55
log
@Several fixes in the config reload handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.54 2016/05/23 18:28:22 renato Exp $ */
d69 4
a72 4
	RB_ENTRY(kroute_prefix)			 entry;
	struct in_addr				 prefix;
	uint8_t					 prefixlen;
	TAILQ_HEAD(plist, kroute_priority)	 priorities;
d77 1
a77 1
	struct kaddr		 addr;
a90 1
int	kif_compare(struct kif_node *, struct kif_node *);
d101 1
d123 1
a123 1
int		fetchifs(unsigned short);
d126 1
a126 1
RB_HEAD(kroute_tree, kroute_prefix)	krt;
d130 1
a130 1
RB_HEAD(kif_tree, kif_node)		kit;
d137 1
a137 6
	RB_INIT(&kit);
	/* init also krt tree so that we can call kr_shutdown() */
	RB_INIT(&krt);
	kr_state.fib_sync = 0;	/* decoupled */

	if (fetchifs(0) == -1)
a142 16
void
kif_redistribute(const char *ifname)
{
	struct kif_node		*kif;
	struct kif_addr		*ka;

	RB_FOREACH(kif, kif_tree, &kit) {
		if (ifname && strcmp(kif->k.ifname, ifname) != 0)
			continue;

		TAILQ_FOREACH(ka, &kif->addrs, entry)
			main_imsg_compose_ldpe(IMSG_NEWADDR, 0, &ka->addr,
			    sizeof(struct kaddr));
	}
}

d205 16
d254 1
a254 1
	return  (0);
a292 1

d373 1
a373 1
			kmpw_uninstall(kif->k.ifname, kif->kpw);
d405 2
a406 1
	dispatch_rtmsg();
d479 1
a479 2
	main_imsg_compose_lde(IMSG_NETWORK_DEL, 0, kr,
	    sizeof(struct kroute));
d514 1
a514 1
	main_imsg_compose_lde(IMSG_NETWORK_ADD, 0, kr, sizeof(struct kroute));
d518 1
a518 1
	return (1);
a553 6
int
kif_compare(struct kif_node *a, struct kif_node *b)
{
	return (b->k.ifindex - a->k.ifindex);
}

d733 7
d791 1
a876 18
uint8_t
mask2prefixlen(in_addr_t ina)
{
	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
}

in_addr_t
prefixlen2mask(uint8_t prefixlen)
{
	if (prefixlen == 0)
		return (0);

	return (htonl(0xffffffff << (32 - prefixlen)));
}

d914 1
a915 2
		main_imsg_compose_ldpe(IMSG_IFSTATUS, 0, &kif->k,
		    sizeof(struct kif));
d917 2
a918 2
			main_imsg_compose_ldpe(IMSG_NEWADDR, 0, &ka->addr,
			    sizeof(struct kaddr));
a919 2
		main_imsg_compose_ldpe(IMSG_IFSTATUS, 0, &kif->k,
		    sizeof(struct kif));
d921 2
a922 2
			main_imsg_compose_ldpe(IMSG_DELADDR, 0, &ka->addr,
			    sizeof(struct kaddr));
d948 2
a949 2
	ka->addr.ifindex = ifindex;
	ka->addr.addr = ifa->sin_addr;
d951 1
a951 1
		ka->addr.mask = mask->sin_addr;
d953 1
a953 1
		ka->addr.mask.s_addr = INADDR_NONE;
d955 1
a955 1
		ka->addr.dstbrd = brd->sin_addr;
d957 1
a957 1
		ka->addr.dstbrd.s_addr = INADDR_NONE;
d962 1
a962 2
	main_imsg_compose_ldpe(IMSG_NEWADDR, 0, &ka->addr,
	    sizeof(struct kaddr));
d983 2
a984 2
		if (ka->addr.addr.s_addr == ifa->sin_addr.s_addr) {
			TAILQ_REMOVE(&kif->addrs, ka, entry);
d986 5
a990 7
			/* notify ldpe about removed address */
			main_imsg_compose_ldpe(IMSG_DELADDR, 0, &ka->addr,
			    sizeof(struct kaddr));

			free(ka);
			return;
		}
d1005 3
a1007 1
		strlcpy(kif->k.ifname, ifan->ifan_name, sizeof(kif->k.ifname));
d1011 2
a1012 1
		kif_remove(kif);
d1019 1
a1019 1
send_rtmsg(int fd, int action, struct kroute *kroute, uint32_t family)
d1034 1
a1034 1
	if (family == AF_MPLS && kroute->local_label < MPLS_LABEL_RESERVED_MAX)
d1047 1
a1047 1
	hdr.rtm_priority = kroute->priority;
d1057 1
a1057 1
		    htonl(kroute->local_label << MPLS_LABEL_OFFSET);
d1069 1
a1069 1
		dst.sin_addr = kroute->prefix;
d1081 1
a1081 1
	nexthop.sin_addr = kroute->nexthop;
d1094 1
a1094 1
		mask.sin_addr.s_addr = prefixlen2mask(kroute->prefixlen);
d1104 1
a1104 1
	if (kroute->remote_label != NO_LABEL && action != RTM_DELETE) {
d1109 1
a1109 1
		    htonl(kroute->remote_label << MPLS_LABEL_OFFSET);
d1118 1
a1118 1
		if (kroute->remote_label == MPLS_LABEL_IMPLNULL) {
d1139 2
a1140 3
				    inet_ntoa(kroute->prefix),
				    kroute->prefixlen);
				return (0);
d1144 2
a1145 3
		    hdr.rtm_type, family, inet_ntoa(kroute->prefix),
		    kroute->prefixlen);
		return (0);
d1188 1
a1188 1
fetchifs(unsigned short ifindex)
d1200 1
a1200 1
	mib[5] = ifindex;
d1456 1
a1456 1
void
d1465 1
a1465 1
		return;
d1472 1
a1472 1
	kmpw_install(kif->k.ifname, kpw);
d1475 1
a1475 1
void
d1484 1
a1484 1
		return;
d1489 1
a1489 1
		return;
d1494 1
a1494 1
	kmpw_uninstall(kif->k.ifname, kpw);
d1497 1
a1497 1
void
d1515 1
a1515 1
		return;
d1532 6
a1537 2
	if (ioctl(kr_state.ioctl_fd, SIOCSETMPWCFG, &ifr))
		log_warn("ioctl SETMPWCFG");
d1540 2
a1541 2
void
kmpw_uninstall(const char *ifname, struct kpw *kpw)
d1546 1
a1547 1
	memset(&ifr, 0, sizeof(ifr));
d1550 6
a1555 2
	if (ioctl(kr_state.ioctl_fd, SIOCSETMPWCFG, &ifr))
		log_warn("ioctl SETMPWCFG");
@


1.54
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).

In addition, copy in_addr structs directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.53 2016/05/23 17:43:42 renato Exp $ */
d149 1
a149 1
kif_redistribute(void)
d155 3
@


1.53
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d624 1
a624 1
		kp->prefix.s_addr = kr->prefix.s_addr;
d658 1
a658 1
		memcpy(&kn->r, kr, sizeof(struct kroute));
d971 1
a971 1
	ka->addr.addr.s_addr = ifa->sin_addr.s_addr;
d973 1
a973 1
		ka->addr.mask.s_addr = mask->sin_addr.s_addr;
d977 1
a977 1
		ka->addr.dstbrd.s_addr = brd->sin_addr.s_addr;
d1091 1
a1091 1
		dst.sin_addr.s_addr = kroute->prefix.s_addr;
d1103 1
a1103 1
	nexthop.sin_addr.s_addr = kroute->nexthop.s_addr;
d1333 1
a1333 2
				prefix.s_addr =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
d1366 2
a1367 2
					nexthop.s_addr = ((struct
					    sockaddr_in *)sa)->sin_addr.s_addr;
d1421 1
a1421 1
			kr.prefix.s_addr = prefix.s_addr;
d1423 1
a1423 1
			kr.nexthop.s_addr = nexthop.s_addr;
d1494 1
a1494 1
	memcpy(kif->kpw, kpw, sizeof(*kif->kpw));
d1547 1
a1547 1
	sin->sin_addr.s_addr = kpw->nexthop.s_addr;
@


1.52
log
@Standardize some log messages and fix some inconsistencies.

We were using several different names for the same thing in our log
messages: neighbor, neighbor ID, nbr ID and LSR ID.

Standardize to always use "lsr-id" to refer to a neighbor.

Also:
* Use log_warnx() instead of log_warn() when appropriate;
* Use fatal(x) instead of err(x) when appropriate;
* Fix some inconsistent log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.51 2016/05/23 16:14:36 renato Exp $ */
d47 1
a47 1
	u_int32_t		rtseq;
d64 1
a64 1
	u_int8_t			 priority;
d71 1
a71 1
	u_int8_t				 prefixlen;
d93 4
a96 4
struct kroute_prefix	*kroute_find(in_addr_t, u_int8_t);
struct kroute_priority	*kroute_find_prio(in_addr_t, u_int8_t, u_int8_t);
struct kroute_node	*kroute_find_gw(in_addr_t, u_int8_t, u_int8_t,
    struct in_addr);
d102 2
a103 2
struct kif_node		*kif_find(u_short);
struct kif_node		*kif_insert(u_short);
d105 1
a105 2
void			 kif_clear(void);
struct kif_node		*kif_update(u_short, int, struct if_data *,
d110 1
a110 1
u_int8_t	prefixlen_classful(in_addr_t);
d112 6
a117 5
void		if_change(u_short, int, struct if_data *, struct sockaddr_dl *);
void		if_newaddr(u_short, struct sockaddr_in *, struct sockaddr_in *,
		    struct sockaddr_in *);
void		if_deladdr(u_short, struct sockaddr_in *, struct sockaddr_in *,
		    struct sockaddr_in *);
d120 1
a120 1
int		send_rtmsg(int, int, struct kroute *, u_int32_t);
d123 1
a123 1
int		fetchifs(u_short);
d345 1
a345 1
	u_int32_t		 rl;
d382 22
d488 1
a488 1
	u_int32_t	 a;
d565 1
a565 1
kroute_find(in_addr_t prefix, u_int8_t prefixlen)
d576 1
a576 1
kroute_find_prio(in_addr_t prefix, u_int8_t prefixlen, u_int8_t prio)
d596 1
a596 1
kroute_find_gw(in_addr_t prefix, u_int8_t prefixlen, u_int8_t prio,
d743 1
a743 1
kif_find(u_short ifindex)
d747 1
a747 1
	bzero(&s, sizeof(s));
d766 1
a766 1
kif_insert(u_short ifindex)
d810 1
a810 1
kif_update(u_short ifindex, int flags, struct if_data *ifd,
d861 1
a861 1
u_int8_t
d878 1
a878 1
u_int8_t
d888 1
a888 1
prefixlen2mask(u_int8_t prefixlen)
d915 1
a915 1
if_change(u_short ifindex, int flags, struct if_data *ifd,
d949 2
a950 2
if_newaddr(u_short ifindex, struct sockaddr_in *ifa, struct sockaddr_in *mask,
    struct sockaddr_in *brd)
d954 1
a954 1
	u_int32_t	 a;
d989 2
a990 2
if_deladdr(u_short ifindex, struct sockaddr_in *ifa, struct sockaddr_in *mask,
    struct sockaddr_in *brd)
d1041 1
a1041 1
send_rtmsg(int fd, int action, struct kroute *kroute, u_int32_t family)
d1052 5
a1056 2
	/* Implicit NULL label should not be added to the FIB */
	if (family == AF_MPLS && kroute->local_label == MPLS_LABEL_IMPLNULL)
d1060 1
a1060 1
	bzero(&hdr, sizeof(hdr));
d1075 1
a1075 1
		bzero(&label_in, sizeof(label_in));
d1088 1
a1088 1
		bzero(&dst, sizeof(dst));
d1100 1
a1100 1
	bzero(&nexthop, sizeof(nexthop));
d1113 1
a1113 1
		bzero(&mask, sizeof(mask));
d1127 1
a1127 1
		bzero(&label_out, sizeof(label_out));
d1212 1
a1212 1
fetchifs(u_short ifindex)
d1279 1
a1279 1
	u_int8_t		 prefixlen, prio;
d1281 1
a1281 1
	u_short			 ifindex = 0;
d1288 1
a1288 1
		if (len < offset + sizeof(u_short) ||
d1488 1
a1488 1
		log_warn("%s: failed to find mpw by index (%u)", __func__,
d1513 1
a1513 1
		log_warn("%s: %s is not set", __func__, kif->k.ifname);
@


1.51
log
@More renaming.

Rename a few more things to improve readability.

* s/F_PW_CONTROLWORD_CONF/F_PW_CWORD_CONF/ (shorter)
* s/F_PW_CONTROLWORD/F_PW_CWORD/ (shorter)
* s/LDPD_FLAG_*/F_LDPD_*/ (consistency)
* s/lde_nbr_address/lde_addr/ (shorter)
* s/ldp_discovery_socket/ldp_disc_socket/ (shorter)
* s/ldp_ediscovery_socket/ldp_edisc_socket/ (shorter)
* s/ldp_sendboth/main_imsg_compose_both/ (consistency)
* s/cons/total/ (makes more sense)
* s/kaddr/ka/ (consistency with remaining code)
* Always use 'ln' for lde_nbrs (consistency)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.50 2016/05/23 15:38:58 renato Exp $ */
d1482 1
a1482 1
		log_warn("%s: failed to find mpw by index (%u)", __func__,
d1513 1
a1513 1
		log_warn("%s: unhandled pseudowire type (%#X)", __func__,
@


1.50
log
@Filter our RTM_GET messages which are not from us.

Pulled from ospfd. Original author: claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.49 2016/05/23 15:16:16 renato Exp $ */
d1518 1
a1518 1
	if (kpw->flags & F_PW_CONTROLWORD)
@


1.49
log
@Don't try to install pseudowires of unknown type.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.48 2016/05/23 15:14:07 renato Exp $ */
d1288 4
@


1.48
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.47 2015/09/27 17:30:38 stsp Exp $ */
a1507 1

d1511 1
@


1.47
log
@As done for bgpd recently, rename if_mediatype to if_type in ldpd.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.46 2015/07/21 04:52:29 renato Exp $ */
d172 1
a172 1
		log_warn("kr_init: socket");
d179 1
a179 1
		log_warn("kr_init: setsockopt(SO_USELOOPBACK)");
d189 1
a189 1
		log_warn("kr_init: setsockopt(ROUTE_MSGFILTER)");
d195 1
a195 1
		log_warn("kr_init getsockopt SOL_SOCKET SO_RCVBUF");
d216 1
a216 1
		log_warn("kr_init: ioctl socket");
d233 1
a233 1
		log_warnx("kr_change: lost FEC %s/%d nexthop %s",
d401 1
a401 1
			log_warnx("kr_show_route: wrong imsg len");
d419 1
a419 1
			log_warnx("kr_show_route: wrong imsg len");
d430 1
a430 1
		log_debug("kr_show_route: error handling imsg");
d601 1
a601 1
			fatal("kroute_insert");
d613 1
a613 1
			fatal("kroute_insert");
d634 1
a634 1
			fatal("kroute_insert");
d666 1
a666 1
		log_warnx("kroute_remove failed to find %s/%u",
d686 1
a686 1
			log_warnx("kroute_remove failed for %s/%u",
d902 1
a902 1
		log_warn("if_change: kif_update(%u)", ifindex);
d937 2
a938 1
		log_warnx("if_newaddr: corresponding if %d not found", ifindex);
d947 1
a947 1
		fatal("if_newaddr");
d976 2
a977 1
		log_warnx("if_deladdr: corresponding if %d not found", ifindex);
d1141 1
a1141 1
		log_warn("send_rtmsg: action %u, AF %d, prefix %s/%u",
d1171 1
a1171 1
		log_warn("fetchtable");
d1206 1
a1206 1
		log_warn("fetchif");
d1230 1
a1230 1
		log_warn("dispatch_rtmsg: read error");
d1363 1
a1363 1
				log_warnx("dispatch_rtmsg route not found");
d1407 1
a1407 1
				log_warnx("dispatch_rtmsg route not found");
d1459 1
a1459 1
		log_warn("kmpw_set: failed to find mpw by index (%u)",
d1478 1
a1478 1
		log_warn("kmpw_unset: failed to find mpw by index (%u)",
d1484 1
a1484 1
		log_warn("kmpw_unset: %s is not set", kif->k.ifname);
d1510 1
a1510 1
		log_warn("kmpw_install: unhandled pseudowire type (%#X)",
@


1.46
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.45 2015/07/21 04:43:28 renato Exp $ */
d802 1
a802 1
	kif->k.media_type = ifd->ifi_type;
@


1.45
log
@Add configuration reload support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.44 2015/07/21 04:39:28 renato Exp $ */
d23 1
d51 1
d84 1
d214 6
d306 1
d332 4
d346 1
d374 4
d1448 94
@


1.44
log
@Improve handling of addresses on ldpe.

This is a preliminary work for the the next patch (sigup config
reload). We want to make sure that the ldpe process can handle duplicated
addresses.

The idea is to alloc two different if_addr structures for each address,
and link one in the global list of addresses (used to send address
messages) and link the other to the associated interface list of
addresses.

Doing that we will be able to call kif_redistribute() after reloading
the config file and activate the new LDP enabled interfaces.

NOTE: Interfaces are created at config parse time and the child
processes inherit them on fork() so there's no need to send a status
update at startup.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.43 2015/07/19 18:27:59 renato Exp $ */
a497 6
}

void
kr_reload(void)
{
	/* XXX TODO */
@


1.43
log
@Rework kroute.c to send only the best routes to lde.

This is major rework of the kroute.c code. The idea is remove complexity
from the lde process by making kroute.c advertise only the lowest priority
routes of each prefix.

kroute.c now keeps track of all routes using three different structures:
kroute_prefix, kroute_priority and kroute_node.

kroute_prefix represents a prefix and contains an ordered list of
priorities (kroute_priority) and for each priority there is a list of
nexthops (kroute_node). Arranging the routes using these three structures
allows for the writing of a simpler code, easier to understand.

Whenever a route is removed, if there's another route for the same prefix,
but with a lower priority, this route is immediately sent to lde.

Additional fixes:
* On RTM_CHANGE, remove the old route before installing the new one;
* On IMSG_CTL_KROUTE_ADDR, show all nexthops for multpath routes;
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.42 2015/07/17 21:26:05 claudio Exp $ */
a151 3
		main_imsg_compose_ldpe(IMSG_IFSTATUS, 0, &kif->k,
		    sizeof(struct kif));

@


1.42
log
@Filter routes based on RTF_LLINFO and RTF_BROADCAST flags and use RTF_CONNECTED
to properly track connected routes on -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.41 2015/04/04 16:21:48 renato Exp $ */
d54 17
a70 3
	RB_ENTRY(kroute_node)	 entry;
	struct kroute		 r;
	struct kroute_node	*next;
d86 2
a87 2
void	kr_redistribute(struct kroute_node *);
int	kroute_compare(struct kroute_node *, struct kroute_node *);
d90 7
a96 5
struct kroute_node	*kroute_find_fec(in_addr_t, u_int8_t, struct in_addr);
struct kroute_node	*kroute_find_any(in_addr_t, u_int8_t);
struct kroute_node	*kroute_matchprio(struct kroute_node *, u_int8_t);
int			 kroute_insert(struct kroute_node *);
int			 kroute_remove(struct kroute_node *);
d106 1
a106 1
struct kroute_node	*kroute_match(in_addr_t);
d123 3
a125 3
RB_HEAD(kroute_tree, kroute_node)	krt;
RB_PROTOTYPE(kroute_tree, kroute_node, entry, kroute_compare)
RB_GENERATE(kroute_tree, kroute_node, entry, kroute_compare)
d220 1
a220 1
	struct kroute_node	*kr;
d222 1
d224 6
a229 6
	kr = kroute_find_fec(kroute->prefix.s_addr, kroute->prefixlen,
	    kroute->nexthop);

	if (kr == NULL) {
		log_warnx("kr_change: lost FEC %s/%d",
		    inet_ntoa(kroute->prefix), kroute->prefixlen);
d233 1
a233 1
	if (kr->r.flags & F_LDPD_INSERTED)
d236 3
a238 3
	kr->r.local_label = kroute->local_label;
	kr->r.remote_label = kroute->remote_label;
	kr->r.flags = kr->r.flags | F_LDPD_INSERTED;
d241 1
a241 1
	if (send_rtmsg(kr_state.fd, action, &kr->r, AF_MPLS) == -1)
d244 3
a246 3
	if (kr->r.nexthop.s_addr != INADDR_ANY &&
	    kr->r.remote_label != NO_LABEL) {
		if (send_rtmsg(kr_state.fd, RTM_CHANGE, &kr->r, AF_INET) == -1)
d256 1
a256 1
	struct kroute_node	*kr;
d259 3
a261 3
	kr = kroute_find_fec(kroute->prefix.s_addr, kroute->prefixlen,
	    kroute->nexthop);
	if (kr == NULL)
d264 1
a264 1
	if (!(kr->r.flags & F_LDPD_INSERTED))
d266 2
a267 2
	if (kr->r.nexthop.s_addr != INADDR_ANY &&
	    kr->r.remote_label != NO_LABEL)
d271 1
a271 1
	if (send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r, AF_MPLS) == -1)
d274 3
a276 3
	kr->r.flags &= ~F_LDPD_INSERTED;
	kr->r.local_label = NO_LABEL;
	kr->r.remote_label = NO_LABEL;
d279 1
a279 1
	    send_rtmsg(kr_state.fd, RTM_CHANGE, &kr->r, AF_INET) == -1)
d297 3
a299 1
	struct kroute_node	*kr;
d306 8
a313 3
	RB_FOREACH(kr, kroute_tree, &krt)
		if (kr->r.flags & F_LDPD_INSERTED) {
			send_rtmsg(kr_state.fd, RTM_ADD, &kr->r, AF_MPLS);
d315 4
a318 2
			if (kr->r.nexthop.s_addr != INADDR_ANY &&
			    kr->r.remote_label != NO_LABEL) {
d320 1
a320 1
				    &kr->r, AF_INET);
d323 1
d331 3
a333 1
	struct kroute_node	*kr;
d339 9
a347 2
	RB_FOREACH(kr, kroute_tree, &krt) {
		if (kr->r.flags & F_LDPD_INSERTED) {
d349 1
a349 1
			    &kr->r, AF_MPLS);
d351 4
a354 4
			if (kr->r.nexthop.s_addr != INADDR_ANY &&
			    kr->r.remote_label != NO_LABEL) {
				rl = kr->r.remote_label;
				kr->r.remote_label = NO_LABEL;
d356 2
a357 2
				    &kr->r, AF_INET);
				kr->r.remote_label = rl;
a362 1

d376 3
a378 1
	struct kroute_node	*kr, *kn;
d389 10
a398 9
		RB_FOREACH(kr, kroute_tree, &krt)
			if (!flags || kr->r.flags & flags) {
				kn = kr;
				do {
					main_imsg_compose_ldpe(IMSG_CTL_KROUTE,
					    imsg->hdr.pid,
					    &kn->r, sizeof(kn->r));
				} while ((kn = kn->next) != NULL);
			}
d407 3
a409 3
		kr = NULL;
		kr = kroute_match(addr.s_addr);
		if (kr != NULL)
d411 1
a411 1
			    &kr->r, sizeof(kr->r));
a416 1

d452 4
a482 1
	kr_redist_remove(kr);
d487 1
a487 1
kr_redistribute(struct kroute_node *kh)
d489 1
d492 9
a500 7
	/* only the highest prio route can be redistributed */
	if (kroute_find_fec(kh->r.prefix.s_addr, kh->r.prefixlen,
	    kh->r.nexthop) != kh)
		return;

	for (kn = kh; kn; kn = kn->next)
		kr_redist_eval(&kn->r);
d506 1
a506 7
	struct kroute_node	*kr;

	/* XXX this does not make sense in ldpd */
	RB_FOREACH(kr, kroute_tree, &krt) {
		if (kr->r.flags & F_REDISTRIBUTED)
			kr_redistribute(kr);
	}
d511 1
a511 1
kroute_compare(struct kroute_node *a, struct kroute_node *b)
d513 1
a513 1
	if (ntohl(a->r.prefix.s_addr) < ntohl(b->r.prefix.s_addr))
d515 1
a515 1
	if (ntohl(a->r.prefix.s_addr) > ntohl(b->r.prefix.s_addr))
d517 1
a517 1
	if (a->r.prefixlen < b->r.prefixlen)
d519 1
a519 1
	if (a->r.prefixlen > b->r.prefixlen)
a521 4
	if (ntohl(a->r.nexthop.s_addr) < ntohl(b->r.nexthop.s_addr))
		return (-1);
	if (ntohl(a->r.nexthop.s_addr) > ntohl(b->r.nexthop.s_addr))
		return (1);
d532 2
a533 2
struct kroute_node *
kroute_find_fec(in_addr_t prefix, u_int8_t prefixlen, struct in_addr nexthop)
d535 1
a535 1
	struct kroute_node	s;
d537 2
a538 3
	s.r.prefix.s_addr = prefix;
	s.r.prefixlen = prefixlen;
	s.r.nexthop.s_addr = nexthop.s_addr;
d543 2
a544 2
struct kroute_node *
kroute_find_any(in_addr_t prefix, u_int8_t prefixlen)
d546 13
a558 2
	struct kroute_node	s;
	struct kroute_node	*kn, *best = NULL;
d560 1
a560 14
	s.r.prefix.s_addr = prefix;
	s.r.prefixlen = prefixlen;
	s.r.nexthop.s_addr = 0;

	kn = RB_NFIND(kroute_tree, &krt, &s);
	while (kn) {
		if (!best || best->r.priority > kn->r.priority)
			best = kn;
		kn = RB_NEXT(kroute_tree, &krt, kn);
		if (kn == NULL || kn->r.prefix.s_addr != prefix ||
		    kn->r.prefixlen != prefixlen)
			break;
	}
	return (best);
d564 2
a565 1
kroute_matchprio(struct kroute_node *kr, u_int8_t prio)
d567 9
a575 5
	while (kr) {
		if (kr->r.priority == prio)
			return (kr);
		kr = kr->next;
	}
d581 1
a581 1
kroute_insert(struct kroute_node *kr)
d583 3
a585 1
	struct kroute_node	*krm, *krh;
d587 26
a612 10
	if ((krh = RB_INSERT(kroute_tree, &krt, kr)) != NULL) {
		/*
		 * Multiple FEC, add to ordered list
		 */
		if (kr->r.priority < krh->r.priority) {
			/* head element */
			if (RB_REMOVE(kroute_tree, &krt, krh) == NULL) {
				log_warnx("kroute_insert failed to del %s/%u",
				    inet_ntoa(krh->r.prefix), krh->r.prefixlen);
				return (-1);
a613 14
			if (RB_INSERT(kroute_tree, &krt, kr) != NULL) {
				log_warnx("kroute_insert failed to add %s/%u",
				    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
				return (-1);
			}
			kr->next = krh;
			krh = kr;
		} else {
			for (krm = krh; krm->next != NULL &&
			    krm->next->r.priority < kr->r.priority;
			    krm = krm->next)
				;
			kr->next = krm->next;
			krm->next = kr;
d615 27
a641 2
	} else
		krh = kr;
a642 1
	kr_redistribute(krh);
d647 1
a647 1
kroute_remove(struct kroute_node *kr)
d649 3
a651 1
	struct kroute_node	*krm;
d653 3
a655 1
	if ((krm = RB_FIND(kroute_tree, &krt, kr)) == NULL) {
d657 1
a657 1
		    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
d660 5
d666 6
a671 25
	if (krm == kr) {
		/* head element */
		if (RB_REMOVE(kroute_tree, &krt, kr) == NULL) {
			log_warnx("kroute_remove failed for %s/%u",
			    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
			return (-1);
		}
		if (kr->next != NULL) {
			if (RB_INSERT(kroute_tree, &krt, kr->next) != NULL) {
				log_warnx("kroute_remove failed to add %s/%u",
				    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
				return (-1);
			}
		}
	} else {
		/* somewhere in the list */
		while (krm->next != kr && krm->next != NULL)
			krm = krm->next;
		if (krm->next == NULL) {
			log_warnx("kroute_remove multipath list corrupted "
			    "for %s/%u", inet_ntoa(kr->r.prefix),
			    kr->r.prefixlen);
			return (-1);
		}
		krm->next = kr->next;
d674 4
a677 7
	kr_redist_remove(&kr->r);

	/* kill MPLS LSP if one was installed */
	if (kr->r.flags & F_LDPD_INSERTED)
		if (send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r, AF_MPLS) ==
		    -1) {
			free(kr);
d680 3
a683 1
	free(kr);
d690 3
a692 1
	struct kroute_node	*kr;
d694 14
a707 2
	while ((kr = RB_MIN(kroute_tree, &krt)) != NULL)
		kroute_remove(kr);
d809 1
a809 1
struct kroute_node *
d813 1
a813 1
	struct kroute_node	*kr;
d817 3
a819 2
		if ((kr = kroute_find_any(key & prefixlen2mask(i), i)) != NULL)
			return (kr);
d822 3
a824 2
	if ((kr = kroute_find_any(0, 0)) != NULL)
			return (kr);
d1238 3
a1240 1
	struct kroute_node	*kr, *okr;
d1243 1
a1243 1
	int			 flags, mpath;
a1259 1
		flags = 0;
a1260 1
		mpath = 0;
d1262 1
a1271 6
			prefix.s_addr = 0;
			prefixlen = 0;
			nexthop.s_addr = 0;
			mpath = 0;
			prio = 0;

a1287 3

			if (rtm->rtm_flags & RTF_MPATH)
				mpath = 1;
d1341 22
d1376 3
a1378 35
			if ((okr = kroute_find_fec(prefix.s_addr, prefixlen,
			    nexthop))
			    != NULL) {
				/* get the correct route */
				kr = okr;
				if ((kr = kroute_matchprio(okr, prio)) ==
				    NULL) {
					log_warnx("mpath route not found");
					/* add routes we missed out earlier */
					goto add;
				}

				if (kr->r.flags & F_LDPD_INSERTED)
					flags |= F_LDPD_INSERTED;
				kr->r.nexthop.s_addr = nexthop.s_addr;
				kr->r.flags = flags;
				kr->r.ifindex = ifindex;

				/* just readd, the RDE will care */
				kr_redistribute(okr);
			} else {
add:
				if ((kr = calloc(1,
				    sizeof(struct kroute_node))) == NULL) {
					log_warn("dispatch calloc");
					return (-1);
				}
				kr->r.prefix.s_addr = prefix.s_addr;
				kr->r.prefixlen = prefixlen;
				kr->r.nexthop.s_addr = nexthop.s_addr;
				kr->r.flags = flags;
				kr->r.ifindex = ifindex;
				kr->r.priority = prio;
				kr->r.local_label = NO_LABEL;
				kr->r.remote_label = NO_LABEL;
d1380 10
a1389 2
				kroute_insert(kr);
			}
a1391 3
			if ((kr = kroute_find_fec(prefix.s_addr, prefixlen,
			    nexthop)) == NULL)
				continue;
d1393 3
a1395 4
			okr = kr;
			if ((kr = kroute_matchprio(kr, prio)) == NULL) {
				log_warnx("dispatch_rtmsg mpath route"
				    " not found");
d1398 1
a1398 1
			if (kroute_remove(kr) == -1)
@


1.41
log
@Remove lo protection.

There's no need to protect the 127/8 network on ldpd since this network
is filtered before being sent to lde.

If we receive a label mapping for this network, it won't be installed
because lde has no nexthop for it, and thus the code will always fall
into the LMp.13 case of the RFC "Receive Label Mapping" algorithm:
the mapping will be recorded but not used.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.40 2015/03/21 18:34:01 renato Exp $ */
d1218 2
a1219 1
			if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
d1262 4
d1270 4
@


1.40
log
@Remove unused variables and functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.39 2015/03/21 18:32:01 renato Exp $ */
a91 1
int		protect_lo(void);
a193 3
	if (protect_lo() == -1)
		return (-1);

a760 22
int
protect_lo(void)
{
	struct kroute_node	*kr;

	/* special protection for 127/8 */
	if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
		log_warn("protect_lo");
		return (-1);
	}
	kr->r.prefix.s_addr = htonl(INADDR_LOOPBACK & IN_CLASSA_NET);
	kr->r.prefixlen = 8;
	kr->r.flags = F_CONNECTED;
	kr->r.local_label = NO_LABEL;
	kr->r.remote_label = NO_LABEL;

	if (RB_INSERT(kroute_tree, &krt, kr) != NULL)
		free(kr);	/* kernel route already there, no problem */

	return (0);
}

@


1.39
log
@Remove interface finite state machine.

In the name of simplicity, remove the interface FSM that was inherited
from ospfd. In ldpd interfaces are just up or down, so keeping a
FSM for that is an overkill. Now instead of calling if_fsm(), just
call if_update() whenever a relevant event occurs (status change,
address addition/removal).

Additional notes:
1 - s/if_act_/if_/

2 - Remove the IMSG_IFUP and IMSG_IFDOWN events. Now whenever an
interface changes its state a IMSG_IFSTATUS event will be generated
with the new status.

kroute.c ldpd.h ldpe.c ldpe.h CVS:
----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.38 2015/03/21 18:20:19 renato Exp $ */
a114 2

int		flag_implicit_null = 0;
@


1.38
log
@ldpd: Don't assign labels for BGP routes.

Although RFC 5036 is not explicit about this, LDP should not assign
labels for BGP routes. Doing that would be very resource consuming
in some scenarios and unnecessary. The goal is generally only to
establish LSPs among all PEs in the AS since LDP is not used as an
end in itself but as a means to implement advanced solutions like
MPLS L2/L3 VPNs. Some implementations (e.g. JunOS) go further and
only assign labels for /32 loopback routes advertised in the IGP.

If Inter-AS LSPs are necessary, BGP itself should be used for
distributing IPv4 labeled routes (e.g. option C. of section 10 in
RFC 4364).
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.37 2015/02/11 05:56:51 claudio Exp $ */
d139 1
a139 1
		main_imsg_compose_ldpe(IMSG_IFUP, 0, &kif->k,
d858 4
a861 1
	if (link_new == link_old) {
a863 4
		return;
	} else if (link_new) {
		main_imsg_compose_ldpe(IMSG_IFUP, 0, &kif->k,
		    sizeof(struct kif));
d868 1
a868 1
		main_imsg_compose_ldpe(IMSG_IFDOWN, 0, &kif->k,
@


1.37
log
@Use sizeof(u_short) in the first check since there are RT messages that
are less then sizeof(*rtm) bytes long (e.g. interface announcements).
Found the hard way by phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.36 2015/02/10 08:25:51 claudio Exp $ */
d1248 4
@


1.36
log
@Sync kroute code with bgpd/ospfd code regarding EAGAIN and short reads
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.35 2015/02/10 01:03:54 claudio Exp $ */
d1210 1
a1210 1
		if (len < offset + sizeof(*rtm) ||
@


1.35
log
@Pass SOCK_NONBLOCK | SOCK_CLOEXEC to some more sockets. We never want to
sleep on a socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.34 2015/01/16 06:40:17 deraadt Exp $ */
d106 1
a106 1
int		rtmsg_process(char *, int);
d1177 2
d1192 1
a1192 1
rtmsg_process(char *buf, int len)
d1204 1
a1204 2

	int			 offset;
d1210 3
@


1.34
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.33 2014/06/23 03:46:17 guenther Exp $ */
d157 2
a158 1
	if ((kr_state.fd = socket(AF_ROUTE, SOCK_RAW, 0)) == -1) {
@


1.33
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.32 2013/10/30 17:24:34 deraadt Exp $ */
a20 1
#include <sys/param.h>
d40 1
@


1.32
log
@another simple %i to %d conversion for obviousness
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.31 2013/10/15 21:54:19 renato Exp $ */
d1107 1
a1107 1
	mib[1] = AF_ROUTE;
d1143 1
a1143 1
	mib[1] = AF_ROUTE;
@


1.31
log
@Don't bind a label for the default route.

After discussing with claudio@@ we came to the conclusion that it's
more safe to ignore the default route and don't bind a label for
it.
OK @@claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.30 2013/10/15 20:21:25 renato Exp $ */
d887 1
a887 1
		log_warnx("if_newaddr: corresponding if %i not found", ifindex);
d925 1
a925 1
		log_warnx("if_deladdr: corresponding if %i not found", ifindex);
@


1.30
log
@Fix whitespace and other style issues.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.29 2013/06/04 00:41:18 claudio Exp $ */
d425 2
a426 2
	 * We consider the loopback net, multicast and experimental addresses
	 * as not redistributable.
d430 1
@


1.29
log
@fix some minor issues before proceeding with the remaining patches from
Renato Westphal. Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.28 2013/06/03 16:56:47 claudio Exp $ */
d556 1
a556 1
		 * Multiple FEC, add to ordered list 
d850 1
a850 1
		log_warn("if_change:  kif_update(%u)", ifindex);
a1073 1

@


1.28
log
@Advertise the implicit-null label for routes attached to loopback
interfaces to guarantee PHP. With this 'fib-update no' is not totaly
broken because of missing mappings for the loopbacks.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.27 2013/06/03 16:53:49 claudio Exp $ */
d897 1
a897 1
	ka->addr.addr = ifa->sin_addr;
d899 1
a899 1
		ka->addr.mask = mask->sin_addr;
d903 1
a903 1
		ka->addr.dstbrd = brd->sin_addr;
@


1.27
log
@Implement support for multiple addresses per interface.
This replaces the way addresses and interface are chained together.
In ospfd there was a 1 to 1 mapping (with iface clones) but LDP does
not have that limitation.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.26 2013/06/01 20:13:04 claudio Exp $ */
d1300 4
@


1.26
log
@Filter out route messages we don't need and log kernel messages in
super verbose mode.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.25 2011/06/26 19:19:23 claudio Exp $ */
d59 5
d87 2
a88 2
struct kif		*kif_update(u_short, int, struct if_data *,
			    struct sockaddr_dl *);
d132 16
d660 1
a660 1
kif_findname(char *ifname, struct in_addr addr, struct kif_addr **kap)
a662 1
	struct kif_addr	*ka;
d665 1
a665 10
		if (!strcmp(ifname, kif->k.ifname)) {
			ka = TAILQ_FIRST(&kif->addrs);
			if (addr.s_addr != 0) {
				TAILQ_FOREACH(ka, &kif->addrs, entry) {
					if (addr.s_addr == ka->addr.s_addr)
						break;
				}
			}
			if (kap != NULL)
				*kap = ka;
a666 1
		}
d715 1
a715 1
struct kif *
d717 1
a717 1
    struct sockaddr_dl *sdl)
d724 3
a726 1
	}
d744 1
a744 1
	return (&kif->k);
d844 3
a846 1
	struct kif		*kif;
d848 2
a849 1
	if ((kif = kif_update(ifindex, flags, ifd, sdl)) == NULL) {
d853 2
d856 17
a872 2
	/* notify ldpe about interface link state */
	main_imsg_compose_ldpe(IMSG_IFINFO, 0, kif, sizeof(struct kif));
d881 1
d889 5
d896 2
a897 1
	ka->addr = ifa->sin_addr;
d899 1
a899 1
		ka->mask = mask->sin_addr;
d901 1
a901 1
		ka->mask.s_addr = INADDR_NONE;
d903 1
a903 1
		ka->dstbrd = brd->sin_addr;
d905 1
a905 1
		ka->dstbrd.s_addr = INADDR_NONE;
d908 4
d931 1
a931 1
		if (ka->addr.s_addr == ifa->sin_addr.s_addr) {
d933 5
a937 1
			/* XXX inform engine about if change? */
@


1.25
log
@Remove obsolete mcast routes in ldpd and ripd.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.24 2010/10/20 12:16:41 claudio Exp $ */
d132 1
d144 11
a154 1
		log_warn("kr_init: setsockopt");	/* not fatal */
d1163 1
@


1.24
log
@Since on shutdown fib_sync is forced to 1 to remove the multicast route
it needs to be set to 0 afterwards again, because the FIB was decoupled
right before and now no "route vanished before delete" messages are
printed on shutdown.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.23 2010/10/15 13:18:45 claudio Exp $ */
a110 1
struct kroute	kr_all_routers;
a111 1
int		flag_all_routers = 0;
a166 11
	kr_all_routers.prefix.s_addr = inet_addr(AllRouters);
	kr_all_routers.prefixlen = mask2prefixlen(INADDR_BROADCAST);
	kr_all_routers.nexthop.s_addr = htonl(INADDR_LOOPBACK);
	kr_all_routers.remote_label = NO_LABEL;

	kr_state.fib_sync = 1;	/* force addition of multicast route */
	if (send_rtmsg(kr_state.fd, RTM_ADD, &kr_all_routers, AF_INET) != -1)
		flag_all_routers = 1;

	kr_state.fib_sync = fs;	/* now set correct sync mode */

a244 7

	if (flag_all_routers) {
		kr_state.fib_sync = 1;	/* force removal of mulitcast route */
		(void)send_rtmsg(kr_state.fd, RTM_DELETE, &kr_all_routers,
		    AF_INET);
		kr_state.fib_sync = 0;	/* back to decoupled state */
	}
@


1.23
log
@Rework the kroute framework of ldpd. ldpd is different from the other
routing daemons. Change the way the kroute tree is indexed (by FEC with
a linked list in case there is a priority conflict -- same route + nexthop
at different priorities). This needs a mpath capable MPLS routing table.
Still work in progress but works a lot better in close meshed networks.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.22 2010/10/07 12:38:00 claudio Exp $ */
d263 1
@


1.22
log
@Don't try to add MPLS routes with a incomming MPLS_LABEL_IMPLNULL label.
The kernel has now a static entry for them and they should not hit the
wire anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.21 2010/09/01 13:54:54 claudio Exp $ */
a69 2
int	kr_change_fib(struct kroute_node *, struct kroute *, int);
int	kr_delete_fib(struct kroute_node *);
a70 1
struct kroute_node	*kroute_find(in_addr_t, u_int8_t, u_int8_t);
d72 2
a73 1
struct kroute_node	*kroute_matchgw(struct kroute_node *, struct in_addr);
d188 1
a188 1
kr_change_fib(struct kroute_node *kr, struct kroute *kroute, int action)
d190 15
a206 1
	kr->r.nexthop.s_addr = kroute->nexthop.s_addr;
d223 1
a223 1
kr_change(struct kroute *kroute)
d226 1
a226 1
	int			 action = RTM_ADD;
d230 2
a232 15
	if (kr == NULL) {
		log_warnx("kr_change: lost FEC %s/%d",
		    inet_ntoa(kroute->prefix), kroute->prefixlen);
		return (-1);
	}

	if (kr->r.flags & F_LDPD_INSERTED)
		action = RTM_CHANGE;

	return (kr_change_fib(kr, kroute, action));
}

int
kr_delete_fib(struct kroute_node *kr)
{
d235 3
a237 3

	/* remove F_LDPD_INSERTED flag, route still exists in kernel */
	kr->r.flags &= ~F_LDPD_INSERTED;
d243 3
a245 2
	if (kroute_remove(kr) == -1)
		return (-1);
d247 2
a248 14
	return (0);
}

int
kr_delete(struct kroute *kroute)
{
	struct kroute_node	*kr, *nkr;

	kr = kroute_find_fec(kroute->prefix.s_addr, kroute->prefixlen,
	    kroute->nexthop);
	if (kr == NULL)
		return (0);

	if (kr_delete_fib(kr) == -1)
a250 6
	while (kr != NULL) {
		nkr = kr->next;
		if (kr_delete_fib(kr) == -1)
			return (-1);
		kr = nkr;
	}
d443 2
a444 1
	if (kroute_find(kh->r.prefix.s_addr, kh->r.prefixlen, RTP_ANY) != kh)
d456 1
d476 1
a476 4
	/* if the priority is RTP_ANY finish on the first address hit */
	if (a->r.priority == RTP_ANY || b->r.priority == RTP_ANY)
		return (0);
	if (a->r.priority < b->r.priority)
d478 1
a478 1
	if (a->r.priority > b->r.priority)
d491 1
a491 1
kroute_find(in_addr_t prefix, u_int8_t prefixlen, u_int8_t prio)
a493 1
	struct kroute_node	*kn, *tmp;
d497 1
a497 1
	s.r.priority = prio;
d499 1
a499 12
	kn = RB_FIND(kroute_tree, &krt, &s);
	if (kn && prio == RTP_ANY) {
		tmp = RB_PREV(kroute_tree, &krt, kn);
		while (tmp) {
			if (kroute_compare(&s, tmp) == 0)
				kn = tmp;
			else
				break;
			tmp = RB_PREV(kroute_tree, &krt, kn);
		}
	}
	return (kn);
d503 1
a503 1
kroute_find_fec(in_addr_t prefix, u_int8_t prefixlen, struct in_addr nexthop)
d506 1
a506 1
	struct kroute_node	*kn, *kr;
d510 1
a510 1
	s.r.priority = 0;	/* trick to use RB_NFIND */
d514 2
a515 2
		if ((kr = kroute_matchgw(kn, nexthop)))
			return (kr);
d519 1
a519 1
			return (NULL);
d521 1
a521 1
	return (NULL);
d525 1
a525 1
kroute_matchgw(struct kroute_node *kr, struct in_addr nh)
a526 4
	in_addr_t	nexthop;

	nexthop = nh.s_addr;

d528 1
a528 1
		if (kr->r.nexthop.s_addr == nexthop)
d539 1
a539 1
	struct kroute_node	*krm;
d541 1
a541 1
	if ((krm = RB_INSERT(kroute_tree, &krt, kr)) != NULL) {
d543 1
a543 1
		 * Multipath route, add at end of list.
d545 22
a566 4
		while (krm->next != NULL)
			krm = krm->next;
		krm->next = kr;
		kr->next = NULL; /* to be sure */
d568 1
a568 1
		krm = kr;
d570 1
a570 1
	kr_redistribute(krm);
d614 8
d751 1
a751 2
		if ((kr = kroute_find(key & prefixlen2mask(i), i,
		    RTP_ANY)) != NULL)
d755 1
a755 1
	if ((kr = kroute_find(0, 0, RTP_ANY)) != NULL)
a756 1

d952 1
d964 1
a964 2
		hdr.rtm_flags |= RTF_MPLS;
		hdr.rtm_priority = RTP_DEFAULT;
a975 1
		hdr.rtm_priority = kroute->priority;
d1261 2
a1262 1
			if ((okr = kroute_find(prefix.s_addr, prefixlen, prio))
d1266 1
a1266 2
				if ((mpath || prio == RTP_OSPF) &&
				    (kr = kroute_matchgw(okr, nexthop)) ==
d1280 1
a1280 1
				kr_redistribute(kr);
d1301 2
a1302 2
			if ((kr = kroute_find(prefix.s_addr, prefixlen, prio))
			    == NULL)
d1306 1
a1306 2
			if (mpath &&
			    (kr = kroute_matchgw(kr, nexthop)) == NULL) {
@


1.21
log
@s/lfib/fib/ for more consitency with the other routing daemons.
This started manly because of ldpctl beeing inconsistent and me misstyping
lfib almost every time.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.20 2010/07/12 14:35:13 bluhm Exp $ */
a943 1
	u_int32_t		hr_label;
d949 3
a951 9
	/* Implicit NULL label should be added/remove just one time */
	hr_label = kroute->local_label;
	if (hr_label == MPLS_LABEL_IMPLNULL) {
		if (action == RTM_ADD && flag_implicit_null)
			return (0);

		if (action == RTM_DELETE && !flag_implicit_null)
			return (0);
	}
a1065 8
	}

	if (hr_label == MPLS_LABEL_IMPLNULL) {
		if (action == RTM_ADD)
			flag_implicit_null = 1;

		if (action == RTM_DELETE)
			flag_implicit_null = 0;
@


1.20
log
@Merge duplicate log messages into one log_warn().
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.19 2010/07/08 09:41:05 claudio Exp $ */
d275 1
a275 1
	kr_lfib_decouple();
d288 1
a288 1
kr_lfib_couple(void)
d312 1
a312 1
kr_lfib_decouple(void)
@


1.19
log
@Kill more code in kroute.c that is unneeded in ldpd. ldpd is a bit strange
since it does not care that much about reachability of routes. The idea is
to have diverse LSP in the kernel and the kernel should then decide which
path should be used.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.18 2010/06/30 05:27:56 claudio Exp $ */
d1058 1
a1058 2
		switch (errno) {
		case ESRCH:
a1066 6
			} else {
				log_warnx("send_rtmsg: action %u, "
				    "prefix %s/%u: %s", hdr.rtm_type,
				    inet_ntoa(kroute->prefix),
				    kroute->prefixlen, strerror(errno));
				return (0);
a1067 7
			break;
		default:
			log_warnx("send_rtmsg: action %u, "
			    "AF %d prefix %s/%u: %s", hdr.rtm_type,
			    family, inet_ntoa(kroute->prefix),
			    kroute->prefixlen, strerror(errno));
			return (0);
d1069 4
@


1.18
log
@Pass a struct kroute and not a kroute_node to kr_redist_remove(). This
allows kr_redist_eval() to call kr_redist_remove(0 instead of hand rolling
the same code.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.17 2010/06/30 05:21:38 claudio Exp $ */
a85 1
int			 kif_validate(u_short);
d237 2
a238 5
	if (kr->r.flags & F_KERNEL) {
		/* remove F_LDPD_INSERTED flag, route still exists in kernel */
		kr->r.flags &= ~F_LDPD_INSERTED;
		return (0);
	}
d240 1
a424 4
	/* Only static routes are considered for redistribution. */
	if (!(kr->flags & F_KERNEL))
		goto dont_redistribute;

a428 4
	/* interface is not up and running so don't announce */
	if (kr->flags & F_DOWN)
		goto dont_redistribute;

a586 10
	if (!(kr->r.flags & F_KERNEL)) {
		kr->r.flags &= ~F_DOWN;
		return (0);
	}

	if (kif_validate(kr->r.ifindex))
		kr->r.flags &= ~F_DOWN;
	else
		kr->r.flags |= F_DOWN;

a730 4
                kif->k.nh_reachable = (flags & IFF_UP) &&
		    (LINK_STATE_IS_UP(ifd->ifi_link_state) ||
		    (ifd->ifi_link_state == LINK_STATE_UNKNOWN &&
		    ifd->ifi_type != IFT_CARP));
a751 13
int
kif_validate(u_short ifindex)
{
	struct kif_node		*kif;

	if ((kif = kif_find(ifindex)) == NULL) {
		log_warnx("interface with index %u not found", ifindex);
		return (1);
	}

	return (kif->k.nh_reachable);
}

d784 1
a784 1
	kr->r.flags = F_KERNEL|F_CONNECTED;
a850 1
	struct kroute_node	*kr, *tkr;
a851 1
	u_int8_t		 reachable;
a857 10
	reachable = (kif->flags & IFF_UP) &&
	    (LINK_STATE_IS_UP(kif->link_state) ||
	    (kif->link_state == LINK_STATE_UNKNOWN &&
	    kif->media_type != IFT_CARP));

	if (reachable == kif->nh_reachable)
		return;		/* nothing changed wrt nexthop validity */

	kif->nh_reachable = reachable;

a859 14

	/* update redistribute list */
	RB_FOREACH(kr, kroute_tree, &krt) {
		for (tkr = kr; tkr != NULL; tkr = tkr->next) {
			if (tkr->r.ifindex == ifindex) {
				if (reachable)
					tkr->r.flags &= ~F_DOWN;
				else
					tkr->r.flags |= F_DOWN;

				kr_redistribute(tkr);
			}
		}
	}
d1211 1
a1211 1
		flags = F_KERNEL;
a1315 5
				if (kif_validate(kr->r.ifindex))
					kr->r.flags &= ~F_DOWN;
				else
					kr->r.flags |= F_DOWN;

a1339 2
				continue;
			if (!(kr->r.flags & F_KERNEL))
@


1.17
log
@Kill IMSG_KLABEL_INSERT and all the related functions around it.
IMSG_KLABEL_CHANGE is smart enough to know when something is a change
or an insert.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.16 2010/06/30 05:07:09 claudio Exp $ */
d65 1
a65 1
void	kr_redist_remove(struct kroute_node *);
d411 1
a411 1
kr_redist_remove(struct kroute_node *kn)
d414 1
a414 1
	if ((kn->r.flags & F_REDISTRIBUTED) == 0)
d418 2
a419 2
	kn->r.flags &= ~F_REDISTRIBUTED;
	main_imsg_compose_lde(IMSG_NETWORK_DEL, 0, &kn->r,
d462 1
a462 6
	/* was the route redistributed? */
	if ((kr->flags & F_REDISTRIBUTED) == 0)
		return (0);

	kr->flags &= ~F_REDISTRIBUTED;
	main_imsg_compose_lde(IMSG_NETWORK_DEL, 0, kr, sizeof(struct kroute));
d650 1
a650 1
	kr_redist_remove(kr);
@


1.16
log
@Rework how we "redistribute" networks. Send all pathes of an active route
to the lde so we can assign remote labels to all of those pathes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.15 2010/06/30 02:09:22 claudio Exp $ */
a192 7
	/* nexthop within 127/8 -> ignore silently */
	if ((kroute->nexthop.s_addr & htonl(IN_CLASSA_NET)) ==
	    htonl(INADDR_LOOPBACK & IN_CLASSA_NET))
		return (0);

	kr->r.prefix.s_addr = kroute->prefix.s_addr;
	kr->r.prefixlen = kroute->prefixlen;
d196 1
a196 1
	kr->r.flags = kroute->flags | F_LDPD_INSERTED;
a613 24
	return (0);
}

int
kroute_insert_label(struct kroute *kr)
{
	struct kroute_node *krn;

	krn = kroute_find(kr->prefix.s_addr, kr->prefixlen, RTP_ANY);
	if (krn == NULL) {
		log_debug("kroute_insert_label: prefix %s/%d not present",
		    inet_ntoa(kr->prefix), kr->prefixlen);
		return (-1);
	}

	krn->r.flags |= F_LDPD_INSERTED;
	krn->r.local_label = kr->local_label;
	krn->r.remote_label = kr->remote_label;

	send_rtmsg(kr_state.fd, RTM_ADD, kr, AF_MPLS);

	if (kr->nexthop.s_addr != INADDR_ANY && kr->remote_label != NO_LABEL)
		send_rtmsg(kr_state.fd, RTM_CHANGE, kr, AF_INET);

@


1.15
log
@Sync kroute.c code with ospfd's version of kroute.c. A small step to support
multipath routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.14 2010/06/21 19:43:36 claudio Exp $ */
d66 1
a66 1
int	kr_redist_eval(struct kroute *, struct kroute *);
d426 2
a427 5

	if (kn == NULL) {
		main_imsg_compose_lde(IMSG_NETWORK_DEL, 0, &kn->r,
		    sizeof(struct kroute));
	}
d431 1
a431 1
kr_redist_eval(struct kroute *kr, struct kroute *orig)
d465 1
a465 1
	*orig = *kr;
d474 1
d481 1
a481 1
	struct kroute		 kr;
d487 2
a488 12
	bzero(&kr, sizeof(kr));
	if (!kr_redist_eval(&kh->r, &kr))
		return;

	if (kr.flags & F_REDISTRIBUTED) {
		main_imsg_compose_lde(IMSG_NETWORK_ADD, 0, &kr,
		    sizeof(struct kroute));
	} else {
		kr = kh->r;
		main_imsg_compose_lde(IMSG_NETWORK_DEL, 0, &kr,
		    sizeof(struct kroute));
	}
@


1.14
log
@Send the right kroute struct to ldpctl for IMSG_CTL_KROUTE. This should
fix printing of multipath routes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.13 2010/06/07 13:24:23 claudio Exp $ */
d74 1
a74 1
struct kroute_node	*kroute_find_fec(in_addr_t, u_int8_t, in_addr_t);
d93 1
a93 1
void		if_change(u_short, int, struct if_data *);
d96 2
d225 1
a225 1
	    kroute->nexthop.s_addr);
d266 1
a266 1
	    kroute->nexthop.s_addr);
d569 1
a569 1
kroute_find_fec(in_addr_t prefix, u_int8_t prefixlen, in_addr_t nexthop)
d572 1
a572 1
	struct kroute_node	*kn;
d580 2
a581 2
		if (kn->r.nexthop.s_addr == nexthop)
			break;
d584 2
a585 4
		    kn->r.prefixlen != prefixlen) {
			kn = NULL;
			break;
		}
d587 1
a587 1
	return (kn);
d797 1
a797 1
	if ((kif = kif_find(ifindex)) == NULL)
d800 5
d934 2
a935 1
if_change(u_short ifindex, int flags, struct if_data *ifd)
d937 1
a937 1
	struct kroute_node	*kr;
d941 1
a941 1
	if ((kif = kif_update(ifindex, flags, ifd, NULL)) == NULL) {
d961 6
a966 5
		if (kr->r.ifindex == ifindex) {
			if (reachable)
				kr->r.flags &= ~F_DOWN;
			else
				kr->r.flags |= F_DOWN;
d968 2
a969 1
			kr_redistribute(kr);
d1003 26
d1213 2
a1214 6
	char			*buf, *next, *lim;
	struct rt_msghdr	*rtm;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_in	*sa_in;
	struct sockaddr_mpls	*sa_mpls;
	struct kroute_node	*kr;
d1238 2
a1239 61
	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

		if ((sa = rti_info[RTAX_DST]) == NULL)
			continue;

		if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
			continue;

		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_warn("fetchtable");
			free(buf);
			return (-1);
		}

		kr->r.flags = F_KERNEL;
		kr->r.priority = rtm->rtm_priority;
		kr->r.local_label = NO_LABEL;
		kr->r.remote_label = NO_LABEL;

		switch (sa->sa_family) {
		case AF_INET:
			kr->r.prefix.s_addr =
			    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
			sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];
			if (rtm->rtm_flags & RTF_STATIC)
				kr->r.flags |= F_STATIC;
			if (rtm->rtm_flags & RTF_DYNAMIC)
				kr->r.flags |= F_DYNAMIC;
			if (sa_in != NULL) {
				if (sa_in->sin_len == 0)
					break;
				kr->r.prefixlen =
				    mask2prefixlen(sa_in->sin_addr.s_addr);
			} else if (rtm->rtm_flags & RTF_HOST)
				kr->r.prefixlen = 32;
			else
				kr->r.prefixlen =
				    prefixlen_classful(kr->r.prefix.s_addr);
			break;
		default:
			free(kr);
			continue;
		}

		kr->r.ifindex = rtm->rtm_index;
		if ((sa = rti_info[RTAX_GATEWAY]) != NULL)
			switch (sa->sa_family) {
			case AF_INET:
				kr->r.nexthop.s_addr =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				break;
			case AF_LINK:
				kr->r.flags |= F_CONNECTED;
				break;
			}
d1241 1
a1241 10
		if ((sa_mpls = (struct sockaddr_mpls *)rti_info[RTAX_SRC])
		    != NULL)
			kr->r.local_label =
			    ntohl(sa_mpls->smpls_label) >> MPLS_LABEL_OFFSET;

		kroute_insert(kr);

	}
	free(buf);
	return (0);
d1249 2
a1250 6
	char			*buf, *next, *lim;
	struct rt_msghdr	*rtm;
	struct if_msghdr	 ifm;
	struct ifa_msghdr	*ifam;
	struct kif		*kif = NULL;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
d1273 2
a1274 29
	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		switch (rtm->rtm_type) {
		case RTM_IFINFO:
			bcopy(rtm, &ifm, sizeof ifm);
			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
			get_rtaddrs(ifm.ifm_addrs, sa, rti_info);

			if ((kif = kif_update(ifm.ifm_index,
			    ifm.ifm_flags, &ifm.ifm_data,
			    (struct sockaddr_dl *)rti_info[RTAX_IFP])) == NULL)
				fatal("fetchifs");

			kif->nh_reachable = (kif->flags & IFF_UP) &&
			    (LINK_STATE_IS_UP(ifm.ifm_data.ifi_link_state) ||
			    (ifm.ifm_data.ifi_link_state ==
			    LINK_STATE_UNKNOWN &&
			    ifm.ifm_data.ifi_type != IFT_CARP));
			break;
		case RTM_NEWADDR:
			ifam = (struct ifa_msghdr *)rtm;
			if ((ifam->ifam_addrs & (RTA_NETMASK | RTA_IFA |
			    RTA_BRD)) == 0)
				break;
			sa = (struct sockaddr *)(ifam + 1);
			get_rtaddrs(ifam->ifam_addrs, sa, rti_info);
d1276 1
a1276 9
			if_newaddr(ifam->ifam_index,
			    (struct sockaddr_in *)rti_info[RTAX_IFA],
			    (struct sockaddr_in *)rti_info[RTAX_NETMASK],
			    (struct sockaddr_in *)rti_info[RTAX_BRD]);
			break;
		}
	}
	free(buf);
	return (0);
a1283 12
	char			*next, *lim;
	struct rt_msghdr	*rtm;
	struct if_msghdr	 ifm;
	struct ifa_msghdr	*ifam;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_in	*sa_in;
	struct kroute_node	*kr;
	struct in_addr		 prefix, nexthop;
	u_int8_t		 prefixlen;
	u_int8_t		 prio;
	int			 flags;
	u_short			 ifindex = 0;
d1295 22
a1316 2
	lim = buf + n;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
d1325 5
d1331 10
a1340 5
		prio = rtm->rtm_priority;
		if (rtm->rtm_type == RTM_ADD || rtm->rtm_type == RTM_CHANGE ||
		    rtm->rtm_type == RTM_DELETE) {
			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
			get_rtaddrs(rtm->rtm_addrs, sa, rti_info);
d1342 1
a1342 1
			if (rtm->rtm_tableid != 0)
d1345 1
a1345 1
			if (rtm->rtm_pid == kr_state.pid) /* caused by us */
d1348 1
a1348 1
			if (rtm->rtm_errno)		/* failed attempts... */
d1354 4
d1375 4
d1402 1
d1405 1
a1405 1
				log_warnx("dispatch_rtmsg no nexthop for %s/%u",
d1410 12
a1421 7
			if ((kr = kroute_find(prefix.s_addr, prefixlen,
			    prio)) != NULL) {
				/*
				 * ldp route overridden by kernel. Preference
				 * of the route is not checked because this is
				 * forced -- most probably by a user.
				 */
a1423 2
				if (kr->r.flags & F_REDISTRIBUTED)
					flags |= F_REDISTRIBUTED;
d1436 1
d1439 1
a1439 1
					log_warn("dispatch_rtmsg");
d1455 2
a1456 2
			if ((kr = kroute_find(prefix.s_addr, prefixlen,
			    prio)) == NULL)
d1460 7
a1466 7

			if (kr->r.flags & F_LDPD_INSERTED) {
				main_imsg_compose_lde(IMSG_NETWORK_DEL, 0,
				    &kr->r, sizeof(struct kroute));

				send_rtmsg(kr_state.fd, RTM_DELETE,
				    &kr->r, AF_MPLS);
a1467 1

d1473 2
a1474 2
			if_change(ifm.ifm_index, ifm.ifm_flags,
			    &ifm.ifm_data);
a1480 2
			sa = (struct sockaddr *)(ifam + 1);
			get_rtaddrs(ifam->ifam_addrs, sa, rti_info);
d1487 11
d1506 2
a1507 1
	return (0);
@


1.13
log
@Store all labels in ldpd in host byte order without any additional shifting.
Add the necessary ntohl() and shifts in various places and cleanup the byte
order mess we had before. michele@@ agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.12 2010/05/25 13:29:45 claudio Exp $ */
d376 1
a376 1
					    &kr->r, sizeof(kr->r));
@


1.12
log
@Remove another leftover from ospfd. ldpd does not have a concept of ext_tag
and so there is no need to carry ext_tag and rtlabels around.
"Yes! kill kill kill" michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.11 2010/05/19 13:13:36 claudio Exp $ */
d1029 1
a1029 1
	hr_label = ntohl(kroute->local_label) >> MPLS_LABEL_OFFSET;
d1056 2
a1057 1
		label_in.smpls_label = kroute->local_label;
d1110 2
a1111 1
		label_out.smpls_label = kroute->remote_label;
d1120 1
a1120 2
		if (ntohl(kroute->remote_label) >> MPLS_LABEL_OFFSET ==
		    MPLS_LABEL_IMPLNULL) {
d1272 2
a1273 1
			kr->r.local_label = sa_mpls->smpls_label;
@


1.11
log
@Set RTF_MPLS in rtm_fmask and rtm_flags because ldpd wants to play with
the MPLS part of those routes.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.10 2010/04/13 15:39:29 michele Exp $ */
a201 3
	kr->r.ext_tag = kroute->ext_tag;
	rtlabel_unref(kr->r.rtlabel);	/* for RTM_CHANGE */
	kr->r.rtlabel = kroute->rtlabel;
a221 2
	kroute->rtlabel = rtlabel_tag2id(kroute->ext_tag);

a698 1
	rtlabel_unref(kr->r.rtlabel);
a1181 1
	struct sockaddr_rtlabel	*label;
a1272 7
		if ((label = (struct sockaddr_rtlabel *)
		    rti_info[RTAX_LABEL]) != NULL) {
			kr->r.rtlabel =
			    rtlabel_name2id(label->sr_label);
			kr->r.ext_tag =
			    rtlabel_id2tag(kr->r.rtlabel);
		}
a1364 1
	struct sockaddr_rtlabel	*label;
a1472 11
				rtlabel_unref(kr->r.rtlabel);
				kr->r.rtlabel = 0;
				kr->r.ext_tag = 0;
				if ((label = (struct sockaddr_rtlabel *)
				    rti_info[RTAX_LABEL]) != NULL) {
					kr->r.rtlabel =
					    rtlabel_name2id(label->sr_label);
					kr->r.ext_tag =
					    rtlabel_id2tag(kr->r.rtlabel);
				}

a1493 8

				if ((label = (struct sockaddr_rtlabel *)
				    rti_info[RTAX_LABEL]) != NULL) {
					kr->r.rtlabel =
					    rtlabel_name2id(label->sr_label);
					kr->r.ext_tag =
					    rtlabel_id2tag(kr->r.rtlabel);
				}
@


1.10
log
@When a prefix has a implicit null label associated, force pop operation.
This allow us to correcly do penultimate hop popping.

From Thomas Habets. Thanks.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.9 2010/03/25 12:05:18 claudio Exp $ */
d1050 1
d1064 1
d1118 1
@


1.9
log
@Kroute updates from the LDE are per FEC so do the lookup in kroute with
prefix/len and nexthop but do not consider the priority. send_rtmsg() needs
to use the kroute element and not the one sent from the LDE since that one
has no priority set (which is needed). This seems to solve a problem where
ldpd modified the wrong routes. OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.8 2010/03/24 19:13:10 claudio Exp $ */
d1121 12
a1132 4
		if (family == AF_MPLS)
			hdr.rtm_mpls = MPLS_OP_SWAP;
		else
			hdr.rtm_mpls = MPLS_OP_PUSH;
@


1.8
log
@We need to set the rtm_priority when changing a route so that we do not
modify a possible better route instead. A bit more is still needed.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.7 2010/03/03 10:17:05 claudio Exp $ */
d74 1
a195 10
	/* send update */
	if (send_rtmsg(kr_state.fd, action, kroute, AF_MPLS) == -1)
		return (-1);

	if (kroute->nexthop.s_addr != INADDR_ANY &&
	    kroute->remote_label != NO_LABEL) {
		if (send_rtmsg(kr_state.fd, RTM_CHANGE, kroute, AF_INET) == -1)
			return (-1);
	}

d206 10
d227 2
a228 1
	kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen, RTP_ANY);
d268 3
a270 2
	if ((kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen,
	    kroute->priority)) == NULL)
d566 24
@


1.7
log
@Rework the kroute code by stealing some code from ospfd and massaging it
a lot more. Main reason for this is to add priority support. Additionally
add some additional NO_LABEL fixes.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.6 2010/02/19 12:47:29 claudio Exp $ */
d1048 1
a1048 1
		hdr.rtm_priority = 0;
@


1.6
log
@Do not double free a knode when kroute_insert() fails. kroute_insert()
will free the node if something fails.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.5 2009/09/28 09:48:46 michele Exp $ */
d56 1
d66 1
a66 1
int	kr_redist_eval(struct kroute *, struct rroute *);
d73 2
a74 1
struct kroute_node	*kroute_find(in_addr_t, u_int8_t);
d97 1
a97 2
int		send_rtmsg(int, int, struct kroute *);
int		send_rtlabelmsg(int, int, struct kroute *, u_int32_t);
d101 1
d119 3
a162 2
	RB_INIT(&krt);

d172 1
d175 1
a175 1
	if (send_rtmsg(kr_state.fd, RTM_ADD, &kr_all_routers) != -1)
a189 2
	struct kroute_node	*kn;

d196 1
a196 1
	if (send_rtlabelmsg(kr_state.fd, action, kroute, AF_MPLS) == -1)
d199 3
a201 3
	if (kroute->nexthop.s_addr != NULL) {
		if (send_rtlabelmsg(kr_state.fd, action, kroute,
		    AF_INET) == -1)
d205 9
a213 23
	/* create new entry unless we are changing the first entry */
	if (action == RTM_ADD) {
		if ((kn = calloc(1, sizeof(*kn))) == NULL)
			fatal(NULL);
	} else
		kn = kr;

	kn->r.prefix.s_addr = kroute->prefix.s_addr;
	kn->r.prefixlen = kroute->prefixlen;
	kn->r.local_label = kroute->local_label;
	kn->r.remote_label = kroute->remote_label;
	kn->r.nexthop.s_addr = kroute->nexthop.s_addr;
	kn->r.flags = kroute->flags | F_LDPD_INSERTED;
	kn->r.ext_tag = kroute->ext_tag;
	rtlabel_unref(kn->r.rtlabel);	/* for RTM_CHANGE */
	kn->r.rtlabel = kroute->rtlabel;

	if (action == RTM_ADD) {
		if (kroute_insert(kn) == -1) {
			log_debug("kr_update_fib: cannot insert %s",
			    inet_ntoa(kn->r.nexthop));
		}
	}
d226 1
a226 1
	kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen);
d228 7
a234 1
	if (kr != NULL && kr->r.flags & F_KERNEL)
d252 1
a252 1
	if (send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r) == -1)
d264 1
a264 1
	struct kroute_node	*kr;
d266 2
a267 2
	if ((kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen)) ==
	    NULL)
d273 6
d289 2
a290 1
		(void)send_rtmsg(kr_state.fd, RTM_DELETE, &kr_all_routers);
d308 9
a316 2
		if (!(kr->r.flags & F_KERNEL))
			send_rtmsg(kr_state.fd, RTM_ADD, &kr->r);
d325 1
d332 1
a332 1
			send_rtlabelmsg(kr_state.fd, RTM_DELETE,
d335 5
a339 2
			if (kr->r.nexthop.s_addr != NULL) {
				send_rtlabelmsg(kr_state.fd, RTM_DELETE,
d341 1
d361 1
a361 1
	struct kroute_node	*kr;
d374 6
a379 2
				main_imsg_compose_ldpe(IMSG_CTL_KROUTE,
				    imsg->hdr.pid, &kr->r, sizeof(kr->r));
a419 2
	struct rroute	 rr;

a425 1
	rr.kr = kn->r;
d428 2
a429 2
		main_imsg_compose_lde(IMSG_NETWORK_DEL, 0, &rr.kr,
		    sizeof(struct rroute));
d434 1
a434 1
kr_redist_eval(struct kroute *kr, struct rroute *rr)
d436 1
a436 1
	u_int32_t	 a, metric = 0;
d459 2
a460 1
	 * Consider networks with nexthop loopback as not redistributable.
d462 2
a463 1
	if (kr->nexthop.s_addr == htonl(INADDR_LOOPBACK))
d468 1
a468 8
	/*
	 * only on of all multipath routes can be redistributed so
	 * redistribute the best one.
	 */
	if (rr->metric > metric) {
		rr->kr = *kr;
		rr->metric = metric;
	}
d483 1
a483 1
	struct rroute		 rr;
d485 2
a486 3
	bzero(&rr, sizeof(rr));
	rr.metric = UINT_MAX;
	if (!kr_redist_eval(&kh->r, &rr))
d489 7
a495 3
	if (rr.kr.flags & F_REDISTRIBUTED) {
		main_imsg_compose_lde(IMSG_NETWORK_ADD, 0, &rr,
		    sizeof(struct rroute));
d497 3
a499 3
		rr.kr = kh->r;
		main_imsg_compose_lde(IMSG_NETWORK_DEL, 0, &rr.kr,
		    sizeof(struct rroute));
d526 8
d545 1
a545 1
kroute_find(in_addr_t prefix, u_int8_t prefixlen)
d548 1
d552 22
d575 7
a581 1
	return (RB_FIND(kroute_tree, &krt, &s));
d587 12
a598 6
	if (RB_INSERT(kroute_tree, &krt, kr) != NULL) {
		log_warnx("kroute_insert failed for %s/%u",
		    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
		free(kr);
		return (-1);
	}
d610 1
a610 1
	kr_redistribute(kr);
d619 1
a619 1
	krn = kroute_find(kr->prefix.s_addr, kr->prefixlen);
d630 1
a630 1
	send_rtlabelmsg(kr_state.fd, RTM_ADD, kr, AF_MPLS);
d632 2
a633 2
	if (kr->nexthop.s_addr != INADDR_ANY)
		send_rtlabelmsg(kr_state.fd, RTM_ADD, kr, AF_INET);
d641 4
a644 2
	if (RB_REMOVE(kroute_tree, &krt, kr) == NULL) {
		log_warnx("kroute_remove failed for %s/%u",
d649 27
d820 2
a821 1
		if ((kr = kroute_find(key & prefixlen2mask(i), i)) != NULL)
d825 1
a825 1
	if ((kr = kroute_find(0, 0)) != NULL)
d842 1
a842 1
	kr->r.prefix.s_addr = htonl(INADDR_LOOPBACK);
d845 2
d889 2
a890 2
#define	ROUNDUP(a, size)	\
    (((a) & ((size) - 1)) ? (1 + ((a) | ((size) - 1))) : (a))
d901 1
a901 1
			    ROUNDUP(sa->sa_len, sizeof(long)));
d995 1
a995 1
send_rtlabelmsg(int fd, int action, struct kroute *kroute, u_int32_t family)
a1016 3
	if (family == AF_INET && kroute->remote_label == 0)
		return (0);

d1021 1
a1021 7
	/* ldpd must not add/delete AF_INET routes, instead it should just
	   modify existing ones adding/remove relevant MPLS infos */
	if (family == AF_INET)
		hdr.rtm_type = RTM_CHANGE;
	else
		hdr.rtm_type = action;

a1022 1
	hdr.rtm_priority = 0;
d1036 1
d1048 1
d1082 1
a1082 1
	if (kroute->remote_label != 0 && action != RTM_DELETE) {
d1105 1
a1105 1
			if (hdr.rtm_type == RTM_CHANGE) {
d1114 1
a1114 1
				log_warnx("send_rtlabelmsg: action %u, "
d1122 3
a1124 3
			log_warnx("send_rtlabelmsg: action %u, "
			    "prefix %s/%u: %s", hdr.rtm_type,
			    inet_ntoa(kroute->prefix),
a1141 110
send_rtmsg(int fd, int action, struct kroute *kroute)
{
	struct iovec		iov[5];
	struct rt_msghdr	hdr;
	struct sockaddr_in	prefix;
	struct sockaddr_in	nexthop;
	struct sockaddr_in	mask;
	struct sockaddr_rtlabel	sa_rl;
	int			iovcnt = 0;
	const char		*label;

	/* initialize header */
	bzero(&hdr, sizeof(hdr));
	hdr.rtm_version = RTM_VERSION;
	hdr.rtm_type = action;
	hdr.rtm_priority = RTP_STATIC;
	if (action == RTM_CHANGE)	/* force PROTO2 reset the other flags */
		hdr.rtm_fmask = RTF_PROTO2|RTF_PROTO1|RTF_REJECT|RTF_BLACKHOLE;
	hdr.rtm_seq = kr_state.rtseq++;	/* overflow doesn't matter */
	hdr.rtm_msglen = sizeof(hdr);
	hdr.rtm_hdrlen = sizeof(struct rt_msghdr);
	/* adjust iovec */
	iov[iovcnt].iov_base = &hdr;
	iov[iovcnt++].iov_len = sizeof(hdr);

	bzero(&prefix, sizeof(prefix));
	prefix.sin_len = sizeof(prefix);
	prefix.sin_family = AF_INET;
	prefix.sin_addr.s_addr = kroute->prefix.s_addr;
	/* adjust header */
	hdr.rtm_addrs |= RTA_DST;
	hdr.rtm_msglen += sizeof(prefix);
	/* adjust iovec */
	iov[iovcnt].iov_base = &prefix;
	iov[iovcnt++].iov_len = sizeof(prefix);

	if (kroute->nexthop.s_addr != 0) {
		bzero(&nexthop, sizeof(nexthop));
		nexthop.sin_len = sizeof(nexthop);
		nexthop.sin_family = AF_INET;
		nexthop.sin_addr.s_addr = kroute->nexthop.s_addr;
		/* adjust header */
		hdr.rtm_flags |= RTF_GATEWAY;
		hdr.rtm_addrs |= RTA_GATEWAY;
		hdr.rtm_msglen += sizeof(nexthop);
		/* adjust iovec */
		iov[iovcnt].iov_base = &nexthop;
		iov[iovcnt++].iov_len = sizeof(nexthop);
	}

	bzero(&mask, sizeof(mask));
	mask.sin_len = sizeof(mask);
	mask.sin_family = AF_INET;
	mask.sin_addr.s_addr = prefixlen2mask(kroute->prefixlen);
	/* adjust header */
	hdr.rtm_addrs |= RTA_NETMASK;
	hdr.rtm_msglen += sizeof(mask);
	/* adjust iovec */
	iov[iovcnt].iov_base = &mask;
	iov[iovcnt++].iov_len = sizeof(mask);

	if (kroute->rtlabel != 0) {
		sa_rl.sr_len = sizeof(sa_rl);
		sa_rl.sr_family = AF_UNSPEC;
		label = rtlabel_id2name(kroute->rtlabel);
		if (strlcpy(sa_rl.sr_label, label,
		    sizeof(sa_rl.sr_label)) >= sizeof(sa_rl.sr_label)) {
			log_warnx("send_rtmsg: invalid rtlabel");
			return (-1);
		}
		/* adjust header */
		hdr.rtm_addrs |= RTA_LABEL;
		hdr.rtm_msglen += sizeof(sa_rl);
		/* adjust iovec */
		iov[iovcnt].iov_base = &sa_rl;
		iov[iovcnt++].iov_len = sizeof(sa_rl);
	}

retry:
	if (writev(fd, iov, iovcnt) == -1) {
		switch (errno) {
		case ESRCH:
			if (hdr.rtm_type == RTM_CHANGE) {
				hdr.rtm_type = RTM_ADD;
				goto retry;
			} else if (hdr.rtm_type == RTM_DELETE) {
				log_info("route %s/%u vanished before delete",
				    inet_ntoa(kroute->prefix),
				    kroute->prefixlen);
				return (0);
			} else {
				log_warnx("send_rtmsg: action %u, "
				    "prefix %s/%u: %s", hdr.rtm_type,
				    inet_ntoa(kroute->prefix),
				    kroute->prefixlen, strerror(errno));
				return (0);
			}
			break;
		default:
			log_warnx("send_rtmsg: action %u, prefix %s/%u: %s",
			    hdr.rtm_type, inet_ntoa(kroute->prefix),
			    kroute->prefixlen, strerror(errno));
			return (0);
		}
	}

	return (0);
}

int
d1197 3
a1209 2
			if (rtm->rtm_flags & RTF_PROTO1)
				kr->r.flags |= F_BGPD_INSERTED;
d1242 6
a1247 12
		if (rtm->rtm_flags & RTF_PROTO2)  {
			send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r);
			free(kr);
		} else {
			if ((label = (struct sockaddr_rtlabel *)
			    rti_info[RTAX_LABEL]) != NULL) {
				kr->r.rtlabel =
				    rtlabel_name2id(label->sr_label);
				kr->r.ext_tag =
				    rtlabel_id2tag(kr->r.rtlabel);
			}
			kroute_insert(kr);
d1249 1
d1345 1
d1370 1
a1406 2
				if (rtm->rtm_flags & RTF_PROTO1)
					flags |= F_BGPD_INSERTED;
d1435 2
a1436 2
			if ((kr = kroute_find(prefix.s_addr, prefixlen)) !=
			    NULL) {
d1479 3
d1495 2
a1496 2
			if ((kr = kroute_find(prefix.s_addr, prefixlen)) ==
			    NULL)
d1505 1
a1505 1
				send_rtlabelmsg(kr_state.fd, RTM_DELETE,
@


1.5
log
@When a route is deleted, ldpd should remove labels associated with it from
lfib (the kernel lib) but not from the lib. These could be used later on when
the route come back.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.4 2009/08/06 09:07:49 michele Exp $ */
a223 1
			free(kn);
@


1.4
log
@ldpd must not add/delete AF_INET routes, it just have to change them
inserting/deleting MPLS infos.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.3 2009/07/13 19:04:26 michele Exp $ */
d415 1
a415 1
		main_imsg_compose_lde(IMSG_NETWORK_DEL, 0, &rr,
d487 1
a487 1
		main_imsg_compose_lde(IMSG_NETWORK_DEL, 0, &rr,
d1533 1
a1533 4
			/*
			 * last route is getting removed request the
			 * ldp route from the RDE to insert instead
			 */
d1535 1
a1535 1
				main_imsg_compose_lde(IMSG_KROUTE_GET, 0,
d1537 3
d1541 1
@


1.3
log
@Get rid of the multipath code, as it is not needed.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.2 2009/06/05 22:40:24 chris Exp $ */
d921 1
a933 3
	if (family == AF_INET && action == RTM_ADD)
		action = RTM_CHANGE;

d937 8
a944 1
	hdr.rtm_type = action;
a945 4
/*	if (action == RTM_CHANGE)
		hdr.rtm_fmask = RTF_PROTO3|RTF_PROTO2|RTF_PROTO1|
		    RTF_REJECT|RTF_BLACKHOLE;
*/
d1003 2
a1004 1
	if (kroute->remote_label != 0) {
d1022 1
a1140 1

@


1.2
log
@rtm->rtm_hdrlen conversion

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
a55 1
	struct kroute_node	*next;
d64 1
a64 1
void	kr_redist_remove(struct kroute_node *, struct kroute_node *);
d69 1
a69 1
int	kr_change_fib(struct kroute_node *, struct kroute *, int, int);
a72 1
struct kroute_node	*kroute_matchgw(struct kroute_node *, struct in_addr);
d184 1
a184 2
kr_change_fib(struct kroute_node *kr, struct kroute *kroute, int krcount,
    int action)
d186 1
a186 2
	int			 i;
	struct kroute_node	*kn, *nkn;
d188 4
a191 23
	if (action == RTM_ADD) {
		/*
		 * First remove all stale multipath routes.
		 * This step must be skipped when the action is RTM_CHANGE
		 * because it is already a single path route that will be
		 * changed.
		 */
		for (kn = kr; kn != NULL; kn = nkn) {
			for (i = 0; i < krcount; i++) {
				if (kn->r.nexthop.s_addr ==
				    kroute[i].nexthop.s_addr)
					break;
			}
			nkn = kn->next;
			if (i == krcount)
				/* stale route */
				if (kr_delete_fib(kn) == -1)
					log_warnx("kr_delete_fib failed");
			log_debug("kr_update_fib: before: %s%s",
			    inet_ntoa(kn->r.nexthop),
			    i == krcount ? " (deleted)" : "");
		}
	}
d193 3
a195 25
	/*
	 * now add or change the route
	 */
	for (i = 0; i < krcount; i++) {
		/* nexthop within 127/8 -> ignore silently */
		if ((kroute[i].nexthop.s_addr & htonl(IN_CLASSA_NET)) ==
		    htonl(INADDR_LOOPBACK & IN_CLASSA_NET))
			continue;
		if (action == RTM_ADD && kr) {
			for (kn = kr; kn != NULL; kn = kn->next) {
				if (kn->r.nexthop.s_addr ==
				    kroute[i].nexthop.s_addr)
					break;
			}

			log_debug("kr_update_fib: after : %s%s",
			     inet_ntoa(kroute[i].nexthop),
			     kn == NULL ? " (added)" : "");

			if (kn != NULL)
				/* nexthop already present, skip it */
				continue;
		} else
			/* modify first entry */
			kn = kr;
d197 3
a199 3
		/* send update */
		if (send_rtlabelmsg(kr_state.fd, action, &kroute[i], AF_MPLS)
		    == -1)
d201 1
a201 5
		if (kroute[i].nexthop.s_addr != NULL) {
			if (send_rtlabelmsg(kr_state.fd, action, &kroute[i],
			    AF_INET) == -1)
				return (-1);
		}
d203 6
a208 4
		/* create new entry unless we are changing the first entry */
		if (action == RTM_ADD)
			if ((kn = calloc(1, sizeof(*kn))) == NULL)
				fatal(NULL);
d210 9
a218 9
		kn->r.prefix.s_addr = kroute[i].prefix.s_addr;
		kn->r.prefixlen = kroute[i].prefixlen;
		kn->r.local_label = kroute[i].local_label;
		kn->r.remote_label = kroute[i].remote_label;
		kn->r.nexthop.s_addr = kroute[i].nexthop.s_addr;
		kn->r.flags = kroute[i].flags | F_LDPD_INSERTED;
		kn->r.ext_tag = kroute[i].ext_tag;
		rtlabel_unref(kn->r.rtlabel);	/* for RTM_CHANGE */
		kn->r.rtlabel = kroute[i].rtlabel;
d220 6
a225 7
		if (action == RTM_ADD)
			if (kroute_insert(kn) == -1) {
				log_debug("kr_update_fib: cannot insert %s",
				    inet_ntoa(kn->r.nexthop));
				free(kn);
			}
		action = RTM_ADD;
d227 1
d232 1
a232 1
kr_change(struct kroute *kroute, int krcount)
d241 2
a242 6
	if (kr != NULL) {
		if (kr->r.flags & F_KERNEL)
			action = RTM_CHANGE;
		else if (kr->next == NULL)	/* single path route */
			action = RTM_CHANGE;
	}
d244 1
a244 1
	return (kr_change_fib(kr, kroute, krcount, action));
d271 1
a271 1
	struct kroute_node	*kr, *nkr;
d277 3
a279 6
	while (kr != NULL) {
		nkr = kr->next;
		if (kr_delete_fib(kr) == -1)
			return (-1);
		kr = nkr;
	}
a300 1
	struct kroute_node	*kn;
d309 1
a309 3
			for (kn = kr; kn != NULL; kn = kn->next) {
				send_rtmsg(kr_state.fd, RTM_ADD, &kn->r);
			}
a317 1
	struct kroute_node	*kn;
d324 4
a327 1
			for (kn = kr; kn != NULL; kn = kn->next) {
d329 1
a329 6
				    &kn->r, AF_MPLS);

				if (kr->r.nexthop.s_addr != NULL) {
					send_rtlabelmsg(kr_state.fd, RTM_DELETE,
					    &kn->r, AF_INET);
				}
a349 1
	struct kroute_node	*kn;
d362 2
a363 6
				kn = kr;
				do {
					main_imsg_compose_ldpe(IMSG_CTL_KROUTE,
					    imsg->hdr.pid,
					    &kn->r, sizeof(kn->r));
				} while ((kn = kn->next) != NULL);
d402 1
a402 1
kr_redist_remove(struct kroute_node *kh, struct kroute_node *kn)
d414 1
a414 6
	/* probably inform the RDE (check if no other path is redistributed) */
	for (kn = kh; kn; kn = kn->next)
		if (kn->r.flags & F_REDISTRIBUTED)
			break;

	if (kn == NULL)
d417 1
a474 1
	struct kroute_node	*kn;
a475 1
	int			 redistribute = 0;
d479 1
a479 5
	for (kn = kh; kn; kn = kn->next)
		if (kr_redist_eval(&kn->r, &rr))
			redistribute = 1;

	if (!redistribute)
d495 1
a495 1
	struct kroute_node	*kr, *kn;
d498 1
a498 13
		for (kn = kr; kn; kn = kn->next) {
			/*
			 * if it is redistributed, redistribute again metric
			 * may have changed.
			 */
			if (kn->r.flags & F_REDISTRIBUTED)
				break;
		}
		if (kn) {
			/*
			 * kr_redistribute copes with removes and RDE with
			 * duplicates
			 */
a499 1
		}
a535 17
struct kroute_node *
kroute_matchgw(struct kroute_node *kr, struct in_addr nh)
{
	in_addr_t	nexthop;

	nexthop = nh.s_addr;

	while (kr) {
		if (kr->r.nexthop.s_addr == nexthop)
			return (kr);
		kr = kr->next;
	}

	return (NULL);
}


d539 6
a544 14
	struct kroute_node	*krm;

	if ((krm = RB_INSERT(kroute_tree, &krt, kr)) != NULL) {
		/*
		 * Multipath route, add at end of list and clone the
		 * ldpd inserted flag.
		 */
		kr->r.flags |= krm->r.flags & F_LDPD_INSERTED;
		while (krm->next != NULL)
			krm = krm->next;
		krm->next = kr;
		kr->next = NULL; /* to be sure */
	} else
		krm = kr;
d556 1
a556 1
	kr_redistribute(krm);
d587 2
a588 4
	struct kroute_node	*krm;

	if ((krm = RB_FIND(kroute_tree, &krt, kr)) == NULL) {
		log_warnx("kroute_remove failed to find %s/%u",
d593 1
a593 28
	if (krm == kr) {
		/* head element */
		if (RB_REMOVE(kroute_tree, &krt, kr) == NULL) {
			log_warnx("kroute_remove failed for %s/%u",
			    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
			return (-1);
		}
		if (kr->next != NULL) {
			if (RB_INSERT(kroute_tree, &krt, kr->next) != NULL) {
				log_warnx("kroute_remove failed to add %s/%u",
				    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
				return (-1);
			}
		}
	} else {
		/* somewhere in the list */
		while (krm->next != kr && krm->next != NULL)
			krm = krm->next;
		if (krm->next == NULL) {
			log_warnx("kroute_remove multipath list corrupted "
			    "for %s/%u", inet_ntoa(kr->r.prefix),
			    kr->r.prefixlen);
			return (-1);
		}
		krm->next = kr->next;
	}

	kr_redist_remove(krm, kr);
d824 1
a824 1
	struct kroute_node	*kr, *tkr;
d848 5
a852 6
		for (tkr = kr; tkr != NULL; tkr = tkr->next) {
			if (tkr->r.ifindex == ifindex) {
				if (reachable)
					tkr->r.flags &= ~F_DOWN;
				else
					tkr->r.flags |= F_DOWN;
d854 1
a854 1
			}
a855 1
		kr_redistribute(kr);
a1075 1
	hdr.rtm_flags = RTF_MPATH;
d1376 1
a1376 1
	struct kroute_node	*kr, *okr;
d1379 1
a1379 1
	int			 flags, mpath;
a1401 1
		mpath = 0;
a1419 4
#ifdef RTF_MPATH
			if (rtm->rtm_flags & RTF_MPATH)
				mpath = 1;
#endif
d1469 1
a1469 1
			if ((okr = kroute_find(prefix.s_addr, prefixlen)) !=
a1470 13
				/* just add new multipath routes */
				if (mpath && rtm->rtm_type == RTM_ADD)
					goto add;
				/* get the correct route */
				kr = okr;
				if (mpath && (kr = kroute_matchgw(okr,
				    nexthop)) == NULL) {
					log_warnx("dispatch_rtmsg mpath route"
					    " not found");
					/* add routes we missed out earlier */
					goto add;
				}

d1501 1
a1501 1
				kr_redistribute(okr);
a1502 1
add:
a1530 8
			/* get the correct route */
			okr = kr;
			if (mpath &&
			    (kr = kroute_matchgw(kr, nexthop)) == NULL) {
				log_warnx("dispatch_rtmsg mpath route"
				    " not found");
				return (-1);
			}
d1535 1
a1535 2
			if (okr == kr && kr->next == NULL &&
			    kr->r.flags & F_LDPD_INSERTED)
d1538 1
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1092 1
d1226 1
d1356 1
a1356 1
		sa = (struct sockaddr *)(rtm + 1);
d1551 1
a1551 1
			sa = (struct sockaddr *)(rtm + 1);
@

