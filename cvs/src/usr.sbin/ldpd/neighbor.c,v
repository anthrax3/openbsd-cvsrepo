head	1.79;
access;
symbols
	OPENBSD_6_2:1.79.0.6
	OPENBSD_6_2_BASE:1.79
	OPENBSD_6_1:1.79.0.4
	OPENBSD_6_1_BASE:1.79
	OPENBSD_6_0:1.77.0.2
	OPENBSD_6_0_BASE:1.77
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.52.0.4
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.43.0.6
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.43.0.4
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.24.0.8
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.79
date	2017.03.04.00.15.35;	author renato;	state Exp;
branches;
next	1.78;
commitid	BOl8emh4A0ljUk3b;

1.78
date	2016.09.03.16.07.08;	author renato;	state Exp;
branches;
next	1.77;
commitid	fYTaUp1tzXub9AKi;

1.77
date	2016.07.01.23.29.55;	author renato;	state Exp;
branches;
next	1.76;
commitid	OkOx7tFZtmlIlivU;

1.76
date	2016.07.01.23.22.42;	author renato;	state Exp;
branches;
next	1.75;
commitid	KNtlNq8t1jai5pAy;

1.75
date	2016.07.01.23.14.31;	author renato;	state Exp;
branches;
next	1.74;
commitid	DKNC9fIizmSRxKR1;

1.74
date	2016.06.13.23.01.37;	author renato;	state Exp;
branches;
next	1.73;
commitid	6Kn577N67pcmgY5D;

1.73
date	2016.06.13.20.19.40;	author renato;	state Exp;
branches;
next	1.72;
commitid	pBNsEb3sqMOC0tnw;

1.72
date	2016.05.23.19.20.55;	author renato;	state Exp;
branches;
next	1.71;
commitid	8nGP7z5tJSygyBn7;

1.71
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.70;
commitid	TLlfi1Pk0Z97z8HM;

1.70
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.69;
commitid	AQBoOveMRKjtVfFv;

1.69
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.68;
commitid	t07H0Mk6WGdVWB0W;

1.68
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.67;
commitid	D7VvXbswyzx5Ahb2;

1.67
date	2016.05.23.18.55.21;	author renato;	state Exp;
branches;
next	1.66;
commitid	85kONxXVWUqI2Jhb;

1.66
date	2016.05.23.18.28.22;	author renato;	state Exp;
branches;
next	1.65;
commitid	FV8IR5RMrg1EHRis;

1.65
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.64;
commitid	VpAym8dVR6eY4drQ;

1.64
date	2016.05.23.16.58.31;	author renato;	state Exp;
branches;
next	1.63;
commitid	uXtq8faMqaWAoZrF;

1.63
date	2016.05.23.16.23.06;	author renato;	state Exp;
branches;
next	1.62;
commitid	XJl1Mpa27tMoxe3U;

1.62
date	2016.05.23.16.20.59;	author renato;	state Exp;
branches;
next	1.61;
commitid	nAtgYzDo97D7UnEI;

1.61
date	2016.05.23.16.18.51;	author renato;	state Exp;
branches;
next	1.60;
commitid	0IKOnhMGNkMbV1lE;

1.60
date	2016.05.23.16.16.44;	author renato;	state Exp;
branches;
next	1.59;
commitid	lsfNt5ZefaCVBrpj;

1.59
date	2016.05.23.15.59.55;	author renato;	state Exp;
branches;
next	1.58;
commitid	2jPamx70j4TMPRN1;

1.58
date	2016.05.23.15.57.50;	author renato;	state Exp;
branches;
next	1.57;
commitid	412vkTYh5W4EltoT;

1.57
date	2016.05.23.15.49.31;	author renato;	state Exp;
branches;
next	1.56;
commitid	RpMaNILGRIfJM8EJ;

1.56
date	2016.05.23.15.47.24;	author renato;	state Exp;
branches;
next	1.55;
commitid	Eng7dm0NElMq9Yi3;

1.55
date	2016.05.23.15.43.11;	author renato;	state Exp;
branches;
next	1.54;
commitid	weS0xzAgWBV4f0dh;

1.54
date	2016.05.23.15.41.04;	author renato;	state Exp;
branches;
next	1.53;
commitid	GWVZlQK3ZbMPg5pq;

1.53
date	2016.05.23.15.14.07;	author renato;	state Exp;
branches;
next	1.52;
commitid	l3e6PhvoAh8C7elc;

1.52
date	2015.07.21.05.02.57;	author renato;	state Exp;
branches;
next	1.51;
commitid	HgM2vLtnZjFgxhpg;

1.51
date	2015.07.21.05.01.46;	author renato;	state Exp;
branches;
next	1.50;
commitid	XffmjWB83F5FGFp5;

1.50
date	2015.07.21.04.58.48;	author renato;	state Exp;
branches;
next	1.49;
commitid	zvZYEuz9wxbvZ2db;

1.49
date	2015.07.21.04.43.28;	author renato;	state Exp;
branches;
next	1.48;
commitid	QaTrdqMa9i0CUoyW;

1.48
date	2015.07.19.21.04.38;	author renato;	state Exp;
branches;
next	1.47;
commitid	jI3o3zBRaRv2piIx;

1.47
date	2015.07.19.21.01.56;	author renato;	state Exp;
branches;
next	1.46;
commitid	3CZZKtMxWnvDQhpO;

1.46
date	2015.07.19.20.50.03;	author renato;	state Exp;
branches;
next	1.45;
commitid	HQ4RevpYoLNvLRj2;

1.45
date	2015.03.21.18.34.01;	author renato;	state Exp;
branches;
next	1.44;
commitid	cFXa8ucj1hCSVYz6;

1.44
date	2015.02.09.11.54.24;	author claudio;	state Exp;
branches;
next	1.43;
commitid	LTeEOygtHEq8pPcX;

1.43
date	2013.10.17.17.47.04;	author renato;	state Exp;
branches;
next	1.42;

1.42
date	2013.10.15.20.41.10;	author renato;	state Exp;
branches;
next	1.41;

1.41
date	2013.10.15.20.36.30;	author renato;	state Exp;
branches;
next	1.40;

1.40
date	2013.10.15.20.31.13;	author renato;	state Exp;
branches;
next	1.39;

1.39
date	2013.10.15.20.21.26;	author renato;	state Exp;
branches;
next	1.38;

1.38
date	2013.06.04.02.39.10;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2013.06.04.02.34.48;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2013.06.04.02.25.28;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2013.06.04.01.32.16;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2013.06.04.00.56.49;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2013.06.01.19.42.07;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2013.06.01.19.28.55;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2013.06.01.18.47.07;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2013.06.01.18.24.28;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2013.06.01.18.21.45;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2013.06.01.18.16.35;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.01.01.34.57;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2013.05.31.14.10.10;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2013.05.30.16.14.50;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2011.03.12.01.57.13;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2011.01.10.12.28.25;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2010.10.26.12.22.35;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.06.08.36.33;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.06.08.28.44;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.02.14.34.04;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.30.01.47.11;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.10.10.04.10;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2010.05.28.12.27.17;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.25.09.26.12;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.19.15.28.51;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.26.16.02.18;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2010.02.25.17.40.46;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.21.20.41.35;	author michele;	state Exp;
branches;
next	1.9;

1.9
date	2010.02.20.21.05.00;	author michele;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.19.14.32.34;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.19.13.37.09;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.18.09.26.29;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.18.09.25.16;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.06.16.12.47;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.01.12.47.02;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.22.34.45;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.79
log
@Implement RFC 5919 (LDP End-of-LIB).
@
text
@/*	$OpenBSD: neighbor.c,v 1.78 2016/09/03 16:07:08 renato Exp $ */

/*
 * Copyright (c) 2013, 2016 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005, 2008 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ldpd.h"
#include "ldpe.h"
#include "lde.h"
#include "log.h"

static __inline int	 nbr_id_compare(struct nbr *, struct nbr *);
static __inline int	 nbr_addr_compare(struct nbr *, struct nbr *);
static __inline int	 nbr_pid_compare(struct nbr *, struct nbr *);
static void		 nbr_update_peerid(struct nbr *);
static void		 nbr_ktimer(int, short, void *);
static void		 nbr_start_ktimer(struct nbr *);
static void		 nbr_ktimeout(int, short, void *);
static void		 nbr_start_ktimeout(struct nbr *);
static void		 nbr_itimeout(int, short, void *);
static void		 nbr_start_itimeout(struct nbr *);
static void		 nbr_idtimer(int, short, void *);
static int		 nbr_act_session_operational(struct nbr *);
static void		 nbr_send_labelmappings(struct nbr *);

RB_GENERATE(nbr_id_head, nbr, id_tree, nbr_id_compare)
RB_GENERATE(nbr_addr_head, nbr, addr_tree, nbr_addr_compare)
RB_GENERATE(nbr_pid_head, nbr, pid_tree, nbr_pid_compare)

struct {
	int		state;
	enum nbr_event	event;
	enum nbr_action	action;
	int		new_state;
} nbr_fsm_tbl[] = {
    /* current state	event that happened	action to take		resulting state */
/* Passive Role */
    {NBR_STA_PRESENT,	NBR_EVT_MATCH_ADJ,	NBR_ACT_NOTHING,	NBR_STA_INITIAL},
    {NBR_STA_INITIAL,	NBR_EVT_INIT_RCVD,	NBR_ACT_PASSIVE_INIT,	NBR_STA_OPENREC},
    {NBR_STA_OPENREC,	NBR_EVT_KEEPALIVE_RCVD,	NBR_ACT_SESSION_EST,	NBR_STA_OPER},
/* Active Role */
    {NBR_STA_PRESENT,	NBR_EVT_CONNECT_UP,	NBR_ACT_CONNECT_SETUP,	NBR_STA_INITIAL},
    {NBR_STA_INITIAL,	NBR_EVT_INIT_SENT,	NBR_ACT_NOTHING,	NBR_STA_OPENSENT},
    {NBR_STA_OPENSENT,	NBR_EVT_INIT_RCVD,	NBR_ACT_KEEPALIVE_SEND,	NBR_STA_OPENREC},
/* Session Maintenance */
    {NBR_STA_OPER,	NBR_EVT_PDU_RCVD,	NBR_ACT_RST_KTIMEOUT,	0},
    {NBR_STA_SESSION,	NBR_EVT_PDU_RCVD,	NBR_ACT_NOTHING,	0},
    {NBR_STA_OPER,	NBR_EVT_PDU_SENT,	NBR_ACT_RST_KTIMER,	0},
    {NBR_STA_SESSION,	NBR_EVT_PDU_SENT,	NBR_ACT_NOTHING,	0},
/* Session Close */
    {NBR_STA_PRESENT,	NBR_EVT_CLOSE_SESSION,	NBR_ACT_NOTHING,	0},
    {NBR_STA_SESSION,	NBR_EVT_CLOSE_SESSION,	NBR_ACT_CLOSE_SESSION,	NBR_STA_PRESENT},
    {-1,		NBR_EVT_NOTHING,	NBR_ACT_NOTHING,	0},
};

const char * const nbr_event_names[] = {
	"NOTHING",
	"ADJACENCY MATCHED",
	"CONNECTION UP",
	"SESSION CLOSE",
	"INIT RECEIVED",
	"KEEPALIVE RECEIVED",
	"PDU RECEIVED",
	"PDU SENT",
	"INIT SENT"
};

const char * const nbr_action_names[] = {
	"NOTHING",
	"RESET KEEPALIVE TIMEOUT",
	"START NEIGHBOR SESSION",
	"RESET KEEPALIVE TIMER",
	"SETUP NEIGHBOR CONNECTION",
	"SEND INIT AND KEEPALIVE",
	"SEND KEEPALIVE",
	"CLOSE SESSION"
};

struct nbr_id_head nbrs_by_id = RB_INITIALIZER(&nbrs_by_id);
struct nbr_addr_head nbrs_by_addr = RB_INITIALIZER(&nbrs_by_addr);
struct nbr_pid_head nbrs_by_pid = RB_INITIALIZER(&nbrs_by_pid);

static __inline int
nbr_id_compare(struct nbr *a, struct nbr *b)
{
	return (ntohl(a->id.s_addr) - ntohl(b->id.s_addr));
}

static __inline int
nbr_addr_compare(struct nbr *a, struct nbr *b)
{
	if (a->af < b->af)
		return (-1);
	if (a->af > b->af)
		return (1);

	return (ldp_addrcmp(a->af, &a->raddr, &b->raddr));
}

static __inline int
nbr_pid_compare(struct nbr *a, struct nbr *b)
{
	return (a->peerid - b->peerid);
}

int
nbr_fsm(struct nbr *nbr, enum nbr_event event)
{
	struct timeval	now;
	int		old_state;
	int		new_state = 0;
	int		i;

	old_state = nbr->state;
	for (i = 0; nbr_fsm_tbl[i].state != -1; i++)
		if ((nbr_fsm_tbl[i].state & old_state) &&
		    (nbr_fsm_tbl[i].event == event)) {
			new_state = nbr_fsm_tbl[i].new_state;
			break;
		}

	if (nbr_fsm_tbl[i].state == -1) {
		/* event outside of the defined fsm, ignore it. */
		log_warnx("%s: lsr-id %s, event %s not expected in "
		    "state %s", __func__, inet_ntoa(nbr->id),
		    nbr_event_names[event], nbr_state_name(old_state));
		return (0);
	}

	if (new_state != 0)
		nbr->state = new_state;

	if (old_state != nbr->state) {
		log_debug("%s: event %s resulted in action %s and "
		    "changing state for lsr-id %s from %s to %s",
		    __func__, nbr_event_names[event],
		    nbr_action_names[nbr_fsm_tbl[i].action],
		    inet_ntoa(nbr->id), nbr_state_name(old_state),
		    nbr_state_name(nbr->state));

		if (nbr->state == NBR_STA_OPER) {
			gettimeofday(&now, NULL);
			nbr->uptime = now.tv_sec;
		}
	}

	if (nbr->state == NBR_STA_OPER || nbr->state == NBR_STA_PRESENT)
		nbr_stop_itimeout(nbr);
	else
		nbr_start_itimeout(nbr);

	switch (nbr_fsm_tbl[i].action) {
	case NBR_ACT_RST_KTIMEOUT:
		nbr_start_ktimeout(nbr);
		break;
	case NBR_ACT_RST_KTIMER:
		nbr_start_ktimer(nbr);
		break;
	case NBR_ACT_SESSION_EST:
		nbr_act_session_operational(nbr);
		nbr_start_ktimer(nbr);
		nbr_start_ktimeout(nbr);
		if (nbr->v4_enabled)
			send_address_all(nbr, AF_INET);
		if (nbr->v6_enabled)
			send_address_all(nbr, AF_INET6);
		nbr_send_labelmappings(nbr);
		break;
	case NBR_ACT_CONNECT_SETUP:
		nbr->tcp = tcp_new(nbr->fd, nbr);

		/* trigger next state */
		send_init(nbr);
		nbr_fsm(nbr, NBR_EVT_INIT_SENT);
		break;
	case NBR_ACT_PASSIVE_INIT:
		send_init(nbr);
		send_keepalive(nbr);
		break;
	case NBR_ACT_KEEPALIVE_SEND:
		nbr_start_ktimeout(nbr);
		send_keepalive(nbr);
		break;
	case NBR_ACT_CLOSE_SESSION:
		ldpe_imsg_compose_lde(IMSG_NEIGHBOR_DOWN, nbr->peerid, 0,
		    NULL, 0);
		session_close(nbr);
		break;
	case NBR_ACT_NOTHING:
		/* do nothing */
		break;
	}

	return (0);
}

struct nbr *
nbr_new(struct in_addr id, int af, int ds_tlv, union ldpd_addr *addr,
    uint32_t scope_id)
{
	struct nbr		*nbr;
	struct nbr_params	*nbrp;
	struct adj		*adj;
	struct pending_conn	*pconn;

	log_debug("%s: lsr-id %s transport-address %s", __func__,
	    inet_ntoa(id), log_addr(af, addr));

	if ((nbr = calloc(1, sizeof(*nbr))) == NULL)
		fatal(__func__);

	LIST_INIT(&nbr->adj_list);
	nbr->state = NBR_STA_PRESENT;
	nbr->peerid = 0;
	nbr->af = af;
	nbr->ds_tlv = ds_tlv;
	if (af == AF_INET || ds_tlv)
		nbr->v4_enabled = 1;
	if (af == AF_INET6 || ds_tlv)
		nbr->v6_enabled = 1;
	nbr->id = id;
	nbr->laddr = (ldp_af_conf_get(leconf, af))->trans_addr;
	nbr->raddr = *addr;
	nbr->raddr_scope = scope_id;
	nbr->conf_seqnum = 0;

	LIST_FOREACH(adj, &global.adj_list, global_entry) {
		if (adj->lsr_id.s_addr == nbr->id.s_addr) {
			adj->nbr = nbr;
			LIST_INSERT_HEAD(&nbr->adj_list, adj, nbr_entry);
		}
	}

	if (RB_INSERT(nbr_id_head, &nbrs_by_id, nbr) != NULL)
		fatalx("nbr_new: RB_INSERT(nbrs_by_id) failed");
	if (RB_INSERT(nbr_addr_head, &nbrs_by_addr, nbr) != NULL)
		fatalx("nbr_new: RB_INSERT(nbrs_by_addr) failed");

	TAILQ_INIT(&nbr->mapping_list);
	TAILQ_INIT(&nbr->withdraw_list);
	TAILQ_INIT(&nbr->request_list);
	TAILQ_INIT(&nbr->release_list);
	TAILQ_INIT(&nbr->abortreq_list);

	/* set event structures */
	evtimer_set(&nbr->keepalive_timeout, nbr_ktimeout, nbr);
	evtimer_set(&nbr->keepalive_timer, nbr_ktimer, nbr);
	evtimer_set(&nbr->init_timeout, nbr_itimeout, nbr);
	evtimer_set(&nbr->initdelay_timer, nbr_idtimer, nbr);

	nbrp = nbr_params_find(leconf, nbr->id);
	if (nbrp && pfkey_establish(nbr, nbrp) == -1)
		fatalx("pfkey setup failed");

	pconn = pending_conn_find(nbr->af, &nbr->raddr);
	if (pconn) {
		session_accept_nbr(nbr, pconn->fd);
		pending_conn_del(pconn);
	}

	return (nbr);
}

void
nbr_del(struct nbr *nbr)
{
	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));

	nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
	pfkey_remove(nbr);

	if (nbr_pending_connect(nbr))
		event_del(&nbr->ev_connect);
	nbr_stop_ktimer(nbr);
	nbr_stop_ktimeout(nbr);
	nbr_stop_itimeout(nbr);
	nbr_stop_idtimer(nbr);

	mapping_list_clr(&nbr->mapping_list);
	mapping_list_clr(&nbr->withdraw_list);
	mapping_list_clr(&nbr->request_list);
	mapping_list_clr(&nbr->release_list);
	mapping_list_clr(&nbr->abortreq_list);

	if (nbr->peerid)
		RB_REMOVE(nbr_pid_head, &nbrs_by_pid, nbr);
	RB_REMOVE(nbr_id_head, &nbrs_by_id, nbr);
	RB_REMOVE(nbr_addr_head, &nbrs_by_addr, nbr);

	free(nbr);
}

static void
nbr_update_peerid(struct nbr *nbr)
{
	static uint32_t	 peercnt = 1;

	if (nbr->peerid)
		RB_REMOVE(nbr_pid_head, &nbrs_by_pid, nbr);

	/* get next unused peerid */
	while (nbr_find_peerid(++peercnt))
		;
	nbr->peerid = peercnt;

	if (RB_INSERT(nbr_pid_head, &nbrs_by_pid, nbr) != NULL)
		fatalx("nbr_update_peerid: RB_INSERT(nbrs_by_pid) failed");
}

struct nbr *
nbr_find_ldpid(uint32_t lsr_id)
{
	struct nbr	n;
	n.id.s_addr = lsr_id;
	return (RB_FIND(nbr_id_head, &nbrs_by_id, &n));
}

struct nbr *
nbr_find_addr(int af, union ldpd_addr *addr)
{
	struct nbr	n;
	n.af = af;
	n.raddr = *addr;
	return (RB_FIND(nbr_addr_head, &nbrs_by_addr, &n));
}

struct nbr *
nbr_find_peerid(uint32_t peerid)
{
	struct nbr	n;
	n.peerid = peerid;
	return (RB_FIND(nbr_pid_head, &nbrs_by_pid, &n));
}

int
nbr_adj_count(struct nbr *nbr, int af)
{
	struct adj	*adj;
	int		 total = 0;

	LIST_FOREACH(adj, &nbr->adj_list, nbr_entry)
		if (adj_get_af(adj) == af)
			total++;

	return (total);
}

int
nbr_session_active_role(struct nbr *nbr)
{
	if (ldp_addrcmp(nbr->af, &nbr->laddr, &nbr->raddr) > 0)
		return (1);

	return (0);
}

/* timers */

/* Keepalive timer: timer to send keepalive message to neighbors */

static void
nbr_ktimer(int fd, short event, void *arg)
{
	struct nbr	*nbr = arg;

	send_keepalive(nbr);
	nbr_start_ktimer(nbr);
}

static void
nbr_start_ktimer(struct nbr *nbr)
{
	struct timeval	 tv;

	/* send three keepalives per period */
	timerclear(&tv);
	tv.tv_sec = (time_t)(nbr->keepalive / KEEPALIVE_PER_PERIOD);
	if (evtimer_add(&nbr->keepalive_timer, &tv) == -1)
		fatal(__func__);
}

void
nbr_stop_ktimer(struct nbr *nbr)
{
	if (evtimer_pending(&nbr->keepalive_timer, NULL) &&
	    evtimer_del(&nbr->keepalive_timer) == -1)
		fatal(__func__);
}

/* Keepalive timeout: if the nbr hasn't sent keepalive */

static void
nbr_ktimeout(int fd, short event, void *arg)
{
	struct nbr *nbr = arg;

	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));

	session_shutdown(nbr, S_KEEPALIVE_TMR, 0, 0);
}

static void
nbr_start_ktimeout(struct nbr *nbr)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = nbr->keepalive;

	if (evtimer_add(&nbr->keepalive_timeout, &tv) == -1)
		fatal(__func__);
}

void
nbr_stop_ktimeout(struct nbr *nbr)
{
	if (evtimer_pending(&nbr->keepalive_timeout, NULL) &&
	    evtimer_del(&nbr->keepalive_timeout) == -1)
		fatal(__func__);
}

/* Session initialization timeout: if nbr got stuck in the initialization FSM */

static void
nbr_itimeout(int fd, short event, void *arg)
{
	struct nbr *nbr = arg;

	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));

	nbr_fsm(nbr, NBR_EVT_CLOSE_SESSION);
}

static void
nbr_start_itimeout(struct nbr *nbr)
{
	struct timeval	 tv;

	timerclear(&tv);
	tv.tv_sec = INIT_FSM_TIMEOUT;
	if (evtimer_add(&nbr->init_timeout, &tv) == -1)
		fatal(__func__);
}

void
nbr_stop_itimeout(struct nbr *nbr)
{
	if (evtimer_pending(&nbr->init_timeout, NULL) &&
	    evtimer_del(&nbr->init_timeout) == -1)
		fatal(__func__);
}

/* Init delay timer: timer to retry to iniziatize session */

static void
nbr_idtimer(int fd, short event, void *arg)
{
	struct nbr *nbr = arg;

	log_debug("%s: lsr-id %s", __func__, inet_ntoa(nbr->id));

	nbr_establish_connection(nbr);
}

void
nbr_start_idtimer(struct nbr *nbr)
{
	struct timeval	tv;

	timerclear(&tv);

	tv.tv_sec = INIT_DELAY_TMR;
	switch(nbr->idtimer_cnt) {
	default:
		/* do not further increase the counter */
		tv.tv_sec = MAX_DELAY_TMR;
		break;
	case 2:
		tv.tv_sec *= 2;
		/* FALLTHROUGH */
	case 1:
		tv.tv_sec *= 2;
		/* FALLTHROUGH */
	case 0:
		nbr->idtimer_cnt++;
		break;
	}

	if (evtimer_add(&nbr->initdelay_timer, &tv) == -1)
		fatal(__func__);
}

void
nbr_stop_idtimer(struct nbr *nbr)
{
	if (evtimer_pending(&nbr->initdelay_timer, NULL) &&
	    evtimer_del(&nbr->initdelay_timer) == -1)
		fatal(__func__);
}

int
nbr_pending_idtimer(struct nbr *nbr)
{
	if (evtimer_pending(&nbr->initdelay_timer, NULL))
		return (1);

	return (0);
}

int
nbr_pending_connect(struct nbr *nbr)
{
	if (event_initialized(&nbr->ev_connect) &&
	    event_pending(&nbr->ev_connect, EV_WRITE, NULL))
		return (1);

	return (0);
}

static void
nbr_connect_cb(int fd, short event, void *arg)
{
	struct nbr	*nbr = arg;
	int		 error;
	socklen_t	 len;

	len = sizeof(error);
	if (getsockopt(nbr->fd, SOL_SOCKET, SO_ERROR, &error, &len) < 0) {
		log_warn("%s: getsockopt SOL_SOCKET SO_ERROR", __func__);
		return;
	}

	if (error) {
		close(nbr->fd);
		errno = error;
		log_debug("%s: error while connecting to %s: %s", __func__,
		    log_addr(nbr->af, &nbr->raddr), strerror(errno));
		return;
	}

	nbr_fsm(nbr, NBR_EVT_CONNECT_UP);
}

int
nbr_establish_connection(struct nbr *nbr)
{
	struct sockaddr_storage	 local_sa;
	struct sockaddr_storage	 remote_sa;
	struct adj		*adj;
	struct nbr_params	*nbrp;
	int			 opt = 1;

	nbr->fd = socket(nbr->af,
	    SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
	if (nbr->fd == -1) {
		log_warn("%s: error while creating socket", __func__);
		return (-1);
	}

	nbrp = nbr_params_find(leconf, nbr->id);
	if (nbrp && nbrp->auth.method == AUTH_MD5SIG) {
		if (sysdep.no_pfkey || sysdep.no_md5sig) {
			log_warnx("md5sig configured but not available");
			close(nbr->fd);
			return (-1);
		}
		if (setsockopt(nbr->fd, IPPROTO_TCP, TCP_MD5SIG,
		    &opt, sizeof(opt)) == -1) {
			log_warn("setsockopt md5sig");
			close(nbr->fd);
			return (-1);
		}
	}

	memcpy(&local_sa, addr2sa(nbr->af, &nbr->laddr, 0), sizeof(local_sa));
	memcpy(&remote_sa, addr2sa(nbr->af, &nbr->raddr, LDP_PORT),
	    sizeof(local_sa));
	if (nbr->af == AF_INET6 && nbr->raddr_scope)
		addscope((struct sockaddr_in6 *)&remote_sa, nbr->raddr_scope);

	if (bind(nbr->fd, (struct sockaddr *)&local_sa,
	    local_sa.ss_len) == -1) {
		log_warn("%s: error while binding socket to %s", __func__,
		    log_sockaddr((struct sockaddr *)&local_sa));
		close(nbr->fd);
		return (-1);
	}

	if (nbr_gtsm_check(nbr->fd, nbr, nbrp)) {
		close(nbr->fd);
		return (-1);
	}

	/*
	 * Send an extra hello to guarantee that the remote peer has formed
	 * an adjacency as well.
	 */
	LIST_FOREACH(adj, &nbr->adj_list, nbr_entry)
		send_hello(adj->source.type, adj->source.link.ia,
		    adj->source.target);

	if (connect(nbr->fd, (struct sockaddr *)&remote_sa,
	    remote_sa.ss_len) == -1) {
		if (errno == EINPROGRESS) {
			event_set(&nbr->ev_connect, nbr->fd, EV_WRITE,
			    nbr_connect_cb, nbr);
			event_add(&nbr->ev_connect, NULL);
			return (0);
		}
		log_warn("%s: error while connecting to %s", __func__,
		    log_sockaddr((struct sockaddr *)&remote_sa));
		close(nbr->fd);
		return (-1);
	}

	/* connection completed immediately */
	nbr_fsm(nbr, NBR_EVT_CONNECT_UP);

	return (0);
}

int
nbr_gtsm_enabled(struct nbr *nbr, struct nbr_params *nbrp)
{
	/*
	 * RFC 6720 - Section 3:
	 * "This document allows for the implementation to provide an option to
	 * statically (e.g., via configuration) and/or dynamically override the
	 * default behavior and enable/disable GTSM on a per-peer basis".
	 */
	if (nbrp && (nbrp->flags & F_NBRP_GTSM))
		return (nbrp->gtsm_enabled);

	if ((ldp_af_conf_get(leconf, nbr->af))->flags & F_LDPD_AF_NO_GTSM)
		return (0);

	/* By default, GTSM support has to be negotiated for LDPv4 */
	if (nbr->af == AF_INET && !(nbr->flags & F_NBR_GTSM_NEGOTIATED))
		return (0);

	return (1);
}

int
nbr_gtsm_setup(int fd, int af, struct nbr_params *nbrp)
{
	int	 ttl = 255;

	if (nbrp && (nbrp->flags & F_NBRP_GTSM_HOPS))
		ttl = 256 - nbrp->gtsm_hops;

	switch (af) {
	case AF_INET:
		if (sock_set_ipv4_minttl(fd, ttl) == -1)
			return (-1);
		ttl = 255;
		if (sock_set_ipv4_ucast_ttl(fd, ttl) == -1)
			return (-1);
		break;
	case AF_INET6:
		if (sock_set_ipv6_minhopcount(fd, ttl) == -1)
			return (-1);
		ttl = 255;
		if (sock_set_ipv6_ucast_hops(fd, ttl) == -1)
			return (-1);
		break;
	default:
		fatalx("nbr_gtsm_setup: unknown af");
	}

	return (0);
}

int
nbr_gtsm_check(int fd, struct nbr *nbr, struct nbr_params *nbrp)
{
	if (!nbr_gtsm_enabled(nbr, nbrp)) {
		switch (nbr->af) {
		case AF_INET:
			sock_set_ipv4_ucast_ttl(fd, -1);
			break;
		case AF_INET6:
			/*
			 * Send packets with a Hop Limit of 255 even when GSTM
			 * is disabled to guarantee interoperability.
			 */
			sock_set_ipv6_ucast_hops(fd, 255);
			break;
		default:
			fatalx("nbr_gtsm_check: unknown af");
			break;
		}
		return (0);
	}

	if (nbr_gtsm_setup(fd, nbr->af, nbrp) == -1) {
		log_warnx("%s: error enabling GTSM for lsr-id %s", __func__,
		    inet_ntoa(nbr->id));
		return (-1);
	}

	return (0);
}

static int
nbr_act_session_operational(struct nbr *nbr)
{
	struct lde_nbr	 lde_nbr;

	nbr->idtimer_cnt = 0;

	/* this is necessary to avoid ipc synchronization issues */
	nbr_update_peerid(nbr);

	memset(&lde_nbr, 0, sizeof(lde_nbr));
	lde_nbr.id = nbr->id;
	lde_nbr.v4_enabled = nbr->v4_enabled;
	lde_nbr.v6_enabled = nbr->v6_enabled;
	lde_nbr.flags = nbr->flags;
	return (ldpe_imsg_compose_lde(IMSG_NEIGHBOR_UP, nbr->peerid, 0,
	    &lde_nbr, sizeof(lde_nbr)));
}

static void
nbr_send_labelmappings(struct nbr *nbr)
{
	ldpe_imsg_compose_lde(IMSG_LABEL_MAPPING_FULL, nbr->peerid, 0,
	    NULL, 0);
}

struct nbr_params *
nbr_params_new(struct in_addr lsr_id)
{
	struct nbr_params	*nbrp;

	if ((nbrp = calloc(1, sizeof(*nbrp))) == NULL)
		fatal(__func__);

	nbrp->lsr_id = lsr_id;
	nbrp->auth.method = AUTH_NONE;

	return (nbrp);
}

struct nbr_params *
nbr_params_find(struct ldpd_conf *xconf, struct in_addr lsr_id)
{
	struct nbr_params *nbrp;

	LIST_FOREACH(nbrp, &xconf->nbrp_list, entry)
		if (nbrp->lsr_id.s_addr == lsr_id.s_addr)
			return (nbrp);

	return (NULL);
}

uint16_t
nbr_get_keepalive(int af, struct in_addr lsr_id)
{
	struct nbr_params	*nbrp;

	nbrp = nbr_params_find(leconf, lsr_id);
	if (nbrp && (nbrp->flags & F_NBRP_KEEPALIVE))
		return (nbrp->keepalive);

	return ((ldp_af_conf_get(leconf, af))->keepalive);
}

struct ctl_nbr *
nbr_to_ctl(struct nbr *nbr)
{
	static struct ctl_nbr	 nctl;
	struct timeval		 now;

	nctl.af = nbr->af;
	nctl.id = nbr->id;
	nctl.laddr = nbr->laddr;
	nctl.raddr = nbr->raddr;
	nctl.nbr_state = nbr->state;

	gettimeofday(&now, NULL);
	if (nbr->state == NBR_STA_OPER) {
		nctl.uptime = now.tv_sec - nbr->uptime;
	} else
		nctl.uptime = 0;

	return (&nctl);
}

void
nbr_clear_ctl(struct ctl_nbr *nctl)
{
	struct nbr		*nbr;

	RB_FOREACH(nbr, nbr_addr_head, &nbrs_by_addr) {
		if (ldp_addrisset(nctl->af, &nctl->raddr) &&
		    ldp_addrcmp(nctl->af, &nctl->raddr, &nbr->raddr))
			continue;

		log_debug("%s: neighbor %s manually cleared", __func__,
		    log_addr(nbr->af, &nbr->raddr));
		session_shutdown(nbr, S_SHUTDOWN, 0, 0);
	}
}
@


1.78
log
@Rework the sending of address messages.

* Respect the session's negotiated maximum pdu length and split the
  sending of our local addresses into multiple messages if necessary;

* Log sent/received addresses;

* Add new wrappers to send only one address (send_address_single)
  and to send all addresses of the given address-family
  (send_address_all). These wrappers create a temporary list of addresses
  to be sent, and send_address() then acts on this last.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.77 2016/07/01 23:29:55 renato Exp $ */
d743 1
@


1.77
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.76 2016/07/01 23:22:42 renato Exp $ */
d188 1
a188 1
			send_address(nbr, AF_INET, NULL, 0);
d190 1
a190 1
			send_address(nbr, AF_INET6, NULL, 0);
@


1.76
log
@Decrease the initialization FSM timeout.

The previous value of 180 was just too long. If a neighbor get stuck in
the initialization FSM for more than 15 seconds, then there's certainly
something wrong and the session should be dropped.

A potential case of a neighbor getting stuck in the initialization
FSM is when both the local and the remote LSRs disable the LDPv4 GTSM
negotiation and there's a mismatch in their GTSM configuration (one is
enabled for GTSM while the other is not).

In this case, a smaller timeout allows for a quicker recovery of the
session when the configuration is fixed on either side.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.75 2016/07/01 23:14:31 renato Exp $ */
d71 1
d73 1
@


1.75
log
@Add GTSM support (RFC 6720).

This also finishes the missing bits from our RFC 7552 implementation
because GTSM is mandatory for LDPv6.

To avoid any kind of interoperability problems, I included a few
knobs to enable/disable GTSM on a per-address-family and per-neighbor
basis. Cisco's LDPv6 implementation, for instance, doesn't support GTSM.

"reads good" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.74 2016/06/13 23:01:37 renato Exp $ */
d462 1
a462 1
	tv.tv_sec = DEFAULT_KEEPALIVE;
@


1.74
log
@Implement support for the Configuration Sequence Number TLV.

The Configuration Sequence Number optional TLV is documented in RFC 5036,
pages 53 and 54.

Fixes IxANVL LDP test 23.10.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.73 2016/06/13 20:19:40 renato Exp $ */
d611 5
d640 83
@


1.73
log
@Implement a timeout for the session initialization FSM.

This prevents neighbors stuck in the initialization FSM to linger forever
as long as the associated transport connection is up.

This timeout can be seen in the 'Session Initialization State Transition
Diagram' of RFC 5036. The RFC, however, doesn't specify how much we
should wait. Let's use 180 seconds for that, the default LDP hold time.

Fixes IxANVL LDP test 6.15.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.72 2016/05/23 19:20:55 renato Exp $ */
d247 1
@


1.72
log
@Add support for manually resetting neighbors.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.71 2016/05/23 19:14:03 renato Exp $ */
d44 2
d169 5
d269 1
d297 1
d440 31
@


1.71
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.70 2016/05/23 19:11:42 renato Exp $ */
d680 16
@


1.70
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.69 2016/05/23 19:09:25 renato Exp $ */
d4 1
@


1.69
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.68 2016/05/23 18:58:48 renato Exp $ */
a21 1
#include <sys/ioctl.h>
a22 2
#include <sys/socket.h>
#include <netinet/in.h>
a24 4
#include <net/if.h>

#include <ctype.h>
#include <err.h>
a25 1
#include <stdio.h>
a27 1
#include <event.h>
a30 1
#include "ldp.h"
d32 1
a32 1
#include "control.h"
a33 1
#include "lde.h"
@


1.68
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.67 2016/05/23 18:55:21 renato Exp $ */
d46 11
a56 2
void	nbr_send_labelmappings(struct nbr *);
int	nbr_act_session_operational(struct nbr *);
a57 5
static __inline int nbr_id_compare(struct nbr *, struct nbr *);
static __inline int nbr_addr_compare(struct nbr *, struct nbr *);
static __inline int nbr_pid_compare(struct nbr *, struct nbr *);

RB_HEAD(nbr_id_head, nbr);
a58 1
RB_HEAD(nbr_addr_head, nbr);
a59 1
RB_HEAD(nbr_pid_head, nbr);
a61 32
static __inline int
nbr_id_compare(struct nbr *a, struct nbr *b)
{
	return (ntohl(a->id.s_addr) - ntohl(b->id.s_addr));
}

static __inline int
nbr_addr_compare(struct nbr *a, struct nbr *b)
{
	if (a->af < b->af)
		return (-1);
	if (a->af > b->af)
		return (1);

	return (ldp_addrcmp(a->af, &a->raddr, &b->raddr));
}

static __inline int
nbr_pid_compare(struct nbr *a, struct nbr *b)
{
	return (a->peerid - b->peerid);
}

struct nbr_id_head nbrs_by_id = RB_INITIALIZER(&nbrs_by_id);
struct nbr_addr_head nbrs_by_addr = RB_INITIALIZER(&nbrs_by_addr);
struct nbr_pid_head nbrs_by_pid = RB_INITIALIZER(&nbrs_by_pid);

uint32_t	peercnt = 1;

extern struct ldpd_conf		*leconf;
extern struct ldpd_sysdep	 sysdep;

d109 27
d315 1
a315 1
void
d318 2
d383 1
a383 1
void
d392 1
a392 1
void
d414 1
a414 1
void
d424 1
a424 1
void
d446 1
a446 1
void
d608 1
a608 1
int
d626 1
a626 1
void
@


1.67
log
@Assorted fixes and small cleanup.

Nothing really interesting here.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.66 2016/05/23 18:28:22 renato Exp $ */
d69 1
a69 1
	if (ntohl(a->raddr.s_addr) < ntohl(b->raddr.s_addr))
d71 1
a71 1
	if (ntohl(a->raddr.s_addr) > ntohl(b->raddr.s_addr))
d74 1
a74 1
	return (0);
d191 4
a194 1
		send_address(nbr, NULL, 0);
d226 2
a227 1
nbr_new(struct in_addr id, struct in_addr addr)
d231 1
d234 2
a235 1
	log_debug("%s: lsr-id %s", __func__, inet_ntoa(id));
d242 7
d250 10
a259 3
	nbr->laddr = leconf->trans_addr;
	nbr->raddr = addr;
	nbr->peerid = 0;
d281 1
a281 1
	pconn = pending_conn_find(nbr->raddr);
d342 1
a342 1
nbr_find_addr(struct in_addr addr)
d345 2
a346 1
	n.raddr = addr;
d359 13
d374 1
a374 1
	if (ntohl(nbr->laddr.s_addr) > ntohl(nbr->raddr.s_addr))
d529 1
a529 1
		    inet_ntoa(nbr->raddr), strerror(errno));
d539 2
a540 2
	struct sockaddr_in	 local_sa;
	struct sockaddr_in	 remote_sa;
d545 2
a546 1
	nbr->fd = socket(AF_INET, SOCK_STREAM|SOCK_NONBLOCK|SOCK_CLOEXEC, 0);
d567 5
a571 4
	memset(&local_sa, 0, sizeof(local_sa));
	local_sa.sin_family = AF_INET;
	local_sa.sin_port = htons(0);
	local_sa.sin_addr = nbr->laddr;
d573 2
a574 2
	if (bind(nbr->fd, (struct sockaddr *) &local_sa,
	    sizeof(struct sockaddr_in)) == -1) {
d576 1
a576 1
		    inet_ntoa(local_sa.sin_addr));
a580 5
	memset(&remote_sa, 0, sizeof(remote_sa));
	remote_sa.sin_family = AF_INET;
	remote_sa.sin_port = htons(LDP_PORT);
	remote_sa.sin_addr = nbr->raddr;

d586 1
a586 1
		send_hello(adj->source.type, adj->source.link.iface,
d590 1
a590 1
	    sizeof(remote_sa)) == -1) {
d598 1
a598 1
		    inet_ntoa(nbr->raddr));
d612 2
d619 4
d624 1
a624 1
	    &nbr->id, sizeof(nbr->id)));
d661 1
a661 1
nbr_get_keepalive(struct in_addr lsr_id)
d669 1
a669 1
	return (leconf->keepalive);
d678 1
d680 2
a681 1
	nctl.addr = nbr->raddr;
@


1.66
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).

In addition, copy in_addr structs directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.65 2016/05/23 17:43:42 renato Exp $ */
a256 2
	/* init pfkey - remove old if any, load new ones */
	pfkey_remove(nbr);
d486 1
a486 1
	if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &error, &len) < 0) {
@


1.65
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d236 3
a238 3
	nbr->id.s_addr = id.s_addr;
	nbr->laddr.s_addr = leconf->trans_addr.s_addr;
	nbr->raddr.s_addr = addr.s_addr;
d537 1
a537 1
	local_sa.sin_addr.s_addr = nbr->laddr.s_addr;
d550 1
a550 1
	remote_sa.sin_addr.s_addr = nbr->raddr.s_addr;
d643 2
a644 2
	memcpy(&nctl.id, &nbr->id, sizeof(nctl.id));
	memcpy(&nctl.addr, &nbr->raddr, sizeof(nctl.addr));
@


1.64
log
@Fix fd leak in error path.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.63 2016/05/23 16:23:06 renato Exp $ */
d87 1
a87 1
u_int32_t	peercnt = 1;
d316 1
a316 1
nbr_find_peerid(u_int32_t peerid)
d319 10
a328 2
	n.peerid = peerid;
	return (RB_FIND(nbr_pid_head, &nbrs_by_pid, &n));
d332 1
a332 1
nbr_find_ldpid(u_int32_t rtr_id)
d335 2
a336 2
	n.id.s_addr = rtr_id;
	return (RB_FIND(nbr_id_head, &nbrs_by_id, &n));
d534 1
a534 1
	bzero(&local_sa, sizeof(local_sa));
d547 1
a547 1
	bzero(&remote_sa, sizeof(remote_sa));
@


1.63
log
@Reuse nbr_pending_connect() on nbr_del().
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.62 2016/05/23 16:20:59 renato Exp $ */
d515 1
d521 1
@


1.62
log
@Standardize some log messages and fix some inconsistencies.

We were using several different names for the same thing in our log
messages: neighbor, neighbor ID, nbr ID and LSR ID.

Standardize to always use "lsr-id" to refer to a neighbor.

Also:
* Use log_warnx() instead of log_warn() when appropriate;
* Use fatal(x) instead of err(x) when appropriate;
* Fix some inconsistent log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.61 2016/05/23 16:18:51 renato Exp $ */
d280 1
a280 1
	if (event_pending(&nbr->ev_connect, EV_WRITE, NULL))
@


1.61
log
@Make neighbor parameters per lsr-id not per transport-address.

With the advent of IPv6 support, a single neighbor can have two different
transport-addresses: one for ipv4 and one for ipv6. In order to define
neighbor-specific parameters in an indistinguishable way, define them
by lsr-id. This way we can switch between LDPov4 and LDPov6 and keep
the same configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.60 2016/05/23 16:16:44 renato Exp $ */
d157 1
a157 1
		log_warnx("%s: neighbor ID %s, event %s not expected in "
d168 1
a168 1
		    "changing state for neighbor ID %s from %s to %s",
d229 1
a229 1
	log_debug("%s: LSR ID %s", __func__, inet_ntoa(id));
d275 1
a275 1
	log_debug("%s: LSR ID %s", __func__, inet_ntoa(nbr->id));
d312 1
a312 1
		fatalx("nbr_new: RB_INSERT(nbrs_by_pid) failed");
d380 1
a380 1
	log_debug("%s: neighbor ID %s", __func__, inet_ntoa(nbr->id));
d412 1
a412 1
	log_debug("%s: neighbor ID %s", __func__, inet_ntoa(nbr->id));
@


1.60
log
@Rework the way we handle income connection requests.

The logic of the previous code was to accept all TCP connection requests
(destined to port 646) and create a tcp_conn structure for each them. Once
the first packet of a connection was received, we would analyze the
LDP Initialization message and identify its origin by looking at the
LSR-ID field.

When parsing a received TCP packet, we would need to distinguish between
two cases: tcp packet from an LDP neighbor and tcp packet from a newborn
connection (not associated with any neighbor yet). For this reason,
the session_read() function was quite complicated.

Also, we were not keeping track of the allocated tcp_conn structures. So,
we were subject to memory leaks and even DOS attacks.

With this patch, we also accept all TCP connection requests, but with two
major differences:
* We identify the neighbor by the source address of the SYN
  packet. This is possible because we don't support label spaces, so
  the transport-address by itself is enough to identify a neighbor,
  we don't need to wait for the Initialization message;
* If there's no matching adjacency for this neighbor, then we start a
  timer of 5 seconds. If we receive a Hello packet from this neighbor
  within this interval, then we stop this timer and move on in
  the Initialization state machine. Otherwise, we send a No Hello
  Notification message and close the socket. We try to avoid sending
  the No Hello notification as much as possible because it triggers the
  backoff exponential in the remote peer, which considerably slow down
  the session establishment process.

In summary, this new approach allows for a simpler code and fixes the
memory leak problem mentioned before.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.59 2016/05/23 15:59:55 renato Exp $ */
d259 1
a259 1
	nbrp = nbr_params_find(leconf, nbr->raddr);
d511 1
a511 1
	nbrp = nbr_params_find(leconf, nbr->raddr);
d590 1
a590 1
nbr_params_new(struct in_addr addr)
d597 1
a597 1
	nbrp->addr.s_addr = addr.s_addr;
d604 1
a604 1
nbr_params_find(struct ldpd_conf *xconf, struct in_addr addr)
d609 1
a609 1
		if (nbrp->addr.s_addr == addr.s_addr)
d616 1
a616 1
nbr_get_keepalive(struct in_addr addr)
d620 1
a620 1
	nbrp = nbr_params_find(leconf, addr);
@


1.59
log
@Fix issue with the exponential backoff timer.

Do not start the exponential backoff timer when playing the passive role
of the session establishment process.

RFC 5036 - Section 2.5.3 says:
"The specific session establishment action that must be
delayed is the attempt to open the session transport connection by
the LSR playing the active role".
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.58 2016/05/23 15:57:50 renato Exp $ */
d50 1
d55 2
d67 11
d84 1
d227 1
d243 2
d263 6
d295 1
@


1.58
log
@Remove duplicated code in timer functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.57 2016/05/23 15:49:31 renato Exp $ */
d389 1
a389 4
	if (nbr_session_active_role(nbr))
		nbr_establish_connection(nbr);
	else if (nbr->state == NBR_STA_INITIAL)
		nbr_fsm(nbr, NBR_EVT_INIT_RCVD);
@


1.57
log
@We don't need a separate function for sending address withdraws.

Address and Address Withdraw messages have the exact same format, only
their type is different.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.56 2016/05/23 15:47:24 renato Exp $ */
a322 1
	struct timeval	 tv;
d325 1
a325 5

	timerclear(&tv);
	tv.tv_sec = (time_t)(nbr->keepalive / KEEPALIVE_PER_PERIOD);
	if (evtimer_add(&nbr->keepalive_timer, &tv) == -1)
		fatal(__func__);
d331 1
a331 1
	struct timeval	tv;
d333 1
a334 2

	/* XXX: just to be sure it will send three keepalives per period */
a335 1

@


1.56
log
@Move some code around.

This patch doesn't introduce any logical change.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.55 2016/05/23 15:43:11 renato Exp $ */
d176 1
a176 1
		send_address(nbr, NULL);
@


1.55
log
@Add knob to configure the transport address.

This will be especially important when we add support for IPv6, because
we'll not be able to use the router-id as the transport-address in
this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.54 2016/05/23 15:41:04 renato Exp $ */
a52 1
RB_PROTOTYPE(nbr_id_head, nbr, id_tree, nbr_id_compare)
a54 1
RB_PROTOTYPE(nbr_pid_head, nbr, pid_tree, nbr_pid_compare)
a628 14
}

void
ldpe_nbr_ctl(struct ctl_conn *c)
{
	struct nbr	*nbr;
	struct ctl_nbr	*nctl;

	RB_FOREACH(nbr, nbr_pid_head, &nbrs_by_pid) {
		nctl = nbr_to_ctl(nbr);
		imsg_compose_event(&c->iev, IMSG_CTL_SHOW_NBR, 0, 0, -1, nctl,
		    sizeof(struct ctl_nbr));
	}
	imsg_compose_event(&c->iev, IMSG_CTL_END, 0, 0, -1, NULL, 0);
@


1.54
log
@Allow setting the session holdtime per neighbor.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.53 2016/05/23 15:14:07 renato Exp $ */
d223 2
a224 1
	nbr->addr.s_addr = addr.s_addr;
d243 1
a243 1
	nbrp = nbr_params_find(leconf, nbr->addr);
d311 1
a311 1
	if (ntohl(ldpe_router_id()) > ntohl(nbr->addr.s_addr))
d476 1
a476 1
		    inet_ntoa(nbr->addr), strerror(errno));
d498 1
a498 1
	nbrp = nbr_params_find(leconf, nbr->addr);
d514 1
a514 1
	local_sa.sin_addr.s_addr = ldpe_router_id();
d527 1
a527 1
	remote_sa.sin_addr.s_addr = nbr->addr.s_addr;
d546 1
a546 1
		    inet_ntoa(nbr->addr));
d621 1
a621 1
	memcpy(&nctl.addr, &nbr->addr, sizeof(nctl.addr));
@


1.53
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.52 2015/07/21 05:02:57 renato Exp $ */
d599 12
@


1.52
log
@Rename, move and reuse mapping list functions.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.51 2015/07/21 05:01:46 renato Exp $ */
d144 3
a146 4
		log_warnx("nbr_fsm: neighbor ID %s, "
		    "event %s not expected in state %s",
		    inet_ntoa(nbr->id), nbr_event_names[event],
		    nbr_state_name(old_state));
d154 1
a154 1
		log_debug("nbr_fsm: event %s resulted in action %s and "
d156 1
a156 1
		    nbr_event_names[event],
d215 1
a215 1
	log_debug("nbr_new: LSR ID %s", inet_ntoa(id));
d218 1
a218 1
		fatal("nbr_new");
d252 1
a252 1
	log_debug("nbr_del: LSR ID %s", inet_ntoa(nbr->id));
d331 1
a331 1
		fatal("nbr_ktimer");
d345 1
a345 1
		fatal("nbr_start_ktimer");
d353 1
a353 1
		fatal("nbr_stop_ktimer");
d363 1
a363 1
	log_debug("nbr_ktimeout: neighbor ID %s", inet_ntoa(nbr->id));
d377 1
a377 1
		fatal("nbr_start_ktimeout");
d385 1
a385 1
		fatal("nbr_stop_ktimeout");
d395 1
a395 1
	log_debug("nbr_idtimer: neighbor ID %s", inet_ntoa(nbr->id));
d428 1
a428 1
		fatal("nbr_start_idtimer");
d436 1
a436 1
		fatal("nbr_stop_idtimer");
d467 1
a467 1
		log_warn("nbr_connect_cb getsockopt SOL_SOCKET SO_ERROR");
d474 2
a475 3
		log_debug("nbr_connect_cb: error while "
		    "connecting to %s: %s", inet_ntoa(nbr->addr),
		    strerror(errno));
d493 1
a493 2
		log_warn("nbr_establish_connection: error while "
		    "creating socket");
d517 2
a518 2
		log_warn("nbr_establish_connection: error while "
		    "binding socket to %s", inet_ntoa(local_sa.sin_addr));
d544 2
a545 2
		log_warn("nbr_establish_connection: error while "
		    "connecting to %s", inet_ntoa(nbr->addr));
d581 1
a581 1
		fatal("nbr_params_new");
@


1.51
log
@Remove more unused defines.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.50 2015/07/21 04:58:48 renato Exp $ */
a575 24
}

void
nbr_mapping_add(struct nbr *nbr, struct mapping_head *mh, struct map *map)
{
	struct mapping_entry	*me;

	me = calloc(1, sizeof(*me));
	if (me == NULL)
		fatal("nbr_mapping_add");
	me->map = *map;

	TAILQ_INSERT_TAIL(mh, me, entry);
}

void
mapping_list_clr(struct mapping_head *mh)
{
	struct mapping_entry	*me;

	while ((me = TAILQ_FIRST(mh)) != NULL) {
		TAILQ_REMOVE(mh, me, entry);
		free(me);
	}
@


1.50
log
@Fix some awful ipc synchronization issues.

Under some rare circumstances the following can happen:
1 - one neighbor sends a label withdraw followed by a fatal notification
    message;
2 - ldpe parses the label withdraw and sends it to lde;
3 - ldpe parses the fatal notification message and closes the session;
4 - lde processes the label withdraw and asks ldpe to send a label release;
5 - at around the same time, ldpe restarts the session with the neighbor;
6 - ldpe processes the lde message and then sends a label release to the new
    neighbor.

The problem is that we don't want a message enqueue to a neighbor to be sent
after the session is restarted. If a session is closed, all the enqueued
messages should be discarded.

To acomplish this, we update the peerid of the nbr structure everytime the
session is established.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.49 2015/07/21 04:43:28 renato Exp $ */
d74 1
a74 1
u_int32_t	peercnt = NBR_CNTSTART;
@


1.49
log
@Add configuration reload support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.48 2015/07/19 21:04:38 renato Exp $ */
d225 1
a226 7
	/* get next unused peerid */
	while (nbr_find_peerid(++peercnt))
		;
	nbr->peerid = peercnt;

	if (RB_INSERT(nbr_pid_head, &nbrs_by_pid, nbr) != NULL)
		fatalx("nbr_new: RB_INSERT(nbrs_by_pid) failed");
d270 2
a271 1
	RB_REMOVE(nbr_pid_head, &nbrs_by_pid, nbr);
d277 15
d364 1
a364 2
	log_debug("nbr_ktimeout: neighbor ID %s peerid %u", inet_ntoa(nbr->id),
	    nbr->peerid);
d396 1
a396 2
	log_debug("nbr_idtimer: neighbor ID %s peerid %u", inet_ntoa(nbr->id),
	    nbr->peerid);
d563 3
@


1.48
log
@Add missing LIST_INIT's.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.47 2015/07/19 21:01:56 renato Exp $ */
d249 1
a249 1
	nbrp = nbr_params_find(nbr->addr);
d492 1
a492 1
	nbrp = nbr_params_find(nbr->addr);
d606 1
a606 1
nbr_params_find(struct in_addr addr)
d610 1
a610 1
	LIST_FOREACH(nbrp, &leconf->nbrp_list, entry)
@


1.47
log
@Implement md5 authentication support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.46 2015/07/19 20:50:03 renato Exp $ */
d221 1
@


1.46
log
@Remove incomplete support for unnecessary modes of  operation.

LDP has several modes of operation, it was designed in that way so it
could run on legacy equipment like ATM/FR switches with very strict
memory limitations.

For modern hardware there's no point on using either the "Conservative
Label Retention" or "Downstream On Demand" modes of operation since they
save memory at cost of blackholing traffic when routing changes. Major
vendors implement only the "Liberal Label Retention" and "Downstream
Unsolicited" modes for non ATM/FR hardware. Let's do that too.

As for using either "Independent Control" or "Ordered Control", let's
stick with the first option mainly because it's easier to implement
and because it doesn't really matter which control mode is used. For
reference, Cisco implements only "Independent Control" and Juniper only
"Ordered Control". Both modes are interoperable.

The point of supporting only one combination of all modes of operation
is that it will allow for the writing of a simpler code without removing
useful functionality.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.45 2015/03/21 18:34:01 renato Exp $ */
d26 1
d76 2
a77 1
extern struct ldpd_conf	*leconf;
d213 2
a214 1
	struct nbr	*nbr;
d246 6
d261 1
d478 2
a479 2
	struct sockaddr_in	local_sa;
	struct sockaddr_in	remote_sa;
d481 2
d491 13
d588 26
@


1.45
log
@Remove unused variables and functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.44 2015/02/09 11:54:24 claudio Exp $ */
d537 2
a538 4
	if (leconf->mode & MODE_ADV_UNSOLICITED) {
		ldpe_imsg_compose_lde(IMSG_LABEL_MAPPING_FULL, nbr->peerid, 0,
		    NULL, 0);
	}
@


1.44
log
@More SOCK_NONBLOCK | SOCK_CLOEXEC love and one less session_socket_blockmode
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.43 2013/10/17 17:47:04 renato Exp $ */
a553 27
}

struct mapping_entry *
nbr_mapping_find(struct nbr *nbr, struct mapping_head *mh, struct map *map)
{
	struct mapping_entry	*me = NULL;

	TAILQ_FOREACH(me, mh, entry) {
		if (me->map.prefix.s_addr == map->prefix.s_addr &&
		    me->map.prefixlen == map->prefixlen)
			return (me);
	}

	return (NULL);
}

void
nbr_mapping_del(struct nbr *nbr, struct mapping_head *mh, struct map *map)
{
	struct mapping_entry	*me;

	me = nbr_mapping_find(nbr, mh, map);
	if (me == NULL)
		return;

	TAILQ_REMOVE(mh, me, entry);
	free(me);
@


1.43
log
@Improve parsing of label mapping messages and merge all recv_label*
functions into a single generic function.

Add a few error checks and implement parsing of optional tlvs.
Putting it all together helps avoid to code duplication and improve
maintainability.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.42 2013/10/15 20:41:10 renato Exp $ */
d472 1
a472 1
	nbr->fd = socket(AF_INET, SOCK_STREAM, 0);
a477 2

	session_socket_blockmode(nbr->fd, BM_NONBLOCK);
@


1.42
log
@Minor fixes on if_del() and nbr_new().

if_del(): this function is always called after an IF_EVT_DOWN event so
there's no need to cleanup things here;

nbr_new(): C structs shouldn't be copied directly.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.41 2013/10/15 20:36:30 renato Exp $ */
d259 5
a263 5
	nbr_mapping_list_clr(nbr, &nbr->mapping_list);
	nbr_mapping_list_clr(nbr, &nbr->withdraw_list);
	nbr_mapping_list_clr(nbr, &nbr->request_list);
	nbr_mapping_list_clr(nbr, &nbr->release_list);
	nbr_mapping_list_clr(nbr, &nbr->abortreq_list);
d586 1
a586 1
nbr_mapping_list_clr(struct nbr *nbr, struct mapping_head *mh)
@


1.41
log
@Simplify the lde_nbr_new() function.

There's no need the pass a whole lde_nbr structure as argument if we
want only the neighbor IP address.

Also, remove the lde_nbr_del() prototype on lde.h because it's a
duplicate.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.40 2013/10/15 20:31:13 renato Exp $ */
d220 1
a220 1
	nbr->addr = addr;
@


1.40
log
@Improve debug and error logs.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.39 2013/10/15 20:21:26 renato Exp $ */
a529 2
	struct lde_nbr	 rn;

d532 2
a533 5
	bzero(&rn, sizeof(rn));
	rn.id.s_addr = nbr->id.s_addr;

	return (ldpe_imsg_compose_lde(IMSG_NEIGHBOR_UP, nbr->peerid, 0, &rn,
	    sizeof(rn)));
@


1.39
log
@Fix whitespace and other style issues.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.38 2013/06/04 02:39:10 claudio Exp $ */
d343 1
a343 1
	log_debug("nbr_ktimeout: neighbor ID %s peerid %lu", inet_ntoa(nbr->id),
d376 1
a376 1
	log_debug("nbr_idtimer: neighbor ID %s peerid %lu", inet_ntoa(nbr->id),
d457 2
a458 1
		    "connecting to %s", inet_ntoa(nbr->addr));
d474 1
a474 1
		log_debug("nbr_establish_connection: error while "
d488 1
a488 1
		log_debug("nbr_establish_connection: error while "
d515 1
a515 1
		log_debug("nbr_establish_connection: error while "
@


1.38
log
@Speed-up the session establishment process
* Send an extra Hello message before attempting to connect to a remote
  peer to guarantee that it formed an adjacency with us as well;
* Don't wait for the first timeout to send the first Hello message.
Both tricks together will allow for fast session establish since with both
optimizations passive role neighbors can open the connection immediatly by
sending and receiving the hellos at the same time as the TCP session.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.37 2013/06/04 02:34:48 claudio Exp $ */
d291 1
a291 1
		return 1;
d293 1
a293 1
	return 0;
@


1.37
log
@Always accept TCP connection requests and identify to which neighbor
it belongs only _after_ receiving an Initialization message containing
the information we need. Before an Initialization message is received,
the TCP connection shouldn't be associated with any neighbor/adjacency.
Therefor refactor that part into a own module.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.36 2013/06/04 02:25:28 claudio Exp $ */
d469 1
d497 8
@


1.36
log
@Implement support for adjacencies and targeted hellos
Refactor adjacencies out of the neighbor handling so that it is possible to
have more complex topologies with targeted sessions.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.35 2013/06/04 01:32:16 claudio Exp $ */
a48 1
static __inline int nbr_addr_compare(struct nbr *, struct nbr *);
a53 3
RB_HEAD(nbr_addr_head, nbr);
RB_PROTOTYPE(nbr_addr_head, nbr, addr_tree, nbr_addr_compare)
RB_GENERATE(nbr_addr_head, nbr, addr_tree, nbr_addr_compare)
a64 6
nbr_addr_compare(struct nbr *a, struct nbr *b)
{
	return (ntohl(a->addr.s_addr) - ntohl(b->addr.s_addr));
}

static __inline int
a70 1
struct nbr_addr_head nbrs_by_addr = RB_INITIALIZER(&nbrs_by_addr);
a83 1
    {NBR_STA_PRESENT,	NBR_EVT_CONNECT_UP,	NBR_ACT_CONNECT_SETUP,	NBR_STA_INITIAL},
d85 1
d89 1
d103 1
d181 1
a181 1
		nbr_act_connect_setup(nbr);
d183 3
a185 5
		if (nbr_session_active_role(nbr)) {
			/* trigger next state */
			send_init(nbr);
			nbr_fsm(nbr, NBR_EVT_INIT_SENT);
		}
a216 2
	if ((nbr->rbuf = calloc(1, sizeof(struct ibuf_read))) == NULL)
		fatal("nbr_new");
a228 2
	if (RB_INSERT(nbr_addr_head, &nbrs_by_addr, nbr) != NULL)
		fatalx("nbr_new: RB_INSERT(nbrs_by_addr) failed");
a265 1
	RB_REMOVE(nbr_addr_head, &nbrs_by_addr, nbr);
a267 1
	free(nbr->rbuf);
a279 8
nbr_find_ip(u_int32_t addr)
{
	struct nbr	n;
	n.addr.s_addr = addr;
	return (RB_FIND(nbr_addr_head, &nbrs_by_addr, &n));
}

struct nbr *
a516 8
void
nbr_act_connect_setup(struct nbr *nbr)
{
	evbuf_init(&nbr->wbuf, nbr->fd, session_write, nbr);
	event_set(&nbr->rev, nbr->fd, EV_READ | EV_PERSIST, session_read, nbr);
	event_add(&nbr->rev, NULL);
}

d616 1
a616 1
	RB_FOREACH(nbr, nbr_addr_head, &nbrs_by_addr) {
@


1.35
log
@Properly implement the exponential backoff timer on session initialization

According with the section 2.5.3 of RFC 5036, an LSR must throttle its
session setup retry attempts with an exponential backoff in situations
where Initialization messages are being NAK'd (because of disagreements
on session parameters). It doesn't mention using this procedure for TCP
connection failures. With that said, start the inactive delay timer only
after receiving an appropriate notification message.

When playing the active role of the initialization process, throttle the
session setup retry attempts by not connecting to the remote peer. When
playing the passive role, throttle the session setup retry attempts by
delaying the processing of the received Initialization message.

Diff by Renato Westphal, adjusted by myself
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.34 2013/06/04 00:56:49 claudio Exp $ */
a94 3
/* Discovery States */
    {NBR_STA_DOWN,	NBR_EVT_HELLO_RCVD,	NBR_ACT_STRT_ITIMER,	NBR_STA_PRESENT},
    {NBR_STA_SESSION,	NBR_EVT_HELLO_RCVD,	NBR_ACT_RST_ITIMER,	0},
d106 1
a112 1
	"HELLO RECEIVED",
a123 2
	"START INACTIVITY TIMER",
	"RESET INACTIVITY TIMER",
a175 7
	case NBR_ACT_RST_ITIMER:
	case NBR_ACT_STRT_ITIMER:
		if (nbr->holdtime != INFINITE_HOLDTIME)
			nbr_start_itimer(nbr);
		else
			nbr_stop_itimer(nbr);
		break;
d231 1
a231 1
	nbr->state = NBR_STA_DOWN;
a253 1
	evtimer_set(&nbr->inactivity_timer, nbr_itimer, nbr);
a269 1
	nbr_stop_itimer(nbr);
a322 33
/* Inactivity timer: timeout based on hellos */
/* ARGSUSED */
void
nbr_itimer(int fd, short event, void *arg)
{
	struct nbr *nbr = arg;

	log_debug("nbr_itimer: neighbor ID %s peerid %lu", inet_ntoa(nbr->id),
	    nbr->peerid);

	nbr_del(nbr);
}

void
nbr_start_itimer(struct nbr *nbr)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = nbr->holdtime;

	if (evtimer_add(&nbr->inactivity_timer, &tv) == -1)
		fatal("nbr_start_itimer");
}

void
nbr_stop_itimer(struct nbr *nbr)
{
	if (evtimer_pending(&nbr->inactivity_timer, NULL) &&
	    evtimer_del(&nbr->inactivity_timer) == -1)
		fatal("nbr_stop_itimer");
}

d628 1
a628 1
	struct timeval		 tv, now, res;
a634 9
	if (evtimer_pending(&nbr->inactivity_timer, &tv)) {
		timersub(&tv, &now, &res);
		if (nbr->state & NBR_STA_DOWN)
			nctl.dead_timer = DEFAULT_NBR_TMOUT - res.tv_sec;
		else
			nctl.dead_timer = res.tv_sec;
	} else
		nctl.dead_timer = 0;

@


1.34
log
@Minor adjustments in the initialization FSM
* Remove the unused NBR_EVT_DOWN event;
* Print the FSM transitions before performing the appropriate actions. In
  this way nested calls to nbr_fsm() won't print the state transitions in
  reverse order;
* When playing the active role of the initialization process, transition
  from NBA_STA_PRESENT to NBR_STA_INITIAL before going to NBR_STA_OPENSENT;
* Call session_shutdown() on nbr_ktimeout() to remove duplicated code;
* Notify the lde process when a neighbor is deleted (discovery timeout);
* Fix a few memory leaks on nbr_del().
Diff from Renato Westphal.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.33 2013/06/01 19:42:07 claudio Exp $ */
a221 1
		nbr_start_idtimer(nbr);
a447 3
	if (!nbr_session_active_role(nbr))
		return;

d451 4
a454 1
	nbr_establish_connection(nbr);
d463 1
d465 15
a578 1
		nbr_start_idtimer(nbr);
d601 2
@


1.33
log
@Restart the keepalive timer whenever a LDP PDU is sent. There is no need
to send a keepalive packet when a other PDU was sent out.
Also add a missing NBR_EVT_PDU_RCVD call to recv_address() which restarts
the session keepalive timeout. All other places already do that.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.32 2013/06/01 19:28:55 claudio Exp $ */
d98 1
a99 1
    {NBR_STA_PRESENT,	NBR_EVT_CONNECT_UP,	NBR_ACT_CONNECT_SETUP,	NBR_STA_INITIAL},
d103 1
a103 1
    {NBR_STA_PRESENT,	NBR_EVT_INIT_SENT,	NBR_ACT_NOTHING,	NBR_STA_OPENSENT},
a109 1
    {NBR_STA_SESSION,	NBR_EVT_DOWN,		NBR_ACT_CLOSE_SESSION,	},
d122 1
a122 2
	"INIT SENT",
	"DOWN"
d144 1
a144 1
	int		i, ret = 0;
d163 16
a178 1
	ret = 0;
d202 7
a208 1
		ret = nbr_act_connect_setup(nbr, 0);
d229 1
a229 25
	if (ret) {
		log_warnx("nbr_fsm: error changing state for neighbor ID %s, "
		    "event %s, state %s", inet_ntoa(nbr->id),
		    nbr_event_names[event], nbr_state_name(old_state));
		return (-1);
	}

	if (new_state != 0)
		nbr->state = new_state;

	if (old_state != nbr->state) {
		log_debug("nbr_fsm: event %s resulted in action %s and "
		    "changing state for neighbor ID %s from %s to %s",
		    nbr_event_names[event],
		    nbr_action_names[nbr_fsm_tbl[i].action],
		    inet_ntoa(nbr->id), nbr_state_name(old_state),
		    nbr_state_name(nbr->state));

		if (nbr->state == NBR_STA_OPER) {
			gettimeofday(&now, NULL);
			nbr->uptime = now.tv_sec;
		}
	}

	return (ret);
d233 1
a233 1
nbr_new(u_int32_t nbr_id, struct in_addr a)
d237 2
d245 2
a246 2
	nbr->id.s_addr = nbr_id;
	nbr->addr = a;
d278 3
a280 1
	session_close(nbr);
d290 4
d419 1
a419 3
	send_notification_nbr(nbr, S_KEEPALIVE_TMR, 0, 0);
	/* XXX race, send_notification_nbr() has no chance to be sent */
	session_close(nbr);
d518 1
a518 1
	nbr_act_connect_setup(nbr, 1);
d570 3
a572 1
	return (nbr_act_connect_setup(nbr, 1));
d575 2
a576 2
int
nbr_act_connect_setup(struct nbr *nbr, int active)
a580 7

	if (active) {
		send_init(nbr);
		nbr_fsm(nbr, NBR_EVT_INIT_SENT);
	}

	return (0);
@


1.32
log
@The keepalive timeout should be configured on a global basis and not per
interface.
Remove the iface pointer from the 'nbr' structure because it's not
needed anymore.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.31 2013/06/01 18:47:07 claudio Exp $ */
d107 1
d122 1
@


1.31
log
@Drop support for per-interface labelspaces.
Support for per-interface labelspaces is only necessary for legacy ATM/FR
interfaces running in cell-mode. We shouldn't worry about this.
For platform-wide label spaces the label space id is always 0.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.30 2013/06/01 18:24:28 claudio Exp $ */
d236 1
a236 1
nbr_new(u_int32_t nbr_id, struct iface *iface, struct in_addr a)
a246 1
	nbr->iface = iface;
a662 1
	memcpy(nctl.name, nbr->iface->name, sizeof(nctl.name));
a664 1

a665 1
	nctl.iface_state = nbr->iface->state;
@


1.30
log
@Use the nbr_stop_[*]timer functions
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.29 2013/06/01 18:21:45 claudio Exp $ */
a64 2
	if (ntohl(a->id.s_addr) - ntohl(b->id.s_addr) == 0)
		return (a->lspace - b->lspace);
d236 1
a236 2
nbr_new(u_int32_t nbr_id, u_int16_t lspace, struct iface *iface,
    struct in_addr a)
a246 1
	nbr->lspace = lspace;
d316 1
a316 1
nbr_find_ldpid(u_int32_t rtr_id, u_int16_t lspace)
a319 1
	n.lspace = lspace;
a592 1
	rn.lspace = nbr->lspace;
@


1.29
log
@After sending a keepalive message in the OPENSENT state, we must move to
the OPENREC state and wait for a keepalive before considering the
session as established
Another bug fix by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.28 2013/06/01 18:16:35 claudio Exp $ */
d288 4
a291 8
	if (evtimer_pending(&nbr->inactivity_timer, NULL))
		evtimer_del(&nbr->inactivity_timer);
	if (evtimer_pending(&nbr->keepalive_timer, NULL))
		evtimer_del(&nbr->keepalive_timer);
	if (evtimer_pending(&nbr->keepalive_timeout, NULL))
		evtimer_del(&nbr->keepalive_timeout);
	if (evtimer_pending(&nbr->initdelay_timer, NULL))
		evtimer_del(&nbr->initdelay_timer);
d367 2
a368 1
	if (evtimer_del(&nbr->inactivity_timer) == -1)
d405 2
a406 1
	if (evtimer_del(&nbr->keepalive_timer) == -1)
d440 2
a441 1
	if (evtimer_del(&nbr->keepalive_timeout) == -1)
d476 2
a477 1
	if (evtimer_del(&nbr->initdelay_timer) == -1)
@


1.28
log
@After returning from accept, we got a TCP connection not a LDP session.
Rename event/actions in the discovery FSM to avoid confusion
* NBR_EVT_SESSION_UP -> NBR_EVT_CONNECT_UP
* NBR_ACT_SESSION_EST -> NBR_ACT_CONNECT_SETUP
* nbr_act_session_establish -> nbr_act_connect_setup
* NBR_ACT_INIT_SEND -> NBR_ACT_PASSIVE_INIT
* NBR_ACT_STRT_KTIMER -> NBR_ACT_SESSION_EST
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.27 2013/06/01 01:34:57 claudio Exp $ */
d106 1
a106 1
    {NBR_STA_OPENSENT,	NBR_EVT_INIT_RCVD,	NBR_ACT_KEEPALIVE_SEND,	NBR_STA_OPER},
a195 2
		nbr_act_session_operational(nbr);
		nbr_start_ktimer(nbr);
a197 2
		send_address(nbr, NULL);
		nbr_send_labelmappings(nbr);
@


1.27
log
@Always advertise the Router-ID as the transport address.
RFC 5036 - Section 2.5.2 says:
    An LSR MUST advertise the same transport address in all
    Hellos that advertise the same label space...
To satisfy this condition, always advertise the Router-ID as the
transport address by using the "IPv4 Transport Address" TLV in the
generated Hello messages.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.26 2013/05/31 14:10:10 claudio Exp $ */
d101 3
a103 3
    {NBR_STA_PRESENT,	NBR_EVT_SESSION_UP,	NBR_ACT_SESSION_EST,	NBR_STA_INITIAL},
    {NBR_STA_INITIAL,	NBR_EVT_INIT_RCVD,	NBR_ACT_INIT_SEND,	NBR_STA_OPENREC},
    {NBR_STA_OPENREC,	NBR_EVT_KEEPALIVE_RCVD,	NBR_ACT_STRT_KTIMER,	NBR_STA_OPER},
d118 1
a118 1
	"SESSION UP",
d132 1
a132 1
	"START KEEPALIVE TIMER",
d134 2
a135 2
	"START NEIGHBOR SESSION",
	"SEND INIT",
d181 1
a181 1
	case NBR_ACT_STRT_KTIMER:
d188 2
a189 2
	case NBR_ACT_SESSION_EST:
		ret = nbr_act_session_establish(nbr, 0);
d191 1
a191 1
	case NBR_ACT_INIT_SEND:
d525 1
a525 1
	nbr_act_session_establish(nbr, 1);
d577 1
a577 1
	return (nbr_act_session_establish(nbr, 1));
d581 1
a581 1
nbr_act_session_establish(struct nbr *nbr, int active)
@


1.26
log
@When the ldpe process calls connect(), it doesn't regain control until
either the connection is made or an error occurs. The time the process
is blocked can be significantly large to the point of other LDP sessions
being torn down because of their holdtime. Besides that, the ldpctl
program gets unresponsive if the ldpe process is blocked. Fix these
issues by using a non-blocking connect.
Diff from Renato Westphal [renatowestphal at gmail.com]
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.25 2013/05/30 16:14:50 claudio Exp $ */
d336 9
d457 1
a457 1
	if (ntohl(nbr->addr.s_addr) >= ntohl(nbr->iface->addr.s_addr))
d531 2
a532 6
	struct sockaddr_in	in;

	bzero(&in, sizeof(in));
	in.sin_family = AF_INET;
	in.sin_port = htons(LDP_PORT);
	in.sin_addr.s_addr = nbr->addr.s_addr;
d543 20
a562 1
	if (connect(nbr->fd, (struct sockaddr *)&in, sizeof(in)) == -1) {
@


1.25
log
@Simplify hello holdtime calculation and stop the timeout timer if the
holdtime is "infinite".
Diff from Renato Westphal [renatowestphal at gmail.com]
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.24 2011/03/12 01:57:13 claudio Exp $ */
d31 1
a44 1
int	nbr_establish_connection(struct nbr *);
d290 2
d454 1
a454 1
	nbr_act_session_establish(nbr, 1);
d486 34
d536 2
d539 6
d552 2
a553 1
	return (0);
a558 5
	if (active) {
		if (nbr_establish_connection(nbr) < 0)
			return (-1);
	}

@


1.24
log
@Bad bad Claudio. Fix an evil bug that caused nbr addr_tree corruption.
Do not insert neighbors first to the address tree and then assign the
address to the struct. Instead pass the address to nbr_new() so all
keys for the various RB trees are available when setting the neighbor up.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.23 2011/01/10 12:28:25 claudio Exp $ */
d170 4
a173 1
		nbr_start_itimer(nbr);
@


1.23
log
@Fix a bad heritage from ospfd. Make neighbors independent of interfaces.
They are not bound as strongly as in ospf and causes problems when the
TCP connection is established from an not connected IP (e.g. a loopback).
Use three RB trees to sort the neighbor list by id, addr and peerid.
More cleanup is needed but this makes ldpd work against peers using
loopback IPs. Problem found, reported and fix tested again by Marcel Wiget.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.22 2010/10/26 12:22:35 claudio Exp $ */
d239 2
a240 1
nbr_new(u_int32_t nbr_id, u_int16_t lspace, struct iface *iface)
d253 1
@


1.22
log
@struct mapping_entry should just have a struct map instead of own
definition of a FEC mapping. This makes extending struct map simpler
and makes it possible to access the additional data in struct map.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.21 2010/09/06 08:36:33 claudio Exp $ */
d40 1
d48 3
a50 1
LIST_HEAD(nbr_head, nbr);
d52 9
a60 4
struct nbr_table {
	struct nbr_head		*hashtbl;
	u_int32_t		 hashmask;
} nbrtable;
d62 23
a84 2
#define NBR_HASH(x)		\
	&nbrtable.hashtbl[(x) & nbrtable.hashmask]
a237 17
void
nbr_init(u_int32_t hashsize)
{
	u_int32_t        hs, i;

	for (hs = 1; hs < hashsize; hs <<= 1)
		;
	nbrtable.hashtbl = calloc(hs, sizeof(struct nbr_head));
	if (nbrtable.hashtbl == NULL)
		fatal("nbr_init");

	for (i = 0; i < hs; i++)
		LIST_INIT(&nbrtable.hashtbl[i]);

	nbrtable.hashmask = hs - 1;
}

a240 1
	struct nbr_head	*head;
d251 1
a256 2
	head = NBR_HASH(nbr->peerid);
	LIST_INSERT_HEAD(head, nbr, hash);
d258 6
a263 3
	/* add to peer list */
	nbr->iface = iface;
	LIST_INSERT_HEAD(&iface->nbr_list, nbr, entry);
d296 3
a298 2
	LIST_REMOVE(nbr, entry);
	LIST_REMOVE(nbr, hash);
d307 3
a309 11
	struct nbr_head	*head;
	struct nbr	*nbr;

	head = NBR_HASH(peerid);

	LIST_FOREACH(nbr, head, hash) {
		if (nbr->peerid == peerid)
			return (nbr);
	}

	return (NULL);
d313 1
a313 1
nbr_find_ip(struct iface *iface, u_int32_t rtr_id)
d315 3
a317 8
	struct nbr	*nbr;

	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr->addr.s_addr == rtr_id)
			return (nbr);
	}

	return (NULL);
d321 1
a321 1
nbr_find_ldpid(struct iface *iface, u_int32_t rtr_id, u_int16_t lspace)
d323 4
a326 8
	struct nbr	*nbr;

	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr->id.s_addr == rtr_id && nbr->lspace == lspace)
			return (nbr);
	}

	return (NULL);
d628 14
@


1.21
log
@Only run the nbr_idtimer() when this side is acting as master (establishing
the tcp session). Calling nbr_act_session_establish() on slave systems can
crash ldpd because active events are reinitialized.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.20 2010/09/06 08:28:44 claudio Exp $ */
d559 1
a559 4

	me->prefix = map->prefix.s_addr;
	me->prefixlen = map->prefixlen;
	me->label = map->label;
d570 2
a571 2
		if (me->prefix == map->prefix.s_addr &&
		    me->prefixlen == map->prefixlen)
@


1.20
log
@The nbr_reset_*() timer fucntions are the same as the nbr_start_* function.
So replace the few calls to the reset function with nbr_start_*().
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.19 2010/09/02 14:34:04 claudio Exp $ */
d443 3
@


1.19
log
@NBR_STA_SESSION, NBR_STA_UP, and NBR_STA_ACTIVE represent all the same
group of states (all but NBR_STA_DOWN). Clean up this confusion and remove
NBR_STA_UP and NBR_STA_ACTIVE.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.18 2010/06/30 01:47:11 claudio Exp $ */
a139 2
		nbr_reset_itimer(nbr);
		break;
d144 1
a144 1
		nbr_reset_ktimeout(nbr);
d147 1
a147 1
		nbr_reset_ktimer(nbr);
a365 12
void
nbr_reset_itimer(struct nbr *nbr)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = nbr->holdtime;

	if (evtimer_add(&nbr->inactivity_timer, &tv) == -1)
		fatal("nbr_reset_itimer");
}

a402 14
void
nbr_reset_ktimer(struct nbr *nbr)
{
	struct timeval	tv;

	timerclear(&tv);

	/* XXX: just to be sure it will send three keepalives per period */
	tv.tv_sec = (time_t)(nbr->keepalive / KEEPALIVE_PER_PERIOD);

	if (evtimer_add(&nbr->keepalive_timer, &tv) == -1)
		fatal("nbr_reset_ktimer");
}

a436 12
void
nbr_reset_ktimeout(struct nbr *nbr)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = nbr->keepalive;

	if (evtimer_add(&nbr->keepalive_timeout, &tv) == -1)
		fatal("nbr_reset_ktimeout");
}

a477 13

void
nbr_reset_idtimer(struct nbr *nbr)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = INIT_DELAY_TMR;

	if (evtimer_add(&nbr->initdelay_timer, &tv) == -1)
		fatal("nbr_reset_idtimer");
}

a521 1

@


1.18
log
@Switch prefix in struct map to a struct in_addr instead of a u_int32_t.
Needed for further clean etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.17 2010/06/10 10:04:10 claudio Exp $ */
d70 1
a70 1
    {NBR_STA_UP,	NBR_EVT_HELLO_RCVD,	NBR_ACT_RST_ITIMER,	0},
d82 1
a82 1
    {NBR_STA_UP,	NBR_EVT_DOWN,		NBR_ACT_CLOSE_SESSION,	},
d311 1
a311 1
	struct nbr	*nbr = NULL;
d324 1
a324 1
	struct nbr	*nbr = NULL;
@


1.17
log
@Signal a neighbor down event to the LDE when the TCP session is closed.
The LDE only tracks neighbors with a running sessions, no session no
neighbor needed. So do not wait until the neighbor is removed in the
engine to signal the LDE since that happens a lot later.
Solves a fatal in LDE when restarting a remote ldpd quickly.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.16 2010/05/28 12:27:17 claudio Exp $ */
d611 1
a611 1
	me->prefix = map->prefix;
d624 1
a624 1
		if (me->prefix == map->prefix &&
@


1.16
log
@Send the IMSG_NEIGHBOR_UP msg when the neighbor is going into operational
status instead upon creation (when the first HELLO is received). The LDE
needs only to know about operational neighbors or it may happen that the
LDE is sending messages to neighbors that have no session open resulting
in a crash because of unitialized structures.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.15 2010/05/26 13:56:08 nicm Exp $ */
d174 2
a271 2
	ldpe_imsg_compose_lde(IMSG_NEIGHBOR_DOWN, nbr->peerid, 0, NULL, 0);

@


1.15
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.14 2010/05/25 09:26:12 claudio Exp $ */
d45 1
d152 1
d166 1
a230 1
	struct lde_nbr	 rn;
a263 7
	bzero(&rn, sizeof(rn));
	rn.id.s_addr = nbr->id.s_addr;
	rn.lspace = nbr->lspace;
	rn.ifindex = nbr->iface->ifindex;
	ldpe_imsg_compose_lde(IMSG_NEIGHBOR_UP, nbr->peerid, 0, &rn,
	    sizeof(rn));

d578 13
@


1.14
log
@I removed code in the last commit that is needed. Allocate rbuf now by
default or else we bomb on the first read access.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.13 2010/05/19 15:28:51 claudio Exp $ */
d232 1
a232 1
	if ((nbr->rbuf = calloc(1, sizeof(struct buf_read))) == NULL)
@


1.13
log
@Remove yet another ospf leftover that is not needed here. This time
neighbor self and all the madness surrounding this amazing concept.
LDP is not self aware so there is no need for this.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.12 2010/03/26 16:02:18 claudio Exp $ */
d231 2
@


1.12
log
@Never call close(nbr->fd) when the neighbor session was fully established,
call session_close(nbr) instead since only that will do all needed cleanup.
Still not prefect but at least the lde is no longer eating all CPU when a
session times out. OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.11 2010/02/25 17:40:46 claudio Exp $ */
a117 3
	if (nbr == nbr->iface->self)
		return (0);

d224 1
a224 1
nbr_new(u_int32_t nbr_id, u_int16_t lspace, struct iface *iface, int self)
a232 4
	if (!self)
		if ((nbr->rbuf = calloc(1, sizeof(struct buf_read))) == NULL)
			fatal("nbr_new");

a247 5
	if (self) {
		nbr->addr.s_addr = iface->addr.s_addr;
		nbr->priority = iface->priority;
	}

a263 1
	rn.self = self;
@


1.11
log
@Do not use bufferevent for something that's already covered in the imsg
buffer API. This fixes a few possible problems in session_read and does
some further cleanup in various places. Wrap msgbuf into evbuf to add
libevent functionality and use buf_read to handle the read side of a
session.  OK michele@@ and dlg@@ did not see anything evil
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.10 2010/02/21 20:41:35 michele Exp $ */
d458 2
a459 1
	close(nbr->fd);
@


1.10
log
@Check bufferevent_new() return value. If it is NULL print an error message
and return.

From Martin Hedenfalk.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.9 2010/02/20 21:05:00 michele Exp $ */
d236 4
d288 2
d304 1
a574 10
nbr_close_connection(struct nbr *nbr)
{
	bufferevent_disable(nbr->bev, EV_READ|EV_WRITE);
	bufferevent_free(nbr->bev);
	close(nbr->fd);

	return (0);
}

int
a576 3
	evbuffercb	readfn = session_read;
	everrorcb	errorfn = session_error;

d582 3
a584 8
	nbr->bev = bufferevent_new(nbr->fd, readfn, NULL, errorfn, nbr);
	if (nbr->bev == NULL) {
		log_warn("nbr_act_session_establish: bufferevent_new");
		return (-1);
	}

	bufferevent_settimeout(nbr->bev, 0, 0);
	bufferevent_enable(nbr->bev, EV_READ|EV_WRITE);
@


1.9
log
@Remove unneeded abstraction in neighbor fsm.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.8 2010/02/19 14:32:34 claudio Exp $ */
d589 5
@


1.8
log
@Oups, unbreak build.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.7 2010/02/19 13:37:09 claudio Exp $ */
d138 2
d142 1
a142 1
		ret = nbr_act_reset_itimer(nbr);
d145 1
a145 1
		ret = nbr_act_start_itimer(nbr);
d148 1
a148 1
		ret = nbr_act_reset_ktimeout(nbr);
d151 1
a151 1
		ret = nbr_act_reset_ktimer(nbr);
d154 2
a155 3
		/* XXX */
		ret = nbr_act_start_ktimer(nbr);
		nbr_act_start_ktimeout(nbr);
a162 1
		/* XXX */
d164 1
a164 1
		ret = send_keepalive(nbr);
d167 2
a168 3
		/* XXX */
		ret = nbr_act_start_ktimer(nbr);
		nbr_act_start_ktimeout(nbr);
d175 1
a175 1
		ret = nbr_act_start_idtimer(nbr);
a537 65
/* actions */
int
nbr_act_reset_itimer(struct nbr *nbr)
{
	nbr_reset_itimer(nbr);

	return (0);
}

int
nbr_act_start_itimer(struct nbr *nbr)
{
	nbr_start_itimer(nbr);

	return (0);
}

int
nbr_act_reset_ktimer(struct nbr *nbr)
{
	nbr_reset_ktimer(nbr);

	return (0);
}

int
nbr_act_start_ktimer(struct nbr *nbr)
{
	nbr_start_ktimer(nbr);

	return (0);
}

int
nbr_act_reset_ktimeout(struct nbr *nbr)
{
	nbr_reset_ktimeout(nbr);

	return (0);
}

int
nbr_act_start_ktimeout(struct nbr *nbr)
{
	nbr_start_ktimeout(nbr);

	return (0);
}

int
nbr_act_reset_idtimer(struct nbr *nbr)
{
	nbr_reset_idtimer(nbr);

	return (0);
}

int
nbr_act_start_idtimer(struct nbr *nbr)
{
	if (nbr->addr.s_addr < nbr->iface->addr.s_addr)
		nbr_start_idtimer(nbr);

	return (0);
}
d559 1
a559 1
		nbr_act_start_idtimer(nbr);
@


1.7
log
@Cleanup a bit, remove unneeded dummy neighbor and initialize queue heads
in the correct place. Queue mappings ordered by inserting at tail.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.6 2010/02/18 09:26:29 claudio Exp $ */
a212 1
	struct nbr_head	*head;
@


1.6
log
@Remove some debug messages that are too verbose and no longer needed.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.5 2010/02/18 09:25:16 claudio Exp $ */
a213 1
	struct nbr	*nbr;
a225 16

	/* allocate a dummy neighbor used for self originated AS ext routes */
	if ((nbr = calloc(1, sizeof(*nbr))) == NULL)
		fatal("nbr_init");

	nbr->id.s_addr = ldpe_router_id();
	nbr->state = NBR_STA_DOWN;
	nbr->peerid = NBR_IDSELF;
	head = NBR_HASH(nbr->peerid);
	LIST_INSERT_HEAD(head, nbr, hash);

	TAILQ_INIT(&nbr->mapping_list);
	TAILQ_INIT(&nbr->withdraw_list);
	TAILQ_INIT(&nbr->request_list);
	TAILQ_INIT(&nbr->release_list);
	TAILQ_INIT(&nbr->abortreq_list);
d258 6
a609 1
	int			st;
d611 1
d617 1
a617 1
	if (nbr->fd < 0) {
d623 1
a623 2
	st = connect(nbr->fd, (struct sockaddr *)&in, sizeof(in));
	if (st < 0 ) {
d673 1
a673 1
		    0, 0);
d690 1
a690 1
	TAILQ_INSERT_HEAD(mh, me, entry);
@


1.5
log
@Close a fd leak when opening the tcp connection to the neighbor.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.4 2009/12/06 16:12:47 michele Exp $ */
a408 3

	log_debug("nbr_ktimer: neighbor ID %s peerid %lu", inet_ntoa(nbr->id),
	    nbr->peerid);
@


1.4
log
@During the session's initialization, when playing the passive role, send
the initialization message before the keepalive.

This fixes session initialazion failures noticed by Christophe Fillot.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.3 2009/08/01 12:47:02 michele Exp $ */
d642 1
@


1.3
log
@Correctly print interface state and neighbor uptime in ldpctl show neighbor.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.2 2009/06/05 22:34:45 michele Exp $ */
d163 2
a164 2
		send_keepalive(nbr);
		ret = send_init(nbr);
@


1.2
log
@Correctly send notification messages when errors occur.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d113 1
d200 5
d756 1
d767 2
a768 2
/*
	if (nbr->state == NBR_STA_FULL) {
d772 1
a772 1
*/
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d460 1
a460 1
	send_notification_nbr(nbr, S_KEEPALIVE_TMR);
@

