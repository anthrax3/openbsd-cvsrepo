head	1.62;
access;
symbols
	OPENBSD_6_0:1.57.0.2
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.13.0.6
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.4
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.2
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.62
date	2017.03.03.23.36.06;	author renato;	state Exp;
branches;
next	1.61;
commitid	nsyffCkbHeLwduqi;

1.61
date	2017.03.03.23.30.57;	author renato;	state Exp;
branches;
next	1.60;
commitid	mvwmKJi9MZW7VKOy;

1.60
date	2017.01.20.12.19.18;	author benno;	state Exp;
branches;
next	1.59;
commitid	qrjsXLNhiS0G91tf;

1.59
date	2016.09.28.14.39.52;	author krw;	state Exp;
branches;
next	1.58;
commitid	VsoFRUtzDouNG1Ir;

1.58
date	2016.09.02.17.03.24;	author renato;	state Exp;
branches;
next	1.57;
commitid	oHghF3eNQnFZklxo;

1.57
date	2016.07.15.17.03.10;	author renato;	state Exp;
branches;
next	1.56;
commitid	jlZzdQtCijXdAmN4;

1.56
date	2016.07.01.23.29.55;	author renato;	state Exp;
branches;
next	1.55;
commitid	OkOx7tFZtmlIlivU;

1.55
date	2016.07.01.23.14.31;	author renato;	state Exp;
branches;
next	1.54;
commitid	DKNC9fIizmSRxKR1;

1.54
date	2016.06.18.17.13.05;	author renato;	state Exp;
branches;
next	1.53;
commitid	C9BDjZlAk1G5zEq3;

1.53
date	2016.06.18.01.30.28;	author renato;	state Exp;
branches;
next	1.52;
commitid	RRdvqkWDmQM8wk8u;

1.52
date	2016.06.13.20.15.58;	author renato;	state Exp;
branches;
next	1.51;
commitid	tHSOojUwG1vQtHLQ;

1.51
date	2016.06.08.23.30.07;	author renato;	state Exp;
branches;
next	1.50;
commitid	HVCFOK1E6L5k34rQ;

1.50
date	2016.06.06.16.42.41;	author renato;	state Exp;
branches;
next	1.49;
commitid	1iRJyXrhohyNUnrn;

1.49
date	2016.06.06.15.30.59;	author renato;	state Exp;
branches;
next	1.48;
commitid	DG8Q9ksVqeiXuWBB;

1.48
date	2016.05.23.19.16.00;	author renato;	state Exp;
branches;
next	1.47;
commitid	wKGrbgE7dtbu6ic6;

1.47
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.46;
commitid	TLlfi1Pk0Z97z8HM;

1.46
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.45;
commitid	AQBoOveMRKjtVfFv;

1.45
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.44;
commitid	t07H0Mk6WGdVWB0W;

1.44
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.43;
commitid	D7VvXbswyzx5Ahb2;

1.43
date	2016.05.23.18.55.21;	author renato;	state Exp;
branches;
next	1.42;
commitid	85kONxXVWUqI2Jhb;

1.42
date	2016.05.23.18.41.59;	author renato;	state Exp;
branches;
next	1.41;
commitid	zjb4P8L4wSROotP5;

1.41
date	2016.05.23.18.40.15;	author renato;	state Exp;
branches;
next	1.40;
commitid	LYl0nXLaUb8GwBRC;

1.40
date	2016.05.23.18.36.55;	author renato;	state Exp;
branches;
next	1.39;
commitid	Ba6Sgjw90tNqVKLo;

1.39
date	2016.05.23.18.33.56;	author renato;	state Exp;
branches;
next	1.38;
commitid	YK3Z5X8iSxlfPhoT;

1.38
date	2016.05.23.18.28.22;	author renato;	state Exp;
branches;
next	1.37;
commitid	FV8IR5RMrg1EHRis;

1.37
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.36;
commitid	VpAym8dVR6eY4drQ;

1.36
date	2016.05.23.16.54.22;	author renato;	state Exp;
branches;
next	1.35;
commitid	LfWxXXNhiR6poNUS;

1.35
date	2016.05.23.16.18.51;	author renato;	state Exp;
branches;
next	1.34;
commitid	0IKOnhMGNkMbV1lE;

1.34
date	2016.05.23.16.14.36;	author renato;	state Exp;
branches;
next	1.33;
commitid	hNzA87VdOHsaOms9;

1.33
date	2016.05.23.15.55.45;	author renato;	state Exp;
branches;
next	1.32;
commitid	2u97ZvNFB0AGCiaX;

1.32
date	2016.05.23.15.47.24;	author renato;	state Exp;
branches;
next	1.31;
commitid	Eng7dm0NElMq9Yi3;

1.31
date	2016.05.23.15.43.11;	author renato;	state Exp;
branches;
next	1.30;
commitid	weS0xzAgWBV4f0dh;

1.30
date	2016.05.23.15.41.04;	author renato;	state Exp;
branches;
next	1.29;
commitid	GWVZlQK3ZbMPg5pq;

1.29
date	2016.05.23.15.14.07;	author renato;	state Exp;
branches;
next	1.28;
commitid	l3e6PhvoAh8C7elc;

1.28
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches;
next	1.27;
commitid	LQHdRRMF0nq0fugE;

1.27
date	2015.12.05.13.11.48;	author claudio;	state Exp;
branches;
next	1.26;
commitid	c8UgZO1MU5iqaNd3;

1.26
date	2015.07.21.05.04.12;	author renato;	state Exp;
branches;
next	1.25;
commitid	xx9kMymPWvtBzJZ5;

1.25
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.24;
commitid	puLLDX1XPNc3GxB9;

1.24
date	2015.07.21.04.45.21;	author renato;	state Exp;
branches;
next	1.23;
commitid	DOwVSvrpKsgJLpe1;

1.23
date	2015.07.21.04.43.28;	author renato;	state Exp;
branches;
next	1.22;
commitid	QaTrdqMa9i0CUoyW;

1.22
date	2015.02.09.11.54.24;	author claudio;	state Exp;
branches;
next	1.21;
commitid	LTeEOygtHEq8pPcX;

1.21
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Uu5nFG3wCl0LACBb;

1.20
date	2014.07.12.20.16.38;	author krw;	state Exp;
branches;
next	1.19;
commitid	lIxCxHhVEpsmXOdi;

1.19
date	2013.11.26.11.59.38;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2013.10.15.20.21.25;	author renato;	state Exp;
branches;
next	1.17;

1.17
date	2013.06.04.02.25.28;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2013.06.03.16.53.49;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2013.06.01.20.13.04;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2013.05.04.09.26.24;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2011.08.20.19.02.28;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.01.13.54.54;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.08.09.41.05;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.30.05.21.38;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.02.16.01.41;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.03.10.17.05;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.25.17.40.46;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.02.20.34.58;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.28.09.15.58;	author sobrado;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.13.19.04.26;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.06.08.09.43;	author pyr;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Allow to run on a non-default rdomain.

OK claudio@@
@
text
@/*	$OpenBSD: ldpd.c,v 1.61 2017/03/03 23:30:57 renato Exp $ */

/*
 * Copyright (c) 2013, 2016 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2008 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <err.h>
#include <errno.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>

#include "ldpd.h"
#include "ldpe.h"
#include "lde.h"
#include "log.h"

static void		 main_sig_handler(int, short, void *);
static __dead void	 usage(void);
static __dead void	 ldpd_shutdown(void);
static pid_t		 start_child(enum ldpd_process, char *, int, int, int,
			    char *);
static void		 main_dispatch_ldpe(int, short, void *);
static void		 main_dispatch_lde(int, short, void *);
static int		 main_imsg_compose_both(enum imsg_type, void *,
			    uint16_t);
static int		 main_imsg_send_ipc_sockets(struct imsgbuf *,
			    struct imsgbuf *);
static void		 main_imsg_send_net_sockets(int);
static void		 main_imsg_send_net_socket(int, enum socket_type);
static int		 main_imsg_send_config(struct ldpd_conf *);
static int		 ldp_reload(void);
static void		 merge_global(struct ldpd_conf *, struct ldpd_conf *);
static void		 merge_af(int, struct ldpd_af_conf *,
			    struct ldpd_af_conf *);
static void		 merge_ifaces(struct ldpd_conf *, struct ldpd_conf *);
static void		 merge_iface_af(struct iface_af *, struct iface_af *);
static void		 merge_tnbrs(struct ldpd_conf *, struct ldpd_conf *);
static void		 merge_nbrps(struct ldpd_conf *, struct ldpd_conf *);
static void		 merge_l2vpns(struct ldpd_conf *, struct ldpd_conf *);
static void		 merge_l2vpn(struct ldpd_conf *, struct l2vpn *,
			    struct l2vpn *);

struct ldpd_global	 global;
struct ldpd_conf	*ldpd_conf;

static char		*conffile;
static struct imsgev	*iev_ldpe;
static struct imsgev	*iev_lde;
static pid_t		 ldpe_pid;
static pid_t		 lde_pid;

/* ARGSUSED */
static void
main_sig_handler(int sig, short event, void *arg)
{
	/* signal handler rules don't apply, libevent decouples for us */
	switch (sig) {
	case SIGTERM:
	case SIGINT:
		ldpd_shutdown();
		/* NOTREACHED */
	case SIGHUP:
		if (ldp_reload() == -1)
			log_warnx("configuration reload failed");
		else
			log_debug("configuration reloaded");
		break;
	default:
		fatalx("unexpected signal");
		/* NOTREACHED */
	}
}

static __dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-dnv] [-D macro=value] [-f file]"
	    " [-s socket]\n", __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct event		 ev_sigint, ev_sigterm, ev_sighup;
	char			*saved_argv0;
	int			 ch;
	int			 debug = 0, lflag = 0, eflag = 0;
	char			*sockname;
	int			 pipe_parent2ldpe[2];
	int			 pipe_parent2lde[2];

	conffile = CONF_FILE;
	ldpd_process = PROC_MAIN;
	log_procname = log_procnames[ldpd_process];
	sockname = LDPD_SOCKET;

	log_init(1);	/* log to stderr until daemonized */
	log_verbose(1);

	saved_argv0 = argv[0];
	if (saved_argv0 == NULL)
		saved_argv0 = "ldpd";

	while ((ch = getopt(argc, argv, "dD:f:ns:vLE")) != -1) {
		switch (ch) {
		case 'd':
			debug = 1;
			break;
		case 'D':
			if (cmdline_symset(optarg) < 0)
				log_warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'n':
			global.cmd_opts |= LDPD_OPT_NOACTION;
			break;
		case 's':
			sockname = optarg;
			break;
		case 'v':
			if (global.cmd_opts & LDPD_OPT_VERBOSE)
				global.cmd_opts |= LDPD_OPT_VERBOSE2;
			global.cmd_opts |= LDPD_OPT_VERBOSE;
			break;
		case 'L':
			lflag = 1;
			break;
		case 'E':
			eflag = 1;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	argc -= optind;
	argv += optind;
	if (argc > 0 || (lflag && eflag))
		usage();

	if (lflag)
		lde(debug, global.cmd_opts & LDPD_OPT_VERBOSE);
	else if (eflag)
		ldpe(debug, global.cmd_opts & LDPD_OPT_VERBOSE, sockname);

	/* fetch interfaces early */
	kif_init();

	/* parse config file */
	if ((ldpd_conf = parse_config(conffile)) == NULL ) {
		kif_clear();
		exit(1);
	}

	if (global.cmd_opts & LDPD_OPT_NOACTION) {
		if (global.cmd_opts & LDPD_OPT_VERBOSE)
			print_config(ldpd_conf);
		else
			fprintf(stderr, "configuration OK\n");
		kif_clear();
		exit(0);
	}

	/* check for root privileges  */
	if (geteuid())
		errx(1, "need root privileges");

	/* check for ldpd user */
	if (getpwnam(LDPD_USER) == NULL)
		errx(1, "unknown user %s", LDPD_USER);

	log_init(debug);
	log_verbose(global.cmd_opts & (LDPD_OPT_VERBOSE | LDPD_OPT_VERBOSE2));

	if (!debug)
		daemon(1, 0);

	log_info("startup");

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC,
	    PF_UNSPEC, pipe_parent2ldpe) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC,
	    PF_UNSPEC, pipe_parent2lde) == -1)
		fatal("socketpair");

	/* start children */
	lde_pid = start_child(PROC_LDE_ENGINE, saved_argv0,
	    pipe_parent2lde[1], debug, global.cmd_opts & LDPD_OPT_VERBOSE,
	    NULL);
	ldpe_pid = start_child(PROC_LDP_ENGINE, saved_argv0,
	    pipe_parent2ldpe[1], debug, global.cmd_opts & LDPD_OPT_VERBOSE,
	    sockname);

	event_init();

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, main_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, main_sig_handler, NULL);
	signal_set(&ev_sighup, SIGHUP, main_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sighup, NULL);
	signal(SIGPIPE, SIG_IGN);

	/* setup pipes to children */
	if ((iev_ldpe = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_lde = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_ldpe->ibuf, pipe_parent2ldpe[0]);
	iev_ldpe->handler = main_dispatch_ldpe;
	imsg_init(&iev_lde->ibuf, pipe_parent2lde[0]);
	iev_lde->handler = main_dispatch_lde;

	/* setup event handler */
	iev_ldpe->events = EV_READ;
	event_set(&iev_ldpe->ev, iev_ldpe->ibuf.fd, iev_ldpe->events,
	    iev_ldpe->handler, iev_ldpe);
	event_add(&iev_ldpe->ev, NULL);

	iev_lde->events = EV_READ;
	event_set(&iev_lde->ev, iev_lde->ibuf.fd, iev_lde->events,
	    iev_lde->handler, iev_lde);
	event_add(&iev_lde->ev, NULL);

	if (main_imsg_send_ipc_sockets(&iev_ldpe->ibuf, &iev_lde->ibuf))
		fatal("could not establish imsg links");
	main_imsg_send_config(ldpd_conf);

	if (kr_init(!(ldpd_conf->flags & F_LDPD_NO_FIB_UPDATE),
	    ldpd_conf->rdomain) == -1)
		fatalx("kr_init failed");

	/* notify ldpe about existing interfaces and addresses */
	kif_redistribute(NULL);

	if (ldpd_conf->ipv4.flags & F_LDPD_AF_ENABLED)
		main_imsg_send_net_sockets(AF_INET);
	if (ldpd_conf->ipv6.flags & F_LDPD_AF_ENABLED)
		main_imsg_send_net_sockets(AF_INET6);

	/* remove unneeded stuff from config */
		/* ... */

	event_dispatch();

	ldpd_shutdown();
	/* NOTREACHED */
	return (0);
}

static __dead void
ldpd_shutdown(void)
{
	pid_t		 pid;
	int		 status;

	/* close pipes */
	msgbuf_clear(&iev_ldpe->ibuf.w);
	close(iev_ldpe->ibuf.fd);
	msgbuf_clear(&iev_lde->ibuf.w);
	close(iev_lde->ibuf.fd);

	kr_shutdown();
	config_clear(ldpd_conf);

	log_debug("waiting for children to terminate");
	do {
		pid = wait(&status);
		if (pid == -1) {
			if (errno != EINTR && errno != ECHILD)
				fatal("wait");
		} else if (WIFSIGNALED(status))
			log_warnx("%s terminated; signal %d",
			    (pid == lde_pid) ? "label decision engine" :
			    "ldp engine", WTERMSIG(status));
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	free(iev_ldpe);
	free(iev_lde);

	log_info("terminating");
	exit(0);
}

static pid_t
start_child(enum ldpd_process p, char *argv0, int fd, int debug, int verbose,
    char *sockname)
{
	char	*argv[5];
	int	 argc = 0;
	pid_t	 pid;

	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
	case 0:
		break;
	default:
		close(fd);
		return (pid);
	}

	if (dup2(fd, 3) == -1)
		fatal("cannot setup imsg fd");

	argv[argc++] = argv0;
	switch (p) {
	case PROC_MAIN:
		fatalx("Can not start main process");
	case PROC_LDE_ENGINE:
		argv[argc++] = "-L";
		break;
	case PROC_LDP_ENGINE:
		argv[argc++] = "-E";
		break;
	}
	if (debug)
		argv[argc++] = "-d";
	if (verbose)
		argv[argc++] = "-v";
	if (sockname) {
		argv[argc++] = "-s";
		argv[argc++] = sockname;
	}
	argv[argc++] = NULL;

	execvp(argv0, argv);
	fatal("execvp");
}

/* imsg handling */
/* ARGSUSED */
static void
main_dispatch_ldpe(int fd, short event, void *bula)
{
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct imsg		 imsg;
	int			 af;
	ssize_t			 n;
	int			 shut = 0, verbose;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("imsg_get");

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_REQUEST_SOCKETS:
			af = imsg.hdr.pid;
			main_imsg_send_net_sockets(af);
			break;
		case IMSG_CTL_RELOAD:
			if (ldp_reload() == -1)
				log_warnx("configuration reload failed");
			else
				log_debug("configuration reloaded");
			break;
		case IMSG_CTL_FIB_COUPLE:
			kr_fib_couple();
			break;
		case IMSG_CTL_FIB_DECOUPLE:
			kr_fib_decouple();
			break;
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_KROUTE_ADDR:
			kr_show_route(&imsg);
			break;
		case IMSG_CTL_IFINFO:
			if (imsg.hdr.len == IMSG_HEADER_SIZE)
				kr_ifinfo(NULL, imsg.hdr.pid);
			else if (imsg.hdr.len == IMSG_HEADER_SIZE + IFNAMSIZ)
				kr_ifinfo(imsg.data, imsg.hdr.pid);
			else
				log_warnx("IFINFO request with wrong len");
			break;
		case IMSG_CTL_LOG_VERBOSE:
			/* already checked by ldpe */
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		default:
			log_debug("%s: error handling imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
static void
main_dispatch_lde(int fd, short event, void *bula)
{
	struct imsgev	*iev = bula;
	struct imsgbuf	*ibuf = &iev->ibuf;
	struct imsg	 imsg;
	ssize_t		 n;
	int		 shut = 0;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("imsg_get");

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_KLABEL_CHANGE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct kroute))
				fatalx("invalid size of IMSG_KLABEL_CHANGE");
			if (kr_change(imsg.data))
				log_warnx("%s: error changing route", __func__);
			break;
		case IMSG_KLABEL_DELETE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct kroute))
				fatalx("invalid size of IMSG_KLABEL_DELETE");
			if (kr_delete(imsg.data))
				log_warnx("%s: error deleting route", __func__);
			break;
		case IMSG_KPWLABEL_CHANGE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct kpw))
				fatalx("invalid size of IMSG_KPWLABEL_CHANGE");
			if (kmpw_set(imsg.data))
				log_warnx("%s: error changing pseudowire",
				    __func__);
			break;
		case IMSG_KPWLABEL_DELETE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct kpw))
				fatalx("invalid size of IMSG_KPWLABEL_DELETE");
			if (kmpw_unset(imsg.data))
				log_warnx("%s: error unsetting pseudowire",
				    __func__);
			break;
		default:
			log_debug("%s: error handling imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
main_imsg_compose_ldpe(int type, pid_t pid, void *data, uint16_t datalen)
{
	if (iev_ldpe == NULL)
		return;
	imsg_compose_event(iev_ldpe, type, 0, pid, -1, data, datalen);
}

void
main_imsg_compose_lde(int type, pid_t pid, void *data, uint16_t datalen)
{
	imsg_compose_event(iev_lde, type, 0, pid, -1, data, datalen);
}

static int
main_imsg_compose_both(enum imsg_type type, void *buf, uint16_t len)
{
	if (imsg_compose_event(iev_ldpe, type, 0, 0, -1, buf, len) == -1)
		return (-1);
	if (imsg_compose_event(iev_lde, type, 0, 0, -1, buf, len) == -1)
		return (-1);
	return (0);
}

void
imsg_event_add(struct imsgev *iev)
{
	iev->events = EV_READ;
	if (iev->ibuf.w.queued)
		iev->events |= EV_WRITE;

	event_del(&iev->ev);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev);
	event_add(&iev->ev, NULL);
}

int
imsg_compose_event(struct imsgev *iev, uint16_t type, uint32_t peerid,
    pid_t pid, int fd, void *data, uint16_t datalen)
{
	int	ret;

	if ((ret = imsg_compose(&iev->ibuf, type, peerid,
	    pid, fd, data, datalen)) != -1)
		imsg_event_add(iev);
	return (ret);
}

void
evbuf_enqueue(struct evbuf *eb, struct ibuf *buf)
{
	ibuf_close(&eb->wbuf, buf);
	evbuf_event_add(eb);
}

void
evbuf_event_add(struct evbuf *eb)
{
	if (eb->wbuf.queued)
		event_add(&eb->ev, NULL);
}

void
evbuf_init(struct evbuf *eb, int fd, void (*handler)(int, short, void *),
    void *arg)
{
	msgbuf_init(&eb->wbuf);
	eb->wbuf.fd = fd;
	event_set(&eb->ev, eb->wbuf.fd, EV_WRITE, handler, arg);
}

void
evbuf_clear(struct evbuf *eb)
{
	event_del(&eb->ev);
	msgbuf_clear(&eb->wbuf);
	eb->wbuf.fd = -1;
}

static int
main_imsg_send_ipc_sockets(struct imsgbuf *ldpe_buf, struct imsgbuf *lde_buf)
{
	int pipe_ldpe2lde[2];

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_ldpe2lde) == -1)
		return (-1);

	if (imsg_compose(ldpe_buf, IMSG_SOCKET_IPC, 0, 0, pipe_ldpe2lde[0],
	    NULL, 0) == -1)
		return (-1);
	if (imsg_compose(lde_buf, IMSG_SOCKET_IPC, 0, 0, pipe_ldpe2lde[1],
	    NULL, 0) == -1)
		return (-1);

	return (0);
}

static void
main_imsg_send_net_sockets(int af)
{
	main_imsg_send_net_socket(af, LDP_SOCKET_DISC);
	main_imsg_send_net_socket(af, LDP_SOCKET_EDISC);
	main_imsg_send_net_socket(af, LDP_SOCKET_SESSION);
	imsg_compose_event(iev_ldpe, IMSG_SETUP_SOCKETS, af, 0, -1, NULL, 0);
}

static void
main_imsg_send_net_socket(int af, enum socket_type type)
{
	int			 fd;

	fd = ldp_create_socket(af, type);
	if (fd == -1) {
		log_warnx("%s: failed to create %s socket for address-family "
		    "%s", __func__, socket_name(type), af_name(af));
		return;
	}

	imsg_compose_event(iev_ldpe, IMSG_SOCKET_NET, af, 0, fd, &type,
	    sizeof(type));
}

struct ldpd_af_conf *
ldp_af_conf_get(struct ldpd_conf *xconf, int af)
{
	switch (af) {
	case AF_INET:
		return (&xconf->ipv4);
	case AF_INET6:
		return (&xconf->ipv6);
	default:
		fatalx("ldp_af_conf_get: unknown af");
	}
}

struct ldpd_af_global *
ldp_af_global_get(struct ldpd_global *xglobal, int af)
{
	switch (af) {
	case AF_INET:
		return (&xglobal->ipv4);
	case AF_INET6:
		return (&xglobal->ipv6);
	default:
		fatalx("ldp_af_global_get: unknown af");
	}
}

int
ldp_is_dual_stack(struct ldpd_conf *xconf)
{
	return ((xconf->ipv4.flags & F_LDPD_AF_ENABLED) &&
	    (xconf->ipv6.flags & F_LDPD_AF_ENABLED));
}

static int
main_imsg_send_config(struct ldpd_conf *xconf)
{
	struct iface		*iface;
	struct tnbr		*tnbr;
	struct nbr_params	*nbrp;
	struct l2vpn		*l2vpn;
	struct l2vpn_if		*lif;
	struct l2vpn_pw		*pw;

	if (main_imsg_compose_both(IMSG_RECONF_CONF, xconf,
	    sizeof(*xconf)) == -1)
		return (-1);

	LIST_FOREACH(iface, &xconf->iface_list, entry) {
		if (main_imsg_compose_both(IMSG_RECONF_IFACE, iface,
		    sizeof(*iface)) == -1)
			return (-1);
	}

	LIST_FOREACH(tnbr, &xconf->tnbr_list, entry) {
		if (main_imsg_compose_both(IMSG_RECONF_TNBR, tnbr,
		    sizeof(*tnbr)) == -1)
			return (-1);
	}

	LIST_FOREACH(nbrp, &xconf->nbrp_list, entry) {
		if (main_imsg_compose_both(IMSG_RECONF_NBRP, nbrp,
		    sizeof(*nbrp)) == -1)
			return (-1);
	}

	LIST_FOREACH(l2vpn, &xconf->l2vpn_list, entry) {
		if (main_imsg_compose_both(IMSG_RECONF_L2VPN, l2vpn,
		    sizeof(*l2vpn)) == -1)
			return (-1);

		LIST_FOREACH(lif, &l2vpn->if_list, entry) {
			if (main_imsg_compose_both(IMSG_RECONF_L2VPN_IF, lif,
			    sizeof(*lif)) == -1)
				return (-1);
		}
		LIST_FOREACH(pw, &l2vpn->pw_list, entry) {
			if (main_imsg_compose_both(IMSG_RECONF_L2VPN_PW, pw,
			    sizeof(*pw)) == -1)
				return (-1);
		}
	}

	if (main_imsg_compose_both(IMSG_RECONF_END, NULL, 0) == -1)
		return (-1);

	return (0);
}

static int
ldp_reload(void)
{
	struct ldpd_conf	*xconf;

	if ((xconf = parse_config(conffile)) == NULL)
		return (-1);

	if (main_imsg_send_config(xconf) == -1)
		return (-1);

	merge_config(ldpd_conf, xconf);

	return (0);
}

void
merge_config(struct ldpd_conf *conf, struct ldpd_conf *xconf)
{
	merge_global(conf, xconf);
	merge_af(AF_INET, &conf->ipv4, &xconf->ipv4);
	merge_af(AF_INET6, &conf->ipv6, &xconf->ipv6);
	merge_ifaces(conf, xconf);
	merge_tnbrs(conf, xconf);
	merge_nbrps(conf, xconf);
	merge_l2vpns(conf, xconf);
	free(xconf);
}

static void
merge_global(struct ldpd_conf *conf, struct ldpd_conf *xconf)
{
	/* change of router-id requires resetting all neighborships */
	if (conf->rtr_id.s_addr != xconf->rtr_id.s_addr) {
		if (ldpd_process == PROC_LDP_ENGINE) {
			ldpe_reset_nbrs(AF_INET);
			ldpe_reset_nbrs(AF_INET6);
			if (conf->rtr_id.s_addr == INADDR_ANY ||
			    xconf->rtr_id.s_addr == INADDR_ANY) {
				if_update_all(AF_UNSPEC);
				tnbr_update_all(AF_UNSPEC);
			}
		}
		conf->rtr_id = xconf->rtr_id;
	}

	conf->rdomain= xconf->rdomain;

	if (conf->trans_pref != xconf->trans_pref) {
		if (ldpd_process == PROC_LDP_ENGINE)
			ldpe_reset_ds_nbrs();
		conf->trans_pref = xconf->trans_pref;
	}

	if ((conf->flags & F_LDPD_DS_CISCO_INTEROP) !=
	    (xconf->flags & F_LDPD_DS_CISCO_INTEROP)) {
		if (ldpd_process == PROC_LDP_ENGINE)
			ldpe_reset_ds_nbrs();
	}

	conf->flags = xconf->flags;
}

static void
merge_af(int af, struct ldpd_af_conf *af_conf, struct ldpd_af_conf *xa)
{
	int			 egress_label_changed = 0;
	int			 update_sockets = 0;

	if (af_conf->keepalive != xa->keepalive) {
		af_conf->keepalive = xa->keepalive;
		if (ldpd_process == PROC_LDP_ENGINE)
			ldpe_stop_init_backoff(af);
	}
	af_conf->thello_holdtime = xa->thello_holdtime;
	af_conf->thello_interval = xa->thello_interval;

	/* update flags */
	if (ldpd_process == PROC_LDP_ENGINE &&
	    (af_conf->flags & F_LDPD_AF_THELLO_ACCEPT) &&
	    !(xa->flags & F_LDPD_AF_THELLO_ACCEPT))
		ldpe_remove_dynamic_tnbrs(af);

	if ((af_conf->flags & F_LDPD_AF_NO_GTSM) !=
	    (xa->flags & F_LDPD_AF_NO_GTSM)) {
		if (af == AF_INET6)
			/* need to set/unset IPV6_MINHOPCOUNT */
			update_sockets = 1;
		else if (ldpd_process == PROC_LDP_ENGINE)
			/* for LDPv4 just resetting the neighbors is enough */
			ldpe_reset_nbrs(af);
	}

	if ((af_conf->flags & F_LDPD_AF_EXPNULL) !=
	    (xa->flags & F_LDPD_AF_EXPNULL))
		egress_label_changed = 1;

	af_conf->flags = xa->flags;

	if (egress_label_changed) {
		switch (ldpd_process) {
		case PROC_LDE_ENGINE:
			lde_change_egress_label(af, af_conf->flags &
			    F_LDPD_AF_EXPNULL);
			break;
		case PROC_MAIN:
			kr_change_egress_label(af, af_conf->flags &
			    F_LDPD_AF_EXPNULL);
			break;
		default:
			break;
		}
	}

	if (ldp_addrcmp(af, &af_conf->trans_addr, &xa->trans_addr)) {
		af_conf->trans_addr = xa->trans_addr;
		update_sockets = 1;
	}

	if (ldpd_process == PROC_MAIN && update_sockets)
		imsg_compose_event(iev_ldpe, IMSG_CLOSE_SOCKETS, af, 0, -1,
		    NULL, 0);
}

static void
merge_ifaces(struct ldpd_conf *conf, struct ldpd_conf *xconf)
{
	struct iface		*iface, *itmp, *xi;

	LIST_FOREACH_SAFE(iface, &conf->iface_list, entry, itmp) {
		/* find deleted interfaces */
		if ((xi = if_lookup(xconf, iface->ifindex)) == NULL) {
			LIST_REMOVE(iface, entry);
			if (ldpd_process == PROC_LDP_ENGINE)
				if_exit(iface);
			free(iface);
		}
	}
	LIST_FOREACH_SAFE(xi, &xconf->iface_list, entry, itmp) {
		/* find new interfaces */
		if ((iface = if_lookup(conf, xi->ifindex)) == NULL) {
			LIST_REMOVE(xi, entry);
			LIST_INSERT_HEAD(&conf->iface_list, xi, entry);

			/* resend addresses to activate new interfaces */
			if (ldpd_process == PROC_MAIN)
				kif_redistribute(xi->name);
			continue;
		}

		/* update existing interfaces */
		merge_iface_af(&iface->ipv4, &xi->ipv4);
		merge_iface_af(&iface->ipv6, &xi->ipv6);
		LIST_REMOVE(xi, entry);
		free(xi);
	}
}

static void
merge_iface_af(struct iface_af *ia, struct iface_af *xi)
{
	if (ia->enabled != xi->enabled) {
		ia->enabled = xi->enabled;
		if (ldpd_process == PROC_LDP_ENGINE)
			if_update(ia->iface, ia->af);
	}
	ia->hello_holdtime = xi->hello_holdtime;
	ia->hello_interval = xi->hello_interval;
}

static void
merge_tnbrs(struct ldpd_conf *conf, struct ldpd_conf *xconf)
{
	struct tnbr		*tnbr, *ttmp, *xt;

	LIST_FOREACH_SAFE(tnbr, &conf->tnbr_list, entry, ttmp) {
		if (!(tnbr->flags & F_TNBR_CONFIGURED))
			continue;

		/* find deleted tnbrs */
		if ((xt = tnbr_find(xconf, tnbr->af, &tnbr->addr)) == NULL) {
			if (ldpd_process == PROC_LDP_ENGINE) {
				tnbr->flags &= ~F_TNBR_CONFIGURED;
				tnbr_check(tnbr);
			} else {
				LIST_REMOVE(tnbr, entry);
				free(tnbr);
			}
		}
	}
	LIST_FOREACH_SAFE(xt, &xconf->tnbr_list, entry, ttmp) {
		/* find new tnbrs */
		if ((tnbr = tnbr_find(conf, xt->af, &xt->addr)) == NULL) {
			LIST_REMOVE(xt, entry);
			LIST_INSERT_HEAD(&conf->tnbr_list, xt, entry);

			if (ldpd_process == PROC_LDP_ENGINE)
				tnbr_update(xt);
			continue;
		}

		/* update existing tnbrs */
		if (!(tnbr->flags & F_TNBR_CONFIGURED))
			tnbr->flags |= F_TNBR_CONFIGURED;
		tnbr->hello_holdtime = xt->hello_holdtime;
		tnbr->hello_interval = xt->hello_interval;
		LIST_REMOVE(xt, entry);
		free(xt);
	}
}

static void
merge_nbrps(struct ldpd_conf *conf, struct ldpd_conf *xconf)
{
	struct nbr_params	*nbrp, *ntmp, *xn;
	struct nbr		*nbr;
	int			 nbrp_changed;

	LIST_FOREACH_SAFE(nbrp, &conf->nbrp_list, entry, ntmp) {
		/* find deleted nbrps */
		if ((xn = nbr_params_find(xconf, nbrp->lsr_id)) == NULL) {
			if (ldpd_process == PROC_LDP_ENGINE) {
				nbr = nbr_find_ldpid(nbrp->lsr_id.s_addr);
				if (nbr) {
					session_shutdown(nbr, S_SHUTDOWN, 0, 0);
					pfkey_remove(nbr);
					if (nbr_session_active_role(nbr))
						nbr_establish_connection(nbr);
				}
			}
			LIST_REMOVE(nbrp, entry);
			free(nbrp);
		}
	}
	LIST_FOREACH_SAFE(xn, &xconf->nbrp_list, entry, ntmp) {
		/* find new nbrps */
		if ((nbrp = nbr_params_find(conf, xn->lsr_id)) == NULL) {
			LIST_REMOVE(xn, entry);
			LIST_INSERT_HEAD(&conf->nbrp_list, xn, entry);

			if (ldpd_process == PROC_LDP_ENGINE) {
				nbr = nbr_find_ldpid(xn->lsr_id.s_addr);
				if (nbr) {
					session_shutdown(nbr, S_SHUTDOWN, 0, 0);
					if (pfkey_establish(nbr, xn) == -1)
						fatalx("pfkey setup failed");
					if (nbr_session_active_role(nbr))
						nbr_establish_connection(nbr);
				}
			}
			continue;
		}

		/* update existing nbrps */
		if (nbrp->flags != xn->flags ||
		    nbrp->keepalive != xn->keepalive ||
		    nbrp->gtsm_enabled != xn->gtsm_enabled ||
		    nbrp->gtsm_hops != xn->gtsm_hops ||
		    nbrp->auth.method != xn->auth.method ||
		    strcmp(nbrp->auth.md5key, xn->auth.md5key) != 0)
			nbrp_changed = 1;
		else
			nbrp_changed = 0;

		nbrp->keepalive = xn->keepalive;
		nbrp->gtsm_enabled = xn->gtsm_enabled;
		nbrp->gtsm_hops = xn->gtsm_hops;
		nbrp->auth.method = xn->auth.method;
		strlcpy(nbrp->auth.md5key, xn->auth.md5key,
		    sizeof(nbrp->auth.md5key));
		nbrp->auth.md5key_len = xn->auth.md5key_len;
		nbrp->flags = xn->flags;

		if (ldpd_process == PROC_LDP_ENGINE) {
			nbr = nbr_find_ldpid(nbrp->lsr_id.s_addr);
			if (nbr && nbrp_changed) {
				session_shutdown(nbr, S_SHUTDOWN, 0, 0);
				pfkey_remove(nbr);
				if (pfkey_establish(nbr, nbrp) == -1)
					fatalx("pfkey setup failed");
				if (nbr_session_active_role(nbr))
					nbr_establish_connection(nbr);
			}
		}
		LIST_REMOVE(xn, entry);
		free(xn);
	}
}

static void
merge_l2vpns(struct ldpd_conf *conf, struct ldpd_conf *xconf)
{
	struct l2vpn		*l2vpn, *ltmp, *xl;

	LIST_FOREACH_SAFE(l2vpn, &conf->l2vpn_list, entry, ltmp) {
		/* find deleted l2vpns */
		if ((xl = l2vpn_find(xconf, l2vpn->name)) == NULL) {
			LIST_REMOVE(l2vpn, entry);

			switch (ldpd_process) {
			case PROC_LDE_ENGINE:
				l2vpn_exit(l2vpn);
				break;
			case PROC_LDP_ENGINE:
				ldpe_l2vpn_exit(l2vpn);
				break;
			case PROC_MAIN:
				break;
			}
			l2vpn_del(l2vpn);
		}
	}
	LIST_FOREACH_SAFE(xl, &xconf->l2vpn_list, entry, ltmp) {
		/* find new l2vpns */
		if ((l2vpn = l2vpn_find(conf, xl->name)) == NULL) {
			LIST_REMOVE(xl, entry);
			LIST_INSERT_HEAD(&conf->l2vpn_list, xl, entry);

			switch (ldpd_process) {
			case PROC_LDE_ENGINE:
				l2vpn_init(xl);
				break;
			case PROC_LDP_ENGINE:
				ldpe_l2vpn_init(xl);
				break;
			case PROC_MAIN:
				break;
			}
			continue;
		}

		/* update existing l2vpns */
		merge_l2vpn(conf, l2vpn, xl);
		LIST_REMOVE(xl, entry);
		free(xl);
	}
}

static void
merge_l2vpn(struct ldpd_conf *xconf, struct l2vpn *l2vpn, struct l2vpn *xl)
{
	struct l2vpn_if		*lif, *ftmp, *xf;
	struct l2vpn_pw		*pw, *ptmp, *xp;
	struct nbr		*nbr;
	int			 reset_nbr, reinstall_pwfec, reinstall_tnbr;
	int			 previous_pw_type, previous_mtu;

	previous_pw_type = l2vpn->pw_type;
	previous_mtu = l2vpn->mtu;

	/* merge intefaces */
	LIST_FOREACH_SAFE(lif, &l2vpn->if_list, entry, ftmp) {
		/* find deleted interfaces */
		if ((xf = l2vpn_if_find(xl, lif->ifindex)) == NULL) {
			LIST_REMOVE(lif, entry);
			free(lif);
		}
	}
	LIST_FOREACH_SAFE(xf, &xl->if_list, entry, ftmp) {
		/* find new interfaces */
		if ((lif = l2vpn_if_find(l2vpn, xf->ifindex)) == NULL) {
			LIST_REMOVE(xf, entry);
			LIST_INSERT_HEAD(&l2vpn->if_list, xf, entry);
			xf->l2vpn = l2vpn;
			continue;
		}

		LIST_REMOVE(xf, entry);
		free(xf);
	}

	/* merge pseudowires */
	LIST_FOREACH_SAFE(pw, &l2vpn->pw_list, entry, ptmp) {
		/* find deleted pseudowires */
		if ((xp = l2vpn_pw_find(xl, pw->ifindex)) == NULL) {
			switch (ldpd_process) {
			case PROC_LDE_ENGINE:
				l2vpn_pw_exit(pw);
				break;
			case PROC_LDP_ENGINE:
				ldpe_l2vpn_pw_exit(pw);
				break;
			case PROC_MAIN:
				break;
			}

			LIST_REMOVE(pw, entry);
			free(pw);
		}
	}
	LIST_FOREACH_SAFE(xp, &xl->pw_list, entry, ptmp) {
		/* find new pseudowires */
		if ((pw = l2vpn_pw_find(l2vpn, xp->ifindex)) == NULL) {
			LIST_REMOVE(xp, entry);
			LIST_INSERT_HEAD(&l2vpn->pw_list, xp, entry);
			xp->l2vpn = l2vpn;

			switch (ldpd_process) {
			case PROC_LDE_ENGINE:
				l2vpn_pw_init(xp);
				break;
			case PROC_LDP_ENGINE:
				ldpe_l2vpn_pw_init(xp);
				break;
			case PROC_MAIN:
				break;
			}
			continue;
		}

		/* update existing pseudowire */
    		if (pw->af != xp->af ||
		    ldp_addrcmp(pw->af, &pw->addr, &xp->addr))
			reinstall_tnbr = 1;
		else
			reinstall_tnbr = 0;

		/* changes that require a session restart */
		if ((pw->flags & (F_PW_STATUSTLV_CONF|F_PW_CWORD_CONF)) !=
		    (xp->flags & (F_PW_STATUSTLV_CONF|F_PW_CWORD_CONF)))
			reset_nbr = 1;
		else
			reset_nbr = 0;

		if (l2vpn->pw_type != xl->pw_type || l2vpn->mtu != xl->mtu ||
		    pw->pwid != xp->pwid || reinstall_tnbr || reset_nbr ||
		    pw->lsr_id.s_addr != xp->lsr_id.s_addr)
			reinstall_pwfec = 1;
		else
			reinstall_pwfec = 0;

		if (ldpd_process == PROC_LDP_ENGINE) {
			if (reinstall_tnbr)
				ldpe_l2vpn_pw_exit(pw);
			if (reset_nbr) {
				nbr = nbr_find_ldpid(pw->lsr_id.s_addr);
				if (nbr && nbr->state == NBR_STA_OPER)
					session_shutdown(nbr, S_SHUTDOWN, 0, 0);
			}
		}
		if (ldpd_process == PROC_LDE_ENGINE &&
		    !reset_nbr && reinstall_pwfec)
			l2vpn_pw_exit(pw);
		pw->lsr_id = xp->lsr_id;
		pw->af = xp->af;
		pw->addr = xp->addr;
		pw->pwid = xp->pwid;
		strlcpy(pw->ifname, xp->ifname, sizeof(pw->ifname));
		pw->ifindex = xp->ifindex;
		if (xp->flags & F_PW_CWORD_CONF)
			pw->flags |= F_PW_CWORD_CONF;
		else
			pw->flags &= ~F_PW_CWORD_CONF;
		if (xp->flags & F_PW_STATUSTLV_CONF)
			pw->flags |= F_PW_STATUSTLV_CONF;
		else
			pw->flags &= ~F_PW_STATUSTLV_CONF;
		if (ldpd_process == PROC_LDP_ENGINE && reinstall_tnbr)
			ldpe_l2vpn_pw_init(pw);
		if (ldpd_process == PROC_LDE_ENGINE &&
		    !reset_nbr && reinstall_pwfec) {
			l2vpn->pw_type = xl->pw_type;
			l2vpn->mtu = xl->mtu;
			l2vpn_pw_init(pw);
			l2vpn->pw_type = previous_pw_type;
			l2vpn->mtu = previous_mtu;
		}

		LIST_REMOVE(xp, entry);
		free(xp);
	}

	l2vpn->pw_type = xl->pw_type;
	l2vpn->mtu = xl->mtu;
	strlcpy(l2vpn->br_ifname, xl->br_ifname, sizeof(l2vpn->br_ifname));
	l2vpn->br_ifindex = xl->br_ifindex;
}

struct ldpd_conf *
config_new_empty(void)
{
	struct ldpd_conf	*xconf;

	xconf = calloc(1, sizeof(*xconf));
	if (xconf == NULL)
		fatal(NULL);

	LIST_INIT(&xconf->iface_list);
	LIST_INIT(&xconf->tnbr_list);
	LIST_INIT(&xconf->nbrp_list);
	LIST_INIT(&xconf->l2vpn_list);

	return (xconf);
}

void
config_clear(struct ldpd_conf *conf)
{
	struct ldpd_conf	*xconf;

	/*
	 * Merge current config with an empty config, this will deactivate
	 * and deallocate all the interfaces, pseudowires and so on. Before
	 * merging, copy the router-id and other variables to avoid some
	 * unnecessary operations, like trying to reset the neighborships.
	 */
	xconf = config_new_empty();
	xconf->ipv4 = conf->ipv4;
	xconf->ipv6 = conf->ipv6;
	xconf->rtr_id = conf->rtr_id;
	xconf->trans_pref = conf->trans_pref;
	xconf->flags = conf->flags;
	merge_config(conf, xconf);
	free(conf);
}
@


1.61
log
@Allow to specify an alternate control socket.

This is required to run multiple instances of ldpd.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.60 2017/01/20 12:19:18 benno Exp $ */
d258 4
a264 3
	if (kr_init(!(ldpd_conf->flags & F_LDPD_NO_FIB_UPDATE)) == -1)
		fatalx("kr_init failed");

d775 2
@


1.60
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

removal of log_rtmsg() aproved by claudio@@

ok claudio@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.59 2016/09/28 14:39:52 krw Exp $ */
d41 2
a42 1
static pid_t		 start_child(enum ldpd_process, char *, int, int, int);
d100 2
a101 2
	fprintf(stderr, "usage: %s [-dnv] [-D macro=value] [-f file]\n",
	    __progname);
d112 1
d119 1
d128 1
a128 1
	while ((ch = getopt(argc, argv, "dD:f:nvLE")) != -1) {
d144 3
d172 1
a172 1
		ldpe(debug, global.cmd_opts & LDPD_OPT_VERBOSE);
d217 2
a218 1
	    pipe_parent2lde[1], debug, global.cmd_opts & LDPD_OPT_VERBOSE);
d220 2
a221 1
	    pipe_parent2ldpe[1], debug, global.cmd_opts & LDPD_OPT_VERBOSE);
d314 2
a315 1
start_child(enum ldpd_process p, char *argv0, int fd, int debug, int verbose)
d349 4
@


1.59
log
@'unneded stuff' -> 'unneeded stuff' in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.58 2016/09/02 17:03:24 renato Exp $ */
d116 1
@


1.58
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.57 2016/07/15 17:03:10 renato Exp $ */
d260 1
a260 1
	/* remove unneded stuff from config */
@


1.57
log
@Update per-neighbor GTSM options on config reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.56 2016/07/01 23:29:55 renato Exp $ */
d40 1
a40 1
static void		 ldpd_shutdown(void);
a41 1
static int		 check_child(pid_t, const char *);
d76 1
a76 6
	/*
	 * signal handler rules don't apply, libevent decouples for us
	 */

	int	die = 0;

d80 2
a81 14
		die = 1;
		/* FALLTHROUGH */
	case SIGCHLD:
		if (check_child(ldpe_pid, "ldp engine")) {
			ldpe_pid = 0;
			die = 1;
		}
		if (check_child(lde_pid, "label decision engine")) {
			lde_pid = 0;
			die = 1;
		}
		if (die)
			ldpd_shutdown();
		break;
d107 1
a107 1
	struct event		 ev_sigint, ev_sigterm, ev_sigchld, ev_sighup;
a218 1
	signal_set(&ev_sigchld, SIGCHLD, main_sig_handler, NULL);
a221 1
	signal_add(&ev_sigchld, NULL);
d270 1
a270 1
static void
d274 1
d276 5
a280 5
	if (ldpe_pid)
		kill(ldpe_pid, SIGTERM);

	if (lde_pid)
		kill(lde_pid, SIGTERM);
d283 1
d285 1
d287 8
a294 3
		if ((pid = wait(NULL)) == -1 &&
		    errno != EINTR && errno != ECHILD)
			fatal("wait");
a296 3
	config_clear(ldpd_conf);

	msgbuf_clear(&iev_ldpe->ibuf.w);
a297 1
	msgbuf_clear(&iev_lde->ibuf.w);
a342 20
}

static int
check_child(pid_t pid, const char *pname)
{
	int	status;

	if (waitpid(pid, &status, WNOHANG) > 0) {
		if (WIFEXITED(status)) {
			log_warnx("lost child: %s exited", pname);
			return (1);
		}
		if (WIFSIGNALED(status)) {
			log_warnx("lost child: %s terminated; signal %d",
			    pname, WTERMSIG(status));
			return (1);
		}
	}

	return (0);
@


1.56
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.55 2016/07/01 23:14:31 renato Exp $ */
d1014 2
@


1.55
log
@Add GTSM support (RFC 6720).

This also finishes the missing bits from our RFC 7552 implementation
because GTSM is mandatory for LDPv6.

To avoid any kind of interoperability problems, I included a few
knobs to enable/disable GTSM on a per-address-family and per-neighbor
basis. Cisco's LDPv6 implementation, for instance, doesn't support GTSM.

"reads good" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.54 2016/06/18 17:13:05 renato Exp $ */
d883 2
a884 3
				if_del(iface);
			else
				free(iface);
@


1.54
log
@Fix memory leak found with valgrind.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.53 2016/06/18 01:30:28 renato Exp $ */
d816 1
d832 10
d865 1
a865 3
		if (ldpd_process == PROC_MAIN)
			imsg_compose_event(iev_ldpe, IMSG_CLOSE_SOCKETS, af,
			    0, -1, NULL, 0);
d867 4
d1004 4
a1007 1
		if (nbrp->keepalive != xn->keepalive ||
@


1.53
log
@Use log_warnx() instead of log_warn() when appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.52 2016/06/13 20:15:58 renato Exp $ */
d1033 1
a1033 1
				l2vpn_del(l2vpn);
a1036 1
				free(l2vpn);
a1038 1
				free(l2vpn);
d1041 1
@


1.52
log
@Do not create sockets for disabled address-families.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.51 2016/06/08 23:30:07 renato Exp $ */
d499 1
a499 1
				log_warn("%s: error changing route", __func__);
d506 1
a506 1
				log_warn("%s: error deleting route", __func__);
d513 1
a513 1
				log_warn("%s: error changing pseudowire",
d521 1
a521 1
				log_warn("%s: error unsetting pseudowire",
@


1.51
log
@Fix quick reconnect when the transport address is changed.

When the transport address is changed, we can't try to reconnect to the
neighbors inside merge_af() because the ldpe process still didn't receive
the new network sockets from the parent at this point. To resolve this,
try to reconnect just after we receive these sockets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.50 2016/06/06 16:42:41 renato Exp $ */
d275 4
a278 2
	main_imsg_send_net_sockets(AF_INET);
	main_imsg_send_net_sockets(AF_INET6);
@


1.50
log
@Fix imsg parameter passing

When ldpe requests new network sockets to the parent process (after the
transport-address is changed), it must specify the desired address-family
(IPv4 or IPv6). We can use the 'pid' or 'peerid' members of the imsg_hdr
structure for this. Use 'pid' for convenience (no need to extend the
wrapper function, ldpe_imsg_compose_parent()).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.49 2016/06/06 15:30:59 renato Exp $ */
a812 2
	struct nbr		*nbr;
	struct nbr_params	*nbrp;
a854 15
		if (ldpd_process == PROC_LDP_ENGINE) {
			RB_FOREACH(nbr, nbr_id_head, &nbrs_by_id) {
				if (nbr->af != af)
					continue;

				session_shutdown(nbr, S_SHUTDOWN, 0, 0);
				pfkey_remove(nbr);
				nbr->laddr = af_conf->trans_addr;
				nbrp = nbr_params_find(leconf, nbr->id);
				if (nbrp && pfkey_establish(nbr, nbrp) == -1)
					fatalx("pfkey setup failed");
				if (nbr_session_active_role(nbr))
					nbr_establish_connection(nbr);
			}
		}
@


1.49
log
@Speed up session establishment after config reload.

If we change a neighbor's password or the global transport-address,
cancel the affected pending connects and, when playing the active role
of the session establishment process, try to connect again right away
with the new password and/or transport-address.

Without this patch we have to wait for the timeout of the pending
connects, which might be a lot of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.48 2016/05/23 19:16:00 renato Exp $ */
d413 1
a413 1
			af = imsg.hdr.peerid;
@


1.48
log
@Improve security by calling exec after fork.

For each child process (lde and ldpe), re-exec ldpd with a special
"per-role" getopt flag. This way we have seperate ASLR/cookies per
process.

Based on a similar patch for bgpd, from claudio@@

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.47 2016/05/23 19:14:03 renato Exp $ */
a862 1

d868 2
d978 2
d998 2
d1027 2
@


1.47
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.46 2016/05/23 19:11:42 renato Exp $ */
d41 1
d47 2
d51 1
a67 3
static int		 pipe_parent2ldpe[2];
static int		 pipe_parent2lde[2];
static int		 pipe_ldpe2lde[2];
d126 1
d128 3
a130 1
	int			 debug = 0;
d138 5
a142 1
	while ((ch = getopt(argc, argv, "dD:f:nv")) != -1) {
d163 6
d175 10
a224 3
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC,
	    PF_UNSPEC, pipe_ldpe2lde) == -1)
		fatal("socketpair");
d227 4
a230 4
	lde_pid = lde(ldpd_conf, pipe_parent2lde, pipe_ldpe2lde,
	    pipe_parent2ldpe);
	ldpe_pid = ldpe(ldpd_conf, pipe_parent2ldpe, pipe_ldpe2lde,
	    pipe_parent2lde);
a245 5
	close(pipe_parent2ldpe[1]);
	close(pipe_parent2lde[1]);
	close(pipe_ldpe2lde[0]);
	close(pipe_ldpe2lde[1]);

d265 4
d318 41
d617 19
d695 1
a695 1
ldp_reload(void)
a702 4
	struct ldpd_conf	*xconf;

	if ((xconf = parse_config(conffile)) == NULL)
		return (-1);
d746 14
d1219 2
a1220 2
void
config_clear(struct ldpd_conf *conf)
d1224 1
a1224 2
	/* merge current config with an empty config */
	xconf = malloc(sizeof(*xconf));
a1227 1
	*xconf = *conf;
d1232 21
a1253 1

@


1.46
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.45 2016/05/23 19:09:25 renato Exp $ */
d4 1
@


1.45
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.44 2016/05/23 18:58:48 renato Exp $ */
a21 4
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/stat.h>
a22 6

#include <netinet/in.h>
#include <arpa/inet.h>
#include <netmpls/mpls.h>

#include <event.h>
a32 1
#include "ldp.h"
d34 1
a34 1
#include "control.h"
a35 1
#include "lde.h"
@


1.44
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.43 2016/05/23 18:55:21 renato Exp $ */
d49 33
a81 33
void		main_sig_handler(int, short, void *);
__dead void	usage(void);
void		ldpd_shutdown(void);
int		check_child(pid_t, const char *);

void	main_dispatch_ldpe(int, short, void *);
void	main_dispatch_lde(int, short, void *);
int	main_imsg_compose_both(enum imsg_type, void *, uint16_t);
void	main_imsg_send_net_sockets(int);
void	main_imsg_send_net_socket(int, enum socket_type);
int	ldp_reload(void);
void	merge_global(struct ldpd_conf *, struct ldpd_conf *);
void	merge_af(int, struct ldpd_af_conf *, struct ldpd_af_conf *);
void	merge_ifaces(struct ldpd_conf *, struct ldpd_conf *);
void	merge_iface_af(struct iface_af *, struct iface_af *);
void	merge_tnbrs(struct ldpd_conf *, struct ldpd_conf *);
void	merge_nbrps(struct ldpd_conf *, struct ldpd_conf *);
void	merge_l2vpns(struct ldpd_conf *, struct ldpd_conf *);
void	merge_l2vpn(struct ldpd_conf *, struct l2vpn *, struct l2vpn *);

int	pipe_parent2ldpe[2];
int	pipe_parent2lde[2];
int	pipe_ldpe2lde[2];

struct ldpd_conf	*ldpd_conf = NULL;
struct imsgev		*iev_ldpe;
struct imsgev		*iev_lde;
char			*conffile;

pid_t			 ldpe_pid = 0;
pid_t			 lde_pid = 0;

extern struct ldpd_conf	*leconf;
d84 1
a84 1
void
d122 1
a122 1
__dead void
a131 2
struct ldpd_global global;

d279 1
a279 1
void
d309 1
a309 1
int
d331 1
a331 1
void
d412 1
a412 1
void
d502 1
a502 1
int
d567 1
a567 1
void
d576 1
a576 1
void
d625 1
a625 1
int
d699 1
a699 1
void
d731 1
a731 1
void
d795 1
a795 1
void
d830 1
a830 1
void
d842 1
a842 1
void
d883 1
a883 1
void
d950 1
a950 1
void
d1000 1
a1000 1
void
@


1.43
log
@Assorted fixes and small cleanup.

Nothing really interesting here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.42 2016/05/23 18:41:59 renato Exp $ */
d57 2
a58 2
void	main_imsg_send_net_sockets(void);
void	main_imsg_send_net_socket(enum socket_type);
d61 1
d63 1
d268 2
a269 1
	main_imsg_send_net_sockets();
d339 1
d365 2
a366 1
			main_imsg_send_net_sockets();
d570 1
a570 1
main_imsg_send_net_sockets(void)
d572 4
a575 4
	main_imsg_send_net_socket(LDP_SOCKET_DISC);
	main_imsg_send_net_socket(LDP_SOCKET_EDISC);
	main_imsg_send_net_socket(LDP_SOCKET_SESSION);
	main_imsg_compose_ldpe(IMSG_SETUP_SOCKETS, 0, NULL, 0);
d579 1
a579 1
main_imsg_send_net_socket(enum socket_type type)
d583 1
a583 1
	fd = ldp_create_socket(type);
d585 2
a586 2
		log_warnx("%s: failed to create %s socket", __func__,
		    socket_name(type));
d590 1
a590 1
	imsg_compose_event(iev_ldpe, IMSG_SOCKET_NET, 0, 0, fd, &type,
d594 33
d692 2
a703 4
	struct nbr		*nbr;
	struct nbr_params	*nbrp;
	int			 egress_label_changed = 0;

d707 2
a708 1
			ldpe_reset_nbrs();
d711 2
a712 2
				if_update_all();
				tnbr_update_all();
d718 8
a725 2
	if (conf->keepalive != xconf->keepalive) {
		conf->keepalive = xconf->keepalive;
d727 1
a727 1
			ldpe_stop_init_backoff();
d730 17
a746 2
	conf->thello_holdtime = xconf->thello_holdtime;
	conf->thello_interval = xconf->thello_interval;
d750 3
a752 3
	    (conf->flags & F_LDPD_TH_ACCEPT) &&
	    !(xconf->flags & F_LDPD_TH_ACCEPT))
		ldpe_remove_dynamic_tnbrs();
d754 2
a755 2
	if ((conf->flags & F_LDPD_EXPNULL) !=
	    (xconf->flags & F_LDPD_EXPNULL))
d758 1
a758 1
	conf->flags = xconf->flags;
d763 2
a764 1
			lde_change_egress_label(conf->flags & F_LDPD_EXPNULL);
d767 2
a768 1
			kr_change_egress_label(conf->flags & F_LDPD_EXPNULL);
d775 2
a776 2
	if (conf->trans_addr.s_addr != xconf->trans_addr.s_addr) {
		conf->trans_addr = xconf->trans_addr;
d778 1
a778 1
			imsg_compose_event(iev_ldpe, IMSG_CLOSE_SOCKETS, 0,
d782 3
d788 1
a788 1
				nbr->laddr = conf->trans_addr;
d825 2
a826 2
		iface->hello_holdtime = xi->hello_holdtime;
		iface->hello_interval = xi->hello_interval;
d833 12
d854 1
a854 1
		if ((xt = tnbr_find(xconf, tnbr->addr)) == NULL) {
d866 1
a866 1
		if ((tnbr = tnbr_find(conf, xt->addr)) == NULL) {
d1075 2
a1076 1
    		if (pw->lsr_id.s_addr != xp->lsr_id.s_addr)
d1108 2
@


1.42
log
@Enable changing the router-id via config reload.

Now ldpd can start without a router-id, since it can be set later. Since
a router-id of 0.0.0.0 is invalid, interfaces and targeted-neighbors
will check for a valid router-id in order to be activated.

When the router-id is changed, all the neighborships are reset.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.41 2016/05/23 18:40:15 renato Exp $ */
a55 1

d212 1
a212 1
	if (socketpair(AF_UNIX, SOCK_STREAM |SOCK_NONBLOCK | SOCK_CLOEXEC,
d412 2
a413 2
	struct imsgev  *iev = bula;
	struct imsgbuf *ibuf = &iev->ibuf;
a416 1
	struct kpw	*kpw;
d457 3
a459 3

			kpw = imsg.data;
			kmpw_set(kpw);
d465 3
a467 3

			kpw = imsg.data;
			kmpw_unset(kpw);
d1071 3
@


1.41
log
@Several fixes in the config reload handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.40 2016/05/23 18:36:55 renato Exp $ */
d670 13
a682 1
	/* change of rtr_id needs a restart */
@


1.40
log
@Don't create l2vpn targeted neighbors inside the config parser.

When removing a configured pseudowire, we remove the associated tnbr
in ldpe_l2vpn_pw_exit(). So, when a new pseudowire is configured, it
makes sense to create its tnbr in ldpe_l2vpn_pw_init() to keep things
consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.39 2016/05/23 18:33:56 renato Exp $ */
d80 2
d262 1
a262 1
	kif_redistribute();
d666 2
d671 6
a676 1
	conf->keepalive = xconf->keepalive;
a678 1
	conf->trans_addr = xconf->trans_addr;
d681 5
d704 18
d744 4
d754 2
a756 3
	/* resend addresses to activate new interfaces */
	if (ldpd_process == PROC_MAIN)
		kif_redistribute();
d784 1
d795 2
d805 1
d813 1
a813 3
					if (nbr->state == NBR_STA_OPER)
						session_shutdown(nbr,
						    S_SHUTDOWN, 0, 0);
d830 1
a830 4
					if (nbr->state == NBR_STA_OPER)
						session_shutdown(nbr,
						    S_SHUTDOWN, 0, 0);
					pfkey_remove(nbr);
d839 7
d851 1
d855 2
a856 6
			if (nbr &&
			    (nbr->auth.method != nbrp->auth.method ||
			    strcmp(nbr->auth.md5key, nbrp->auth.md5key) != 0)) {
				if (nbr->state == NBR_STA_OPER)
					session_shutdown(nbr, S_SHUTDOWN,
					    0, 0);
d862 2
d912 2
d922 6
d942 1
a942 1
			lif->l2vpn = l2vpn;
d946 2
a947 2
		/* update existing interfaces */
		lif->l2vpn = l2vpn;
d974 1
d989 19
a1007 12
		/* changes that require a full reset of the pseudowire */
		if (l2vpn->pw_type != xl->pw_type ||
		    l2vpn->mtu != xl->mtu ||
		    pw->lsr_id.s_addr != xp->lsr_id.s_addr ||
		    pw->pwid != xp->pwid ||
		    ((pw->flags &
		    (F_PW_STATUSTLV_CONF|F_PW_CWORD_CONF)) !=
		    (xp->flags &
		    (F_PW_STATUSTLV_CONF|F_PW_CWORD_CONF)))) {
			LIST_REMOVE(pw, entry);
			LIST_REMOVE(xp, entry);
			LIST_INSERT_HEAD(&l2vpn->pw_list, xp, entry);
d1009 7
a1015 15
			switch (ldpd_process) {
			case PROC_LDE_ENGINE:
				l2vpn_pw_exit(pw);
				l2vpn_pw_init(xp);
				break;
			case PROC_LDP_ENGINE:
		    		if (pw->lsr_id.s_addr != xp->lsr_id.s_addr) {
					ldpe_l2vpn_pw_exit(pw);
					ldpe_l2vpn_pw_init(xp);
				}
				free(pw);
				break;
			case PROC_MAIN:
				free(pw);
				break;
d1018 25
d1044 2
a1045 2
		/* update existing pseudowires */
		pw->l2vpn = xp->l2vpn;
d1048 1
d1050 1
@


1.39
log
@Create network sockets on the parent process.

We drop our privileges in ldpe right after we create the network sockets.
The problem is that we might want to change the transport-address and
reload the config, in which case we need new sockets. To allow that,
always create the network sockets in the parent process and pass them
to ldpe via imsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.38 2016/05/23 18:28:22 renato Exp $ */
a906 2
			LIST_REMOVE(pw, entry);

d909 1
a909 1
				l2vpn_pw_del(pw);
a912 1
				free(pw);
a914 1
				free(pw);
d917 3
d956 1
a956 1
				l2vpn_pw_del(pw);
@


1.38
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).

In addition, copy in_addr structs directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.37 2016/05/23 17:43:42 renato Exp $ */
d58 2
d265 2
d359 3
d564 25
a712 2
			if (ldpd_process == PROC_LDP_ENGINE)
				if_init(xi);
d751 1
a751 1
				tnbr_init(xt);
@


1.37
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d638 1
a638 1
	conf->trans_addr.s_addr = xconf->trans_addr.s_addr;
d958 1
a958 1
	memcpy(xconf, conf, sizeof(*xconf));
@


1.36
log
@Rework L2VPN code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.35 2016/05/23 16:18:51 renato Exp $ */
d57 1
d59 6
a64 2
int	ldp_sendboth(enum imsg_type, void *, u_int16_t);
void	merge_l2vpns(struct ldpd_conf *, struct l2vpn *, struct l2vpn *);
d127 2
d133 1
a133 1
	int			 ch, opts = 0;
d156 1
a156 1
			opts |= LDPD_OPT_NOACTION;
d159 3
a161 3
			if (opts & LDPD_OPT_VERBOSE)
				opts |= LDPD_OPT_VERBOSE2;
			opts |= LDPD_OPT_VERBOSE;
d173 2
a174 1
	if ((ldpd_conf = parse_config(conffile, opts)) == NULL )
d176 1
d178 2
a179 2
	if (ldpd_conf->opts & LDPD_OPT_NOACTION) {
		if (ldpd_conf->opts & LDPD_OPT_VERBOSE)
d183 1
d196 1
a196 1
	log_verbose(opts & (LDPD_OPT_VERBOSE | LDPD_OPT_VERBOSE2));
d479 1
a479 1
main_imsg_compose_ldpe(int type, pid_t pid, void *data, u_int16_t datalen)
d487 1
a487 1
main_imsg_compose_lde(int type, pid_t pid, void *data, u_int16_t datalen)
d515 2
a516 2
imsg_compose_event(struct imsgev *iev, u_int16_t type,
    u_int32_t peerid, pid_t pid, int fd, void *data, u_int16_t datalen)
d568 1
a568 1
	if ((xconf = parse_config(conffile, ldpd_conf->opts)) == NULL)
d618 2
a619 2
int
ldp_sendboth(enum imsg_type type, void *buf, u_int16_t len)
d621 6
a626 5
	if (imsg_compose_event(iev_ldpe, type, 0, 0, -1, buf, len) == -1)
		return (-1);
	if (imsg_compose_event(iev_lde, type, 0, 0, -1, buf, len) == -1)
		return (-1);
	return (0);
d630 1
a630 1
merge_config(struct ldpd_conf *conf, struct ldpd_conf *xconf)
d632 1
a632 5
	struct iface		*iface, *itmp, *xi;
	struct tnbr		*tnbr, *ttmp, *xt;
	struct nbr_params	*nbrp, *ntmp, *xn;
	struct l2vpn		*l2vpn, *ltmp, *xl;
	struct nbr		*nbr;
a634 1
	conf->flags = xconf->flags;
d640 26
a665 1
	/* merge interfaces */
d682 1
a682 1
				if_init(conf, xi);
d721 1
a721 1
				tnbr_init(conf, xt);
@


1.35
log
@Make neighbor parameters per lsr-id not per transport-address.

With the advent of IPv6 support, a single neighbor can have two different
transport-addresses: one for ipv4 and one for ipv6. In order to define
neighbor-specific parameters in an indistinguishable way, define them
by lsr-id. This way we can switch between LDPov4 and LDPov6 and keep
the same configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.34 2016/05/23 16:14:36 renato Exp $ */
d884 1
a884 1
		    pw->addr.s_addr != xp->addr.s_addr ||
d900 1
a900 1
		    		if (pw->addr.s_addr != xp->addr.s_addr) {
@


1.34
log
@More renaming.

Rename a few more things to improve readability.

* s/F_PW_CONTROLWORD_CONF/F_PW_CWORD_CONF/ (shorter)
* s/F_PW_CONTROLWORD/F_PW_CWORD/ (shorter)
* s/LDPD_FLAG_*/F_LDPD_*/ (consistency)
* s/lde_nbr_address/lde_addr/ (shorter)
* s/ldp_discovery_socket/ldp_disc_socket/ (shorter)
* s/ldp_ediscovery_socket/ldp_edisc_socket/ (shorter)
* s/ldp_sendboth/main_imsg_compose_both/ (consistency)
* s/cons/total/ (makes more sense)
* s/kaddr/ka/ (consistency with remaining code)
* Always use 'ln' for lde_nbrs (consistency)
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.33 2016/05/23 15:55:45 renato Exp $ */
d710 1
a710 1
		if ((xn = nbr_params_find(xconf, nbrp->addr)) == NULL) {
d712 1
a712 1
				nbr = nbr_find_ldpid(nbrp->addr.s_addr);
d726 1
a726 1
		if ((nbrp = nbr_params_find(conf, xn->addr)) == NULL) {
d731 1
a731 1
				nbr = nbr_find_ldpid(xn->addr.s_addr);
d752 1
a752 1
			nbr = nbr_find_ldpid(nbrp->addr.s_addr);
@


1.33
log
@Split merge_config() into smaller functions to improve readability.

The merge code will get bigger when we introduce IPv6 support, so we
better prepare the ground for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.32 2016/05/23 15:47:24 renato Exp $ */
d250 1
a250 1
	if (kr_init(!(ldpd_conf->flags & LDPD_FLAG_NO_FIB_UPDATE)) == -1)
d483 1
a483 1
ldp_sendboth(enum imsg_type type, void *buf, uint16_t len)
d561 2
a562 1
	if (ldp_sendboth(IMSG_RECONF_CONF, xconf, sizeof(*xconf)) == -1)
d566 1
a566 1
		if (ldp_sendboth(IMSG_RECONF_IFACE, iface,
d572 1
a572 1
		if (ldp_sendboth(IMSG_RECONF_TNBR, tnbr,
d578 1
a578 1
		if (ldp_sendboth(IMSG_RECONF_NBRP, nbrp,
d584 1
a584 1
		if (ldp_sendboth(IMSG_RECONF_L2VPN, l2vpn,
d589 1
a589 1
			if (ldp_sendboth(IMSG_RECONF_L2VPN_IF, lif,
d594 1
a594 1
			if (ldp_sendboth(IMSG_RECONF_L2VPN_PW, pw,
d600 1
a600 1
	if (ldp_sendboth(IMSG_RECONF_END, NULL, 0) == -1)
d887 1
a887 1
		    (F_PW_STATUSTLV_CONF|F_PW_CONTROLWORD_CONF)) !=
d889 1
a889 1
		    (F_PW_STATUSTLV_CONF|F_PW_CONTROLWORD_CONF)))) {
@


1.32
log
@Move some code around.

This patch doesn't introduce any logical change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.31 2016/05/23 15:43:11 renato Exp $ */
d661 6
a667 1
	/* merge tnbrs */
d699 7
a706 1
	/* merge neighbor parameters */
d764 6
a770 1
	/* merge l2vpns */
d810 1
a810 1
		merge_l2vpns(conf, l2vpn, xl);
a811 2

	free(xconf);
d815 1
a815 1
merge_l2vpns(struct ldpd_conf *xconf, struct l2vpn *l2vpn, struct l2vpn *xl)
@


1.31
log
@Add knob to configure the transport address.

This will be especially important when we add support for IPv6, because
we'll not be able to use the router-id as the transport-address in
this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.30 2016/05/23 15:41:04 renato Exp $ */
d480 10
@


1.30
log
@Allow setting the session holdtime per neighbor.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.29 2016/05/23 15:14:07 renato Exp $ */
d621 1
@


1.29
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.28 2016/02/02 17:51:11 sthen Exp $ */
d722 1
@


1.28
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.27 2015/12/05 13:11:48 claudio Exp $ */
d375 1
a375 1
			log_debug("main_dispatch_ldpe: error handling imsg %d",
d427 1
a427 2
				log_warn("main_dispatch_lde: error changing "
				    "route");
d434 1
a434 2
				log_warn("main_dispatch_lde: error deleting "
				    "route");
d453 1
a453 1
			log_debug("main_dispatch_lde: error handling imsg %d",
@


1.27
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.26 2015/07/21 05:04:12 renato Exp $ */
a207 3

	/* show who we are */
	setproctitle("parent");
@


1.26
log
@Call control_cleanup() from the ldpe process, where it belongs.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.25 2015/07/21 04:52:29 renato Exp $ */
d328 1
a328 1
		if ((n = imsg_read(ibuf)) == -1)
d405 1
a405 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.25
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.24 2015/07/21 04:45:21 renato Exp $ */
a276 1
	control_cleanup();
@


1.24
log
@Reuse merge_config() logic to simplify the shutdown of each process.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.23 2015/07/21 04:43:28 renato Exp $ */
d59 1
d403 1
d442 16
d549 3
d578 17
d619 1
d748 43
d795 105
d910 1
@


1.23
log
@Add configuration reload support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.22 2015/02/09 11:54:24 claudio Exp $ */
d285 2
a290 1
	free(ldpd_conf);
d710 16
@


1.22
log
@More SOCK_NONBLOCK | SOCK_CLOEXEC love and one less session_socket_blockmode
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.21 2015/01/16 06:40:17 deraadt Exp $ */
d57 1
a57 1
/*int	ldp_reload(void); */
a58 2
/*int	merge_interfaces(struct lspace *, struct lspace *); */
/*struct iface *iface_lookup(struct lspace *, struct iface *); */
a99 1
/*
a103 1
*/
a347 1
/*
a352 1
*/
a523 1
/*
a526 1
	struct lspace		*lspace;
d528 2
d538 3
a540 2
	LIST_FOREACH(lspace, &xconf->lspace_list, entry) {
		if (ldp_sendboth(IMSG_RECONF_AREA, lspace, sizeof(*lspace)) == -1)
d542 7
d550 4
a553 5
		LIST_FOREACH(iface, &lspace->iface_list, entry) {
			if (ldp_sendboth(IMSG_RECONF_IFACE, iface,
			    sizeof(*iface)) == -1)
				return (-1);
		}
a560 1
	kr_reload();
d577 4
a580 4
	struct lspace		*a, *xa, *na;
	struct iface		*iface;
	struct redistribute	*r;
	int			 rchange = 0;
d582 1
d584 13
a596 29
	conf->spf_delay = xconf->spf_delay;
	conf->spf_hold_time = xconf->spf_hold_time;
	if ((conf->redistribute & REDISTRIBUTE_ON) !=
	    (xconf->redistribute & REDISTRIBUTE_ON))
		rchange = 1;
	conf->redistribute = xconf->redistribute;
	conf->rfc1583compat = xconf->rfc1583compat;

	if (ldpd_process == PROC_MAIN) {
		while ((r = SIMPLEQ_FIRST(&conf->redist_list)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(&conf->redist_list, entry);
			free(r);
		}
		while ((r = SIMPLEQ_FIRST(&xconf->redist_list)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(&xconf->redist_list, entry);
			SIMPLEQ_INSERT_TAIL(&conf->redist_list, r, entry);
		}
		goto done;
	}

	for (a = LIST_FIRST(&conf->lspace_list); a != NULL; a = na) {
		na = LIST_NEXT(a, entry);
		if ((xa = lspace_find(xconf, a->id)) == NULL) {
			if (ldpd_process == PROC_LDP_ENGINE) {
				LIST_FOREACH(iface, &a->iface_list, entry)
					if_fsm(iface, IF_EVT_DOWN);
			}
			LIST_REMOVE(a, entry);
			lspace_del(a);
d599 22
d622 2
a623 5
	for (xa = LIST_FIRST(&xconf->lspace_list); xa != NULL; xa = na) {
		na = LIST_NEXT(xa, entry);
		if ((a = lspace_find(conf, xa->id)) == NULL) {
			LIST_REMOVE(xa, entry);
			LIST_INSERT_HEAD(&conf->lspace_list, xa, entry);
d625 5
a629 8
				LIST_FOREACH(iface, &xa->iface_list, entry) {
					if_init(conf, iface);
					if (if_fsm(iface, IF_EVT_UP)) {
						log_debug("error starting "
						    "interface %s",
						    iface->name);
					}
				}
d631 9
a641 25
		a->stub = xa->stub;
		a->stub_default_cost = xa->stub_default_cost;
		if (ldpd_process == PROC_LDE_ENGINE)
			a->dirty = 1;

		if (merge_interfaces(a, xa) &&
		    ldpd_process == PROC_LDP_ENGINE)
			a->dirty = 1;
	}

	if (ldpd_process == PROC_LDP_ENGINE) {
		LIST_FOREACH(a, &conf->lspace_list, entry) {
			LIST_FOREACH(iface, &a->iface_list, entry) {
				if (iface->state == IF_STA_NEW) {
					iface->state = IF_STA_DOWN;
					if_init(conf, iface);
					if (if_fsm(iface, IF_EVT_UP)) {
						log_debug("error starting "
						    "interface %s",
						    iface->name);
					}
				}
			}
		}
	}
d643 5
a647 4
done:
	while ((a = LIST_FIRST(&xconf->lspace_list)) != NULL) {
		LIST_REMOVE(a, entry);
		lspace_del(a);
a648 2
	free(xconf);
}
d650 15
a664 16
int
merge_interfaces(struct lspace *a, struct lspace *xa)
{
	struct iface	*i, *xi, *ni;
	int		 dirty = 0;

	for (i = LIST_FIRST(&a->iface_list); i != NULL; i = ni) {
		ni = LIST_NEXT(i, entry);
		if (iface_lookup(xa, i) == NULL) {
			log_debug("merge_config: proc %d label space %s removing "
			    "interface %s", ldpd_process, inet_ntoa(a->id),
			    i->name);
			if (ldpd_process == PROC_LDP_ENGINE)
				if_fsm(i, IF_EVT_DOWN);
			LIST_REMOVE(i, entry);
			if_del(i);
d667 5
d673 11
a683 11
	for (xi = LIST_FIRST(&xa->iface_list); xi != NULL; xi = ni) {
		ni = LIST_NEXT(xi, entry);
		if ((i = iface_lookup(a, xi)) == NULL) {
			log_debug("merge_config: proc %d label space %s adding "
			    "interface %s", ldpd_process, inet_ntoa(a->id),
			    xi->name);
			LIST_REMOVE(xi, entry);
			LIST_INSERT_HEAD(&a->iface_list, xi, entry);
			xi->lspace = a;
			if (ldpd_process == PROC_LDP_ENGINE)
				xi->state = IF_STA_NEW;
a685 20
		log_debug("merge_config: proc %d label space %s merging interface %s",
		    ldpd_process, inet_ntoa(a->id), i->name);
		i->addr = xi->addr;
		i->dst = xi->dst;
		i->mask = xi->mask;
		i->abr_id = xi->abr_id;
		i->baudrate = xi->baudrate;
		i->dead_interval = xi->dead_interval;
		i->mtu = xi->mtu;
		i->transmit_delay = xi->transmit_delay;
		i->hello_interval = xi->hello_interval;
		i->rxmt_interval = xi->rxmt_interval;
		if (i->metric != xi->metric)
			dirty = 1;
		i->metric = xi->metric;
		i->priority = xi->priority;
		i->flags = xi->flags;
		i->type = xi->type;
		i->media_type = xi->media_type;
		i->linkstate = xi->linkstate;
d687 18
a704 6
		if (i->passive != xi->passive) {
			if (ldpd_process == PROC_LDP_ENGINE)
				if_fsm(i, IF_EVT_DOWN);
			i->passive = xi->passive;
			if (ldpd_process == PROC_LDP_ENGINE)
				if_fsm(i, IF_EVT_UP);
a706 2
	return (dirty);
}
d708 1
a708 9
struct iface *
iface_lookup(struct lspace *lspace, struct iface *iface)
{
	struct iface	*i;

	LIST_FOREACH(i, &lspace->iface_list, entry)
		if (i->ifindex == iface->ifindex)
			return (i);
	return (NULL);
a709 1
*/
@


1.21
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.20 2014/07/12 20:16:38 krw Exp $ */
d196 2
a197 2
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
	    pipe_parent2ldpe) == -1)
d199 2
a200 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_parent2lde) == -1)
d202 2
a203 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_ldpe2lde) == -1)
a204 6
	session_socket_blockmode(pipe_parent2ldpe[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2ldpe[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2lde[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2lde[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_ldpe2lde[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_ldpe2lde[1], BM_NONBLOCK);
@


1.20
log
@Close connections when msgbuf_write() returns 0.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.19 2013/11/26 11:59:38 henning Exp $ */
a26 1
#include <sys/param.h>
@


1.19
log
@deal with msgbuf_write EAGAIN, ok gilles benno
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.17 2013/06/04 02:25:28 claudio Exp $ */
d342 1
a342 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d344 2
d420 1
a420 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d422 2
@


1.18
log
@Fix whitespace and other style issues.
OK claudio@@
@
text
@d342 1
a342 1
		if (msgbuf_write(&ibuf->w) == -1)
d418 1
a418 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.17
log
@Implement support for adjacencies and targeted hellos
Refactor adjacencies out of the neighbor handling so that it is possible to
have more complex topologies with targeted sessions.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.16 2013/06/03 16:53:49 claudio Exp $ */
a265 1

@


1.16
log
@Implement support for multiple addresses per interface.
This replaces the way addresses and interface are chained together.
In ospfd there was a 1 to 1 mapping (with iface clones) but LDP does
not have that limitation.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.15 2013/06/01 20:13:04 claudio Exp $ */
a298 2

	close(ldpd_conf->ldp_session_socket);
@


1.15
log
@Filter out route messages we don't need and log kernel messages in
super verbose mode.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.14 2013/05/04 09:26:24 jsg Exp $ */
d257 3
@


1.14
log
@fix a use after free
ok sthen@@ jung@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.13 2011/08/20 19:02:28 sthen Exp $ */
a172 2
	/* parse config file */

d190 1
a190 1
	log_verbose(opts & LDPD_OPT_VERBOSE);
@


1.13
log
@Decouple log_verbose() from log_init() so the verbose flag stays set with
"-v" (previously only "-vd" worked). Similar to recent ospfd commit.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.12 2010/09/01 13:54:54 claudio Exp $ */
a297 1
	free(ldpd_conf);
d300 1
@


1.12
log
@s/lfib/fib/ for more consitency with the other routing daemons.
This started manly because of ldpctl beeing inconsistent and me misstyping
lfib almost every time.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.11 2010/07/08 09:41:05 claudio Exp $ */
d137 1
a158 1
			log_verbose(1);
d192 1
@


1.11
log
@Kill more code in kroute.c that is unneeded in ldpd. ldpd is a bit strange
since it does not care that much about reachability of routes. The idea is
to have diverse LSP in the kernel and the kernel should then decide which
path should be used.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.10 2010/06/30 05:21:38 claudio Exp $ */
d259 1
a259 1
	if (kr_init(!(ldpd_conf->flags & LDPD_FLAG_NO_LFIB_UPDATE)) == -1)
d363 2
a364 2
		case IMSG_CTL_LFIB_COUPLE:
			kr_lfib_couple();
d366 2
a367 2
		case IMSG_CTL_LFIB_DECOUPLE:
			kr_lfib_decouple();
@


1.10
log
@Kill IMSG_KLABEL_INSERT and all the related functions around it.
IMSG_KLABEL_CHANGE is smart enough to know when something is a change
or an insert.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.9 2010/06/02 16:01:41 claudio Exp $ */
d466 2
@


1.9
log
@MPLSCTL_ENABLE is gone, no need to check for it. There is also no real
reason why ldpd needs to check for ip forwarding so remove that check
as well. Reminded by phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.8 2010/05/26 13:56:07 nicm Exp $ */
a430 6
		case IMSG_KLABEL_INSERT:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct kroute))
				fatalx("invalid size of IMSG_KLABEL_INSERT");
			kroute_insert_label(imsg.data);
			break;
@


1.8
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.7 2010/03/03 10:17:05 claudio Exp $ */
a27 1
#include <sys/sysctl.h>
a131 3
	int			 ipforwarding, mplsenable;
	int			 mib[4];
	size_t			 len;
a164 21

	mib[0] = CTL_NET;
	mib[1] = PF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_FORWARDING;
	len = sizeof(ipforwarding);
	if (sysctl(mib, 4, &ipforwarding, &len, NULL, 0) == -1)
		err(1, "sysctl");

	if (ipforwarding != 1)
		log_warnx("WARNING: IP forwarding NOT enabled");

	mib[0] = CTL_NET;
	mib[1] = PF_MPLS;
	mib[2] = MPLSCTL_ENABLE;
	len = sizeof(mplsenable);
	if (sysctl(mib, 3, &mplsenable, &len, NULL, 0) == -1)
		err(1, "sysctl");

	if (mplsenable != 1)
		log_warnx("WARNING: MPLS NOT enabled");
@


1.7
log
@Rework the kroute code by stealing some code from ospfd and massaging it
a lot more. Main reason for this is to add priority support. Additionally
add some additional NO_LABEL fixes.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.6 2010/02/25 17:40:46 claudio Exp $ */
d531 1
a531 1
evbuf_enqueue(struct evbuf *eb, struct buf *buf)
d533 1
a533 1
	buf_close(&eb->wbuf, buf);
@


1.6
log
@Do not use bufferevent for something that's already covered in the imsg
buffer API. This fixes a few possible problems in session_read and does
some further cleanup in various places. Wrap msgbuf into evbuf to add
libevent functionality and use buf_read to handle the read side of a
session.  OK michele@@ and dlg@@ did not see anything evil
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.5 2009/11/02 20:34:58 claudio Exp $ */
d457 3
d463 3
d471 3
@


1.5
log
@More IMSG_CTL_LOG_VERBOSE, still doing the same toggeling of log_debug().
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.4 2009/10/28 09:15:58 sobrado Exp $ */
d519 31
@


1.4
log
@remove an unimplemented flag from both usage() and getopt(3)'s
option string.

ok claudio@@, michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.3 2009/07/13 19:04:26 michele Exp $ */
d162 1
a163 1

d359 1
a359 1
	int			 shut = 0;
d405 5
@


1.3
log
@Get rid of the multipath code, as it is not needed.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.2 2009/06/06 08:09:43 pyr Exp $ */
d122 1
a122 1
	fprintf(stderr, "usage: %s [-cdnv] [-D macro=value] [-f file]\n",
d142 1
a142 1
	while ((ch = getopt(argc, argv, "cdD:f:nv")) != -1) {
@


1.2
log
@make ldpd imsg-in-a-lib ready too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d430 1
a430 1
	int		 count, shut = 0;
d455 1
a455 3
			count = (imsg.hdr.len - IMSG_HEADER_SIZE) /
			    sizeof(struct kroute);
			if (kr_change(imsg.data, count))
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d69 2
a70 2
struct imsgbuf		*ibuf_ldpe;
struct imsgbuf		*ibuf_lde;
d265 2
a266 2
	if ((ibuf_ldpe = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_lde = malloc(sizeof(struct imsgbuf))) == NULL)
d268 4
a271 2
	imsg_init(ibuf_ldpe, pipe_parent2ldpe[0], main_dispatch_ldpe);
	imsg_init(ibuf_lde, pipe_parent2lde[0], main_dispatch_lde);
d274 9
a282 9
	ibuf_ldpe->events = EV_READ;
	event_set(&ibuf_ldpe->ev, ibuf_ldpe->fd, ibuf_ldpe->events,
	    ibuf_ldpe->handler, ibuf_ldpe);
	event_add(&ibuf_ldpe->ev, NULL);

	ibuf_lde->events = EV_READ;
	event_set(&ibuf_lde->ev, ibuf_lde->fd, ibuf_lde->events,
	    ibuf_lde->handler, ibuf_lde);
	event_add(&ibuf_lde->ev, NULL);
d318 4
a321 4
	msgbuf_clear(&ibuf_ldpe->w);
	free(ibuf_ldpe);
	msgbuf_clear(&ibuf_lde->w);
	free(ibuf_lde);
d355 2
a356 1
	struct imsgbuf		*ibuf = bula;
d414 1
a414 1
		imsg_event_add(ibuf);
d417 1
a417 1
		event_del(&ibuf->ev);
d426 2
a427 1
	struct imsgbuf  *ibuf = bula;
d474 1
a474 1
		imsg_event_add(ibuf);
d477 1
a477 1
		event_del(&ibuf->ev);
d485 1
a485 1
	imsg_compose(ibuf_ldpe, type, 0, pid, data, datalen);
d491 1
a491 1
	imsg_compose(ibuf_lde, type, 0, pid, data, datalen);
a493 1
/* this needs to be added here so that ldpctl can be used without libevent */
d495 1
a495 1
imsg_event_add(struct imsgbuf *ibuf)
d497 19
a515 7
	ibuf->events = EV_READ;
	if (ibuf->w.queued)
		ibuf->events |= EV_WRITE;

	event_del(&ibuf->ev);
	event_set(&ibuf->ev, ibuf->fd, ibuf->events, ibuf->handler, ibuf);
	event_add(&ibuf->ev, NULL);
d555 1
a555 1
	if (imsg_compose(ibuf_ldpe, type, 0, 0, buf, len) == -1)
d557 1
a557 1
	if (imsg_compose(ibuf_lde, type, 0, 0, buf, len) == -1)
@

