head	1.69;
access;
symbols
	OPENBSD_6_2:1.69.0.2
	OPENBSD_6_2_BASE:1.69
	OPENBSD_6_1:1.69.0.4
	OPENBSD_6_1_BASE:1.69
	OPENBSD_6_0:1.63.0.2
	OPENBSD_6_0_BASE:1.63
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.6
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.29.0.10
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.8
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.6
	OPENBSD_5_0:1.29.0.4
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.2
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.69
date	2017.03.04.00.15.35;	author renato;	state Exp;
branches;
next	1.68;
commitid	BOl8emh4A0ljUk3b;

1.68
date	2017.03.04.00.12.26;	author renato;	state Exp;
branches;
next	1.67;
commitid	bHPjS8k63pM8XVeR;

1.67
date	2017.03.04.00.09.17;	author renato;	state Exp;
branches;
next	1.66;
commitid	tAFME29r3wKSl8xr;

1.66
date	2017.03.04.00.03.04;	author renato;	state Exp;
branches;
next	1.65;
commitid	QsrgLdkTVf5ppNUE;

1.65
date	2017.03.03.23.59.58;	author renato;	state Exp;
branches;
next	1.64;
commitid	gV1qOHkMtUZEiLK0;

1.64
date	2017.03.03.23.41.27;	author renato;	state Exp;
branches;
next	1.63;
commitid	lvj5kMm2TzZDSXqr;

1.63
date	2016.07.01.23.36.38;	author renato;	state Exp;
branches;
next	1.62;
commitid	h9Qy21EPYXbAFnoh;

1.62
date	2016.07.01.23.29.55;	author renato;	state Exp;
branches;
next	1.61;
commitid	OkOx7tFZtmlIlivU;

1.61
date	2016.06.18.01.29.05;	author renato;	state Exp;
branches;
next	1.60;
commitid	uibFJsTlGAQwmzl4;

1.60
date	2016.06.18.01.25.53;	author renato;	state Exp;
branches;
next	1.59;
commitid	ru2TxJdOjUpe8t8d;

1.59
date	2016.06.11.02.03.36;	author renato;	state Exp;
branches;
next	1.58;
commitid	UoiUlvFaMRStnI43;

1.58
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.57;
commitid	TLlfi1Pk0Z97z8HM;

1.57
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.56;
commitid	AQBoOveMRKjtVfFv;

1.56
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.55;
commitid	t07H0Mk6WGdVWB0W;

1.55
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.54;
commitid	D7VvXbswyzx5Ahb2;

1.54
date	2016.05.23.18.55.21;	author renato;	state Exp;
branches;
next	1.53;
commitid	85kONxXVWUqI2Jhb;

1.53
date	2016.05.23.18.46.13;	author renato;	state Exp;
branches;
next	1.52;
commitid	6J1vRySyD703dZ8m;

1.52
date	2016.05.23.18.44.47;	author renato;	state Exp;
branches;
next	1.51;
commitid	gbvW7yPBn4z2KEIi;

1.51
date	2016.05.23.18.32.24;	author renato;	state Exp;
branches;
next	1.50;
commitid	58jYqsNQiIs57K2s;

1.50
date	2016.05.23.18.28.22;	author renato;	state Exp;
branches;
next	1.49;
commitid	FV8IR5RMrg1EHRis;

1.49
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.48;
commitid	VpAym8dVR6eY4drQ;

1.48
date	2016.05.23.16.54.22;	author renato;	state Exp;
branches;
next	1.47;
commitid	LfWxXXNhiR6poNUS;

1.47
date	2016.05.23.16.52.16;	author renato;	state Exp;
branches;
next	1.46;
commitid	abUj7dgnGqGYyasW;

1.46
date	2016.05.23.16.43.57;	author renato;	state Exp;
branches;
next	1.45;
commitid	yXgTKNKOaRXeBjel;

1.45
date	2016.05.23.16.29.22;	author renato;	state Exp;
branches;
next	1.44;
commitid	TvYWPJTlFdeHPfB0;

1.44
date	2016.05.23.16.25.11;	author renato;	state Exp;
branches;
next	1.43;
commitid	rbQYKxfpthpZ0H0X;

1.43
date	2016.05.23.16.14.36;	author renato;	state Exp;
branches;
next	1.42;
commitid	hNzA87VdOHsaOms9;

1.42
date	2016.05.23.16.12.28;	author renato;	state Exp;
branches;
next	1.41;
commitid	vVUYnEJVjv7IWE6u;

1.41
date	2016.05.23.15.14.07;	author renato;	state Exp;
branches;
next	1.40;
commitid	l3e6PhvoAh8C7elc;

1.40
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.39;
commitid	puLLDX1XPNc3GxB9;

1.39
date	2015.07.21.04.48.42;	author renato;	state Exp;
branches;
next	1.38;
commitid	AMGkBBNYB6bWMC2O;

1.38
date	2015.07.21.04.46.51;	author renato;	state Exp;
branches;
next	1.37;
commitid	vYpvRbGMQ79lkA2Y;

1.37
date	2015.07.19.20.54.16;	author renato;	state Exp;
branches;
next	1.36;
commitid	AcGJH529uphBS2D2;

1.36
date	2015.07.19.20.50.03;	author renato;	state Exp;
branches;
next	1.35;
commitid	HQ4RevpYoLNvLRj2;

1.35
date	2015.07.19.18.34.32;	author renato;	state Exp;
branches;
next	1.34;
commitid	KRfbPnwCvwQrLOu3;

1.34
date	2015.07.19.18.27.59;	author renato;	state Exp;
branches;
next	1.33;
commitid	9kOXzqr0NuJAc5FM;

1.33
date	2015.06.10.20.50.05;	author miod;	state Exp;
branches;
next	1.32;
commitid	MQR5kHnk6hKSfZ87;

1.32
date	2015.04.04.15.15.44;	author renato;	state Exp;
branches;
next	1.31;
commitid	0KK6eZelqMVrwBLG;

1.31
date	2013.10.15.20.21.25;	author renato;	state Exp;
branches;
next	1.30;

1.30
date	2013.06.03.16.56.47;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2010.11.04.09.49.07;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2010.10.26.12.08.14;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2010.10.21.08.24.06;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2010.08.27.12.22.46;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2010.08.26.08.39.43;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.30.22.15.02;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.30.05.21.38;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.30.01.47.11;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.09.14.01.03;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.07.13.24.23;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.02.11.56.29;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.25.09.31.25;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2010.05.19.15.28.51;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2010.05.11.14.54.52;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.13.15.39.29;	author michele;	state Exp;
branches;
next	1.14;

1.14
date	2010.03.03.10.17.05;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2010.02.25.21.47.08;	author michele;	state Exp;
branches;
next	1.12;

1.12
date	2010.02.25.21.07.31;	author michele;	state Exp;
branches;
next	1.11;

1.11
date	2010.02.25.21.02.46;	author michele;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.19.12.49.21;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.19.18.03.08;	author michele;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.08.16.45.51;	author michele;	state Exp;
branches;
next	1.7;

1.7
date	2010.01.02.14.56.02;	author michele;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.28.09.48.46;	author michele;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.02.16.19.17;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.08.18.59.29;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.19.17.10.09;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.22.34.45;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.69
log
@Implement RFC 5919 (LDP End-of-LIB).
@
text
@/*	$OpenBSD: lde_lib.c,v 1.68 2017/03/04 00:12:26 renato Exp $ */

/*
 * Copyright (c) 2013, 2016 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netmpls/mpls.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "ldpd.h"
#include "lde.h"
#include "ldpe.h"
#include "log.h"

static __inline int	 fec_compare(struct fec *, struct fec *);
static int		 lde_nbr_is_nexthop(struct fec_node *,
			    struct lde_nbr *);
static void		 fec_free(void *);
static struct fec_node	*fec_add(struct fec *fec);
static struct fec_nh	*fec_nh_add(struct fec_node *, int, union ldpd_addr *,
			    uint8_t priority);
static void		 fec_nh_del(struct fec_nh *);

RB_GENERATE(fec_tree, fec, entry, fec_compare)

struct fec_tree		 ft = RB_INITIALIZER(&ft);
struct event		 gc_timer;

/* FEC tree functions */
void
fec_init(struct fec_tree *fh)
{
	RB_INIT(fh);
}

static __inline int
fec_compare(struct fec *a, struct fec *b)
{
	if (a->type < b->type)
		return (-1);
	if (a->type > b->type)
		return (1);

	switch (a->type) {
	case FEC_TYPE_IPV4:
		if (ntohl(a->u.ipv4.prefix.s_addr) <
		    ntohl(b->u.ipv4.prefix.s_addr))
			return (-1);
		if (ntohl(a->u.ipv4.prefix.s_addr) >
		    ntohl(b->u.ipv4.prefix.s_addr))
			return (1);
		if (a->u.ipv4.prefixlen < b->u.ipv4.prefixlen)
			return (-1);
		if (a->u.ipv4.prefixlen > b->u.ipv4.prefixlen)
			return (1);
		return (0);
	case FEC_TYPE_IPV6:
		if (memcmp(&a->u.ipv6.prefix, &b->u.ipv6.prefix,
		    sizeof(struct in6_addr)) < 0)
			return (-1);
		if (memcmp(&a->u.ipv6.prefix, &b->u.ipv6.prefix,
		    sizeof(struct in6_addr)) > 0)
			return (1);
		if (a->u.ipv6.prefixlen < b->u.ipv6.prefixlen)
			return (-1);
		if (a->u.ipv6.prefixlen > b->u.ipv6.prefixlen)
			return (1);
		return (0);
	case FEC_TYPE_PWID:
		if (a->u.pwid.type < b->u.pwid.type)
			return (-1);
		if (a->u.pwid.type > b->u.pwid.type)
			return (1);
		if (a->u.pwid.pwid < b->u.pwid.pwid)
			return (-1);
		if (a->u.pwid.pwid > b->u.pwid.pwid)
			return (1);
		if (ntohl(a->u.pwid.lsr_id.s_addr) <
		    ntohl(b->u.pwid.lsr_id.s_addr))
			return (-1);
		if (ntohl(a->u.pwid.lsr_id.s_addr) >
		    ntohl(b->u.pwid.lsr_id.s_addr))
			return (1);
		return (0);
	}

	return (-1);
}

struct fec *
fec_find(struct fec_tree *fh, struct fec *f)
{
	return (RB_FIND(fec_tree, fh, f));
}

int
fec_insert(struct fec_tree *fh, struct fec *f)
{
	if (RB_INSERT(fec_tree, fh, f) != NULL)
		return (-1);
	return (0);
}

int
fec_remove(struct fec_tree *fh, struct fec *f)
{
	if (RB_REMOVE(fec_tree, fh, f) == NULL) {
		log_warnx("%s failed for %s", __func__, log_fec(f));
		return (-1);
	}
	return (0);
}

void
fec_clear(struct fec_tree *fh, void (*free_cb)(void *))
{
	struct fec	*f;

	while ((f = RB_ROOT(fh)) != NULL) {
		fec_remove(fh, f);
		free_cb(f);
	}
}

/* routing table functions */
static int
lde_nbr_is_nexthop(struct fec_node *fn, struct lde_nbr *ln)
{
	struct fec_nh		*fnh;

	LIST_FOREACH(fnh, &fn->nexthops, entry)
		if (lde_address_find(ln, fnh->af, &fnh->nexthop))
			return (1);

	return (0);
}

void
rt_dump(pid_t pid)
{
	struct fec		*f;
	struct fec_node		*fn;
	struct lde_map		*me;
	static struct ctl_rt	 rtctl;

	RB_FOREACH(f, fec_tree, &ft) {
		fn = (struct fec_node *)f;
		if (fn->local_label == NO_LABEL &&
		    LIST_EMPTY(&fn->downstream))
			continue;

		switch (fn->fec.type) {
		case FEC_TYPE_IPV4:
			rtctl.af = AF_INET;
			rtctl.prefix.v4 = fn->fec.u.ipv4.prefix;
			rtctl.prefixlen = fn->fec.u.ipv4.prefixlen;
			break;
		case FEC_TYPE_IPV6:
			rtctl.af = AF_INET6;
			rtctl.prefix.v6 = fn->fec.u.ipv6.prefix;
			rtctl.prefixlen = fn->fec.u.ipv6.prefixlen;
			break;
		default:
			continue;
		}

		rtctl.local_label = fn->local_label;
		LIST_FOREACH(me, &fn->downstream, entry) {
			rtctl.in_use = lde_nbr_is_nexthop(fn, me->nexthop);
			rtctl.nexthop = me->nexthop->id;
			rtctl.remote_label = me->map.label;

			lde_imsg_compose_ldpe(IMSG_CTL_SHOW_LIB, 0, pid,
			    &rtctl, sizeof(rtctl));
		}
		if (LIST_EMPTY(&fn->downstream)) {
			rtctl.in_use = 0;
			rtctl.nexthop.s_addr = INADDR_ANY;
			rtctl.remote_label = NO_LABEL;

			lde_imsg_compose_ldpe(IMSG_CTL_SHOW_LIB, 0, pid,
			    &rtctl, sizeof(rtctl));
		}
	}
}

void
fec_snap(struct lde_nbr *ln)
{
	struct fec	*f;
	struct fec_node	*fn;

	RB_FOREACH(f, fec_tree, &ft) {
		fn = (struct fec_node *)f;
		if (fn->local_label == NO_LABEL)
			continue;

		lde_send_labelmapping(ln, fn, 0);
	}

	lde_imsg_compose_ldpe(IMSG_MAPPING_ADD_END, ln->peerid, 0, NULL, 0);

	/*
	 * RFC 5919 - Section 4:
	 * "An LDP speaker that conforms to this specification SHOULD signal
	 * completion of its label advertisements to a peer by means of a
	 * Notification message, if its peer has advertised the Unrecognized
	 * Notification capability during session establishment.  The LDP
	 * speaker SHOULD send the Notification message (per Forwarding
	 * Equivalence Class (FEC) Type) to a peer even if the LDP speaker has
	 * zero Label bindings to advertise to that peer".
	 */
	if (ln->flags & F_NBR_CAP_UNOTIF) {
		lde_send_notification_eol_prefix(ln, AF_INET);
		lde_send_notification_eol_prefix(ln, AF_INET6);
		lde_send_notification_eol_pwid(ln, PW_TYPE_WILDCARD);
	}
}

static void
fec_free(void *arg)
{
	struct fec_node	*fn = arg;
	struct fec_nh	*fnh;

	while ((fnh = LIST_FIRST(&fn->nexthops)))
		fec_nh_del(fnh);
	if (!LIST_EMPTY(&fn->downstream))
		log_warnx("%s: fec %s downstream list not empty", __func__,
		    log_fec(&fn->fec));
	if (!LIST_EMPTY(&fn->upstream))
		log_warnx("%s: fec %s upstream list not empty", __func__,
		    log_fec(&fn->fec));

	free(fn);
}

void
fec_tree_clear(void)
{
	fec_clear(&ft, fec_free);
}

static struct fec_node *
fec_add(struct fec *fec)
{
	struct fec_node	*fn;

	fn = calloc(1, sizeof(*fn));
	if (fn == NULL)
		fatal(__func__);

	fn->fec = *fec;
	fn->local_label = NO_LABEL;
	LIST_INIT(&fn->upstream);
	LIST_INIT(&fn->downstream);
	LIST_INIT(&fn->nexthops);

	if (fec_insert(&ft, &fn->fec))
		log_warnx("failed to add %s to ft tree",
		    log_fec(&fn->fec));

	return (fn);
}

struct fec_nh *
fec_nh_find(struct fec_node *fn, int af, union ldpd_addr *nexthop,
    uint8_t priority)
{
	struct fec_nh	*fnh;

	LIST_FOREACH(fnh, &fn->nexthops, entry)
		if (fnh->af == af &&
		    ldp_addrcmp(af, &fnh->nexthop, nexthop) == 0 &&
		    fnh->priority == priority)
			return (fnh);

	return (NULL);
}

static struct fec_nh *
fec_nh_add(struct fec_node *fn, int af, union ldpd_addr *nexthop,
    uint8_t priority)
{
	struct fec_nh	*fnh;

	fnh = calloc(1, sizeof(*fnh));
	if (fnh == NULL)
		fatal(__func__);

	fnh->af = af;
	fnh->nexthop = *nexthop;
	fnh->remote_label = NO_LABEL;
	fnh->priority = priority;
	LIST_INSERT_HEAD(&fn->nexthops, fnh, entry);

	return (fnh);
}

static void
fec_nh_del(struct fec_nh *fnh)
{
	LIST_REMOVE(fnh, entry);
	free(fnh);
}

uint32_t
egress_label(enum fec_type fec_type)
{
	switch (fec_type) {
	case FEC_TYPE_IPV4:
		if (ldeconf->ipv4.flags & F_LDPD_AF_EXPNULL)
			return (MPLS_LABEL_IPV4NULL);
		break;
	case FEC_TYPE_IPV6:
		if (ldeconf->ipv6.flags & F_LDPD_AF_EXPNULL)
			return (MPLS_LABEL_IPV6NULL);
		break;
	default:
		fatalx("egress_label: unexpected fec type");
	}

	return (MPLS_LABEL_IMPLNULL);
}

void
lde_kernel_insert(struct fec *fec, int af, union ldpd_addr *nexthop,
    uint8_t priority, int connected, void *data)
{
	struct fec_node		*fn;
	struct fec_nh		*fnh;
	struct lde_map		*me;
	struct lde_nbr		*ln;

	fn = (struct fec_node *)fec_find(&ft, fec);
	if (fn == NULL)
		fn = fec_add(fec);
	if (fec_nh_find(fn, af, nexthop, priority) != NULL)
		return;

	log_debug("lde add fec %s nexthop %s",
	    log_fec(&fn->fec), log_addr(af, nexthop));

	if (fn->fec.type == FEC_TYPE_PWID)
		fn->data = data;

	if (fn->local_label == NO_LABEL) {
		if (connected)
			fn->local_label = egress_label(fn->fec.type);
		else
			fn->local_label = lde_assign_label();

		/* FEC.1: perform lsr label distribution procedure */
		RB_FOREACH(ln, nbr_tree, &lde_nbrs)
			lde_send_labelmapping(ln, fn, 1);
	}

	fnh = fec_nh_add(fn, af, nexthop, priority);
	lde_send_change_klabel(fn, fnh);

	switch (fn->fec.type) {
	case FEC_TYPE_IPV4:
	case FEC_TYPE_IPV6:
		ln = lde_nbr_find_by_addr(af, &fnh->nexthop);
		break;
	case FEC_TYPE_PWID:
		ln = lde_nbr_find_by_lsrid(fn->fec.u.pwid.lsr_id);
		break;
	default:
		ln = NULL;
		break;
	}

	if (ln) {
		/* FEC.2  */
		me = (struct lde_map *)fec_find(&ln->recv_map, &fn->fec);
		if (me)
			/* FEC.5 */
			lde_check_mapping(&me->map, ln);
	}
}

void
lde_kernel_remove(struct fec *fec, int af, union ldpd_addr *nexthop,
    uint8_t priority)
{
	struct fec_node		*fn;
	struct fec_nh		*fnh;
	struct lde_nbr		*ln;

	fn = (struct fec_node *)fec_find(&ft, fec);
	if (fn == NULL)
		/* route lost */
		return;
	fnh = fec_nh_find(fn, af, nexthop, priority);
	if (fnh == NULL)
		/* route lost */
		return;

	log_debug("lde remove fec %s nexthop %s",
	    log_fec(&fn->fec), log_addr(af, nexthop));

	lde_send_delete_klabel(fn, fnh);
	fec_nh_del(fnh);
	if (LIST_EMPTY(&fn->nexthops)) {
		RB_FOREACH(ln, nbr_tree, &lde_nbrs)
			lde_send_labelwithdraw(ln, fn, NULL, NULL);
		fn->local_label = NO_LABEL;
		if (fn->fec.type == FEC_TYPE_PWID)
			fn->data = NULL;
	}
}

void
lde_check_mapping(struct map *map, struct lde_nbr *ln)
{
	struct fec		 fec;
	struct fec_node		*fn;
	struct fec_nh		*fnh;
	struct lde_req		*lre;
	struct lde_map		*me;
	struct l2vpn_pw		*pw;
	int			 msgsource = 0;

	lde_map2fec(map, ln->id, &fec);
	fn = (struct fec_node *)fec_find(&ft, &fec);
	if (fn == NULL)
		fn = fec_add(&fec);

	/* LMp.1: first check if we have a pending request running */
	lre = (struct lde_req *)fec_find(&ln->sent_req, &fn->fec);
	if (lre)
		/* LMp.2: delete record of outstanding label request */
		lde_req_del(ln, lre, 1);

	/* RFC 4447 control word and status tlv negotiation */
	if (map->type == MAP_TYPE_PWID && l2vpn_pw_negotiate(ln, fn, map))
		return;

	/*
	 * LMp.3 - LMp.8: loop detection - unnecessary for frame-mode
	 * mpls networks.
	 */

	/* LMp.9 */
	me = (struct lde_map *)fec_find(&ln->recv_map, &fn->fec);
	if (me) {
		/* LMp.10 */
		if (me->map.label != map->label && lre == NULL) {
			/* LMp.10a */
			lde_send_labelrelease(ln, fn, NULL, me->map.label);

			/*
			 * Can not use lde_nbr_find_by_addr() because there's
			 * the possibility of multipath.
			 */
			LIST_FOREACH(fnh, &fn->nexthops, entry) {
				if (lde_address_find(ln, fnh->af,
				    &fnh->nexthop) == NULL)
					continue;

				lde_send_delete_klabel(fn, fnh);
				fnh->remote_label = NO_LABEL;
			}
		}
	}

	/*
	 * LMp.11 - 12: consider multiple nexthops in order to
	 * support multipath
	 */
	LIST_FOREACH(fnh, &fn->nexthops, entry) {
		/* LMp.15: install FEC in FIB */
		switch (fec.type) {
		case FEC_TYPE_IPV4:
		case FEC_TYPE_IPV6:
			if (!lde_address_find(ln, fnh->af, &fnh->nexthop))
				continue;

			fnh->remote_label = map->label;
			lde_send_change_klabel(fn, fnh);
			break;
		case FEC_TYPE_PWID:
			pw = (struct l2vpn_pw *) fn->data;
			if (pw == NULL)
				continue;

			pw->remote_group = map->fec.pwid.group_id;
			if (map->flags & F_MAP_PW_IFMTU)
				pw->remote_mtu = map->fec.pwid.ifmtu;
			if (map->flags & F_MAP_PW_STATUS)
				pw->remote_status = map->pw_status;
			fnh->remote_label = map->label;
			if (l2vpn_pw_ok(pw, fnh))
				lde_send_change_klabel(fn, fnh);
			break;
		default:
			break;
		}

		msgsource = 1;
	}
	/* LMp.13 & LMp.16: Record the mapping from this peer */
	if (me == NULL)
		me = lde_map_add(ln, fn, 0);
	me->map = *map;

	if (msgsource == 0)
		/* LMp.13: just return since we use liberal lbl retention */
		return;

	/*
	 * LMp.17 - LMp.27 are unnecessary since we don't need to implement
	 * loop detection. LMp.28 - LMp.30 are unnecessary because we are
	 * merging capable.
	 */
}

void
lde_check_request(struct map *map, struct lde_nbr *ln)
{
	struct fec	 fec;
	struct lde_req	*lre;
	struct fec_node	*fn;
	struct fec_nh	*fnh;

	/* wildcard label request */
	if (map->type == MAP_TYPE_TYPED_WCARD) {
		lde_check_request_wcard(map, ln);
		return;
	}

	/* LRq.1: skip loop detection (not necessary) */

	/* LRq.2: is there a next hop for fec? */
	lde_map2fec(map, ln->id, &fec);
	fn = (struct fec_node *)fec_find(&ft, &fec);
	if (fn == NULL || LIST_EMPTY(&fn->nexthops)) {
		/* LRq.5: send No Route notification */
		lde_send_notification(ln, S_NO_ROUTE, map->msg_id,
		    htons(MSG_TYPE_LABELREQUEST));
		return;
	}

	/* LRq.3: is MsgSource the next hop? */
	LIST_FOREACH(fnh, &fn->nexthops, entry) {
		switch (fec.type) {
		case FEC_TYPE_IPV4:
		case FEC_TYPE_IPV6:
			if (!lde_address_find(ln, fnh->af, &fnh->nexthop))
				continue;

			/* LRq.4: send Loop Detected notification */
			lde_send_notification(ln, S_LOOP_DETECTED, map->msg_id,
			    htons(MSG_TYPE_LABELREQUEST));
			return;
		default:
			break;
		}
	}

	/* LRq.6: first check if we have a pending request running */
	lre = (struct lde_req *)fec_find(&ln->recv_req, &fn->fec);
	if (lre != NULL)
		/* LRq.7: duplicate request */
		return;

	/* LRq.8: record label request */
	lre = lde_req_add(ln, &fn->fec, 0);
	if (lre != NULL)
		lre->msg_id = ntohl(map->msg_id);

	/* LRq.9: perform LSR label distribution */
	lde_send_labelmapping(ln, fn, 1);

	/*
	 * LRq.10: do nothing (Request Never) since we use liberal
	 * label retention.
	 * LRq.11 - 12 are unnecessary since we are merging capable.
	 */
}

void
lde_check_request_wcard(struct map *map, struct lde_nbr *ln)
{
	struct fec	*f;
	struct fec_node	*fn;
	struct lde_req	*lre;

	RB_FOREACH(f, fec_tree, &ft) {
		fn = (struct fec_node *)f;

		/* only a typed wildcard is possible here */
		if (lde_wildcard_apply(map, &fn->fec, NULL) == 0)
			continue;

		/* LRq.2: is there a next hop for fec? */
		if (LIST_EMPTY(&fn->nexthops))
			continue;

		/* LRq.6: first check if we have a pending request running */
		lre = (struct lde_req *)fec_find(&ln->recv_req, &fn->fec);
		if (lre != NULL)
			/* LRq.7: duplicate request */
			continue;

		/* LRq.8: record label request */
		lre = lde_req_add(ln, &fn->fec, 0);
		if (lre != NULL)
			lre->msg_id = ntohl(map->msg_id);

		/* LRq.9: perform LSR label distribution */
		lde_send_labelmapping(ln, fn, 1);
	}

	/*
	 * RFC 5919 - Section 5.3:
	 * "When an LDP speaker receives a Label Request message for a Typed
	 * Wildcard FEC (e.g., a particular FEC Element Type) from a peer, the
	 * LDP speaker determines the set of bindings (as per any local
	 * filtering policy) to advertise to the peer for the FEC type specified
	 * by the request.  Assuming the peer had advertised the Unrecognized
	 * Notification capability at session initialization time, the speaker
	 * should send the peer an End-of-LIB Notification for the FEC type when
	 * it completes advertisement of the permitted bindings".
	 */
	if (ln->flags & F_NBR_CAP_UNOTIF) {
		switch (map->fec.twcard.type) {
		case MAP_TYPE_PREFIX:
			lde_send_notification_eol_prefix(ln,
			    map->fec.twcard.u.prefix_af);
			break;
		case MAP_TYPE_PWID:
			lde_send_notification_eol_pwid(ln,
			    map->fec.twcard.u.pw_type);
			break;
		default:
			break;
		}
	}
}

void
lde_check_release(struct map *map, struct lde_nbr *ln)
{
	struct fec		 fec;
	struct fec_node		*fn;
	struct lde_wdraw	*lw;
	struct lde_map		*me;

	/* wildcard label release */
	if (map->type == MAP_TYPE_WILDCARD ||
	    map->type == MAP_TYPE_TYPED_WCARD ||
	    (map->type == MAP_TYPE_PWID && !(map->flags & F_MAP_PW_ID))) {
		lde_check_release_wcard(map, ln);
		return;
	}

	lde_map2fec(map, ln->id, &fec);
	fn = (struct fec_node *)fec_find(&ft, &fec);
	/* LRl.1: does FEC match a known FEC? */
	if (fn == NULL)
		return;

	/* LRl.3: first check if we have a pending withdraw running */
	lw = (struct lde_wdraw *)fec_find(&ln->sent_wdraw, &fn->fec);
	if (lw && (map->label == NO_LABEL || map->label == lw->label)) {
		/* LRl.4: delete record of outstanding label withdraw */
		lde_wdraw_del(ln, lw);
	}

	/* LRl.6: check sent map list and remove it if available */
	me = (struct lde_map *)fec_find(&ln->sent_map, &fn->fec);
	if (me && (map->label == NO_LABEL || map->label == me->map.label))
		lde_map_del(ln, me, 1);

	/*
	 * LRl.11 - 13 are unnecessary since we remove the label from
	 * forwarding/switching as soon as the FEC is unreachable.
	 */
}

void
lde_check_release_wcard(struct map *map, struct lde_nbr *ln)
{
	struct fec		*f;
	struct fec_node		*fn;
	struct lde_wdraw	*lw;
	struct lde_map		*me;

	RB_FOREACH(f, fec_tree, &ft) {
		fn = (struct fec_node *)f;
		me = (struct lde_map *)fec_find(&ln->sent_map, &fn->fec);

		/* LRl.1: does FEC match a known FEC? */
		if (lde_wildcard_apply(map, &fn->fec, me) == 0)
			continue;

		/* LRl.3: first check if we have a pending withdraw running */
		lw = (struct lde_wdraw *)fec_find(&ln->sent_wdraw, &fn->fec);
		if (lw && (map->label == NO_LABEL || map->label == lw->label)) {
			/* LRl.4: delete record of outstanding lbl withdraw */
			lde_wdraw_del(ln, lw);
		}

		/* LRl.6: check sent map list and remove it if available */
		if (me &&
		    (map->label == NO_LABEL || map->label == me->map.label))
			lde_map_del(ln, me, 1);

		/*
		 * LRl.11 - 13 are unnecessary since we remove the label from
		 * forwarding/switching as soon as the FEC is unreachable.
		 */
	}
}

void
lde_check_withdraw(struct map *map, struct lde_nbr *ln)
{
	struct fec		 fec;
	struct fec_node		*fn;
	struct fec_nh		*fnh;
	struct lde_map		*me;
	struct l2vpn_pw		*pw;

	/* wildcard label withdraw */
	if (map->type == MAP_TYPE_WILDCARD ||
	    map->type == MAP_TYPE_TYPED_WCARD ||
	    (map->type == MAP_TYPE_PWID && !(map->flags & F_MAP_PW_ID))) {
		lde_check_withdraw_wcard(map, ln);
		return;
	}

	lde_map2fec(map, ln->id, &fec);
	fn = (struct fec_node *)fec_find(&ft, &fec);
	if (fn == NULL)
		fn = fec_add(&fec);

	/* LWd.1: remove label from forwarding/switching use */
	LIST_FOREACH(fnh, &fn->nexthops, entry) {
		switch (fec.type) {
		case FEC_TYPE_IPV4:
		case FEC_TYPE_IPV6:
			if (!lde_address_find(ln, fnh->af, &fnh->nexthop))
				continue;
			break;
		case FEC_TYPE_PWID:
			pw = (struct l2vpn_pw *) fn->data;
			if (pw == NULL)
				continue;
			break;
		default:
			break;
		}
		if (map->label != NO_LABEL && map->label != fnh->remote_label)
			continue;

		lde_send_delete_klabel(fn, fnh);
		fnh->remote_label = NO_LABEL;
	}

	/* LWd.2: send label release */
	lde_send_labelrelease(ln, fn, NULL, map->label);

	/* LWd.3: check previously received label mapping */
	me = (struct lde_map *)fec_find(&ln->recv_map, &fn->fec);
	if (me && (map->label == NO_LABEL || map->label == me->map.label))
		/* LWd.4: remove record of previously received lbl mapping */
		lde_map_del(ln, me, 0);
}

void
lde_check_withdraw_wcard(struct map *map, struct lde_nbr *ln)
{
	struct fec	*f;
	struct fec_node	*fn;
	struct fec_nh	*fnh;
	struct lde_map	*me;

	/* LWd.2: send label release */
	lde_send_labelrelease(ln, NULL, map, map->label);

	RB_FOREACH(f, fec_tree, &ft) {
		fn = (struct fec_node *)f;
		me = (struct lde_map *)fec_find(&ln->recv_map, &fn->fec);

		if (lde_wildcard_apply(map, &fn->fec, me) == 0)
			continue;

		/* LWd.1: remove label from forwarding/switching use */
		LIST_FOREACH(fnh, &fn->nexthops, entry) {
			switch (f->type) {
			case FEC_TYPE_IPV4:
			case FEC_TYPE_IPV6:
				if (!lde_address_find(ln, fnh->af,
				    &fnh->nexthop))
					continue;
				break;
			case FEC_TYPE_PWID:
				if (f->u.pwid.lsr_id.s_addr != ln->id.s_addr)
					continue;
				break;
			default:
				break;
			}
			if (map->label != NO_LABEL && map->label !=
			    fnh->remote_label)
				continue;

			lde_send_delete_klabel(fn, fnh);
			fnh->remote_label = NO_LABEL;
		}

		/* LWd.3: check previously received label mapping */
		if (me && (map->label == NO_LABEL ||
		    map->label == me->map.label))
			/*
			 * LWd.4: remove record of previously received
			 * label mapping
			 */
			lde_map_del(ln, me, 0);
	}
}

int
lde_wildcard_apply(struct map *wcard, struct fec *fec, struct lde_map *me)
{
	switch (wcard->type) {
	case MAP_TYPE_WILDCARD:
		/* full wildcard */
		return (1);
	case MAP_TYPE_TYPED_WCARD:
		switch (wcard->fec.twcard.type) {
		case MAP_TYPE_PREFIX:
			if (wcard->fec.twcard.u.prefix_af == AF_INET &&
			    fec->type != FEC_TYPE_IPV4)
				return (0);
			if (wcard->fec.twcard.u.prefix_af == AF_INET6 &&
			    fec->type != FEC_TYPE_IPV6)
				return (0);
			return (1);
		case MAP_TYPE_PWID:
			if (fec->type != FEC_TYPE_PWID)
				return (0);
			if (wcard->fec.twcard.u.pw_type != PW_TYPE_WILDCARD &&
			    wcard->fec.twcard.u.pw_type != fec->u.pwid.type)
				return (0);
			return (1);
		default:
			fatalx("lde_wildcard_apply: unexpected fec type");
		}
		break;
	case MAP_TYPE_PWID:
		/* RFC4447 pw-id group wildcard */
		if (fec->type != FEC_TYPE_PWID)
			return (0);
		if (fec->u.pwid.type != wcard->fec.pwid.type)
			return (0);
		if (me == NULL || (me->map.fec.pwid.group_id !=
		    wcard->fec.pwid.group_id))
			return (0);
		return (1);
	default:
		fatalx("lde_wildcard_apply: unexpected fec type");
	}
}

/* gabage collector timer: timer to remove dead entries from the LIB */

/* ARGSUSED */
void
lde_gc_timer(int fd, short event, void *arg)
{
	struct fec	*fec, *safe;
	struct fec_node	*fn;
	int		 count = 0;

	RB_FOREACH_SAFE(fec, fec_tree, &ft, safe) {
		fn = (struct fec_node *) fec;

		if (!LIST_EMPTY(&fn->nexthops) ||
		    !LIST_EMPTY(&fn->downstream) ||
		    !LIST_EMPTY(&fn->upstream))
			continue;

		fec_remove(&ft, &fn->fec);
		free(fn);
		count++;
	}

	if (count > 0)
		log_debug("%s: %u entries removed", __func__, count);

	lde_gc_start_timer();
}

void
lde_gc_start_timer(void)
{
	struct timeval	 tv;

	timerclear(&tv);
	tv.tv_sec = LDE_GC_INTERVAL;
	if (evtimer_add(&gc_timer, &tv) == -1)
		fatal(__func__);
}

void
lde_gc_stop_timer(void)
{
	if (evtimer_pending(&gc_timer, NULL) &&
	    evtimer_del(&gc_timer) == -1)
		fatal(__func__);
}
@


1.68
log
@Implement RFC 6667 (Typed Wildcard FEC for PWid).
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.67 2017/03/04 00:09:17 renato Exp $ */
d29 1
d219 16
d631 26
@


1.67
log
@Implement RFC 5918 (Typed Wildcard FEC).
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.66 2017/03/04 00:03:04 renato Exp $ */
d815 7
@


1.66
log
@Implement support for PWid group wildcards.

This was missing from our original RFC 4447 VPLS implementation. Now
ldpd understands group wildcards as mandated by the RFC, but we still
don't send them ourselves. I can't see any case in which sending a group
wildcard would be useful, but nonetheless this patch provides a function
called lde_send_labelwithdraw_pwid_wcard() which is ready to be used in
the future anytime we feel like it might be useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.65 2017/03/03 23:59:58 renato Exp $ */
d527 6
d584 34
d627 1
d703 1
d807 14
@


1.65
log
@Fix processing of Label Withdraw messages.

Whenever we receive a Label Withdraw message with an optional Label
TLV, we should check if this label matches the label previously
received from this neighbor for this FEC. If they don't match then we
shouldn't uninstall the previous label from the kernel. This fixes a
misinterpretation from the "Receive Label Withdraw" algorithm described
in the A.1.5 section of RFC 5036.

Also, simplify the check of pending withdraws in lde_check_release()
and lde_check_release_wcard().
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.64 2017/03/03 23:41:27 renato Exp $ */
d389 1
d406 2
a407 1
		lde_send_labelwithdraw_all(fn, NO_LABEL);
d451 1
a451 1
			lde_send_labelrelease(ln, fn, me->map.label);
d585 4
a588 2
	/* TODO group wildcard */
	if (map->type == MAP_TYPE_PWID && !(map->flags & F_MAP_PW_ID))
d590 1
d626 5
a639 1
		me = (struct lde_map *)fec_find(&ln->sent_map, &fn->fec);
d660 4
a663 2
	/* TODO group wildcard */
	if (map->type == MAP_TYPE_PWID && !(map->flags & F_MAP_PW_ID))
d665 1
d696 1
a696 1
	lde_send_labelrelease(ln, fn, map->label);
d714 1
a714 1
	lde_send_labelrelease(ln, NULL, map->label);
d718 4
a747 1
		me = (struct lde_map *)fec_find(&ln->recv_map, &fn->fec);
d755 22
@


1.64
log
@Minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.63 2016/07/01 23:36:38 renato Exp $ */
d595 1
a595 2
	if (lw && (map->label == NO_LABEL ||
	    (lw->label != NO_LABEL && map->label == lw->label))) {
d624 1
a624 2
		if (lw && (map->label == NO_LABEL ||
		    (lw->label != NO_LABEL && map->label == lw->label))) {
d676 3
d723 4
@


1.63
log
@More renaming and whitespace cleanup.

No binary change after "strip -s".
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.62 2016/07/01 23:29:55 renato Exp $ */
d532 1
a532 1
		lde_send_notification(ln->peerid, S_NO_ROUTE, map->msg_id,
d546 2
a547 2
			lde_send_notification(ln->peerid, S_LOOP_DETECTED,
			    map->msg_id, htons(MSG_TYPE_LABELREQUEST));
@


1.62
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.61 2016/06/18 01:29:05 renato Exp $ */
d532 1
a532 1
		lde_send_notification(ln->peerid, S_NO_ROUTE, map->messageid,
d547 1
a547 1
			    map->messageid, htons(MSG_TYPE_LABELREQUEST));
d563 1
a563 1
		lre->msgid = ntohl(map->messageid);
@


1.61
log
@Remove TODO comments about loop detection.

LDP loop detection is only necessary for ATM LSRs running in cell mode. We
are never going to implement this "feature".

Also, add two more comments in lde_check_request().
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.60 2016/06/18 01:25:53 renato Exp $ */
d312 3
a314 3
		if (!(ldeconf->ipv4.flags & F_LDPD_AF_EXPNULL))
			return (MPLS_LABEL_IMPLNULL);
		return (MPLS_LABEL_IPV4NULL);
d316 3
a318 3
		if (!(ldeconf->ipv6.flags & F_LDPD_AF_EXPNULL))
			return (MPLS_LABEL_IMPLNULL);
		return (MPLS_LABEL_IPV6NULL);
d320 1
a320 1
		log_warnx("%s: unexpected fec type", __func__);
d323 1
a323 1
	return (NO_LABEL);
@


1.60
log
@Fix small LIB<->LFIB synchronization issue.

ldpd operates only with the best routes of each IP prefix. In other words,
the routes with the lowest priorities.

When a route with a better priority is detected (possibly with a different
nexthop), we should uninstall the labels from the "old" routes and try
to install a new label for the new route (if there's one available in
the LIB).

In this specific case, ldpd was failing to uninstall the labels from the
old routes because it wasn't keeping track of each route's priority in
lde. With this missing bit of information, the parent process had no way
to get the correct label to uninstall when processing a IMSG_KLABEL_DELETE
message.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.59 2016/06/11 02:03:36 renato Exp $ */
d439 2
a440 2
	 * LMp.3 - LMp.8: Loop detection LMp.3 - unecessary for frame-mode
	 * mpls networks
d525 1
a525 1
	/* TODO LRq.1: loop detection */
d531 1
d545 1
@


1.59
log
@Add missing ntohl() when recording a label request.

Fixes the following ANVL LDP tests: 1.5 and 9.4.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.58 2016/05/23 19:14:03 renato Exp $ */
d36 2
a37 1
static struct fec_nh	*fec_nh_add(struct fec_node *, int, union ldpd_addr *);
d267 2
a268 1
fec_nh_find(struct fec_node *fn, int af, union ldpd_addr *nexthop)
d274 2
a275 1
		    ldp_addrcmp(af, &fnh->nexthop, nexthop) == 0)
d282 2
a283 1
fec_nh_add(struct fec_node *fn, int af, union ldpd_addr *nexthop)
d294 1
d328 1
a328 1
    int connected, void *data)
d338 1
a338 1
	if (fec_nh_find(fn, af, nexthop) != NULL)
d358 1
a358 1
	fnh = fec_nh_add(fn, af, nexthop);
d384 2
a385 1
lde_kernel_remove(struct fec *fec, int af, union ldpd_addr *nexthop)
d394 1
a394 1
	fnh = fec_nh_find(fn, af, nexthop);
@


1.58
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.57 2016/05/23 19:11:42 renato Exp $ */
d555 1
a555 1
		lre->msgid = map->messageid;
@


1.57
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.56 2016/05/23 19:09:25 renato Exp $ */
d4 1
@


1.56
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.55 2016/05/23 18:58:48 renato Exp $ */
a19 2
#include <sys/ioctl.h>
#include <sys/time.h>
a20 3
#include <net/if.h>
#include <net/if_types.h>
#include <netinet/in.h>
a21 4
#include <arpa/inet.h>
#include <ctype.h>
#include <err.h>
#include <stdio.h>
a22 1
#include <unistd.h>
d24 1
a24 1
#include <event.h>
d27 1
a27 1
#include "ldp.h"
a28 1
#include "lde.h"
@


1.55
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.54 2016/05/23 18:55:21 renato Exp $ */
d41 7
a47 7
static int fec_compare(struct fec *, struct fec *);

void		 fec_free(void *);
struct fec_node	*fec_add(struct fec *fec);
struct fec_nh	*fec_nh_add(struct fec_node *, int, union ldpd_addr *);
void		 fec_nh_del(struct fec_nh *);
int		 lde_nbr_is_nexthop(struct fec_node *, struct lde_nbr *);
d51 2
a52 7
extern struct nbr_tree	lde_nbrs;
RB_PROTOTYPE(nbr_tree, lde_nbr, entry, lde_nbr_compare)

extern struct ldpd_conf		*ldeconf;

struct fec_tree	ft = RB_INITIALIZER(&ft);
struct event gc_timer;
d61 1
a61 1
static int
d151 1
a151 1
int
d229 1
a229 1
void
d253 1
a253 1
struct fec_node *
d288 1
a288 1
struct fec_nh *
d305 1
a305 1
void
@


1.54
log
@Assorted fixes and small cleanup.

Nothing really interesting here.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.53 2016/05/23 18:46:13 renato Exp $ */
d45 1
a45 1
struct fec_nh	*fec_nh_add(struct fec_node *, struct in_addr);
d87 12
d162 1
a162 1
		if (lde_address_find(ln, &fnh->nexthop))
d178 2
a179 1
		if (fn->fec.type != FEC_TYPE_IPV4)
d182 12
a193 2
		if (fn->local_label == NO_LABEL &&
		    LIST_EMPTY(&fn->downstream))
d195 1
a196 2
		rtctl.prefix = fn->fec.u.ipv4.prefix;
		rtctl.prefixlen = fn->fec.u.ipv4.prefixlen;
a197 1

d281 1
a281 1
fec_nh_find(struct fec_node *fn, struct in_addr nexthop)
d286 2
a287 1
		if (fnh->nexthop.s_addr == nexthop.s_addr)
d294 1
a294 1
fec_nh_add(struct fec_node *fn, struct in_addr nexthop)
d302 2
a303 1
	fnh->nexthop = nexthop;
a319 3
	if (!(ldeconf->flags & F_LDPD_EXPNULL))
		return (MPLS_LABEL_IMPLNULL);

d322 2
d325 4
d337 2
a338 2
lde_kernel_insert(struct fec *fec, struct in_addr nexthop, int connected,
    void *data)
d348 1
a348 1
	if (fec_nh_find(fn, nexthop) != NULL)
d352 1
a352 1
	    log_fec(&fn->fec), inet_ntoa(nexthop));
d368 1
a368 1
	fnh = fec_nh_add(fn, nexthop);
d373 2
a374 1
		ln = lde_nbr_find_by_addr(fnh->nexthop);
d394 1
a394 1
lde_kernel_remove(struct fec *fec, struct in_addr nexthop)
d403 1
a403 1
	fnh = fec_nh_find(fn, nexthop);
d409 1
a409 1
	    log_fec(&fn->fec), inet_ntoa(nexthop));
d465 2
a466 1
				if (lde_address_find(ln, &fnh->nexthop) == NULL)
d483 2
a484 1
			if (!lde_address_find(ln, &fnh->nexthop))
d549 2
a550 1
			if (!lde_address_find(ln, &fnh->nexthop))
d673 2
a674 1
			if (!lde_address_find(ln, &fnh->nexthop))
d717 3
a719 1
				if (!lde_address_find(ln, &fnh->nexthop))
@


1.53
log
@Introduce a garbage collector for dead entries in the LIB.

If we lose a route and all of its associated labels, then there's no
point on keeping an entry for it in the LIB.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.52 2016/05/23 18:44:47 renato Exp $ */
d267 1
a318 3
	log_debug("lde add fec %s nexthop %s",
	    log_fec(fec), inet_ntoa(nexthop));

a321 1

d325 3
a371 3
	log_debug("lde remove fec %s nexthop %s",
	    log_fec(fec), inet_ntoa(nexthop));

a375 1

d381 3
d611 1
a611 1
		    (map->label == NO_LABEL || map->label == me->map.label)) {
a612 1
		}
@


1.52
log
@Simplify label allocation.

Whenever we lose a route, unset the local label. If the same route is
learned again later, allocate a new label for it. No need to be economic
with labels, it's not worth the added complexity.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.51 2016/05/23 18:32:24 renato Exp $ */
d57 1
d712 48
@


1.51
log
@Reuse lde_address_find() inside lde_check_mapping().
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.50 2016/05/23 18:28:22 renato Exp $ */
d330 5
a334 22
	if (LIST_EMPTY(&fn->nexthops)) {
		if (fn->local_label == NO_LABEL) {
			if (connected)
				fn->local_label = egress_label(fn->fec.type);
			else
				fn->local_label = lde_assign_label();
		} else {
			/* Handle local label changes */
			if (connected &&
			    fn->local_label < MPLS_LABEL_RESERVED_MAX) {
				/* explicit withdraw of the previous label */
				lde_send_labelwithdraw_all(fn, NO_LABEL);
				fn->local_label = egress_label(fn->fec.type);
			}

			if (!connected &&
			    fn->local_label < MPLS_LABEL_RESERVED_MAX) {
				/* explicit withdraw of the previous label */
				lde_send_labelwithdraw_all(fn, NO_LABEL);
				fn->local_label = lde_assign_label();
			}
		}
d388 1
@


1.50
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).

In addition, copy in_addr structs directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.49 2016/05/23 17:43:42 renato Exp $ */
a416 1
	struct lde_addr		*addr;
d449 11
a459 7
			LIST_FOREACH(fnh, &fn->nexthops, entry)
				TAILQ_FOREACH(addr, &ln->addr_list, entry)
					if (fnh->nexthop.s_addr ==
					    addr->addr.s_addr) {
						lde_send_delete_klabel(fn, fnh);
						fnh->remote_label = NO_LABEL;
					}
@


1.49
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d245 1
a245 1
	memcpy(&fn->fec, fec, sizeof(fn->fec));
d278 1
a278 1
	fnh->nexthop.s_addr = nexthop.s_addr;
d497 1
a497 1
	memcpy(&me->map, map, sizeof(*map));
@


1.48
log
@Rework L2VPN code.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.47 2016/05/23 16:52:16 renato Exp $ */
d292 16
d333 1
a333 1
				fn->local_label = MPLS_LABEL_IMPLNULL;
d339 1
a339 1
			    fn->local_label != MPLS_LABEL_IMPLNULL) {
d341 2
a342 3
				RB_FOREACH(ln, nbr_tree, &lde_nbrs)
					lde_send_labelwithdraw(ln, fn);
				fn->local_label = MPLS_LABEL_IMPLNULL;
d346 1
a346 1
			    fn->local_label == MPLS_LABEL_IMPLNULL) {
d348 1
a348 2
				RB_FOREACH(ln, nbr_tree, &lde_nbrs)
					lde_send_labelwithdraw(ln, fn);
a386 1
	struct lde_nbr		*ln;
d403 5
a407 3
	if (LIST_EMPTY(&fn->nexthops))
		RB_FOREACH(ln, nbr_tree, &lde_nbrs)
			lde_send_labelwithdraw(ln, fn);
@


1.47
log
@Fix bug in the processing of label withdraws and releases.

The F_MAP_PW_ID flag is only set for PW-ID mappings, which means that we
were ignoring all label withdraws and label releases for non PW-ID FECs.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.46 2016/05/23 16:43:57 renato Exp $ */
d95 2
a96 2
		if (ntohl(a->u.pwid.nexthop.s_addr) <
		    ntohl(b->u.pwid.nexthop.s_addr))
d98 2
a99 2
		if (ntohl(a->u.pwid.nexthop.s_addr) >
		    ntohl(b->u.pwid.nexthop.s_addr))
d311 3
a344 1
	fnh->data = data;
d346 13
a358 1
	ln = lde_find_address(fnh->nexthop);
d450 5
a454 2
		if (lde_address_find(ln, &fnh->nexthop) == NULL)
			continue;
d456 1
a456 6
		msgsource = 1;

		/* LMp.15: install FEC in FIB */
		fnh->remote_label = map->label;
		switch (map->type) {
		case MAP_TYPE_PREFIX:
d459 5
a463 2
		case MAP_TYPE_PWID:
			pw = (struct l2vpn_pw *) fnh->data;
d469 1
d473 2
d476 2
d516 5
a520 1
		if (lde_address_find(ln, &fnh->nexthop)) {
d524 2
d623 5
a627 4
	struct fec	 fec;
	struct fec_node	*fn;
	struct fec_nh	*fnh;
	struct lde_map	*me;
d640 12
a651 3
		if (lde_address_find(ln, &fnh->nexthop)) {
			lde_send_delete_klabel(fn, fnh);
			fnh->remote_label = NO_LABEL;
d653 2
d683 11
a693 3
			if (lde_address_find(ln, &fnh->nexthop)) {
				lde_send_delete_klabel(fn, fnh);
				fnh->remote_label = NO_LABEL;
d695 2
@


1.46
log
@Make send_labelmessage() more robust.

Immediately return from this function if the given list of mappings
is empty. This way we have more freedom when sending label messages,
not having to care with corner cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.45 2016/05/23 16:29:22 renato Exp $ */
d533 1
a533 1
	if (!(map->flags & F_MAP_PW_ID))
d603 1
a603 1
	if (!(map->flags & F_MAP_PW_ID))
@


1.45
log
@Fix byte order issues with notification messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.44 2016/05/23 16:25:11 renato Exp $ */
a199 1
	int		 count = 0;
a206 1
		count++;
d208 2
a209 3
	if (count > 0)
		lde_imsg_compose_ldpe(IMSG_MAPPING_ADD_END,
		    ln->peerid, 0, NULL, 0);
@


1.44
log
@Remove unnecessary break statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.43 2016/05/23 16:14:36 renato Exp $ */
d493 1
a493 1
		    MSG_TYPE_LABELREQUEST);
d501 1
a501 1
			    map->messageid, MSG_TYPE_LABELREQUEST);
@


1.43
log
@More renaming.

Rename a few more things to improve readability.

* s/F_PW_CONTROLWORD_CONF/F_PW_CWORD_CONF/ (shorter)
* s/F_PW_CONTROLWORD/F_PW_CWORD/ (shorter)
* s/LDPD_FLAG_*/F_LDPD_*/ (consistency)
* s/lde_nbr_address/lde_addr/ (shorter)
* s/ldp_discovery_socket/ldp_disc_socket/ (shorter)
* s/ldp_ediscovery_socket/ldp_edisc_socket/ (shorter)
* s/ldp_sendboth/main_imsg_compose_both/ (consistency)
* s/cons/total/ (makes more sense)
* s/kaddr/ka/ (consistency with remaining code)
* Always use 'ln' for lde_nbrs (consistency)
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.42 2016/05/23 16:12:28 renato Exp $ */
a85 1
		break;
a101 1
		break;
@


1.42
log
@Rename a few constants to avoid confusion.

In ldpd we have the map structure, which is used to represent a label message,
and the fec structure, used to store FECs in the LIB.

As of now, ldpd supports two type of FECs:
* IPv4 prefix (FEC_TYPE_IPV4);
* PWID (FEC_TYPE_PWID).

For the label messages, the following contants were being used:
* FEC_WILDCARD;
* FEC_PREFIX (IPv4 or IPv6);
* FEC_PWID.

Since these contants have similar names to the previous ones, rename
them to:
* MAP_TYPE_WILDCARD;
* MAP_TYPE_PREFIX;
* MAP_TYPE_PWID.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.41 2016/05/23 15:14:07 renato Exp $ */
d393 1
a393 1
	struct lde_nbr_address	*addr;
@


1.41
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.40 2015/07/21 04:52:29 renato Exp $ */
d410 1
a410 1
	if (map->type == FEC_PWID && l2vpn_pw_negotiate(ln, fn, map))
d449 1
a449 1
		case FEC_PREFIX:
d452 1
a452 1
		case FEC_PWID:
@


1.40
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.39 2015/07/21 04:48:42 renato Exp $ */
d127 1
a127 1
		log_warnx("fec_remove failed for %s", log_fec(f));
d226 1
a226 1
		log_warnx("fec_free: fec %s downstream list not empty",
d229 1
a229 1
		log_warnx("fec_free: fec %s upstream list not empty",
d248 1
a248 1
		fatal("fec_add");
d281 1
a281 1
		fatal("fec_nh_add");
@


1.39
log
@Record all fields of the received label mappings.

Since we implement the Liberal Label Retention mode, we need to record
all fields of the received label mappings so the messages can be processed
later when there is a matching nexthop for the advertised FECs.

This will be important when we implement VPLS because we need to retain
information like the pseudowire's interface MTU and Group ID.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.38 2015/07/21 04:46:51 renato Exp $ */
d44 1
a44 2
struct fec_node	*fec_add(struct in_addr, u_int8_t);
struct fec_nh	*fec_nh_find(struct fec_node *, struct in_addr);
d68 1
a68 1
	if (ntohl(a->prefix.s_addr) < ntohl(b->prefix.s_addr))
d70 1
a70 5
	if (ntohl(a->prefix.s_addr) > ntohl(b->prefix.s_addr))
		return (1);
	if (a->prefixlen < b->prefixlen)
		return (-1);
	if (a->prefixlen > b->prefixlen)
d73 32
a104 7
	return (0);
}

struct fec *
fec_find_prefix(struct fec_tree *fh, in_addr_t prefix, u_int8_t prefixlen)
{
	struct fec	 s;
d106 1
a106 4
	s.prefix.s_addr = prefix;
	s.prefixlen = prefixlen;

	return (fec_find(fh, &s));
d127 1
a127 2
		log_warnx("fec_remove failed for %s/%u",
		    inet_ntoa(f->prefix), f->prefixlen);
d167 3
d174 2
a175 3
		rtctl.prefix = fn->fec.prefix;
		rtctl.prefixlen = fn->fec.prefixlen;
		rtctl.flags = fn->flags;
d209 1
a209 1
		lde_send_labelmapping(ln, fn);
d226 2
a227 2
		log_warnx("fec_free: fec %s/%u downstream list not empty",
		    inet_ntoa(fn->fec.prefix), fn->fec.prefixlen);
d229 2
a230 2
		log_warnx("fec_free: fec %s/%u upstream list not empty",
		    inet_ntoa(fn->fec.prefix), fn->fec.prefixlen);
d242 1
a242 1
fec_add(struct in_addr prefix, u_int8_t prefixlen)
d250 1
a250 2
	fn->fec.prefix.s_addr = prefix.s_addr;
	fn->fec.prefixlen = prefixlen;
d257 2
a258 2
		log_warnx("failed to add %s/%u to ft tree",
		    inet_ntoa(fn->fec.prefix), fn->fec.prefixlen);
d298 2
a299 1
lde_kernel_insert(struct kroute *kr)
a304 1
	char			 buf[16];
d306 2
a307 3
	log_debug("kernel add route %s/%u nexthop %s",
	    inet_ntoa(kr->prefix), kr->prefixlen,
	    inet_ntop(AF_INET, &kr->nexthop, buf, sizeof(buf)));
d309 1
a309 2
	fn = (struct fec_node *)fec_find_prefix(&ft, kr->prefix.s_addr,
	    kr->prefixlen);
d311 1
a311 1
		fn = fec_add(kr->prefix, kr->prefixlen);
d313 1
a313 1
	if (fec_nh_find(fn, kr->nexthop) != NULL)
d318 1
a318 1
			if (kr->flags & F_CONNECTED)
d324 1
a324 1
			if ((kr->flags & F_CONNECTED) &&
d332 1
a332 1
			if (!(kr->flags & F_CONNECTED) &&
d342 2
a343 5
		RB_FOREACH(ln, nbr_tree, &lde_nbrs) {
			lde_send_labelmapping(ln, fn);
			lde_imsg_compose_ldpe(IMSG_MAPPING_ADD_END,
			    ln->peerid, 0, NULL, 0);
		}
d346 2
a347 1
	fnh = fec_nh_add(fn, kr->nexthop);
a348 1

d360 1
a360 1
lde_kernel_remove(struct kroute *kr)
a364 1
	char			 buf[16];
d366 2
a367 3
	log_debug("kernel remove route %s/%u nexthop %s",
	    inet_ntoa(kr->prefix), kr->prefixlen,
	    inet_ntop(AF_INET, &kr->nexthop, buf, sizeof(buf)));
d369 1
a369 2
	fn = (struct fec_node *)fec_find_prefix(&ft, kr->prefix.s_addr,
	    kr->prefixlen);
d374 1
a374 1
	fnh = fec_nh_find(fn, kr->nexthop);
d379 1
d389 1
d395 1
d398 2
a399 2
	fn = (struct fec_node *)fec_find_prefix(&ft, map->prefix.s_addr,
	    map->prefixlen);
d401 1
a401 1
		fn = fec_add(map->prefix, map->prefixlen);
d409 4
d441 4
a444 2
		if (lde_address_find(ln, &fnh->nexthop)) {
			msgsource = 1;
d446 4
a449 2
			/* LMp.15: install FEC in FIB */
			fnh->remote_label = map->label;
d451 11
d464 1
a464 9
	if (msgsource == 0) {
		/* LMp.13: perform lsr label release procedure */
		if (me == NULL)
			me = lde_map_add(ln, fn, 0);
		memcpy(&me->map, map, sizeof(*map));
		return;
	}

	/* LMp.16: Record the mapping from this peer */
d469 4
d483 1
d491 2
a492 2
	fn = (struct fec_node *)fec_find_prefix(&ft, map->prefix.s_addr,
	    map->prefixlen);
d520 1
a520 2
	lde_send_labelmapping(ln, fn);
	lde_imsg_compose_ldpe(IMSG_MAPPING_ADD_END, ln->peerid, 0, NULL, 0);
d532 1
d537 6
a542 2
	fn = (struct fec_node *)fec_find_prefix(&ft, map->prefix.s_addr,
	    map->prefixlen);
d602 1
d607 6
a612 2
	fn = (struct fec_node *)fec_find_prefix(&ft, map->prefix.s_addr,
	    map->prefixlen);
d614 1
a614 1
		fn = fec_add(map->prefix, map->prefixlen);
@


1.38
log
@Rename structures and functions to be more generic.

LDP work with FECs, where a FEC can be a prefix, a pseudowire and so on.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.37 2015/07/19 20:54:16 renato Exp $ */
d163 1
a163 1
			rtctl.remote_label = me->label;
d341 1
a341 8
		if (me) {
			struct map	map;

			bzero(&map, sizeof(map));
			map.prefix.s_addr = me->fec.prefix.s_addr;
			map.prefixlen = me->fec.prefixlen;
			map.label = me->label;

d343 1
a343 2
			lde_check_mapping(&map, ln);
		}
d406 1
a406 1
		if (me->label != map->label && lre == NULL) {
d408 1
a408 1
			lde_send_labelrelease(ln, fn, me->label);
d437 1
a437 1
		me->label = map->label;
d444 1
a444 1
	me->label = map->label;
d525 1
a525 1
	if (me && (map->label == NO_LABEL || map->label == me->label))
d556 1
a556 1
		    (map->label == NO_LABEL || map->label == me->label)) {
d592 1
a592 1
	if (me && (map->label == NO_LABEL || map->label == me->label))
d621 2
a622 1
		if (me && (map->label == NO_LABEL || map->label == me->label))
@


1.37
log
@Rework label mapping algorithms to be more in line with the RFC.

This patch presents a thoroughly review of the label mapping
algorithms. Most of the changes are minor bug fixes in the handling of
received label messages.

Additional improvements:
* Add a few more references to the Appendix A of the RFC5036 ("LDP
  Label Distribution Procedures") into the code;
* Add full multipath support;
* Send label withdraws when appropriate;
* Add label withdraw/release wildcard support.

NOTE: As a result of implementing only the "Liberal Label Retention" and
"Downstream Unsolicited" modes, we will never send a label request
("Request  Never"). And that means that we can ignore the following
notification messages: "Label Request Aborted", "No Label Resources",
"No Route" and "Label Resources Available". The following algorithms
mentioned in the RFC can also be ignored: "Timeout of Deferred Label
Request", "Detect Local Label Resources Have Become Available" and
"Receive Label Abort Request".

Now, considering that we only support one combination of all modes of
operation, we can say that we have an almost complete implementation of
the protocol.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.36 2015/07/19 20:50:03 renato Exp $ */
d43 6
a48 6
void		 rt_free(void *);
struct rt_node	*rt_add(struct in_addr, u_int8_t);
struct rt_lsp	*rt_lsp_find(struct rt_node *, struct in_addr);
struct rt_lsp	*rt_lsp_add(struct rt_node *, struct in_addr);
void		 rt_lsp_del(struct rt_lsp *);
int		 lde_nbr_is_nexthop(struct rt_node *, struct lde_nbr *);
d57 1
a57 1
struct fec_tree	rt = RB_INITIALIZER(&rt);
d130 1
a130 1
lde_nbr_is_nexthop(struct rt_node *rn, struct lde_nbr *ln)
d132 1
a132 1
	struct rt_lsp		*rl;
d134 2
a135 2
	LIST_FOREACH(rl, &rn->lsp, entry)
		if (lde_address_find(ln, &rl->nexthop))
d145 1
a145 1
	struct rt_node		*rr;
d149 4
a152 4
	RB_FOREACH(f, fec_tree, &rt) {
		rr = (struct rt_node *)f;
		if (rr->local_label == NO_LABEL &&
		    LIST_EMPTY(&rr->downstream))
d155 4
a158 4
		rtctl.prefix = rr->fec.prefix;
		rtctl.prefixlen = rr->fec.prefixlen;
		rtctl.flags = rr->flags;
		rtctl.local_label = rr->local_label;
d160 2
a161 2
		LIST_FOREACH(me, &rr->downstream, entry) {
			rtctl.in_use = lde_nbr_is_nexthop(rr, me->nexthop);
d168 1
a168 1
		if (LIST_EMPTY(&rr->downstream)) {
d180 1
a180 1
rt_snap(struct lde_nbr *ln)
d183 1
a183 1
	struct rt_node	*rn;
d186 3
a188 3
	RB_FOREACH(f, fec_tree, &rt) {
		rn = (struct rt_node *)f;
		if (rn->local_label == NO_LABEL)
d191 1
a191 1
		lde_send_labelmapping(ln, rn);
d200 1
a200 1
rt_free(void *arg)
d202 2
a203 2
	struct rt_node	*rr = arg;
	struct rt_lsp	*rl;
d205 8
a212 8
	while ((rl = LIST_FIRST(&rr->lsp)))
		rt_lsp_del(rl);
	if (!LIST_EMPTY(&rr->downstream))
		log_warnx("rt_free: fec %s/%u downstream list not empty",
		    inet_ntoa(rr->fec.prefix), rr->fec.prefixlen);
	if (!LIST_EMPTY(&rr->upstream))
		log_warnx("rt_free: fec %s/%u upstream list not empty",
		    inet_ntoa(rr->fec.prefix), rr->fec.prefixlen);
d214 1
a214 1
	free(rr);
d218 1
a218 1
rt_clear(void)
d220 1
a220 1
	fec_clear(&rt, rt_free);
d223 2
a224 2
struct rt_node *
rt_add(struct in_addr prefix, u_int8_t prefixlen)
d226 1
a226 1
	struct rt_node	*rn;
d228 3
a230 3
	rn = calloc(1, sizeof(*rn));
	if (rn == NULL)
		fatal("rt_add");
d232 6
a237 6
	rn->fec.prefix.s_addr = prefix.s_addr;
	rn->fec.prefixlen = prefixlen;
	rn->local_label = NO_LABEL;
	LIST_INIT(&rn->upstream);
	LIST_INIT(&rn->downstream);
	LIST_INIT(&rn->lsp);
d239 3
a241 3
	if (fec_insert(&rt, &rn->fec))
		log_warnx("failed to add %s/%u to rt tree",
		    inet_ntoa(rn->fec.prefix), rn->fec.prefixlen);
d243 1
a243 1
	return (rn);
d246 2
a247 2
struct rt_lsp *
rt_lsp_find(struct rt_node *rn, struct in_addr nexthop)
d249 1
a249 1
	struct rt_lsp	*rl;
d251 3
a253 3
	LIST_FOREACH(rl, &rn->lsp, entry)
		if (rl->nexthop.s_addr == nexthop.s_addr)
			return (rl);
d257 2
a258 2
struct rt_lsp *
rt_lsp_add(struct rt_node *rn, struct in_addr nexthop)
d260 1
a260 1
	struct rt_lsp	*rl;
d262 3
a264 3
	rl = calloc(1, sizeof(*rl));
	if (rl == NULL)
		fatal("rt_lsp_add");
d266 3
a268 3
	rl->nexthop.s_addr = nexthop.s_addr;
	rl->remote_label = NO_LABEL;
	LIST_INSERT_HEAD(&rn->lsp, rl, entry);
d270 1
a270 1
	return (rl);
d274 1
a274 1
rt_lsp_del(struct rt_lsp *rl)
d276 2
a277 2
	LIST_REMOVE(rl, entry);
	free(rl);
d283 2
a284 2
	struct rt_node		*rn;
	struct rt_lsp		*rl;
d293 1
a293 1
	rn = (struct rt_node *)fec_find_prefix(&rt, kr->prefix.s_addr,
d295 2
a296 2
	if (rn == NULL)
		rn = rt_add(kr->prefix, kr->prefixlen);
d298 1
a298 1
	if (rt_lsp_find(rn, kr->nexthop) != NULL)
d301 2
a302 2
	if (LIST_EMPTY(&rn->lsp)) {
		if (rn->local_label == NO_LABEL) {
d304 1
a304 1
				rn->local_label = MPLS_LABEL_IMPLNULL;
d306 1
a306 1
				rn->local_label = lde_assign_label();
d310 1
a310 1
			    rn->local_label != MPLS_LABEL_IMPLNULL) {
d313 2
a314 2
					lde_send_labelwithdraw(ln, rn);
				rn->local_label = MPLS_LABEL_IMPLNULL;
d318 1
a318 1
			    rn->local_label == MPLS_LABEL_IMPLNULL) {
d321 2
a322 2
					lde_send_labelwithdraw(ln, rn);
				rn->local_label = lde_assign_label();
d328 1
a328 1
			lde_send_labelmapping(ln, rn);
d334 2
a335 2
	rl = rt_lsp_add(rn, kr->nexthop);
	lde_send_change_klabel(rn, rl);
d337 1
a337 1
	ln = lde_find_address(rl->nexthop);
d340 1
a340 1
		me = (struct lde_map *)fec_find(&ln->recv_map, &rn->fec);
d358 2
a359 2
	struct rt_node		*rn;
	struct rt_lsp		*rl;
d367 1
a367 1
	rn = (struct rt_node *)fec_find_prefix(&rt, kr->prefix.s_addr,
d369 1
a369 1
	if (rn == NULL)
d373 2
a374 2
	rl = rt_lsp_find(rn, kr->nexthop);
	if (rl == NULL)
d378 2
a379 2
	rt_lsp_del(rl);
	if (LIST_EMPTY(&rn->lsp))
d381 1
a381 1
			lde_send_labelwithdraw(ln, rn);
d387 2
a388 2
	struct rt_node		*rn;
	struct rt_lsp		*rl;
d394 1
a394 1
	rn = (struct rt_node *)fec_find_prefix(&rt, map->prefix.s_addr,
d396 2
a397 2
	if (rn == NULL)
		rn = rt_add(map->prefix, map->prefixlen);
d400 1
a400 1
	lre = (struct lde_req *)fec_find(&ln->sent_req, &rn->fec);
d411 1
a411 1
	me = (struct lde_map *)fec_find(&ln->recv_map, &rn->fec);
d416 1
a416 1
			lde_send_labelrelease(ln, rn, me->label);
d418 1
a418 1
			LIST_FOREACH(rl, &rn->lsp, entry)
d420 1
a420 1
					if (rl->nexthop.s_addr ==
d422 2
a423 2
						lde_send_delete_klabel(rn, rl);
						rl->remote_label = NO_LABEL;
d432 2
a433 2
	LIST_FOREACH(rl, &rn->lsp, entry) {
		if (lde_address_find(ln, &rl->nexthop)) {
d437 2
a438 2
			rl->remote_label = map->label;
			lde_send_change_klabel(rn, rl);
d444 1
a444 1
			me = lde_map_add(ln, rn, 0);
d451 1
a451 1
		me = lde_map_add(ln, rn, 0);
a453 1

d465 2
a466 2
	struct rt_node	*rn;
	struct rt_lsp	*rl;
d471 1
a471 1
	rn = (struct rt_node *)fec_find_prefix(&rt, map->prefix.s_addr,
d473 1
a473 1
	if (rn == NULL || LIST_EMPTY(&rn->lsp)) {
d480 2
a481 2
	LIST_FOREACH(rl, &rn->lsp, entry) {
		if (lde_address_find(ln, &rl->nexthop)) {
d489 1
a489 1
	lre = (struct lde_req *)fec_find(&ln->recv_req, &rn->fec);
d495 1
a495 1
	lre = lde_req_add(ln, &rn->fec, 0);
d500 1
a500 1
	lde_send_labelmapping(ln, rn);
d513 1
a513 1
	struct rt_node		*rn;
d517 1
a517 1
	rn = (struct rt_node *)fec_find_prefix(&rt, map->prefix.s_addr,
d520 1
a520 1
	if (rn == NULL)
d524 1
a524 1
	lw = (struct lde_wdraw *)fec_find(&ln->sent_wdraw, &rn->fec);
d532 1
a532 1
	me = (struct lde_map *)fec_find(&ln->sent_map, &rn->fec);
d546 1
a546 1
	struct rt_node		*rn;
d550 2
a551 2
	RB_FOREACH(f, fec_tree, &rt) {
		rn = (struct rt_node *)f;
d554 1
a554 1
		lw = (struct lde_wdraw *)fec_find(&ln->sent_wdraw, &rn->fec);
d562 1
a562 1
		me = (struct lde_map *)fec_find(&ln->sent_map, &rn->fec);
d578 2
a579 2
	struct rt_node	*rn;
	struct rt_lsp	*rl;
d582 1
a582 1
	rn = (struct rt_node *)fec_find_prefix(&rt, map->prefix.s_addr,
d584 2
a585 2
	if (rn == NULL)
		rn = rt_add(map->prefix, map->prefixlen);
d588 4
a591 4
	LIST_FOREACH(rl, &rn->lsp, entry) {
		if (lde_address_find(ln, &rl->nexthop)) {
			lde_send_delete_klabel(rn, rl);
			rl->remote_label = NO_LABEL;
d596 1
a596 1
	lde_send_labelrelease(ln, rn, map->label);
d599 1
a599 1
	me = (struct lde_map *)fec_find(&ln->recv_map, &rn->fec);
d609 2
a610 2
	struct rt_node	*rn;
	struct rt_lsp	*rl;
d616 2
a617 2
	RB_FOREACH(f, fec_tree, &rt) {
		rn = (struct rt_node *)f;
d620 4
a623 4
		LIST_FOREACH(rl, &rn->lsp, entry) {
			if (lde_address_find(ln, &rl->nexthop)) {
				lde_send_delete_klabel(rn, rl);
				rl->remote_label = NO_LABEL;
d628 1
a628 1
		me = (struct lde_map *)fec_find(&ln->recv_map, &rn->fec);
@


1.36
log
@Remove incomplete support for unnecessary modes of  operation.

LDP has several modes of operation, it was designed in that way so it
could run on legacy equipment like ATM/FR switches with very strict
memory limitations.

For modern hardware there's no point on using either the "Conservative
Label Retention" or "Downstream On Demand" modes of operation since they
save memory at cost of blackholing traffic when routing changes. Major
vendors implement only the "Liberal Label Retention" and "Downstream
Unsolicited" modes for non ATM/FR hardware. Let's do that too.

As for using either "Independent Control" or "Ordered Control", let's
stick with the first option mainly because it's easier to implement
and because it doesn't really matter which control mode is used. For
reference, Cisco implements only "Independent Control" and Juniper only
"Ordered Control". Both modes are interoperable.

The point of supporting only one combination of all modes of operation
is that it will allow for the writing of a simpler code without removing
useful functionality.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.35 2015/07/19 18:34:32 renato Exp $ */
d52 3
d151 4
d183 2
a184 3
	struct rt_node	*r;
	struct lde_map	*me;
	struct map	 map;
a185 1
	bzero(&map, sizeof(map));
d187 3
a189 4
		r = (struct rt_node *)f;
		map.prefix = r->fec.prefix;
		map.prefixlen = r->fec.prefixlen;
		map.label = r->local_label;
d191 2
a192 5
		me = lde_map_add(ln, r, 1);
		me->label = r->local_label;

		lde_imsg_compose_ldpe(IMSG_MAPPING_ADD, ln->peerid, 0, &map,
		    sizeof(map));
d194 3
d205 2
a206 5
	while ((rl = LIST_FIRST(&rr->lsp))) {
		LIST_REMOVE(rl, entry);
		free(rl);
	}

d214 1
a214 1
	free(rl);
d285 3
a287 2
	struct lde_nbr_address	*addr;
	struct lde_map		*map;
d289 3
a291 2
	log_debug("kernel add route %s/%u", inet_ntoa(kr->prefix),
	    kr->prefixlen);
d298 1
a298 7
	rl = rt_lsp_find(rn, kr->nexthop);
	if (rl == NULL)
		rl = rt_lsp_add(rn, kr->nexthop);

	/* There is static assigned label for this route, record it in lib */
	if (kr->local_label != NO_LABEL) {
		rn->local_label = kr->local_label;
a299 1
	}
d301 24
a324 7
	if (rn->local_label == NO_LABEL) {
		if (kr->flags & F_CONNECTED)
			/* Directly connected route */
			rn->local_label = MPLS_LABEL_IMPLNULL;
		else
			rn->local_label = lde_assign_label();
	}
d326 5
a330 5
	LIST_FOREACH(map, &rn->downstream, entry) {
		addr = lde_address_find(map->nexthop, &rl->nexthop);
		if (addr != NULL) {
			rl->remote_label = map->label;
			break;
d334 1
d337 16
a352 2
	/* Redistribute the current mapping to every nbr */
	lde_nbr_do_mappings(rn);
d360 2
d363 3
a365 2
	log_debug("kernel remove route %s/%u", inet_ntoa(kr->prefix),
	    kr->prefixlen);
d374 3
a376 4
	if (rl != NULL)
		rt_lsp_del(rl);

	/* XXX handling of total loss of route, withdraw mappings, etc */
d378 4
a381 2
	/* Redistribute the current mapping to every nbr */
	lde_nbr_do_mappings(rn);
d390 1
a390 1
	struct lde_nbr_address	*addr = NULL;
d392 1
a392 3

	log_debug("label mapping from nbr %s, FEC %s, label %u",
	    inet_ntoa(ln->id), log_fec(map), map->label);
d396 1
a396 1
	if (rn == NULL) {
a397 2
		rn->local_label = lde_assign_label();
	}
d399 1
a399 1
	/* first check if we have a pending request running */
d402 1
d405 4
a408 1
	/* TODO Loop detection LMp.3 - LMp.8 */
d410 6
a415 16
	LIST_FOREACH(me, &rn->downstream, entry) {
		if (ln != me->nexthop)				/* LMp.9 */
			continue;
		if (lre)
			/* LMp.10 Note 6: req. mappings are always new */
			break;
		if (me->label != map->label) {			/* LMp.10 */
			/*
			 * This is, according to the RFC, a try to install a
			 * multipath LSP which is not supported by the RFC.
			 * So instead release the old label and install the
			 * new one.
			 */
			log_debug("possible multipath FEC %s, "
			    "label %u, old label %u",
			    log_fec(map), map->label, me->label);
d417 8
a425 2
		/* there can only be one mapping */
		break;
d428 4
a431 1
	/* LMp.11: get nexthop */
d433 7
a439 3
		addr = lde_address_find(ln, &rl->nexthop);
		if (addr)
			break;
d441 2
a442 2
	if (addr == NULL) {
		/* in liberal mode just note the mapping */
a445 1

d449 1
a449 7
	/* LMp.14 do we actually need this FEC for now this is always true */
	rl->remote_label = map->label;

	/* LMp.15 install FEC in FIB */
	lde_send_change_klabel(rn, rl);

	/* Record the mapping from this peer LMp.16 */
d454 6
a459 2
	/* Redistribute the current mapping to every nbr LMp.17-31 */
	lde_nbr_do_mappings(rn);
a467 1
	struct lde_nbr	*lnn;
d469 1
a469 2
	log_debug("label request from nbr %s, FEC %s",
	    inet_ntoa(ln->id), log_fec(map));
d471 1
d474 1
a474 1
	if (rn == NULL) {
d480 1
a486 3

		if (rl->remote_label != NO_LABEL)
			break;
d489 1
a489 1
	/* first check if we have a pending request running */
d492 1
d494 2
a495 1
	/* else record label request */
d500 9
a508 15
	/* there is a valid mapping available */
	if (rl != NULL) {
		/* TODO loop protection handling (LRq.9) */
		lde_send_labelmapping(ln, rn);
		return;
	}

	/* no mapping available, try to request */
	/* XXX depending on the request behaviour we could return here */
	LIST_FOREACH(rl, &rn->lsp, entry) {
		lnn = lde_find_address(rl->nexthop);
		if (lnn == NULL)
			continue;
		lde_send_labelrequest(lnn, rn);
	}
d514 3
a516 6
	struct rt_node	*rn;
	struct lde_req	*lre;
	struct lde_map	*me;

	log_debug("label release from nbr %s, FEC %s",
	    inet_ntoa(ln->id), log_fec(map));
d520 1
d524 6
a529 5
	/* first check if we have a pending withdraw running */
	lre = (struct lde_req *)fec_find(&ln->sent_wdraw, &rn->fec);
	if (lre) {
		fec_remove(&ln->sent_wdraw, &lre->fec);
		free(lre);
d532 1
a532 1
	/* check sent map list and remove it if available */
d534 1
a534 1
	if (me)
d537 31
a567 4
	/* remove FEC if not in use anymore */
	/* XXX what about outstanding label requests? */
	if (!LIST_EMPTY(&rn->upstream))
		return;
d569 5
a573 3
	/* XXX if originated here free all resources */
	/* else decide if a label release should be forwarded. */
	/* Since we do liberal retention we can keep the path mapped. */
a582 3
	log_debug("label withdraw from nbr %s, FEC %s",
	    inet_ntoa(ln->id), log_fec(map));

a584 3

	lde_send_labelrelease(ln, rn, map->label);

d586 1
a586 2
		/* LSP not available, nothing to do */
		return;
d588 1
a588 1
	/* remove LSP from kernel */
d590 4
a593 6
		if (lde_address_find(ln, &rl->nexthop))
			break;
	}
	if (rl) {
		rl->remote_label = NO_LABEL;
		lde_send_delete_klabel(rn, rl);
d596 4
a599 1
	/* check recv map list and remove it if available */
d601 2
a602 1
	if (me)
d604 9
d614 2
a615 3
	/* if ordered distribution */
	/* walk over upstream list and send withdraws for LSP that depend on
	 * the removed LSP */
d617 20
a636 2
	/* if independent distribution and adv on demand */
	/* Generate Event: Recognize New FEC for FEC. */
@


1.35
log
@Uninstall associated label bindings when a neighbor is down.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.34 2015/07/19 18:27:59 renato Exp $ */
a366 5
		/* The route is not yet in fib. If we are in liberal mode
		 *  create a route and record the label */
		if (ldeconf->mode & MODE_RET_CONSERVATIVE)
			return;

a406 7
		/* route not yet available LMp.13 */
		if (ldeconf->mode & MODE_RET_CONSERVATIVE) {
			log_debug("FEC %s: conservative ret but no route",
			    log_fec(map));
			lde_send_labelrelease(ln, rn, map->label);
			return;
		}
@


1.34
log
@Rework kroute.c to send only the best routes to lde.

This is major rework of the kroute.c code. The idea is remove complexity
from the lde process by making kroute.c advertise only the lowest priority
routes of each prefix.

kroute.c now keeps track of all routes using three different structures:
kroute_prefix, kroute_priority and kroute_node.

kroute_prefix represents a prefix and contains an ordered list of
priorities (kroute_priority) and for each priority there is a list of
nexthops (kroute_node). Arranging the routes using these three structures
allows for the writing of a simpler code, easier to understand.

Whenever a route is removed, if there's another route for the same prefix,
but with a lower priority, this route is immediately sent to lde.

Additional fixes:
* On RTM_CHANGE, remove the old route before installing the new one;
* On IMSG_CTL_KROUTE_ADDR, show all nexthops for multpath routes;
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.33 2015/06/10 20:50:05 miod Exp $ */
a49 1
RB_PROTOTYPE(fec_tree, fec, entry, fec_compare)
@


1.33
log
@Typos: equalivant, fucntion, libary.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.32 2015/04/04 15:15:44 renato Exp $ */
d45 2
a46 2
struct rt_lsp	*rt_lsp_find(struct rt_node *, struct in_addr, u_int8_t);
struct rt_lsp	*rt_lsp_add(struct rt_node *, struct in_addr, u_int8_t);
d247 1
a247 1
rt_lsp_find(struct rt_node *rn, struct in_addr nexthop, u_int8_t prio)
d252 1
a252 2
		if (rl->nexthop.s_addr == nexthop.s_addr &&
		    rl->priority == prio)
d258 1
a258 1
rt_lsp_add(struct rt_node *rn, struct in_addr nexthop, u_int8_t prio)
d260 1
a260 1
	struct rt_lsp	*rl, *nrl;
d268 1
a268 1
	rl->priority = prio;
a269 16
	/* keep LSP list sorted by priority because only the best routes
	 * can be used in a LSP. */
	if (LIST_EMPTY(&rn->lsp))
		LIST_INSERT_HEAD(&rn->lsp, rl, entry);
	else {
		LIST_FOREACH(nrl, &rn->lsp, entry) {
			if (prio < nrl->priority) {
				LIST_INSERT_BEFORE(nrl, rl, entry);
				break;
			}
			if (LIST_NEXT(nrl, entry) == NULL) {
				LIST_INSERT_AFTER(nrl, rl, entry);
				break;
			}
		}
	}
d296 1
a296 1
	rl = rt_lsp_find(rn, kr->nexthop, kr->priority);
d298 1
a298 1
		rl = rt_lsp_add(rn, kr->nexthop, kr->priority);
d343 1
a343 1
	rl = rt_lsp_find(rn, kr->nexthop, kr->priority);
a449 1
	u_int8_t	 prio = 0;
a462 5
		/* only consider pathes with highest priority */
		if (prio == 0)
			prio = rl->priority;
		if (prio < rl->priority)
			break;
a491 5
		/* only consider pathes with highest priority */
		if (prio == 0)
			prio = rl->priority;
		if (prio < rl->priority)
			break;
@


1.32
log
@Show the full LIB in the "ldpctl show lib" command.

The LIB is a table where the router keeps all known MPLS labels. So,
we should loop over all the received label mappings from all neighbors
to show the full LIB.

The lde_nbr_is_nexthop() function was introduced to verify if a lib
entry is supposed to be installed in the fib (according to the fib entry's
nexthop and the addresses advertised by the lib entry's nexthop). This is
better than keeping track of lib<->fib entries with pointers and back
pointers because it keeps the lib/fib structures independent of each
other, which in turn makes the code less prone to bugs.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.31 2013/10/15 20:21:25 renato Exp $ */
d57 1
a57 1
/* FEC tree fucntions */
@


1.31
log
@Fix whitespace and other style issues.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.30 2013/06/03 16:56:47 claudio Exp $ */
d48 1
d127 12
a143 1
	struct rt_lsp		*rl;
d154 4
a157 9
		LIST_FOREACH(rl, &rr->lsp, entry) {
			rtctl.nexthop = rl->nexthop;
			rtctl.remote_label = rl->remote_label;
			rtctl.in_use = 1;

			if (rtctl.nexthop.s_addr == htonl(INADDR_ANY))
				rtctl.connected = 1;
			else
				rtctl.connected = 0;
d162 7
a168 11
		if (LIST_EMPTY(&rr->lsp)) {
			LIST_FOREACH(me, &rr->downstream, entry) {
				rtctl.in_use = 0;
				rtctl.connected = 0;
				/* we don't know the nexthop use id instead */
				rtctl.nexthop = me->nexthop->id;
				rtctl.remote_label = me->label;

				lde_imsg_compose_ldpe(IMSG_CTL_SHOW_LIB, 0, pid,
				    &rtctl, sizeof(rtctl));
			}
@


1.30
log
@Advertise the implicit-null label for routes attached to loopback
interfaces to guarantee PHP. With this 'fib-update no' is not totaly
broken because of missing mappings for the loopbacks.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.29 2010/11/04 09:49:07 claudio Exp $ */
a94 1

a124 1

d448 1
a448 1
	/* Record the mapping from this peer LMp.16 */	
d598 1
a598 1
	
@


1.29
log
@Only consider pathes with highest priority when replying to label
requests. Else a priority inversion may happen that would build
label switching pathes that use inactive routes.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.28 2010/10/26 12:08:14 claudio Exp $ */
d323 1
a323 1
		if (kr->nexthop.s_addr == INADDR_ANY)
@


1.28
log
@Change lde_check_request(), lde_check_mapping(), lde_send_labelmapping(),
lde_send_labelrequest(), and lde_nbr_do_mappings() to follow the
algorithms defined in Appendix A of RFC 5036. Added comments and
markers for better understanding and to find missing bits.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.27 2010/10/21 08:24:06 claudio Exp $ */
d45 2
a46 2
struct rt_lsp	*rt_lsp_find(struct rt_node *, struct in_addr);
struct rt_lsp	*rt_lsp_add(struct rt_node *, struct in_addr);
d246 1
a246 1
rt_lsp_find(struct rt_node *rn, struct in_addr nexthop)
d251 2
a252 1
		if (rl->nexthop.s_addr == nexthop.s_addr)
d258 1
a258 1
rt_lsp_add(struct rt_node *rn, struct in_addr nexthop)
d260 1
a260 1
	struct rt_lsp	*rl;
d268 1
a268 1
	LIST_INSERT_HEAD(&rn->lsp, rl, entry);
d270 16
d312 1
a312 1
	rl = rt_lsp_find(rn, kr->nexthop);
d314 1
a314 1
		rl = rt_lsp_add(rn, kr->nexthop);
d359 1
a359 1
	rl = rt_lsp_find(rn, kr->nexthop);
d466 1
d480 5
d514 5
@


1.27
log
@Start implementing the missing lablemapping messages in the LDE and
fix the existing ones to correctly track outstanding request and
sent / recv mappings.
Looks good to michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.26 2010/08/27 12:22:46 claudio Exp $ */
d378 2
a379 4
	if (lre) {
		fec_remove(&ln->sent_req, &lre->fec);
		free(lre);
	}
d384 4
a387 12
		if (ln == me->nexthop) {
			if (me->label == map->label) {
				/* Duplicate: RFC says to send back a release,
				 * even though we did not release the actual
				 * mapping. This is confusing.
				 */
				log_debug("duplicate FEC %s, label %u",
				    log_fec(map), map->label);
				lde_send_labelrelease(ln->peerid, map);
				return;
			}
			/* old mapping that is now changed */
d389 11
d401 2
d405 1
a410 1

d412 1
a412 1
		/* route not yet available */
d416 1
a416 1
			lde_send_labelrelease(ln->peerid, map);
d427 1
d430 4
a433 1
	/* Record the mapping from this peer */	
d438 1
a438 3
	lde_send_change_klabel(rn, rl);

	/* Redistribute the current mapping to every nbr */
a448 2
	struct lde_map	*me;
	struct map	 localmap;
d476 4
a482 8
		bzero(&localmap, sizeof(localmap));
		localmap.prefix = map->prefix;
		localmap.prefixlen = map->prefixlen;
		localmap.label = rn->local_label;

		me = lde_map_add(ln, rn, 1);
		me->label = rn->local_label;

d484 1
a484 1
		lde_send_labelmapping(ln->peerid, &localmap);
a487 15
	/* else record label request */
	lre = calloc(1, sizeof(*lre));
	if (lre == NULL)
		fatal("lde_check_request");

	lre->fec = rn->fec;
	lre->msgid = map->messageid;

	if (fec_insert(&ln->recv_req, &lre->fec)) {
		log_warnx("failed to add %s/%u to recv req",
		    inet_ntoa(lre->fec.prefix), lre->fec.prefixlen);
		free(lre);
	}

	/* XXX  map should not be * reused, especially the messageid */
d494 1
a494 3

		/* TODO record request on the sent_req list of lnn */
		lde_send_labelrequest(lnn->peerid, map);
d548 1
a548 1
	lde_send_labelrelease(ln->peerid, map);
@


1.26
log
@Fix format string that was not changed after the log_fec introduction.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.25 2010/08/26 08:39:43 claudio Exp $ */
d173 1
a173 1
rt_snap(u_int32_t peerid)
d177 1
d187 4
a190 1
		lde_imsg_compose_ldpe(IMSG_MAPPING_ADD, peerid, 0, &map,
d343 2
a344 4
	if (rl == NULL)
		/* nexthop lost */

	rt_lsp_del(rl);
d357 1
d376 9
d392 2
d411 2
d444 1
a457 5
	/* first check if we have a pending request running */
	lre = (struct lde_req *)fec_find(&ln->recv_req, &rn->fec);
	if (lre != NULL)
		return;

d469 5
d481 4
d489 15
d505 1
d511 1
d513 2
d516 20
a535 12
		lre = calloc(1, sizeof(*lre));
		if (lre == NULL)
			fatal("lde_check_request");

		lre->fec = rn->fec;
		lre->msgid = map->messageid;

		if (fec_insert(&ln->recv_req, &lre->fec)) {
			log_warnx("failed to add %s/%u to recv req",
			    inet_ntoa(lre->fec.prefix), lre->fec.prefixlen);
			free(lre);
		}
d537 14
d554 1
a554 1
lde_check_release(struct map *map, struct lde_nbr *ln)
d556 5
a560 1
	log_debug("label mapping from nbr %s, FEC %s",
d563 30
a592 2
	/* check withdraw list */
	/* check sent map list */
@


1.25
log
@Fix a memory leak in an error path. Found and diff by Igor Zinovik.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.24 2010/06/30 22:15:02 claudio Exp $ */
d358 1
a358 1
	log_debug("label mapping from nbr %s, FEC %s/%u, label %u",
@


1.24
log
@Make it possible to store multiple LSP to a FEC. This is another step to
handle multipath routes in MPLS.
Looks good to michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.23 2010/06/30 05:21:38 claudio Exp $ */
d483 1
a483 1
		if (fec_insert(&ln->recv_req, &lre->fec))
d486 2
@


1.23
log
@Kill IMSG_KLABEL_INSERT and all the related functions around it.
IMSG_KLABEL_CHANGE is smart enough to know when something is a change
or an insert.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.22 2010/06/30 01:47:11 claudio Exp $ */
d43 6
d127 1
d132 3
a134 1
	struct rt_node		*r;
d138 10
a147 7
		r = (struct rt_node *)f;
		rtctl.prefix.s_addr = r->fec.prefix.s_addr;
		rtctl.prefixlen = r->fec.prefixlen;
		rtctl.nexthop.s_addr = r->nexthop.s_addr;
		rtctl.flags = r->flags;
		rtctl.local_label = r->local_label;
		rtctl.remote_label = r->remote_label;
d149 4
a152 4
		if (!r->present)
			rtctl.in_use = 0;
		else
			rtctl.in_use = 1;
d154 10
a163 4
		if (rtctl.nexthop.s_addr == htonl(INADDR_LOOPBACK))
			rtctl.connected = 1;
		else
			rtctl.connected = 0;
d165 4
a168 2
		lde_imsg_compose_ldpe(IMSG_CTL_SHOW_LIB, 0, pid, &rtctl,
		    sizeof(rtctl));
d192 21
d215 58
a272 1
	fec_clear(&rt, free);
d279 1
d288 2
a289 31
	if (rn == NULL) {
		rn = calloc(1, sizeof(*rn));
		if (rn == NULL)
			fatal("lde_insert");

		rn->fec.prefix.s_addr = kr->prefix.s_addr;
		rn->fec.prefixlen = kr->prefixlen;
		rn->remote_label = NO_LABEL;
		rn->local_label = NO_LABEL;
		LIST_INIT(&rn->upstream);
		LIST_INIT(&rn->downstream);

		if (fec_insert(&rt, &rn->fec))
			log_warnx("failed to add %s/%u to rt tree",
			    inet_ntoa(rn->fec.prefix), rn->fec.prefixlen);
	}

	if (rn->present) {
		if (kr->nexthop.s_addr == rn->nexthop.s_addr)
			return;

		/* The nexthop has changed, change also the label associated
		   with prefix */
		rn->remote_label = NO_LABEL;
		rn->nexthop.s_addr = kr->nexthop.s_addr;

		if ((ldeconf->mode & MODE_RET_LIBERAL) == 0) {
			/* XXX: we support just liberal retention for now */
			log_warnx("lde_kernel_insert: missing mode");
			return;
		}
d291 3
a293 18
		LIST_FOREACH(map, &rn->downstream, entry) {
			addr = lde_address_find(map->nexthop, &rn->nexthop);
			if (addr != NULL) {
				rn->remote_label = map->label;
				break;
			}
		}

		log_debug("lde_kernel_insert: prefix %s%u, "
		    "changing label to %u", inet_ntoa(rn->fec.prefix),
		    rn->fec.prefixlen, map ? map->label : 0);

		lde_send_change_klabel(rn);
		return;
	}

	rn->present = 1;
	rn->nexthop.s_addr = kr->nexthop.s_addr;
d301 8
d310 1
a310 1
		addr = lde_address_find(map->nexthop, &rn->nexthop);
d312 1
a312 1
			rn->remote_label = map->label;
d317 1
a317 10
	if (rn->local_label == NO_LABEL) {
		/* Directly connected route */
		if (kr->nexthop.s_addr == INADDR_ANY) {
			rn->local_label = MPLS_LABEL_IMPLNULL;
			rn->nexthop.s_addr = htonl(INADDR_LOOPBACK);
		} else
			rn->local_label = lde_assign_label();
	}

	lde_send_change_klabel(rn);
d327 1
a327 2
	struct lde_map		*map;
	struct lde_nbr		*ln;
d335 1
d338 7
a344 17
	if (ldeconf->mode & MODE_RET_LIBERAL) {
		ln = lde_find_address(rn->nexthop);
		if (ln) {
			map = calloc(1, sizeof(*map));
			if (map == NULL)
				fatal("lde_kernel_remove");

			map->label = rn->remote_label;
			map->fec = rn->fec;
			map->nexthop = ln;
			LIST_INSERT_HEAD(&rn->downstream, map, entry);
			if (fec_insert(&ln->recv_map, &map->fec))
				log_warnx("failed to add %s/%u to recv map (1)",
				    inet_ntoa(map->fec.prefix),
				    map->fec.prefixlen);
		}
	}
d346 2
a347 3
	rn->remote_label = NO_LABEL;
	rn->nexthop.s_addr = INADDR_ANY;
	rn->present = 0;
d354 2
a355 1
	struct lde_nbr_address	*addr;
d369 1
a369 6
		rn = calloc(1, sizeof(*rn));
		if (rn == NULL)
			fatal("lde_check_mapping");

		rn->fec.prefix = map->prefix;
		rn->fec.prefixlen = map->prefixlen;
a370 9
		rn->remote_label = NO_LABEL;
		rn->present = 0;

		LIST_INIT(&rn->upstream);
		LIST_INIT(&rn->downstream);

		if (fec_insert(&rt, &rn->fec))
			log_warnx("failed to add %s/%u to rt tree",
			    inet_ntoa(rn->fec.prefix), rn->fec.prefixlen);
d388 7
a394 2
	addr = lde_address_find(ln, &rn->nexthop);
	if (addr == NULL || !rn->present) {
d401 2
a402 13
		if (me == NULL) {
			me = calloc(1, sizeof(*me));
			if (me == NULL)
				fatal("lde_check_mapping");
			me->fec = rn->fec;
			me->nexthop = ln;

			LIST_INSERT_HEAD(&rn->downstream, me, entry);
			if (fec_insert(&ln->recv_map, &me->fec))
				log_warnx("failed to add %s/%u to recv map (2)",
				    inet_ntoa(me->fec.prefix),
				    me->fec.prefixlen);
		}
d408 1
a408 5
	rn->remote_label = map->label;

	/* If we are ingress for this LSP install the label */
	if (rn->nexthop.s_addr == INADDR_ANY)
		lde_send_change_klabel(rn);
d411 2
a412 12
	if (me == NULL) {
		me = calloc(1, sizeof(*me));
		if (me == NULL)
			fatal("lde_check_mapping");

		me->fec = rn->fec;
		me->nexthop = ln;
		LIST_INSERT_HEAD(&rn->downstream, me, entry);
		if (fec_insert(&ln->recv_map, &me->fec))
			log_warnx("failed to add %s/%u to recv map (3)",
			    inet_ntoa(me->fec.prefix), me->fec.prefixlen);
	}
d415 1
a415 1
	lde_send_change_klabel(rn);
d426 1
d435 1
a435 1
	if (rn == NULL || rn->remote_label == NO_LABEL) {
d441 1
a441 6
	if (lde_address_find(ln, &rn->nexthop)) {
		lde_send_notification(ln->peerid, S_LOOP_DETECTED,
		    map->messageid, MSG_TYPE_LABELREQUEST);
		return;
	}

d446 13
a458 2
	if (rn->nexthop.s_addr == INADDR_ANY ||
	    rn->remote_label != NO_LABEL) {
d465 6
a470 2
	} else {
		lnn = lde_find_address(rn->nexthop);
d472 1
a472 2
			/* XXX this feels wrong.... */
			return;
@


1.22
log
@Switch prefix in struct map to a struct in_addr instead of a u_int32_t.
Needed for further clean etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.21 2010/06/09 14:01:03 claudio Exp $ */
d263 1
a263 1
	lde_send_insert_klabel(rn);
@


1.21
log
@Move the logging of FEC changes to the LDE and print the FEC and label
information. This is more useful.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.20 2010/06/07 13:24:23 claudio Exp $ */
d162 1
a162 1
		map.prefix = r->fec.prefix.s_addr;
d317 1
a317 1
	rn = (struct rt_node *)fec_find_prefix(&rt, map->prefix,
d329 1
a329 1
		rn->fec.prefix.s_addr = map->prefix;
d422 1
a422 1
	rn = (struct rt_node *)fec_find_prefix(&rt, map->prefix,
@


1.20
log
@Store all labels in ldpd in host byte order without any additional shifting.
Add the necessary ntohl() and shifts in various places and cleanup the byte
order mess we had before. michele@@ agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.19 2010/06/02 11:56:29 claudio Exp $ */
d184 3
d276 3
d314 3
d419 3
d472 5
@


1.19
log
@Start reworking the LDE. Implement a FEC RB tree that can be used for the
route table and the per neighbor request and mapping lists.
The received and sent mappings are added to the per neighbor RB tree and
additionally linked to the route table. This makes lookups, etc. a lot
easier. While there flip the neighbor hash list over to a RB tree.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.18 2010/05/25 09:31:25 claudio Exp $ */
d164 1
a164 2
		map.label = (ntohl(r->local_label) & MPLS_LABEL_MASK) >>
		    MPLS_LABEL_OFFSET;
d221 1
a221 2
				rn->remote_label =
				    htonl(map->label << MPLS_LABEL_OFFSET);
d239 1
a239 1
		rn->local_label = htonl(kr->local_label << MPLS_LABEL_OFFSET);
d246 1
a246 2
			rn->remote_label =
			    htonl(map->label << MPLS_LABEL_OFFSET);
d254 1
a254 2
			rn->local_label =
			    htonl(MPLS_LABEL_IMPLNULL << MPLS_LABEL_OFFSET);
d285 1
a285 2
			map->label = (ntohl(rn->remote_label) &
			    MPLS_LABEL_MASK) >> MPLS_LABEL_OFFSET;
d375 1
a375 1
	rn->remote_label = htonl(map->label << MPLS_LABEL_OFFSET);
@


1.18
log
@Kill a bogus bzero() and introduce an empty lde_check_release().
That function will be needed soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.17 2010/05/19 15:28:51 claudio Exp $ */
a22 2
#include <netinet/in.h>
#include <arpa/inet.h>
d25 1
d27 1
d41 5
a46 3
RB_HEAD(rt_tree, rt_node)	 rt;
RB_PROTOTYPE(rt_tree, rt_node, entry, rt_compare)
RB_GENERATE(rt_tree, rt_node, entry, rt_compare)
d48 1
a48 1
u_int32_t	lde_assign_label(void);
d50 1
a50 1
/* route table */
d52 1
a52 1
rt_init(void)
d54 1
a54 1
	RB_INIT(&rt);
d57 2
a58 2
int
rt_compare(struct rt_node *a, struct rt_node *b)
d72 2
a73 2
struct rt_node *
rt_find(in_addr_t prefix, u_int8_t prefixlen)
d75 1
a75 1
	struct rt_node	 s;
d80 1
a80 1
	return (RB_FIND(rt_tree, &rt, &s));
d83 7
d91 1
a91 1
rt_insert(struct rt_node *r)
d93 1
a93 4
	if (RB_INSERT(rt_tree, &rt, r) != NULL) {
		log_warnx("rt_insert failed for %s/%u",
		    inet_ntoa(r->prefix), r->prefixlen);
		free(r);
a94 2
	}

d99 1
a99 1
rt_remove(struct rt_node *r)
d101 3
a103 3
	if (RB_REMOVE(rt_tree, &rt, r) == NULL) {
		log_warnx("rt_remove failed for %s/%u",
		    inet_ntoa(r->prefix), r->prefixlen);
d106 2
d109 9
a117 2
	free(r);
	return (0);
d120 1
d124 1
d128 4
a131 3
	RB_FOREACH(r, rt_tree, &rt) {
		rtctl.prefix.s_addr = r->prefix.s_addr;
		rtctl.prefixlen = r->prefixlen;
d155 1
d160 4
a163 4

	RB_FOREACH(r, rt_tree, &rt) {
		map.prefix = r->prefix.s_addr;
		map.prefixlen = r->prefixlen;
d175 1
a175 14
	struct rt_node	*r;

	while ((r = RB_MIN(rt_tree, &rt)) != NULL)
		rt_remove(r);
}

u_int32_t
lde_assign_label()
{
	static u_int32_t label = MPLS_LABEL_RESERVED_MAX;

	/* XXX some checks needed */
	label++;
	return (htonl(label << MPLS_LABEL_OFFSET));
a181 3
	struct rt_label		*rl;
	struct iface		*iface;
	struct lde_nbr		*ln;
d183 1
a183 1
	struct map		 localmap;
d185 2
a186 1
	rn = rt_find(kr->prefix.s_addr, kr->prefixlen);
d192 2
a193 2
		rn->prefix.s_addr = kr->prefix.s_addr;
		rn->prefixlen = kr->prefixlen;
d196 2
a197 1
		TAILQ_INIT(&rn->labels_list);
d199 3
a201 1
		rt_insert(rn);
d219 2
a220 2
		TAILQ_FOREACH(rl, &rn->labels_list, node_l) {
			addr = lde_address_find(rl->nexthop, &rn->nexthop);
d223 1
a223 1
				    htonl(rl->label << MPLS_LABEL_OFFSET);
d228 3
a230 2
		log_debug("lde_kernel_insert: prefix %s, changing label to %u",
		    inet_ntoa(rn->prefix), rl ? rl->label : 0);
d241 1
a241 1
		rn->local_label = (htonl(kr->local_label) << MPLS_LABEL_OFFSET);
d245 2
a246 2
	TAILQ_FOREACH(rl, &rn->labels_list, node_l) {
		addr = lde_address_find(rl->nexthop, &rn->nexthop);
d249 1
a249 1
			    htonl(rl->label << MPLS_LABEL_OFFSET);
d267 1
a267 21
	localmap.label = (ntohl(rn->local_label) & MPLS_LABEL_MASK) >>
	    MPLS_LABEL_OFFSET;
	localmap.prefix = rn->prefix.s_addr;
	localmap.prefixlen = rn->prefixlen;

	LIST_FOREACH(iface, &ldeconf->iface_list, entry) {
		LIST_FOREACH(ln, &iface->lde_nbr_list, entry) {
			if (ldeconf->mode & MODE_ADV_UNSOLICITED &&
			    ldeconf->mode & MODE_DIST_INDEPENDENT)
				lde_send_labelmapping(ln->peerid, &localmap);

			if (ldeconf->mode & MODE_ADV_UNSOLICITED &&
			    ldeconf->mode & MODE_DIST_ORDERED) {
			       /* XXX */
				if (rn->nexthop.s_addr == INADDR_ANY ||
				    rn->remote_label != NO_LABEL)
					lde_send_labelmapping(ln->peerid,
					    &localmap);
			}
		}
	}
d274 1
a274 1
	struct rt_label		*rl;
d277 2
a278 1
	rn = rt_find(kr->prefix.s_addr, kr->prefixlen);
d285 2
a286 2
			rl = calloc(1, sizeof(*rl));
			if (rl == NULL)
d289 9
a297 5
			rl->label = rn->remote_label;
			rl->node = rn;
			rl->nexthop = ln;
			TAILQ_INSERT_TAIL(&rn->labels_list, rl, node_l);
			TAILQ_INSERT_TAIL(&ln->labels_list, rl, nbr_l);
a309 1
	struct rt_label		*rl;
d311 4
a314 8
	struct lde_map_entry	*me, *menew;
	struct lde_req_entry	*req;
	struct iface		*iface;
	struct map		 localmap;

	/* The route is not yet in fib. If we are in liberal mode create a
	   route and record the label */
	rn = rt_find(map->prefix, map->prefixlen);
d316 2
d325 2
a326 2
		rn->prefix.s_addr = map->prefix;
		rn->prefixlen = map->prefixlen;
d331 2
a332 1
		TAILQ_INIT(&rn->labels_list);
d334 3
a336 1
		rt_insert(rn);
d339 2
a340 3
	TAILQ_FOREACH(me, &ln->recv_map_list, entry) {
		if (me->prefix.s_addr == map->prefix &&
		    me->prefixlen == map->prefixlen) {
d342 4
d349 2
d356 1
d361 15
a376 10
		rl = calloc(1, sizeof(*rl));
		if (rl == NULL)
			fatal("lde_check_mapping");

		rl->label = map->label;
		rl->node = rn;
		rl->nexthop = ln;

		TAILQ_INSERT_TAIL(&rn->labels_list, rl, node_l);
		TAILQ_INSERT_TAIL(&ln->labels_list, rl, nbr_l);
d387 4
a390 51
	menew = calloc(1, sizeof(*menew));
	if (menew == NULL)
		fatal("lde_check_mapping");

	menew->prefix.s_addr = map->prefix;
	menew->prefixlen = map->prefixlen;
	menew->label = map->label;

	TAILQ_INSERT_HEAD(&ln->recv_map_list, menew, entry);

	/* Redistribute the current mapping to every nbr */
	localmap.label = rn->local_label;
	localmap.prefix = rn->prefix.s_addr;
	localmap.prefixlen = rn->prefixlen;

	LIST_FOREACH(iface, &ldeconf->iface_list, entry) {
		LIST_FOREACH(ln, &iface->lde_nbr_list, entry) {
			/* Did we already send a mapping to this peer? */
			TAILQ_FOREACH(me, &ln->sent_map_list, entry) {
				if (me->prefix.s_addr == rn->prefix.s_addr &&
				    me->prefixlen == rn->prefixlen)
					break;
			}
			if (me != NULL) {
				/* XXX: check RAttributes */
				continue;
			}

			if (ldeconf->mode & MODE_ADV_UNSOLICITED &&
			    ldeconf->mode & MODE_DIST_ORDERED) {
				lde_send_labelmapping(ln->peerid, &localmap);

				menew = calloc(1, sizeof(*menew));
				if (menew == NULL)
					fatal("lde_check_mapping");

				menew->prefix.s_addr = map->prefix;
				menew->prefixlen = map->prefixlen;
				menew->label = map->label;

				TAILQ_INSERT_HEAD(&ln->sent_map_list, menew,
				    entry);
			}

			TAILQ_FOREACH(req, &ln->req_list, entry) {
				if (req->prefix.s_addr == rn->prefix.s_addr &&
				    req->prefixlen == rn->prefixlen)
					break;
			}
			if (req != NULL) {
				lde_send_labelmapping(ln->peerid, &localmap);
d392 6
a397 15
				menew = calloc(1, sizeof(*menew));
				if (menew == NULL)
					fatal("lde_check_mapping");

				menew->prefix.s_addr = map->prefix;
				menew->prefixlen = map->prefixlen;
				menew->label = map->label;

				TAILQ_INSERT_HEAD(&ln->sent_map_list, menew,
				    entry);

				TAILQ_REMOVE(&ln->req_list, req, entry);
				free(req);
			}
		}
d399 1
d402 3
d410 4
a413 4
	struct lde_req_entry	*lre, *newlre;
	struct rt_node		*rn;
	struct lde_nbr		*lnn;
	struct map		 localmap;
d415 2
a416 1
	rn = rt_find(map->prefix, map->prefixlen);
d429 3
a431 5
	TAILQ_FOREACH(lre, &ln->req_list, entry) {
		if (lre->prefix.s_addr == map->prefix &&
		    lre->prefixlen == map->prefixlen)
			return;
	}
d433 2
a434 2
	/* XXX: if we are egress ? */
	if (rn->remote_label != NO_LABEL) {
d444 1
d449 2
a450 2
		newlre = calloc(1, sizeof(*newlre));
		if (newlre == NULL)
d453 2
a454 2
		newlre->prefix.s_addr = map->prefix;
		newlre->prefixlen = map->prefixlen;
d456 3
a458 1
		TAILQ_INSERT_HEAD(&ln->req_list, newlre, entry);
a464 14
}

void
lde_label_list_free(struct lde_nbr *nbr)
{
	struct rt_label	*rl;

	while ((rl = TAILQ_FIRST(&nbr->labels_list)) != NULL) {
		TAILQ_REMOVE(&nbr->labels_list, rl, nbr_l);
		TAILQ_REMOVE(&nbr->labels_list, rl, node_l);
		if (TAILQ_EMPTY(&rl->node->labels_list))
			rt_remove(rl->node);
		free(rl);
	}
@


1.17
log
@Remove yet another ospf leftover that is not needed here. This time
neighbor self and all the madness surrounding this amazing concept.
LDP is not self aware so there is no need for this.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.16 2010/05/11 14:54:52 claudio Exp $ */
a464 2
	bzero(&newlre, sizeof(newlre));

d508 5
@


1.16
log
@No need to do a rt_find() twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.15 2010/04/13 15:39:29 michele Exp $ */
a267 3
			if (ln->self)
				continue;

@


1.15
log
@When a prefix has a implicit null label associated, force pop operation.
This allow us to correcly do penultimate hop popping.

From Thomas Habets. Thanks.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.14 2010/03/03 10:17:05 claudio Exp $ */
a293 1
	rn = rt_find(kr->prefix.s_addr, kr->prefixlen);
@


1.14
log
@Rework the kroute code by stealing some code from ospfd and massaging it
a lot more. Main reason for this is to add priority support. Additionally
add some additional NO_LABEL fixes.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.13 2010/02/25 21:47:08 michele Exp $ */
d121 1
a121 1
		if (!r->present || r->remote_label == NO_LABEL)
@


1.13
log
@One more substitution of label 0 with NO_LABEL.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.12 2010/02/25 21:07:31 michele Exp $ */
d193 1
d234 1
a234 1
	if (kr->local_label) {
d248 1
a248 1
	if (!rn->local_label) {
d294 1
@


1.12
log
@Whitespaces cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.11 2010/02/25 21:02:46 michele Exp $ */
d278 1
a278 1
				    rn->remote_label != 0)
@


1.11
log
@NO_LABEL (instead of zero) must be used to mean that no labels are associated
with the prefix.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.10 2010/02/19 12:49:21 claudio Exp $ */
d261 1
a261 1
	   MPLS_LABEL_OFFSET;
d266 7
a272 7
	       LIST_FOREACH(ln, &iface->lde_nbr_list, entry) {
		       if (ln->self)
			       continue;

		       if (ldeconf->mode & MODE_ADV_UNSOLICITED &&
			   ldeconf->mode & MODE_DIST_INDEPENDENT)
			       lde_send_labelmapping(ln->peerid, &localmap);
d274 2
a275 2
		       if (ldeconf->mode & MODE_ADV_UNSOLICITED &&
			   ldeconf->mode & MODE_DIST_ORDERED) {
d277 6
a282 6
			       if (rn->nexthop.s_addr == INADDR_ANY ||
				   rn->remote_label != 0)
				       lde_send_labelmapping(ln->peerid,
					   &localmap);
		       }
	       }
@


1.10
log
@If a neighbor goes down we need to cleanup the LIB from all FEC that point
via that neighbor. Fixes a use after free and an additional NULL dereference
in a log_debug is fixed as well.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.9 2010/01/19 18:03:08 michele Exp $ */
d121 1
a121 1
		if (!r->present)
d192 1
d204 1
a204 1
		rn->remote_label = 0;
d312 1
a312 1
	rn->remote_label = 0;
d342 1
@


1.9
log
@Don't fatalx() when a static route is deleted.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.8 2010/01/08 16:45:51 michele Exp $ */
d208 1
d212 1
a212 1
		TAILQ_FOREACH(rl, &rn->labels_list, entry) {
d222 1
a222 1
		    inet_ntoa(rn->prefix), rl->label);
d237 1
a237 1
	TAILQ_FOREACH(rl, &rn->labels_list, entry) {
d297 5
a301 5
		rl = calloc(1, sizeof(*rl));
		if (rl == NULL)
			fatal("lde_kernel_remove");

		rl->label = rn->remote_label;
d303 2
a304 2
		ln = lde_find_address(rn->nexthop);
		if (ln != NULL) {
d306 3
a308 3
			TAILQ_INSERT_TAIL(&rn->labels_list, rl, entry);
		} else
			free (rl);
d370 1
d373 2
a374 1
		TAILQ_INSERT_TAIL(&rn->labels_list, rl, entry);
d509 14
@


1.8
log
@Implement section A.1.6 of RFC 5036: "Recognize new FEC".

When a new prefix is learnt, redistribute the local label associated with
it to the other connected peers.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.7 2010/01/02 14:56:02 michele Exp $ */
d303 5
a307 6
		if (ln == NULL)
			fatalx("lde_kernel_remove: unable to find neighbor");

		rl->nexthop = ln;

		TAILQ_INSERT_TAIL(&rn->labels_list, rl, entry);
a309 1
	/* XXX */
@


1.7
log
@In the "ldpctl show lib" output print every known label and make clear if it
is currently in use or not.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.6 2009/09/28 09:48:46 michele Exp $ */
d179 2
d182 1
d236 6
a241 10
	/* There is already a local mapping, check if there
	   is also a remote one */
	if (rn->local_label) {
		TAILQ_FOREACH(rl, &rn->labels_list, entry) {
			addr = lde_address_find(rl->nexthop, &rn->nexthop);
			if (addr != NULL) {
				rn->remote_label =
				    htonl(rl->label << MPLS_LABEL_OFFSET);
				break;
			}
d243 3
a245 1
	} else {
d256 26
@


1.6
log
@When a route is deleted, ldpd should remove labels associated with it from
lfib (the kernel lib) but not from the lib. These could be used later on when
the route come back.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.5 2009/08/02 16:19:17 michele Exp $ */
a113 3
		if (!r->present)
			continue;

d120 5
@


1.5
log
@"ldpctl show lib" output cleanup.

- Show only the remote/local labels of the prefixes currently present
in fib.

- Write a "-" instead of "0" when a remote label is not present (the
prefix is directly connected). It avoids confusion with explicit null label.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.4 2009/07/08 18:59:29 michele Exp $ */
d253 33
@


1.4
log
@Detect nexthop change.
React installing the label associated with the new nexthop
in the kernel routing table.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.3 2009/06/19 17:10:09 michele Exp $ */
d114 3
d123 5
@


1.3
log
@When operating in liberal mode, retain labels even if they aren't learnt
from current nexthop.

ok laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.2 2009/06/05 22:34:45 michele Exp $ */
d165 1
a165 1
lde_insert(struct kroute *kr)
d184 27
a210 1
	if (rn->present)
d212 1
a230 2
				TAILQ_REMOVE(&rn->labels_list, rl, entry);
				free(rl);
@


1.2
log
@Correctly send notification messages when errors occur.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lde_lib.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d167 3
a169 1
	struct rt_node	*rn;
d171 12
a182 3
	rn = calloc(1, sizeof(*rn));
	if (rn == NULL)
		fatal("lde_insert");
d184 4
a187 1
	rn->prefix.s_addr = kr->prefix.s_addr;
a188 2
	rn->prefixlen = kr->prefixlen;
	TAILQ_INIT(&rn->labels_list);
d190 5
a194 1
	rt_insert(rn);
d196 14
a209 1
	if (kr->local_label == 0) {
d217 1
d219 1
a219 3
		lde_send_insert_klabel(rn);
	} else
		rn->local_label = (htonl(kr->local_label) << MPLS_LABEL_OFFSET);
d233 2
d236 17
a252 2
	if (rn == NULL)
		return;
d265 1
a265 1
	if (addr == NULL) {
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d328 2
a329 1
		lde_send_notification(ln->peerid, S_NO_ROUTE);
d334 2
a335 1
		lde_send_notification(ln->peerid, S_LOOP_DETECTED);
@

