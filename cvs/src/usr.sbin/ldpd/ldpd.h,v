head	1.87;
access;
symbols
	OPENBSD_6_1:1.87.0.4
	OPENBSD_6_1_BASE:1.87
	OPENBSD_6_0:1.80.0.2
	OPENBSD_6_0_BASE:1.80
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.55.0.4
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.42.0.8
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.42.0.6
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.42.0.2
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.29.0.4
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.2
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.6
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.87
date	2017.03.04.00.21.48;	author renato;	state Exp;
branches;
next	1.86;
commitid	luKtDak9oSLriyOU;

1.86
date	2017.03.04.00.12.26;	author renato;	state Exp;
branches;
next	1.85;
commitid	bHPjS8k63pM8XVeR;

1.85
date	2017.03.04.00.09.17;	author renato;	state Exp;
branches;
next	1.84;
commitid	tAFME29r3wKSl8xr;

1.84
date	2017.03.04.00.06.10;	author renato;	state Exp;
branches;
next	1.83;
commitid	GMDFIgs8eMuH7Rxe;

1.83
date	2017.03.03.23.36.06;	author renato;	state Exp;
branches;
next	1.82;
commitid	nsyffCkbHeLwduqi;

1.82
date	2017.03.03.23.30.57;	author renato;	state Exp;
branches;
next	1.81;
commitid	mvwmKJi9MZW7VKOy;

1.81
date	2017.01.20.12.19.18;	author benno;	state Exp;
branches;
next	1.80;
commitid	qrjsXLNhiS0G91tf;

1.80
date	2016.07.01.23.36.38;	author renato;	state Exp;
branches;
next	1.79;
commitid	h9Qy21EPYXbAFnoh;

1.79
date	2016.07.01.23.33.46;	author renato;	state Exp;
branches;
next	1.78;
commitid	o5yBQ1cPVCcMZ7gA;

1.78
date	2016.07.01.23.14.31;	author renato;	state Exp;
branches;
next	1.77;
commitid	DKNC9fIizmSRxKR1;

1.77
date	2016.06.13.23.01.37;	author renato;	state Exp;
branches;
next	1.76;
commitid	6Kn577N67pcmgY5D;

1.76
date	2016.05.23.19.20.55;	author renato;	state Exp;
branches;
next	1.75;
commitid	8nGP7z5tJSygyBn7;

1.75
date	2016.05.23.19.16.00;	author renato;	state Exp;
branches;
next	1.74;
commitid	wKGrbgE7dtbu6ic6;

1.74
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.73;
commitid	TLlfi1Pk0Z97z8HM;

1.73
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.72;
commitid	AQBoOveMRKjtVfFv;

1.72
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.71;
commitid	t07H0Mk6WGdVWB0W;

1.71
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.70;
commitid	D7VvXbswyzx5Ahb2;

1.70
date	2016.05.23.18.55.21;	author renato;	state Exp;
branches;
next	1.69;
commitid	85kONxXVWUqI2Jhb;

1.69
date	2016.05.23.18.43.28;	author renato;	state Exp;
branches;
next	1.68;
commitid	AsaVUcI80dYBe4eH;

1.68
date	2016.05.23.18.40.15;	author renato;	state Exp;
branches;
next	1.67;
commitid	LYl0nXLaUb8GwBRC;

1.67
date	2016.05.23.18.33.56;	author renato;	state Exp;
branches;
next	1.66;
commitid	YK3Z5X8iSxlfPhoT;

1.66
date	2016.05.23.18.25.30;	author renato;	state Exp;
branches;
next	1.65;
commitid	CR4Vr5IW5Uyetn11;

1.65
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.64;
commitid	VpAym8dVR6eY4drQ;

1.64
date	2016.05.23.17.00.40;	author renato;	state Exp;
branches;
next	1.63;
commitid	3KHOYftnvJzmjKLP;

1.63
date	2016.05.23.16.48.06;	author renato;	state Exp;
branches;
next	1.62;
commitid	4kI0TsNqeR7BvCyt;

1.62
date	2016.05.23.16.46.02;	author renato;	state Exp;
branches;
next	1.61;
commitid	NenT5qvVB6XmD81l;

1.61
date	2016.05.23.16.31.27;	author renato;	state Exp;
branches;
next	1.60;
commitid	c72xshgOyJT70vM6;

1.60
date	2016.05.23.16.14.36;	author renato;	state Exp;
branches;
next	1.59;
commitid	hNzA87VdOHsaOms9;

1.59
date	2016.05.23.16.10.23;	author renato;	state Exp;
branches;
next	1.58;
commitid	dfHsmfmr62xnFBxd;

1.58
date	2016.05.23.16.08.18;	author renato;	state Exp;
branches;
next	1.57;
commitid	BnqFnJhiKFbG4Dc4;

1.57
date	2016.05.23.14.59.50;	author renato;	state Exp;
branches;
next	1.56;
commitid	Zbc4sTxSIKWZvMzM;

1.56
date	2015.09.27.17.30.38;	author stsp;	state Exp;
branches;
next	1.55;
commitid	pKhBZfZX0D7hOGSk;

1.55
date	2015.07.21.05.01.46;	author renato;	state Exp;
branches;
next	1.54;
commitid	XffmjWB83F5FGFp5;

1.54
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.53;
commitid	puLLDX1XPNc3GxB9;

1.53
date	2015.07.21.04.45.21;	author renato;	state Exp;
branches;
next	1.52;
commitid	DOwVSvrpKsgJLpe1;

1.52
date	2015.07.21.04.43.28;	author renato;	state Exp;
branches;
next	1.51;
commitid	QaTrdqMa9i0CUoyW;

1.51
date	2015.07.21.04.40.56;	author renato;	state Exp;
branches;
next	1.50;
commitid	aaU19t2dCdAdF6ZH;

1.50
date	2015.07.21.04.39.28;	author renato;	state Exp;
branches;
next	1.49;
commitid	KR83ZYzpLqbp9L95;

1.49
date	2015.07.19.21.01.56;	author renato;	state Exp;
branches;
next	1.48;
commitid	3CZZKtMxWnvDQhpO;

1.48
date	2015.07.19.20.54.17;	author renato;	state Exp;
branches;
next	1.47;
commitid	AcGJH529uphBS2D2;

1.47
date	2015.07.19.20.50.03;	author renato;	state Exp;
branches;
next	1.46;
commitid	HQ4RevpYoLNvLRj2;

1.46
date	2015.07.19.18.27.59;	author renato;	state Exp;
branches;
next	1.45;
commitid	9kOXzqr0NuJAc5FM;

1.45
date	2015.04.04.15.15.44;	author renato;	state Exp;
branches;
next	1.44;
commitid	0KK6eZelqMVrwBLG;

1.44
date	2015.03.21.18.32.01;	author renato;	state Exp;
branches;
next	1.43;
commitid	Q890u5RO8xyMjkAO;

1.43
date	2015.02.09.11.54.24;	author claudio;	state Exp;
branches;
next	1.42;
commitid	LTeEOygtHEq8pPcX;

1.42
date	2013.06.04.02.34.48;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2013.06.04.02.28.27;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2013.06.04.02.25.28;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2013.06.04.00.56.49;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2013.06.03.17.01.59;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2013.06.03.16.53.49;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2013.06.01.19.42.07;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2013.06.01.19.28.55;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2013.06.01.18.47.07;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2013.06.01.18.35.02;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2013.06.01.18.26.40;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2013.06.01.18.16.35;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2013.05.31.14.11.31;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2012.04.12.17.33.43;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.10.12.28.25;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2010.10.07.12.02.23;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.02.14.34.04;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.01.13.54.54;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.08.09.41.05;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.30.05.21.38;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.30.01.47.11;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2010.05.25.13.29.45;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.25.09.35.45;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.19.15.28.51;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2010.05.14.13.53.51;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2010.05.11.15.01.46;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.29.12.09.28;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.15.15.44.37;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.15.15.39.32;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2010.04.15.15.04.23;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.03.10.17.05;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.25.17.40.46;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.02.14.56.02;	author michele;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.02.20.34.58;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.28.09.48.46;	author michele;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.02.16.19.17;	author michele;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.13.19.04.26;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.06.18.31.42;	author pyr;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.06.08.09.43;	author pyr;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.22.34.45;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.87
log
@Send VPLS MAC withdrawals.

RFC 4762 says that MAC address withdrawal messages can be used to
improve convergence time in VPLS networks. This patch makes ldpd send
MAC withdrawals whenever a non-pseudowire interface pertaining to a
VPLS goes down. The processing of received MAC withdrawals will be
implemented later.
@
text
@/*	$OpenBSD: ldpd.h,v 1.86 2017/03/04 00:12:26 renato Exp $ */

/*
 * Copyright (c) 2013, 2016 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _LDPD_H_
#define _LDPD_H_

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <net/if_arp.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <event.h>
#include <imsg.h>

#include "ldp.h"

#define CONF_FILE		"/etc/ldpd.conf"
#define	LDPD_SOCKET		"/var/run/ldpd.sock"
#define LDPD_USER		"_ldpd"

#define LDPD_OPT_VERBOSE	0x00000001
#define LDPD_OPT_VERBOSE2	0x00000002
#define LDPD_OPT_NOACTION	0x00000004

#define TCP_MD5_KEY_LEN		80
#define L2VPN_NAME_LEN		32

#define	RT_BUF_SIZE		16384
#define	MAX_RTSOCK_BUF		128 * 1024
#define	LDP_BACKLOG		128

#define	F_LDPD_INSERTED		0x0001
#define	F_CONNECTED		0x0002
#define	F_STATIC		0x0004
#define	F_DYNAMIC		0x0008
#define	F_REJECT		0x0010
#define	F_BLACKHOLE		0x0020
#define	F_REDISTRIBUTED		0x0040

struct evbuf {
	struct msgbuf		wbuf;
	struct event		ev;
};

struct imsgev {
	struct imsgbuf		 ibuf;
	void			(*handler)(int, short, void *);
	struct event		 ev;
	short			 events;
};

enum imsg_type {
	IMSG_NONE,
	IMSG_CTL_RELOAD,
	IMSG_CTL_SHOW_INTERFACE,
	IMSG_CTL_SHOW_DISCOVERY,
	IMSG_CTL_SHOW_NBR,
	IMSG_CTL_SHOW_LIB,
	IMSG_CTL_SHOW_L2VPN_PW,
	IMSG_CTL_SHOW_L2VPN_BINDING,
	IMSG_CTL_CLEAR_NBR,
	IMSG_CTL_FIB_COUPLE,
	IMSG_CTL_FIB_DECOUPLE,
	IMSG_CTL_KROUTE,
	IMSG_CTL_KROUTE_ADDR,
	IMSG_CTL_IFINFO,
	IMSG_CTL_END,
	IMSG_CTL_LOG_VERBOSE,
	IMSG_KLABEL_CHANGE,
	IMSG_KLABEL_DELETE,
	IMSG_KPWLABEL_CHANGE,
	IMSG_KPWLABEL_DELETE,
	IMSG_IFSTATUS,
	IMSG_NEWADDR,
	IMSG_DELADDR,
	IMSG_LABEL_MAPPING,
	IMSG_LABEL_MAPPING_FULL,
	IMSG_LABEL_REQUEST,
	IMSG_LABEL_RELEASE,
	IMSG_LABEL_WITHDRAW,
	IMSG_LABEL_ABORT,
	IMSG_REQUEST_ADD,
	IMSG_REQUEST_ADD_END,
	IMSG_MAPPING_ADD,
	IMSG_MAPPING_ADD_END,
	IMSG_RELEASE_ADD,
	IMSG_RELEASE_ADD_END,
	IMSG_WITHDRAW_ADD,
	IMSG_WITHDRAW_ADD_END,
	IMSG_ADDRESS_ADD,
	IMSG_ADDRESS_DEL,
	IMSG_NOTIFICATION,
	IMSG_NOTIFICATION_SEND,
	IMSG_NEIGHBOR_UP,
	IMSG_NEIGHBOR_DOWN,
	IMSG_NETWORK_ADD,
	IMSG_NETWORK_DEL,
	IMSG_SOCKET_IPC,
	IMSG_SOCKET_NET,
	IMSG_CLOSE_SOCKETS,
	IMSG_REQUEST_SOCKETS,
	IMSG_SETUP_SOCKETS,
	IMSG_RECONF_CONF,
	IMSG_RECONF_IFACE,
	IMSG_RECONF_TNBR,
	IMSG_RECONF_NBRP,
	IMSG_RECONF_L2VPN,
	IMSG_RECONF_L2VPN_IF,
	IMSG_RECONF_L2VPN_PW,
	IMSG_RECONF_END
};

union ldpd_addr {
	struct in_addr	v4;
	struct in6_addr	v6;
};

#define IN6_IS_SCOPE_EMBED(a)   \
	((IN6_IS_ADDR_LINKLOCAL(a)) ||  \
	 (IN6_IS_ADDR_MC_LINKLOCAL(a)) || \
	 (IN6_IS_ADDR_MC_INTFACELOCAL(a)))

/* interface states */
#define	IF_STA_DOWN		0x01
#define	IF_STA_ACTIVE		0x02

/* targeted neighbor states */
#define	TNBR_STA_DOWN		0x01
#define	TNBR_STA_ACTIVE		0x02

/* interface types */
enum iface_type {
	IF_TYPE_POINTOPOINT,
	IF_TYPE_BROADCAST
};

/* neighbor states */
#define	NBR_STA_PRESENT		0x0001
#define	NBR_STA_INITIAL		0x0002
#define	NBR_STA_OPENREC		0x0004
#define	NBR_STA_OPENSENT	0x0008
#define	NBR_STA_OPER		0x0010
#define	NBR_STA_SESSION		(NBR_STA_INITIAL | NBR_STA_OPENREC | \
				NBR_STA_OPENSENT | NBR_STA_OPER)

/* neighbor events */
enum nbr_event {
	NBR_EVT_NOTHING,
	NBR_EVT_MATCH_ADJ,
	NBR_EVT_CONNECT_UP,
	NBR_EVT_CLOSE_SESSION,
	NBR_EVT_INIT_RCVD,
	NBR_EVT_KEEPALIVE_RCVD,
	NBR_EVT_PDU_RCVD,
	NBR_EVT_PDU_SENT,
	NBR_EVT_INIT_SENT
};

/* neighbor actions */
enum nbr_action {
	NBR_ACT_NOTHING,
	NBR_ACT_RST_KTIMEOUT,
	NBR_ACT_SESSION_EST,
	NBR_ACT_RST_KTIMER,
	NBR_ACT_CONNECT_SETUP,
	NBR_ACT_PASSIVE_INIT,
	NBR_ACT_KEEPALIVE_SEND,
	NBR_ACT_CLOSE_SESSION
};

TAILQ_HEAD(mapping_head, mapping_entry);

struct map {
	uint8_t		type;
	uint32_t	msg_id;
	union {
		struct {
			uint16_t	af;
			union ldpd_addr	prefix;
			uint8_t		prefixlen;
		} prefix;
		struct {
			uint16_t	type;
			uint32_t	pwid;
			uint32_t	group_id;
			uint16_t	ifmtu;
		} pwid;
		struct {
			uint8_t		type;
			union {
				uint16_t	prefix_af;
				uint16_t	pw_type;
			} u;
		} twcard;
	} fec;
	struct {
		uint32_t	status_code;
		uint32_t	msg_id;
		uint16_t	msg_type;
	} st;
	uint32_t	label;
	uint32_t	requestid;
	uint32_t	pw_status;
	uint8_t		flags;
};
#define F_MAP_REQ_ID	0x01	/* optional request message id present */
#define F_MAP_STATUS	0x02	/* status */
#define F_MAP_PW_CWORD	0x04	/* pseudowire control word */
#define F_MAP_PW_ID	0x08	/* pseudowire connection id */
#define F_MAP_PW_IFMTU	0x10	/* pseudowire interface parameter */
#define F_MAP_PW_STATUS	0x20	/* pseudowire status */

struct notify_msg {
	uint32_t	status_code;
	uint32_t	msg_id;		/* network byte order */
	uint16_t	msg_type;	/* network byte order */
	uint32_t	pw_status;
	struct map	fec;
	struct {
		uint16_t	 type;
		uint16_t	 length;
		char		*data;
	} rtlvs;
	uint8_t		flags;
};
#define F_NOTIF_PW_STATUS	0x01	/* pseudowire status tlv present */
#define F_NOTIF_FEC		0x02	/* fec tlv present */
#define F_NOTIF_RETURNED_TLVS	0x04	/* returned tlvs present */

struct if_addr {
	LIST_ENTRY(if_addr)	 entry;
	int			 af;
	union ldpd_addr		 addr;
	uint8_t			 prefixlen;
	union ldpd_addr		 dstbrd;
};
LIST_HEAD(if_addr_head, if_addr);

struct iface_af {
	struct iface		*iface;
	int			 af;
	int			 enabled;
	int			 state;
	LIST_HEAD(, adj)	 adj_list;
	time_t			 uptime;
	struct event		 hello_timer;
	uint16_t		 hello_holdtime;
	uint16_t		 hello_interval;
};

struct iface {
	LIST_ENTRY(iface)	 entry;
	char			 name[IF_NAMESIZE];
	unsigned int		 ifindex;
	unsigned int		 rdomain;
	struct if_addr_head	 addr_list;
	struct in6_addr		 linklocal;
	enum iface_type		 type;
	uint8_t			 if_type;
	uint16_t		 flags;
	uint8_t			 linkstate;
	struct iface_af		 ipv4;
	struct iface_af		 ipv6;
};

/* source of targeted hellos */
struct tnbr {
	LIST_ENTRY(tnbr)	 entry;
	struct event		 hello_timer;
	struct adj		*adj;
	int			 af;
	union ldpd_addr		 addr;
	int			 state;
	uint16_t		 hello_holdtime;
	uint16_t		 hello_interval;
	uint16_t		 pw_count;
	uint8_t			 flags;
};
#define F_TNBR_CONFIGURED	 0x01
#define F_TNBR_DYNAMIC		 0x02

enum auth_method {
	AUTH_NONE,
	AUTH_MD5SIG
};

/* neighbor specific parameters */
struct nbr_params {
	LIST_ENTRY(nbr_params)	 entry;
	struct in_addr		 lsr_id;
	uint16_t		 keepalive;
	int			 gtsm_enabled;
	uint8_t			 gtsm_hops;
	struct {
		enum auth_method	 method;
		char			 md5key[TCP_MD5_KEY_LEN];
		uint8_t			 md5key_len;
	} auth;
	uint8_t			 flags;
};
#define F_NBRP_KEEPALIVE	 0x01
#define F_NBRP_GTSM		 0x02
#define F_NBRP_GTSM_HOPS	 0x04

struct l2vpn_if {
	LIST_ENTRY(l2vpn_if)	 entry;
	struct l2vpn		*l2vpn;
	char			 ifname[IF_NAMESIZE];
	unsigned int		 ifindex;
	uint16_t		 flags;
	uint8_t			 linkstate;
	uint8_t			 mac[ETHER_ADDR_LEN];
};

struct l2vpn_pw {
	LIST_ENTRY(l2vpn_pw)	 entry;
	struct l2vpn		*l2vpn;
	struct in_addr		 lsr_id;
	int			 af;
	union ldpd_addr		 addr;
	uint32_t		 pwid;
	char			 ifname[IF_NAMESIZE];
	unsigned int		 ifindex;
	uint32_t		 remote_group;
	uint16_t		 remote_mtu;
	uint32_t		 remote_status;
	uint8_t			 flags;
};
#define F_PW_STATUSTLV_CONF	0x01	/* status tlv configured */
#define F_PW_STATUSTLV		0x02	/* status tlv negotiated */
#define F_PW_CWORD_CONF		0x04	/* control word configured */
#define F_PW_CWORD		0x08	/* control word negotiated */
#define F_PW_STATUS_UP		0x10	/* pseudowire is operational */

struct l2vpn {
	LIST_ENTRY(l2vpn)	 entry;
	char			 name[L2VPN_NAME_LEN];
	int			 type;
	int			 pw_type;
	int			 mtu;
	char			 br_ifname[IF_NAMESIZE];
	unsigned int		 br_ifindex;
	LIST_HEAD(, l2vpn_if)	 if_list;
	LIST_HEAD(, l2vpn_pw)	 pw_list;
};
#define L2VPN_TYPE_VPWS		1
#define L2VPN_TYPE_VPLS		2

/* ldp_conf */
enum ldpd_process {
	PROC_MAIN,
	PROC_LDP_ENGINE,
	PROC_LDE_ENGINE
} ldpd_process;

static const char * const log_procnames[] = {
	"parent",
	"ldpe",
	"lde"
};

enum socket_type {
	LDP_SOCKET_DISC,
	LDP_SOCKET_EDISC,
	LDP_SOCKET_SESSION
};

enum hello_type {
	HELLO_LINK,
	HELLO_TARGETED
};

struct ldpd_af_conf {
	uint16_t		 keepalive;
	uint16_t		 thello_holdtime;
	uint16_t		 thello_interval;
	union ldpd_addr		 trans_addr;
	int			 flags;
};
#define	F_LDPD_AF_ENABLED	0x0001
#define	F_LDPD_AF_THELLO_ACCEPT	0x0002
#define	F_LDPD_AF_EXPNULL	0x0004
#define	F_LDPD_AF_NO_GTSM	0x0008

struct ldpd_conf {
	struct in_addr		 rtr_id;
	unsigned int		 rdomain;
	struct ldpd_af_conf	 ipv4;
	struct ldpd_af_conf	 ipv6;
	LIST_HEAD(, iface)	 iface_list;
	LIST_HEAD(, tnbr)	 tnbr_list;
	LIST_HEAD(, nbr_params)	 nbrp_list;
	LIST_HEAD(, l2vpn)	 l2vpn_list;
	uint16_t		 trans_pref;
	int			 flags;
};
#define	F_LDPD_NO_FIB_UPDATE	0x0001
#define	F_LDPD_DS_CISCO_INTEROP	0x0002

struct ldpd_af_global {
	struct event		 disc_ev;
	struct event		 edisc_ev;
	int			 ldp_disc_socket;
	int			 ldp_edisc_socket;
	int			 ldp_session_socket;
};

struct ldpd_global {
	int			 cmd_opts;
	char			*csock;
	time_t			 uptime;
	struct ldpd_af_global	 ipv4;
	struct ldpd_af_global	 ipv6;
	uint32_t		 conf_seqnum;
	int			 pfkeysock;
	struct if_addr_head	 addr_list;
	LIST_HEAD(, adj)	 adj_list;
	struct in_addr		 mcast_addr_v4;
	struct in6_addr		 mcast_addr_v6;
	TAILQ_HEAD(, pending_conn) pending_conns;
};

/* kroute */
struct kroute {
	int			 af;
	union ldpd_addr		 prefix;
	uint8_t			 prefixlen;
	union ldpd_addr		 nexthop;
	uint32_t		 local_label;
	uint32_t		 remote_label;
	unsigned short		 ifindex;
	uint8_t			 priority;
	uint16_t		 flags;
};

struct kpw {
	unsigned short		 ifindex;
	int			 pw_type;
	int			 af;
	union ldpd_addr		 nexthop;
	uint32_t		 local_label;
	uint32_t		 remote_label;
	uint8_t			 flags;
};

struct kaddr {
	unsigned short		 ifindex;
	int			 af;
	union ldpd_addr		 addr;
	uint8_t			 prefixlen;
	union ldpd_addr	 	 dstbrd;
};

struct kif {
	char			 ifname[IF_NAMESIZE];
	unsigned short		 ifindex;
	int			 flags;
	uint8_t			 link_state;
	uint8_t			 mac[ETHER_ADDR_LEN];
	int			 mtu;
	unsigned int		 rdomain;
	uint8_t			 if_type;
	uint64_t		 baudrate;
};

/* control data structures */
struct ctl_iface {
	int			 af;
	char			 name[IF_NAMESIZE];
	unsigned int		 ifindex;
	int			 state;
	uint16_t		 flags;
	uint8_t			 linkstate;
	enum iface_type		 type;
	uint8_t			 if_type;
	uint16_t		 hello_holdtime;
	uint16_t		 hello_interval;
	time_t			 uptime;
	uint16_t		 adj_cnt;
};

struct ctl_adj {
	int			 af;
	struct in_addr		 id;
	enum hello_type		 type;
	char			 ifname[IF_NAMESIZE];
	union ldpd_addr		 src_addr;
	uint16_t		 holdtime;
	union ldpd_addr		 trans_addr;
};

struct ctl_nbr {
	int			 af;
	struct in_addr		 id;
	union ldpd_addr		 laddr;
	union ldpd_addr		 raddr;
	time_t			 uptime;
	int			 nbr_state;
};

struct ctl_rt {
	int			 af;
	union ldpd_addr		 prefix;
	uint8_t			 prefixlen;
	struct in_addr		 nexthop;	/* lsr-id */
	uint32_t		 local_label;
	uint32_t		 remote_label;
	uint8_t			 flags;
	uint8_t			 in_use;
};

struct ctl_pw {
	uint16_t		 type;
	char			 ifname[IF_NAMESIZE];
	uint32_t		 pwid;
	struct in_addr		 lsr_id;
	uint32_t		 local_label;
	uint32_t		 local_gid;
	uint16_t		 local_ifmtu;
	uint32_t		 remote_label;
	uint32_t		 remote_gid;
	uint16_t		 remote_ifmtu;
	uint32_t		 status;
};

extern struct ldpd_conf		*ldpd_conf;
extern struct ldpd_global	 global;

/* parse.y */
struct ldpd_conf	*parse_config(char *);
int			 cmdline_symset(char *);

/* kroute.c */
int		 kif_init(void);
int		 kr_init(int, unsigned int);
void		 kif_redistribute(const char *);
int		 kr_change(struct kroute *);
int		 kr_delete(struct kroute *);
void		 kr_shutdown(void);
void		 kr_fib_couple(void);
void		 kr_fib_decouple(void);
void		 kr_change_egress_label(int, int);
void		 kr_show_route(struct imsg *);
void		 kr_ifinfo(char *, pid_t);
struct kif	*kif_findname(char *);
void		 kif_clear(void);
int		 kmpw_set(struct kpw *);
int		 kmpw_unset(struct kpw *);

/* util.c */
uint8_t		 mask2prefixlen(in_addr_t);
uint8_t		 mask2prefixlen6(struct sockaddr_in6 *);
in_addr_t	 prefixlen2mask(uint8_t);
struct in6_addr	*prefixlen2mask6(uint8_t);
void		 ldp_applymask(int, union ldpd_addr *,
		    const union ldpd_addr *, int);
int		 ldp_addrcmp(int, const union ldpd_addr *,
		    const union ldpd_addr *);
int		 ldp_addrisset(int, const union ldpd_addr *);
int		 ldp_prefixcmp(int, const union ldpd_addr *,
		    const union ldpd_addr *, uint8_t);
int		 bad_addr_v4(struct in_addr);
int		 bad_addr_v6(struct in6_addr *);
int		 bad_addr(int, union ldpd_addr *);
void		 embedscope(struct sockaddr_in6 *);
void		 recoverscope(struct sockaddr_in6 *);
void		 addscope(struct sockaddr_in6 *, uint32_t);
void		 clearscope(struct in6_addr *);
struct sockaddr	*addr2sa(int af, union ldpd_addr *, uint16_t);
void		 sa2addr(struct sockaddr *, int *, union ldpd_addr *);

/* ldpd.c */
void			 main_imsg_compose_ldpe(int, pid_t, void *, uint16_t);
void			 main_imsg_compose_lde(int, pid_t, void *, uint16_t);
void			 imsg_event_add(struct imsgev *);
int			 imsg_compose_event(struct imsgev *, uint16_t, uint32_t, pid_t,
			    int, void *, uint16_t);
void			 evbuf_enqueue(struct evbuf *, struct ibuf *);
void			 evbuf_event_add(struct evbuf *);
void			 evbuf_init(struct evbuf *, int, void (*)(int, short, void *), void *);
void			 evbuf_clear(struct evbuf *);
struct ldpd_af_conf	*ldp_af_conf_get(struct ldpd_conf *, int);
struct ldpd_af_global	*ldp_af_global_get(struct ldpd_global *, int);
int			 ldp_is_dual_stack(struct ldpd_conf *);
void			 merge_config(struct ldpd_conf *, struct ldpd_conf *);
struct ldpd_conf	*config_new_empty(void);
void			 config_clear(struct ldpd_conf *);

/* socket.c */
int		 ldp_create_socket(int, enum socket_type);
void		 sock_set_recvbuf(int);
int		 sock_set_reuse(int, int);
int		 sock_set_bindany(int, int);
int		 sock_set_ipv4_tos(int, int);
int		 sock_set_ipv4_recvif(int, int);
int		 sock_set_ipv4_minttl(int, int);
int		 sock_set_ipv4_ucast_ttl(int fd, int);
int		 sock_set_ipv4_mcast_ttl(int, uint8_t);
int		 sock_set_ipv4_mcast(struct iface *);
int		 sock_set_ipv4_mcast_loop(int);
int		 sock_set_ipv6_dscp(int, int);
int		 sock_set_ipv6_pktinfo(int, int);
int		 sock_set_ipv6_minhopcount(int, int);
int		 sock_set_ipv6_ucast_hops(int, int);
int		 sock_set_ipv6_mcast_hops(int, int);
int		 sock_set_ipv6_mcast(struct iface *);
int		 sock_set_ipv6_mcast_loop(int);

/* printconf.c */
void	print_config(struct ldpd_conf *);

/* logmsg.h */
struct in6_addr;
union ldpd_addr;
struct hello_source;
struct fec;

const char	*log_sockaddr(void *);
const char	*log_in6addr(const struct in6_addr *);
const char	*log_in6addr_scope(const struct in6_addr *, unsigned int);
const char	*log_addr(int, const union ldpd_addr *);
char		*log_label(uint32_t);
char		*log_hello_src(const struct hello_source *);
const char	*log_map(const struct map *);
const char	*log_fec(const struct fec *);
const char	*af_name(int);
const char	*socket_name(int);
const char	*nbr_state_name(int);
const char	*if_state_name(int);
const char	*if_type_name(enum iface_type);
const char	*msg_name(uint16_t);
const char	*status_code_name(uint32_t);
const char	*pw_type_name(uint16_t);

#endif	/* _LDPD_H_ */
@


1.86
log
@Implement RFC 6667 (Typed Wildcard FEC for PWid).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.85 2017/03/04 00:09:17 renato Exp $ */
d29 1
d32 1
d332 2
a333 1
	uint8_t			 link_state;
d480 1
@


1.85
log
@Implement RFC 5918 (Typed Wildcard FEC).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.84 2017/03/04 00:06:10 renato Exp $ */
d211 1
@


1.84
log
@Implement RFC 5561 (LDP Capabilities).

This patch per-se doesn't introduce any useful functionality, but prepares
the ground for new enhancements to ldpd (i.e. implementation of new RFCs
that make use of LDP capabilities).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.83 2017/03/03 23:36:06 renato Exp $ */
d207 6
@


1.83
log
@Allow to run on a non-default rdomain.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.82 2017/03/03 23:30:57 renato Exp $ */
d231 5
d240 1
@


1.82
log
@Allow to specify an alternate control socket.

This is required to run multiple instances of ldpd.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.81 2017/01/20 12:19:18 benno Exp $ */
d261 1
d392 1
d465 1
d539 1
a539 1
int		 kr_init(int);
@


1.81
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

removal of log_rtmsg() aproved by claudio@@

ok claudio@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.80 2016/07/01 23:36:38 renato Exp $ */
d413 1
@


1.80
log
@More renaming and whitespace cleanup.

No binary change after "strip -s".
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.79 2016/07/01 23:33:46 renato Exp $ */
d360 6
d611 23
@


1.79
log
@Be more compliant with RFC 4447.

When sending a label withdraw during the pseudowire Control Word
negotiation, append a "Wrong C-bit" status TLV after the FEC TLV (in
conformance to RFC 4447 section 6.2). Apparently this has no use other
than aiding in troubleshooting.

Also, extend the recv_labelmessage() function to accept Status TLVs and
ignore them instead of shutting down the session.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.78 2016/07/01 23:14:31 renato Exp $ */
d194 1
a194 1
	uint32_t	messageid;
d209 1
a209 1
		uint32_t	code;
d212 1
a212 1
	} status;
d226 3
a228 3
	uint32_t	status;
	uint32_t	messageid;	/* network byte order */
	uint16_t	type;		/* network byte order */
@


1.78
log
@Add GTSM support (RFC 6720).

This also finishes the missing bits from our RFC 7552 implementation
because GTSM is mandatory for LDPv6.

To avoid any kind of interoperability problems, I included a few
knobs to enable/disable GTSM on a per-address-family and per-neighbor
basis. Cisco's LDPv6 implementation, for instance, doesn't support GTSM.

"reads good" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.77 2016/06/13 23:01:37 renato Exp $ */
d208 5
d219 5
a223 4
#define F_MAP_PW_CWORD	0x02	/* pseudowire control word */
#define F_MAP_PW_ID	0x04	/* pseudowire connection id */
#define F_MAP_PW_IFMTU	0x08	/* pseudowire interface parameter */
#define F_MAP_PW_STATUS	0x10	/* pseudowire status */
@


1.77
log
@Implement support for the Configuration Sequence Number TLV.

The Configuration Sequence Number optional TLV is documented in RFC 5036,
pages 53 and 54.

Fixes IxANVL LDP test 23.10.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.76 2016/05/23 19:20:55 renato Exp $ */
d291 2
d301 2
d375 1
a581 1
int		 sock_set_ipv4_mcast_ttl(int, uint8_t);
d584 3
d591 3
@


1.76
log
@Add support for manually resetting neighbors.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.75 2016/05/23 19:16:00 renato Exp $ */
d399 1
@


1.75
log
@Improve security by calling exec after fork.

For each child process (lde and ldpe), re-exec ldpd with a special
"per-role" getopt flag. This way we have seperate ASLR/cookies per
process.

Based on a similar patch for bgpd, from claudio@@

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.74 2016/05/23 19:14:03 renato Exp $ */
d80 1
@


1.74
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.73 2016/05/23 19:11:42 renato Exp $ */
d116 1
d343 1
a343 1
enum {
d567 1
@


1.73
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.72 2016/05/23 19:09:25 renato Exp $ */
d4 1
@


1.72
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.71 2016/05/23 18:58:48 renato Exp $ */
d24 2
a26 2
#include <sys/socket.h>
#include <sys/time.h>
a27 1
#include <md5.h>
d31 1
a32 1
#include <imsg.h>
@


1.71
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.70 2016/05/23 18:55:21 renato Exp $ */
a404 2
extern struct ldpd_global global;

d506 3
d515 1
a516 1
int		 kr_init(int);
a518 1
void		 kif_clear(void);
a522 1
void		 kr_dispatch_msg(int, short, void *);
d526 1
a528 8
int		 kmpw_install(const char *, struct kpw *);
int		 kmpw_uninstall(const char *);

/* log.h */
const char	*nbr_state_name(int);
const char	*if_state_name(int);
const char	*if_type_name(enum iface_type);
const char	*notification_name(uint32_t);
d553 9
a561 12
void	main_imsg_compose_ldpe(int, pid_t, void *, uint16_t);
void	main_imsg_compose_lde(int, pid_t, void *, uint16_t);
void	merge_config(struct ldpd_conf *, struct ldpd_conf *);
void	config_clear(struct ldpd_conf *);
int	imsg_compose_event(struct imsgev *, uint16_t, uint32_t, pid_t,
	    int, void *, uint16_t);
void	imsg_event_add(struct imsgev *);
void	evbuf_enqueue(struct evbuf *, struct ibuf *);
void	evbuf_event_add(struct evbuf *);
void	evbuf_init(struct evbuf *, int, void (*)(int, short, void *), void *);
void	evbuf_clear(struct evbuf *);

d565 2
@


1.70
log
@Assorted fixes and small cleanup.

Nothing really interesting here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.69 2016/05/23 18:43:28 renato Exp $ */
d130 10
d193 1
a193 1
	union map_fec {
d195 2
a196 1
			struct in_addr	prefix;
d198 1
a198 1
		} ipv4;
d230 4
a233 3
	struct in_addr		 addr;
	struct in_addr		 mask;
	struct in_addr		 dstbrd;
d237 12
a250 2
	struct event		 hello_timer;

d252 1
d254 1
a254 8
	LIST_HEAD(, adj)	 adj_list;

	time_t			 uptime;
	unsigned int		 ifindex;
	int			 state;
	uint16_t		 hello_holdtime;
	uint16_t		 hello_interval;
	uint16_t		 flags;
d257 1
d259 2
d268 2
a269 2
	struct in_addr		 addr;

d311 2
d359 11
d372 2
a373 1
	struct in_addr		 trans_addr;
d378 1
a378 3
	uint16_t		 keepalive;
	uint16_t		 thello_holdtime;
	uint16_t		 thello_interval;
d382 9
a390 2
#define	F_LDPD_TH_ACCEPT	0x0002
#define	F_LDPD_EXPNULL		0x0004
d395 2
a397 3
	int			 ldp_disc_socket;
	int			 ldp_edisc_socket;
	int			 ldp_session_socket;
d399 3
d409 4
a412 2
	struct in_addr		 prefix;
	struct in_addr		 nexthop;
a414 1
	uint16_t		 flags;
a415 1
	uint8_t			 prefixlen;
d417 1
d423 2
a424 1
	struct in_addr		 nexthop;
d432 4
a435 3
	struct in_addr		 addr;
	struct in_addr		 mask;
	struct in_addr		 dstbrd;
d440 1
a440 1
	uint64_t		 baudrate;
d442 1
a443 1
	unsigned short		 ifindex;
d445 1
a445 1
	uint8_t			 link_state;
d450 1
a451 1
	time_t			 uptime;
a453 1
	uint16_t		 adj_cnt;
d455 3
d460 2
a461 3
	enum iface_type		 type;
	uint8_t			 linkstate;
	uint8_t			 if_type;
d465 1
d469 1
a469 1
	struct in_addr		 src_addr;
d471 1
d475 1
d477 2
a478 1
	struct in_addr		 addr;
d484 2
a485 1
	struct in_addr		 prefix;
d487 1
a487 1
	struct in_addr		 nexthop;
d522 1
a522 1
void		 kr_change_egress_label(int);
a526 2
uint8_t		 mask2prefixlen(in_addr_t);
in_addr_t	 prefixlen2mask(uint8_t);
d540 1
d542 17
a558 1
int		 bad_ip_addr(struct in_addr);
d573 4
d578 1
a578 1
int		 ldp_create_socket(enum socket_type);
d587 4
@


1.69
log
@Use SO_BINDANY before binding sockets to the transport-address.

This allows ldpd to start on a system without any IP address and bind
to the transport-address successfully.  Without this patch, we'd need to
monitor the new addresses from the kernel and create the network sockets
only when the transport-address is available in the system.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.68 2016/05/23 18:40:15 renato Exp $ */
d480 4
a483 4
void		 kmpw_set(struct kpw *);
void		 kmpw_unset(struct kpw *);
void		 kmpw_install(const char *, struct kpw *);
void		 kmpw_uninstall(const char *, struct kpw *);
d492 2
@


1.68
log
@Several fixes in the config reload handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.67 2016/05/23 18:33:56 renato Exp $ */
d511 1
@


1.67
log
@Create network sockets on the parent process.

We drop our privileges in ldpe right after we create the network sockets.
The problem is that we might want to change the transport-address and
reload the config, in which case we need new sockets. To allow that,
always create the network sockets in the parent process and pass them
to ldpe via imsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.66 2016/05/23 18:25:30 renato Exp $ */
d465 1
a465 1
void		 kif_redistribute(void);
@


1.66
log
@Move socket creation and setup into a specialized function.

Right now we use three network sockets in ldpd:
* the discovery socket (udp+mcast);
* the extended discovery socket (udp);
* the session socket (tcp).

When we introduce IPv6 support, we'll get three more sockets. In order
to prevent code duplication in the future, add a specialized function
that creates a socket according to the given type (and address-family
later). This also improves readability because it makes it easier to
see the differences between each socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.65 2016/05/23 17:43:42 renato Exp $ */
d116 4
d134 4
d251 1
@


1.65
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d318 6
d499 1
@


1.64
log
@Move setsockopt helper functions to a separate file.

IPv6 support is coming and we don't want to pollute the interface.c file
with too many of these helper functions.

Also, rename these functions from if_set_* to sock_set_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.63 2016/05/23 16:48:06 renato Exp $ */
d40 4
a50 3
#define	LDPD_FLAG_NO_FIB_UPDATE	0x0001
#define	LDPD_FLAG_TH_ACCEPT	0x0002

d173 2
a174 2
	u_int8_t	type;
	u_int32_t	messageid;
d178 1
a178 1
			u_int8_t	prefixlen;
d181 4
a184 4
			u_int16_t	type;
			u_int32_t	pwid;
			u_int32_t	group_id;
			u_int16_t	ifmtu;
d187 4
a190 4
	u_int32_t	label;
	u_int32_t	requestid;
	u_int32_t	pw_status;
	u_int8_t	flags;
d199 4
a202 4
	u_int32_t	messageid;
	u_int32_t	status;
	u_int32_t	type;
	u_int32_t	pw_status;
d204 1
a204 1
	u_int8_t	flags;
d228 3
a230 3
	u_int16_t		 hello_holdtime;
	u_int16_t		 hello_interval;
	u_int16_t		 flags;
d232 2
a233 2
	u_int8_t		 if_type;
	u_int8_t		 linkstate;
d243 4
a246 4
	u_int16_t		 hello_holdtime;
	u_int16_t		 hello_interval;
	u_int16_t		 pw_count;
	u_int8_t		 flags;
d259 2
a260 1
	struct in_addr		 addr;
d264 1
a264 1
		u_int8_t		 md5key_len;
d266 1
d268 1
d275 2
a276 2
	u_int16_t		 flags;
	u_int8_t		 link_state;
d282 2
a283 2
	struct in_addr		 addr;
	u_int32_t		 pwid;
d286 4
a289 4
	u_int32_t		 remote_group;
	u_int16_t		 remote_mtu;
	u_int32_t		 remote_status;
	u_int8_t		 flags;
d324 14
a337 6
	struct in_addr		rtr_id;
	LIST_HEAD(, iface)	iface_list;
	struct if_addr_head	addr_list;
	LIST_HEAD(, tnbr)	tnbr_list;
	LIST_HEAD(, nbr_params)	nbrp_list;
	LIST_HEAD(, l2vpn)	l2vpn_list;
d339 9
a347 13
	u_int32_t		opts;
#define LDPD_OPT_VERBOSE	0x00000001
#define LDPD_OPT_VERBOSE2	0x00000002
#define LDPD_OPT_NOACTION	0x00000004
	time_t			uptime;
	int			pfkeysock;
	int			ldp_discovery_socket;
	int			ldp_ediscovery_socket;
	int			ldp_session_socket;
	int			flags;
	u_int16_t		keepalive;
	u_int16_t		thello_holdtime;
	u_int16_t		thello_interval;
d350 2
d354 8
a361 8
	struct in_addr	prefix;
	struct in_addr	nexthop;
	u_int32_t	local_label;
	u_int32_t	remote_label;
	u_int16_t	flags;
	u_short		ifindex;
	u_int8_t	prefixlen;
	u_int8_t	priority;
d365 1
a365 1
	u_short			 ifindex;
d368 3
a370 3
	u_int32_t		 local_label;
	u_int32_t		 remote_label;
	u_int8_t		 flags;
d374 1
a374 1
	u_short			 ifindex;
d382 1
a382 1
	u_int64_t		 baudrate;
d385 3
a387 3
	u_short			 ifindex;
	u_int8_t		 if_type;
	u_int8_t		 link_state;
d396 4
a399 4
	u_int16_t		 adj_cnt;
	u_int16_t		 flags;
	u_int16_t		 hello_holdtime;
	u_int16_t		 hello_interval;
d401 2
a402 2
	u_int8_t		 linkstate;
	u_int8_t		 if_type;
d410 1
a410 1
	u_int16_t		 holdtime;
d422 1
a422 1
	u_int8_t		 prefixlen;
d424 4
a427 4
	u_int32_t		 local_label;
	u_int32_t		 remote_label;
	u_int8_t		 flags;
	u_int8_t		 in_use;
d431 1
a431 1
	u_int16_t		 type;
d433 9
a441 9
	u_int32_t		 pwid;
	struct in_addr		 nexthop;
	u_int32_t		 local_label;
	u_int32_t		 local_gid;
	u_int16_t		 local_ifmtu;
	u_int32_t		 remote_label;
	u_int32_t		 remote_gid;
	u_int16_t		 remote_ifmtu;
	u_int32_t		 status;
d445 1
a445 1
struct ldpd_conf	*parse_config(char *, int);
d458 1
d463 2
a464 2
u_int8_t	 mask2prefixlen(in_addr_t);
in_addr_t	 prefixlen2mask(u_int8_t);
d474 1
a474 1
const char	*notification_name(u_int32_t);
d480 2
a481 2
void	main_imsg_compose_ldpe(int, pid_t, void *, u_int16_t);
void	main_imsg_compose_lde(int, pid_t, void *, u_int16_t);
d484 2
a485 2
int	imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t, pid_t,
	    int, void *, u_int16_t);
@


1.63
log
@Fix warnings when compiling with -pedantic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.62 2016/05/23 16:46:02 renato Exp $ */
d480 9
@


1.62
log
@Release allocated memory before exiting.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.61 2016/05/23 16:31:27 renato Exp $ */
d154 1
a154 1
	NBR_EVT_INIT_SENT,
d252 1
a252 1
	AUTH_MD5SIG,
@


1.61
log
@Remove unnecessary mirroring of sockets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.60 2016/05/23 16:14:36 renato Exp $ */
d444 1
@


1.60
log
@More renaming.

Rename a few more things to improve readability.

* s/F_PW_CONTROLWORD_CONF/F_PW_CWORD_CONF/ (shorter)
* s/F_PW_CONTROLWORD/F_PW_CWORD/ (shorter)
* s/LDPD_FLAG_*/F_LDPD_*/ (consistency)
* s/lde_nbr_address/lde_addr/ (shorter)
* s/ldp_discovery_socket/ldp_disc_socket/ (shorter)
* s/ldp_ediscovery_socket/ldp_edisc_socket/ (shorter)
* s/ldp_sendboth/main_imsg_compose_both/ (consistency)
* s/cons/total/ (makes more sense)
* s/kaddr/ka/ (consistency with remaining code)
* Always use 'ln' for lde_nbrs (consistency)
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.59 2016/05/23 16:10:23 renato Exp $ */
a225 1
	int			 discovery_fd;
a238 1
	int			 discovery_fd;
@


1.59
log
@Remove unused code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.58 2016/05/23 16:08:18 renato Exp $ */
d291 2
a292 2
#define F_PW_CONTROLWORD_CONF	0x04	/* control word configured */
#define F_PW_CONTROLWORD	0x08	/* control word negotiated */
@


1.58
log
@Several improvements in the parsing of UDP/Hello packets.

* Fix check of the packet's size and the "PDU Length" field;
* Add check for the "Message Length" field;
* Check for invalid labelspace earlier.
* Use if_lookup() on disc_recv_iface() to reduce one level of identation;

Additionally, add the following safeguards:
* Check for unicast link hellos;
* Check for multicast targeted hellos;
* Validate packet's source address;
* Validate received transport-address.

Put the ancillary function bad_ip_addr() into a new file, util.c, which
will be used later for several other things.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.57 2016/05/23 14:59:50 renato Exp $ */
a66 1
	void			*data;
@


1.57
log
@Explicitly close the pfkey socket on exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.56 2015/09/27 17:30:38 stsp Exp $ */
d466 3
@


1.56
log
@As done for bgpd recently, rename if_mediatype to if_type in ldpd.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.55 2015/07/21 05:01:46 renato Exp $ */
d335 1
@


1.55
log
@Remove more unused defines.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.54 2015/07/21 04:52:29 renato Exp $ */
d233 1
a233 1
	u_int8_t		 media_type;
d378 1
a378 1
	u_int8_t		 media_type;
d394 1
a394 1
	u_int8_t		 mediatype;
@


1.54
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.53 2015/07/21 04:45:21 renato Exp $ */
a41 3

#define NBR_IDSELF		1
#define NBR_CNTSTART		(NBR_IDSELF + 1)
@


1.53
log
@Reuse merge_config() logic to simplify the shutdown of each process.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.52 2015/07/21 04:43:28 renato Exp $ */
d41 1
d81 2
d92 2
d113 1
d123 3
d176 14
a189 2
	struct in_addr	prefix;
	u_int8_t	prefixlen;
a190 1
	u_int32_t	messageid;
d192 1
d195 5
a199 2
#define F_MAP_WILDCARD	0x01	/* wildcard FEC */
#define F_MAP_REQ_ID	0x02	/* optional request message id present */
d205 3
d209 2
d250 1
d272 41
d331 1
d359 9
d425 14
d458 4
@


1.52
log
@Add configuration reload support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.51 2015/07/21 04:40:56 renato Exp $ */
a254 2
	struct event		disc_ev;
	struct event		edisc_ev;
d374 1
@


1.51
log
@Assorted fixes and code cleanup for targeted neighbors.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.50 2015/07/21 04:39:28 renato Exp $ */
d115 2
a120 1
#define	IF_STA_NEW		0x00	/* dummy state for reload */
a362 1
void		 kr_reload(void);
@


1.50
log
@Improve handling of addresses on ldpe.

This is a preliminary work for the the next patch (sigup config
reload). We want to make sure that the ldpe process can handle duplicated
addresses.

The idea is to alloc two different if_addr structures for each address,
and link one in the global list of addresses (used to send address
messages) and link the other to the associated interface list of
addresses.

Doing that we will be able to call kif_redistribute() after reloading
the config file and activate the new LDP enabled interfaces.

NOTE: Interfaces are created at config parse time and the child
processes inherit them on fork() so there's no need to send a status
update at startup.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.49 2015/07/19 21:01:56 renato Exp $ */
d223 1
@


1.49
log
@Implement md5 authentication support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.48 2015/07/19 20:54:17 renato Exp $ */
d183 1
a183 2
	LIST_ENTRY(if_addr)	 global_entry;
	LIST_ENTRY(if_addr)	 iface_entry;
d188 1
d195 1
a195 1
	LIST_HEAD(, if_addr)	 addr_list;
d257 1
a257 1
	LIST_HEAD(, if_addr)	addr_list;
@


1.48
log
@Rework label mapping algorithms to be more in line with the RFC.

This patch presents a thoroughly review of the label mapping
algorithms. Most of the changes are minor bug fixes in the handling of
received label messages.

Additional improvements:
* Add a few more references to the Appendix A of the RFC5036 ("LDP
  Label Distribution Procedures") into the code;
* Add full multipath support;
* Send label withdraws when appropriate;
* Add label withdraw/release wildcard support.

NOTE: As a result of implementing only the "Liberal Label Retention" and
"Downstream Unsolicited" modes, we will never send a label request
("Request  Never"). And that means that we can ignore the following
notification messages: "Label Request Aborted", "No Label Resources",
"No Route" and "Label Resources Available". The following algorithms
mentioned in the RFC can also be ignored: "Timeout of Deferred Label
Request", "Detect Local Label Resources Have Become Available" and
"Receive Label Abort Request".

Now, considering that we only support one combination of all modes of
operation, we can say that we have an almost complete implementation of
the protocol.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.47 2015/07/19 20:50:03 renato Exp $ */
d40 2
d224 16
d259 1
@


1.47
log
@Remove incomplete support for unnecessary modes of  operation.

LDP has several modes of operation, it was designed in that way so it
could run on legacy equipment like ATM/FR switches with very strict
memory limitations.

For modern hardware there's no point on using either the "Conservative
Label Retention" or "Downstream On Demand" modes of operation since they
save memory at cost of blackholing traffic when routing changes. Major
vendors implement only the "Liberal Label Retention" and "Downstream
Unsolicited" modes for non ATM/FR hardware. Let's do that too.

As for using either "Independent Control" or "Ordered Control", let's
stick with the first option mainly because it's easier to implement
and because it doesn't really matter which control mode is used. For
reference, Cisco implements only "Independent Control" and Juniper only
"Ordered Control". Both modes are interoperable.

The point of supporting only one combination of all modes of operation
is that it will allow for the writing of a simpler code without removing
useful functionality.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.46 2015/07/19 18:27:59 renato Exp $ */
d102 2
d165 1
a168 1
	u_int8_t	prefixlen;
d172 1
a172 2
#define F_MAP_OPTLABEL	0x02	/* optional label present */
#define F_MAP_REQ_ID	0x04	/* optional request message id present */
@


1.46
log
@Rework kroute.c to send only the best routes to lde.

This is major rework of the kroute.c code. The idea is remove complexity
from the lde process by making kroute.c advertise only the lowest priority
routes of each prefix.

kroute.c now keeps track of all routes using three different structures:
kroute_prefix, kroute_priority and kroute_node.

kroute_prefix represents a prefix and contains an ordered list of
priorities (kroute_priority) and for each priority there is a list of
nexthops (kroute_node). Arranging the routes using these three structures
allows for the writing of a simpler code, easier to understand.

Whenever a route is removed, if there's another route for the same prefix,
but with a lower priority, this route is immediately sent to lde.

Additional fixes:
* On RTM_CHANGE, remove the old route before installing the new one;
* On IMSG_CTL_KROUTE_ADDR, show all nexthops for multpath routes;
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.45 2015/04/04 15:15:44 renato Exp $ */
a232 7
#define	MODE_DIST_INDEPENDENT	0x01
#define	MODE_DIST_ORDERED	0x02
#define	MODE_RET_LIBERAL	0x04
#define	MODE_RET_CONSERVATIVE	0x08
#define	MODE_ADV_ONDEMAND	0x10
#define	MODE_ADV_UNSOLICITED	0x20

a249 1
	u_int8_t		mode;
@


1.45
log
@Show the full LIB in the "ldpctl show lib" command.

The LIB is a table where the router keeps all known MPLS labels. So,
we should loop over all the received label mappings from all neighbors
to show the full LIB.

The lde_nbr_is_nexthop() function was introduced to verify if a lib
entry is supposed to be installed in the fib (according to the fib entry's
nexthop and the addresses advertised by the lib entry's nexthop). This is
better than keeping track of lib<->fib entries with pointers and back
pointers because it keeps the lib/fib structures independent of each
other, which in turn makes the code less prone to bugs.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.44 2015/03/21 18:32:01 renato Exp $ */
d350 2
a351 3

u_int8_t	mask2prefixlen(in_addr_t);
in_addr_t	prefixlen2mask(u_int8_t);
@


1.44
log
@Remove interface finite state machine.

In the name of simplicity, remove the interface FSM that was inherited
from ospfd. In ldpd interfaces are just up or down, so keeping a
FSM for that is an overkill. Now instead of calling if_fsm(), just
call if_update() whenever a relevant event occurs (status change,
address addition/removal).

Additional notes:
1 - s/if_act_/if_/

2 - Remove the IMSG_IFUP and IMSG_IFDOWN events. Now whenever an
interface changes its state a IMSG_IFSTATUS event will be generated
with the new status.

kroute.c ldpd.h ldpe.c ldpe.h CVS:
----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.43 2015/02/09 11:54:24 claudio Exp $ */
d324 1
a325 2
	struct in_addr		 adv_rtr;
	time_t			 uptime;
a328 2
	u_int8_t		 prefixlen;
	u_int8_t		 connected;
@


1.43
log
@More SOCK_NONBLOCK | SOCK_CLOEXEC love and one less session_socket_blockmode
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.42 2013/06/04 02:34:48 claudio Exp $ */
a87 2
	IMSG_IFUP,
	IMSG_IFDOWN,
a117 17
#define	IF_STA_ANY		(IF_STA_DOWN | IF_STA_ACTIVE)

/* interface events */
enum iface_event {
	IF_EVT_NOTHING,
	IF_EVT_UP,
	IF_EVT_DOWN,
	IF_EVT_NEWADDR,
	IF_EVT_DELADDR
};

/* interface actions */
enum iface_action {
	IF_ACT_NOTHING,
	IF_ACT_UPDATE,
	IF_ACT_RST
};
@


1.42
log
@Always accept TCP connection requests and identify to which neighbor
it belongs only _after_ receiving an Initialization message containing
the information we need. Before an Initialization message is received,
the TCP connection shouldn't be associated with any neighbor/adjacency.
Therefor refactor that part into a own module.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.41 2013/06/04 02:28:27 claudio Exp $ */
a246 5
enum blockmodes {
	BM_NORMAL,
	BM_NONBLOCK
};

a356 3

/* control.c */
void	session_socket_blockmode(int, enum blockmodes);
@


1.41
log
@Cleanup ctl commands and remove unused variables inherited from ospfd
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.40 2013/06/04 02:25:28 claudio Exp $ */
d156 1
@


1.40
log
@Implement support for adjacencies and targeted hellos
Refactor adjacencies out of the neighbor handling so that it is possible to
have more complex topologies with targeted sessions.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.39 2013/06/04 00:56:49 claudio Exp $ */
a212 1
	u_int64_t		 baudrate;
a215 1
	int			 session_fd;
a216 1
	int			 mtu;
a222 1
	u_int8_t		 priority;
a317 8
	struct in_addr		 addr;
	struct in_addr		 mask;
	struct in_addr		 rtr_id;
	struct in_addr		 dr_id;
	struct in_addr		 dr_addr;
	struct in_addr		 bdr_id;
	struct in_addr		 bdr_addr;
	time_t			 hello_timer;
a318 1
	u_int64_t		 baudrate;
d321 1
a321 3
	int			 mtu;
	int			 nbr_cnt;
	int			 adj_cnt;
d323 1
a323 1
	u_int16_t		 holdtime;
a327 1
	u_int8_t		 priority;
a340 2
	struct in_addr		 dr;
	struct in_addr		 bdr;
a341 4
	u_int32_t		 db_sum_lst_cnt;
	u_int32_t		 ls_req_lst_cnt;
	u_int32_t		 ls_retrans_lst_cnt;
	u_int32_t		 state_chng_cnt;
a342 2
	u_int8_t		 priority;
	u_int8_t		 options;
@


1.39
log
@Minor adjustments in the initialization FSM
* Remove the unused NBR_EVT_DOWN event;
* Print the FSM transitions before performing the appropriate actions. In
  this way nested calls to nbr_fsm() won't print the state transitions in
  reverse order;
* When playing the active role of the initialization process, transition
  from NBA_STA_PRESENT to NBR_STA_INITIAL before going to NBR_STA_OPENSENT;
* Call session_shutdown() on nbr_ktimeout() to remove duplicated code;
* Notify the lde process when a neighbor is deleted (discovery timeout);
* Fix a few memory leaks on nbr_del().
Diff from Renato Westphal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.38 2013/06/03 17:01:59 claudio Exp $ */
d48 1
d75 1
d145 7
a151 9
#define	NBR_STA_DOWN		0x0001
#define	NBR_STA_PRESENT		0x0002
#define	NBR_STA_INITIAL		0x0004
#define	NBR_STA_OPENREC		0x0008
#define	NBR_STA_OPENSENT	0x0010
#define	NBR_STA_OPER		0x0020
#define	NBR_STA_SESSION		(NBR_STA_PRESENT | NBR_STA_INITIAL | \
				NBR_STA_OPENREC | NBR_STA_OPENSENT | \
				NBR_STA_OPER)
a155 1
	NBR_EVT_HELLO_RCVD,
a167 2
	NBR_ACT_STRT_ITIMER,
	NBR_ACT_RST_ITIMER,
d211 1
d220 1
a220 1
	u_int16_t		 holdtime;
d229 14
d255 5
d269 1
d273 1
d281 1
d286 2
d346 8
a358 1
	time_t			 dead_timer;
@


1.38
log
@Remove the IMSG_NEIGHBOR_CHANGE message
Unlike OSPF, LDP has no concept of intermediate states. A session is
either operational or not operational as far as the label distribution
engine (lde) is concerned. In this case, the IMSG_NEIGHBOR_UP and
IMSG_NEIGHBOR_DOWN messages are enough.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.37 2013/06/03 16:53:49 claudio Exp $ */
a163 1
	NBR_EVT_DOWN
@


1.37
log
@Implement support for multiple addresses per interface.
This replaces the way addresses and interface are chained together.
In ospfd there was a 1 to 1 mapping (with iface clones) but LDP does
not have that limitation.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.36 2013/06/01 19:42:07 claudio Exp $ */
a106 1
	IMSG_NEIGHBOR_CHANGE,
a211 2

	LIST_HEAD(, lde_nbr)	 lde_nbr_list;
@


1.36
log
@Restart the keepalive timer whenever a LDP PDU is sent. There is no need
to send a keepalive packet when a other PDU was sent out.
Also add a missing NBR_EVT_PDU_RCVD call to recv_address() which restarts
the session keepalive timeout. All other places already do that.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.35 2013/06/01 19:28:55 claudio Exp $ */
d85 5
a89 1
	IMSG_IFINFO,
d125 3
a127 1
	IF_EVT_DOWN
d133 1
a133 1
	IF_ACT_STRT,
d202 8
d217 1
a217 3
	struct in_addr		 addr;
	struct in_addr		 dst;
	struct in_addr		 mask;
d258 1
d284 2
a285 2
struct kif_addr {
	TAILQ_ENTRY(kif_addr)	 entry;
d366 1
d376 1
a376 1
struct kif	*kif_findname(char *, struct in_addr, struct kif_addr **);
@


1.35
log
@The keepalive timeout should be configured on a global basis and not per
interface.
Remove the iface pointer from the 'nbr' structure because it's not
needed anymore.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.34 2013/06/01 18:47:07 claudio Exp $ */
d157 1
@


1.34
log
@Drop support for per-interface labelspaces.
Support for per-interface labelspaces is only necessary for legacy ATM/FR
interfaces running in cell-mode. We shouldn't worry about this.
For platform-wide label spaces the label space id is always 0.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.33 2013/06/01 18:35:02 claudio Exp $ */
a213 1
	u_int16_t		 keepalive;
d255 1
a314 1
	char			 name[IF_NAMESIZE];
a325 1
	int			 iface_state;
@


1.33
log
@Drop support for passive interfaces.
Support for passive interfaces was inherited from ospfd but it doesn't
make any sense at all for ldpd.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.32 2013/06/01 18:26:40 claudio Exp $ */
a205 2
	u_int16_t		 lspace_id;

a291 1
	struct in_addr		 lspace;
a319 1
	struct in_addr		 lspace;
a334 1
	struct in_addr		 lspace;
@


1.32
log
@Don't allow enabling LDP on loopback and carp interfaces.
LDP should be allowed only on physical or tunnel interfaces.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.31 2013/06/01 18:16:35 claudio Exp $ */
a222 1
	u_int8_t		 passive;
a314 1
	u_int8_t		 passive;
@


1.31
log
@After returning from accept, we got a TCP connection not a LDP session.
Rename event/actions in the discovery FSM to avoid confusion
* NBR_EVT_SESSION_UP -> NBR_EVT_CONNECT_UP
* NBR_ACT_SESSION_EST -> NBR_ACT_CONNECT_SETUP
* nbr_act_session_establish -> nbr_act_connect_setup
* NBR_ACT_INIT_SEND -> NBR_ACT_PASSIVE_INIT
* NBR_ACT_STRT_KTIMER -> NBR_ACT_SESSION_EST
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.30 2013/05/31 14:11:31 claudio Exp $ */
d114 2
a115 3
#define	IF_STA_LOOPBACK		0x02
#define	IF_STA_ACTIVE		0x04
#define	IF_STA_ANY		0x07
@


1.30
log
@Remove unused definitions
Diff from Renato Westphal [renatowestphal at gmail.com]
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.29 2012/04/12 17:33:43 claudio Exp $ */
d153 1
a153 1
	NBR_EVT_SESSION_UP,
d168 1
a168 1
	NBR_ACT_STRT_KTIMER,
d170 2
a171 2
	NBR_ACT_SESSION_EST,
	NBR_ACT_INIT_SEND,
@


1.29
log
@accept pacing ldpd way. Since this daemon has multiple listening fds
we add them all to a accept queue that does the pacing with the
accept_pause() and accept_unpause() calls.
With and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.28 2011/01/10 12:28:25 claudio Exp $ */
a39 2
#define NBR_HASHSIZE		128

a358 6

/* in_cksum.c */
u_int16_t	 in_cksum(void *, size_t);

/* iso_cksum.c */
u_int16_t	 iso_cksum(void *, u_int16_t, u_int16_t);
@


1.28
log
@Fix a bad heritage from ospfd. Make neighbors independent of interfaces.
They are not bound as strongly as in ospf and causes problems when the
TCP connection is established from an not connected IP (e.g. a loopback).
Use three RB trees to sort the neighbor list by id, addr and peerid.
More cleanup is needed but this makes ldpd work against peers using
loopback IPs. Problem found, reported and fix tested again by Marcel Wiget.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.27 2010/10/07 12:02:23 claudio Exp $ */
d249 1
a249 1
	struct event		disc_ev, sess_ev;
@


1.27
log
@Garbage collect some unused structs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.26 2010/09/02 14:34:04 claudio Exp $ */
a201 1
	LIST_HEAD(, nbr)	 nbr_list;
@


1.26
log
@NBR_STA_SESSION, NBR_STA_UP, and NBR_STA_ACTIVE represent all the same
group of states (all but NBR_STA_DOWN). Clean up this confusion and remove
NBR_STA_UP and NBR_STA_ACTIVE.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.25 2010/09/01 13:54:54 claudio Exp $ */
a353 18
};

struct ctl_sum {
	struct in_addr		 rtr_id;
	u_int32_t		 spf_delay;
	u_int32_t		 spf_hold_time;
	u_int32_t		 num_ext_lsa;
	u_int32_t		 num_lspace;
	time_t			 uptime;
	u_int8_t		 rfc1583compat;
};

struct ctl_sum_lspace {
	struct in_addr		 lspace;
	u_int32_t		 num_iface;
	u_int32_t		 num_adj_nbr;
	u_int32_t		 num_spf_calc;
	u_int32_t		 num_lsa;
@


1.25
log
@s/lfib/fib/ for more consitency with the other routing daemons.
This started manly because of ldpctl beeing inconsistent and me misstyping
lfib almost every time.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.24 2010/07/08 09:41:05 claudio Exp $ */
d147 3
a149 6
#define	NBR_STA_ACTIVE		(~NBR_STA_DOWN)
#define	NBR_STA_SESSION		(NBR_STA_PRESENT | NBR_STA_PRESENT | \
				NBR_STA_INITIAL | NBR_STA_OPENREC | \
				NBR_STA_OPER | NBR_STA_OPENSENT | \
				NBR_STA_ACTIVE)
#define	NBR_STA_UP		(NBR_STA_PRESENT | NBR_STA_SESSION)
@


1.24
log
@Kill more code in kroute.c that is unneeded in ldpd. ldpd is a bit strange
since it does not care that much about reachability of routes. The idea is
to have diverse LSP in the kernel and the kernel should then decide which
path should be used.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.23 2010/06/30 05:21:38 claudio Exp $ */
d49 1
a49 1
#define	LDPD_FLAG_NO_LFIB_UPDATE	0x0001
d78 2
a79 2
	IMSG_CTL_LFIB_COUPLE,
	IMSG_CTL_LFIB_DECOUPLE,
d396 2
a397 2
void		 kr_lfib_couple(void);
void		 kr_lfib_decouple(void);
@


1.23
log
@Kill IMSG_KLABEL_INSERT and all the related functions around it.
IMSG_KLABEL_CHANGE is smart enough to know when something is a change
or an insert.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.22 2010/06/30 01:47:11 claudio Exp $ */
d52 6
a57 8
#define	F_KERNEL		0x0002
#define	F_CONNECTED		0x0004
#define	F_STATIC		0x0008
#define	F_DYNAMIC		0x0010
#define	F_DOWN			0x0020
#define	F_REJECT		0x0040
#define	F_BLACKHOLE		0x0080
#define	F_REDISTRIBUTED		0x0100
a294 1
	u_int8_t		 nh_reachable;	/* for nexthop verification */
@


1.22
log
@Switch prefix in struct map to a struct in_addr instead of a u_int32_t.
Needed for further clean etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.21 2010/05/26 13:56:07 nicm Exp $ */
a86 1
	IMSG_KLABEL_INSERT,
a405 1
int		 kroute_insert_label(struct kroute *);
@


1.21
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.20 2010/05/25 13:29:45 claudio Exp $ */
d187 1
a187 1
	u_int32_t	prefix;
@


1.20
log
@Remove another leftover from ospfd. ldpd does not have a concept of ext_tag
and so there is no need to carry ext_tag and rtlabels around.
"Yes! kill kill kill" michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.19 2010/05/25 09:35:45 claudio Exp $ */
d425 1
a425 1
void	evbuf_enqueue(struct evbuf *, struct buf *);
@


1.19
log
@Add upcomming IMSG_LABEL_RELEASE, IMSG_LABEL_WITHDRAW and IMSG_LABEL_ABORT.
Add missing bits to struct map and restructure/simplify the lde.c imsg
code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.18 2010/05/19 15:28:51 claudio Exp $ */
a277 2
	u_int16_t	rtlabel;
	u_int32_t	ext_tag;
a300 12
/* name2id */
struct n2id_label {
	TAILQ_ENTRY(n2id_label)	 entry;
	char			*name;
	u_int16_t		 id;
	u_int32_t		 ext_tag;
	int			 ref;
};

TAILQ_HEAD(n2id_labels, n2id_label);
extern struct n2id_labels rt_labels;

a416 8

/* name2id.c */
u_int16_t	 rtlabel_name2id(const char *);
const char	*rtlabel_id2name(u_int16_t);
void		 rtlabel_unref(u_int16_t);
u_int32_t	 rtlabel_id2tag(u_int16_t);
u_int16_t	 rtlabel_tag2id(u_int32_t);
void		 rtlabel_tag(u_int16_t, u_int32_t);
@


1.18
log
@Remove yet another ospf leftover that is not needed here. This time
neighbor self and all the madness surrounding this amazing concept.
LDP is not self aware so there is no need for this.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.17 2010/05/14 13:53:51 claudio Exp $ */
d94 3
d190 1
d192 1
d194 3
@


1.17
log
@Order struct element by size.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.16 2010/05/11 15:01:46 claudio Exp $ */
a206 1
	struct nbr		*self;
@


1.16
log
@Kill IMSG_RECONF_AREA. LDP does not have a concept of areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.15 2010/04/29 12:09:28 claudio Exp $ */
d184 1
d186 1
a186 1
	u_int32_t	prefix;
a187 1
	u_int32_t	messageid;
@


1.15
log
@Remove some more ospfd-ism from the interface code. This time remove
of most of the IF_TYPE_ special cases and most interface types.
Point-to-point and broadcast still present because of find_iface()
which needs addtional fixing.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.14 2010/04/15 15:44:37 claudio Exp $ */
a108 1
	IMSG_RECONF_AREA,
@


1.14
log
@Log recieved notifications in a human understanable way. Makes debugging
a bit easier.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.13 2010/04/15 15:39:32 claudio Exp $ */
d138 1
a138 4
	IF_TYPE_BROADCAST,
	IF_TYPE_NBMA,
	IF_TYPE_POINTOMULTIPOINT,
	IF_TYPE_VIRTUALLINK
@


1.13
log
@Cleanup the interface FSM by removing most of the ospfd specific states
that have nothing to do with LDP.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.12 2010/04/15 15:04:23 claudio Exp $ */
d427 1
@


1.12
log
@Instead of having three ways of setting fds non-blocking use
session_socket_blockmode() everywhere.
Additionally make two fatal() distinguishable.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.11 2010/03/03 10:17:05 claudio Exp $ */
d118 2
a119 5
#define	IF_STA_POINTTOPOINT	0x04
#define	IF_STA_DROTHER		0x08
#define	IF_STA_MULTI		(IF_STA_DROTHER | IF_STA_BACKUP | IF_STA_DR)
#define	IF_STA_ANY		0x7f
#define	IF_STA_ACTIVE		(~IF_STA_DOWN)
@


1.11
log
@Rework the kroute code by stealing some code from ospfd and massaging it
a lot more. Main reason for this is to add priority support. Additionally
add some additional NO_LABEL fixes.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.10 2010/02/25 17:40:46 claudio Exp $ */
d243 5
d398 3
@


1.10
log
@Do not use bufferevent for something that's already covered in the imsg
buffer API. This fixes a few possible problems in session_read and does
some further cleanup in various places. Wrap msgbuf into evbuf to add
libevent functionality and use buf_read to handle the read side of a
session.  OK michele@@ and dlg@@ did not see anything evil
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.9 2010/01/02 14:56:02 michele Exp $ */
d53 6
a58 5
#define	F_BGPD_INSERTED		0x0004
#define	F_CONNECTED		0x0008
#define	F_DOWN			0x0010
#define	F_STATIC		0x0020
#define	F_DYNAMIC		0x0040
d277 1
a277 5
};

struct rroute {
	struct kroute	kr;
	u_int32_t	metric;
@


1.9
log
@In the "ldpctl show lib" output print every known label and make clear if it
is currently in use or not.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.8 2009/11/02 20:34:58 claudio Exp $ */
d60 5
d441 4
a444 1

@


1.8
log
@More IMSG_CTL_LOG_VERBOSE, still doing the same toggeling of log_debug().
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.7 2009/09/28 09:48:46 michele Exp $ */
d367 1
@


1.7
log
@When a route is deleted, ldpd should remove labels associated with it from
lfib (the kernel lib) but not from the lib. These could be used later on when
the route come back.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.6 2009/08/02 16:19:17 michele Exp $ */
d80 1
@


1.6
log
@"ldpctl show lib" output cleanup.

- Show only the remote/local labels of the prefixes currently present
in fib.

- Write a "-" instead of "0" when a remote label is not present (the
prefix is directly connected). It avoids confusion with explicit null label.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.5 2009/07/13 19:04:26 michele Exp $ */
a82 1
	IMSG_KROUTE_GET,
@


1.5
log
@Get rid of the multipath code, as it is not needed.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.4 2009/06/06 18:31:42 pyr Exp $ */
d362 2
d366 1
a366 2
	u_int32_t		 local_label;
	u_int32_t		 remote_label;
@


1.4
log
@Get ready for including imsg.h from a lib, when it comes along.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.3 2009/06/06 08:09:43 pyr Exp $ */
d399 1
a399 1
int		 kr_change(struct kroute *, int);
@


1.3
log
@make ldpd imsg-in-a-lib ready too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.2 2009/06/05 22:34:45 michele Exp $ */
d33 1
a33 1
#include "imsg.h"
@


1.2
log
@Correctly send notification messages when errors occur.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpd.h,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d33 1
a44 1
#define	READ_BUF_SIZE		65535
d60 2
a61 30
/* buffer */
struct buf {
	TAILQ_ENTRY(buf)	 entry;
	u_char			*buf;
	size_t			 size;
	size_t			 max;
	size_t			 wpos;
	size_t			 rpos;
};

struct msgbuf {
	TAILQ_HEAD(, buf)	 bufs;
	u_int32_t		 queued;
	int			 fd;
};

#define	IMSG_HEADER_SIZE	sizeof(struct imsg_hdr)
#define	MAX_IMSGSIZE		8192

struct buf_read {
	u_char			 buf[READ_BUF_SIZE];
	u_char			*rptr;
	size_t			 wpos;
};

struct imsgbuf {
	TAILQ_HEAD(, imsg_fd)	fds;
	struct buf_read		r;
	struct msgbuf		w;
	struct event		ev;
d63 3
a65 3
	int			fd;
	pid_t			pid;
	short			events;
a107 12
struct imsg_hdr {
	enum imsg_type	type;
	u_int16_t	len;
	u_int32_t	peerid;
	pid_t		pid;
};

struct imsg {
	struct imsg_hdr	 hdr;
	void		*data;
};

a385 12
/* buffer.c */
struct buf	*buf_open(size_t);
struct buf	*buf_dynamic(size_t, size_t);
int		 buf_add(struct buf *, void *, size_t);
void		*buf_reserve(struct buf *, size_t);
void		*buf_seek(struct buf *, size_t, size_t);
int		 buf_close(struct msgbuf *, struct buf *);
void		 buf_free(struct buf *);
void		 msgbuf_init(struct msgbuf *);
void		 msgbuf_clear(struct msgbuf *);
int		 msgbuf_write(struct msgbuf *);

a389 13
/* imsg.c */
void	 imsg_init(struct imsgbuf *, int, void (*)(int, short, void *));
ssize_t	 imsg_read(struct imsgbuf *);
ssize_t	 imsg_get(struct imsgbuf *, struct imsg *);
int	 imsg_compose(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
	    void *, u_int16_t);
struct buf	*imsg_create(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
		    u_int16_t);
int	 imsg_add(struct buf *, void *, u_int16_t);
int	 imsg_close(struct imsgbuf *, struct buf *);
void	 imsg_free(struct imsg *);
void	 imsg_event_add(struct imsgbuf *); /* needs to be provided externally */

d431 4
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d229 6
@

