head	1.75;
access;
symbols
	OPENBSD_6_2:1.75.0.6
	OPENBSD_6_2_BASE:1.75
	OPENBSD_6_1:1.75.0.4
	OPENBSD_6_1_BASE:1.75
	OPENBSD_6_0:1.67.0.2
	OPENBSD_6_0_BASE:1.67
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.42.0.4
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.31.0.6
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.75
date	2017.03.04.00.21.48;	author renato;	state Exp;
branches;
next	1.74;
commitid	luKtDak9oSLriyOU;

1.74
date	2017.03.04.00.15.35;	author renato;	state Exp;
branches;
next	1.73;
commitid	BOl8emh4A0ljUk3b;

1.73
date	2017.03.04.00.09.17;	author renato;	state Exp;
branches;
next	1.72;
commitid	tAFME29r3wKSl8xr;

1.72
date	2017.03.04.00.06.10;	author renato;	state Exp;
branches;
next	1.71;
commitid	GMDFIgs8eMuH7Rxe;

1.71
date	2017.03.03.23.44.35;	author renato;	state Exp;
branches;
next	1.70;
commitid	mV5MMkodXlL2okSe;

1.70
date	2017.03.03.23.30.57;	author renato;	state Exp;
branches;
next	1.69;
commitid	mvwmKJi9MZW7VKOy;

1.69
date	2016.09.03.16.07.08;	author renato;	state Exp;
branches;
next	1.68;
commitid	fYTaUp1tzXub9AKi;

1.68
date	2016.09.02.17.10.34;	author renato;	state Exp;
branches;
next	1.67;
commitid	azy8IeWn9oiqxwik;

1.67
date	2016.07.16.19.24.30;	author renato;	state Exp;
branches;
next	1.66;
commitid	LXVlFOsFAoTwgzCX;

1.66
date	2016.07.01.23.33.46;	author renato;	state Exp;
branches;
next	1.65;
commitid	o5yBQ1cPVCcMZ7gA;

1.65
date	2016.07.01.23.29.55;	author renato;	state Exp;
branches;
next	1.64;
commitid	OkOx7tFZtmlIlivU;

1.64
date	2016.07.01.23.14.31;	author renato;	state Exp;
branches;
next	1.63;
commitid	DKNC9fIizmSRxKR1;

1.63
date	2016.06.27.19.06.33;	author renato;	state Exp;
branches;
next	1.62;
commitid	OXyvybFBtSb4ppHx;

1.62
date	2016.06.18.17.31.32;	author renato;	state Exp;
branches;
next	1.61;
commitid	Ou0pUplgSHSojMsH;

1.61
date	2016.06.13.23.01.37;	author renato;	state Exp;
branches;
next	1.60;
commitid	6Kn577N67pcmgY5D;

1.60
date	2016.06.13.20.19.40;	author renato;	state Exp;
branches;
next	1.59;
commitid	pBNsEb3sqMOC0tnw;

1.59
date	2016.06.11.01.46.36;	author renato;	state Exp;
branches;
next	1.58;
commitid	u4rx6q4TyXyUJBXY;

1.58
date	2016.06.09.17.26.32;	author renato;	state Exp;
branches;
next	1.57;
commitid	iKrQLOonXcGPkDwb;

1.57
date	2016.05.23.19.20.55;	author renato;	state Exp;
branches;
next	1.56;
commitid	8nGP7z5tJSygyBn7;

1.56
date	2016.05.23.19.16.00;	author renato;	state Exp;
branches;
next	1.55;
commitid	wKGrbgE7dtbu6ic6;

1.55
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.54;
commitid	TLlfi1Pk0Z97z8HM;

1.54
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.53;
commitid	AQBoOveMRKjtVfFv;

1.53
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.52;
commitid	t07H0Mk6WGdVWB0W;

1.52
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.51;
commitid	D7VvXbswyzx5Ahb2;

1.51
date	2016.05.23.18.55.21;	author renato;	state Exp;
branches;
next	1.50;
commitid	85kONxXVWUqI2Jhb;

1.50
date	2016.05.23.18.41.59;	author renato;	state Exp;
branches;
next	1.49;
commitid	zjb4P8L4wSROotP5;

1.49
date	2016.05.23.18.40.15;	author renato;	state Exp;
branches;
next	1.48;
commitid	LYl0nXLaUb8GwBRC;

1.48
date	2016.05.23.18.33.56;	author renato;	state Exp;
branches;
next	1.47;
commitid	YK3Z5X8iSxlfPhoT;

1.47
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.46;
commitid	VpAym8dVR6eY4drQ;

1.46
date	2016.05.23.16.16.44;	author renato;	state Exp;
branches;
next	1.45;
commitid	lsfNt5ZefaCVBrpj;

1.45
date	2016.05.23.15.47.24;	author renato;	state Exp;
branches;
next	1.44;
commitid	Eng7dm0NElMq9Yi3;

1.44
date	2016.05.23.15.43.11;	author renato;	state Exp;
branches;
next	1.43;
commitid	weS0xzAgWBV4f0dh;

1.43
date	2016.05.23.15.41.04;	author renato;	state Exp;
branches;
next	1.42;
commitid	GWVZlQK3ZbMPg5pq;

1.42
date	2015.07.21.05.02.57;	author renato;	state Exp;
branches;
next	1.41;
commitid	HgM2vLtnZjFgxhpg;

1.41
date	2015.07.21.04.58.48;	author renato;	state Exp;
branches;
next	1.40;
commitid	zvZYEuz9wxbvZ2db;

1.40
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.39;
commitid	puLLDX1XPNc3GxB9;

1.39
date	2015.07.21.04.43.28;	author renato;	state Exp;
branches;
next	1.38;
commitid	QaTrdqMa9i0CUoyW;

1.38
date	2015.07.21.04.40.56;	author renato;	state Exp;
branches;
next	1.37;
commitid	aaU19t2dCdAdF6ZH;

1.37
date	2015.07.21.04.39.28;	author renato;	state Exp;
branches;
next	1.36;
commitid	KR83ZYzpLqbp9L95;

1.36
date	2015.07.19.21.01.56;	author renato;	state Exp;
branches;
next	1.35;
commitid	3CZZKtMxWnvDQhpO;

1.35
date	2015.04.04.15.09.47;	author renato;	state Exp;
branches;
next	1.34;
commitid	LIJMvAJU0aJtE45t;

1.34
date	2015.03.21.18.34.01;	author renato;	state Exp;
branches;
next	1.33;
commitid	cFXa8ucj1hCSVYz6;

1.33
date	2015.03.21.18.32.01;	author renato;	state Exp;
branches;
next	1.32;
commitid	Q890u5RO8xyMjkAO;

1.32
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.31;
commitid	2uw1UTO4k6erpWzK;

1.31
date	2013.10.17.17.52.21;	author renato;	state Exp;
branches;
next	1.30;

1.30
date	2013.10.17.17.47.04;	author renato;	state Exp;
branches;
next	1.29;

1.29
date	2013.10.15.20.21.26;	author renato;	state Exp;
branches;
next	1.28;

1.28
date	2013.10.15.20.13.47;	author renato;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.04.02.34.48;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2013.06.04.02.28.27;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2013.06.04.02.25.28;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.04.01.32.16;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2013.06.04.00.56.49;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2013.06.03.16.53.49;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.01.19.28.55;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.01.18.47.07;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.01.18.16.35;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.01.01.34.57;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2013.05.31.14.10.10;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2012.04.12.17.33.43;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.12.01.57.13;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2011.01.10.12.28.25;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2010.11.04.09.52.16;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.26.12.22.35;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.06.08.28.43;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.19.15.28.51;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.14.13.49.09;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.04.15.15.04.23;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.25.17.40.46;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.22.09.44.04;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2010.02.20.21.28.39;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.20.21.05.00;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.22.34.45;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.75
log
@Send VPLS MAC withdrawals.

RFC 4762 says that MAC address withdrawal messages can be used to
improve convergence time in VPLS networks. This patch makes ldpd send
MAC withdrawals whenever a non-pseudowire interface pertaining to a
VPLS goes down. The processing of received MAC withdrawals will be
implemented later.
@
text
@/*	$OpenBSD: ldpe.h,v 1.74 2017/03/04 00:15:35 renato Exp $ */

/*
 * Copyright (c) 2013, 2016 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 * Copyright (c) 2004, 2005, 2008 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _LDPE_H_
#define _LDPE_H_

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <net/pfkeyv2.h>

#include "ldpd.h"

#define min(x,y) ((x) <= (y) ? (x) : (y))
#define max(x,y) ((x) > (y) ? (x) : (y))

struct hello_source {
	enum hello_type		 type;
	struct {
		struct iface_af	*ia;
		union ldpd_addr	 src_addr;
	} link;
	struct tnbr		*target;
};

struct adj {
	LIST_ENTRY(adj)		 global_entry;
	LIST_ENTRY(adj)		 nbr_entry;
	LIST_ENTRY(adj)		 ia_entry;
	struct in_addr		 lsr_id;
	struct nbr		*nbr;
	int			 ds_tlv;
	struct hello_source	 source;
	struct event		 inactivity_timer;
	uint16_t		 holdtime;
	union ldpd_addr		 trans_addr;
};

struct tcp_conn {
	struct nbr		*nbr;
	int			 fd;
	struct ibuf_read	*rbuf;
	struct evbuf		 wbuf;
	struct event		 rev;
};

struct nbr {
	RB_ENTRY(nbr)		 id_tree, addr_tree, pid_tree;
	struct tcp_conn		*tcp;
	LIST_HEAD(, adj)	 adj_list;	/* adjacencies */
	struct event		 ev_connect;
	struct event		 keepalive_timer;
	struct event		 keepalive_timeout;
	struct event		 init_timeout;
	struct event		 initdelay_timer;

	struct mapping_head	 mapping_list;
	struct mapping_head	 withdraw_list;
	struct mapping_head	 request_list;
	struct mapping_head	 release_list;
	struct mapping_head	 abortreq_list;

	uint32_t		 peerid;	/* unique ID in DB */
	int			 af;
	int			 ds_tlv;
	int			 v4_enabled;	/* announce/process v4 msgs */
	int			 v6_enabled;	/* announce/process v6 msgs */
	struct in_addr		 id;		/* lsr id */
	union ldpd_addr		 laddr;		/* local address */
	union ldpd_addr		 raddr;		/* remote address */
	uint32_t		 raddr_scope;	/* remote address scope (v6) */
	time_t			 uptime;
	int			 fd;
	int			 state;
	uint32_t		 conf_seqnum;
	int			 idtimer_cnt;
	uint16_t		 keepalive;
	uint16_t		 max_pdu_len;

	struct {
		uint8_t			established;
		uint32_t		spi_in;
		uint32_t		spi_out;
		enum auth_method	method;
		char			md5key[TCP_MD5_KEY_LEN];
	} auth;
	int			 flags;
};
#define F_NBR_GTSM_NEGOTIATED	 0x01
#define F_NBR_CAP_DYNAMIC	 0x02
#define F_NBR_CAP_TWCARD	 0x04
#define F_NBR_CAP_UNOTIF	 0x08

RB_HEAD(nbr_id_head, nbr);
RB_PROTOTYPE(nbr_id_head, nbr, id_tree, nbr_id_compare)
RB_HEAD(nbr_addr_head, nbr);
RB_PROTOTYPE(nbr_addr_head, nbr, addr_tree, nbr_addr_compare)
RB_HEAD(nbr_pid_head, nbr);
RB_PROTOTYPE(nbr_pid_head, nbr, pid_tree, nbr_pid_compare)

struct pending_conn {
	TAILQ_ENTRY(pending_conn)	 entry;
	int				 fd;
	int				 af;
	union ldpd_addr			 addr;
	struct event			 ev_timeout;
};
#define PENDING_CONN_TIMEOUT	5

struct mapping_entry {
	TAILQ_ENTRY(mapping_entry)	entry;
	struct map			map;
};

struct ldpd_sysdep {
	uint8_t		no_pfkey;
	uint8_t		no_md5sig;
};

extern struct ldpd_conf		*leconf;
extern struct ldpd_sysdep	 sysdep;
extern struct nbr_id_head	 nbrs_by_id;
extern struct nbr_addr_head	 nbrs_by_addr;
extern struct nbr_pid_head	 nbrs_by_pid;

/* accept.c */
void	accept_init(void);
int	accept_add(int, void (*)(int, short, void *), void *);
void	accept_del(int);
void	accept_pause(void);
void	accept_unpause(void);

/* hello.c */
int	 send_hello(enum hello_type, struct iface_af *, struct tnbr *);
void	 recv_hello(struct in_addr, struct ldp_msg *, int, union ldpd_addr *,
	    struct iface *, int, char *, uint16_t);

/* init.c */
void	 send_init(struct nbr *);
int	 recv_init(struct nbr *, char *, uint16_t);
void	 send_capability(struct nbr *, uint16_t, int);
int	 recv_capability(struct nbr *, char *, uint16_t);

/* keepalive.c */
void	 send_keepalive(struct nbr *);
int	 recv_keepalive(struct nbr *, char *, uint16_t);

/* notification.c */
void	 send_notification_full(struct tcp_conn *, struct notify_msg *);
void	 send_notification(struct tcp_conn *, uint32_t, uint32_t, uint16_t);
void	 send_notification_rtlvs(struct nbr *, uint32_t, uint32_t, uint16_t,
	    uint16_t, uint16_t, char *);
int	 recv_notification(struct nbr *, char *, uint16_t);
int	 gen_status_tlv(struct ibuf *, uint32_t, uint32_t, uint16_t);

/* address.c */
void	 send_address_single(struct nbr *, struct if_addr *, int);
void	 send_address_all(struct nbr *, int);
void	 send_mac_withdrawal(struct nbr *, struct map *, uint8_t *);
int	 recv_address(struct nbr *, char *, uint16_t);

/* labelmapping.c */
#define PREFIX_SIZE(x)	(((x) + 7) / 8)
void	 send_labelmessage(struct nbr *, uint16_t, struct mapping_head *);
int	 recv_labelmessage(struct nbr *, char *, uint16_t, uint16_t);
int	 gen_pw_status_tlv(struct ibuf *, uint32_t);
uint16_t len_fec_tlv(struct map *);
int	 gen_fec_tlv(struct ibuf *, struct map *);
int	 tlv_decode_fec_elm(struct nbr *, struct ldp_msg *, char *,
	    uint16_t, struct map *);

/* ldpe.c */
void		 ldpe(int, int, char *);
int		 ldpe_imsg_compose_parent(int, pid_t, void *,
		    uint16_t);
int		 ldpe_imsg_compose_lde(int, uint32_t, pid_t, void *,
		    uint16_t);
void		 ldpe_reset_nbrs(int);
void		 ldpe_reset_ds_nbrs(void);
void		 ldpe_remove_dynamic_tnbrs(int);
void		 ldpe_stop_init_backoff(int);
struct ctl_conn;
void		 ldpe_iface_ctl(struct ctl_conn *, unsigned int);
void		 ldpe_adj_ctl(struct ctl_conn *);
void		 ldpe_nbr_ctl(struct ctl_conn *);
void		 mapping_list_add(struct mapping_head *, struct map *);
void		 mapping_list_clr(struct mapping_head *);

/* interface.c */
struct iface	*if_new(struct kif *);
void		 if_exit(struct iface *);
struct iface	*if_lookup(struct ldpd_conf *, unsigned short);
struct iface_af *iface_af_get(struct iface *, int);
void		 if_addr_add(struct kaddr *);
void		 if_addr_del(struct kaddr *);
void		 if_update(struct iface *, int);
void		 if_update_all(int);
struct ctl_iface *if_to_ctl(struct iface_af *);
in_addr_t	 if_get_ipv4_addr(struct iface *);

/* adjacency.c */
struct adj	*adj_new(struct in_addr, struct hello_source *,
		    union ldpd_addr *);
void		 adj_del(struct adj *, uint32_t);
struct adj	*adj_find(struct hello_source *);
int		 adj_get_af(struct adj *adj);
void		 adj_start_itimer(struct adj *);
void		 adj_stop_itimer(struct adj *);
struct tnbr	*tnbr_new(struct ldpd_conf *, int, union ldpd_addr *);
struct tnbr	*tnbr_find(struct ldpd_conf *, int, union ldpd_addr *);
struct tnbr	*tnbr_check(struct tnbr *);
void		 tnbr_update(struct tnbr *);
void		 tnbr_update_all(int);
struct ctl_adj	*adj_to_ctl(struct adj *);

/* neighbor.c */
int			 nbr_fsm(struct nbr *, enum nbr_event);
struct nbr		*nbr_new(struct in_addr, int, int, union ldpd_addr *,
			    uint32_t);
void			 nbr_del(struct nbr *);
struct nbr		*nbr_find_ldpid(uint32_t);
struct nbr		*nbr_find_addr(int, union ldpd_addr *);
struct nbr		*nbr_find_peerid(uint32_t);
int			 nbr_adj_count(struct nbr *, int);
int			 nbr_session_active_role(struct nbr *);
void			 nbr_stop_ktimer(struct nbr *);
void			 nbr_stop_ktimeout(struct nbr *);
void			 nbr_stop_itimeout(struct nbr *);
void			 nbr_start_idtimer(struct nbr *);
void			 nbr_stop_idtimer(struct nbr *);
int			 nbr_pending_idtimer(struct nbr *);
int			 nbr_pending_connect(struct nbr *);
int			 nbr_establish_connection(struct nbr *);
int			 nbr_gtsm_enabled(struct nbr *, struct nbr_params *);
int			 nbr_gtsm_setup(int, int, struct nbr_params *);
int			 nbr_gtsm_check(int, struct nbr *, struct nbr_params *);
struct nbr_params	*nbr_params_new(struct in_addr);
struct nbr_params	*nbr_params_find(struct ldpd_conf *, struct in_addr);
uint16_t		 nbr_get_keepalive(int, struct in_addr);
struct ctl_nbr		*nbr_to_ctl(struct nbr *);
void			 nbr_clear_ctl(struct ctl_nbr *);

/* packet.c */
int			 gen_ldp_hdr(struct ibuf *, uint16_t);
int			 gen_msg_hdr(struct ibuf *, uint16_t, uint16_t);
int			 send_packet(int, int, union ldpd_addr *,
			    struct iface_af *, void *, size_t);
void			 disc_recv_packet(int, short, void *);
void			 session_accept(int, short, void *);
void			 session_accept_nbr(struct nbr *, int);
void			 session_shutdown(struct nbr *, uint32_t, uint32_t,
			    uint32_t);
void			 session_close(struct nbr *);
struct tcp_conn		*tcp_new(int, struct nbr *);
void			 pending_conn_del(struct pending_conn *);
struct pending_conn	*pending_conn_find(int, union ldpd_addr *);

char	*pkt_ptr;	/* packet buffer */

/* pfkey.c */
int	pfkey_read(int, struct sadb_msg *);
int	pfkey_establish(struct nbr *, struct nbr_params *);
int	pfkey_remove(struct nbr *);
int	pfkey_init(void);

/* l2vpn.c */
void	ldpe_l2vpn_init(struct l2vpn *);
void	ldpe_l2vpn_exit(struct l2vpn *);
void	ldpe_l2vpn_pw_init(struct l2vpn_pw *);
void	ldpe_l2vpn_pw_exit(struct l2vpn_pw *);

#endif	/* _LDPE_H_ */
@


1.74
log
@Implement RFC 5919 (LDP End-of-LIB).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.73 2017/03/04 00:09:17 renato Exp $ */
d176 1
@


1.73
log
@Implement RFC 5918 (Typed Wildcard FEC).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.72 2017/03/04 00:06:10 renato Exp $ */
d109 1
d183 1
@


1.72
log
@Implement RFC 5561 (LDP Capabilities).

This patch per-se doesn't introduce any useful functionality, but prepares
the ground for new enhancements to ldpd (i.e. implementation of new RFCs
that make use of LDP capabilities).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.71 2017/03/03 23:44:35 renato Exp $ */
d108 1
@


1.71
log
@Kill send_notification_nbr().

Be more clever and trigger the PDU SENT event inside send_notification()
when tcp->nbr is set. This way we can eliminate send_notification_nbr()
and always use send_notification() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.70 2017/03/03 23:30:57 renato Exp $ */
d107 1
d156 2
d166 2
@


1.70
log
@Allow to specify an alternate control socket.

This is required to run multiple instances of ldpd.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.69 2016/09/03 16:07:08 renato Exp $ */
d162 1
a162 3
void	 send_notification(uint32_t, struct tcp_conn *, uint32_t,
	    uint16_t);
void	 send_notification_nbr(struct nbr *, uint32_t, uint32_t, uint16_t);
@


1.69
log
@Rework the sending of address messages.

* Respect the session's negotiated maximum pdu length and split the
  sending of our local addresses into multiple messages if necessary;

* Log sent/received addresses;

* Add new wrappers to send only one address (send_address_single)
  and to send all addresses of the given address-family
  (send_address_all). These wrappers create a temporary list of addresses
  to be sent, and send_address() then acts on this last.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.68 2016/09/02 17:10:34 renato Exp $ */
d183 1
a183 1
void		 ldpe(int, int);
@


1.68
log
@lde() and ldpe() should return void.

Remove these leftovers from the pre-fork+exec era.

Spotted by and ok rzalamena@@ ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.67 2016/07/16 19:24:30 renato Exp $ */
d169 2
a170 1
void	 send_address(struct nbr *, int, struct if_addr *, int);
@


1.67
log
@Remove potential overflow when validating message's length.

Also, use uint16_t for msg_type on gen_msg_hdr().
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.66 2016/07/01 23:33:46 renato Exp $ */
d182 1
a182 1
pid_t		 ldpe(int, int);
@


1.66
log
@Be more compliant with RFC 4447.

When sending a label withdraw during the pseudowire Control Word
negotiation, append a "Wrong C-bit" status TLV after the FEC TLV (in
conformance to RFC 4447 section 6.2). Apparently this has no use other
than aiding in troubleshooting.

Also, extend the recv_labelmessage() function to accept Status TLVs and
ignore them instead of shutting down the session.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.65 2016/07/01 23:29:55 renato Exp $ */
d254 1
a254 1
int			 gen_msg_hdr(struct ibuf *, uint32_t, uint16_t);
@


1.65
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.64 2016/07/01 23:14:31 renato Exp $ */
d166 1
@


1.64
log
@Add GTSM support (RFC 6720).

This also finishes the missing bits from our RFC 7552 implementation
because GTSM is mandatory for LDPv6.

To avoid any kind of interoperability problems, I included a few
knobs to enable/disable GTSM on a per-address-family and per-neighbor
basis. Cisco's LDPv6 implementation, for instance, doesn't support GTSM.

"reads good" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.63 2016/06/27 19:06:33 renato Exp $ */
d199 1
a199 1
void		 if_del(struct iface *);
@


1.63
log
@Handle ibuf_add() errors.

tweaks from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.62 2016/06/18 17:31:32 renato Exp $ */
d104 1
d106 2
d242 3
@


1.62
log
@Fix removal of dual-stack neighbors.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.61 2016/06/13 23:01:37 renato Exp $ */
d172 2
a173 2
void	 gen_pw_status_tlv(struct ibuf *, uint32_t);
void	 gen_fec_tlv(struct ibuf *, struct map *);
@


1.61
log
@Implement support for the Configuration Sequence Number TLV.

The Configuration Sequence Number optional TLV is documented in RFC 5036,
pages 53 and 54.

Fixes IxANVL LDP test 23.10.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.60 2016/06/13 20:19:40 renato Exp $ */
d209 1
a209 1
void		 adj_del(struct adj *, int, uint32_t);
@


1.60
log
@Implement a timeout for the session initialization FSM.

This prevents neighbors stuck in the initialization FSM to linger forever
as long as the associated transport connection is up.

This timeout can be seen in the 'Session Initialization State Transition
Diagram' of RFC 5036. The RFC, however, doesn't specify how much we
should wait. Let's use 180 seconds for that, the default LDP hold time.

Fixes IxANVL LDP test 6.15.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.59 2016/06/11 01:46:36 renato Exp $ */
d92 1
@


1.59
log
@Use uint16_t for notification type.

This doesn't fix any bug as we were already using uint16_t everywhere
else.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.58 2016/06/09 17:26:32 renato Exp $ */
d71 1
d232 1
@


1.58
log
@Send a fatal notification when the last hello adjacency is deleted.

RFC 5036 says:
  "When the last Hello adjacency for an LDP session is
  deleted, the LSR terminates the LDP session by sending a Notification
  message and closing the transport connection".

Send a "Hold Timer Expired" notification when the triggering event is
a hello hold time timeout. In the other cases, like disabling LDP on an
interface, send a "Shutdown" notification instead.

Before this patch we were just closing the neighbor's transport
connection.

Fixes the following ANVL LDP tests: 7.17 and 23.3.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.57 2016/05/23 19:20:55 renato Exp $ */
d158 2
a159 2
	    uint32_t);
void	 send_notification_nbr(struct nbr *, uint32_t, uint32_t, uint32_t);
@


1.57
log
@Add support for manually resetting neighbors.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.56 2016/05/23 19:16:00 renato Exp $ */
d207 1
a207 1
void		 adj_del(struct adj *);
@


1.56
log
@Improve security by calling exec after fork.

For each child process (lde and ldpe), re-exec ldpd with a special
"per-role" getopt flag. This way we have seperate ASLR/cookies per
process.

Based on a similar patch for bgpd, from claudio@@

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.55 2016/05/23 19:14:03 renato Exp $ */
d240 1
@


1.55
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.54 2016/05/23 19:11:42 renato Exp $ */
d176 1
a176 1
pid_t		 ldpe(struct ldpd_conf *, int[2], int[2], int[2]);
@


1.54
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.53 2016/05/23 19:09:25 renato Exp $ */
d4 2
@


1.53
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.52 2016/05/23 18:58:48 renato Exp $ */
d22 7
a30 6

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <net/pfkeyv2.h>
@


1.52
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.51 2016/05/23 18:55:21 renato Exp $ */
d100 6
d126 6
d153 1
a153 1
void	 send_notification_nbr(struct nbr *, uint32_t, uint32_t, uint32_t);
d156 1
a156 1
void	 send_notification_full(struct tcp_conn *, struct notify_msg *);
d167 1
a168 1
void	 gen_pw_status_tlv(struct ibuf *, uint32_t);
a177 5
void		 ldpe_dispatch_main(int, short, void *);
void		 ldpe_dispatch_lde(int, short, void *);
void		 ldpe_dispatch_pfkey(int, short, void *);
void		 ldpe_setup_sockets(int, int, int, int);
void		 ldpe_close_sockets(int);
a182 1
void		 ldpe_iface_af_ctl(struct ctl_conn *, int, unsigned int);
a189 6
int		 if_start(struct iface *, int);
int		 if_reset(struct iface *, int);
void		 if_update_af(struct iface_af *, int);
void		 if_update(struct iface *, int);
void		 if_update_all(int);

a193 2
struct if_addr	*if_addr_new(struct kaddr *);
struct if_addr	*if_addr_lookup(struct if_addr_head *, struct kaddr *);
d196 3
a198 3

struct ctl_iface 	*if_to_ctl(struct iface_af *);

a199 4
int		 if_join_ipv4_group(struct iface *, struct in_addr *);
int		 if_leave_ipv4_group(struct iface *, struct in_addr *);
int		 if_join_ipv6_group(struct iface *, struct in6_addr *);
int		 if_leave_ipv6_group(struct iface *, struct in6_addr *);
d203 1
a203 1
    union ldpd_addr *);
a209 1
void		 tnbr_del(struct tnbr *);
a213 1

d217 16
a232 26
struct nbr	*nbr_new(struct in_addr, int, int, union ldpd_addr *, uint32_t);
void		 nbr_del(struct nbr *);
void		 nbr_update_peerid(struct nbr *);

struct nbr	*nbr_find_ldpid(uint32_t);
struct nbr	*nbr_find_addr(int, union ldpd_addr *);
struct nbr	*nbr_find_peerid(uint32_t);
int		 nbr_adj_count(struct nbr *, int);

int	 nbr_fsm(struct nbr *, enum nbr_event);
int	 nbr_session_active_role(struct nbr *);

void	 nbr_ktimer(int, short, void *);
void	 nbr_start_ktimer(struct nbr *);
void	 nbr_stop_ktimer(struct nbr *);
void	 nbr_ktimeout(int, short, void *);
void	 nbr_start_ktimeout(struct nbr *);
void	 nbr_stop_ktimeout(struct nbr *);
void	 nbr_idtimer(int, short, void *);
void	 nbr_start_idtimer(struct nbr *);
void	 nbr_stop_idtimer(struct nbr *);
int	 nbr_pending_idtimer(struct nbr *);
int	 nbr_pending_connect(struct nbr *);
int	 nbr_establish_connection(struct nbr *);

uint16_t		 nbr_get_keepalive(int, struct in_addr);
d235 2
a236 9

struct ctl_nbr	*nbr_to_ctl(struct nbr *);

extern struct nbr_id_head	nbrs_by_id;
RB_PROTOTYPE(nbr_id_head, nbr, id_tree, nbr_id_compare)
extern struct nbr_addr_head	nbrs_by_addr;
RB_PROTOTYPE(nbr_addr_head, nbr, addr_tree, nbr_addr_compare)
extern struct nbr_pid_head	nbrs_by_pid;
RB_PROTOTYPE(nbr_pid_head, nbr, pid_tree, nbr_pid_compare)
d239 10
a248 12
int	 gen_ldp_hdr(struct ibuf *, uint16_t);
int	 gen_msg_hdr(struct ibuf *, uint32_t, uint16_t);
int	 send_packet(int, int, union ldpd_addr *, struct iface_af *, void *,
	    size_t);
void	 disc_recv_packet(int, short, void *);
void	 session_accept(int, short, void *);
void	 session_accept_nbr(struct nbr *, int);
void	 session_read(int, short, void *);
void	 session_write(int, short, void *);
void	 session_close(struct nbr *);
void	 session_shutdown(struct nbr *, uint32_t, uint32_t, uint32_t);

a249 2
void			 tcp_close(struct tcp_conn *);
struct pending_conn	*pending_conn_new(int, int, union ldpd_addr *);
a251 1
void			 pending_conn_timeout(int, short, void *);
d259 1
a259 1
int	pfkey_init(struct ldpd_sysdep *);
@


1.51
log
@Assorted fixes and small cleanup.

Nothing really interesting here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.50 2016/05/23 18:41:59 renato Exp $ */
d34 3
a36 3
		struct iface	*iface;
		struct in_addr	 src_addr;
	}			 link;
d41 1
d43 2
a44 1
	LIST_ENTRY(adj)		 iface_entry;
d46 1
d50 1
a50 1
	struct in_addr		 addr;
a52 1
struct nbr;
d76 5
a80 2
	struct in_addr		 laddr;		/* local address */
	struct in_addr		 raddr;		/* remote address */
d82 3
a84 1

a85 2
	uint32_t		 peerid;	/* unique ID in DB */

d104 2
a105 1
	struct in_addr			 addr;
d128 2
a129 2
int	 send_hello(enum hello_type, struct iface *, struct tnbr *);
void	 recv_hello(struct in_addr, struct ldp_msg *, struct in_addr,
d148 1
a148 1
void	 send_address(struct nbr *, struct if_addr *, int);
d162 2
a163 1
int		 ldpe_imsg_compose_parent(int, pid_t, void *, uint16_t);
d169 6
a174 5
void		 ldpe_setup_sockets(int, int, int);
void		 ldpe_close_sockets(void);
void		 ldpe_reset_nbrs(void);
void		 ldpe_remove_dynamic_tnbrs(void);
void		 ldpe_stop_init_backoff(void);
d176 1
d184 5
a188 4
int		 if_start(struct iface *);
int		 if_reset(struct iface *);
int		 if_update(struct iface *);
void		 if_update_all(void);
d193 1
d199 1
a199 1
struct ctl_iface	*if_to_ctl(struct iface *);
d201 5
a205 2
int	 if_join_group(struct iface *, struct in_addr *);
int	 if_leave_group(struct iface *, struct in_addr *);
d208 2
a209 1
struct adj	*adj_new(struct nbr *, struct hello_source *, struct in_addr);
d211 2
a212 1
struct adj	*adj_find(struct nbr *, struct hello_source *);
d215 1
a215 1
struct tnbr	*tnbr_new(struct ldpd_conf *, struct in_addr);
d217 1
a217 1
struct tnbr	*tnbr_find(struct ldpd_conf *, struct in_addr);
d220 1
a220 1
void		 tnbr_update_all(void);
d225 1
a225 1
struct nbr	*nbr_new(struct in_addr, struct in_addr);
d230 1
a230 1
struct nbr	*nbr_find_addr(struct in_addr);
d232 1
d250 1
a250 1
uint16_t		 nbr_get_keepalive(struct in_addr);
d266 2
a267 1
int	 send_packet(int, struct iface *, void *, size_t, struct sockaddr_in *);
d278 1
a278 1
struct pending_conn	*pending_conn_new(int, struct in_addr);
d280 1
a280 1
struct pending_conn	*pending_conn_find(struct in_addr);
@


1.50
log
@Enable changing the router-id via config reload.

Now ldpd can start without a router-id, since it can be set later. Since
a router-id of 0.0.0.0 is invalid, interfaces and targeted-neighbors
will check for a valid router-id in order to be activated.

When the router-id is changed, all the neighborships are reset.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.49 2016/05/23 18:40:15 renato Exp $ */
a30 2
TAILQ_HEAD(ctl_conns, ctl_conn)	ctl_conns;

d167 1
@


1.49
log
@Several fixes in the config reload handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.48 2016/05/23 18:33:56 renato Exp $ */
d166 1
@


1.48
log
@Create network sockets on the parent process.

We drop our privileges in ldpe right after we create the network sockets.
The problem is that we might want to change the transport-address and
reload the config, in which case we need new sockets. To allow that,
always create the network sockets in the parent process and pass them
to ldpe via imsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.47 2016/05/23 17:43:42 renato Exp $ */
d166 2
@


1.47
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d158 3
d164 2
a165 3
int		 ldpe_imsg_compose_parent(int, pid_t, void *, uint16_t);
int		 ldpe_imsg_compose_lde(int, uint32_t, pid_t, void *,
		     uint16_t);
d176 1
a179 1
void		 if_init(struct iface *);
d199 1
d201 2
a202 2
void		 tnbr_init(struct tnbr *);
struct tnbr	*tnbr_find(struct ldpd_conf *, struct in_addr);
@


1.46
log
@Rework the way we handle income connection requests.

The logic of the previous code was to accept all TCP connection requests
(destined to port 646) and create a tcp_conn structure for each them. Once
the first packet of a connection was received, we would analyze the
LDP Initialization message and identify its origin by looking at the
LSR-ID field.

When parsing a received TCP packet, we would need to distinguish between
two cases: tcp packet from an LDP neighbor and tcp packet from a newborn
connection (not associated with any neighbor yet). For this reason,
the session_read() function was quite complicated.

Also, we were not keeping track of the allocated tcp_conn structures. So,
we were subject to memory leaks and even DOS attacks.

With this patch, we also accept all TCP connection requests, but with two
major differences:
* We identify the neighbor by the source address of the SYN
  packet. This is possible because we don't support label spaces, so
  the transport-address by itself is enough to identify a neighbor,
  we don't need to wait for the Initialization message;
* If there's no matching adjacency for this neighbor, then we start a
  timer of 5 seconds. If we receive a Hello packet from this neighbor
  within this interval, then we stop this timer and move on in
  the Initialization state machine. Otherwise, we send a No Hello
  Notification message and close the socket. We try to avoid sending
  the No Hello notification as much as possible because it triggers the
  backoff exponential in the remote peer, which considerably slow down
  the session establishment process.

In summary, this new approach allows for a simpler code and fixes the
memory leak problem mentioned before.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.45 2016/05/23 15:47:24 renato Exp $ */
d48 1
a48 1
	u_int16_t		 holdtime;
d81 1
a81 1
	u_int32_t		 peerid;	/* unique ID in DB */
d86 2
a87 1
	u_int16_t		 keepalive;
d90 3
a92 4
		u_int8_t		established;
		struct in_addr		local_addr;
		u_int32_t		spi_in;
		u_int32_t		spi_out;
d112 2
a113 2
	u_int8_t		no_pfkey;
	u_int8_t		no_md5sig;
d125 2
a126 1
void	 recv_hello(struct iface *,  struct in_addr, char *, u_int16_t);
d130 1
a130 1
int	 recv_init(struct nbr *, char *, u_int16_t);
d134 1
a134 1
int	 recv_keepalive(struct nbr *, char *, u_int16_t);
d137 3
a139 3
void	 send_notification_nbr(struct nbr *, u_int32_t, u_int32_t, u_int32_t);
void	 send_notification(u_int32_t, struct tcp_conn *, u_int32_t,
	    u_int32_t);
d141 1
a141 1
int	 recv_notification(struct nbr *, char *, u_int16_t);
d144 2
a145 3
void	 send_address(struct nbr *, struct if_addr *);
int	 recv_address(struct nbr *, char *, u_int16_t);
void	 send_address_withdraw(struct nbr *, struct if_addr *);
d149 2
a150 2
void	 send_labelmessage(struct nbr *, u_int16_t, struct mapping_head *);
int	 recv_labelmessage(struct nbr *, char *, u_int16_t, u_int16_t);
d152 1
a152 1
void	 gen_pw_status_tlv(struct ibuf *, u_int32_t);
d154 1
a154 1
    u_int16_t, struct map *);
d161 6
a166 4
int		 ldpe_imsg_compose_parent(int, pid_t, void *, u_int16_t);
int		 ldpe_imsg_compose_lde(int, u_int32_t, pid_t, void *,
		     u_int16_t);
u_int32_t	 ldpe_router_id(void);
a168 1
void		 ldpe_iface_ctl(struct ctl_conn *, unsigned int);
d177 2
a178 2
void		 if_init(struct ldpd_conf *, struct iface *);
struct iface	*if_lookup(struct ldpd_conf *, u_short);
a187 7
int	 if_set_mcast(struct iface *);
int	 if_set_recvif(int, int);
void	 if_set_recvbuf(int);
int	 if_set_mcast_loop(int);
int	 if_set_mcast_ttl(int, u_int8_t);
int	 if_set_tos(int, int);
int	 if_set_reuse(int, int);
d198 1
a198 1
void		 tnbr_init(struct ldpd_conf *, struct tnbr *);
d208 3
a210 2
struct nbr	*nbr_find_ldpid(u_int32_t);
struct nbr	*nbr_find_peerid(u_int32_t);
d242 2
a243 2
int	 gen_ldp_hdr(struct ibuf *, u_int16_t);
int	 gen_msg_tlv(struct ibuf *, u_int32_t, u_int16_t);
d247 1
a247 4

struct tcp_conn *tcp_new(int, struct nbr *);
void		 tcp_close(struct tcp_conn *);

d251 8
a258 1
void	 session_shutdown(struct nbr *, u_int32_t, u_int32_t, u_int32_t);
@


1.45
log
@Move some code around.

This patch doesn't introduce any logical change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.44 2016/05/23 15:43:11 renato Exp $ */
d62 1
a62 1
	RB_ENTRY(nbr)		 id_tree, pid_tree;
d98 8
d241 2
@


1.44
log
@Add knob to configure the transport address.

This will be especially important when we add support for IPv6, because
we'll not be able to use the router-id as the transport-address in
this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.43 2016/05/23 15:41:04 renato Exp $ */
d172 2
a199 1
void		 ldpe_adj_ctl(struct ctl_conn *);
d230 5
a234 1
void		 ldpe_nbr_ctl(struct ctl_conn *);
@


1.43
log
@Allow setting the session holdtime per neighbor.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.42 2015/07/21 05:02:57 renato Exp $ */
d76 3
a78 2
	struct in_addr		 addr;
	struct in_addr		 id;
@


1.42
log
@Rename, move and reuse mapping list functions.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.41 2015/07/21 04:58:48 renato Exp $ */
d223 1
@


1.41
log
@Fix some awful ipc synchronization issues.

Under some rare circumstances the following can happen:
1 - one neighbor sends a label withdraw followed by a fatal notification
    message;
2 - ldpe parses the label withdraw and sends it to lde;
3 - ldpe parses the fatal notification message and closes the session;
4 - lde processes the label withdraw and asks ldpe to send a label release;
5 - at around the same time, ldpe restarts the session with the neighbor;
6 - ldpe processes the lde message and then sends a label release to the new
    neighbor.

The problem is that we don't want a message enqueue to a neighbor to be sent
after the session is restarted. If a session is closed, all the enqueued
messages should be discarded.

To acomplish this, we update the peerid of the nbr structure everytime the
session is established.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.40 2015/07/21 04:52:29 renato Exp $ */
d156 2
a157 1
void		 ldpe_fib_update(int);
a220 1

a221 5

void			 nbr_mapping_add(struct nbr *, struct mapping_head *,
			    struct map *);
void			 mapping_list_clr(struct mapping_head *);

@


1.40
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.39 2015/07/21 04:43:28 renato Exp $ */
d201 1
@


1.39
log
@Add configuration reload support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.38 2015/07/21 04:40:56 renato Exp $ */
d130 1
d142 4
d255 6
@


1.38
log
@Assorted fixes and code cleanup for targeted neighbors.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.37 2015/07/21 04:39:28 renato Exp $ */
d162 1
a162 1
struct iface	*if_lookup(u_short);
d188 1
a188 1
struct tnbr	*tnbr_find(struct in_addr);
d223 1
a223 1
struct nbr_params	*nbr_params_find(struct in_addr);
@


1.37
log
@Improve handling of addresses on ldpe.

This is a preliminary work for the the next patch (sigup config
reload). We want to make sure that the ldpe process can handle duplicated
addresses.

The idea is to alloc two different if_addr structures for each address,
and link one in the global list of addresses (used to send address
messages) and link the other to the associated interface list of
addresses.

Doing that we will be able to call kif_redistribute() after reloading
the config file and activate the new LDP enabled interfaces.

NOTE: Interfaces are created at config parse time and the child
processes inherit them on fork() so there's no need to send a status
update at startup.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.36 2015/07/19 21:01:56 renato Exp $ */
d184 1
a184 1
struct tnbr	*tnbr_new(struct ldpd_conf *, struct in_addr, int);
d186 1
@


1.36
log
@Implement md5 authentication support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.35 2015/04/04 15:09:47 renato Exp $ */
d163 2
@


1.35
log
@Remove unused parameter from adj_new().

The adjacency holdtime is set in recv_hello().

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.34 2015/03/21 18:34:01 renato Exp $ */
d29 1
d86 9
d102 5
d146 1
d218 4
d241 6
@


1.34
log
@Remove unused variables and functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.33 2015/03/21 18:32:01 renato Exp $ */
d161 1
a161 2
struct adj	*adj_new(struct nbr *, struct hello_source *, u_int16_t,
    struct in_addr);
@


1.33
log
@Remove interface finite state machine.

In the name of simplicity, remove the interface FSM that was inherited
from ospfd. In ldpd interfaces are just up or down, so keeping a
FSM for that is an overkill. Now instead of calling if_fsm(), just
call if_update() whenever a relevant event occurs (status change,
address addition/removal).

Additional notes:
1 - s/if_act_/if_/

2 - Remove the IMSG_IFUP and IMSG_IFDOWN events. Now whenever an
interface changes its state a IMSG_IFSTATUS event will be generated
with the new status.

kroute.c ldpd.h ldpe.c ldpe.h CVS:
----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.32 2014/10/25 03:23:49 lteo Exp $ */
a199 4
			    struct map *);
struct mapping_entry	*nbr_mapping_find(struct nbr *, struct mapping_head *,
			    struct map *);
void			 nbr_mapping_del(struct nbr *, struct mapping_head *,
@


1.32
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.31 2013/10/17 17:52:21 renato Exp $ */
d139 3
a141 1
int		 if_fsm(struct iface *, enum iface_event);
@


1.31
log
@Respect the max pdu length and merge all send_label* functions into
a single generic function.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.30 2013/10/17 17:47:04 renato Exp $ */
a27 1
#include <netinet/in_systm.h>
@


1.30
log
@Improve parsing of label mapping messages and merge all recv_label*
functions into a single generic function.

Add a few error checks and implement parsing of optional tlvs.
Putting it all together helps avoid to code duplication and improve
maintainability.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.29 2013/10/15 20:21:26 renato Exp $ */
d125 1
a126 5
void	 send_labelmapping(struct nbr *);
void	 send_labelrequest(struct nbr *);
void	 send_labelwithdraw(struct nbr *);
void	 send_labelrelease(struct nbr *);
void	 send_labelabortreq(struct nbr *);
@


1.29
log
@Fix whitespace and other style issues.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.28 2013/10/15 20:13:47 renato Exp $ */
d125 1
a126 1
int	 recv_labelmapping(struct nbr *, char *, u_int16_t);
a127 1
int	 recv_labelrequest(struct nbr *, char *, u_int16_t);
a128 1
int	 recv_labelwithdraw(struct nbr *, char *, u_int16_t);
a129 1
int	 recv_labelrelease(struct nbr *, char *, u_int16_t);
a130 1
int	 recv_labelabortreq(struct nbr *, char *, u_int16_t);
d208 1
a208 2
void			 nbr_mapping_list_clr(struct nbr *,
			    struct mapping_head *);
@


1.28
log
@Since a targeted neighbor can be created both by configuration and
on runtime, the ldpd_conf structure used should be passed as an
argument to avoid segfaults.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.27 2013/06/04 02:34:48 claudio Exp $ */
d22 1
a226 1

@


1.27
log
@Always accept TCP connection requests and identify to which neighbor
it belongs only _after_ receiving an Initialization message containing
the information we need. Before an Initialization message is received,
the TCP connection shouldn't be associated with any neighbor/adjacency.
Therefor refactor that part into a own module.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.26 2013/06/04 02:28:27 claudio Exp $ */
d173 1
a173 1
struct tnbr	*tnbr_new(struct in_addr, int);
@


1.26
log
@Cleanup ctl commands and remove unused variables inherited from ospfd
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.25 2013/06/04 02:25:28 claudio Exp $ */
d51 5
a55 2
struct nbr {
	RB_ENTRY(nbr)		 id_tree, addr_tree, pid_tree;
d58 5
a77 2
	struct ibuf_read	*rbuf;

a83 1

d113 2
a114 1
struct ibuf	*send_notification(u_int32_t, u_int32_t, u_int32_t);
a184 1
struct nbr	*nbr_find_ip(u_int32_t);
a203 1
void	 nbr_act_connect_setup(struct nbr *);
d223 4
@


1.25
log
@Implement support for adjacencies and targeted hellos
Refactor adjacencies out of the neighbor handling so that it is possible to
have more complex topologies with targeted sessions.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.24 2013/06/04 01:32:16 claudio Exp $ */
a79 5

	u_int8_t		 priority;
	u_int8_t		 options;

	u_int8_t		 flags;
@


1.24
log
@Properly implement the exponential backoff timer on session initialization

According with the section 2.5.3 of RFC 5036, an LSR must throttle its
session setup retry attempts with an exponential backoff in situations
where Initialization messages are being NAK'd (because of disagreements
on session parameters). It doesn't mention using this procedure for TCP
connection failures. With that said, start the inactive delay timer only
after receiving an appropriate notification message.

When playing the active role of the initialization process, throttle the
session setup retry attempts by not connecting to the remote peer. When
playing the passive role, throttle the session setup retry attempts by
delaying the processing of the received Initialization message.

Diff by Renato Westphal, adjusted by myself
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.23 2013/06/04 00:56:49 claudio Exp $ */
d32 17
a48 3
struct mapping_entry {
	TAILQ_ENTRY(mapping_entry)	entry;
	struct map			map;
d55 1
a56 1
	struct event		 inactivity_timer;
a78 1
	u_int16_t		 holdtime;
d85 1
a85 1
	u_int8_t		 hello_type;
d87 3
d100 1
a100 1
int	 send_hello(struct iface *);
d165 15
a190 3
void	 nbr_itimer(int, short, void *);
void	 nbr_start_itimer(struct nbr *);
void	 nbr_stop_itimer(struct nbr *);
d221 1
a221 1
int	 send_packet(struct iface *, void *, size_t, struct sockaddr_in *);
@


1.23
log
@Minor adjustments in the initialization FSM
* Remove the unused NBR_EVT_DOWN event;
* Print the FSM transitions before performing the appropriate actions. In
  this way nested calls to nbr_fsm() won't print the state transitions in
  reverse order;
* When playing the active role of the initialization process, transition
  from NBA_STA_PRESENT to NBR_STA_INITIAL before going to NBR_STA_OPENSENT;
* Call session_shutdown() on nbr_ktimeout() to remove duplicated code;
* Notify the lde process when a neighbor is deleted (discovery timeout);
* Fix a few memory leaks on nbr_del().
Diff from Renato Westphal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.22 2013/06/03 16:53:49 claudio Exp $ */
d63 1
@


1.22
log
@Implement support for multiple addresses per interface.
This replaces the way addresses and interface are chained together.
In ospfd there was a 1 to 1 mapping (with iface clones) but LDP does
not have that limitation.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.21 2013/06/01 19:28:55 claudio Exp $ */
d149 1
a149 1
struct nbr	*nbr_new(u_int32_t, struct in_addr);
d175 1
a175 1
int	 nbr_act_connect_setup(struct nbr *, int);
@


1.21
log
@The keepalive timeout should be configured on a global basis and not per
interface.
Remove the iface pointer from the 'nbr' structure because it's not
needed anymore.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.20 2013/06/01 18:47:07 claudio Exp $ */
d100 1
a100 1
void	 send_address(struct nbr *, struct iface *);
d102 1
a102 1
void	 send_address_withdraw(struct nbr *, struct iface *);
d131 1
a131 1
struct iface	*if_new(struct kif *, struct kif_addr *);
d134 1
a134 3

int		 if_act_start(struct iface *);
int		 if_act_reset(struct iface *);
@


1.20
log
@Drop support for per-interface labelspaces.
Support for per-interface labelspaces is only necessary for legacy ATM/FR
interfaces running in cell-mode. We shouldn't worry about this.
For platform-wide label spaces the label space id is always 0.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.19 2013/06/01 18:16:35 claudio Exp $ */
a56 1
	struct iface		*iface;
d151 1
a151 1
struct nbr	*nbr_new(u_int32_t, struct iface *, struct in_addr);
@


1.19
log
@After returning from accept, we got a TCP connection not a LDP session.
Rename event/actions in the discovery FSM to avoid confusion
* NBR_EVT_SESSION_UP -> NBR_EVT_CONNECT_UP
* NBR_ACT_SESSION_EST -> NBR_ACT_CONNECT_SETUP
* nbr_act_session_establish -> nbr_act_connect_setup
* NBR_ACT_INIT_SEND -> NBR_ACT_PASSIVE_INIT
* NBR_ACT_STRT_KTIMER -> NBR_ACT_SESSION_EST
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.18 2013/06/01 01:34:57 claudio Exp $ */
a64 1
	u_int16_t		 lspace;
d97 1
a97 2
struct ibuf	*send_notification(u_int32_t, struct iface *, u_int32_t,
	    u_int32_t);
d152 1
a152 1
struct nbr	*nbr_new(u_int32_t, u_int16_t, struct iface *, struct in_addr);
d156 1
a156 1
struct nbr	*nbr_find_ldpid(u_int32_t, u_int16_t);
d193 1
a193 1
int	 gen_ldp_hdr(struct ibuf *, struct iface *, u_int16_t);
@


1.18
log
@Always advertise the Router-ID as the transport address.
RFC 5036 - Section 2.5.2 says:
    An LSR MUST advertise the same transport address in all
    Hellos that advertise the same label space...
To satisfy this condition, always advertise the Router-ID as the
transport address by using the "IPv4 Transport Address" TLV in the
generated Hello messages.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.17 2013/05/31 14:10:10 claudio Exp $ */
d180 1
a180 1
int	 nbr_act_session_establish(struct nbr *, int);
@


1.17
log
@When the ldpe process calls connect(), it doesn't regain control until
either the connection is made or an error occurs. The time the process
is blocked can be significantly large to the point of other LDP sessions
being torn down because of their holdtime. Besides that, the ldpctl
program gets unresponsive if the ldpe process is blocked. Fix these
issues by using a non-blocking connect.
Diff from Renato Westphal [renatowestphal at gmail.com]
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.16 2012/04/12 17:33:43 claudio Exp $ */
d162 1
@


1.16
log
@accept pacing ldpd way. Since this daemon has multiple listening fds
we add them all to a accept queue that does the pacing with the
accept_pause() and accept_unpause() calls.
With and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.15 2011/03/12 01:57:13 claudio Exp $ */
d41 1
d176 1
d178 1
@


1.15
log
@Bad bad Claudio. Fix an evil bug that caused nbr addr_tree corruption.
Do not insert neighbors first to the address tree and then assign the
address to the struct. Instead pass the address to nbr_new() so all
keys for the various RB trees are available when setting the neighbor up.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.14 2011/01/10 12:28:25 claudio Exp $ */
d75 7
@


1.14
log
@Fix a bad heritage from ospfd. Make neighbors independent of interfaces.
They are not bound as strongly as in ospf and causes problems when the
TCP connection is established from an not connected IP (e.g. a loopback).
Use three RB trees to sort the neighbor list by id, addr and peerid.
More cleanup is needed but this makes ldpd work against peers using
loopback IPs. Problem found, reported and fix tested again by Marcel Wiget.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.13 2010/11/04 09:52:16 claudio Exp $ */
d146 1
a146 1
struct nbr	*nbr_new(u_int32_t, u_int16_t, struct iface *);
@


1.13
log
@Rewrite all packet parsers to be more careful about alignment. Until
now ldpd had no chance to run on a strict alignment architecture but
this makes ldpd happy on sparc64. Be careful to do all needed overflow
checks and try to make all parsing functions look similar.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.12 2010/10/26 12:22:35 claudio Exp $ */
d38 1
a38 1
	LIST_ENTRY(nbr)		 entry, hash;
a121 1
void		 ldpe_nbr_ctl(struct ctl_conn *);
a145 1
void		 nbr_init(u_int32_t);
d149 2
a150 2
struct nbr	*nbr_find_ip(struct iface *, u_int32_t);
struct nbr	*nbr_find_ldpid(struct iface *, u_int32_t, u_int16_t);
d181 1
@


1.12
log
@struct mapping_entry should just have a struct map instead of own
definition of a FEC mapping. This makes extending struct map simpler
and makes it possible to access the additional data in struct map.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.11 2010/09/06 08:28:43 claudio Exp $ */
a97 1
int	 recv_address_withdraw(struct nbr *, char *, u_int16_t);
@


1.11
log
@The nbr_reset_*() timer fucntions are the same as the nbr_start_* function.
So replace the few calls to the reset function with nbr_start_*().
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.10 2010/05/26 13:56:08 nicm Exp $ */
d34 1
a34 3
	u_int32_t			label;
	u_int32_t			prefix;
	u_int8_t			prefixlen;
@


1.10
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.9 2010/05/19 15:28:51 claudio Exp $ */
a162 1
void	 nbr_reset_itimer(struct nbr *);
a165 1
void	 nbr_reset_ktimer(struct nbr *);
a168 1
void	 nbr_reset_ktimeout(struct nbr *);
a171 1
void	 nbr_reset_idtimer(struct nbr *);
@


1.9
log
@Remove yet another ospf leftover that is not needed here. This time
neighbor self and all the madness surrounding this amazing concept.
LDP is not self aware so there is no need for this.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.8 2010/05/14 13:49:09 claudio Exp $ */
d57 1
a57 1
	struct buf_read		*rbuf;
d92 1
a92 1
struct buf	*send_notification(u_int32_t, struct iface *, u_int32_t,
d192 2
a193 2
int	 gen_ldp_hdr(struct buf *, struct iface *, u_int16_t);
int	 gen_msg_tlv(struct buf *, u_int32_t, u_int16_t);
@


1.8
log
@Do not send notifications directly onto the wire. Decide in the caller how
to send the notification. On accept use write() else queue message and try
to send the queued messages out via msgbuf_write(). This may still fail but
is better then the code beforehands.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.7 2010/04/15 15:04:23 claudio Exp $ */
d151 1
a151 1
struct nbr	*nbr_new(u_int32_t, u_int16_t, struct iface *, int);
@


1.7
log
@Instead of having three ways of setting fds non-blocking use
session_socket_blockmode() everywhere.
Additionally make two fatal() distinguishable.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.6 2010/02/25 17:40:46 claudio Exp $ */
d91 2
a92 1
void	 send_notification(u_int32_t, struct iface *, int, u_int32_t,
a93 1
void	 send_notification_nbr(struct nbr *, u_int32_t, u_int32_t, u_int32_t);
@


1.6
log
@Do not use bufferevent for something that's already covered in the imsg
buffer API. This fixes a few possible problems in session_read and does
some further cleanup in various places. Wrap msgbuf into evbuf to add
libevent functionality and use buf_read to handle the read side of a
session.  OK michele@@ and dlg@@ did not see anything evil
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.5 2010/02/22 09:44:04 claudio Exp $ */
a147 1
int	 if_set_nonblock(int);
@


1.5
log
@Correctly encode FEC prefixes. This makes my test setup much happyer.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.4 2010/02/20 21:28:39 michele Exp $ */
d41 2
a42 1
	struct bufferevent	*bev;
a53 2
	int			 fd;

d57 1
a60 1

d63 1
a179 1
int	 nbr_close_connection(struct nbr *);
d197 1
a197 1
void	 session_recv_packet(int, short, void *);
d199 2
a200 2
void	 session_read(struct bufferevent *, void *);
void	 session_error(struct bufferevent *, short, void *);
@


1.4
log
@Make send_* functions return void (and not int) as they can just succeed
or fatal().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.3 2010/02/20 21:05:00 michele Exp $ */
d103 1
@


1.3
log
@Remove unneeded abstraction in neighbor fsm.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.2 2009/06/05 22:34:45 michele Exp $ */
d83 1
a83 1
int	 send_init(struct nbr *);
d87 1
a87 1
int	 send_keepalive(struct nbr *);
d91 1
a91 1
int	 send_notification(u_int32_t, struct iface *, int, u_int32_t,
d93 1
a93 1
int	 send_notification_nbr(struct nbr *, u_int32_t, u_int32_t, u_int32_t);
d97 1
a97 1
int	 send_address(struct nbr *, struct iface *);
d99 1
a99 1
int	 send_address_withdraw(struct nbr *, struct iface *);
d103 1
a103 1
int	 send_labelmapping(struct nbr *);
d105 1
a105 1
int	 send_labelrequest(struct nbr *);
d107 1
a107 1
int	 send_labelwithdraw(struct nbr *);
d109 1
a109 1
int	 send_labelrelease(struct nbr *);
d111 1
a111 1
int	 send_labelabortreq(struct nbr *);
@


1.2
log
@Correctly send notification messages when errors occur.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpe.h,v 1.1 2009/06/01 20:59:45 michele Exp $ */
a133 1
int		 if_act_elect(struct iface *);
a177 8
int	 nbr_act_reset_itimer(struct nbr *);
int	 nbr_act_start_itimer(struct nbr *);
int	 nbr_act_reset_ktimer(struct nbr *);
int	 nbr_act_start_ktimer(struct nbr *);
int	 nbr_act_reset_ktimeout(struct nbr *);
int	 nbr_act_start_ktimeout(struct nbr *);
int	 nbr_act_reset_idtimer(struct nbr *);
int	 nbr_act_start_idtimer(struct nbr *);
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d91 3
a93 2
int	 send_notification(int, struct iface *, int);
int	 send_notification_nbr(struct nbr *, u_int32_t);
a208 1
void	 session_write(struct bufferevent *, void *);
d211 1
@

