head	1.61;
access;
symbols
	OPENBSD_6_0:1.57.0.2
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.61
date	2017.03.03.23.41.27;	author renato;	state Exp;
branches;
next	1.60;
commitid	lvj5kMm2TzZDSXqr;

1.60
date	2017.03.03.23.36.06;	author renato;	state Exp;
branches;
next	1.59;
commitid	nsyffCkbHeLwduqi;

1.59
date	2017.01.05.13.53.09;	author krw;	state Exp;
branches;
next	1.58;
commitid	3AKCl24jEn0sIt6p;

1.58
date	2017.01.05.12.42.18;	author krw;	state Exp;
branches;
next	1.57;
commitid	uzjOUwLRoN7KbcZI;

1.57
date	2016.07.01.23.14.31;	author renato;	state Exp;
branches;
next	1.56;
commitid	DKNC9fIizmSRxKR1;

1.56
date	2016.06.21.21.35.24;	author benno;	state Exp;
branches;
next	1.55;
commitid	AL6SnrmnHkmPOpjv;

1.55
date	2016.06.18.01.33.02;	author renato;	state Exp;
branches;
next	1.54;
commitid	Cf5vCsARaN2NV7l0;

1.54
date	2016.05.23.19.16.00;	author renato;	state Exp;
branches;
next	1.53;
commitid	wKGrbgE7dtbu6ic6;

1.53
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.52;
commitid	TLlfi1Pk0Z97z8HM;

1.52
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.51;
commitid	AQBoOveMRKjtVfFv;

1.51
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.50;
commitid	t07H0Mk6WGdVWB0W;

1.50
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.49;
commitid	D7VvXbswyzx5Ahb2;

1.49
date	2016.05.23.18.55.21;	author renato;	state Exp;
branches;
next	1.48;
commitid	85kONxXVWUqI2Jhb;

1.48
date	2016.05.23.18.41.59;	author renato;	state Exp;
branches;
next	1.47;
commitid	zjb4P8L4wSROotP5;

1.47
date	2016.05.23.18.36.55;	author renato;	state Exp;
branches;
next	1.46;
commitid	Ba6Sgjw90tNqVKLo;

1.46
date	2016.05.23.18.31.12;	author renato;	state Exp;
branches;
next	1.45;
commitid	nHUSXWKa1vdMbRgF;

1.45
date	2016.05.23.18.28.22;	author renato;	state Exp;
branches;
next	1.44;
commitid	FV8IR5RMrg1EHRis;

1.44
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.43;
commitid	VpAym8dVR6eY4drQ;

1.43
date	2016.05.23.16.54.22;	author renato;	state Exp;
branches;
next	1.42;
commitid	LfWxXXNhiR6poNUS;

1.42
date	2016.05.23.16.39.47;	author renato;	state Exp;
branches;
next	1.41;
commitid	KHzrHJWU82G7vELl;

1.41
date	2016.05.23.16.35.37;	author renato;	state Exp;
branches;
next	1.40;
commitid	kBkfn3IA7pHWJlRN;

1.40
date	2016.05.23.16.20.59;	author renato;	state Exp;
branches;
next	1.39;
commitid	nAtgYzDo97D7UnEI;

1.39
date	2016.05.23.16.18.51;	author renato;	state Exp;
branches;
next	1.38;
commitid	0IKOnhMGNkMbV1lE;

1.38
date	2016.05.23.16.14.36;	author renato;	state Exp;
branches;
next	1.37;
commitid	hNzA87VdOHsaOms9;

1.37
date	2016.05.23.16.08.18;	author renato;	state Exp;
branches;
next	1.36;
commitid	BnqFnJhiKFbG4Dc4;

1.36
date	2016.05.23.15.43.11;	author renato;	state Exp;
branches;
next	1.35;
commitid	weS0xzAgWBV4f0dh;

1.35
date	2016.05.23.15.41.04;	author renato;	state Exp;
branches;
next	1.34;
commitid	GWVZlQK3ZbMPg5pq;

1.34
date	2016.05.23.15.32.48;	author renato;	state Exp;
branches;
next	1.33;
commitid	XVU4bpPKZtnBxFvS;

1.33
date	2016.05.23.15.30.43;	author renato;	state Exp;
branches;
next	1.32;
commitid	4Irt06csSTr2OMUF;

1.32
date	2016.05.23.15.28.39;	author renato;	state Exp;
branches;
next	1.31;
commitid	fUz5Y2dlemUSlJmh;

1.31
date	2015.09.27.17.30.38;	author stsp;	state Exp;
branches;
next	1.30;
commitid	pKhBZfZX0D7hOGSk;

1.30
date	2015.07.21.04.56.44;	author renato;	state Exp;
branches;
next	1.29;
commitid	gTguoKXzJDzFxvI9;

1.29
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.28;
commitid	puLLDX1XPNc3GxB9;

1.28
date	2015.07.21.04.45.21;	author renato;	state Exp;
branches;
next	1.27;
commitid	DOwVSvrpKsgJLpe1;

1.27
date	2015.07.21.04.40.56;	author renato;	state Exp;
branches;
next	1.26;
commitid	aaU19t2dCdAdF6ZH;

1.26
date	2015.07.19.21.04.38;	author renato;	state Exp;
branches;
next	1.25;
commitid	jI3o3zBRaRv2piIx;

1.25
date	2015.07.19.21.01.56;	author renato;	state Exp;
branches;
next	1.24;
commitid	3CZZKtMxWnvDQhpO;

1.24
date	2015.07.19.20.50.03;	author renato;	state Exp;
branches;
next	1.23;
commitid	HQ4RevpYoLNvLRj2;

1.23
date	2014.11.20.05.51.20;	author jsg;	state Exp;
branches;
next	1.22;
commitid	3Z7yItGpFsmshk0c;

1.22
date	2014.11.14.03.20.37;	author doug;	state Exp;
branches;
next	1.21;
commitid	M08zdkdK3z1pxKwF;

1.21
date	2014.11.03.18.44.36;	author bluhm;	state Exp;
branches;
next	1.20;
commitid	8nAFL7sqdqdC8oHX;

1.20
date	2014.01.22.00.21.16;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2013.11.25.12.57.42;	author benno;	state Exp;
branches;
next	1.18;

1.18
date	2013.10.15.20.13.47;	author renato;	state Exp;
branches;
next	1.17;

1.17
date	2013.06.04.02.25.28;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2013.06.03.16.58.14;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2013.06.03.16.53.49;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2013.06.01.19.28.55;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.01.18.47.07;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.01.18.35.02;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.01.18.30.32;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.01.18.26.40;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2013.05.30.15.44.37;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.06.21.42.40;	author sthen;	state Exp;
branches;
next	1.7;

1.7
date	2010.09.01.13.54.54;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.08.03.18.42.40;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.21.19.41.44;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.25.13.29.45;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.18.15.25.28;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2010.02.16.08.02.21;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Minor tweaks.
@
text
@/*	$OpenBSD: parse.y,v 1.60 2017/03/03 23:36:06 renato Exp $ */

/*
 * Copyright (c) 2013, 2015, 2016 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2004, 2005, 2008 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2004 Ryan McBride <mcbride@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/stat.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <err.h>
#include <unistd.h>
#include <ifaddrs.h>
#include <net/if_types.h>
#include <limits.h>
#include <stdio.h>
#include <syslog.h>

#include "ldpd.h"
#include "ldpe.h"
#include "lde.h"
#include "log.h"

struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
};
TAILQ_HEAD(files, file);

struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
TAILQ_HEAD(symhead, sym);

struct config_defaults {
	uint16_t	keepalive;
	uint16_t	lhello_holdtime;
	uint16_t	lhello_interval;
	uint16_t	thello_holdtime;
	uint16_t	thello_interval;
	union ldpd_addr	trans_addr;
	int		afflags;
	uint8_t		pwflags;
};

typedef struct {
	union {
		int64_t		 number;
		char		*string;
	} v;
	int lineno;
} YYSTYPE;

#define MAXPUSHBACK	128

static int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
static int		 kw_cmp(const void *, const void *);
static int		 lookup(char *);
static int		 lgetc(int);
static int		 lungetc(int);
static int		 findeol(void);
static int		 yylex(void);
static int		 check_file_secrecy(int, const char *);
static struct file	*pushfile(const char *, int);
static int		 popfile(void);
static int		 yyparse(void);
static int		 symset(const char *, const char *, int);
static char		*symget(const char *);
static struct iface	*conf_get_if(struct kif *);
static struct tnbr	*conf_get_tnbr(union ldpd_addr *);
static struct nbr_params *conf_get_nbrp(struct in_addr);
static struct l2vpn	*conf_get_l2vpn(char *);
static struct l2vpn_if	*conf_get_l2vpn_if(struct l2vpn *, struct kif *);
static struct l2vpn_pw	*conf_get_l2vpn_pw(struct l2vpn *, struct kif *);
int			 conf_check_rdomain(unsigned int);
static void		 clear_config(struct ldpd_conf *xconf);
static uint32_t		 get_rtr_id(void);
static int		 get_address(const char *, union ldpd_addr *);
static int		 get_af_address(const char *, int *, union ldpd_addr *);

static struct file		*file, *topfile;
static struct files		 files = TAILQ_HEAD_INITIALIZER(files);
static struct symhead		 symhead = TAILQ_HEAD_INITIALIZER(symhead);
static struct ldpd_conf		*conf;
static int			 errors;

static int			 af;
static struct ldpd_af_conf	*af_conf;
static struct iface		*iface;
static struct iface_af		*ia;
static struct tnbr		*tnbr;
static struct nbr_params	*nbrp;
static struct l2vpn		*l2vpn;
static struct l2vpn_pw		*pw;

static struct config_defaults	 globaldefs;
static struct config_defaults	 afdefs;
static struct config_defaults	 ifacedefs;
static struct config_defaults	 tnbrdefs;
static struct config_defaults	 pwdefs;
static struct config_defaults	*defs;

static unsigned char		*parsebuf;
static int			 parseindex;
static unsigned char		 pushback_buffer[MAXPUSHBACK];
static int			 pushback_index;

%}

%token	INTERFACE TNEIGHBOR ROUTERID FIBUPDATE RDOMAIN EXPNULL
%token	LHELLOHOLDTIME LHELLOINTERVAL
%token	THELLOHOLDTIME THELLOINTERVAL
%token	THELLOACCEPT AF IPV4 IPV6 GTSMENABLE GTSMHOPS
%token	KEEPALIVE TRANSADDRESS TRANSPREFERENCE DSCISCOINTEROP
%token	NEIGHBOR PASSWORD
%token	L2VPN TYPE VPLS PWTYPE MTU BRIDGE
%token	ETHERNET ETHERNETTAGGED STATUSTLV CONTROLWORD
%token	PSEUDOWIRE NEIGHBORID NEIGHBORADDR PWID
%token	EXTTAG
%token	YES NO
%token	INCLUDE
%token	ERROR
%token	<v.string>	STRING
%token	<v.number>	NUMBER
%type	<v.number>	yesno ldp_af l2vpn_type pw_type
%type	<v.string>	string

%%

grammar		: /* empty */
		| grammar include '\n'
		| grammar '\n'
		| grammar conf_main '\n'
		| grammar varset '\n'
		| grammar af '\n'
		| grammar neighbor '\n'
		| grammar l2vpn '\n'
		| grammar error '\n'		{ file->errors++; }
		;

include		: INCLUDE STRING		{
			struct file	*nfile;

			if ((nfile = pushfile($2, 1)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}
		;

string		: string STRING	{
			if (asprintf(&$$, "%s %s", $1, $2) == -1) {
				free($1);
				free($2);
				yyerror("string: asprintf");
				YYERROR;
			}
			free($1);
			free($2);
		}
		| STRING
		;

yesno		: YES	{ $$ = 1; }
		| NO	{ $$ = 0; }
		;

ldp_af		: IPV4	{ $$ = AF_INET; }
		| IPV6	{ $$ = AF_INET6; }
		;

l2vpn_type	: VPLS	{ $$ = L2VPN_TYPE_VPLS; }
		;

pw_type		: ETHERNET		{ $$ = PW_TYPE_ETHERNET; }
		| ETHERNETTAGGED	{ $$ = PW_TYPE_ETHERNET_TAGGED; }
		;

varset		: STRING '=' string {
			char *s = $1;
			if (global.cmd_opts & LDPD_OPT_VERBOSE)
				printf("%s = \"%s\"\n", $1, $3);
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				fatal("cannot store variable");
			free($1);
			free($3);
		}
		;

conf_main	: ROUTERID STRING {
			if (!inet_aton($2, &conf->rtr_id)) {
				yyerror("error parsing router-id");
				free($2);
				YYERROR;
			}
			free($2);
			if (bad_addr_v4(conf->rtr_id)) {
				yyerror("invalid router-id");
				YYERROR;
			}
		}
		| FIBUPDATE yesno {
			if ($2 == 0)
				conf->flags |= F_LDPD_NO_FIB_UPDATE;
			else
				conf->flags &= ~F_LDPD_NO_FIB_UPDATE;
		}
		| RDOMAIN NUMBER {
			if ($2 < 0 || $2 > RT_TABLEID_MAX) {
				yyerror("invalid rdomain");
				YYERROR;
			}
			conf->rdomain = $2;
		}
		| TRANSPREFERENCE ldp_af {
			conf->trans_pref = $2;

			switch (conf->trans_pref) {
			case AF_INET:
				conf->trans_pref = DUAL_STACK_LDPOV4;
				break;
			case AF_INET6:
				conf->trans_pref = DUAL_STACK_LDPOV6;
				break;
			default:
				yyerror("invalid address-family");
				YYERROR;
			}
		}
		| DSCISCOINTEROP yesno {
			if ($2 == 1)
				conf->flags |= F_LDPD_DS_CISCO_INTEROP;
			else
				conf->flags &= ~F_LDPD_DS_CISCO_INTEROP;
		}
		| af_defaults
		| iface_defaults
		| tnbr_defaults
		;

af		: AF ldp_af {
			af = $2;
			switch (af) {
			case AF_INET:
				af_conf = &conf->ipv4;
				break;
			case AF_INET6:
				af_conf = &conf->ipv6;
				break;
			default:
				yyerror("invalid address-family");
				YYERROR;
			}

			afdefs = *defs;
			defs = &afdefs;
		} af_block {
			af_conf->keepalive = defs->keepalive;
			af_conf->thello_holdtime = defs->thello_holdtime;
			af_conf->thello_interval = defs->thello_interval;
			af_conf->flags = defs->afflags;
			af_conf->flags |= F_LDPD_AF_ENABLED;
			af_conf = NULL;
			af = AF_UNSPEC;
			defs = &globaldefs;
		}
		;

af_block	: '{' optnl afopts_l '}'
		| '{' optnl '}'
		|
		;

afopts_l	: afopts_l afoptsl nl
		| afoptsl optnl
		;

afoptsl		:  TRANSADDRESS STRING {
			if (get_address($2, &af_conf->trans_addr) == -1) {
				yyerror("error parsing transport-address");
				free($2);
				YYERROR;
			}
			free($2);
			if (bad_addr(af, &af_conf->trans_addr)) {
				yyerror("invalid transport-address");
				YYERROR;
			}
			if (af == AF_INET6 &&
			   IN6_IS_SCOPE_EMBED(&af_conf->trans_addr.v6)) {
				yyerror("ipv6 transport-address can not be "
				    "link-local");
				YYERROR;
			}
		}
		| GTSMENABLE yesno {
			if ($2 == 0)
				defs->afflags |= F_LDPD_AF_NO_GTSM;
		}
		| af_defaults
		| iface_defaults
		| tnbr_defaults
		| interface
		| tneighbor
		;

af_defaults	: THELLOACCEPT yesno {
			if ($2 == 0)
				defs->afflags &= ~F_LDPD_AF_THELLO_ACCEPT;
			else
				defs->afflags |= F_LDPD_AF_THELLO_ACCEPT;
		}
		| EXPNULL yesno {
			if ($2 == 0)
				defs->afflags &= ~F_LDPD_AF_EXPNULL;
			else
				defs->afflags |= F_LDPD_AF_EXPNULL;
		}
		| KEEPALIVE NUMBER {
			if ($2 < MIN_KEEPALIVE || $2 > MAX_KEEPALIVE) {
				yyerror("keepalive out of range (%d-%d)",
				    MIN_KEEPALIVE, MAX_KEEPALIVE);
				YYERROR;
			}
			defs->keepalive = $2;
		}
		;

iface_defaults	: LHELLOHOLDTIME NUMBER {
			if ($2 < MIN_HOLDTIME || $2 > MAX_HOLDTIME) {
				yyerror("hello-holdtime out of range (%d-%d)",
				    MIN_HOLDTIME, MAX_HOLDTIME);
				YYERROR;
			}
			defs->lhello_holdtime = $2;
		}
		| LHELLOINTERVAL NUMBER {
			if ($2 < MIN_HELLO_INTERVAL ||
			    $2 > MAX_HELLO_INTERVAL) {
				yyerror("hello-interval out of range (%d-%d)",
				    MIN_HELLO_INTERVAL, MAX_HELLO_INTERVAL);
				YYERROR;
			}
			defs->lhello_interval = $2;
		}
		;

tnbr_defaults	: THELLOHOLDTIME NUMBER {
			if ($2 < MIN_HOLDTIME || $2 > MAX_HOLDTIME) {
				yyerror("hello-holdtime out of range (%d-%d)",
				    MIN_HOLDTIME, MAX_HOLDTIME);
				YYERROR;
			}
			defs->thello_holdtime = $2;
		}
		| THELLOINTERVAL NUMBER {
			if ($2 < MIN_HELLO_INTERVAL ||
			    $2 > MAX_HELLO_INTERVAL) {
				yyerror("hello-interval out of range (%d-%d)",
				    MIN_HELLO_INTERVAL, MAX_HELLO_INTERVAL);
				YYERROR;
			}
			defs->thello_interval = $2;
		}
		;

nbr_opts	: KEEPALIVE NUMBER {
			if ($2 < MIN_KEEPALIVE || $2 > MAX_KEEPALIVE) {
				yyerror("keepalive out of range (%d-%d)",
				    MIN_KEEPALIVE, MAX_KEEPALIVE);
				YYERROR;
			}
			nbrp->keepalive = $2;
			nbrp->flags |= F_NBRP_KEEPALIVE;
		}
		| PASSWORD STRING {
			if (strlcpy(nbrp->auth.md5key, $2,
			    sizeof(nbrp->auth.md5key)) >=
			    sizeof(nbrp->auth.md5key)) {
				yyerror("tcp md5sig password too long: max %zu",
				    sizeof(nbrp->auth.md5key) - 1);
				free($2);
				YYERROR;
			}
			nbrp->auth.md5key_len = strlen($2);
			nbrp->auth.method = AUTH_MD5SIG;
			free($2);
		}
		| GTSMENABLE yesno {
			nbrp->flags |= F_NBRP_GTSM;
			nbrp->gtsm_enabled = $2;
		}
		| GTSMHOPS NUMBER {
			if ($2 < 1 || $2 > 255) {
				yyerror("invalid number of hops %lld", $2);
				YYERROR;
			}
			nbrp->gtsm_hops = $2;
			nbrp->flags |= F_NBRP_GTSM_HOPS;
		}
		;

pw_defaults	: STATUSTLV yesno {
			if ($2 == 1)
				defs->pwflags |= F_PW_STATUSTLV_CONF;
			else
				defs->pwflags &= ~F_PW_STATUSTLV_CONF;
		}
		| CONTROLWORD yesno {
			if ($2 == 1)
				defs->pwflags |= F_PW_CWORD_CONF;
			else
				defs->pwflags &= ~F_PW_CWORD_CONF;
		}
		;

pwopts		: PWID NUMBER {
			if ($2 < MIN_PWID_ID ||
			    $2 > MAX_PWID_ID) {
				yyerror("pw-id out of range (%d-%d)",
				    MIN_PWID_ID, MAX_PWID_ID);
				YYERROR;
			}

			pw->pwid = $2;
		}
		| NEIGHBORID STRING {
			struct in_addr	 addr;

			if (!inet_aton($2, &addr)) {
				yyerror("error parsing neighbor-id");
				free($2);
				YYERROR;
			}
			free($2);
			if (bad_addr_v4(addr)) {
				yyerror("invalid neighbor-id");
				YYERROR;
			}

			pw->lsr_id = addr;
		}
		| NEIGHBORADDR STRING {
			int		 family;
			union ldpd_addr	 addr;

			if (get_af_address($2, &family, &addr) == -1) {
				yyerror("error parsing neighbor address");
				free($2);
				YYERROR;
			}
			free($2);
			if (bad_addr(family, &addr)) {
				yyerror("invalid neighbor address");
				YYERROR;
			}
			if (family == AF_INET6 &&
			    IN6_IS_SCOPE_EMBED(&addr.v6)) {
				yyerror("neighbor address can not be "
				    "link-local");
				YYERROR;
			}

			pw->af = family;
			pw->addr = addr;
		}
		| pw_defaults
		;

pseudowire	: PSEUDOWIRE STRING {
			struct kif	*kif;

			if ((kif = kif_findname($2)) == NULL) {
				yyerror("unknown interface %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			if (kif->if_type != IFT_MPLSTUNNEL) {
				yyerror("unsupported interface type on "
				    "interface %s", kif->ifname);
				YYERROR;
			}

			pw = conf_get_l2vpn_pw(l2vpn, kif);
			if (pw == NULL)
				YYERROR;

			pwdefs = *defs;
			defs = &pwdefs;
		} pw_block {
			struct l2vpn	*l;
			struct l2vpn_pw *p;

			/* check for errors */
			if (pw->pwid == 0) {
				yyerror("missing pseudowire id");
				YYERROR;
			}
			if (pw->lsr_id.s_addr == INADDR_ANY) {
				yyerror("missing pseudowire neighbor-id");
				YYERROR;
			}
			LIST_FOREACH(l, &conf->l2vpn_list, entry) {
				LIST_FOREACH(p, &l->pw_list, entry) {
					if (pw != p &&
					    pw->pwid == p->pwid &&
					    pw->af == p->af &&
					    pw->lsr_id.s_addr ==
					    p->lsr_id.s_addr) {
						yyerror("pseudowire already "
						    "configured");
						YYERROR;
					}
				}
			}

			/*
			 * If the neighbor address is not specified, use the
			 * neighbor id.
			 */
			if (pw->af == AF_UNSPEC) {
				pw->af = AF_INET;
				pw->addr.v4 = pw->lsr_id;
			}

			pw->flags = defs->pwflags;
			pw = NULL;
			defs = &globaldefs;
		}
		;

pw_block	: '{' optnl pwopts_l '}'
		| '{' optnl '}'
		| /* nothing */
		;

pwopts_l	: pwopts_l pwopts nl
		| pwopts optnl
		;

l2vpnopts	: PWTYPE pw_type {
			l2vpn->pw_type = $2;
		}
		| MTU NUMBER {
			if ($2 < MIN_L2VPN_MTU ||
			    $2 > MAX_L2VPN_MTU) {
				yyerror("l2vpn mtu out of range (%d-%d)",
				    MIN_L2VPN_MTU, MAX_L2VPN_MTU);
				YYERROR;
			}
			l2vpn->mtu = $2;
		}
		| pw_defaults
		| BRIDGE STRING {
			struct l2vpn	 *l;
			struct kif	 *kif;

			if ((kif = kif_findname($2)) == NULL) {
				yyerror("unknown interface %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			if (l2vpn->br_ifindex != 0) {
				yyerror("bridge interface cannot be "
				    "redefined on l2vpn %s", l2vpn->name);
				YYERROR;
			}

			if (kif->if_type != IFT_BRIDGE) {
				yyerror("unsupported interface type on "
				    "interface %s", kif->ifname);
				YYERROR;
			}

			LIST_FOREACH(l, &conf->l2vpn_list, entry) {
				if (l->br_ifindex == kif->ifindex) {
					yyerror("bridge %s is already being "
					    "used by l2vpn %s", kif->ifname,
					    l->name);
					YYERROR;
				}
			}

			l2vpn->br_ifindex = kif->ifindex;
			strlcpy(l2vpn->br_ifname, kif->ifname,
			    sizeof(l2vpn->br_ifname));
		}
		| INTERFACE STRING {
			struct kif	*kif;
			struct l2vpn_if	*lif;

			if ((kif = kif_findname($2)) == NULL) {
				yyerror("unknown interface %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			lif = conf_get_l2vpn_if(l2vpn, kif);
			if (lif == NULL)
				YYERROR;
		}
		| pseudowire
		;

optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl		/* one newline or more */
		;

interface	: INTERFACE STRING	{
			struct kif	*kif;

			if ((kif = kif_findname($2)) == NULL) {
				yyerror("unknown interface %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			iface = conf_get_if(kif);
			if (iface == NULL)
				YYERROR;

			ia = iface_af_get(iface, af);
			if (ia->enabled) {
				yyerror("interface %s already configured for "
				    "address-family %s", kif->ifname,
				    af_name(af));
				YYERROR;
			}
			ia->enabled = 1;

			ifacedefs = *defs;
			defs = &ifacedefs;
		} interface_block {
			ia->hello_holdtime = defs->lhello_holdtime;
			ia->hello_interval = defs->lhello_interval;
			iface = NULL;
			defs = &afdefs;
		}
		;

interface_block	: '{' optnl interfaceopts_l '}'
		| '{' optnl '}'
		| /* nothing */
		;

interfaceopts_l	: interfaceopts_l iface_defaults nl
		| iface_defaults optnl
		;

tneighbor	: TNEIGHBOR STRING	{
			union ldpd_addr	 addr;

			if (get_address($2, &addr) == -1) {
				yyerror("error parsing targeted-neighbor "
				    "address");
				free($2);
				YYERROR;
			}
			free($2);
			if (bad_addr(af, &addr)) {
				yyerror("invalid targeted-neighbor address");
				YYERROR;
			}
			if (af == AF_INET6 &&
			   IN6_IS_SCOPE_EMBED(&addr.v6)) {
				yyerror("targeted-neighbor address can not be "
				    "link-local");
				YYERROR;
			}

			tnbr = conf_get_tnbr(&addr);
			if (tnbr == NULL)
				YYERROR;

			tnbrdefs = *defs;
			defs = &tnbrdefs;
		} tneighbor_block {
			tnbr->hello_holdtime = defs->thello_holdtime;
			tnbr->hello_interval = defs->thello_interval;
			tnbr = NULL;
			defs = &afdefs;
		}
		;

tneighbor_block	: '{' optnl tneighboropts_l '}'
		| '{' optnl '}'
		| /* nothing */
		;

tneighboropts_l	: tneighboropts_l tnbr_defaults nl
		| tnbr_defaults optnl
		;

neighbor	: NEIGHBOR STRING	{
			struct in_addr	 addr;

			if (inet_aton($2, &addr) == 0) {
				yyerror("error parsing neighbor-id");
				free($2);
				YYERROR;
			}
			free($2);
			if (bad_addr_v4(addr)) {
				yyerror("invalid neighbor-id");
				YYERROR;
			}

			nbrp = conf_get_nbrp(addr);
			if (nbrp == NULL)
				YYERROR;
		} neighbor_block {
			nbrp = NULL;
		}
		;

neighbor_block	: '{' optnl neighboropts_l '}'
		| '{' optnl '}'
		| /* nothing */
		;

neighboropts_l	: neighboropts_l nbr_opts nl
		| nbr_opts optnl
		;

l2vpn		: L2VPN STRING TYPE l2vpn_type {
			l2vpn = conf_get_l2vpn($2);
			if (l2vpn == NULL)
				YYERROR;
			l2vpn->type = $4;
		} l2vpn_block {
			l2vpn = NULL;
		}
		;

l2vpn_block	: '{' optnl l2vpnopts_l '}'
		| '{' optnl '}'
		| /* nothing */
		;

l2vpnopts_l	: l2vpnopts_l l2vpnopts nl
		| l2vpnopts optnl
		;

%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

static int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;
	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		fatalx("yyerror vasprintf");
	va_end(ap);
	logit(LOG_CRIT, "%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
	return (0);
}

static int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

static int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{"address-family",		AF},
		{"bridge",			BRIDGE},
		{"control-word",		CONTROLWORD},
		{"ds-cisco-interop",		DSCISCOINTEROP},
		{"ethernet",			ETHERNET},
		{"ethernet-tagged",		ETHERNETTAGGED},
		{"explicit-null",		EXPNULL},
		{"fib-update",			FIBUPDATE},
		{"gtsm-enable",			GTSMENABLE},
		{"gtsm-hops",			GTSMHOPS},
		{"include",			INCLUDE},
		{"interface",			INTERFACE},
		{"ipv4",			IPV4},
		{"ipv6",			IPV6},
		{"keepalive",			KEEPALIVE},
		{"l2vpn",			L2VPN},
		{"link-hello-holdtime",		LHELLOHOLDTIME},
		{"link-hello-interval",		LHELLOINTERVAL},
		{"mtu",				MTU},
		{"neighbor",			NEIGHBOR},
		{"neighbor-addr",		NEIGHBORADDR},
		{"neighbor-id",			NEIGHBORID},
		{"no",				NO},
		{"password",			PASSWORD},
		{"pseudowire",			PSEUDOWIRE},
		{"pw-id",			PWID},
		{"pw-type",			PWTYPE},
		{"rdomain",			RDOMAIN},
		{"router-id",			ROUTERID},
		{"status-tlv",			STATUSTLV},
		{"targeted-hello-accept",	THELLOACCEPT},
		{"targeted-hello-holdtime",	THELLOHOLDTIME},
		{"targeted-hello-interval",	THELLOINTERVAL},
		{"targeted-neighbor",		TNEIGHBOR},
		{"transport-address",		TRANSADDRESS},
		{"transport-preference",	TRANSPREFERENCE},
		{"type",			TYPE},
		{"vpls",			VPLS},
		{"yes",				YES}
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

static int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

static int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

static int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

static int
yylex(void)
{
	unsigned char	 buf[8096];
	unsigned char	*p, *val;
	int		 quotec, next, c;
	int		 token;

 top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
 nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && \
	x != '!' && x != '=' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

static int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		log_warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		log_warnx("%s: group writable or world read/writable", fname);
		return (-1);
	}
	return (0);
}

static struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		log_warn("calloc");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		log_warn("strdup");
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		log_warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

static int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

struct ldpd_conf *
parse_config(char *filename)
{
	struct sym	*sym, *next;

	conf = config_new_empty();
	conf->rdomain = 0;
	conf->trans_pref = DUAL_STACK_LDPOV6;

	defs = &globaldefs;
	defs->keepalive = DEFAULT_KEEPALIVE;
	defs->lhello_holdtime = LINK_DFLT_HOLDTIME;
	defs->lhello_interval = DEFAULT_HELLO_INTERVAL;
	defs->thello_holdtime = TARGETED_DFLT_HOLDTIME;
	defs->thello_interval = DEFAULT_HELLO_INTERVAL;
	defs->pwflags = F_PW_STATUSTLV_CONF|F_PW_CWORD_CONF;

	if ((file = pushfile(filename,
	    !(global.cmd_opts & LDPD_OPT_NOACTION))) == NULL) {
		free(conf);
		return (NULL);
	}
	topfile = file;

	yyparse();
	errors = file->errors;
	popfile();

	/* Free macros and check which have not been used. */
	TAILQ_FOREACH_SAFE(sym, &symhead, entry, next) {
		if ((global.cmd_opts & LDPD_OPT_VERBOSE2) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	/* check that all interfaces belong to the configured rdomain */
	errors += conf_check_rdomain(conf->rdomain);

	/* free global config defaults */
	if (errors) {
		clear_config(conf);
		return (NULL);
	}

	if (conf->rtr_id.s_addr == INADDR_ANY)
		conf->rtr_id.s_addr = get_rtr_id();

	/* if the ipv4 transport-address is not set, use the router-id */
	if ((conf->ipv4.flags & F_LDPD_AF_ENABLED) &&
	    conf->ipv4.trans_addr.v4.s_addr == INADDR_ANY)
		conf->ipv4.trans_addr.v4 = conf->rtr_id;

	return (conf);
}

static int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		errx(1, "cmdline_symset: malloc");

	strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

static char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

static struct iface *
conf_get_if(struct kif *kif)
{
	struct iface	*i;
	struct l2vpn	*l;

	if (kif->if_type == IFT_LOOP ||
	    kif->if_type == IFT_CARP ||
	    kif->if_type == IFT_BRIDGE ||
	    kif->if_type == IFT_MPLSTUNNEL) {
		yyerror("unsupported interface type on interface %s",
		    kif->ifname);
		return (NULL);
	}

	LIST_FOREACH(l, &conf->l2vpn_list, entry)
		if (l2vpn_if_find(l, kif->ifindex)) {
			yyerror("interface %s already configured under "
			    "l2vpn %s", kif->ifname, l->name);
			return (NULL);
		}

	LIST_FOREACH(i, &conf->iface_list, entry)
		if (i->ifindex == kif->ifindex)
			return (i);

	i = if_new(kif);
	LIST_INSERT_HEAD(&conf->iface_list, i, entry);
	return (i);
}

static struct tnbr *
conf_get_tnbr(union ldpd_addr *addr)
{
	struct tnbr	*t;

	t = tnbr_find(conf, af, addr);
	if (t) {
		yyerror("targeted neighbor %s already configured",
		    log_addr(af, addr));
		return (NULL);
	}

	t = tnbr_new(conf, af, addr);
	t->flags |= F_TNBR_CONFIGURED;
	LIST_INSERT_HEAD(&conf->tnbr_list, t, entry);
	return (t);
}

static struct nbr_params *
conf_get_nbrp(struct in_addr lsr_id)
{
	struct nbr_params	*n;

	LIST_FOREACH(n, &conf->nbrp_list, entry) {
		if (n->lsr_id.s_addr == lsr_id.s_addr) {
			yyerror("neighbor %s already configured",
			    inet_ntoa(lsr_id));
			return (NULL);
		}
	}

	n = nbr_params_new(lsr_id);
	LIST_INSERT_HEAD(&conf->nbrp_list, n, entry);
	return (n);
}

static struct l2vpn *
conf_get_l2vpn(char *name)
{
	struct l2vpn	 *l;

	if (l2vpn_find(conf, name)) {
		yyerror("l2vpn %s already configured", name);
		return (NULL);
	}

	l = l2vpn_new(name);
	LIST_INSERT_HEAD(&conf->l2vpn_list, l, entry);
	return (l);
}

static struct l2vpn_if *
conf_get_l2vpn_if(struct l2vpn *l, struct kif *kif)
{
	struct iface	*i;
	struct l2vpn	*ltmp;
	struct l2vpn_if	*f;

	if (kif->if_type == IFT_LOOP ||
	    kif->if_type == IFT_CARP ||
	    kif->if_type == IFT_BRIDGE ||
	    kif->if_type == IFT_MPLSTUNNEL) {
		yyerror("unsupported interface type on interface %s",
		    kif->ifname);
		return (NULL);
	}

	LIST_FOREACH(ltmp, &conf->l2vpn_list, entry)
		if (l2vpn_if_find(ltmp, kif->ifindex)) {
			yyerror("interface %s already configured under "
			    "l2vpn %s", kif->ifname, ltmp->name);
			return (NULL);
		}

	LIST_FOREACH(i, &conf->iface_list, entry) {
		if (i->ifindex == kif->ifindex) {
			yyerror("interface %s already configured",
			    kif->ifname);
			return (NULL);
		}
	}

	f = l2vpn_if_new(l, kif);
	LIST_INSERT_HEAD(&l2vpn->if_list, f, entry);
	return (f);
}

static struct l2vpn_pw *
conf_get_l2vpn_pw(struct l2vpn *l, struct kif *kif)
{
	struct l2vpn	*ltmp;
	struct l2vpn_pw	*p;

	LIST_FOREACH(ltmp, &conf->l2vpn_list, entry) {
		if (l2vpn_pw_find(ltmp, kif->ifindex)) {
			yyerror("pseudowire %s is already being "
			    "used by l2vpn %s", kif->ifname, ltmp->name);
			return (NULL);
		}
	}

	p = l2vpn_pw_new(l, kif);
	LIST_INSERT_HEAD(&l2vpn->pw_list, p, entry);
	return (p);
}

int
conf_check_rdomain(unsigned int rdomain)
{
	struct iface	*i;
	int		 errs = 0;

	LIST_FOREACH(i, &conf->iface_list, entry) {
		if (i->rdomain != rdomain) {
			logit(LOG_CRIT, "interface %s not in rdomain %u",
			    i->name, rdomain);
			errs++;
		}
	}

	return (errs);
}

static void
clear_config(struct ldpd_conf *xconf)
{
	struct iface		*i;
	struct tnbr		*t;
	struct nbr_params	*n;
	struct l2vpn		*l;
	struct l2vpn_if		*f;
	struct l2vpn_pw		*p;

	while ((i = LIST_FIRST(&xconf->iface_list)) != NULL) {
		LIST_REMOVE(i, entry);
		free(i);
	}

	while ((t = LIST_FIRST(&xconf->tnbr_list)) != NULL) {
		LIST_REMOVE(t, entry);
		free(t);
	}

	while ((n = LIST_FIRST(&xconf->nbrp_list)) != NULL) {
		LIST_REMOVE(n, entry);
		free(n);
	}

	while ((l = LIST_FIRST(&xconf->l2vpn_list)) != NULL) {
		while ((f = LIST_FIRST(&l->if_list)) != NULL) {
			LIST_REMOVE(f, entry);
			free(f);
		}
		while ((p = LIST_FIRST(&l->pw_list)) != NULL) {
			LIST_REMOVE(p, entry);
			free(p);
		}
		LIST_REMOVE(l, entry);
		free(l);
	}

	free(xconf);
}

static uint32_t
get_rtr_id(void)
{
	struct ifaddrs		*ifap, *ifa;
	uint32_t		 ip = 0, cur, localnet;

	localnet = htonl(INADDR_LOOPBACK & IN_CLASSA_NET);

	if (getifaddrs(&ifap) == -1) {
		log_warn("getifaddrs");
		return (0);
	}

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (strncmp(ifa->ifa_name, "carp", 4) == 0)
			continue;
		if (ifa->ifa_addr->sa_family != AF_INET)
			continue;
		cur = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr;
		if ((cur & localnet) == localnet)	/* skip 127/8 */
			continue;
		if (ntohl(cur) < ntohl(ip) || ip == 0)
			ip = cur;
	}
	freeifaddrs(ifap);

	return (ip);
}

static int
get_address(const char *s, union ldpd_addr *addr)
{
	switch (af) {
	case AF_INET:
		if (inet_pton(AF_INET, s, &addr->v4) != 1)
			return (-1);
		break;
	case AF_INET6:
		if (inet_pton(AF_INET6, s, &addr->v6) != 1)
			return (-1);
		break;
	default:
		return (-1);
	}

	return (0);
}

static int
get_af_address(const char *s, int *family, union ldpd_addr *addr)
{
	if (inet_pton(AF_INET, s, &addr->v4) == 1) {
		*family = AF_INET;
		return (0);
	}

	if (inet_pton(AF_INET6, s, &addr->v6) == 1) {
		*family = AF_INET6;
		return (0);
	}

	return (-1);
}
@


1.60
log
@Allow to run on a non-default rdomain.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.59 2017/01/05 13:53:09 krw Exp $ */
d972 1
a972 1
top:
d1074 1
a1074 1
nodigits:
@


1.59
log
@Replace hand-rolled for(;;) emptying of 'symhead' TAILQ with more
modern TAILQ_FOREACH_SAFE().

No intentional functional change.

ok millert@@ bluhm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.58 2017/01/05 12:42:18 krw Exp $ */
d102 1
d137 1
a137 1
%token	INTERFACE TNEIGHBOR ROUTERID FIBUPDATE EXPNULL
d247 7
d853 1
d1186 1
d1221 3
d1452 17
@


1.58
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.57 2016/07/01 23:14:31 renato Exp $ */
d1199 1
a1199 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
@


1.57
log
@Add GTSM support (RFC 6720).

This also finishes the missing bits from our RFC 7552 implementation
because GTSM is mandatory for LDPv6.

To avoid any kind of interoperability problems, I included a few
knobs to enable/disable GTSM on a per-address-family and per-neighbor
basis. Cisco's LDPv6 implementation, for instance, doesn't support GTSM.

"reads good" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.56 2016/06/21 21:35:24 benno Exp $ */
d1234 4
a1237 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d1296 1
a1296 1
	TAILQ_FOREACH(sym, &symhead, entry)
d1301 1
@


1.56
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.55 2016/06/18 01:33:02 renato Exp $ */
d139 1
a139 1
%token	THELLOACCEPT AF IPV4 IPV6
d327 4
d420 12
d826 2
@


1.55
log
@Do not allow configuring the same interface for both LDP and VPLS.

Configuring an interface for both LDP signaling and as a member of a
VPLS instance doesn't cause any harm as far as ldpd is concerned. But
it certainly doesn't make any sense, so it's better to reject the
configuration and warn the user instead of ignoring this silently.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.54 2016/05/23 19:16:00 renato Exp $ */
d211 1
d214 7
@


1.54
log
@Improve security by calling exec after fork.

For each child process (lde and ldpe), re-exec ldpd with a special
"per-role" getopt flag. This way we have seperate ASLR/cookies per
process.

Based on a similar patch for bgpd, from claudio@@

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.53 2016/05/23 19:14:03 renato Exp $ */
a609 8
			if (kif->if_type == IFT_BRIDGE
			    || kif->if_type == IFT_LOOP
			    || kif->if_type == IFT_CARP) {
				yyerror("unsupported interface type on "
				    "interface %s", kif->ifname);
				YYERROR;
			}

d1281 1
a1281 4

	LIST_FOREACH(i, &conf->iface_list, entry)
		if (i->ifindex == kif->ifindex)
			return (i);
d1285 1
d1292 11
d1366 16
a1388 7

	LIST_FOREACH(ltmp, &conf->l2vpn_list, entry)
		if (l2vpn_if_find(ltmp, kif->ifindex)) {
			yyerror("interface %s is already being "
			    "used by l2vpn %s", kif->ifname, ltmp->name);
			return (NULL);
		}
@


1.53
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.52 2016/05/23 19:11:42 renato Exp $ */
d1158 1
a1158 2
	if ((conf = calloc(1, sizeof(struct ldpd_conf))) == NULL)
		fatal(__func__);
a1174 5

	LIST_INIT(&conf->iface_list);
	LIST_INIT(&conf->tnbr_list);
	LIST_INIT(&conf->nbrp_list);
	LIST_INIT(&conf->l2vpn_list);
@


1.52
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.51 2016/05/23 19:09:25 renato Exp $ */
d4 1
@


1.51
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.50 2016/05/23 18:58:48 renato Exp $ */
a24 2
#include <sys/types.h>
#include <sys/socket.h>
a25 1
#include <netinet/in.h>
a28 1
#include <errno.h>
a32 1
#include <stdarg.h>
a33 1
#include <string.h>
a35 1
#include "ldp.h"
d37 1
a38 1
#include "ldpe.h"
@


1.50
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.49 2016/05/23 18:55:21 renato Exp $ */
d48 1
a48 2
TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
d54 2
a55 14
} *file, *topfile;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);
a56 1
TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
d64 1
a64 20

int		 symset(const char *, const char *, int);
char		*symget(const char *);

void		 clear_config(struct ldpd_conf *xconf);
uint32_t	 get_rtr_id(void);
int		 get_address(const char *, union ldpd_addr *);
int		 get_af_address(const char *, int *, union ldpd_addr *);

static struct ldpd_conf	*conf;
static int		 errors = 0;

int			 af = AF_UNSPEC;
struct ldpd_af_conf	*af_conf = NULL;
struct iface		*iface = NULL;
struct iface_af		*ia = NULL;
struct tnbr		*tnbr = NULL;
struct nbr_params	*nbrp = NULL;
struct l2vpn		*l2vpn = NULL;
struct l2vpn_pw		*pw = NULL;
a76 14
struct config_defaults	 globaldefs;
struct config_defaults	 afdefs;
struct config_defaults	 ifacedefs;
struct config_defaults	 tnbrdefs;
struct config_defaults	 pwdefs;
struct config_defaults	*defs;

struct iface		*conf_get_if(struct kif *);
struct tnbr		*conf_get_tnbr(union ldpd_addr *);
struct nbr_params	*conf_get_nbrp(struct in_addr);
struct l2vpn		*conf_get_l2vpn(char *);
struct l2vpn_if		*conf_get_l2vpn_if(struct l2vpn *, struct kif *);
struct l2vpn_pw		*conf_get_l2vpn_pw(struct l2vpn *, struct kif *);

d85 55
d781 1
a781 1
int
d797 1
a797 1
int
d803 1
a803 1
int
d856 1
a856 8
#define MAXPUSHBACK	128

unsigned char	*parsebuf;
int		 parseindex;
unsigned char	 pushback_buffer[MAXPUSHBACK];
int		 pushback_index = 0;

int
d904 1
a904 1
int
d920 1
a920 1
int
d943 1
a943 1
int
d1092 1
a1092 1
int
d1112 1
a1112 1
struct file *
d1143 1
a1143 1
int
d1223 1
a1223 1
int
d1284 1
a1284 1
char *
d1297 1
a1297 1
struct iface *
d1319 1
a1319 1
struct tnbr *
d1337 1
a1337 1
struct nbr_params *
d1355 1
a1355 1
struct l2vpn *
d1370 1
a1370 1
struct l2vpn_if *
d1397 1
a1397 1
struct l2vpn_pw *
d1416 1
a1416 1
void
d1457 1
a1457 1
uint32_t
d1486 1
a1486 1
int
d1505 1
a1505 1
int
@


1.49
log
@Assorted fixes and small cleanup.

Nothing really interesting here.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.48 2016/05/23 18:41:59 renato Exp $ */
d84 2
a85 1
int		 host(const char *, struct in_addr *, struct in_addr *);
d90 2
d93 1
d100 1
d105 2
d111 1
d118 1
a118 1
struct tnbr		*conf_get_tnbr(struct in_addr);
d137 2
a138 2
%token	THELLOACCEPT
%token	KEEPALIVE TRANSADDRESS
d142 1
a142 1
%token	PSEUDOWIRE NEIGHBOR PWID
d149 1
a149 1
%type	<v.number>	yesno l2vpn_type pw_type
d159 1
a159 2
		| grammar interface '\n'
		| grammar tneighbor '\n'
d197 4
d225 1
a225 1
			if (bad_ip_addr(conf->rtr_id)) {
d236 14
a249 5
		| THELLOACCEPT yesno {
			if ($2 == 0)
				conf->flags &= ~F_LDPD_TH_ACCEPT;
			else
				conf->flags |= F_LDPD_TH_ACCEPT;
d251 3
a253 3
		| EXPNULL yesno {
			if ($2 == 0)
				conf->flags &= ~F_LDPD_EXPNULL;
d255 1
a255 1
				conf->flags |= F_LDPD_EXPNULL;
d257 16
a272 4
		| KEEPALIVE NUMBER {
			if ($2 < MIN_KEEPALIVE || $2 > MAX_KEEPALIVE) {
				yyerror("keepalive out of range (%d-%d)",
				    MIN_KEEPALIVE, MAX_KEEPALIVE);
d275 12
a286 1
			conf->keepalive = $2;
d288 13
a300 2
		| TRANSADDRESS STRING {
			if (!inet_aton($2, &conf->trans_addr)) {
d306 1
a306 1
			if (bad_ip_addr(conf->trans_addr)) {
d310 6
d317 1
d320 24
d432 1
a432 1
		| NEIGHBOR STRING {
d435 2
a436 2
			if (inet_aton($2, &addr) == 0) {
				yyerror("error parsing neighbor address");
d441 1
a441 1
			if (bad_ip_addr(addr)) {
d448 24
d507 1
a507 1
				yyerror("missing pseudowire neighbor");
d514 3
a516 1
					    pw->lsr_id.s_addr == p->lsr_id.s_addr) {
d524 9
d644 9
d656 2
a657 2
			iface->hello_holdtime = defs->lhello_holdtime;
			iface->hello_interval = defs->lhello_interval;
d659 1
a659 1
			defs = &globaldefs;
d673 1
a673 1
			struct in_addr	 addr;
d675 1
a675 1
			if (inet_aton($2, &addr) == 0) {
d682 1
a682 1
			if (bad_ip_addr(addr)) {
d686 6
d693 1
a693 1
			tnbr = conf_get_tnbr(addr);
d703 1
a703 1
			defs = &globaldefs;
d720 1
a720 1
				yyerror("error parsing neighbor address");
d725 2
a726 2
			if (bad_ip_addr(addr)) {
				yyerror("invalid neighbor address");
d800 1
d803 1
d810 2
d818 2
d832 1
d1165 1
a1165 1
	conf->keepalive = DEFAULT_KEEPALIVE;
d1168 1
a1172 2
	conf->thello_holdtime = TARGETED_DFLT_HOLDTIME;
	conf->thello_interval = DEFAULT_HELLO_INTERVAL;
d1213 5
a1217 2
	if (conf->trans_addr.s_addr == 0)
		conf->trans_addr = conf->rtr_id;
d1301 3
a1303 7
	LIST_FOREACH(i, &conf->iface_list, entry) {
		if (i->ifindex == kif->ifindex) {
			yyerror("interface %s already configured",
			    kif->ifname);
			return (NULL);
		}
	}
d1319 1
a1319 1
conf_get_tnbr(struct in_addr addr)
d1323 1
a1323 1
	t = tnbr_find(conf, addr);
d1326 1
a1326 1
		    inet_ntoa(addr));
d1330 1
a1330 1
	t = tnbr_new(conf, addr);
d1486 1
a1486 1
host(const char *s, struct in_addr *addr, struct in_addr *mask)
d1488 15
a1502 2
	struct in_addr		 ina;
	int			 bits = 32;
d1504 6
a1509 7
	memset(&ina, 0, sizeof(struct in_addr));
	if (strrchr(s, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(ina))) == -1)
			return (0);
	} else {
		if (inet_pton(AF_INET, s, &ina) != 1)
			return (0);
d1512 4
a1515 2
	*addr = ina;
	mask->s_addr = prefixlen2mask(bits);
d1517 1
a1517 1
	return (1);
@


1.48
log
@Enable changing the router-id via config reload.

Now ldpd can start without a router-id, since it can be set later. Since
a router-id of 0.0.0.0 is invalid, interfaces and targeted-neighbors
will check for a valid router-id in order to be activated.

When the router-id is changed, all the neighborships are reset.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.47 2016/05/23 18:36:55 renato Exp $ */
d87 1
a87 1
static int			 errors = 0;
d141 1
a141 3
%type	<v.number>	yesno
%type	<v.number>	l2vpn_type
%type	<v.number>	pw_type
d262 2
a263 3
			if ($2 < MIN_HOLDTIME ||
			    $2 > MAX_HOLDTIME) {
				yyerror("hello holdtime out of range (%d-%d)",
d281 2
a282 3
			if ($2 < MIN_HOLDTIME ||
			    $2 > MAX_HOLDTIME) {
				yyerror("hello holdtime out of range (%d-%d)",
a285 1
			conf->thello_holdtime = $2;
a294 1
			conf->thello_interval = $2;
d351 1
a351 2
				yyerror(
				    "error parsing neighbor address");
a384 1
			LIST_INSERT_HEAD(&l2vpn->pw_list, pw, entry);
d398 1
a398 1
				yyerror("missing pseudowore neighbor");
d401 2
a402 3

			LIST_FOREACH(l, &conf->l2vpn_list, entry)
				LIST_FOREACH(p, &l->pw_list, entry)
d410 2
d414 1
a415 1
			pw = NULL;
a498 1
			LIST_INSERT_HEAD(&l2vpn->if_list, lif, entry);
d519 1
a522 8
			if (iface->if_type == IFT_LOOP ||
			    iface->if_type == IFT_CARP ||
			    iface->if_type == IFT_MPLSTUNNEL) {
				yyerror("unsupported interface type on "
				    "interface %s", iface->name);
				YYERROR;
			}
			LIST_INSERT_HEAD(&conf->iface_list, iface, entry);
a529 1

d547 2
a548 2
				yyerror(
				    "error parsing neighbor address");
d554 1
a554 1
				yyerror("invalid neighbor address");
a561 3
			tnbr->flags |= F_TNBR_CONFIGURED;
			LIST_INSERT_HEAD(&conf->tnbr_list, tnbr, entry);

a567 1

d585 1
a585 2
				yyerror(
				    "error parsing neighbor address");
a597 1
			LIST_INSERT_HEAD(&conf->nbrp_list, nbrp, entry);
a616 1
			LIST_INSERT_HEAD(&conf->l2vpn_list, l2vpn, entry);
a1024 1
	memset(&globaldefs, 0, sizeof(globaldefs));
d1070 1
a1070 1
	if (conf->rtr_id.s_addr == 0)
d1165 8
d1174 1
a1174 1

d1191 2
a1192 1

d1210 1
a1210 1

d1225 1
a1225 1

d1234 1
d1251 3
a1253 1
	return (l2vpn_if_new(l, kif));
d1260 1
d1270 3
a1272 1
	return (l2vpn_pw_new(l, kif));
@


1.47
log
@Don't create l2vpn targeted neighbors inside the config parser.

When removing a configured pseudowire, we remove the associated tnbr
in ldpe_l2vpn_pw_exit(). So, when a new pseudowire is configured, it
makes sense to create its tnbr in ldpe_l2vpn_pw_init() to keep things
consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.46 2016/05/23 18:31:12 renato Exp $ */
d1333 4
a1336 2
	if (getifaddrs(&ifap) == -1)
		fatal("getifaddrs");
a1349 3

	if (ip == 0)
		fatal("router-id is 0.0.0.0");
@


1.46
log
@Fix bugs in pseudowire parameters negotiation.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.45 2016/05/23 18:28:22 renato Exp $ */
a354 1
			struct tnbr	*t;
d363 4
a368 8

			t = tnbr_find(conf, addr);
			if (t == NULL) {
				t = tnbr_new(conf, addr);
				LIST_INSERT_HEAD(&conf->tnbr_list, t, entry);
			}

			t->pw_count++;
d1200 1
a1200 1
	if (t && (t->flags & F_TNBR_CONFIGURED)) {
@


1.45
log
@Copy structs by assignment instead of memcpy.

Copying by straight assignment is shorter, easier to read and has a
higher level of abstraction. We'll only avoid it when copying from an
unaligned source (e.g., network buffers).

In addition, copy in_addr structs directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.44 2016/05/23 17:43:42 renato Exp $ */
d330 1
a330 1
			if ($2 == 1) {
d332 1
a332 2
				defs->pwflags |= F_PW_STATUSTLV;
			} else {
a333 2
				defs->pwflags &= ~F_PW_STATUSTLV;
			}
d336 1
a336 1
			if ($2 == 1) {
d338 1
a338 2
				defs->pwflags |= F_PW_CWORD;
			} else {
a339 2
				defs->pwflags &= ~F_PW_CWORD;
			}
d1061 1
a1061 4
	defs->pwflags |= F_PW_STATUSTLV_CONF;
	defs->pwflags |= F_PW_STATUSTLV;
	defs->pwflags |= F_PW_CWORD_CONF;
	defs->pwflags |= F_PW_CWORD;
@


1.44
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d405 1
a405 1
			memcpy(&pwdefs, defs, sizeof(pwdefs));
d550 1
a550 1
			memcpy(&ifacedefs, defs, sizeof(ifacedefs));
d592 1
a592 1
			memcpy(&tnbrdefs, defs, sizeof(tnbrdefs));
d1111 1
a1111 1
		conf->trans_addr.s_addr = conf->rtr_id.s_addr;
d1384 1
a1384 1
	addr->s_addr = ina.s_addr;
@


1.43
log
@Rework L2VPN code.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.42 2016/05/23 16:39:47 renato Exp $ */
d83 1
a83 1
u_int32_t	 get_rtr_id(void);
d96 5
a100 5
	u_int16_t	lhello_holdtime;
	u_int16_t	lhello_interval;
	u_int16_t	thello_holdtime;
	u_int16_t	thello_interval;
	u_int8_t	pwflags;
d126 1
a126 1
%token	INTERFACE TNEIGHBOR ROUTERID FIBUPDATE
d200 1
a200 1
			if (conf->opts & LDPD_OPT_VERBOSE)
d223 1
a223 1
				conf->flags |= LDPD_FLAG_NO_FIB_UPDATE;
d225 1
a225 1
				conf->flags &= ~LDPD_FLAG_NO_FIB_UPDATE;
d229 1
a229 1
				conf->flags &= ~LDPD_FLAG_TH_ACCEPT;
d231 7
a237 1
				conf->flags |= LDPD_FLAG_TH_ACCEPT;
d703 1
d742 4
a745 4
u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;
d837 4
a840 4
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;
d1051 1
a1051 1
parse_config(char *filename, int opts)
d1056 1
a1056 2
		fatal("parse_config");
	conf->opts = opts;
d1059 1
a1059 1
	bzero(&globaldefs, sizeof(globaldefs));
d1072 2
a1073 1
	if ((file = pushfile(filename, !(conf->opts & LDPD_OPT_NOACTION))) == NULL) {
a1079 1
	LIST_INIT(&conf->addr_list);
d1091 1
a1091 1
		if ((conf->opts & LDPD_OPT_VERBOSE2) && !sym->used)
a1189 10
int
bad_ip_addr(struct in_addr addr)
{
	u_int32_t a = ntohl(addr.s_addr);

	return (((a >> IN_CLASSA_NSHIFT) == 0)
	    || ((a >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET)
	    || IN_MULTICAST(a) || IN_BADCLASS(a));
}

d1339 1
a1339 1
u_int32_t
d1343 1
a1343 1
	u_int32_t		 ip = 0, cur, localnet;
d1375 1
a1375 1
	bzero(&ina, sizeof(struct in_addr));
@


1.42
log
@clear_config() should only deallocate memory and nothing else.

clear_config() is called when the parser fails (at startup or config
reload). While cleaning up the allocated memory, the parser should not
log anything, after all the daemon's running configuration is untouched.
So, in this case, we se should clear the partial config by hand and
avoid functions like if_del().
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2016/05/23 16:35:37 renato Exp $ */
d365 1
a365 1
			pw->addr.s_addr = addr.s_addr;
d410 1
a410 1
			if (pw->addr.s_addr == INADDR_ANY) {
d419 1
a419 1
					    pw->addr.s_addr == p->addr.s_addr) {
@


1.41
log
@Do not accept incomplete pseudowires in the configuration.

There's no point on keeping in the config something that can not be used,
it just adds unnecessary complexity. Also, it's better to warn the user
that there's something wrong rather than play nice and ignore the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2016/05/23 16:20:59 renato Exp $ */
d1314 1
a1314 1
		if_del(i);
d1319 1
a1319 1
		tnbr_del(t);
@


1.40
log
@Standardize some log messages and fix some inconsistencies.

We were using several different names for the same thing in our log
messages: neighbor, neighbor ID, nbr ID and LSR ID.

Standardize to always use "lsr-id" to refer to a neighbor.

Also:
* Use log_warnx() instead of log_warn() when appropriate;
* Use fatal(x) instead of err(x) when appropriate;
* Fix some inconsistent log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.39 2016/05/23 16:18:51 renato Exp $ */
d404 10
@


1.39
log
@Make neighbor parameters per lsr-id not per transport-address.

With the advent of IPv6 support, a single neighbor can have two different
transport-addresses: one for ipv4 and one for ipv6. In order to define
neighbor-specific parameters in an indistinguishable way, define them
by lsr-id. This way we can switch between LDPov4 and LDPov6 and keep
the same configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2016/05/23 16:14:36 renato Exp $ */
d992 1
a992 1
		log_warn("malloc");
@


1.38
log
@More renaming.

Rename a few more things to improve readability.

* s/F_PW_CONTROLWORD_CONF/F_PW_CWORD_CONF/ (shorter)
* s/F_PW_CONTROLWORD/F_PW_CWORD/ (shorter)
* s/LDPD_FLAG_*/F_LDPD_*/ (consistency)
* s/lde_nbr_address/lde_addr/ (shorter)
* s/ldp_discovery_socket/ldp_disc_socket/ (shorter)
* s/ldp_ediscovery_socket/ldp_edisc_socket/ (shorter)
* s/ldp_sendboth/main_imsg_compose_both/ (consistency)
* s/cons/total/ (makes more sense)
* s/kaddr/ka/ (consistency with remaining code)
* Always use 'ln' for lde_nbrs (consistency)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2016/05/23 16:08:18 renato Exp $ */
d1220 1
a1220 1
conf_get_nbrp(struct in_addr addr)
d1225 1
a1225 1
		if (n->addr.s_addr == addr.s_addr) {
d1227 1
a1227 1
			    inet_ntoa(addr));
d1232 1
a1232 1
	n = nbr_params_new(addr);
@


1.37
log
@Several improvements in the parsing of UDP/Hello packets.

* Fix check of the packet's size and the "PDU Length" field;
* Add check for the "Message Length" field;
* Check for invalid labelspace earlier.
* Use if_lookup() on disc_recv_iface() to reduce one level of identation;

Additionally, add the following safeguards:
* Check for unicast link hellos;
* Check for multicast targeted hellos;
* Validate packet's source address;
* Validate received transport-address.

Put the ancillary function bad_ip_addr() into a new file, util.c, which
will be used later for several other things.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.36 2016/05/23 15:43:11 renato Exp $ */
d334 2
a335 2
				defs->pwflags |= F_PW_CONTROLWORD_CONF;
				defs->pwflags |= F_PW_CONTROLWORD;
d337 2
a338 2
				defs->pwflags &= ~F_PW_CONTROLWORD_CONF;
				defs->pwflags &= ~F_PW_CONTROLWORD;
d1053 2
a1054 2
	defs->pwflags |= F_PW_CONTROLWORD_CONF;
	defs->pwflags |= F_PW_CONTROLWORD;
@


1.36
log
@Add knob to configure the transport address.

This will be especially important when we add support for IPv6, because
we'll not be able to use the router-id as the transport-address in
this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2016/05/23 15:41:04 renato Exp $ */
a107 2

int			 bad_ip_addr(struct in_addr);
@


1.35
log
@Allow setting the session holdtime per neighbor.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2016/05/23 15:32:48 renato Exp $ */
d132 1
a132 1
%token	KEEPALIVE
d243 12
d709 1
d1096 2
@


1.34
log
@Add support for including additional configuration files.

Pulled from ospfd. Original author: dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2016/05/23 15:30:43 renato Exp $ */
d236 1
a236 2
			if ($2 < MIN_KEEPALIVE ||
			    $2 > MAX_KEEPALIVE) {
d289 10
a298 1
nbr_opts	: PASSWORD STRING {
@


1.33
log
@Fix router-id selection if static router-id is not given.

First convert IP addresses to host byte-order before checking which one
is smaller. Additionally fix the check to find the lowest configured IP
as suggested by the RFC.

Pulled from ospfd. Original author: claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2016/05/23 15:28:39 renato Exp $ */
d139 1
d151 1
d162 15
d670 1
@


1.32
log
@Bring in the findeol() fix from pfctl.

Pulled from ospfd. Original author: henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2015/09/27 17:30:38 stsp Exp $ */
d1313 1
a1313 1
		if (cur > ip || ip == 0)
@


1.31
log
@As done for bgpd recently, rename if_mediatype to if_type in ldpd.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2015/07/21 04:56:44 renato Exp $ */
a762 1
	pushback_index = 0;
d766 4
a769 1
		c = lgetc(0);
@


1.30
log
@Validate ip addresses on configuration.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2015/07/21 04:52:29 renato Exp $ */
d353 1
a353 1
			if (kif->media_type != IFT_MPLSTUNNEL) {
d425 1
a425 1
			if (kif->media_type != IFT_BRIDGE) {
d455 3
a457 3
			if (kif->media_type == IFT_BRIDGE
			    || kif->media_type == IFT_LOOP
			    || kif->media_type == IFT_CARP) {
d490 3
a492 3
			if (iface->media_type == IFT_LOOP ||
			    iface->media_type == IFT_CARP ||
			    iface->media_type == IFT_MPLSTUNNEL) {
@


1.29
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2015/07/21 04:45:21 renato Exp $ */
d109 2
d201 4
d529 4
d571 4
d1131 10
@


1.28
log
@Reuse merge_config() logic to simplify the shutdown of each process.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2015/07/21 04:40:56 renato Exp $ */
d44 1
d92 2
d100 1
d106 1
d112 3
d132 3
d141 2
d154 1
d175 7
d282 183
d485 2
a486 1
			    iface->media_type == IFT_CARP) {
d580 20
d634 4
a637 1
		{"external-tag",		EXTTAG},
d641 1
d644 1
d648 3
d652 1
d657 2
d998 4
d1013 1
d1142 5
a1146 6
	LIST_FOREACH(t, &conf->tnbr_list, entry) {
		if (t->addr.s_addr == addr.s_addr) {
			yyerror("targeted neighbor %s already configured",
			    inet_ntoa(addr));
			return (NULL);
		}
d1172 55
d1233 3
d1250 13
@


1.27
log
@Assorted fixes and code cleanup for targeted neighbors.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2015/07/19 21:04:38 renato Exp $ */
d935 3
a937 1
	struct iface	*i;
d939 1
a939 1
	while ((i = LIST_FIRST(&conf->iface_list)) != NULL) {
d942 10
@


1.26
log
@Add missing LIST_INIT's.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2015/07/19 21:01:56 renato Exp $ */
d203 1
d322 2
d909 1
a909 1
	t = tnbr_new(conf, addr, 1);
@


1.25
log
@Implement md5 authentication support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2015/07/19 20:50:03 renato Exp $ */
d765 5
@


1.24
log
@Remove incomplete support for unnecessary modes of  operation.

LDP has several modes of operation, it was designed in that way so it
could run on legacy equipment like ATM/FR switches with very strict
memory limitations.

For modern hardware there's no point on using either the "Conservative
Label Retention" or "Downstream On Demand" modes of operation since they
save memory at cost of blackholing traffic when routing changes. Major
vendors implement only the "Liberal Label Retention" and "Downstream
Unsolicited" modes for non ATM/FR hardware. Let's do that too.

As for using either "Independent Control" or "Ordered Control", let's
stick with the first option mainly because it's easier to implement
and because it doesn't really matter which control mode is used. For
reference, Cisco implements only "Independent Control" and Juniper only
"Ordered Control". Both modes are interoperable.

The point of supporting only one combination of all modes of operation
is that it will allow for the writing of a simpler code without removing
useful functionality.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2014/11/20 05:51:20 jsg Exp $ */
d88 3
a90 2
struct iface	*iface = NULL;
struct tnbr	*tnbr = NULL;
d104 3
a106 2
struct iface	*conf_get_if(struct kif *);
struct tnbr	*conf_get_tnbr(struct in_addr);
d123 1
d140 1
d245 15
d343 29
d412 1
d414 1
d904 18
@


1.23
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2014/11/14 03:20:37 doug Exp $ */
a120 1
%token	DISTRIBUTION RETENTION ADVERTISEMENT
a180 42
		| DISTRIBUTION STRING {
			conf->mode &= ~(MODE_DIST_INDEPENDENT |
			    MODE_DIST_ORDERED);

			if (!strcmp($2, "independent"))
				conf->mode |= MODE_DIST_INDEPENDENT;
			else if (!strcmp($2, "ordered"))
				conf->mode |= MODE_DIST_ORDERED;
			else {
				yyerror("unknown distribution type");
				free($2);
				YYERROR;
			}
		}
		| RETENTION STRING {
			conf->mode &= ~(MODE_RET_CONSERVATIVE |
			    MODE_RET_LIBERAL);

			if (!strcmp($2, "conservative"))
				conf->mode |= MODE_RET_CONSERVATIVE;
			else if (!strcmp($2, "liberal"))
				conf->mode |= MODE_RET_LIBERAL;
			else {
				yyerror("unknown retention type");
				free($2);
				YYERROR;
			}
		}
		| ADVERTISEMENT STRING {
			conf->mode &= ~(MODE_ADV_ONDEMAND |
			    MODE_ADV_UNSOLICITED);

			if (!strcmp($2, "ondemand"))
				conf->mode |= MODE_ADV_ONDEMAND;
			else if (!strcmp($2, "unsolicited"))
				conf->mode |= MODE_ADV_UNSOLICITED;
			else {
				yyerror("unknown retention type");
				free($2);
				YYERROR;
			}
		}
a357 2
		{"advertisement",		ADVERTISEMENT},
		{"distribution",		DISTRIBUTION},
a364 1
		{"retention",			RETENTION},
a708 3

	conf->mode = (MODE_DIST_INDEPENDENT | MODE_RET_LIBERAL |
	    MODE_ADV_UNSOLICITED);
@


1.22
log
@Add gcc printf format attributes to yyerror() in parse.y files.
No yyerror() calls needed to be changed.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2014/11/03 18:44:36 bluhm Exp $ */
d588 3
@


1.21
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2014/01/22 00:21:16 henning Exp $ */
d60 3
a62 1
int		 yyerror(const char *, ...);
@


1.20
log
@relax the cfg file secrecy check slightly to allow group readability
default permissions and mtree NOT changed.
prodded by benno, ok phessler benno jmatthew theo pelikan florian
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2013/10/15 20:13:47 renato Exp $ */
d376 1
a376 1
	char		*nfmt;
d380 2
a381 3
	if (asprintf(&nfmt, "%s:%d: %s", file->name, yylval.lineno, fmt) == -1)
		fatalx("yyerror asprintf");
	vlog(LOG_CRIT, nfmt, ap);
d383 2
a384 1
	free(nfmt);
@


1.19
log
@use u_char for buffers in yylex, for ctype calls
found by millert@@, ok deraadt@@
@
text
@d678 2
a679 2
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		log_warnx("%s: group/world readable/writeable", fname);
@


1.18
log
@Since a targeted neighbor can be created both by configuration and
on runtime, the ldpd_conf structure used should be passed as an
argument to avoid segfaults.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2013/06/04 02:25:28 claudio Exp $ */
d429 1
a429 1
char	*parsebuf;
d431 1
a431 1
char	 pushback_buffer[MAXPUSHBACK];
d522 2
a523 2
	char	 buf[8096];
	char	*p, *val;
d546 1
a546 1
				*p++ = (char)c;
d591 1
a591 1
			*p++ = (char)c;
@


1.17
log
@Implement support for adjacencies and targeted hellos
Refactor adjacencies out of the neighbor handling so that it is possible to
have more complex topologies with targeted sessions.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2013/06/03 16:58:14 claudio Exp $ */
d895 1
a895 1
	t = tnbr_new(addr, 1);
@


1.16
log
@Fix bug in the fib-update command
The "fib-update" directive wasn't accepting "no" as an option.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2013/06/03 16:53:49 claudio Exp $ */
d87 1
d90 4
a93 2
	u_int16_t	holdtime;
	u_int16_t	hello_interval;
d98 1
d102 1
d114 5
a118 2
%token	INTERFACE ROUTERID FIBUPDATE
%token	HOLDTIME HELLOINTERVAL KEEPALIVE
a120 1
%token	HELLOINTERVAL
d135 1
d222 6
d237 2
a238 1
		| defaults
d240 1
a240 1
defaults	: HOLDTIME NUMBER {
d243 1
a243 1
				yyerror("holdtime out of range (%d-%d)",
d247 1
a247 1
			defs->holdtime = $2;
d249 1
a249 1
		| HELLOINTERVAL NUMBER {
d256 23
a278 1
			defs->hello_interval = $2;
d312 2
a313 2
			iface->holdtime = defs->holdtime;
			iface->hello_interval = defs->hello_interval;
d325 38
a362 2
interfaceopts_l	: interfaceopts_l defaults nl
		| defaults optnl
d399 16
a414 12
		{"advertisement",	ADVERTISEMENT},
		{"distribution",	DISTRIBUTION},
		{"external-tag",	EXTTAG},
		{"fib-update",		FIBUPDATE},
		{"hello-interval",	HELLOINTERVAL},
		{"holdtime",		HOLDTIME},
		{"interface",		INTERFACE},
		{"keepalive",		KEEPALIVE},
		{"no",			NO},
		{"retention",		RETENTION},
		{"router-id",		ROUTERID},
		{"yes",			YES}
d744 6
a749 2
	defs->holdtime = DEFAULT_HOLDTIME;
	defs->hello_interval = DEFAULT_HELLO_INTERVAL;
d880 18
@


1.15
log
@Implement support for multiple addresses per interface.
This replaces the way addresses and interface are chained together.
In ospfd there was a 1 to 1 mapping (with iface clones) but LDP does
not have that limitation.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2013/06/01 19:28:55 claudio Exp $ */
d334 1
@


1.14
log
@The keepalive timeout should be configured on a global basis and not per
interface.
Remove the iface pointer from the 'nbr' structure because it's not
needed anymore.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2013/06/01 18:47:07 claudio Exp $ */
d97 1
a97 1
struct iface	*conf_get_if(struct kif *, struct kif_addr *);
a253 15
			struct kif_addr	*ka = NULL;
			char		*s;
			struct in_addr	 addr;

			s = strchr($2, ':');
			if (s) {
				*s++ = '\0';
				if (inet_aton(s, &addr) == 0) {
					yyerror(
					    "error parsing interface address");
					free($2);
					YYERROR;
				}
			} else
				addr.s_addr = 0;
d255 1
a255 1
			if ((kif = kif_findname($2, addr, &ka)) == NULL) {
a259 9
			if (ka == NULL) {
				if (s)
					yyerror("address %s not configured on "
					    "interface %s", s, $2);
				else
					yyerror("unnumbered interface %s", $2);
				free($2);
				YYERROR;
			}
d261 1
a261 1
			iface = conf_get_if(kif, ka);
d783 1
a783 1
conf_get_if(struct kif *kif, struct kif_addr *ka)
d788 1
a788 2
		if (i->ifindex == kif->ifindex &&
		    i->addr.s_addr == ka->addr.s_addr) {
d795 1
a795 1
	i = if_new(kif, ka);
@


1.13
log
@Drop support for per-interface labelspaces.
Support for per-interface labelspaces is only necessary for legacy ATM/FR
interfaces running in cell-mode. We shouldn't worry about this.
For platform-wide label spaces the label space id is always 0.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2013/06/01 18:35:02 claudio Exp $ */
a89 1
	u_int16_t	keepalive;
a90 1
	u_int8_t	mode;
d214 9
a233 9
		| KEEPALIVE NUMBER {
			if ($2 < MIN_KEEPALIVE ||
			    $2 > MAX_KEEPALIVE) {
				yyerror("keepalive out of range (%d-%d)",
				    MIN_KEEPALIVE, MAX_KEEPALIVE);
				YYERROR;
			}
			defs->keepalive = $2;
		}
a299 1
			iface->keepalive = defs->keepalive;
d686 1
a690 1
	defs->keepalive = DEFAULT_KEEPALIVE;
@


1.12
log
@Drop support for passive interfaces.
Support for passive interfaces was inherited from ospfd but it doesn't
make any sense at all for ldpd.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2013/06/01 18:30:32 claudio Exp $ */
a95 1
struct config_defaults	 lspacedefs;
d111 1
a111 1
%token	LSPACE INTERFACE ROUTERID FIBUPDATE
a360 1
		{"labelspace",		LSPACE},
@


1.11
log
@A bit nicer error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2013/06/01 18:26:40 claudio Exp $ */
d115 1
a115 1
%token	EXTTAG PASSIVE
d316 2
a317 6
interfaceopts_l	: interfaceopts_l interfaceoptsl nl
		| interfaceoptsl optnl
		;

interfaceoptsl	: PASSIVE		{ iface->passive = 1; }
		| defaults
a362 1
		{"passive",		PASSIVE},
@


1.10
log
@Don't allow enabling LDP on loopback and carp interfaces.
LDP should be allowed only on physical or tunnel interfaces.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2013/05/30 15:44:37 claudio Exp $ */
d293 2
a294 2
				yyerror("unsupported interface type %s",
				    iface->name);
@


1.9
log
@Do not use a carp address as ldp router id because it is not unique.
Pulled from ospfd.
Diff from Renato Westphal [renatowestphal at gmail.com]
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2013/03/06 21:42:40 sthen Exp $ */
d35 1
d291 6
@


1.8
log
@as done in ospf{,6}d/relayd, sync yyerror in various other daemons with
that from bgpd, so that it logs to syslog when daemonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2010/09/01 13:54:54 claudio Exp $ */
d853 2
@


1.7
log
@s/lfib/fib/ for more consitency with the other routing daemons.
This started manly because of ldpctl beeing inconsistent and me misstyping
lfib almost every time.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2010/08/03 18:42:40 henning Exp $ */
d39 1
d327 2
a328 1
	va_list	ap;
d332 3
a334 3
	fprintf(stderr, "%s:%d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
d336 1
@


1.6
log
@fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432
applied to all the others by yours truly. ok theo
isn't it amazing how far this parser (and more) spread?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2010/06/21 19:41:44 claudio Exp $ */
d110 1
a110 1
%token	LSPACE INTERFACE ROUTERID LFIBUPDATE
d167 1
a167 1
		| LFIBUPDATE yesno {
d169 1
a169 1
				conf->flags |= LDPD_FLAG_NO_LFIB_UPDATE;
d171 1
a171 1
				conf->flags &= ~LDPD_FLAG_NO_LFIB_UPDATE;
d351 1
a356 1
		{"lfib-update",		LFIBUPDATE},
@


1.5
log
@Requiring { } blocks for interfaces is dumb since most don't need any
additional options.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2010/05/25 13:29:45 claudio Exp $ */
d524 2
a525 1
				else if (next == '\n')
d527 1
a527 1
				else
@


1.4
log
@Remove another leftover from ospfd. ldpd does not have a concept of ext_tag
and so there is no need to carry ext_tag and rtlabels around.
"Yes! kill kill kill" michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2010/02/18 15:25:28 michele Exp $ */
d305 1
@


1.3
log
@Set the correct defaults for label advertisement, retention and distribution.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2010/02/16 08:02:21 michele Exp $ */
d110 1
a110 1
%token	LSPACE INTERFACE ROUTERID LFIBUPDATE RTLABEL
a214 9
		| RTLABEL STRING EXTTAG NUMBER {
			if ($4 < 0 || $4 > UINT_MAX) {
				yyerror("invalid external route tag");
				free($2);
				YYERROR;
			}
			rtlabel_tag(rtlabel_name2id($2), $4);
			free($2);
		}
a358 1
		{"rtlabel",		RTLABEL},
@


1.2
log
@Plug a memory leak in pushfile().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d700 2
a701 1
	defs->mode = (MODE_DIST_INDEPENDENT | MODE_RET_LIBERAL |
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d644 1
a644 2
	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
d646 5
@

